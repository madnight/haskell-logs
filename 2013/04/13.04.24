00:16:09 <Ghoul_> Interesting
00:16:34 <Ghoul_> I don't see any occurrences of " ", whiteSpace, etc in the buildExpressionParser function
00:16:38 <Ghoul_> But I don't really understand it
00:18:12 <tikhonjelvis> It just combines a bunch of different parsers into a single one that produces some sort of expression
00:18:25 <tikhonjelvis> so you would handle whitespace and the like in the parsers you pass into it
00:20:25 <Ghoul_> tikhonjelvis: the problem was that it was't doing things like this correctly:
00:20:38 <Ghoul_> x = 5+-3
00:20:52 <Ghoul_> Even if - was a prefix operator, it was giving unexpected -
00:21:00 <Ghoul_> unless x = 5+(-3) which worked fine
00:21:42 <tikhonjelvis> hmm
00:22:01 <Ghoul_> and a side effect of that was that you couldn't do this with no sapces
00:22:03 <Ghoul_> *spaces
00:22:11 <tikhonjelvis> oh, so 5+ -3 worked?
00:22:14 <Ghoul_> (something>-2)
00:22:20 <Ghoul_> Uh, lets check
00:22:35 <Ghoul_> yeah
00:22:36 <Ghoul_> it does.
00:22:41 <tikhonjelvis> hmm
00:24:43 <_emm_> Hi
00:25:36 <_emm_> Do we have anything like Python's SimpleHTTPServer on hackage? My research hasn't turned up anything of interest, so I've ended with Snap at the moment
00:26:39 <tikhonjelvis> Ghoul_: Does unary - have a higher precedence than +?
00:29:15 <fizbin> What's the easiest/most idiomatic way of turning a UArray Int Word8 into a Bytestring?
00:31:53 <tikhonjelvis> Ghoul_: I tried replicating your program with a tiny parser that only supported numbers, binary + and unary -. As long as unary - has a higher precedence than binary +, everything works including "5+-3".
00:42:25 <hpaste> burgerboy pasted “Equivalent of Eq Class” at http://hpaste.org/86452
00:42:45 <burgerboy> Hi, can you have a look at my hpaste post?
00:44:01 <tikhonjelvis> Erm, is the problem with being able to derive MyClass?
00:47:02 <_d3f> I can't install haskell-platform on my Debian (sid), because of the dependencies.
00:47:31 <burgerboy> tikhonjelvis : it gave this error :
00:47:34 <burgerboy> 10 - Syntax error in input (unexpected keyword "deriving")
00:48:03 <tikhonjelvis> Right, to get it to parse, you have to enable a language extension
00:48:11 <tikhonjelvis> StandaloneInstances, I think
00:48:36 <tikhonjelvis> or StandaloneDeriving
00:49:36 <tdammers> _d3f: how are you installing? apt? source? third-party .deb?
00:50:07 <tikhonjelvis> burgerboy: So if you put {-# LANGUAGE StandaloneDeriving #-} at the top of your file, it should parse correctly.
00:50:25 <_d3f> tdammers: apt-get
00:50:28 <tikhonjelvis> However, I think it still won't work because GHC does not know how to derive MyClass.
00:50:35 <burgerboy> let me try :)
00:51:28 <tdammers> _d3f: well, then maybe you'll have to wait a few days for sid to rearrange itself...
00:52:49 <_d3f> yeah I think so, tdammers, because I got ghc 7.6.3 and dep is << 7.4.1+ - idk why
00:53:22 <burgerboy> tikhonjelvis : I got the same error
00:54:15 <tikhonjelvis> Interesting
00:54:28 <tikhonjelvis> I was expecting something like "Can't make a derived instance of `MyClass Char': ..."
00:54:55 <tikhonjelvis> or, in your case, "Can't make a derived instance of `MyClass ()': ..."
00:54:56 <burgerboy> I don't get that error with ghci at all, just with hugs
00:55:04 <tikhonjelvis> oh, you're using Hugs?
00:55:11 <burgerboy> yeah
00:55:12 <tikhonjelvis> umm
00:55:14 <tikhonjelvis> why?
00:55:28 <burgerboy> I have to
00:55:34 <tdammers> _d3f: I run testing precisely because of these issues
00:55:41 <tikhonjelvis> oh
00:55:42 <tikhonjelvis> hmm
00:56:08 <tikhonjelvis> I think StandaloneDeriving might be GHC-only
00:56:11 <tdammers> _d3f: sid is intended for debian developers; it is sometimes broken, semi-intentionally
00:56:16 <burgerboy> Can I ask something else?
00:56:17 <tikhonjelvis> where did you get the code from originally?
00:56:35 <burgerboy> here : http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Classes.html#Eq
00:57:13 <tikhonjelvis> burgerboy: Yeah, I think that's full of GHC-specific magic
00:57:39 <burgerboy> okey, with ghci, I get this error :
00:57:44 <tikhonjelvis> it really isn't the best file to look at because it has to deal with some internals of the compiler
00:57:49 <_d3f> tdammers, yeah plus you are close to forced to use experimental pkgs too.
00:58:26 <burgerboy> tikhonjelvis : Do you know somewhere else that I could find a better code?
00:58:37 <tikhonjelvis> that depends on exactly what you want to do
00:59:03 <burgerboy> I want a class that what Eq does, only it should have a name that I Want
00:59:17 <tikhonjelvis> ah
00:59:34 <tikhonjelvis> getting the deriving mechanism to work with a custom class is not easy
00:59:38 <tikhonjelvis> I have no idea of how to do it myself
00:59:59 <tikhonjelvis> apart from that, everything else is fairly straightforward
01:00:58 <burgerboy> anyway with ghci, I get this error : 54:35: parse error on input `#'
01:01:07 <tikhonjelvis> Right
01:01:12 <tikhonjelvis> the # stuff is another extension
01:01:27 <tikhonjelvis> it's for dealing with the primitive representation of numbers
01:01:48 <tikhonjelvis> so it's tied to the compiler internals
01:02:03 <burgerboy> is it a big deal if I just remove them?
01:02:31 <tikhonjelvis> hmm
01:02:35 <tikhonjelvis> I doubt the code would work then
01:02:47 <tikhonjelvis> basically, this part of the code is defining how to compare numbers for equality
01:02:48 <burgerboy> yeah it doesn't :D
01:03:11 <tikhonjelvis> it has to unbox numbers and use a built-in function like ==# to do it
01:03:58 <tikhonjelvis> essentially, much of this code wraps a bunch of different primitive operations into the == and /= functions
01:04:08 <tikhonjelvis> which lets those particular functions just be normal Haskell functions
01:04:21 <tikhonjelvis> with all the magic hidden away into things called foo# (or ==# in this case)
01:04:38 <tikhonjelvis> the # basically signifies magical things built into the compiler (more or less)
01:04:57 * hackagebot lifted-base 0.2.0.4 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.0.4 (BasVanDijk)
01:05:55 <tikhonjelvis> I think trying to replicate the Eq class is not the best idea, simply because of how closely it has to be tied to fairly low-level implementation details
01:06:46 <tikhonjelvis> anyhow, I have to go, but have fun with your Haskell exploration
01:06:50 <burgerboy> tikhonjekvis : actually, I have to overload Eq class for a specific data type, I couldn't find a way to do it, so I'm trying this.
01:08:19 <quchen> I'm not so sure implementing Eq yourself would have different performance.
01:10:05 <Ralith> Eq is tied to what now?
01:10:13 <Ralith> not that reimplementing things is useful in general
01:11:23 <burgerboy> Ralith : I didn't understand your question
01:37:24 <lbch> Hello.
01:40:01 * hackagebot TCache 0.10.0.6 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.6 (AlbertoCorona)
02:00:01 * hackagebot shakespeare-css 1.0.4 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.4 (MichaelSnoyman)
02:45:02 * hackagebot hmemdb 0.2.0.4 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.2.0.4 (MiguelMitrofanov)
02:52:32 <aleator> A quick code golf: What is the snappiest way to read line from terminal until an empty line?
02:53:36 <Kinnison> (takewhile (not . null)) <$> getContents
02:53:37 <merijn> aleator: I would guess either a manual recursion or something from monad-loops?
02:53:37 <Kinnison> ?
02:53:45 <shachaf> Kinnison: What?
02:53:45 <donri> aleator: getLine?
02:53:50 <Kinnison> shachaf: I'm guessing
02:53:57 <Kinnison> shachaf: and undercaffeinated
02:54:00 <aleator> Kinnison: That closes stdin.
02:54:02 <donri> aleator: or readLine if you want to 'read'  the result
02:54:03 <merijn> :t getContents
02:54:04 <lambdabot> IO String
02:54:15 <Kinnison> bah
02:54:17 <merijn> Kinnison: Proably needs a lines in there
02:54:18 <shachaf> It doesn't typecheck.
02:54:21 <Kinnison> mmm yes
02:54:32 <Kinnison> For some reason I had in my head getContents :: IO [String]
02:54:42 <donri> oh it's readLn, haha consistency
02:54:43 <merijn> :t takeWhile (not . null) . lines <$> getContents
02:54:45 <lambdabot> IO [[Char]]
02:54:53 <shachaf> That's still wrong.
02:54:57 <merijn> shachaf: Probably
02:55:04 <shachaf> Admittedly aleator should've given a reference implementation.
02:55:29 <merijn> I would use either of my suggestions, check out monad-loops or just manually recurse
02:55:32 <donri> and i misinterpreted the question, ignore me (well you can use getLine to build it)
02:55:39 <Kinnison> :-)
02:55:44 <aleator> Reformulated, how can I make this one line (readThem = do {l <- getLine; if not (null l) then do {s <- readThem; return (l:s)} else return [l]}
02:56:02 <aleator> look nice
02:56:33 <aleator> Monad-loops would like me to stuff the results into a writer.
02:56:59 * Kinnison goes back to writing reports for work, haskell golf... way to early in the day for this
02:57:55 <donri> aleator: you could translate merijn's version to pipes :p
02:58:00 <romm> > let x = (+3) <*> (*100)
02:58:02 <lambdabot>   not an expression: `let x = (+3) <*> (*100)'
02:58:25 <donri> maybe overkill, but it would do exactly the right thing i think (short, composable and no lazy IO)
02:58:44 <t7> im trying to simulate a poker betting round with as little state as possible, anyone know a nice pattern for this? or has done this before?
02:58:45 <romm> can someone explain to me why the second type of <*> here is expected to be (a0 -> b0) -> a0
02:58:46 <aleator> donri: That isn't that crazy idea as it sounds :)
02:58:48 <merijn> unfoldWhileM (not . null) getLine :)
02:58:58 <merijn> aleator: No it doesn't
02:59:08 <merijn> Control.Monad.Loops.unfoldWhileM :)
02:59:33 <donri> aleator: getLineS >-> takeWhileD (not . null) -- or something
02:59:38 <merijn> :: Monad m => (a -> Bool) -> m a -> m [a]
03:00:22 <aleator> donri: Hmm.. Still would need me to pull the thing out of the pipe though
03:01:00 <donri> aleator: you'd probably write your program as a pipeline and run that?
03:01:29 <aleator> merijn: I missed that. Thanks!
03:01:55 <aleator> donri: I've already got logicT in here so my brain would probably sprain if I did that :)
03:03:09 <Cale> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/release-7-6-3.html -- good release notes :)
03:04:21 <aleator> Oops. I got this out of ghci, but can
03:04:30 <aleator> Oops. I got this out of ghci, but can't replicate it http://hpaste.org/86460
03:06:52 <romm> > (+3) <*> (*100)
03:06:53 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> b0
03:09:03 <mauke_tmp> > (+3) <$> (*100)
03:09:05 <lambdabot>   *Exception: show: No overloading for function
03:09:17 <mauke_tmp> > ((+3) <$> (*100)) b
03:09:18 <lambdabot>   b * 100 + 3
03:10:17 <romm> so, (<*>) :: Applicative f => f (a -> b) -> f a -> f b
03:10:17 <romm> . f here is ((->) Num) and a = b = Num, right?
03:12:58 <romm> also,  f <*> g = \x -> f x (g x) so the above should yield something like (x+3) (x*100)? why does is work if i do fmap (+) (+3) <*> (*100)?
03:15:43 <quchen> f here is  (Num a) => (->) a
03:15:47 <osa1> I can't get hdevtools working for projects with multiple files, I'm getting "error loading targets" errors when a module imports another module that is in the same folder, any ideas ?
03:15:57 <osa1> s/hdevtools/vim-hdevtools
03:16:11 <t7> urgh there is no clean way to write poker betting rules :(
03:18:04 <romm> quchen, i understand that. i don't get the behavior of <*>
03:18:49 <quchen> romm: As in why it works, or for what it's useful for?
03:19:04 <romm> the why
03:19:27 <Ralith> :t (<*>)
03:19:28 <romm> also, the "why doesn't it work" in the cases i mentioned above.
03:19:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:21:03 <quchen> The type sig in this case doesn't help much I guess
03:21:04 <romm> so the first param is something that gets 'a' and returns a func 'a -> b'
03:21:04 <quchen> @ty (<*>) `asAppliedTo` (+3)
03:21:05 <lambdabot> Num b => ((a -> b) -> a -> b) -> ((a -> b) -> a) -> (a -> b) -> b
03:22:10 <burgerboy> hi, can anyone show me a simple implementation of "hiding" keyword? I haven't found one on the internet
03:22:22 <merijn> burgerboy: You mean in imports?
03:22:38 <burgerboy> merijn : yes
03:22:39 <merijn> burgerboy: "import Control.Category hiding (id, (.))"
03:22:57 <merijn> burgerboy: That imports all things in the Control.Category module, except id and (.)
03:22:58 <eurekaignem> REGISTER eurekaignem jafnvaegi@gmail.com
03:23:18 <burgerboy> okey, thank you
03:23:23 <eurekaignem> oops.
03:23:45 <eurekaignem> ok, here goes my noob question, with caveat...
03:24:09 <eurekaignem> I am a noob, and I got some really general questions about building a website with Haskell.  Before I explain how dumb I realize that I am, please consider, any help you offer me at this early stage will save days if not weeks of work for me.  Most big failures occur because of flawed decisions early in the design stage.... that is REALLY where you can help me... even though it means you have to lower yourself to 
03:24:52 <hpaste> burgerboy pasted “import error ” at http://hpaste.org/86461
03:25:08 <burgerboy> can you tell me why I get the error in that hpaste post?
03:25:12 <quchen> eurekaignem: As long as we see you tried something yourself and aren't abusing this channel for something you could've googled in 1 minute, there are no "too basic" questions.
03:25:37 <merijn> burgerboy: I don't understand why the import is inside the class declaration?
03:26:09 <fff> Comp313 anyone?
03:26:17 <Kinnison> burgerboy: (a) imports belong at the top level, just after the module declaration (if you have one) and (b) you don't import class instances.  What are you trying to achieve?
03:26:29 <merijn> burgerboy: Are you trying to say "NetworkOp a" requires that a supports equality?
03:26:41 <Guest60729> Anyone doing comp313*
03:27:02 <quchen> Maybe ask in #comp313
03:27:09 <burgerboy> merijn : actually what I'm trying to do is to overload Eq instance with a different name (idk if it makes sense)
03:27:10 <merijn> Guest60729: Presumably yes, whether anyone here is, who knows :p
03:27:22 <merijn> burgerboy: That doesn't make sense, no
03:27:56 <merijn> burgerboy: Why do you want to do that?
03:28:21 <quchen> romm: I'm not sure what you mean with "the example above doesn't work".
03:28:42 <burgerboy> merijn : I want to have a class which checks the equality of a certain type. I can't derive Eq instance
03:29:00 <quchen> romm: But as a little spoiler, I don't think the general Applicative style is used much for functions anyway, except for religious purposes.
03:29:01 <romm> quchen, 1 sec, i'm gathering my thoughts
03:29:08 <quchen> @quote zip`ap`tail
03:29:08 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
03:29:13 <merijn> burgerboy: You can just define the class and add an Eq constraint to the class function
03:29:32 <romm> quchen, it's more of a "i need to understand exactly how this works before i proceed" kind of thing
03:30:17 <burgerboy> merijn : can you please explain what you said a little better? That's what I want to have for days but I haven't been able to do
03:30:31 <eurekaignem> I am too dumb to install Linus on my windows laptop (even DSL).  So I am programming Haskell using a Linux emulator on my laptop.   The website was started on the server using WordPress on Windows OS.  I chose to migrate to a more custom built website using Haskell.   Is it correct that I should tell the server operator to wipe our domain name clean of the Windows OS and replace with Linux?    goddesses that is an
03:30:41 <burgerboy> merijn : can you tell me how I can do it?
03:34:22 <__xc> interesting stupid fact if you do 2^32 / unixtimestamp you get something close to pi
03:35:21 <__xc> > getCurrentTime
03:35:23 <lambdabot>   Not in scope: `getCurrentTime'
03:36:04 <__xc> > 2^32 / 1366799800
03:36:14 <lambdabot>   3.1423528859164307
03:36:23 <flux> __xc, interesting and stupid indeed! the reverse unix pi time is within four days!
03:36:32 <quchen> romm: (+) <$> (+3) <*> (*10)  =  ((+) . (+3)) <*> (*10)  =  \x -> ((+) . (+3)) x (x*10)  =  \x -> ((+) (x+3)) (x*10)  =  \x -> (x+3) + (x*10)
03:36:37 <flux> THE ONLY TIME EVER, as well.
03:36:37 <quchen> Just write it out
03:36:47 <__xc> hehe
03:37:46 <romm> quchen, exactly what i was doing. i just got confused with (+) . (+3) since it's not very "math-like"
03:38:24 <romm> i think i got it, thanks
03:38:25 <quchen> romm: Using "." with functions that usually expect two parameters is often quite confusing, yes.
03:38:33 <quchen> You get this a lot when converting to point-free notation.
03:38:44 <quchen> That's usually what makes pointfree pointless
03:39:14 <romm> pun notedm 5 points.
03:39:21 <romm> *noted
03:39:47 <romm> thanks for the help
03:41:23 <quchen> romm: I wouldn't recommend taking too much time to worry about the Reader Applicative. It's something you can go back to later.
03:43:43 <romm> i see
03:46:06 <eurekaignem> Haskell/Windows OS/    Motivation for asking "can I run a Haskell program as an executable on a server Windows platform?"  is:  1). it runs, 2):  enough  work on other than the application program (HTML and JS) was accomplished that even though I want to change the application language to Haskell,  if I could justify staying on the client Windows platform it would save some weeks of work.
03:46:18 <merijn> burgerboy: You can write "class Eq a => NetworkOp a where". which means you can only make instance of "NetworkOp a" if a is also an instance of Eq
03:46:50 <eurekaignem> last 'client Windows'  should have read ' server Window's '.
03:47:01 <merijn> burgerboy: Alternatively you could do something like "class NetworkOp a where foo :: Eq a => a -> a -> Something"
03:47:24 <burgerboy> what will Something be?
03:47:33 <merijn> burgerboy: That depends on what you want the function to do
03:48:07 <burgerboy> so there should be a function implementation instead of the Something
03:48:15 <merijn> burgerboy: It's hard to give an example without knowing what NetworkOp is supposed to do
03:49:01 <burgerboy> it checks equality of 2 graphs
03:49:07 <merijn> romm: It also works wonders to look up the implementation of Applicative/Functor/Monad for "(->) a" and do the subsitutions by hand on paper
03:49:42 <merijn> Oh, wait, quchen already did that :p
03:50:30 <merijn> eurekaignem: Haskell itself works well enough on Windows, but I'm not sure whether the web frameworks have a dependency on unix or not
03:51:33 <luite> the GHC IO manager is much better on non-Windows though
03:51:57 <luite> yesod works on windows, i suspect the other frameworks do too
03:52:52 <donri> i think happstack is the only one that supports sendfile on windows ;)
03:53:30 <luite> oh i didn't know there was a sendfile for windows
03:53:34 <quchen> merijn: But even after doing that ten times it doesn't make much sense to me
03:53:45 <quchen> merijn: It works, yes, but that's all I get out of that
03:53:51 <donri> on the other hand i think sendfile in warp on linux is more optimized
03:54:47 <luite> donri: does it need two packets to send the header and the contents?
03:55:33 <merijn> quchen: I usually treat it like math
03:56:05 <luite> donri: where's the sendfile windows code in happstack?
03:56:12 <donri> @hackage sendfile
03:56:12 <lambdabot> http://hackage.haskell.org/package/sendfile
03:56:27 <merijn> Pffft, lambdabot doesn't even have the quote I was looking for
03:56:29 <donri> don't know if header is a separate packet
03:56:35 <merijn> @remember JohnVonNeumann In mathematics you don't understand things. You just get used to them.
03:56:35 <lambdabot> Nice!
03:57:06 <luite> donri: ah
03:57:29 <donri> supposedly warp and sendfile-simple use less syscalls in recent versions
03:59:20 <luite> hm, but it should be doable to add the windows sendfile code to simple-sendfile
03:59:31 <donri> sure
03:59:37 <luite> on the other hand i think no one really uses yesod on windows in production...
03:59:54 <burgerboy> merijn : "class NetworkOp a where foo :: Eq a => a -> a -> Something" does this work only for one function? can I write 2 functions inside it?
04:00:06 <donri> bit sad that the author of sendfile-simple never contacted jeremy about patching sendfile instead though :/
04:03:24 <burgerboy> merijn : class NetworkOp a where foo :: Eq a => a -> a -> Something => gave this error : Syntax error in input (unexpected keyword "where")
04:03:24 <merijn> burgerboy: You can write as many functions are you like within a class, but are you sure you need a typeclass?
04:03:56 <burgerboy> merijn : yes, I know I need a typeclass
04:05:43 <hpc> you can't add additional constraints to 'a' like that
04:06:03 <hpc> you would do class Eq a => NetworkOp a where ...
04:06:16 <hpc> (doesn't solve the syntax error though)
04:06:27 <Ralith> burgerboy: how do you know you need a typeclass?
04:07:34 <merijn> hpc: Oh, you can only constrain variables not mentioned in the class? I guess that makes sense, I wasn't sure
04:09:30 <burgerboy> my current code is like this : class NetworkOp a where foo :: Eq a => Eq (Network a) where (Graph x) == (Graph y) = equCheck (deGraph (Graph x)) (deGraph (Graph y))
04:09:38 <burgerboy> how should I change it?
04:10:21 <merijn> burgerboy: Why not "instance Eq a => Eq (NetworkOp a) where"?
04:11:01 <burgerboy> in this case, do I have to define NetworkOp class somewhere else?
04:11:31 <shachaf> That code looks familiar...
04:12:01 <burgerboy> for this : class NetworkOp a where foo :: Eq a => instance Eq a => Eq (Network a) where (Graph x) == (Graph y) = equCheck (deGraph (Graph x)) (deGraph (Graph y))
04:12:16 <burgerboy> I get this : Syntax error in type signature (unexpected keyword "instance")
04:13:17 <merijn> burgerboy: Why do you need a NetworkOp class at all?
04:13:57 <burgerboy> this is the way the teacher wants the code, he wants a NetworkOp class
04:14:49 <shachaf> You sound almost as confused as your classmate.
04:16:13 <burgerboy> we are the same person, I want burgers so I changed my nickname
04:17:16 <shachaf> Oh.
04:17:17 <burgerboy> can you tell me how can I solve this problem please? :D
04:17:38 <shachaf> No.
04:17:51 <shachaf> I don't know what the problem even is.
04:18:16 <shachaf> But I recommend reading an introduction to Haskell syntax and, if you insist on using type classes, type classes.
04:19:27 <burgerboy> I read LYAH and other things
04:19:40 <burgerboy> I can tell the problem again if you are interested
04:20:31 <shachaf> Did you read the section on type classes?
04:20:40 <merijn> Actually, I recommend asking your professor/TA for clarification on what exactly they expect from you
04:21:09 <shachaf> Yes, what merijn said. If you're the same person as before, then it seems likely that you aren't sure what's being asked.
04:21:18 <merijn> As former functional languages TA I was almost amazed by the lack of questions until an hour before the deadline "hey, I dunno what to do here, help me!"
04:21:36 * cmccann thinks there should be a rule that all Haskell homework assignments must have any use of type classes approved by shachaf before being assigned to students.
04:21:40 <merijn> To which the usualy response is "well, you've had a week to ask me, I'm busy now. Start sooner next time!"
04:22:14 <shachaf> cmccann: But that's impossible!
04:22:17 <merijn> IOW it's never to early to ask clarification, but it *might* be to late
04:22:24 <merijn> shachaf: It's not like you have anything else to do!
04:22:47 <shachaf> merijn: I mean, it's impossible that a Haskell homework assignment that has any use of type classes would be approved by me.
04:23:28 <Ralith> shachaf: perhaps that's the point
04:23:41 <jesyspa> shachaf: Huh, what's the problem with type classes?
04:23:43 <cmccann> shachaf: what about an assignment "show how this unnecessary typeclass can be refactored into a record of functions and how this simplifies the following code".
04:24:17 <shachaf> jesyspa: cmccann is just making fun of me.
04:24:21 <shachaf> I'm going along with it.
04:24:46 <cmccann> I'm more complaining about overuse of typeclasses in homework assignments for beginners, really.
04:24:56 <cmccann> making fun of shachaf is just a means to that end.
04:25:00 <shachaf> Yes, I usually complain about that.
04:25:32 <shachaf> cmccann: Is making fun of me every an end in itself?
04:25:32 <merijn> Making fun of shachaf is SOP, no? :>
04:25:59 <merijn> I love "making fun of shachaf"! They're so easy!
04:26:00 <cmccann> shachaf: no, I don't think it ever ends
04:26:58 <cmccann> seriously though, use of typeclasses when they provide no benefit is a common mistake among beginners already. we really don't need homework assignments encouraging it further.
04:27:04 <shachaf> Yep.
04:27:15 <shachaf> Or books, for that matter.
04:27:23 <cmccann> that too.
04:27:28 <shachaf> I bet your book won't encourage it further.
04:27:34 <cmccann> indeed it won't.
04:27:50 <shachaf> (because it won't every be written!!!!)
04:27:53 <shachaf> s/y//
04:27:59 <shachaf> Speaking of which, how's that book going?
04:28:33 <cmccann> shachaf: the current rash of homework problems in here and on SO is moving it up the priority list. >:[
04:28:37 * cmccann shakes his fist.
04:28:57 <Ralith> it's end of semester
04:28:58 <shachaf> Oh, we've found cmccann's weakness.
04:29:00 <jesyspa> Recently I had a case where I had a type (tree) and would sometimes like to perform a rename operation.  However, apart from simple one-to-one renaming I sometimes also wanted to perform a list of renames, or renaming an f Type with f a functor.  Is using typeclasses for this a bad idea?
04:29:00 <Ralith> it'll go back down again
04:29:09 <shachaf> Now I just need to spam SO and #haskell with awful homework assignments.
04:29:51 <shachaf> jesyspa: I don't understand what you said well enough to say yes or no.
04:29:51 <cmccann> jesyspa: the complaining here is primarily about defining dumb type classes, not using existing ones
04:30:12 <jesyspa> I defined an extra one for it. :P
04:30:21 <jesyspa> Let me make a paste.
04:31:04 <aleator> Hey, since you're at it, criticise my course material also: http://functional-programming.it.jyu.fi/TIES343/Chapters/00600_Recursion.html (It'll draw you an ugly chess board if you play with it.)
04:31:27 <merijn> I define typeclasses *all* the time and then abuse them for awful typelevel recursion \o/
04:31:43 <cmccann> man, I was just having some tea before leaving for work. I don't got time for this right now. :[
04:32:33 <merijn> jesyspa: The issue is not so much that defining typeclasses is wrong, it's just that many people tend to use typeclasses for everything as a sort of ghetto OO
04:32:50 <cmccann> yep.
04:33:04 <merijn> jesyspa: For things that could just as easily be solved by doing things like "give a dictionary of higher-order functions"
04:34:00 <cmccann> a second common mistake is making type classes with no rhyme or reason where the instances have nothing in common except a desire to overload function names. (this is not always a bad thing, but it's usually not a good thing either)
04:34:01 <hpaste> jesyspa pasted “frivolous typeclasses?” at http://hpaste.org/86465
04:34:10 <cmccann> it may be ad-hoc polymorphism but it shouldn't be THAT ad-hoc.
04:34:28 <jesyspa> Is this something I should not do?
04:35:37 <cmccann> jesyspa: there's probably a better way but I can't say what from only that paste and when I'm about to leave for work
04:35:42 <merijn> jesyspa: Needs more GADTs and phantom types :>
04:36:04 <shachaf> That paste is a syntax error anyway.
04:36:07 <cmccann> jesyspa: that's probably borderline at worst though.
04:36:08 <oberon_es> hi all
04:36:14 <shachaf> It's quite difficult to tell from that.
04:36:18 <merijn> jesyspa: It looks like you have some type of AST, but I don't understand what the use of renamble is supposed to be?
04:36:44 <cmccann> anyway I'm out
04:37:10 <jesyspa> merijn: This is from a type inference algorithm implementation; when I find that two types are actually equal, I'd like to change all instances of one to the other.
04:37:43 <jesyspa> shachaf: Sorry, the | on line 1 should have been a =
04:38:36 <merijn> In that case, I stand by my observation of "needs more GADTs" and let haskell's typechecker do the checking for you xD
04:38:48 <shachaf> It looks like you're doing overloading-for-convenience here.
04:38:57 <shachaf> I.e. you have three functions and you want to give them all the same name.
04:39:00 <jesyspa> merijn: Could you give an example, please?
04:39:03 <jesyspa> shachaf: Yeah, pretty much.
04:39:05 <shachaf> They don't have a whole lot in common other than that.
04:39:13 <shachaf> I don't like that use of type classes much.
04:39:17 <aleator> jesyspa: Also, for twisting of the brain, try the bound package for this. Does almost certainly away with the need for renamablewith ;)
04:39:54 <merijn> jesyspa: I'll make a simple paste, but note that I'm only half serious :p
04:40:19 <jesyspa> aleator: Thanks, added to my list of things to abuse. :D
04:41:28 <merijn> jesyspa: I guess you'd like something like "Function (Type a) (Type b)" to represent "a -> b"?
04:42:27 <jesyspa> merijn: Yes.
04:44:00 <hpaste> merijn annotated “frivolous typeclasses?” with “Haskell typechecked typed AST” at http://hpaste.org/86465#a86466
04:44:07 <merijn> jesyspa: You can do things like that
04:44:47 <jesyspa> Ehhh.
04:45:02 <jesyspa> So if I do Simple "foo", the type is Type a for any a?
04:45:36 <merijn> jesyspa: Yes, similar to "Nothing :: Maybe a"
04:45:47 <merijn> jesyspa: You could have "Simple :: a -> Type a" too
04:46:28 <jesyspa> I don't think a -> Type a would work particularly well, seeing as the types are all given by Strings.
04:46:33 <aleator> merijn: Custom dictates that you should now be challenged to parse that from a string ;)
04:46:37 <merijn> jesyspa: GADTs let's you annotate all constructors explicitly with types, which means you can enforce that some constructors only return a fixed type
04:46:58 <merijn> jesyspa: i.e. "IntC :: Int -> Type Int"
04:47:20 <merijn> Which means that trying to return IntC with 'Type Char' is a type error
04:47:33 <jesyspa> I see.  Hm.
04:48:05 <merijn> aleator: Sure, but if your AST is for typechecking an EDSL you don't need to parse from String
04:48:36 <merijn> jesyspa: Here's a more in-depth example using an expression type: https://en.wikibooks.org/wiki/Haskell/GADT
04:48:55 * merijn continues his slow quest to infect everyone with GADT obsession, regardless of what they're doing :>
04:50:11 * hackagebot fay 0.14.5.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.14.5.0 (AdamBergmark)
04:50:54 <merijn> jesyspa: Even if it ends up being useless for what you're doing right now, you should still read that! :p
04:51:03 * jesyspa is reading. :)
04:56:02 <beaky> helo
04:56:17 <beaky> how do Typeclasses solve the expression problem?
04:56:32 <shachaf> They don't.
04:56:39 <beaky> ah
04:56:43 <beaky> :(
04:56:44 <aleator> merijn: I also tried to gadtconvert people. Not much success but the slides turned out nice: http://functional-programming.it.jyu.fi/TIES341/slides/TypeTrickery.html
04:56:49 <beaky> I always thought they did
04:57:40 <merijn> Lunch time!
04:58:38 <beaky> are all monads also monoids?
04:58:55 <beaky> > Just 3 `mappend` Nothing
04:58:56 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:58:56 <lambdabot>    (GHC.Num.Num a0)
04:58:56 <lambdabot>      a...
04:59:14 <k00mi> shachaf: they don't? wikipedia explicitly mentions them as a solution
04:59:56 <hpaste> burgerboy pasted “module instantiate” at http://hpaste.org/86468
05:00:35 <burgerboy> can you have a look at my primitive question in the link?
05:00:54 <shachaf> k00mi: Hmm, the Wikipedia page didn't say that until the very last edit.
05:01:13 <no-n> Think all nouny. No verby.
05:01:24 <shachaf> I wonder if that edit is vandalism or something.
05:01:49 <shachaf> Probably not.
05:02:01 <k00mi> it's been there for quite a while
05:02:05 <Cale> beaky: You can solve the expression problem using them
05:02:52 <shachaf> Maybe Cale and I are thinking of different things. :-)
05:02:55 <Cale> beaky: you might be interested in this lecture http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes
05:06:51 <beaky> ah
05:18:19 <no-n> how can I check for "Justness" in a guard and assign what's inside the Just to a variable at the same time?
05:18:41 <shachaf> | Just x <- y
05:18:47 <beaky> > Just 3 `mappend` Just 4
05:18:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
05:18:49 <lambdabot>    (GHC.Num.Num a0)
05:18:49 <lambdabot>      a...
05:18:50 <shachaf> If you're sure that you want a guard.
05:18:59 <aCube> Maybe pattern matching is enough?
05:19:36 <aCube> > Just [3] `mappend` Just [4]
05:19:37 <lambdabot>   Just [3,4]
05:21:42 <gspr> Is there a nice functional data structure that is a tree (with parent access, so for example a zipper) endowed with the following: Given a node at depth i with value x, quickly obtain a list of all other nodes at depth i with value x? "Quick" here means "quicker than searching the tree"
05:24:20 <gspr> (The extra structure should also be cheap to maintain when doing tree operations such as deleting or moving subtrees)
05:28:17 <luite> http://hpaste.org/86469 <- any suggestions for making the `f' in foldForward produce more than one result depending on the node type? for example for an IfNode it would generate two pieces, one for the if branch, one for the else branch. a while node would produce one piece that flows into the loop body, and another piece later that flows out of the whole loop
05:37:43 <merijn> aleator: Your slides don't work with JS disabled :p
05:38:28 <merijn> aleator: Also, needs more DataKinds :)
05:39:08 <merijn> aleator: btw, the new GHC 7.7 lets you do easy type equality and recursion in TypeFamilies
05:52:15 <aleator> merijn: Well. Naturally they don't. The list of cases where they don't work is quite long by now :)
05:53:00 <aleator> merijn: Easy type equality? Where? Where?
05:55:58 <hpaste> merijn pasted “TypeFamily easy type equality” at http://hpaste.org/86470
05:56:09 <merijn> aleator: That works in 7.7
05:56:20 <merijn> Definitions within a where block are checked in lexical order
05:58:42 <aleator> merijn: Ah. And that nonlinear patterny thingy works just like that?
05:58:59 <aleator> Very nice
05:59:56 <merijn> That code should work as is (maybe I missed an extension, but other than that)
06:00:06 <merijn> Because that's what I'm using and tested in my own code :p
06:00:35 <merijn> You can use :kind! to evaluate the result of TypeFamily application in ghci
06:00:50 <aleator> I had a small trial of using type level lists to list specific IO cababilities that each function uses but ran out of steam with the equality.
06:02:24 <aleator> merijn: How much of everything broke when you started using ghc head?
06:02:24 <merijn> aleator: Yeah, I had the same issue
06:02:34 <merijn> aleator: I dunno, I only use it for this code
06:02:56 <merijn> aleator: I keep 7.4 in my path as default ghc and have 7.7 installed to ~/ghc
06:03:20 <merijn> When I want to use 7.7 I just have to do "export PATH=~/ghc/bin:$PATH" and it'll use 7.7
06:03:58 <aleator> I need to pretty much keep in sync two desktops and one server with the web-evaluator. Not using the same version of everything usually ends up biting me.
06:04:10 <aleator> +with
06:04:31 <merijn> Biggest downside so far is that hsdevtools doesn't recognise this syntax yet, so my vim plugin keeps reporting syntax error
06:05:22 <xplat_> heh, so now with 7.7 duplication between type-level and value-level definitions can be more obvious :)
06:05:53 <aleator> Perhaps it can go away at some point?
06:07:07 <tromp__> :t \(a,_) (_,b) -> a*b
06:07:09 <lambdabot> Num a => (a, t) -> (t1, a) -> a
06:08:18 <xplat_> aleator: well, i guess first there needs to be support for type-level guards ...
06:09:06 <xplat_> aleator: otoh, i'm not sure that's a good idea
06:09:29 <JordiGH> As what I thought would be a simple exercise, I decided to try to implement mergesort... and then I realised that I don't know how to slice or split lists! But then again, lists seem like the wrong sort of thing here, since they're lisp-like consed lists. If I was doing numerical analysis, I would like fixed-size arrays. So, (1) how do I split ordinary lists and (2) where is the fixed-size array type?
06:11:38 <aleator> JordiGH: Data.List.splitAt and Data.Vector respectively
06:12:26 <JordiGH> aleator: Thanks. I'll look at the source of the former. Also, is Data.Vector the right kind of type to implement arrays of arbitrary dimension, like Fortran arrays or C++ valarrays?
06:12:41 <xplat_> JordiGH: otoh cons-style lists are basically just what you want during a mergesort
06:13:02 <aleator> JordiGH: I think repa aims to be closer to that
06:13:03 <JordiGH> xplat_: Kinda? You still have to do some sort of list traversal just to get the size.
06:13:19 <xplat_> JordiGH: why do you need the size?
06:13:30 <aleator> You can split a list without knowing length
06:13:34 <JordiGH> xplat_: You need some sort of list traversal just to be able to know where to split it.
06:13:59 <JordiGH> I found an example where there was something like racing pointers to know where to split.
06:14:20 <JordiGH> Which seemed to me a bit.... ugly.
06:14:37 <xplat_> JordiGH: you can just split by alternating elements
06:14:50 <JordiGH> xplat_: That doesn't respect order in a way mergesort would like it.
06:16:08 <xplat_> JordiGH: why wouldn't mergesort like it?
06:16:23 <aleator> Not stable then?
06:16:41 <JordiGH> xplat_: I assume you meant the second split function suggested here: http://en.literateprograms.org/Merge_sort_%28Haskell%29#split
06:17:45 <fizbin> :t \a b -> (fst a <> fst b, snd a <> snd b)
06:17:47 <lambdabot> (Monoid t, Monoid a) => (a, t) -> (a, t) -> (a, t)
06:17:53 <JordiGH> xplat_: The first one is what I called racing pointers... it isn't really that, racing pointers are for another cute problem, finding a loop in a linked list without incurring extra memory.
06:18:02 <fizbin> @djinn (Monoid t, Monoid a) => (a, t) -> (a, t) -> (a, t)
06:18:02 <lambdabot> Error: Class not found: Monoid
06:18:52 <fizbin> :t mappend *** mappend
06:18:53 <lambdabot> (Monoid b', Monoid b) => (b, b') -> (b -> b, b' -> b')
06:21:18 <gspr> (This is a modification of a question I asked a bit earlier). Given a tree, is there a functional data structure that encodes the tree along with: 1) Easy access to parent (zippers?). 2) Given a node, obtain all other nodes with the same value at the same level?  The additional structure in point 2 should also be easy to maintain under common tree operations.
06:21:49 <xplat_> JordiGH: you can make the alternating one stable by grouping according to your key in the split pass, then you can sort them by head and re-merge
06:25:21 * hackagebot crypto-conduit 0.5.2 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.2 (FelipeLessa)
06:25:24 <xplat_> (of course there can be disadvantages to that too ...)
06:30:02 <xplat_> JordiGH: the easiest thing of course is to use a list and already know the length, then you can just use splitAt.  you can even overestimate the length and the cost is low, just don't underestimate
06:30:49 <JordiGH> xplat_: I kinda wonder why all lists don't already carry their size around with them. Also, I find myself wishing for Python-like or R-like or Octave-like or Julia-like or Perl-like list slicing.
06:31:13 <xplat_> JordiGH: lists don't always have a finite length
06:31:33 <JordiGH> xplat_: So use some special type that could be infinite.
06:31:44 <xplat_> also, sometimes the algorithm that produces a list takes as long to produce the length as the whole list
06:32:34 <xplat_> in which case you're basically making an extra length pass ahead of time.  this could even mean you have to allocate the whole list instead of using bounded memory
06:33:30 <mauke_tmp> simple list slices can be done with take/drop
06:34:16 <aCube> http://hackage.haskell.org/packages/archive/vector/latest/doc/html/Data-Vector.html#v:slice
06:34:23 <xplat_> actually if you want to have a stable, fast, local splitting pass for mergesort, you can do this
06:35:46 <xplat_> use splitAt to split into 1,1,2,4,8,16,32... . use splitAt splitting with known length to mergesort each of these chunks until you come to an empty one.  merge the remaining chunks from left to right.
06:36:51 <xplat_> should be able to fuse this together to get something local
06:37:01 <xplat_> might even happen automatically
06:37:15 <t7> i wanna chain maybes and choose the first Just
06:37:35 <geekosaur> :t catMaybes
06:37:38 <lambdabot> [Maybe a] -> [a]
06:37:51 <t7> is that cooler than some infix op?
06:37:53 <quchen> :t fromList . catMaybes
06:37:54 <lambdabot>     Not in scope: `fromList'
06:37:54 <lambdabot>     Perhaps you meant one of these:
06:37:54 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
06:38:00 <geekosaur> or, depending on exactly what you mean, it might be sequence for Maybe
06:38:07 <pxqr> is it possible to enable emacs auto-fill-mode for haddock annotations?
06:38:13 <xplat_> it might be msum for maybe
06:38:18 <xplat_> because it is
06:38:42 <fizbin> @hoogle (a -> a -> a) -> arr (a,a) (a,a)
06:38:42 <lambdabot> No results found
06:38:51 <pxqr> it's so annoying to press fill paragrapth every time
06:38:54 <fizbin> @djinn (a -> a -> a) -> arr (a,a) (a,a)
06:38:54 <lambdabot> -- f cannot be realized.
06:39:03 <fizbin> Well crud.
06:39:03 <xplat_> > msum [Nothing, Nothing, Nothing, Just "a moment", Nothing, Just "kidding"]
06:39:05 <lambdabot>   Just "a moment"
06:39:21 <fizbin> Oh, wait. No wonder that type didn't work...
06:40:51 <aCube> :t (***)
06:40:53 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:41:02 <aCube> :t join (***)
06:41:03 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
06:41:26 <parcs> hi
06:42:10 <shachaf> > lastOf (traverse._Just) [Nothing, Nothing, Nothing, Just "a moment", Nothing, Just "kidding"]
06:42:11 <lambdabot>   Just "kidding"
06:42:29 <fizbin> :t let join' (f::a->b) = join f in join'
06:42:31 <lambdabot> (a -> a -> a1) -> a -> a1
06:43:34 <fizbin> aCube: Okay, I see what that does. Except, of course, that isn't really the type I want. Now if I could only figure out the type I do want, really...
06:44:23 <fizbin> @djinn (Monad m) => (a -> m b) -> (a, a) -> m (b, b)
06:44:23 <lambdabot> -- f cannot be realized.
06:44:33 <fizbin> Oh, come on djinn.
06:44:38 <quchen> fizbin: What are you trying to accomplish, sir?
06:44:46 <supki> @ty both
06:44:48 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
06:44:57 <fizbin> Two different things, quchen.
06:45:11 <Cale> fizbin: djinn doesn't know anything about monads
06:45:22 * hackagebot Obsidian 0.0.0.5 - Embedded language for GPU Programming  http://hackage.haskell.org/package/Obsidian-0.0.0.5 (JoelSvensson)
06:45:32 <shachaf> Cale: No, djinn knows about monads. Djinn is just incompetent in this particular area.
06:45:42 <shachaf> @djinn-names
06:45:43 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool
06:45:48 <Cale> oh, interesting
06:46:12 <shachaf> @djinn Monad x => b -> x b
06:46:13 <lambdabot> -- f cannot be realized.
06:46:14 <shachaf> @djinn Monad x => a -> x a
06:46:14 <lambdabot> f = return
06:46:19 <shachaf> good type class support
06:46:25 <Cale> lol, haha
06:46:28 <Eduard_Munteanu> Wow.
06:46:29 <Cale> Makes sense
06:46:30 <fizbin> wtf, djinn.
06:46:39 <shachaf> It's not actually rank-2.
06:46:39 <elliott> shachaf: more like typoclass support am I right
06:46:41 <Cale> Djinn doesn't know how to deal with higher rank types
06:46:44 <elliott> because when you make a typo it breaks, see
06:46:48 <shachaf> It's just passing a hard-wired implicit parameter sort of thing.
06:46:48 <Cale> so it can't really support typeclasses properly
06:46:49 <shachaf> Or something.
06:46:51 <t7> > msum [ Just 1, Just 3]
06:46:54 <lambdabot>   Just 1
06:47:22 <Cale> Yeah, it's doing just rank-1 translation of typeclasses, which is fine for stuff like Eq
06:47:44 <Eduard_Munteanu> Um, what's rank for typeclasses?
06:47:49 <Cale> but garbage once you have typeclass methods which are polymorphic in additional parameters not mentioned in the typeclass head
06:48:30 <Eduard_Munteanu> You mean return is polymorphic in 'a' inside the typeclass definition?
06:48:36 <Cale> yeah
06:48:57 <xplat_> Cale: you'd think it could handle a simple replacement-based axiom schema though
06:48:58 <shachaf> This also means that the straightforward record desugaring isn't valid Haskell 2010.
06:49:19 <Cale> That is true
06:50:09 <monoidal> personally I would prefer if Haskell required to use "forall" keyword in classes, such as class Monad m where return :: forall a. a -> m a. Perhaps not everywhere, but polymorphic methods somehow deserve that IMO.
06:50:33 <Cale> Well, you can write that
06:51:15 <Cale> The convention is that any free type variable in a type signature is implicitly universally quantified at the top level of the type signature in which it occurs.
06:51:32 <xplat_> but don't you just have return :: forall m a. Monad m => a -> m a ?
06:51:49 <shachaf> It's a bit odd that type class signatures have scoped variables.
06:51:53 <monoidal> indeed. In some sense typeclass definitions have a weak form of scoped variables
06:52:40 <xplat_> it seems like that's not a higher-rank signature actually
06:53:15 <Cale> xplat_: The data constructor for the typeclass dictionary has a higher-rank type
06:53:16 <monoidal> xplat_: Once you convert it to a dictionary, it becomes higher-rank
06:53:25 <aCube> type MonadDict m = MonadDict (forall a. a -> m a)
06:53:33 <Cale> (data)
06:53:39 <aCube> yeah, right
06:53:39 <t7> better way todo this?:  concat . filter ((== 1) . length) . group
06:54:01 <elliott> nub
06:54:07 <elliott> oh, I guess that's not nub
06:54:13 <fizbin> :t first
06:54:14 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
06:54:28 <aCube> concat . filter (not . null . drop 1) . group ?
06:54:48 <hpaste> “Anonymous Coward” annotated “GADTs” with “GADTs (annotation)” at http://hpaste.org/86445#a86471
06:54:59 <xplat_> Cale: oh, djinn uses the dictionary translation instead of dealing with things directly?
06:54:59 <aCube> oops, that is not quite right. But you don't need to check for the whole list's length
06:55:28 <Cale> data Monad :: (* -> *) -> Constraint where Monad :: (Functor m) => (forall a. a -> m a) -> (forall a b. m a -> (a -> m b) -> m b) -> Monad m
06:55:44 <Cale> ;)
06:56:28 <fizbin> :t let fun = undefined :: (a -> b) in first fun
06:56:29 <lambdabot> (b, d) -> (c, d)
06:56:38 <Cale> xplat_: yes
06:57:10 <aCube> :t first `asAppliedTo` (+1)
06:57:12 <lambdabot> Num c => (c -> c) -> (c, d) -> (c, d)
06:57:13 <xplat_> Cale: couldn't it ... i dunno ... return' :: Monad m a -> a -> m a where Monad is an abstract type?
06:57:36 <monoidal> Cale: or record syntax { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b} -> Monad m
06:58:04 <aCube> monoidal, is that valid (with GADTs) ?
06:58:27 <Cale> aCube: Well, the record syntax is, the construction of a Constraint is not.
06:58:28 <monoidal> aCube: don't know. in any case data Monad :: (* -> *) -> Constraint is already invalid
06:58:45 <xplat_> Cale: er, Monad m -> a -> m a
06:58:59 <Cale> though it's a little different:
06:59:04 <Cale> It'd be...
07:00:33 <Cale> data Monad :: (* -> *) -> Constraint where Monad { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b } :: Monad m -- not entirely sure where the class contexts go in this syntax...
07:00:45 <Cale> I think perhaps before the constructor
07:00:57 <Cale> I dunno.
07:01:31 <fizbin> :t maybe
07:01:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:03:48 <monoidal> Cale: this syntax is deprecated. it's Monad :: { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b } -> Monad m
07:04:03 <Eduard_Munteanu> Uh, can you actually do that?
07:04:22 * Eduard_Munteanu gets flashbacks of Agda
07:04:23 <monoidal> Eduard_Munteanu: yes. it compiles (s/Constraint/*)
07:04:45 <Eduard_Munteanu> Wow.
07:05:09 <hpaste> monoidal pasted “monad as a GADT” at http://hpaste.org/86472
07:05:20 <monoidal> Eduard_Munteanu: ^
07:05:56 <Eduard_Munteanu> Err, I don't get it... is that supposed to be a typeclass?
07:06:11 <Eduard_Munteanu> Or merely a GADT that carries the monad structure?
07:06:43 <monoidal> Eduard_Munteanu: it's a GADT
07:06:47 <Cale> errr http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
07:06:54 <Eduard_Munteanu> Cale's (* -> *) -> Constraint confused me I guess :)
07:06:57 <Cale> why doesn't the documentation reflect that syntax, I wonder
07:07:27 <monoidal> Cale: that deserves a ticket
07:07:44 <Eduard_Munteanu> Oh... what does that syntax mean? Why aren't there two fields, each for one method?
07:07:57 <Cale> Eduard_Munteanu: there are
07:08:11 <Cale> Eduard_Munteanu: note that the braces have a comma in the middle of them
07:08:34 <Eduard_Munteanu> Yeah, so   {a, b} -> c   is the same thing as   a -> b -> c   here?
07:08:40 <Cale> yeah
07:08:47 <Cale> similarly to ordinary record syntax
07:08:49 <Eduard_Munteanu> Ah.
07:09:40 <Cale> So with the new notation according to monoidal, the place to put the (Functor m) class constraint is a little more obvious (you'd stick it just after the first ::)
07:10:30 <Eduard_Munteanu> So, can you actually declare a proper typeclass with that? (get some Constraint instead of *)
07:10:38 <monoidal> Eduard_Munteanu: No, only *
07:10:43 <Eduard_Munteanu> Aww. :(
07:14:26 <fizbin> Hey, if I have a binary structure that fits all in memory (say, a few k or so) and I need to manipulate the stuffing out of it - flipping bits at specific spots, setting bytes at other fixed offsets - what's the most idiomatic structure to use? Right now I'm writing up code to make all my functions return (ST s (STUArray s Int Word8)) and then I'll use (pack . elems . runSTUArray) to turn that into a Bytestring.
07:14:35 <fizbin> Does that sound like a sensible plan?
07:19:23 <fizbin> :t elems . runSTUArray
07:19:24 <lambdabot> Not in scope: `runSTUArray'
07:20:09 <xplat_> fizbin: not obviously nonsensical, anyway
07:20:57 <xplat_> fizbin: seems like you ought to be able to do something nice with Storable and fuse away the intermediate datastructure, but i dunno if that works in practice (maybe in ghc8?)
07:22:40 <pxqr> fizbin: it seems like UArrays tightly pack booleans one-to-one  as well as storable vectors.
07:24:11 <fizbin> pxqr: Right, and if I were only flipping bits I'd use an STUArray of Bool, but it isn't just flipping bits. Several times it's "overwrite the bytes starting at offset x with this sequence of bytes".
07:24:41 <fizbin> pxqr: So I think it makes the code easier to work with if I stick to a collection of Word8 values.
07:24:59 <fizbin> And I'll use the stuff in Data.Bits for the bit twiddling.
07:26:02 <pxqr> fizbin: well, i'm doing something like you saying now. I just using ForeignPtr Word8 and malloc. :)
07:26:26 <fizbin> Hrm. Maybe...
07:29:05 <mfenwick100> any thoughts on whether it's good/bad that Data.Foldable is a superclass of Data.Traversable?
07:29:53 <mfenwick100> i have a datatype that seems to have a natural Traversable instance, but i can't figure out a good Foldable instance
07:30:30 <monoidal> mfenwick100: foldMap = foldMapDefault
07:32:52 <tromp__> what is the complexity of Integer multiplication in ghc? is it quadratic or less?
07:32:54 <Sixstix> is here someone who is able to speak german and can tell me what is ment by "verschränkt recursive"
07:33:08 <Sixstix> i have no idea how it's called in english
07:33:26 <mfenwick100> @Sixstix:  maybe mutual recursion?
07:33:26 <lambdabot> Unknown command, try @list
07:33:27 <tromp__> that means shrunken?!
07:33:27 <quchen> Mutually recursive?
07:33:44 <tromp__> that makes more sense
07:33:59 <Sixstix> interlocked recursive?
07:34:01 <Sixstix> does that make sense?
07:34:02 <parcs> :O
07:34:17 <Sixstix> we have directly recursive, recursive and "verschränkt" recursive
07:34:19 <monoidal> Sixstix: mutual recursion is established terminology
07:34:38 <monoidal> Sixstix: unless the meaning is different
07:35:22 <monoidal> Sixstix: for example, you can define odd 0 = False; odd x = even (x-1); even 0 = True; even x = odd (x-1)
07:35:23 <Sixstix> mutual recursive would be something like function a references b and b references a?
07:35:42 <monoidal> that's mutual recursion
07:36:11 <jagaj> what is the difference between a 'value' and a 'type' in haskell? I'm having difficultly understanding this
07:36:25 <elliott> jagaj: a type is like a set of values.
07:36:29 <elliott> values "have" types.
07:36:30 <Eduard_Munteanu> jagaj: it's like elements vs sets
07:36:34 <elliott> for instance, False and Bool are values of type Bool.
07:36:44 <monoidal> False and True are values of type Bool
07:36:45 <Eduard_Munteanu> True.
07:36:47 <elliott> data MyType = A | B | C -- A, B and C are the values of the type MyType.
07:36:49 <simpson> *False and True are values of Bool.
07:37:00 <tromp__> () is a value of type () . Clear now:-?
07:37:00 <elliott> simpson: that's not really grammatical...
07:37:08 <Eduard_Munteanu> Hah, tromp__
07:37:23 <jagaj> hmm
07:37:25 <simpson> elliott: No, it never is. :c
07:37:27 <monoidal> or, "not" is a value of type "Bool -> Bool"
07:37:32 <Eduard_Munteanu> Also, [()] :: [()] :P
07:37:47 <quchen> That should clear things up.
07:37:52 <elliott> jagaj: have you used other programming languages like C?
07:37:54 <monoidal> jagaj: If you write "x :: y", then x is a value and y is a type. For example False :: Bool
07:37:56 <tromp__> :t http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[()]
07:37:58 <lambdabot> parse error on input `='
07:38:02 <jagaj> elliott: that is where I am coming from, yes
07:38:06 <elliott> in C, 123 is a value of type int, for instance
07:38:24 <elliott> in Haskell, 123 is a value of type Int too (it can also be used as an Integer or Float or other numeric types, but that's not relevant here)
07:38:30 <elliott> it's the same thing
07:38:50 <elliott> data MyType = A | B | C -- is like -- enum MyType { A, B, C }
07:39:05 <jagaj> ok, I'm fairly sure I understand that then. I must be getting confused elsewhere
07:39:08 <elliott> but Haskell's types are a lot more powerful & flexible than C's
07:39:22 <elliott> do you have a specific example of your confusion? e.g. some code or text you don't understand
07:39:22 <jagaj> I'll be back when I can ask a better question, thank you very much for the help everyone
07:39:27 <elliott> hehe, ok
07:39:49 <Sixstix> okay, yeah, you were right
07:39:54 <quchen> I found the difference between value constructors and type constructors confusing in the beginning.
07:39:59 <quchen> Maybe that's the issue here.
07:39:59 <jagaj> I'm reading lyah and the entire chapter on types and typeclasses is confusing me
07:39:59 <Sixstix> verschränkt rekursiv = mutual recursion
07:40:01 <Sixstix> thankts for that
07:40:09 <Sixstix> *thanks
07:40:11 <jagaj> particularly type constructor/value constructor
07:40:17 <jagaj> and typeclasses v. types
07:40:18 <jagaj> etc..
07:40:37 <jagaj> I need to figure out what it is exactly I don't understand though, otherwise I'll probably waste your time
07:41:19 <elliott> jagaj: well, "value constructor" is just something like False or Just
07:41:45 <jagaj> is it just 'another name' for a value or is it something more?
07:41:50 <elliott> well
07:41:52 <elliott> if we have
07:41:56 <elliott> data Maybe a = Nothing | Just a
07:41:56 <jagaj> I'm mentally equating it with C's typedef atm
07:42:03 <jagaj> and I suspect that maybe a failure of understanding
07:42:06 <elliott> then "Nothing" and "Just" are value constructors (usually just called constructors)
07:42:15 <elliott> (similarly, data Bool = False | True -- False and True are constructors)
07:42:54 <elliott> an easy way to tell is: constructors are just the values whose names start with an uppercase letter (of course, this doesn't tell you what they /are/)
07:43:06 <monoidal> jagaj: typedef in C defines a type (not a value)
07:43:08 <elliott> a type constructor is something like "Maybe"; it takes another type and makes a type out of it
07:43:13 <Shaladdle> Is there an analog to value constructors in C?
07:43:22 <elliott> so for instance, since (Maybe Int) is a type, Maybe is a type constructor
07:43:33 <elliott> and since (Just 123) is a value (of type (Maybe Int)), Just is a value constructor
07:43:48 <jagaj> monoidal: but it isn't like a type constructor?
07:43:56 <elliott> (there's some ambiguity over whether e.g. Bool counts as a type constructor, since it doesn't actually take any type arguments; the terminology is not perfect)
07:44:08 <elliott> jagaj: do you know about tagged unions in C?
07:44:12 <jagaj> elliott: yes
07:44:13 <Eduard_Munteanu> Shaladdle: not really, I don't think so... only enums are a bit close
07:44:32 <Eduard_Munteanu> But they're plain ints. :(
07:44:38 <elliott> jagaj: you can think of e.g. (Either Int String) as a tagged union of Int and String
07:44:50 <elliott> struct { enum { AnInt, AString } tag; void *data; }
07:45:00 <jagaj> elliott: and that's a type constructor or value constructor?
07:45:03 <jagaj> or it doesn't matter?
07:45:04 <elliott> it's a type
07:45:10 <elliott> "Either" is a type constructor
07:45:14 <elliott> the Haskell form of it is much simpler: data Either a b = Left a | Right b
07:45:21 <jagaj> but it takes 2 values, yes?
07:45:25 <elliott> 2 types :)
07:45:32 <jagaj> ...
07:45:44 <elliott> this means, for every type a, and for every type b, Either a b is a type (hence: Either is a type constructor; hence: Either String Int is a type (because String and Int are types))
07:45:48 <jagaj> Why are Int and String types? or am I totally lost
07:45:54 <Eduard_Munteanu> :t "abc"
07:45:56 <jagaj> I feel like I'm asking bad questions
07:45:56 <lambdabot> [Char]
07:45:56 <elliott> they're types in C too...
07:45:59 <elliott> int x = 123;
07:46:01 <elliott> char *x = "abc";
07:46:06 <elliott> int and (char *) are types there
07:46:13 <jagaj> ah!
07:46:14 <jagaj> ok
07:46:20 <elliott> they correspond to Int and String in Haskell (actually, Haskell's String is Unicode)
07:46:35 <elliott> carrying on from what I was saying about Either:
07:47:04 <elliott> ...it also says that for every value of type a, (Left a) is a value of type (Either a b), and for every value of type b, (Right b) is a value of type (Either a b)
07:47:23 <jagaj> ok
07:47:29 <elliott> hence: Left and Right are (value) cosntructors; hence: Left "abc" is a valid value of type Either String Int; hence: Right 123 is a valid value of type Either String Int
07:47:33 <jagaj> so taking an example from lyah
07:48:03 <jagaj> "data Shape = Circle Float Float Float | Rectangle Float Float Float Float"
07:48:07 <elliott> er, wait.
07:48:11 <elliott> what I said was misleading.
07:48:27 <elliott> it also says that for every value x of type a, (Left x) is a value of type (Either a b), and for every value y of type b, (Right y) is a value of type (Either a b)
07:48:30 <elliott> there.
07:48:43 <jagaj> Circle and Rectangle are value constructors, and Shape is a type?
07:48:45 <danr> jagaj: yes, that means a shape is either a circle or a rectangle, plus some extra Float information about them (3 for circles, four for rectangles)
07:48:48 <elliott> jagaj: yep
07:48:49 <monoidal> jagaj: Yes
07:48:49 <danr> jagaj: yes
07:48:52 <jagaj> woo!
07:48:55 <elliott> jagaj: that means if you have a Float called x, a Float called y, and a Float called z, then (Circle x y z) is a Shape
07:49:05 <jagaj> the fact that he doesn't explain that in this, made me think I was understanding it wrong
07:49:09 <elliott> and if you have Floats a,b,c,d, (Rectangle a b c d) is a Shape
07:49:16 <quchen> The whole channel has just been waiting for him to respon to elliott's explanation in order to say "well done padawan" :-D
07:49:26 <zammy> is there some OS haskell made of?
07:49:28 <elliott> hehehe
07:49:41 <elliott> jagaj: the notation is a little confusing thanks to the fact that "Rectangle" and "Circle" differ from "Float" there.
07:49:45 <jagaj> elliott: thank you for your time, you've help me quite a lot the last few days :)
07:49:47 <danr> zammy: i think there is an OS called horse that is mainly written in Haskell
07:49:54 <jagaj> and everyone else chiming in, thank you as well
07:49:56 <elliott> the first name is the name of the constructor, and everything after it is the arguments it takes.
07:50:09 <elliott> :)
07:50:21 <danr> zammy: oh no, house: http://programatica.cs.pdx.edu/House/
07:50:34 <zammy> cool thx
07:50:58 <danr> zammy: also, first search hit: http://stackoverflow.com/questions/6638080/is-there-os-written-in-haskell
07:52:22 <voxpopuli> what is the best, if any, way to do parallel computation with haskell?  specifically: accessing cpu threads, cpu simd, and gpu
07:53:21 <danr> zammy: this was also one of the hits: http://answers.bettor.com/images/Articles/thumbs/extralarge/Field-for-Haskell-Invitational-swells-up-to-eight-as-the-big-names-of-horse-racing-gear-themselves-for-a-1million-purse-83731.jpg
07:53:34 <zammy> that's enought thanks
07:53:38 <zammy> XD
07:53:41 <danr> ^^
07:54:07 <Eduard_Munteanu> Haha, danr
07:55:19 <aCube> :t base
07:55:20 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => a -> p a (f a) -> p String (f String)
07:55:26 <aCube> Where is this from?
07:55:32 <Eduard_Munteanu> @index base
07:55:32 <lambdabot> Text.Html
07:55:33 <quchen> voxpopuli: That depends entirely on your problem. There's Control.Parallel, Control.Concurrent, various GPU libraries etc.
07:55:51 <aCube> @hoogle base
07:55:52 <lambdabot> Control.Exception.Base module Control.Exception.Base
07:55:52 <lambdabot> Text.Html base :: String -> HtmlAttr
07:55:52 <lambdabot> Text.XHtml.Strict base :: String -> HtmlAttr
07:56:44 <quicksilver> aCube: with a type like that I'm thinking it's in lens somewhere
07:57:21 <elliott> aCube: Numeric.Lens
07:57:28 <t7> i need a fast way to get every permutation of n items from a list
07:57:36 <elliott> the real type is Integral a => Prism' String a
07:57:52 <aCube> elliott, thanks
07:58:05 <elliott> er sorry
07:58:09 <elliott> Integral a => Int -> Prism' String a
07:58:27 * aCube just noticed that :i in ghci doesn't expand type synonyms
07:58:55 <monoidal> aCube: you can use :kind! for this.
07:59:08 <t7> map (take n) (permutations mylist)   isnt quick enough
07:59:39 <Eduard_Munteanu> t7: you probably need to nub it too
07:59:45 <t7> yeah im doing that
08:00:20 <t7> help me please clever people :D
08:01:11 <t7> ah i guess i can do a list comprehension, i know the length
08:01:13 <Kinnison> Gah, nobody has tested bootstrapping ghc properly in forever
08:01:43 <klrr> how do i define a datatype which works like Bool, except that anything is True except something called nil?
08:01:44 <quchen> Kinnison: Most of us aren't familiar with how to handle Si wafers
08:02:24 <DMcGill> klrr: What? How will this be different from Bool and what do you need it for?
08:02:29 <simpson> klrr: Well, it's up to your function which produces Bools to be able to do that classification.
08:02:35 <armlesshobo> data MyBool = MyTrue | nil
08:02:49 <zammy> can haskell substitute c++ in all?
08:03:00 <Clint> klrr: what do you mean by "anything"?
08:03:04 <quchen> @faq Can Haskell substitute C++ in all?
08:03:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:03:11 <DMcGill> zammy: http://www.haskell.org/haskellwiki/FFI_Introduction
08:03:16 <voxpopuli> quchen: i'd gotten the impression from searching around that while concurrent/multicore is well implemented, data parallel simd was sort of ad hoc or not fully supported at this point.  is that not the case?
08:03:56 <zammy> FUCK AWESOME
08:04:05 <zammy> let's develop a haskell OS
08:04:11 <zammy> open source
08:04:23 <quchen> voxpopuli: Oh, you're talking about going parallel all the way. I'm not sure about the state of data parallel Haskell, I've only seen a couple of talks on it.
08:04:26 <elliott> feel free. :p
08:04:32 <simpson> zammy: There have been several attempts. Go look up House.
08:04:55 <zammy> yes... that attempts is ... low try
08:05:12 <voxpopuli> yes, i'm trying to take parallel to 11
08:05:22 <Kinnison> quchen: there's distrib/hc-build which afaict hasn't been touched/tested since around 6.4
08:05:29 <Kinnison> quchen: It's making me ultra-sad
08:05:38 <Kinnison> quchen: as I need to be able to build ghc somewhere I don't have ghc already
08:05:39 <quchen> 11 cores should be easy with the new scheduler ;-)
08:07:04 <Kinnison> quchen: the --enable-hc-boot argument to configure still results in the makefiles trying to run ghc
08:07:16 <Kinnison> quchen: but brokenly because it has turned off about half of the ghc configuration stuff
08:07:22 <Kinnison> quchen: all in all, it makes me super-sad
08:07:47 * Kinnison throws away 12G of build trees and writes off ca. 24h of wasted CPU time
08:07:52 <quchen> Kinnison: Hm. I wonder where the ARM builds are coming from myself.
08:08:04 <Kinnison> quchen: cross-compilation is a different thing entirely
08:08:13 <Kinnison> quchen: and has had a lot of work done on it recently
08:08:19 <quchen> Oh right, ARM is supported via LLVM only
08:08:23 * Kinnison wonders if that work is what has resulted in hc-boot not working
08:08:36 <aCube> @hoogle (a -> m Bool) -> m a -> m a
08:08:36 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
08:08:37 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
08:08:37 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
08:09:29 <fizbin> Okay, I need help from someone who understands ST and the "forall" in the runST signature.
08:10:02 <fizbin> I'm trying to convert a bunch of code that uses [Word8] into using (ST s (STUArray s Int Word8))
08:10:30 <kartoffelbrei> aCube: if you are looking for ifM, i'm afraid you'll have to write that yourself, But if you are searching for stuff like whileM, look at the monad-loop package.
08:10:35 <fizbin> And it isn't going well; error messages make no sense.
08:10:42 <hpaste> fizbin pasted “Can't incrementally convert to (ST s (STUArray s Int Word8))” at http://hpaste.org/86478
08:12:31 <Eduard_Munteanu> fizbin: sTUArrayToList can't be implemented with that type the way you think
08:12:32 <quchen> fizbin: "return" missing? "listToSTUArray byteList = return . (...)"
08:13:31 <quchen> Eh, nevermind that.
08:14:08 <Eduard_Munteanu> fizbin: you most likely want something like   sTUArrayToList :: STUArray s Int Word8 -> ST s [Word8]
08:14:18 <fizbin> Eduard_Munteanu: Why?
08:14:40 <fizbin> Eduard_Munteanu: Why can't I runST inside sTUArrayToList ?
08:15:27 <Eduard_Munteanu> fizbin: ah, sure, you can do that... you can't invoke that in the ST monad though
08:15:44 <Eduard_Munteanu> Actually, you can't.
08:15:45 <fizbin> I want to incrementally convert stuff that's not in the ST world (and using Word8) over to the ST world, checking along the way. To do that, I need conversion functions.
08:15:58 <Eduard_Munteanu> You need to forall s like runST.
08:16:18 <dEPy> hye guys
08:16:31 <monoidal> fizbin: For example, you cannot write f :: ST s a -> a; f = runST
08:16:35 <dEPy> how can I access elements inside my tasklist directive, http://jsfiddle.net/depy/VC4J6/4/ ?
08:16:41 <dEPy> oops, wrong channel
08:17:11 <fizbin> monoidal, Eduard_Munteanu: See the comments for stuff I've tried. Using forall can get my module to compile, but then my conversion functions aren't inverses of each other.
08:17:46 <monoidal> fizbin: using . on higher-rank types is hazardous
08:17:55 <monoidal> fizbin: it simply often won't work.
08:18:11 <jfischoff> Has anyone tried to write a wrapper of Language.Haskell.TH that uses GADTs to be able to distinguish between Dec's?
08:18:47 <fizbin> Well then how can I have my conversion functions work?
08:18:53 <aCube> testExpression xs = sTUArrayToList $ listToSTUArray xs
08:18:54 <aCube> works
08:19:13 <Eduard_Munteanu> fizbin: you don't need actual inverses
08:19:16 <aCube> with testExpression xs = sTUArrayToList $ listToSTUArray xs
08:19:19 <aCube> oops
08:19:25 <aCube> listToSTUArray :: [Word8] -> ST s (STUArray s Int Word8)
08:19:35 <aCube> and sTUArrayToList :: (forall s. ST s (STUArray s Int Word8)) -> [Word8]
08:19:49 <Eduard_Munteanu> That'd require impredicative instantiation of 's', I guess.
08:19:51 <quchen> Doesn't ($) have special rules for this?
08:19:58 <quchen> (Rules that (.) doesn't have)
08:20:02 <Eduard_Munteanu> quchen: it does
08:20:05 <jfischoff> I was thinking of make a 'data Name a' type and reifyType :: Name Type' -> Dec Type',  or something like that
08:21:13 <fizbin> Huh. So apparently I *almost* had it, and was bitten by "." not actually meaning what I thought it meant.
08:21:13 <t7> ugh lazyness sucks sometimes
08:21:35 <quchen> So what about "sTU... x = elems $ runSTUArray $ x"?
08:21:43 <jfischoff> @tell mgsloan have you thought about make GADT wrapper around TH so your functions can be total easier?
08:21:44 <lambdabot> Consider it noted.
08:21:45 <aCube> quchen, what are those "speical rules" ?
08:22:16 <fizbin> I thought that (f . g) x = f (g x) and apparently it does mean that mostly, except "Oh, and throw up all over the place if you come into contact with forall"
08:22:26 <quchen> aCube: Not crashing when you use it on ST. Maybe Eduard_Munteanu knows more than that.
08:22:52 <Eduard_Munteanu> :t (Prelude..)
08:22:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:23:16 <quchen> fizbin: case f,g of ST -> return WARRGARBL; _ -> f (g x)
08:23:21 <fizbin> Because I don't need to use $ to make it work - defining testExpression as \xs -> sTUArrayToList (listToSTUArray xs) also works.
08:23:27 <fizbin> w.t.f.
08:23:34 <Eduard_Munteanu> fizbin: that would require instantiating some type variables to polymorphic stuff, and it isn't generally supported.
08:23:45 <Eduard_Munteanu> Sure, that works too.
08:24:23 <DoomOfMalentai> hi guys anyone know anything abour RC of new haskell platform
08:24:24 <Eduard_Munteanu> :t (Prelude..) runST ?x
08:24:25 <lambdabot> (?x::a -> forall s. ST s c) => a -> c
08:24:33 <DoomOfMalentai> was supposed to be build yesterday
08:24:41 <DoomOfMalentai> and wiki is pointing to old one still
08:24:50 <monoidal> fizbin: when you have a signature like "forall a. a -> a", GHC can substitute "Int" for "a" to get "Int -> Int", but it cannot substitute "forall b. b" to get "(forall b. b) -> (forall b. b)"
08:24:52 <hpaste> tux annotated “Can't incrementally convert to (ST s (STUArray s Int Word8))” with “This works too (if you accept another Wrapper)” at http://hpaste.org/86478#a86479
08:25:38 <fizbin> Eduard_Munteanu: Why does the . version cause that polymorphic type variable instantiation and the version (\xs -> sTUArrayToList (listToSTUArray xs)) not require the same polymorphic type variable instantiation ?
08:25:53 <fizbin> @src (Prelude..)
08:25:53 <lambdabot> Source not found. I feel much better now.
08:26:09 <Eduard_Munteanu> fizbin: there's nothing to instantiate when you do simple function application
08:26:37 <Eduard_Munteanu> runST requires a value polymorphic in 's' and it gets one.
08:27:05 <fizbin> Eduard_Munteanu: I guess I don't understand what you mean by polymorphic type variable instantiation then.
08:27:07 <Eduard_Munteanu> fizbin: that's just (.)
08:27:19 <Eduard_Munteanu> fizbin: see what monoidal said above
08:27:41 <Eduard_Munteanu> Except you apply it to (.).
08:27:42 <klrr> Clint: i mean any type , everything in the whole language is true except nil, that's what i try implement
08:27:56 <ReleaseCandidate> :t Just 6
08:27:59 <lambdabot> Num a => Maybe a
08:28:49 <fizbin> Eduard_Munteanu: Okay, but then let's take the \xs -> ... version.
08:28:49 * Eduard_Munteanu wonders what sort of impredicativity annotations would make sense
08:29:25 <Eduard_Munteanu> fizbin: which would that be?
08:29:25 <fizbin> Eduard_Munteanu: When it's figuring out the type, (listToSTUArray xs) has type (ST s (STUArray s Int Word8))
08:29:39 <fizbin> Eduard_Munteanu: That's not got a "forall" in it.
08:30:04 <Eduard_Munteanu> fizbin: sure it does
08:30:25 * hackagebot yesod 1.1.9.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.9.3 (MichaelSnoyman)
08:30:27 * hackagebot yesod-static 1.1.2.3 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.2.3 (MichaelSnoyman)
08:30:37 <Eduard_Munteanu> It's just implicit. :)
08:31:32 <Eduard_Munteanu> fizbin: look at it another way... runST wants something polymorphic in 's'. You give it something that works forall s. ...
08:32:48 <fizbin> I'm having trouble figuring out how forall binds.
08:32:50 <aCube> :t runST
08:32:52 <lambdabot> (forall s. ST s a) -> a
08:33:08 <aCube> it wants something that works for all s
08:33:55 <fizbin> Apparently, these type signatures are all equivalent: (forall s. [Word8] -> ST s (STUArray s Int Word8));  [Word8] -> (forall s. ST s (STUArray s Int Word8)); [Word8] -> ST s (STUArray s Int Word8)
08:34:20 <Eduard_Munteanu> fizbin: yep
08:34:31 <fizbin> However, (forall s. ST s (STUArray s Int Word8)) -> [Word8] is not equivalent to ST s (STUArray s Int Word8) -> [Word8]
08:34:35 <hseg> Was arguing with a friend recently on the ease of implementing programs in functional languages as opposed to imperative languages, and he brought the counterexample of Kruskall's algorithm, which basically reduces to union-find. I haven't succeeded in either finding an intuitive way of implementing this in Haskell without incurring either performance penalties or purity penalties. Can't find any literature on the subject.
08:34:51 <Eduard_Munteanu> Let's change notation a bit, and do some pseudoAgdaskell.
08:35:06 <fizbin> Eduard_Munteanu: I've never done Agda.
08:35:27 <elliott> hseg: there's a chance nobody knows how to implement it equally fast purely.
08:35:50 <elliott> you should be able to implement it equally fast, and exposed as a pure function, with ST. of course the code will look more imperative.
08:35:52 <Eduard_Munteanu> Look at    (s :: *) -> [Word8] -> ST s (STUArray s Int Word8)
08:35:54 <monoidal> hseg: unionfind is a perfect use case for runST imo
08:36:09 <Eduard_Munteanu> Consider 's' an ordinary parameter, except it's a type.
08:36:11 <hseg> I know. I remember seeing somewhere that there exist programs that experience a logarithmic slowdown when implemented purely.
08:36:34 <hseg> But doesn't ST reduce the purity of the function?
08:36:36 <Eduard_Munteanu> Then look at    ((s :: *) -> [Word8]) -> ST s (STUArray s Int Word8)
08:36:47 <Eduard_Munteanu> Do you see how they differ?
08:36:48 <monoidal> hseg: I would say no.
08:37:09 <Clint> klrr: so you want Maybe?
08:37:31 <Eduard_Munteanu> The latter is actually a   (t :: *) -> ((s :: *) -> [Word8]) -> ST t (STUArray t Int Word8)
08:37:34 <fizbin> Eduard_Munteanu: I'm having trouble with (s :: *). You seem to be declaring a function that takes a type as a parameter and returns a function that takes a value as a parameter.
08:37:45 <Eduard_Munteanu> fizbin: yep
08:38:12 <fizbin> I'm not used to these two worlds mixing. I'm guessing that's the Agda bit?
08:38:13 <klrr> Clint: yeah, but my own maybe
08:38:17 <klrr> ?src Maybe
08:38:17 <lambdabot> data Maybe a = Nothing | Just a
08:38:21 <klrr> omg
08:38:24 <klrr> that was simple :D
08:38:38 <Eduard_Munteanu> fizbin: yeah.
08:38:47 <klrr> data Bool a = Nil | True a
08:38:50 <klrr> :D
08:38:58 <klrr> im implementing Arc btw
08:38:58 <monoidal> klrr: note this conflicts with Prelude.True.
08:39:09 <klrr> monoidal: yeah i might use different names
08:39:21 <klrr> data Bool' a = Nil | True' a
08:39:57 <fizbin> Eduard_Munteanu: Okay, I guess I see how they differ.
08:40:02 <Eduard_Munteanu> fizbin: take   id :: (a :: *) -> (a -> a)   for example. You can "pass" id the type Bool, and it gives you back a  Bool -> Bool   function
08:40:35 <fizbin> It seems to me that the function with type (t :: *) -> ((s :: *) -> [Word8]) -> ST t (STUArray t Int Word8) is totally ignoring its second argument, yes?
08:41:06 <fizbin> (Barring weird reflection stuff, I suppose.)
08:41:53 <Eduard_Munteanu> fizbin: it wasn't supposed to be a meaningful type
08:42:05 <fizbin> Eduard_Munteanu: Okay, now in this pseudo-Agda-notation, what's "forall" turn into?
08:43:00 <Eduard_Munteanu> fizbin: forall introduces types and type functions\.
08:43:10 <Eduard_Munteanu> fizbin: it's the (a :: *) thing
08:43:37 <fizbin> Okay, so I see why (forall s. [Word8] -> ST s (STUArray s Int Word8)) is equivalent to [Word8] -> ST s (STUArray s Int Word8)
08:43:49 <Eduard_Munteanu> fizbin: you need to name the * thing because the rest of the type depends on it.
08:43:57 <fizbin> But why then is [Word8] -> (forall s. ST s (STUArray s Int Word8)) also equivalent?
08:44:32 <Eduard_Munteanu> fizbin: it just flips the "arguments"
08:44:45 <fizbin> Hrm.
08:45:16 <Eduard_Munteanu> [Word8] -> ST s (STUArray s Int Word8) = (s :: *) -> [Word8] -> ST s (STUArray s Int Word8)
08:45:25 * hackagebot http-reverse-proxy 0.1.1.6 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.1.6 (MichaelSnoyman)
08:45:55 <fizbin> It's not clear to me that flipping the arguments should be something that can be cleanly handwaved away.
08:45:56 <Eduard_Munteanu> [Word8] -> (forall s. ST s (STUArray s Int Word8)) = [Word8] -> ((s :: *) -> ST s (STUArray s Int Word8)) = [Word8] -> (s :: *) -> ST s (STUArray s Int Word8)
08:46:46 <Eduard_Munteanu> (= is some "moral" equality :D)
08:47:36 <Eduard_Munteanu> fizbin: IOW, it doesn't matter if I give it a [Word8] then instantiate 's', or instantiate 's' then give it the [Word8]
08:48:36 <monoidal> fizbin: Note that if you have a value of type Int -> a -> a, and you give it some Int, it becomes a -> a. Giving explicit forall, this means you can take a function forall a. Int -> a -> a, apply it, and get forall a. a -> a. So in some sense the function forall a. Int -> a -> a is equivalent to Int -> forall a. a -> a
08:48:45 <Eduard_Munteanu> This is just an analogy though, don't take it too far.
08:49:42 <fizbin> Okay, so let me check this: (forall s. somethingWithS) -> SomeOtherType isn't equivalent to (somethingWithS -> SomeOtherType). However, that second type is equivalent to (forall s. somethingWithS -> SomeOtherType).
08:50:01 <monoidal> fizbin: Yes
08:50:33 <monoidal> fizbin: All type variables are implicitly quantified with forall at the beginning of the signature.
08:51:19 <monoidal> * those variables which are not explicitly quantified have an implicit "forall" at the beginning of the signature.
08:52:09 <monoidal> fizbin: in other words, the type a -> Int is equivalent to forall a. (a -> Int) but NOT (forall a. a) -> Int.
08:52:14 <fizbin> And what about FirstType -> (forall s. somethingWithS) -> SecondType ? If I follow the analogy, I get that this is not equivalent to anything I could get by restructuring how the forall is scoped.
08:52:42 <monoidal> fizbin: indeed.
08:53:01 <Eduard_Munteanu> fizbin: FirstType -> (forall s. somethingWithS -> SecondType)   is equivalent
08:53:09 <monoidal> Eduard_Munteanu: no
08:53:11 <fizbin> That is, FirstType -> (forall s. somethingWithS) -> SecondType is distinct from FirstType -> (forall s. somethingWithS -> SecondType)
08:53:24 <fizbin> Eduard_Munteanu: If it is, I've missed the analogy.
08:53:31 <Eduard_Munteanu> Oh, wait, monoidal is right.
08:53:37 <fizbin> ok.
08:53:42 * Eduard_Munteanu is sometimes dumb :P
08:53:58 <_kwstas> hello there! I'm new to Haskell and I have a question. Is there a way using list coprehension (or list monad) to "generate" two values instead of one, in each iteration? something like [x:x+1 | x <- [1..5]] -> [1,2,2,3,3,4,4,5]?
08:54:18 <tromp__> sure
08:54:27 <monoidal> > [y | x <- [1..5], y <- [x,x+1]]
08:54:31 <lambdabot>   [1,2,2,3,3,4,4,5,5,6]
08:54:39 <monoidal> _kwstas: ^
08:54:55 <fizbin> Okay, but FirstType -> (forall s. somethingWithS -> SecondType) is equivalent to (forall s. FirstType -> somethingWithS -> SecondType) , yes?
08:55:01 <monoidal> fizbin: Yes
08:55:12 <fizbin> (Which is equivalent to dropping the "forall s.")
08:55:40 <monoidal> fizbin: This is a special case of previous equivalence, put X = somethingWithS -> SecondType and you get "FirstType -> forall s. X" ~ "forall s. FirstType -> X"
08:55:40 <Eduard_Munteanu> Yeah, because of the somewhat crazy implicit quantification. :)
08:55:47 <_kwstas> oh! is that so simple? thanks a lot monoidal!!!
08:56:46 <fizbin> Okay, now. I think I'm almost ready to understand monoidal's comment above about not being able to substitute (forall b. somethingWithB) in for the "a" in "a -> a".
08:56:47 <ReleaseCandidate> > 9**99
08:56:49 <lambdabot>   2.9512665430652752e94
08:57:41 <fizbin> Is it because the "b" in the two substitutions ends up being different so that what you really get is something like (forall b. somethingWithB) -> (forall b0. somethingWithB0) ?
08:58:08 <Eduard_Munteanu> fizbin: it's just that normal instantiation takes a polymorphic type and gives you a concrete one
08:58:53 <fizbin> :t (Prelude..)
08:58:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:59:32 <monoidal> fizbin: in place of a,b,c above you can put monomorphic types (those which do not contain forall, neither implicit or explicit) but not polymorphic
09:00:13 <fizbin> Right, I'm trying to figure out why. Because sometimes you can substitute in polymorphic types. E.g., when a type variable appears only once.
09:00:16 <Eduard_Munteanu> You can interpret it as * containing just concrete types.
09:00:21 <fizbin> I think, at least.
09:00:41 <Eduard_Munteanu> Mm, no.
09:00:47 <fragamus> I have learned so much haskell but I still feel like I don't know crap
09:01:00 <Eduard_Munteanu> :t runST
09:01:02 <lambdabot> (forall s. ST s a) -> a
09:01:37 <Eduard_Munteanu> runST x   where x :: forall s. ST s Bool   is fine.
09:01:43 <fizbin> E.g., going back to my issue, (listToSTUArray . sTUArrayToList) is just fine apparently, but (sTUArrayToList . listToSTUArray) blows up.
09:01:56 <Eduard_Munteanu> The types do match after all, as far as 's' is concerned.
09:02:38 <Eduard_Munteanu> What are the types of those, again?
09:03:00 <fizbin> monoidal: So when "a" and "c" are polymorphic, fine. When "b" is polymorphic, sadness.
09:03:02 <fragamus> 9**9**9
09:03:14 <fragamus> > 9**9**9
09:03:15 <lambdabot>   Infinity
09:03:21 <fragamus> hmmm
09:03:40 <fizbin> Eduard_Munteanu: listToSTUArray :: [Word8] -> ST s (STUArray s Int Word8) and sTUArrayToList :: (forall s. ST s (STUArray s Int Word8)) -> [Word8]
09:03:50 <fragamus> lambdabot you are mistaken
09:04:10 <Sixstix> how can I see how long my function took to terminate?
09:04:19 <Eduard_Munteanu> fizbin: alright... then you can see sTUArrayToList requires a polymorphic value... you can't just instantiate 's' then pass it to sTUArrayToList.
09:04:27 <fizbin> Eduard_Munteanu: And it's listToSTUArray . sTUArrayToList is fine.
09:05:05 <Sixstix> at a lecture i've seen something like (0.01sec x bytes)
09:05:29 <fizbin> Eduard_Munteanu: Sure. That's by design. (Not by my design, but by the design of whoever wrote runSTUArray, where this forall comes from)
09:05:37 <Sixstix> or was that something my prof implemented himself?
09:06:29 <geekosaur> Sixstix, if this was in ghci:  :set +s
09:06:53 <aCube> Or maybe he used the linux command `time' ?
09:06:56 <cschneid> does haskell have a way to do multiple functions of the same name that work on different types, other than typeclasses?  For instance, `sum :: [Maybe Int]` side by side with `sum :: [Int]`? or even a `sum :: [MyOwnType]`
09:07:20 <aCube> cschneid, what would sum do on an arbitrary type?
09:07:21 <cschneid> or would the way to implement that be a summable typeclass that I can then make instances of
09:07:23 <Sixstix> yea, exactly what I've been looking for, thanks :)
09:07:25 <ReleaseCandidate> > 7 ** 87
09:07:27 <lambdabot>   3.338331660151908e73
09:07:28 <cschneid> aCube: whatever I define for that type.
09:07:35 <fizbin> cschneid: That's the whole point of typeclasses
09:07:35 <ReleaseCandidate> :t Just "ben"
09:07:39 <lambdabot> Maybe [Char]
09:08:10 <geekosaur> aCube, 'time' normally just shows times, not bytes... some shells will let you capture some meaning of 'bytes' but probably not a meaningful one for this
09:08:22 <Eduard_Munteanu> fizbin: try replacing the type variables in (.)'s type manually and try removing the foralls
09:08:23 <geekosaur> (do you really care how much paging happened?)
09:08:26 <aCube> Or maybe it was +RTSOPTS -sstderr?
09:08:27 <cschneid> fizbin: ok. So in this case a summable typeclass would make sense? that defines just the one `sum` function which instances can then define however they choose?
09:08:35 <merijn> cschneid: The way to do it without typeclasses is this
09:08:57 <merijn> "summable :: (a -> a -> a) -> [a] -> a"
09:09:07 <aCube> cschneid, what do you require for the types of the list?
09:09:08 <merijn> cschneid: In fact, that already exists
09:09:15 <aCube> :t sumBy
09:09:17 <lambdabot> Not in scope: `sumBy'
09:09:17 <merijn> cschneid: It's called foldr and foldl :)
09:09:22 <merijn> :t foldr
09:09:24 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:09:27 <merijn> :t foldl
09:09:28 <lambdabot> (a -> b -> a) -> a -> [b] -> a
09:09:35 <cschneid> hah, ya.
09:09:53 <fizbin> :t foldr1 (<>)
09:09:55 <lambdabot> Monoid a => [a] -> a
09:09:58 <merijn> cschneid: Using typeclasses where you can use first class functions is an anti-pattern that's very common amongst beginners :p
09:10:01 <Eduard_Munteanu> fizbin: you'll see you can instantiate 's' according to the argument you pass to the composed function
09:10:03 <aCube> :t msum
09:10:05 <lambdabot> MonadPlus m => [m a] -> m a
09:10:10 <aCube> :t mconcat
09:10:13 <fizbin> @hoogle Monoid a => [a] -> a
09:10:14 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
09:10:14 <lambdabot> Prelude head :: [a] -> a
09:10:14 <lambdabot> Data.List head :: [a] -> a
09:10:14 <lambdabot> Monoid a => [a] -> a
09:11:05 <aCube> :t oneOf
09:11:08 <lambdabot> Eq a => [a] -> Splitter a
09:11:17 <fizbin> Eduard_Munteanu: Okay, so I think I might have some idea of what's happening.
09:12:07 <fizbin> :t let foo = undefined :: (a -> b); bar = undefined :: (b -> c) in bar . foo
09:12:17 <lambdabot> a -> c
09:12:35 <merijn> cschneid: btw, the underlying (GHC) implementation of typeclasses is to just pass a dictionary/tuple of functions as hidden extra argument to the function
09:12:39 <fizbin> :t let foo = undefined :: (a -> b); bar = undefined :: (b -> c) in foo . bar
09:12:42 <lambdabot> a -> c
09:12:53 <cschneid> merijn: interesting. that's fun to know
09:12:59 <aCube> merijn, when should I use functions as arguments, and when typeclasses?
09:13:14 <fizbin> Wait, wtf lambdabot.
09:13:16 <merijn> cschneid: There was a nice talk of SPJ on that but I can't remember the name, maybe someone else here remembers?
09:13:45 <Eduard_Munteanu> fizbin: you realize there's no such foo or bar, right?
09:13:53 <Eduard_Munteanu> :t unsafeCoerce
09:13:54 <lambdabot> Not in scope: `unsafeCoerce'
09:13:57 <merijn> aCube: It's mostly a matter of taste, but if you can do it without typeclasses, that's usually better
09:13:59 <Eduard_Munteanu> @hoogle unsafeCoerce
09:14:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:14:12 <fizbin> :t let foo = undefined :: (Word8 -> Int); bar = undefined :: (Int -> Char) in foo . bar
09:14:14 <lambdabot>     Couldn't match expected type `Word8' with actual type `Char'
09:14:14 <lambdabot>     Expected type: Int -> Word8
09:14:14 <lambdabot>       Actual type: Int -> Char
09:14:20 <Eduard_Munteanu> :t ?foo . ?bar
09:14:21 <fizbin> Okay, that's more like it.
09:14:22 <lambdabot> (?foo::b -> c, ?bar::a -> b) => a -> c
09:14:46 <czro_> How do I copy all values from a Ptr CDouble of length n to a Data.Vector.Storable CDouble of length n?
09:14:49 <aCube> merijn, but when you get lots of addFoo, addBar, ... functions?
09:15:09 <Eduard_Munteanu> But here they're all related in the same type.
09:15:22 <merijn> aCube: Parameterise them by making the Foo/Bar an additional argument?
09:15:52 <Eduard_Munteanu> (so both 'b's match for example)
09:16:01 <merijn> aCube: I've never really had to implement my own typeclasses, except when I was doing type-level programming
09:16:03 <fizbin> Eduard_Munteanu: I was thinking that my two functions were (a -> b) and (b -> a). And they were, sort of, but the "b" there was a polymorphic type.
09:16:21 <czro_> peekElemOff and pokeElemOff in an imperative loop on the underlying storage? Feels dirty...
09:16:50 <Eduard_Munteanu> fizbin: rewrite that as   foo :: a -> b    bar :: c -> d
09:16:57 <merijn> czro_: Maybe read them to list, convert list to vector, convert vector back to Ptr?
09:17:11 <Eduard_Munteanu> fizbin: you're free to rename variables
09:17:26 <merijn> There was a "Storable a => Int -> Ptr a -> [a]" function or something like that
09:17:40 <fizbin> Eduard_Munteanu: So when I try to combine them in the order (b -> a) . (a -> b) then it would blow up, because the "b" is polymorphic and wouldn't match properly.
09:17:54 <aCube> merijn, but isn't one point of typeclasses to remove that boilerplate, so that i.e. not every container type needs a traverseVector, traverseMap, ... function?
09:18:32 <fizbin> When I combine them in the opposite order though it works and I get the type (forall s1. ST s1 (STUArray s1 Int Word8)) -> ST s (STUArray s Int Word8)
09:18:40 <merijn> aCube: Yes, but there's not many sensible things that aren't already covered by those :p
09:19:46 <merijn> aCube: What I'm said referred to defining your own classes, not to implementing instance for existing classes, that's perfectly expected, of course
09:20:37 <aCube> :t let x = undefined :: a -> b; y = undefined :: (forall b. b -> Int) -> Int in y . x
09:20:40 <lambdabot> a -> Int
09:20:42 <merijn> aCube: If in doubt you could always ask here "Is this a stupid thing to do using typeclasses"?
09:21:27 <Eduard_Munteanu> aCube: again, you do realize there's no such x, right?
09:21:29 <merijn> aCube: The reason for this being considered an antipattern is that many newcomers define lots ot typeclasses with all sorts of accessors as a sort of "ghetto OO"
09:21:44 <merijn> Eduard_Munteanu: Sure there is :)
09:21:48 <merijn> undefined :>
09:21:51 <Eduard_Munteanu> @hoogle unsafeCoerce
09:21:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:21:52 <aCube> merijn, ah ok.
09:21:52 <Eduard_Munteanu> :)
09:22:00 <merijn> Also, "let x = x in x"
09:22:22 <aCube> :t let x = undefined :: a -> b; y = undefined :: (forall b. b -> Int) -> Int in y . x -- Isn't this what fizbin had in his code?
09:22:25 <lambdabot> a -> Int
09:22:33 <cschneid> merijn: what's the best way to combine interfaces? ie, in other code I may have a list of [Maybe Int] and [Int] and either way I want to sum it (with its own semantics). ideally without remembering the maybe version is called maybeSum.
09:22:45 <Eduard_Munteanu> aCube: no, it was certainly less polymorphic
09:23:09 <aCube> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int -> Int) -> Int in y . x
09:23:11 <lambdabot>     Couldn't match expected type `forall s. ST s Int -> Int'
09:23:11 <lambdabot>                 with actual type `ST s0 Int'
09:23:11 <lambdabot>     Expected type: Int -> forall s. ST s Int -> Int
09:23:12 <cschneid> merijn: so just from a programmer speed point of view, "I have a list of numberish things, and want to sum em" seems like a useful idea (extrapolated to app-specific kinds of work, not just sums)
09:23:12 * typoclass thinks "ghetto OO" is a very cute way of putting it. kudos.
09:23:37 <fizbin> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int -> Int) -> Int in x . y
09:23:39 <lambdabot> (forall s1. ST s1 Int -> Int) -> ST s Int
09:23:41 <aCube> cschneid, make those "numberish" things an instance of Num?
09:23:50 <Eduard_Munteanu> That's not right.
09:23:53 <merijn> cschneid: Numberish things should be an instance of Num (if they're actual numbers)
09:24:03 <merijn> cschneid: Otherwise, it's trivial to define it using foldl/r
09:24:15 <Eduard_Munteanu> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int) -> Int in y . x
09:24:17 <lambdabot>     Couldn't match expected type `forall s. ST s Int'
09:24:17 <lambdabot>                 with actual type `ST s0 Int'
09:24:17 <lambdabot>     Expected type: Int -> forall s. ST s Int
09:24:24 <Eduard_Munteanu> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int) -> Int in x . y
09:24:26 <lambdabot> (forall s1. ST s1 Int) -> ST s Int
09:24:29 <Eduard_Munteanu> See?
09:24:35 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int -> Int) -> Int in y . x -- Why does this fail? I still don't get it
09:24:37 <lambdabot>     Couldn't match expected type `forall s. ST s Int -> Int'
09:24:37 <lambdabot>                 with actual type `ST s0 Int'
09:24:37 <lambdabot>     Expected type: Int -> forall s. ST s Int -> Int
09:24:39 <fizbin> So yeah, that captures the pattern. One way of compose fails because polymorphic weirdness, but the other way works.
09:24:50 <merijn> cschneid: For example, consider I want to "sum" lists, right (granted this already exists, but it's a nice simple example!)
09:24:51 <typoclass> cschneid: catMaybes? it fetches all the Just's from a list of Maybe
09:24:57 <aCube> x returns forall s. ST s Int, and y takes forall s. ST s Int
09:25:01 <merijn> :t foldl (++) []
09:25:02 <lambdabot> [[a]] -> [a]
09:25:16 <merijn> Wanna combine other things?
09:25:18 <aCube> :t mconcat
09:25:21 <lambdabot> Monoid a => [a] -> a
09:25:27 <aCube> :t Sum
09:25:28 <Eduard_Munteanu> aCube: the actual type is less polymorphic than needed, because of monomorphic instantiation
09:25:29 <lambdabot> a -> Sum a
09:25:32 <fizbin> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int -> Int) -> Int in (\z -> y (x z))
09:25:34 <lambdabot>     Couldn't match expected type `ST s Int -> Int'
09:25:34 <lambdabot>                 with actual type `ST s0 Int'
09:25:34 <lambdabot>     In the return type of a call of `x'
09:25:36 <merijn> :t foldl (undefined :: Foo -> Foo -> Foo) (undefined :: Foo)
09:25:38 <lambdabot> Not in scope: type constructor or class `Foo'
09:25:38 <lambdabot> Not in scope: type constructor or class `Foo'
09:25:38 <lambdabot> Not in scope: type constructor or class `Foo'
09:25:41 <merijn> bah
09:25:54 <merijn> :t foldl (undefined :: a -> a -> a) (undefined :: a)
09:25:55 <lambdabot> [b] -> b
09:25:59 <Eduard_Munteanu> aCube: so x returns a ST s Int for a fixed 's'.
09:26:14 <aCube> Eduard_Munteanu, thanks, got it
09:26:28 <merijn> cschneid: If you use it a lot, you can make a definition in you module "mySum = foldl f zero"
09:26:42 <fizbin> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int) -> Int in x . y
09:26:43 <lambdabot> (forall s1. ST s1 Int) -> ST s Int
09:26:51 <cschneid> merijn: I suppose my underlying question is better answered by looking at real applications written in haskell. But unfortunately most real apps dive so deep into more complex types it goes over my head. Is there a good app I can read that isn't super complex?
09:27:01 <fizbin> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int) -> Int in (\z -> y $ x z)
09:27:03 <lambdabot> Int -> Int
09:27:07 <cschneid> merijn: the design & structure of non-trivial programs is always a hurdle of learning a new language.
09:27:08 <aCube> The operation "combine things" sounds like a Monoid for me.
09:27:34 <fizbin> The radically weird part for me is that (\z -> y $ x z) works.
09:28:03 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int -> Int) -> Int in (\z -> y $ x z)
09:28:05 <lambdabot>     Couldn't match expected type `ST s Int -> Int'
09:28:05 <merijn> cschneid: Xmonad maybe?
09:28:05 <lambdabot>                 with actual type `ST s0 Int'
09:28:05 <lambdabot>     In the return type of a call of `x'
09:28:09 <typoclass> cschneid: if you have some code you can always hpaste it and ask people in here
09:28:14 <merijn> cschneid: Last I checked it was only about 1200 LOC?
09:28:15 <fizbin> Because Eduard_Munteanu's explanation that "x returns ST s Int for some specific s" doesn't explain why (\z -> y $ x z) works.
09:29:04 <ab9rf> i still haven't figured out how to do a GUI in haskell
09:29:11 <Eduard_Munteanu> fizbin: ($) is special
09:29:19 <fizbin> Also, hey. Aren't the type (Int -> ST s Int) and (Int -> (forall s. ST s Int)) supposed to be the same?
09:29:24 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int -> Int) -> Int in (\z -> y $ x z) -- Doesn't work?
09:29:25 <lambdabot>     Couldn't match expected type `ST s Int -> Int'
09:29:25 <lambdabot>                 with actual type `ST s0 Int'
09:29:25 <lambdabot>     In the return type of a call of `x'
09:29:29 <cschneid> back to day-job, thanks for helping me out merijn / everybody
09:29:31 <typoclass> ... but yeah, i wish we had a mid-size program that we could direct everyone to. xmonad is decent, but maybe not optimal
09:29:57 <Eduard_Munteanu> fizbin: yes...
09:30:06 <fizbin> And yet this works:
09:30:14 <Eduard_Munteanu> ab9rf: gtk2hs seems reasonable
09:30:19 <cschneid> typoclass: my problem is that most "real" apps by necessity have to use a wide swath of haskell to get their job done, so it's hard for me as an advanced newbie to wrap my head around some of the fancier parts, especially when it's not annotated with what's going on.
09:30:25 <cschneid> typoclass: since it's just not written as a tutorial program
09:30:27 <fizbin> :t let x = undefined :: Int -> ST s Int; y = undefined :: (forall s. ST s Int -> Int) -> Int in (\z -> y $ x z)
09:30:28 <lambdabot>     Couldn't match expected type `ST s Int -> Int'
09:30:29 <lambdabot>                 with actual type `ST s0 Int'
09:30:29 <lambdabot>     In the return type of a call of `x'
09:30:38 <fizbin> Oh, wait. hold on...
09:30:47 <merijn> cschneid: Maybe some elaborate xmonad configurations would also work as examples
09:30:48 <Eduard_Munteanu> Too many Ints. :)
09:30:58 <ab9rf> Eduard_Munteanu: i haven't gotten that t work on my system yet
09:31:04 <ab9rf> Eduard_Munteanu: to be fair, i haven't tried very hard
09:31:14 <Eduard_Munteanu> ab9rf: Windows perhaps? I remember having a bit of trouble getting it to work.
09:31:16 <typoclass> cschneid: absolutely true. i do think there's a need for that. a few programs for reading, well written and well designed, about 100 lines
09:31:20 <ab9rf> Eduard_Munteanu: and i suspect that the main problem there is windows, rather than haskell
09:31:25 <Eduard_Munteanu> Eh.
09:31:32 <ab9rf> Eduard_Munteanu: i got SDL to work a few nights ago, at least
09:31:43 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int in (\z -> y $ x z)
09:31:44 <lambdabot> Int -> Int
09:31:52 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int in y . x
09:31:53 <lambdabot>     Couldn't match expected type `forall s. ST s Int'
09:31:54 <lambdabot>                 with actual type `ST s0 Int'
09:31:54 <lambdabot>     Expected type: Int -> forall s. ST s Int
09:31:57 <aCube> that's it :D
09:32:08 <cschneid> typoclass: anyway, I'd be interested if you run across any, I'll go check out xmonad too. I know there are some articles on its design out there
09:32:17 <Eduard_Munteanu> Again, ($) is handled differently by GHC, it's special.
09:32:33 <aCube> Eduard_Munteanu, and ordinary function application too?
09:32:34 <ab9rf> Eduard_Munteanu: how is ($) special in GHC?
09:32:37 <fizbin> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int in (\z -> y (x z)) — look, no ($)
09:32:37 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
09:32:42 <Eduard_Munteanu> They do some trick like  (\z -> y $ x z)  ==>  (\z -> y (x z))
09:32:46 <fizbin> Stupid cut-and-paste.
09:33:06 <Eduard_Munteanu> aCube: ordinary function application isn't an operator, there's nothing to instantiate
09:33:38 <fizbin> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int in (\z -> y (x z))
09:33:39 <lambdabot> Int -> Int
09:33:51 <Eduard_Munteanu> Yup, totally expected. :P
09:34:12 <fizbin> Eduard_Munteanu:  Okay, you've said that before. I don't understand what you mean by "there's nothing to instantiate"
09:34:18 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int in (\z -> y $ x $ y $ x z)
09:34:20 <lambdabot> Int -> Int
09:34:44 <Eduard_Munteanu> fizbin: (.) is a function which takes two arguments. You must instantiate those type variables.
09:35:10 <Eduard_Munteanu> :t (.)
09:35:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:35:18 <ab9rf> Eduard_Munteanu: so GHC never actually invokes ($), it gets treated as a sort of sugar instead?
09:35:19 <fizbin> Eduard_Munteanu: Okay. Don't I need to instantiate the type of (x z) in the function application?
09:35:42 <aCube> fizbin, in the function application, it's forced to be polymorphic by y
09:36:14 <Eduard_Munteanu> ab9rf: dunno the details :/
09:36:38 <ab9rf> Eduard_Munteanu: ah, oh well :)
09:37:19 <aCube> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int; (.') = undefined :: (forall s. ST s Int -> Int) -> ST s Int -> Int  in y .' x
09:37:20 <lambdabot> parse error on input `)'
09:39:45 <Eduard_Munteanu> :t let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int; apply = ($) in (\z -> apply y (x z))
09:39:47 <lambdabot>     Couldn't match expected type `forall s. ST s Int'
09:39:47 <lambdabot>                 with actual type `ST s0 Int'
09:39:47 <lambdabot>     In the return type of a call of `x'
09:39:50 <aCube> @ty let x = undefined :: Int -> (forall s. ST s Int); y = undefined :: (forall s. ST s Int) -> Int; combine = undefined :: a -> (Int -> forall s. ST s Int) -> Int -> Int  in y `combine` x
09:39:52 <lambdabot> Int -> Int
09:40:00 <Eduard_Munteanu> ab9rf, fizbin: you may find that interesting ^^
09:40:37 <ab9rf> Eduard_Munteanu: interesting
09:40:44 <aCube> Eduard_Munteanu, wow, that rule confuses everything :P
09:40:49 <Eduard_Munteanu> So it is some sort of ugly hack.
09:41:07 <aCube> Very ugly
09:43:33 <Eduard_Munteanu> However it is useful when you do stuff like    runST $ do    [continue on the following lines]
09:43:46 <Eduard_Munteanu> Otherwise you'd have to wrap it in some ugly parens.
09:44:34 <Eduard_Munteanu> > runST $ return 5
09:44:35 <lambdabot>   5
09:44:44 <Eduard_Munteanu> > (runST . return) 5
09:44:46 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s c0'
09:44:46 <lambdabot>              with a...
09:46:01 <Eduard_Munteanu> > (runIdentity . return) 5
09:46:05 <lambdabot>   5
09:46:18 <Eduard_Munteanu> (in case you had doubts :P)
09:47:49 <betfan> http://tinyurl.com/c3cvxz3   best soccer tips site... i`ve bought from them
09:49:28 <ab9rf> wonder if that site runs on haskell
09:50:06 --- mode: ChanServ set +o geekosaur
09:52:07 <geekosaur> oh, missed idoru
09:52:09 --- mode: geekosaur set -o geekosaur
10:06:35 <pygmalion> Can someone point be to the most popular/supported linear algebra library for Haskell? I've gotten lost in a maze of old mailing list threads.
10:07:51 <HugoDaniel> pygmalion: whats the use case ?
10:08:56 <DMcGill> I'm using hmatrix for my project, it's a set of bindings to GSL
10:09:48 <DMcGill> it doesn't have the type safety of some of the others (i.e. there's just a type `Matrix Double' when some others have the sizes encoded in the types)
10:10:06 <pygmalion> HugoDaniel: I need to implement some matrix decompositions. I just need basic operations like matrix-matrix multiplication, matrix-vector multiplication, computing the norm, etc.
10:10:23 <pygmalion> DMcGill: I'll check it out, thanks.
10:11:44 <HugoDaniel> pygmalion: how big are the matrices ?
10:11:53 <HugoDaniel> 4x4 at most ?
10:12:22 <pygmalion> HugoDaniel: No, they could be larger than that.
10:12:52 <pygmalion> HugoDaniel: e.g. 20x20
10:13:23 <DMcGill> GSL is sounding like a better and better idea tbh
10:20:06 <gspr> pygmalion, DMcGill: AFAIK hmatrix does its linear algebra using BLAS and LAPACK. GSL is only used for the optimization stuff, I think.
10:22:19 <gspr> pygmalion: I've found hmatrix pleasant to work with.
10:24:53 <DMcGill> that sounds about right gspr, GSL is also used for the ods stuff iirc
10:25:03 <DMcGill> s/ods/ode
10:45:34 <refold> @seen kosmikus
10:45:34 <lambdabot> Unknown command, try @list
10:46:54 <refold> @version
10:46:54 <lambdabot> lambdabot 4.2.2.1
10:46:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:47:40 <refold> @list
10:47:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:49:21 <typoclass> refold: "seen" is provided by another bot. which apparently is not here today. but you could check ircbrowse, it has a search function
10:50:30 <refold> typoclass: thanks
11:06:59 <m4b> is there a typeclass where instance declarations allow the use of &&, ||, i.e.; a boolean typeclass?  There does not seem to be one, which is puzzling, since every other significant algebraic structure from group theory seems represented in some way by typeclasses.
11:09:44 <quchen> m4b: There's a package for that on Hackage.
11:09:45 <Kinnison> boolean is a type
11:09:54 <Kinnison> oh, ick :-)
11:09:55 <m4b> Kinnison: Bool is a type
11:09:58 * Kinnison heads off
11:10:07 <Kinnison> m4b: Bool is certainly the name of the boolean type :-)
11:10:12 <quchen> @hackage boolean
11:10:12 <lambdabot> http://hackage.haskell.org/package/boolean
11:10:13 * Kinnison really does head off :-)
11:10:22 <quchen> @hackage Boolean
11:10:22 <lambdabot> http://hackage.haskell.org/package/Boolean
11:10:27 <quchen> Pardon.  That one.
11:12:24 <typoclass> @type and
11:12:26 <lambdabot> [Bool] -> Bool
11:12:38 <m4b> guchen: thank you; I'm just curious why this isnt apart of the standard implementation? +, -, /, etc., all have supporting typeclasses, yet &&, ||, dont
11:13:04 <typoclass> so, i wouldn't be able to use 'and' or that kind of thing on those Boolean instances i defined, using package Boolean
11:14:02 <typoclass> m4b: could you tell us more about your use case? you have custom data's and you want to define some functions (&&, ||) on them?
11:14:39 <quchen> m4b: Well there's a very limited amount of things that act like Bool.
11:14:54 <m4b> quchen: you could make the same argument for numbers
11:15:17 <m4b> quchen: if your structure is idempotent, you'd probably want to have access to &&, ||, etc.
11:16:18 <quchen> I don't think idempotency is very relevant here.
11:16:21 <m4b> typoclass: I was just curious, since it seems very natural to have a typeclass for Booleans
11:16:43 <quchen> Suppose you have a matrix M with M^3 = E. How would "||" look like for this?
11:16:50 <quchen> What would be the laws defining the type class?
11:16:51 <m4b> quchen: idempotency is completely relevant for anything in a boolean group; A ∧ A = A
11:17:07 <typoclass> m4b: i'm not saying that the current state of haskell has excellent reasons that convince everyone :-) but on the other hand, i'm also not convinced that a hypothetical typeclass Boolish is useful. couldn't you define a converter function toBool for your data type and use the regular && from Prelude?
11:17:13 <m4b> quchen: oh boy; just look up the laws for a boolean group
11:17:17 <elliott> boolean algebras are a well-defined concept, guys
11:17:27 <m4b> elliott: thank you
11:18:35 <kosmikus> refold: pong?
11:18:54 <refold> kosmikus: hi
11:18:55 <quchen> Well then maybe don't call it "idempotent" because that's a very widely used term in math. Call it "boolean algebra" for example.
11:18:56 <johnw> typoclass: there are at least two packages I know of that provide a Boolish
11:19:31 <elliott> quchen: m4b was not equating idempotency and boolean algebras...
11:19:44 <johnw> cond is one
11:19:50 <applicative> RebindableSyntax has a special rule for if ... then ... else ....
11:20:14 <refold> kosmikus: Can you file a ticket about the relative path bug with shared sandboxes that you told me about yesterday?
11:20:22 <johnw> Boolean is the other
11:20:23 <m4b> elliott: heh, thank you again
11:20:23 <typoclass> johnw: yes, but why? what would you use that for? so far, the discussion seemed to be only on the level of "it's popular in math, so we need a typeclass for that" :-)
11:20:30 <quchen> elliott: Well then I misunderstood " if your structure is idempotent, you'd probably want to have access to &&, ||, etc."
11:20:51 <refold> kosmikus: I tried reproducing it today but failed.
11:21:03 <johnw> typoclass: you mean, why have a Boolean type class instead of taking taking a Bool argument?
11:22:16 <typoclass> johnw: i'm unclear on what m4b is planning. i was wondering what rules out a function "toBool :: Foobar -> Bool"
11:22:26 <johnw> yeah
11:22:32 * applicative hadn't noticed humanity grasping to overload || and && quite the way they do + and - and  1 2 3
11:22:44 <elliott> why do we have Monoid?
11:22:54 <m4b> exactly
11:23:05 <elliott> because it encapsulates an operation many types of data have, with laws
11:23:21 <applicative> Monoid is among the most easily mocked classes in the standard libraries
11:23:21 <kosmikus> refold: perhaps I mis-diagnosed the problem. I can try to reproduce it, but it'll have to wait until tomorrow.
11:23:21 <elliott> you can argue about how commonly useful a boolean algebra class would be, but that doesn't mean it's not as meaningful
11:23:43 <m4b> typoclass: I see your point; and I don't think I'm saying "it's popular in math, so..."
11:23:46 <elliott> applicative: well, I couldn't exactly use Num as an example :)
11:23:47 <refold> kosmikus: no problem. thanks.
11:23:49 <johnw> elliott: I hear you; do you have any idea why having a boolean abstraction isn't more popular?
11:23:56 <typoclass> elliott: yes, that's what i mean. "commonly useful" is the question here
11:23:59 <elliott> applicative: Monad would be perhaps better, but is more to the CT side of things
11:24:04 <applicative> for the reason that every type supports a monoid instance on the one condition that it is not e mpty
11:24:11 <elliott> johnw: probably because it just doesn't come up much
11:24:21 <Eduard_Munteanu> Yeah, especially given black and white thinking is so popular. :P
11:24:36 <applicative> elliott: m4b was using Num as his example, thats what puzzled me
11:25:15 <elliott> I agree that "ad hoc overloading of various operations that just happen to involve Bool" would be awful, but I don't think that's what's being queried about here
11:25:46 <applicative> yes, but sensible people keep inquiring what is being queried about here
11:26:17 <hackedy> metaqueries, if you will
11:26:33 <applicative> hm I recommend this one https://github.com/tomlokhorst/AwesomePrelude/blob/master/src/Generic/Data/Bool.hs
11:26:44 <elliott> [insert some nonsense about queries forming a monad]
11:26:49 <Sixstix> is there a way or a program to get syntax highlited haskell code into a pdf?
11:26:51 <m4b> applicative: boolean algebras are a well understood structure; &&, ||, are "built-in" operators.  Similarly, +, -, etc., are
11:27:36 <applicative> I think the trouble is partly that 'generalized boolean', could go about 4000 different directions, many of which actually do show up in familiar libraries
11:27:55 <applicative> thus in Data.Set there is union, intersection, etc etc.
11:27:57 <m4b> "built in" operators; now it may not "find much use", but it seems relatively easy to have boolean typeclass to support overload, if necessary, and I was just wondering why it isn't present, in the standard implementation, is all.
11:28:28 <applicative> m4b: && and || are NOT built in.
11:28:31 <Botje> Sixstix: off the top of my head; a2ps, vim :hardcopy, or latex with \usepackage{listings}
11:28:53 <m4b> applicative: heh, ok.
11:29:35 <applicative> the only relevant builltin thing is if then else, and the only possible objection is resolved with RebindableSyntax
11:29:36 <Sixstix> thanks, I think I'm going to try latex
11:29:40 <m4b> they're part of the prelude, is what i meant.
11:30:19 <applicative> even True and False are defined terms
11:30:29 <Sixstix> 1,3gb...
11:30:31 <m4b> so are +, -, etc.
11:30:55 <Botje> Sixstix: if you don't know latex or don't have it installed, go with a2ps instead.
11:31:16 <hiptobecubic> @src sequence
11:31:17 <lambdabot> sequence []     = return []
11:31:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:31:17 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:31:18 <Sixstix> I'll need it for math class anyway
11:31:21 <typoclass> m4b: i think it's largely because of "do the simplest thing that could possibly work, at least until it becomes clear that the more elaborate thing is necessary". usually "the simplest thing" means functions, not typeclasses
11:31:22 <Sixstix> so why not
11:31:41 <Botje> because latex *ducks*
11:32:19 <m4b> typoclass: yea for sure; similarly, it could be argued map is present because a beginning user doesnt want to see weird messages about Functor
11:33:02 <arbn> I wish map and fmap had a name that encouraged the one-parameter interpretation more. :/
11:33:12 * arbn loves to bitch about Haskell naming conventions.
11:33:28 <Sixstix> is it difficult to learn?
11:33:51 <Botje> no
11:33:51 <typoclass> applicative: could you elaborate on the connection between a generalized Bool and Data.Set.union or intersection?
11:34:04 <applicative> Sixstix: no, but it sort of keeps going and eats up your entire life ...
11:34:07 <typoclass> arbn: how do you mean one-parameter interpretation?
11:34:09 <Botje> it just has a will of its own :)
11:34:09 <Eduard_Munteanu> They're both lattices?
11:34:39 <m4b> typoclass: there is a classic connection between union, boolean or, and intersection, boolean and
11:34:51 <applicative> typoclass: what are the the operations we expect of a 'boolean algebra', or which are suggested by the words George Boole?
11:35:17 <arbn> typoclass: Err. Single application, due to currying, is kind of a prettier concept in my mind. Petty aesthetic complain. I think fmap as lifting a single function to one on f.
11:35:31 <arbn> complaint*
11:35:55 <m4b> applicative: i'm not sure if your question is rhetorical, but again, it sounds like you might not realize a boolean algebra is a very well-defined structure
11:36:08 <applicative> the use of the word 'boolean' for what Frege called the truth values rests on an interpretation of terms in boole's calculus as propositions, rather than concepts, sets, whatever
11:36:14 <typoclass> arbn: right :-) we all agree partial application is useful and looks good
11:36:43 <Cale> What's wrong with fmap in that regard?
11:36:59 <m4b> oh no Frege was dropped ;)
11:37:16 <Chousuke> I was thinking about Functors today. in Haskell's case, fmap is the operation that maps morphisms, right?
11:37:17 <applicative> dropped? never!
11:37:20 <lysgaard> Is there support for type level natural numbers in Haskell now?
11:37:20 <lambdabot> lysgaard: You have 1 new message. '/msg lambdabot @messages' to read it.
11:37:25 <m4b> *name dropped
11:37:31 <jfischoff> Chousuke: yes
11:37:41 <Chousuke> so is the type constructor that is a Functor the operation that maps the objects?
11:37:47 <jfischoff> yes
11:37:48 <arbn> It's just that, to me, "fmap" sounds more like a two-parameter interpretation. Mapping the function across some structure, as opposed to lifting the function to one on structures.
11:37:49 <applicative> hah I never think of anything else
11:37:50 <Jeanne-Kamikaze> I'm running a program with +RTS -hc but the output chart only shows the first 3 seconds of execution time, or at least the x axis only goes up to 3; any idea what's going on ?
11:38:36 <Chousuke> jfischoff: thanks for the confirmation
11:38:46 <applicative> lysgaard: yes, though they might not have the calculational properties -- or possiblities of proof -- you might be looking for
11:38:57 <jfischoff> Chousuke: np I just went through the same exercise :)
11:39:17 <Cale> arbn: You could choose to read it as "functor on maps"
11:39:44 <Chousuke> I'm thinking of writing something about what I understand about Haskell and its various abstractions just to make sure I can explain to myself what they are
11:40:02 <Chousuke> might take a while before I have something I'd dare show to other people though.
11:40:52 <h4199> as long as you don't publish a monad tutorial at the end, go for it :P
11:40:55 <arbn> Cale: Hm. I suppose so.
11:41:30 <Cale> (I realise that this is etymologically disingenuous ;)
11:41:30 <typoclass> applicative: you mean that we need something like "class Boolish where (&&) :: ... (||) ...; instance Boolish Bool where ...; instance Boolish Data.Set where (&&) = intersection; (||) = union"
11:41:35 <jfischoff> Chousuke: I would just show it. Get any misunderstandings cleared up
11:41:40 <Chousuke> h4199: well, it'd probably have a section on monads too. But I'm not going to make any analogies at least.
11:42:00 <applicative> m4b: you might find the Absolute Master amusing here's a decent starting point http://www.scribd.com/doc/52327095/Frege-Foundations-of-Arithmetic
11:42:37 <applicative> typoclass: well, we would want to know more what the person was thinking under the heading of 'Boole' but why not?
11:42:38 <m4b> typoclass: well &&, not, are functionally complete
11:43:13 <lysgaard> applicative: I want to encode matrix dimension in a matrix datatype. Standard linear algebra stuff
11:43:15 <h4199> Chousuke: I agree, sometimes you don't know that you don't know until you try to explain it to someone, even if that person is yourself
11:43:20 <m4b> typoclass: so you'd maybe have something like: a && b = not ((not a) || (not b))
11:43:49 <m4b> in this way, you could implement n-valued logics, etc.
11:43:51 <typoclass> m4b: well i left out 'not' because i don't know how to implement this for Data.Set :-)
11:44:17 <applicative> lysgaard: I'm not sure anyone has been bold enough to try it yet. There are a million implementations of the poster child to type level nats, the fixed length vector
11:44:35 <typoclass> applicative: ok fair enough! i need to think about this a little
11:45:08 <Chousuke> h4199: I started by trying to explain Category to myself and couldn't even think of any examples besides -> and Kleisli :P
11:45:14 * applicative meant 'the poster child of type level nats' .. which is still mildly illiterate
11:46:15 <m4b> applicative: thanks for the link; but most of his views on logic are a bit... antiquarian, arent they?  Not many logicists left; moreover, all of the model theorists views are generally accepted as a better approach
11:46:15 <coburrito> Chousuke: In Haskell, I find it's easier to think of things that could be implemented using Arrow, and then you get the Category implementation from that.
11:46:39 <Chousuke> Are there any languages which allow you to use number literals at the type level?
11:47:07 <byorgey> Chousuke: yes, there's one called "Haskell" ;)
11:47:18 <lysgaard> applicative: Do you have any link, reference on type level nats fro Hasklel?
11:47:29 <Chousuke> Every dependent typing tutorial just does heterogeneous list or fixed length vectors and the Nat implementation always looks extremely cumbersome.
11:47:38 <typoclass> Prelude.and would probably come out as :: (Boolish b) => [b] -> b . for a list of Data.Set, it'd get you the guys that are contained in every one of the Sets. i guess that's something
11:47:51 <applicative> m4b, no not at all, his developed system is much closer to the ideas implicit in 'functional programming' and the associated literature than any logician since. He invented lambda abstraction, currying, on and on
11:47:59 <applicative> to say nothing of the quantifiers!
11:48:00 <elliott> typoclass: aka "interections"
11:48:02 <elliott> *intersections
11:48:11 <Eduard_Munteanu> Chousuke: why are Nats awkward?
11:48:25 <m4b> applicative: which developed system, the begriffsherifft (bad spelling)?
11:48:26 <Eduard_Munteanu> Chousuke: I think the inductive definition is rather useful
11:48:28 <applicative> he invented higher order logic on the same day he invented modern logic
11:48:42 <m4b> applicative: same could be said for C.S. Peirce; in fact, add modal logics to that as well
11:48:49 <applicative> m4b things like currying are only in the Grundgesetze
11:48:51 <Chousuke> Eduard_Munteanu: besides the fact that you get succ succ succ succ whatever everywhere?
11:49:04 <applicative> all of higher order logic is in Begriffschrifft 1879
11:49:07 <Chousuke> the definition is useful, but it's not exactly a good user experience :P
11:49:12 <typoclass> elliott: do we have that? i see only unions in Data.Set
11:49:25 <m4b> applicative: his system, at least the one I'm familiar with, was 2-dimensional, and no one uses it anymore; everything tin modern logic is descended from the notation in the Principia
11:49:27 <Eduard_Munteanu> Chousuke: Agda lets you use number literals which get translated to succ / zero stuff
11:49:30 <byorgey> Chousuke: you very rarely want to write literal values greater than one.
11:49:31 <elliott> oh, maybe not.
11:49:40 <typoclass> elliott: but yeah :-) it's clear enough what you meant, whether it exists in current versions or not
11:49:42 <applicative> m4b frege antedates all these things, there is really no comparison
11:49:46 <Chousuke> byorgey: you might see those in type errors though
11:49:46 <byorgey> Chousuke: but yes, Agda lets you do this, and also Haskell now does as well.
11:49:51 <byorgey> Chousuke: true.
11:50:07 <m4b> applicative: again, C.S. Peirce, but his work was unpublished
11:51:37 <applicative> m4b: his notation is two dimensional, yes what does that have to do with anything, the basic system is parenthesis free for example and immediately expresses the tree form of the thought or judgment
11:52:40 <applicative> m4b there is nothing in Peirce bless him, to compare.  It is like comparing creator and creature
11:52:53 <m4b> applicative: ok. that's fine.  just his views on arithmetic are logicist; no one takes logicism seriously anymore.  moreover, he was a universalist; godel, tarski, pioneered the model theoretic viewpoint which isgenerally agreed to be the correct way to think about things
11:53:25 <applicative> m4b: you are expressing a standpoint characteristic of maybe the sixties
11:53:26 <m4b> applicative: not saying his contributions weren't immense; but his philosophical views on mathematics and logic are essentially dead
11:53:52 <applicative> m4b: Alonzo Church did nothing but read Frege from the minute he discovered him until his death
11:53:57 <m4b> applicative: is that a fallacy of origins I hear?
11:54:09 <Chousuke> are you sure "Peirce" is not a typo? A name like that would bother me.
11:54:19 <m4b> Chousuke: not a typo
11:54:39 <applicative> Church's works after sometime circa 1940 are all defense and interpretations and modernizations of his Master
11:54:54 <applicative> Chousuke: it's weird but correct
11:55:08 <m4b> applicative: that's cool.  Since you just capitalized his name, I think the discussion is over :P
11:55:09 <applicative> I mean, the spelling of the logician/philosopher's name
11:55:49 <m4b> applicative: I actually need to go, but more seriously, good discussion :)
11:55:55 <applicative> m4b: ? ok
11:56:21 <m4b> applicative: was just teasing, you obviously like Frege _a lot_ ;)
11:56:49 <applicative> m4b the literature on Frege from the last forty years is probably about 40 times as extensive as that on peirce or russell
11:57:12 <applicative> it isn't a personal eccentricity at all
11:57:26 <solrize_> is that because of van heijenoort?
11:57:49 <typoclass> ok with the hypothetical Boolish class, how would functions look that currently give back a Bool? e.g. even :: (Integral a) => a -> Bool. if i call "even x :: (Boolish Data.Set)", i'd get back a Set with zero members or one member?
11:57:52 <solrize_> wait, that thing about church is bogus
11:57:57 <applicative> It is just a curiosity of the computer science world that they don't know anything about Frege
11:58:07 <applicative> what thing?
11:58:12 <Eduard_Munteanu> typoclass: I don't think that's the point
11:58:25 <Eduard_Munteanu> typoclass: rather defining the operations of a boolean algebra
11:58:35 <philosophy> hi, i thought programming was about solving peoples problems, instead of creating more.
11:58:36 <Eduard_Munteanu> Which needn't correspond to truth.
11:58:38 <ab9rf> i've heard of frege :)
11:58:49 <Eduard_Munteanu> Or binary choice.
11:59:10 <applicative> people probably need more problems philosophy
11:59:18 <elliott> philosophy: if only!
11:59:24 <ab9rf> sometimes the solution to one problem is two new problems :)
11:59:35 <elliott> philosophy: why, has Haskell disappointed you? :p
11:59:41 <ab9rf> and besides, if we solved all of our problems, we'd have nothing to do on thursdays
11:59:52 <johnw> elliott: that reads funny, if you think of it as you asking the discipline of philosophy itself :)
11:59:57 <dEPy> any1 that know javascript also can check this out this code for monoid lists and tell me if this makes any sense? http://jsfiddle.net/depy/5R859/1/
12:00:04 <Eduard_Munteanu> Good thing trolling solves problems. :)
12:00:07 <typoclass> Eduard_Munteanu: things usually don't make sense to me until i have some examples :-/ i was going through Prelude and trying to figure out how things would be influenced by the Boolish class, in particular by instance Boolish Set
12:00:08 <Chousuke> It seems to me that in haskell when you solve a problem your next problem is figuring out whether you can use what you just learned to solve even more problems
12:00:10 <elliott> typoclass: a boolean algebra class would by no means rule out returning Bools
12:00:36 <elliott> typoclass: you might as well ask: if we define classes for numbers, what is sqrt 2 :: Integer?
12:00:38 <typoclass> elliott: sure
12:01:53 <Eduard_Munteanu> typoclass: http://en.wikipedia.org/wiki/Boolean_algebra_(structure)#Examples   see the 2nd example
12:01:58 <typoclass> elliott: for starters i'm assuming instance Boolish Bool, which means it'd all be as it is today, and instance Boolish Set. which i'm trying to think about
12:02:08 <philosophy> i'm confused.
12:02:14 <applicative_> solrize_: what was bogus, I didn't follow.
12:02:30 <applicative_> excellent state for someone with that nick
12:03:01 <philosophy> trying my hands on AI, Finance, Chess, Statisitcs seems the only way to use a langauge. or the most useful one.
12:03:14 <Eduard_Munteanu> typoclass: you might also want to consider lattices generally, to avoid getting stuck into the {0, 1} thing.
12:03:17 <philosophy> my nickname is an irony.
12:04:11 <dEPy> noone knows javascript? :S
12:04:21 <dEPy> Or my code just makes no sens ... O_
12:04:24 <applicative_> what to know.
12:04:48 <dEPy> I've posted something above..
12:05:00 <dEPy> this: makes any sense? http://jsfiddle.net/depy/5R859/1/
12:05:13 <ab9rf> who crossed the stream?
12:05:34 * hackagebot yesod-platform 1.1.9 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.9 (MichaelSnoyman)
12:06:02 <tac_> Heyting Algebras 4 Lyf
12:06:23 <FireFly> dEPy: doesn't that make more sense to ask in ##javascript?
12:06:46 <dEPy> FireFly, usually people there don't see past DOM :S
12:06:53 <typoclass> dEPy: hi, you seem to be calling mappend sometimes as mappend([12]) and sometimes as mappend(12). i don't exactly if those are interchangeable in javascript
12:06:55 <FireFly> :|
12:07:01 <applicative_> dEPy: everyone is savage with people who try to find a monad or functor in javascript, but monoid I think they'd be hard pressed to keep to themselves
12:07:06 <philosophy> can hakshell be used in the field to make real world applications?
12:07:12 <FireFly> dEPy: I'd love if we'd get less DOM questions and more like this
12:07:29 <jfischoff> philosophy: yes
12:07:29 <typoclass> philosophy: haskell is a general-purpose language, yes
12:07:34 <FireFly> The problem is that everyone seems to think that it's all about the DOM, so we only get relatively boring DOM questions >.<
12:07:37 <dEPy> FireFly, unfortunately it's the other way around. :)
12:07:38 <Eduard_Munteanu> No, you can only use it at the headquarters. :P
12:07:44 <applicative_> in the field? no, you need a computer
12:07:52 <elliott> it is likely that the problems (if any) with this encoding are about details of JS, not details of monoids.
12:07:57 <dEPy> maybe that's the reason 99% of JS code stinks
12:07:59 <elliott> hence Haskellers are unlikely to be able to help.
12:08:03 <philosophy> isn't it slower than the rest? slower to code, runs at slower speeds?
12:08:04 <jfischoff> applicative_: um hello laptop
12:08:25 <applicative_> oh terribly slow, totally clunky
12:08:26 <jfischoff> philosophy: no
12:08:38 <philosophy> hmm
12:08:43 <applicative_> jfischoff: oh yeah I forgot that there are batteries
12:08:45 <Eduard_Munteanu> Luckily we're slow too so we don't notice.
12:09:01 <philosophy> ok
12:09:15 <philosophy> so whats the advantage in all that?
12:09:21 <Chousuke> haskell is so slow, it never actually does anything until you ask
12:09:32 <Eduard_Munteanu> Yeah... dat slow!
12:09:36 <philosophy> can I adopt this language in my firm? and cut costs?
12:09:40 <applicative_> there are lots of regular user apps in haskell, here's one that should come with every system http://johnmacfarlane.net/pandoc/index.html
12:09:57 <typoclass> philosophy: it's definitely among the faster languages. (for instance, haskell is not interpreted but compiled.) i'd argue that coding speed is also faster with haskell, if you count "time until you get a well-working solution". other language (dynamic languages) will be faster at "time until you get a non-working solution" :-)
12:10:09 <Eduard_Munteanu> I think PhDs cost more than run-of-the-mill programmers.
12:10:22 <Eduard_Munteanu> (not that I have one :P)
12:10:27 <applicative_> you mean, it costs a lot to get a PhD?
12:10:36 <typoclass> philosophy: that's a very broad question that depends a lot on what you do and what the employees are like
12:10:42 <Eduard_Munteanu> Erm, it costs more to employ people with PhDs.
12:10:47 <dEPy> typoclass, I'm always calling mappend on MonoidList, that's L2 and L3 that looks like 12 and 13 :D
12:10:50 <jfischoff> philosophy: what costs?
12:10:52 <philosophy> i see.
12:10:57 <RenJuan> employ them as what?
12:10:58 <Eduard_Munteanu> Unless they have a PhD in pure math, then they work really cheaply at McDonalds. :P
12:11:05 <philosophy> $/hours.
12:11:11 <applicative_> philosophy: youre employees will love it, don't tell them about it they'll get too interested
12:11:15 <philosophy> if hours reduce you cut costs.
12:11:19 <solrize_> http://the-27th-comrade.appspot.com/blog/ahJzfnRoZS0yN3RoLWNvbXJhZGVyDAsSBUVudHJ5GOFdDA
12:11:29 <philosophy> i see.
12:11:37 <solrize_>  My company uses Haskell, because we do not have much manpower. We do not get paid enough, so we take many contracts. We cannot afford QA teams, so we use a sadistic compiler. We cannot dedicate too much time to any particular project, so we prefer to learn dense idioms (which takes time upfront, and saves time later), rather than learn sparse idioms that take more time to implement every time and debug individually. We do not keep
12:11:38 <solrize_> a project in live mode after we have handed it over, due to little manpower, so any bugs that we have to cure at our own cost must be caught in development.
12:12:07 * Eduard_Munteanu wouldn't have trolled had he not noticed the first thing philosophy said upon joining the channel
12:12:11 <philosophy> we jst use CPP.
12:12:29 <typoclass> dEPy: oh yes. sorry. i misread l as 1 :-/
12:12:46 <typoclass> philosophy: CPP being the C preprocessor?
12:12:55 <Eduard_Munteanu> We use that too, hey!
12:13:09 <dEPy> see, 1min after I posted it on #javascript 1st question was what's wrong with regular array and 2nd answer was not to fight the language O_
12:13:11 <aristid> solrize_: somehow i find that account depressing
12:13:12 <philosophy> jst C++.
12:13:21 <solrize_> aristid it's a troll
12:13:22 <applicative_> philosophy: don't worry your employees can *still* use the cpp
12:13:39 * elliott wonders if someone is trying to save the world from evil servers...
12:13:41 <solrize_> http://projects.haskell.org/cpphs/
12:13:44 <applicative_> oh c++ ick
12:13:58 <philosophy> there has been a surge with haskell  but I dont understand it all so well so I came here to ask.
12:14:09 <typoclass> Eduard_Munteanu: yeah ... not in every file. and i guess when it's used, it's limited to a few ifdefs. in c it's more like, tons of includes, defines, macros, general weirdness
12:14:17 <aristid> solrize_: hmm i don't understand that troll then
12:14:21 * applicative_ surges 
12:14:28 <philosophy> is it scalable?
12:14:41 <elliott> solrize_: I just read that post as ignorance, not trolling, when I saw it.
12:14:44 <applicative_> webscale no question
12:14:47 <philosophy> like hmm you can program a giant software, use classes etc?
12:15:02 * aCube read scalable as scala ble
12:15:10 <johnw> philosophy: yes and yes
12:15:13 <applicative_> classes, jim, but not as you know them
12:15:26 <philosophy> ok
12:15:31 <johnw> what Haskell lacks is not really in the language itself
12:15:31 <Eduard_Munteanu> < philosophy> hi, i thought programming was about solving peoples problems, instead of creating more.
12:15:34 * hackagebot groundhog-mysql 0.3.0.1 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.3.0.1 (BorisLykah)
12:15:35 <Eduard_Munteanu> First thing he said.
12:15:36 <goodfellow>   mueval-core: Time limit exceeded
12:15:36 * hackagebot groundhog-postgresql 0.3.0.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.3.0.1 (BorisLykah)
12:16:11 <philosophy> I just don't understand it I will have to look into the language itself.
12:16:27 <johnw> philosophy: expect your research to take a little bit of time
12:16:42 <applicative_> if you want an easy to get hold of an example of an open source 'giant software' written in haskell try maybe https://github.com/ghc/ghc
12:16:58 <philosophy> It just sounds kinda magical beyond belief, they sa you can do these things that no other language can do but I don't know what.
12:16:59 <typoclass> philosophy: i suggest you try out some haskell :-) i think of it like vim (or emacs). it's a steep learning curve, but after some time you won't want to go back to anything else
12:17:02 <Eduard_Munteanu> acfoltzer: Scala *is* bleh! :P
12:17:03 <philosophy> well thanks anyways.
12:17:03 <typoclass> @where lyah
12:17:03 <lambdabot> http://www.learnyouahaskell.com/
12:17:12 <solrize_> http://corp.galois.com/blog/2009/4/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galo.html
12:17:12 <typoclass> philosophy: here is a book you can read online ^^
12:17:20 <solrize_> that galois presentation is good
12:17:35 <Eduard_Munteanu> acfoltzer: er... sorry, wrong nick, I meant aCube
12:17:51 <tdammers> or if you want a largish piece of software that is not a compiler for its own language, look into Pandoc
12:17:58 <typoclass> philosophy: even if you don't end up using haskell, you'll have become a better programmer :-)
12:18:06 <applicative_> tdammers: yeah I already tried it on him
12:18:17 <ab9rf> i've little interest in languages built on top of the JVM at this point
12:18:20 <johnw> typoclass: he may become a worse imperative programmer though :)
12:18:23 <Chousuke> sometimes I forget Haskell is over 20 years old.
12:18:25 <shesek> opopppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp
12:18:25 <shesek> ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp
12:18:26 <shesek> ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp
12:18:29 --- mode: ChanServ set +o elliott
12:18:30 --- mode: ChanServ set +o johnw
12:18:31 <shesek> ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp
12:18:32 --- mode: elliott set +q shesek!*@*
12:18:34 --- mode: ChanServ set +o johnw
12:18:37 --- mode: ChanServ set +o johnw
12:18:39 --- mode: johnw set +b *!~shesek@217.132.17.175
12:18:42 --- kick: shesek was kicked by johnw (Kicked)
12:18:44 <DMcGill> hey solrize_: am I missing something? The link "download slides :: .pdf" is dead to me
12:18:45 --- mode: johnw set -o johnw
12:18:50 <philosophy> ?
12:18:54 <solrize_> http://www.scribd.com/doc/19502765/Engineering-Large-Projects-in-Haskell-A-Decade-of-FP-at-Galois
12:18:54 <philosophy> well ok
12:18:54 --- mode: elliott set -q shesek!*@*
12:19:14 <applicative_> good work elliott and johnw
12:19:20 <DMcGill> thanks
12:19:27 <typoclass> awww :-) a message from a cat. how cute
12:19:41 <philosophy> what was those pp's for?
12:19:41 --- mode: elliott set -b *!~shesek@217.132.17.175
12:19:52 --- mode: elliott set +b *!~shesek@217.132.17.175$#haskell-ops
12:19:58 <elliott> uh, good timing.
12:19:59 <philosophy> i got it.
12:20:02 <typoclass> philosophy: cat sat on keyboard i guess
12:20:07 --- mode: elliott set -b *!~shesek@217.132.17.175$#haskell-ops
12:20:17 <elliott> shesek: paste malfunction? :p
12:20:34 <shesek> cat malfunction
12:20:40 --- mode: elliott set -o elliott
12:20:45 <shesek> I'm not sure how he managed to only press the "p" button tho o_O
12:20:49 <windrunner> /prog/ ?
12:20:51 <ab9rf> heh
12:20:57 <elliott> it pressed "o" too
12:21:00 <elliott> very talented cat
12:21:07 <johnw> put him into a Schroedinger monad!
12:21:32 <snoyberg> hey johnw
12:21:32 <shesek> :)
12:21:36 <johnw> snoyberg: hi!
12:21:43 <typoclass> shesek: awww :-) how cute. tell him MEOW from all of us here at #haskell
12:22:03 <shesek> heh, will do :D
12:22:08 <shesek> and sorry about the flood
12:22:50 <applicative_> it was a pleasure shesek
12:23:25 <danr> oh, we have cats writing on #haskell nowadays too, how cute
12:23:41 <ab9rf> i'll take the cats over the trolls
12:24:32 <applicative_> hm where are those goofy haskell lolcats .  A couple of them are pretty hilarious
12:25:16 <geekosaur> @google lambdacats
12:25:18 <lambdabot> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg
12:25:18 <lambdabot> Title: Lambdacats - Sean Leather's Photos
12:25:35 <applicative_> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=960526221&k=nfFLFvG&lb=1&s=A not *too* bad
12:26:25 <Eduard_Munteanu> Nice, productive way to append things to your stomach.
12:26:58 <johnw> why does Haskell have an undefined value for every type?  what are the benefits?
12:27:06 <applicative_> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=960526421&k=tSKXkj9&lb=1&s=A is heartbreaking somehow
12:27:13 <eyebloom> Is there such a thing as type level syntactic sugar? For example \x y-> (x,y) is actually \x y -> (,) x y. Is It's type, a -> b -> (a, b), also syntactic sugar?
12:27:17 <Eduard_Munteanu> johnw: it's just honest...
12:27:25 <Eduard_Munteanu> johnw: you have them anyway, implicitly
12:27:34 <johnw> that makes sense, thanks!
12:27:45 <elliott> johnw: well we have infinite loops...
12:27:45 <typoclass> applicative_: yes. i also find it heartbreaking when i see a haskell programmer stuck in the io monad
12:27:46 <johnw> i had thought about non-explicit "undefined"
12:27:49 <johnw> hadn't
12:27:51 <Eduard_Munteanu> johnw: better do   foo = undefined   or   foo = error "undefined"   than   foo = foo   :)
12:27:51 <tromp__> johnw: because haskell has partial functions
12:28:07 <tromp__> johnw: only a language with all functions total can avoid undef
12:28:19 <typoclass> i guess we could ditch undefined and use error instead
12:28:28 <applicative_> ah the one by byorgey about the 'monad tutorial fallacy' is the best though http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=1288212148&k=5KLHJ3V&lb=1&s=A
12:28:31 <elliott> eyebloom: sure, that's sugar for (->) a ((->) b ((,) a b))
12:29:33 <eyebloom> So (,) is automatically promoted to a type level function or is it a different function?
12:29:45 <elliott> eyebloom: it's just a type with the same name as a value
12:29:50 <elliott> like data Foo a b = Foo a b
12:30:08 <tromp__> :t (,)
12:30:09 <lambdabot> a -> b -> (a, b)
12:30:19 <Chousuke> applicative_: is that a Kleisli Cat?
12:30:22 <eyebloom> Is it defined in prelude or built into the language?
12:30:31 <applicative_> :k (,)
12:30:33 <lambdabot> * -> * -> *
12:30:39 <typoclass> applicative_: one of my favorites is "static cat" being checked at compile time
12:31:04 <elliott> eyebloom: well, you can't define (,) yourself.
12:31:08 <elliott> the syntax is special.
12:31:09 <applicative_> yes pretty good
12:31:19 <tromp__> not without some language extensions
12:31:49 <cumbersome> Hi. If I can pose one question - how can I declare my own type MyType so that it would be internally seen as, let's say, triple (a,b,b) ?
12:31:57 <tromp__> i've seen proposals that would allow user-defined if then else and (,)
12:32:15 <dmwit> cumbersome: newtype MyType a b = MyType (a,b,b) -- ?
12:32:16 <tromp__> forget what it was called
12:32:16 <applicative_> data MyType a b = MyType a b b ?
12:32:30 <Eduard_Munteanu> tromp__: mixfix?
12:32:54 <Eduard_Munteanu> Lambda case too.
12:33:01 <Eduard_Munteanu> At least that's how Agda does it.
12:33:04 <applicative_> dmwit is answering more precisely than me cumbersome
12:33:05 <elliott> cumbersome: internally seen howso?
12:33:25 <dmwit> applicative_ is answering more pragmatically than me cumbersome
12:33:29 <cumbersome> but isn't it just giving a synonym to existing type? The thing is, suppose, I'd like to declare some special functions that would work for MyType but not for 'normal' (a,b,b)
12:33:33 <tromp__> it was something else
12:33:45 <elliott> cumbersome: newtype is what you want, then
12:33:46 <dmwit> cumbersome: No. Don't confuse "type" and "newtype".
12:33:49 <elliott> but you should probably use "data"
12:33:55 <elliott> rather than newtype-of-tuple
12:33:59 <dmwit> cumbersome: "type" makes an alias; "newtype" makes an isomorphic (but not equal!) type
12:34:24 <cumbersome> oh, okay, thanks!
12:34:39 <dmwit> cumbersome: And, probably, "data" is even better, because there's not so many already-existing functions on triples that you would want to reuse anyway.
12:34:46 <eyebloom> elliott: I see. I've been trying to figure out this problem http://hastebin.com/raw/bewiqihiyo, and came up with a new solution http://hastebin.com/raw/takeduvaqo but so far I think my problems come from a lack of understanding of type level functions...
12:34:58 <GeneralMayhem> is there a function that will automatically translate between isomorphic newtypes without having to write it out each time?
12:35:16 <elliott> eyebloom: well, there isn't really such a thing as a proper "type level function", without language extensions.
12:35:22 <elliott> there are types/type constructors/etc.
12:35:30 <dmwit> GeneralMayhem: Nope, though you might like the "newtype" package, which declares a class so you don't have to remember the name of the isomorphism.
12:35:54 <applicative_> @type iso
12:35:55 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
12:35:58 <elliott> eyebloom: "A mini version of this language only includes three functions, lam, app and ext (lambda, apply and extension respectively). The only difference between this and other embedded languages is that terms embedded in an extension have access to a global variable that is invisible to the terms themselves."
12:36:03 <elliott> eyebloom: you know, Haskell already has this :p
12:36:10 <elliott> (the Reader monad, can be written in "applicative" style using the Applicative instance)
12:36:35 <eyebloom> I'm not sure that it's the same thing.
12:36:58 <elliott> well, I guess if you have writing too then it's more like State. anyway, this interface seems possible to me.
12:37:10 <elliott> you didn't explain what ext should do.
12:37:12 <elliott> do you have an example of its use?
12:38:16 <applicative_> GeneralMayhem: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs there is also of course unsafeCoerce...
12:38:37 <eyebloom> I was trying to simplify the problem for my example... but basically you can use this to write really succinct graph traversals, and I believe possibly compile out redundant work.
12:39:54 <elliott> "Ideally the result of evaluating this would be a (global', \x y-> x y)" -- surely it would have to be e.g. (global', \x -> (global'', \y -> (global''', x y)))
12:40:02 <cumbersome> Hmm. I wanted to add one more constraint to MyType, that is both a and b be of type Enum. But I can't discern where lays the problem in: data (Enum a, Enum b) => Mytype a b = MyType (a, b, b)
12:40:19 <elliott> cumbersome: you should put that constraint on your functions instead
12:40:47 <cumbersome> these which will be used on MyType, elliott?
12:40:51 <elliott> cumbersome: right.
12:40:57 <elliott> foo :: (Enum a, Enum b) => MyType a b -> ...
12:40:58 <applicative_> since you'll have to anyway
12:41:13 <eyebloom> Well, global would not necessarily change type, ideally it wouldn't because you would want every extension to expect the same type anywhere in the expression.
12:41:22 <elliott> eyebloom: I wasn't talking about type changing
12:41:25 <elliott> I was talking about value changing
12:41:40 <eyebloom> Ok understood
12:41:53 <applicative_> in haskell all the values are persistent, its the types that are mutable
12:43:52 <elliott> anyway, I admit I don't really understand your goals or the example.
12:44:10 <dmwit> "In Haskell, types are mutable." <- what?
12:44:56 <eyebloom> elliot: What would the type of lam and app be according to your idea?
12:44:58 <cumbersome> that might be because I haven't yet understood the distinction between types, values and classess - and I'm experimenting ; )
12:45:16 <elliott> eyebloom: I don't really have an idea, since like I said, I don't understand the problem :)
12:45:54 <dmwit> :t ap -- eyebloom
12:45:56 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:46:22 <ab9rf> types are mutable?
12:46:33 <dmwit> Asking for "the type of lambda" usually doesn't make sense, because lambda by itself isn't a term.
12:46:33 <eyebloom> Well the issue with (global', \x -> (global'', \y -> (global''', x y))) is that the expression would evaluate to global' and you would want it to evaluate to global''' .
12:47:00 <ab9rf> muh?
12:47:06 <dmwit> applicative_: Explain yourself!
12:47:43 <typoclass> dmwit: i suppose he meant polymorphic. "5 can be an Int, and 5 can be a Float" etc.
12:47:52 <adimit> the 'token' lambda can have a type in syntactic terms, i.e. within an AST. Inside the type theory of a formal system, it can't.
12:48:09 <adimit> (if you preserve the idea of what lambda means.)
12:48:16 <eyebloom> dmwit: Thanks, that makes sense, the issue is how to construct the converse m a -> m b -> m (a -> b)
12:49:19 <dmwit> I will admit that I haven't been following along, so on the face of it that type doesn't look reasonable to me.
12:49:39 <ab9rf> i'm having trouble understading what that type would be useful for
12:51:14 <eyebloom> dmwit: No problem thanks for your interest. I made an attempt to state the problem here: http://hastebin.com/raw/bewiqihiyo, and came up with a new solution http://hastebin.com/raw/takeduvaqo which fits into the type system but has other huge problems.
12:53:07 <adimit> eyebloom: in your signature, both a and b represent values. I guess you could make the above function by deconstructing b and abstracting over one component of b that is of type a.
12:53:37 <adimit> (or just ignoring a, i.e. having as implementation `const B :: b`
12:54:00 <eyebloom> elliott: The idea is essentially to build a lambda calculus that secretly passes a global variable through the evaluation of a term. The variable is only available to language extensions which are responsible for keeping it's modification commutative and consistent throughout the evaluation of the term.
12:54:11 <elliott> I will say this: your "ext" type looks very much like the "join" operation of the Sttae monad.
12:54:14 <elliott> *State
12:54:58 <eyebloom> I'm trying if I can to avoid defining the problem using the monad sublanguage at least until I understand it fully.
12:55:43 <eyebloom> adimit: I'm not sure I understand.
12:56:24 <adimit> eyebloom: you can't do it as generally as your idea above. The function would have to know intimate details about b, in fact the most intimate detail: how to deconstruct it.
12:56:59 <adimit> I don't think it makes much sense either way…
12:57:00 <dmwit> eyebloom: (m a -> m b) -> m (a -> b) is a very different (and much more reasonable) type to want.
12:57:09 <dmwit> eyebloom: Which is the type your problem description gives to lam.
12:57:21 <eyebloom> adimit: you mean in terms of the arity of b?
12:57:27 <ab9rf> dmwit: yeah, that at least makes sense
12:57:42 <adimit> eyebloom: b is a type. It doesn't have arity, but it can have kind.
12:57:48 <adimit> (I think.)
12:58:16 <eyebloom> I see, what do mean be deconstruct then?
12:58:17 <dmwit> Kinds are just a more specific characterization than arity.
12:58:21 <eyebloom> I
12:58:24 <elliott> does anyone know much about the state of haskell web servers? in particular: is there any serious competition beyond warp, snap-server, and happstack-server?
12:58:42 <sproingie> yesod?
12:58:57 <elliott> sproingie: warp is yesod's server
12:59:08 <sproingie> ah, servers alone
12:59:09 <stepcut> elliott: acme-http
12:59:25 <adimit> dmwit: true that, but you can't mix-and-match the concepts easily. They apply to different portions of the calculus. (Most discussions I've seen even use different lambdas for term-level and type-level operations.)
12:59:28 <Eduard_Munteanu> Haha.
12:59:46 <stepcut> acme-http is super fast.. for the limited number of things it supports
12:59:53 <sproingie> do they all speak WAI?
13:00:08 <stepcut> sproingie: no, only warp/yesod use WAI
13:00:12 <Eduard_Munteanu> NOWAI
13:00:17 <elliott> stepcut: I fear my use-case may be too hopelessly obscure to fall under acme-http's support :P
13:00:18 <adimit> eyebloom: you deconstruct algebraic data types in a pattern match (that's pretty basic Haskell.)
13:00:25 <stepcut> elliott: :)
13:00:37 <sproingie> oh the W is Warp then, not Web?
13:00:55 <stepcut> sproingie: no, it is Web.. just nobody else uses it
13:01:01 <sproingie> *grmbl*
13:01:13 <adimit> eyebloom: http://learnyouahaskell.com/syntax-in-functions explains it. But again, it's *not* going to work for uninstantiated, parametric types.
13:01:19 <sproingie> something like rack/plack/wsgi would be nice
13:01:23 <elliott> stepcut: happstack is getting a new server sometime, right?
13:01:34 <stepcut> elliott: yup. hyperdrive.
13:01:40 <sproingie> but i dunno, people can't agree on iterators themselves
13:01:49 <eyebloom> dmwit: That's a very good question. The basic type of lam in a HOAS syntax as I understand it is lam::repr (a) -> repr (b) -> repr (a->b)
13:02:20 <eyebloom> In my case I want repr to be something like (g->(g, t))
13:02:43 <stepcut> elliott: recently made a big breakthrough on the parser verification issue, and also pipes-parse will be out soon
13:02:52 <elliott> eyebloom: I think you mean:
13:02:55 <elliott> (repr a -> repr b) -> repr (a -> b)
13:02:57 <stepcut> elliott: which means we should finally have the technology to implement it ;)
13:03:02 <elliott> which is the "HO" part of "HOAS"
13:03:13 <dmwit> eyebloom: I suppose part of the problem you're having notionally stems from the fact that the function provided to "lam" may call its argument any number of times -- including none.
13:03:21 <eyebloom> Sorry you are definitely correct.
13:03:28 <dmwit> eyebloom: So perhaps you will have better luck giving an operational, rather than denotational, semantics.
13:03:31 <elliott> stepcut: mmm. it sounds interesting, but I admit bias against pipes :/
13:03:43 <arkeet> what's wrong with pipes :\
13:03:56 <elliott> perhaps I should NIH my own webserver and base it on edwardk's machines so I can have my very own special incompatible universe :p
13:03:56 <stepcut> elliott: go on?
13:04:09 <elliott> stepcut: oh, it's a personal bias. nothing that should sway your design decisions.
13:04:19 <eyebloom> dmwit: That's exactly correct about the argument.
13:04:53 <elliott> #1 bias is all the (() -> ...) you have to put everywhere. #2 bias is the massive proliferation of type parameters. #3 bias is its reinvention of all the standard monad transformers
13:05:35 * hackagebot Strafunski-StrategyLib 5.0.0.3 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.3 (JamesKoppel)
13:05:39 <dmwit> eyebloom: If you forbid mutating the state, I think things get easier. =)
13:06:35 <dmwit> ?djinn ((g -> a) -> (g -> b)) -> (g -> (a -> b))
13:06:35 <lambdabot> f a b c = a (\ _ -> c) b
13:06:44 <elliott> also, if anyone knows: do the three web servers I mentioned differ in terms of things like HTTP pipelining support?
13:07:15 <stepcut> elliott: they all support pipelining and https. Only some support web sockets
13:07:49 <eyebloom> dmwit: Unfortunately that's not an option, even though we are putting limits on the kind of mutation that can occur the value must change.
13:08:17 <mmmmmmm> Could anyone help me with this code instance (Eq a)=> Eq (Network a) where (Node a b) == (Node c d) = a == c (Graph (x:xs)) == (Graph (y:ys)) = x == y _ == _ = False
13:08:25 <dmwit> How limited can it get? =)
13:08:26 <elliott> stepcut: good to know (do you know which does not support websockets?)
13:08:28 <dmwit> Can we add idempotency?
13:08:47 <eyebloom> Firstly: Commutative
13:08:57 <applicative_tmp> mmmmmmm: is this found code or something you wrote?
13:09:18 <mmmmmmm> i wrote but it gives error
13:09:26 <eyebloom> Secondly we expect the result any extension querying the variable to alway get the same result.
13:09:27 <fizbin> mmmmmmm: Use hpaste. (http://hpaste.org/)
13:09:41 <applicative_tmp> data Network a = Node a a | Graph [a] or something
13:10:17 <eyebloom> So from the perspective of the language it is not mutable, but from the perspective of the haskell compiler it is.
13:10:18 <stepcut> elliott: happstack-server does not at this time. It will with hyperdrive
13:10:33 <dmwit> eyebloom: That doesn't sound mutable to me. Just lazy.
13:10:41 <elliott> stepcut: ok, cool.
13:10:51 <hpaste> mmmmmmm pasted “instance error” at http://hpaste.org/86503
13:10:54 <elliott> I guess the Snap server is getting ported to io-streams or something instead of enumerator sometime in the future, too
13:10:57 <dmwit> Or rather, that kind of mutability is exactly the kind you get for free from laziness: one-time updates from thunk to value.
13:10:58 <applicative_tmp> hyperdrive ? happstack salesmanship is really improving
13:11:02 <stepcut> elliott: yes
13:11:20 <stepcut> applicative_tmp: can't spell hyperdrive with out hype!
13:11:27 <fizbin> mmmmmmm: And what's the error?
13:11:50 <fizbin> mmmmmmm: Though I notice that you should indent lines 5, 6, and 7.
13:11:56 <elliott> sort of tempting to have a go at writing my own. I am terrible at NIH
13:11:59 <mmmmmmm> Couldn't match expected type `Node t0' with actual type `Network t1'
13:12:32 <stepcut> elliott: a new low-level HTTP server? or a high-level framework built on an existing low-level server?
13:12:33 <fizbin> mmmmmmm: Oh, right. Duh, yes, of course it would give that error.
13:12:37 <elliott> stepcut: so does hyperdrive do anything incredibly fancy I should know about? (assuming it will be some form of usable relatively soon)
13:12:39 <GeneralMayhem> mmmmmmm: where are you actually using (==)?
13:13:02 <elliott> stepcut: the former... my goals don't align with any existing framework, so I am content with not having any
13:13:05 <eyebloom> dmwit: Yes I agree but I'm not convinced that the best way to do that is with laziness. For example querying a graph might actually change order of the representation of the graph even though it doesn't change the results of any query. That's close to laziness but not quite the same.
13:13:13 <elliott> (also, my goals are a little bizarre.)
13:13:18 <mmmmmmm> I'm using it to compare graphs
13:13:22 <fizbin> mmmmmmm: The issue is that "Network" isn't a type. You've defined a *module* called Network, and in that module you have a *type* called Node.
13:13:27 <GeneralMayhem> mmmmmmm: oh, hold on
13:13:34 <stepcut> elliott: it will provide greater assurance of correctness and will have more sensible performance when the request rate exceeds the server capacity
13:14:02 <fizbin> mmmmmmm: So, first off, I think you meant line 4 to be "instance (Eq a)=> Eq (Node a) where"
13:14:16 <stepcut> elliott: and give you more ability to control those types of internals as well
13:14:20 <GeneralMayhem> fizbin: he defines Network at the bottom;
13:14:27 <fizbin> Oh, wait. Yeah.
13:14:51 <elliott> I wonder if anyone has bound the http-parser library to Haskell
13:15:02 <stepcut> elliott: for example, you can provide your own accept loop with explicit control over the forking of handlers
13:15:08 <hpaste> applicative annotated “instance error” with “instance error (annotation)” at http://hpaste.org/86503#a86504
13:15:09 <fizbin> mmmmmmm: Okay, so it seems to me that you're trying to define == on both Node and on Network.
13:15:14 <elliott> stepcut: cool
13:15:15 <GeneralMayhem> fizbin: mmmmmmm: i think the real problem is that you need to define Eq instances separately for Node and Network
13:15:33 <GeneralMayhem> fizbin: mmmmmmm: where right now you're trying to smash them together
13:15:36 <applicative_tmp> mmmmmmm: I suppose this has been explained, but ^^^ seems to be what you meant?
13:15:38 <eyebloom> dmwit: Which is why I think in the eyes of the type system the global is actually mutable.
13:15:39 <fizbin> mmmmmmm: What applicative annotated your hpaste with should compile.
13:16:13 <mmmmmmm> oke ty very much
13:16:29 <fizbin> mmmmmmm: However, that being said, I think your definitions of == , while they may now compile, are not what you want.
13:16:42 <applicative_tmp> mmmmmmm: but the == definition for Node seems fishy.  I think there was something else
13:16:46 <GeneralMayhem> mmmmmmm: do you not care about the rest of the network?
13:16:57 <GeneralMayhem> mmmmmmm: are two graphs identical if their head node is the same?
13:17:07 <fizbin> mmmmmmm, applicative_tmp: Both == definitions look weird to me.
13:17:40 <GeneralMayhem> fizbin: it's the same problem in both, though
13:17:41 <mmmmmmm> not actually but i'm trying something simple
13:17:46 <applicative_tmp> fizbin: I wasn't sure what was intended for the second
13:17:50 <GeneralMayhem> fizbin: he's ignoring the rest of the network
13:17:59 <applicative_tmp> the empty graphs are always unequal
13:18:10 <applicative_tmp> does seem a little odd, surely they're always the same!
13:18:13 <dmwit> eyebloom: You might like to read a bit about semi-persistence. I think it's a very related idea.
13:18:44 <eyebloom> Thanks I'll look into it.
13:18:46 <GeneralMayhem> how do you test equality on lists, ignoring order?
13:19:34 <mmmmmmm> i'm not testing equality on lists only name of the nodes
13:19:36 <dmwit> eyebloom: Studied primarily by Conchon and Filliatre, it seems.
13:19:51 <applicative_tmp> you want repeated elements to be counted too GeneralMayhem ?
13:19:55 <eyebloom> I see.
13:20:14 <GeneralMayhem> mmmmmmm: if you want to check for true network equality you need to check that the list of neighbors in each node is equal
13:20:23 <applicative_tmp> mmmmmmm: this seems strange though, why not a function 'sameName' ?
13:20:28 <GeneralMayhem> mmmmmmm: but you probably don't care what order the connections are in
13:20:35 <GeneralMayhem> applicative_tmp: hadn't thought of that
13:21:29 <GeneralMayhem> applicative_tmp: i was thinking (all (flip elem [b]) [a]) && (all (flip elem [a]) [b])
13:21:30 <fizbin> mmmmmmm: Do you intend that two Network instances are == if only the label on the first Node is equal, or did you intend to compare all the labels?
13:21:38 <mmmmmmm> yes
13:21:54 <GeneralMayhem> mmmmmmm: that wasn't a y/n question...
13:22:09 <fizbin> mmmmmmm: What I asked was a "this or that" question. I don't understand "yes" as an answer.
13:22:09 <hpaste> mmmmmmm pasted “tree” at http://hpaste.org/86505
13:22:31 <mmmmmmm> actually i want to modify this code for graphs
13:23:24 <GeneralMayhem> mmmmmmm: that's going to be some pretty heavy modifications
13:23:27 <GeneralMayhem> mmmmmmm: to the point where you
13:23:34 <GeneralMayhem> mmmmmmm: 're better off starting over
13:23:51 <applicative_tmp> GeneralMayhem: everything in either is in the other. I don't know what would be the most efficient way to define this. I think if it wasn't important I would use Data.Set.toList and fromList, which is maybe tawdry
13:23:59 <GeneralMayhem> mmmmmmm: trees and graphs are not very much alike, particularly when that tree implementation doesn't allow values at every node, only at leaves
13:24:06 <dmwit> eyebloom: Perhaps another possibility is to make the global state a parameter to the denotation, rather than a part of the denotation.
13:24:14 <dmwit> eyebloom: Haven't thought this through yet, but let's see...
13:25:18 <eyebloom> What do you mean by parameter to the denotation.
13:28:00 <GeneralMayhem> applicative_tmp: i think pretty much any implementation is going to end up O(m*n), so it shouldn't matter much
13:28:04 <Sixstix> is an iterative function always linear?
13:28:20 <GeneralMayhem> applicative_tmp: unless you get clever with hashes
13:28:29 <applicative_tmp> > ( (==) `on` S.fromList) "California" (reverse "California")
13:28:31 <lambdabot>   True
13:28:44 <applicative_tmp> but it looks so good, GeneralMayhem
13:29:12 <applicative_tmp> somehow it must be better with lenses
13:29:40 <applicative_tmp> linear?
13:29:50 <applicative_tmp> iterative?
13:30:11 * applicative_tmp , inwardly: function?
13:31:02 <applicative_tmp> GeneralMayhem: oh there is also Data.HashSet or whatever, but of course, one you start using one of them, there's the question why you were using lists tobegin with
13:31:17 <applicative_tmp> once you start, rather
13:32:03 <Sixstix> I have to check certain functions on how they're build up, like tail recursive, iterative and stuff like that...
13:32:06 <hpaste> Rafih pasted “a Test” at http://hpaste.org/86506
13:32:18 <Sixstix> thought maybe someone here could help me with that
13:33:07 <GeneralMayhem> applicative_tmp: I think if we're at the point of sets we're already beyond where lists would have been helpful
13:33:22 <GeneralMayhem> applicative_tmp: i was just trying to get mmmmmmm 's code working/logical with a minimum of overhaul
13:33:40 <fizbin> Sixstix: You mean you have to analyze certain functions and declare that they're one of those categories, or that you need to construct functions in one of those categories?
13:33:49 <GeneralMayhem> applicative_tmp: which led to a couple questions the answers to which might not ever be useful in the real world
13:34:11 <fizbin> GeneralMayhem: I think mmmmmmm's Eq instances would be best done by just deriving Eq.
13:34:21 <Sixstix> I have to analyze them
13:34:28 <applicative_tmp> certainly!
13:34:28 <Sixstix> there are 5 functions given
13:34:38 <GeneralMayhem> fizbin: i'm not so sure
13:34:39 <applicative_tmp> I mean, deriving Eq
13:34:58 <fizbin> Though I suppose you can't derive Eq if you don't want the (Eq a) constraint on Network and Node generally.
13:34:58 <Sixstix> but my script is trolling me, google won't really help
13:35:05 <GeneralMayhem> fizbin: the edges from one node can get out of order without the network being practically different
13:35:44 <applicative_tmp> hmm
13:35:48 <fizbin> GeneralMayhem: Fair enough.
13:35:49 <GeneralMayhem> > [0, 1] == [1, 0]
13:35:53 <lambdabot>   mueval-core: Time limit exceeded
13:36:07 <applicative_tmp> maybe mmmmmmm needs a fancier type?  but it might be torture to devise it
13:36:11 <fizbin> > [0, 1] == [1, 0::Int]
13:36:15 <lambdabot>   mueval-core: Time limit exceeded
13:36:22 <GeneralMayhem> wat
13:36:23 <fizbin> Wtf, lambdabot?
13:36:28 <Eduard_Munteanu> > 0 == 1
13:36:29 <lambdabot>   False
13:36:34 <Eduard_Munteanu> Aww.
13:36:43 <GeneralMayhem> i just ran it on ghci, it returns false, regardless of lambdabot's personal problems
13:36:44 <Eduard_Munteanu> It's probably just slow.
13:36:52 <applicative_tmp> yes this has been happening in private discussion with her
13:36:59 <fizbin> :t [0, 1] == [1, 0::Int]
13:37:02 <lambdabot> Bool
13:37:11 <fizbin> Well, good.
13:37:13 <arkeet> > [0, 1] == [1, 0]
13:37:15 <lambdabot>   False
13:37:25 <fizbin> :t [[0,1],[1,0]]
13:37:27 <lambdabot> Num t => [[t]]
13:37:27 <GeneralMayhem> arkeet: she likes you
13:37:33 <arkeet> lambdabot does weird things sometimes
13:37:49 <GeneralMayhem> fizbin: in any case, you want that to return true for mmmmmmm 's purposes
13:37:59 <GeneralMayhem> fizbin: so you need either a different type or a non-derived Eq
13:38:16 <applicative_tmp> I think she doesn't like my typing, and of course she's right
13:38:48 <fizbin> GeneralMayhem: Sure. I think that maybe [(a,Int)] is the wrong type for adjacent, and mmmmmmm should be using Data.Map a Int, which would make the derived instance behave.
13:39:16 <GeneralMayhem> fizbin: agreed, and you also need to do the same thing at the Network level, because nobody cares what order you store the nodes in
13:39:16 <fizbin> And then a Data.Set (Node a) instead of [Node a]
13:39:26 <GeneralMayhem> exactly
13:39:54 <fizbin> Sixstix: Wait, your "script"? You have some sort of automated way to analyze functions to see if they're recursive or iterative?
13:40:15 <GeneralMayhem> has he also analyzed them to see if they terminate?
13:40:50 <GeneralMayhem> actually, so long as it's only one or the other, you can write that script just by looking for the name of the function inside its own declaration
13:41:03 <GeneralMayhem> it'll miss corecursion, but it's good enough for govt work
13:41:36 <ab9rf> mmm
13:42:02 <GeneralMayhem> s/corecursion/mutual recursion
13:43:04 <fizbin> GeneralMayhem: It is commonly believed that the halting problem means that you can never write a program that says whether or not a given program terminates. This is not quite true; you can't write a program that says whether its input terminates *for every program*. It's perfectly possible to write willHalt :: Program -> Maybe Bool that returns "Just" when it can conclude whether a program terminates and Nothing when it can't re
13:43:22 <elliott> "when it can't re"
13:43:46 <fizbin> Did I get cut off?
13:43:50 <simpson> fizbin: Nope. You can't conclude whether you would be able to conclude whether that program would halt.
13:44:07 <simpson> Oh, I see.
13:44:23 <simpson> You'd try some known strategies, and if they all fail, then you'd return Nothing. Interesting.
13:44:28 <fizbin> simpson: Sure you can. Trivially, you can hard code a few inputs for the demo, and return Nothing for everything else.
13:44:39 <orzo> I've made a data structure implement Monad and that's how I interact with it.  Later, I realize that it would be better to give the data structure some context, say a value of type Double.  The actual value is computed, so not in the type system.	Therefore, unless I want to rewrite all my code to stop using the Monad interface, I need to somehow encode this computed Double value into the type
13:44:45 <elliott> fizbin: yes
13:44:45 <orzo> system so that "return x" has access to it.  Is that possible?
13:45:11 <fizbin> Ah, my sentence ended "whether a program terminates and Nothing when it can't reach a conclusion."
13:47:21 <fizbin> orzo: It sounds like you want to take your original Monad and wrap it in (STT Double)
13:47:47 <orzo> I'm not familiar with STT
13:49:33 <elliott> orzo: it sounds like you want ReaderT?
13:49:43 <fizbin> orzo: Actually, that's overkill. You want to wrap it in (StateT Double), which you can read about here: http://book.realworldhaskell.org/read/monad-transformers.html
13:49:52 <elliott> is it really StateT?
13:49:54 <elliott> "a value of type Double"
13:51:06 <fizbin> I assumed orzo would want to update the double during the monad calculation, but you're right that that wasn't said.
13:52:02 <dmwit> eyebloom: still around?
13:52:40 <tromp__> is there a variation on filter that takes [Bool] instead of (a->Bool) ?
13:53:02 <ab9rf> tromp__: probably a way to do that using a zip
13:53:03 <dmwit> :t \xs ys -> [y | (x, y) <- zip xs ys, x]
13:53:05 <lambdabot> [Bool] -> [t] -> [t]
13:53:12 <orzo> fizbin: actually no, i don't need to update it. I compute the double before i start using the data structure and from then on it is static
13:53:35 <dmwit> tromp__: I don't think there's any standard library function like that.
13:53:38 <fizbin> Okay, then use ReaderT instead of StateT. Same page in realworldhaskell though.
13:53:38 <PJBoy> hello, I'm getting a syntax error on this snippet of code http://codepad.org/6faIFIa8 could anyone help me resolve it?
13:53:58 <arkeet> :t \xs ys -> catMaybes (zipWith (\x y -> guard x *> pure y) xs ys)
13:53:58 <tromp__> thx, dmwit
13:54:00 <lambdabot> [Bool] -> [a] -> [a]
13:54:09 <dmwit> :t (map fst . filter snd .) . zip
13:54:11 <lambdabot>     The operator `.' [infixr 9] of a section
13:54:11 <lambdabot>         must have lower precedence than that of the operand,
13:54:11 <lambdabot>           namely `.' [infixr 9]
13:54:18 <fizbin> PJBoy: You're missing an "else" in line 7
13:54:19 <dmwit> :t ((map fst . filter snd) .) . zip
13:54:21 <lambdabot> [b] -> [Bool] -> [b]
13:54:32 <PJBoy> fixbin, oh of course, thank you
13:54:38 <PJBoy> *fizbin
13:54:56 <ab9rf> else is not optional :)
13:55:13 <dmwit> :t (join .) . zipWith (\x y -> guard x >> return y)
13:55:15 <PJBoy> that was a rookie mistake
13:55:16 <lambdabot> [Bool] -> [a] -> [a]
13:55:51 <ab9rf> dmwit: i like that one
13:56:17 <ab9rf> @pl (join .) . zipWith (\x y -> guard x >> return y)
13:56:18 <lambdabot> (join .) . zipWith ((. return) . (>>) . guard)
13:56:44 <fizbin> :t (join .) . zipWith ((. return) . (>>) . guard)
13:56:45 <lambdabot> [Bool] -> [a] -> [a]
13:56:50 <arkeet> oh yeah, join would work too.
13:57:03 <dmwit> > length "(join.).zipWith((.return).(>>).guard)"
13:57:06 <lambdabot>   37
13:57:09 <ab9rf> > let f = (join .) . zipWith ((. return) . (>>) . guard) in f [True,False,True] [1..]
13:57:11 <lambdabot>   [1,3]
13:57:26 <arkeet> ab9rf: it was mine first :c
13:57:36 <arkeet> almost
13:57:42 <arkeet> :)
13:57:42 <dmwit> yes, I blame arkeet for this code
13:57:46 <tromp__> @let filtWith = (join .) . zipWith ((. return) . (>>) . guard)
13:57:48 <ab9rf> arkeet: i'm not taking credit fo rit
13:57:49 <lambdabot>  Defined.
13:57:57 <dmwit> ab9rf: You were giving me credit for it.
13:58:01 <dmwit> Which wasn't fair.
13:58:09 <tromp__> @let fib a b = a:fib b (a+b)
13:58:11 <ab9rf> fine, arkeet can have the credit and the blame :)
13:58:11 <lambdabot>  Defined.
13:58:17 <arkeet> yes, always blame me.
13:59:05 <tromp__> > tail $ filtWith (map (==1) $ zipWith mod (fib 2 1 ) [0..]) [0..]
13:59:07 <lambdabot>   *Exception: divide by zero
13:59:22 <ab9rf> arkeet: i was just thinking "hm, there's a solution with catMaybes" and *poof* there it was
13:59:28 <ab9rf> divide by zero?
13:59:38 <ab9rf> oh, you zipWith'd mod
14:00:19 <ab9rf> > zipWith mod (fib 2 1) [1..]
14:00:23 <lambdabot>   mueval-core: Time limit exceeded
14:00:28 <tromp__> > zip (fib 2 ) [0..]
14:00:28 <ab9rf> snrk
14:00:30 <lambdabot>   Couldn't match expected type `[a0]' with actual type `a1 -> [a1]'
14:00:33 <tromp__> > zip (fib 2 2) [0..]
14:00:33 <arkeet> :t fib
14:00:35 <lambdabot>   [(2,0),(2,1),(4,2),(6,3),(10,4),(16,5),(26,6),(42,7),(68,8),(110,9),(178,10...
14:00:35 <lambdabot> Num a => a -> a -> [a]
14:00:40 <tromp__> > zip (fib 2 1) [0..]
14:00:43 <lambdabot>   [(2,0),(1,1),(3,2),(4,3),(7,4),(11,5),(18,6),(29,7),(47,8),(76,9),(123,10),...
14:00:56 <fizbin> lambdabot: Feeling lagged? Need a reboot?
14:01:40 <tromp__> > filtWith (tail $ map (==1) $ zipWith mod (fib 2 1 ) [0..]) [1..]
14:01:43 <hpaste> dmwit pasted “operational semantics are easier” at http://hpaste.org/86511
14:01:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:01:50 <ab9rf> hehe
14:01:57 <dmwit> ?tell eyebloom http://hpaste.org/86511 ?
14:01:58 <lambdabot> Consider it noted.
14:03:02 <fizbin> @src fib
14:03:02 <lambdabot> Source not found. Do you think like you type?
14:03:19 <tromp__> > filtWith (map (==1) $ zipWith mod (fib 1 3) [1..]) [1..]
14:03:22 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:03:45 <ab9rf> fizbin: tromp__ defined it for lambdabot earlier
14:04:05 <fizbin> With something like let fib a b = a:(fib b (a+b)) ?
14:04:26 <ab9rf> 15:57 < tromp__> @let fib a b = a:fib b (a+b)
14:04:40 <arkeet> that is slow fib.
14:04:41 <arkeet> :p
14:04:57 <arkeet> or is it?
14:04:59 <arkeet> never mind.
14:05:05 <arkeet> > fib 0 1 !! 1000
14:05:07 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
14:05:43 <Shaladdle> let f a = a + 1
14:05:47 <Shaladdle> f 20
14:05:50 <hpaste> mmmmmmm pasted “new” at http://hpaste.org/86513
14:05:56 <elliott> > let fibs@(_:(zipWith (+) fibs -> more)) = 0 : 1 : more in fibs
14:05:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:06:04 <elliott> behold, mortals.
14:06:12 <Shaladdle> how do I make lambdabot lambda?
14:06:16 <Shaladdle> or am I gullible?
14:06:20 <Shaladdle> :t 1
14:06:21 <dmwit> > let f a = a + 1 in f 20
14:06:23 <lambdabot> Num a => a
14:06:24 <lambdabot>   21
14:06:34 <dmwit> ...but there's no lambda in that.
14:06:40 <dmwit> > (\a -> a + 1) 20
14:06:42 <lambdabot>   21
14:06:45 <Shaladdle> well yeah
14:06:46 <Shaladdle> ohh
14:06:56 <Shaladdle> oh do I have to put a '>'?
14:07:01 <dmwit> "> ", in fact
14:07:11 <Shaladdle> does it remember function definitions?
14:07:17 <Shaladdle> or is it just a one shot expression?
14:07:25 <dmwit> You may use ?let to define things slightly long-term.
14:07:34 <Shaladdle> ?let f a = a * 2
14:07:38 <Shaladdle> f 231
14:07:38 <lambdabot>  Defined.
14:07:41 <Shaladdle> > f 231
14:07:45 <lambdabot>   Ambiguous occurrence `f'
14:07:45 <lambdabot>  It could refer to either `L.f', defined at <local...
14:07:53 <elliott> @undefine
14:07:55 <elliott> pick a name that isn't f :p
14:07:58 <Shaladdle> hehe
14:08:01 <dmwit> > f 231
14:08:02 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:08:03 <lambdabot>    (GHC.Show.Show a0)
14:08:03 <lambdabot>     ...
14:08:05 <Shaladdle> ?let banana a = a * 2
14:08:08 <lambdabot>  Defined.
14:08:10 <Shaladdle> banana 12
14:08:18 <Shaladdle> > banana 12
14:08:21 <lambdabot>   24
14:08:25 <Shaladdle> sweet
14:08:31 <Shaladdle> it's probably just some person entering things into ghci
14:08:40 <Shaladdle> :P
14:08:45 <fizbin> > fix (\x -> 0:1:zipWith (+) x (tail x))
14:08:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:09:08 <h4199> @yar
14:09:08 <lambdabot> I'd like to drop me anchor in her lagoon
14:09:21 <Shaladdle> lolwat
14:09:37 <Rembane> filthybot
14:09:49 <h4199> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
14:09:51 <lambdabot>   "hail satan"
14:09:55 <Shaladdle> ?let filthybot = "lambdabot"
14:09:57 <lambdabot>  Defined.
14:10:16 <fizbin> WhyOhWhyArentThereMoreWomenAtHaskellConferencesBot
14:10:42 <fizbin> @pl \x -> 0:1:zipWith (+) x (tail x)
14:10:43 <lambdabot> (0 :) . (1 :) . ap (zipWith (+)) tail
14:11:51 <fizbin> @pl \a b -> fix $ ([a,b]++) . ap (zipWith (+)) tail
14:11:51 <lambdabot> (fix .) . flip flip (ap (zipWith (+)) tail) . (((.) . (++)) .) . (. return) . (:)
14:12:09 <fizbin> :t flip
14:12:11 <lambdabot> (a -> b -> c) -> b -> a -> c
14:12:13 <fizbin> :t flip flip
14:12:15 <lambdabot> b -> (a -> b -> c) -> a -> c
14:13:04 <fizbin> let fib' = \a b -> fix $ ([a,b]++) . ap (zipWith (+)) tail in fib' 1 3
14:13:16 <fizbin> > let fib' = \a b -> fix $ ([a,b]++) . ap (zipWith (+)) tail in fib' 1 3
14:13:18 <lambdabot>   [1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,...
14:15:33 <hpaste> mmmmmmm pasted “new2” at http://hpaste.org/86514
14:15:55 <mmmmmmm> Here is my new code but i'm still getting the same error
14:21:34 <chrisdotcode_> hello all :)
14:21:52 <monoidal> mmmmmmm: To define equality of custom objects, use "instance Eq <type> where (Graph a) == (Graph b) = nodeListEq a b, for example
14:22:14 <monoidal> mmmmmmm: and you shouldn't hide Prelude's (==)
14:22:57 <monoidal> mmmmmmm: aaa I see
14:23:26 <monoidal> mmmmmmm: you need to indent:instance (Eq a)=> Eq (Network a) where (Graph a ) == (Graph b ) = nodeListEq a b <- after "where" you should indent
14:23:27 <mmmmmmm> i have some other modules if i dont hide it program gives another error :(
14:23:50 <monoidal> mmmmmmm: don't hide (==)
14:24:16 <monoidal> mmmmmmm: add instance Eq a => Eq (Node a)
14:24:53 <monoidal> mmmmmmm: equality of nodes and graphs are different operations. The case _ == _ is redundant (and wrong); it is not possible to have different types on left and right side of (==).
14:25:36 <mmmmmmm> ok i will try ty very much
14:25:44 * johnw uses join on mmmmmmm to yield m
14:28:52 <chrisdotcode_> so why does this violate the functor laws: "instance Functor [] where
14:28:52 <chrisdotcode_>   fmap _ [] = []
14:28:52 <chrisdotcode_>   fmap g (x:xs) = g x : g x : fmap g xs"?
14:29:09 <chrisdotcode_> is it because of the g x : g x instead of just g x : fmap g xs?
14:29:33 <johnw> it changes structure
14:29:42 <Trollkastel> chrisdotcode: Well, try mechanically replacing your definitions in the functor laws (fmap id = id, fmap (f . g) = fmap f . fmap g).
14:29:42 <johnw> it would have to be g x : fmap g xs
14:29:52 <johnw> functor must be homomorphic
14:30:38 * hackagebot data-aviary 0.4.0 - Combinator birds.  http://hackage.haskell.org/package/data-aviary-0.4.0 (StephenTetley)
14:30:56 <chrisdotcode_> so it's because it's mutating the element twice, instead of just once, then?
14:31:07 <Trollkastel> chrisdotcode: Mutating?
14:31:14 <johnw> it changes the structure of the list
14:31:14 <chrisdotcode_> * applying the function
14:31:22 <johnw> functors are only allow to mutate the elements in the list
14:31:25 <elliott> chrisdotcode_: because fmap id x is not x
14:31:34 <elliott> for instance, fmap id [1,2,3] would be [1,1,2,2,3,3]
14:31:36 <elliott> which is not [1,2,3]
14:31:40 <johnw> so, fmap on any [_,_,_] must yield a [_,_,_]
14:31:50 <chrisdotcode_> elliott: right, okay. I get it now!
14:31:53 <gspr> Can a zipper be endowed with extra structure that, given a node with value x on level l, allows easy access to all other nodes with value x on level l? (While still remaining nice and functional)
14:32:13 <johnw> chrisdotcode: now, a fold is allowed to do what you're trying to do
14:32:18 <chrisdotcode_> johnw: okay, thanks for making it more abstract now
14:32:22 <tgeeky> gspr: that sounds like dependent types (easy access to all other nodes with value x)
14:32:29 <chrisdotcode_> johnw: yeah, I"m still reading typeclassopedia from yesterday :)
14:32:42 <johnw> that's a great article!
14:33:02 <chrisdotcode_> it's just *slightly* above my head :)
14:33:04 <tgeeky> chrisdotcode_: give byorgey a ++ by typing "byorgey++" if you liked it
14:33:33 <Trollkastel> chrisdotcode: A functor is not just defined by an implementation of the functions exposed by the Functor type class, it is also defined by the fact it satisfies the functor laws. Ditto for other type classes corresponding to mathematical structures - you do not just have to provide some operations, you also have to satisfy some axioms.
14:33:39 * tgeeky guesses that it was one of his first big publications, and maybe after his PhD it will be one of his last ones before going out into the world
14:34:28 <chrisdotcode_> Trollkastel: so it's implementation + adherence to the laws. got it. thanks :)
14:36:06 <gspr> tgeeky: Hmm... ok then. So what I'd really like to do is have something like a tree with easy access to parents *and* easy access across equal-value nodes on the same level. Something one might implement as a tree (with parent-pointers) where also all equally-valued nodes on the same level are connected in a circular linked list. Does that sound like anything… with a name?
14:36:38 <tgeeky> gspr: a jump list sounds closest
14:37:18 <tgeeky> gspr: but I don't really know
14:37:24 <gspr> tgeeky: OK, thanks anyway :)
14:37:48 <dmwit> gspr: (just joined, but...) non-inductive types are a bit tricky to model in Haskell
14:37:55 <gspr> dmwit: Indeed, I know :)
14:37:57 <dmwit> gspr: You might have to resort to using ST or IO.
14:38:25 <gspr> dmwit: I had a hunch. Thought it would be best to make sure I wasn't missing some brilliant variant of zippers or something :)
14:38:31 <gspr> dmwit: Thanks!
14:38:48 <dmwit> gspr: Yep, designing zippers for this stuff (read back a bit now) is an open problem.
14:39:17 <gspr> dmwit: Aha, interesting! I'll stop banging my head against that then ;)
14:39:30 <dmwit> Or bang harder and publish. ;-)
14:40:11 <gspr> dmwit: ;-)
14:40:16 <gspr> dmwit: Anyways, thanks for enlightening me
14:52:16 <mm_freak> is anyone working on pipes-bytestring right now?  if not, then i'm going to
14:52:57 <hpc> you should work on it anyway
14:53:06 <mm_freak> alright =)
14:53:07 <hpc> then submit a totally incompatible patch
14:53:11 <hpc> :D
14:53:18 <Clint> then fork it?
14:53:45 <parcs> > (27-16)/27
14:53:46 <lambdabot>   0.4074074074074074
14:54:25 <johnw> is that the so called Florida equation?
14:54:38 <johnw> (area code)
15:01:28 <parcs> > (72-47)/72
15:01:30 <lambdabot>   0.3472222222222222
15:01:34 <Hafydd> That isn't an equation.
15:08:20 * hackagebot BiobaseTurner 0.3.1.0 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.3.1.0 (ChristianHoener)
15:08:20 <eyebloom> dmwit: I stepped away for a minute and just saw your hpaste.
15:08:20 <lambdabot> eyebloom: You have 1 new message. '/msg lambdabot @messages' to read it.
15:08:24 <johnw> yes
15:08:24 <johnw> sorry
15:10:55 <RenJuan> it is in fact an equation  (27-16)/27 = 0.4074074074074074
15:17:24 <johnw> Filesystem really does need a copyTree function
15:18:50 <efie> data MyData = MyDada ([Int],Int). can I somehow force that only those values of type MyData are allowed where the second part of the tuple, the Int, is an element of the list of Ints?
15:19:29 <geekosaur> smart constructor, maybe
15:19:49 <eyebloom> @djinn ((g->(g,a)) -> (g->(g',b))) -> (g->(a->g',a->b))
15:19:50 <lambdabot> f a b =
15:19:50 <lambdabot>     (\ c ->
15:19:50 <lambdabot>      case a (\ d -> (d, c)) b of
15:19:50 <lambdabot>      (e, _) -> e,
15:19:50 <lambdabot>      \ f ->
15:19:52 <lambdabot>      case a (\ g -> (g, f)) b of
15:19:54 <lambdabot>      (_, h) -> h)
15:20:42 <GeneralMayhem> efie: buildMyData :: [Int] -> Int -> Maybe MyData
15:21:04 <GeneralMayhem> efie: buildMyData l i | i elem l = Just MyData l i
15:21:14 <GeneralMayhem> efie: buildMyData _ _ = Nothing
15:22:07 <efie> GeneralMayhem: ok thanks so far; but it is also possible to make this explicit in the type definition, by extensions mabye?
15:22:30 <efie> or definition of data myData, don't know the right expression
15:22:40 <eyebloom> @djinn ((g->(g,a)) -> (g->(g,b))) -> (g->(g,a->b))
15:22:40 <lambdabot> f a b =
15:22:40 <lambdabot>     (b,
15:22:40 <lambdabot>      \ c ->
15:22:40 <lambdabot>      case a (\ d -> (d, c)) b of
15:22:40 <lambdabot>      (_, e) -> e)
15:23:02 <GeneralMayhem> efie: not that i know of
15:23:13 <quchen> efie: Sounds like a dependent type, which isn't supported by Haskell.
15:23:31 <elliott> efie: you could have the Int be an index into the first list instead.
15:23:35 <elliott> then the condition is simply that the index is valid.
15:23:57 <hpc> or you could have a list zipper
15:24:12 <hpc> depending on what your "index" is for
15:24:16 <GeneralMayhem> efie: I think the real answer might be farther upstream
15:24:21 <efie> hm yeah maybe not the best exampe :) in fact I want to define a data type for a CFG, and I want to state that the start symbol is an elemnt of the list of nonterminalsymbols
15:24:24 <GeneralMayhem> efie: i.e. what exactly are you trying to accomplish?
15:24:45 <GeneralMayhem> efie: make nonterminal a different datatype?
15:25:33 <hpc> i expect CFG is going to end up being a GADT of some sort
15:25:39 * hackagebot NumInstances 1.3 - Instances of numeric classes for functions and tuples  http://hackage.haskell.org/package/NumInstances-1.3 (ConalElliott)
15:27:26 <efie> GeneralMayhem: what do you mean? so far I have something like data CFG = CFG ([NonTerminalSymbol],[TerminalSymbol],NonTerminalSymbol,Rules); data NonTerminalSymbol = ...
15:27:48 <hpc> efie: perhaps what you want is
15:27:57 <hpc> data CFG a where
15:28:09 <hpc>   StringTerm :: String -> CFG String
15:28:22 <hpc>   IntTerm :: Int -> CFG Int
15:28:23 <hpc>   ...
15:28:45 <GeneralMayhem> efie: are you trying to parse one cfg
15:28:52 <GeneralMayhem> efie: or make a general cfg engine?
15:28:53 <hpc>   Operator :: CFG Identifier -> CFG Expr -> CFG Expr -> CFG Expr
15:29:18 <GeneralMayhem> efie: for the former, you might find it easier to write the cfg entirely in haskell types, as hpc is doing
15:29:20 <efie> GeneralMayhem: I want to calculate all derivations
15:29:31 <GeneralMayhem> efie: that... doesn't mean anything to me
15:29:33 <efie> hpc: thanks, I'll check what GADTs are about
15:29:42 <GeneralMayhem> efie: are you parsing one specific grammar?
15:29:49 <GeneralMayhem> efie: or making the grammar itself an input?
15:29:50 <efie> GeneralMayhem: no
15:30:05 <efie> yes
15:30:22 <hpc> efie: what ends up happening is your syntax tree translates perfectly directly into a (CFG a) tree
15:30:32 <dmwit> um
15:30:33 <lambdabot> dmwit: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:30:42 <hpc> (given suitable parsing code)
15:30:57 <dmwit> eyebloom: I am sure it is NOT typesafe.
15:31:02 <dmwit> It will certainly need a type system.
15:31:09 <dmwit> I wanted to do something simple first to show the idea.
15:31:16 <eyebloom> I see.
15:31:43 <dmwit> hpc, efie: Um, using GADTs for a general CFG type seems like sort of a bad idea.
15:32:08 <eyebloom> I think when it comes down to it. The reason I'm doing things in this way is because I want to piggyback off the typechecker.
15:32:15 <hpc> dmwit: it makes a fine intermediate form
15:32:23 <dmwit> For any given CFG, that seems okay, but for CFGs in general?
15:32:33 <eyebloom> And that's also the reason that this would be difficult.
15:32:50 <hpc> oh, i see
15:33:10 <efie> dmwit: what do you suggest?
15:33:26 <dmwit> eyebloom: You can still piggy-back off GHC's type checker.
15:33:44 <dmwit> eyebloom: For *you*, GADTs seem like the order of the day. =)
15:33:53 <dmwit> efie: I don't see what was wrong with your proposal.
15:34:16 <eyebloom> dmwit: Yes I've definitely tried doing this with GADTs
15:34:22 <dmwit> type CFG = Map NonTerminal Rule
15:34:29 <eyebloom> That was actually my first approach.
15:34:43 <elliott> you could use HOAS, too
15:34:56 <dmwit> HOAS seems hard to me, for his use.
15:35:12 <eyebloom> But I decided to try expressing the problem without them.
15:35:39 <dmwit> type Rule = [[Either NonTerminal Terminal]] -- or some such thing
15:35:50 <efie> dmwit: I want to state that the NonTerminalSymbol which acts as a startsymbol has to be in the list of all NonTerminalSymbols of the CFG
15:35:51 <hpc> dmwit: parameterize over the non-terminal type and get type CFG nonterm = Map monterm (Rule nonterm)
15:36:15 <dmwit> gotta run
15:36:29 <eyebloom> Basically you would need to decribe a type function repr where repr a = g->(g,a) and repr (a->b) = g->a->(g,b)
15:37:09 <eyebloom> But maybe I have that very wrong.
15:39:05 <dmwit> back for a minute or two =P
15:39:38 <dmwit> efie: How about data CFG nonterm term = CFG nonterm (Rule nonterm term) (Map nonterm (Rule nonterm term)) ?
15:39:47 <dmwit> The first nonterm and Rule nonterm term being the start rule.
15:39:58 <dmwit> ...and the Map being the rest, of course
15:40:13 <dmwit> eyebloom: That much at least seems possible with type families.
15:40:34 <danharaj> Sad that I couldn't go to the nyhg talks. :[
15:41:28 <danharaj> !nwon 2
15:42:10 <hpaste> eyebloom pasted “Restated to use data constructor rather than tuple” at http://hpaste.org/86521
15:43:01 <eyebloom> I just transferred the code to use a data constructor, because I figure that will be easier to state as a type family.
15:44:42 <elliott> (,) is a data constructor too :p
15:47:34 <efie> dmwit: hmm sounds good! thanks
15:47:36 <GeneralMayhem> >:t (,)
15:47:42 <eyebloom> I know
15:48:06 <eyebloom> I'm just trying to make things a little clearer #graspingatstraws.
15:50:03 <eyebloom> djinn came up with my exact original (wrong) answer. It always amazes me when that happens.
15:50:40 * hackagebot unordered-containers 0.2.3.1 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.3.1 (JohanTibell)
15:50:42 * hackagebot MFlow 0.2.0.7 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.7 (AlbertoCorona)
16:04:01 <oio> a function that can take several strings? fstring arg1 arg2 argn
16:04:54 <oio> curry..
16:04:55 <geekosaur> varargs is ... difficult. see Text.Printf
16:06:56 <geekosaur> note that you need *some* way to determine where the parameters end; there is no way to simply slurp up all the strings (and if there were, what would you do in the case where you wanted one to *not* be absorbed but instead passed on to the next thing?)
16:10:03 <c_wraith> I kind of wish TH would run in the middle of typechecking, such that there was a function available that would give you the type the splice needed to unify with.
16:10:11 <c_wraith> However, that sounds like an engineering nightmare.
16:10:50 <c_wraith> Also, it would need to distinguish between bound an unbound type variables, for extra fun.
16:12:44 <chrisdotcode> so one thing I'm missing from other languages are default arguments. are they needed in Haskell, or am I Doing It Wrong (tm)?
16:13:02 <glguy> You can make a record if you need that
16:13:12 <glguy> and use record update syntax for the arguments you want to specify
16:13:26 <glguy> somefunction defaultargs { field = override }
16:13:45 <elliott> you can often avoid them by factoring things into nicer combinators, also.
16:13:56 <chrisdotcode> elliott: how would one do that?
16:13:58 <c_wraith> I want default arguments only very rarely in haskell code.
16:14:01 <elliott> chrisdotcode: it depends :)
16:14:51 <chrisdotcode> elliott: so what about a function that takes a config file, with a sane default location? def startup(config="config.json")
16:15:11 <elliott> chrisdotcode: well, /that/ case is easy
16:15:14 <elliott> if there's only one argument
16:15:23 <elliott> you can just say startup :: IO (), startupWith :: FilePath -> IO ()
16:15:27 <elliott> startup = startupWith "config.json"
16:15:34 <elliott> minimal overhead, clean to both define and use
16:16:05 <chrisdotcode> elliot: what about def startup(config="config.json", runenv=env, magicstuff=1234) ? :-)
16:16:11 <elliott> then it gets harder :)
16:16:14 <elliott> you can use glguy's solution.
16:16:21 <chrisdotcode> so a record?
16:16:28 <glguy> startup defs { config = "config.json" }
16:16:28 <elliott> but again, it really depends on the precise details of the situation. it's not a "natural" transformation :)
16:17:06 <chrisdotcode> elliott: so haskell doesn't *need* default args?
16:17:12 <geekosaur> real "default parameters" runs into the same thing I just pointed out to oio...
16:17:17 <chrisdotcode> well nothing *needs* them...
16:17:50 <geekosaur> you could come up with a language like Haskell that supported them, but you'd lose much of the utility of higher order functions
16:18:18 <Mortchek> It's kind of hard to reconcile default arguments and currying
16:18:27 <Mortchek> automatic currying, I should say
16:18:38 <Eduard_Munteanu> Automatic?
16:18:58 <Mortchek> Never mind, I am committing the classic error of confusing currying and partial application
16:19:01 <tgeeky> just pick some big number and write all of the possible curryN-ed functions
16:19:33 <tgeeky> uncurry9 a..z 1..4
16:19:57 <tgeeky> (this is not a serious idea. or is it?)
16:20:09 <Mortchek> If you explicitly stated when you were partially applying a function (a concept which makes less sense in Haskell), you could still have default args
16:20:23 <Eduard_Munteanu> Obviously if we have n-tuples transparently, we should also have n-currying like that. (Beats me how, though. :D)
16:33:33 <Peaker> geekosaur, did you find the Alice thing?
16:34:56 <geekosaur> sorry, was I supposed to be finding something other than what I already did?
16:36:34 <Peaker> geekosaur, you found something? I'd love to see that work
16:36:42 <geekosaur> ...
16:38:20 <Peaker> Guess not
16:39:03 <geekosaur> should I resend the URL I gave you and you supposedly saw, or am I now your research assistant and obligated to do a full reference search for you?
16:39:26 <Peaker> geekosaur, I don't recall any URL, I'll check my logs again
16:41:39 <Peaker> geekosaur, if you had given a URL, it didn't have "http" in it... http://hpaste.org/86522
16:41:50 <geekosaur> sorry, I thought I had sent it here
16:42:07 <geekosaur> I even commented on it afterward... but not in my logs either
16:42:12 <geekosaur> lemme dig out if browser again
16:42:36 <geekosaur> http://www.atarimania.com/utility-atari-st-alice-the-personal-pascal_23188.html
16:42:57 <geekosaur> apparently you can even download it there if you can find an ST to run it on...
16:43:06 <Peaker> thanks
16:43:17 <fengshaun_> hi all, it seems like getRequest from Network.HTTP chokes when presented with a url that has [ and ] in path.  How can I escape those characters?
16:44:33 <pxqr> How can I find out if a program have compiled with -threaded or not?
16:44:36 <pxqr> at runtime
16:45:01 <Heffalump> fengshaun_: did you try %5B and %5D
16:45:02 <Heffalump> ?
16:45:14 <luite_> pxqr: rtsSupportsBoundThreads
16:45:47 <pxqr> luite_: nice, thanks!
16:45:48 <fengshaun_> Heffalump: I haven't, thanks!  Can it be done automatically?  Something like url_escape in python?
16:47:15 <Heffalump> GeneralMayhem: I think the network-uri package contains the necessary stuff
16:47:34 <fengshaun_> thanks, I'll check that out
16:47:41 <Heffalump> s/GeneralMayhem/fenshaun_/ # sorry
16:48:07 <Heffalump> ah, looks like it's still in the network package, module Network.URI
16:49:07 <Peaker> Alice sounds like it was cute and probably ahead of its time..
16:49:37 <fengshaun_> found it, it' escapeURIString :D
16:50:53 <Peaker> I guess its usability/usefulness all depends on how slick the UI was in actuality
16:54:58 <mm_freak> now this is really weird
16:55:10 <mm_freak> writeProxy :: (Monoid l) => (() -> ProxyFast a' () () b (Writer l) r) -> l
16:55:10 <mm_freak> writeProxy = execWriter . runProxy
16:55:30 <mm_freak> if i remove the type signature, it can't infer the Monoid constraint
16:55:46 <mm_freak> however, if i write 'writeProxy p = execWriter (runProxy p)' the inference works
16:56:04 <mm_freak> all types involved are rank-1
16:56:06 <arkeet> not some dmr thing?
16:56:21 <mm_freak> arkeet: dmr?
16:56:35 <arkeet> monomorphism restriction.
16:56:42 <arkeet> but that would be obvious.
16:57:00 <arkeet> I forget what the d is for.
16:57:03 <elliott> dreaded
16:57:09 <elliott> also, probably damned.
16:57:11 <parcs> dumb
16:57:12 <mm_freak> then i would expect GHC to actually tell me that
16:57:14 <arkeet> I would have said damned.
16:57:27 <arkeet> mm_freak: so what exactly does it infer?
16:57:33 <elliott> strong opponents may consider the alternate phrase fmr, which I just made up.
16:57:35 <elliott> the f stands for friendly.
16:57:37 <mm_freak> No instance for (Monoid c0) arising from a use of `runProxy'
16:57:46 <arkeet> ambiguous type?
16:57:49 <elliott> looks like DMR to me.
16:58:11 <arkeet> it would help to see the rest of the message.
16:58:34 <mm_freak> alright…  i write type signatures everywhere except in my test suites…  i want those to be as concise as possible
16:58:43 <mm_freak> but i'll go with the type siganture then
17:00:43 <elliott> you could just disable the MR
17:08:37 <Peaker> Hah! Got alice to compile&run on Linux :-)
17:09:58 <elliott> does anyone know how to promote data types with String arguments using DataKinds?
17:10:03 <elliott> shouldn't the Symbol stuff support that?
17:10:14 <elliott> it complains `Constructor' of type `String -> Type' is not promotable
17:10:32 <Peaker> Ok, the UI is pretty shitty, but it's cute nonetheless :)
17:10:56 <c_wraith> elliott: Hmm. That does sound like it should work, but I seem to recall some pretty big limitations in that stuff so far.
17:11:18 <elliott> I mean, I assume I could do my own manual promotion of it using Symbol. but that sounds annoying.
17:11:29 <elliott> so I'm wondering what you are "meant" to do here.
17:11:55 <c_wraith> I guess the problem is that promoted String is not Symbol
17:13:27 <tommd> aleator: ping
17:13:36 <xplat> @remember cmccann < cmccann> shachaf: nobody will associate with someone who breaks the monoid laws! < shachaf> cmccann: That's why I go by a secret identity.
17:13:37 <lambdabot> It is stored.
17:14:32 <tommd> @quote arm
17:14:33 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
17:17:18 <Peaker> geekosaur, after trying to use alice for a few minutes, it becomes pretty clear why that wasn't a hit :)
17:44:26 <__xc> > (2^) 2
17:44:28 <lambdabot>   4
17:44:46 <__xc> > (2^). (2^). (2^). (2^) 2
17:44:48 <lambdabot>   *Exception: show: No overloading for function
17:45:03 <__xc> > (2^). (2^). (2^). (2^) $ 2
17:45:05 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
17:45:42 * hackagebot BiobaseTurner 0.3.1.1 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.3.1.1 (ChristianHoener)
17:46:20 <__xc> is it possible to construct a f.g.h from a [f,g,h] list?
17:46:47 <__xc> (random question nothing to do in particular)
17:46:59 <luite_> appEndo . mconcat . map Endo
17:48:32 <elliott> or foldr (.) id
17:48:38 <elliott> they have to be a -> a though
17:49:46 <__xc> > appEndo . mconcat . map Endo $ [f,g]
17:49:48 <lambdabot>   Ambiguous type variable `a0' in the constraints:
17:49:48 <lambdabot>    (GHC.Show.Show a0)
17:49:48 <lambdabot>     ...
17:49:57 <luite_> monoids are easier!
17:49:59 <__xc> > appEndo . mconcat . map Endo $ [f,g] :: Expr
17:50:01 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
17:50:01 <lambdabot>              w...
17:50:26 <Eduard_Munteanu> :t appEndo . mconcat . map Endo $ [?f,?g]
17:50:27 <lambdabot> (?f::a -> a, ?g::a -> a) => a -> a
17:51:08 <Eduard_Munteanu> > appEndo . mconcat . map Endo $ [f,g :: Expr]
17:51:09 <lambdabot>   Couldn't match expected type `a0 -> a0'
17:51:09 <lambdabot>              with actual type `Debu...
17:51:19 * Eduard_Munteanu wanders away
17:52:41 <elliott> > appEndo . foldMap Endo $ [f,g] :: Expr
17:52:43 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
17:52:44 <lambdabot>              w...
17:52:48 <elliott> oh
17:52:51 <elliott> > (appEndo . foldMap Endo $ [f,g]) x :: Expr
17:52:53 <lambdabot>   f (g x)
17:53:09 <elliott> > ala Endo foldMap [f,g] x :: Expr
17:53:11 <lambdabot>   f (g x)
17:53:12 <elliott> lens power.
17:53:59 <Ghoul_> tikhonjelvis: hi
17:55:55 <DanielDiaz> What's the best option to import the Group class as a subclass of Monoid?
17:57:05 <c_wraith> DanielDiaz: that question doesn't make a lot of sense. Group either depends on Monoid or it doesn't. Importing it doesn't change that.
17:58:11 <c_wraith> Hmm.  I guess I shouldn't be surprised that the free monoid isn't a group.  In fact, after thinking about it a bit more, I'm now wondering why I was surprised by that.
17:58:24 <DanielDiaz> c_wraith: I would like not to need defining a Group class again, and, if possible, I would like one class implying the other. Does that make sense?
17:59:04 <c_wraith> DanielDiaz: sure, but that's completely unaffected by how you import things. That's my point.
17:59:05 <elliott> I don't even know what Group class you are referring to.
17:59:44 <DanielDiaz> I refer to a group as a monoid where every element is invertible
18:00:01 <elliott> yes, I know what a group is...
18:00:02 <DanielDiaz> so I would have a class with a method for the inverses, plus the methods in the monoid class
18:00:09 <elliott> ok, so this is a class you're defining?
18:00:11 <__xc> > (foldr (.) id $ [a,b,c,d]) x :: Expr
18:00:15 <lambdabot>   Couldn't match expected type `b0 -> b0'
18:00:15 <lambdabot>              with actual type `Debu...
18:00:29 <DanielDiaz> and I am pretty sure that this has been done several times
18:00:31 <__xc> > (foldr (.) id $ [f.g.h.i]) x :: Expr
18:00:31 <c_wraith> class (Monoid a) => Group a where inverse :: a -> a
18:00:33 <lambdabot>   Couldn't match expected type `b0 -> b1'
18:00:33 <lambdabot>              with actual type `Debu...
18:00:37 <elliott> the terminology "import" refers to a very specific thing: an "import" statement, so that's why c_wraith gave that answer.
18:00:51 <elliott> if you just want to define a Group class as a subclass of monoid, then -- yeah, what c_wraith said
18:01:18 <__xc> > (foldr (.) id $ [f,g,h]) x :: Expr
18:01:20 <lambdabot>   f (g (h x))
18:01:21 <DanielDiaz> the point was that I want to use a predefined class
18:01:40 <elliott> ok. from where?
18:01:48 <elliott> can you give a hint? package name? :P
18:01:56 <DanielDiaz> and, since is defined in several packages around Hackage, I was asking for the best option.
18:02:09 <elliott> oh. by "best option" you meant best choice for the class, I see
18:04:59 <elliott> edwardk's "algebra" package might be a decent place.
18:05:06 <DanielDiaz> there is this "groups" package that, for some reason, doesn't have haddock documentation?
18:05:33 <DanielDiaz> yeah, I was that one
18:05:55 <c_wraith> honestly, unless the package comes with a ton of instances, I don't see much value in using a pre-existing class
18:06:07 <elliott> edwardk's comes with a ton of instances, of course. :p
18:06:31 <c_wraith> that's not always a given.  Depends on how he was feeling when he made the class.
18:06:46 <DanielDiaz> but I don't get why the need of LeftModule, RightModule and Monoidal classes
18:07:14 <c_wraith> Usually when he does that, it's because the existing class leaves out something he considers to be important
18:07:41 <DanielDiaz> c_wraith: an explanation would be nice!
18:08:05 <DanielDiaz> I know what those terms mean, but I don't see the need to define a Group
18:08:22 <xplat> dmwit: so when are you adding Compact as a class between Universe and Finite?
18:09:02 <xplat> dmwit: (or above Finite at least ... might not be a subclass of Universe?)
18:09:39 <c_wraith> It's interesting to me that the Group class is in a module named Additive
18:09:48 <c_wraith> It kind of implies it's not intended to be fully general
18:09:55 <__xc> and constructing [(2^), (3^)] from [2,3] and (^) ?
18:09:58 <c_wraith> Ah, and indeed it isn't
18:10:06 <__xc> >  scanl (^) 1 [1,2,3,4]
18:10:07 <danharaj> > map (^) [2,3]
18:10:08 <lambdabot>   [1,1,1,1,1]
18:10:09 <lambdabot>   *Exception: showList: No overloading for function
18:10:10 <DanielDiaz> c_wraith: yeah, like guessing that the group is commutative
18:10:21 <__xc> >  scanl (^) 2 [1,2,3,4]
18:10:23 <lambdabot>   [2,2,4,64,16777216]
18:10:59 <c_wraith> DanielDiaz: well, not only that..  There are two different obvious groups for many of the types he provides instances for..  Additive and Multiplicative.  There are only Additive instances there.
18:11:18 <c_wraith> DanielDiaz: So that Group class really is intended only to represent additive groups
18:11:38 <DanielDiaz> c_wraith: when one says additive group, usually means abelian
18:11:38 <__xc> zipWith will do that
18:12:11 <DanielDiaz> DanielDiaz: but you can also use multiplication notation, it is not really a new type of group as far as I know
18:12:39 <c_wraith> DanielDiaz: well, yes, all the instances are probably abelian, too. But that's not the only assumption. It's also implying the group operation is addition, or whatever analog of it makes sense on the set in question
18:12:40 <DanielDiaz> c_wraith: haha, the last one I cited myself haha
18:12:45 <c_wraith> yes, I noticed :)
18:13:15 <c_wraith> DanielDiaz: It's not about what the group means, since obviously algebra treats a group as a group, no matter what - it's more about what the default instances are.
18:13:36 <DanielDiaz> c_wraith: OK, I think I kinda see what you mean now.
18:13:48 <c_wraith> DanielDiaz: for instance, you can't declare an (Integer, *, 1) instance with that class, because there's already an instance for Integer, and it's (Integer, +, 0)
18:14:09 <DanielDiaz> c_wraith: anyway, that wouldn't be a group
18:14:26 <danharaj> s/Integer/Rational
18:14:33 <c_wraith> Rationals don't work either
18:14:36 <c_wraith> Because of 0
18:14:37 <DanielDiaz> right
18:14:41 <c_wraith> So...  positive rationals!
18:14:42 <danharaj> Rational*
18:14:43 <c_wraith> there
18:14:44 <c_wraith> :)
18:15:16 <DanielDiaz> well, I still think a Monoid a => Group a class makes more sense in general
18:16:00 <DanielDiaz> of course, this particular case should have its intention
18:16:56 <c_wraith> and I've just been doing a lot of number theory, so I'm thinking "of course (Z_p, *, 1) is a group!"
18:17:10 <c_wraith> Which is what threw me on making that example.
18:17:18 <DanielDiaz> I see
18:17:29 <philipdexter> if i do `last $ "a" ++ foo ++ "b"`, why can't the compiler deduce that the answer should be 'b'? the only reason I can think that the answer wouldn't be 'b' was if foo created an infinite list
18:18:05 <mm_freak> how well does Coarbitrary work in quickcheck?  i'm a bit worried
18:18:09 <tikhonjelvis> philipdexter: or if foo is ⊥, no?
18:18:24 <philipdexter> true, yeah i thought of that too just didn't include it, sorry
18:18:38 <tikhonjelvis> but yeah, I think that's enough reason on its own
18:18:50 <tikhonjelvis> also, even if it could, that sort of optimization probably wouldn't be worth including
18:18:56 <tikhonjelvis> I doubt it comes up often enough
18:19:59 <elliott> you can consider writing instead: 'b' :)
18:20:14 <philipdexter> i tried `a = last $ replicate 1000000 'a' ++ "b"` with -O2 and it did not optimize it to something like `a = 'b'`, it _could_ do it though correct? is the only thing stopping this a compiler limitation? there is no theoretical point stopping it?
18:20:21 <philipdexter> haha, true, sorry, this is pretty contrived
18:20:37 <elliott> well, there is no theoretical reason to ban any optimisation of a program that halts into its result.
18:20:44 * hackagebot quickcheck-instances 0.3.2 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.2 (AntoineLatter)
18:20:52 <elliott> worst case, it could run your program for a year and if it halts, compile the result in.
18:21:47 <philipdexter> elliott: alright, as I expected. thank you
18:44:06 <hpaste> “Anonymous Coward” revised “SQL Parser”: “SQL parser +comment” at http://hpaste.org/76009
18:46:09 <cmccann> elliott: that's a lame worst case.
18:46:24 <elliott> cmccann: you're lame.
18:46:40 <cmccann> elliott: what it should do is use your credit card to fire up a bunch of AWS instances and simulate your program on all possible inputs. then compile it to a simple lookup table.
18:46:59 <elliott> that's actually what I do.
18:47:15 <cmccann> sounds practical.
18:55:07 <Ghoul_> whats the state of lambdachine
18:59:10 <jekor> Is it possible to use Template Haskell without the GHCi linker? The GHCi linker is broken for some ELF relocations on FreeBSD.
18:59:55 <Clint> jekor: basically no
19:00:11 <Clint> fix the linker stuff
19:01:00 <jekor> Sounds like it's going to be fun...
19:03:49 <cschneid> I'm reading some xmonad code - how do I figure out which library a given function comes from? "getDefaultTemplate" in a helper script for instance. hoogle doesn't find it, where after that?
19:04:05 <danharaj> use hayoo
19:04:10 <danharaj> it searches hackage in its entirety
19:04:44 <cschneid> ahh, cool
19:04:48 <cschneid> danharaj: thanks
19:06:01 <jekor> Hmm...I came across DYNAMIC_BY_DEFAULT in mk/build.mk (notes on Trac)...
19:10:20 <cschneid> what's a .hsc file - as distinct from just a .hs?
19:14:01 <Clint> cschneid: input to hsc2hs
19:14:52 <cschneid> Clint: ahh, it parses C FFI stuff and pulls it in?
19:15:58 <johnw> cschneid: a .hsc file is a bunch of shorthand for writing "raw" FFI code
19:16:25 <johnw> like, #ccall will turn into a foreign import,e ct.
19:16:45 <Clint> cf. c2hs
19:17:06 <johnw> and c2hsc
19:17:07 <johnw> :)
19:17:19 <cschneid> ok - next question from reading xmonad: what does the tilde do here:   ~(Just nbc_) <- initColor dpy.....
19:17:31 <johnw> cschneid: that's a weak pattern match
19:17:37 <johnw> i'd google that one, if I were you
19:17:53 <cschneid> words are easier to google on than "hey, wtf does a tilde do there" :)
19:18:08 <johnw> good for weak pattern match in haskell
19:18:10 <johnw> google
19:23:03 <tommd> @tell aleator If you're around tomorrow and up for it then I'd love to talk about the CV library.
19:23:03 <lambdabot> Consider it noted.
19:29:29 <parcs> jekor: with DYNAMIC_BY_DEFAULT the ghci linker is no longer used i don't think
19:29:47 <parcs> jekor: instead GCC is invoked to build a .o and then libdl links it
19:30:46 <elliott> johnw: hm, where did you pick up "weak" from? I've always seen it called irrefutable
19:31:13 <johnw> ah, lazy is what I meant to say
19:35:13 <johnw> foo (a,_) = a, is the same as foo x = case x of (a,_) -> a; while foo ~(a,_) = a is the same as foo = fst
19:36:08 <johnw> the first function is strict in its argument, the second is not
19:36:15 <johnw> hence, lazy pattern
19:45:18 <arkeet> > fst undefined `seq` ()
19:45:21 <lambdabot>   *Exception: Prelude.undefined
19:45:25 <arkeet> johnw: I disagree.
19:45:33 <arkeet> well.
19:45:38 <realitygrill> mm_freak: hello, do you mind if i ask you a question about your monad tutorial?
19:45:47 <arkeet> > let foo ~(a,_) = a in foo undefined `seq` ()
19:45:51 <lambdabot>   *Exception: Prelude.undefined
19:45:59 <arkeet> well
19:46:45 <arkeet> foo ~(a,_) = a  doesn't get you anything.
19:46:50 <arkeet> it's still strict.
19:47:24 <arkeet> there is a difference between, say, foo (a,b) = (a,b) and foo ~(a,b) = (a,b)
19:47:37 <arkeet> > let foo (a,b) = (a,b) in foo undefined `seq` ()
19:47:37 <johnw> ah, I see
19:47:39 <lambdabot>   *Exception: Prelude.undefined
19:47:40 <arkeet> > let foo ~(a,b) = (a,b) in foo undefined `seq` ()
19:47:42 <lambdabot>   ()
19:48:17 <johnw> > let foo ~(a,_) = a in foo (undefined,undefined) `seq` ()
19:48:19 <lambdabot>   *Exception: Prelude.undefined
19:48:56 <arkeet> anything that maps (a,_) to a must be strict, so the lazy pattern doesn't get you anything there.
19:49:03 <johnw> i see
19:49:12 <johnw> good point
19:49:13 <arkeet> meanwhile,
19:49:33 <arkeet> foo (a,b) = (a,b) maps ⊥ to ⊥
19:49:36 <arkeet> foo ~(a,b) = (a,b) maps ⊥ to (⊥,⊥)
19:49:59 <pxqr> is it reasonable to use cereal-conduit with network-conduit with tcp connection?
19:50:16 <arkeet> sounds reasonable.
19:50:17 <johnw> pxqr: isn't that kind of exactly what's for?
19:52:10 <dmwit> xplat: Isn't compact a property of values, not types?
19:52:21 <tgeeky> or categories
19:52:21 <pxqr> johnw: yes, I'm new with conduits and just want to clarify it. But i have "too few bytes" error. Maybe i make mistake somewhere in other place...
19:52:53 <dmwit> xplat: Anyway, assuming you're talking about the "impossible functional programs", I wasn't really planning on adding that stuff.
19:53:33 <dmwit> xplat: It's just too easy to write a Haskell function which doesn't satisfy the prerequisites but also doesn't obviously break them.
19:53:54 <dmwit> xplat: If you want to send some patches, I guess I wouldn't reject them, but I won't be spending any time on it myself.
19:54:14 <dmwit> (And there are other packages that offer that anyway, aren't there?)
19:58:02 <mm_freak> realitygrill: feel free
19:59:07 <realitygrill> mm_freak: i'm not sure what you mean by 'threading' - does it just mean piping the state around?
19:59:26 <mm_freak> realitygrill: yeah
19:59:28 <realitygrill> mm_freak: when you talk about the IO monad, I do understand why you can't reference Universe, though
19:59:31 <realitygrill> hmm
19:59:57 <realitygrill> but piping the state of the universe is fine if you don't go back in time
19:59:59 <mm_freak> realitygrill: i'd like to note that the tutorial is old and i'd explain a few things differently nowadays, particularly IO
20:00:02 <realitygrill> but there's no way to guarantee that?
20:00:03 <realitygrill> oh really
20:00:04 <realitygrill> :/
20:00:42 <mm_freak> realitygrill: well, State without 'get' and 'put' is a nice way to allow threading state without forking
20:01:18 <mm_freak> you could interpret IO like State Universe, but that interpretation is obsolete
20:01:33 <mm_freak> a better interpretation of IO (IMO) is as a recipe language
20:01:49 <realitygrill> .. explain that a bit more?
20:02:02 <RenJuan> you realitygrill ask?
20:02:15 * RenJuan suspects a collusion
20:02:43 <mm_freak> realitygrill: an 'IO String' is a procedure that produces a String
20:03:07 <elliott> @quote /bin/ls
20:03:08 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:03:19 <DanielDiaz> a Maybe String is a String, or maybe not...
20:03:45 <mm_freak> realitygrill: and the monadic part of IO is about when a parametric IO action (that is a function that produces an IO action) depends on a value, but that value would be produced by another IO action
20:03:59 <mm_freak> realitygrill: the type of (>>=) makes this quite clear:  (>>=) :: IO a -> (a -> IO b) -> IO b
20:04:02 <johnw> sometimes I swear my CPU spends half its time converting String <-> Text
20:04:15 <mm_freak> johnw: that's quite possible
20:04:24 <mm_freak> if you want the speed of Text, don't introduce String in the first place
20:04:33 <realitygrill> hmm
20:04:40 <johnw> yeah, but the FFI is not based around Text
20:04:50 <johnw> while the rest of my library is
20:04:59 <elliott> well, the FFI doesn't really have that strong a connection to String either
20:05:00 <mm_freak> johnw: you can use ByteString instead of String
20:05:08 <johnw> i do, but sometimes I need Text
20:05:29 <mm_freak> johnw: you can use Text, but communicate ByteStrings
20:05:37 <johnw> ?
20:06:09 <mm_freak> johnw: CString is just Ptr CChar
20:06:23 <mm_freak> so you can easily convert between CString and ByteString
20:06:54 <mm_freak> then you can use, say, encodeUtf8 and decodeUtf8
20:07:00 <johnw> yes, I do this, all over the place
20:07:04 <johnw> up, down, left and right
20:07:09 <johnw> it seems I never have the type I want
20:07:14 * elliott doesn't see where String itself would get involved
20:07:22 * mm_freak neither
20:07:27 <johnw> elliott: some of the libraries I'm using use String
20:07:37 <elliott> oh. I thought it was FFI-related
20:07:53 <johnw> ah, I was using withCString
20:08:05 <johnw> but that's only because I already had a String
20:08:07 <johnw> anyway, n/m
20:08:18 <johnw> it just seems like there's a heck of a lot of converting going on around here, I need to see if I can clean that up
20:09:17 <johnw> the function that introduced the String I'm complaining about at this very moment was openBinaryTempFile
20:09:25 <mm_freak> the conversion between ByteString and Text is reasonable, btw
20:09:54 <johnw> I try to make anything textual a Text, and "data" a ByteString, wherever I possibly can
20:10:00 <johnw> but some libraries still require String, sadly
20:10:45 <mm_freak> ByteString should probably become part of the base library
20:10:46 <elliott> well, sometimes String is what you want.
20:10:53 <mm_freak> elliott: when?
20:10:55 <johnw> elliott: when is that?
20:11:22 <elliott> when you want to processit incrementally.
20:11:26 <elliott> [] as control structure
20:11:33 <geekosaur> hm?
20:11:38 <mm_freak> elliott: that works with ByteString/Text as well
20:11:40 <elliott> also I suspect it's more efficient for incredibly small strings.
20:11:40 <geekosaur> bytestring is a bootlib, I believe
20:11:52 <mm_freak> elliott: it isn't
20:11:52 <elliott> mm_freak: [] is as good as it gets at the job it does.
20:11:53 <geekosaur> at one point it was actually in base, but that was a maintenance nightmare
20:12:00 <johnw> I kind of wish String was just deprecated
20:12:18 <mm_freak> elliott: the thing is, it doesn't do a good job at text processing, even if you process individual characters
20:12:47 <elliott> not everything you can possibly do with a sequence of codepoints falls under conventional "text processing"
20:12:47 <mm_freak> elliott: compare map toUpper to T.map toUpper
20:12:49 <geekosaur> if what yoy actually meant was that ByteString should become String, well, no
20:13:04 <mm_freak> geekosaur: no
20:13:10 <elliott> if you use lists as a control structure elsewhere in your program, why would it be verboten to sometimes have the element type be Char?
20:13:26 <mm_freak> geekosaur: String is probably fine…  it's just not what it pretends to be =)
20:13:37 <geekosaur> sure it is
20:13:48 <johnw> elliott: it wouldn't be verboten at all.  I don't want to stop people from using [Char].  I want to stop libraries from using String as the String type
20:13:49 <geekosaur> npobody promised it was an *efficient* string representation
20:14:30 <geekosaur> and changing that would require massive reworking, as currently you have lots of things using String and you need to decide which are reasonably ByteString and which are Text
20:14:51 <geekosaur> also, that job becomes an absolute nightmare as soon as you ask about pathnames
20:14:57 <mm_freak> to be fair i'm not entirely happy with Text either
20:15:05 <geekosaur> because Windows pathnames are Text but POSIX pathnames are ByteString (!)
20:15:31 <geekosaur> (no matter how hard people try to pretend POSIX pathnames are UTF8 or etc.)
20:15:48 <mm_freak> i good substitute for String would be a lazy Word32-encoded Text, i guess
20:15:59 <elliott> FilePath as a type synonym was one of Haskell's biggest mistakes, really
20:16:02 <mm_freak> s/^i/a/
20:16:18 <elliott> anyway, I'd rather Text not become *too* standard purely because I don't really like its internal representation :P
20:16:27 <mm_freak> ditto
20:16:31 <elliott> I'd prefer a finger-tree-of-UTF-8 like edwardk uses in trifecta, or something.
20:16:41 <elliott> of course that makes interacting with ICU and stuff harder. but arrays are so bad.
20:16:58 <mm_freak> elliott: Word32 arrays would be fine
20:17:15 <geekosaur> (which is still another nightmare that would have to be dealt with, and it's still not clear that the CJK folks have given up and accepted UTF8 instead of more efficient for CJK encodings, python3 be damned)
20:17:28 <elliott> might as well move to a more purely-functional friendly representation if you take that leap from compatibility
20:18:02 <mm_freak> elliott: not that i complain about the efficiency of String, but i don't want something even worse ;)
20:18:19 <elliott> well, edwardk uses it in trifecta. i'm sure it's not slow.
20:18:38 <elliott> whether it's better than Text or not, is arguable and surely depends a lot on the use-case. but I'm sure it could be optimised.
20:18:49 <mm_freak> if you want something like that there is Seq Char
20:19:23 <elliott> Seq Char isn't similar.
20:19:36 <elliott> the structure I'm talking about is a finger tree of *small arrays* of UTF-8
20:19:44 <elliott> unpacked at the leaves -> more efficient
20:19:49 <elliott> like a rope.
20:20:44 <mm_freak> i think there should be an efficient representation for text strings…  Text does that quite well
20:21:45 <mm_freak> but it's far from optimal
20:22:09 <mm_freak> i really hope that vector-bytestring gets usable
20:22:16 <mm_freak> and perhaps vector-text some day
20:37:28 <eafe> what's the least strange way to get the tail of a sequence (Data.Sequence)? I'd think being an instance of foldable, traversable would give me something. I can think of ways to make it, just thought theremight be something obvious
20:38:10 <mm_freak> eafe: viewl?
20:38:17 <eafe> pattern matching?
20:38:20 <geekosaur> :t (Data.Sequence.|>)
20:38:23 <lambdabot> Seq.Seq a -> a -> Seq.Seq a
20:38:36 <geekosaur> hm, wrong one.
20:38:41 <mm_freak> eafe: you can use viewl in a pattern guard
20:38:56 <mm_freak> | x :< xs <- viewl s = …
20:39:18 <geekosaur> viewr would be the tail, no? viewl is head?
20:39:34 <mm_freak> geekosaur: head/tail, init/last
20:39:45 <eafe> tailS (viewl -> _ :< t) = t
20:39:48 <geekosaur> yeh, I knew I used the wrong term there
20:39:54 <geekosaur> ok
20:40:15 <mm_freak> eafe: yeah, that's another way to do it, if you don't mind ViewPatterns
20:40:41 <mm_freak> (i never understood how PatternGuards made it into h2010, but ViewPatterns didn't)
20:40:51 <eafe> do I have to pay twice if I repeat that in a pattern guard?
20:41:10 <eafe> or view pattern, for that matter
20:41:10 <mm_freak> eafe: probably…  use a 'where' to avoid it
20:41:28 <eafe> thanks mm_freak
20:41:34 <mm_freak> | _ :< xs <- v = … where v = viewl s
20:44:06 <Ghoul_> Can somebody help me with an issue I have -- I'm trying to bind the result of parsec reservedOp to the constructor of one of my data structures and pass that across to the constructor of Prefix which has type (GenParser tok st (a -> a))
20:44:13 <Ghoul_> I'm not sure how to do it... http://hpaste.org/86528
20:44:32 <Ghoul_> The issue is under `operators`
20:53:55 <Ghoul_> In regards to the problem above I'm actually looking for the shorthand to this: http://hpaste.org/86530 if anyone knows
20:55:50 * hackagebot binary-file 0.15.18 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.18 (YoshikuniJujo)
20:56:03 <Clint> @. pl undo do { reservedOp name ; return (\x -> Constructor name x) }
20:56:03 <lambdabot> reservedOp name >> return (Constructor name)
20:59:12 <Ghoul_> Clint: will >=> do what I want to do?
20:59:21 <Ghoul_> Constructor >=> reservedOp name
21:00:05 <Clint> Ghoul_: i don't actually know what you want to do
21:00:44 <meditans> hi all, I have a question regarding hayoo api search. But first a preliminary question. Why the version of the package wx above 0.12.1.6 don't contain the html api reference?
21:01:00 <meditans> look at http://hackage.haskell.org/package/wx-0.12.1.5
21:01:23 <meditans> and to http://hackage.haskell.org/package/wx-0.13.2
21:01:24 <Ghoul_> Clint: I'd like to get rid of the "return" if it's possible
21:01:26 <Clint> meditans: because the build failed
21:01:48 <Clint> Ghoul_: are you saying that reservedOp name >> return (Constructor name) actually does what you want?
21:02:06 <Ghoul_> moment, I'll test the program.
21:02:44 <meditans> clint thanks, and why people continue putting up versions if the build fails? I'm surely missing something
21:03:48 <Ghoul_> aw, It doesn't seem to work
21:03:53 <Clint> i'm not surprised
21:04:10 <Clint> meditans: it's probably only failing because the wx libraries are broken on hackage or something
21:05:35 <geekosaur> meditans, wx won't build on the hackage machine unless the wx C/C++ libraries are installed on the build machine. I expect that the hackage buildbot is not able to install arbitrary (and, in the case of wx, complex) foreign dependencies
21:07:06 <meditans> clint thanks for the explanation. Now, for the second question: I know that in the package wx-0.12.1.6, and in particular Graphics.UI.WX.Media, there is a function named bitmap. But how would I found it through a hayoo search? (meaning, could you provide the exact string?)
21:07:24 <meditans> geekosaur, i see, thanks
21:08:18 <geekosaur> there is a way to upload prebuilt documentation, IIRC, wich is probably how this was solved in the past; you might need to contact the wx package maintainers
21:09:33 <hpaste> Bayu pasted “Iconia PC tablet dengan Windows 8” at http://hpaste.org/86531
21:10:00 --- mode: ChanServ set +o geekosaur
21:10:27 <meditans> geekosaur, yes, but that particular function is documented on hackage, see http://hackage.haskell.org/packages/archive/wx/0.12.1.6/doc/html/Graphics-UI-WX-Media.html, the thing is I don't manage to find it through Hayoo, and I'd like to know why
21:11:00 <geekosaur> hayoo will only look at bootlibs by default
21:11:06 <geekosaur> oh ait
21:11:14 <geekosaur> no, that's hoogle. hayoo should have seen it...
21:11:33 * geekosaur trying to do too much at once, sigh
21:11:38 --- mode: geekosaur set -o geekosaur
21:12:01 <flebron> What is a reasonable way of pointfree reading two ints from a string, and feeding them to an f :: Int -> Int -> String?
21:12:11 <flebron> (The input is the string.)
21:12:24 <flebron> Maybe uncurry f . (read &&& read) or something?
21:13:30 <geekosaur> meditans, hm, hayoo doesn;t seem to have indexed wx at all
21:13:43 <geekosaur> "package:wx" gets wxFruit and wxdirect
21:14:01 <geekosaur> you'll have to contact the hayoo maintainer about that one, I suspect
21:14:10 <elliott> probably it needs to build docs or something to idnex it?
21:14:17 <meditans> ok, how do I do it?
21:14:35 <geekosaur> http://holumbus.fh-wedel.de/hayoo/about.html
21:14:52 <geekosaur> elliott, hackage has the docs for at least some wx versions
21:15:10 <geekosaur> I didn't think hayoo built its own, it uses hackage
21:15:24 <geekosaur> (its own *index*, yes,but from hackage's docs)
21:20:24 <ab9rf> flebron: you have to use the version of read tht returns the unread portion of the string, i suspect
21:21:24 <ab9rf> :t (&&&)
21:21:25 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:22:02 <flebron> well
21:22:09 <flebron> I think I can do it this way
21:22:30 <otters> :t loop
21:22:33 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
21:22:34 <flebron> > (read *** read.tail) $ break (==' ') "5 4"
21:22:36 <lambdabot>   (*Exception: Prelude.read: no parse
21:23:04 <flebron> > (read *** read.tail) $ break (==' ') "5 4" :: (Int, Int)
21:23:06 <lambdabot>   (5,4)
21:24:46 <ab9rf> flebron: not bad
21:25:05 <flebron> (i'm going to hell for that)
21:25:09 <ab9rf> > break (==' ') "5 4"
21:25:12 <lambdabot>   ("5"," 4")
21:25:24 <ab9rf> ah, hence the tail
21:25:42 <ab9rf> map read $ words "5 4"
21:25:51 <ab9rf> > map read $ words "5 4"
21:25:53 <lambdabot>   [*Exception: Prelude.read: no parse
21:25:58 <ab9rf> > map read $ words "5 4" :: [Int]
21:26:00 <lambdabot>   [5,4]
21:26:05 <otters> > read "()"
21:26:07 <lambdabot>   ()
21:26:11 <otters> as I suspected
21:27:53 <ab9rf> @t head (\x -> zip x (tail x))
21:27:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:28:00 <flebron> I wish I could use words, but going from [Int] to (Int, Int) seems hard :(
21:28:11 <ab9rf> :t \x -> head (zip x (tail x))
21:28:13 <lambdabot> [b] -> (b, b)
21:28:20 <ab9rf> @pl \x -> head (zip x (tail x))
21:28:20 <lambdabot> head . ap zip tail
21:28:26 <ab9rf> (head . ap zip tail) [2,4]
21:28:33 <ab9rf> > (head . ap zip tail) [2,4]
21:28:35 <lambdabot>   (2,4)
21:28:37 <ab9rf> really?
21:28:51 * flebron never learned to use ap
21:29:02 <ab9rf> neither have i
21:29:05 <ab9rf> :)
21:29:17 <ab9rf> > (head . ap zip tail) [2,4,5]
21:29:19 <lambdabot>   (2,4)
21:29:22 <ab9rf> > (head . ap zip tail) [2]
21:29:24 <lambdabot>   *Exception: Prelude.head: empty list
21:29:47 <ab9rf> that is a fairly abusive use of zip :)
21:29:58 <flebron> yes haha
21:30:47 <ab9rf> > let qq = \s -> (head . ap zip tail (map read $ words s) in qq "20 5"
21:30:48 <arkeet> ap is easy
21:30:49 <lambdabot>   <hint>:1:57: parse error on input `in'
21:30:55 <arkeet> ap f g x = f x (g x)
21:31:04 <ab9rf> > let qq = \s -> (head . ap zip tail) (map read $ words s) in qq "20 5"
21:31:06 <lambdabot>   (*Exception: Prelude.read: no parse
21:31:16 <ab9rf> > let qq = \s -> (head . ap zip tail) (map read $ words s) :: (Int,Int) in qq "20 5"
21:31:17 <lambdabot>   (20,5)
21:31:32 <ab9rf> @pl \s -> (head . ap zip tail) (map read $ words s)
21:31:32 <lambdabot> head . ap zip tail . map read . words
21:31:38 <ab9rf> there ya go
21:31:46 <ab9rf> that's _so_ obvious :)
21:31:51 <mm_freak> is there a way to actually ask the operating system for a bunch of memory pages?
21:32:00 <Clint> > liftA2 (,) head last $ [20,5]
21:32:01 <lambdabot>   (20,5)
21:32:11 <mm_freak> i.e. bypass haskell's/GHC's heap
21:32:25 <ab9rf> mm_freak: possible, probably, but not easy
21:32:43 <mm_freak> when i call malloc(), doesn't that do it?
21:32:52 <ab9rf> mm_freak: no, not necessarily
21:33:06 <Clint> looks like Foreign.Marshal.Alloc.malloc does
21:33:08 <ab9rf> malloc has its own heap manager, it might or might not actully go to the OS
21:33:39 <mm_freak> Clint: that uses the heap
21:33:54 <Clint> foreign import ccall unsafe "stdlib.h malloc"  _malloc  ::          CSize -> IO (Ptr a)
21:34:00 <Clint> so that's a lie?
21:34:09 <mm_freak> hmm
21:34:14 <mm_freak> ok
21:34:17 <mm_freak> thanks =)
21:34:34 <geekosaur> it's using C's heap manager instead of haskell's. actually asking the OS for memory is ... more difficult
21:34:38 <geekosaur> you may want mmap()
21:34:44 <ab9rf> @pl \s -> (liftA2 (,) head last) (map read $ words s)
21:34:45 <lambdabot> liftA2 (,) head last . map read . words
21:34:48 <XexonixXexillion> what about importing something like posix_memalign if you want whole pages?
21:34:54 <mm_freak> well, using the heap is probably fine…  this is really about mlocking memory
21:35:17 <mm_freak> won't kill to lock some other data as well
21:39:56 <mm_freak> will the RTS touch Storable memory in any way?  i mean, could it copy it?
21:40:56 <shachaf> Storable?
21:41:10 <shachaf> What do you mean?
21:41:50 <shachaf> If it's allocated with malloc, the RTS won't move it. But Storable is just a class for working with arbitrary memory -- it doesn't have to do with how it's allocated.
21:42:23 <mm_freak> i know it won't move, but i need to make sure it isn't copied either
21:42:42 <mm_freak> malloc seems to bypass the RTS, so that's probably fine
21:43:28 <shachaf> Are you putting a key in it or something?
21:43:57 <mm_freak> yeah
21:44:09 <mm_freak> a key only needed at startup in a long running program
21:44:13 <shachaf> OK.
21:44:37 <shachaf> I would be pretty surprised if the RTS copies memory that you allocate with malloc etc.
21:45:14 <mm_freak> indeed, but i don't have much insight into the internals of the RTS
21:45:49 <mm_freak> simon marlow is the bruce schneier of haskell =)
22:02:58 <johnw> how is that?
22:03:00 <johnw> he loves squids too?
22:03:40 <shachaf> I think it means that people make a lot of jokes about him.
22:04:21 <johnw> I didn't realize people made jokes about Bruce
22:05:08 <shachaf> Well, they're off-topic for this channel anyway.
22:05:15 <k0001> 1]
22:05:57 <mm_freak> johnw: http://www.schneierfacts.com/
22:06:04 <mm_freak> @quote schneier
22:06:04 <lambdabot> mm_freak says: bruce schneier is an endofunctor that turns all automorphisms into identities
22:14:59 <realitygrill> is there a standard pronunciation for (>>)?
22:15:21 <hackedy> realitygrill: yeah, "(>>)"
22:16:04 <elliott> realitygrill: "then", say.
22:16:10 <mm_freak> realitygrill: i say "and then" or "followed by", depending on the monad
22:16:14 <realitygrill> hmm..
22:16:16 <elliott> or you can just not pronounce it.
22:16:17 <realitygrill> ok, no standard
22:16:20 <elliott> "print 1, print 2."
22:16:26 <realitygrill> ah
22:17:02 <hackedy> I've also heard monad-plus (I think?) but that's not how you would *pronounce* it
22:17:13 <mm_freak> i find (>>=) and (>>) weird anyway…  if at all possible i always go with (>=>)
22:17:50 <realitygrill> .. what is that?
22:18:10 <realitygrill> arrow?
22:18:21 <mm_freak> realitygrill: kleisli composition, i.e. combine two monadic functions
22:18:28 <realitygrill> ah, thanks
22:18:29 <mm_freak> turn a -> m b and b -> m c into a -> m c
22:18:40 <realitygrill> just :t-ed it :)
22:19:21 <shachaf> mm_freak: Do you avoid do-notation, too?
22:19:48 <mm_freak> shachaf: that's a consequence, isn't it?
22:20:45 <mm_freak> not that (>>=) is bad, it just feels weird…  too general and all that
22:20:56 <mm_freak> essentially for the same reason i find for-loops weird
22:25:39 <johnw> let's add LANGUAGE CommonLispLoop, then I can say: let x = loop x from 0 to 5 collecting (x+1) finally (return x) :)
22:25:55 <Demos> wait loops? what
22:26:04 <johnw> it's a joke :)
22:27:42 <elliott> lens sort of does LOOP-y stuff.
22:27:54 <Demos> sorry I was distracted by schinerfacts
22:27:57 <johnw> that really doesn't surprise me :)
22:28:14 <shachaf> lens's "loops" are so easy
22:28:58 <mm_freak> johnw: looks like a list comprehension to me
22:42:38 <johnw> does anyone know how to turn a ByteString into a ResumableSource IO ByteString?
22:43:07 <Heffalump> did you try return, or is ResumableSource not a Monad transformer?
22:43:32 <johnw> it's not a monad, no
22:43:45 <johnw> sourceLbs will get me a Source
22:43:57 <johnw> a ResumableSource is apparently that you've started reading, but which still has data left
22:44:01 <johnw> i'll try take 0
22:45:54 <johnw> yeah, that did it: fst <$> (sourceLbs r $$+ Data.Conduit.Binary.take 0)
22:52:14 <realitygrill> wtf list monad
22:53:17 <immanuelkant> :type last
22:53:47 <sw2wolf> @ty last
22:53:49 <lambdabot> [a] -> a
22:54:54 <immanuelkant> @ty (:)
22:54:55 <lambdabot> a -> [a] -> [a]
22:55:14 <immanuelkant> can we do pattern matching like (xs:x)
22:55:25 <immanuelkant> or just (x:xs) is allowed?
22:55:43 <h4199> not if want you want is to access the last element
22:56:11 <h4199> haskell doesn't know xs means "rest of the list"
22:56:57 <immanuelkant> oops i understand now
22:57:43 <immanuelkant> we used (:) so it understands xs as the first element.. that makes sense
22:58:03 <immanuelkant> when we use (xs:s) that is
22:58:53 <h4199> yup yup
23:08:20 <johnw> x and xs are just names, after all, swapping them means nothing
23:09:37 <johnw> you could do this: foo (init &&& tail -> (xs,x)) = ...
23:09:44 <johnw> i mean, init &&& last
23:10:41 <sw2wolf> @ty init &&& last
23:10:43 <lambdabot> [c'] -> ([c'], c')
23:10:57 * hackagebot yesod-platform 1.1.9.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.9.1 (MichaelSnoyman)
23:16:55 <aleator> @tell tommd sure
23:16:56 <lambdabot> Consider it noted.
23:35:57 * hackagebot shakespeare-css 1.0.5 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.5 (MichaelSnoyman)
23:40:57 * hackagebot shakespeare-css 1.0.5.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.5.1 (MichaelSnoyman)
23:42:20 <Ghoul_> :t forever
23:42:22 <lambdabot> Monad m => m a -> m b
23:43:06 <johnw> it's funny that forever has a return type :)
23:45:21 <mm_freak> johnw: wouldn't it be weird if it wouldn't?
23:45:29 <mm_freak> m a -> …?
23:45:40 <h4199> .................................
23:45:41 <johnw> i'm kind of kidding
23:45:49 <johnw> from a denotational standpoint, the passage of time doesn't really matter
23:45:58 <johnw> but from an operational standpoint, there will never be a return value
23:46:03 <johnw> so it's odd that it has a type
23:46:13 <mm_freak> what would not having a type mean?
23:46:24 <johnw> m a -> Void
23:46:31 <mm_freak> that wouldn't work
23:46:34 <johnw> yeah, I know
23:46:39 <mm_freak> if anything, m Void
23:46:42 <johnw> true
23:47:07 <mm_freak> but i think m b captures better that there isn't actually a result
23:47:41 <shachaf> m a -> m Void would be a perfectly reasonable type.
23:48:08 <mm_freak> except that it would force you to use (<$) all the time without providing any real benefit
23:48:21 <mm_freak> would you want 'const' to have the type a -> Void -> a?
23:49:00 <mm_freak> also "m Void" is far from "not having a type" =)
23:49:28 <shachaf> m Void is a great type.
23:49:41 <shachaf> I don't know what johnw means by "an operational standpoint" and "a denotational standpoint".
23:50:16 <johnw> denotational means that the implementation of forever has nothing to do with its type, right?
23:50:21 <johnw> it's jut m a-> m b
23:50:26 <johnw> there's nothing there to indicate that time is involved
23:50:41 <johnw> operational means how the function behaves, unless I'm misusing the term
23:51:08 <mm_freak> johnw: the type is actually quite clear about what the implementation has to look like
23:51:34 <johnw> how come I feel like no one is understanding what I'm saying?
23:51:35 <mm_freak> it states that 'forever' will perform the given action a certain possibly infinite number of times
23:52:14 <johnw> :t join . return
23:52:16 <lambdabot> Monad m => m a -> m a
23:53:41 <johnw> :t :t join . return . ap $ return id
23:53:42 <lambdabot> parse error on input `:'
23:53:46 <johnw> :t join . return . ap $ return id
23:53:47 <lambdabot> Monad m => m b -> m b
23:54:40 <johnw> mm_freak: I don't see where the type of forever implies that it might perform the action more than once
23:54:49 <elliott> since "m b"
23:55:37 <shachaf> elliott: "m b" mostly implies that you're cheating and using evil recursion.
23:55:39 <sw2wolf> @ty forever
23:55:41 <lambdabot> Monad m => m a -> m b
23:55:46 <elliott> shachaf: yes, like "forever".
23:55:50 <shachaf> You might as well say "forever x = forever x" with that type, though.
23:55:59 <shachaf> Once you've started cheating, you can't be sure of anything.
23:56:17 <mm_freak> johnw: it doesn't, but it can only perform the action again or loop forever without doing anything
23:56:46 <johnw> are you saying the type doesn't make "sense", and so its only choice is to never try to return?
23:57:19 <mm_freak> johnw: think about it…  what would returning look like?  there is only one possibility:  return undefined
23:57:26 <johnw> right
23:57:34 <johnw> :t ap (return undefined)
23:57:36 <lambdabot> Monad m => m a -> m b
23:57:47 <mm_freak> johnw: it's important to note here that we often pretend that bottom doesn't exist
23:57:54 <johnw> it's like returning infinite recursion
23:57:58 <mm_freak> but then of course 'forever' itself doesn't make sense
23:58:03 <shachaf> mm_freak: You can't pretend bottom doesn't exist and -- yes.
23:58:13 <arkeet> I want to pretend seq doesn't exist.
23:58:29 <shachaf> arkeet wants to pretend puns don't exist.
23:58:59 <h4199> @ty flip (>>=) ((fmap f) .return )
23:59:00 <lambdabot> (Monad m, Functor m, Show a, FromExpr b) => m a -> m b
23:59:24 <arkeet> @ty flip (>>=) ((fmap ?f) .return )
23:59:25 <lambdabot> (?f::a -> b, Monad m, Functor m) => m a -> m b
