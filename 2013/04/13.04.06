00:00:35 <Saizan> which is one reason catch is in IO, so you can blame the ability of telling them apart on the catcher rather than the thrower
00:03:24 <tomberek> the haskell wiki and hackage documentation for Netwire suggests that there is a way to run instants non-continuously, but all the examples I have seen use the same continuous main loop... what is the other way?
00:03:53 <ski_> .. it could be nice to have `String -> ExnMessage' and `ExnMessage -> IO String' functions, for use with `fail'
00:05:33 <lispy> tomberek: you might have better luck with that question on stackoverflow
00:05:47 <lispy> tomberek: I don't know if any netwire experts frequent here.
00:06:49 <tomberek> lispy: well, on a similar topic: is there a newer/better instance of a arrowised FRP?
00:07:02 <tomberek> i thought Netwire was pretty current
00:12:07 <LambdaDusk> tomberek: The main point of netwire is the "stepSession" function
00:13:07 <LambdaDusk> tomberek: It represents a single step that returns you the result of your wire - you don't have to use this function in a main loop, you can call it any time
00:13:14 <Saizan> ski_: how would you use them?
00:14:37 <tomberek> LamdaDusk: yep, and the documentation suggests that instead of continuously calling it in a loop, it could be called conditional on input. But if I'm either polling input, or waiting for an exception to update my wires, what's the point of FRP?
00:15:36 <LambdaDusk> tomberek: The point of FRP in general is just a functional way to describe what happens on an event
00:16:55 <LambdaDusk> tomberek: You could use monads and a more imperative-style of programming if you prefer that. FRP is just a different way to describe reactions to events, a more Haskell-y way
00:17:46 <tomberek> LamdaDusk: maybe I should back up a bit. I'm trying to write something that responds to keyboard input. But that occurs infrequently. So I'm wondering if there is a better way than the loop at :http://hackage.haskell.org/packages/archive/netwire/4.0.7/doc/html/Control-Wire.html
00:18:09 <ski_> Saizan : `fail :: MonadFail m => ExnMessage -> m a' (automatically wrapping the generated string describing the location of the pattern-match failure in the `do'); and if you want to extract the string, you have to go `IO'
00:18:48 <LambdaDusk> tomberek: does your wire still need the current time? What do you use to poll the event? if you use SDL, you can simply use waitEvent and call the wire then
00:19:43 <tomberek> LamdaDusk: no need for current time, currently the polling is done by a wire every time stepSession is called... i am not familiar with SDL -- one moment
00:20:43 <LambdaDusk> tomberek: The question is if your framework lets you use an onEvent callback - if not, you will have ot use polling
00:21:28 <tomberek> LamdaDusk: got it, i guess that's the right terminology.....  what frameworks allow an onEvent callback?
00:23:00 <LambdaDusk> tomberek: I don't quite know what your project is... I have only dabbled with the usual game libraries. SDL, GLUT and GLFW allow for it, if you know how.
00:23:23 <LambdaDusk> GLUT requires IORef for it, though, and SDL does it via waitEvent
00:24:02 <LambdaDusk> tomberek: See here for GLFW callbacks: http://hackage.haskell.org/packages/archive/GLFW/0.5.1.0/doc/html/Graphics-UI-GLFW.html#g:8
00:24:57 <LambdaDusk> tomberek: You would have to use an IORef to store the result wire and session and to read them again
00:25:09 <tomberek> LamdaDusk: to reduce dependecies, what about registerFd in base?
00:26:01 <tomberek> would that be a low level version of the same thing?
00:26:04 <LambdaDusk> tomberek: Well I am not familiar with that one at all, but it looks the same as above.
00:26:51 <LambdaDusk> tomberek: So yes, you can use that one as well
00:27:01 <tomberek> that way I don't have to depend on GLUT/GLFW (this is a CLI, not GUI)
00:27:28 <LambdaDusk> tomberek: I didn't know what project you're working on ^^
00:28:01 <LambdaDusk> I have experimented a lot with netwire recently, but in the direction of gaming stuff
00:29:03 <tomberek> LamdaDusk: just something for the command line using ansi-terminal
00:29:43 <tomberek> LambdaDusk: I just want to avoid the polling-like main loop, but instead just trigger a callback on various events
00:30:35 <LambdaDusk> tomberek: Just remember the session is stateful
00:32:42 <tomberek> LamdaDusk: sure.... or is all this something I shouldn't worry about and just use the standard stepSession loop?  (i've made that work, i was wondering if there was a better solution that doesn't seem so wasteful)
00:35:43 <LambdaDusk> tomberek: Really depends... if you have a main loop anyway. There's many ways to achieve this, and in my opinion AFRP isn't really that well explored to come up with a "best solution" that easily. Why not try both and run some benchmarks and tests?
00:36:25 <tomberek> LamdaDusk: got it, I didn't know if there was some standard solution that i was unaware of... thanks for the help!
00:37:18 <LambdaDusk> tomberek: no problem
00:37:38 <LambdaDusk> tomberek: Let me know how it turned out
00:38:10 <tomberek> ok, (right now i'm finding out that System.Event and GHC.Event are not in the windows build... gar!)
00:38:35 <LambdaDusk> haskell + windows = torture
00:39:48 <tomberek> yeah.. i know
00:40:17 <LambdaDusk> took me ages to find a way to load textures on windows and linux with the same code
00:53:12 <LambdaDusk> tomberek: maybe http://hackage.haskell.org/package/hlibev helps?
00:56:43 <tomberek> LamdaDusk: not sure,,,if I can figure out how to make a EvLoopPtr to use Iocallback, but i might be a bit out of my league here
00:57:32 <latermuse> http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
01:01:19 <latermuse> haskell beats c is a pretty big name for a paper
01:04:09 <latermuse> great read though
01:04:29 <LambdaDusk> latermuse: Getting haskell to be faster than an equivalent C program usually results in ugly haskell code that is almost the same as the C code anyway
01:08:11 <mm_freak_> LambdaDusk: that's not true…  i get very close to C with idiomatic haskell…  it's just that people disagree on what idiomatic means
01:08:19 <mm_freak_> lists are almost never idiomatic
01:17:47 <Rotaerk_> mm_freak_, odd for something that's "never idiomatic" to be so ubiquitous in introductions to the language
01:33:07 <kaan_> hi, i've got a question regarding data types and constructors. I want a data type, which contains the Integers 0 to 9 and a blank (it's a sudoku game)
01:33:28 <kaan_> i started like this data Cell = 0 | ..| 9 | B
01:33:37 <kaan_> but this won't work
01:33:54 <kaan_> it says "parse error on '0' "
01:36:01 <kaan_> How can I implement it?
01:37:16 <mikeplus64> kaan_: can't start data constructor names with numbers
01:37:27 <mikeplus64> it has to be an upper case letter
01:37:44 <mikeplus64> so maybe data Cell = C0 | C1 | ... | C9 | B
01:38:35 <mikeplus64> kaan_: but if you really want numbers, then just use one, e.g. data Cell = Cell Int | B
01:38:50 <mikeplus64> if you want small positive numbers you can import Data.Word and use data Cell = Cell Word8 | B
01:38:59 <kaan_> But then it isn't restricted to 0-9
01:40:13 <mikeplus64> yeah. so maybe you do want data Cell = C0 | ...
01:40:25 <arkeet> or maybe you want a smart constructor
01:40:46 <arkeet> having a large number of constructors is ugly.
01:41:25 <kaan_> mikeplus64, C0..C9 is nice, but when I make it an instance of Show I've got to write 11 shows..
01:41:39 <arkeet> not just Show; you have to use that everywhere.
01:41:43 <mikeplus64> kaan_: data Cell = C0 | ... deriving Show
01:42:07 <kaan_> mikeplus64, then, it prints out C0, but I want only 0
01:42:12 <arkeet> kaan_: you should read about smart constructors.
01:42:22 <kaan_> okay I will do that
01:43:19 <mikeplus64> arkeet: even if you have cell :: Word8 -> Cell if the word8 is out of the bounds it's a runtime error. smart constructors don't really help for this i think
01:43:47 <arkeet> help for what?
01:45:15 <mikeplus64> to statically say that making a cell won't raise an exception i guess? that if you try to make an invalid cell, it's a compile time error
01:45:21 <kaan_> Yes, then it throws an Exception
01:45:28 <arkeet> or you could return a Maybe value.
01:45:37 <arkeet> mikeplus64: what if the cell value isn't known at compile time?
01:45:53 <mikeplus64> arkeet: then it's still limited to the constructors you made
01:46:14 <arkeet> how do you make one?
01:46:22 <kaan_> hmm is it my little understanding, or is this a flaw in haskell...
01:46:26 <kaan_> =
01:46:27 <kaan_> ?
01:46:40 <mikeplus64> arkeet: by typing C0?
01:46:48 <arkeet> mikeplus64: at runtime?
01:47:00 <arkeet> kaan_: haskell isn't really any worse than other languages at this
01:47:21 <kaan_> arkeet, agreed
01:48:14 <kaan_> okay, then I use N Int.. I don't want to write so many show instances.. and of course it would also be impossible, if I only wanted ints from 0 to 1000...
01:48:23 <arkeet> right, it doesn't scale.
01:49:23 <mikeplus64> you don't have to write "so many show instances", it would just be show (N i) = show i
01:49:42 <arkeet> you have to write a lot if it's C0 | C1 | C2 | ...
01:50:04 <arkeet> well, unless you derive Enum and use that or something.
01:50:20 <kaan_> mikeplus64, yes I meant that for C0 to C9
01:51:48 <kaan_> same problem with defining the field.. data Row = [Cell], but then, there could be more than 9 Cells...
01:51:50 <mikeplus64> yeah. i think it will be simplest to just use type Cell = Maybe Int/Word/Word8/whatever
01:53:44 <mikeplus64> i think for the whole board it would be easier to use Array (Int, Int) Cell, at least that way you know that rows are allt he same length
01:53:52 <mikeplus64> (or whatever array type you fancy most)
01:53:57 <ski_> kaan_ : perhaps you could remove the `B' case and instead use `Maybe' ?
01:54:10 <arkeet> I would use Maybe indeed.
01:54:12 <ski_> kaan_ : also, why use `show' if you want `0' rather than `C0' ?
01:54:32 <kaan_> the B is for Blank
01:54:35 <ski_> i know
01:54:56 <arkeet> data Cell = N Int | B -- note that Cell is the same as Maybe Int
01:54:59 <kaan_> show B = " ", otherwise, the board won't align well
01:55:08 <kaan_> ( I want to show it in the console)
01:55:17 <arkeet> kaan_: the point is that you should perhaps write a function other than show.
01:55:25 <arkeet> for displaying a cell.
01:55:26 <ski_> `show' is mainly intended for interactive testing/debugging, as as a quick simple way of serializing
01:55:30 <arkeet> ^
01:55:55 <arkeet> in particular, the result of show should something like an expression that can be read back with read.
01:55:56 <ski_> since you want something else, consider writing another function for displaying a board, not using `show'
01:56:22 <ski_> (s/as as/or as/)
01:56:53 <kaan_> ski_, what do you mean by that?
01:57:34 <ski_> i was correcting a grammar mistake i made
01:57:40 <kaan_> okay :-)
01:58:48 <kaan_> I am going with the Maybe Int, that's best in my opinion.
01:58:55 <arkeet> I agree.
01:58:58 <arkeet> :)
01:59:14 <kaan_> and as you sad, I use a function for creating the field...
01:59:16 <kaan_> thanks
02:15:15 <kaan_> okay, I am out thanks to you all, mikeplus64, arkeet, ski_
02:15:26 <kaan_> :-)
02:36:26 <tomberek> @src (-->)
02:36:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:36:31 <tomberek> :t (-->)
02:36:32 <lambdabot> parse error (possibly incorrect indentation)
02:36:46 <mikeplus64> @hoogle (-->) +xmonad
02:36:47 <lambdabot> Could not find some databases: xmonad
02:36:47 <lambdabot> Searching in:
02:36:47 <lambdabot>   .
02:36:53 <mikeplus64> @hoogle (-->)
02:36:53 <lambdabot> No results found
02:37:19 <tomberek> it does something
02:38:08 <tomberek> ah, i found it
02:38:23 <Kinnison> http://xmonad.org/xmonad-docs/xmonad/XMonad-ManageHook.html#v:-45--45--62-
02:38:47 <Kinnison> that was surprisingly tough to hunt down
02:39:34 <tomberek> Control.Wire.Trans.Switch
02:40:13 <tomberek> Kinnison: that's the one i was looking for
02:40:35 * Kinnison got side-tracked by mikeplus64 and his +xmonad :-)
02:40:37 <tomberek> http://hackage.haskell.org/packages/archive/netwire/4.0.7/doc/html/Control-Wire-Trans-Switch.html#v:-45--45--62-
02:40:54 <tomberek> is there a combinator for liftA2 (,)  ?
02:41:09 <arkeet> you mean like liftA2 (,) ?
02:41:19 <Kinnison> :t liftA2 (,)
02:41:20 <lambdabot> Applicative f => f a -> f b -> f (a, b)
02:41:50 <Kinnison> Not that I can spot
02:42:01 <tomberek> so i can do    foo  `something`  bar    and get the f (a,b)
02:42:41 <arkeet> if f is (r ->) then you could use (&&&)
02:42:56 <tomberek> :t (&&&)
02:42:57 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:43:11 <tomberek> hm.....
02:46:54 <arkeet> you can also always define your own operator for it.
02:56:56 <lewis1711> http://hpaste.org/85289 this doesn't work because FileSize returns "FileOffset" and not "IO FileOffset" right?
02:57:33 <lewis1711> (trying to replace the commented out code)
02:58:41 <ski_> you have an unmatched bracket
02:58:54 <ski_> and you want to use `return' to get it to type check
02:59:12 <Kinnison> tomberek: Prelude Control.Applicative> let x <**> y = pure (,) <*> x <*> y
02:59:12 <Kinnison> Prelude Control.Applicative> :t (<**>)
02:59:12 <Kinnison> (<**>) :: Applicative f => f a1 -> f a -> f (a1, a)
02:59:14 <ski_>   getFileSize path = return . fileSize =<< getFileStatus path
02:59:19 <lewis1711> yes, that too
02:59:26 <Kinnison> tomberek: is that what you were hoping for?
02:59:29 <ski_> which in this case can be abbreviated to
02:59:38 <ski_>   getFileSize path = liftM fileSize (getFileStatus path)
02:59:50 <lewis1711> ohhh, I thought return was a part of do notation, like <-
02:59:57 <lewis1711> cool, didn't know it was an actual function
03:00:02 <ski_> (you can alternatively use `fmap' or `(<$>)' instead of `liftM')
03:00:07 <hiptobecubic> :t return
03:00:07 <ski_> yes, it is
03:00:07 <tomberek> Kinnison, yes, i've seen that in some code, is that already in Control.Applicative? i didn't see it in the latest versions
03:00:08 <lambdabot> Monad m => a -> m a
03:00:15 <Kinnison> tomberek: No, i just wrote it :-)
03:00:17 <ski_>   return :: a -> IO a  -- in your case
03:00:28 <Kinnison> tomberek: let x <**> y = pure (,) <*> x <*> y
03:00:28 <arkeet> @hoogle <**>
03:00:28 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
03:00:35 <lewis1711> that signature makes very little sense though. how does it know what the "m" is if you juts give it "a"?
03:00:36 <arkeet> too bad it already exists and conflicts with something else :p
03:00:39 * Kinnison knows
03:00:44 <Kinnison> I was just picking something easy to type
03:00:48 <hiptobecubic> arkeet, flipped <*> ?
03:00:51 * Kinnison is wrong-lazy :-)
03:00:54 <arkeet> hiptobecubic: no
03:01:01 <hiptobecubic> :t (<*>)
03:01:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:01:05 <arkeet> that "executes the actions" in the wrong order
03:01:11 <hiptobecubic> ah
03:01:55 <monsieurlu> hey guys, I'm looking for the division algorithm for large integer used in haskell.. does someone know where I can find it?
03:02:53 <tomberek> oh well, I guess liftA2 (,) will work
03:02:55 <arkeet> monsieurlu: ghc uses gmp for its big integers.
03:04:30 <lewis1711> thanks ski_. slightly more confused but have somewhere to start fro
03:04:32 <lewis1711> m
03:05:44 <monsieurlu> arkeet: oh ok. is this librarie haskell code?
03:07:51 <lewis1711> :t return
03:07:53 <lambdabot> Monad m => a -> m a
03:08:02 <lewis1711> how does it "choose" m?
03:08:08 <lewis1711> there is no info about m in the argument
03:08:29 <Kinnison> lewis1711: the type of the point of use (if that's the right way to describe it) will constrain m
03:08:53 <ski_> lewis1711 : it is overloaded, just like `read :: Read a => String -> a' is overloaded
03:08:58 <arkeet> :t 5
03:08:59 <lambdabot> Num a => a
03:09:00 <ski_> > not (read "False")
03:09:01 <lambdabot>   True
03:09:04 <arkeet> same way it chooses a here
03:09:07 <ski_> > 2 * (read "False")
03:09:08 <arkeet> to be e.g. Int or Double
03:09:08 <lambdabot>   *Exception: Prelude.read: no parse
03:09:09 <Kinnison> lewis1711: eventually the type system will work out what it's meant to be, or else it'll complain about ambiguities
03:09:09 <ski_> > 2 * (read "3")
03:09:10 <arkeet> or whatever.
03:09:11 <lambdabot>   6
03:09:26 <arkeet> (except there is defaulting for Num.)
03:09:28 <lewis1711> ok, I sort of understand, but right now I am just going to file it under "magic"
03:09:37 <arkeet> it's the same type inference as usual.
03:09:56 <ski_> > 2 + (3 :: Double)
03:09:58 <lambdabot>   5.0
03:09:59 <ski_> > 2 + (3 :: Rational)
03:10:01 <lambdabot>   5 % 1
03:10:31 <ski_> lewis1711 : in this case, it chooses different things to do for the `+', depending on the types
03:10:43 <ski_> > (2 :: Rational) + (3 :: Rational) :: Rational
03:10:44 <lambdabot>   5 % 1
03:10:50 <ski_> > (2 :: Double) + (3 :: Rational)
03:10:51 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
03:10:51 <lambdabot>              with actual ty...
03:10:56 <ski_> > 2 + (3 :: Rational) :: Double
03:10:58 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
03:10:58 <lambdabot>              with actual ty...
03:11:06 <lewis1711> ski_: where my brain is failing is that, with say (+), we know the type constructor. it's num
03:11:17 <lewis1711> with return we don't know it
03:11:17 <quchen> lewis1711: Consider the following code: "do { x <- Just 1; return x }". There's a "Just" in there, so the compiler knows you're using the Maybe monad, so it can conclude that the "return" is also a Maybe statement.
03:11:21 <ski_> the two arguments to `+', and the result, must be of the same numeric type, otherwise it will complain
03:11:21 <arkeet> Num isn't a type constructor.
03:11:32 <lewis1711> type class?
03:11:33 <arkeet> yes
03:11:43 <ski_> lewis1711 : it's "just" overloading on the return type
03:11:47 <arkeet> but it doesn't matter whether there's a type class or not
03:12:08 <arkeet> say I write something like
03:12:18 <arkeet> > return 5 ++ [1,2]
03:12:21 <lambdabot>   [5,1,2]
03:12:30 <ski_> lewis1711 : in any case, it does *not* decide on the overloading by looking at the *values* passed to it at run-time. it decides at compile-time, based on the types
03:12:32 <arkeet> er, let's pretend numbers are Int.
03:12:36 <arkeet> a priori, return 5 has type Monad m => m Int
03:12:49 <arkeet> but we're using it as an argument to (++) :: [a] -> [a] -> [a]
03:12:55 <arkeet> so it unifies m Int with [a]
03:12:58 <arkeet> and concludes that m = []
03:13:02 <arkeet> (and a = Int)
03:13:29 <ski_> (and the type `[a]' is a shorthand for `[] a', so matches `m a' with `m = []' as arkeet says)
03:13:48 <ski_> (er, matches `m Int', i suppose)
03:13:51 <arkeet> type information does not propagate only in one direction.
03:14:18 <lewis1711> arkeet: ahh. yes haskell does strange things with directions
03:16:05 <lewis1711> I appreciate the explinations, they're being absorbed slowly :)
03:51:49 <mm_freak_> Rotaerk_: not saying that it's wrong to use lists, but in almost all scenarios i found better abstractions
03:52:09 <mm_freak_> streams, arrays, maps, trees, conduits/pipes, …
03:54:54 <lewis1711> I'm really, really hungry recently
03:55:07 <lewis1711> whoops wrong channel
03:55:58 * osfameron giggles
03:56:31 <donri> list is a control structure, and it's great for that
03:57:56 <donri> at least for pure computations :p
03:59:26 <luite> http://hdiff.luite.com/reduce/cycle/
03:59:59 * hackagebot cabal2nix 1.49 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.49 (PeterSimons)
04:00:04 <donri> luite: this like stepeval?
04:00:47 <luite> donri: stepeval does graph reduction directy on the expression, this shows the stg machine stack and heap
04:01:13 <donri> neato
04:01:13 <luite> the ghcjs rts is running the thing in the background
04:01:31 <luite> it just calls the function to draw the whole heap and stack every reduction step
04:01:52 <luite> (it's easy to do this with any running ghcjs compiled program, just replace the main loop (h$mainLoop) with this one
04:01:55 <luite> )
04:02:27 <donri> luite: ghcjs http://youtu.be/e_DqV1xdf-Y
04:02:33 <luite> donri: see here for more examples http://hdiff.luite.com/reduce/
04:02:57 <luite> the foldl, foldr, foldl' are interesting, you can see how foldl and foldr blow the stack in different ways
04:03:04 <luite> and foldl' works with constant stack
04:03:30 <luite> the sum/cycle thing doesnt build a long list, but still a lot of thunks due to the laziness of sum
04:03:52 <luite> this is all compiled without optimization, with demand analysis, much of the heap would disappear
04:04:48 <luite> donri: i hope we can expand this stuff and uses it as a debugger
04:04:54 <luite> but we'll need more source mapping information
04:08:14 <klrr> what's the reason to have both fmap and map? also, a list is a functor?
04:08:47 <Iceland_jack> klrr: People have argued to combine the two
04:08:59 <donri> klrr: historical reasons, and polymorphism being harder to teach
04:09:04 <Iceland_jack> Some people feel that the type signature of ‘fmap’ would be too difficult
04:11:00 <klrr> > :t fmap
04:11:02 <lambdabot>   <hint>:1:1: parse error on input `:'
04:11:09 <klrr> ?type fmap
04:11:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:11:19 <klrr> ?type map
04:11:20 <lambdabot> (a -> b) -> [a] -> [b]
04:11:27 <klrr> isn''t the the same?
04:11:30 <klrr> they*
04:11:31 <shachaf> klrr: It used to be that fmap was called map.
04:11:43 <shachaf> Some people found the error messages confusing so they specialized it.
04:11:47 <Iceland_jack> klrr: one is a specialization of the other
04:11:58 <shachaf> klrr: A list is not a functor. But the type (constructor) [] is a functor.
04:12:18 <klrr> ?type []
04:12:19 <shachaf> Just like Maybe is a functor but Just 5 isn't. :-)
04:12:19 <lambdabot> [a]
04:12:25 <shachaf> No, not the value []
04:12:31 <donri> :k []
04:12:32 <lambdabot> * -> *
04:12:44 <shachaf> @ty map :: (a -> b) -> [] a -> [] b -- an alternative way of writing that type
04:12:45 <lambdabot> (a -> b) -> [a] -> [b]
04:12:55 <ski_> @src [] fmap
04:12:55 <lambdabot> fmap = map
04:12:55 <klrr> well food brb
04:13:02 <shachaf> [a] is just syntax sugar for ([] a), and the type (constructor) [] isn't special -- it's just like Maybe.
04:13:47 * donri really thinks it'd be nicer if it was just "List"
04:13:47 <__xc> > take 5 $ zip [1..] (intersperse False $ repeat True)
04:13:48 <lambdabot>   [(1,True),(2,False),(3,True),(4,False),(5,True)]
04:13:50 <Iceland_jack> It can be confusing, like now (,) is either an explicit tuple (α → β → (α, β)) or a type constructor (★ → ★ → ★)
04:13:53 <Iceland_jack> *like how
04:13:57 <lewis1711> speak of the devil, I was just looking into that
04:13:59 <lewis1711> http://stackoverflow.com/questions/7463500/why-do-we-have-map-fmap-and-liftm
04:14:13 <lewis1711> the top voted answer has a pretty good explination
04:18:38 <__xc> > take 5 $ map (\n->(n,odd n) [1..]
04:18:40 <lambdabot>   <hint>:1:34: parse error (possibly incorrect indentation)
04:18:50 <__xc> > take 5 $ map (\n->(n,odd n)) [1..]
04:18:51 <lambdabot>   [(1,True),(2,False),(3,True),(4,False),(5,True)]
04:20:22 <lewis1711> ' theForm : _ <- getFormsByAction "http://anotherpage.com/" ' what does ': _ mean
04:20:59 <__xc> > 1 == (1)
04:21:00 <lambdabot>   True
04:21:25 <danr> lewis1711: it means that theForm is bound to the first element of the list and nothing (therefore the underscore) is bound to the tail of the list
04:21:49 <danr> lewis1711: the colon, :, pronounced cons, is the constructor for lists. it is written infix
04:23:19 <lewis1711> oh, it's just list syntax. thought it was some strange do notation thing
04:25:03 <danr> lewis1711: right. and you can pattern match on the left of the do notation arrow
04:28:58 <timthelion> I cannot seem to find the docs on anotating function deffinitions with quickchecks.  The wikipage just tells how to do it through GHCI. Where can I find such docs?
04:32:07 <__xc> can you pattern match deeply, like  (True, x) : _ <- ..  ; (False,_) : _ <- ... ; ..
04:32:51 <shachaf> That depends on what "deeply" means.
04:33:03 <shachaf> You can't match on multiple patterns in a do block -- you'll need to use case or something.
04:33:14 <shachaf> But your pattern can be arbitrarily complicated.
04:34:45 <__xc> thx, you answered 2 questions
04:35:19 <shachaf> You could've figured out the answer to at least one of them by trying it yourself. :-)
04:35:43 <timthelion> > do (x:_) <- Just [1] ; f <- Nothing ; return x -- shachaf: well you can: you just don't get a result that acts as a choice.
04:35:45 <lambdabot>   Nothing
04:36:13 <lewis1711> having the interpreter give me angry messages is one of my favourite parts about haskell
04:36:57 <timthelion> > do (((x,_),_),_) <- (((1,2),3),4) ; return x -- __xc
04:36:59 <lambdabot>   No instance for (GHC.Base.Monad ((,) ((t1, t2), t0)))
04:36:59 <lambdabot>    arising from a use...
04:37:08 <timthelion> > do (((x,_),_),_) <- Just (((1,2),3),4) ; return x -- __xc
04:37:10 <lambdabot>   Just 1
04:45:26 <ski_> > do x:_ <- Just [1] ; f <- Nothing ; return x
04:45:28 <lambdabot>   Nothing
04:47:07 <__xc> > let pm x = case x of (((y,_),_),_) -> y; ((y,_),_) -> y; (y, _)->y in pm (((1,2),3),4) -- don't get the problem there ;(
04:47:08 <lambdabot>   Occurs check: cannot construct the infinite type:
04:47:08 <lambdabot>    t1 = ((t1, t2), t0)Occ...
04:48:59 <__xc> > let pm (((y,_),_),_) = y; pm ((y,_),_) = y;pm (y, _)=y;pm _ = "ok" in pm (((1,2),3),4)
04:49:01 <lambdabot>   Couldn't match type `(,) [GHC.Types.Char]' with `[]'Couldn't match type `(,...
04:49:58 <quchen> __xc: Your return types aren't the same in each case. "ok" is a String, but the "y" in the first pattern is an Int.
04:50:14 <__xc> yes
04:50:33 <__xc> > let pm (((y,_),_),_) = y; pm ((y,_),_) = y;pm (y, _)=y;pm _ = 0 in pm (((1,2),3),4)
04:50:35 <lambdabot>   Occurs check: cannot construct the infinite type:
04:50:35 <lambdabot>    t1 = ((t1, t2), t0)Occ...
04:51:05 <quchen> y in the second pattern is a tuple.
04:54:20 <RenJuan> anybody know of a haskellers vs. location info of any sort? e.g. IPs in the channel vs geo location.
04:54:45 <donri> @where haskellers
04:54:46 <lambdabot> I know nothing about haskellers.
04:54:53 <timthelion> http://www.haskellers.com/
04:54:53 <quchen> @google haskellers
04:54:55 <lambdabot> http://www.haskellers.com/
04:54:55 <lambdabot> Title: Haskellers
04:55:14 <donri> @wiki Haskellers
04:55:14 <lambdabot> http://www.haskell.org/haskellwiki/Haskellers
04:55:20 <donri> :(
04:55:31 <donri> i seem to recall a map of haskellers
04:55:40 <klrr> is there any language that is more excellent than haskell?=
04:55:50 <timthelion> donri: look at the link I posted.
04:55:51 <donri> klrr: yes. next question!
04:56:09 <timthelion> donri: which language?
04:56:10 <RenJuan> thx, all
04:56:25 <klrr> donri: okey , next question, which one?
04:56:31 <klrr> java? (kidding dont ban me :P )
04:56:42 <quchen> PHP has great runtime type resolving
04:56:42 <donri> timthelion: every language is more excellent at being that language than haskell
04:56:56 <timthelion> klrr: what about elm?
04:57:03 <klrr> timthelion: what's that?
04:57:03 <ski_> @map
04:57:03 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:57:08 <donri> ski_: ah
04:57:25 <timthelion> klrr: http://elm-lang.org/
04:57:30 <donri> klrr: define excellent? not sure there is an absolute measure.
04:57:36 * timthelion doesn't like elm, because it's not lazy.
04:57:46 <ski_> @wiki Haskell user locations
04:57:46 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_user_locations
04:57:49 <donri> timthelion: idris!
04:57:50 <ski_> RenJuan ^
04:58:28 <timthelion> donri: I read a tutorial on idris today in which a guy supposedly proved "reverse" is the same as "reverse". I didn't get the point.
04:58:51 <klrr> donri: while learning, you say "wow" all the time and am supprised how excellent everything is
04:59:03 <donri> timthelion: well it's interesting because it's strict but total so strictness doesn't really matter
04:59:26 <donri> klrr: maybe you mean "interesting" or "novel"
04:59:38 <quchen> reverse is total? That's new.
04:59:39 <timthelion> klrr: try j.
04:59:41 <RenJuan> ski, thx!
05:00:04 <ski_> yw
05:00:06 <klrr> hmm
05:00:15 <donri> klrr: if so my suggestions include: elm, agda, idris, rust, some lisp
05:00:22 <timthelion> klrr: have you used erlang yet?
05:00:39 <donri> timthelion: for finite lists, sure
05:00:42 <ski_> klrr : you should look into logic programming, if you haven't yet
05:00:59 <donri> timthelion: but i was talking about idris in general
05:01:00 <ski_> like Prolog,Mercury,Oz
05:01:40 <donri> timthelion: (of course it has both optional laziness and configurable totality checker)
05:02:16 * timthelion googles total functional programming.
05:02:46 <donri> timthelion: https://github.com/edwinb/Idris-dev/wiki/Unofficial-FAQ
05:03:24 <klrr> timthelion: nope
05:03:42 <klrr> ive only used C, scheme, python, game maker language and haskell
05:03:48 <klrr> scheme and c was nice :D
05:04:58 <timthelion> klrr: then I think you should try a visual language, like piet or befunge.
05:05:13 <klrr> visual language?Å
05:05:56 <timthelion> klrr: google them
05:06:22 <Hidenori> is it okay to ask a question abt haskell?
05:06:36 <timthelion> Hidenori: Probably :)
05:06:46 <timthelion> Hidenori: but asking about asking is off topic here.
05:07:04 <Hidenori> i see lol
05:07:28 <donri> klrr: if you're looking for theoretical beauty you should maybe study dependent types (agda and idris are good contenders)
05:08:51 <Hidenori> im reading Learn You a Haskell for Great good and made a function that looks like "removeNonUppercase st = [ c <- st, c `elem` [ 'A'..'Z']]"
05:09:54 <donri> Hidenori: you probably want [ c | c <- st, c `elem` ... ]
05:09:56 <Hidenori> and the textbook says the type of this function is "[Char]->[Char]" but it takes sth like [1,2,3] and returns it but i thought [1,2,3] is not [Char] so im confused
05:10:24 <Hidenori> donri : aww you're right
05:10:40 <quchen> :t let removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] in removeNonUppercase
05:10:42 <lambdabot> [Char] -> [Char]
05:10:56 <__xc> hmm yes quchen, i've missed a chapter ;)  because I didn't think the following was wrong
05:11:00 <__xc> > let foo (Just (Just x)) = x; foo (Just x) = x; foo _ = 0 in foo (Just (Just 3))
05:11:01 <lambdabot>   Occurs check: cannot construct the infinite type:
05:11:02 <lambdabot>    t0 = Data.Maybe.Maybe t0
05:11:39 <__xc> > let foo (Just x) = x; foo _ = 0 in foo (Just 3)
05:11:41 <lambdabot>   3
05:12:03 <ski_> > let foo (Just (Just x)) = Left x; foo (Just x) = Right x; foo _ = Left 0 in foo (Just (Just 3))
05:12:05 <lambdabot>   Left 3
05:13:05 <__xc> so it wants a Data.Maybe
05:13:17 <quchen> ..?
05:13:18 <ski_> it's just `Maybe'
05:16:19 <__xc> trying a sort of deep fromMaybe
05:16:41 <ski_> what is the type you want for the operation ?
05:17:18 <__xc> good question
05:18:03 <__xc> :) not possible, probably
05:18:41 <__xc> but the same idea with tuples abive should work, Tuples are not types
05:18:52 <quchen> Tuples are types.
05:19:01 <ski_> tuples *have* types
05:19:24 <__xc> hmm no, ((Int,Int),Int) is not (Int,Int)
05:19:26 <ski_> (tuple types, namely (which would be distinct from type tuples, had Haskell had any such))
05:19:46 <__xc> yes, I'm wrong
05:20:25 <__xc> what I'm thinking is simply a recursing function
05:22:15 <merijn> I think I get what you want, but it won't work without dependent types
05:22:45 <merijn> i.e. traverse an arbitrary number of Maybe's to retrieve the inner value (or throw an exception if the inner thing is Nothing)
05:23:13 <ski_> how would it know when to stop ?
05:23:20 <merijn> Might not even be possible with dependent types, tbh
05:23:25 <__xc> yes just playing though ;)
05:23:54 <__xc> something like 'flatten'
05:23:55 <ski_> if you pass a natural number, it would be possible, obviously
05:24:18 <__xc> :t flatten
05:24:20 <lambdabot> Tree a -> [a]
05:24:31 <ski_> otherwise, it seems to require telling at run-time whether the current value is of type `Maybe a' for some `a' or not
05:25:08 <__xc> > flatten [[1,2],3]
05:25:10 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a0'
05:25:10 <lambdabot>              with actual t...
05:25:12 <merijn> ski_: You could probably do it with terribly hacky abuse of Data.Typeable, I guess
05:25:33 <ski_> yes (but dependent types doesn't entail type classes :)
05:25:39 <tootsie> > concat [[1,2,3],[4,5,6]]
05:25:40 <lambdabot>   [1,2,3,4,5,6]
05:26:00 <ski_> __xc : we like parametric polymorphism
05:26:02 <merijn> ski_: I was thinking whether you could do it by structural inspection of the types in a dependent language
05:26:22 <ski_> merijn : yes, which would then fail parametricity
05:26:23 <merijn> ski_: With Data.Typeable I think you can manage a terrible version in haskell
05:26:39 * ski_ nods
05:27:19 <merijn> But I wouldn't recommend it for anything beyond shits & giggles :p
05:27:51 <hpaste> quchen pasted “Flattening!” at http://hpaste.org/85293
05:28:16 <quchen> You can do some flatten-able structure using essentially "Nested a = Either a (Nested a)".
05:31:29 <ski_> quchen : also try with `data Nested a = Value a | Deep [Nested a]' and `data Nested a = Value a | Deep (Nested [a])'
05:32:22 <luite> donri: hm, i think i should modify the stack view in the step by step reduce to use one graph node per stack frame, not per stack slot
05:34:55 <ski_> merijn : .. the question is how to write `dynMaybe :: Dynamic -> Maybe Dynamic' with `dynMaybe (toDyn Nothing) = Nothing' and `dynMaybe (toDyn (Just a)) = Just (toDyn a)'
05:35:08 <ski_> (preferably without using `unsafeCoerce')
05:36:39 <ski_> (.. or more generally, how to also do similar things for other types)
05:37:23 <ski_> (i think in Clean with its builtin support for dynamics (even polymorphic, iirc), this would just be a matter of pattern-matching)
05:41:33 <ski_> (indeed : "Checking and Unifying Types Schemes using Type Pattern Variables" <http://clean.cs.ru.nl/download/html_report/CleanRep.2.2_10.htm#_Toc311798086>)
05:44:18 <Saizan> would be cool to have a typeclass system that could handle dynamics for polymorphic types
05:44:56 <whatdoesitmean> I know this is not the best channel to ask but can someone tell me what is his interpretation of this illustration? http://oi47.tinypic.com/29pb382.jpg Would be interesting to see if different people have similar interpretations
05:44:58 <whatdoesitmean> http://oi47.tinypic.com/29pb382.jpg
05:45:24 <ski_> hm, `Dynamic -> (forall a. Typeable a => a -> o) -> o' could work, if one could reify run-time knowledge about `a' to compile-time
05:47:40 <XexonixXexillion> can fgl handle graphs with about 56k nodes?, I keep getting a stack overflow in my code and can't work out why
05:47:54 <__xc> data Nested a = Value a | Deep [Nested a] == Trees?
05:48:22 <__xc> > flatten $ Node 12 [Node 3 [Node 4 [], Node 5 []]]
05:48:24 <lambdabot>   [12,3,4,5]
05:48:58 <ski_> __xc : some kind of tree, yes (which kind ?)
05:49:29 <__xc> forgot the name
05:49:51 <__xc> multiple children - trees
05:50:17 <tootsie> @src concat
05:50:18 <lambdabot> concat = foldr (++) []
05:50:29 <ski_> hm .. `dynIORef :: Dynamic -> IORef Dynamic' wouldn't be very useful
05:50:38 <tootsie> > concat ['a','b']
05:50:39 <lambdabot>   Couldn't match expected type `[a0]'
05:50:40 <lambdabot>              with actual type `GHC.Type...
05:50:48 <tootsie> > concat ["hello", "there"]
05:50:50 <lambdabot>   "hellothere"
05:51:00 <ski_> __xc : .. and elements where ?
05:51:04 <mm_freak_> donri: even as a control structure i regularly find streams to fit better
05:51:08 <mm_freak_> and they are faster, too
05:51:27 <mm_freak_> if you don't need the [], you could just as well go without it
05:52:32 <__xc> ski_, elements are a list a Trees
05:52:53 <ski_> __xc : sorry, i don't understand what you mean
05:53:08 <__xc> Nodes*
05:53:21 <jassper> hello
05:53:28 <ski_> __xc : where are the elements of this tree located ?
05:53:34 <ski_> hello jassper
05:53:53 <jassper> I was writing my code using error but recently realized it does not set the exitcode like System.Exit.exitFailure
05:54:29 <jassper> however the latter returns IO a, and I used error at places where IO monad is not there...
05:55:02 <jassper> is there something standard to cover this? or can I do unsafePerformIO exitFailure ?
05:56:10 <tootsie> sockets: select returns the nbr of sockets ready for something. but how doe sthat help me if i dont know which they are? i want the ones that are ready, not just how many. do i Have to do select with just one socket at a time?
05:56:24 <ski_> jassper : you could try setting an exception handler catching the `error's and using the appropriate exit code, i suppose
05:56:28 <geekosaur> jassper, an untrapped "error" should force some non-zero exit code, but you can't specify which directly. you can trap it in main though
05:57:24 <jassper> untrapped error gives zero exit code here...
05:57:30 <__xc> ski_,they belong to a Tree,  the  possible representation haskell uses is with a Node Id and its list of Noe children
05:57:46 <__xc> but you know it
05:57:56 <jassper> I have ghc-7.4.1-1ubuntu2
05:58:13 <__xc> Node value* an ..
05:58:15 <ski_> __xc : yes. i suppose i was after you saying that you know the elements are in the *leaves* of the tree (as opposed to in the internal nodes)
05:58:56 <__xc> totally right
05:59:00 <ski_> __xc : and how does this kind of tree differ from `data Nested a = Value a | Deep (Nested [a])' ?
05:59:33 <__xc> there is no value, in each node I guess
05:59:57 <ski_> that is true for both kinds of trees, so it's not a difference
05:59:57 <__xc> in the one above
06:00:02 * hackagebot computational-algebra 0.1.3.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.3.0 (HiromiIshii)
06:00:25 <__xc> > Node 12 [Node 3 [Node 4 [], Node 5 []]]
06:00:27 <lambdabot>   Node {rootLabel = 12, subForest = [Node {rootLabel = 3, subForest = [Node {...
06:00:43 <ski_> (i.e. true for both `data Nested a = Value a | Deep [Nested a]' and `data Nested a = Value a | Deep (Nested [a])', i mean)
06:00:47 <__xc> this ^ is not just leaves
06:00:47 * geekosaur is getting $? = 1 for "error" on mint (ubuntu derivative), fwiw
06:00:59 <ski_> yes, i was not talking about that kind tree
06:01:03 <__xc> a ok
06:01:11 <ski_> s/tree/of tree/
06:01:37 <__xc> the diff between  Deep (Nested [a]) and  Deep [Nested a] is trickey then
06:01:49 <ski_> yes ;)
06:01:53 <ski_> (but interesting)
06:02:51 <__xc> let alone  Deep [Nested [a]]
06:03:25 <ski_> yea, you can leave that one alone for the time being ..
06:04:30 <__xc> but for your question, one has 1 child max
06:04:53 <ski_> .. depends on how you think about it :)
06:05:08 <__xc> containing a list of values though
06:05:19 <ski_> try constructing an example value of type `Nested Integer', for `data Nested a = Value a | Deep (Nested [a])'
06:06:47 <__xc> Deep (Deep [Value 1, Value 2])
06:07:11 <ski_> not quite
06:07:30 <__xc> dang :
06:07:46 <ski_>   Value 0 :: Nested Integer  -- agree ?
06:07:54 <__xc> yes
06:08:11 <ski_> how about using just one `Deep' constructor, how to make a value of type `Nested Integer' then ?
06:08:13 <__xc> ah I mixed with [Value a]
06:09:15 <__xc> Deep (Value [0])
06:09:19 <ski_> yes
06:09:35 <ski_> and also `Deep (Value [0,1,2])', e.g.
06:09:45 <ski_> now, how about two `Deep' constructors ?
06:11:05 <__xc> if this is allowed
06:11:49 <ski_> it is allowed, yes
06:11:50 <__xc> but wait isn't data Nested a = [Value a] | Deep (Nested a),  isomorphic to `data Nested a = Value a | Deep (Nested [a])`
06:12:12 <ski_> `data Nested a = [Value a] | Deep (Nested a)' isn't a valid data type declaration
06:12:30 <__xc> right
06:12:39 <__xc> either a list or..
06:12:45 <ski_> if you meant `data Nested a = Value [a] | Deep (Nested a)' -- then no, it's not isomorphic to the definition under question
06:13:21 <__xc> yes  it's a larger definition
06:13:45 <ski_> it gives rise to a different "looking" data structure
06:14:22 <ski_> __xc : any idea about how to use two `Deep' data constructors to construct a value of type `Nested Integer' ?
06:14:25 <__xc> else, what is your idea with 2 Deep's?
06:14:46 <__xc> one for a Leaf, an one for not
06:14:52 <__xc> and*
06:14:57 <ski_> well, let's consider how we can construct a value of type `Nested Integer'
06:15:01 <ski_>   ??? :: Nested Integer
06:15:20 <ski_> we can select this `???' to be of shape `Value x'
06:15:25 <donri> mm_freak_: sometimes you want the laziness though? like as the monoid in a Writer, and want the elements on demand
06:15:30 <ski_>   Value x :: Nested Integer
06:15:39 <ski_>   Value (x :: Integer)
06:15:58 <ski_> but that gets us already into choosing an integer `x', and we had already seen this case
06:16:15 <ski_> so, we try instead selecting the above `???' to be of shape `Deep ???'
06:16:22 <ski_>   Deep ??? :: Nested Integer
06:16:36 <ski_>   Deep (??? :: Nested [Integer])
06:16:59 <ski_> now, we have to select a constructor to construct a `Nested [Integer]' with
06:17:08 <ski_> if we choose `Value xs', we get
06:17:13 <ski_>   Deep (Value xs :: Nested [Integer])
06:17:19 <ski_>   Deep (Value (xs :: [Integer]))
06:17:23 <donri> mm_freak_: hm, seems you can do that with sequence too
06:17:30 <ski_> and you saw this case above
06:17:35 <ski_> __xc : following ?
06:17:35 <donri> mm_freak_: (so what does it mean that Seq is strict?)
06:17:35 <__xc> WOW
06:17:40 <__xc> IF THAT WORKS
06:17:43 <__xc> oops
06:17:58 <ski_> now, let's instead select this second `???' to *also* be of shape `Deep ???'
06:17:59 <ski_> so
06:18:09 <ski_>   Deep (Deep ??? :: Nested [Integer])
06:18:21 <ski_>   Deep (Deep (??? :: Nested [[Integer]]))
06:18:38 <ski_> now, we have to select a value of type `Nested [[Integer]]'
06:18:42 <ski_> we could choose it like
06:18:49 <ski_>   Deep (Deep (Value xss :: Nested [[Integer]]))
06:18:53 <ski_> e.g., specifically
06:19:22 <ski_>   Deep (Deep (Value [[0,1],[],[2,3,4]])) :: Nested Integer
06:19:29 <ski_> __xc : seeing the pattern yet ?
06:19:54 <__xc> yes, it's isomorphic to lists dimensions
06:20:10 <__xc> wait
06:20:10 <ski_> the number of `Deep's tell the number of nested list levels
06:21:11 <ski_> compare this with
06:21:28 <__xc> how is  Deep (Deep (Value [[0,1],[],[2,3,4]])) different from a  Deep (Deep (Value [1,2,3]))
06:21:36 <__xc> it is clearly but
06:22:03 <__xc> it's hard to see where the list levels are deconstructed
06:22:12 <ski_> well
06:22:25 <ski_>   [1,2,3] :: [Integer]
06:22:33 <ski_>   Value [1,2,3] :: Nested [Integer]
06:22:41 <__xc> yes
06:22:41 <ski_>   Deep (Value [1,2,3]) :: Nested Integer
06:22:52 <__xc> yes
06:23:05 <ski_>   Deep (Deep (Value [1,2,3])) -- type error, `Integer' doesn't match `[a]' for any `a'
06:23:15 <ski_> however
06:23:21 <__xc> yes
06:23:26 <ski_>   [[0,1],[],[2,3,4]] :: [[Integer]]
06:23:33 <ski_>   Value [[0,1],[],[2,3,4]] :: Nested [[Integer]]
06:23:42 <ski_>   Deep (Value [[0,1],[],[2,3,4]]) :: Nested [Integer]
06:23:48 <ski_>   Deep (Deep (Value [[0,1],[],[2,3,4]])) :: Nested Integer
06:23:59 <__xc> and you need to manually define each level like that?
06:24:07 <ski_> compare this to
06:24:08 <ski_>   Deep [Deep [Value 0,Value 1],Deep [],Deep [Value 2,Value 3,Value 4]] :: Nested Integer  -- using the alternative (simpler) `data Nested a = Value a | Deep [Nested a]'
06:24:43 <ski_> in this simpler tree variant the `Deep'/`Value' constructors are interleaved with the list levels
06:24:46 <ski_> however, in
06:24:49 <ski_>   Deep (Deep (Value [[0,1],[],[2,3,4]])) :: Nested Integer
06:25:01 <ski_> the `Deep'/`Value' constructors all precede the list levels
06:25:11 <__xc> yes that's why the 1st example is simpler to do
06:25:29 <ski_> this also means that *all* the branches in this version *must* have the same length !
06:25:41 <ski_> (s/length/depth/, if you prefer)
06:25:48 <__xc> yes
06:26:17 <ski_> so, we can use this to represent a type of *perfectly balanced* trees, e.g. :)
06:26:28 <__xc> I was wrongly thinking of a 1-child tree initially
06:26:59 <__xc> yes the constraint can have a use
06:27:14 <__xc> it's just more painful to have contrcutors
06:28:51 <__xc> --- #haskell online course ---- :)
06:29:10 <ski_> this is close to what one could have in dependently typed programming : a pair of a natural number `n' (the depth), and an `n'-times nested list of `a's (elements)
06:33:31 <__xc> B-Trees i think, follows this
06:35:31 * ski_ doesn't know very much about B-Trees
06:38:09 <__xc> "A B-tree is kept balanced by requiring that all leaf nodes be at the same depth"  http://en.wikipedia.org/wiki/B-tree
06:38:20 <osa1_> how can I get system time in milliseconds ?
06:39:52 <quchen> osa1_: Depends on your system. Haskell can only access the time to the system's accuracy. It supports picoseconds, but the last decimals will just be some guess.
06:40:34 <osa1_> quchen: ok, so how can I read system time ? which function ?
06:40:50 <quchen> osa1_: Data.Time is the right place to look I think. http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime
06:41:33 <quchen> getCurrentTime gets you your data, what's left is extraction
06:52:06 <jassper> I have discovered the cause why certain times I got non zero error codes... I used some tools for compiler generation and the toold has swallowed :/
07:14:46 <BOY77X> http://www.reddit.com/r/amateurandpornstar/comments/1bqczi/hot_amateur_and_pornstar_gif_pictures_and_movie/
07:20:49 * hackagebot data-category 0.5.1.0 - Category theory  http://hackage.haskell.org/package/data-category-0.5.1.0 (SjoerdVisscher)
07:24:08 <aCube> Is there a function [a] -> ReaderT b [] a ?
07:24:25 <Taneb> :t lift
07:24:26 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:24:34 <aCube> oh right :) Thanks
07:24:37 <Taneb> :t lift :: [a] -> ReaderT b [] a
07:24:38 <lambdabot> [a] -> ReaderT b [] a
07:24:43 <Taneb> No problem!
07:24:59 <donri> @hoogle [a] -> ReaderT b [] a
07:24:59 <lambdabot> Did you mean: [a] -> ReaderT b [a] a
07:25:00 <lambdabot> No results found
07:25:07 <donri> silly hoogle
07:25:20 <donri> @hoogle google
07:25:20 <lambdabot> Google rocks!
07:25:20 <lambdabot> package GoogleChart
07:25:20 <lambdabot> package GoogleDirections
07:25:23 <donri> @hoogle hoogle
07:25:24 <lambdabot> Can't think of anything more interesting to search for?
07:25:24 <lambdabot> package hoogle
07:40:50 * hackagebot hmemdb 0.2.0.2 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.2.0.2 (MiguelMitrofanov)
07:50:43 <aCube> @hoogle (a -> m Bool) -> m () -> m a -> m ()
07:50:43 <lambdabot> No results found
07:50:52 <aCube> @hoogle (a -> m Bool) -> m () -> m ()
07:50:53 <lambdabot> Data.Data gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
07:50:53 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:50:53 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:51:36 <aCube> @hoogle (MonadPlus m) => (a -> m Bool) -> m () -> m ()
07:51:36 <lambdabot> Data.Data gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
07:51:36 <lambdabot> Data.Data gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
07:51:36 <lambdabot> Data.Generics.Aliases mkMp :: (MonadPlus m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
08:00:17 <klrr> ?src otherwise
08:00:17 <lambdabot> otherwise = True
08:00:23 <klrr> i knew it :P
08:01:11 <klrr> > let x = 2 in x | x > 5 = "PENIS!" | True = "MUUHAHAHAHAH!"
08:01:11 <connelly_> so I'm trying to learn the llvm package - how would I find source code that uses it to learn from examples?
08:01:13 <lambdabot>   <hint>:1:16: parse error on input `|'
08:02:00 <donri> connelly_: http://packdeps.haskellers.com/reverse/llvm best i can do
08:02:09 <connelly_> thanks
08:20:50 <dmwit> klrr: guards have to be attached to definitions
08:21:21 <dmwit> > let x = 5; y | x > 5 = "CRUDE" | True = "MUUHAHAHAHAH!" in y
08:21:23 <lambdabot>   "MUUHAHAHAHAH!"
08:22:11 <Taneb> dmwit, would that get done at compile time?
08:22:32 <donri> @hackage ghc-core
08:22:32 <lambdabot> http://hackage.haskell.org/package/ghc-core
08:22:47 <dmwit> Taneb: Probably not. There's an easy way to check, though.
08:22:54 <klrr> dmwit: oh okey
08:23:28 <dmwit> Taneb: I think generally speaking code doesn't get run at compile-time, even "simple" code like 5 > 5.
08:23:31 <klrr> well can someone explain why i get this error "dataTypeParser.hs:26:16: Parse error in pattern: char" when i try to run this code http://hpaste.org/85298 ?
08:23:42 <Taneb> Ah
08:24:02 <Taneb> I kind of view compilers in general, especially GHC, as a sort of magic box that turns programs into magic
08:24:04 <geekosaur> klrr, indentation
08:24:14 <dmwit> klrr: Lines 27-29 are indented one space too much.
08:24:38 <geekosaur> although actually that sounds like it happens after the error...
08:24:41 <klrr> okey, where can i find an explaination of all indentation rules and recomendated style?
08:24:48 <geekosaur> oh, no, that's right
08:24:51 <copumpkin> > let f False False = False; f _ _ = True in f True undefined
08:24:51 <dmwit> geekosaur: nah, it parses as "char '(' x <- "
08:24:52 <lambdabot>   True
08:25:06 <dmwit> klrr: All indentation rules are in the Report.
08:25:06 <geekosaur> indentation is actually pretty simple: if it's more indented, it's continuation
08:25:07 <dmwit> ?where report
08:25:08 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
08:25:17 <dmwit> Style is another matter.
08:25:55 <dmwit> copumpkin: This calls for... unamb!
08:26:10 <geekosaur> also we recommend not using tabs, because editors and ghc often disagree as to their meaning and that can lead to code that looks fine in your editor and still is mis-indented
08:26:19 <copumpkin> dmwit: it's a tad unexpected :)
08:26:40 <jmcarthur> copumpkin: it is?
08:26:42 <dmwit> Alternately: ask your editor to make tabs visible, and treat tabs and spaces as incomparable in width.
08:26:44 <merijn> haskell standards define tabs as being 8 spaces, so unless you have your editor set to the same, you're in for a bunch of sadness :p
08:26:49 <dmwit> Alternately alternately: understand the rules.
08:27:01 <jmcarthur> copumpkin: oh i can see why it might be
08:27:01 <copumpkin> jmcarthur: for me it was a little, yep
08:27:14 <klrr> here's the new code http://hpaste.org/85298 , now i get this error "dataTypeParser.hs:67:33: parse error on input `,'" any ideas?
08:27:15 <dmwit> Tabs are "increase to the next multiple of 8", which can be less than eight spaces. Just to be precise.
08:27:15 <copumpkin> jmcarthur: it needs to figure out if the first pattern matches, and that is matching against the second argument
08:27:33 <quchen> merijn: The report defines a tab as "spaces up to the next tabstop". Just to spice things up a little, I assume.
08:27:41 <copumpkin> but it seems to be picking a different order
08:27:43 <dmwit> klrr: stray ']'
08:27:51 <merijn> quchen: Oh, that's even less nice :p
08:28:08 <quchen> merijn: Could be worse (tab stops are Fibonacci apart etc)
08:28:11 <jmcarthur> copumpkin: it looks like it's just left-to-right to me
08:28:16 <copumpkin> jmcarthur: yep
08:28:27 <klrr> dmwit: stray , what does that mean?
08:28:39 <copumpkin> the obvious thing I thought it was doing is "if first arg is False and second arg is False, then False, else True"
08:28:51 <dmwit> klrr: Just stare at the line it's complaining about until you see it.
08:28:59 <copumpkin> which would produce a different result on my test
08:29:02 <dmwit> It's not hard to spot, and it's good practice anyway.
08:29:02 <jmcarthur> copumpkin: oh?
08:29:31 <jmcarthur> > let f a b = if a == False && b == False then False else True in f True undefined
08:29:33 <lambdabot>   True
08:29:37 <dmwit> copumpkin: Well, core has only cases on single expressions that match only the top constructor, right?
08:29:56 <dmwit> eh, ignore me
08:30:26 <copumpkin> jmcarthur: yeah, but then that relies on the laziness of && :)
08:30:26 <dmwit> jmcarthur: force more things
08:30:51 <dmwit> > let f a b = (a == False) `seq` (b == False) `seq` if a == False && b == False then False else True in f True undefined
08:30:52 <lambdabot>   *Exception: Prelude.undefined
08:31:01 <jmcarthur> dmwit: it did what i intended it to do
08:31:13 <dmwit> But not what copumpkin was trying to say he expected.
08:31:19 <Saizan> > let f False !x = False; f _ _ = True in f True undefined
08:31:21 <lambdabot>   True
08:31:28 <dmwit> I agree that copumpkin's expectations are stupid and he should feel stupid. ;-)
08:31:33 <jmcarthur> oh that one is surprising, Saizan
08:31:50 <copumpkin> why is that more surprising?
08:31:59 <dmwit> I'm with copumpkin.
08:32:01 <Saizan> follows the same logic, but yeah
08:32:02 <copumpkin> a pattern match on the outermost is a strictification
08:32:10 <jmcarthur> it means me understanding of bang patterns is wrong
08:32:12 <jmcarthur> *my
08:32:27 <klrr> dmwit: i fixed it
08:33:18 <jmcarthur> i think i always assumed that bang patterns are evaluated before the rest of the pattern
08:33:23 <jmcarthur> silly now that i think about it
08:34:38 <jmcarthur> i guess it's really more like:   let f False x = x `seq` False; f _ _ = True in f True undefined
08:35:06 <jmcarthur> hmm
08:35:29 <jmcarthur> > let f !x False = False; f _ _ = True in f undefined True
08:35:30 <lambdabot>   *Exception: Prelude.undefined
08:35:39 <jmcarthur> alright, now we're on the same page
08:36:14 <yezariaely> when I load a haskell file in haskell-mode (emacs) it calls :cd <dir> before :load src/MyFile.hs
08:36:32 <yezariaely> Can i tell it to change to src directly? because the other modules are not found.
08:36:56 <yezariaely> emacs' buffers directory is src/
08:37:31 <skuggi> Is there a way to do something like provide class instances for type families?
08:38:05 <Saizan> yezariaely: i think it's looking for a .cabal file to identify the dir, but i also tought that behaviour got removed from recent versions of haskell-mode
08:38:13 <skuggi> something like: instance Class a => Class (Fam a) ...
08:38:16 <skuggi> _
08:38:17 <skuggi> ?
08:38:23 <Saizan> skuggi: nope
08:38:32 <skuggi> :/
08:39:05 <Saizan> for the same reason we can only pattern match on constructors, more or less
08:39:41 <skuggi> how so?
08:41:32 <Philippa> the instance dispatch mechanism has to be able to pick an instance (or show there's none) for any given type
08:41:37 <Philippa> that's ultimately about lots of pattern-matching rules
08:42:33 <yezariaely> Saizan: there is a cabal file which should be correct. My haskell-mode version is 2.8.0 which is not the newest.
08:43:11 <Saizan> yezariaely: yeah, it doesn't actually read the .cabal file, it just checks its presence and :cd into that dir
08:43:21 <Saizan> yezariaely: it's not very smart
08:43:27 <yezariaely> hmm, that's ... bad.
08:44:09 <Saizan> you could put a dummy .cabal file into src/ and retry :)
08:44:15 <yezariaely> ah!
08:44:24 <yezariaely> good idea, Saizan!  thanks1
08:44:58 <SaBer> might be a stupid question, but what is the origin of the >>= and <=< symbols?
08:46:25 <geekosaur> I don't know who came up with them, but the idea is supposed to be pushing data through a pipeline
08:48:08 <geekosaur> so you have a flow of data a >>= b >>= c >>= d >>= e
08:49:05 <SaBer> ok
08:51:43 <skuggi> Couldn't you have a mechanism to constrain a type family to only produce types which have a certain class?
08:53:29 <skuggi> like subclassing but for type families?
08:53:45 <adek> Can some of you explain me how actually Control.Concurrent.Timer is working?
08:54:15 <Philippa> skuggi: in theory we could do that, yeah
08:54:23 <ab9rf> skuggi: that made no sense to me, but i don't claim to understand type families and so i hope someone will restate your question or answer it in a way that makes sense so i learn something :)
08:55:26 <Philippa> ab9rf: skuggi's suggesting rules like Foo a => Fam b, so that Fam b must always satisfy Foo a
08:55:36 <Philippa> (which you'd have to declare when declaring Fam!)
08:55:58 <Philippa> we already have that for classes, which were our original attempt at arbitrary constraints :-)
08:56:23 <ab9rf> Philippa: so type classes are to classes what classes are to types?
08:56:32 <dmwit> adek: What package is that in?
08:56:35 <ab9rf> no, that doesn't seem quite right
08:56:55 <adek> dmwit: it is timers
08:56:58 <ab9rf> the page on the haskell wiki is confusing me further
08:57:45 <Philippa> ab9rf: "class" always means "type class" in Haskell these days. We used to distinguish "type classes" and "[type] constructor classes" back when the latter were new
08:57:54 <dmwit> ab9rf: type families are to types what functions are to terms
08:58:07 <ab9rf> dmwit: i misstated, i meant type families when i said type classes
08:58:11 <Philippa> dmwit: that too (more or less), yeah
08:58:13 <quchen> adek: It's a wrapper around using threadDelay.
08:58:22 <Philippa> aside from the bit where type families are open instead of closed
08:58:35 <adek> quchen: So it starts a thread and sets delay and then performs action?
08:58:53 <quchen> adek: Looks like it.
08:59:29 <quchen> adek: oneShotAction action delay = fork (suspend delay >> action)
08:59:42 <quchen> suspend comes from Concurrent.Suspend
08:59:58 <quchen> It's a threadDelay that works on Integer basically
09:00:05 <adek> quchen: if so, am I write that the following usecase is correct: I have a server, it gets requests which has some action and delay, when I receive message I create a new timer, start it and it will do my action when time elapses
09:00:12 <adek> am I right*
09:01:20 <ab9rf> sometimes i get the feeling tht i'm creating giant rube goldberg constructions that happen to generate results when they run, but only because the contraption is inhabited by mice that are smarter than i am and that make everything work out despite the fact that i'm an idiot
09:01:24 <skuggi> Philippa: maybe it wouldn't be all that useful. you can always just have Class (Fam b) => ...
09:01:38 <quchen> I don't understand. My servers get binary data, work with that, and then respond.
09:01:42 <quchen> Why would there be a delay?
09:02:01 <DrChaos> um....I'm trying to write a recursive "raise base to n-th power" function in C, and I'd figure you guys might know how to write it
09:02:08 <adek> quchen: Say you are in lab and after some time you need to add substance X to the mixture
09:02:14 <ab9rf> DrChaos: this is #haskell, not #c
09:02:14 <DrChaos> I'd like to switch to haskell and try writing it in that
09:02:18 <ab9rf> DrChaos: ah
09:02:27 <DrChaos> but erm...I just don't know how to do it
09:02:33 <Philippa> skuggi: there are times one cares, like when you'd 'lose' and have to 'recreate' the ... instance but you've got evidence for Fam b to hand
09:02:37 <DrChaos> if I can't do it in C I probably can't do it in haskell
09:02:40 <ab9rf> :t (^)
09:02:40 <lambdabot> (Integral b, Num a) => a -> b -> a
09:03:02 <quchen> DrChaos: base to the n-th power is successive multiplication.
09:03:02 <ski_> DrChaos : do you know how to write e.g. factorial or fibonacci recursively ?
09:03:14 <skuggi> Philippa: actually, i guess you kinda put class constraint on a type familiy, if you make it an associated type instead, rihgt?
09:03:16 <quchen> adek: I see. In that case yes, that package could be for you.
09:03:25 <adek> quchen: thanks!
09:03:26 <DrChaos> ski_ :: I think I did do that once, but I erased all my Haskell source code
09:03:26 <quchen> adek: Using threadDelay is like a poor man's watch.
09:03:30 <skuggi> s/kinda/kinda can/
09:03:35 <adek> quchen: How poor?
09:03:52 <ski_> DrChaos : perhaps recall/rework those first ?
09:03:55 <ab9rf> i assume threadDelay only guarnatees a minimum bound on the wait?
09:03:57 <Philippa> skuggi: those do that, yeah. Being able to declare Fam after Class is nice, though
09:04:05 <timthelion> ab9rf: ye
09:04:07 <ab9rf> if you ask for 1 second, you'll get at least a second, but you might get a year?
09:04:07 <timthelion> s
09:04:39 <quchen> adek: Not sure. I'm just saying if you need millisecond accuracy it's not the right thing. Suppose your CPU is busy, and the timer fires, i.e. the "threadDelay" stops delaying. If there's lots of other things to do, the scheduler won't work on the suspended thread right away.
09:04:40 <ab9rf> that's the usual contract for timed sleep methods on preemptive multitasking systems
09:04:48 <timthelion> ab9rf: best to use the real time kernel module for real delay times ;)
09:05:03 <geekosaur> hypothetically. in practice, it could be off by up to a second on many OSes and that's before the haskell runtime gets involved
09:05:07 <dmwit> DrChaos: I recommend the Gentle Introduction to Haskell or one of the other tutorials available ta
09:05:10 <dmwit> ?where tutorial
09:05:10 <lambdabot> http://www.haskell.org/tutorial/
09:05:13 <adek> quchen: In my case magnitude would be at least a few seconds
09:05:13 <dmwit> eh
09:05:14 <skuggi> Philippa: that's true
09:05:15 <dmwit> ?where tutorials
09:05:15 <lambdabot> http://haskell.org/haskellwiki/Tutorials
09:05:15 <ab9rf> geekosaur: or much longer if te system is highly loaded
09:05:21 <dmwit> DrChaos: The latter. =P
09:05:27 <quchen> adek: Unless your CPU is heavily loaded you should be fine then.
09:05:31 <geekosaur> (like, sayfreenode last night? :)
09:05:45 <timthelion> dmwit: you sadistic? Why recomend gentle introduction, that one's brutal!
09:05:56 <adek> quchen: Great, thank you for explanatino
09:05:59 <dmwit> It's great. Short and to the point. No fluff.
09:05:59 <ab9rf> especially if the thread gets swapped out while it's asleep and you have to wait for the pager to swap it back in.....
09:06:05 * ski_ thought the gentle introduction was quite nice
09:06:08 <osfameron> dmwit: no gentleness either
09:06:20 <dmwit> I can't stand LYAH (or the Ruby one it's based on) for exactly that reason: too much fluff.
09:06:32 * dmwit high fives ski_
09:06:35 * timthelion loved LYAH
09:06:37 <hpaste> oab pasted “highest” at http://hpaste.org/85302
09:06:39 <monochrom> the gentle introduction is not brutal. but you do have to use it slowly
09:06:48 <timthelion> dmwit: did you read the guys book about haskell music too?
09:06:53 <osfameron> LYAH has very little fluff compared the the terrible self-indulgent ruby crap
09:06:56 <ab9rf> dmwit: i can see why some people like lyah.  i'd like something about half way between the gentle intro and lyah.
09:07:04 <oab> woah cool
09:07:07 <quchen> What's that Ruby tut?
09:07:09 <Adeon> I wonder what kind of introduction a brutal introduction to haskell would be
09:07:12 <oab> didn't realize it would do that
09:07:14 <ski_> @quote gentle.introduction
09:07:14 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
09:07:20 <ab9rf> osfameron: well, ruby is a fad language right now, with a lot of people writing tutorials who barely understand the language themselves.
09:07:44 <quchen> @botsnack
09:07:44 <lambdabot> :)
09:07:44 <osfameron> ab9rf: oh, _why understood Ruby very well indeed
09:07:49 <ab9rf> osfameron: you think that is bad, you should read some of the utter crap that gets published as "php tutorials"
09:07:53 <timthelion> dmwit: actually, if you read the source to the base library, I think it's less brutal than "gentle introductionL
09:08:09 <merijn> ab9rf: Have you seen RWH?
09:08:28 <ab9rf> merijn: i don't remember.  i think it was one of the resurces i used two years ago when i firt tried to lern haskell
09:08:51 <timthelion> ab9rf: I think ruby is out of style after those months averaging >1 zero day per day on rails.
09:09:23 <ski_> DrChaos : the key to writing recursion is to be able to "spot a smaller instances of the same kind of problem you're trying to solve, when solving a larger problem"
09:09:35 <ab9rf> timthelion: my friend the CS prof says that ruby is falling out of favor.  i don't know if i agree with him, but i do see less new ruby stuff on github so i suspect he's likely right
09:09:57 <donri> "zero day" more liek "one a day" amarite
09:10:03 <ab9rf> timthelion: it looks like python is back to being the language du jour of the hackathon crowd
09:10:06 <quchen> ab9rf: Maybe Github counts Ruby as Perl again
09:10:18 <ski_> DrChaos : e.g., to write out a string, first write the first character, then recursively write the rest of the characters (a substring)
09:10:21 <timthelion> quchen: :D
09:10:29 <ab9rf> quchen: there's even less perl though
09:10:34 <monochrom> if I read the source to the base library, I would not be able to guess what those "class Functor m" and "instance Functor Maybe" are about. but I found out by reading the gentle introduction.
09:10:45 <ski_> DrChaos : or, to write out a string backwards, first write the rest of the characters backwards, then write the first character
09:11:03 <ab9rf> perl is only used by old farts to write one-off sysadmin scripts that metastatize over time until they take over the entire server
09:11:09 <monochrom> the gentle introduction is not gentle. it is succint. but it is not brutal.
09:11:31 <oab> should I profile this or assume it is fast
09:11:33 <oab> lol
09:11:33 <ski_> DrChaos : in both cases, "write out all characters in the substring consisting of all but the first characters" is the sub-problem of the same kind as the whole "write out all characters in the string"
09:12:09 <quchen> oab: Never profile. It's the manly thing to do.
09:12:29 <timthelion> ab9rf: perl is mostly used by young chumps trying to look cool with their regex ubfuscations
09:12:36 <ski_> DrChaos : to compute `pow(x,n)' recursively, you need to spot a "smaller instance" of this kind of problem, while solving it (except in some base case, which will stop the recursion)
09:12:38 <dmwit> Maybe I should add "update the Gentle Intro to Haskell 2010" to my list of things to do in my copious free time.
09:12:42 <Philippa> monochrom: it was reasonably gentle for its target audience, I felt
09:12:51 <monochrom> I would also not learn the ~ pattern by reading the source code of base. or the @ pattern. I learned them from the gentle introduction
09:12:56 <Philippa> but yeah, if I had time I'd offer to write the brutal introduction. It'd swear at you a lot, of course
09:13:20 <oab> I just used the @ pattern, wonder if it was good use
09:13:32 <dmwit> Also, I will note that despite the fact that I am now in the Gentle Intro's target audience, I definitely wasn't at the time I read it.
09:13:56 <quchen> I like how people pick specific language features out of production source as examples on the parts where the gentle introduction isn't the worst choice.
09:14:10 <oab> I'm too lazy to benchmark this, but try to beat this http://hpaste.org/85302
09:14:40 <dmwit> oab: You know of http://graphics.stanford.edu/~seander/bithacks.html I guess?
09:15:20 <ski_> s/(W# (high_ w))/W# (high_ w)/
09:15:23 <oab> dmwit: yes I looked at it
09:16:04 <oab> it's probably faster to just lookup the whole word rather than shift and count 4 times
09:17:43 <fryguybob> oab: case ... -> ...; x@_ -> ...  The @ there is not needed.
09:18:45 <oab> really, how do I get the value of the check function in the case?
09:19:07 <fryguybob> x@_ is the same as just x
09:19:24 <neutrino_> hello
09:19:48 <neutrino_> i would like to mention that knowing haskell netted me my latest non-haskell job
09:20:04 <jmcarthur> :D
09:20:11 <quchen> Tell us about it
09:20:14 <quchen> (in #blah?)
09:20:28 <neutrino_> i don't go to channels where people are abusive of each other
09:20:46 <shachaf> And also where you're banned.
09:20:59 <neutrino_> i'm not banned there, leave me alone shachaf
09:21:06 <quchen> Oh. I think I missed that.
09:21:07 <neutrino_> you go around irc telling people i'm banned everywhere
09:21:12 <neutrino_> go pick on someone else
09:21:15 <oab> fryguybob: you mean here ...r3@_->r3 `plusWord#` 16##}... for example?
09:21:39 * timthelion wonders how to find out if/where neutrino_ is really banned.
09:21:43 <neutrino_> in fact, i was expressly invited there some time ago but refused to go
09:22:00 <quchen> Well this got childish fast. Nevermind, keep your story.
09:22:09 <timthelion> neutrino_: Go read about data paralel haskell, it will calm your nerves.
09:22:28 <neutrino_> timthelion: obviously not banned from shachaf's bizzarre imagination
09:22:35 <fryguybob> oab: Yeah that is the same as  r3 -> r3 ...
09:22:48 <jmcarthur> how about we be on topic?
09:22:52 <neutrino_> ok
09:23:28 <jmcarthur> neutrino_: congrats on your job, and i'm glad to hear haskell helped
09:23:49 <oab> ah yes, I didn't realize that would match anything else
09:23:52 <oab> as well
09:24:04 <oab> hmm, I wonder why
09:24:38 <neutrino_> so the interview is going ok, and the guy says let's have a practical test, let's see you write fizzbuzz. i kind of laugh out, go up to the flipchart, so he tries to "up the stakes" and asks me to implement quicksort instead, and write tests for it
09:24:54 <neutrino_> and i'm like, "can i implement it recursively? <trollface.jpg>"
09:25:14 <osfameron> how would you do it nonrecursively?
09:25:27 <ski_> presumably by simulating a stack ..
09:25:40 <neutrino_> well, recursion is not supported in the language i'd be working with
09:25:43 <jmcarthur> osfameron: by using something like C and a for loop?
09:25:46 <Philippa> the tail-recursive version is worth hanging on to
09:25:54 <jmcarthur> neutrino_: not *supported*?
09:25:58 <ab9rf> monochrom: i am right now forgetting what the ~ pattern is.  and it took me ages to understand @ patterns
09:26:02 <neutrino_> yes, you get stack overflows
09:26:02 <hpc> neutrino_: run away screaming
09:26:10 <Philippa> ski_: if you're willing to, your stack doesn't have to be very stack-like either
09:26:10 <ski_> ab9rf : lazy pattern
09:26:15 <ab9rf> monochrom: ~ is "fail late"?
09:26:16 <jmcarthur> neutrino_: oh you just mean it doesn't optimize tail calls
09:26:16 <neutrino_> so afterwards i taught him how to use quickcheck
09:26:18 <osfameron> ah
09:26:23 <ab9rf> ski_: oh, right.  i remember now.
09:26:26 <ski_> Philippa : anything particular in mind ?
09:26:48 <Philippa> ski_: find a way to encode paths through the stack-over-time tree for a given array size into an int
09:26:57 <ab9rf> ski_: i can't recall having used that in any of my own code, but that's probably just because i'm not terribly good yet :)
09:26:58 <neutrino_> jmcarthur: yeah, calling that recursion is like calling python functional
09:27:12 <ski_> neutrino_ : stack overflows for a single recursive call ?
09:27:24 <jmcarthur> neutrino_: you can still write many recursive algorithms just fine
09:27:31 <jmcarthur> neutrino_: anything with a bounded depth
09:27:38 <jmcarthur> (well, with reasonable bounds)
09:28:07 <ab9rf> Dartmouth BASIC doesn't support recursion :)
09:28:15 <ski_> jmcarthur : well, you can have it not optimize tail calls, but still provide a stack which doesn't overflow ..
09:28:17 * timthelion remembers that the reason he origionally joined this channel was to ask about using quickcheck inline(not in ghci)
09:28:34 <jmcarthur> ski_: well, yeah, but how many languages would have the latter and not the former anyway?
09:29:11 <Philippa> jmcarthur: given that Scheme's the only FPL I can think of off-hand that mandates TCO?...
09:29:12 <ab9rf> i remember writing nonrecursive versions of quicksort, using an explicit stack
09:29:22 <ab9rf> that was ages ago
09:29:24 <jmcarthur> Philippa: i meant language implementation
09:29:31 <neutrino_> timthelion: i use test-framework for that iirc
09:29:36 <DrChaos> Are there haskell bindings to Qt 5?
09:29:43 <ski_> Philippa : hm, i assume you mean a single int rather than say an array of them -- interesting
09:29:51 <DrChaos> or do I just get really good at programming and Haskell and write them myself?
09:29:52 <neutrino_> it's been a few months since i'd last used quickcheck
09:29:59 <ab9rf> in place sort involving flopping elements of the array around and keeping track of the various partitions in an explicit stack
09:30:02 <DrChaos> surely somebody had done something with qt 4?
09:30:10 <Philippa> jmcarthur: yeah, but that means you're going to get the occasional implementation that's got a functioning GC, chains its activation records fine on the heap and doesn't TCO
09:30:13 <neutrino_> DrChaos: i believe there's some qt stuff. why not check hackage?
09:30:18 <Philippa> (or at least doesn't TCO /yet/)
09:30:25 <neutrino_> DrChaos: you can always use c2hs, it's very simple to use.
09:30:37 <Philippa> admittedly TCO is a shitload easier once  you know CPS and/or ANF!
09:30:53 <ab9rf> DrChaos: http://hackage.haskell.org/trac/summer-of-code/ticket/1116
09:30:57 <neutrino_> jmcarthur: also, btw, thanks
09:31:01 <DrChaos> see, I want Qt 5 support because there's this Qt Platform Abstraction (QPA) thing/plugin for Qt 5 that allows you to run a Qt 5 program under something that is NOT Xorg on Linux very easily
09:31:08 <ski_> jmcarthur : hm, possibly CL ?
09:31:09 <ab9rf> DrChaos: that was a summer-of-code project four yers ago, you should see if anything came of it
09:31:10 * ski_ isn't sure
09:31:13 <DrChaos> you just do ./qt5app -platform wayland-egl
09:31:22 <ab9rf> DrChaos: sorry, six years ago
09:31:35 <DrChaos> ab9rf :: ok
09:31:41 <neutrino_> jmcarthur: it's not 100% there yet, i've been presented with a contract and it's got like 36 hidden clauses that let them terminate me immediately, and 14 excuses not to pay me at all, and several large liabilities
09:31:47 <ab9rf> DrChaos: http://sourceforge.net/projects/qthaskell
09:31:49 <neutrino_> so i'm gonna talk about that on monday
09:31:53 <jmcarthur> neutrino_: yuck
09:31:54 <ab9rf> DrChaos: although that appers to be dead
09:32:03 <neutrino_> jmcarthur: can't blame them for trying!
09:32:09 <ab9rf> DrChaos: also http://www.haskell.org/haskellwiki/HQK
09:32:10 <jmcarthur> sure you can
09:32:16 <ski_> Philippa : actually Scheme doesn't mandate TCO (and some (conforming) implementations doesn't do it) -- it mandates "proper tail recursion", though :)
09:32:24 <Philippa> hah
09:32:26 <neutrino_> if i were in their position i'd try the same thing :D
09:32:31 <neutrino_> btw, does scala do TCO?
09:32:35 <ab9rf> DrChaos: HQK appears to be incomplete
09:32:46 <neutrino_> they use scala for some stuff there
09:32:59 <neutrino_> i heard it's pretty nasty though and not really amazing as a functional lang
09:33:07 <DrChaos> ab9rf :: *sniff* *sniff*
09:33:19 <ski_> Philippa : i.e. Chicken just keeps adding to the C stack (by transforming into CPS), never returning, until it's full, at which point it GCs the stack and continues
09:33:23 <neutrino_> does it even have type inference?
09:33:53 <neutrino_> ski_: i heard of that approach, sounds like fun
09:33:54 <DrChaos> is there a GTK+3 binding out yet? last time I checked there wasn't (it's in progress afaik)
09:34:01 <Philippa> ski_: yeah, Scheme's really talking about space rather than time behaviour
09:34:09 <neutrino_> DrChaos: gtk 3 is fairly new altogether..
09:34:16 <timthelion> DrChaos: there are patches for gtk2hs but it's not in hackage.
09:34:17 <neutrino_> DrChaos: worst case scenario, use the python binding?
09:34:19 <Philippa> for slightly wobbly but nevertheless sensible values of 'space behaviour' of course
09:34:24 <ski_> Philippa : and MIT-Scheme keeps the last 100 stack frames or so around for debugging purposes -- the point is that the space usage of unboundedly many tail calls is still bounded :)
09:34:37 * ski_ nods
09:34:38 <DrChaos> timthelion :: yes but are they complete patches?
09:34:41 <ludamad> Anyone have an example of reading the request body using Warp ? I can't for the life of me figure out how to work with conduits
09:34:51 <timthelion> DrChaos: Cairo canvas draw support is still incomplete, but the rest should work.
09:35:04 <DrChaos> timthelion :: NICE
09:35:35 <timthelion> DrChaos: They were made by the guy that does leksah, current leksah build page should have them.
09:35:41 <jmcarthur> neutrino_: scala has type inference, but in the presence of all its other language features it's hard to get right, so you end up annotating a lot of code anyway
09:36:06 <tootooroo> What exactly does (***) do when applied to two Kleisli IOs?
09:36:27 <hpaste> mbuf pasted “close failed in file object destructor” at http://hpaste.org/85303
09:36:41 <neutrino_> jmcarthur: :(
09:36:50 <mbuf> the above works inside ghci, but, fails with the mentioned error when run through CLI
09:37:03 <donri> tootooroo: what you'd expect ;)
09:37:16 <jmcarthur> tootooroo: it would have type   Kleisli IO a c -> Kleisli IO b d -> Kleisli IO (a,b) (c,d)
09:37:25 <tootooroo> donri: I would expect the two original Kleisli IOs to be run, but I have no idea in what order.
09:37:38 <tootooroo> jmcarthur: I know that far.
09:37:56 <jmcarthur> it *probably* does the left one first, but i would check the code
09:38:29 <quchen> f *** g = first f >>> second g
09:38:47 <tootooroo> jmcarthur: The type information alone does not reveal anything about execution order, alas. Actually, I could expect two separate threads to be launched and run concurrently.
09:39:11 <jmcarthur> tootooroo: yeah, so just look at the Arrow instance for Kleisli
09:39:18 <jmcarthur> tootooroo: you can't expect that at all
09:39:23 <geekosaur> mbuf, that error is from python and probably means your haskell program exited before it did. you should probably wait for it to actually finish before exiting.
09:39:27 <monoidal> tootooroo: you shouldn't expect that; think about Kleisli m for some general monad m
09:39:28 <tootooroo> jmcarthur: Why not?
09:39:33 <jmcarthur> tootooroo: the implementation has to be parameterized over the monad, and not all monads can spawn threads
09:39:38 <ski_> (btw, "proper tail recursion" is perhaps somewhat of a misnomer, since it's a property about all tail calls, not just ones which happen to participate in recursion)
09:39:44 <mbuf> geekosaur: yes, koji tool is a Python script
09:39:49 <geekosaur> hm, except readProcess hsould not be lazy...
09:39:53 <donri> >>> runKleisli (Kleisli putStrLn *** Kleisli putStrLn) ("a","b")
09:39:54 <donri> a
09:39:54 <donri> b
09:39:54 <donri> ((),())
09:40:07 <tootooroo> jmcarthur: Oh.
09:40:16 <tootooroo> monoidal: Right.
09:40:33 <mbuf> geekosaur: are there any examples I can refer on how to wait from an invocation to forkIO?
09:40:42 <jmcarthur> tootooroo: the laws probably don't allow it to run either of the more than once, but i'm not sure
09:41:00 <jmcarthur> tootooroo: i suspect that the only viable implementations are do A then B or do B then A
09:41:24 <jmcarthur> tootooroo: and even that choice might be mandated by the laws, depending on how other Arrow stuff is implemented in that instance
09:41:30 <monoidal> tootooroo: I think it is, in principle, possible that only Arrow (Kleisli IO) was defined, by concurrent spawning, but that would mean there would be no polymorphic Arrow (Kleisli m)
09:41:45 <geekosaur> mbuf, you may want to use the async package instead of forkIO directly; the easiest way to wait on a forkIO-d thread is to have it write to an MVar or Chan on completion and block on that
09:41:47 <DrChaos> timthelion :: NICE
09:42:09 <DrChaos> killall dcompmgr
09:42:16 <mbuf> geekosaur: I see
09:42:18 <jmcarthur> DrChaos: issues?
09:42:21 <ski_> jmcarthur : i suspect interleavings would be ok
09:42:54 <ski_> .. i.e. if we didn't expect `f *** g = first f >>> second g' to be a law as well (do we ?)
09:43:18 <DrChaos> jmcarthur :: yes, dcompmgr --gl (Use opengl for drawing) causes all the windows to flash white and blink rapidly...the console says something about there being no GL visual for depth 32
09:43:29 <DrChaos> so much for that
09:44:02 <jmcarthur> ski_: i'm not seeing that law anywhere in the docs, at least
09:44:06 <donri> ski_: does that definition even matter, with no strictness?
09:44:14 <jmcarthur> donri: it matter with effects
09:44:21 <jmcarthur> donri: e.g. Kleisli IO
09:44:26 <jmcarthur> *matters
09:44:39 <ski_> donri : hm ?
09:44:54 <jmcarthur> donri: where by "matter" i mean "has multiple distinguishable implementations"
09:44:59 <donri> i guess what matters here is the Category.. of Kleisli
09:46:27 <donri> that's where the order of *** ends up defined
09:46:37 <ski_> > (`runKleisli` (0,0)) $ Kleisli (\n -> [n,n+1]) *** Kleisli (\n -> [n,n+2])
09:46:38 <ski_> > (`runKleisli` (0,0)) $ Kleisli (\n -> [n,n+2]) *** Kleisli (\n -> [n,n+1])
09:46:38 <lambdabot>   [(0,0),(0,2),(1,0),(1,2)]
09:46:39 <donri> (Kleisli f) . (Kleisli g) = Kleisli (\b -> g b >>= f)
09:46:40 <lambdabot>   [(0,0),(0,1),(2,0),(2,1)]
09:47:00 <donri> so f.g runs g first, and >>>=flip(.)
09:47:43 <jmcarthur> the order of (***) is defined in Arrow...
09:47:55 <monoidal> donri: (.) has no other choice, though. (***) does
09:48:09 <donri> jmcarthur: well, for the default implementation, which uses (>>>), which is (.) flipped
09:48:28 <jmcarthur> donri: i don't see the relevance
09:48:34 <monoidal> donri: the default could be first f >>> second g or second g >>> first f
09:48:45 <donri> my point is that i don't think (***) (or (.)) has a defined order independent of any one instance
09:48:59 <jmcarthur> donri: the point is that the laws don't specify what the default implementation or an overridden implementation should do as far as ordering goes
09:49:12 <jmcarthur> donri: (.) doesn't have a choice about ordering
09:49:18 <DrChaos> jmcarthur :: ok, don't ever try dcompmgr unless you are willing to hack on it or it gets fixed in the future
09:49:32 <donri> and for Kleisli, what ends up determining the sequencing order of the effects is its definition of (.)
09:49:39 <jmcarthur> donri: wha-?
09:49:40 <DrChaos> OpenGL drawing is broken on Intel hardware
09:49:54 <simpson> Strong words.
09:49:57 <jmcarthur> DrChaos: this isn't relevant here and is interrupting an on-topic conversation
09:49:58 <simpson> (Patches welcome!)
09:50:05 <ski_> donri : no, it's the definition of `(***)' which could have a real choice affecting the sequencing order
09:50:07 <jmcarthur> DrChaos: (not trying to be rude)
09:50:13 <donri> jmcarthur: (.) certainly has a choice about how it defines composition of a kleisli arrow
09:50:28 <jmcarthur> donri: the laws are quite restrictive about what (.) is allowed to do
09:50:35 <monoidal> donri: no, there is only one way to compose a -> m b and b -> m c
09:50:44 <monoidal> donri: you have to run effects of the first function first
09:50:46 <donri> (Kleisli f) . (Kleisli g) = Kleisli (\b -> g b >>= f)  -- that lambda is the key
09:51:07 <jmcarthur> donri: so what's the other way?
09:51:12 <ski_> (in the presence of `MonadFix', the issue would be different)
09:52:36 <donri> i don't know if there's a different definition possible. that's not the point. :) the point is someone was wondering where to look to figure out the sequencing ordering of Kleisli's ***, and (.) is the key
09:52:41 <LambdaDusk> just in case anyone cares: compiling GHC 7.6.2 on the raspberry pi fails after 7 hours, unrecoverable, it seems
09:52:50 <jmcarthur> donri: that *is* the point
09:53:02 <jmcarthur> donri: there is no other definition of (.) possible, but there *are* other definitions of (***) possible
09:53:19 <jmcarthur> donri: and i still don't see what (.) has to do with it
09:53:24 <donri> ok, i see your point
09:54:17 <jmcarthur> donri: in fact, *any* arrow has at least two implementations of (***)
09:54:51 <jmcarthur> donri: f *** g = first f . second g   or   f *** g = second g . first f
09:55:21 <DrChaos> LambdaDusk :: does it need more RAM?
09:55:22 <jmcarthur> donri: there might be no observable difference for some arrows though
09:55:47 <quchen> LambdaDusk: NOOOOOO - but thanks for telling us :-|
09:56:06 <quchen> LambdaDusk: What's the error?
09:57:28 <LambdaDusk> DrChaos, quchen: Something with OpenBinaryFile... it tries to open a file in /tmp/ that does not exist
09:57:50 <monoidal> LambdaDusk: http://www.haskell.org/pipermail/glasgow-haskell-users/2013-January/023367.html ?
09:57:52 <LambdaDusk> RAM is actually no trouble at all, the ghc processes never went over 200 MB consumption
09:58:10 <LambdaDusk> oh yes
09:58:54 <LambdaDusk> exactly that error
09:59:16 <LambdaDusk> doesn't tell me how to upgrade llvm
09:59:52 <quchen> And once you've done that in only 7 more hours you'll know whether it was successful.
10:00:20 <LambdaDusk> GHC uses "llc" and that comes from the llvm package which will always serve llvm 3.0
10:00:45 <LambdaDusk> nah it wont because it's early at stage 2 and the others are done
10:01:06 <amiller> question about the 'finally tagless' approach
10:01:07 <amiller> http://okmij.org/ftp/tagless-final/index.html#call-by-any
10:01:23 <amiller> in this oleg compares to the initial encoding using gadts, which resembles what i've done previously
10:01:36 <amiller> and to put it in agda or coq with the initial encoding i had to use PHOAS to avoid negative position terms
10:01:43 <amiller> is that necessary in the final encoding?
10:01:53 <amiller> in other words
10:01:55 <amiller> class EDSL exp where
10:01:56 <amiller>           lam :: (exp a -> exp b) -> exp (a :-> b)
10:02:31 <amiller> should i use PHOAS by introducing some other thing like EDSL h exp where      lam :: (h a -> exp b) -> (exp a :-> b)
10:02:56 <quchen> LambdaDusk: Do you know how Debian's 7.4.1 was built?
10:03:40 <LambdaDusk> quchen: No idea...
10:04:13 <amiller> i think that the answer is that negativity doesn't matter because it is already parametric in 'exp'
10:04:41 <amiller> the negativity arises in the 'initial' case because you can pattern match on a term but that isn't possible with the parametric exp
10:08:55 <klrr> haskell compiler suggested that the problem was a typo, it was :D
10:09:01 <klrr> HASKELL ROCKS MOTHA¤"*"*!
10:09:41 <monochrom> actually, it is just one compiler giving that suggestion
10:10:13 <klrr> yeah, well
10:10:21 <monochrom> soon, you will find that the same suggestion is completely off the mark
10:11:06 <klrr> no it's not it was right suggestion
10:11:13 <klrr> GHC ROCKS MOTHA¤"¤"!¤!
10:11:17 <__xc> > zipWith (/=) [True,False,True,False] [True,False,False,True]
10:11:19 <lambdabot>   [False,False,True,True]
10:11:35 <monochrom> I mean in the future for another problem
10:11:39 <__xc> xor
10:12:28 <monoidal> trivia: it might be better to define xor = (/=) :: Bool -> Bool -> Bool. why?
10:12:59 <kartoffelbrei> klrr: I find the suggestions pretty annoying most of the time. Especially the "Possible fix: ad an instance blabla..."
10:13:12 <monoidal> kartoffelbrei: this one is removed in 7.6 or head (I don't remember)
10:13:35 <monoidal> in head
10:13:58 <monochrom> IMO, it is not better to define xor. it is better to use /= directly
10:13:59 <kartoffelbrei> monoidal: it's head. my 7.6.2 still says that.
10:14:02 <merijn> @quote instead.of.eta
10:14:02 <lambdabot> lispy says: jkramer> I think since the last update, hlint suggests weird/wrong things <lispy> jkramer: like, "Instead of eta reduction, try a Factory pattern." ?
10:14:11 <kartoffelbrei> but i'm glad they removed it.
10:14:59 <monochrom> other people will disagree. their reason boils down to: they really want the name xor, not negotiable.
10:15:33 <monochrom> I respect that, but I really want the name /=, not negotiable. I agree to disagree.
10:15:38 <monoidal> monochrom: there's another reason, not a name, for having xor = (/=) specifically for booleans
10:15:40 <LambdaDusk> all right, updated to llvm 3.1
10:16:16 <jmcarthur> the nice thing about xor is the type
10:16:18 <jmcarthur> :t xor
10:16:20 <lambdabot> Bits a => a -> a -> a
10:16:37 <jmcarthur> not restricted to Bool
10:16:41 <monoidal> oh, yes
10:16:50 <monochrom> you are probably saying, it is the same reason about map vs fmap, length vs genericLength
10:16:52 <merijn> > xor True False
10:16:53 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Bool)
10:16:53 <lambdabot>    arising from a use of `D...
10:16:57 <merijn> awww
10:17:03 <klrr> what does lookup? (i didnt get hoogles explaination)
10:17:04 <Boreeas> > xor 1 1
10:17:05 <lambdabot>   0
10:17:07 <monoidal> monochrom: my reason is bit different
10:17:10 <monochrom> I respect that, but again I agree to disagree, not negotiable
10:17:12 <merijn> Why isn't Bool an instance of Bits? :>
10:17:22 <Boreeas> :t Bits
10:17:24 <lambdabot> Not in scope: data constructor `Bits'
10:17:25 <monoidal> spoiler warning
10:17:45 <monochrom> I can't think of any other reason
10:17:48 <LambdaDusk> :i Bits
10:17:55 <kartoffelbrei> :t lookup
10:17:57 <merijn> Boreeas: Bits is a typeclass, not a value
10:17:57 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:17:57 <klrr> merijn: are you the xonotic dev?
10:17:57 <geekosaur> no :i in lambdabot
10:17:58 <monoidal> monochrom: you can write True `xor` False `xor` True, but not True /= False /= True
10:18:03 <merijn> klrr: Nope
10:18:05 <jmcarthur> for example, that zipWith (/=) example could also be a part of this instance:   instance Bits a => Bits (ZipList a)
10:18:16 <LambdaDusk> quchen: Compiling on...
10:18:18 <jmcarthur> (i think... need to look at what methods it requires to be sure)
10:18:19 <klrr> merijn: okey, there's a xonotic lead developer with same nick :P
10:18:20 <merijn> At least, I think not? Considering I've never heard of xonotic
10:18:31 <klrr> http://www.xonotic.org/
10:18:35 <__xc> > xor 3 2
10:18:36 <lambdabot>   1
10:18:42 <klrr> open source pro arena shooter game
10:18:52 <klrr> well, what does lookup, how does it work?
10:18:54 <klrr> ?src lookup
10:18:54 <lambdabot> lookup _key []          =  Nothing
10:18:55 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
10:18:55 <lambdabot>                         | otherwise = lookup key xys
10:19:10 <monochrom> I see, but I have long stopped caring about saving parentheses
10:19:20 <merijn> klrr: I'm not surprised. It's not a common name, so it's usually still available as nick, but at the same time it's common enough that there's several tens or hundreds of us active in hacking circles
10:19:27 <jmcarthur> eh, that instance isn't doable
10:19:40 <jmcarthur> testBit, in particular, makes things tough
10:19:50 <monoidal> monochrom: in this case, I don't see any other reasons :) I do like seeing associativity in code, but that's just a preference
10:19:52 <merijn> klrr: It matches values with the first entry in a tuple and returns the second entry in the tuple
10:20:07 <jmcarthur> it's also unfortunate the bitSize is documented as not inspecting its argument
10:20:08 <merijn> > lookup 1 [(2,'a'),(3,'b')]
10:20:10 <lambdabot>   Nothing
10:20:13 <merijn> > lookup 2 [(2,'a'),(3,'b')]
10:20:15 <lambdabot>   Just 'a'
10:20:23 <monoidal> monochrom: I would be very concerned if I had to write (2+3)+4, for example.
10:20:26 <jmcarthur> oh, it says it's undefined for types not supported it without inspection...
10:20:36 <jmcarthur> not sure how i feel about that, but i guess it means it's not a problem here
10:20:52 <klrr> i actually wrote a real world program today :D
10:20:55 <klrr> https://github.com/CodetalkDev/food/blob/master/recipes/pancake-mix.md
10:21:06 <klrr> in natural language, the pan is the compiler
10:21:18 <jmcarthur> i'm hungry
10:21:22 <klrr> jmcarthur: Mix the wheat flour with the half of the milk.
10:21:23 <klrr> 02: Add the rest of the milk, the eggs and the salt.
10:21:23 <klrr> 03: Steak the butter and add it into the mix.
10:21:26 <klrr> 04: Bake thin pancashit
10:21:27 <klrr> shit
10:21:31 <__xc> @where wor
10:21:31 <lambdabot> I know nothing about wor.
10:21:32 <klrr> sry, dont ban me
10:21:36 <__xc> @where xor
10:21:36 <lambdabot> I know nothing about xor.
10:21:42 <klrr> fucking x11, having mouse middle click as paste xD
10:21:43 <monochrom> I would do: (/=) = (Prelude./=); infixl whatever (/=)
10:22:06 <quchen> Würde mich heute spontan besamen lassen. Wenn du aus NRW bist, ein Auto hast mit dem du in die Provinz fahren kannst und ein unerfahrener Echtbernd bist, melde dich einfach :3
10:22:14 <quchen> Yeah thanks klrr
10:22:25 <quchen> Should've known better ;-(
10:22:26 <Philippa> klrr: my gf linked to someone's Hello World cake last night
10:22:34 <quchen> Sorry everyone :x
10:22:54 <__xc> who defined lambdabot's xor?
10:22:57 <quchen> Careful what you mark to send your friends on the internet 8)
10:23:10 <monochrom> Data.Bits defined lambdabot's xor
10:23:13 <LambdaDusk> quchen: Wem würdest du sowas senden?
10:23:36 <ab9rf> i feel lost
10:23:45 <quchen> LambdaDusk: It's from Krautchan. Don't even ask.
10:23:57 <merijn> quchen: Suuuuuure it is...
10:24:01 <jmcarthur> yeah i completely take back my ZipList instance for Bits idea. it doesn't even make sense if it's a list of variable sized values
10:24:05 <LambdaDusk> quchen: Yeah sure is
10:24:09 <monoidal> monochrom: ah yes, that's another solution. In fact believe infixl is the default
10:24:16 <jmcarthur> or infinite-sized ones
10:24:31 <monochrom> recipes on github. perhaps next time I will post source code on www.allrecipes.ca
10:25:18 <merijn> monochrom: But then how would you fork them?!
10:25:18 <ab9rf> monochrom: considering the quality of recipes on allrecipies, i don't think anyone could reasonably object.
10:25:24 <klrr> what's the diff between div and / ?
10:25:31 <merijn> :t div
10:25:31 <ab9rf> :t div
10:25:32 <lambdabot> Integral a => a -> a -> a
10:25:33 <lambdabot> Integral a => a -> a -> a
10:25:33 <int-e> monochrom: do you know the passage from the foreword to TAoCP where Knuth admits he has barely resisted the temptation to call the series "The Programmer's cookbook"?
10:25:33 <ab9rf> :t (/)
10:25:34 <merijn> :t (/)
10:25:34 <lambdabot> Fractional a => a -> a -> a
10:25:36 <lambdabot> Fractional a => a -> a -> a
10:25:38 <ab9rf> that's the difference
10:25:44 <merijn> klrr: Take a look at the types :)
10:25:45 <ski_> @quote stereo
10:25:45 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
10:25:51 <ski_> bah
10:26:02 <ab9rf> that was pretty synchronous, wasn't it? :)
10:26:11 <merijn> :p
10:26:20 <geekosaur> @quote majestic.stereo
10:26:20 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
10:26:21 <int-e> monochrom: he then goes on saying that he might still write a book "algorithms for the kitchen" some day. :-)
10:26:22 <monochrom> merijn: apparently, people have been forking recipes for a thousand years without github help
10:26:23 <ab9rf> ski_: now i have to go find out what a BanachTyvski is
10:26:32 * geekosaur *eyeroll*
10:26:34 <merijn> monochrom: But how would you contribute patches?!
10:26:46 <ab9rf> merijn: with FTP: Food Transport Protocol
10:26:50 <int-e> merijn: "here, taste this!"
10:26:52 <merijn> int-e: Tanenbaum has a cookbook called "preparing your input" :)
10:26:53 <klrr> merijn: thanks, so div is for ints, / is for floats?
10:27:00 <LambdaDusk> waaaaaaah my pi doesn't compile haskell anyway
10:27:04 <int-e> merijn: "tastes good, how did you make it?"
10:27:04 <ab9rf> klrr: no, div is for ints, / is for fractionals
10:27:09 <monochrom> to contribute patches, send me email
10:27:15 <ab9rf> well, div is for integrals :)
10:27:24 <ski_> monochrom : why `infixl' ?
10:27:46 <merijn> > (4 / 5, 4 `div` 5)
10:27:47 <ab9rf> LambdaDusk: haskell is a bit heavy for the pi, it'll usually compile but the linker strains the capability of the device
10:27:47 <lambdabot>   (0.8,0)
10:27:48 <monochrom> infixl because I tossed a coin and it was head
10:27:56 * ski_ integrates ab9rf over a compact domain
10:28:05 <ski_> i see. makes sense
10:28:23 <LambdaDusk> ab9rf: it was doing so well, my little pi...
10:28:36 <ski_> @dice 1d2
10:28:37 <lambdabot> 1d2 => 2
10:28:49 <Philippa> ab9rf: I bet having the 512MB variant helps - I got loaned one of the earlier ones
10:28:53 <ab9rf> LambdaDusk: we really need a cross-compilatio environment...
10:28:58 <merijn> klrr: Well, I'm not sure which types are Fractional, but it is different from floats (which would be Floating), but other than that, close enough
10:29:13 <ab9rf> Philippa: the 512MB variant can usually chug through although it takes a while.  the 256MB variant has no real chance.
10:29:19 <Philippa> *nod*
10:29:27 <Philippa> (2GB on this chromebook is obviously spoiling me)
10:29:34 <Philippa> (and yet, I want 4)
10:29:38 <ab9rf> i search google for BanachTyvski and i get some crap abut a volleyball coach
10:29:56 <LambdaDusk> i have the model B
10:30:04 <ab9rf> ha!  all of the hits for BanachTyvski are just that quote above!
10:30:05 <LambdaDusk> however, the trouble here is another error
10:30:09 <merijn> ab9rf: I think it should be Banach Tarski
10:30:13 <ski_> preflex: xseen geheimdienst
10:30:13 <preflex>  geheimdienst was last seen on freenode/#haskell 1 year, 94 days, 13 hours, 40 minutes and 28 seconds ago, saying: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Naive_definition
10:30:16 <monochrom> search for Banach Tarski instead. I don't know what's with Tyvski
10:30:19 <ab9rf> there's eight hits and all of them are just replicants of that same IRC quote
10:30:26 <merijn> ab9rf: Tyvski doesn't sound familiar
10:30:33 <monochrom> in fact, there is an xkcd for that too
10:30:33 <ab9rf> monochrom: Banach-Tarski i've at least heard of.
10:31:00 <monochrom> http://xkcd.com/804/
10:31:47 <ab9rf> at least, both Banach and Tarski are names i recognize and i have soe sense of banach spaces and that.  i don't know specifically waht it's in reference too, but i don't relly care anymore :)
10:31:55 <monochrom> someone also said just yesterday: when confronted with a problem, some people say, "I know, I'll use Banach Tarski". now they have two problems...
10:31:56 <__xc> :t (%)
10:31:57 <lambdabot>     Not in scope: `%'
10:31:57 <lambdabot>     Perhaps you meant `R.%' (imported from Data.Ratio)
10:31:57 <ab9rf> BanachTyvski appears to be sui generis nonsense at this point
10:32:21 <__xc> > 2% 3 --guess it'd exist
10:32:23 <lambdabot>   Not in scope: `%'
10:32:23 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
10:32:34 <__xc> > 2 R.% 3 --guess it'd exist
10:32:36 <lambdabot>   2 % 3
10:32:48 <ab9rf> heh, (2%) should take 2 precent of its argument :)
10:33:01 <Taneb> > 412 R.% 18
10:33:01 <__xc> > 2 R.% 3 + 1 R.% 3
10:33:02 <ab9rf> (2%) milk
10:33:02 <lambdabot>   206 % 9
10:33:02 <lambdabot>   can't find file: L.hs
10:33:19 <__xc> > (2 R.% 3) + (1 R.% 3)
10:33:21 <lambdabot>   1 % 1
10:33:24 <monochrom> Banach spaces and Tarski theorem for fixed points are both unrelated to Banach-Tarski
10:33:53 <merijn> monochrom: Ha! I like that one
10:34:05 <ab9rf> monochrom: well they're related, but the relationship is not really conceptual :)
10:34:05 <__xc> :t (R.%)
10:34:07 <lambdabot> Integral a => a -> a -> Ratio a
10:35:35 <__xc> > (10 R.% 5) :: (Ratio Int)
10:35:36 <lambdabot>   2 % 1
10:41:49 <__xc> > ((Just 10) R.% (Just 5)) :: (Ratio (Maybe Int))
10:41:51 <lambdabot>   No instance for (GHC.Real.Integral
10:41:51 <lambdabot>                     (Data.Maybe.Maybe GH...
10:42:52 <__xc> > Just (10 R.% 5) :: (Maybe (Ratio Int))
10:42:53 <lambdabot>   Just (2 % 1)
10:53:13 <Sct> [NTCTC001|10s+x7#lu1mbswtduoh56%u82965g!tcxp]
10:53:33 <geekosaur> ...
10:54:58 <ab9rf> Sct: gesundheit
10:55:18 <shachaf> !list
10:55:18 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
10:58:18 <int-e> http://www.rigsofrods.com/threads/42864-Solved-IRC-BAN-Please-Explain :-)
11:00:48 <ab9rf> heh
11:02:53 <ab9rf> does anybody know how those payloads are actually formatted?
11:04:18 <sw17ch> Is there an `allEq` function for lists such that `True == allEq [1,1,1]` and `False == allEq [1,2,1]`?
11:04:28 <sw17ch> or do i just stick with my quick implementation
11:04:41 <monoidal> sw17ch: I don't think there's one in standard libraries
11:04:55 <sw17ch> Hoogle yielded nothing, so I decided to try here.
11:05:04 <geekosaur> :t all (==)
11:05:06 <lambdabot>     Couldn't match expected type `Bool' with actual type `a0 -> Bool'
11:05:06 <lambdabot>     Expected type: a0 -> Bool
11:05:06 <lambdabot>       Actual type: a0 -> a0 -> Bool
11:05:10 <geekosaur> whoops
11:05:19 <jmcarthur> :t all
11:05:21 <lambdabot> (a -> Bool) -> [a] -> Bool
11:05:22 <monoidal> sw17ch: f [] = True; f x = init x == tail x is one option
11:05:26 <jmcarthur> :t all id
11:05:27 <mapf>  some sort of fold
11:05:27 <lambdabot> [Bool] -> Bool
11:05:28 <geekosaur> ab9rf, http://www.ntalk.de/Nettalkdoku/doku.php?id=nettalk:functionality
11:05:33 <jmcarthur> oh i misunderstood
11:05:38 <monoidal> sw17ch: or, f (x:xs) = all (==x) xs
11:05:39 <jmcarthur> :t foldl (==) True
11:05:40 <lambdabot> [Bool] -> Bool
11:05:48 <jmcarthur> oh that's wrong too
11:05:49 <jmcarthur> bah
11:05:50 <geekosaur> yeh, I was misthinking
11:06:08 <jmcarthur> we fail
11:06:54 <jmcarthur> :t null . drop 1 . group
11:06:55 <lambdabot> Eq a => [a] -> Bool
11:08:08 <simpson> > let allEq (x:y:[]) = x == y; allEq (x:xs@(y:ys)) = x == y && allEq xs in allEq [1,1,1]
11:08:10 <lambdabot>   True
11:08:15 <simpson> > let allEq (x:y:[]) = x == y; allEq (x:xs@(y:ys)) = x == y && allEq xs in allEq [1,1,2]
11:08:17 <lambdabot>   False
11:08:30 <simpson> This is what happens when Python people write Haskell.
11:08:33 <jmcarthur> > let allEq = null . drop 1 . group in allEq [1,1,1]
11:08:35 <lambdabot>   True
11:08:36 <jmcarthur> > let allEq = null . drop 1 . group in allEq [1,1,2]
11:08:37 <lambdabot>   False
11:08:50 <sw17ch> hmm
11:08:58 <monoidal>  f (x:xs) = all (==x) xs is IMO most readable
11:09:05 <hpc> simpson: a little-known secret of haskell is that functions are functions no matter how you write them ;)
11:09:06 <mapf> :t (<= 1) . length . group
11:09:08 <lambdabot> Eq a => [a] -> Bool
11:09:31 <sw17ch> now, can we generalize it over Functor?
11:09:37 <jmcarthur> mapf: if the length is long that will take a long time
11:09:58 <jmcarthur> sw17ch: we could generalize it over Foldable
11:10:09 <mapf> jmcarthur: yep, but thats simplest I can imagine
11:10:20 <monoidal> jmcarthur: assuming you can get to some element
11:10:26 <monoidal> ah, via toList
11:11:05 <ab9rf> the goal is a predicate for "are all the elements of the list the same"?
11:11:20 <sw17ch> ab9rf: yes!
11:11:41 <jmcarthur> :t null . drop 1 . group . Data.Foldable.toList
11:11:43 <lambdabot> (Eq a, Foldable t) => t a -> Bool
11:11:43 <ab9rf> i like monoidal's expression for that along with the observation that you need f [] = True
11:12:10 <jmcarthur> nub instead of groups would also work. that might be more clear
11:12:19 <jmcarthur> i think it might not even be slower since it's still lazy
11:12:26 <ab9rf> nub is comparatively expensive
11:12:27 <ParahSail1n> :ty group
11:12:34 <jmcarthur> i don't think nub is expensive for this case
11:12:36 <sw17ch> yeah, i shied away from nub
11:12:37 <ParahSail1n> @ty group
11:12:38 <lambdabot> Eq a => [a] -> [[a]]
11:12:44 <jmcarthur> @src nub
11:12:45 <lambdabot> nub = nubBy (==)
11:12:48 <jmcarthur> @src nubBy
11:12:48 <lambdabot> nubBy eq []             =  []
11:12:49 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:12:56 <ab9rf> jmcarthur: i'm not sure at what point laziness will cut nub off
11:13:17 <ab9rf> obviously you could do length (nub l) <= 1
11:13:30 <jmcarthur> ab9rf: as soon as it encounters a new value, it emits it. if it ever emits a second one, we will stop evaluating
11:13:37 <jmcarthur> no, length is bad
11:13:47 <ab9rf> jmcarthur: yeah, length is bad
11:13:50 <jmcarthur> you would want to do  null . drop 1
11:13:53 <ab9rf> ah, drop 1
11:13:54 <ab9rf> clever
11:14:00 <hpaste> sw17ch pasted “allEq” at http://hpaste.org/85304
11:14:11 <ab9rf> jmcarthur: except won't that except if given an empty list?
11:14:20 <monoidal> null . drop 1 . group
11:14:28 <monoidal> ab9rf: drop n [] == []
11:14:33 <ab9rf> ah, ok
11:14:44 <jmcarthur> > let allEq = null . drop 1 . group in allEq $ [1,1,2] ++ repeat undefined
11:14:46 <lambdabot>   False
11:14:51 <jmcarthur> > let allEq = null . drop 1 . nub in allEq $ [1,1,2] ++ repeat undefined
11:14:53 <lambdabot>   False
11:14:58 <sw17ch> :t null
11:14:59 <lambdabot> [a] -> Bool
11:15:04 <monoidal>  let allEq = null . drop 1 . nub in allEq $ repeat 1
11:15:07 <monoidal> > let allEq = null . drop 1 . nub in allEq $ repeat 1
11:15:12 <lambdabot>   mueval: ExitFailure 1
11:15:13 <lambdabot>  mueval: Prelude.undefined
11:15:17 <ab9rf> heh
11:15:31 <jmcarthur> that would be _|_ due to the spec
11:15:54 <ab9rf> so null . drop 1 . nub wins
11:16:03 <jmcarthur> "wins"?
11:16:13 <ab9rf> well, it solves the problem and appears to be fairly efficient
11:16:16 <jmcarthur> there are many nice implementations mentioned so far :)
11:16:22 <ab9rf> and quite terse
11:16:45 <ab9rf> and slightly nonobvius, which is always a good thing :)
11:17:27 <sw17ch> I'm a fan of the shortest possible implementation here.
11:17:28 <ab9rf> monoidal's definition is also fairly nice and its efficiency is a bit more obvious
11:17:44 <ab9rf> but it requires an additional case to deal with []
11:17:45 <jmcarthur> you could also replace  null . drop 1  with  (<=(1::Nat)) . genericLength
11:17:56 <ab9rf> jmcarthur: ugh
11:18:02 <klrr> can someone give me an example of how to use "maybe", i just get errors when i try it out in the ghci?
11:18:02 <jmcarthur> it's longer but more directly fits some peoples' intuitions
11:18:13 <ab9rf> :t maybe
11:18:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:18:20 <klrr> i know the type
11:18:26 <ab9rf> good :)
11:18:26 <klrr> i just dont get how to use it
11:18:34 <jmcarthur> > maybe (-1) succ $ Just 10
11:18:35 <lambdabot>   11
11:18:37 <jmcarthur> > maybe (-1) succ $ Nothing
11:18:39 <lambdabot>   -1
11:19:02 <klrr> > maybe 1 (2<) Just 5
11:19:04 <lambdabot>   Couldn't match expected type `t0 -> t1'
11:19:04 <lambdabot>              with actual type `GHC....
11:19:05 <ab9rf> the first argument is what you return for Nothing, and the second is a function to applied to the enclosed value for a Just
11:19:15 <jmcarthur> klrr: the function has to return the same type as the default
11:19:19 <monoidal> klrr: you need $ or parens
11:19:26 <ab9rf> > maybe False (2<) Just 5
11:19:27 <lambdabot>   Couldn't match expected type `t0 -> t1'
11:19:28 <lambdabot>              with actual type `GHC....
11:19:28 <klrr> > maybe 1 (2<) $ Just 5
11:19:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
11:19:29 <lambdabot>    arising from the literal `1...
11:19:41 <mapf> klrr: maybe is actually eliminator
11:19:43 <monoidal> ah, right, the type is wrong
11:19:43 <jmcarthur> > maybe False (2<) $ Just 5
11:19:45 <lambdabot>   True
11:19:48 <ab9rf> > maybe False (2<) (Just 5)
11:19:49 <lambdabot>   True
11:19:54 <ab9rf> > maybe False (6<) (Just 5)
11:19:55 <lambdabot>   False
11:19:59 <ab9rf> > maybe False (6<) Nothing
11:20:00 <klrr> > maybe False (2<) $ Just 5
11:20:01 <lambdabot>   False
11:20:01 <lambdabot>   can't find file: L.hs
11:20:11 <klrr> i dont get it
11:20:22 <klrr> why dont " maybe 1 (2<) $ Just 5" work?
11:20:30 <jmcarthur> klrr: think about the types
11:20:32 <jmcarthur> :t maybe
11:20:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:20:43 <jmcarthur> klrr: so b = Int
11:20:47 <klrr> yeah? all are Num,
11:20:51 <ab9rf> klrr: because (2<) does not return a type compatible with 1
11:20:54 <jmcarthur> klrr: (a -> b) = Int -> Bool
11:20:56 <jmcarthur> klrr: contradiction
11:21:05 <jmcarthur> klrr: because now you're trying to say b is both Int and Bool,
11:21:16 <ab9rf> :t 1
11:21:17 <lambdabot> Num a => a
11:21:20 <klrr> > maybe 1 ((<) 2) $ Just 5
11:21:21 <sw17ch> :t null
11:21:22 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
11:21:22 <lambdabot>    arising from the literal `1...
11:21:23 <lambdabot> [a] -> Bool
11:21:27 <ab9rf> Bool is not in Num a
11:21:38 <jmcarthur> the Num thing just complicates the error message here
11:21:40 <klrr> > maybe 1 ((+) 2) $ Just 5
11:21:42 <lambdabot>   7
11:21:43 <sw17ch> :t null . drop
11:21:45 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'
11:21:45 <lambdabot>     Expected type: Int -> [a0]
11:21:45 <lambdabot>       Actual type: Int -> [a1] -> [a1]
11:21:47 <ab9rf> Num is not an type, it's a class
11:21:48 <jmcarthur> > maybe (1 :: Int) ((<) 2) $ Just 5
11:21:49 <klrr> aa now i get it thanks!
11:21:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:21:50 <lambdabot>              with actual type ...
11:22:10 <ab9rf> sw17ch: drop takes an argument
11:22:20 <jmcarthur> :t null . drop 1
11:22:22 <lambdabot> [a] -> Bool
11:22:23 <ab9rf> :t \x -> null . drop x
11:22:24 <lambdabot> Int -> [a] -> Bool
11:22:26 <sw17ch> oops, right
11:22:42 <ab9rf> @pl \x -> null . drop x
11:22:42 <lambdabot> (null .) . drop
11:22:49 <jmcarthur> > map (null . drop 1) [[],[a],[a,b]]
11:22:50 <lambdabot>   [True,True,False]
11:23:34 <ab9rf> > zipWith ( (null .) . drop) (repeat 2) [[],[a],[a,b]]
11:23:35 <lambdabot>   [True,True,True]
11:23:47 <ab9rf> > zipWith ( (null .) . drop) (repeat 2) [[],[a],[a,b],[a,b,c]]
11:23:49 <lambdabot>   [True,True,True,False]
11:24:19 <ab9rf> > zipWith ( (null .) . drop) [1..10] (repeat "cookie")
11:24:21 <lambdabot>   [False,False,False,False,False,True,True,True,True,True]
11:24:57 <jmcarthur> @check \x y -> (x <= y) == (null . drop y $ replicate x ())
11:24:59 <lambdabot>   Not in scope: `myquickcheck'
11:25:11 <ab9rf> aw
11:27:15 <klrr> does haskell has any functions which test types, like "list? [1,2,3]; True; int? 4; True; string? [1,2,3]; False" ?
11:27:24 <jmcarthur> :t typeOf
11:27:25 <lambdabot> Typeable a => a -> TypeRep
11:27:39 <jmcarthur> > typeOf ()
11:27:39 <klrr> thanks!
11:27:40 <lambdabot>   ()
11:27:41 <jmcarthur> > typeOf True
11:27:43 <lambdabot>   Bool
11:27:54 <jmcarthur> it lives in Data.Typeable
11:28:00 <jmcarthur> we don't use it much
11:28:04 <ab9rf> note that you won't have much use for it
11:28:22 <quchen> int? :: Int -> Bool
11:28:22 <ab9rf> the language tends to abhor loose types
11:28:25 <quchen> int? = const True
11:28:45 <jmcarthur> klrr: good luck defining your list that can contain values of different types (it's doable, but if you manage to find the way you will see why it's not desirable)
11:28:56 <ab9rf> haskell is not PHP :)
11:29:01 <jmcarthur> quchen: ha!
11:29:07 <quchen> @hackage acme-php
11:29:07 <lambdabot> http://hackage.haskell.org/package/acme-php
11:29:11 <quchen> ^ ab9rf
11:29:24 <jmcarthur> > let isInt :: Int -> Bool; isInt _ = True in isInt 5
11:29:26 <lambdabot>   True
11:29:28 <jmcarthur> > let isInt :: Int -> Bool; isInt _ = True in isInt "nope"
11:29:30 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:29:30 <lambdabot>              with actual type ...
11:29:56 <quchen> jmcarthur: Issue a system call to runghc, parse the stderr
11:30:26 <jmcarthur> quchen: i like the type of sort in that package
11:30:40 <jmcarthur> sort :: [()] -> [()]
11:31:08 <jmcarthur> probably just due to the monomorphism restriction
11:31:19 <quchen> jmcarthur: Yeah I don't understand that one
11:31:51 <jmcarthur> it's just missing its type signature in the implementation and the monomorphism restriction is not disabled
11:32:18 <jmcarthur> so it's just defaulting :\
11:32:38 <quchen> jmcarthur: That reminds me that I don't get the monomorphism restriction in the first plcae
11:32:42 <jmcarthur> :t \a b -> compare a b
11:32:43 <lambdabot> Ord a => a -> a -> Ordering
11:32:51 <Mortchek> sort :: [()] -> [()]; sort = id -- :P
11:32:53 <ab9rf> quchen: hahah
11:32:55 <jmcarthur> ah that might not default anyway
11:33:35 <ab9rf> quchen: that's truly evil
11:33:42 <quchen> ..?
11:33:44 <ab9rf> quchen: it fails to implement many of PHP's infamous errors though
11:33:46 <quchen> Oh you mean the package
11:33:47 <jmcarthur> quchen: essentially the monomorphism restriction is to make it harder to accidentally define some non-function value that has different representations for different types
11:34:05 <ab9rf> quchen: such as treating all strings that start with a digit as being equal if they're equal in their conversion to integers :)
11:34:08 <jmcarthur> quchen: e.g. Num a => [a]  at the top level or something
11:34:23 <ab9rf> quchen: yes
11:34:23 <jmcarthur> quchen: could take up a lot more space if you accidentally use it as multiple types
11:34:49 <quchen> jmcarthur: Oh, a CAF that's instantiated for Int, Integer, LazyNaz, ... for 10^10 numbers for example?
11:35:08 <jmcarthur> ab9rf: my former roommate wrote this awesomeness http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
11:35:16 <jmcarthur> quchen: yeah, stuff like that
11:35:43 <ab9rf> jmcarthur: i run into that at least once a month.  it's a pretty good article, although i hae quibbles with a few minor points.
11:35:52 <quchen> jmcarthur: Well then I don't get why it's enabled by default.
11:36:05 <quchen> jmcarthur: Sounds like "Hey let's enable -Wall to prevent accidents"
11:36:19 <ab9rf> jmcarthur: it's always fun to post a link to that into a PHP forum or community and watch the gerbils explode
11:36:35 <jmcarthur> quchen: it also reduced beginner-unfriendly error messages sometimes
11:36:41 <jmcarthur> quchen: it is largely considered a mistake though
11:36:52 <quchen> ab9rf: There's a long thread of eevee arguing with some PHP fanboy. It's cycle-sad-funny to read.
11:37:14 <jmcarthur> he always finds people that make him sad
11:37:20 <jmcarthur> it makes me sad
11:37:29 <__xc> yees tha'ts sad
11:37:30 <jmcarthur> that said, i want to read this
11:37:41 <quchen> This?
11:37:44 <quchen> The thread?
11:37:48 <jmcarthur> the thread you referred to
11:37:53 <quchen> Let me look it up
11:37:55 <__xc> Php is the cause of much evil
11:37:59 <simpson> jmcarthur: You roomed with eevee? That's pretty cool.
11:38:23 <__xc> no joke, I don"t care
11:39:03 <mapf> can somebody explane why does Network.Socket doing htons for PortNumber, but not doing htonl for HostAddress?
11:39:30 <quchen> jmcarthur: I'll post the link in #haskell-blah
11:39:32 <jmcarthur> simpson: yup. i didn't realize he was well-known enough for that to be something notable though
11:39:42 <jmcarthur> i mean i know that article has been around
11:40:16 <simpson> jmcarthur: He's known in the Python community and he's a pretty cool guy.
11:40:27 <jmcarthur> yeah
11:40:32 <applicative> hm, the php->haskell compiler has to define the predicate "isTruthy" :   let  condExpr = "(do { r <- sequence [" ++ (concatExprs "," conds) ++ "]; return $ all isTruthy r })"
11:40:42 <simpson> Haha!
11:41:02 <jmcarthur> he was a perl fan when we were roomies and i thought he was crazy :P
11:42:13 <applicative> it seems not to have developed, as I was imagining, into a pretentious package 'language-php' to put alongside 'language-c' and the like
11:43:30 <applicative> which would be much more amusing than acme-php
11:43:59 <applicative> https://github.com/jhartikainen/hs-language-php/
11:46:29 <klrr> when i try compile my program it says "Integer is not in scope", http://hastebin.com/gecuvucubo.hs lines 88-113 is the relevant ones (the program is a simeple scheme repl from the Write a scheme in haskell in 48 hour tutorial)
11:46:34 <klrr> any ideas?
11:46:56 <applicative> you used "Integer" as a value
11:47:22 <klrr> applicative: should i use a random int instead?
11:47:29 <applicative> on line 106?
11:49:10 <klrr> applicative: yes
11:49:13 <merijn> pffft
11:49:22 <merijn> That pastebin doesn't even load if you have JS disabled
11:49:43 <klrr> i know but it's stylish
11:49:51 <applicative> something is wrong with that and the next two lines, and maybe the 'whattype' functions needs to be thought through...
11:50:20 <mapf> klrr: hpaste is even more stylish
11:50:24 <applicative> merijn: http://hastebin.com/raw/gecuvucubo
11:50:25 <klrr> applicative: hmm, well that's my solution to the problem, im trying to implement "string?" etc.
11:50:29 <klrr> mapf: not imo :P
11:50:59 <d-snp> :( the yesod guys kind of messed up on WAI
11:51:18 <applicative> but the second element of each pair is a function from [LispValue] -> LispValue, so maybe you want these to be return LispBool or whatever
11:51:49 <simpson> d-snp: How so?
11:52:01 <mapf> klrr: well, but it's not working with w3m
11:52:25 <d-snp> simpson: well, they forgot to specify an interface for webservers, so now frameworks like Yesod have webserver specific code in them
11:53:04 <d-snp> for example, yesod has Yesod.Default.Main which depends on Warp
11:53:06 <klrr> mapf: what's w3m?
11:53:17 <jmcarthur> opened up a random project of mine and found the unintentional awesomeness: "destroy kitten"
11:53:41 <simpson> d-snp: Well, maybe you should /join #yesod and give them some patches.
11:53:48 <d-snp> hmm alright
11:53:50 <mapf> klrr: it's so called `pager': http://en.wikipedia.org/wiki/W3m
11:53:52 <timthelion> jmcarthur: really, is there *ANYTHING* awsome about destroying kitties?
11:54:09 <jmcarthur> it's only one kitten
11:54:10 <applicative> klrr: i think I see, it should be               ("number?", whatType (17 :: Integer)),
11:54:32 <mapf> w3m can work with emacs, so you can browse without leave emacs
11:55:24 <applicative> no, that's not quite right it's a LispThing -> LispThing function not [LispThing] -> LispThing
11:55:45 <timthelion> mapf: Why not just use picocom to send signals right to your network card?  So much more light weight!
11:56:37 <mapf> timthelion: well, thats just convenient :) for paste for exsample
11:56:54 <mapf> timthelion: i'm not a big fan
11:57:57 * timthelion remebers his emacs years.  Ended up with such a mess in the .emacs file.  Too much customization IS a bad thing.
12:00:06 <applicative> grr, klrr, why are you using Typeable, this is a simple matter, e.g. isLispString (String _) = True; isLispString _ = False, or the like
12:07:27 <applicative> wow augustss is out of control on Reddit.  Seems it's occasionally worth reading after all... http://www.reddit.com/r/haskell/comments/1bsitm/lazy_io_breaks_equational_reasoning/
12:16:13 * hackagebot monad-ox 0.3.0 - Monad for observation extraction  http://hackage.haskell.org/package/monad-ox-0.3.0 (JakubWaszczuk)
12:18:05 <fluffynukeit> hi all.  Hoping to get help.  I have a function that accepts arguments of type (Message a).  Depending on the type of a, I want to add a to a list.  The type constructor of a is irrelevant to me.  Is there a way to do this?  Essentially I want to pattern match on the type of a, not any particular type constructor of a. Thanks.
12:18:46 <Eduard_Munteanu> Hi.
12:18:58 <Eduard_Munteanu> I think you mean data constructor?
12:19:12 <fluffynukeit> indeed I do, thanks
12:19:45 <Eduard_Munteanu> Typeclasses are much like "pattern-matching types".
12:20:14 <Eduard_Munteanu> You would define an instance for the possible types 'a' can be.
12:21:35 <Eduard_Munteanu> But I'm unsure what you mean by "add a to a list".
12:22:06 <Eduard_Munteanu> If you mean adding a value of type 'a' to a list, then lists are homogenous anyway.
12:22:29 <merijn> Do you mean like "Message a -> [a] -> [a]"?
12:22:48 <Saizan> you want one list per type, maybe?
12:23:06 <fluffynukeit> Eduard_Munteanu:  essentially I want a function that does this :: [Message a] -> [Message MyTypeHere]
12:23:36 <Eduard_Munteanu> fluffynukeit: and MyTypeHere depends on 'a'?
12:23:49 <fluffynukeit> I want to filter out all messages for which a does not match MyTypeHere
12:24:27 <Eduard_Munteanu> fluffynukeit: a list stores values of a single type, so I'm not sure what you mean
12:24:45 <ceii> fluffynukeit, you can do that if you restrict "a" to the Typeable class, which contains a "typeOf" operation
12:25:10 <int-e> ceii: then the elemnts are still missing an existential wrapper.
12:25:17 <ceii> right
12:26:58 <fluffynukeit> thanks guys.  Here's some more specifics.  I have a channel,  I am putting (Message a) into the channel, where a is either FMessage or BMessage.  What I want to do is filter these guys so that one listener gets only FMessages and another gets only BMessages (frontend and backend).
12:27:16 <merijn> Why not have two channels?
12:27:50 <int-e> "channel" being something like Control.Concurrent.Chan? If so, you'll find that you can't mix those messages on the same channel in the first place.
12:28:21 <Clint> you could do a tuple of (destination, message)
12:28:33 <fluffynukeit> int-e, why is that?  They are all of type Message
12:28:37 <geekosaur> although if FMessage and BMessage are data constructors for the same type, foo (Message m@(AMessage {})) = ...
12:28:37 <Philippa> int-e: they're constructors, not types
12:28:54 <geekosaur> and then another case for BMessage
12:28:57 <fluffynukeit> geekosaur, they are not data constructors
12:29:05 <int-e> fluffynukeit: you talked about "Message a" with varying a.
12:29:10 <timthelion> int-e: sure you can: data Message a = FMessage a | BMessage a
12:29:12 <int-e> Philippa: not sure.
12:29:27 <geekosaur> fluffynukeit, in that case you probably can't even get them into the same Chan. as you've been told
12:29:38 <int-e> Philippa: the problem description is shifting :)
12:29:41 <geekosaur> if you could, it would be because they were data constructors for the same type
12:29:42 <Eduard_Munteanu> data FMessage; data BMessage   ?
12:30:10 <fluffynukeit> FMessage and BMessage are not data constructors, they are types
12:30:15 <Clint> why
12:30:24 <timthelion> fluffynukeit: well make a data constructor to hold them.  The solution to polymorphism, is megamorphism(one big monomophic type that covers both sub types)
12:30:38 <Eduard_Munteanu> I guess we wants to do some type-safe stuff, and those are phantom
12:30:42 <geekosaur> fluffynukeit, and you have already created a Chan that is capable of holding both?
12:30:43 <fluffynukeit> timthelion and I have, it's called Message
12:30:45 <geekosaur> if so, show it
12:31:26 <fluffynukeit> ok, give me a second to hpaste.  Thanks all.  Sorry it I'm unclear.
12:31:34 <timthelion> fluffynukeit: then have your frontend "peek" at the chanel, and "get" the things that bellong to the data constructor for FMessage, and vice versa.
12:31:39 <geekosaur> pretty sure you can't create a Chan of (Message a) that will let you use any a on the same channel
12:31:50 <Eduard_Munteanu> Chan Bytestring or some such :P
12:31:57 <geekosaur> unless you use existentials, in which case you have "erased" the type and cannot see it at all
12:32:01 <Eduard_Munteanu> (assuming that's Storable)
12:33:59 * timthelion agrees with whoever sugested two channels
12:36:14 <hpaste> fluffynukeit pasted “Channel filtering” at http://hpaste.org/85306
12:37:59 <Eduard_Munteanu> fluffynukeit: well, it's not like you can pass both kinds through the same chan
12:38:20 <Philippa> though the tricky bit's when something then needs to wait on "one of either"
12:38:21 <Eduard_Munteanu> So those functions are pretty much nops :)
12:38:58 <fluffynukeit> ok everyone, in case you missed it there's an hpaste there of what I'm hoping to accomplish.  Two channels is indeed a solution, but if I can avoid it that would be splendid because it seems cleaner to me.
12:39:06 <d-snp> can a main function return something different then just IO()? for example, could it be IO String instead?
12:39:25 <mapf> d-snp: why?
12:39:26 <simpson> d-snp: Where would it return it to?
12:39:28 <geekosaur> d-snp, yes, but what it returns will be discarded
12:39:32 <Eduard_Munteanu> ^^
12:39:36 <merijn> I think main can return anything, yes
12:39:38 <monoidal> d-snp: it can be IO a for any a
12:39:39 <d-snp> awesome, thank you :P
12:39:56 <monoidal> d-snp: but there's little point in being anything other than IO ()
12:39:57 <timthelion> fluffynukeit: just get rid of a, you don't need it.
12:40:06 <timthelion> fluffynukeit: that will solve your problem.
12:40:18 <merijn> fluffynukeit: The two channel approach seems much cleaner to me than the one channel approach, tbh
12:40:20 * monoidal thinks main :: IO a in haskell is a mistake
12:40:32 <timthelion> fluffynukeit: data Message = MFMessage FMessage | MBMessage BMessage
12:40:36 <Eduard_Munteanu> fluffynukeit: if you have a fixed set of types you need to handle, then you should just build a datatype with multiple constructors
12:41:17 <osfameron> monoidal: integer return value no?
12:41:28 <Eduard_Munteanu> Yeah, an integer return code makes sense.
12:41:43 <Eduard_Munteanu> But possibly that's OS-specific?
12:41:51 <geekosaur> but then we'd either have to make it always IO Int (breaking change) or special case IO Int
12:41:54 <fluffynukeit> timthelion, Eduard_Munteanu: yes, it looks like you guys came to the same suggestion at once.  Makes total sense and I'm kicking myself for not thinking it.  TYVM
12:41:55 <bscarlet> d-snp: At least for me, if main returns something showable other than (), it gets printed.
12:42:06 <geekosaur> um?
12:42:08 <monoidal> osfameron: no, you can return the integer via functions in System.Exit iirc
12:42:11 <geekosaur> ghci will do that, ghc will not
12:42:24 <geekosaur> and ghci won't if you use :main so it simulates the way ghc does it
12:42:35 <d-snp> my reason is that main is special in the sense that you can point to it with a cabal file
12:42:52 <monoidal> osfameron: integers returned by main are ignored
12:43:15 <d-snp> not sure if I can actually use that, but just good to know..
12:52:31 <d-snp> how does haskell's reflection system work? can I say I want to call the function called 'buildApplication' in the file 'main.hs' with the prototype 'IO Network.WAI.Application' somehow?
12:53:21 <d-snp> so I know everything about the function except what module it is in
12:53:47 <d-snp> ghci seems to be able to do it
12:53:51 <jmcarthur> err... you can only have one module per file...
12:53:56 <jmcarthur> so you do know what module it's in
12:55:05 <d-snp> but I only have the filename in a string, it can have a different module name than its filename right?
12:55:41 <jmcarthur> the only module allowed to have a different file name is the Main module
12:56:23 <jmcarthur> which you have to name explicitly when you build it anyway
12:56:36 <jmcarthur> so, again, you already know the module's name
12:57:17 <timthelion> How does one find the shortest [a] in an [[a]]?  Finding the longest is easy with foldr :/
12:57:37 <shachaf> That is a GHC rule, not a Haskell rule.
12:57:37 <quchen> minimumBy length
12:57:42 <jmcarthur> shachaf: ah
12:57:56 <shachaf> Not that that's really relevant. :-)
12:58:07 <shachaf> minimumBy smartCompareListsOnLength
12:58:47 <timthelion> that seems quite ineficient, as finding a lists length is hard.
12:59:01 <timthelion> many times worse than finding the longest.
12:59:32 <jmcarthur> you are after the actual list or just its length?
12:59:33 <quchen> timthelion: You can also iterate "map tail" over the list until one is empty.
12:59:49 <timthelion> jmcarthur: actual list
12:59:57 <shachaf> That's why smartCompareListsOnLength
13:00:54 <timthelion> shachaf: ^_^
13:00:57 <shachaf> @ty let cmp [] [] = EQ; cmp (_:xs) [] = GT; cmp [] (_:ys) = LT; cmp (_:xs) (_:ys) = cmp xs ys in cmp
13:00:58 <lambdabot> [t] -> [t1] -> Ordering
13:01:00 <shachaf> timthelion: What?
13:01:14 <timthelion> shachaf: well, that is a bit better :)
13:01:19 <shachaf> ?
13:01:59 <timthelion> shachaf: it's still not efficient.
13:02:24 <monoidal> timthelion: why?
13:02:26 <shachaf> How?
13:03:14 <timthelion> shachaf: it's quite the same as a stupid comparison, if all your lists are the same length.
13:03:32 <quchen> timthelion: But it won't crash on infinte lists.
13:03:57 <monoidal> timthelion: you won't get anything better
13:04:06 <shachaf> It is using lazy naturals in the form of lists of some type.
13:05:04 <quchen> monoidal: Well, using cmp will walk both lists all the time, i.e. comparing xs, ys, zs will mean running through 4 lists.
13:05:38 <monoidal> quchen: asymptotically it's the same?
13:06:04 <monoidal> however, I see that [repeat 1, repeat 1, [1]] could not work
13:06:21 <jmcarthur> timthelion: if all the lists are the same length you can't avoid traversing everything
13:06:31 <quchen> monoidal: asymptotically isn't the only thing that's relevant. O(10^10) isn't the same as O(4).
13:06:38 <monoidal> quchen: it is :)
13:06:51 <quchen> For infinitely large data, yes.
13:07:02 <simpson> quchen: That's precisely why we use O(). There are other notations for that stuff.
13:07:03 <monoidal> O(10^10) is the same as O(4) by definition of big O
13:07:04 <shachaf> No, for any data.
13:07:07 <eyebloom> Can you pattern match on type?
13:07:20 <monoidal> eyebloom: no. perhaps you want a typeclass
13:07:29 <__xc> with instance
13:07:37 <quchen> Well, yes, in the computational sense. I meant O as in "how much stuff you have to do".
13:07:52 <quchen> (I thought that was obvious.)
13:07:54 <monoidal> big O has one meaning
13:08:03 <elliott> O is there specifically to make those two things equal.
13:08:29 <hpaste> timthelion pasted “fast shortest” at http://hpaste.org/85307
13:08:29 <quchen> Oh crap, a metaphor, better correct it over ten lines. Pardon. Keep using cmp
13:08:48 <monoidal> there's a different between metaphor and outright wrong usage
13:09:27 <quchen> "A metaphor is a figure of speech that describes a subject by asserting that it is, on some point of comparison, the same as another otherwise unrelated object."
13:09:28 <eyebloom> If I promote a type such as:    data Nat = Zero | Succ n  to a kind how can I access that value when typechecking?
13:09:32 <quchen> Semantics. Always fun to argue about.
13:09:40 * timthelion bangs head. Realises he was mischaraterizing minimumBy's behavior
13:09:52 <eyebloom> *data Nat = Zero | Succ Nat
13:10:12 <shachaf> quchen...
13:10:22 <shachaf> Never mind. :-)
13:11:02 <monoidal> eyebloom: assuming you have -XDataKinds it should be available normally when you give it in a type signature
13:13:16 <timthelion> shachaf: sorry for wasting your time, you were right all along.
13:13:47 <monoidal> timthelion: think about [repeat 1, repeat 1, [2]]
13:14:02 <shachaf> You can make a function that works for that input, but not with minimumBy.
13:14:46 <timthelion> shachaf: mm?
13:14:49 <monoidal> quchen: sorry to beat a dead horse, but what you should have written, is, for example, "10^10 n isn't the same as 4n". big O notation specifically removes the constants.
13:15:46 <eyebloom> So if I define a constructor data C :: Nat -> * where C1 :: Int -> C n
13:16:34 <eyebloom> and then a function id :: C (Succ n) -> C n
13:16:44 <eyebloom> id = \x -> x
13:17:03 <elliott> you'll need id (C1 n) = C1 n
13:17:16 <elliott> or id = unsafeCoerce (safe, faster if your structure is recursive :( )
13:17:36 <shachaf> :☹(
13:18:12 <monoidal> timthelion: I believe that if you want cases such as [repeat 1, repeat 1, [2]] to work, you have to traverse all lists simultaneously (not focus on two of them)
13:18:25 <eyebloom> what happens if I try to apply id to an expression of type C Zero
13:18:34 <elliott> it is a type error
13:18:42 <elliott> you cannot match Zero and Succ n
13:18:54 <elliott> just like ("x" + (1::Int)) fails
13:18:57 <elliott> can't match Int and String
13:19:22 <monoidal> eyebloom: you can't write say f :: [Int] -> [Char]; f (x@[]) = x either
13:19:22 <eyebloom> I see.
13:20:48 <eyebloom> What if I want to unwrap a C1 and rewrap it. Is there a way I can retain it's original type.
13:21:06 <eyebloom> sorry, unwrap a C
13:21:17 <elliott> sure
13:21:27 <elliott> foo :: C n -> C n; foo (C1 n) = C1 n
13:21:32 <elliott> or just foo = id
13:21:33 <eyebloom> such as unC (C1 x) = x
13:21:45 <Kazimuth> hm. is there a power operator that takes complex exponents?
13:22:11 <eyebloom> I see so basically it's all in the type signature.
13:22:15 <monoidal> Kazimuth: I think (**)
13:22:37 <Kazimuth> monoidal: nope
13:22:44 <monoidal> > (2 :+ 3) ** (3 :+ 4)
13:22:45 <lambdabot>   (-0.20455292179417606) :+ 0.8966232598799768
13:22:59 <Kazimuth> oh. What am I doing wrong then
13:23:01 <Kazimuth> wait
13:23:04 <Kazimuth> I think I got it
13:28:36 <latro`a> wait, which branch of log does ** assume for Complex?
13:28:37 <latro`a> >.>
13:29:33 <otters> :t (:+)
13:29:34 <lambdabot> a -> a -> Complex a
13:29:45 <otters> > (0 :+ 1) ** (0 :+ 1)
13:29:46 <lambdabot>  Terminated
13:29:49 <otters> what
13:30:25 <Eduard_Munteanu> Principal branch I guess?
13:31:02 <Eduard_Munteanu> > (0 :+ 1) ** (2 :+ 0)
13:31:04 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
13:31:26 <latro`a> the thing you tried before worked fine in my ghci
13:32:08 <latro`a> (0 :+ 1) ** (0 :+ 1) - exp(-pi/2) gives 0.0 :+ 0.0, too
13:32:23 <tootsie> so
13:32:27 <tootsie> <><>
13:32:50 <tootsie> > let (<>) a b = a /= b in 5 <> 7
13:32:52 <lambdabot>   True
13:33:14 <tootsie> > let (!=) a b = a /= b in 5 != 7
13:33:16 <lambdabot>   True
13:33:24 <tootsie> why was the /= chosen?
13:33:35 <latro`a> looks more like \neq I guess
13:33:51 <tootsie> > let a = 10 in a /= 2
13:33:53 <lambdabot>   True
13:34:06 <Iceland_jack> tootsie: /= looks like ≠ don'tcha think?
13:35:47 <tootsie> Iceland: mmm, maybe
13:35:57 <tootsie> but != is widely used
13:36:34 <Iceland_jack> I wasn't making a case for it, but that's the reason for it
13:37:45 <mapf> which one logger is recommended if i have a few threads?
13:40:20 <derek_c> Hello! Does anyone know a way to auto-format Haskell code using Sublime Text?
13:40:52 <shachaf> Auto-formatting Haskell is impossible because layout has meaning.
13:41:14 <SoupEvil> SublimeHaskell is a good plugin for sublime + haskell
13:41:23 <timthelion> shachaf: that's not true in general, see yi(though it makes mistakes sometyimes)
13:41:25 <SoupEvil> there is a Stylish function
13:41:34 <donri> derek_c: bet you could make it filter with stylish-haskell
13:41:53 <shachaf> timthelion: Maybe you mean that it's true in general but not true in particular?
13:42:15 <timthelion> shachaf: no, something cannot be true in general but not true in particular.
13:43:36 <SoupEvil> some netwire coders here? i'm seeking for some deeper examples for netwire, in concrete some Wires with Monads, like Reader
13:44:27 <merijn> SoupEvil: Here you go: http://hpaste.org/83098
13:44:43 <derek_c> SoupEvil: haha thanks!
13:44:48 <merijn> SoupEvil: mm_freak hangs out here as well (he wrote netwire)
13:45:00 <donri> SoupEvil: i know two blog posts anyway, https://danbst.wordpress.com/2013/01/23/novice-netwire-user/  http://jshaskell.blogspot.se/2012/11/breakout-improved-and-with-netwire.html
13:45:04 <timthelion> merijn: where did you get that from?
13:45:07 <derek_c> guys, I couldn't find an explanation of the helper function "go"
13:45:47 <merijn> timthelion: mm_freak wrote it for me when I asked the same question :p
13:46:02 <derek_c> why is the Haskell docs not searchable
13:46:11 <shachaf> @where hoogle
13:46:11 <lambdabot> http://haskell.org/hoogle
13:46:13 <shachaf> @where hayoo
13:46:14 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:46:18 <shachaf> Now they are.
13:46:21 <donri> derek_c: https://www.fpcomplete.com/hoogle
13:46:28 <timthelion> merijn: oh, I was hoping it was from the secret jane street repos(thus you not linking to something published, but hpasting instead)
13:46:43 <timthelion> donri: hoogle didn't help ME find go
13:46:50 <merijn> I'm not even remotely associated with Jane Street, so I'd have to hack in there first :)
13:46:55 <donri> timthelion: 'go' is usually a local binding
13:46:59 <SoupEvil> merijn, donri: thanks a lot
13:47:04 <derek_c> aha thanks
13:47:41 <timthelion> merijn: I'm getting interested in them. I used to think of them as boring, until I read their web page: Jane Street does not take customers...
13:47:48 <derek_c> I was just looking at this: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
13:47:56 <derek_c> and in the 2.1.1 section, it uses "go"
13:48:09 <derek_c> but I don't know what it dos
13:48:10 <derek_c> does
13:48:19 <timthelion> merijn: apparently, they make enough off the capital they have,that they can employ a bunch of people and don't need other people's money to play with.
13:48:37 <donri> derek_c: it's defined after 'where'
13:49:43 <derek_c> oh!!
13:49:45 <derek_c> damn it
13:49:53 <derek_c> I thought it was a standard helper function
13:50:00 <derek_c> donri: thanks!
13:50:05 <donri> :)
13:51:04 <merijn> derek_c: "go" is a common name for helper functions that do the actual work, so they'll almost always be in a let/where clause close by
13:51:26 <derek_c> merijn: I see haha
13:51:40 <donri> do you!
13:51:46 <donri> go you!*
13:51:50 <merijn> It's similar to lists being called "x:xs" in patterns
13:52:42 <__xc> note that the "!" are lazy paramters
13:53:58 <donri> __xc: other way around
13:54:07 <monoidal> "~" is lazy pattern, "!" is strict
13:55:08 <shachaf> @ty let x `map` [] = []; x `map` (fs:f) = (:) (x fs) (x `map` f) in map
13:55:10 <lambdabot> (t -> a) -> [t] -> [a]
14:04:30 <__xc> ah ok ;)
14:05:42 <tootsie> > take 3 [1,2]
14:05:44 <lambdabot>   [1,2]
14:06:04 <__xc> > drop 3 [1,2]
14:06:06 <lambdabot>   []
14:07:51 <tootsie> > drop 3 [1..10]
14:07:53 <lambdabot>   [4,5,6,7,8,9,10]
14:08:21 <tootsie> > let xs = [1..10] in sum xs / length xs
14:08:23 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:08:23 <lambdabot>    arising from a use o...
14:08:32 <tootsie> ?
14:08:45 <tootsie> also, what would I use if i need haskell?
14:08:50 <tootsie> also, what would I use if i need arrays in haskell?
14:09:17 <ab9rf> tootsie: you needed parentheses on that last example
14:09:25 <Taneb> If you need Haskell, you'd use Haskell
14:09:30 <shachaf> ab9rf: ?
14:09:35 <Taneb> If you need arrays in Haskell, you'd use arrays
14:09:37 <Taneb> They exist
14:09:37 <ab9rf> no, sorry, not parentheses, a type tag
14:09:42 <monoidal> ab9rf: actually parens won't change
14:09:49 <shachaf> ab9rf: ?
14:09:54 <ab9rf> :t sum [1..10]
14:09:55 <lambdabot> (Enum a, Num a) => a
14:09:59 <ab9rf> :t length [1..10]
14:10:00 <lambdabot> Int
14:10:01 <monoidal> > let xs = [1..10] in fromIntegral (sum xs) / fromIntegral (length xs)
14:10:03 <ab9rf> :t (/)
14:10:03 <lambdabot>   5.5
14:10:04 <lambdabot> Fractional a => a -> a -> a
14:10:26 <ab9rf> (/) doesn't have an instance that includes Int
14:10:46 <shachaf> Right. So you need a function to convert, or something.
14:11:02 <ab9rf> or use div :)
14:11:14 <ab9rf> although that might not yield the desired result
14:12:21 <ab9rf> tootsie: anyway, haskell has array constructs.  but you might not need arrays; just because you'd use arrays in some other language doesn't mean you'd use them in haskell.
14:12:55 <tootsie> so average would have the type: avg :: [Int] -> Maybe Double?
14:13:03 <tootsie> since you could pass []
14:13:06 <tootsie> for 0/0
14:13:20 <monoidal> tootsie: yes, that's a good type
14:13:38 <monoidal> tootsie: alternatively, avg :: Fractional a => [a] -> Maybe a
14:13:55 <ab9rf> monoidal: is Int an instance of Fractional?
14:14:00 <monoidal> ab9rf: no
14:14:02 <tomberek> nope
14:14:03 <ab9rf> didn't think so
14:14:31 <monoidal> the point is, the caller has to do the conversion. it's better to leave it to him, rather than do it inside the function
14:14:44 <ab9rf> agreed.
14:14:59 <ab9rf> taking the average of integers doesn't inherently make sense
14:15:11 <tromp_> :t <$
14:15:13 <lambdabot> parse error on input `<$'
14:15:19 <tromp_> :t <*
14:15:21 <lambdabot> parse error on input `<*'
14:15:23 <ab9rf> :t (<$)
14:15:24 <lambdabot> Functor f => a -> f b -> f a
14:15:25 <monoidal> :t (<$) -- tromp_
14:15:26 <lambdabot> Functor f => a -> f b -> f a
14:15:30 <tromp_> ah, yes:)
14:16:15 <__xc> > fromIntegral (2 R.% 1)
14:16:16 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio a0))
14:16:16 <lambdabot>    arising from a u...
14:16:48 <merijn> __xc: Rationals aren't integrals :p
14:17:19 <merijn> :t fromIntegral
14:17:21 <lambdabot> (Integral a, Num b) => a -> b
14:17:32 <merijn> :t 2 R.% 1
14:17:33 <lambdabot> Integral a => Ratio a
14:17:50 <__xc> > (2 R.% 1) :: Int
14:17:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:17:51 <lambdabot>              with actual type ...
14:18:01 <merijn> __xc: That's a type error too
14:18:03 <latro`a> > (2 R.% 1) :: Ratio Int
14:18:04 <ab9rf> you can't foce a ratio to an int
14:18:04 <lambdabot>   2 % 1
14:18:31 <ab9rf> > R.approxRational (2 R.% 1)
14:18:33 <lambdabot>   *Exception: show: No overloading for function
14:18:47 <__xc> > round  (2 R.% 1)
14:18:48 <lambdabot>   2
14:19:09 <adzeitor> fromRational $ 61 % 8
14:19:26 <merijn> adzeitor: Forgot the leading "> "
14:19:34 <adzeitor> > fromRational $ 61 % 8
14:19:36 <lambdabot>   Not in scope: `%'
14:19:36 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
14:19:41 <adzeitor> > fromRational $ 61 R.% 8
14:19:43 <lambdabot>   7.625
14:19:52 <merijn> :t fromRational
14:19:53 <lambdabot> Fractional a => Rational -> a
14:20:16 <ab9rf> haskell has way more numeric types than most languages, for some funny reason :)
14:21:15 <ab9rf> > R.approxRational 7.625
14:21:17 <lambdabot>   *Exception: show: No overloading for function
14:21:26 <ab9rf> bah, no show for ratios, i hat eyou
14:21:50 <magicman> @type R.approxRational
14:21:51 <lambdabot> RealFrac a => a -> a -> Rational
14:21:52 <shachaf> ab9rf: Look again!
14:21:57 <tromp_> hmm, what is the empty parser called in Parsec?
14:21:58 <ab9rf> oh, right, there's a second argument
14:22:09 <ab9rf> it wants an epsilon
14:22:22 <ab9rf> > R.approxRational 7.625 0.0001
14:22:24 <lambdabot>   61 % 8
14:22:41 <ab9rf> it would be vaguely nicer if those were flipped
14:22:44 <ab9rf> although i suppose not
14:23:02 <ab9rf> since the choice of epsilon depends to a degree on the number being approximated
14:23:23 <__xc> o great ^
14:23:30 <monoidal> tromp_: parsec is an instance of Alternative, right? so you can check :i Alternative
14:23:37 <tdammers> hmm, I wonder...
14:23:46 <tdammers> > R.approxRational 1 100.0
14:23:48 <__xc> > R.approxRational 1.333 0.0001
14:23:48 <lambdabot>   0 % 1
14:23:49 <lambdabot>   1029 % 772
14:24:05 <adzeitor> > R.approxRational 7.625 0.1
14:24:06 <lambdabot>   23 % 3
14:24:32 <tdammers> > R.approxRational 1 -1
14:24:32 <ab9rf> > R.approxRational 1 2
14:24:34 <lambdabot>   *Exception: show: No overloading for function
14:24:34 <lambdabot>   can't find file: L.hs
14:24:44 <tdammers> > R.approxRational 1 -1
14:24:45 <ab9rf> > R.approxRational 1.0 2.0
14:24:46 <lambdabot>   *Exception: show: No overloading for function
14:24:47 <lambdabot>   0 % 1
14:24:48 <tromp_> thx, monoidal
14:24:49 <monoidal> tdammers: that was parsed as (R.approxRational 1) - 1
14:24:56 <tdammers> oh wait, yeah
14:24:59 <tdammers> > R.approxRational 1 (-1)
14:25:01 <lambdabot>   0 % 1
14:25:32 <ab9rf> 0%1 is the "simplest" rational
14:25:45 <__xc> > R.approxRational 1 1
14:25:47 <lambdabot>   0 % 1
14:25:47 <ab9rf> if 0 is in the epsilon interval of the argument you wil get 0%1
14:25:53 <__xc> > R.approxRational 1 0.1
14:25:55 <lambdabot>   1 % 1
14:26:34 <ab9rf> you're not guaranteed the _closest_ rational, just the _simplest_
14:26:37 <__xc> > R.approxRational pi 0.0001
14:26:39 <lambdabot>   333 % 106
14:27:13 <int-e> > let rats = 0 : (rats >>= \x -> [x+1, 1/(x+1)] in rats :: [Rational]
14:27:15 <lambdabot>   <hint>:1:47: parse error on input `in'
14:27:22 <ab9rf> i'm not sure that the simplest role creates a total ordering
14:27:26 <ab9rf> er, rule
14:27:42 <int-e> > let rats = 0 : (rats >>= \x -> [x+1, 1/(x+1)]) in rats :: [Rational]
14:27:44 <lambdabot>   [0 % 1,1 % 1,1 % 1,2 % 1,1 % 2,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 ...
14:29:11 <ab9rf> cute
14:29:17 <int-e> ok, need to start at 1 and leave 0 as an exceptional case.
14:29:19 <tootsie> moving average filters and lists are not a good match, how do I use arrays in haskell?
14:31:37 * __xc has no idea how's the rat's thing is working
14:32:18 <parcs> tootsie: have you tried using Data.Sequence?
14:32:37 <x_x> Is it possible to convert Maybe (IO ()) to IO () ?
14:32:43 <x_x> I want to use (fmap print)
14:32:45 <parcs> tootsie: it provides O(1) uncons and unsnoc
14:33:09 <tdammers> parcs: I read that as "it provides O(1) unicorns"
14:33:18 <tdammers> I want O(1) unicorns now.
14:33:30 <int-e> __xc: I think of it as doing the additive version of Euclid's algorithm in reverse. (which is: if a > b, subtract b from a; if b > a, subtract a from b; when a = b, that's the gcd of a and b)
14:33:37 <tootsie> Sequence has O(1) access?
14:33:46 <monoidal> x_x: you probably want fromMaybe (return ())
14:33:52 <parcs> yeah Seq is essentially magic
14:33:54 <int-e> __xc: and 1 = 1/1 represents a=b=1, with gcd 1.
14:34:00 <monoidal> x_x: i.e. case ... of Nothing -> return (); Just a -> a
14:34:49 <ab9rf> O(1) unicorns for everyone!
14:34:54 <x_x> monoidal: aha, indeed that works! I was wondering whether it was possible to do m (IO ()) to IO () in general - for monads m.
14:35:15 <x_x> monoidal: or what conditions are required on m to do this operation.
14:35:22 <monochrom> O(1)corns
14:35:33 <tootsie> arent there any real arrays?
14:35:33 <__xc> int-e, yes gotta plays with bot to understand the monadic thing
14:35:37 <int-e> what's a multicorn?
14:35:38 <monochrom> afterall, uni is already O(1)
14:35:47 <ab9rf> tootsie: what do yu mea by a "real array"?
14:36:04 <tootsie> constant access
14:36:06 <parcs> tootsie: yes there are. see Data.Array
14:36:33 <ab9rf> tootsie: what are you trying to do?
14:36:46 <parcs> ab9rf: moving average, it seems
14:36:50 <monochrom> if you have Haskell Platform, you can also try Data.Vector etc
14:37:29 <monoidal> x_x: Data.Foldable.sequence_
14:37:49 <ab9rf> i thought moving average could be done with accumulators
14:38:07 <monoidal> x_x: that works if m is anything foldable, and instead of IO you can have any monad
14:38:12 <monochrom> if you have merely 10000 elements, you can use a list, which is O(10000) access, but O(10000)=O(1)
14:38:15 <monoidal> x_x: m need not be a monad
14:38:27 <monoidal> x_x: for starters, see sequence_ and sequence (in Prelude)
14:38:40 <monoidal> > sequence [Just 3, Just 4] -- x_x
14:38:42 <lambdabot>   Just [3,4]
14:38:45 * monochrom likes to mess with your minds!
14:38:45 <ab9rf> you don't need to keep the entire data stream, just as many elements as are used for the moving average window, plus the sum
14:39:00 <x_x> monoidal: oh wow, that's sweet. I should have guessed something like this might exist just from [IO a] to IO [a] of sequence.
14:39:15 <Taneb> > sequence [Just 3, Nothing]
14:39:16 <x_x> monoidal: I was looking in functors - wrong superclass of [].
14:39:17 <lambdabot>   Nothing
14:39:26 <Taneb> > foldr mplus [Just 3, Nothing]
14:39:28 <lambdabot>   *Exception: show: No overloading for function
14:39:29 <ab9rf> at each step, you take the last element off the window, subtract it from the sum, add the next value to the sum and the window, and report the adverage
14:39:33 <Taneb> > foldr mplus Nothing [Just 3, Nothing]
14:39:35 <lambdabot>   Just 3
14:39:46 <ab9rf> for exponential decay you don't even need that
14:39:47 <shachaf> x_x: t (m a) -> m (t a) is Traversable
14:40:01 <shachaf> Where m is a Monad, t is a Traversable
14:40:21 <monoidal> x_x: if you have some time to spare, I recommend reading typeclassopedia <http://www.haskell.org/haskellwiki/Typeclassopedia> which describes many similar classes
14:41:10 <x_x> monoidal: is that the one by byorgey? it's 404'ing - but I'm sure I've seen it before.
14:41:32 <x_x> monoidal: nvm. broken parsing on the web client.
14:41:45 <monoidal> x_x: yes, it's by him
14:42:03 <monoidal> there's a section on Foldable and Traversable
14:42:10 <int-e> > let xs = [sin x | x <- [0,0.1..]]; ma n xs = let (xs0,xs1) = splitAt n xs in map (/fromIntegral n) $ scanl (\x (y,z) -> x-y+z) (sum xs0) (zip xs xs1) in ma 100 xs
14:42:11 <lambdabot>   can't find file: L.hs
14:42:24 <__xc> > let rats = 0 : (rats >>= \x -> [x+1, x+2]) in take 10 rats
14:42:26 <lambdabot>   [0,1,2,2,3,3,4,3,4,4]
14:43:16 <__xc> > let rats = 0 : (rats >>= \x -> [x+1]) in take 10 rats
14:43:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
14:43:26 <x_x> shachaf: thanks! I will try to figure out now why if a Foldable is a Functor, it has sequence - but otherwise it has just sequence_. It'll probably be a nice exercise.
14:43:47 <int-e> anyway there's your typical moving average code (which will accumulate some rounding errors over time) without horrible !!n costs.
14:43:54 <tootsie> what is the diff betweeen int and integer
14:43:55 <tootsie> ?
14:44:27 <startling> tootsie: "Int" is a machine integer; "Integer" is an unbounded bigint
14:44:30 <shachaf> x-x: Traversable ~ sequence, Foldable ~ sequence_
14:44:53 <x_x> shachaf: exactly. Foldable+Functor => Traversable.
14:44:54 <ion> Int is something that shouldn’t have been in Prelude in the first place IMNSHO.
14:45:20 <int-e> purists... :P
14:45:59 <int-e> next you'll say that giving Double an Eq instance was a bad idea, never mind its Ord or Num instances.
14:46:03 <tootsie> what is the naming convention for helper functions+
14:46:25 <tootsie> like a recursive function with an extra param called by the opriginal function
14:46:32 <monoidal> tootsie: go
14:46:58 <int-e> yeah, 'go' is common for worker loops.
14:47:33 <ion> > (pi :: Double) == pi  -- Eq Double works just fine.
14:47:34 <lambdabot>   True
14:47:52 <monoidal> ion: what about NaN...?
14:47:59 <Taneb> > (0/0) == (0/0)
14:48:01 <int-e> > (0/0) == (0/0)
14:48:01 <lambdabot>   False
14:48:02 <lambdabot>   False
14:48:05 <startling> instance Num [Bool] where ...
14:48:08 <Taneb> > (1/0) == (1/0)
14:48:10 <lambdabot>   True
14:48:10 <ion> monoidal: Their evilness is within Double, not Eq. :-P
14:48:32 <tootsie> so you cant pass an Int to take....
14:48:50 <startling> tootsie: there's a thing in Data.List
14:48:54 <int-e> > (1/3 + 1/3 + 1/3) == (1+1+1)/3
14:48:55 <mikeplus64> tootsie: use fromInteger/fromIntegral
14:48:56 <lambdabot>   True
14:49:00 <startling> :t take
14:49:02 <lambdabot> Int -> [a] -> [a]
14:49:06 <startling> tootsie: ^ actually, you can
14:49:24 <startling> tootsie: (but it doesn't make much sense)
14:49:25 <mikeplus64> tootsie: take (fromIntegral something) xs
14:49:34 <startling> mikeplus64: that's not very good
14:49:39 <__xc>  rats = 0 : (rats >>= \x -> [x+1]) -- it initializes itself with 0?
14:49:53 <__xc> [0]*
14:49:54 <monoidal> mikeplus64: genericTake
14:49:58 <startling> ^ yeah
14:50:15 <mikeplus64> > maxBound :: Int
14:50:17 <startling> mikeplus64's code will fail if the integer is bigger than machine ints allow
14:50:17 <lambdabot>   9223372036854775807
14:50:28 <mikeplus64> i think once you've gotten that many elements in a list you've got problems
14:50:32 <mikeplus64> > 2^28
14:50:33 <lambdabot>   268435456
14:50:33 <merijn> __xc: For more amazement
14:50:42 <shachaf> __xc: The list [0] is never in existence at any point.
14:50:43 <int-e> __xc: the first element is 0. so rats >>= foo  will invoke foo 0, and append that to the list. Now in your example, that means that the list now starts with 0, then 1. So next, foo will be invoked with 1. etc.
14:50:51 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:50:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:51:20 <monoidal> or simply, let f = 0:f  - there's never [0] here
14:51:28 <startling> mikeplus64, uhhh
14:51:46 <startling> mikeplus64, I've used many lists longer than maxBound
14:51:52 <int-e> __xc: and as shachaf says, this all happens in the same list; it's just that the list has a tail that has yet to be evaluated. That's the nature of lazy evaluation.
14:52:29 <startling> mikeplus64: like 'fibs' up there
14:52:32 <__xc> ok
14:53:37 <mikeplus64> startling: 9223372036854775807 elements? really?
14:53:37 <startling> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! maxBound
14:53:46 <lambdabot>   mueval: Prelude.undefined
14:53:56 <startling> mikeplus64, lists can be infinite.
14:54:16 <__xc>  > let rats = 0 : (rats >>= \x -> [x+1])  in rats !! 2
14:54:24 <adzeitor> > let p[Drog = 1:map succ prog in prog
14:54:25 <__xc> > let rats = 0 : (rats >>= \x -> [x+1])  in rats !! 0
14:54:27 <lambdabot>   0
14:54:27 <lambdabot>   can't find file: L.hs
14:54:33 <__xc> > let rats = 0 : (rats >>= \x -> [x+1])  in rats !! 1
14:54:34 <lambdabot>   1
14:54:36 <startling> though that 'Prelude.undefined' is pretty weird.
14:54:47 <mikeplus64> startling: but in the case of fibs it will just keep growing
14:54:50 <adzeitor> > let prog = 1:map succ prog in prog
14:54:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:54:51 <__xc> > let rats = 0 : (rats >>= \x -> [x+1])  in rats !! 2
14:54:53 <lambdabot>   2
14:55:00 <startling> > repeat 'a' !! maxBound
14:55:05 <merijn> startling: I think it doesn't know which maxBound to pic?
14:55:06 <lambdabot>   mueval: ExitFailure 1
14:55:06 <lambdabot>  mueval: Prelude.undefined
14:55:27 <startling> merijn, take isn't polymorphic though
14:55:27 <ion> @type (!!)  -- it does
14:55:30 <lambdabot> [a] -> Int -> a
14:55:36 <startling> err, neither is (!!)
14:55:39 <ion> And if it wouldn’t, that would be a compile-time error.
14:55:51 <monoidal> hm, the Prelude.undefined error looks really weird. might be a bug in mueval
14:55:54 <startling> ion, it could be a mueval error
14:56:35 <__xc> adzeitor,  elegant
14:57:25 <startling> anyway, there's literally no reason to use take . fromIntegral rather than genericTake
14:58:08 <startling> @src take
14:58:09 <lambdabot> take n _      | n <= 0 =  []
14:58:09 <lambdabot> take _ []              =  []
14:58:09 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:58:10 <adzeitor> __xc: tnx... I'm trying to get work rats without >>=  concatmap...
14:58:11 <Kinnison> bleh, I have a list of the type [(a, Maybe b)]
14:58:18 <Kinnison> is there an easy way I can lift catMaybes to behave?
14:58:19 <startling> ^ no reason for that to be restricted to Int, either
14:58:35 <startling> Kinnison, what are you trying to do?
14:58:56 <Kinnison> startling: [(a, Maybe b)] -> [(a, b)] where any Nothings remove the entire tuple
14:58:56 <ab9rf> Kinnison: what do you want insead of that list?
14:59:03 <ab9rf> ah
14:59:24 <ion> @type \xs -> [ (a,b) | (a, Just b) <- xs]
14:59:24 <startling> Kinnison: filter (isNothing . snd)
14:59:25 <lambdabot> [(t, Maybe t1)] -> [(t, t1)]
14:59:53 <startling> ion: :/
14:59:54 <ab9rf> i think ion's bakes the cake
15:00:20 <startling> > let ion xs = [ (a,b) | (a, Just b) <- xs] in ion [Nothing]
15:00:22 <ab9rf> @pl \xs -> [(a,b) | (a, Just b) <- xs]
15:00:22 <lambdabot> return . (((a, b) | (a, Just b)) <-)
15:00:23 <lambdabot>   Couldn't match expected type `(t0, Data.Maybe.Maybe t1)'
15:00:23 <lambdabot>              with ...
15:00:37 <startling> er
15:00:44 <ab9rf> startling: your lis tis the wrong type
15:00:49 <startling>  > let ion xs = [ (a,b) | (a, Just b) <- xs] in ion [(1, Nothing)]
15:00:50 <ab9rf> needs to be [((), Nothing)]
15:00:58 <startling> > let ion xs = [ (a,b) | (a, Just b) <- xs] in ion [(1, Nothing)]
15:01:01 <lambdabot>   []
15:01:20 <startling> > let ion xs = [ (a,b) | (a, Just b) <- xs] in ion [(1, Nothing), (2, Just 'a')]
15:01:22 <lambdabot>   [(2,'a')]
15:01:26 <startling> oh, huh.
15:01:38 <Kinnison> me has to admit he was expecting something magical with Control.Arrow
15:01:38 <monoidal> is there (a, Maybe b) -> Maybe (a,b) somewhere?
15:01:49 <ab9rf> :t return . (((a,b) | (a Just b)) <-)
15:01:50 <Kinnison> something as understandable as a list comprehension is unexpected
15:01:50 <lambdabot> parse error on input `|'
15:01:54 <ab9rf> though so
15:01:56 <startling> it's just liftSnd (a, b) = (,) a <$> b
15:02:04 <ab9rf> i guess @pl doesn't cope with list comprehensions :)
15:02:13 <hpc> monoidal: something in Foldable
15:02:19 <monoidal> yeah
15:02:34 <ab9rf> @hoogle (a, Maybe b) -> Maybe (a,b)
15:02:35 <lambdabot> No results found
15:03:26 <adzeitor> > let rats2 = 0 : (concatMap (\x -> [x+1, 1/(x+1)]) rats2) :: [Rational] in rats2
15:03:27 <lambdabot>   [0 % 1,1 % 1,1 % 1,2 % 1,1 % 2,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 ...
15:03:36 <ion> @type catMaybes . map sequence
15:03:37 <lambdabot> [[Maybe a]] -> [[a]]
15:03:49 <ion> @type catMaybes . map Data.Traversable.sequence
15:03:51 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
15:04:04 <monoidal> but (a,) is not Traversable
15:04:05 <ion> > (catMaybes . map Data.Traversable.sequence) [("foo", Nothing), ("bar", Just 42)]
15:04:08 <lambdabot>   [("bar",42)]
15:04:23 <monoidal> oh, it is? I must be missing an instance
15:04:54 <startling> > _2 id (1, Just 2)
15:04:56 <lambdabot>   Just (1,2)
15:05:11 <merijn> monoidal: It's been suggested on libraries@ in the past, dunno why it hasn't been added yet
15:05:47 <startling> I think I just won "Most Evil Use For Lenses".
15:05:51 * Kinnison giggles
15:05:56 <ion> Oh, huh. instance Traversable ((,) b)
15:05:57 <__xc> > let f = [0 , 1] : (f >>= \[x,y]-> [x+y] )  in concat f
15:05:58 <ion>   -- Defined in `Control.Lens.Internal.Instances'
15:05:59 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
15:06:03 <hpc> startling: nicely done
15:06:21 <ion> I didn’t realize/remember that Lens provides orphan instances for Traversable.
15:06:26 <monoidal> @type catMaybes . map (uncurry (fmap . (,)))
15:06:28 <lambdabot> [(a, Maybe a1)] -> [(a, a1)]
15:06:29 <int-e> adzeitor: I made a mistake initially; if you replace 0 by 1 there, the list will not contain any duplicates. :)
15:06:59 <startling> > traverse id (1, Just 2) -- works too
15:07:01 <lambdabot>   Just (1,2)
15:07:21 <__xc> > let f = [0 , 1] : (f >>= \[x,y]-> [x,x+y] )  in concat f  --should fib
15:07:22 <hpc> :t traverse `asTypeOf` _2
15:07:22 <monoidal> > sequence (1, Just 2) -- startling
15:07:23 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
15:07:24 <lambdabot> (Applicative f, Traversable t, Field2 (t a) (t b) a b) => (a -> f b) -> t a -> f (t b)
15:07:24 <lambdabot>   can't find file: L.hs
15:08:10 <monoidal> > sequenceA (1, Just 2)
15:08:11 <lambdabot>   Not in scope: `sequenceA'
15:08:12 <lambdabot>  Perhaps you meant one of these:
15:08:12 <lambdabot>    `Data.Travers...
15:08:22 <ion> startling: Yeah, sequenceA = traverse id
15:08:23 <monoidal> > Data.Traversable.sequenceA (1, Just 2)
15:08:25 <lambdabot>   Just (1,2)
15:08:30 <startling> neat.
15:08:43 <__xc> > let f = [0 , 1] : (f >>= \[x,y]-> [[x,y][y,x+y]] )  in concat f  --should fib
15:08:45 <lambdabot>   The function `[x, y]' is applied to one argument,
15:08:45 <lambdabot>  but its type `[t0]' has ...
15:08:50 <adzeitor> > let rats = 1 : (rats >>= \x -> [x+1, 1/(x+1)]) in rats :: [Rational]
15:08:52 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
15:09:13 <monoidal> > let f = [0 , 1] : (f >>= \[x,y]-> [[x,y],[y,x+y]] )  in concat f
15:09:15 <lambdabot>   [0,1,0,1,1,1,0,1,1,1,1,1,1,2,0,1,1,1,1,1,1,2,1,1,1,2,1,2,2,3,0,1,1,1,1,1,1,...
15:09:21 <__xc> > let f = [0 , 1] : (f >>= \[x,y]-> [[x,y],[y,x+y]] )  in concat f  --should fib
15:09:22 <lambdabot>   [0,1,0,1,1,1,0,1,1,1,1,1,1,2,0,1,1,1,1,1,1,2,1,1,1,2,1,2,2,3,0,1,1,1,1,1,1,...
15:09:36 <adzeitor> int-e: nice :D
15:09:40 <__xc> not exactly fib :)
15:09:49 <Ontolog> hey guys im using ghci to learn me a haskell. i want to write a module and then import it in ghci. i have a file called Traffic.hs in the current directory, but import Traffic doesn't look for this file. Is there like an env var i can set or something?
15:10:09 <startling> Ontolog, it needs to have "module Traffic where" at the top
15:10:17 <Ontolog> startling: got that part
15:10:33 <startling> Ontolog: then you can :cd to the appropriate directory
15:10:38 <__xc> > let f = [0 , 1] : (f >>= \[x,y]-> [[y,x+y]] )  in concat f
15:10:40 <lambdabot>   [0,1,1,1,1,2,2,3,3,5,5,8,8,13,13,21,21,34,34,55,55,89,89,144,144,233,233,37...
15:10:47 <monoidal> >  let f = (0 , 1) : (fmap (\(x,y)-> (y,x+y)) f )  in take 10 f
15:10:47 <Ontolog> startling: i ran ghci from that directory
15:10:49 <lambdabot>   [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55)]
15:10:51 <merijn> Ontolog: I usually start ghci in the directory with the file and then do ":l filename.hs"
15:10:51 <ion> Try “:load Traffic.hs” or “ghci Traffic.hs” in the shell.
15:10:59 <monoidal> >  let f = (0 , 1) : (fmap (\(x,y)-> (y,x+y)) f )  in map fst f  -- __xc
15:10:59 <startling> Ontolog: what's the error you're getting?
15:11:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:11:12 <Ontolog> merijn: yeah that works but i want to know how to get import to work
15:11:21 <hpc> Ontolog: i run "ghci path/to/file.hs"
15:11:31 <__xc> monochrom, yes
15:11:31 <parcs> @src e
15:11:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:11:36 <Ontolog> startling: could not find module Traffic
15:11:37 <hpc> testing as you describe with just import, it doesn't work for me either
15:11:40 <Ontolog> ok myabe i should ask more generally
15:11:45 <parcs> @where e
15:11:45 <lambdabot> I know nothing about e.
15:11:47 <Ontolog> how do I setup my search path for modules?
15:11:53 <monoidal> > __xc: Prelude.iterate is better for this purpose
15:11:55 <lambdabot>   Not in scope: `__xc'Not in scope: `is'
15:11:55 <lambdabot>  Perhaps you meant one of these:
15:11:55 <lambdabot>    ...
15:11:57 <Ontolog> ala CLASSPATH in Java or RUBYLIB in Ruby
15:12:13 <startling> weird, I didn't realize 'import' in GHCI doesn't work for local modules.
15:12:36 <parcs> Ontolog: you can't use 'import' to load a source file in ghci
15:12:43 <Ontolog> oh
15:12:49 <Ontolog> interesting
15:12:51 <ion> If you use cabal-dev ghci, it will work for anything seen by yourpackage.cabal
15:13:03 <Ontolog> ion: i don't understand what that means
15:13:15 <Ontolog> im a complete noob
15:13:18 <byorgey> it's not really relevant at this point
15:13:34 <Ontolog> there must be a way to append to the default module search path
15:13:37 <ion> ontolog: You don’t need to at this point. :load should be enough for learning purposes.
15:13:49 <tootsie> so should the first point of an n-point mafilter on the input [1,2,3,4,5] and n=3 be 1 or 2?
15:13:50 <Ontolog> is this like forbidden knowledge or something?
15:14:18 <tootsie> whats the O() of the mafilter given above?
15:14:22 <merijn> Ontolog: Basically import in ghci only works with installed (and compiled) libraries. Which is a bunch of stuff to learn which is probably not immediately interesting right now
15:14:26 <ion> I don’t think import looks for .hs files in any path.
15:14:58 <Ontolog> merijn: ohhhhh..... ok fair enough
15:15:14 <Ontolog> just wondering, if i had a "project" that contained libraries and such
15:15:22 <Ontolog> and scripts that depended on those libraries
15:15:22 <tootsie> can I lazily check a list for a cond and immediately abort if it is true?
15:15:28 <Ontolog> would i need to install all of that into the system?
15:15:40 <genisage> I think you can change where ghci looks for files with the -i option.
15:15:50 <ion> ontolog: At that point, cabal-dev ghci should be useful. But you don’t need to learn about that just yet, i think.
15:15:52 <Ontolog> genisage: thanks
15:15:53 <tootsie> > let failed xs = or (==Nothing )[Just 5, Nothing]
15:15:55 <lambdabot>   not an expression: `let failed xs = or (==Nothing )[Just 5, Nothing]'
15:15:58 <merijn> Ontolog: Usually you'd use cabal to install libraries and check dependencies, etc.
15:16:05 <tootsie> > let failed xs = or (==Nothing ) in failed [Just 5, Nothing]
15:16:05 <Ontolog> i see
15:16:07 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
15:16:07 <lambdabot>              with actual ty...
15:16:16 <Ontolog> cool guys thanks a bunch for your help, now back to the book :)
15:16:19 <tootsie> @type or
15:16:21 <lambdabot> [Bool] -> Bool
15:16:26 <tootsie> @type any
15:16:28 <lambdabot> (a -> Bool) -> [a] -> Bool
15:16:32 <merijn> Ontolog: Cabal is not very hard to learn, but I'd usually recommend just doing something simple using :l first and then once you start branching out to more complex things, learn cabal then.
15:16:35 <Iceland_jack> tootsie: You may want msum
15:16:37 <tootsie> > let failed xs = any (==Nothing ) in failed [Just 5, Nothing]
15:16:39 <ion> ontolog: That is, as an alternative to “cabal install”ing development versions of the project.
15:16:39 <lambdabot>   *Exception: show: No overloading for function
15:16:47 <merijn> Ontolog: Otherwise you spend some time reading boring docs, rather than learning cool haskell stuff ;)
15:16:57 <Iceland_jack> > msum [Just 1, Just 2, Nothing, Just 4, Just 5]
15:17:00 <lambdabot>   Just 1
15:17:07 <Iceland_jack> no sorry, sequence
15:17:09 <Iceland_jack> > sequence [Just 1, Just 2, Nothing, Just 4, Just 5]
15:17:11 <lambdabot>   Nothing
15:17:14 <Ontolog> true that, thanks for keeping me focused :) i tend to go off on tangents
15:17:42 <tootsie> > let failed = any (==Nothing ) in failed [Just 5, Nothing]
15:17:44 <lambdabot>   True
15:18:27 <Ontolog> are all data types exported by a module by default?
15:18:37 <adzeitor> > any isNothing [Just 5, Nothing]
15:18:37 <Ontolog> i thought I needed to explicitly specify those
15:18:38 <lambdabot>   True
15:18:53 <startling> Ontolog: everything is exported unless you do "module X (blah, ...) where"
15:19:03 <Ontolog> ahhh
15:19:09 <Ontolog> thanks
15:19:11 <startling> Ontolog: in which case only 'blah' and '...' are exported
15:19:23 <Ontolog> got it
15:19:32 <parcs> tootsie: use isNothing instead of == Nothing -- the latter requires a superfluous Eq constraint
15:19:58 <tootsie> > fromJust $ Just 5
15:20:00 <lambdabot>   5
15:20:06 <tootsie> @src catMaybes
15:20:06 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:20:13 <startling> > Just (\a -> a) == Nothing -- tootsie
15:20:14 <tootsie> > fromJust nothing
15:20:15 <lambdabot>   False
15:20:17 <lambdabot>   Not in scope: `nothing'
15:20:23 <startling> wut
15:20:23 <lewis1711> http://www.haskell.org/hoogle/?hoogle=Monad+m+%3D%3E+m+a+-%3E+a is there some fundamental reason why this doesn't exist?
15:20:29 <tootsie> > fromJust Nothing
15:20:31 <lambdabot>   *Exception: Maybe.fromJust: Nothing
15:20:37 <__xc> > "haslell"  >>= (\x -> [succ x])  -- when you don't like map
15:20:38 <startling> is there an Eq instance for (a -> b) somewhere.
15:20:39 <lambdabot>   "ibtmfmm"
15:20:41 <ion> If you find yourself using isNothing it’s likely there’s a better way to do whatever you’re doing.
15:20:45 <startling> > id == id
15:20:47 <lambdabot>   *Exception: (==): No overloading for function
15:20:55 <startling> > (\a -> a) == (\a -> a)
15:20:58 <lambdabot>   *Exception: (==): No overloading for function
15:21:09 <startling> > Just id == Nothing
15:21:11 <lambdabot>   False
15:21:13 <startling> wtf
15:21:16 <tootsie> @hoogle catmaybes
15:21:16 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
15:21:24 <ion> lewis1711: How would you convert an IO String to String? How about Parser Integer to Integer?
15:21:26 <tootsie> where is it ?
15:21:26 <monoidal> startling: there should be somewhere on hackage for finite a, or if you search more, for compact a
15:21:27 <hpc> startling: in that case, it isn't using the (==) instance
15:21:37 <hpc> startling: follow it like any other evaluation
15:21:42 <hpc> Nothing == Just _ = False
15:21:53 <ion> lewis1711: There are other monads than just containers of a single value.
15:21:55 <startling> > Just id == Just id
15:21:56 <lambdabot>   *Exception: (==): No overloading for function
15:22:23 <startling> hpc: sure, but that's assuming there's an instance Eq (Maybe (a -> b))
15:22:42 <hpc> startling: there is
15:22:43 <lewis1711> ion: well converting IO String to a string would surely just be.. the string
15:22:45 <startling> which there seems to be. that's crazy.
15:22:49 <hpc> Eq a => Eq (Maybe a)
15:22:52 <tntc> I'm a haskell noob, running through Learn Me a Haskell for Great Good. Any suggestions for how to gain a better understanding of the language? I know some python, java, C, C++, Obj-C, and Common Lisp. Haskell just seems...better.
15:23:01 <startling> hpc, there's no Eq (a -> b), though
15:23:02 <hpc> there's an instance for (a -> b), as much of a non-instance as it is
15:23:05 <ion> lewis1711: There is no such a thing as “the string” in an IO String.
15:23:17 <hpc> :t \x -> id == x
15:23:19 <lambdabot> (a -> a) -> Bool
15:23:21 <tntc> Learn You*
15:23:23 <startling> lewis1711: an IO String is a set of instructions to get a string
15:23:29 <startling> hpc: ah
15:23:40 <startling> still, crazy.
15:23:41 <lewis1711> I see
15:23:41 <hpc> startling: (==) _ _ = error "blahblah"
15:23:51 <hpc> it has some unfortunate consequences, yes
15:23:52 <ion> lewis1711: IO String represents a computation that can be executed to generate a string. /bin/ls represents a computation that can be executed to generate a list of files.
15:23:55 <startling> hpc: :/
15:24:50 <lewis1711> actually I don't see. fmap can run these instructions and go inside of it to apply a function
15:24:56 <startling> lewis1711: nah
15:25:14 <startling> lewis1711, fmap just says "when you get the string, remember to run this function on it"
15:25:28 <startling> (for IO, at least)
15:25:39 <ion> lewis1711: fmap f (something :: IO String) doesn’t run the IO action, it returns a new IO action that upon an execution in the future will apply f to the String that will be generated.
15:26:09 <hpc> lewis1711: in something like C, "this is a string" is not a value that prints to the screen when executed
15:26:15 <hpc> because it's not a thing that can be executed
15:26:16 <startling> lewis1711: let g = getLine in do getLine; getLine; -- this gets two different lines
15:26:16 <hpc> it's a string
15:26:34 <hpc> void printString() { print("this is a string"); }
15:26:53 <startling> er, I meant "let g = getLine in do g; g;"
15:26:53 <hpc> with that, printString is a value that prints to the screen when executed
15:26:57 <hpc> but it's not a String either
15:27:07 * hackagebot json-tools 0.5.0 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.5.0 (NicolasPouillard)
15:27:10 <hpc> it's a function of no arguments
15:27:34 <hpc> if haskell did not have an IO type and allowed arbitrary execution everywhere, printString would still not be a string
15:27:40 <hpc> it would be of type () -> String
15:27:47 <hpc> lewis1711: does that help you understand?
15:27:52 <adzeitor> tntc: keep running lyah, combine with project euler, try to write something useful
15:28:04 <Kinnison> :-)
15:28:07 <lewis1711> hpc: kind of. but at some point in this computation there's a string
15:28:15 <tootsie> so what is better. having mafilter returning [Maybe Double] or just let avg assume input is safe(lets make an avg function just for ma then) and let mafilter return Nothing if given [] else [Double]?
15:28:32 * applicative has done his duty today as member of the Revolutionary Committee for the Defense of Lazy IO, http://www.reddit.com/r/haskell/comments/1bsitm/lazy_io_breaks_equational_reasoning/c99whoo
15:28:33 <hpc> lewis1711: that's right
15:28:45 <Kinnison> Today my brain is definitely broken
15:28:55 <hpc> lewis1711: and we can't really bring things "out of IO", so we appear to be stuck
15:29:07 <Kinnison> is there a convenient way to form a [a] -> [a] -> Bool which return true if any element of the first list appears in the second list ?
15:29:07 <applicative> curse the renegade oleg!
15:29:14 <hpc> lewis1711: but what we can do is bring things "into IO"
15:29:26 <hpc> lewis1711: specifically, we will use (>>=)
15:29:38 <hpc> (>>=) takes a monadic action like your elusive (IO String)
15:29:52 <hpc> and it also takes a function of type (String -> IO SomethingElse)
15:29:52 <lewis1711> hpc: sure. I can do basic stuff with bind and all that, and no you can use the values
15:30:17 <lewis1711> I guess I just imagined fmap or liftM performing some kind of "get value out of IO action", and wondered what it was
15:30:23 <lewis1711> s/no/know
15:30:25 <monoidal> Kinnison: any (elem y) x
15:30:39 <hpc> that operation is inside (>>=) somewhere, if you need a place to put it
15:30:40 <monoidal> umm any (`elem` y) x
15:30:50 <lewis1711> hmm ok
15:30:51 <Kinnison> monoidal: gah, I *knew* there'd be something simple
15:30:57 <Kinnison> monoidal: I had 'any' even sat here
15:30:58 <hpc> and used so that you never have to know it is there
15:31:00 <Kinnison> monoidal: sigh, thanks
15:31:12 <startling> lewis1711, learning and reconstructing the Reader monad would be helpful at this point
15:31:32 <tntc> adzeitor: cool. I was rather impressed by the tools that are there for Haskell devs. Hoogle and Hackage and stuff. Too good for words.
15:33:27 <applicative> > 5 & (do { x <- (+1); y <- (+2); return (x + y)}
15:33:28 <lambdabot>   <hint>:1:48: parse error (possibly incorrect indentation)
15:33:38 <applicative> > 5 & (do { x <- (+1); y <- (+2); return (x + y)})
15:33:40 <lambdabot>   13
15:33:52 <applicative> ah, the real reader monad is in scope
15:34:56 <applicative> I'll take & over 'runReader' any day
15:34:59 <ion> > 5 & do { x <- (+1); y <- (+2); return (x + y)}
15:35:01 <lambdabot>   13
15:35:07 <ion> > 5 & do x <- (+1); y <- (+2); return (x + y)
15:35:09 <lambdabot>   13
15:35:20 <applicative> much better
15:46:26 <___xc> :t (+1)
15:46:27 <lambdabot> Num a => a -> a
15:46:39 <tootsie> @src sum
15:46:39 <lambdabot> sum = foldl (+) 0
15:46:58 <___xc> how is (+1) a monad?
15:47:08 * hackagebot monad-stm 0.1.0.0 - MonadSTM class analogous to MonadIO  http://hackage.haskell.org/package/monad-stm-0.1.0.0 (MiguelMitrofanov)
15:47:10 * hackagebot monad-stm 0.1.0.1 - MonadSTM class analogous to MonadIO  http://hackage.haskell.org/package/monad-stm-0.1.0.1 (MiguelMitrofanov)
15:47:36 <merijn> ___xc: The "(->) a" monad
15:47:45 <___xc> hmm
15:47:52 <___xc> ok
15:47:54 <parcs> (+1) :: Int -> Int, i.e. (+1) :: (->) Int Int
15:47:58 <monoidal> __xc: it's reader without newtype
15:48:21 <merijn> :t (>>=) `asAppliedTo` (+1)
15:48:22 <lambdabot> Num a => (a -> a) -> (a -> a -> b) -> a -> b
15:48:58 <__xc> > (do x <- (+1); y <- (+2); return (x + y)) 3
15:49:00 <lambdabot>   9
15:50:16 <__xc> > 5 & (+6)
15:50:18 <lambdabot>   11
15:50:55 <applicative> 5 & (+6) <*> (+7)
15:50:57 <__xc> 3
15:51:03 <merijn> __xc: Basically, if you have "(>>=) :: Monad m => m a -> (a -> m b) -> m b" and the monad instance of "(->) r" then you can replace the m with r ->, resulting in "(>>=) :: (r -> a) -> (a -> r -> b) -> r -> b"
15:51:10 <applicative> > 5 & (+6) <*> (+7)
15:51:12 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> b0
15:51:22 <applicative> > 5 & ((+6) <*> (+7))
15:51:24 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> b0
15:51:29 <applicative> oh
15:51:53 <applicative> > 5 & ((+) <$> (+7) <*> (+7))
15:51:55 <lambdabot>   24
15:52:12 <Fuco> I have a function paths :: ([char],[char]) -> ([char],[char]), I give it an initial value and it computes "next step". Now, after couple of iterations it won't change the input = it reaches a fix-point. Is there a way in haskell to let it "loop" until it hits the fixpoint?
15:52:16 <merijn> __xc: Meditate on thos type signatures until enlightenment is achieved :)
15:52:38 <Fuco> basically it calculates a transitive closure of sorts, and I need to stop it when all the things are added.
15:52:49 <merijn> Fuco: Will it never be the same until before the fixpoint?
15:52:55 <Fuco> no
15:53:02 <merijn> eh, until the fixpoint, I mean
15:53:27 <Fuco> in each step it modifies the output (it grows in size) and only stops at the fixpoint
15:53:30 <__xc> merijn, ok
15:53:46 <merijn> Because than you could just use iterate or something and recurse over the resulting list until you hit two consecutive values that are the same
15:53:49 <merijn> :t iterate
15:53:51 <lambdabot> (a -> a) -> a -> [a]
15:53:57 <adzeitor> > :i (->)
15:53:58 <Fuco> merijn: good idea
15:53:58 <lambdabot>   <hint>:1:1: parse error on input `:'
15:54:04 <adzeitor> > @type (->)
15:54:06 <lambdabot>   <hint>:1:1: parse error on input `@'
15:54:23 <merijn> Fuco: Although I think iterate is a bit inefficiently implemented for this. Writing something similar yourself should be fairly simple
15:54:55 <Kinnison> I think I ought to go to sleep, but before I do, anyone have any idea about this one:
15:55:01 <Kinnison> I have [a -> Bool] -> [a] -> Bool
15:55:04 <__xc> > 5 & (Just 4)
15:55:05 <lambdabot>   Couldn't match expected type `a0 -> b0'
15:55:06 <lambdabot>              with actual type `Data...
15:55:06 <Kinnison> to implement
15:55:20 <Kinnison> where I get True if *any* of the predicates in list one meet *any* of the elments in list two
15:55:23 <Kinnison> and I cannot get my brain around what to do
15:55:51 <merijn> __xc: & is just "flip ($)"
15:55:53 <hseg> Using parsec 3.1.3, I got the error: <interactive>: internal error: allocation of 3211412 bytes too large (GHC should  have complained at compile-time)
15:55:55 <merijn> :t (&)
15:55:56 <lambdabot> a -> (a -> b) -> b
15:56:19 <merijn> > Just $ 4
15:56:21 <lambdabot>   Just 4
15:56:25 <merijn> > 4 & Just
15:56:27 <lambdabot>   Just 4
15:56:29 <shachaf> I,I cps1 :: a -> (a -> b) -> b
15:56:31 <hseg> Any help in figuring out why I got it?
15:56:32 <monoidal> Kinnison: you want a hint or solution?
15:56:42 <shachaf> cps2 :: (a -> b) -> (b -> r) -> a -> r
15:56:42 <Kinnison> monoidal: frankly right now, solution, so I can finish this hideous function and go to bed
15:56:49 <applicative> iter op seed = loop seed True where loop x False = x; loop x True = loop (op x) (op x == x)
15:56:59 <monoidal> Kinnison: \x y -> or $ liftM2 ($) x y
15:57:02 <webpyre> is Vector an array?
15:57:12 <applicative> yes
15:57:17 <monoidal> Kinnison: or, or [f x | f <- .. , x <- ...]
15:57:21 <flebron_> I'd do it the dumb way, [f x | f <- fs, x <- xs]
15:57:34 <Kinnison> of course there'd be an 'or'
15:57:37 <flebron_> :)
15:57:41 <Kinnison> I suppose 'or' is 'any id' ?
15:57:46 <monoidal> Kinnison: yes
15:57:53 <Kinnison> I am clearly too tired :-)
15:58:32 <flebron_> You can also or [any f xs | f <- fs]
15:58:38 <Kinnison> yay, that's doing the right thing
15:58:40 <Kinnison> thanks monoidal
15:58:41 <monoidal> flebron: or of that
15:58:44 * Kinnison -> bed before it's Sunday (just)
15:58:55 <flebron_> monoidal: There's an or there :o
15:59:05 <monoidal> flebron_: ah, sorry
15:59:16 <Fuco> Kinnison: you can also ue e.g. [odd,even] <*> [1,2,3] to get the list of all the applications (6 in this case)
15:59:24 <Fuco> and then just look if there's True in it
15:59:26 <webpyre> in haskell do we add_noise or addNoise?
15:59:32 <hseg> addNoise
15:59:33 <flebron_> That's pretty, Fuco :)
15:59:34 <monoidal> webpyre: addNoise
15:59:50 <flebron_> Yay for applicatives.
16:00:01 <hseg> I got this error using Parsec 3.1
16:00:05 <hseg> .3: <interactive>: internal error: allocation of 3211412 bytes too large (GHC should  have complained at compile-time)
16:00:39 <hseg> Any ideas why I got it?
16:01:31 <monoidal> hseg: which ghc?
16:01:33 <gertc> how do i read this? instance Category (->) where ...
16:01:54 <hpc> gertc: have you read the monad instance for functions?
16:01:59 <monoidal> hseg: if recent, looks like a ghc bug
16:02:08 <hseg> 7.4.2
16:02:10 <ion> (->) is an instance of the Category type class, here are the method definitions.
16:02:26 <hpc> :k (->)
16:02:28 <lambdabot> * -> * -> *
16:02:35 <monoidal> gertc: a -> b is a shorthand for (->) a b
16:02:38 <shachaf> I,I instance Category (->) where id = id; (.) = (.)
16:02:48 <applicative> webpyre: either is permissible of course. Certainly it's best not to export anything with _
16:03:01 <DrChaos> erm...does anybody have any Haskell exercises for me? I have implemented most of Data.List but I deleted all my work :(
16:03:10 <monoidal> gertc: so "id :: c a a" becomes "id :: (->) a a" which is the same as "id :: a -> a"
16:04:02 <monoidal> gertc: and "(.) :: cat b c -> cat a b -> cat a c" becomes "(.) :: (->) b c -> (->) a b -> (->) a c" which is "(.) :: (b -> c) -> (a -> b) -> a -> c"
16:04:06 <hpc> DrChaos: implement simpleHTTP ;)
16:05:13 <hseg> DrChaos: Or if you're feeling particularly masochistic, implement GHC. jk :-)
16:05:14 <merijn> DrChaos: Write a simple compiler :)
16:05:41 <__xc> implement PHP from haskell
16:05:52 <Eduard_Munteanu> Compile lambda calculus to SKI :)
16:05:53 <hpc> DrChaos: contribute to this: https://github.com/headprogrammingczar/php-haskell-prelude
16:05:55 <__xc> a PHP parser in haskell
16:06:03 <applicative> I think he's looking for exercises
16:06:27 <hpc> i actually think implementing simpleHTTP is a good exercise
16:06:33 <merijn> Ok, useless joking aside. I was actually serious about the simple compiler suggestion. It's not very hard to compile a fictional language to some other high level language
16:06:40 <webpyre> is white noise uniform or normally distributed?
16:06:56 <merijn> I dunno, compile something fictional to python or JS
16:06:59 <hseg> Oops. As I was saying, I'm implementing projects 7-12 of TECS in Haskell, and it has proved to be a really good learning experience.
16:07:06 <monoidal> DrChaos: write a mastermind game?
16:07:06 <hpc> https://en.wikipedia.org/wiki/White_noise
16:07:19 <adzeitor> DrChaos: reddit dailyprogramming, project euler, http://rosalind.info
16:07:26 <merijn> Oh, mastermind is a good one, yeah
16:08:03 <webpyre> Dr Chaos: write a bayesian spamfilter or a simple spamfilter just based on counting words
16:08:03 <applicative> define a type of arithmetical expressions; then write an evaluator; then write something that renders them as expressions in various languages; then a parser of some format for the expressions
16:08:07 <merijn> Project Euler is...not liked here :p
16:08:14 <hpc> PE is great
16:08:18 <hpc> for learning number theory
16:08:24 <webpyre> merijn: how come?
16:08:26 <hpc> (but not much else)
16:08:28 <hseg> What's wrong with project euler?
16:08:29 <webpyre> aha
16:08:37 <merijn> applicative: Good one, nice way to trick people into learning compilers :)
16:08:54 <applicative> project euler is awesome, i used it to learn haskell syntax
16:09:08 <sacundim> does anybody feel like providing some feedback on this: https://github.com/sacundim/free-operational
16:09:11 <merijn> DrChaos: Go with applicative's suggestion, it's good! He's tricking you into writing a compiler without realising it ;)
16:09:24 <sacundim> i don't really know what i'm doing, i just do what the types tell me to do...
16:10:18 <nwf> Quick question for the channel: is there a canonical name in the base libraries for the function with type (a -> b) -> (c -> d) -> (Either a c) -> (Either b d) ?
16:10:34 <shachaf> nwf: Not in base.
16:10:39 <sacundim> isn't there an Arrow function like that?
16:10:40 <hpc> sacundim: what is this wizardry
16:10:43 <merijn> webpyre: PE solutions don't look much like "real" programs, so they don't really teach you how to write "real" programs in haskell. They're not very focussed on things that are easy to do in haskell (multithreading, concurrency, code reuse) and focus on some confusing things (code golfing, the number hierarchy, etc)
16:10:46 <shachaf> Oh, wait.
16:10:49 <nwf> shachaf: In Lens, by chance? :)
16:10:49 <sacundim> hpc: i'm not wholy sure either
16:11:01 <shachaf> No, Control.Arrow has it.
16:11:19 <monoidal> nwf: it might be bimap (not in base)
16:11:20 <shachaf> nwf: (Control.Arrow.+++)
16:11:27 <shachaf> And also bimap, but that's not base.
16:11:49 <nwf> Alrighty!  Thanks. :)
16:11:53 <shachaf> But, c'mon, like, bifunctors, man.
16:12:06 <hpc> sacundim: oh, i think i see
16:12:13 <startling> is there IO stuff for Text somewhere?
16:12:18 <shachaf> It only depends on semigroups and semigroupoids and tagged and contravariant and comonad and nats!
16:12:34 <hpc> sacundim: it transforms a computation into a structure of operations
16:12:42 <hpc> and lets you match on it
16:12:59 <nwf> shachaf: I am sure that I pull all that in as part of my dependency on lens, but still.
16:13:04 <monoidal> startling: Data.Text.IO?
16:13:09 <sacundim> hpc: yeah, i know that much, i wrote it :-).  i'm just not sure i'm not doing something stupid
16:13:15 <startling> monoidal: heh, should have guessed
16:13:16 <shachaf> nwf: Oh, sure.
16:13:19 <hpc> sacundim: does it work?
16:13:26 <sacundim> I think it does
16:13:30 <shachaf> nwf: lens depends on bifunctors. So you can just use that.
16:13:30 <webpyre> so, white noise IS uniform, not normal distributed. but isnt gaussian = white and gaussian=normal?
16:13:35 <hpc> then i think you aren't doing something stupid ;)
16:13:48 <hseg> This is odd. I'm getting an out of memory error from parsec when giving it a ~500 char  string to parse.
16:13:49 <shachaf> nwf: Did you know you can sort of make lenses that are based on bifunctors rather than profunctors?
16:13:49 <sacundim> but i don't know if i'm doing something dumb in terms of performance or anything
16:13:55 <shachaf> You get something weird.
16:14:18 <hpc> webpyre: it's more subtle than just what kind of distribution it is
16:14:27 <monoidal> hseg: can you paste it somewhere?
16:14:35 <hseg> The parser?
16:14:41 <monoidal> yes
16:14:59 <hseg> Sure thing. Fair warning, it's ~100 lines of code.
16:15:09 <sacundim> dont' paste it on channel
16:15:11 <nwf> shachaf: You mean (covariant,covariant) bifunctors?
16:15:15 <monoidal> hseg: hpaste.org
16:15:17 <shachaf> nwf: Yes.
16:15:21 <nwf> Weird.
16:15:31 <shachaf> nwf: (Or (contravariant,contravariant). But that doesn't really get you anything.)
16:15:35 <startling> what's the monadic equivalent for the word "traversal"?
16:15:35 <hpaste> hseg pasted “Memory-eating parser” at http://hpaste.org/85313
16:15:47 <shachaf> Instead of p a b -> p s t, you get p s b -> p a t
16:15:48 <monoidal> startling: "monadic traversal"?
16:15:55 <startling> monoidal: fair enough!
16:16:05 <shachaf> Then you can instantiate p at (,) or Either or something directly, when you want to use a lens/prism.
16:16:15 <shachaf> It works for lenses and prisms but doesn't work as well for Isos.
16:16:45 <webpyre> i see so you have gaussian white nosie and uniform white noise
16:16:52 <nwf> One of these days I will understand all this better than I do now... :\
16:17:42 <sacundim> nwf: or you'll understand types well enough that you can plug all the functions together and get them to work without having any idea how the heck it works.  that's where I'm at
16:18:27 <nwf> I make ghci do that for me (poor thing).
16:18:44 <monoidal> hseg: I can't see how it could happen from it. if it's "internal error: allocation of 3211412 bytes too large (GHC should have complained at compile-time)"  then that's really suspicious
16:19:17 <pharaun> sacundim: that sounds like me, tho i think i do *try* to understand sone of the types, some of them are... fancy tho
16:19:33 <hseg> Right. I'm getting different errors based on if I force GHCi to print the input and the packed input before parsing.
16:19:42 <monoidal> hseg: if you can check 7.6, go for it. if it will give the same thing there, I'd report a bug
16:19:48 <webpyre> is there a plotting lib for haskell?
16:20:17 <monoidal> hseg: note that checking 7.6 might be a lot of work if you have a lot of packages installed...
16:21:16 <hseg> Nah. The only package I have installed is SHA. But this is very odd, considering the fact that very similar code worked on the same Platform.
16:21:30 <pharaun> monoidal: even with cabal-dev?
16:21:49 <monoidal> pharaun: oh, it should be easier then, don't know it
16:21:55 <hseg> I'll test my old code, and see whether it's a problem in my version of the platform
16:22:45 <monoidal> hseg: the only occurence of "(GHC should have complained at compile-time)" is in GHC scheduler code, there are no bugs reported containing that string
16:22:46 <Eduard_Munteanu> webpyre: chart is an easy one\
16:22:48 <pharaun> monoidal: i haven't made much use yet but i heard its lovely for lots things and well yeah
16:22:51 <Eduard_Munteanu> @hackage chart
16:22:51 <lambdabot> http://hackage.haskell.org/package/chart
16:23:19 <Eduard_Munteanu> Huh.
16:23:24 <Eduard_Munteanu> @hackage Chart
16:23:24 <lambdabot> http://hackage.haskell.org/package/Chart
16:23:31 <pharaun> there's two Chart? :)
16:23:34 <Eduard_Munteanu> Ah, that's better.
16:23:42 <pharaun> that seems.. awkward
16:23:44 <Eduard_Munteanu> pharaun: no, looks like there's no 'chart'
16:23:49 <gertc> monoidal: ok but why make the data type be named (->) instead of cat or someting? Would it not make this extreemly confusing in combination with Type signatures?
16:24:18 <pharaun> Eduard_Munteanu: :| good job lambdabot :p
16:24:42 <mpiechotka> @pl (\x -> f g (h g x))
16:24:42 <lambdabot> f g . h g
16:24:47 <Eduard_Munteanu> @hackage willnotcheckifthepackageexists
16:24:47 <lambdabot> http://hackage.haskell.org/package/willnotcheckifthepackageexists
16:24:55 <hseg> OK. *Now* I'm getting a segfault. Old code here - remember, this *worked* a month ago:
16:24:57 <hpaste> hseg pasted “Earlier version of parser” at http://hpaste.org/85314
16:24:59 <monoidal> gertc: it could be called Function, and we would have Function a b = a -> b. but it was decided (->), and it's rather logical, since that resembles section, i.e. 2+2 is the same thing as (+) 2 2
16:25:14 <mpiechotka> @pl (\x -> f g (h g x) i)
16:25:14 <lambdabot> flip (f g . h g) i
16:25:20 <startling> hseg, wild guess: is 'hashable' involved somewhere?
16:25:51 <hseg> only place I'm hashing anything is in the Main.hs, where I hash a path using SHA
16:25:53 <gertc> monoidal: aaa ok now i get it i think
16:25:54 <jmcarthur> i want to make a package called willnotcheckifthepackageexists just to surprise people who click the obviously-not-real link
16:26:06 <hseg> Doesn't appear anywhere inside the core code
16:26:29 <pharaun> jmcarthur: doit ;p also good way to troll the bot
16:26:46 <startling> jmcarthur: write an alternative lambdabot plugin that *does* check for existence on hackage and call it that.
16:27:25 <jmcarthur> haha
16:28:01 <pharaun> startling: oh hey, that's even better idea
16:28:11 <hseg> OK. Something's fishy here. I see my old code segfaults on syntactically incorrect input.
16:28:19 <hseg> Parsec shouldn't do that
16:28:19 <Fuco> so I have: ap (,) return ... that has type a -> (a, m a), but how do I tell it that m = []? I want e.g. 1 -> (1,[1])
16:28:22 <shachaf> willnotcheckifthepackageexistswhenprecededbyitsquotation
16:28:42 <pharaun> hseg: got a pastie of the code or is it too large?
16:28:50 <shachaf> Fuco: Well, you can specify the type, as in (ap (,) return :: ...), or you can just use it.
16:29:05 <hseg> Fuco: By annotating it with type forall a. a -> (a, [a]) ?
16:29:27 <gertc> thx
16:29:30 <hseg> Old code here: http://hpaste.org/85314 segfaults with incorrect input
16:29:44 <Fuco> shachaf: if I just use it (ap (,) return 1) I get: Ambiguous type variable `m' in the constraint
16:29:59 <hseg> New code here: http://hpaste.org/85313 complains of lack of memory on correct input
16:30:13 <Fuco> hseg: ok, I'll try that :P I don't know much about these forall constraints (yet :))
16:30:14 <shachaf> Fuco: Are you sure you're "just using it"?
16:30:46 <Fuco> shachaf: I write this in ghci: `ap (,) return 1'
16:31:04 <shachaf> Fuco: OK, you're applying it to an argument.
16:31:13 <shachaf> So in this case it's probably simplest to annotate it with a type.
16:31:21 <shachaf> You're not actually "using" it except polymorphically.
16:31:41 <shachaf> (1, return 1) -- error
16:31:52 <shachaf> (1, return 1 :: [Int]) -- success
16:32:01 <Fuco> hm, so then what would be "just using it"?
16:32:15 <shachaf> (1, return 1) :: (Int, [Int]) -- success
16:32:19 <shachaf> Lots of things.
16:32:22 <webpyre> if i have an Int and an IO Int how can I add them in a mapM?
16:32:25 <monoidal> > head $ snd (1, return 1)
16:32:26 <lambdabot>   1
16:32:29 <shachaf> For example passing the tuple to a function that wants a tuple of that type.
16:32:40 <shachaf> Or passing the second half of it to a list function, like monoidal did.
16:32:50 <monoidal> webpyre: fmap (+x) y
16:32:52 <sacundim> webpyre: liftM (+int) ioint?
16:32:55 <hseg> Fuco: In brief, all free variables in type signatures for functions are quantified with forall. This means that you can beta-reduce all the free variables however you like.
16:34:19 <monoidal> hseg: In general programs compiled by GHC should not segfault, except when you use unsafe functions or FFI
16:34:39 <ab9rf> yeah, if ghc/ghci segfault and yu're not using unsafe functions, something bad has happened.
16:34:42 <ab9rf> (or FFI)
16:34:47 <hseg> Right. This is completely out of character for Haskell
16:37:41 <hpaste> webpyre pasted “random IO mapM” at http://hpaste.org/85319
16:37:52 <monoidal> hseg: In general programs compiled by GHC should not segfault, except when you use unsafe functions or FFI
16:37:57 <webpyre> can someone help me?
16:37:57 <monoidal> whoops, sorry
16:38:23 <elliott> monoidal: worth saying twice? :P
16:38:30 <hseg> Right. Any ideas what diagnostics I can perform to try and figure out what's going on?
16:38:41 <monoidal> accidentally pressed up arrow
16:38:46 <Eduard_Munteanu> webpyre: how's the mapM related to what you want to do?
16:39:10 <webpyre> maybe it isnt
16:39:55 <webpyre> the first fmap should be mapM but it still doesnt work
16:40:04 <ab9rf> heh
16:40:31 <monochrom> @type mapM
16:40:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:40:32 <monoidal> hseg: if you can, I'd attempt to (1) check if it still crashes on 7.6; (2) make the program as small as possible to reliable crash (3) report it on ghc trac http://hackage.haskell.org/trac/ghc/wiki/ReportABug
16:40:42 <webpyre> oops it does
16:40:59 <linduxed> do you guys tend to use some tool for running tests automatically upon file change?
16:41:17 <webpyre> works now
16:41:24 <sacundim> webpyre, a nitpick: i'd reorder the arguments in addUniformWhiteNoise
16:41:55 <hseg> It warns in strong terms not to install GHC alone.
16:41:57 <monochrom> mapM (\v -> do { r <- uniformWhiteNoise a b; return (v + r) }) xs
16:41:59 <sacundim> Double -> Double -> [Double] -> IO [Double]
16:42:14 * Eduard_Munteanu missed the paste
16:42:30 <pharaun> hseg: its because its usually *better* for you to use the distro/package provider
16:42:54 <Eduard_Munteanu> Actually you can move the call to uniformWhiteNoise out of that.
16:42:55 <pharaun> hseg: but there *are* cases where it is valid to install ghc alone such as bootstrapping on a platform/distro without ghc provided
16:43:24 <hseg> And if I already have GHC and cabal?
16:43:47 <ab9rf> hseg: are you being naughty?
16:44:15 <hseg> I am being very nice
16:44:44 <pharaun> hseg: oh this is for 7.6 test? yeah go install the 7.6 ghc
16:45:05 <pharaun> its not too hard actually, my main issue was libgmp
16:45:21 <pharaun> but was pretty easy to get a *local* install of ghc + platform up and running
16:46:26 <hseg> Hopefully, my experience will be as good as yours. Here goes nothing...
16:47:19 <linduxed> i'm mostly thinking about running a set of tests automatically
16:54:27 <monoidal> good night
16:54:42 <hseg> Installed GHC 7.6. Why doesn't it see most of the packages that came with the platform? Specifically, why can't it find Text.Parsec.Token?
16:55:34 <elliott> hseg: probably you installed platform for an older ghc
16:55:36 <elliott> packages are per-version
16:56:11 <hseg> OK. So I guess I need to manually install those packages that GHC can't find now?
16:58:07 <Ontolog> lambdabot: map (read :: Int) ["1","2","3"]
16:58:10 <carter> hseg if by manual you mean cabal update ; cabal install X
16:58:10 <carter> yes
16:58:20 <Ontolog> how do i tell lambdabot to evaluate haskell
16:58:33 <elliott> > map read ["1","2","3"] :: [Int]
16:58:34 <lambdabot>   [1,2,3]
16:58:45 <Ontolog> oh....
16:58:59 <Ontolog> not sure how that works
16:59:13 <__xc> > haskell :: Expr
16:59:16 <hseg> Right. Secondly, for some reason ghc --version still outputs that it's version 7.4.2, not 7.6.1
16:59:16 <lambdabot>   Not in scope: `haskell'
17:01:33 <Ontolog> elliott: can you explain?
17:02:31 <fryguybob> > let haskell = var "haskell" in haskell + 1 -- __xc ?
17:02:33 <lambdabot>   1+haskell
17:02:40 <elliott> Ontolog: I'm not sure what you're confused about
17:02:43 <elliott> > 123
17:02:44 <lambdabot>   123
17:02:49 <elliott> is how to evaluate haskell with lambdabot
17:03:04 <Ontolog> elliott: no i mean you changed my expression to make it work
17:03:10 <elliott> right, (read :: Int) is a type error
17:03:16 <elliott> (read :: String -> Int) would have worked, though
17:03:21 <elliott> but it also works to specify the type of the resulting list
17:03:23 <__xc> > let haskell = "haskell" in haskell + 1
17:03:25 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
17:03:25 <lambdabot>    arising from a use of `GH...
17:03:38 <Ontolog> elliott: oh ok then haskell infers the type of read
17:03:51 <startling> Ontolog: it can't always, though
17:04:20 <applicative> if it cant figure it out, the results are unpleasant
17:04:23 <startling> > read "1"
17:04:25 <lambdabot>   *Exception: Prelude.read: no parse
17:05:07 <applicative> thats a somewhat confusing message until you imprint that it almost always means "I didn't make the return type clear enough"
17:05:09 <sacundim> elliott: edwardk and you were helping me out with free and operational some weeks ago, dunno if you remember.  anyway, dunno if you might want to have a look at what I wrote after that conversation: https://github.com/sacundim/free-operational
17:05:11 <startling> > read "()" -- on the other hand...
17:05:14 <lambdabot>   ()
17:05:42 <elliott> sacundim: cool
17:05:57 <elliott> sacundim: that countAsk example looks like you could simplify it with some cool folding combinators
17:06:08 <sacundim> yeah, haven't worked it out yet
17:06:13 <pharaun> hseg: your path
17:06:27 <sacundim> you can't fold the view type like you could fold a monoid, so i got stumped when i tried it
17:06:38 <startling> Ontolog: essentially, polymorphic things you evaluate in ghci will try to give you a ()
17:06:40 <hseg> Right. Changing it, and I'm looking to make it permanent.
17:07:02 <startling> Ontolog: when you just say "read "123"", it doesn't parse, because it's using "read :: String -> ()"
17:07:14 <sacundim> first i'm trying to figure out if I did anythign crassly wrong, but I don't even know how to unit test something like this...
17:07:27 <elliott> sacundim: mumble mumble lens mumble
17:07:53 <sacundim> elliott: mumble mumble looks like perl mumble
17:08:05 <Ontolog> startling: what's a ()? null function?
17:08:18 <startling> Ontolog: null data type
17:08:21 <hseg> Ontolog: the unit data type
17:08:29 <sacundim> Ontolog: it's called "unit", and it's a type that has only one value, ()
17:08:31 <applicative> @type ()
17:08:31 <hseg> Has only one value - ()
17:08:32 <startling> yeah, "null" is actually the wrong word
17:08:32 <lambdabot> ()
17:08:59 <elliott> sacundim: pfft, you can just ignore all the operators. but I was thinking that you could likely expose folds of some kind for the views.
17:09:14 <DrChaos> ok, I guess the first programming exercise I should have is how to generate the fibonacci sequence
17:09:18 <Ontolog> everything is a function in haskell right?
17:09:18 <hseg> startling: Wouldn't the null data type be the uninhabited data type. i.e. any type that is only inhabited by _|_?
17:09:32 <sacundim> elliott: i'm still trying to understand the code i did write.
17:09:36 <Ontolog> and values are just functions that return themselves?
17:09:41 <hseg> Ontolog: Not really. Functions are first-class, though
17:09:45 <Ontolog> oh
17:10:06 <startling> hseg: yeah, hence <startling> yeah, "null" is actually the wrong word
17:10:20 <elliott> sacundim: oh, that's a terrible strategy. you should just keep plowing on until you have a whole ecosystem you don't understand. then other people can figure it out for you
17:10:24 <elliott> it worked for edwardk
17:10:43 <startling> Ontolog, values are not functions.
17:11:26 <elliott> Ontolog: functions are just a type of value.
17:11:32 <elliott> just like some values are lists, some values are integers.
17:11:44 <hseg> startling: One *could* view values as 0-ary functions, though/
17:11:51 <Ontolog> i thought values are just a type of function that that would be more category-theory-esque
17:12:01 <startling> hseg: nah
17:12:30 <startling> hseg: there's an article about why that's wrong but I can't find it. :X
17:12:41 <Ontolog> startling: try harder :p
17:12:44 <Ontolog> i'm interested
17:13:14 <Ontolog> i thought CT was all like 'look at all objects as functions and then just talk about them using these axioms that apply to functions'
17:13:14 <Saizan> well it's terminology so it can't really be wrong, it might be less than useful though
17:13:34 <elliott> @google conal everything function haskell
17:13:36 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
17:13:37 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
17:13:40 <elliott> this doesn't really have anything to do with CT though.
17:13:41 <sacundim> beat me to it
17:13:48 <hseg> BTW, why does cabal install stuff in AppData, when that means that when cabal is updated, the old version will be called by default?
17:13:50 <Saizan> Ontolog: haskell is not CT
17:13:53 <elliott> Ontolog: btw, "object" means something else in CT, also.
17:13:56 <startling> Ontolog: more like "we don't really care about objects at all"
17:14:02 <Ontolog> fine
17:14:40 <lewis1711> I really should write something non-trivial in haskell and see if I miss objects
17:14:48 <carter> acfoltzer a friend who knows ARM was looking at the GHC cas asm and went "this needs some love"
17:14:52 <DrChaos> I don't even know how to implement fibonacci recursively
17:15:01 <carter> i may have nerd snipped him with asm into getting into haskell bottom up
17:15:03 <startling> lewis1711: not what I meant; sorry for the confusion.
17:15:05 <DrChaos> I guess I'd start out by saying that the first fibonacci number is 1
17:15:17 <startling> DrChaos: wrong. :P
17:15:27 <DrChaos> the second is 3
17:15:35 <startling> ???
17:15:48 <lewis1711> startling: I meant "alan kay" objects, just an idle thought :)
17:15:57 <sacundim> DrChaos: and the 0th is 1
17:16:06 <elliott> a fibonacci number is just the sum of the two previous fibonacci numbers. given that knowledge and the base cases, a recursive implementation is easy
17:16:22 <lewis1711> oh I do get angry when people start recursive factorials at case 1 and not case 0. well not angry. more smug
17:18:42 <webpyre> > let fib n = if n == 0 || n == 1 then n else fib (n-1) + fib (n-2) in map fib [1..10]
17:18:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
17:19:46 <sacundim> isn't fib 0 = 1?
17:20:17 <Ontolog> i want my type to be an instance of Read
17:20:23 <webpyre> > let fib n = if n == 0 || n == 1 then 1 else fib (n-1) + fib (n-2) in map fib [1..10]
17:20:25 <Ontolog> i tried mapping read "Thing" = Thing
17:20:25 <lambdabot>   [1,2,3,5,8,13,21,34,55,89]
17:20:27 <Ontolog> but that didn't work
17:20:50 <sacundim> webpyre: just in case, mine was not a rhetorical question
17:21:23 <webpyre> > let fac n = if n < 1 then 1 else n * fac (n-1) in map fac [0..10]
17:21:25 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
17:22:03 <webpyre> lewis1711: does that make you look smug?
17:23:05 <webpyre> is (filter cond . map f) O(N) or O(2N) ?
17:23:31 <Eduard_Munteanu> Those Os are equivalent. :)
17:23:38 <lewis1711> webpyre: I am not sure what you meant to illustrate with that point :)
17:23:42 <webpyre> yeah but you know what i mean
17:23:53 <webpyre> is fac 0 = 1?
17:23:57 <djahandarie> webpyre, it's fused together in a single loop if that's what you're asking
17:23:58 <lewis1711> yes
17:24:03 <webpyre> djahandarie: ok
17:24:10 <Fuco> is there functon [a] -> [a] that keeps maximum elements (all of them)? maximum :: [a] -> a only keeps one
17:24:24 <webpyre> :t max
17:24:25 <lambdabot> Ord a => a -> a -> a
17:24:30 <webpyre> :t maximum
17:24:31 <Eduard_Munteanu> I guess it should fuse. Though Prelude stuff rarely fuses all the way.
17:24:31 <lambdabot> Ord a => [a] -> a
17:24:55 <djahandarie> I suppose it's possible it may not fuse. I think it should though.
17:25:01 <djahandarie> Could check the core.
17:25:24 <Eduard_Munteanu> Yeah, I think that will, it's harder to fuse away the entire list or stuff like that.
17:26:05 <Eduard_Munteanu> e.g. stuff like sum [1..100]
17:26:11 <sacundim> Fuco: i don't think so
17:26:58 <Eduard_Munteanu> The stream-fusion package is nice for those cases.
17:27:16 <Ontolog> holy shit, hello world is 1.4MB compiled?!
17:27:25 <Eduard_Munteanu> Ontolog: due to static linking
17:27:36 <Ontolog> oh...
17:27:44 <sacundim> Fuco: such a function would return a list all of whose elements are equal.  which produces no more information that the max value and the count
17:27:49 <Eduard_Munteanu> -dynamic should get you < 20KiB or so
17:28:14 <Ontolog> sorry i haven't done much C, so the binary includes all the haskell code it needs to run? so like i could just run the binary on another system (some os etc) and run it?
17:28:19 <Fuco> sacundim: not true. Consider: max ["abc","efg","a","b"] -> ["abc","efg"]
17:28:29 <Ontolog> i mean that other system wouldn't have GHC
17:28:29 <Eduard_Munteanu> Ontolog: yes
17:28:30 <Fuco> `max' begin the hypothetical function
17:28:32 <Ontolog> cool
17:28:45 <Eduard_Munteanu> Ontolog: it only links in the Haskell libs, not the system stuff
17:28:57 <Eduard_Munteanu> Those are dynamically-linked anyway.
17:29:12 <Ontolog> right
17:29:14 <sacundim> Fuco, wouldn't that have to be ["efg"]?
17:29:35 <Fuco> "abc" and "efg" are equal accoding to the ordering by length
17:29:49 <Fuco> (which is what haskell does with lists)
17:29:56 <sacundim> ok. so it's not Ord a => [a] -> [a]
17:30:29 <Fuco> if I ask for maximum I think the Ord a is implied :P
17:30:32 <sacundim> you want (a -> a -> Ordering) -> [a] -> [a]
17:30:42 <hseg> Now is the moment of truth. I'm testing parsec 3.1.3 with GHC 7.6.1 on my new parser. Hopefully this won't crash
17:30:50 <sacundim> > max "abc" "efg"
17:30:52 <lambdabot>   "efg"
17:31:18 <hseg> However, considering that GHC is consuming 400,000 K RAM and counting, that's unlikely
17:31:20 <sacundim> Fuco, String uses the Ord instance for [Char], which gives you "abc" < "efg"
17:31:39 <sacundim> so you need to provide your own comparison to get the ordering by length
17:31:50 <Fuco> hm, right
17:32:08 <startling> "dictionary ordering"
17:32:48 <lightquake> does anybody know where bitc's been?
17:32:57 <lightquake> hdevtools has been pretty unmaintained lately :(
17:33:18 <hseg> 1.5 MB RAM - This is insane.
17:34:35 <lewis1711> how am I supposed to run ed and ghc on the same machine now?
17:35:14 <hpaste> webpyre pasted “maximums - simpler way? fold?” at http://hpaste.org/85321
17:35:49 <webpyre> Fuco^^ is that what you want btw?
17:37:02 <Fuco> uff, I can't tell what it does, really :p
17:37:12 <Fuco> try it on [1,2,5,3,5,2], should return [5,5]
17:37:32 <jmcarthur> hseg: that's 29 cents worth of RAM!
17:37:37 <Fuco> though as mentioned above the version with a->a->Ordering would be more useful.
17:37:47 <lightquake> i assume hseg meant 1.5 GB
17:38:01 <sacundim> webpyre, Fuco: that looks like a start.  first i'd rewrite it to use compare instead of >, == and <, then make it accept the comparison function as an argument
17:38:02 <Fuco> but I've solved it in a different way... this would be too inefficient anyway :P
17:38:14 <hseg_> Posting from different computer: I don't think changing to GHC 7.6.1 helped, as GHC is now consuming 2.3 MB of RAM in order to try and parse the sample.
17:38:28 <jmcarthur> lightquake: i guess $30 is a little more significant, but still not much compared to the rest of the computer...
17:38:29 <ab9rf> Fuco: is there a reason not to simply use filter and maximum?
17:38:35 <lightquake> hseg_: do you mean MB or GB?
17:38:36 <jmcarthur> hseg_: do you mean GB?
17:38:39 <hseg_> MB
17:38:42 <webpyre> fuco: it does
17:38:43 <ab9rf> you have to traverse the list twice anyhow
17:38:44 <jmcarthur> that's silly
17:38:55 <jmcarthur> hseg_: 2.3 MB is not huge
17:39:06 <lightquake> why are you complaining about single-digit megabytes of memory? are you a time traveler from 1998?
17:39:08 <ab9rf> hm, maybe not
17:39:09 <Fuco> ab9rf: well yes, the specification has changed
17:39:18 <jmcarthur> we're talking 45 cents (while i'm computing these prices) worth of memory here
17:39:25 <ab9rf> Fuco: there's a specification?
17:39:29 <hseg_> Actually, wait. Looking at the figures, they're given in KB. So I have 2,000,000 KB of usage. Oops
17:39:43 <jmcarthur> that's more worth complaining about then
17:39:45 <Fuco> what I wanted was, e.g.: ["a","b","abc","efg","cd"] return ["abc","efg"]
17:39:46 <lightquake> yeah
17:39:58 <Fuco> that is by ordering by length, return the maximal elements
17:40:12 <ab9rf> :t filter
17:40:14 <lambdabot> (a -> Bool) -> [a] -> [a]
17:40:21 <Fuco> it's like... imagine a poset, and return maximums (not! greatest element)
17:40:47 <jmcarthur> hseg_: what are you trying to parse?
17:41:09 <hseg_> A 400-character file in an assembly-like language
17:41:31 <ab9rf> :t maximum
17:41:32 <lambdabot> Ord a => [a] -> a
17:41:34 <jmcarthur> hseg_: oh i just read a bit earlier. why are you blaming ghc for this? it sounds like you have a messed up program, to me
17:41:45 <webpyre> ab9rf: how does my list traverse the list twice?
17:41:56 <jmcarthur> i may have misunderstood you, actually
17:41:59 <ab9rf> \list -> filter (\x -> length x == l) list where l = maximum (map length list)
17:42:01 <jmcarthur> i'm being too harsh
17:42:08 <ab9rf> webpyre: yours does not
17:42:10 <jmcarthur> hseg_: sorry, i'll be more constructive
17:42:24 <jmcarthur> hseg_: how big is your parser? small enough to put on hpaste?
17:42:41 <ab9rf> webpyre: yours is fairly clever, i like it
17:42:43 <hseg_> A) I posted the code above. B) I'm only using Parsec, and yet I'm getting segfaults and out-of-memory errors
17:42:55 <ab9rf> webpyre: you can probably adapt it to do this "new" maximum
17:43:02 <hseg_> C) it's OK, I was all WTF?! when I saw this, too
17:43:15 <Fuco> ab9rf: that wouldn't work in general case though :P
17:43:35 <pharaun> jmcarthur: its up on pb
17:43:44 <hseg_> D) The code is on the computer that has 99% RAM usage right now. I don't think I'll succeed in getting it off of there any time soon
17:44:05 <jmcarthur> hseg_: is this it? http://hpaste.org/85314
17:44:10 <jmcarthur> hseg_: control-C
17:44:20 <hseg_> Although.... I sent it to someone by email. A sec, reposting on hpaste
17:44:27 <hpaste> ab9rf annotated “maximums - simpler way? fold?” with “maximums - by length” at http://hpaste.org/85321#a85322
17:44:43 <hseg_> What you posted is an earlier version of the parser that segfaulted with GHC 7.4.2
17:44:50 <jmcarthur> ah
17:44:52 <hseg_> And ^C doesn't work
17:44:57 <ab9rf> Int is probably too narrow
17:45:02 <ab9rf> you can really use any Ord n that case
17:45:14 <ab9rf> just has to be comparable
17:45:29 <ab9rf> i haven't tested that though :)
17:45:41 <webpyre> @src comparing
17:45:42 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:47:33 <hpaste> hseg pasted “Parser” at http://hpaste.org/85323
17:47:43 <Hermit> Fuco: what are you trying to do?
17:48:11 <webpyre> can someone explaing comparing to me?
17:48:45 <webpyre> i thoguht it should have the type (a->a->b) -> a -> a -> Ordering not (a->b) -> a -> a -> Ordering
17:48:46 <Fuco> Hermit: well, nothing really. What I *wanted* was to return maximal elements of a poset. But it was an XY problem and I have a better solution now
17:49:14 <ab9rf> ok, sorry about that
17:49:20 <ab9rf> couple of type errors in that post
17:49:21 <Hermit> not sure what it is but.. ok  (/me is having connection problems, missed a big chunk)
17:49:24 <hseg_> webpyre: compare is the general-case comparison between two values of an instance of Ord
17:49:41 <jmcarthur> hseg_: could you also hpaste the text you are trying to parse so i can play with it?
17:49:49 <Fuco> Hermit: XY problem is when you thing Y is the best way to solve X, so you ask how to do Y instead of how to do X :)
17:49:55 <Fuco> s/thing/think/
17:50:07 <hpaste> ab9rf revised “maximums - by length”: “Maximums by length (fixed)” at http://hpaste.org/85322
17:50:14 <hseg_> webpyre: comparing is the comparison of the images of two values under a function to an instance of Ord
17:50:51 <ab9rf> webpyre: that was a clever solution
17:51:19 <Hermit> webpyre: what part of it?
17:51:20 <ab9rf> you could do this as a fold but it would be fairly messy
17:51:27 <jmcarthur> hseg_: oh, i guess i also have no idea what Syntax.VM is
17:51:53 <Hermit> geez, what a bitchy connection
17:51:57 <Hermit> webpyre: what part of it?
17:52:30 <webpyre> ab93f: what my first one? i dont know, im just learning haskell
17:52:46 <ab9rf> oddly, it produces the list backwards
17:52:53 <ab9rf> which i find amusing
17:53:09 <ab9rf> *DTest> maximums ["a","b","abc","efg","cd"]
17:53:10 <ab9rf> ["efg","abc"]
17:53:35 <hpaste> hseg pasted “Syntax” at http://hpaste.org/85325
17:54:53 <hpaste> hseg pasted “Input” at http://hpaste.org/85326
17:55:46 <hseg_> And now the secret's out - this is homework, but I'm desperate, since this does not appear to be normal behaviour for Haskell
17:57:03 <Hermit> hseg_: what's not "normal behaviour" according to you?
17:57:16 * hackagebot vinyl 0.1.1.0 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.1.1.0 (JonSterling)
17:57:41 <hseg_> That pure code should segfault? That packages in the Platform should experience out-of-memory errors on trivial input?
18:00:16 <hpaste> sacundim pasted “my quick shot at maximums” at http://hpaste.org/85327
18:01:23 <lispy> hseg_: are you on windows?
18:01:35 <lispy> hseg_: (I saw your comment that ^C doesn't work)
18:02:06 <hseg_> Yes. Unfortunately. And ^C does exist in Windows.
18:02:19 <hseg_> Also, GHC crashed, so the computer is working now.
18:02:36 <arkeet> sacundim: that just looks like it takes all the minimum elements from the list?
18:02:44 <lispy> hseg_: ^C does not send sigkill in the standard console though
18:03:34 <hpaste> hseg annotated “my quick shot at maximums” with “You can use filter here” at http://hpaste.org/85327#a85328
18:04:34 <arkeet> hseg_: == doesn't work, you still have to use comparison
18:04:35 <arkeet> :p
18:04:46 <hseg_> Why?
18:04:53 <arkeet> because you aren't given Eq a.
18:05:23 <__xc> > pi < 4
18:05:25 <lambdabot>   True
18:05:35 <arkeet> > pi :: CReal
18:05:36 <dmwit> class Eq a => Ord a
18:05:37 <lambdabot>   3.1415926535897932384626433832795028841972
18:05:38 <jmcarthur> arkeet: Ord implies Eq
18:05:44 <arkeet> jmcarthur: you aren't given Ord a.
18:05:52 <jmcarthur> then how do you compare?
18:05:55 <__xc> > pi < 'e'
18:05:56 <hpaste> hseg pasted “Isn't Ord an instance of Eq?” at http://hpaste.org/85329
18:05:56 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Char)
18:05:56 <lambdabot>    arising from a use o...
18:05:59 <sacundim> hseg: takeWhile will stop once it sees the first false
18:06:05 <arkeet> maximumsBy is being passed (a -> a -> Ordering)
18:06:06 <sacundim> arkeet: oops, yeah
18:06:14 <dmwit> > pi < exp 1
18:06:16 <lambdabot>   False
18:06:20 <hseg_> Or some form of pattern match
18:06:31 <__xc> > 3 < 'e'
18:06:32 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:06:33 <lambdabot>    arising from the literal `3...
18:06:36 <arkeet> anyway, ignoring the by stuff,
18:06:39 <arkeet> why not
18:06:40 <sacundim> hseg_: let me restate.  filter will traverse the whole list.  takeWhile will only traverse a prefix
18:06:41 <dmwit> > 3 < exp 1
18:06:43 <lambdabot>   False
18:06:44 <jmcarthur> arkeet: a == b = cmp a b == Eq
18:06:59 <hseg_> i.e. case compare x y of {EQ -> True; _ -> False}
18:06:59 <arkeet> jmcarthur: read the code again.
18:06:59 <jmcarthur> *EQ
18:07:00 <dmwit> __xc: 'e' is a Char, which is not a kind of number.
18:07:09 <arkeet> anyway, maximums xs = filter (== maximum xs) xs
18:07:17 <sacundim> hseg_: since i sorted the list, I'm guaranteed the elements of interest are at the beginning
18:07:21 <__xc> > 3 :: Char
18:07:21 <arkeet> (what's wrong with this?)
18:07:22 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:07:23 <lambdabot>    arising from the literal `3...
18:07:25 <jmcarthur> arkeet: i'm just saying if you want (==) you can define it with the compare function you are given
18:07:26 <arkeet> (it's O(n) too)
18:07:34 <arkeet> jmcarthur: yes. but you can't literally write ==
18:07:41 <jmcarthur> arkeet: why not? just define it locally
18:07:42 <sacundim> arkeet: but the thing is that the function that Fuco is interested in is actually maximumsBy
18:07:50 <arkeet> jmcarthur: well you should have said that. :p
18:07:55 <sacundim> but yeah, my maximums sucks...
18:07:58 <jmcarthur> arkeet: let a == b = cmp a b == EQ in blah blah blah
18:08:06 <hpaste> webpyre pasted “maximums - final version” at http://hpaste.org/85330
18:08:07 <dmwit> jmcarthur: Not quite like that...
18:08:11 <jmcarthur> well i guess you can't use == on both sides
18:08:17 <webpyre> ^^ ok now it is general as well
18:08:27 <jmcarthur> let eq a b = cmp a b == EQ in blah blah blah
18:08:33 <arkeet> sacundim: sure, so maximumsBy cmp xs = filter (\x -> x `cmp` maximumBy cmp xs == EQ) xs
18:08:34 <arkeet> easy.
18:09:06 <jmcarthur> that doesn't look right
18:09:20 <arkeet> why not?
18:09:23 <jmcarthur> :t \cmp x -> x `cmp` maximumBy cmp xs == EQ
18:09:24 <lambdabot>     Not in scope: `xs'
18:09:24 <lambdabot>     Perhaps you meant one of these:
18:09:25 <lambdabot>       `x' (line 1), `x' (imported from Debug.SimpleReflect),
18:09:29 <jmcarthur> :t \cmp x xs -> x `cmp` maximumBy cmp xs == EQ
18:09:30 <lambdabot> (a -> a -> Ordering) -> a -> [a] -> Bool
18:09:34 <jmcarthur> ah, nevermind
18:09:43 <sacundim> arkeet: isn't that O(n!)
18:09:46 <NemesisD> hey guys. isn't there an extension which binds the type variables in a function's signature to those in the where clause?
18:09:47 <arkeet> sacundim: why?
18:09:47 <ab9rf> webpyre: nice
18:09:52 <arkeet> maximumBy is O(n), and filtering is O(n).
18:09:57 <dmwit> NemesisD: ScopedTypeVariables
18:09:59 <jmcarthur> NemesisD: ScopedTypeVariables can be a way
18:10:00 <Nisstyre-laptop> NemesisD: scoped type variable
18:10:01 <Nisstyre-laptop> *s
18:10:04 <Nisstyre-laptop> dammit
18:10:08 <arkeet> @quote stereo
18:10:08 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
18:10:08 <dmwit> NemesisD: You must ask for the scoping with the "forall" keyword.
18:10:13 <arkeet> argh
18:10:17 <jmcarthur> @quote fugue
18:10:18 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:10:28 <ab9rf> hah, ain't that the truth
18:10:40 <NemesisD> dmwit: what do you mean
18:10:46 <sacundim> arkeet, um, O(n^2).  you're doing maximumBy cmp xs in the filter.
18:11:02 <arkeet> I assume cmp is O(1)
18:11:14 <ab9rf> you want to pull the maximumBy out
18:11:19 <sacundim> yep
18:11:21 <arkeet> maximumBy goes linearly through the list
18:11:24 <webpyre> if order doesnt matter. if it does then youd have to reverse the answer and youre basically back to O(N)*2
18:11:26 <ab9rf> that's why i used a where in my version
18:11:37 <sacundim> arkeet: yes, and so does filter
18:11:45 <sacundim> nested loops
18:11:47 <arkeet> yes, and you're doing one after the other.
18:11:49 <arkeet> no it's not nested.
18:11:51 <arkeet> well.
18:12:01 <arkeet> ok fine, pull out the maximumBy.
18:12:14 <arkeet> maximumsBy cmp xs = let m = maximumBy cmp xs in filter (\x -> x `cmp`  == EQ) xs
18:12:14 <ab9rf> i wouldn't trust GHC to recognize that that clause is invariant and optimize it out
18:12:18 <arkeet> you're rigt.
18:12:22 <arkeet> h
18:12:37 <arkeet> hmm, insert a "m" there.
18:12:50 <NemesisD> hmm ok maybe that's not what i mean. i've got a class constraint like: foo :: FromJSON (PaginatedResponse a), everything is fine, but it happens that foo recursively calls itself, and then ghc complains it couldn't deduce FromJSON (PaginatedResponse a0)
18:12:55 <arkeet> except now you have to treat the empty list separately.
18:12:58 <NemesisD> i'm presuming the a0 is from the recursive call
18:13:02 <jmcarthur> ab9rf: if it was performance critical then i wouldn't either, but usually i would because usually it gets it right anyway
18:13:07 <webpyre> anyone here knows anyone that does DSP?
18:13:08 <ab9rf> > maximum []
18:13:09 <lambdabot>   *Exception: Prelude.maximum: empty list
18:13:14 <ab9rf> yup you do
18:13:20 <NemesisD> am i going to have to re-annotate the call to foo with its own type or something?
18:13:27 <ab9rf> webpyre: ugh
18:13:32 <ab9rf> webpyre: i know a tiny bi about DSP
18:13:39 <NemesisD> not what i need* not mean
18:13:41 <ab9rf> webpyre: not enough to code anything though
18:13:49 <jmcarthur> NemesisD: you have you use forall to bind the type variables that you want to be in scope in your where clause
18:14:06 <jmcarthur> NemesisD: and you have to actually write types somewhere, whether they be type signatures or type annotations
18:14:11 <hseg_> I still have no idea why Parsec is using 2GB of memory to parse http://hpaste.org/85326, with the syntax given here: http://hpaste.org/85325 and the parser given here: http://hpaste.org/85323
18:14:16 <ab9rf> jmcarthur: what were you talking to me about?
18:14:25 <jmcarthur> ab9rf: "i wouldn't trust GHC to recognize that that clause is invariant and optimize it out"
18:14:28 <ab9rf> jmcarthur: noevermind, i figured it out
18:14:50 <hpaste> arkeet annotated “my quick shot at maximums” with “my quick shot at maximums (annotation)” at http://hpaste.org/85327#a85331
18:14:52 <ab9rf> this channel can move rather fast at times
18:14:55 <ab9rf> that or i move really lsow
18:14:58 <NemesisD> jmcarthur: so the function foo has an explicit type signature specifying the constraint FromJSON (PaginatedResponse a), but it fails to compile when it calls itself recursively
18:15:22 <jmcarthur> ab9rf: there are 976 people here right now. i'm not surprised that it moves fast sometimes
18:15:37 <pharaun> hseg_: ok have you ran a profiler?
18:15:41 <arkeet> wait.
18:15:45 <arkeet> actually, the [] case isn't needed.
18:15:50 <jmcarthur> NemesisD: i don't see why that should be a problem :\
18:15:50 <pharaun> it will tell you more details, may have a thunk leak? check the profiler
18:15:53 <arkeet> the filter predicate never runs if the list is empty.
18:15:53 <arkeet> :)
18:16:02 <arkeet> (so m is never evaluated)
18:16:02 <jmcarthur> NemesisD: fails how
18:16:04 <jmcarthur> err
18:16:07 <jmcarthur> didn't mean to send that
18:16:11 <NemesisD> jmcarthur: so would i have to do: foo :: FromJSON (PaginatedResponse a) => IO a = do; doWork; foo :: FromJSON (PaginatedResponse a) => IO a
18:16:12 <jmcarthur> i was going tot hink more
18:16:15 <jmcarthur> and now i have to do something else
18:16:22 <hseg_> No. Not yet, and I don't really know how to do it.
18:16:22 <arkeet> time to go.
18:17:09 <pharaun> hseg_: ok excellent time to figure it out, ok my reference - real world haskell, let me fin dthe chapter
18:17:55 <pharaun> hseg_: http://book.realworldhaskell.org/read/profiling-and-optimization.html
18:18:02 <hseg_> Thanks.
18:19:30 <webpyre> what haskell docking programs are therte
18:19:55 <sacundim> haddock
18:20:08 <NemesisD> this library is turning into a horrible mess before my eyes
18:20:16 <int-e> docking?
18:20:57 <jmcarthur> NemesisD: i don't understand what you mean by "foo :: FromJSON (PaginatedResponse a) => IO a = do; doWork; foo :: FromJSON (PaginatedResponse a) => IO a"
18:21:04 <jmcarthur> NemesisD: why does the foo signature appear twice?
18:21:50 <jmcarthur> NemesisD: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
18:22:35 <NemesisD> jmcarthur: hold on i think i fixed this by eliminated an unnecessary IO monad
18:23:02 <NemesisD> i was wrapping a monad that had an instance of MonadIO in an IO unnecessarily
18:23:04 <jmcarthur> "an IO monad" reads funny to me
18:23:19 <jmcarthur> i see
18:25:38 <ab9rf> jmcarthur: how so?
18:26:06 <jmcarthur> ab9rf: there is only one IO monad
18:26:14 <ab9rf> jmcarthur: ah, indeed
18:26:18 <sipa> and he does not share power
18:26:20 <ab9rf> THERE CAN BE ONLY ONE
18:26:29 <ab9rf> *cue Queen*
18:28:37 <sacundim> i think NemesisD might mean some Monad m => m (m a) -> m a business
18:31:31 <webpyre> coarbvitrary is not a visible method of class Arbitrary
18:32:33 <Fuco> is there some nicer way to pointlessify `f . g a b c' other than `(((f.).).).g' ?
18:33:46 <ab9rf> Fuco: what's wrong with (((f.).).).g?
18:34:00 <Fuco> nothing, but it's pretty ugly ;P
18:34:13 <ab9rf> really?  i think it has a rhythm to it :)
18:34:14 <no-n> what does that even do?
18:34:37 <Fuco> no-n: \a b c -> f . g a b c
18:34:47 <lewis1711> Fuco: use a fold
18:34:59 <no-n> f . g $ a b c ?
18:35:17 <hseg_> Odd. Although I recompiled Parsec for GHC 7.6.1, I now get that the module Text.Parsec.Token can't be found.
18:35:19 <Fuco> no-n: that's not pointless :P
18:35:24 <no-n> heh
18:37:15 <Fuco> I guess sometimes point-free style isn't the right choice... because what I end up now is: `(((f .) .) .) . ap ((.) . (.) . (.) . g) h' :/
18:38:46 <shachaf> Named arguments are not the devil.
18:39:10 <hseg_> OK, now I'm really getting worried about the sanity of my system. When compiling without flags, I don't get any warnings. But if I try to insert profiling flags, I get "Could not find module" errors.
18:39:39 * int-e is just hoping that  [(2k)! / k!]^2  is not supposed to be a binomial coefficient.
18:39:46 <pharaun> hseg_: you need to compile thing with profiled enabled (platform)
18:39:51 <otters> :t \f g h -> (((f .) .) .) . ap ((.) . (.) . (.) . g) h
18:39:52 <pharaun> tho i would think that it was by default enabled
18:39:53 <lambdabot> (b -> c) -> (a -> b1 -> b) -> (a -> a1 -> a2 -> a3 -> b1) -> a -> a1 -> a2 -> a3 -> c
18:39:57 <int-e> wrong channel.
18:40:20 <hseg_> ? Command line: ghc -prof Main.hs
18:40:34 <hseg_> Gives me errors that some modules couldn't be found
18:40:48 <Fuco> shachaf: yea, it's just for fun, I'm trying to write this thing point-free :P But now it's getting ridiculous :D
18:41:10 <elliott> hseg_: sounds like you haven't installed the profiling libraries for parsec
18:41:41 <hseg_> How do I do that?
18:42:15 <elliott> you can enable library profiling in ~/.cabal/config
18:42:18 <shachaf> Fuco: Sometimes people make special functions like (.:::) for this sort of thing (compose function to function that takes four arguments)... But really you're best off leaving it with named arguments.
18:42:29 <hseg_> OK.
18:45:32 <hseg_> How do I reinstall packages with profiling? I already set library-profiling to True in the config.
18:45:47 <otters> cabal install package --reinstall
18:45:53 <hseg_> Alternatively, how do I uninstall a package?
18:45:59 <otters> ghc-pkg unregister package
18:46:11 <hseg_> But cabal will hate my guts for that
18:46:19 <otters> Yeah, well, you'll have to soldier on.
18:46:32 <otters> You could cabal install the version you already have.
18:46:34 <webpyre> how would you quockcheck test a function like maximum or maximums?
18:46:42 <otters> (if it isn't the latest.)
18:46:45 <otters> Then reasonably nothing should break.
18:47:12 <hseg_> I already have the latest version. I didn't get your suggestion.
18:47:25 <otters> It doesn't have profiling installed, though.
18:47:30 <hseg_> Right.
18:47:37 <otters> So reinstall it.
18:48:07 <hseg_> But cabal says it's dangerous. I always take my warnings seriously.
18:48:16 <otters> Reinstall it anyway.
18:48:24 <otters> If you want profiling.
18:49:24 <webpyre> how would you quickcheck test a function like maximum or maximums?
18:49:55 <webpyre> could you describe in an exact manner quickehck CANNOT test?
18:50:24 <hseg_> Parsec depends on Data.Text, and trying to reinstall it says parsec might get broken.
18:50:30 <otters> It won't get broken.
18:51:03 <hseg_> So I pass --force-reinstalls?
18:51:49 <otters> yes
18:54:30 <BMeph> webpyre: What's maximums, webpyre?
18:55:44 <webpyre> maximums [1,2,3,3,3,2] => [3,3,3]
18:56:10 <webpyre> http://hpaste.org/85330
18:57:10 <webpyre> i cant think of any valuable test for quickCheck. id have to write testcases by hand
18:59:40 <hseg_> otters: FYI, I'm being forced to reinstall mtl, transformers, text, parsec by your plan. Still going through with it.
19:00:06 <shachaf> Wait, what's going on here?
19:00:16 <shachaf> Is someone --force-reinstalling?
19:01:21 <hseg_> Yep. otters said that the reason I was getting module not found errors when compiling my code with profiling flags was that the libraries weren't compiled with profiling support
19:01:53 <hseg_> So I've recompiled SHA, mtl, transformers, text, and parsec, and am now recompiling my own code.
19:02:13 <otters> Are those all the libraries that needed profiling?
19:03:05 <hseg_> Those libraries didn't *need* profiling. It's just that they weren't detected by GHC/cabal when compiling those libraries that did need profiling
19:04:12 <webpyre> so quickcheck cant name the test that failed?
19:05:20 <jacklyn> Is there a way to speed up the checking of equality? It's taking up half the running time of my program
19:05:22 <ParahSail1n> yeah it's my opinion that enable library profiling should be default true in cabal conf
19:05:57 <ParahSail1n> make it easier for people starting for the first time, so they dont have to rebuild everything when they decide they need to start profiling
19:06:02 <hseg_> Question: can one compile non-profiling code with libraries that have been compiled for profiling?
19:06:25 <ParahSail1n> yes, the regular .o and the .p_o are separate
19:06:34 <hseg_> If so, it would make loads of sense to just ship the libraries with profiling enabled by default.
19:06:47 <ParahSail1n> library-profiling builds an extra supplementary set
19:07:03 <hseg_> Why on earth are we making stuff hard on the newbies for when they need profiling?
19:07:11 <ParahSail1n> the platform ones i believe normally are shipped with the p_o files
19:07:40 <ParahSail1n> advanced people dont always consider people low on the learning curve?
19:07:53 <hseg_> No they aren't. At least not mtl, transformers and text. I had to recompile those myself
19:07:58 <elliott> hseg_: well, you're installing things by hand, and with a version of GHC different to what the platform is on (unless it's been updated)
19:08:00 <ParahSail1n> hseg_, just mv .ghc to .crap and .cabal to .crap2
19:08:01 <elliott> things are going to be rough
19:08:03 <hseg_> :-D
19:08:17 <ParahSail1n> and cabal instal from scratch, with the cabal conf enabling library profiling
19:08:33 <shachaf> ParahSail1n: Why mv .cabal?
19:08:38 <hseg_> elliott: This occurs even when compiling with the GHC from Platform
19:08:59 <ParahSail1n> shachaf, because im superstitious and dont understand how cabal works yet
19:09:10 <shachaf> @where sicp
19:09:10 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
19:09:18 <shachaf> See the third link above.
19:09:20 <ParahSail1n> the last few times i've done that, i haven't mv'd .cabal
19:09:21 <shachaf> Maybe it'll help.
19:09:30 <ParahSail1n> and it's seemed to work
19:10:01 <ParahSail1n> shachaf, ah, thanks
19:10:23 <hseg_> If we're already on the topic of changing the defaults, wouldn't it be easier on the distribution of libraries to have the libraries all be dynamically linked?
19:10:40 <adelbertc_> recently installed haskell-platform via mac os homebrew, looking to learn haskell coming from scala, any recommendations on books to pick up? if possible a book with exercises would be preferred
19:10:43 <hseg_> i.e. no cross-module code optimizations between packages?
19:10:58 <shachaf> But cross-module optimizations are important.
19:11:42 <ParahSail1n> hseg_, enabling library-profiling by default has nearly no cost, namely doubling build time maybe
19:11:56 <ParahSail1n> that would be a much more significant choice
19:13:01 <hseg_> Firstly, I meant no cross-package optimization. Secondly, it would avoid the so-called "DLL Hell" currently observed with cabal.
19:13:26 <shachaf> Cross-package optimization is important.
19:13:52 <shachaf> I rarely observe that.
19:14:16 <shachaf> In this case you're observing something which is, I think, due to a deficiency of cabal-install in reïnstalling things that use profiling, or something.
19:14:55 <webpyre> could you describe in an exact manner quickehck CANNOT test?
19:15:16 <hseg_> point 3 here, for example: http://cdsmith.wordpress.com/2011/01/16/haskells-own-dll-hell/
19:16:44 <ParahSail1n> lol nice diaresis, the new yorker
19:29:31 <hseg_> How do I get profiling information while limiting the maximum heap size? i.e. I'm using -M2G, and so my program crashes before generating profiling information.
19:35:51 <hseg_> Forget my comments above. I see that this issue has been given quite some thought and that things aren't as simple as I thought.
19:35:59 <hseg_> Anyhow, how do I get profiling information while limiting the maximum heap size? i.e. I'm using -M2G, and so my program crashes before generating profiling information.
19:45:50 <applicative> hm, adelbertc_ left when no one recommended any haskell readings.  :(
19:48:06 <hseg_> My program crashes because of a lack of memory. Even when using -M, it crashes. I don't get profiling info when it crashes. So how do I get profiling information?
19:48:20 <Ralith> hseg_: how large is your program?
19:48:24 <ab9rf> hseg_: just add more memory :)
19:48:41 <hseg_> Memory usage? It consumes 3GB before it crashes
19:48:54 <sacundim> can you reduce the input size
19:49:10 <hseg_> Input is ~0.5 KB
19:49:24 <applicative> is there something irrational about the program? did you paste it somewhere.
19:49:46 * applicative can use more memory than that with 0.0 kb input
19:49:50 <ab9rf> hehe
19:50:22 <hseg_> Basically, the crash seems centered around this module: http://hpaste.org/85323, here's the data types: http://hpaste.org/85325, and here's the input: http://hpaste.org/85326
19:51:35 <sacundim> hseg_: what i might do at this point is write quickcheck test cases for pieces of the program
19:51:46 <sacundim> because that might pinpoint the problem location more narrowly
19:51:55 <sacundim> but learning quickcheck is a bit of work
19:52:53 <sacundim> ...and I don't know how to quickcheck a parser, but there's that other testing lib
19:53:24 <hseg_> I'll try testing with simple strings.
19:56:08 <sacundim> hseg_: quick googling reveals this, dunno if you've seen it: http://blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/
20:05:17 <Apes> If I have a new type like "newtype Gear = Gear Int", how can I create a value of that type?
20:05:28 <shachaf> Gear 5
20:05:32 <shachaf> Hmm, no.
20:05:33 <shachaf> Gear 4
20:06:13 <ion> Yeah, the latter one.
20:06:35 <sacundim> some people would say that should be Gear 3
20:06:38 <sipa> fix Gear
20:06:50 <ion> Gear 3 is an abomination.
20:07:15 <sacundim> oh, wait, did i make the joke that shachaf made
20:07:35 <ion> shachaf: Joke? What’s he talking about?
20:08:06 <Apes> So newtype sets up a new class, and a default constructor is provided.
20:08:10 <Apes> Thanks for the help.
20:08:20 <Ralith> there are no classes involved
20:08:21 <ion> Not a class. Just a type.
20:08:22 <shachaf> Apes: No, there are no classes.
20:08:35 <shachaf> Apes: And this isn't a "default" constructor -- it's the only constructor you're going to get.
20:08:39 <ion> And i’m not sure what “default” constructor means here.
20:08:49 <sacundim> Apes: what Haskell calls a "class" is something else
20:08:59 <shachaf> Apes: Haskell does not do OO, or at least not this way. You should forget all OO concepts for a while while you learn Haskell.
20:09:26 <hseg_> Found the cause of the expensive memory, but not why it occurred. Note that on line 11 of the input, the parameter to label has an underscore in it, and that in the code for parsing a label statement, in line 43, everything up to the underscore is consumed, and then nothing can be consumed any more.
20:10:07 <hseg_> Although that doesn't explain why Parsec didn't balk on finding stuff for which the lookahead has no parse
20:12:21 <parcs> purely functional queues are cool
20:16:28 <wavewave> all pure functional data structures are cool
20:17:11 <sacundim> hmmm, i recall Okasaki's book showing some that weren't
20:18:05 <parcs> i ought to try to understand finger trees
20:19:07 <shachaf> edwardk had some slides about them
20:19:09 <wavewave> persistent data structure is very useful.
20:19:23 <shachaf> http://comonad.com/reader/2010/finger-trees/
20:21:31 <startling> does anyone here use heist? I've got a HeistState with some templates and some splices in it; how do I actually render the templates?
20:23:03 <hpaste> hseg annotated “Parser” with “Parser memory leak fix” at http://hpaste.org/85323#a85334
20:23:14 <applicative> hseg_: well, that was torture, but it is indeed using absurd amts of memory
20:23:26 <hseg_> Can someone explain why the fix I posted works? because I know that it works, but I don't know why.
20:23:51 <sacundim> where is the change?
20:24:07 <applicative> hseg_: it is clearly all the uses of try in the main 'statement' parser.  If I kill them, it works instantly, but fails after ten lines since it's not correct ....
20:24:08 <hseg_> http://hpaste.org/diff/85323/85334
20:24:28 <sacundim> oh.  i should learn hpaste -_-
20:24:52 <hseg_> But I can't remove the uses of try, since I have parses with common prefixes.
20:25:25 <hseg_> I can refactor it into an LL(1) grammar, but that would remove clarity.
20:25:26 <applicative> hseg_: right i wasn't meaning that, I was just investigating them, and it would of course typecheck.  I see, I didnt see the update
20:26:00 <applicative> hseg_: but it seems like you solved the main difficulty ?
20:26:57 <hseg_> The problem is solved, but I don't understand why it existed in the first place. Parsec should have errored out, saying it had no parse that starts with an underscore after having parsed everything up to the first underscore
20:29:16 <sacundim> hseg_, i don't understand any of that stuff, but general rule of thumb: at this point I would try to build a simpler example of the problem you're running into.  Either that will allow you to figure it out on your own, and if not it would be suitable for a stack overflow question...
20:30:55 <ryeguy> is there a way to read in floats without a leading digit?
20:31:03 <ryeguy> e.g. (read ".3" :: Float) throws an exception
20:31:42 <wavewave> put 0 in front forcefully ;-)
20:31:43 <genisage> read '0':string
20:31:44 <applicative> hseg_: yeah I'm not sure why it went berserk, but the offending statement would seem to be label LOOP_START or similar later
20:31:51 <hseg_> sacundim: Simple test case: parse code "" $ Data.Text.pack "label START_LOOP"
20:32:16 <sacundim> hseg_: i mean a simpler program
20:32:24 <sacundim> simpler parser
20:32:34 <jmcarthur> wavewave, genisage: you have to be careful with that. it could be a negative number
20:32:45 <ryeguy> genisage, wavewave: doh, thanks. i didn't think that 0 can be prepended blindly :D
20:33:00 <jmcarthur> ryeguy: it can't ^^
20:33:08 <jmcarthur> ryeguy: unless, at least, you know it won't be negative
20:33:13 <wavewave> jmcarthur: yes. ;-)
20:33:33 <ryeguy> jmcarthur: good point. In my case it is always positive though
20:33:38 <liyang> It's best not to use Text.Read. It's dodgey in lots of ways. Unfortunately it's part of the Haskell Report so much harder to fix.
20:33:38 <applicative> hseg_: my current crazy theory is it's   nonNLWS0 = many nonNLWS
20:33:56 <ryeguy> liyang: what alternative is there?
20:34:44 <liyang> ryeguy: I'm inclined to use attoparsec.
20:34:56 <jmcarthur> attoparsec has a float parser?
20:34:57 <liyang> Or trifecta, perhaps.
20:35:09 <liyang> jmcarthur: it has a Rational parser, I believe.
20:35:20 <hseg_> OK. What makes you believe that?
20:35:29 <jmcarthur> that would have trouble with   1.3e5
20:36:04 <liyang> jmcarthur: no, it's different from the x % y Rational parser given by the Read class. It accepts floating-point notation.
20:36:12 <nh2> what is a recommended way to import a darcs repo into git?
20:36:14 <jmcarthur> ah
20:36:25 <jmcarthur> nh2: sacrificial lamb
20:36:25 <wavewave> darcs bridget
20:36:41 <wavewave> bridge..
20:36:46 <liyang> nh2: first born would sweeten the deal.
20:37:25 <nh2> liyang: it will take me at least 9 months to get a first-born
20:37:33 <jmcarthur> lol
20:37:38 <nh2> wavewave: where do I get that? On it's wiki page it says "darcs get **TBC** darcs-bridge"
20:38:06 <startling> why are first-borns worth the most anyway? it takes much longer to get any of the others.
20:38:18 <wavewave> nh2: i used it for changing all my darcs info. I am looking for the link now.
20:38:24 <nh2> it looks like that was some gsoc project, where the projectee forgot to actually mention where the result is
20:38:34 <wavewave> s/info/repo
20:38:36 <liyang> ryeguy: but if you want to support e.g. ".2e-3" you'll have to fudge your own parser. Maybe you can reuse http://hackage.haskell.org/packages/archive/attoparsec/latest/doc/html/Data-Attoparsec-ByteString-Char8.html#v:rational or #v:double
20:39:28 <wavewave> http://darcs.net/DarcsBridgeUsage
20:39:52 <nh2> wavewave: that's where the "darcs get **TBC** darcs-bridge" is on
20:40:09 <wavewave> yeah... I now notice it.
20:40:27 <wavewave> I did the change last year (around this time. )
20:41:04 <nh2> wavewave: I have a grand plan: if you have a darcs-bridge repo around, you could run darcs-bridge on it and upload it to github
20:41:23 <liyang> :t Data.Attoparsec.ByteString.Char8.rational
20:41:24 <lambdabot> Couldn't find qualified module.
20:42:12 <nh2> I'll go to #darcs in the meantime and ask if they know more
20:44:59 <nh2> wavewave: http://www.owenstephens.co.uk/programming/2011/07/12/gsoc-project-darcs-bridge.html this might be it
20:45:23 <nh2> eww "404: repository does not exist"
20:46:08 <pygmalion> I'm giving Haskell another try after a lot of OCaml programming. I'm trying to do something that is very common in OCaml, defining a nested function, and unable to find the syntax that works for Haskell. Here's a simplified snippet in OCaml: https://gist.github.com/pygatea/c73c9f192bcec7855fbf
20:46:30 <pygmalion> I can't figure out how to do something like those nested let expressions in Haskell.
20:47:09 <shachaf> > let f x = let g y = let a = 2 in let b = 3 in a * b * y in g x in f 5
20:47:11 <lambdabot>   30
20:47:18 <shachaf> Works for me.
20:47:25 <arkeet> pygmalion: it's almost exactly the same. mind layout, though
20:47:30 <shachaf> (You'd probably write it a bit differently but generally it works.)
20:47:42 <arkeet> everything inside the let has to be indented further than the let.
20:47:48 <arkeet> er
20:47:56 <arkeet> is that right?
20:48:40 <shachaf> > let { f x = let { g y = let { a = 2 } in let { b = 3 } in a * b * y } in g x } in f 5 -- more {}
20:48:42 <lambdabot>   30
20:48:48 <hseg_> OK, time for bed. Will finish figuring this out later.
20:48:59 <shachaf> > let { f x = let { g y = let { a = 2; b = 3 } in a * b * y } in g x } in f 5 -- you can define multiple things in one let
20:49:01 <lambdabot>   30
20:49:03 <nh2> wavewave: http://hub.darcs.net/owst/darcs-bridge-export-branch "DO NOT USE, unless you know EXACTLY what you are doing (which you don't, because I don't!)"
20:49:39 <arkeet> > let f x = let {g y = a*b*y; a=2; b=3} in g x in f 5
20:49:40 <lambdabot>   30
20:50:05 <arkeet> > 30
20:50:07 <lambdabot>   30
20:50:58 <pygmalion> arkeet: Thanks! Maybe this is my issue, can you have a let nested within a where?
20:51:07 <shachaf> Yes.
20:51:15 <shachaf> If you have Haskell code which isn't working, I suggest you @paste it.
20:51:21 <arkeet> @paste
20:51:21 <lambdabot> Haskell pastebin: http://hpaste.org/
20:51:30 <shachaf> Otherwise people will have to guess randomly at what you're doing, which is frustrating for everyone.
20:51:59 <nh2> wavewave: do you have a copy around because I really can't find it
20:52:21 <wavewave> nh2: unfortunately, I cannot find a copy now.
20:52:23 <pygmalion> Yes, sorry. I'm actually unsure if it's actually an issue with the code or just an issue with haskell-mode in emacs not being robust enough to validate the syntax. I'll come back if it's the former.
20:52:52 <pygmalion> Also, shachaf, what's the more Haskell-y way to write that snippet? (you say you'd probably write it a bit differently)
20:52:54 <wavewave> nh2: probably on my computer in my office.. but right now I cannot connect there.
20:53:10 <nh2> wavewave: ok
20:53:11 <wavewave> at least not present on my laptop.
20:53:34 <flebron> Hi. I thought interact was what I wanted, but apparently not. How can I read lines from stdin, and output f of each line to stdout?
20:53:41 <arkeet> pygmalion: you can bind multiple things with one let.
20:53:42 <flebron> (Where f :: String -> String.)
20:53:49 <wavewave> if I find it, then I will put it on my github (http://github.com/wavewave)
20:53:49 <lightquake> is there a list somewhere of which version of ghc has which version of base?
20:53:51 <jmcarthur> :t interact -- flebron
20:53:52 <lambdabot> (String -> String) -> IO ()
20:53:57 <shachaf> flebron: interact wiith lines and unlines
20:54:00 <flebron> jmcarthur, apparently it's not exactly that :s
20:54:05 <jmcarthur> oh right, using lines and unlines
20:54:14 <flebron> I should unlines and then fmap?
20:54:20 <jmcarthur> :t \f -> interact $ unlines . map f . lines
20:54:22 <lambdabot> (String -> String) -> IO ()
20:54:22 <arkeet> interact takes a function that transforms the entire input and gives the entire output.
20:54:22 <mauke> no, you should lines, then map f
20:54:33 <lightquake> arkeet: oh, right
20:55:15 <jmcarthur> :t interact . (unlines .) . (. lines) . map  -- i think i got this right, but i don't think i recommend this
20:55:17 <lambdabot> (String -> String) -> IO ()
20:55:21 <flebron> Huh. So interact is literally just x <- getContents   f x?
20:55:28 <flebron> (Where the "   " is a newline. :s)
20:55:35 <jmcarthur> flebron: well, along with putStr
20:55:38 <jmcarthur> @src interact
20:55:38 <lambdabot> interact f = do s <- getContents; putStr (f s)
20:55:38 <arkeet> :t interact . over (iso lines unlines . mapped)
20:55:39 <lambdabot> (String -> String) -> IO ()
20:55:42 <flebron> Oh right, putStr, not just f x.
20:55:51 <flebron> f x is not an IO _. :)
20:56:10 <jmcarthur> arkeet: you and your lens fanciness
20:56:17 <jmcarthur> i learned lens and still rarely use it
20:56:20 <nh2> wavewave: ahh I've got it http://darcsden.com/mornfall/darcs-fastconvert
20:56:26 <nh2> "including Owen's changes GSoC 2011 (fork of owst's darcs-fastconvert-gsoc) "
20:56:32 <arkeet> I keep forgetting which way iso goes.
20:56:38 <nh2> they should really update that wiki page
20:56:41 <arkeet> it's worsened by the fact that it's opposite from prism
20:57:17 <wavewave> nh2: great! good to know that. I might have some forgotten darcs repo in my directories.
20:57:52 <arkeet> > over (iso lines unlines . mapped) (show . length) "abc\nde\nf"
20:57:53 <lambdabot>   "3\n2\n1\n"
20:58:02 <shachaf> arkeet: Use more involutions.
20:58:06 <liyang> pygmalion: Haskell has where-clauses. This was my one major dislike regarding O'Caml.
20:58:08 <arkeet> shachaf: =(
20:59:01 <shachaf> liyang: Does "where" even make sense in OCaml?
20:59:04 <wavewave> nh2: hmm not compilable on my machine due to unix-compat.
20:59:06 <applicative> the "where" just by itself is a work of genius
20:59:51 <lightquake> in particular, I'd like to know when base got upgraded to 4.4
20:59:52 <liyang> shachaf: does OCaml even make sense with its strictness?
21:00:07 <jmcarthur> yes
21:00:08 <lightquake> actually, now i want to know how you'd do the lines thing with pipes
21:00:13 <wavewave> lightquake : check this http://www.haskell.org/ghc/dist/
21:00:17 <applicative> strictness is for chumps; it breaks referential transparency
21:00:30 <jmcarthur> applicative: what?
21:00:32 <Ralith> liyang: what's so great about where?
21:00:38 <wavewave> lightquake : rather brute force but at least possible to know.
21:00:49 <Ralith> applicative: allocating memory is for chumps, it etc etc :P
21:00:51 <jmcarthur> applicative: in what way?
21:00:58 <liyang> Ralith: it lets me write things leaving all the footnotes at the bottom.
21:01:16 <liyang> Ralith: so as not to interrupt the main text, as it were.
21:01:59 <Ralith> that was cause for "major dislike"?
21:02:01 <jmcarthur> in any conversation about strictness and non-strictness, i always find myself defending whichever one is the underdog
21:02:01 <applicative> jmcarthur: that's my new insane theory. oleg's LazyIOBreaksReferentialTransparency.hs just proves that strict length + semi-strict-IO are no good
21:02:04 <shachaf> liyang: Do you even make sense?
21:02:11 <jmcarthur> haha
21:02:27 <flebron> Stylistically, I like where better than let.
21:02:34 <liyang> shachaf: I try my best. =)
21:02:35 <wavewave> lightquake : better http://www.haskell.org/ghc/docs
21:03:11 * applicative would forbid let, but there seems no better way to get sharing in plenty of contexts
21:03:14 <flebron> If you see the definition of the function, you can skip it if you already can infer what it is from the names of the variables I've used. If you want more, you keep reading the tabbed "where".
21:03:19 <liyang> shachaf: you know by now that anything I say should be considered at least half-trolling. :)
21:03:51 <liyang> Ralith: half-trolling. :)
21:03:54 <wavewave> lightquake: for example, ghc-6.12.2 has base 4.2.0.1 according to http://www.haskell.org/ghc/docs/6.12.2/html/libraries/
21:04:02 <liyang> Ralith: but major annoyance at least.
21:04:03 <lightquake> wavewave: good to know, thanks :)
21:04:07 <hseg> Was noting the bug to fix later, when I realized that line 48 here: http://hpaste.org/85313 means that if the line doesn't match anything and isn't empty or a comment, Parsec will generate an infinite list of Nothing in line  87
21:04:32 <lightquake> does ghc provide a way to try to poke bytes of memory into arbitrary addresses?
21:04:34 <Ralith> liyang: never used it much myself, save for things like recursive accumulators
21:04:42 <Ralith> maybe I should try applying it more
21:05:29 <liyang> Ralith: I pretty much never use let ... in clauses. let ... in do-blocks only.
21:05:30 <arkeet> lightquake: getLineS >-> mapD f >-> putStrLnD
21:05:36 <lightquake> arkeet: neat
21:05:48 <hseg> i.e. Parsec would consume everything up to the first underscore, and then the manyTill statement eof would cause it to infinitely attempt to parse the underscore using the statement parser. statement would return Nothing and wouldn't consume anything. Cue infinite memory usage and infinite loop.
21:06:06 <liyang> Ralith: s/clauses/expressions/
21:06:10 <nh2> wavewave: I updated the wiki
21:06:36 <wavewave> nh2: cool. thanks for  that effort.
21:06:47 <pharaun> hseg: haha
21:06:52 <pharaun> hseg: nice discovery
21:06:58 <pharaun> hseg: did you try the profiling stuff
21:07:40 <hseg> Yes. I had to rebuild loads of stuff, and then because my program never terminated, I couldn't get profiling info.
21:07:54 <arkeet> I suppose one would want to handle EOF.
21:08:05 <hseg> There should be an option to display continuous profiling info on stderr
21:08:12 <applicative> hseg: I see, so the label parser succeeded up to label whatever, then found an infinite list of Nothing statements
21:08:46 <hseg> Right. So I need to find some way of making the statement parser fail if it doesn't consume anything.
21:09:03 <applicative> label LOOP_START or rather, up to the underscore
21:09:18 <liyang> Ralith: and only when the RHS of the do-block let-clause actually depends on something bound earlier.
21:09:22 <hseg> Right.
21:09:26 <niteria> if agda makes you a better haskell programmer, what makes you a better agda programmer?
21:09:48 <Ralith> formal study of intuitionistic logic?
21:09:49 <hseg> niteria: the oracle to the halting problem
21:09:51 <liyang> niteria: Martin-Löf.
21:09:54 <hseg> :-)
21:10:02 <applicative> the number of key bindings you know, maybe
21:10:20 <liyang> And how well you know your Unicode.
21:10:31 <applicative> Martin-Löf is a terrible agda programmer
21:11:14 <liyang> (And your tolerance of Emacs.)
21:11:16 <niteria> I get the feeling that people can unify arbitrary things in their heads when they use implicit arguments
21:11:47 <hseg> Anyhow, I'm off to bed, finally. I shall probably see you guys in ~7 hours. Still have a bunch of code to write and test cases to run.
21:14:12 <arkeet> hmmm
21:14:19 <arkeet> I wonder why hGetLineS handles eof and getLineS doesn't?
21:14:31 <liyang> niteria: at some point it all coalesces into inituition.
21:15:58 <pharaun> emacs is what makes me sad about agda
21:16:02 <niteria> I haven't really used much agda, but I'm afraid that when you write agda code you get to the point where you have some code written, you write a new function and you realise you aren't propagating some proof you need and you have to rewrite everything to propagate it
21:16:21 <liyang> Emacs makes me a sad pagda. :<
21:16:28 <niteria> in other words I'm afraid agda isn't modular
21:16:39 <shachaf> @arrrr
21:16:39 <lambdabot> Avast!
21:16:58 <applicative> stictness and modularity dont go together
21:17:08 <liyang> Does Chris Done hang around here?
21:17:16 <shachaf> Sometimes.
21:17:16 <Ralith> niteria: my limited experience coding in Idris indicates that it's not hard to propagate everything
21:17:35 <applicative> idris is a picnic
21:17:38 <liyang> He's been doing a structural editor thing which might make a nice front-end for Agda or Epigram.
21:17:45 <Ralith> it seems to be pretty obvious when you discard something
21:18:01 * liyang should take a look at Idris...
21:18:09 <Ralith> since it generally involves literally discarding some variable
21:18:17 <applicative> it really is pretty amazing
21:18:21 <Ralith> so just keep an eye out for _s in bindings
21:18:27 <Ralith> er, pattern matches
21:18:30 <niteria> I see
21:18:38 <Ralith> and variables that could be replaced with one of coures
21:18:42 <Ralith> course*
21:19:07 <Ralith> also, it doesn't seem to be that hard to add propagation you forgot so long as there's no nontrivial proving involved
21:19:35 <niteria> so, do you end up with all functions taking everything in form of 9000 parameters or some god record?
21:20:11 <applicative> foo _ _ _ _ _ _ _ _ _ Z _ _ _ = Z
21:20:21 <Ralith> implicit parameters help
21:20:29 <Ralith> so does good factoring
21:20:56 <Ralith> I wrote a 'find' on Vect that doesn't lose any information for Idris recently, and the return type is a bit bulky, I admit
21:21:01 <applicative> foo _ _ _ _  {S Z }_ _ _ _ Z _ _ {Z} = Z
21:21:28 <Ralith> Either (All (\x => Not (P x)) xs) (y : a ** (P y, (i : Fin n ** y = index i xs)))
21:22:05 <niteria> use more unicode ;p
21:22:18 <Ralith> I think Idris is meant to be usable from things other than emacs
21:22:55 * applicative uses it in his moronic textmate with slight adjustments to the haskell package
21:23:06 * elliott thinks it's probably best to prove properties about a simpler definition of find than to stuff it all into the type like that
21:23:31 <Ralith> it is a very simple definition!
21:23:43 <Ralith> it's just that sometimes you want the index, sometimes you want the value, and sometimes you want both.
21:24:04 <applicative> 'either it's P everywhere, or there's somewhere where it isn't '
21:24:09 <elliott> s/definition/type/
21:24:49 <Ralith> my goal there was to avoid the need for redundant traversals without losing useful proofs
21:25:28 <Ralith> of course you can make it a lot cleaner if you don't care about (constant factors of) runtime
21:26:29 <Ralith> also as applicative points out it's perfectly friendly, just large.
21:27:31 <niteria> can the use of unary encoding for numbers hurt performance if it is only used in types?
21:27:44 <Ralith> what do you mean by "only used in types"?
21:28:04 <arkeet> type-level naturals
21:28:12 <arkeet> I assume
21:28:17 <liyang> DTP? Runtime performance? Hahahahaaa. Let me get back to you in a decade or two.
21:28:36 <Ralith> dependent types don't have type-level things because types are value-level
21:28:48 <Ralith> liyang: *you* get back to *me* in a year :P
21:28:51 <liyang> (FSVO 'value'.)
21:29:06 <startling> it's like python!
21:29:18 <startling> classes are objects!
21:29:24 <arkeet> oh you're talking about dependent types.
21:29:29 <liyang> And Set is in Set!
21:30:00 <Ralith> niteria: in general, doing what you want is part of erasure, and isn't always easy.
21:30:22 <arkeet> hmm
21:30:29 <arkeet> machines is easy.
21:30:36 <niteria> no one talks about performance with DTP, I wondered if it is because no one cares or if it is hard
21:30:41 <arkeet> it would be nice if it came with a bunch of pre-built machines for IO or something
21:30:46 <Ralith> Idris cares about performance.
21:31:11 <liyang> niteria: I don't think we're at that point yet. And what Ralith said.
21:31:19 <Ralith> it's an active research area
21:31:24 <Ralith> afaik Idris is leading the charge
21:31:28 * liyang wonders what Idris sacrafices for performance.
21:31:39 <Ralith> maturity
21:31:40 <Ralith> ^^
21:31:53 <liyang> I see...
21:32:15 <Ralith> DT impls haven't historically tried very hard for perf, afaik
21:32:27 <Ralith> so there's a lot of progress to be made that doesn't entail tradeoffs.
21:32:48 <Ralith> a fair bit of low hanging fruit, even.
21:32:53 <liyang> Sure, it's not considered that important because no one's using it for heavy computation yet.
21:32:59 <Ralith> exactly
21:33:02 <liyang> Right now, fast later.
21:33:39 <Ralith> niteria: with regard to your specific question, in theory a whole-program analysis could completely erase nats that are not inspected at runtime.
21:34:13 <Ralith> local analyses will have a harder time because it is very easy to pull indexes like that *out* of types.
21:34:16 <arkeet> lightquake: machines version: runT_ $ getLineS ~> auto f ~> putStrLnM
21:34:21 <niteria> in theory lazy IO in haskell could be smarter :)
21:34:22 <arkeet> where getLineS and putStrLnM are suitably defined machines.
21:34:50 <Ralith> for example, for Vect : Type -> Nat -> Type, you can write length : Vect a n -> Nat; length {n=n} _ = n
21:34:59 <applicative> there isn't any reason to think Idris wont end up being as fast as you please, for one thing optimizations arising from totality will be possible
21:35:30 * Ralith is very excited about breaking performance barriers with idris
21:35:44 <arkeet> and they're easy to define, e.g. getLineS = repeatedly $ liftIO getLine >>= yield
21:35:50 <arkeet> (well, this doesn't handle eof)
21:36:47 <niteria> cool, can it be assumed that you don't pay for proofs in performance?
21:37:16 <Ralith> in theory, proofs can be made to be free.
21:37:27 <Ralith> in practice there are some harder things, but often they will be free anyway.
21:37:55 <liyang> Any time I've heard edwinb, he's always on about some band named "Erasure".
21:38:22 <Ralith> for example, Idris is currently capable of erasing anything that manipulates values whose types are inhabited by only one value
21:38:42 <Ralith> this describes all equality proofs
21:38:56 <applicative> even in coq its a big point that proofs can erased. I suppose someone has actually compiled  a program
21:39:00 <Ralith> however, it does not describe inductive proofs
21:39:38 <Ralith> I'm not deeply familiar with what other kinds of erasure idris does, but I do know that when I'm debugging codegen output there are a *lot* of erased values.
21:40:51 <Ralith> also note that insofar as they don't perform abysmally, whole-program analyses are viable.
21:40:52 <niteria> I'm thinking of doing my master's degree in some DT language
21:41:24 <Ralith> I think separate compilation of dependently typed code is fairly futile
21:41:30 <Ralith> niteria: where are you located?
21:41:37 <niteria> Poland, Warsaw
21:41:43 <Ralith> dammit.
21:41:53 <nh2> wavewave: https://github.com/nh2/darcs-fastconvert
21:41:55 <Ralith> all the DT people are in europe >.<
21:41:57 <liyang> niteria: I did my PhD in some DT language. It was painful. (Though I learnt a lot.) Might have been better if I did it *on* a DT language.
21:42:03 <nh2> wavewave: I fixed the compilation, can you try?
21:42:04 * Ralith is lonely on the west coast
21:42:12 <Ralith> (of north america)
21:42:22 <Ralith> liyang: that's one of my candidate career plans
21:43:00 <shachaf> Ralith: Come to California!
21:43:02 <niteria> liyang: I think I'll write some library with Agda or Idris
21:43:04 <Ralith> shachaf: what's in california?
21:43:12 <shachaf> Everything that matters.
21:43:14 <lightquake> arkeet: machines?
21:43:15 <Ralith> :P
21:43:28 <Ralith> if I go for grad school I'm thinking about berkeley
21:43:34 <niteria> Ralith: they are in Europe but not in Poland
21:43:36 <Ralith> no idea if they'd want me though
21:43:49 * liyang feels he's warming back up to hacking in Agda or something else now, after the trauma of his thesis.
21:44:04 <shachaf> They like dependent types in PSU, don't they?
21:44:11 <Ralith> PSU?
21:44:20 <shachaf> Portland State University
21:44:23 <shachaf> Or am I mixing it up?
21:44:31 <Ralith> if so, that would definitely be nice to know
21:44:41 <simpson> There are definitely many Haskell hackers here.
21:44:42 <niteria> liyang: is your thesis available anywhere?
21:44:43 <elliott> Power Supply Unit
21:44:45 <shachaf> larrytheliquid is doing his PhD there and I think I've also heard of some other people
21:44:48 <Ralith> berkeley would be great but I'm not optimistic with my 3.2ish gpa
21:44:49 <bos> oh dear
21:45:08 * shachaf wonders whether this is more of a #-blah discussion by now.
21:45:09 <bos> i cannot persuade cabal to compile a .hsc file in a test suite
21:45:10 <liyang> niteria: draft on cs.nott.ac.uk/~gmh somewhere. I'll put it up on GitHub eventually.
21:45:26 <lewis1711> hello liyang. I see you on my facebook sometimes
21:45:46 <Ralith> niteria: you should join #idris and hang out
21:45:48 <Ralith> we have cookies!
21:45:53 <shachaf> liyang: Now you're Graham Hutton, too?
21:46:14 <lewis1711> I see him as well.
21:46:54 * liyang had the impression that most TT-based DTP is European. Of course, there's a whole subculture of misguided 'DTP' with the likes of DepML and ATS &c...
21:47:14 <liyang> lewis1711: OMG. Worlds colliding.
21:47:19 <niteria> Ralith: it's only fair since I'm already on #agda
21:47:32 <niteria> liyang: it's colorful
21:47:51 <lewis1711> liyang: yes, I am laurences friend.
21:47:53 <niteria> and unicode'y
21:48:04 <liyang> shachaf: I've been too depressed wrt the whole thing to actually put it up on my own site. ¬_¬
21:48:14 <Ralith> liyang: I've always felt suspicious of that stuff, but why do you say it's misguided?
21:48:17 <root____1> q
21:48:19 <root____1> q
21:49:04 <elliott> root____1: consider other letters.
21:49:51 <applicative> > a
21:49:52 <lambdabot>   a
21:50:04 <liyang> Ralith: they focus so much on practicality that much of the potential of DTP has been thrown out with the bathwater, as it were. Just my impression.
21:50:46 <liyang> lewis1711: I know you... ¬_¬
21:50:50 <Ralith> liyang: mine as well; was curious if someone had a more well researched opinion
21:52:26 <ab9rf> >
21:54:01 <sacundim> if i ever ascend to divine status I want a Monad m => (a -> m b) -> m (a -> b) function.  cuz i just keep trying to do stuff that requires one...
21:54:18 <pygmalion> So I'm putStr'ing a the output of a function (after applying show to the result) and getting <<loop>>, any clues on debugging this?
21:54:39 <arkeet> pygmalion: probably the function itself is looping.
21:55:46 <pygmalion> arkeet: So maybe I should run it in ghci and set a breakpoint and see what's going on...
21:55:53 <liyang> Ralith: I don't know. They're not marketing those languages towards someone like me in any case, so I'm less inclined to find out.
21:56:08 * Ralith nod
21:58:03 * hackagebot stable-maps 0.0.3.3 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.3.3 (EdwardKmett)
22:00:08 <flebron> What's a straightforward way of grouping pairs of consecutive elements in a list into tuples, that's better than the obvious list comprehension? i.e. [a, b, c, d, e, f] -> [(a, b), (c, d), (e, f)]
22:01:25 <wavewave> flebron : use chunksOf in split package
22:01:27 <arkeet> flebron: what would you do for an odd-length list?
22:01:39 <flebron> arkeet: My input has no such list :)
22:01:48 <arkeet> sketchy.
22:02:06 <flebron> chunksOf it is :)
22:02:15 <flebron> arkeet: Programming contest problem, that's the input specification.
22:02:39 <nh2> luite: can I clone repos from http://hdiff.luite.com ?
22:02:59 <ab9rf> hm, is there an uninterleave?
22:04:26 <wavewave> nh2: I tried to compile darcs-fastconvert. still failed with Not in scope: `catch'  , which need pretty simple fix.
22:04:42 <nh2> wavewave: ah, the standard 7.6 problem
22:05:17 <nh2> wavewave: do you want to fix that and send a pull request? installing the deps on my 7.6 would take ages again
22:07:28 <Bike> Does GHC still have subkinding?
22:09:46 <luite> nh2: i don't think that supported, not sure. why would you want to do that though, they don't contain the real commits
22:09:53 <luite> only one for each uploaded version
22:10:27 <nh2> luite: I know, but still better than no history at all. I need a clone of fingertree-psqueue
22:12:28 <luite> oh hey, looks like   git clone http://hdiff.luite.com/cgit/fingertree-psqueue/
22:12:30 <luite> just works :)
22:12:44 <luite> guess i forgot to disable it in cgit
22:12:58 <luite> well so far nobody's been abusing it so it should be ok
22:16:49 <lewis1711> what does "Lol (Lmao, Rofl)" mean as a type? a functor that works on a tuple?
22:18:16 <applicative> it looks like there should be Lol Char too
22:18:35 <nh2> luite: that is nice! maybe you should use that cgit option that allows you to make a clone url public - might be useful.
22:18:40 <applicative> Lol ()
22:19:16 <arkeet> how much space does hdiff use?
22:19:21 <wavewave> nh2: I made change and sent a pull request to you. Since I do not have ghc-7.4 now, would you check it for ghc-7.4?
22:19:32 <nh2> wavewave: sure
22:20:19 <luite> arkeet: dunno, it's a lot of files, which probably have some overhead, the hackage archive is not that big though, under 2GB last time i checked
22:20:25 <BMeph> "Some people who are worried about their programming skills, say 'I know, I'll join a programming contest!' Now they have two problems. Of multiple parts."
22:21:14 <Ralith> and a time limit!
22:21:35 <Ralith> time limits make me program badly, because they make me reluctant to do anything exploratory
22:22:04 <arkeet> luite: ah, that's not that large then
22:22:16 <lewis1711> if you want the actual example, it's "download :: String -> Shpider (ShpiderCode, Page)" but I see it a lot
22:23:04 * hackagebot vinyl 0.1.1.1 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.1.1.1 (JonSterling)
22:23:06 * hackagebot vinyl 0.1.1.2 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.1.1.2 (JonSterling)
22:24:06 <applicative> lewis1711: yes, the (SphiderCode,Page) is just appearing there as any old type If Shpider is a functor then fmap snd . download :: String -> Shpider Page
22:24:54 <nh2> wavewave: almost, I had to import "as E". But now pushed and it should work on both.
22:25:56 <lewis1711> I don't like this library. I can't use it on the commandline because its types don't derive show
22:26:20 <lewis1711> interpreter I mean
22:29:16 <wavewave> nh2: thanks. now I checked darcs-fastconvert by converting gnuplot darcs repo to gnuplot git repo.
22:29:29 <wavewave> nh2: you can see the result at http://github.com/wavewave/gnuplot.git
22:29:35 <nh2> wavewave: nice
22:29:37 <wavewave> works fine.
22:31:10 <wavewave> I was about to add a new functionality to gnuplot package. to use cairolatex terminal for supporting both latex text and transparency.
22:49:37 <hpaste> vamega pasted “Naked Expressions” at http://hpaste.org/85339
22:49:57 <vamega> Hi, was wondering if I could get some help figuring out why the above isn't compiling?
22:50:38 <niteria> what's the error message?
22:50:52 <vamega> Queries.hs:65:1: Parse error: naked expression at top level
22:51:11 <shachaf> vamega: Ah. Look at line 56.
22:51:12 <vamega> From what stackoverflow tells me about that error message
22:51:15 <shachaf> Er, 65.
22:51:17 <niteria> you quoted type declaration
22:51:49 <vamega> Ah
22:51:53 <vamega> Nevermind
22:51:59 <vamega> Sorry about that.
22:52:08 <vamega> I'm feeling rather idiotic now.
22:54:24 <vamega> For questions about snap.
22:54:31 <vamega> Is this an appropriate place to ask
22:54:42 <vamega> Or should I be heading to another channel?
22:54:51 <elliott> I think there is #snap or #snapframework or something?
22:55:17 <vamega> Thanks
22:55:22 <vamega> Going over there now
22:55:23 <shachaf> @where web
22:55:23 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
23:07:17 <Guest89391> @pl \xs n -> take n xs
23:07:17 <lambdabot> flip take
23:27:20 <neutrality> #join #haskell
23:28:09 <neutrality> Has anybody used digestive-functors-heist with jquery
23:28:45 <neutrality> The id names that df is choosing seems to be throwing off the css selectors
23:29:36 <neutrality> for example jquery doesn't like $("#myform.name")
23:30:31 <neutrality> Bah, I'll just go play legend of grimrock
23:35:59 <lewis1711> I'm a little confused about standalone deriving. what's the syntax for type A (B, C) ? I've tried "instance deriving Show A", "instance deriving Show A (B, C)", none work
23:36:07 <lewis1711> it says B and C already derive show
23:37:57 <neutrality> lewis: paste some code please
23:38:00 <arkeet> lewis1711: what do you mean by type A (B,C)?
23:38:11 <arkeet> what exactly is the data type?
23:38:23 <arkeet> btw, it's "deriving instance", not "instance deriving"
23:39:39 <lewis1711> ok maybe I should start from the beginning. The author of a lib forgot to derive show and i want to use it from the commandline. so I ran ghci with "-XStandaloneDeriving"
23:41:13 <arkeet> data ... = ... ?
23:41:49 <lewis1711> sorry? :)
23:43:28 <arkeet> well
23:43:30 <arkeet> in general
23:44:05 <arkeet> if in principle you could write your own instance: instance [constraints =>] Show (your type) where ...
23:44:08 <arkeet> then you just write
23:44:13 <arkeet> deriving instance [constraints =>] Show (your type)
23:45:18 <lewis1711> the specific error is " No instance for (Show (String -> Shpider (ShpiderCode, Page)))"
23:45:30 <lewis1711> I'm a bit over my head here, basically I like trying out libs from the commandline
23:47:03 <arkeet> well obviously there's no Show instance fo rfunctions.
23:47:45 <lightquake> lewis1711: how would you Show a function?
23:48:03 <lewis1711> ok bad example
23:48:10 <lewis1711> 'No instance for (Show (Shpider (ShpiderCode, Page)))'
23:48:20 <lewis1711> when i try and use the function, I give it an argument
23:49:10 <lightquake> the reason you can't Show that is because it's equivalent to a function
23:49:20 <arkeet> why don't you show some code?
23:49:29 <arkeet> like the declaration for the data type you're trying to derive Show for
23:49:31 <shachaf> arkeet: Because code is equivalent to a function.
23:49:39 <arkeet> I hate you ,shachaf
23:49:56 <shachaf> imo you should hate lightquake instead
23:49:59 <lightquake> arkeet: Shpider is StateT ShpiderState IO
23:50:21 <lewis1711> arkeet: it's not my code
23:50:41 <shachaf> lewis1711: You are not going to be able to derive a Show instance for that type.
23:51:01 <lewis1711> oh
23:51:12 <lewis1711> well that's a bummer
23:51:49 <lightquake> @unmtl StateT ShpiderState IO (ShpiderCode, Page)
23:51:49 <lambdabot> ShpiderState -> IO (ShpiderCode, Page, ShpiderState)
23:51:54 <lightquake> yeah, you can't show that
23:52:36 <ion> Huh. unmtl does interesting things with tuples.
23:52:58 <lightquake> oh huh i just noticed that
23:53:33 <ion> @unmtl StateT a m (b,c,d,e,f)
23:53:33 <lambdabot> a -> m (b, c, d, e, f, a)
23:54:03 <shachaf> @untml (a,(b,c))
23:54:03 <lambdabot> Maybe you meant: unmtl unpl
23:54:07 <shachaf> @unmtl (a,(b,c))
23:54:07 <lambdabot> (a, (b, c))
23:54:14 <arkeet> @unmtl Identity (a,(b,c))
23:54:14 <lambdabot> (a, (b, c))
23:54:19 <lewis1711> why can't you show it, exactly?
23:54:26 <arkeet> lewis1711: because you can't show functions.
23:54:29 <lewis1711> the answer may be way over my head but..
23:54:37 <lewis1711> ok, right
23:54:46 <arkeet> and it wraps a function.
23:58:40 <lewis1711> I thought it was a computation?
