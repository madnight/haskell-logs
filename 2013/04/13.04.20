00:02:11 <hamid> haskell is amazigly flexible but is it possible to fetch out the parameters of the a curried function? I mean I want to find out what x is in (+x); e.g. x in (+3) is 3. Or just it's in my imagination? :P
00:02:55 <edwardk> hamid: in that case just apply it to 0 ;)
00:03:00 <Trollkastel> hamid: I do not think you can do that. :-|
00:03:02 <edwardk> hamid: in general, no you can't do that
00:03:08 <Trollkastel> hamid: I mean, in the general case.
00:04:33 * hackagebot simple 0.4.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.4.0 (AmitLevy)
00:05:06 <edwardk> man, that is a package name even I envy.
00:05:27 <simpson> edwardk: Make a package "simply" with a type "Simply".
00:05:34 <simpson> Simply do this thing please
00:05:35 <hamid> hmm yeah i thought so :D
00:05:45 <hamid> edwardk, Trollkastel thanks :)
00:05:50 <edwardk> hamid: its a feature not a bug ;)
00:06:19 <edwardk> hamid: otherwise you'd have distinguishable equality between lots of different functions that are otherwise equivalent
00:06:35 <edwardk> if you want a defunctionalized representation store it defunctionalized
00:06:50 <vhz> edwardk: "Simple" is still available :p
00:06:54 <edwardk> then write an interpreter for it
00:07:13 <hamid> hmm edwardk seems fair. i wanted a magic :P
00:07:31 <hamid> s/i/but i/
00:08:02 <edwardk> hamid: your magic would cost everyone else a _lot_ of performance, because all of a sudden most optimizations the compiler can currently do would become unsound
00:08:45 <hamid> edwardk, hmm that's what noobs always want ;)
00:08:58 <edwardk> r5rs scheme for instance makes it so every lambda carries with it a notion of location, this makes it so you can take a function and compare it for equality with itself and it'll say 'true' or 'false' based on if its the same closure, etc.
00:09:18 <edwardk> but this means that the compiler can't freely optimize away functions or change representations unless it knows you never use that feature
00:09:56 <edwardk> that requires control flow analysis which is quite difficult in particular cases and often impossible in practice, just to get back to where you started without that feature
00:10:24 <edwardk> the alternative is to just do the optimization without respect for that operation, but then you lose the ability to reason about the behavior of your program
00:10:52 <edwardk> both strike me as disastrously disproportional issues to introduce for a convenience of that sort ;)
00:11:40 <simpson> I'm reminded of a thing I read today about EQ.
00:12:24 <simpson> http://www.erights.org/elib/equality/grant-matcher/
00:12:34 <elliott> edwardk: your package would have to be called "complex".
00:12:50 <hamid> :)
00:12:56 <Trollkastel> Is there any way to read 4 or 8 bytes from a Handle, and store the result in a Word32 or Word64?
00:13:26 <elliott> scheme also lets you sweep away the definition of + from under another function.
00:13:41 <elliott> so i think even optimising arithmetic is sort of forbidden.
00:16:58 <arkeet> Trollkastel: depending on what you're doing, you may want something like the binary package
00:17:50 <Trollkastel> arkeet: ty, I will have a look.
00:18:00 <edwardk> elliott: hahaha
00:18:35 <DiegoNolan> How do you extend functions for type synonyms?
00:18:36 <arkeet> dynamic scope makes no sense.
00:18:40 <arkeet> DiegoNolan: extend?
00:18:44 <DiegoNolan> like
00:18:55 <DiegoNolan> type Matrix = [[Double]]
00:19:01 <DiegoNolan> how would i get head to work on that ?
00:19:10 <arkeet> you just do it
00:19:11 <DiegoNolan> Or any other list functions
00:19:16 <edwardk> head does work on that
00:19:20 <DiegoNolan> really?
00:19:26 <arkeet> yes, it's a type synonym.
00:19:29 <edwardk> > head [[1,2,3,4],[5,6,7,8]]
00:19:32 <Trollkastel> DiegoNolan: A type synonym is a... synonym.
00:19:34 <lambdabot>   mueval-core: Time limit exceeded
00:19:37 <edwardk> > head [[1,2,3,4],[5,6,7,8]]
00:19:39 <lambdabot>   [1,2,3,4]
00:20:29 <Ke> what was the problem with the first one
00:20:36 <elliott> nothing
00:20:41 <DiegoNolan> well TIL
00:20:41 <elliott> lambdabot is weird
00:24:26 <haasn> lambdabot is a very limited attention span
00:24:30 <haasn> she gets distracted sometimes
00:24:37 <haasn> in this case I think it was a lambda-shaped butterfly
00:24:45 <haasn> has a*
00:39:34 * hackagebot splaytree 0.1.5 - Provides an annotated splay tree  http://hackage.haskell.org/package/splaytree-0.1.5 (JohnLato)
00:39:36 * hackagebot splaytree 0.1.4 - Provides an annotated splay tree  http://hackage.haskell.org/package/splaytree-0.1.4 (JohnLato)
01:08:06 <b__> is there a general way to change base for a bytestring, or should I use Data.ByteString.Base16 etc?
01:08:43 <b__> the decode functions in BS.Base16 and BS.Base64 have different types
01:10:59 <johnw> how can I run the garbage collector manually?
01:11:26 <shachaf> performGC
01:11:31 <johnw> thanks!
01:12:31 <johnw> yep, that worked like a charm
01:13:28 <shachaf> So not very well?
01:13:36 <johnw> a very good charm
01:13:48 <shachaf> Hmm, most charms don't tend to work, I'm told.
01:13:59 <shachaf> I guess you're lucky.
01:14:06 <johnw> i had an FFI library "shutdown" call, and had to be sure that any finalizers that were going to run as a result of GC had a chance to run before that call
01:14:13 <johnw> otherwise, the finalizer asserts
01:14:16 <vhz> b__: the sandi package might be more appropriate if you want a more consistent API.
01:15:27 <shachaf> I'm not sure that's entirely reliable.
01:15:33 <johnw> oh, absolutely
01:15:49 <johnw> i can feel the reliability exuding from it in waves
01:29:47 * hackagebot hlibgit2 0.18.0.1 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.1 (JohnWiegley)
01:30:31 <hellcook> Hi
01:32:24 <johnw> well, that sure took a lot of work
01:32:27 <b__> vhz, looks interesting, thanks
01:35:03 <johnw> shachaf: oh, it's probably not a "full sweep", is it
01:35:31 <aristid> johnw: and ghc has no way to hook in initializers / destructors either?
01:35:53 <aristid> johnw: maybe you could make a small helper library in C that just does the init / destruction thing
01:36:17 <aristid> in the way you proposed
01:36:19 <johnw> well, I can just hack it straight into my custom version of libgit2
01:36:28 <johnw> i already maintain patches
01:36:31 <aristid> but?
01:36:39 <johnw> won't work on Windows, for one thing
01:36:52 <aristid> but you want hlibgit2 to work on windows? :D
01:36:59 <johnw> yes
01:37:21 <Javran> is there some common way to wrap functions that might fail into Maybe?  e.g. `read` to `maybeRead`
01:38:50 <shachaf> There is spoon
01:39:07 <johnw> and try
01:39:09 <shachaf> But it's kind of evil. You're not "supposed" to be able to do this. Better to use the right API in the first place.
01:39:22 <shachaf> teaspoon . read :: Read a => String -> Maybe a
01:40:39 <aristid> Javran: for read, the answer is: use reads instead
01:40:41 <aristid> :t reads
01:40:43 <lambdabot> Read a => ReadS a
01:40:57 <aristid> ah, a case of UNHELPFUL TYPE SYNONYMS
01:41:17 <Javran> ok, got it
01:41:49 <Javran> but I'm curious about why this is considered evil?
01:42:22 <aristid> Javran: spoon is evil because it relies on trickery, and does not always work
01:42:26 <johnw> for shachaf, evilness and the devil are often not quite as dire as one might think
01:42:35 <elliott> spoon is as dire as it gets.
01:42:49 <elliott> it breaks the language's semantics. it's on the level of unsafePerformIO.
01:42:54 <johnw> oh wow
01:42:56 <elliott> that doesn't mean it's never useful.
01:43:11 <elliott> but if you do find it useful you should be reporting bugs in the libraries you're using, to tell them to export a safe API.
01:43:43 <aristid> bug against the standard library: "read is unsafe and the type of reads is annoying" :D
01:44:06 <elliott> aristid: resolved FIXED: check out readMaybe in a recent GHC
01:44:09 <Javran> I've checked the code, it uses unsafePerformIO..
01:44:14 <aristid> elliott: ooh cool
01:44:31 <aristid> elliott: what does recent mean?
01:44:52 <elliott> 7.6+ I think.
01:44:55 <aristid> Javran: which code are you talking about?
01:45:08 <Javran> http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/src/Control-Spoon.html#spoon
01:45:33 <dEPy> I lost
01:45:56 <aristid> elliott: do i need to load some module? because it's clearly not in the prelude (unlike read and reads) :)
01:46:25 <aristid> Javran: oh i thought you meant the unsafe code you're trying to use
01:46:43 <elliott> aristid: Text.Read
01:47:53 <aristid> elliott: nope, not in ghc 7.6.2
01:47:58 <aristid> must be 7.8 then :/
01:48:25 <elliott> it's in 7.6.
01:48:29 <elliott> I know because I have it and have used it.
01:48:43 <elliott> perhaps I misnamed it, let me check.
01:48:51 <elliott> oh.
01:48:54 <elliott> i misnamed the module
01:50:24 <elliott> no I didn't.
01:50:34 <elliott> aristid:
01:50:35 <elliott> $ ghci
01:50:36 <elliott> GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
01:50:38 <elliott> {--} import Text.Read
01:50:38 <elliott> {--} :t readMaybe
01:50:40 <elliott> readMaybe :: Read a => String -> Maybe a
01:52:33 <aristid> elliott: oops i had loaded the environment for ghc 7.6 but was still using ghci 7.4.2, that explains it :D
01:53:28 <elliott> heh
01:54:50 <mr_> Is there a way to dynamically load code from an untrusted source in a safe way?
01:59:28 <mm_freak> mr_: mueval may be a solution
01:59:40 <mm_freak> that's what powers lambdabot's evaluator
01:59:47 <mm_freak> > let 2 + 2 = 5 in 2 + 2
01:59:49 <lambdabot>   5
02:00:11 <no-n[0]> oh, NICE
02:00:14 <no-n[0]> haha
02:02:24 <no-n[0]> > let 2 + 2 = 5 in 2 + 2 + 2
02:02:25 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
02:02:38 <no-n[0]> of course ;P
02:03:22 <mm_freak> > let 2 + 2 = 5; x + y = x Prelude.+ y in 2 + 2 + 2
02:03:23 <lambdabot>   7
02:03:32 <no-n[0]> :_)
02:05:24 <mr_> mm_freak: too bad it is not a library, also, loading files with it is not safe (says the README)
02:06:00 <mm_freak> mr_: sure it is a library
02:06:01 <mm_freak> http://hackage.haskell.org/package/mueval
02:06:15 <mm_freak> and obviously it's not safe…  you're executing untrusted code ;)
02:08:17 <mr_> mm_freak: But shouldn't it be possible to have the user provide a function of type Int -> Int and to expect it to be entirely safe to load it? It's Int -> Int and there are not side-effects, so what could go wrong?
02:08:46 <mr_> (except non-termination, of course)
02:10:17 <bitonic> mr_: non-termination is a ‘wrong’
02:11:08 <bitonic> if your goal is avoiding people ddos’ing lambdabot :)
02:11:28 <elliott> mr_: look into Safe Haskell
02:11:59 <structuralist> so I'm looking at hs-plugins...
02:12:32 <structuralist> I also see that GHC API has some interactive stuff – http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html#g:11
02:12:50 <structuralist> was this around back then?
02:13:07 <structuralist> is hs-plugins still relevant? (still haven't quite wrapped my head around it)
02:14:07 <structuralist> or is what it does subsumed by this GHC interactive stuff
02:14:09 <mr_> elliott: thanks
02:14:35 <mr_> bitonic: at the moment I am more interested in not compromising my webserver, the load handling comes later ;_)
02:15:04 <bitonic> mr_: OK I was just pointing out that for the purposes of lambdabot avoiding that is needed
02:15:19 <bitonic> (didn’t really follow the discussion above)
02:15:23 <bitonic> > length [1..]
02:15:28 <lambdabot>   mueval-core: Time limit exceeded
02:16:58 <arcatan> > unsafePerformIO $ putStrLn "hello"
02:17:00 <lambdabot>   Not in scope: `unsafePerformIO'
02:20:42 <shachaf> mr_: You can only trust SafeHaskell so much.
02:20:50 <shachaf> There are always things like
02:20:56 <shachaf> @google unsafe coerce without extensions
02:20:59 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7453
02:20:59 <lambdabot> Title: #7453 (unsafe coerce without extensions) – GHC
02:22:26 <elliott> shachaf: didn't core lint catch that one?
02:23:26 <bitonic> elliott: spj says so in the comments
02:24:24 <shachaf> elliott: Yes.
02:24:44 <shachaf> Core lint is a good idea when you're doing this sort of thing.
02:24:50 <shachaf> But it's not guaranteed to catch every type checker bug.
02:25:55 <elliott> well, sure. you can't trust anything.
02:27:35 <shachaf> You can trust some things more than others.
02:27:59 <elliott> I'd trust Safe Haskell + core-lint more than a lot of things
02:28:28 * shachaf ∈ a lot of things
02:28:32 <bitonic> well most languages don’t even try to provide something like that.  so...
02:28:49 <mr_> shachaf: nice bug..
02:28:50 <shachaf> bitonic: Yes, usually people do sandboxing at a different level.
02:29:58 <bitonic> but even in the things that are really supposed to be ‘safe’ by design (e.g. Coq) there are many levels of third parties to be trusted... it’s sad
02:33:05 <Dinocroc> Hello
02:33:12 <bitonic> Dinocroc: hello
02:35:25 <latermuse> dinocroc: hello
02:58:59 <ChewieBeardy> hey guys, I have a silly question regarding functors
02:59:24 <ChewieBeardy> for something to be a functor, it has, in addition to having an fmap implementation, to obey the functor laws right?
02:59:36 <ChewieBeardy> for instance, fmap id = id
02:59:54 <ChewieBeardy> but that implies a sens of equality testing for us to prove it
03:00:06 <ChewieBeardy> does that mean that we can only make functors out of Eq instances?
03:00:18 <dario> no
03:01:07 <ChewieBeardy> I mean, haskell wise it will work, because the language doesn't enforce the laws
03:01:46 <ChewieBeardy> but conceptually, can we prove that fmap id X == id X without comparing X?
03:01:55 <shachaf> Sure.
03:01:56 <elliott> you can use equational reasoning. note that it's =, not ==
03:02:06 <shachaf> For example you can't compare functions, in general.
03:02:15 <shachaf> But (r ->) is an instance of Functor.
03:02:16 <elliott> for instance, if you're defining a Functor instance for functions, you can show that the function you return is equivalent to the input, given id.
03:02:21 <elliott> god dammit shachaf.
03:02:32 <elliott> or, if you define a Functor instance for infinite streams.
03:02:55 <elliott> you just show the result is extensionally the same as what you got in. it is something you must do, not the computer
03:03:12 <ChewieBeardy> I see
03:03:53 <elliott> usually it's easy.
03:05:06 <ChewieBeardy> so, is it fundamentally impossible for a computer to enforce the law, or could we imagine an haskell variant that could?
03:05:31 <bitonic> ChewieBeardy: you can embed some notion of term equality in your language
03:06:05 <dario> well, the computer usually cannot prove things like "this function does the same as that function for every possible input"
03:06:07 <bitonic> ChewieBeardy: but in languages like Haskell it wouldn’t be viable
03:06:34 <dario> it's called rice's theorem ;)
03:06:59 <elliott> ChewieBeardy: you can require that the programmer supply a machine-checkable proof of the law.
03:07:07 <bitonic> right, your functions must all be total for that to work
03:07:11 <elliott> computers cannot in general prove mathematical theorems for you.
03:07:20 <elliott> bitonic: not really
03:07:27 <elliott> you can have a total proof language that talks about partial functions
03:07:50 <ChewieBeardy> so we'd need a finite number of inputs?
03:07:59 <elliott> hm?
03:08:13 <ChewieBeardy> to "prove" equality of a function
03:08:42 <dario> no, we'd need to add a kind of annotation language, that (in computer-provable steps) shows how the two functions are equal
03:08:47 <bitonic> elliott: fair enough
03:08:51 <typoclass> ChewieBeardy: a 'total function' is one that will give an output for every input. a counterexample (= a partial function) is head, because head [] throws an exception
03:09:05 <ChewieBeardy> oh I see
03:09:23 <ChewieBeardy> sorry for all the beginner questions, but it's so interesting
03:09:35 <elliott> you can prove equality of two partial functions
03:10:57 <bitonic> elliott: I guess what I was referring to is that your proof system/logic framework/whatever has to be total.  you can then embed a partial model in it
03:10:58 <ChewieBeardy> but when you say that computers cannot prove mathematical theorems, does that mean that things like Coq "cheat"?
03:11:31 <_oggy> i'm using hsenv for a project, but can't get cabal install to install the docs for me. --reinstall --enable-documentation doesn't do anything. any ideas?
03:12:03 <elliott> ChewieBeardy: no
03:12:17 <elliott> it means with coq, you do the proving. the computer can help you, but you are in the end, proving the theorem to it.
03:12:22 <elliott> and it checks it
03:12:24 <bitonic> ChewieBeardy: computers *can* prove mathematical theorems, but not arbitrarily...  also in Coq most of the thinking is done by humans, the computer checks that the human is not making mistakes
03:12:29 <ijp> one analogy would be with IDEs, they don't come up with the program, just help you write it
03:12:32 <elliott> you can't just give the riemann hypothesis to coq and get an answer out :)
03:12:46 <elliott> but if you have an answer to the riemann hypothesis, you can tell it to coq and it'll confirm it for you.
03:13:06 <ChewieBeardy> I understand
03:13:20 <ChewieBeardy> thanks a lot for the answer guys!
03:13:27 <ChewieBeardy> answerS even
03:14:04 <quchen> ChewieBeardy: Here's a simple example of a functor and how to show it obeys the law. http://hpaste.org/86155
03:16:29 <ChewieBeardy> ok, so basically, we can reduce (\x -> x) to id without defining equality for x
03:16:37 <elliott> right
03:16:50 <elliott> and you can reduce (\x -> id x) to id
03:17:03 <elliott> and (\x -> let y = id x in head [y]) to id. etc.
03:18:15 <bitonic> ChewieBeardy: as an aside, the problem of defining nice notion of equality in a way so that a computer can check your equality proofs is a very active area, so it’s not a beginner question or a ‘solved’ problem :)
03:19:07 <ChewieBeardy> haha
03:19:30 <elliott> well, if you keep your proofs fully separated and just there for machine checking, then plain old extensional equality should work, I think.
03:19:40 <elliott> but people like to do more exciting things than that.
03:20:50 <bitonic> elliott: I’m not sure what you mean with ‘keeping proofs fully separated’, but ‘classic’ extensional type theories (like nuplr) have problems, since you need to carry around the derivations otherwise type checking is undecidable
03:22:17 <elliott> bitonic: by fully separated, I mean no referencing them from the value level, no "evaluation" of them, etc.
03:22:35 <elliott> but yeah extensional equality is hard and confusing :(
03:22:40 <elliott> we should be able to have nice things
03:22:52 <bitonic> elliott: OK, so you can’t use your equality proofs and use them to substitute equal things
03:25:15 <bitonic> ChewieBeardy: anyway, I mentioned that because one of the things that gets people really excited now is an equality that coincides with the notion of isomorphisms, which would be awesome if it works out
03:27:25 <ChewieBeardy> well up until now, I thought that the two notions were the sort of the same :P
03:28:17 <bitonic> ChewieBeardy: well that’s the natural thing to think isn’t it?  but convincing computers is another story
03:28:49 <bitonic> up to now the equalities we have in the popular systems (Coq, Agda) are much more restrictive than that
03:29:24 <ijp> stupid computers. They ruined computer science.
03:29:28 <ChewieBeardy> haha
03:29:31 <elliott> i like to secretly root against HoTT because conor mcbride doesn't like it.
03:29:36 <elliott> this helps me avoid the daunting task of learning it.
03:30:11 <Dinocroc> Computer ruined computer science laughs
03:30:23 <bitonic> elliott: well the fact that equality proof have computational content complicates things a lot yes...  it’s not clear yet if it will compute and if it will be practical when if it will
03:30:35 <elliott> well, he doesn't like it on principle.
03:30:51 <elliott> (because you lose the whole part where non-isomorphic types can have structure differentiating them, or such.)
03:30:56 <bitonic> elliott: I think that the principle is that UIP doesn’t hold
03:31:14 <oelewapp1rke> sorry I'm just a haskell beginner. So  I have a few questions. If : is 'cons in haskell' why doesn't [1]:[2] work ?
03:31:28 <elliott> oelewapp1rke: because cons prepends one element to a list
03:31:38 <elliott> you give it an element (a) and a list ([a]) and it gives you the new list ([a])
03:31:40 <elliott> try 1:[2]
03:31:41 <typoclass> oelewapp1rke: (:) takes one element and a list
03:31:48 <kennyd> > [1]:[[2]]
03:31:50 <lambdabot>   [[1],[2]]
03:31:51 <oelewapp1rke> ah
03:31:55 <typoclass> oelewapp1rke: and, no need to apologize :-)
03:31:59 <bitonic> elliott: do you mean ‘you lose the whole part where *isomorphic* types can have structure differentiating them’?
03:32:01 <monoidal> oelewapp1rke: to concatenate two lists use ++
03:32:16 <elliott> bitonic: er, yes.
03:32:21 * elliott is tired.
03:32:52 <bitonic> elliott: that is annoying computationally, I think.  but conceptually treating isomorphic things as the same is liberating, imo.  we’ll see
03:33:18 <leggo> :t (:)
03:33:19 <lambdabot> a -> [a] -> [a]
03:33:23 <oelewapp1rke> I was looking at the google code jam results, and the third place is a haskeller
03:33:40 * elliott isn't sure he's comfortable with Char = Word21 or whatever.
03:33:42 <oelewapp1rke> I'm looking to decipher his code
03:34:26 <bitonic> elliott: by the way, in Agda or Coq you can’t prove those unequal either.  you’re just in a limbo :P
03:35:23 <elliott> bitonic: that's ok, i don't mind being unable to prove equalities.
03:35:27 <shachaf> elliott: imo Char should be Word21 minus the invalid codepoints like 0xD800
03:35:30 <elliott> er *inequalities
03:35:37 <elliott> it's being able to prove equalities that bothers me.
03:35:43 <elliott> call it equality conservatism.
03:35:58 <shachaf> pigworker doesn't like HoTT?
03:36:07 <bitonic> elliott: Conor coined many religion-inspired terms regarding these type theories, now you start as well :P?
03:36:11 <elliott> shachaf: that's the impression I get.
03:36:14 <bitonic> with politics
03:36:24 <bitonic> I don’t think he doesn’t like it.  I think he thinks it’s unmanageable
03:36:37 <elliott> bitonic: pfft, he did that too. ("John Major equality")
03:36:42 <bitonic> ah, right!
03:37:03 <bitonic> so the conservative equality is taken as well
03:37:06 <dEPy> how can I defined function names :-: ? have to wrap it in quotes or someting=
03:37:07 <dEPy> ?
03:37:23 <monoidal> dEPy: code?
03:37:27 <shachaf> You cannot*.
03:37:31 <shachaf> * Unless it's a constructor.
03:37:45 <monoidal> dEPy: infix operators starting with : are constructors
03:38:09 <dEPy> monoidal, for example:  let <$$> f xs = fmap f xs
03:38:18 <monoidal> dEPy: let (<$$>) f xs = ...
03:38:20 <bitonic> elliott: although that’s ‘conservative’ for a different reason :)
03:38:26 <dEPy> monoidal,  ah right...
03:38:29 <monoidal> dEPy: or, let f <$$> xs = ...
03:39:14 <dEPy> monoidal, I forgot I have to put it in parent if it's prefix
03:40:08 <elliott> bitonic: "I know it’s rather popular these days to consider a set equality which admits nontrivial (hence non-erasable) isomorphisms, e.g. via Voevodsky’s univalence axiom. I am very much interested in supporting a class of construction invariant under isomorphism, but that’s not what’s happening here. By choosing a finer equality, I do prevent the adoption of isomorphism as equality, but that’s not the only way to support isomorphism. I th
03:40:15 <elliott> probably got cut off
03:40:30 <bitonic> was that a comment to a blog post?
03:40:41 <bitonic> ah, Hier.agda
03:41:39 * bitonic has Epilogue archived for moments like these
03:41:53 <bitonic> right
03:42:11 <bitonic> note that ‘it’s *pragmatically* helpful’
03:42:27 <bitonic> he wants to have a manageable computational theory (again, I think, I’m not him)
03:43:01 <bitonic> in this case it means that all equality proofs are really ‘refl’
03:43:13 <elliott> well, I've seen other comments from him about isomorphisms-as-equalities losing structure which seemed to have no computational content whatsoever, only philosophical. of course I'm not a mind-reader and I don't recall them off-hand, but I don't remember it being that simple
03:43:39 <elliott> if only there were some way to contact this mythical creature... :P
03:43:40 <bitonic> well, in that post he invokes pragmatism :)
03:44:10 <bitonic> twitter seems to be the best way these days ehe
03:44:35 <bitonic> 4 out of 5 of my tweets are pointed at pigworker :P
03:45:00 <elliott> if we just shout real loud he'll hear we're talking about him and come on over here all the way from glasgow.
03:45:28 <bitonic> clutching on a deep fried mars bar
03:50:36 <ijp> bitonic: most of the people that buy those are tourists
03:50:58 <dEPy> Is there any good reason for <*> implementation for list to do all the combinations instead of doing "1 on 1" ? For example instead of doing like this:  [(*2), (*4)] <*> [1,2]  = [2,8] ?
03:51:01 <bitonic> ijp: aha.  tbf, I’d probably buy one.
03:51:16 <monoidal> dEPy: for compatibility with the monad instance
03:51:24 <dEPy> monoidal, ok :)
03:51:45 <monoidal> dEPy: [] is a monad and the second way to make [] an applicative does not give a monad
03:53:40 <elliott> dEPy: ZipList is available for the zippy behaviour. (you will find the wrapping makes it unusable and may wish to use zipWith ($) instead)
03:59:07 <leggo> monoidal and why does monad instance do that?
03:59:45 <leggo> that's the more interesting question
04:00:13 * hackagebot zeromq3-haskell 0.3.1 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.3.1 (ToralfWittner)
04:00:14 <monoidal> leggo: the monad instance for lists is x >>= f = concat (map f x), or simply join = concat
04:00:24 <bitonic> leggo: people have deemed the current Monad instance to be more worthy/useful
04:00:42 <bitonic> actually wait.
04:00:48 <bitonic> forget what I said :P
04:01:04 * bitonic was still thinking of Applicative...
04:01:23 <quchen> monoidal: it's flip concatMap.
04:01:32 <leggo> monoidal that doesn't explain the why
04:02:55 <bitonic> leggo: how would you implement a Monad instance with the ‘zipping’ behaviour?
04:03:09 <leggo> why wasn't list monad implemented so that { x <- [1,2]; y <- [3,4]; return (x,y) }  returns [(1,3), (2,4)] ? is it an arbitrary decision?
04:03:16 <leggo> +do
04:03:40 <Cale> leggo: It's not an arbitrary decision
04:03:50 <monoidal> leggo: there is no implementation that would do this, and abide the monad laws
04:04:08 <bitonic> leggo: it’s by far the most ‘obvious’ instance.  for fixed-width lists you can do the zipping, but otherwise it’s tricky
04:04:26 <Cale> Also, as it stands the list monad is incredibly useful
04:04:44 <Cale> So even if there were a zipping instance, we probably wouldn't want to make it the default one
04:04:59 <bitonic> <http://photos1.blogger.com/blogger/3557/910/1600/annotated_monads.1.jpg>
04:05:07 <leggo> what monad law would zipping behavior break?
04:05:16 <elliott> leggo: try writing (>>=).
04:05:20 <elliott> then we'll show you how it breaks the laws
04:05:30 <elliott> it comes because the two lists can have different shapes
04:05:35 <elliott> it's not always [1,2] [3,4] sometimes it's [1] and [2,3,4]
04:12:01 <saml> > scanl f [a,b,c]
04:12:03 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
04:12:03 <lambdabot>                     [Deb...
04:12:09 <saml> > scanl f x [a,b,c]
04:12:11 <lambdabot>   [x,f x a,f (f x a) b,f (f (f x a) b) c]
04:15:43 <quchen> Cale: "The list monad is incredibly useful"?
04:16:26 <bitonic> quchen: to do non-deterministic computation—e.g. proceed with any of these values
04:16:39 <quchen> Am I overlooking something? I mean it's there and all, but I don't use it very often
04:16:43 <bitonic> that’s the common way of thinking about it
04:17:21 <bitonic> then you can recover any possible result
04:17:32 <aristid> discrete probabilities can be simulated with lists, as well :) it's rather crude and inefficient but... :D
04:18:29 <Cale> quchen: I use it all the time. It's at least as useful as list comprehensions, but moreso because you have all the stuff in Control.Monad.
04:19:11 <monoidal> aristid: probabilities are rather newtype Prob = Prob [(Prob, Float)] - another monad (can be thought of composition of List and Writer though)
04:19:30 <quchen> Cale: Right, when you're doing complicated list comprehensions it's probably a good thing.
04:19:33 <monoidal> Prob [(a,Float)] rather
04:19:48 <aristid> monoidal: i know. but that's harder to use from ghci
04:19:56 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
04:19:58 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
04:19:59 <quchen> I guess I mostly file the list monad under "eh, comprehension" and overlook it :-)
04:20:17 <Cale> > filterM (const [False,True]) [1..5]
04:20:19 <lambdabot>   [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,...
04:20:19 <merijn> quchen: It's not about comprehensions but more like "I have 5 functions that return lists of results and want to apply f2 to the result of f1 and f3 to the result of f2, etc. to get all possible results"
04:20:33 <Cale> (though we now have subsequences for that :)
04:20:38 <aristid> quchen: ever heard about monad comprehensions?
04:20:48 <quchen> aristid: Yes.
04:20:49 <bitonic> quchen: well, comprehensions are terribly useful.  I use list comprehensions all the time.  I even prefer them to ‘map’ if the function is even slightly involved
04:20:53 <bitonic> and you can pattern match
04:21:02 <bitonic> (in the list monad/comprehensions)
04:21:30 <monoidal> usually I use the list monad when there's some combinatorial question to solve
04:21:50 <aristid> bitonic: you can also pattern match in do blocks :)
04:22:04 <quchen> aristid: But that involves fail which is bah
04:22:24 <aristid> quchen: for lists the effect is exactly the same
04:22:26 <bitonic> aristid: that’s what I meant with ‘in the list monad’ :)
04:22:37 <aristid> ok.
04:22:55 <bitonic> quchen: ‘fail _ = []’ in []
04:23:22 <quchen> Well, fail = const mzero is probably the only sane definition.
04:23:59 <bitonic> quchen: it’s the same, for [].  if you are arguing that ‘fail’ shouldn’t be in Monad, that’s another discussion
04:24:16 <bitonic> it does allow for nice pattern matches failures in some cases (like this one)
04:24:45 <aristid> it should be there but in a separate class. obviously ;)
04:24:56 <bitonic> aristid: so how do you treat pattern matches in ‘do’?
04:25:20 <bitonic> automatically put a ‘MonadZero’ constraint?
04:25:35 <bitonic> what if you want it to crash?
04:25:54 <aristid> bitonic: interesting question. :P
04:25:57 <quchen> If you're not matching against an atomic name ("x"), put a MonadFail constraint on the block.
04:27:18 <bitonic> quchen: that’s a reasonable solution, but they went for pragmatism at the time, and they didn’t have MonadZero (I think).  in the end it’s not too bad, nowadays if the monad is MonadZero too ‘fail’ will probably reflect that.  if it doesn’t, it’ll crash hard, which is what you expect from a pattern match failure
04:29:51 <elliott> MonadZero was a thing and it was deilberately removed, AIUI.
04:32:51 <dEPy> what do you guys mostly use? linux, win or mac?
04:33:10 <quchen> Yes.
04:33:33 <arcatan> yeah
04:34:26 <typoclass> dEPy: i use linux because i haven't found anything better
04:35:03 <saml> https://gist.github.com/saml/5425696  how would you express this in haskell?
04:35:16 <saml> cutoff is some global constant
04:36:13 <dEPy> typoclass, any particular distro your fond of?
04:36:59 <dEPy> you're *
04:37:22 <saml> ubuntu
04:37:25 <typoclass> dEPy: i'm kind of looking :-) folks recommended fedora to me, others recommended against fedora ... i've got arch linux right now but these days it's not very good anymore
04:37:45 <dEPy> typoclass, what about ubuntu?
04:38:28 <aristid> clearly nixos is the best distribution
04:38:30 <typoclass> dEPy: don't know much about it. i've used it around 2006-8, but got fed up with the massive breakage every 6 months
04:38:46 <typoclass> aristid: right, that might be a good possibility. i should look at it
04:38:49 <dEPy> typoclass, breakage? because of updates or?
04:39:08 <typoclass> dEPy: yeah, they came out with new versions every 6 months
04:41:32 <gienah> dEPy: sabayon is a rolling binary distro with good haskell support (haskell packages are built from the source code using the gentoo haskell overlay)
04:41:44 <typoclass> saml: what is that code supposed to do?
04:42:48 <saml> typoclass, iterate cutoff - x times setting y. then call g(x,y)
04:46:03 <typoclass> saml: sorry, i'm not sure what the code means. there's a for loop for iterating, but inside of that it also seems to call itself recursively
04:46:26 <saml> yah not sure how to express that
04:55:19 <hpaste> Cale pasted “Direct translation” at http://hpaste.org/86157
04:55:24 <Cale> saml: ^^
04:55:39 <leggo> do { x <- [1,2]; y <- [3,4]; return (x,y); } expands to [1,2] >>= \x -> [3,4] >>= \y -> return (x, y), which is basically concat $ map (\x -> map (\y -> (x,y)) [3,4]) [1,2]. did I get that right?
04:55:46 <saml> Cale,  thanks
04:55:51 <Cale> leggo: you missed a concat
04:56:01 <leggo> inner one?
04:56:06 <Cale> yeah
04:56:25 <leggo> yeah good catch
04:56:55 <merijn> Cale: Are you a wizard or something? o.O
04:57:10 <leggo> I was thinking the same :)
04:57:33 <Cale> merijn: :)
04:58:19 <typoclass> hehe, "I have no idea what this program is meant to compute", but he wrote the code anyway. that's pretty artistic :-)
04:58:52 <merijn> typoclass: Naah, that's ok
04:59:07 <Cale> typoclass: Well, it was saml's C code
04:59:15 <merijn> I can't remember how many times I've debugged peoples code in here without having any clue what it was doing
04:59:23 <saml> typoclass,  Cale   i was trying to implement faster ackermann http://codepad.org/MMfXD0Bn    for this http://www.reddit.com/r/haskell/comments/1cq3r4/inefficient_ackermann_implementation_not_obvious/
05:00:26 <Cale> ah, makes sense
05:00:27 <typoclass> Cale: sure :-) i didn't mean to criticize. you just seemed like a tight-rope walker. kind of impressive but i wouldn't dare
05:00:41 <Cale> I thought the nested recursion seemed a little Ackermannish
05:02:09 <typoclass> saml: just as a heads-up for next time, it'd have helped if you had mentioned the word ackermann at some point :-)
05:02:12 <Cale> typoclass: Well, my hope was to show how it's not that hard to do, and pretty mechanical once you're past the initial step
05:02:59 <Cale> The hard part is just interpreting the C code and making explicit how the code pointer moves around after each statement
05:03:14 <Cale> and then it's all highschool algebra
05:03:42 <Cale> (substitute the definition of one thing into another until you can't do it anymore)
05:05:44 <taylorgb> Say, Cale, how did your work on a game written in Haskell go? Or is it not finished yet?
05:06:52 <Cale> We're on hiatus, I've been working for the same guy at skedge.me instead. Our game engine is good enough for skirmish sort of combat stuff, but it needs a bunch of work to really make the ARPG we intended.
05:07:54 <Cale> and lots of actual content programming (skill effects) and some UI still needs doing
05:08:28 <aristid> Cale: oh sounds like a product that is actually useful, this skedge thing
05:08:36 <taylorgb> Interesting
05:09:50 <saml> splitting f to f1, f2, f3, f4 is hard
05:10:59 <Cale> saml: The idea is that the result of the function representing a given line of C code will be the function representing the *next* line of C code to run, applied to the new values of any local variables.
05:11:39 <Cale> (all the mutable variables become function parameters)
05:13:15 <Cale> saml: For example, f3 is going to call f2, because the next thing to do after the last line of a for loop is the decrement, and then f2 calls f1 because after that you do the test again.
05:13:53 <Cale> and when f3 calls f2, it does so with the updated value for y
05:14:22 <Cale> and in that case, I could just translate the expression for what to update y to directly
05:14:48 <Cale> saml: Does that make a bit more sense?
05:15:05 <saml> no. i'm drawing flow diagram on paper :P
05:15:28 <saml> how would you implement ackermann so that it'll compute 4,1  or 4,2  without out of memory?
05:24:00 <Cale> saml: did you see http://stackoverflow.com/questions/16115815/ackermann-very-inefficient-with-haskell-ghc ?
05:31:03 <hpaste> Cale pasted “Ackermann” at http://hpaste.org/86158
05:31:11 <Cale> saml: ^^
05:31:44 <Cale> The specialisations for low m parameters are important though
05:33:31 <Cale> I suspect Memo.integral isn't really the best thing to be doing in general here
05:36:08 <saml> hoa Memo is magic
05:37:06 <Cale> actually, it has no effect on performance in this case :P
05:38:16 <Cale> Now that I think about it, it only makes this slower, because ack 4 2 = ack 3 (ack 4 1) = ack 3 (ack 3 (ack 4 0)) = ack 3 (ack 3 (ack 3 1))
05:38:38 <Cale> and then the special case for ack 3 triggers a bit and you're done
05:39:15 <Cale> and nowhere in that process did it need to apply ack to the same parameters twice
05:40:03 <saml> making ack toplevel and calling it works well
05:40:57 <Cale> yep
05:42:00 <Cale> you should also note...
05:42:35 <hpaste> Cale annotated “Ackermann” with “Ackermann (annotation)” at http://hpaste.org/86158#a86159
05:43:08 <Cale> removing those special cases, but keeping memoisation on lets us do ack 4 1 faster than C does it, even though we're using big Integers instead of Int :)
05:44:35 <saml> whoa
05:45:06 <Cale> (of course, memoising means that we're dramatically changing the algorithm being used)
05:45:39 <Cale> The raw version I think ought to work, but presently doesn't
05:46:09 <Cale> dolio's comment on the reddit post indicates that he thinks it's a bug
05:46:18 <Cale> http://hackage.haskell.org/trac/ghc/ticket/7850
05:48:53 <Cale> Apparently the bug is not in GHC 7.0.4
05:49:15 <Cale> (whatever GHC bug the original program is triggering)
05:51:29 <monoidal> For what's worth, it seems to be fixed in HEAD. I can reproduce out-of-memory with 7.6.2 but not 7.7
05:53:30 <Asterfield> Day two of Haskell fiddling. My brain on discovering lazy execution and infinites: "o.O"
05:54:21 <typoclass> Asterfield: ;-)
05:54:32 <typoclass> Asterfield: we call it lazy evaluation usually
05:55:10 <Botje> @quote skull
05:55:10 <lambdabot> Makali says: Whenever a programmer thinks, "Hey, skins, what a cool idea", their computer's speakers should create some sort of cock-shaped soundwave and plunge it repeatedly through their skulls.
05:55:23 <Botje> hmm. that's not the one.
05:55:25 <Botje> @quote tape
05:55:26 <lambdabot> hiptobecubic says: I feel like this program is just a bunch of glue and duct tape holding a bottle of nitroglycerine off of the ground.
05:55:37 <Botje> bleah. you've changed, lambdabot
05:57:25 <hiptobecubic> Botje, what were you hoping for?
05:57:36 <Asterfield> typoclass: :P My bad, thank you
05:58:00 <typoclass> Asterfield: no problem at all :-)
05:59:01 <FireFly> @quote kyevan skull
05:59:02 <lambdabot> kyevan says: my skull is already mostly duct tape. And I'm only on page 25 of YAHT!
05:59:06 <FireFly> maybe
05:59:47 <Palmik> Hi guys, could anyone here run this benchmark and tell me what you think? Benchmark: http://hpaste.org/86162 (my results are below). It seems that Data.Set.insert has linear complexity, or am I doing something wrong? (And please, do not tell me I should use Data.IntSet.IntSet for Int, as it is irrelevant)
06:03:17 <Botje> hiptobecubic: that one :)
06:03:34 <Cale> Palmik: http://sepulcarium.org/blog/posts/2013-04-07-criterion.html -- I wonder if what you're seeing has anything to do with this
06:08:10 <[1]papyrus> is haskell  good performance compared with lisp ?
06:08:47 <[1]papyrus> specifically sbcl.
06:09:12 <Taneb> That's not a great question, because there are numerous Haskell and Lisp implementations. I doubt Haskell could outperform Lisp on a Lisp machine.
06:09:35 <Palmik> Cale: Hmm, that is worrying.
06:10:04 <typoclass> [1]papyrus: haskell is generally quite fast. the haskell implementation that everyone uses is called ghc
06:10:09 <Taneb> However, GHC is a great compiler, and well-written Haskell code is really fast
06:10:23 <Palmik> Cale: I will see if reversing the order of the benchmarks changes anything.
06:10:39 <cocon> With -XPolyKinds and 'data T m a = MkT (m a)' GHCi gives 'm a -> T * m a' as the type for MkT. Is there any way to make it not display the '*'?
06:10:55 <[1]papyrus> thanks a lot.
06:11:02 <typoclass> Taneb: lisp machines? those things where a tiny number was built about 40 years ago? that sounds awfully obscure :-)
06:11:34 <monoidal> conon: currently, no
06:11:35 <Cale> Palmik: though the variations in that case were only a few nanoseconds
06:11:44 <Taneb> typoclass, I stand by the truth of my sentence, although perhaps not the relevance.
06:11:47 <monoidal> cocon: ^
06:11:59 <Cale> Palmik: so on second thought, that's probably not it
06:12:27 <cocon> monoidal: thanks. I find this obscures things quite a bit for larger types. Also, infix syntax would be nice.
06:12:47 <monoidal> cocon: fortunatelly, it's "debugging" output, obscures a lot but has no other consequences
06:12:51 <Taneb> typoclass, I think I saw one in a museum once.
06:12:57 <monoidal> cocon: what do you mean by infix
06:13:01 <monoidal> ?
06:13:18 <cocon> monoidal: well, it makes error messages unreadable
06:13:36 <merijn> cocon: TypeOperators lets you have infix syntax for types, afaik
06:13:37 <cocon> monoidal: infix constructors are bracketed and used as prefix
06:14:07 <cocon> merijn: yes, but when promoted to kinds they are printed as prefix.
06:14:13 <merijn> ah
06:14:15 <Palmik> Cale: it's the same, see the last annotation: http://hpaste.org/86162
06:14:44 <typoclass> [1]papyrus: here is some benchmarks from the shootout. http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=sbcl&data=u64q take it with a grain of salt, there's always difficulty in measuring these things
06:15:00 <Palmik> Well, I will create an issue on github and ask on reddit, maybe someone will come up with something.
06:15:07 <Asterfield> Oh that's a question I've been curious about. How is Haskell performance compared to other established languages like Java/C? Forgive me if it's a beginner question, the thought just struck me while doing the "rightTriangles" function of Learn You A Haskell
06:15:56 <Cale> Asterfield: generally good
06:16:15 <beaky> hello
06:16:17 <typoclass> Asterfield: haskell doesn't need to be embarrassed. it's quite good overall. check the shootout that i linked a minute ago :-)
06:16:21 <beaky> how do I embed c++ in haskell
06:16:24 <Asterfield> Cale: I'm guessing it runs much faster than languages like Python or Ruby?
06:16:36 <Cale> Asterfield: GHC compiled Haskell does, yes
06:16:51 <beaky> ghc compiled haskell is pretty fast
06:16:58 <Asterfield> Cale: Cool :) Thanks
06:17:02 <Asterfield> typoclass: Reading now :)
06:17:04 <typoclass> Asterfield: those are interpreted, so they'll have a harder time anyway
06:17:09 <Cale> (typically, depending on the case, you might find some Python program which runs faster because it spends most of its time in C code that is just called directly)
06:18:09 <Cale> But as for general practicality, there's very few things which I wouldn't consider using Haskell for due to performance concerns.
06:18:48 <Cale> Of course, the GHC runtime isn't small, and so if you go down to small enough embedded things it won't work, but Haskell can make a nice metalanguage for programming microcontrollers anyway :)
06:19:32 <Asterfield> Cale: I'd probably be using the C-ish Audrino language for microcontrollers, so a runtime doesn't really bother me :P
06:20:15 <dolio> You should use forth for that, obviously.
06:20:41 <merijn> Asterfield, Cale: Yeah, the only thing I probably would really avoid haskell for is (hard) realtime stuff with tight deadlines and extremely memory limited embedded stuff
06:20:48 <Cale> Asterfield: I mean, if you wanted to make Haskell code run compile directly to something which could run on a microcontroller, you might have trouble
06:21:09 <Cale> (minus the spurious 'run' generated by edit-fail)
06:21:29 <Asterfield> Cale: :P haha I understood what you meant I think
06:22:02 <Cale> But you can crosscompile and get Haskell programs running okay on an iPhone, for instance.
06:22:04 <merijn> And I guess for really numeric stuff I might look at something else than haskell too, but then I hardly ever do numeric stuff
06:23:12 <Asterfield> merijn: Define "Numeric stuff"
06:23:44 <merijn> Asterfield: lots of huge matrices and vector stuff
06:24:00 <merijn> Asterfield: The type of things people use FORTRAN for, basically :p
06:24:16 <Palmik> Hmm, can I force GHC to use specific version of some package (without cabal)
06:24:22 <mikeplus64> a linear algebra package that used repa would be nice
06:24:33 <mikeplus64> or accelerate
06:24:46 <Asterfield> merijn: matrices and vectors o.o. I just pulled an almost all nighter trying to figure that stuff out for a deadline
06:25:05 <Asterfield> Not in haskell, mind you, in Calculus :P
06:25:05 <Cale> As far as I know, the main reason anyone still uses fortran for that stuff is libraries.
06:25:28 <merijn> Or (to pimp my colleagues stuff) you should be using SAC for numeric code based on vector/matrix stuff :p
06:25:30 <mikeplus64> Asterfield: there are plenty of good matrice/vector packages, but they won't be fortran speed
06:26:06 <mikeplus64> @hackage SAC
06:26:06 <lambdabot> http://hackage.haskell.org/package/SAC
06:26:42 <merijn> mikeplus64: Not haskell library, it's a language
06:27:21 <mikeplus64> oh, i see
06:27:48 <merijn> Single Assignment C, which is basically a functional language disguised to look like C. They have some pretty heavy duty optimisation machinery in there
06:27:55 <Palmik> Does ghc --make automatically use the latest available version of package if possible?
06:28:22 <merijn> And proper multi-dimensional matrix and vector types, which is pretty neat
06:28:41 <mikeplus64> Palmik: usually but sometimes it's unreliable, if you want to be sure, you can use -fforce-recomp
06:28:52 <Cale> Palmik: You can specify using -package packagename-version
06:29:16 <Palmik> Cale, mikeplus64 will do, thanks.
06:30:11 <Cale> merijn: Why isn't the compiler implemented in Haskell and on hackage? ;)
06:32:16 <merijn> Cale: Because they started like 15 years ago, I don't work on it and they tend to have some objections to haskell (mostly from their background as focussing on performance for numeric code) :p
06:33:45 <ijp> has anyone written a "snippet" for emacs, that will generate the case analyses in a function/case for you given a type?
06:34:18 <ijp> I am not entirely sure how this would work, but it feels like something that would have been written :P
06:35:17 <elliott> I think Agda has that :P
06:42:14 <m_hyperbolic> Is there a quick way to compare the runtime of to functions? (to compare implementation)
06:42:18 <m_hyperbolic> two*
06:43:34 <aristid> m_hyperbolic: criterion?
06:45:34 <finnrobi> m_hyperbolic: there's a very simple package called timeit if all you want is execution time but I don't know exactly how accurate it is
06:45:41 <Palmik> For those interested, here is the topic about the weird time complexity of insert for containers from containers package: http://redd.it/1cqnae
06:46:08 <m_hyperbolic> aristid: finnrobi: I'll take a look at the two. Thanks!
06:55:19 * hackagebot simple 0.4.1 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.4.1 (AmitLevy)
07:21:15 <dan_s28> can someone give me a hint on making an alias to :l in ghci
07:21:15 <dan_s28> i am trying to just make a shortcut for load
07:21:15 <typoclass> dan_s28: how about ":r"? it reloads the last file you loaded
07:21:15 <dan_s28> so I dont ever have to type a long path
07:21:16 <dan_s28> ah :r ?
07:21:32 <dan_s28> well that is about as simple as it gets
07:21:53 <dan_s28> been searching for something on a dozen sites and none mentioned :r
07:22:03 <dan_s28> thanks  typo
07:22:20 <typoclass> dan_s28: you're welcome
07:23:19 <cmccann> dan_s28: if that's the case, you might also be interested in :?
07:32:57 <dEPy> what are the actuall steps of computation here  (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5      ?
07:33:40 <cmccann> what do you mean by "actual steps"?
07:34:08 <cmccann> it computes exactly what it says. It's using the ((->) e) Applicative instance, if that's what you're asking about.
07:34:12 <dEPy> oh, the lambda gets called with each of the (+3), (*2) and (/2) applied to 5?
07:34:34 <dEPy> oh ye, it's how the ((->) t) is defined, that's why
07:36:13 <dEPy> so (5+3), (5*2) and (5/2) will be applied to lambda as parameters right?
07:36:45 <cmccann> yes
07:37:29 <cmccann> the ((->) e) instance is basically the Reader monad, either providing an "environment" value or duplicating a single argument among many functions
07:37:33 <cmccann> however you want to look at it
07:38:16 <beaky> how does haskell manage to be faster than even java?
07:39:41 <ijp> given a sufficiently silly benchmark, I think I could make PHP look faster than fortran
07:39:47 <beaky> lol
07:40:31 <beaky> given a sufficiently smart compiler, I think Haskell could be faster than fortran too :D
07:40:39 <cmccann> dEPy: you can think of the <$> and <*> stuff as lifting a regular function and composing it with each of the functions
07:40:42 <Taneb> Oh man, Hayoo is down
07:41:55 <bgamari> I just noticed that myself
07:41:56 <cmccann> ijp: for example, Haskell excels at benchmarks that involve doing a bunch of calculation and then discarding the result :D
07:42:16 <beaky> lol
07:42:59 <beaky> how are typeclasses different from interfaces
07:43:14 <beaky> in the static object-oriented languaaaes?\
07:44:13 <typoclass> beaky: one difference is that an interface is a type (if you have an interface Runnable, you can have a variable "Runnable r = ..."). typeclasses are not types
07:45:06 <beaky> ah
07:45:10 <cmccann> that's partly a consequence of having subtyping
07:45:36 <beaky> and there are no such thing as subtyping in haskell?
07:45:40 <beaky> there is*
07:46:04 <cmccann> not in the same way
07:46:53 <beaky> ah
07:47:04 <beaky> I guess subtyping isn't important :D
07:47:08 <beaky> even for ad-hoc polymorphism
07:47:38 <cmccann> using an interface as a type is sorta like an existential with a type class constraint in Haskell
07:47:58 <cmccann> but lacking proper subtyping it's far less useful
07:48:05 <beaky> ah
07:48:11 <cmccann> and usually considered a bad approach in Haskell
07:56:39 <RenJuan> somebody should do a Haskell Manual of Style
07:57:23 <beaky> if monoids are so easy, and monads are burritos, what are applicatives?
08:01:03 <danr> strong lax monoidal endofunctors?
08:02:51 <cmccann> Applicative is really more about being a closed functor than monoidal
08:03:07 <cmccann> but if both categories are monoidal closed those are the same anyway
08:03:35 <beaky> ah
08:03:40 <cmccann> you basically get "a functor that preserves currying"
08:03:43 <beaky> so a closed functor is like a functor
08:03:50 <elliott> but closed.
08:03:52 <beaky> ah
08:03:58 <cmccann> a closed functor is a functor between closed categories
08:04:32 <cmccann> which are categories that have objects corresponding to hom-sets
08:05:44 <monoidal> bit like Haskell monads are actually Kleisli triples
08:05:44 <cmccann> which in programming terms basically means having higher-order functions
08:05:48 <elliott> cmccann: and what's a category?!?!
08:06:01 <cmccann> elliott: please see shachaf's diagram for details
08:06:13 <elliott> that diagram was made specially for me. I'm special.
08:06:19 <cmccann> yes.
08:06:22 <elliott> good.
08:06:23 <cmccann> that diagram is also special.
08:06:27 <elliott> yes. for me.
08:06:38 <cmccann> it's special for you in a special way.
08:06:52 * danr wants to see the special diagram
08:07:47 <cmccann> danr: https://twitter.com/copumpkin/status/302960443067101185
08:07:52 <elliott> danr: http://flockdraw.com/upload/8kr07f6lb00s44k80c4.png
08:07:56 <elliott> wow, go to hell cmccann.
08:08:02 <cmccann> hahaha yessssssss
08:08:04 <elliott> do you have it bookmarked or something? I cannot imagine anyone finding it quicker than I did.
08:08:09 <cmccann> no.
08:08:12 <cmccann> I actually googled for it.
08:08:24 <elliott> oh. I went to copumpkin's twitter and hit the end key a lot
08:08:28 <elliott> then I typed ctrl+f shachaf
08:08:38 <cmccann> clearly that approach is suboptimal.
08:08:48 <danr> oh, that's great!
08:09:08 <elliott> note that the black lines were my addition.
08:09:22 <elliott> that h used to be lowercase. and the E used to be an L. it was unacceptable
08:09:53 <danr> now put this on a tshirt
08:11:08 <parcs> hi
08:12:05 <elliott> i'd wear it
08:20:52 <the-m6> does anyone know why using an infinite list in a list comprehension, with a predicate filter that truncates the list, bombs out ghci?
08:21:02 <the-m6> i.e. :             buggyNatsBelow n = [x | x <- [1..], x < 10]
08:21:31 <the-m6> err,    buggyNatsBelow n = [x | x <- [1..], x < n]
08:21:36 <Taneb> the-m6, because the filter doesn't know that the list increases forever
08:21:48 <Taneb> > [x | x <- [1..], x < 10]
08:21:52 <lambdabot>   mueval-core: Time limit exceeded
08:21:58 <Taneb> > take 10 [x | x <- [1..], x < 10]
08:22:02 <lambdabot>   mueval-core: Time limit exceeded
08:22:07 <Taneb> > take 9 [x | x <- [1..], x < 10]
08:22:08 <hpaste> “Anonymous Coward” pasted “System.Random type error” at http://hpaste.org/86172
08:22:08 <lambdabot>   [1,2,3,4,5,6,7,8,9]
08:22:20 <Taneb> the-m6, use takeWhile
08:22:36 <the-m6> so it has to do with the laziness of list construction, and the way in which the filter is applied
08:22:38 <the-m6> cool man
08:22:44 <the-m6> that was surprising to me
08:22:50 <ihm1> http://hpaste.org/86172  Any idea what's going on here?
08:23:18 <Taneb> ihm1, add a type signature, it doesn't know what type you want
08:23:33 <ihm1> Why can't it be polymorphic?
08:24:20 <the-m6> thanks taneb.
08:24:20 <ihm1> λ > :t random g
08:24:21 <ihm1> random g :: (RandomGen g, Random a) => (a, g)
08:24:38 <danr> it won't generate a random type for you ;)
08:24:41 <ihm1> what about the hpasted expression makes it any less typeable?
08:24:49 <Taneb> the-m6, because they're both polymorphic separately. As soon as you access a, you have to know the type of b
08:29:30 <ihm1> Taneb: What of this then? http://hpaste.org/86174
08:31:06 <Taneb> ihm1, that looks like it works. Does it?
08:31:11 <ihm1> Nope
08:31:17 <ihm1> Let me add the type error
08:31:55 <hpaste> ihm1 revised “Another System.Random type error”: “Another System.Random type error” at http://hpaste.org/86174
08:33:29 <Taneb> ...huh
08:34:19 <ihm1> Providing a concrete RandomGen type doesn't help either
08:37:37 <monoidal> ihm1: your code compiles for me
08:38:43 <ihm1> monoidal: What version of ghc do you have?
08:38:46 <monoidal> 7.6.2
08:38:52 <ihm1> I'm running 7.4.2
08:40:04 <ihm1> Hm
08:40:44 <monoidal> ihm1: does it work with randomVector :: StdGen -> Int -> ([Double], StdGen) ?
08:41:16 <ihm1> monoidal: Nope
08:41:59 <monoidal> ihm1: what is the error?
08:42:15 <monoidal> (don't paste it here - tell me just the first line or via hpaste)
08:43:09 <hpaste> ihm1 revised “Another System.Random type error”: “Another System.Random type error” at http://hpaste.org/86174
08:44:40 <ihm1> monoidal: http://hpaste.org/86174
08:45:50 <monoidal> ihm1: can you add a signature to the line with random: "(x, g')  = random g :: (Double, StdGen)"?
08:46:31 <monoidal> it is really weird. I never suspected GHC could give amgiguity errors in a such simple situation.
08:46:45 <ihm1> monoidal: That worked actually. I don't see why it's needed though
08:48:34 <bitonic> what’s the name for the graph algorithm that given a graph with vertices V and given a subset of the edges V’ it builds a new graph with vertices V’ where you have new edges added for all the paths formed by vertices in V ∩ V’?
08:49:34 <monoidal> ihm1: I don't see it either. It's probably a bug in GHC, since it changed in 7.6
08:52:04 <ihm1> Strangely it's also not a problem in 7.4.1
08:52:20 <kate_r> hi
08:52:25 <kate_r> i have a rather logic-related question
08:52:26 <kate_r> does anyone know what the type of a first order function might be in HOL's type theory?
08:53:44 <monoidal> ihm1: by the way, you can write the function very concisely using the state monad (it's essentially replicateM)
08:54:38 <ihm1> monoidal: Yes good point
08:55:01 <typoclass> ihm1: how about the dmr?
08:55:26 <ihm1> typoclass: Turning on NoMonomorphismRestriction had no effect
08:55:37 <typoclass> ihm1: i see. hm!
08:55:41 <typoclass> how weird
08:56:11 <monoidal> ihm1: for a spoiler, see http://hpaste.org/86177
08:58:20 <ihm1> monoidal: Nice! I wasn't aware of the `state' function so mine was a bit more verbose
08:59:30 <ihm1> monoidal: Oddly with that definition ghc is happy with the fully polymorphic type
08:59:30 <ihm1> randomVector :: (RandomGen g, Random a) => g -> Int -> ([a], g)
09:02:00 <monoidal> ihm1: some time ago 'State' was usually used instead of 'state' (it was a constructor of the State monad); after the redesign everything users transformers and the constructors are not exported
09:02:22 <elliott> actually, the constructor is exported
09:02:25 <elliott> it's just the constructor is StateT
09:02:30 <elliott> previously State was its own type, not StateT over Identity
09:03:02 <monoidal> ihm1: in general, you can read most of System.Random library as-if they used state, for example random can have type State StdGen Double
09:03:16 <monoidal> elliott: right, thanks for correction
09:04:51 <dmj> I can make a monad a functor by just making fmap = liftM right?
09:05:04 <Taneb> Yes
09:05:30 <dmj> would this also be suitable? fmap f ma = return f `ap` ma
09:05:59 <monoidal> dmj: yes
09:06:07 <dmj> and this: ma >>= (return . f)
09:06:19 <monoidal> dmj: also yes
09:06:24 <elliott> this is too easy. say something false! :)
09:06:51 <monoidal> dmj: personally I prefer the last one, since it uses bare monad functions
09:07:41 <dmj> elliott: oh don't worry, that will come
09:08:15 <dmj> monoidal: why do I need to put the -XFlexibleInstances tag and -XundeciableInstances tag to do this?
09:08:22 <dmj> monoidal: to make a monad a functor
09:08:27 <mvb> > foldl (+) 0 [1,2,3]
09:08:29 <lambdabot>   6
09:08:32 <elliott> it's fine to make *a* monad a functor.
09:08:33 <abizern> I'm having trouble with `cabal install hake`: I get: Could not find module `System.Directory.Tools'
09:08:35 <elliott> *all* monads, however...
09:08:59 <dmj> elliott: which monads cannot be made functors?
09:09:00 <hpc> elliott: is also fine, except haskell's type system gets in the way ;)
09:09:24 <elliott> dmj: none
09:09:31 <hpc> dmj: none; writing the general instance causes a lot of inference problems
09:10:01 <hpc> and requires extensions in the module (and modules that import it?) to work
09:10:07 <monoidal> dmj: you are writing instance Monad f => Functor f? Problem is, this will not do what you might think it should
09:10:24 <hpc> dmj: what should really happen is the opposite
09:10:33 <hpc> Functor f => Monad f
09:10:37 <dmj> monoidal: yes, instance Monad m => Functor m where
09:10:38 <hpc> or rather
09:10:47 <monoidal> dmj: It will mean: If you want a Functor instance for some f, search for the Monad instance. The solver does not backtrack.
09:10:47 <hpc> Functor f => Applicative f, Applicative f => Monad f
09:11:23 <monoidal> dmj: You need undecidable instances, because with such definitions search ing for an instance might loop
09:11:24 <kqr> if i'm going to learn a UI toolkit for haskell, is wx or gtk preferred?
09:11:36 <hpc> kqr: might as well learn both
09:11:41 <hpc> decide which you like better
09:11:55 <Clint> then fix qt
09:12:16 <kqr> hpc, so it's just a matter of which one i like the most, and not that one is severely disadvantaged compared to the other in terms of libraries?
09:12:27 <dmj> monoidal: so undecidable instances is a compiler option that will stop ghc's looping?
09:12:35 <monoidal> dmj: No. it will allow it
09:12:52 <mvb> so interfaces. I have a class Buffer/LinkedList that have operations like foreach and accumulate, ie in haskell map and fold. can I have a class that ALSO implements an interface? like all datastructures could have methods for doing something to each value or adding all the values together.
09:12:55 <hpc> Clint: ;)
09:13:01 <monoidal> dmj: Otherwise, finding instances has to terminate because the types get smaller
09:13:40 <monoidal> dmj: well, strictly speaking ghc has an option that limits the depth
09:14:17 <monoidal> (I don't remember the details here)
09:16:01 <engla> mvb: those interfaces are here http://www.haskell.org/haskellwiki/Foldable_and_Traversable   (or I'm not sure what you mean)
09:17:28 <mvb> lol that was suppsoed to go in C++ :)
09:17:42 <dmj> monoidal: interesting, Can classes use this kind of syntax as well? class Monad m => Functor m where ... to create a sort of interface inheritance?
09:18:23 <dmj> monoidal: Just assume for some arbitrary classes, Monad and Functor would be a bad example
09:18:33 <Rotaerk_> :t Applicative
09:18:35 <lambdabot> Not in scope: data constructor `Applicative'
09:18:35 <Rotaerk_> err
09:18:47 <Rotaerk_> :info Applicative
09:18:57 <Rotaerk_> there something akin to than in here?
09:19:01 <Rotaerk_> that*
09:19:54 <Rotaerk_> whatever; dmj, look at the definition of Applicative:   http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Control-Applicative.html
09:22:04 <hpaste> kqr pasted “what does this cabal error mean?” at http://hpaste.org/86180
09:22:38 <monoidal> dmj: You can write "class Functor m => Monad m" to assert that every monad instance should be a functor
09:22:45 <dmj> Rotaerk: thanks I see, so GHC defines all Applicatives to be Functors, but not all Functors are Monads so we have to make an instance to do this, not a class. Is this going to be fixed?
09:23:46 <kqr> i'm trying to install wxhaskell with cabal, but it throws me the pasted error message. it also warns me about a missing configuration. could it be that i have an old version of the wx libraries from the package manager?
09:24:12 <monoidal> dmj: I hope it will, but it might be hard to fix. People often desire Applicative m => Monad m.
09:27:23 <dmj> monoidal: So were Monads added first then Applicatives and Functors?
09:27:57 <monoidal> dmj: Applicatives were later. Not sure if monads were the same time as functors.
09:28:41 <aristid> it wouldn't surprise me (although i don't know) if functors came before monads
09:29:16 <monoidal> dmj: it is possible - though distant - that the hierarchy problem might be fixed with new GHC extensions that allow default definitions
09:36:24 <ExternalReality> Are there any database productes out there that use Algebraic Data Types to represent Schemas. All I can find is Acid State and XML stores. I know Object Oriented databases exist.
09:36:28 <kqr> (the problem was old wx libraries, for whoever's curious)
09:37:01 <abizern> kqr - how did you delete the old libraries?
09:37:27 <kqr> abizern, apt-get remove
09:37:38 <kqr> abizern, installed new(er) through deb packages
09:37:54 <abizern> ta
09:48:35 <t4nk761> how can do a map on type [IO (Maybe [HistoricalQuote])]
09:49:58 <Rarrikins> @hoogle [IO a] -> IO [a]
09:49:59 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:49:59 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
09:49:59 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
09:51:49 <Jed__> Hi
09:52:52 <typoclass> Jed__: hello
09:53:23 <Jed__> Can anyone here help with a small / simple problem?
09:53:32 <Rarrikins> t4nk761: Maybe something like fmap (map f . catMaybes) . sequence
09:54:34 <t4nk761> hoogle catMaybes
09:54:42 <t4nk761> @hoogle catMaybes
09:54:42 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:01:35 <t4nk761> Rarrikins: that didn't work
10:01:49 <Rarrikins> t4nk761: Didn't work how?
10:02:06 <t4nk761>     Expected type: [a0 -> [Maybe (Maybe [HistoricalQuote])]]
10:02:12 <t4nk761>       Actual type: [IO (Maybe [HistoricalQuote])]
10:03:09 <t4nk761> The function I want to map has type fmtHQuote :: Maybe [HistoricalQuote] -> IO ()
10:03:32 <t4nk761> [IO (Maybe [HistoricalQuote])]
10:03:42 <Rarrikins> @type fmap (map f . catMaybes) . sequence
10:03:43 <lambdabot> (Monad f, Functor f, Show a, FromExpr b) => [f (Maybe a)] -> f [b]
10:04:08 <Rarrikins> @type fmap (map f) . sequence
10:04:10 <lambdabot> (Monad f, Functor f, Show a, FromExpr b) => [f a] -> f [b]
10:06:42 <t4nk761> Rarrikins : fmap (map fmtHQuote) . sequence works, but not is getting printed.
10:10:21 <Rarrikins> Maybe: join . fmap (f . sequence) . sequence
10:12:14 <Rarrikins> That should turn it to IO [Maybe a], then to IO (Maybe [a]), then apply f to it, then convert it from IO (IO ()) to IO ().
10:14:26 <Rarrikins> f . Just . catMaybes might be better for the fmap, though.
10:17:06 <dan_s28> why is compare (odd 3) (odd 6) GT?
10:17:19 <elliott> > (odd 3, odd 6)
10:17:21 <lambdabot>   (True,False)
10:17:24 <elliott> True is greater than False.
10:17:42 <dan_s28> is that a basic Boolean rule?
10:17:48 <Taneb> It's a Haskell rule
10:18:01 <Taneb> I think it's also the rule in e.g., C
10:18:03 <natte> if you map them to 1 and 0, makes sense
10:18:03 <dan_s28> good > evil :)
10:18:11 <dan_s28> true natte
10:18:11 <CindyLinz> -1 is true in C..
10:18:36 <monochrom> please don't read too much into it. a convention is picked, that is all.
10:18:42 <t4nk761> Rarrikins: let's start from stracth
10:18:50 <dan_s28> ok mono
10:19:26 <t4nk761> i want to map Maybe [HistoricalQuote] -> IO () over [IO (Maybe [HistoricalQuote])]
10:19:28 <dan_s28> reading the two pop books , bouncing between them (learn you and real wolrd) - thanks for the answersw
10:19:42 <Rarrikins> Oh!
10:20:01 <elliott> generally you don't want [IO ...]
10:20:15 <Rarrikins> t4nk761: I missed the [HistoricalQuote] in the type
10:21:12 <Rarrikins> t4nk761: So, you can sequence it to turn it to IO [Maybe [HistoricalQuote]]. You can then fmap (map f) to turn it to IO (IO ()). You can then join to turn it to IO ().
10:21:28 <Rarrikins> Hmm, not quite right.
10:21:39 <t4nk761> :t sequence
10:21:40 <lambdabot> Monad m => [m a] -> m [a]
10:21:55 <t4nk761> :t join
10:21:57 <lambdabot> Monad m => m (m a) -> m a
10:22:07 <cmccann> the convention in general is for the "nope" constructor to be first in the type definition, which makes it compare as less than other constructors
10:22:15 <cmccann> cf. Nothing, Left, []
10:23:09 <byorgey> :t  \f -> join . fmap (mapM_ f) . sequence
10:23:10 <lambdabot> (Monad m, Functor m) => (a -> m b) -> [m a] -> m ()
10:23:19 <byorgey> how's that?
10:23:24 <Rarrikins> Yeah, that's it :)
10:25:20 <t4nk761> OMG is it Brent. I am big fan of your Typeclassopedia article.. Thank you.
10:25:38 <byorgey> thanks t4nk761, glad you enjoyed it =)
10:25:45 <cmccann> byorgey: so apparently you're the PR guy for making pretty pictures with Haskell?
10:25:58 <byorgey> I guess so!
10:26:20 <cmccann> I've been working on a painting application in Haskell, if you'd find that interesting
10:26:20 <byorgey> are there any particular pretty pictures you would like made with Haskell?  Or any people who need convincing? =)
10:26:27 <byorgey> neat
10:26:47 <t4nk761> byorgey: I also went through your lecture notes as well.. Keep them coming. Haskell needs you.
10:26:56 <byorgey> thanks t4nk761
10:27:14 <cmccann> I'd been using MyPaint but it's dedicated to being pretty minimalist and is occasionally a bit laggy, and drawing in GIMP is just annoying
10:27:18 <cmccann> so I decided to write my own
10:28:28 <t4nk761> Rarrikins and byorgey : that worked like a charm
10:28:37 <t4nk761> thanks for jumping in.
10:29:10 <t4nk761> i will spend the rest of the day understanding it.
10:29:59 <cmccann> byorgey: anyway, dunno how close that is to the stuff you're interested in. I can let you know when I have it working well enough to be worth using, if you like
10:30:58 <byorgey> cmccann: so is it raster-oriented or vector-oriented?
10:31:05 <beaky> I am a dude
10:31:40 <cmccann> byorgey: primarily raster
10:32:43 <cmccann> and assumes a pressure-sensitive drawing tablet
10:32:50 <byorgey> ah, cool
10:32:58 <ClaudiusMaximus> cmccann: any plans for symmetry support for drawing tilings?
10:33:06 <cmccann> yes
10:33:13 <cmccann> also some sort of animation support eventually
10:33:21 <byorgey> cmccann: I'm definitely interested, I'd love to hear more when you have it working etc.
10:33:35 <ClaudiusMaximus> great, looking forward (i have a cheapo tablet that I've bearly used)
10:33:43 <ClaudiusMaximus> *barely
10:34:22 <cmccann> I hacked the GTK bindings so I could get the pressure input, which is working. now I'm tinkering with how to store the image data.
10:34:37 <cmccann> one idea I'm taking from MyPaint is no set canvas size
10:35:07 <cmccann> just an infinite canvas view that expands the image data as necessary when you draw
10:35:34 <byorgey> that sounds nice
10:35:58 <cmccann> I'm also using openGL for display so I can do photoshop layer blending type stuff in a fragment shader
10:38:58 <cmccann> any suggestions or ideas for the application are welcome though I dunno how many people in here even have a tablet...
10:42:33 <cmccann> byorgey: oh also, jmcarthur is getting the band back together^W^W^W^W^W organizing an effort at building a coherent game development library for Haskell
10:42:40 <cmccann> which might be sorta relevant as well
10:42:47 <parcs> woot!
10:43:06 <cmccann> as anyone idling in #haskell-game has probably noticed
10:43:52 <parcs> i think you mean ^H :P
10:44:06 <cmccann> probably
10:44:18 <parcs> wait, never mind..
10:44:27 <cmccann> I was too enthusiastic about making a blues brothers reference to look up the specifics
10:44:37 <cmccann> priorities
10:47:04 <cmccann> byorgey: what do you use for geometry types in diagrams? vector-space?
10:54:12 <jmcarthur> cmccann: yeah it looks like vector-space
10:54:20 <jmcarthur> http://hackage.haskell.org/packages/archive/diagrams-core/0.6.0.2/doc/html/Diagrams-Core-Points.html
10:54:27 <cmccann> yeah, was just looking
10:55:00 <cmccann> I was actually considering whether we should maybe just use it, at least for now
10:55:02 <jmcarthur> i am a fan of the newtype wrapper approach
10:55:06 <jmcarthur> i was thinking that too
10:55:18 <jmcarthur> although i wish it had less stuff we don't need
10:55:33 <jmcarthur> all the memotrie deps and stuff
10:55:34 <cmccann> yeah but we were settling on something pretty close to a subset of it
10:55:53 <elliott> the edwardk platform™ has linear
10:55:55 <jmcarthur> most of it at least looks generally useful even if not directly for us, i guess
10:55:58 <elliott> if that suits your needs.
10:56:26 <jmcarthur> elliott: do you know if it has anything for affine spaces?
10:57:17 <cmccann> elliott: is it the painfully abstract sort of edwardk library, or the optimized in disturbing ways sort? or both?
10:57:40 <jmcarthur> the important bit of the wikipediea article: "In an affine space, one can subtract points to get vectors, or add a vector to a point to get another point, but one cannot add points. In particular, there is no distinguished point that serves as an origin."
10:57:46 <cmccann> we don't need to be super-optimized but we really don't want unnecessary overhead for basic geometric stuff
10:58:06 <jmcarthur> cmccann: it looks fairly practical to me
10:59:11 <elliott> cmccann: only one way to find out
10:59:15 <cmccann> it also seems to depend on a good chunk of the edwardk platform™ elliott mentioned
10:59:16 <jmcarthur> cmccann: although for a beginner still not very discoverable i guess
10:59:23 <elliott> (i think it's part of the disturbing new edwardk practical libraries trend)
11:00:12 <jmcarthur> cmccann: doesn't look huge. semigroupoids is the biggest of those in the list in terms of transitive dependencies i think
11:00:58 <cmccann> just noting
11:01:03 <jmcarthur> it has no story for points though
11:01:07 <cmccann> I'm not that averse to large dependency lists
11:01:36 <jmcarthur> i'm not either. i'm averse to a certain class of dependencies
11:02:01 <jmcarthur> in particular, ones that are not very quicky updated when necessary
11:02:07 <cmccann> well
11:02:11 <jmcarthur> ed's libs are fine there
11:02:28 <cmccann> updating quickly is definitely something edwardk can do I think yes
11:02:37 <jfischoff> is there such a thing as a free zipper?
11:03:39 <cmccann> jfischoff: oleg's reified traversal thing seems closest, but you'd first have to define a zipper precisely to know what a free one would look like
11:04:00 <jmcarthur> linear has a number of lensy types in it
11:04:03 <elliott> well, lens' zippers (soon to be zippers' zippers) are basically oleg's thing.
11:04:09 <elliott> but more generalised and actually useful.
11:04:13 <cmccann> most of the type-driven zipper stuff is more limited in what it can talk about
11:04:26 <jmcarthur> on the one hand that is convenient, but on the other hand that can be confusing documentation if you aren't familiar with how that works
11:05:10 <cmccann> jmcarthur: which types are you looking at?
11:05:53 <jmcarthur> cmccann: see for example the R2 class http://hackage.haskell.org/packages/archive/linear/1.1.1/doc/html/Linear-V2.html
11:06:24 <cmccann> oh yeah
11:06:43 <cmccann> those are actual lenses of the "no lens dependency" style
11:07:06 <jmcarthur> right
11:07:14 <jmcarthur> a style which i like
11:07:43 <cmccann> we can always selectively re-export stuff or provide a simplified core API or whatever
11:07:53 <jmcarthur> although i think it would like it more if some attempt was made to make it clear (not that we can't submit patches for that if we felt it necessary)
11:08:06 <elliott> it's sort of a bad style in some ways. :(
11:08:11 <jmcarthur> any library we use we can also contribute to
11:08:36 <cmccann> I'm still inclined to just suck it up and have a lens dependency
11:08:51 <elliott> wait, you're writing a full application and don't want a lens dependency? :p
11:08:56 <cmccann> no, this is a library
11:09:06 <jmcarthur> it is a set of libraries
11:09:15 <elliott> thing with lenses defined independently is that using them is still really painful without lens.
11:09:25 <cmccann> but I know any application I write using it would depend on lens
11:09:51 <jmcarthur> i am still not completely sold on the lens style
11:10:25 * hackagebot hlibgit2 0.18.0.2 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.2 (JohnWiegley)
11:10:34 <cmccann> I'm not sold on any of the alternatives
11:10:38 <jmcarthur> nor i
11:10:43 <jmcarthur> i am not sold on lenses in general
11:10:44 <cmccann> other than avoiding named fields entirely
11:11:04 <elliott> nice thing about lens being a kitchen sink is that you can use it in a bunch of ways
11:11:05 <jmcarthur> i never find myself wanting to do deep record updates really
11:11:14 <cmccann> and admittedly I'm a big advocate of not using named record fields without good reason
11:11:19 <elliott> psht, it's not really about records at all :p
11:11:25 <jmcarthur> (i know that)
11:11:32 <elliott> i mean, or fields.
11:11:46 <jmcarthur> traversals are great
11:11:48 <cmccann> ok yes, true :P
11:11:49 <jmcarthur> that aspect i like
11:12:11 * elliott wants a language with all the lens stuff built in.
11:12:14 <jmcarthur> i guess the thing i'm not sold on is "traverse all the things"
11:12:34 <cmccann> lens doesn't traverse ALL the things.
11:12:44 <cmccann> like IORefs, those are spoilsports.
11:12:46 <jmcarthur> it would if it could
11:13:44 <elliott> i hear that's being worked on :p
11:13:48 <elliott> also, prisms!!
11:14:34 <aristid> prisms!!!
11:15:09 <elliott> prisms!!!!!!!!!!¡
11:15:24 <beaky> monoids?
11:15:30 <aristid> beaky: too easy.
11:15:31 <cmccann> anyway, point is I expect lens to be a relatively common dependency for applications using our library, and we have enough dependencies that adding more of the edwardk platform (tm) doesn't bother me
11:15:35 <typoclass> beaky: lol
11:16:00 <jmcarthur> cmccann: i don't have concrete enough objections to hold water, so i concede
11:16:35 <cmccann> and I can see value to the consistency that would come from us picking a specific library to solve problems that lens solves
11:16:49 <cmccann> as part of the whole "bundle of libraries that work well together" notion
11:17:24 <jmcarthur> that is a compelling point
11:17:46 <parcs> :O
11:17:48 <jmcarthur> if we will use lens anyway, this linear package looks good too
11:18:09 <cmccann> we'll need to build more on top of it vs. vector-space I think
11:18:12 <jmcarthur> it only lacks affine spaces
11:18:21 <jmcarthur> and a distinct point type (we could newtype that)
11:18:25 <cmccann> but it's a good basis (ha, ha) to start from
11:18:30 <jmcarthur> i propose we just modify linear
11:18:35 <jmcarthur> ed will surely accept it
11:19:11 <cmccann> I dunno what his plans are for that package
11:19:16 <johnw> he's very likely to accept it
11:19:35 <jmcarthur> i think the scope of that package is pretty clearly defined and this falls into that scope
11:19:38 <cmccann> i.e. whether it's intended to be small and minimal and built on by other libraries
11:19:40 <cmccann> ok
11:19:42 <johnw> linear is in a really good state right now; what are you proposing adding to it, jmcarthur?
11:19:54 <johnw> cmccann: it's a minimal core right now
11:19:58 <jmcarthur> johnw: affine spaces and a newtype wrapper for points
11:20:08 <johnw> jmcarthur: that sounds quite appropriate
11:20:18 <johnw> and would obviate vector-spaces altogether, wouldn't it
11:20:24 <jmcarthur> i think not quite
11:20:37 <jmcarthur> vector-space has some other stuff too, but i don't think we need it, at least not right now
11:20:43 <cmccann> jmcarthur: it also occurs to me that we might want to have explicit support for homogeneous coordinates
11:21:01 <smithw> Hello. Suppose I have two functions, f :: a -> [b] and g :: b -> Maybe c. f generates an almost infinite list, for computation time purposes. Is there a way for me to have a "thread" running f, and multiple other threads running g, that last one grabbing elements from f's return value as soon as they become available?
11:21:03 <cmccann> though more as an eventually thing
11:21:14 <Fuco> OT: how can I typeset lens bracket in latex? The one used for anamorphisms?
11:21:26 <jmcarthur> cmccann: what for?
11:21:58 <cmccann> jmcarthur: for the same things that opengl uses them for
11:22:08 <jmcarthur> perspective projections?
11:22:47 <cmccann> they make a lot of calculations easier, moreso in 3d than 2d though
11:22:50 <jmcarthur> right
11:23:13 <jmcarthur> i guess in the long run we might offer some rudimentary 3d maths support or something, but yeah, for now it's not important
11:23:28 <cmccann> (also, technically with homogeneous coordinates you can distinguish vectors and points by value, but not by type)
11:24:48 <cmccann> I vaguely recall there being situations where they help in 2d as well
11:24:51 <jmcarthur> that is interesting. i didn't think about that. i think it's not what we want though
11:24:56 <cmccann> but I can't remember what
11:25:07 <fryguybob> cmccann: You con build up a transformation that includes translations.
11:25:08 <cmccann> it's not, I want that to be type-enforced
11:25:38 <cmccann> fryguybob: yeah, but how much does that simplify things in 2d? that's one thing I can't recall
11:25:47 <fryguybob> This gives you something like locally affine transformations.
11:25:49 <monochrom> smithw: try things in Control.Parallel and Control.Parallel.Strategies. they are in the "parallel" package. it comes with Haskell Platform.
11:25:49 <cmccann> transformation matrices are nice though
11:26:01 <jmcarthur> 2d affine transformations are already important
11:26:16 <smithw> monochrom, thanks, I will look it up
11:26:21 <jmcarthur> but you don't have to augment your coordinates to use them
11:26:46 <cmccann> yeah, homogeneous coordinates gets you a projective space
11:30:12 <hamid> @src uncurry
11:30:12 <lambdabot> uncurry f p = f (fst p) (snd p)
11:30:22 <jmcarthur> this is a cool signature for matrix multiplication, actually...  (!*!) :: (Functor m, Foldable r, Additive r, Distributive n, Num a) => m (r a) -> r (n a) -> m (n a)
11:31:06 <cmccann> jmcarthur: is there an easier way to combine and calculate affine transforms other than extending them to projective transforms and using a transformation matrix there?
11:32:03 <jmcarthur> cmccann: ah, no, i think that extension is the most straightforward. however, i think you can leave off the bottom row because it never changes
11:32:04 <cmccann> storing just a offset+angle makes it hard to compose transformations
11:32:45 <jmcarthur> so you end up with a 3x2 matrix
11:33:00 <cmccann> still, if we basically need to compute projective transformations anyway...
11:33:08 <cmccann> not a big deal either way though
11:33:34 <jmcarthur> if you think about it, it's just a 2x2 transformation matrix and a translation
11:33:56 <jmcarthur> just with the extra math to handle both at once when you compose them
11:34:29 <fryguybob> Also note that inverses do what you would expect them to (the inverse of the 3x3).
11:34:50 <cmccann> that's handy
11:34:54 <parcs> :)
11:36:24 <cmccann> anyway, I was asking byorgey about diagrams earlier because he has some geometry stuff in there that would be useful for us as well
11:37:02 <hamid> @src otherwise
11:37:03 <lambdabot> otherwise = True
11:37:05 <cmccann> but I'm not sure if there'd be any reasonable way to share code there
11:37:06 <hamid> :P
11:37:29 <lavorno> cmccann: how easy is to use diagrams ? how large is the biggest diagrams drawing (how many entities) ?
11:37:41 <cmccann> beats me, ask byorgey
11:37:46 <fryguybob> lavorno: Easy!
11:37:51 <jfischoff> easy
11:37:52 <cmccann> it's pretty easy to do simple stuff with
11:37:57 <cmccann> I never tried to do anything fancy
11:38:07 <cmccann> the examples are nice too
11:38:12 <lavorno> fryguybob: great - how about big size diagrams ?
11:38:33 <lavorno> yes, seen the examples and i like them v much indeed
11:38:35 <fryguybob> lavorno: We haven't focused on handling a large number of primatives, but I've made diagrams with thousands.
11:39:01 <lavorno> fryguybob: thousands of what ? (nodes/edges/colors/etc)
11:39:23 <fryguybob> Primiitves, so lines, beziers, whatever.  The output is typically rather large at that point, but in some cases you can cut it down by running it through some other processor.
11:39:38 <lavorno> sounds good
11:39:44 <lavorno> how about the size of the canvas ?
11:39:49 <lavorno> is that configurable ?
11:40:01 <lavorno> also - can you split the canvas in a nr of rectangles ?
11:40:15 <lavorno> (and get them individually then assemble them)
11:40:33 <fryguybob> lavorno: All the backends at this point use Doubles.
11:40:59 <fryguybob> lavorno: You do not have to worry about the cavas, you just work in a vector space.
11:41:03 <lavorno> fryguybob: i was asking abt something like a "virtual canvas"
11:41:21 <lavorno> so how do i conntrol the resolution? by zooming in ?
11:41:42 <fryguybob> lavorno: Each diagram is in its own vector space and combining diagrams does what you would hope that it would.
11:41:59 <fryguybob> lavorno: So you could think of each diagram as its own "virtual canvas"
11:42:02 <lavorno> that's great from model point of view
11:42:13 <lavorno> how about from representation/drawing pt of view ?
11:42:35 <fryguybob> lavorno: I'm not sure what you mean?
11:42:56 <lavorno> usually for large drawings (with many thousands of entities) the screen resolution is not enough
11:43:23 <lavorno> to avoid that people can define a "virtual canvas" so they can choose how big the drawing will be
11:43:46 <lavorno> so the images are visible and not touch/overlap in a hodge-podge
11:44:09 <fryguybob> lavorno: Diagrams is vector graphics so nothing is pinned down beyond having coordiantes that are Double precision floating point.
11:44:12 <lavorno> then u can split that canvas in 16x16 printouts
11:44:44 <fryguybob> lavorno: Oh, there is a primitive that takes a diagram and clips it to a particular view.
11:45:13 <lavorno> fryguybob: can you split a diagram in a nr of "pages" ?
11:45:32 <lavorno> (that when assembled together give the whole diagram back)
11:45:48 <lavorno> think about google maps for example
11:45:53 <fryguybob> lavorno: Sure.
11:45:55 <lavorno> they have a very large "virtual canvas"
11:46:16 <lavorno> and assemble pieces of it with various types of images, depending on what resolution u are looking at the map
11:46:25 <fryguybob> lavorno: Right now for most backends the "rest" of the diagram would not be culled though.
11:46:52 <lavorno> fryguybob: not clear what u mean, pls detail a bit
11:47:28 <fryguybob> If you look here and search for "clipping" there is an example: http://projects.haskell.org/diagrams/manual/diagrams-manual.html
11:47:47 <lavorno> ok, thanks - will take a look
11:48:27 <fryguybob> lavorno: In both those examples the "code" for the parts of the diagram not seen is still emitted.  It is up to the program that uses the file that diagrams gives to "remove" the extra data.
11:48:51 <fryguybob> That said if you know what you are making diagrams from you can do this culling yourself.
11:49:32 <lavorno> fryguybob: i am looking at handling a large nr of entities (thousands, maybe tens of thous)
11:50:05 <lavorno> the size can be approx equal in some cases (where the canvas size comes in the pic)
11:50:47 <lavorno> the size canb e quite different in other cases - in which the  capability to navigate is important (but this one sd b handled ok by the vector graphics)
11:51:27 <lavorno> (by "the size" i mean the raport between the diameter of the bigggest and the smallest entities in the diagram)
11:52:36 <fryguybob> lavorno: Right, as long as the range of a Double works for you it is fine.  We do have some work towards generalizing even that though.
11:52:50 <lavorno> sounds good
11:52:59 <lavorno> finally, being able to collapse parts of the digram would help also
11:53:39 <lavorno> meaning - can one draw a "high level diagram" initially then "zoom in" various parts and see what's in later no ?
11:53:46 <lavorno> (later on)
11:53:52 <fryguybob> lavorno: Yes
11:53:56 <lavorno> great
11:54:29 <lavorno> what's the environment used to display the diagrams ? can it be shown in a browser ? or needs a special GL env ?
11:54:40 <cocon2000> Is there any way to use a more light-weight/custom syntax for using a quasiquotation than [blah|...|] ?
11:54:53 <hamid> Is there anyway to find Functor Types in ghci?
11:55:20 <cocon> :i Functor
11:55:22 <fryguybob> lavorno: There are several backends so SVG, PDF, PNG, whatever you would want.
11:55:43 <hamid> cocon, thanks
11:55:45 <jfischoff> cocon2000: #define blah(x) [blah| x |] maybe?
11:55:56 <cocon2000> oh, good idea. thanks!
11:56:08 <jfischoff> that might not be valid cpp though ...
11:56:45 <lavorno> so for png the client needs to be a special one to allow for "packing" and "unpacking" of the sub-diagrams ? or can it work from a browser (when the zoom-in level gets over a certain level the lower level nodes are displayed" ?
11:56:48 <geekosaur> cpp shouldn't care
11:57:20 <fryguybob> lavorno: No that sort of thing is not built into diagrams.
11:57:49 <lavorno> so u need to have multiple kind of diagrams and manage the zoom level yourself, right ?
11:58:06 <lavorno> the diagrams are just calculating and printing the pics
11:59:06 <lavorno> fryguybob: does it support predefined layouts ? (can you tell it to draw one or a group of nodes in a specific point and then draw everything else around that ?) or it has to have full freedom where it chooses to draw the elements ?
11:59:13 <fryguybob> lavorno: Yes we are just producing the vector graphics typically in the form of a file.  But PDF for example does not need to read the whole file to display just one page.
11:59:39 <lavorno> fryguybob: sounds good - how about layout support ?
12:00:12 <fryguybob> lavorno: The manual that I linked to gives a better description then I can here.
12:06:26 <lavorno> fryguybob: thanks for helping out. is there proper support on mac? i have tried to use diagrams in the past and i didn't pass the install part.. where are we with that ?
12:06:48 <lavorno> (what's the best way to install it)
12:07:50 <fryguybob> lavorno: The SVG backend has less dependencies so it should be quite easy to install
12:08:25 <fryguybob> cabal install diagrams-svg
12:09:13 <lavorno> frygubob: k tx, very useful help. will give it a try and let u know ;)
12:09:59 <__xc> > ( map (/2) [4,6], [4,6] >>=  return . (/2) )
12:10:01 <lambdabot>   ([2.0,3.0],[2.0,3.0])
12:10:27 <__xc> lens way might look like #2
12:17:04 <czro> Hello. Short question regarding the ffi. I'm using Data.Vector.Storable Int and need to cast it to a C function taking an int* as argument without modyfing it. Do I have to convert the vector to a vector of CInt first?
12:18:28 <parcs> czro: a Haskell Int is not a C int
12:19:59 <czro> parcs: I know. Just wondered what the best practice is for passing haskell array to c. Use CInt arrays? (Vector). I'm gonna have a look at the hmatrix library sources to see how it's done there...
12:20:16 <parcs> yeah, use CInt if you want to pass ints to C
12:20:44 <parcs> don't convert but rather use CInt throughout
12:21:02 <parcs> if you need the extra bits then use Int64
12:21:14 <parcs> and expect an int64_t on the C side
12:21:27 <czro> parcs: ok. I'll give it a try. Thanks.
12:23:18 <mvb> bind and return is what i need for Maybe right?
12:23:21 <mvb> @src Maybe
12:23:22 <lambdabot> data Maybe a = Nothing | Just a
12:23:31 <parcs> need?
12:23:41 <mvb> @src (Maybe >>=)
12:23:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:23:51 <mvb> how do I egt the source for >>= for maybe?
12:24:02 <geekosaur> @src Maybe (>>=)
12:24:03 <lambdabot> (Just x) >>= k      = k x
12:24:03 <lambdabot> Nothing  >>= _      = Nothing
12:24:15 <mvb> >>= = bind?
12:24:44 <monoidal> mvb: yes
12:25:20 <monoidal> mvb: it's not like you need them for Maybe -- you need them to make Maybe a monad
12:25:37 <monoidal> mvb: or in fact any type constructor
12:26:03 <mvb> @type return
12:26:04 <lambdabot> Monad m => a -> m a
12:26:15 <mvb> @type (>>=)
12:26:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:26:36 <hseg> Although that's inaccurate. You could also make a type a monad by defining return, fmap, and join for it, or return and (>=>)
12:26:37 <lambdabot> hseg: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:26:50 <hseg> s/inaccurate/slightly inaccurate/
12:27:22 <merijn> mvb: FYI @src doesn't return the actual source
12:27:34 <merijn> mvb: It just does a lookup in a stored table and returns whatever code is there
12:28:15 <merijn> mvb: If you want to see the *actual* code you're usually better of following the "source" link on the haddock pages you find using for example google
12:45:20 <cmccann> roconnor: hey, what's the likelihood of getting some performance improvements into Data.Colour?
12:45:31 <luite> +1
12:45:32 <luite> ;p
12:47:32 <ivoscc> I'm having some issues trying to install pandoc on arch via cabal install, i'm getting the following http://hpaste.org/86192 , can I make it be more verbose about the error?
12:48:09 <supki> -v3
12:48:13 <donri> ivoscc: yeah, don't use -j ;) or see ~/.cabal/logs
12:49:21 <supki> ExitFailure 9 looks like if cabal was killed
12:50:03 <donri> exit codes don't correspond to kill signals AFAIK
12:51:47 <ivoscc> I'm trying again with -v3 and without -j (just put it there cause i saw it on hakyll's docs)
12:53:00 <monochrom> there is some chance of out-of-memory
12:54:49 <ivoscc> monochrom: you're right, http://hpaste.org/86193
12:56:17 <ivoscc> any idea why it would need 1048576 bytes :S ?
12:57:05 <monochrom> that's just 1MB. and the message just means "can't get another 1MB", as opposed to "can't have total 1MB"
12:58:11 <ab9rf> it probably allocates a meg at a time
12:58:42 <roconnor> cmccann: do you have performance measurements?
12:58:52 <ab9rf> what are you building this on?
12:58:55 <ivoscc> oh, was thinking kbytes
12:59:11 <ivoscc> ab9rf: arch vps
12:59:17 <ab9rf> what OS, arch, system memory, swapfile?
12:59:39 <dmj> can pandoc convert .lhs to .html?
12:59:50 <Nisstyre-laptop> probably
12:59:52 <Nisstyre-laptop> man pandoc
12:59:58 <roconnor> cmccann: I'm certainly willing to accept any patches to improve performance as long as it doesn't break the abstraction.  I'm hoping some RULES might be extremely helpful.
13:00:48 <ivoscc> ab9rf: htop shows 157/999MB, swap 0/0 MB
13:00:58 <ivoscc> don't think thats a problem
13:00:58 <ab9rf> that's your problem
13:01:04 <ab9rf> you only have a gig of ram and no swap
13:01:09 <ab9rf> you're OOMing
13:01:16 <cmccann> roconnor: I kinda wanted unpacked (or even storable) vectors of your types
13:01:25 <ab9rf> add a swapfile and try again
13:01:28 <cmccann> roconnor: and luite had another issue about conversions
13:02:05 <dmj> omg that's awesome
13:02:24 <luite> oh yeah nonlinear sRGB conversion uses a really slow codepath with generic realToFrac or something
13:03:47 <rifki> Hi, I need to overload (==) operator for a special data type. Is there a way other than that giving an Eq instance?
13:04:13 <cmccann> rifki: that's exactly what Eq instances are for
13:04:14 <ab9rf> rifki: nope
13:04:26 <ab9rf> rifki: that's the only way to do it.  why would you wnt to do ait any other way?
13:04:31 <engla> happily, there is no overloading in haskell. only typeclasses
13:04:33 <cmccann> rifki: you can write your own instance by hand instead of deriving it
13:04:44 <monochrom> you have to fight it or join it. that is, you have to suppress Eq or use Eq.
13:05:01 <monochrom> "if you can't join them, beat them"
13:05:12 <ab9rf> Eq only requires (==), right?
13:05:15 <mauke> > join (==) 'k'
13:05:17 <lambdabot>   True
13:05:18 <monochrom> yes
13:05:25 <monoidal> ab9rf: yes, although you can use (/=) too
13:05:33 <ab9rf> monoidal: that's what i figured.
13:05:39 <rifki> I'm told that I should define a class and then overload the operator
13:05:44 <monoidal> they're defined in terms of each other
13:05:50 <ab9rf> rifki: the type class already exists, it's called Eq
13:06:06 <ab9rf> you can't overload in haskell
13:06:20 <monoidal> rifki: Either define a new class, say "Equatable" and your own operator, or use existing class Eq
13:06:21 <ab9rf> (==) is only defined on types that are in Eq
13:06:30 <ab9rf> you can make your own operator, but it won't be (==)
13:06:37 <monoidal> rifki: there's no option to use (==) for non-Eq
13:06:42 <ab9rf> it'll be (=~=) or something
13:06:52 <geekosaur> rifki, I asked this yesterday, although not quite in as much detail... can you please show us (in pastebin) the exact problem wording?
13:07:21 <hpaste> mvb pasted “Maybe in python, hrrm” at http://hpaste.org/86194
13:07:24 <geekosaur> because the wording you are using is not appropriate for Haskell at all, and I don't think your instructor really used the terminology you are using
13:07:30 <rifki> monodial : I should do what you said first, can you give me more information about
13:07:41 <rifki> monodial : about it?
13:07:52 <mvb> Anyone have a nicer idea for how to implement Maybe in python http://hpaste.org/86194 ??
13:08:01 <ivoscc> ab9rf: you were right, added swapfile and it compiled smoothly :)
13:08:04 <latro`a> that all assumes you don't hide the Eq class
13:08:06 <monochrom> rifki: who told you to define a class, and what is the context, and where can we read it on the web?
13:08:12 <latro`a> in which case you can define == in a different class name
13:08:25 <ab9rf> ivoscc: ghc can use very large amounts of memory
13:08:53 <rifki> monochrom : it's a homework so..
13:09:10 <ivoscc> ab9rf: yeah, I can see that, such a hungry monster hehe, thanks!
13:09:15 <monochrom> yes, we want to read the homework verbatim uncensored
13:09:16 <geekosaur> so?
13:09:26 <geekosaur> you are allowed to show us the exact wording of the assignment
13:09:36 <geekosaur> what is not allowed is someone feeding you the exact solution
13:09:36 <ab9rf> trust us, we won't steal your instructor's homework
13:10:00 <monoidal> mvb: haskellish bind is non-destructive (it returns a new object). not sure would that be better by Python standards
13:10:04 <ab9rf> technically we're allowed to feed it to you, but you're not allowed to accept it :)
13:10:19 <geekosaur> but we can try to help youunderstand (a) what the instructor is asking (b) how to figure out the answer yourself
13:10:19 <ab9rf> well, i am, since i have no academic affiliations
13:10:32 <ab9rf> some of the others here might be under honor code restrictions because they are academics
13:11:03 <monoidal> rifki: in any case, if you insist on creating your own class, and can't do it yourself, I recommend reading a little. it's basic material
13:11:30 <monoidal> rifki: for example, see learnyouahaskell.com
13:11:52 <rifki> okey, thanks
13:12:41 <monochrom> I actually have no moral objection to doing someone else's homework. the only things stopping me are I am uninterested and I am unpaid.
13:13:28 <monochrom> but I am really upset at "put the question in your own words to show that you don't understand"
13:13:45 <mauke> occasionally I do someone's homework in creative ways
13:14:14 <mauke> like solving someone's C exercise in Haskell
13:14:48 <mauke> also good: doing it in C but every function in the program consists of exactly one return statement
13:15:07 <monochrom> as for learning, I believe in Piaget's theory, concrete before abstract. therefore, in beginner contexts, the best presentation of "the general, abstract direction" is the concrete solution itself.
13:16:25 <ab9rf> monochrom: i will admit that about half the time someone is in here with a homework problem they can't figure out, it's because they've misunderstood the instructor's intentions
13:16:51 <lispy> learning is hard
13:17:04 <monochrom> broad, handwaving descriptions of "the general, abstract direction" of course make total sense to people who have already finished learning
13:18:56 <adimit> misunderstanding of the instructor's intentions does not seldom stem from poorly *formulated* intentions, or from poorly *understood* intentions on the instructor's side (i.e. I've seen plenty of people give exercises they demselves didn't fully grasp.)
13:19:25 <adimit> *themselves. boo. What's wrong with me?
13:23:01 <roconnor> luite: what do suggest instead of realToFrac?  Aren't there specialization RULES for realToFrac?
13:23:14 <cmccann> perhaps the rules aren't firing for some reason
13:23:30 <roconnor> cmccann: I'm probably not interested in anything that isn't (compatible with) Haskell 98
13:23:47 <cmccann> there was a Q on StackOverflow at one point about some rules that weren't firing because they were eta-expanded for no good reason
13:24:03 <luite> roconnor: yeah there are, but that only works if the code that calls it is not polymorphic
13:24:07 <hpaste> mvb pasted “Python maybe not to be(got it :) )?” at http://hpaste.org/86197
13:24:18 <luite> roconnor: adding specialization rules to the conversion code would fix it
13:24:23 <mvb> bah ^^ Maybe doesnt fit so well with Python semantics I guess
13:24:24 <roconnor> luite: so some SPECIALIZE pragma should get rid of the polymorphism?
13:24:34 <roconnor> I will accpet patches with SPECIALIZE pragmas
13:25:08 <cmccann> roconnor: hm I guess Storable is from the FFI addendum
13:25:13 <cmccann> which wasn't actually in H98
13:25:28 <luite> roconnor: i worked around it for now by doing the delinearization in my own specialized code
13:25:29 <mel-> hi
13:25:33 <roconnor> cmccann: okay I might consider Haksell 2010/2011
13:25:43 <roconnor> luite: understood
13:26:15 <roconnor> what does Storable do?
13:26:18 <cmccann> dunno if there's anything I can do about unboxed vectors though
13:26:43 <mel-> I'd like to use the Maybe monad inside the IO monad (as in this small example: http://hpaste.org/86198). How do I do that? The program as it is does not compile. Is this a situation where I need to use monad 'transformers'? Thanks!
13:26:48 <cmccann> roconnor: translate to a C struct-style memory representation
13:27:31 <mauke> @src Storable
13:27:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:27:32 <geekosaur> mel-, easiest solution there is use let instead of <-
13:27:41 <Mortchek> mel-, you want let, not <-
13:27:50 <Mortchek> let a = foo l
13:27:52 <ab9rf> what dey sed
13:27:56 <geekosaur> <- is only for values in the monad (in this case IO); for a pure value you want let
13:28:30 <mel-> Hmmm, okay, thanks. I thought that <- would be desugared to let anyway.
13:28:33 <geekosaur> (now, if you were using Maybe monadically it might change, but you're using it as a pure computation)
13:28:35 <mel-> Seems I was wrong.
13:28:42 <Mortchek> do { a <- foo l ; whatever } is equivalent to foo l >>= \a -> whatever
13:28:52 <geekosaur> no, <- desugars to monadic bind (>>=)
13:29:03 <ab9rf> there's no monad to bind into here
13:29:11 <Mortchek> @type (>>=)
13:29:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:29:28 <hseg> Doesn't <- desugar to bind with a lambda abstraction?
13:29:31 <merijn> "do { let x = bar; foo }" desugares to "let x = bar in foo"
13:29:33 <Mortchek> Since foo l is a Maybe Bool and your whatever returns an IO (), the types don't match up
13:29:44 <hseg> i.e. a <- expr desugars to expr >>= \a ->
13:29:52 <merijn> hseg: Yes
13:29:57 <geekosaur> hseg, yes, but neither is "let"
13:30:21 <geekosaur> (although the lambda is in some sense "close" to ```let```
13:30:22 <geekosaur> (
13:30:30 <geekosaur> ... typing hopw does it work
13:30:47 <ab9rf> a keyboard! how quaint!
13:31:07 <Mortchek> ab9rf, I suppose you type using Morse code?
13:31:49 <Mortchek> Hmm, "quaint" could go either way technologically
13:31:58 <roconnor> cmccann: are you thinking Storable for RGB or for Colour itself?
13:32:17 <Mortchek> You could be one of those "a true hacker would use X" people or someone who uses something way more advanced and convenient than a keyboard
13:32:25 <roconnor> what I really need to do is learn criterion and test to see what rules make a difference
13:32:32 <roconnor> I guess I need to make some benchmarks
13:33:06 <mel-> okay, but how would i do the following? Say I have "rollDice :: IO Int" and I want to use this function in a computation of type "callback :: Maybe (IO ())"
13:33:14 <cmccann> roconnor: unfortunately what I'd really like is unboxed vectors of AlphaColour, Storable would only save me from having an orphan instance
13:33:28 <roconnor> right
13:33:34 <mel-> I cannot get my code to compile since when i use rollDice I get a type mismatch.
13:33:51 <monoidal> mel_: use Just?
13:34:11 <Mortchek> mel-, what would that computation do?
13:34:11 <cmccann> roconnor: but vector uses extensions and I don't think I can implement it efficiently without having something that breaks the abstraction somehow
13:34:20 <hseg> mel-: If you can change the signature of callback to Maybe (IO a), then you could just wrap the value of rollDice in a Just.
13:34:24 <roconnor> cmccann: likely
13:35:06 <mel-> Mortchek: depending on rollDice it would return a putStrLn
13:35:10 <cmccann> roconnor: could I talk you into a way to split Colour into its channels but leave Chan abstract?
13:35:26 <monoidal> mel-: you can use fmap (const ()) to convert IO Int to IO (), or equivalently void function from Control.Monad
13:35:37 <cmccann> and to build a Colour from channel values obviously
13:35:51 <Mortchek> mel-, why is it a Maybe?
13:35:54 <roconnor> cmccann: probably not.  The key abstraction Colour provide is what basis is used to represent the colour vector.
13:36:19 <mel-> as in: http://hpaste.org/86199
13:36:49 <mel-> Mortchek: i cannot change that, as I want to use an API which is not under my control.
13:37:03 <Mortchek> mel-, it looks to me as if you want a "do nothing" action if you don't get a 1, so that'd just be return () :: IO ()
13:37:13 <cmccann> roconnor: ok
13:37:16 <monoidal> mel-: what you have here is hook :: IO (Maybe a)
13:37:40 <monoidal> mel-: It cannot be Maybe (IO a). That would mean that you can tell whether it's Nothing or Just without doing IO, but here the result depends on the randomness.
13:37:49 <xplat> roconnor: having an unboxed vector rep makes it much more useful at megapixel and gigapixel volumes though
13:37:58 <cmccann> roconnor: back to rolling my own color blending I guess
13:38:11 <Mortchek> mel-, a Maybe (IO ()) is either an action computing a (), or nothing at all.
13:38:20 <mel-> I am confused.
13:38:30 <mel-> the API I want to use is this: setEventHook :: Maybe (IO ()) -> IO ()
13:38:40 <mel-> so, this is Maybe (IO ()).
13:38:59 <roconnor> xplat: I understand :(
13:39:02 <Mortchek> mel-, what does setEventHook do?
13:39:11 <cmccann> roconnor: my first quick tests indicate that the overhead of boxing makes the library pretty much unusable for me
13:39:22 <mel-> it installs an event hook in the readline library.
13:39:38 <Botje> mel-: and presumably sending a Nothing in will clear the event hook?
13:39:56 <xplat> mel-: oh, then Nothing means 'remove the hook'
13:39:58 <mel-> I guess, sending Nothing means 'nothing to do'
13:40:02 <merijn> mel-: The API just wants you to wrap an IO () in Just
13:40:04 <mel-> i doubt that.
13:40:07 <cmccann> roconnor: and probably will for any use that involves storing per-pixel colors in any sort of quantity
13:40:09 <Mortchek> mel-, here's probably what you want: hook = Just $ do …
13:40:17 <Mortchek> mel-, and then don't bother with the Just and Nothing inside the body
13:40:22 <Mortchek> Instead of the Nothing try return ()
13:40:29 * hackagebot hlibgit2 0.18.0.3 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.3 (JohnWiegley)
13:40:31 * hackagebot base58address 0.2 - Parsing and serialization for Base58 addresses (Bitcoin and Ripple)  http://hackage.haskell.org/package/base58address-0.2 (StephenWeber)
13:40:53 <merijn> Mortchek: "setEventHook (Just myHook)" :)
13:40:54 <roconnor> cmccann: right;  Colour is probably more useful for libraries like Chart.
13:40:56 <merijn> eh
13:41:02 <Mortchek> That is an action that first rolls a die, then on a 1 prints your string, and on anything else does nothing.
13:41:02 <merijn> s/Mortcheck/mel-
13:41:25 <Mortchek> Yeah, merijn idea is probably clearer
13:41:28 <Mortchek> +'s
13:41:39 <Mortchek> myHook :: IO ()
13:41:53 <roconnor> maybe one day we can have efficency and abstraction
13:41:59 <mel-> merijn: THAT is a good solutation. it compiiles. thanks.
13:42:08 <ab9rf> salutations
13:42:16 <mel-> but I still don't understand how I would mix e.g. Maybe and IO.
13:42:16 <xplat> cmccann: do you have an example of something you're doing that's too slow?
13:42:25 <Mortchek> mel-, depends on what you mean by "mix"
13:42:44 <ab9rf> to make probabalistic IO muffins
13:42:47 <mel-> Mortchek: probably. It just feels highly nontrivial too me. :)
13:42:51 <xplat> mel-: there are lots of ways to mix them
13:42:51 <monochrom> "Maybe (IO ())" and "Just (putStrLn "hello")" are not mixing
13:43:17 <Mortchek> mel-, do you understand the difference between IO (Maybe a) and Maybe (IO a)?
13:43:58 <Xaratas> Couldn't match expected type `Int' with actual type `Integer' <-------- ahhh, can i change the ghci input to something non stupid?
13:44:00 <cmccann> xplat: pretty much what I just said, modifying a moderately large raster image stored as an array/vector/whatever
13:44:19 <mel-> Mortchek: I think/hope so. Monards are non-abelian. :P
13:44:30 <ab9rf> Xaratas: got paste?
13:44:33 <cmccann> xplat: I didn't do much benchmarking, just some quick tests, but you can probably imagine how well a boxed array of pixel colors worked
13:45:02 <Xaratas> ab9rf: just simple copy paste steps like this: concatMap (\possible -> buildSquareHelper'' magicSum dim (line+1) (invLine-1) possible nextPermutations' other) nextPossible
13:45:10 <mel-> can somebody explain to me in one sentence why my hpaste.org version did not compile while redefining "hook" to "IO ()" and using the Just when I install the hook does work? it's not really clear to me.
13:45:23 <Xaratas> ab9rf: the + in not for integer now 
13:45:24 <ab9rf> Xaratas: can you put the code that isn't unifying on hpaste.org?
13:45:37 <cmccann> xplat: I'm working on a painting application if that helps, so modifying the image is the bulk of the work being done
13:45:41 <Mortchek> mel-, were you still wrapping the result in Just?
13:45:52 <xplat> cmccann: yeah, well, i was hoping to see something more specific
13:46:01 <Mortchek> I mean, within hook
13:46:22 <xplat> because i don't know the lib that well yet
13:46:26 <mel-> Mortchek: I guess i should do a new hpaste.
13:46:31 <Mortchek> setEventHook expects a Maybe (IO ()), so if you pass it Just myHook, myHook's got to be an IO ()
13:46:35 <Mortchek> Yeah, good idea.
13:46:36 <mel-> Thanks for your help, by the way.
13:46:42 <Mortchek> No problem.
13:46:43 <ab9rf> integer constants are polymorphic, so that message is someting else
13:47:02 <cmccann> xplat: sorry, the app I'm working on is a pile of messy hacks at the moment and I gave up on trying to use Data.Colour pretty quickly
13:47:09 <merijn> mel-: You're not mixing Maybe and IO
13:47:27 <ab9rf> IO () is a fairly reasonable type for a hook
13:47:55 <merijn> mel-: "IO ()" is "an IO action that does something when executed, "Maybe (IO ())" is just "either an "IO ()" action or nothing"
13:48:12 <xplat> cmccann: ah, i see, i was hoping to see if seeing the actual code would give me an idea for how to get unboxing to happen without losing abstraction
13:48:12 <monochrom> it is not like "Maybe Int" mixes Maybe and Int. well, unless you say it is.
13:48:36 <Mortchek> And an IO (Maybe a) is an IO action that computes either an a or nothing at all
13:48:40 <Mortchek> Just for comparison
13:48:50 <xplat> cmccann: i also thought it might help me, actually, since i'm working on an image viewer
13:49:30 <xplat> cmccann: (my current favourite is based on gtk+1.2 and imlib1, you can imagine how fun it is to build that in this day and age)
13:49:38 <Xaratas> ab9rf: hm, i got a feeling that my own function make it an int type
13:49:39 <ab9rf> ha
13:49:57 <ab9rf> Xaratas: you probably have one that is Int and another that is Integer
13:50:19 <xplat> and all other image viewers i've seen make me want to poke my eyes out just so i won't need an image viewer again ☺
13:50:27 <Xaratas> one that is Int and all other a which gets Integer
13:50:31 <ab9rf> Xaratas: haskell's arithmetic functions (most of them at least) are defined on Num a, but you have t have the same on both sides
13:50:40 <cmccann> xplat: I'm using openGL for display so I dunno if that would help you at all :P
13:50:47 <ab9rf> so Int + Int is ok, and Integer + Integer, but not Int + Integer
13:51:10 <cmccann> xplat: is your code uploaded anywhere?
13:51:12 <mel-> okay, here is my new hpaste: http://hpaste.org/86200
13:51:15 <adimit> ab9rf: yes, because Int ~ Integer does not hold (~ is something like type-level equality)
13:51:39 <__xc> > (1 :: Int) + (1 :: Integer)
13:51:39 <ab9rf> xplat: i hate UI code of all sorts
13:51:40 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:51:41 <lambdabot>              with actual type ...
13:51:44 <mel-> merijn: that is clear to me. maybe 'mixing' is the wrong word.
13:51:44 <merijn> mel-: Oh, that's simple to explain
13:51:58 <merijn> mel-: Let me desugar this code for you
13:51:59 <ab9rf> xplat: i worked on gtk 1.0 so i understand your pain
13:52:26 <xplat> cmccann: not yet, i'm porting from C top-down and spent the last couple of days shaving the yak of using lens to access C globals so i can see what i've got while i work
13:52:37 <adimit> > fromIntegral (9::Int) + (4::Integer)
13:52:37 * cmccann considers just using a mutilated local version of Data.Colour for now in order to procrastinate on implementing stuff properly until closer to something ready for public consumption
13:52:38 <lambdabot>   13
13:52:47 <mel-> merijn: i am very thankful. :)
13:52:50 <merijn> @undo do { dice <- rollDice; if dice == 1 then Just $ putStrLn "Got a one!" else Nothing }
13:52:50 <lambdabot> rollDice >>= \ dice -> if dice == 1 then Just $ putStrLn "Got a one!" else Nothing
13:53:04 <cmccann> xplat: that sounds like a remarkably hirsute yak indeed
13:53:14 <monoidal> mel-: Do you see that [Just 5, Nothing] has type [Maybe Int] and Just [5,4] has type Maybe [Int]? They're clearly different and not interchangeable
13:53:20 <merijn> :t (>>=) `asAppliedTo` (undefined :: IO Int)
13:53:22 <lambdabot> IO Int -> (Int -> IO b) -> IO b
13:53:29 <ab9rf> as an aside, i should make yaks shearable in dwarf fortress
13:53:45 <merijn> mel-: If you look at that type and then at what your if/else/then returns, what do you see?
13:53:46 <mel-> monoidal: yes
13:54:21 <xplat> cmccann: heh, for me that's nothing.  i actually have two prototypes that work in two days, i just need to see if either can get into lens proper, and maybe clean up a couple of things in one
13:54:47 <monoidal> mel-: You might have had a similar confusion, but instead of lists there is IO. so IO (Maybe a) and Maybe (IO a) are different: one is an action that returns a maybe, the other is maybe of an action
13:54:56 <merijn> mel-: Your "if/then/else" return a Maybe value, but you're in a monadic do-block for IO (because rollDice is in IO)
13:55:08 <hpaste> paullik pasted “Parens vs no parens in function type declaration” at http://hpaste.org/86201
13:55:12 <paullik> Hi. What's the difference between those two forms (with/without parens), lyah.com uses parens but I saw that I actually can write a function type declaration without them, which way is a better practice and why?
13:55:15 <xplat> not a huge deal at all compared to the piles and piles of C i need to make sense of
13:55:34 <monochrom> paullik: the parentheses there are optional
13:55:39 <cmccann> xplat: you sure reimplementing from the ground up wouldn't be a better plan? :P
13:55:42 <Mortchek> paullik, you need parens if there are more than one, so many people write the parens regardless.
13:55:50 <monoidal> paullik: there is no difference. But if you need several constraints, like (Num a, Num b) => a -> b, they are required
13:55:55 <merijn> mel-: Having the separate hook has everything in IO (i.e. you have rollDice that is IO and putStrln that is also IO), then you take this entire "IO ()" value and wrap it in Just to make it "Maybe (IO ())"
13:55:57 <ab9rf> paullik: if you have more than one constraint then you need parens
13:56:08 <xplat> cmccann: well, i don't want to lose the ineffable quality that makes this viewer tolerable
13:56:16 <Mortchek> Yay question dogpile
13:56:24 <mel-> bah, why doesn't Ctrl-S freeze my terminal so that I can finally read that haskell desguaring code without my chat scrolling all the time!!
13:56:25 <ab9rf> hm, is an empty constraint list in parenthesis permissible?
13:56:31 <mel-> i cannot work like this!
13:56:34 <mel-> ;-)
13:56:39 <ab9rf> mel-: backscroll FTW
13:56:43 <paullik> wow, thanks for the prompt response guys, it's all clear now
13:56:45 <merijn> mel-: You can PM lambdabot too
13:56:56 <monoidal> mel-: Ctrl-Q should unfreeze
13:57:11 <monoidal> mel-: ah, sorry, misread
13:57:17 <mel-> aaaah, hack: change terminal dimensions and then scroll backwards ;-)
13:57:32 <monoidal> ab9rf: yes
13:57:34 * monochrom frowns. don't you have PgUp? or is it really a terminal and you're using netcat for irc?
13:57:40 <mel-> that's probably a mosh-problem (by the way, mosh is super cool).
13:57:51 <cmccann> xplat: anyway, I doubt anything I'm working on would be all that helpful for you
13:58:03 <ab9rf> monoidal: cool
13:58:12 <Mortchek> mel-, irssi?
13:58:23 <monoidal> ab9rf: but AFAIR there's trouble with defining type T = () :: Constraint
13:58:23 <cmccann> static images are pretty far from anything my application really cares about
13:58:42 <monoidal> ab9rf: because () means unit tuple and somehow I can't get it to mean empty constraint
13:58:51 <ab9rf> monoidal: heh
13:58:57 * monochrom shakes head. a broken program and you call it super cool.
13:59:06 <xplat> cmccann: well, i'm going to have to basically reimplement the image loader backend and the display widget, and it of course does dynamic scaling and (one of the things i love) dynamic gamma adjustment
13:59:46 <Mortchek> Never mind, didn't realize mosh was a program
13:59:47 <xplat> monochrom: mosh is pretty cool in principle.  (but yeah, it's also pretty broken.  i gave up on it within days.)
13:59:50 <cmccann> xplat: unless you want to be tied to OpenGL none of my display stuff is likely to help
14:00:02 <cmccann> xplat: and I'm probably just going to load with JuicyPixels or whatever
14:00:12 <mel-> Mortchek: yes
14:00:23 <Mortchek> Oh, but it's not your IRC program. So you are using irssi for IRC?
14:00:27 <mel-> okay, that was very helpful
14:00:32 <Mortchek> mel-, /scrollback goto -X, X is however many lines you want to go back
14:00:33 <merijn> mel-: Well, even without the @undo, let me ask you "what is the type of the if/then/else expression in your broken code?"
14:00:43 <xplat> cmccann: tied to opengl is way better than being tied to imlib1, and probably a better way to accelerate things than the custom mmx hacks it's currently doing
14:01:06 <mel-> Mortchek: eh, sorry, i recentely replaces irssi with weechat!
14:01:09 <mel-> i forgot.
14:01:11 <Mortchek> Ah, I see
14:01:21 <xplat> weechat is pretty broken too
14:01:37 <xplat> and it should be, with how it's coded >:(
14:02:01 <adimit> it's pretty funny. IRC is so bloody old, and yet there's no decent client…
14:02:06 <Nafai> xplat: how is weechat broken?
14:02:12 <cmccann> xplat: what OSs are you targeting and is OpenGL 2.1 acceptable?
14:02:38 <xplat> Nafai: well, i always had problems with redraw on my input line, and some of the scripts are pretty wonky
14:02:43 <monochrom> xchat is pretty decent. my sane definition of decent anyway.
14:03:00 <monochrom> I'm sure you all use the insane definition "it must be in a terminal emulator"
14:03:08 <cmccann> xchat is bad only in boring, mundane ways
14:03:11 <xplat> Nafai: oh, and it doesn't print URLs sanely
14:03:24 <cmccann> which is really all you can hope for with software
14:03:27 <adimit> monochrom: my IRC client has to live on a remote atom server. So, yes.
14:03:39 <monochrom> "and PgUp must not work, it must be an obscure ctrl key combo"
14:03:55 <xplat> monochrom: i only care that it must be in screen.  as long as that means being in a terminal emulator, though ...
14:04:00 <adimit> pgup works fine in weechat with tmux.
14:04:02 <mauke> in what irc client does PgUp not work?
14:04:13 <mel-> merijn: does the fact that I'm in a 'monadic IO block' mean that I somehow return 'IO Maybe'?
14:04:17 <Mortchek> There are also IRC programs that stay resident on a server but that you can attach a frontend to
14:04:43 <monochrom> I use a bouncer on a remote server.
14:04:47 <adimit> bouncers I believe they were called.
14:04:59 <xplat> cmccann: targeting debian and ubuntu linux, maybe other linux variants.  no windows, macos, probably no android.
14:05:14 <mauke> how do bouncers keep history?
14:05:16 <Mortchek> smuxi is an example of what I mean
14:05:27 <aristid> mauke: by just storing it?
14:05:37 <mauke> aristid: how do I access it?
14:05:49 <aristid> mauke: probably by sshing into the server
14:05:53 <mel-> When I use >>=, i guess is it the left-hand-value of >>= that determines what monad's implementation of bind is to be used, correct?
14:05:54 <aristid> mauke: i don't use a bouncer.
14:06:04 <aristid> i use weechat in screen.
14:06:05 <xplat> cmccann: opengl 2.1 is probably fine
14:06:11 <mauke> it's terminal emulators all the way down
14:06:17 <Mortchek> mel-, it's the whole thing, since both sides must agree in type
14:06:20 <merijn> mel-: Yes, since when you start with rollDice the last expression in the do block (and actually all those in between) have to be of type "IO something"
14:06:22 <aristid> mauke: it truly is.
14:06:35 <merijn> mel-: But your if/then/else is of type "Maybe  (IO ())"
14:06:48 <Mortchek> There are no definitions for ill-typed references to (>>=)
14:06:48 <xplat> mel-: they have to match, so it's either side's
14:07:18 <cmccann> xplat: ok, you might be able to get some use out of my stuff then
14:07:21 <mel-> good. ah, that was kinda hard.
14:07:23 <aristid> iTerm2 (terminal emulator) -> mosh (terminal emulator) -> screen (terminal emulator) -> weechat (NOT a terminal emulator)
14:07:24 <mel-> :)
14:07:25 <merijn> mel-: This is also not what the setEventHook function expects. The setEventHook function wants Maybe (IO ()) which means "Just myHook" (to set a hook) or "Nothing" (to unset a hook)
14:07:51 <xplat> aristid: knowing weechat, it probably is a terminal emulator with the right extension
14:07:56 <merijn> mel-: The clean version has an entire "IO ()" hook, which you then wrap with Just and give to setEventHook to set it
14:08:01 <mel-> merijn: check!
14:08:38 <parcs> > fmap fix return 3
14:08:39 <lambdabot>   3
14:08:54 <aristid> xplat: i don't think i have that extension installed :)
14:09:13 <cmccann> xplat: I can probably give you displaying an image inside a GL context in a GTK control with some limited scrolling and zooming support in the near-ish future
14:09:16 <aristid> xplat: i probably should though! THOU SHALT NOT BREAK THE CHAIN OF TERMINAL EMULATORS, it is written i believe
14:10:26 <Mortchek> aristid, it helps that you can arbitrarily nest screen
14:10:29 * hackagebot hlibgit2 0.18.0.4 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.4 (JohnWiegley)
14:10:47 <Mortchek> I used to run with a local screen containing a remote screen until I realized that was slightly insane
14:10:57 <Mortchek> +irssi
14:11:01 <aristid> Mortchek: can become a little cumbersome to operate the inner screens that way ;)
14:11:07 <xplat> cmccann: that would be handy, thanks.  and i might give you back some hacks to use Data.Colour without losing all your speed
14:11:08 <Mortchek> Indeed.
14:11:24 <aristid> Mortchek: well you could give them different escapes
14:12:11 <cmccann> xplat: I'll probably end up rolling my own color stuff anyway, even with unboxing I wouldn't be able to use Data.Colour everywhere
14:12:52 <xplat> cmccann: ah
14:13:40 <Mortchek> aristid, I actually didn't know that
14:14:10 <Mortchek> but I have run into close calls where I was using irssi but at the same time I wanted to screen share with someone, so I made a new screen, and I enabled multiuser, but it turned out I accidentally did that to the irssi screen
14:15:07 <Mortchek> (of course, screen sharing is a terrible idea with someone you don't trust anyway, since it gives them access to your login)
14:15:10 <geekosaur> there's always using tmux for one and screen for the other...
14:16:09 <dmj> I'm using hakyll+pandoc to compile .lhs to html, but I still want the user to be able to download the .lhs file. Anyone know how to copy a directory into _site w/o compilation?
14:16:22 <dmj> in hakyll
14:16:44 <supki> cp ?
14:17:52 <lispy> dmj: I would recommend asking #hakyll it seems to be a pretty active channel
14:18:34 <lispy> dmj: as to the answer, I remember there being a straightforward 'compiler' for moving files but I don't recall the name of it.
14:18:38 <hpaste> dmj pasted “hakyll cpy” at http://hpaste.org/86202
14:18:46 <parcs> is overflow of a Word or Int undefined?
14:19:05 <dmj> lispy: thanks
14:19:06 <supki> also there is copyFileCompiler
14:19:07 <lispy> > suc (maxBound :: Word)
14:19:08 <lambdabot>   Not in scope: `suc'
14:19:08 <lambdabot>  Perhaps you meant one of these:
14:19:08 <lambdabot>    `sum' (imported fro...
14:19:12 <lispy> > succ (maxBound :: Word)
14:19:14 <lambdabot>   *Exception: Enum.succ{Word}: tried to take `succ' of maxBound
14:19:28 <lispy> > 1 + (maxBound :: Word)
14:19:29 <lambdabot>   0
14:19:55 <lispy> parcs: Hm...I'm not sure but it seems like some of the ways to get the overflow are undefined
14:20:06 <parcs> > 100 `shiftR` 100 :: Int
14:20:08 <lambdabot>   0
14:20:30 <parcs> lispy: yeah.. and the haskell report doesn't seem to specify what happens during overflow
14:20:51 <parcs> oh wait
14:20:53 <parcs> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (⊥, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
14:20:54 <xplat> demons fly out of your nose, obviously
14:21:11 <xplat> well, i guess that would be an effect
14:21:33 <lispy> I wonder why they chose to make that undefined
14:21:59 <Mortchek> You can actually exploit the demons flying out of your nose effect to write unsafePerformIO
14:22:01 <xplat> maybe the same reason C did
14:22:23 <xplat> at least in Haskell you can fall back to Integer if you want more sanity and less performance
14:22:25 <parcs> lispy: optimization!
14:22:51 <geekosaur> because, while it's theoretically possible for a CPU to provide decent hardware support for anything other than truncation, all current ones truncate and if you want anything else you must perform at least one additional operation
14:22:53 <Mortchek> (in a manner that works only in the implementation that does that, of course)
14:23:19 <parcs> since in C overflow of signed ints is undefined, 100*a/2 === 50*a. you can't perform that substition if a is an unsigned int though
14:23:36 <geekosaur> also so the implementation can choose to detect over/underflow when not optimizing, without violating the spec?
14:23:48 <xplat> Mortchek: does this involve drawing a pentagram around your nose?
14:24:40 <mvb> > (Just 9) + (Just 8)
14:24:42 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
14:24:42 <lambdabot>    arising from a use o...
14:24:58 <xplat> parcs: it's too bad it causes naive attempts to detect overflow to fail though
14:25:30 <mauke> > (+) <$> Just 9 <*> Just 8
14:25:32 <lambdabot>   Just 17
14:25:50 <xplat> especially the part where they fail silently and erase the handlers during dead code elimination
14:25:59 <mvb> @type <$>
14:26:00 <lambdabot> parse error on input `<$>'
14:26:04 <mvb> @type (<$>)
14:26:04 <parcs> xplat: heh yeah.. how would you get around that actually?
14:26:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:26:13 <mvb> @type (<*>)
14:26:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:26:28 <quchen> mvb: <$> is infix for fmap, <*> is from Applicative.
14:26:33 <mjo_>  mvb : Look at the Applicative section in the Typeclassopedia
14:26:40 <mietek> Does anyone know any LLVM packages for Haskell which aren't the FFI bindings?
14:26:44 <xplat> parcs: you have to detect the overflow by performing a computation that doesn't overflow but has a different result when your desired computation overflows
14:26:56 <mietek> bos mentioned some LLVM IR generating DSLs
14:27:08 <xplat> parcs: like for a + b, you can do a > MAXINT - b
14:27:16 <mietek> http://www.reddit.com/r/haskell/comments/1cq1w1/are_the_llvmcore_bindings_still_being_maintained/c9j8pty?context=2
14:27:31 <mvb> im not to keen on the &¤/#(¤/(# syntax in haskell
14:27:38 <mvb> how do you remember what theys tand for?
14:27:45 <parcs> xplat: ah, makes sense
14:28:01 <mauke> mvb: I'm not to keen on the words/nouns/verbs syntax in english. how do you remember what they stand for?
14:28:02 <geekosaur> mvb, a decent editor helps there...
14:28:12 <geekosaur> but as you use them more, yyou learn them
14:29:01 <monoidal> mvb: You might look at http://www.haskell.org/haskellwiki/Keywords
14:29:05 <quchen> mvb: Learn them one at a time. Each set of operators, rarely bigger than two at a time, corresponds to some unit of learning. For example, learning about Applicative will most likely introduce you to <$> and <*>; Monad has >>= and >>, etc.
14:29:10 <monoidal> mvb: that's for standard syntax
14:29:40 <xplat> lens will introduce you to a lot in big chunks, but they follow patterns
14:30:25 <quchen> xplat: But Lens isn't a standard lib.
14:30:34 <xplat> quchen: yet
14:31:08 <quchen> I doubt it will ever be.
14:31:14 <quchen> Platform maybe, or probably.
14:31:38 <xplat> quchen: i pretty much consider Platform standard, for all intents and purposes
14:31:40 <quchen> I just meant to say it's not part of the "operators you should know as a beginner" canon.
14:31:52 <monoidal> I am a lenophobe. The number of operators it defines frightens me
14:32:36 <xplat> monoidal: it really only defines about 5 operators and 5 metaoperators, the rest just come from the fact that haskell doesn't actually have metaoperators
14:34:04 <monochrom> I understand &&& more than I understand "dependency injection" and "RESTful"
14:34:36 <monochrom> symbols are clearer than natural language
14:34:41 <quchen> Same here. (Is there something to understand about &&& though in the first place?)
14:35:01 <h4199> What would have to change to allow metaoperators? dependent typing?
14:35:03 <mauke> "do this AND that"
14:35:31 <xplat> 'dependency injection' means 'using an xml-configured linker at runtime, only the rest of your toolchain doesn't know about it so you also have to write a bunch of boilerplate'
14:35:51 <xplat> h4199: nah, it would be purely at the syntax level
14:36:04 <h4199> hmm
14:36:06 <quchen> xplat: That made the word longer but still doesn't tell me anything ;-)
14:36:10 <monochrom> &&& is an Arrow operator
14:36:44 <xplat> quchen: which is the same thing dependency injection does to your code ;-)
14:37:12 <quchen> xplat: Neat! And RESTfulness is what you get when you imitate immutability in other languages, right?
14:37:49 <ab9rf> monochrom: RESTful means "i've read a paper on buzzword compliance"
14:38:20 <quchen> Haskell: put the mutable state of your webserver (probably a Bool or something) to a file on the disk. C++: Write 50 blog posts on how to gather all of your state
14:38:20 <monochrom> I just heard that it got someone a PhD
14:38:29 <xplat> RESTfulness is what you get when you use URLs as pointers, and then use a bunch of immutable data structures because pointers are now too expensive
14:38:32 <ab9rf> monochrom: it did
14:38:39 <mvb> @src Maybe (>>=)
14:38:39 <lambdabot> (Just x) >>= k      = k x
14:38:39 <lambdabot> Nothing  >>= _      = Nothing
14:38:45 <mvb> @src Maybe return
14:38:46 <lambdabot> return              = Just
14:38:52 <ab9rf> monochrom: we gave someone a PhD for saying "writing programs so that obvious things are obvious is a good idea"
14:39:13 <quchen> ab9rf: Sociology?
14:40:24 <mvb> how can Just and Nothign have doifferent return types in Maybe=
14:40:34 <mvb> i have to return the result of >>= with Just
14:41:02 <quchen> mvb: Justs and Nothings can both have the same type, similar to how 0 and 1 are different but share the same type.
14:41:23 <quchen> "Just <something>" and "Nothing" are both of type "Maybe <some type>"
14:41:54 <quchen> The type of return for Maybe for example is "a -> Maybe a".
14:42:05 <applicative_> for Just you mean
14:42:18 <applicative_> oh i see return
14:42:47 <monoidal> mvb: the types in the bind definition are: (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b; x :: a, k :: a -> Maybe b; Nothing on the LHS is Maybe a, on the RHS is Maybe b. You might make sure the math checks out.
14:42:49 <monochrom> this is why I don't use the word "return" unless I really mean the Monad method
14:43:09 <quchen> monochrom: But 'result' often sounds weird :-(
14:43:11 * applicative_ 's brain is exhausted from reading ML trolls proving ghc is lame
14:43:21 <xplat> i still wish 'return' was called 'pure' in the first place
14:43:26 <monochrom> I say "answer" and "co-domain"
14:43:39 <applicative_> omg stack overflow for the ackerman function!
14:43:44 <cmccann> dependency injection is simple to understand. if you think of applications and their dependencies by analogy to functions and types, DI frameworks are kinda like the quasi-CPS encoding of existential types
14:43:48 <xplat> applicative_: you mean people actually read xml trolls besides Robert Harper?
14:43:55 <xplat> er, ml trolls
14:44:11 <quchen> I've never heard of ML trolls.
14:44:17 <quchen> They don't seem to be very good at it.
14:44:36 <monoidal> applicative_: for the stack overflow thing, I think the main work would be bisecting to the commit that fixed it.
14:44:43 <applicative_> I assume this stackoverflow thing is ml trolling
14:44:52 <applicative_> monoidal: the commit doesn't really fix it.
14:45:01 <applicative_> i built head to see this
14:45:04 <applicative_> it isn't a bug
14:45:07 <applicative_> http://stackoverflow.com/questions/16115815/ackermann-very-inefficient-with-haskell-ghc/16125176?noredirect=1#comment23032687_16125176
14:46:00 <applicative_> this is a program where even a minute amount of compile time calculation helps
14:46:20 <applicative_> that's not quite the way to puit it
14:46:21 <monoidal> applicative_: HEAD gives 0.1% of memory on my machine, 7.6.2 gives oom. It's clearly a bug in ghc
14:46:36 <applicative_> monoidal: it still wipes out my macbook air
14:46:39 <monoidal> applicative_: I don't think HEAD unrolls things to make it somehow efficient
14:47:03 <monoidal> applicative_: ghc-7.7 -O2 does not work for you?
14:47:07 <applicative_> nope
14:47:10 <xplat> won't all those programs compute ack(4,1) completely wrong because it far overflows a machine word?
14:47:22 <eyebloom> What's the correct way to write this term so that it doesn't cause a parse error: http://hpaste.org/86204
14:47:22 <applicative_> xplat: yes, it's a troll we are dealing with
14:47:36 <hseg> BTW, what does asAppliedTo mean in: [23:53] <merijn> :t (>>=) `asAppliedTo` (undefined :: IO Int) ? I can't find it on Hoogle.
14:47:42 <applicative_> xplat: a serious person would have a program that accepts command line arguments
14:47:55 <applicative_> monoidal: try your big machine with ack 4 2
14:48:00 <quchen> hseg: It's basically a specialized const without implmenentation
14:48:05 <quchen> :t asAppliedTo
14:48:05 <cmccann> asAppliedTo is a lambdabot thing
14:48:07 <lambdabot> (t -> b) -> t -> t -> b
14:48:22 <applicative_> it is juest a question where things crash, this is the f*ing ackermann function we are talking about
14:48:27 <quchen> hseg: It's only used to specifying an argument's type, for example ...
14:48:28 <cmccann> it's useful for seeing how polymorphic types get specialized
14:48:39 <cmccann> like showing people in #haskell what the Arrow combinators mean without scaring them
14:48:41 <quchen> :t (>>=) `asAppliedTo` (undefined :: Maybe a)
14:48:43 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
14:48:49 <mvb> oh wait (Just x) >>= k      = k x // so k must be a fun a -> Maybe b
14:48:58 <quchen> mvb: Right :-)
14:49:06 <hseg> And I assume that lambdabot accepting [00:38] <mvb> @src Maybe (>>=) is just a lambdabot extension? i.e. it is illegal to say Foo f to refer to Foo's implementation of f. Then again, I don't think it's actually needed IRL.
14:49:22 <quchen> Yeah, that's also Lambdabot.
14:49:33 <applicative_> haha, i'm being 'downvoted' by clueless idiots
14:49:37 <mvb> so how do I define the functions >>= and return for a Monad?
14:49:41 <mvb> monad Perhaps x where
14:49:45 <mvb> doesnt work for me
14:50:04 <quchen> mvb: Have you read LYAH?
14:50:04 <ab9rf> applicative_: reddit or SO?
14:50:08 <hseg> @src asAppliedTo
14:50:08 <lambdabot> Source not found. My brain just exploded
14:50:10 <hpaste> mvb pasted “aaaa” at http://hpaste.org/86205
14:50:22 <monoidal> applicative_: ack 4 2, ghc-7.7 -O2, 100% cpu, 0.1% mem
14:50:26 <applicative_> SO
14:50:30 <monoidal> applicative_: and my laptop is far from powerful
14:51:11 <ab9rf> ack ack ack
14:51:26 <hpaste> Saizan revised “aaaa”: “correction” at http://hpaste.org/86205
14:51:33 <hpaste> Quchen annotated “aaaa” with “aaaa (annotation)” at http://hpaste.org/86205#a86207
14:51:56 <Saizan> mvb: you should read about typeclasses
14:52:00 <applicative_> how long did it take monoidal
14:52:27 <monoidal> applicative_: didn't wait for it to finish
14:52:44 <monoidal> applicative_: as far as I understand, the point is memory consumption
14:53:18 <quchen> hseg: 1. @src basically searches a static textfile (and hot Hackage or something). 2. asAppliedTo = undefined :: (a -> b) -> a -> (a -> b)
14:53:23 <monoidal> applicative_: 7.6 gives OOM within ~1-2 seconds
14:54:12 <quchen> s/undefined/const
14:54:16 <quchen> Woopsie.
14:54:18 <cmccann> applicative_: the bug here is not that GHC should be fast on a stupid microbenchmark, it's that it GHC shouldn't consume all available memory for no apparent reason
14:54:37 <applicative_> keep waiting
14:54:38 <mvb> what doies the state monad do?
14:54:40 <hseg> Nice. So basically, asAppliedTo coerces the first parameter of its first parameter to the type of its second parameter? Thus allowing one to check its type?
14:55:10 <hseg> Also, wasn't your original definition correct, i.e. asAppliedTo = undefined :: (a -> b) -> a -> (a -> b)
14:55:12 <hseg> >
14:55:13 <mauke> @unmtl State s a
14:55:13 <lambdabot> s -> (a, s)
14:55:14 <hseg> ?
14:55:25 <quchen> hseg: Oh, right. That one was also correct.
14:55:47 <quchen> hseg: asAppliedTo is really only used to check the type of something "if XY was inserted as its first parameter".
14:56:10 <quchen> :t (&&&) `asAppliedTo` (undefined :: a -> b)
14:56:11 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
14:56:17 <quchen> ... compared to
14:56:19 <quchen> :t (&&&)
14:56:21 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:56:31 <monoidal> applicative_: it still runs, and memory usage didn't budge
14:56:38 <hseg> Right. Which is basically what I do manually in GHCi. e.g. :t foo (undefined :: [Bar]) (undefined :: [Baz])
14:56:51 <applicative_> i dont get the original 'bug' with e.g. args 5 2, for the simple reason it never gets to the point where it kicks in
14:56:57 <cmccann> hseg: yes
14:57:04 <quchen> hseg: But then you'll have to define Bar and Baz first.
14:57:24 <cmccann> hseg: which is why lambdabot has it, but it's not in the standard libraries
14:57:25 <quchen> hseg: Implicit params make it unreadable, so: asAppliedTo. :-)
14:57:31 <cmccann> it's really only useful at a REPL
14:57:55 <hseg> Of course. That was implied. BTW, is there a way to make GHCi display the type of stuff respecting newtypes?
14:57:59 <quchen> cmccann: On a related note, do you know how to persistently load it in GHCi? Simply putting it in ghci.conf kills it on :r
14:58:20 <quchen> hseg: You mean "type"s, not newtypes there?
14:58:26 <hseg> i.e. :t "foo" gives me "foo" :: [Char], which causes things to become unreadable for large expressions
14:58:31 <hseg> right
14:59:09 <hseg> Couldn't we have come up with a more sensible keyword for that? e.g. typedef or alias?
14:59:22 <quchen> Not that I know of. I have the feeling that it roughly drags the "type name" along through functions though, so when you do something with String it'll give you back a String (and not a [Char])
15:00:04 <quchen> I think it would be hard to implement to look for the appropriate type definition.
15:00:11 <quchen> It's basically guesswork.
15:00:19 <quchen> And good guessing engines are hard ;-)
15:00:57 <cmccann> quchen: importing it should work
15:01:14 <cmccann> just make yourself a utility module, install the package, and import that in your .ghci
15:01:22 <monoidal> applicative_: anyway I terminated it, ran for 7 minutes and still memory use neglible
15:01:25 <xplat> well, coq's 'fold' tactic is pretty good at this sort of thing if you figure out what some of the aliases were yourself
15:01:30 <applicative_> maybe this is a linux bug, if by bug we mean what cmcann means; i cannot reproduce the original stack overflow with ghc-7.6 it just take 2 minutes
15:01:38 <xplat> (that is, outsourcing the guessing to a human)
15:01:39 <quchen> cmccann: config imports are lost on :r too I think
15:01:56 <quchen> cmccann: It's a similar issue that prevents all the colored GHCi prettyprint hacks from working
15:01:57 <applicative_> i have gotten it with various altered versions
15:02:06 <hseg> It *does* make it more inconvenient to use GHCi to test whether my intuition re: types of stuff is correct. Especially when working with stacks of monad transformers, which I specifically invented type aliases for.
15:02:32 <mvb> > fmap 3 $ ( (Just (+)) >>= return . 1)
15:02:34 <lambdabot>   Just 3
15:02:43 <applicative_> I consider the 'bug' to be that ghc takes 2 minutes where gcc takes 10 seconds.
15:02:46 <mvb> wtf
15:02:49 <mvb> doesnt work in ghci
15:02:52 <quchen> hseg: That may be true. But then on the other hand, I'd rather read [Char] than "Filename" instead of "String".
15:02:54 <mvb> and here it returns wrong answer
15:03:27 <mvb> and here it returns wrong answer'
15:03:35 <mvb> > fmap 3 $ ( (Just (+)) >>= return . 1)
15:03:37 <lambdabot>   Just 3
15:03:40 <mvb> @type fmap
15:03:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:03:47 <mvb> @type (id 3)
15:03:49 <lambdabot> Num a => a
15:03:54 <mvb> @type 3
15:03:55 <applicative_> but the fact that ghc takes 2 minutes for naive ack 4 1 where gcc take 10 sec. is due to familiar features of ghc , which vanish when we make a real program, e.g. that takes command line arguments
15:03:56 <lambdabot> Num a => a
15:04:01 <cmccann> quchen: you sure? it's always seemed to work for me
15:04:05 <xplat> mvb: that's the right answer, you just don't understand what it's doing because there's a confusing Num instance
15:04:05 <monoidal> applicative_: did stackoverflow guys say this? The discussion seems to mention only the program nonterminating due to OOM
15:04:14 <quchen> mvb: Maybe query Lambdabot in private if you don't want to show the commands to the entire channel.
15:04:14 <mvb> > fmap (\x -> 3) $ ( (Just (+)) >>= return . 1)
15:04:16 <lambdabot>   Just 3
15:04:24 <mvb> i want help
15:04:25 <xplat> @type 3 `asAppliedTo` (+ 1)
15:04:27 <lambdabot> (Num a, Num b) => (a -> a) -> b
15:04:40 <FireFly> mvb: the "fmap 3 $" part is because.. of lambdabot-isms
15:05:05 <applicative_> I dont see that that is the problem at all since it doesnt stack overflow on my machine; if it were, there would be no point telling us how well mlton and ocamlopt do
15:05:05 <FireFly> so ignore the fact that it worked in lambdabot but not ghci
15:05:16 <xplat> mvb: if there wasn't the instance Num b => Num (a -> b) you'd just get a type error
15:05:22 <mvb> so i cant fmap a value to a function?`
15:05:32 <mvb> obv sicne it is not a function
15:05:35 <mvb> or is it?
15:05:42 <mvb> wrong type of the func
15:05:42 <quchen> cmccann: It works when loading GHCi, yes. But after that, load some other module and it's gone.
15:05:43 <FireFly> in lambdabot numbers are functions P:
15:05:45 <FireFly> :P*
15:06:01 <hseg> :-s. Would you rather read StateT Integer (ReaderT [Char] Identity Char) [[Char]] than StateT (Reader String Char) [String], quchen?
15:06:18 <xplat> > fmap (flip id 3) $ ( (Just (+)) >>= return . 1)
15:06:20 <lambdabot>   Just 1
15:06:39 <quchen> hseg: Sure I would like to have the feature you mentioned, but I can't see how it could be realized easily
15:06:42 <cmccann> quchen: have you tried it? I'm almost certain it retains imported modules if they come from an installed package
15:06:46 <xplat> er, right, the 1 has the same problem :)
15:07:04 <xplat> > fmap (flip id 3) $ ( (Just (+)) <*> return 1)
15:07:06 <lambdabot>   Just 4
15:07:07 <applicative_> monoidal: the title of the SO post is 'ghc very inefficient'
15:07:09 <quchen> cmccann: Yes, just did (with Data.List in the config, then importing Monad manually). 7.4.2 here
15:07:42 <hseg> Right. One more thing for my list of stuff that would be nice if they existedm but are probably impossible/impractical.
15:08:11 <monoidal> applicative_: is this the only indication?
15:08:38 <monoidal> applicative_: The original version of the question contained "The Haskell version is the only one that fails to terminate properly because it takes too much memory. What can I do to improve it without heavily fuglifying the code?"
15:08:39 <applicative_> monoidal: no stack overflow on macbook air ghc-7.6 for the original program with 4 2 as args either
15:09:01 <applicative_> yeah, it's a mess his remarks
15:09:04 <quchen> hseg: I guess GHCi could favor type over "ordinary". That might not be so hard actually. (I'm not a dev though) - the only problem I still see is if there are multiple synonyms
15:09:23 <quchen> hseg: Although, for complicated types, the search may take a long time (?)
15:09:37 <quchen> You would basically have to match every subtree against all type defs
15:10:17 <monoidal> applicative_: you do have -O2, right?
15:10:23 <applicative_> monoidal: you don't recognize a dishonest ml troll when you see one; i live among them
15:10:30 <applicative_> monoidal: yes
15:10:31 <xplat> quchen: in general you would be doing trial higher-order matches against all your type synonyms.  that is definitely slow, although it was recently proved decidable i think
15:10:42 <applicative_> ghc --make -O2 ackermanbug.hs
15:10:55 <xplat> applicative_: you live in pittsburgh?  or is it france?
15:11:16 <applicative_> The Glorious Glasgow Haskell Compilation System, version 7.6.2
15:11:33 <monoidal> applicative_: and, just to make sure, you cleaned the *.hi and *.o files before?
15:11:39 <applicative_> maxBound :: Int 9223372036854775807
15:11:41 * geekosaur used to be CS zephyr's token haskeller...
15:11:46 <applicative_> yes hclean
15:12:00 <applicative_> is my program for eliminating
15:12:03 <applicative_> hi etc
15:12:30 <cmccann> applicative_: edwardk suggested putting haskell stickers all over things outside harper's office
15:12:43 <cmccann> but I'm inconveniently far away on another side of town :[
15:12:49 <applicative_> hz
15:12:50 <applicative_> ha
15:13:22 <xplat> cmccann: he technically might have offered you a bus pass
15:13:43 <cmccann> pf, it's only a few bucks for the bus fare
15:13:49 <cmccann> it's more the inconvenience
15:13:59 <quchen> What's a ML troll anyway
15:14:06 <quchen> And why are they posting page long things on SO
15:14:13 <quchen> Is there some rivalry I don't know about?
15:14:23 <xplat> cmccann: maybe you can design a robot to take the bus and sticker the hallway
15:14:26 <cmccann> quchen: not really
15:14:44 <applicative_> yeah, ml people hate haskell. I don't get it; I don't hate ML ocaml, f#; I would defend them against morons
15:14:54 <monochrom> applicative_: how much memory does the program use? I have only 3GB
15:14:54 <edwardk> cmccann: i'm willing to supply the stickers
15:14:54 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:14:55 <cmccann> just some sour grapes from a few people who preferred other languages in places that Haskell is somewhat dominant
15:15:15 <monoidal> applicative_: perhaps you might leave a comment on http://hackage.haskell.org/trac/ghc/ticket/7850 containing information about your system?
15:15:49 <quchen> cmccann: Glad to see Haskell's not on the bottom of the food chain of "things that the public doesn't care about" anymore then ;-)
15:16:16 <xplat> quchen: it's climbed just high enough for a few people to grab onto its legs
15:16:34 <cmccann> quchen: well these are basically all variations on the domain of "statically typed functional languages"
15:16:40 <quchen> Yeah I hear monads are becoming popular in other functional languages, such as JavaScript. (Not sure if joking)
15:16:40 <cmccann> there's not many contenders here
15:16:54 <typoclass> it seems a bit unnecessary. the guys with 0.03% market share attacking the guys with 0.05% ...
15:17:54 <xplat> typoclass: the main thing is they're really competing for the same narrow market segment
15:18:21 <applicative_> monochrom: it uses plenty of memory, ~2gigabytes, but then answers correctly in  1m43s
15:18:29 <monochrom> I see
15:18:32 <h4199> I have never noticed any hostility from anyone other than the ML fellow who infrequently blogs about "problems" in Haskell. I can't recall his name. Is the problem really that big?
15:18:34 <cmccann> quchen: it seems to mostly be some SML fans butthurt at Haskell being popular in academic circles and a handful of ocaml folks grumbling that Haskell gets more hype
15:18:48 <typoclass> h4199: something with frog i think
15:18:55 <typoclass> h4199: frog industries or some such
15:19:05 <applicative_> h4199: Harper aka Existential Type?
15:19:12 <monochrom> Jon Harrop?
15:19:22 <cmccann> F# is more like Scala, attracts too many Haskell fans who need to target a specific platform for there to be a lot of antagonism
15:19:26 <applicative_> ah Harrop my kind of troll
15:19:50 <monochrom> Jon Harrop would be the one of the Frog something company
15:20:03 <davorak> So when I build haddock packaes I almost always end up seeing: `No links will be generated to these packages: rts-1.0, ffi-` is is possible to generate links to them and if so how?
15:20:04 <h4199> yup he's the one
15:20:06 <xplat> harrop unlike harper is not really worth reading
15:20:10 <cmccann> I think most people who actually use ocaml for serious work don't give a crap about how popular it is vs. Haskell
15:20:13 <typoclass> xplat: i dunno ... they could just as well team up for the common goal of making functional programming more popular
15:20:37 <monochrom> I respect Harper. he just has a different opinion, and a tiny error.
15:20:39 <xplat> typoclass: yep and that happens too
15:21:15 <cmccann> monochrom: eh, too many of his comments about Haskell are phrased in such a way to be technically correct but misleading by connotation.
15:21:28 <cmccann> that's intellectual dishonesty and makes me suspicious of pretty much everything else he says.
15:21:34 <quchen> cmccann: Oh, it's on SO then
15:21:45 <monochrom> I guess so. but I overlook that
15:21:56 <applicative_> monochrom: yeah, it's true that head takes much less memory, and only 23 seconds, i.e. a joke compared to gcc
15:21:59 <monoidal> Jon Harrop's blog is beautiful. He has a post from Feb 2013 that laments that hashtables are slow in GHC 6.10 and 6.12
15:22:27 <applicative_> that recent?  I thought he'd been cured
15:22:28 <cmccann> there are few things I hold in lower regard than people willfully misleading with the truth.
15:22:29 <typoclass> is this the 'harper' guy i keep hearing about? http://existentialtype.wordpress.com/
15:22:36 <monochrom> yes
15:22:40 <monoidal> typoclass: yes
15:22:49 <typoclass> mono*: thanks
15:22:51 <applicative_> yeah, he's actually wonderful, just has issues about haskells 'sexiness'
15:22:58 <applicative_> how come my language is not so sexy, not fair
15:23:05 <monochrom> as opposed to Stephen Harper, Prime Minister of Canada!
15:23:39 <xplat> it's pretty hard to be sexy when 'standard' is the only spelled-out word in your name :)
15:23:42 <quchen> monochrom: That post can not be serious.
15:23:47 <applicative_> typoclass: I'd be happy to read a post like http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/ every morning
15:24:06 <monochrom> which post?
15:24:21 <applicative_> on Boolean Blindness
15:24:27 <quchen> Eh, meant monoidal, sorry. Harper's post about hash tables http://flyingfrogblog.blogspot.de/
15:24:45 <applicative_> quchen: harrop not harper!!!
15:24:45 <monochrom> sorry, I mean quchen: which post is not serious?
15:24:47 <cmccann> also harper frankly just seems kinda obnoxious to me, there was a post he made about not teaching OOP to students that seemed incredibly irritating and blatant trolling even though I pretty much agreed with it 100%
15:24:55 <quchen> I think he just stashed that post (it claims the 2010 platform was just released) and found it under the carpet
15:25:19 <Peaker> cmccann, "Kill the scourage of imperative programming, and the scourage of laziness", heh
15:25:28 <monochrom> ok, the hash table post.
15:25:33 <cmccann> meanwhile harrop is a joke, he exists only to promote himself and his alleged "company"
15:26:03 <cmccann> apparently harrop got banned from wikipedia because he kept spamming articles with links to his own site or something
15:26:14 <quchen> You guys are confusing! I thought Harrop was a loony. Who is this Harper guy
15:26:38 <monochrom> I am not confusing
15:26:38 <monoidal> quchen: Indeed, he's reposting something older - but to do this in 2013 when things have changed a lot? that's not sane
15:26:39 <Peaker> quchen, after http://flyingfrogblog.blogspot.de/ I did my own measurements, and Harrop retreated to much lower difference numbers.. I see he kept the lies on the blog though, which is typical of him
15:26:49 <geekosaur> Stephen Harper, CMU CS prof who hates Haskell
15:27:08 <monochrom> hahaha
15:27:10 <typoclass> applicative_: right. i read that once and found it unimpressive; he just rambles. i guess i'll give him another chance and have a look at the blog
15:27:17 <Peaker> quchen, also, I patched GHC and got the numbers up to better-than his F# ones, depending on the silliness of the example used/assumptions in the benchmark
15:27:26 <cmccann> quchen: harrop is a dumbass who can be ignored, harper is a well-respected CS researcher who occasionally writes really obnoxious blog posts
15:27:51 <Peaker> quchen, but he never did correct his blog
15:27:58 <applicative_> I guess I accept this that we can speak of a 'bug' HEAD at least keeps the memory down
15:28:15 <applicative_> pardon standard illteracy, monochrom monoidal
15:28:27 <quchen> cmccann: I'll try to remember that then
15:29:56 <Peaker> when augustusson wrote "More points for lazy evaluation", he mentioned 5 strong reasons and 1 weak reason that lazy evaluation is useful.   Harper replied with something like "I only care about reason 5, and we do lose that, but it's worth it"
15:30:03 <applicative_> ah the troll built the forked jhc and now gets 1.9 sec for the program, due to corrupt compiler optimizations
15:30:19 <Peaker> he didn't go through the trouble of explaining a response to each reason
15:30:32 <quchen> Seems like he has a PR problem
15:30:59 <applicative_> Peaker: it was really interesting, he just has very little experience with Haskell, despite no doubt perfect understanding of the system,  else he wouldn't say he didn't care about those things
15:31:24 <quchen> Peaker: Do you have the URL to augustusson's post?
15:31:34 <cmccann> applicative_: talking about harper there?
15:31:37 <applicative_> 'yes its true in the strict world, we stick to concrete types, and do mindlessly detailed recursive definitions, and so on and ''
15:31:40 <monoidal> quchen: http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
15:31:42 <applicative_> cmccann: yea
15:32:00 <cmccann> applicative_: maybe we should buy a copy of LYAH for him
15:32:03 <Peaker> applicative_, Yeah, when he discusses Haskell he tends to say things like "Every program in Haskell must be riddled with unsafePerformIO to get any work done at all", or "you need to use 60's Algol style to do imperative programming in Haskell"  which really suggest he has no clue what he's talking about
15:32:04 <quchen> monoidal: Thanks
15:32:48 <applicative_> Peaker: see, yeah that's amazing, the unsafePerformIO thing;  but again, his understanding of the haskell type system seems perfect
15:33:21 <monoidal> one of my favorite tweets: ‏@PLT_Borat: Robert Pike is dual of Robert Harper
15:33:33 <Peaker> applicative_, well, he does also claim that Monads can be easily represented in SML with module functors, and uses an example that doesn't actually represent the monad generalization, iirc. so I'm not sure it is perfect
15:33:41 <Peaker> monoidal, haha
15:33:48 <applicative_> complaints to do with type classes v. (his invention) a proper module system seem good ... until you realize how damn convenient type classes are despite everything
15:34:47 * geekosaur waiting for brain to unfog... but notes that it's pretty sad an antequarian sysadmin can do better on the haskell front
15:35:32 <geekosaur> robert harper. knew something was wrong there (and did something about it...)
15:36:19 <applicative_> oh got it hadn't occurred that geekosaur must have known him
15:36:29 <geekosaur> huh? I didn't
15:36:36 <applicative_> oh good
15:36:45 <geekosaur> ECE actually has fairly little interaction with SCS
15:36:52 <applicative_> i mean if he'd found out you knew haskell....
15:37:19 <Peaker> applicative_, http://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/  <-- he doesn't address how one would write monadic combinators, which would be a real pain, because they'd all have to be wrapped in signatures too and instantiated for each case. It doesn't actually seem to be a practical way of working with Monads, but he's just not thorough enough to discover it
15:37:33 <geekosaur> probably just pointed and laughed. ECE sysadmin? not someone a CS prof would take seriously
15:38:33 <cmccann> if anyone is really bored, here's the epic saga of jon harrop vs. an uptight srs biznis wikipedia user: http://en.wikipedia.org/wiki/User_talk:Requestion/Archive_1#Jdh30_Warnings
15:39:46 <quchen> cmccann: How do I follow that conversation? It only shows me Harrop's charming post.
15:40:06 <quchen> cmccann: Or is it the rat's tail that follows
15:40:08 <monoidal> cmccann: Wow.
15:40:10 <applicative_> Peaker: here's one in ocaml http://lambda.jimpryor.net/code/monads.ml
15:40:13 <h4199> Wikipedia can be a real rabbit hole
15:40:23 <cmccann> quchen: keep reading, follow some of the links
15:40:35 <monoidal> quchen: Read after "Charming. (Requestion 08:31, 9 April 2007 (UTC))"
15:40:37 <cmccann> I stumbled on this while checking the talk page of one of the articles involved
15:41:28 <quchen> cmccann: Ooooh, he namedropped his site in random articles
15:41:32 <cmccann> yep
15:41:34 <cmccann> repeatedly
15:41:41 <cmccann> after being told to stop multiple times
15:41:42 <quchen> cmccann: And since that counts as an edit, a world of shit came upon him
15:41:50 <quchen> In addition, his edits were bad
15:43:07 <applicative_> Peaker: i don't konw how usable it is. there are some examples of State in http://lambda.jimpryor.net/state_monad_tutorial/
15:43:15 <cmccann> http://en.wikipedia.org/wiki/Wikipedia_talk:WikiProject_Spam/2007_Archive_May#ffconsultancy.com has most of the same content as part of the pointlessly bureaucratic wikipedia process that I think ended up with harrop banned
15:43:39 <h4199> Did they ban his IP range? That is usually the final measure before semi protecting articles or arbitration
15:43:48 <applicative_> dylukes that's his name, he's in the 'burgh too cmcann
15:44:03 <Peaker> applicative_, well, essentially it boils down to passing all the type-class dictionaries manually via module parameters
15:44:03 <davorak> So when I build haddock packaes I almost always end up seeing: `No links will be generated to these packages: rts-1.0, ffi-` is is possible to generate links to them and if so how?
15:44:34 <typoclass> davorak: i think i've seen exactly that message eleventy million times :-)
15:44:36 <applicative_> Peaker: yes, but I guess that's what we expected.
15:44:37 <Peaker> applicative_, which means every polymorphic function must be declared in a new signature so it can be parameterized over the monads it is polymorphic too
15:44:56 <monochrom> davorak: it is impossible and unnecessary. ignore.
15:45:09 <Peaker> applicative_, I guess it might also rule out lots of useful higher-rank polymorphism
15:45:25 <Peaker> applicative_, I'm not sure how higher-rank would mesh with module instantiations
15:45:38 <cmccann> do most MLs even have higher-rank polymorphism?
15:45:45 <hseg> monochrom: isn't there a way to have those links link to the hackage version of those packages?
15:46:04 <geekosaur> there is one?
15:46:29 <jmcarthur> cmccann: ocaml does, but you have to wrap the function in a record, object, or first class module
15:46:32 <monochrom> there is no rts on hackage
15:46:37 <Peaker> cmccann, I don't know -- but if the module-based encoding of monads is incapable of expressing higher-rank types with monad constraints, it is an important difference
15:46:45 <geekosaur> they're compiler intrinsics
15:47:20 <cmccann> I know F# doesn't but neither does C# so that could be a .NET limitation
15:47:24 <jmcarthur> Peaker: at least in ocaml, the module system is powerful enough but other aspect of the type system make it impossible (no higher kinded types)
15:47:46 <typoclass> looking at it again, i don't know why the boolean blindness article is quoted regularly. there's only one example, it's very far down, and i don't think it's well chosen. he manages to spend 1300 words on saying essentially "sometimes Maybe is a better choice than Bool, and don't use Bools if you don't need to"
15:47:51 <hseg> Oh. But for other packages, it is possible?
15:48:04 <monochrom> then I don't know
15:48:28 <jmcarthur> Peaker: oh, by higher rank did you mean higher kind?
15:48:33 <Peaker> jmcarthur, wow, no higher-kinded types seems like quite a weakness
15:48:42 <typoclass> ... *and* he's pretty pompous about it. there's no point whatsoever to using the word 'iatrogenic', except demonstrating that somebody gave him a dictionary as a birthday present
15:49:00 <Peaker> jmcarthur, no no, I meant higher-rank, because that's where dictionary passing might go in interesting positions, where I'm not sure ML module instantiations can pass params
15:49:09 <jmcarthur> Peaker: to be clear, you can define and use type constructors. you just can't make them polymorphic without using functors, which are not *quite* enough to get true higher kinded types
15:49:13 <monochrom> typoclass: perhaps I should write my take on that subject! I have more points to make in fewer words and more concrete examples.
15:49:15 <quchen> typoclass: What boolean blindness post?
15:49:29 <typoclass> monochrom++
15:49:30 <quchen> monochrom: Go for it! :-)
15:49:47 <cmccann> monochrom: yes you should, absolutely.
15:49:55 <jmcarthur> Peaker: ah, yeah, you can define honest to goodness higher rank types (with runtime cost...)
15:50:13 <cmccann> monochrom: I would rather disagree with something you wrote than agree with something harper wrote.
15:50:13 <jmcarthur> (the runtime costs are no weirder than our arbitrary costs for existential types)
15:50:26 <davorak> monochrom: Yeah I thought as much thanks for the reply.
15:50:30 <monochrom> it is also a subject newbies want and need to hear about. they write "if xs is empty then ... else head, tail" because other languages taught them to.
15:50:49 <cmccann> monochrom: yes, I see that a lot on StackOverflow
15:51:21 <typoclass> quchen: don't waste your time with it, instead look at this much more clear description. it's what dan licata said on boolean blindness http://tinyurl.com/cyundam
15:51:22 <Peaker> typoclass, I do like that post, but maybe it's not written that well -- but I think it did clarify things in my head about booleans.. I think only then I finally realized that the good old "if/else" branching as a dominant form is such a bad idea.. that virtually all use of booleans is some invariant not being modeled in the type system, and that tracking the meaning of booleans is hard enough to warrant custom isomorphic types, which I tend
15:51:22 <Peaker>  to do since
15:51:50 <h4199> quchen: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
15:51:59 <quchen> typoclass: Fair enough, thanks
15:52:38 <Peaker> typoclass, when I do end up using booleans, I tend to have silly types like:   data DoesNeedParens = NeedParens | DontNeedParens
15:53:08 <typoclass> Peaker: yes, but i don't think that's even related to Bools fundamentally. you can also make the case that an Int doesn't know what it is about, whether it represents meters or seconds or cats
15:53:08 <Peaker> typoclass, which makes caller code more readable, slightly safer (cannot mix two unrelated bools) and makes meaning invertion bugs less likely
15:53:29 <haasn> in configuration-like stuff like that I'd go for something like data Flag = NeedsParens | ... -- and [Flag]
15:53:53 <Peaker> typoclass, right about that part. But the fact that "if/then/else" is not a great construct is an important insight that flies in the face of virtually all mainstream (and non-mainstream?) PL design
15:54:16 <Peaker> typoclass, I don't think I've understood/internalized that point quite as clearly until the boolean blindness article
15:55:14 <Peaker> it also touches on the booleans-vs-propositions idea, which I find interesting
15:55:16 <tromp_> Peaker: isn't it easier to have newtype DoesNeedParens = DoesNeedParens Boolean in that case?
15:55:29 <typoclass> Peaker: true. but i think it may be sufficient to say "if you can, scrap 'if isDefined x then fetchDefinition ...' and instead write 'case fetchDefinition of Just ...'"
15:55:34 <Peaker> the last paragraph about nulls is clear to Haskellers, but makes a good point too
15:55:50 <Peaker> tromp_, maybe, I don't know :)
15:56:05 <typoclass> Peaker: i don't know what a null is. is it like Nothing?
15:56:06 <typoclass> ;-)
15:56:26 <Peaker> tromp_, perhaps it might encourage a use like:   DoesNeedParens (complex expression here)   whereas I'd rather not go through booleans at all here for clarity
15:57:35 <monochrom> "newtype X = X Boolean" may end up syntactically more costly than "data X = No | Yes" in the long run.
15:57:55 <monochrom> i.e., a million occurences of "X False" vs "No"
15:58:13 <Rarrikins> Just say No
15:58:26 <monochrom> that is 2 million tokens vs 1 million tokens
15:58:27 <Peaker> Just say WantSex False
15:59:02 <monochrom> however, if you decide that it is unimportant, I don't mind either way
16:00:36 <djahandarie> I'm walking in at the last second, but things like map X do not get optimized out
16:00:55 <monochrom> ah, that one too
16:01:21 <monoidal> djahandarie: when X is a newtype? that's arguably a missing feature
16:01:22 <djahandarie> It tends to be the biggest issue, and also the main reason you see unsafeCoerce in code
16:01:48 <monoidal> hopefully that will be in 7.8 or 7.10
16:02:06 <parcs> iirc there's a ticket for that issue. anyone know the link?
16:02:08 <tmiw> hi
16:02:09 <Peaker> djahandarie, why not? If X is a newtype?
16:02:14 <monoidal> parcs: newtype wrappers
16:02:26 * BMeph_ finds that SICP quote immensely self-ironic
16:02:28 <Peaker> map NewType -> map id -> id -> nothing?
16:02:34 <monoidal> parcs: http://hackage.haskell.org/trac/ghc/wiki/NewtypeWrappers
16:02:50 <parcs> ah, thanks
16:03:18 <monoidal> Peaker: essentially once GHC knows types "X" and "Y" are equivalent, you can write "newtype wrapper f :: [Maybe (X,Int)] -> [Maybe (Y,Int)]" to get a O(1)-coercion
16:03:32 <monoidal> Peaker: so it avoids the map id -> id step
16:03:55 <Peaker> why can't ordinary RULE (map id -> id) fire?
16:04:18 <monoidal> Peaker: It can.
16:05:33 <monoidal> Peaker: but consider e.g. Int -> T vs Int -> R where R is a newtype of T
16:05:36 <leggo> how would I do this with a do syntax?
16:05:40 <leggo> > [1,2,3] >>= \x -> [x,-x]
16:05:42 <lambdabot>   [1,-1,2,-2,3,-3]
16:05:55 <monoidal> Peaker: converting that manually changes semantics when _|_ is present (just like eta conversion)
16:06:01 <monochrom> do { x <- [1,2,3]; [x, -x] }
16:06:28 <monochrom> @undo do { x <- [1,2,3]; [x, -x] }
16:06:29 <lambdabot> [1, 2, 3] >>= \ x -> [x, - x]
16:06:33 <monochrom> :)
16:06:40 <leggo> oh ok, so it doesn't need to end with return
16:06:52 <leggo> just needs a proper type
16:06:57 <haasn> @do [1,2,3] >>= \x -> [x,-x]
16:06:57 <lambdabot> do { x <- [1, 2, 3]; [x, - x]}
16:07:30 <BMeph_> leggo: That's kind-of why "return" has that name - it's a pun for imperative programmers. ;)
16:08:29 <leggo> BMeph yes
16:08:51 <Rarrikins> @unpl \x -> [x, -x]
16:08:52 <lambdabot> \ x -> [x, - x]
16:08:55 * Rarrikins gasps
16:10:17 <hseg> @pl \x -> [x,-x]
16:10:17 <lambdabot> (line 1, column 10):
16:10:17 <lambdabot> unexpected "-"
16:10:17 <lambdabot> expecting expression
16:10:21 <hseg> @pl \x -> [x,- x]
16:10:21 <lambdabot> (line 1, column 10):
16:10:21 <lambdabot> unexpected "-"
16:10:21 <lambdabot> expecting expression
16:10:24 <hseg> @pl \x -> [x, - x]
16:10:24 <lambdabot> (line 1, column 11):
16:10:24 <lambdabot> unexpected "-"
16:10:26 <lambdabot> expecting expression
16:10:35 <Rarrikins> @pl \x -> [x, negate x]
16:10:36 <hseg> @pl \x -> [x, -x]
16:10:36 <lambdabot> (line 1, column 11):
16:10:36 <lambdabot> unexpected "-"
16:10:36 <lambdabot> expecting expression
16:10:36 <lambdabot> ap (:) (return . negate)
16:10:39 <monoidal> Rarrikins: for tuples, you can do id &&& negate
16:10:43 <quchen> Parentheses, guys.
16:10:55 <NemesisD> anyone familiar with io-streams? i'm trying to figure out how to turn a Builder into an outputstring, or maybe a lazy bytestring
16:10:57 <Rarrikins> @pl \x -> [x, (-x)]
16:10:58 <lambdabot> ap (:) (return . negate)
16:11:12 <Rarrikins> @. pl undo do { x <- [1,2,3]; [x, (-x)] }
16:11:13 <lambdabot> ap (:) (return . negate) =<< [1, 2, 3]
16:12:10 <Peaker> hseg, experimental lambdabot tests in privmsg, please?
16:12:16 <troydm> wat is that ap part lambdabot saying?
16:12:22 <hseg> OK, sorry.
16:12:28 <troydm> ap (:) <- that?
16:12:33 <Peaker> @src (->) ap
16:12:33 <lambdabot> Source not found. stty: unknown mode: doofus
16:12:37 <monoidal> troydm: ap is a function in Control.Monad
16:12:41 <Rarrikins> @src ap
16:12:41 <lambdabot> ap = liftM2 id
16:12:48 <troydm> oic
16:13:00 <troydm> it's just a liftM2 over id
16:13:07 <troydm> never used it
16:13:12 <typoclass> Rarrikins: i think there's no way to make "\x -> [x, negate x]" any clearer or shorter :-)
16:13:13 <hseg> troydm: IIRC, ap x y = id <$> x <*> y
16:13:14 <monoidal> troydm: it is the same thing as  (<*>) used in applicatives
16:13:30 <hseg> i.e. ap = <*>
16:13:34 <haasn> hseg: id <$> x = x -- it's a functor law
16:13:52 <hseg> Right. Noticed that 2sec after posting.
16:14:57 <structuralist> So… Happstack vs. Snap vs. Yesod. Opinions?
16:16:52 <h4199> depends on your needs, depends on your expectations
16:17:44 <structuralist> what are the qualitative differences?
16:18:09 <structuralist> (I'm looking for something simple, elegant, & fast. not necessarily comprehensive)
16:19:11 <merijn> structuralist: snap seems to be simplest/most barebones framework, happstack is a good default start, I think (and their acid-state stuff is really neat!)
16:19:56 <giogadi> howdy!
16:20:00 <BMeph_> So, "Happstack isn't fast, Snap isn't elegant, and Yesod isn't simple?" ;p
16:20:03 <merijn> structuralist: Yesod is attempting to be the end-all, be-all, supports everything framework. It gets some criticism for having too much magic and template haskell in there
16:20:07 <giogadi> I've got a question about netwire
16:20:18 <structuralist> ok so probably not yesod for me then
16:20:24 <structuralist> does snap have something like acid-state?
16:20:36 <merijn> structuralist: If you wan simple then probably not, no :p
16:20:46 <applicative> oh monoidal quit darn
16:20:48 <merijn> I found yesod to complicated
16:20:58 <Luke> snap is simple and in that way is elegant
16:21:05 <giogadi> I have a function which requires a delta time step and another input. I'd like to construct a wire which applies this function to an input.
16:21:07 <Luke> snap also has an acid-state snaplet
16:21:10 <h4199> yes, http://hackage.haskell.org/package/snaplet-acid-state
16:21:13 <merijn> I think happstack isn't a lot slower than happstack
16:21:16 <merijn> eh
16:21:17 <merijn> snap
16:21:23 <quchen> What's acid-state useful for? The package description doesn't say much
16:21:37 <quchen> (And the website is 500-ing me)
16:21:38 <hpaste> applicative pasted “ack segfaults in c !!” at http://hpaste.org/86212
16:21:45 <merijn> quchen: It allows you to have any serialisable haskell structure with ACID guarantees
16:21:56 <h4199> it happstack redoing its backend?
16:21:56 <Luke> snap has a new http server based on io-streams which looks pretty promising wrt latency and throughput
16:21:59 <merijn> quchen: So if you want ACID without the database, it's great
16:22:01 <quchen> I should look up ACID then.
16:22:07 <applicative> can anyone else get a segfault with gcc -O3 thatprogram.c ^^^
16:22:12 <h4199> isn't*
16:22:28 <merijn> quchen: It's a database term "Atomicity, Consistency, Independence (?) and Durability"
16:22:30 <applicative> which *just asks for ack 4 2* ...
16:22:38 <sipa> isolation, i think
16:22:44 <merijn> Oh, right isolation
16:23:08 <quchen> merijn: And how does that relate to Haskell?
16:23:20 <hpc> integrity?
16:23:30 <quchen> It seems to be a DB normalization that makes certain guarantees about the data.
16:23:56 <sipa> hpc: could be!
16:23:58 <geekosaur> are you suggesting nobody would want to do database-y stuff in haskell?
16:24:16 <merijn> quchen: It doesn't. Basically it means "actions don't interfere with each other, they are atomic (i.e. either they succeed or they don't), consistency means you don't have half updates and durability means once an action succeeds it remains succeeded even if the machine crashes and power fails"
16:24:19 <structuralist> h4199: seems they're redoing it with pipes
16:24:19 <Rarrikins> applicative: I got a segfault
16:24:22 <quchen> geekosaur: I'm saying that database-y stuff is part of the database, and not something I want to impose on Haskell types
16:24:29 <merijn> quchen: I meant that the acid terms are not specifically database only
16:24:43 <applicative> Rarrikins: nice, thanks.
16:25:04 * geekosaur expects the C program is running afoul of how C programs typically extend the stack segment; ackerman tends to do a number on stacks...
16:25:05 <structuralist> is happstack as actively developed as snap?
16:25:05 <merijn> quchen: Basically, it means you can persist your datastructures to disk with the guarantee that if your program crashes/power fails/whatever your data can still be recovered and resumed for the next program execution
16:25:21 <merijn> structuralist: happstack and snap both seem equally mature and active development wise
16:25:39 <merijn> structuralist: I think it's really a toss up, they seem about equally simple, fast, etc.
16:25:54 <merijn> structuralist: I'd pick whichever one seems easiest to learn from the docs for you
16:25:55 <quchen> merijn: So I can see acid-state as providing a wrapper around the global program state that I can backup and what not?
16:26:02 <merijn> quchen: Yes
16:26:05 <structuralist> ok I'm leaning towards happstack because I like pipes :P
16:26:31 <merijn> quchen: You open up an acid state, perform mutations/actions on that and each action will be automatically saved to disk
16:26:52 <merijn> quchen: When your program crashes/shutsdown/whatever that data remains on disk and can be read in again
16:27:03 <quchen> merijn: Oh, it'll even do the saving for you? So it's not just some generic module, but with very specific reliability features built-in
16:27:11 <quchen> merijn: It's basically intended to be used for crashes? :-D
16:27:12 <applicative> Rarrikins: the original C program but with ack 4 2 (as here) and no advice that   ack 1 n = n + 2 is fated to stack overflow, but it will take much longer than ghc ...
16:27:12 <merijn> quchen: Yes
16:27:23 <hpc> quchen: it's as usable a database as mysql
16:27:31 <merijn> quchen: It's meant to be used as "a database when you don't want an actualy database"
16:27:35 <hpc> (but it's not an sql database)
16:27:35 <structuralist> how's acid-state performancewise?
16:27:46 <quchen> merijn: I see. Sounds pretty good actually.
16:27:49 <merijn> quchen: i.e. you just want to store a Map or whatever instead of a real table
16:27:53 <merijn> quchen: It is really neat
16:28:16 <merijn> structuralist: It depends on your use case. It keeps all the data in memory, so not really suitable to *really* big data sets
16:28:21 <quchen> merijn: It has no Binary dependency though. Does it use a similar concept to store things though?
16:28:23 <hpc> structuralist: it's been described as fast, but i have no good frame of reference
16:28:59 <merijn> structuralist: It seems pretty fast for what it does, but if you plan on reimplementing a "real" database you might be better of using an actual database
16:29:21 <merijn> structuralist: If you just want to persist/store haskell datastructures, I don't think there's many faster/nicer methods
16:29:32 <structuralist> if I start out with acid-state for a prototype and want to later scale using a real database will that be painful?
16:29:34 <merijn> quchen: I don't really remember all the details tbh
16:29:54 <merijn> structuralist: Yes, in the sense that acid-state and database are usually used entirely differently
16:30:03 <structuralist> oh excellent
16:30:17 <structuralist> what's a typical use case for acid-state?
16:30:44 <merijn> structuralist: acid-state doesn't use stuff like tables, you use it for haskell data structures. Like I said, stuff like Map, whatever random (serialisable) data structure you like
16:31:01 <merijn> structuralist: You can make a table data structure and store that, but that seems counter productive :p
16:31:06 <merijn> Just use a real DB in that case
16:31:46 <merijn> structuralist: Well, if you have a game with a worldstate or an application config that needs to be saved, that could be nice examples
16:32:28 <merijn> Just open the old config/state and go from there, updating changes as you go, when you close the app, everything is on disk
16:33:13 <merijn> Anyhoo, I need to start slowly heading to bed...
16:33:25 <structuralist> alright, thanks merijn!
16:33:46 <structuralist> that was helpful and I'm now excited to use happstack
16:35:02 <quchen> I kind of wanna use acid-state for something now.
16:35:18 <structuralist> inspiring blog post: http://www.happstack.com/page/view-page-slug/15/happstack-fay-acid-state-shared-datatypes-are-awesome
16:39:33 <giogadi> I've got a quick question about netwire. anyone here familiar with it?
16:40:38 <johnw> if you ask the question, someone may answer
16:40:45 <johnw> but we rarely claim familiarity
16:40:50 <giogadi> haha, ok
16:41:16 <giogadi> well, I have a wire whose input is a string, and its output is an IO ()
16:41:37 <giogadi> I'd like to use the periodically wire to only print the input string every few seconds
16:42:26 <giogadi> to do this, does it matter which way I compose the printing and the periodically wires?
16:44:44 <johnw> it may take a while for an answer to appear
16:45:04 <giogadi> that's fine, thanks johnw
16:45:09 <johnw> good luck!
16:50:23 <merijn> I think you don't want an IO () output, I think you want to use IO as your wire's monad
16:51:05 <merijn> i.e. Wire e IO String ()
16:51:33 <merijn> I think you want to have periodically . myPrintWire
16:52:15 <merijn> For true expert advice you'll want mm_freak, but I forget which timezone he lives in...
16:55:01 <dmj> has anyone had any luck using wxHaskell on OSX 10.8+?
16:56:05 <ab9rf> dmj: i can't even get it to work on windows
16:56:14 * xplat finishes commenting out all of hxt
16:57:15 <dmj> ab9rf: Are any GUI packages working for haskell? (pref. osx)
16:57:35 <arkeet> gtk2hs?
16:58:02 <dmj> arkeet: is that what you use?
16:58:07 <Rotaerk_> hmm, is there any kind of mechanism available that's kind of like an algebraic data type, but where I can add the value constructors ad-hoc (from different modules).  I would then expect to be able to pattern match on only the constructors my current module is aware of (through its dependencies)
16:58:09 <arkeet> I don't use any gui stuff
16:58:50 <arkeet> Rotaerk_: and if someone passes you a value that your module isn't aware of?
16:59:01 <Rotaerk_> it would be handled by the _ case
16:59:02 <xplat> Rotaerk_: typeclasses sort of work like that, but probably data types a la carte are closer
16:59:05 <Rotaerk_> or "otherwise"
16:59:19 <Rotaerk_> err
16:59:32 <Rotaerk_> no not otherwise
16:59:37 <arkeet> hmm
16:59:39 <arkeet> idea
17:02:26 <Rotaerk_> xplat, what do you mean "data types a la carte"?
17:02:33 <xplat> (also the typing context in twelf can work like that, except the part where you can't quite pattern match at all, although definitions by inversion in its logic programming language are similar.  and the typing context in delphin, but i think that's still an experimental toy language)
17:02:55 <xplat> Rotaerk_: it's a programming technique, it's googleable
17:03:07 <Rotaerk_> oh
17:03:27 <Rotaerk_> neat; didn't know it all went together as one big technical phrase
17:04:19 <copumpkin> I prefer my data à la mode
17:04:44 <Rotaerk_> my use case is something like... I've got a Map I A, where I is some index, and A is this ad-hoc discriminated union
17:05:28 <Rotaerk_> I could then request the value mapped to for a given index, and if it's a constructor I recognize, I'd handle it, otherwise ignore it
17:06:13 <Rotaerk_> my goal is that the thing managing the map itself shouldn't know anything about the types that it can hold, yet the users will need to be able to discriminate
17:06:32 <xplat> Rotaerk_: Data.Dynamic might also work for that?
17:07:07 <Rotaerk_> hmm
17:07:26 <copumpkin> Rotaerk_: have you considered having a Map :: (* -> *) -> *?
17:07:31 <xplat> the main advantage of data types a la carte over Data.Dynamic is it lets you exclude the case where functions get something they don't know about; you're planning to handle that case though
17:07:33 <copumpkin> I enjoy that structure, myself
17:07:50 <copumpkin> so the keys carry the type of the value they map to
17:08:12 <copumpkin> get :: Map f -> f a -> Maybe a
17:08:32 <arkeet> what would you use for f?
17:08:32 <haasn> I've yet to find a genuine use for Data.Dynamic other than proving that it can be done
17:08:42 <haasn> that is, one outside the ‘Acme’ namespace
17:08:43 <copumpkin> arkeet: some ad-hoc type representing your keys, or something :)
17:08:49 <theWinner> hey all
17:09:06 <copumpkin> we have a winner here
17:09:07 <theWinner> I'm trying to find the source code for haskell's difference lists.
17:09:14 <copumpkin> @hackage dlist
17:09:14 <lambdabot> http://hackage.haskell.org/package/dlist
17:09:16 <theWinner> hey pumpkin
17:09:21 <haasn> theWinner: simplest form is [a] -> [a]
17:09:24 <copumpkin> http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/src/Data-DList.html#DList
17:09:26 <xplat> copumpkin: don't you mean Sg (DMap Key (const *)) (\tm -> Map Key (lookup tm))
17:09:34 <haasn> though it can be generalized to all monoids
17:09:34 <copumpkin> lol
17:09:39 <copumpkin> xplat: yes, of course
17:09:40 <Rotaerk_> copumpkin, hmm, not ignoring you; processing your suggestion... don't quite get it yet
17:09:44 <haasn> Monoid m => (m ~ (m -> m))
17:09:48 <shachaf> haasn: And categories!
17:09:56 <arkeet> :t Endo . mappend
17:09:58 <lambdabot> Monoid a => a -> Endo a
17:10:17 <xplat> Rotaerk_: don't worry about it, it's not really something Haskell supports
17:10:17 <arkeet> :t flip appEndo mempty
17:10:19 <lambdabot> Monoid c => Endo c -> c
17:10:26 <theWinner> thanks!
17:10:39 <Rotaerk_> xplat, it doesn't?  I thought it supported that kind of type
17:10:42 <shachaf> ($ mempty) . appEndo -- /me will go to medium lengths to avoid flip
17:10:45 <theWinner> I'm trying to write a diff list for F#, and am hoping to use this as a start
17:11:02 <theWinner> I'm amazed that I can't find a diff list for ocaml that I could copy
17:11:03 <haasn>  appEndo ? mempty
17:11:03 <shachaf> (appEndo ?? mempty) -- also acceptable
17:11:08 <haasn> oh, ??
17:11:23 <FireFly> @ty (??)
17:11:25 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:11:27 <haasn> :t (?)
17:11:28 <shachaf> (??) = flip
17:11:28 <lambdabot> Not in scope: `?'
17:13:13 <haasn> re: my earlier claim about m ~ (m -> m) I'm suddenly unsure; using False/True with (||) as an example, the ‘not’ function contradicts the isomorphism law of mappend (not mempty) = not, the former reduces to id
17:13:16 <sw2wolf> what's the usage of Arbitrary ?
17:13:25 <sw2wolf> @hoogle Arbitrary
17:13:25 <lambdabot> Test.QuickCheck.Arbitrary class Arbitrary a
17:13:26 <lambdabot> Test.QuickCheck class Arbitrary a
17:13:26 <lambdabot> Test.QuickCheck.Arbitrary arbitrary :: Arbitrary a => Gen a
17:13:49 <arkeet> haasn: there's an embedding
17:13:54 <arkeet> but it's not surjective.
17:14:00 <shachaf> haasn: No, m -> m is bigger than m, of course.
17:14:13 <shachaf> Every DList value will be of the form (x <>)
17:14:16 <Rarrikins> sw2wolf: It's used to make an arbitrary example.
17:14:23 <shachaf> But there are many other function values in the world.
17:14:42 <sw2wolf> Rarrikins: thx
17:14:51 <xplat> haasn: like 'reverse'
17:14:59 <arkeet> the functions f :: m -> m that come from an element m are precisely those such that f x = f mempty <> x
17:15:05 <haasn> yes that makes sense, m ≠ m^m
17:15:19 <haasn> there's no way they can be isomorphic in the first place
17:15:19 <arkeet> element of m*
17:15:29 <shachaf> Well, if m = 1...
17:15:34 <haasn> in general
17:16:22 <xplat> there are also certain domains that are iso to their own endofunctionspace i think
17:16:44 <xplat> but they are not sets/flat domains and need to be carefully constructed
17:16:46 <haasn> how many functions () -> () exist in proper Haskell? \_ -> (); \() -> (); \_ -> ⊥ ?
17:17:17 <arkeet> assuming there is only one ⊥, yes
17:17:19 <hpc> haasn: and ⊥
17:17:25 <arkeet> that too
17:17:28 <hpc> if you assume seq
17:17:32 <arkeet> seq sucks
17:17:34 <haasn> hpc: ah, yes
17:17:52 <shachaf> I say that ⊥ is not a function.
17:17:56 <haasn> (though that depends on whether -- yeah
17:18:01 <arkeet> sure it is.
17:18:01 <hpc> incidentally
17:18:05 <structuralist> for terms of untyped lambda calculus t ~ t^t no?
17:18:06 <xplat> it's still an element of the type
17:18:17 <arkeet> structuralist: what is ^?
17:18:21 <xplat> and that means it can be applied
17:18:25 <structuralist> t -> t
17:18:26 <hpc> (->) as exponentiation holds in total languages as 1^1 and \() -> ()
17:18:30 <arkeet> yes, what is ->
17:18:33 <haasn> structuralist: for terms of untyped lambda calculus, t=1, essentially
17:18:34 <xplat> it's not a canonical function (a lambda)
17:18:41 <xplat> but then neither is unsafeCoerce
17:18:43 <hpc> and in non-total languages, you need seq to keep the same equality
17:18:56 <hpc> because () has two inhabitants and 2^2 is 4
17:19:01 <haasn> untyped -> unityped
17:19:41 <xplat> hpc: but Bool has 3 inhabitants, and i don't think it's got 9 endofunctions
17:20:06 <structuralist> the type is mu t . t -> t right?
17:20:36 <hpc> xplat: i think so; lemme try and list them
17:20:50 <arkeet> arghhhh
17:21:00 <arkeet> stupid type literals
17:21:15 <FireFly> Okay, I'm probably just tired but I don't see how (??) is implemented to satisfy the type lambdabot gave...
17:21:27 <FireFly> Could someone explain?
17:21:31 <shachaf> @ty (??)
17:21:31 <hpc> xplat: crap, you're right
17:21:32 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:21:47 <hpc> there are 6 such functions
17:21:48 <shachaf> @ty \m x -> fmap ($ x) m
17:21:49 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:21:56 <xplat> hpc: there's actually more than six
17:21:56 <hpc> bottom, id, not, and 3 consts
17:22:18 <FireFly> ...oh
17:22:25 <FireFly> shachaf: yeah, thanks
17:22:28 <haasn> hpc: if x then ... else undefined
17:22:29 <hpc> oh yes, hmm
17:22:51 <haasn> two more of those, then another two for the other way round
17:22:56 <haasn> (if not x ...)
17:22:59 <hpc> that's 10
17:23:02 <xplat> there's also strict id, if x then undefined else {True/False}, if x then {True/False} else undefined
17:23:02 <hpc> dammit!
17:23:06 <xplat> so that's 5 more
17:23:19 <hpc> strict id = id
17:23:21 <shachaf> Strict id?
17:23:30 <xplat> hrm, you're right
17:23:39 <hpc> my count is
17:23:44 <xplat> oh, strict const True and strict const False
17:23:51 <xplat> so my count is 12
17:24:13 <hpc> so moral of the story is, bottom sucks
17:24:27 <arkeet> I count at least 13.
17:24:37 <Rotaerk_> hpc, you prefer top eh?
17:24:40 <hpc> arkeet: what are we missing?
17:24:47 <xplat> bottom sucks bottom.  in an infinitely recursive loop :)
17:24:49 <haasn> but Bool -> Bool is 3^3 aka 27
17:24:56 <arkeet> oh, two of the ones I was thinking of are probably the same.
17:24:58 <haasn> don't know how you arrived at 9 endofunctions in the first place
17:25:09 <shachaf> haasn: You can't discriminate on ⊥ like that.
17:25:22 <haasn> well yes, minus those impossibilities
17:25:25 <arkeet> haasn: you can't send say ⊥ to True and send True elsewhere
17:25:28 <xplat> haasn: either way, it's not a power of 3
17:25:41 <hpc> yeah, if bottom was a true value (haha) then you could build 27
17:25:47 <cmccann> it should be 27 minus any possibilities that give non-_|_ on _|_ but aren't const something
17:25:52 <cmccann> right?
17:25:54 <haasn> I'm just saying that there being more than 9 is not surprising
17:25:56 <hpc> so really the question becomes counting the functions you can't write
17:26:10 <hpc> (the non-monotonic functions)
17:26:13 <shachaf> cmccann: And also f = ⊥?
17:27:02 <cmccann> shachaf: can you distinguish that from const _|_?
17:27:07 <shachaf> Yes, with seq.
17:27:10 <shachaf> We were allowing seq.
17:27:15 <cmccann> oh well seq is stupid
17:27:19 <cmccann> that's your problem then
17:27:26 <shachaf> Well, so's ⊥.
17:28:00 <cmccann> seq is more stupider though.
17:28:23 <hpc> cmccann: the question is how many stupiders it is
17:28:38 <shachaf> hpc: All of them, according to cmccann.
17:28:46 <cmccann> yes, all the stupids.
17:29:00 <xplat> bottom contains the least information by definition, hence it is the stupidest value
17:29:54 <merijn> fat-bottomed function, you make my rocking world more miserable? :<
17:30:56 <cmccann> more like make your rocking worl*** Exception: Prelude.undefined
17:31:11 <merijn> ooh
17:31:18 <merijn> That's actually a good one :p
17:31:21 <shachaf> I am seeing 12 values of that type.
17:31:24 <shachaf> What is arkeet's 13th?
17:31:32 <arkeet> I'm including bottom
17:31:35 <shachaf> So am I.
17:31:43 <arkeet> oh and I corrected myself
17:32:03 <shachaf> Oh.
17:32:07 <shachaf> So you're also seeing 12?
17:32:14 <arkeet> yeah
17:32:30 <shachaf> Then I declare myself correct by virtue of having the same answer as arkeet.
17:32:43 <arkeet> 9 strict ones, 3 constant ones, one is both strict and constant
17:32:44 <merijn> @remember merijn&cmccann "Fat-bottomed function, you make my rocking worl*** Exception: Prelude.undefined"
17:32:44 <arkeet> and then ⊥
17:32:44 <lambdabot> Okay.
17:32:56 <cmccann> heh
17:33:08 <arkeet> (and clearly anything non-strict is constant)
17:33:16 <shachaf> @forget shachaf Don't fixity fit ain't broken.
17:33:16 <lambdabot> Done.
17:33:22 <shachaf> Why would you put that there?
17:33:26 * shachaf is annoyed.
17:33:40 <cmccann> maybe it was put there to annoy you.
17:33:46 <shachaf> Probably.
17:33:57 <shachaf> That seems to be the main motivation of everything.
17:34:05 <arkeet> this same thing works for any flat domains
17:34:06 <cmccann> the better question is why you would say that in the first place.
17:34:19 <merijn> I remember I finally managed to get like 5+ funny quotes of me in lambdabot (without my intervention even), but then lambdabot died and lost the quote file :(
17:34:27 <shachaf> merijn: It's back!
17:34:28 <shachaf> -ish
17:34:29 <xplat> well, an endofunction on a lifted flat domain has strict functions that assign each of the values ((n+1)²), strict const functions (n+1), nonstrict const functions (n), and bottom (1)
17:34:35 <shachaf> I went through #haskell logs and put all the old quotes back.
17:34:50 <arkeet> if X and Y are flat and have m and n values (including ⊥), then X -> Y has ⊥ together with mn + n - 1 non-⊥ values.
17:34:52 <theWinner> so, about haskell
17:34:56 <xplat> er, sorry, ((n+1)^n) for the first
17:34:57 <cmccann> shachaf: good work
17:35:14 <theWinner> i personally dislike laziness-by-default
17:35:17 <merijn> ooh, I look cool again! \o/
17:35:17 <hpc> > (n+1)**2 + (n + 1) + n + 1 :: Expr
17:35:19 <lambdabot>   (n + 1)**2 + (n + 1) + n + 1
17:35:20 <cmccann> shachaf: most of them were probably from you anyway
17:35:22 <xplat> so (n+1)^n + 2n + 2?
17:35:26 <arkeet> er
17:35:27 <theWinner> i would rather opt-in to laziness
17:35:29 <arkeet> n^m + n - 1
17:35:35 <arkeet> er
17:35:36 <typoclass> shachaf: thanks for the work, that's great
17:35:40 <theWinner> only in the places that I need it
17:35:48 <merijn> theWinner: Then you probably want OCaml/F#/Habit :p
17:35:53 <arkeet> never mind.
17:36:00 <hpc> xplat: i think it would be n(n+1)
17:36:04 <cmccann> theWinner: I would rather laziness by default so that I don't have to deal with other people's code not opting into laziness where they should
17:36:04 <theWinner> I'm wondering if I'm in the minority
17:36:11 <hpc> because you can't match on bottom
17:36:28 <theWinner> cmccann, I can empathise with that
17:36:30 <arkeet> there are n^(m-1) strict functions and n constant functions.
17:36:37 <merijn> theWinner: Well, in the haskell community you wil definitely be in the minority with that opinion
17:36:42 <hpc> er
17:36:47 <hpc> wait no i am dumb
17:36:48 <theWinner> I mean in the FP community
17:36:49 <BMeph_> theWinner: Don't forget to make everything that uses or depends on that opted-in laziness accommodate it...and good luck tracking it all down. ;)
17:36:54 <merijn> theWinner: What's the problem you have with lazy by default?
17:36:59 <arkeet> minus 1 for double-counting const ⊥, and plus 1 for ⊥
17:36:59 <xplat> oh, i'm double-counting the strict consts
17:37:07 <theWinner> it's harder to reason about performance for me
17:37:12 <cmccann> laziness is pretty much always better as long as the performance overhead is small enough to not matter
17:37:16 <merijn> theWinner: Well, the OCaml/SML/F# people all like their functional languages strict, so
17:37:16 <cmccann> which is usually the case
17:37:20 <arkeet> so n^(m-1) + n
17:37:27 <xplat> well, an endofunction on a lifted flat domain has strict functions that assign each of the values ((n+1)^2), nonstrict const functions (n), and bottom (1)
17:37:42 <arkeet> xplat: there is only one nonstrict const function.
17:37:49 <arkeet> you probably mean strict.
17:37:56 <arkeet> er
17:37:58 <arkeet> I'm backwards.
17:38:00 <merijn> theWinner: The Habit people are working on a haskell-like language for systems programming, that one will be strict to make low level performance analysis simpler
17:38:01 <hpc> merijn: as i understand it, the F# programmers like their functional languages to be like C# but developed faster
17:38:03 <xplat> oh, i could swear i fixed the exponent
17:38:03 <BMeph_> theWinner: You're definitely in the "listens-to-Harper" community majority. ;)
17:38:14 <cmccann> I also don't think it's easy to reason about performance in strict languages.
17:38:19 <arkeet> anyway, who cares.
17:38:45 <xplat> ((n+1)^n) + n + 1
17:38:45 <hpc> cmccann: i would say it's exactly as easy to reason about performance in strict or lazy languages
17:38:53 <merijn> shachaf: Ha, I don't even remember half those quotes of me being in lambdabot :p
17:39:19 <xplat> () : 2 + 1 + 1 = 4 ; Bool : 9 + 2 + 1 = 12
17:39:24 <theWinner> merijn, that sounds interresting
17:39:27 <cmccann> hpc: given a static codebase I agree, I think laziness has more potential for non-local performance impacts when modifying code.
17:39:28 <theWinner> I love type classes
17:39:30 <hpc> > map (\n -> ((n+1)^n) + n + 1) [1..]
17:39:31 <lambdabot>   [4,12,68,630,7782,117656,2097160,43046730,1000000010,25937424612,7430083707...
17:39:44 <xplat> > map (\n -> ((n+1)^n) + n + 1) [0..]
17:39:46 <merijn> hpc,cmccann: I disagree, strict performance analysis can be done locally. i.e. pick one scope and you can analyse the performance. With laziness the efficiency can depend on how code is used
17:39:46 <lambdabot>   [2,4,12,68,630,7782,117656,2097160,43046730,1000000010,25937424612,74300837...
17:39:50 <hpc> > map (\n -> (n^n) - (((n+1)^n) + n + 1)) [1..]
17:39:51 <lambdabot>   [-3,-8,-41,-374,-4657,-71000,-1273617,-26269514,-612579521,-15937424612,-45...
17:39:56 <theWinner> BMeph_, who is Harper, please?
17:40:13 <merijn> hpc,cmccann: That means you can analyse the performance of a function in isolation without knowing the context it'sused in
17:40:18 <xplat> 2 functions on Void : id and undefined
17:40:22 <hpc> > map (\n -> ((n+1)^(n+1)) - (((n+1)^n) + n + 1)) [1..]
17:40:22 <merijn> theWinner: Bob Harper, big ML fan and Haskell hater
17:40:24 <lambdabot>   [0,15,188,2495,38874,705887,14680056,344373759,8999999990,259374245999,8173...
17:40:29 <cmccann> merijn: that's what I mean about static code
17:40:30 <arkeet> actually I agree, seq sucks
17:40:32 <theWinner> haskell hater, ha :)
17:40:35 <hpc> and voila!
17:40:36 <theWinner> no reason to hate
17:40:40 <arkeet> it's seq's fault that we don't get a cartesian closed category.
17:40:46 <arkeet> or something.
17:40:46 <merijn> theWinner: He likes to rant and whine about how it's unfair that haskell is more popular than his beloved ML :)
17:40:48 <hpc> the difference in size between monotonic bottom and non-...
17:40:49 <theWinner> haskell is great for the people who prefer it
17:41:01 <cmccann> merijn: given a fixed codebase you can reason backwards based on the demands for values
17:41:12 <theWinner> and it has moved FP forward a great deal
17:41:15 <BMeph_> merijn: Than SML - all the other ML varieties are second-class, too. ;þ
17:41:25 <merijn> cmccann: Oh, sure. But that means your codebase needs to be small enough to analyse as a whole :)
17:41:35 <hpc> cmccann: given a fixed codebase you don't have to reason about performance because it's forever unchanging!
17:41:43 <hpc> you can memoize all its outputs
17:41:47 <merijn> Speaking of SML, anyone here ever got Milton running on OSX?
17:41:47 <cmccann> haha
17:42:55 <cmccann> anyway, it's fun to think about how you'd specify something like big-O for lazy functions that actually accounts for the space/time complexity as a function of how much is forced
17:43:04 <cmccann> but it's definitely more complicated to analyze
17:43:27 <theWinner> I am surprised too, I suppose, for Haskell's popularity vs., say, F#
17:43:41 <cmccann> F# is much newer
17:44:05 <theWinner> actually, it seems like very few people are talking about F# at all
17:44:07 <hpc> F#'s target audience is people who are too smart for .net but have to use it anyway
17:44:11 <xplat> F# is popular with functional programmers who have to work on .NET but don't have to work in C#
17:44:13 <theWinner> haha
17:44:15 <merijn> theWinner: Haskell's type system is much more flexible for advanced type hackery and it's 100% pure, unlike most of the F#/ML variants
17:44:17 <cmccann> pretty much
17:44:27 <merijn> Also, I think haskell's syntax is prettier
17:44:43 <shachaf> Haskell's monoids are easier.
17:45:02 <merijn> theWinner: Not many people talk about F# because it's a bit boring
17:45:02 <theWinner> i do personally find Haskell's syntax too irregular. I like 'there's just one way to express it' where possible.
17:45:06 <hpc> shachaf: especially in the category of endofunctors
17:45:20 <merijn> Note: I don't mean boring as insult
17:45:25 <theWinner> merjin, boring how?
17:45:29 <merijn> It's just...there's not much to say about it
17:45:41 <hpc> theWinner: the way i see it is, "your code should look like what it does"
17:45:45 <lispy> I need to take lambdabot down for a bit sorry
17:45:46 <xplat> theWinner: strictly speaking 'there's just one way to express it' doesn't allow function application to exist
17:45:53 <lispy> Probably about 3 hours
17:45:54 <parcs> > text "noooooooooooooooooooooooooooooo"
17:45:55 <lambdabot>   noooooooooooooooooooooooooooooo
17:45:55 <hpc> and many times, the exact same definition expresses two different concepts
17:45:58 <cmccann> to anyone familiar with C# and Haskell, learning F# seems like mostly an exercise in figuring out which ideas apply when
17:46:03 <hpc> or more than 2
17:46:07 <lispy> Perhaps someone else can run a lambdabot in the mean time :)
17:46:09 <merijn> It's basically ML with .NET interaction, if you have to use .NET it's nice, but it doesn't really have any exciting "no one else has this" features
17:46:23 <theWinner> one thing that irks me is when programmers use F# as a more succinct C#
17:46:30 <xplat> theWinner: or at least, not applied to any arguments that are statically known
17:46:31 <theWinner> all OOP everywhere
17:46:42 <hpc> it has a very boring "no one else has this" feature, which is every library ever written for .net
17:46:42 <theWinner> ugh
17:47:11 <cmccann> hpc: I seem to recall it has a few somewhat novel ideas but I can't recall the details
17:47:14 <merijn> theWinner: So basically, the people who write F# are "people who write haskell/scala/SML/ocaml, but can't get away with that at work" :p
17:47:21 <cmccann> nothing that sounded incredibly exciting to me at least
17:47:42 <cmccann> I think scala is more widely used in practice than F#
17:47:45 <theWinner> My boss let me write F# at work, but I opted out because we had to quickly pass the codebase over to a bunch of idiots
17:47:45 <hpc> merijn: incidentally, a lot of F# developers prototype their new language features in ghc
17:47:50 <squidz> after learning functional languages, I have to now do some low-level embedded programming. Coming from functional programming. Looking at coding in something like C looks like hell to me. Other than program C in a functional style, can somebody please help me. Is there another language out there?
17:47:55 <hpc> from what i have heard, anyway
17:48:09 <merijn> hpc: I wouldn't be surprised
17:48:15 <xplat> squidz: atom?
17:48:23 <theWinner> sadly, you might be stuck with C++
17:48:33 <cmccann> hpc: given how many people on the C# team know Haskell that doesn't surprise me
17:48:34 <BMeph_> squidz: ATS!! ;þ
17:48:38 <merijn> I would say C > C++ for low-level embedded
17:48:47 <hpc> squidz: how "embedded" is this code?
17:48:48 <cmccann> there's a lot of Haskell influence floating around microsoft's programming language folks
17:48:50 <merijn> c11 is pretty neat
17:48:53 <hpc> could you get away with perl, for instance?
17:49:04 <merijn> hpc: Can anyone?
17:49:06 <XexonixXexillion> I'd say Ada > C for embedded, but most that's just my opinion
17:49:16 <XexonixXexillion> s/most/mostly/
17:49:23 <hpc> perl is a fantastic language burdened by awful programmers
17:49:25 <theWinner> templates are great compared to, say, nothing
17:49:29 <theWinner> er, #define
17:49:38 <squidz> hpc: we will be coding some small chip for simple led circuit stuff as far as I know. Im not sure how much memory the chips have, but im pretty sure it aint much
17:49:42 <hpc> in much the same way that C++ is an awful language blessed with fantastic programmers
17:49:44 <merijn> theWinner: Clearly you've never witnessed my awesome CPP templates :p
17:49:52 <hpc> oh, ouch
17:50:20 <squidz> could ats/atom be used for this kind of stuff?
17:50:22 <hpc> squidz: if the instruction set is simple enough, i say go with writing a haskell program that outputs the code you want to have run
17:50:26 <xplat> XexonixXexillion: in theory i think ada somehow ought to be better than C, practically speaking i have a conditioned aversion :)
17:50:36 <merijn> I wasn't supposed to use void* for my container data structures, because that "wasn't type safe", so I implemented typed containers using CPP templates :p
17:50:40 <hpc> squidz: it's not as hard as it sounds
17:51:09 <squidz> hpc: im not sure what you mean by output
17:51:16 <XexonixXexillion> xplat: I think the conditioned aversion comes from c programmers being forced to use ada and *really* disliking it
17:51:29 <theWinner> well, thx all for the help!
17:51:35 <XexonixXexillion> strongly typed languages annoy c programmers
17:51:56 <merijn> That's not true, I'm a C programmer and I <3 strong typing :p
17:52:19 <xplat> so the options that sound realistic so far, roughly in order of greatest to least abstraction: ATS, Haskell/Atom, Ada, Cyclone, functional C
17:52:45 <XexonixXexillion> merijn: do you dislike Ada? I may have to refine my statement
17:52:56 <hpc> squidz: http://hpaste.org/86218
17:53:25 <hpc> it's something along the lines of those programs that output makefiles
17:53:32 <hpc> except significantly less awful
17:53:55 <merijn> XexonixXexillion: I don't know Ada
17:54:06 <xplat> XexonixXexillion: the conditioned aversion comes from the way libraries are handled in most Ada compilers, the GUI toolkit that had to use generated code because Ada83 couldn't abstract over callbacks type-safely, and the build system in csh that rebuilt every module every time, period (1.5-4 hr build depending which machine)
17:55:28 <hpc> xplat: oh god what
17:55:32 <merijn> XexonixXexillion: But I upgraded my GHC to head to get type families with where clauses, so that should put me strongly in the "loves static typing" group of programmers :p
17:55:42 <xplat> and the crappy build system was heavily caused by the other two, because the library thing made make unusable and the built-in makelike thing in the $20,000/seat compiler was too stupid to understand the code generator's deps
17:55:47 <hpc> xplat: that reminds me of trying to code for the source engine
17:56:23 <XexonixXexillion> xplat: Fair enough. Ada compilers have gotten a lot better. GNAT would be brilliant if it wasn't so terrible at optimising function calls
17:58:34 <et09> how do i said for an Int, display if it's in the range between 0 and 100, otherwise, pick either 0 or 100 whichever is closest
17:58:41 <et09> how do i say*
17:58:55 <XexonixXexillion> I should mention that my views are probably biased due to the fact I work for a man who is pretty much the Ada Reference Manual in human form
18:00:22 <xplat> > let clamp a b x = (x `max` a) `min` b in map (clamp 0 100) [-100, -20, 20, 80, 120]
18:00:25 <Rotaerk_> hmm think I figured out how to get something like an ad-hoc discriminated union
18:00:37 <xplat> oh, right, no lambdabot
18:00:54 <et09> how does that work O_O
18:00:57 <XexonixXexillion> what happened to lambdabot?
18:01:09 <et09> LAMMJohnson:  took over obviously
18:01:23 <xplat> XexonixXexillion: lispy had to take it offline for a few hours, probably machine maintenance of some kind
18:01:59 <et09> oh ok
18:02:11 <et09> awesome
18:02:28 <lispy> Cale: Please restart lambdabot when you get a chance. The machine migration was successful.
18:02:46 <lispy> the host now has twice the ram!
18:02:56 <lispy> (linode free upgrade)
18:05:56 <Rotaerk_> I could do something like:  class SubtypeOf A B where tryCast :: A -> Maybe B
18:07:56 <arkeet> Rotaerk_: maybe you could come up with something using Typeable
18:08:16 <Rotaerk_> data Foo = FooInt Int | FooString String; instance SubtypeOf Foo Int where tryCast (FooInt i) = Just i; tryCast _ = Nothing
18:08:39 <arkeet> this sounds smelly
18:09:02 <ab9rf> if lambdabot has more ram, shouldn't that make it ramdabot, since it's obviously grown up now?
18:09:12 <Rotaerk_> then there can be some consumers that just request (SubtypeOf a Int) and others that request (SubtypeOf a String)
18:10:03 <arkeet> they may as well just ask for an Int or a String
18:10:31 <Rotaerk_> but it might not be an int, or it might not be a string
18:10:50 <arkeet> yes, but forall a. Subtypeof a Int => a   is the same as  Maybe Int
18:11:07 <arkeet> er
18:11:08 <Rotaerk_> (SubtypeOf a String, SubtypeOf a Int) => a -> something
18:11:14 <shachaf> arkeet: Next up: How many functions :: Maybe () -> Maybe () are there?
18:11:20 <arkeet> :(
18:11:35 <arkeet> that's not hard, Maybe () is totally ordered
18:12:12 <hpc> im making my own semantics! with blackjack and hookers!
18:12:16 <hpc> in fact, forget the semantics
18:12:25 <Rotaerk_> hmm actually, I think this is all for nothing; I think I'm forgetting the purpose I originally had
18:12:50 <arkeet> Rotaerk_: you may as well have Maybe Int -> Maybe String -> something
18:13:16 <Rotaerk_> I'm attempting what i believe is called "subject-oriented programming"
18:14:06 <Rotaerk_> arkeet, in that case what if it's both an int AND a string
18:14:22 <arkeet> Rotaerk_: indeed
18:14:37 <arkeet> data Bar = Bar Int String
18:14:46 <hpc> > 0xford
18:14:50 <Rotaerk_> hmm I guess technically the SubtypeOf would still act that way
18:15:01 <hpc> (that used to be 15 :()
18:15:14 <arkeet> it isn't now?
18:15:29 <hpc> they took away the function instance
18:15:36 <hpc> some frivolous crap about type safety :P
18:15:38 <arkeet> it's back for some reason
18:15:47 <hpc> !!
18:15:48 <arkeet> unless it's out agai
18:15:50 <arkeet> n
18:15:59 <arkeet> why can't we have nice things.
18:16:07 <arkeet> we got the correct (.), but NumInstances cam back.
18:16:11 <hpc> in any event, it parses as (0xf) ord
18:16:15 <arkeet> I know.
18:16:16 <arkeet> :p
18:17:05 <hpc> related: https://github.com/headprogrammingczar/php-haskell-prelude/pull/1
18:17:29 <Cale> lispy: ssh seems unresponsive
18:23:29 <Cale> @bot
18:24:21 <Cale> @bot
18:24:27 <lambdabot> :)
18:24:43 <cmccann> > 0xford
18:24:49 <lambdabot>   15
18:25:00 <xplat> > let clamp a b x = (x `max` a) `min` b in map (clamp 0 100) [-100, -20, 20, 80, 120]
18:25:06 <lispy> Cale: Thanks!
18:25:07 <lambdabot>   [0,0,20,80,100]
18:25:12 <ab9rf> yummu
18:31:13 <jfischoff> Does fmap associate objects in one category with objects in another? I can see how it associates arrows, I would think it would need something like pure to take objects to objects
18:31:21 <arkeet> > let clamp a b x = sort [a,b,x] !! 1 in map (clamp 0 100) [-100, -20, 20, 80, 120]
18:31:26 <lambdabot>   [0,0,20,80
18:31:30 <arkeet> huh?
18:31:34 <arkeet> > let clamp a b x = sort [a,b,x] !! 1 in map (clamp 0 100) [-100, -20, 20, 80, 120]
18:31:36 <lambdabot>   [0,0,20,80,100]
18:32:03 <xplat> jfischoff: in haskell it's not the fmap for the type constructor that associates objects to objects, it's the type constructor itself what does that
18:32:31 <jfischoff> Okay that makes sense
18:34:41 <Cale> jfischoff: And the Functor class might more rightfully be called Endofunctor, but since it's hard to talk about other categories inside Haskell in the first place, it's reasonable.
18:34:54 * jfischoff nods
18:35:21 <arkeet> it is?
18:35:27 <arkeet> hard, that is
18:35:49 <jfischoff> They're all subcategories of Hask
18:36:15 <arkeet> what about * -> *
18:36:33 <Cale> What about it?
18:36:39 <xplat> arkeet: Control.Category is the only real attempt that doesn't use 7.4+ features, and it only represents categories that can be represented with an object set of 'all Haskell types'.  so no finite categories, etc
18:37:04 <Cale> and the composition map is quite restricted
18:37:09 <xplat> jfischoff: they don't all have to be subcategories of Hask though
18:37:10 <Cale> because of polymorphism
18:37:28 <arkeet> xplat: I love monoids.
18:37:32 <arkeet> they are categories.
18:37:37 <jfischoff> xplay: do say more
18:38:30 <xplat> jfischoff: i'm pretty sure you can represent Hask^op as a Control.Category and it is not a subcategory of Hask
18:38:47 <arkeet> * -> * makes a fine category.
18:39:02 <arkeet> where say an arrow from f to g is a function forall a. f a -> g a
18:39:25 <jfischoff> xplat: interesting
18:39:28 <arkeet> well k -> * for any k
18:40:31 <xplat> arkeet: there's no common way to represent * -> * and Hask before 7.4 though
18:40:51 <arkeet> really?
18:41:42 <xplat> and even after there is ... awkwardness.  edwardk tried to do a category lib that could do things like that and he said there are showstopping usability problems as late as 7.6.x
18:42:19 <arkeet> well yes, there would have been trouble doing that sort of stuff generically.
18:42:31 <xplat> and iirc he doubts they'll all be fixed for 7.8 but don't quote me on that
18:43:03 <xplat> certainly not before 7.8 though
18:43:11 <arkeet> what are the issues in 7.6?
18:44:24 <Saizan> i've seen him struggle with no eta for type tuples, i.e. the difference between x and (fst x, snd x) at the type level
18:44:53 <darinmorrison> xplat: re: usability problems, is there a writeup of the problems anywhere? kind of curious
18:44:54 <arkeet> hm
18:44:58 <dolio> Eta is actually wrong for tuples in 7.6.
18:45:15 <darinmorrison> hmm
18:45:27 <xplat> ah, yeah, that was the big one for 7.6 i think
18:45:34 <Saizan> yeah, you can derive unsafeCoerce from it
18:45:36 <xplat> because of $*(@#& Any
18:45:48 <arkeet> Saizan: !??
18:45:57 <darinmorrison> heh.. oops
18:46:17 <shachaf> Good old Any.
18:46:18 <arkeet> someone remind me why Any exists?
18:47:10 <Saizan> Dynamic needs something safe to unsafeCoerce to and from, no idea other than that
18:47:13 <xplat> arkeet: because types didn't have bottom, so they were behaving too nicely
18:48:05 <dolio> Whenever GHC needs to default an unconstrained variable somewhere, ostensibly it gets defaulted to Any.
18:48:25 <Saizan> in the thread about this spj suggested to make Any something other than a type constructor so you can't pattern match on it and tell it apart from (a,b)
18:49:06 <dolio> I'm not sure where you can actually see that outside of GHCi.
18:49:20 <dolio> But in principle it could happen in other places.
18:49:33 <xplat> Saizan: ah, so have it act like a type variable that's always sitting in the context, mocking you?
18:49:53 <dolio> For instance: data E = forall a. E (a -> a) ; foo = E (\x -> x).
18:50:05 <xplat> that would be better than letting you match on it, yeah
18:50:42 <Saizan> xplat: i guess, or a type family which never gets an instance?
18:51:54 <dolio> What type is (\x -> x) given before we pack it in the existential? Any -> Any, maybe.
18:52:12 <xplat> Saizan: it seems like you could still get types of empty kinds out of it though, and that might be bad
18:53:42 <dolio> It seems like going through that decision is unnecessary, though.
18:53:42 <Saizan> xplat: considering the limited type-level machinery it might not show yet
18:54:09 <dolio> Our type checker at work doesn't do anything like that, not that it's a model of excellence.
18:55:03 <Saizan> it just doesn't bother filling in E's type argument?
18:55:37 * hackagebot Clipboard 2.2.0.2 - System clipboard interface.  http://hackage.haskell.org/package/Clipboard-2.2.0.2 (DanielDiaz)
18:55:59 <xplat> it really should either complain, or default it to something that actually exists
18:56:02 <dolio> Saizan: There's nothing in the algorithm that forces concrete values for all variables that fall out of scope.
18:56:21 <dolio> Why would it complain? It doesn't matter what it picks.
18:57:20 <cmccann> maybe the GHC devs just like zonking things.
18:57:47 <dolio> Saizan: I don't think we even keep track of the kind of information we'd need to detect the situation.
18:57:52 <dolio> It'd be a lot of work.
18:58:34 <Saizan> well, GHC translates to Core so you get an application like "E @ Any (\x -> x)"
18:58:47 <dolio> Oh, maybe that explains it, then.
18:59:17 <dolio> Anyhow, Any is almost sensible in that respect.
18:59:33 <dolio> Because otherwise you get arbitrary stuff, like E @ () (\x -> x)
18:59:55 <dolio> And then, if I make the existential have kind * -> *, maybe you get E @ Maybe (\x -> x)
19:00:13 <Saizan> yeah, it'd be a mess
19:00:57 <dolio> And one day I come along and use a kind that you don't have any good default for.
19:01:59 <dolio> But it's terrible to have it be a separate, distinguishable value in data-ish kinds.
19:03:54 <dolio> You can see that same problem, though.
19:04:15 <dolio> If I existentially quantify over (*, *) it's no problem, because you can canonically default to (Any, Any).
19:04:30 <dolio> But if it's Either * *, you have to pick Left * vs. Right *.
19:04:39 <dolio> Er, Left Any vs. Right Any.
19:06:09 <xplat> yeah, that's why i think it should whine and die
19:07:01 <dolio> That's not a very good solution, though.
19:07:17 <xplat> why not?
19:07:35 <dolio> It's whining that you have to specify some information that can't possibly matter to satisfy a problem that exists only the core language, not the surface language.
19:08:15 <xplat> well, why would you need to write E (\x -> x) in the first place?
19:08:24 <dolio> You wouldn't.
19:08:42 <xplat> then you don't have to specify anything :)
19:09:06 <dolio> Are we going to assume that because the simple example I thought of isn't good, there are no examples that are good?
19:10:21 <Rotaerk_> does anything already exist like that SubtypeOf class I mentioned earlier?
19:10:21 <dolio> I do have a better hypothetical example, actually.
19:11:17 <dolio> Database joins have types like R (| a, b |) -> R (| b, c |) -> R (| a, c |).
19:11:28 <xplat> dolio: i was actually assuming that none of the examples are good on a general principle that things like that (and i'm having trouble articulating 'things like that') are bad
19:11:35 <dolio> Er, R (| a, b, c |)
19:12:38 <dolio> Eventually you might pack your relation in a data structure that doesn't tell you exactly what columns are involved in the relation, because it doesn't matter.
19:13:08 <benzrf> hello!
19:13:25 <dolio> The backend can observe the structure of whatever relations you'e put together, and it does all its work on that.
19:13:28 <benzrf> is it just me or is ghc really a haskell interpreter, in a sense?
19:13:32 <xplat> okay, but if there are any rows in the relation, you'd better have known what the columns were before you packed it
19:13:45 <benzrf> the idea is that programs generate imperative programs, right?
19:13:59 <xplat> and probably you should have even if there weren't any rows
19:14:46 <cmccann> benzrf: that's a conceptual abstraction, not a reality of GHC's operation
19:14:56 <benzrf> ok
19:16:11 <dolio> xplat: Why? Who cares? You're forcing the programmer to write down an annotation that fixes some splitting of the row types, just so the type system can figure out the exact splitting, and then throw it away, because no one ever looks at it.
19:16:36 <benzrf> also: if I want to do something like have two different types in a signature that are both implementors of Num, can I do something like 'foo :: (Num a, b) => a -> b -> a'?
19:16:46 <dolio> No one can ever look at it to make decisions based on it.
19:17:47 <cmccann> benzrf: no, it would be (Num a, Num b)
19:17:58 <benzrf> ok
19:18:41 <benzrf> also: how do I make functions that are infix by default?
19:18:50 <dolio> In fact, I'm not even sure it's possible to specify in general.
19:18:51 <xplat> well, i guess i'd be okay with it being defaulted to 'Any' if you could convince me that Any can never, ever be observed by anything, either directly or indirectly.
19:19:18 <cmccann> benzrf: give them a name made of symbols
19:19:32 <benzrf> oh! thanks
19:19:58 <cmccann> benzrf: operators are not special in Haskell, they're just names made of symbols that are infix by default
19:20:05 <benzrf> ok
19:20:08 <benzrf> I assumed
19:20:33 <cmccann> note that you can also write operators prefix using parens like (++) and non-operators infix with backticks like `elem`
19:20:38 <xplat> benzrf: i'm partial to $+!* myself
19:20:43 <Saizan> dolio: funnily you've basically introduced "domains are non-empty" that way
19:20:46 <benzrf> I know cmccann
19:20:56 <cmccann> both also work in definitions, and you can give fixity declarations to non-operators
19:22:02 <Saizan> anyhow i agree that weak existentials erase enough information that defaulting is fine
19:22:04 <xplat> Saizan: yeah, and things like 'domains are non-empty' are the kind of thing i mean by 'observing indirectly'
19:23:06 <xplat> so if they default and the actual value can't mattter, i'd rather they default to something real
19:23:24 <dolio> For instance, I can write: foo r = Wrap (r `join` [{ x = 1 }]), which ostensibly can work independently of whether r already has an x column, or doesn't. But one is forced to choose one or the other if we require that the splitting be known before wrapping.
19:23:32 <xplat> and if the compiler can't synthesize an arbitrary real value in the domain, at least at that point it should complain
19:24:44 <Saizan> dolio: what's the type of foo there?
19:25:21 <dolio> R (| r |) -> Wrap
19:25:27 <dolio> Or something like it.
19:27:41 <xplat> dolio: if R didn't have an 'x' column it's a cross join?
19:27:51 <dolio> Yes.
19:29:13 <xplat> so basically as far as what you can access: you get either [{ x = 1 }] or []
19:30:29 <xplat> [{ x = 1 }] if r was nonempty and had no x, or if it had x and at least one row where x was 1, and [] otherwise
19:31:20 <dolio> I'm not sure what you mean.
19:31:39 <xplat> i'm still not seeing where examples like this justify a possible sacrifice of type soundness
19:31:40 <dolio> In our situation, you can't look at relations.
19:32:03 <dolio> You can't inspect anything about them. You just hand them off to something else that looks at them.
19:32:26 <dolio> What sacrifice of type soundness?
19:32:34 <dolio> Our system doesn't have Any.
19:32:46 <xplat> dolio: ah, so something else can look at them and bypass the type system, so it can see all the rows?
19:32:48 <dolio> It doesn't figure this stuff out if it doesn't need to.
19:32:53 <xplat> er, all the columns
19:33:30 <dolio> GHC needs something to dump in the core.
19:33:47 <xplat> well, i'm still trying to think when you would want a function that restricts a relation if it has a certain column, and extends it with a constant value if it doesn't have that column
19:34:03 <dolio> But I don't see why that fact should require you to nail this down in the surface language.
19:34:25 <xplat> and what if r has an x column, but it's not numeric?
19:34:59 <dolio> That's not an issue in our system, either.
19:35:05 <dolio> Fortunately or unfortunately.
19:35:27 <xplat> columns are all numeric, or they're all 'untyped' like sqlite?
19:35:47 <dolio> Columns are declared beforehand with a particular type.
19:36:45 <dolio> Anyhow, what if instead of the type I gave before, I used: join : R r -> R s -> R (r ∪ s)?
19:37:11 <xplat> oh, columns are typed, but the map from name to type is universal.  just like fortran!  :)
19:37:32 <dolio> Now there isn't even anything to figure out.
19:38:02 <dolio> It's just an artifact of the way we chose to specify the row types.
19:38:20 <dolio> But we have to nail it down for some reason.
19:38:27 <NemesisD> anyone know of a good way to figure out the types of non-exported functions in ghci?
19:40:39 <xplat> well, i think it makes sense that the split would have to be figured out, because it determines what kind of join you actually have.  the type with ∪ is a silly type because it means you can't read the join columns off the type
19:41:15 <xplat> that's part of why i liked what i saw of the row type system you guys are using in the first place
19:44:42 <dolio> Anyhow, in our situation, the types are really just a sanity check. There's no information propagated down from them.
19:44:59 <dolio> The types just correspond to information that's in the terms, which is what will actually be used.
19:47:17 <dolio> It's probably more of a factor to avoid having to specify information in our case.
19:47:45 <dolio> But I still think it's silly to have to specify it in GHC, just because core needs something in it. Even in principle.
19:48:04 <dolio> But, exposing Any the way it is in the surface language is bad.
19:48:52 <dolio> Really seems like that could be part of the core translation only.
19:49:14 <dolio> Oh, except they also use it as a safe coercion target.
19:49:21 <dolio> So it's pulling multiple duties.
19:50:08 <pxqr> Is there a library for parsing numeric sizes with suffixes? For exsample (read "1KiB" == 1024)
19:50:41 <sm> http://hackage.haskell.org/package/dimensional
19:55:38 <xplat> i still maintain that the properties you give up by having Any are more important than the properties you gain by it, especially at the type level
19:55:38 <pxqr> sm: thx, nice package, but seems like overkill; I just want to parse command line arguments with optparse-applicative.
19:56:38 <Rotaerk_> that seems weird... I have an "instance (a ~ b) => MyClass a b ..."
19:57:23 <Rotaerk_> and it works fine when I load it into GHCi, but then if I define a new type, it stops working, with the claim that there are overlapping instances
19:58:14 <Rotaerk_> (if I define the new type within GHCi, that is)
19:58:47 <xplat> sm: where are the parsing functions?  i only see Show instances ...
19:59:28 <xplat> Rotaerk_: instance ... => MyClass a b overlaps with everything, regardless of what ... => is
20:00:07 <Rotaerk_> o_O
20:00:13 <xplat> Rotaerk_: instances are chosen based only on the type constructor, they *add* constraints to be satisfied, but candidates aren't eliminated if the constraints are unsatisfiable
20:00:23 <Rotaerk_> darn
20:00:46 <dolio> xplat: Well, I mean, I don't care if they have it in Fc, because they need to fill in some gaps in core, as long as I don't lose anything from the Haskell side, and can't tell it's there.
20:01:04 <hpaste> Rotaerk pasted “Subtype” at http://hpaste.org/86220
20:01:11 <dolio> If it precludes eta and such, then I'm unhappy.
20:01:33 <xplat> dolio: yeah, i guess i just have less confidence than you that it can really be hidden, in the end
20:01:42 <Rotaerk_> that instance of Subtype allows me to do this:  tryConstrainType 5 :: (Num a) => Maybe a
20:01:51 <dolio> Well, I don't know if it can be hidden. They haven't done a good job of it so far.
20:02:01 <Rotaerk_> but if the instance is defined as just:  instance Subtype a a where ...
20:02:07 <Rotaerk_> then the above doesn't work
20:04:48 <xplat> i don't think any case of instance Foo a b c ... where a b c ... are bare type variables (unique or repeated) is going to work out for you
20:04:48 <Rotaerk_> xplat, looks like if I replace the "instance (a~b) => Subtype a b" with "instance Subtype a a", the overlapping issue still happens
20:05:18 <xplat> at least one should have an actual constructor head
20:06:12 <hpaste> Rotaerk annotated “Subtype” with “Subtype (annotation)” at http://hpaste.org/86220#a86221
20:06:22 <xplat> now if you defined all the Subtype instances of the form Subtype a a by hand that could work, but it would be awkward to use
20:06:38 <xplat> i think you really want to be using Data.Typeable or Data.Dynamic for this
20:06:40 <Rotaerk_> note the ghci log
20:07:16 <Rotaerk_> the fact that running it once works, then a data declaration, then running it again fails
20:07:44 <Saizan> yeah, that's probably just a ghci bug
20:07:54 <Rotaerk_> hmm k
20:08:10 <Saizan> data decls at the prompt are a fairly recent addition
20:08:19 <Rotaerk_> ah
20:09:15 <xplat> that doesn't change the fact that as soon as you add any other instances of Subtype you'll get overlaps everywhere
20:10:45 <Saizan> yeah, you're going to need OverlappingInstances for this to do something, it's not necessarily going to be useful though
20:11:10 <Saizan> but instance (a~b) => Subtype a b should still work better than instance Subtype a a
20:11:49 <Rotaerk_> I have a use-case for it; although I may try the approaches xplat  mentioned as well (i.e. Typeable, Dynamic or data types a la carte)
20:13:57 <xplat> if your approach to challenging but non-central problems you hit along the way when writing software is to first try writing your own solution, and then see if a library might work only if you fail, you'll learn a lot but you won't get much done
20:14:29 <Rotaerk_> true
20:14:40 <xplat> (bitter experience speaking)
20:15:16 <cmccann> xplat: that strategy seems to work well for edwardk
20:16:30 <et09> best regex library for easy search/replace?
20:16:49 <et09> or alternately just a nromal search replace where i can replace \n
20:18:45 <et09> wow just replace huh ..
20:18:50 <Rotaerk_> hmm, well with OverlappingInstances enabled, my approach seems to workworks
20:18:54 <Rotaerk_> -works
20:19:11 <Rotaerk_> however, I do prefer more "standard" solutions when they work, so will look into the others
20:19:29 <cmccann> I don't think there is a good solution to what you're trying to do
20:19:35 <cmccann> type classes don't want to work that way
20:19:52 <Rotaerk_> they do work though; at least in my test cases
20:20:00 <no-n[1]> is there a haskell library for playing musical notes?
20:20:21 <xplat> cmccann: edwardk is truly the most successful example of that strategy in action that i've seen.  i've noted a lot of other examples of people who accomplished amazing things that way, but edwardk stands out in a lot of them were the things he actually intended to do in the first place
20:20:30 <et09> @hoogle Data.String.Utils
20:20:30 <lambdabot> package array-utils
20:20:31 <lambdabot> package astview-utils
20:20:31 <lambdabot> package bluetileutils
20:20:38 <et09> huh...
20:20:45 <cmccann> xplat: haha yeah pretty much
20:21:28 <et09> @hoogle replace
20:21:28 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Replace :: TextureFunction
20:21:28 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
20:21:28 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
20:21:31 <et09> oh
20:21:57 <h4199> no-n[1]: http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound take your pick
20:22:16 <no-n[1]> thank you h4199
20:22:47 <et09> how do i make a Text?
20:23:45 <xplat> et09: Text.pack
20:23:57 <et09> thi is bizarre
20:24:01 <xplat> or use {-# LANGUAGE OverloadedStrings #-}
20:24:32 <et09> does Data.String.Utils not exist anymore or something?
20:24:49 <xplat> then you can just write '"foo"' where a Text is expected
20:25:12 <xplat> hm, did Data.String.Utils exist in the first place?  i don't remember it
20:25:22 <et09> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html it's there, whatever that means
20:25:49 <xplat> oh, that means you have to install the MissingH package to get it
20:26:03 <xplat> 'cabal install MissingH' from the shell
20:26:17 <et09> oh...
20:29:56 <hpaste> Rotaerk revised “Subtype”: “Subtype usage example” at http://hpaste.org/86220
20:30:57 <Rotaerk_> hmm probably should've put a better example... one demonstrating why i wanted it in the first place
20:31:51 <Rotaerk_> i.e. so I can write functions like:  (Subtype Foo a, Subtype Bar a) => Map Int a -> something
20:32:19 <Rotaerk_> which can work on FBB without knowing about Baz
20:32:42 * applicative continues deranged over-emotional war against SO ml trolls
20:33:49 * applicative regrets that he has but one `lift` to give for his programming language
20:35:47 <xplat> applicative: you know the best reason not to feed trolls?  evolution.
20:35:57 <applicative> oh no
20:36:03 <applicative> of course you are right
20:36:19 <applicative> stop me before i feed again!
20:36:32 <xplat> applicative: humans are primarily social animals.  argument and debate are originally a form of ritual combat, not a dialectical process to get at the truth
20:36:50 <applicative> if in the future, there are nothing but well-fed trolls left, who will feed them ???
20:38:05 <applicative> anyway I'm a worthless combatant because of my weird combination of extensive knowledge and even more extensive ignorance
20:38:13 <xplat> applicative: that means we judge debaters the same way we judge combatants.;  confidence, lack of fear and defensiveness.  when you go out of your way to pick fights with chest-beating mental midgets who aren't even in your way, it lowers you to their level, makes you look bad.  makes your point look bad by association.
20:38:30 <lightquake> does anybody know what happened to the author of hdevtools?
20:38:35 <applicative> hm, okay, you are curing me
20:38:46 <applicative> hdevtools, cant remember it
20:38:58 <lightquake> it's like ghc-mod except it has a client/server architecture so it's faster
20:39:10 <lightquake> but the dev hasn't committed anything in 3 months
20:40:49 <applicative> oh yes I remember thinking it was too fancy for my taste
20:41:06 <applicative> lightquake: that wouldn't be so bad, but there seem to be nice patches waiting
20:41:11 <lightquake> yeah
20:41:26 <lightquake> whereas ghc-mod seems to be actually, like, actively developed
20:44:42 <NickC__> If I use @hoogle here, does it spam everyone else reading this?
20:44:48 <cmccann> yes
20:44:53 <lightquake> yes
20:44:57 <cmccann> you can /msg lambdabot though
20:45:02 <lightquake> or just use real hoogle
20:45:09 <cmccann> that too!
20:45:23 <NickC__> ok, I won't then.  Good idea on the /msg.
20:54:48 <Rotaerk_> xplat, hmm, Dynamic seems like it could work, but it's less typesafe; on the other hand it's free and standard
20:55:25 <Rotaerk_> i.e. instead of (Subtype Int a, Subtype String a) => a -> b, I can just do Dynamic -> b
20:56:13 <Rotaerk_> hmm... then again, I guess a in the first one could technically be any type as well...
20:57:07 <Rotaerk_> yea Dynamic's better I guess; a type class that says "it could be an int (or it could be something else!)" is pointless
21:01:15 <mm_freak> design pattern question: imagine you have a State (Maybe X) computation that will consume (replace by Nothing) the Maybe X if it fulfills a predicate…  i'm looking for a sensible way to encode this
21:02:00 <mm_freak> withX :: (X -> (a, Bool)) -> State (Maybe X) (Maybe a)
21:02:24 <mm_freak> getX :: State (Maybe X) (Maybe X) and popX :: State (Maybe X) ()
21:02:26 <mm_freak> etc.
21:02:29 <mm_freak> any suggestions?
21:02:52 <Rotaerk_> fulfills what predicate
21:03:08 <mm_freak> side note:  the actual monad i am using has an inhibition mechanism…  if there is no message or if the message does not fulfill the predicate, the computation just suspends
21:03:18 <mm_freak> Rotaerk_: for example the Bool in withX
21:03:32 <mm_freak> the problem is:  i hate Bools
21:03:45 <mm_freak> and with the getX/popX approach i'd have to repeat myself
21:04:35 <ab9rf> hating bools sounds like a personal problem
21:05:03 <mm_freak> ab9rf: i hate Bools for the same reason i hate pointers
21:05:16 <mm_freak> or while loops
21:05:58 <mm_freak> ab9rf: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
21:08:02 <mm_freak> i guess with the continuation approach + LambdaCase it's not that bad
21:08:21 <mm_freak> my library is continuation madness anyway =)
21:10:07 <xplat> there's such a thing as hating Bools too much.  short of dependent types, a Bool is an appropriate mechanism when you have a bit that can theoretically mean anything depending on context of use
21:10:32 <xplat> if the context is more restricted, it might suggest a different type
21:10:48 * applicative loves LambdaCase, he would never have anticipated it
21:11:13 <djahandarie> And even with dependent types (or especially with dependent types), performance is a major issue with using non-bool structures.
21:11:22 <xplat> what's not to love?
21:12:00 <applicative> nothing, I think in advance I thought it was just another tiresome syntactic nicety the experts shouldn't was time on
21:13:00 <applicative> I think I have noticed that it has a secret advantage when inlining, since it is eta-reduced if you write foo = \case ... instead of the more usual form
21:13:14 <applicative> though that could have been done before more longwindedly
21:13:31 <mgsloan> Screw Maybe and Bool, just always use Either!
21:13:36 <xplat> well, anything that optionally saves you thinking of a name can never be all bad
21:13:48 <applicative> theres that too
21:14:01 <mgsloan> or "These" if you like trinary
21:14:36 <applicative> what are the constructors of These? I was needing one yesterday
21:14:37 <mm_freak> this isn't really about replacing "data Bool = True | False" by "data Consume = Consume | Ignore", because then i'm still using booleans, i'm just giving them a better name
21:14:37 <Cale> data Bool = False | True | FileNotFound
21:15:18 <mm_freak> just like replacing 'for' by 'foreach' doesn't solve the locality problem
21:15:31 <mm_freak> replacing 'for' by 'foldr' does
21:15:53 <cmccann> mgsloan: :D
21:16:04 <xplat> mm_freak: well, that can help sometimes because you can no longer confuse 'it Truely should be consumed' with 'it Truely should be ignored'.  although you can always just match filter as best you can.
21:16:45 <applicative> Either is just Bool with 'decoration'
21:17:10 <xplat> Cale: data Bool = False | True | Abort | Retry | Ignore
21:17:29 <mgsloan> applicative: And lists are just peano numbers with 'decoration'
21:17:38 <applicative> right
21:17:50 <applicative> but i like the peano numbers, what could be more wonderful
21:17:54 <xplat> itym 'ornamentation'
21:18:04 <cmccann> tuples are just () with multiple decorations
21:18:06 <applicative> oh right, I used the wrong word
21:18:14 <mgsloan> course, I suppose Z / the empty list doesn't have ornamentation
21:18:30 <sirspazzolot> if my math experience stops with basic calc, will I be able to fully appreciate functional programming
21:18:42 <Rotaerk_> I feel kind of dirty for considering using Data.Dynamic
21:18:48 <mm_freak> applicative: Either is also a sensible family of monads
21:18:57 <mm_freak> the danger is when you need to fold an Either
21:19:03 <applicative> no problem sirspazzolot no math needed.  something like logic does help but is far from needed
21:19:05 <mm_freak> sirspazzolot: sure
21:19:11 <cmccann> sirspazzolot: calculus isn't gonna help much. being comfortable with symbolic manipulation like in algebra might help in Haskell.
21:19:35 <applicative> sirspazzolot: high school algebra is more like it yes, as cmccann is saying
21:19:48 <xplat> sirspazzolot: only in that if you fully appreciate functional programming, your math experience will not havee stopped with basic calc.
21:19:50 <cmccann> sirspazzolot: symbolic logic and naive set theory are nice to know. also some discrete math like combinatorics. that's general computer science knowledge though.
21:20:03 <xplat> (or at all)
21:20:49 <cmccann> yeah learning Haskell might have an adverse effect on your state of not experiencing math. it tends to lure people in :P
21:20:52 <applicative> sirspazzolot: you end up learning little bits of abstract math, I guess -- that's what is leading to your question -- but it is deeply embedded in practical experience you will be having
21:21:07 <cmccann> it tends to sneak up on you really
21:21:26 <ab9rf> cmccann: sadly a lot of computer science people are lacking in discrete math
21:21:27 <cmccann> neat things you figure out for practical reasons suddenly turning out to be some obscure math you'd never heard of
21:22:04 <applicative> so the experience of learning it will go without being noticed. and once you see some of the abstractions you will experience an intense pleasure and begin writing opaque blog posts no one will understand....
21:22:32 <ab9rf> applicative: hopefully not involving burritos in any wy
21:22:42 <applicative> god willing no.
21:22:47 * cmccann remembers a question on SO to the effect of "I came up with this abstraction while programming and it seems to useful to be new, someone tell me what I've reinvented"
21:22:54 <applicative> haha
21:22:59 <cmccann> (it was a resumption monad I think)
21:23:09 <applicative> oh thats pretty fancy
21:23:14 <sirspazzolot> haha alright. looking forward to it then. I'll start reading lyah when I think up and implement a window layout for this darned python thing
21:23:43 <applicative> sirspazzolot: well our crowd is always here to get you over the various amusing humps and so on!
21:23:44 <cmccann> applicative: yeah it was sort of a stripped-down minimal version of the concept if I'm remembering correctly
21:23:57 <sirspazzolot> lovely to hear!
21:23:58 <cmccann> rather that confusing it with something else on SO or whatever
21:26:47 <cmccann> ok, I asked this in #haskell-lens earlier but only a couple people responded
21:26:54 <cmccann> if you have "class (Applicative f) => FooFunctor f where ..." satisfying the additional laws "const () <$> x === pure ()" and "liftA2 (,) x x === (\a -> (a, a)) <$> x" what else can you conclude about law-abiding instances?
21:28:55 <tgeeky> cmccann: I am not sure if I can answer it, but I think the answer is in: http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
21:29:31 <cmccann> it shouldn't be too hard to figure out the main idea of what those imply
21:29:40 <cmccann> there's some hair-splitting I can't decide on though
21:30:36 <xplat> summary of conclusions from #haskell-lens: State, Writer, List, ZipList do not satisfy the first law, Reader, Stream and Identity satisfy both laws.  there may or may not be any instances that satisfy the first and not second law, and cmccann is intensely interested in this point
21:30:47 <cmccann> hahaha
21:31:02 <xplat> also, there may or may not be any non-Representable functors that satisfy the first law
21:31:23 * tgeeky wonders if that is the diagram on page 17
21:31:36 <tgeeky> no i think not
21:31:41 <cmccann> it's just one of those things that bugs me until I get someone else to figure it out for me
21:33:52 <cmccann> anyway, it's from a SO question: http://stackoverflow.com/q/16123588/157360
21:34:06 <cmccann> I left out his second law because I'm pretty certain it's implied by the first
21:38:29 <tgeeky> cmccann: is 2. "flip"?
21:38:46 <cmccann> 2 is that the functor be commutative
21:39:20 <cmccann> which is true of more functors than the ones in question here
21:40:10 <cmccann> but yeah, flip is commutativity for Reader
21:40:20 <applicative> it occurs to me that school calculus may be of some use in learning haskell, not from the material, but from the sense of function and argument, and of the function itself as a topic and as argument of a function
21:40:37 <hpaste> jamil pasted “folds” at http://hpaste.org/86225
21:40:37 <applicative> this is a point already made by Frege 1879 in introducing the concept of the higher order function
21:40:46 <cmccann> applicative: many calculus courses don't really emphasize that point very well alas
21:41:03 <applicative> true, i'm just thinking the experience might of use
21:41:06 <NemesisD> ugh, conduit's api is incredibly obtuse
21:41:21 <jamil_1> hi all, looking for explanation of this code: http://hpaste.org/86225
21:41:48 <applicative> jamil_1: it looks like it would compile
21:41:51 <applicative> :)
21:41:58 <jamil_1> it does
21:42:09 <jamil_1> but why
21:42:40 <xplat> NemesisD: yeah, if you haven't used either before you might try starting with pipes first to understand the principles and then seeing if the convenience features of conduit are worthwhile
21:43:31 <applicative> jamil_1: it's even more beautiful if you write the associated diagrams. let me see if i can find some pictures
21:43:45 <xplat> (or alternately--seeing whether you're using yesod, because then the choice is made for you)
21:44:58 <NemesisD> xplat: at this point io-streams solves all of my needs much more elegantly
21:45:19 <tgeeky> cmccann: looking at things a little further, it looks as though that paper I referenced is relevant
21:45:38 <cmccann> it does deal with representable functors
21:45:48 <cmccann> I'm not sure if anything in there answers my question though :T
21:45:48 <tgeeky> cmccann: check out page 16
21:45:58 <jamil_1> applicative: like this: http://i.imgur.com/mGenH2x.jpg
21:45:58 <tgeeky> well, maybe what you have is the linear lifting lemma
21:46:08 <tgeeky> or rather, you need that thing
21:46:09 <NemesisD> unfortunately im finding myself having to extract the body from a WAI request, which is a source. slogging through the conduit docs, which don't seem at all optimized for the simple case
21:46:50 <tgeeky> cmccann: in his language, you don't have i combinators (because you are allowing duping, because of #3), but you do have a c combinator (which is flip)
21:46:56 <tgeeky> and you also have k
21:47:40 <tgeeky> this version of the paper does not have the definitions
21:47:45 <tgeeky> at the end
21:48:28 <tgeeky> now i can see them. wierd. Mozilla PDF renderer.
21:48:41 <Shou> Hi, can anyone help me with Attoparsec? I'm trying to parse a string ":us" that can optionally have arguments ":us anything goes here", but if it's just ":us" it'll return (Partial _) if I try anything after the (A.string ":us") like (A.string ":us" >> A.skipWhile (== ' ')) or even A.atEnd, and I understand why it's happening but not how to circumvent it.
21:48:49 <tgeeky> cmccann: anything? Or are you *sure* it's not similar enough?
21:49:08 <xplat> NemesisD: io-streams don't seem all that elegant to me, but i guess they look better compared to conduit
21:49:47 <cmccann> tgeeky: the main thing I'm wondering is whether the second law changes anything, or if it's implied by the first
21:49:48 <applicative> jamil_1: yes right perfect you also need the corresponding 'dual' image for something like data Nu = forall s . Nu (s -> f s) s
21:50:14 <tgeeky> cmccann: is it not implied by the first
21:50:23 <NemesisD> xplat: i find it way easier to get real work done in and still be able to understand my code, without all the esoteric infix operators
21:50:32 <cmccann> tgeeky: for finite structures it is
21:50:41 <cmccann> tgeeky: for infinite structures I'm not sure
21:50:50 <NemesisD> im sure there are complex cases that conduit solves better but i haven't come close to hitting those
21:51:11 <tgeeky> cmccann: I'm sure Hinze's Stream is an infinte structure, yes?
21:51:23 <tgeeky> cmccann: and he has k, s, and c checked in the diagram on page 17
21:51:48 <applicative> jamil_1: here's both, in over mathematical style http://patternsinfp.wordpress.com/2011/04/11/morality-and-temptation/
21:51:50 <cmccann> tgeeky: basically the question is whether you can make something that works more like the standard [] instance without violating the first law and Applicative laws
21:52:07 <cmccann> Stream I doubt, but I can't convince myself about infinite types in general
21:52:45 <tgeeky> cmccann: what would you call 1)?
21:53:18 <applicative> jamil_1: this works through some of the material more practically with the specific functor "Prelist a", where data Prelist a b = Nil | Cons a b
21:53:20 <applicative> http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
21:53:33 <cmccann> tgeeky: hm?
21:53:46 <tgeeky> cmccann: if we're giving a nickname to each law
21:53:56 <applicative> i remember finding it very hard the first time I read it, and it is oriented at fusion optimizations, but that gives it practical interest jamil_1
21:53:57 <tgeeky> cmccann: what is the nickname for 1, if 2 is "flip"
21:54:12 <jamil_1> "As we know, recursive data types are fixpoints of non-recursive ones"
21:54:25 <jamil_1> I didn't know
21:54:45 <cmccann> tgeeky: beats me
21:54:55 <applicative> yes, but there are two fixpoints available. the one you mention, and the other. 'mu' and 'nu' in the fancier jargon. somehow I figured it all out when I got them together
21:54:59 <jamil_1> applicative: so I started out to understand one set of slide now I have two more articles :)
21:55:11 <applicative> good work, jamil_1 :)
21:55:36 <applicative> jamil_1: but I'm not sure I'm hitting on the pedagogically best ones. Still thinking
21:56:01 <otters> how long should it take to upload a package to hackage? I've been waiting about 20 minutes
21:56:19 <applicative> the theory of 'initial algebras' and 'final coalebras' folds and unfolds is insanely beautiful, but I remember it taking a while...
21:56:20 <cmccann> applicative: did you mention the bananas lenses and barbed wire paper?
21:56:30 <xplat> NemesisD: i find it looks way too imperative and when i want to do anything pipeliney i have to figure out which 'polarity' to work at
21:56:31 <cmccann> that's relevant-ish
21:56:53 <applicative> cmccann: no, I can't remember isn't that really hard?  I was thinking there must be more modern simple expositions.
21:57:02 <xplat> NemesisD: but then i havent really tried it seriously because of this initial impression
21:57:17 <cmccann> I vaguely recall it being approachable but I may not be a the best judge of that
21:57:49 <applicative> jamil_1: cmccann is referring to http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf which is an older exposition in a wonderful lost symbolism
21:58:30 * applicative demands a Squiggol implementation now!
21:58:32 <cmccann> "banana brackets" is a term worth keeping
21:58:34 <cmccann> forever
21:58:54 <applicative> somehow I find them hard to read, maybe i didn't work hard enough
21:59:04 <xplat> like 'banana hammock'
21:59:18 <cmccann> wow that quit was oddly appropriate
21:59:33 <applicative> ha.
21:59:55 <applicative> I used to have a bootleg of Algebra of Programming, which is more elementary and covers some of this.
21:59:56 <cmccann> hahahaha http://www.willamette.edu/~fruehr/logos/PNGs/CataLaw.png
22:00:03 <xplat> can you quote it for those of us who hide quits from non-speakers?
22:00:19 <cmccann> xplat: not the message, the user bananagram
22:00:30 <xplat> ah, heh
22:00:48 * hackagebot kevin 0.8 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.8 (JoelTaylor)
22:00:51 * hackagebot extcore 1.0.2 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-1.0.2 (TimChevalier)
22:00:52 * hackagebot kevin 0.8.1 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.8.1 (JoelTaylor)
22:00:54 * hackagebot kevin 0.8.2 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.8.2 (JoelTaylor)
22:01:15 <NemesisD> xplat: if you are proficient with conduit, i'm working with requestBody :: Source (ResourceT IO) ByteString, i'm trying to write fullBody :: Source (ResourceT IO) ByteString -> IO ByteString
22:01:20 <applicative> jamil_1: I'm not sure it will take you that far, but this is quite readable http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/origami.pdf
22:01:32 <applicative> you learn how to fold and unfold the natural numbers!
22:01:51 <applicative> jamil_1: the natural numbers are type Nat = Fix Maybe
22:03:09 <otters> will there be a point at which cabal update will only download changes, not the whole package db?
22:03:53 <tgeeky> otters: exactly when there are no changes
22:04:07 <otters> huh?
22:04:30 <tgeeky> otters: no. i was saying, it will download 0 changes when there are 0, and the whole thing otherwise
22:04:40 <otters> will it support doing that in future?
22:05:03 <tgeeky> otters: I'd wager no unless you submit a patch and/or bug report. cabal's issues page might be on github -- check there
22:05:21 <applicative> jamil_1_: the type of foldNat is Nat -> (a -> a) -> a -> a , i.e. it takes a Nat to its church encoding.  This is contained in the definition of fold you gave
22:05:36 <Ralith> NemesisD: there should be a standard along the lines of Source m a -> m [a]
22:05:39 <Ralith> NemesisD: 'drain' maybe?
22:05:42 <Ralith> been a while
22:05:49 <Ralith> then just mconcat it
22:06:02 <NemesisD> ah ok
22:06:11 <Ralith> a standard combinator*
22:07:24 <applicative> jamil_1_: sorry,i'm flooding you with material, I'm still not sure I have the most efficient intro
22:09:35 <NemesisD> Ralith: ah. i think its consume: Monad m => Consumer a m [a], not sure what you do with Consumers though
22:09:50 <NemesisD> ah its a type alias
22:48:48 <lightquake> how did IO programming in haskell work before the io monad?
22:49:37 <typoclass> lightquake: not?
22:50:32 <typoclass> lightquake: you had to write programs like "main :: [Request] -> [Response]" or some such
22:52:52 <lightquake> huh
23:02:06 <djahandarie> lightquake, http://www.haskell.org/definition/haskell-report-1.2.ps.gz
23:02:42 <djahandarie> http://r6.ca/blog/20110520T220201Z.html is a useful read.
23:07:49 <arkeet> also the top answer http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with
23:26:25 <argiopeweb> It appears I need a little guidance. I'm using attoparsec-conduit to parse a very large file (~20GB). My parser works beautifully, but I can't find the best way to repeatedly apply it. Recursive parser leaves me without liftIO, the "many" family of combinators just eats memory.
23:30:23 <AfC> Is there a -fno-warn-about... flag to suppress "Module `Prelude' does not export `catch'"?
23:30:35 <hpaste> “Anonymous Coward” pasted “2x2 array exception” at http://hpaste.org/86226
23:31:08 <prkchp_sndwch> that would be me... never have used hpaste before...
23:31:36 <prkchp_sndwch> anyway, I'm having some trouble creating a basic 2x2 dimensional array. does anybody know what I'm doing wrong in that paste?
23:36:50 * BMeph_ restrains himself from unhelpfully responding: "it"
23:41:22 <hpaste> BMeph annotated “2x2 array exception” with “2x2 array exception (now, unacceptional)” at http://hpaste.org/86226#a86227
23:42:52 <BMeph_> prkchp_sndwch: Speciafically, the first argument is (low_bound, high_bound), not (ranges_of_some_bound, range_of_more_bounds). :)
23:43:58 <prkchp_sndwch> I realize now I mean 2 dimesional array of 4x4 values, not 2x2 array.
23:44:31 <prkchp_sndwch> BMeph_, I'm still confused why your change replaced the first (1,4) with (1,1)
23:45:08 <prkchp_sndwch> also, the new change still gives the same array *** Exception: Error in array index
23:48:30 <BMeph_> prkchp_sndwch: The second member of the pairs in your list are the elements. If you want 4x4 values, then those have to be 4x4 values.
23:49:16 <BMeph_> prkchp_sndwch: So, what are the bounds on your two dimensions?
23:50:51 <prkchp_sndwch> BMeph_, 1 through 4 and 1 through 4
23:51:23 <prkchp_sndwch> all having values of 1, just trying my hands at some basic array construction before I try more complex tasks
23:54:57 <lightquake> i feel like making something neat with pipes but i'm not sure what i'd make
23:55:38 <Mortchek> Write an indoor plumbing library
23:57:09 <coburrito> Ah. Haskellers... so many solutions in want of problems.
23:58:05 <lightquake> coburrito: :P
