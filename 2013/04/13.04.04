00:02:28 <finishingmove> guys
00:02:30 <finishingmove> anyone on windows?
00:02:54 <RayNbow`TU> Win7 x64 here
00:03:03 <finishingmove> What IDE do you use?
00:03:24 <finishingmove> (or editor)
00:03:25 <RayNbow`TU> for Haskell I actually use Notepad... :p
00:03:44 <RayNbow`TU> but then again, I haven't really done large projects in Haskell
00:03:45 <finishingmove> And how do you handle your indentations? Manually or do you have a plugin?
00:04:17 <RayNbow`TU> in case of Haskell, I just do it manually by pressing the spacebar enough times
00:04:41 <finishingmove> that's tedious
00:04:42 <RayNbow`TU> for other languages I'm using Eclipse
00:04:56 <RayNbow`TU> (I still have to try out the Haskell plugin for Eclipse)
00:12:08 <elliott> you generally don't get indentation as deep as in most languages in haskell.
00:12:14 <elliott> so I find pressing the spacebar to be less annoying than you'd expect
00:12:28 <elliott> (and the subtleties of haskell indentation mean that automation can make it take *more* effort.)
00:17:59 <opqdonut> emacs is pretty good with automatic indentation
00:24:46 <osfameron> spacebar?  I use the <TAB> key (though it emits spaces)
00:35:02 <kurkale6ka> Hi, why is this (++) <$> Just "johntra" resulting in Just ("johntra"++) and not Just (++"johntra")
00:35:25 <kurkale6ka> What's the rule
00:35:59 <latermuse> what does the 'c' stand for in the lens type: lens :: (c -> a) -> (c -> a -> c) -> Lens' c a
00:36:09 <latermuse> is it just an ambiguous type like 'a'?
00:36:36 <edwardk> probably 'container' or something
00:36:40 <edwardk> :info lens
00:36:47 <edwardk> @ty lens
00:36:49 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
00:36:58 <edwardk> its usually written that way
00:37:31 <edwardk> kurkale6ka: (++) a b = (a ++ b)
00:37:58 <edwardk> (++) <$> Just "johntra" =  Just ((++) "johntra") = Just ("johntra"++)
00:38:32 <luite_> i copied all three folds to a more permanent location http://hdiff.luite.com/reduce/
00:39:07 <kurkale6ka> edwardk: I get it, thx
01:05:07 <Scabe> How would I implement a function which uses this profile:
01:05:25 <Scabe> maybe_divide :: Maybe Integer -> Maybe Integer -> Maybe Integer
01:05:49 <Scabe> and then responds  >maybe_divide (Just 5)(Just 2)
01:05:51 <Scabe> Just 5
01:05:54 <Scabe> I mean Just 2
01:06:42 <Scabe> >maybe_divide Nothing (Just 1) = Nothing
01:08:21 <mauke> liftA2
01:09:09 <mikeplus64> (or liftM2, but they're identical)
01:09:28 <mikeplus64> you can also explicitly pattern match; maybe_divide (Just x) (Just y) = Just (x / y); maybe_divide _ _ = Nothing
01:11:14 <amatsu> Is there any way to map across a list of lists into one list, without using (++)?
01:11:31 <mikeplus64> concatMap?
01:12:20 <amatsu> mikeplus64: concatMap uses (++) internally.
01:12:48 <mikeplus64> @src (++)
01:12:48 <lambdabot> []     ++ ys = ys
01:12:48 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:12:48 <lambdabot> -- OR
01:12:48 <lambdabot> xs ++ ys = foldr (:) ys xs
01:12:50 <amatsu> I guess as long as I don't strictly evaluate everything the repeated (++) calls shouldn't have a huge impact on performance..
01:13:10 <amatsu> oh!
01:13:45 <mikeplus64> because of list fusion you might be lucky and the ++ calls fused together when you compile with -O2
01:14:22 <amatsu> mikeplus64: Alright then, I'll give it a shot, thanks!
01:14:35 <quchen> amatsu: (++) is only bad if you parenthesize it the wrong way.
01:14:48 <quchen> There's nothing wrong with "concat" just because it uses (++).
01:15:12 <mikeplus64> maybe compile with -ddump-rules-fired or similar, although iirc the rule names are kind of unhelpful
01:15:46 <quchen> mikeplus64: There's only a handful of rules in Data.List, so if you know the name they're not hard to search for
01:16:20 <mikeplus64> yeah, but it would still be nice if they were a bit less cryptically named
01:18:09 <quchen> Oh, nevermind, there are no fusion rules in Data.List.
01:18:16 <quchen> GHC.Base then? :s
01:18:22 <mikeplus64> i suppose
01:19:24 <quchen> forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys
01:19:31 <quchen> Wonderful! ++ gone.
01:19:37 <quchen> (The rule is named "++".)
01:36:34 <ana_> hi
01:38:19 <ana_> can some one tell me how i can load one of this funktions? i.e. fun1 ? http://nopaste.me/paste/490163254515d3ba8616f6  , i always get  " not in scope" its a example of a friend
01:39:54 <mauke> ana_: what are you doing and what's the error message?
01:41:32 <quchen> ana_: It may help to format your code so lines aren't longer than 80 characters. I can't read what you've pasted.
01:41:46 <ana_> i just want to load "fun1" i.e. with " fun1 "hello"  , error is  always  somethink like this http://nopaste.me/paste/737869081515d3c9d0ee8f
01:42:25 <quchen> You can use "let" in GHCi to define things. 'let fun1 "hello" = "world"'
01:44:35 <mauke> ana_: ok, but what did you do before that?
01:45:28 <ana_> oh , i need to learn some basics in hascell, this is e example code, i just need to get the code run, the code is correkt
01:45:51 <ana_> let sems to be fine, now he get the function,, but no putput
01:45:55 <ana_> *output
01:46:17 * hackagebot raw-strings-qq 1.0 - Raw string literals for Haskell.  http://hackage.haskell.org/package/raw-strings-qq-1.0 (MikhailGlushenkov)
01:46:18 <quchen> "let" defines the function. You can use it afterwards.
01:46:25 <quchen>  let foo = 2
01:46:27 <quchen>  foo
01:46:29 <quchen>  >>> 2
01:49:53 <ana_> quchen:  maybe this helps ? http://nopaste.me/paste/751054525515d3e9300cfb
01:50:48 <quchen> fun1 is a function.
01:51:00 <quchen> When you type in "fun1" only, GHCi tries to display it.
01:51:15 <quchen> However, there's no way of displaying a function, and that's where the error comes from.
01:51:29 <quchen> What you *can* display are that function's values.
01:51:51 <quchen> i.e. type in 'fun1 "hello"'
01:51:59 <quchen> (Or whatever you've defined fun1 with)
01:53:11 <hpaste> quchen pasted “Basic GHCi usage” at http://hpaste.org/85149
01:53:15 <quchen> ^ Like this.
01:53:37 <swi> Hello everyone :)
01:53:44 <quchen> Morning :-)
01:54:05 <swi> i have a trouble understanding applicatives. Can someone help me ?
01:54:12 <quchen> Yes.
01:55:47 <swi> thanks :) i.e. a fmap (or <$>). As i understand fmap is like mpa (well map just a fmap only for lists). So how can i use fmap to apply some function to some list ?
01:56:13 <ramses_> > (+1) <$> [1..10]
01:56:14 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
01:56:15 <quchen> fmap doesn't need Applicative. fmap is from Functor.
01:56:20 * hackagebot raw-strings-qq 1.0.1 - Raw string literals for Haskell.  http://hackage.haskell.org/package/raw-strings-qq-1.0.1 (MikhailGlushenkov)
01:56:22 <mauke> swi: fmap someFunction someList
01:56:24 <quchen> Applicatives are an extension of Functor.
01:57:31 <quchen> swi: For lists, fmap isn't "like" map, fmap *is* map. :-)
01:58:10 <swi> quchen: seems like i confuse abotu that functor/applicatives/monoids at all :D
01:58:31 <quchen> You probably meant "monads" there, not "monoids" :P
01:58:31 <mauke> I love monoids
01:58:40 <ramses_> swi: applicatives are defined by "pure" and "<*>"
01:58:41 <quchen> MAUKE, WHY? TELL US!
01:58:43 <quchen> :-)
01:58:53 <swi> quchen: monads, yes
01:59:09 <mauke> quchen: they're so easy
01:59:10 <ramses_> swi: LYAH explains those three pretty well imho
01:59:14 <ramses_> @where lyah
01:59:15 <lambdabot> http://www.learnyouahaskell.com/
01:59:46 <swi> ramses_: in fact i just end reading LYAH yesterday :(
01:59:51 <quchen> It explains everything well except Reader :s
02:00:42 <ramses_> swi: then maybe you should read the chapter on applicatives again, I had to read it a couple of times before everything really sank in
02:01:02 <swi> as i'v read lyah i remeber that fmap, but cant understand it's using with <*>
02:01:17 <ramses_> swi: they're quite easy once you get them, but they are pretty strange until then
02:01:52 <swi> ramses_: seems like it. this book is written so nice that you read and think 'wow, i catch it!", but a few pages left and you find yourself in 'wtf?' situation :)
02:02:08 <Eduard_Munteanu> That's normal.
02:02:16 <mauke> > [filter isLower, map toUpper] <*> ["Hi", "World"]
02:02:19 <lambdabot>   ["i","orld","HI","WORLD"]
02:02:34 <ramses_> swi: really, just give that chapter another read, it will give a more cohesive explanation then you'll get here, I think
02:02:51 <ramses_> s/then/than
02:04:23 <swi> mauke: oh that it! it' confused me alot about the fact thet :t for <$> and <*> is the same
02:04:35 <swi> well.. allmost
02:04:45 <b_jonas> :t <$>
02:04:46 <lambdabot> parse error on input `<$>'
02:04:53 <Eduard_Munteanu> You mean fmap and (<$>)?
02:04:54 <quchen> swi: That "almost" is crucial :-)
02:04:54 <b_jonas> :t (<$>)
02:04:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:04:58 <b_jonas> :t (<*>)
02:05:00 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:05:02 <b_jonas> they're no way the same
02:05:21 <ramses_> their f isn't even the same thing
02:06:27 <swi> ramses_: type description sometimes so informative for me
02:06:55 <ramses_> swi: I have trouble parsing that sentence...
02:07:16 <swi> uninformative*
02:07:33 <ramses_> that makes more sense :) You'll get used to it
02:07:52 <quchen> swi: What Functors, Applicatives and Monads *are* are structures that share some common properties. These structures can be found in many places, hence Functors, Applicatives and Monads can do many different things. The main thing when learning them is recognizing those patterns.
02:08:28 <swi> so i need to read this chapter again and again
02:08:31 <quchen> I just played around with Maybe and friends for a couple of months. Spoiler: it becomes crystal clear after a while :-)
02:08:45 <mauke> swi: nah, just start using them somewhere
02:09:10 <mauke> > div 5 2
02:09:12 <lambdabot>   2
02:09:19 <ramses_> swi: at the same time play with them, just reading over and over wont help..
02:09:20 <mauke> > div <$> Just 5 <*> Just 2
02:09:22 <lambdabot>   Just 2
02:09:37 <mauke> > div <$> [5, 10, 7] <*> [2, 3]
02:09:39 <lambdabot>   [2,1,5,3,3,2]
02:09:40 <swi> mauke: i can't figure out where (exclude some artificial examples)
02:10:09 <swi> > div <$> [5,10,7] <* [2,3]
02:10:11 <lambdabot>   *Exception: showList: No overloading for function
02:10:16 <swi> :D
02:10:22 <mauke> :t div <$> [5,10,7] <* [2,3]
02:10:23 <lambdabot> Integral a => [a -> a]
02:10:29 <mauke> a list of functions
02:11:10 <mauke> > sequence (div <$> [5,10,7] <* [2,3]) 100
02:11:12 <lambdabot>   [0,0,0,0,0,0]
02:11:13 <quchen> I don't like list much as an example Applicative. I'd recommend using Maybe.
02:11:15 <ramses_> swi: I learned the most about using applicatives from writing a parser for a simple language using only applicative operators, no monadic ones. But that may be a little much, depending on your background
02:11:18 <mauke> > sequence (div <$> [5,10,7] <* [2,3]) 2
02:11:20 <lambdabot>   [2,2,5,5,3,3]
02:11:38 * Kinnison doesn't quite see what <* is doing there
02:11:50 <mauke> > [5, 10, 7] <* [2,3]
02:11:51 <lambdabot>   [5,5,10,10,7,7]
02:12:17 <ramses_> Kinnison: it repeats every operation n times, with n the lenght of the list to its right. Its elements don't matter
02:12:23 <mauke> > [ x | x <- [5, 10, 7], _ <- [2, 3] ]
02:12:24 <lambdabot>   [5,5,10,10,7,7]
02:12:28 <mauke> ^
02:12:30 * Kinnison sees
02:13:01 <ramses_> Kinnison: it looks at the effects (number of results in the list) but not the values
02:13:06 <swi> all thoses <* << >> =<< just scare
02:13:10 <quchen> Kinnison: *> is >>: Execute first action, discard result, execute second action. <* is the other way round: execute first action (retain result), execute second action and discard its result.
02:13:27 <Kinnison> quchen: aah, neato, I get it now
02:14:14 <swi> ramses_: my background is heavily attached to operation with DB and processing data from them
02:15:34 <quchen> Kinnison: In monadic terms, "m << f = do { x <- m; f; return x }"
02:15:45 <quchen> (<< doesn't actually exist)
02:16:13 <swi> :t (>>)
02:16:15 <lambdabot> Monad m => m a -> m b -> m b
02:16:18 <mauke> select functions.f(args.x) from functions cross join args
02:16:25 <ramses_> it would just be "m << f = do { m; f }", I guess
02:16:34 <ramses_> s/<</>>
02:17:07 <ramses_> ah, wait, I'm being confused!
02:17:15 * swi remember that >> is just like do block (like pipe in linux)
02:17:29 <Kinnison> I thought >>= was more like pipe
02:17:30 * ramses_ goes off to get more coffee
02:17:39 <swi> damn
02:17:39 <quchen> swi: Don't jump to >> and monads yet. You're working on Applicative first. :-P
02:17:51 <Kinnison> quchen: Seems to me that << would be a potentially interesting thing to have :-)
02:17:56 <swi> quchen: seems like i need to work at functor first :D
02:18:08 <Kinnison> swi: Aye, build carefully, functor, applicative, (monoid?), monad
02:18:10 <ramses_> Kinnison: <* is just as good ;)
02:18:13 <quchen> The hierarchy is Functor -> Applicative -> Monad.
02:18:19 <mauke> monoid is not part of the same track
02:18:20 * Kinnison jumped to monad too early and is only now starting to get the underlying stuff
02:18:24 <Kinnison> mauke: ta, I wasn't sure
02:18:26 <Kinnison> ramses_: I guess so
02:18:32 <mauke> monoids are much simpler
02:18:51 <mauke> even easier than Num
02:18:59 <swi> mauke: what is that select functions.f(args.x) from functions cross join args ?
02:19:00 <quchen> Monoids were "why is this even there" simple when I read about them first :-)
02:19:18 <mauke> swi: pseudo-SQL
02:19:34 <swi> mauke: surely pseudo :)
02:19:42 <mauke> quchen: you know about Data.Default, right? :-)
02:19:52 <swi> looks like a some orm
02:19:57 <quchen> mauke: No
02:20:06 <mauke> @hackage data-default
02:20:06 <lambdabot> http://hackage.haskell.org/package/data-default
02:20:50 <quchen> swi: So here's something to practice on: You've got a list [1,2,3,4,5]. Make this into [("hello", 1), ("hello", 2), ...] using fmap.
02:21:24 <quchen> mauke: Okay, well that's ummm
02:21:32 <swi> quchen: hm.. interesting :
02:21:34 <quchen> Why is this even there :D
02:21:35 <Lethalman> about Default... why def instead of default? :S
02:21:43 <mauke> Lethalman: 'default' is a keyword
02:21:50 <Lethalman> ah
02:22:15 <mauke> quchen: have you ever written a no-op exception handler?
02:22:20 <Lethalman> good to know, just read about default
02:22:27 <mauke> something like ... `catch` \_ -> return ()
02:22:35 <quchen> mauke: I.e. a catchall?
02:22:40 <mauke> yeah
02:22:48 <Taneb>  Aren't catchalls bad ideas?
02:22:48 <quchen> Yes
02:22:49 <swi> > fmap (\x->("hello",x)) [1,2,3,4,5]
02:22:51 <lambdabot>   [("hello",1),("hello",2),("hello",3),("hello",4),("hello",5)]
02:22:54 <quchen> Taneb: Depends.
02:22:57 <quchen> swi: Nice!
02:23:03 <mauke> quchen: ... `catch` def
02:23:13 <swi> quchen: but i think lambda is not the nicest way :)
02:23:25 <FireFly> So then remove it :p
02:23:33 <mauke> quchen: that's a triple combo using the Default instances of (), IO, and (e ->)
02:23:43 <FireFly> Hm
02:23:59 <quchen> mauke: oooookayyy
02:24:04 <quchen> mauke: Processing ...
02:24:26 <supki> I write these handlers as `mplus` return ()
02:24:41 <mauke> quchen: what's also fairly common is that you have a config record
02:24:50 <quchen> mauke: My Catchall was more complicated, I can tell you that :-D
02:25:26 <mauke> Config{ extraFields = [], caseInsensitive = False, sortOrder = Ascending, ... } or something like that
02:26:24 <mauke> and because users don't want to type out all fields manually, the library provides a default config that can be adapted
02:26:32 <swi> FireFly: hard to figure it out. fmap apply f to elem of list. but how can i apply tuple?
02:26:42 <mauke> defaultConfig{ sortOrder = Descending }  -- everything else is defaults
02:26:47 <ramses_> @ty (,) -- swi
02:26:48 <lambdabot> a -> b -> (a, b)
02:27:13 <quchen> Makes sense. So how does "`catch` def" work? def = function, so it's `catch` const def. This def is now IO, whose default is presumably "return def", and now def becomes ()?
02:27:19 <ramses_> > (,) "hello" 4
02:27:21 <lambdabot>   ("hello",4)
02:27:40 <ramses_> swi: ^ that should get you started
02:28:17 <mauke> quchen: yes, but I was cheating
02:28:33 <swi> :t (,)
02:28:34 <lambdabot> a -> b -> (a, b)
02:28:40 <mauke> quchen: it doesn't work as written with the current Control.Exception.catch (you need more type information)
02:28:47 <swi> damn.. all is function! damn! stupid me
02:28:49 <quchen> mauke: Why isn't there a Monad version instance for Default? Seems odd that only IO has a def instance
02:29:04 <quchen> mauke: Hm. Well it's certainly useful to know in any case.
02:29:20 <FireFly> > ("hello",) 4  -- why does this require an extension though? it seems like it'd be unambiguous to me
02:29:22 <lambdabot>   Illegal tuple section: use -XTupleSections
02:29:32 <swi> > fmap ((,) "hello") [1..5]
02:29:33 <lambdabot>   [("hello",1),("hello",2),("hello",3),("hello",4),("hello",5)]
02:29:40 <quchen> FireFly: It's unambiguous, but not part of the standard.
02:29:42 <mauke> quchen: works with catchIOError, though
02:29:49 <FireFly> quchen: ah
02:29:56 <mauke> quchen: Monad is another class, not a type. I can't make it an instance
02:30:07 <quchen> mauke: What's the difference between "IO errors" and normal thrown exceptions by the way?
02:30:15 <mauke> and Haskell doesn't let you say: "use this instance for any type that is also an instance of this other class"
02:30:18 <swi> and i allmost forgot that tuple in haskell not the same as in python :\
02:30:34 <mauke> quchen: IO errors are this specific type: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#t:IOException
02:30:42 <mauke> quchen: other exceptions are other types
02:31:06 <mauke> some examples on the same page
02:31:32 <quchen> Oh, right.
02:32:04 <quchen> My confusion came from somewhere else I think: why is there throw and throwIO
02:32:33 <swi> quchen:  ramses_ thanks a lot :) Going to read that chapter from lyah again and play around a bit :)
02:33:30 <quchen> swi: You've got a 'Just (1,"hello")'. Make this 'Just ("hello",1)' using fmap
02:33:36 <ramses_> swi: np, don't hesitate to come back here if you've got more questions
02:42:01 <xpika> is there a winghci for OSX?
02:42:24 <quchen> The terminal? :s
02:44:24 <xpika> quchen: is there a terminal i can get where i can highlight and then replace the text ive clicked on?
02:45:44 <quchen> Not that I know of
02:46:08 <quchen> But all I've ever used is gnome-terminal, so I'm not the right guy to ask
02:47:19 <typoclass> xpika: you can always hit the cursor up key, which will fetch lines that you earlier entered. you can then edit them. also, try hitting tab after you entered half of a function name, e.g. "conc" + tab should complete it to "concat"
02:48:33 <quchen> typoclass, xpika: You can even use Bash keys in GHCi. Hit Ctrl+R :-D
02:50:35 <Kneiva> xpika: I use a text editor to modify code and then I just load that file in ghci (eg. :load mytest.hs). And having them both open, it's pretty easy to jump between them.
02:52:36 <mauke> quchen: throw is like error in that it constructs a "value" of an arbitrary type that throws an exception when evaluated
02:52:40 <Kneiva> and ":reload" or ":r" to refresh that file
02:53:08 <mauke> quchen: throwIO is an IO command for throwing an exception
02:55:23 <quchen> mauke: Oh, so I can see "throwIO" like a "Nothing".
02:55:42 <quchen> I can bind it to a variable and it doesn't hurt, but when I perform it it'll crash
02:55:58 <quchen> With that in mind, it's lunch time. :-)
02:58:34 <blueonyx> hi, how can i use pattern guard syntax, when i cant extract data via pattern matching (because of abstract data type)?
02:59:10 <Cale> blueonyx: Well, pattern guards let you match on the result of applying a function.
02:59:30 <blueonyx> my terminology is probably bad here
02:59:57 <typoclass> blueonyx: do you have an example? (please use hpaste if the code is > 1 line)
03:00:00 <typoclass> @where hpaste
03:00:00 <lambdabot> http://hpaste.org/
03:00:12 <Cale> So, you can apply a function to the value of your abstract data type which produces a result which is possible to pattern match on, hopefully
03:00:37 <hpaste> blueonyx pasted “rewrite for abstract data type” at http://hpaste.org/85154
03:02:19 <blueonyx> typoclass, Cale: i tried a where clause for all | guards, which failed :/
03:03:12 <Cale> Where's the pattern guard here?
03:03:24 <blueonyx> -pattern then?
03:03:35 <blueonyx> whats the pipe called?
03:03:41 <Cale> oh, that's just a guard
03:03:46 <blueonyx> yea sry
03:03:46 <typoclass> blueonyx: ah :-) yeah, it's called just 'guard' here. a pattern guard is another thing
03:03:49 <Cale> You're just using a normal guard :)
03:04:11 <Cale> So, what's the problem with this code?
03:04:13 <blueonyx> my problem is then about "pattern matching" and "guards" k
03:04:19 <Cale> sc can't be compared with 304?
03:04:22 <hamid> haha implementing a stream in strict lanauages like c++ doesn't mean anything at all! i did implemented that and remembered that I don't have lazy evalution. what can i do? :)) it was just a mess.
03:04:51 <blueonyx> Cale: the H.Response is no longer exported, so i have to use record syntax (responseStatus)
03:04:54 <typoclass> blueonyx: by the way, i think in this particular case, you can put the 304 directly in line 1 (HT.Status 304 sm)
03:05:01 <Cale> hamid: Easy! Just implement lazy evaluation. ;)
03:05:13 <notdan> I don't know, I've implemented streams in Scheme a while ago
03:05:20 <notdan> but I bet it's messier in C++
03:05:53 <Cale> blueonyx: aha, then your answer really is to use pattern guards!
03:05:56 <hamid> Cale, it just doesn't feel right :D
03:06:17 <aCube> Streams don't need a lazy language, do they? They're just a step function and a value, aren't they?
03:06:38 <hamid> aCube, streams are infinits.
03:06:49 <hamid> that's the point. how can i use them :P
03:08:10 <hpaste> Cale annotated “rewrite for abstract data type” with “rewrite for abstract data type (annotation)” at http://hpaste.org/85154#a85155
03:08:20 <Cale> blueonyx: ^^
03:08:45 <Cale> blueonyx: That'll work if you stick {-# LANGUAGE PatternGuards #-} at the top of your file
03:09:15 <Cale> blueonyx: you could also just awkwardly use case to match, but the fall-through can be really nice
03:10:08 <blueonyx> Cale: yea thanks, but i have forgotten more lines where i test sc, so i need to repeat the pattern guard to extract the status?
03:10:16 <swi> quchen: em.. if i use swap from Data.Tuple it is ok ? :)
03:10:20 <blueonyx> Cale: how about the case to match?
03:11:13 <hpaste> typoclass annotated “rewrite for abstract data type” with “rewrite for abstract data type (annotation)” at http://hpaste.org/85154#a85156
03:11:21 <typoclass> blueonyx: how about this? ^^
03:11:56 <blueonyx> typoclass: still error: no data constructor H.Response :)
03:12:06 <blueonyx> Cale: thanks, found http://www.haskell.org/haskellwiki/Case#Guards
03:12:12 <blueonyx> typoclass: thanks anyhow
03:12:15 <hpaste> Cale annotated “rewrite for abstract data type” with “rewrite for abstract data type (annotation) (annotation)” at http://hpaste.org/85154#a85157
03:13:44 <swi> > fmap (Just . swap) Just (1,"hello")
03:13:45 <lambdabot>   Couldn't match expected type `(a0, b0)'
03:13:46 <lambdabot>              with actual type `Data...
03:14:01 <hpaste> typoclass annotated “rewrite for abstract data type” with “rewrite for abstract data type (annotation) (annotation) (annotation)” at http://hpaste.org/85154#a85158
03:14:30 <swi> > fmap (Just . swap) (Just (1,"hello"))
03:14:32 <lambdabot>   Just (Just ("hello",1))
03:14:49 <blueonyx> Cale: ah thats even better, thanks :)
03:15:09 <typoclass> blueonyx: ok, another suggestion ^^. a view pattern (... -> ...) will take an argument, apply apply the left side of the "->" to it, then pattern-match with the right side
03:18:12 <Cale> I'm not sure whether I really believe in view patterns
03:18:34 <Cale> I've yet to see them used to actually improve a real piece of code in the wild.
03:18:46 <blueonyx> dito
03:19:14 <Cale> Pattern guards on the other hand, have saved me a lot of trouble in some circumstances
03:20:34 <Cale> They're especially nice in the case that you're doing some type hackery, and using GADTs to carry around evidence that certain types are equal. Pattern guards nicely let you artificially pattern match on things to unpack the type equality constraints you need.
03:20:55 <Eduard_Munteanu> Cale: I found view patterns nice for "pattern-matching" on Seqs
03:21:22 <Cale> Eduard_Munteanu: Oh, you're right, that is nice
03:27:28 <typoclass> Cale: i've found view patterns cool when you get an argument and use it only once, e.g. passing it to splitAt. a bit heavy on parens, but i hope this example makes sense: "sort' (p:(partition (< p) -> (lesser, greater))) = sort' lesser ++ [p] ++ sort' greater"
03:27:45 <typoclass> ... and you're right, i need to look at pattern guards. i've barely ever seen them :-)
03:28:22 <mauke> map _ [] = []; map f ((f -> x) : (map f -> xs)) = x : xs
03:29:36 <typoclass> mauke: er, that doesn't seem to help :-)
03:29:40 <typoclass> mauke: but it's cute
03:31:20 * hackagebot hmemdb 0.2.0.1 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.2.0.1 (MiguelMitrofanov)
03:32:30 <typoclass> quicksort example with pattern guards (i hope that's correct): "sort' (p:xs) | (lesser, greater) <- partition (< p) xs = sort' lesser ++ [p] ++ sort' greater". the difference is, view patterns let you omit the argument name (xs). this is handy if you use it only once anyway. it reduces name clutter
03:32:32 <mm_freak_> snoyberg: hi there…  is it possible/feasible to write an HTTP proxy with WAI?
03:36:19 <Spockz> A while back I looked at HLint and saw that it had some extra Hint files that contained a lot of extra rules. Now I only see Dollar.hs and Generalise.hs and both contain only one rule. Where did all those extra rules go?
03:43:41 <typoclass> Cale: anyway, thank you for the discussion. i "somehow" liked view patterns, but couldn't articulate why. your doubts made me think it through :-) so thanks
03:44:18 * typoclass hopes he's making sense
03:44:22 <quchen> swi: Using swap is fine. You can also easily implement it yourself.
03:44:40 <quchen> swi: Your "Just" is too much though
03:44:51 <mauke> it's Just too much
03:45:53 <Cale> typoclass: Yeah, that makes sense, though the Data.Sequence example I think is more compelling than the partition one. I'm not sure that I like to see a lot of computation going on inside nestable patterns, at least in this form.
03:48:05 <swi> quchen: oops :)
03:48:06 <typoclass> Cale: right. it is heavy on parens, isn't it. i'm sure there's better examples that need only one level of parens
03:48:20 <swi> > fmap swap Just (1,"hello")
03:48:21 <lambdabot>   Couldn't match expected type `(a0, b0)'
03:48:21 <lambdabot>              with actual type `Data...
03:48:25 * typoclass purrs and goes look up Data.Sequence
03:48:31 <swi> > fmap (swap) Just (1,"hello")
03:48:32 <lambdabot>   Couldn't match expected type `(a0, b0)'
03:48:33 <lambdabot>              with actual type `Data...
03:48:35 <Cale> typoclass: That example also isn't bad as a pattern guard
03:48:50 <swi> ouch
03:48:55 <swi> > fmap (swap) (Just (1,"hello"))
03:48:57 <lambdabot>   Just ("hello",1)
03:49:32 <Cale> sort (x:xs) | (lesser, greater) <- partition (< x) xs  = sort lesser ++ [x] ++ sort greater
03:50:00 <typoclass> Cale: yup, but that requires the xs name, doesn't it. i'd say the point of view patterns is to reduce clutter from intermediate names
03:52:34 <snoyberg> mm_freak_: i think so, i've certainly written a reverse proxy, and erik's been working on a normal proxy
03:57:26 <quchen> swi: Well done.
03:58:14 <quchen> swi: Now think about how to fmap a "Just 1" to "Nothing".
03:58:38 <swi> quchen: oops. For what it maybe need ?
03:58:41 <swi> may be*
03:58:42 <quchen> Spoiler: it's a loaded question. :-)
04:00:44 <mjga> I wonder how to make elegant handling of long list of results that may be Either errors or parse results. It works as long, as I try not to print out errors before processing rest of output: Data.Either.partitionEithers gives stack overflow, because there are so many more correct results (few gigabytes) than errors. Any hints how to avoid this issue?
04:00:56 <swi> > fmap (\x->Nothing) Just 1
04:00:58 <lambdabot>   Nothing
04:01:31 <quchen> There's parentheses missing around "Just 1".
04:01:46 <quchen> What you wrote is "(fmap (\x -> Nothing) Just) 1"
04:02:27 <quchen> > fmap (\x -> Nothing) (Just 1) -- beeeeep
04:02:29 <lambdabot>   Just Nothing
04:02:53 <swi> aah.. i forgot context :)
04:03:57 <quchen> The point is that you can't map a "Just something" to a "Nothing". Can you think of why that would be?
04:04:19 <quchen> (It holds in general that you can't change the structure of a Functor using fmap, not just in case of Maybe)
04:04:50 <quchen> In other words, a Functor/fmap *never* changes the context
04:07:18 <swi> quchen: hm.. but why it allow it ?
04:08:07 <quchen> Valid instances of Functor need fmap to obey the Functor laws.
04:08:31 <quchen> That's a critical point about Functors (and Applicative etc.): implementations don't only have to have the right type signature, but also obey some laws.
04:08:48 <quchen> In the Functor case, those laws are "fmap id = id" and "fmap (f.g) = fmap f . fmap g".
04:09:24 <quchen> With that in mind, the question still stands :-)
04:09:48 <swi> i dont sure i understand question :(
04:10:38 <quchen> Oh, I just noticed that LYAH talks about functors twice, maybe you're not in the second part yet. That's where the Functor laws are mentioned.
04:11:31 <swi> i remember functors law
04:11:42 <quchen> Oh. Well then - no excuses! ;-D
04:11:44 <swi> i dont understand question (perhaps my bad english)
04:11:48 <quchen> Oh.
04:12:05 <quchen> "Why can't you fmap a Just value to a Nothing value"
04:12:18 <quchen> i.e. why is there no function f to do
04:12:19 <swi> cause it change context
04:12:27 <quchen> fmap f (Just 1) == Nothing
04:12:39 <b_jonas> you use (>>=) to do that
04:12:51 <quchen> b_jonas: We don't have monads yet.
04:13:27 <quchen> swi: That fact is encoded in the functor laws. Can you find it?
04:14:24 <swi> quchen: you mean 2nd law about fmap (f . g) = fmap f . fmap g ?
04:15:03 <quchen> No. Suppose fmap can change Justs to Nothings, that law doesn't say much about that.
04:15:19 <quchen> if fmap f can do Just -> Nothing, why shouldn't fmap (f.g) be able to
04:15:28 <quchen> It's the first law, fmap id = id.
04:15:53 <quchen> id x = x, so id doesn't change the context (it changes nothing at all).
04:16:13 <swi> > fmap id Just 1
04:16:14 <lambdabot>   Just 1
04:16:15 <quchen> But then "fmap id" doesn't change context as well, as stated by the law
04:16:22 <quchen> Parentheses!
04:16:24 <swi> > id Just 1
04:16:26 <lambdabot>   Just 1
04:16:26 <quchen> > fmap id (Just 1)
04:16:28 <lambdabot>   Just 1
04:16:52 <aCube> > fmap (+3) Just 1
04:16:53 <swi> isnt it the same in this example?
04:16:54 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
04:16:54 <lambdabot>    arising from a use o...
04:16:59 <aCube> > fmap (+3) (Just 1)
04:17:01 <lambdabot>   Just 4
04:17:01 <quchen> fmap id Just 1 = (fmap id Just) 1. That's something completely different.
04:17:07 <swi> think i lost something
04:17:09 <quchen> It's coincidence the two have the same result.
04:17:24 <aCube> fmap fromJust Just 3
04:17:25 <aCube> > fmap fromJust Just 3
04:17:27 <lambdabot>   3
04:17:53 <swi> > fromJust Just 3
04:17:54 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (t0 -> t1)'
04:17:54 <lambdabot>              wit...
04:18:04 <quchen> aCube: That's not the Maybe, but the function instance of Functor you're using there.
04:18:11 <aCube> quchen: I know :D
04:18:16 <int-e> right. fmap = (.) there
04:18:21 <aCube> > fmap (fmap (+3)) Just 3
04:18:23 <lambdabot>   Just 6
04:18:25 <aCube> :)
04:18:45 <int-e> > fmap fmap fmap (+3) Just 3
04:18:47 <lambdabot>   Just 6
04:18:49 <int-e> and so on.
04:18:58 <swi> omg
04:19:05 <quchen> swi: Just ignore that :-P
04:19:35 <swi> quchen: somewhere in lyah i saw something like mapping list of func over list of vals...
04:19:43 <swi> it's was scaare
04:20:01 <int-e> > let obfuscate = fmap in obfuscate obfuscate obfuscate (+3) Just 3 -- that's how it should be written
04:20:03 <lambdabot>   Just 6
04:20:12 <quchen> m >>= f = \r -> m (f r) r = \r -> (m . f) r r = \r -> (fmap m f) r r = \r -> fmap m f r r
04:20:15 <quchen> Much clearer now!
04:20:30 <quchen> I should've changed m to h and f to u
04:20:33 <int-e> quchen: self-documenting even :)
04:20:36 <quchen> fmap h u r r
04:20:53 <robstewartuk> Are there any rules about defining an executable in a .cabal file combing the hs-source-dirs and main-is arguments? I.e. can I say hs-source-dirs: src and main-is: Foo/Bar/Baz.hs ?
04:21:15 <robstewartuk> Or must I say: hs-source-dirs: src/Foo/Bar/ and main-is: Baz.hs ?
04:21:28 <dcoutts_> robstewartuk: easy way to find out :-) try it
04:21:36 <quchen> swi: Lists of functions are just ordinary lists in Haskell. Functions aren't special.
04:21:57 <lattenwald> > [(+3), (*2)] <*> [2 .. 5]
04:21:58 <lambdabot>   [5,6,7,8,4,6,8,10]
04:21:59 <aCube> > zipWith ($) [(+3), (+4), (+5)] [1,2,3,4]
04:21:59 <dcoutts_> robstewartuk: I think it'd probably work either way round
04:22:00 <lambdabot>   [4,6,8]
04:22:00 <lattenwald> scary?
04:22:02 <quchen> > fmap ($ 3) [(+1), (2*)]
04:22:04 <lambdabot>   [4,6]
04:22:17 <dcoutts_> robstewartuk: but I'd go for the first one
04:22:30 <swi> quchen: > [(+3),(*2)] *> [1,2]
04:22:34 <robstewartuk> Well both work, though I'm seeing a very strange behaviour with cloudhaskell executables the first way round (I'm putting a simple example together).
04:22:45 <quchen> swi: That's using Applicatives, you're not at that point yet. :-)
04:22:57 <quchen> (*> is from Applicative)
04:23:35 <swi> quchen: opps. i mean that <*> thing i was scared :)
04:24:01 <swi> doesnt it too much 'sugar' in haskell syntax ?
04:24:48 <int-e> > let (><><><>) = id in succ ><><><> 1 -- it's just infix operators
04:24:49 <lambdabot>   2
04:25:56 <swi> >  let (>=--.) = id succ >=--. 1
04:25:57 <lambdabot>   not an expression: `let (>=--.) = id succ >=--. 1'
04:26:02 <swi> :D
04:26:47 <typoclass> swi: so it's not really syntactic sugar built into the haskell language. it's just some libraries that some people wrote
04:27:34 <swi> typoclass: i know, i mean there is a lot of that infix functions and it's confuse when reading code
04:28:59 <no-n> where can I get a list of all the typeclasses?
04:29:29 <mm_freak_> snoyberg: is there any way to get the full request string with WAI?
04:29:30 <FireFly> There's something fishy with ><> ...
04:29:36 <aCube> @where typeclassopedia
04:29:36 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:29:39 <typoclass> swi: that's true :-/ it takes some getting used to
04:29:46 <snoyberg> mm_freak_: you mean path info + query string?
04:29:46 <no-n> thank you aCube
04:29:56 <int-e> FireFly: that was intended :)
04:30:07 <aCube> that's not all, only the most commonly used ones
04:30:08 <mm_freak_> snoyberg: like when someone requests "GET http://blah:1234/xxx" i particularly need "blah" and 1234
04:31:27 <typoclass> no-n: the major ones are described in typeclassopedia. i don't think there's a complete list because anyone could define some new typeclasses and put them on hackage, after all
04:31:46 <no-n> ok
04:32:18 <snoyberg> mm_freak_: serverName and serverPort
04:32:37 <mm_freak_> snoyberg: serverName works, but serverPort returns the proxy server's port, not the requested port
04:33:29 <snoyberg> mm_freak_: i think that might be a bug actually
04:33:48 <mm_freak_> oh
04:33:59 <snoyberg> mm_freak_: i take that back, the docs *do* make it clear that the current behavior is current
04:34:08 <mm_freak_> i'm using WAI 1.4.0
04:34:26 <mm_freak_> snoyberg: yes, i know
04:34:36 <mm_freak_> snoyberg: that's why i'm asking =)
04:34:38 <snoyberg> mm_freak_: i've honestly never used either serverName or serverPort in my applications, the current behavior may not be the best
04:35:05 <mm_freak_> yeah, after all you can always refer to the Settings used in runSettings
04:35:44 <mm_freak_> snoyberg: serverHost and serverPort may not even make sense in some scenarios
04:35:56 <snoyberg> i'd be open to changing that behavior, but it would have to go through a discussion on web-devel
04:36:18 <snoyberg> tbh, i'm not even sure why they're included, since they're so rarely needed
04:36:33 <mm_freak_> sure…  is there a workaround i can use for now?
04:36:36 <snoyberg> it's included in hack, that's probably where i got it from
04:36:53 <snoyberg> i don't think so, besides patching warp locally
04:37:00 <mm_freak_> hmm, ok
04:37:02 <mm_freak_> thanks
04:37:30 <mm_freak_> WAI or warp?  i think this is WAI land?
04:44:40 <osa1> is there a way to catch exceptions like "Prelude.head: empty list" ?
04:46:30 <danr> osa1: yes... but it's normally not the best practice: http://stackoverflow.com/questions/6088341/haskell-non-exhaustive-pattern-exception
04:47:03 <aCube> :t listToMaybe
04:47:04 <lambdabot> [a] -> Maybe a
04:47:07 <mapf> is it possible to find out absolute current time using only the 'base'?
04:47:07 <danr> you're probably better off using Maybe
04:47:27 <osa1> ok thanks
04:48:08 <mapf> I don't want to add dependency for time for my lib.
04:48:20 <typoclass> osa1: when you use head, it's generally recommended to think twice (or thrice). pattern matching is probably better, it gives you compiler warnings and line numbers at runtime. "case xs of (x:_) -> ... x ..."
04:48:57 <typoclass> mapf: 'time' is one of the packages like 'base'. they all come with ghc. there should be no problem with having that dependency
04:49:20 <mapf> typoclass: ok, thanks.
04:49:33 <FireFly> @source listToMaybe
04:49:34 <lambdabot> listToMaybe not available
04:49:42 <FireFly> > listToMaybe [1,2,3]
04:49:43 <lambdabot>   Just 1
04:49:46 <FireFly> ah
04:50:15 <typoclass> FireFly: it has a weird name, but it's just "a variant of head that gives you a Maybe"
04:50:39 <aCube> :t maybeToList
04:50:40 <lambdabot> Maybe a -> [a]
04:50:48 <FireFly> Yeah, I'd just call it maybeHead or something
04:50:49 <FireFly> :\
04:50:54 <supki> > [1,2,3] ^? _head
04:50:56 <lambdabot>   Just 1
04:50:57 <aCube> headMay is in Safe
04:51:06 <aCube> > [1,2,3] ^.. _head
04:51:08 <lambdabot>   [1]
04:51:09 <aCube> :D
04:51:22 <FireFly> > [] ^.. _head
04:51:24 <lambdabot>   []
04:51:25 <typoclass> aCube: somehow i think maybeToList and all those functions are subsumed by something in Data.Foldable, but i don't know
04:52:31 <aCube> > toList $ Just 3
04:52:33 <lambdabot>   Not in scope: `toList'
04:52:33 <lambdabot>  Perhaps you meant one of these:
04:52:33 <lambdabot>    `Data.Foldable.t...
04:52:38 <aCube> > Data.Foldable.toList $ Just 3
04:52:40 <lambdabot>   [3]
04:52:59 <aCube> :)
04:53:27 <typoclass> aCube: ah. less complicated than i thought :-)
04:54:04 <aCube> But I don't know of an alternative for listToMaybe
04:55:37 <typoclass> the other day i read someone saying "no you don't need function X, that's just a special case of Data.Foldable.for_". unfortunately i can't remember X but i found it nonobvious and clever
04:55:54 <supki> whenJust
04:56:15 <typoclass> supki: oh wait, that could actually have been it
04:56:18 <aCube> :t whenJust
04:56:20 <lambdabot> Not in scope: `whenJust'
04:56:26 <aCube> what's that?
04:56:29 <aCube> fmap?
04:56:38 <aCube> or maybe?
04:56:39 <aCube> :t maybe
04:56:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:56:54 <aCube> :t for_
04:56:56 <lambdabot>     Not in scope: `for_'
04:56:56 <lambdabot>     Perhaps you meant one of these:
04:56:56 <lambdabot>       `Data.Foldable.for_' (imported from Data.Foldable),
04:57:00 <aCube> :t Data.Foldable.for_
04:57:01 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
04:57:13 <supki> whenJust :: Monad m => Maybe a -> (a -> m b) -> m ()
04:57:53 <typoclass> aCube: i think this is it http://www.haskell.org/pipermail/libraries/2011-November/017255.html
04:58:27 <aCube> :t flip (maybe (return ()) )
04:58:29 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
04:58:33 <ijp> are there any known issues with bit shifting on largewords?
04:58:45 <aCube> Oh, that's the proposed implementation XD
04:58:52 <ijp> I was trying to convert a list of word128 into a list of word8 and vice versa
04:59:03 <aCube> :t Data.Foldable.forM_
04:59:05 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
04:59:16 <aCube> oh, neat :)
05:00:13 <quchen> Half of learning Haskell is finding out that your function already exists in some library
05:00:23 <quchen> The other half is "if not, then it's a combination of two" ;-)
05:00:38 <typoclass> afaict, the difference between for_ and forM_ seems to be only the constraint (Applicative vs. Monad)
05:00:48 <supki> :t iforM_
05:00:50 <lambdabot> (Monad m, FoldableWithIndex i t) => t a -> (i -> a -> m b) -> m ()
05:00:57 <aCube> :t for_
05:00:59 <lambdabot>     Not in scope: `for_'
05:00:59 <lambdabot>     Perhaps you meant one of these:
05:00:59 <lambdabot>       `Data.Foldable.for_' (imported from Data.Foldable),
05:00:59 <typoclass> quchen: true :-) but #haskell is an excellent tool for that
05:01:20 <quchen> IRC cloud bot
05:01:43 <typoclass> ok, for the first time ever, i'm damn impressed with hoogle. if you put in "Maybe a -> (a -> m b) -> m ()", it finds for_ and forM_
05:02:09 <quchen> Why is that impressive?
05:02:18 <quchen> Oh, because it finds t = Maybe
05:02:39 <aCube> @hoogle Maybe a -> (a -> m ()) -> m ()
05:02:40 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:02:40 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:02:40 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:02:41 <typoclass> quchen: yeah, because t ~ Maybe, and because i kinda expect hoogle to never find anything :-/
05:03:03 <typoclass> aCube: i was using the web thingy
05:03:12 <quchen> typoclass: I usually search by name only, but then it's a crucial tool in my workflow
05:03:34 <aCube> typoclass: oh right, it finds for_ and forM_ :)
05:04:56 <ijp> hmm, http://article.gmane.org/gmane.comp.lang.haskell.beginners/4253/ suggests there is a bug in them
05:12:06 <typoclass> aCube: it's interesting that you asked about how to write listToMaybe using Data.Foldable. i guess you'd have to have a function converting any Foldable into any other, i.e. (Foldable a, Foldable b) => a x -> b x
05:12:51 <typoclass> i bet it's not hard to write
05:13:24 <typoclass> (that function would of course subsume D.F.toList)
05:14:19 <aCube> typoclass: I think that's not possible, that would need something like "Unfoldable" I think :D
05:15:55 <ijp> okay, I've hacked around it by converting to an Integer, then shiftRing that
05:16:04 <quchen> Excellent naming issue
05:16:31 <typoclass> aCube: i think you're right. there's no general way to produce a Foldable, is there?
05:16:37 <byorgey> nope
05:16:38 <aCube> typoclass: no
05:16:50 <ijp> I don't suppose anyone knows where the bug tracker for Data.Largewords is (or if there is one?)
05:17:18 <byorgey> you could write   (Foldable a, Monoid (b x)) => (x -> b x) -> a x -> b x
05:17:20 <typoclass> ijp: often the front page for the hackage package lists a bug tracker url
05:17:56 <aCube> class Splitable a where split :: a -> (a,a); class Unfoldable f where unfold :: (Splitable s) => s -> f s ?
05:18:09 <typoclass> ijp: see here http://hackage.haskell.org/package/largeword-1.0.4
05:18:42 <ijp> yeah, I'm there now.
05:20:15 <Taneb> There is LargeWord, but is there SmallWord?
05:20:28 <Taneb> (seriously, on numerous occasions I've wanted Word4 or smaller)
05:21:59 <quchen> LargeWord has interesting instances.
05:23:36 <sopvop> So, I have something like "float x = 1, float y = x, float z = y, string baz = x;" and want to substitute all variables until none can be substituted. and like, get type errors. Do I need to implement simply typed lambda calculus or what?
05:25:07 <t7> (\x:float -> (\y:float -> ...) x) 1
05:25:13 <t7> simply typed yes
05:26:53 <sopvop> is there any example code? like library or .. calculator?
05:28:04 <dmwit> ?google write yourself a scheme haskell tutorial
05:28:07 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
05:28:07 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, open books for an open world
05:28:13 <sopvop> thanks
05:28:22 <ijp> the last thing the world needs is more schemes
05:28:23 <dmwit> Though Scheme's type system is even simpler still.
05:28:42 <aCube> > mempty <> mempty
05:28:44 <lambdabot>   ()
05:29:52 <aCube> :t mempty :: ()
05:29:53 <lambdabot> ()
05:30:05 <typoclass> apparently we have a Monoid instance for ()
05:30:31 <typoclass> > () <> ()
05:30:33 <lambdabot>   ()
05:31:05 <Kinnison> yep
05:31:05 <Kinnison> instance Monoid () -- Defined in Data.Monoid
05:31:17 <alexander__b> is there an rdf api for haskell?
05:31:23 <quchen> typoclass: It's useful if you're using RWST without needing the Reader for example
05:32:03 <typoclass> quchen: hmm!
05:32:50 <quchen> Eh, Writer
05:33:47 <typoclass> quchen: ah. sounds more plausible now :-)
05:39:57 <aCube> is there a typeclass like this: class A m where isEnd :: a -> Bool; next :: a -> a. ? Like a class of streams
05:40:32 <typoclass> aCube: (i guess 'm' is meant as 'a')
05:40:47 <aCube> oh, I think that's not quite right
05:43:46 <quchen> MonadSupply?
05:44:12 <quchen> http://hackage.haskell.org/package/monad-supply-0.3
05:59:40 <no-n> Eq, Ord, Show, Read, Bounded, Enum are all the derivable typeclasses?
06:00:48 <geekosaur> in standard haskell, yes
06:00:56 <no-n> *nod*
06:01:25 <Kinnison> For everyone else there's template-haskell :-)
06:01:26 <aCube> Ghc can derive these with extensions:
06:01:29 <aCube> -XDeriveDataTypeable  -XDeriveFunctor       -XDeriveTraversable
06:01:30 <aCube> -XDeriveFoldable      -XDeriveGeneric
06:01:34 <mm_freak_> when converting a 'Map a b' to an 'a -> b' it's not a functor because of the constraint…  is there anything categorical that captures this conversion?
06:01:47 <ramses_> or -XGenericNewtypeDeriving
06:01:53 <geekosaur> also there's an extension to derive things "through" a newtype
06:01:54 <Kinnison> mm_freak_: a -> b seems a tad optimistic
06:02:28 <Kinnison> mm_freak_: a -> Maybe b seems more plausible, surely
06:02:35 <mm_freak_> Kinnison: sorry, Map is a full-coverage version of Data.Map that has default values
06:03:09 <ramses_> err, -XGeneralizedNewtypeDeriving*
06:03:27 <mm_freak_> i guess i'll just use lenses
06:03:29 <mm_freak_> thanks
06:04:05 <dmwit> mm_freak_: I guess you mean there's some kind of Ord constraint?
06:04:17 <dmwit> If so, this is called a subcategory in CT terms.
06:04:19 <supki> no-n: also Ix
06:04:24 <Kinnison> mm_freak_: Oh righty, I see
06:04:43 <aCube> :t (M.!)
06:04:44 <lambdabot> Ord k => M.Map k a -> k -> a
06:04:45 <mm_freak_> dmwit: yes…  is there an edwardk-style library that covers this?
06:05:25 <dmwit> I guess there's several generalizations of Functor that could be used for this available on Hackage, no?
06:06:14 <dmwit> I don't have a browser on me at the moment, but I vaguely recall rmonad covering something like this, and there's any Functor generalization which uses a type variable instead of (->).
06:08:10 <dmwit> err, hm
06:08:37 <dmwit> mm_freak_: You want to map over the key type or the value type?
06:10:37 <aCube> :t imap
06:10:38 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
06:10:43 <ramses_> dmwit: it has to be the value, since the key is contravariant, isn't it?
06:10:55 <dmwit> Contravariant functors are perfectly good functors. =)
06:11:15 <ramses_> dmwit: yeah, but he was asking about how to implement Functor, which is covariant
06:11:16 <dmwit> And I think he must mean mapping over the key, since mapping over the value doesn't result in any constraint as far as I can tell.
06:11:17 <aCube> ramses_: then Map is a Profunctor? :O
06:11:30 <dmwit> ramses_: No, he was asking for what generalization of Functor he should look for!
06:12:00 <ramses_> oh, ok, I took "functor" to be "Functor"...
06:12:21 <dmwit> mm_freak_: Well, bifunctors has a type variable, but in the wrong place. =P
06:12:35 <ramses_> aCube: I guess, although the Ord constraint might be a problem there as well
06:13:49 <dmwit> mm_freak_: Anyway, category-extras had it in Control.Functor if you're okay with depending on such a huge package (and deprecated at that).
06:14:08 <mm_freak_> dmwit: there was a library specifically for these generalized functors
06:14:15 <dmwit> Yeah, I'm looking for it.
06:14:21 <dmwit> I can't find it, though...
06:14:25 <mm_freak_> me neither
06:16:27 <aCube> @hoogle rmonad
06:16:27 <lambdabot> package rmonad
06:16:38 <aCube> @hackage rmonad
06:16:38 <lambdabot> http://hackage.haskell.org/package/rmonad
06:17:10 <aCube> "A library for restricted monads based on associated datatypes"
06:19:57 <dmwit> Huh. How come when I looked at rmonad fifteen minutes ago when I first suggested it I dismissed it?
06:20:00 <dmwit> dmwit--
06:23:06 <aCube> :i Comonad
06:28:47 <hpaste> Bayu pasted “Konsumen Cerdas Paham Perlindungan Konsumen” at http://hpaste.org/85170
06:31:55 * hackagebot swish 0.9.0.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.1 (DouglasBurke)
06:41:35 <aCube>  Data.Foldable contains fold :: (Foldable f, Monoid m) => f m -> m. Would the "inverse" of fold be unfold :: (Unfoldable f, X m) => m -> f m? If yes, how is X called?
06:45:24 <__xc> I don't even understand the notion of "unfold"
06:45:37 <companion_cube> :t unfoldl
06:45:38 <lambdabot>     Not in scope: `unfoldl'
06:45:38 <lambdabot>     Perhaps you meant one of these:
06:45:38 <lambdabot>       `Seq.unfoldl' (imported from Data.Sequence),
06:45:43 <companion_cube> :t unfold
06:45:44 <lambdabot>     Not in scope: `unfold'
06:45:44 <lambdabot>     Perhaps you meant one of these:
06:45:44 <lambdabot>       `unfoldr' (imported from Data.List),
06:45:48 <companion_cube> :t unfoldr
06:45:49 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:46:17 <companion_cube> __xc: it 'extracts' a a from a b, yielding a new b, until no extraction is possible
06:46:20 <dcoutts> aCube: I'm not sure that Data.Foldable has a sensible inverse because what it's really doing is folding over the elements of a container, not a natural fold over the structure of the data, so I'm not sure that an unfold in that context makes sense, there wouldn't necessarily be a way to reconstruct the structure
06:46:25 <companion_cube> and returns the list of such a
06:46:54 <__xc> fold (or reduce) is a family of higher order functions that process a data structure in some order and build a return value. This is as opposed to the family of unfold functions which take a starting value and apply it to a function to generate a data structure.
06:46:56 <cads> hey guys
06:47:09 * __xc learning
06:47:10 <dcoutts> aCube: it could make sense for containers that have a structure purely determined by the value and order of the elements, but otherwise you're loosing information
06:47:12 <typoclass> __xc: yeah, that's a good description
06:47:40 <typoclass> cads: hello
06:47:51 <aCube> I see, there are several packages providing a notion of "unfolding" (unfoldable, recursion-schemes, ...)
06:48:43 <monoidal> Data.Foldable is a bit of a misnomer; it's more Data.Listable
06:50:21 <typoclass> aCube: if i understand correctly, it's not really a matter of "just add 1-2 functions to Data.Foldable", it's more a matter of "write another typeclass and module that is a counterpart to Data.Foldable"
06:50:53 <dcoutts> aCube: recursion-schemes is more like classic natural folds and unfolds
06:52:52 <cads> hey guys, what is the haskell situation like on openbsd?
06:53:17 <cads> I might need to build gitit there, and do latex, tor, and a few other things
06:53:34 <cads> but I'm asking directly about how well cabal and haskell in general are integrated
06:59:06 <bitonic> cads: cabal is not really ‘integrated’ with most linux distributions anyway
06:59:38 <cads> bitonic: it 'just works' in ubuntu and arch, for example
07:00:04 <cads> that's because we have some high profile members that are ubuntu and arch users, I believe
07:00:08 <bitonic> cads: in the sense that you can install it, yes.
07:00:34 <bitonic> cads: but OpenBSD seems to have the HP in the ports too
07:00:42 <typoclass> cads: what do you mean? you're asking about hackage packages being converted into packages of those linux distributions?
07:01:10 <bitonic> actually the port linked in the wiki seems third party
07:01:27 * bitonic doesn’t know much about OpenBSD ports work
07:26:40 <mbuf> suppose if I have multiple command line options (Bool) using cmdargs, how can I dispatch a separate function when a particular option is passed as an argument? I also need to check whether only one option is given http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm
07:31:56 * hackagebot cabal2nix 1.48 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.48 (PeterSimons)
07:31:58 * hackagebot shakespeare 1.0.4 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.4 (GregWeber)
07:32:00 * hackagebot shakespeare-js 1.1.3 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.3 (GregWeber)
07:34:14 <typoclass> mbuf: how do you mean? f = (if flag then theSpecialFunction else id) ...?
07:35:43 <mbuf> typoclass: suppose if I have multiple options -a, -b, -c etc.
07:40:24 <typoclass> mbuf: could you clarify? are you asking for information on if-then-else? or how to use cmdargs to check if a certain flag -c is set?
07:40:38 <typoclass> mbuf: if you have any code, that will help. use hpaste if it's > 1 line
07:40:42 <typoclass> @where hpaste
07:40:42 <lambdabot> http://hpaste.org/
07:41:00 <mbuf> typoclass: sure, will do
07:43:47 <hpaste> mbuf pasted “dispatch for cmdArgs” at http://hpaste.org/85178
07:44:22 <mbuf> typoclass: I can't call a do method in one of the dispatch guard matches?
07:45:02 <ab9rf> you can, but the type has to work out to Bool, which is difficult to arrange
07:45:10 <mbuf> ab9rf: I see
07:45:43 <mbuf> ab9rf: probably need to read lot of code before I can write useful code, I guess
07:45:47 <ab9rf> or do you mean the right side of the guarded match?  you can put anything you want there as long as all of them hav the same type
07:45:58 <mbuf> ab9rf: yes, right side
07:46:05 <ab9rf> all possible matches of a function definition have to have the same type
07:46:11 <mbuf> ab9rf: okay
07:46:20 <ab9rf> i'm not clear on what you're doing here
07:46:29 <ab9rf> dispatch a | prepare a = print "prepare"
07:46:40 <mbuf> ab9rf: that was just for debugging
07:46:43 <aCube> mbuf: You want to replace print "Nothing" by something that really does "Nothinh" ?
07:47:07 <armlesshobo> @src Maybe show
07:47:07 <lambdabot> Source not found. Wrong!  You cheating scum!
07:47:08 <ab9rf> "prepare a" in that case is a guard and must evaluate to a boolean to mean anything
07:47:16 <armlesshobo> you'd have to do it yourself :P
07:47:29 <robstewartuk> dcoutts: just sent you an email RE: defining cloudhaskell executables in cabal files :-)
07:47:36 <ab9rf> which it does, because of your defintion of the Yum type
07:48:04 <ab9rf> i'm unclear on what your problem is here
07:48:30 <hpaste> typoclass annotated “dispatch for cmdArgs” with “dispatch for cmdArgs (annotation)” at http://hpaste.org/85178#a85179
07:48:35 <dmj> does anyone have some recent snap code for just setting up a basic website that is a little more robust than just echo'ing bytestrings? I know the snap site has its code on github, wasn't sure if this was old or not. Or a good tutorial.
07:49:17 <typoclass> mbuf: what you can always do is move the IO code into main, and pass the Bool (not IO Bool) into dispatch. see annotation ^^
07:50:42 <ab9rf> you generally don't want to pass IO objects, although there are (of course) exceptions to that
07:50:43 <hpaste> mbuf revised “dispatch for cmdArgs”: “dispatch for cmdArgs” at http://hpaste.org/85178
07:51:10 <mbuf> ab9rf: typoclass the above is sort of what I am trying to do
07:51:13 <merijn> ab9rf: Ha! I want to pass IO actions all the time :)
07:51:19 <armlesshobo> lol
07:51:30 <merijn> First class IO is great!
07:52:01 <ab9rf> merijn: what does (b,c) <- runRpmBuild (....) do?
07:52:21 <typoclass> ab9rf: it's supposed to be inside a do block
07:52:28 <tdammers> why would first-class IO be any less awesome than first-class-anything-else?
07:52:28 <ab9rf> ah, i see
07:52:28 <mbuf> typoclass: yes
07:52:44 <ab9rf> why not just make dispatch return a IO type and return the IO value?
07:52:50 <ab9rf> you can evaluate the do-block in the main
07:52:59 <typoclass> mbuf: i suggest you move the runRpmBuild call into main :-) you can then pass its result tuple into dispatch
07:53:01 <ab9rf> ad recover the bindings (if you even care about them) there
07:53:12 <mbuf> typoclass: I see
07:53:47 <mbuf> typoclass: actually this is just a start; depending on more command line options, I want to implement other functions as well
07:54:10 <mbuf> typoclass: not necessarily runRpmBuild
07:54:46 <ab9rf> mbuf: i would suggest writing a function that takes the cmdArgs object and returns an IO object that will execute that action when evaluated
07:55:03 <ab9rf> then do the actual execution and binding (if you care abot binding) in main
07:55:03 <mbuf> I haven't explored System.Console.GetOpt yet
07:55:23 <mbuf> ab9rf: I see
07:55:34 <mbuf> ab9rf: so we keep pure and impure code separately
07:55:43 <typoclass> mbuf: System.Console.GetOpt is the more basic possibility. cmdargs is more funky :-)
07:55:52 <mbuf> typoclass: I see
07:55:59 <hpaste> aCube annotated “dispatch for cmdArgs” with “dispatch for cmdArgs (annotation)” at http://hpaste.org/85178#a85182
07:57:02 <mbuf> aCube: interesting
07:57:14 <Philonous> cmdargs is a horrible hack that makes me cringe
07:57:20 <ab9rf> Philonous: heh
07:57:26 <ParahSailin> @hoogle optparse-applicative
07:57:26 <lambdabot> No results found
07:57:32 <aCube> Philonous: there is a pure version of cmdargs afaik
07:57:45 <typoclass> ParahSailin: yeah, that seems to be what kids these days are using ...
07:57:51 <aCube> @hayoo
07:57:51 <lambdabot> Unknown command, try @list
07:57:54 <Clint> it's the new trend
07:58:14 <Clint> parseargs and cmdargs get no love
07:58:28 <ab9rf> mbuf: i'd almost certainly use a Maybe on that function and return Nothing for no match
07:58:55 <mbuf> ab9rf: in which function?
07:59:14 <ab9rf> dispatch
07:59:23 <mbuf> ab9rf: okay
07:59:37 <ab9rf> i'mnot sure whether you want Maybe IO or IO Maybe, though
08:00:36 <ab9rf> i'd be happier if your dispatch methods returned IO () instead of IO (something else)
08:00:47 <Philonous> aCube:  Ah, that's OK then. But it still comes with the horrifying unsafeperformIO-based annotations?
08:00:55 <mbuf> ab9rf: why not Maybe [Char] as aCube had written?
08:01:05 <aCube> Philonous: yes
08:01:32 <ab9rf> mbuf: that's fine if all of your dispatch options will always call runRpmBuild
08:01:47 <ab9rf> if the purpose of this function is solely to infer rpm arguments
08:01:56 <mbuf> ab9rf: okay
08:02:27 <mbuf> ab9rf: aCube typoclass thanks!
08:02:43 <ab9rf> if you want a more generalized dispatcher, you need a generalized return type, and IO () is about as general as it gets
08:04:25 <quchen> Is there a way to check which packages use a specific function?
08:04:45 <quchen> I'd like to know how many things use Foreign.Marshal.Error.void
08:05:14 <ab9rf> quchen: download all of the packages, parse them out, and check the parse trees? :)
08:05:42 <quchen> Is there good a way to check which packages use a specific function?
08:06:50 <typoclass> mbuf: feel free to check back when you have a little more code :-)
08:07:33 <typoclass> quchen: it may not be that crazy. hackage is a few gb (2-3 gb?)
08:07:43 <mbuf> typoclass: will do; out of curiosity are there any pair programming or tutorial sessions held in this channel?
08:07:57 <ab9rf> mbuf: you can always ask, no guarantees on takers
08:08:10 <mbuf> ab9rf: okay
08:08:21 <typoclass> in some way, this entire channel is a constant pair programming session :-)
08:08:28 <mbuf> typoclass: :)
08:09:01 <quchen> typoclass: But then I still have to parse all of them. Do they import the module? If they use a function called "void", is it that one?
08:10:29 <dcoutts> robstewartuk: solved!
08:11:12 <robstewartuk> Wow, that was exceedingly fast!
08:11:13 <dcoutts> robstewartuk: 5min to find the problem 15min to write the explanation :-)
08:11:18 * robstewartuk reads response.
08:12:10 <robstewartuk> I'm glad it appeared to be a reasonably sane query.
08:12:15 <dcoutts> robstewartuk: hope you don't mind, I cc'ed a couple mainling lists as I think other people might be interested
08:12:21 <typoclass> quchen: true. a search engine for all code on hackage would be a nice thing to have. i can't remember if anyone has done work on that
08:12:48 <dcoutts> typoclass: hayoo!
08:12:52 <typoclass> quchen: there's some general code search engines, e.g. http://code.ohloh.net/ , but i don't think it's really suited for haskell
08:12:56 <quchen> typoclass: I think edwardk did something like that once to find good unused syntax for Lens
08:13:38 <quchen> Oh well, mail's out, I'll just wait for a response from the list and then decide
08:13:56 <dcoutts> typoclass: ah, code itself, not docs. It'd be a nice thing to integrate into the new hackage server
08:14:04 <typoclass> dcoutts: yeah :-)
08:15:03 <typoclass> quchen: it's not very uncommon. i recall reading a message on -libraries the other day that said "i propose adding isLeft and isRight to Data.Either, because i checked and the following 34 packages define their own isLeft and isRight functions: (long list)"
08:16:04 <quchen> typoclass: Good to know. I'd still like to not do the thing myself. ;-)
08:16:06 <applicative_> yes, but they shouldn't define isLeft ...
08:16:22 <quchen> typoclass: It's just about how many packages use a deprecated function
08:16:31 <quchen> So that's probably not worth the hassle
08:16:48 <dcoutts> typoclass, quchen: tibbe has been thinking of a code search too, idea is to write a tool using the ghc api to dump def/use info packages and then collect that into a massive index
08:17:03 <typoclass> dcoutts: interesting
08:17:04 <quchen> On a related note, can re-exports be marked as deprecated? I.e. "import it from that other module in the future please"
08:17:05 <dcoutts> erm, def/use info for all modules in each package
08:17:47 <typoclass> we already have a thing for "who uses this package", don't we. next we'd need "who uses this module" and finally "who uses this function"
08:18:16 <dcoutts> typoclass: right, it'd be able to find all uses of a name
08:18:17 <quchen> new-new-hackage!
08:18:59 <typoclass> ... and then, hackage 7.0 will tell you "i see that compared to yourpackage-0.5, yourpackage-0.6 has changed function foo. this will impact the following 74 places in 13 packages: ..."
08:19:00 <typoclass> :)
08:19:43 <applicative_> quchen: write {-# DEPRECATED moo "Use Moo.moo instead" #-}
08:20:35 <quchen> applicative_: Does that work for reexports?
08:20:39 <cdh473> I'm having an issue with regexps in haskell. I am trying to split a string on every space, and also each full-stop ('.'); however, I do not want to remove the full-stop from the array, only put it in the array as its own element. Is there any way I can do all this in a single regexp? I tried using "[(?=.) ]" to no avail; it removes the full-stop from the array. AFAIK, that would work in another language'
08:20:39 <cdh473> s regex parser.
08:20:51 <quchen> You posted the normal way of deprecating something
08:21:20 <applicative_> yes
08:21:30 <quchen> cdh473: Have you looked at Data.List.Split? It defines functions that may be more suitable for your task.
08:21:37 <quchen> applicative_: Good to know!
08:21:49 <cdh473> quchen: no, i'll have a look.
08:23:13 <quchen> cdh473: Sounds like you're looking for words, and then concatMapping "split on dot while keeping it" over that.
08:23:15 <ab9rf> i hate regexps
08:23:26 <quchen> ab9rf: They are so hacky
08:23:44 * RenJuan has dejavu
08:26:42 <applicative_> quchen: yeah it doesnt work, I guess you had already seen ghc's complaint
08:27:32 <ab9rf> cdh473: honestly i would not use regexps for this
08:28:02 <cdh473> okay.
08:28:04 <applicative_> the obvious expedient of importing qualified, deprecating moo = Moo.moo and exporting moo does work
08:28:53 <ab9rf> look at the source of words or of split and adapt it :)
08:29:46 <ab9rf> although words is fairly gnarly, as i recall
08:30:11 <typoclass> cdh473: here's an example, first using 'words' for the spaces, then Data.List.Split for the periods
08:30:13 <typoclass> > map (Data.List.Split.split $ oneOf ".") $ words $ "lol. cats. meow"
08:30:14 <lambdabot>   [["lol",".",""],["cats",".",""],["meow"]]
08:30:46 <ab9rf> that's fairly close
08:32:49 <applicative_> map (Data.List.Split.split $ oneOf ".") $ words $ "Data.List.Split.split  lol. cats. meow"
08:33:22 <applicative_> > map (Data.List.Split.split $ oneOf ".") $ words $ "Data.List.Split.split  lol. cats. meow"
08:33:24 <lambdabot>   [["Data",".","List",".","Split",".","split"],["lol",".",""],["cats",".",""]...
08:34:00 <cdh473> not quite. :c
08:34:56 <typoclass> cdh473: well, what do you need?
08:35:43 <cdh473> i need it to not produce those empty strings
08:36:17 <cdh473> i mean, i guess i could just flatten it out to give one flat list and then just remove all the empty strings from it
08:37:02 <typoclass> > filter (not . null) . concat . map (Data.List.Split.split $ oneOf ".") . words $ "lol. cats. meow"
08:37:03 <lambdabot>   ["lol",".","cats",".","meow"]
08:37:07 <typoclass> cdh473: ^^
08:37:09 <fizbin> cdh473: The regex that would work in a certain language's parser is "(\.)| ", not what you had.
08:37:14 <ab9rf> cdh473: that's an option, but it's not very tidy
08:37:25 <cdh473> !
08:37:32 <ab9rf> you generate data that you then throw away
08:37:34 <ab9rf> that's wasteful :)
08:37:50 <ab9rf> it hastens the heat death of the universe
08:37:52 <cdh473> lol
08:38:00 <cdh473> hang on, i want to try the regex solution
08:38:16 <typoclass> ab9rf: maybe D.L.Split can be made to not produce empty lists. it has stuff like endBy
08:38:31 <ab9rf> typoclass: yeah, you have to transform the Splitter with dropFinalBlank
08:38:50 <cdh473> err, "(\.)| " gives a lexical error, but anyways
08:39:05 <ab9rf> cdh473: that's because you aren't using That Other Language :)
08:39:11 <Iceland_jack> 15:29 <benedikt> mig langar að læra svona mikið um FP
08:39:11 <Iceland_jack> 15:29 <benedikt> :(
08:39:11 <cdh473> hehe
08:39:39 <ab9rf> > map (Data.List.Split.split $ dropFinalBlank . oneOf ".") . words $ "lol. cats. meow."
08:39:41 <lambdabot>   Couldn't match expected type `Data.List.Split.Internals.Splitter
08:39:41 <lambdabot>           ...
08:39:47 <applicative_> @type Data.Text.breakOn
08:39:48 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> (Data.Text.Internal.Text, Data.Text.Internal.Text)
08:40:04 <ab9rf> > map (Data.List.Split.split $ (dropFinalBlank . oneOf ".")) . words $ "lol. cats. meow."
08:40:05 <lambdabot>   Couldn't match expected type `Data.List.Split.Internals.Splitter
08:40:06 <lambdabot>           ...
08:40:13 <ab9rf> oh duh
08:40:20 <ab9rf> > map (Data.List.Split.split $ dropFinalBlank . (oneOf ".")) . words $ "lol. cats. meow."
08:40:21 * osfameron grumbles about the Poplular Front of Judea
08:40:22 <lambdabot>   Couldn't match expected type `Data.List.Split.Internals.Splitter
08:40:22 <lambdabot>           ...
08:40:27 <twomashi> does anyone find that programming in imperative languages is weird after using haskell
08:40:41 <ab9rf> twomashi: yes
08:40:46 <sproingie> of course.  i find myself wanting to curry shell scripts
08:40:53 <sproingie> actually with stdin it kind of works
08:41:02 <ab9rf> :t dropFinalBlank
08:41:04 <lambdabot> Splitter a -> Splitter a
08:41:10 <ab9rf> :t oneOf "."
08:41:11 <lambdabot> Splitter Char
08:41:14 <twomashi> it doesnt seem so straightforward anymore.. maybe im just burned out though
08:41:21 <ab9rf> :t dropFinalBlank $ oneOf "."
08:41:22 <lambdabot> Splitter Char
08:41:32 <ab9rf> > map (Data.List.Split.split $ dropFinalBlank $ oneOf ".") . words $ "lol. cats. meow."
08:41:34 <lambdabot>   [["lol","."],["cats","."],["meow","."]]
08:41:45 <ab9rf> > concat $ map (Data.List.Split.split $ dropFinalBlank $ oneOf ".") . words $ "lol. cats. meow."
08:41:47 <lambdabot>   ["lol",".","cats",".","meow","."]
08:41:55 <cdh473> :D
08:42:17 <parcs> it takes a while for both paradigms to coexist peacefully in your brain
08:43:08 <typoclass> sproingie: don't get me started on shell scripts! if they get longer than about 5 lines, they quickly become uncontrollable
08:43:14 <ab9rf> typoclass: 5?  try 2.
08:43:36 <Iceland_jack> Hey now, shell scripting is perfectly legible
08:43:41 <ab9rf> typoclass: i used to wrangle autoconf, i know _way_ too much about that crap
08:44:17 <sproingie> i draw the line at about 40 lines before i think it'd be better in perl or python
08:44:22 <sproingie> basically a screen
08:44:45 <Clint> shell scripting should always be done in shell
08:44:49 <ab9rf> sproingie: it's a sad day when perl is the better choice of implementation :)
08:44:53 <applicative_> is there any reason there couldn't be a special file type .hscript, which would have just be a giant io do block, with lets etc
08:44:55 <sproingie> that or i break it into more scripts
08:45:22 <ab9rf> i think the configure script for the gimp was around 6000 lines, when i was working on it
08:45:24 <sproingie> i like scripts with massive pipelines.  i got 48 cores on this box and i plan to use 'em *all*
08:45:46 <ab9rf> of course most of that was boilerplated by autoconf but still
08:45:54 <applicative_> any definitions at the top level would have to be in lets so it'd be like ML ...
08:46:24 <typoclass> i keep using haskell instead of shell scripts, and it keeps going better than expected
08:46:41 <typoclass> Iceland_jack: that's a joke, right? :-)
08:46:56 <ab9rf> Iceland_jack: just like sendmail.cf files are "perfectly legible"
08:47:05 <ab9rf> if you're a dyslexic chicken perhaps
08:47:48 <ab9rf> of course, haskell has some splaining to do for some of its operators
08:47:53 <ab9rf> :t (.).(.)
08:47:54 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:48:00 <Iceland_jack> typoclass: I don't joke.
08:49:03 <ab9rf> @unpl (.).(.)
08:49:03 <lambdabot> (\ i b c f -> i (b c f))
08:49:32 * applicative_ figured he'd find choice examples of hideous bash scripts on https://github.com/languages/Shell but they're looking kind of reasonable...
08:49:59 <merijn> applicative_: Look at the FreeBSD ports system, it is held together entirely by shell scripts and makefiles :p
08:50:44 <t7> yuck
08:51:19 <ab9rf> beats using sed to do infinite-precision arithmetic
08:51:53 <ab9rf> Data.List.Split is awesome
08:51:57 <typoclass> merijn: the argument is that it needs inordinate amounts of discipline and manpower and babysitting
08:52:34 <ab9rf> typoclass: which means only the uberleet can do it, thereby allowing some poor schmucks to prove their manliness?
08:53:31 <applicative_> I thought it would be the opposite, everyone who uses FreeBSD knows a bit of the shell lingo
08:54:11 <ab9rf> i think we should move discussion of the manliness or otherwise of freebsders to -blah :)
08:54:52 * applicative_ agrees, but not before affirming his port system uses ruby....
08:56:10 <merijn> typoclass: Oh, I'm certainly not arguing it's a great idea :p
08:56:43 <typoclass> merijn: oh then i misunderstood you. you were arguing that freebsd is terrible
08:56:45 <typoclass> :-/
09:00:48 <ab9rf> heh
09:00:52 <mapf> I make import Paths_mylib_name (version); to get the version from cabal file. All working ok, but now I have some changes and I get `undefined reference to <...version1_closure>'. I have no idea what to do next.
09:00:59 <ab9rf> the default splitter for Data.List.Split splits on nothing
09:01:12 <dcoutts> mapf: all modules in a library must be listed in the .cabal file
09:01:19 <ab9rf> it uses a predicate splitter of (const False)
09:01:30 <dcoutts> mapf: ie add it to the other-modules list
09:03:42 <mapf> dcoutts: indeed, i forget the one. but now I have the same error from linker.
09:04:25 <dcoutts> mapf: you'll need to rebuild the lib once you changed its cabal file, so the extra .o file gets included
09:05:04 <mapf> and my lib has name `blah-blah', so I replace '-' by '_' since package names don't accept '-'. Is it right? though it working some time before...
09:05:56 <dcoutts> mapf: right
09:06:27 <dcoutts> mapf: the module name has _ where your package name has -, because '-' isn't valid in a module name
09:12:33 <mikusp> how to convert a string with escaped letters to utf8? e.g. "kr\243tki poradnik jak si\281 ceni\263"
09:15:23 <geekosaur> those don't look utf8 encoded... good luck
09:15:35 <ab9rf> \281 is invalid
09:15:49 <ab9rf> iirc, the digits after the \ are in octal
09:16:12 <typoclass> mikusp: you could use iconv to convert it to utf8 before you feed it to haskell
09:16:29 <mikusp> i get it from parsing a json with Aeson
09:16:36 <monoidal> ab9rf: they're decimals
09:16:41 <mikusp> so iconv won't help
09:16:46 <ab9rf> monoidal: really?  huh i thought it was octal
09:16:57 <ab9rf> mikusp: are you sure those aren't just the result of Show?
09:17:03 <monoidal> > '\69'
09:17:05 <lambdabot>   'E'
09:17:11 <ab9rf> > '\243'
09:17:13 <lambdabot>   '\243'
09:17:40 <mikusp> you mean that internally they are in utf8 and show escapes them?
09:17:48 <ab9rf> mikusp: that's a distinct possibility
09:17:55 <ab9rf> > show "\\"
09:17:55 <monoidal> mikusp: not sure if utf8, but unicode
09:17:56 <lambdabot>   "\"\\\\\""
09:18:12 <typoclass> mikusp: try 'length' on one of those chars.
09:18:18 <typoclass> > length '\243'
09:18:20 <lambdabot>   Couldn't match expected type `[a0]'
09:18:20 <lambdabot>              with actual type `GHC.Type...
09:18:22 <monoidal> mikusp: if you do putStr "kr\243tki poradnik jak si\281 ceni\263" you'll see "krótki poradnik jak się cenić"
09:18:26 <typoclass> > length "\243"
09:18:27 <lambdabot>   1
09:18:32 <mikusp> you're right
09:19:02 <ab9rf> show escapes anything not in the basic plane
09:19:14 <ab9rf> > show "\6002"
09:19:15 <lambdabot>   "\"\\6002\""
09:19:29 <mikusp> is there a way to tell show to not escape?
09:19:32 <ab9rf> > "\6002"
09:19:33 <lambdabot>   "\6002"
09:19:43 <ab9rf> > "\65"
09:19:45 <lambdabot>   "A"
09:19:53 <ab9rf> > length "\6002"
09:19:55 <lambdabot>   1
09:19:58 <monoidal> mikusp: that would be the identity function
09:20:08 <monoidal> mikusp: i.e. showWithoutEscaping x = x
09:20:12 <ab9rf> mikusp: you probably don't want to use show
09:20:14 <typoclass> mikusp: show is often just a helper for debugging, and for the actual code you'd give the String directly to hPutStr or wherever
09:20:15 <Philonous> monoidal:  No, show also adds quotes
09:20:15 <monoidal> maybe add "
09:20:18 <__xc> > read '\243'
09:20:20 <lambdabot>   Couldn't match expected type `GHC.Base.String'
09:20:20 <lambdabot>              with actual typ...
09:20:27 <__xc> > read "\243"
09:20:29 <lambdabot>   *Exception: Prelude.read: no parse
09:20:45 <aCube> :t read
09:20:47 <lambdabot> Read a => String -> a
09:20:51 <aCube> > read "()"
09:20:53 <lambdabot>   ()
09:20:57 <ab9rf> > read "\243" :: Char
09:20:59 <lambdabot>   *Exception: Prelude.read: no parse
09:21:06 <ab9rf> odd
09:21:12 <ab9rf> i would have expected that to have a parse
09:21:16 <Philonous> > read "'\243'" :: Char
09:21:18 <lambdabot>   '\243'
09:21:19 <ab9rf> oh, right
09:21:24 <ab9rf> silly quotes
09:21:28 <mikusp> ok, thanks for help
09:21:56 <__xc> wanted to convert back '\243' to  'E'
09:22:13 <Philonous> ab9rf:  I think the show and read instances are supposed to be compatible, and show is supposed to produce legal haskell code
09:22:14 <__xc> oops
09:22:23 <__xc> tha'tts different
09:22:24 <ab9rf> Philonous: ye
09:22:37 <monoidal> __xc: '\69' == 'E'
09:22:57 <__xc> monoidal, yes sorry misread
09:22:57 <monoidal> it's the same thing, use fromEnum to get the number
09:23:41 <Philonous> Is the enum instance for Char a good idea?
09:23:47 <__xc> > fromEnum '$'
09:23:48 <ab9rf> a good idea for what?
09:23:49 <lambdabot>   36
09:24:18 <niteria> > fromEnum 'ł'
09:24:18 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
09:24:33 <monoidal> Philonous: mildly useful, you can write ['a'..'z'] for example
09:24:34 <typoclass> niteria: lambdabot doesn't understand unicode
09:24:52 <ab9rf> why wouldn't Char have an Enum instance?
09:24:56 <__xc> > succ ''
09:24:56 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
09:25:13 <__xc> > succ ''
09:25:13 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
09:25:15 <ab9rf> lambdabot doesn't understand unicode
09:25:18 <ab9rf> stop being mean to it
09:25:18 <__xc> > succ '$'
09:25:20 <lambdabot>   '%'
09:25:36 <__xc> okok
09:25:45 <typoclass> ab9rf: please don't refer to her as 'it'
09:25:51 <ab9rf> typoclass: bah
09:26:04 <ab9rf> typoclass: programs do not have gender
09:26:09 <Philonous> ab9rf:  I was just thinking that it unnecessarily fixes an encoding, but I guess since Char are unicode characters the instance isn't baseless
09:26:33 <ab9rf> Philonous: there's no pretension that Char is an abstract character devoid of encoding
09:26:45 <Clint> s/encoding/set/
09:27:14 <ab9rf> Philonous: i've seen people try that in the past, and before unicode it kinda made sense
09:28:00 <__xc> @check succ . prec == id
09:28:02 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `prec'
09:28:02 <lambdabot>  Perhaps you meant one of ...
09:28:04 <ab9rf> Philonous: but Unicode is suppose to be "one charset to rule them all" and so there's no good reason to have a character type that includes unicode that also contemplates characters that aren't in unicode
09:28:26 <ab9rf> Philonous: and who uses EBCDIC these days?
09:28:30 <Philonous> ab9rf:  Yes, I forgot for a second that Char is unicode
09:28:41 <__xc> @pl succ . pred
09:28:42 <lambdabot> succ . pred
09:28:47 <niteria> > succ maxBound :: Char
09:28:49 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
09:28:58 <niteria> so, no
09:29:03 <ab9rf> succ . pred is not necessarily id
09:29:09 <ab9rf> because of the maxBound issue
09:29:14 <ab9rf> similar for pred . succ
09:29:14 <__xc> ah right
09:29:17 <ab9rf> the domains are not the same
09:29:33 <Philonous> But can it disagree with id?
09:29:48 <ab9rf> Philonous: they are the same for all elements in the domain of the composite
09:30:05 <ab9rf> or at least should be :)
09:30:22 <hpaste> mapf pasted “linker error for version import” at http://hpaste.org/85183
09:31:02 <mapf> well i rm dist; but get the same.
09:31:10 <twomashi> does GHC "cheat" on immutability if it detects that it can safely recycle a memory address for a particular variable?
09:31:14 <ab9rf> missing -l?
09:31:33 <mapf> ab9rf: where is?
09:31:35 <ab9rf> twomashi: how is that cheating?
09:31:35 <c_wraith> twomashi: nope.
09:31:52 <ab9rf> immutability is a language-level concept
09:32:06 <twomashi> right… so it can easily
09:32:07 <ab9rf> the compiler isn't required to treat memory as immutable
09:32:33 <monoidal> in some sense, that recycling is a job of the register allocator
09:32:43 <ab9rf> that's a code genreation issue
09:32:50 <monoidal> (not for memory addresses)
09:32:57 <ab9rf> monoidal: registers are just a type of memory
09:33:58 <monoidal> ab9rf: they don't have addresses
09:34:06 <ab9rf> monoidal: so?
09:34:11 <ab9rf> they have ways to be referred to
09:34:26 <monoidal> ab9rf: sure. but the original point was about addresses
09:34:45 <ab9rf> monoidal: some architectures have really large register files and in those registers really kinda do have addresses
09:35:40 <int-e> I thought the question was about heap objects. But it's hard to say for sure.
09:36:54 <ab9rf> monoidal: and on a machine with very limited registers you might use a chunk of memory as if it were a register file :)
09:37:01 * hackagebot xml-picklers 0.3.2 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.2 (PhilippBalzarek)
09:48:29 <GREENBIBO> http://www.reddit.com/r/onlyteensgallery/comments/1bo3h6/melissa_black_double_anal_penetration/
09:49:39 <danharaj> I feel obligated to have a conversation just to get that unsightly spam out of my view.
09:50:05 <ab9rf> @unpl (.)(.)(.)(.)
09:50:05 <lambdabot> (\ e f i k l -> e f i (k l))
09:50:38 <Taneb> danharaj, have you seen lens-opengl?
09:50:55 <danharaj> Taneb: No but it sounds promising from the name alone.
09:51:00 <Taneb> https://github.com/lens/lens-opengl
09:51:01 <ab9rf> hm, yes, it does
09:51:25 <ab9rf> i need to get a toolchain on my laptop that works reliably
09:51:45 <ab9rf> i haven't been able to get a build of any of sdl, wxwidgets, or ncurses that will work with ghc
09:53:49 <typoclass> ab9rf: what are you planning with ncurses?
09:59:32 <ab9rf> typoclass: retro games
10:00:08 <ab9rf> the best i can get so far is a segfault
10:00:42 <applicative_> hm, what operating system is it?
10:02:01 <otters> I'm not surprised there's a /r/onlyteensgallery
10:02:28 <ab9rf> otters: please don't talk about
10:02:31 <ab9rf> we don't need the FBI in here
10:02:31 <otters> okay
10:02:57 <donri> otters: #haskell-blah
10:02:59 <hiptobecubic> "swizzle"
10:03:11 <otters> no, I'm done
10:04:08 <hiptobecubic> This is looks horrifically repetitive. Is there no better way to do this? https://github.com/lens/lens-opengl/blob/master/src/Graphics/Rendering/OpenGL/Lens.hs
10:05:40 <elliott> well, it's boilerplate
10:05:48 <elliott> it's repetitive so user code doesn't have to be
10:05:54 <elliott> probably most of it could be TH-derived, but then you have to work with TH
10:07:48 <ab9rf> typoclass: i have the utterly crazy idea of writing a dwarf fortress clone in haskell
10:08:04 <sproingie> ab9rf: really?  me too :)
10:08:23 <ab9rf> sproingie: i've been working on DFHack for nigh on a year now, and know DF internals fairly well
10:08:47 <sproingie> so you well know DF is sort of a tower of hacks
10:08:52 <ab9rf> sproingie: oh, god yes
10:09:11 <ab9rf> sproingie: there's some mindnumbingly bad code in there
10:09:22 <sproingie> i'd just go green-field from scratch, i call it a "sim-roguelike"
10:09:26 <ab9rf> sproingie: i've looked at the decompilations
10:09:36 <ab9rf> sproingie: reusing the code is out of the question.  it'd be a conceptual rewrite
10:09:39 <sproingie> i was going to call it Goblin Horde but someone already beat me to Goblin Camp
10:10:02 <sproingie> tho porting/rewriting Goblin Camp in haskell might not be a bad thought
10:10:15 <ab9rf> sproingie: that might be interesting in its own right
10:10:37 <ab9rf> sproingie: of course, i risk having toady declare me a nonperson :)
10:10:38 <sproingie> tho i can't resist the thought of "GH" being written with GHC
10:10:50 <sproingie> Goblin Horde Compiler
10:10:53 <merijn> sproingie: "Dwarves Must Die" and hope you don't get sued by Robot Entertainment ;)
10:11:32 <sproingie> Urist and Morul present: Dorfs Must Die
10:12:15 <sproingie> i'd call it that if i wrote it in D
10:12:22 <sproingie> using the DMD compiler :)
10:13:23 <sproingie> as it is all i can manage to do is write some basic tile engine crap in java and occasionally scala before losing interest
10:13:27 <Philonous> Is there anyone in the community who has acces to the DF sources?
10:13:31 <ab9rf> sproingie: at one point (i think in worldgen) there is a 51-way switch that increments one of 51 different stack variables, depending on the switch variable (0..50)
10:13:46 <sproingie> i suspect exposure to the DF source would cause me to enter a Fell Mood
10:13:52 <ab9rf> sproingie: any sane programmer would have simply had a 51-element array and indexed into the array.
10:14:01 <Philonous> Err, never mind, I though this was -blah -_-
10:14:57 <elliott> looks like -blah to me :P
10:14:59 <ab9rf> Philonous: we can move it tere
10:25:24 <aCube> > foldr1 f [a,b,c]
10:25:25 <lambdabot>   f a (f b c)
10:25:27 <aCube> > foldl1 f [a,b,c]
10:25:28 <lambdabot>   f (f a b) c
10:26:37 <otters> oh THAT'S how it works
10:27:00 <aCube> I keep forgetting which one is which :D
10:28:53 <genk> hi
10:29:08 <byorgey> hi genk
10:29:27 <quchen> aCube: foldr is the right one. foldl is that guy with the glasses that have a fake nose and mustache attached.
10:29:43 <aCube> :D
10:30:02 <genk> brent, how are you? i am in need of some help, if you can.
10:30:05 <quchen> Here's a nice tutorial website: http://foldl.com/
10:30:05 <aCube> quchen: but when I'm accumulating a non-lazy value, I can use foldl', no?
10:30:11 <quchen> And for foldr: http://foldr.com/
10:30:47 <byorgey> genk: I'm well, thanks.  Just post your questions in here and people will help you as they can.
10:30:53 <quchen> aCube: Rule of thumb is that consuming a list is foldr, unless you're absolutely sure foldl' is better.
10:30:58 <byorgey> genk: if you need to show some code, you can put it on hpaste.org
10:31:07 <genk> thanks brent.
10:31:58 <ramses_> quchen: +1 for those sites :)
10:31:59 <genk> I want to find the indices of all occurences of an element in a list of lists. e.g. I want to find all of the indices (as tuples like (row,column)) in [["-", "-", "X", "-", "-"],   ["A", "X", "X", "-", "-"],   ["A", "-", "-", "A", "F"],   ["-", "-", "F", "F", "F"],   ["-", "X", "-", "-", "-"]]. Any ideas?
10:32:18 <dmwit> You might like findIndices as a building block.
10:32:21 <dmwit> :t findIndices
10:32:22 <lambdabot> (a -> Bool) -> [a] -> [Int]
10:32:25 <ramses_> genk: sounds like homework?
10:32:32 <genk> yep
10:32:32 <aCube> quchen: When is foldl' better? When the result cannot be computed partially (lazily)?
10:32:36 <quchen> ramses_: They aren't mine though
10:32:49 <dmwit> Beyond that, you should say what you tried and why it didn't work.
10:32:55 <ramses_> quchen: no, but I hadn't heart about them yet
10:32:59 <Kaidelong> foldl' is generally better if your operator is commutative and you're sure you're going to be consuming *the whole list* every time it is called. IE you're building a flat value rather than one that can be partially evaluated
10:33:05 <genk> ramses_ I wrote a function but it only gathers indices in a list, using findIndices in Data.List
10:33:10 <quchen> aCube: To avoid stack overflows. Summing a huge list is the typical foldl example.
10:33:29 <ramses_> genk: then hpaste what you've already got and we can start from there
10:33:31 <Kaidelong> foldl' anyway
10:33:33 <quchen> What Kaidelong said.
10:33:45 <Kaidelong> foldl should probably never be used
10:33:57 <elliott> foldl is useful for like three things, none of which I can remember
10:34:03 <aCube> foldl' (.) or foldr (flip (.)) ?
10:34:04 <Kaidelong> there are probably some corner cases out there som... yeah
10:34:05 <ramses_> genk: (on hpaste.org, not here)
10:34:11 <hpaste> genk pasted “findAgent” at http://hpaste.org/85185
10:35:00 <genk> ramses_ here they are.
10:35:37 <Kaidelong> although in stuff like OCaml it's generally foldr you want to avoid using
10:35:46 <clahey> foldl' seems like it would be more efficient than foldr.
10:35:48 <genk> ramses_ hold on I am adding comments, sorry for that
10:36:28 <dmwit> clahey: That depends a lot on how you consume the fold's output.
10:36:33 <Kaidelong> clahey: It actually depends on the situation. foldr doesn't have to do any work at all if it is never forced
10:36:46 <dmwit> If your fold needs to be strict, foldl' is more efficient. If your fold will be used lazily, foldr is more efficient.
10:37:02 <dmwit> (That's a 0th-order approximation to the truth, of course; always profile when it matters.)
10:37:07 <Kaidelong> and it can also consume only part of a list
10:37:23 <Kaidelong> whereas foldl' always consumes the whole list
10:38:00 <genk> ramses_ now I've added the comments. can you help?
10:38:40 <parcs> the compiler ought to figure out when to make foldl strict in the accumulator
10:38:57 <ramses_> genk: what's the problem? The first function seems to do what you described?
10:39:02 <Kaidelong> also if the operator you're folding in is a data constructor, you are almost always going to want foldr
10:40:00 <monochrom> except when that data constructor has strict fields, and then you want foldl' again
10:40:20 <clahey> Which one does sum use?
10:40:26 <monochrom> and there are exceptions to that exception
10:40:27 <Kaidelong> foldr
10:40:41 <Kaidelong> I believe
10:40:42 <monochrom> in the end, it's going to be like a Taylor series
10:40:43 <parcs> it uses foldl, but the compiler is smart enough to make it strict in the accumulator when it makes sense
10:40:53 <quchen> sum uses neither.
10:41:00 <quchen> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sum
10:41:01 <Kaidelong> @src sum
10:41:01 <lambdabot> sum = foldl (+) 0
10:41:10 <Kaidelong> I stand corrected
10:41:13 <genk> ramses_ i've added a sample input and my desired output
10:41:13 <dmwit> genk: By the way, whatever you did with comments doesn't seem to be showing up here.
10:41:26 <quchen> sum is hardcoded.
10:41:29 <parcs> quchen: which is basically inlined foldl
10:41:34 <dmwit> genk: Where have you added these?
10:41:38 <quchen> parcs: Yes.
10:41:44 <genk> ramses_ which my code fails to do
10:41:53 <parcs> so it uses foldl
10:42:00 <hpaste> genk revised “findAgent”: “findAgent” at http://hpaste.org/85185
10:42:10 <genk> dmwit sorry here it is again
10:42:29 <ludamad> What do you guys recommend I use for a simple http server ?
10:42:40 <ludamad> I do not plan to do anything too htmly, just talk over http
10:42:55 <elliott> warp, or snap's server?
10:44:28 <ludamad> elliott: Are those two suggestions, or a question ?
10:45:01 <ramses_> genk: your findall basically outputs all info you need, you just need to transform it a bit, right?
10:45:17 <hpaste> genk revised “findAgent”: “findAgent” at http://hpaste.org/85185
10:45:22 <typoclass> genk: so, do you actually need those indices directly, or will they be input to some later function? because then you're probably better off just walking through everything with a few 'map's, checking if the element is relevant, and directly doing the "some later function"
10:45:49 <ramses_> genk: (btw, your example in the paste misses a parameter for findAll, a one I guess from the desired output)
10:46:23 <elliott> ludamad: two suggestions
10:46:30 <genk> typoclass: i will pass the results to another function which detects if there is a "collision" and removes them accordingly to create a new list
10:47:05 <genk> ramses_: ah yes, you are right.
10:47:41 <pamojarpan> do you know any collaborative web tool to edit haskell files? Something like hpaste but allowing collaborative edition.
10:48:04 <typoclass> pamojarpan: shapr's thingamajig! what was the name ... ghc live or something?
10:48:05 <ramses_> genk: I haven't really looked at your implementation in detail, but writing a third function to transform the output of findAll into the desired form shouldn't be too hard I think
10:48:18 <ramses_> genk: some filtering and folding should do, I think
10:48:53 <genk> typoclass: I need indices of the elements since I want to "move" those "Agents" in my map and the easiest way I figured out was to gather their coordinates, apply the movement, and create a new list from the new coordinates.
10:49:20 <hpaste> “Cathleen Grice” pasted “My loan result” at http://hpaste.org/85188
10:49:54 <typoclass> genk: right ok. have you looked at the elemIndices function? (hlint actually suggests it, below your paste)
10:49:56 <typoclass> > elemIndices 'l' "lolcats"
10:49:57 <lambdabot>   [0,2]
10:50:46 <genk> ramses_: yes, you are right. I finally got to "findAll" but I am stuck there.
10:50:50 <byorgey> ugh hpaste spam
10:51:04 <__xc> > succ maxBound :: Bool == minBound :: Bool
10:51:05 <lambdabot>   <hint>:1:35: parse error on input `::'
10:51:18 <genk> typoclass: yes I also tried that but still it cannot figure out how to locate a primitive element in a list of lists
10:51:22 <klrr> i want to define a type which has a Int, and then two optional parameters(which is of the same type) , how do i do that?
10:51:28 <__xc> > succ (maxBound :: Bool) == (minBound :: Bool)
10:51:30 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
10:51:34 <genk> typoclass: elemIndices :: Eq a => a -> [a] -> [Int]
10:51:37 <ramses_> genk: consider combining that with map
10:51:56 <ramses_> :t map . elemIndices
10:51:57 <lambdabot> Eq a => a -> [[a]] -> [[Int]]
10:52:05 <__xc> to me succ opred should loop in the set
10:52:29 <genk> ramses_: i'll try that.
10:52:30 <__xc> like in Z/nZ intger sets
10:52:35 <klrr> i want to define a type which has a Int, and then two optional parameters(which is of the same type) , how do i do that?
10:52:46 <ab9rf> optional parameters?
10:53:13 <ab9rf> i'm not sure what you mean, but that sounds like an algebraic type with three (or maybe four) constructors
10:53:17 <typoclass> > map (elemIndices 'l') ["lolcats", "the lolcats"] -- genk, you could start with this
10:53:18 <lambdabot>   [[0,2],[4,6]]
10:53:50 <typoclass> > zip [0..] "stuff" -- genk, to add indices to a list, giving a list of tuples, use this :-)
10:53:52 <lambdabot>   [(0,'s'),(1,'t'),(2,'u'),(3,'f'),(4,'f')]
10:54:23 <parcs> klrr: data Foo a = Foo Int (Maybe a) (Maybe a) perhaps
10:54:42 <ab9rf> parcs: damn you, beat me to it
10:54:46 <klrr> ab9rf: i mean , if the type is named "Test", it is "Test Int Float Float" where the floats doesnt have to be included
10:54:56 <parcs> u snooze u lose
10:54:56 <klrr> parcs: oh that's a good idea
10:55:08 <genk> typoclass: thanks, I tried zipping before but I ended up starting from 1 for every row. I'll try that now.
10:55:16 <ab9rf> klrr: data Test = Test1 Int | Test2 Int Float | Test3 Int Float Float
10:55:34 <ab9rf> klrr: but i suspect that parcs' formulation is probably better in the long run
10:55:43 <klrr> ab9rf: that's not what i meant :P
10:56:00 <ab9rf> klrr: haskell doesn't really have the concept of an "optional argument"
10:56:19 <ab9rf> but it does have optional values :)
10:56:49 <klrr> ab9rf: well, im trying to implement a binary tree, and all nodes doesnt have to have childrens
10:56:54 <genk> typoclass: a little more help, I tried zipping like this before (now with lolcats :)  : zip [1..] (map (elemIndices 'l') ["lolcats", "the lolcats"])
10:57:01 <dmwit> > let f x yss = do { (r, xy) <- zip [0..] yss; (c, y) <- zip [0..] ys; guard (y == x); return (r, c) } in f 'l' ["lolcats", "stuffl"]
10:57:02 <lambdabot>   Not in scope: `ys'
10:57:03 <lambdabot>  Perhaps you meant one of these:
10:57:03 <lambdabot>    `yss' (line 1), `s' ...
10:57:14 <dmwit> > let f x yss = do { (r, ys) <- zip [0..] yss; (c, y) <- zip [0..] ys; guard (y == x); return (r, c) } in f 'l' ["lolcats", "stuffl"]
10:57:16 <lambdabot>   [(0,0),(0,2),(1,5)]
10:57:16 <genk> typoclass: it turns:   [(1,[0,2]),(2,[4,6])]
10:57:19 <dmwit> just for fun =P
10:57:21 <ab9rf> klrr: Data.Tree
10:57:43 <klrr> ab9rf: well, im supposed to implement it myself, it's exercise :)
10:58:37 <ab9rf> klrr: there's lots of different ways to do trees.
10:59:05 <typoclass> genk: yes, so the next task will be to map (or rather concatMap) over that list, creating the final list of indices
10:59:35 <ab9rf> klrr: e.g. do you put labels on all nodes, or only on leafs?
11:00:17 <genk> :t concatMap
11:00:19 <lambdabot> (a -> [b]) -> [a] -> [b]
11:00:48 <genk> typoclass: let me look at concatMap, I haven't used it before
11:01:06 <klrr> ab9rf: this is the exercise -> http://shuklan.com/haskell/lec05.html#/0/23 , here's my first attempt -> http://hpaste.org/85190 , but it doesnt seem to work, why is that?
11:01:13 <dmwit> ?src concatMap
11:01:13 <lambdabot> concatMap f = foldr ((++) . f) []
11:01:17 <dmwit> ugh
11:01:22 <dmwit> concatMap f xs = concat (map f xs)
11:01:37 <typoclass> genk: oh it's just doing map, and concat afterwards
11:01:39 <dmwit> modulo some junk thrown in for efficiency
11:01:45 <aCube> What's the best way to swap two elements in a list?
11:02:03 * hackagebot http-conduit-downloader 1.0.6 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.6 (VladimirShabanov)
11:02:04 <dmwit> klrr: Node isn't the name of a type.
11:02:05 <c_wraith> aCube: I generally find some other way to solve the problem. :)
11:02:31 <klrr> dmwit: oh , but why cant i use a type constructor in there?
11:02:35 <c_wraith> aCube: more seriously, [] isn't a good data structure if you need to do things like that.
11:02:41 <dmwit> klrr: I'm not really sure what you're going for with the Child constructor, though, so I can't really say how to fix it.
11:02:53 <genk> dmwit: I just saw your code, let me try it
11:02:54 <klrr> dmwit: it
11:02:57 <dmwit> klrr: You can (indeed, must) use a type constructor. But Node isn't a type constructor.
11:03:01 <xenon21> klrr: take a look at this -> data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
11:03:03 <klrr> dmwit: it's supposed to be a binary tree
11:03:09 <typoclass> aCube: cut the list up, then construct another list in the desired order? 'cut up' in the sense of (x:xs) or something
11:03:10 <klrr> dmwit: it's not?
11:03:13 <xenon21> it's from the book LYAH
11:03:15 <Mortchek> klrr, it's a data constructor.
11:03:24 <klrr> xenon21: no i dont wanna cheat sry
11:03:30 <klrr> Mortchek: okey
11:03:34 <dmwit> klrr: Haskell has two completely separate namespaces: type level and value level.
11:03:41 <dmwit> klrr: Which can be surprising and is easily forgotten.
11:04:07 <dmwit> klrr: Your declaration is (attempting to) creating one new name at the type level (Tree) and two new names at the value level (Node, Child).
11:04:20 <aCube> Oh wait, I really want permutations :)
11:04:43 <klrr> dmwit: can i fix it somehow without rewritting the design of the implemenetation?
11:04:43 <c_wraith> that's easy. Just use Data.List.permutations! :)
11:05:05 <dmwit> klrr: I'm sure you can. But like I said, I don't really understand what you want from a Child, so I can't give too much guidance here.
11:05:11 <dmwit> klrr: What is a Child supposed to be?
11:05:32 <c_wraith> I still find the choice of implementation for permutations a bit odd. Choosing the laziest version, rather than the fastest version.. I mean, laziness is good, but so is performance.
11:05:34 <Mortchek> klrr, keep in mind that if you had a Child data constructor, you could construct a free-standing value, not necessarily in a tree, that is a Child. What would that mean?
11:05:38 <dmwit> klrr: Maybe you meant something like data Tree = Node Int (Maybe Tree) (Maybe Tree) ?
11:05:43 <klrr> dmwit: a child is the two nodes below a node
11:05:50 <klrr> or sth
11:05:54 <klrr> i donno actually :P
11:06:10 <klrr> dmwit: that's nice idea
11:06:28 <klrr> thanks, but it's sad im too stupid to finish exercise wihtout cheating xD
11:06:49 <dmwit> Not at all. Algebraic types take a bit of practice to get used to.
11:06:55 <xenon21> klrr: yeah, but it's alright just for study.
11:07:03 <ramses_> > let f = fmap ((>>= \(a,b) -> map ((,) a) b) . (zip [2..]) . filter (not . null)) . (map . ((map (+1) .) . elemIndices)) in f 'l' ["lolcats", "stuffl"]
11:07:04 <lambdabot>   [(2,1),(2,3),(3,6)]
11:07:15 <ramses_> hehe :)
11:08:14 <dmwit> klrr: Take heart, and keep chugging through more and more exercises. That's my 100% proven advice.
11:08:27 <dmwit> SCIENCE
11:09:29 <klrr> :)
11:11:32 <xenon21> klrr: i recommend the 8th chapter from LYAH. it explains the type constructor and the value constructor clearly :)
11:12:50 <klrr> xenon21: just read it :P
11:13:03 <klrr> maybe not carefully enough though :/
11:14:23 <ab9rf> read it again, haskell stuff takes a few passes to fully understand often enough :)
11:14:40 <__xc> why couldn't there be infinite enumerable
11:15:04 <elliott> there is an infinite Enum instance (Integer), but it has to cheat.
11:15:13 <elliott> in particular, fromEnum
11:15:14 <__xc> {0,1,2} with succ 2 = 0
11:15:16 <mapf> :i hashUnique
11:15:33 <danharaj> I am a horrible person.
11:15:45 <typoclass> danharaj: thanks for the heads-up
11:15:46 <danharaj> I made attribute grammars compute breadth first search for me.
11:16:26 <__xc> elliott, yes was thinking to other Z/nZ sets
11:16:26 <elliott> __xc: that is explicitly forbidden if you also derive Bounded
11:16:38 <klrr> i dont think the problem is me not understanding types, it's me not understanding *"%¤¤""# binary trees
11:16:44 <elliott> and more generally, goes counter to other Enum instances, and the default methods may behave weirdly, etc. note: I think this is a misdesign, but it's how it is
11:16:58 <elliott> also it's not entirely clear how to interpret a range in that setting
11:17:04 <__xc> yet maxBound in {0,1,2} wouls still return 2
11:17:21 <elliott> then that violates the laws
11:17:35 <elliott> "For any type that is an instance of class Bounded as well as Enum, the following should hold:
11:17:38 <__xc> hmm right
11:17:38 <elliott> The calls succ maxBound and pred minBound should result in a runtime error."
11:17:39 <lesile> hi, i just recieved my assignment. I have to create a online website scheduling system that link in with sms and outlook.. and need a simple guide how to do this.. i.e. use access or mysql and and use xyz and do etc... It's been over 10 years since I touched programming.
11:17:59 <quchen> Welcome to #haskell.
11:18:01 <lesile> vb6 was the latest when I grad. colletge
11:18:10 <quchen> This is a Haskell channel.
11:18:17 <armlesshobo> lol
11:18:17 <elliott> __xc: more generally, I think it's expected that succ p > p, and p > pred p, where defined
11:18:41 <klrr> <- me cheated instead
11:18:45 <lesile> quched, haskell is a programming channel right?
11:18:46 <elliott> (though Enum doesn't require Ord either)
11:18:48 <klrr> idiotic but convenient
11:18:56 <elliott> lesile: this channel is specifically about the Haskell functional programming language
11:19:01 <elliott> not programming in general
11:19:01 <__xc> elliott, yes the Ord relation also, ok thx
11:19:03 <quchen> lesile: #haskell is about programming as much as onions are about cooking.
11:19:32 <xenon21> maybe you could ask at SO :)
11:19:33 <lesile> ic can you give me the irc channell for web programming /development channel?
11:19:38 <armlesshobo> #haskell is about spatulas :P
11:19:52 <lesile> thx in advance quchen
11:19:59 <sproingie> i thought it was about burritos
11:20:05 <quchen> lesile: Unfortunately no, but I think you can find references to those online. I haven't been anywhere but in #haskell on Freenode so far.
11:20:25 <quchen> Maybe check your client's channel list?
11:20:34 <typoclass> lesile: that seems like a long, elaborate project :-) you might want to start with learning some basic haskell. lyah is a good book available for free
11:20:37 <typoclass> @where lyah
11:20:37 <lambdabot> http://www.learnyouahaskell.com/
11:21:09 <elliott> they left
11:21:23 <elliott> but also, I doubt they were planning to do it in Haskell :)
11:21:33 <ChongLi_> just a subtle form of trolling
11:21:39 <__xc> he right I guess
11:22:02 <__xc> there ae numerous of them on SO
11:22:44 <klrr> what does fromIntegral do? (didnt get hoogles explaination)
11:23:04 <danharaj> :t fromIntegral
11:23:05 <lambdabot> (Integral a, Num b) => a -> b
11:23:15 <otters> klrr: it's numeric type conversion
11:23:19 <danharaj> fromIntegral 1 :: Double
11:23:20 <typoclass> klrr: it's a universal conversion function for numbers
11:23:24 <danharaj> > fromIntegral 1 :: Double
11:23:26 <lambdabot>   1.0
11:23:34 <danharaj> > fromIntegral 1 :: Rational
11:23:36 <lambdabot>   1 % 1
11:23:43 <otters> > fromIntegral (2 ^ 64) :: Int
11:23:44 <lambdabot>   0
11:24:01 <klrr> otters: okey, so it what does it do?
11:24:09 <otters> all those things
11:24:13 <__xc> > fromIntegral pi :: Rational
11:24:15 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:24:15 <lambdabot>    (GHC.Float.Floating a0)...
11:24:21 <klrr> i dont get it
11:24:25 <otters> klrr: it converts numbers to other types
11:24:28 <klrr> ?src fromIntegral
11:24:29 <lambdabot> fromIntegral = fromInteger . toInteger
11:24:32 <otters> :t round
11:24:33 <lambdabot> (Integral b, RealFrac a) => a -> b
11:24:45 <hpaste> pamojarpan revised “filenum”: “--” at http://hpaste.org/85160
11:25:02 <klrr> otters: so, it take a type and a type and returns the first type as the second?
11:25:26 <otters> in so many words
11:25:44 <xenon21> :info Integral
11:25:44 <otters> it takes a number in the typeclass Integer and returns a number in the typeclass Num
11:26:14 <klrr> otters: okey, that explains it better :D how do you specify what type it gonna return?
11:26:48 <otters> klrr: normally what you'd use fromIntegral for is, say, if you have an Int and you're passing it to a function that needs a Double
11:27:11 <xenon21> :t fromIntegral
11:27:13 <lambdabot> (Integral a, Num b) => a -> b
11:27:15 <otters> that way you can just do yourFunc (fromIntegral someNumber)
11:27:22 <otters> and it magically converts to the equivalent Double
11:27:28 <klrr> now i get it, thanks! :D
11:27:29 <otters> klrr: you can also use an explicit typecast
11:27:33 <otters> > fromIntegral 1 :: Rational
11:27:35 <lambdabot>   1 % 1
11:28:30 <__xc>  > fromIntegral (1%1) :: Doublel
11:28:33 <andrew> Can anyone tell me why this takes forever to compute?
11:28:33 <andrew> http://hpaste.org/85192
11:28:38 <__xc> > fromIntegral (1%1) :: Double
11:28:40 <lambdabot>   Not in scope: `%'
11:28:40 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
11:28:59 <Guest29682> I know the issue is in my recurrsion I just dont know where
11:29:01 <otters> > fromIntegral (1 R.% 1) :: Double
11:29:03 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio a0))
11:29:03 <lambdabot>    arising from a u...
11:29:32 <__xc> > fromIntegral 1.0 :: Int
11:29:33 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:29:34 <lambdabot>    (GHC.Real.Fractional a0...
11:29:40 <Williams> is there an equivalent for converting from double to int?
11:29:45 <otters> :t round
11:29:47 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:50 <otters> :t truncate
11:29:50 <danharaj> :t truncate
11:29:51 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:52 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:58 <otters> :t floor
11:29:59 <lambdabot> (Integral b, RealFrac a) => a -> b
11:30:17 <Williams> oh of course
11:30:53 <klrr> can someone explain what "it" does , in this scenario : http://shuklan.com/haskell/lec06.html#/0/10 ?
11:30:55 <danharaj> Guest29682: the last case does not ever get checked because the pattern (x,y) matches anything of the form (x, 1000) first.
11:31:08 <danharaj> Guest29682: also you should not use number patterns, use guards instead.
11:31:28 <otters> klrr: "it" is the previous result
11:31:28 <Mortchek> danharaj, what's wrong with number patterns?
11:31:29 <__xc> integral is the family of Int, Int8, Int16, Integer..?
11:31:36 <otters> klrr: in ghci
11:31:54 <Guest29682> danharaj: dohhh
11:32:04 * hackagebot fixed-vector 0.4.0.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.4.0.0 (AlexeyKhudyakov)
11:32:23 <danharaj> Mortchek: http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010#
11:32:44 <elliott> er?
11:32:48 <elliott> those aren't n+k patterns
11:32:50 <xenon21> Guest29682: try reordering the patterns, the edge condition(the last one) is never going to be evaluated
11:32:55 <elliott> pattern-matching on numeric literals is perfectly fine and not removed at all
11:33:14 <Mortchek> danharaj, that doesn't answer my question.
11:33:16 <elliott> n+k patterns are of the form "f (n+k) = ..." (for some constant k)
11:33:59 <danharaj> elliott: matching on numeric literals is kind of poor form imo
11:33:59 <klrr> ?src foldl
11:34:00 <lambdabot> foldl f z []     = z
11:34:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:34:10 <danharaj> elliott: it is kind of error prone
11:34:12 <Mortchek> danharaj, but why?
11:34:21 <genk> typoclass: do you have any time?
11:34:29 <elliott> danharaj: I don't see why... it has a well-defined, simple desugaring in terms of Num and Eq, and is much more readable when dealing with nested patterns
11:34:35 <elliott> do you avoid pattern-matching on Chars too?
11:34:36 <danharaj> Mortchek: Because ordering your pattern matches to get all your cases right is tricky because of the way pattern match fallthrough works.
11:34:48 <hpaste> genk pasted “findAgent2” at http://hpaste.org/85193
11:35:05 <klrr> is foldl like map, but it lets the function in question also take two parameters and also returns the total value, not a list?
11:35:11 <Mortchek> danharaj, you have to order your patterns correctly for *any* type.
11:35:15 <otters> > foldl f [a,b,c]
11:35:16 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
11:35:17 <lambdabot>                     [Deb...
11:35:22 <Mortchek> danharaj, I'm wondering what your argument specifically for numbers is.
11:35:23 <otters> > foldl f a [b,c,d]
11:35:25 <lambdabot>   f (f (f a b) c) d
11:35:39 <Mortchek> And using guards doesn't obviate the needs to order your cases correctly.
11:35:40 <genk> map (elemIndices 'l') ["lolcats", "the lolcats"]
11:35:43 <Guest29682> Removed the 0,0 pattern aswell since it was usless
11:35:45 <otters> > foldl (:) [] [1..10]
11:35:47 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
11:35:49 <otters> rats
11:35:54 <otters> > foldr (:) [] [1..10]
11:35:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:36:00 <genk> > map (elemIndices 'l') ["lolcats", "the lolcats"]
11:36:02 <lambdabot>   [[0,2],[4,6]]
11:36:16 <danharaj> Mortchek: Usually when you are doing numeric stuff you are also going to have guards of the form (x == y) etc. and IMO it is better to have all your conditions listed as guards than have pattern matching on literals and then guards.
11:36:45 <Kaidelong> klrr: map is an example of foldr, actually. Although what you said seems right
11:36:46 <genk> > let f x yss = do { (r, ys) <- zip [0..] yss; (c, y) <- zip [0..] ys; guard (y == x); return (r, c) } in f 'l' ["lolcats", "stuffl"]
11:36:48 <lambdabot>   [(0,0),(0,2),(1,5)]
11:36:56 <Kaidelong> I mean, not exactly right but not wrong-minded
11:36:58 <Mortchek> danharaj, why is that better?
11:37:09 <genk> this works but I have no idea why
11:37:23 <Kaidelong> map f = foldr ((:) . f) []
11:37:49 <otters> @pl \a b -> f b : a
11:37:49 <lambdabot> flip ((:) . f)
11:38:33 <klrr> what's scanl?
11:38:34 <Kaidelong> oh yeah, it does need to be flipped doesn't it?
11:38:34 <typoclass> genk: i think the author said "just for fun" afterwards :-) it wasn't meant completely seriously
11:38:35 <Kaidelong> herp
11:38:59 <danharaj> Mortchek: because it is easier to read a list of guards and tell what case is what then a list of patterns each with a list of guards, some of the guards being duplicates across pattern matches.
11:39:07 <danharaj> s/then/than
11:39:09 <Mortchek> I see.
11:39:11 <otters> :t a
11:39:13 <lambdabot> Expr
11:39:34 <typoclass> genk: so, i'd recommend this as the starting point --
11:39:35 <typoclass> > zip [0..] (map (elemIndices 'l') ["lolcats", "the lolcats"])
11:39:36 <lambdabot>   [(0,[0,2]),(1,[4,6])]
11:39:39 <Mortchek> danharaj, can you think of an example where this might get in the way?
11:39:43 <danharaj> elliott: to answer, I use patternguards :P
11:39:58 <xenon21> klrr: like foldl but shows you the accumulator state and the final result too
11:40:15 <xenon21> states
11:40:21 <klrr> are there any good explainations of scanl? the lyah is not good for less intellegent people, and it was the only one showing up in google
11:40:27 <danharaj> Mortchek: not off hand
11:40:37 <klrr> xenon21: that's almost same as lyah one
11:41:27 <xenon21> klrr: yeah, i actually take from it :)
11:41:51 <klrr> hehe :)
11:42:13 <klrr> what's the accumelator? (why even use so difficult words :P )
11:42:35 <typoclass> genk: you could use 'map' on this list. the function would have to process each of those tuples (consisting of a number and a list). this will look something like "map (\(idx, list) -> ...)". in the place of "...", you'd produce a list of your desired format (you mentioned it initially, i think it was [(3,0), (3,2)])
11:43:30 <klrr> can someone tell the practical difference between "." and "$" ? i dont really see big difference, so where should i use the one and the other?
11:43:33 <glguy> > let findAll x xs = xs ^@.. itraversed . itraversed . filtered (x==) in findAll 'l' ["lolcats", "the lolcats"]
11:43:35 <lambdabot>   [(0,'l'),(2,'l'),(4,'l'),(6,'l')]
11:44:00 <glguy> klrr: (.) composes two functions and gives you one back, ($) takes one function and one argument to that function
11:44:51 <Mortchek> :t (.)
11:44:52 <klrr> glguy: yes i know, but i dont see the difference in use, i mean, where should i write "(not.odd) 4" or "not $ odd 4"?
11:44:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:44:53 <Mortchek> :t ($)
11:44:53 <genk> typoclass: sorry I have been disconnected. what do you suggest to go further from your example
11:44:55 <lambdabot> (a -> b) -> a -> b
11:45:02 <otters> map ((+1) . (+3)) [1..10]
11:45:05 <otters> > map ((+1) . (+3)) [1..10]
11:45:06 <__xc> > let fcons = flip (:) in foldl fcons [] [1..10]10]
11:45:07 <lambdabot>   [5,6,7,8,9,10,11,12,13,14]
11:45:08 <lambdabot>   can't find file: L.hs
11:45:08 <typoclass> klrr: the key thing about $ is that its precedence is so low
11:45:16 <glguy> klrr: you should write not (odd 4)
11:45:23 <glguy> :-)
11:45:30 <xenon21> klrr: take a look from the example (LYAH again :-D)
11:45:33 <glguy> In this case it's a matter of taste
11:45:34 <Mortchek> klrr, if the two are effectively the same in context, it's a matter of judgment
11:45:45 <typoclass> genk: try this, near the bottom :-) http://tunes.org/~nef/logs/haskell/13.04.04
11:45:45 <xenon21> > scanl (+) 0 [1,2,3,4]
11:45:48 <lambdabot>   [0,1,3,6,10]
11:45:49 <klrr> but both . and $ is to remove parantheses right?
11:45:49 <glguy> klrr: it matters when you do things like:   map (f . g) xs
11:45:55 <otters> no
11:45:59 <otters> $ is to remove parentheses
11:46:49 <tromp_> choosing between not (odd 4),  not . odd $ 4,  not $ odd 4, is a matter of preference
11:46:49 <klrr> well, then why do the haskellers usually say "writting f(g(h(x))) is ugly, (f.g.h)(x) is beutiful"?
11:46:51 <glguy> > let findAll x xs = xs ^@.. icompose (,) itraversed itraversed . filtered (x==) in findAll 'l' ["lolcats", "the lolcats"] -- there we go ^_^
11:46:53 <lambdabot>   [((0,0),'l'),((0,2),'l'),((1,4),'l'),((1,6),'l')]
11:47:39 <glguy> klrr: people like (f.g.h) x      because they can cut the "f.g" part out and name it and replace what they cut with that name
11:47:41 <tromp_> f . g . h $ x  has less clutter
11:48:23 <typoclass> klrr: good question :-) personally, i find both of them not very pretty
11:48:25 <Mortchek> Sometimes you get long chains of function application and you don't want a bunch of ))))) noise at the end
11:48:35 <Mortchek> So (.) is perfect for that
11:49:31 <amindfv> does acid-state have something like Control.Monad.State.withState? (so i don't have to explicitly write get/put/return for each update function?)
11:50:13 <genk> typoclass: let me give it a try :)
11:50:52 <typoclass> genk: sure. you'll end up with a list of lists, so you're only one 'concat' away from the final list
11:52:26 * hackagebot sundown 0.5.0.2 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.5.0.2 (FrancescoMazzoli)
11:52:28 <Guest29682> http://hpaste.org/85194 Fixed my recurrsion bug but now its giving me the wrong answer, for 1 - 10 it'll return 22 rather than 23
11:53:16 <Guest29682> :S
11:54:05 <Mortchek> Guest29682, are you required to implement this with a recursive function definition? Because there are easier ways.
11:54:15 <Guest29682> nope
11:54:23 <Guest29682> Its not homework its from project euler
11:54:29 <Mortchek> Great, do you know about list comprehensions?
11:54:37 <Guest29682> nope
11:55:03 <klrr> hhhasskell is not good
11:55:31 <armlesshobo> > foldr (+) 0 [1..10]
11:55:32 <Mortchek> Guest29682, read this section and see if you can implement it using what you learn here: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
11:55:32 <lambdabot>   55
11:56:22 <dolio> > let divisibleBy n | n `mod` 3 == 0 = 0 | n `mod` 5 == 0 = 0 | otherwise = n in map divisibleBy [1..10]
11:56:23 <lambdabot>   [1,2,0,4,0,0,7,8,0,0]
11:56:33 <dolio> > let divisibleBy n | n `mod` 3 == 0 = 0 | n `mod` 5 == 0 = 0 | otherwise = n in sum $ map divisibleBy [1..10]
11:56:34 <lambdabot>   22
11:56:48 <Guest29682> But it should be 23 :(
11:56:56 <typoclass> dolio: that example seems to be lacking a certain buzz
11:57:17 <dolio> The problem description says that 3 + 5 + 6 + 9 = 23.
11:57:18 <Guest29682> Mortchek: I've been reading that book, i'll go read that secton
11:57:21 <dolio> > 3 + 5 + 6 + 9
11:57:22 <lambdabot>   23
11:57:29 <dolio> Notice which numbers are not in that list.
11:57:55 <Guest29682> ohhhhhh
11:58:01 <dolio> :)
11:58:06 <Guest29682> Damn brain
11:59:32 <Guest29682> I should remember to play with prelude for debugging in future
11:59:57 <ChongLi> the list comprehension expresses it more cleanly I think
12:00:04 <ChongLi> > sum [n | n <- [0..9], n `mod` 3 == 0 || n `mod` 5 == 0]
12:00:06 <lambdabot>   23
12:00:08 <Guest29682> I was actually learning about map & filter in class
12:00:14 <Guest29682> I just never though to use a range
12:00:48 <Mortchek> You can actually express a lot of problems either as list comprehensions or with map and filter
12:01:01 <Mortchek> This one's no exception
12:01:52 <Guest29682> I enjoy recursion though :(
12:02:08 <genk> typoclass: can you explain how map (\(idx, list) -> ...) works, i could not understand
12:02:25 <xenon21> > let divisibleBy n | n `mod` 3 == 0 = 0 | n `mod` 5 == 0 = 0 | otherwise = n in sum $ map divisibleBy [1..9]
12:02:27 <lambdabot>   22
12:02:36 <xenon21> sorry
12:02:45 <xenon21> > let divisibleBy n | n `mod` 3 == 0 = n | n `mod` 5 == 0 = n | otherwise = 0 in sum $ map divisibleBy [1..9]
12:02:47 <lambdabot>   23
12:02:52 <Mortchek> Recursion's an implementation detail, and it's definitely appropriate for many problems. But if the primitives already exist in the language, it's probably easier just to use those
12:03:05 <Mortchek> I'm not saying don't play with recursion
12:03:35 <Mortchek> But if your goal is to write a function rather than to play with recursion, then I'd reach for the folds and map and filter and such
12:03:37 <xenon21> you switched the positions of '= 0' and '= n'
12:04:16 <Guest29682> xenon21: Yea I fixed it
12:04:22 <Guest29682> :)
12:05:08 <ChongLi> one example I find quite beautiful is the choose function from this tutorial by SPJ
12:05:13 <ChongLi> https://www.fpcomplete.com/user/simonpj/beautiful-concurrency/4-the-santa-claus-problem
12:05:56 <Guest29682> on to problem two
12:06:04 <ChongLi> it uses a list comprehension to build up a list of actions and then folds over them
12:06:20 <typoclass> genk: well it's not done yet. you need to put stuff where the "..." is. what it does is create a function (\... -> ...), also known as a lambda. this is because 'map' expects you to give a function as the first argument. (idx, list) in that place is a pattern-match on a tuple, meaning as 'map' passes in the tuples from the input list [(0,[stuff]), (1,[otherstuff])], we take them apart, giving the name 'idx' to 0 and the name 'list' to [stu
12:06:25 <ChongLi> it's a custom control structure that is very elegant
12:07:18 <typoclass> genk: oh and in (\... -> ...), the left side indicates the arguments that this function expects, and the right side gives the result value of that function
12:07:49 <Guest29682> Haskell having no loops causes me issues coming from a imperative language
12:08:12 <ion> Haskell has no loops?
12:08:39 <tromp_> > mapM_ print [0..9]
12:08:41 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
12:08:41 <lambdabot>    arising from a use of ...
12:08:45 <ChongLi> Guest29682: Haskell has loops, they're just not built into the language :)
12:08:48 <tromp_> there's your loop
12:08:56 <jorgno> I'm wondering if anyone can tell me why I get this error: http://hpaste.org/85195, I don't understand why GHC can't deduce the that it is correct, the code that produced the error: http://hpaste.org/85196, complete code here: https://github.com/nordmoen/IT3708-EA
12:09:03 <genk> typoclass: starting to figure it out, i'll try some more, thanks :)
12:09:18 <Mortchek> >> for [1..10] (\x -> [2 * x, 3 * x])
12:09:21 <Mortchek> > for [1..10] (\x -> [2 * x, 3 * x])
12:09:23 <lambdabot>   Not in scope: `for'
12:09:23 <lambdabot>  Perhaps you meant one of these:
12:09:23 <lambdabot>    `Data.Traversable.f...
12:09:42 <typoclass> genk: check back with the channel if you're having too much trouble filling in the "...". by the way, you can ask anyone :-) not just me
12:09:46 <Mortchek> > Data.Traversable.for [1..10] (\x -> [2 * x, 3 * x])
12:09:48 <lambdabot>   [[2,4,6,8,10,12,14,16,18,20],[2,4,6,8,10,12,14,16,18,30],[2,4,6,8,10,12,14,...
12:09:51 <elliott> jorgno: your fundep looks the wrong way around
12:10:03 <Mortchek> That was a bad example and not really what I remembered that doing :P
12:10:09 <typoclass> Guest29682: "a loop is a list waiting to happen" ;-)
12:10:13 <elliott> jorgno: you are writing Phenotype b BitArray => BitArray -> b
12:10:21 <elliott> jorgno: but the fundep goes like b -> BitArray, not BitArray -> b there
12:10:24 <applicative> jorgno: is Bitarray a synonymn for [Bool]?
12:10:29 <elliott> perhaps it should be develop         :: (Phenotype a b)  => a -> b
12:10:31 <kartoffelbrei> "Data.Traversable.f..." is lambdabot now censoring itself?
12:10:32 <tromp_> > map succ "IBM"
12:10:32 <elliott> or the fundep should be | b -> a
12:10:33 <lambdabot>   "JCN"
12:10:35 <elliott> applicative: yeah, see line one of the paste
12:10:36 <applicative> oh elliot figured it out
12:10:42 <genk> typoclass: ok i will. you are very helpful, thank you very much for the great advices :)
12:10:43 <tromp_> > map pred "IBM"
12:10:44 <lambdabot>   "HAL"
12:10:58 <jorgno> applicative: Yes it is, just for testing the code
12:11:08 <ChongLi> "I'm sorry Dave"
12:11:09 <applicative> the browser way of using freenode has the obnoxious feature of stopping the feed while you type
12:11:13 <Rotaerk> tromp_, wonder if that's a coincidence
12:11:43 <ab9rf> > map succ "IBM"
12:11:44 <typoclass> genk: you're welcome ;-)
12:11:45 <lambdabot>   "JCN"
12:12:01 <ab9rf> wonder what that stands for
12:12:09 <ab9rf> japanese computer noogies?
12:12:14 <jorgno> elliott: The problem is that both a and b in the declaration should be Bitarray
12:12:26 <ab9rf> the actual answer is "NCR"
12:12:31 <kartoffelbrei> Jupiter Code Nutjobs
12:12:33 <ab9rf> IBM was 'succ NCR' in a very real way
12:13:00 <jorgno> elliott: develop should go from a genotype to a phenotype
12:13:02 <ab9rf> watson chose the name to be "bigger" than National Cash Register
12:15:37 <elliott> jorgno: well, this may be a program structure issue
12:15:45 <elliott> but GHC is right to tell you that you are assuming things that might not be true
12:15:55 <elliott> you could give an instance Phenotype () BitArray
12:16:08 <elliott> then you can clearly see id would not satisfy the type Phenotype b BitArray => BitArray -> b
12:17:58 <jorgno> elliott: I guess it is strange if GHC gives me the same error when changing the Phenotype instance to Phenotype () Bitarray
12:18:18 <elliott> well, it's simple: your fundep doesn't let you deduce what you want
12:18:21 <elliott> if you reversed it, it should
12:18:28 <typoclass> ab9rf: how exactly does JCN stand for NCR?
12:19:14 <jorgno> elliott: reversed it? I don't quite get what you mean by that
12:20:14 <elliott> jorgno: as in, if your fundep was | b -> a
12:20:16 <elliott> not | a -> b
12:20:18 <elliott> in the class definition
12:20:55 <elliott> you know that b (confusingly, called "a" in your other class, since you swap the order, but...) is Bitarray, and you're trying to deduce that a is Bitarray, but the functional dependency you have only goes the other way around
12:21:03 <applicative> jorgno: could you put develop under the head of phenotype instead, this solves everything
12:21:46 <jorgno> elliott: But logically should it not go from a phenotype to a genotype since a genotype can be developed into many phenotypes, but a phenotype can only have one genotype
12:22:31 <elliott> I agree that there's probably a modelling error here. is applicative's solution viable?
12:24:00 <jorgno> applicative: I don't think that would be correct logically since a genotype must be developed into a phenotype, http://hpaste.org/85197 here is the code which uses these instances to give it a bit more background and it should there make a bit more sense
12:25:11 <applicative> jorgno: if you think of genotypes as DNA sequences that can mutate etc., theres no need to mention phenotypes at all, then you bring in phenotype - genotype connections together to explain fitness etc
12:25:33 <genk> i am trying to find the x,y coordinates of occurrences of an element in a list of lists. then i want to store these coordinates in a tuple. i came to -- zip [1..] (map (elemIndices element) list) -- but this returns -- [(1,[y1,y2]),(2,[y3,y4])] -- where 1 and 2 are x coordinates and yi are the y coordinates. i want to break this list so that it turns into -- [(1,y1),(1,y2),(2,y3),(2,y4)] -- which is my desired representation. typocla
12:25:37 <genk> and suggested that i can use -- map (\(idx, list) -> ...) -- where in the place of "..." i would produce a list of my desired format, and maybe a concat away from the solution. but i am stuck here and cannot figure it out. i am really confused. any help is appreciated.
12:26:07 <applicative> jorgno: by the way if you declare Phenotype a b then Genotype b needn't be explicit
12:26:31 <armlesshobo> i understand IO actions are unpredictable regarding actually getting executed, but isn't there a semantic way of trying to force order? using (>>) doesn't necessarily help
12:26:48 <armlesshobo> i'll paste an example
12:27:19 <jorgno> applicative: Genotype is like the DNA yes, but every use needs a Phenotype, which is the developed "creature". So I might want to create a Bitarray Genome, but create an ANN using that Bitarray, but I might also want to create a different Phenotype which also uses the Bitarray Genome
12:28:20 <applicative> jorgno: yes, you can do that if you get reference to Phenotype out of Genome itself
12:28:37 <applicative> the phenotype tells you what interpretation of genotype its working with
12:29:03 <applicative> by the way, the other bit of code you attached also compiles with my proposed revision.
12:29:34 <jorgno> applicative: Moving develop into the Phenotype?
12:30:05 <applicative> yes
12:30:21 <applicative> and moving the failing instance in the other module of course
12:31:52 <jorgno> Ok, well I just finds it stange, because the Genotype should develop into the Phenotype, since fitness makes little sense in the Genotype, one would messure fitness one a human's ability to run and not the DNA of that human
12:32:00 <applicative> jorgno: I think these mutually referential type classes are a bit of a problem.  Really you should just settle on one true Genotype type, I'd think, like Vector Int or something
12:33:06 <elliott> jorgno: it might help to think of your class hierarchy independently of what you're modelling.
12:33:23 <elliott> what you're trying to express surely makes logical sense, but if you look at what you're actually telling Haskell, you can see that you're asking for something that doesn't make sense :)
12:34:07 <jorgno> elliott: Ok, but how would I go about doing it, the current design is due this SO question: http://stackoverflow.com/questions/15766904/redesign-of-haskell-type-classes
12:34:37 <applicative> jorgno: the thing is you don't put enough in Phenotype to give any definition of develop a hook
12:34:43 <elliott> I suspect I don't have enough domain knowledge to model the problem effectively
12:35:43 <hpaste> armlesshobo pasted “IO order” at http://hpaste.org/85198
12:35:44 <applicative> jorgno: if you put developPhenotype under phenotype, then at least then the develop under Genotype could be defined.
12:37:29 <jorgno> applicative: My intention with the class declaration was for it to be extensible, so if I wanted a bitarray and an ANN I could reuse the mutate and crossover functions, but just redefine the develop and create a new Phenotype instance. My problem is that I have a problem designing this in a functional way, I have already done it in Python which might hinder me more than help at the moment
12:37:30 <applicative> armlesshobo: should main = putStr ">>" >> etc, ?
12:38:35 <armlesshobo> applicative: the goal is to build an initial list to search against and then loop
12:38:43 <armlesshobo> once the loop begins, first output the ">>"
12:38:52 <armlesshobo> and then get the line
12:39:01 <armlesshobo> (and continue onward)
12:39:43 <Adeon> doesn't the output system work so that it doesn't flush unless you put in a newline
12:41:21 <ChongLi> :t System.IO.hSetBuffering
12:41:22 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Handle.Types.BufferMode -> IO ()
12:42:12 <ChongLi> just set to NoBuffering and you're good to go
12:42:35 <Adeon> in other words, this has nothing to do with haskell being lazy
12:43:07 <Adeon> putStr ">>" waits until a newline before anything goes to standard output
12:43:14 <Adeon> you can set NoBuffering or flush the stream explicitly
12:43:19 <Adeon> I think
12:43:40 <ChongLi> yes
12:43:58 <armlesshobo> i see
12:44:15 <armlesshobo> so i should use hSetBuffering stdout NoBuffering
12:45:15 <genk> typoclass: i am sorry but i am really stuck at this point and cannot figure it out. noone else seems to respond :)
12:45:25 <quchen> No buffering is usually a bad idea when you're sending out lots of data.
12:45:31 <quchen> That's what buffering is for after all.
12:45:57 <armlesshobo> quchen: fortunately, that wouldn't apply here. :)
12:53:10 <pmade> Is there a way to write a function that can take as an argument either a ByteString or a Text?  It doesn't do anything with that argument, it pattern matches on another argument and dispatches to another function.
12:53:47 <tromp_> sure'; define a typeclass for it
12:54:05 <pmade> tromp_: okay, that's a good idea.
12:56:42 <armlesshobo> doing hSetBuffering stdout NoBuffering resolved the issue
12:58:26 <danharaj> edwardk: My little side project has led me to implement breadth-first search attributively, and there is structure here I do not understand.
13:02:36 * hackagebot sundown 0.5.1 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.5.1 (FrancescoMazzoli)
13:02:37 <danharaj> edwardk: I am not sure if you got that message I wrote?
13:02:38 * hackagebot fb 0.14.3 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.3 (FelipeLessa)
13:05:32 <Rotaerk> hmm so far I've only seen typeclasses used for commonly used generic abstractions; do you guys in practice use them also for abstracting details from your functions, like interfaces are used in OO languages?
13:05:37 <armlesshobo> edwardk: i'm digging the whole letting the hair grow out thing. I've been doing it myself :P
13:05:52 <armlesshobo> i'm just waiting for my employers to say anything before I get it cut.
13:06:03 <Rotaerk> armlesshobo, typing with your toes?
13:06:11 <edwardk> armlesshobo:
13:06:17 <simpson> armlesshobo: Hopefully your employers don't care.
13:06:27 <armlesshobo> Rotaerk: I use my face.
13:06:35 <armlesshobo> simpson: yeah, it would be awesome.
13:06:36 <edwardk> armlesshobo: My wife is particularly fond of it long, so I haven't had much choice. ;)
13:06:42 <armlesshobo> edwardk: mine is too, ha
13:06:53 <armlesshobo> edwardk: she likes when I put it back in a ponytail
13:07:09 <Rotaerk> I don't like long hair; too much maintenance
13:07:36 * hackagebot fb 0.14.4 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.4 (FelipeLessa)
13:08:00 <armlesshobo> Rotaerk: it's not so bad. the only bad thing was it getting stuck in my arms or back when I toss and turn
13:08:10 <Rotaerk> ah
13:08:38 <armlesshobo> it's cool because I can dress up as a swashbuckler :)
13:08:42 <armlesshobo> or a pirate
13:08:43 <armlesshobo> :)
13:09:36 <int-e> @tell stepcut is the patch mentioned in http://code.google.com/p/happstack/issues/detail?id=225 available anywhere?
13:09:36 <lambdabot> Consider it noted.
13:09:45 <Rotaerk> hmm, and regarding my question:  an example case I'm considering using it for, if i were writing chess, the chess board could be represented in a variety of ways
13:10:10 <dgpratt> :seen copumpkin
13:10:14 <Rotaerk> so would you make a chessboard typeclass, and implement it with one of those ways, writing your functions in terms of the typeclass instead of the concrete types
13:11:11 <armlesshobo> Rotaerk: can more than one thing be part thise ChessBoard typeclass?
13:11:13 <Rotaerk> or is there another more appropriate mechanism for that
13:11:19 <armlesshobo> Rotaerk: what other types can be a ChessBoard?
13:11:49 <Rotaerk> well it could be a Map from 2-tuple to some kind of state for each cell
13:11:54 <Rotaerk> or it could be an array
13:12:34 <Rotaerk> and might be others... and I'd make my choice of which for performance concerns
13:12:38 * hackagebot fb 0.14.4.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.4.1 (FelipeLessa)
13:12:46 <armlesshobo> It seems that ChessBoard is a specific type
13:12:57 <armlesshobo> that would belong to one or more typeclasses
13:13:17 <danharaj> edwardk: got a moment to spare?
13:13:49 <Rotaerk> armlesshobo, hmm it can't be a specific type unless there was 1 clear way of representing it
13:14:10 <Rotaerk> and that doesn't seem to be the case
13:14:37 <armlesshobo> of course it could. You would subsequently represent it's possible value with the appropriate constructor
13:15:12 <armlesshobo> data ChessBoard = Chessboard <fill in the gaps>
13:15:56 <Rotaerk> hmm i guess if I'm just trying to abstract implementation details for flexibility in performance optimization, then I don't need the ability to have multiple implementations side by side within the same program
13:16:21 <Rotaerk> and as such, I can just use an abstract data type (i.e. I don't expose the ctors)
13:17:38 * hackagebot json-fu 0.0.0 - Generic JSON serialization / deserialization  http://hackage.haskell.org/package/json-fu-0.0.0 (SimonHengel)
13:18:12 <edwardk> danharaj: somewhat. whats up?
13:18:53 <danharaj> edwardk: I implemented depth-first and breadth-first traversals as part of my side learning on attribute grammars. dfs is easy. bfs was tricky, and horribly asymmetric. http://hpaste.org/85199
13:19:12 <edwardk> danharaj: you should just use the traversal for it
13:19:49 <danharaj> edwardk: I know, I know. This is just a kind of silliness to see how expressive attributes can get. There's trickiness here I don't quite understand yet.
13:20:12 <edwardk> > ["hello","world]^..levels traverse . traverse
13:20:14 <lambdabot>   <hint>:1:46:
13:20:14 <lambdabot>      lexical error in string/character literal at end of input
13:20:19 <edwardk> > ["hello","world"]^..levels traverse . traverse
13:20:20 <lambdabot>   Ambiguous occurrence `levels'
13:20:20 <lambdabot>  It could refer to either `Data.Tree.levels',...
13:20:27 <edwardk> > ["hello","world"]^..Lens.levels traverse . traverse
13:20:29 <lambdabot>   ["hello","world"]
13:20:36 <edwardk> > ["hello","world"]^..Lens.levels (traverse.traverse) . traverse
13:20:38 <lambdabot>   "hewlolrold"
13:21:02 <danharaj> heh, cool. I can implement dijkstra's algorithm using a variation of how I implemented bfs though! :P
13:23:10 <tom4939> Is anybody aware of the differnce between https://research.microsoft.com/en-us/um/people/simonpj/papers/c--/hoopl-haskell10.pdf and http://www.cs.tufts.edu/~nr/pubs/dfopt.pdf
13:23:17 <Ontolog> looking at this: http://learnyouahaskell.com/recursion#quick-sort while cool and all it would seem that the whole point is lost if the array (list) is not sorted in-place
13:23:23 <tom4939> That's: "Hoopl: Dataflow Optimization Made Simple" vs "Hoopl: A Modular, Reusable Library for
13:23:26 <tom4939> Dataflow Analysis and Transformation"
13:24:26 <elliott> Ontolog: yeah, the standard quick sort example is bad as an actual sort
13:24:28 <c_wraith> Ontolog: you can't sort an immutable structure in place.
13:24:31 <elliott> mergesort is used for lists in practice
13:25:13 <c_wraith> in practice, mergesort (or really complex variants of it) are used by everything.
13:25:21 <Ontolog> i see
13:25:31 <c_wraith> It has better cache use properties than quicksort
13:25:35 <Ontolog> is there any way to sort something 'in-place' in haskell?
13:25:46 <c_wraith> Use a mutable data structure
13:25:51 <Taneb> Ontolog, if you use, eg, mutable vectors
13:26:15 <aztek> hi! is there an example of something that is Functor, but not Apply?
13:26:25 <c_wraith> aztek: you mean Applicative?
13:26:46 <c_wraith> aztek: if so, ((,) a) is an easy example.  You can't implement pure for it.
13:26:48 <aztek> c_wraith: no, Apply from semigroupoids
13:26:53 <c_wraith> Oh, ok.
13:26:58 <Rotaerk> is a binary tree an applicative?
13:27:05 <hpc> @src Apply
13:27:05 <lambdabot> Source not found. Are you on drugs?
13:27:07 <hpc> Rotaerk: yes
13:27:28 <aztek> http://hackage.haskell.org/packages/archive/semigroupoids/3.0.2/doc/html/Data-Functor-Apply.html#g:2
13:27:32 <armlesshobo> how is a binary tree an applicative? what am I missing?
13:27:51 <hpc> armlesshobo: it's a monad, too
13:27:53 <Guest29682> Whats a interesting problem for someone with limited haskell skills
13:28:18 <armlesshobo> Guest29682: "how can i improve my Haskell skills?"
13:28:19 <c_wraith> aztek: That's an interesting question. I don't see why not, because everything I know of that has issues being an Applicative without Functor is because of pure
13:28:36 <c_wraith> aztek: so being Applicative without pure means..  I can't think of any examples
13:28:36 <Rotaerk> heh
13:28:38 <hpc> Guest29682: something IO-heavy might be a good challenge
13:28:39 <monoidal> Guest29682: RPN calculator?
13:29:08 <Rotaerk> I'm just not sure what the result should be for applying a non-trivial tree to a non-trivial tree
13:29:19 <Rotaerk> binary tree *
13:29:36 <monoidal> Guest29682: or a text sokoban clone
13:29:37 <armlesshobo> hpc: ah, as long as something is part of Functor, it can be Applicative
13:29:46 <hpc> armlesshobo: no
13:30:02 <Guest29682> Never heard of RPN
13:30:03 <hpc> armlesshobo: but you can define a monad instnce
13:30:24 <hpc> and monad gives applicative
13:30:36 <edwardk> aztek: newtype Foo a = forall x. Foo (Bar x) (x -> a)  for any Bar that is a GADT that you can't smash together.
13:30:49 <armlesshobo> hpc: class Functor f => Applicative f where ...
13:31:22 <edwardk> c_wraith: Applicative without pure: Map k, IntMap, HashMap k
13:31:23 <elliott> armlesshobo: that means that every Applicative must be a Functor
13:31:31 <elliott> not that every Functor is an Applicative
13:31:31 <aztek> c_wraith: Semigroup f => (f a, b) is Apply but not Applicative
13:31:42 <hpc> armlesshobo: class Rectangle a => Square a
13:31:51 <tom4939> Guest29682: https://duckduckgo.com/Reverse_Polish_notation
13:32:06 <c_wraith> neither of those were the question, though
13:32:24 <armlesshobo> if a type is a Functor, it can also be Applicative. But not necessarily so.
13:32:30 <armlesshobo> that's all I was saying.
13:32:32 <c_wraith> The question is "What's something that can be a Functor, but not an Apply?"
13:32:33 <tom4939> Guest29682: If you're interested in becoming more familiar with the type system: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
13:33:02 <monoidal> Guest29682: or a number guessing game? computer chooses a number in [1..100], you have to guess it and are told if the guess is too high or too small
13:33:21 <c_wraith> And given that every Functor I can think of that can't be an Applicative fails because of pure, I'm not coming up with anything that fails to be an Apply
13:33:47 <armlesshobo> c_wraith: it can be a new data type that doesn't have an instance of Applicative defined.
13:33:48 <hpc> c_wraith: aztek has a good example
13:33:57 <hpc> it can be Functor
13:34:11 <c_wraith> hpc: I think you're still not reading the question
13:35:42 <edwardk> hpc: the Semigroup example is Apply, not Applicative.
13:36:00 <edwardk> hpc: but its still Apply, the original question was seeking Functor that is not Apply
13:36:13 <edwardk> to which i replied newtype Foo a = forall x. Foo (Bar x) (x -> a)  for any Bar that is a GADT that you can't smash together.
13:36:32 <c_wraith> that has to be data, though. :P
13:36:36 <edwardk> which is one of the yoneda lemma types
13:36:39 <edwardk> sure
13:36:39 <edwardk> data
13:36:44 <edwardk> i started with the other Yoneda lemma and switched
13:36:56 <c_wraith> But yeah, when you involve GADTs, all sorts of things fall apart.  That's true.
13:37:17 <edwardk> data Ref a = forall x. Ref (IORef x) (x -> a)
13:37:31 <edwardk> thats the readonly side of an IORef
13:37:51 <c_wraith> Yes, fmap for that is nicely straight-forward.
13:39:09 <c_wraith> and..  Apply's <.> would be...  Yeah, it doesn't work
13:39:38 <edwardk> ski loves that example
13:39:59 <c_wraith> amusingly, pure sort of works for that case.
13:40:16 <c_wraith> It involves a bottom, but it doesn't abuse it.
13:40:40 <edwardk> well, it does if you have the readRef :: Ref a -> IO a
13:41:02 <c_wraith> Wait, it doesn't work at all.  It'd need unsafePerformIO, and I'm not going there.
13:43:27 <edwardk> =)
13:43:56 <aztek> edwardk: i don't understand your example. there're two arguments to Foo on the right side
13:44:14 <c_wraith> aztek: pretend it says "data" instead of newtype
13:44:19 <c_wraith> aztek: then it works
13:44:47 <aztek> oh, okay
13:45:22 <c_wraith> aztek: he also gave a more concrete example, the Ref type.
13:45:52 <aztek> c_wraith: yeah, i see now
13:45:57 <aztek> thanks edwardk!
13:46:19 <Ontolog> can you metaprogram in haskell?
13:46:19 <fryguybob> Is it true that  f <$> (a <|> b) === (f <$> a) <|> (f <$> b)?
13:46:36 <edwardk> fryguybob: yes
13:46:50 <monoidal> Ontolog: template haskell, but often you don't need to
13:47:12 <fryguybob> edwardk: Thanks
13:57:44 * hackagebot miniball 0.1.0.2 - Bindings to Miniball, a smallest enclosing ball library  http://hackage.haskell.org/package/miniball-0.1.0.2 (GardSpreemann)
14:15:39 <dimka> Is there a way to get list a packages that will be installed after running `cabal install x.cabal` without running this command and install all these packages?
14:16:04 <shachaf> cabal install --dry-run
14:16:26 <hpc> but the type is only inhabited for propositions that are decidably decidable
14:16:30 <hpc> er
14:16:33 <hpc> this isn't #agda
14:16:44 <dimka> shachaf: great, thanks
14:17:39 <meyersh> Whoa. GHCi `:r` removes definitions that have been removed from the file!
14:17:55 <otters> yes
14:18:04 <c_wraith> yeah, :r erases the whole environment
14:18:06 <dmwit> :r removes *all* definitions.
14:18:09 <quchen> It also removes definitions you have in your ghci.conf :-(
14:18:20 <hpc> quchen: that sounds like a bug
14:18:25 <meyersh> It's not magically keeping track of what definitions come from what file? :(
14:18:26 <dmwit> (but then it adds some back in -- namely the ones made in the thing you're reloading)
14:19:02 <quchen> hpc: It's the way the config is used I think, not strictly a bug. The config file is basically run on a per-line mode in the beginning.
14:19:25 <dmwit> quchen: solution: redefine :r
14:20:09 <quchen> dmwit: My main issues is that this prohibits hacking colored output in the thing. I looked at the source to see whether I could find a clean way of doing this, but to no avail.
14:20:45 <dmwit> I mean, you can define new : commands that last across :r, can't you?
14:20:59 <dmwit> So define one of those to do :r followed by whatever you need for colored output.
14:21:02 <dmwit> Right?
14:21:06 <dmwit> <- not an expert
14:21:19 <hpc> my solution has always been to just not do complicated things in ghci
14:21:22 <quchen> Hm. Maybe. I would guess :r is hardcoded and is hard to overwrite though.
14:21:24 <hpc> it always works
14:21:49 <quchen> hpc: Not playing music hardly fixes your record player.
14:21:56 <dmwit> quchen: Okay, that sounds plausible. But making a new command instead of replacing :r seems like a pretty good solution to me.
14:22:36 <quchen> dmwit: But then I have to invoke that command manually.
14:22:48 <quchen> What I'd need is redefining :r with ":r plus color".
14:22:54 <hpc> quchen: complicated things go in .hs files
14:23:12 <dmwit> I don't see why "I have to invoke that command manually" is such a bad thing.
14:23:19 <dmwit> You have to invoke :r manually, too.
14:23:24 <dmwit> (Or what am I misunderstanding?)
14:23:35 <quchen> dmwit: Coloring isn't something I'd like to invoke manually ;-)
14:23:46 <quchen> It's not a dealbreaker, but makes the environment nicer.
14:23:52 <dmwit> I don't get it.
14:24:16 <dmwit> Is your complaint just that you don't want to have to type :s instead of :r (for example)?
14:24:33 <quchen> Oh, that's what you meant.
14:25:19 <quchen> Not sure that works though. I'll give it a shot I guess
14:25:46 * dmwit disappears
14:27:29 <fryguybob> Cale: I think the STM thing you were looking at last night is a memory ordering bug in the RTS.  Did anyone report it?
14:27:45 * hackagebot bytes 0.6 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.6 (EdwardKmett)
14:42:51 <boygrmn88> http://amateurgirlfuckedhard.blogspot.com/2013/04/the-best-amateur-and-pornstar-collection.html
14:43:27 <Ontolog> wtf
14:43:35 <hiptobecubic> blogspot? really?
14:43:37 <c_wraith> well, he was killed pretty fast
14:44:00 <quchen> Porn on the internet? Wow, check it out guys!
14:44:09 <quchen> Oh
14:44:12 <quchen> No Haskell in there
14:44:16 <Ontolog> yeah off topic
14:45:09 <hiptobecubic> I'm not seeing how zipWith . zipWith gets its type
14:45:15 <hiptobecubic> :t zipWith . zipWith
14:45:16 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
14:45:37 <hiptobecubic> So given zipWith and (.), what goes where
14:45:40 <hiptobecubic> :t (.)
14:45:42 <shachaf> zipWith . zipWith = \f xs ys -> zipWith (zipWith f) xs ys
14:45:43 <mauke> hiptobecubic: inline the definition of (.)
14:45:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:46:24 <c_wraith> :t map . map
14:46:25 <lambdabot> (a -> b) -> [[a]] -> [[b]]
14:46:29 <c_wraith> exact same thing
14:46:58 <shachaf> @ty (=<<) . (=<<)
14:47:00 <lambdabot> Monad m => (a -> m b) -> m (m a) -> m b
14:47:41 <shachaf> @ty liftA2 . liftA2
14:47:42 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
14:47:47 <quchen> I love the part in edwardk's talk where he talks about dot dot dot dot dot.
14:51:47 <LAMMJohnson> Hey, guys. I'm having trouble figuring out some type issue with SDL-image from hackage.
14:51:50 <LAMMJohnson>     Couldn't match expected type `SurfaceStruct'
14:51:52 <LAMMJohnson>                 with actual type `SDL-0.6.3:Graphics.UI.SDL.Types.SurfaceStruct'
14:52:20 <elliott> sounds like a packaging issue
14:52:24 <LAMMJohnson> I thought it might be.
14:52:36 <mauke> sounds like a version issue
14:52:38 <elliott> you probably have multiple versions of a package installed
14:52:43 <hiptobecubic> Version numbers appearing in types usually mean everything is boned i think
14:53:01 <hiptobecubic> did you install two versions of SDL?
14:53:14 <LAMMJohnson> Possibly once through my package manager and once through cabal.
14:53:39 <hiptobecubic> well hopefully your package manager knows how to correctly uninstall
14:54:28 <LAMMJohnson> Trying it out now. Cheers, guys.
14:54:52 <elliott> LAMMJohnson: you might find http://www.vex.net/~trebla/haskell/sicp.xhtml helpful
14:56:31 <LAMMJohnson> elliott: This is exactly what I need. thankyou.
14:57:02 <LAMMJohnson> Perfect. Removed via package manager and installed via cabal.
15:03:45 <jfischoff> Enigmagic: The Llvm library with ghc is much more what I was looking for. Have you seen it?
15:04:36 * jfischoff is happy to have discovered FastString
15:08:00 <armlesshobo> jfischoff: i hear it's fast...
15:09:17 <jfischoff> I've used a similar package in a game engine. There nice to have.
15:19:10 <hseg> Is there a better way to write the following: do { a' <- get; let a = show a'; ...} ?
15:20:03 <jfischoff> > show <$> Just 1
15:20:05 <lambdabot>   Just "1"
15:20:21 <jfischoff> @src (<$>)
15:20:22 <lambdabot> f <$> a = fmap f a
15:22:05 <raek> hseg: do { a <- fmap show get; ... }
15:22:51 <hseg> Thx.
15:23:15 <raek> or do { a <- liftM show get; ... } if you prefer...
15:23:52 <hseg> Or even do { a <- show <$> get; ...}
15:24:16 <clahey> Is there a function that does something like:: [[a]] -> Array (Int, Int) a
15:24:24 <clahey> Hoogle doesn't seem to have one.
15:24:30 <clahey> I suppose I need to provide bounds as well.
15:25:09 <elliott> listArray may be helpful
15:25:15 <sw2wolf> @djinn [[a]] -> Array (Int, Int) a
15:25:15 <lambdabot> Error: Undefined type []
15:25:17 <fryguybob> clahey: listArray bounds . concat
15:25:27 <fryguybob> where bounds is your bounds...
15:25:37 <elliott> sw2wolf: djinn isn't *that* clever
15:25:55 <sw2wolf> sure
15:26:07 <clahey> fryguybob: That collapses my lists.  I want 2 dimensional.
15:26:14 <clahey> I'll check out listArray a bit more.
15:26:26 <elliott> collapses howso?
15:29:54 <clahey> elliott: listArray bounds . concat turns my list of lists into just a list of elements.
15:29:56 <clahey> Oh, I see.
15:30:21 <clahey> The problem is that the list of lists is sparse.
15:30:30 <elliott> ah
15:33:43 <hpaste> hseg pasted “Old code” at http://hpaste.org/85213
15:33:47 <hseg> Was browsing through some old code, and found this (modulo name changes to avoid having to explain the long story of what the code does): http://hpaste.org/85213 What does the "state . runState" part do?
15:34:56 <hseg> Original code available to those patient enough to trawl through ~50 lines of translator code + an explanation of the source-target translation.
15:35:10 <clahey> Is there a way to specify a default value for an array without filling it with the value?
15:37:58 <geekosaur> clahey, that's meaningless
15:38:47 <quchen> hseg: Being silly, that's what it does.
15:39:02 <quchen> hseg: The one function results in a State, the other one in a StateT.
15:39:14 <clahey> geekosaur: How so?
15:39:24 <quchen> runState deconstructs the State, state packs it in a StateT.
15:39:30 <quchen> :t state . runState
15:39:32 <lambdabot> MonadState s m => State s a -> m a
15:40:00 <geekosaur> could you explain what state you think an array has which allows it to have values that are not filled in, yet have default values?
15:40:13 <clahey> geekosaur: I would like an array of size (r,c) with *these* values, and *this* value for any unspecified indices.
15:40:22 <clahey> geekosaur: I just mean I don't have to fill in each missing index by hand.
15:40:32 <geekosaur> oh.
15:40:45 <quchen> clahey: Sparse array?
15:41:20 <clahey> quchen: Yeah, that's basically what I'm looking for.
15:41:31 <clahey> quchen: Though it'd probably be faster to just build a non sparse array.
15:41:57 <quchen> Then create an array full of default values and edit your non-defaults in?
15:42:45 * geekosaur didn't think sparse arrays were a thing...
15:43:31 <clahey> quchen: Yeah, that's what I ended up doing.
15:43:42 <hseg> So basically, all it does is convert my State value into a StateT value? Why is that silly?
15:44:39 <quchen> hseg: It would probably be easier to change the type sig of the first function to make it StateT as well.
15:45:09 <quchen> clahey: If you do it in ST you've got to allocate on array only
15:45:33 <hseg> Even though it only makes use of the State, and not the enclosed data?
15:45:39 <hseg> I
15:46:15 <hseg> 'm probably going to have to wrap the entire thing in another state anyway, so it's not as if I'm averse to changing the types.
15:47:29 <quchen> hseg: For small code like this I'd say unify the monads. If you're combining two different libraries, state.runState may be more useful.
15:47:49 <clahey> quchen: Right now I'm doing it pure, but I'll look into that.
15:48:12 <quchen> state.runState just looks very awkward. If you use it, you should probably leave a comment.
15:48:15 <hseg> It's ~300 lines of code. How would you unify the monads?
15:48:26 <quchen> Oh I thought it's just that snippet.
15:48:35 <hseg> i.e. what do you mean by "unifying monads"
15:48:47 <quchen> "Make all State to StateT"
15:49:02 <quchen> Oh there's Reader in there
15:49:29 <hseg> No, no. It's just a MWE to show where the line appeared, along with enough context to show why I would have that in the first place
15:49:40 <merijn> "reader and state" sounds like "I want RWS"
15:50:03 <quchen> merijn: Maybe, yes. I usually start using RWS if I have to use two of them.
15:50:18 <hseg> It does sound like that, but the state and the reader enclose two different data
15:50:18 <quchen> hseg: I think you're a little restrictive on your ifExpr type anyway.
15:50:28 <quchen> If you give that a MonadState constraint, it's polymorphic.
15:50:49 <quchen> So basically delete the type sig, use :t in GHCi and put the result ontop of your function
15:50:50 <hpaste> clahey pasted “Array from sparse List of Lists” at http://hpaste.org/85214
15:51:32 <clahey> quchen: So, that's what I came up with, but any pointers would be awesome.
15:51:49 <clahey> quchen: In particular if there's a way to make it faster without adding much code.
15:52:10 <quchen> It's flattening right now I think.
15:52:29 <quchen> A 2D Array has ((iMin, iMax), (jMin, jMax)) boundaries
15:52:36 <quchen> Right now you're just double-parenthesizing
15:52:57 <quchen> Also I didn't know you were doing 2D. Reading comprehension B- for me there haha
15:53:06 <clahey> quchen: Well, my function only takes the upper bound, not both bounds.
15:53:26 <quchen> Ah OK, it's like a square cutoff
15:53:29 <clahey> And doesn't a 2D array have ((iMin, jMin), (iMax, jMax)) boundaries?
15:53:34 <quchen> Or rectangle
15:53:43 <monochrom> yes
15:53:47 <quchen> clahey: Could be
15:54:17 <clahey> In any case, I've put that in my library, but it would still be cool to have it be faster.
15:54:21 <clahey> Even if it does have more code.
15:54:33 <clahey> I don't think speed is going to be an issue for that bit though.
15:54:43 <quchen> In the 2D case, make a function to make a 1D list to an Array. Map this over your 2D list, you'll get a list of Arrays.
15:54:50 <quchen> Then apply your array-maker on that.
15:55:12 <clahey> Make a list of Arrays and turn that into a single Array?
15:55:24 <clahey> Well, my solution does seem to work.
15:55:26 <quchen> Arr wait no that's not very good
15:55:31 <quchen> Been working with Vector too much ;-)
15:55:41 <quchen> Array has native 2D support, I forgot
15:57:54 <hseg> Basically, what I have here is a function that is dependent on some RO state and has to generate sequential data. I later will also have to keep track of some global state. All of this seems like it should be implemented using a StateT (Integer, globalType) (Reader roType) returntype
15:58:04 <hseg> Unless you have a better idea?
15:58:13 <quchen> Some brute force method would work of course, but it's not necessarily a very good solution. I'd probably ask Stackoverflow here.
15:58:52 <quchen> hseg: RO state?
15:59:25 <hseg> As in, some configuration var. That kind of stuff.
15:59:35 <quchen> Oh, it's "read only"
15:59:55 <quchen> Generating sequential data: Writer. Read-only: Reader. State: State.
16:00:04 <quchen> Sounds like RWS to me.
16:00:49 <quchen> (RWS is an efficient combination of Reader+Writer+State, in case you don't know it.)
16:01:42 <hseg> Wait, Writer can be used to create stuff like: map each occurence of "foo" in l by f("foo"), and sequentially number those occurences
16:02:33 <quchen> Writer can append monoidal stuff.
16:02:34 <hseg> i.e. ["foo","bar","baz","foo"] => ["0"++f("foo"), "bar","baz,"1"++f("foo")]
16:03:02 <pala2> Why this is incorrect?  sin . cos 42
16:03:03 <pala2> The Function application is no more left-associative if (.) is used in infix notation?
16:03:23 <pala2> (.) sin cos 42   works
16:03:33 <quchen> pala2: "space" binds tighter than (.), so your code is read as sin . (cos 42)
16:03:48 <hseg> Right. Not what I'm looking for. I need to convert each occurence of some string in the input by a unique version of its image under some function.
16:04:22 <monochrom> (.) sin cos 42 = ((.) sin cos) 42 = (sin . cos) 42
16:04:22 <quchen> hseg: Hmm. That's a little tricky, a plain monoid won't do here
16:05:31 <hseg> Right. The way I did it up till now is placing that function in State Integer, then starting with state 0 and incrementing the state each time the function is called. The state is used to create a unique version of the image.
16:05:34 <quchen> hseg: Can't you just let the Writer build your ordinary [String] list, and do the numbering after you've ran the RWS, i.e. on the final Writer output?
16:05:34 <pala2> quchen: Thanks! Any reference where the order of binding tightness is listed for other operations too?
16:05:50 <quchen> pala2: You can check with :i in GHCi
16:05:54 <quchen> :i (.)
16:06:03 <aCube> doesn't work in lambdabot
16:06:12 <quchen> pala2: Function application via space has thetightest binding of everything
16:06:32 <quchen> pala2: `infix` has infixl 9, which is one level weaker
16:06:41 <quchen> The rest you can look up using :i
16:07:09 <quchen> ("space" has infixl 10 so to speak)
16:07:55 <pala2> quchen: thanks, but how you do :i "space" ??
16:08:02 <pala2> any symbolic representation of space?
16:08:12 <geekosaur> you don't; it's syntax, not an operator
16:08:22 <geekosaur> also 10 is not actually a valid precedence
16:08:24 <monochrom> a good tutorial may have an incomplete precedence table, but it ought to tell you about "function application is above all those operators"
16:08:35 <monochrom> but a good tutorial may be non-existent
16:09:09 <hseg> Not really. Full story: I'm writing a compiler (homework). I need to convert each occurence of an if statement into a series of unique labels with the jump instructions bound to those unique labels I create. I don't see how I can change the target labels after generating the code and still maintain correct cross-referencing.
16:09:13 <ion> > let f "foo" = do { n <- get; put (n+1); return (show n) }; f xs = return xs in runState (traverse f (words "woo bar baz foo")) 0
16:09:14 <lambdabot>   (["woo","bar","baz","0"],1)
16:09:22 <ion> > let f "foo" = do { n <- get; put (n+1); return (show n) }; f xs = return xs in runState (traverse f (words "foo bar baz foo")) 0
16:09:24 <lambdabot>   (["0","bar","baz","1"],2)
16:09:50 <ion> Oh, it was homework. I didn’t realize.
16:11:15 * sw2wolf time for breakfast
16:11:43 <quchen> hseg: zip your parse tree with [1..]? ;-)
16:12:03 <quchen> Gotta go to bed now, but I'm out of good ideas for today since five hours ago anyway
16:12:20 <quchen> Have a good night everyone
16:12:31 <hseg> Good night quchen. Thanks for the help anyway.
16:12:36 <hseg> :q
16:12:52 <hseg> That pasted in the wrong window
16:13:06 <dmwit> hseg: Cryptic comment which may be unrelated, given that I've only seen the last minute or two of conversation: laziness gives you one-time mutation.
16:13:31 <hseg> ? In what sense
16:13:37 <elliott> one-time, semantics-preserving mutation
16:13:49 <dmwit> You can mutate a thunk into an evaluated value.
16:15:00 <dmwit> In other words: you don't have to pick a label up front, so long as you can pick a label eventually.
16:16:05 <hseg> The problem being, that the label must be replicated across all the references to it.
16:16:21 <pala2> Anyone can tell me how to get the infixl of function application? :i "space" doesn't work :-)
16:17:20 <dmwit> Function application is part of the syntax; it doesn't have a fixity in the sense functions do.
16:17:27 <dmwit> You can read about how it's parsed in the Report.
16:17:29 <hseg> i.e. it is insufficient to just make the output an Either, and zip the Lefts with [1..], because some of the Lefts need to refer to the same number
16:17:50 <pala2> dmwit: but quchen just said, that it has the tightest infixl. hm...
16:17:52 <dmwit> hseg: I'm not really following what the problem is. Why can't you just draw from [1..] as you build the thing?
16:18:12 <ion> pala2: I suppose you can assume it to be ≥ 10.
16:18:25 <dmwit> pala2: It was meant to be read as an analogy, not literally.
16:18:26 <ion> That’s what showsPrec definitions do.
16:18:28 <elliott> technically record syntax is even tighter.
16:18:46 <dmwit> hseg: (or any other infinite list)
16:18:51 <pala2> okay, thank you
16:19:17 <slack1256> harper says that parallelism arises naturally with strict semantics. Does that mean that the ghc developers had to jump humps to get the current performance?
16:19:51 <geekosaur> harper says lots of things...
16:20:01 <dmwit> ?quote harper.*gonna
16:20:01 <lambdabot> No quotes match. You untyped fool!
16:20:02 <elliott> "harper says", when preceded by a statement that can taken as a criticism of Haskell, should be treated with an adequately-sized grain of salt
16:20:05 <hseg> Wait, wait. Are you suggesting that I add a parameter of type [Integer] to the generating function, and just consume the head of the list when I need the uniqueness? That would involve changing a *lot* of code. And I don't see the benefit over just using a State Integer
16:20:06 <liyang> harper says… what geekosaur said.
16:20:18 <elliott> (that doesn't mean it's false, but it means you should be sceptical.)
16:20:21 <dmwit> harper's gonna hrap
16:20:56 <geekosaur> anywy, parallelism is at least as likely to arise naturally from non-strict semantics; in fact there's quite a bit of parallel haskell that relies on that
16:20:57 <slack1256> I've but harper is THE harper
16:21:13 <elliott> we are referring to the harper, too
16:21:19 <ivanm> are there any Identity-based optimisations somewhere? for some reason, when I replace Identity at the bottom of my stack with a custom Identitly-like Monad, my program runtime increases :/
16:21:20 <geekosaur> (enough to annoy Harper, who hates and possibly fears non-strict semantics)
16:21:37 <dmwit> hseg: Nah, I'm suggesting you use State [label] or possibly Reader [label].
16:22:02 * geekosaur would not be surprised if there are some RULES pragmas about targeting Identity...
16:22:07 <elliott> ivanm: maybe there are some RULES
16:22:29 <ivanm> I had a quick look in transformers and couldn't see any
16:22:36 <ivanm> maybe I should grep the transformers and mtl source
16:22:43 <liyang> The first RULE of #haskell is that you do not talk about the RULES.
16:22:57 <liyang> The second RULE of #haskell is that you DO NOT TALK about the RULES.
16:23:06 * ivanm glares pointedly at liyang 
16:23:45 <hseg> Right. But, again, how is that better than just using State Integer and modifying the state as appropriate?
16:23:49 <liyang> Σ:3
16:24:00 <geekosaur> {-# RULES liyang = id #-}
16:24:08 <ivanm> elliott: grepping for Identity didn't show it in any rules or anything...
16:24:22 <aCube> ivanm: try -ddump-rule-firings when compiling
16:24:31 <elliott> perhaps there is something clever in the instances for Identity? beats me
16:24:31 <aCube> (afair that was the option)
16:24:34 <liyang> Don't rewrite me to a trivial function bro!
16:24:35 <elliott> maybe it is a newtype and yours isn't
16:24:44 <ivanm> elliott: well, I copied the instances over just to check that
16:24:52 <ivanm> and mine is a newtype
16:25:09 * elliott gives up
16:25:10 <slack1256> but wasn't that the reason of why gph used lenient evaluation and the whole 'an alternative to laziness'?
16:25:11 <ivanm> I defined it just to see if there _was_ something going on with Identity
16:25:25 <elliott> you could investigate Core and stuff. sounds unpleasant
16:26:09 <ivanm> yeah, I'm also trying to work out how to get an arbitrary stack to be as performant as an explicit stack with Identity on the bottom
16:26:20 <ivanm> and RULEs don't seem to like type families :/
16:27:07 <DanielDiaz> how do I deprecate a package in Hackage?
16:27:33 <ivanm> DanielDiaz: you upload a version full of "DON'T USE THIS" warnings in the description
16:27:33 <liyang> ivanm: there's an ap^H^H^H^H ticket for that http://hackage.haskell.org/trac/ghc/ticket/7611
16:27:41 <tgeeky> DanielDiaz: find one that is depcrated and copy their info
16:27:47 <ivanm> then you email the hackage maintainers asking them to deprecate the package (which just hides it from view)
16:27:48 <tgeeky> DanielDiaz: I think you can do status: deprecated
16:28:06 <ivanm> liyang: heh (at the "app" reference)
16:28:08 <hseg> BTW, I have the feeling I'm doing something wrong by using ++ dozens of times to construct a list
16:28:21 <tgeeky> hseg: you are
16:28:39 <liyang> ivanm: wait, I'm not sure what's the right ticket…
16:28:40 <ivanm> difference lists!
16:28:49 <hseg> Is there a better way? Esp. is the List Monoid optimized for concatenations?
16:28:53 <ivanm> liyang: there's another one that came up with the exact same error message
16:28:55 <tgeeky> @hackage dlist -- hseg
16:28:55 <lambdabot> http://hackage.haskell.org/package/dlist -- hseg
16:28:57 <DanielDiaz> ivanm, tgeeky: So it's mostly say it in the documentation. I can
16:29:02 <ivanm> DanielDiaz: yup
16:29:09 <DanielDiaz> *I can't do it manually.
16:29:32 <hseg> Shouldn't the List Monoid instance be optimized for this?
16:29:36 <DanielDiaz> ivanm: alright. Thanks. :)
16:29:44 <ivanm> hseg: nope
16:29:50 <ivanm> they're singly-linked lists
16:29:54 <ivanm> appending is _bad_
16:30:00 <tgeeky> DanielDiaz: http://hackage.haskell.org/package/trhsx change the stability / ynopsis to Deprecated, and e-mail someone.
16:30:03 <ivanm> assuming by "List" you mean []
16:30:06 <ivanm> not some wrapper
16:30:12 <ldgonza> I'm being obtuse here, or one can't do something like 'foldr (+) [1, 2, 3, 4]' without encapsulating it in a function?
16:30:21 <DanielDiaz> tgeeky: someone like?
16:30:25 <ivanm> ldgonza: you need a base case
16:30:25 <dmwit> > foldr (+) 1 [2,3,4]
16:30:26 <elliott> ldgonza: try a 0 after that (+)
16:30:26 <lambdabot>   10
16:30:41 <aCube> > foldr1 (+) [1,2,3]
16:30:42 <lambdabot>   6
16:30:45 <aCube> > foldr1 (+) []
16:30:45 <otters> > foldr f a [b,c,d,e]
16:30:47 <lambdabot>   *Exception: Prelude.foldr1: empty list
16:30:47 <lambdabot>   can't find file: L.hs
16:31:12 <tgeeky> DanielDiaz: I've only ever e-mailed the guy listed on including browsing and checking packages) are available to all. However, uploading packages requires a HackageDB username and password.
16:31:16 <tgeeky> Getting a Hackage username
16:31:17 <dmwit> Of course, the literal answer to your question is "you're being obtuse".
16:31:19 <tgeeky> ugh.
16:31:24 <tgeeky> i hate my client.
16:31:34 <tgeeky> DanielDiaz: see http://hackage.haskell.org/packages/accounts.html
16:31:46 <hseg> Doesn't make sense. Why would the *Monoid* instance, the instance that specifically is used for *concatenating* data, not be optimized for concatenation? It would be like IO not optimizing for the constraint of there only being one valid state at every given time.
16:31:54 <ldgonza> I deserved that so much :P
16:31:58 <ldgonza> much appreciated
16:32:09 <elliott> bad analogy given that IO has nothing to do with state
16:32:29 <elliott> (well, it contains state: IORefs etc.)
16:32:29 <liyang> ivanm: this is my workaround for RULES involving TypeFamilies: https://github.com/liyang/thyme/commit/95922ed8ea2661418ec24a77372926e8abee3036#L1R34
16:32:40 <DanielDiaz> tgeeky: Yes, I already have an account. I just want to deprecate one of my packages. I will send the e-mail and add the info in the .cabal file as well.
16:32:43 <geekosaur> hseg, lists are not optimal, they are *convenient*
16:32:53 * hackagebot yesod-auth-fb 1.5.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.5.1 (FelipeLessa)
16:32:58 <tgeeky> DanielDiaz: yes, I was just using that to point to the guys e-mail without pasting it in here.
16:34:35 <hseg> Right. Forget the above. However, DLists *will* pull in extra dependencies, and I hoped the [] Monoid instance was optimized for appends like Dlist is.
16:34:51 <elliott> you can use the Endo [a] instance, no dependency required
16:34:58 <ivanm> liyang: looks like fun :/
16:35:07 <hseg> Endo [a]? WTFH is that?
16:35:15 <aCube> hseg: DLists are a completely different datastructure, so you cannot optimize the [] instance to do the same as the DList one
16:35:33 <hseg> Right. Pity, though.
16:35:34 <dmwit> Endo a is a fancy way to spell a -> a
16:35:50 <dmwit> DList a is a fancy way to spell [a] -> [a]
16:36:05 <hseg> Why don't you speak in English? :-)
16:36:08 <ivanm> liyang: the fact that I'm using CostraintKinds to do stuff like "type AMonad m = (Applicative m, Monad m)" probably doesn't help either :/
16:36:31 <ivanm> hseg: RWH has a chapter on difference lists if you want to see how they work, etc.
16:36:48 <dmwit> TIL I don't speak English
16:36:59 <ivanm> dmwit: can you read it though? :p
16:37:23 <shachaf> I,I #define AMonad(m) (Applicative m, Monad m)
16:37:50 <ivanm> liyang: and, of course, it would help if I got my pragmas straight: I meant I've been having trouble with _SPECIALISE_ working on type families (though the Identity thing might be due to RULEs)
16:37:54 <dmwit> class AMonad m; instance (Applicative m, Monad m) => AMonad m
16:38:03 <otters> oh THAT'S what ConstraintKinds is??!
16:38:28 <ivanm> shachaf: would that work? I didn't know you could have nested parens in type sig constraints
16:38:33 <ivanm> otters: that's one usage of them
16:38:40 <ivanm> and one that I've been abusing a fair bit :p
16:38:53 <hseg> :D. I did get it, though. So basically, DLists are of type [a] -> [a], and all functions on them basically create chains of compositions that when unDL is called will collapse into a single list?
16:39:03 <ivanm> dmwit: didn't think that for this one case that would work since you're not going to add any more instances
16:39:08 <ivanm> hseg: yes
16:39:18 <ivanm> but it has the downside that things like head, etc. are now O(n)
16:39:20 <shachaf> ivanm: It works, but only with ConstraintKinds. :-)
16:39:31 <ivanm> shachaf: heh
16:39:39 <dmwit> Oh, I guess I meant to put the constraint in the class declaration, too.
16:39:55 <otters> ConstraintKinds is cool then
16:39:57 <hseg> Something like State monads creating elaborate chains of compositions, that when runState is called with the initial state, collapse into the (endState, retVal) pair?
16:40:22 <aCube> > appEndo (Endo ([1,2,3]++) <> Endo ([4,5,6]++) <> Endo ([7,8,9]++)) []
16:40:24 <lambdabot>   [1,2,3,4,5,6,7,8,9]
16:40:24 <ivanm> yup
16:40:42 <otters> Endo is a monoid under function application right?
16:41:01 <dmwit> otters: hmmm?
16:41:12 <aCube> @src Endo mappend
16:41:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:41:16 <dmwit> The monoid operation for Endo is (.)
16:41:18 <ivanm> anyway, this still doesn't help me figure out why copying the source of the Identity Functor, re-naming it and then using it instead of Identity is slower :/
16:41:23 <dmwit> now that I think I understand the question.
16:41:58 <liyang> ivanm: isn't SPECIALISE more or less a RULES?
16:42:00 <cmccann> ivanm: rewrite rules probably
16:42:21 <ivanm> cmccann: yes, aCube suggested that earlier; I can't find any that apply though :/
16:42:29 <ivanm> liyang: *shrug* quite possibly
16:42:35 <hseg> I think I'll note that at the top of my code, for future optimization.
16:42:36 <cmccann> not necessarily obvious ones
16:42:53 <ivanm> well, there aren't any rewrite rules in transformers or mtl
16:42:55 <aCube> > appEndo (Endo (a+) <> Endo (b+) <> Endo (c+)) d
16:42:56 <lambdabot>   a + (b + (c + d))
16:43:22 <ivanm> and I've done -ddump-rule-firings, but nothing there shouts out at me as being relevant
16:43:40 <aCube> diff on core? :P
16:44:00 <ivanm> yeah, pass... ;-)
16:44:06 <aCube> > appEndo (Endo (a++) <> Endo (b++) <> Endo (c++)) d
16:44:08 <lambdabot>   a <> b <> c <> d
16:44:12 <monochrom> yikes, core diff is the hard way... :)
16:44:12 <aCube> :O it replaces ++ by <>
16:44:16 <cmccann> ivanm: do it for SCIENCE!
16:44:19 <shachaf> ivanm: -dverbose-core2core might help
16:44:23 <otters> > appEndo (Endo f <> Endo g) a
16:44:25 <lambdabot>   f (g a)
16:44:29 <otters> awesome
16:44:41 <hpc> @quote appendo
16:44:41 <lambdabot> quicksilver says: 'appEndo' sounds like a harry potter spell
16:44:55 <aCube> > appEndo (Endo (a++) <> Endo (b++) <> Endo (c++)) d -- That one is funny
16:44:57 <cmears> appendo monoidus!
16:44:57 <lambdabot>   a <> b <> c <> d
16:44:58 <ivanm> cmccann: for some reason when I try and have GHC output core by setting the options in my .cabal file, ghc has a "the impossible happened"
16:45:06 <ivanm> (though strangely enough using ghc-core works :/)
16:45:10 <cmccann> haha
16:45:23 <ivanm> shachaf: oh, that reminds me: do you maintain ghc-core now?
16:45:46 <shachaf> ivanm: In theory...
16:45:50 <ivanm> heh
16:46:23 * monochrom tries to imagine what does "maintainer, in theory" means :)
16:46:27 <ivanm> any possibility of having the .hi and .o files be put into a temp directory rather than littering the source directory?
16:46:42 <ivanm> monochrom: he's listed as being the maintainer, but relies on everyone else doing the work :p
16:47:05 <monochrom> -odir may be the flag
16:47:32 <ivanm> yeah, something like that
16:47:53 <ivanm> ghc-core already creates a temp file to output the core into
16:47:54 * hackagebot HaTeX-meta 1.2.1 - This package is deprecated. From version 3, HaTeX does not need this anymore.  http://hackage.haskell.org/package/HaTeX-meta-1.2.1 (DanielDiaz)
16:48:03 <shachaf> ivanm: Yes.
16:48:18 <ivanm> alternatively, is there any way (rather than using shell redirection) to have ghc spit out the core into a file rather than just stdout?
16:48:19 <shachaf> ivanm: There are a bunch of things that I want to do to it.
16:48:28 <monochrom> -ddump-to-file
16:48:29 <ivanm> shachaf: *nod*
16:48:32 <ivanm> monochrom: ta
16:48:34 <shachaf> "patches welcome" and all that, but I'll get to it eventually.
16:48:49 <shachaf> Unfortunately -ddump-to-file loses informtaion. :-(
16:48:55 <zeta-> I've installed ghc and the platform, but a few packages didn't get haddock'ed (just from ghc I think)
16:48:57 <zeta-> How can I run haddock on all the ghc packages? Or will running 'make install' again fix it without hosing ghc itself?
16:49:00 <shachaf> But that's probably not relevant for you.
16:49:11 <ivanm> zeta-: which ones?
16:49:19 <ivanm> if it's just the warnings about rts, you can ignore that
16:49:20 <DanielDiaz> shachaf: what information is lost? I have been using -ddump-to-file for a while...
16:49:23 <dmwit> :t (++)
16:49:24 <lambdabot> Monoid m => m -> m -> m
16:49:43 <shachaf> DanielDiaz: I think it was ordering information.
16:49:57 <otters> :t (<>)
16:49:59 <lambdabot> Monoid m => m -> m -> m
16:50:05 <otters> :t fold
16:50:07 <lambdabot> (Foldable t, Monoid m) => t m -> m
16:50:35 <zeta-> rts was certainly one, but a few others HUnit?
16:51:19 <zeta-> just want to avoid lots of annoying warnings
16:51:25 <otters> I feel like Prelude should just replace (.) with Control.Category..
16:51:49 <monochrom> rts is meant to have no haddock
16:52:06 <otters> what is rts?
16:52:08 <ivanm> zeta-: HUnit doesn't come with the platform AFAIK
16:52:14 <monochrom> HUnit has haddock
16:52:15 <ivanm> otters: the run time system (i.e. C stuff)
16:52:20 <otters> oh
16:52:31 <ivanm> zeta-: are you sure you haven't built stuff yourself with cabal-install afterwards?
16:52:39 <ivanm> you need to enable documentation building in ~/.cabal/config
16:52:42 <monochrom> HUnit comes with Haskell Platform
16:52:48 <ivanm> oh? *shrug*
16:53:10 <ivanm> interesing... despite having "-fno-enable-rewrite-rules", "-ddump-rule-firings" still lists some rules as firing...
16:53:12 <zeta-> Yes but haddock was installed by then
16:54:01 <ivanm> zeta-: ummm, whether haddock was installed wouldn't matter if you installed stuff yourself
16:54:10 <DanielDiaz> ivanm: maybe is running fire rules from modules you are not compiling?
16:54:11 <ivanm> what matters was whether you told cabal-install to use it or not
16:54:48 <ivanm> DanielDiaz: one of them is "Rule fired: Class op $p1Keyless", and Keyless is my class (and I don't have any RULEs in there!)
16:55:03 <ivanm> the other two rules are about return and <=
16:55:09 <ivanm> * <=#
16:55:28 <DanielDiaz> ivanm: Oh, yes. I have seen those rules before in my modules. I supposed they are created automatically.
16:55:32 <ivanm> *nod*
16:55:42 <zeta-> So I need to install the platform and explicitly tell it to generate the haddocks?
16:55:44 <ivanm> though disabling the rules definitely makes all my usage of Vector much slower! :o
16:55:57 <ivanm> zeta-: no, I was talking about if you installed anything yourself afterwards
16:56:03 <ivanm> zeta-: how are you installing the platform?
16:56:30 <zeta-> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
16:57:01 <zeta-> though I'm using ghc 7.6.2
16:57:01 <ivanm> so... you're building it by hand?
16:57:09 <zeta-> yes
16:57:16 <ivanm> that makes a difference then
16:57:22 <monochrom> then it builds docs by default
16:57:43 <ivanm> so you definitely enabled documentation in ~/.cabal/config ?
16:57:59 <zeta-> I thought it should but some have been missed
16:58:22 * zeta- checks
16:58:32 <ivanm> no, it has nothing to do with "some have been missed"
16:58:41 <ivanm> did _you_ enable the setting in your configuration file?
16:59:07 <monochrom> ivanm, the build scripts of haskell platform for unix does not call cabal-install at all
16:59:15 <zeta-> documentation: True
16:59:20 <monochrom> ~/.cabal/config is completely ignored
16:59:33 <ivanm> monochrom: oh, I missed the bit that did that; I saw the bit at the end that had the cabal-install command
16:59:51 <ivanm> zeta-: did you use the pre-built ghc binary or get it from somewhere?
17:00:01 <monochrom> you have to look into the actual build scripts, and IIRC they build docs by default
17:00:23 <ivanm> just checking if it maybe didn't have haddock for some reason
17:01:15 <zeta-> pre-built ghc binary
17:01:22 <monochrom> if the haddock program is not found, a lot more libs will have no doc, such as text
17:02:46 <zeta-> I think it initially had a problem finding haddock...
17:03:09 <ivanm> and so you installed haddock?
17:03:13 <zeta-> but later managed to find it
17:03:40 <zeta-> no haddock was there all along
17:04:08 <zeta-> from part way through building ghc anyway
17:05:21 <zeta-> Can I 'make' just the docs? or the whole lot
17:08:10 <ivanm> zeta-: check the Makefile; might have a documentation flag
17:08:30 <finishingmove> Hello, everyone. Anyone on Windows ?
17:08:49 <ivanm> finishingmove: probably _someone_
17:08:51 <finishingmove> I'm looking for an optimal Haskell development environment on Windows (IDE / editor-wise)
17:08:51 <zeta-> ivanm: Ok thanks
17:09:19 <finishingmove> especially in regards to Haskell's special indentation rules
17:09:28 <ivanm> finishingmove: I don't know about "optimal", but you can use Visual Studio (there's a plugin), there's a prebuilt version of leksah IIRC, or use emacs or vim
17:09:38 <ivanm> (both of which also have editing modes available)
17:10:42 <ivanm> cmccann: so I disabled all the rules... and there's still a time difference :/
17:11:05 <ryant5000> is there a good technique for sharing data between methods of a typeclass? e.g.: suppose you have to print out the name of the type (from a Typeable superclass), and you want to avoid doing the serialization multiple times
17:11:06 <elliott> perhaps cross-module inlining stuff?
17:11:06 <fryguybob> finishingmove: Optimal sort of depends on your personal taste.  I'm happy with notepad++ and powershell, but spend most of my time with putty into a linux machine...
17:11:24 <cmccann> ivanm: interesting
17:12:00 <ryant5000> i've got a situation where i'm doing some fairly involved computation based on the type itself, so ideally i'd like to express it in one place, and also not have it get recomputed every time a method is invoked
17:12:04 <ivanm> ryant5000: write all the definitions outside of the class, and use helper functions, etc.,?
17:12:09 <finishingmove> fryguybob do you use some plugins for syntax highlighting / indentation for N++ ?
17:12:33 <ivanm> elliott: *shrug* if anything, I would have figured my Identity clone would have been better, as the source is right there and more easily inlined
17:12:55 <ryant5000> ivanm: yeah, that's what i'm doing right now: i've got one function, basically (Superclass a) => RecordWithAllTheMethods a, and then i assign each one by hand
17:13:25 <fryguybob> finishingmove: No, just what came with it.
17:13:36 <Saizan> ryant5000: does that ensure the sharing you want?
17:13:48 <fryguybob> finishingmove: On linux I use vi with flymake.
17:13:59 <ryant5000> Saizan: it certainly doesn't seem to ensure it *syntactically*
17:14:16 <ryant5000> Saizan: i guess ghc might pick up on it; i'll give that a try
17:14:22 * cmccann uses SciTE on linux, which is basically a less user-friendly notepad++
17:14:38 <hseg> If I have a StateT Integer (State String foo), how do I distinguish between the inner and outer get/put/modify? Alternatively, if I have a State (Integer, String) foo, how do I bind a function of type a -> State Integer b to it?
17:15:30 <parcs> hseg: using just 'get' you'll get an integer back. use 'lift get' to get a string back.
17:15:45 <cmccann> depends on which "get" you're using
17:15:52 <monochrom> "lift get" gives you the String, "get" gives you the Integer
17:16:00 <cmccann> if it's from MonadState things might be ambiguous
17:16:24 <parcs> hseg: and use mapState re your 2nd question
17:17:07 <Saizan> ryant5000: i think you might need to make the thing you want to share a method of the class, and refer to it by that method's name in the other methods, that way it should get a slot in the dictionary and shared
17:17:28 <hseg> Well, I *am* using MonadState. But so, as long as I keep the signatures correct, I can change the monad wrapped by the StateT as much as I like, and I will get the Integer no matter what?
17:17:44 <monochrom> yes
17:17:48 <ryant5000> Saizan: well, that would make sense, but the "stuff needing to be shared" depends heavily on the particular instance being defined
17:18:19 <ivanm> hseg: any particular reason for not using a combined State?
17:18:24 <Saizan> ryant5000: its type too? i guess one could use a type family
17:18:24 <luite_> ryant5000: http://hdiff.luite.com:3000/ <- live GHCJS heap view ( also other folds at: http://hdiff.luite.com/reduce/ )
17:18:34 <ryant5000> Saizan: maybe i could make an auxiliary class, implement *it* for this type, and then refer to that...
17:19:03 <ryant5000> luite_: sweet!
17:19:09 <hseg> Just the fact that I didn't know about mapState and that the Integer and the String are two distinct states
17:19:34 <luite_> ryant5000: the blue thing is the stack, white is heap
17:19:36 <ryant5000> luite_: it's only using 25% of one core on my machine
17:19:41 <ryant5000> that's not bad at all
17:20:08 <luite_> ryant5000: oh this spends almost 100% of the time in drawing the svg and laying out the graph, which is some d3.js based code, node haskell
17:20:19 <luite_> ryant5000: inspecting the heap is not terribly easy inside haskell
17:20:22 <ryant5000> luite_: yeah, that's great
17:20:23 <ryant5000> yeah
17:20:39 <luite_> it tends to evaluate the things you look at :)
17:20:50 <ryant5000> luite_: haha yeah
17:21:15 <luite_> ryant5000: anyway i hope this can be extended to a full fledged debugger.
17:21:21 <ryant5000> luite_: yeah, that would be great
17:24:10 <luite_> hm it should probably also color statically allocated heap nodes differntly
17:28:24 <ryant5000> Saizan: it looks like dictionaries themselves get rebuilt pretty regularly; if i put a trace in "instance Show Blah" and then run something like "print Blah >> print Blah", the trace shows twice
17:28:30 <ryant5000> (in GHCi, anyway)
17:29:35 <ivanm> ryant5000: well, it's a function, not a constant
17:29:39 <monochrom> there seems to be alternative explanations to that observation
17:29:46 <ivanm> so I would expect it to be run twice
17:29:52 * sw2wolf how to debug xmonad ?
17:30:13 <cads> hey guys, do you guys know if there are opportunities for sponsorship in the haskell community?
17:30:29 <ivanm> sw2wolf: 1) ask in #xmonad; 2) start with saying what your issues are; 3) ??? 4) Profit!
17:30:30 <ivanm> ;-)
17:30:31 <parcs> what kind of sponsorship?
17:30:38 <ryant5000> ivanm: oh, actually, i did the trace wrong in any case :P
17:30:49 <cads> ie, ways for students to connect with mentors to help them with a big haskell project
17:31:02 <cads> like a google summer of code
17:31:03 <luite_> cads: do you want to sponsor me? ;p
17:31:11 <ivanm> ryant5000: heh
17:31:16 <cads> luite_: hah, I don't think I could!
17:31:26 <cads> I think of a sponsor like a thesis advisor
17:31:32 <ryant5000> ivanm: ah ha! like this, it works: show = trace "Building dictionary" $ \_ -> "Blah"
17:31:44 <ivanm> cads: oh, so not "sponsor" in the sense of "give money"
17:31:49 <sw2wolf> ivanm: In fact it is general to debug any haskell app.
17:32:09 <parcs> well, haskell (ghc) does participate in gsoc
17:32:09 <cads> s/he's gotta be so much more advanced than you that it's fairly easy for them to advise you in even the toughest problems you face
17:32:23 <cads> the real tough problems of conceptual development are your own
17:32:25 <luite_> in about a month the gsoc proposals have to be in
17:32:37 <parcs> sooner
17:32:58 <parcs> oh wait, no. in 3 days the accepted organizations will be announced
17:33:19 <cads> parcs: ahaha
17:33:24 <cads> got my hopes up
17:33:31 <parcs> god what a terrible timeline http://www.google-melange.com/gsoc/homepage/google/gsoc2013
17:33:40 <parcs> there is no mention of specific dates...
17:33:46 <ivanm> cads: for GSoC, the usual approach IIRC is to email the mailing list saying what your proposal is, and hope someone agrees to mentor you
17:34:00 <parcs> http://hackage.haskell.org/trac/summer-of-code/
17:34:43 <luite_> yeah, so May 3
17:34:46 <cads> ivan`: are there similar precedents of people pinging the haskell mailing list with a proposal and request for mentorship?
17:35:38 <parcs> i think gsoc requires that each student has a mentor
17:36:02 <cads> yeah, I'm not too interested in participating in that
17:36:04 <parcs> oh wait, are you talking about gsoc anymore? :P
17:36:09 <parcs> okay
17:36:29 <cads> I wonder what it takes to start such an effort in the haskell community
17:36:44 <cads> assuming the incentive is not money
17:37:12 <luite_> what should it be instead?
17:37:36 <cads> well, I see that the stipend is for the student
17:37:45 <tgeeky> some guy raised $20,000 to work on git-annex
17:37:47 <cads> and says nothing of the incentive the mentor gets
17:38:02 <cads> tgeeky: yeah, then he started not delivering!
17:38:03 <startling> tgeeky: heh
17:38:04 <luite_> the organization gets a small amount, to cover the costs
17:38:16 <luite_> but it's only $500 or so, not for the mentor
17:38:23 <luite_> the mentor gets a free t-shirt
17:38:23 <cads> luite_: ah
17:38:26 <cads> haha
17:38:29 <cads> done and done
17:38:34 <cads> free lambda t-shirt?
17:38:35 <cads> ok
17:38:36 <luite_> and 2 people per organization get a free flight to google hq in mountain view
17:38:56 <cads> haha
17:39:16 <tgeeky> I imagine that goes somewhat like the pesant me would would be looking at Versailles, or something.
17:39:32 <tgeeky> Here are all the things money can buy! That you don't have!
17:39:36 <cads> lol fuck a bunch of that imperialist trash
17:39:46 <luite_> tgeeky: it's not that spectaclar :p
17:39:58 <tgeeky> yeah, I suspect. They never show you the cool stuff these days, anyway.
17:40:07 <luite_> lots of green, low rise office buildings like typical for the bay area outside SF center
17:41:01 <cads> so who here feels like they are experienced that they could mentor a student's project without too much effort?
17:41:19 <luite_> depends on the student
17:41:29 <startling> I want to generate pdfs of nicely-styled tables programmatically. For a number of reasons, LaTeX is not appropriate here. What else could I use?
17:41:57 <ivanm> startling: go via HTML then print to PDF?
17:42:04 <cads> luite_: assuming you are able to pick the student, of course
17:42:06 <ivanm> (wkhtml2pdf or something has good results IIRC)
17:42:20 <startling> ivanm: hm, that'd be doable.
17:42:28 <shachaf> Rumour goes I'll get a free t-shirt even without mentoring.
17:42:30 <cads> I would say "hell no", mostly because I would mix up a student more than I'd help them
17:42:33 <luite_> prince also does nice html to pdf, but it's pretty expensive
17:42:38 <ivanm> startling: otherwise... wasn't there someone starting work on a PDF library in Haskell?
17:42:47 <startling> ivanm: no idea, was there?
17:42:55 <cads> shachaf: it's the future, scarcity has been solved, free t-shirts for everyone :P
17:43:06 <ryant5000> Saizan: it looks like the sharing does work out pretty well.  the dictionary seems to get built when i call a function with a (Show Blah) constraint from a function that doesn't have one
17:43:08 <startling> I suppose I could do postscript, too, but then I'd need to do alignment on my own.
17:43:15 <ivanm> @hackage HPDF
17:43:15 <lambdabot> http://hackage.haskell.org/package/HPDF
17:43:18 <ivanm> startling: ^^
17:43:33 <ivanm> there's also HsHaruPDF, whatever that is
17:43:48 <startling> ivanm: wow cool
17:43:59 <ivanm> pdf-toolbox-core, but I'm not sure if it can generate PDF
17:44:08 <startling> it even has some typesetting stuff figured out already.
17:44:45 <ivanm> line2pdf apparently does text -> pdf stuff
17:44:51 <tgeeky> ivanm: nice. what's for reading PDFs?
17:45:08 <ivanm> tgeeky: pdf2line? ;-)
17:45:17 <ivanm> pdf-toolbox-core is meant to be for manipulating pdfs
17:45:25 <tgeeky> ivanm: i was saying nice to HPDF
17:45:34 <ivanm> tgeeky: ahhh *shrug*
17:45:41 <ivanm> I just searched for pdf on the hackage page ;-)
17:45:46 <tgeeky> ok
17:46:04 <ivanm> though the main module for line2pdf is weird; it just re-exports the internal module with no documentation :s
17:46:16 <cads> shachaf: do you feel like it would be too much of a commitment? You'd have to listen to a possibly teenage person whicker on about that week's stupid pile of mistakes. And what if the little fuck doesn't deliver, and you sponsored him for nothing more than a lambdabot t-shirt.
17:46:20 <cads> A limited edition.
17:46:23 <cads> lambdabot
17:46:27 <cads> t-shirt
17:46:39 <otters> luite_: can you make it faster
17:46:46 <tgeeky> cads: if you are in industry or university, you may have an obligation to do mentorships of one sort or another
17:46:52 <cads> I'm sure that would still be a horrible spit in the eye :D
17:47:17 <luite_> otters: the heap view? yeah probably by optimizing the graph layout javascript. chrome is much faster than firefox here btw
17:47:24 <otters> I'm using Safari
17:47:34 <luite_> oh haven't tested that, i'll try now
17:47:46 <cads> tgeeky: I know that some professors are obligated to mentor theses, but I didn't know about any other kind of requirements.
17:48:23 <tgeeky> cads: I remember professors being obligated to mentorship and speaking engagements at Georgia Tech.
17:48:28 <tgeeky> for local high schools
17:48:38 <tgeeky> at least, in my College, not in the University level
17:48:42 <cads> hah, I should check that out
17:48:48 <parcs> what does "obligation" mean in contract law? :P
17:49:05 <cads> tgeeky: I had forgotten you live near the A
17:49:10 <luite_> otters: oh looks about as fast as chrome here
17:49:35 <luite_> otters: but still, it's really unoptimimized. it should probably not relayout the whole graph every time
17:49:42 <tgeeky> I could be a mentor, and would do it, if I had the credentials.
17:49:50 <luite_> just add nodes and do a full relayout once in a while
17:49:56 <tgeeky> I could also be a student, if I had the credentials :)
17:50:12 <luite_> you need credentials to be a mentor? oh sh*
17:50:22 <luite_> i'll send back my t-shirt :p
17:50:22 <parcs> oh wow obligation actually means "required". i always thought it meant "strongly encouraged"...
17:50:38 <cads> luite_: yeah, because most people think they'd make a _great_ mentor
17:50:55 <cads> "pick a topic, yeah I'll teach ya"
17:51:25 <ryant5000> parcs: but what does "required" really mean in contract law? :P
17:51:29 <tgeeky> well it's different in GSoC anyway. It's more like, convince me that you can do one of the following topics
17:51:46 <tgeeky> or convince me that your (++ "your topic") is appropriate
17:51:49 <parcs> ryant5000: "do it or you're fired" probably
17:52:06 <cads> parcs: obligations tend to imply consequences to their being broken.
17:52:13 <tgeeky> parcs: in this case, yes. Well, do it if you want to recieve your salary.
17:52:52 <ryant5000> parcs: yeah, i guess it probably means "required", lol
17:54:20 <cads> Obligation  A Juridical relation whereby a person maydemand from another the observance of a determinativeconduct (giving, doing, not doing), and in case of breach,may demand satisfaction from the assets of the latter.
17:54:31 <cads> source: http://www.scribd.com/doc/4068616/Obligations-and-Contracts
17:54:34 <cmccann> ryant5000: it means "do what this says or you get to find out what less pleasant parts of the contract mean as well"
17:54:59 <cads> Contract  Meeting of the mind between two persons whereby one binds himself, with respect to the other, togive something or to render some service.
17:55:06 <ryant5000> cmccann: haha i'm well aware ;)
17:55:17 <cads> A contract necessarily gives rise to an obligation but anobligation does not always need to have a contract.
17:55:27 <cads> this is awesome language
17:55:42 <ryant5000> cads: you should start using the terms "obligor" and "obligee" ;)
17:55:53 <cads> I love how philosophical law can be
17:56:05 <cads> I mean "a meeting of the mind"!
17:56:16 <ryant5000> cads: yup, some people say it's basically "applied philosophy"
17:56:19 <cads> so abstract :)
17:56:35 <cads> ryant5000: sounds right
17:56:51 <cads> and add math too, and you get economics :D
17:57:18 <cads> take away ethics, and you get finance
17:57:48 <luite_> otters: here's the ticket, if you want to help ;p https://github.com/ghcjs/ghcjs/issues/61
17:58:20 <cads> hmm, it's clear from this article that these lawyer guys don't know that contracts live in a monad
17:58:31 <cads> but are probably implicitly using that fact
17:58:42 <cmccann> cads: I dunno, math and philosophy have too much grounding in reality to add up to economics :P
17:58:55 <cads> cmccann: zing!
17:59:29 <ivanm> so I just used Vector's Id monad instead of Identity... still slower :s
18:00:59 <ivanm> WHY IS IDENTITY SO MUCH FASTER?!?!?!?!
18:01:16 <cmccann> ivanm: shenanigans
18:01:19 <parcs> is Id a newtype?
18:01:36 <ivanm> the only thing I can think of is because there's "type State s = StateT s Identity", it somehow optimises... :/
18:01:38 <ivanm> parcs: yes
18:02:09 <cmccann> ivanm: c'mon man it's time to inspect the core
18:02:15 <cmccann> gotta figure this out
18:02:25 <cmccann> do it for SCIENCE
18:02:32 <parcs> wait a second are you using the Identity from transformers?
18:02:51 <ivanm> parcs: yes
18:03:57 <elliott> ivanm: it's time to give up. you can't possibly compete with the high-quality industry-strength optimised identity monad that transformer has.
18:04:00 <elliott> too much work has been put into it.
18:04:04 <ivanm> elliott: heh
18:04:31 <monochrom> you may have to look at core afterall
18:04:32 <parcs> where's the Id monad from?
18:04:32 <ivanm> I'm hoping determining this will help me figure out how to get performance back when I generalise my type sig to let me use any Monad, not just Identity
18:04:48 <ivanm> parcs: Data.Vector.Fusion.Util
18:05:15 <ivanm> I've also defined my own newtype MI a = MI { runMI :: a } monad as a comparison
18:05:17 <monochrom> however, you may suspect that looking at core is still not enough. because: after looking at core and seeing the difference, the question "but why are they different?" remains
18:05:19 <ivanm> it's also slow
18:05:31 <ivanm> monochrom: hence why I'm avoiding reading the core
18:05:56 <ivanm> OK, I think part of the issue was that I was using the mtl version of StateT rather than transformers
18:06:05 <ivanm> and thus there's lift going on...
18:06:09 <shachaf> cads: I'm not sure that's how I'd put it.
18:06:17 <monochrom> this is a great time to say something like "some people say, 'I know, I will look at core'. now they have two problems" :)
18:07:10 <shachaf> ivanm: What are you doing, anyway?
18:07:17 <parcs> core is not so bad once you learn about -dsuppress-all, which makes it look like haskell without type signatures
18:07:54 <ivanm> shachaf: short version: when trying to work out how to optimise some Monadic code (which is actually pure but wrapped with a Monad), I found that using Identity was faster than using a clone of Identity
18:08:18 <monochrom> -ddepress-all
18:08:40 <ivanm> now I find that if I use Control.Monad.Trans.State rather than Control.Monad.State, my usage of StateT is identical for Identity and a custom variant
18:08:54 <cmccann> monochrom: btw, sorry about giving you a hard time the other day. :[ honestly wasn't trying to antagonize you.
18:08:58 <ivanm> but it's slower than using Identity with Control.Monad.State.StateT :/
18:09:48 <monochrom> ok, thanks
18:10:40 <Michael__> Is there a way, in template haskell/haskell, to get the number of arguments a type constructor takes?
18:11:34 <cmccann> Michael__: with TH I'm sure you can get that from reifying whatever it is
18:13:33 <ivanm> isn't that how the "smart" version of fst/snd works, which uses TH to let you get the specified element from an n-tuple?
18:14:06 <ivanm> OK, for some reason using StateT from mtl is faster than using StateT from transformers
18:14:19 <ivanm> just changing the import statement makes the difference
18:14:22 * ivanm == confused
18:14:41 <cmccann> it's probably edwardk's fault somehow
18:16:24 <no-n> data Person = Person { firstName :: String, lastName :: String } -- is there a way make records such that the fields can be accessed something like person.firstName and not go into the local namespace?
18:16:45 <ivanm> no-n: it's a common request
18:17:04 <ivanm> but IIRC no-one has found a syntax, etc. that the consensus agrees upon
18:17:12 <ivanm> as it is, the existing record syntax is a compromise
18:17:25 <no-n> ok
18:17:59 <cmccann> disliking the current record syntax is the only thing there's broad agreement on
18:19:14 <no-n> heh
18:19:35 <no-n> you'd think they'd come to something after 20 years :/
18:19:53 <cmccann> well there's no shortage of ideas
18:20:16 <no-n> ok
18:20:55 <dolio> Changing the syntax to r.lastName doesn't really fix the issues that bug a lot of people.
18:20:55 <geekosaur> what they come to after 20 years is ever more baroque bikeshedding...
18:20:56 * cmccann prefers skipping all the fancier stuff and just letting data types introduce a qualified namespace
18:20:59 <no-n> any idea when it might change by?
18:21:08 <sipa> 2140?
18:21:16 <no-n> lol
18:21:57 <no-n> cmccann: how do I do that?
18:22:05 <Cale> dolio: I would *hate* that
18:22:23 <cmccann> no-n: you don't, that's the point
18:22:25 <parcs> n-
18:22:33 <Cale> no-n: The period is already foolishly overloaded
18:22:37 <cmccann> it's what I'd prefer instead of various fancier stuff about resolving overloaded names
18:22:45 <Cale> I dislike the fact that it's being used for module qualification enough
18:22:49 <parcs> no-n: you can use the 'lens' package to fix both problems
18:23:20 <parcs> but instead of person.firstName it'll be person^.firstName
18:23:54 <dolio> Obviously r::firstName is the way to go.
18:23:54 <Cale> no-n: (.) is supposed to be function composition, or at least a generalisation of it :)
18:24:09 <no-n> ah, yeah. true, lol.
18:25:06 <parcs> actually i don't think 'lens' helps with the namespacing problem. or does it?
18:25:16 <Cale> I want field extraction to be a function, in any case, and it's best if whatever we represent it by looks at least something like function application.
18:25:19 <elliott> it sort of does
18:25:20 <dolio> You have to manually namespace with type classes.
18:25:26 <dolio> Like Wadler intended.
18:25:34 <elliott> there is machinery for auto-typeclassey stuff but it's a bit rough
18:25:38 <Cale> The namespacing problem is a non-issue
18:26:21 <Cale> Just name things distinctly and stop whining :P
18:26:47 <parcs> but naming is hard
18:27:01 <dolio> Yeah.
18:27:27 <dolio> Ed and I were working a week or two ago, and realized we needed a notion of identifier wider than the 'global' names we had.
18:27:36 <dolio> So we were thinking about naming it cosmic.
18:27:38 <dolio> Or galactic.
18:27:54 <parcs> hard
18:27:59 <parcs> oops
18:28:11 <sipa> universal?
18:28:23 <Cale> Or just stellar -- maybe you're not leaving the solar system yet :)
18:28:38 <parcs> superglobal
18:28:39 <dolio> See, the problem with universal or cosmic is that you have nowhere to go if the same thing happens again.
18:28:46 <elliott> multiversal
18:28:51 <parcs> and then supersuperglobal
18:28:54 <Cale> interplanetary
18:28:56 <cmccann> intergalactic
18:29:02 <sipa> mathiversal
18:29:18 <geekosaur> stellar, galactic, supergroup, universe, ...
18:29:27 <dolio> Superduper comes after super.
18:29:37 <parcs> metaglobal
18:29:52 <geekosaur> global', global'', global''', ...
18:30:01 <sipa> moar
18:30:18 * cmccann figures that the sequence of larger scopes needs to end with "yourmom"
18:30:23 <cmccann> it's like tradition or something.
18:30:31 <sipa> that's what she said
18:30:36 <Cale> naming is easy, you just pick one letter and then you name all your things that letter with some number of primes
18:30:40 <ion> globaller
18:30:42 <sipa> oh, this isn't -blah!
18:31:02 <Cale> x, x', x'', x''', x'''', x''''', ... infinitely many names, how many more do you need?! :)
18:31:08 <dolio> I think I also suggested simplical instead of global.
18:31:32 * ion suddenly got a flashback to the Global Trash demo on Amiga.
18:32:07 <ldgonza> also they're easier to translate to a godel code
18:32:33 <cmccann> how about "global", "gloobal", "glooobal", &. especially if you pronounce it with a proportionally drawn-out vowel.
18:32:54 <cmccann> or maybe extend the "a" instead. or both vowels, dunno.
18:33:09 <geekosaur> gooooogle probably has that trademarked :p
18:33:13 <cmccann> haha
18:33:33 <dolio> Oh, we also have "Schema" for kind schemata, and we entertained the idea of the same construct at the type level.
18:33:46 <dolio> But KindSchema and TypeSchema is annoying.
18:33:59 <dolio> So, the best I could come up with what "Schema" for kinds and "Scheme" for types.
18:34:28 <dolio> With was, even.
18:38:16 <monochrom> Gödel Summer of Code?
18:38:47 <ryant5000> The First Rule of Gödel Summer of Code is: we do not talk about Gödel Summer of Code.
18:39:10 <ryant5000> at least not if we're participating
18:39:31 <monochrom> why? I thought Gödel loved self-references!
18:39:47 <ldgonza> The second rule is: some rules may be true, but we can't proove it
18:40:03 <ryant5000> haha
18:40:16 <cmccann> they only accept projects that involve being rejected from Gödel Summer of Code in the plan
18:40:42 <lightquake> oh, huh. i just realized that the reason that 'join id' is ill-typed in haskell is because (join id) (join id) would have type forall a. a
18:40:55 <ldgonza> Either that, or the judges are incoherent!
18:41:50 <cads> The Grothendieck Summer of  Code!
18:42:22 <cads> winners earn a fields medal, then quit math, and vow to talk only to flowers
18:42:59 <cads> the Peyton Jones Summer of Code
18:43:21 <cads> winners (and losers) forced to wear a literal hair shirt all summer.
18:43:33 <cads> shirt has a 'lambda' crocheted into the front
18:43:45 * cmccann figures a Galois Summer of Code would end with pistols at dawn
18:43:55 <cads> fukyea.jgp
18:44:03 <cads> +1 cmccann
18:57:34 <ivanm> cmccann: I think I've worked it out: mtl and transformers have different definitions of gets!
18:58:07 <cmccann> well yeah
18:58:17 <cmccann> one is monomorphic to StateT
18:58:21 <cmccann> the other is part of MonadState
18:58:32 <monochrom> ho hum. that's right. but it should mean the mtl one is slower (it's one more layer of abstraction). is that what you observe too?
18:58:51 <ivanm> monochrom: it depends on the base Monad
18:59:12 <ivanm> when using Identity, the mtl one is faster; when using a clone of Identity the transformers one is faster
19:00:15 <monochrom> that's what bugs me and prevents me from believing most explanations. mtl should not be faster, ever.
19:02:40 <monochrom> I mean this: most explanations predict that mtl should not be faster. therefore I don't believe those explanations.
19:03:34 <ivanm> huh?
19:05:10 <monochrom> ok, you have made observations, and you are looking for a theory to explain the observations
19:05:18 <ivanm> yes
19:05:39 <monochrom> for example, one theory is "mtl's get is different from transformer's get"
19:05:55 <monochrom> but that theory predicts something contrary to the observations
19:06:15 <ivanm> well, that's not a theory, it appears to be true... :p
19:06:25 <pharaun> pragma to rewrite rules for speedups?
19:07:17 <monochrom> oh ok, yes, it is a true statement. but it does not explain one observation.
19:07:31 <cmccann> ivanm: what happens if you duplicate StateT and/or MonadState, do you get similar differences?
19:07:35 <ivanm> well, I'm trying again, this time explicitly copying the definition out and changing between them
19:07:43 <ivanm> cmccann: haven't gone that far yet :p
19:07:44 <cmccann> might help to narrow down where the shenanigans are occurring
19:08:12 <Saizan> are there any SPECIALISE pragmas for StateT s Identity?
19:08:44 <ivanm> Saizan: there aren't any pragmas of any kind that I can find in mtl or transformers
19:08:53 <ivanm> (that apply, anyway; there are some LANGUAGE pragmas)
19:09:26 <cmccann> ivanm: also what if you import absolutely nothing you don't have to? make sure there aren't rogue pragmas sneaking in from parts unknown.
19:09:26 <monochrom> there are still two factors not explored
19:09:54 <monochrom> 1. somehow, you built transformers and mtl with different optimization levels
19:11:06 <monochrom> 2. code optimization is a lot of heuristics, perhaps it is just being fragile at one tiny difference
19:11:32 <cmccann> I think point 2 is already under consideration
19:12:02 <cmccann> in that he wants to reproduce the improved performance whatever the reason is :P
19:12:10 <Nisstyre-laptop> Is there a hash library that works with Text?
19:13:15 <ivanm> OK, for the record: using Id from vector with transformer-gets is ~45s, mtl-gets is ~52s; Identity with transformer-gets is ~44s, using mtl-gets is ~53s
19:13:42 <ivanm> for these cases, I copied the definition of gets from the respective libraries into my own
19:14:09 <cmccann> those numbers sound reasonable, right?
19:14:14 <ivanm> cmccann: yup
19:14:15 <ivanm> so when StateT is on top of your transformers stack, it appears that using the definition of gets from transformers is more efficient
19:14:29 <cmccann> that also makes sense
19:14:36 <ion> nisstyre: Data.Hashable seems to work.
19:14:38 <ivanm> now I'm going to check this again using the version of gets from the libraries themselves makes a difference
19:15:31 <Nisstyre-laptop> ion: okay cool
19:15:41 <Nisstyre-laptop> I was looking at Data.Digest
19:15:47 <ivanm> oh, and for the record, I was using the mtl export of StateT for that; but apart from some class-based indirection for get, put and state there shouldn't be a difference
19:16:33 <Nisstyre-laptop> ion: is Data.Hashable cryptographic? It's fine if it's not.
19:16:52 <ion> nisstyre: Probably not.
19:17:09 <ivanm> monochrom: I used the default options for both transformers and mtl; both using my distro packages (which are source-based and use Cabal)
19:17:11 <Nisstyre-laptop> ion: cool, then it's exactly what I need
19:17:14 <monochrom> if it is fast, it is not cryptographic :)
19:17:38 <ivanm> now, here's the fun bit: if I actually use gets from mtl, the runtime for using Identity is ~37s :/
19:19:13 <ivanm> using StateT from mtl, hiding gets and using gets from transformers (with Identity from transformers), ~45 s
19:21:30 <ivanm> in comparison, not using mtl at all is ~45s again
19:21:40 <ivanm> so somehow there must be some extra magic optimisations coming through with mtl
19:23:32 * ivanm is even more confused now
19:24:08 <monochrom> transformers.cabal and mtl.cabal do not specify any optimization flags. therefore, if your distro is not naughty, they both get the default -O
19:25:09 <ivanm> well, it definitely doesn't do any per-package specific mangling that I know of
19:26:29 <ivanm> nope, no explicit optimisation flag usage for any package
19:30:21 <ivanm> I can think of three possibilities: 1) somehow GHC does some uber optimisations for the definition of gets for StateT s Identity in mtl which somehow doesn't apply when I copy/paste the definition of gets into my own source code
19:30:43 <ivanm> 2) the fact that it's via a class lends itself to some optimisation (when in general I find that the opposite is true)
19:31:12 <shachaf> Have you pasted code yet?
19:31:20 <ivanm> shachaf: it's rather large to paste :/
19:31:29 <pharaun> ivanm: no reduced snippet?
19:31:34 <shachaf> Well, reducing it is a good way to figure out what's going on.
19:33:03 <ivanm> except that this is coming from the benchmark of a new library I'm working on, so I'm not sure how to reduce it sanely :/
19:34:11 <ivanm> that's why it's taken me so long even to work out that changing the definition of "gets" can make such a difference
19:34:56 <shachaf> Reducing big test cases into small test cases is a useful skill.
19:36:24 <ivanm> *nod*
19:37:06 <ivanm> I've done it before; but since the actual test case is a BFS traversal of a graph, it's a bit hard to work out where I can start reducing it
19:38:08 <ab9rf> are you testing the actual traversal?
19:38:26 <ab9rf> or testing some other thing that is computed during a traversal?
19:40:16 <ivanm> ab9rf: testing the underlying data structure used for the graph
19:40:26 <ivanm> this is a _benchmark_, not a test suite :)
19:40:54 <ab9rf> ah
19:41:27 <ivanm> duh, I'm doing the traversal four different ways and (for now) two different inputs; simplifying that would help reducing the problem
20:22:44 <ldgonza> anyone knows how to stop a computation in emacs inferior haskell buffer?
20:22:57 <ldgonza> without killing the buffer outright, that is
20:23:09 <cmears> C-c C-c will usually do it
20:23:18 <cmears> Just hammer away at C-c until something happens
20:25:52 <ldgonza> ah superb, there it is
20:25:56 <ldgonza> thanks
20:26:04 <rosslazer> Hello
20:26:12 <rosslazer> I have a question about the snd command
20:26:21 <ldgonza> I had redefined C-c C-C as something else, turns out the upper case doesn't work with C- prefix
20:26:38 <ldgonza> doesn't differentiate it from C-c I mean
20:26:50 <cmears> Right, C-C === C-c
20:27:01 <rosslazer> when I map it to a pair ('T','A')  it returns "A"
20:27:09 <rosslazer> I need 'A', the A to be a char
20:27:12 <rosslazer> for my function
20:27:15 <rosslazer> any thoughts?
20:27:43 <cmears> > snd ('T', 'A')
20:27:44 <lambdabot>   'A'
20:28:01 <cmears> so something about your map is going awry
20:28:10 <ldgonza> if you're mapping you're basically getting snd('T', 'A') : something_else
20:28:10 <rosslazer> map snd [('A','T')]
20:28:30 <rosslazer> Because it's in a list
20:28:32 <cmears> > map snd [('A','T')]
20:28:34 <lambdabot>   "T"
20:28:37 <rosslazer> right
20:28:40 <cmears> right, so you are getting a list of answers
20:28:42 <ldgonza> you're getting 'T':[]
20:28:45 <rosslazer> right
20:28:48 <rosslazer> how do I just get T
20:28:51 <cmears> with one element
20:28:51 <rosslazer> anonymous function?
20:28:57 <ldgonza> head?
20:28:59 <cmears> don't put pair in a singleton list
20:29:21 <rosslazer> map head doesn't work
20:29:25 <ldgonza> head $ map snd  [('A', 'T')]
20:29:42 <rosslazer> THANK YOU!
20:29:46 <ldgonza> you're not going to be able to get a single element out of a map
20:30:18 <rosslazer> idgonza thanks this was a part of a CS homework problem
20:30:40 <ldgonza> but it's kinda wierd that you're having to map it though, doesn't make much sense
20:30:43 <rosslazer> I had this list called pairs = [('A','T'),('C','G'),('G','C'),('T','A')]
20:31:04 <rosslazer> and I had to check to See if one of the first elements in each of the pairs matched
20:31:12 <rosslazer> so I used an anon function match x  =  head $ map snd (filter (\(y,z) -> x==y) pairs)
20:31:16 <rosslazer> See the filter part
20:31:33 <cmears> Ah
20:32:15 <cmears> Probably best to do something sensible if none of them match...
20:32:52 <newsham> ?hoogle [a] -> Maybe a
20:32:52 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
20:32:53 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
20:32:53 <lambdabot> Prelude head :: [a] -> a
20:33:11 <newsham> s/head/listToMaybe/
20:33:26 <Clint> @src lookup
20:33:26 <lambdabot> lookup _key []          =  Nothing
20:33:27 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
20:33:27 <lambdabot>                         | otherwise = lookup key xys
20:33:56 <newsham> > lookup 'C' [('A','T'),('C','G'),('G','C'),('T','A')]
20:33:57 <lambdabot>   Just 'G'
20:34:41 <NemesisD> was hoping someone could help me. i've painted myself into a corner with this code.
20:34:57 <newsham> i assume its not corner-painting code?
20:35:02 <ab9rf> NemesisD: what code?
20:35:05 <Clint> that would be in LOGO
20:35:17 <ldgonza> or Processing
20:35:57 <NemesisD> https://github.com/MichaelXavier/librato-haskell/blob/streaming-result/src/Network/Librato/Types.hs#L47 is the type, i get a problem here https://github.com/MichaelXavier/librato-haskell/blob/streaming-result/src/Network/Librato.hs#L111
20:35:59 <hpaste> NemesisD pasted “StateT in IO/Generator monad” at http://hpaste.org/85226
20:37:22 <NemesisD> basically this Librato.hs from top to bottom is structured to wrap LibratoM, which is an alias for a partially applied StateT. everything is good until i get to defining something in the Generator monad (which is an instance of MonadIO)
20:38:03 <Clint> why are you trying to liftIO getPaginatedPage?
20:38:07 <NemesisD> there's a bunch of cruft in that file but the areas of interest start at line 101 and onward
20:39:23 <jfischoff> ab9rf: I haven't tried is out at all, but the beginnings of a LLVM assembly quasiquoter: https://github.com/jfischoff/llvm-quasi/blob/master/src/LLVM/Assembler/Grammar.hs
20:40:01 <NemesisD> Clint: was just playing around with it. if i drop the liftIO i get couldn't match S.StateT ClientConfiguration m0 with Generator a. expected Generator a (LibratoResponse (PaginatedResource a)), actual type LibratoM m0 (LibratoResponse (PaginatedResource a))
20:40:41 <NemesisD> so its like i need to get that generator "under" my LibratoM transformer, i think?
20:48:42 <NemesisD> if i change the typesig of pageGenerator to: ByteString -> PaginatedRequest query -> LibratoM m (Generator a ()) and set it to undefined it works. just need to figure out how to steer the implementation into that type...
20:49:19 <rosslazer> I have a function that ends in the type Maybe [(Char,Char)]
20:49:27 <rosslazer> and I have two strings called s1 and s2 why doesn
20:49:41 <rosslazer> doesn't the following function return that type
20:49:42 <rosslazer> zip (map (\x -> [x]) s1) (map (\x -> [x]) s2)
20:50:19 <NemesisD> i'm not seeing where that Maybe would come from
20:50:39 <rosslazer> Well Maybe can be Nothing or [(Char,Char)] right?
20:50:47 <rosslazer> Full function
20:50:47 <rosslazer> zipDNA :: String -> String -> Maybe [(Char,Char)]
20:50:48 <geekosaur> no
20:50:48 <rosslazer> zipDNA s1 s2
20:50:50 <rosslazer> 	| (dnaMatch s1) == s2 = zip (map (\x -> [x]) s1) (map (\x -> [x]) s2)
20:50:50 <rosslazer> 	| otherwise = Nothing
20:51:02 <rosslazer> ??
20:51:06 <geekosaur> Nothing or Just [(Char,Char)]
20:51:06 <NemesisD> yeah but your function does nothing to construct a maybe
20:51:17 <geekosaur> the Just is not optional
20:51:37 <newsham> > let f x = [x]; s1 = "test"; s2 = "this" in zip (map f s1) (map f s2)
20:51:38 <lambdabot>   [("t","t"),("e","h"),("s","i"),("t","s")]
20:51:50 <newsham> > let f x = [x]; s1 = "test"; s2 = "this" in zip s1 s2
20:51:52 <lambdabot>   [('t','t'),('e','h'),('s','i'),('t','s')]
20:52:01 <newsham> did you want the latter?
20:52:09 <rosslazer> yes
20:53:12 <rosslazer> I'm confused though with your syntax
20:53:22 <rosslazer> oh wait
20:53:24 <rosslazer> I see it not
20:53:28 <ldgonza> why are you turning the elements into lists?
20:53:40 <ldgonza> oh unless you want strings
20:53:59 <BMeph_> Is "map (:[])" faster than "(transpose . (:[]))"?
20:54:32 <rosslazer> So it needs to say Just? got it thanks guys
20:55:29 <ab9rf> :t transpose . (:[])
20:55:30 <lambdabot> [a] -> [[a]]
20:55:36 <newsham> ross: your function has to return the same type in all cases.  if it returns a "Nothing" in one case then it must return either a Nothing or a Just x in other cases
20:55:51 <ab9rf> @src transpose
20:55:51 <lambdabot> transpose []             = []
20:55:51 <lambdabot> transpose ([]   : xss)   = transpose xss
20:55:51 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:56:03 <newsham> ross: because   Maybe a = Nothing | Just a
20:58:06 <ab9rf> BMeph_: i'd expect the map to be faster because it doesn't involve additional list comprehensions, but you'd have to profile to know for sure
20:59:16 <arkeet> transpose ([]:[]) = transpose [] = [], transpose ((x:xs):[]) = (x : []) : transpose (xs : [])
20:59:30 <arkeet> I wouldn't be surprised if it generated the same code as map (:[])
20:59:40 <ab9rf> arkeet: yeah, that was my expectation actually
21:00:01 <ab9rf> arkeet: since the list comprehensions are over empty lists in this case
21:00:23 <arkeet> I would much rather *read* map (:[]), though
21:00:30 <arkeet> (and write)
21:00:34 <ab9rf> the map (:[]) is much more obvious what it's doing
21:00:55 <ab9rf> (it's feeding each element of the list to a monkey)
21:01:29 <newsham> consmonster
21:01:43 <NemesisD> how should i read: "Could not deduce (m ~ Generator a0)
21:02:21 <newsham> (:[]) would be a nice t-shirt image
21:02:28 <arkeet> NemesisD: ~ is type equality. who knows what's going on without the rest of the message, though?
21:02:58 <ab9rf> newsham: it amuses me that quite a few smilies are valid haskell operators
21:03:11 <newsham> http://www.thenewsh.com/~newsham/consMonster.jpg
21:03:27 <newsham> though prob the braces should be red
21:04:54 <hpaste> NemesisD pasted “could not deduce ” at http://hpaste.org/85227
21:05:30 <NemesisD> arkeet: ^ i'm stuck. it seems like i could maybe solve this by adding more stuff to the typeclass constraints or being more specific about the type variable m?
21:07:04 <arkeet> NemesisD: your type claims to work for any m.
21:08:04 <arkeet> I have no idea what the type of getPaginatedPage is.
21:08:42 <ab9rf> FromJSON has a fairly wide polymorphic type
21:08:47 <ab9rf> you may need to put a signature on that
21:10:51 <NemesisD> hmm, i'm still kind of stuck on the error, it says cannot deduce m ~ Generator a0, so am I trying to put enough constraints on m such that Generator a0 satisfies it?
21:11:16 <arkeet> what if you just drop the type signature and see what it infers?
21:12:16 <ab9rf> actually, it's looking for a FromJSON (PaginatedReponse a)
21:12:23 <NemesisD> hmm. doing that it says could not deduce (FromJSON (PaginatedResponse a0)) arising from use of pageGenerator
21:12:27 <ab9rf> does PaginatedResponse have a FromJSON instance?
21:13:55 <NemesisD> i got some help with that type signature, i've defined some instances like so: instance FromJSON (PaginatedResponse Foo)
21:14:28 <arkeet> it would help a lot if you could actually show us the types of the other things you're using.
21:14:43 <ab9rf> yeah, we're kinda pissing in the wind here
21:15:33 <RenJuan> I wish there was a haskell app server that wasn't trynna be a web server
21:15:34 <NemesisD> yeah. i apologize for how much context this entails. the files in question live here https://github.com/MichaelXavier/librato-haskell/blob/streaming-result/src/Network/Librato.hs#L111 and here https://github.com/MichaelXavier/librato-haskell/blob/streaming-result/src/Network/Librato/Types.hs#L47
21:24:33 <ab9rf> NemesisD: i think your problem is the use of unless
21:24:40 <ab9rf> :t unless
21:24:41 <lambdabot> Monad m => Bool -> m () -> m ()
21:25:17 <ab9rf> hm, hold on
21:25:24 <ab9rf> no, you have Generator a ()
21:28:53 <ab9rf> i don't see why m can't be unified to Generator a0
21:30:37 <ab9rf> of course, the error message doesn't match the code at github either
21:30:56 <NemesisD> ab9rf: yeah and i'm actually commenting unless in the code im looking at now just to figure things out. by unify do you mean specify it instead of m?
21:32:49 <NemesisD> oh, and isn't there a type extension where type variables in the where clause reference those in the main function's type signature?
21:34:01 <ab9rf> NemesisD: i was wrong on unless, i got some of the types confused
21:35:15 <ab9rf> NemesisD: the error in your past specifies a type signature for pageGenerator that is different from that in the source file.  that makes contributing to your analysis difficult.
21:35:46 <NemesisD> ab9rf: you're right. i'll push up what i'm working with atm
21:37:53 <ivanm> just to make things interesting... whilst trying to reduce my test case, I now have the mtl version being slower :/
21:38:19 <NemesisD> ab9rf: ok pushed. the error at present is:
21:38:21 <hpaste> NemesisD pasted “deduce generator” at http://hpaste.org/85230
21:40:03 <NemesisD> if replacing m with Generator a0 is the solution and it bubbles all the way up to the topmost function, i think that might be a problem and i think i'd have to stop that nonsense with a liftIO somewhere
21:41:58 <ab9rf> why does ClientConfiguration have two Generator type parameters?
21:43:02 <ab9rf> oh, that's StateT
21:43:14 <ab9rf> i'm obviously too tired
21:43:15 <NemesisD> yeah
21:43:43 <ab9rf> i'm still concerened about (Generator a a0)
21:44:06 <ab9rf> normally the second type parameter in a Generator is not a monad
21:44:41 <ab9rf> but it's forced to be one because of (Generator a0) before that
21:45:05 <NemesisD> ab9rf: yeah i am a bit confused by it too. i don't know what the second type parameter of generator means: http://hackage.haskell.org/packages/archive/io-streams/1.0.1.0/doc/html/System-IO-Streams.html#g:8
21:45:36 <NemesisD> fromGenerator throws it away and yield forces it to be ()
21:46:50 <ab9rf> NemesisD: that's one of those things i don't really understand yet
21:47:19 <ab9rf> NemesisD: but i'm suspicious that you have some type arguments switched somewhere, or something
21:50:32 <ab9rf> i'm suspicious now of the liftIO in getRequestStreaming
21:51:25 <ab9rf> what type do you expect it to lift into?
21:51:39 <NemesisD> ab9rf: fromGenerator results in an IO, i have to lift that into my LibratoM no?
21:52:27 <ab9rf> oh LibratoM is a type alias
21:53:00 <NemesisD> yeah. it's a pattern i picked up a while ago
21:53:11 <ab9rf> (Generator a0) is an incompletely applied type constructor
21:53:35 <ab9rf> that's why it's balking
21:53:58 <ab9rf> i think
21:54:19 <NemesisD> ahh yeah you're right, hmm
21:55:12 <NemesisD> i'm never explicitly specifying that partially applied type constructor anywhere currently
21:55:31 <ab9rf> might be liftIO generating it
21:55:43 <ab9rf> comment out the signature on getRequestStreaming and see what happens
21:57:36 <xenon21> ?src sequence
21:57:36 <lambdabot> sequence []     = return []
21:57:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:57:36 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
21:57:45 <ab9rf> (Generator a0) is problematic, since a0 pretty much has to be ()
21:57:58 <ab9rf> and () is not a monad
22:06:09 <hpaste> “Anonymous Coward” pasted “zz” at http://hpaste.org/85231
22:07:15 <xenon21> sorry, where can I find sources like this
22:07:19 <xenon21> ?src sequence
22:07:19 <lambdabot> sequence []     = return []
22:07:19 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:07:19 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
22:07:48 <ivanm> xenon21: read the documentation, click on the "source" link
22:08:14 <NemesisD> ab9rf: it seems to be bubbling up (Generator a0) as m, before getRequestStreaming was whining about not being able to deduce m ~ Generator a0, now with that signature commented, the highest function, getMetrics is saying it can't deduce Generator a0
22:09:18 <xenon21> ivanm: ahh, I didn't see it, thanks you :)
22:12:02 <NemesisD> ab9rf: its confusing that a using generator at the low level is exerting so much control all the way *up* the stack here
22:12:07 <NemesisD> seems bad
22:43:45 <luite_> is it possible to let cabal-intstall build Setup scripts with a Cabal version different from the one that came with GHC?
22:49:37 <gienah> luite_: since I never use cabal-install I don't really know. I think though that it would work ok with most packages, exceptions are stuff that actually uses the Cabal library like haddock and leksah, which need a --constraint="Cabal == $(cabal-version)"
22:49:57 <gienah> where $(cabal-version) is the different one
22:49:59 <luite_> yeah but this is a different kind of using
22:50:41 <luite_> gienah: but i think that suggestion made me realize what's wrong, tnx :)
22:51:48 <gienah> luite_: no worries (me just states random facts triggering lateral thinking)
22:52:35 <luite_> ok that worked :)
22:54:01 <luite_> gienah: i'm using a bit of a hack, with a fake Cabal package registered in the ghcjs package db
22:54:13 <luite_> but that must match the version of the one i want to use
22:54:36 <luite_> anyway it still doesn't work, but it's a different problem now
22:55:54 <gienah> neat you figured out one hack :)
23:02:20 <luite_> yeah the goal is to make ghcjs cabal integration less hacky, but so far i needed to add more hacks to make the proper solution work than the original 5-line hack...
23:10:35 <luite_> whoah it works
23:10:50 <gienah> :)
23:11:26 <luite_> oh bah more errors
23:11:35 <luite_> grr, i hate build systems :p
23:12:17 * gienah is obviously a masochist
23:16:03 <hpaste> “Lowongan kerja terbaru 2013,bisnis online,online marketing” pasted “Lowongan kerja terbaru 2013,bisnis online,online marketing” at http://hpaste.org/85233
