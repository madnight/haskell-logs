00:00:13 <startling> the other way is to count occurences and then break after that number of occurences
00:00:33 <arkeet> I think that could potentially be less lazy.
00:00:50 <arkeet> well, you could use lazy naturals.
00:01:05 <DarkFox> Examples?
00:01:40 <startling> arkeet: fair enough
00:02:07 <arkeet> DarkFox: e.g. as soon as you see it twice, you know everything up to the first occurrence is before the break.
00:02:26 <arkeet> or something
00:02:43 <DarkFox> code examples? :P
00:02:51 <arkeet> exercise!
00:03:35 <DarkFox> :|
00:05:12 <applicative> > Data.Text.findIndex (=='c') $ Data.Text.reverse "acac"
00:05:15 <lambdabot>   Not in scope: `Data.Text.findIndex'
00:05:15 <lambdabot>  Perhaps you meant `Data.List.findIndex...
00:05:19 <applicative> ;(
00:05:46 <applicative> DarkFox: ^^^ text has better combinators
00:06:16 <DarkFox> :/
00:06:29 <arkeet> Data.List has those too
00:06:31 <DarkFox> Just wanna strip a suffix really
00:07:02 <startling> DarkFox: is this a file extension thing?
00:07:24 <osa1> am I missing something or do we really not have a function that returns system time in milliseconds ?
00:07:45 <DarkFox> startling: index.html
00:07:47 <shachaf> That depends on who "we" is.
00:08:09 <startling> DarkFox: and you want "index"? System.FilePath.dropExtension
00:08:18 <DarkFox> startling: No
00:08:24 <shachaf> @google how do i strip an extension from a file in haskell
00:08:25 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/filepath/System-FilePath-Posix.html
00:08:25 <lambdabot> Title: System.FilePath.Posix
00:08:28 <DarkFox> I want /a/b/c/index.html to /a/b/c
00:08:30 <DarkFox> even
00:08:35 <DarkFox> I want /a/b/c/index.html to /a/b/c/ *
00:08:58 <shachaf> Maybe one of those functions will help.
00:09:03 <startling> DarkFox: takeDirectory, then
00:09:19 <DarkFox> Neat
00:10:42 <DarkFox> Or more splitFileName so I check that the file is index.html
00:10:50 <DarkFox> Or use isSuffixOf
00:11:07 <startling> sure.
00:11:22 <arkeet> be careful with isSuffixOf in case your file is really called windex.html
00:12:30 <DarkFox> Ha not that searching for /index.html wouldn't work ;)
00:12:35 <DarkFox> Just using splitFileName
00:12:59 * DarkFox wonders why url not fixed :/
00:14:43 <osa1> shachaf: how do you do it ? can you share ? I think I just skimmed over all the stdlib and still couldn't find an easy way(ie. just one or two function call)
00:15:01 <DarkFox> Hmm
00:15:08 <shachaf> Get time in microseconds, divide by 1000?
00:15:56 <DarkFox> Yay
00:16:00 <DarkFox> cache </3
00:16:51 <arkeet> osa1: have you looked in the time package?
00:17:30 <applicative> > let lastc c str = foldl' (\(x,n)(y,m) -> if x /= y then (x,n) else (y,m)) (c, -1) (zip str [1..]) in lastc 'c' "acccccccccd"
00:17:32 <lambdabot>   ('c',10)
00:17:56 <applicative> DarkFox: ? ^^
00:18:20 <DarkFox> Heh
00:19:32 <DarkFox> applicative: I think this is better ... removeIndexStr u = case splitFileName u of { (d, "index.html") | isLocal -> d; _ -> u } where isLocal = not $ isInfixOf "://" u
00:20:02 <DarkFox> Strips the index.html if it's there and is not on another website.
00:20:46 <applicative> oh you want to get rid of substrings
00:21:08 <DarkFox> Well.. Suffix if there assuming :// isn't found
00:21:25 <arkeet> > lastOf folded $ "acccccd" ^@.. ifolded . filtered (== 'c')
00:21:27 <lambdabot>   Just (5,'c')
00:21:41 <DarkFox> > isInfixOf "a" "abc" -- false cause not infix?
00:21:42 <lambdabot>   True
00:21:45 <DarkFox> O.o
00:21:58 <DarkFox> infix is between, no?
00:22:05 <niteria> it is between
00:22:10 <niteria> "" and "bc"
00:22:22 <DarkFox> I.e not suffix or prefix
00:22:25 <DarkFox> niteria: Ah
00:22:48 <DarkFox> I wouldn't call that infix really :P
00:23:15 <arkeet> > lastOf (ifolded . filtered (== 'c') . withIndex) "accccd"
00:23:16 <arkeet> much better.
00:23:17 <lambdabot>   Just (4,'c')
00:23:28 <DarkFox> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
00:23:29 <DarkFox> HA
00:23:37 <DarkFox> Smart cookie write that
00:23:39 <applicative> T.replace :: T.Text -> T.Text -> T.Text -> T.Text ; replace "index.htm" "" -- sort of
00:24:06 <arkeet> > lastOf (ifolded . filtered (== 'c') . asIndex) "accccd"
00:24:08 <lambdabot>   Just 4
00:24:09 <DarkFox> applicative: /test/index.html/testing/lol/
00:24:27 <shachaf> > last . filter ((== 'c') . snd) . zip [0..] $ "accccd"
00:24:28 <lambdabot>   (4,'c')
00:24:33 <shachaf> Remember life before lens?
00:24:36 <arkeet> nope
00:24:38 <shachaf> It was so awful, man.
00:24:58 <arkeet> it hadn't even occured to me to try not-lens.
00:25:00 <applicative> DarkFox: yes it needs more work/
00:25:01 * DarkFox hugs edwardk 
00:25:09 <DarkFox> applicative: :P
00:25:27 * DarkFox wonders why he has where x where y XD
00:25:39 <arkeet> shachaf: last is unsafe, anyway.
00:26:03 <DarkFox> Ahh that's why too lazy to pass a variable :P
00:26:35 <niteria> partial functions from prelude make me sad
00:27:17 <niteria> is there PreludeSafe?
00:27:34 <arkeet> I bet there are several.
00:27:36 <applicative> : . (
00:27:39 * DarkFox is tempted to move his {about,contact,archive}.index to {about,contact,archive}/index.html :3
00:27:52 <applicative> there is Safe
00:28:15 <applicative> the error package has some too
00:29:27 <applicative> http://hackage.haskell.org/packages/archive/errors/1.4.1/doc/html/Control-Error-Safe.html niteria
00:30:28 <applicative> http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html
00:30:50 <arkeet> see, several.
00:30:59 <niteria> nice, I like Control.Error.Safe, it has tailZ
00:31:38 <arkeet> I don't like it. it should have Alternative versions.
00:32:32 <niteria> can anyone upload to hackage?
00:32:57 <hpaste> tvrtrt pasted “ghjb gh” at http://hpaste.org/85394
00:33:22 <niteria> are there any rules on what is hackage worthy?
00:40:06 <DarkFox> niteria: Anyone can
00:40:15 <DarkFox> niteria: Common sense for if people may want it there
00:40:19 <DarkFox> :)
00:40:39 <DarkFox> niteria: http://hackage.haskell.org/packages/hackage.html
00:41:12 <DarkFox> niteria: "Any real person with a Cabal package to upload is welcome."
00:41:16 <DarkFox> http://hackage.haskell.org/packages/accounts.html
00:43:53 <DarkFox> applicative: Heh. This would work too ..  removeIndexHtml u | "index.html" `isSuffixOf` u = take (length u - 11) u | otherwise = u
00:44:12 <DarkFox> s/11/10/
00:45:20 <DarkFox> But again would match windex.html
00:51:33 <Elision> I'm writing a Value class of my own, and trying to make it an instance of Num
00:51:53 <Elision> but if I write, for example, -4 :: Value, ghci hangs
00:52:08 <Elision> what is being called to do that conversion?
00:52:52 <Elision> (fromInteger (-4)) :: Value works fine
00:53:53 <shachaf> negate 4
00:54:49 <arkeet> Elision: presumably you defined neither (-) nor negate, which are defined in terms of each other by default.
00:55:09 <Elision> ah, brilliant
00:55:26 <Elision> I can see where that would cause a problem
00:55:27 <shachaf> arkeet: If only someone implemented that extension... :☹(
00:55:34 <Elision> thanks!
00:56:13 <arkeet> shachaf: I wouldn't know how
00:57:25 <shachaf> ?
00:57:43 <shachaf> SPJ is happy to provide guidance.
00:58:00 <arkeet> well, I have more immediate things to be doing.
00:58:10 <donri> what extension?
00:58:36 <arkeet> make the compiler aware of minimal complete definitions, so it can warn when you write an incomplete one.
00:58:49 <arkeet> instance definitions.
00:59:15 <Elision> it seems like it would be simple enough to make negate be defined as (fromIntegral (-1)) * x
00:59:31 <arkeet> Elision: multiplication is often slower than subtraction.
00:59:44 <arkeet> it makes more sense to define it as 0 - x, I think
00:59:58 <donri> ah yeah, please add that :D
01:00:01 <shachaf> Elision: Why do that when there's a specialiszed negate operation?
01:00:02 <donri> why extension though?
01:00:25 <Elision> I suppose
01:00:26 <shachaf> Because how else would you tell the compiler?
01:00:39 <arkeet> it could be a pragma.
01:00:53 <shachaf> True. By extension I actually meant pragma.
01:00:58 <donri> oh are you suggesting syntax extensions to guide the compiler?
01:01:09 <shachaf> But close enough. It's an extension of the compiler code! To do new things!
01:01:14 <shachaf> As opposed to what?
01:02:06 <shachaf> If you can figure out another way to do it I'd be glad to hear.
01:02:42 <donri> yeah, no, i was hoping you had already figured out black magic for analyzing existing code
01:03:03 <shachaf> For solving the halting problem?
01:03:13 <donri> hehe
01:04:16 <donri> i'm obviously missing something, but seems you could find definitions that mention each other and then warn if neither has an override?
01:04:31 <shachaf> Please see the issue that I filed in the GHC Trac.
01:04:45 <shachaf> Recursion is not the devil.
01:04:50 <shachaf> Well, not always.
01:04:51 <donri> okies
01:04:58 <shachaf> I think it was #7633.
01:05:07 <donri> also would be nice if haddock could show those annotations you're suggesting
01:05:32 <shachaf> You can see my proposed pragma there.
01:05:34 <donri> yep that's the one
01:05:43 <arkeet> oh, you already made a ticket for it
01:05:48 <donri> http://hackage.haskell.org/trac/ghc/ticket/7633
01:06:00 <shachaf> Yes, a while ago.
01:06:12 <shachaf> "It's a bit ad hoc, but probably a jolly useful feature. Nothing technically hard about implementing it. If anyone wants to have a go, I'm happy to advise." -- SPJ
01:06:18 <shachaf> I guess it's advice, not guidance.
01:06:55 <donri> an ad-hoc solution for an ad-hoc overloading mechanism!
01:09:17 * hackagebot concraft 0.5.0 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.5.0 (JakubWaszczuk)
01:13:15 <timbod> I've got a hostname as a String. http-conduit requires a hostname as a Data.ByteString. How should I convert?
01:13:32 <Taneb> Data.ByteString.Char8.pack
01:13:42 <shachaf> Taneb: :-(
01:13:57 <Taneb> shachaf, is there a better way?
01:14:15 <shachaf> It might be that that's the function you'll use in this case, but you should carefully make that decision.
01:14:17 * hackagebot concraft-pl 0.1.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.1.0 (JakubWaszczuk)
01:14:17 <timbod> Taneb: won't that give me a Data.ByteString.Char8? I need a Data.ByteString.
01:14:17 <donri> convert it to Text and encode it to a bytestring!
01:14:24 <shachaf> A String and a ByteString don't represent the same thing.
01:14:26 <Taneb> timbod, it's the same type
01:14:42 <timbod> Is it really?
01:14:47 <Taneb> Yeah
01:14:53 <Taneb> But listen to what shachaf is saying
01:15:58 <Taneb> Data.ByteString.Char8.pack will, I think, take each character modulo 256, so if you have any Unicode, it's gonna be messed up
01:16:11 <timbod> I see:
01:16:13 <timbod> Prelude> :t Data.ByteString.empty
01:16:15 <timbod> Data.ByteString.empty :: Data.ByteString.Internal.ByteString
01:16:17 <timbod> Prelude> :t Data.ByteString.Char8.empty
01:16:19 <timbod> Data.ByteString.Char8.empty :: Data.ByteString.Internal.ByteString
01:16:21 <timbod> Prelude> Data.ByteString.empty == Data.ByteString.Char8.empty
01:16:23 <timbod> Loading package bytestring-0.9.2.1 ... linking ... done.
01:16:25 <timbod> True
01:16:27 <timbod> Prelude>
01:16:29 <timbod> I always thought they were distinct.
01:16:35 <donri> on the other hand, i suspect you can't have unicode in a hostname.
01:16:35 <timbod> Are they just type synonyms??
01:16:43 <Taneb> Not even that
01:16:44 <donri> there's some encoding for unicode in domain names though
01:16:49 <Taneb> They are literally the same type
01:17:06 <donri> so maybe the right solution is to find an implementation of that encoding
01:17:11 <arkeet> donri: that depends on whether you are dealing with IDNs that aren't encoded.
01:17:27 <mauke> timbod: Data.ByteString and Data.ByteString.Char8 both re-export the same ByteString type from Data.ByteString.Internal
01:18:04 <timbod> Has this always been the case? I'm sure I had to deal with them being different in the past...
01:18:14 <arkeet> you might be thinking of strict vs lazy bytestrings.
01:18:43 <timbod> arkeet: Possibly. I know how they differ.
01:18:58 <donri> relephant? http://hackage.haskell.org/packages/archive/punycode/2.0/doc/html/Data-Text-Punycode.html
01:19:09 <timbod> Oh well. That makes solving my problem easy.
01:19:24 <Taneb> But the .Char8 modules just swap Word8 for Char, which can sometimes have weird consequences
01:19:53 <timbod> In the case of a hostname, I expect there won't be any non-ascii characters.
01:19:55 <shachaf> timbod: Or maybe it makes solving a problem which looks like your problem but is actually racist easy. :-)
01:20:29 <timbod> racist meaning "ascii only"?
01:20:40 <shachaf> Yep.
01:20:55 <shachaf> "assumes the entire world speaks English"
01:21:06 <timbod> I didn't write the data-conduit API!
01:21:18 <shachaf> ?
01:21:19 <donri> timbod: conduit isn't the problem
01:21:43 <shachaf> There are ways to encode a String into a ByteString that are OK.
01:21:53 <shachaf> UTF8 and Punycode are two that might be relevant here.
01:22:01 <timbod> Sure. I know that.
01:22:15 <timbod> But this function from http-conduit:
01:22:17 <timbod> host :: Request m -> ByteString
01:22:27 <timbod> says that a hostname is ascii, I think.
01:22:33 <shachaf> ?
01:22:39 <shachaf> A ByteString contains bytes.
01:22:55 <shachaf> What those bytes mean -- an ASCII encoding or a UTF8 encoding or a UTF8 encoding -- is something else.
01:22:56 <timbod> Well, given it doesn't specify an encoding.
01:23:12 <shachaf> Well, I bet there is still one that's relevant.
01:23:23 <shachaf> Unfortunately it might be a bit of work to figure it out.
01:23:30 <timbod> If it were host :: Request m -> Text, then there wouldn't be any doubt.
01:23:47 <shachaf> Or maybe the encoding isn't up to it. I don't know.
01:24:20 <timbod> Showing my own acute lack of i8n knowledge - are there hostnames that aren't purely ascii?
01:24:25 <donri> timbod: the encoding isn't always known by the library, in which case it's better to give the user a bytestring and let them decide
01:24:42 <donri> but i don't know the standards for hostnames
01:24:58 <timbod> I guess it comes down to what libc considers the encoding is (for hostnames).
01:24:59 <donri> timbod: there's IDNs as arkeet notes, not sure how those relate here
01:25:10 <shachaf> http://דוגמה.טעסט/
01:25:30 <shachaf> timbod: It's possible that this isn't libc's job.
01:25:31 <timbod> OK. Point made!
01:25:47 <timbod> I'm impressed that firefox just followed that link.
01:26:03 <shachaf> But it changed the displayed URL to xn-..., right?
01:26:24 <donri> http://☃.net/
01:26:29 <Ralith> "This page masculine styled for convenience sake but is obviously intended for women"
01:26:30 <Nimatek> "This page masculine styled for convenience sake but is obviously intended for women"
01:26:32 <Ralith> that is a weird page, shachaf.
01:26:34 <Nimatek> Lol ↑
01:26:34 <donri> shachaf: modern browsers don't
01:26:47 <Ralith> donri: chrome isn't modern?
01:26:48 <mauke> donri: depends
01:26:54 <donri> Ralith: nope
01:27:03 <Ralith> well I've sure been misled.
01:27:15 <shachaf> donri: There are several reasons Chrome uses xn- there, such as to avoid phishing.
01:27:34 <shachaf> timbod: Note: These are very uncommon in practice. It's possible that for the program you're writing, you don't really care, and you can just go with .Char8.
01:27:34 <Ralith> that seems prudent
01:27:35 <mauke> timbod: if this is HTTP, then host names will be encoded using punycode
01:27:39 <donri> Ralith: probably by google's sneaky advertising suggesting you should "upgrade" from the latest firefox to chrome
01:27:49 <Ralith> donri: I don't run chrome.
01:27:52 <shachaf> timbod: However this path of least resistance leads to a less Unicode-compliant world.
01:27:59 <donri> :)
01:28:13 <donri> shachaf: good point
01:29:26 <donri> not that uncommon. i know plenty of swedish sites with åäö in the domain names
01:29:33 <mauke> dohoho
01:30:02 <shachaf> donri: Well, I mean, they don't even speak English. Who cares about them?
01:30:05 <mauke> my antivirus blocks http://böse.de for security reasons ("category: malware")
01:30:54 <donri> i have anti-phishing disabled so it worked for me but got blocked by a redirect filter instead ^_^
01:35:27 <timbod> When you said "punycode" I thought this was a joke...
01:35:59 <Zouppen> donri: yes, in Finland, too. Although most of the sites register the non-diaeresis form, too.
01:36:03 <shachaf> I'm sure the name was a joke.
01:36:10 <donri> true
01:39:04 <arkeet> huh, I didn't know they had IDNs for TLDs.
01:42:12 <startling> isn't there a thing in lens that turns a traversal into an fmap-type function?
01:42:30 <shachaf> over?
01:42:52 <startling> oh. right.
01:43:15 <donri> aka %~
01:43:46 <Taneb> :t Data.Traversable.fmapDefault
01:43:47 <lambdabot> Traversable t => (a -> b) -> t a -> t b
01:45:12 <arkeet> :t over traverse
01:45:14 <lambdabot> Traversable t => (a -> b) -> t a -> t b
01:46:30 <donri> :t over itraverse
01:46:32 <lambdabot>     Couldn't match expected type `Mutator b0'
01:46:32 <lambdabot>                 with actual type `a0 -> f0 b1'
01:46:32 <lambdabot>     Expected type: Setting (->) s0 t1 a1 b0
01:46:34 <donri> :(
01:46:40 <arkeet> :t over itraversed
01:46:41 <lambdabot> (Indexable i p, TraversableWithIndex i t) => p a b -> t a -> t b
01:46:48 <donri> oic
01:46:59 <arkeet> :t iover itraversed
01:47:00 <lambdabot> TraversableWithIndex i t => (i -> a -> b) -> t a -> t b
01:47:32 <arkeet> :t itraverse
01:47:33 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
01:48:48 <Taneb> > imap (*) [0..10]
01:48:50 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100]
01:49:13 <arkeet> heh
01:49:35 <shachaf> @ty Control.Lens.Internal.ifmap
01:49:36 <lambdabot> Control.Lens.Internal.Context.IndexedFunctor w => (s -> t) -> w a b s -> w a b t
01:49:38 <shachaf> @ty imap
01:49:40 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
01:49:47 <FireFly> @ty inoremap
01:49:48 <lambdabot> Not in scope: `inoremap'
01:50:03 <donri> > ["1","2","3"].map(parseInt)
01:50:05 <lambdabot>   Not in scope: `parseInt'
01:50:22 <Taneb> > ["1","2","3"] & map read :: [Int]
01:50:25 <lambdabot>   [1,2,3]
01:50:34 <donri> Taneb: javascript joke
01:50:42 <Taneb> bah
01:50:48 * FireFly notes that ["1","2","3"].map(Number) would've worked better
01:51:19 <arkeet> > ["1","2","3"]^..folded.to read :: [Int]
01:51:21 <lambdabot>   [1,2,3]
01:52:01 <donri> ['10','10','10','10','10'].map(parseInt) => [10, NaN, 2, 3, 4]
01:53:02 <arkeet> what??
01:53:24 <FireFly> (spoilers: it's because `map` passes the index as the second parameter to the callback, and `parseInt` expects the radix as an optional second parameter)
01:53:25 <Taneb> > ["1","2","3"]^..folded.base 10
01:53:27 <lambdabot>   [1,2,3]
01:53:48 <FireFly> s/callback/function being mapped/
01:54:02 <arkeet> ahh.
01:54:14 <Taneb> > ["1","2","3"]^..folded.base 4
01:54:16 <lambdabot>   [1,2,3]
01:54:29 <Taneb> > ["1","2","3"]^..folded.decimal
01:54:31 <lambdabot>   Not in scope: `decimal'
01:55:04 <arkeet> > "a" ^? base 10
01:55:05 <lambdabot>   Nothing
01:55:11 <arkeet> good
01:56:20 <quchen> What's the rationale behind the naming of "^.."? "^." is "get", the double dot kind of stands for "apply toList" here.
01:56:35 <shachaf> It means you get a list.
01:56:45 <shachaf> It's not so much "apply toList" because there's no Foldable involved.
01:56:49 <shachaf> But it *is* toListOf.
01:56:49 <quchen> Ah, as opposed only a single focused value
01:56:57 <shachaf> Yes.
01:57:30 <shachaf> ^. means view. ^.. is the point where the types get so complicated that you start to see double.
01:58:16 <quchen> But it's different to simply getting what's one level higher? That is, viewing a list is different from ^..-ing its elements?
01:58:34 <quchen> (Not sure if that question is even right) :-\
01:58:53 <Taneb> @quickcheck \xs -> (xs ::[Int]) == (xs ^.. folded)
01:58:53 <lambdabot> Unknown command, try @list
01:58:54 <shachaf> I don't think the question is right or wrong.
01:59:02 <shachaf> There is no list involved.
01:59:09 <shachaf> > (1,2) ^.. view both
01:59:11 <lambdabot>   Couldn't match type `Data.Monoid.Endo' with `(,) t1'Couldn't match type `Co...
01:59:12 <shachaf> Er.
01:59:14 <shachaf> > (1,2) ^.. both
01:59:15 <lambdabot>   [1,2]
01:59:42 <arkeet> ^.. collects all the results and puts them in a list.
02:00:08 <quchen> shachaf: Well, lists are a nice simple structure that has all the basic typeclasses, so I tend to use it in examples.
02:00:20 <shachaf> OK, but ^.. is about monoids, not lists.
02:00:27 <quchen> arkeet: Ah.
02:00:39 <shachaf> Lists happen to be a good way to look at a monoid, though. :-)
02:00:56 <shachaf> Before you ^.. the traversal is actually in a binary tree, but you're not allowed to know the shape of the tree.
02:01:18 <startling> shachaf: that's interesting.
02:02:41 <quchen> Is ".." generally a sign for "creates a list" in Lens?
02:02:55 <quchen> There are those more complicated looking operators like ^@.. etc.
02:03:22 <Taneb> quchen, it's just those two
02:03:43 <shachaf> .. means you get a list, yes.
02:03:57 <shachaf> All of these operators also have names, by the way.
02:03:58 <quchen> Taneb: Woops, just saw that in the docs. That solves one of my mysteries, I thought there were another ten or so :-)
02:04:04 <shachaf> You can look in the documentation to learn about it. :-)
02:05:21 <Taneb> quchen, there's also (^!!), which is similar but monady
02:05:21 <donri> > over both show (1,'x')
02:05:23 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
02:05:23 <lambdabot>    arising from the literal `1...
02:05:24 <quchen> shachaf: Finding a starting point is usually the hardest thing looking at the docs of Lens. It's quickly overwhelming.
02:05:38 <shachaf> Well, you had one here: (^..) and (^@..)
02:05:47 <shachaf> There's a special documentation file, .Operators, that lists only operators.
02:05:54 <quchen> Oh!
02:06:05 <shachaf> You can search for .. on that page.
02:06:11 <quchen> Well that's useful. Thanks!
02:06:28 <quchen> Taneb: Thanks for the heads up, I'll put that on my todo list somewhere :-)
02:06:50 <Taneb> (Actions and MonadicFolds aren't used very often at all)
02:06:59 <arkeet> we don't really know what actions are.
02:07:01 <shachaf> The main reason is that they're terrible.
02:07:08 <arkeet> or what they're supposed to be.
02:07:14 <shachaf> They're supposed to be terrible.
02:07:16 <shachaf> That's their goal in life.
02:07:19 <arkeet> fine.
02:07:19 <shachaf> They make bad puns.
02:07:30 <arkeet> like what?
02:07:52 <shachaf> Like me.
02:07:52 <arkeet> :t (^!?)
02:07:53 <lambdabot> Monad m => s -> Acting m (Leftmost a) s t a b -> m (Maybe a)
02:07:54 <arkeet> :t (^?!)
02:07:56 <lambdabot> s -> Getting (Endo a) s t a b -> a
02:08:33 <Taneb> :t act putStrLn . _Nothing . folded
02:08:35 <lambdabot>     Not in scope: `_Nothing'
02:08:35 <lambdabot>     Perhaps you meant `isNothing' (imported from Data.Maybe)
02:08:43 <Taneb> COMPLETELY USELESS
02:22:08 <webpyre> if a socket is just listening and not calling accept, how can another socket connect?
02:22:42 <shachaf> isLarge :: Integer -> Bool; isLarge = unsafeCoerce
02:23:32 <quchen> shachaf: It's so flexible.
02:24:55 <quchen> The same thing should work for lists and null as well
02:24:57 <donri> (unsafeCoerce :: Integer -> Bool) (fromIntegral (maxBound :: Int) + 1)
02:25:06 <shachaf> @tell ddarius isLarge :: Integer -> Bool; isLarge = unsafeCoerce
02:25:06 <lambdabot> Consider it noted.
02:27:43 <supki> I like how  2 ^ 63 - 2 ^ 62  is large, but  2 ^ 62  is not. Totally different numbers
02:30:27 <quchen> isLarge = (unsafeCoerce $!)  --  How about this one?
02:31:35 <Taneb> Little things that annoy me: Storable Vectors aren't Storable
02:32:01 <quchen> Taneb: You have to pack them yourself?
02:32:05 <shachaf> quchen: How about it?
02:32:19 <quchen> shachaf: What are you referring to?
02:32:25 <shachaf> 02:30 <quchen> isLarge = (unsafeCoerce $!)  --  How about this one?
02:32:57 <quchen> Oh. Well, supki stated that the difference is large, but the number in its evaluated form isn't.
02:33:18 <quchen> I thought usafeCoerce would coerce the "-" function application in that case, not the number it evaluates to.
02:33:33 <quchen> So I was wondering whether a strict unsafeCoerce would solve that.
02:33:39 <shachaf> unsafeCoerce is strict.
02:33:45 <shachaf> It's id.
02:34:06 <quchen> Oh. How does supki's statement come about then?
02:34:56 <shachaf> Because of GMP details.
02:35:16 <shachaf> The question is whether the Integer is stored as a machine Int# or as a GMP Int# + ByteArray
02:35:43 <quchen> Ah, and unsafeCoerce exposes that difference although it's not observable otherwise
02:35:56 <shachaf> Yes.
02:36:28 <quchen> So there's some form of hysteresis there - the same number can be Int# and GMP, depending on how it's obtained?
02:36:42 <luite> yes
02:36:53 <shachaf> No, the number is just a number.
02:37:02 <shachaf> It can be encoded into Integer in at least two different ways, though. :-)
02:37:29 <quchen> ... that's a little detailed. I'll read it as "yes".
02:37:49 <luite> integer-gmp switches to the J# when S# overflows, but doesn't switch back to S# even if the result would fit there
02:38:05 <quchen> I kind of thought that an Int-sized Integer number is always represented by an Int#.
02:38:27 <quchen> luite: Is that to save "is the number small now" checks?
02:38:49 <shachaf> Probably it's not worth the trouble.
02:38:59 <shachaf> If the number was large before, it'll probably be large again.
02:39:02 <shachaf> Or not. Who knows.
02:39:26 <quchen> I'm beginning to appreciate the black box Integer is.
02:40:08 <luite> quchen: I think it might be able to use the GMP limbcount information for that
02:40:10 <shachaf> Anyway I was just being pedantic and/or profound. Probably the former.
02:40:15 <luite> but yeah checking every operation has some overhead
02:41:12 <shachaf> The Integer value means (conal-style) an integer, as in an element of the set ℤ and all that.
02:41:25 <shachaf> There are a whole bunch of ways to encode that value.
02:41:30 <shachaf> That's all.
02:42:01 <quchen> Something else I wanted to ask for some time now: GMP is simply linked in GHC as a library. How is this different from an FFI call? Integer doesn't seem to have the concurrency problems the FFI does. Is there some qualitative difference between the types of linking?
02:42:19 <shachaf> The FFI doesn't have concurrency problems.
02:42:24 <ion> I wonder if there’s a not-too-nasty way to convert an Integer that contains a GMP value that would fit in an Int to a non-GMP Integer? I don’t need it, but i’m curious.
02:42:39 <quchen> shachaf: I expected you'd say that ;-)
02:43:00 <shachaf> So you know the answer?
02:43:06 <quchen> No.
02:43:16 <quchen> shachaf: an FFI call basically exits Haskell and lets the external lib do its thing as I understand it.
02:43:39 <ion> I suppose going through an Int might be one of the less nasty methods.
02:43:59 <bitonic> quchen: that’s true for ‘unsafe’ calls only
02:43:59 <shachaf> ion: I don't know of a way.
02:44:10 <bitonic> quchen: normal FFI calls can be interrupted by the RTS
02:44:36 <shachaf> I'm sure GMP calls are more similar to unsafe calls than to safe calls.
02:44:39 <shachaf> Though they're neither.
02:44:41 <quchen> bitonic: So if my C is pure, there's no difference to how GHC can handle it compared to the libs contained in GHC itself?
02:45:10 <shachaf> What "libs contained in GHC itself"?
02:45:10 <bitonic> shachaf: OK, just wanted to point that out :P
02:45:28 * bitonic is not sure what quchen means either
02:46:20 <shachaf> Ah, you're asking whether a GMP call can be interrupted?
02:46:42 <quchen> No. I'm trying to find out how to ask this ithe right way. Let me think ;-)
02:47:01 <ion> kluge n = if n' == n then n' else n where n' = toInteger (fromInteger n :: Int)
02:48:30 <shachaf> I wonder whether the report allows e.g. ⊥ for overflow in fromInteger :: Integer -> Int
02:51:08 <quchen> So here it comes in a reformulated way: The problem with FFI calls that makes concurrency odd is when C does mutable things, so when doing concurrent calls to the mentioned method weird things can happen. The way I understand it, using GMP is similar to an FFI call in the sense that Haskell hands control to a C library. Why does using Integer this way not suffer from mentioned concurrency problems? Is it simply that the GMP code is structur
02:51:42 <Kinnison> Whatever you said ended at '...GMP code is structur'
02:51:45 <ion> quchen: /script load splitlong and then say that again.
02:51:59 <shachaf> Maybe the answer you're looking for is "GMP is reëntrant and thread-safe, with some exceptions"
02:52:09 <quchen> So here it comes in a reformulated way: The problem with FFI calls that makes concurrency odd is when C does mutable things, so when doing concurrent calls to the mentioned method weird things can happen. The way I understand it, using GMP is similar to an FFI call in the sense that Haskell hands control to a C library. Why does using Integer this way not suffer from mentioned concurrency problems? Is it simply that the GMP code is ...
02:52:09 <ion> quchen: mkdir -pv ~/.irssi/scripts && ln -s . ~/.irssi/scripts/autorun && ln -s /usr/share/irssi/scripts/splitlong.pl ~/.irssi/scripts/
02:52:15 <quchen> ... structured nicely so calls to it are pure, hence no concurrency issues?
02:52:43 <Kinnison> GMP is pretty pure anyway IIRC
02:52:54 <Kinnison> It has been a while
02:53:11 <quchen> ion: Thanks, didn't know about that script.
02:54:33 <shachaf> However, maybe being interruptible is a concern. But you said you didn't care about that.
02:54:39 <shachaf> Anyway, I'm going to sleep.
02:55:30 <quchen> shachaf: I don't know what that means, so when you read me as not caring, that's where it came from.
02:55:46 <quchen> Anyway, have a good night, and thanks for the explanations
02:58:21 <shachaf> quchen: It means: If an operation takes a long time, will it stop other threads from running until it's done?
02:58:50 <shachaf> Since this isn't GHC-generated code, it's hard to put in the explicit checks for "am i taking too long".
02:59:13 <shachaf> I don't know whether GMP calls are interruptible. My guess would be that they're not but that no one cares that much most of the time.
02:59:38 <shachaf> If you're doing arithmetic on really huge Integers then maybe you do care.
03:01:28 <shachaf> And now I will go to sleep.
03:03:23 <beaky> hello
03:04:18 <beaky> is there a name for a function that takes a normal function and returns a version of that function that works on some functor?
03:04:46 <eikke> beaky: fmap?
03:04:52 <typoclass> @type fmap
03:04:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:04:58 <beaky> ah yes
03:05:00 <eikke> :i Functor
03:05:01 <beaky> that one thanks
03:05:13 <beaky> how do I write my own functor?
03:05:28 <eikke> beaky: define an instance of the Functor class
03:05:38 <eikke> which boils down to (guess what) implementing 'fmap'
03:05:56 <eikke> but in lots of cases GHC can derive a Functor instance automatically
03:05:57 <beaky> instance Functor BeakyFunctor where fmap f _ = ? -- are there any functor laws?
03:06:02 <beaky> ah
03:06:15 <eikke> using the DeriveFunctor extension
03:06:46 <Taneb> beaky, fmap id = id; fmap f . fmap g = fmap (f . g)
03:06:52 <eikke> beaky: laws @ http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Functor.html#v:fmap
03:07:59 <romm> hello. how does foldr know to stop folding on the first key found in code like this: let findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing
03:08:51 <romm> i'm guessing it's something do to with the Maybe construct, but I don't understand the mechanism.
03:09:24 <marekw2143> hello , how is IO monad implemented? I mean how lazy "getContents >>= putStrLn " "calls" getContents and putStrLn at intervals?
03:11:56 <typoclass> romm: that doesn't stop, if i'm reading this correctly
03:12:28 <startling> is there a thing somewhere so that I can do "change someTraversal (\f -> x)" where I would normally have to do "someTraversal (\f -> x *> f)" ?
03:13:02 <romm> typoclass, hmm... i ran it on "let d = [(k,k ++ " val") | k <- map show [1..]]", and it stopped.
03:14:34 <int-e> marekw2143: I'm tempted to say "it's magic". There's a function  System.IO.Unsafe.unsafeInterleaveIO  that can delay an IO action until its result is needed; it is used for implementing lazy IO.
03:15:35 <typoclass> > foldr f x [a,b,c] -- romm, here's an example
03:15:38 <lambdabot>   f a (f b (f c x))
03:16:53 <romm> typoclass, i'm sorry, and example for what?
03:17:36 <donri> romm: it has to do with not recursing on acc, no?
03:18:22 <romm> donri, i don't know, that's basically what i'm asking :)
03:19:34 <typoclass> romm: f is applied to the last element of the list and the initial value (f c x). the result from that is fed to another application of f, and so on. there's 3 applications of f, because the list has 3 elements. i don't think it could somehow abort part-way in
03:20:11 <typoclass> romm: in other words, when you say 'stops folding on the first key found', it's really starting at the end of the list and gives you the last key found :-)
03:20:28 <typoclass> romm: does that make sense?
03:20:35 * typoclass needs moar coffees
03:20:40 <romm> donri, yeah, it seems you're right. removing the Maybe construct doesn't affect it, so it seems that not depending on the acc makes it work that way...
03:20:48 <sopvop> Why the hell monoid instance of HashMap keeps original value on collision?!
03:20:59 <romm> typoclass: no :) because i tested it and it doesn't work that way :)
03:21:00 * sopvop is furious
03:21:26 <romm> typoclass: take a dict with two keys and 2 different values, and findKey will find the first one.
03:21:32 <startling> sopvop: ugh
03:22:18 <paolino> > head $ foldr (:) [] [1..]
03:22:19 <lambdabot>   1
03:23:08 <donri> >  let findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing in findKey 'b' [('a',a),('b',b),('c',c)]
03:23:10 <lambdabot>   Just b
03:23:29 <donri> ^_^
03:23:58 <typoclass> romm: yes, i meant the other way round. in "f a (f b (f c x))", you can see that the innermost expression is "f c x". c is the last element of the list
03:24:45 <paolino> >  let findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing in findKey 2 $ zip [1..] ['a'..]
03:24:46 <romm> typoclass: but my list is infinite
03:24:47 <lambdabot>   Just 'b'
03:25:33 <donri> :t fix
03:25:34 <lambdabot> (a -> a) -> a
03:25:38 <danr> > (length ['a'..],length [1..])
03:25:42 <lambdabot>   mueval-core: Time limit exceeded
03:26:17 <danr> > length ['a'..]
03:26:19 <lambdabot>   1114015
03:26:35 <paolino> oh
03:26:43 <paolino> >  let findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing in findKey 2 $ zip [1..] [1..]
03:26:48 <lambdabot>   Just 2
03:26:48 <typoclass> > let findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing in findKey 7 $ cycle [(9, 1234), (7, 456), (7, 789)] -- infinite list
03:26:50 <lambdabot>   Just 456
03:27:05 <romm> ha! :)
03:27:48 <startling> > repeat 12 !! maxBound
03:27:53 <lambdabot>   mueval: ExitFailure 1
03:27:53 <lambdabot>  mueval: Prelude.undefined
03:27:58 <startling> > repeat 12 !! maxBound -- ping gwern
03:28:04 <lambdabot>   mueval: ExitFailure 1
03:28:04 <lambdabot>  mueval: Prelude.undefined
03:28:17 <romm> so after donri's suggestion, the followup question is how does this mechanism work? foldr knows to behave this way when the acc doesn't change? how?
03:28:30 <donri> laziness
03:28:39 <paolino> it evaluates until the key is found, the foldr build the expression
03:29:37 <donri> in f x y, f x is evaluated before y
03:29:41 <romm> but if my acc actually accumulated the values, it wouldn't stop, would it not?
03:30:08 <paolino> you stop needing acc at one point
03:30:16 <donri> acc is the lambda applied to the next pair
03:32:37 <donri> > let f (k,v) acc = if k == 2 then Just v else acc in f (1,a) (f (2,b) (f (3, b) Nothing)
03:32:39 <lambdabot>   <hint>:1:88: parse error (possibly incorrect indentation)
03:32:45 <romm> i.... don't get it.
03:32:54 <donri> > let f (k,v) acc = if k == 2 then Just v else acc in f (1,a) (f (2,b) (f (3, b) Nothing))
03:32:56 <lambdabot>   Just b
03:33:04 <romm> let findKey key = foldr (\(k,v) acc -> if k == key then acc+v else acc) 0 in findKey 1 $ cycle [(1,11),(2,22)]
03:33:32 <romm> let findKey key = foldr (\(k,v) acc -> if k == key then v else acc) 0 in findKey 1 $ cycle [(1,11),(2,22)]
03:33:52 <romm> ...did i just kill lambdabot?
03:34:00 <paolino> you miss a '>'
03:34:04 <typoclass> romm: nope, she only listens to lines with "> "
03:34:19 <romm> oooh.
03:34:24 <romm> > let findKey key = foldr (\(k,v) acc -> if k == key then acc+v else acc) 0 in findKey 1 $ cycle [(1,11),(2,22)]
03:34:26 <lambdabot>   *Exception: stack overflow
03:34:35 <donri> f (2,b) (f (3, b) Nothing) -- when we get here, we return "Just b" and ignore the second argument, which isn't evaluated at all due to laziness
03:34:50 <romm> okay. so here acc actually accumulates and indeed foldr doesn't stop.
03:35:12 <typoclass> romm: in "f a (f b (f c x))", f is given the arguments a and (f b (f c x)). the latter is named acc inside the lambda. now, due to laziness, acc is only evaluated when needed. in other words, it's only evaluated when we hit the 'else' branch. does this make sense?
03:35:36 <romm> oooh
03:35:39 <donri> f (2,b) is evaluated before (f (3, b) Nothing)
03:35:42 <romm> thank you!
03:35:47 <romm> finally got it.
03:36:20 <typoclass> romm: yeah, as donri is saying, if you apply your code on an infinite list, you could never get Nothing out
03:36:37 <romm> so foldl wouldn't stop in my example.
03:37:02 <typoclass> romm: ok great :-) sorry for the initial explanation, i realize now it must have been confusing
03:37:10 <typoclass> > foldl f x [a,b,c]
03:37:12 <lambdabot>   f (f (f x a) b) c
03:37:21 <donri> you obviously can't find a missing item in an infinite sequence, no :)
03:37:48 <donri> bbl
04:11:01 <ocharles> well, it's "obvious" that you can get a proof that -1 is not in the infinite set of positive integers...
04:19:45 <webpyre> sockets: if a socket is listening and a client tries to connect, will it succeed to connect even if the server socket does not call accept? how can this be?
04:19:54 <int-e> > Seq.length $ (iterate
04:19:56 <lambdabot>   <hint>:1:22: parse error (possibly incorrect indentation)
04:20:46 <int-e> > Seq.length $ (iterate (\s -> () Seq.<| s Seq.>< s) (Seq.empty)) !! 64
04:20:48 <lambdabot>   -1
04:22:14 <int-e> Is there an implementation of finger trees on hackage that allows measurements over an arbitrary monoid?
04:23:05 <int-e> Oh, too easy. "fingertree" is what I'm looking for.
04:29:47 <Taneb> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
04:29:48 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
04:32:39 <byorgey> odd that @djinn uses b first and then a
04:33:15 <luite> a is the first argument though
04:33:30 <quchen> Is that <*> for Cont?
04:34:03 <Taneb> quchen, yeah
04:34:28 <Taneb> You know, if r is a Monoid, Cont r is Alternative (but ContT r m isn't)
04:34:51 <alexander__b> my brain is still a bit C, so how would I most easily divide N elements by 0.5? that is, I have a start number (let's say 0.25), and I want to divide it by 0.5 five times.
04:35:04 <quchen> alexander__b: iterate
04:35:06 <alexander__b> I assume I would use an "endless list" to take advantage of lazyness.
04:35:08 <ocharles> :T iterate
04:35:10 <ocharles> :t iterate
04:35:12 <lambdabot> (a -> a) -> a -> [a]
04:35:16 <Taneb> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
04:35:16 <lambdabot> f a b c = a (\ d -> b d c)
04:35:19 * ocharles shakes a fist at case sensitivity
04:35:28 <quchen> > iterate (/ 0.5) 0.25 !! (5+1)
04:35:29 <lambdabot>   16.0
04:35:48 <int-e> quchen: the +1 is too much
04:35:48 <Cale> > 0.25 * (1/0.5)^5
04:35:49 <lambdabot>   8.0
04:36:07 <quchen> int-e: Iterate starts with no function application, that's why I added the 1
04:36:20 <hiptobecubic> but index starts with 0
04:36:21 <int-e> quchen: but xs !! 0 is the first element of the list.
04:36:23 <Cale> > 0.25/0.5^5
04:36:24 <lambdabot>   8.0
04:36:24 <quchen> Right.
04:36:29 <quchen> Good point.
04:36:52 <supki> > lastOf (taking 4 (iterated (/ 0.25))) 0.25
04:36:54 <lambdabot>   Just 16.0
04:36:57 <alexander__b> I just found out how I would do it with my current level of knowledge
04:37:05 <quchen> Anyway, alexander__b: look at iterate.
04:37:11 <quchen> > take 5 $ iterate f x
04:37:12 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x)))]
04:37:40 <alexander__b> I would do e.g. "take 10 $ map (/2) 60"
04:37:54 <quchen> That's a type error.
04:37:59 <alexander__b> [60]
04:38:09 <alexander__b> take 10 $ map (/2) [60..]
04:38:10 <quchen> That's well-typed, but divides 60 by 2 once.
04:38:12 <alexander__b> > take 10 $ map (/2) [60..]
04:38:14 <lambdabot>   [30.0,30.5,31.0,31.5,32.0,32.5,33.0,33.5,34.0,34.5]
04:38:30 <alexander__b> I'll look into iterate though. thanks.
04:38:39 <quchen> map (/2) [60..] = [60/2, 61/2, 62/2 ...]
04:38:49 <alexander__b> oh right of course
04:38:52 <merijn> alexander__b: Iterate repeatedly applies the same function to the result of the previous application
04:38:59 <alexander__b> I was thinking of using fold
04:39:07 <alexander__b> but I guess iterate is easier?
04:39:21 <merijn> Yes ;)
04:39:24 <quchen> fold would also not work I think.
04:39:24 <hiptobecubic> @src iterate
04:39:24 <lambdabot> iterate f x =  x : iterate f (f x)
04:39:26 <merijn> > iterate (+1) 0
04:39:27 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:39:28 <alexander__b> take 5 $ iterate (/2) 60
04:39:29 <int-e> > let xs = 60 : map (/2) xs in take 10 xs -- same as  take 10 (iterate (/2) 60)
04:39:30 <lambdabot>   [60.0,30.0,15.0,7.5,3.75,1.875,0.9375,0.46875,0.234375,0.1171875]
04:39:33 <alexander__b> was what I did. so it works nice.
04:39:35 <alexander__b> thanks.
04:39:41 <quchen> iterate is more like an unfold.
04:39:52 <merijn> quchen: Well, you could write it as a recursion, so by definition you can write it as a fold
04:40:19 <merijn> Since any recursion can be rewritten as fold + a trivial function
04:40:27 <alexander__b> how do I get ghci to not use scientific notation?
04:40:32 <alexander__b> > take 5 $ iterate (/2) 0.5
04:40:34 <lambdabot>   [0.5,0.25,0.125,6.25e-2,3.125e-2]
04:40:36 <quchen> merijn: But it's not very straight forward, is it? My fold implementation would've been folding over "replicate (/2)" or something.
04:40:45 <alexander__b> like that. I would like decimals with n-precision.
04:41:01 <merijn> quchen: Oh, sure, it might not be necessarily simple. BUt you certainly can ;)
04:41:32 <quchen> merijn: So what I wrote above would be the implementation? Or am I overlooking something obvious and simple
04:41:42 <merijn> quchen: See also "A Tutorial on the Universality and Expressiveness of Fold"
04:41:55 <quchen> merijn: Also, can all recursion be reformulated as a f.....oh you were faster
04:41:56 <quchen> :-)
04:41:57 <hiptobecubic> alexander__b, there's a printf function, but i don't know if you can change the default output directly
04:42:17 <merijn> It's a fairly readable paper by Graham Hutton on that topic
04:42:35 <quchen> The default float output is the Show instance, which you can't change.
04:42:43 <quchen> Printf is probably the way to go.
04:43:16 <quchen> merijn: Neat, it's even in Haskell! Expected something Schemey for some reason
04:43:43 <byorgey> a paper by Graham Hutton is unlikely to be in anything other than Haskell =)
04:44:05 <quchen> byorgey: Oh right, I mixed up the name, thought of Paul Graham for some reason. Hutton's the book author, right?
04:45:02 <int-e> > foldr (\x c acc -> acc : c (acc / x)) (\_ -> []) (replicate 5 0.5) 0.25
04:45:04 <lambdabot>   [0.25,0.5,1.0,2.0,4.0]
04:45:16 <Cale> Yeah, and his writing is far more to the point ;)
04:51:48 <quchen> Cale: Graham likes to procrastinate in his articles, yes. :-)
04:52:27 <quchen> int-e: Are foldrs with functions as accumulators still regarded as folds though? I'm unfamiliar with the theoretical definition.
04:52:42 <quchen> (I'm using that myself a lot, but I'm never quite sure how idiomatic it is.)
04:52:52 <int-e> quchen: certainly, otherwise you'll have trouble implementing foldl with foldr.
04:53:21 <quchen> int-e: Right.
04:53:30 <quchen> Silly me.
04:59:37 <Taneb> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
05:00:30 <lambdabot> f a b = a (\ c -> c b)
05:05:24 <quchen> Guessing Cont types could be a game show
05:05:44 <quchen> ... join?
05:06:14 <hpaste> hseg pasted “Help re: Monad Laws proofs” at http://hpaste.org/85398
05:06:51 <Taneb> quchen, yep
05:07:53 <Taneb> @djinn ((a -> r -> r) -> r -> r) -> (Maybe (a, (a -> r -> r) -> r -> r) -> r -> r) -> r -> r
05:07:54 <lambdabot> f a b c = a (\ d e -> b (Just (d, \ f -> f d)) e) (b Nothing c)
05:08:08 <Taneb> (a tricky one)
05:08:08 <armlessh1bo> yall are up too early
05:08:16 <Taneb> armlessh1bo, it's lunchtime here
05:08:44 <hpaste> quchen annotated “Help re: Monad Laws proofs” with “Help re: Monad Laws proofs (annotation)” at http://hpaste.org/85398#a85399
05:08:57 <armlessh1bo> Taneb: England?
05:09:03 <armlessh1bo> somewhere in Europe?
05:09:11 <Taneb> armlessh1bo, yeah
05:09:22 <Taneb> UK
05:09:27 <armlessh1bo> already had your elevensies
05:09:27 <quchen> 14:00 here
05:09:28 <armlessh1bo> :P
05:09:36 <armlessh1bo> and other british meal times
05:10:02 <armlessh1bo> quchen: somewhere in eastern europe?
05:10:14 <Taneb> Western Europe, I think
05:10:18 <armlessh1bo> yea
05:10:18 <quchen> armlessh1bo: Arguably. Bavaria
05:10:28 <quchen> East of Portugal at least
05:11:02 <armlessh1bo> lol
05:11:10 <quchen> Taneb: Is that really a standard function there? :s
05:11:13 <armlessh1bo> Germany is still Western Europe to me lol
05:11:18 <Taneb> quchen, not really
05:11:18 <typoclass> quchen: bavaria counts as europe? is that new?
05:11:28 <hseg> quchen: You're missing the point of what I'm attempting to do. Given (>=>) and the laws associated with it, prove the laws fpr (>>=). You're using the definition f >=> g = \x -> (f x) >>= g, which is only applicable the other way round
05:11:31 <Taneb> It's msplit for Cont (Endo a)
05:11:34 <Taneb> from logict
05:11:47 <kurkale6ka> newtype Pair b a = Pair { getPair :: (a,b) } What means that the second type parameter represents the type of the first component in the tuple?
05:11:47 <quchen> Oh. Well I would never have guessed that.
05:12:07 <hseg> That's noted in the first few lines of comment in the original paste
05:12:11 <quchen> typoclass: It was a joke. Bavaria is of course the center of Europe.
05:12:12 <Taneb> (I'm writing instances and being ridiculous)
05:12:39 <quchen> hseg: Oh, sorry then, the annotation isn't very helpful in that case
05:13:16 <hseg> It's OK.
05:13:31 <quchen> hseg: So you're trying to derive the pasted formula given the usual monad laws then
05:13:40 <quchen> And you've got the other >=> laws already, and this one is still open?
05:14:15 <hseg> No, I'm trying to derive the usual presentation of the monad laws from their presentation in terms of >=>
05:14:35 <hseg> And I've reduced the problem to deriving the pasted identity from the >=> laws
05:14:42 <quchen> Aaah.
05:15:04 <hseg> Where the laws are given here: http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_3
05:15:43 <hseg> I'm willing to post the remainder of the proofs on request.
05:18:01 <quchen> The >=> laws always confuse me. They look like the monoid laws, but I'm always told that's not the monoid in the "monoid in the category of ...".
05:18:20 <armlessh1bo> if I call hGetLine 5 times, does it discard the data after each call, or does it wait until after it goes out of scope before releasing it?
05:18:55 <quchen> armlessh1bo: Does that matter? Sounds like it's up to the compiler's current mood to do that
05:19:11 <hseg> They're not monoid laws, but rather Category laws.
05:19:28 <armlessh1bo> quchen: well, my goal for my little project is to not consume so much memory when I don't need to.
05:19:35 <quchen> hseg: >=> is an associative binary operation with identity. Why is that not a monoid?
05:19:42 <armlessh1bo> and reading in a 180MB file seems a bit unnecessary
05:20:37 <quchen> armlessh1bo: Oh, something practical. I don't know in that case. :-/
05:20:51 <armlessh1bo> so, I want to read a line at a time and parse through the file, looking for matches to a provided query
05:21:46 <quchen> armlessh1bo: I think the rule of thumb is that IO works sequentially, but when the compiler starts optimizing I don't know what can happen.
05:21:57 <hseg> I don't know. It *does* seem that you're right. I was thinking more in terms of the Kleisli category of the monad.
05:22:02 <quchen> But maybe ask someone with proper knowledge about this later :-s
05:22:03 <Botje> armlessh1bo: unless you pass the previously read line to next iterations, you'll be fine.
05:23:27 <armlessh1bo> Botje: so, I shouldn't loop on a hGetLine, I should loop a function that calls a function that does hGetLine?
05:24:27 <Botje> armlessh1bo: uh, show your code.
05:24:44 <armlessh1bo> Botje: don't have code, just planning the attack
05:24:55 <quchen> hseg: Hm. That actually brings up the question what the difference between a category and a monoid is in Haskell terms.
05:25:17 <Botje> something like loop = do { l <- getLine; ...; loop } should work fine.
05:25:26 <quchen> hseg: Oh, a monoid has m->m->m, whereas a category can have altering types?
05:25:54 <hseg> Right. I probably was wrong. Also, I'm not that knowledgable in this topic.
05:26:07 <hseg> Looking at Category, it doesn't seem to have laws listed
05:26:36 <quchen> hseg: It says "A class for categories. id and (.) must form a monoid."
05:26:42 <quchen> Guess that answers that
05:27:08 <alpounet> quchen, hseg, well, in a monoid you can combine any two elements, that's not the case in the kleisli category of a monad I guess
05:27:50 <quchen> alpounet: How so?
05:27:57 <quchen> alpounet: Type mismatches?
05:28:45 <hseg> quchen: No, Kind mismatches
05:29:19 <hseg> As in, instances of Category have kind * -> * -> *, while instances of Monoid have kind *
05:29:38 <quchen> So a monoid would be something of sorts "mappend :: cat a a -> cat a a -> cat a a"
05:30:01 <quchen> Whereas category can have the more general version "(.) :: cat a b -> cat c a -> cat c b"
05:32:59 <hseg> Right. Rule of thumb - if it has type variables, it doesn't have a monoid instance (though if you instantiate some of the variables, you could generate an instance)
05:34:12 <quchen> Good to know, thanks.
05:34:12 <ion> instance (Monoid a, Monoid b) => Monoid (a, b)
05:34:25 <ion> instance Monoid b => Monoid (a -> b)
05:35:04 <ion> Some examples of types with type variables that do have a Monoid instance.
05:35:16 <ion> The [a] instance doesn’t even need a Monoid constraint on a.
05:35:30 <alpounet> quchen, you can get a monoid if you restrict to (a -> m a) though I guess
05:38:23 <byorgey> alpounet: indeed
05:38:27 <hseg> Wait, what? Now I'm confused. Is there a restriction on what kinds can be instances of Monoid or isn't there?
05:38:42 <byorgey> hseg: there is.  Only things with kind * can be instances of Monoid.
05:38:48 <byorgey> (a -> m a) has kind *.
05:38:53 <alpounet> hseg, something that's a monoid is necessarily a type, not a type constructor
05:38:55 <byorgey> (->) has kind  * -> * -> *
05:39:20 <hseg> But (a,b) is of kind * -> * -> *, no?
05:39:23 <byorgey> no
05:39:29 <byorgey> (,) is of kind  * -> * -> *
05:39:31 <alpounet> no hseg because you can't feed it any more type variable
05:39:32 <byorgey> (a,b) :: *
05:39:36 <alpounet> or type
05:40:08 <hseg> Oh. So the monoid instance would have, e.g. mappend :: (a,b) -> (a,b) -> (a,b)
05:40:14 <merijn> :k (,)
05:40:15 <lambdabot> * -> * -> *
05:40:19 <byorgey> Maybe :: * -> * ;  Maybe a :: *.  and so on.
05:40:23 <merijn> :k (,) Int
05:40:25 <lambdabot> * -> *
05:40:26 <alpounet> (,) can be seen as some kind of type level function. (,) expects two types (or type variables if your code is polymorphic)
05:40:31 <byorgey> hseg: right.
05:40:42 <merijn> alpounet: Well, type level constructor
05:40:59 <hseg> Right. I think I got it now.
05:41:05 <merijn> Since that's what it is (and we now have actual type level functions too)
05:41:32 <hseg> Wat. Could you give an example of a non-trivial type level function?
05:41:52 <opqdonut> using type families
05:42:03 <opqdonut> e.g. http://www.haskell.org/haskellwiki/Type_arithmetic
05:42:28 <alpounet> merijn, type constructor is used too, but that won't help people understand the point we're trying to explain with. however, type level function is, I think, right too
05:42:30 <merijn> hseg: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs
05:42:36 <opqdonut> oh, that first example actually uses fundeps instead of type families
05:42:54 <merijn> hseg: BoxFun is a type function there
05:43:06 <merijn> It takes a type as input and returns a different type
05:43:22 <merijn> (Actually, it takes a list of types as input and returns a type)
05:44:07 <hseg> Okay. I think I need to read up a bit more on the topic.
05:45:03 <merijn> hseg: A short explanation of what it is doing is: "Pattern p" is an input pattern (haskell data structure) describing the input format. p is a list of types here
05:45:32 <merijn> hseg: BoxFun turns a list of types into a function type that takes each of the types in the list and returns "IO ()"
05:46:00 <hseg> Can someone help me prove this: http://hpaste.org/85398 identity given the monad laws in terms of >=>?
05:46:06 <merijn> hseg: It thus typechecks whether the function arguments of the function passed to apply matches the types of the Pattern passed to apply
05:46:17 <hseg> Nice. Again, I think I need to read more on this
05:46:41 <merijn> Or, even shorter "it checks at compile time that my callback function has the right number of arguments for the pattern I'm associating it with"
05:47:20 <merijn> hseg: A good place to start before looking into type functions is GADTs (although people might disagree with me about that)
05:47:32 <merijn> Because GADTs are the bee's knees
05:47:45 <hseg> ? Don't understand that expression
05:48:04 <merijn> X is the bee's knees = X is awesome
05:48:10 <hseg> But I wanted to learn GADTs anyway, so that's OK.
05:48:27 <merijn> http://www.phrases.org.uk/meanings/the-bees-knees.html
05:48:53 <merijn> hseg: I have some examples of using GADTs and DataKinds in that repo to (in Types.hs I think?)
05:49:06 <merijn> I should revisit that code sometime
05:49:08 <typoclass> merijn: i've heard that gadts are the cat's pajamas ...?
05:58:22 <hseg> Can someone help me prove this: http://hpaste.org/85398 identity given the monad laws in terms of >=>?
05:58:49 <hseg> i.e. (id >=> f) . g === g >=> f
06:02:39 <int-e> (id >=> f) . g = (\x -> id x >>= f) . g =
06:03:34 <int-e> \x -> (\x -> id x >>= f) (g x) = \x -> id (g x) >>= f) = \x -> g x >>= f  = g >=> f. No monad laws are actually involved.
06:03:40 <quchen> int-e: He wants to show the equality mentioned using the monad laws as axioms, so to speak.
06:03:50 <hseg> int-e: You're missing the point. I'm trying to prove the >>= monad laws from the >=> monad laws, not the other way round
06:04:35 <quchen> i.e. show that (monad laws)   ==>   (id >=> f) . g === g >=> f
06:05:01 <hseg> quchen: s/monad laws/monad laws in terms of >=>/
06:07:17 <dmwit> I don't understand how int-e is missing the point.
06:07:41 <dmwit> Surely if you're going to prove (>>=) monad laws in terms of the (>=>) monad laws, you must assume some connection between (>>=) and (>=>).
06:07:59 <dmwit> int-e has assumed the obvious connection, namely that f >=> g = \x -> f x >>= g
06:08:05 <dmwit> (and nothing else, including monad laws)
06:08:34 <int-e> (f >=> g) . h = (f . h) >=> g  is not covered by the "Kleisli arrows are a category" monad laws.
06:10:17 <hseg> Wait. You're right. I did have to define (>>=) = (id >=>)
06:11:04 <linduxed> hey guys, i'm having a really tough time trying to formulate one line in this code https://gist.github.com/linduxed/5336662
06:11:04 <hseg> So you're saying that it is equally legitimate, in the proof, to define the inverse of this assignment, i.e. use >=>'s definition in terms of >>=?
06:11:13 <linduxed> the line in question is 19
06:11:25 <dmwit> We could try to formulate the proof in terms of your connection instead, if you like.
06:11:40 <hseg> That would be nice.
06:12:07 <int-e> hseg: nah I think you asked a valid question, although I'd ask for a precise statement of the monad laws in terms of (>=>) instead :)
06:12:33 <dmwit> return >=> f = f >=> return = f; (f >=> g) >=> h = f >=> (g >=> h)
06:12:46 <hseg> The precise statement is given in the typeclassopedia: http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_3
06:13:19 <dmwit> alternately
06:13:26 <linduxed> i need to somehow go through the starting (availableDirections start), which will be [DRight, DDown] and store all the paths generated
06:13:26 <dmwit> (>=>) is associative and return is its unit
06:13:44 <linduxed> or well, that's what I want to do, but i don't know how to express that on line 19
06:14:02 <linduxed> right now it's not lining up with the type system
06:14:03 <Botje> linduxed: oh, heh. that's a fun euler problem
06:14:31 <linduxed> Botje: sure is, and i'm one tweak away from finishing the problem :-S
06:14:45 <linduxed> i just can't express the problem properly on that line
06:15:26 <Botje> linduxed: so you want to take all the paths generated by the call to branchLoop and put d in front of them, right?
06:15:33 <int-e> is there a variant of @free that lets one specify the type?
06:15:45 <quchen> linduxed: I'm not sure brute force is a good solution for this problem, but if you see it as Haskell practice that's besides the point.
06:15:58 <quchen> In that case ignore what I said. :-)
06:16:00 <dmwit> int-e: ?free lets you specify the type
06:16:02 <linduxed> quchen: right, brute force it is
06:16:04 <dmwit> ?free foo :: a -> b
06:16:04 <lambdabot> g . foo = foo . f
06:16:33 <int-e> @free gteqgt :: (a -> m b) -> (b -> m c) -> (a -> m c)
06:16:33 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,17)-(160,45): Non-exhaustive patterns in case
06:16:35 <linduxed> Botje: well, availableDirections already determines whether it's ok to move down or right
06:16:41 <Botje> linduxed: so the naive way of writing that would be [ d : path | path <- branchLoop ... ]
06:16:54 <int-e> @free gteqgt :: (a -> [b]) -> (b -> [c]) -> (a -> [c])
06:16:55 <lambdabot> $map g . k = p . f => $map h . q = f1 . g => $map h . gteqgt k q = gteqgt p f1 . f
06:16:59 <Botje> linduxed: which desugars to map (d:) (branchLoop ...)
06:17:01 <beaky> hello
06:17:03 <linduxed> Botje: hmmm, i wouldn't have thought of that
06:17:16 <beaky> is haskell's [a] a singly linked list, or a dobly linked one?
06:17:22 <quchen> beaky: singly
06:17:23 <mauke> @src []
06:17:23 <lambdabot> data [] a = [] | a : [a]
06:17:31 <beaky> ah
06:17:39 <quchen> beaky: Each element consists of a value and a "rest of the list".
06:17:50 <dmwit> beaky: Have you ever tried to implement an immutable, doubly-linked list?
06:17:58 <dmwit> If you have, you'll know why nobody uses them. =)
06:17:58 <beaky> dmwit: no; best I got was a zipper thing
06:18:06 <linduxed> Botje: the desugared version is a little to heavy for my mind right now, will have to digest that for a bit
06:18:08 <dmwit> (in any language)
06:18:13 <beaky> what's wrong with purely-functional doubly-linekd list?
06:18:16 <beaky> they are slow?
06:18:20 <linduxed> Botje: the list comprehension version however, i'll have a look at that
06:18:22 <beaky> hard to implement?
06:18:35 <dmwit> beaky: Think for a moment about what bits of the list you have to copy when you update a node.
06:18:44 <Botje> linduxed: it's a transliteration of what I wrote above in english.
06:18:44 <beaky> not cache-friendly? (I think singly-linked list is not cache friendly either)
06:18:45 <beaky> ah
06:19:52 <beaky> well a purely-functional update of a doubly-linked list is like making a new list
06:20:12 <beaky> or am I mistaken? :D
06:20:23 <Taneb> But with a singly linked list, a lot of the new list can be shared with the old list
06:20:26 <Taneb> The entire tail
06:20:38 <Taneb> But with a doubly-linked list, the whole thing has to be done from scratch
06:20:40 <beaky> ah
06:20:48 <quchen> You'll have to renew the entire spine of the list, beaky. That kind of defeats the purpose of a doubly linked list.
06:20:51 <parcs> Data.Sequence is like a doubly linked list
06:20:51 <lambdabot> parcs: You have 8 new messages. '/msg lambdabot @messages' to read them.
06:21:02 <parcs> cool
06:21:05 <beaky> lol
06:21:12 <quchen> parcs: Viewer discretion is advised ;-)
06:21:16 <dmwit> ?msg parcs and one for good measure
06:21:17 <lambdabot> Not enough privileges
06:21:20 <dmwit> um
06:21:24 <beaky> aw
06:21:24 <dmwit> ?tell parcs ^^
06:21:24 <lambdabot> Consider it noted.
06:21:25 <Taneb> tell or ask
06:21:54 <linduxed> Botje: well the line now reads as branchLoop (d:ds) currPos = [ d : path | path <- branchLoop (availableDirections moveOneStep) moveOneStep ] where
06:22:02 <linduxed> Botje: but that doesn't use ds at all
06:22:04 <beaky> I've read somewhere that haskell's data sequence is a very smart and elegant data structure
06:22:15 <linduxed> Botje: hmmm, wait a minute
06:22:20 <beaky> and I saw a picture of it somewhere on wikipdia and it's awesome
06:22:37 <beaky> it's like a layered tree
06:23:03 <beaky> with O(1) push_front and push_back
06:23:17 * dmwit wonders in what sense finger trees are like doubly-linked lists
06:23:20 <Botje> linduxed: oh, right. then ++ it with branchLoop ds currPos or something?
06:23:21 <linduxed> Botje: added "++ branchLoop ds currPos", we'll see how well that works
06:23:28 <beaky> yeah they are quite differentfrom doubly-linked list
06:23:52 <int-e> hseg: if I read that correctly, then we get (p . f) >=> q = (p >=> q) . f as a free theorem, letting g=h=id in the above result (and using $map id = id).
06:23:52 <linduxed> Botje: gaaaah
06:23:56 <linduxed> didn't work
06:24:24 <linduxed> Botje: https://gist.github.com/5336733
06:24:30 <beaky> O(1) end access/update, O(log n) random access, O(m log n) insert is awesome
06:24:39 <linduxed> i have NO idea what to do about that
06:24:41 <hseg> Whoa. Wait, what? Could you please explain?
06:24:49 <int-e> hseg: But that assumes that  Kleisli m a b = a -> m b and that m is a Functor.
06:24:54 <Botje> linduxed: you're trying to print a function.
06:25:04 <Botje> linduxed: that typically means you forgot to feed a parameter to your function
06:25:12 <linduxed> Botje: hmmm, ok?
06:25:27 <linduxed> Botje: yeah now i understand that... still don't know what to do
06:25:30 <linduxed> lemme see here...
06:25:40 <Botje> linduxed: how many arguments does pickAllPaths take?
06:25:51 <linduxed> oh ffs i'm an idiot
06:26:03 <linduxed> ok
06:26:06 <linduxed> that fixed that
06:26:10 <linduxed> new problem though
06:26:24 <Botje> linduxed: the solution is somewhere around 100 * 10^9, so don't expect to be able to solve it this way
06:26:24 <linduxed> return of pickAllPaths (2,2) is []
06:26:59 <linduxed> dude, i want to be able to solve a 2x2 with this method first
06:27:04 <linduxed> can't even do that atm :-P
06:27:19 <linduxed> hmmm
06:27:21 <Botje> well, work it through by hand
06:28:11 <int-e> hseg: Honestly I don't really understand free theorems, I was just curious whether they could be applied to your question.
06:29:17 <quchen> Amortized time simply refers to the average/most likely real world case, right?
06:29:31 <merijn> linduxed: Also, remember your best debugging friend, Debug.Trace.trace :)
06:29:39 <quchen> As in "performance worse than amortized is only found in pathological examples"
06:29:43 <linduxed> merijn: yeah, i'm busting it out right now
06:30:16 <merijn> quchen: No, amortised means averaged over time
06:30:39 <merijn> quchen: i.e. one specific update might take a lot longer than amortised, but the next bunch will be quicker
06:31:10 <quchen> merijn: Ah, when you said "time" it meant something like "many operations"
06:31:40 <linduxed> i just don't get this
06:31:46 <merijn> quchen: For example, imagine having to rebalance a tree. That takes a lot of time, but if you only have to do it every 100 or 1000 thousand inserts and makes the intermediate ones a lot faster (or even O(1)) then you can spread the rebalancing cost over those 100s or 1000s and call that the amortised cost
06:31:49 <linduxed> when i add a "trace (show d) $" before the list comprehension
06:31:54 <linduxed> i see all of the directions
06:32:00 <hseg> quchen: It means you specify its behaviour over time rather than at each invocation.
06:32:01 <linduxed> so it's clearly going through all of them
06:32:09 <linduxed> but it's still returning [] in the end
06:32:12 <linduxed> :-S
06:32:19 <dmwit> Amortized analyses often omit discussion of a common caveat at the beginning: they are typically valid only in special circumstances that limits the amount of "backtracking" that you do.
06:32:44 <merijn> linduxed: hpaste the code?
06:33:09 <linduxed> merijn: https://gist.github.com/5336779
06:33:14 <linduxed> that's the one that typechecks and everything
06:33:25 <pamojarpan> hello, is there someone with experience using haskell for dsp?
06:33:31 <dmwit> For example, for an amortized queue, it's assumed that you don't hold on to a specific queue and repeatedly dequeue from it. Instead, you're expected to dequeue once, then perform the rest of your operations on the queue returned by this operation.
06:33:33 <merijn> quchen: My dictionary defines "to amortize" as "gradually write off the initial cost of (an asset)"
06:33:34 <linduxed> running "pickAllPaths (2,2)" is what i want to do
06:34:01 <linduxed> the return result currently is [], while it should be six [Direction]
06:34:18 <merijn> linduxed: Style remark, it's common to have the where at the beginning of its own line
06:34:20 <Botje> linduxed: work out branchLoop [DRight] (1,2) by hand.
06:34:28 <quchen> dmwit, merijn: That clarified it I think, thanks.
06:34:31 <Botje> (assuming you have a 2x2 gridSize)
06:34:37 <merijn> So either start the functions directly after the line containing "where" or have where on it's own line and the definitions below.
06:34:41 <linduxed> merijn: oh, i'm used to putting it after the line :-/
06:34:48 <linduxed> merijn: i take it my style is uncommon?
06:34:59 <dmwit> pamojarpan: Just ask your question. If somebody knows, they'll answer; if not, you'll wait around for no answer -- same as you will for that question.
06:35:11 <linduxed> Botje: lemme see
06:35:45 <merijn> linduxed: Yes, since it makes it easy to miss the where (I was actually confused upon first seeing the code, until I spotted it at the end)
06:36:29 <Botje> linduxed: also ponder what map (d:) [] produces, versus map (d:) [[]]
06:36:45 <Botje> (or the list-comprehension equivalents)
06:37:12 <merijn> More common would be "where start = (0,0)" in place of "start = (0,0)" (that means indenting the rest to match the indent of start) or to have "where\nstart = (0, 0)" with some appropriate indent after the newline
06:38:02 <pamojarpan> dmwit: Sorry man. I just wanna know some general impressions about expressiveness and performance. I'm just starting with haskell and I'm sick of C++ for image processing (Bayer domain).
06:39:34 <linduxed> merijn: i've seen the style where people have an indent matching the place where start is, but i don't like it when the indentation isn't a multiple of whatever-amount-of-spaces-i-use
06:40:11 <merijn> linduxed: If you indent start to be the line below where then you don't have the problem (or, you do but you get to pick how far you indent start)
06:41:15 <linduxed> merijn: this better? https://gist.github.com/5336821
06:41:33 <linduxed> merijn: a half-indent instead
06:41:59 <hpaste> merijn pasted “where on its own line” at http://hpaste.org/85403
06:42:22 <merijn> Ah, yeah that's exactly the example I had :)
06:42:45 <hpaste> hseg pasted “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>” at http://hpaste.org/85404
06:42:47 <merijn> The only rule is start needs to be indented more than the w in where and everything else needs to be indented equal with start
06:43:07 <linduxed> yeah, i've seen that style a few times before, and i guess that's ok
06:43:08 <linduxed> now
06:43:20 <linduxed> back to understanding why the hell my code returns []
06:43:26 <linduxed> gotta think about what Botje said
06:43:33 <romm> pamojarpan: what so bad with C++ for image processing?
06:43:44 <dmwit> start does not need to be indented more than where
06:44:25 <linduxed> dmwit: but i want it at 4 spaces, i'll indent where with a half-step
06:44:59 <dmwit> You can indent it with a half-step if you want, but you don't need to.
06:45:15 <pamojarpan> romm: because the algorithm and the scheduling are coupled. And I don't like C++ syntax, neither it's OO model.
06:45:18 <linduxed> dmwit: yeah i know that, thx
06:45:22 <hseg> dmwit: Doesn't where start a layout?
06:45:37 <dmwit> hseg: No, where is a layout herald. The first thing after where starts the layout.
06:45:43 <merijn> ah
06:45:55 <merijn> ok, my bad. Still I prefer that style :p
06:46:16 <hseg> Right. Like "of" in "case .. of" and "do". That was what I meant.
06:46:42 <dmwit> Okay. But saying that "where" is a layout herald does not mean that "start" must be indented more than "where".
06:46:52 <dmwit> It can be more, equal, or less; depending on enclosing blocks.
06:47:00 <merijn> linduxed: When you reach gridSize, what is the return value of calling availableDirections?
06:47:04 <hseg> Can someone review my proof of the inferrence of the >>= laws from the >=> laws here: http://hpaste.org/85404 ?
06:47:17 <linduxed> merijn: []
06:47:28 <merijn> linduxed: And "branchLoop [] _" is?
06:47:38 <linduxed> merijn: []
06:47:58 <merijn> > [ True:path | path <- []]
06:47:59 <lambdabot>   []
06:48:09 <linduxed> but that's at the end of a:b:c:d:[]
06:48:11 <linduxed> i thought
06:48:21 <linduxed> i don't see how it could do that
06:48:37 <linduxed> i'm totally confused by what lambdabot just wrote
06:48:41 <linduxed> makes no sense to me
06:48:47 <merijn> linduxed: For each entry in "branchLoop []" it appends a value and returns the list of that
06:48:56 <linduxed> yes
06:48:58 <merijn> > [ True:path | path <- [[]]]
06:48:59 <lambdabot>   [[True]]
06:49:23 <linduxed> i have to fucking digest that
06:49:24 <dmwit> linduxed: ...but there are no entries in "branchLoop []", so it appends a value to no entries.
06:49:25 <linduxed> omg
06:49:26 <merijn> linduxed: You want branchLoop to return a list of empty paths, when you reach gridSize
06:49:30 <linduxed> this makes no sense in my head
06:49:35 <merijn> Not a list with no paths :)
06:49:40 <linduxed> why [[]] makes it work like i think but [] doesn't
06:49:53 <merijn> linduxed: [[]] and [] are different things
06:49:56 <merijn> > length [[]]
06:49:58 <lambdabot>   1
06:49:58 <dmwit> linduxed: [] is an empty list (no paths); [[]] is a singleton list (one path, namely the empty one)
06:50:02 <merijn> > length []
06:50:03 <lambdabot>   0
06:50:23 * linduxed just has to stare at this shit for a moment
06:50:29 <dmwit> > []:[] -- just for fun, because I hate you and hope you die
06:50:30 <merijn> [[]] = [] : [], [] = []
06:50:30 <lambdabot>   [[]]
06:51:04 <linduxed> dmwit: i assume that was directed to lambdabot :-)
06:51:27 <merijn> linduxed: You take all paths and append the possible steps to them in branchLoop, which is right. *but* you need to have actual paths to append them to, even if they are empty paths
06:51:27 <dmwit> No, you, linduxed! I HATE YOU AND HOPE YOU DIE =(
06:51:45 <linduxed> :-(
06:51:48 <quchen> wat
06:51:50 <merijn> A list with no paths will append something to each of the nonexistent paths, resulting in a still empty list
06:52:06 <dmwit> Yay, he's back!
06:52:11 <linduxed> :-)
06:52:44 <merijn> linduxed: Remember that "[d:path | path <- branchLoop [] foo]" is equal to "map (d:) $ branchLoop [] foo"
06:53:00 <merijn> > map (+1) []
06:53:01 <lambdabot>   []
06:53:07 <merijn> > map (True:) []
06:53:09 <lambdabot>   []
06:53:26 <merijn> > map (True:) [[]]
06:53:28 <lambdabot>   [[True]]
06:53:30 <linduxed> well in that case i've got a problem
06:53:31 <merijn> > map (True:) [[False]]
06:53:32 <lambdabot>   [[True,False]]
06:53:53 <linduxed> because availableDirections clearly should have the type that is has currently
06:54:01 <linduxed> returning [Direction]
06:54:16 <ab9rf> :t []:[]
06:54:17 <lambdabot> [[a]]
06:54:21 <linduxed> i can't change it to [[Direction]], because that mames no sense
06:54:25 <linduxed> *makes
06:54:31 <merijn> I think you're just building the path the wrong way around
06:54:45 <linduxed> merijn: that could be the case
06:54:46 <dmwit> But... availableDirections doesn't need to change at all, does it?
06:54:48 <merijn> linduxed: You don't have to change availableDirections
06:54:49 * dmwit opens the paste again
06:54:55 <merijn> linduxed: You need to change branchLoop
06:55:03 <merijn> branchLoop is returning the empty list
06:55:09 <linduxed> merijn: i was thinkinthat i should change line 27 to [[]]
06:55:17 <linduxed> that that's what you meant
06:55:20 <merijn> No, line 19
06:55:30 <linduxed> ok
06:55:51 <dmwit> You should not change line 19 until you understand the change you are making, however.
06:55:59 <linduxed> well
06:56:04 <dmwit> Anything else is dishonest.
06:56:05 <merijn> The problem is when "availableDirections moved" returns [], then branchLoop returns []
06:56:18 <ab9rf> dmwit: not fond of development by random mutation, are you?
06:56:23 <linduxed> i changed it to "branchLoop [] _ = [[]]" and it works now
06:56:28 <linduxed> with that said though
06:56:44 <linduxed> exactly like dmwit said, i need to understand this
06:56:44 <merijn> linduxed: Try rewriting it using map instead of the list comprehension
06:56:48 <dmwit> ab9rf: I hate it and hope it dies!
06:57:05 <ab9rf> dmwit: it's just the software engineering equivalent of natural selection!
06:57:09 <hiptobecubic> stochastic programming :)
06:57:20 <linduxed> merijn: i don't have a problem with the list comprehension part
06:57:33 <merijn> linduxed: No, but doing that will help you realise the actual problem
06:57:53 <merijn> The list comprehension is sneakily hiding a subtle detail that is really obvious when using map
06:58:20 <linduxed> merijn: what i have a problem with is that True:[] doesn't end up as [True] but True:[[]] does
06:58:26 <hseg> Can someone please review my proof here http://hpaste.org/85404 ?
06:58:50 <merijn> linduxed: "True:[]" does end up as [True]
06:59:04 <merijn> > True:[]
06:59:05 <linduxed> see that's what i don't get
06:59:06 <lambdabot>   [True]
06:59:18 <merijn> But!
06:59:20 <linduxed> and here lies the problem for me!
06:59:32 <linduxed> i don't see a difference in my code!
06:59:34 <dmwit> ab9rf: Well I don't like natural selection either! GO GO modern medicine!
06:59:35 <merijn> > [True:path | path <- []]" -- /= True:[]
06:59:37 <armlessh1bo> @type (:)
06:59:37 <lambdabot>   <hint>:1:40:
06:59:37 <lambdabot>      lexical error in string/character literal at end of input
06:59:38 <lambdabot> a -> [a] -> [a]
06:59:48 <merijn> > [True:path | path <- []] -- /= True:[]
06:59:49 <lambdabot>   []
06:59:54 <linduxed> exactly!
06:59:58 <linduxed> that makes no sense to me
07:00:00 <dmwit> Actually I'm not sure how far I want to back that last claim up.
07:00:18 <merijn> linduxed: Maybe this helps
07:00:21 <hiptobecubic> linduxed, where would the [] come from?
07:00:29 <merijn> > [True:path | path <- [False]]
07:00:30 <hiptobecubic> linduxed, it can't come from [], there's nothing in []
07:00:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
07:00:31 <lambdabot>              with actual ty...
07:00:49 <merijn> linduxed: path becomes every element in the list, *not* the list itself
07:00:55 <merijn> Empty lists have no elements
07:01:04 <linduxed> ooooooh
07:01:18 <hiptobecubic> linduxed, you have an empty bag and you're saying "take everything out of it and put a bean in each"
07:01:20 <merijn> Like I said earlier "map foo []" = "[foo path | path <- []]"
07:01:24 <linduxed> so it can't DO any True:path, because there's no path to do anything with
07:01:29 <linduxed> so it generates no elements
07:01:31 <merijn> linduxed: Correct
07:01:35 <linduxed> because it has nothing to generate from
07:01:43 <hiptobecubic> well
07:01:46 <hiptobecubic> it's the terminal case
07:01:51 <dmwit> hseg: If you take f >=> g = \x -> f x >>= g as an axiom, you don't need the contortions involved in the first lemma.
07:02:05 <hiptobecubic> lists are always defined like  x:y:[]
07:02:10 <dmwit> hseg: return a >>= k = (return >=> k) a directly
07:02:11 <hiptobecubic> your list just doesn't have x or y in it
07:02:29 <linduxed> okokok
07:02:37 <linduxed> so lemme get this straight now
07:02:41 <dmwit> hseg: or return a >>= k = (\x -> return x >>= k) a = (return >=> k) a if you prefer
07:02:48 <merijn> linduxed: You were just unlucky that [] and [[]] are both valid values of [[Direction]] :)
07:02:49 <linduxed> when i had [] on the end of line 19
07:02:57 <hseg> Right. However, I can't see how to prove the lemma without taking it as an axiom, which is what was causing me trouble earlier.
07:03:21 <linduxed> essentially, it needed d:d:d:[] but i gave it something like d:d:d:
07:03:32 <linduxed> and some... sub-[] at the end
07:03:33 <linduxed> right?
07:03:36 <armlessh1bo> merijn: does the 'x <- [1,2,3]' in [x | x <- [1,2,3]] act like '[1,2,3] >>= (\x -> ...'
07:03:48 <merijn> armlessh1bo: Yes
07:04:01 <merijn> armlessh1bo: In fact, it *is* [1,2,3] >>= \x
07:04:06 <armlessh1bo> :O mind exploded
07:04:20 <armlessh1bo> i knew it. that conniving little bugger.
07:04:26 <merijn> armlessh1bo: There's even an extension MonadComprehensions that makes list comprehension work on any monad
07:04:58 <hiptobecubic> merijn, demo?
07:05:16 <merijn> hiptobecubic: I'm not sure it works in lambdabot and not sure I know the syntax correctly :p
07:05:16 <quchen> > [ x | x <- Just 1 ]
07:05:17 <lambdabot>   Couldn't match expected type `[t0]'
07:05:18 <lambdabot>              with actual type `Data.May...
07:05:21 <quchen> :-(
07:05:45 <geekosaur> caleskell, but no monad comps :/
07:06:02 <merijn> quchen: Example works in ghci if you ":set MonadComprehensions"
07:06:13 <hiptobecubic> ok
07:06:17 <quchen> merijn: Yes I know, I wanted to find out whether Lambdabot has it enabled
07:06:27 <hiptobecubic> 7.6+ ?
07:06:30 <merijn> quchen: I wanted to type "quchen's", but I failed
07:06:40 <merijn> hiptobecubic: I was using 7.4
07:06:43 <hiptobecubic> hmm
07:06:46 <merijn> I think it's in earlier versions too
07:07:00 <hiptobecubic> flag not recognized
07:07:16 <merijn> including the terminating s?
07:07:20 <hiptobecubic> yes
07:07:39 <merijn> merijn ~ 0$ ghci -XMonadComprehensions
07:07:42 <merijn> GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
07:07:54 <hiptobecubic> yes had to do it at the start of ghci
07:07:57 <hiptobecubic> works now
07:08:15 <merijn> :set also works for me, but then you need to leave out the -X
07:08:17 <hseg> dmwit: So, does it make sense to attempt to prove the lemma without assuming the definition of >=> in terms of >>= ? If so, how would you suggest going around doing it?
07:08:25 <hseg> Otherwise, why not?
07:08:25 <linduxed> obviously, now that i understand it and it works, i realize that not only does it print out all the paths, it also prints out all the partial paths on the way to the end :-S
07:08:34 <linduxed> time to rework this shit
07:08:48 <merijn> oh wait, you do need the -X, my bad
07:09:03 <hiptobecubic> oh
07:09:22 <merijn> linduxed: You live, you learn ;)
07:09:29 <linduxed> merijn: yeah, i guess
07:09:57 <linduxed> merijn: the funny thing about this is that i have already done a more complicated version of this before and i still can't solve this properly :-D
07:09:58 <merijn> Might wanna use the list monad instead of this
07:10:10 <dmwit> hseg: Well, the oddity is that id is not the identity in the right category.
07:10:43 <hseg> Right. return is the identity in this category.
07:11:04 <dmwit> hseg: And also it has the wrong type. -_-
07:11:06 <merijn> oneStep :: (Int, Int) -> Path -> [Path]
07:11:10 <dmwit> ?ty (id >=>)
07:11:12 <lambdabot> Monad m => (b -> m c) -> m b -> m c
07:11:13 <dmwit> ?ty (>>=)
07:11:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:11:29 <hseg> ?ty (>>=)
07:11:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:11:58 <hseg> ?ty flip (>>=)
07:12:00 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:12:16 <hseg> You're right, I forgot a flip there.
07:12:23 <thirsteh> is there a library that will take an URL (Text) and give me proto, host and path (splitting path not necessary)?
07:12:58 <Kinnison> Network.URL ? (from the url package)
07:13:07 <Kinnison> http://hackage.haskell.org/packages/archive/url/2.1.3/doc/html/Network-URL.html
07:14:09 <thirsteh> I'd like to use Text if possible
07:14:19 <thirsteh> this has to be very fast
07:14:31 <thirsteh> everything I've found has been something in-between, e.g. take a String
07:14:44 <hpaste> hseg revised “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>”: “Fixed proof” at http://hpaste.org/85404
07:14:47 <thirsteh> although, I suppose a linked list might be faster when I'm just splitting it up anyway
07:15:10 <hiptobecubic> well you can also do it yourself if it's this specialized
07:15:21 <thirsteh> taking a text and parsing it doesn't really seem that specialized
07:15:48 <hiptobecubic> split at :, drop two and split at /, then hope you don't get any weird input
07:16:01 * Nimatek caught a whiff of premature optimization there
07:16:01 <Kinnison> If only url parsing was that simple :-)
07:16:24 <thirsteh> Nimatek: I wish. This is very mature. I am directly constrained by the speed of this
07:16:48 <thirsteh> and I already have the URL as Text
07:17:15 <beaky> hello
07:17:22 <hiptobecubic> Hello
07:17:59 <Kinnison> take the source to network.uri and port it to Text
07:18:03 <Kinnison> it's BSD(ish) licenced
07:18:26 <thirsteh> k
07:18:39 <dmwit> hseg: Aha, we're missing something.
07:18:53 <dmwit> hseg: Namely, we're missing the axioms that say we're coherent with the functor's fmap.
07:19:26 <hseg> i.e. fmap f . fmap g = fmap $ f . g
07:19:27 <hseg> ?
07:19:44 <dmwit> No, the analog of the law m >>= return . f = fmap f
07:19:50 <dmwit> = fmap f m, I mean
07:22:12 <beaky> can you do functional programming in an eager language?
07:22:14 <hseg> OK. Are you saying it's missing as an assumption or as a law to be proven?
07:22:19 <ab9rf> beaky: sure
07:22:31 <hseg> beaky: Definitely. Why wouldn't you?
07:22:41 <beaky> ha
07:22:42 <beaky> ah*
07:22:43 <klrr> okey, so can i replace mapM with fmap?
07:22:52 <ab9rf> beaky: haskell is not universally lazy, and there are eager functional languages
07:23:26 <beaky> so non-strictness makes a language more powerful than if it were strict?
07:23:28 <ab9rf> i was looking at one the other day
07:23:37 <dmwit> hseg: It's missing as an assumption. It may not be helpful here, but I think there's another thing missing connecting (>=>) and (.) that will be helpful.
07:23:44 <hseg> klrr: No. liftM = fmap. mapM is something entirely different
07:23:46 <ab9rf> non-strictness is a tool.
07:23:56 <beaky> ah
07:23:56 <klrr> hseg: so what's mapM?
07:24:04 <ab9rf> virtually all computer languages are of equal power
07:24:28 * hackagebot eq 3.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-3.1 (EdwardKmett)
07:24:30 * hackagebot syb-extras 0.2.4.1 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.4.1 (EdwardKmett)
07:24:43 <hseg> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:mapM
07:25:04 <ab9rf> the differences are in how easily, or not, expressing particular concepts, algorithms, etc. are
07:25:14 <hseg> It basically fmaps the function, then binds everything together.
07:25:15 <beaky> haskell is one of the most elegant programming languages I've ever used :D
07:25:25 <klrr> beaky: no shit
07:25:29 <hpaste> quchen pasted “mapM/sequence written out” at http://hpaste.org/85406
07:25:29 <klrr> it's AWESOME ! :D
07:25:49 <quchen> Have a look at the above paste, klrr.
07:25:58 <klrr> quchen: will do
07:26:17 <quchen> klrr: You'll want to understand sequence; mapM is a trivial step from there.
07:26:27 <ab9rf> beaky: i've used many elegant languages. :)
07:26:43 <beaky> ah
07:28:01 <hpaste> hseg revised “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>”: “Added fmap laws” at http://hpaste.org/85404
07:28:35 <hpaste> hseg revised “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>”: “Fixed precedence” at http://hpaste.org/85404
07:28:46 <dmwit> hseg: Well, I can't see a useful way to use the fmap law. Anyhow, it seems to me that a law which on the (>=>) only allows "id" as an argument is going to be awfully hard to use.
07:29:29 * hackagebot bed-and-breakfast 0.1 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.1 (JulianFleischer)
07:29:32 <hseg> Right. As you said, it's the unit of the wrong category for the proof.
07:30:00 <hseg> But I don't see how to prove this otherwise, and I know this has already been proven.
07:30:04 <dmwit> hseg: How would you feel about the following law instead:
07:30:40 <dmwit> uh, one more sec
07:31:00 <hpaste> hseg revised “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>”: “Noted usages of lemma” at http://hpaste.org/85404
07:31:12 <dmwit> hseg: \x -> (f x >>=) === flip (f >=>)
07:31:34 <dmwit> hseg: This is clearly a generalization of your (>>=) law, and is sufficient (I believe) to prove everything without the (f >=> g) law.
07:32:45 <hseg> It looks alright.
07:33:11 <hseg> I'll try proving the lemma using that generalization, and see how far I can get/
07:33:12 <Cale> "Error: Monad law, right identity" hehe
07:33:54 <dmwit> hseg: Actually, that rewrites to (>>=) . f = flip (f >=>), which is exactly the form of your lemma if you squint. =)
07:34:58 <dmwit> Anyway, yeah, I feel mildly convinced that the law (>>=) . f = flip (f >=>) can't be derived from (>>=) = flip (id >=>)
07:35:36 <dmwit> (even allowing yourself to use the monad laws for (>=>) and return)
07:36:02 <ab9rf> is squinting at a formula a valid proof step?
07:36:08 <merijn> ab9rf: Yes
07:36:09 <Cale> haha
07:36:26 <dmwit> Depends how much you've practiced squinting. =D
07:36:28 <merijn> @quote inverses
07:36:29 <lambdabot> PhilipWadler says: To see that "in" and "out" are inverses, stare at the following diagram
07:36:46 <ab9rf> that explains why so many of my math professors seemed to be squinting all the time
07:37:06 <ab9rf> that or they just needed new glasses
07:38:09 <t7> @hoogle (a -> Maybe b) -> [a] -> ([a], [b])
07:38:10 <lambdabot> No results found
07:38:20 <t7> @hoogle (a -> Either a b) -> [a] -> ([a], [b])
07:38:20 <lambdabot> No results found
07:39:23 <ab9rf> what are you looking for?
07:39:33 <Mortchek> That's basically a partition then a map, no?
07:39:49 <dmwit> :t \f -> partitionEithers . map f
07:39:50 <lambdabot> (a1 -> Either a b) -> [a1] -> ([a], [b])
07:39:59 <hseg> I would rewrite your generalization, in order to make the lemma more obvious, as: flip $ (>>=) . f = (f >=>)
07:40:24 <dmwit> I'm perfectly happy with that rewrite.
07:40:39 <dmwit> after all, flip (flip f) = f
07:41:02 <dmwit> :t (.:)
07:41:04 <lambdabot>     Not in scope: `.:'
07:41:04 <lambdabot>     Perhaps you meant one of these:
07:41:04 <lambdabot>       `.' (imported from Prelude),
07:42:26 <ab9rf> i'm not sure how to do the first one, with Maybe
07:42:53 <ab9rf> becaust the map will elide the original a's when Maybe returns Nothing
07:43:19 <ab9rf> :t catMaybes . map f
07:43:21 <lambdabot> (Show a1, FromExpr (Maybe a)) => [a1] -> [a]
07:43:31 <ab9rf> oops
07:43:35 <ab9rf> :t \f - > catMaybes . map f
07:43:36 <lambdabot> parse error on input `-'
07:43:41 <ab9rf> :t \f -> catMaybes . map f
07:43:42 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
07:43:47 <ab9rf> my spacebar is freaking out today
07:45:00 <hpaste> hseg revised “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>”: “Using dmwit's generalization of the >>= law” at http://hpaste.org/85404
07:45:04 <merijn> pfft, l2implicitparam ;)
07:45:10 <merijn> :t catMaybes . map ?f
07:45:12 <lambdabot> (?f::a1 -> Maybe a) => [a1] -> [a]
07:45:16 <hseg> I think that ought to do the trick
07:45:29 <supki> :t mapMaybe
07:45:31 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:46:00 <merijn> There's probably a lens traversal for this :p
07:46:24 <ab9rf> merijn: i don't offhand know how to generate that character :)
07:46:38 <ocharles> A lens traversal to do what?
07:46:50 <quchen> Anything.
07:46:59 <ocharles> @faq Can I use a lens for this?
07:47:00 <lambdabot> The answer is: Yes! Haskell can do that.
07:47:01 <hseg> dmwit: Would you mind having a look? This should be a complete proof that a definition of >=> that satisfies the >=> laws gives rise to a definition of >>= that satisfies the >>= laws
07:47:02 <quchen> There's also an infix operator for that.
07:47:06 <supki> @ty \f xs -> xs ^.. to f . _Just
07:47:08 <lambdabot> (t -> Maybe a) -> t -> [a]
07:47:31 <ab9rf> that's a different type
07:47:39 <supki> oh
07:47:51 <supki> @ty \f xs -> xs ^.. folded . to f . _Just
07:47:52 <lambdabot> Foldable f => (a1 -> Maybe a) -> f a1 -> [a]
07:48:02 <ab9rf> heh
07:54:41 <parcs> @check True
07:54:43 <lambdabot>   Not in scope: `myquickcheck'
07:58:48 <hseg> Thanks guys.
07:59:02 <hseg> I need to return the laptop I'm working on, though. See you!
07:59:12 <klrr> i get this wacky error "Scheme.hs:6:26: Module `System.IO' does not export `│Prelude System.IO> :t pro
07:59:41 <hiptobecubic> wacky indeed
08:00:04 <typoclass> klrr: could you put Scheme.hs on hpaste.org?
08:00:08 <klrr> i get this wacky error "Scheme.hs:6:26: Module `System.IO' does not export `try'" when i have this in my imports http://hpaste.org/85411
08:00:22 <klrr> sry X11 sucks a lot when it comes to copy pasting
08:03:07 <quchen> klrr: You're hiding a function from a module that doesn't export that function, namely System.IO.try.
08:03:10 <Botje> klrr: then don't hide it if it doesn't exist anyway :)
08:04:42 <typoclass> klrr: there's been some recent changes regarding exceptions, so if you're working from a book, it'll likely look in the wrong places for "catch" and "try" and that stuff
08:09:43 <klrr> okey thanks!
08:10:12 <merijn> klrr: Specifically, (almost?) all exception stuff has been moved to Control.Exception and isn't exported elsewhere
08:10:16 <hiptobecubic> has rwh online been updated?
08:10:24 <Cale> Lemma quchen : forall a b c : Type, forall f : (b -> m c), forall g : (a -> m b),
08:10:25 <Cale>    compose a (m b) (m c) (kleisli (m b) b c f (identity (m b))) g
08:10:25 <Cale>      = kleisli a b c f g.
08:10:25 <Cale> intuition.
08:10:30 <Cale> Proof completed.
08:10:47 <Cale> lol
08:11:06 <hiptobecubic> Proof by intimidation?
08:11:58 <Cale> intuition is a Coq tactic
08:12:27 <hiptobecubic> inuimidation
08:14:46 <quchen> Cale: Thank you. I finally have a Lemma named after me.
08:16:16 <ab9rf> i have a fallacy named afer me
08:20:34 <dmwit> ?tell hseg I annotated http://hpaste.org/85404 with the smallest axiom set that seems to work, along with minimized proofs that use the axioms where appropriate but transparently fold and unfold definitions of (.), ($), flip, id, and the like.
08:20:34 <lambdabot> Consider it noted.
08:26:58 <ab9rf> snerk
08:27:03 <ab9rf> feh
08:29:38 <ludamad> is there an explicit way to destroy a http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/Control-Concurrent-Chan.html ?
08:30:05 <Taneb> Do you need to?
08:30:25 <ludamad> Not necessarily, but I figured it'd be more efficient
08:30:40 <ludamad> depending on the implementation
08:36:00 <Michae___> What does IDLE mean, as a cost center in profiling?
08:43:24 <ab9rf> Michae___: number of ticks in which a capability was idle, i am fairly certain
08:45:06 <merijn> Michae___: Presumably means "no thread to run, because everything was blocked"
08:45:16 <Michae___> Okay, thank you
08:45:58 <Cale> ludamad: Just by losing all references to it somehow.
08:47:50 <narens> lens question: is there an easier way to write this? (1,2) & _1 <%~ (+3) & \(i,v) -> v & _2 %~ (+i) == (4,6)
08:48:11 <narens> the thing I don't like is the \(i,v) bit
08:48:22 <hiptobecubic> narens, haskell-lens is all about this i believe
08:48:40 <Michae___> Is anyone familiar with the Gloss Graphics library?
08:48:55 <edwardk> narens: sure
08:49:20 <narens> edwardk: how so?
08:50:06 <edwardk> something like: (1,2) & _1 <+~ 3 & _2._2 +~ i == (4,6)
08:50:23 <edwardk> i i probably missed an _2 selection at the end
08:50:36 <luite> hm where does the +i come from there?
08:50:40 <luite> the i
08:50:57 <edwardk> oh, hrmm
08:51:06 <edwardk> i just realized that i was the result of the previous computation
08:51:21 <edwardk> messy =)
08:51:38 <edwardk> probably nicer in State
08:52:41 <narens> edwardk: haha, yea. Also, how can i eta reduce if I were to put that in a function? eg: let f x = x & _1 <%~ (+3) & \(i,v) -> v & _2 %~ (+i)
08:54:20 <kurkale6ka> newtype Pair b a = Pair { getPair :: (a,b) } What means that the second type parameter represents the type of the first component in the tuple?
08:55:42 <danr> kurkale6ka: constructions like these are mainly to declare instances for classes, like this Pair you have, you can make a Functor instance which looks at the first component of the pair (unlike what instance Functor (a,) where ... does)
08:55:53 <Philonous> narens:  is \(i,v) -> v not just snd ?
08:56:03 <hiptobecubic> Philonous, yes.
08:57:50 <Philonous> All those cryptic infix operators make it hard to read
08:58:31 <narens> Philonous: yea, its an overkill for that example just because there is intermediate value storage... I was just trying out things
08:58:38 <luite> Philonous: the i is used again later
09:00:18 <kurkale6ka> danr: ok, will have to investigate further
09:01:46 <danr> kurkale6ka: in which context did you read this?
09:02:06 <kurkale6ka> danr: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
09:02:17 <ab9rf> what's wrong with cryptic infix operators?  didn't you grow up using APL?
09:02:51 <danr> kurkale6ka: right, so he does an instance for Functor (Pair c) there. How is that instance different from a Functor (,) c instance?
09:03:17 <Philonous> ab9rf:  I'm afraid not.
09:04:09 <kurkale6ka> danr: well, seems like the Applicative ust take one argument only
09:12:38 <Shin-LaC> LYAH has you make a binary tree type, with operations that preserve ordering; but then it implements fmap by simply applying f to each node, which can obviously break ordering
09:13:20 <Nisstyre-laptop> Shin-LaC: well, you can still preserve the order if you're careful
09:13:43 <Philonous> Nisstyre-laptop:  How so?
09:14:08 <Nisstyre-laptop> Philonous: by re-ordering it after applying an fmap that makes it not ordered
09:14:09 <Shin-LaC> if you only use monotonically increasing functions, I guess
09:14:15 <Nisstyre-laptop> that too
09:14:39 <Philonous> Nisstyre-laptop:  I think the given algorithms doesn't do that.
09:14:42 <Shin-LaC> Nisstyre: I think it's inappropriate to have an fmap that produces a broken tree
09:14:53 <Philonous> That's an unreasonable restriction
09:14:56 <Shin-LaC> it should be defined in such a way as to preserve ordering
09:14:57 <Nisstyre-laptop> Shin-LaC: well, maybe you should ask the author why he did it that way
09:15:02 <Nisstyre-laptop> I haven't read that part of the book
09:15:07 <Shin-LaC> where is the author?
09:15:13 <Nisstyre-laptop> dunno
09:15:23 <Shin-LaC> author, show yourself
09:15:24 <Nisstyre-laptop> isn't there an email address or something?
09:15:50 <Philonous> Shin-LaC:  Mind sharing the URL?
09:16:15 <Shin-LaC> Philonous: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
09:16:23 <Philonous> Thanks
09:17:11 <Shin-LaC> np
09:17:25 <Nisstyre-laptop> Shin-LaC: I don't think a functor has to preserve any kind of order anyway
09:17:55 <merijn> Nisstyre-laptop: It does, else it breaks the functor law
09:18:05 <Nisstyre-laptop> merijn: howso?
09:18:14 <merijn> x == fmap id x
09:18:30 <merijn> So, if the data structure has an order, fmap should preserve it
09:18:33 <linduxed> merijn: i ended up reworking the code https://gist.github.com/5338086
09:18:37 <linduxed> merijn: thx for the help
09:18:42 <linduxed> Botje: thx for the help before
09:18:42 <Nisstyre-laptop> merijn: not sure how that follows
09:18:50 <Nisstyre-laptop> I'm not saying you're wrong
09:19:00 <Philonous> Shin-LaC:  Seems to be an oversight in the book.
09:19:26 <merijn> Nisstyre-laptop: If fmap doesn't preserve order, than "fmap id x" is not necessarily equal to "x", since the fmap might have reordered
09:19:27 <Philonous> Nisstyre-laptop:  The functor doesn't but being ordered was an invariant of the type
09:19:30 <Nisstyre-laptop> merijn: when you say "order" do you mean that it's an ordered set?
09:19:31 <Shin-LaC> merijn: it's not the functor law that gets broken in this case
09:19:42 <Shin-LaC> it's the binary search tree invariant
09:20:26 <merijn> linduxed: You could try to clean it up using the list monad
09:20:36 <Shin-LaC> Nisstyre-laptop: the type in this case is a binary tree where it is guaranteed that left < x < right, at each node
09:20:39 <merijn> linduxed: I think, I'm not sure if it'll improve readability
09:20:52 <merijn> Shin-LaC: Oh, that
09:21:07 <merijn> Shin-LaC: Binary search trees aren't functors
09:21:08 <Nisstyre-laptop> Shin-LaC: you could give it a different ordering though, surely?
09:21:20 <linduxed> merijn: wouldn't really know how, i think
09:21:52 <Shin-LaC> merijn: yet LYAH makes them an instance of Functor
09:21:53 <Shin-LaC> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
09:21:54 <merijn> linduxed: x >>= f is equal to "concatMap f x"
09:21:55 <Shin-LaC> that's my complaint
09:22:02 <Nisstyre-laptop> Shin-LaC: it depends on how < is defined
09:22:18 <Nisstyre-laptop> that's what I'm saying
09:22:39 <Shin-LaC> Nisstyre-laptop: I'm not sure how that's relevant
09:23:06 <Nisstyre-laptop> Shin-LaC: it is, since you can create your own instances of Ord
09:23:26 <Shin-LaC> but that's not what was done here
09:23:46 <Nisstyre-laptop> fair enough, I guess you were ordering numbers
09:23:46 <merijn> Shin-LaC: It's not a 100% true functor, ok, to bad.
09:23:50 <linduxed> merijn: i haven't gotten to >>= in my haskell journey, so i have no idea what you're talking about
09:23:58 <Shin-LaC> basically, I'm saying that http://learnyouahaskell.com/making-our-own-types-and-typeclasses uses functors wrong
09:24:06 <Shin-LaC> s/uses/teaches/
09:24:16 <merijn> linduxed: Ah...in that case nevermind, it'll probably be needlessly confusing then :)
09:24:32 <linduxed> merijn: all i know is that comes from monads and that i'll get to that soon
09:24:48 <Nisstyre-laptop> merijn: I think you misunderstood the problem btw
09:25:01 <Nisstyre-laptop> it wasn't that fmap potentially screwed with the order as in the positions of each node
09:25:06 <ski_> Shin-LaC : does LYAH intend the BST property to be an invariant of the `Tree' type, or just included in the pre- and post-conditions of the functions they define on it ?
09:25:08 <Nisstyre-laptop> it was that it was applying the function to every node
09:25:16 <merijn> Nisstyre-laptop: Yeah, I got it that too, now
09:25:18 <Nisstyre-laptop> and so he was saying that it could result in a tree that was no longer "ordered"
09:25:21 * ski_ . o O ( `reorder :: Ord a => CoYoneda BST a -> BST a')
09:25:50 <merijn> linduxed: Yeah, just keep going, you could try to use this as a neat example when you get that far
09:25:51 <Nisstyre-laptop> but I was saying that really depends on how the Ord instance is defined
09:26:15 <Shin-LaC> ski_: it's hard to tell, since LYAH's style is not at all rigorous
09:26:41 <ski_> Shin-LaC : i suspect it's the latter -- in which case there is no problem (afaiu)
09:26:59 <ski_> (except maybe they not being clear enough about this)
09:27:08 <merijn> Nisstyre-laptop: It boils down to BST can't be a functor since we have no way to enforce the relevant constraints on the fmap/functor typeclass
09:27:09 <Shin-LaC> ski_: the structure is introduced as: "Now, we're going to implement a binary search tree."
09:27:22 <Shin-LaC> so it's the former
09:27:22 <quchen> If the tree was a "good" functor, fmap wouldn't mess up the tree for all instances of Ord. However, I think it's a valid Functor instance. It just makes the rest of the API inconsistent.
09:27:27 <merijn> i.e. BST is only a functor for functions that maintain ordering
09:27:38 <quchen> I wouldn't say it's wrong in terms of Functors, it's just a poor example of one.
09:27:51 <Nisstyre-laptop> merijn: so in a dependently typed language it could be enforced?
09:27:53 <Shin-LaC> it's not just a generic tree that you can use as a BST
09:27:56 <merijn> Nisstyre-laptop: Maybe?
09:27:57 <Shin-LaC> it's supposed to *be* a BST
09:27:58 <Philonous> quchen:  It's wrong since it breaks the types invariant
09:28:16 <quchen> Philonous: The type's invariant?
09:28:25 <merijn> Nisstyre-laptop: A similar problem would be the Functor-ness of Set (Set is only a Functor for functions whose results are Ord)
09:28:53 <quchen> "fmap for that tree obeys the Functor laws, therefore it's a Functor."
09:29:09 <merijn> quchen: Yes, but it doesn't obey the BST laws
09:29:24 <Philonous> quchen:  It doesn't result in valid BSTs . Like
09:29:26 <Philonous> -like
09:29:32 <quchen> That's true.
09:29:41 <ski_> Shin-LaC : yeah, `Tree' might be used as the *representation* type for something like `Data.Set' -- note the "representation" is key here; the invariant isn't then (at least conceptually) attached to the `Tree' type itself, but only to the `Data.Set.Set' type (as conceptually constructed as a quotient/factor type of the former)
09:29:48 <quchen> Oh, he claims it is a BST. Nevermind then.
09:30:30 <quchen> I thought he just uses a "Tree" that has searching functions that assume it's a BST, and then defines Functor for a tree of the same data type, which is not necessarily a BST.
09:31:36 * ski_ wishes Haskell would make a clearer separation between an abstract type, and a representation type, like in Mercury <http://web.archive.org/web/20130102213246/http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html>
09:32:43 <ski_> (doing this would make it easier to not confuse oneself when reasoning about quotient ior sub- types)
09:33:25 <Shin-LaC> quchen: yes, the choice of simply "Tree" as a name is another poor one perhaps. but all the discussion makes it clear that it's meant to be a BSTreee
09:33:33 <ski_> Shin-LaC : .. anyway, for a `BST' type, it would be possibly to use `fmap' on `CoYoneda BST' instead, and reorder when going back to `BST'
09:33:44 <Shin-LaC> what's CoYoneda?
09:33:45 <ski_> .. i wonder whether it's possible to do anything smarter here ?
09:33:49 <ExternalReality> > :t map
09:33:51 <lambdabot>   <hint>:1:1: parse error on input `:'
09:33:57 <ski_> Shin-LaC : `CoYoneda BST b = exists a. (BST a,a -> b)'
09:34:15 <ski_> Shin-LaC : it's basically a delayed `fmap'
09:34:43 <ski_> `CoYoneda f' is always a functor, regardless of whether `f' is or isn't
09:34:56 <quchen> ski_: instance (Continuous (a->b), Surjective (a->b)) => Functor (Tree a) where ...
09:34:59 <quchen> ;-)
09:35:09 <ski_> (and `BST' isn't a functor, per the discussion above)
09:35:21 <linduxed> merijn: oh and btw
09:35:36 <ski_> quchen : elaborate on what you mean ?
09:35:40 <linduxed> while the code is theoretically correct
09:35:52 <linduxed> it works for smaller grids
09:35:57 <linduxed> make it 20x20
09:36:01 <linduxed> shit takes forever
09:36:35 <quchen> ski_: I just meant that if you could constrain the functions given to fmap to be order-preserving you could make a functor-y instance.
09:36:35 <LilGreenGhouls> Hey guys, complete beginner. I've got a question about ghci behaviour if anyone has the time. Why am I able to write: 'let rec = \x -> x :: Num a => a -> a'.. but if I am to replace the 'Num' with 'Enum' I get an error?
09:36:49 <quchen> ski_: No answer needed, I know it was silly. :-P
09:37:13 <LilGreenGhouls> meaning I can't do stuff like let test = succ.. which seems weird to me
09:37:27 <otters> LilGreenGhouls: what is the error
09:38:06 <LilGreenGhouls> "Ambigious type variable `a0' in the constraint<interactive>:251:14:
09:38:06 <LilGreenGhouls>     Ambiguous type variable `a0' in the constraint:
09:38:06 <LilGreenGhouls>       (Enum a0) arising from an expression type signature
09:38:06 <LilGreenGhouls>     Probable fix: add a type signature that fixes these type variable(s)
09:38:06 <LilGreenGhouls>     In the expression: (\ x -> x) :: Enum a => a -> a
09:38:08 <LilGreenGhouls>     In an equation for `redfdf':
09:38:10 <LilGreenGhouls>         redfdf = (\ x -> x) :: Enum a => a -> a
09:38:13 <LilGreenGhouls> Prelude Data.Char>
09:38:48 <ski_> Shin-LaC : iow, we have `data CoYoneda f b = forall a. FmapIncl (a -> b) (f a)' (an "existential data type") and then `instance Functor (CoYoneda f) where fmap bc (FmapIncl ab fa) = FmapIncl (bc . ab) fa', `incl :: f a -> CoYoneda f a; incl fa = FmapIncl id fa' and `proj :: Functor f => CoYoneda f a -> f a; proj (FmapIncl ab fa) = fmap ab fa'
09:39:12 <ski_> Shin-LaC : note the absence of `Functor f' in the instance declaration, and the presence of it in `proj'
09:39:12 <Eduard_Munteanu> Monomorphism restriction, I guess.
09:40:02 <LilGreenGhouls> thanks Eduard_Munteanu. Will read about it
09:40:27 <ski_> Shin-LaC : apart from being able to `fmap' over things that are not functors (`IORef' is another example), `CoYoneda' is useful to delay the actual traversal, so that you only traverse once, instead of many times (though sometimes optimizations will do this anyway)
09:40:47 <ski_> quchen : i don't follow
09:41:18 <Nisstyre-laptop> LilGreenGhouls: http://ideone.com/JxJsUc
09:41:19 <Eduard_Munteanu> LilGreenGhouls: you need to give the function a type signature, that's only providing one for the rhs.
09:41:32 <Shin-LaC> ski_: I wish things were named after what they do, like in programming, and not after who published a paper about them, like in math
09:41:43 <ab9rf> Shin-LaC: hehe
09:42:00 <ab9rf> Shin-LaC: sometimes it's hard to come up with a name for what thigns do
09:42:04 <ab9rf> currying, for example
09:42:08 <ski_> quchen : oh, i see (though i don't get the "surjective" part)
09:42:21 <Nisstyre-laptop> alternatively, "let f = id" works
09:42:55 <quchen> ski_: Also that part is wrong ;(
09:43:11 <LilGreenGhouls> cheers again guys :D
09:43:28 <Nisstyre-laptop> ski_: so does it let you delay multiple traversals?
09:43:45 <ski_> (btw "order-preserving" is just `Monotone', no ? `Continuous' is more i think)
09:43:46 <Nisstyre-laptop> (of the same data structure)
09:44:04 <ski_> Nisstyre-laptop : yes, but all of the traversals must of course be `fmap's
09:44:08 <Nisstyre-laptop> yeah
09:44:09 <Nisstyre-laptop> neat
09:44:10 <quchen> ski_: Yes.
09:44:38 <quchen> ski_: The right thing would've been "monotonely increasing" anyway.
09:44:52 <ski_> Nisstyre-laptop : `fmap' on `CoYoneda f' just composes together the functions to be mapped, it's `proj' that actually `fmap's their composition on the underlying `f'
09:45:04 <Nisstyre-laptop> okay
09:45:15 <ski_> often "monotone" is a synonym of "(monotonely) increasing"
09:46:13 <quchen> Haven't heard of that.
09:46:44 <ski_> in such cases, "(monotonely) decreasing" is known as "antitone"
09:47:14 <ski_> Nisstyre-laptop : it's a bit similar to how `(>>=)' in (`Cont o' and) `CoDensity m' "right-associates"
09:47:23 <quchen> Haven't read or heard about that in neither math nor physics so far
09:49:00 <ski_> quchen : <http://en.wikipedia.org/wiki/Monotonic_function#Monotonicity_in_order_theory>
09:51:18 <quchen> ski_: Thanks. "Order theory", hmm. Never heard of that.
09:54:30 <hpaste> Cale annotated “Proof that the monad laws in terms of >>= are expressible given the monad laws in terms of >=>” with “Basically unreadable Coq formalisation (different proofs of same results)” at http://hpaste.org/85404#a85415
09:55:36 <ski_> quchen : also see <http://en.wikipedia.org/wiki/Galois_connection> and <http://en.wikipedia.org/wiki/Adjunction#Posets>
09:56:22 <ski_> quchen : also, <http://en.wikipedia.org/wiki/Complete_partial_order> crops up in denotational semantics of programming languages (cf. `_|_' for talking about the "value" of a non-returning expression in Haskell)
09:58:27 <ski_> Cale : is the OP of that on IRC ?
09:58:34 <Cale> OP?
09:58:55 <ski_> Original Poster
09:59:07 <Cale> I just posted that
09:59:26 <Cale> (I also wrote it)
09:59:42 <ski_> you pasted the original <http://hpaste.org/revision/85404> ?
09:59:50 <Cale> oh
09:59:54 <Cale> not that one
10:00:12 <Cale> looks like hseg did, I guess he's gone
10:02:40 <ski_> ok
10:05:13 <linduxed> merijn: lol
10:05:55 <linduxed> merijn: figured out something, the amount of of paths is represented by a pascal triangle
10:06:01 <linduxed> hahaha
10:13:20 * ski_ . o O ( <http://en.wikipedia.org/wiki/Catalan_number> )
10:20:00 <jquinn> How do I make a standalone windows executable with ghc?
10:21:27 <c_wraith> jquinn: that's the default when you compile with ghc on windows, unless you've somewhere set dynamic linking as the default
10:22:00 <ab9rf> the default should yield an executable that depends only on standard windows libraries
10:22:20 <jquinn> c_wraith: Thank you, also a beginner question, what's the syntax for running the executable
10:22:37 <ab9rf> jquinn: program.exe
10:22:45 <c_wraith> for modern versions of ghc, the simplest version is ghc WhateverYourMainIs.hs
10:22:47 <ab9rf> or just program
10:22:58 <ab9rf> once you've compiled it, that is
10:23:03 <c_wraith> for older versions of ghc, you also needed a --make argument, but that was years ago now
10:45:13 <oio> could someone compile this on windows (works fine on mac)? it exits unexpectedly
10:45:35 <hpaste> oio pasted “exits ” at http://hpaste.org/85416
10:59:38 * hackagebot continue 0.1.0 - Control  http://hackage.haskell.org/package/continue-0.1.0 (ErtugrulSoeylemez)
10:59:40 * hackagebot continue 0.1.1 - Continuation-based user interaction monad  http://hackage.haskell.org/package/continue-0.1.1 (ErtugrulSoeylemez)
11:05:10 <Philonous> Sometimes I wish records had default values.
11:05:39 <mm_freak> defRecord :: Record
11:06:41 <glguy> defRecord { thatOneField = nonDefaultValue }
11:06:41 <simpson> I *do* wish that it were easier to create large chunks of state which will power MonadState stacks.
11:07:16 <mm_freak> simpson: what do you mean?
11:08:02 <simpson> mm_freak: Let's say that my stack has a bunch of things that I can only get from IO, like, uh, GL references.
11:08:11 <ab9rf> Philonous: they don't?
11:08:19 <Philonous> mm_freak:  Yeah, that solves the problem in practice, but you have to go and change every occurrence of the constructor with the default value
11:08:47 <simpson> Now, I do intend to execute the whole shebang in StateT IO or so, but I have to have an extra weird thing to set up my state initially, even though I'm probably gonna very quickly replace what I've got in my state with newer things.
11:09:01 <ab9rf> Philonous: so just plan for that from the start, then you don't have to change anything :)
11:09:19 <simpson> I can promise in a comment that "undefined" isn't gonna hurt for an initial value, but I can't convince Haskell that that is safe.
11:10:05 <merijn> Out of curiosity, is there anything like a declarative UI library for haskell?
11:11:12 <Philonous> mm_freak:  Also, it's weird to have a default value that has undefineds in it.
11:11:30 <merijn> I've been playing with vty-ui for terminal stuff, but it's very operational. It's all IO actions having effects, which makes circular references between UI components rather inconvenient to work with...
11:12:13 <merijn> And I think all the usual GUI libraries have the same type of issues
11:12:16 <ab9rf> merijn: the bindings to curses and gtk have at least some concept of interface objects
11:12:20 <ab9rf> merijn: but mostly it's effects
11:13:05 <ab9rf> merijn: what are you looking for?
11:13:22 <Eduard_Munteanu> I guess FRP toolkits might be more like that.
11:13:23 <ab9rf> merijn: nobody has ever formulated a coherent functional way to do UIs, as far as i know
11:13:26 <merijn> ab9rf: Yeah, but having interface objects means you have to do this elaborate dance of instantiating things in the right order and then updating to have everything refer to the right things
11:13:28 <ryant5000> merijn: have you looked at Conal's research in that direction? fran, etc.?
11:13:41 <merijn> ryant5000: I've looked into FRP yeah, but not yet for UIs
11:13:57 <ab9rf> last i heard that was still an area with active ongoing research
11:14:08 <merijn> And I feel mixing two different FRP libraries in one program maybe a bit much as I'm currently using netwire for my networking/IO stuff
11:14:16 <ryant5000> merijn: not all of Conal's stuff is FRP-based
11:14:16 <merijn> ab9rf: I know, hence why I'm asking
11:14:21 <mm_freak_> simpson: perhaps what you're looking for is modular state?
11:14:36 <simpson> mm_freak_: Well, I mean, I can certainly split my objects up more and more and more.
11:14:37 <jutaro> merjin: Their is a first binding to qml. HsQML
11:14:49 <ryant5000> merijn: he also has Tangible Functional Programming
11:14:53 <simpson> mm_freak_: But the only pure total thing I can do is lots of Maybes, and I don't like that.
11:15:03 <ryant5000> merijn: http://conal.net/papers/Eros/
11:15:10 <merijn> ryant5000: I'll look into it
11:15:15 <mm_freak_> Philonous: if some fields don't have reasonable defaults, use smart constructors
11:15:21 <mm_freak_> defRecord :: Int -> Record
11:15:29 <merijn> jutaro: qml looks like exactly the kind of stuff I don't want
11:15:38 <mm_freak_> simpson: no, there is another way, but that other way is not a monad (it's an arrow) =)
11:15:58 <simpson> mm_freak_: Ha, sure.
11:16:19 <jutaro> merjin: I'm evaluating it, it has not yet native events for Haskell, as far as I understand
11:16:37 <Philonous> mm_freak_:  But I'm using records to avoid positional arguments
11:16:53 <ab9rf> Philonous: that's just syntax sugar anyhow
11:16:56 <mm_freak_> Philonous: defRecord :: MissingFields -> Record
11:17:04 <jutaro> But it seems to me such a fight with this gtk... librarries and qml would present a much thinner and cleaner interface
11:17:23 <Philonous> mm_freak_:  Then I have to sets of names to initiate the same field
11:17:36 <Philonous> two*
11:17:54 <mm_freak_> Philonous: that's the only real problem i see there, and it's really code beauty problem, not something fundamental =)
11:17:58 <merijn> Seems like such a waste that after 40+ years all GUI frameworks still suck
11:18:11 <jutaro> merjin: What is it about QML you dont want? Its not in Haskell?
11:18:37 <parcs> cario has a declarative xml interface
11:18:39 <mm_freak_> Philonous: however, think of a server that needs a port number and IP address to bind to
11:19:07 <mm_freak_> Philonous: data Server = Server { srvBind :: Bind };  data Bind = Bind { bindPort :: Int, bindAddress :: String }
11:19:19 <Philonous> mm_freak_:  It's not fundamental anyway. It's just about saving a few key strokes and reducing visual clutter by cutting down on boiler plate (though it reduces clarity because it's not entirely clear which fields would be initiated by default)
11:19:20 <merijn> jutaro: It's just a markup language, afaict you can't do functionality in it
11:19:29 <mm_freak_> Philonous: simpleServer :: Bind -> Server
11:19:49 <mm_freak_> access, both read and write, can be done easily using lenses
11:19:58 <mm_freak_> and for initialization you have smart constructors
11:20:14 <merijn> parcs: I don't want to just specify the interface declaratively, but also how it behaves. i.e. have their behaviour depend on each other.
11:20:20 <mm_freak_> simpson: i was serious btw…  you can use an arrow to abstract this away nicely
11:20:39 <jutaro> its not xml, and you can do functionality in it
11:20:58 <simpson> mm_freak_: Yeah, I know. Not sure if I want to go down that route, but yes.
11:21:21 <mm_freak_> simpson: if you like categorical/applicative programming, you probably want to
11:21:29 <jutaro> it has json like syntax and its not bad compared to wxwidgets, gtk, old qt, ...
11:21:39 <simpson> mm_freak_: TBH I'm really gettin' into declarative unprogramming. :3
11:21:40 <mm_freak_> i use that approach all the time, because State sucks for most things
11:21:52 <Philonous> mm_freak_:  Presumably Server has a few more fields that can be initialized with defaults.
11:22:13 <parcs> merijn: do you want a phd? because you'll probably get one if you invent such a library :P
11:22:33 <merijn> parcs: Actually, yes I do, now I just need someone who'll pay me for it
11:23:00 <merijn> parcs: Also, I realise I'll probably have to invent it myself, I was just curious about the current state-of-the-art before I reinvent the boring parts of the wheel
11:23:18 <klrr> AHAHAHHAJNSDFNJDFNMJKSDMKADŜD
11:24:22 <mm_freak> and yes, GUI frameworks suck bad…  i hope some day someone will relieve me from having to write a netwire-based toolkit =)
11:24:53 <merijn> mm_freak: Right, I'll get right on that, how much will you pay me to do it? ;)
11:25:48 <mm_freak> merijn: well, nobody payed me to write netwire in the first place, but i'm happy to return the feedback and support and probably some code =)
11:26:25 <Lethalman> mm_freak, yeah, same goes for the web, that's due to excessive mvc-foo imo
11:26:39 <merijn> mm_freak: Blah :p
11:26:44 <luite> mm_freak: would you be interested in contributing web code? :)
11:27:14 <Lethalman> I'm dreaming a web framework with alternative concepts
11:27:33 <luite> i got reactive-banana running with ghcjs, sodium should also work
11:27:39 <mm_freak> Lethalman: incidentally i just released a library for continuation-based user interfaces that allows to write web applications like command line applications =)
11:27:46 <luite> but none really developed into a gui toolkit
11:27:46 <aristid> Lethalman: maybe you should have a look at what already exists in haskell land then :)
11:27:49 <mm_freak> result <- runForm myForm
11:27:50 <mm_freak> =)
11:27:55 <mm_freak> http://hackage.haskell.org/package/continue
11:28:07 <Eelis> mm_freak: heh, i love reading the Netwire readme and having *no* clue what it's for
11:28:09 <mm_freak> @ luite, too
11:28:14 <Lethalman> aristid, what exists in haskell land is pretty much similar to other web frameworks
11:28:17 <aristid> mm_freak: ah the siren song of continuations for the web :P
11:28:36 <Lethalman> mm_freak, does it do any kind of serialization?
11:28:43 <luite> mm_freak: oh interesting, but that sounds rather not-webscale?
11:28:44 <mm_freak> Lethalman: nope
11:28:53 <aristid> Lethalman: i didn't know that statically verified routing was standard
11:28:55 <mm_freak> luite: the only problem Lethalman just mentioned
11:29:00 <luite> for the lack of concise non-buzzwords :p
11:29:13 <Lethalman> aristid, but routing is standard
11:29:36 <Lethalman> aristid, it's still the same concept, just in haskell form
11:29:54 <mm_freak> http://hpaste.org/79601
11:29:57 <aristid> Lethalman: what are you interested in, then?
11:30:09 <mm_freak> this is an old paste, where i demonstrated the idea of continuation-based user interaction
11:30:16 <luite> mm_freak: still an interesting approach for smaller scale or admin things
11:30:16 <mm_freak> note:  this is NOT continuation passing style
11:30:21 <Philonous> mm_freak:  How does netwire compare to reactive-banana?
11:30:26 <Lethalman> aristid, as said, something alternative... don't know what yet, but not the usual sold mvc
11:30:33 <aristid> mm_freak: that's the one i didn't understand, right? :P
11:31:00 <dmwit> For continuation-based web, see also WASH (which may perhaps be bitrotted by now).
11:31:25 <aristid> i think continuations are not the right approach for the web.
11:31:33 <aristid> especially not if they expire
11:31:51 <Lethalman> mm_freak, too bad I can't navigate the reference, they aren't generated yet :(
11:31:53 <mm_freak> Philonous: http://stackoverflow.com/questions/14654385
11:31:58 <aristid> you also can't share continuation links with other people, usually
11:32:26 <luite> aristid: yeah i was looking into serializable continuations for that reason, but those aren't terribly usable in ghc
11:32:31 <mm_freak> aristid: what do you mean?  i think i'm talking about five different topics at the same time =)
11:32:39 <Lethalman> aristid, agreed, but maybe you can use query strings directly as continuation information rather than the full blown state serialization, but somebody told be that's not easy :)
11:32:44 <dmwit> WASH continuations don't expire, because the data contained in them is stored in the browser not the server.
11:33:00 <mm_freak> aristid: ContinueT gives you controllable expiration
11:33:06 <Lethalman> dmwit, ah yeah, that's good
11:33:15 <aristid> mm_freak: mean with what? the "didn't understand" thing? that was just because i think you showed the paste to me before and it took a while and some explanation until i got the basic idea
11:33:31 <Lethalman> dmwit, is it WashNGO?
11:33:32 <mm_freak> aristid: as said, it's not CPS…  it's more like Cofree, but a monad version of that
11:33:33 <jfischoff> dmwit: just raised a serious issue against Data.Universe ;)
11:34:09 <aristid> mm_freak: let's say you have a website with logins. how can a user share a link with another user who has a different login?
11:34:15 <mm_freak> aristid: see the readme, perhaps that helps: https://github.com/ertes/continue
11:34:27 <jfischoff> Haskellers great and small what would be a generally useful project for the community?
11:34:47 <dmwit> Lethalman: http://www.informatik.uni-freiburg.de/~thiemann/papers/padl02.pdf
11:34:50 <dmwit> jfischoff: taking a look
11:34:59 <mm_freak> aristid: say you have a ComeHere in your web-routes type…  then in your ContinueT-based web app you would write:  link ComeHere
11:35:13 <jfischoff> dmwit: it deserves your immediate attention ;)
11:35:15 <mm_freak> aristid: then anyone who visits the ComeHere resources would "resume" at that exact spot
11:35:24 <dmwit> jfischoff: hum
11:35:44 <dmwit> jfischoff: I'd be willing to add a module that exports both, but not (I think) to do the exact thing you suggest.
11:35:59 <aristid> mm_freak: the "link ComeHere" would incorporate the login info, no?
11:36:02 <dmwit> Unless I can be convinced that everything that wants to use universe also wants a dumbed-down version of LogicT...?
11:36:13 <mm_freak> aristid: you could even put it in the middle of a handler, where some database requests have already been made…  no need for a cache…  just re-enter the computation at the right place and haskell's sharing and GC takes care of the rest =)
11:36:22 <jfischoff> dmwit: I just want universeDef
11:36:34 <dmwit> ah yes
11:36:40 <Sculptor> gm
11:36:48 <dmwit> I think we could easily export universeDef.
11:36:54 <jfischoff> dmwit: maybe it can be a default for the class ala default instances?
11:36:58 <mm_freak> aristid: not necessarily…  depends on how you store your sessions…  presumable you would have some database/directory for sessions, so authenticated actions would be disallowed
11:37:06 <dmwit> jfischoff: I don't think so; it has constraints.
11:37:08 <mm_freak> presumably
11:37:12 <dmwit> wait
11:37:15 <dmwit> What are default instances?
11:37:16 <merijn> jfischoff: Contributing to Peaker's structural editor/version control thing :p
11:37:22 <jfischoff> err default signatures
11:37:33 <aristid> mm_freak: why disallow when you could check them against the auth of the user who tries to run them?
11:37:40 <jfischoff> merijn: I would like to actually
11:37:49 <mm_freak> aristid: sure, you could do that
11:38:10 <mm_freak> aristid: there is nothing wrong with session switching, as long as you don't assume that the session is the same after you set a reentry point
11:38:12 <Lethalman> mm_freak, aristid, unless there's some kind of dependency tracking, that sorts out what's needed to display a page... maybe that's the alternative thing I'm looking at :P
11:38:20 <jfischoff> I have been meaning ask him if he has any use for GPU accelerated fonts.
11:38:46 <dmwit> jfischoff: I don't see either of those on http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html ?
11:38:51 <aristid> jfischoff: he uses opengl anyways i think
11:38:58 <Lethalman> for example
11:39:11 <mm_freak> aristid: i'm still working on the library and i might put a WAI-based example online today
11:39:20 <Lethalman> what about recreating the dom tree when something change, rather than modifying the dom directly with JS actions?
11:39:21 <jfischoff> dmwit: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/generic-programming.html
11:39:28 <luite> is Peaker still working on that? I haven't seen any updates recently
11:39:32 <Lethalman> that would be a pure action
11:39:34 <aristid> mm_freak: i think continuations or your stuff might be helpful in non-web contexts as well tho
11:39:41 <jfischoff> dmwit: err better http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/type-class-extensions.html#class-default-signatures
11:39:50 <dmwit> I see. How old is it?
11:40:03 <aristid> mm_freak: consider an existing event-based c++ application with lots of state in various classes
11:40:23 <mm_freak> aristid: definitely…  think of a command line calculator where at some points you say, "x = 15", then you notice that x = 15 was a bad choice and you reenter with x = 17 and see all your previous work with x = 17 =)
11:40:31 <jfischoff> dmwit: since 7.4 I think
11:40:53 <Lethalman> so what about my idea? :S
11:40:55 <mm_freak> aristid: that's basically what the hpaste above demonstrates
11:41:02 <dmwit> Will you be happy with not exporting universeDef but adding a default signature if GHC>=7.4?
11:41:03 <HugoDaniel> hi
11:41:06 <merijn> luite: He was last I checked
11:41:13 <jfischoff> dmwit: yes
11:41:13 <aristid> mm_freak: or for another randomly chosen toy example, an automatic trading application.
11:41:20 <dmwit> I see.
11:41:30 <Lethalman> on change -> recompute the whole page theoretically as a pure action instead of modifying the dom with JS actions... would that be possible somehow?
11:41:35 <dmwit> That's not to say I've decided against exporting universeDef, just checking what you think is good. =)
11:41:42 <jfischoff> dmwit: I think that is my main use case
11:41:51 <dmwit> right
11:42:09 <mm_freak> aristid: yeah…  many examples come to mind…  ContinueT basically solves some of my problems that netwire couldn't solve =)
11:42:17 <mm_freak> it's orthogonal to netwire in a sense
11:42:24 <jfischoff> instance Universe BoundedEnumThing
11:42:30 <dmwit> So it's no more annoying than the current situation if you want to support old GHCs, and it is less annoying if you're okay with banning GHC <7.4.
11:42:35 <dmwit> I think that's a nice tradeoff, so I'll do it.
11:43:09 <mm_freak> aristid: in fact Wire and ContinueT are very similar…  compare the types
11:43:23 <jfischoff> dmwit: you can wrap it #ifdef to support both
11:43:26 <mm_freak> newtype Wire e m a b = Wire (a -> m (Either e b, Wire e m a b))
11:43:42 <dmwit> jfischoff: No you can't.
11:43:46 <aristid> mm_freak: they are not compatible though?
11:43:48 <mm_freak> newtype ContinueT e f m a = ContinueT (m (Either e a, f (ContinueT e f m a)))
11:43:49 <badkins> Starting with: nAnd x y = not ((&&) x y) I was able to obtain the curried version: nAnd x = not . ((&&) x)  but I'm having trouble going one step further to get rid of x
11:43:49 <dmwit> jfischoff: But what I want can be done anyway.
11:44:02 <dmwit> jfischoff: (Because you can't enable CPP before you choose which extensions to use.)
11:44:03 <mm_freak> aristid: they do different things
11:44:10 <elliott> @pl \x -> not . ((&&) x)
11:44:10 <lambdabot> (not .) . (&&)
11:44:23 <elliott> (you should probably write nand x y = not (x && y) instead unless you have a really good reason)
11:44:47 <badkins> elliott I'm experimenting with the syntax
11:44:47 <aristid> mm_freak: maybe you could still unify them :>
11:44:57 <mm_freak> aristid: they have inhibition in common (called "suspension" in ContinueT), but ContinueT doesn't switch…  instead it registers
11:44:57 <jfischoff> dmwit: oh I guess it could use cabal flags perhaps (for the extension)?
11:45:03 <dmwit> jfischoff: yes, exactly
11:45:07 <jfischoff> ah
11:45:08 <elliott> badkins: yeah, fai renough
11:45:08 <mm_freak> aristid: i don't think that's possible, because they are orthogonal
11:45:14 <elliott> just pointing out this is a bad idea in practice :P
11:45:17 <dmwit> jfischoff: Which is especially nice because then we don't have to be GHC-specific, as if that matters. ;-)
11:45:28 <badkins> elliott do you know how to get rid of x ?
11:45:32 <linduxed> let's say i've got the function "foo :: [Int] -> [[Int]]" with the definition "foo inNums". it takes inNums, does some stuff to them, then returns a [Int] which it feeds to itself recursively. this recursive "foo newNums" should be appended to inNums and this should go infinitely.  The question is: i'm pretty sure there's a higher order function for this type of stuff but i've forgotten which one, anyone
11:45:33 <linduxed> knows?
11:45:41 <badkins> This doesn't work: nAnd = not . ((&&))
11:45:48 <jfischoff> dmwit: right :). Is supporting an old version even worth the effort?
11:45:53 <monochrom> not . ((&&) x) = (not .) ((&&) x) = ((not .) . (&&)) x
11:45:58 <merijn> linduxed: Maybe iterate?
11:46:02 <elliott> badkins: lambdabot does: I showed it before my previous line
11:46:08 <linduxed> merijn: hmmm, maybe
11:46:08 <jfischoff> the haskell platform is 7.4 now ...
11:46:09 <mm_freak> linduxed: iterate?
11:46:10 <elliott> <elliott> @pl \x -> not . ((&&) x)  <lambdabot> (not .) . (&&)
11:46:12 <merijn> :t iterate
11:46:13 <linduxed> merijn: i'll have a look
11:46:14 <lambdabot> (a -> a) -> a -> [a]
11:46:23 <linduxed> looks pretty good
11:46:25 <mm_freak> > map (take 3) . iterate (drop 3) $ [0..]
11:46:27 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,...
11:46:30 <merijn> linduxed: Is it easy to chance foo into "[Int] -> [Int]"?
11:46:44 <mm_freak> > iterate (map succ) [1..3]
11:46:45 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
11:46:46 <linduxed> merijn: i'm generating pascals triangle
11:47:00 <badkins> elliott thanks - that wasn't intuitive!
11:47:06 <elliott> indeed not :)
11:47:14 <linduxed> merijn: so it just takes [1, 1] and does the next row
11:47:14 <merijn> > let foo = map (+1) in iterate foo [1,2,3,5]
11:47:15 <elliott> probably easiest way to understand it is to expand it back out using (.)'s definition
11:47:15 <lambdabot>   [[1,2,3,5],[2,3,4,6],[3,4,5,7],[4,5,6,8],[5,6,7,9],[6,7,8,10],[7,8,9,11],[8...
11:47:43 <merijn> linduxed: If you make foo return the next row, based on the input, then iterate will do what you want
11:48:24 <linduxed> merijn: thx!
11:48:25 <monochrom> badkins: you are supposed to use algebra, not intuition. or rather, not untrained intuition
11:48:29 <monochrom> not . ((&&) x) = (not .) ((&&) x) = ((not .) . (&&)) x
11:49:38 <Xaratas> hmm, for n=4 the algorithm is useable fast, for n=5 does it work? is the ammount of work so vastly exploding? 6 minutes runtime and still zero results
11:49:52 <badkins> monochrom: I'm not seeing the particular algebraic properties you're using there
11:50:24 <merijn> > let foo xs = zipWith (+) (0:xs) (xs ++ [0]) in iterate foo [1]
11:50:26 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
11:50:27 <monochrom> ok, the first step is analogous to: x + y = (x +) y
11:50:31 <mm_freak> > iterate (\xs -> head xs : liftA2 (zipWith (+)) id tail xs ++ [last xs]) [1]
11:50:34 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
11:50:50 <merijn> mm_freak: I think mine is considerably simpler :)
11:50:51 <mm_freak> ugly, and merijn's solution is better =)
11:51:06 <mm_freak> well
11:51:17 <monochrom> the second step is analogous to: f (g x) = (f . g) x, where f = (not .)
11:51:19 <mm_freak> not better…  technically it's the same, but yours looks better =)
11:51:43 <Xaratas> o
11:51:46 <Xaratas> the same
11:51:56 <Xaratas> thats a bendable word here
11:52:33 <MOMI> Hi, a quick question is it possible to write this without the commas, is there any suntatic sugar available for that.Thanks
11:52:34 <MOMI> let lostNumbers = [4,8,15,16,23,42]
11:52:43 <Xaratas> i have gotten 7 versions of the same yesterday
11:52:46 <badkins> elliott what does "@pl" stand for in your query to lambdabot ?
11:52:52 <merijn> linduxed: There you go, one line pascal's triangle ;)
11:52:52 <mm_freak> > iterate (liftA2 (zipWith (+)) (0 :) (++ [0])) [1]
11:52:55 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
11:53:00 <mm_freak> merijn: combined =P
11:53:03 <merijn> badkins: PointLess
11:53:05 <Botje> MOMI: map read . words $ "4 8 15 ..."
11:53:11 <badkins> awesome - thx
11:53:17 <monochrom> "point" refers to parameters such as x
11:53:19 <merijn> badkins: It tries to elimiante "points" (i.e. variable names)
11:53:35 <Botje> MOMI: or (4:8:15:16:32:42:[]), or is that cheating?
11:54:20 <MOMI> well when I was learning back perl there was an option for that which speeds up the writting of code
11:54:48 <badkins> yeah, I got the "point" think - just didn't know I could ask lambdabot for that transformation
11:54:49 <Botje> map read . words will get you pretty close to perl's qw(...) yes.
11:54:56 <badkins> s/think/thing/
11:54:57 <MOMI> example
11:54:58 <MOMI> http://www.misc-perl-info.com/perl-qw.html
11:55:03 <linduxed> merijn: damn, i wouldn't have thought of it that way
11:55:13 <MOMI> look at the
11:55:14 <MOMI> @array = qw/sweet bitter sour salty hot/;
11:55:15 <lambdabot> Drink up, me 'earties
11:55:18 <Botje> MOMI: fine, ignore me.
11:55:19 <linduxed> merijn: didn't think of zipWith
11:55:28 <merijn> linduxed: zipWith is your friend :)
11:55:37 <Botje> MOMI: thirdly, you could implement this feature using quasiquotations as well.
11:56:02 <merijn> badkins: Well, usually @pl does more harm than good, but sometimes it turns up something useful
11:56:02 <MOMI> How Botje.Thanks for the help
11:56:05 <monochrom> some people assume without asking that "point" refers to the . operator, and get very confused at how pointless has more . operators, not fewer
11:56:05 <elliott> there are packages to do so i think
11:56:27 <monochrom> it is another example of confusion caused by wrong assumptions
11:56:29 <Botje> MOMI: you read the documentation on quasiquotations and you implement the feature you want.
11:56:36 <Botje> I don't know how to do it off-hand.
11:56:39 <MOMI> Ok.I will
11:56:52 <MOMI> Thanks for help Botje appreciate it.:)
11:57:28 <dmwit> Wait, I thought it was possible to check for individual extensions in a cabal file.
11:57:37 <dmwit> But this is not listed in the "conditions" section of the manual.
11:57:40 <Botje> MOMI: http://hackage.haskell.org/packages/archive/yesod-routes/0.0.1/doc/html/src/Yesod-Routes-Parse.html this is /very/ close.
11:57:42 <dmwit> Is this possible, or not?
11:58:08 <Botje> MOMI: it allows you to write "routes" like the first example in http://www.yesodweb.com/book/basics
11:58:09 <dcoutts> dmwit: they are checked (similarly to C libs), but it's not currently possible to do conditional stuff on them
11:58:19 <merijn> There's no "atoms" like thing, right? Unless I do some form of quasi-quoting?
11:58:21 <dmwit> oh, bugger
11:58:37 <dmwit> So I have to check GHC version instead, then?
11:59:03 <jfischoff> dmwit: yeah I think so
12:00:02 <Xaratas> ok, simple question: is there a better way than nub to find out if 2 lists of different size are disjunct? I have 2 lists before nub but need them combined
12:00:23 <merijn> Xaratas: Convert to set and union?
12:00:36 <merijn> Assuming your elements are Ord
12:00:42 <Xaratas> they are
12:00:53 <Xaratas> simple numbers, should be Int
12:00:56 <merijn> Well, then that is probably the easiest and most efficient
12:01:04 <MOMI> Thanks Botje will study it now and report back.:)
12:01:21 <oio> > sleep 1
12:01:23 <lambdabot>   Not in scope: `sleep'
12:01:31 <merijn> oio: lambdabot doesn't allow IO
12:01:49 <merijn> For obvious reasons
12:02:09 <oio> gettin weird stuuf with this
12:02:10 <oio> module Main where  import System.Posix   dem x = do 	sleep 1 	putChar $ "Que notas llevas" !! (x - 1) 	dem (x + 1 )   main = do 	putChar '\n' 	dem 1
12:02:12 <Xaratas> "lambdabot doesn't sleep" would be a better explanaiton ;)
12:02:22 <hpc> it also doesn't allow other things, for less obvious reasons
12:02:34 <merijn> oio: Paste on hpaste?
12:02:36 <monochrom> lambdabot doesn't drink and drive
12:02:44 <hpc> also, tabs
12:03:06 <Botje> oio: you are probably running into buffering.
12:03:15 <Botje> oio: try hSetBuffer stdOut NoBuffering
12:03:27 <Botje> modulo letter casing
12:03:51 <hpc> hSetBuffering stdout NoBuffering
12:03:53 <monochrom> does anyone actually know, with evidence, what "weird stuff" means?
12:04:26 <merijn> monochrom: Don't harsh their buzz!
12:04:36 <hpc> monochrom: ancient encrypted diaries, delivered by fedex
12:04:52 <merijn> Back to my question...atoms? I'll need to go the quasiquoting route, right?
12:04:58 <oio> Didnt work threadelay same stuff
12:05:53 <dmwit> jfischoff: done
12:05:59 <jfischoff> :)
12:08:39 <dmwit> oio: Can you tell us what you expect to happen and what happened instead?
12:08:52 <dmwit> The more precise the two descriptions are, the better.
12:11:23 <carter> jfischoff did you figure out building on your side?
12:11:32 <jfischoff> carter: yeah
12:11:55 <jfischoff> jfischoff: cleaning and rebooting fixed it
12:11:56 <carter> cool
12:12:06 <jfischoff> haha
12:12:26 <jfischoff> I do like to talk to myself
12:12:37 <carter> oh?
12:12:42 <carter> hopefully it helps you think
12:15:39 <Xaratas> merijn: thanks got 17.5% better runtime
12:17:42 <merijn> Xaratas: \o/
12:18:36 <Xaratas> now is the question if n=5 is really so big that it takes ages or if i have a bug
12:19:53 <ollehar1> anyone into type level hackery?
12:20:13 <merijn> ollehar1: Lots of people :)
12:20:53 <armlesshobo> type level hackery is my family name
12:20:56 <monochrom> not me
12:21:04 <armlesshobo> Armlesshobo T. L. Hackery
12:21:22 <aCube> HLists are fun
12:22:18 <jfischoff> I find type level programming is a great way to feel smart without accomplishing anything. So yes, I'm into it.
12:23:33 <ollehar1> ok, good :) I'm mainly working in OCaml, but i figured trying it out in haskell since ocaml doesn't have the community (unfortunately).
12:23:33 <ollehar1> my question is this: how to define, at type level, that a number is greater than another? (peano numbers, I would assume). so (in pseudo code) Greate (n1, n2) won't compile if n1 < n2.
12:23:53 <ollehar1> *Greater
12:24:11 <jfischoff> handle your cases with a type family through induction
12:25:13 <luksow> I have to share something with you guys: I tried Scala yesterday and I'm glad that Haskell was my first FP. Scala isn't nearly as beautiful as Haskell is and everything in Scala is so _heavy_
12:25:26 <ab9rf> luksow: heh
12:25:43 <ollehar1> jfischoff: I will google that, thanks
12:25:47 <ab9rf> luksow: scala is on my future project list.  i looked at it briefly about six months ago but put it aside for later.
12:26:02 <jfischoff> ollehar1: I'll show you in a sec...
12:26:38 <luksow> ab9rf, I'm learning it because it's the most "commercial" FP in my country (Poland)...
12:26:38 <Eelis> i seem to recall that Clean had serializable functions. has something like that been done for Haskell yet?
12:27:02 <ab9rf> luksow: i wonder how specific to poland that is
12:27:17 <luksow> heh, probably not at all ;)
12:27:40 <luksow> but Clojure is probably even less then Haskell here
12:27:53 <luite> Eelis: as a ghc extension, eden
12:28:01 <ab9rf> i have only briefly examined scala and have not looked at clojure at all
12:28:08 <merijn> There's no way to create a type from a value I guess? i.e. I want to pass a value to a GADT constructor to have that value end up as a type in my GADTs type
12:28:11 <kennyd> luksow what did you mean by heavy
12:28:39 <merijn> Eelis: Partially, cloud haskell can serialise some closures, but not all
12:29:01 <luite> it doesn't really serialize closures, just function names with arguments
12:29:09 <Eelis> luite: hmm
12:29:12 <Eelis> merijn: ah, cool
12:29:22 <luite> ^ that was about cloud haskell
12:29:22 <Eelis> merijn: what are the limitations like?
12:29:26 <elliott> merijn: that would be dependent types
12:29:31 <Eelis> oh
12:29:33 <merijn> elliott: Yeah, I know :(
12:30:04 <romm> ab9rf: i think the most widely used FPL is erlang, no?
12:30:11 <ab9rf> romm: probably true.
12:30:19 <ab9rf> romm: although i am no expert
12:30:28 <ab9rf> i tried to learn erlang about three years ago, got nowhere with it
12:30:32 <luksow> kennyd, well syntax is still verbose when comparing it to Haskell (but it's not that important and it is arguable) but I'm deeply disappointed with tools. First of all JVM makes Scala apps slow to start. Secondly SBT is quite hard to use and I don't really understand even the simple configs. Thirdly I installed recommended Emacs plugins for Scala and one (ENSIME, similiar to ghc-mod I suppose) have eaten 1G of RAM after startup...
12:30:43 <ab9rf> i'd probably do better now
12:30:51 <romm> ab9rf: basically what's happening with me an haskell now :)
12:31:04 <ab9rf> romm: i'm on my second pass with haskell
12:31:05 <merijn> elliott: I'm trying some brainstorming on a nicer GUI approach as I was discussing earlier, but doing that nicely is a bit tricky if you want to statically verify the correctness. You'd want some way to encode identifiers in the types :\
12:31:17 <ab9rf> romm: my first pass i learned a little, but didn't really grasp monads at all
12:31:21 <romm> ab9rf: indeed, me too. second pass with LYAH, actually.
12:31:29 <simpson> romm: According to TIOBE, the most popular functional programming language is Python. :3
12:31:49 <ab9rf> simpson: hahah
12:31:54 <luksow> simpson, :D
12:31:57 <simpson> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
12:31:59 <ab9rf> simpson: at least it's not PHP
12:32:21 <simpson> ab9rf: PHP is not functional by the common definition most FP people agree on.
12:32:27 <Hafydd> Hahah
12:32:28 <romm> simpson: oh. well is does indeed have a lot of FP snippets in it.
12:32:38 <ab9rf> romm: i spent about two months rying to learn haskell about two years ago.  managed to write a couple of small programs, but nothing really interesting.
12:32:40 <edwardk> We are officially part of the summer of code!
12:32:43 <ab9rf> simpson: neither is python :)
12:32:51 <luite> edwardk: \o/
12:32:53 <simpson> romm, ab9rf : I bet that you cannot define FP satisfactorily in a way that excludes Python. >:3
12:32:58 <simpson> edwardk: Woot@!
12:33:01 <luksow> edwardk, great!
12:33:09 <ab9rf> simpson: probably not
12:33:11 <tac> simpson: TIOBE?
12:33:21 <merijn> The only way I can think of encoding identifiers in types would be to use TH or quasiquoting to generate code instead of writing haskell directly :\
12:33:28 <ab9rf> simpson: i'm not sure i can define functional programming in any useful way anyhow
12:33:29 <luite> edwardk: is the number of slots already known?
12:33:49 <romm> simpson: i won't take that bet. actually, at this point of time i fail to see the usefulness of haskell. or it's advantage over python in the tasks i do.
12:33:50 <simpson> tac: I linked it above. An index that includes the otherwise-invisible fortresses of entrenched enterprise code sequestered around the globe.
12:34:04 <edwardk> luite: sadly no. we get to ask for a number of slots as we start getting applications
12:34:29 <ab9rf> simpson: oh, someone tried to do a survey of entrenched enterprise code?  that had to be a political nightmare.
12:34:47 <simpson> ab9rf: They do it on a pretty regular basis.
12:34:55 <donri> TIOBE 2014: 'lens' is now in the top ten most discussed programming languages.
12:35:05 <edwardk> donri: hah
12:35:07 <simpson> ab9rf: Anyway, that's why you see Pascal and VB ranked so highly.
12:35:14 <ab9rf> simpson: yeah, i'm not surprised
12:35:30 <ab9rf> simpson: my gf worked for Cardinal Health a few years ago.  they had all sorts of weird crap there.
12:35:52 <simpson> ab9rf: Oh man, healthcare industry stuff. Did she have to do MUMPS? :c
12:35:59 <ab9rf> simpson: no, fortunately not :)
12:36:28 <ab9rf> simpson: she worked for a while in the nuclear pharmacy division, and a lot of that code was _ancient_, simply beause any changes had to be approved by both the FDA _and_ the NRC.
12:36:52 <simpson> Uf.
12:36:58 <armlesshobo> ab9rf: New Repulic of California?
12:37:08 <ab9rf> armlesshobo: nuclear regulatory commission
12:37:10 <armlesshobo> Republic*
12:37:12 <armlesshobo> oh :P
12:37:29 <ab9rf> the division she worked for manufactured short-lived medically therapeutic radioisotopes
12:37:46 <romm> well... if the NRC fails in their job, the acronym will change.
12:38:17 <ab9rf> stuff with shelf lives measured in hours
12:38:59 <ab9rf> they had to go three rounds with the regulators to apply software updates
12:39:09 <Xaratas> ups, if my rough calculation only a bit correct i have an increase in workload of factor ~280k from n=4 to n=5
12:41:46 <ab9rf> fortunately none of the stuff she worked on was in process control, the closest she got to that was label printers
12:48:08 <benzrf> hello! I don't know Haskell, but before I learn it I wanted to ask about a few things
12:48:16 <Eduard_Munteanu> Hi.
12:48:17 <Eelis> benzrf: by all means!
12:48:21 <mm_freak> aristid: https://github.com/ertes/continue/blob/master/test/Main.hs
12:48:30 <mm_freak> aristid: small web app experiment =)
12:48:44 <mm_freak> stepcut: you might find this interesting, too
12:48:57 <mm_freak> stepcut: it's WAI, though
12:49:05 <benzrf> for example... how, exactly do you do I/O with referential transparency? I've read that you pass the world as an argument via monads (another thing I don't know anything about) and then get back a suitably altered version, but I don't see how that solves anything...
12:49:24 <mm_freak> benzrf: that's just an interpretation
12:49:32 <stepcut> mm_freak: yeah, hyperdrive is not ready for consumption yet
12:49:34 <benzrf> ok
12:49:39 <mm_freak> benzrf: main = forever (putStrLn "Hello world!")
12:49:41 <parcs> edwardk: but we're not on the list!
12:49:44 <mm_freak> that's what I/O code looks like =)
12:50:02 <edwardk> "We (haskell.org) have been officially accepted into the Google Summer of Code for 2013. We should show up in the mentoring organization list as soon as I get some information we need to finalize the listing."
12:50:03 <shachaf> benzrf: The world-passing analogy that people give is pretty much just wrong, and also unhelpful.
12:50:11 <benzrf> ok
12:50:12 <benzrf> how does it work, then?
12:50:34 <Eduard_Munteanu> edwardk: congrats, are you involved in it?
12:50:45 <shachaf> benzrf: There are a bunch of introductions to it listed in the FAQ.
12:50:53 <mm_freak> benzrf: I/O actions can be defined in a domain-specific language…  in that sense they are like recipes…  a recipe is just data after all
12:50:53 <benzrf> ok
12:51:07 <shachaf> benzrf: The general idea is that you write the description of an imperative program that does I/O in Haskell.
12:51:15 <benzrf> ok, that
12:51:19 <benzrf> makes sense I guess?
12:51:22 <shachaf> benzrf: Then something comes along and executes your description.
12:51:23 <benzrf> but...
12:51:29 <shachaf> Except it's much less awkward than it sounds. :-)
12:51:32 <edwardk> Eduard_Munteanu: i've been our org administrator for the last ~4 years
12:51:34 <benzrf> but...
12:52:05 <benzrf> if your program as a whole is referentially transparent...
12:52:17 <carter> edwardk cool
12:52:23 <benzrf> doesn't that mean that it has to finish before the 'constructed program' is run?
12:52:23 <edwardk> Eduard_Munteanu: Mostly it consists of harassing people to submit reviews, dealing with fallout when things go south between mentor/student and gently nudging things along in the right direction.
12:52:24 <Eduard_Munteanu> edwardk: mmm... so that's how lens got documented :P
12:52:38 <mm_freak> benzrf: no, that's where laziness comes into play =)
12:52:46 <benzrf> mm_freak: how does that work?
12:52:51 <shachaf> Eduard_Munteanu: I assure you no one got paid for any work that ever happened to lens.
12:52:52 <mm_freak> benzrf: but your intuition is quite close
12:52:53 <edwardk> Eduard_Munteanu: I figure it is one thing I can give back to the Haskell community
12:53:02 <shachaf> mm_freak: It doesn't really have to do with laziness at all.
12:53:05 <benzrf> hooray
12:53:06 <mm_freak> benzrf: indeed haskell programs are evaluated and the resulting action is then run
12:53:16 <shachaf> You could do I/O the way Haskell does it in a strict language with no problem.
12:53:18 <edwardk> shachaf: Well, I already gave you a 20% raise. What more do you want?
12:53:23 <mm_freak> shachaf: it does indeed:  'forever' critically depends on lazy evaluation
12:53:38 <carter> edwardk a raise in what currency? :p
12:53:47 <edwardk> carter: pick.
12:53:54 <edwardk> The nice thing about 0 is it is pretty universal ;)
12:53:59 <merijn> carter: 20% of 0 = 0
12:54:01 <hpaste> jfischoff pasted “Type Level Programming Example” at http://hpaste.org/85430
12:54:01 <carter> jah
12:54:02 <shachaf> edwardk: five dola, like copumpkin promised
12:54:05 <jfischoff> ollehar1: ^
12:54:18 <mm_freak> shachaf: without laziness you get a chicken/egg problem as soon as you have an infinite action or a branch somewhere
12:54:23 <carter> jfischoff neat
12:54:26 <ab9rf> just charge a bitcoin :)
12:54:26 <shachaf> mm_freak: It does not.
12:54:39 <shachaf> mm_freak: You can have cyclic lists in a strict language.
12:54:45 <edwardk> shachaf: you'll have to collect that from copumpkin assuming he still has anything as crass as dolas in his bank account, and hasn't cashed them all in for bitcoins
12:54:56 <jfischoff> carter: oh there are better ways now, but ollerhar1 wants to do it in ocaml so I kept it simple
12:55:00 <benzrf> I am so angry that I didn't invest in bitcoin
12:55:02 <benzrf> :<
12:55:03 <merijn> ollehar1, jfischoff: The True is redundant
12:55:04 <tgeeky> you can't burn bitcoins for heat!
12:55:11 <benzrf> I could've made millions!
12:55:12 <benzrf> MILLIONS
12:55:13 <ab9rf> tgeeky: you can print them out and then burn them :)
12:55:20 <carter> jfischoff i don't think you can do that inequality with typelits as they current live
12:55:30 <carter> or at least the baked in type nats
12:55:31 <chrisdotcode> masters, I come for enlightenment. durnig programming I always think imperatively. how does a student mold his thinking to the functional way?
12:55:42 <mm_freak> shachaf: a cyclic list doesn't do the job…  imagine a parser and printer for a turing-complete language
12:55:42 <merijn> ollehar1, jfischoff: Oh wait, I thought that was a typeclass, rather than type fun. You could easily implement the same with recursion on typeclasses
12:55:52 <carter> chrisdotcode: i like to write down the math the describes what a valid answer is
12:56:02 <carter> then turn that into a recursive/ inductive computation
12:56:05 <jfischoff> merijn: yeah you could
12:56:21 <carter> there are some upsides to the type class approach
12:56:25 <chrisdotcode> carter: so your thoughts and pseudo code are initial imperative?
12:56:31 <benzrf> so...
12:56:32 <benzrf> wait
12:56:36 <jfischoff> merjin: I think type families make the structural recursion more obvious
12:56:36 <carter> chrisdotcode: no they're "the math"
12:56:46 <benzrf> hrm
12:56:58 <chrisdotcode> carter: what if the problem is something like "turn this list into a tree", for example.
12:57:13 <carter> chrisdotcode: thats a combinatorical problem
12:57:17 <carter> combinatorics is math :)
12:57:24 <mm_freak> benzrf: anyway, i suggest you just try it out =)
12:57:30 <chrisdotcode> carter: so the answer for me is to learn more math?
12:57:36 <carter> chrisdotcode no
12:57:40 <benzrf> :s
12:57:44 <mm_freak> benzrf: grab LYAH and write great applications
12:57:46 <mm_freak> @where LYAH
12:57:46 <lambdabot> http://www.learnyouahaskell.com/
12:57:49 <carter> chrisdotcode yes/no
12:57:50 <benzrf> I kn ow it :P
12:57:58 <mm_freak> good =)
12:57:59 <carter> chrisdotcode what do you want to work on / do?
12:58:01 <parcs> chrisdotcode: by reading and writing lots of haskell of course
12:58:03 <benzrf> I started it a year or two ago, didn't see it going anywhere, and stopped
12:58:05 <carter> yes
12:58:10 <carter> that works too
12:58:13 <benzrf> this was before I knew anything at all about FP
12:58:22 <benzrf> now I think I'll give it a better chance :)
12:58:42 <mm_freak> go ahead =)
12:58:45 <ollehar1> jfischoff: great! I'll dig into this :)
12:58:56 <carter> heres's a great book on combinatorics http://algo.inria.fr/flajolet/Publications/books.html
12:59:00 <romm> benzrf: well, i know a little about FP, but i still don't see it going anywhere :)
12:59:06 <romm> it's a great mindgame though
12:59:16 <benzrf> ok
12:59:21 <mm_freak> and feel free to ask questions, even if you think they are stupid…  #haskell is one of the few places where there are no stupid questions…  sometimes i have the impression that we don't even have off-topic questions =)
12:59:50 <mm_freak> let me prove it…
12:59:52 <carter> romm is that romy?
12:59:57 <mm_freak> is fire really a plasma?
13:00:09 <carter> thats a cool question
13:00:16 <carter> that i don't know enough physics to help with
13:00:24 <romm> carter: nope, sorry.
13:00:29 <carter> np
13:00:52 <jfischoff> ollehar1: it is not actually very useful as it stands. You might want singletons not sure...
13:01:35 <shachaf> mm_freak: That sounds off-topic. Take it to #-blah. hth
13:01:44 <mm_freak> shachaf: =(
13:01:57 <merijn> Crap, why do half my problems always end up in "I need dependent types to write this"? :<
13:02:28 <mm_freak> merijn: probably because you're overengineering things a bit
13:02:54 <chrisdotcode> carter: so what's the true solution? write down my thougts in math, and then haskellify it? what if I have to build a house? how is this done functionally?
13:03:02 <merijn> mm_freak: I want some static guarantees that are hard to get otherwise
13:03:11 <carter> chrisdotcode you first write down the floor plan / spec for the house
13:03:13 <carter> to make sure it makes sense
13:03:23 <carter> before you build a house :)
13:03:24 <merijn> mm_freak: The alternative is to say "screw it, might as well just tell people to use Lua instead"
13:03:38 <carter> haskell is also good at the "just write stuff and see what works" approach
13:03:54 <carter> but it really rewards that combined with occasional thoughtful planning
13:03:58 <chrisdotcode> carter: is that a functional approach, though? to me that seems imperative, as in: 1. write down floor plan 2. buy materials 3. build
13:04:07 <carter> chrisdotcode thats not code
13:04:09 <merijn> mm_freak: I could just stuff everything in Maps with String identifiers, but that leaves me in the exact kinda mess there exists currently
13:04:17 <glguy> functional and imperative aren't opposites
13:04:17 <chrisdotcode> carter: it's weak pseudo code :)
13:04:18 <carter> I can / and sometimes do write really imperative code in haskell
13:04:31 <chrisdotcode> glguy: right, shouldn't they be complementary?
13:04:33 <carter> haskell is a tool for solving problems
13:04:44 <carter> not a religion :)
13:04:56 <ollehar1> merijn: one guy on SO keep telling me to use coq ;)
13:05:14 <merijn> ollehar1: He's lying, use Agda or Idriss ;)
13:05:16 <Eduard_Munteanu> ollehar1: clearly he's wrong, use Agda :P
13:05:19 <Eduard_Munteanu> Heh.
13:05:21 <chrisdotcode> carter: how easy it is to be imperative in haskell, besides if/else statements?
13:05:31 <carter> chrisdotcode EASY
13:05:41 <merijn> chrisdotcode: Super easy
13:05:41 <elliott> if/then/else is not imperative at all
13:05:47 <carter> that too
13:05:51 <chrisdotcode> carter, merijn: what tools/constructs am I missing
13:05:54 <ollehar1> I'm learning ATS a bit... :P
13:05:56 <merijn> chrisdotcode: Just stuff everything in the IO monad :)
13:05:56 <carter> chrisdotcode none
13:05:57 <chrisdotcode> elliott: they're not?
13:05:57 <byorgey> if/else statements are imperative.  Haskell does not have them.
13:05:59 <carter> you have all of them
13:06:07 <byorgey> Haskell only has if expressions.
13:06:12 * elliott thinks it might be easier to answer these questions if you had a more solid understanding of exactly what imperative means, esp. what the benefits of more declarative code are
13:06:13 <carter> oh yeah, if then else expressions
13:06:26 <carter> chrisdotcode whats your computer science / programming experience to date?
13:06:45 <carter> are you like an embedded systems dev thats branching out or in the middle of school or what? :)
13:07:15 <carter> (i actually know some cool embedded systems people who do a funky mix of C and haskell for their work)
13:07:19 <chrisdotcode> carter: one day I will be hopefully :) I'm self-taught, but I know my data structures and I'm currently trying to learn about compilers, when haskell caught my eye
13:07:26 <ollehar1> Eduard_Munteanu: merijn: lightweight dependent types FTW, maybe
13:07:32 <chrisdotcode> in college, but not really learning anything from it.
13:08:09 <jfischoff> sounds like most of my college classes
13:08:35 <romm> i always have trouble believing these statements
13:08:40 <jfischoff> chrisdotcode: I would switch colleges
13:08:44 <chrisdotcode> you Ph.D haskell guys are much smarter than me :p
13:08:58 <mm_freak> merijn: you may have taken it the wrong way…  i'm not saying that dependent types are bad…  i've just found that sometimes, when i don't overengineer stuff, i end up with much simpler types
13:08:58 <chrisdotcode> jfischoff: yeah, I've been told that. It's either that, or try things on my own.
13:09:14 <hpc> @where lyah
13:09:14 <lambdabot> http://www.learnyouahaskell.com/
13:09:17 <mm_freak> merijn: in other words, ask yourself whether you really need to statically guarantee that you don't divide by zero =)
13:09:54 <hpc> chrisdotcode: the dirty secret of haskell programmers is that their power does not come from their PhD, but their bowtie
13:09:56 <jfischoff> chrisdotcode: you want teachers like byorgey and dmwit. Go some where better it will change your whole opinion of college
13:10:13 <chrisdotcode> hpc: duly noted
13:10:19 <jfischoff> @remember hoc the dirty secret of haskell programmers is that their power does not come from their PhD, but their bowtie
13:10:19 <lambdabot> It is forever etched in my memory.
13:10:22 <carter> chrisdotcode jfischoff  is right, good mentoring is key
13:10:24 <merijn> mm_freak: I'm trying to sketch out what a "non-sucky" GUI library/DSL would look like, and I would like to statically guarantee there's no "loose ends", i.e. every interaction that should be tied to something *is*
13:10:30 <hpc> @forget hoc the dirty secret of haskell programmers is that their power does not come from their PhD, but their bowtie
13:10:30 <lambdabot> Done.
13:10:35 <carter> merijn that'd be awesome and useful
13:10:39 <hpc> @remember hpc the dirty secret of haskell programmers is that their power does not come from their PhD, but their bowtie
13:10:40 <lambdabot> Done.
13:10:41 <chrisdotcode> jfischoff: I feel like there's no definitive trail for understanding and learning lots of CS material. for example, for compilers, there's only two texts: the dragon book and Let's build a compiler
13:11:03 <merijn> chrisdotcode: There's "Build Yourself a Scheme in 48 Hours"
13:11:07 <chrisdotcode> and the dragon book is not for mere mortals I here
13:11:07 <carter> chrisdotcode the dragon book is not a good Book
13:11:15 <carter> its terribly boring
13:11:22 <carter> chrisdotcode google aroudn for more materials
13:11:24 <chrisdotcode> most of the "academic" CS books suck, and seem more for flexing intellectual muscles than teaching
13:11:30 <chrisdotcode> there's SICP
13:11:31 <hpc> carter: heh, i consider SICP to be the same
13:11:31 <merijn> tbh, building compilers is pretty easy. It's just hard to see that when you've never done it
13:11:33 <carter> theres lots of other good books and lecture notes
13:11:35 <mm_freak> merijn: a non-sucky GUI DSL would be declarative and the best way to guarantee that there are no loose ends is by enforcing a categorical design
13:11:36 <chrisdotcode> which also seems too high up for me
13:11:42 <carter> hpc i enjoyed reading SICP in highschool
13:11:50 <chrisdotcode> high school? sheesh >_>
13:11:54 <romm> chrisdotcode: huh? no. there are great CS books. maybe not about compilers.
13:11:55 <chrisdotcode> you guys are waaay smarter than I
13:12:03 <hpc> someone told me "you should read SICP, it will teach you a lot"
13:12:10 <chrisdotcode> romm: okay, yeah. that's true.
13:12:14 <carter> how to design programs is a nice intro book
13:12:18 <hpc> i read it, and all i learned was that the book is an introductory course that is coincidentally in lisp
13:12:34 <merijn> mm_freak: Maybe, but I have no clue what that'd look like, so I'm starting from "what I'd want to be able to write" to "how would I enforce that that'd actually work"
13:12:35 <hpc> it barely covers functional programming, even
13:12:35 <carter> hpc the point is its also good exposition
13:12:51 <aristid> hpc: which WILL teach you a lot if an introductory course is what you need.
13:13:23 <hpc> yeah, the person who recommended it was misrepresenting the book
13:13:29 <chrisdotcode> okay, so I know this may be heretical, but I don't really like how the lisps look. to me, it seems like compiler slavery. besides prefix (which I love), not every datastructure needs to be a list. I prefer python or haskell, which are insanely expressive, IMO
13:13:42 <hpc> ooh
13:13:44 <hpc> "compiler slavery"
13:13:47 <chrisdotcode> they seem "human-readably" intuitive
13:13:52 <merijn> chrisdotcode: Lisp has other data structures than lists...
13:13:54 <chrisdotcode> haskell and python that is
13:14:07 <hpc> imo though, python makes you a slave to guido
13:14:12 <meyersh> merijn: Not according to widely held beliefs. ;-)
13:14:15 <hpc> and his whims on what constitutes a valid program
13:14:23 <chrisdotcode> hpc: I somewhat agree
13:14:43 <romm> hpc: what do you mean?
13:14:55 <chrisdotcode> romm: there's GIL, which is always discussed
13:15:01 <hpc> romm: mostly his hate of functional programming
13:15:05 <hpc> which he thinks is a feature
13:15:08 <mm_freak> merijn: in a hypothetical GUI DSL of my design you would have primitive GUIs (morphisms) and primitive combinators…  prove that all primitive GUIs are valid and prove that all combinators produce valid result GUIs for valid input GUIs
13:15:23 <hpc> he has tried on several occasions to remove map/reduce/filter
13:15:43 <romm> chrisdotcode: the GIL is an implementation issue. it doesn't affect the language.
13:15:44 <chrisdotcode> hpc: really? I did not know that
13:15:48 <hpc> and lambdas are deliberately gimped
13:15:49 <mm_freak> merijn: if your primitive combinators are categorical you get most of the safe GUI DSL for free
13:15:52 <romm> hpc: hmm. didn't know that
13:15:55 <carter> chrisdotcode: sounds like you need to work through some good intro materials right now
13:15:56 <chrisdotcode> romm: oops, my mistake, yeah.
13:16:06 <chrisdotcode> carter: intro to what exactly?
13:16:12 <carter> LYAH and/or htdp2e are excellent
13:16:19 <chrisdotcode> carter: LYAH is wonderfuly
13:16:22 <chrisdotcode> * wonderful
13:16:27 <chrisdotcode> I'm almost through it
13:16:27 <carter> so whats your question?
13:16:29 <carter> :)
13:16:45 <carter>   whats the goal :)
13:16:48 <hpc> http://www.artima.com/weblogs/viewpost.jsp?thread=98196
13:16:55 <romm> hpc: well, at least he didn't succeed.
13:17:15 <chrisdotcode> my initial question was "how do I think functionally when writing psuedo-code solutions", but a secondary question became "how do I learn more about software, especially compiler writing" xD
13:17:16 <mm_freak> merijn: in other words, you probably have most of what you need without any fancy types =)
13:17:46 <hpaste> Ontolog pasted “Recursively defined, circularly linked data structure” at http://hpaste.org/85432
13:18:07 <carter> chrisdotcode : theres that write a scheme compiler in 2 days document
13:18:16 <hpc> afaict, the closest language to haskell, philosophically and design-speaking, is perl
13:18:17 <carter> you could also explore GHC source :)
13:18:32 <carter> (don't do that, unless you have LOTs of time, its a big program)
13:18:33 <Ontolog> I'm having trouble mapping some data to a data type I created, please see the comments in here http://hpaste.org/85432
13:18:39 <merijn> mm_freak: Lemme describe one annoying issue I run into that I want to solve. I often find myself defining widgets that should interact, but should be in different parts of the UI. i.e. a form and the stuff processing it's results. The frameworks I've tried so far force you to define widgets where you use them, rather than based on their interconnection
13:18:40 <romm> hpc: uh, he didn't actually remove the functionality. it's just that the syntax is list comprehension instead of filter() or map().
13:18:59 <merijn> mm_freak: This results in a lot of inconvenience and global state hacks to get the behaviour where you want it
13:19:06 <chrisdotcode> carter: I was looking at a "let's build a compiler", translated to python tutorial. I want to write one in haskell eventually, but I'm not there yet :)
13:19:20 <hpc> Ontolog: you can do mutual recursion inside 'where'
13:19:41 <hpc> Ontolog: your problem is you need M.fromList
13:19:54 <hpc> or rather, fromList
13:19:58 <hpc> because unqualified import
13:20:10 <romm> hpc: and i actually agree that comprehensions are clearer and generally better.
13:20:15 <merijn> mm_freak: I would like to have a way to define widgets that interact together in a single place and then hand them to different UI parts for actual display. But now I want to enforce that you don't accidentally pass only a subset of these related widgets to UIs. i.e. they should actually be complete
13:21:00 <hpc> romm: and why have functions when instead you can have this magical syntax? that is the route to C++
13:21:19 <merijn> mm_freak: Defining a set of primitive GUIs and primitive combinators is a nice idea, and you'd know all possible GUIs are valid. But does that mean you can actually write the GUIs you *want*?
13:21:35 <hpc> surely a fast implementation of map/reduce/filter exists
13:21:53 <romm> hpc: how is that different from any syntax? why have a -> b ->c instead of c function(a,b)?
13:22:09 <romm> hpc: [f(x) for x in something] is very, very clear.
13:22:25 <merijn> mm_freak: If I end up with a bunch of combinators I don't actually want and none of the combinators I *do* want the exercise is still futile
13:22:32 <hpc> it is unnecessary syntax
13:22:44 <hpc> when you can implement what you want in-language
13:22:56 <romm> hpc: i disagree, and so do many others :)
13:23:08 <hpc> hell, make map(f, list) = [f(x) for x in list]
13:23:14 <hpc> poof, no performance issues
13:23:21 <NemesisD> hmm, exception is not derivable?
13:23:25 <hpc> unless somehow there's a ton of overhead on making a lambda?
13:23:36 <hpc> guido's arguments were just plain weird
13:23:45 <hpc> and what harm is there to the language in having them around?
13:24:10 <hpc> surely a python programmer already knows how to read the cast bones and divine the one true way
13:24:15 <merijn> NemesisD: You don't need to derive Exception. You can just write "instance Exception Foo"
13:24:52 <merijn> NemesisD: Provided Foo is Show and Typeable
13:25:00 <hpc> romm: and btw, i consider haskell's (->) to be syntax, since it is an unimplementable type
13:25:10 <ollehar1> jfischoff: will the code work for arbitrary large numbers, or just zero and one? type-level recursion is what got me in ocaml before. (also get funny errors in ghci...)
13:25:13 <hpc> and it doesn't follow haskell's rules for type constructors
13:25:36 <merijn> ollehar1: It will work for as large a number as the GHC typechecker can fit in your RAM
13:25:47 <hpc> romm: this is more along the lines of... actually the exact same thing
13:25:54 <romm> hpc: i don't understand your argument. i only agree that dropping lambda is questionable.
13:26:00 <hpc> romm: removing map, filter, foldr, because we have list comprehensions
13:26:07 <ollehar1> merijn: ah, good :)
13:26:14 <hpc> it's a bad idea in haskell and a bad idea in python
13:26:35 <hpc> end rant
13:26:40 <chrisdotcode> python needs better anonymous function support. lambdas are a not-so-good implementation ._.
13:27:14 <romm> hpc: heh, okay :) but know that you left me unconvinced :)
13:27:20 <romm> chrisdotcode: in what way?
13:27:28 <ab9rf> mmm
13:27:46 <chrisdotcode> romm: you can't pass them around, or return them easily, as you would in, say, javascript
13:27:56 <chrisdotcode> return function(foo) { return bar}
13:28:21 <chrisdotcode> in python, as you know, you have to seperately declare the function, then return it, which defeats the whole point of anon functions, IMO
13:28:28 <chrisdotcode> or, *one* of the purposes of anon functions
13:29:01 <hpc> chrisdotcode: "but if you give it a name you can do anything you want in the function!" /guido
13:29:16 <chrisdotcode> hpc: ._. I do like Python, but it has it's warts...
13:29:25 <chrisdotcode> I think a python/haskell mix would be my favorite language
13:30:02 <hpc> actually... i know what lambdas deny you
13:30:03 <romm> chrisdotcode: i guess that is indeed a con, but personally i don't think i would ever use such a feature.
13:30:04 <hpc> first-class IO!
13:30:21 <chrisdotcode> hpc: shh! I'm not at monads yet! :p
13:30:53 <romm> anyway, sorry for derailing the discussion off topic. back to LYAH to find what's so useful about this language :)
13:30:54 <hpc> i am throwing (IO a) parameters around constantly in my code
13:31:21 <hpc> trailing IO parameters are maybe my favorite style of coding
13:31:36 <hpc> withFile "/foo/bar.txt" $ \text -> do ...
13:31:54 <hpc> cgi . https . loggedIn $ do ...
13:32:11 <merijn> chrisdotcode: I thought that too and started designing a python/haskell hybrid. After some time I realised I was just designing haskell
13:32:31 <merijn> So I stopped and went back to haskell
13:32:38 <hpc> forkIO . loopWithLock $ \crit -> do ...
13:32:58 <chrisdotcode> merijn: thats why I'm also hesistant to start something like that. I feel if I knew more about haskell, the only things I would dislike about haskell are some minor syntatical things. like "\" for anon functions and "$" for application.
13:33:11 <hpc> ($) isn't syntactical
13:33:48 <chrisdotcode> how is it *not* a syntax choice? couldn't have very well been another symbol?
13:33:49 <hpc> '\' is probably my favorite part of haskell syntax
13:33:59 <hpc> lambda is so important, you don't have to press the shift key to type it
13:34:00 <merijn> chrisdotcode: It could
13:34:07 <hpc> @src ($)
13:34:08 <lambdabot> f $ x = f x
13:34:23 <merijn> > let (^) f x = f x in (+1) ^ 2
13:34:25 <lambdabot>   3
13:34:40 <merijn> > let (.) f x = f x in (+1) . 2
13:34:41 <lambdabot>   3
13:34:44 <Ontolog> hpc: actually i didn't even get to the point where i tried to run the code, just having trouble figuring out how to implement it. I think what I actually need is a type that just represents the Segments, instead of inferring them from the nodeVectors on a Node
13:34:45 <Xaratas> >94% runtime in one lambda are there obvious suggestions?: notCollidingLines = map (\(x,_,_,_) -> filter ((needed ==) . Set.size . Set.fromList . (x ++)) otherUniqueLines) nextReal
13:34:48 <hpc> > let (#) x f = f x in "twelve" # length # (+ 15)
13:34:50 <lambdabot>   <hint>:1:7: parse error on input `)'
13:34:59 <merijn> hpc: Magic hash :)
13:35:07 <hpc> bleeeech
13:35:25 <merijn> > let ( # ) x f = f x in "twelve" # length # (+15)
13:35:26 <lambdabot>   21
13:35:34 <chrisdotcode> hpc, merijn: ...okay. all of that went over my head.
13:35:55 <chrisdotcode> hpc: you were telling me about ($) right?
13:35:59 <merijn> chrisdotcode: We just defined a function identical to $, but with different symbols
13:35:59 <hpc> yes
13:36:04 <hpc> ($) is an ordinary function
13:36:06 <Xaratas> @ty (#)
13:36:08 <lambdabot> parse error on input `)'
13:36:18 <hpc> if you wanted to make it not an operator, it would be
13:36:19 <merijn> Xaratas: I defined it on that line, in the let
13:36:20 <dario> @ty ( # )
13:36:21 <hpc> apply f x = f x
13:36:22 <lambdabot> Not in scope: `#'
13:36:24 <chrisdotcode> merijn: oh, yes. now I see. didn't know haskell was *that* powerful...
13:36:30 <hpc> but that would be silly
13:36:33 <chrisdotcode> right
13:36:42 <chrisdotcode> can haskell do operator overloading?
13:36:51 <chrisdotcode> especially on abstract data types?
13:37:00 <merijn> chrisdotcode: Typeclasses are the closest thing
13:37:02 <Xaratas> merijn: ok, then it got over my head too
13:37:04 <hpc> type classes are for overloading
13:37:08 <merijn> Take a look at (+)
13:37:10 <hpc> operators are ordinary functions
13:37:31 <hpc> so when you see a freaky symbol in somebody's code, just remember
13:37:38 <hpc> they are an asshole for not using a regular named function ;)
13:37:39 <merijn> Xaratas: I defined a function named "#" that takes an argument and a function and applies them
13:38:10 <hpc> chrisdotcode: do you know how operator sections work yet?
13:38:13 <merijn> Xaratas: Since I only used operator symbols (the haskell report defines which those are) the function was an infix operator
13:38:16 <chrisdotcode> hpc: no, not yet
13:38:54 <hpc> chrisdotcode: enclose an infix function application in parens, like (x + 5), then just remove one side
13:38:57 <merijn> Xaratas: "apply f x = f x" is identical to "( # ) f x = f x", with the exception that apply is a function (i.e. prefix) and # is an operator (i.e. infix)
13:39:01 <hpc> so, (x +) or (+ 5)
13:39:22 <hpc> chrisdotcode: and those get replaced with \v -> x + v, or \v -> v + 5
13:39:44 <merijn> Xaratas: Do you understand this line?
13:39:58 <hpc> chrisdotcode: a quick way to leapfrog from newbie haskell programmer to intermediate is to take a few days to think about what ($ x) means
13:40:05 <hpc> or, \f -> f x
13:40:12 <merijn> > let apply x f = f x in apply (apply "twelve" length) (+15)
13:40:14 <lambdabot>   21
13:40:39 <chrisdotcode> hpc: yeah, thankfully LiveScript (the coffeescript fork) helped me understand awesome stuff like map (+15) [1,2,3]
13:40:48 <hpc> groovy
13:40:59 <chrisdotcode> so I didn't know what they were called, but I knew how they worked, and how awesome they were
13:41:01 <Xaratas> merijn: yes, now its only the "use as few signs as possible to name something" thing for which functional programmer tends to (hoffe man versteht mich)
13:41:18 <badkins> @pl \x y -> not (x && y)
13:41:18 <lambdabot> (not .) . (&&)
13:41:49 <merijn> Xaratas: Well, it was more of an example that "$" is just an ordinary function and not syntax, so you can define your own version of it
13:42:05 <chrisdotcode> "point free style" is what that's called, right?
13:42:07 <Xaratas> ok
13:42:11 <Botje> badkins: isn't that the same as (||) `on` not ? :)
13:42:12 <Xaratas> @pl \(x,_,_,_) -> filter ((needed ==) . Set.size . Set.fromList . (x ++)
13:42:12 <lambdabot> (line 1, column 7):
13:42:13 <lambdabot> unexpected "_"
13:42:13 <lambdabot> ambiguous use of a non associative operator
13:42:16 <hpc> point free style is different
13:42:39 <chrisdotcode> hpc: sin . cos . abs . (+2) ?
13:42:39 <hpc> but... kinda the same
13:42:44 <Xaratas> @pl \(x,_,_,_) -> filter ((needed ==) . Set.size . Set.fromList . (x ++) dataset)
13:42:45 <lambdabot> (line 1, column 7):
13:42:45 <lambdabot> unexpected "_"
13:42:45 <lambdabot> ambiguous use of a non associative operator
13:42:50 <hpc> yeah
13:42:53 <Xaratas> :/
13:43:02 <hpc> pointfree is when you replace \x -> sin . cos $ x with sin . cos
13:43:15 <geekosaur> there are no standard operations on n-tuples for n > 2
13:43:21 <geekosaur> so @pl can't do anything with them
13:43:27 <badkins> Botje what is on ?
13:43:29 <chrisdotcode> hpc: is that just for developer convience, or is "points free style" actual mathematical notation?
13:43:29 <hpc> which is mostly just dropping the "\x ->"
13:43:35 <Botje> @src on
13:43:36 <lambdabot> (*) `on` f = \x y -> f x * f y
13:44:04 <ixmatus> if Maybe is a type constructor and it has the kind * -> *; and Int is a concrete type and has the kind * what is "Just"? I understand it's a data constructor - but I don't know exactly "what" it is...
13:44:04 <Xaratas> (*) was short for map?
13:44:04 <hpc> chrisdotcode: i would say mostly the latter, in that instead of reasoning about functions by what values they take, you are reasoning about functions by what they are
13:44:31 <badkins> Botje deMorgan?
13:44:35 <chrisdotcode> so meta-functioning then...
13:44:40 <merijn> ixmatus: It's a data constructor, i.e. a value of type "a -> Maybe a"
13:44:43 * hackagebot utility-ht 0.0.9 - Various small helper functions for Lists, Maybes, Tuples, Functions  http://hackage.haskell.org/package/utility-ht-0.0.9 (HenningThielemann)
13:44:44 <Botje> ixmatus: just is a data constructor. it has a type a -> Maybe a.
13:44:44 <geekosaur> Xaratas, it's just a variable
13:44:50 <merijn> ixmatus: And "a -> Maybe a" has kind *
13:45:00 <hpc> chrisdotcode: no idea what "meta-functioning" is ;)
13:45:20 <merijn> Since a has kind *, Maybe a has kind * (follows from your own example) and (->) has kind * -> * -> *
13:45:30 <chrisdotcode> hahaha
13:45:34 <geekosaur> Xaratas: * there is an operator variable, which has to be wrapped in parens to be used as a parameter that way
13:45:47 <geekosaur> but then can be used as an operator in the definition
13:46:04 <chrisdotcode> but haskell seems beautiful for the most part. like I was saying before, I want to solve problems functionally, but I'm not sure where to "dive in". can reading real world haskell after LYAH help concrete it for me?
13:46:07 <hpc> it helps to keep in your head that everything is on the same level; functions and infix operators are no more special than ordinary things like "this is a string", or 5
13:46:29 <merijn> ixmatus: Make sense?
13:46:33 <hpc> after LYAH, i went to the "write your own IRC bot" page on the wiki
13:46:48 <hpc> just pick something to program, and make it
13:46:50 <ixmatus> merijn: do I have to "construct" in order to get a type reference for the data constructor? I know I cannot do: ":t Just"
13:47:00 <merijn> ixmatus: You can
13:47:02 <merijn> :t Just
13:47:04 <lambdabot> a -> Maybe a
13:47:17 <hpc> and to find libraries you need to make those things, use http://www.haskell.org/hoogle/
13:47:19 <ixmatus> oh poopy me - I was typing :k Just
13:47:24 <ixmatus> :-p
13:47:25 <merijn> ixmatus: Constructors behave identical to functions, the only difference being you can't pattern match functions
13:47:42 <merijn> > map Just [1..10]
13:47:43 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
13:47:44 <chrisdotcode> hpc: okay, sounds awesome! is haskell suitable for web development, in the sense that I can rapidly prototype? I know what snap is, but not more than that.
13:47:53 <ixmatus> okay - my question is silly then because I accidentally was typing ":k Just"
13:48:02 <merijn> ixmatus: It happens :)
13:48:09 <ixmatus> well, thanks :)
13:48:11 <hpc> it's definitely good for web dev
13:48:23 <ixmatus> and yes it definitely makes sense
13:48:25 <JoeyA> :k Just
13:48:25 <hpc> i wrote my website from scratch and i think it came out well
13:48:26 <lambdabot> Not in scope: type constructor or class `Just'
13:48:30 <JoeyA> :(
13:48:38 <hpc> it depends on SHA1 and hdbc-mysql, and that's it
13:48:39 <merijn> JoeyA: :k only works for things on the type level
13:48:42 <merijn> :k Either
13:48:43 <lambdabot> * -> * -> *
13:48:51 <JoeyA> ah
13:48:51 <chrisdotcode> hpc: was it a blog?
13:48:51 <ixmatus> because Just is a function it can't have a kind
13:48:51 <hpc> you should probably go with snap/happstack/yesod though :P
13:48:58 <JoeyA> Just :: * -> Maybe *
13:49:03 <hpc> just a blog, yeah
13:49:04 <JoeyA> Makes sense.
13:49:06 <merijn> ixmatus: Exactly
13:49:13 <hpc> dinky CGI thing with some user controls
13:49:15 <mightybyte> chrisdotcode: I think Haskell is fantastic for web dev
13:49:22 <merijn> JoeyA: Well, you could have that if you enabled DataKinds ;)
13:49:32 <JoeyA> :set -XDataKinds
13:49:34 <chrisdotcode> mightybyte: rapid prototyping and all
13:49:36 <chrisdotcode> ?
13:49:44 <mightybyte> Hah!  Funny you should ask.
13:50:06 <JoeyA> :set -XDependentTypes -- maybe one day
13:50:14 <merijn> JoeyA: You'll get "Just :: AnyK -> Maybe AnyK"
13:50:14 <mightybyte> I was just having a discussion with my coworker who is using fswatch to provide near instant updates when he changes a template.
13:50:54 <Fuco> how can I print loaded modules in ghci? I set my prompt to '> ' so I don't see them
13:51:06 <chrisdotcode> mightybyte: what framework/etc. are you using? I'd like to see some "real world" haskell code that is easy enough for a newbie to reason about with some effort
13:51:21 <ixmatus> chrisdotcode Haskell w/ Snap is actually pretty quick - what's "slower" is the relative lack of 3rd party libs that you kind of have to do yourself - but the framework core in both Snap and Yesod is very stable and mature
13:51:22 <parcs> Fuco: :show modules
13:51:39 <JoeyA> merijn: I get Just :: * -> Maybe * unless I enable PolyKinds, in which case I get Just :: k -> Maybe k
13:51:44 <mightybyte> chrisdotcode: I use Snap
13:51:46 <Fuco> parcs: thanks
13:52:00 <chrisdotcode> ixmatus: can't you do like 3million threads on consumer grade computer with haskell?
13:52:00 <merijn> JoeyA: I was using 7.4 for that, so maybe it changed in 7.6
13:52:29 <ixmatus> chrisdotcode Haskell's support for lightweight threads is excellent
13:52:36 <Xaratas> 3 mio threads would be a bad idea anyway
13:52:45 <ixmatus> but that's not the majority issue, right? I mean Erlang can do it too
13:52:55 <chrisdotcode> no, haha I was just curious
13:52:58 <JoeyA> Xaratas: what if it's one thread per I/O operation?
13:53:01 <mightybyte> chrisdotcode: The other frameworks focus more on generating markup from code, so the really fast template reloading that I described won't be as quick with them.
13:53:05 <rafaa> Hello! I have a list, a function and an initial value. My objective is computing a new list by applying the function to each element on the list and to the initial value. The function returns the value for the new list as long as the the value for the next iteration. I hope it's clear. I'm using Python, but I'm asking here because I think it's a FP construct which I don't know the name. It seems a foldl, but returns a vector instead of a
13:53:07 <rafaa>  single value, and the "accumulator" doesn't really accumulate anything
13:53:27 <JoeyA> You laugh (I assumed you laughed), but every time you call System.Timeout, it forks a thread.
13:53:38 <JoeyA> (and kills it on exit)
13:53:59 <Botje> rafaa: sounds like scanl. or mapAccumL
13:54:01 <Xaratas> hm
13:54:15 <Botje> :t mapAccumL
13:54:16 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:54:18 <JoeyA> > scanl (+) 0 [1..10]
13:54:20 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
13:54:33 <JoeyA> @src scanl
13:54:33 <lambdabot> scanl f q ls = q : case ls of
13:54:33 <lambdabot>     []   -> []
13:54:33 <lambdabot>     x:xs -> scanl f (f q x) xs
13:54:45 <JoeyA> ^ teh codes :-)
13:54:59 <mikeplus64> > mapAccumL (\a x -> (a + x, a - x)) 0 [0..10]
13:55:00 <lambdabot>   (55,[0,-1,-1,0,2,5,9,14,20,27,35])
13:55:14 <mikeplus64> > mapAccumL (\a x -> (a + x, a + x)) 0 [0..10]
13:55:16 <lambdabot>   (55,[0,1,3,6,10,15,21,28,36,45,55])
13:56:11 <rafaa> @Botje @JoeyA aaargh I'll need some time to decipher Haskell signature, but I think you got it
13:56:11 <lambdabot> usage: @vote <poll> <choice>
13:56:40 <JoeyA> uncurried form of mapAccumL, for clarity (at least to me): ((acc, x) -> (acc, y))   ->   (acc -> [x]) -> (acc, [y])
13:57:07 <JoeyA> @vote end_slavery aye
13:57:07 <lambdabot> No such poll:"end_slavery"
13:58:48 <mm_freak> merijn: my current approach is to keep the two separate
13:58:59 <mm_freak> there the world of interactions and the world of widgets
13:59:15 <mm_freak> widgets form two monoids with the same identity (horizontal and vertical)
13:59:16 <merijn> mm_freak: That's exactly what I think sucks about current UIs :)
13:59:37 <chrisdotcode> what do you guys think about elm?
13:59:42 <chrisdotcode> how close is it to haskell?
13:59:43 <mm_freak> merijn: no, it's actually useful, because you can do both:  you can keep them separate or do everything at once
14:00:12 <mm_freak> merijn: separate: liftA2 (,) label textField
14:00:23 <mm_freak> merijn: together:  label <> textField
14:00:41 <JoeyA> chrisdotcode: Elm is a nice introduction to FRP (functional reactive programming), and good for simple mockups.
14:00:56 <chrisdotcode> JoeyA: is it haskellesque?
14:01:00 <mm_freak> where:  instance (Monoid a) => Monoid (F a)
14:01:15 <JoeyA> chrisdotcode: yes.  It doesn't support type signatures yet, though
14:01:19 <JoeyA> (last time I checked)
14:01:45 <mightybyte> chrisdotcode: I like the looks of forml
14:02:15 <JoeyA> So for big stuff, you'll struggle.  Coding in regular Haskell will help you learn the language itself much better than Elm will.
14:02:24 <merijn> mm_freak: I don't see how that helps?
14:02:39 <mm_freak> merijn: what's the problem?
14:04:01 <merijn> I was finding myself with UI where parts of screen 1 rely on parts of screen 2, which made defining the code of their interactions very inconvenient, as would need to define both UIs before I could write the handler referring to the other UI
14:08:56 <Ontolog> so in Haskell I can't do this: let foo (x:xs) = x where x = read x :: Int
14:09:11 <Ontolog> is that a general rule that i can't redefine an identifier?
14:09:21 <Rembane_> Ontolog: Yes
14:09:35 <hpc> you are using the same x in every place
14:09:39 <ab9rf> you can shadow a prior definition but you cannot redefine it
14:09:39 <mm_freak> Ontolog: you can shadow identifiers in nested let/where clauses
14:09:40 <Lethalman> merijn, that's my feeling as well, and that mvc doesn't solve (and didn't solve in 30 years)
14:09:41 <Rembane_> Ontolog: That would break the pure part of the language.
14:09:43 <hpc> as a string, int, and [int]
14:09:46 <edwardk> x = read x is particularly insidious
14:09:49 <int-e> it's the x = read x that fails to type-check
14:09:57 <ab9rf> yeah, what would x = read x *mean*?
14:09:58 <dmwit> > let foo (x:xs) = x where x = read x in foo [()]
14:10:02 <lambdabot>   mueval-core: Time limit exceeded
14:10:04 <hpc> int-e: the other part is an infinite type error
14:10:08 <geekosaur> it's recursive
14:10:10 <dmwit> ab9rf: It would mean "be the string who is its own parse".
14:10:12 <geekosaur> except it doesn't typecheck
14:10:19 <ab9rf> dmwit: yeah, a fixed point
14:10:34 <int-e> hpc: oh. right, both bindings of x lead to a recursive type.
14:10:34 <mm_freak> Ontolog: shadowing/redefining does not mean "changing" though…  it's a good habit to read "=" as "equals", not "set to"
14:10:40 <int-e> > let a = a where a = 42 in a
14:10:42 <lambdabot>   42
14:10:49 <ab9rf> int-e: heh
14:10:56 <mm_freak> merijn: are you talking in netwire terms?  because in netwire this isn't actually a problem
14:11:24 <int-e> hpc: actually, no, my first diagnosis was the right one :)
14:11:28 <dmwit> Ontolog: In other words: no, it is not a general rule that you can't redefine an identifier.
14:11:31 <Lethalman> > do a <- return 10; a <- return 20; return a :: Maybe Int
14:11:33 <lambdabot>   Just 20
14:11:39 <Lethalman> :P
14:11:40 <mm_freak> merijn: rec r1 <- gui1 -< r2; r2 <- gui2 -< r1
14:11:43 <Lethalman> but this discussion was already done
14:11:47 <ab9rf> x = read x doesn't *re*define x
14:11:51 <ab9rf> it tries to define x, and fails
14:12:01 <dmwit> It tries to redefine x.
14:12:05 <dmwit> Because x is already in scope.
14:12:05 <Fuco> so foldM is like foldl, is there a version the other way around?
14:12:11 <ab9rf> dmwit: yes, if x had a prior definition
14:12:15 <dmwit> It does!
14:12:21 <int-e> > let foo (x:xs) = x where x = show x in foo [1]
14:12:21 <dmwit> It's bound by the pattern (x:xs).
14:12:22 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:12:25 <mm_freak> Fuco: like a foldrM?
14:12:26 <Ontolog> so how do we shadow?
14:12:35 <ab9rf> int-e: ha
14:12:38 <Fuco> mm_freak: yes
14:12:49 <Ontolog> lol wtf did lambdabot do?
14:12:49 <ab9rf> int-e: i'm sur ethat's useful for somethig
14:12:52 <dmwit> Ontolog: You shadowed just like you tried to do. Just keep in mind that the right-hand side of your equation sees the variable you're defining, not the shadowed one.
14:12:56 <ab9rf> Ontolog: what int-e told it ot
14:12:58 <int-e> it's a bit funny actually that 'where' can shadow left-hand sides.
14:13:02 <arkeet> > let x = show x in x
14:13:03 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:13:06 <int-e> ab9rf: I doubt it.
14:13:08 <int-e> :)
14:13:28 <dmwit> > let foo (x:xs) = x where x = xs in foo [()] -- Ontolog, this for example redefines x
14:13:30 <lambdabot>   []
14:13:30 <ab9rf> Ontolog: that's the start of the fixed point for the show function
14:13:56 <ab9rf> that's because wheres are bound later than the function's own pattern match, right?
14:13:57 <Ontolog> oh so i just had to add 'in foo' ?
14:14:06 <dmwit> Ontolog: No. You're focusing on the wrong part.
14:14:10 <merijn> mm_freak: Sure, but most GUIs don't seem to come with a netwire toolkit?
14:14:22 <hpc> ab9rf: where is bound between parameters and guards
14:14:22 <dmwit> Ontolog: The correct part to focus on is that the variable "x" doesn't appear on the right-hand side of its own definition in my example.
14:14:28 <staafl> is there a way of sectioning the minus operator with the 2nd operand
14:14:31 <ab9rf> hpc: thank you
14:14:35 <arkeet> staafl: subtract
14:14:35 <int-e> it's reall the same as   let foo (x:xs) = let x = xs in x ... where the behavior would not surprise anybody :)
14:14:37 <dmwit> Ontolog: (Generally, it is *allowed* to appear there -- but putting it there makes a recursive definition.)
14:14:40 <int-e> *really
14:14:41 <Ontolog> dmwit: ohhh it can't be on the righthand side
14:14:42 <arkeet> > subtract 3 5
14:14:43 <lambdabot>   2
14:14:44 <hpc> let-in is bound exactly where it appears
14:14:46 <Ontolog> oh
14:14:48 <staafl> arkeet, that was quick :-) thanks!
14:14:48 <meyersh> > /msg lambdabot > Data.ByteString.Base64.decode $ Data.ByteString.Char8.pack "SXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIG9iZnVzY2F0ZSBwYXNzd29yZHMgaW4gcHJvZ3JhbSB0ZXh0Pw=="
14:14:49 <lambdabot>   <hint>:1:1: parse error on input `/'
14:14:58 <Lethalman> merijn, there's any netwire web ui?
14:15:21 <merijn> Lethalman: Dunno, don't care. Web dev doesn't interest me
14:15:26 <Lethalman> ah
14:15:37 <dmwit> Ontolog: Here is a de-shadowed version of your original code, just so you can see what GHC thought of it.
14:15:38 <ab9rf> merijn: but that's the footur of da intarweb!
14:15:39 <Ontolog> oh i see, so i can redefine x just not in terms of itself
14:15:48 <dmwit> foo (x1:xs) = x2 where x2 = read x2 :: Int
14:16:03 <merijn> dmwit: read x1, presumably
14:16:08 <dmwit> merijn: nope!
14:16:16 <Ontolog> wtf im so confused
14:16:23 <arkeet> Ontolog: every time you "redefine" a variable, you're really making a new one and losing access to the old one.
14:16:30 <ab9rf> if it were x1 then x2 = read x1 would have a noninfinite type
14:16:33 <Ontolog> arkeet: yeah that was the original intention
14:16:36 <dmwit> Ontolog: This is clearly not what you *meant* to write; the question is whether you can see how GHC might believe that is what you meant.
14:16:43 <arkeet> ab9rf: no, it would have type String.
14:16:57 <merijn> dmwit: Ah, you were giving a broken example
14:17:01 <arkeet> > let x = read x in x
14:17:05 <lambdabot>   mueval-core: Time limit exceeded
14:17:05 <fizbin> What's the lens synonym of (flip (.)) ?
14:17:17 <dmwit> merijn: I gave exactly what I said I'd give: a de-shadowed version of his original code. =)
14:17:20 <edwardk> :t flip (.)
14:17:21 <ab9rf> arkeet: oh, it's a string that never generates anything in a finite time
14:17:22 <lambdabot> (a -> b) -> (b -> c) -> a -> c
14:17:23 <edwardk> :t (>>>)
14:17:24 <arkeet> fizbin: lens doesn't have one, but Control.Category has (>>>)
14:17:24 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
14:17:36 <merijn> dmwit: You can't expect to read what you said before!
14:17:36 <fizbin> I thought lens had one too.
14:17:39 <edwardk> we have flip ($), not flip (.)
14:17:42 <edwardk> t (&)
14:17:44 <edwardk> :t (&)
14:17:45 <mm_freak> Fuco: foldrM _ z [] = return z; foldrM f z (x:xs) = foldrM f z xs >>= f x
14:17:46 <lambdabot> a -> (a -> b) -> b
14:17:46 <fizbin> Ah, ok.
14:17:52 <danharaj> edwardk: do you know of a quick treatment of cofree recursive comonads?
14:18:08 <ab9rf> cofree makes me want coffee
14:18:14 <danharaj> coffee sounds good, brb
14:18:16 <mm_freak> Fuco: however, notice that this foldrM is likely very inefficient and unlike foldr it likely doesn't work for infinite lists
14:18:29 <merijn> mm_freak: My current sketch actually looks rather Wire like, so I'd hope that I can just convert the entire thing to Wires and use netwire to implement it :p
14:18:44 <mm_freak> merijn: would be great =)
14:19:13 <mm_freak> merijn: not that i'm in urgent need of a GUI wrapper, but it would be great to have one
14:19:15 <Ontolog> is it just me or does Vim's default auto indentation for haskell all wrong?
14:19:19 <Fuco> mm_freak: I'm using it to check paths in graph (finite) for a certain atribute using the Maybe monad
14:19:26 <Fuco> if the atribute is not present on the edge ->Nothing
14:19:39 <mm_freak> Fuco: are you sure you want foldrM for that?
14:19:40 <merijn> mm_freak: But that still means I have to solve the step of defining a GUI DSL that works well with such an approach, rather than having the current imperative "execute IO to create containers and attach handlers, etc" approach
14:19:43 <Fuco> so I foldr over zip p (tail p)
14:19:53 <Fuco> that's the list of edges
14:20:09 <Fuco> > let p = "abcd" in zip p (tail p)
14:20:11 <lambdabot>   [('a','b'),('b','c'),('c','d')]
14:20:47 <Fuco> hm, I guess I could just use foldM (flip whatever) :P
14:20:48 <mm_freak> merijn: there is a useful reader-like approach to identifier generation similar to what the reform library does
14:21:16 <mm_freak> merijn: you can generate a pure description of the GUI and then assign the various elements to actual toolkit objects
14:21:44 <dmwit> Ontolog: It is probably not just you.
14:21:47 <mm_freak> merijn: you can also use a state monad…  in that case every widget wire would fetch a new id in the first instant
14:21:48 <parcs> Ontolog: i personally turn off autoindentation
14:22:00 <parcs> Ontolog: why do i need a program to press tab for me? am i that lazy? :P
14:22:42 <ab9rf> parcs: i am so why shouldn't you be?
14:23:02 <mm_freak> Fuco: notice that all monadic folds depend on the strictness of (>>=) for the underlying monad
14:23:07 <ab9rf> i want the progrm to _type_ for me, ideally
14:23:41 <merijn> mm_freak: Although, presumably I'd want wires to do something like return TripleEither (GlobalEvent, CustomEvent, DisplayValue). So you could separate builtin things like focus/keypress from events generated by user code
14:24:54 <merijn> Unless I make the union of both event type the inhibition monoid and display the result otherwise...
14:26:00 <merijn> But if it inhibits I don't forward to any other wires, so if anything I guess displaying should be the inhibition and events the in and outputs...
14:26:49 <mm_freak> merijn: actually i'm asking myself whether it is a good idea to ignore branches which aren't reached
14:27:12 <merijn> Well, it makes sense in some contexts, but not in others
14:27:44 <mm_freak> merijn: yeah…  it seems to make writing GUI code more complicated, so i'm looking for a solution
14:27:53 <ab9rf> robert frost disagrees
14:28:00 <mm_freak> in networking code you definitely want that behavior, while for GUIs it's probably a bad idea
14:28:27 <mm_freak> merijn: my idea is to reintroduce the Reactive class, so that you can implement your own Wire type very easily
14:28:51 <merijn> It seems like you really want the "rendering" and event production to be separate for GUIs
14:28:58 <mm_freak> basic idea:  if you can define stepWire and mkGen you have a wire type and get all the prefabs and combinators for free
14:29:15 <merijn> What's mkGen?
14:29:20 <mm_freak> but now you're in control of the combination semantics
14:29:35 <merijn> (I'm too lazy to search the docs :p)
14:29:53 <mm_freak> mkGen is the constructor
14:30:00 <mm_freak> the "most general" wire constructor
14:30:26 <merijn> ah, right
14:31:09 <merijn> Maybe having the display value be in State monad and making it a wire over that is a better idea
14:31:24 <merijn> Then you just never inhibit
14:32:05 <mm_freak> well, consider this:  label . liftA2 (+) field1 field2
14:32:07 <Fuco> hm, now trying to filter through the Maybes... any nicer way to write this: (\x -> case x of Just x -> True; Nothing -> False)
14:32:14 <mm_freak> oh man
14:32:23 <mm_freak> i'm writing such a great library and using it wrong =)
14:32:29 <merijn> Fuco: catMaybe?
14:32:29 <ab9rf> heh
14:32:29 <mm_freak> label . (field 1 + field 2)
14:32:33 <mm_freak> there we go =)
14:32:33 <merijn> :t catMaybes
14:32:34 <lambdabot> [Maybe a] -> [a]
14:32:40 <Fuco> great ;)
14:32:50 <fizbin> :t isJust
14:32:51 <lambdabot> Maybe a -> Bool
14:33:01 <ab9rf> i have never found a way to construct GUIs that i find palatable.
14:33:07 <merijn> fizbin: I think he just wanted to filter out the Nothing's
14:33:15 <merijn> isJust is gross!
14:33:19 <mm_freak> merijn: if field1 inhibits, because its textField does not currently contain a number, then you don't see the label
14:34:09 <merijn> mm_freak: Isn't that more a matter of how/when you update the rendering of the widgets?
14:34:46 * hackagebot vector-space-map 0.1.0.0 - vector-space operations for finite maps using Data.Map  http://hackage.haskell.org/package/vector-space-map-0.1.0.0 (ChristianConkle)
14:35:26 <Fuco> wow, I didn't know you can pattern match like this: [x | Just x <- ls] << that gets rid of Nothings :O magic!
14:36:03 <Taneb> > fail "test" :: String
14:36:05 <lambdabot>   ""
14:36:05 <merijn> Fuco: That only works for MonadPlus, I think? Else it throws an exception if the match doesn't work
14:36:17 <mm_freak> merijn: no…  example:  you want a GUI that displays two text fields and a label…  the label should display the sum of the two text fields
14:36:23 <Taneb> merijn, I think it works for things with a non-default fail definition
14:36:36 <mm_freak> merijn: ideally such a GUI would look like this:  label . (field1 + field2)
14:36:47 <mm_freak> but with the current semantics of netwire this doesn't work
14:36:52 <Fuco> ah, might be. Maybe is a MonadPlus I suppose
14:36:57 <mm_freak> the label would not be visible until you actually enter valid numbers
14:37:01 <merijn> hmmm
14:37:22 <mm_freak> in particular this is impossible:  (label <|> "please enter valid numbers") . (field1 + field2)
14:38:02 <mm_freak> well…  caption "please enter valid numbers"
14:39:02 <merijn> Wait, how would that one work? What's the type of label and caption supposed to be?
14:40:00 <parcs> > fmap fix return1
14:40:02 <lambdabot>   Not in scope: `return1'
14:40:02 <lambdabot>  Perhaps you meant one of these:
14:40:02 <lambdabot>    `return' (impor...
14:45:17 <mm_freak> merijn: well, something like:  label :: (HasStringContent a) => GUI a Widget
14:45:28 <mm_freak> and caption is basically a static version of label
14:45:57 <merijn> Has someone defined a type level Set yet? I guess not?
14:47:49 <monochrom> I want Type Level Haskell
14:48:20 <merijn> monochrom: Me too!
14:48:21 <hpc> monochrom: oleg has a website, you know ;)
14:49:03 <otters> where all the work is done by the compiler
14:49:04 <monochrom> yeah but he hasn't done "delimited control at the type level"!
14:52:37 * Pentium i wont One DDoS-er`d have anyone here ?
14:52:48 <jfischoff> is there a reason why the is not a package that implements the data type a la carte style of effects for all the things in System like getCurrentDirectory, etc?
14:53:01 <jfischoff> s /the/there
14:54:04 <hpc> jfischoff: lots of typing? :P
14:54:18 * Pentium  Visite This WebSite Please Wait To Open  wWw.AlbCom.Org
14:54:25 * Pentium  Visite This WebSite Please Wait To Open  wWw.AlbCom.Org
14:54:31 * Pentium  Visite This WebSite Please Wait To Open  wWw.AlbCom.Org
14:54:32 --- mode: ChanServ set +o monochrom
14:54:35 --- mode: monochrom set +b *!*@79.106.109.251
14:54:35 --- kick: Pentium was kicked by monochrom (Pentium)
14:54:36 <jfischoff> hpc: in theory would it work?
14:56:09 <Ontolog> i still can't get my head around something in Haskell
14:56:34 --- mode: monochrom set -b *!*@79.106.109.251
14:56:34 <hpc> jfischoff: i don't totally remember the paper, and links to it are 404ing
14:56:38 --- mode: monochrom set -o monochrom
14:56:55 <hpc> but i can think of many ways to implement the ultimate goal
14:57:08 <Ontolog> I have a recursive data structure, and two instances of this structure should refer to each other
14:57:15 <jfischoff> hpc: http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf does that work?
14:57:33 <Ontolog> like how does a node in a recursive data structure refer to another node, where both nodes are currently being defined
14:57:56 <jfischoff> Ontolog: just try it
14:58:03 <merijn> hmm, is there a way I can do if/else in type funs?
14:58:15 <jfischoff> merjin: yes
14:58:23 <hpc> Ontolog: implementation-wise, it could be done in a similar way you would make a circular linked list in C
14:58:28 <merijn> I want to return x iff two types unify and something else otherwise
14:58:33 <merijn> jfischoff: How?
14:58:33 <hpc> list a, b;
14:58:39 <hpc> a.next = b;
14:58:41 <hpc> b.next = a;
14:58:56 <Ontolog> exactly
14:59:02 <jfischoff> merijn: https://github.com/goldfirere/singletons/blob/master/devel/Test/ByHand.hs#L122
14:59:19 <Ontolog> but isn't that like: where a = b + 1; b = a + 1 ?
14:59:28 <hpc> Ontolog: as far as language semantics goes, it helps to just learn the rules of construction and pattern matching and evaluation in general
14:59:44 <hpc> and then the recursive definitions will just make sense
14:59:49 <merijn> jfischoff: Yeah, but I don't know how to get Bool
14:59:58 <hpc> Ontolog: it is; (+) is a strict function though
15:00:08 <hpc> before we can get anywhere on the result, we need to evaluate the arguments
15:00:25 <merijn> jfischoff: I have "type instance Foo a (x ': xs)" and want to return False if (a ~ x) and something else if not
15:00:34 <mm_freak> nitpick:  (+) is not strict, but (+) for most predefined types is
15:00:39 <hpc> and so to evaluate a we need to evaluate b and so we need to evaluate a...
15:00:44 <hpc> er yes, that
15:00:51 <jfischoff> merijn: you make an instance of :==: for your types
15:01:03 <hpc> (+) on a lazy Nat type will be quite happy to crunch through your a, b definitions
15:01:11 <hpc> and the result will be ω
15:01:25 <Ptival> @djinn (a -> b -> c -> d) -> (d -> e -> f -> g) -> (a -> b -> c -> e -> f -> g)
15:01:26 <lambdabot> f a b c d e = b (a c d e)
15:01:44 <hpc> (if you write (+) to match on the right)
15:01:53 <shachaf> @djinn (a -> b -> c -> d) -> (d -> q) -> a -> b -> c -> q
15:02:01 <hpc> Ontolog: let's take a basic example
15:02:03 <merijn> jfischoff: Is :==: defined somewhere or?
15:02:08 <hpc> data Nat = Zero | Succ Nat
15:02:11 <lambdabot> f a b c d e = b (a c d e)
15:02:19 <hpc> a = Succ b; b = Succ a
15:02:25 <shachaf> @@ @pl @djinn (a -> b -> c -> d) -> (d -> q) -> a -> b -> c -> q
15:02:26 <lambdabot>  f = flip ((.) . (.) . (.))
15:02:26 <hpc> now we evaluate a
15:02:27 <jfischoff> merijn: not really. Its in the singleton package
15:02:35 <hpc> we match on the constructor and immediately see it is Succ
15:02:40 <jfischoff> merijn: wait
15:02:44 <hpc> we want to go further; let's match on b
15:02:51 <hpc> we immediately see the constructor is Succ
15:02:56 <merijn> jfischoff: oh, blah. That means I'd have to define :==: for every possible permutation of types by the way it looks...
15:02:58 <hpc> now we want to go further again, so we match on a
15:03:04 <hpc> oh hey! it's already evaluated
15:03:09 <hpc> etc, etc
15:03:29 <hpc> but we have stopping points at every constructor
15:03:44 <hpc> if all we care about is (Succ (Succ _)), we can see that
15:03:56 <hpc> if we want 4 Succs, we can make two rounds through the cycle
15:03:59 <jfischoff> merijn: Its only slightly worse then what one does in the value world
15:04:24 <merijn> No, because in the value world I can derive it
15:04:36 <merijn> Also, I want it to work for arbitrary types, so still no luck
15:05:20 <jfischoff> merijn: the singleton library will derive it for you
15:05:55 <carter> jfischoff what build flavor for ghc were you doing?
15:06:17 <jfischoff> merijn: assuming they are part of the same kind family
15:06:24 <jfischoff> carter: devel2
15:06:33 <carter> jfischoff ok i'll try that again later
15:07:12 <carter> thanks
15:07:18 <jfischoff> np
15:07:23 <carter> i had things die when i tried quick-llvm
15:08:06 <merijn> jfischoff: I think I only need equality on *, so that should be ok
15:09:05 <merijn> That should be sufficient to define a type level set, I think
15:09:20 <hpaste> arbn pasted “avoid undefined?” at http://hpaste.org/85437
15:09:55 <arbn> Yo. Any advice on how to avoid passing undefined there?
15:10:10 <arbn> It works, but I think there should be a better way.
15:10:10 <jfischoff> merijn: Set is related to this https://gist.github.com/jfischoff/4034291
15:10:45 <shachaf> By passing an actual value of type a?
15:10:49 * shachaf isn't sure what's going on there.
15:11:09 <hpc> what type is undefined being used as?
15:11:41 <arbn> shachaf, hpc: XmlTree
15:12:16 <arbn> This is using HXT.
15:12:29 <shachaf> Are you sure?
15:12:44 <shachaf> You have "LA XmlTree something"?
15:13:34 <quchen> arbn: Add "data Hole = Hole", replace "unknown" with "Hole", look at the compiler error. It'll tell you the type of Hole.
15:13:50 <augur> quchen: blegh
15:13:53 <augur> fake holes :|
15:14:11 <quchen> arbn: Update GHC, and in an hour write _hole. It's way cleaner!
15:14:12 <danharaj> What is foldl to [] if foldr is its catamorphism?
15:14:42 <shachaf> danharaj: a weirdomorphism hth
15:14:51 <danharaj> :|
15:15:35 <merijn> jfischoff: hmm, but with Data.Singletons I get an error on when I try to do ":t undefined :: Char :==: Int", shouldn't that just work?
15:15:46 <arbn> "Couldn't match expected type `XmlTree' with actual type `Hole'"
15:15:52 <sproingie> prepozygohistomorphicexpialidocious
15:16:06 <shachaf> danharaj: foldl doesn't really fold with the structure of the list at all
15:16:09 <ab9rf> gesundheit
15:16:15 <danharaj> shachaf: correct
15:16:22 <danharaj> shachaf: but it's not like foldl is a bizarre function.
15:16:35 <mm_freak> supercalifragilisticexpialidomorphism
15:16:36 <shachaf> Just because it has the word "fold" in its name doesn't mean there's going to be a name for it ending in "omorphism".
15:16:44 <arbn> schlumpi: So, yes, I am sure that is XmlTree.
15:16:48 <ab9rf> it's a twistomorphism :)
15:16:50 <danharaj> I did not imply that that is what I expected.
15:16:51 <arbn> shachaf: ^^
15:16:52 <sproingie> nosuchmorphism
15:16:59 <Nisstyre> morphomorphism
15:17:07 <ab9rf> misanthromorphism
15:17:15 <mm_freak> mormonorphism
15:17:20 <bscarlet> lesphism?
15:17:21 <typoclass> miscmorphism
15:17:33 <geekosaur> antimorphism
15:17:38 <sproingie> dreadedmonomorphism
15:17:39 <typoclass> othermorphism
15:17:48 <mm_freak> "oh my god!  i'm getting an orphism!"
15:17:50 <typoclass> notsureifmorphism
15:18:19 <sproingie> roflmorphism
15:18:25 <yabadaba> hi
15:18:35 <acowley> Good news everyone, the great orphism shortage is finally over!
15:18:38 <quchen> Good evening, sir.
15:18:44 <merijn> Unless I still need to explicitly list the types I want to compare with Singletons, in which case the library still doesn't get me anything :\
15:18:45 <ab9rf> orphiorphism
15:18:50 <yabadaba> and irc bot linked to an interpreted, that would b cool
15:19:04 <taylorgb> orphism shortage or morphism shortage
15:19:43 <sproingie> there's a shortage of the letter ''
15:19:51 <acowley> I'm willing to drop the "m" constraint for the sake of all those young haskellers out there
15:19:55 <merijn> Bah, type funs is so close, yet so far away from something useful :(
15:19:59 <quchen> yabadaba: An interpreted bot? We have Lambdabot. She's occasionally mean but in general very helpful.
15:20:04 <Fuco> what is ~: forcePair ~(x,y) = (x,y)
15:20:20 <acowley> irrefutable pattern match
15:20:25 <merijn> Fuco: Lazy pattern match
15:20:26 <jfischoff> merijn: no to your first question, yes to your second ;)
15:20:29 <yabadaba> thank you quchen
15:20:39 <hpc> in this case, forcePair is also a lie of a function name
15:20:48 <jfischoff> merjin: I guess it wasn't a question :p
15:20:49 <Fuco> lazy meaning what exactly?
15:20:52 <hpc> or a very clever half-truth
15:20:55 <merijn> jfischoff: If I don't, then why is it apparently not working?
15:20:59 <acowley> what was the reasoning behind that name choice?
15:21:20 <geekosaur> it's not checked until something in the pattern is actually evaluated, instead of being checked up front (strictly)
15:21:23 <merijn> jfischoff: Oh wait, I misparsed
15:21:25 <merijn> ok
15:21:26 <merijn> dammit
15:21:44 <Fuco> aha, right. Makes sense. Thanks
15:21:47 <merijn> This shouldn't be so hard to define :(
15:21:50 <quchen> Fuco: When you're pattern matching against (a,b), the program has to check whether you've got a tuple in the first place, and then match a and b. An irrefutable promises "don't worry, the pattern will always match, don't bother checking whether it actually has the form".
15:22:00 <nart> hi
15:22:04 <jfischoff> merijn: no it shouldn't
15:22:09 <quchen> If you break the promise the program is going to be angry though.
15:22:27 <hpc> Fuco: in your specific case, without a tilde the logic is
15:22:33 <merijn> I guess I'll have to hack something together with typeclasses, but then I need ugly typeclass constraints on everything :(
15:22:45 <jfischoff> jfischoff: what are you trying to do?
15:22:47 <typoclass> > (\(~(a,b)) -> 123) undefined -- Fuco, here is an example
15:22:48 <lambdabot>   123
15:22:54 <jfischoff> err
15:22:55 <typoclass> > (\((a,b)) -> 123) undefined -- compare
15:22:57 <lambdabot>   *Exception: Prelude.undefined
15:23:00 <hpc> "when forcing the result of forcePair tuple", we must first force the tuple
15:23:03 <jfischoff> merijn: what are you trying to do?
15:23:05 <hpc> and with a tilde, the result is
15:23:07 <hpc> "when forcing the result of forcePair tuple", we must first force the tuple
15:23:09 <hpc> :P
15:23:38 <arbn> Woah. I just changed the type only on another function to "ArrowXml a => ... -> a () XmlTree", and then passed () instead of undefined, and it works with the same expressions.
15:23:44 <merijn> jfischoff: Have a list of types and check whether a given type is already in it and prevent duplicates
15:23:58 <yabadaba> is it ok to give this to lambdabot (\a b -> a + b) 1 2 because im geting the silence treatment
15:24:15 <merijn> So "type family Elem :: * -> [*] -> Bool"
15:24:16 <Fuco> right, thanks guys. Seems like it might be useful sometime :P I've just noticed it randomly and it seemed interesting :P
15:24:16 <quchen> yabadaba: Put "> " in front of it.
15:24:17 <sproingie> you need to add a > at the beginning of the line
15:24:19 <elliott> > (\a b -> a + b) 1 2
15:24:20 <lambdabot>   3
15:24:24 <sproingie> even when pm'ing the bot
15:24:31 <quchen> Yes.
15:24:36 <yabadaba> i did private ok lol
15:25:11 <merijn> jfischoff: And "type family Union :: [*] -> [*] -> [*]"
15:25:35 <merijn> But without equality on * those are hard/impossible to write
15:26:10 <jfischoff> merijn: I wonder if we could use ~ directly for this?
15:26:19 <jfischoff> merijn: my guess is yes
15:26:30 <merijn> jfischoff: I thought so too, but I can't figure out how
15:26:40 <merijn> I dunno how to add a constraint to a type instance
15:27:07 <jfischoff> merijn: yeah we need constraints
15:27:55 <merijn> You'd want "If (a ~ b) True False"
15:28:16 <merijn> But (a ~ b) is not something you can match on
15:28:24 <feliperosa> What (~) means?
15:28:51 <merijn> feliperosa: "a ~ b" means that a and b unify (i.e. can be the same type)
15:29:18 <feliperosa> merijn: Oh, right. Thanks :)
15:30:15 <__xc> :t (~)
15:30:17 <lambdabot> parse error on input `)'
15:30:26 <hpc> :k (~)
15:30:28 <merijn> __xc: It on the type level
15:30:28 <lambdabot> AnyK -> AnyK -> Constraint
15:30:42 <__xc> yes thought
15:30:57 <elliott> you can do type-level decidable equality nowadays
15:30:58 <elliott> in GHC head
15:31:02 <elliott> using overlapping type families
15:31:09 <__xc> :t ( Int ~ Int)
15:31:11 <lambdabot>     Not in scope: data constructor `Int'
15:31:11 <lambdabot>     Perhaps you meant one of these: `In' (line 124), `InR' (line 131)
15:31:11 <lambdabot> Pattern syntax in expression context: ~Int
15:31:15 <merijn> Wouldn't it be possible to implement Constraint -> Bool or whatever?
15:31:16 <__xc> :k ( Int ~ Int)
15:31:17 <lambdabot> Constraint
15:31:25 <elliott> merijn: no, that would violate open world assumption
15:31:43 <elliott> adding new instances shouldn't change behaviour
15:31:48 <merijn> elliott: The open world assumption can blow a goat, it keeps screwing with my ability to write code
15:32:03 <elliott> its lack would screw with you even more
15:32:09 <elliott> and also with the compiler writers
15:32:17 <merijn> I wish I could explicitly close type families...
15:32:31 <merijn> I wish the same for typeclasses, tbh
15:32:44 <merijn> elliott: So how can I do equality in head?
15:32:59 <elliott> type family Equal a b :: Bool; type instance where Equal a a = True; Equal a b = False
15:33:11 <ocharles> The order of that matters, right?
15:33:17 <jfischoff> oh right richard added that
15:33:38 <jfischoff> singtetons author
15:33:42 <merijn> elliott: So in head you can get type families where order matters?
15:33:45 <hpc> elliott: i think the rule is instance specificity?
15:34:03 <hpc> type families are meant to be open, so you can't have order-sensitivity
15:34:08 <ocharles> jfischoff: eisenberg, i believe
15:34:17 <hpc> otherwise, you can engineer a situation where the order of imports changes semantics
15:34:18 * jfischoff nods
15:35:14 <__xc> in my opinion singletons can always be avoided
15:35:31 <__xc> (just randomly)
15:35:36 <merijn> __xc: Singletons doesn't do what you think it does
15:35:38 <elliott> merijn: overlapping, yes
15:35:53 <elliott> hpc: in "type instance where", order matters
15:35:54 <merijn> elliott: That already solves my problem without needing equality
15:36:05 <__xc> merijn, yu mean specifically http://hackage.haskell.org/package/singletons?
15:36:05 <elliott> merijn: it's the same behind the scenes
15:36:07 <merijn> Since I can then just write "    Insertable x (x ': xs) = False"
15:36:34 <merijn> Or Elem and reverse the return value
15:36:45 <merijn> __xc: Yes
15:37:07 <merijn> Time to delete 7.6 and install HEAD...
15:37:30 <merijn> Do I really need HEAD or is the latest binary new enough?
15:40:15 <dimka> How can I compose f ∷ α → IO (Maybe α), g ∷ α → IO (Maybe α) and h ∷ α → Maybe β in something like ~ (h . g . f) ∷ α → IO (Maybe β) ?
15:40:34 <jfischoff> :t (<=<)
15:40:35 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:40:56 <yabadaba> someone a while back asked what ~ means, wikipedia explains nicely. i have and example for lamdabot
15:41:11 <yabadaba> (\f a (x, y) -> f a) (1+) 2 undefined
15:41:34 <yabadaba> shold give Program error: Prelude.undefined
15:41:41 <yabadaba> while
15:41:49 <merijn> elliott: Do I really need HEAD or is the latest binary sufficient?
15:41:51 <yabadaba> (\f a ~(x, y) -> f a) (1+) 2 undefined
15:41:57 <yabadaba> should be 3
15:42:00 <ocharles> yabadaba: different ~
15:42:05 <yabadaba> ok sry
15:42:17 <ocharles> irrefutible pattern matching is different from ~ in constraints
15:42:28 <yabadaba> ooooohhhkay
15:42:49 <dmwit> dimka: MaybeT f >=> MaybeT g >=> lift . h
15:43:03 <dmwit> uh
15:43:05 <dimka> ohlord
15:43:09 <dmwit> dimka: last one isn't lift
15:43:23 <dmwit> but are you sure you got h's type right? it looks unlike the other two, so I just want to make sure
15:43:36 <elliott> merijn: latest binary should work
15:43:50 <dimka> dmwit: yep, last one is without IO
15:43:54 <dmwit> okay
15:44:14 <merijn> Wait..latest binary appears to be 7.6.2 that seems suspiciously old
15:44:34 <dmwit> MaybeT . f >=> MaybeT . g >=> MaybeT . fmap return . h
15:44:52 <dmwit> Or just redefine them to work in the MaybeT IO monad to begin with.
15:45:11 <dmwit> :t \f g h -> MaybeT . f >=> MaybeT . g >=> MaybeT . fmap return . h
15:45:13 <lambdabot> Not in scope: data constructor `MaybeT'
15:45:13 <lambdabot> Not in scope: data constructor `MaybeT'
15:45:13 <lambdabot> Not in scope: data constructor `MaybeT'
15:45:13 <dimka> MaybeT from maybet package?
15:45:21 <dmwit> heh, whoops
15:45:35 <dmwit> hm, no
15:46:00 <dmwit> dimka: MaybeT from transformers
15:46:19 <dimka> Oh, got it
15:46:43 <__xc> what does the singleton type @Bool@ achieve more than native Bool for example?
15:47:19 <dmwit> Seems the last one should be MaybeT . return . h
15:47:21 <dmwit> phew!
15:47:29 <dmwit> Took a few tries, but ghci finally agrees that I'm right. ;-)
15:47:30 <merijn> __xc: It's for hoisting things to the type level
15:47:59 <dmwit> __xc: There is no singleton type Bool. There are singleton types True and False of kind Bool.
15:48:13 <dmwit> (or some types isomorphic to this situation)
15:48:16 <ocharles> __xc: read the singletons paper linked from that package - it's not hard and the first few pages should provide you with enough context
15:48:32 <__xc> so you define a function String -> @Bool@ ->  @Bool@  fo example
15:49:08 <jfischoff> __xc: Bool is a kind, and has types True' and False'
15:49:09 <__xc> ocharles, ocharles ah yes this link works
15:49:15 <merijn> __xc: No, it's so you can define type functions for things like "foo :: Foo True -> Baz"
15:49:17 * jfischoff hopes he remembers correctly
15:49:31 <merijn> jfischoff: 'True, but close enough ;)
15:49:37 <jfischoff> oh right
15:50:12 <merijn> ok, I'll try installing 7.6.2 and the 7.7 source tomorrow
15:50:13 <__xc> ok thx
15:50:15 <merijn> It's bed time
15:51:15 <merijn> And then afterwards I need to declare my undying love for whoever got that to work
15:51:22 <jfischoff> merijn: have a good night!
15:53:28 <__xc> :k Bool
15:53:29 <lambdabot> *
15:53:57 <__xc> :t True
15:53:59 <lambdabot> Bool
15:54:21 <jfischoff> :t 'True
15:54:22 <lambdabot>     Syntax error on 'True
15:54:23 <lambdabot>     Perhaps you intended to use -XTemplateHaskell
15:54:35 <jfischoff> so we don't have DataKinds on
16:28:49 <tibbe> I think I have implemented a reverse state monad by mistake. :(
16:29:04 <tibbe> I was trying to extend a byte string builder with information on how many bytes have been written so far.
16:29:17 <tibbe> And the numbers I'm getting suggest I'm getting the values tunneled back from the future. :/
16:29:29 <c_wraith> it's really impressive to do that accidentally
16:29:57 <lavorno> sounds like ray bradbury "breaking the time continuum in haskell"
16:30:02 <lavorno> :)
16:30:19 <c_wraith> well, reverse state is a well-known time-travel monad. You just don't usually get it accidentally
16:30:30 <sipa> i accidentally causality
16:30:50 <lavorno> c_wraith: can i use it to travel to a place where i understand how to use exceptions in haskell ?
16:30:56 <lavorno> (or to a time0
16:31:18 <c_wraith> It's restricted to things that are easier to calculate
16:31:45 <cannon10100> Hello!
16:31:58 <lavorno> hi
16:32:40 <tibbe> c_wraith: it might not be what I actually did, but the output looks like it
16:32:54 <tibbe> c_wraith: it has a distinct "value travel in both directions" behavior
16:33:04 <ab9rf> what, haskell has retrotemporality support?
16:33:29 <c_wraith> (it's really just knot-tying in an unexpected way)
16:34:01 <c_wraith> tibbe: is it possible you're actually having state travel forward, but being evaluated in a different order than you expect?
16:34:28 <sipa> ab9rf: it used to
16:34:34 <sipa> :p
16:34:35 <tibbe> c_wraith: anything is possible at this stage
16:34:42 <tibbe> but the code seems to simple to be wrong
16:34:44 <ab9rf> sipa: and will once again, but not today?
16:34:46 * tibbe goes and thinks
16:34:52 <ab9rf> jam yesterday, jam tomorrow, but never jam today
16:34:59 <typoclass> @remember tibbe I think I have implemented a reverse state monad by mistake. The numbers suggest I'm getting the values tunneled back from the future. :/
16:34:59 <lambdabot> Nice!
16:38:23 <lavorno> question : where is a good place to read about the latest / best approach to do exception handling in haskell ? large apps
16:40:07 <simpson> lavorno: Mu. It depends on what you're building.
16:40:33 <simpson> lavorno: Many times it is preferable to avoid exceptions altogether. What are you doing with them?
16:40:43 <lavorno> simpson: large app, parsing, arrows, io
16:40:52 <lavorno> pure and impure
16:41:04 <lavorno> just want an unified approach
16:41:36 <lavorno> and i've read abt maybe, either, exc, etc.. but nobody seems to agree on what's "the best approach"
16:41:44 <lavorno> and the notes i've found are a few years old
16:41:47 <c_wraith> that's because there isn't a best approach
16:41:50 <pygmalion> In OCaml you can replace parentheses with begin..end, is there any equivalent way to group code in Haskell? I'm just thinking about long case clauses (or possibly nested) )for example. or is the parser generally robust enough to not run into issues?
16:41:59 <lavorno> c_wraith: ?
16:42:25 <c_wraith> lavorno: there are a lot of different approaches because there are a lot of different things you may want to communicate
16:42:33 <c_wraith> lavorno: no approach works for all of them
16:42:55 <lavorno> c_wraith: great point, ok let's get some examples
16:43:09 <tibbe> for pure code it's basically Maybe if there's one "error value" and Either if there are more
16:43:10 <c_wraith> lavorno: however, there are libraries available to help you manage different things and convert between them in a way that makes sense for you
16:43:17 <c_wraith> lavorno: http://hackage.haskell.org/package/errors is an example
16:43:35 <lavorno> c_wraith: i've read that and still unclear :)
16:44:04 <lavorno> tibbe: sounds good but how does either play with arrows ?
16:44:27 <tibbe> lavorno: don't know, after 8 or so years of haskell I've never used arrows
16:44:51 <lavorno> tibbe: hmmm... so are you saying i should just try something else? :)
16:45:10 <tibbe> lavorno: perhaps you're problem is a perfect fit for arrows, I've just never found such a problem
16:45:15 <lavorno> tibbe: besides the exception handling part - everything works great so far
16:45:18 <c_wraith> hxt is the only real project that uses arrows, and people mostly are moving away from it because arrows really aren't that good.
16:45:43 <tibbe> there was a lot of hulabalua about arrows for a short while (on the topic of parsing). I've never really seen them come up again
16:45:46 <lavorno> c_wraith ; i am using hxt as well and i love it..
16:46:00 <tibbe> that's the only library I've tried that uses them
16:46:06 <tibbe> they mostly get me confused
16:46:16 <tibbe> but they did work ok in hxt
16:46:24 <lavorno> tibbe: yes, i liked hxt lib v much..
16:46:28 <tibbe> (but then again, I haven't tried any other xml libraries)
16:46:46 <lavorno> tibbe: played a bit with other and are a lot less semantically rich
16:46:52 <lavorno> (others)
16:47:09 <c_wraith> edwardk likes to talk about how hxt is actually an example of arrows being the wrong abstraction. He says that most of the type signatures in it indicate that they aren't actually using the full abstraction, and a much simpler alternative would work just as well
16:47:12 <lavorno> but all suffer of the same problem.. not a unified approack
16:47:25 <ab9rf> one library to rule them all
16:47:41 <lavorno> c_wraith: i would love to hear / read that talk.. can you pls share more details ?
16:47:43 <dmwit> pygmalion: I'm not sure why the last question makes sense, but there aren't a lot of alternatives to parentheses in Haskell.
16:47:50 <dmwit> pygmalion: You can eliminate some with ($), but not all.
16:47:58 <c_wraith> dmwit: named expressions
16:48:16 <dmwit> I don't see that named expressions are special to Haskell (compared to OCaml).
16:48:45 <c_wraith> They're not. They're just the most reliable way to get rid of parens (in expressions)
16:49:23 <c_wraith> lavorno: it was actually in here. I suppose I could check public logs to see if I can find it
16:49:30 <lavorno> c_wraith: also, if there is a simpler abstraction that is working as well as hxt (or better) i will try it and report back - just need the pointer where to find it
16:49:55 <lavorno> c_wraith: thanks
16:50:55 <ab9rf> what's wrong with parentheses?
16:50:57 <typoclass> pygmalion: you could always pull out parts of an expression into 'where' or 'let', in order to improve readability
16:51:32 <dmwit> typoclass: Is this not what "named expressions" meant?
16:52:24 <lavorno> c_wraith: i'll have to go deal with some impure things, but will leave this on, pls just post the link here when you find it - tx again
16:53:24 <typoclass> dmwit: i'm not sure. i read this as being some technical term for a feature that haskell and ocaml have
16:54:00 <dmwit> Yes. That feature is let/where binding. =)
16:54:19 <c_wraith> lavorno: found it at http://ircbrowse.net/browse/haskell?id=14560256&timestamp=1352701666#t1352701666
16:54:42 <ab9rf> dmwit: we need to add that right away :)
16:55:06 <typoclass> dmwit: ok! :-) then i guess i reiterated your comments more concretely, and possibly that was unnecessary
16:57:24 <pygmalion> dmwit, typoclass: Yeah, more lets and wheres is probably the answer. I think it's actually not an issue as much in Haskell as in OCaml. In OCaml the parser gets choked up on nested cases or conditionals if you don't parenthesize them. Doesn't seem to be the case here.
16:57:26 <lavorno> c_wraith: tx - browsed quickly and they are just discussing how arrows are not necessarily a good concept but there is a lot of work in a xml parsing library.. i don't want to re-write hxt by myself.. any other alternative ?
16:57:52 <dmwit> pygmalion: Well, having layout helps a lot.
16:58:00 <dmwit> pygmalion: Way fewer things need to be parenthesized to begin with.
16:58:16 <pygmalion> dmwit: Yeah, which is quite nice.
16:58:36 <lavorno> i am not edvanced enough to catch the finer nuances edwardk is referring to. for me hxt works great so far. just want to add some exception handling and was wandering what's the best approach..
17:00:20 <typoclass> lavorno: i didn't understand the irc conversation as saying that hxt is terrible, just that if they started the hxt project today, they would probably write it slightly differently because in the meantime, Applicative has been invented
17:02:37 <c_wraith> Yeah..  The upshot isn't "don't use hxt", it's "Arrows weren't a good fit there, either"
17:02:44 <c_wraith> hxt still has plenty going for it, as a library
17:04:35 <monochrom> @type ap
17:04:36 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:04:45 <imgoinghomenowci> is there any way to install haskell on a mac without having to use xcode?
17:04:59 <c_wraith> not on newer versions of os x
17:05:13 <c_wraith> they used to package the tools seperately, but stopped doing that as of...  Lion?
17:06:01 <c_wraith> Maybe mountain lion.  The current state is that getting apple's command-line developer tools requires installing xcode
17:06:14 <monochrom> @type pure
17:06:15 <lambdabot> Applicative f => a -> f a
17:06:55 <c_wraith> I suppose that you could, in theory, build a version of GHC that uses an alternative toolchain with similar tools..  But it's a lot of work.
17:07:03 <monochrom> > pure (+) <*> pure 1 <*> pure 5 :: Maybe Integer
17:07:06 <lambdabot>   Just 6
17:07:24 <c_wraith> wait, what?
17:07:47 <Shin-LaC> c_wraith: that's not true
17:07:49 <c_wraith> Oh, nevermind.  hah.  I got totally confused with an earlier article I was reading.
17:08:02 <c_wraith> Shin-LaC: which part?
17:08:13 <Shin-LaC> the part where you need Xcode
17:08:45 <Shin-LaC> go to https://developer.apple.com/xcode/ and find where it says "Looking for additional developer tools? View Downloads"
17:09:02 <Shin-LaC> log in with your apple ID
17:09:06 <imgoinghomenowci> ok ok
17:09:16 <Shin-LaC> you can download a dmg with just the CLT
17:09:28 <c_wraith> still requires an apple id, for no reason.  But it is better, at least.
17:09:52 <typoclass> apple makes it all so easy!
17:10:10 <c_wraith> Shin-LaC: thanks for the pointer.
17:10:58 <ab9rf> feeeeeeeh
17:12:56 <imgoinghomenowci> @Shin-LaC thanks so much
17:12:57 <lambdabot> Unknown command, try @list
17:13:08 <Shin-LaC> np
17:15:51 <orion_> @pl plus (x, y) = x + y
17:15:51 <lambdabot> plus = uncurry (+)
17:18:08 <liori> hello, what should i set in the initial screen of leksah if i want to work inside virthualenv?
17:19:49 <hpaste> Ontolog pasted “unintended infinite data structure” at http://hpaste.org/85445
17:23:06 <Ontolog> hpc: i think this is related to the last question you helped me with
17:24:51 <Ontolog> dmwit: i think you would know what's wrong as well
17:26:34 <Ontolog> Cale: of course you would know as well ;-) ... going down the list here lol
17:36:23 <orion_> @pl replicate2 (x, y) = case x of { (0) -> []; (z) -> (y : replicate2 (x - 1, y))}
17:36:23 <lambdabot> (line 1, column 31):
17:36:24 <lambdabot> unexpected '{'
17:36:24 <lambdabot> expecting variable, "(", operator or end of input
17:37:59 <andrewsw> Ontolog: you have defined exactly what you described, it looks to me
17:38:50 <Ontolog> andrewsw: well `show` should handle circular references right?
17:38:52 <andrewsw> Ontolog: node A4 has (Nothing, Node B4) and node B4 has (Node A4, Nothing), but Node A4 has (Nothing, Node B4)...
17:39:28 <andrewsw> that's what it's doing -- showing you the recursive nature of the data structure.
17:39:29 <Ontolog> andrewsw: the problem is, i don't think the circular reference is being created, unless show is being dumb and can't handle circular references
17:40:11 <Ontolog> andrewsw: also, when i go to process this data structure, it never finished, when it should finish quickly since im giving a very small input
17:40:50 <Ontolog> like how does Haskell know if I want a 'new thing' or have it use the reference to a thing that's already defined?
17:41:03 <andrewsw> well...
17:41:15 <monochrom> there is no pointer equality in standard Haskell. therefore, show must be dumb about circular data structures, it must be unable to know "I have seen this before". also all other functions, not just show.
17:41:17 <andrewsw> it helps if you don't define them both at the same time.
17:41:47 <andrewsw> you've defined nodeA in terms of nodeB and nodeB in terms of nodeA.
17:42:09 <andrewsw> and in fact you've embedded those nodes recursively inside each other.
17:45:02 <orion_> @pl replicate2 (x, y) = case x of (0) -> []; (z) -> (y : replicate2 (x - 1, y))
17:45:02 <lambdabot> (line 1, column 37):
17:45:02 <lambdabot> unexpected '>'
17:45:02 <lambdabot> expecting operator
17:45:20 <monochrom> to find out whether new nodes are created or old nodes are reused, you must step outside and use profilers, read machine code, etc.
17:45:56 <monochrom> often, it doesn't have to be as low-level as machine code, GHC's core code is good enough
17:46:23 <monochrom> anyway my point is you must verify it at the outside, meta level
17:48:20 <Hermit> how can I see what packages depend on a specific one?
17:49:05 <Ontolog> i'm still not understanding how to achieve what i want...
17:49:12 <andrewsw> what do you want?
17:51:50 <lightquake> where can i get some CSS files for use with pandoc's syntax highlighting
17:52:08 <Ontolog> oh wait you guys are saying that my data structure is as i intended, show *is* dumb (because it has to be), and that to figure out why the processing of this data structure is also taking forever, i need to do some hardcore shit
17:52:49 <andrewsw> Ontolog: what are you trying to do to this data structure?
17:54:10 <hpaste> Ontolog pasted “what I'm doing” at http://hpaste.org/85446
17:55:52 <monochrom> aren't you supposed to compare nodeIds yourself?
17:57:03 <Ontolog> compare?
17:57:11 <Ontolog> where would i compare nodeIds?
17:57:44 <monochrom> where you want to know "x is a node, y is a node, are they the same?"
17:57:49 <andrewsw> how do you know what nodes you've visited?
17:58:13 <Ontolog> monochrom: and where would i need that?
17:58:33 <Ontolog> andrewsw: the traversal is linear so i don't really need to know
17:58:48 <Ontolog> i mean linear as in one direction
17:58:57 <monochrom> I don't know. I have run out of time.
17:59:09 <andrewsw> Ontolog: you clearly have a cycle in your graph.
17:59:17 <Ontolog> andrewsw: a cycle?
18:00:03 <Ontolog> shortestPath matches on Nothing and that's suppose to prevent shortestPath from going on and on
18:00:31 <andrewsw> Ontolog: a sequence of edges that cause a traversl to repeast the same path is a cycle.
18:01:28 <Ontolog> andrewsw: so look at shortestPath, i thought that pattern matching should handle it
18:01:50 <Ontolog> compare that with the output from show in the previous post
18:02:21 <Ontolog> we are certainly reaching the condition where a segment has the type of Nothing
18:02:25 <andrewsw> without reading too closely, it looks like it should terminate, yes.
18:02:27 <Ontolog> which should end the recursion
18:03:35 <Ontolog> can I add a do block to the RHS of a where assignment?
18:03:47 <Ontolog> where _ = print someShit
18:04:09 <Ontolog> since it doesn't effect the purity of the function itself
18:04:34 <Ptival> why do you think it does not?
18:06:30 <Ontolog> Ptival: it doesn't change the output of the function
18:06:55 <Ontolog> Ptival: but yeah it would still have side effects
18:10:55 <sw2wolf> @wn monoid
18:10:55 <lambdabot> No match for "monoid".
18:16:14 <Ontolog> lambdabot: fromJust (Just "a")
18:16:20 <Ontolog> > fromJust (Just "a")
18:16:21 <lambdabot>   "a"
18:16:27 <shachaf> Don't use fromJust. :-(
18:16:28 <Ontolog> how do I import fromJust?
18:16:34 <Ontolog> im just testing something
18:16:39 <Ontolog> how do i get it into my scope
18:16:43 <Ontolog> import Maybe not working
18:16:47 <shachaf> fromJust(Just x)=x
18:16:56 <shachaf> Do you know about Hoogle?
18:16:58 <shachaf> @where hoogle
18:16:58 <lambdabot> http://haskell.org/hoogle
18:17:02 <shachaf> @hoogle fromJust
18:17:03 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
18:19:15 <Ontolog> is there nothing like ptrace for haskell?
18:19:36 <Ontolog> i just want it to print out function application for certain functions though
18:19:50 <Eduard_Munteanu> I don't see how that would be of much use though.
18:20:08 <Eduard_Munteanu> Try using Debug.Trace.
18:20:16 <Eduard_Munteanu> @hoogle trace
18:20:17 <lambdabot> Debug.Trace module Debug.Trace
18:20:17 <lambdabot> Debug.Trace trace :: String -> a -> a
18:20:17 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
18:20:48 <Ontolog> cool thanks
18:21:37 <Eduard_Munteanu> You do something like   "message to display when evaluating" `trace` resultOfEvaluatingThisExpression
18:23:08 <Ontolog> ah but it has to give a result
18:23:20 <Ontolog> i think i found the problem
18:27:14 <Eduard_Munteanu> Ontolog: hm? Whatever function you're defining has a definition, that's your "result"
18:27:14 <ab9rf> what is the problem?
18:27:17 <orion_> @pl replicate
18:27:17 <lambdabot> replicate
18:30:41 <orion_> @pl repeat x = xs where xs = x:xs
18:30:41 <lambdabot> (line 1, column 25):
18:30:42 <lambdabot> unexpected " "
18:30:42 <lambdabot> expecting operator
18:30:44 <startling> are there bindings to a library somewhere that would let me compile html to pdf?
18:31:24 <orion_> @pl repeat (x:xs) = x:x:xs
18:31:24 <lambdabot> repeat = ap (liftM2 (.) (:) (:) . head) tail
18:31:29 <Ontolog> Eduard_Munteanu: yeah, my problem was infinite recursion
18:31:38 <Ontolog> Eduard_Munteanu: hence having a result is also a problem :p
18:31:41 <orion_> @pl repeat (x:xs) = x:(repeat xs)
18:31:41 <lambdabot> repeat = fix ((`ap` tail) . (. head) . flip ((.) . (:)))
18:31:47 <Eduard_Munteanu> Heh.
18:31:50 <Ontolog> thanks for all the helps guys, laters
18:32:43 <orion_> @pl f n x = take n (repeat x)
18:32:43 <lambdabot> f = (. repeat) . take
18:33:09 <Eduard_Munteanu> startling: does your input have to be HTML?
18:33:19 <orion_> @pl f (n, x) = take n (repeat x)
18:33:19 <lambdabot> f = uncurry ((. repeat) . take)
18:33:39 <Eduard_Munteanu> startling: I mean, you could output both HTML and PDF from something else with pandoc
18:35:59 <startling> Eduard_Munteanu: my input is already html, yeah.
18:36:13 <startling> (it's tables, which are annoying to generate in anything but html)
18:38:27 <Eduard_Munteanu> I guess there has to be a way, a lot of browsers support printing a webpage, optionally to a .ps/.pdf.
18:40:41 <typoclass> startling: is it an option to use some command line tool? there must be stuff like that around, given that we have one for pdf to text and another for pdf to html
18:41:22 <startling> typoclass: yeah, I'm using wkhtmltopdf atm and am about to write some bindings to it. I was just wondering if there was anything currently.
18:47:41 <orion_> @pl tails xs = zipWith (drop) [0..] (replicate (1 + length xs) xs)
18:47:41 <lambdabot> tails = zipWith drop [0..] . (replicate =<< (1 +) . length)
18:50:49 <orion_> @pl tails xs = xs: zipWith (drop) [1..] (replicate (length xs) xs)
18:50:49 <lambdabot> tails = ap (:) (zipWith drop [1..] . (replicate =<< length))
18:51:17 <orion_> @pl tails xs = zipWith (drop) [0..1 +length xs] (repeat xs)
18:51:17 <lambdabot> tails = ap (zipWith drop . enumFromTo 0 . (1 +) . length) repeat
18:52:10 <BMeph> @pl tails xs = (++[]) . takeWhile (not . null) . iterate (drop 1) $ xs
18:52:11 <lambdabot> tails = (++ []) . takeWhile (not . null) . iterate (drop 1)
18:52:38 * BMeph shrugs; not much to this game, is there? ;)
18:52:47 <orion_> nice, thanks ;)
18:53:08 <orion_> getting started to point free style
18:55:00 * hackagebot stm-conduit 1.1.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-1.1.0 (ClarkGaebel)
18:55:56 <orion_> and the result it's actually:
18:56:01 <orion_> tails = (++ [[]]) . takeWhile (not . null) . iterate (drop 1)
18:56:49 <BMeph> orion_: My bad - should've used the Robo-Monkey. ;)
18:57:03 <deech> Hi all, what's the best way of installing multiple versions of GHC on the same machine?
18:57:04 <BMeph> @pl tails xs = (:[]) . takeWhile (not . null) . iterate (drop 1) $ xs
18:57:04 <lambdabot> tails = return . takeWhile (not . null) . iterate (drop 1)
18:57:35 <BMeph> Okay, that didn't do it...you win, o! :)
18:57:57 <BMeph> deech: I like the serial method! ;þ
18:58:44 <deech> BMeph: That's certainly the simplest. Except I need to test installing Platform with 7.4.2 for a friend and I have 7.6.1.
18:58:59 <ab9rf> @pl (:[]).(:[])
18:58:59 <lambdabot> return . return
18:59:01 <ab9rf> hehe
18:59:23 <geekosaur> BMeph, I'd say the easiest way is not to; see for example virtualbox
18:59:34 <ab9rf> @pl (.)$(.)$(.)$(.)
18:59:34 <lambdabot> ((((.) .) .) .)
18:59:55 <geekosaur> a jail might work if you're on an OS that has easy jail setup/teardown
19:00:00 * BMeph always closes his eyes when virtualbox goes by... ;þ
19:00:00 * hackagebot bed-and-breakfast 0.1.1 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.1.1 (JulianFleischer)
19:00:18 * geekosaur actually uses vmware...
19:00:34 * BMeph finds VMW is worse.
19:02:45 * sw2wolf why do we need pointless ?
19:03:01 <liyang> … I'll just leave this here: http://www.reddit.com/r/haskell/comments/1bymg1/monads_are_burritos_in_spacesuits_full_of_nuclear/
19:03:27 <ab9rf> sw2wolf: because it's pointless!
19:03:50 <ab9rf> @unpl (.)$(.)$(.)$(.)
19:03:50 <lambdabot> (\ b c f i k l -> b c f i (k l))
19:04:09 <shachaf> @unpl (.)(.)(.)(.)
19:04:09 <lambdabot> (\ e f i k l -> e f i (k l))
19:04:22 <BMeph> @unpl (.).(.).(.).(.)
19:04:22 <lambdabot> (\ o b c f i l -> o (b c f i l))
19:04:34 <ab9rf> @unpl ($).($)
19:04:34 <lambdabot> (\ g b -> g b)
19:05:16 <ab9rf> sadly, (=^.^=) is not a defined operator
19:06:24 <liyang> ^.^ is vector dot-product from @hackage vector-space
19:06:46 <sw2wolf> ab9rf: i feel @unpl result is much clearer than its original thing
19:08:52 <ab9rf> sw2wolf: sometimes
19:09:08 <typoclass> sw2wolf: that's often true. i think a little bit of pl can help clarity, but more pl quickly becomes nonsense
19:09:26 <ab9rf> there's a reason it's called "pointless"
19:09:47 <parcs> > 730 * 731 * 0.03 / 2
19:09:49 <lambdabot>   8004.45
19:10:01 * hackagebot multiarg 0.14.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.14.0.0 (OmariNorman)
19:10:38 <ab9rf> > R.approxRational 8004.45 .01
19:10:40 <lambdabot>   *Exception: show: No overloading for function
19:10:44 <ab9rf> bah
19:11:08 <ab9rf> > R.approxRational 8004.45 0.01
19:11:10 <lambdabot>   72040 % 9
19:12:13 <shergill> any views on where in the monad stack should LoggingT be inserted?
19:13:48 <parcs> > 2011 / 7
19:13:49 <lambdabot>   287.2857142857143
19:14:57 <parcs> > 7*287*288/2
19:14:58 <lambdabot>   289296.0
19:15:01 * hackagebot prednote 0.8.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.8.0.0 (OmariNorman)
19:18:06 <ab9rf> mathbuse
19:18:43 <deech> BMeph: the answer was virthualenv
19:22:10 <shergill> deech: hsenv replaces virthualenv
19:24:45 <latermuse> is 'mconcat ["hi", "meow"]' better than just doing '"hi" ++ "meow"' ?
19:25:03 * hackagebot fsnotify 0.0.7 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.7 (GregWeber)
19:25:15 <elliott> latermuse: no
19:25:20 <elliott> it is worse, in fact, because it is less clear
19:25:38 <latermuse> so in what situation would mconcat be preferable over (++)?
19:26:10 <elliott> when you have a list
19:26:30 <elliott> (though you should probably just spell it concat in that case; mconcat is for when you're working with arbitrary monoids, generally)
19:26:55 <latermuse> mconcat is more academic then
19:27:03 <geekosaur> more general
19:27:12 <latermuse> gotcha
19:27:13 <geekosaur> monoid captures a concept which is in some ways a generalization of lists
19:27:48 <geekosaur> and mconcat is to concat as mappend is to (++)
19:28:23 <latermuse> ahh gotcha
19:28:47 <latermuse> > foldr (++) "" ["hi", "meow"]
19:28:49 <lambdabot>   "himeow"
19:28:49 <geekosaur> so, for a concrete example, xmonad defines all its hooks as monoids so you can use mappend and mconcat to combine hooks
19:29:13 <latermuse> thats convenient
19:29:16 <latermuse> @src concat
19:29:16 <lambdabot> concat = foldr (++) []
19:29:16 <geekosaur> rather than having to know what kind of hook it is (some are lists, some are monads, some are functions)
19:29:59 <latermuse> so mconcat/mappend are used for general types
19:30:04 * hackagebot bed-and-breakfast 0.1.2 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.1.2 (JulianFleischer)
19:30:10 <latermuse> general functors
19:30:27 <geekosaur> and you don't need to know what kind of hook something is to mappend or mconcat it
19:31:19 <jamil> hi, what does | m -> e in "class (Monad m) => MonadError e m | m -> e where" mean ?
19:31:20 <latermuse> just need to know it's mempty, correct?
19:31:35 <shachaf> jamil: It is a "functional dependency"
19:31:40 <shachaf> @google functional dependenceis haskell
19:31:42 <lambdabot> http://www.haskell.org/haskellwiki/Functional_dependencies
19:31:42 <lambdabot> Title: Functional dependencies - HaskellWiki
19:31:50 <geekosaur> usually you're chaining to the original value by pulling it out of the config record, but mempty is defined correctly for each type
19:32:05 <geekosaur> so you don't even need to know anything beyond mempty
19:32:33 <latermuse> convenient
20:40:15 <Cale> Ontolog: still here?
20:40:24 <Cale> Ontolog: I noticed you pinged me earlier
20:40:41 <beaky> hello
20:41:31 <Cale> hi
20:41:39 <beaky> How does haskell instantiate polymorphic types like [a]? does it create instances everytime it encounters a new concrete type like C++?
20:41:53 <beaky> the way  C++ templates do it *
20:42:53 <Cale> No
20:43:15 <Cale> Well, at least in GHC
20:43:25 <Cale> All ordinary values in GHC are represented uniformly by pointers to code
20:43:26 <beaky> ah
20:44:31 <shachaf> The C++ way would be impossible in some cases like polymorphic recursion.
20:44:39 <Cale> Because of polymorphic recursion, it's possible to have programs which in essence apply type constructors to an unbounded number of types "at runtime"
20:45:07 * hackagebot hoodle-render 0.3.1 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.3.1 (IanWooKim)
20:45:09 * hackagebot hoodle-core 0.11 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.11 (IanWooKim)
20:45:11 * hackagebot hoodle 0.2.0 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.2.0 (IanWooKim)
20:45:20 <hpaste> Cale pasted “Worst power of 2 algorithm ever ;)” at http://hpaste.org/85447
20:45:29 <Cale> ^^ have a look at that
20:46:18 <Cale> aNest = N 1 (N [1,1] (N [[1,1],[1,1]] (N [[[1,1],[1,1]],[[1,1],[1,1]]] ...)))
20:46:30 <copumpkin> wow
20:46:36 <copumpkin> that's a pretty bad power of two algorithm
20:46:40 <copumpkin> I had a pretty bad one in a similar vein
20:46:46 <startling> for some traversals, I want to sequence an effect in without changing the value, so I do something like "someTraversal $ \x -> whatever *> return x"; is there a way to autommate that?
20:47:12 <startling> er, s/return/pure
20:47:31 <cmears> is it "someTraversal <* whatever" ?
20:47:31 <shachaf> startling: If you're not changing the value, why do it at all?
20:47:43 <Cale> shachaf: because effect
20:47:43 <shachaf> Just use the old structure.
20:47:56 <shachaf> Cale: Yes, but you don't need to rebuild the structure.
20:48:06 <shachaf> You can just traverse_ and then use the old one.
20:48:09 <copumpkin> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
20:48:14 <lambdabot>   mueval: ExitFailure 1
20:48:15 <lambdabot>  mueval: Prelude.undefined
20:48:17 <copumpkin> dammit
20:48:18 <copumpkin> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
20:48:22 <lambdabot>   mueval-core: Time limit exceeded
20:48:24 <copumpkin> Cale: well :(
20:48:29 <copumpkin> > take 5 . map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
20:48:31 <lambdabot>   [2,4,8,16,32]
20:48:35 <copumpkin> >_>
20:48:44 <Cale> haha
20:48:56 <startling> shachaf: is there a thing that takes a traversal and turns it into a underscore-style traversal?
20:49:02 <shachaf> Yes.
20:49:06 <shachaf> @ty traverseOf_
20:49:09 <lambdabot> (Functor f, Profunctor p) => Accessing p (Traversed r f) s t a b -> p a (f r) -> s -> f ()
20:49:14 <startling> shachaf: thanks. :)
20:49:23 <shachaf> Of course you could just use the traversal.
20:49:32 <shachaf> It'll mean using extra space but it would have the same effect.
20:49:57 <startling> this is a Functor F => (a -> f a) -> b -> b
20:50:02 <Hermit> > map (2^) [1..5]  -- copumpkin
20:50:03 <lambdabot>   [2,4,8,16,32]
20:50:12 <copumpkin> Hermit: oh shit! who knew it was that simple
20:50:14 <Cale> beaky: anyway, polymorphism is usually achieved by picking some uniform representation for values, so that every value is the same size in memory -- so when you have a list of values of any type, code that doesn't need to depend on what those values are, can simply not follow those pointers, and thus the same piece of code will work on any type of list.
20:50:15 <startling> er, s/F/f
20:50:18 <copumpkin> and here I was thinking I needed to fix show
20:50:32 * geekosaur watches the point soar far overhead...
20:50:38 <ab9rf> w00f
20:50:41 <Hermit> copumpkin: I'm seriously hoping you are being sarcastic
20:50:43 <ab9rf> what did i walk in on
20:50:44 <copumpkin> :P
20:50:48 <beaky> ah
20:51:00 <copumpkin> Hermit: your one is doing unnecessary work though
20:51:08 <copumpkin> > iterate (*2) 2
20:51:09 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
20:51:16 <copumpkin> that one's asymptotically more efficient
20:51:19 <Cale> beaky: as another little example to stare at...
20:51:26 <Hermit> right
20:51:32 <beaky> I guess that's how you can implement smething ike that at the low level (e.g. in C)
20:51:32 <copumpkin> yours is however asymptotically more efficient than my earlier implementation :P
20:51:34 <copumpkin> or than Cale's
20:52:00 <ab9rf> is ti really unnecessary work?  what if you need a space heater and all you have is haskell?
20:52:07 <copumpkin> good point ab9rf
20:52:11 <dolio> > iterate (join (+)) 2 -- adding is better than multiplying amirite?
20:52:12 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
20:52:21 <copumpkin> dolio: another excellent point
20:52:25 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f 0) [0..]
20:52:27 <lambdabot>   ["0","(0,0)","((0,0),(0,0))","(((0,0),(0,0)),((0,0),(0,0)))","((((0,0),(0,0...
20:52:39 <startling> ab9rf: that violates purity!
20:52:54 <Cale> ^^ this kind of thing involves using "infinitely many" instances of Show
20:53:02 <copumpkin> Cale: unpossible!
20:53:05 <Cale> Of course, it really boils down to 2 instances
20:53:13 <shachaf> > iterate (`shiftL` 1) 2
20:53:15 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
20:53:23 <copumpkin> shachaf is super duper efficient
20:53:26 <Cale> Show Integer, and  (Show a, Show b) => Show (a,b)
20:53:30 <ab9rf> startling: reminds me of an old basic programmer i knew who was irate that C would optimize away his idle loops "But how else am I going to get a one second pause?"
20:53:56 <shachaf> > [2,4,8,16,32] -- maximally efficient??
20:53:58 <lambdabot>   [2,4,8,16,32]
20:54:00 <startling> ab9rf: :/
20:54:05 <ab9rf> @src iterate
20:54:05 <lambdabot> iterate f x =  x : iterate f (f x)
20:54:16 <copumpkin> Cale: I feel like your data type for computing powers of twos is error-prone
20:54:21 <Cale> ?
20:54:25 <Cale> Oh, it is
20:54:28 <copumpkin> I think you should change [a] to (a, a)
20:54:31 <copumpkin> to make it more precise
20:54:39 <Cale> You could use it to compute powers of other numbers, or things which aren't powers
20:54:39 <dolio> > map setBit [1..5]
20:54:40 <lambdabot>   Ambiguous type variable `a0' in the constraints:
20:54:41 <lambdabot>    (GHC.Enum.Enum a0)
20:54:41 <lambdabot>     ...
20:54:53 <Cale> I didn't really design it to compute powers of two :P
20:54:57 <ab9rf> :t setBit
20:54:58 <lambdabot> Bits a => a -> Int -> a
20:54:59 <copumpkin> :O
20:55:05 <dolio> Oh.
20:55:14 <dolio> > map (setBit 0) [1..5]
20:55:16 <lambdabot>   [2,4,8,16,32]
20:55:17 <no-n[3]> how do I get a unicode character from its ordinal value?
20:55:27 <ab9rf> :t chr
20:55:28 <lambdabot> Int -> Char
20:55:31 <no-n[3]> ty
20:55:53 <ab9rf> i should charge a bitcoin per answer :)
20:55:53 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in take 10 . map ((+3) . length . f 0) $ [0..]
20:55:54 <dolio> > map bit [1..5] -- here we go
20:55:56 <lambdabot>   [4,8,16,32,64,128,256,512,1024,2048]
20:55:56 <lambdabot>   can't find file: L.hs
20:56:20 <ab9rf> Cale: did you mean to skip 2?
20:56:37 <dolio> Was that a race condition?
20:56:44 <Cale> ab9rf: Yes?
20:56:56 <ab9rf> heh
20:57:16 <Cale> I am adding 3 after all
20:57:22 <geekosaur> L.hs is a race, yes
20:57:24 <ab9rf> if you say so
20:57:40 <Cale> > map bit [1..5]
20:57:42 <lambdabot>   [2,4,8,16,32]
20:58:00 <Cale> ab9rf: A whole bitcoin?
20:58:06 <ab9rf> Cale: sure, why not? :)
20:58:14 <ab9rf> Cale: they'll be worthless ina  few weeks anyway
20:58:19 <Cale> haha
20:58:40 <Cale> I've definitely had the thought of borrowing some bitcoins
20:58:50 <ab9rf> Cale: short selling? :)
20:58:52 <Cale> yes
20:59:05 <ab9rf> Cale: i'm waiting for people to get prosecuted for failing to report cash trasnactions in excess of $10,000
21:00:08 <ab9rf> if i had any money to play with i might be tempted
21:00:57 <wavewave> Does anyone know about status of secure multiparty computation library in haskell?
21:02:13 <wavewave> I see this paper, but cannot find any lib yet http://corp.galois.com/storage/files/downloads/icfp47-launchbury.pdf
21:04:12 <wavewave> btw, a new version of hoodle announced :-)
21:06:12 <bscarlet> Urg. "cabal install --builddir=/some/absolute/path test-framework" fails, seemingly with some sort of collision inside the builddir, with leftovers from regex-posix causing trouble when test-framework gets built.
21:09:52 <tootooroo> Is there any difference between openFile and openBinaryFile on Linux?
21:10:18 <Ralith> shouldn't be
21:10:39 <Ralith> unless there's RTS-level encoding stuff
21:11:10 <tootooroo> For the most part, I intend to read ByteStrings.
21:11:29 <tootooroo> strict*
21:11:57 <Ralith> do you have any reason not to use openBinaryFile?
21:12:55 <tootooroo> Not really, I was just wondering.
21:15:08 * hackagebot asn1-types 0.1.0 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.1.0 (VincentHanquez)
21:35:09 * hackagebot bed-and-breakfast 0.1.3 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.1.3 (JulianFleischer)
21:59:26 <keith___> True quicksort in C sorts in-place:
21:59:26 <keith___> / To sort array a[] of size n: qsort(a,0,n-1)
21:59:26 <keith___> void qsort(int a[], int lo, int hi)
21:59:26 <keith___> {
21:59:26 <keith___>   int h, l, p, t;
21:59:27 <keith___>   if (lo < hi) {
21:59:29 <keith___>     l = lo;
21:59:31 <keith___>     h = hi;
21:59:33 <keith___>     p = a[hi];
21:59:36 <elliott> keith___: please don't paste
21:59:37 <keith___>     do {
21:59:38 <keith___>       while ((l < h) && (a[l] <= p))
21:59:39 --- mode: ChanServ set +o elliott
21:59:40 <keith___>           l = l+1;
21:59:42 <keith___>       while ((h > l) && (a[h] >= p))
21:59:43 --- mode: elliott set +q keith___!*@*
21:59:55 * elliott waits for the paste to run out...
22:00:07 --- mode: elliott set -q keith___!*@*
22:00:09 <keith___>   }
22:00:10 * hackagebot bed-and-breakfast 0.1.4 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.1.4 (JulianFleischer)
22:00:11 <keith___> }
22:00:13 <keith___> sorry
22:00:18 <Clint> at least it was in haskell
22:00:19 <elliott> it's ok :) you can use http://hpaste.org/ instead
22:00:26 --- mode: elliott set -o elliott
22:05:10 * hackagebot crypto-pubkey-types 0.3.0 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.3.0 (VincentHanquez)
22:05:12 * hackagebot crypto-pubkey 0.1.3 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.1.3 (VincentHanquez)
22:05:30 <hpaste> “http://johanesgultom.blogspot.com/2013/04/konsumen-cerdas-paham-perlindungan.html” pasted “http://johanesgultom.blogspot.com/2013/04/konsumen-cerdas-paham-perlindungan.html” at http://hpaste.org/85449
22:06:24 <shachaf> Can something be chrisdone about these?
22:08:33 <hpaste> “Resepmasakanyuni.blogspot.com” pasted “Resepmasakanyuni.blogspot.com” at http://hpaste.org/85450
22:09:16 <pharaun> elliott: at least its better than having an unkillable bot dumping megabytes of html into the channel
22:09:36 <keith___> how to solve this problem; i got bunch of cereal on my living room carpet, should i let bird inside or let the maids clean it up
22:10:38 <lavorno> keith__: talk to google, they are v good with the cookies :)
22:12:04 <elliott> keith___: this channel is about the haskell programming language, you know :P
22:12:51 <ChongLi> keith___: sounds like a job for STM
22:13:06 <lavorno> eliott: the haskell solution to keith__'s problem : get the Bird then use Arrows
22:13:24 <pharaun> bind the birds then arrow them?
22:14:13 <lavorno> pharaun: that sounds great.. if you can also handle exceptions - for impure birds - even better
22:15:15 <lavorno> (apologies, i'm obsessed with handling exceptions nowadays and still haven't figured out how to handle that)
22:15:28 <pharaun> lavorno: my exception handling tool of choice is a grill
22:15:51 <lavorno> pharaun : a grill or a grid ?
22:15:54 <pharaun> i can't claim to be a terrific fan of exception in haskell
22:16:12 <pharaun> lavorno: is grid of grills an acceptable answer?
22:16:17 <lavorno> haskell on a grid => high temperature
22:16:49 <lavorno> pharaun: how does the grill handle exceptions ?
22:16:55 <lavorno> (arrow kind)
22:17:04 <pharaun> lavorno: frying the bird and arrow :3
22:17:10 <pharaun> om noms
22:17:14 <lavorno> :)
22:18:01 <shachaf> This sounds kind of off-topic for Freenode.
22:18:11 <lavorno> agreed
22:18:56 <lavorno> but on topic - how do we handle exceptions in haskell ? (what's the most up to date info)
22:19:18 <keith___> ill find coordinates for the cereal and let birds go at it ty all ;)
22:19:39 <simpson> lavorno: Wasn't this something that you asked about earlier?
22:19:43 <lavorno> yes
22:19:48 <lavorno> but i had to step out
22:19:55 <lavorno> and didn't hear what was the conclusion
22:20:18 <lavorno> do we have a conclusion / best practices / etc on exception handling ?
22:20:37 <lavorno> (besides "write your own stuff" is possible, i'm not up to task unfortunately)
22:20:45 <lavorno> is==if
22:21:20 <simpson> Well, if you have to deal with exceptions, then deal with them. You have to be in IO to catch them, so be in IO and catch them.
22:21:42 <simpson> That's why I advised you earlier to write code that doesn't need exceptions.
22:21:52 <lavorno> simpson: great point but it conflicts with another advice
22:22:13 <lavorno> one other advice in most of places is "use pure code as much as possible"
22:22:28 <lavorno> so i try to move from io as quickly as possible into pure
22:22:34 <lavorno> then handle exc there
22:22:47 <lavorno> but if i use regular exc - they end-up in io...
22:22:55 <lavorno> and i'm moving around the tail
22:23:09 <simpson> lavorno: I guess I don't get your point. Could you illustrate with an example?
22:23:17 <lavorno> example:
22:23:25 <lavorno> i parse data from a file
22:23:33 <lavorno> the file can throw i/o exceptions
22:23:39 <lavorno> i handle them when i open/read the file
22:23:51 <lavorno> then i start the parsing
22:24:16 <lavorno> during parsing i may have malformed data and all sorts of errors in the file (that are not i/o, just  bad data)
22:24:46 <simpson> But you don't need to have exceptions in order to indicate a failed parse.
22:24:53 <lavorno> also, depending on lbraries, some are using exc, others either/ maybe/etc
22:25:25 <simpson> Well, roll your eyes and go with the library that suits you.
22:26:14 <lavorno> the point is i can't just use one lib
22:26:18 <lavorno> there are many i need
22:26:39 <lavorno> and they have diff exc/error handling accross the board (monadic, arrow, either, etc)
22:26:52 <lavorno> (with i/o sprinkled all over for good measure)
22:27:10 <simpson> Pick the style that you prefer, stick to that style, only use libraries with that style, and berate anybody who disagrees. :3
22:27:15 <lavorno> so i guess i'm asking what's the best approach for that
22:27:21 <simpson> BTW, have you joined the church of edwardk yet? We have lenses! :3
22:27:50 <lavorno> i haven't got the chance to play with lenses.. but do you think they will solve all of this exc handling stuff ?
22:28:25 <elliott> lens has exception functionality
22:28:32 <elliott> that works with standard Control.Exception
22:28:36 <lavorno> (i've watched ed doing a presentation once and it kind of flew over my cooko's nest 10000m high)
22:28:58 <elliott> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Exception-Lens.html
22:31:59 <latermuse> why is this fizzbuzz code getting a parse error?
22:32:16 <latermuse> mapM_ (putStrLn . c) [1..100] where c x = case x of {(x `mod` 15 == 0) -> "FizzBuzz"; (`mod` 3 == 0) -> "Fizz"; (`mod` 5 == 0) -> "Buzz"; otherwise -> show x;}
22:32:40 <latermuse> mod
22:32:52 <latermuse> this is the error: Parse error in pattern: x `mod` 15
22:32:58 <shachaf> Because that is not a pattern.
22:33:19 <latermuse> how can I rephrase it to be a pattern?
22:33:31 <shachaf> You can't.
22:33:43 <latermuse> gotcha
22:33:46 <shachaf> It's a boolean, right?
22:33:54 <shachaf> You want if-then-else or guards. You're using case.
22:34:19 <latermuse> yeah, i got it working with if-then-else and guards. was just trying to see if it can work with case or not
22:35:10 <lavorno> elliott: i was looking over that link and it looks way to advanced for where i am at the moment.. i can understand maybe/either/exception handling (similar to c++/java/etc) but this require for me to know a lot of stuff upfront.. not sure i can envision how to use that for exception handling unification..
22:35:13 <shachaf> Booleans are not patterns. They're inferior to patterns. Patterns are special.
22:37:01 <lavorno> elliott: is there an example somewhere showing how lenses can be used to unify exception handling across the board ? (maybe/either/classic exc/monadic exc/arrow exc/io exc....etc)
22:37:12 <elliott> the module I linked only concerns itself with IO exceptions
22:38:00 <lavorno> great, but it is too advanced for me to "get it" just by looking at it.. so are there some good examples that can help ?
22:38:43 <elliott> not other than what's in that module, afaik
22:41:41 <lavorno> eliott: thanks.. is there some source code built on top of it using that approach, that i can look at ?
22:47:40 <elliott> lavorno: probably edwardk has some :P
22:48:08 <lavorno> elliott: i found this https://github.com/ekmett/lens
22:48:15 <lavorno> was looking through it
22:48:30 <shachaf> You were at the SF talk?
22:49:00 <lavorno> no, seen it on youtube (and was flowing way over my head :) )
22:49:31 <monochrom> you need to wear 3D glasses to view lens videos!
22:51:45 <lavorno> monochrom: true.. for me horse glasses are required - so i don't get too scared about what's been vehiculated around
23:02:41 <lightquake> @pl \x y f -> x f >> y f
23:02:42 <lambdabot> liftM2 (>>)
23:02:50 <lightquake> … ok, that's cute
23:20:12 * hackagebot bed-and-breakfast 0.2 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.2 (JulianFleischer)
23:20:57 * monochrom boggles at that name
23:25:11 <lightquake> why is design so hard
23:25:32 <shachaf> why are monoids so easy
23:30:43 <elliott> shachaf: don't you think the "i love x. it is so easy" thing is a bit overdone?
23:30:57 <elliott> ™
23:31:15 <shachaf> I didn't say I love anything.
23:31:58 <monochrom> why is Y so Y
23:32:24 <jamil> what is the return type of "return a = ErrorT $ return (Right a)"
23:32:33 <jamil> in "instance (Monad m, Error e) => Monad (ErrorT e m) where"
23:32:37 <jamil> from http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Error.html#ErrorT
23:33:08 <mauke> (Monad m, Error e) => ErrorT e m a
23:33:11 <jamil> return a :: ErrorT m (Either e a) ?
23:34:02 <jamil> how so ?
23:34:16 <sw2wolf> @ty ErrorT $ return (Right a)
23:34:18 <lambdabot> Monad m => ErrorT e m Expr
23:35:48 <jamil> I see
23:36:48 <jamil> so runErrorT peels off one layer
23:38:08 <sw2wolf> @ty runErrorT
23:38:09 <lambdabot> ErrorT e m a -> m (Either e a)
