00:00:10 <Kinnison> @djinn a -> (a -> b) -> b
00:00:13 <lambdabot> f a b = b a
00:00:22 <Kinnison> heh
00:00:43 <fruitFly> oh no.. what's wrong with this now? http://codepad.org/LNo0EFh5
00:00:54 <djcoin> Would you choose Haskell over say, erlang, to write a distributed database ? And if so what would be the pros/cons ?
00:01:12 <lambdadelta> fruitFly: Why the indentation?
00:01:12 <Kinnison> fruitFly: you're missing a 'where' or else you want to unindent the applyTwice definition
00:01:36 <lambdadelta> fruitFly: Just align everything to the left.
00:01:43 <Kinnison> fruitFly: Also, if you are expecting to run that code with main as a real main function, you might want a print in there :-)
00:01:46 * Kinnison heads to work
00:03:35 <fruitFly> lambdadelta: Kinnison I indented because I thought everything was a subset of main; I'm a total noob.
00:06:17 <lambdadelta> fruitFly: http://codepad.org/kUG44cHK - as you can see, I am no fan of using explicit type signatures :-P
00:08:43 <fruitFly> lambdadelta: :) .. They're only used for clarity, right?
00:08:51 <osa1> my program fails to build in hackage because hackage uses a older(3.0.1 instead of 3.0.5) version of Alex, I'm wondering if hackage will be updated soon(I tried writing some CPP direvtives to make it working with old Alex too, but old I can't install Alex 3.0.1 on my machine because some other library problems,Module `System.IO.Error' does not export `try' etc.)
00:11:38 <lambdadelta> fruitFly: Well, not just for clarity. Sometimes, you do need explicit type signatures. GHC has lots of type system extensions, some of which are so powerful they make type inference impossible for certain terms.
00:15:03 * shachaf wonders why people ask Haskell questions in ##categorytheory.
00:15:22 <mm_freak_> you don't wonder why people ask CT questions here, do you?
00:16:02 <shachaf> No. It is probably standard for a person who's sufficiently interested in Haskell-and-related-matters to be somewhat interested in category theory.
00:16:24 <shachaf> The reverse is not true. Most category theorists don't care about Haskell, no matter how much they learn about the topic.
00:17:19 <mm_freak_> but a discussion of topological spaces is probably just as OT here as a question about StateT is in ##categorytheory
00:17:25 <johnw> shachaf: because it's more of a CT question, and you have seemed in the past to think those were not the best thing for #haskell
00:17:27 <mm_freak_> i don't mind if we have both
00:17:30 <mmaruseacph2> I had a teacher on CT which said that Haskell is to CT as an apple is to food
00:18:25 <shachaf> Haskell is to CT as Norway is to food.
00:18:54 <mm_freak_> mmaruseacph2: haskell doesn't have much to do with CT, but it provides the framework to express CT ideas reasonably
00:19:15 <sw2wolf> What does @djinn mean ?
00:19:19 <shachaf> At any rate I don't answer people's questions in the other channel.
00:19:44 <mm_freak_> sw2wolf: turn a type into its corresponding expression, if possible…  search for "curry howard isomorphism"
00:19:49 <mmaruseacph2> that's exactly what the teacher meant :)
00:19:50 <mm_freak_> @djinn a -> b -> a
00:19:50 <lambdabot> f a _ = a
00:20:07 <mm_freak_> @djinn b -> (a -> b) -> Maybe a -> b
00:20:07 <lambdabot> f a b c =
00:20:07 <lambdabot>     case c of
00:20:07 <lambdabot>     Nothing -> a
00:20:07 <lambdabot>     Just d -> b d
00:20:22 <sw2wolf> mm_freak_: thx
00:20:40 <shachaf> As you can see, @djinn sometimes generates long output. So it's best used privately, in /msg, unless you're making a point.
00:21:00 <mmaruseacph2> isn't that true of all lambdabot's commands?
00:21:07 <mm_freak_> mmaruseacph2: not all
00:21:09 <mm_freak_> > [1..]
00:21:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:21:13 <mm_freak_> try that in private ;)
00:21:23 <sw2wolf> ok
00:21:41 <mm_freak_> (don't worry, it doesn't spam you forever)
00:22:00 <mmaruseacph2> :))
00:22:04 <mmaruseacph2> I saw :)
00:22:54 <djcoin> Is it easy in haskell to have meaningful errors reports - i mean with laziness and optimization, it sounds hard, but i have no experience with this
00:35:26 <fruitFly> @t zip
00:35:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:35:40 <fruitFly> @type zip
00:35:41 <lambdabot> [a] -> [b] -> [(a, b)]
00:38:38 <fruitFly> @type zipWith
00:38:42 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
00:42:14 <fruitFly> how do I check the implementation of zip instead of just it's type?
00:42:52 <h4199> @src zipWith
00:42:53 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:42:53 <lambdabot> zipWith _ _      _      = []
00:44:20 <fruitFly> @src zip
00:44:20 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
00:44:20 <lambdabot> zip _      _      = []
00:44:35 <fruitFly> thanks h4199  :)
00:46:13 <fruitFly> what are the rules for indenting in haskell? I though one would indent after main but that doesn't seem to be the case? How strict is the indenting? What do you think is best practice?
00:47:32 <osa1__> is there a way to check if Alex version if <= 3.0.2 in CPP ?
00:48:49 <h4199> http://en.wikibooks.org/wiki/Haskell/Indentation that should help you get the general idea, regarding main, treat it like any other function
00:48:56 * hackagebot basic-prelude 0.3.5.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.5.0 (MichaelSnoyman)
00:49:21 <lambdadelta> fruitFly: Indentation is for blocks. - http://hpaste.org/new
00:49:33 <lambdadelta> fruitFly: In that example, test1 and test2 are equivalent.
00:49:41 <lambdadelta> dammit
00:49:54 <lambdadelta> http://hpaste.org/86905
00:52:42 <fruitFly> lambdadelta: alright thanks? indent is 4 spaces? doesn't matter, right? I just can't tab in codepad.org that's why
00:54:15 <lambdadelta> fruitFly: Indentation is as many spaces as you want, as long as you are consistent.
00:54:39 <mm_freak_> i still have trouble deciding between conduit and pipes…  conduit seems to make everything easier and is much more actively developed…  on the other hand pipes just feels more "right"
00:55:25 <ion> I tend to use two spaces whenever nothing dictates otherwise (e.g. “let ” being four characters).
00:55:48 <mmaruseacph2> I use two spaces everywhere, set sts=2 in vim :)
00:56:11 <mm_freak_> fruitFly: haskell has an unusual coding guideline:  write readable code
00:56:12 <ion> I’d prefer elastic tab stops.
00:56:30 <johnw> aristid: ping
00:56:48 <johnw> mm_freak_: I think you're not alone there
00:57:02 <mm_freak_> johnw: about the conduit/pipes dilemma?
00:57:04 <johnw> mm_freak_: I use conduits because it gets the job done, but I'm always intrigued by Gabriel's posts
00:57:15 <h4199> mm_freak_: I have made a toy program with both and can't decide either. I was surprised by the lack of bytestring in pipes/proxy. Apparently it is in the works though
00:57:22 <johnw> that said, I really don't have any complaints at all about conduit.  it does what it does really well
00:57:32 <johnw> even if it may not have the glowing mathematical purity that pipes claims
00:57:49 <mm_freak_> johnw: currently i'm using pipes for new stuff, but i've become very unsure by gabrial still not replying to my mail…
00:57:57 <mm_freak_> gabriel
00:58:13 <johnw> maybe try him on google+
00:58:17 <h4199> He was in here today... wasn't he?
00:59:31 <mm_freak_> i don't want to create an account just to talk to one guy
01:00:20 <johnw> can't fault you there
01:00:37 <johnw> well, one thing I can say is this
01:00:45 <johnw> conduit has more of a community, because yesod is based on it
01:00:53 <mm_freak_> IMO as a developer not being reachable by mail = not existing, so i assume that either he's on vacation or something or he simply doesn't want to reply
01:01:03 <johnw> pipes still really the endeavor of one, albeit very enthusiastic and intelligent, person
01:01:12 <mm_freak_> yeah
01:01:30 <mm_freak_> despite the theoretical beauty of pipes i guess i'll go back to conduit
01:01:49 <johnw> just pretend you imported pipes and changed the names, and all will be well :)
01:01:59 <mm_freak_> hehe
01:02:31 <mm_freak_> what's his nickname here anyway?
01:02:46 <johnw> i don't know
01:03:11 <h4199> Tekmo right?
01:03:18 <mm_freak_> oh, that's him?
01:05:18 <h4199> I'm fairly certain
01:05:32 <johnw> he's active on reddit, at least
01:06:24 <fruitFly> why is zipWith' being called twice here:
01:06:25 <fruitFly> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]   [[3,4,6],[9,20,30],[10,12,12]]
01:06:37 <johnw> to zip the sublists
01:06:57 <mm_freak_> fruitFly: you zip the outer lists by zipping the inner lists
01:07:19 <mm_freak_> > zip ["abc", "def"] [[1..3], [7..9]]
01:07:20 <lambdabot>   [("abc",[1,2,3]),("def",[7,8,9])]
01:07:25 <mm_freak_> > zipWith zip ["abc", "def"] [[1..3], [7..9]]
01:07:29 <lambdabot>   [[('a',1),('b',2),('c',3)],[('d',7),('e',8),('f',9)]]
01:08:12 <fruitFly> mm_freak_: johnw the example is here http://learnyouahaskell.com/higher-order-functions#higher-orderism
01:08:45 <mm_freak_> fruitFly: do you understand what higher order functions are about?  (not what they are, but why they are great)
01:10:09 <fruitFly> mm_freak_: it just seems intuitive that functions should be able to take functions as parameters to me
01:10:17 <fruitFly> mm_freak_: I'm still just learning though
01:10:34 <mm_freak_> sure, that's the formal part…  it makes sense, but it's also very useful
01:10:51 <mm_freak_> fruitFly: http://www.youtube.com/watch?v=b9FagOVqxmI
01:11:12 <mm_freak_> a good and concise video about "higher-orderism" =)
01:11:49 <ion> That talk is nice.
01:11:50 <fruitFly> mm_freak_:  I imagine so... I'm looking at my above paste of the function.... it makes sense but I'm trying to understand the little details (maybe I shouldn't)... is (zipWith' (*)) being passed as the function to the first zipWith' along with the 2 [[]]s?
01:11:59 <h4199> speaking of mzero, has anyone played with plush?
01:12:16 <Chousuke> fruitFly: yes.
01:13:02 <mm_freak_> fruitFly: check out the two steps i did above and remember that zip = zipWith (,)
01:13:32 <mm_freak_> the outer zip passes each pair of sublists to the inner function to produce the result at that spot
01:13:53 <fruitFly> Chousuke: mm_freak_ wouldn't the first thing to be evaluated is zipWith' (*) and that would return a function that takes 2 lists... what exactly would that pass to the first zipWith' function... it seems as if it would lose some parameters.. but obviously I'm wrong
01:14:21 <mm_freak_> > zipWith (\xs ys -> (xs, ys)) ["abc", "def"] ["stu", "xyz"]
01:14:22 <lambdabot>   [("abc","stu"),("def","xyz")]
01:14:35 <Chousuke> fruitFly: think of what the first zipWith passes to the function you give it
01:14:42 <mm_freak_> so the function receives "abc" and "stu" and just turns it into "abc" and "stu"
01:14:49 <mm_freak_> but it may just as well zip them
01:15:14 <fruitFly> mm_freak_: zipWith takes a function too
01:15:24 <mm_freak_> > zipWith (\xs ys -> zipWith (\x y -> (x, y)) xs ys) ["abc", "def"] ["stu", "xyz"]
01:15:26 <lambdabot>   [[('a','s'),('b','t'),('c','u')],[('d','x'),('e','y'),('f','z')]]
01:15:27 <Chousuke> fruitFly: ie. what are the parameters (zipWith (*)) will receive
01:15:28 <fruitFly> @type zipWith
01:15:29 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
01:15:48 <mm_freak_> fruitFly: concentrate on the outer zip
01:15:56 <mm_freak_> what's the type 'a' in your example?
01:16:16 <mm_freak_> (let's assume 1 :: Int for simplicity)
01:17:25 <fruitFly> Chousuke: won't (zipWith (*)) execute and return a function that takes 2 lists as parameters... NO, right... because it also has to take the two lists as well.... or is the zipWith(*) not the first thing being evaluated? and like mm_freak_ says concentrate on the first one...
01:17:47 <fruitFly> mm_freak_: alright
01:18:00 <Chousuke> fruitFly:  yeah, you get a function that gets two lists as parameters
01:18:03 <fruitFly> I can kinda see the logic... but it isn't solid yet
01:18:11 <Chousuke> fruitFly: and that function is passed to the outer zipWith
01:18:25 <fruitFly> Chousuke: yes ok... then how does haskell apply * to [[]] and [[]]
01:18:27 <mm_freak_> fruitFly: 'zipWith f xs ys' isn't a function
01:18:55 <Chousuke> fruitFly: it doesn't. the nested lists are parameters to the *first* zipWith
01:19:30 <mm_freak_> fruitFly: 'zipWith f' on the other hand is a function, but that's not the source of your confusion
01:20:02 <mm_freak_> i understand your question this way:  how come that you use zipWith as the first argument to zipWith and not on the result?
01:20:08 <Chousuke> fruitFly: maybe it'd be clearer if you just defined f = zipWith (*) and looked at zipWith f [[...]]
01:20:29 <mm_freak_> i.e. why 'zipWith (zipWith f)' and not 'zipWith g (zipWith f xs ys)'
01:20:48 <fruitFly> Chousuke: so the first zipWith gets a function that takes 2 lists as parameters but it outputs them multiplied
01:21:26 <fruitFly> I'm just looking for where haskell rips the '[' ']' from the lists so it can multiply the inner lists
01:21:35 <mm_freak_> fruitFly: zipWith f [a,b,c] [x,y,z] = [f a x, f b y, f c z]
01:21:39 <mm_freak_> now all those values are lists
01:22:02 <fruitFly> Chousuke: ok, I will try that
01:22:10 <mm_freak_> zipWith (zipWith f) [as, bs, cs] [xs, ys, zs] = [zipWith f as xs, zipWith f bs ys, zipWith f cs zs]
01:22:16 <fruitFly> mm_freak_: gimmie a sec.. I'm gonna look at your logic now
01:22:51 <mm_freak_> just like:  map (map f) [xs, ys, zs] = [map f xs, map f ys, map f zs]
01:22:52 <Chousuke> fruitFly: basically, you're only looking at * and thinking it somehow multiplies lists, but what you should be paying attention to are the zipWiths
01:22:59 <mm_freak_> > map (map toUpper) ["hello", "there"]
01:23:00 <lambdabot>   ["HELLO","THERE"]
01:23:22 <mm_freak_> fruitFly: in fact you might rename zipWith to zipWith2 and map to zipWith1 =)
01:23:26 <fruitFly> mm_freak_: why isn't zipWith f xs ys a function and zipWith f is?
01:23:55 <mm_freak_> fruitFly: because of currying:  all functions take a single argument…  functions of multiple arguments are emulated by functions returning functions
01:24:08 <mm_freak_> fruitFly: more formally application notation is left-associative:  f x y = (f x) y
01:24:21 <mm_freak_> so when 'f x y' is correct, then 'f x' is a function and you can pass it another argument, y
01:24:45 <mm_freak_> fruitFly: correspondingly (->) is right-associative:  a -> b -> c = a -> (b -> c)
01:25:08 <mm_freak_> so:  hPutStrLn :: Handle -> String -> IO ()
01:25:14 <mm_freak_> is the same as:  hPutStrLn :: Handle -> (String -> IO ())
01:25:36 <mm_freak_> and you can write:  hPutStrLn stdout :: String -> IO ()
01:25:44 <mm_freak_> and apply it:  (hPutStrLn stdout) "blah"
01:26:01 <mm_freak_> which you can write more conveniently as:  hPutStrLn stdout "blah"
01:26:38 <mm_freak_> fruitFly: was that helpful?
01:27:57 <MichaelA> Hey, I need a bit of help with explaining algebraic data types. I mean, to me, it's just the way you define types in Haskell but there seems to be some deep underlying conceptual or mathematical difference between algebraic data types and, say, objects in other languages. Anyone got any pointers on that?
01:28:24 <fruitFly> mm_freak_: I think I get the idea of currying and left associative vs right associative.. it was helpful.. still rereading everything though
01:28:45 <fruitFly> mm i dn't know what stdout is thoug
01:28:47 <fruitFly> though*
01:28:54 <fruitFly> mm_freak_: ^
01:29:26 <mm_freak_> fruitFly: stdout is just the Handle that corresponds to the standard output of a program, likely the terminal
01:29:32 <mm_freak_> could be any other file handle
01:35:38 <johnw> did MichaelA really ask a question like that and then disappear??
01:36:20 <hvr> johnw: maybe he was impatient and didn't want to wait any longer...
01:36:28 <johnw> man, I really wanted to talk to him about it too
01:36:30 <hiptobecubic> johnw, 2 minutes is way too long
01:36:36 <hiptobecubic> people got shit to do!
01:36:45 * hiptobecubic watches cartoons
01:37:41 <mm_freak_> i was just about to answer, when he left =)
01:47:58 <eikke> I hate it when my ugly mutable/imperative version of some Vector operation is 5x faster than a nice high-level immutable version
01:50:58 <mm_freak_> eikke: either your algorithm is simply imperative in nature or you you find better ways to encode it purely
01:51:13 <mm_freak_> s/you you/you may/
01:59:37 <eikke> mm_freak_: merge 2 sorted vectors into a sorted vector
02:01:15 <mm_freak_> eikke: i see only ugly index-iterating ways to do it purely, but it should be just as fast as the imperative version
02:01:28 <t7> > let fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) (n - 2) in map fib [1..12]
02:01:29 <mm_freak_> maybe even faster when composed with other vector functions
02:01:29 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = a0 -> t0
02:01:38 <t7> oh whoops
02:02:25 <mm_freak_> eikke: i.e. start like this:  merge :: (Ord a) => V.Vector a -> V.Vector a -> V.Vector a
02:02:34 <t7> > let fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) + fib (n - 2) in map fib [1..12]
02:02:36 <eikke> mm_freak_: that's what I'm afraid of: the imperative version now won't compose using stream-fusion
02:02:36 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144]
02:02:43 <mm_freak_> eikke: merge xs ys = loop 0 0 where loop i j = …
02:02:57 <eikke> mm_freak_: that's what I got now, +- :)
02:03:39 <mm_freak_> eikke: really?  it should be about as fast as you can get…  also my example is missing the V.unfoldrN
02:03:39 <eikke> mm_freak_: https://gist.github.com/NicolasT/fe0715cf328d4c49ee3b
02:04:37 <mm_freak_> eikke: that looks very different from what i have in mind…  gimme a second
02:05:51 <eikke> mm_freak_: guess you'd keep a pair of ints as state for the unfoldr instead of actual  vectors
02:07:04 <eikke> didnt think of that indeed, but even then I'm afraid the 'Just' wrapping will be painful. There should be an unfoldrN' which takes (s -> (a, s)) instead of (s -> Maybe (a, s)) and requires N items to be produced
02:08:04 <eikke> mm_freak_: using unfoldr handling a 'tail' when 2 lists are completely different in size (handled by 'leftover' in the imperative version) will be painful
02:11:48 <hpaste> “Ertugrul Söylemez” pasted “Merge sorted vectors” at http://hpaste.org/86907
02:11:54 <mm_freak_> eikke: http://hpaste.org/86907
02:12:23 <mm_freak_> eikke: don't worry about the Just…  it shouldn't make a practical difference
02:12:48 <mm_freak_> and don't bother to use strict pairs, unless you unbox them as well, but that might turn out to be slower
02:14:08 <eikke> mm_freak_: I used -funbox-strict-fields
02:14:18 <mm_freak_> eikke: try with regular (,) first
02:14:35 <mm_freak_> i don't expect strict tuples to make a difference
02:15:28 <mm_freak_> eikke: from your code i infer that your main problem is bad sharing
02:15:29 <eikke> mm_freak_: interesting how your version prunes several guards, didn't consider that
02:15:38 <mm_freak_> my code uses full sharing
02:16:07 <mm_freak_> so i refer to the original vectors all the time…  the approach is ugly, but it's fast
02:17:54 <fruitFly> So haskell knows f is a function and assumes y and x are it's parameters? http://codepad.org/dGZZYUGk
02:18:50 <fruitFly> ok, right... I think I get it... you can't type out f without it's parameters.. makes no sense
02:19:03 <mm_freak_> fruitFly: sure it does
02:19:24 <Chousuke> is there a way to write flip point-free?
02:19:40 <mm_freak_> @pl flip f x y = f y x
02:19:41 <lambdabot> flip = flip
02:19:43 <mm_freak_> lol
02:19:47 <shachaf> Yes.
02:20:09 <eikke> mm_freak_: fwiw, my original 'merge2' is 5-6x time of 'merge', your version (adapted to use unsafeIndex instead of !) is 2-3x 'merge', so at least twice as fast as my merge2
02:20:24 <Lethalman> \o/
02:22:41 <mm_freak_> :t liftA2 (.) (liftA2 liftA2 id (const id)) (const const)
02:22:43 <lambdabot> (a -> b -> c) -> b -> a -> c
02:22:53 <mm_freak_> Chousuke: there
02:23:23 <mm_freak_> you can always remove points using const, id and (<*>)
02:23:23 <shachaf> @ty let s = ap; k = const in s (s (k s) (s (k k) s)) (k k)
02:23:24 <lambdabot> (b1 -> a -> b) -> a -> b1 -> b
02:23:30 <mm_freak_> to see how this works refer to SKI calculus
02:23:45 <mm_freak_> in particular to a process called abstraction elimination
02:24:47 <johnw> mm_freak_: I ran abstraction elimination on some of my math books, and now I just have book covers
02:24:47 <mmaruseacph2> http://www.haskell.org/haskellwiki/Calitatea_si_inspectorul_cozonacilor
02:24:54 <mmaruseacph2> there seems to be some spam on haskell wiki
02:24:59 <Chousuke> :P
02:24:59 <mmaruseacph2> at least on Romanian pages
02:25:08 <mm_freak_> lol
02:25:28 <Chousuke> mm_freak_: I'll keep that in mind.
02:25:35 <mmaruseacph2> in fact, why are there Romanian pages?
02:25:43 <mmaruseacph2> shouldn't the entire wiki be in english?
02:28:02 <mmaruseacph2> another one http://www.haskell.org/haskellwiki/Cum_se_rateaza_un_examen
02:28:03 <fruitFly> @src div
02:28:03 <lambdabot> Source not found.
02:28:10 <fruitFly> @type div
02:28:12 <lambdabot> Integral a => a -> a -> a
02:28:16 <fruitFly> -.-
02:29:18 <mm_freak_> eikke: i'd be interested in the results of your benchmarking
02:29:34 <eikke> mm_freak_: absolute numbers?
02:29:44 <mm_freak_> eikke: ideally both
02:29:50 <mm_freak_> but the relative numbers are most interesting
02:30:03 <eikke> mm_freak_: I'll resend my message ;)
02:30:06 <eikke> mm_freak_: fwiw, my original 'merge2' is 5-6x time of 'merge', your version (adapted to use unsafeIndex instead of !) is 2-3x 'merge', so at least twice as fast as my merge2
02:30:11 <mm_freak_> (oh
02:30:24 <mm_freak_> sorry, missed it =)
02:30:27 <eikke> np
02:30:44 <eikke> some 'core' reading up next ;)
02:31:06 <mm_freak_> eikke: i wouldn't expect it to be that slow…  let me think
02:31:40 <eikke> mm_freak_: this is ghc 7.4/HP, i'll retry using ghc 7.7something and a more recent 'vector' version as well
02:32:12 <eikke> and make sure the tuple is actually unboxed etc
02:33:10 <mm_freak_> i'm on GHC 7.6 and vector 0.10 here
02:33:54 <eikke> mm_freak_: will take some time, need to compile several criterion deps
02:34:03 * hackagebot packed-dawg 0.1.0.0 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.1.0.0 (AndrasKovacs)
02:34:05 * hackagebot scrabble-bot 0.1.0.0 - Scrabble play generation.  http://hackage.haskell.org/package/scrabble-bot-0.1.0.0 (AndrasKovacs)
02:34:42 <eikke> mm_freak_: I do think having an unfoldrN' without the maybe wrapping will help as well, consider http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/src/Data-Vector-Fusion-Stream-Monadic.html#unfoldrNM
02:35:04 <eikke> that introduces a useless check&branch
02:35:28 <mithsv> Anyone using gloss on OSX 10.8.3? The examples render a few frames and then freeze
02:36:37 <fruitFly> succintly, what is vector fusion or stream vectors or whatever? I heard it make haskell as fast pr faster than C or am I just waay off?
02:36:52 <mm_freak_> eikke: i see…  in that case composing map and iterateN may actually perform better
02:37:14 <mm_freak_> fruitFly: eliminating data structures from generated code
02:37:36 <mm_freak_> fruitFly: as a very simple example there is a law that map f . map g = map (f . g)
02:38:26 <mm_freak_> stream fusion and deforestation are both optimizations that turn list-like operations into stream operations and eliminate intermediate data structures
02:38:29 <fruitFly> mm_freak_: i'm just about to get to map in lyah... so what are the impliations of this to haskell?
02:39:00 <merijn> fruitFly: The implication is that you only traverse the argument list once instead of twice
02:39:02 <mm_freak_> fruitFly: the implication is that you may find that an idiomatic solution is just as fast or even faster than an ugly recursive or imperative solution =)
02:39:18 <merijn> fruitFly: The idea behind fusion can be summarised as "don't do in multiple loops what you could do in one single loop"
02:39:36 <mm_freak_> fruitFly: for example when you want to sum a list, don't bother to use explicit recursion…  just use foldl' (or sum)
02:39:44 <fruitFly> merijn:  mm_freak_  so this is a modern advent that speeds haskell the fuck up?
02:40:00 <merijn> fruitFly: It's not really modern, the idea is as old as compilers
02:40:01 <mm_freak_> fruitFly: basically yeah, mainly by saving allocations
02:40:08 <mauke> hey, wasn't fruitFly banned before?
02:40:23 <merijn> fruitFly: It's just that Haskell's semantics are much more amenable to these optimisations than C is
02:40:54 <merijn> fruitFly: C compilers first have to "prove" the nested loops can safely be merged without side effects screwing things up
02:42:00 <Lethalman> mm_freak_, so that a filter followed by a map followed by another map will be "fused" in a single loop?
02:43:07 <mm_freak_> Lethalman: that's the idea, but in that particular case i think there is a problem, because regular haskell lists use deforestation, which doesn't work well with 'filter'
02:43:07 <shachaf> mauke: Yes. As far as I can tell the bans are still there.
02:43:24 * Lethalman looks up deforestation
02:43:42 <merijn> Lethalman: Yes
02:44:04 <mm_freak_> shachaf, mauke: i don't see a reason to ban fruitFly though
02:45:11 <fruitFly> I was told I was banned by Elliot for some protontorpedoing, but as I'm actually trying to learn haskell Cale told me I was unbanned; I think he didn't see my subnet in the ban list.
02:45:37 <fruitFly> shachaf:  mauke ^^
02:46:16 <fruitFly> mm_freak_: and I think I understand the zipWith' example now well enough and the flip to move on
02:46:32 <fruitFly> thanks :) mm_freak_
02:46:40 <mm_freak_> you're welcome =)
02:48:31 <mm_freak_> is there an easy way to run ghc --make with cabal-dev?
02:48:41 <mm_freak_> i.e. circumventing cabal entirely
02:48:44 <fruitFly> merijn: mm_freak_ and I dn't want to get too brief into it as I'm a noob, but I dn't get the loops you guys were talking about pertaining to vector optimization as haskell "doesn't use loops"... it's sounds like some lower level stuff and I'm not exactly sure where it's happening or even how it's implimented... but it does make sense to use less loops
02:50:08 <true_droid> where can I find the source of Haskell's stdlib? I'd like to look at various instances of the Read type class
02:50:26 <tuxhat> hey i'm having a hard time to compiled xmobar on crux linux
02:50:28 <true_droid> for instance, :info Int shows that it's defined in GHC.Read
02:50:28 <mm_freak_> fruitFly: let me give a more fundamental note on this:  good haskell libraries (the vector library is one of them) are designed such that you can program in a declarative style without giving up good performance
02:50:38 <mm_freak_> fruitFly: that's why things like stream fusion exist
02:50:42 <true_droid> where do I look for GHC.Read?
02:50:50 <tuxhat> i have pretty much all the deps except for "text" which is where i get confused and parsec3
02:50:57 <mm_freak_> true_droid:
02:50:59 <mm_freak_> @hackage base
02:50:59 <lambdabot> http://hackage.haskell.org/package/base
02:51:12 <tuxhat> i have it install
02:51:18 <mm_freak_> tuxhat: do you use cabal-install?
02:51:19 <tuxhat> ghc-7.6.2-1
02:51:22 <tuxhat> i want to use it
02:51:29 <mm_freak_> tuxhat: you should
02:51:31 <tuxhat> but cabal isn't in v7.6.201
02:51:34 <tuxhat> i want to
02:51:42 <mm_freak_> when you use it, just type:  calba update && cabal install xmobar
02:51:47 <mm_freak_> s/calba/cabal/
02:51:49 <tuxhat> i know how to use cabal
02:51:59 <tuxhat> but why its not in ghc-7.6.2-1
02:52:11 <mm_freak_> tuxhat: because it's not part of GHC
02:52:25 <tuxhat> how can i install cabal-install
02:52:31 <tuxhat> it needs parsec3
02:52:38 <tuxhat> that is the problem
02:52:43 <tuxhat> and parsec3 needs text
02:52:45 <mm_freak_> tuxhat: ideally through the haskell platform
02:53:00 <mm_freak_> if you have linux, you can probably also install it through your package manager
02:53:02 <tuxhat> i have runghc
02:53:03 <true_droid> mm_freak_: thanks
02:53:23 <tuxhat> im using crux linux
02:53:26 <tuxhat> its source base
02:53:33 <mm_freak_> tuxhat: did you install GHC manually?
02:53:40 <tuxhat> yeah from source
02:53:52 <tuxhat> using a Pkgfile
02:53:55 <tuxhat> from crux
02:54:02 <mm_freak_> tuxhat: you should install the haskell platform instead…  if you prefer, you can install that one from source, if you're patient enough
02:54:16 <tuxhat> i have ghc install
02:54:36 <tuxhat> and ghc-x11
02:54:39 <tuxhat> and mlt
02:54:49 <tuxhat> i'm just missing parsec3
02:55:11 <mm_freak_> tuxhat: you'll probably be missing a lot more…  really make your life easier and install the platform
02:55:13 <tuxhat> that is why im asking what is the deal because i want to compiled cabal-install
02:55:18 <mm_freak_> http://www.haskell.org/platform/linux.html
02:55:32 <tuxhat> what u mean by platform
02:55:38 <tuxhat> i thought ghc was the platform
02:55:57 <mm_freak_> no, GHC is just a compiler
02:56:02 <tuxhat> i see
02:56:09 <tuxhat> thanks
02:56:14 <johnw> mm_freak_: and it installs a few core packages
02:56:19 <tuxhat> so where can i get the platform
02:56:26 <johnw> the link above
02:56:29 <mm_freak_> tuxhat: see the link i just posted
02:57:01 <tuxhat> aaa
02:57:10 <tuxhat> so ghc 7.4.2 is the platform ?
02:57:28 <johnw> no
02:57:33 <johnw> the Haskell Platform is the platform
02:57:46 <tuxhat> nevermind i see
02:57:48 <tuxhat> haha
03:00:07 <tuxhat> hmm
03:00:18 <tuxhat> it says i need ghc 7.4.2
03:00:20 <tuxhat> or something
03:00:43 <tuxhat> i have ghc 7.6.2-1
03:01:13 <tuxhat> hmm
03:03:25 <tuxhat> checking version of ghc... 7.6.2
03:03:28 <tuxhat> configure: error: The Haskell Platform version 2012.4.0.0 requires ghc-7.4.2
03:04:08 <mm_freak_> the platform is still on GHC 7.4?
03:04:22 <tuxhat> yeah
03:04:38 <tuxhat> unless u have a higher one
03:04:47 <tuxhat> this is 2012 4.0.0
03:04:54 <mm_freak_> i don't use the platform…  i'm using my package manager
03:05:12 <tuxhat> :p
03:05:23 <tuxhat> yeah usually that is the better case, but with crux is another story
03:05:35 <mm_freak_> i'm not familiar with crux, sorry
03:05:55 <tuxhat> :P yeah most people dont care for it.. but oh well
03:06:03 <tuxhat> matter of taste
03:06:33 <mm_freak_> if you want to keep GHC 7.6 you should simply fetch the needed packages from hackage and use the included Setup.lhs script until you have cabal-install working
03:06:36 <tuxhat> maybe if compiled 7.4.2
03:06:44 <mm_freak_> then you simply install the rest through cabal-install, including xmobar
03:07:23 <tuxhat> how u use it to compiled Setup.lhs ?
03:07:45 <tuxhat> runghc Setup.lhs configure ?
03:08:07 <tuxhat> i was trying to  compiled parsec3
03:08:21 <mm_freak_> tuxhat: yeah
03:08:22 <tuxhat> i need parsec3 and text
03:08:36 <mm_freak_> be sure to fetch the correct version
03:08:44 <tuxhat> hmm
03:08:52 <tuxhat> how u work runghc ?
03:08:55 <tuxhat> it has no man
03:08:56 <tuxhat> for it
03:09:12 <mm_freak_> just the way you said
03:09:20 <mm_freak_> runghc Setup.lhs configure
03:09:21 <mm_freak_> runghc Setup.lhs build
03:09:23 <mm_freak_> runghc Setup.lhs install
03:09:29 <tuxhat> aaa thanks
03:09:32 <mm_freak_> fetch packages from hackage:  http://hackage.haskell.org/package/parsec
03:10:04 <mm_freak_> if in doubt review this:  runghc Setup.lhs --help
03:10:33 <tuxhat> yeah darcs
03:10:46 <tuxhat> ok freak thanks :)
03:10:58 <mm_freak_> you're welcome and good luck =)
03:11:15 <tuxhat> thanks
03:11:19 <tuxhat> aa i see
03:11:30 <tuxhat> now its crying about text
03:11:33 <tuxhat> thats what i need man
03:11:40 <mm_freak_> then install text first =)
03:11:45 <mm_freak_> @hackage text
03:11:45 <lambdabot> http://hackage.haskell.org/package/text
03:12:02 <mm_freak_> the installation process is the same for all packages
03:12:11 <tuxhat> i try that
03:12:15 <tuxhat> here is the problem
03:12:29 <tuxhat> its asking of CA certificates
03:12:41 <mm_freak_> huh?  for what?
03:12:52 <tuxhat> or its not a repository
03:12:59 <mm_freak_> not a repository
03:13:05 <mm_freak_> install from the source tgz
03:13:06 <tuxhat> darcs failed
03:13:35 <tuxhat> yeah
03:13:45 <tuxhat> i think i tried that
03:13:51 <tuxhat> and reason i came in here
03:13:52 <tuxhat> lulz
03:14:10 <mm_freak_> to install a package you do precisely these steps:  1. download the tar.gz for the version you need from hackage, 2. extract, 3. use the Setup.lhs script like above
03:14:19 <mm_freak_> haskell packages are very consistent in that matter
03:14:32 <tuxhat> but thats where i went wrong
03:14:36 <tuxhat> i didnt build it
03:14:39 <tuxhat> i just install it
03:14:44 <tuxhat> now its building
03:14:48 <mm_freak_> if you used darcs, you didn't follow these steps ;)
03:14:56 <tuxhat> thanks for teachign me more on the complitor
03:15:06 <tuxhat> compilor
03:15:14 <mm_freak_> compiler =)
03:15:31 <tuxhat> haha yeah man i have no sleep been hacking on crux all morning
03:15:32 <tuxhat> lulz
03:16:46 <tuxhat> hmm missing mtl i thought i install this
03:19:21 <mm_freak_> tuxhat: if you install GHC 7.4 you can simply use the haskell platform
03:19:49 <mm_freak_> it installs all these core libraries for you with three short commands
03:20:19 <tuxhat> yeah
03:20:24 <tuxhat> i guess i'm better with that
03:20:32 <tuxhat> i have transformer 0.3
03:20:39 <tuxhat> but its saying it depends on it
03:20:43 <tuxhat> woot
03:23:42 <Jaxan> does ghc always uses gcc, or can I tell it to use clang?
03:25:17 <mm_freak_> Jaxan: it shouldn't use gcc at all
03:25:19 <quicksilver> Jaxan: it normally doesn't use a C compiler at all
03:25:27 <Jaxan> oh really
03:25:29 <Jaxan> hmm I thought so
03:25:35 <quicksilver> it did used to.
03:25:55 <quicksilver> but these days it has two backends, one a native one written byt he GHC devs and one which goes via llvm.
03:26:05 <quicksilver> (the via-C backend is still there for porting I think)
03:26:25 <mm_freak_> there is the "unregisterised" mode for porting
03:26:59 <shachaf> GHC still generates some C code as part of normal compilation, I think. But not C compiled from Haskell code.
03:27:26 <tuxhat> hmm mtl 2.1.2 is built on ghc-7.4
03:27:36 <quicksilver> mm_freak_: (unregisterised does go via C thought doesn't it?)
03:27:50 <tuxhat> i can't compiled mtl
03:28:21 <shachaf> There's also unregisterised via LLVM.
03:28:52 <quicksilver> interesting
03:29:10 * quicksilver doesn't understand what the point of that would be but doesn't have time to ask the right questiosns.
03:29:13 <mm_freak_> quicksilver: i think it's not the same thing…  unregisterised mode is specifically for unsupported platforms
03:29:25 <mm_freak_> so it uses as much portable C as possible and doesn't use some optimizations
03:29:44 <mm_freak_> i think it even reintroduces the big STG main loop
03:30:00 <tuxhat> parsec says it needs mtl any i have 1.1.0.2 installed i don't understanding why it says i depends on it when its install hmm
03:30:15 <mm_freak_> tuxhat: because mtl 1 is old
03:30:20 <mm_freak_> you want mtl 2.1.x instead
03:30:27 <mm_freak_> @hackage mtl
03:30:27 <lambdabot> http://hackage.haskell.org/package/mtl
03:30:32 <tuxhat> yeah
03:30:39 <tuxhat> but it fails to build it
03:30:57 <mm_freak_> tuxhat: use the platform ;)
03:31:02 <tuxhat> hahhaa
03:31:13 <tuxhat> to save me the trouble eh
03:31:20 <mm_freak_> yeah
03:31:28 <mm_freak_> that's what the platform is for after all
03:33:22 <mm_freak_> is there a way to invoke ghc --make through cabal-dev?
03:34:50 <supki> ghc -package-db=cabal-dev/packages-*.conf --make =)
03:35:26 <tuxhat> cool
03:35:40 <tuxhat> haskell is so cool
03:39:57 <t7> ruby is cool
03:40:01 <t7> haskell is meh
03:40:15 <dEPy> ok
03:40:40 <tuxhat> haskell is not meh great language, once again its a matter of taste
03:41:00 <johnw> ooh: ghc: panic! (the 'impossible' happened)
03:41:04 <johnw> don't see that often
03:41:26 <t7> johnw, i take it you are not on windows
03:41:36 <johnw> nope
03:41:37 <johnw> Mac
03:43:34 <johnw> oh, hehe
03:43:48 <johnw> I had misspelled a deriving type class as "ord" instead of Ord
03:43:50 <johnw> gotta report that
03:44:07 <supki> that's known bug I think
03:44:17 <supki> unless you're on 7.6 or something
03:44:22 <johnw> no, i'm on 7.4
03:44:29 <johnw> do you know the ticket number, or what keyword to search for?
03:44:36 <supki> yeah, that should be fixed already
03:44:36 <supki> hmm
03:44:52 <shachaf> I assume "report that" means "search for it in the bug database and make a new bug if it's not there".
03:45:16 <quicksilver> johnw: http://hackage.haskell.org/trac/ghc/ticket/6073#comment:1 ?
03:45:21 <ion> Yeah, that one has been fixed AFAIU. Try upgrading to 7.6.
03:45:26 <johnw> excellent
03:45:37 <johnw> can't upgrade, sadly
03:45:42 <ion> Why?
03:45:56 <quicksilver> well that particular bug is hardly a reason to upgrade
03:46:06 <quicksilver> once you know the problem, you fix it
03:46:15 <ion> quicksilver: Sure, i’m just curious
03:46:22 <shachaf> haskell-platform with 7.6 will be out soon
03:47:06 <mm_freak_> supki: thanks
03:47:18 <ion> I’m totally fine with “don’t feel like upgrading”, but “can’t upgrade, sadly” made me curious. :-)
03:52:51 <dudlite777> hey this might be a stupid question but if I paste my own code into pastebin that is for a university assignment, could I be done for plagerism since it shows up on google when you search it?
03:53:13 <Jaxan> dudlite777: you can put your name in the pastebin?
03:53:16 <Botje> you can mark pastes as private in some pastebins.
03:53:42 <Botje> alternatively, sign the post with your GPG key :]
03:53:49 <dudlite777> I uploaded it a day ago and have just submitted my assignment
03:54:01 <dudlite777> just thought of it after, and sure enough it comes up on google
03:54:06 <dudlite777> anything i can do?
03:54:14 <Botje> get it removed from said pastebin.
03:54:29 <merijn> dudlite777: Preemptively mail your professor that that's your post and hope you can convince him
03:54:42 <merijn> dudlite777: Alternatively, try to delete it and hope there's no match
03:54:55 <dudlite777> Thanks, I will email the professor
03:55:04 <Botje> next time, use a private pastebin :P
03:55:09 <dudlite777> yeah lol
03:55:42 <mauke> or twitter a md5 hash of your code so you have timestamped proof :-)
03:57:29 <hpaste> test revised “tiny parser”: “test” at http://hpaste.org/86885
03:58:37 <hpaste> mitchell revised “parser”: “edit” at http://hpaste.org/86786
03:59:18 <hpaste> mitchell revised “tiny parser”: “edit” at http://hpaste.org/86804
03:59:34 <mm_freak_> sometimes the granularity of haskell libraries is inconvenient
03:59:52 <johnw> is there any way to create a data constructor synonym?  I can do type A = B, and a = b, but what about A = B, where A and B are data constructors?
03:59:55 <mm_freak_> i think i've never written a project that uses directory without filepath
04:00:30 <mm_freak_> johnw: you can write a = B, but not A = B, i.e. you can't pattern-match using the alias
04:00:41 <johnw> i think that's good enough
04:00:45 <johnw> oh, no, it's not
04:01:02 <johnw> but I can use view patterns to get where i want to go
04:01:09 <mm_freak_> or lenses or …
04:01:35 <ion> unsafeCoerce
04:01:41 <mm_freak_> btw, in many cases you can use pattern guards instead of view patterns…  that way you don't have to enable an extension
04:04:01 <tuxhat>  attempting to use module `Prelude' (./Prelude.hs) which is not loaded
04:04:05 <johnw> i use ViewPatterns in every file I write
04:04:09 <johnw> so that ship has sailed :)
04:04:23 <tuxhat> when i try to compiled the base and it also said i need unix
04:04:33 <mauke> > let () | x <- 42 = () in ()
04:04:35 <lambdabot>   ()
04:04:46 <mauke> tuxhat: why are you trying to compile base?
04:05:00 <tuxhat> well i need the platform
04:05:01 <ion> tuxhat: You don’t need to compile base separately. You already got it when you installed GHC.
04:05:18 <ion> don’t need to, and shouldn’t.
04:05:28 <tuxhat> well ok cool
04:06:00 <dudlite777> woohoo it's all gone =D
04:06:10 <dudlite777> thank god for edit
04:07:06 <tuxhat> the ghc platform said it needs like ghc-7.4.2
04:07:12 <tuxhat> so i tried to compiled that
04:07:15 <mauke> no
04:07:19 <mauke> the platform comes with ghc
04:07:31 <tuxhat> well i do ./configure
04:07:35 <tuxhat> and it say that
04:07:40 <tuxhat> what do u want me to say
04:07:46 <mauke> stop doing configure
04:07:48 <mauke> what is even going on
04:07:54 <mauke> what are you trying to achieve?
04:08:10 <tuxhat> um to install haskell platform
04:08:14 <tuxhat> from source
04:08:19 <mauke> why from source?
04:08:29 <tuxhat> because i'm on a source base system
04:08:42 <ion> wat
04:09:00 <tuxhat> some systems are source base
04:09:02 <tuxhat> :P
04:09:03 <mauke> what
04:09:17 <tuxhat> crux linux is a source base distro
04:09:22 <mauke> and?
04:09:41 <tuxhat> well and well thats why i have source of haskell platform to install the platform
04:09:47 <tuxhat> adn thats why i use ./configure
04:10:00 <mauke> no, that doesn't explain anything
04:11:52 <tuxhat> so i'm trying to install haskell platform from source and when i do a ./configure << which says on their page i get the error: the haskell platform version 2012.4.0.0 requires ghc-7.4.2
04:12:12 <mauke> have fun
04:15:47 <mm_freak_> tuxhat: what mauke is trying to say is that your distribution doesn't support haskell very well ;)
04:16:21 <tuxhat> it does support it umm if haskell provides source for it .. since i do have ghc-7.6.2 install
04:16:45 <tuxhat> what i'm guessing is that you can not install the platform source if u have ghc-7.6.2 already installed
04:17:14 <mm_freak_> the haskell platform is based on GHC 7.4, so you should install that one instead
04:17:34 <mm_freak_> IIRC there are binary releases, so you don't really need to build from source, but that's up to you
04:17:36 <tuxhat> which i did try to do and it ask it depends on haskell-base and haskell-unix
04:19:47 <tuxhat> how can i get the binary releases
04:20:31 <typoclass> tuxhat: check this http://www.haskell.org/ghc/download
04:20:39 <mm_freak_> tuxhat: http://www.haskell.org/ghc/download_ghc_7_4_2
04:21:27 <mm_freak_> tuxhat: as a side note, if you prefer source-based distributions, but want a distribution that is more haskell-friendly (i.e. install everything you need with one command), check out nixos
04:21:42 <mm_freak_> https://nixos.org/
04:22:15 <mm_freak_> not that i suggest to switch your whole distribution, but an interesting side note =)
04:23:55 <ion> However, i do suggest to swtich your whole distribution.
04:23:58 <ion> Just kidding. :-P
04:24:46 <tuxhat> i have debian on my other sata , the reason i have crux on my second sata for this reason doing things in a source base world
04:24:53 <typoclass> nixos is source based? i'll remove it from the list of stuff i wanted to look at
04:25:11 <tuxhat> i dont want nixos .. i have crux because i like it and once again its a matter of taste
04:25:12 * typoclass thinks that (no offense) the whole "source only" thing is a giant waste of cpu time. and people's time.
04:25:20 <tuxhat> to what u like .. and this is what i like and works well for me
04:26:33 <tuxhat> ghc-7.4.2-x86_64-unknown-linux.tar.bz2 << is that the binary release ?
04:27:00 <mm_freak_> typoclass: it's source-based in a good manner, i.e. you still get binary packages =)
04:27:16 <typoclass> mm_freak_: ok fair enough
04:27:29 <tuxhat> all bsd distros are source base
04:27:40 <tuxhat> but they do have binary package manager
04:27:45 <typoclass> tuxhat: yes that seems to be the binary for amd64
04:28:05 <tuxhat> ok thanks , but it seems i have to still compiled it
04:28:47 <mm_freak_> typoclass: the idea is this:  nix can actually guarantee that iff you build package P with configuration X and there is a binary available for it, you can safely use the binary version
04:28:48 <typoclass> tuxhat: i think that .tar.bz2 contains binary files (not source files)
04:29:06 <tuxhat> umm
04:29:20 <ion> tuxhat: Are you trying to package haskell-platform for the distro or do you just want it installed?
04:29:25 <mm_freak_> typoclass: depending on your system configuration that may mean that you might build a few packages from source, but the bulk will be binary
04:29:31 <tuxhat> i just want it install
04:30:25 <typoclass> mm_freak_: fair enough
04:30:46 <tuxhat> yeah freak is right
04:31:15 <ion> tuxhat: Something like this <https://gist.github.com/ion1/2815423> might be less painful. I don’t tend to install haskell-platform, i do that and install whatever packages i need using cabal.
04:33:39 <tuxhat> well
04:33:51 <tuxhat> i'm missing dep for cabal
04:33:57 <tuxhat> i normally would use cabal
04:34:37 <tuxhat> i need persec3 but i'm missing mtl and i try to build it but i get a bunch of code and it stops building
04:35:36 <typoclass> tuxhat: either you need the platform, or alternatively, you first need ghc, then cabal, then everything else
04:37:04 <tuxhat> http://pastebin.com/YgFdyzuN
04:37:10 <mauke> The paste YgFdyzuN has been copied to http://hpaste.org/86917
04:37:14 <tuxhat> i said about 5 times already i have ghc-7.6.2
04:37:40 <typoclass> tuxhat: ok sorry, i came in in the middle of the discussion
04:37:50 <tuxhat> no problem its ok
04:37:51 <tuxhat> :P
04:38:03 <tuxhat> i just want a solution
04:38:07 <tuxhat> and some help
04:38:29 <t7> should have used the platform
04:38:29 <tuxhat> i need mtl 2.1 to get cabal-install
04:38:39 <t7> thats what people test against usually
04:38:48 <tuxhat> yeah i know but its too late now
04:38:59 <t7> nah just remove ghc
04:39:17 <tuxhat> well i dont know how to remove ghc from a source base
04:39:57 <tuxhat> well if i can get mtl 2.1 sorted
04:40:19 <tuxhat> i can get persec3 install and i can install cabal-install
04:44:04 <typoclass> does the newest mtl (2.1.2) build with ghc 7.6? http://hackage.haskell.org/package/mtl-2.1.2 mentions "built on ghc 7.4" but doesn't talk about 7.6
04:44:28 <tuxhat> hmm
04:44:40 <tuxhat> well
04:46:40 <tuxhat> http://www.cruxmeister.net/ports/cruxmeister/
04:49:09 <nimish> is there a nice way to extract results from postgresql-simple for queries like "select 2+2" without creating a newtype wrappers?
04:49:18 <supki> typoclass: yes
04:49:29 <nimish> since there doesn't seem to be a nice FromRow instance for Int, just fromfield
04:49:39 <typoclass> supki: yes it builds?
04:49:47 <supki> typoclass: yes =)
04:51:51 <typoclass> supki: thanks for confirming. how weird. then i wonder what the "Could not deduce a ~ b from the context" stuff is http://hpaste.org/86917
04:52:07 <mm_freak_> typoclass: yes it does
04:52:16 <mm_freak_> … for me at least
04:52:23 <typoclass> mm_freak_: thanks
04:58:20 <supki> runghc Setup.hs build works too
05:00:33 <typoclass> does Setup.hs check for missing dependencies, like "cabal install" does?
05:00:42 <supki> yes
05:00:50 <dcoutts> typoclass: yes
05:00:51 <supki> well, configure step checks
05:00:58 <typoclass> ok, thanks
05:02:08 <supki> I don't get what Control.Monad.Signatures is in that log
05:02:50 <typoclass> supki: it's puzzling, isn't it
05:04:07 * hackagebot openssl-streams 1.1.0.0 - OpenSSL network support for io-streams.  http://hackage.haskell.org/package/openssl-streams-1.1.0.0 (GregoryCollins)
05:04:14 <tuxhat> ok i just remove ghc-7.6.2 by doing pkgrm ghc
05:04:27 <tuxhat> now i edit the Pkgfile and change the version to 7.4.2
05:04:32 <tuxhat> no compiling
05:04:35 <tuxhat> now
05:04:58 <tuxhat> yesh is compiling
05:05:37 <tuxhat> so cabal is in 7.4.2 right
05:06:02 <tuxhat> oh yeah thats true i need to compiled the platform
05:07:08 <tuxhat> this is gonna take along time i need to top up my coffee cup :-B
05:08:11 <typoclass> tuxhat: just for double-checking -- compiling ghc yourself takes a long time and is generally pointless. if you have any chance, it's recommended to use the binary .tar.bz2 packages from here http://www.haskell.org/ghc/download_ghc_7_4_2
05:08:11 <tuxhat> i personally find haskell goes well with source base systems :P
05:08:49 <tuxhat> well typo i know but i use crux
05:09:00 <eikke> tuxhat: so?
05:09:49 <tuxhat> i think it is compiling the binary source
05:09:59 <mauke> hahaha
05:10:12 <tuxhat> yup
05:10:13 <geekosaur> typoclass, the package utilities mentioned indicate they're on freebsd; fbsd ports is build-from-source
05:10:17 <tuxhat> it got the binary source
05:10:17 <geekosaur> and while there are packages, they're often out of date
05:10:48 <tuxhat> well im not using freebsd but crux ports system is much so like freebsd
05:11:30 <tuxhat> anyways to answer typo im compiling the binary source
05:11:48 <tuxhat> sorry i thought i was compiling the src but its the binary one
05:11:50 <tuxhat> my bad
05:12:18 <tuxhat> ghc-7.4.2-linux-unknown_x86_64.tar.bz
05:12:23 <tuxhat> ^ thats the binary one eh
05:12:42 <tuxhat> bz2*
05:12:51 <tuxhat> thats the once its compiling
05:12:58 <tuxhat> it still take along time :P
05:13:52 <tuxhat> but thats ok at least i can get mtl and all that other nice stuff if i choose not to use platform
05:14:22 <tuxhat> or maybe i should just compilied platform
05:14:37 <typoclass> tuxhat: i'm not sure what you mean by "the binary source", but that file name you quoted looks good. it'll contain the ghc binaries and scripts that can install them
05:14:57 <tuxhat> yeah
05:15:02 <tuxhat> the version is good
05:15:11 <tuxhat> mtl doesn't support 7.6.2
05:15:39 <tuxhat> mtl-dev perhaps support 7.6.2
05:16:58 <tuxhat> hmm the person that done the Pkgfile for crux he should of use the platform version u know.. hmm common human i suppose..
05:16:59 <typoclass> tuxhat: well i asked earlier, and two people reported mtl builds on ghc 7.6, so i guess something else was going on. (although i have no idea what. the compiler output that you pastebinned was quite puzzling to me.)
05:17:32 <tuxhat> yeah for me too
05:17:34 <tuxhat> lulz
05:17:55 <tuxhat> i think 7.6.2 is a bad version for crux
05:18:09 <tuxhat> it should be 7.4.2 i should report it to the guy
05:18:21 <tuxhat> i just change the version
05:19:10 <tuxhat> its nice i'm one of the few people that installs haskell on crux
05:19:19 <tuxhat> i like the challenge
05:19:57 <tuxhat> crux is a very unix type system its not unix but the way the system is design is very much like unix
05:22:18 <tuxhat> its easy to setup haskell on debian sudo apt-get cabal-install
05:22:21 <tuxhat> :P
05:23:33 <tuxhat> but debian to me like most distro is too automatic and it baby you to much which i hate.. i like a manual system where i have full control over all my stuff on it and also it makes you understand each source more
05:25:37 <mm_freak_> can i stop hoogle from downloading stuff?  it should generate ONLY the documentation i specify
05:33:19 <immanuelkant> @ty nub
05:33:21 <lambdabot> Eq a => [a] -> [a]
05:33:31 <immanuelkant> @ty length.nub
05:33:32 <lambdabot> Eq a => [a] -> Int
05:34:34 <eikke> hmh, shouldnt the /topic be updated? I thought GHC 7.6.3 was released some time ago?
05:34:41 <tuxhat> What You See is What You Get
05:37:23 <tuxhat> i'm guessing 7.6.3 is Dev
05:37:41 <tuxhat> if it exist
05:38:05 <typoclass> eikke: probably yes! though "some time" is only 4 days :-)
05:38:28 <tuxhat> lulz
05:38:37 <tuxhat> 4 days is not "some time ago"
05:38:50 <tuxhat> its more like it just release not long ago
05:38:55 * typoclass has no idea how to use lambdabot's frightening @topic thingy
05:39:08 <tuxhat> does it matter
05:39:11 <quicksilver> it doesn't work, I don't think
05:39:14 <tuxhat> is the question
05:40:21 * tuxhat is compiling 7.4.2
05:40:23 <tuxhat> :P
05:41:10 --- mode: ChanServ set +o quicksilver
05:41:14 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by quicksilver
05:41:20 --- mode: quicksilver set -o quicksilver
05:46:54 * typoclass wonders idly why the topic has this faux-[String] look
05:47:21 <tuxhat> :P
05:47:37 <Kinnison> typoclass: probably managed by lambdabot
05:47:48 <eikke> typoclass: my feeling of timespans is severaly damaged
05:47:52 <Kinnison> typoclass: and to that end, it's probably not faux so much as Show.
05:48:10 <tuxhat> looks alright to me :P
05:48:25 <eikke> typoclass: most of the time I have no clue whether I did something today, yesterday or somewhere last week :-/
05:48:46 <tuxhat> gives it more a "#haskell" to it
05:49:39 <typoclass> Kinnison: not sure. lambdabot has a facility for that, but i think it's a bit difficult to use. quicksilver just now didn't seem to use it
05:50:29 <tuxhat> to be honest and keep it simple , if you understand the topic it's what matter. and besides it is just a topic
05:50:46 <Kinnison> typoclass: I imagined that lambdabot would be able to manage it, and as such quicksilver kept it in the right format.  Maybe I was wrong :-)
05:51:40 <typoclass> Kinnison: yes, well, maybe we can put it this way -- lambdabot can manage the topic, but we can't manage lambdabot :-)
05:51:48 <Kinnison> :-)
06:09:18 * hackagebot linux-blkid 0.1.0.0 - Linux libblkid  http://hackage.haskell.org/package/linux-blkid-0.1.0.0 (NicolaSquartini)
06:16:13 <matthiasgoergens> Is there a way to get Haskell-code running on Google Native Client?
06:33:53 <zebr> hey all. is there a name for a structure which has with it a set of functions, so e.g. you have a triple t=(a,b,c) and that as associated (f,g,h) such that (g y t) = (a, g b, c)
06:33:59 <zebr> sorry if that seems a bit vague
06:34:15 <zebr> oops, i meant (a, y b, c)
06:34:51 <zebr> i think it would be right to say it has a set of associated functors?
06:35:59 <Cale> no constraints on f or h?
06:36:15 <Cale> also, what's y?
06:36:28 <Cale> oh
06:36:30 <zebr> no constraints. and y is a function
06:36:30 <Cale> er
06:37:10 <Cale> So, you only want to constrain g
06:37:18 <Cale> There's no name for this
06:37:55 <mauke> this sounds like a record with accessors
06:37:57 <zebr> Cale: hm, ok. is it correct to say it's a functor, since g lifts y?
06:38:22 <Cale> uhhh
06:38:23 <mauke> inb4 lenses
06:38:25 <zebr> (forgive me, i have yet to really 'get' cat theory)
06:38:29 <byorgey> yes, it is a functor
06:38:34 <Cale> There is a functor involved here
06:38:48 <Cale> but it's not necessarily going to be an instance of Functor
06:38:53 <byorgey> I don't understand what f and h have to do with anything though
06:39:00 <Cale> Yeah, neither do I
06:39:08 <mauke> they're accessors for the 1st/3rd field
06:39:12 <Cale> Wat
06:39:13 <mauke> g is for the 2nd yield
06:39:18 <Cale> But he said they were unconstrained1
06:39:21 <byorgey> oh, so it's a trifunctor?
06:39:25 <zebr> sorry i misunderstood >.>;
06:39:26 <mauke> g y (a,b,c) = (a, y b, c)
06:39:32 <zebr> i meant them to be constrained, sorry
06:39:37 <shachaf> Does Nikita Volkov have a nick here?
06:39:44 <mauke> f y (a,b,c) = (y a, b, c)
06:39:57 <Cale> zebr: ^^ do you want that equation to be true?
06:40:47 <quchen> One feature of laziness is that it's a sort of optimization on a high level, unnecessary code is never executed. However, all the concrete cases this benefits that I can think of are one-line examples. Are there nontrivial, practically relevant ones that you have encountered in the past?
06:40:48 <zebr> yeah - though i want it to be extendable to any arbitrary structure, not just a triple. a list, say, has n of them.
06:41:02 <zebr> or a tree
06:41:34 <zebr> so is there a more specific name than just a functor? a .. multifunctor? :p
06:42:08 <mauke> quchen: dynamic programming with lazy arrays
06:42:29 <Cale> Well, lists are a bit of a challenge because if you have a list of values and a list of functions, they might not have the same length.
06:42:44 <Cale> Or for trees, there's nothing to guarantee that the trees' shapes line up.
06:42:59 <int-e> quchen: Data.MemoTrie stuff, and don't forget that laziness is what allows us to define custom control structures.
06:43:00 <quchen> mauke: For memoization?
06:43:29 <mauke> quchen: I'm not sure whether this counts as memoization
06:43:44 <zebr> Cale: what if it were a set that was *defined* as, well, lining up?
06:43:57 <quchen> int-e: Custom control structures as in "hand-crafted if things to suit specific problems"?
06:44:01 <int-e> (defining   if b x y = if b then x else y   would be a horrible idea in a strict language)
06:44:21 <quchen> mauke: What did you mean with it then?
06:44:31 <mauke> dynamic programming
06:45:39 <quchen> mauke: In the sense that you can throw lots of functionality at a problem, and have the program decide which ones to use during runtime?
06:45:56 <Cale> zebr: well, okay, for triples, you get a functor C^3 -> C which in the case of Haskell sends a triple of types to the type of triples, and a triple of functions to a function of triples.
06:46:09 <mauke> quchen: I don't understand the question
06:47:13 <Cale> The objects of C^3 are triples of objects of C, and the arrows (X,Y,Z) -> (X',Y',Z') in C^3 are simply triples of arrows (f: X -> X', g: Y -> Y', h: Z -> Z')
06:47:18 <quchen> mauke: Well, I don't understand what you meant with "dynamic programming" in conjunction to my question. Isn't dynamic programming just breaking up your program in many little parts?
06:47:36 <mzero> any chance Ganesh S. is here?
06:47:50 <shachaf> mzero: Yes -- Heffalump.
06:47:54 <Cale> and the composition and identities are the "obvious" ones -- just elementwise composition on triples
06:48:09 <mauke> quchen: no, the parts also have to be self-similar
06:48:21 <int-e> quchen: laziness may be less important than we like to think; its main benefit has been said (by SPJ?) to be that it kept the language pure.
06:48:26 <Cale> and there's a functor C^3 -> C which sends each triple (X,Y,Z) to the product type X x Y x Z, which in Haskell we even write as (X,Y,Z)
06:48:28 <mauke> quchen: and they should overlap
06:48:47 <mauke> quchen: and that's more a description of the kinds of problems dynamic programming is a solution to
06:49:15 <Cale> and which sends an arrow of C^3 (which is a triple of arrows of C) to the appropriate arrow X x Y x Z -> X' x Y' x Z'
06:49:57 <quchen> int-e: Yes, laziness has many other benefits (such as making Haskell work in the first place). I just wondered about the performance gain it could provide in some cases.
06:50:23 <int-e> quchen: but I've found that things like infinite lists are really nice, conceptually, and that's not limited to one-liners. (dynamic programming has been mentioned. also having a library provide a list of all primes is really nice for reusability (up to the point where you need too many primes and exhaust your memory.))
06:50:44 <mauke> quchen: this is the "stupid" (memoization based) variant of dynamic programming, yes
06:51:22 <quchen> mauke: Do you have an example of arrays used like this? Doesn't need to be code, just a concept
06:51:22 <mauke> quchen: but instead of writing a lookup table, checking whether the result is already known, and storing new results, etc., we simply abuse laziness
06:51:41 <quchen> mauke: Well, that's a sort of memoization then
06:51:42 <mauke> we blindly pre-generate the whole table of results
06:51:57 <mauke> thanks to laziness only the values actually required at runtime will be computed and stored
06:52:04 <quchen> Oh, right. You can "pre-memoize".
06:52:12 <mauke> (laziness is like write-once storage)
06:53:13 <tomejaguar> Laziness is merely a syntactic nicety.  It's a very nice nicety (perhaps much preferable to the alternative) but it is completely replicable in a strict language by using lambdas and memoization.
06:53:39 <mauke> tomejaguar: that can be slow as fuck
06:54:26 <mauke> also, I don't think that's memoization
06:54:27 <mzero> also - QuickCheck maintainers around? Koen C. or Nick S.?
06:54:29 <shachaf> Laziness is a rather nicer primitive than "memoization".
06:54:40 <tomejaguar> mauke: lambdas *and* memoization
06:54:46 <tomejaguar> That's exactly what laziness is
06:54:49 <Sculptor> yo
06:54:53 <mauke> tomejaguar: no
06:55:14 <tomejaguar> mauke: Do you have a counterexample?
06:55:16 <mauke> well, unless you're talking about memoizing a zero-argument function
06:55:20 <tomejaguar> mauke: yes
06:55:23 <mauke> but I still don't like the term
06:55:36 <mauke> but that's besides the point
06:56:09 <tomejaguar> The point I was trying to make is that the only benefit of laziness in Haskell is that allows a nice syntax.
06:56:22 <mauke> try taking a language such as python and sprinkling local functions everywhere and see how fast it is
06:57:16 <quchen> tomejaguar: That sounds a little too general, almost as if laziness could be seen as sugar.
06:57:39 <mauke> it is, in a way, but it's super pervasive
06:57:57 <mauke> like implementing continuations by rewriting your whole code in CPS
06:58:10 <tomejaguar> mauke: That's how GHC does it.
06:58:21 <tomejaguar> quchen: Laziness is exactly sugar.
06:58:23 <mauke> ghc is designed for it
06:58:52 <tomejaguar> Oh, I don't think doing that would be performant in an *arbitrary* language
06:59:05 <tomejaguar> but there's no reason performant laziness could not be supported in a strict language.
06:59:09 <shachaf> What is sugar?
06:59:17 <shachaf> Is Haskell sugar for x86 machine code?
06:59:27 <tomejaguar> shachaf: Take a strict language, wrap everything in "
06:59:29 <tomejaguar> ...
06:59:30 <luite> it's sugar for JavaScript code
06:59:31 <tomejaguar> in "
06:59:41 <mauke> receive string literals
06:59:43 <tomejaguar> (where's my backslash ...)
07:00:08 <tomejaguar> Wrap everything in "memoize \() -> ..."
07:00:12 <tomejaguar> and you have a lazy language
07:00:20 <mauke> tomejaguar: that's broken
07:00:27 <mauke> you also have to change your accessors
07:00:40 <tomejaguar> How so?
07:00:59 <tomejaguar> You have to make all you datatypes contain memoized computations rather values
07:01:05 <tomejaguar> but that's the same thing.
07:01:22 <mauke> print(2 + 2); would turn into something like print()((memoize \() -> 2 + 2)())
07:01:43 <tomejaguar> Right
07:01:49 <mauke> no, wrong actually
07:01:56 <mauke> depending on how you want print to work
07:02:08 <tomejaguar> Well, you have to be careful with IO
07:02:24 <mauke> anyway, I'm not sure global transformations really count as "sugar" anymore
07:02:42 <shachaf> +()(2())(2())()
07:03:05 <tomejaguar> My original claim was "syntactic nicety"
07:03:21 <shachaf> How about "semantic nicety"?
07:03:31 <applicative_> is strictness also a syntactic nicety for laziness?
07:03:33 <shachaf> And by "nicety" I mean "s".
07:03:41 <ion> How about “semitic nicety”?
07:03:54 <tomejaguar> applicative_: yes, by putting ! in front of all function arguments
07:03:58 * applicative_ is trying to find the dual of 'nicety'
07:04:07 <tomejaguar> (... and data fields I guess)
07:05:11 <shachaf> So "nicety" means "can be compiled into"?
07:05:35 <mauke> C is a syntactic nicety for Lisp
07:06:05 <tomejaguar> What I mean by "laziness is a semantic nicety" is that you can get all the benefits of laziness in a strict language with a simple syntactic rewriting process.
07:06:26 <mauke> that's where I disagree
07:06:27 <tomejaguar> operationally that is
07:06:40 <tomejaguar> One of the benefits is syntax.  That benefit you obviously lose.
07:06:49 <tomejaguar> mauke: What's your disagreement?
07:06:50 <mauke> the other benefit is the rest of the language
07:06:52 <armlesshobo> elegants?
07:06:55 <armlesshobo> elegance*
07:07:10 <mauke> you can't introduce laziness "locally"
07:07:29 <applicative_> this must mean something like 'all codata and operations on them' can be expressed in a language with just functions as codata. Or something ...
07:07:31 <mauke> it changes how you write libraries and how you interact with the rest of the language
07:07:44 <mux> tomejaguar: have you read that "optional laziness doesn't cut it" blog entry?
07:08:38 <aristid> johnw: pong?
07:08:59 <aristid> johnw: -> Query?
07:12:09 <armlesshobo> you can't just flipflop between evaluation types and expect the same result/behavior
07:13:37 <hpaste> “Anonymous Coward” pasted “cool probability thing” at http://hpaste.org/86922
07:15:56 <parcs> the cool part is that draw n is equivalent to randomRIO (1,n)
07:16:13 <armlesshobo> haha
07:20:14 <parcs> i.e. you can model a discrete uniformally-random variable with N values by performing N consecutive yes/no experiments and stopping on the first success
07:27:10 <tomejaguar> mux: I have not.  I will check it out, thanks.
07:28:03 <parcs> there is a proof of the divergence of the harmonic series in there
07:28:51 <mux> tomejaguar: pointing it out because it expresses my point of view on this worded in a much better way than I would be able to
07:29:27 <dmwit> parcs: I think one thing that's neat about draw is that it can lazily emit Succ constructors.
07:29:41 <dmwit> Which randomRIO probably cannot do.
07:30:33 <armlesshobo> mux: "Well, in my experience, lazy-by-default languages (meaning Haskell) tend to suffer from the dual problem: it's hard to figure out exactly where you need to put your strictness annotations."
07:31:10 <armlesshobo> can it really be that difficult? (honest question)
07:31:12 <parcs> dmwit: ooh nice
07:32:10 <dmwit> armlesshobo: It takes experience and tool support. (Like most other programming skills.)
07:32:47 <applicative_> oh man, suddenly to get remote access to my library I need to install a java something runtime.  maybe we should start tricking people into install ghc this way
07:33:55 <luite> applicative_: and then bundle the ask toolbar with update, profit!
07:34:07 <lambdadelta> applicative_: What (as in what program) exactly needs you to install a Java-something-runtime?
07:34:36 <armlesshobo> vnc?
07:35:22 <applicative_> lambdadelta: I'm not sure, I sign into some webpage that gives me remote access to the system, and thus privileges to look at journals etc
07:35:30 <klrr> is lazy evaluation unsafe in the sense that if some argument is false but never gets evaluated then that error might not be cought ?
07:35:30 <lambdabot> klrr: You have 1 new message. '/msg lambdabot @messages' to read it.
07:35:36 <fizbin> lambdadelta: Some libraries (the buildings with books in them) require the use of a java applet or JWS program to access their holdings.
07:35:39 <applicative_> but today I couldn't sign in because there was a 'missing plugin'
07:35:58 <dmwit> > const 3 (error "klrr, I don't think that's unsafe!")
07:35:58 <mauke> klrr: I'm not sure that question makes sense
07:35:59 <lambdabot>   3
07:36:20 <applicative_> yes, it seems fizbin would comprehend whatever it si
07:36:20 <applicative_> is
07:36:57 <armlesshobo> lazy means that the expression isn't evaluated until it absolutely has to be.
07:37:00 <klrr> mauke: consider this http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2.1 it tells that in applicative order eval it would produce an error with lazy it wouldnt, isnt this kind of unsafe to not check if all arguments are correct?
07:37:03 <eikke> mm_freak_: I'm afraid I won't be able to provide numbers with more recent GHCs (well, HEAD), too many packages not building due to API changes in base, and no time to fix now
07:37:05 <applicative_> fizbin: but the applet is some small nothing that comes when I ask for the page, only I couldn't run it?
07:37:41 <mauke> klrr: I don't understand what you mean by "correct" and "unsafe"
07:37:45 <fizbin> applicative_: Right, because your web browser probably has (sensibly!) disabled java applets.
07:38:05 <mauke> klrr: consider this: in C, if (0) { hello(); } will never call hello()
07:38:13 <applicative_> hm
07:38:14 <mauke> isn't this unsafe if calling hello would produce an error?
07:38:14 <klrr> mauke: unsafe in the sense that the error is not cought until the test in the if is false
07:38:19 <klrr> so it requires more testing
07:38:39 <mauke> klrr: similarly if (x) { f(); } else { g(); } will never call both f and g
07:38:43 <mauke> klrr: so it requires more testing
07:38:53 <mauke> wouldn't it be better to always call them both?
07:38:56 <lambdadelta> klrr: If a thunk will never be evaluated, it may as well be bottom, and it should not matter.
07:39:15 <klrr> okey, well it was just a thought
07:39:41 <klrr> is it more difficult to implement lazy evaluation if you're making a lisp or can i just use the stuff in sicp?
07:41:38 <applicative_> > if False then error "Strict!" else "Lazy"
07:41:39 <lambdabot>   "Lazy"
07:42:06 <lambdadelta> klrr: Why would lazy evaluation be difficult to implement? If you are using a strict language, all you need is a mutable cell which may be unevaluated (with some evlauation function) or evaluated (with some value).
07:42:08 <klrr> haskell is lazy
07:42:45 <applicative_> > if False then error "Strict!" else if False then error "Strict!" else "Lazy?"
07:42:46 <lambdabot>   "Lazy?"
07:42:50 <t7> > length [error "strict!"]
07:42:51 <lambdabot>   1
07:43:35 <klrr> lambdadelta: i just thought, in my current working prototype it evaluates the args and then apply them, i cant seem to figure out a way to implement that so that the args are not evaluate but still applied to the functions body somehow
07:43:58 <simpson> klrr: Consider this example from Python, which is non-lazy by default: if False: raise RuntimeError("Strict!");; else: print "Lazy?"
07:44:01 <armlesshobo> it evaluates the expression and memoizes it
07:44:02 <applicative_> presumably normal order evaluation is easier to implement than strict or lazy.
07:44:09 <latermuse> how is the error function not in a monad?
07:44:26 <armlesshobo> @type error
07:44:28 <lambdabot> [Char] -> a
07:44:28 <lambdadelta> latermuse: Why would it have to be in one?
07:44:39 <latermuse> I was thinking it would act like putStrLn
07:44:55 <klrr> ?src error
07:44:55 <lambdabot> error s = throw (ErrorCall s)
07:45:03 <lambdadelta> latermuse: Perhaps you were thinking about fail?
07:45:05 <klrr> ?type error
07:45:07 <lambdabot> [Char] -> a
07:45:13 <latermuse> ahh yes! fail
07:45:15 <lambdadelta> ?type fail
07:45:18 <lambdabot> Monad m => String -> m a
07:45:27 <Cale> fail is an abomination
07:45:40 <mauke> fail is merely in the wrong class
07:45:42 <lambdadelta> Cale: Yeah, but what can be done about it?
07:45:51 <Cale> It can be moved out of Monad
07:45:55 <Jaxan> nuke it from orbit
07:46:09 <armlesshobo> > fail "I failed"
07:46:11 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
07:46:11 <lambdabot>    arising from a use of `M36331557...
07:46:21 <armlesshobo> see, not as effective
07:46:24 <armlesshobo> as
07:46:28 <armlesshobo> > error "I failed"
07:46:30 <lambdabot>   *Exception: I failed
07:46:45 <Cale> I would really like to see the old Haskell 1.4 translation of the do-notation.
07:46:46 <mauke> > fix fail
07:46:47 <lambdabot>   ""
07:46:50 <shachaf> class Monad m => MonadZero m where mzero :: m a; mzero = fail "mzero"; fail :: String -> m a; fail _ = mzero; {-# MINIMAL fail #-}; {-# MINIMAL mzero #-} -- ?
07:46:51 <armlesshobo> > error "Exception:"
07:46:52 <lambdabot>   *Exception: Exception:
07:47:18 <eikke> what does the MINIMAL pragma do?
07:47:25 <Cale> Or at least some combination of that using fail from a separate class in place of MonadZero/mzero
07:47:39 <shachaf> Nothing, until it's implemented.
07:47:41 <shachaf> @google minimal complete definition ghc trac
07:47:43 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7633
07:47:44 <lambdabot> Title: #7633 (Checkable "minimal complete definitions") – GHC
07:47:49 <eikke> oh, interesting
07:48:14 <eikke> can't the compiler figure that out automatically though?
07:48:27 <lambdadelta> Should Monad not simply be pure and join, or pure and (>>=)?
07:48:30 <shachaf> How?
07:48:41 <applicative_> sure
07:48:43 <shachaf> (Did you read the GHC issue?)
07:48:48 <eikke> not yet
07:48:51 <applicative_> you would need a functor instance
07:49:21 * hackagebot finite-field 0.5.0 - Finite Fields  http://hackage.haskell.org/package/finite-field-0.5.0 (MasahiroSakai)
07:50:05 <shachaf> class Applicative m => Monad m where (>>=) :: m a -> (a -> m b) -> m b; join :: m (m a) -> m a; m >>= f = join (fmap f m); join m = m >>= id; {-# MINIMAL (>>=) #-}; {-# MINIMAL join #-}
07:50:46 <applicative_> that would be nice if ghci would also tell me whats minimal with :info ...
07:52:34 <applicative_> as it is, :i Foldable gives 8 undifferentiated methods.
07:53:22 <Eduard_Munteanu> Couldn't it figure out the minimal definition by itself, theoretically?
07:53:23 <shachaf> Foldable documentation suggests that implementing foldr is reasonable.
07:53:30 <shachaf> It's not. It's evil. You should implement foldMap.
07:53:35 <shachaf> Eduard_Munteanu: How?
07:53:45 <shachaf> (Did you read the ticket linked above?)
07:54:33 <Eduard_Munteanu> shachaf: it can look at the definitions and see if there are circular references, I think
07:54:36 <Eduard_Munteanu> No, I should.
07:55:39 <Eduard_Munteanu> Ah, I see, they thought about it but turned it down.
07:55:51 <applicative_> the idea of making an applicative constraint on monad is a good one.   I want the ZipList instance for lists, then I'll use ap for the other ....
07:56:17 <shachaf> Eduard_Munteanu: You mean #6028?
07:56:39 <Eduard_Munteanu> shachaf: yeah
07:56:44 <shachaf> That's turned down because it's wrong.
07:57:00 <shachaf> And see Alternative, which has two methods which are explicitly meant to be mutually recursive in terms of each other.
07:57:14 <Eduard_Munteanu> Yeah, I suppose you can't make it accurate.
07:57:24 <Eduard_Munteanu> Right, that'd fail.
07:57:53 <int-e> Eduard_Munteanu: in easy cases, probably. but imagine we add  fold f = Fix . fmap (fold f) . unFix  to Functor's type class for some reason, what would an automatic analysis say about the status of this  fold?  (newtype Fix f = Fix { unFix :: f (Fix f) }; fold :: Functor f => (f a -> a) -> Fix f -> a; if I have not messed up)
07:59:21 <Eduard_Munteanu> I see.
07:59:26 <applicative_> shachaf: your ticket got the 'jolly useful' from spj; there's glory for you
08:00:04 * applicative_ remember a sentence about laziness being 'jolly convenient'
08:00:18 <shachaf> Given that doing it automatically would seem to involve solving the halting problem in general, I thought manual annotation isn't so bad, given that everyone does it anyway.
08:00:38 <eikke> spj is a jolly good fellow :)
08:01:23 <applicative_> yes, its a waste on reflection that such a comment is written but isn't used
08:01:51 <shachaf> goodfellow is a jolly goodfellow
08:01:57 <shachaf> < 'a'
08:01:59 <goodfellow>   'a'
08:02:02 <shachaf> good goodfellow
08:02:30 <applicative_> Ord has everything mutually definable, but if I remember one point of entry is unusually disastrous
08:05:49 <applicative_> hm thats not right, at least as Ord stands.
08:06:29 <applicative_> Shaladdle: is WV.CC.CMU.EDU the West Virginia Community College of Carnegie Mellon University?
08:06:40 <geekosaur> heh
08:07:10 <applicative_> well they have one in Qatar or wherever ...
08:07:49 * geekosaur doesn't think he ever heard what that was supposed to mean, but it's the main campus wireless.
08:08:12 <applicative_> ah
08:08:16 <geekosaur> given how generally behind the networking there usually was, I always read WV as wavelan :p
08:08:47 <dmwit> WaveLAN with closed captioning
08:09:24 * applicative_ across the ravine thought they were always super-advanced in every possible respect
08:09:25 <ibotty> hi, i think i might have a very easy question regarding hunit.
08:09:25 <ibotty> how do i assertEqual IO(ByteString)s?
08:10:39 <geekosaur> considering how long it took them to figure out the concept of subnetting...
08:11:55 <applicative_> ibotty: it's clear you can't use assertEqual directly
08:13:02 <applicative_> but liftM2 (==) iobs1 iobs2 would get you close to something, no, ibotty
08:13:32 <adahlberg> https://gist.github.com/addahlbe/b2ed07571001b04859e9       anyone mind taking a look at my tree. I would like to return none or do nothing. But I am new to Haskell and am having trouble find something on the web that is the equivalence. The code is commented where I am having problems.
08:14:09 <mauke> adahlberg: you can't "do nothing"
08:14:12 <ibotty> applicative_:  i think so. i thought that that should be so comon to have something in HUnit itself or so.
08:14:39 <tuxhat> building the haskell platform now
08:14:42 <mauke> adahlberg: your type signature says treeValue always returns a value (of type 'a'), even for empty trees
08:15:54 <mauke> adahlberg: you could change it to treeValue :: Tree a -> [a]
08:15:59 <mauke> and concatMap treeValue
08:16:12 <adahlberg> okay, Ill try that, thanks.
08:16:37 <Mortomes> Or treeValue :: Tree a -> Maybe a
08:21:05 <applicative_> ibotty: of course theres also lifting assertEqual "mycomment" , e.g. mx >>= \x -> my >>=  assertEqual "hi" x and the like.
08:22:10 <applicative_> join $ liftM2 (assertEqual "ahem") mbs mbs2
08:22:30 * applicative_ is missing something obviously simpler
08:23:22 <ibotty> i thought about
08:23:23 <ibotty> TestCase $ assert $ liftM (== "abc") iobs
08:23:23 * dmwit writes down this example
08:23:53 <ibotty> but that does not really work. (failure gets counted as success)
08:24:22 * hackagebot http-streams 0.6.0.0 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.6.0.0 (AndrewCowie)
08:24:23 <ibotty> (oh, i misread my ghci output)
08:24:42 <ibotty> it just does not tell me what happened :/
08:27:44 <applicative_> give the wrong string
08:27:50 <applicative_> it rather
08:28:00 <ibotty> ?
08:28:43 <ibotty> what i get is something like the following:
08:28:44 <ibotty> ### Failure:
08:28:44 <ibotty> Cases: 1  Tried: 1  Errors: 0  Failures: 1
08:28:44 <ibotty> Counts {cases = 1, tried = 1, errors = 0, failures = 1}
08:29:03 <ibotty> (with a blank line in between failure and  cases)
08:33:23 <ibotty> applicative_: thank you. lifting assertEqual is quiet clean, so i did that
08:46:17 <augur> koninkje_away: we should totally read this Keenan and Stabler book
08:47:54 <Eduard_Munteanu> earspliT4: what are you up to?
08:49:02 <quicksilver> splitting, apparently
08:50:03 <fizbin> Weird.
08:51:39 <mm_freak_> eikke: oh, thanks for trying, but you didn't have to go through the trouble =)
08:55:48 <eikke> mm_freak_: I want that stuff to run for my own purposes anyway, so will work on it later ;)
09:03:37 <bob981> hello
09:03:56 <klrr> hi bob981
09:04:39 <bob981> hay klrr, im doing an assignment and have no idea how to do it
09:05:27 <Cale> bob981: What are you trying to do, and what have you tried?
09:06:00 <fizbin> bob981: Okay, but be aware that many people in this channel will try to give you hints and pushes (given that this was a homework assignment) rather than outright answers.
09:06:04 <bob981> i have to writea parser for Tiny language thingy.
09:06:30 <bob981> umm...
09:06:36 <bob981> data Exp = Zero | One | TT | FF | Read | I Ide |
09:07:24 <applicative_> with Hutton's parser library
09:07:42 <bob981> <factor> ::= read | false | true | 0 | 1 |  <ide> | (<expr>)
09:08:00 <bob981> ok, ive done most, except im stuck on <ide>
09:08:16 <fizbin> bob981:  Use hpaste (http://hpaste.org) for quoting much code.
09:08:23 <mauke> hahahaha
09:08:34 <mauke> it's deja vu all over again
09:08:45 <bob981> for eg, read is
09:08:47 <bob981>  factor                        =  do symbol "read"
09:09:17 <bob981> >                                     return Read
09:09:18 <lambdabot>   Not in scope: data constructor `Read'
09:09:19 <lambdabot>  Perhaps you meant `Dead' (imported f...
09:09:42 <bob981> i dont know how to do the <ide>
09:09:44 <mauke> bob981: we've seen this exercise before
09:09:47 <mauke> or at least I have
09:10:31 <bob981> oh have you?
09:10:41 <bob981> i also have to implement the cmd for it
09:10:58 <bob981> all my friends are lost on it and cannot help
09:11:08 <mauke> do you know any haskell?
09:11:20 <hpaste> Agentomega pasted “Problems with Where” at http://hpaste.org/86931
09:11:21 <applicative_> bob981: you are in New Zealand?
09:11:54 <mauke> Agentomega: unmatched '('
09:12:06 <Agentomega> Ohhhhhhhhhhhhh.  I feel like a derp now.  Thanks guys XD
09:12:12 <Botje> bob981: you already have an `ident' parser that parses the representation of an identifier.
09:12:12 <bob981> http://fpaste.org/9578/33830813/
09:12:13 <mauke> my work here is done
09:12:56 <Agentomega> Mauke, you are a code ninja.  Thanks for your help haha
09:13:18 <bob981> hay yes im in new zealand
09:13:47 <bob981> ive lined u the code thing i have
09:14:07 <mauke> you also have the Parsing module
09:14:17 <mauke> which is where 'ident' is provided
09:14:21 <bob981> yea, my code uses the basic parser, as ull see in the code what ive done
09:15:00 <bob981> im not sure how to write the <ide> in this code. everything ive tried comes up with errors
09:15:19 <jfischoff> What are reasons to use Free monad ( package free etc.) encoding of language instead of straightforward ADT of the AST? (I don't care about Data type ala carte extendability)
09:15:33 <mauke> bob981: well, what exactly have you tried so far?
09:15:51 <klrr> anyone know what kind of program i could write tonight?
09:15:58 <Clint> a useful one
09:16:01 <tuxhat> cabal install :)
09:16:14 <klrr> Clint: like what?
09:16:28 <tuxhat> thanks for the help and company hackage community, until next time. . . i'm signing off
09:16:30 <bob981> tbh, i have no idea what im doing with this assignment. but my lecturer said the identifier is tricky to write
09:16:31 <tuxhat> cheers
09:16:43 <Clint> klrr: one that takes an .ics file, splits it into individual events, and uploads those to a caldav server
09:17:15 <bob981> do i have to like write another thing like term called ide?
09:17:27 <hseg> Can anyone point me to a tutorial for defining tokenizers for Parsec?
09:17:37 <klrr> Clint: okey, (0) what's a .ics file, what format etc.? (1) events? hmm what's an event in this context? (2) caldav server? do i need certain access or sth?
09:17:58 <Kinnison> hseg: Do you mean using the extant tokeniser builder stuff, using alex, or something else?
09:18:42 <hseg> Using the builtin Parsec tokenisers. I think they're defined in Text.Parsec.{Language,Tokens}
09:18:48 <Kinnison> okay
09:18:48 <Kinnison> erm
09:18:55 <south> I have a quick question
09:18:56 <Clint> klrr: (0) icalendar/rfc5545 (1) a calendar event, demarcated by BEGIN:VEVENT and END:VEVENT (2) http or https, probably authenticated
09:19:09 <south> Would you guys mind helping me out?
09:19:11 <Kinnison> hseg: I do a very simple one in my calculator example on youtube
09:19:32 <Cale> south: We won't know until you ask it! :)
09:19:36 <chrisdotcode> hello everyone :)
09:19:41 <south> Hi!
09:19:45 <south> And alright cool, here's the question
09:19:48 <hseg> Kinnison: This? http://www.youtube.com/watch?v=G8WW3bGIZFc&playnext=1&list=PL_xuff3BkASMOzBr0hKVKLuSnU4UIinKx&feature=results_main
09:19:54 <Kinnison> hseg: http://www.youtube.com/watch?v=dmG7uldiiM0 might help you a little.  Otherwise I don't know of tutorials per-se
09:19:55 <chrisdotcode> hi south
09:20:06 <applicative_> bob981: Isn't Ide short for 'identifier', I don't think you'd want identifiers with parentheses etc in the middle of them
09:20:12 <south> If I have a data type like defined like data Example a = Example (Example a) (Example a)
09:20:16 <Cale> south: (and answering beginner questions is a large part why we're here)
09:20:18 <Kinnison> hseg: that series, but the one I referenced
09:20:20 <klrr> Clint: too difficult
09:20:23 <klrr> :(
09:20:31 <Clint> :(
09:20:50 <south> Is there a way to assert that, for example, Example (Example 1) (Example 2) == Example (Example 2) (Example 1) for pattern matching purposes?
09:20:53 <Cale> south: There's only one completely defined value of that type for a given choice of a
09:20:56 <Kinnison> hseg: I'm not the best explainer, but at least you can follow along on-screen and with the git repo :-)
09:21:00 <fizbin> bob981: Do you have any guidance anywhere on what can be in an identifier?
09:21:03 <hseg> OK.
09:21:04 <Cale> south: and it looks like an infinite tree
09:21:12 <Cale> ex :: Example a
09:21:14 <hseg> south: You could define an Eq instance for Example
09:21:15 <south> Yeah, that's correct
09:21:17 <Cale> ex = Example ex ex
09:21:28 <mauke> south: what's the 'a' parameter for?
09:21:42 <south> What I'm actually doing is building a little algebraic interpreter
09:21:50 <fizbin> bob981: For example, do you know that identifiers must be only alphanumerics, or only letters, or any non-space character?
09:21:52 <south> The 'a' parameter is for a number
09:22:13 <south> So the actual thing I'm curious about is if I have
09:22:29 <Cale> Maybe something like  data Tree a = Leaf a | Branch (Tree a) (Tree a)
09:22:59 <south> I've got an Expression data type with +, -, etc
09:23:26 <south> but right now I'm pattern matching like this : hopefully this makes sense...
09:23:26 <south> simplify (a :*: (Const 1))         = simplify a simplify ((Const 1) :*: a)         = simplify a
09:23:31 <bob981> umm... this chat is soo tiny
09:23:46 <south> Agh, that's supposed to be two lines
09:23:48 <fizbin> south: You can't quite do what you want directly, but a thing to try is have a function called "canonical" that takes an Example object and sorts things into a standard form and then write your function as: foo ex = case (canonical ex) of … and use pattern matches in the case statement.
09:24:30 <south> @fizbin I think that makes sense
09:24:30 <lambdabot> Unknown command, try @list
09:24:34 <bob981> heres what ive got, http://fpaste.org/9583/36733905/
09:24:45 <south> erm, how do I talk at people? Haha
09:24:54 <mauke> bob981: maybe try http://webchat.freenode.net/ instead?
09:24:59 <bob981> this is the factor part. dont know how to write the ide part
09:25:04 <applicative_> bob981: it's odd, the problem is <ident> isn't explained anywhere. Note that the Hutton library defines something like it http://hpaste.org/86805
09:25:11 <mauke> south: by using their name
09:25:17 <south> mauke okay, haha
09:25:46 <fizbin> bob981: Because if you don't know what should be allowed in an identifier, it's going to be hard to write a parser for it.
09:25:57 <Kinnison> hseg: If you have any ideas for additional haskell videos, let me know.  I'm doing some videos about my git server software right now, then I'll probably want to return to Haskell for a bit
09:26:00 <bob981> string
09:26:16 <bob981> > type Ide  =  String
09:26:19 <lambdabot>   <hint>:1:1: parse error on input `type'
09:26:45 <hseg> Kinnison: Thanks.
09:27:24 <south> fizbin: I thought there might be a language extension or something that allowed for it, but I guess not -- seems like "canonical" would sort of move the logic rather than avoid writing it
09:28:17 <south> But, that's okay! My simplification code just goes through a lot o fcases so I thought I'd ask. Thanks for the help everyone!
09:28:23 <fizbin> bob981: Yes, I saw that, but … maybe I'm not explaining it well. If absolutely *any* character could be in an identifier, what's to prevent your parser from taking the entire program as a single identifier and concluding that the way to parse it is just "I <program text>"
09:29:33 <JordiGH> So if you need to do something like write a device driver where you need to manipulate addresses in memory and all that fun stuff, how do you do this in Haskell?
09:30:03 <applicative_> fizbin: exactly, there must be a characterization implicit.  The other guy said it couldn't begin with a capital; I think it was the same as Hutton's ident
09:30:45 <bob981> i dont know. i dont understand any of it. but need to do this (due in a few hours)
09:30:48 <applicative_> on line 88 here http://hpaste.org/86805
09:31:14 <bob981> yup, all that is imported
09:31:24 <fizbin> applicative_: Okay, if it's that then isn't "ide" just: do { s <- identifier; return s }
09:31:40 <geekosaur> you don[t understand any of it but ... this sounds like badness
09:31:55 <bob981> http://fpaste.org/9587/36733948/
09:32:00 <bob981> is my full code so far
09:32:04 <applicative_> not quite, it is to return an Exp rather a String, so it should be return (I s) I guess
09:32:31 <theOtherTrueMike> hey folks
09:32:52 <fizbin> applicative_: Right, forgot the "I"
09:33:10 <klrr> if something is of type "IO ..." i think it as "IO Foobar - a function that returns a Foobar and may do a side-effect action", but this only applies to the IO monad i guess how should i think of other monads and what are they useful for?
09:33:48 <applicative_> bob981: lines 101-2 of yours don't typecheck do they?  The Exp you're looking for in that alternative is going to be of the form I x
09:34:51 <bob981> that bit of code i dont understand what im supposed to do. nothing ive tried works and lecturer said its a tricky part
09:35:06 <applicative_> Ide is not an expression, its a synonym for String.  You wouldn't write ... return String
09:35:14 <mauke> bob981: are you just arranging characters?
09:35:21 <mauke> or do you understand some haskell
09:35:26 <fizbin> bob981: So with your code, I'd rip out lines 101-103 and instead at the bottom of factor (after the "(" clause) put:
09:35:31 <applicative_> hi theOtherTrueMike
09:35:37 <bob981> i understand some haskell yes, buit not this part :P
09:35:41 <fizbin> do s <- identifier
09:35:54 <fizbin>     return (I s)
09:36:41 <theOtherTrueMike> I have been trying to learn haskell for fun, and have run into some stack over flow problems. Anyone care to help me understand tail recursion?
09:37:08 <applicative_> tail recursion probably isn't the problem
09:37:13 <theOtherTrueMike> well
09:37:14 <cschneid> theOtherTrueMike: tail recursion is only tangentially relevant to learning haskell.
09:37:29 <theOtherTrueMike> i wrote a aritficial neural network
09:37:38 <bob981> "I is bound to the value of E in the memory (overwriting whatever was bound previously tp I)" I is identifier. E is expression
09:37:41 <theOtherTrueMike> and am trying to train it with a big data set
09:37:47 <cschneid> theOtherTrueMike: probably it's a lazy-thunk problem. I ran into that building a map. instead of (a => b) it was (a -> function that makes b) for every key
09:37:53 <theOtherTrueMike> ok
09:37:54 <theOtherTrueMike> well
09:38:00 <theOtherTrueMike> perhaps that is the issue
09:38:15 <theOtherTrueMike> it says stack space overflow
09:38:21 <theOtherTrueMike> so I assumed it was stack
09:38:29 <applicative_> I see theOtherTrueMike is it on github or hpaste or whatever?
09:38:33 <theOtherTrueMike> here: https://www.dropbox.com/s/azk0nj7k83qhm1z/schoolNN.hs
09:38:39 <theOtherTrueMike> this is my training app
09:39:03 <theOtherTrueMike> the profiler says that the memory leak is happening in chainOutput
09:39:16 <theOtherTrueMike> so I tried to rewrite it
09:39:22 <theOtherTrueMike> using tail recursion
09:39:26 <fizbin> bob981: What were you quoting that for?
09:39:28 <theOtherTrueMike> but perhaps that is not the real problem
09:39:58 <mauke> theOtherTrueMike: function calls don't use stack
09:40:02 <bob981> thats what the Tiny language does with ide
09:40:13 <bob981> if ur interested
09:40:19 <theOtherTrueMike> mauke: oh
09:40:37 <theOtherTrueMike> mauke: then I suppose that I have been waisting my time with that
09:40:41 <klrr> can i use the State monad to have a [(a,a)] as state and being able to fetch information from it and add information to it?
09:40:45 <bob981> ?
09:40:46 <theOtherTrueMike> *waste
09:40:54 <Wiederhorst> hello, i'm in a bit of a typing mess. Can someone tell me why GHC "Couldn't match type `Floating GLdouble' with `Foreign.C.Types.CDouble'" even though "type GLdouble = CDouble" ?
09:41:20 <mauke> Floating GLdouble? o_O
09:41:33 <applicative_> bob981: that's what happens when you actually bind, but you aren't representing Commands yet
09:41:38 <klrr> why does haskell sucks beuacase it's not possible to write stuff except if your an PhD dude
09:41:51 <applicative_> Floating isn't a type
09:41:55 <elliott> klrr: please don't troll
09:42:10 <klrr> elliott: im not
09:42:13 <applicative_> klrr: aww, I never studies CS for even one minute
09:42:18 <applicative_> studied
09:42:21 <latermuse> klrr: I can write "stuff" and im not a phd
09:42:25 <latermuse> "stuff"
09:42:29 <geekosaur> Wiederhorst, show the code that gives you that error
09:42:31 <geekosaur> @paste
09:42:31 <lambdabot> Haskell pastebin: http://hpaste.org/
09:42:43 <aristid> applicative_: but you have a PhD in mathematics, surely?
09:42:47 <Wiederhorst> ok, back in a minute
09:42:50 <bob981> i need to write the comands too. thats the next step
09:42:56 <klrr> then tell me how to have a way to a list of pairs in the background that i can retrieve and add info to?
09:43:17 <elliott> klrr: sounds like you want State [(Foo,Bar)]?
09:43:18 <mauke> klrr: why?
09:43:19 <theOtherTrueMike> so, what is the best way to track down why I am running out of stack memory?
09:43:30 <elliott> do { pairs <- get; ... put newPairs }
09:43:32 <klrr> mauke: beucase all programs need state
09:43:38 <elliott> hmm, I shouldn't feed people who try to get help by trolling.
09:43:50 <klrr> elliott: okey, how would i add and retrive info from and to that?
09:44:02 <elliott> I already told you.
09:44:10 <klrr> sorry!
09:44:21 <klrr> so
09:44:23 <mauke> klrr: no, why should I write your code for you?
09:44:36 <bob981> data Cmd = Assign Ide Exp | Output Exp | ... is my next task. is there where i write about identifier?
09:44:46 <mauke> "haskell sucks, tell me how to do X and Y" is not a good way to get help
09:45:00 <klrr> type GameState = State [(String, Info)]
09:45:01 <klrr> ?
09:45:04 <klrr> mauke: sure
09:45:08 <Iceland_jack> mauke: It can be a good way ;)
09:45:08 <klrr> write a game for me
09:45:10 <elliott> it's better than it should be :(
09:45:42 <urandom__> is there a reason why haskell has now support for optional (named) parameter? this is really a pain, i always end up having to write "helper functions"
09:46:34 <urandom__> s/now/no
09:46:38 <klrr> i will never become a fucking dick programmer due to haskell :)
09:46:44 <elliott> klrr: please stop
09:46:54 <klrr> i should kill myself good bye
09:47:03 <theOtherTrueMike> so...
09:47:11 <theOtherTrueMike> my question sort of got buried up there
09:47:26 <elliott> urandom__: it interacts badly with currying/partial application
09:47:30 <elliott> urandom__: also, you can do it with records
09:47:32 <theOtherTrueMike> is there a good way to determine why you are running out of memory?
09:47:40 <elliott> data MyParams = MyParams { ... }; default = MyParams { ... }
09:47:45 <elliott> myFunc default { param = ... }
09:47:46 <theOtherTrueMike> I have been running it with profiling
09:47:53 <Wiederhorst> geekosaur, i've copypased from several files what i think is involved, plus the error to: http://hpaste.org/86938
09:48:04 <theOtherTrueMike> +RTS -hc -p
09:48:29 <theOtherTrueMike> and run hp2ps on it so I can read it
09:49:43 <bob981> umm. thnx, something u said befor helped. seems to work now
09:50:26 <urandom__> nah elliott, using records is still way more troublesome than having optional named parameter
09:50:47 <theOtherTrueMike> the graphs seem to point to one particular function, but if I am not running out due to a stack overflow I don't quite know what is causing my program to use 160M to open a an 11M file
09:51:23 <elliott> urandom__: I think you underestimate how troublesome named parameters would be for Haskell :P
09:51:30 <fizbin> @type \x f -> x >>= (\y -> return (f y))
09:51:32 <lambdabot> Monad m => m a -> (a -> b) -> m b
09:51:34 <elliott> anyway, you can often refactor your API to not need named parameters at all.
09:51:51 <elliott> but what's awkward about a record? with the data-default package, you can make the syntax consistent for all functions taking them
09:51:59 <fizbin> Oh, that's just (flip fmap). Duh.
09:52:07 <allenj12> is there a way to make a list  of triples a specific length?
09:52:10 <elliott> foo params = ... myarg params ...; and call it as foo def or foo def { ... }
09:52:27 <fizbin> @type liftM
09:52:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
09:53:02 <geekosaur> Wiederhorst, there isn't enough there to actually build it and there's nothing that jumps out at me that would cause ghc to infer a(n incorrect) type Floating Double
09:53:22 <Adeon> theOtherTrueMike: it's possible you are building a large, unevaluated thunk because of haskell's laziness and when its value is finally demanded, stack blows up
09:53:28 <geekosaur> can you annotate that with the exact error message? (and relate its position information to what you showed us?)
09:53:38 <Wiederhorst> i could put it all on a public git
09:53:44 <urandom__> can you give an realistic example where using optional named parameter would be troublesome when haskell had them, elliott? or some link to a discussion about it
09:53:45 <Wiederhorst> one minute
09:54:32 <Adeon> theOtherTrueMike: which you may be able to fix by adding strictness annotations or seq things to strategic places
09:54:36 <elliott> urandom__: consider f as a function (name :: String) -> Int, meaning that it has a name parameter that defaults to "foo". let's also say it calculates the length of the name and returns it. so if you evaluate "f" in GHCi, you'll get 3, because it defaults to "foo"
09:54:43 <theOtherTrueMike> applicative_, should I post it on hpaste, or is dropbox good enough?
09:54:43 <elliott> urandom__: so then how do you pass the *function* f to a higher-order function?
09:54:50 <elliott> it's never obvious when f is "fully applied"
09:55:21 <elliott> languages like Coq have implicit parameters like this but they pay a complexity cost for it (and it's often awkward to work with), they're much less necessary in Haskell than they are there though
09:55:58 <theOtherTrueMike> adeon, how would I determine if that were happening?
09:56:42 <theOtherTrueMike> could ghcii report on the state of thunks?
09:57:07 <Eduard_Munteanu> elliott: I think they're a pain only for Haskell
09:57:23 <Eduard_Munteanu> And well, not very useful either.
09:57:40 <Eduard_Munteanu> They make more sense for dependent stuff.
09:57:52 <Adeon> I think the debugger may help finding the offending place but I forgot how it works
09:58:13 <Wiederhorst> geekosaur: http://bitbucket.org/DasHannes/pso.git can you clone this?
09:58:45 <theOtherTrueMike> adeon: I need to read up on strictness annotations anyway, so I will probably start there
09:59:29 <theOtherTrueMike> adeon: once I understand how to use them I will try to figure out where I am losing all my memory
09:59:36 <Adeon> if you have a tail-recursive function that uses an accumulator of some kind, you might want to make that strict
10:00:13 <theOtherTrueMike> adeon: at times I am tempted to write it all up in C#, but I want to stick it through and learn haskell for real.
10:00:36 <theOtherTrueMike> adeon: https://www.dropbox.com/s/azk0nj7k83qhm1z/schoolNN.hs
10:00:58 <theOtherTrueMike> chain output is the offender
10:01:13 <theOtherTrueMike> it just eats up memory
10:02:19 <theOtherTrueMike> adeon: though perhaps I am just writing this whole thing wrong
10:02:43 <theOtherTrueMike> adeon: I don't really understand how to mix input and output
10:04:42 <theOtherTrueMike> adeon: thanks for your help - I am going to read up on strictness.
10:04:47 <theOtherTrueMike> see all of you later
10:17:14 <schellsan> does anyone know which part of yesod uses fsnotify?
10:18:01 <c_wraith> luite would know for sure
10:18:10 <luite> yesod devel does
10:18:28 <schellsan> is that a package on hackage?
10:18:29 <c_wraith> That was my guess, but I wanted to defer to the guy who wouldn't need to guess
10:18:40 <luite> schellsan: it's in yesod or yesod-bin
10:18:47 <schellsan> right - my guess too, but search...ahh
10:18:51 <schellsan> thanks!
10:19:23 <luite> i think yesod 1.2 moves it to yesod-bin, but that's not on hackage yet
10:20:58 <oconnor0> has anyone here used hit or gitlib? and which do you recommend?
10:21:51 <mmaruseacph2> does anyone know how to make hat work with code which uses RecordWildcards?
10:22:55 <geekosaur> hat still works?
10:23:22 <mmaruseacph2> I am testing it right now :))
10:24:05 <Wiederhorst> geekosaur: were you able to clone my code?
10:24:27 <geekosaur> last I checked, hat built its own custom copy of various system libs and didn't like a lot of the newer stuff
10:25:45 <geekosaur> Wiederhorst, I had been speaking generally, I can't really drop everything and build someone's project right now
10:26:24 <mmaruseacph2> :(
10:26:26 <mmaruseacph2> too bad
10:26:30 <geekosaur> maybe someone else here can help you, but my point wasn't really that I should have a whole program suite to work with, I wanted to see more *relevant* information
10:26:40 <mmaruseacph2> it was useful for debugging for some assignment at my uni
10:26:44 <dmwit> Wiederhorst: SOP is to produce a minimal reproducing file.
10:26:53 <mmaruseacph2> I intended to give to the students some minimal debugging tips
10:27:00 <mmaruseacph2> aside from the Debug.Trace
10:27:14 <dmwit> Wiederhorst: Delete stuff until the problem changes. Then put that last bit back and delete other stuff.
10:27:57 <geekosaur> mmaruseacph2, maybe hood/ghood?
10:28:02 <Wiederhorst> i'll try that.
10:28:06 <mmaruseacph2> let me check that, geekosaur
10:28:36 <geekosaur> and explore the Debug section of hackage
10:29:04 <geekosaur> hat was like first generation, hood was second generation (and also looks a little old now), there are probably newer things around
10:31:02 <dmwit> hood looks great
10:31:29 <dmwit> also magical
10:32:37 <aCube> ghc-vis looks interesting
10:32:48 <mmaruseacph2> thanks :D
10:33:32 <tgeeky> mmaruseacph2: also, adding/deleting type signatures to both check what you mean and check what GHC says, ImplicitParamters to inspect the types of things (and/or Holes if you are using a new enough GHC)
10:33:44 <tgeeky> mmaruseacph2: and threadscope
10:38:09 <aCube> tgeeky: What is the GHC version required for TypeHoles?
10:38:57 <tgeeky> aCube: 7.8.1, ie currently pre-release
10:39:34 <aCube> 7.8 also fixes the hpc search path error?
10:40:27 <Wiederhorst> is 'Fractional GLdouble' a type? Or if not, what kind of object ist?
10:41:09 <tgeeky> @type Fractional
10:41:11 <lambdabot> Not in scope: data constructor `Fractional'
10:41:17 <parcs> Fractional GLDouble is a constraint
10:41:36 <pqmodn> @info Fractional
10:41:37 <lambdabot> Fractional
10:41:37 <aCube> Or the head of an instance definition
10:41:41 <pqmodn> lambdabot: thanks!
10:42:27 <geekosaur> pqmodn, there is no @info or :i in lambdabot
10:42:37 <geekosaur> it's edit-correcting to something useless
10:42:42 <pqmodn> darn
10:42:49 <aCube> ?info Fractional
10:42:49 <lambdabot> Fractional
10:42:52 <geekosaur> @instances Frsctional
10:42:53 <lambdabot> Couldn't find class `Frsctional'. Try @instances-importing
10:42:56 <geekosaur> bah
10:42:59 <geekosaur> @instances Fractional
10:43:00 <lambdabot> Double, Float
10:43:07 <aCube> ? is also lambdabot? :O
10:43:20 <geekosaur> yes
10:43:47 <aCube> @instances Traversable
10:43:48 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
10:44:03 <aCube> @instances-importing
10:44:04 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
10:44:12 <parcs> aCube: the head of an instance definition is a constraint ;)
10:44:12 <geekosaur> @instances-importing Data.Traversable Traversable
10:44:13 <lambdabot> ErrorT e f, Maybe, WriterT w f, []
10:45:01 <aCube> parcs: instance Fractional GLDouble where -- Is a constraint ?
10:45:16 <parcs> aCube: the instance head is a constraint
10:46:18 <mmaruseacph2> well, students are not at the level where extensions are menaingful to them
10:46:32 <mmaruseacph2> they only have three classes of 2 hours of haskell
10:46:56 <Hidenori> Does the function application have the highest precedence?
10:46:59 <mmaruseacph2> so I have to use a tool which is as less intrusive as possible
10:47:02 <tgeeky> mmaruseacph2: that's a shame. all the cool bits require extensions :o
10:47:10 <Eduard_Munteanu> mmaruseacph2: I suspect they'll mostly write simple functions at that level, so perhaps debugging isn't really an issue.
10:48:09 <Eduard_Munteanu> Hidenori: yes, except record update syntax
10:48:36 <mmaruseacph2> Eduard_Munteanu: true
10:48:45 <mmaruseacph2> they have a parser combinator library
10:48:53 <mmaruseacph2> and have to use it to parse regular expressions
10:48:59 <mmaruseacph2> nothing too hard
10:49:11 <Hidenori> Eduard_Munteanu thanks. then what about infix functions?
10:49:57 <Eduard_Munteanu> Hidenori: no, that doesn't apply to infix operators (except when you make them prefix)
10:50:17 <Eduard_Munteanu> For infix ops you define fixities anyway.
10:50:49 <Hidenori> Eduard_Munteanu: Hmm I found a table of precedence of operators and I am wondering where infix function will be located
10:51:04 <mmaruseacph2> why is there no tool to remove installed packages?
10:51:11 <mmaruseacph2> via cabal or something similar?
10:51:32 <Clint> no one will ever know
10:51:41 <Eduard_Munteanu> mmaruseacph2: you can only  ghc-pkg unregister  packages, or use distro specific package management
10:51:58 <acube> or use rm -r ~/.cabal + cabal install everythig again
10:52:06 <k00mi_> Hidenori: you can define fixity for infix functions, the default is probably the same as for operators
10:52:12 <mmaruseacph2> ghc-pkg does the entire removal?
10:52:17 <Eduard_Munteanu> Hidenori: look at fixities declarations, you get to choose
10:52:28 <geekosaur> no, just removes the entry in the package list
10:52:33 <mmaruseacph2> right now, I'm having separate cabal folders and I switch between them
10:52:42 <geekosaur> you may want cabal-dev
10:52:45 <mmaruseacph2> but maybe it's time to have a single one and use .git backup :D
10:52:58 <mmaruseacph2> I still have to learn :D
10:53:05 <geekosaur> or even hsenv
10:53:08 <Hidenori> k00mi_:Is fixity related to precedence?
10:53:21 <mmaruseacph2> also, why is there a cabal executable in user home and one in PATH?
10:53:32 <mmaruseacph2> is there a difference between running one or the other?
10:53:34 <Hidenori> Eduard_Munteanu: I can choose precedence?
10:53:37 <mmaruseacph2> should one be preffered?
10:53:53 <Eduard_Munteanu> Hidenori: yes, and associativity (if it applies)
10:54:24 <Eduard_Munteanu> mmaruseacph2: if you've updated cabal as the user, then you want to use that updated cabal (from ~/.cabal/bin)
10:54:49 <Hidenori> Eduard_Munteanu: Sounds too advanced to me lol
10:55:10 <mmaruseacph2> ah, so it's better not to update it and always run the root one :-/
10:55:31 <geekosaur> what?
10:55:41 <Clint> ask your system administrator
10:56:13 <k00mi_> Hidenori: http://www.haskell.org/haskellwiki/Keywords#infix.2C_infixl.2C_infixr
10:57:53 <geekosaur> Hidenori: fixity = precedence + associativity (left, right, none)
10:58:18 <Hidenori> geeksaur: Ohh I see. Thanks
10:58:34 <Hidenori> K00mi_ thanks for the link. Im reading that now :)
10:58:43 <geekosaur> associativity is like how most things group x + y + z = (x + y) + z, but exponentiation is right associative x ** y ** z = x ** (y ** z)
10:59:34 <geekosaur> and a few things are non-associative so you need to specify parentheses to say which you want
10:59:40 <stepkut> I have a ordered list of key/value pairs, where the order is based on what the user wants the order to be, not any sort of Ord constraint. I want to be able to efficiently retrieve a particular key/value pair, and find what keys come immediately before and after the requested key. Not really sure what type to use for this
11:01:35 <parcs> Data.Map with the key being a data type with a custom ord instance
11:02:16 <stepkut> i don't see that working out
11:02:31 <stepkut> the ordering is arbitrary and can change at runtime
11:02:44 <stepkut> also, I don't see how to easily get before and after
11:04:04 <parcs> Data.Map has indexing operations that let you get the pair before and after a key
11:06:35 <dolio> parcs: How's he going to define an ord instance based on, 'the user gave me a list in this order,' though? :)
11:06:36 <stepkut> hmm
11:07:12 <elliott> you can do that with reflection!
11:07:18 <dolio> Nooo!
11:07:26 <elliott> yessss!!!!!! embrace the power!!
11:07:29 * geekosaur can imagine doing that... in IO
11:08:08 <stepkut> I could store the sort order in the type and use that for the Ord instance, but that seems like it would make for a really expensive compare operation
11:08:32 <stepkut> unless I use something smarter than List/Sequence
11:08:35 <dolio> Do you have to be able to modify the order?
11:08:39 <stepkut> yes
11:08:43 <dolio> Oh.
11:08:50 <dolio> How often?
11:08:54 <stepkut> not too often
11:09:07 <stepkut> reading is far, far more common that updating
11:09:11 <dolio> Well, you could preprocess into a more efficient representation, then.
11:09:14 <elliott> stepkut: reflection basically lets you store the sort order in the type efficiently.
11:09:20 <elliott> fwiw.
11:09:30 <stepkut> elliott: I don't know what that means :)
11:10:31 <elliott> stepkut: well, newtype MyWrapper usersList a = MyWrapper a; instance Reifies usersList [a] => Ord (MyWrapper usersList a) where compare (MyWrapper a) (MyWrapper b) = ... where usersList :: [a]; usersList = reflect (Proxy :: Proxy usersList).
11:10:36 <stepkut> I could do something like this,
11:10:38 <stepkut> data Elements = Elements { elementOrder :: Seq ElementId, elementMap :: Elements ElementId (ElementId, ElementId, StoryElement)
11:10:46 <elliott> then you can use reify to stuff a list in.
11:10:48 <stepkut> where elementOrder is the order, and when it is changed, I rebuild the Map
11:10:50 <elliott> it might not work for your use-case though.
11:11:00 <elliott> (you can read "Reifies usersList [a]" as "usersList is a type-level [a]")
11:12:20 <stepkut> so, I want to have a story with a bunch of chapters. Each chapter will be displayed as a single web page, and the pages need to have forward and backward links. And I don't want the link to a specific chapter to change if new chapters are added before or after a chapter later on.
11:12:50 <stepkut> so, I think I need to assign a permanant id to each chapter, and be able to retrieve that quickly, but I also need to be able to figure out what chapter comes before and after it (if any)
11:13:28 <stepkut> but, adding new chapters is very infrequent compared to people reading the story ... hopefully ;)
11:14:17 <stepkut> so.. I guess I can store the chapter order list in something like a Seq, but cache the lookup process in a Map
11:45:50 <jfischoff> is there a reference on the steps for adding lambda bot another irc room?
11:46:29 <tswett> I would expect those steps to be "ask lambdabot's owner to do that".
11:46:45 <tswett> Who is that, again? Cale?
11:46:51 <ijp> or run your own
11:47:03 <jfischoff> yes I want to run it on my own
11:47:09 <tswett> Ah.
11:48:09 <tswett> Well, there's this: http://www.haskell.org/haskellwiki/Lambdabot#Installing That tells you how to install it, but not how to configure it or run it.
11:49:11 <tswett> Anyway, I'm wondering if there's a hash function on strings that has the property that hash(a ++ b) can easily be calculated from hash(a) and hash(b).
11:49:28 <Philonous> sproingie:  You should make your own #haskell-blah, with blackjack and Books ;)
11:49:46 <sproingie> and hookers, and ...
11:49:48 <mauke> possibly related: rolling hashes
11:49:57 <tswett> Where a "hash function" is just any function that is usually injective, so to speak.
11:50:07 <johnw> tswett: you want a hashing monoid
11:50:47 <tswett> I do have one idea: associate each character with a matrix; hash a string by multiplying the matrices.
11:50:54 <johnw> that's been mentioned before: http://www.haskell.org/pipermail/haskell-cafe/2011-February/089588.html
11:50:58 <johnw> but no solution that I can find
11:50:59 <Feuerbach> tswett: I believe the term is "homomorphic hashing". You can try to google it.
11:51:03 <ijp> tswett: looks like you tweak online.rc in the source
11:51:21 <tswett> It's definitely a monoid homomorphism, yeah.
11:51:23 <Philonous> sproingie:  But seriously, someone should open an alternative -blah
11:51:25 <acube> jfischoff: There is also https://github.com/DanBurton/lambdabot-remedies
11:51:36 <johnw> http://blog.notdot.net/2012/08/Damn-Cool-Algorithms-Homomorphic-Hashing
11:51:43 <ijp> er, jfischoff sorry
11:52:04 <tswett> Ooh, fountain codes look neat. But lemme keep reading.
11:52:47 <benzrf> hi!
11:52:57 <benzrf> I've been reading about monads and I think I half understand them
11:53:04 <benzrf> but how does redefining >>= work?
11:53:07 <johnw> then you need to read about "nads"
11:53:13 <jfischoff> acute, ijp: thanks
11:53:15 <sproingie> Philonous: eh, not every conversation is to everyone's taste at all times
11:53:16 <benzrf> does haskell have multiple dispatch?
11:53:22 <johnw> benzrf: no, it does not
11:53:22 <benzrf> johnw: I'm ok thanks
11:53:24 <benzrf> ok
11:53:33 <benzrf> so... how can you redefine >>= for different types?
11:53:43 <sproingie> it's part of the Monad typeclass
11:53:49 <johnw> benzrf: however, what you'd normally do with MD, you can often achieve with higher-order functions
11:53:58 <Taneb> benzrf: read about type classes
11:54:00 <tswett> I wonder how quickly you can multiply matrices in Z/2Z.
11:54:03 <benzrf>  ok
11:54:05 <johnw> benzrf: instance Monad MyType where m >>= f = ...
11:54:14 <sproingie> haskell dispatches on the expected type of the expression, not any single arg in it
11:54:44 <benzrf> ohhh
11:54:45 <benzrf> ok
11:54:56 <benzrf> sorry, I was reading the wikipedia page and it looked like it was redefining it
11:54:59 <benzrf> one sec
11:55:00 <johnw> benzrf: if you do define your own Monad, pay attention to the laws
11:55:04 * johnw has made that mistake
11:55:11 <benzrf> INTCMSFTFGEKOWMTAMZNCVXWFCDIS
11:55:14 <benzrf> ugh what
11:55:18 <sproingie> the law is a ass
11:55:32 <benzrf> http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#The_Maybe_monad
11:55:39 <benzrf> look at the code samples, they made me confused :c
11:55:55 <benzrf> namely the one where they define >>=
11:56:06 <sproingie> the wikipedia page is not the best
11:56:22 <sproingie> go with LYAH, take a week or so to read it
11:56:30 <benzrf> I know
11:56:32 <Philonous> benzrf:  Have you familiarized yourself with higher-order functions and type classes already? You should have a solid grip on those before tackling monads
11:56:33 <benzrf> I'm partway through it
11:56:37 <benzrf> I'm impatient :P
11:56:43 <benzrf> Philonous: I already knew some stuff about HOF
11:56:48 <benzrf> typeclasses, ehhh
11:56:49 <sproingie> i hear you.  LYAH gets to be pretty slow going, but it's very rich
11:56:51 <mauke> start with Show
11:56:55 <mauke> then Eq
11:57:07 <benzrf> I'm just supplementing my lyah with some random browsing
11:57:08 <johnw> I second the LYAH recommendation, strongly
11:57:08 <benzrf> :3
11:57:20 <johnw> just diving in to defining >>= for some monad is rough going
11:57:42 <sproingie> Typeclassopedia is also an excellent thing to read alongside LYAH
11:58:19 <sproingie> if you have trouble scaling LYAH's walls of text in the later chapters, TC will give you more succinct nutshell summaries of many of the same concepts
12:02:08 <benzrf> ok, so...
12:02:13 <benzrf> when using do-notation
12:02:41 <benzrf> does <- unpack the  value on the right into the value on the left for the remainder of the block
12:02:57 <johnw> "unpack" is a poor choice, but in essence yes
12:02:59 <benzrf> ok
12:03:02 <benzrf> 'demonad'
12:03:12 <johnw> we often say "execute"
12:03:24 <johnw> x <- y executes y and binds it to x for the remainder of the block
12:03:33 <johnw> binds the resulting value
12:03:37 <Philonous> benzrf:  x <- f; e is desugared to (f >>= \x -> e), so what exactly it does depends on your choice of monad.
12:03:56 <benzrf> ok good
12:04:02 <benzrf> got it :D
12:04:12 <Philonous> johnw:  If there is a resulting value.
12:04:35 <Philonous> benzrf:  There might not be a resulting value. Or multiple. It all depends on your monad.
12:04:44 <benzrf> true
12:05:00 <ski> @undo do x <- f; e
12:05:00 <lambdabot> f >>= \ x -> e
12:05:18 <johnw> Philonous: good point!
12:05:34 <johnw> or it may cause the monad to short-circuit at that point before any "binding" is accomplished
12:05:44 <benzrf> ok, so, in do notation... the line after 'foo <- bar' always has to either be an expression or another binding?
12:05:51 <benzrf> and the first expression is the last line?
12:06:02 <johnw> x <- y in the Maybe monad, where y yields "Nothing", results in no binding to "x" ever happening; the code doesn't get to that point
12:06:02 <ski> it has to be a `do' command
12:06:15 <benzrf> wait
12:06:17 <Philonous> benzrf:  No. You can have multiple lines with only expressions.
12:06:22 <benzrf> ok wait so...
12:06:23 <benzrf> hm
12:06:32 <benzrf> what would that *do*, though?
12:06:46 <Philonous> benzrf:  e.g. (putStrLn "hello"; putStrLn "world")
12:07:00 <ski> a `do' command can be of shapes `<pat> <- <expr>', `<expr>', `let {<local decls>}'
12:07:00 <benzrf> @undo do putStrLn "hello"; putStrLn "world"
12:07:01 <lambdabot> putStrLn "hello" >> putStrLn "world"
12:07:08 <Philonous> benzrf:  That depends on you monad. Generally, it will sequence the effects while ignoring the value.
12:07:09 <benzrf> ohh, I didn't know about >> yet
12:07:10 <benzrf> right ok
12:07:32 <mauke> @src (>>)
12:07:33 <lambdabot> m >> k      = m >>= \_ -> k
12:08:08 <benzrf> ok
12:08:10 <benzrf> so
12:08:20 <benzrf> >> is like >>=, but it discards the first one
12:08:33 <benzrf> *first term
12:08:34 <benzrf> no
12:08:36 <benzrf> never min
12:08:50 <sproingie> it discards the result from the first term
12:08:55 <benzrf> right
12:08:58 <benzrf> what I was trying to say
12:09:08 <benzrf> @undo do name <- getLine; putStrLn name
12:09:08 <lambdabot> getLine >>= \ name -> putStrLn name
12:09:15 <benzrf> ok
12:09:16 <benzrf> ok
12:09:37 <ion> ok
12:09:42 <sproingie> or to go pointfree, getLine >>= putStrLn
12:09:47 <benzrf> right
12:09:58 <ski> @type putStrLn =<< getLine
12:10:00 <lambdabot> IO ()
12:10:22 <benzrf> wait
12:10:27 <benzrf> @def +
12:10:27 <lambdabot> Maybe you meant: bf do let
12:10:29 <sproingie> get used to what pointfree looks like, but feel free to clarify your own code with args if you need to
12:10:32 <benzrf> blugh
12:10:45 <benzrf> @src (=<<)
12:10:45 <lambdabot> f =<< x = x >>= f
12:10:50 <benzrf> ok
12:10:53 <benzrf> hmmmm
12:11:04 <sproingie> it's >>= flipped around, because it sometimes looks cooler
12:11:05 <benzrf> is there an easy way to do that in do-notation
12:11:19 <elliott> f =<< m = do { x <- m; f x }
12:11:41 <benzrf> ok
12:11:43 <benzrf> thank you much@!
12:11:50 <sproingie> usually you use =<< for the purpose of avoiding the do-notation
12:11:53 * dmwit snarks: do { f =<< m }
12:12:01 <elliott> > do { () }
12:12:03 <lambdabot>   ()
12:12:09 <sproingie> do { me }
12:12:34 <dmwit> > don't ()
12:12:36 <Philonous> elliott:  Wait, what?
12:12:38 <lambdabot>   mueval-core: Time limit exceeded
12:12:54 <dmwit> Philonous: The translation of do { e } is e. =)
12:12:57 <elliott> > do re mi
12:12:59 <lambdabot>   Ambiguous occurrence `re'
12:12:59 <lambdabot>  It could refer to either `L.re', defined at <loc...
12:13:05 <elliott> :(
12:13:05 <mauke> > do do do do do e
12:13:08 <lambdabot>   e
12:13:09 <mauke> @undefine
12:13:16 <dmwit> Philonous: Any monad constraints that arise arise naturally from the use of (>>=); they aren't a part of the translation itself.
12:13:18 <elliott> :t re
12:13:20 <lambdabot> Gettable f => AReview s t a b -> (t -> f t) -> b -> f b
12:13:25 <elliott> dammit, edwardk.
12:13:33 <Philonous> dmwit:  Ah, right.
12:14:02 <byorgey> Philonous: what, you're not familiar with the () monad? ;-)
12:14:13 <Philonous> dmwit:  Obviously, since with rebindable syntax you can replace (>>=) alltogether
12:14:50 <acube> > fmap (+3) ()
12:14:51 <lambdabot>   Couldn't match expected type `f0 b0' with actual type `()'
12:15:08 <dmwit> Hm. How exciting is rebindable syntax? Do you get to change what's done to the last line of each do block?
12:15:12 <abc22134> @type sequence [(1+)]
12:15:13 <Philonous> byorgey:  Well, except for the kind error...
12:15:15 <lambdabot> Num a => a -> [a]
12:15:19 <byorgey> Philonous: =)
12:15:34 <dmwit> I guess not, except by munging what (>>) and (>>=) do. But that's probably enough.
12:15:53 <dmwit> data Unit a = Unit deriving (Functor, Monad)
12:16:17 <heath> i'm reading a paper on my kindle where the author "λa . --stuff that is bound"
12:16:48 <heath> is that syntax allowble? by default can you substitute \a -> with λa . ?
12:17:00 <dmwit> Nope.
12:17:01 <byorgey> heath: no
12:17:01 <Philonous> heath:  Not in haskell, no
12:17:05 <heath> didn't think so
12:17:14 <heath> ty
12:17:26 <Philonous> heath:  Is it haskell, though? It's standard lambda calculus notation
12:17:26 <dmwit> triply no
12:17:38 <heath> yeah, he claims it's haskell
12:18:02 <acube> There is some extension to allow λx for \x (-XUnicodeSomething)
12:18:18 <mauke> acube: unlikely
12:18:29 <h4199> It is an alpha char, it would need a compiler hack to work the way you expect. The suggestion got canned a while ago
12:18:31 <geekosaur> there are some editors which will present and translate it, but it's not actually valid haskell because there is no Unicode symbol representation of a lambda (it's alpha)
12:18:54 <Philonous> acube:  -XUnicodeSyntax
12:18:59 <mauke> \x is superior to λx in every way
12:19:13 <mauke> I don't know why people want to use λ anyway
12:19:22 <johnw> pretty
12:19:23 <johnw> want
12:19:35 <mauke> \ is prettier
12:19:39 <johnw> I have Emacs show me \ as λ, so it doesn't bother me
12:19:42 <acube> There is ∀, 	⇒ too :D
12:19:50 <mauke> acube: those make sense, though
12:19:51 <h4199> Vim can as well
12:19:53 <edwardk> clearly they should just put hats on their variables like church intended
12:20:05 <edwardk> it'll be like april fools on reddit all over again
12:20:07 <dmwit> mauke: Because λ is more traditional. No other reason, really.
12:20:11 <johnw> i really don't find \ prettier, at all, so this is down to aesthetics
12:20:14 <Philonous> acube:  It doesn't contain \ though
12:20:54 <byorgey> ugh, why does λ look so ugly in this terminal font =P
12:21:01 <dolio> Also, put your type annotations in superscript.
12:21:06 <dolio> None of this colon business.
12:21:21 <dmwit> Also, we must now spend at least 30 lines debating comment syntax.
12:21:24 <dmwit> It is the Law.
12:21:25 <Philonous> Can't have \ meaning λ, all my identifiers are Greek.
12:21:46 <johnw> edwardk: after our discussion about analytics, I had a dream where I spent the night at your house.  You had really bad Internet, man.
12:22:00 <johnw> great salmon sandwiches for breakfast, though
12:22:11 <mauke> no haddock?
12:22:15 <johnw> strangely not
12:22:20 <c_wraith> Philonous: it's ok, λ is an identifier character in haskell anyway
12:23:33 <elliott> edwardk ensures his connection is bad to increase productivity
12:23:50 <dolio> I suspect he has good internet, and doesn't eat breakfast.
12:23:53 <elliott> he can only access github unthrottled
12:23:56 <shergill> johnw: how do you get emacs to convert \ to λ? something like glasses-mode?
12:24:07 <johnw> shergill: I use font-lock, actually
12:24:12 <mauke> φοραλλ
12:24:14 <johnw> see https://github.com/jwiegley/haskell-config
12:24:15 <c_wraith> though 𝛌 is not an identififier in haskell!
12:24:24 <c_wraith> ... unicode is kind of a mess
12:24:26 <elliott> Philonous: λ doesn't work, even with unicodesyntax
12:24:32 * hackagebot reflection 1.3.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.3.1 (EdwardKmett)
12:24:43 <shergill> johnw: thanks
12:24:48 <Philonous> elliott:  I know.
12:26:23 <elliott> the ideal lambda syntax is clearly (x̂. x)
12:27:11 <floyd_pinkham> (^x . x) isn't so bad, which was Church's second option after caret, according to legend
12:27:22 <sproingie> wasn't that church's original syntax before a printing mistake turned it into λ?
12:27:48 <abc22134> "^x" is caret, hat above letter is circumflex (WP says so)
12:28:25 <sproingie> the problem with λ is that it's a letter, not punctuation
12:30:21 <floyd_pinkham> the problem for haskell, you mean?
12:31:18 <sproingie> right
12:31:46 <tac_> If only we had Yet Another Arrow to use instead of lambda
12:32:06 <tac_> x => x * x + 1 or something
12:32:17 <sproingie> i guess the lexer could special case it but that would be ugly
12:32:28 <dolio> What good would that do?
12:33:08 <sproingie> you could always lex λ as a symbol then.  but that would be an ugly hack
12:33:32 <h4199> ĉâŝê vs \case hmm
12:33:37 <johnw> tac_: I think you want ↦
12:33:44 <sproingie> h4199: spikey!
12:34:04 <dolio> Anyhow, 'x -> x * x + 1' is already probably not ambiguous.
12:34:13 <dolio> But it requires arbitrary lookahead.
12:34:18 <sproingie> someone should invent a Zalgo programming language that uses nothing but combining characters for syntax
12:34:29 <tac_> johnw: yes. He will do just fine
12:34:30 <ion> Not uglier than lexing \ as something totally different from, say, \\
12:34:45 <tac_> x ↦ x :: Int -> Int
12:35:09 <johnw> that arrow is used in math for definitions, not types
12:35:18 <h4199> x ⇛  x
12:35:23 <johnw> oh, I see
12:35:25 <johnw> you're typing the definition :)
12:35:37 <tac_> johnw: yesm
12:36:15 <dmwit> > foldr f z [w,x,y]
12:36:16 <lambdabot>   f w (f x (f y z))
12:37:12 <dolio> Also 'f \x -> x' is not ambiguous, but if you got rid of the \, you'd have to write 'f (x -> x)'.
12:37:23 <dolio> Which is awful.
12:37:29 <mauke> you already do
12:37:33 <dolio> You do now.
12:37:44 <johnw> huh, i always write f $ \x -> x
12:37:45 <dolio> But in theory, you could change it.
12:37:46 <elliott> (x -> e) is nasty.
12:37:49 <elliott> because the (->) comes after the x.
12:37:55 <elliott> so it looks like a function application first.
12:37:58 <johnw> is the $ not needed there?
12:38:07 <dolio> johnw: No it is.
12:38:15 <ion> elliott: Just like (x + e) which looks like a function application first.
12:38:30 <dolio> But it would be possible to remove that restriction, I think.
12:38:49 <elliott> ion: but there, x is a value that's evaluated.
12:43:56 <temp_> I want to find a function that pulls multiple values out of a list based on their index (something like: foo :: [a] -> [Int] -> [a])
12:44:01 <temp_> where would I find that?
12:44:23 <temp_> or would I have to convert it to a sequence first?
12:45:06 <simpson> Isn't there something like `select` in Data.List?
12:45:07 <Eduard_Munteanu> :t \is -> map (flip !!) is
12:45:11 <lambdabot>     Couldn't match expected type `[b0]'
12:45:11 <lambdabot>                 with actual type `(a0 -> b1 -> c0) -> b1 -> a0 -> c0'
12:45:11 <lambdabot>     In the first argument of `(!!)', namely `flip'
12:45:11 <johnw> temp_: that would be a fold
12:45:23 <johnw> a fold would have vastly better performance than mapping !!
12:45:24 <Eduard_Munteanu> :t \is -> map (flip (!!)) is
12:45:26 <lambdabot> [Int] -> [[c] -> c]
12:45:39 <Eduard_Munteanu> Err.
12:46:02 <Eduard_Munteanu> :t \xs -> map (xs !!)
12:46:03 <lambdabot> [b] -> [Int] -> [b]
12:46:07 <johnw> is there a fold that decrements a counter as it goes?
12:46:17 <Philonous> > (\xs is -> zipWith (!!) (repeat xs) is) ['a' .. 'z'] [1,3,25]
12:46:19 <lambdabot>   "bdz"
12:46:31 <temp_> wow
12:46:33 <temp_> that was fast
12:46:45 <johnw> i written this a few times: foldr (\x (idx,xs) -> (idx+1,x:xs)) (0,[]) ys
12:46:51 <johnw> temp_: but it's slow
12:46:57 <Philonous> > map (['a' .. 'z'] !! ) [1,3,25]
12:46:57 <johnw> temp_: !! will re-scan the list each time
12:46:59 <lambdabot>   "bdz"
12:47:05 <temp_> hmm
12:47:28 <temp_> a fast solution would be nice
12:47:35 <Eduard_Munteanu> johnw: zip what you're folding
12:48:21 <temp_> would zipping it be faster?
12:48:22 <johnw> > foldr (\x (idx,zs,xs) -> if not (null zs) && idx == head zs then (idx+1,tail zs,x:xs) else (idx+1,zs,xs)) (0,[1,3,25],[]) ['a' .. 'z']
12:48:23 <lambdabot>   (26,[],"awy")
12:48:35 <johnw> that has linear performance
12:49:15 <johnw> (just shift the meaning of index to suit your taste)
12:49:28 <dolio> > foldr (\x (idx,zs,xs) -> if not (null zs) && idx == head zs then (idx+1,tail zs,x:xs) else (idx+1,zs,xs)) (0,[12,3,25],[]) ['a' .. 'z']
12:49:30 <temp_> ok, I will try to add that into what I am working on
12:49:30 <lambdabot>   (26,[3,25],"n")
12:49:43 <johnw> ah, yes, it needs for the indices to be sorted
12:49:49 <Philonous> johnw:  Seems to be wrong, though. That should be "acy", not "awy", no?
12:50:03 <johnw> Philonous: that is true, hmm
12:50:09 <temp_> oh
12:50:11 <temp_> hmm
12:50:17 <Eduard_Munteanu> Well, if you really need to (!!), you probably want to convert to an array first.
12:50:30 <dolio> > foldr (\x (idx,zs,xs) -> if not (null zs) && idx == head zs then (idx+1,tail zs,x:xs) else (idx+1,zs,xs)) (0,[1,1,3,25],[]) ['a' .. 'z']
12:50:32 <lambdabot>   (26,[1,3,25],"y")
12:50:43 <Eduard_Munteanu> :t listArray
12:50:45 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
12:50:57 <Philonous> Or not worry about it, profile first and possibly improve later
12:51:09 <Eduard_Munteanu> Or maybe you shouldn't index directly at all.
12:51:18 <temp_> the purpose of this is to extract the pertinent values out of an array containing all of the results of the nodes in a neural network
12:51:25 <johnw> Philonous: ah, it's because of the foldr
12:51:32 <johnw> > foldl (\(idx,zs,xs) x -> if not (null zs) && idx == head zs then (idx+1,tail zs,x:xs) else (idx+1,zs,xs)) (0,[1,3,25],[]) ['a' .. 'z']
12:51:34 <lambdabot>   (26,[],"zdb")
12:51:35 <Eduard_Munteanu> temp_: and what counts as pertinent?
12:51:48 <Eduard_Munteanu> Some arbitrary values, or can you describe it some other way?
12:51:50 <johnw> well, anyway, that's why it was awz
12:52:10 <temp_> the output of the nodes that are in the layer directly above the current node
12:52:39 <temp_> Eduard_Munteanu: sorry, that last comment was directed at you
12:53:04 <Eduard_Munteanu> temp_: seems to me like you might not need to index into a list, depending on how you represent the network
12:53:33 <temp_> Eduard_Munteanu: so, with 2 input nodes, 3 hidden nodes, and 2 output nodes if I am looking at the third node then 0 and 1 would be the values I want
12:54:11 <temp_> Eduard_Munteanu: If I were looking at the last node, 2,3,and 4 would be the ones I want
12:54:55 <temp_> I am representing it as a list of nodes
12:55:22 <temp_> Eduard_Munteanu: they are using different constructors if they are input nodes
12:58:51 <temp__> apparently I timed out or something
12:59:07 <temp__> Eduard_Munteanu: I am back
13:00:20 <Eduard_Munteanu> I'm trying to think if there's a better representation (perhaps tree-like) for the neural net, but I'm a bit busy.
13:00:38 <temp__> Eduard_Munteanu: that is fine
13:00:55 <temp__> Eduard_Munteanu: I am doing this for fun anyway
13:01:07 <temp__> Eduard_Munteanu: so it is not like I have a deadline
13:02:10 <temp__> Eduard_Munteanu: my problem with trying to represent it as a tree was which end to build it from (as output values propagate down and errors propagate up)
13:02:46 <temp__> Eduard_Munteanu: and i couldn't figure out how to make multiple things point to the same object in memory
13:02:58 <Eduard_Munteanu> Anyway, if you're doing indexing an array would be better.
13:03:27 <temp__> Eduard_Munteanu: When I got logged out I lost all the chat history
13:03:40 <elliott> the topic has logs
13:03:41 <temp__> Eduard_Munteanu: was there a correct array example posted?
13:03:49 <Eduard_Munteanu> No, nothing complete.
13:03:53 <Eduard_Munteanu> @hoogle listArray
13:03:54 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
13:03:54 <temp__> elliott: cool
13:03:54 <lambdabot> Data.Array listArray :: Ix i => (i, i) -> [e] -> Array i e
13:03:54 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
13:04:13 <hpaste> johnw pasted “temp_.hs” at http://hpaste.org/86943
13:04:14 <temp__> elliott: thanks
13:04:21 <Eduard_Munteanu> listArray (0, 3) [1,2,3,4] ! 2
13:04:22 <johnw> temp__: that version works, and is linear
13:04:25 <Eduard_Munteanu> > listArray (0, 3) [1,2,3,4] ! 2
13:04:25 <fizbin> temp__: The problem of making things point both directions reminds me of a problem someone else asked about here sometime last week.
13:04:27 <lambdabot>   3
13:04:28 <johnw> (for lists)
13:05:05 <temp__> johnw: thanks
13:05:37 <Eduard_Munteanu> > let ar = listArray (0, 3) [1,2,3,4] in map (ar !!) [3, 0]
13:05:40 <lambdabot>   Couldn't match expected type `[b0]'
13:05:40 <lambdabot>              with actual type `GHC.Arr....
13:05:46 <Eduard_Munteanu> > let ar = listArray (0, 3) [1,2,3,4] in map (ar !) [3, 0]
13:05:49 <fizbin> temp__: That person wanted a tree-like structure, but where each tree had a "parent" pointer. That's tough to build up efficiently in haskell bit by bit since any change would propagate to the entire structure.
13:05:49 <lambdabot>   [4,1]
13:06:34 <fizbin> temp__: However, it is possible to build it up without parent pointers and then have a separate function that tacks on all the parent pointers at the end.
13:06:39 * elliott mutters about zippers
13:06:40 <temp__> fizbin: This might even be worse than that since it is more of a web than a tree
13:07:25 <Eduard_Munteanu> elliott: unfortunately a node can have either 2 parents or 2 children in his example
13:07:55 <fizbin> temp__: Sure. It can't be any worse though than a general directed graph, and Data.Graph.Inductive is pretty nice for dealing with graphs in haskell.
13:08:07 <Eduard_Munteanu> You might be able to tie a knot though, not sure how good that is.
13:08:27 <Eduard_Munteanu> (for common parents / children)
13:08:28 <tomejaguar> Does anyone have examples of when is polymorphic seq needed?  In the obvious examples that I can think of, the type of a in a `seq` b is known statically.
13:08:29 <temp__> Eduard_Munteanu, elliott: I read about tying knots, but Didn't understand it
13:08:56 <Eduard_Munteanu> temp__: well, you can use that to build a doubly-linked list of sorts, but updates to it suck
13:09:27 <temp__> Eduard_Munteanu: updates to the structure, or to the values, or both?
13:10:00 <Eduard_Munteanu> temp__: just values, even if you leave the shape as it is
13:10:03 <temp__> Eduard_Munteanu: I plan on building a network and updating its values over 200,000 times for my initial training
13:10:12 <fizbin> temp__: Everything. Every update will require rebuilding everything.
13:10:27 <temp__> ok, well then that will not work
13:10:36 <temp__> i am already getting stack overflows
13:10:36 <Eduard_Munteanu> tomejaguar: f :: A -> B, f !x = y   ===    f x = x `seq` y
13:10:57 <fizbin> My suggestion is that you have the structure in a "pure" data structure, but make the values STRefs and then do your updates inside ST.
13:11:15 <tomejaguar> Eduard_Munteanu: Sure, but then you know statically that x :: A
13:11:22 <temp__> I figured that I might as well improve the code while I try to figure out where I am making so many thunks
13:11:33 <Eduard_Munteanu> tomejaguar: you always know the types statically :)
13:12:01 <temp__> fizbin: that makes sense
13:12:10 <temp__> fizbin: break them aparet
13:12:13 <Eduard_Munteanu> tomejaguar: polymorphism doesn't involve dynamic dispatching of any sort, except when typeclasses are involved. So I'm not sure why you think seq is special.
13:12:13 <temp__> *apart
13:13:09 <tomejaguar> Eduard_Munteanu: Hmm, that's not quite what I meant.  I'll have to think about making my question better.  Anyway, foldl' seems to be a counterexample to what I was thinking.
13:13:23 <Eduard_Munteanu> @src foldl'
13:13:23 <lambdabot> foldl' f a []     = a
13:13:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:13:35 <temp__> ok, I will look into splitting apart the network into values and structure
13:13:41 <temp__> thanks guys
13:14:38 <Eduard_Munteanu> That's going to suck a bit.
13:17:25 <fizbin> temp__: Do all your calculating on (NetThing (STRef s a)) objects. That should keep you from needing to rebuild as you train. Just have some functions then that converts a (NetThing Int) or whatever your base data type is into a (NetThing (STRef s Int)) and vice versa, and...
13:22:37 <ciaranm> does (f a, f b) -> f (a, b) have a canonical name?
13:23:26 <elliott> ciaranm: some variant on "zip" or lifting a pair.
13:23:29 <elliott> but no, not really.
13:23:34 <fizbin> :t both
13:23:36 <elliott> f a -> f b -> f (a, b) has the canonical name liftA2 (,) :)
13:23:37 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
13:23:52 <elliott> oh, I guess it's actually both id, heh
13:23:53 <elliott> :t both id
13:23:57 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
13:23:58 <elliott> :t sequenceAOf both
13:24:02 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
13:24:11 <acube> both id is not polymorphic enought :P
13:24:24 <elliott> well, true.
13:24:38 <acube> @ty uncurry $ liftA2 (,)
13:24:38 <elliott> :t bitraverse id id
13:24:41 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
13:24:42 <lambdabot>     Not in scope: `bitraverse'
13:24:42 <lambdabot>     Perhaps you meant one of these:
13:24:42 <lambdabot>       `itraverse' (imported from Control.Lens),
13:24:43 <elliott> aw.
13:25:06 <acube> @ty bimap
13:25:20 <lambdabot>     Not in scope: `bimap'
13:25:20 <lambdabot>     Perhaps you meant one of these:
13:25:20 <lambdabot>       `imap' (imported from Control.Lens),
13:25:20 <ciaranm> isn't it what an applicative "really" is, though?
13:26:13 <acube> ciaranm: Yes, that's another way to define Applicative which is afaik also described on Typeclassopedia (with your function being "combine" or something)
13:26:31 <elliott> well, it's not equivalent in the full generality of CT.
13:26:32 <elliott> just in Hask.
13:26:41 <elliott> also you need f ()
13:27:02 <ciaranm> isn't that Pointed?
13:27:08 <acube> elliott: but this function and pure works too, no?
13:27:27 <elliott> sure.
13:27:40 <elliott> but f () and f a -> f b -> f (a,b) are more consistent with each other.
13:27:46 <elliott> they don't have the "free fmap" that pure and (<*>) give you
13:28:02 <acube> pure gives free fmap?
13:28:06 <elliott> yes
13:28:14 <elliott> nil :: f (), then pure x = x <$ nil
13:28:21 <acube> A right, you need it for (<*>) to get free fmap
13:35:26 <dolio> Applicative is called "closed monoidal functor" in category theory.
13:36:24 <dolio> But I don't think they talk about it much.
13:37:09 <dolio> Because any monoidal functor is automatically a closed monoidal functor if the monoidal categories are closed.
13:44:57 <vamega2> Hi
13:45:57 <vamega2> I was wondering if someone knew what the inbuilt operator for flip (.) is
13:46:09 <elliott> (>>>)
13:46:11 <elliott> but it's not built in, really
13:46:14 <elliott> it's defined in Control.Category
13:46:16 <vamega2> last time I was here someone had mentioned that this had already been defined in Control.Category.
13:46:27 <vamega2> Ahh, thanks.
13:46:28 <elliott> @package base
13:46:28 <lambdabot> http://hackage.haskell.org/package/base
13:46:31 <elliott> has the Control.Category docs, btw
13:47:49 <vamega2> Any idea why hayoo wouldn't find that operator?
13:47:53 <vamega2> I tried a search for (a -> b) -> (b -> c) -> a -> c
13:48:20 <ciaranm> :t (>>>)
13:48:25 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
13:48:31 <ciaranm> it's defined on categories, not functions
13:51:54 <vamega2> are functions instances of categories?
13:52:53 <elliott> (->) is an instance of Category
13:53:13 <johnw> vamega2: the functions of a category form a category of their own
13:53:18 <johnw> s/functions/morphisms
13:54:09 <vamega2> johnw, any chance you could run me through that again?
13:54:14 <johnw> sure
13:54:18 <johnw> take any category C
13:54:21 <vamega2> I don't have a background in category theory.
13:54:28 <johnw> now consider the set of all morphisms in C (functions, in the case of Haskell)
13:54:38 <johnw> this set is itself a category
13:54:57 <johnw> where the binary associative operator is composition
13:55:08 <johnw> and the identity is "id"
13:55:11 <dmwit> what
13:55:21 <johnw> sorry, I'm messing this
13:55:27 <johnw> I've been thinking about monoids too much this week
13:55:32 <johnw> where the morphisms are composition
13:55:41 <dmwit> what
13:55:58 <ciaranm> i think johnw is proving that every category is a category in a natural way
13:56:12 <dmwit> I think johnw is confused.
13:56:15 <johnw> i am
13:56:18 <johnw> dmwit: help
13:56:32 <johnw> i shouldn't jump into CT discussions while actively debugging an error
13:56:38 <ciaranm> a category is just a category in the category of categories
13:56:51 <vamega2> It's going to be a while before I get into category theory.
13:57:04 <dmwit> But the original question was sort of broken to begin with.
13:57:14 <vamega2> But at somepoint I'm going to figure out what that meant.
13:57:25 <vamega2> thanks anyway, but the explanation seems to be lost on me.
13:57:32 <dmwit> To ask "is X a category?" one must first say what the objects, arrows, and composition of X look like.
13:57:34 <mauke> @remember ciaranm a category is just a category in the category of categories
13:57:35 <lambdabot> Done.
13:58:02 <johnw> dmwit: isn't a category's hom-set also a category?  the objects are now the morphisms from the original category, and the morphisms are composition?
13:58:05 <dmwit> We can certainly take a single function to be the object in a discrete category, but that's a stupid way of making a category out of a function.
13:58:49 <dmwit> johnw: A category doesn't have a hom-set. A pair of objects from a category has a hom-set.
13:59:16 <dolio> johnw: For every category, there is an arrow category, with arrows as objects and commutative squares as arrows, if that's what you mean.
13:59:18 <johnw> then did I mean to say, don't the morphisms from any category also form a category?  the objects are now the morphisms from the original category, and the morphisms are composition?
13:59:19 <Eduard_Munteanu> I guess he means Hom(A, -) and Hom(-, A)?
13:59:27 <johnw> dolio: yes, thank you!
13:59:36 <johnw> that's exactly what my poor communication skills are trying to convey
13:59:50 <johnw> Hask→
14:00:13 <dmwit> Yes, that's sensible. But it doesn't really answer the question, "Are functions instances of categories?".
14:00:18 <johnw> is the category (roughly) represented by instance Category (->)
14:00:31 <johnw> Eduard_Munteanu: indeed!
14:00:39 <dmwit> Or perhaps I misunderstood both the question and your answer. Dunno.
14:00:40 <johnw> the fact that you guys are understanding me despite myself is quite touching
14:01:25 <simpson> Wait, Hask is the category? I thought that it was the set of all types expressible in Haskell. Did I just mislearn?
14:01:49 <johnw> Hask is close to being a category
14:01:53 <johnw> the category of all types expressible in Haskell :)
14:02:07 <johnw> because of things like ⊥, it is not actually a category
14:02:21 <simpson> I can't see your Unicode but I'm guessing that you wrote _|_/
14:02:24 <johnw> yes
14:02:31 <Eduard_Munteanu> Category represents a category (actually subcategory of Hask) by reference to the arrow type.
14:02:32 <ciaranm> johnw: sure it is. it's a topological category!
14:02:35 <johnw> http://www.haskell.org/haskellwiki/Hask
14:02:38 <johnw> ciaranm: ooh, nice!
14:03:02 <johnw> ciaranm: you should note that on the wiki page
14:03:35 <ciaranm> johnw: there are slides somewhere. "What is the category for Hask", or something
14:03:44 <simpson> Oh, okay.
14:03:46 <johnw> yeah, I've read those
14:03:49 <ciaranm> johnw: also explains why free usually isn't finite
14:03:52 <Eduard_Munteanu> The objects of a Category are objects of Hask.
14:04:07 <Eduard_Munteanu> (exactly the objects of Hask)
14:04:15 <simpson> So Hask is the category, and we refer to Hask's objects, the set of all types that Haskell can express, as simply "Haskell's types" or some other informal shorthand.
14:04:38 <Eduard_Munteanu> Since e.g. Category.id :: cat a a has to work for any type in Hask.
14:08:59 <simpson> Different topic: Haskell doesn't have inheritance of types, just composition of types. I understand this. However, it is difficult to explain to people (especially those with only Java/C++ experience) that inheritance is not strictly necessary in order to solve programming problems. Has somebody already done a writeup/blog post on this somewhere?
14:11:22 <Eduard_Munteanu> simpson: s/inheritance/subtyping/ I guess, but what do you mean about composition?
14:11:53 <tromp> google type classes vs OO
14:12:10 <simpson> Eduard_Munteanu: Do you remember Java or C++ or any object-*oriented* language without true objects?
14:12:40 <simpson> tromp: I was hoping for an example in a language that people who have this problem might know and understand.
14:12:45 <Eduard_Munteanu> Both, to some extent... what do you mean without true objects? Classes not being "objects"?
14:13:11 <simpson> Well, Smalltalk, Python, Ruby, etc. where everything is an object.
14:13:15 <tromp> 4th hit is about java
14:13:40 <Eduard_Munteanu> Don't know the others as well, but I see the point.
14:13:44 <simpson> tromp: Link? (Remember, Google's results differ depending on who's searching.)
14:13:45 <EvanR> true objects
14:13:47 <EvanR> false objects
14:14:00 <Eduard_Munteanu> ⊥ and ⊤ :P
14:14:18 <tromp> http://stackoverflow.com/questions/6948166/javas-interface-and-haskells-type-class-differences-and-similarities
14:14:22 <Ralith> simpson: I have a hard time understanding how inheritance could be seen as necessary to start with
14:14:32 <tromp> more about interfaces than OO though
14:14:32 <Ralith> simpson: maybe ask them to provide examples where they think it is, then describe how to do without?
14:14:37 <simpson> Ralith: Imagine that you know no languages besides Java and C++.
14:14:52 <Ralith> imagining that my mind works differently is hard
14:14:59 <ciaranm> simpson: i tried doing that and felt very stupid and ignorant
14:15:07 <ciaranm> simpson: then i started huffing paint fumes
14:15:07 <simpson> Ralith: And yes, I was going to do that, but I was kind of hoping that somebody had exhausted all of the possibilities and already demonstrated that each of them could be refactored.
14:15:22 <Ralith> simpson: well, when you do it take notes and make a blog post ^^
14:15:31 <simpson> ciaranm: Would you believe that a large swath of the general programmer population only knows those two languages?
14:15:36 <ciaranm> simpson: no
14:15:43 <wole> @pl \xs -> head ([0..] \\ xs)
14:15:43 <lambdabot> (line 1, column 20):
14:15:43 <lambdabot> unexpected "\\"
14:15:43 <lambdabot> expecting variable, "(", operator or ")"
14:15:58 <simpson> ciaranm: Would you believe that I have coworkers that only know those two languages and get worried when I use Python because they don't know it very well?
14:15:58 <ciaranm> simpson: most of 'em know some lousy "web" language, and don't know c++
14:16:00 <wole> @pl (\xs -> head ([0..] \\ xs))
14:16:00 <lambdabot> (line 1, column 21):
14:16:00 <lambdabot> unexpected "\\"
14:16:00 <lambdabot> expecting variable, "(", operator or ")"
14:16:21 <Ralith> I think my boss at microsoft only knew C++ and C#
14:16:39 <Ralith> I was like "can I use F# for this project" and he had no idea what I was talking about
14:16:40 <simpson> Sure. And C# is just Java plus an argument. :3
14:17:02 <simpson> Anyway, thanks for the reflection. I'm guessing that I'll just get to blog some. :3
14:17:16 <wole> @pl (\xs -> head ((\\) [0..] xs))
14:17:17 <lambdabot> (line 1, column 17):
14:17:17 <lambdabot> unexpected "\\"
14:17:17 <lambdabot> expecting pattern
14:17:34 <hpc> Ralith: use F# anyway for just your part
14:17:50 <hpc> and expose a token OO interface in C# so there isn't much whining
14:18:11 <Ralith> hpc: I don't actually know F#, so I wasn't willing to bet on my ability to make it seamless.
14:18:45 <Ralith> (I didn't actually know C# at the time either, but it's just another C-like, so that wasn't a problem)
14:19:09 <EvanR> c++-like
14:19:10 <hpc> heh
14:19:22 <hpc> java-like
14:19:23 <hpc> ;)
14:19:24 * Eduard_Munteanu coins C/C++/C#
14:19:29 <EvanR> lol
14:19:32 <Eduard_Munteanu> That should annoy a lot of people.
14:19:35 * hackagebot BiobaseXNA 0.7.0.1 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.7.0.1 (ChristianHoener)
14:19:57 <hpc> i just always say (C.*|Java)
14:19:57 <ciaranm> i saw someone looking for C/C+/C++ developers once
14:20:08 <Eduard_Munteanu> Hah.
14:20:08 <johnw> let's just call it C(|\+\+|#)
14:20:20 <hpc> in addition to annoying all 4 languages, it annoys haskell programmers for senseless regexes
14:20:27 <EvanR> C+-1
14:20:31 <EvanR> covers C--
14:20:40 <simpson> None of these cover D. :3
14:20:47 <ciaranm> no-one cares
14:20:56 <hpc> EvanR: we don't need to piss off C-- programmers; there aren't any
14:20:58 <johnw> yeah, D is sadly a bit too irrelevant to even think about
14:21:00 <EvanR> looking for [A-Z]#? devs
14:23:02 <EvanR> C# == Db
14:23:13 <ciaranm> apparently musicians insist they're different
14:23:26 <EvanR> well its the same note
14:23:30 <Eduard_Munteanu> Arguably F# is the worst language by that measure.
14:23:34 <ciaranm> but a different scale, or something
14:23:51 <mietek> @hoogle (a, b) -> (b -> c) -> (a, c)
14:23:51 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
14:23:51 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
14:23:51 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
14:23:52 <Eduard_Munteanu> EvanR: only in equal temperament
14:24:01 <monoidal> http://en.wikipedia.org/wiki/Enharmonic
14:24:09 <mm_freak> D is one of the very few imperative languages that support generic generics
14:24:15 <mm_freak> the only other such language i know is C++
14:24:16 <EvanR> what does # or b mean in non equal temperment
14:24:21 <mietek> @hoogle (b -> c) -> (a, b) -> (a, c)
14:24:21 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
14:24:21 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
14:24:21 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
14:24:27 <mietek> Hrm
14:24:35 * hackagebot ViennaRNA-bindings 0.0.2.3 - ViennaRNA v2 bindings  http://hackage.haskell.org/package/ViennaRNA-bindings-0.0.2.3 (ChristianHoener)
14:24:41 <monoidal> mietek: Control.Arrow.second
14:24:43 <Eduard_Munteanu> They divide each tone in 9 steps, # gives you 5 counting up from below, flats give you 5 counting down from above
14:25:02 <mietek> monoidal: thanks, I thought there was something like it
14:26:33 <monoidal> mietek: you might be interested in http://stackoverflow.com/questions/413930/haskell-how-to-compose-not-with-a-function-of-arbitrary-arity/415154#415154
14:26:43 <ciaranm> fmap fmap fmap
14:26:44 <ciaranm> hth
14:26:56 <Eduard_Munteanu> (so C# played together with Db should give you quite a bit of beating)
14:26:59 <hpc> i prefer the total recall operator
14:27:03 <hpc> (.) (.) (.)
14:27:10 <hpc> 3 guesses why it's called that ;)
14:27:23 <ciaranm> (.).(.) it's an owl!
14:28:18 <mietek> monoidal: interesting, but a bit overkill
14:29:14 <Eduard_Munteanu> hpc: I'll pretend I totally forgot :P
14:30:09 <ciaranm> isn' tit obvious?
14:32:12 <mietek> @pl f' a_ s_ = second BS.pack (f a_ (BS.unpack s_))
14:32:12 <lambdabot> f' = (second BS.pack .) . (. BS.unpack) . f
14:32:17 <mietek> Ugh
14:32:24 <tomejaguar> Are semantic editor combinators what we now call lenses?
14:32:44 <edwardk> semantic editor combinators are more like 'setters' out of lens.
14:32:45 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
14:32:47 <edwardk> lenses are bigger
14:32:54 <ciaranm> semantic editor combinators used to be a generalisation of functors
14:32:58 <edwardk> they can do more than an SEC could but they subsume that role
14:33:27 <tomejaguar> I see.  Is that where (one of) the original ideas for lenses started?
14:33:36 <hpc> edwardk: "my library is bigger than your library" :D
14:33:49 <edwardk> with an SEC you could only modify its target(s) with a pure function. with a lens you can read, you can run monadic actions over it, etc.
14:33:53 <edwardk> very much so
14:33:57 <mietek> @pl f' a_ = second BS.pack . f a_ . BS.unpack
14:33:57 <lambdabot> f' = (second BS.pack .) . (. BS.unpack) . f
14:34:56 <edwardk> one of the first talks i gave on lens was in california at google, and conal was in the audience so i went out of my way to describe lenses by starting from semantic editor combinators and then adding some newtypes so they fit the shape of 'traverse' and working up with the laws for functors, etc. from there.
14:35:04 <edwardk> i used a similar approach in the talk i gave in new york
14:35:18 <h4199> http://www.youtube.com/watch?v=cefnmjtAolY&feature=youtu.be -- the talk in NY
14:35:33 <mietek> @pl f x -> g x . h
14:35:34 <lambdabot> (line 1, column 7):
14:35:34 <lambdabot> unexpected '>'
14:35:34 <lambdabot> expecting operator
14:35:38 <mietek> @pl f x = g x . h
14:35:39 <lambdabot> f = (. h) . g
14:35:41 <edwardk> thats what i was fishing for. thanks =)
14:35:49 <edwardk> i was trying to find the link
14:36:03 <mietek> There has to be a better way to write this.  I thought flip would help.
14:37:12 <edwardk> mietek: i tend not to use pointfree when it requires a flip or composing sections
14:37:34 <edwardk> at that point its not providing insight, just contortions ;)
14:37:55 <mietek> edwardk: me too, but I think one flip is excusable
14:38:11 <Apes> @pl f . g $ x y
14:38:12 <lambdabot> f (g (x y))
14:38:21 <Apes> @pl f $ g $ x y
14:38:21 <lambdabot> f (g (x y))
14:38:36 <Apes> What
14:38:51 <edwardk> (.) binds very tightly. $ binds very loosely
14:39:11 <edwardk> (f . g) $ (x y)
14:39:31 <Apes> @pl (f . g) $ x y
14:39:31 <lambdabot> f (g (x y))
14:39:39 <edwardk> if ($) had the opposite fixity you could actually get more interesting results with it
14:40:01 <edwardk> as it is it is just a disappointment i've learned to live with ;)
14:40:24 <oconnor0> opposite fixity?
14:40:31 <hpc> i don't think interesting things are the appropriate domain of ($)
14:40:43 <edwardk> We currently have infixr 0 $
14:40:49 <edwardk> so it winds up redundant with (.)
14:41:10 <edwardk> if it was infixl 0 $ then you could $ separate out $ arguments to a function $ with them
14:41:22 <edwardk> as it is it can only ever be used for a single argument
14:41:37 <edwardk> which leads to crap like (foo $! bar baz) $! quux quaffle
14:41:57 <edwardk> with the other fixity you could use foo $! bar baz $! quux quaffle    -- to apply two arguments strictly, etc.
14:42:32 <oconnor0> huh, interesting, thanks.
14:43:32 <edwardk> but then the usual pointfree conversion schtick of going through replacing final pairs of ()'s with $'s, and then going through replacing all but the leftmost $ with (.), and then seeing if the argument you are passing to the function is only the last arg to the $ to finish converting even that one to (.) doesn't work
14:43:44 <edwardk> er all but the rightmost $
14:44:56 <sw2wolf> I know $! uses `seq`, but seems no real difference between ($) and ($!) ?
14:45:27 <edwardk> > const () $ undefined
14:45:29 <lambdabot>   ()
14:45:31 <edwardk> > const () $! undefined
14:45:33 <lambdabot>   *Exception: Prelude.undefined
14:45:38 <Iceland_jack> sw2wolf: isn't that a real difference?
14:45:40 <Iceland_jack> :)
14:45:51 <sw2wolf> :t const
14:45:53 <lambdabot> a -> b -> a
14:46:08 <ciaranm> > const 3 4
14:46:12 <lambdabot>   3
14:46:15 <ciaranm> > return 3 4
14:46:17 <lambdabot>   3
14:46:18 <anshul> I want to understand how to write efficient haskell code from first principles. One of the things I am reading is Simon Peyton Jones's `Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine - Version 2.5`. Can anybody tell me if 1) How close is the modern implementation of GHC to the concepts presented in this paper 2) What other resources are out there to help me acheive my goal. Thanks!
14:46:33 <Iceland_jack> > const 'a' undefined
14:46:34 <lambdabot>   'a'
14:46:38 <edwardk> anshul: it is alarmingly close to the current approach
14:46:57 <anshul> @edwardk: why alarmingly?
14:46:58 <lambdabot> Unknown command, try @list
14:47:02 <sw2wolf> @src ($)
14:47:02 <lambdabot> f $ x = f x
14:47:03 <edwardk> anshul: there is a paper on dynamic pointer tagging that is also relevant which refines that with new stuff
14:47:24 <sw2wolf> @src ($!)
14:47:24 <lambdabot> f $! x = x `seq` f x
14:47:25 <edwardk> anshul: read http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/ptr-tagging.pdf for more
14:47:38 <sw2wolf> Iceland_jack: i see  now, thx
14:47:38 <hpc> anshul: it's a fairly old paper
14:47:47 <anshul> edwardk: Thanks!
14:47:59 <edwardk> actually one of the best papers on how the current approach works is a paper on how to completely redesign it. in the process he had to describe the existing system in a _ton_ of detail. that is rob ennals' thesis
14:48:01 <hpc> anshul: and it's lasted longer than average, given the typical breakneck pace of most other research that moves around haskell
14:48:34 <edwardk> anshul http://ennals.org/rob/archive/intel/pubs/thesis.pdf
14:48:49 <edwardk> anshul: reading his thesis was how i learned to think about the spineless tagless g-machine
14:49:03 <ciaranm> sounds like a rock band
14:49:28 <edwardk> anshul: but yeah hpc summarized my point of view. its old, but still surprisingly useful in its current state
14:49:28 <mm_freak> the more i work with the pipes library the more i recognize its drawbacks
14:49:29 <ciaranm> "edwardk and the spineless tagless g-machine, live at the monadery"
14:49:37 * hackagebot cblrepo 0.7.3 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.7.3 (MagnusTherning)
14:49:58 <mm_freak> for example it seems impossible to write a base64 pipe
14:50:12 <edwardk> mm_freak: time to switch to machines ;)
14:50:13 <hpc> anshul: it's the lisp of compiler abstractions ;)
14:50:28 <elliott> mm_freak: what, realli?
14:50:31 <shergill> ennals thesis is pretty comprehensive
14:50:41 <mm_freak> edwardk: any advantage over conduit? =)
14:51:04 <mm_freak> elliott: yes…  you can't recognize the end of a stream, unless the producer specifically tells you about it
14:51:18 <mm_freak> i.e. you need to produce a stream of Maybe ByteString, not ByteString
14:51:23 <edwardk> mm_freak: a non-trivial reduction in the number of parameters ;)
14:51:28 <mm_freak> or you need upstream communication
14:51:38 <mm_freak> edwardk: what do you mean?
14:52:06 <edwardk> mm_freak: my statement was intended as tongue in cheek, but machines does use far fewer types and knobs to accomplish many of the same goals
14:52:38 <mm_freak> edwardk: hmm, i'm used to 4 type arguments =)
14:52:47 <mm_freak> Wire e m a b, ContinueT e f m a, …
14:52:59 <mm_freak> and conduit's Pipe a b m r =)
14:52:59 <edwardk> it has a different focus and is more of a  work-in-progress research project to see if we can improve the state of things
14:53:12 <mm_freak> edwardk: but i'm happy to give it a shot
14:53:39 <mm_freak> edwardk: 50% of the libraries i use are yours anyway =P
14:54:01 <ocharles> don't feed the Kmett monopoly!
14:54:02 <mm_freak> you should probably repackage them as category-extras-ng =)
14:55:21 <mm_freak> btw, netwire 5 is on its way, and it might actually obsolete pipes
14:55:21 <mietek> @pl f' s_ = second BS.pack . (flip f) (BS.unpack s_)
14:55:21 <lambdabot> f' = (second BS.pack .) . flip f . BS.unpack
14:55:52 <ocharles> i should play with machines again, mealy and moore sound alien enough to me to make me want to learn them
14:56:16 <mm_freak> mealy is just Auto, isn't it?
14:56:27 <ocharles> that means nothing to me :)
14:56:32 <ocharles> so maybe!
14:56:33 <luite> hm they're pretty standard undergrad cs material
14:56:44 <zzo38> Is there Haskell program to write programs for Z-machine?
14:57:46 <edwardk> zzo38: i have a z-machine implementation or two in haskell around somewhere
14:57:47 <edwardk> i don't have one that compiles to it though
14:58:17 <carter> mm_freak whats pending in netwire that's going to be so interesting?
14:58:31 <mm_freak> carter: push/pull
14:58:52 <mm_freak> pipes demonstrated how to do it purely, so i can use it in netwire
14:59:00 <carter> mm_freak ok cool
14:59:01 <anshul> edwardk: Thanks!
14:59:08 <carter> and how will the perf / usability compare?
14:59:14 <carter> i'm relativley unfamiliar with netwire
14:59:30 <zzo38> edwardk: Yes, I have seen that already, but I means a Haskell program that can be used to compile programs for the Z-machine (not necessarily a Haskell compiler!)
14:59:59 <mm_freak> carter: it should not change…  according to mine and others' benchmarks netwire is the fastest FRP library available, but FRP is just a special case
15:00:17 <mm_freak> i'm going to turn it into a full stream processing library and then provide an FRP module
15:00:18 <carter> mm_freak cool
15:00:29 <carter> is the haddocks on hackage a good place to start
15:00:35 <carter> and where are these benchmarks?
15:00:56 <mm_freak> carter: to get started look into the Control.Wire module's haddocks…  it has a tutorial
15:01:05 <mm_freak> slightly outdated, but enough to get going
15:01:21 <edwardk> zzo38: yeah, no compiler here. i just use inform ;)
15:01:42 <mm_freak> carter: the benchmarks are in my mailbox, but just look at the Wire type…  it's just a very thin layer around regular haskell functions =)
15:01:57 <ocharles> i really need to play with netwire :(
15:02:10 <carter> mm_freak thanks
15:02:11 <ocharles> too many toys! this never happens in other programming languages!
15:02:56 <carter> mm_freak and what determins the time value?
15:03:08 <carter> (for the things i'm doing... i don't care about time, just streaming throughput)
15:03:15 <zzo38> I already wrote a macro assembler for Z-machine (in C), and I am working on a OASYS->Z-machine compiler (it actually takes OASYS binary code as input, so you still need a OASYS compiler), and intend to write another, much better, Z-machine compiler in C. However I also have the idea of something in Haskell for writing Z-machine programs.
15:03:18 <mm_freak> carter: either you pass time deltas in your application loop or you use Session
15:03:28 <carter> session?
15:03:42 <carter> ahh
15:03:44 <carter> in the docs
15:04:04 <mm_freak> carter: for example if you use constant time deltas you can perform a wire step as simple as this:  (mx, w') <- stepWire w (1/60) x
15:04:07 <zzo38> Inform has various restrictions, such as you cannot change the word separators, and so on. There are probably many other things you cannot do; as far as I know neither ZIL nor Inform allows objects to share a property table.
15:04:27 <mm_freak> carter: if you want to use real time instead, you can use clockSession + stepSession
15:04:40 <carter> mm_freak cool,
15:04:41 <mm_freak> instead of stepWire that is
15:04:44 <carter> i don't care about time :)
15:04:52 <carter> i just want to have composable streaming FAST
15:04:52 <mm_freak> you should in FRP =)
15:05:14 <carter> yeah, i don't care about reactive per se
15:05:20 <carter> i just have a stream of work chunks
15:05:30 <carter> and i want composing and passing work around to be easy and FAST
15:05:51 <carter> at least for what i'm currently up to
15:05:59 <mm_freak> you can certainly do that with netwire, but currently you may find it too general for your purpose
15:06:03 <carter> yeah
15:06:10 <carter> so machines or pipes or hand rolled stuff
15:06:12 <carter> got it
15:06:27 <mm_freak> carter: depends on your composition network
15:06:39 <carter> mm_freak oh? how so?
15:06:50 <mm_freak> carter: if you need to do things like this:  a . (b <|> c) . d
15:06:55 <mm_freak> then netwire is the way to go
15:07:16 <mm_freak> (either b or c handles the current stream instant, whichever wants to)
15:07:23 <carter> mm_freak is that composition with failur?
15:07:29 <carter> or what?
15:07:32 <mm_freak> carter: composition with signal inhibition
15:07:42 <mm_freak> inhibition is netwire's notion of an unhappened event
15:08:33 <mm_freak> for example in an FRP system you might write this to move your spaceship up:  velocity = pure (0, 1) . keyDown Space <|> pure (0, 0)
15:09:11 <carter> so that passes (0,1) if the keydown event happend
15:09:15 <carter> and (0,0)
15:09:17 <carter> othwerise?
15:09:31 <mm_freak> if keyDown Space did not inhibit, yeah
15:09:47 <carter> what happens if it inhibits?
15:09:54 <mm_freak> "ready?" . for 3 <|> "go"
15:10:03 <mm_freak> display "ready?" for three seconds, then "go"
15:10:08 <carter> ok
15:10:22 <carter> its a left biased alternative
15:10:27 <mm_freak> if all of them inhibit, the whole system inhibits, i.e. stepWire will return a Left
15:10:41 <carter> k
15:10:47 <carter> yeah
15:10:54 <carter> i don't think i need that for what i'm currently doing at allll
15:11:04 <carter> mm_freak i'm writing linear algebra codes :)
15:11:16 <zzo38> Most uses of <|> are left biased, I think; but <|> in Haskell is really a monoid so you could do it reversed too if you want to
15:11:35 <cmccann> carter: I find I am increasingly hoping that your stuff will save me from having to figure out how to make some of my stuff go faster :T
15:11:45 <hpc> zzo38: it's quite explicitly a higher-kinded monoid
15:11:45 <carter> cmccann i hope so too
15:11:49 <mm_freak> carter: then you might be better off with conduit/machines/pipes =)
15:11:52 <carter> mm_freak cool
15:11:58 <carter> figured as much once you got into details
15:12:08 <carter> mm_freak that said, super intriguing once ghcjs gets out
15:12:14 <carter> then i could write portable browser things
15:12:17 <carter> in haskell
15:12:21 <carter> and use some FRP thing for guis
15:12:31 <mm_freak> carter: i got confirmation from two sources that netwire compiles on GHCJS already =)
15:12:42 <carter> luite and who else?
15:12:51 <mm_freak> michael snoyman
15:13:12 <luite> probably because i told him ;p
15:13:26 <mm_freak> luite: no, he was the first to test this =)
15:13:48 <luite> when was this? perhaps with the old code generator
15:14:48 <cmccann> carter: right now I'm trying to figure out how to tackle a trade-off between more expensive operations in a single loop vs. really cheap operations in multiple loops over the same data
15:15:09 <zzo38> hpc: Yes, a higher-kinded monoid, is what I mean. (I made up a simpler class for a (* -> *) monoid called Plus, which does not need any other class, unlike Alternative and MonadPlus)
15:15:18 <carter> cmccann Intel manual says looping over a struct of arrays is faster than an array of structs
15:15:41 <carter> so unless you're ffing out, Unboxed is going to get better cpu prefetching than Storable
15:15:45 <mietek> @hoogle a -> (a, a)
15:15:45 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
15:15:45 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
15:15:45 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
15:16:09 <cmccann> carter: it's not that, the underlying data is the same in either case
15:16:28 <carter> cmccann how expensive is the op?
15:16:32 <carter> vs cheap?
15:16:41 <zzo38> I don't really think Haskell->JavaScript is particularly useful; I would like to have Haskell compiler into various other things though, which they don't have
15:17:08 <zzo38> Such as into Glulx, MMIX, etc
15:17:18 <carter> zzo38 thats a bold statement
15:17:18 <carter> which targets do you want that make sense/
15:17:24 <mm_freak> luite: the mail is from oct 2, 2012
15:17:54 <luite> mm_freak: oh yeah definitely old code generator then, and it wouldn't have been usable since it was horribly leaky back then
15:18:05 <cmccann> carter: it's about consolidating multiple transformations on the same data, combining calculations, and skipping unnecessary computations. the cheap version produces more garbage and does multiple traversals but the inner loop(s) would copying data and doing some simple arithmetic
15:18:31 <zzo38> carter: Glulx and MMIX and so on. I would think that to be better than compiling to JavaScripts, at least.
15:18:31 <carter> cmccann i'd have to see the code for the versions
15:18:37 <mm_freak> luite: leaking would pretty much defeat netwire
15:18:47 <mm_freak> so i guess the leaking didn't apply there
15:18:48 <carter> zzo38 but thosearen't real targets
15:18:58 <carter> zzo38 just write an llvm target for htose :P
15:19:14 <cmccann> carter: yeah and I've been changing too many other things to get a good point of comparison. plus other considerations are more important right now.
15:19:33 <luite> mm_freak: yeah the biggest leak was plugged, but the old generator has some unfixable leaks for long running programs because it has no blackholing
15:19:42 <carter> zzo38 people could stand to make serious income via building stuff using ghcjs, i doubtthe same could be said of knuth assembly
15:19:43 <cmccann> carter: but I have like no intuition for what is or is not a horrible way to do this stuff so I'm just hoping it's fast enough for now until I can do some benchmarking later
15:20:06 <carter> cmccann if you're only copying an amount of info that fits comfortable into l1, you're probably fine
15:20:10 <zzo38> carter: Yes, I wanted to have LLVM target for those, as well as LLVM targeting ARM2, and other things, but they don't want to have that! GNU target ARM2 and MMIX (not Glulx), but LLVM does not support such old version of ARM.
15:20:23 <mm_freak> luite: what did the code generator generate from?  core?  c--?  …?
15:20:23 <carter> zzo38 then write a patch
15:20:29 <luite> mm_freak: both from STG
15:20:49 <zzo38> carter: Maybe
15:20:59 <carter> zzo38 maybe which?
15:21:04 <mm_freak> luite: then it might be that GHC optimized a large number of allocations away in an earlier stage
15:21:08 <zzo38> Maybe I might write the patch.
15:21:15 <cmccann> carter: I'm currently breaking everything into 64-pixel squares and doing some pre-calculation to make every pixel's calculation independent of the others
15:21:31 <carter> 64 * 3 * 8 bytes?
15:22:13 <luite> mm_freak: well in october 2012, every thunk would be leaked, since references to its free variables would never be removed, even after it's forced
15:22:13 <carter> cmccann what sort of calc
15:22:17 <carter> you're way too vague :)
15:22:27 <cmccann> carter: 4 Floats, currently in a Storable Vector but I can change to Unboxed easily
15:22:37 <carter> cmccann unboxed WILL be faster
15:22:42 <cmccann> carter: right see a lot of the code is pretty vague right now too i.e. incomplete
15:22:56 <luite> mm_freak: after the fix in the old codegen, the references would be killed when it's fully forced
15:23:07 <luite> mm_freak: and in the new codegen, they're killed immediately when forcing starts
15:23:08 <carter> cmccann the cpu can detect the strided accesses per array better with the struct of arrays rather than array of structs
15:23:21 <carter> and memory throughput will be your bottle neck on really fast per pixel ops
15:23:26 <mm_freak> luite: what about the current code generator?  would you faithfully recommend using GHCJS for real projects?
15:24:12 <luite> mm_freak: well not yet, it's based on GHC 7.8 and everything is rather new, ghc and cabal patches still need to get accepted/merged
15:24:40 <luite> but there are no huge unfixable architectural problems anymore (that i know of at least :p )
15:24:54 <carter> luite if i start doing ghc hacking in the next month or so
15:24:57 <carter> please bother me to help out
15:25:00 --- mode: ChanServ set +o shachaf
15:25:29 --- mode: shachaf set -bbb *!*2425dabc@*.36.37.218.188 *!*2425e945@*.36.37.233.69 *!*2425da0b@*.36.37.218.11
15:25:34 --- mode: shachaf set -o shachaf
15:26:01 <mm_freak> luite: great =)
15:26:02 <luite> carter: the ghc patch itself is fairly straightforward, just adds a JavaScript platform and some stuff required by that, and a way to override GHC.Prim
15:26:07 <zzo38> I supppose you could use Haskell->JavaScript to write Haskell program to work with many programs that use JavaScript programming (webpages, XUL runner, Synchronet, etc) but in some cases probably it would be better to just write a native Haskell interface for them.
15:26:40 * carter zzo38  depends. Tradeoffs exist. having both choices is better than not. 
15:26:46 * carter hrm
15:27:01 <zzo38> carter: Well, yes, I am not suggesting *removing* the Haskell->JavaScript compiler!
15:27:03 <cmccann> carter: the calculations themselves are calculating the position of a pixel relative to a region around a line being drawn to figure out what gets drawn there, then doing some alpha blending and whatnot
15:27:15 <carter> cmccann still do it unboxed
15:27:16 <quchen> luite: Oh, GHCJS is supposed to be merged into GHC? I thought it was just a separate compiler built using GHC somehow.
15:27:23 <carter> you'll be able to use my magic shit soon :)
15:27:25 <zzo38> It is OK to write such things, of course.
15:27:26 <carter> in a month or so
15:27:27 <quchen> luite: That's pretty awesome then.
15:27:52 <luite> quchen: no, short term plan is that it's standalone, using the GHC API, but we need a few changes in GHC itself to properly support JavaScript
15:28:05 <carter> luite so does it make it possible to easily write new backends from ghc core?
15:28:07 <luite> JS has a special FFI, and a custom Platform
15:28:11 <cmccann> carter: the current scheme is also designed to let me offload some calculations to the GPU on the fly
15:28:24 <quchen> luite: I see. So for the time being it's parallel to GHC, using as much of it as it can.
15:28:31 <cmccann> carter: which I am not doing yet but I have a rough sketch of how that might work
15:28:45 <carter> cmccann lemme tell you something interesting off channel
15:28:51 <luite> quchen: yeah, so we can release updates more often than ghc
15:28:51 <cmccann> ok
15:29:20 <DigitalKiwi> secrets don't make friends
15:29:49 <carter> DigitalKiwi yes, but some things are related to professional work i'm doing
15:30:07 <applicative_> oh howdy zzo38 !
15:30:16 <DigitalKiwi> :(
15:30:27 <carter> that people will find out about in 1-3 months anyways
15:30:43 <carter> which is better that way, 'cause then everyone won't have to ask me about it before its ready to use :)
15:30:46 <luite> carter: the Platform added is JS specific, other parts make it easier to generate code for multiple architectures from the same GHC installation (GHC.Prim is target platform dependent, 32/64 bit are different, one patch lets you override that, another patch makes it easier to generate code for multiple targets by adding a custom Way (which gets you a custom .xx_o, .xx_hi extension)
15:31:07 <carter> luite sweet!
15:31:16 <carter> that'd be really handy for me later this year I think
15:31:30 <carter> Igloo thanks for adding those remarks to the ticket
15:32:10 <luite> mm_freak: I'm hoping to get a GSoC student to build a program and website with ghcjs that compiles simple gui apps using diagrams to standalone widgets (html+js files that you can include in blog posts or other pages etc)
15:32:33 <zzo38> If it is a Synchronet or XUL runner program, then Mozilla specific stuff can be used, but for webpages and other portable JavaScript programs, you probably should not use Mozilla specific stuff.
15:32:43 <luite> mm_freak: should give results similar to this: http://hdiff.luite.com/tmp/active-diagrams-mockup.png , http://hdiff.luite.com/tmp/diagrams-mockup-2.png , and link back to a simple pastebin site to play with the code
15:32:48 <carter> luite i'd be happy to do that as a break from my own stuff
15:33:08 <luite> that way we can get some testing before the september release :)
15:33:19 <zzo38> If you want to use Haskell to make HTML, you could probably just write a Haskell library to do that; it doesn't need a specific target it can be compiled for any computer and just output the HTML data.
15:33:24 <Eduard_Munteanu> How're the GSoC applications faring so far?
15:33:28 <carter> zzo38 theres more than one way to do it
15:33:34 * Eduard_Munteanu wonders if any students hang around
15:33:36 <carter> zzo38 don't impose beliefs :)
15:33:48 <carter> luite seriously i'd be happy to spend some time on it this summer
15:34:04 <mm_freak> luite: that would be awesome
15:34:19 <applicative_> I don't know anything about it, does this ghc->js business write decent javascript given 'normal' haskell?
15:34:21 <zzo38> Of course it won't be sufficient if you want to run a Haskell program on a HTML page though! In that case you would need to compile Haskell into JavaScript or Java program, too, but this would have to be separate from the HTML, I would think.
15:34:22 <luite> carter: ah cool, i hope to get teh gsoc project accepted first
15:34:31 <luite> applicative_: uh well, no
15:34:32 <luite> :p
15:34:32 <carter> luite i'm not a student any more :)
15:34:40 <carter> its just somethig that's valuable for me
15:34:43 <carter> so helping out
15:34:45 <applicative_> luite: ah.
15:34:49 <carter> would be epic valuable for me later :)
15:34:58 <luite> carter: i know, the student is notdan
15:35:01 <mm_freak> applicative_: the generated javascript would be pretty much unintelligible to humans =)
15:35:01 <carter> ahhh
15:35:03 <carter> ohhh
15:35:06 <carter> you have a student lined up
15:35:08 <carter> got it
15:35:27 <carter> cool
15:35:30 <mm_freak> applicative_: although code generated from STG tends to be much more readable than from G or even SKI
15:35:33 <luite> applicative_: it's tail call optimized, cps transformed, custom stacks for threading
15:35:50 <mm_freak> i wrote an SKI compiler once…  unsurprisingly the generated code looked like unlambda =)
15:35:51 <luite> applicative_: so unfortunately not very close to real js
15:35:54 <zzo38> Does it have a mode to enable/disable Mozilla-specific stuff and Microsoft-specific stuff of JavaScript and so on?
15:36:00 <applicative_> so, it is not klunky slow though
15:36:20 <luite> applicative_: interestingly it does get a lot more readable with the optimizer i committed earlier this week
15:36:45 <luite> which does simple dataflow analysis to make the code a lot shorter
15:37:16 <mm_freak> luite: how long did you need to port the RTS?
15:37:20 <luite> (it's the ghcjs equivalent of hoopl, unfortunately hoople turned out to be not terribly easy to use for this)
15:37:41 <carter> luite neat!
15:37:44 <mm_freak> the original port that is
15:38:03 <applicative_> so in the end you will make elm and fay and co. irrelevant?  cruel fate
15:38:23 <cmccann> mm_freak: unlambda pf. you should compile to lazy k instead.
15:38:30 <luite> mm_freak: oh the older versions were mostly done by victor nazarov and hamishmack
15:39:03 <luite> mm_freak: it's not really a port of the rts, it has its own scheduler and implementation for mvars and stuff
15:39:15 <mm_freak> cmccann: that's not really realistic, if you want to get some performance
15:39:16 <haasn> unlambda is disgusting
15:39:18 <haasn> it has side effects
15:39:19 <haasn> yuck
15:39:29 <cmccann> exactly
15:39:35 <cmccann> lazy k is pure and lazy!
15:39:37 <luite> mm_freak: the old version had a main loop that looked much like what the "making a fast curry" paper described
15:39:52 <luite> mm_freak: the new one has lots of apply functions that are specialized, and autogenerated
15:40:12 <zzo38> I have seen Elm, which I think it a subset of Haskell; this is useful because then it means not only to make a webpage but it can also be compiled with Haskell and therefore used with various other things too and is not specific to a webpage or a JavaScript or whatever.
15:40:13 <mm_freak> cmccann: with a lazy k-like approach there isn't really a sensible way to introduce arbitrary effects
15:40:14 <luite> mm_freak: similar to the native ghc, but not quite the same specializations
15:40:20 <mm_freak> luite: i see
15:40:30 <cmccann> mm_freak: effects are overrated anyway
15:40:43 <mm_freak> cmccann: not if you want to do actual programming =)
15:40:44 <luite> applicative_: ghcjs is a lot heavier though, bigger code, cps transformed everywhere
15:41:03 <cmccann> mm_freak: pf, programming.
15:41:13 <mm_freak> even GHC compiles IO code to a representation you may recognize as State RealWorld =)
15:41:17 <applicative_> but somehow practical as well, or one anticipates this?
15:41:30 <applicative_> sorry, I'm asking stupid questions never really thought about it
15:42:01 <mm_freak> applicative_: lazy k code pretty much does this:  main = interact f, where f is your lazy k program
15:42:04 <luite> Elm is interesting by itself, integrating frp fully into the language
15:42:19 <zzo38> Yes, I know Lazy K.
15:42:24 <luite> GHCJS is a more general purpose approach, support threading, io manager etc, use your favourite frp lib
15:42:29 <haasn> the problem with subsets of haskell is that I want my lens, damnit
15:42:43 <luite> yeah lens is supported of course
15:42:53 <applicative_> well you just need rank2types for that haasn
15:42:55 <haasn> yes re: elm and whatnot
15:43:01 <elliott> interact is sufficient to describe all effects
15:43:06 <elliott> just like old haskell did
15:43:10 <mm_freak> the problem with subsets of haskell is that i want my RankNTypes, ScopedTypeVariables, GADTs, TypeFamilies, …
15:43:21 <applicative_> all that io monad stuff is glorified interact
15:43:24 <elliott> you just need someone helpful on the other end
15:43:31 <haasn> applicative_: yeah but some of these ‘compiles-to-X proper subset of haskell’ languages don't even have type classes
15:43:35 <luite> applicative_: i think ghcjs is mainly useful for bigger single page js "applications"
15:43:39 <shachaf> mm_freak: Like haasn said -- lens.
15:43:52 <mm_freak> i'm not using lens that much
15:44:00 <zzo38> I don't really like the using all effect with interact, since it gets mix up with how lazy the program is, and that stuff
15:44:11 <luite> applicative_: you can get a Fay app with closure compiler down to a few lines of code if you don't use much
15:44:20 <luite> applicative_: ghcjs apps will always be thousands
15:44:26 <mithsv> luite: any plans to support asm.js?
15:44:31 <applicative_> zzo38, yeah interact is awesome that way :)
15:44:36 <luite> mithsv: no
15:44:39 <haasn> I program in lens these days, though I occasionally use Haskell with it
15:45:13 <mm_freak> i like the categorical feel to haskell programming, which lens completely removes
15:45:26 <applicative_> I suppose the closure compiler can't make much of the javascript you write?
15:45:28 <luite> mithsv: asm.js is not very useful if you do advanced things like allocating new objects
15:45:53 <luite> applicative_: oh it's pretty simple and repetitive javascript, so it works fine
15:46:04 <luite> takes a while though, because it's lots of code
15:46:34 <mm_freak> luite: btw, can you use multiple GHCJS-produced javascripts on a single page?
15:46:37 <luite> applicative_: the ghcjs optimizer uses some knowledge about the rts to do some optimizations that closure compiler can't do
15:47:09 <zzo38> Is it possible to write a Haskell library that can run Elm programs in SDL or gloss or whatever?
15:47:24 <mm_freak> zzo38: yes
15:47:44 <mm_freak> zzo38: but prepare to work on it for a few years =)
15:47:53 <luite> applicative_: for example the global variable, h$sp, the stack pointer, can be moved around more if you know that exceptions in certain places will kill the current haskell thready anyway
15:47:53 <johnw> mm_freak: how does lens remove the "categorical feel"?
15:47:55 <mm_freak> implementing a browser is highly nontrivial =)
15:48:04 <johnw> it's all about profunctors these days
15:48:15 <haasn> implement a haskell library that binds into webkit to run elm programs
15:48:27 <zzo38> mm_freak: I mean without requiring an entire web browser!
15:48:36 <haasn> I suggest using the elm compiler as back-end
15:48:49 <mm_freak> johnw: lens style feels like i'm writing OO code most of the time…  i prefer "fmap f x" over "traverse l %~ f"
15:48:53 <applicative_> why not just run them in a browse zzo38
15:48:56 <applicative_> browser
15:48:59 <zzo38> So that it can run natively, as if the Elm program is really a Haskell program importing some library.
15:49:16 <johnw> mm_freak: using lens doesn't stop you from doing that :)
15:49:42 * hackagebot process-conduit 1.0.0.1 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-1.0.0.1 (HideyukiTanaka)
15:49:43 <luite> mm_freak: currently the new generation linker generates one big out.js file with all the dependencies. and also rts.js and lib.js. multiple out.js would probably work (i'd have to check though), but much code would be loaded twice
15:49:56 <mm_freak> johnw: i didn't say i don't use lens…  but i really only use it when it actually makes my code much shorter or more readable, which pretty much boils down to when i use StateT =)
15:50:06 <zzo38> applicative_: I mean so that you can run it natively without requiring an entire web browser, and so that you can do other things with the program to allow making it do different things too, rather than what it currently does, so that you can use the same code for two things, for example.
15:50:06 <luite> mm_freak: but before release, there are going to be more linking options (because i need them for wolfgang)
15:50:09 <johnw> mm_freak: I'm in the same boat
15:50:10 <shachaf> mm_freak: over traverse f x
15:50:14 <haasn> s/over mapped/fmap/g -- hooray, declarative
15:50:17 <johnw> I don't really think I'd ever use lens everywhere
15:50:41 <zzo38> I don't really like the Lazy K I/O either; something like this might work a bit better:  http://esolangs.org/wiki/Talk:Bruijndejx
15:50:43 <luite> mm_freak: and later an incremental loading thing is going to be added, where you split a program into multiple parts, and it will load the required .js on demand when you start using some program feature that needs it
15:50:56 <mm_freak> luite: i originally moved away from haxe to ugly direct javascript precisely for this reason
15:51:22 <mm_freak> to be practical you need to make sure that you can use multiple GHCJS programs on the same page sensibly
15:51:47 <mm_freak> (haxe now supports this)
15:51:47 <luite> mm_freak: why can't you compile them as a single program?
15:52:02 <mm_freak> luite: because i might not be the one compiling the other program =)
15:52:03 <zzo38> Perhaps put the separate GHCJS programs as separate JavaScript objects.
15:52:12 <luite> mm_freak: ah right
15:52:35 <mm_freak> luite: also at least with haxe occasionally you had namespace conflicts
15:52:54 <mm_freak> when i first tried it it was difficult to combine with jQuery
15:54:18 <luite> all GHCJS symbols are prefixed with h$ to avoid clashing, not put in some object by default though, since that makes it much harder for closure compiler
15:55:07 <zzo38> luite: Well, in some things it is OK since you can load separate modules in separate namespaces, but webpages don't work like that, I think.
15:55:09 <jfischoff> it just occurred to me that sandboxing will make added default signatures and more instances to existing packages a simpler exercise
15:55:27 <jfischoff> you have to maintain them although
15:56:01 <luite> zzo38: yeah scripts included with a <script> tag get loaded in the global namespace, but you can still avoid making too many global names
15:57:24 <zzo38> luite: Yes; in some other programs that allow JavaScript modules to be loaded, you can have separate namespaces for separate programs, but not with webpages, and possibly other things also might not; this is why it might be useful to make an option to put it into an object, too
15:59:52 <luite> zzo38: hmm, i hope it will be easy to make that a link-time options (i.e. not requiring too much js code mangling)
16:01:42 <luite> but linking is the thing i'll get to when the optimizer and cabal patches are done :)
16:01:49 <mzero> Is Nick Smallbone around?
16:02:00 <mzero> (I don't know Nick's nick!)
16:02:48 <zzo38> The FFI types would probably have to be different for using with JavaScript.
16:03:13 <luite> they're the same actually, so far
16:04:32 <luite> perhaps it can be improved a bit by adding JS specific primitive types
16:04:41 <zzo38> Probably some can be the same, but some would be different, such as the JavaScript primitive string type, object type, array type, etc
16:04:51 <BigEndian> I'm sure this is a basic question, but is there a way of sequencing actions that might throw an exception such that when one fails the next action in the sequence is ran?
16:04:59 <luite> but so far, storing objects in ByteArray# works ok, and Int# ~ Number, Double# ~ Number
16:05:02 <shachaf> What is an "action"?
16:05:36 <BigEndian> Each action involves IO
16:05:50 <shachaf> OK.
16:06:09 <Ralith> you could write one
16:06:12 <shachaf> Please specify the rest of the behavior you want.
16:06:13 <BigEndian> basically I've created a simple menu type which lists some choices, the user enters a key, and a choice is matched and returned to a handler function, which does some IO action depending on the choice
16:06:18 <luite> zzo38: all GHC primops are for haskell stuff, you can do things on a JS Array, by wrapping it in a JSObj ( = JSObj ByteArray# ), and using the FFI to modify it
16:06:23 <BigEndian> I just wanted to sequence menus together
16:06:26 <luite> zzo38: all modifications would be in IO
16:06:31 <BigEndian> as some menus contain common components or handlers
16:07:07 <luite> zzo38: and there are some utilities and typeclasses to make converting stuff easier
16:07:53 <luite> zzo38: there's a fast convertion function that converts a Text to a javascript string by encoding the underlying buffer
16:08:01 <Bezdomnyj> discconect
16:08:55 <luite> zzo38: strings are immutable, so you can also write a pure API for those if you want, but Text wouldn't work, since JS strings are actually pretty horrible
16:09:13 <luite> i mean using real js strings as storage for Text
16:09:49 <zzo38> Yes, all modifications would be in IO, I would think, and JS objects can be mutable but Haskell FFI already has some stuff for conversion dealing with it
16:10:36 <zzo38> I would think to avoid the namespace problem one thing to do is, make the "main" just be compiled into something like (function(){...})(); and then any foreign exports can be given names outside of that too.
16:14:14 <zzo38> And then, for example, if you are using it in a webpage, make the Haskell program to import the module for the HTML DOM, and then load the compiled program using <script>. You can even write things in Haskell it makes it possible to make the names in the HTML to have prefixes and write the function to translate them so you can use more than one program!
16:14:18 <luite> zzo38: hm, problem is that you either have to duplicate the whole rts in that thing, so you get multiple schedulers running if you have multiple programs, or you still get some leaks outside that main function, because CAFs get registered with the RTS
16:16:03 <zzo38> luite: Then I suppose best is making it a compile-time option to specify the internal RTS or external RTS with the name that you give it.
16:17:34 <luite>  yeah we'll see what users need.
16:19:40 <zzo38> Things like Haskell ANSI colors library could then be written also to support JavaScripts when used in Synchronet, and versions of GUI libraries can be written to use HTML, and other file I/O and ordinary program I/O like standaline programs, can be written to work with standalone JavaScripts, etc.
16:20:24 <luite> ANSI color already works if you run your program in the console with node.js or spidermonkey jsshell :p
16:20:50 <zzo38> luite: Yes, I suppose so, it works if you are running it locally, but I meant as a BBS door program.
16:21:01 <luite> so you have pretty green [Ok] for your test-framework tests, be prepared to wait a bit longer though :)
16:21:14 <mm_freak> how does cabal-install invoke haddock to generate the big overall contents page?
16:21:34 <luite> zzo38: the old codegen had a demo with hterm, a javascript terminal emulator, i think it should work out of the box there
16:21:44 <zzo38> I know I would expect it to already work with node.js or jsshell or whatever. (However, note that Windows does it differently, for one example.)
16:22:25 <luite> zzo38: the new one probably lacks a bit of ffi implementation for stdin, but i think it should be doable in a few days to build a terminal program with that as well
16:23:53 <luite> (you just modify some objects in the io manager before you start your program, to write stdout to your terminal emulator instead of console.log etc)
16:24:37 <luite> the default implementation tries to detect node.js, spidermonkey or browser
16:25:42 <luite> node.js and spidermonkey can also read files with readFile
16:25:55 <luite> browser is currently unimplemented, would be doable with ajax though
16:26:03 <zzo38> I would think just writing them as separate packages with the same name would be better, than then you tell the compiler which package to use, by conditional compilation or whatever, instead of using autodetect. However, autodetect could be made the default option, I suppose.
16:27:05 <luite> zzo38: i'm not sure that's worth it, it's only a few lines somewhere in the rts
16:28:46 <zzo38> Well, I suppose *you* don't have to, if someone else who wants it can add such a feature!
16:29:06 <luite> sure, send me a pull req :p
16:31:48 <zzo38> I currently have no need to compile Haskell programs into JavaScript, but if I do have, then I can do.
16:33:33 <zzo38> Some people have made global variables in Haskell by using unsafePerformIO and then turn off inlining, but I don't like that way, so I used Data.Typeable instead.
16:33:37 <luite> there are probably a few more things that could be configurable
16:34:26 <luite> zzo38: does that give you global mutable variables?
16:36:34 <zzo38> luite: No, but you can combine it with a State monad, or whatever, in order to fake it, without needing I/O at all.
16:38:03 <zzo38> You can use a extensible product record to store the values indexed by the types, in that way.
16:40:44 <zzo38> You could use Data.Typeable also for making other kind of global distinct things.
16:40:55 <johnw> zzo38: do you have a simple example?
16:41:08 <zzo38> johnw: Well, I have this: http://hackage.haskell.org/packages/archive/extensible-data/0.1.0.4/doc/html/Data-Extensible-Product.html
16:41:35 <johnw> and a motivating example that uses it?
16:41:54 <johnw> i can't read code that abstract that has no docs and know how it's meant to be used, not yet
16:42:08 <zzo38> No, I don't have the motivating example.
16:43:03 <zzo38> I only have the explanation of something like variables from different modules added into one record.
16:43:25 <zzo38> So it can be used similarly to global variables, is one possible thing to do with such things.
16:44:50 <johnw> i'm sure it can be, just don't see how :)
16:45:12 <zzo38> Some people have complained, how can you construct such a record? Well, I have made that work, even using default values that can depend on another value.
16:45:57 <zzo38> johnw: For example,   StateT (ExtProd Globals) IO
16:46:30 <johnw> how do you then query for a global?
16:47:04 <zzo38> It might not run as efficient as the other way, but it is more mathematically elegant from what I can see.
16:47:22 <johnw> i'm all for getting rid of unsafePerformIO hacks, so I'm interested in this
16:47:35 <johnw> if code depends on context, that context should be passed in somehow
16:47:42 <johnw> not hidden at global scope behind unsafePerformIO
16:48:02 <zzo38> johnw: You can use getExtProd and putExtProd to read/write those variables, and use the state monad operations with it.
16:48:15 <ParahSail1n> @src catMaybes
16:48:16 <lambdabot> catMaybes ls = [x | Just x <- ls]
16:48:20 <zzo38> This even allows variables to be private, since the type that labels them will be private.
16:49:12 <johnw> ParahSai1in: i'm glad you asked lambdabot that
16:49:32 <johnw> i never realized that behavior of the list monad
16:50:53 <zzo38> Well, there are other ways to write catMaybes too, such as:  catMaybes = (>>= maybeToList);
16:52:25 <johnw> wait, how doe Just x <- ls work?
16:52:46 <johnw> is that builtin to list comprehensions?
16:52:54 <cmears> It's a pattern match, like in do-notation
16:52:56 <shachaf> Yes.
16:52:56 <johnw> that it only draws elements that succeed the pattern match?
16:53:02 <shachaf> @src catMaybes
16:53:02 <lambdabot> catMaybes ls = [x | Just x <- ls]
16:53:04 <johnw> cool, I never knew that feature existed
16:53:06 <shachaf> @undo catMaybes ls = [x | Just x <- ls]
16:53:06 <lambdabot> catMaybes ls = concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
16:53:09 <jfischoff> is there a standard newtype of Either that has a Monoid instance?
16:53:28 <shachaf> This feature is almost the only thing that justifies list comprehensions' existence.
16:53:35 <johnw> yeah, I can see that now
16:53:45 <johnw> I pretty much never need them, but this is useful
16:53:52 <zzo38> I don't understand why you need two syntax for that thing, both do-notation and comprehension-notation which is similar.
16:54:09 <johnw> zzo38: I tried to write what that catMaybes is doing in do-notation just now
16:54:14 <johnw> but it needs an exhuastive pattern match
16:54:47 <shachaf> In do-notation it'll work the same way as the list comprehension.
16:54:59 <shachaf> @undo catMaybe ls = do { Just x <- ls; return x }
16:54:59 <lambdabot> catMaybe ls = ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
16:55:06 <shachaf> > fail "" :: [a]
16:55:08 <lambdabot>   []
16:55:16 <zzo38> johnw: I don't think so, there is the "fail" which is used for pattern mismatch in do-notation, so if you write   do { Just x <- ls; [x]; }    then if the element is Nothing it will fail and be [] instead of continuing with the rest of the statements in the do-notation.
16:55:34 <johnw> ah, I was writing it wrong
16:55:36 <cmears> > (\ys -> do { Just x <- ys ; return x} ) [Nothing, Just 2, Nothing, Just 3]
16:55:37 <lambdabot>   [2,3]
16:55:44 <johnw> that is too cool
16:56:00 <johnw> shachaf: what is that a feature of?  do notation, or the list monad?
16:56:08 <shachaf> Yes.
16:56:09 <luite> johnw: monads in general, fail
16:56:11 <johnw> ahh
16:56:16 <johnw> because pattern match fails call fail
16:56:24 <johnw> and fail in list is... return []?
16:56:41 <shachaf> johnw: By examining the thing I gave to @undo carefully, you can see that it doesn't mention lists anywhere.
16:56:54 <zzo38> johnw: No, fail is [], not return []
16:56:57 <johnw> examining carefully...
16:57:00 <zzo38> mzero is also []
16:57:04 <shachaf> fail is const []
16:57:04 <chrisdotcode> hello everyone :)
16:57:34 <johnw> interesting!
16:57:35 <johnw> thanks
16:57:39 <johnw> learn something new about Haskell every day
16:58:14 <johnw> zzo38: what would a getExtProd call look like, if I had some Globals typE?
16:58:54 <haasn> and return = const for the (->) s monad, so yes, ‘fail’ for [] is ‘return []’
16:58:58 <johnw> it seems I can use lensExtProd ?? ~. value
16:59:04 <johnw> I'm just not clear what "??" should b ehere
16:59:10 <zzo38> haasn: Yes, for that reason, it does work.
17:00:15 <johnw> so that kind of list comprehension is really more akin a fold
17:00:33 <zzo38> johnw: The ?? would be a value of the type that labels that field of the record. Probably it would just be a type with a single constructor, like:   data Xyzzy = Xyzzy deriving Typeable;   and then use Xyzzy as the label.
17:01:19 <johnw> and then what does the record field look like?
17:01:31 <zzo38> To specify the type of the values of that variable, and the default values, you have to make a instance of ExtProdC.
17:01:37 <johnw> foo :: Xyzzy?
17:01:56 <johnw> installing now so I can try this out
17:02:47 <zzo38> johnw: No. If Xyzzy is a field of (ExtProd Globals) and stores a value of type Int, with the default value 42, then you write:   instance ExtProdC Globals Xyzzy where { type ExtProdF Xyzzy = Int; defaultExtProd _ _ = 42; }
17:02:59 <johnw> ahh
17:04:43 <zzo38> Of course, global variables isn't the only thing it can be used for!
17:09:03 <johnw> zzo38: is this right:
17:09:08 <johnw> constructExtProd Globals [ Xyzzy :*= "Hello"]
17:09:12 <johnw> doesn't type check
17:09:17 <johnw> (the type for Xyzzy is String)
17:09:23 <johnw> the associated type synonym, that is
17:11:51 <hpaste> johnw pasted “extdata.hs” at http://hpaste.org/86953
17:11:51 <zzo38> johnw: Yes, it should be! On the computer I am on right now, I don't have Haskell so I won't test it, but when I get home, I can. Remember that the type of the record is then (ExtProd Globals); Globals is the type which labels the entire record and may contain whatever information is needed to decide the default value.
17:11:54 <johnw> there's my example so far
17:12:32 <zzo38> The problem is the type of foo; you should have (ExtProd Globals) and not (ExtProdF Globals).
17:14:07 <johnw> hmm. very close now, but it thinks the ExtProd i'm constructing has  type String -> Globals, rather than Globals
17:14:55 <zzo38> Also, the constructor Globals takes a string. If you don't need the database URI to determine the default values of any fields which this record might have, remove that part.
17:15:07 <johnw> oh, right!
17:15:38 <johnw> cool!  it works
17:17:47 <johnw> oh, you use data-lens
17:17:48 <johnw> :(
17:18:19 <zzo38> Well, it can be changed if you want; you don't have to use data-lens. This file is pretty old and hasn't been updated.
17:18:30 <johnw> so, now my next question
17:18:38 <johnw> why not just use StateT?
17:18:44 <johnw> why introduce this extra typeable machinery?
17:19:04 <zzo38> Note that the fields that the Globals type itself should have, are whatever is needed to determine the default values of the record, *not* the values in the record itself.
17:19:09 <hpaste> johnw pasted “extdata-motivator.hs” at http://hpaste.org/86954
17:19:40 <zzo38> johnw: So that you can have separate modules which don't know each other, having private variables, without needing to do anything about it.
17:20:12 <johnw> they will just have orphaned instances for their custom accessors?
17:20:36 <zzo38> johnw: Yes, and it will still work.
17:20:43 <johnw> hmm... i see the magic now
17:20:53 <johnw> decoupled yet shared global state
17:21:07 <chance> am i correct that case ... of's args on the left hand side are patterns?
17:21:12 <johnw> normal global state would require every module to know the same type
17:21:39 <johnw> chance: case x of y -> z, there y is the pattern
17:21:39 <hpc> chance: yes, case <expr> of [<pattern> -> <expr>]
17:21:57 <chance> no wonder i was so confused where these b' were coming from.
17:22:08 <zzo38> The type which is called Globals here, still need to be known by all the modules, but the types of the fields can be private to each module.
17:22:32 <chance> it confused me because there was a where clause right above this case expression and the labels used in it, and below it in the case were the same.
17:22:38 <johnw> sure, Globals itself is just a common name
17:22:52 <johnw> but all knowledge of each accessor is local to the module that uses it
17:23:13 <johnw> i would suggest taking my example, and what we just said about decoupling, and inserting it into the haddocks for that module :)
17:23:44 <johnw> zzo38: is field lookup O(n)?
17:24:58 <zzo38> johnw: Field lookup uses HaskMap, so it is O(min(n,W)).
17:25:07 <zzo38> s/HaskMap/HashMap/
17:25:26 <hpc> MaskHap
17:25:28 <hpc> MisHap
17:25:40 <johnw> zzo38: you have a handy little bit of code here, it just needs a little bit of motivating example, but then I think everyone will see the beauty of it :)
17:25:45 <johnw> oh, and an upgrade to lens
17:25:48 <zzo38> This was written before TypeRep is Ord. Now that it is, it can be fixed, to use Map if that would be better, and to use Control.Lens instead of Data.Lens if that would be better.
17:26:22 <johnw> i think hashmap is a good enough choice
17:26:29 <johnw> but definitely Control.Lens
17:26:38 <johnw> then diving into accessors within state would be downright elegant
17:27:20 <zzo38> Yes, I think so!
17:28:00 <johnw> ok, this is pretty great then :)
17:30:17 <zzo38> I might not have time to do that when I go home, but you or others can also fix it if you want; I don't mind.
17:32:47 <BobFunk> anybody run into 'The build-tool has reset ENV. --env=std required.
17:32:55 <BobFunk> on os x mountain lion
17:33:01 <BobFunk> when trying to run ghci or ghc
17:33:16 <BobFunk> seems to be an issue related to brew
17:33:22 <johnw> zzo38: do you have the project on github?
17:33:25 <BobFunk> but can't figure out how to get past it
17:33:49 <zzo38> johnw: No, I have no repository for it, sorry.
17:34:05 <johnw> so, the code in the tarball on Hackage is the latest version?
17:34:12 <zzo38> Yes.
17:35:50 <zzo38> My request is that you either give the new package a different name (you can hide my package then if you don't use it), or do all of the following: Update the major version number. Keep it public domain. Make a note that there is the permission for you to update it. Make a note that it is still considered my package.
17:36:21 <johnw> sure, sound reasonable
17:37:04 <zzo38> If you give it a new name I don't care what you do with it, but if you give it the same name I would insist on those conditions.
17:37:57 <johnw> i might have called it extensible-records.  I wonder if the functionality can be merged with vinyl
17:38:44 <zzo38> You can do those things if you want, I suppose, if "extensible-records" is not already taken.
17:39:29 <johnw> since vinyl is also bills itself as "Extensible Records"
17:39:59 <johnw> yeah, it looks like almost the same thing
17:40:25 <zzo38> I haven't looked at vinyl so I don't know.
17:40:51 <johnw> instead of constructExtProd Globals [ Xyzzy :*= "Hello"], you'd use xyzzy =: "Hello" :: PlainRec Globals
17:41:10 <johnw> where xyzzy = Field :: "xyzzy" ::: String
17:41:47 <johnw> so I think it's label-indexed, rather than type-indexed, but I bet you are turning types into labels behind the scenes
17:42:23 <johnw> but at the very least you've helped me understand vinyl much better!
17:43:54 <johnw> hmm. although it doesn't look like you can use the type Globals without at some point declaring what it's types are, so maybe the decoupling issue isn't being solved here
17:43:57 <zzo38> Does anyone in this channel have any ideas about Haskell libraries/etc to write Z-machine programs with?
17:44:01 <zzo38> I do have some.
17:46:04 <zzo38> johnw: Yes, not entirely. But you can make up some module that does nothing other than exports a Globals type.
17:46:25 <johnw> but it would have to import every module, to know their types
17:46:36 <johnw> with your approach, that is unnecessary
17:50:01 <ryant5000> is there any way to make a default instance for an associated data type?
17:50:14 <ryant5000> or, "associated data family", i guess
17:53:05 <edwardk> ryant5000: yes
17:53:15 <edwardk> well, you can make a default value
17:53:19 <edwardk> if thats what you mean
17:53:40 <edwardk> class Foo a where type Bar a; type Bar a = (a,a)    -- will work.
17:53:42 <ryant5000> edwardk: is there special syntax for that? i get a syntax error when i write "newtype Blah a = Blah"
17:53:54 <ryant5000> edwardk: no, not a type family; a data family
17:53:56 <edwardk> oh, sorry, data type, not type
17:54:00 <edwardk> you're screwed there
17:54:05 <edwardk> each data constructor is its own thing
17:54:06 <ryant5000> i thought i might be
17:54:14 <ryant5000> yeah, that makes sense
17:54:19 <edwardk> so it doesn't make sense
17:54:34 <ryant5000> right; that's fair, i just wanted to check before refactoring a bunch of stuff
17:54:38 <edwardk> yeah
17:54:43 <ryant5000> thanks
17:55:09 <edwardk> you might be able to get away with just using a newtype wrapper around a common data type by convention but you'll need to plumb it yourself
17:56:01 <ryant5000> edwardk: makes sense
17:58:16 <johnw> everywhere I look, I seem to be finding monoids these days
17:58:34 <cmccann> edwardk: how not-fast is using Data.Reflection, out of curiosity?
17:58:35 <johnw> monads, applicative functors, categories -- all deal with monoids at different levels
17:58:48 <elliott> cmccann: reflection is approximateli 100% fast.
17:58:53 <edwardk> cmccann: Data.Reflection is effectively just a function call
17:58:54 <elliott> it's just a funcall at runtime.
17:59:06 <edwardk> cmccann: so its all but instantaneous
17:59:11 <cmccann> ok cool
17:59:13 <edwardk> cmccann: the speed is comparable to 'const'
17:59:19 <cmccann> same goes for "given"?
17:59:23 <edwardk> (as that is the implementation)
17:59:24 <edwardk> yes
17:59:59 <edwardk> its about 3 orders of magnitude faster than the version before elliott and i went insane optimizing it ;)
18:00:15 <elliott> cmccann: don't use given. :(
18:00:18 <elliott> it's evil.
18:00:23 <edwardk> given makes elliott sad
18:00:36 <elliott> that is the definition of evil.
18:00:37 <edwardk> so only use it if your goal is to make him cry
18:00:46 <cmccann> edwardk: that's a good goal.
18:00:50 <cmccann> also, why is given evil?
18:00:55 <elliott> cmccann: "You should only give a single value for each type. If multiple instances are in scope, then the behavior is implementation defined."
18:01:01 <elliott> plus it cannot be implemented w/o unsafeCoerce
18:01:04 <elliott> unlike the main reflection API
18:01:08 <edwardk> cmccann: because it can't be implemented by a slow path. it relies inherently on this approach
18:01:31 <Ghoul_> http://stackoverflow.com/questions/16310426/haskell-parsec-trouble-breaking-out-of-pattern -- I'd appreciate some help with this parsec issue if there's any parsec-practicing haskellians with some free time~
18:01:31 <edwardk> so if ghc changes its behavior about how to store dictionaries in a way where we can't do this hack, then its completely out of luck
18:01:41 <cmccann> ah
18:02:10 <edwardk> we can always revert to the slow path or the even slower path that was in the original paper for the normal Reifies trick though
18:02:26 <edwardk> well, the updated for ghc 7.0+ variant on the original paper version
18:02:34 <edwardk> reflection is fairly high maintenance ;)
18:02:39 <cmccann> ok, makes sense.
18:03:09 <cmccann> not sure if I'm going to use reflection in the end anyhow, but figured I'd see if it helped simplify some code.
18:03:29 <edwardk> i also need to make _another_ version based on a trick by Oleg to fix the Control.Exception.Lens code to work with HEAD.
18:04:05 <cmccann> I'm still not sure what's the ideal scenario for using reflection vs. using ...something that isn't reflection
18:04:12 <edwardk> lens currently relies on a hacked exception type to make quasi-legal Handlers out of folds.
18:04:31 <edwardk> but that hacked type relied on the ability to make up a Typeable instance
18:04:34 <edwardk> i can't do that any more
18:04:44 <cmccann> ah yes
18:05:00 <cmccann> hand-written Typeable is going away or something, right?
18:05:05 <edwardk> yeah
18:06:05 <edwardk> so now i need to concoct a form of reflection that can admit a Typeable instance for the phantom type argument, just for that one module in lens
18:06:12 <edwardk> oleg's trick can handle that
18:06:29 <edwardk> its basically a type level reference counter, and a linked list of reference cells
18:06:33 <edwardk> (or tree i suppose)
18:06:44 <edwardk> so the type level number is still possible to have Typeable
18:06:56 <johnw> edwardk: do you have a more basic motivating example for reify?  I can't see how the code in Monoid.hs is adding anything to what Monoid already does
18:07:04 <edwardk> so i can work around Typeable and still monkey patch the exception machinery to get it to let me do what i need
18:07:24 <cmccann> edwardk: that sounds like a terrifying depth of hackery
18:07:27 <edwardk> johnw: consider the need to make a monoid out of a function and a 'zero' you have in scope
18:07:38 <Ghoul_> I understand now why the hackage is called the /hack/age.
18:07:56 <edwardk> johnw: reifyMonoid (+) 0     or reifyMonoid (\x y -> (x + y) `mod` n) 0
18:08:01 <johnw> oh, you mean you can do it with any arbitrary function and zero, without needing a Monoid instances for the type?
18:08:04 <edwardk> johnw: where n is a _value_ in scope
18:08:14 <johnw> ok, that's cool
18:08:17 <johnw> Monoids made to order
18:08:40 <edwardk> johnw: now you could of course try to do this with just making your monoid for that kind of modular arithmetic take a function arg for its modulus
18:08:48 <lispy> get'em while their categorical!
18:08:52 <lispy> they're*
18:09:40 <edwardk> newtype Mod a = Mod { runMod :: a -> a }; instance Integral a => Num (Mod a) where Mod n + Mod m = Mod $ \modulus -> (n modulus + m modulus) `mod` modulus
18:10:00 <edwardk> but now consider what happens when you have an expression graph involving 'Mod a'
18:10:39 <edwardk> let one = Mod (const 1); two = one + one; four = two + two; eight = four + four in eight
18:10:55 <edwardk> with the function based representation you get sharing of the _functions_ not of their results.
18:11:09 <edwardk> with reify you get sharing of the answers because the compiler can distribute the dictionary for you
18:11:30 <edwardk> as that pattern gets deeper it makes a bigger and bigger asymptotic difference
18:11:35 <geisthaus> wow cabal has been being updated like crazy lately...whats new in it?
18:11:36 <edwardk> the function based version gets no sharing
18:11:45 <edwardk> make sense?
18:11:53 <johnw> no, but I'll come back to it
18:12:06 <johnw> i have an edwardk section in my notes
18:12:08 <edwardk> =P
18:12:12 <geisthaus> ha :D
18:12:13 <lispy> geisthaus: the move to github
18:12:18 <geisthaus> ahhh
18:12:40 <geisthaus> gonna need a faster computer just to keep up with the updates and compiles of it if this keeps up
18:12:46 <lispy> hehe
18:12:59 <Ralith> Enigmagic: merged in llvm-st (git subtree merges are awesome)
18:14:03 <edwardk> johnw: if you compute with newtype Mod5 = Mod5 Int; instance Num Mod5 where Mod5 a + Mod5 b = Mod5 (mod (a + b) 5)  -- you share values, so when you go to compute four = two + two; you just add the answers together and take the remainder.
18:14:56 <edwardk> johnw: with the version where you pass in the modulus you don't share values, you share the function 'two = Mod5 (\n -> runMod one n + runMod one n)
18:15:00 <edwardk> sharing that doesn't help you
18:15:09 <edwardk> you have to go into the fucntion and evaluate it at 'n
18:15:19 <johnw> I see, that does make sense
18:15:29 <edwardk> the compiler can't know you'll only ever call this function with the same n
18:15:38 <edwardk> with a typeclass though it can know that by confluence
18:15:51 <edwardk> so if it can discharge the typeclass obligation it can do so immediately
18:15:56 <edwardk> and then share the answer over and over
18:16:21 <edwardk> reflection lets you get the former Mod5 behavior despite using a dictionary made out of some arbitrary value you have in scope
18:16:26 <edwardk> it does it by using pure evil
18:16:52 <johnw> unsafeCorce?
18:16:59 <edwardk> in part
18:17:10 <edwardk> it also exploits the representation of single member dictionaries
18:17:29 <geisthaus> confluence? single memeber dictionaries?
18:18:28 <edwardk> geisthaus: there is only ever one instance of a typeclass for a given type. any other instance for that type should be equivalent. so instance resolution is confluent (in the absence of overlapping, incoherent instances)
18:18:48 <edwardk> if you give up that property you wind up in scala
18:19:05 <geisthaus> the FP analogue of singletons in OO?
18:19:11 <edwardk> then you're stuck reasoning about implicits completely operationally
18:19:40 <lispy> geisthaus: http://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)
18:19:46 <edwardk> well, its more than a singleton, because you can generate that dictionary (or an equivalent replacement) several times over the course of your program
18:20:10 <acowley> Really?
18:20:17 <edwardk> If I tell you there is an instance for Ord [Int]     then you can know that you can compare lists of integers for lexicographical ordering
18:20:20 <edwardk> acowley sure
18:20:20 <acowley> I thought there was only one dictionary for a given instance
18:20:23 <cmccann> edwardk: that reminds me, how does using reflection differ from implicit params?
18:21:27 <lispy> cmccann: the authors touch on that in the intro: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
18:21:28 <edwardk> acowley: sortList :: Ord a => [[a]] -> [[a]]; sortList = sort;    i called you with the instance for Ord for the base value type 'a', then used the instance Ord a => Ord [a]    to make a new dictionary
18:21:58 <lispy> cmccann: edward's reflection package builds and refines the approach in that paper
18:22:00 <edwardk> acowley: that isn't the same dictionary. its equivalent, and should mean the same as any other dictionary you build for that type
18:22:06 <acowley> Oops, you're of course right
18:22:39 <Ralith> Enigmagic: I'm thinking it might make the most sense to make it part of llvm-wrapper, and perhaps even make llvm-wrapper part of llvm-base
18:22:44 <Ralith> collapse things down a bit
18:22:44 <cmccann> lispy: I know, and it's more the "builds and refines" part that I'm wondering about
18:22:47 <edwardk> acowley: this is observable if you put something with unsafePerformIO in the instance and have superclasses you derive from
18:23:11 <acowley> edwardk: What kind of a monster would do something like that?
18:23:18 <edwardk> confluence just tells us you don't really care where the compiler gets that dictionary from, because it should be the same, so it gives the compiler a lot of freedom
18:23:27 <edwardk> acowley: take a look at the guts of intern ;)
18:23:38 <acowley> I'll wait till I have an empty stomach
18:23:42 <edwardk> they haven't let me have an intern since
18:23:46 <acowley> hahaha
18:25:05 <acowley> Oh that's actually not so bad
18:25:34 <edwardk> cmccann: the main thing is that reflection is expected to work as a superclass constraint and the fact that implicit params does is a horrible implementation detail
18:25:37 <acowley> We've all done less elaborate variations of that, and I wish there was a more socially acceptable way of doing it
18:26:07 <edwardk> cmccann: also the reflection story gives you a fresh type variable to use ST-like to track it through your code.
18:26:08 <cmccann> edwardk: as opposed to reflection, where the fact it works at all is a horrible implementation detail? :P
18:26:28 <edwardk> cmccann: its a horrible implementation detail that works clear back to hugs and base 2.0 =P
18:26:37 <acowley> I've never thought to want an interned IntSet
18:26:40 <edwardk> cmccann: can't say the same thing about implicit params
18:27:04 <edwardk> acowley: O(1) set comparisons are nice
18:27:28 <acowley> I'm usually building up one big IntSet for a while, then doing lookups, then throwing it away and doing it again.
18:27:52 <edwardk> yeah, the interning there actually supports that usecase
18:28:06 <edwardk> because it only ever has to recheck the path its building as you modify it
18:28:16 <edwardk> the constants kinda suck
18:28:26 <edwardk> but if you need a lot of sets it can make a big difference in memory footprint
18:28:38 <acowley> That makes sense
18:51:55 <mm_freak> reflection 1.3 fails for me
18:52:07 <mm_freak> A newtype constructor cannot have an existential context,
18:52:07 <mm_freak> but `Magic' does
18:52:29 <cmccann> that might be why 1.3.1 was uploaded a few hours later
18:53:10 <mm_freak> oh…  what a coincidence
18:53:51 <ab9rf> heh, oops
18:53:57 <cmccann> edwardk doesn't let little things like compiler errors stop him from uploading something to hackage every few minutes
18:54:01 <mm_freak> murphy's law at work…  i update exactly in the bad period =)
18:54:08 <mm_freak> hehe
18:54:12 <edwardk> mm_freak: try 1.3.1
18:55:02 <edwardk> mm_freak: 1.3 added PolyKinds to Data.Reflection on 7.6.x to the module containing the definition for 'Magic'. This caused http://hackage.haskell.org/trac/ghc/ticket/7873#comment:1
18:55:11 <monochrom> in the future, "cabal upload" will perform "cabal install" 3 times to make sure :)
18:55:14 <edwardk> mm_freak: i was able to eventually work around it with a kind restricting signature.
18:55:40 <edwardk> (with polykinds there is an existential kind in the signature)
18:56:44 <cmccann> oh boy existential kinds
18:56:44 <edwardk> It happened when i was merging things back out of analytics, and it 'worked for me', as i was on 7.4 and the code had worked where i merged it from because 'Magic' had been defined in a module without PolyKinds
18:57:00 <edwardk> but turning on PolyKinds makes it so that newtypes just stop working in lots of cases they were previously okay
18:57:29 <edwardk> yay
18:58:56 <mm_freak> i'm still struggling to solve the documentation problem with cabal-dev
18:58:57 <Eduard_Munteanu> I wonder if an infinite sort hierarchy makes sense in Haskell.
18:59:09 <cmccann> like Omega or whatever?
18:59:29 <cmccann> I think that's spelled with an actual omega but pf
18:59:38 <Eduard_Munteanu> cmccann: not sure, at least like Agda or Coq's Set. Except you wouldn't really be able to embed values in types.
18:59:54 <mm_freak> does anyone know how haddock is invoked by cabal-install to produce the overall index.html?
19:00:17 <mm_freak> or perhaps why cabal-dev skips this most important step?
19:01:01 <edwardk> Eduard_Munteanu: when i talked to stephanie weirich last she seemed to be leaning towards star-in-star for system Fc internally at least.
19:01:34 <mm_freak> well, i'll just give virthualenv a try
19:02:25 <mm_freak> so much for virthualenv…  it only works with base < 4.6
19:04:00 <Eduard_Munteanu> edwardk: hm, I haven't really looked at Fc, but it is interesting
19:04:37 <Eduard_Munteanu> edwardk: err, brainfart... I read that as F* (as in the MS stuff)
19:04:59 <Eduard_Munteanu> Possibly because of "star-in-star" :)
19:05:45 <Eduard_Munteanu> So * :: * would be sort of consistent? I guess so, it's more like Prop than Set.
19:05:50 <DigitalKiwi> thought the microsoft thing was f sharp
19:06:11 <Eduard_Munteanu> DigitalKiwi: look up F* too, it's more interesting stuff ;)
19:06:39 <Eduard_Munteanu> DigitalKiwi: http://research.microsoft.com/en-us/projects/fstar/
19:07:04 <DigitalKiwi> oh huh
19:07:28 <monochrom> soon, they will also have f-dollar and f-euro
19:08:10 <monochrom> oh! the Dijkstra monad. I read about that one.
19:09:29 <monochrom> (note: Dijkstra did not invent the Dijkstra monad. Dijkstra invented weakest preconditions. then this group of people rephrase that as a monad. that's what happened.)
19:11:05 <tgeeky> typical! The only thing you can be sure of when math/cs/physics objects/techniques are named after people, is that the name probably isn't the historically fairest one
19:12:06 <shachaf> It's monochrom's law unfair naming.
19:12:22 <tgeeky> shachaf: approved!
19:12:22 <monochrom> hahaha
19:13:07 <shachaf> s/law/law of/
19:13:25 <monochrom> historically fair names usually consist of at least 3 names, such as the Cauchy-Schwarz-SomeoneElse inequality!
19:13:39 <tgeeky> Erdos
19:13:52 <elliott> the monochrom-monochrom-monochrom law of unfair naming
19:13:58 <monochrom> haha
19:14:27 <shachaf> The monochrom-monotonom law of confusing names.
19:16:31 <Eduard_Munteanu> I guess twanvl can't complain either. (it also sounds rather cool as a name for something)
19:17:29 <cmccann> I should start naming all my bad ideas after other people.
19:18:26 <tgeeky> the george h. w. bush rm -rf express?
19:18:56 <Ralith> monochrom: where can I read about the dijkstra monad?
19:19:32 <Eduard_Munteanu> Ralith: why are you asking monochrom and not Dijkstra? :P
19:19:51 <monochrom> somewhere on that fstar page
19:20:24 <JoeyA> Speaking of which, we should name someone "Haut", and invent a new unit for temperature.  Same scale as Fahrenheit, but offset 32° so 0° is freezing point of water.
19:20:47 <JoeyA> The nice thing about the Haut scale (pronounced "hot") is that 180° is the boiling point.
19:21:47 <tgeeky> JoeyA: dismissed with prejudice!
19:22:10 <edwardk> JoeyA: so when something gets close to boiling you just turn it 180° and ...
19:22:14 <Eduard_Munteanu> Dayum, man... that burns, it's hawt.
19:22:42 <Eduard_Munteanu> Obviously math people will turn that into π, you know.
19:22:58 <edwardk> half-tau
19:23:06 <JoeyA> Right, like any respectable type of degree.
19:23:13 <Eduard_Munteanu> I guess those are the math hipster people.
19:23:28 <JoeyA> (except the kind you get at college)
19:24:03 <edwardk> yeah clearly τ is twice π because it has half as many legs, er.. wot?
19:24:35 <Eduard_Munteanu> Wasn't there a pi with three legs too?
19:24:35 <JoeyA> 2π/3 radians Haut is nice weather for swimming.
19:24:41 <edwardk> Eduard_Munteanu: i think they just wanted a second day in the year to eat pie
19:24:43 <sellout-> edwardk: Well, a three-legged version of π was originally proposed, but it’s not in Unicode, so …
19:24:57 <JoeyA> err
19:25:06 <tgeeky> Eduard_Munteanu: yes, and there's an egyptian heiroglyph that has two and three legs like pi
19:25:14 <tgeeky> both of which stand for numbers
19:25:22 <JoeyA> make that π/2
19:25:34 <Eduard_Munteanu> The circumference of the square wheel? :P
19:25:36 <tgeeky> I don't know what the pi + extra leg thing means though
19:25:52 <tgeeky> Eduard_Munteanu: no, "eye |||"
19:25:57 <tgeeky> is 2/3 I think
19:26:04 <tgeeky> eye || is 1/2 maybe?
19:26:17 <JoeyA> 2π/3 radians == 120°
19:26:44 <JoeyA> 120°H + 32 = 152°F
19:26:44 <tgeeky> Eduard_Munteanu: nope, I was wrong on both
19:26:57 <tgeeky> Eduard_Munteanu: eye three lines is (3/4), eye two lines is (2/3)
19:27:28 <tgeeky> Eduard_Munteanu: http://en.wikipedia.org/wiki/Egyptian_fraction
19:27:32 <Eduard_Munteanu> Ah.
19:29:48 <tgeeky> Eduard_Munteanu: also, I think educated people call that pointy ellipse shape "mouth" instead of eye, but I am a rebel
19:39:50 <johnw> I've seen the 3/4 one used as the icon of a game, I think
19:45:03 <MichaelA_> Hey, I'm trying to see the analogy between category-theoretical functors and Haskell functors and I think I got it, just want to check: types that are an instance of the functor type class are functors in that they produce a mapping from type a (which is a category) to type f a (which is a different category) and they produce mappings between morphisms with fmap.
19:48:23 <Clint> is it sane to export a Paths_ module?
19:54:59 <edwardk> sellout: i'd expect a three legged pi to be 3pi/2 anyways
19:55:10 <edwardk> so i don't think its any better ;)
19:55:17 <mm_freak> Clint: you shouldn't do that
19:56:02 <mm_freak> Clint: export specific values from it and ideally give them a different name
19:56:39 <mm_freak> otherwise people importing your module will end up writing:  import Clint.X hiding (version, …)
19:56:53 <Clint> mm_freak: here's my problem: i'm not exporting it and users are getting an undefined reference on the version closure used by the library
20:06:23 <moto9> hi all, I want to generate consistent data. Like QuickCheck's Arbitrary but with many constraints. Do you have any reading hints for me? Did anybody try constraint satisfaction techniques to produce consistent data?
20:09:50 * hackagebot DAV 0.4.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.4.1 (ClintAdams)
20:14:50 * hackagebot hstatistics 0.2.5 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.5 (VivianMcPhail)
20:22:00 <Flaeme> Yay it exists!
20:22:27 * Flaeme adds this to channels to connect to.
20:28:55 <Eduard_Munteanu> Flaeme: not only, but we're a large and helpful channel! :)
20:29:03 <Eduard_Munteanu> (and very very modest too!)
20:29:49 <td123> what's the function that applies a function to an item recursively, and puts each intermediate value into successive items in a list?
20:29:59 <Eduard_Munteanu> :t iterate
20:30:01 <copumpkin> hmm, scanl?
20:30:01 <lambdabot> (a -> a) -> a -> [a]
20:30:04 <copumpkin> oh
20:30:07 <td123> Eduard_Munteanu: thanks :)
20:30:08 <copumpkin> yeah, that sounds more like it
20:30:22 <Eduard_Munteanu> scanl sort of fits the bill too
20:30:54 <Eduard_Munteanu> @src iterate
20:30:55 <lambdabot> iterate f x =  x : iterate f (f x)
20:31:20 <oio> A function that receives an arbitrary set of arguments ?
20:32:00 <Eduard_Munteanu> oio: no, a function that gives you [x, f x, f (f x), ...]
20:32:05 <oio> func arg1 arg2 arg3 argn
20:33:15 <Flaeme> Eduard_Munteanu: Well, good! :) I've been using XMonad and finally decided to get more into how haskell works instead of just copying, and I find it both a refreshing break from, well, pretty much most languages, and pretty easy to understand.
20:33:44 <Eduard_Munteanu> Sure. There's #xmonad too, btw.
20:33:48 <applicative_> > id ($) ($) even 3
20:33:50 <lambdabot>   False
20:34:13 <applicative_> id can handle a lot of arguments
20:34:51 <Flaeme> I should also join #archlinux-haskell or something like that, too. I know it exists, just not the name.
20:35:02 <oio> ;(
20:36:26 <Flaeme> Even if there are only like 12 people in there. :P
20:40:44 <applicative_> 'cabal is evil' has over 100 reddit comments; a veritable tsunami in a demi-tasse
20:41:47 <Clint> cabal or Cabal?
20:42:09 <elliott> as if people who do this kind of thing know the difference
20:42:37 <Clint> so who can tell me what i should have done instead of http://hdiff.luite.com/cgit/DAV/commit?id=0.4.1 ?
20:46:09 <applicative_> hm whats wrong with it Clint ?
20:46:44 <Clint> applicative_: users were getting (.text+0xb6d): undefined reference to `DAVzm0zi4_PathszuDAV_version1_closure'
20:46:46 <applicative_> oh I found it above
20:46:57 <applicative_> yipe
20:49:04 <applicative_> I'm not sure I follow, but were you counting you package + version be a 'User Agent'
20:50:03 <Clint> applicative_: there was a static string before.. i changed it to be the version-based string and trouble ensued
20:50:04 <applicative_> counting it as a User Agent, rather
20:50:23 <Clint> yes, for now
20:50:28 <Clint> or for then
20:53:36 <applicative_> hm. occasionally you see people do this in a less sophisticated way, there's just some string called version defined someplace they wont forget to update, then they write something like that with their own 'version'
20:54:29 <Clint> so i can't force it to inline or whatever?
20:55:59 <applicative_> hah, even better http://hackage.haskell.org/packages/archive/fgl/latest/doc/html/src/Data-Graph-Inductive.html#version
20:56:41 * Clint sighs.
20:58:14 <Clint> i sense that i'm going to end up making the caller set it anyway
21:01:40 <applicative_> Clint is there some CPP trigger for this? look at lines 68ff https://github.com/jgm/pandoc/blob/master/pandoc.hs
21:02:58 <Clint> applicative_: oh, cool
21:03:46 <shachaf> Hmm, Friday is the deadline for GSoC proposals.
21:05:53 <johnw> new GSoC proposal: figure out a way to extend the deadlines
21:07:48 <lispy> johnw: is that the gsoc equivalent of wishing for more wishes?
21:09:32 <johnw> exactly
21:10:20 <lispy> the 'cabal hell' and 'cabal is evil' sort of posts are weird to me now. I no longer run into those issues. Now when I have cabal woes it's very different. I don't know what to tell those people. Obviously they are running into something frustrating but it must be available because I'm not hitting it and I probably do more haskell than they do.
21:10:40 <lispy> s/available/avoidable
21:11:17 <mm_freak> lispy: people often refer to cabal hell as the inability to update/install new packages without reinstalling world
21:11:35 <lispy> mm_freak: right. I don't bump into that anymore.
21:11:50 <Clint> applicative_: seems to define the dependency versions, but not the package version itself
21:12:22 <lispy> mm_freak: perhaps because I use cabal-dev to a fault
21:15:14 * lispy notes he should be doing his cousera homework
21:21:17 <sproingie> cabal-dev didn't help with some conflicting version problems.  i suppose virthualenv might
21:21:19 <applicative__> Clint, I see he uses Paths_ to get the version number for the library itself
21:21:38 <Clint> applicative__: well, thanks for trying
21:23:12 <applicative__> the only differences I can see are 1) he defines a special pandocVersion in one of the library modules, rather than just using version directly; and 2) only uses it in the executable.
21:24:20 <applicative__> Clint it's hard to see how defining hDavVersion somewhere and then using it in davRequest would help
21:25:04 <Clint> applicative__: i'm just going to make it the caller's problem, which it probably should have been in the first place
21:26:41 <applicative__> seems a little disappointing.
21:27:12 <mm_freak> lispy: cabal-dev introduces problems of its own
21:28:42 <mm_freak> in fact i'm about to go back to regular cabal-install again
21:28:49 <mm_freak> far less painful
21:30:29 <ryantanjunming> Usage of `par` and `pseq`, any good examples?
21:31:48 <shachaf> Yes, but you'll have to be more specific.
21:32:10 <applicative__> \query lambdabot
21:32:14 <applicative__> duhrrwa
21:33:18 <applicative__> ryantanjunming: what do you want to know about par and pseq?
21:34:23 <applicative__> > let x = 3 * 4 ; y = 3 * 5 in x `par` y `pseq` x + y
21:34:25 <ryantanjunming> applicative__: i know what par is purposed for but how does that interact with pseq..?
21:34:27 <lambdabot>   27
21:34:31 <applicative__> doesn't count as a good example....
21:35:00 <applicative__> pseq comes before the term that actually uses the expressions evaluated in parallel
21:35:32 <ryantanjunming> so x `par` y, which gets evaluated first?
21:35:45 <applicative__> > let x = 3 * 4 ; y = 3 * 5; z = [1..] !! 10 in x `par` y `par` z `pseq` x + y + z
21:35:46 <lambdabot>   38
21:35:57 <ryantanjunming> whats !!?
21:35:58 <mm_freak> remote-build-reporting: anonymous
21:36:00 <mm_freak> what's that?!
21:36:31 <applicative__> they are calculated in parallel, and then used in the thing after pseq.  This is not too scientific an account.
21:38:03 <applicative__> ryantanjunming: have you seen the ordinary `seq` of Haskell?
21:38:34 <applicative__> > let z = 3 + 4 in z `seq` z + 1
21:38:37 <lambdabot>   8
21:38:47 <applicative__> @type seq
21:38:49 <lambdabot> a -> b -> b
21:38:55 <applicative__> @type pseq
21:38:57 <lambdabot> a -> b -> b
21:39:22 <Eelis> i guess using pseq in this way is similar to using futures in other languages, except that with Haskell it's built-in whereas in a language like C++, futures are just a library component
21:40:32 <applicative__> seq requires that its first argument be evaluated -- reduced to 'weak head normal form' -- before it is used in the second arg of seq
21:41:06 <shachaf> applicative__: ?
21:41:16 <applicative__> ?
21:41:21 <shachaf> What does "it is used in the second argument of seq" have to do with it?
21:41:35 <applicative__> this account is a little, I'm trying to get ryantanjunming to ask more questions.
21:41:39 <shachaf> (And there is no "before" requirement. This is seq.)
21:41:59 <shachaf> OK.
21:42:01 <ryantanjunming> applicative__: oh sry, am in a lecture
21:42:05 <applicative__> yeah, i don't think that matters for the present pedagogical purpose, though I would like to know more
21:42:20 <mm_freak> come on guys, what is this?  my ~/.cabal/config contains this like:  remote-build-reporting: anonymous
21:42:30 <mm_freak> does that mean that cabal is sending my build reports somewhere?
21:42:42 <ryantanjunming> applicative__: whats the difference between seq and pseq
21:42:52 <applicative__> mm_freak: I get a list of your builds every morning
21:42:55 <elliott> applicative__: in (seq a b), b can be evaluated first
21:43:00 <elliott> in both report and ghc
21:43:24 <mm_freak> apparently the option isn't documented anywhere
21:43:32 <applicative__> elliott: yes, we are preparing to explain x `par` y `par` z `pseq` f x y z
21:43:48 <elliott> that was re: "though I would like to know more", perhaps I misinerpreted
21:43:55 <mm_freak> and i'm very nervous about undocumented "remote" "reporting" functionality
21:44:06 <elliott> but the difference is relevant here
21:44:18 <elliott> since in (pseq a b), a *must* be evaluated first, that's the reason to use it over seq
21:44:20 <applicative__> oh , i probably would like to know more in that sense too :) , but I was meaning more of what ryantanjunming 's problem was
21:45:24 <johnw> elliott: wait, with seq a b, a might not be evaluated first?
21:45:34 <elliott> indeed
21:45:45 <applicative__> hm, yes, the idea of a detour via seq may be pointless. I was wondering if he had seen it, then we could consider the comparison
21:45:46 <johnw> whaaa?  isn't that the meaning of seq?
21:45:53 <ryantanjunming> ive a hailstone program, does par and pseq, will be pasting it here.. just dont understand how parenthesis is used in par and pseq
21:45:55 <shachaf> That's the meaning of pseq.
21:46:01 <johnw> so what does seq mean then?
21:46:07 <shachaf> Well, not meaning. Behavior.
21:46:34 <applicative__> what it means is, flip const?
21:46:35 <shachaf> seq ⊥ _ = ⊥; seq _ a = a
21:46:56 <hpaste> natnayr pasted “hailstone” at http://hpaste.org/86960
21:47:26 <elliott> perhaps it is easier to consider ($!)
21:47:35 <elliott> f $! x must be _|_ if either f or x is
21:47:40 <elliott> but nothing is said about which is evaluated first
21:47:54 <elliott> erm
21:47:57 <elliott> f $! x must be _|_ if either f or x or (f x) is
21:47:58 <ryantanjunming> applicative__ : so yeah, here it is..
21:47:59 <elliott> but nothing is said about which is evaluated first
21:48:07 <elliott> (except that f must be evaluated before (f x), of course...)
21:48:17 <coppro> wait, what does $! do?
21:48:36 <shachaf> @src $!
21:48:36 <lambdabot> f $! x = x `seq` f x
21:48:44 <elliott> so let f = const longComputation. f $! undefined could evaluate (f undefined), hence longComputation, to whnf
21:48:50 <elliott> then evaluate undefined, and diverge
21:48:53 <elliott> no ordering guarantee
21:48:55 <shachaf> coppro: Also, elliott just gave the definition. :-)
21:49:43 <NemesisD> i see the term combinators talked about a lot in haskell documentation. in the context of haskell, is there any difference between combinators and functions
21:50:15 <sproingie> nope, it's just a connotation of how you use the function
21:50:28 <sproingie> i.e. you expect to combine them.  so typically it's a higher order function
21:50:34 <applicative__> ryantanjunming: the use seems legitimate.  the precedence of both is like that of $
21:51:16 <sproingie> every function in haskell that takes more than one arg is a HOF, so combinators arise really easily
21:51:26 <applicative__> ryantanjunming: so you should be able to eliminate all parentheses in line 26
21:51:27 <NemesisD> sproingie: so would most infix operators be combinators?
21:51:31 <ryantanjunming> so how would that relate to the following? x `par` y `par` z `pseq` f x y z
21:51:40 <Ghoul_> Nothing : 3 : 2 : 1
21:51:42 <sproingie> NemesisD: potentially, yes
21:51:42 <Ghoul_> > Nothing : 3 : 2 : 1
21:51:45 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe a0),
21:51:45 <lambdabot>                    GHC...
21:51:57 <Ghoul_> > Nothing : Just 3 : Just 2 : Just 1
21:51:59 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a0]'
21:51:59 <lambdabot>              with actu...
21:52:24 <NemesisD> sproingie: what manner of combination are we talking here, like composition?
21:53:57 <applicative__> ryantanjunming: I'm not sure i understand it's the same as par x (par y (pseq x (f x y z)))
21:54:45 <applicative__> everything is arranged to let you write that  x `par` y `par` z `pseq` f x y z which is sort of the stereotyped usage
21:57:00 <sproingie> NemesisD: pretty much any way you want, the typical connotation with combinators is that there's some amount of orthogonality going on
21:57:25 <sproingie> NemesisD: it doesn't really have a hard and fast definition other than "functions you combine"
21:57:42 <ryantanjunming> applicative__: yeah alright then, any websites or resources to check from besides the haskell documents?
21:57:59 <mm_freak> am i really the only one who cares about this option?  if it does what its name suggests, it would mean that cabal phones home…
21:58:28 <shelf> who cares
21:59:20 <shelf> but if you cannot get the answer you want, use wireshark
21:59:20 <applicative__> mm_freak: it's been around a while, it was advertised.  I would give everything I own to Duncan C if possible....
21:59:23 <sproingie> only ever use wireshark behind a highly firewalled box.  wireshark itself has tons of security issues.
21:59:34 <applicative__> ryantanjunming: unfortunately the new state of the art primer http://ofps.oreilly.com/titles/9781449335946/sec_par-eval.html seems to skip par and pseq for the Eval monad
21:59:59 <applicative__> sorry, should have linked the title page http://ofps.oreilly.com/titles/9781449335946/index.html
22:00:13 <mm_freak> applicative__: my search didn't give any such advertisement, and it's a serious security breach in my case…  it means that i've been sending confidential information around without even knowing it
22:01:21 <applicative__> mm_freak: I concede I only considered cases like my own
22:01:55 <ryantanjunming> applicative__: ahh good book, thanks!!
22:01:55 <mm_freak> do you know how to disable that?
22:02:26 <applicative__> ryantanjunming: it's excellent, yes
22:02:39 <applicative__> mm_freak: no, dcoutts must know
22:02:47 <mm_freak> dcoutts: ping
22:02:55 <mm_freak> applicative__: thanks
22:03:18 <johnw> shachaf: http://stackoverflow.com/questions/7427192/would-seq-ever-be-used-instead-of-pseq
22:03:21 <johnw> just fyi
22:03:34 <shachaf> johnw: ?
22:03:35 <Saizan> mm_freak: afaik it's not sending anything anywhere, yet
22:03:43 <johnw> shachaf: it was apropos of that earlier discussion
22:04:04 <shachaf> Did I say something that contradicts that page?
22:04:08 <johnw> no
22:04:16 <johnw> n/m then
22:04:44 <ryantanjunming> >max 1 2
22:05:00 <mm_freak> Saizan: that's reassuring, but i'd like to make sure
22:05:00 <chance> can someone explain to me how splitVal works in this code; http://web.engr.oregonstate.edu/~erwig/cs381/Haskell/WarmUpWorkOut/List2.hs ?
22:05:02 <ryantanjunming> > max [1] [2]
22:05:03 <lambdabot>   [2]
22:05:11 <Saizan> mm_freak: there's the "cabal report" command to send reports but i think it's only going to work with hackage2
22:05:21 <chance> ive tried reasoning through it, but dont quite see whats happening in that magic.
22:06:07 <chance> for reference: http://web.engr.oregonstate.edu/~erwig/cs381/Haskell/WarmUpWorkOut/WorkOut
22:06:31 <chance> mostly practice exercises for a class ill be taking sometime in the future.
22:06:41 <mm_freak> Saizan: ok, i hope that's the only way to send build reports…  i hope dcoutts will shed some light on this
22:10:19 <cmears> chance, I think the only way to do it is to try to evaluate a few examples by hand
22:11:15 <chance> hmm
22:15:04 <chance> actuallyi think i see whats going on
22:15:19 <chance> although i dont know how id logically figure out how to do that on my own yet xD
22:16:22 <cmears> It takes most people some time to be familiar with
22:16:43 <cmears> I remember struggling with logic programming at first, and then you just get used to it
22:21:35 <sproingie> cmears: your knowledge finally unifies and unblocks the Grok logic variable :)
22:27:00 <applicative> ah dcoutts_ is here mm_freak
22:27:27 <applicative> oh and so is dcoutts I'm confused
22:27:35 <dcoutts_> mwahaha!
22:28:54 <applicative> we wanted to know about the field in the .cabal/config file about anonymous reporting
22:29:34 <dcoutts_> applicative: ah yes, that's a little unfortunate
22:29:49 <applicative> remote-build-reporting: ...
22:29:57 <dcoutts_> applicative: it's default value should have been blank, not "anonymous"
22:30:21 <dcoutts_> applicative: the idea was later we could have people explicitly opt-in to anonymous build reporting
22:30:42 <applicative> in any case, it isn't being used at the moment?
22:30:56 <dcoutts_> but accidentally the default value ended up being wrong, so we'll have to come up with a different value to indicate an explicit opt-in
22:31:18 <dcoutts_> applicative: not yet, the old hackage doesn't support uploading anonymous build reports
22:31:34 <dcoutts_> applicative: but more or less all the code to do it is in cabal already
22:31:47 <dcoutts_> applicative: interested in finishing it off?
22:31:54 <applicative> so mm_freak is safe so far.  he does't seem to be awake, but was worried he has a more secure setup than some of us
22:32:37 <applicative> what is the advantage of these reports, briefly
22:32:39 <dcoutts_> applicative: no, the plan is for opt-in to anon build reporting, not opt-out
22:33:00 <applicative> yeah I understood
22:33:27 <dcoutts_> applicative: well, if we can collect 10s of 1000s of these things on hackage then we can get a much better idea of what packages work, and on what platforms and against what deps
22:33:43 <dcoutts_> applicative: as opposed to having just a small handful of build bots
22:33:44 <shachaf> Roman Cheplyaka doesn't tend to be around IRC, right?
22:33:54 <applicative> i guess its obvious.  feuerbach
22:35:00 <applicative> hm, i wonder how hard it would be to complete.
22:35:36 <applicative> do i signal mm_freak with @tell i guess
22:35:54 <dcoutts_> applicative: on the client side the main thing is to prompt people to opt-in when the first start using cabal, and to finish the code for actually uploading
22:36:18 <applicative> the prompt sounds easy....
22:36:46 <dcoutts_> applicative: the idea is we would POST the reports when we do cabal update
22:36:54 <applicative> what is uploaded the whole contents of --verbose=30 or whatever?
22:37:01 <Saizan> shachaf: not lately
22:37:21 <dcoutts_> applicative: you can check, but I think the code to collect the reports in a per-server file is already working
22:37:27 <applicative> ah, so they are stored until update, then while the laborious update happens theres a POST in parallel
22:39:33 <applicative> ah I see the BuildReports directory in the repo
22:42:14 <applicative> the first time cabal is run, or something like that, there should be a bit of discussion of the config file, for example, people are forever regretting some of the obviously sane defaults like no profiling
22:43:24 <dcoutts_> applicative: when you get it working, you'll see that the anon build report files are quite simple, and rather minimal info (so it should be actually anonymous)
22:43:53 <dcoutts_> it also supports detailed build reporting, which is basically the anon build metadata + a full build log
22:44:00 <applicative> yeah, i see how the data structure works.
22:44:17 <dcoutts_> that's to support the build bot use case
22:44:17 <applicative> dcoutts_: I see and that is for some deeper level of opting in?
22:44:22 <dcoutts_> right
22:44:36 <dcoutts_> none | anonymous | detailed
22:45:12 <dcoutts_> applicative: the new hackage server actually supports the detailed reports already, but not the anonymous kind yet
22:45:57 <dcoutts_> the anon ones require special handling to preserve anonymity
22:45:57 <applicative> the hackage server already in place?
22:46:18 <dcoutts_> applicative: the new impl, currently running at new-hackage.haskell.org
22:46:56 <dcoutts_> applicative: re first time, yes, and other things like bindir
22:47:14 <applicative> bindir ?
22:47:22 <applicative> you mean, where it is and put it in path
22:47:31 <dcoutts_> yes
22:48:00 <dcoutts_> applicative: I'd like the default setup to be that we install binaries with version suffixes into ~/.cabal/bin, and then symlink unversioned ones into ~/bin which should be on the $PATH
22:48:08 <applicative> its kind of distasteful having a pileof text for first use, but I wonder if thought out it could save some trouble
22:48:15 <dcoutts_> cabal can do both of those things already
22:48:41 <dcoutts_> applicative: yeah so far we've made it non-interactive, but I think we could do better with being interactive in some cases
22:48:55 <applicative> oh, I don't have a ~/bin by default, do linuxes?
22:49:08 <mauke> applicative: no
22:49:11 <dcoutts_> applicative: many do, or at least support it
22:49:27 <dcoutts_> applicative: e.g. they have it on the $PATH, even if it doesn't exist by default
22:49:33 <dcoutts_> it's a pretty common convention
22:50:17 <applicative> oh interesting.
22:50:43 <applicative> it would spare some disasters with things like pandoc where we have piles of nonadept users
22:51:03 <applicative> bless them
22:51:45 <ryantanjunming> :t Smaller
22:51:46 <lambdabot> Not in scope: data constructor `Smaller'
22:52:41 <applicative> I wonder though, I do have my own ~/bin with sundry nonsense in it. but that everything haskelly is in .cabal and a few other places and can be deleted has some advantages
22:53:04 <dcoutts_> applicative: that's why we'd only symlink them into ~/bin
22:53:12 <applicative> e.g. mzero had a script to delete everything haskelly you ever installed, it wouldn't want to pick through ~/bin
22:53:24 <applicative> right.
22:53:30 <dcoutts_> applicative: and the code for doing the symlinking is careful to not overwrite things it does not control
22:53:51 <dcoutts_> applicative: it only overwrites existing symlinks that point into the same place
22:54:41 <dcoutts_> applicative: so such a script would still be possible, it'd need to read the symlinks
22:55:45 <applicative> oh i see the elaborate discussion in InstallSymlink.hs
22:55:55 <dcoutts_> right
22:57:12 <applicative> hm and how can i find out about the hackage server on the other end. I guess thats obvious, just never noticed it actually had source ....
22:57:14 <bos> i never thought i'd find myself pining for c++
22:57:42 <dcoutts_> applicative: code.haskell.org/hackage-server/
22:58:03 <dcoutts_> bos: mm?
22:58:40 <applicative> bos is it amidst haskelling that you are pining for c++ ?
23:00:17 <bos> certain aspects of templates and the STL are surprisingly thoughtfully put together
23:01:30 <lispy> bos: I always forget his name, but there was that one guy that designed a lot of it
23:01:36 <bos> alexei stepanov has a pretty good book about how you put together a good hierarchy of what we think of as typeclasses, allowing you to build interesting algorithms with known properties
23:01:37 <lispy> bos: he does good generic programming
23:01:41 <lispy> ah, yeah him
23:01:54 <applicative> dcoutts_: well i will study, It maybe the communication back and forth with hackage will involve something beyond my competence but there's always a first time.
23:02:22 <bos> our typeclass hierarchy in haskell suffers in comparison as a result of being the scattered work of a bunch of random smart people
23:03:02 <bos> plus typeclasses kill performance
23:03:15 <dcoutts_> applicative: great. The communication for posting detailed build reports is already in place and fairly clear. The anon path on the server is not there yet, but would actually be simpler.
23:03:26 <lispy> And we could probably be putting type classes to better use in places that we don't use it. See for example, handles and other IO resources.
23:04:17 <dcoutts_> applicative: see http://new-hackage.haskell.org/api#reports-core
23:04:37 <applicative> ah
23:04:51 <dcoutts_> applicative: so for detailed reports, you POST the report metadata, it gives you back a report id url, then you attach a build log to that
23:05:30 <dcoutts_> applicative: for anon it'll be simpler, just POST all of them in one file (they don't get given separate ids)
23:05:44 <dcoutts_> and for anon it'll not require authentication
23:08:32 <applicative> i guess i would build a version of this server somewhere so i could see what i'm doing.
23:09:28 <applicative> well, I will bother you more when I look into it more. this week i must read a newzealand thesis -- which is why I'm on #haskell....-- then it's summer
23:09:56 <dcoutts_> applicative: yes, it's not hard to build on its own
23:10:06 <dcoutts_> applicative: ok, cool
23:25:02 * hackagebot templatepg 0.2.5 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/templatepg-0.2.5 (ChrisForno)
23:30:02 * hackagebot dates 0.2.2.0 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.2.0 (IlyaPortnov)
23:50:03 <hpaste> jekor pasted “Unbound implicit parameter” at http://hpaste.org/86965
23:50:52 <shachaf> jekor: Monomorphism restriction?
23:50:55 <jekor> I'm trying to figure out why the compiler can't derive the correct type restriction in that paste. It derives others fine, and I can't see the difference.
23:50:56 <jekor> Hmm...
23:51:13 <jekor> Wow, nice. Thanks.
23:51:34 <jekor> Heh, in reducing my test case I removed NoMonomorphismRestriction and got a different (above) error.
23:52:24 <jekor> I was just reading about that tonight too. I still don't understand it.
23:52:34 <arkeet> it's evil.
23:52:47 <jekor> I suppose that's all I need to know :P
23:54:17 <johnw> jekor: if you have a locally defined, polymorphic function, the use of that function will "fix" the types if you have monomorphism restriction enabled.  that's my understanding
23:54:50 <johnw> making the function global, or remove the restriction, makes it polymorphic over all invocations
23:55:02 <arkeet> no, top-level things get monomorphicized too.
23:55:04 <johnw> amirite?
23:55:04 <shachaf> Not really.
23:55:06 <shachaf> It doesn't have to do with being locally defined, or with being a function, or with the use of the function.
23:55:27 <johnw> arkeet: guess i've just never encountered it in that context
23:55:32 <johnw> good to know
23:55:36 <johnw> shachaf: haha
23:55:56 <johnw> well, I spelled monomorphism right.  baby steps
23:55:58 <arkeet> any binding without arguments is subject to the monomorpihsm restriction.
23:56:04 <arkeet> @where dmr
23:56:04 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:56:19 <johnw> ah
23:56:32 <shachaf> If you have a binding like this -- name = ... -- and with no type signature, it'll be monomorphic.
23:56:53 <johnw> nice way to put it
23:56:55 <shachaf> This is true regardless of whether it's a function, and regardless of whether it's locally defined, and regardless of whether you use it.
23:57:00 <johnw> right
