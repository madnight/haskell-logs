00:03:52 <Shin-LaC> why can't I do full pattern matching in guards?
00:04:07 <mm_freak> Shin-LaC: you can?
00:04:10 <ski_> you can, with pattern guards
00:04:18 <mm_freak> | Just x <- M.lookup x myMap
00:04:20 <mm_freak> | Just x <- M.lookup k myMap
00:04:35 <ski_> (also stuff like `| case blah of ... = ...')
00:05:09 <mm_freak> i'm slowly getting used to monad-control…  i even start to understand how to write MonadTransControl instances =)
00:05:16 <mm_freak> and why my type sucks for that =/
00:05:22 <Shin-LaC> oh ok
00:06:03 <Shin-LaC> hrm
00:10:11 * sw2wolf what's monad stack ?
00:10:45 * ski_ calls the /me police
00:10:59 <ski_> (presumably "monad transformer stack" was meant)
00:12:31 <ski_> Apes : .. mhm
00:14:26 <Shin-LaC> is there a function for applying a function n times?
00:16:52 <Shin-LaC> oh, iterate
00:16:52 <sw2wolf> yeah, it is monad transformer stack
00:19:08 <mm_freak> Shin-LaC: "apply n times" can have many meanings
00:19:20 <mm_freak> iterate, replicateM, …
00:20:15 <Shin-LaC> in this case I needed to "Replicate the elements of a list a given number of times."
00:20:22 <Shin-LaC> so I did: repli (h:t) n = iterate ((:) h) (repli t n) !! n
00:20:47 <mm_freak> Shin-LaC: like this?
00:20:51 <mm_freak> > replicate 10 'a'
00:20:53 <lambdabot>   "aaaaaaaaaa"
00:20:59 <Shin-LaC> no
00:21:13 <Shin-LaC> repli "afsfd" 3 -> "aaafffsssfffddd"
00:21:32 <mm_freak> > concatMap (replicate 3) "abc"
00:21:33 <lambdabot>   "aaabbbccc"
00:21:39 <ski_> > replicate 3 =<< "abc"
00:21:41 <lambdabot>   "aaabbbccc"
00:22:10 <Shin-LaC> isn't it less efficient to first build lots of lists and then concatenate then?
00:22:15 <mm_freak> no
00:22:20 <Shin-LaC> why not
00:22:25 <mm_freak> likely your variant is less efficient
00:23:04 <mm_freak> Shin-LaC: if you unroll all the definitions you get quite a straightforward algorithm for doing this
00:23:52 <mm_freak> composing list functions always gives you an efficient solution…  also you benefit from deforestation optimizations
00:25:43 <mm_freak> Shin-LaC: as a useful note, if you can't express your list transformation as a composition of list functions it suggests that your transformation is either unsound or inherently unlisty
00:26:54 <Shin-LaC> why does concatMap exist?
00:27:02 <Shin-LaC> what's the advantage over doing concat(map …)
00:27:16 <shachaf> None, really.
00:27:16 <ski_> shorthand
00:27:31 <shachaf> Well, concat(map …) is weird syntax. You should use concat (map …) :-)
00:27:37 <simpson> @src concatMap
00:27:37 <lambdabot> concatMap f = foldr ((++) . f) []
00:27:44 <Shin-LaC> concat $ map
00:27:49 <shachaf> concatMap is what list comprehensions are made of, more or less. Maybe that's important.
00:27:57 <mm_freak> Shin-LaC: it's so common that you get a name for it…  in fact (>>=) is flip concatMap, so concatMap is a building block of the list monad
00:28:34 <shachaf> (>>=) :: Monad m => m a -> Codensity m a
00:29:03 <ski_> @undo [y | x <- xs, y <- f x]
00:29:03 <lambdabot> concatMap (\ x -> concatMap (\ y -> [y]) f x) xs
00:29:05 <shachaf> Is there a point to this? data Foo m a = forall x. Foo (m x) (x -> m a)
00:29:39 <otters> fix Foo
00:29:50 <c_wraith> shachaf: that's actually something I've considered deeply. The answer is..  For some values of m.
00:29:51 <shachaf> What?
00:30:05 <shachaf> Oh boy, I love deep consideration.
00:30:15 <shachaf> imo go on
00:32:04 <c_wraith> if m is some monad that gives you extra information when the action is run, in some way or another, and you use that information to determine whether/how to run the function with the value the action results in
00:33:19 <Shin-LaC> why does this not terminate? dropEveryNth l n = (take (n-1) l) ++ dropEveryNth (drop n l) n
00:33:22 <c_wraith> Then you might you a data type like that to send things over a monomorphic interface, like a Chan
00:33:32 <c_wraith> I've actually written code similar to that in the past.
00:33:41 <c_wraith> But without actually needing the existential
00:33:50 <ski_> Shin-LaC : what's the base case ?
00:33:54 <c_wraith> But it's what made me curious if there were cases when the existential actually makes sense.
00:34:06 <sw2wolf> @wn existential
00:34:06 <lambdabot> *** "existential" wn "WordNet (r) 3.0 (2006)"
00:34:06 <lambdabot> existential
00:34:07 <lambdabot>     adj 1: derived from experience or the experience of existence;
00:34:07 <lambdabot>            "the rich experiential content of the teachings of the
00:34:07 <lambdabot>            older philosophers"- Benjamin Farrington; "formal
00:34:08 <lambdabot> [6 @more lines]
00:34:24 <Shin-LaC> oh
00:34:27 <c_wraith> And I could think of those cases, but they weren't the ones I was dealing with
00:34:41 <Shin-LaC> ski_: I see
00:34:44 <Shin-LaC> fixed
00:34:56 <Shin-LaC> as an aside, is that a good approach?
00:34:57 <shachaf> What's a concrete case where it makes sense?
00:35:16 <Shin-LaC> I'm not sure if I'm really "composing list functions"
00:37:31 <c_wraith> Every case I can think of is both hand-wavey and huge. Now is not the time for me to try to pin one down sanely.
00:38:17 <c_wraith> too tired
00:39:47 <shachaf> OK.
00:39:51 <shachaf> Tell me if you think of one.
00:42:18 <ski_> sw2wolf : as in existential type
00:43:00 <shachaf> ski_: Did you see my conclusion that fmap :: CoYoneda f a -> f a; fmap :: f a -> Yoneda f a?
00:48:33 <ski_> shachaf : conclusion ?
00:49:09 <shachaf> Maybe not a conclusion.
00:50:49 <ski_> shachaf : i use those as handy mnemotechniques for recalling the definition of `Yoneda' and `CoYoneda'
00:51:35 <ski_> (and similarly for `CoDensity' and `Density' wrt `(>>=)' and `(=>>)', yes)
00:51:53 <shachaf> Right, that too.
00:52:04 <shachaf> Are there other things like that?
00:52:14 <shachaf> Bazaar is vaguely like it.
00:53:22 <ski_> recall `Bazaar' ?
00:55:14 <shachaf> Bazaar a b t = Bazaar { runBazaar :: forall f. Applicative f => (a -> f b) -> f t }
01:02:17 <shachaf> dcoutts: Is --enable-executable-profiling just broken on ghc 7.6/Cabal 1.16.0/cabal-install 1.16.0.2?
01:02:27 <shachaf> (I suppose the version of Cabal is what matters.)
01:03:59 <sw2wolf> ski_: thx
01:04:39 <ski_> sw2wolf : if you have more questions, just ask
01:05:34 <mm_freak> snoyberg: i have a monad for which i can define a MonadBaseControl instance, but not a MonadTransControl instance…  the reason is that the "state" contains computations in that monad
01:05:50 <mm_freak> is this conceptually unsound or is it reasonable that it happens for some monads?
01:06:01 <snoyberg> mm_freak: i hope it's reasonable, i do it ;)
01:06:07 <mm_freak> ok =)
01:06:32 <snoyberg> https://github.com/yesodweb/yesod/blob/yesod1.2/yesod-core/Yesod/Core/Types.hs#L367
01:06:41 <snoyberg> i don't see any problem with it
01:06:59 <ski_> shachaf : hm, `\o p a -> Bazaar a p o' is an indexed monad ?
01:08:34 <mm_freak> snoyberg: i'm still having a lot of trouble with it though
01:08:51 <shachaf> ski_: It is?
01:09:23 <shachaf> We called that type Baz.
01:09:35 <shachaf> I know that (Baz t b) is Traversable.
01:11:49 <ski_>   return :: a -> (forall i. Applicative i => (a -> i o) -> i o)
01:11:55 <ski_>   (>>=) :: (forall i. Applicative i => (a -> i p) -> i o) -> (a -> forall i. Applicative i => (b -> i q) -> i p) -> (forall i. Applicative i => (b -> i q) -> i o)
01:12:34 <ski_> and apparently `Applicative' isn't really used
01:13:59 <ski_> .. not sure whether this is useful, though
01:14:38 <sw2wolf> ski_: can ghci load module which not in current directory ?
01:14:50 <sw2wolf> i mean :load Foo
01:16:21 <ski_> you can use `-i' to specify additional directories to search
01:16:51 <sw2wolf> ghci -i ... ?
01:16:55 <nh2> snoyberg: why does yesod-core depend on shakespeare? Is there a an even smaller yesod package that only does routing and request -> response convenience?
01:17:35 <snoyberg> nh2: yesod-core uses shakespeare internally for producing error responses
01:17:53 <snoyberg> but the *real* reason is so that it can provide instances for ToWidget and a few other things
01:18:12 <snoyberg> you can use yesod-core without touching shakespeare if you want
01:24:05 <sw2wolf> ski_: -i<dir> works. The Foo modules is loaded. Howver, code in Foo cannot manipulate some data files which are in the same <DIR> as Foo.  Donot i have to `cd` to <DIR> ?
01:25:11 <mm_freak> snoyberg: ok, you're cheating the same way as i do…  that's reassuring =)
01:25:22 <mm_freak> you're just putting the lower StM into your higher StM =)
01:25:31 <snoyberg> mm_freak: we're all wrong together ;)
01:25:46 <snoyberg> but yes, i think it's a safe approach
01:25:58 <snoyberg> and i'm not sure how useful MonadTransControl actually is in practice
01:26:14 <snoyberg> the only thing i really need is `MonadBaseControl IO`
01:26:31 <ski_> i think code in `Foo' do not automagically run in a context (read, dynamical environment) where the current directory is the directory containing `Foo' (or perhaps alternatively the base directory from which `Foo' was reached ?)
01:26:54 <mm_freak> snoyberg: alright…  me too
01:38:25 <nh2> snoyberg: thanks
02:03:20 <sw2wolf> sorry, just come back.
02:03:30 <circle> I've copied an exercise out of the book exactly and it doesn't work
02:03:32 <circle> here's the code
02:04:18 <hpaste> circle pasted “why” at http://hpaste.org/85077
02:04:50 <shachaf> Because the book is simplifying some things.
02:04:55 <shachaf> The code is not runnable as is, unfortunately.
02:05:21 <shachaf> See http://www.cs.nott.ac.uk/~gmh/book.html for a version of the code you can run.
02:05:29 <sw2wolf> i.e. readFile "bar.dat" will error if we dont `cd` to <DIR> containing "bar.dat" first.
02:05:34 <shachaf> Assuming that's the book, anyway.
02:06:04 <circle> ah ok
02:06:06 <circle> thanks
02:15:16 * hackagebot som 4.1 - Self-Organising Maps  http://hackage.haskell.org/package/som-4.1 (AmyDeBuitleir)
02:15:42 <mm_freak> snoyberg: you may also be interested in my new library:  https://github.com/ertes/continue
02:15:59 <mm_freak> now that i managed to write a MonadBaseControl instance i'm feeling safe to publish it =)
02:16:56 <mm_freak> this library enables writing continuation-based web frameworks
02:17:13 <mm_freak> finally you can write stateful web apps (like forms) like command line applications =)
02:17:43 <snoyberg> wow, interesting
02:18:00 <snoyberg> reading the README made me think "goto", but i can see it's more sophisticated than that
02:18:08 <mm_freak> yeah
02:18:46 <mm_freak> snoyberg: if f is a Comonad, then goto is possible
02:19:35 <mm_freak> but then it mostly behaves like plain old ContT
02:19:41 <mm_freak> so not very interesting =)
02:20:07 <shachaf> imo Codensity
02:20:58 <mm_freak> after some testing i will put it on hackage
02:21:21 <mm_freak> i want to implement a "replayable command line" application
02:21:47 <jMCg> Is it possible or sensible to run my own hpackage server?
02:21:48 <snoyberg> so you store closures in memory, correct?
02:21:57 <mm_freak> but replayable with different values…  think of a computer algebra system where you have written a lot of stuff, but then you want to repeat all the calculations with a slightly different value somewhere
02:22:01 <mm_freak> Continue makes that possible
02:22:05 <mm_freak> snoyberg: yeah
02:22:12 <snoyberg> jMCg: depending on your needs, you could consider yackage (http://hackage.haskell.org/package/yackage)
02:27:20 <jMCg> snoyberg: can you elaborate on "depending on your needs" - or would I have to do that? (My needs are: We have an internal buildserver (jenkins), we would like to be able to build stuff automatickally, with all its [our internal] dependencies, and potentially use the "repo" for central deployments)
02:27:49 <snoyberg> i've used yackage for those kinds of setups before
02:28:15 <snoyberg> it's an incredibly dumb server, it doesn't have any kind of security, good UI, etc
02:28:23 <snoyberg> but if it's just for automation, it should work
02:30:14 <ski_> mm_freak : reminds me of <http://www.smlnj.org/doc/SMLofNJ/pages/smlnj.html#SIG:SML_OF_NJ.exportML:VAL>
02:34:01 <mm_freak> ski_: except that Continue doesn't solve the function serialization problem =)
02:36:03 <snoyberg> i'm having trouble getting a UnicodeSyntax module to parse with haskell-src-exts (https://gist.github.com/snoyberg/5299745)
02:36:11 <ski_> yea, i was thinking about the boolean thing
02:36:13 <snoyberg> it's working with stylish-haskell, just not with my code, any thoughts?
02:37:03 <jMCg> snoyberg: I really love this documentation..
02:40:58 <sw2wolf> why canot i use Data-Files in *.cabal? http://paste.lisp.org/display/136467
02:41:38 <dcoutts_> sw2wolf: that field goes in the main section
02:41:52 <dcoutts_> as does extra-source-files
02:43:07 <sw2wolf> dcoutts_: oh, let me try
02:50:08 <sw2wolf> dcoutts_: `cabal register money` reports: cabal: Unrecognised flags: money
02:50:41 <dcoutts_> sw2wolf: cabal register doesn't take any args
02:52:39 <sw2wolf> thx, it reports: cabal: <command line>: Failed to load interface for `Money'
02:54:21 <dcoutts_> sw2wolf: can you paste the full log of running the command, with -v, and also the .cabal file
02:54:22 <sw2wolf> dcoutts_: thx, i will test it later.
02:54:31 <dcoutts_> that's not an error message I recognise
02:54:48 <sw2wolf> cabal register -v
02:54:48 <sw2wolf> /usr/local/bin/ghc --abi-hash -fbuilding-cabal-package -O -odir dist/build -hidir dist/b
02:54:48 <sw2wolf> uild -stubdir dist/build -i -idist/build -i. -idist/build/autogen -Idist/build/autogen -
02:54:48 <sw2wolf> Idist/build -optP-include -optPdist/build/autogen/cabal_macros.h -package-name money-0.1
02:54:51 <sw2wolf> .0.0 -hide-all-packages -package-id base-4.5.0.0-1a022b3476300ed3e5bfdd46dd7221d0 -packa
02:54:54 <sw2wolf> ge-id directory-1.1.0.2-295465228776dcfcc680f61dc2cbcb59 -package-id old-time-1.1.0.0-68
02:54:58 <sw2wolf> 1e9789e8750358e65a9448b60ba641 -package-id process-1.1.0.1-91185c964ab744c1f3cbca1863d2b
02:55:01 <sw2wolf> a45 -package-id random-1.0.1.1-3bece392c9f5221263ed25c90c28e1ec -package-id time-1.4-3e1
02:55:04 <sw2wolf> 86a51d3674e5d65b5a7925db3d3a7 -XHaskell98 Money
02:55:08 <sw2wolf> cabal: <command line>: Failed to load interface for `Money'
02:55:09 <dcoutts_> sorry, I meant hpaste or something like that
02:55:15 <sw2wolf> sorry
02:55:45 <dcoutts_> sw2wolf: ok, looks like either you have not built the code yet, or there's a mismatch between the modules you have and what you declare in the .cabal file
02:56:19 <sw2wolf> http://paste.lisp.org/display/136468
02:57:50 <sw2wolf> cabal file: http://paste.lisp.org/display/136469
02:58:24 <dcoutts_> sw2wolf: and did you build the code before running register?
02:58:41 <sw2wolf> not yet
02:58:50 <dcoutts_> ok, that's a pre-requisite
02:59:47 <sw2wolf> i see now, thx
03:02:57 <typoclass> sw2wolf: just to make sure, you can generally just do "cabal install somepackage" and it will automatically do register and all the other steps
03:03:37 <sw2wolf> yeah
03:04:22 <sw2wolf> time for dinner now, bye
03:30:28 * hackagebot family-tree 0.4.1.1 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.4.1.1 (NathanVanDoorn)
03:35:11 <bitonic> jaspervdj: hey gotta go out but if you think that recording the filepath is too much of an hassle just close the issue
04:05:29 * hackagebot iCalendar 0.2.1 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.2.1 (ChristianRoedliAmble)
04:07:30 <DarkFox> How do you tell ghc to compile using multiple threads?
04:07:33 <DarkFox> cores *
04:07:47 <DarkFox> 70-90% of core 1/8
04:08:52 <danr> ghc -threaded
04:08:56 <danr> oh
04:09:03 <Kinnison> http://hackage.haskell.org/trac/ghc/ticket/910
04:09:46 <DarkFox> What about with cabal?
04:09:58 <DarkFox> I.e cabal install packageX -?
04:09:59 <Kinnison> cabal -j just does multiple package builds in parallel
04:10:08 <Kinnison> doesn't help when building a single large package
04:10:32 <Kinnison> if you have one package which has maybe 30 or more modules in it, it can't take advantage of multi-core systems
04:10:38 <DarkFox> But many dependancies?
04:11:26 <DarkFox> cabal install -j4 hakyll # Am I running that right?
04:11:35 <DarkFox> To use 4 cores instead of the 1.
04:12:10 <Kinnison> If you want to build in parallel internally, you'd need to write a makefile and not use ghc --make
04:12:33 <DarkFox> What does it default to if you just do -j?
04:13:41 <Kinnison> You can do ghc -M -dep-makefile .depend $(SRCS)
04:14:00 <DarkFox> O.o
04:14:03 <Kinnison> to make a .depend file with the dependency info you would need in order to do an individual ghc invocation per module
04:14:10 <Kinnison> But it's very messy
04:14:50 <DarkFox> So. -j doesn't use multiple cores, just compiles multiple things concurrently?
04:20:52 <byorgey> DarkFox: it does use multiple cores.
04:21:27 <mm_freak> do you say "suspensible" or "suspendable"?
04:21:56 <hiptobecubic> the latter
04:22:06 <brisbin> quit
04:22:45 <DarkFox> byorgey: I see one core getting the flogging and the rest idle
04:22:53 <mm_freak> thanks
04:24:36 <arkeet> DarkFox: cabal install -j just installs multiple packages in parallel.
04:25:06 <DarkFox> Yea
04:25:30 <DarkFox> How many at once with -j?
04:25:42 <DarkFox> (default N in -jN
04:25:44 <DarkFox> )
04:26:29 <arkeet> uh
04:27:01 <arkeet> I think it's "as many as it can." I might be confusing it with something else though
04:27:37 <DarkFox> Okay :)
04:33:34 <hpaste> Nilsi pasted “Intersection” at http://hpaste.org/85084
04:33:49 <nilsi> What wrong with that one?
04:34:07 <nilsi> Some type problem but can't tell exactly
04:34:17 <nilsi> Couldn't match type `(->) [a0]' with `[]'
04:35:46 <ski_> nilsi : sounds like missing or unexpected extra function argument
04:35:59 * ski_ looks at paste
04:36:30 <byorgey> nilsi: intersection' takes three arguments, but in the first two cases you are calling it with only two
04:37:08 <byorgey> also, note that  intersection' as bs a:result  parses as  (intersection' as bs a) : result.  I assume you instead want  intersection' as bs (a:result) .
04:37:08 <ski_> nilsi : in addition to what byorgey said, you probably intended brackets around the `a:result' in the "equals" case
04:37:42 <ski_> note that
04:37:44 <ski_>   intersection' as bs a:result
04:37:54 <ski_> will be parsed as if you had written
04:37:59 <ski_>   (intersection' as bs a):result
04:38:09 <ski_> which is presumably not what you intended
04:39:08 <nilsi> byorgey, ski_: ahh, im blind. Thank's guy's not used to the syntax yet
04:39:51 <ski_> nilsi : finally, (a) you might want to use `case compare a b of LT -> ...; GT -> ...; EQ -> ...' instead of the three guards; and (b) consider returning the list of resulting elements directly, instead of using an accumulator argument
04:41:09 <ski_> (doing (b) will make your code incremental instead of bulkly : to compute a single element of the resulting list will no longer require a full traversal of the input lists until you hit the empty list for one of them)
04:41:22 <ski_> (s/bulkly/bulky/)
04:41:43 <nilsi> ski_: Okey, sound definitely better. thanks
04:42:24 <ski_> nilsi : .. also, if you plan on staying, #haskell.se might perhaps also be interesting
04:44:48 <FireFly> No-one's said anything in there in quite a while though..
05:00:44 <alexander__b> findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
05:00:46 <alexander__b> findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing
05:01:12 <_mr> alexander__b: (you might want to check out "lookup")
05:01:27 <alexander__b> I'm having trouble seeing why the tuple sent as argument becomes the argument to the lambda (in addition to the acc)
05:01:33 <alexander__b> _mr: I know of lookup.
05:03:11 <_mr> The type of foldr is (a -> b -> b) -> b -> [a] -> b
05:03:29 <_mr> you start out with acc being Nothing
05:04:13 <alexander__b> yes. I am aware of this. the thing I'm not seeing is how (k,v) gets sent to the lambda function.
05:04:47 <_mr> (k,v) is an element of the list, which you go through
05:04:59 <alexander__b> the lambda functions takes (k,v) and acc. how does the (k,v) from the function type signature "get into" the lambda function?
05:05:24 <alexander__b> how am I supposed to be reading this for it to become obvious that the (k,v) in the type definition is the (k,v) in the lambda parameter list?
05:05:30 <_mr> Oh, is it the name that is confusing you?
05:05:36 <arkeet> foldr :: ((k,v) -> Maybe v -> Maybe v) -> Maybe v -> [(k,v)] -> Maybe v
05:06:06 <_mr> You could just have written (\(key', value) -> if key' == key Maybe value...
05:06:07 <alexander__b> _mr: no. it is where the (k,v) parameter in the lambda function comes from.
05:06:26 <arkeet> :t foldr :: ((k,v) -> Maybe v -> Maybe v) -> Maybe v -> [(k,v)] -> Maybe v
05:06:27 <lambdabot> ((k, v) -> Maybe v -> Maybe v) -> Maybe v -> [(k, v)] -> Maybe v
05:06:31 <alexander__b> _mr: i.e. where am I telling the lambda function what to use for (k,v)
05:06:44 <arkeet> the value?
05:06:44 <_mr> alexander__b: it's just what foldr does. it expects a function of that type.
05:09:20 <alexander__b> _mr: I get what foldr does. what I'm asking is how I'm supposed to read this to understand how the lambda function "knows" what (k,v) is. it is not obvious where this argument comes from. Nothing is given as an argument at the far right, like I would expect. where is (k,v) given?
05:09:38 <timthelion> Is there a library for saving a tree-like structure of (FileName,String) pairs to a directory structure? So I could build the output of my program(a website generator) without IO?
05:09:47 <arkeet> alexander__b: foldr is responsible for that.
05:09:53 * timthelion can obviously code this himself.
05:09:58 <arkeet> @src foldr
05:09:58 <lambdabot> foldr f z []     = z
05:09:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:10:05 <dmwit> alexander__b: foldr supplies the value of (k,v) by looking at the list
05:10:06 <_mr> alexander__b: do you know about partially applied functions?
05:10:14 <arkeet> or higher order functions.
05:10:18 <dmwit> alexander__b: foldr is the one that calls the lambda you passed in
05:10:24 <alexander__b> _mr: somewhat. I assume that's the magic that's confusing me.
05:10:40 <arkeet> you give foldr the lambda.
05:10:40 <alexander__b> dmwit: yes, I get that foldr calls the lambda.
05:10:44 <arkeet> and then foldr does stuff with it.
05:10:47 <alexander__b> yes.
05:10:49 <_mr> alexander__b: it is the same way as (+1) is a function that takes a number and adds +1 to it
05:10:54 <dmwit> Oh. Can you say again what you don't get, then?
05:11:01 <arkeet> I don't see what this has to do with partially applied functions.
05:11:02 <alexander__b> dmwit: I am asking how the lambda knows about the list, not how foldr knows about the lambda.
05:11:12 <dmwit> alexander__b: The lambda doesn't know about the list.
05:11:16 <dmwit> alexander__b: foldr knows about the list.
05:11:22 <dmwit> alexander__b: But foldr calls the lambda. =)
05:11:23 <alexander__b> dmwit: OK. why?
05:11:28 <arkeet> because you gave it the list.
05:11:29 <alexander__b> dmwit: why does foldr know about the list?
05:11:34 <alexander__b> where?
05:11:37 <arkeet> when you called it.
05:11:39 <dmwit> alexander__b: Because you hand it a list as its last argument.
05:12:00 <dmwit> alexander__b: That is, when you call findKey, you hand findKey a list; findKey hands this list to foldr.
05:12:01 <arkeet> findKey key xs = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing xs
05:12:17 <alexander__b> arkeet: it doesn't say key xs
05:12:20 <alexander__b> findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing
05:12:29 <dmwit> Yep, sneaky, isn't it?
05:12:41 <dmwit> Nevertheless, findKey has a function type, and its type demands an extra list.
05:12:42 <arkeet> sure, instead of writing f x = g x, they just write f = g.
05:12:43 <dmwit> So does foldr's.
05:12:43 <alexander__b> well, this is likely the root of my confusion.
05:13:07 <arkeet> oh, so that's why we're talking about partial application.
05:13:15 <_mr> :-)
05:13:19 <arkeet> let me abbreviate (\(k,v) acc -> if k == key then Just v else acc) as f
05:13:25 <alexander__b> right.
05:13:30 <arkeet> findKey key = foldr f Nothing
05:13:31 <alexander__b> so it could just as well have been,
05:13:33 <alexander__b> findKey key xs = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing xs
05:13:38 <arkeet> sure.
05:13:43 <arkeet> but when we write   findKey key = foldr f Nothing
05:13:46 <alexander__b> because then I remember/get it. thanks.
05:13:49 <arkeet> what that really means is
05:13:53 <arkeet> findKey key = \x -> foldr f Nothing x
05:14:07 <mm_freak> is there a nice applicative configuration file library?
05:14:18 <arkeet> that's how behaviour of partially applied functions is defined.
05:14:31 <arkeet> mm_freak: let me know if you find one!
05:14:41 <alexander__b> arkeet: thanks.
05:14:53 <typoclass> alexander__b: this is similar how you could have your own name for 'map' or any other function. you could do "m = map". then it'd work to do "m something [1..3]"
05:15:41 <typoclass> alexander__b: and you can give map just one of its arguments, leaving the other one open. "mm = map something" will work, and then you can do "mm [0..7]"
05:15:57 <mm_freak> arkeet: right now i'm looking into 'configurator' and 'dyre'
05:16:06 <mm_freak> they both seem to be sophisticated
05:16:33 <alexander__b> typoclass: right. thanks.
05:16:40 <mm_freak> but neither is applicative =/
05:20:51 <mm_freak> i guess i'll use boomerang for configuration
06:01:00 <dmwit> Why is applicative a feature?
06:01:08 <dmwit> (for a configuration library)
06:03:01 <typoclass> dmwit: because of category theory. haven't you heard?
06:03:05 <typoclass> ;)
06:03:55 <merijn> Any clues why cabal would report C libraries as missing, but have no errors in its output with -v3?
06:04:44 <dcoutts> merijn: calling gcc for the link test ought to fail, though plausibly gcc might fail with no error message
06:05:36 <merijn> dcoutts: I was trying to compile the unix package under cygwin, initially it failed on wrong headers, because the gcc that ships with platform doesn't define __CYGWIN__ (which is needed by the headers), but it did find the libraries
06:06:17 <merijn> dcoutts: Now I got ghc to call the cygwin gcc instead of the one it ships with, which removes the header error, but now it claims to not find the relevant libraries
06:06:37 <dcoutts> merijn: hmm, I'm not sure you want to be using cygwin gcc/headers do you? you're going to be using the mingw gcc and c lib in the end
06:07:07 <merijn> I'm pretty sure the unix package won't work without cygwin on windows...
06:07:08 <dcoutts> since ghc links using mingw and the mingw libs
06:07:33 <dcoutts> merijn: certainly it needs the headers, but you want the mingw ones
06:07:48 <merijn> So I guess I need to build ghc from scratch under cygwin instead of using platform if I want to use cygwin...
06:08:10 <dcoutts> does ghc even support building with cygwin?
06:08:22 <merijn> At some point it did, afaik
06:08:29 <dcoutts> it did, years and years ago
06:08:29 <merijn> Why wouldn't it?
06:09:00 <dcoutts> merijn: why should it be a supported platform?
06:09:03 <merijn> I can't be the only person that wants to run code that relies on unix on windows
06:09:29 <merijn> The only other solutions is to port every single dependency I have that somehow relies on unix...
06:09:31 <dcoutts> merijn: check the ghc wiki
06:09:37 * typoclass wonders again what merijn is up to ...
06:10:37 <merijn> typoclass: What do you mean "what I'm up to"? I have code that uses some libraries that depend on the unix package and I'd like that code to run on windows, without having to port every dependency I have
06:11:10 <merijn> Doesn't seem like such an uncommon thing to want
06:12:18 <typoclass> merijn: sure! :-) we talked about it yesterday. but is that the story with the university project consisting of terrible c code by multiple authors, of which you scrapped half?
06:12:23 <dcoutts> merijn: http://hackage.haskell.org/trac/ghc/wiki/Building/Platforms/Windows
06:12:25 <typoclass> or another thing?
06:12:33 <dcoutts> "So GHC targets MinGW, not Cygwin. It is in principle possible to build a version of GHC, GHC-cygwin, that targets Cygwin instead. The up-side of GHC-cygwin is that Haskell programs compiled by GHC-cygwin can import the (Haskell) Posix library. We do not support GHC-cygwin, however; it is beyond our resources."
06:12:40 <merijn> typoclass: Nah, that's something else entirely
06:12:55 <merijn> dcoutts: Yeah, I just found that.
06:14:25 <merijn> Ok, like I said. I'll have to build ghc from source to get it to use cygwin. Bummer
06:14:48 <dcoutts> merijn: there's the http://hackage.haskell.org/package/unix-compat
06:15:14 <merijn> dcoutts: Yeah, but afaict that only has some modules for filesystem/path manipulation stuff
06:15:14 <dcoutts> merijn: and you'll have to fix all the issues to actually build ghc using cygwin, given that it's not a supported platform
06:16:14 <dcoutts> it's a bit more than filesystem+path stuff
06:16:21 <typoclass> aren't there any other thingies that add posix compatibility to windows? i thought microsoft has an offering, or had one
06:16:27 <merijn> Are there any? I would naively expect that mostly work...
06:16:44 <merijn> typoclass: Depends on which posix standard you refer too
06:17:17 <typoclass> merijn: sure, it's fuzzy
06:18:17 <merijn> Windows sucks as a dev environment, but if I ever want any code I write to be run by my friends/family I need to somehow be able to build stuff on it...
06:18:55 <dmwit> That's not quite true. There's always the web-app ruote.
06:18:56 <dmwit> route.
06:19:11 <merijn> Yeah...fuck that route
06:20:19 <merijn> That only works for a limited set of programs, and it's not a set I'm interested in
06:23:15 <mauke> hahaha, oh wow. one of my packages has 147 reverse dependencies
06:23:21 <mauke> I'm popular!
06:24:11 <dmwit> One of your packages is one of my favorite packages. =)
06:28:12 <danr> mauke: which one? :)
06:28:49 <nomeata> merijn: I have sucessfully ceated gtk apps on linux that run on windows, without ever running windows
06:28:59 <mauke> danr: data-default
06:29:18 <nomeata> merijn: http://www.joachim-breitner.de/archive/screen-message/screen-message-setup-0.18.exe is the windows version of http://packages.debian.org/sid/sm
06:29:40 <nomeata> Ah, I’m on #haskell, not on #debian....
06:40:41 * hackagebot MusicBrainz-libdiscid 0.4.1.0 - Binding to libdiscid by MusicBrainz  http://hackage.haskell.org/package/MusicBrainz-libdiscid-0.4.1.0 (AndreTwupack)
06:51:10 <nobdraisentone> ghc-pkg check is clear, but I cannot import any module of installed package. How can I understand why?
06:51:59 <arkeet> maybe it's hidden?
06:52:15 <arkeet> ghc-pkg describe will tell
06:56:46 <tromp_> :t maybe
06:56:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:56:48 <nobdraisentone> arkeet: https://gist.github.com/dmalikov/7f7aa483a3f1125c09bf
06:59:26 <mauke> ls /usr/lib64/xmonad-9999/ghc-7.6.2
06:59:58 <nobdraisentone> HSxmonad-0.11.o  XMonad  XMonad.hi  libHSxmonad-0.11.a
07:00:01 <__ghjk> :t True
07:00:02 <lambdabot> Bool
07:00:29 <mauke> that looks fine
07:00:38 <tromp_> :t (<$>)
07:00:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:01:06 <__ghjk> > maybe True (_ -> False) (Maybe True)
07:01:08 <lambdabot>   Pattern syntax in expression context: _ -> FalseNot in scope: data construc...
07:01:20 <nade>  hey all, I see to be misunderstanding Monads, specifically the Maybe monad. I thought that this should work... http://bpaste.net/show/mZduknqJTFyifv8WxGIq/
07:01:46 <nade> My intention was to capture only arrow key inputs. Is this completely misguided?
07:02:13 <parcs> nade: http://bpaste.net/show/aBTTZ8S2qoQIymrXn8Ei/
07:02:22 <__ghjk> > maybe "should I go?" (_ -> False) (Maybe True)
07:02:24 <lambdabot>   Pattern syntax in expression context: _ -> FalseNot in scope: data construc...
07:02:48 <typoclass> nade: hello. so, when you write IO Maybe Char, it'll group as (IO Maybe) Char, which won't work. you need to give parens explicitly: IO (Maybe Char)
07:02:56 <arkeet> nade/parcs: you could also float the return otuside teh if.
07:03:02 <arkeet> also, this has nothing to do with the Maybe monad.
07:03:02 <nade> parcs: what does wrapping the value in parens signify?
07:03:07 <nobdraisentone> mauke: there was some ghci command to check why package modules can not import, but I don't remember it
07:03:10 <typoclass> nade: (just to clarify, so far it doesn't have anything to do with the Maybe monad :-) )
07:03:21 <arkeet> nade: which parens?
07:03:27 <nade> oh
07:03:29 <arkeet> you want return (Just key), not (return Just) key.
07:03:30 <nade> i see
07:03:35 <ski_> > maybe "should you stay?" (\_ -> "should I stay?") (Just False)
07:03:36 <typoclass> __ghjk: hello, you seem to be forgetting the "\". try "(\_ -> ...)"
07:03:36 <lambdabot>   "should I stay?"
07:03:39 <arkeet> which is what it would mean without parens.
07:03:44 <nade> so it was just a syntax issue
07:04:10 <arkeet> http://bpaste.net/show/7tk7ckKbJxdHlnF9Po3H/
07:04:31 <McManiaC> parcs: IO (Maybe ...)
07:04:33 <__ghjk> typoclass, he right, switching between erlang..
07:04:36 <parcs> no reason in doing that
07:04:40 <nade> arkeet: why is that preferred?
07:04:51 <arkeet> actually, I'd write a separate function Char -> Maybe Char
07:05:01 <arkeet> and use that.
07:05:24 <nade> which gets called from the IO monad?
07:05:30 <parcs> if you really want to shorten the expression you can do 'return $ key <$ guard (isControl key)'
07:05:55 <arkeet> indeed.
07:06:16 <__ghjk> ski_, what is the (Just false) for then?
07:06:25 <vlatkoB> Is there a way to write
07:06:26 <vlatkoB> instance Functor T where
07:06:26 <vlatkoB>   fmap f (TS x) = TS (f x)
07:06:26 <vlatkoB>   fmap f (TO x) = TO (f x)
07:06:26 <vlatkoB>   fmap f (TC x) = TC (f x)
07:06:26 <vlatkoB>  in a shorter form?
07:06:45 <arkeet> vlatkoB: you can derive Functor with -XDeriveFunctor
07:06:48 <bxc_> is there a unique counter/supply monad in hackage? /me sees lots of examples of one but not a hackage one
07:06:57 <parcs> bxc_: Data.Unique
07:07:00 <parcs> bxc_: in base
07:07:01 <ski_> __ghjk : as scrutinee input for `maybe' ?
07:07:14 <ski_> @src maybe
07:07:14 <lambdabot> maybe n _ Nothing  = n
07:07:14 <lambdabot> maybe _ f (Just x) = f x
07:07:55 <typoclass> __ghjk: are you sure you need the 'maybe' function? what are you planning?
07:08:01 <bxc_> parcs: not really what i'm after: i want a showable symbol (eg a counter or sometihng like it) for embedding as object IDs in som ejson
07:08:25 <bxc_> parcs: i suppose i could use the hash.
07:08:33 <arkeet> @pl \key -> key <$ guard (isControl key)
07:08:33 <lambdabot> ap (<$) (guard . isControl)
07:08:49 <vlatkoB> arkeet: I meant is there a some syntax that will allow to write it as fmap f (d x) = d (fx)?
07:08:55 <arkeet> vlatkoB: no
07:09:10 <arkeet> vlatkoB: what you wrote is the best you can do without any extensions.
07:09:20 <vlatkoB> Thanks, I'll take a look at -XDeriveFunctor.
07:10:05 <__ghjk> > maybe "should you?" (\x -> if x "no" else "yes") (Just False)
07:10:06 <lambdabot>   <hint>:1:38: parse error on input `else'
07:10:08 <ski_> vlatkoB : one alternative is to factor the definition into `data T a = T SOC a' and `data SOC = S | O | C'
07:10:12 <__ghjk> > maybe "should you?" (\x -> if x "no"; else "yes") (Just False)
07:10:14 <lambdabot>   <hint>:1:39: parse error on input `else'
07:10:35 <typoclass> __ghjk: lambdabot is also available privately by doing "/query lambdabot"
07:10:40 <ski_> __ghjk : you're missing a `then'
07:11:00 <__ghjk> > maybe "should you?" (\x -> if x then "no" else "yes") (Just False)
07:11:02 <lambdabot>   "yes"
07:13:00 <arkeet> vlatkoB: ok sure, what ski_ said. and then maybe you could just use (SOC,a) instead of T a
07:13:55 <__ghjk> seems bot is tired
07:15:18 <notdan> Hm, I am using way too much Data.Map maps in this project...
07:15:34 <notdan> Albeit I wanted to use Haskell functions, but I need to Ord them
07:15:36 <notdan> damn
07:16:12 <vlatkoB> Hm, instance Functor (SOC,a) where
07:16:12 <vlatkoB>   fmap f (SOC x) = SOC (f x)
07:16:12 <vlatkoB>  is not good. How to write it
07:16:22 <mauke> write what?
07:17:00 <notdan> vlatkoB: check your types
07:17:01 <vlatkoB> The Functor with ski_'s suggestion
07:17:32 <notdan> It's ought to be : fmap f (SOC x, a) = ..
07:17:42 <notdan> Since you are writing a functor instance for a pair
07:18:24 <mauke> notdan: what exactly is a pair of kind * -> *?
07:18:44 <atriq> data Pair a = Pair a a?
07:19:27 <tharper> data Pair a = Pair Int a?
07:20:40 <vlatkoB> Uf, that's too much for me now. Just wanted to see if it is possible to write it shorter. I'll have to study this suggestions of yours. Thanks.
07:20:44 <notdan> mauke: no idea
07:20:56 <notdan> mauke: I don't understand what vlatkoB is trying to do frankly
07:21:08 <mauke> me neither, which is why I asked
07:21:28 <mauke> vlatkoB: what is SOC?
07:21:44 <vlatkoB> I thought there is a syntax to write the three functions of fmap (that look very similar) in a shorter way. See a page up.
07:21:47 <ski_> vlatkoB : istr, there is already a `Functor (w,)' instance somewhere -- perhaps in `Control.Monad.Writer' or `Control.Monad.Instances' ?
07:22:31 <mauke> vlatkoB: a page up is mostly joins and quits
07:22:35 <vlatkoB> I'm still learning and this is my first functor, so I'd like to understand it, not so much just to solve it. :-).
07:23:00 <ski_> seems to be `Control.Monad.Instances', yes
07:24:07 <vlatkoB> mauke: I meant this: Is there a way to write
07:24:07 <vlatkoB> instance Functor T where
07:24:07 <vlatkoB>   fmap f (TS x) = TS (f x)
07:24:07 <vlatkoB> <vlatkoB>   fmap f (TO x) = TO (f x)
07:24:07 <vlatkoB>   fmap f (TC x) = TC (f x)
07:24:09 <vlatkoB> in a shorter form?
07:24:10 <ski_> vlatkoB : however, you could write it yourself for `Functor T', given my alternative definition of it in terms of `SOC' above ..
07:24:16 <mauke> vlatkoB: what is T?
07:24:35 <mauke> vlatkoB: and what does it have to do with (SOC, a)?
07:24:44 <ski_> presumably vlatkoB's original definition is something like `data T a = TS a | TO a | TC a'
07:25:08 <vlatkoB> data T a =  TS { tSingle :: a }
07:25:09 <vlatkoB>           | TO { tOpen   :: a }
07:25:09 <vlatkoB>           | TC { tClose  :: a }
07:25:14 * ski_ nods
07:25:30 <mauke> ok, and now the interesting bit
07:25:46 <ski_> <ski_> vlatkoB : one alternative is to factor the definition into `data T a = T SOC a' and `data SOC = S | O | C'
07:25:52 <ski_> (for context)
07:26:32 <mauke> instance Functor T where fmap f (T c x) = T c (f x)
07:31:26 <vlatkoB> mauke, ski_: Yes, that compiles. Thanks.
07:32:14 <no-n> when is the id function useful?
07:32:44 <elliott> no-n: as an argument to higher-order functions
07:32:56 <no-n> ok
07:33:05 <tac> no-n: it's mostly useful for completeness' sake
07:33:20 <elliott> also for stating laws
07:33:28 <tac> right
07:33:33 <tac> id is very important theoretically
07:34:14 <mauke> no-n: when is the number 0 useful?
07:34:17 <typoclass> > let f b = map (if b then pred else id) [0..4] in f True -- no-n, here is an example. it's a bit far-fetched, but i hope not too much
07:34:19 <lambdabot>   [-1,0,1,2,3]
07:35:21 <no-n> ok :)
07:49:30 <Rc43> Hi, guys.
07:49:53 <ChongLi> hi
07:51:03 <Halite> umm
07:51:04 <lambdabot> Halite: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:52:17 <Halite> @
07:52:24 <Halite> @help
07:52:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:53:12 <Halite> in a data type decleration, I need a state with an object parameter that is of ANY object WITH properties
07:53:36 <Halite> s-properties-states
07:53:52 <merijn> I'm not exactly sure what that means?
07:54:08 <Halite> something like State 4 or State "hi"
07:54:33 <Halite> so a data type state with a parameter of any object
07:54:58 <Halite> data ... = State Object ...
07:55:01 <geekosaur> "object" is a red flag...
07:55:13 <ski_> should the type of `State "hi"' include `String' ?
07:55:26 <Halite> yes
07:55:56 <Halite> but type parameters seem to only carry a type if I remember correctly
07:56:03 <ski_> surely something is wrong with `data State a = MkState a' -- so what is it ?
07:56:21 <Halite> it was my brain gone nuts
08:01:36 <plhk> how is (<|>) pronounced?
08:02:36 <ramses_> plhk: "or" ?
08:02:49 <ski_> perhaps "or" or "alternatively", or something like that ?
08:03:01 <elliott> or "else"
08:03:25 <ramses_> plhk: just pronounce it "<|>" ;)
08:03:26 <Halite> "or else"
08:04:26 <Sculptor> plhk, is that haskell or an emoticon
08:04:40 <ramses_> :t (<|>)
08:04:42 <lambdabot> Alternative f => f a -> f a -> f a
08:04:58 <ramses_> Sculptor: it's haskell ^^
08:05:39 <Sculptor> apparently
08:12:40 <Breadmonster> Umm, why are Haskell lists singly linked?
08:12:52 <ams_> which crypto library is fastest in haskell?
08:13:01 <Breadmonster> And how do you implement a doubly linked list?
08:13:05 <jesyspa> Breadmonster: Well, it means you can reuse the tail, for one.
08:13:11 <quchen> Breadmonster: Well, it's an element and another list, which means singly linked
08:13:11 <osfameron> Breadmonster: zippers
08:13:24 <elliott> doubly linked lists don't make as much sense in an immutable context
08:13:25 <ChongLi> Breadmonster: because singly-linked lists are far more common and generally useful
08:13:47 <elliott> not only are they hard to work with, but they'd do badly at the things haskell lists are used for most
08:13:50 <ChongLi> and doubly linked lists are far less efficient
08:13:51 <Breadmonster> Yeah, but what I meant was, ++ takes ages.
08:13:53 <elliott> (e.g. "streaming" control structures)
08:13:56 <quchen> Breadmonster: There's a section on how to create a circular doubly-linked list here: http://www.haskell.org/haskellwiki/Tying_the_Knot
08:14:14 <Breadmonster> elliott: What are Haskell lists used for?
08:14:16 <ChongLi> Breadmonster: if you're doing a lot of appending, perhaps use another data structure with constant append?
08:14:28 <osfameron> generally speaking, you don't want a doubly linked list
08:14:29 <Breadmonster> jesyspa: What do you mean by reusing the tail?
08:14:32 <ChongLi> Haskell lists are as much of a control structure
08:14:32 <elliott> Breadmonster: well, in some ways lists are one of haskell's most important control structures
08:14:37 <Breadmonster> How?
08:14:38 <ams_> which crypto library is fastest in haskell?
08:14:41 <elliott> produced and processed incrementally so they can be GC'd as you go
08:14:48 <elliott> (or even eliminated entirely)
08:14:50 <mauke> Breadmonster: (++) on a doubly linked list takes forever
08:14:57 <elliott> that doesn't work if you have pointers back
08:15:05 <ChongLi> Breadmonster: Haskell's lists are actually what other languages (such as Scheme) call streams
08:15:07 <Breadmonster> ChongLi: Umm, haven't got to that part of LYAH yet.
08:15:13 <Breadmonster> Okay.
08:15:31 <Breadmonster> ChongLi: I was referring to the other data structures, btw.
08:15:32 <jesyspa> Breadmonster: If you have the list x = [1,2,3,4,5] and do y = 0:x and z = 1:x, y and x can both share a pointer to x.
08:16:00 <ChongLi> Breadmonster: if you want to really understand streams, I can show you a lecture from SICP on them
08:16:03 <Breadmonster> mauke: Isn't appending in a doubly linked list done in constant time?
08:16:08 <ChongLi> then you'll see how beautiful and powerful they are
08:16:10 <Breadmonster> ChongLi: What chapter?
08:16:10 <mauke> Breadmonster: no
08:16:15 <companion_cube> Breadmonster: with mutation
08:16:23 <ChongLi> http://mitpress.mit.edu/sicp/full-text/sicp/book/node69.html
08:16:28 <Iceland_jack> Breadmonster: You can try Data.Sequence if you need faster data structures, but I suggest reading on first
08:16:41 <ChongLi> Breadmonster: https://www.youtube.com/watch?v=RcPhdoL8RcE
08:16:42 <mauke> Breadmonster: the first problem is that a doubly linked list has an infinite number of nodes
08:16:45 <Breadmonster> Iceland_jack: Thank you :)
08:16:48 <ChongLi> here's the demonstration of a stream machine :)
08:16:59 <Breadmonster> mauke: How does that work?
08:17:03 <Breadmonster> ChongLi: Thanks :)
08:17:06 <mauke> Breadmonster: if all you need is a fast list builder, have a look at dlist
08:17:11 <Breadmonster> Haskell has some of the best community ever.
08:17:19 <Breadmonster> I really appreciate it guys.
08:17:26 <Breadmonster> Now all I need is a job at Jane Street.
08:17:40 <fizbin> Yeah, the haskell community is up there with the non-rails part of the ruby community.
08:17:53 <Iceland_jack> heh
08:17:53 <elliott> you know Jane Street use OCaml, right? :P
08:18:10 <mauke> Breadmonster: imagine a list containing A and B. since A points to B and B points to A, you can forever traverse the list as A->B->A->B->A->B->...
08:19:39 <fizbin> I once wrote a haskell program that had a structure that wrapped two lists that I treated something like a doubly linked list.
08:19:58 <ChongLi> the Haskell list (or stream) really is the ideal general structure for control and simple data
08:20:07 <ChongLi> it's very simply implemented
08:20:11 <Breadmonster> elliott: I don't see how that matters.
08:20:19 <Breadmonster> ChongLi: Okay, that was mind opening.
08:20:22 <elliott> just checking
08:20:29 <Breadmonster> So you can apply several maps and filters with one pass?
08:20:41 <ChongLi> Breadmonster: yes, by composing them together
08:20:44 <elliott> usually you don't make a "pass" all at once at all
08:20:54 <ab9rf> fizbin: there's a nonrails part of the ruby community? :)\
08:20:55 <elliott> you do all the operations you have piled up element by element as you go through consuming the list
08:20:58 <fizbin> And with that structure, updates were O(1),  if you only wanted to change the element being pointed to by the "head".
08:20:58 <Breadmonster> elliott: In theory.
08:21:18 <fizbin> ab9rf: There is. They're mostly on the ruby-talk list, though.
08:21:19 <ChongLi> if you have some list which has a billion elements and the first step of your "pipeline" takes the first 10 elements
08:21:31 <ChongLi> the rest of the pipeline only has to deal with those 10 elements
08:21:44 <ChongLi> indeed, you could use an infinite list
08:21:58 <ab9rf> fizbin: i am vaguely joking, since i've actually done a fair bit of ruby programming but haven't touched rails at all
08:22:03 <mauke> fizbin: oh, a zipper
08:22:08 <elliott> Breadmonster: in practice
08:22:34 <fizbin> mauke: Yeah, I suppose it was something like that. I didn't know about zippers at the time.
08:22:50 <fizbin> It was for a turing machine simulation and represented the "tape".
08:23:32 <ski_> sounds like a zipper
08:23:47 <ChongLi> Breadmonster: I recommend going through that whole chapter on stream processing
08:24:00 <Breadmonster> Do I have to finish LYAH before I can go through Real World Haskell?
08:24:06 <atriq> No
08:24:14 * Kinnison used both in conjunction
08:24:15 <atriq> They're completely separate
08:24:21 <ab9rf> Breadmonster: no, you can do whatever you want
08:24:26 <ab9rf> Breadmonster: there is no monster at the end of the book
08:24:28 <Kinnison> I read through RWH almost in-order and used LYAH to explain stuff to me
08:24:29 <Kinnison> :-)
08:24:32 <Breadmonster> What's recommended?
08:24:38 <Breadmonster> Alright.
08:24:41 <ChongLi> Breadmonster: watch this example of the 8 queens puzzle: https://www.youtube.com/watch?v=skd-nyVyzBQ
08:24:59 <fizbin> I went through RWH after just reading "A Gentle Introduction…". I know some people who used RWH with no prior Haskell experience.
08:25:04 <Breadmonster> Damn, I wish I was at MIT.
08:25:25 <fizbin> Breadmonster: No, you don't. Not really.
08:25:39 <Breadmonster> fizbin: Why do you say that?
08:25:45 <ChongLi> these lectures were actually given at HP, I believe
08:25:46 <atriq> Wishing you had the ability to apply to MIT, that's another thing
08:25:52 <fizbin> Among other things, they don't teach scheme as the intro course anymore.
08:26:01 <atriq> Wishing you've already graduated MIT is pretty good, too
08:26:17 <Breadmonster> atriq: I would've applied, but they're too expensive.
08:26:19 <ChongLi> wish you were at MIT in the 80s :)
08:26:22 <fizbin> The course that used to use SICP now uses python.
08:26:24 <Breadmonster> So I'm planning to do my Masters there.
08:26:45 <djahandarie> MIT is absolutely useless for this sort of stuff.
08:26:45 <Breadmonster> wait, do you have to do FP to get a CS degree?
08:27:11 <atriq> No, but at most places you probably will at some point, I think
08:27:12 <djahandarie> Only guy who does anything even closely related there is Adam Chlipala
08:27:23 <djahandarie> s/closely/remotely/
08:27:38 <fizbin> MIT also has a reputation for chewing people up; given the caliber of entrants to their various programs, they just don't produce as many graduates as they should.
08:27:39 <Breadmonster> Also, can someone please explain what the difference between foldl and foldr is to me?
08:27:53 <fizbin> :t x
08:27:54 <lambdabot>     Ambiguous occurrence `x'
08:27:54 <lambdabot>     It could refer to either `L.x', defined at <local>:5:1
08:27:54 <lambdabot>                           or `Debug.SimpleReflect.x',
08:27:57 <Halite> MIT is great
08:28:02 <fizbin> :t j
08:28:04 <lambdabot> Expr
08:28:05 <elliott> > foldr f z [a,b,c,d]
08:28:07 <lambdabot>   f a (f b (f c (f d z)))
08:28:07 * djahandarie would recommend CMU or UPenn if you want to do functional programming
08:28:08 <elliott> > foldl f z [a,b,c,d]
08:28:10 <lambdabot>   f (f (f (f z a) b) c) d
08:28:10 <Halite> :t ban
08:28:11 <lambdabot>     Not in scope: `ban'
08:28:11 <lambdabot>     Perhaps you meant `tan' (imported from Prelude)
08:28:15 <Halite> :t tan
08:28:16 <lambdabot> Floating a => a -> a
08:28:24 <Halite> > tan 3.5
08:28:26 <lambdabot>   0.3745856401585947
08:28:26 <donri> :t L.x
08:28:28 <lambdabot> Num a => a
08:28:35 <donri> > L.x
08:28:35 <elliott> Breadmonster: ^ is a demonstration
08:28:37 <lambdabot>   5
08:28:43 <donri> is that a @let?
08:28:47 <ski_> > foldl (flip f) z [a,b,c,d]
08:28:49 <lambdabot>   f d (f c (f b (f a z)))
08:28:49 <ChongLi> everyone spamming lambdabot all of a sudden
08:28:58 <Halite> 3.5 says "I like having a nice tan!" and tans into 0.3745856401585947
08:29:04 <ski_> donri : probably
08:29:14 <elliott> Breadmonster: generally you want to use foldr or foldl'. the latter for "strict" stuff like when you are accumulating a standard number type
08:29:18 <elliott> foldl itself is rarely useful
08:29:22 <Breadmonster> djahandarie: I would love to, but UPenn rejected me; I think it's because I asked for financial aid, being an international.
08:29:34 <xenon> I think LYAH explained on this nicely :)
08:29:45 <mauke> @undefine
08:29:47 <mauke> > x
08:29:49 <lambdabot>   x
08:30:51 <Breadmonster> does Haskell support function overloading?
08:30:58 <elliott> with typeclasses, sure
08:31:02 <elliott> no ad-hoc overloading
08:31:13 <elliott> (though you can make ad-hoc typeclasses, if you'd like)
08:31:17 <Breadmonster> Oh, okay.
08:31:37 <ski_> `read' is overloaded
08:31:39 <ski_> @type read
08:31:40 <lambdabot> Read a => String -> a
08:31:43 <ChongLi> type classes are extremely powerful in conjunction with the rest of Haskell's type system
08:31:46 <ski_> > not (read "False")
08:31:47 <lambdabot>   True
08:31:58 <ski_> > 2 * read "34"
08:31:59 <lambdabot>   68
08:32:17 <ski_> > 2 * read "False"
08:32:18 <lambdabot>   *Exception: Prelude.read: no parse
08:33:20 <ChongLi> > reverse $ read "[1,2,3]" :: [Int]
08:33:22 <lambdabot>   [3,2,1]
08:36:01 <Breadmonster> Has anyone here worked with Mathematica?
08:36:01 <Breadmonster> because there's a particular Mathematica feature that I want to implement in Haskell.
08:36:01 <Breadmonster> Mathematica's flatten command.
08:36:01 <ski_> istr lambdabot had an interface to it at some point ..
08:36:01 <parcs> Breadmonster: what does flatten do?
08:36:01 <djahandarie> > map (*2) $ read "[1,2,3]"
08:36:01 <lambdabot>   [2,4,6]
08:36:01 <djahandarie> > map (*2) $ read "[1..]"
08:36:02 <lambdabot>   *Exception: Prelude.read: no parse
08:36:02 <ChongLi> > concat [[1,2,3],[5,3]]
08:36:02 <lambdabot>   [1,2,3,5,3]
08:36:02 <djahandarie> Hehe
08:36:02 <Breadmonster> parcs: Takes a list of lists and turns them into one list
08:36:02 <ab9rf> writing  flatten in haskell is a fairly common assignment
08:36:02 <ChongLi> Breadmonster: like concat?
08:36:02 <ski_> @type concat
08:36:02 <lambdabot> [[a]] -> [a]
08:36:02 * hackagebot uuagc 0.9.42.3 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.42.3 (JeroenBransen)
08:36:02 <ab9rf> the main problem with it is that haskell lists are homogenous, while mathematica lists are heterogenous
08:36:02 <Breadmonster> ChongLi: Yeah, but can we extend that to nested lists of any depth?
08:36:02 <ski_> UUAG !
08:36:08 <jesyspa> Yay, new UUAG. :D
08:36:59 <no-n> is there a heterogenous alternative to lists in haskell?
08:37:00 <parcs> Breadmonster: yeah, with type classes
08:37:00 <ChongLi> no-n: yes, typles
08:37:00 <ski_> no-n : perhaps you're looking for tuples ?
08:37:00 <ChongLi> tuples
08:37:00 <ChongLi> :)
08:37:00 <no-n> I guess :p
08:37:10 <ab9rf> except that a 2-tuple and a 3-tuple are not of the same type
08:37:15 <no-n> yeah
08:37:20 <merijn> no-n: Why would you want a heterogeneous list?
08:37:23 --- mode: ChanServ set +o mauke
08:37:23 --- mode: mauke set +b *!*@unaffiliated/octagonfly
08:37:27 <no-n> I don't know
08:37:33 --- kick: Halite was kicked by mauke (multiple ban evasion)
08:37:33 <merijn> Wanting those is usually a design flaw :)
08:37:36 <ab9rf> you typically don't
08:37:45 <ski_> no-n : if there's some structured pattern to the heterogenicity, you might be able to define a type for it
08:38:00 <ChongLi> no-n: what operations can you perform on something which could be any type at all?
08:38:06 <no-n> yeah, I suppose. it's not something I need to do, so it was kind of an empty question.
08:38:07 <ChongLi> identity
08:38:07 <ab9rf> in many many languages, heterogenous lists are used as ad hoc structured data types
08:38:19 <no-n> good point, ChongLi
08:38:20 <ChongLi> that's basically all I know of
08:38:29 <ab9rf> because the language either does not support them, or because programmers are too lazy to use the language's constructs for structured data
08:38:38 <ski_> e.g. `data List f a = Nil | Cons a (List f (f a))' would mean that `List f a' describes a "list" of elements of types `a',`f a',`f (f a)',`f (f (f a))',&c.
08:39:21 <ChongLi> no-n: I think what people really want when they say they want heterogeneous lists is dynamic typing
08:39:31 <ab9rf> ChongLi: usually
08:39:33 --- mode: mauke set -o mauke
08:39:49 <ski_> no-n : sometimes wrapping the elements in data constructors of an auxiliary type (maybe even a GADT) is sensible
08:41:30 <ChongLi> if you really, really need dynamic typing (and this is rare) you can accomplish it with Data.Typeable
08:41:31 <Breadmonster> ab9rf: Despite all that, Python lists are pretty amazing.
08:41:48 <Breadmonster> ChongLi: How do you do typecasts in Haskell?
08:41:56 <ab9rf> Breadmonster: no, they're not
08:42:05 <ski_> Breadmonster : normally you don't
08:42:11 <lispy> ?hoogle cast
08:42:11 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
08:42:11 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
08:42:11 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
08:42:21 <lispy> Breadmonster: ^^
08:43:00 <Breadmonster> Fine.
08:43:18 <ChongLi> Breadmonster: if you really want to see how powerful Haskell lists are, check out the list monad
08:43:22 <ski_> > cast False :: Maybe Bool
08:43:24 <lambdabot>   Just False
08:43:26 <ski_> > cast False :: Maybe Integer
08:43:28 <lambdabot>   Nothing
08:44:49 <GREENBIBOY> http://www.reddit.com/r/spanishporn/comments/1bkvxq/spanish_girl_fucked_hard/
08:45:24 <ChongLi> is it just me or does #haskell get more trolls than most places?
08:45:40 <atriq> ChongLi, we're a big channel, and we're friendly
08:46:08 <parcs> this channel is near the top of freenode's channel list
08:46:18 <ChongLi> parcs: ahh, that's odd
08:46:21 <Breadmonster> ChongLi: Umm, does Data.List.group only work for sorted lists?
08:46:23 <elliott> ChongLi: it's one of the top five channels on freenode in terms of users or thereabouts, so it gets a lot of stuff
08:46:35 <`^_^v> why don't you set +s so it wont be
08:46:36 <Kinnison> Also, we made twitter for one of our trollings the other day
08:46:37 <parcs> ChongLi: well it's ordered by channel size, and #haskell is one of the largest
08:46:52 <ChongLi> ah, I never would've guessed that!
08:46:55 <Kinnison> https://twitter.com/domenic/status/319339660012834817
08:46:55 <ab9rf> `^_^v: because we're friendly people and aren't trying to hide from the world :)
08:47:04 <ChongLi> I've never looked at any of the channel lists
08:47:17 <`^_^v> do you really think people are going to look at the status list then choose to learn haskell based on its position or something?
08:47:27 <ChongLi> I just came here directly because I'm interested in Haskell :)
08:47:28 <`^_^v> people that want to chat about haskell figure out that there's a #haskell channel
08:47:54 <ab9rf> i admit that i didn't look to see if there was a haskell channel before coming here
08:48:02 <ab9rf> but i've been on freenode since 1999
08:48:02 <parcs> newtype NestedList a = NestedList (Either [a] (NestedList [NestedList a]))
08:48:16 <elliott> I don't think there's any point to +s, the amount of spam we get isn't disruptive and they're always dealt with quickly (often at the freenode level)
08:48:20 <ab9rf> although it wasn't called freenode then
08:48:21 <Clint> i'm continually amazed that anyone looks at channel lists
08:48:26 <ChongLi> I don't mind the trolls so much; I think it's really amusing when we convert them
08:48:35 <Breadmonster> ChongLi: Umm, does Data.List.group only work for sorted lists?
08:48:43 <glguy> #haskell-ops is the best place to discuss spam and responses to it
08:48:47 <ab9rf> elliott: in a way we're acting as one of freenode's honeypots
08:48:54 <atriq> Breadmonster, it groups consecutively
08:49:06 <Breadmonster> atriq: meaning? Several passes?
08:49:12 <atriq> Single pass
08:49:16 <ChongLi> > group "Mississippi"
08:49:18 <lambdabot>   ["M","i","ss","i","ss","i","pp","i"]
08:49:23 <ab9rf> Breadmonster: it groups based on the order present
08:49:30 <atriq> It only groups consecutive letters
08:49:36 <parcs> > [[True,False],True]
08:49:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
08:49:38 <lambdabot>              with actual ty...
08:49:41 <ChongLi> so can you say the string "Mississippi" is sorted? I guess so
08:49:44 <Kinnison> > group . sort "Mississippi"
08:49:46 <lambdabot>   Couldn't match expected type `a0 -> [a1]' with actual type `[a2]'
08:49:49 <Kinnison> oopsie
08:49:53 <ab9rf> parentheses :)
08:49:58 <Kinnison> > group . sort $ "Mississippi"
08:49:59 <lambdabot>   ["M","iiii","pp","ssss"]
08:50:13 <Breadmonster> Kinnison: Ah, that was what I was looking for.
08:50:19 * Kinnison is trying to get used to dotting and dollaring
08:50:34 <parcs> type NestedList = Free [] ?
08:50:37 <Iceland_jack> > group (sort "Mississippi")
08:50:38 <lambdabot>   ["M","iiii","pp","ssss"]
08:50:43 <Kinnison> Breadmonster: there's probably a more efficient way to do it
08:51:02 <ChongLi> the key to remembering how to compose functions this way is to understand that whitespace has the highest operator precedence
08:51:02 <Kinnison> Breadmonster: but 'groupsorted = group . sort' might be enough for you :-)
08:51:35 * Kinnison had to do the id is $ learning curve a couple of days ago
08:51:36 <Kinnison> that was fun
08:53:02 <Breadmonster> And how do you curry a function with more than two arguments?
08:53:09 <ab9rf> i found some old code of mine that does map ( f . ($x) )
08:53:17 <elliott> Breadmonster: every function has one argument. so it depends on how you want to do it
08:53:24 <elliott> (do you mean uncurry?)
08:53:24 <ab9rf> i don't know why i used a $ section there or how i got to that state of the code
08:53:26 <elliott> :t uncurry . uncurry
08:53:28 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
08:53:32 <elliott> :t \f (a,b,c) -> f a b c
08:53:33 <lambdabot> (t1 -> t2 -> t3 -> t) -> (t1, t2, t3) -> t
08:53:49 <Breadmonster> elliott: For example, if I wanted to pass a function that divides a number by 3, say, then I could do something like this.
08:54:04 <Breadmonster> func = flip . div 3
08:54:07 <ab9rf> :t \x -> ($x)
08:54:09 <lambdabot> a -> (a -> b) -> b
08:54:32 <elliott> Breadmonster: sure, or func = (`div` 3)
08:54:34 <Breadmonster> elliott: What if the function has more than two arguemnts?
08:54:44 <elliott> that's partial application, though, not currying
08:54:56 <elliott> Breadmonster: well, func = f a b c means that func d = f a b c d
08:54:59 <Breadmonster> Sorry, I always confuse the two.
08:55:08 <elliott> if you want func x = f a x b for some a and b, then the best way is simply to write that
08:55:15 <elliott> but you could also do func = flip (f a) b or something ugly like that
08:55:19 <Kinnison> Other languages call partial application currying
08:55:21 <Kinnison> it's quite annoying
08:55:30 <Breadmonster> elliott: Oh, okay, thank you, that's exactly what I was I looking for.
08:58:12 <Breadmonster> Guys, how does Haskell store expressions?
08:58:19 <Breadmonster> Because I'm going through SICP.
08:58:44 <ab9rf> store?
08:58:50 <Breadmonster> And lazy evaluation is easy in LISP.
08:58:59 <ab9rf> Breadmonster: lazy evaluation is the default in haskell
08:58:59 <Breadmonster> ab9rf: Okay, listen to this and correct me if I'm wrong.
08:59:16 <ChongLi> yeah, it's even easier in Haskell :)
08:59:29 <ab9rf> it's not merely easy, it requires effort to avoid :)
08:59:32 <Breadmonster> In C++, say, let's presume I have a function int add (int a, int b) { return a + b; }
08:59:48 <elliott> Breadmonster: it's best to ask about a specific implementation, like GHC
09:00:02 <elliott> Haskell doesn't specify how to implement the language on a real computer, it just specifies what things should evaluate to
09:00:10 <ab9rf> the haskell specification doesn't mandate any particular represention at the machine level.
09:00:31 <ab9rf> it could be stored as gnomic thoughts in the ether :)
09:00:52 <Breadmonster> Ah, that's what I meant.
09:00:54 <Kinnison> gnomic thoughts are a tad monolithic
09:00:55 <Breadmonster> Okay, how does GHC do it?
09:01:09 <sm> http://ejohn.org/blog/asmjs-javascript-compile-target/ is interesting.. doesn't haskell compile to llvm too ?
09:01:30 <elliott> Breadmonster: well, your question still isn't very clear to me :)
09:01:43 <ab9rf> sm: there are haskell compilers that target llvm, yes
09:02:13 <Breadmonster> elliott: Can I please PM?
09:02:26 <fryguybob> Breadmonster: If you are interested in what representation GHC compiles to there are a series of interesting papers that you can read.
09:02:28 <sm> then we're only an emscripten hop and skip away from haskell in the browser.. ?
09:02:38 <ChongLi> sm: not exactly :)
09:02:44 <sm> boo :)
09:02:46 <Breadmonster> fryguybob: I'm just done with high school, will that fly over my head?
09:02:50 <ab9rf> sm: there's already haskell compilers that generate javascript.
09:03:01 <merijn> mauke: I've already seen an FRP game in haskell compiled to javascript that runs in the browser
09:03:05 <merijn> err
09:03:07 <sm> indeed, but this way sounds faster
09:03:07 <merijn> s/mauke/sm
09:03:22 <fryguybob> Breadmonster: I can't make that judgement for you.  But I can give you links to papers.
09:03:26 <ChongLi> sm: it sure does, doesn't it :)
09:03:27 <elliott> Breadmonster: why not ask the channel?
09:03:39 <elliott> there are people better at explaining things than me, after all :p
09:03:43 <Breadmonster> Because it's a few successive messages that will get lost.
09:03:53 <ChongLi> Breadmonster: I have a large scrollback buffer
09:03:55 <ab9rf> Breadmonster: haskell questions, even massively abtruse ones, are not off topic
09:04:15 <djahandarie> Anything that makes me look bad is off-topic
09:04:25 <Breadmonster> Okay, fine. In C++ when you call a function, like I said, int add (int x) { return x + 1; }, the computer allocates 4 bytes for the integer x.
09:04:32 <ChongLi> sm: the issue is the GHC runtime
09:04:37 <Breadmonster> So whatever expression is passed, evaluates to an integer.
09:04:48 <ab9rf> Breadmonster: i'm afraid that the answer in GHC is "it's complicated" :)
09:04:51 <Breadmonster> and is then stored to wherever x refers to.
09:04:54 <fryguybob> @where stg -- Breadmonster
09:04:58 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
09:05:02 <Breadmonster> ab9rf: Can you explain further?
09:05:28 <elliott> that isn't necessarily true for C++, I don't think
09:05:30 <ab9rf> Breadmonster: not briefly, and i would urge that you read the papers referenced above
09:05:45 <elliott> (though I don't really know how closely C++ specifies low-level operational details like that)
09:05:49 <Breadmonster> That just flew way over my head.
09:05:54 <ab9rf> elliott: no, it's not.  parameters are often passed in registers although you could claim that that's a form of "storage allocation"
09:06:08 <Breadmonster> elliott: True, but that's the idea you get.
09:06:19 <ab9rf> elliott: the C++ standard does nto mandate any particular call frame strategy
09:06:40 <elliott> ab9rf: right, fair enough
09:06:51 <ab9rf> elliott: parameters can be in register frames, stack frames, heap frames, any combination thereof, or indeed anything else that might be dreamt of that has the same semantic behavior
09:06:58 <elliott> ab9rf: I was wondering whether it had the as-if rule that C does (which would mean it could skip having a standard "memory" at all, in theory)
09:07:01 <Breadmonster> ab9rf: Judging from that abstract, it's going to fly over my head.
09:07:14 <elliott> Breadmonster: ezyang has a nice series of posts on haskell evaluation
09:07:31 <elliott> http://blog.ezyang.com/2011/04/the-haskell-heap/
09:07:39 <ab9rf> elliott: it's entirely permissible for a global optimizer to detect that a parameter is unused and eliminate it from generated code.
09:08:07 <ab9rf> elliott: not to mention compilers routinely chop code into pieces and inline the pieces
09:08:30 <ab9rf> elliott: trying to decompile modern C++-generated code is a royal pain because of this.
09:08:48 <elliott> right
09:08:57 <ab9rf> elliott: i've seen entire classes disappear from C++ code because of global optimization and inlining
09:09:13 <magiknapkin> I have a question about data types.
09:09:30 <tac> @quote type
09:09:51 <tac> where's lambdabot?? :(
09:10:07 <fryguybob> Breadmonster: If you want an intuition for what goes on when GHC code is run you can think of  let x = ...  as allocation and  case x of ...  as evaluation.
09:10:59 <ChongLi> Breadmonster: try doing ghc -ddump simpl
09:11:02 <Breadmonster> fryguybob: My question was actually much simpler. How is an expression passed as a function parameter stored until it is required to be evaluated?
09:11:04 <ChongLi> when compiling your program
09:11:12 <ab9rf> Breadmonster: as a thunk
09:11:20 <ChongLi> to see how your program is dramatically transformed
09:11:21 <Breadmonster> fryguybob: Now that I've learned how to phrase it properly.
09:11:29 <Breadmonster> ab9rf: Okay, what's a thunk?
09:11:34 <ChongLi> -ddump-simpl
09:11:35 <ChongLi> rather
09:11:43 <fryguybob> Breadmonster: Heap objects.
09:11:43 <elliott> you can pattern-match in let and not pattern-match in case
09:11:45 <ab9rf> Breadmonster: an unevaluated expression :)
09:11:53 <elliott> Breadmonster: did you see that ezyang link?
09:11:56 <elliott> it explains thunks etc. quite nicely IMO
09:12:04 <Breadmonster> ab9rf: So is it stored as a string or what?
09:12:10 <ab9rf> Breadmonster: no, it's a thunk.
09:12:14 <Breadmonster> elliott: I did, and hence I asked a more specific question.
09:12:23 <ab9rf> Breadmonster: the exact machine representation of a thunk is implementation-dependent
09:12:38 <Breadmonster> ab9rf: Okay, I'm talking abotu GHC.
09:12:45 <ab9rf> Breadmonster: i'm not an expert on GHC internals
09:12:49 <tac> > 1 + 1
09:13:02 <tac> @quote
09:13:21 <ChongLi> Breadmonster: what I think you're beginning to learn is that Haskell is a very high level language
09:13:40 <ChongLi> what code you write can often be extremely different from what the machine actually runs
09:13:40 <xenon> I'm new on Haskell, so, are every expression in Haskell lazy?
09:13:48 <xenon> (is)
09:13:49 <jesyspa> Breadmonster: Here is how I was taught it, but I don't know how far it is from the way things are done in practice: http://www.cs.uu.nl/wiki/pub/Cco/CourseResources/new_implementation_technique.pdf
09:13:50 <ab9rf> xenon: basically
09:13:52 <ab9rf> xenon: yes
09:14:01 <jesyspa> s/was/am being/
09:14:19 <xenon> ab9rf: thanks :D
09:14:25 <Clint> except expressions aren't lazy
09:14:28 <ab9rf> Breadmonster: you could probably store thunks as strings, but doing so would be grostesquely inefficient
09:14:44 <elliott> Breadmonster: well, a thunk is just what the post says: a value that has yet to be evaluated
09:14:56 <elliott> when you say "f (x+1)", f gets a thunk representing (x+1), and may or may not evaluate that thunk
09:15:19 <ab9rf> back when i took computer science, a thunk was an encapsulation of code that might (or might not) be used later
09:15:29 <fryguybob> Breadmonster: ezyang's blog explains it at an easy to understand level.
09:15:39 <fryguybob> Breadmonster: for details http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
09:15:51 <elliott> Breadmonster: the second post goes into more details as to exactly what a thunk is, etc.
09:16:16 <ab9rf> when you evaluated a thunk, it would be executed, and whatever it did would happen and its vlaue (if any) would be returned
09:16:48 <levi> The encapsulation has to include both a reference to the code and to its environment, which contains references to where the free variables in its expression were lexically bound.
09:17:16 <ab9rf> there was a subtle difference between a thunk and a closure that i no longer remember, it having been now over two decades
09:17:32 <levi> But once a thunk is evaluated, it can just be a reference to the value.
09:17:54 <ab9rf> levi: assuming the thunk is pure, at last
09:18:03 <xenon> is it called memoizing?
09:18:38 <levi> Since, in a purely functional language, it has to always evaluate to the same value. Any impure constructs might not be able to have that optimization applied, of course.
09:19:04 <levi> Presumably the type system is able to keep track of that.
09:19:36 <elliott> xenon: "sharing"
09:19:49 <elliott> memoisation is generally about functions (whose results are not automatically memoised by GHC)
09:20:19 <levi> xenon: Memoizing is related, but not quite the same thing.
09:20:48 <accidus> Who came up with the generalisation of the Writer monad to an arbitrary monoid?
09:21:32 <Breadmonster> Okay, fine, thank you guys.
09:21:51 <Breadmonster> It's really hard to wrap my head around some things.
09:22:27 <xenon> thanks both of you :)
09:22:31 <ab9rf> Breadmonster: haskell does that to people whose entire experience is only with imperative languages
09:22:49 <Breadmonster> I'm cool with a lot of FP, but there are times that I don't get some of the subtleties because I have no clue how something is actually done on bare metal.
09:22:59 <ab9rf> Breadmonster: read those papers :)
09:23:11 <Breadmonster> After I get a CS degree thank you.
09:23:15 <levi> Breadmonster: Instead of taking on a stack structure as in C-like languages as it runs, Haskell takes on more of a graph structure based on pointers to thunks. That's not necessarily the final story about what the machine code looks like, though, since compilers can do crazy things when they know you're not changing values behind their back.
09:23:37 <Breadmonster> levi: that was helpful, thank you :)
09:23:53 <ChongLi> yes
09:24:17 <ChongLi> the takeaway is this: GHC can twist and contort your code beyond all recognition
09:24:43 <Breadmonster> It would've been helpful if I could tell how.
09:24:49 <Breadmonster> But I guess I'm not up for that.
09:24:52 <Breadmonster> Anyway.
09:24:58 <Breadmonster> Where's the Haskell forum?
09:25:00 <ChongLi> it's really not that important :)
09:25:10 <ChongLi> there's a mailing list
09:25:14 <ChongLi> I don't know of any forum
09:25:31 <levi> C was actually considered a huge step backward to optimizing compiler writers of the day, as the barely constrained pointers make it really hard to detect where particular variables change value.
09:25:32 <Breadmonster> Okay, what's the official form of communication?
09:25:33 <ChongLi> http://www.haskell.org/mailman/listinfo/haskell-cafe
09:25:56 <levi> It's why Fortran lives on in scientific computing.
09:26:03 <ChongLi> official form of communication?
09:26:12 <ChongLi> who do you want to contact?
09:26:46 <levi> Lots of haskell people will answer questions here, haskell-cafe, the haskell reddit, and the haskell Stack Overflow.
09:26:56 <Breadmonster> Okay.
09:27:01 <Breadmonster> No, just a forum for dev stuff.
09:27:12 <Breadmonster> I think I'll begin with the mailing list.
09:27:18 <Breadmonster> Thanks a lot, guys.
09:27:28 <Breadmonster> See you :)
09:27:31 <ChongLi> bye :)
09:28:14 <quchen> levi: Oh, *that*'s the reason Fortran is still used (and faster)?
09:30:15 <merijn> The reason that Fortran is still used is because C doesn't have proper arrays
09:30:30 <merijn> Which means most array code in C is super unoptimised
09:30:57 <quchen> Let's move this to #-blah
09:31:43 <companion_cube> the reason is aliasing problems in C, yeah
09:44:49 <clahey> So, I understand how to build trees in a procedural language.
09:44:57 <clahey> Say you have a number of items that need to go into a tree.
09:44:58 <niteria> :t Right
09:45:03 <niteria> @type Right
09:45:10 <clahey> You change the tree as you go through the items.
09:45:24 <clahey> In a functional language though, do you just build a new tree each time you read a new item?
09:45:35 <niteria> huh, no lamdabot
09:45:54 <clahey> I know there's fromAssocList for maps, for instance, but say I'm implementing a new tree...  How do I do this?
09:45:54 <merijn> clahey: Yes, but since branches are immutable you can copy all the unchanged branches
09:46:05 <byorgey> clahey: sure.  But note that can still be efficient because the new tree can share all the unchanged parts with the old tree
09:46:14 <quchen> clahey: You only have to rebuild the spine of the tree up to the element you're changing.
09:46:28 <clahey> Okay.  There's no faster way than that, eh?
09:46:45 <quchen> clahey: Related SO question: http://stackoverflow.com/questions/14165989/how-is-insert-ologn-in-data-set
09:47:19 <byorgey> clahey: there can't possibly be a faster way than that.  Even with mutable trees you still have to traverse it to find the right place to insert.
09:48:04 <quchen> byorgey: Well, asymptotically at least. Updating a mutable tree will still be faster in practice.
09:48:22 <companion_cube> unless you use STL-like iterators
09:48:32 <companion_cube> in which case finding where to insert can be faster
09:48:44 <quchen> companion_cube: Faster than log(n)??
09:49:14 <companion_cube> quchen: for some cases, like  1/ find if some element is in the tree 2/ if not, use the iterator you got from 1/ to insert it at the right place in O(1)
09:49:52 <clahey> companion_cube: That's still log(n) to find if the element is in the tree.
09:49:59 <clahey> companion_cube: You just moved the work.
09:50:08 <companion_cube> but you do only one traversal, instead of two
09:50:10 <clahey> Possibly you kept yourself from doing the same work twice, but that's different.
09:50:15 <companion_cube> yes
09:50:43 <clahey> But yeah, what I was asking about was whether there was some way to do it faster in practice.
09:51:10 <clahey> I'm used to allocation being slow, so writing to memory log(n) times seems much faster than allocating log(n) new nodes.
09:51:19 <hpaste> Jeremy pasted “Project Euler 58” at http://hpaste.org/85094
09:51:33 <quchen> Why would you need multiple traversals? Seems pretty natural to me to combine search and insertion.
09:51:53 <quchen> Above it sounded like it's a special feature of C++'s implementation
09:52:07 <clahey> quchen: Well, if you want to get the value and insert a new value if you can't find it, you do need a function that lets you do that in some way.
09:52:17 <clahey> You could just have the search function return a Zipper.
09:52:26 <clahey> Though that's a lot bigger.
09:52:34 <clahey> And you could have a "findOrInsert" function.
09:52:43 <clahey> Or a "changeOrInsert" function.
09:52:50 <companion_cube> quchen: well, how do you do this in one traversal in haskell? find if an element is present, insert something if not
09:53:41 <clahey> companion_cube: findOrInsert :: Tree -> value -> Tree
09:53:51 <clahey> companion_cube: Or perhaps:
09:54:11 <hiptobecubic> clahey, how do you find the value there? You get a Tree back, then what?
09:54:14 <clahey> findOrInsert :: Tree -> (Value -> Ordering) -> (Tree, Value)
09:54:17 <quchen> companion_cube: Sounds straightforward using splitMember
09:54:19 <companion_cube> ok for that, but I wonder if you can avoid allocating if the element is present
09:54:32 <quchen> Or am I forgetting something
09:54:41 <clahey> :t splitMember
09:54:43 <clahey> Oh right.
09:54:50 <quchen> splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
09:54:57 <quchen> "O(log n). Performs a split but also returns whether the pivot element was found in the original set."
09:55:11 <hiptobecubic> sounds exactly right
09:55:28 <companion_cube> is this really O(log n)? or just lazy?
09:55:33 <clahey> Oh, my findOrInsert function was missing the default value to get inserted.
09:55:42 <quchen> Laziness doesn't change asymptotics afaik
09:55:52 <clahey> findOrInsert :: Tree -> (Value -> Ordering) -> Value -> (Tree, Either Value Value)
09:56:00 <clahey> Or perhaps Maybe Value.
09:56:15 <clahey> To determine whether it returned the internal value or inserted the default.
09:56:18 <hiptobecubic> findOrInsert :: Ord a => Tree -> a -> (bool, Tree)
09:56:22 <quchen> companion_cube: Also the implementation is quite simple. It's basically "search for x, when you arrive return left and right subtrees"
09:56:33 <aCube> Is lambdabot away?
09:56:40 <companion_cube> quchen: hmmm, and what about the tree above?
09:56:48 <clahey> I guess what I'm talking about it really only useful for Map, not Set.
09:57:20 <hiptobecubic> @faq Can Haskell shoopdawoop!?
09:57:24 <geekosaur> there was a netsplit earlier, LB is presumably either stuck on the other side of it or possibly contemplating its navel due to mis-recovery
09:57:31 <hiptobecubic> apparently
09:58:28 <quchen> companion_cube: Oh, you mean the spine above has to be re-allocated? That may be, right
09:58:41 <Shin-LaC> I'm trying to do question 23
09:58:47 <Shin-LaC> extract n randomly-selected items from a list
09:58:51 <clahey> findOrInsert :: Ord a => Map k a -> k -> a -> (Map k a, Maybe a)
09:58:52 <companion_cube> I think you need to, it's a kind of zipper of what's left and what's right
09:59:03 <clahey> And of course, switch Ord a to Ord k.
09:59:16 <Shin-LaC> I see that there's a randomRs that returns and infinite list of random numbers
09:59:39 <Shin-LaC> but of course it never updates the global PRNG
09:59:42 <Shin-LaC> (I think)
09:59:45 <quchen> companion_cube: I'm not sure how the function hanles this and I gotta go now :-(
09:59:49 <Shin-LaC> its that bad?
09:59:55 <Shin-LaC> *is
09:59:56 <quchen> companion_cube: Here's the source: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Set-Base.html#splitMember
10:00:02 <clahey> Oh, but what would be a really useful function would be:
10:00:10 <quchen> companion_cube: If you feel like investigating and find something out @tell me
10:00:15 <quchen> Lambdabot, get well soon :-)
10:00:22 <clahey> findOrInsert :: Ord k => Map k a -> k -> (k -> a) -> (Map k a, a)
10:00:37 <clahey> Basically using the Map as a cache for the function (k -> a)
10:01:37 <nimbus57> Can anyone review my Project Euler 58? http://hpaste.org/85094
10:02:12 <niteria>     f >>= k = \ r -> k (f r) r
10:02:29 <niteria> oops
10:03:14 <niteria> anyway, is it any different from \r -> (k . f) r r ?
10:04:09 <niteria> I wondered if there's a function that would let me omit r
10:04:24 <quchen> join (k.f)
10:04:57 <quchen> For functions, "join f x = f x x"
10:05:04 <quchen> Gotta run to the bus now, really. Bye :-)
10:05:48 * hackagebot network-metrics 0.3.1 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.3.1 (BrendanHay)
10:06:16 <ab9rf> @pl \r -> (k . f) r r
10:06:21 <niteria> no lambdabot
10:06:24 <ab9rf> oh, beh
10:06:58 <stelleg> does anyone know how to export the contructor for a newtype?
10:07:03 <stelleg> e.g.
10:07:05 <ab9rf> BAD LAMBDABOT!
10:07:21 <stelleg> newtype Score = Score Int Int
10:07:33 <ab9rf> Score(Score) or Score(..)
10:07:40 <stelleg> hmm
10:07:43 <stelleg> I tried Score(..)
10:07:44 <atriq> stelleg, that's an invalid newtype
10:08:08 <ab9rf> yeah, newtypes can only have one type
10:08:23 <ab9rf> you need to use data for that
10:08:31 <ab9rf> or use (Int,Int) since that would be a single value
10:09:03 <ab9rf> er, one value not one type
10:09:17 <stelleg> ab9rf: oh
10:09:27 <stelleg> ab9rf: yeah good point, I thought it was a newtype
10:09:38 <stelleg> but it turns out it is a data constructor
10:09:47 <stelleg> with just one constructor
10:09:53 <ab9rf> you can either do data Score = Score Int Int or newtype Score = Score (Int,Int)
10:09:58 <stelleg> wonder why its not getting exported correctly with Score(..)
10:10:05 <stelleg> ab9rf: cool thanks
10:10:05 <ab9rf> stelleg: because it doesn't exist :)
10:10:28 <stelleg> data Score = Score Int [TypeCost] [TextMatch]
10:10:31 <ab9rf> oh, you used data?
10:10:35 <stelleg> yeah
10:10:45 <ab9rf> then exporting Score(Score) or Score(..) should do it
10:10:46 <stelleg> its a hackage library, not mine
10:10:50 <stelleg> weird...
10:11:01 <stelleg> oh
10:11:07 <stelleg> I think I know why
10:11:15 <ab9rf> the first exports just the single constructor, the second exports all constructors
10:11:39 <stelleg> ab9rf: yeah that makes sense
10:11:57 <niteria> nimbus57: tail $ take 5 $ iterate (\x -> x + (sl + 1)) n, looks like you can replace that with n + 4 * (sl + 1), I may be off by one
10:12:41 <niteria> you can also replace (\x -> x + (sl + 1)) with section: (+ (sl + 1))
10:13:08 <ab9rf> sections are what made me initially love haskell
10:14:35 <clahey> Next question.
10:14:43 <Shin-LaC> is there an advantage over using a list comprehension instead of map, filter?
10:14:47 <clahey> Say I want to parse strings with simple parentheses?
10:14:57 <elliott> Shin-LaC: just readability, often
10:15:00 <clahey> No nested parentheses.
10:15:05 <elliott> and list comprehensions can work with monads if you turn on an extension
10:15:07 <clahey> a(bc)de(fgh)
10:15:10 <elliott> (all monads rather than just [], that is)
10:15:21 <clahey> Any reason not to use something like parsec or trifecta?
10:15:26 <ab9rf> Shin-LaC: use whatever you find most expressive
10:15:30 <Shin-LaC> ok
10:15:32 <ab9rf> clahey: you like working harder?
10:16:09 <ab9rf> Shin-LaC: the main advantage of map and filter is that they're often easier to make generic than a list comprehension is
10:16:18 <ab9rf> Shin-LaC: epsecially making them apply to monads other than list
10:16:24 <clahey> ab9rf: No, just making sure I'm not missing some easier tool.
10:20:20 <ab9rf> clahey: parsec isn't easy?
10:20:48 * hackagebot ajhc 0.8.0.4 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.4 (KiwamuOkabe)
10:21:11 <clahey> ab9rf: It's not hard.  I was just curious if there was even easier.
10:23:16 <lulf> ls
10:23:34 <SuperNoeMan> hey, I heard that extraction to haskell from Coq is kind of poor
10:25:51 <niteria> I heard it's unsafeCoerce everywhere
10:26:09 <niteria> oh, I thought you meant Agda
10:26:12 <SuperNoeMan> does anybody have any experience that I could hear from?
10:39:17 <feliperosa> arrgh, parallel programming in haskell is so frustrating... What can be the cause of high garbage collection in parallel vector reduction (using (+))?
10:39:53 <feliperosa> I've tried par & pseq and the Par monad, but either way I get too much garbage collection
10:41:04 <pamojarpan> hello, I'm a newbie with a problem in a haskell program
10:41:09 <pamojarpan> https://docs.google.com/document/d/1o3Uo_OkelsHwtcG2RmWdI6Am6z5mKEoIMQDohpTP9Vk/edit
10:41:11 <pamojarpan> any help?
10:42:11 <feliperosa> pamojarpan: could you please use hpaste.org? that would make it easier to read
10:42:19 <pamojarpan> of course
10:43:00 <hpaste> pamojarpan pasted “Haskell file reader” at http://hpaste.org/85095
10:44:57 <jfischoff> what's the best way to covert a Float to a Double?
10:45:18 <feliperosa> :t toRational
10:45:30 <feliperosa> oh noes, where's he
10:45:44 <jfischoff> okay wasn't sure if there was a better way
10:46:14 <feliperosa> but I guess I'm wrong
10:46:40 <jfischoff> (fromRational . toRational) was my first thought
10:46:51 <jfischoff> but that seems bad
10:46:57 <feliperosa> oh yeah, that's what I was missing
10:46:58 <hpaste> pamojarpan revised “Haskell file reader”: “Haskell file reader” at http://hpaste.org/85095
10:47:36 <hpaste> pamojarpan revised “Haskell file reader”: “Haskell file reader” at http://hpaste.org/85095
10:48:01 <supki> jfischoff: realToFrac (which is fromRational . toRational)
10:48:04 <feliperosa> pamojarpan: The thing is that printSummary gives you IO (), so using map printSummary over a [[Int]] will result in [IO ()]
10:49:07 <pamojarpan> how can I solve that?
10:49:16 <pamojarpan> I don't understand Monads pretty well
10:49:58 <kbdz> Hello. Is where a category where types with kind * are objects and type constructors, say *->*, are arrows?
10:51:34 <simpson> kbdz: Sorry, I don't quite understand your question.
10:51:40 <feliperosa> pamojarpan: You could use mapM_. That is mapM_ :: (a -> m b) -> [a] -> m (), that would run all your computations and ignore their results (no problem since IO () has no results anyway, just effects)
10:51:48 <ab9rf> indeed, i also failed to parse it
10:52:43 <hpaste> pamojarpan revised “Haskell file reader”: “Haskell file reader” at http://hpaste.org/85095
10:52:57 <feliperosa> pamojarpan: mapM simply applies the function (a -> m b) to each elem of [a] and gather their results in a list, so their effects are taken as well
10:53:35 <narens> Question: with the lens package I can do (1,2) _1 %~ (+1) to get (2,2), but I'd like to use a monadic function to modify so If i naively do (1,2) _1 %~ (\x -> Just (x+1)) I will get (Just 2,2). But what i really want is Just (2,2)... can it be done?
10:54:08 <otters> Just $ (1,2) _1 %~ 2
10:54:14 <otters> er
10:54:16 <otters> .~
10:54:39 <pamojarpan> feliperosa: I've changed map to mapM_
10:54:46 <pamojarpan> still the same problem
10:55:02 <narens> otters: eh? I need to modify not just set
10:55:04 <feliperosa> pamojarpan: Not the same, there were 2 problems
10:55:47 <supki> narens:  (1, 2) & _1 (\x -> Just (x + 1))
10:55:50 <feliperosa> pamojarpan: Now you have a problem with the types in parseFile. You see, you're running a IO computation there but not saying that with the types.
10:55:57 <kbdz> simpson: Types with kind * and functions make up Hask category. Type constructors looks like functions so I wonder do they make up a category too,
10:56:21 <narens> supki: nice
10:56:30 <narens> supki: how does that work?
10:56:33 <jfischoff> float2Double was what I wanted
10:56:42 <jfischoff> in GHC.Float
10:56:49 <simpson> kbdz: IIUC type constructors *are* functions.
10:56:55 <Hafydd> @hoogle float2Double
10:57:20 <feliperosa> pamojarpan: And you're mixing monad types in that expression too.
10:57:23 <Hafydd> D:
10:57:27 <merijn> narens: Normally you use the Identity functor to get results from a lens like _1, but lens works with any functor. This is just using the Maybe functor instead of the identity one, afaik
10:57:30 <jfischoff> lambdabot is down I think
10:57:39 <jfischoff> @slap
10:58:01 <pamojarpan> feliperosa: so,
10:58:01 <pamojarpan> parseFile:: String -> IO [Int]
10:58:02 <narens> merijn: I knew the lens package is worth all its dependencies!
10:58:17 <merijn> narens: Maybe you want to look at edwardk's lens talk where he shows where these type signatures are coming from
10:58:28 <merijn> It's very interesting, but a bit long :p
10:58:37 <aristid> > (1, 2) & _1 (\x -> Just (x + 1))
10:58:42 <narens> merijn: I have, but only skimmed. It'll take some time to absorb all
10:59:22 <kbdz> simpson: I do not mean data constructors like Just. I mean types with kind *->*. They aren't functions.
10:59:26 <merijn> aristid: lambdabot is dead :\
10:59:40 <aristid> merijn: NOOOOO
11:00:28 <pamojarpan> feliperosa: should I change some let expressions to <-?
11:02:00 <feliperosa> pamojarpan: No, but the oposite. You should change <- to let. You see L.readInt has type L.ByteString -> Maybe (Int, L.ByteString) right. So you could first map that then take the list out of the Maybe monad.
11:02:52 <feliperosa> pamojarpan: Like mapM L.readInt nums has type Maybe [(Int, L.ByteString)]. So you could case that: case numtupla of { ... }
11:04:02 <hpaste> pamojarpan revised “Haskell file reader”: “Haskell file reader” at http://hpaste.org/85095
11:04:48 <pamojarpan> feliperosa: I haven't seen case yet
11:05:02 <pamojarpan> feliperosa: and thank you very much
11:05:09 <pamojarpan> feliperosa: :)
11:05:14 <hpaste> feliperosa annotated “Haskell file reader” with “Haskell file reader (annotation)” at http://hpaste.org/85095#a85100
11:09:56 <feliperosa> Can someone help me with parallel haskell things? rofl, why can't I figure that out. 0.25 s of GC out of 0.33 yay...
11:11:27 <hpaste> pamojarpan revised “Haskell file reader”: “Haskell file reader” at http://hpaste.org/85095
11:11:46 <pamojarpan> feliperosa: more errors, :(
11:12:27 <narens> feliperosa: what are you trying to do?
11:12:40 <pamojarpan> feliperosa: fromMaybe is the solution, right?
11:13:06 <feliperosa> pamojarpan: Not the safest, but would do yes.
11:13:29 <pamojarpan> feliperosa: what do you wanna mean with safest?
11:14:45 <clahey> Okay, so I've defined a trifecta parser.
11:14:47 <feliperosa> narens: Well, I trying to learn parallel programming in haskell. I did a program to sum all elements of a vector (from Data.Vector) in parallel (a la divide and conquer) but it's doing a lot of garbage collection and I don't understand why...
11:14:53 <clahey> Or I could change it to be a parsec parser easily enough.
11:14:56 <clahey> How do I run it on a String?
11:15:12 <clahey> The docs only seem to say how to read from a file.
11:15:44 <kbdz> I.e. value level constructor "Just" is an arrow in the Hask.
11:15:45 <kbdz> I wonder is where a category there _type level_ constructor Maybe :: * -> * is an arrow.
11:16:02 <feliperosa> pamojarpan: Sry, I misread it. I thought you said fromJust hehe.
11:17:41 <merijn> feliperosa: Computation not strict enough, maybe?
11:18:11 <narens> feliperosa: where is the code?
11:18:16 <hpaste> feliperosa pasted “why GC? why?” at http://hpaste.org/85102
11:18:20 <hpaste> pamojarpan revised “Haskell file reader”: “Haskell file reader” at http://hpaste.org/85095
11:18:52 <feliperosa> merijn: Maybe, I'll look for that.
11:18:56 <magicman> clahey: Text.Trifecta.Parser exports parseString :: Parser a -> Delta -> String -> Result a; No clue what this Delta thing is, though. I haven't used trifecta myself.
11:19:19 <hpaste> pamojarpan revised “Haskell file reader (annotation)”: “test” at http://hpaste.org/85100
11:21:31 <pamojarpan> feliperosa: I have to go, I'll return to this problem in some hours. Thanks for your help.
11:21:55 <feliperosa> pamojarpan: Ok :).
11:22:41 <clahey> magicman: Huh, it's not listed on http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/Text-Trifecta-Parser.html
11:23:21 <magicman> Ahh, I was looking at the 1.0 docs.
11:24:04 <clahey> Which I didn't find with google.  Yeay google!
11:24:04 <hpaste> pamojarpan revised “Haskell file reader (annotation)”: “test” at http://hpaste.org/85100
11:26:43 <feliperosa> Doing -qg2 doubles production time. Does that mean anything useful?
11:27:56 <feliperosa> Cuts of total memory in use by 2 as reported by -s
11:29:39 <feliperosa> merijn: I thought that put (from Control.Monad.Par) was fully strict and that would help (I'm using Par).
11:32:10 <hpaste> “Anonymous Coward” annotated “why GC? why?” with “why GC? why? (annotation)” at http://hpaste.org/85102#a85106
11:32:35 <narens> feliperosa: that would be my take... i did a fixed number slices but that can be changed
11:33:28 <danharaj> edwardk: I found a paper that well describes the idea you explained to me yesterday. "Attribute Grammars as a Functional Programming Paradigm"
11:33:39 <edwardk> that sounds right
11:33:42 <edwardk> was it helpful?
11:33:58 <danharaj> edwardk: Yes, but now I am hung up on something, which is probably why I had trouble getting it.
11:35:13 <danharaj> edwardk: This method can compute the root node's attributes by building an annotated tree and then smashing it down with a knot-tie to finish the loop. But I am trying to get the whole annotated tree.
11:36:10 <Ontolog> is there any difference at all in the semantics of the expressions (null x) and (x == [])?
11:36:58 <edwardk> oh, i've done that before, so it can be done =)
11:37:30 <danharaj> edwardk: I am not sure that is a good explanation of what I am trying to express.
11:37:37 <feliperosa> narens: Hum, interesting. It got some parallel working
11:37:51 <Zariel> If I have a module in src/stuff do I need to specify all modules like this in other-modules?  hs-source-dirs: src
11:38:01 <edwardk> i mean i've extracted the tree with a cofree comonad annotating what the values were at each level
11:38:12 <xnyhps> Ontolog: The second one requires Eq on the values of x, the fist one doesn't.
11:38:35 <Ontolog> xnyhps: thanks
11:39:45 <__op> @src null
11:41:01 <__op> lambdabot has left (Excess Flood)
11:42:07 * hackagebot Win32-junction-point 0.1 - Support for manipulating NTFS junction points.  http://hackage.haskell.org/package/Win32-junction-point-0.1 (MichaelSteele)
11:42:08 <Ontolog> I have another question about two different operations on lists that seem to be inconsistent in their strictness. (head []) will raise an Exception, while (take 3 [1,2]) returns [1,2]. Given the behavior of head I would expect a function like take to also raise an exception. Or looking at it the other way, head [] could return some kind of null object.
11:42:28 <Ontolog> So can someone explain to me how this is in fact consistent?
11:42:31 <geekosaur> what is null object?
11:42:39 <Ontolog> like in Ruby we have Nil
11:42:55 * geekosaur watches point sail far overhead...
11:42:59 <Ontolog> so doing something like (head []) in Ruby would return nil
11:43:03 <monochrom> there is no null object in haskell
11:43:21 <Ontolog> ok, why not
11:43:22 <monochrom> see http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
11:44:07 <Ontolog> monochrom: in a nutshell?
11:44:14 <monochrom> take and head are not meant to be related. take does what it does: give you a perfectly fine list, even if it's short. head does what it does: give you an element or die trying.
11:44:19 <geekosaur> but to address your actual question: take returns a list, an empty list is consistent with thar
11:44:45 <geekosaur> head returns an a from an [a]. it does not (although some argue it should) return a Maybe a
11:45:13 <geekosaur> "null object" is not a thing in Haskell. you might want to learn about Haskell's type system.
11:45:31 <Ontolog> geekosaur: yes, i understand, i want to understand why though
11:45:36 <monochrom> to say that "take and head are not consistent together" is comparing apples and oranges
11:45:43 <Ontolog> geekosaur: just high-level 2 sentence explanation
11:45:54 <geekosaur> note however that head *is* acknowledged to be something of a wart. sadly, we're kinda stuck with it for historical reasons, but we tend to recommend people not use it precisely for that reason.
11:45:55 <Ontolog> monochrom: i see
11:46:11 <Ontolog> geekosaur: what to use instead of head?
11:46:22 <niteria> pattern matching
11:46:52 <Zariel> damnit cabal be helpful
11:47:06 <geekosaur> foo [] = {- some reasonable default -}; foo (x:_) = {- whatever -}
11:48:13 <fryguybob> > let safeHead (a:_) = Just a; safeHead _ = Nothing in (safeHead [1,2], safeHead [])
11:48:19 <fryguybob> :(
11:48:45 <niteria> (Just 1, Nothing) :D
11:49:04 <Ontolog> oh, Nothing
11:49:09 <Ontolog> so Nothing is null :p
11:49:15 <niteria> it isn't
11:49:18 <Ontolog> yeah i know
11:49:21 <qentrinia> What happened to lambdabot? :(
11:49:29 <fryguybob> Ontolog: Notice the type is different.  That's the important part.
11:49:32 <monochrom> Nothing is not null because Nothing is not pervasive, null is pervasive
11:49:43 <Ontolog> pervasive?
11:49:44 <geekosaur> it's a null that you have to declare support for
11:49:58 <geekosaur> (and, thereby, have to handle somehow)
11:50:02 <monochrom> every type has a null, every type does not have a Nothing
11:50:26 <Ontolog> oh yeah i shouldn't confused my talk of null with the null operator
11:50:40 <Ontolog> i mean just something that is semantically NULL like in the SQL sense
11:50:57 <niteria> undefined is sort of like null
11:51:48 <niteria> but with null you can test for nullness
11:52:28 <danharaj> edwardk: http://hpaste.org/85108 I would like to give `compute` the same signature as synthetic, but I do not see how this representation of attributes allows that.
11:52:47 <Ontolog> i just wonder if the behavior of functions like head make the language a bit more verbose than other high-level languages such as ruby or perl
11:52:56 <edwardk> danharaj: i'm going to have to do this offline later
11:52:59 <danharaj> (also I am about 12 sure that I correctly defined compute)
11:53:16 <Ontolog> i guess all the strict typing would do that as well
11:53:21 <danharaj> edwardk: Please do not go out of your way to entertain my questions :)
11:53:24 <niteria> Ontolog: the other way around, you have a Maybe monad
11:53:39 <edwardk> danharaj: its just that i'm currently pair programming =)
11:53:56 <niteria> so you don't have to check for nullness on every step
11:55:59 * hackagebot yesod-auth-fb 1.5 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.5 (FelipeLessa)
11:55:59 * hackagebot sscgi 0.1.0 - Simple SCGI Library  http://hackage.haskell.org/package/sscgi-0.1.0 (ChrisForno)
11:57:04 <clahey> edwardk: What does the delta argument to Text.Trifecta.parseString do?
11:57:17 <clahey> edwardk: It seems to be causing the first character of my string to get skipped.
11:57:29 <Ontolog> question about ranges: does [1..1000] immediately allocate memory for all 1000 list positions?
11:57:33 <clahey> I passed in delta '\0' cause I didn't know what else to pass.
11:57:52 <monochrom> no
11:57:59 <edwardk> clahey: its usually used to give a filename
11:57:59 <edwardk> clahey: what delta are you supplying?
11:58:10 <edwardk> that would skip a char alright =)
11:58:13 <niteria> Ontolog: no it's actually enumFromTo 1 1000
11:58:26 <Ontolog> monochrom: so what if I like drop the 500th element from the list, does it split into two ranges?
11:58:27 <geekosaur> Ontolog, haskell is not strict, in general values are computed when demanded. write your code properly and that would not allocate anything at all...
11:58:38 <Ontolog> geekosaur: i see
11:58:53 <edwardk> use mempty or the filename hint
11:58:58 <geekosaur> (stream fusion, it generates a value and consumes it immediatey, no allocation)
12:00:03 <clahey> edwardk: That could use some documentation.
12:00:14 <edwardk> clahey: patch! =)
12:00:24 <edwardk> trifecta in general is completely underdocumented
12:02:36 <hseg> Is it possible to install the Haskell Platform on a pendrive and use it portably across Windows computers, without needing admin rights on any of the computers?
12:03:26 <visof> wow haskell now is 1068 users
12:04:00 <clahey> edwardk: Fair enough.  :)
12:04:55 <merijn> I believe edwardk's strategy is to become popular enough that other people will document your stuff for you :p
12:05:33 <edwardk> hseg: possible? probably. easy? don't think so
12:05:43 <edwardk> merijn: it seems to be working so far
12:06:09 <hseg> This: http://www.haskell.org/pipermail/wikibook/2012-July/000083.html gives me hope. But there doesn't seem to have been feedback to that.
12:06:24 <edwardk> release all the things with enough instances and types that its obvious that you don't want to try to release another package to compete with me on code quality, then by the time you've finished understanding it you can go and document it ;)
12:17:33 <hseg> What could trip me up in trying to get Haskell to be portable?
12:18:41 <edwardk> portable how?
12:19:41 <danharaj> Cabal on windows uses appdata iirc.
12:19:41 <danharaj> (As does GHC?)
12:20:35 <dcoutts> see System.Directory.getAppUserDataDirectory "foo"
12:21:10 <dcoutts> on windows that uses %appdata%/foo on unix it uses ~/.foo
12:21:19 <dcoutts> and cabal uses System.Directory.getAppUserDataDirectory "cabal"
12:22:04 <hseg_> Hm. Is there any way that I can redirect that?
12:23:28 <darthdeus> guys, why am i getting this when i run "cabal haddock"? cabal: You need to re-run the 'configure' command. The version of Cabal being
12:23:29 <darthdeus> used has changed (was Cabal-1.16.0.1, now Cabal-1.14.0).
12:23:44 <dcoutts> hseg: for cabal or in general?
12:23:50 <darthdeus> it doesn't matter if i re-run configure
12:23:50 <darthdeus> it still happens
12:24:50 <hseg_> For cabal is sufficient.
12:24:52 <dcoutts> darthdeus: check if blowing away your ~/.cabal/setup-exe-cache/ makes any difference
12:25:39 <dcoutts> hseg: there's an env var or command line flag you can use to tell cabal which config file to use, all other directories can be set in that config file
12:26:05 <darthdeus> dcoutts: i dont have anything there
12:26:12 <darthdeus> trying cabal install cabal-install now and updating
12:26:46 <dcoutts> darthdeus: also doing a clean might fix it, it'd force it to rebuild the setup
12:27:29 <hseg> It seems, from searching around a bit, that the env var APPDATA points to the location of appdata. So, if I set it to some folder on the pendrive, cabal should store its files there
12:27:50 <dcoutts> hseg: it doesn't literally use the env var, it calls some win32 function
12:28:17 <hseg> Right. But setting the var before windows execs into cabal should do the trick.
12:28:18 <dcoutts> (I think)
12:28:27 <dcoutts> maybe, maybe not
12:28:45 <fryguybob> hseg: That doesn't sound like a good way to do things.
12:29:08 <hseg> I know. Which is why I asked for an official system in the first place.
12:29:46 <fryguybob> hseg: Change the cabal config?
12:30:11 <hseg> But the path to the cache dir will change on each startup.
12:30:31 <dcoutts> hmm?
12:30:54 * hackagebot MusicBrainz-libdiscid 0.4.1.1 - Binding to libdiscid by MusicBrainz  http://hackage.haskell.org/package/MusicBrainz-libdiscid-0.4.1.1 (AndreTwupack)
12:31:01 <hseg> As in, each time I use a different computer, the drive letter, and thus the path, will change.
12:31:21 <darthdeus> dcoutts: didn't help, it works when i run "runhaskell Setup.lhs haddock"
12:31:22 <darthdeus> but not as the tutorial says
12:31:29 <darthdeus> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
12:31:42 <dmwit> s/way the/way they/
12:31:53 <dcoutts> darthdeus: does cabal clean; cabal configure; cabal build  work?
12:32:01 <dmwit> sorry, thought focus was on my other terminal
12:32:13 <darthdeus> dcoutts: yes, thanks :)
12:32:26 <dcoutts> hseg: I don't think I see what the problem is you're trying to solve
12:32:57 <darthdeus> also probably a stupid question, but why is this working Cabal-Version: >= 1.2 when the version i have installed is 1.1.4?
12:33:15 <fryguybob> hseg: You are looking for "portable" in the sense of having your haskell stuff on a removable drive that you take with you?
12:33:20 <dcoutts> darthdeus: we have a bug where cabal doesn't completely reliably keep track of the version of the Cabal lib used to build the Setup.hs, so if you change the version then sometimes it goes wrong, but cleaning it should fix it
12:33:36 <dmwit> darthdeus: I bet you don't have 1.1.4 installed.
12:33:42 <hseg> fryguybob: Exactly
12:33:56 <dcoutts> darthdeus: you have 1.14 or 1.16 installed
12:34:18 <hseg> Something like http://www.portablepython.com/ for Python
12:34:21 <dcoutts> darthdeus: ghc-pkg list Cabal
12:34:31 <darthdeus> oops, sorry
12:34:32 <darthdeus> i'm stupid :)
12:34:55 <dcoutts> hseg: ok, so for that you need a fully relocatable installation, and Cabal can't quite do that yet, though most of the pieces are in place
12:35:11 <dcoutts> hseg: ie everything using relative paths, so it's location independent
12:35:48 <dcoutts> hseg: in particular we have to be able to install all packages in a prefix independent way, and also have a config file that allows locations to be relative to the location of the config file itself
12:36:13 <hseg> Damn. So I guess the only solution for the time being is to remote into some place where Haskell is installed, even though the connection is a PITA to set up.
12:36:35 <dcoutts> ghc itself is relocatable, but the extra packages you install will not be
12:42:42 <sproingie> cabal-dev could be more like virtualenv if everything was relocateable
12:43:25 <donri> @hackage hsenv
12:43:57 <sproingie> ENOBOT
12:45:03 <carter> hey all, i'm trying to write some type classes that make use of type lits, and i'm getting an odd type error that i'm not understanding http://hpaste.org/85109
12:45:18 <Hafydd> EEEEEE
12:45:23 <sproingie> ooh hsenv looks much nicer
12:45:31 <carter> any thoughts on why i'm getting that type inference error would be nice :)
12:48:46 <jfischoff> carter: you would have a similar problem even if there weren't type lits around
12:48:52 <carter> ok
12:49:06 <carter> i thought with flexible instances i could do that
12:49:14 <carter> or what am i missing?
12:49:24 <jfischoff> or maybe I am missing something
12:49:50 <carter> hrmm
12:50:17 <carter> even just doing  > class  StaticPrimMatrixLayout  (Sized n  lay) where
12:50:21 <carter> has the problem
12:50:41 <jfischoff> yeah so would data Test a = Test a; class Foo (Test a) where
12:50:52 * hackagebot arrowp 0.5.0.2 - preprocessor translating arrow notation into Haskell 98  http://hackage.haskell.org/package/arrowp-0.5.0.2 (RossPaterson)
12:51:06 <elliott> do you want instance, not class
12:51:13 <jfischoff> you can only have type variables after the name
12:51:19 <carter> nope
12:51:22 <carter> wait
12:51:23 <carter> hrmm
12:51:24 <carter> ok
12:51:31 <carter> ahhhhhh
12:51:52 <carter> i think i see what you're saying
12:52:03 <jfischoff> :)
12:52:05 <carter> i can do constructors on the instances
12:52:08 <carter> not in the class dec
12:52:10 <carter> damn
12:52:13 <jfischoff> yeah
12:52:22 <elliott> I don't know what it even means to use class there
12:52:23 <carter> i totally forgot about that
12:52:45 <elliott> you could make the class on the nat or something
12:53:11 <carter> yeah
12:53:14 <carter> i feel better now
12:53:18 <carter> cool
12:53:33 <carter> embarrased that i totally forgot about this
12:54:29 <jfischoff> when you start pulling your hair out with type level programming (or rank n types) its easy to miss the little stuff
12:54:37 <carter> yeah
12:54:44 <xenon21> ahh, sorry guys, how can I observe how a function is implemented in ghci
12:54:44 <carter> and i really really want to use type lits :)
12:55:05 <arkeet> xenon21: you cannot.
12:55:28 <jfischoff> I found the singleton library helpful, because of the examples if nothing else.
12:55:45 <carter> i should look at it
12:56:13 <jfischoff> :)
12:57:01 <xenon21> arkeet: thanks :)
12:58:29 <jfischoff> xenon21: :list might be helpful. There is traced http://hackage.haskell.org/packages/archive/traced/2009.4.3/doc/html/Debug-Traced.html which can be helpful.
13:00:14 <xenon21> jfischoff: thanks jfischoff, i will look at them :)
13:15:53 * hackagebot trifecta 1.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.1 (EdwardKmett)
13:30:00 <simpson> edwardk++ for trifecta bump.
13:30:10 <edwardk> np
13:32:42 <carter> whats the bump accomplish here?
13:33:21 <edwardk> lens 3.10 compat mostly
13:33:32 <carter> 10's out?
13:33:36 <carter> didn't 3.9 just get out?
13:33:36 <simpson> It's probably a rollup of all of the pending trifecta changes, including better parsers compat.
13:33:38 <edwardk> need it to build some in house stuff and there were some incremental improvements other people shipped
13:33:47 <carter> ahh
13:33:49 <edwardk> 3.10 isn't released yet but this lets trifecta build with lens HEAD
13:33:52 <carter> ok
13:33:57 <carter> whats new between 3.9 and head?
13:34:13 <edwardk> https://github.com/ekmett/lens/blob/master/CHANGELOG.markdown
13:34:26 <edwardk> trifecta had a combinator named 'failing' that conflicted
13:34:36 <edwardk> now trifecta has 'failed'
13:34:51 <carter> got it
13:35:21 <meyersh> > [1..3]
13:35:39 * meyersh snuffles sadly over the loss of Lambdabot.
13:36:13 <mauke> preflex: seen lambdabot
13:36:14 <preflex>  lambdabot was last seen on #haskell 4 hours, 31 minutes and 15 seconds ago, saying: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
13:36:31 <arkeet> long live lambdabot!
13:36:44 <shachaf> Cale: ☝
13:38:36 <carter> what happened to lambda bot?
13:38:39 <Cale> @bot
13:38:46 <lambdabot> :)
13:38:53 <tootsie> what is emant by an extensible type system?
13:39:08 <Cale> tootsie: Context?
13:40:51 <commanace> Hey... has anyone had any luck creating an opengl-window from within ghci with nvidia drivers? I tried with the following result: http://hpaste.org/85111
13:41:03 <niteria> iteratee produces single value?
13:41:13 <commanace> Apparently I'm not the only one with this problem: http://stackoverflow.com/questions/7867290/freeglut-does-not-work-in-ghci
13:41:28 <shachaf> Cale: Thanks!
13:41:39 <parcs> commanace: use GLFW-b
13:42:04 <commanace> parcs, i did... that lead to the output on hpaste
13:42:54 <parcs> oh
13:42:59 <parcs> use nouveau :)
13:43:26 <parcs> does running the compiled binary work?
13:43:36 <commanace> parcs: binary works, yes
13:44:17 <parcs> what about ghci -fno-state-hack
13:44:20 <parcs> oops
13:44:24 <parcs> ghci -fno-sandbox
13:44:24 <commanace> parcs: yes, nouveau would be a fallback, however it looks like a solvable problem...
13:44:32 <commanace> I'll check
13:44:38 <parcs> oops ghci -fno-ghci-sandbox
13:44:40 <arkeet> opengl prefers to run in the main thread.
13:44:45 <arkeet> so ^
13:45:01 <parcs> that may be so but opengl via ghci works flawlessly for me
13:45:10 <arkeet> sure, so some drivers may get lucky.
13:45:24 <arkeet> it works fine here with intel drivers.
13:45:40 <parcs> looks like most drivers get lucky, except for evil proprietary nvidia onse
13:45:53 <arkeet> heh
13:46:43 <carter> Cale i'm darn gullible then
13:46:51 <commanace> no-ghci-sandbox doesn't help unfortunately :)
13:47:21 <arkeet> does the compiled program work with -threaded?
13:47:37 <arkeet> err
13:48:44 <commanace> arkeet: yes
13:49:22 <arkeet> I wonder what it is if -fno-ghci-sandbox doesn't help.
13:49:31 <arkeet> what about the glut version?
13:49:35 <arkeet> in ghci
13:50:43 <commanace> I'm wondering, why it even looks for swrast_dri.so ... i thought that belongs to some generic graphics driver?
13:51:11 <arkeet> swrast eh.
13:51:28 <commanace> arkeet: I also had trouble with glut, the message was different though, let me look it up again
13:51:45 <arkeet> same message as the SO question?
13:52:18 <commanace> arkeet: yes, indeed :)
13:54:43 <commanace> maybe trying nouveau is really my best guess...
13:55:32 <arkeet> but does the glut version work with -fno-ghci-sandbox?
13:55:49 <arkeet> it does look like a somewhat different problem than the glfw one.
13:58:25 <zenzike> I'm a bit confused. I've compiled using ghc --make -O2 -rtsopts -prof -auto-all
13:58:50 <zenzike> I was expecting all top level functions in a subsidary imported file to be given an SCC
13:59:06 <zenzike> but when I run by binary wiht +RTS -p, they're not showing up in the report
13:59:11 <danharaj> -caf-all
13:59:29 <zenzike> danharaj: aha :-)
14:00:34 <zenzike> danharaj: good try, but that still isn't being detailed enough
14:02:43 <zenzike> (of course, it works fine when I manually add an SCC to the top level clause, but I still find it strange that it's not being added automatically)
14:03:17 <zenzike> Oh dear, I know why: I should use +RTS -pa
14:05:54 * hackagebot data-default 0.5.3 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.5.3 (LukasMai)
14:06:18 <stelleg> :t g f = f [1] == [1]
14:06:19 <lambdabot> parse error on input `='
14:06:34 <commanace> arkeet: actually I think it is the same problem. Look, I ran it with LIBGL_DEBUG=verbose http://hpaste.org/85114
14:06:39 <stelleg> :t let g f = f [1] == [1] in g
14:06:40 <lambdabot> (Eq t1, Num t, Num t1) => ([t] -> [t1]) -> Bool
14:07:22 <commanace> arkeet: and unfortunately no-ghci-sandbox didn't do the trick
14:07:30 <commanace> but thanks for your help :)
14:08:39 <otters> > let g f = f [1] == [1] in g reverse
14:08:40 <lambdabot>   True
14:10:51 <stelleg> :m Data.Typeable
14:11:09 <stelleg> let g f = f [1] == [1] in typeOf g
14:11:15 <stelleg> > let g f = f [1] == [1] in typeOf g
14:11:17 <lambdabot>   ([Integer] -> [Integer]) -> Bool
14:11:23 <stelleg> so
14:11:39 <stelleg> that doesn't work in ghc, only ghci ( and lambdabot )
14:11:46 <stelleg> anyone know why?
14:12:08 <stelleg> ghc throws an error about g not being an instance of Typeable
14:13:32 <mauke> it's too polymorphic
14:13:41 <mauke> lambdabot defaults it down to Integer
14:13:52 <stelleg_> any way to make GHC do the same?
14:14:00 <mauke> add a type signature
14:14:33 <stelleg_> I can't for what I'm doing
14:15:13 <c_wraith> I bet you can.
14:15:16 <stelleg_> I'm generating the body of g f on the fly
14:15:31 <stelleg_> and want to infer the type of f on the fly
14:15:41 <stelleg_> using the plugins package
14:16:02 <stelleg_> seems like it should be possible
14:16:05 <stelleg_> i.e.
14:16:11 <mauke> :t (\f -> f [1] == [1])
14:16:12 <lambdabot> (Eq t1, Num t1, Num t) => ([t] -> [t1]) -> Bool
14:16:33 <stelleg_> :t let g f = f [1] == [1] in g
14:16:35 <lambdabot> (Eq t1, Num t, Num t1) => ([t] -> [t1]) -> Bool
14:17:46 <stelleg_> mauke: I'll try with the anonymous lambda
14:19:34 <mauke> {-# LANGUAGE ExtendedDefaultRules #-}
14:19:35 <stelleg_> nope, same error
14:19:45 <stelleg_> mauke: thanks I'll try that
14:20:56 <stelleg_> mauke: awesome, thanks!
14:21:05 <stelleg_> exactly what I needed
14:21:16 <stelleg_> best IRC channel ever
14:21:27 * mauke is the best IRC channel ever
14:21:46 <stelleg_> :)
14:23:28 * sproingie /j #mauke
14:23:44 * mauke joins himself
14:23:55 * Hafydd LEFT INNER JOINS mauke.
14:24:00 <sproingie> you can get arrested for doing that in public
14:24:25 <mauke> :t join ?mauke
14:24:27 <lambdabot> (?mauke::m (m a), Monad m) => m a
14:24:56 <shachaf> m (m auke) -> m auke
14:26:59 <quchen> #mauke is empty :-(
14:27:54 <mauke> thachaf
14:28:19 <shachaf> ywauke
14:28:27 <meyersh> > :t return
14:28:29 <lambdabot>   <hint>:1:1: parse error on input `:'
14:28:48 * meyersh seg faults.
14:28:49 <Hafydd> Hahah.
14:29:08 <meyersh> it's this== return :: Monad m => a -> m a
14:29:18 <Hafydd> :t return
14:29:20 <lambdabot> Monad m => a -> m a
14:29:27 <meyersh> Hafydd: Thanks.
14:30:00 <meyersh> Is Monad here special? I'm trying to learn some monad basics and I'm confused about `data M a = ...` and this `Monad`.
14:30:22 <Hafydd> Monad is not special. It's a type class defined in the Prelude.
14:30:26 <mauke> meyersh: stop trying to learn monads
14:30:35 <mauke> meyersh: start with basic types and classes
14:31:01 <mauke> re: classes: Show, Eq, Ord, Read, Functor
14:31:04 <quchen> This ^
14:33:53 <meyersh> That's fair. I'm only trying to get enough to implement a function from the paper "Monads for Functional Programming", the Star function, and "m (star) \a.n" notation seemed like it would be cleared if I implemented it.
14:34:10 <meyersh> s/cleared/clearer/
14:34:30 <mauke> what does star do?
14:35:26 <meyersh> Paper says "... we need a way to apply a function of type a -> M b to a computation of type M a. It is convenient to write these in an order where the argument comes before the function. (*) :: M a -> (a -> M b) -> M b"
14:35:43 <mauke> :t (>>=)
14:35:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:36:09 <meyersh> mauke: Star is bind?
14:36:13 <mauke> yes
14:36:30 <c_wraith> And doesn't conflict with standard ascii for multiplication
14:36:36 <quchen> That paper is not very suitable for an introduction to monads in Haskell.
14:36:56 <mauke> > let (>>=) = (*) in 6 >>= 9
14:36:58 <lambdabot>   54
14:37:05 <monochrom> "m (star) \a.n" becomes "m >>= \a -> n" in modern haskell
14:37:17 <mauke> > let (>>=) = (*); 6 * 9 = 42 in 6 >>= 9
14:37:18 <otters> > let (*) = (>>=) in 6 * 9
14:37:19 <lambdabot>   42
14:37:20 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
14:37:20 <lambdabot>    arising from the ambiguity check f...
14:37:25 <niteria> @where iteratees
14:37:25 <lambdabot> http://hackage.haskell.org/package/iteratee http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
14:37:33 <monochrom> "unit" becomes "return"
14:37:45 <mauke> all hail unitinu
14:38:17 <monochrom> that paper is the best monad tutorial ever.
14:38:33 <monochrom> it is why I do not write one.
14:38:42 <quchen> monochrom: That does not contradict my statement. ;-)
14:38:48 <meyersh> monochrom: Coming from non-functional programming, unit is more familiar than return.
14:39:19 <monochrom> I think they contradict a bit. most people learn monads because they want to work with haskell.
14:39:24 <tromp_> :t permutatiions
14:39:25 <lambdabot>     Not in scope: `permutatiions'
14:39:25 <lambdabot>     Perhaps you meant `permutations' (imported from Data.List)
14:39:36 <tromp_> :t permutations
14:39:37 <lambdabot> [a] -> [[a]]
14:39:55 <monochrom> I can agree that the notation is not modern haskell, but that is the only shortcoming, and it is tiny.
14:40:44 <monochrom> to some extent it may be an advantage, if you plan to define your own monad type class for playing, and not clash with Prelude
14:41:36 <ChongLi> hmmm
14:41:38 <quchen> I think it's a fairly technical article, and maybe worth a read once you got some intuition. I'm pretty sure I wouldn't learn much from it as an introduction to/tutorial about monads.
14:41:44 <ChongLi> ghcjs requires darcs to install
14:42:05 <niteria> Misty and Fluffy for the win
14:42:18 <monochrom> I am not sure what kind of "technical" you mean.
14:42:50 <monochrom> I agree you want intuition. but that's where the problem begins. how do you get intuition?
14:42:59 <tromp_> > [z|z@[d,o,n,t,p,e,r,i,s,h]<-permutations [0..9],o*t*e*i*h>0,d%o+n%t==p%e+r%i+s%h]
14:43:00 <lambdabot>   Not in scope: `%'
14:43:00 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)Not in...
14:43:34 <tromp_> > [z|z@[d,o,n,t,p,e,r,i,s,h]<-permutations [0..9],o*t*e*i*h>0,d R.%o+n R.%t==p R.%e+r R.%i+s R.%h]
14:43:36 <lambdabot>   [[7,3,4,8,5,6,2,1,0,9],[4,8,7,3,5,6,2,1,0,9],[7,2,6,8,5,4,3,1,0,9],[6,8,7,2...
14:43:54 <quchen> monochrom: For me it meant tinkering around with the standard monads until I found out that >>= and <- always suck a value out of something. :-)
14:43:56 <monochrom> useful intuition comes from experience with examples. only. (hint: not from reading philosophical flowery descriptions)
14:44:09 <monochrom> yes, tinkering
14:44:43 <monochrom> Wadler's paper precisely invites you to tinker. he gives you enough examples to start your tinkering
14:45:00 <monochrom> tinkering is also "technical"
14:45:07 <shachaf> monochrom: But I want intuition on how to write philosophical flowery descriptions.
14:45:43 <quchen> You first need intuition for that
14:45:59 <tromp_> > length [z|z@[d,o,n,t,p,e,r,i,s,h]<-permutations [0..9],o*t*e*i*h>0,d R.%o+n R.%t==p R.%e+r R.%i+s R.%h]
14:46:02 <lambdabot>   mueval-core: Time limit exceeded
14:46:26 <quchen> A version of LYAH that has Latex and shachaf on the left and classical LYAH on the right would be great.
14:46:27 <Hafydd> > a
14:46:29 <lambdabot>   a
14:46:40 <Hafydd> :t a
14:46:41 <lambdabot> Expr
14:46:42 <quchen> And then they scroll simultaneously.
14:47:23 <monochrom> "intuition before examples and tinkering" is flawed
14:47:35 <ChongLi> hmm, ghcjs is failing to build :(
14:47:55 <ChongLi> Configuring hsc2hs-0.67...
14:47:56 <ChongLi> make[1]: *** No rule to make target `libraries/Cabal/Cabal/ghc.mk'.  Stop.
14:47:57 <quchen> monochrom: Worked for me.
14:47:59 <monochrom> concrete before abstract. special before general. experimentation before intuition.
14:48:31 <tromp_> > length [z|z@[d,o,n,t,p,e,r,i]<-permutations [1..8],d R.%o+n R.%t==p R.%e+r R.%i]
14:48:33 <lambdabot>   72
14:48:51 <meyersh> Reminds me of "cruelty of really teaching cs." - We plan for tomorrow in yesterdays language.
14:48:54 <monochrom> if you think you have intuition, you probably got it from examples. I think you even said it yourself.
14:49:58 <quchen> 1. Read monad chapter. 2. Re-read monad chapter. 3. Try monads in GHCi. 4. Get angry at monads. 5. Throw a dice; if not 6 goto [1.]. If 6. Insight!
14:50:39 <monochrom> learning is not a spectator sport. reading is not enough. the sooner you play, the faster you learn.
14:51:06 <Hafydd> > [a..z]
14:51:07 <lambdabot>   *Exception: not a number
14:51:16 <Hafydd> > enumFromTo a z
14:51:17 <lambdabot>   *Exception: not a number
14:51:27 <monochrom> and Wadler's article gives you enough variety to play with
14:51:31 <quchen> > ['a'..'f']
14:51:33 <lambdabot>   "abcdef"
14:52:18 <Hafydd> > a+b
14:52:19 <lambdabot>   a + b
14:52:41 <dilinger_> > [0xa..0xf]
14:52:42 <lambdabot>   [10,11,12,13,14,15]
14:53:21 <quchen> Hafydd: a, b, f etc. come from simple-reflect. http://hackage.haskell.org/package/simple-reflect
14:53:26 <mauke> > 0xf0rd
14:53:28 <lambdabot>   240
14:53:31 <monochrom> reading only accomplishes information transfer. but learning is not information transfer. during learning, if you read, it is for getting suggestions on what to experiment with, not for information transfer. most learners don't get that.
14:53:41 <Hafydd> I see.
14:53:58 <jaroslaw> I've only just started studying Haskell but the lectures and notes by John Hughes here http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html have cleared a few things up for me.
14:54:03 <shachaf> > 0xford
14:54:04 <lambdabot>   15
14:54:27 <mauke> beautiful
14:54:45 <Hafydd> Hashah.
14:55:05 <dmwit> > rd
14:55:07 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:55:12 <dmwit> hum =)
14:55:17 <elliott> > oxford
14:55:17 <Hafydd> > tail rd
14:55:19 <lambdabot>   can't find file: L.hs
14:55:19 <lambdabot>   15
14:55:28 <mauke> > tail rd
14:55:30 <lambdabot>   ["One can prepared coconut pecan frosting.","Three slash four cup vegetable...
14:55:35 <Hafydd> > tail rd
14:55:37 <lambdabot>   ["One can prepared coconut pecan frosting.","Three slash four cup vegetable...
14:55:47 <Hafydd> > tails rd !! 3
14:55:47 <shachaf> > map head rd
14:55:50 <lambdabot>   can't find file: L.hs
14:55:52 <lambdabot>   ["Four large eggs.","One cup semi-sweet chocolate chips.","Three slash four...
14:55:54 * hackagebot bitset 1.4.0 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.0 (SergeiLebedev)
14:55:57 * shachaf sighs
14:56:08 <Hafydd> > tails rd !! 5
14:56:10 <lambdabot>   ["Three slash four cups butter or margarine.","One and two third cups granu...
14:56:16 <Hafydd> > tails rd !! 6
14:56:18 <lambdabot>   ["One and two third cups granulated sugar.","Two cups all-purpose flour.","...
14:56:19 <dmwit> Why are you bothering with the "tails"?
14:56:22 <dmwit> just rd !! 5
14:56:28 <Hafydd> So I can see more than one sometimes.
14:56:28 <elliott> > rd == cake
14:56:30 <lambdabot>   True
14:56:37 <elliott> but consider /msg lambdabot (or reading L.hs)
14:56:44 <Hafydd> Yes, okay.
14:56:53 <shachaf> > railroad
14:56:55 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:57:01 <shachaf> > railroad == cake
14:57:03 <lambdabot>   False
14:57:45 <mauke> > length railroad
14:57:50 <lambdabot>   mueval: ExitFailure 1
14:57:50 <lambdabot>  mueval: Prelude.undefined
14:58:06 <mauke> > railroad == cycle cake
14:58:11 <lambdabot>   mueval: ExitFailure 1
14:58:12 <lambdabot>  mueval: Prelude.undefined
14:58:14 <dmwit> > take (length cake) railroad == cake
14:58:16 <lambdabot>   True
14:58:19 <mauke> I'll take that as a yes
14:58:28 <dilinger_> wait, where is rd coming from?
14:58:50 <Hafydd> > take 1000 (cycle cake) == take 1000 railroad
14:58:52 <lambdabot>   True
15:00:20 <Hafydd> > let n = (maxBound :: Int) in take n (cycle cake) == take n railroad
15:00:24 <lambdabot>   mueval-core: Time limit exceeded
15:01:00 <shachaf> @let sum'n'max xs = (sum xs, maximum xs)
15:01:02 <lambdabot>  Defined.
15:02:26 <niteria> :t sum &&& maximum
15:02:27 <lambdabot> (Num c', Ord c') => [c'] -> (c', c')
15:02:48 <stelleg_> :t (&&&)
15:02:50 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:03:19 <parcs> > undefined &&& id `seq` ()
15:03:21 <lambdabot>   ()
15:03:48 <Hafydd> > ['&'] & ((&&) &&& (&&))
15:03:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:03:50 <lambdabot>              with actual ty...
15:05:26 <Hafydd> > let (&&) = id in ['&'] & ((&&) &&& (&&))
15:05:28 <lambdabot>   ("&","&")
15:05:43 <Hafydd> Free emoticon.
15:11:45 <Hafydd> > reduce (a - a)
15:11:46 <lambdabot>   a - a
15:12:04 <Hafydd> > reduce (1 - 1) :: Expr
15:12:06 <lambdabot>   0
15:12:43 <lcfrs> edwardk: scala question pm? also kind of related to codensity.
15:13:06 <edwardk> feel free. bit busy at the moment, but i'll reply as i can
15:16:52 <niteria> @type let y x = (x,x) in (y.y.y.y.y.y.y.y)
15:16:54 <lambdabot> a -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a,
15:16:54 <lambdabot>  a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a,
15:16:54 <lambdabot> a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a,
15:16:54 <lambdabot> a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a,
15:16:54 <lambdabot>  a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a),
15:16:56 <lambdabot> (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a,
15:16:58 <lambdabot>  a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
15:17:56 <niteria> I wonder if it's possible to generate longer type with fewer characters
15:17:57 <c_wraith> Hmm.  Apparently lambdabot doesn't cap the output size of that plugin
15:18:03 * djahandarie was thinking the same thing as niteria
15:18:13 <djahandarie> In fact probably everyone was thinking that
15:18:58 <Hafydd> let y x = (x,x) in ((y.y.y.y.y),"hhhh!")
15:19:00 <Hafydd> > let y x = (x,x) in ((y.y.y.y.y),"hhhh!")
15:19:01 <lambdabot>   (*Exception: showsPrec: No overloading for function
15:19:18 * Hafydd blushes.
15:19:32 <niteria> @type let y =   in (y.y.y.y.y.y.y.y) ""
15:19:34 <lambdabot> parse error on input `in'
15:19:42 <niteria> @type let y x = (x,x) in (y.y.y.y.y.y.y.y) ""
15:19:44 <lambdabot> (((((((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))), ((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char])))), (((([Char], [Char]), ([Char], [Char])
15:19:44 <lambdabot> ), (([Char], [Char]), ([Char], [Char]))), ((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))))), ((((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))
15:19:44 <lambdabot> ), ((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char])))), (((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))), ((([Char], [Char]), ([Char], [Char])),
15:19:44 <lambdabot>  (([Char], [Char]), ([Char], [Char])))))), (((((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))), ((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))
15:19:44 <lambdabot> )), (((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))), ((([Char], [Char]), ([Char], [Char])), (([Char], [Char]), ([Char], [Char]))))), ((((([Char], [Char]), ([Char], [
15:19:46 <lambdabot> [8 @more lines]
15:19:51 <niteria> yeah, thats longer
15:19:52 <djahandarie> Hah.
15:19:58 <elliott> bit spammy
15:20:02 <armlesshobo> i don't understand what's going on here.
15:20:13 <Hafydd> @type let y x = (x,x) in ((y.y.y.y),hhhh)
15:20:15 <lambdabot> Not in scope: `hhhh'
15:20:24 <quchen> Mind moving that to a private session?
15:20:43 <niteria> sorry
15:20:49 <djahandarie> But what about science?
15:22:40 <niteria> I'm not sure why y = join (,) doesn't work here
15:22:46 <elliott> .@type let a x=(x,x);b=a.a;c=b.b in c.c should be longer.
15:24:01 <quchen> Building power towers of types?
15:24:11 <lispy> ackertype
15:24:21 <dEPY> anyone can explain to me what exactly "return" does?
15:24:35 <dEPY> does it wrap something in IO?
15:24:48 <Eduard_Munteanu> @@ @type let y x = (x, x) in (@run text . take 31 . cycle $ "y.")
15:25:03 <lambdabot>  thread killed
15:25:09 <Eduard_Munteanu> Aww.
15:25:10 <armlesshobo> dEPY: it is a monadic function
15:25:24 <byorgey> dEPY: it depends on the particular instance of Monad being used.
15:25:25 <nooodl_> protip: y x=(x,x,x,x)
15:25:31 <byorgey> dEPY: it is a type class method.
15:25:32 <armlesshobo> dEPY: what byorgey said
15:25:38 <dEPY> armlesshobo: ok enough said, I'm not that far in LYAH
15:25:43 <dEPY> :)
15:25:43 <armlesshobo> @src return Maybe
15:25:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:25:45 <byorgey> > return 3 :: Maybe Int
15:25:47 <armlesshobo> uhh
15:25:51 <lambdabot>   mueval-core: Time limit exceeded
15:25:57 <byorgey> > return 3 :: Maybe Int
15:25:59 <lambdabot>   Just 3
15:26:01 <byorgey> > return 3 :: [Int]
15:26:02 <lambdabot>   [3]
15:26:10 <quchen> @src Maybe return
15:26:10 <lambdabot> return              = Just
15:26:11 <quchen> :-)
15:26:12 <byorgey> > return 3 :: IO Int
15:26:12 <armlesshobo> yes
15:26:13 <armlesshobo> that
15:26:14 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Int))
15:26:14 <lambdabot>    arising fro...
15:26:18 <ceii> Is there some fancy type system extention that can type a function z f = f.f such that z y is okay?
15:26:29 <armlesshobo> so for type Maybe, return is simply the Just constructor
15:26:36 <niteria> that's omega
15:26:38 <Eduard_Munteanu> dEPY: yes, return gives you an IO action which, executed, returns that value
15:26:59 <byorgey> ceii: what is y ?
15:27:14 <byorgey> @type let z f = f . f in z
15:27:19 <lambdabot> (a -> a) -> a -> a
15:27:20 <ceii> byorgey: the one from the spam above; y x = (x,x)
15:27:27 <byorgey> ah.
15:27:44 <armlesshobo> Eduard_Munteanu: how is it an IO action?
15:28:01 <armlesshobo> Eduard_Munteanu: return isn't the same for all types
15:28:12 <Eduard_Munteanu> Sure, but I thought he asked what 'return' did in IO.
15:28:42 <byorgey> ceii: yes, you could give z the type   (forall a. a -> (a,a)) -> b -> ((b,b),(b,b))
15:28:46 <byorgey> ceii: using Rank2Types
15:29:18 <elliott> (but there's only really one function of type (forall a. a -> (a,a)), so that has limited usefulness0
15:29:21 <byorgey> > let z :: (forall a. a -> (a,a)) -> b -> ((b,b),(b,b)); z f = f . f; y x = (x,x)  in  z y 3
15:29:22 <elliott> *)
15:29:24 <byorgey> indeed.
15:29:25 <lambdabot>   mueval-core: Time limit exceeded
15:29:27 <armlesshobo> @src IO return
15:29:27 <lambdabot> return x    = returnIO x
15:29:32 <byorgey> > let z :: (forall a. a -> (a,a)) -> b -> ((b,b),(b,b)); z f = f . f; y x = (x,x)  in  z y 3
15:29:36 <lambdabot>   mueval-core: Time limit exceeded
15:29:41 <byorgey> stupid mueval
15:29:56 <lambdabot> sorry :(
15:29:59 <byorgey> hehe
15:30:04 <byorgey> it's not your fault lambdabot
15:30:07 <monochrom> IO implementation is compiler-specific and not very enlightening
15:30:21 <elliott> @botsnack
15:30:21 <lambdabot> :)
15:30:26 <armlesshobo> ha
15:31:13 <jfischoff> mauke: http://hackage.haskell.org/trac/ghc/ticket/7346 this would solve our issue
15:43:25 <quchen> I've got a StateT IO. Suppose an intermediate IO action throws an Exception (file not found etc.), is there any way I could recover the state?
15:43:40 <c_wraith> no
15:44:11 <quchen> Hmpf. Suspected that but hoped for the best. Thanks though
15:44:18 <c_wraith> Well..  what state?
15:44:26 <c_wraith> It's technically sort of possible.
15:45:09 <Ontolog> does Haskell have objects and methods at all?
15:45:09 <quchen> c_wraith: My state is basically a list of files I've touched. When the whole thing is done, there's some cleanup to do in those files, so I'd like to investigate the final state.
15:45:39 <quchen> Ontolog: It's debatable whether or not or to what extent is OOP, but most likely it's not a good idea to think in those terms.
15:45:40 <c_wraith> If you catch the exceptions with a try inside the liftIO, it won't disturb the state.
15:46:05 <c_wraith> That might be what you really want to do
15:46:13 <hpc> Ontolog: the other side of the coin, if you mean "are there things which take these exact literal names"
15:46:28 <hpc> then there is nothing currently called an "object", and there is a thing currently (sometimes) called a "method"
15:46:38 <hpc> that is, a typeclass method
15:46:39 <hpc> :t show
15:46:47 <quchen> c_wraith: Sounds like a good plan. I could basically suspend the exception, do the cleanup, and re-throw it then
15:46:47 <hpc> pah
15:46:50 <lambdabot> Show a => a -> String
15:48:29 <c_wraith> quchen: yes, that's definitely viable
15:48:54 <monochrom> quchen: monad-control may help you
15:49:04 <Ontolog> is there a native type for arbitrary precision floating point numbers (ala Integer)?
15:49:11 <copumpkin> no
15:49:27 <copumpkin> there's Data.Fixed but that's the opposite of floating :)
15:49:35 <copumpkin> it might serve your needs though
15:49:37 <Ontolog> ohhh
15:49:39 <Ontolog> right
15:49:43 <copumpkin> there's also Rational
15:49:46 <__op> @src null
15:49:46 <lambdabot> null []     = True
15:49:46 <lambdabot> null (_:_)  = False
15:49:50 <quchen> monochrom: Thanks, I'll have a look at it
15:49:55 <Ontolog> oh Rational that's cool
15:49:59 <copumpkin> or you can help edwardk and/or me fix Rounded :)
15:50:09 <Ontolog> i suck at programming so maybe not
15:51:09 <jfischoff> what's up with rounded?
15:53:17 <Ontolog> in GHC, are all the core language functions (things like head, fst, take, etc.) implemented in C? Is there a class of core functions or types that are implemented in Haskell itself?
15:53:29 <luite_> no, all of those arent
15:53:30 <Eduard_Munteanu> Ontolog: no
15:53:49 <Ontolog> Eduard_Munteanu: no to which question?
15:53:52 <luite_> Ontolog: there are some lower level primitive operations, that are implemented in Cmm or C
15:53:52 <Eduard_Munteanu> Ontolog: but yes, the basic types can't be defined in Haskell itself
15:54:01 <luite_> Ontolog: see the GHC.Prim or the GHC.PrimOpWrappers modules
15:54:01 <Eduard_Munteanu> Ontolog: head isn't a special function\
15:54:17 <DragonFly> is there a way to evaluate an expression without printing it in GHCi?
15:54:18 <Ontolog> i see
15:54:31 <DragonFly> lazy evaluation can sometimes be a pain...
15:54:32 <luite_> Ontolog: list is implemented as any other ADT in GHC
15:54:44 <jfischoff> DragonFly: seq?
15:55:16 <monochrom> quchen: lifted-base is likely even better. as in, already done the work for you for StateT IO. it uses monad-control underneath.
15:55:19 <Ontolog> luite_: so there's a small number of primitives used to implement everything else?
15:55:36 <luite_> Ontolog: well, small, it's over 300 i think
15:56:21 <luite_> Ontolog: those are for arithmetic, low level arrays (used in text, vector, Array etc), threading things
15:56:23 <DragonFly> jfischoff: thanks
15:56:40 <Ontolog> luite_: that's great, makes it easier to understand the language
15:56:42 <jfischoff> np
15:58:02 <luite_> Ontolog: an Int in GHC haskell is actually a I# Int# constructor, the Int# is the primitive type (it's unlifted, doesn't have bottom, can't make thunks out of it), the primitive operations work on that kind of things
15:58:04 <quchen> monochrom: Thanks again. :-)
15:58:21 <luite_> Ontolog: the I# constructor just wraps the Int# in a regular haskell object.
15:58:29 <Eduard_Munteanu> @src Int
15:58:30 <lambdabot> data Int = I# Int#
15:58:35 <luite_> Ontolog: all the Int operations are then implemented in terms of the primops and the underlying Int#
15:59:12 <monochrom> Ontolog: if you understand "data [a] = [] | a:[a]", then all of head, take, length... are not "core"
15:59:14 <jmcarthur> I wish the constructors didn't also end in #. makes it hard to *actually* find the unboxed stuff
16:00:12 <jmcarthur> Ontolog: here are some (GHC) primitives http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html
16:00:31 <jmcarthur> Ontolog: don't them unless you have a really good reason to
16:00:40 <jmcarthur> Ontolog: hint: you usually don't have a good reason to use them
16:00:45 <Eduard_Munteanu> Definitely don't them.
16:01:05 <jmcarthur> Ontolog: also, don't use them as a way to understand the language
16:01:10 <jmcarthur> Ontolog: they have nothing to do with haskell proper
16:01:12 <luite_> if you want to implement the next low level package like text you need them
16:01:17 <luite_> for user code, probably not :)
16:01:36 <Ontolog> ah, thanks for all the info, you guys are so thorough
16:02:00 <jmcarthur> they are a great way to get familiar with ghc at least :)
16:02:18 <jmcarthur> and it can be fun to play with them a bit and see if you can somehow do better than ghc's optimizer
16:02:42 <Eduard_Munteanu> Yes, some of the people in here can bore you to death with minute details. :P
16:02:51 <Eduard_Munteanu> Just ask. ;)
16:03:04 <Ontolog> hah, no i really appreciate it actually
16:03:51 <jmcarthur> luite_: what's the distinction between GHC.Prim and GHC.PrimOpWrappers?
16:04:24 <luite_> jmcarthur: i think PrimOpWrappers are real functiosn that you can curry, and GHC.Prim is just a fake module or something
16:04:31 <jmcarthur> i see that the latter doesn't have any type definitions
16:04:37 <jmcarthur> huh, okay
16:04:48 <luite_> oh i might be wrong :)
16:04:57 <luite_> but GHC.Prim is hardcoded in GHC
16:05:01 <jmcarthur> yeah
16:05:14 <Eduard_Munteanu> I suspect a lot of that stuff is re-exported from various other modules.
16:05:22 <luite_> and real primops cant be curried, the coreprep step fixes the code so it doesn't try to do that
16:05:53 <hpc> GHC.Prim is the end of the turtle tower, as it were?
16:06:03 <jmcarthur> definitely
16:06:35 <jmcarthur> yeah it does looks like PrimOpWrappers could conceivably be a way to get currying
16:07:00 <jmcarthur> just redefines the primitives with eta-expansion and adds NOINLINE pragmas
16:07:04 <Eduard_Munteanu> Well, at some point you do have to handle say, number addition somehow, and it's not just an RTS call for obvious performance reasons.
16:07:14 <fryguybob> hpc: It is just different turtles from there on.
16:07:39 <jmcarthur> Eduard_Munteanu: s/RTS/FFI/ ?
16:07:48 <fragamus> howdy
16:07:57 <Eduard_Munteanu> Or that, yeah. I mean, not just a call.
16:08:02 <monochrom> primop is where the turtle tower ends and the russian dolls begin!
16:08:43 <jfischoff> @remember monochrom primop is where the turtle tower ends and the russian dolls begin!
16:08:44 <lambdabot> Done.
16:10:38 <merijn> Ontolog: Things work similar to other compiled language. I mean, C also doesn't really have a notion of addition it just has built-in primitives for addition in assembler. So all C code gets translated to primitive operations and then the compiler produces the assembler for those primitve operations
16:11:48 <Ontolog> ohhh, so all the haskell code in a script will get compiled to these haskell primitives and executed against a vm?
16:12:10 <merijn> Ontolog: Similarly, haskell is translated to haskell's "primitive operations" and then the compiler knows how to turn those into running code (i.e. STG machine code in the case of GHC), which means haskell is implemented in haskell. Parts of the GHC runtime system are implemented in C, though
16:12:32 <Eduard_Munteanu> We prefer to call it a runtime system, rather than VM, though yeah, close.
16:12:38 <Eduard_Munteanu> Also Haskell compiles to native code.
16:13:06 <Ontolog> ah, cool stuff
16:13:19 <Eduard_Munteanu> Eventually all those addition primops get translated to actual asm operations.
16:13:26 <merijn> Ontolog: Well...it depends on how you look at it. The primitve oeprations are compiled down to machine code, but there's also a runtime system which is used, which you could call a VM. Or not, depending on how picky you are about terminology
16:13:53 <Ontolog> im not clear on the distinction
16:13:57 <Ontolog> between a vm and 'runtime system'
16:14:13 <jfischoff> c and c++ both have runtimes
16:14:29 <Ontolog> i just understand vm as taking a set of platform-independent instructions and turning those into platform-dependent ones
16:15:20 <Eduard_Munteanu> Ontolog: it's not like Java, because (1) it doesn't try that hard to abstract the actual machine, and (2) there's no bytecode involved, or anything that would be executed against a VM, as you say (it's all native code, like C)
16:16:30 <Ontolog> so, so what do we call the part that translated haskell into its primitive operations?
16:16:43 <jfischoff> the compiler
16:16:47 <Ontolog> i see
16:16:58 <merijn> Ontolog: haskell code is not platform-independent, it's compiled down to machine code by GHC, much like C and C++
16:17:01 <Ontolog> and the part that turns that into machine code?
16:17:16 <jfischoff> oh wait I too many cooks
16:17:17 <chance> antoher compiler.
16:17:27 <chance> another*
16:17:32 <Ontolog> ok, so it's a 2-stage compilation process and doesn't involve a vm at all
16:17:44 <Ontolog> in the case of ghc
16:17:45 <merijn> It's just that the compiled machine code uses some library functions from the runtime system to function
16:18:09 <merijn> Well, it's 1 stage or something like 5 or 6 stage, depending on how precise you want to be
16:18:35 <chance> there are *a lot* of pieces on compilers and interpreters.
16:18:45 <merijn> Haskell gets translated to Core, which gets translated to Cmm (I think?), which gets translated to something, etc.
16:18:56 <Ontolog> ah, well that's good to understand
16:19:01 <luite_> haskell -> core -> stg -> cmm -> native/llvm
16:19:06 <Ontolog> and I suppose this is all implementation specific right?
16:19:17 <Ontolog> like i heard of haskell being implemented on the parrot vm
16:19:30 <Ontolog> the haskell standard doesn't dictate this does it?
16:19:31 <luite_> Ontolog: the other way around, there's a perl 6 implementation in haskell
16:19:42 <Ontolog> pugs
16:19:52 <luite_> or maybe there's a parrot vm codgen for haskell that i don't know about
16:19:57 <Ontolog> parrot was suppose to support perl and haskell and ruby
16:19:57 <Ontolog> etc
16:20:16 <sproingie> i dont believe parrot was ever targeted for haskell
16:20:27 <Ontolog> ohh ok i must have gotten confused
16:21:00 <sproingie> there was some idea of getting it to run other languages like python, but it never got far, so that track was abandoned a while ago
16:21:22 <luite_> Ontolog: there are some other targets, .NET is in GHC but is probably unmaintained, there's a tracing jit that uses the lua vm i think
16:21:28 <sproingie> (along with the rest of perl6 i'd say)
16:21:44 <luite_> and a bunch of haskell->javascript things
16:22:14 <jmcarthur> i don't care about the distinction between a RTS and a VM. they are the same thing, to me
16:22:22 <sproingie> they're both runtimes
16:22:23 <Ontolog> oh wow haskell -> javascript would be cool, since i do mostly web dev
16:22:42 <merijn> Parrot was implemented in haskell
16:22:52 <sproingie> no, pugs was
16:22:52 <merijn> Ontolog: It's quite far along already
16:23:01 <jmcarthur> Ontolog: pugs was/is implemented in haskell. may be what you are thinking
16:23:06 <sproingie> pugs had its own runtime that was not parrot
16:23:09 <Ontolog> yeah i know about pugs
16:23:20 <Ontolog> i thought that parrot was going to handle haskell as well
16:23:30 <Ontolog> but just a wrong assumption lol
16:23:38 <jmcarthur> i doubt it would be a great fit for haskell
16:23:41 <merijn> I've seen people succesfully compile haskell to javascript and run the resulting code. It's not foolproof yet, there's lots of pitfalls, but very promising
16:23:46 <sproingie> pretty much everything but rakudo is dead in perl6 land.  this is actually a good thing, there's actually a modicum of focus now
16:23:47 <merijn> Just ask luite_ :p
16:23:52 <luite_> Ontolog: in the short term you might be interested in Fay, which is a subset of haskell
16:23:52 <jmcarthur> at least, ghc's execution model is quite different from that of most other languages
16:23:55 <sproingie> but perl6 is still the infinite trainwreck
16:24:20 <Ontolog> yeah perl6 is rediculous
16:24:28 <luite_> Ontolog: i'm working on a more complete haskell->js compiler, but it requires GHC HEAD and some patches
16:24:29 <Ontolog> i was trying to get into it like 3 years ago
16:24:56 <Ontolog> luite_: ah, bleeding edge stuff :) well if i get to that point i'll have to give it a try
16:24:57 <luite_> Ontolog:  in probably 6 months it should be easily installable from hackage
16:24:58 <sproingie> an official release of perl6 is an asymptote, it'll never actually get there
16:25:06 <luite_> Ontolog: when GHC 7.8.1 is out
16:25:11 <Ontolog> luite_: cool
16:25:27 <Ontolog> sproingie: yeah sadly... i started my career in perl and was looking forward to 6, but it seems that ruby has already filled that gap
16:25:48 <jfischoff> and then Haskell replace Ruby ;)
16:25:54 <Ontolog> haha god
16:25:57 <Ontolog> ppl can barely program ruby
16:26:15 <Ontolog> i don't think the masses will be able to handle haskell
16:26:23 <jfischoff> not true
16:26:40 <jfischoff> > sum [1..3]
16:26:43 <lambdabot>   6
16:26:44 <Ontolog> i'm talking like completely average shops
16:27:01 <jfischoff> makes more sense to beginners
16:27:02 <luite_> Ontolog: it's still early, but i'm quite happy with some of the results. you get threading in a js environment, exceptions work, haskell works like you expect :)
16:27:21 <jfischoff> average shops do what they are told ;)
16:27:24 <ion> luite: Very nice
16:27:33 <Ontolog> luite_: that's really amazing actually
16:28:28 <jmcarthur> Ontolog: i think the difficulty of haskell is widely overstated. the difficulty of haskellers, however, is not :)
16:29:00 <luite_> I'm a bit tired of the dataflow analysis stuff that i can't get to work right, so i'm trying to make a fun step by step evaluation heap viewer now :)
16:29:05 <merijn> jmcarthur++
16:29:13 <Ontolog> hah, well i remember when i was trying it out several years ago it self like quite the hurdle, going to give it another shot though
16:29:27 <jmcarthur> it's mostly a mind game
16:29:50 <merijn> Actually, I think one problem with haskell is that we have a lot more code reuse than many other language as a result you need to be familiar with a substantial set of libraries before idiomatic haskell makes sense (Control.* for one)
16:30:05 <jmcarthur> you just have to convince yourself that the new things you're seeing a no crazier than when you were first learning the programming concepts you are now familiar with
16:30:19 <jmcarthur> *are no crazier
16:30:31 <luite_> especially lens ;p
16:30:34 <jmcarthur> merijn: yeah
16:30:46 <jmcarthur> luite_: we should make a pact to never introduce beginners to lens
16:31:03 <luite_> jmcarthur: have you written a profunctor tutorial yet?
16:31:09 <jmcarthur> god
16:31:17 <merijn> jmcarthur: You said lens...now shachaf and edwardk will show up to confuse newbies :<
16:31:18 <luite_> =)
16:31:23 <jmcarthur> (actually profunctors are not all that crazy)
16:31:27 <luite_> i know
16:31:39 <luite_> just like monads :p
16:31:39 <elliott> merijn: I feel left out!!!
16:31:42 <jfischoff> Anything where type inference fails is bad for beginners
16:31:43 <jmcarthur> merijn: "edwardk (~edwardk@pdpc/supporter/professional/edwardk) has quit (Ping timeout: 245 seconds)"
16:31:52 <ijp> can I express numbers directly in hex?
16:32:03 <merijn> I looked at the profunctor explanation, they're not that hard, but I think it'll take awhile before I think of them as natural
16:32:11 <jmcarthur> ijp: yup, just put "0x" in front of the number
16:32:12 <merijn> > 0xAF
16:32:14 <lambdabot>   175
16:32:15 <ijp> jmcarthur: ah of course
16:32:22 <lispy> > 0xFFFFFF
16:32:24 <lambdabot>   16777215
16:32:37 <lispy> > 0x123179
16:32:39 <lambdabot>   1192313
16:34:01 <jmcarthur> merijn: if you are used to thinking about variance or whether a type occurs in positive or negative positions, it's pretty natural
16:34:15 <jmcarthur> admittedly i think haskellers are not typically used to thinking about these things
16:35:11 <jmcarthur> all you really need to know are: (+a, +b), (Either +a +b), (-a -> +b)
16:35:29 <jmcarthur> the negative sign means that you can't define a Functor for that argument, but you can define a Contrafunctor for it
16:35:37 <jmcarthur> (playing a little loose with terminology)
16:35:45 <jmcarthur> which just means the function has to be backward
16:35:51 <jmcarthur> it's "precomposition"
16:36:20 <eikke> I tend to explain variance in an OO/subtyping context: "Given A <: B, is List<A> <: List<B>?"
16:36:27 <jmcarthur> furthermore, if you negate a parameter that is already negative, it's positive
16:36:39 <jmcarthur> e.g.   ((a -> r) -> r)   -- the a is positive here
16:36:56 <jmcarthur> and the r is invariant, since it occurs in both negative and positive positions, so you can't define either kind of functor for it
16:37:28 <jmcarthur> eikke: i am horrible with subtyping and can't reason about that effectively :(
16:37:51 <jmcarthur> i just have to resort to positive and negative positions anyway
16:38:33 <nuttycom> I always think of variance in terms of substitutability.
16:38:56 <eikke> it makes sense for most Java-style devs though :) "If some method takes an A, and a B is subtype of A, that same method can also take a B and treat it as an A. If some method takes a list of As, it could also take a list of Bs and treat all items as As, so A and B are covariant"
16:39:18 <eikke> err, List is covariant
16:39:26 <jmcarthur> my first real encounter with variance is from the world of OCaml in the context of polymorphic variants. was a hard lesson in the complexities of subtyping
16:39:27 <ab9rf> jmcarthur: huh.  i don't understand what you're tlaking about, but you touched on something there that might help me understand it eventually.
16:39:31 * eikke shuts up, it's late
16:39:46 <c_wraith> subtyping is where variance *really* causes headaches
16:40:16 <Ontolog> http://www.haskell.org/haskellwiki/GHCi_in_colour mentioned the --colour option for ghci, but my ghci doesn't understand it
16:40:20 <Ontolog> anyone know about this?
16:40:35 <ab9rf> jmcarthur: a connection with the rules for generics in java
16:40:39 <jmcarthur> ab9rf: the best exercise is to try to define an instance of Functor for the type   newtype Foo a b = Foo (b -> a),  fail, then discover that you can still implement   (c -> b) -> Foo a b -> Foo a c
16:40:52 <jmcarthur> ab9rf: ah, yeah these are all related
16:41:01 <ab9rf> jmcarthur: ok, so that's not just me
16:41:24 <jmcarthur> ab9rf: in positive position, subtyping relationships are preserved. in negative position, they are flipped
16:41:33 <nuttycom> I'm a noob to haskell, but here's something I've been wondering. In OO, inheritance gives you an open set of types and a closed set of operations on those types, with polymorphic dispatch. Typeclasses give you the same, but the dispatch is static instead of dynamic.
16:41:52 <merijn> jmcarthur: Sure, like I said, I get it intellectually. The intuition just isn't there yet
16:42:01 <jmcarthur> nuttycom: not always static. for example, if you have an existential type with a type class constraint, there must be some dictionary passed at runtime
16:42:24 <arkeet> or if you just have a polymorphic function with a typeclass constraint.
16:42:28 <nuttycom> jmcarthur: interesting, how is that dictionary resolved?
16:42:29 <ab9rf> jmcarthur: i'm too sleepy to actually parse it out right now, but there's an intuitive connection that i'll explore later
16:42:34 <arkeet> nuttycom: it's passed around
16:42:35 <jmcarthur> Ontolog: i don't know anything about that. i use a custom pretty printer in mine
16:42:43 <merijn> nuttycom: It's stored together with the value by GHC
16:42:57 <Ontolog> jmcarthur: cool, what package handles the pretty printing?
16:43:00 <jmcarthur> nuttycom: it is inserted concretely at the point where the concrete type becomes an existential type
16:43:02 <jfischoff> jmcarthur: is the pretty printer available?
16:43:03 <arkeet> Foo a => a -> b  is internally  FooDict a -> a -> b
16:43:20 <jmcarthur> Ontolog, jfischoff: it's a stupidly simple thing. i don't have it hackage
16:43:21 <nuttycom> that's a cool approach; it's essentially dynamic reification.
16:43:23 <nuttycom> I dig it.
16:43:50 <jfischoff> jmcarthur: put it on github!
16:43:59 <jmcarthur> nuttycom: in fact, ghc actually uses dictionaries *everywhere*. it's just that they can be optimized away most of the time
16:44:08 <jfischoff> that's where all my stupid things are :p
16:44:15 <lispy> > let f i = read ("0x" ++ show i) :: Integer in iterate f 0x10 -- hexanocci
16:44:17 <lambdabot>   [16,22,34,52,82,130,304,772,1906,6406,25606,153094,1388692,20481682,5415952...
16:44:25 <jmcarthur> i have a github account, but i'm a darcs holdout :(
16:44:34 <arkeet> so typeclasses don't *really* add anything new, since you can always just do explicit dictionary passing.
16:44:42 <arkeet> but that's a pain in the butt.
16:44:44 * jfischoff nods
16:45:03 <merijn> As mercurial fan I feel doubly excluded in the haskell community :p
16:45:05 <arkeet> anyway, the reflection package takes advantage of this representation to make dictionaries at runtime :p
16:45:12 <jmcarthur> merijn: ha!
16:45:22 <jmcarthur> arkeet: wat
16:45:30 <nuttycom> arkeet: that's unfortunate. Coming from Scala explicit dictionary passing is pretty useful when you want locally-scoped dictionaries. I've always wondered how haskell handles that.
16:45:34 <merijn> Fortunately hg-git works pretty well, so I can still use mercurial with github :)
16:46:00 * hackagebot adobe-swatch-exchange 0.1.0.0 - parse Adobe Swatch Exchange files and (optionally) output .css files with the colors  http://hackage.haskell.org/package/adobe-swatch-exchange-0.1.0.0 (JeremyShaw)
16:46:06 <jmcarthur> nuttycom: you can kind of do that, but it's not so useful in practice
16:46:15 <arkeet> @hackage reflection
16:46:17 <lambdabot> http://hackage.haskell.org/package/reflection
16:46:26 <jmcarthur> merijn: yeah, git-darcs interoperation is awful
16:46:40 <merijn> git clobbers file move history, though :(
16:46:43 <nuttycom> jmcarthur: I'm just thinking of scope-dependent equality, scope-dependent ordering, things like that.
16:46:51 <arkeet> whoa, Given is a new addition
16:47:05 <merijn> nuttycom: Usually people just pass a lambda for that
16:47:09 <merijn> :t sortBy
16:47:11 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
16:47:21 <merijn> :t groupBy
16:47:22 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
16:47:26 <merijn> That sorta thing
16:47:38 <jmcarthur> nuttycom: ah i've (recently) done awkward tricks like that give function does
16:47:42 <jmcarthur> woops
16:47:44 <fizbin> @pl \x -> []:concatMap (\y -> map (:y) [1,2,3]) x
16:47:45 <jmcarthur> arkeet: ^^
16:47:45 <lambdabot> ([] :) . (flip map [1, 2, 3] . flip (:) =<<)
16:47:51 <jmcarthur> nuttycom: that wasn't intended for you, sorry
16:48:24 <arkeet> nuttycom: reflection can do that if you really want. :p
16:48:25 <arkeet> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
16:48:43 <nuttycom> arkeet: heh... sounds like somewhere I don't really want to go
16:48:46 <arkeet> heh
16:48:55 <arkeet> but yeah, usually you don't need it.
16:49:44 <merijn> Explicit dictionary passing is really just "passing lambda's" anyway :)
16:50:00 <arkeet> mhm
16:50:03 <nuttycom> Sure, just lambdas that might be able to refer to one another.
16:50:13 <jmcarthur> nuttycom: i don't understand what you mean
16:50:41 <nuttycom> jmcarthur: implementing map in terms of bind, for example
16:50:51 <jmcarthur> what about it?
16:50:52 <merijn> nuttycom: I suspect you'll find this to not be a really siginifcant problem, though
16:51:25 <nuttycom> merijn: Oh, I'm sure not, once I've figured out the haskell way. I have to just shed the other half of my assumptions. :)
16:51:52 <nuttycom> Scala's dragged me halfway to haskell, figure I ought to claw my way the rest of the distance.
16:52:25 <jmcarthur> nah, it only brought you a fifth of the way here :P
16:53:17 <nuttycom> jmcarthur: Perhaps. I do use scalaz religiously though, and wrote a fair bit of its iteratee library, so I'm on my way.
16:53:18 <shachaf> merijn: Why would I "confuse newbies" when I can confuse you?
16:53:22 <bitonic>  nuttycom: I’m going the other way around now—learning a bit of Scala after years of Haskell :)
16:53:24 <monochrom> using zenoization, you can say it's always one half
16:53:34 <bitonic> gotta have a bit of mess once in a while
16:54:41 <eikke> bitonic: haskell cleans your head too much?
16:54:55 <elliott> nuttycom: is it true Scala has no polymorphism over higher-kinded types?
16:54:56 <fizbin> @pl \x -> []:do {a <- [1,2,3]; b <- x; return (a:b)}
16:54:56 <lambdabot> (line 1, column 13):
16:54:56 <lambdabot> unexpected '{'
16:54:56 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
16:55:03 <elliott> fizbin: try @undo first.
16:55:17 <arkeet> @@ @pl @undo \x -> []:do {a <- [1,2,3]; b <- x; return (a:b)}
16:55:17 <lambdabot>  liftM2 (:) [[], 1, 2, 3]
16:55:49 <fizbin> Um, I don't think that's right.
16:55:57 <arkeet> :t \x -> []:do {a <- [1,2,3]; b <- x; return (a:b)}
16:55:59 <lambdabot> Num a => [[a]] -> [[a]]
16:56:00 * hackagebot putlenses 0.0.1 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.0.1 (HugoPacheco)
16:56:04 <jfischoff> elliot: no monad?
16:56:11 <arkeet> @undo \x -> []:do {a <- [1,2,3]; b <- x; return (a:b)}
16:56:12 <lambdabot> \ x -> [] : [1, 2, 3] >>= \ a -> x >>= \ b -> return (a : b)
16:56:14 <bitonic> elliott: <http://adriaanm.github.com/research/2010/10/06/new-in-scala-2.8-type-constructor-inference/>?
16:56:16 <arkeet> yeah that's wrong, haha.
16:56:24 <arkeet> @@ @pl @undo \x -> []:(do {a <- [1,2,3]; b <- x; return (a:b)})
16:56:24 <lambdabot>  ([] :) . liftM2 (:) [1, 2, 3]
16:56:52 <bitonic> eikke: nah I just don’t want to code *only* in Haskell for personal projects and Scala has some nice libraries (Akka for example, waiting for distributed haskell to work propersly...)
16:56:58 <nuttycom> elliott: It's true that you can't speak about meta-kinds directly, but I'm not 100% confident about your question.
16:57:21 <nuttycom> you certainly have kind polymorphism in that you can define a true monad, traverse, etc.
16:57:34 <eikke> bitonic: oh yeah, I wish someone could convince jboner to create hAkka :-)
16:57:41 <arkeet> nuttycom: can you parametrize over monads?
16:57:58 <elliott> nuttycom: maybe I was thinking of OCaml
16:58:02 <bitonic> eikke: distributed-haskell is pretty much that
16:58:10 <ben> hi. could someone sum up the dilemma caused by multi parameter type classes. I only see references to solving it with other extensions but i don't quite get the problem
16:58:11 <nuttycom> trait Monad[M[_]] { def point(a: => A): M[A]; def bind[A, B](m: M[A])(f: A => M[B]): M[B] }
16:58:21 <bitonic> elliott: I’m very much a Scala noob but I’m pretty sure it can do what you’re asking :)
16:58:24 <elliott> ok, that looks like the real deal to me
16:58:25 <nuttycom> And yes, you can parameterize over monads using type members.
16:58:29 <fizbin> I saw a paper a while ago that claimed that Scala with certain implicits was very similar to an intermediate form used in most haskell compilers.
16:58:33 <monochrom> nuttycom: elliott's question means: both haskell and scala have "f :: t -> [t]". now, haskell also has "g :: Int -> m Int" (well, have to add "Functor m"), does scala have that too?
16:58:35 <elliott> such ugly syntax :P
16:58:51 <elliott> monochrom: I think you'll perhaps find Functor m not quite enough for that :)
16:58:56 <eikke> bitonic: it's the groundwork, like basic erlang without otp. akka brings quite some more things to the table (~ otp)
16:59:12 <monochrom> oh, change Functor to another type class
16:59:17 <bitonic> eikke: well right, but we need the groundwork first
16:59:32 <eikke> sure
17:00:14 <nuttycom> In the project I work on, we parameterize over type members so that we can use a call-by-need monad for testing, but Future in production.
17:00:23 <nuttycom> erm, parameterize over monads.
17:00:23 <jmcarthur> elliott: ocaml doesn't have higher kinded types :(
17:00:46 <monochrom> "M[_]" looks like what we want
17:00:48 <jmcarthur> elliott: the best you can do is parameterize one module over another
17:00:59 <elliott> jmcarthur: what, surely you can write a generic "list" type
17:01:05 <elliott> isn't that what 'a list is
17:01:09 <elliott> can you not define that yourself??
17:01:14 <jmcarthur> yes you can
17:01:18 <elliott> ok, phew
17:01:27 <bitonic> in OCaml type constructors are hopelessly inflexible if I recall correctly—you can’t even partially apply them
17:01:29 <eikke> you can define 'a list, but not ('a 'b) list
17:01:36 <bitonic> (or maybe that was SML)
17:01:48 <nuttycom> When you want to parameterize over monads, it's explicit dictionary passing, but with syntactic sugar that makes the explicit passing implicit, if that makes any sense.
17:01:50 <jmcarthur> you can't write something like   type ('a, 'f) mylist = Nil | Cons of 'a 'f * ('a, 'f) list
17:01:56 <nuttycom> You don't have to write out the monad instance you're passing.
17:02:03 <monochrom> MLs have 'a list but not int 'm
17:02:10 <eikke> bitonic: no, ocaml indeed. constructors dont behave like normal functions.
17:02:21 <elliott> right
17:02:24 <elliott> so all type variables are of kind *
17:02:31 <jmcarthur> basically the type system is first order
17:02:32 <eikke> elliott: yes
17:02:39 <eikke> which is highly annoying once in a while :P
17:02:46 <monochrom> you see how the way I phrase the question is very powerful! :)
17:02:47 <jmcarthur> *extremely* annoying :(
17:02:48 <bitonic> more than once in a while
17:02:55 <elliott> nuttycom: like typeclasses but you can have multiple instances for a type, right?
17:02:58 <bitonic> yeah the little I’ve coded in SML was painful
17:03:02 <elliott> (which isn't purely an advantage)
17:03:03 <nuttycom> elliott: correct
17:03:26 <bitonic> ah, implicits!  Scala’s most wondrous feature lol
17:03:46 <eikke> I got stuck on it when trying to port "A Generic Deriving Mechanism" (~ GHC generics) to OCaml
17:03:51 <jmcarthur> the main problem is that ML culture is very attached to being able to define a new type without having to use a constructor to inject into and project out of it
17:03:57 <bitonic> in Scala ‘Some(42) + "blah"’ is "Some(42)blah"
17:04:07 <jmcarthur> which means many of your type constructors are not injective
17:04:11 <bitonic> (Some is Just more or less)
17:04:40 <nuttycom> bitonic: many of us wish  anyToStringAdd (the responsible party for that madness) to be burned at the stake
17:04:48 <bitonic> nuttycom: ehe.
17:04:58 <jmcarthur> so this is related to the fact that you can't partially apply a type synonym in haskell
17:05:12 <bitonic> in Scala + is a method of every object!  you can append a string to anything.
17:05:29 * eikke goes zzz
17:05:32 <jmcarthur> except that in ocaml you can make a type synonym behave like a newtype (apart from lacking constructor) by just making its representation abstract
17:05:35 <otters> heh, implicits...
17:05:37 <nuttycom> bitonic: You can actually disable it, but it's a pain in the ass.
17:05:41 <otters> can't tell where the transformation is? neither can we!
17:05:45 <OlegYch> bitonic: that is not caused by implicits, but by java compatibility
17:05:45 <bitonic> nuttycom: can you?
17:05:53 <nuttycom> The trick is to define another implicit conversion in scope with the same signature.
17:05:55 <bitonic> OlegYch: well it’s made possible by implicits
17:06:02 <bitonic> nuttycom: aha.  great fun.
17:06:06 <nuttycom> bmckenna's "wartremover" project provides a bunch of some such.
17:06:23 <Hayro>  http://www.winterrowd.com/fullscreen/?GameId=10  free  game
17:06:23 <jmcarthur> eikke: yeah we have had a lot of "fun" writing our own generics in ocaml
17:06:24 <nuttycom> With the additional implicit, you get ambiguity and the compiler throws up its hands.
17:06:47 <jmcarthur> hey it's a free game everybody! you know you have to click it! ...
17:07:00 <nuttycom> anyway, off for now but might actually be back with lots of questions if I decide to really try writing some haskell later
17:07:01 <arkeet> @hackage free-game
17:07:01 <lambdabot> http://hackage.haskell.org/package/free-game
17:07:07 <bitonic> nuttycom: I asked about that in #scala a few hours ago and they linked this <https://issues.scala-lang.org/browse/SI-194> and <https://issues.scala-lang.org/browse/SI-7327>
17:07:09 <arkeet> =)
17:07:22 <arkeet> it's free in at least 3 senses of the term.
17:07:34 <merijn> jmcarthur: I enjoy clicking random suspicious links to watch how nothing happens :)
17:07:49 <jmcarthur> i tired of that after a while
17:07:51 <jmcarthur> was amusing at firast
17:07:53 <jmcarthur> *first
17:08:56 <nuttycom> bitonic: well, SIP-18 added features to allow the hiding of certain language features behind compiler pragmas, so some of us are conspiring for a SIP (Scala Improvement Proposal or some such) that's the dual of that - the ability to turn off certain language features with compiler pragmas.
17:09:19 <nuttycom> martin's opposed, of course, but that's to be expected
17:09:41 <sw2wolf> In mhDigitToInt (W8# i) = I# (word2Int# (indexWord8OffAddr# addr (word2Int# i))) , what does w8# and  I#  mean ?
17:09:46 <bitonic> I think Haskell with IncoherentInstances and ImpredicativeTypes turned on by default would be great
17:10:30 <merijn> ...
17:10:49 <merijn> Everytime I use ImpredicativeTypes I get yelled at in here :<
17:10:56 <monochrom> I# is the data constructor of Int
17:11:02 <bitonic> merijn: haters gonna hate
17:11:05 <arkeet> I keep forgetting what ImpredicativeTypes is supposed to solve.
17:11:07 <monochrom> W8# may be the data constructor of Word8
17:11:21 <merijn> arkeet: "Maybe (forall a. a)"
17:11:23 <sw2wolf> monochrom: W8# is constructor for Word8 ?
17:11:33 <monochrom> maybe. I have not checked.
17:11:35 <merijn> sw2wolf: Yup
17:11:44 <arkeet> merijn: who would want that?
17:11:46 <merijn> sw2wolf: Well, probably. I haven't checked either :p
17:12:03 <merijn> arkeet: Me, when I use GADTs + DataKinds to enforce constraints in the type system
17:12:22 <monochrom> if you look through the haddocks of those GHC.* modules, you may find them
17:12:30 <arkeet> I'll think about it some other time.
17:12:32 <merijn> Sometimes I have values of different types, which are really just the same type with different constraints
17:12:35 <monochrom> I am too lazy to look
17:12:44 <shachaf> i love monochrom
17:12:45 <shachaf> he is so lazy
17:13:18 <no-n> I'll do it tomorrow!
17:13:29 <monochrom> in general, impredicative type means: whenever you want to instantiate a type variable, you can instantiate it too... a forall type!
17:14:08 <monochrom> therefore, when you see "Maybe a -> a", you can instantiate it to "Maybe (forall b. b->b) -> (forall b. b->b)"
17:14:43 <DiegoNolan> ls
17:15:16 <monochrom> $
17:16:01 <S11001001> ln -s . ./blah; find blah -name boo -print
17:16:14 <merijn> btw, is it possible to have impredicative channels? I haven't tried before and I'm lazy...
17:16:36 <monochrom> time limit exceeded
17:16:41 <merijn> i.e. "Chan (forall a. a)" so that readChan :: Chan (forall a.a) -> (forall a . a)
17:17:00 <monochrom> it is as possible as impredicative types
17:17:31 <monochrom> currently, GHC's impredicative type extension does not function properly. therefore, you must be disappointed
17:18:11 <sw2wolf> @wn impredicative
17:18:12 <lambdabot> No match for "impredicative".
17:18:17 <sw2wolf> @wn predicative
17:18:18 <lambdabot> *** "predicative" wn "WordNet (r) 3.0 (2006)"
17:18:18 <lambdabot> predicative
17:18:18 <lambdabot>     adj 1: of adjectives; relating to or occurring within the
17:18:18 <lambdabot>            predicate of a sentence; "`red' is a predicative
17:18:18 <lambdabot>            adjective in `the apple is red'" [ant: {attributive},
17:18:18 <monochrom> until, you just crank up RankNTypes and go "newtype Workaround = W (forall a. a)" and then it's just Chan Workaround
17:18:20 <lambdabot>            {prenominal}]
17:19:02 <shachaf> That's not even RankNTypes, it's just PolymorphicComponents.
17:19:21 <shachaf> Can you believe PolymorphicComponents isn't in Haskell 98?
17:20:02 <sw2wolf> @ty (<*>)
17:20:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:20:36 <c_wraith> Technically, polymorphic components make the constructor higher-rank.
17:21:02 <shachaf> c_wraith: Get your details out of here!
17:21:06 <DiegoNolan> How do I make this work?  What should the type be
17:21:18 <DiegoNolan> Data.ListLike.replicate 10 (3 :: Int)
17:21:35 <arkeet> what do you mean by "work"?
17:21:38 <DiegoNolan> compile
17:22:02 <arkeet> that piece of code is fine by itself.
17:22:07 <monochrom> that thing alone wouldn't compile. but perhaps you already know. show complete actual code
17:22:19 <DiegoNolan> I'm tying it into ghci
17:22:30 <arkeet> and you're getting an ambiguous type error.
17:22:39 <arkeet> because you're not specifying the type of the container.
17:22:43 <DiegoNolan> No instance
17:22:51 <DiegoNolan> Yeah, but I have no idea what it should be
17:23:00 <monochrom> do you want a list?
17:23:09 <c_wraith> Well, if you have no clue, how would the compiler?
17:23:17 <DiegoNolan> Well I want a listlike array
17:23:35 <arkeet> then tell it that you want an array.
17:23:43 <Sgeo> Aww. I found a GHC bug, but apparently it's fixed in 7.6
17:24:02 <c_wraith> Sgeo: gotta find them faster.
17:24:14 <arkeet> replicate 10 3 :: Array i Int   -- put your index type for i there.
17:24:17 <monochrom> I have not played with ListLike. I don't know which array types qualify. (and yes, there are several array types, not just one)
17:24:39 <arkeet> well, Data.Array.Array is the one that has the ListLike instance.
17:25:26 <c_wraith> DiegoNolan: by the way, "ListLike" is a property a type might have. It isn't a modification of a type.
17:25:46 <__op> instance Jacky (Chan a)
17:26:12 <monochrom> actually, you know what, "instance Jacky Chan" is also acceptable :)
17:26:28 <DiegoNolan> Ic
17:26:35 <arkeet> DiegoNolan: ListLike is a typeclass.
17:26:56 <DiegoNolan> Data.ListLike.replicate 10 (3 :: Int) :: Array Int Int
17:26:57 <DiegoNolan> works
17:27:03 <arkeet> sure.
17:27:04 <DiegoNolan> why does it show the indexs as tuples
17:27:18 <DiegoNolan> next to the values
17:27:28 <arkeet> because that's how Array's Show instance works.
17:27:34 <__op> yes a simple data Jacky Chan = Maybe Chan
17:27:34 <monochrom> I am wondering why you're playing with ListLike and whether you need to, especially since you don't have an expectation.
17:28:03 <merijn> shachaf: heh, I've never heard of PolymorphicComponents?
17:28:23 <DiegoNolan> I'm wondering the same thing.
17:28:41 <merijn> And I read the entire GHC manual of extensions recently!
17:30:04 <ctult> Does Haskell have pipes (|>) natively?
17:30:14 <arkeet> "natively"?
17:30:23 <monochrom> chapter 7 is unlikely to list all extension names. chapter 4 last section (flag reference) does list all
17:30:29 <merijn> What's a pipe?
17:30:40 <hpc> just about everything interesting in haskell is a library
17:30:40 <merijn> shachaf: Tell me more about PolymorphicComponents!
17:31:06 <shachaf> merijn: It means you can have data Foo = Foo { x :: forall .... ... }
17:31:11 <shachaf> x is a component that is polymorphic.
17:31:28 <ctult> Okay, does Haskell have pipes?
17:31:33 <ctult> at all?
17:31:35 <arkeet> what are pipes?
17:31:44 <ParahSail1n> ctult, yes, haskell can emit to fd1, fd2, and receive from fd0
17:31:51 <merijn> GHC has been pointing me in the wrong direction with its "did you mean ImpredicativeTypes" thing...
17:32:06 <hpc> ctult: well, when you take tubes and put them in a series you get the internet...
17:32:07 <ParahSail1n> @faq can haskell pipe?
17:32:07 <lambdabot> The answer is: Yes! Haskell can do that.
17:32:08 <merijn> I need to look into this
17:32:15 <ctult> no, a |> b |> c would run c(b(a))
17:32:24 <ctult> The |> part is a pipe.
17:32:26 <ctult> Like in ML
17:32:28 <merijn> That's just function composition in reverse, isn't it?
17:32:30 <hpc> that's not a pipe
17:32:35 <merijn> :t (%)
17:32:35 <arkeet> that's flipped function application.
17:32:37 <lambdabot>     Not in scope: `%'
17:32:37 <lambdabot>     Perhaps you meant `R.%' (imported from Data.Ratio)
17:32:38 <arkeet> :t (&)
17:32:40 <lambdabot> a -> (a -> b) -> b
17:32:42 <ctult> merijn: no
17:32:59 <arkeet> > a & f & g :: Expr
17:33:00 <lambdabot>   Ambiguous type variable `a0' in the constraints:
17:33:01 <lambdabot>    (GHC.Show.Show a0)
17:33:01 <lambdabot>     ...
17:33:04 <arkeet> oh great.
17:33:29 <ctult> What I am asking is if I can do this:
17:33:31 <ctult> let (|>) v f = f v
17:33:31 <ctult> let (|<) f v = f v
17:33:38 <merijn> Why not
17:33:39 <ctult> have to*
17:33:39 <arkeet> you sure can.
17:33:56 <fizbin> > (+3) & (*2) & 1
17:33:57 <arkeet> we already have f $ x = f x in Prelude.
17:33:58 <lambdabot>   1
17:33:59 <merijn> > let (|>) v f = f v in 5 |> show
17:34:00 <lambdabot>   "5"
17:34:09 <arkeet> the flipped version isn't in a standard library.
17:34:21 <c_wraith> It is in lens, though
17:34:27 <arkeet> > 5 & show
17:34:29 <merijn> > let (|>) v f = f v in 5 |> show |> (++"!")
17:34:29 <lambdabot>   "5"
17:34:30 <fizbin> > 1 5
17:34:31 <lambdabot>   "5!"
17:34:32 <lambdabot>   1
17:34:40 <fizbin> Ugh, I was afraid of that.
17:34:48 <merijn> fizbin: You've been Caleskelled!
17:34:49 <arkeet> > "abc" & length & show & (++"!!")
17:34:51 <lambdabot>   "3!!"
17:35:07 <fizbin> Weren't we going to wipe out NumInstances?
17:35:09 <arkeet> it's not a big deal.
17:35:14 <arkeet> fizbin: it returned somehow.
17:35:23 <arkeet> Cale: is NumInstances intentionally back?
17:36:02 <arkeet> if not, could you take it out? and also fix (.) too?
17:36:02 <monochrom> in general, you will never get rid of special interest groups getting their special interests on lambdabot
17:36:03 <arkeet> :p
17:36:26 <arkeet> :t flip
17:36:27 <lambdabot> (a -> b -> c) -> b -> a -> c
17:36:56 <fizbin> monochrom: So what you're saying is we need a loud SIG with something to put into lambdabot that's deeply incompatible with NumInstances...
17:36:59 <monochrom> and Cale will say, (.) is already corrected, it's his correction, you're asking "could we wrong (.)?"
17:37:16 <Cale> What's wrong with (.) now?
17:37:22 <ion> :t (.)
17:37:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:37:28 <arkeet> whoa
17:37:35 <ctult> Is Ruby a good functional-style language?
17:37:37 <Cale> I could fix it back to the way it was, if that's what you're asking :)
17:37:41 <fizbin> :t (++)
17:37:42 <monochrom> > id . [1,2,3]
17:37:42 <lambdabot> Monoid m => m -> m -> m
17:37:43 <arkeet> no, it's fine!
17:37:44 <lambdabot>   Couldn't match expected type `a0 -> c0' with actual type `[t0]'
17:37:44 <ion> This (.) is fine. Thanks for switching to it.
17:37:46 <__op> :t (.)(.)
17:37:47 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
17:37:50 * arkeet <3 cale
17:37:53 <otters> :t (.).(.)
17:37:54 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:38:03 <Hermit> ctult: pff, no
17:38:07 <arkeet> Cale: so what about NumInstances?
17:38:08 <monochrom> I apologize
17:38:17 <Cale> What about them?
17:38:19 <Eduard_Munteanu> Or make it like (<<<) :)
17:38:23 <arkeet> are they supposed to be back?
17:38:29 <arkeet> > 1 2 3
17:38:30 <lambdabot>   1
17:38:38 <Cale> Is that a problem?
17:38:50 <arkeet> we took them out once.
17:39:24 <otters> :t (<<<) <<< (<<<)
17:39:25 <lambdabot> Control.Category.Category cat => cat b c -> (a -> cat a1 b) -> a -> cat a1 c
17:39:25 <monochrom> perhaps we need to say, on odd days, 1 2 should make sense, and on even days, 1 2 should not make sense
17:39:54 <c_wraith> Ok, so we need to set what modules are imported by a cron script.
17:39:59 <no-n>     data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) -- how would I right over >1 lines/
17:40:05 <Cale> c_wraith: Or just some Template Haskell :)
17:40:16 <shachaf> Cale: Well, it's confused people before.
17:40:19 <Cale> Oh, wait, can you control imports in TH?
17:40:22 <arkeet> no-n: by inserting line breaks.
17:40:26 <c_wraith> no, TH can't affect imports.
17:40:28 <c_wraith> CPP can
17:40:34 * elliott would rather see NumInstances gone too, fwiw
17:40:39 <croikle> otters: let <<<<<<<<< = (<<<) <<< (<<<) :D
17:40:39 <Cale> Yeah, CPP isn't powerful enough though
17:40:43 <__op> :t (1 2 3)
17:40:45 <lambdabot> Num t => t
17:40:50 <c_wraith> back to cron!
17:40:51 <no-n> how do I write a line break?
17:40:55 <otters> croikle: (<<<<<<<<<)*
17:41:01 <arkeet> no-n: oh, are you trying to do that in ghci?
17:41:09 <__op> > 1 2 3 == 1
17:41:10 <lambdabot>   True
17:41:11 <no-n> no
17:41:17 <Cale> no-n: Just indent the following line a bit more
17:41:22 <arkeet> no-n: I don't see what the pr--oh.
17:41:38 <Cale> no-n: Typically, the style is to line up the |'s with the =
17:41:59 <arkeet> and you can put deriving on its own line.
17:42:10 <arkeet> as long as each line after the first is indented by some amount.
17:42:12 <__op> > 1   2  "foo" == 1
17:42:13 <lambdabot>   True
17:42:39 <arkeet> @check \x -> 1 x == 1
17:42:40 <lambdabot>   Not in scope: `myquickcheck'
17:42:43 <arkeet> oh.
17:42:48 <no-n> ok
17:43:04 <c_wraith> > map (sin^2 + cos^2) [1..10]
17:43:06 <lambdabot>   [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.999...
17:43:11 <__op> o lambdabot is a checker also
17:43:30 <c_wraith> Hmm. Is that always going to error downwards if it does?
17:43:30 <arkeet> lispy: how come OpenGL has its own copy of StateVar now?
17:44:04 <arkeet> > filter (\x -> (sin^2 + cos^2) x > 1) [1..1000]
17:44:05 <lambdabot>   [50.0,89.0,96.0,159.0,200.0,211.0,242.0,271.0,329.0,375.0,433.0,450.0,480.0...
17:44:15 <c_wraith> guess not, but it does seem rare
17:44:32 <__op> > ("foo" "bar") :: String
17:44:33 <lambdabot>   The function `"foo"' is applied to one argument,
17:44:33 <lambdabot>  but its type `[GHC.Types....
17:44:33 <sw2wolf> @ty unsafePerformIO
17:44:35 <lambdabot> Not in scope: `unsafePerformIO'
17:44:46 <sw2wolf> :t unsafePerformIO
17:44:47 <lambdabot> Not in scope: `unsafePerformIO'
17:44:58 <sw2wolf> @hoogle unsafePerformIO
17:44:59 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
17:44:59 <lambdabot> Foreign unsafePerformIO :: IO a -> a
17:46:34 <finishingmove> how can i see the current directory that GHCi is running in ?
17:46:42 <sw2wolf> :pwd
17:46:45 <sw2wolf> :!pwd
17:47:44 <no-n> if I wanted to write that in ghci, how would I make it continue after the line "data Shape"? I have :set +m
17:48:41 <arkeet> no-n: the same way. don't forget to indent.
17:48:50 <sw2wolf> seems :{ --- :}
17:49:34 <fxr>  /j #haskell-lens
17:49:37 <fxr> ups
17:49:38 <no-n> ah
17:50:14 <arkeet> and yeah, you can use :{ and :} for multi-line input too.
17:50:25 <arkeet> possibly easier than :set +m
17:50:28 <jmcarthur> yay (.) is normal!
17:50:32 <no-n> yeah
17:50:38 <arkeet> yay!
17:51:21 <sm> hey all.. I'm using #if MIN_VERSION_directory(1,2,0) as recommended by cabal docs. Why do I get error: missing binary operator before token "(" if I compile with ghc or ghc -cpp ?
17:52:01 <arkeet> sm: probably because MIN_VERSION_directory isn't defined.
17:52:19 <arkeet> unless you build with cabal.
17:54:32 <ctult> What do all of you prefer over the other: Ruby or Python?
17:54:58 <c_wraith> There's not a huge distinction between them.
17:55:24 <ctult> c_wraith: They are totally different...
17:55:25 <monochrom> I prefer haskell
17:55:49 <ctult> monochrom: Me too, but sadly, there is no JVM implementation of Haskell.
17:55:53 <dolio> Do you prefer burnt caramel ice cream or salted caramel ice cream?
17:56:08 <shachaf> dolio: salted hth
17:56:13 <ctult> dolio: salted
17:56:15 <c_wraith> They both have a lot of conceptually really dirty habits baked into their cultures, they have similar semantics. In the end, go with whichever appears to have the better libraries.
17:56:33 <c_wraith> (for your particular task, that is)
17:56:51 <ctult> c_wraith: I prefer Ruby's syntax.
17:56:56 <ctult> At least it's not Java.
17:57:02 <c_wraith> they both have pretty terrible syntax.
17:57:09 <c_wraith> python is keyword-heavy
17:57:12 <ctult> c_wraith: At least it's not Java.
17:57:13 <c_wraith> ruby is punctuation-heavy
17:57:18 <shachaf> ctult: I think the point some people are making is that this is pretty off-topic for this channel.
17:57:25 <monochrom> I don't understand why JVM is relevant to what *I* prefer
17:57:38 <hpc> python has a not particularly benevolent dictator
17:57:46 <shachaf> Also it's one of those "useless arguments" that get people angry and accomplish nothing.
17:57:58 <hpc> oh, this isn't -blah?
17:57:59 <ctult> meh
18:00:37 <Sgeo> I guess Haskell can't detect when I do something that may end up needing IncoherentInstances later?
18:01:03 <__op> > Pi - 3
18:01:05 <lambdabot>   Not in scope: data constructor `Pi'
18:01:06 <monochrom> I guess it can't, too.
18:01:17 <c_wraith> Well, IncoherentInstances are a case of overlapping instances.
18:01:22 <__op> > PI - 3
18:01:24 <lambdabot>   Not in scope: data constructor `PI'
18:01:26 <monochrom> you need lowercase pi, haskell is not mathematica
18:01:34 <c_wraith> Before you write an overlapping instance, there's no need for the extension
18:01:45 <__op> yes I know /query lam..
18:01:58 <Sgeo> I didn't need an extension to compile the instances, just to use them
18:02:13 <c_wraith> Yeah, that's common
18:02:17 <c_wraith> I'm not sure why, though
18:02:21 <__op> @hoogle PI
18:02:22 <lambdabot> Prelude pi :: Floating a => a
18:02:22 <lambdabot> Data.Fixed type Pico = Fixed E12
18:02:22 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles module Graphics.Rendering.OpenGL.GL.PixelRectangles
18:03:43 <__op> > pi- 3.141592653589793
18:03:44 <lambdabot>   0.0
18:03:56 <shachaf> > pi- 3.141592653589793 :: CReal
18:03:58 <lambdabot>   0.0000000000000002384626433832795028841972
18:04:43 <__op> > (pi- 3.141592653589793)*10^16
18:04:45 <lambdabot>   0.0
18:05:02 <__op> > (pi- 3.141592653589793)*10^16 :: CReal
18:05:04 <lambdabot>   2.3846264338327950288419716939937510582098
18:05:18 <Hafydd> {-# Language IncoherentSyntax #-}
18:05:56 <Sgeo> Is there anyway to say "not a function" as a requirement in an instance declaration?
18:06:12 <monochrom> no
18:06:29 <elliott> well, technically probably yes. but...
18:06:37 <elliott> (I bet cmccann could do it.)
18:06:54 <c_wraith> I think there are hacks that let you express type-inequality as a constraint.
18:06:59 <c_wraith> But you should be afraid of them
18:07:21 <merijn> I can (unfortunately) tell you the elliott and c_wraith are right :(
18:07:40 <merijn> Which made the type function I wanted to write rather impossible :\
18:07:57 <cmccann> elliott: I think the state of the art there hasn't progressed beyond oleg's scary hacks
18:08:18 <finishingmove> i did ":l myFile" in GHCi, how would i exit this mode?
18:08:26 <c_wraith> finishingmove: :l
18:08:27 <Hafydd> :l
18:08:32 <finishingmove> duh.. thanks :)
18:08:35 <merijn> It'd be really neat if you could distinguish between "function" and "not function" so you have a nice terminal case for your recursion :\
18:08:36 <elliott> :l looks like a smiley.
18:08:48 <shachaf> I,I I,I looks like an owl face
18:08:52 <cmccann> also, a "not a function" requirement on an instance would still match functions on the instance head
18:08:56 <Hafydd> A slightly self-satisfied smirk.
18:09:04 <Hafydd> For knowing the answer.
18:09:50 <c_wraith> Anyway, I'm pretty sure there's no brand of type hackery that would let you detect that State s a is a function
18:10:23 <merijn> c_wraith: I don't think that's what he wants anyway
18:10:45 <Sgeo> I'm trying to get this insanity to work
18:11:04 * hackagebot binary-file 0.14.1 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.14.1 (YoshikuniJujo)
18:11:07 <c_wraith> It's more of a philosophical objection. There are things that "are" functions at some level that are not function types.
18:11:09 <Sgeo> http://codepad.org/DDnLRM7i
18:11:45 <merijn> c_wraith: In my case I just want to detect function types
18:13:14 <sm> arkeet: sorry (lost the window) and thank you. I sheepishly remember asking and being answered the same way quite recently. Too much multi-tasking >:|
18:13:26 <c_wraith> actually, Reader r a would have been a better example.
18:13:40 <arkeet> sm: ??
18:13:54 <arkeet> oh
18:14:07 <arkeet> (I lose track of who I answered easily.)
18:14:28 <sm> I rely on emacs search.. thx!
18:15:31 <sm> yes now I remember.. I must now include cabal's macros file when building without it
18:17:07 <sm> -optP-include -optPhledger/dist/build/autogen/cabal_macros.h
18:20:00 <cmccann> lispy: you around?
18:59:10 <lispy> cmccann: yes
18:59:13 <lispy> cmccann: what's up?
18:59:19 <lispy> cmccann: I'm hoping to leave soon
18:59:28 <cmccann> lispy: oh, don't let me keep you then
18:59:37 <lispy> if it's quick I don't mind :)
18:59:42 <cmccann> just was gonna ask about the changes in the latest OpenGL
18:59:50 <cmccann> you're still maintaining that, right?
18:59:53 <lispy> yes
19:00:00 <lispy> Not much changed in the latest release.
19:00:08 <cmccann> mostly wondering if there's any reason to use previous version(s)
19:00:10 <lispy> Just folded some separate packages back in for the platform
19:00:18 <cmccann> lots of API changes but seemed like not much else
19:00:20 <lispy> none that I'm aware of
19:00:35 <lispy> In fact, more recent versions should have better performance
19:00:40 <cmccann> I'm writing some lenses for all the VectorN VertexN &c. stuff
19:00:50 <lispy> There was a change in OpenGLRaw that made it so that you get better RULES firing
19:00:51 <cmccann> and don't feel like supporting the previous version unless I need to :P
19:01:03 <cmccann> having it all in OpenGL seems nicer
19:01:05 * hackagebot diagrams-builder 0.3.0.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.3.0.1 (BrentYorgey)
19:01:06 <jmcarthur> forget the old versions
19:01:20 * lispy nods at jmcarthur 
19:01:23 <cmccann> ok, works for me
19:01:28 <lispy> cmccann: I hope that  helped. I'm going to split :)
19:01:31 <cmccann> yep!
19:01:32 <lispy> ttyl
19:01:32 <cmccann> thanks
19:01:37 <lispy> yw
19:09:49 <hpaste> “Anonymous Coward” pasted “infinite input stream” at http://hpaste.org/85127
19:10:23 <geekosaur> whoever that was: sequence on IO will never return
19:10:38 <jocolloman> Hi all, I am trying to create an infinite stream of characters from user input and would like something like what I just posted
19:10:44 <jocolloman> I know that sequence will never return
19:11:00 <jocolloman> my solution was to just pass around an [IO Char] and unwrap it later
19:11:48 <S11001001> jocolloman: Stream in the streams package probably has a fold function that you might find suitable
19:11:51 <elliott> jocolloman: you can use getContents
19:11:59 <elliott> jocolloman: it's kind of evil though.
19:12:22 <jocolloman> elliott: evil?
19:12:33 <elliott> evil. because it's lazy IO
19:12:40 <S11001001> that is, there exists (a -> b -> b) -> Stream a -> b
19:12:44 <elliott> note that if you're passing around [IO Char], then all elements of your list are equal
19:12:53 <elliott> i.e., you have [getChar,getChar,getChar,getChar,...]
19:13:02 <elliott> and can simply replace anything that accesses from that list in your program with getChar
19:13:46 <jocolloman> S11001001: Thanks! I will check it out.
19:14:00 <jocolloman> elliott: Ah, that makes sense.
19:14:29 <elliott> (if that works, then it's probably preferable to using lazy IO -- more predictable)
19:16:34 <Cale> Lazy I/O is not all that unpredictable, and it's not really all that bad in many cases. It's just when you want to have more control over resources (i.e. be concerned about the number of open filehandles for instance) or you really want to handle exceptions well that it really becomes a concern.
19:17:24 <Cale> If you're writing a program whose main business is opening one big file and doing something with the contents, or processing its standard input into some other form, it's not so bad.
19:20:33 <Cale> In fact, jocolloman, you may like to know about interact
19:20:35 <Cale> :t interact
19:20:38 <lambdabot> (String -> String) -> IO ()
19:21:05 * hackagebot uuid 1.2.10 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.10 (AntoineLatter)
19:21:23 <Cale> jocolloman: This produces a program which reads from stdin and writes a function of the input string to stdout, lazily
19:21:52 <jocolloman> Cale: Interesting I was unaware of interact
19:44:16 <kristof> Have any of you guys ever wished for first-class types, and with good reason?
19:44:28 <kristof> Not just talking about type instances
19:44:30 <shachaf> I've wished for it with bad reason.
19:44:34 <shachaf> Does that count?
19:44:35 <dmwit> See also: agda.
19:44:40 <kristof> shachaf: no
19:44:47 <kristof> I'm just wondering, out of curiousity.
19:44:55 <kristof> *curiosity
19:45:07 <Cale> kristof: What do you mean by first class types?
19:45:14 <kristof> Cale: I mean types as first class citizens.
19:45:16 <Cale> Dependent types?
19:45:32 <kristof> Dependent types are a great way of introducing first class types, but that's not necessarily the same.
19:45:40 <kristof> I'm just talking about first class types in general.
19:46:32 <kristof> I was thinking, and my non-rigorous academic background is probably faulting enough so that this would never work, but I was thinking about a scenario in which "dirty" types could be generated in haskell during runtime.
19:46:32 <cmccann> kristof: I think that's too much generality to remark on
19:46:39 <kristof> cmccann: Probably.
19:46:47 <Cale> I'm not sure what kind of type system you're thinking of
19:47:11 <cmccann> I'm not seeing what wouldn't be covered under dependent types, stuff like Data/Typeable, or type-level computation like type families
19:47:45 <dmwit> What is a dirty type?
19:47:54 <Cale> Yeah, that's a decent question :)
19:48:02 <kristof> Anyway, the same way that Haskell separates side effects and purity through the use of monads, "dirty" types could be omitted from Hindley-Milner checking during compilation
19:48:15 <kristof> Simply because first class types ruin HM in general
19:48:18 <Cale> You can already, via polymorphic recursion, have programs which use values of infinitely many types at runtime.
19:48:20 <kristof> Am I correct?
19:48:28 <Cale> (In Haskell 98 even)
19:48:54 <kristof> Polymorphic recursion is not quite the same thing as generating a new type sometime during execution.
19:49:00 <cmccann> GHC haskell long since gave up on all types being inferable
19:49:28 <sproingie> isn't it effectively the halting problem?
19:49:29 <kristof> It still uses the HM type inference algorithm during compile-time, though
19:49:45 * elliott doesn't understand kristof's goals.
19:49:49 <kristof> I'm sorry, I'm all over the place
19:49:53 <Cale> kristof: Types are properties of the program which are verified at compile time.
19:50:03 <kristof> You're right, I don't understand my goals either
19:50:06 <kristof> Cale: In Haskell.
19:50:17 <Cale> Well...
19:50:20 <cmccann> kristof: you probably have a potentially well-defined idea that you don't have the background knowledge to explain clearly :P
19:50:28 <sproingie> ghc is the perl regex of type systems :)
19:50:38 <kristof> cmccann: No, I don't think it's well-defined at all, and I most certainly don't have the necessary knowledge.
19:50:51 <kristof> Essentially, the only thing I'm trying to talk about is first-class types.
19:50:53 <Cale> I guess you can redefine what types are, but then you start having to ask why use the word "type" at all.
19:50:56 <sproingie> abuseable in so many happy fun evil ways
19:50:59 <pdxleif> kristof: Check out idris - it looks almost just like haskell, but types are first-class values (no seperate namespaces for types and values)
19:51:03 <kristof> Which dynamic languages have because an untyped lambda calculus can do that.
19:51:12 <kristof> pdxleif: Statically typed:
19:51:15 <kristof> *?
19:51:23 <kristof> I think I've heard of it
19:51:23 <sproingie> pdxleif: i imagine it drops the uppercase-for-types thing then?
19:51:40 <pdxleif> Yep
19:51:49 <kristof> pdxleif: I'll look that up, thank you.
19:51:55 <Cale> uh, no
19:52:00 <sproingie> interesting.  how's idris's runtime performance?
19:52:02 <Cale> Constructors are still uppercase
19:52:08 <Cale> in idris
19:52:17 <kristof> I guess what brought this on was that I was thinking about what makes macros nonexistant in Haskell.
19:52:23 <pdxleif> data Person = mkPerson String Int
19:52:29 <Cale> kristof: They exist
19:52:33 <Cale> kristof: See Template Haskell
19:52:34 <dmwit> kristof: idris is just another dependently-typed language. So if you know what dependent types are, and find them lacking compared to your wild imagination, I doubt you will be satisfied with idris.
19:52:34 <cmccann> idris is dependently typed but not trying to be a theorem prover, or something like that, right?
19:52:35 <kristof> Cale: Not in the LISP sense
19:52:40 <sproingie> kristof: TH has macros
19:52:41 <Cale> kristof: See Template Haskell
19:52:44 <kristof> Cale: Template Haskell is only close, as far as I know
19:52:49 <Cale> No, it's macros
19:52:49 <kristof> ...but you guys probably know more.
19:52:51 <kristof> Okay.
19:52:52 <dmwit> kristof: (Have you said yet what it is about dependent typing that doesn't live up to your imagination, by the way?)
19:52:57 <cmccann> TH suffers more from Haskell's syntax than its type system.
19:53:16 <sproingie> i've yet to find someone who professes unqualified love for TH
19:53:29 <Cale> Yeah, people don't use TH except when they really really need to because Haskell's syntax is complicated, so generating it at compile time can be sort of awkward.
19:53:30 <kristof> dmwit: I like static typing. And dependent typing messes with HM. My imagination is not a good standard to judge by, in any case.
19:53:37 <pdxleif> He just gave some lectures on it recently - http://edwinb.wordpress.com/blog/
19:53:39 <simpson> sproingie: Well, they should obviously be importing it qualified. :3
19:53:42 <Cale> But apart from that, it's the exact same idea :P
19:53:52 <sproingie> simpson: Joke.drumfill
19:53:59 <dmwit> kristof: Depedent types are static. Although HM doesn't work as-is, there is still a lot of inference that can be done.
19:54:11 <pdxleif> But basically, cabal install idris, then the "idris" command is the equivalent of ghc / ghci
19:54:26 <Cale> kristof: Just about any meaningful extension of HM tends to lose type inference.
19:54:29 <kristof> dmwit: But is there necessarily type-safety? Dependently typed systems can also suffer from a lot of type complexity.
19:54:36 <Cale> kristof: Haskell 98 doesn't even have complete type inference
19:54:39 <cmccann> dmwit: and your second sentence is also true of GHC Haskell
19:54:45 <Cale> (because of type classes)
19:54:51 <kristof> Hmm.
19:54:52 <kristof> I see.
19:55:02 <shachaf> Cale: And polymorphic recursion.
19:55:08 <Cale> Indeed!
19:55:10 <dmwit> kristof: Yes, dependent types are necessarily type-safe. If the compiler accepts your program, it will never go wrong at runtime.
19:55:23 <kristof> I've just been interested in type systems lately, but I don't have that computer scientist background to talk about it. I'm just a mathematician.
19:55:24 <pdxleif> sproingie: I think ranging from a couple times slower to horribly slower than GHC, at the moment.  But he says he thinks it can beat GHC in the future, taking advantage of the extra type information it has to morph execution, etc.
19:55:38 <Cale> kristof: What kind of mathematics? :)
19:55:46 <pdxleif> C backend, w/ recently added Java & JavaScript backends.
19:55:50 <shachaf> dmwit: All you need to do is define "going wrong" as a type error!
19:56:09 * cmccann defines puns as a type error
19:56:12 <kristof> Cale: Mathematical analysis, mostly. But I like like like abstract algebra, and I've, er, been afraid of but wanting to touch on topology as of late
19:56:31 <Cale> kristof: Are you aware of Voevodsky's program, and homotopy type theory?
19:56:41 <kristof> Cale: Neither!
19:56:48 <cmccann> kristof: that's no worse of a starting point for type theory than many branches of computer science
19:56:48 <sproingie> pdxleif: huh, i ought to check it out sometime.  'course, i barely understand *haskell* as it is
19:56:49 <Cale> http://homotopytypetheory.org/
19:57:18 <pdxleif> It's just like haskell, only w/out the cool parts like laziness and type inference.  woo
19:57:30 <sproingie> no type inference?  ow.
19:57:57 <pdxleif> But the compiler can assert that your programs will terminate and not crash.
19:58:00 <kristof> cmccann: Computer science with an emphasis on formal logic and type-theory is probably the best bounding point, I'd think.
19:58:15 <kristof> LISP is based off of the untyped lamda calculus, isn't it?
19:58:20 <cmccann> well yes having a background in type theory is a good place to start from when learning type theory :P
19:58:23 <Cale> kristof: It turns out that Martin-Löf's type system, which was originally constructed from a computational viewpoint can also be interpreted as a system for describing homotopy types.
19:58:23 <sproingie> pdxleif: i thought that was basically impossible for any turing-complete language
19:58:39 <kristof> Cale: But what's Veovodsky's program?
19:58:43 <stelleg_> sproingie: it is impossible for any turing-complete language
19:58:47 <cmccann> sproingie: turing completeness is overrated
19:58:50 <kristof> oh, it's in there
19:58:53 <Cale> kristof: To use this as a foundations for mathematics :)
19:58:56 <kristof> Cale: Just saw the word
19:59:06 <elliott> depending on your definition of "turing complete"
19:59:14 <stelleg_> see: the halting problem
19:59:20 <cmccann> kristof: and yes, lisps are basically untyped lambda calculus with a few extra bits
19:59:21 <elliott> these languages are not turing complete in the same way haskell cannot do io
19:59:35 <elliott> yet you can easily make such a language that lets you write programs that run forever, just as haskell allows you to do IO
19:59:37 <pdxleif> sproingie: Yeah.  If you stay withing a subset, it can prove things terminate. If you wander outside that, it says "Possible non-termination due to non-decreasing condition in recursion of foo", or something.
19:59:38 * geekosaur is misreading that as Voivodski's program and being amused
19:59:58 <cmccann> elliott: you can also easily write a program that provably halts in a time that vastly exceeds the lifespan of the hardware running it
20:00:13 <elliott> cmccann: sure. but it's good as a proof!
20:00:29 <Cale> So, you can classify homotopy types into levels, where h-level 0 consists of just the contractible space, and then h-level k+1 consists of all the spaces where the space of paths between any pair of points is h-level k
20:00:53 <sproingie> pdxleif: hm, so as a corollary to proving things halt, i guess such a system could prove that things halt within X amount of time?  could have interesting consequences for realtime
20:00:57 <cmccann> computers aren't real turing machines anyway
20:00:58 <Cale> kristof: and so then h-level 1 consists of the empty space and the contractible space (which can be thought of as truth values)
20:01:04 <elliott> cmccann: it would be interesting to have a language where, not only is it total, but it can only express things below a certain O() or something
20:01:07 <cmccann> they're just finite state machines putting on airs
20:01:11 <elliott> cmccann: but, not in an ad hoc way.
20:01:20 <kristof> Cale: Wait, the empty space and contractible space are thought of as truth values?
20:01:21 <elliott> like, you'd get some kind of weaker form of induction for your types, or something.
20:01:25 <Cale> kristof: and h-level 2 consists of spaces where for any two points, there's either a unique path between them, or no path
20:01:27 <elliott> substructural mumble mumble
20:01:29 <cmccann> elliott: regular expressions? :P
20:01:32 <elliott> this is kind of -blah I guess.
20:01:34 <Cale> kristof: Yeah, like 0 and 1 :)
20:01:36 <elliott> cmccann: with types!!
20:01:43 <pdxleif> sproingie: Hmm... I guess it could keep track of the algorithmic complexity of operations?
20:01:46 <cmccann> oh man static typed regexps that would be great
20:02:08 <Cale> (a space with no points, and a space with essentially a unique point, up to homotopy)
20:02:30 <kristof> Cale: Sorry, reading your first comment again. Just wrapping my mind around the relationships between an h-level k and an h-level k+1
20:02:42 <ab9rf> static type regular expressions?
20:02:56 <pdxleif> The author said it can delete chunks of code it know won't run, which actually speeds up compilation, cause it doesn't have to generate code for those parts.
20:02:58 <Cale> kristof: So, h-level 2 is like sets (of contractible components)
20:03:01 <kristof> Cale: Does this relate to categories, in a way?
20:03:14 <Cale> kristof: and then h-level 3 is essentially like groupoids :)
20:03:16 <kristof> I mean, I think it should, but I'm wondering what that relationship might look like
20:03:27 <kristof> oh
20:03:29 <cmccann> elliott: anyway, you almost get something like that automatically with linear types because you basically can't manufacture more data than you're given
20:03:33 <kristof> oh it's starting to make sense
20:03:41 <cmccann> but that doesn't really get you to expressing actual complexity bounds
20:03:47 <kristof> Cale: Wait, so wouldn't that make this more general then categories?
20:03:48 <cmccann> but maybe something similar?
20:04:17 <sproingie> what's more general than categories?
20:04:22 <Cale> kristof: Well, it's perhaps a nice foundational place to build category theory in.
20:04:29 <kristof> Right
20:04:32 <ab9rf> sproingie: categories?
20:04:35 <shachaf> sproingie: You misunderstand. It'd make it more general, and then categories.
20:04:45 <sproingie> ohhhhh
20:04:45 <Cale> kristof: which also in some way naturally captures logic and set theory
20:04:48 <kristof> sproingie: So that's the answer to your question. H-levels are.
20:04:56 <kristof> Cale: That's really profound, though
20:05:09 <sproingie> shachaf: commas, they're your friend :)
20:05:09 <elliott> cmccann: right
20:05:17 <elliott> cmccann: that's what substructural mumble mumble meant.
20:05:44 <Cale> kristof: and so the really cool thing about this system is that every mathematical statement you make, corresponds to a space, and the truth of that statement corresponds to that space having a point
20:06:12 <kristof> Cale: What do you mean by statement?
20:06:48 <Cale> Well, this system they're working on is not unlike first-order logic, with some tweaks.
20:07:03 <Cale> The types look quite a lot like first order logic statements
20:07:03 <cmccann> elliott: yeah and I'm really not sure where to go from there
20:07:22 <elliott> cmccann: I guess you'll have to not do that work for me, then.
20:07:29 <kristof> Oh, I see
20:07:32 <kristof> Is there a paper on this?
20:07:45 <cmccann> elliott: I'll put that on my list with all the other stuff I'm not doing for people
20:07:48 <kristof> Cale: Or should I just browse this site a bit?
20:07:56 <kristof> Oh. "The Book".
20:08:03 <Cale> With 'and' corresponding to a Cartesian product of spaces, and 'or' corresponding to disjoint union, and 'forall x:A. P(x)' corresponding to a space of fibrations over A
20:09:06 <kristof> I see
20:09:11 <kristof> So what are some applications of this?
20:09:17 <Cale> kristof: and the proofs of the statements are terms in this type system which can also be thought of as programs :)
20:09:38 <kristof> Cale: http://golem.ph.utexas.edu/category/2013/03/category_theory_in_homotopy_ty.html#more
20:09:39 <Cale> (in addition to being points in these spaces)
20:10:10 <kristof> This is kind of what I was asking
20:10:37 <Cale> Immediate applications? I don't know, but it seems really nice. Certainly Martin-Löf type theory has a lot of features which might be interesting to put into practical programming languages.
20:10:52 <kristof> Aaaah, this is very cool stuff
20:10:55 <Cale> (It's a dependently typed system)
20:11:09 <kristof> Oh, that reminds me, I need to venture off and research a bit on Idris
20:11:52 <Cale> Under "Links" on that site I linked, there's a talk by Awodey and one by Voevodsky which are pretty good, right at the top of the list of links.
20:12:17 <Cale> and... there was another video which is a nice introduction to the sort of things which are being considered
20:12:47 <Cale> http://math.andrej.com/2011/12/07/hott-equivalences/
20:12:48 <jfischoff> I'm surprised there isn't a Haskell ADT for the llvm language, or is there and I am missing it somehow?
20:13:12 <applicative_> theres the llvm library
20:13:24 <Cale> ^^ that video may not make perfect sense straight away, but it's actually a fun introduction even if you don't understand quite what the rules of the game being played are
20:14:27 <jfischoff> applicative_: which I still getting my head around, but it doesn't seem to have an ADT for the language, but perhaps it offers equivalent power through its interface?
20:15:56 <applicative_> http://hackage.haskell.org/packages/archive/llvm/3.0.1.0/doc/html/LLVM-Core.html seems to throw around the language of an ADT.
20:16:50 <Cale> kristof: Oh, I also wanted to say, one of the goals is to construct a foundation for mathematics which wouldn't be so awkward for mathematicians to actually translate things into in practice. Everyone pays lip service to ZFC, but very few people actually translate everything into a form where it could be machine checked.
20:17:16 <applicative_>  I'm only familiar with it from once having built Lennart A.s Basic DSL
20:17:52 <cmccann> applicative_: clearly one of the best DSLs ever devised
20:18:18 <kristof> Cale: "I'm going to talk logic, BUT I'm going to write geometry."
20:18:28 <Cale> :)
20:18:31 <kristof> I don't know why, that made me chuckle
20:18:47 <kristof> Cale: ZFC?
20:19:01 <Cale> Zermelo-Frankel set theory with Choice
20:19:07 <kristof> Ah
20:19:13 <kristof> For... stuff like origin machines?
20:19:15 <Cale> Fraenkel
20:19:21 <kristof> Or am I misinterpreting what you mean by choice
20:19:24 <jfischoff> applicative_: its different then the llvm doc
20:19:24 <kristof> *oracle machines
20:19:26 <Cale> The axiom of choice
20:19:33 <kristof> Oh, that one :P
20:20:18 <Cale> i.e. that the Cartesian product of any family of nonempty sets is nonempty
20:20:22 <kristof> Cale: It's funny how computer science is the one field where you get hackers and mathematicians in the same major
20:20:26 <ab9rf> applicative_: LLVM has an ADT for its IR, but that doesn't necessarily relate closely to any common programminng language
20:20:36 <ab9rf> kristof: music
20:20:51 <kristof> ab9rf: There's that, too.
20:21:21 <applicative_> ab9rf: yeah,  I was wondering, not knowing anything about llvm
20:22:31 * applicative_ is still recovering from a bunch of lectures of Martin Lof last week. 
20:22:38 <ab9rf> applicative_: normally if you are going to target LLVM you will generate a language-specific ADT from your parser, then transform that into LLVM's IR ADT
20:22:43 <Nafai> Kinnison used LLVM in his BF interpreter in this video http://www.youtube.com/watch?v=G8WW3bGIZFc made me want to look into LLVM more
20:25:34 <ab9rf> applicative_: i'm slowly writing a couple of language parsers in haskell, and i will probably end up playing with LLVM at some point
20:25:55 <jfischoff> so there isn't an ADT version of the store instruction
20:25:59 <jfischoff> but there is http://hackage.haskell.org/packages/archive/llvm/3.0.1.0/doc/html/LLVM-Core.html#v:store
20:26:25 <jfischoff> but you have to actually give a memory location from your Haskell program
20:26:50 <ab9rf> jfischoff: IDStore?
20:26:54 * sw2wolf the LLVM xmonad works very well ...
20:27:02 <jfischoff> ab9rf: oh!
20:27:19 <jfischoff> there we go mystery solved
20:27:33 <ab9rf> jfischoff: the hackage docs are a bit sparse, you really need to refer to LLVM's own documentation
20:27:46 <Cale> kristof: Of course, functional programmers are all applied logicians who spend all their time proving boring theorems in interesting ways in an inconsistent intuitionist logic.
20:28:05 <jfischoff> ab9rf: I used a case sensitive search
20:28:06 <cmccann> Cale: that's a good summary.
20:28:07 <ab9rf> Cale: you say that like it's a bad thing
20:28:10 <ab9rf> jfischoff: heh
20:28:21 <Cale> ab9rf: I didn't say it was a bad thing :)
20:28:25 <jfischoff> I knew I was missing something :p
20:29:25 <shachaf> Cale: Even the dependent-type functional programmers?
20:29:26 <jfischoff> ab9rf: have you seen Lennarts blog intro. Its pretty cool.
20:29:30 <sw2wolf> @hoogle llvm
20:29:30 <lambdabot> package llvm
20:29:30 <lambdabot> package llvm-extra
20:29:30 <lambdabot> package llvm-ht
20:29:45 <ab9rf> jfischoff: no, i've only read a couple of blog articles about llvm
20:30:03 <jfischoff> http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
20:30:09 <Cale> shachaf: Well, those guys often work in consistent intuitionist logics -- at least, the ones who are willing to give up Turing completeness.
20:32:19 <cmccann> pf, it's not like you can't translate any potentially non-terminating computation into one that's productively corecursive
20:32:33 <cmccann> it just may never produce anything interesting before you get tired of checking
20:33:45 <ab9rf> jfischoff: hadn't seen this.  thanks.
20:34:03 <hpaste> a pasted “HiLo” at http://hpaste.org/85132
20:34:13 <applicative_> ab9rf: jfischoff well, your task is in any case to get the Basic package to build again...  I want to write haskell like this ^^^
20:34:23 <hpaste> “jfischoff are you happy now edwardk?” pasted “ghci crash” at http://hpaste.org/85133
20:34:51 <jfischoff> any idea how to prevent that ^^^?
20:35:21 <jfischoff> mind you I have two versions of llvm. The llvm package was built against 3.0 and ghc against 3.2
20:35:34 <ab9rf> applicative_: i'm actually working on a Dartmouth BASIC interpreter :)
20:35:47 <jfischoff> applicative_: do you remember why it stopped working?
20:36:06 <ab9rf> applicative_: but actually writing it within Haskell syntax, probably not going to work :)
20:36:29 * applicative_ tries to figure out what lennart's Num instance can be, for those monadic line numbers
20:37:43 <applicative_> jfischoff: I don't remember it was a while ago I tried it.  It may be mostly haskell-internal problems, like the one his python dsl had with ImpredicativeTypes
20:37:56 <napping> this looks bad: http://hpaste.org/85134
20:39:15 <jfischoff> applicative_: it would be cool to get that working
20:40:24 <napping> am I doing something wrong, or is STM broken?
20:41:10 <neutrality> napping: What is it that main is supposed to do?
20:42:17 <napping> run in parallel two transactions which set atomically one TVar Bool if both are unset, while a parallel thread checks that both don't become set
20:42:35 <Cale> napping: reset' will eventually succeed once both dog and cat are True, and set them both to False
20:42:59 <Cale> napping: but then you run it again, and nothing will ever set them to True, so it will never succeed
20:43:01 <napping> at -N1 or without -threaded it runs fine, with -N2 or higher it hits the "oops"
20:43:12 <Cale> and GHC detects this, and kills the thread
20:43:43 <napping> ah, that would do it
20:44:10 <napping> atomically oops is finishing on an asynchronous exception rather than an actual problem
20:44:37 <napping> I saw claims GHC's STM could allow write skew
20:45:56 <jfischoff> ab9rf: The ADT for IR doesn't appear to be complete…can't see how to use it create a function ...
20:46:25 <ab9rf> jfischoff: that blog post explains how to create functions
20:46:51 <jfischoff> sure but their adt directly. I would rather just make the adt and pretty print it
20:47:00 <ab9rf> jfischoff: heh, it's not that simple
20:47:07 <ab9rf> jfischoff: the ADT only describes basic blocks
20:47:07 <jfischoff> why not?
20:47:13 <neutrality> napping: I'm not sure what you mean by "STM can also write Skew"
20:47:14 <Cale> napping: Since you're setting dog and cat to True in separate threads, there is a very real chance for oops to complete normally
20:47:28 <ab9rf> jfischoff: i can't answer that. ask the people wh write LLVM :)
20:47:53 <jfischoff> ab9rf: but llvm language has a function construct right?
20:48:05 <Cale> napping: If setDog completes its transaction, and then setCat completes its transaction, and then oops runs, it will finish normally
20:48:14 <napping> how do both complete?
20:48:19 <ab9rf> jfischoff: there's a createFunction thing, and also defineFunction and newFunction
20:48:24 <Cale>     forkIO (atomically setDog)
20:48:24 <Cale>     forkIO (atomically setCat)
20:48:29 <jfischoff> ab9rf: http://llvm.org/docs/LangRef.html#functions
20:48:31 <ab9rf> setMouse
20:48:57 <ab9rf> let tom = cat, jerry = mouse
20:49:11 <jfischoff> ab9rf: I used the createFunction etc, very cool stuff not how I feel like working.
20:49:14 <Cale> oh, I see, setDog itself has a guard against either being set
20:49:25 <napping> http://hpaste.org/85134
20:49:28 <Cale> okay, sure
20:49:33 <ab9rf> jfischoff: well, you'll have to write a trnslation layer then :)
20:49:40 <napping> here, this drops the retry in reset' and uses a semaphore
20:49:54 <napping> now it doesn't get stuck and happily "Tick"s away, but ocassionally reports an oop
20:49:58 <jfischoff> of just flesh out the rest of the ADT I guess
20:50:41 <jfischoff> Enigmagic maybe you help me with llvm questions
20:50:59 <Cale> napping: btw, lots = replicateM_
20:51:17 <ab9rf> jfischoff: 'functions' in LLVM are specifically machine-level global code symbols.  they might not correspond to a given's language "function" construct
20:51:59 <jfischoff> ab9rf: that's fine.
20:53:14 <jfischoff> I just want to be able to create all the syntactical constructs I can in a module file with a haskell adt
20:53:22 <napping> I thought the transaction log was checked atomically
20:55:01 <Cale> napping: anything you put in atomically should appear to the rest of the system as if it ran completely or not at all.
20:55:15 <Cale> napping: What kind of output are you seeing?
20:55:23 <Cale> I only see Tick printed repeatedly
20:55:48 <napping> did you build -threaded and run with -N2 (>1)
20:57:15 <Cale> Oh right, ghci behaves differently even though it's built with -threaded.
20:57:31 <napping> http://hpaste.org/85134
20:57:41 <napping> removed the ticks, repeated the test
20:57:47 <Cale> okay, so now I see an "Oh Noes!" before the first Tick
20:58:13 <napping> note it's not rechechecked, if you don't change it like I just pasted
20:59:14 <napping> I don't see how that's possible if things actually run atomically
20:59:59 <Cale> yeah, hmm
21:00:36 <napping> not happening at -N1 and without threaded is also a bad sign
21:00:41 <napping> you are not running 7.8?
21:01:08 <luite_> http://hdiff.luite.com:3000/
21:01:09 <Cale> 7.6.2
21:03:09 <Cale> hmm, well this is very interesting
21:03:44 <luite_> oh sorry the graph is not tall enough in firefox
21:04:32 <luite_> gave it a fixed height
21:05:56 <Cale> luite_: that's cool
21:06:15 <napping> well, I'm out of time for tonight. Didn't see any relevant bugs in a quick search
21:06:33 <Cale> napping: There's definitely something fishy going on here
21:06:53 <luite_> Cale: I just hacked the ghcjs scheduler to let it show the heap at every step. I remember you posting similar diagrams somwhere :)
21:07:05 <Cale> yeah
21:07:19 <Cale> also reminiscent of HOPS
21:07:38 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
21:08:06 <luite_> ah yeah, cool :)
21:10:15 <luite_> it reduces to nothing because it actually does a print of the result
21:11:04 <luite_> http://hdiff.luite.com:3000/showeval.hs.txt the source
21:12:26 <monochrom> w00t haskell weekly news!
21:14:33 <monochrom> @quote shachaf monoids
21:14:33 <lambdabot> shachaf says: edwardk will try to get you addicted to monoids. The first one is always free.
21:14:39 <monochrom> hehehe!
21:15:01 <monochrom> haahaha that one is so good!
21:15:29 <carter> was that a real quote?
21:15:50 <Cale> I'm betting it was
21:15:56 <monochrom> not sure what's "real", but let me just say yes
21:18:23 <luite_> Cale: but this is just STG, you can see that in the end the graph grows too much to the right because of the foldl pushing all numbers on the stack
21:18:41 <luite_> i should let it show the stack properly
21:36:50 <neutrality> Cale: do you think that problem nap was asking about could have been done using Control.Concurrent.Async and without a semaphore
21:39:39 <Cale> neutrality: I haven't yet bothered to fully understand what was going on there, but if there's a bug in STM, then it could potentially affect many things.
21:39:39 <Cale> async uses STM, so it's possible that a bug in STM would affect it
21:46:13 <neutrality> skew
21:48:34 <luite_> http://hdiff.luite.com:3000/ <- hmm, adding the stack doesn't really make it clearer, and the graph drawing lib i use doesn't seem to support fixed positions
21:55:31 <hpaste> Neutrality annotated “skew?” with “skew? (annotation) (annotation)” at http://hpaste.org/85134#a85143
21:58:43 <neutrality> Cale: If your still about, what do you think of that?
22:00:54 <Cale> neutrality: well, that's definitely cleaner -- does it still exhibit the same behaviour?
22:04:26 <neutrality> Cale: No -- the second forever loop runs eternally and the first one (the forkIO) does not get a chance to output anything.
22:05:01 <neutrality> Cale: This could be because I ran it in the interpreter and didn't compile it with threading.
22:05:49 <Cale> neutrality: Oh, you definitely want to compile with -threaded and run with +RTS -N2 to test what we were seeing
22:06:19 <neutrality> Cale: I know, lol.
22:07:02 <neutrality> Phyrex1an: "phyrexian" was from Magic the Gathering No?
22:07:24 <phyrex1an> yes
22:07:25 <lambdabot> phyrex1an: You have 1 new message. '/msg lambdabot @messages' to read it.
22:07:51 <neutrality> phyrex1an: cool
22:19:43 <wessel> Hi
22:26:10 <wess> Any one want to help me with a haskell problem ? :(
22:26:30 <jfischoff> of course!
22:26:39 <jfischoff> just not me ;)
22:26:41 <simpson> wess: Don't ask to ask, just ask.
22:27:32 <wess> I have a list
22:27:41 <wess> with tuples of size 3 in
22:27:57 <wess> how do I create a new list
22:28:09 <Iceland_jack> New list?
22:28:38 <Iceland_jack> Your question is too vague
22:28:45 <wess> it is not the hole question
22:28:50 <wess> Im just thiking how to explain my problem
22:28:51 <ParahSail1n> [(a,b,c)] -> ?
22:28:52 <wess> sorry
22:29:27 <wess> ok so my List looks like this [(Double,[Char], Double, Double)]	
22:29:30 <wess> I want to create a new list
22:29:36 <wess> but the conditions is
22:29:41 <wess> the second double
22:29:47 <wess> i.e. [(Double,[Char], Double<--, Double)]	
22:29:51 <wess> has to be summed
22:29:54 <wess> and if its value is say 10
22:29:59 <wess> stop adding items from the old list
22:30:00 <wess> to the new one
22:30:18 <wess> is that still to vague ?
22:30:32 <Iceland_jack> So a 4-tuple, not a 3-tuple
22:30:35 <wess> yeah
22:30:40 <Iceland_jack> You can use takeWhile
22:31:02 <wess> i tried list comprehension before
22:31:06 <wess> like
22:31:14 <wess> total =   [ (x,y,z,b) | (x,y,z,b) <- sortedData, b + b < 15 ] 	
22:31:14 <Iceland_jack> @ty takeWhile (\(_, _, d, _) -> d /= 10)
22:31:16 <lambdabot> (Eq a, Num a) => [(t, t1, a, t2)] -> [(t, t1, a, t2)]
22:31:17 <wess> but obv that didnt work
22:31:21 <ParahSail1n> sounds like he wants to accumulate a value for his takewhile predicate
22:31:27 <wess> yeah
22:31:48 <Iceland_jack> This seems like a very strange way of doing things to me, what are you trying to accomplish?
22:32:05 <Iceland_jack> You probably don't want tuples to store your data
22:32:15 <wess> I have to use a touple
22:32:20 <wess> because I have different data types ?
22:32:26 <wess> obviously open to suggestions
22:32:27 <simpson> wess: Hm. This isn't homework, right?
22:32:28 <ParahSail1n> wess mix up a scanl with a takeWhile
22:32:38 <Iceland_jack> wess: You can use data to declare a new datatype
22:32:41 <wess> it is homework, but also trying to learn
22:32:47 <wess> its not all my homework
22:32:51 <ParahSail1n> use scanl to accumulate the sum
22:33:05 <Iceland_jack> I have no idea what you're trying to model but: data Person = Person Int String
22:33:05 <ParahSail1n> takeWhile to take until predicate
22:33:12 <Iceland_jack> could store a person's age + name
22:33:16 <Iceland_jack> instead of (Int, String)
22:36:53 <ParahSail1n> @ty \l -> takeWhile (\(x,_) -> x < 10) $ scanl (\(sum, xs) i@(_, _, x, _) -> (sum+x, i:xs)) (0, []) l
22:36:55 <lambdabot> (Num a, Ord a) => [(t, t1, a, t2)] -> [(a, [(t, t1, a, t2)])]
22:37:37 <Iceland_jack> ParahSail1n: Maybe not give the solution to homework directly
22:37:49 <wess> Thanks
22:37:51 <Iceland_jack> It may be obvious that wess did not come up with that themselves
22:37:55 <wess> im not after the solution
22:37:58 <wess> just want ideas
22:38:02 <wess> because I have tried so many things now
22:38:10 <ParahSail1n> i dont think i gave him a correct answer
22:38:14 <wess> yeah I dont want anything to complex
22:38:28 <wess> just point me in the right direction
22:38:52 <wess> but thanks
22:38:53 <Iceland_jack> wess: I would start out implementing it in a simple recursive fasion
22:39:01 <ParahSail1n> @src scanl
22:39:01 <lambdabot> scanl f q ls = q : case ls of
22:39:02 <lambdabot>     []   -> []
22:39:02 <lambdabot>     x:xs -> scanl f (f q x) xs
22:39:09 <wess> takeWhile seems elegant
22:39:09 <Iceland_jack> wess: http://learnyouahaskell.com/recursion ← this may be helpful
22:39:09 <ParahSail1n> you can write all that stuff yourself
22:39:14 <ParahSail1n> @src takeWhile
22:39:14 <lambdabot> takeWhile _ []                 =  []
22:39:15 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
22:39:15 <lambdabot>                    | otherwise =  []
22:39:15 <wess> been there
22:39:16 <wess> so many times lol
22:39:33 <ParahSail1n> and do it better than composing takeWhile and scanl
22:40:19 <Iceland_jack> ‘takeWhile’ does exactly what it says on the tin, ‘scanl’ is a little more involved
22:40:42 <mzero> wess - take this as two separate parts: 1) how do you compute the successive sum of the third part of the tuple..... 2) how do you select a part of the list based on that list of successive sums
22:40:59 <neutrality> Cale: if you are still there I don't think there is a way that the program can have both cat and dog set to true at the same time, which is the only way it would print "Oh Noes!" so I don't see how Nappier is getting that output.
22:41:12 <neutrality> But hey. It provided me with some fun.
22:41:23 <mzero> I'd guess that at your level, it would be better, more instructive to NOT learn scanl --- and instead figure out how to write part 1 yourself
22:41:25 <Cale> neutrality: That's the bug that we're discussing
22:41:35 <Iceland_jack> What mzero said
22:41:41 <wess>  mzero I did think of that, but I need to maintain some order in my list
22:42:03 <mzero> no worries... lists ARE ordered!
22:42:14 <neutrality> You see, I don't get that output. The bug is not showing up for me. Is it showing up for you?
22:42:49 <mzero> also - start simple - ignore the tuple....   how would you compute the successive sum (do you understand what I mean by that?) of this list:   [ 4, 5, 8, 1, 4, 0, 3 ]?
22:43:03 <wess> yeah I understand
22:43:18 <mzero> cool - try writing a fucntion to do that - and hpaste it for us
22:43:22 <wess> kk
22:43:26 <mzero> :-)
22:43:32 <Iceland_jack> ☺
22:43:35 <wess> i might be a while :P
22:43:37 <wess> but will try
22:43:43 <wess> dnt go to bed !
22:43:44 <mzero> (I'm assuming here you want help understanding .... and won't mind taking it slow, piece by peice)
22:43:53 <wess> I have all day
22:43:54 <wess> :)
22:43:55 <mzero> I'm up for anohter hour!
22:43:59 <mzero> heh
22:44:38 <wess> @ mzero successive sum, you mean the sum of the list right ?
22:44:43 <neutrality> Cale: If you get to the bottom of it please be sure to put it on Haskell reddit or something. I'm interested to hear the result.
22:44:45 <wess> of all elements in the list
22:44:46 <osa1> can anyone give me an example expression that is typeable under a type system with subtyping but not typeable under classic let-polymorphism, and vice versa
22:44:58 <mzero> no - I mean I want the sum at each point.
22:44:59 <osa1> um yeah that means two expressions
22:45:16 <wess> ahh
22:45:20 <mzero> so the result for that list would be  [ 4, 9, 17, 18, 22, 22, 25 ]
22:45:51 <wess> k thnks brb
22:49:18 <neutrality> Cale: Anyway I am using GHC 7.4.2 with the latest version of STM and I am not seeing the behaviour that nappier is seeing. Hope that helps.
22:49:48 <Cale> neutrality: okay, cool
22:50:01 <Cale> neutrality: You compiled with -threaded and ran his program with +RTS -N2?
22:50:47 <neutrality> Yes. I compiled both the original program and my cleaned up version and niether showed the buggy behaviour.
22:53:23 <shachaf> Welcome to issue 264 of the HWN, an issue covering crowd-sourced bits of information about Haskell from around the web. This issue covers the week of March 17 to 30, 2013.
22:53:29 <shachaf> good week
22:53:51 <cmears> Cale, neutrality: I tried both too with 7.6.2, and didn't see any output at all (is that the correct behaviour?)
22:54:02 <mzero> I wish all my weeks had 14 days in 'em
22:54:19 <Cale> cmears: which program did you run exactly?
22:56:54 <mzero> how ya doin', wess ?
22:58:16 <cmears> Cale, I just tried all four from the hpaste
22:58:38 <cmears> 85140 gives "Tick\nTick\n..."
22:58:57 <cmears> the other three (85134,85141,85143) give no output
23:00:38 <Cale> cmears: and you compiled with -threaded and ran with +RTS -N2 on the commandline?
23:00:44 <cmears> That's right
23:00:47 <Cale> huh
23:00:49 <Cale> interesting
23:01:05 <Cale> I'm using 7.6.2 and I see a bunch of "Oh Noes"
23:02:00 <cmears> with stm-2.4.2, if it makes any difference
23:03:56 <cmears> got an "oh noes" with ghc 7.4.1
23:04:03 <cmears> (with the first program)
23:04:25 <cmears> Actually, all of them give oh noes with ghc 7.4.1
23:08:59 <luite_> added the STG eval stack  http://hdiff.luite.com:3000/
23:11:21 <Cale> luite_: cool!
23:13:56 <luite_> Cale: i compiled foldl' now, it's a lot less interesting to watch :)
23:15:29 <Cale> luite_: I was just noticing that :)
23:16:39 <Cale> luite_: try foldr :)
23:17:08 <luite_> should be foldr now
23:19:23 <Cale> Interesting
23:19:50 <luite_> ghcjs does eager blackholing, so everything on the stack becomes a blackhole immediately
23:20:36 <luite_> (since we don't have control ovr the garbage collector, lazy blackholing doesn't make much sense)
23:23:54 <luite_> sorry for the large js size btw, it's half the base package linked in, I'm still working on reducing ghcjs' output size
23:38:12 <finishingmove> can anyone share a reasonable indentation config for Sublime Text 2 (for Haskell syntax naturally) ?
23:38:50 <finishingmove> (or recommend a Haskell IDE / editor that works on Windows and is better than ST2)
23:41:13 * hackagebot cipher-aes 0.1.8 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.8 (VincentHanquez)
23:43:31 <finishingmove> anyone ?
23:45:54 <newsham> has anyone built a "traditional" web server (ie. like apache, serves static files, supports options like home dirs, indexing, etc) out of any of the modern haskell web components (ie. like warp)?
23:48:56 <fragamus_> is there anyone who understands Uustalu's factorial example
23:58:11 <fragamus_> Not sure my chat is working can you guys see this
23:58:44 <fragamus_> Im on iPhone colloquy app
23:59:10 <ousado> yes
23:59:49 <ousado> fragamus_: ^
