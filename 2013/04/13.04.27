00:01:33 <awgn> Hi. Is there any guide to follow about haskell libraries? which are worth learning and which are not?
00:04:44 <johnw> awgn: no
00:04:57 <johnw> ask here when you have a particular need
00:04:57 <awgn> cool
00:06:57 <awgn> At least a list of libraries and a suggested order to study would be very welcome...
00:07:05 <donri> @google 24 days of hackage
00:07:06 <kartoffelbrei> awgn: here is a nice series of blog post exploring some cool packages on hackage http://ocharles.org.uk/blog/ (look at the 24 days of Hackage ones)
00:07:07 <lambdabot> http://ocharles.org.uk/blog/
00:07:07 <lambdabot> Title: Posts
00:07:12 <donri> awgn: see that
00:07:14 <johnw> awgn: how far in haskell have you gone?
00:07:49 <awgn> johnw, not much
00:08:00 <johnw> tell me the hardest thing you've recently comprehended
00:09:06 <awgn> state monad I guessÖ I study haskell from time to time cause I use other languages daily
00:09:35 <donri> awgn: also https://github.com/tibbe/haskell-docs/blob/master/libraries-directory.md
00:10:33 * hackagebot zmcat 0.2 - Command-line tool for ZeroMQ.  http://hackage.haskell.org/package/zmcat-0.2 (LucasDiCioccio)
00:10:45 <ezyang> It seems inaccurate to describe a catamorphism as an initial algebra. What is a more accurate way of describing it?
00:10:47 <johnw> awgn: perhaps you'd enjoy learning conduit/pipes/io-streams
00:11:25 <johnw> ezyang: it's a unique homomorphism from an initial algebra into some other algebra
00:12:26 <ezyang> johnw: Right-o, that's what I'm looking for
00:13:06 <Rotaerk> trying to determine if there's a benefit to (\fs acc -> foldl (flip fmap) acc fs) over (\fs -> foldl (flip (.)) id fs)
00:13:20 <Rotaerk> all the cases where the former equals the latter don't seem to be that useful
00:13:27 <Rotaerk> err doesn't equal *
00:14:13 <ezyang> Gosh, using the technical terms is going to be impenetrable, isn't it...
00:14:43 <awgn> I have been heard about lens also. Which one is recommended? the Kmett's lens?
00:14:50 <donri> awgn: yes
00:14:51 <johnw> awgn: yes, definitely
00:14:58 <edwardk> yes, but i'm biased
00:15:02 <donri> ;)
00:15:06 <awgn> thanks :-)
00:15:33 <donri> awgn: some think the lens package is unnecessarily complicated but it's worth it for the sheer power and flexibility
00:15:48 <johnw> donri: they kind of say the exact same thing about Haskell
00:15:48 <Lethalman> :t foldl (flip (.)) id
00:15:50 <lambdabot> [b -> b] -> b -> b
00:15:51 <johnw> lens is a mini-Haskell
00:16:06 <Lethalman> :t \fs acc -> foldl (flip fmap) acc fs
00:16:08 <lambdabot> Functor f => [a -> a] -> f a -> f a
00:17:08 <awgn> And what about template and quasiquotation? are worth to learn Ö the documentation seems scarce
00:17:12 <edwardk> ezyang: it is the unique f-algebra homomorphism from Mu f to a for a given f-algebra with carrier a.
00:17:47 * Rotaerk picks up the pieces of his brain off the floor.
00:18:26 <edwardk> oh johnw already said that
00:18:36 <edwardk> carry on then =)
00:18:59 <donri> awgn: you probably should at least learn to *use* splices and quasi-quoters. but learning to write library code with TH and QQ interfaces comes much later
00:19:37 <awgn> ok
00:20:11 <donri> awgn: (being a consumer of TH and QQ though is easy stuff, just a few gotchas to look out for)
00:20:11 <Rotaerk> > let compose = foldl (flip (.)) id
00:20:15 <lambdabot>   mueval-core: Time limit exceeded
00:20:16 <shachaf> ezyang: Are you coming to BayHac next month?
00:20:50 <ezyang> shachaf: I have it on my calendar!
00:21:07 <Rotaerk> > let compose fs = foldl (flip (.)) id fs
00:21:08 <lambdabot>  Terminated
00:21:35 <donri> > "ping?"
00:21:37 <lambdabot>   "ping?"
00:22:02 <donri> Rotaerk: those shouldn't parse. is the parser timing out and terminating?
00:22:29 <Rotaerk> > let fmapAll fs acc = foldl (flip fmap) acc fs
00:22:33 <lambdabot>   mueval-core: Time limit exceeded
00:22:37 <ezyang> But I do not know if I will actually make it
00:22:55 <donri> Rotaerk: lambdabot doesn't understand bare 'let' in '>'
00:23:00 <Rotaerk> oh
00:23:06 <Rotaerk> :t compose
00:23:07 <lambdabot>     Not in scope: `compose'
00:23:07 <lambdabot>     Perhaps you meant one of these:
00:23:07 <lambdabot>       `icompose' (imported from Control.Lens),
00:23:15 <donri> you want @let or > let ... in ...
00:23:31 <Rotaerk> is there a way to clear something you've @let-ed
00:23:39 <Rotaerk> i.e. don't want to pollute the channel
00:23:42 <donri> or just :t \fs -> ... etc
00:23:58 <Rotaerk> k
00:24:04 <shachaf> You can only clear everything at once.
00:26:12 <Rotaerk> > let fmapAll fs acc = foldl (flip fmap) acc fs in fmapAll [(+3),(*2),(**2)] id 2
00:26:15 <lambdabot>   100.0
00:26:46 <donri> > let fmapAll fs acc = foldl (flip fmap) acc fs in fmapAll [(+x),(*y),(**z)] id a
00:26:49 <lambdabot>   ((a + x) * y)**z
00:27:09 <Rotaerk> :t a
00:27:12 <lambdabot> Expr
00:27:52 <donri> it's a magic thing that basically records Num operations and such
00:28:11 <donri> @hackage simple-reflect
00:28:11 <lambdabot> http://hackage.haskell.org/package/simple-reflect
00:28:16 <Rotaerk> > let compose fs = foldl (flip (.)) id fs in compose [(+x), (*y), (**z)] id a
00:28:19 <lambdabot>   Couldn't match expected type `t1 -> t0'
00:28:19 <lambdabot>              with actual type `Debu...
00:28:29 <Rotaerk> > let compose fs = foldl (flip (.)) id fs in compose [(+x), (*y), (**z)] a
00:28:32 <lambdabot>   ((a + x) * y)**z
00:29:28 <Rotaerk> > let fmapAll fs acc = foldl (flip fmap) acc fs in fmapAll [(+x),(*y),(**z)] [a, b, c]
00:29:30 <lambdabot>   [((a + x) * y)**z,((b + x) * y)**z,((c + x) * y)**z]
00:29:37 <donri> Rotaerk: also you can /msg lambdabot in private
00:29:41 <Rotaerk> oh
00:37:12 <Rotaerk> hmm yea, fmapAll isn't that useful, because (fmapAll functions values) can be replicated with (fmap (compose functions) values)
00:38:09 <Ralith> surely by 'compose' you mean 'foldl (.) id'
00:38:55 <Rotaerk> Ralith, yep, that's how it's defined, though the (.) is flipped (see above)
00:40:55 <wole> @ty forM_
00:40:58 <johnw> why foldl (flip (.)) id instead of foldr (.) id?
00:41:00 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
00:41:47 <Lethalman> is there an option for cabal install concurrency?
00:41:49 <Lethalman> like make -j
00:42:57 <johnw> cabal install -j
00:43:20 <Lethalman> aaaaah thanks :)
00:43:26 <shachaf> That will install multiple packages at once but not compile multiple modules.
00:43:30 <Rotaerk> johnw, hmm, I don't fully understand the performance ramifications of foldr vs foldl yet
00:43:42 <Lethalman> shachaf, ah not multiple object files?
00:44:06 <Rotaerk> johnw, and that was the suggestion of... http://www.haskell.org/haskellwiki/Compose
00:44:08 <Lethalman> cabal install -j not recognized though
00:44:12 <Lethalman> maybe I have an old version :(
00:44:37 <shachaf> cabal install cabal-install
00:44:46 <Lethalman> ok
00:45:05 <Lethalman> shachaf, I have ghc 7.4.1, is that ok to do?
00:45:19 <shachaf> Should be fine.
00:45:23 <shachaf> But how would I know? Try it and see!
00:46:35 <Lethalman> shachaf, ok, asked... if you knew, good :-)
00:47:46 <Rotaerk> ah great, both functions can be defined in terms of one another
00:48:04 <shachaf> Rotaerk: You can't define foldr in terms of foldl.
00:48:25 <Rotaerk> no I mean, the "fmapAll" and the "concat"
00:48:44 <Rotaerk> err "compose"
00:55:09 <johnw> with foldl, it becomes (f . g) . h which is (\x -> (\x -> f (g x)) (h x)).  with foldr, it becomes f (g . h) which is (\x -> f (g (h x))).  Is there a reason the former should be considered better than the latter?
00:55:35 * hackagebot monad-wrap 0.1 - Wrap functions such as catch around different monads  http://hackage.haskell.org/package/monad-wrap-0.1 (DavidMazieres)
00:56:33 <Lethalman> shachaf, unfortunately, doesn't work well /home/foo/.cabal/logs/data-default-instances-base-0.0.1.log: does not exist
00:56:38 <Lethalman> and so on for each package :(
00:56:58 <Lethalman> where can I report the problem?
01:07:56 <killing-joke> trying to install hakyll via cabal. the dep crypto-api will not build, killing install.
01:08:15 <killing-joke> i get a scope warning, and a suggested fix. " (Use -XFlexibleContexts to lift this restriction) "
01:08:39 <killing-joke> how can i pass the -X<arg> to "cabal install"?
01:10:42 <wole> ((*) + (+))
01:11:28 <wole> @ty ((*) + (+))
01:11:29 <lambdabot> Num a => a -> a -> a
01:11:47 <wole> ((*) + (+)) 5 7
01:14:49 <Lethalman> > ((*) + (+)) 5 7
01:14:51 <lambdabot>   47
01:15:59 <wole> thanks Lethalman - just found that I should prefix with >
01:21:20 <Breadmonster> So I saw Brian Beckman's video on monads.
01:21:27 <Breadmonster> And I had a small question.
01:21:54 <Breadmonster> Are monads a way to perform side effects without relaxing purity?
01:22:13 <Breadmonster> Or are they a more fundamental construct that can have applications in C++, say?
01:22:28 <Breadmonster> Because you don't need the IO monad to do IO in C++.
01:23:04 <shachaf> You could do I/O in Haskell without the idea of "a monad", and most uses of that idea have nothing to do with I/O.
01:23:13 <shachaf> It just happens to be one of the uses.
01:28:55 <Breadmonster> Sorry.
01:29:18 <Breadmonster> Shachaf: What are monads? I mean, he just did some handwaving with functions.
01:31:02 <shachaf> "monad" is the name of an API that a bunch of different types have in common that lets you write some kinds of generic code.
01:31:25 <Breadmonster> Alright, thank you, that makes so much more sense.
01:31:34 <Breadmonster> Now, in this API, what is bind?
01:31:46 <Breadmonster> Or >>= or 'shove' as Beckman calls it?
01:32:48 <shachaf> A function.
01:33:12 <shachaf> I suggest understanding a bunch of concrete examples of this API before trying to understand it in general.
01:33:26 <Breadmonster> Alright, fine, that does work.
01:33:39 <Breadmonster> What monad should I look up?
01:34:19 <Ralith> List, Maybe, State s, Either a, whatever catches your fancy
01:34:23 <Lethalman> Breadmonster, this is the best monad explanation for me: http://webcache.googleusercontent.com/search?q=cache:MHbPuek3uIoJ:www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm+&cd=10&hl=en&ct=clnk&client=iceweasel-a
01:34:39 <Ralith> implement them yourself, understand the implementations
01:35:23 <Breadmonster> Ralith: Where do I find their behavior?
01:35:30 <Breadmonster> Lethalman: Thank you.
01:36:30 <Ralith> Breadmonster: for some of them you should be able to derive it yourself from the types
01:36:58 <Ralith> perhaps all of them
01:37:04 <Breadmonster> Ralith: Honestly, I have no clue what their behavior even ought to be.
01:37:12 <Ralith> that's what makes it fun! :D
01:37:18 <Breadmonster> My only introduction to Monads was Beckman's video.
01:37:42 <Ralith> get out your environment and try it
01:38:28 <Breadmonster> Ralith: Okay, how do I use a monad in Haskell?
01:38:37 <Breadmonster> I don't know the syntax, if that's what you mean.
01:39:14 <Ralith> the only syntax is just optional shorthand for >>= and return
01:39:20 <Ralith> you don't need to know any syntax
01:39:25 <Breadmonster> Okay, fine.
01:39:29 <Breadmonster> How do I use a monad?
01:39:38 <Ralith> by calling >>= and/or return
01:39:44 <Breadmonster> What are they used for?
01:39:48 <Ralith> it varies
01:39:51 <Breadmonster> ...can you show me a concrete example?
01:40:29 <shachaf> Ralith: >>= and return and also other functions/actions.
01:41:19 * Ralith beta-reduces shachaf 
01:41:55 <Breadmonster> Okay, is all this there in Real World Haskell?
01:42:06 <Ralith> I am sure something monady is there
01:44:02 <Breadmonster> Alright, I'll read that, because all this appears to be Greek to me.
01:45:35 * hackagebot hsc3-auditor 0.14 - Haskell SuperCollider Auditor  http://hackage.haskell.org/package/hsc3-auditor-0.14 (RohanDrape)
01:45:37 * hackagebot hsc3-dot 0.14 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.14 (RohanDrape)
01:45:54 <shachaf> Here is a Greek-Haskell dictionary: Œ∑ means return, Œº means join.
01:47:05 <Breadmonster> shachaf: rofl
01:50:35 * hackagebot hsc3-plot 0.14 - Haskell SuperCollider Plotting  http://hackage.haskell.org/package/hsc3-plot-0.14 (RohanDrape)
01:59:32 <bitonic> does cabal offer a way to load up the modules of a project in ghci?  similar to cabal-dev but without creating an environment
02:00:35 * hackagebot hsc3-rec 0.14 - Haskell SuperCollider Record Variants  http://hackage.haskell.org/package/hsc3-rec-0.14 (RohanDrape)
02:00:37 * hackagebot hsc3-sf-hsndfile 0.14 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-hsndfile-0.14 (RohanDrape)
02:00:39 * hackagebot hsdif 0.14 - Haskell SDIF  http://hackage.haskell.org/package/hsdif-0.14 (RohanDrape)
02:00:43 <dcoutts_> bitonic: I have code to do that but it's not quite finished or merged, been distracted by hacking on the new hackage server
02:01:17 <bitonic> dcoutts_: cool, I‚Äôll wait :).  I suppose is a matter of adding the source directory and ‚Äòdist/build‚Äô to ghci load path, more or less?
02:02:00 <dcoutts_> bitonic: you mean if you do it manually?
02:02:09 <bitonic> dcoutts_: to ask the question more directly, is there an easy manual way of doing it?
02:02:12 <bitonic> dcoutts_: yeah :)
02:02:18 <dcoutts_> bitonic: most reliable way is to call cabal build -v
02:02:29 <dcoutts_> copy and paste that huge command line
02:02:43 <dcoutts_> change --make to --interactive
02:03:04 <bitonic> dcoutts_: oh, perfect!
02:03:16 <bitonic> thanks
02:03:18 <dcoutts_> usually no other tweaks are needed, though you might want to change the module/file target
02:03:29 <dcoutts_> or just use :m after you start ghci
02:04:05 <bitonic> OK, perfect
02:04:31 <wole> @faq Is Predicate a functor?
02:04:31 <lambdabot> The answer is: Yes! Haskell can do that.
02:05:35 * hackagebot hspear 0.14 - Haskell Spear Parser  http://hackage.haskell.org/package/hspear-0.14 (RohanDrape)
02:05:37 * hackagebot hdf 0.14 - Haskell data flow library for audio processing  http://hackage.haskell.org/package/hdf-0.14 (RohanDrape)
02:10:35 * hackagebot hmeap 0.14 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.14 (RohanDrape)
02:10:37 * hackagebot hmeap-utils 0.14 - Haskell Meapsoft Parser Utilities  http://hackage.haskell.org/package/hmeap-utils-0.14 (RohanDrape)
02:10:39 * hackagebot hts 0.14 - Haskell Music Typesetting  http://hackage.haskell.org/package/hts-0.14 (RohanDrape)
02:10:41 * hackagebot hly 0.14 - Haskell LilyPond  http://hackage.haskell.org/package/hly-0.14 (RohanDrape)
02:11:16 <donri> dcoutts_: what extra features would cabal repl bring? working :reload? what problems with cabal-dev ghci does it fix, i seem to recall there was something
02:12:30 <dcoutts_> donri: compared to cabal-dev, a less hacky impl. Yes, eventually we will be able to :reload and get pre-processors re-run
02:12:53 <donri> dcoutts_: ah, cabal-dev doesn't handle preprocs correctly?
02:13:10 <dcoutts_> donri: it probably runs them the first time, but not on :reload
02:13:15 <dcoutts_> donri: and I don't know cabal-dev's ui, does it let you say which component or module/file to look at?
02:13:45 <donri> i think it just :loads all your exposed-modules, but i haven't used it in a while
02:14:09 <dcoutts_> what about exes, or packages with multiple components
02:14:30 <dcoutts_> the code has a way to specify the target
02:14:39 <dcoutts_> similar to how you can now build a specific component
02:14:40 <donri> don't think it loads 'em, leading to people doing hacks like including exe deps in library section :p
02:14:45 <dcoutts_> cabal build blah
02:15:30 <donri> for example https://github.com/faylang/fay/blob/master/fay.cabal#L123
02:16:01 <dcoutts_> donri: not so surprising, as I understand it, it works by calling cabal build --with-ghc=fake-ghc-script
02:16:08 <donri> hehe
02:16:20 <dcoutts_> so what it can do is quite limited
02:17:06 <donri> dcoutts_: also, did anyone say you're doing amazing work? :)
02:17:12 <donri> both hackage and cabal
02:17:33 * dcoutts_ wishes he had more time
02:18:56 <donri> you're with well-typed right? do they let you do any of this on company time? hm or is well-typed yours even ...
02:19:52 <dcoutts_> donri: the IHG are funding Well-Typed to get hackage 2 out the door
02:20:00 <donri> ah right
02:20:11 <dcoutts_> which is why we're currently doing public alpha testing of that
02:20:40 * dcoutts_ is working on some non-critical hackage features in his spare time too
02:21:18 <Ralith> the IHG?
02:21:22 <donri> i wonder if crowd-funding a haskell grants fund could work, or if it needs to be earmarked...
02:21:27 <donri> Ralith: industrial haskell group
02:21:30 <dcoutts_> http://industry.haskell.org/
02:21:31 <Ralith> ah, cool
02:21:34 <AfC> dcoutts_: when bos (?) posted a link to say "try hackage2" one of my areas of feedback was that the page layout (and stylesheet) needed some love. I'd be willing to contribute the effort there if a modern presentation of the Haddock pages is of interest.
02:21:51 <donri> AfC: too late!
02:21:56 <dcoutts_> AfC: that would be welcome
02:22:11 <donri> dcoutts_ already did great work making it look like the ocean theme http://new-hackage.haskell.org/
02:22:21 <dcoutts_> AfC: you can see the version of the haddock theme that I stole http://new-hackage.haskell.org/
02:22:54 <AfC> donri: the problem is that it looks _terrible_ on small form factor devices.
02:23:00 <dcoutts_> AfC: but I'm in no way a ui designer, and most of the feedback I've had about the new site has been about its look :-)
02:23:09 <donri> well i guess everything could always use some polish. like i think the header font size is larger than in haddock
02:23:23 <AfC> donri: which is hard to get right.
02:23:25 <AfC> Actually, it's very hard
02:23:50 <AfC> Anyway, since it's so hard, I don't have anything bad to say about dcoutts_'s work.
02:24:00 <dcoutts_> heh :-)
02:24:05 <donri> yeah. at least it seems responsive, but only indirectly
02:24:15 * dcoutts_ basically just copied the haddock one
02:24:39 <AfC> [I put *months* into getting the corporate website for my consultancy to work on various form factors. It's achievable, but not-obvious what constraints to follow and non-trivial to stick with it to get there]
02:24:55 <AfC> Yeah, the haddock stylesheet needs help
02:25:09 <AfC> Of course, then people would bitch because it was different :)
02:25:17 <dcoutts_> AfC: the harder part to fix is the haddock stylesheet that's embedded in the docs of each package
02:25:25 <dcoutts_> not impossible
02:25:34 <AfC> dcoutts_: yeah, we have to fix that in haddock.
02:25:52 <AfC> dcoutts_: but worth doing if we're attending to both sides
02:25:56 <donri> honestly the haddock theme is kinda bad for *large* form factors, at least for haddock. code blocks that span 1920 pixels don't look great ...
02:26:00 <dcoutts_> yes, but also I mean about changing existing package docs
02:26:33 <dcoutts_> AfC: assuming we can do that just with the css and not needing any html changes
02:26:43 <donri> in deed, they should link the same stylesheet, so it's cached and can be updated easily
02:26:59 <donri> doesn't haddock have an option for this, hm
02:27:25 <dcoutts_> AfC: rebuilding all the docs for all packages on hackage is more or less out of the question
02:27:49 <donri> oh, --css takes a file path not a URL
02:28:27 <dcoutts_> donri: well, also in the new server we allow the package author or other hackage trustees to upload docs, so them being self-contained has some advantages
02:28:32 <donri> dcoutts_: hack solution: make hackage-server redirect those .css requests to a central URL
02:28:37 <AfC> dcoutts_: no, that's a common mistake, thinking CSS alone is enough to pull it off. The structure of the pages themselves has to support being styled accordingly.
02:28:51 <donri> dcoutts_: true
02:29:09 <donri> but maybe haddocks should be special-cased, since e.g. they're crosslinked anyway etc
02:29:17 <dcoutts_> donri: maybe
02:29:31 <AfC> [which is where it gets hard, because suddenly page layout you had before that made perfect sense desktop aspect-ratio only has to yield to a compromise]
02:29:59 <dcoutts_> AfC: well there was considerable work done on that I think when the haddock theme was last massively improved (you've seen the old one right?)
02:30:11 <donri> AfC: personally i vaguely feel that if you can't do it with css you shouldn't do it :p i think it leads to simpler designs which i like. but it's probably not practical
02:30:37 <AfC> dcoutts_: > rebuild, yeah, that ain't happening. But going forward the old ones will age out soon enough, and we can always force rebuild the current "latest" set if we have to.
02:30:51 <dcoutts_> AfC: yes
02:31:13 <AfC> dcoutts_: oh, like I said, I'm not complaining - it's hard work and it's ok now. It just needs another refresh
02:31:28 <Rc43> Hello.
02:32:03 <AfC> dcoutts_: I'll drop you an email a bit later and we can chat.
02:32:23 <dcoutts_> AfC: ok sure, btw we also eventually would like to do more than just the css on the new hackage site
02:32:48 <dcoutts_> AfC: e.g. someome prepared us an idea for a new page layout...
02:32:57 <AfC> Nice
02:33:20 <dcoutts_> AfC: http://code.haskell.org/~duncan/hackage-server-new-chrome/package.html
02:33:28 <Rc43> Anybody knows what exactly "make maintainer-clean" in ghc sources does?
02:33:29 <Rc43>  I encountered strange error and want to reconfigure build again, but don't want wait a day for recompilation; does "maintainer-clean" leave generated files?
02:34:02 <dcoutts_> Rc43: I think it removes shipped generated files
02:34:15 <dcoutts_> Rc43: the meaning comes from autoconf/configure conventions
02:38:20 <Rc43> dcoutts_, shipped? You mean there were any generated files in distribution?
02:38:34 <dcoutts_> Rc43: yes
02:38:40 <dcoutts_> like happy and alex
02:39:20 <dcoutts_> which are platform independent, and means you don't need happy an alex installed to build ghc from source
02:39:26 <dcoutts_> Rc43: pretty standard practice
02:43:17 <Rc43> dcoutts_, why it can be neeeded to clean then?
02:45:36 * hackagebot hsc3-rec 0.14.1 - Haskell SuperCollider Record Variants  http://hackage.haskell.org/package/hsc3-rec-0.14.1 (RohanDrape)
02:47:03 <hpaste> Rc43 pasted ‚Äúcygwin build error‚Äù at http://hpaste.org/86674
02:47:12 <Rc43> BTW, maybe anybody knows solution to my first problem: I am building ghc from sources on cygwin using haskell-platform (for windows); "configure" and "make" were successfull, but "make install" produce this errors (look up).
02:47:28 <Rc43> *these
02:47:51 <Rc43> It tries to open package.conf.d and somehow fails.
02:47:59 <Rc43> I looked now, it exists.
02:55:47 <kqr> [Data.Map] why would you use `fromAscList' instead of `fromDistinctAscList' or vice versa? what do you gain?
02:56:38 <shachaf> Efficiency.
02:56:42 <shachaf> (And you lose safety.)
02:57:09 <kqr> okay, so distinctAscList is faster, but it may blow up on you if you're not careful?
02:57:40 <shachaf> If your AscList is not Distinct then you shouldn't use fromDistinctAscList.
02:57:50 <shachaf> You'll get a bad Map.
02:57:52 <kqr> okay
03:00:44 <Rc43> More concrete: about problem above: I get << ghc-pkg.exe: /usr/local/lib/package.conf.d: openFile: does not exist (No such file or directory) >> after executing << "/usr/local/bin/ghc-pkg.exe" --force --global-package-db "/usr/local/lib/package.conf.d" update rts/package.conf.install >>
03:00:56 <Rc43> But this directory exists.
03:10:37 * hackagebot hsc3-graphs 0.14.1 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.14.1 (RohanDrape)
03:15:37 * hackagebot hsc3-utils 0.14 - Haskell SuperCollider Utilities  http://hackage.haskell.org/package/hsc3-utils-0.14 (RohanDrape)
03:25:55 <kqr> hm, is there a quick/recommended way to achieve `(a, [b]) -> [(a, b)]'? i couldn't find anything specific on hoogle, but i can think of a lot of ways to do it, but I don't know what would be considered idiomatic
03:26:41 <Eduard_Munteanu> :t Data.Traversable.sequence
03:26:43 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
03:26:50 <kqr> fancy that
03:27:15 <Eduard_Munteanu> > Data.Traversable.sequence (3, [5, 6, 7])
03:27:17 <lambdabot>   [(3,5),(3,6),(3,7)]
03:27:52 <shachaf> It's also called "strength".
03:28:20 <Eduard_Munteanu> :t sequence   -- it's the more general version of this
03:28:21 <lambdabot> Monad m => [m a] -> m [a]
03:29:03 <Scabe> Is it possible to do a case statement inside a case statement?
03:29:06 <kqr> Eduard_Munteanu, hm, my ghci complains about (,) not being traversable
03:29:08 <Eduard_Munteanu> Scabe: yep
03:29:13 <kqr> Scabe, yes
03:29:15 <Scabe> How would you do that?
03:29:26 <typoclass> Scabe: yes, you only need to pay attention to your indentation
03:29:50 <Scabe> Could you give me an example of how the syntax would look
03:30:31 <Botje> case foo of bar -> case bar of ...
03:30:56 <shachaf> > case case x of 5 -> False; _ -> True of False -> "yes"; _ -> "no"
03:30:58 <lambdabot>   "no"
03:31:22 <Scabe> interesting I'll try this out thanks!
03:32:45 <typoclass> Scabe: check this http://hpaste.org/86676 . the types in all the branches have to agree (here it's String)
03:33:16 <Scabe> Oh cool thanks typoclass will do
03:33:18 <Eduard_Munteanu> Hm, I forget if there's an actual (,) e Traversable instance in base packages.
03:33:18 <shachaf> What, everyone interprets the inner case as being inside one of the branches?
03:33:22 <shachaf> That's boring.
03:34:02 <klrr> i get a strange type error, anyone have an idea what this is all about? https://gist.github.com/klrr/5472635 (code and error in paste) basically it says the it except a certain type but it's wrong, but it's not wrong :P
03:34:24 <kqr> Eduard_Munteanu, there is not, it seems:  http://stackoverflow.com/a/3998770
03:34:29 <typoclass> shachaf: to spice things up, i interpret your word 'boring' as meaning 'exciting and green and moonly'
03:37:40 <Botje> klrr: why would it be a strange type error?
03:38:04 <Botje> klrr: look at line 44. what is the type of xs? what is the type of [xs]? what is the type of List [xs] ?
03:38:40 <klrr> Botje: it's List [Value]
03:38:43 <klrr> i think
03:39:21 <Botje> klrr: is that the answer to the last question?
03:39:50 <klrr> Botje: yes, but i guess it's not and i cant see where it goes wrong in my code
03:39:52 <Botje> klrr: look at the type of xs first.
03:39:58 <Botje> you do xs <- sepBy ...
03:40:11 <klrr> yes so xs is already a list?
03:40:19 <Botje> yes.
03:40:29 <Botje> so what is the type of [xs] ?
03:41:02 <klrr> Botje: wait, the error compiled another source file, it's not the right source for the error
03:41:21 <typoclass> klrr: if you turn on {-# LANGUAGE ScopedTypeVariables #-}, you can add a type annotation "xs :: List [Value] <- sepBy ...". sometimes that's useful to get some clarity
03:42:01 <typoclass> klrr: yes, the message says "x" while the source code says "xs". the message doesn't match the code
03:42:24 <klrr> wait i got some other errors now i might need some more help, but i gonna try first myself
03:42:44 <typoclass> klrr: good plan :-) good luck
03:42:56 <supki> > ("sequence", "_2 id") & both %~ length
03:42:58 <lambdabot>   (8,5)
03:44:30 <klrr> i just got one question, when using "<|>" can i do something like "(makeTheReturnValueToCorrectType someParser) <|> anotherParser..." ?
03:46:57 <Botje> you can chain parsers together using the standard monadic or applicative combinators
03:47:12 <Botje> liftm, fmap, <*>, etc
03:48:54 <klrr> eh i get same error https://gist.github.com/klrr/5472667 with the new source code too, and two new ones
03:50:41 * hackagebot Hs2lib 0.5.7 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.7 (TamarChristina)
03:53:54 <Botje> my remark about line 44 still stands.
03:57:18 <klrr> Botje: i dont understand actually, how should i make it the right type?
03:59:10 <Botje> apply thinking
03:59:18 <Botje> xs is of type [Value]
03:59:22 <Botje> what is the type of [xs] ?
03:59:46 <klrr> it's [[Value]] then
03:59:56 <klrr> okey so i can do simply "List xs"?
04:00:01 <Botje> yes.
04:00:02 <shachaf> Botje: Wow, that's an innovation.
04:00:06 <klrr> okey thanks!
04:00:25 <shachaf> You should patent it.
04:01:23 <Botje> shachaf: no, everyone should benefit from my invention!
04:02:29 <klrr> Botje: that's the spirit :D
04:03:28 <Breadmonster> So I'm using Haskell on Windows, and I can't access cabal.
04:03:39 <Breadmonster> Anyone know where it's stored?
04:03:52 <Breadmonster> Because the docs say that it comes with the Haskell platform.
04:05:19 <typoclass> Breadmonster: you may need to add the correct directory to your PATH. though i thought that the installer does that automatically. have you tried restarting your terminal?
04:05:51 <Breadmonster> typoclass: Yes, I've been running this for the past two weeks.
04:06:20 <klrr> WINDOWS Y ES CRAZY?!
04:06:45 <Breadmonster> typoclass: I can't find the cabal binary anywhere in the installation.
04:07:09 <Heffalump> breadmonster: try c:/Program Files (x86)/Haskell Platform/2012.2.0.0/lib/extralibs/bin/cabal.exe
04:07:21 <typoclass> Breadmonster: so when you do "ghc --version", you get sensible output, but "cabal help" will tell you that the binary wasn't found?
04:07:21 <typoclass> that's weird
04:07:22 <Heffalump> (if you have HP 2012.2.0.0, obviously)
04:09:34 <Breadmonster> Heffalump: Got it :D
04:09:56 <QinGW> why empty list is [a], not [] ?
04:09:57 <Breadmonster> typoclass: if you could please suggest that to the HP designers, I'd really appreciate it.
04:10:11 <Breadmonster> QinGW: The empty list is []
04:10:21 <klrr> i tried to solve the other issue, but now i get some even more long error even if i made a funktion that turned one type into the right one https://gist.github.com/klrr/5472716 , any ideas?
04:10:23 <Eduard_Munteanu> QinGW: [] :: [a]
04:10:38 <Breadmonster> typoclass: I had to add the gcc path variable myself.
04:10:50 <Eduard_Munteanu> QinGW: you might be mixing types and values due to the overlapping syntax
04:11:17 <QinGW> got it
04:11:26 <Breadmonster> Heffalump: Thank you.
04:11:38 <Breadmonster> Also, I see HP comes with parsec?
04:11:55 <shachaf> Only you can say whether you see it.
04:11:57 <kqr> I have a `Map a [Int]'. what would be the best way to add an Int to the list if they key a already exists, and if it doesn't exist create a singleton list with just that Int?
04:12:07 <Heffalump> Breadmonster: I have no idea why it's in that folder, though!
04:12:19 <klrr> i tried to solve the other issue, but now i get some even more long error even if i made a funktion that turned one type into the right one https://gist.github.com/klrr/5472716 , any ideas?
04:12:25 <Breadmonster> Heffalump: Me neither, I think I'll have to edit the path variables myself.
04:13:05 <shachaf> kqr: With lens: over (at k . non []) (e:)
04:13:58 <kqr> shachaf, oh wow that's just a soup of words for me. i guess i have some lenses to learn o_O
04:14:33 <shachaf> You don't have to use lens.
04:14:41 <Botje> klrr: valueToExpr is not a monadic function.
04:14:43 <shachaf> It just happens to have a convenient way to do this sort of thing.
04:14:50 <kqr> shachaf, yeah, i assumed so, and i like convenience
04:14:51 <typoclass> Breadmonster: problem reports can be filed here http://trac.haskell.org/haskell-platform/ . i think it's best if you do that, because i don't know your setup and what you did exactly. (i'm not even a windows user.)
04:15:15 <Botje> klrr: the type error you get is basically "expected type Value -> Parser Expr, actual type Value -> Expr"
04:15:17 <shachaf> Even better would be to use the new anon... But I think that's not out yet?
04:15:26 <Breadmonster> typoclass: Alright, though I don't think that's an error, tbh.
04:15:57 <Cale> kqr: insertWith (++) k [e]
04:15:59 <klrr> Botje: hmm, so i simply remake it's signature like this "Parser Value"?
04:16:04 <Breadmonster> typoclass: privileges are required to perform this operation
04:16:10 <Breadmonster> It's not letting me do that.
04:16:27 <Cale> You don't really need lenses for that, given that it's already an operation which Data.Map provides :P
04:16:32 <typoclass> Breadmonster: there's a 'register' link at the top right
04:16:36 <Breadmonster> Cale: What's a lens?
04:16:47 <kqr> Cale, that's what i was thinking initially, but i'm folding over a list of tuples to insert things, and that requires additional plumbing to do the [e] part
04:17:15 <Cale> well, insertWith (++) k . (:[]) ?
04:17:16 <Eduard_Munteanu> Breadmonster: an abstraction for setters/getters
04:17:29 <kqr> Cale, !
04:17:31 <kqr> Cale, brilliant
04:17:36 <kqr> Cale, i don't know why i didn't think of that
04:17:38 <kqr> Cale, thanks
04:17:46 <Cale> kqr: You could also use a lambda
04:18:00 <Cale> (\e -> insertWith (++) k [e])
04:18:20 <kqr> yeah, it was just so nice looking when i could `uncurry $ insertWith (++)` but i guess i need some more
04:18:21 <Breadmonster> Thanks guys :)
04:18:42 <kqr> "when I could" as in "if I could have"
04:21:14 <shachaf> With exciting new lens, you can use (anon _Empty) to get rid of the annoying use of (==).
04:21:26 <shachaf> Or you can use (anon [] null) right now, I guess.
04:21:32 <shachaf> But Bools are the devil.
04:24:14 <Botje> klrr: a typical solution would be to use liftM or fmap.
04:24:41 <shachaf> Just use fmap.
04:24:54 <alcatraz63> How can you actually constuct a Safe list in this MarkedList example? https://en.wikibooks.org/wiki/Haskell/GADT
04:24:58 <shachaf> liftM is not to be used unless absolutely necessary.
04:25:00 <Botje> or, if you insist on >>=, parseValues >>= return . valueToExpr
04:25:23 <shachaf> alcatraz63: Nil or Cons, just like regular lists.
04:25:24 <Eduard_Munteanu> valueToExpr <$> parseValues    is nicer for this
04:25:52 <alcatraz63> yes, but as long as u use Nil list is always unsafe
04:27:11 <alcatraz63> the only thing i can think of i adding another constuctor like Cons1 :: a -> MarkedList a Safe
04:29:55 <alcatraz63> nvm, i forgot to change b to c in COns
04:32:00 <alcatraz63> yeah but with c there you can just make markedList Int Foo
04:32:15 <shachaf> DataKinds can help with that.
04:32:22 <shachaf> {-# LANGUAGE DataKinds #-}
04:32:32 <shachaf> data Something = Safe | Unsafe
04:32:48 <shachaf> data List :: * -> Something -> * where ...
04:35:23 <Zenol> Hi. I have some newbee questions about lazyness and strictness / stackoverflow. First one : when I write sum acc n = sum (acc + 1) (n - 1) I have a stack overflow with big integers, and I assume that it's caused by the lazyness wich replace acc + 1 by a chunk. But
04:35:40 <Botje> you got cut off after but
04:36:08 <Eduard_Munteanu> Zenol: by a thunk, not chunk
04:36:28 <Cale> Zenol: An important thing to note is that the stack is not a call stack
04:36:31 <Zenol> Eduard_Munteanu > Yeh thunk, it's the morning ^^
04:36:36 <Eduard_Munteanu> Zenol: the problem is addition of normal numbers is strict, and you end up evaluating a very large thunk all at once
04:36:55 <Zenol> Yes yes, let me finish my sentence :p
04:37:04 <Cale> Also, I find it's easier to think at the level of expressions rather than worrying about the details regarding thunks.
04:37:09 * Eduard_Munteanu has mindreading abilities
04:37:10 <Eduard_Munteanu> :P
04:38:06 <Zenol> so : But, when I replace by sum acc n = v `seq` sum v (n-1) where v = acc + 1, wich make acc+1 be evaluated, it's works. I though it shouldn't because I still write n-1. Is the compiler doing some kind of optimisation or I misunderstand how it's working?
04:38:26 <Cale> Are you pattern matching on n?
04:40:51 <Zenol> Cale > No, just testing this function short function to understand how it's working.
04:41:19 <cmears> Zenol, but you must have a base case for it
04:41:28 <shachaf> Zenol: You don't have any other cases for sum? "sum v 0 = v" or anything like that?
04:41:44 <Zenol> Oh, yeh, so yes I'm matching the 0 value.
04:41:56 <shachaf> Yes. So you're forcing n each time to check if it's 0.
04:42:14 <cmears> That prevents a massive thunk from building up
04:42:21 <Zenol> Ohhh
04:42:42 <shachaf> You can't get all the way down to 0 and *then* force the entire thing to find out that you're actually at 0.
04:43:56 <alcatraz63> shachaf: what does DataKinds actually do? (cant find any wiki page with description)
04:44:05 <Eduard_Munteanu> You could still add seq / bang patterns for clarity.
04:44:14 <Zenol> Ok, so if I had a case sum' 42 _ =, then I don't need the `seq`?
04:44:39 <Eduard_Munteanu> Zenol: only if the result is evaluated
04:44:40 <shachaf> @google giving haskell a promotion
04:44:41 <lambdabot> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
04:44:42 <lambdabot> Title: Giving Haskell a Promotion
04:45:01 <shachaf> Zenol: Yes. If you pattern-match on the value then it'll be forced.
04:46:05 <Zenol> Ok and, if I add sum  0 0 = 0. Is it evaluating the value of acc each time or only when n equals 0?
04:46:42 <shachaf> You can probably find that out.
04:46:50 <alcatraz63> ghc-mod lint actually cant parse code with DataKinds
04:47:11 <alcatraz63> was getting a strange error
04:47:15 <shachaf> > let f 0 0 = False; f _ _ = True in f 1 undefined
04:47:17 <lambdabot>   True
04:47:18 <shachaf> > let f 0 0 = False; f _ _ = True in f 0 undefined
04:47:20 <lambdabot>   *Exception: Prelude.undefined
04:47:44 <shachaf> You can look in the Haskell Report for the exact rules on what something like "f 0 0 = 0" means.
04:48:11 <Eduard_Munteanu> It's not quite pattern-matching proper though.
04:48:37 <Eduard_Munteanu> It's sugar for equality comparison.
04:49:03 <alcatraz63> shachaf: ty
04:49:16 <shachaf> Eduard_Munteanu: It is pattern-matching, because 0 is a pattern.
04:49:28 <shachaf> But it's an unusual kind of pattern-matching. :-)
04:49:52 <Eduard_Munteanu> I think that should be reserved for inductively-defined types.
04:50:14 <Zenol> I tested with the sum example and pattern matching on acc cause the value tu be evaluated each time.
04:50:31 <Eduard_Munteanu> BTW, don't you get case expressions and eq tests in Core?
04:51:05 <shachaf> Core case expressions are different from Haskell case expressions anyway.
04:51:55 <Eduard_Munteanu> Fun stuff: define a weird Num instance, like the one for functions. Matching on numbers like that won't work because you don't have Eq.
04:52:12 <shachaf> Eduard_Munteanu: It does in Haskell. GHC is sadly not compliant.
04:52:22 <Eduard_Munteanu> Hm, odd.
04:52:34 <shachaf> (Becuase the Report has Eq as a superclasss of Num.)
04:52:42 <Eduard_Munteanu> Oh.
04:53:27 <Eduard_Munteanu> Is this in Haskell2010 or ever since 98?
04:54:09 <shachaf> It's since 98 and before 98.
04:54:20 <shachaf> Haskell 1.4: class (Eq a, Show a, Eval a) => Num a
04:54:40 <shachaf> GHC made the breaking change fairly recently.
04:55:14 <shachaf> Probably Haskell 2039 (the next version, at the current rate) will reflect it.
04:55:34 <Eduard_Munteanu> :(
04:55:37 <Zenol> I have an other question about list \o/ I have a list made from "iter buildNextState initialState". I would like to make the first n states to be evaluated without launching a "stack space overflow".
04:56:14 <Eduard_Munteanu> Zenol: not sure what those functions are
04:56:23 <Cale> Zenol: Just make sure that no large expressions are being accumulated
04:56:39 * Cale dislikes the word thunk at this level of discussion
04:56:44 <Eduard_Munteanu> Zenol: but if I my hunch is right, you want to evaluate the first n elements in order
04:56:45 <Zenol> Cale > large expressions?
04:56:57 <Zenol> Edward_Munteanu > Yes
04:57:06 <Cale> Zenol: The stack is a stack of pattern matches which are waiting to occur
04:57:32 <Cale> When, say, a case expression pattern matches on something which is not already a constructor
04:57:48 <Cale> that case expression goes on the stack, and its scrutinee is evaluated
04:58:33 <Cale> If the scrutinee is a large expression which consists of many more things which will involve cases pattern matching, you can eventually get a stack overflow
04:58:46 <Cale> For example, let's look at:
04:58:48 <dsturnbull> a library i'm trying to install via cabal (chuchu) is complaining about a type constructor or class `Applicative' not being in scope. any way to help this along? Applicative seems to belong in Control.Applicative which is in the base platform, right?
04:59:02 <Cale> foldl (+) 0 [1..1000000]
04:59:09 <Cale> @src foldl
04:59:09 <lambdabot> foldl f z []     = z
04:59:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:59:46 <Cale> So,  foldl (+) 0 [1..1000000] -> foldl (+) (0 + 1) [2..1000000]
04:59:57 <vamega_> Hi
04:59:58 <Cale> -> foldl (+) ((0 + 1) + 2) [3..1000000]
05:00:32 <vamega_> I was wondering if someone here had a good idea for a project where I could use AttoParsec.
05:00:34 <Cale> -> ... -> foldl (+) ((...((0 + 1) + 2) + ... ) + 1000000) []
05:00:50 <Cale> -> ((...((0 + 1) + 2) + ... ) + 1000000)
05:01:01 <Cale> up to this point, very little stack space will have been used
05:01:14 <vamega_> I'm trying to learn Haskell, with the eventual goal of using it to make a implement a SSH client using the language.
05:01:17 <Cale> (just enough to evaluate the [k..1000000] expressions)
05:01:41 <vamega_> But a simpler example to get my feet wet would be really helpful
05:01:45 <Cale> But now we have something of the form (... + 1000000), and (+) needs to know what its left argument is to be able to evaluate
05:01:57 <Cale> (i.e. it is internally doing some pattern matching)
05:02:29 <Cale> and so this pattern match will go on the stack, and we'll evaluate (... + 999999), which will do a similar thing
05:02:52 <Cale> and by the time we get to (0 + 1) which can successfully evaluate, we'll have at least used a lot of stack space
05:03:04 <Cale> Zenol: does that make sense?
05:03:53 <Cale> Zenol: foldl didn't itself cause a problem, but it built up this giant expression whose evaluation was problematic to carry out
05:04:29 <Cale> Now, compiling with optimisations will do strictness analysis and sometimes get rid of problems like this, but you probably shouldn't rely too much on it.
05:05:04 <Cale> dsturnbull: that's correct
05:05:24 <Zenol> Cale > I think I see the idea but no the details. What is stored on the stack when the expression foldl (+) [1..1000000] is ... err... unfolded? :)
05:05:34 <Cale> nothing
05:05:41 <Cale> Well, okay
05:05:54 <supki> dsturnbull: you can get the source with  cabal unpack chuchu,  fix imports and installed fixed package with  cabal install chuchu.cabal
05:05:54 <Cale> [1..1000000] isn't directly of the form (x : xs)
05:06:05 <supki> s/installed/install/
05:06:16 <Cale> So the pattern match in foldl on the list parameter can't match until that thing evaluates to 1 : [2..1000000]
05:06:58 <Cale> So, foldl's pattern match (which you can think of as desugaring into a case expression) will go on the stack for just a moment
05:07:27 <Cale> But [1..1000000] will immediately evaluate to 1 : [2..1000000], and the stack will be popped again, and x will match 1 and xs will match [2..1000000]
05:07:40 <Cale> foldl f z (x:xs) <-- in this pattern here
05:08:11 <Cale> So the stack will barely be used (just one entry at a time) until foldl finishes running to the end of the list.
05:08:41 <Cale> at which point the 'z' parameter will have built up into this giant expression (thunk)
05:09:18 <Zenol> Cale > So the thunk is the giant expression and is not stored on the stack?
05:09:24 <Cale> right
05:09:48 <Cale> Thunks are the low-level datastructure used to represent expressions at runtime.
05:10:08 <dsturnbull> thanks, problem solved, turned out to be a pretty bad library anyway though. :)
05:10:11 <Cale> (i.e. expressions which have yet to be evaluated)
05:10:11 <Zenol> Cale > Ok. So if I get a stack space overflow it means that it's a pattern matching that is too deep?
05:10:31 <Cale> yes, likely because some giant expression has been accumulated
05:12:20 <Cale> An expression consisting of functions all or most of which need to pattern match on their arguments before they can produce anything.
05:13:12 <Cale> (+) on Integers has this property - it can't produce anything at all until both its arguments are evaluated
05:13:26 <Zenol> Cale > So building expressions with lots of constructor and so are not so costly?
05:13:53 <Cale> Well, you won't get a stack overflow from them anyway
05:14:18 <Cale> They'll use lots of heap space perhaps, but pattern matches on bunches of constructors will immediately finish
05:14:39 <Cale> and not need to use any stack space
05:15:37 <klrr> Botje: how do you mean i should use fmap or liftM? like "fmap valueToExpr $ parseExpr" ?
05:15:44 <Cale> after all, when you have a simple case expression which, say, tries to match against [] or (x:xs), if the expression is already in one of those two forms, it doesn't have to do any further evaluation to match
05:16:18 <Eduard_Munteanu> You also get to use foldr efficiently, which is nice because it builds the result as it goes (and it can be consumed).
05:16:26 <Eduard_Munteanu> (IOW, it's productive)
05:16:53 <HDD-Pro> anyone around? I need help with inspect URL
05:17:09 <Zenol> Cale > So, if I get a stack overflow when I was trying to evaluate the n'th element of the list of iter updateState initialState, it was because I was asking the value of the n'th element, so it should climb back to the first element through pattern matching (and through all the pattern matching functions used by updateState) ?
05:17:14 <Eduard_Munteanu> HDD-Pro: hi, you should ask questions straight away
05:18:31 <Zenol> So maybe something like foldr initialState (iter updateState) (\s f -> f s) would works?
05:18:40 <luite> Eduard_Munteanu: but in the (+) example it just overflows the stack
05:19:01 <Eduard_Munteanu> I mean for inductively-defined data types.
05:19:08 <Eduard_Munteanu> Non-strict stuff.
05:19:28 <Eduard_Munteanu> Zenol: depends if that's strict or not.
05:19:52 * Eduard_Munteanu hasn't been following closely
05:20:00 <HDD-Pro> Hey Eduard_Munteanu, I have various clicks on an application, I need to know the URL that is used behind them, to do so, I have to click inspect URL for every click and then see if this is the right url or not, how can I see that URL for everylink at one single time
05:20:33 <HDD-Pro> for example, I see the backend coding instead of the image on the webpage
05:20:37 <HDD-Pro> how can I see that
05:20:43 <Zenol> @src foldr
05:20:44 <lambdabot> foldr f z []     = z
05:20:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:21:57 <Cale> Zenol: yes, if iter is anything like the standard iterate function, and you're pulling out the nth element without evaluating the others first, then by the time you get to the nth element, it might be a pretty big expression for the evaluator to swallow all at once
05:22:15 <Cale> Zenol: But if you force the evaluation of the list elements as you walk down the list, then it might fix the problem
05:22:36 <Cale> strictList [] = []
05:22:54 <Cale> strictList (x:xs) = x : x `seq` strictList xs
05:23:10 <Cale> Try applying that function to your list before extracting the nth element
05:23:14 <Cale> and see if that helps
05:23:39 <HDD-Pro> how can I view onclick by just hovering?
05:23:49 <Cale> oh, parens...
05:23:56 <Zenol> Cale> Thanks, I try that right now :)
05:23:58 <Cale> strictList (x:xs) = x : (x `seq` strictList xs)
05:25:35 <Cale> Zenol: Depending on the types of things involved, the amount of evaluation which seq causes might or might not be enough.
05:25:43 * hackagebot crypto-pubkey-openssh 0.2.0 - OpenSSH public keys parser  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.0 (FedorGogolev)
05:25:56 <klrr> how do i turn a Parser that returns a ceratin type into another tpye?
05:25:58 <klrr> type*
05:26:46 <Zenol> Cale > Yes but I think that deepSeq would be too much. I'm working on someoneelse's code and I do not completely know how looks like the data.
05:29:35 <HDD-Pro> Hey, there is a click action on a website. How can I know what will happen when I will click it? I can find the option by inspect URL, but how can I save this step and see it directly?
05:29:45 <kqr> Could not find module `Control.Applicative'\nPerhaps you haven't installed the profiling libraries for package `base'?
05:29:50 <kqr> how would i install those? or do i not need to?
05:30:07 <kqr> (i want to profile my program)
05:34:07 <Cale> Zenol: Yeah, deepSeq is usually much more than is required
05:34:54 <Cale> kqr: It's hard to imagine how you installed ghc without getting those, but if you installed via your system package manager, they might be in a separate package
05:35:26 <Cale> kqr: Debian in particular likes to break up their ghc package into 100 tiny fragments.
05:36:32 <kqr> Cale, i'm on ubuntu, and i might have went via haskell-platform in the package manager
05:37:49 <aCube> you might need to install haskell-platform-prof
05:38:15 <kqr> aCube, seems like that was it. thanks
05:39:00 <Zenol> Cale  > Main: out of memory (requested 1048576 bytes) \ o /
05:41:24 <Mortchek> klrr, if it's a functor value, fmap
05:42:12 <Zenol> The states I'm applying updateState on are some kind of arrays with 500*500 Word8. When I build this list by iter f x = let x' f x in x' : x' `seq` iter f x', are all the previous calculated states keeped in memory?
05:46:41 <Botje> klrr: yes, you want to liftM (or fmap, it's the same) the valueToExpr function to your Parser monad, so fmap valueToExpr parseExpr
05:47:15 <ski> > 9999999999999999999999999999999999999999 :: Int32
05:47:17 <lambdabot>   -1
05:47:28 <aCube> xD
05:47:36 <aCube> Why is it -1? :O
05:48:45 <aCube> > 9999999999999999999999999999999999999998 :: Int32
05:48:46 <lambdabot>   -2
05:49:43 <Eduard_Munteanu> HDD-Pro: is this related to Haskell at all?
05:50:47 <Eduard_Munteanu> Maybe that question is more suitable for another channel.
05:59:48 <Zenol> Are there a way to have trace of the use of memory with ghc (I mean to understand where out of memory error come from)?
06:00:26 <cmears> Zenol, you can try the memory profiler
06:01:42 <cmears> See http://book.realworldhaskell.org/read/profiling-and-optimization.html for some examples
06:01:44 <Cale> aCube: Well, 9999999999999999999999999999999999999999 + 1 is divisible by 2^32
06:02:11 <Cale> aCube: 100...000 would be divisible by 2^32 because it's divisible by 10 so many times
06:03:30 <Cale> > 2^32 :: Int32
06:03:32 <lambdabot>   0
06:03:39 <Cale> > 2^31 :: Int32
06:03:40 <lambdabot>   -2147483648
06:04:06 <aCube> I know that. But why is 9999999999999999999999999999999999999999 exactly didvisible by 2 ^ 32?
06:04:12 <Cale> It's not
06:04:30 <aCube> ah right, +1 is
06:04:44 <Eduard_Munteanu> No odd number is divisible by a power of 2.
06:04:46 <aCube> > length $ show $ 9999999999999999999999999999999999999999 + 1
06:04:47 <Cale> Adding 1 to it gives a number of the form 10000...00000, with more than 32 zeroes
06:04:47 <lambdabot>   41
06:05:16 <hpc> so you have a number divisible by 10^32
06:05:24 <hpc> 10^32 is divisible by 2^32
06:05:47 <Cale> For similar reasons
06:05:49 <Eduard_Munteanu> 10^32 = (2 * 5)^32 = 2^32 * 5^32.
06:05:55 <Cale> > product [1..100] :: Int32
06:05:57 <lambdabot>   0
06:06:51 <aCube> ah ok, that's a nice trick :D
06:07:03 <latermuse> can someone quickly summarize what a free applicative functor is? what does the 'free' refer to?
06:08:40 <pete_> So I have some strings which represent character sets; for example, one is: ['0'..'9'] ++ ['a'..'f'] for hex
06:09:00 <pete_> I have an ord' function that takes one of these and a character, and does a pretty stupid linear search across it
06:09:05 <pete_> to say what index a given character is
06:09:29 <pete_> What would be less stupid, using built-ins only?
06:09:47 <Eduard_Munteanu> > chr '9'
06:09:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:09:49 <lambdabot>              with actual type ...
06:09:56 <aCube> > ord '9'
06:09:58 <lambdabot>   57
06:10:01 <aCube> > char 57
06:10:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:10:02 <lambdabot>    arising from the literal `5...
06:10:07 <aCube> > chr 57
06:10:08 <lambdabot>   '9'
06:10:23 <pete_> OK, so as I said, I'm using custom character sets here, rather than ASCII
06:10:31 <Eduard_Munteanu> Ah.
06:11:09 <aCube> Is there something like boost::bimap (a map that is bidirectional, i.e. both types are keys and one can easily find the other key) in haskell?
06:11:10 <Eduard_Munteanu> pete_: a Map wouldn't be too bad
06:11:25 <pete_> Eduard_Munteanu: What module provides that?
06:11:30 <aCube> Data.Map
06:11:33 <pete_> Eduard_Munteanu: That would also mean I could precompute what I want to do with it
06:11:47 <Eduard_Munteanu> Precompute how?
06:12:03 <pete_> I am going to the long way around turning these in to bitmaps
06:12:42 <pete_> I have a reasonably efficient function that does: Encoding -> [Bool] -> Char
06:12:58 <pete_> And a very slow one that goes the other way
06:13:53 <supki> > (['a'..'z'] ++ ['0'..'9']) ^@? traversed . filtered (== '7')
06:13:55 <lambdabot>   Just (33,'7')
06:14:41 <pete_> That looks like a slightly more concise version of:
06:14:41 <pete_> ord e s = ord' 0 (charset e)
06:14:42 <pete_>     where ord' c [] = error "ord fail"
06:14:42 <pete_>           ord' c (x:xs) = if (x == s) then c else ord' (c+1) xs
06:15:08 <pete_> which is what I have
06:16:16 <aCube> > filter ((== '7'). snd) $ zipWith [1..] $ ['a' .. 'z'] ++ ['0' .. '9']
06:16:18 <lambdabot>   Couldn't match expected type `a0 -> b0 -> c0'
06:16:18 <lambdabot>              with actual type...
06:16:24 <aCube> > filter ((== '7'). snd) $ zip[1..] $ ['a' .. 'z'] ++ ['0' .. '9']
06:16:26 <lambdabot>   [(34,'7')]
06:16:38 <aCube> > filter ((== '7'). snd) $ zip [0..] $ ['a' .. 'z'] ++ ['0' .. '9']
06:16:40 <lambdabot>   [(33,'7')]
06:18:24 <aCube> @ty Data.Bimap.fromList
06:18:25 <lambdabot> Couldn't find qualified module.
06:19:04 <klrr> can someone help me? i get some strange type error, "expected type IO t0' with actual type Expr'" https://gist.github.com/klrr/5473103 (error and code in paste), any ideas what ive done wrong?
06:19:18 <supki> > '7' ^.. to ((fromIntegral :: (Int -> Word8)) . ord) .  bits
06:19:20 <lambdabot>   [True,True,True,False,True,True,False,False]
06:21:26 <aCube> klrr, readExpr returns 'Expr', but >>= for the IO monad is of type IO a -> a -> IO b -> IO b, so you somehow have to return an IO action
06:21:56 <aCube> klrr, I guess you want fmap, which is of type (specialized for IO) (a -> b) -> IO a -> IO b
06:21:58 <luite> what's a good way to make short globally unique ids that guarantee uniqueness even between multiple (possibly parallel) invocations of the program?
06:22:41 <aCube> luite, use the pid of the program ?
06:23:26 <klrr> aCube: okey
06:23:49 <luite> aCube: the pid is hardly unique
06:23:56 <luite> oh i need thousands of them per run
06:25:37 <aCube> luite, must those ids also be unique between multiple sequential runs? i.e if I run the program twice?
06:25:42 <elliott> aCube: dropping the parens in (>>=)'s type is a really bad idea
06:25:43 <luite> yes
06:26:03 <aCube> elliott, oops, that'a a type
06:26:50 <luite> it's for generating javascript names for ghcjs local functions. they need to be globally unique, multiple runs of ghcjs can generate parts of a program that need to be linked to a single js file
06:39:32 <klrr> aCube: can you give an example with fmap i dont know how to use fmap except for stuf like using list?
06:42:06 <ski> > array ((0,1),(2,3)) [((i,j),i^j) | (i,j) <- range ((0,1),(2,3))]
06:42:07 <ski> > fmap (^ 2) (array ((0,1),(2,3)) [((i,j),i^j) | (i,j) <- range ((0,1),(2,3))])
06:42:07 <Cale> klrr: Well, the type of fmap for any given f will tell you most of what you need to know about what it's going to do.
06:42:08 <lambdabot>   array ((0,1),(2,3)) [((0,1),0),((0,2),0),((0,3),0),((1,1),1),((1,2),1),((1,...
06:42:08 <lambdabot>   array ((0,1),(2,3)) [((0,1),0),((0,2),0),((0,3),0),((1,1),1),((1,2),1),((1,...
06:42:52 <klrr> Cale: i dont get it, i can do stuff like "fmap (+2) [1,2,3]" but how do i use it instead of a do expression?
06:42:58 <Cale> klrr: For example, there's one particularly natural way to take a function of type (a -> b) and an action of type IO a, and somehow get an action of type IO b
06:43:16 <Cale> which is just to produce the action which does the same thing, but applies the function to the result
06:43:40 <Cale> So we ought to have  fmap f x = do v <- x; return (f v)
06:43:40 <klrr> okey
06:44:35 <ski> @type fmap (read :: String -> Integer) getLine
06:44:36 <lambdabot> IO Integer
06:44:42 <klrr> Cale: but now i get that args is not in scope :/
06:44:43 <ski> @type getLine
06:44:48 <lambdabot> IO String
06:44:52 <Cale> klrr: What's args?
06:45:14 <klrr> http://hpaste.org/86678
06:45:21 <klrr> args is a list of strings
06:45:47 <Cale> and what's arg?
06:45:48 * hackagebot cufft 0.1.0.0 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.0.0 (RobEverest)
06:45:58 <klrr> Cale: args is a list of strings
06:46:06 <klrr> from the command line
06:46:08 <Cale> Yeah, but you have arg on line 9
06:46:10 <Cale> not args
06:46:15 <Cale> Maybe you wanted args there
06:46:18 <klrr> aa ops
06:46:47 <klrr> now i get "Couldn't match expected type `String' with actual type `Char'"
06:47:00 <klrr> on line 9
06:47:37 <klrr> and if i remove the "head"
06:47:47 <klrr> "Couldn't match expected type `IO String' with actual type `[String]'
06:47:49 <klrr> "
06:48:39 <klrr> also why is args of type IO String when i used "<-" ?
06:48:49 <klrr> i want it to be a string
06:48:49 <aCube> klrr, you don't need the fmap there. You don't have any IO in these functions. A simple let binding will do it: let expr = readExpr $ head args
06:49:27 <klrr> type system is messy and illogical for idiot peoples like me sry for distriburbing and thanks i ll try a let epxression
06:50:01 <Cale> klrr: args :: [String], so head args :: String, and readExpr :: String -> Expr, so  readExpr (head args) :: Expr
06:50:09 <Cale> which is also not an IO action, so you don't need to run it
06:51:00 <klrr> Cale: then why did it not work in the first place ? =o
06:51:20 <klrr> is "<-" only for IO actions?
06:51:29 <klrr> i thought it could be used to bind a value
06:51:31 <ski> `<-' is for monadic actions
06:51:42 <ski> for *executing* monadic actions
06:51:48 <ski> e.g. for `IO'-actions
06:52:03 <ski> `=' is for binding the value of an expression to a variable
06:52:22 <Cale> klrr: v <- x means "execute the action x and call its result v"
06:52:24 <ski> (evaluating an expression is different from executing an action)
06:52:39 <klrr> Cale: okey
06:52:41 <dsturnbull> can i pattern match in a way that constrains type?
06:52:53 <dsturnbull> ...in order to specialise a polymorphic function
06:52:59 <kennyd> klrr
06:53:04 <ski> dsturnbull : perhaps you want GADTs ..
06:53:38 <dsturnbull> yes, GADT makes sense for what i want to do. can i make my GADT an instance of Num, for example?
06:54:14 <dsturnbull> or constrain the GADT operands to Num in the decl?
06:55:32 <ski> dsturnbull : you can add a `Num a' constraint on a data constructor of the `GADT', such that when you have something of type `Foo a', and match it on pattern `Blah x y', then you learn that `x :: a',`y :: [a]', and *also* that `Num a'
06:55:36 <ski> e.g.
06:56:06 <ski> this example being `data Foo :: * -> * where Blah :: Num a => a -> [a] -> Foo a'
06:56:19 <ski> so, you can "hide" constraints on variables inside the GADT
06:57:02 <ski> and you can have a function `foo : Foo a -> ..a..', which doesn't have a constraint `Num a', but after you've matched on the `Blah' constructor, you can use `Num'-dependant operations anyway, inside the definition of `foo'
06:57:19 <ski> dsturnbull : is that roughly what you wanted ?
06:57:24 <dsturnbull> ok, yeah, i got it
06:57:48 <dsturnbull> thanks
07:25:18 <true_droid> can anyone suggest a practical book for Haskell like the Yesod book? what I'm looking for is not an introductory material, but something targeted at proficient Haskell developers and that covers some specific industry / frameworks
07:25:54 <elliott> I don't think there really is anything general like that
07:25:58 <elliott> I think the Yesod people were working on one
07:26:14 <elliott> individual frameworks have their own material, of course
07:29:19 <true_droid> this is one looks like it could be interesting http://www.haskell.org/haskellwiki/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B_%D0%BD%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5_Haskell
07:31:54 <dmwit> edwardk: pong
07:32:14 <art12> http://www.i-m.co/ramanda/raody/
07:32:45 <dmwit> art12: Is that related to Haskell in any way?
07:37:20 <ab9rf> art12: can you provide an executive summary?  my browser is laggy today.
07:37:46 --- mode: ChanServ set +o geekosaur
07:41:27 <edwardk> dmwit: reping
07:43:39 <dmwit> repong
07:44:32 <qwert> hello i have a question i have a structure like  data RegEx = Letter char | Seq [RegEx]  and i want to add in Seq more than 1 Letter that i extract from a Pair x= (a,b)   i have the constructor of the Letter (Letter(fst(x)))  how do i add it to Seq?
07:45:07 <Botje> you call Seq with a list of RegEx values.
07:45:34 <Botje> so you could do Seq [Letter 'a', Letter 'b']
07:46:09 <mm_freak> wow, that's confusing
07:47:45 <qwert> how can i translate this into a function using the list contructor?
07:47:52 <Botje> *blink*
07:48:20 <Botje> [...] is the list constructor.
07:48:26 <qwert> function x = Seq++ (Letter(fst(x))) something like this
07:48:29 <Botje> is that not what you meant?
07:48:56 <Botje> if you have an existing Seq you can pattern match on it and extend the list that way
07:49:00 <mm_freak> qwert: you seem to think imperatively‚Ä¶  a RegEx is an immutable value
07:49:09 <Botje> extend (Seq rs) r = Seq (r:rs)
07:49:11 <Botje> for example.
07:49:35 <Botje> that will put the regexp r at the front of the sequence of regexps rs.
07:49:35 <elliott> I like to think edwardk and dmwit have been pinging each other for no reason for hours
07:49:43 <mm_freak> and i'd call that 'precededBy' instead of 'extend'
07:49:47 <Botje> if you want the back, then it's rs ++ [r]
07:50:16 <dmwit> elliott: feels that way =P
07:50:38 <qwert> ok i will try thank you
07:50:40 <dmwit> I think it's a SlowLoris attack.
07:50:48 <mm_freak> (mainly to avoid confusion with the other extend :: (Comonad w) => w a -> (w a -> b) -> w b)
07:51:00 <edwardk> dmwit: rereping
07:51:13 <elliott> @ping
07:51:13 <lambdabot> pong
07:51:34 <mm_freak> i think that's a way to DoS-attack edwardk and thus bring the whole haskell community to its knees
07:51:44 <mm_freak> ping edwardk on IRC using a large botnet
07:56:40 <qwert> Botje : it worked thanks
07:58:53 <cmccann> elliott: ping
07:58:57 <elliott> cmccann: ping
07:59:00 <cmccann> elliott: ping
07:59:00 <elliott> cmccann: pong
07:59:03 <elliott> cmccann: ping
07:59:04 <elliott> cmccann: pong
07:59:04 <hpc> hpc: ping
07:59:05 <cmccann> elliott: pong
07:59:09 <elliott> ok this is stupid.
07:59:10 <cmccann> ok this is stupid
07:59:12 <elliott> help
07:59:13 <cmccann> ...
07:59:15 <hpc> elliott: SYN
07:59:16 <hpc> elliott: SYN
07:59:17 <hpc> elliott: SYN
07:59:30 <elliott> cmccann: please tell me that was just an incredibly quick copy of my message
07:59:33 <cmccann> no
07:59:33 <mm_freak> *: RST
07:59:37 <cmccann> that is literally what I typed
07:59:45 <cmccann> I type faster than I copy and paste
08:00:10 <nexx> cmccann for all lengths? :O
08:00:53 <ctc> where do we need data families instead of type families, any good examples? does it have to do with injectivity?
08:01:13 <elliott> ctc: yes, they can also often infer better (because of the injectivity)
08:01:24 <mm_freak> ctc: i used them mainly for optimizing
08:01:27 <cmccann> nexx: only for things short enough that copying and pasting is slower, obviously
08:01:50 <elliott> cmccann: I, too, am slower at typing things than copying them when they are short enough that copying and pasting is slower
08:01:56 <elliott> I am also equal to myself
08:02:11 <elliott> and my existence implies truth
08:02:21 <cmccann> how remarkable
08:02:51 <isBEKaml> Now, whose existence would imply falsehood? Falsehood itself?
08:03:13 <cmccann> isBEKaml: probably shachaf.
08:03:22 <isBEKaml> *lol*
08:04:03 <ctc> do we have ordered overlapping data families equivalent to ordered overlapping type families in GHC HEAD (or in the near future)?
08:04:25 --- mode: geekosaur set -o geekosaur
08:15:26 <mm_freak> ctc: i think that overlapping data family instances are unsafe
08:15:38 <mm_freak> in a very technical segfaulty sense
08:26:12 <fruitFly> I'm trying to find the the lowest common multiple of the numbers [1..20]
08:26:22 <fruitFly> I'm getting an error at my first gaurd; I'm not sure what's wrong. http://codepad.org/dymYWWlD
08:26:35 <mm_freak> > foldl' lcm 1 [1..20]
08:26:36 <lambdabot>   232792560
08:27:58 <Cale> fruitFly: You're not allowed to have a guard there.
08:28:10 <fruitFly> mm_freak: oh lol... but I haven't even reached folds yet in learnyouahaskell ... I'm interested in your implementation but would still like to get my more verbose one working
08:28:14 <Cale> fruitFly: Guards go before the = sign in a declaration.
08:28:15 <no-n> (map f [0..]) !! 138460 -- is this equivalent to "f 138460" because of laziness or will it calculate f n for n = 0..138459 as well?
08:28:24 <Cale> fruitFly: (and there will be one = sign per guard)
08:28:59 <Cale> fruitFly: But it doesn't particularly make sense to have guards on main as well (because main is not a function, so whichever guard succeeds would always do so)
08:29:13 <Cale> I guess you could do that as a method of conditional compilation or something.
08:29:15 <ab9rf> can i use gourds instead of guards?
08:29:17 <Saizan> no-n: it won't calculate the the other applications of f
08:29:28 <sipa> no-n: the spine of the list will be evaluated for 138459 entries
08:29:29 <fruitFly> Cale: I'm trying to follow http://learnyouahaskell.com/syntax-in-functions#guards-guards ... isn't my gaurd before the equal sign (the main thing aside)?
08:29:36 <sipa> no-n: the actual data in it won't
08:29:47 <Cale> fruitFly: You have  main = lcm n d | ...
08:29:56 <no-n> sipa: I don't know what you mean
08:30:05 <ab9rf> you gget 138459 thunks?
08:30:09 <Cale> fruitFly: Perhaps you intended to make lcm a separate declaration from main
08:30:47 <fruitFly> Cale: I'm not trying to have the gaurds applied to main... just lcm
08:30:57 <fruitFly> Cale: oooh ok
08:31:01 <sipa> no-n: a list _:_:_:...:_:x will be built
08:31:13 <no-n> ahh
08:31:20 <sipa> but the data in it won't
08:31:22 <fruitFly> *thinking*
08:31:26 <sipa> so f will only be evaluated for one application
08:31:43 <fruitFly> Cale:  lyah hasn't even gone over main i don't think... but i remember the other day u sticking it in "main = print(..." to get my program to work
08:31:51 <Cale> no-n: and what's more, those list cells will immediately be garbage as it walks down them, so as little as one cell of them will be in memory at any moment
08:32:14 <ab9rf> Cale: is ghc smart enough to figure that out and optimize out the entire spine walk?
08:32:32 <Cale> fruitFly: yeah, you can write  main = print (some expression)  to make it actually print the value of that expression, but that'll be separate from the rest of your program.
08:32:58 <Cale> ab9rf: Not as such
08:33:02 <Saizan> ab9rf: depends on whether there's a rewrite rule for (!!) i guess
08:33:11 <no-n> neato, Cale
08:33:23 <Cale> ab9rf: There are things which it will optimise out, but I don't believe this is one of them.
08:33:36 <Cale> You might add a RULES pragma to handle this
08:33:50 <fruitFly> Cale:  so how do I just define main without it being attached to lcm?
08:33:59 <Cale> http://codepad.org/1APGObA9
08:34:06 <hpaste> greeny pasted ‚ÄúParse error in pattern‚Äù at http://hpaste.org/86681
08:34:14 <Cale> (there's a timeout because of another issue)
08:34:38 <Cale> or better yet, make lcm' a plain function
08:34:42 <Cale> http://codepad.org/z3MTXV9b
08:35:55 <Cale> This function doesn't compute the lcm though.
08:36:13 <greeny> hello im a haskell newbie. can perhaps somebody explain me why i get a parse error. i try to mirroring fuctions
08:36:44 <Cale> greeny: Because you're pattern matching on a function application.
08:37:03 <Cale> greeny: You can only pattern match on applications of data constructors (which start with an uppercase letter)
08:37:25 <Cale> Perhaps you meant to write  mirrorx f x = f x * (-1) ?
08:37:26 <byorgey> greeny: just remove the parentheses from around (f x)
08:37:57 <Cale> and then  mirrory f x = f (-x)
08:38:21 <Cale> Note that mirrorx f x = (mirrorx f) x
08:39:20 <Cale> In general, function application associates to the left, so when you write  f x y z  it means  ((f x) y) z
08:39:32 <greeny> removing the paranthesis for (f x) and adding them to -1 solved it so far
08:41:46 <greeny> thats an amazing language, but i haven't the perfect feeling for it yet
08:41:53 <greeny> thanks for your help
08:43:03 <matthiasgoergens> The need for the parens around -1 is a bit of a kludge, admittedly.
08:45:08 <greeny> yeah but yesterday our professor mentioded it already, so i should had recognized it^^
08:47:51 * cmccann thinks pattern matching on invertible functions would be a nice feature. like n+k patterns done less stupid.
08:48:05 <simpson> `/bu32
08:48:08 <simpson> Ugh.
08:48:18 <elliott> cmccann: prisms!!!!
08:50:24 <cmccann> elliott: prisms are pattern cases in roughly the same way lenses are record fields yes
08:50:42 <cmccann> pity you can't express exhaustive patterns with prisms though :[
08:50:54 <elliott> cmccann: one day I will get that toy language with structural records and integrated lensy-prismy everything going.
08:51:54 <cmccann> elliott: if you have a notion of a group of lenses/prisms being exhaustive you could probably dispense with constructors entirely!!!1 that would be so cool.
08:52:31 <elliott> cmccann: trade secrets!!
08:52:54 <elliott> you sort of need some primitive notion of a newtype constructor for recursive types. but the rest is subsumed by the structural machinery
08:53:29 <cmccann> yeah
08:55:29 <cmccann> though what I really want is a straightforward and pleasant way to express a partially-constructed value using lenses
08:55:38 <cmccann> filling things in incrementally without having undefined involved
08:55:52 <cmccann> or having the incomplete value be the same type as a usable one
08:55:59 <elliott> well, it's quite easy if you hvae a notion of record subtyping (even if only through polymorphism).
08:56:03 <elliott> *have
08:56:21 <cmccann> see also: straightforward and pleasant way
08:56:47 <cmccann> subtyping is unstraightforward enough in languages that claim to support it
08:57:06 <elliott> well, i have ideas :P
08:57:30 <cmccann> you should turn them into implementations.
08:57:40 <cmccann> those are like ideas, only better.
08:58:22 <elliott> only more work.
08:58:29 <elliott> and more prone to disproving the viability of the ideas.
08:58:49 <cmccann> pf. don't be a quitter.
09:03:44 <ab9rf> partially applied ideas
09:05:11 <Dextr> hi
09:06:10 <Dextr> is there a way in haskell to have the applications code change, without requiring a restart of the process? (so that things like sockets are preserved)
09:08:40 <geekosaur> not geerally, no. that kind of thing works best with runtime support which is provided in languages liek common lisp and erlang/BEAM but not so common elsewhere
09:08:57 <geekosaur> *generally
09:09:11 <geekosaur> you might be able to do it to some extent via the plugins package
09:09:29 <Dextr> yes, but it doesn't have to be as extreme as in dynamic languages.. something like lazy classloading on the jvm would work too
09:10:10 <isBEKaml> from haskell-cafe archives about hotswapping: http://www.haskell.org/pipermail/haskell-cafe/2010-July/080459.html
09:10:22 <cmccann> it seems to me GHCi does quite a bit of dynamic code loading among other things.
09:10:44 <MichaelA_> Hey, can any of you guys by any chance help me with a sanity check? I'm looking at the code for filterM and it looks likes this:
09:10:47 <MichaelA_> filterM          :: (Monad m) => (a -> m Bool) -> [a] -> m [a] filterM _ []     =  return [] filterM p (x:xs) =  do    flg <- p x    ys  <- filterM p xs    return (if flg then x:ys else ys)
09:11:02 <MichaelA_> Ah, that came out un formatted.
09:11:12 <ab9rf> MichaelA_: use hpaste.org
09:11:12 <geekosaur> yes, don't paste into the channel
09:11:15 <geekosaur> @hpaste
09:11:15 <lambdabot> Haskell pastebin: http://hpaste.org/
09:11:20 <cmccann> what about filterM?
09:11:25 <cmccann> most of us know how it works anyway.
09:11:30 <byorgey> MichaelA_: what's your question?  many people here are familiar with the definition of filterM anyway.
09:11:51 <MichaelA_> Well the question is - what's the do notation translate to, in terms of bind
09:12:20 <ab9rf> Dextr: hotswapping requires either a fairly complicated scaffolding to be general, or a bespoke solution to the particular application.
09:12:25 <byorgey> @undo do { flg <- p x; ys  <- filterM p xs; return (if flg then x:ys else ys) }
09:12:25 <lambdabot> p x >>= \ flg -> filterM p xs >>= \ ys -> return (if flg then x : ys else ys)
09:12:30 <byorgey> MichaelA_: ^^^
09:12:56 <MichaelA_> Thanks for that, it's what I though it's going to look like
09:13:08 <byorgey> congrats =)
09:13:22 <Dextr> ab9rf so what's your recommendation?
09:13:44 <ab9rf> Dextr: you can either write a general scaffold, or develop a solution that works for your particular application :)
09:13:58 <ab9rf> Dextr: as far as i know nobody has written a generalized scaffolding for that yet
09:14:12 <MichaelA_> A follow up question - the semantics for bind on lists, are they anything at all like, say, C# SelectMany? It maps every element of a list into a list of it's own and then flattens the list of lists and that kinda seems like what bind on lists does. Am I missing anything?
09:14:52 <cmccann> they are exactly SelectMany
09:15:08 <cmccann> or rather, SelectMany is bind for the list monad, in the sense of being inspired by it
09:15:17 <ab9rf> heh
09:15:54 <MichaelA_> Right, thank you for that. It seems my assumptions are correct which makes it all the more preplexing why my code doesn't work. Well, thanks anyway =)
09:16:32 <cmccann> bind for [] also exists as concatMap, if that helps.
09:17:12 <Dextr> isBEKaml - the solution in that link would end up doubling the ram usage for every reload, right?
09:19:51 <ab9rf> Dextr: why would it do that?
09:20:12 <Dextr> isn't it forking?
09:20:52 <ab9rf> Dextr: no, it's just execing
09:21:02 <ab9rf> you can exec without forking
09:21:07 <geekosaur> exec() = replace process
09:21:22 <ab9rf> the new process inherits the previous process's open files
09:21:32 <ab9rf> er, it's the same process
09:22:09 <ab9rf> exec does not close open files
09:22:15 <ab9rf> (except for those marked close on exec)
09:22:26 <geekosaur> same process, new memory image
09:24:07 <ab9rf> see the execve(2) man page for more details on what happens when you exec a new image
09:24:24 <ab9rf> windows is, of course, different, i'm not sure how you'd do this on windows
09:24:41 <ab9rf> you could also unmap and remap a dynamic library
09:24:56 <ab9rf> that's more OS-specific, though
09:25:05 <Dextr> i'm familiar with exec, but won't creating a new process copy over all of the memory of the original process into the new one, thus doubling it?
09:25:31 <ab9rf> Dextr: (a) no, beause of copy-on-write semantics of fork (b) you're not creating a new process
09:25:39 <Dextr> oh, ok
09:26:14 <ab9rf> Dextr: you don't fork in this case.  you serialize your state and exec the new codebase, which then deserializes the state.
09:27:01 <ab9rf> there are any number of ways to preserve state across an exec
09:28:40 <ab9rf> the other option is to have a persistent wrapper executable that holds the state, and put all the replacable code into a dynamic library that the wrapper exec will unmap and remap as needed
09:30:01 <Dextr> i would really like to avoid dynamic libraries.. since calls across them don't get optimized by the compiler :x
09:31:01 <ab9rf> Dextr: that's not really an issue in this case.  the DLL contains the entire application except for the scaffold that handles the restart mechanism
09:31:29 <ab9rf> the only time you'll call across that boundary is during a restart
09:32:04 <Dextr> won't accessing the global state call across the boundary?
09:32:58 <ab9rf> Dextr: you can choose to only use the wrapper's state during a restart marshal
09:33:20 <Dextr> oh, ok
09:33:31 <ab9rf> so a restart sequence becomes "marshal state to wrapper, request wrapper to restart, unmarshal state from wrapper"
09:35:03 <ab9rf> Dextr: if the state is an opaque hunk to the wrapper, this means you can change the definition of the state during an upgrade as long as the new application can convert the old serialized state into the new state
09:35:33 <ab9rf> just imbed a version number into your serialization and have different deserializer based on that version number
09:36:53 <Dextr> true.. but you have to come up with some sane serialization format before hand for that of course
09:36:59 <ab9rf> yes
09:38:26 <davidfstr> Newbie here. Trying to write a program that reads lines from stdin to a [String]. Found getChar. Stumbling on a lack of loop structures and/or a mutable character buffer to build up lines being read.
09:38:50 <merijn> davidfstr: Might wanna use getLine?
09:39:27 <merijn> davidfstr: Or was that more of a "how would I implement this loop?" question
09:40:42 <davidfstr> merijn: True that function has a reasonable definition to study. Recursive. (I'm trying to learn how to do low level I/O manually as a learning exercise.)
09:42:08 <merijn> davidfstr: Might wanna try rewriting simple existing IO functions from do-notation to >>= and >> to make sure you understand the scoping/typing of everything
09:44:53 <hpaste> merijn pasted ‚ÄúSimple getLine‚Äù at http://hpaste.org/86684
09:45:11 <merijn> davidfstr: The simplest implementation of loops like that (that I can think of) would be something like that
09:51:23 <hpaste> davidfstr pasted ‚ÄúLower-order getLine‚Äù at http://hpaste.org/86686
09:51:48 <davidfstr> merijn: Heh. Already throwing the higher-order fmap at me. :-) I've pasted a lower-order version (which is equivalent to Prelude).
09:52:12 <djahandarie> What's the keyword I'm looking for if I have a 2d bit array, where 1s are blocking and 0s are open, and I want to count the number of "regions" in the grid?
09:52:53 <Botje> do floodfills until no more 0s remain
09:54:07 <danr> djahandarie: dfs/bfs
09:55:52 <djahandarie> Oh wait, this is called connected-component labeling isn't it.
09:57:25 <nadir> Hey, I'm having some trouble with what looks to be formatting in this code:
09:57:27 <nadir> http://hpaste.org/86687
09:57:46 <nadir> The second where clause is what is causing the problem.
09:57:53 <nadir> I have tried using let, but the same thing happens.
09:58:01 <nadir> Any ideas what this could be?
09:59:13 <Clint> nadir: are there any tabs in there?
09:59:39 * geekosaur guesses one is indented with space, other with space+tab
09:59:47 <parcs> i wonder what meaning could be attributed to bangs on type parameters, e.g. Maybe !Int
09:59:57 <nadir> Clint: It looks like there was one. I never knew there was a distinction.
09:59:59 <aCube> geekosaur: one is with tab, other with tab + space
10:00:05 <parcs> er, type arguments
10:00:09 <nadir> I thought editors just used 4 spaces for tabs.
10:00:24 <paroneayea> hey joeyh_!
10:00:32 <paroneayea> $ cabal install git-annex --bindir=$HOME/bin
10:00:33 <merijn> nadir: Which editor do you use?
10:00:36 <paroneayea> should install latest git-annex right?
10:00:45 <paroneayea> it seems to install 3.20121112 which is confusing.
10:00:52 <Clint> paroneayea: did you cabal update?
10:00:55 <nadir> Sublime Text 2, and getting rid of that tab did fix the problem.
10:01:22 <merijn> nadir: Usually there's a setting to insert spaces instead of tabs, but dunno what that setting it in Sublime
10:01:52 <paroneayea> Clint: I did not!
10:01:52 <paroneayea> aha.
10:02:06 <paroneayea> sorry, I am a cabal newbie :)
10:02:34 <davidfstr> Consider the getLine function I wrote (http://hpaste.org/86686). If this was a pure function that was splitting lines in a list, it might create a long (O(n)) thunk chain due to the lazy evaluation nature of Haskell. I suspect this cannot happen in a monadic context, as I suspect monads are evaluated strictly. Is this correct?
10:03:42 <elliott> "monads are evaluated strictly" isn't really a statement that makes sense... it is true that execution of IO actions is strict
10:03:51 <wole> @hoogle (+#)
10:03:51 <lambdabot> No results found
10:03:53 <elliott> but that's a fact about IO rather than monads in general, and execution is separate from evaluation
10:04:22 <wole> @hoogle +#
10:04:22 <lambdabot> No results found
10:04:32 <dmj> what's the quickest way to partition a list [a] -> [(a,a)] where first is evens and second is odds?
10:04:43 <dcoutts_> @hoogle partition
10:04:43 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
10:04:43 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
10:04:43 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
10:04:56 <dcoutts_> :t partition even
10:04:57 <lambdabot> Integral a => [a] -> ([a], [a])
10:05:05 <dcoutts_> davidfstr: neither of those statements are quite right,
10:05:16 <adimit> davidfstr: as an example, there's a strict variant of the State monad, and a Lazy one. So whether the Monad "is" strict or lazy depends on the definitions! (most importantly, it depends on the definition of bind (>>=)
10:05:31 <dmj> dcoutts_: Thank you
10:06:07 <dcoutts_> davidfstr: a lazy list function (like splitting) can be written so that it runs in constant space, it doesn't need to make a chain of thunks in memory
10:07:08 <davidfstr> dcoutts_: Using seq() or its cousins, you mean?
10:08:00 <dcoutts_> davidfstr: I can recommend learning more about how lazy evaluation really works. Understanding haskell evaluation really does help with writing better programs, ie faster, avoiding memory leaks, getting the advantages of lazyness
10:08:53 <dcoutts_> davidfstr: no, that's just about fully evaluating it. Consider something simple like map f xs. Assume for sake of argument that xs is already fully evaluated, so the only issue is what map f is doing,
10:09:32 <ab9rf> i question the merits of assuming xs is fully evaluated, since that's almost never the case :)
10:09:36 <dcoutts_> davidfstr: if I have let ys = map f xs in ... then at this stage before I touch ys, then I have exactly 1 thunk, not a linear chain.
10:10:03 <dcoutts_> ab9rf: pedagogy
10:10:12 <ab9rf> > map (take 10) partition even [0..]
10:10:15 <lambdabot>   The function `GHC.Base.map' is applied to four arguments,
10:10:15 <lambdabot>  but its type `(a...
10:10:19 <ab9rf> oops
10:10:22 <ab9rf> > map (take 10) $ partition even [0..]
10:10:24 <lambdabot>   Couldn't match expected type `[[a0]]'
10:10:25 <lambdabot>              with actual type `([a1],...
10:10:33 <ab9rf> oh, feh, tuple
10:12:16 <dcoutts_> davidfstr: now if I do something with ys, e.g. summing it, at each stage I've got at most two thunks, one for the current element and one for the remaining tail of the list
10:12:58 <dcoutts_> in particular, thinking about the spine of that list ys, if I walk down it (whether or not I look at the element), there's only ever one thunk for the tail at once
10:13:24 <dcoutts_> each time I force the tail, that allocates a new thunk for the new tail
10:13:28 <ab9rf> if you don't look at the element, the cons cell only contains a head thunk, not the entire head
10:13:30 <dcoutts_> so it really is like an iterator
10:13:56 <ab9rf> ghc will drop the head thunk if you don't need it anymore, so a spine walk may end up being constant space
10:15:17 <dcoutts_> @src map
10:15:17 <lambdabot> map _ []     = []
10:15:17 <lambdabot> map f (x:xs) = f x : map f xs
10:15:55 <dcoutts_> davidfstr: ^^ we can see this from the definition of map, and knowing how lazy eval works
10:15:58 <ab9rf> > map (const 5) (repeat undefined)
10:15:59 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
10:16:36 <ab9rf> > map (const 5) (repeat error) -- error is never evaluated
10:16:37 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
10:16:38 <dmj> is there a function like words, instead of splitting on whitespace will split on a comma?
10:16:45 <ab9rf> dmj: yes
10:17:09 <dmj> ab9rf: is it in data.list?
10:17:11 <mauke> no
10:17:21 <dmj> in the std. prelude?
10:17:23 <mauke> Data.List.Split
10:17:34 <ab9rf> yeah, that's the one
10:17:38 <ab9rf> i had to look it up
10:17:48 <ab9rf> Data.List.Split offers splitters that will split on anything
10:18:14 <mauke> I split in your face
10:18:36 <dcoutts_> davidfstr: if we look at the second line, to see it operationally it can help to rewrite it as: let head_thunk = f x; tail_thunk = map f xs in head_thunk : tail_thunk
10:18:46 <ab9rf> :t splitOn
10:18:48 <lambdabot> Eq a => [a] -> [a] -> [[a]]
10:18:59 <dmj> I don't want ppl to have to download this entire pkg, won't there be overhead? I might just yank the source code for splitOn and that's it
10:19:02 <mauke> > splitOn "," "hello"
10:19:03 <lambdabot>   ["hello"]
10:19:07 <mauke> dmj: wat
10:19:09 <ab9rf> > splitOn "," "We,will,rock,you"
10:19:10 <lambdabot>   ["We","will","rock","you"]
10:19:20 <dcoutts_> dmj: split is going to be in the next HP, it's ok to use it
10:19:31 <ab9rf> dmj: you should just use the package, it's fairly involved.
10:19:38 <tsinnema> http://homepages.cwi.nl/~ralf/HList/ is apparently gone. can anyone recommend good readings on hlists?
10:19:38 <mauke> dmj: I don't want to download multiple copies of the same code just to use your program
10:19:46 <mauke> I already have Data.List.Split
10:19:47 <elliott> dmj: overhead like what?
10:19:55 <mauke> @where hlist
10:19:56 <lambdabot> http://hackage.haskell.org/package/HList
10:20:03 <ab9rf> cabal install split
10:20:05 <ab9rf> there, done
10:20:56 <dmj> elliott: when someone does a cabal install on project xyz, won't they have to install all dependendencies? If I'm just using one function from a package, won't this cause unneeded bloat?
10:21:07 <dmj> for the user
10:21:37 <ab9rf> dmj: splitOn is defined interms of several other functions from the package
10:21:49 <dcoutts_> dmj: cabal can download and install dependencies automatically, so it's not a big issue for users
10:21:53 <ab9rf> splitOn   = split . dropDelims . onSublist
10:21:59 <elliott> dmj: chances are most people have split. it's a very common package
10:22:03 <mauke> dmj: again, I already have split
10:22:06 <elliott> and dcoutts_ says it will be in the next haskell platform
10:22:12 <ab9rf> most people will have it
10:22:14 <elliott> so then, everyone (who does not compile their own ghc or whatever) will have it
10:22:21 <ab9rf> it's safe, it's widely used
10:22:55 <elliott> also, consider the effort it takes for you to extract the definition and all the definitions it depends on, and the pain your users will feel when a bug gets fixed in split but your program is still broken, thanks to copying
10:22:58 <ab9rf> 135 other packages use it
10:22:59 <elliott> also, software licensing issues...
10:23:08 <Clint> isn't it in the current HP?
10:23:17 <ab9rf> http://packdeps.haskellers.com/reverse/split
10:23:42 <dmj> alright awesome, will this code break on the next release of HP? Or will the next release somehow seamlessly integrate Data.List.Split
10:24:00 <ab9rf> notably yesod uses it
10:24:41 <tsinnema> ok regarding hlist i found this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.9906 -- looks useful
10:24:45 <ab9rf> dmj: it'll just be part of the standard distribution, is all
10:24:45 <hpaste> davidfstr pasted ‚ÄúlengthOfFirstLine‚Äù at http://hpaste.org/86693
10:25:27 <ab9rf> davidfstr: question?
10:25:29 <davidfstr> Let's consider the concrete case of this function (http://hpaste.org/86693). Isn't that going to at least use O(n) stack space?
10:25:37 <ab9rf> davidfstr: no
10:26:25 <dmj> ab9rf: k thanks
10:26:27 <davidfstr> ab9rf: Why not? Is there a tail recursive optimization in play here?
10:26:40 <ab9rf> davidfstr: haskell evaluates top-down, not bottom-up
10:27:16 <luite> davidfstr: yeah that will use lots of stack if you have long lines
10:27:18 <dcoutts_> davidfstr: yes, that will use linear stack.
10:27:30 <mauke> 'otherwise' is wrong there
10:27:48 <ab9rf> i was wondering why you don't use a pattern match at the function definition
10:27:53 <dcoutts_> it's not wrong, jjust not idiomatic
10:28:13 <engla> it is wrong
10:28:16 <ab9rf> '\n':_ = 0; _:xs = 1 + lengthOfFirstLine xs
10:28:17 <mauke> it's misleading
10:28:48 <luite> ab9rf: that doesn't solve the stack issue though
10:28:52 <ab9rf> luite: no
10:29:05 <dcoutts_> davidfstr: you're right about tail recursion being the issue here. It is not tail recursive
10:29:15 <ab9rf> yeah, the addition is after the tail call
10:29:29 <ab9rf> at each eval step you build another deferred addition
10:29:30 <mauke> nothing is after a tail call
10:29:33 <dcoutts_> davidfstr: but don't get the idea that everything has to be tail recursive. Lazyness quite often saves us from having to make things tail recursive to get linear space usage.
10:29:41 <ab9rf> sorrym after the recusive call
10:30:03 <dcoutts_> davidfstr: like I was going on about map, that's not tail recursive but also runs in constant space
10:30:20 <ab9rf> integer + is strict, isn't it?
10:30:25 <luite> yes
10:30:54 <luite> davidfstr: you can look at the implementation of length to see how it can be done. the problem is that you want the accumulator to be forced every step
10:31:05 <luite> davidfstr: (a simpler way is to use seq)
10:31:58 <davidfstr> luite: OK. I'll try to rewrite in terms of seq. I already know how to rewrite in terms of a helper function & an accumulator, but that form is hard to read.
10:32:17 <dcoutts_> davidfstr: the crucial issue is if the recusive call needs to be done to give an initial answer. If you look at your length function, it's clear that to give an answer we need to make the recursive call. But if you look at map, you can see that it can return (head_thunk : tail_thunk) without evaluating the recursive call to map.
10:32:19 <luite> davidfstr: if you don't seq it, you'll build up a huge thunk on the heap, so be careful :)
10:33:20 <dmj> if I want to go from [String] -> [Int], I want to do something like fmap read xs, instead of map (\s -> read :: Int) xs. Is this possible?
10:33:32 <dmj> (\s -> read s :: Int)
10:34:07 <luite> dmj: yeah that's possible, but fmap on lists is the same as map, why do you want fmap?
10:34:46 <dmj> luite, makes no difference I guess. My issue is with "read x :: Int", I don't want to write out a lambda, point free would be nicer
10:34:55 <dmj> luite: if possible
10:35:18 <luite> dmj: oh you can use read :: (String -> Int) if you want
10:35:30 <luite> or just add a type signature [Int] on the result
10:40:15 <kutta> Hi! Anyone knows how to get a Hackage account these days? On the page there it is said that one should email Ross Paterson, which I did about two weeks ago but I haven't received an answer.
10:40:41 <dmj> luite: thanks
10:40:46 <simpson> kutta: Maybe he's been busy?
10:41:41 <kutta> So the general solution is to pester him?
10:42:00 <simpson> Well, be nice about it. My account took a week or so.
10:42:25 <kutta> Well, thanks.
10:42:38 <dmj> kutta: he responded to me in one day. It was over the weekend when he received my email.
10:42:48 <dmj> kutta: try weekends?
10:42:59 <luite> the screening process sometimes takes a few weeks if there are concerns about your background ;)
10:43:12 <kutta> eh.
10:43:36 <kutta> This current method of registration doesn't seem to scale well anyway
10:43:44 <davidfstr> luite: Do you have an example of using seq to simplify the kind of recursion in the length() function or in the lengthOfFirstLine() function I wrote?
10:43:46 <c_wraith> It's not intended to be permanent.
10:43:56 <c_wraith> Hackage 2 will work differently, whenever it's released.
10:44:28 <elliott> my account took 5 minutes :P
10:44:37 <luite> davidfstr: length xs = go xs 0 where go (x:xs) a = a `seq` go xs (a+1); go [] a = a
10:46:44 <davidfstr> luite: That makes sense. Do you have a version that uses seq alone, without an accumulator?
10:47:00 <luite> davidfstr: that doesn't work
10:48:02 <davidfstr> luite: Aww. I was hoping to avoid accumulators. :-) Definitely not easy to think about IMHO.
10:48:05 <luite> davidfstr: the non-tailrecursive version you had can't be fixed by adding seq somewhere
10:48:30 <luite> davidfstr: usually you don't need to write code like this very often
10:48:33 <elliott> length = foldr' (+) 0
10:48:39 <elliott> er
10:48:45 <elliott> length = foldr' (\_ l -> l+1) 0
10:48:50 <elliott> ...
10:48:55 <elliott> I meant foldl'. and the arguments should be swapped.
10:49:04 <elliott> anyway my point is you can do what luite did without an explicit accumulator.
10:50:54 <luite> yeah foldl' just hides the accumulator and the seq :)
10:51:29 <elliott> you say hide, I say abstract :)
10:53:15 <jutaro> nangijala
10:54:40 <davidfstr> Well, foldl will work on full lists, but not with list fragments. - So you generally recommend putting the code that uses seq, accumulators, and relies on tail-call optimization in higher order library functions?
10:55:04 <elliott> what do you mean by list fragments here?
10:55:22 <elliott> sometimes the best way to write a loop is just to write the tail recursive strict accumulator stuff directly, if it's complex
10:55:23 <davidfstr> lengthOfFirstLine eats a list up until the first "\n".
10:55:30 <elliott> ah
10:55:39 <elliott> lengthOfFirstLine = length . takeWhile (/= '\n')
10:55:48 <elliott> laziness gives composability :)
11:06:17 <hpaste> keep_learning pasted ‚ÄúMonad transformer learning‚Äù at http://hpaste.org/86694
11:06:21 <Targen> snoyberg: Is there any estimate, however rough, imprecise and unreliable, for the release date of Yesod 1.2?
11:06:31 <keep_learning> Hello all
11:06:52 <snoyberg> Targen: we're cleaning up a few details on persistent, and then we'll release, assuming all goes according to plan, within the next week
11:07:07 <Targen> Wonderful!  I‚Äôm looking forward to it.
11:07:26 <keep_learning> I am trying to learn monad transformer. I am doing a computation which can fail so I am returning Nothing
11:07:28 <Eduard_Munteanu> keep_learning: hi
11:07:37 <keep_learning> but getting error.
11:07:43 <keep_learning> Eduard_Munteanu: Hi
11:08:57 <Eduard_Munteanu> keep_learning: return won't do there
11:09:28 <Eduard_Munteanu> @unmtl StateT S (MaybeT IO) Int
11:09:28 <lambdabot> S -> IO (Maybe (Int, S))
11:10:04 <Eduard_Munteanu> :t lift
11:10:05 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:10:52 <Eduard_Munteanu> @src MaybeT
11:10:52 <lambdabot> Source not found. Do you think like you type?
11:10:54 <Eduard_Munteanu> Grr.
11:10:58 <Eduard_Munteanu> @hoogle MaybeT
11:10:58 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:10:58 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
11:10:58 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
11:11:17 <krzysz00> @help
11:11:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:11:23 <krzysz00> @help list
11:11:23 <lambdabot> list [module|command]
11:11:24 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
11:11:32 * Eduard_Munteanu brb
11:15:33 <davidfstr> elliott: Where are these foldl' and foldr' functions you speak of? They do not appear to be in Prelude.
11:15:39 <keep_learning> @unmtl StateT Int IO Int
11:15:39 <lambdabot> Int -> IO (Int, Int)
11:16:10 <elliott> foldr' was a typo
11:16:11 <elliott> @hoogle foldl'
11:16:12 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
11:16:12 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
11:16:12 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
11:16:17 <elliott> foldl' is in Data.List
11:16:28 <keep_learning> @unmtl StateT S ( MaybeT IO ) Int
11:16:28 <lambdabot> S -> IO (Maybe (Int, S))
11:18:52 <keep_learning> @unmtl ReaderT (Int,Int) (StateT Int (MaybeT (Rand StdGen))) a
11:18:52 <lambdabot> Int -> Int -> Int -> StdGen -> (Maybe (a, Int), StdGen)
11:20:28 <davidfstr> elliott: Wooho. Finally got your length variant to work: length3 xs = foldl' (\ acc _ -> acc + 1) 0 xs
11:25:18 <elliott> davidfstr: :)
11:39:39 <dmj> let partitionIndices xs = partition (\x -> (even . fromJust) $ elemIndex x xs) xs
11:39:59 <dmj> is there a better way to parition a list into its even an odd indices? maybe some package has already done this?
11:40:32 <dmj> don't say Data.List.Split
11:42:37 <byorgey> (map snd *** map snd) . partition fst . zip (cycle [True,False])
11:42:37 <Cale> > partition (fst . even) (zip [0..] "hello, there")
11:42:37 <lambdabot>   Couldn't match expected type `(GHC.Types.Bool, b0)'
11:42:37 <lambdabot>              with actua...
11:42:38 <Cale> err
11:42:41 <Cale> > partition (even . fst) (zip [0..] "hello, there")
11:42:43 <lambdabot>   ([(0,'h'),(2,'l'),(4,'o'),(6,' '),(8,'h'),(10,'r')],[(1,'e'),(3,'l'),(5,','...
11:42:48 <Rotaerk> do you guys tend to name various permutations of parameter order for multi-parameter functions
11:42:48 <Rotaerk> or do you just use one name, and then (??) or flip
11:43:02 * elliott suspects split can do that :p
11:43:02 <Cale> Rotaerk: one name and lambda
11:43:18 <byorgey> Rotaerk: I have never seen anyone define multiple permutations
11:43:27 <byorgey> Rotaerk: usually there is one "best" order
11:43:36 <byorgey> for other things, there is flip or (??) or a lambda
11:43:51 <Cale> dmj: If you're operating on indices, zip [0..] is a nice idiom.
11:44:16 <byorgey> > (map snd *** map snd) . partition fst . zip (cycle [True,False]) $ "hello, there"
11:44:17 <lambdabot>   ("hlo hr","el,tee")
11:44:43 <byorgey> > (both (map snd)) . partition fst . zip (cycle [True,False]) $ "hello, there"
11:44:45 <lambdabot>   [('h','e'),('h','l'),('h',','),('h','t'),('h','e'),('h','e'),('l','e'),('l'...
11:44:51 <elliott> byorgey: you've never seen mapM and forM?
11:44:53 <byorgey> wat
11:45:03 <Cale> :t both
11:45:05 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
11:45:05 <byorgey> elliott: oh! good call
11:45:14 <Rotaerk> hmm, well I was considering making, a local extension to, say, Data.Map, where i define deleteFrom = flip delete; insertKeyInto m k a = insert k a m
11:45:15 <Rotaerk> etc
11:45:34 <Rotaerk> just to simplify the code in which they're actually used
11:45:51 <elliott> Rotaerk: consider using delete infix, perhaps?
11:45:52 <Rotaerk> but that gets complicated when you have 3+ parameter functions
11:45:55 <byorgey> Rotaerk: if you tend to use a function flipped a lot, making a name for it locally is perfectly fine
11:46:02 <Cale> Rotaerk: Well, use your best judgement -- if it makes the code nicer to read, go for it!
11:46:43 <Rotaerk> k, thanks; just wanted to see what everyone else tended to do, first
11:49:33 <greeny> i dont get it write a curry funtion; transforming ((a->b)->c) to a->b->c sry for this question^^
11:49:49 <elliott> err, I seriously doubt anyone is actually asking you to do what you said :)
11:49:52 <elliott> (since it is impossible)
11:50:38 <elliott> actually, I guess it isn't impossible.
11:50:42 <elliott> but it's definitely not currying
11:51:02 <greeny> ah i meant ((a,b)->c) -> (a -> b -> c)
11:51:19 <ab9rf> :t uncurry
11:51:20 <elliott> right. so you get three parameters.
11:51:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:51:25 <elliott> the first parameter is a function (a, b) -> c
11:51:27 <ab9rf> :t curry
11:51:29 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:51:29 <elliott> the second is a value of type a
11:51:37 <elliott> the third is a value of type b, and you have to produce a c
11:51:46 <elliott> yourcurry f a b = ...?
11:52:15 <ab9rf> call it vindaloo :)
11:53:00 <monochrom> you're looking at: vindaloo :: ((a,b) -> c) -> a -> b -> c. the type suggests how to code.
11:53:38 <monochrom> vindaloo f x y = ?   bearing in mine f::(a,b)->c, x::a, y::b
11:53:50 <Rotaerk> hmm the naming gets kind of a pain when I've got to distinguish things like these two:  ((Ord k, Foldable f) => Map k a -> f k -> (k -> a) -> Map k a) and ((Ord k, Foldable f) => Map k a -> (k -> a) -> f k -> Map k a)
11:54:10 <ab9rf> heh
11:54:11 <Rotaerk> I'm thinking the former would be "insertKeysInto" and the latter "insertKeysUsingInto"
11:54:32 <byorgey> Rotaerk: this is the point at which it stops being worth it.
11:54:36 <Rotaerk> heh
11:54:44 <byorgey> it will take you longer to remember the right function name than to just write a lambda.
11:55:06 <Rotaerk> yea i think I agree...
11:55:29 <cmccann> also, the lambda will probably be shorter and easier to understand
11:55:39 <greeny> i dont get it... :/
11:55:53 <ab9rf> call one of them samantha and the other gertruide
11:55:57 <ab9rf> er gertrude
11:56:13 <ab9rf> hm, actually i like samantha and serena better
11:56:28 <ab9rf> but i'm old :)
11:56:29 <monochrom> I give you these ingredients. f::(a,b)->c, x::a, y::b. do you understand this? now use these ingredients to make something ?::c, can you do it?
11:56:50 <elliott> greeny: do you know what tuples are?
11:56:56 <elliott> like, have you used (a,b) at all before this question?
11:56:58 <greeny> jep
11:57:01 <elliott> ok.
11:57:04 <elliott> so you need to produce a value of type "c".
11:57:05 * cmccann gives monochrom an (undefined :: c) 
11:57:11 <elliott> the only way you can do that is by using f::(a,b)->c
11:57:20 <elliott> since you don't know what c is. all you have is a function that will produce a c.
11:57:32 <ab9rf> c is a type, not a value
11:58:19 <Rotaerk> though it makes me wonder if there could be some kind of (non-crappy, unambigous) function-application syntax *which supports partial application* where you define the function something like:  insert (into :: Map k a) (using :: k -> a) (keys :: f k)
11:58:35 <Rotaerk> and then you can somehow apply the function with the parameters in any order
11:59:06 <ab9rf> Rotaerk: i've seen something along those lines
11:59:08 <monochrom> write a function that takes a record. then you can write the record with fields in any order.
11:59:17 <Rotaerk> yea but you can't partially apply them
11:59:24 <cmccann> Rotaerk: probably, be specifying that syntax in a way that's useful and unambiguous would probably be a pain
11:59:30 <ab9rf> you write combinators that modify the record
12:00:03 <cmccann> the problem with using a record is that it doesn't distinguish partial application by type.
12:00:24 <ab9rf> i think Data.List.Split does something like this
12:00:41 <cmccann> you could probably be something unspeakably horrible using the same trickery as with "variadic" functions.
12:00:46 <cmccann> s/be/do
12:00:51 <elliott> cmccann: i'm mumbling something about my toy language solving that problem too but it is too quiet for you to hear.
12:00:53 <monochrom> yikes haha
12:00:55 <ab9rf> look at its Strategy type and the combinator sthat construct a Strategy
12:01:21 <monochrom> anyway, from f::(a,b)->c, x::a, y::b, deduce f(x,y) :: c
12:01:24 <cmccann> elliott: I'm mumbling something about how you need to make your toy language a thing that really exists, but it is too loud for you to not hear
12:01:38 <elliott> cmccann: how about you take a break from not doing shachaf's work and do it for me.
12:02:00 <greeny> i have this form :  curry :: ((a,b) -> c) -> (a -> b -> c)
12:02:02 <cmccann> elliott: yes but then who will not do shachaf's work? it ain't gonna not do itself.
12:02:16 <elliott> cmccann: how about I don't it?
12:02:23 <cmccann> hm that might work
12:02:34 <monochrom> greeny, did you see anything I said?
12:02:46 <greeny> yeah but i dont understand it, im sry
12:02:52 <cmccann> do you actually have details worked out for this toy language? or is it just in the jumble of ideas stage.
12:03:10 <monochrom> ok, but I asked "do you understand this?" and you never answered
12:03:14 <elliott> cmccann: I read a buncha papers for research, does that count??
12:03:27 <elliott> cmccann: I mostly have the general outline of how it will work, I think
12:03:32 <ab9rf> elliott: did you fill out reader response forms afterward?
12:03:42 <elliott> the (sub)typing of the actual lenses stuff itself I haven't quite worked out yet.
12:03:57 <elliott> (in particular I want things like "the notion of a getter and a function are the same thing")
12:04:01 <greeny> monochrom: you are right, i tried to read your posts and to implement it first
12:04:16 <cmccann> elliott: I'd actually be interested to see whatever you have, if it's in any shape to be read by not-elliott people.
12:04:16 <byorgey> greeny: is this for a class, or are you just learning Haskell on your own?
12:04:39 <elliott> cmccann: oh I don't have any *code*.
12:05:05 <greeny> studies on university
12:05:08 <cmccann> I meant like, random notes and whatnot.
12:05:12 <Rotaerk> I think it could work something like this:  (insert (into :: Map k a) (using :: k -> a) (keys :: f k)) represents not a function, but a name for a group of functions, and choosing which function within that group is determined by how it's applied.
12:05:28 <elliott> cmccann: well I mostly store those in my head because that way I can avoid committing to actually working on this stuff.
12:05:31 <byorgey> greeny: is there a professor or TA you can ask for help?  We are happy to help too, but sometimes talking to a live person can be most helpful when you are confused about the fundamentals
12:05:35 <cmccann> I tend to accumulate disorganized text files full of bullet-point lists when working out ideas initially.
12:05:37 <Rotaerk> you could partially apply it something like:  (insert using (const a) into _ keys _), which has type Map k a -> f k -> Map k a
12:05:38 <elliott> cmccann: I also store them in /query shachaf
12:05:41 <coppro> win 52
12:05:42 <byorgey> greeny: you may also be interested in reading an online tutorial like Learn You a Haskell
12:05:45 <byorgey> @where lyah
12:05:45 <lambdabot> http://www.learnyouahaskell.com/
12:05:49 <greeny> i think this would be the best
12:06:19 <greeny> buyed already the book "learn you haskell for a great good"
12:06:35 <byorgey> greeny: cool
12:06:46 <cmccann> elliott: maybe I should start storing my own toy language ideas in /query elliott
12:06:59 <byorgey> greeny: that book should help
12:07:14 <Rotaerk> hmm i wonder if this could actually be implemented in haskell somehow, without extensions
12:07:20 <Rotaerk> maybe not with the syntax sugar I described above
12:07:26 <hpaste> davidfstr pasted ‚ÄúlengthOfFirstLine (all variations)‚Äù at http://hpaste.org/86702
12:07:36 <elliott> cmccann: that's a better choice than /query shachaf because I keep logs.
12:07:38 <Rotaerk> s/without extensions/without a new extension/
12:07:39 <davidfstr> elliott: It took me a while to figure out your "lengthOfFirstLine = length . takeWhile (/= '\n')" and write up an explanation. In case anyone is interested, see http://hpaste.org/86702
12:07:42 <elliott> so if you ever forget something I can remind you.
12:07:48 <greeny> sry when i stressed someone out there, kust thougt its easier to understand
12:08:02 <greeny> *for me
12:08:24 <elliott> davidfstr: cool -- you'll find the point-free version becomes easier to understand as you gain experience, I think :)
12:08:45 <elliott> the idea that you can plug two "loops" together directly and the result is efficient is one of the core ideas of Haskell, IMO
12:09:35 <elliott> takeWhile (/= '\n') could also be head . lines if not for the fact that lines "" = []
12:09:53 <elliott> and "length . head . lines" IMO reads very cleanly ("length of the first of the lines" -> "length of the first line")
12:10:40 <elliott> in particular, it's length that's doing most of the abstraction work here, because you get the strict accumulating tail recursion for free
12:10:49 <cmccann> elliott: actually that reminds me, I was just thinking about concocting a toy language with a type system based on dual-intuitionistic logic, mostly because why not.
12:11:06 <hpaste> keep_learning annotated ‚ÄúMonad transformer learning‚Äù with ‚ÄúMonad transformer learning (annotation)‚Äù at http://hpaste.org/86694#a86703
12:11:18 <elliott> cmccann: that sounds awesome. (follow-up question: how on earth would it work?)
12:11:22 <aCube> > length . fromMaybe [] . listToMaybe . lines  $ ""
12:11:24 <lambdabot>   0
12:11:40 <cmccann> elliott: it would work vaguely backwards, mostly
12:12:24 <joe9>  I want to format a Word32 with commas, such as: 45678 => 45,678. I found this article : http://stackoverflow.com/questions/3752898/haskell-format-number-with-commas
12:12:27 <joe9> just wanted to check if there is a better version of doing that.
12:12:30 <cmccann> elliott: like, think about how you might reason from a final result backwards to figure out what subexpressions will be forced in haskell
12:12:40 <keep_learning> Could some one please tell me why this code is giving error http://hpaste.org/86694. I tried to match the type signature
12:12:43 <keep_learning> but still error
12:12:45 <cmccann> elliott: and then picture doing everything like that
12:13:02 <c_wraith> keep_learning: In the first case, you want to short-circuit return?
12:13:02 <byorgey> keep_learning: in the case of (div, 0) you want the computation to "fail" (i.e. result in Nothing for the MaybeT)?
12:13:09 <byorgey> keep_learning: in that case, just use 'mzero'
12:13:14 <elliott> cmccann: does it make sense to give such a language dependent types and end up with a dual-intuitionistic theorem prover???
12:13:53 <cmccann> if anyone cared about proving theorems in dual-intuitionistic logic sure
12:14:07 <keep_learning> @unmtl byorgey Thank you!
12:14:07 <lambdabot> Plugin `unmtl' failed with: Parse error
12:14:21 <keep_learning> byorgey: Thank you!
12:14:25 <cmccann> I don't think byorgey is a monad transformer.
12:14:40 <ab9rf> hehe
12:14:41 <monochrom> what is dual-intuitionistic logic? is it where "x or not x" is provable, "not (x and not x)" is unprovable?
12:14:44 * byorgey is sad to learn that he is not even syntactically valid as a monad transformer.
12:14:52 <keep_learning> Could you please tell me why return Nothing or liftIO . return $ Nothing is not working ?
12:15:14 <elliott> cmccann: pretty sure weirdo dialetheists care.
12:15:30 <cmccann> monochrom: those are both accurate, yes
12:15:32 <byorgey> keep_learning: return Nothing  means you want to actually give Nothing as the result of your computation.
12:15:35 <monochrom> \‚à©/
12:15:40 <byorgey> but that is not what you want, you want the computation to fail.
12:15:50 <elliott> also you get like a dual to the function arrow don't you
12:15:52 <byorgey> i.e.   return Nothing has type  StateT ( Int -> Int -> Int ) ( MaybeT IO ) (Maybe a)
12:15:56 <geekosaur> keep_learning, return in MaybeT is defined to always succeed i.e. not be Nothing
12:15:59 * hackagebot bullet 0.2.3 - A wrapper for the Bullet physics engine.  http://hackage.haskell.org/package/bullet-0.2.3 (CsabaHruska)
12:16:04 <elliott> "p # q" read as "p but not q" or something right??
12:16:10 <elliott> trying to remember what i've read about it.
12:16:17 <byorgey> but you want  StateT ( Int -> Int -> Int ) ( MaybeT IO ) Int
12:16:24 <cmccann> elliott: is that # meaning the "pseudo-difference" or whatever?
12:16:31 <monochrom> hrm I like dual things!
12:16:41 <elliott> cmccann: I think so? I guess?
12:16:48 <monochrom> (did you know: a long time ago, I used the nick "duality")
12:16:51 <elliott> all I know is that instead of getting (p -> q) you get something dual to it
12:16:54 <cmccann> elliott: if so it's basically not (p -> q)
12:16:58 <byorgey> keep_learning: put another way:  'mzero' means 'fail'.  'return Nothing' means 'successfully give the value Nothing'.
12:17:16 <elliott> and whereas (p -> q) is "like" (p \/ ~q) (but constructive), (p # q) is "like" (p /\ ~q) I guess?
12:17:23 <cmccann> yes
12:17:49 <keep_learning> byorgey: geekosaur Thank you!
12:18:47 <cmccann> there are a couple different ways of expressing intuitionistic logic in a larger framework where a simplistic syntactic dualization gives you dual-intuitionistic logic
12:19:18 <cmccann> so it really is almost the same thing
12:20:06 <cmccann> monochrom: this is sort of inspired by my tinkering with linear logic, which is full of all kinds of tidy de morgan dualities!
12:20:10 <elliott> cmccann: I expect this language on my desk by Monday
12:20:28 <cmccann> elliott: I've not really figured out how to turn it into a language yet
12:20:35 <ab9rf> i expect a desk by monday
12:20:39 <elliott> cmccann: I suggest thinking quicker
12:20:50 <ab9rf> or even more quickly!
12:21:22 <cmccann> elliott: the lack of higher-order functions in the usual sense makes it difficult :[
12:22:41 <elliott> cmccann: it's ok, I bet it has lower-order functions.
12:22:50 <elliott> functions that take things even more primitive than values.
12:23:04 <cmccann> well obviously it has the co-functions you mentioned
12:23:36 <cmccann> which you can obviously mpose apart., turning (A # C) into (A # B) and (B # C)
12:23:39 <cmccann> or something like that
12:24:52 <elliott> that is cool.
12:25:17 <elliott> they need a fancy name though. boringction?
12:25:24 <cmccann> and I think there's some sort of existential CPS-y thing that lets you encode classical logic the same way you can with (forall r. (a -> r) -> r)?
12:25:57 <cmccann> (or does that need Cont in general? can't recall)
12:26:00 <elliott> also do you even know what they correspond to C-Hwise? like, A -> B corresponds to producing a value of type B given an assumption of type A, what about A # B?
12:26:17 <elliott> that seems like the most important thing. it occurs to me this is becoming pretty -blah-y.
12:26:57 <cmccann> well, (->) is sort of a disjunction+negation thing, right?
12:27:11 <cmccann> like a restricted form of what classical disjunction means
12:27:43 <elliott> right but... that's not how you write a function from a C-H perspective
12:28:05 <elliott> I guess you can say (p \/ ~q) means you get a p and write a q and then (p /\ ~q) would be either getting a p or writing a q??
12:28:31 <cmccann> right, this is an analogy not an implementation :P
12:29:02 <greeny> ok i found a solution for my problem: curry' f = g where g x y  = f(x,y)
12:29:03 <cmccann> so yeah, in the same sense that Either is crippled vs. classical disjunction, the conjunction type here would be crippled vs. classical conjunction
12:29:09 <greeny> there i can build on
12:29:28 <elliott> greeny: that's equivalent to curry' f x y = f (x,y)
12:29:29 <greeny> thanks for help
12:29:29 <cmccann> and so (A # B) would give you limited access to classical conjunction + negation in a similar way
12:30:43 <elliott> cmccann: what gets weaker about conjunction? intuitionistic to classical logic goes like "you can no longer 'destruct' a disjunction fully, but it's easier to create them", is it the same here or the reverse (you can't construct conjunctions as much, but it's easier to destruct them)? p.s. I have no idea what any of this means, send help./
12:30:53 <cmccann> elliott: so yeah, (A # B) probably comparable to a pair (which you can't split apart with case analysis) containing a value of type A and a continuation of type B that never returns
12:31:44 <elliott> by "continuation of type B", do you mean something that would result in something of type B if it ever returns, which it doesn't?
12:31:48 <cmccann> no
12:31:54 <cmccann> a continuation that accepts something of type B
12:31:56 <elliott> right.
12:31:57 <cmccann> and never returns at all
12:32:40 <cmccann> note that functions can have multiple outputs here, in general
12:32:43 <elliott> so you can go from (A, C -> never) to ((A, B -> never), (B, C -> never))
12:32:55 <cmccann> yes
12:33:01 <cmccann> wait
12:33:02 <cmccann> maybe
12:33:07 <elliott> that's weird. you can just get something of any type B out from nowhere? or is it an "exists B" rather than "forall B"?
12:33:09 <cmccann> I'm not sure if that should be a tuple there
12:33:11 <elliott> exists would make sense. I think.
12:33:15 <cmccann> it might be a disjunction
12:33:17 <greeny> elliott: oh god its so easy, thank a lot :) im really motivated to better understand it
12:33:25 <ab9rf> i feel disjointed
12:33:44 <cmccann> and yeah, existential quantifiers tended to crop up a lot when I was working through this
12:33:53 <elliott> cmccann: disjunction would be weird. like, it might sometimes give you (the same) A back, but other times not? this hurts. go implement it so I can understand it, please.
12:34:38 <cmccann> like I think (exists r. r # (r # a)) corresponds to (forall r. (a -> r) -> r)
12:34:42 <cmccann> in terms of encoding classical logic
12:35:42 <cmccann> also, kinda how intuitionistic truth is more demanding than classical truth, dual-intuitionistic truth is less demanding
12:35:54 <cmccann> we have double-negation elimination, but not introduction
12:36:38 <elliott> cmccann: oh, I guess it makes sense that you could get something of type B for any B.
12:36:45 <elliott> since it isn't necessarily awful if you get a _|_
12:37:03 <conal> I'm looking for a way to transform declarations from haskell-src-exts to Template Haskell. i found the syntax-trees package but it appears to handle only expressions. Any ideas?
12:37:47 <cmccann> elliott: actually there should be a perfectly sensible "bottom" type here, which would be the identity for disjunction
12:37:54 <cmccann> elliott: dual to () and (,) for Haskell
12:38:38 <byorgey> conal: I think that's what haskell-src-meta does?
12:38:43 <cmccann> (I typically use the negative polarity fragment of linear logic when talking about dual-intuitionistic logic, so I call it Bottom instead of 0/Zero/Void/etc)
12:38:53 <ozataman> anybody know if GHC profiling can be used with something like: https://code.google.com/p/jrfonseca/wiki/Gprof2Dot
12:38:55 <byorgey> conal: I've never used it though
12:39:03 <conal> byorgey: thanks. i'll try it out.
12:39:52 <luite> yep it does, jmacro uses it to antiquote haskell back into javascript
12:40:41 <cmccann> elliott: anyway, the main problem is that I have a hard time figuring out how to turn this into a programming language via C-H
12:40:49 <cmccann> because it's not even a closed category I think
12:41:37 <cmccann> elliott: it's probably a cocartesian coclosed category though.
12:41:38 <cmccann> of course.
12:43:27 <elliott> cmccann: are coclosed categories called open???
12:43:37 <elliott> clopen category
12:43:46 <cmccann> not that I know of, but maybe they should be.
12:44:00 <cmccann> this seems to be one of those things where mathematicians don't give a crap about the dualized form
12:44:24 <cmccann> like when you google for "co-something" and 90% of the hits are edwardk's code and the rest are stubs on nlab
12:45:13 <elliott> cmccann: you are an esoteric mathematician.
12:45:45 <cmccann> well, esoteric at least.
12:46:07 <cmccann> anyway I think agda's copatterns might be a useful syntactic style for this.
12:46:12 <cmccann> they're very cute.
12:47:35 <cmccann> (in case it wasn't obvious, such a language would probably work with codata exclusively)
12:47:48 <elliott> it wasn't obvious because I am not very smart.
12:49:20 <cmccann> well, the starting concept is that it would be some sort of co-ML thing.
12:49:51 <aristid> i.e. an impure language?
12:50:01 <cmccann> so it would be non-strict and use codata to the same extent that a generic ML would be strict and use data
12:51:42 <cmccann> I have no idea how dealing with side effects would work. this is confusing enough to begin with, I would rather start with a pure and total toy language and see how it works.
12:52:37 <aristid> cmccann: i just thought because you said co-ML :)
12:52:56 <aristid> hmm
12:53:11 <aristid> if it's dual, then a non-pure language becomes pure... right? :)
12:53:43 <cmccann> aristid: clearly it should be co-impure, i.e. it could reverse arbitrary side effects that already happened :P
12:53:51 <aristid> :)
12:54:02 <aristid> cmccann: that would be a very useful language
12:54:10 <cmccann> yes.
12:54:44 <cmccann> elliott: anyway I expect this all makes sense to you now and you can help me figure out how to implement it.
12:55:18 <elliott> cmccann: uh, of course, definitely, sure, yes, right.
12:55:31 <elliott> cmccann: so about shachaf's work...
12:55:34 <cmccann> haha
12:57:03 <cmccann> elliott: maybe once I create this dual-intuitionistic language you can create a data access library for it based on prisms, with co-prisms called lenses tacked on as well.
12:57:53 <elliott> cmccann: unfortunately your language probably only supports colibraries, which provide coabstractions.
12:58:09 <elliott> which basically let you write your program in a more verbose and unreadable manner.
12:58:19 <cmccann> elliott: so you're saying I should use lens directly?
12:58:20 <cmccann> OH SNAP
12:58:29 <dolio> I think a lot of co-stuff on nlab is probably a stub because it's just dualizing the main article.
12:58:42 <edwardk> elliott: it at least encourages collaboration
12:58:46 <dolio> Why write it twice?
12:59:08 <elliott> edwardk: no, cmccann's language will encourage llaboration
12:59:16 <ab9rf> ha
12:59:26 <ab9rf> is that welsh?
12:59:37 <cmccann> dolio: the coproduct article is pretty long.
13:00:19 <dolio> Yeah, but coproducts are pretty concrete, relatively speaking.
13:00:24 <leggo> > let [x,y] = [[1,2,3],[4,5,6]] in zip x y
13:00:26 <lambdabot>   [(1,4),(2,5),(3,6)]
13:00:31 <leggo> is there a nicer way of doing that?
13:00:38 <haasn> I like to imagine a parallel universe where humans naturally came to define what we know term as co-X first and called that X in their version of things
13:00:45 <haasn> we now*
13:00:58 <davidfstr> Say I want to apply my lengthOfFirstLine function (String -> Int) to stdin. How do I "lift" the standard input stream into a String that operates outside of IO?
13:01:01 <dolio> If you have lots of examples it might make sense.
13:01:51 <hpaste> ggurbet pasted ‚Äúsome eq issue‚Äù at http://hpaste.org/86710
13:01:56 <haasn> > transpose [[1,2,3],[4,5,6]] -- not exactly the same thing, since it's generalized to any number of elements
13:01:58 <lambdabot>   [[1,4],[2,5],[3,6]]
13:02:02 <ggurbet> hello
13:02:11 <monochrom> zip [1,2,3] [4,5,6], or if you must use "let", let x=[1,2,3]; y=[4,5,6] in zip x y
13:02:12 <cmccann> dolio: anyway, in the stuff I'm talking about there's a more significant difference, co-exponentials in a category not identical to its opposite are kinda different form exponentials
13:02:13 <ggurbet> can anyone help me with the issue?
13:03:09 <haasn> monochrom: zip [1..3] [4..6] -- !
13:03:41 <monochrom> sure
13:04:03 <dolio> Yes, but unless you have a lot of examples of coexponentials, the article is just going to be the article about exponentials, minus the examples, and with the dualization expanded out.
13:04:04 <cmccann> dolio: it's entirely possible that there's nothing interesting to say that isn't obvious from the relevant main articles though. I'm just not sure, and outside a few people working on paraconsistent logics there seems to be little interest.
13:04:19 <ab9rf> > zipWith (\x y -> [x,y]) [1..3] [4..6]
13:04:21 <lambdabot>   [[1,4],[2,5],[3,6]]
13:06:07 <cmccann> it's more that there isn't enough existing material to write an nlab page with, rather than the lack of an nlab page as such.
13:10:19 <ab9rf> ggurbet: you don't have an Eq instance for Node a
13:11:44 <ggurbet> ab9rf: i could not understand it
13:12:42 <geekosaur> then you need to work on that
13:13:01 <geekosaur> you can't use (==) without an Eq instance that specifies how (==) works for that type
13:13:21 <haasn> @src Eq
13:13:21 <lambdabot> class  Eq a  where
13:13:21 <lambdabot>     (==), (/=)   :: a -> a -> Bool
13:13:32 <jkarni> Is there any way, for a type Either a b, where b is already an instance of some class C, automatically having the typeclass functions with Right patterns map on to the underlying b functions?
13:13:58 <leggo> > fmap (+10) (1,2)
13:14:00 <lambdabot>   can't find file: L.hs
13:14:08 <leggo> huh
13:14:21 <ab9rf> leggo: lambdabot fart, try again
13:14:27 <leggo> > fmap (+10) (1,2)
13:14:28 <lambdabot>   (1,12)
13:14:32 <haasn> jkarni: you mean, as in an insane for C b => C (Either a b) -- ?
13:14:35 <haasn> instance*
13:14:40 <leggo> is there equivalent that applies f to both fst and snd ?
13:14:49 <haasn> > upon both (+10) (1,2)
13:14:50 <lambdabot>   Couldn't match expected type `(a0, a0) -> (b0, b0)'
13:14:50 <lambdabot>              with actua...
13:14:51 <jkarni> yeah
13:14:54 <haasn> wha
13:14:56 <ab9rf> leggo: no
13:15:02 <haasn> :t upon
13:15:03 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
13:15:09 <haasn> oh
13:15:14 <haasn> > over both (+10) (1,2)
13:15:14 <ab9rf> :t both
13:15:17 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
13:15:17 <lambdabot>   mueval-core: Time limit exceeded
13:15:25 <haasn> > over both (+10) (1,2) -- third time's the charm
13:15:26 <lambdabot>   (11,12)
13:15:27 <ab9rf> ah, both requires that both types be the same
13:15:28 <geekosaur> arrow?
13:15:32 <haasn> or
13:15:38 <haasn> > (1,2) & both +~ 10
13:15:40 <lambdabot>   (11,12)
13:15:44 <ab9rf> where is both from?
13:15:49 <elliott> lens
13:15:51 <haasn> arrow also works:
13:15:54 <ab9rf> ah, that figures
13:15:59 <ab9rf> hoogle doesn't know about lens yet
13:16:00 * hackagebot fay-base 0.14.3.1 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.14.3.1 (AdamBergmark)
13:16:02 <haasn> > join (***) (+10) (1,2)
13:16:04 <lambdabot>   (11,12)
13:16:36 <ggurbet> any ideas?
13:18:06 <ab9rf> ggurbet: add an Eq instance for Node a
13:18:29 <leggo> :t over
13:18:30 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
13:19:33 <jkarni_> The particulars:
13:19:40 <jkarni_> I'm using the fgl graph library
13:20:00 <ggurbet> ab9rf: how? this is part of a homework and i am not supposed to change the behavior of the node
13:20:14 <jkarni_> and would love to have a "path graph" type
13:20:41 <ab9rf> ggurbet: then find out where you're using (==) or (/=) on a Node and remove that code
13:20:55 <jkarni_> s.t. the type Either (<pathgraph>) (<graph>) would be an instance of the Graph class
13:21:05 <jkarni_> but <pathgraph> alone isn't
13:21:23 <jkarni_> since part of the class definition involves adding nodes, etc.
13:21:41 <jkarni_> and adding nodes and edges to pathgraph would result in something else
13:22:17 <jkarni_> (unless I uglyly force it to just return another pathgraph by ignoring multiple edges from a single node)
13:22:56 <jkarni_> This is a case of a more general issue I sometimes run into in haskell
13:23:24 <jkarni_> You might be inclined to implement a safe list, for instance, which is never empty
13:24:13 <capisce> what's the problem with that?
13:24:21 <jkarni_> But you would also like to support e.g. a filter that doesn't return a maybe
13:24:26 <jkarni_> but instead just an empty list
13:24:35 <jkarni_> if the filter function is never true
13:24:45 <ggurbet> ab9rf: this is the only code i have written so far. can the problem be related to elem/notElem
13:24:48 <jkarni_> and then to combine functions such as these
13:25:07 <jkarni_> you might want an either type, with list and safe lists
13:25:54 <ab9rf> :t elem
13:25:55 <lambdabot> Eq a => a -> [a] -> Bool
13:25:56 <jkarni_> but it seems like you'd have to manually pattern match the either filter, in the case of a unsafe list match, to the normal function
13:26:02 <ab9rf> ggurbet: elem requires Eq a, so yes
13:26:26 <jkarni_> am I missing something - is there an easier way for all this?
13:27:16 <ab9rf> ggurbet: possibly getDifferentNodes, you use elem on a Node there
13:27:19 <ggurbet> ab9rf: any suggestions without affecting node structure?
13:27:31 <ggurbet> ab9rf: ok let me check it
13:28:19 <ab9rf> ggurbet: try adding a typesig on getDifferentNodes, that will probably illuminate the problem
13:28:53 <ab9rf> ggurbet: it looks like it should be getDifferentNodes :: (Eq a) => [Node a] -> [Node a] -> [Node a]
13:33:07 <davidfstr> I note that hGetContents returns a pure (lazy) String that can be used outside of the IO monad. What happens if an IO error occurs during lazy evaluation of this string in a pure context (i.e. outside of IO)?
13:33:47 <hpaste> davidfstr pasted ‚ÄúhGetContents + lengthOfFirstLine‚Äù at http://hpaste.org/86713
13:34:07 <davidfstr> Related code to make this question more concrete: http://hpaste.org/86713
13:34:27 <efie> I just read about seq and understand that it is useful in the definition of foldl' if you have an accumulator of type Int for example, but is reducing to WHNF of importance for more complex data structures? (could you maybe give an idea for an example?)
13:34:45 <elliott> efie: you can do something like
13:34:53 <hpaste> ggurbet pasted ‚Äúanother eq issue‚Äù at http://hpaste.org/86714
13:35:05 <elliott> foldl' (\ ... -> p `seq` q `seq` (p+1, q+1))
13:35:14 <elliott> using seq to make evaluation to WHNF do more than just evaluate to WHNF.
13:35:19 <elliott> (see also the deepseq package)
13:35:24 <ggurbet> i corrected the issue but now i am getting another compile error (pasted at the bottom)
13:36:32 <efie> elliott: you mean by pattern matching with a more complex structure seq can be applied to the some desired inner parts?
13:36:46 <elliott> sure.
13:37:05 <efie> ok, thanks
13:37:22 <ggurbet> ab9rf: any ideas for the new error?
13:39:45 <jkarni_> ggurbet: b <-y , with y :: Network a, isn't going to work?
13:41:14 <ggurbet> jkarni_: no it won't?
13:41:31 <jkarni_> maybe if you pattern match into y
13:42:13 <jkarni_> .e.g getDifferentNodes x Graph y ?
13:42:28 <jkarni_> since then y will in fact be a list, and you can perform the usual list comprehension stuff
13:43:45 <monochrom> you need parentheses. getDifferentNodes x (Graph y)
13:44:20 <jkarni_> yup, sorry
13:45:17 <ab9rf> ggurbet: that's a much easier to track error :)
13:46:01 * hackagebot fay-base 0.14.3.2 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.14.3.2 (AdamBergmark)
13:46:14 <ab9rf> yeah, x and y are networks, so you need to extract the node list
13:46:20 <jkarni_> although getLabels expect a network
13:46:48 <jkarni_> nking ... done.
13:46:48 <jkarni_> Œª: :
13:47:02 <ab9rf> nking?
13:47:09 <jkarni_> no clue what that was
13:47:19 <ab9rf> probably a paste oops
13:47:24 <jkarni_> yup
13:48:15 <ggurbet> ab9rf: jkarni_ : well isn't x/y a node list? i cannot differentiate the error here
13:48:21 <ggurbet> it seems like a node list
13:48:30 <ggurbet> where do i make the mistake?
13:48:38 <ab9rf> ggurbet: x and y are Network
13:48:43 <ab9rf> not node lists
13:48:53 <ab9rf> you need to pull the node list out of the Network type
13:49:26 <ab9rf> you could use pattern matching
13:49:50 <ab9rf> getDifferentNodes x@(Graph xn) y@(Graph yn) = ...
13:50:01 <ab9rf> then x will be the network and xn the node list
13:51:11 <ab9rf> you could also use a pattern match with let or where
13:53:48 <ggurbet> thank you for your help
13:54:00 <ggurbet> i will work on it and will try to fix the problem
14:09:58 <atondwal> so I'm using parsec, and trying to do something along the lines of (string "\\\"" <|> noneOf "\"")
14:10:26 <atondwal> but obviously that doesn't work because noneOf parses Chars
14:11:47 <atondwal> so I try  noneOf "\"" >== return . (:[])
14:12:02 <atondwal> err, noneOf "\"" >>= return . (:[])
14:12:28 <atondwal> but that complains that Stream s m isn't a monad :/
14:17:09 <ab9rf> :t noneOf
14:17:12 <lambdabot>     Not in scope: `noneOf'
14:17:12 <lambdabot>     Perhaps you meant `oneOf' (imported from Data.List.Split)
14:17:22 <ab9rf> meh
14:17:39 <killing-joke> i am trying to install hakyll using cabal. the install fails with some broken crypto libs.
14:17:48 <killing-joke> should i be using a different method?
14:17:51 <atondwal> :t Text.ParserCombinators.Parsec.noneOf
14:17:52 <lambdabot> Text.Parsec.Prim.Stream s m Char => [Char] -> Text.Parsec.Prim.ParsecT s u m Char
14:30:11 <ab9rf> eggo
14:35:47 <NemesisD> anyone familiar with io-streams/http-streams? trying to figure out how to build a response handler that disregards the body but still forces it to make the request
14:36:10 <NemesisD> a responseHandler being :: InputStream ByteString -> IO a
14:49:33 <NemesisD> grahhh what do you guys do when your program is hanging on something? i'm sure this is lazy evaluation biting me but i don't really know how to deal with it
14:52:02 <monochrom> I would be unsure.
14:53:13 <ab9rf> hanging?
14:54:22 <NemesisD> i'm testing a http api client. i'm using a project i built that spins up an HTTP server in a thread and can assert on the requests it got/fake responses. the tests work fine except the one returning a 204 no content never terminates
14:55:03 <ab9rf> that sounds like a buggy wuggy
14:55:22 <NemesisD> yup
14:55:27 <ab9rf> you shoud fix that
14:56:11 <NemesisD> thanks for the helpful advice
14:56:22 <ab9rf> anythyme
14:59:41 <ab9rf>  you might get more useful advice if you gave mre specific information
15:02:37 <aCube> !add fort6
15:03:09 <ab9rf> > splitChunks [1,2,3,4] [1..]
15:03:11 <lambdabot>   Not in scope: `splitChunks'
15:03:23 <ab9rf> > Data.Lists.Split.splitChunks [1,2,3,4] [1..]
15:03:25 <lambdabot>   Not in scope: `Data.Lists.Split.splitChunks'
15:03:25 <lambdabot>  Perhaps you meant one of thes...
15:03:33 <ab9rf> > Data.List.Split.splitChunks [1,2,3,4] [1..]
15:03:35 <lambdabot>   Not in scope: `Data.List.Split.splitChunks'
15:03:35 <lambdabot>  Perhaps you meant one of these...
15:03:44 <ab9rf> > Data.List.Split.splitPlaces [1,2,3,4] [1..]
15:03:45 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10]]
15:03:50 <ab9rf> wee
15:04:01 <ab9rf> > (Data.List.Split.splitPlaces [1..] [1..]) !! 10
15:04:03 <lambdabot>   [56,57,58,59,60,61,62,63,64,65,66]
15:04:07 <NemesisD> ab9rf: im not sure where i should be more specific. i must have an infinite loop somewhere or maybe io-streams is waiting forever for something. what tools are available to me in haskell to troubleshoot things like this?
15:05:23 <ab9rf> > map head (Data.List.Split.splitPlaces [1..] [1..])
15:05:25 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
15:05:45 <ab9rf> > map head (Data.List.Split.splitPlaces [0..] [0..])
15:05:47 <lambdabot>   [*Exception: Prelude.head: empty list
15:05:51 <ab9rf> aw
15:05:53 <ab9rf> > map head (Data.List.Split.splitPlaces [1..] [0..])
15:05:56 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
15:06:01 <aCube> @oesis
15:06:01 <lambdabot>  Sequence not found.
15:06:11 <aCube> @oesis 1,2,4,7,11,16,22,29,37,46,56,67
15:06:12 <lambdabot>  Central polygonal numbers (the Lazy Caterer's sequence): n(n+1)/2 + 1; or, m...
15:06:12 <lambdabot>  [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,2...
15:06:20 <ab9rf> aCube: cool
15:06:58 <aCube> @oesis 0,1,3,6,10,15,21,28,36,45,55,66,78,91,105
15:06:59 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
15:06:59 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
15:07:17 <ab9rf> lazy caterer's sequene?
15:07:20 <ab9rf> odd name
15:08:47 <cmccann> ab9rf: it's the largest number of pieces you can cut a pizza into with a given number of straight-line cuts
15:08:52 <ab9rf> cmccann: ah
15:09:02 <cmccann> well, that's the motivation for the name
15:09:24 <cmccann> rephrase in terms of generically inedible circles for the non-pizza form
15:09:54 <cmears> monochrom, are you around?
15:10:12 <monochrom> should it matter?
15:10:16 <ab9rf> eels
15:12:40 <cmears> I looked some more into the space-leak-with-sequence experiments you posted on comp.lang.haskell
15:12:50 <pantsman> my hovercraft is full of eels
15:13:03 <monochrom> I see. then it matters.
15:13:12 <cmears> I came up with a possible explanation: https://gist.github.com/cmears/96df6dc0b317c9b3ae5c#a-second-problem
15:14:34 <cmears> I'm not sure that it's right, so any criticism is welcome (:
15:17:09 <monochrom> did you know: GHC's sequence, when unoptimized, is defined by: foldr k (return []) ms where k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:19:36 <cmears> Ah, no
15:21:26 <cmears> Maybe that is not such a good way to define it?
15:22:57 <monochrom> I do not know. but your theory fails to explain unoptimized sequence.
15:22:58 <parcs> monochrom: what's its optimized definition
15:23:16 <monochrom> its optimized definition is hidden in the rewrite rules
15:23:45 <monochrom> and inlining things and GHC's various optimizations. it's hidden in GHC.
15:23:58 <parcs> that does seem like a bad definition
15:26:13 <parcs> on second thought it's a good definition
15:28:15 <cmears> You mean to call the ordinary sequence, without optimization?
15:28:23 <monochrom> right
15:28:26 <aCube> why not foldr (liftM2 (:)) (return []) ms ?
15:28:52 <aCube> @ty liftM2
15:28:53 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:29:12 <parcs> no real reason i suppose
15:36:11 <hpaste> Rotaerk pasted ‚ÄúStage‚Äù at http://hpaste.org/86721
15:36:30 <Rotaerk_> anything particularly dreadful about my code there?
15:36:43 <Rotaerk_> (it does what I need it to; just asking about style and such)
15:37:25 <cmears> Calling sequence from a program without optimizations gives the same result as the manual foldr-definition --- or do I have to recompile base with optimizations turned off?
15:39:18 <mm_freak> any idea how to prove the category laws for a recursive type like Auto?
15:39:29 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
15:39:51 <ab9rf> very carefully?
15:40:11 <mm_freak> i get (a1 . a2) . a3 = a1 . (a2 . a3) except for one detail:
15:40:32 <mm_freak> the recursive application is (a1 . a2) . a3 for the one and a1 . (a2 . a3) for the other
15:40:54 <cmccann> mm_freak: we then prove that first!
15:40:56 <cmccann> what could go wrong.
15:41:02 <cmccann> s/we/well
15:41:13 <mm_freak> cmccann: that's the very thing i'm trying to prove
15:41:20 <mm_freak> so to prove it that way, i need to prove it
15:41:25 <cmccann> mm_freak: that was the joke :P
15:41:31 <mm_freak> ok ;)
15:41:38 <cmccann> that said
15:41:42 <cmccann> are you sure that isn't valid anyhow?
15:41:46 <cmccann> like, coinductively here
15:41:48 <elliott> mm_freak: that's just like proving any result about a recursive function, right?
15:41:52 <elliott> it's like (co)induction
15:42:02 <mm_freak> hmm, i see
15:42:19 <mm_freak> it makes sense
15:42:36 <elliott> you prove that if (p.q).r = p.(q.r), then (p'.q').r' = p'.(q'.r'), where p',q',r' are all bigger than their '-less counterparts, or such.
15:43:27 <cmccann> it's productive corecursion because you're always proving that the law holds for the next step before relying on the recursive part
15:43:46 <elliott> right.
15:43:59 <elliott> it's sort of weird how functions are codata.
15:44:12 <ab9rf> now i want codfish
15:44:12 <mm_freak> and since there is no base case all i need to prove is the recursive case
15:45:14 <mm_freak> i.e. assuming that (a . b) . c = a . (b . c) i can prove (a' . b') . c' = a' . (b' . c')
15:45:22 <mm_freak> and i'm done, because it applies corecursively
15:45:22 <cmccann> mm_freak: right. it's corecursive, so you just need to prove that you can always make progress
15:45:23 <mm_freak> right?
15:45:38 <elliott> mm_freak: "bisimulation" is a keyword that might help
15:46:06 <mm_freak> i think i get the concept‚Ä¶  it's not really much different from induction
15:46:14 <cmccann> I'm pretty sure this is all 100% legit and valid if you throw enough fancy notation at it.
15:46:15 <elliott> well, it's dual. :p
15:46:31 <Rembane> Recursion but in two ways?
15:47:14 <mm_freak> i guess i was just confused by the lack of a base case
15:47:34 <cec24> i've been writing some big nested lists of double to file by packing them into lazy bytestrings: Binary.encode and then Data.ByteString.Lazy.writeFile on them
15:47:55 <cec24> this is faster than printing the files using ascii, but the resulting blobs are about 2x as big on disk as their ascii versions, this is suprising
15:48:11 <elliott> mm_freak: consider this
15:48:21 <elliott> mm_freak: you want to prove fix (1:) = map id (fix (1:))
15:48:31 <elliott> so you expand each side out to WHNF
15:48:31 <cmccann> ah, good example
15:48:37 <monochrom> cmears: sorry, I misremembered. your theory holds up. I do not have a counterexample.
15:48:37 * cmccann was trying to think of something like that
15:48:41 <elliott> 1 : fix (1:) = id 1 : map id (fix (1:))
15:48:44 <elliott> equate the heads
15:48:47 <elliott> 1 : fix (1:) = 1 : map id (fix (1:))
15:48:49 <cec24> if i was to use C and fwrite the doubles together, they'd be way smaller than writing out all the chars as ascii, is Binary.encode doing something weird?
15:48:52 <elliott> and you're done, by coinduction
15:49:08 <elliott> this is what proving two coinductive streams equal by bisimulation looks like
15:49:31 <cmears> monochrom, thanks, I'm glad it's figured out
15:49:51 <mm_freak> elliott: i get it now =)
15:49:54 <mm_freak> thanks for your help, guys
15:50:07 <monochrom> cmears: that is, both mysequence and Prelude.sequence are the same code, and have the same behaviour, and your theory covers both
15:50:21 <elliott> mm_freak: more formally, if you have a relation R on infinite coinductive streams, and R xs ys -> head xs = head ys, and R xs ys -> R (tail xs) (tail ys), then R xs ys -> xs = ys (using extensional equality)
15:50:33 <elliott> er, there's foralls on all of those
15:50:40 <elliott> you can imagine how this extends to your associativity proof
15:51:38 <cmears> Right, and Prelude.sequence will always have sharing, because it's "explicit" via the foldr
15:52:41 <mm_freak> cec24: just compare the results and perhaps feed them through 'file'
15:53:07 <mm_freak> all kinds of weird encoding things happen, when you go from String (text) to ByteString (byte array)
15:53:07 <cec24> mm_freak: well right, so when i load the files up and look at the contnets they of course agree and thats fine
15:53:10 <cmccann> Rotaerk_: somewhat belatedly I don't see anything blatantly awful in there independently of what the code does
15:53:23 <cec24> mm_freak: i'm going from [[Double]] -> ByteString
15:53:37 <mm_freak> cec24: so what exactly becomes 2x?
15:53:39 <cec24> mm_freak: via Binary.encode but yeah what ever that's doing its not very space efficient
15:54:01 <cec24> mm_freak: the disk space usage, my ascii files are about 32Mb the Binary.encode files are ~ 60Mb
15:54:23 <cec24> mm_freak: and i'd naiively expected it would be much less than a raw ascii dump
15:54:47 <mm_freak> cec24: "1" is shorter than the 8 bytes of a raw Double
15:55:14 <mm_freak> so a text encoding may indeed be shorter
15:55:55 <cec24> mm_freak: hang on, isn't writing out "120923092.249948394839" going to be longer than writing it out as a  double?
15:56:25 <cec24> mm_freak: now i feel like my entire understanding of floats is blown
15:56:43 <mm_freak> cec24: in that case yes, but not in general
15:57:36 <cec24> mm_freak: hmm they're the components of eigenvectors so i was expecting them to be pretty messy
15:58:10 <cec24> mm_freak: well ok, i clearly need to think more about this
15:58:20 <dmwit> Wait a second.
15:58:37 <dmwit> Are we sure that it's the encoding difference, and not binary's method of dealing with [] that's the problem?
15:59:16 <dmwit> If you've peeked in the file, you must know whether most of them are "1" or most are "120923092.249948394839".
16:00:14 <dmwit> If most of them are a full 17-18 bytes, and you're still doubling the size, my guess is that all the indirection that [] introduces is the real problem.
16:00:24 <cec24> dmwit: yes they're mostly ragged
16:00:33 <cec24> dmwit: in the sense of ragged means many sigfigs
16:00:38 <dmwit> right
16:00:52 <cec24> dmwit: so if i concat [[Double]] -> [Double] and then encode it
16:01:11 <dmwit> probably won't help much
16:02:01 * dmwit looks at what the Binary instance for [] does by default
16:02:28 <cec24> dmwit: well at the end of the day file size is really not a big issue, i just wanted the fastest io and avoiding all those calls to Read and such seem to have helped a lot
16:02:42 <dmwit> yes
16:03:21 <dmwit> Hm, the Binary instance for [a] already does what I would have suggested (namely, put the length then all the elements flat).
16:03:35 <cec24> dmwit: how do i look at Binary [a] ? i can't seem to find it on the hackage page
16:03:49 <cec24> dmwit: yes that's eminently sensible
16:04:16 <dmwit> http://hackage.haskell.org/packages/archive/binary/0.7.0.1/doc/html/src/Data-Binary-Class.html#Binary <- grep for [a] here
16:04:37 <dmwit> Perhaps it's the Double instance that's causing problems.
16:04:57 <dmwit> It calls decodeFloat and writes those, hence writes an Integer and an Int.
16:05:08 <dmwit> dunno
16:05:22 <cec24> dimwit: huh, i don't really understand that
16:05:52 <dmwit> What's "that"? And do you want to understand?
16:06:04 <cmccann> dmwit: should I go to hac phi this year [y/n]
16:06:10 <cec24> dimwit: oh what 'decodeFloat' does is what i was wondering about
16:06:30 <dmwit> cmccann: If you have to ask: y
16:06:54 <Rotaerk_> cmccann, k, thanks
16:06:55 <dmwit> cec24: The documentation for it is pretty good, if you know a bit about IEEE 754 to begin with.
16:07:01 <Eduard_Munteanu> [Y/n/?] ?
16:07:17 <cmccann> dmwit: it was a trick question, I'm already looking into the logistics and seeing if I'll be able to
16:07:17 <cec24> dmwit: yeah just started to look at it, now i'm wondering how fwrite works
16:07:18 <Eduard_Munteanu> CONFIG_HACPHI -- no help available, listen to dmwit or stick to the default.
16:07:30 <efie> what does the function is strict in its x-th argument mean? how far is argument x being evaluated? does it just mean that the x-th argument IS evaluated in each and every case (how far is not important)?
16:07:31 <cmccann> Eduard_Munteanu: haha
16:07:53 <dmwit> efie: "f is strict" means "f _|_ = _|_", nothing more
16:07:55 <cmccann> efie: it means that if you pass _|_ as that argument, the result will be _|_
16:08:17 <dmwit> cec24: fwrite?
16:08:18 <cmccann> usually that means the function cares about the value of that argument somehow, but it could be strict just to spite you, who knows
16:08:29 <Unspeakable> Read it: http://www.unspeakable.info/viewtopic.php?f=3&t=3
16:08:30 <ab9rf> > decodeFloat 8e15
16:08:32 <lambdabot>   (8000000000000000,0)
16:08:44 <cec24> dmwit: i'm used to C, size_t fread(void *ptr, size_t size, size_t nmembFILE *" stream );
16:08:55 <dmwit> > decodeFloat 1e63
16:08:56 <lambdabot>   (5473822126268817,157)
16:09:11 <ClaudiusMaximus> repa issue - when i use  computeP  instead of  return . (\a -> deepSeqArray a a) . computeS  my program slows down by a large factor...  could it be because in my traverse'd function i'm unsafePerformIO to race two forkIO threads?
16:09:14 <Eduard_Munteanu> ssize_t, no?
16:09:17 <hpaste> ClaudiusMaximus pasted ‚Äúm-set with repa (code)‚Äù at http://hpaste.org/86723
16:09:20 <efie> ok, thanks
16:09:23 <Eduard_Munteanu> (in the return type)
16:09:45 <dmwit> cec24: Oh, and fwrite similarly just takes a pointer? Then it probably just dumps the double byte-for-byte.
16:09:56 <dmwit> cec24: I agree that it's a bit of a shame that the Binary instance doesn't mimic this somehow.
16:09:57 <cec24> dimka: right it does exactly that, which is what i was expecting
16:10:02 <Eduard_Munteanu> Sure it does, in C.
16:10:05 <hpaste> ClaudiusMaximus annotated ‚Äúm-set with repa (code)‚Äù with ‚Äúm-set with repa (computeS +RTS -s)‚Äù at http://hpaste.org/86723#a86724
16:10:18 <Eduard_Munteanu> With no endianness conversion.
16:10:30 <cec24> yeah, portability is not really my concern here
16:10:45 <cec24> i see how Data.binary is really nice on those grounds
16:10:48 <hpaste> ClaudiusMaximus annotated ‚Äúm-set with repa (code)‚Äù with ‚Äúm-set with repa (computeP +RTS -s)‚Äù at http://hpaste.org/86723#a86725
16:10:54 <dmwit> I think Eduard_Munteanu is saying that portability *is* a concern for the "binary" library, which may explain why they don't do that.
16:10:57 <dmwit> yeah
16:11:19 <Eduard_Munteanu> Data.Binary forced big-endianness upon you, IIRC.
16:11:36 <cec24> dmwit: right i understand they wanted to make something that works cross platform and it seems really good, i think I was looking in the wrong place
16:11:47 <cec24> anyway thanks all, i have to run
16:11:50 <dmwit> cec24: Well, you can always unsafeCoerce to a Word64 and then write. :3
16:11:57 <Ralith> doubles don't have endianness iirc
16:12:03 <cmccann> dmwit: that sounds completely safe!
16:12:03 <Ralith> so it would be safe to dump it out
16:12:23 <dmwit> What could possibly go wrong?
16:12:31 <ab9rf> duck!
16:12:59 <cmccann> I'm not sure a duck could go wrong. it's just a duck.
16:13:21 <cmccann> I hear ducks are notoriously averse to static types though.
16:14:20 <Eduard_Munteanu> I would've never believed ducks and pythons got along so fine.
16:14:22 <Ptival> duck :: forall a. a
16:15:00 <cmccann> Ptival: more like forall a. (Data a) => a
16:15:40 <Ptival> duck :: forall a. (CanQuack a) => a
16:15:41 <Eduard_Munteanu> forall a. (Object a) => a
16:19:06 <dmwit> useDuck :: CanQuack a => a -> IO ()
16:19:39 <dmwit> return-type polymorphism is pretty unusual
16:20:44 <ab9rf> "duck" is what you say when anybody says "what could possible go wrong?" because that statement inevitably means a wrecking ball is about to swing through the area, or some other violent disaster
16:21:06 <ab9rf> also, "what could possibly go wrong?" is a standard Daffy Duck line
16:21:16 <aCube> duck typing
16:21:20 <cmccann> ab9rf: yes. but intentional misinterpretation seemed like more fun.
16:21:27 <ab9rf> cmccann: indeed
16:21:37 <cmccann> anyway, ducks are inherently funny.
16:21:42 <ab9rf> quack
16:22:57 <dmwit> More seriously, though, would it be hard to write a fixed-length 8-byte Binary instance for Double?
16:23:02 <dmwit> How would you do it?
16:23:19 <ab9rf> time for me to retire now and become a duck
16:23:50 <Eduard_Munteanu> dmwit: why are you mentioning fixed-length specially? :/
16:24:16 <cmccann> dmwit: my guess would be a choice from: something slow, something unsafe, or a primop.
16:24:20 <dmwit> Okay, I don't mind if it's variable length and never goes over (sizeOf (undefined :: Double)).
16:24:40 <Eduard_Munteanu> No, I mean when does it make sense to be variable length?
16:25:05 <dmwit> Eduard_Munteanu: The current encoding is variable length.
16:25:10 <Eduard_Munteanu> oO
16:25:46 <Eduard_Munteanu> I guess for portability across different float formats? Not sure if anybody else does it differently except for endianness.
16:26:01 <Ralith> Eduard_Munteanu: I don't think floats have endianness...
16:26:19 <Ralith> not IEEE ones anyway
16:26:23 <dmwit> Hm, Storable does it somehow.
16:26:26 <Eduard_Munteanu> Surely the mantissa needs some notion of endianness?
16:26:33 <dmwit> Oh, but Storable doesn't promise to work on other machines, I guess.
16:27:19 <nbouscal> the exponent would have a notion of endianness as well
16:27:33 <nbouscal> how could it not?
16:27:39 <Eduard_Munteanu> Yeah, I picked that since it's probably the largest thing in there.
16:27:49 <dmwit> Perhaps Ralith is implying that IEEE 754 defines the bit order.
16:27:50 * Eduard_Munteanu unfortunately doesn't remember many details
16:27:52 <nbouscal> yeah the mantissa is larger, but the exponent is still > 1 byte
16:28:00 <Ghoul_> Ducks...
16:28:05 <cmccann> the bits have to go in some order.
16:28:06 <Ralith> dmwit: that's my suspicion; not certain though
16:28:08 <nbouscal> dmwit: Yes, but that defined bit order is either big-endian or little-endian :P
16:28:27 <dmwit> nbouscal: That does not follow.
16:28:40 <nbouscal> not by necessity but by reasonableness
16:28:41 <dmwit> nbouscal: Or rather, I do not follow.
16:29:01 <nbouscal> floats are stored as [sign][exponent][mantissa]
16:29:05 <Eduard_Munteanu> I guess they could store the bits with LSB/MSB inverted
16:29:20 <cmccann> they could store the bits in any well-defined order they wanted.
16:29:23 <nbouscal> the exponent and mantissa both being of the size they are, they have to be stored in either big-endian, little-endian, or some other manner. i think it's pretty unlikely to be the latter
16:29:25 <dmwit> nbouscal: Oh, I see; you're being pedantic. What Ralith means (I think) is that all machines use the same endianness.
16:29:31 <nbouscal> yes, that's what i was saying!
16:29:38 <nbouscal> that they use the same endianness, but that it is one or the other
16:29:49 <dmwit> Okay. That doesn't help further the top-level discussion, though.
16:30:14 <nbouscal> okay. maybe i was just being pedantic then. :)
16:30:23 <cmccann> I'm not sure why something like floats would use anything other than a monotonic order for the bits though, regardless of where byte boundaries fall.
16:30:52 <Eduard_Munteanu> cmccann: why not? After all that's the case for integers.
16:30:53 <ab9rf> cmccann: you're new at this, aren't you? :)
16:31:25 * ab9rf remembers some phenomenally weird storage formats in days gone by
16:32:12 <cmccann> Eduard_Munteanu: integers and floats are very different in how they're stored.
16:32:32 <cmccann> floats are more like several values of whatever bit length packed into some number of bytes.
16:32:39 <Eduard_Munteanu> Hm, I guess IEEE754 doesn't specify endianness? Are you supposed to be able to read doubles produced by a different CPU?
16:32:55 * Eduard_Munteanu can't find much
16:33:27 <dmwit> From http://www.perlmonks.org/?node_id=208558: "Q: Does the order of the bits matter as to whether the format qualifies as a IEEE 754 floating point number? A: No."
16:33:47 <Eduard_Munteanu> cmccann: if you split the double into bytes and store it as a 64bit value, then you do get to pick endianness
16:34:19 <dmwit> So unsafeCoerce'ing to Word64 is Wrong.
16:34:22 <Eduard_Munteanu> Not sure how this applies to 'long double' or 80 bits stuff.
16:34:40 <Eduard_Munteanu> Ah, nvm, that's a multiple of 8 too.
16:35:05 <cmccann> Eduard_Munteanu: alternatively, what integer value you get from interpreting a float as such could be machine-dependent in strange ways.
16:35:18 <dmwit> What, no Bits instance for Double? =P
16:35:25 <Eduard_Munteanu> cmccann: I suspect so... you're not supposed to do it.
16:35:45 <Eduard_Munteanu> You need to go through conversion instructions.
16:36:31 <cmccann> when I've seen bit-packed formats specified they've generally assumed that all bits go in the same order even when crossing byte boundaries and even when more than 8 bits are involved.
16:37:11 <cmccann> which can lead to interesting situations where e.g. a 12-bit packed integer doesn't match the endianness of the same bits stored as a 2-byte integer alone.
16:37:14 <Eduard_Munteanu> cmccann: I think you mean from the programmer / CPU perspective? Bits are always naturally ordered in e.g. shift instructions.
16:37:33 <Eduard_Munteanu> But as soon as that hits memory, YMMV.
16:38:30 <cmccann> Eduard_Munteanu: yeah it all gets messy real fast :T
16:39:05 <dmwit> I'm starting to see why Binary ships out to decodeFloat. =P
16:39:31 <cmccann> that said, according to the internet IEEE floats don't specify byte order, and in practice the order is platform-dependent.
16:39:34 <cmccann> so that's awesome.
16:40:17 <Eduard_Munteanu> Yeah, forced endianness would suck.
16:40:36 <dmwit> Why?
16:40:38 <Eduard_Munteanu> Nobody can agree on that :)
16:40:55 <cmccann> cf. http://stackoverflow.com/q/1786137/157360 and http://stackoverflow.com/q/2782725/157360 and so on
16:41:02 <cmccann> man, computers are so confusing.
16:41:09 <Eduard_Munteanu> Well, I suppose you could shuffle bytes just before they hit memory, but it does seem more complex.
16:41:41 <dmwit> No, I still don't get it.
16:41:54 <Eduard_Munteanu> That doesn't account for mixed endianness or such weird stuff. :)
16:41:56 <dmwit> Somewhere down on the hardware you've got some and and or gates to do the floating point operations.
16:42:01 <Eduard_Munteanu> (but that's rare)
16:42:15 <dmwit> Why does it help to be able to choose what order the inputs come in when you're designing those gates?
16:42:27 <dmwit> It's the same gates no matter what the order is, right?
16:43:02 <Eduard_Munteanu> dmwit: hm, yeah
16:43:51 <Eduard_Munteanu> I guess it only matters if you need to read the opposite endianness.
16:44:37 <dmwit> When I design the successor to 754, I'll pick an endianness.
16:45:07 <cmccann> dmwit: you should make it middle-endian.
16:45:16 <dmwit> I'll make it spiral-endian.
16:45:22 <Eduard_Munteanu> Ah, yes, s/mixed/middle/ above.
16:45:23 <cmccann> awww yeah
16:45:48 <dmwit> aha!
16:45:50 <Rarrikins> You've got to interleave the exponent and mantissa bits, too.
16:46:03 <dmwit> The bit order is the order that digits appear in the base-64 digits of pi.
16:46:07 <dmwit> This is clearly the superior order.
16:46:15 <cmccann> yes.
16:51:01 <monochrom> why are you humans so crazy?! :)
16:52:37 * geekosaur waves banana, ook ook
16:53:00 <monochrom> you're effectively saying, "when I design the successor to 754, I'll add a permutation cipher"
16:53:15 <ma-> :>
16:53:50 <monochrom> I guess it's still less obfuscating than a substitution cipher
16:54:50 <monochrom> and the haskell-cafe post I just clicked to read talks about reactive-banana
16:54:52 <dmwit> monochrom: At least it's a fixed permutation! Current 754 has a permutation cipher and you just have to guess what it is by looking at uname.
16:58:00 <Eduard_Munteanu> Or you could store it in a known format.
16:58:16 <Eduard_Munteanu> (e.g. pick an endianness and stick to it, e.g. big-endian/network order)
16:58:51 <cmccann> Eduard_Munteanu: what, and make things simpler? that's not how technology works.
16:59:00 <Eduard_Munteanu> Aww.
16:59:37 <Eduard_Munteanu> Actually I meant that as a reply for dmwit. You don't need to guess if your application stores data according to some rules.
16:59:54 <dmwit> That is essentially what Binary is doing.
17:00:13 <dmwit> (Storing it in a known format.)
17:20:00 <staafl> what's the simplest way to get GHC to memoize a function?
17:20:57 <arbn> staafl: Write that code to memoize the function, or use a memoization library.
17:20:57 <troydm> staafl: www.haskell.org/haskellwiki/Memoization
17:22:26 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-memocombinators is particularly fun
17:22:58 <staafl> troydm, Cale, thanks
17:24:21 <staafl> troydm, can you explain how the technique in memoized_fib works
17:24:24 <staafl> I can't seem to follow it
17:26:30 <ab9rf> i used one of the memoization thingys in a thing i wrote a while back
17:26:37 <ab9rf> it took a bit to get the hang of it, but it worked fine after that
17:27:35 <troydm> staafl: well since haskell is lazy
17:28:06 <troydm> staafl: (map fib [0 ..] !!)
17:28:14 <troydm> won't be calculated unless needed
17:29:09 <troydm> and since it won't be calculated twice u can say that subsequent calls to memoize_fib will use prev calls's values
17:29:24 <troydm> or simply memoized values
17:32:06 <staafl> troydm, why won't  (map fib [0 ..] !!) be calculated on every call though
17:47:49 <troydm> staafl: no idea rly why, maybe there are ppl here who know better than me
17:48:12 <staafl> troydm, ok, thanks for the pointer in any case :-)
17:48:39 <troydm> but i think memoized_fib (n-1) subsequent call will use previously calculated values of memoized_fib (n-2)
17:48:44 <ab9rf> i'm not even sure what map fib [0..] !! is
17:49:09 <troydm> it means map function fib on [0 ..] list and then take !! n
17:49:23 <ab9rf> yeah, but that token string doesn't parse on its own
17:49:38 <ab9rf> > :t map id [0..] !!
17:49:38 <troydm> :m +Data.List
17:49:40 <lambdabot>   <hint>:1:1: parse error on input `:'
17:49:46 <ab9rf> :t map id [0..] !!
17:49:47 <lambdabot> parse error (possibly incorrect indentation)
17:49:58 <ab9rf> :t (map id [0..] !!)
17:50:00 <lambdabot> (Enum a, Num a) => Int -> a
17:50:01 <troydm> import Data.List ((!!))
17:50:12 <ab9rf> ah, with parens it makes a section
17:50:19 <tgeeky> > (map id [0..]) !! 2
17:50:21 <lambdabot>   2
17:50:33 <tgeeky> > (map id [0..] !!) 2
17:50:34 <lambdabot>   2
17:51:58 <tgeeky> kind of weird to give all integers as an input to a fib function, but to each their own
17:52:04 <troydm> ohh
17:52:07 <troydm> i've figured it out
17:52:31 <troydm> well atleast i think
17:52:36 <troydm> maybe i'm wrong
17:53:45 <staafl> troydm, do share
17:54:11 <twobitsprite> any HopenGL users here? I'm looking for a mapping between C openGL functions/etc to HopenGL functions/etc... I.e., I'm trying to find what Haskell function corresponds to a C function
17:54:17 <tgeeky> this is like one of those threads on unbuntu forums where some guy says "I've totally solved this problem and have it working great now, thanks!" leaving everyone else hanging
17:55:19 <monochrom> I have solved that problem. :)
17:55:26 <troydm> staafl: well i think since [0..] is lazy list and calls to it will be from the same execution domain it will use the same memory internally and thus won't reapply fib function where value is already calculated
17:56:03 <troydm> or so i think it works internally
17:56:27 <staafl> so it's compiler magic, not FP magic?
17:56:55 <troydm> like if u do let a = [0..] in a !! 1 + a !! 2
17:57:20 <troydm> won't a call to a !! 1 and a !! 2 use the same value in memory ?
17:58:13 <staafl> troydm, hmm... I'll have to think this over
17:58:18 <staafl> when I'm less sleep deprived
17:58:31 <troydm> so if u do soem let a = map somecpuintensivefunc [0..] in a !! 1 + a !! 2
17:58:49 <troydm> somefunc will be applied to 0 only once
17:58:57 <troydm> to 1 only once
17:58:59 <troydm> etc
17:59:15 <ab9rf> troydm: the use of map in this case does _not_ create a memoization
17:59:32 <ab9rf> at least not reliably
17:59:48 <troydm> indeed
18:00:18 <ab9rf> the compiler _may_ recognize that it's evaluating a thunk it's aleady evaluated before and join them, but it is not required to
18:01:35 <monochrom> I have to run, but "map x y" alone doesn't tell you anything. you have to look at more code
18:03:33 <monochrom> "let x=0 in let f y = x + f (y-1) in f 10" one single x lives through all iterations of f.
18:04:31 <monochrom> "let f y = (let x=0 in x + f (y-1)) in f 10" every iteration has a new x, unless the compiler is smart and refactors x.
18:04:46 <monochrom> note how "0" alone or "x + f (y-1)" alone tells you nothing.
18:05:34 <monochrom> when designing and analysing memoization (or lack of), look for the "=" signs.
18:13:00 <roconnor> is there an easy way to use HTTP-4000 over ssl?
18:16:21 <copumpkin> roconnor: not as far as I could tell
18:16:26 <copumpkin> I ended up using http-enumerator
18:16:36 <copumpkin> which doesn't force enumerators down your throat, but then they deprecated that one I think
18:17:06 <elliott> http-conduit doesn't force you to use conduits either I think
18:17:11 <copumpkin> oh okay
18:22:03 <roconnor> what is http-enumerator?
18:24:54 <roconnor> or http-conduit
18:25:16 <tgeeky> roconnor: both packages on hackage
18:25:39 <tgeeky> roconnor: http-enumerator is the obselete version of http-conduit, evidently
18:25:59 <roconnor> but that means I have to click on things ... several times.
18:26:55 <roconnor> tls dependency seems promising
18:28:23 <blackdog> ozataman: hey, cassy looks good, cheers :) how far off do you think batch insert is? would it be a hard thing to add for someone new to the codebase?
18:54:01 <koninkje> Any XMLers around? I have a huge XML file which is many (relatively) small entries; I'd like to get a tree for each entry (a la DOM), but process the different entries separately (a la SAX). Is there an easy way to do that?
18:54:18 * koninkje has done plenty of XML processing, just not in Haskell
18:54:37 <copumpkin> sounds like a job for BDB XML >_>
18:55:15 <copumpkin> if you break up the small entries into separate entries in the DB, that is
18:57:27 <koninkje> Ah, there it is: Text.XML.Expat.Tree.saxToTree
18:57:34 <koninkje> that should work well enough
19:21:23 * hackagebot hyakko 0.4.0 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.4.0 (JeremyHull)
19:23:32 <parcs> beautiful
19:57:49 <koninkje> Another XML query: any idea what the "->>ItemM" type is when heap profiling hexpat?
20:01:53 <heath> haskell reads so nicely in this example: https://gist.github.com/heath/5471346
20:02:11 <koninkje> hmmm, looks like it's <List-0.5.1:Data.List.Class.sub_s2K7> ...I wonder what that is...
20:21:47 <lispy> twobitsprite: use OpenGLRaw instead
20:22:07 <lispy> twobitsprite: the hopengl binding is built on it and it matches the C api closely
20:46:59 <ab9rf> heath: haskell has the extra terseness of sections
20:53:40 <NemesisD> anyone know how snaplets can be loaded into a main snap application? i don't understand how they are supposed to be used
21:05:50 <ab9rf> are people who use snap called snappers?
21:06:38 <cmccann> ab9rf: that sounds a bit fishy.
21:09:08 <copumpkin> I've never red 'snappers' in writing anywhere, but perhaps verbally?
21:09:51 <cmccann> copumpkin: I hope that was a deliberate pun and not a typo.
21:10:12 <copumpkin> ^_^
21:11:11 <cmccann> copumpkin: you going to hac phi?
21:11:20 <copumpkin> probably
21:11:33 <copumpkin> you?
21:11:39 <cmccann> hopefully
21:11:55 <cmccann> probably will unless something comes up
21:12:38 <copumpkin> yay
21:12:50 <copumpkin> I think I'm going to scala days right afterwards
21:12:55 <copumpkin> but not the end of the world
21:14:03 <hpaste> dmj pasted ‚Äúprime checker‚Äù at http://hpaste.org/86731
21:14:13 <cmccann> I saw edwardk already has a talk planned for hac phi. which is kind of funny because it's not like he needs an excuse to tell anyone who'll listen what he's working on. :D
21:15:25 <copumpkin> lol
21:17:54 <edwardk> =P
21:19:11 <edwardk> pretty much every time i get through talking to someone about what i'm working on the process of explaining has caused me to realize something i could do better
21:19:26 <edwardk> thus it behooves me to spend more time talking to people =)
21:20:39 <dmj> what's the motivation to use attoparsec over parsec when parsing a plain text file locally?
21:20:40 <cmccann> it's a good technique for clarifying your ideas
21:22:25 <edwardk> dmj: speed
21:22:45 <edwardk> dmj: at the expense of error reporting, sane backtracking behavior, and all else ;)
21:23:20 <parcs> i thought parsec is the one with insane backtracking behavior
21:23:46 <dmj> edwardk: thank you
21:24:16 <edwardk> parsec's backtracking makes perfect sense, it'll backtrack unless the parser has consumed input, thereby committing to a branch
21:24:34 <edwardk> use try to do multiple symbols of lookahead,
21:24:49 <edwardk> the alternative requires you to hold open all contexts for all time, and destroys your ability to do error reporting ever
21:25:10 <edwardk> attoparsec doesn't do decent error reporting because it can't be fixed to do so
21:25:33 <parcs> i see
21:25:46 <cmccann> is the solution is to use trifecta instead? :P
21:26:08 <Saizan> so attoparsec's speed is there unless you use backtracking much?
21:26:32 <edwardk> the benefit of the parsec approach is that you can reason fairly locally about backtracking behavior and as you parse you can throw away contexts as you go
21:26:50 <edwardk> attoparsec is mostly saved by its predominant usage pattern of parsing some kind of packet, then starting all over fresh
21:27:47 <edwardk> attoparsec sits in a paradoxical limbo where for its major usage pattern properly dealing with the backtracking causes it to lose something like 50% speed for the cases bos cares about, so it just won't happen ;)
21:28:46 <bos> i've thought about adding a non-backtracking <|> operator
21:28:56 <bos> but leaving backtracking as the default
21:31:07 <edwardk> The main reason I try to avoid 'non-backtracking by default' is that that default means i can't ever give decent diagnostics when something goes wrong. if you can always backtrack then there is no place to 'blame'
21:31:38 <bos> yep. i don't care about diagnostics very much, alas.
21:31:39 <edwardk> i realize attoparsec sacrifices all that on the altar of speed ;)
21:31:50 <bos> correct :-)
21:32:24 <bos> actually, more to the point: i do care about diagnostics, but when i do, i use parsec.
21:32:52 <edwardk> bos: that reminds me i should spend some time and send you some patches to make it at least _possible_ for me to write an orphan set of 'parsers' instances for attoparsec.
21:33:09 <edwardk> as it stands the lib doesn't expose quite enough for me to write instances that get usable inference.
21:33:15 <bos> i'm not sure what you just said, but sure!
21:33:31 <edwardk> the parsers package provides fairly generic parsing combinators that work across parsing libraries
21:33:34 <edwardk> with parsec, trifecta, etc.
21:33:49 <bos> oh, oh, i see. i hadn't heard of it.
21:34:11 <edwardk> but as it stands behind the scenes in attoparsec you have one hidden private Parser type that takes as a type argument whether or not its ByteString or Text
21:35:09 <edwardk> when i go to make a couple of the instances for some high level parser classes i can't hook in parametrically independent of that choice. it should just be a matter of exposing a small module that offers a few combinators for which the choice of that argument isn't fixed.
21:36:37 <edwardk> as it stands, what happens is i can only make instances for "Parser ByteString a" or "Parser Text a" rather than "Parser r a" so if in a type checking context it can't figure out the input type, my previous attempt just starts whining about lack of type annotations
21:36:55 <bos> yea
21:36:58 <bos> yeah
21:37:02 <bos> apparently i can't type
21:37:53 <bos> i'm currently melting my brain writing a crit-bit tree in haskell.
21:38:01 <edwardk> I had a similar 'painted into a corner' issue involving not being able to write something that could cooperate with Text's Stream machinery
21:38:16 <edwardk> funny. i've been building a whole bunch of blind-trie/fusion-tree stuff lately
21:38:36 <edwardk> mostly for external memory
21:38:39 <bos> i've had it in mind for a while to replace Text's fusion machinery with a monadic stream
21:38:48 <bos> but it feels like work
21:38:56 <bos> of the unrewarding kind
21:40:44 <edwardk> what are you using the crit-bit tree for?
21:40:55 <bos> keeping my brain wrinkly
21:41:16 <edwardk> using a blind trie or encoding the intervening bits?
21:41:17 <hpaste> ryld pasted ‚Äúmapping help‚Äù at http://hpaste.org/86732
21:41:25 <bos> it's a good idea to implement a perverse data structure every once in a while.
21:41:36 <edwardk> i recommend wavelet trees ;)
21:41:45 <edwardk> they've been massively brain bending for me lately
21:42:00 <ryld> hey everyone, need some quick help with a function involving mapping through a list
21:42:07 <edwardk> probably the singularly most useful data structure i've found in the last 10 years
21:42:07 <ryld> code pasted above
21:42:25 <bos> edwardk: crit-bit tree is like a blind trie
21:42:54 <Ralith> edwardk: geez, now I need to go read up on these
21:42:57 <bos> i had to google "blind trie"
21:43:30 <edwardk> there are some good results on trie-like structures under cache oblivious assumptions from the last few years
21:43:39 <Ralith> oh I see
21:43:44 <Ralith> looks clever
21:44:00 <Ralith> edwardk: what are wavelet trees for, beyond storing strings?
21:44:10 <bos> Ralith: making your brain wrinkly :-)
21:44:16 <Ralith> heh
21:44:29 <Ralith> I can get behind that
21:44:37 <bos> the purpose of most data structure research these days is to earn a phd, or occasionally to justify a grant you earned.
21:45:07 <edwardk> Ralith: given a bit vector that can be encoded in zeroth order entropy N space we can extend it with supplementary structures of size little o(N) to support two extra queries, rank, and select.
21:45:41 <edwardk> rank_a(S,i) = # of occurrences of 'a' in S up to position i, and select_a(S,i) = the position of the i'th occurence of 'a' in S.
21:45:52 <edwardk> those can be answered in O(1) with the right supplementary structure
21:46:11 <Ralith> ooh.
21:46:13 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚Äúsnail‚Äù with ‚Äúsnail (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/51197#a86733
21:46:22 <edwardk> using those you can do all sorts of things
21:46:34 <edwardk> wavelet trees lift rank and select from booleans to arbitrary alphabets
21:46:45 <edwardk> and keep the same space guarantees
21:46:59 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚Äúsnail‚Äù with ‚Äúsnail (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/51197#a86734
21:47:18 <edwardk> (technically a wavelet tree works on a prefix-free code made out of an arbitrary base alphabet
21:47:38 <edwardk> now, in my case, what i have is the start of an entire database made out of them
21:47:55 <Ralith> that sounds intruiging
21:48:08 <edwardk> where i'm taking each column that you'd consider key-like, and putting a wavelet tree on the projection of that column out of the rows of data i have
21:49:22 <edwardk> and then using the ability to use a wavelet tree like a stable-sort by that column, and a particularly perverse choice of ordering of the rows that makes it so i get lots of runs in the top levels of all of my wavelet trees
21:49:48 <edwardk> to make it so i can answer lots of aggregation queries, medan-selection, L-estimators like trimmed means, etc. in sublinear time.
21:49:56 <edwardk> over arbitrary subsets of the data
21:50:09 <cmccann> and also everyone gets a pony
21:50:13 <edwardk> yep
21:50:16 <Ralith> best database
21:50:28 <edwardk> well, its mostly focused on OLAP workloads rather than OLTP
21:50:37 <edwardk> its just pretty good at aggregates
21:51:08 <edwardk> i have to bend over backwards to get decent performance for some things that other designs are good at intrinsically though ;)
21:51:32 <edwardk> right now i'm wrestling with a loss of about 4 orders of magnitude performance on deletions
21:52:30 <cmccann> solution: don't delete anything
21:52:39 <edwardk> i was just really really happy when the median selection stuff started making sense
21:52:47 <edwardk> because there _isn't_ an OLAP solution that offers those
21:53:15 <edwardk> at least not a version of them that is sublinear and non-approximate and which doesn't baloon storage requirements
21:53:26 <lispy> hello
21:53:27 <bos> great, i'm going to start asking interview candidates to efficiently implement delete in a wavelet tree
21:53:33 <cmccann> haha
21:53:43 <edwardk> bos: =) actually its quite easy there.
21:53:52 <bos> that will filter out all the non-edwardk-level candidates quite fast
21:53:55 <edwardk> the problem is more with all the other structures i pile on top
21:54:03 <lispy> bos: :)
21:54:23 <edwardk> you can make a wavelet tree out of a dynamic rank/select structure, but then you pay log n for the base rank
21:54:51 <edwardk> so rank for the wavelet tree becomes O ((log n) * (log sigma))  instead of O(log sigma)
21:55:37 <edwardk> a lot of my pain is that i want parallelism which forces me into a design like the cache oblivious lookahead array, where i make wavelet trees in batches by merging, and then have to walk several of them rather than one.
21:56:06 * lispy wanted to make something parallel last week and found it was much slower that way
21:56:31 <lispy> In fact, just running my algorithm without paralleization but on the threaded RTS with -N made it a lot slower.
21:56:38 <edwardk> and then i can delete by using _another_ rank/select structure, but i need to know which of those files contains the entry i want to delete, and doing a full key compare is actually a lot more expensive in this model.
21:58:48 <edwardk> with a centroid trie, and locally-preserving rear coding i could get it down to O(1 + logBase b n + |K|/b) for a cache oblivious blocksize b, but with just the wavelet tree i can only get O(|K| log N) , so i wind up wanding to add the centroid trie, or a blind trie with a giraffe cover or a fusion tree with little LPRC datasets or something to get me to the former asymptotics for deletes
21:58:53 <edwardk> but thats a _lot_ of complexity =(
21:59:14 <edwardk> (where |K| is the length of the key)
21:59:27 <edwardk> and n is the total size of all of my keys in the database
21:59:35 <bos> lispy: that doesn't completely surprise me
22:00:28 <bos> yet again, quickcheck saves my bacon
22:00:54 <lispy> bos: So, just using the threaded RTS without utilizing threads is expected to add overhead?
22:01:09 <bos> lispy: certainly if you've got multiple cores firing, yes
22:01:30 <bos> lispy: if you're not running with +RTS -N, it's maybe a tiny bit slower
22:01:34 * lispy has very rarely experimented with parallelism or concurrency
22:02:57 <lispy> I use mapConcurrently from async (this is a raytracer) over the rows of the output image and I still didn't see a speed up with +RTS -N. I suppose I need to try something like threadscope next.
22:03:00 <bos> lispy: you should buy simon marlow's book, then.
22:03:05 <bos> ...when it comes out.
22:03:13 <lispy> totally
22:03:21 <bos> it's really very very good.
22:04:22 <lispy> I would like for my ray-tracer's mainloop to be pure, but needing a tiny bit of randomness has made that hard.
22:04:46 <lispy> I was thinking that I may say screw it to using haskell for that part and move it to opencl
22:14:34 <edwardk> Ralith: anyways, github.com/analytics in notes/papers.md there is a reading list of interesting stuff that has come up over the course of researching the design. the wavelet tree section is particularly interesting
22:14:47 <Ralith> cool, thanks
22:15:15 <edwardk> Ralith: i'm happy to go into more er.. accessible detail though ;)
22:15:38 <Ralith> heh
22:15:44 <Ralith> I think I followed most of it
22:16:15 <Ralith> enough to get why it's exciting and motivate/contextualize further reading, anyway
22:17:20 <edwardk> Right now what i'm looking into how to get a nice supplementary structure to make updates/deletes tolerably fast, and make it cheaper to read off the actual values held in the rows. right now they are scattered across a lot of different wavelet trees and actually require a fairly alarming number of external I/Os ;)
22:31:30 * hackagebot text 0.11.3.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.3.0 (BryanOSullivan)
22:36:54 <realitygrill> anyone got a recommendation on a GADT tutorial?
22:38:39 <johnw> realitygrill: what would you like to know?
22:38:57 <johnw> the first step I'd recommend doing, is translated an ordinary ADT into its equivalent GADT
22:39:03 <johnw> translating*
22:39:14 <realitygrill> johnw: just learning about the concept generally, i don't even know what a GADT is yet
22:39:19 <realitygrill> hmm
22:39:25 <johnw> so, they are actually very simple
22:39:29 <johnw> let's take an example
22:39:39 <cmccann> it's like a regular, non-G algebraic data type, except that type parameters can depend on the choice of constructor
22:39:40 <johnw> data Maybe a = Nothing | Just a
22:39:47 <johnw> as a GADT, that's:
22:39:51 <johnw> data Maybe a where
22:39:57 <johnw>   Nothing :: Maybe a
22:40:03 <johnw>   Just :: a -> Maybe a
22:40:13 <realitygrill> hm..
22:40:18 <johnw> it's exactly like writing function signatures for the data constructors, instead of the usual shorthand
22:40:36 <johnw> the advantage is that now we can vary the return type between these data constructors
22:40:46 <johnw> (and you can introduce constraints)
22:40:48 <realitygrill> what if it is a product type?
22:40:57 <johnw> Cons :: a -> a -> List a
22:41:00 <cmccann> it still looks like the type of the constructor
22:41:10 <cmccann> I think that's not the type you wanted.
22:41:15 <cmccann> a -> List a -> List a
22:41:19 <johnw> ah, thank you
22:41:27 <johnw> Pair :: a -> a -> Pair a
22:42:00 <realitygrill> okay..
22:42:26 <realitygrill> trying to digest the advantages here
22:42:32 <cmccann> better yet, "Nil :: SizedList Z a" and "Cons :: a -> SizedList n a -> SizedList (S n) a"
22:42:44 <cmccann> now you have lists with length encoded in the type
22:42:56 <johnw> any GADT you write can be transformed back into an isomorphic ADT, so I think of GADT as a convenience feature, not something essential to gain functionality you don't already have access to
22:43:07 <realitygrill> hmm
22:43:18 <cmccann> realitygrill: the main advantages come when you want to do something complicated :P
22:43:26 <realitygrill> ha
22:43:27 <johnw> see http://www.haskellforall.com/2012/06/gadts.html, if you want more info on that transformation
22:43:38 <cmccann> johnw: fyi usually "ADT" means something else than what the last three letters of GADT stand for
22:43:40 <realitygrill> considering i was told, go learn about gadts, that would be useful..
22:43:43 <realitygrill> :o
22:43:47 <cmccann> "abstract" instead of "algebraic"
22:43:56 <johnw> cmccann: huh, I did not know that
22:44:04 <cmccann> johnw: it's annoying
22:44:22 <johnw> are there ADTs which are not also initial algebras?
22:44:46 <cmccann> usually clear from context but not always. if you say ADT without anything to indicate otherwise people will probably assume you mean abstract data type :T
22:45:02 <johnw> well, in my head I meant algebraic, so phew
22:45:22 <realitygrill> i didn't realize that either, thanks
22:45:27 <cmccann> yeah in the middle of a conversation about GADTs it's pretty obvious
22:45:30 <johnw> in Haskell, we use ADT to mean the algebraic variety, yes?
22:45:42 <cmccann> but there's an irritating TLA collision here
22:46:10 <cmccann> in Haskell we mostly just call them data types :P
22:46:17 <johnw> ok
22:46:43 <johnw> realitygrill: does that help?  there really isn't much to look at in GADTs, they are just super handy in some situations
22:47:12 <realitygrill> well, it gets across the basic idea
22:47:29 <Saizan> you need to add TypeFamilies' ~ and ExistentialQuantification to get GADTs out of ADTs
22:48:32 <cmccann> johnw: in Haskell an "abstract data type" generally means one with no constructors exported e.g. Data.Map
22:48:43 <cmccann> so both meanings of the acronym are plausible :T
22:49:27 <johnw> realitygrill: GADTs are just a synthesized yoneda embedding of an initial algebra, what's the problem? ;)
22:49:44 <johnw> cmccann: that's a good point
22:49:44 <realitygrill> johnw: lol. damn you :)
22:58:41 <mitchell> Hi, what does ::= mean in haskell
22:58:48 <ExternalReality> http://hpaste.org/86736 -- Can someone help me with this. It keeps on spinning out into and infinate loop.
22:58:48 <mitchell> is it the same as type?
23:00:12 <johnw> mitchell: it's a type function, defined by whichever library you're using
23:00:33 <johnw> (aka, type constructor)
23:00:39 <ExternalReality> it could also be -- http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:(%3A%3A%3D)
23:00:40 <mitchell> so it is the same as
23:00:41 <johnw> is this glib?
23:01:00 <mitchell> data mytype = [char]
23:01:03 <mitchell> does the same thing?
23:01:15 <mitchell> as data*
23:03:03 <johnw> mitchell: I'm not entirely clear what you're asking
23:03:11 <johnw> type mytype = [char]
23:03:24 <johnw> makes use of the special type constructor [], yes
23:03:34 <johnw> so, one can image: type mytype a b = a ::= b
23:03:47 <ExternalReality> d
23:03:51 <johnw> whatever that means, it depends on the docs for ::=
23:04:21 <johnw> ExternalReality: how do you know this is where the loop is happening?
23:04:43 <johnw> your instance for ConfigBackend is completely circular
23:04:52 <johnw> it's equivalent to saying f = f
23:04:57 <johnw> i mean, f x = f x
23:08:07 <ExternalReality> I see now -- I was looking at this : http://www.haskell.org/haskellwiki/Existential_type
23:08:26 <johnw> ah, I see
23:08:36 <ExternalReality> My instances don't pattern match making them circular
23:08:38 <johnw> yes, that isn't infinitely recursive because "shape" has a different type
23:09:15 <johnw> i must say, we've all written infinitely recursive instances at some time or another :)
23:09:32 <johnw> there is a pattern of f (T x) = f x
23:11:45 <ExternalReality> lol
23:11:57 <ExternalReality> thanks you johnw :-)
23:41:31 * hackagebot certificate 1.3.7 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.7 (VincentHanquez)
23:41:33 * hackagebot cryptocipher 0.5.0 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.5.0 (VincentHanquez)
