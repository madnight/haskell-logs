00:03:07 <killy9999> haskell.org up again, yay
00:04:08 <Ralith> yay
00:04:21 --- mode: ChanServ set +o shachaf
00:04:29 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]' by shachaf
00:04:34 --- mode: shachaf set -o shachaf
00:06:10 <no-n[5]> is there a function that gets a single keystroke from the user, so they don't have to press return?
00:06:56 <mzero> getChar I believe
00:07:04 <mzero> but again, you need to set the buffering on stdin
00:07:22 <shachaf> Sadly, the report agrees on the topic of getChar being a function.
00:08:27 <ivanm> @type getChar
00:08:29 <mzero> no-n[5]: also note that that isn't the same as setting the terminal in "raw" mode -
00:08:29 <lambdabot> IO Char
00:08:37 <ivanm> shachaf: how is getChar a function? :/
00:08:49 <elliott> the report says so
00:08:51 <mzero> but, I'm guessing you don't need "raw" mode
00:09:00 <elliott> from this we can prove that haskell is inconsistent and therefore does not exist.
00:09:06 <no-n[5]> ah
00:09:08 <ivanm> elliott: heh
00:09:16 <elliott> so I guess we don't need a channel for it...
00:09:26 <ivanm> elliott: or an off-topic channel for it
00:09:58 <elliott> no no, it's easy to be off the topic of something that is logically inconsistent. well, maybe not for some.
00:10:01 <shachaf> mzero: hSetBuffering stdin NoBuffering does two different things, one to buffering and one to the terminal.
00:10:07 * elliott should stop saying nonsense while people are trying to help.
00:10:10 <shachaf> mzero: It's kind of annoying that you can't separate the two.
00:10:19 <mzero> still don't think it sets raw mode, does it?
00:10:33 <Hermit> ivanm: it's an io action returning a Char
00:10:41 <ivanm> Hermit: yes, that's my point
00:11:31 <mzero> BAH it DOES set raw mode
00:11:35 <mzero> well.... I'll be!
00:11:53 <Hermit> ivanm: well since it's more like a value, it won't be computed if not needed, so once threaded with bind, it will be performed and it's result retreived
00:11:54 <shachaf> Oh, mzero has been thinking about things like raw mode.
00:12:11 <ivanm> Hermit: I know how getChar works
00:12:26 <ivanm> I was just querying how shachaf said the report said it was a function
00:12:30 <mzero> yes, well.... rather alot, really..... but I don't use Handles.... all Fd over here, all the time!
00:12:41 <Hermit> ivanm: sorry, I missed the context
00:12:47 <shachaf> How doe splush handle raw mode?
00:14:16 <mzero> it doesn't at present - but it will need to poll (ick) for raw mode on it's pseudo terminals, and plumb that state to the front end
00:14:28 <mzero> all of this is so that things like ssh can ask for passwords!
00:14:31 <shachaf> Sounds like fun.
00:14:42 <shachaf> By fun I mean "I'm glad I'm not the one doing it".
00:14:48 <mzero> yeah
00:15:08 <mzero> the only nice thing I can say about low-level POSIX programming in Haskell is....
00:15:15 <mzero> ...it's nicer than in any other language
00:15:50 * sw2wolf what's low-level POSIX programming ? is it FFI ?
00:16:18 <shachaf> sw2wolf: Why do you talk with /me?
00:16:40 <sw2wolf> shachaf: not ask, just thinking
00:17:20 <sw2wolf> i will ask if no result by thinking first
00:17:48 <mzero> sw2wolf: it working directly with the facilities supplied by POSIX, rather than the higher level library supplied by stdc or the Hasekll base libs
00:17:59 <mbuf> what is the recommended way to check the return status of an IO () function?
00:18:11 <mzero> so for example, working with file descriptors rather than handles -- and managing things like forking directly
00:18:17 <shachaf> What is a return status?
00:18:27 <arbn> mbuf: Give an example. Not sure what you mean.
00:18:39 <mzero> mbuf: do you mean, the equivalent of what youd' do checking errno in C?
00:18:39 <shachaf> Also: "IO ()" isn't a function, jokes about the report notwithstanding. Call it an action or a value or something.
00:18:41 <ivanm> I'm guessing the exit code of an executable
00:19:12 <mzero> mbuf: which IO action in particular?
00:19:20 <sw2wolf> mzero: what facilities does POSIX supply ? Isnot it stdc ?
00:19:20 <sw2wolf>  
00:19:32 <ivanm> my guess is: wrap it in catch/handle: if there's an exception, it failed :p
00:19:55 <mzero> sw2wolf: only some of the stdc lib is POSIX - and much what isn't in stdc (that which is *lower* than stdc) is
00:19:57 <shachaf> ivanm: I think it's better to wait until we know what the question is rather than make a random guess.
00:20:10 <mzero> sw2wolf: http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html
00:20:12 <ivanm> true
00:20:31 <hpaste> mbuf pasted “Test return value from IO () function” at http://hpaste.org/85579
00:20:58 <mbuf> arbn: mzero ^^
00:21:17 <ivanm> mbuf: if you want an IO action to return a value indicating success or failure, then have it of type IO Bool or something
00:21:30 <ivanm> there's no way outside of test to tell if it succeeded or not
00:21:41 <ivanm> alternatively, you can throw an exception and catch it
00:22:22 <hpaste> mzero annotated “Test return value from IO () function” with “Test return value from IO () function (annotation)” at http://hpaste.org/85579#a85580
00:23:48 <sw2wolf> mzero: How to implement those POSIX parts not in stdc ?
00:24:00 <hpaste> mzero annotated “Test return value from IO () function” with “Test return value from IO () function (annotation) (annotation)” at http://hpaste.org/85579#a85581
00:24:15 <mzero> sw2wolf: you don't - they are generally supplied by the operating system ---
00:24:21 <mzero> they are "primitive"
00:24:31 <arbn> mbuf: Well, you have a few options. You can throw an exception iff it fails, or make it IO Bool, and probably other things.
00:24:36 <sw2wolf> in assembly ?
00:24:56 <mbuf> mzero: thanks
00:25:12 <mzero> no, the operating system can be written in C or even Haskell --- but it better not use stdc to do its implementation!
00:25:35 <mzero> read the Linux kernel - it is essentially an implementation of the POSIX lower level in C
00:26:14 <mzero> mbuf - I'm assuming you have some actual IO actions to perform in test --- because otherwise it should just be   Int -> Bool
00:26:16 <sw2wolf> mzero: i see now. then it is needed if you do kernel programming i.e. driver ?
00:26:23 <mzero> yes
00:28:19 * sw2wolf but those parts can be portable between different OS ?
00:29:02 <mzero> meaning?
00:29:04 <mzero> which parts?
00:29:19 <mzero> the implementatino of POSIX, or things built on POSIX, or kernel drivers
00:29:22 <sw2wolf> those POSIX parts not in stdc
00:29:25 <mzero> (no, yes, no)
00:29:58 <mzero> the APIs are standard - so calling them is portable (that is their raison d'etre)
00:30:04 <mzero> but the implementations aren't
00:30:49 <sw2wolf> AFAIK, linux driver is VERY different from BSD driver
00:31:37 <arbn> How does this OS conversation relate to Haskell, in this case?
00:32:10 <mzero> exactly....
00:32:14 <mzero> night all!
00:32:42 <sw2wolf> arbn: maybe (getChar) Nothing :)
00:33:33 <sw2wolf> @ty getChar
00:33:34 <lambdabot> IO Char
00:40:07 * hackagebot publicsuffixlist 0.1 - Is a given string a domain suffix?  http://hackage.haskell.org/package/publicsuffixlist-0.1 (MylesMaxfield)
00:55:56 <jamy> Hello! How to solve? instance Show (Constr a) where
00:56:20 <jamy> Hello! How to solve? instance Show (Type a) where
00:56:46 <jamy> show (Constr a) = "" ++ (show a) ++ ""
00:57:16 <Twisol> jamy: What is the error?
00:57:33 <CindyLinz> instance Show a => Show (Type a) where
00:57:38 <jamy> "Cannot justify constraints in instance member binding"
00:57:46 <Twisol> What CindyLinz said, then.
00:58:06 <Twisol> You need to tell Haskell that Type a is only an instance of Show if a is also an instance of Show.
00:58:13 <jamy> if (show a) replace to "" then ok
00:58:30 <Twisol> Right, because `show a` only works if a is a Show instance.
00:58:41 <Twisol> er, a is an instance of a type implementing Show.
00:58:45 <jamy> a in my case its Int
00:58:49 <jamy> only
00:58:57 <Twisol> but Haskell doesn't know that from your instance declaration
00:59:00 <Twisol> you tell it a, not Int
00:59:14 <Twisol> and a could be anything
00:59:18 <quchen> jamy: When you've got code longer than one line put it on HPaste instead of writing it in the channel, because that's quite messy
00:59:21 <quchen> @where hpaste
00:59:22 <lambdabot> http://hpaste.org/
00:59:33 <CindyLinz> Yeah, or you should use: instance Show (Type Int) where
00:59:37 <quchen> As a bonus, you get a free run of HLint :-)
01:00:10 <CindyLinz> since you only use a=Int
01:01:03 <jamy> CindyLinz: ok, i'll try it now
01:02:22 <jamy> instance Show (Type Int) where ... -> Syntax error in instance head (variable expected)
01:02:49 <Twisol> Can you paste the code and the error at hpaste please?
01:03:06 <jamy> ok
01:04:55 <bitonic> I think that ‘instance Show (Type Int) where’ is the worse solution... if you want only int ‘instance (a ~ Int) => Show (Type a) where’, but you most likely simply want ‘instance (Show a) => Show (Type a) where’
01:04:58 <hpaste> jamy pasted “Show instance” at http://hpaste.org/85583
01:05:37 <Twisol> jamy: and the full error output?
01:06:04 <bitonic> jamy: that requires FlexibleInstances, but otherwise should work
01:06:06 <CindyLinz> It seems Node (a, Tree a, Tree a, ...) not Node a  ^^|
01:06:37 <hpaste> bitonic annotated “Show instance” with “Show instance (annotation)” at http://hpaste.org/85583#a85584
01:06:44 <bitonic> jamy: ^^^
01:07:00 <bitonic> sorry, without the FlexibleInstances
01:07:12 <hpaste> bitonic annotated “Show instance” with “Show instance (annotation) (annotation)” at http://hpaste.org/85583#a85585
01:07:20 <Twisol> CindyLinz: That makes it a senary tree. :D
01:08:03 <CindyLinz> oh forget what I said.. orz
01:08:27 <hpaste> jamy annotated “Show instance” with “Show instance (annotation)” at http://hpaste.org/85583#a85586
01:08:47 <bitonic> jamy: are you using Hugs?
01:09:13 <CindyLinz> But jamy you need  instance Show a => Show (Tree a)
01:09:28 <jamy> :) yes
01:09:31 <bitonic> or better, are you using something else than GHC?  in any case, my annotation is Haskell 98, so it should work pretty much everywhere
01:09:54 <CindyLinz> because your 'a' is not always Int
01:10:22 <jamy> so, what i need to put?
01:10:28 <CindyLinz> it is sometimes (Tree Int) or (Tree (Tree Int))
01:10:47 <bitonic> jamy: you need to make sure that the type parameter of Tree is an instance of ‘Show’
01:11:18 <bitonic> CindyLinz: also because ‘instance Show (Tree Int)’ is not valid Haskell.  although Hugs should support that if you enable extensions
01:11:29 <CindyLinz> mmmm
01:11:36 <jamy> bitonic: that error throws in load time
01:12:40 <bitonic> jamy: 1) did you look at <http://hpaste.org/85583#a85585> 2) you seem a bit confused about type classes, I’d read up a bit before starting using them
01:12:55 <bitonic> @where LYAH -- jamy: for example here
01:12:55 <lambdabot> http://www.learnyouahaskell.com/
01:15:36 <jamy> bitonic: http://hpaste.org/85583#a85585 this not work also
01:15:58 <bitonic> jamy: really?  what compiler are you using exactly?
01:16:10 <jamy> the same
01:16:22 <jamy> sorry
01:16:30 <jamy> hugs98
01:17:08 <bitonic> jamy: crap, I just tried, you’re right.  wait a second...
01:18:08 <aleator> Is there a '(a -> Bool) -> (a -> Maybe a)' in base somewhere?
01:18:22 <bitonic> jamy: this is interesting, Hugs can’t justify the Show instance for that big tuple.
01:18:36 <bitonic> I would tend to classify this as a bug
01:19:04 <Taneb> aleator, I don't think so
01:19:46 <bitonic> jamy: OK, Hugs doesn’t have a Show instance for 6-tuples.
01:20:12 <Twisol> that's a 7-tuple actually :D
01:20:25 <bitonic> well, whatever that is :P
01:20:42 <jamy> "deriving (Show) not needded at data definition?"
01:20:43 <bitonic> jamy: so either you define it manually, or you unpack that tuple and print the individual elements
01:20:56 <Taneb> :t \f -> liftM . const <*> guard . f
01:20:57 <lambdabot> MonadPlus m => (r -> Bool) -> r -> m r
01:21:11 <bitonic> jamy: ‘deriving’ doesn’t work either for the same reason
01:21:12 <Taneb> Hurrah for unreadable pointlessness!
01:21:31 <bitonic> jamy: btw, why Hugs?
01:21:32 <Taneb> :t \f a -> const a `liftM` guard (f a)
01:21:34 <lambdabot> MonadPlus m => (r -> Bool) -> r -> m r
01:21:47 <Taneb> aleator, that's how I would write it
01:21:59 <CindyLinz> :t Control.Monad.mfilter
01:22:00 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
01:22:18 <CindyLinz> a little different :|
01:22:31 <jamy> i learn core haskell in this time. And ghc contain many garbage, so i more confused
01:22:51 <jamy> *with him
01:22:52 <Taneb> :t \f a -> if f a then empty else pure a
01:22:53 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
01:23:12 <Taneb> :t if'
01:23:13 <lambdabot>     Not in scope: if'
01:23:14 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
01:23:19 <Taneb> :(
01:23:23 <bitonic> jamy: also, you can simply define ‘data Tree a = Empty | Node a (Tree a) (Tree a) (Tree a) (Tree a) (Tree a) (Tree a)’.
01:23:36 <bitonic> jamy: if you don’t enable extensions you more or less have ‘core Haskell’ with GHC.
01:24:43 <bitonic> also for what concerns ‘learning Haskell’ I’d really recommend reading—either LYAH or ‘Programming in Haskell’
01:25:49 <Twisol> What would be some good intermediate-level Haskell resources? Like, post-LYAH and RWH.
01:26:06 <bitonic> Twisol: doesn’t exist
01:26:16 <merijn> Twisol: It kinda depends what you want to learn
01:26:22 <bitonic> there are scattered resources about some stuff
01:26:26 <nh2> there is post-RWH? that's quite specific then
01:26:28 <quchen> Does Aeson have a prettyprinting cousin, or should I use something else there?
01:26:29 <merijn> bitonic: Well, I'd say there's plenty of them, but rather goal oriented
01:26:31 <bitonic> but not an organic ‘advanced Haskell’ book
01:26:52 <bitonic> Twisol: this channel is probably the best resource :)
01:26:57 <merijn> Twisol: Wanna learn more theory? More libraries/practical stuff? A mix of both?
01:27:01 <Twisol> bitonic: Yep, that's why I lurk. :)
01:27:30 <Twisol> merijn: Theory I think. I don't get to program much in Haskell, but it's really valuable to take inspiration from it for other projects.
01:27:35 <bitonic> Twisol: it’s also a great indexer of scattered resources, so if you want to learn about something more specific we’ll probably have suggestions about what to read
01:27:35 <merijn> Twisol: For example, if you already feel comfortable with all the stuff from RWH take a look at edwardk's lens talk?
01:27:57 <merijn> @where lens
01:27:58 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
01:27:59 <bitonic> Twisol: if it’s theory you’re in I think the important book is TaPL
01:28:36 <bitonic> @where TaPL -- Twisol: this
01:28:36 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
01:28:52 <Twisol> That looks really interesting. Thanks!
01:29:00 <merijn> Twisol: That youtube link is good if you follow the derivations by hand
01:29:12 <nh2> yesterday I was complaining about cabal and the module system. Today I'm doing javascript ...
01:29:13 <merijn> It'll also keep you busy for a while ;)
01:29:16 <bitonic> that’s on the ‘types’ side of theory
01:29:26 <aleator> Taneb: Its simple to make, but I was hoping that it already had a name
01:29:32 <Twisol> merijn: I've been meaning to figure out the lens stuff, so that'll be helpful. Much obliged!
01:31:04 <neurocyte> adnap, ghc should work fine on arm, what problems are you having?
01:31:59 <merijn> Twisol: I tend to recommend looking at Data.Lens first, as it's really simple and easy to figure out type wise and then move on to lens (Control.Lens) since it's much more general and is slowly creeping over and into all haskell code ;)
01:32:12 <jamy> bionic: you propose me to use parametrize constructor with seven arguments instead of constructor with one cortege?
01:32:18 <Twisol> This is probably the kind of book I'd rather have hardcover than on my Kindle, right?
01:33:39 <bitonic> jamy: tha’ts right
01:33:42 <bitonic> *that’s right
01:33:49 <bitonic> although I wouldn’t use the term ‘parametrise’
01:33:57 <merijn> Twisol: Well, it'll make you look really distinguished if you put it in your office/room in between SICP and TAoCP ;)
01:34:02 <bitonic> but yeah I’d give ‘Node’ seven arguments
01:34:42 <bitonic> Twisol: I wouldn’t buy a book like that.  if you’re close to a technical university library it most certainly has it
01:35:22 <bitonic> but yeah I don’t know if they managed to squeeze it on a kindle.  it’s pretty big
01:35:31 <bitonic> like, pages are big.  with lots of derivations and stuff
01:35:34 <Twisol> bitonic: They do list a kindle version, hehe.
01:35:40 <merijn> Shoulda bought a 10 inch kindle DX like me :p
01:35:45 <jesyspa> I've got a two-parameter class C.  I'd like to make instances Foldable f => C (f a) b and Functor f => C a (f b), but that makes the instance choice ambiguous; however, I know taking either path should give the same result.  Can I somehow force GHC to "just choose one already"?
01:36:05 <Twisol> I had to get one book for a class this semester, and some parts of the pages don't seem to fit on the screen. So yeah, tech books seem to work better in paper.
01:36:39 <merijn> I actually got the DX specifically to be able to fit research papers in A4 on it in a readable way
01:36:50 <bitonic> jesyspa: UndecidableInstances and stuff
01:37:41 <jamy> bitonic: and how i can get subtreeses in this case?
01:37:57 <bitonic> jesyspa: actually you shouldn’t need UndecidableInstances for that.  simply FlexibleInstances
01:38:13 <bitonic> jamy: pattern matching
01:38:17 <jesyspa> Hm, I've already got Flexible... Let's see if I can make a testcase.
01:38:48 <hpaste> bitonic pasted “claaaasses” at http://hpaste.org/85587
01:40:27 <Twisol> merijn: Yeah, it doesn't look like my college has the book.
01:41:08 <Twisol> er, *bitonic I mean
01:41:32 <bitonic> Twisol: stage a protest
01:41:37 <Twisol> Haha.
01:42:01 <Hannibal_Smith> Hi
01:42:12 <bitonic> Twisol: on the lines of <http://www.cs.dartmouth.edu/~sergey/langsec/occupy/>
01:42:20 <Hannibal_Smith> Is it possibile debug an Haskell package?
01:42:45 <bitonic> Hannibal_Smith: what do you mean?
01:42:55 <bitonic> @faq can Haskell be debugged?
01:42:55 <lambdabot> The answer is: Yes! Haskell can do that.
01:43:13 <Hannibal_Smith> Ghci can step only in interpreted code
01:43:27 <Twisol> bitonic: Brilliant, I love it. ;)
01:43:28 <Hannibal_Smith> Not in compiled one (packages installed with cabal)
01:44:21 <jesyspa> bitonic: I'm running into this: http://liveworkspace.org/code/2Ulcch$0
01:45:03 <bitonic> Hannibal_Smith: right, that is a problem if you want to use GHCi debugging facilities
01:45:08 <Hannibal_Smith> http://osdir.com/ml/lang.haskell.glasgow.user/2008-02/msg00126.html <-
01:45:30 <Hannibal_Smith> Is it valid today?
01:45:38 <bitonic> Hannibal_Smith: <http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#setting-breakpoints>
01:45:46 <bitonic> actually <http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html>
01:45:50 <bitonic> right at the top of the page
01:46:24 <Hannibal_Smith> bitonic, the problem is, that I have to set an breakpoint inside my module
01:46:39 <jamy> bitonic: like this http://hpaste.org/85588#85588 ?
01:47:01 <Hannibal_Smith> And than set into an function that it's inside an module installed with cabal
01:47:09 <bitonic> Hannibal_Smith: yeah, you can’t do that.
01:47:39 <Hannibal_Smith> Uhm...
01:48:15 <bitonic> Hannibal_Smith: maybe if you describe the actual problem you’re having we can help you
01:49:09 <bitonic> there’s also the option of dumping the source of the package as that mailing list post hints.  but that’s kinda ugly.
01:53:00 <merijn> Twisol: btw, a shorter/quicker read if you want to get into theory
01:53:28 <merijn> Twisol: Graham Hutton's "A Tutorial on the Universality and Expressiveness of Fold" is a really nice one, I think
01:53:47 <bitonic> merijn: that’s not really about type theory, iirc
01:54:17 <merijn> bitonic: I said theory, not type theory :)
01:54:21 <bitonic> oh OK :)
01:54:32 <merijn> Fun with Type Functions is also a neat paper
01:55:01 <bitonic> yeah the important theory related to Haskell is 1) type theory 2) algebra of types 3) domain theory.  some say category theory too :)
01:55:19 <Twisol> Awesome. I like papers like these; I read the draft recently of generalized stream bundles, that was really interesting.
01:55:34 <Twisol> Though I suspect the fold one will be more immediately approachable.
01:55:55 <merijn> I think both are rather approachable
01:56:19 <Twisol> I mean in relation to the generalized stream bundles paper.
01:56:25 <merijn> Ah, maybe
01:56:29 <merijn> I don't know that one
01:56:41 <merijn> Generalizing Monads to Arrows was also really readable and interesting
01:56:51 <Twisol> I saw it linked from Reddit, apparently in preparation for an upcoming convention or something.
01:57:07 <merijn> Or, rather the first half is really readable, the second half less so. But the first half is worth reading even if you don't finish the entire thing
01:58:37 <Twisol> It's a good thing I'm in spring break right now. You guys gave me a lot to look into. :D
02:02:51 <danr> any ideas how to write this in a functional style? http://hpaste.org/85589
02:05:15 <Hannibal_Smith> Filter the list than map a function
02:06:18 <shachaf> danr: Can you give an example of using this?
02:08:05 <danr> shachaf: I have a stepping function for a simulation of bouncing balls :) To check for collisions, I check if the stepped versions of the balls collide, if they do, I change the original balls' velocity. Then I can step without getting collisions
02:08:49 <danr> so the a in this function will be a pair of balls (the same ball, but viewed at different times)
02:09:35 <danr> Hannibal_Smith: the filtering isn't really the important thing here. What I cannot see is how to write this with a map (or a fold) (without using !!)
02:09:59 <shachaf> I meant a more concrete example, as in how it behaves with some simple function.
02:10:16 <danr> shachaf: hang on
02:16:52 <arkeet> danr: I have no idea what you're doing, but are you sure you want to apply f for both pairs (i,j) and (j,i)?
02:17:02 <arkeet> instead of, say, just (i,j) for i < j
02:17:08 <MasseR> danr: I might be completely out of loop but you could probably do something like [f a b | a <- balls, b <- balls]
02:17:17 <arkeet> MasseR: nope, that even has the wrong type.
02:17:36 <MasseR> arkeet: And then folding
02:17:37 <danr> shachaf: I cannot find some simple nice understandable example =/
02:17:40 <arkeet> MasseR: nope
02:17:42 <MasseR> :<
02:17:51 <arkeet> danr: if we restrict to the pairs (i,j) where i < j, then I can imagine there being a recursive solution.
02:17:53 <danr> MasseR: well I get the cartesian product of them if I do that
02:18:08 <danr> arkeet: good point, i < j is actually what I want
02:18:10 <shachaf> You can get a cartesian product of a list with itself minus the diagonal pretty easily.
02:18:19 <shachaf> Oh. In that case.
02:18:25 <danr> arkeet: it starts to smell inits (or tails)
02:18:45 <arkeet> like you can do it for i = 1 and j = 2..n
02:18:48 <arkeet> and then recurse into the tail
02:19:40 <quchen> I've got a Text object, and would like to feed it to a function that needs lazy bytestrings. However, Data.Text.Encoding seems to encode to strict ByteStrings only. Am I overlooking something, or will I have to convert the two ByteStrings into each other?
02:20:02 <shachaf> I imagine it encodes strict Text to strict ByteString and similarly for lazy.
02:20:09 <arkeet> :t foldl
02:20:11 <lambdabot> (a -> b -> a) -> a -> [b] -> a
02:20:46 <supki> quchen: Data.Text.Lazy.Encoding?
02:20:46 <arkeet> :t scanl
02:20:48 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
02:20:50 <shachaf> Anyway a lazy ByteString is a lazy list of strict ByteStrings
02:20:57 <quchen> shachaf, supki: Oooh, there's lazy text! Wow. :-) Thanks
02:21:19 <danr> arkeet: it's a bit tricky because I want to update the tail as well
02:22:11 <arkeet> I know.
02:22:15 <arkeet> a simple fold should do the trick, though.
02:23:01 <danr> arkeet: thanks I think I almost have it now
02:23:30 <arkeet> no I want to do this. :P
02:28:19 <danr> arkeet: ok :) I updated my paste with my solution (it uses explicit recursion)
02:28:24 <danr> but thanks a lot!
02:28:27 <arkeet> @ty let blah f [] = []; blah f (x:xs) = let (x',g') = foldl' (\(y,h) z -> let (y',z') = f y z in (y', h . (z':))) (x,id) xs in x' : blah f (g' []) in blah
02:28:28 <lambdabot> (a -> a -> (a, a)) -> [a] -> [a]
02:28:40 <arkeet> @let blah f [] = []; blah f (x:xs) = let (x',g') = foldl' (\(y,h) z -> let (y',z') = f y z in (y', h . (z':))) (x,id) xs in x' : blah f (g' [])
02:28:42 <lambdabot>  Defined.
02:28:57 <arkeet> > blah (\a b -> (min a b, max a b)) [5,3,2,6,1]
02:29:00 <lambdabot>   [1,2,3,5,6]
02:29:09 <arkeet> well, at least it works.
02:29:18 <danr> ah, clever, bubble sort, of course!
02:29:30 <arkeet> actually it's insertion sort.
02:31:55 <danr> > blah (\ a b -> if a > b then (b,a) else (a,b)) [5,3,2,6,1] -- looks like bubble sort to me
02:31:57 <lambdabot>   [1,2,3,5,6]
02:33:16 <arkeet> no, bubble sort only swaps adjacent pairs.
02:33:58 <arkeet> this swaps stuff with the head until the head is smallest, and then recurses into the tail.
02:34:04 <arkeet> that's insertion sort.
02:34:25 <arkeet> well, almost. insertion sort is supposed to find the minimum and then swap once with the head.
02:34:55 <danr> arkeet: ok, you're right. but isn't the last one you're writing about called selection sort (the one that finds the minimum)
02:35:14 <arkeet> oh, never mind.
02:35:52 <arkeet> I meant selection sort, not insertion sort.
02:38:06 <hpaste> danr annotated “Functional style?” with “Functional style? (annotation) (annotation) (annotation)” at http://hpaste.org/85589#a85592
02:40:16 <arkeet> ok, so yours uses a right fold instead.
02:40:50 <arkeet> which I thought should be possible.
02:40:51 <arkeet> so yeah.
02:43:51 <killy9999> I'm trying to bootstrap cabal-install and I get this error: /usr/bin/ld: cannot find -lgmp
02:43:58 <killy9999> Any ideas?
02:44:07 <Botje> did you install libgmp-dev?
02:44:14 <killy9999> mah
02:44:20 <killy9999> nope, only libgmp
02:44:33 <killy9999> didn't thought I'll also need dev version
02:44:49 <killy9999> great, gotta mail the admin
02:49:32 <jamy> bitonic: like this http://hpaste.org/85588#85588 ?
02:54:17 <shachaf> What is Levent Erkok's nick around here?
02:55:22 <shachaf> I guess it's "levent".
03:42:27 <neothemachine> hi, is there an easy way to do conditional compilation to enable/disable debug output, e.g. by using a cabal flag?
03:44:56 <alpounet> a cabal flag that triggers a #define through the -D option to ghc, and then use that in the code to optionally have debug printing statements, with #ifdef and friends, using the {-# LANGUAGE CPP #-} extension
03:45:55 <neothemachine> ok so I have to include that -D option block for every artifact, like library and executables, rigth?
03:46:49 <alpounet> yes neothemachine, I think this is necessary -- at least, I'm not aware of a solution for writing this only once
03:47:13 <neothemachine> well, ok, then I'll just do that, thanks!
04:17:43 <neutrino_> hi
04:17:47 <neutrino_> has anyone here used atom?
04:36:56 <kuribas> Is there a function to sum over a list of lists?
04:37:08 <companion_cube> :t sum . concat
04:37:09 <lambdabot> Num c => [[c]] -> c
04:37:15 <kuribas> Like zipWith (+) but with more lists.
04:37:24 <companion_cube> sum . concat $ [[1,2],[3,4]]
04:37:25 <jesyspa> Or sum . sum
04:37:32 <companion_cube> hmm, right
04:37:37 <jesyspa> Err, no, sum . map sum
04:37:45 <kuribas> Yes, but returning a list.
04:37:47 <companion_cube> > sum . concat $ [[1,2],[3,4]]
04:37:49 <lambdabot>   10
04:37:52 <mauke> :t map sum . transpose
04:37:54 <lambdabot> Num b => [[b]] -> [b]
04:37:59 <companion_cube> :t zipWith sum
04:38:00 <lambdabot> Num c => [[b -> c]] -> [b] -> [c]
04:38:08 <companion_cube> hmm, not
04:38:12 <mauke> > map sum . transpose $ [[1,2],[3,4]]
04:38:14 <lambdabot>   [4,6]
04:38:22 <kuribas> Ah, that's it! thanks.
04:43:33 <merijn> edwardk: Ooooh...fighting words from dons ;)
04:43:35 <merijn> edwardk: "fclabels: simple, elegant lenses - and the basis of our 300k loc trading platform."
04:43:39 <merijn> Who needs more in a lens library?
04:43:57 <Taneb> "loc"?
04:44:05 <merijn> Taneb: Lines of Code
04:44:32 <merijn> see also sloc (source lines of code, i.e. not counting comments and whitespace)
04:45:40 <luite> merijn: of course it would be 10k loc with lens ;)
04:48:35 <Taneb> merijn, where was the boast written?
04:50:27 <merijn> Taneb: Twitter
04:50:45 <Taneb> Username?
04:50:56 <merijn> Well, the "Who needs more in a lens library?" part was also part of that tweet, hence my "fighting words" remark ;)
04:51:03 <Botje> @donsbot
04:51:04 <lambdabot> Unknown command, try @list
04:52:02 <merijn> https://twitter.com/donsbot/status/322292036600475648
04:52:06 <Taneb> Botje, took me way too long to realise you were telling me his username
04:55:09 <Taneb> fclabel's a :-> b eventually decomposes to (a -> b, (b, a) -> a)
04:55:35 <Taneb> Which is in a data which is in a newtype which is hidden behind two types
04:55:57 <merijn> Which means it doesn't support polymorphic update
04:57:01 <Heffalump>  what does polymorphic update mean, changing a type parameter in the update?
04:57:17 <Taneb> > (3, 4) & _2 .~ "hello"
04:57:19 <lambdabot>   (3,"hello")
04:57:28 <Taneb> Pretty much
04:57:37 <Taneb> > "hello" & mapped %~ ord
04:57:39 <lambdabot>   [104,101,108,108,111]
04:58:00 <Heffalump> > map ord "hello"
04:58:02 <lambdabot>   [104,101,108,108,111]
04:58:02 <__xc> out of curiosity: haskell is a good fit for neural networks right?
04:58:02 <Heffalump> :-)
04:58:22 <Heffalump> @type (\x -> x & mapped %~ ord)
04:58:24 <lambdabot> Functor f => f Char -> f Int
04:58:47 <Heffalump> @type (\f x -> x & mapped %~ f, fmap)
04:58:48 <Taneb> Yeah, in actual code, never say "mapped %~"
04:58:48 <lambdabot> (Functor f1, Functor f) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
04:58:58 <alpounet> __xc, it's a general purpose programming language so yeah. i'm the author of a neural nets lib by the way
04:58:59 <Taneb> It is "fmap", pure and simple
04:59:25 <Taneb> I'd imagine Haskell is a lot better for neural networks than something like C
04:59:56 <alpounet> Taneb, well, elegance wise yes, performance wise some difference still persists
05:02:39 <merijn> Seems like you'd simulate the connections using a matrix, so it'd more depend on the efficiency of your matrix library?
05:03:04 <merijn> Although, if alpounet says they're actually implemented completely differently I yield to his expertise :p
05:03:14 <Taneb> (I know barely anything about neural networks)
05:03:54 <alpounet> merijn, for feedforward neural nets yeah you usually store the weights as matrices :)
05:04:12 <alpounet> and usually the neural nets libraries use hmatrix
05:04:44 <alpounet> i'll bug Alberto Ruiz to check that hmatrix benefits from the simd-friendly additions to ghc/vector
05:04:59 <merijn> \o/
05:05:01 <merijn> i r smrt
05:05:02 <__xc> alpounet okl, I was reading a bit on them, particularly for time series, like (chaotic) forex ones, do your lib makes use of STM?
05:05:41 <__xc> or it's a core single algorithm
05:05:47 <merijn> I suspect not, STM isn't very efficient for numerically intensive code, afaik
05:05:59 <__xc> ok
05:06:02 <merijn> __xc: You're ruling out "plain old concurrent code without STM" :)
05:06:32 <alpounet> __xc, nope, it's a single algorithm -- i'm planning on, at some point, having a multicore-friendly version, and maybe even a gpgpu friendly one. but i'm not there yet
05:06:43 <__xc> I was thinking of the agent model, where concurrency can be used
05:07:41 <alpounet> mm_freak, also authored a neural nets lib I think, 'instinct'
05:07:50 <alpounet> there's HaskellNN too
05:07:59 <alpounet> and mine is hnn: http://github.com/alpmestan/hnn
05:08:47 <__xc> thanks, I still reading the very basics first
05:33:16 <__xc> so you mean you lib use a matrix for connections (what if you want to add/rem one?), this contrasts with the way they present it here http://www.trapexit.org/Erlang_and_Neural_Networks
05:33:37 <__xc> (sorry if it's erlang)
05:58:34 <someoneelse> is there a typeclass i can derive from that's smaller than Num? for example, i only want (+)
05:58:52 <Taneb> Monoid, perhaps
05:59:06 <Taneb> Monoid has mappend :: a -> a -> a, and mempty :: a
05:59:08 <_mr> Semigroup ;-)
05:59:12 <Taneb> Which can be (+) and 0
05:59:23 <Philonous> __xc:  You seem to imply that an algorithm has to be either concurrent or "single core". GHC actually has parallel primitives (See Control.Parallel.par) and supports nested data parallelism.
06:00:03 <someoneelse> okay, i'll be honest, i need an abelian group =)
06:01:22 <someoneelse> Taneb, i wouldn't be able to use (+) then, would i?
06:02:42 <Philonous> someoneelse:  Not necessarily. import Prelude hiding ((+)); (+) = mappend
06:03:14 <Taneb> someoneelse, no
06:03:47 <Taneb> Monoid is an abelian group where you don't care about commutativity or inverses
06:04:41 <theDon> that's just wrong. an abelian group is a monoid where you care about commutativity and inverses. :P
06:04:47 <mauke> cheeseburger without cheese
06:07:29 <someoneelse> Philonous, Taneb hmm, this is getting a bit more complicated than i like. i'm trying to implement a simple Vec3 type, but it seems i'm better off using a new operator for its addition?
06:07:44 <someoneelse> Philonous, not having the regular + from Prelude is no fun =(
06:07:51 <Taneb> Or Data.Monoid.mappend
06:12:12 <Philonous> someoneelse:  I'm just wondering, how do you want to turn Vec3 into a group?
06:12:54 <ab9rf> dammit
06:12:58 <ab9rf> now i want a cheeseburger
06:13:07 <someoneelse> Philonous, vector addition?
06:13:16 <ion> vector addiction
06:13:52 <Philonous> someoneelse:  Never mind, I'm being stupid. I read "field" instead of "group". Carry on.
06:14:17 <someoneelse> Philonous, well, that'd be quite a feat. but if i understand that correctly, at least i could use Num then =)
06:15:08 <someoneelse> i officially have a few hours of haskell experience now, but i still can't seem to find a decent way to implement 3 and 4 dimensional vectors in a single module thus far.
06:15:43 <someoneelse> i don't want arbitrary length vectors (because i think they're.. slower? correct me if i'm wrong) and i don't want 2 new operators, one for 3d vector addition and one for 4d
06:16:03 <ab9rf> hm, i don't think you can have it both ways
06:16:05 <someoneelse> i don't want to make vec3 an instance of num, because signum v is just silly
06:16:33 <ab9rf> if you want overloaded operators that work on both 3d and 4d, you'll have to make both instances of a common class
06:16:50 <merijn> someoneelse: You could define your own vector typeclass with the operators you want and make it work for those 3 or 4 vector types you want
06:16:52 <arkeet> I think one could reasonably make signum v be the unit vector in the direction of v.
06:16:55 <arkeet> the problem is what abs v should be.
06:17:12 <Philonous> someoneelse:  You can just leave signum etc. undefined.
06:17:14 <ab9rf> arkeet: normally the "magnitude" of the vector
06:17:23 <someoneelse> Philonous, won't that break num?
06:17:34 <ab9rf> arkeet: signum v * abs v = v, supposedly
06:17:35 <someoneelse> ab9rf, Num says it must be Vec3 -> Vec3
06:17:44 <merijn> someoneelse: It'll break the code of people using it
06:17:47 <ab9rf> someoneelse: ah, then not definable.
06:17:47 <arkeet> ab9rf: yes. except the "magnitude" doesn't make sense as a Vec3
06:17:52 <ab9rf> arkeet: agreed.
06:18:13 <ab9rf> arkeet: we didn't define abs as (Num a, Num b) => a -> b :)
06:18:14 <Philonous> someoneelse:  It's not pretty, but if you want to use (+) it can be defended.
06:18:15 <someoneelse> merijn, what would break the code?
06:18:26 <arkeet> which is why you should use Data.VectorSpace or so, I think.
06:18:34 <arkeet> well, vector-space.
06:18:43 <merijn> someoneelse: well, leaving them undefined will work, it's just if someone then calls those functions on your types the code will crash
06:18:53 <Philonous> someoneelse:  Someone trying to use abs on your vectors will get an error.
06:19:06 <someoneelse> well, for one, there won't be anyone else using my code
06:19:16 <ab9rf> that's what everyone always says :)
06:19:22 <arkeet> I think you should forget about giving them a Num instance and use vector-space instead.
06:19:29 <ab9rf> i agree with arkeet
06:19:32 <merijn> someoneelse: But tbh, I don't think defining your own typeclass would be really problematic, though
06:19:33 <ab9rf> don't try to jam the abstraction
06:19:40 <someoneelse> okay, Num is out
06:20:04 <someoneelse> i don't want to use vector-space just yet, mainly because i have enough to grok with standard stuff
06:20:17 <someoneelse> so i add a typeclass for <+>
06:20:23 <someoneelse> and use that?
06:20:29 <someoneelse> i assume <+>'s not taken yet? =)
06:20:34 * hackagebot bed-and-breakfast 0.3 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.3 (JulianFleischer)
06:20:45 <arkeet> sure, vector-space calls that ^+^ thouh.
06:21:05 <someoneelse> arkeet, that's a bit disturbing for people used to reading ^^-type emoticons :P
06:21:14 <arkeet> mnemonic: a ^ on one side of the operator means that side takes a vector, as opposed to a scalar.
06:21:20 <arkeet> so you have *^ for scalar-vector multiplication, et.
06:21:21 <arkeet> c
06:21:54 <someoneelse> arkeet, that's a pretty cool idea though
06:22:13 <arkeet> mainly the point is to make a type-level distinction between vectors and scalars.
06:22:13 <merijn> someoneelse: Yeah, you'd do "class MyVector a where (<+>) :: a -> a -> a; magnitude :: Num b => a -> b", etc.
06:22:42 <arkeet> sure. and then you're half way there to vector-space. ok I'll shut up now.
06:23:02 <someoneelse> arkeet, it's purely educational
06:23:19 <merijn> arkeet: Well, for learning experience writing your own typeclass to play with can't hurt if you've never done that
06:23:20 <someoneelse> arkeet, otherwise i'd use whatever's there already, no worries
06:23:29 <arkeet> fair enough :)
06:23:35 <Philonous> class MyVector s v | v -> s where ...
06:23:42 <someoneelse> okay, i'll give that a shot
06:23:53 <arkeet> I suppose edwardk would tell you to use his linear package, instead.
06:24:00 <ab9rf> i'd expect <+> to have something to do with applicatives
06:24:08 <merijn> ab9rf: True
06:24:20 <ab9rf> because of <|> and <*>
06:24:26 <__xc> Philonous ok, will look in current implementations how are aggregated the results of each 'node' neurons
06:24:28 <ab9rf> not sure what, but there you have it
06:24:33 <arkeet> you could think of it as a lifted +.
06:24:47 <arkeet> and it really is liftA2 (+), for an appropriate Applicative instance.
06:24:54 <edwardk> arkeet: that is exactly how linear used to implement it before i added sparse support
06:24:55 <ab9rf> arkeet: true enough
06:25:02 <arkeet> well then
06:25:21 <arkeet> edwardk: sparse stuff isn't applicative anymore?
06:25:51 <ab9rf> i'm still waiting for an except to have =^.^=
06:25:54 <ab9rf> er excuse
06:27:26 <Philonous> someoneelse:  personally I'd go with prefix names, e.g. vPlus and sMul.
06:27:51 <edwardk> arkeet: the Apply instance for Map doesn't do the right thing, so we have 'Additive' in linear
06:28:11 <arkeet> hmm, it doesn't?
06:28:31 <edwardk> arkeet: then you can implement a sparse vector as just an IntMap, and a sparse by dense matrix using IntMap (V3 Double) etc
06:28:35 <edwardk> nope.
06:28:37 <edwardk> add them
06:28:48 <someoneelse> Philonous, i'll try both sooner or later, i guess
06:28:55 <edwardk> you need unionWith (+) not liftF2 (+)
06:29:02 <arkeet> right.
06:29:07 <someoneelse> Philonous, isn't MyVector s v a multiparamtypeclass?
06:29:13 <edwardk> but multiplying them you want the sparse behavior
06:29:16 <merijn> someoneelse: It is
06:29:17 <arkeet> right yeah, that's obvious now.
06:29:36 <edwardk> er i mean multiplying them you want the intersection behavior
06:29:48 <someoneelse> ghci doesn't like those =(
06:29:57 <merijn> someoneelse: Oh? Why not?
06:29:58 <Philonous> someoneelse:  Yes, you need to say what which field underlies your vectors
06:30:34 <Philonous> someoneelse:  :seti -XMultiParamTypeClasses
06:30:44 <someoneelse> merijn, i cite: "Use -XMultiParamTypeClasses to allow multi-parameter classes" -- apparently, it's not a standard feature.
06:31:00 <merijn> someoneelse: ghci uses the same extensions as GHC
06:31:14 <Philonous> someoneelse:  Or rather, add {-# LANGUAGE MultiParamTypeClasses #-} to the top of your file
06:31:32 <someoneelse> yeah, but can i maybe get around that? i don't need full f-v vector spaces, the f is fixed
06:31:46 <merijn> someoneelse: Yeah, MPTC are an extension, but not many people really care about portability beyond GHC
06:31:48 <someoneelse> (as in the outer scalar is the same as the one inside the vector)
06:31:55 <Philonous> someoneelse:  Then just leave out the s "class MyVector v where" ...
06:33:10 <someoneelse> Philonous, that works for addition, but i do need to add a product for FxV, which would be of type s -> v -> v , if i'm not mistaken
06:33:57 <Philonous> someoneelse:  You'll just have to fix a type. vMul :: Double -> v -> v
06:34:34 <arkeet> or you could have s as another parameter to the class and use fundeps,
06:34:40 <merijn> someoneelse: Personally I'd just enable MPTC and be done with it, but I guess that's personal preference
06:34:42 <arkeet> or use an associated type (this is what vector-space does)
06:34:53 <Philonous> arkeet:  That's what I suggested earlier
06:35:06 <someoneelse> okay, MultiParamTypeClasses it is
06:35:16 <arkeet> it's probably a good way to get comfortable with MPTCs and fundeps.
06:35:40 <Philonous> someoneelse:  Actually, you probably want "Data Vec3 a = Vec3 a a a" and "class MyVector v where sMul :: s -> v s -> v s
06:36:15 <arkeet> or that.
06:36:32 <arkeet> but that forces you to have a type constructor, so you can't do vector stuff on say (Double,Double,Double)
06:36:45 <someoneelse> i'm okay with type constructors
06:36:47 <merijn> Did you just capitalise the first letter of a language keyword? Heresy!
06:37:33 <someoneelse> Philonous, thanks, the s -> v s -> v s was exactly what i missed
06:38:21 <arkeet> that is the approach the linear package takes.
06:41:08 <someoneelse> Philonous, though it does tell me that "`v' is applied to too many type arguments" in class Vector v where   sMul :: s -> v s -> v s
06:42:00 <arkeet> someoneelse: you probably wrote an instance for like Vec3 Double, not just Vec3.
06:43:01 <someoneelse> arkeet, the issue seems to be vAdd :: v -> v -> v
06:43:11 <someoneelse> arkeet, ah, i get it, thanks
06:43:14 <arkeet> well, you better change that to v s -> v s -> v s.
06:46:23 <merijn> someoneelse: having v -> v -> v in that class would be like having a "Maybe -> Int" function (which is of course nonsense, since the Maybe needs an argument :)
06:47:47 <someoneelse> merijn, yeah, that made sense, but now i'm having trouble creating the instance, because instance Vector Vec3 works, but i need to do something like instance Num a => Vector (Vec3 a)
06:48:27 <arkeet> or you put the constraint on the methods.
06:48:32 <arkeet> vAdd :: Num s => v s -> v s -> v s
06:48:36 <someoneelse> ah, i see
06:48:39 <arkeet> or you use a MPTC.
06:48:57 <arkeet> then you can put the constraint on the instance.
06:49:26 <arkeet> I'd prefer the latter.
06:49:39 <arkeet> class Vector v s | v -> s where ...
06:49:49 <arkeet> instance Num a => Vector (Vec3 a) a where ...
06:50:05 <arkeet> so sMul :: s -> v -> v, and so on.
06:50:17 <someoneelse> arkeet, thanks!
06:50:39 <arkeet> you'll need to turn on a couple of extensions to do this.
06:51:33 <Philonous> You could put the Num constraint on the data type. data Num a => Vec3 a = Vec3 a a a.
06:51:59 <merijn> Philonous: No
06:52:04 <mauke> Philonous: is that still legal?
06:52:13 <merijn> Then he'd *still* need it on the function or the typeclass
06:52:23 <merijn> mauke: Deprected in haskell2010
06:52:29 <merijn> ghc still supports it
06:52:29 <mauke> merijn: but not removed?
06:52:29 <Philonous> merijn:  Ah, right.
06:52:37 <Philonous> merijn:  I never do that.
06:52:40 <merijn> mauke: Nope, unfortunately
06:52:57 <merijn> Philonous: And now you know the reason why you don't ;)
06:53:13 <Philonous> merijn:  Yeah, it's pretty useless, then.
06:53:31 <merijn> someoneelse: I'd put the Num s constraint on the functions, seems simplest if you want to avoid the extensions you just avoided defining this class :)
06:53:54 <Sculptor> hello
06:58:52 <someoneelse> woa, hpaste is smarter than i am =(
07:00:58 <dmwit> ;quit
07:04:42 <no-n[6]> what's the simplest way to get a random int withing a given range?
07:05:01 <merijn> randomR or something wasn't it?
07:05:13 <merijn> @hoogle Random a => (a, a) -> a
07:05:14 <ab9rf> there's a whole passel of randomizers, iirc
07:05:14 <lambdabot> Test.QuickCheck.Gen choose :: Random a => (a, a) -> Gen a
07:05:14 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
07:05:14 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
07:05:21 <Taneb> :t randomRIO
07:05:22 <lambdabot> Random a => (a, a) -> IO a
07:05:34 <Taneb> or randomR if you already have a generator
07:05:39 <merijn> :t randomR
07:05:41 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:07:02 <no-n[6]> D:
07:08:39 <ab9rf> using the RandomGen based ones avoids the dependence on IO (but you have the generator to fiddle with instead)
07:19:21 <Taneb> I think I need to change family-tree so that one person can't be the child of two sets of parents
07:20:12 <tdammers> families are complicated as it is, and genetic engineering isn't exactly helping
07:20:56 <merijn> Taneb: Oh? Adopted children + adoptive parent + natural parents?
07:21:24 <Taneb> merijn, I said "can't"
07:21:28 <Taneb> At the moment they can
07:23:05 <Taneb> Okay, just thought of another alternative
07:23:19 <Taneb> Attaching some kind of "type of child/parent relationship" to it
07:23:29 <Taneb> eg, Natural-born, Adopted, etc
07:23:55 <tdammers> smells like over-engineering
07:23:56 <merijn> Taneb: Be warned, I remember a blogpost from a guy developing family tree software. He had asserts that prevented cycles
07:24:09 <Taneb> merijn, I saw
07:24:12 <merijn> He received multiple bug reports from people who crashed the program due to those asserts :)
07:24:33 <Taneb> At the moment, it's perfectly legal in family-tree for someone to be his own father
07:24:57 <tdammers> then it's future proof! time travel!
07:24:59 <Taneb> Or even his parent's father
07:25:08 <Taneb> So I think I'm safe from that problem
07:25:31 <Taneb> The problem that I'm trying to address is that it's really inefficient to look up who a person's parents are
07:26:03 <Taneb> Because you have to scan through each family's children
07:26:29 <Taneb> And I think it ends up O (f * log c) where f is the number of families and c is the average number of children per family
07:27:33 <Taneb> When it could be possibly O(f)
07:28:36 <ab9rf> it's best not to make too many assumptions about family structures
07:29:16 <Taneb> There is one assumption I'm making, ab9rf, and that's that families have 0 or more children and up to 2 parents
07:29:29 <ab9rf> Taneb: up to?  some families have as many as seven.
07:29:39 <Taneb> ...really?
07:29:46 <Taneb> 7 parents!?
07:29:46 <ab9rf> never heard of polyamory?
07:29:53 <ab9rf> i have four parents, in some sense
07:29:59 <ab9rf> my mother, my father, my stepfather, and my stepmother
07:30:05 <Taneb> I'd count them as separate families
07:30:17 <ab9rf> what if they all live in the same house?
07:30:23 <Taneb> Even then.
07:30:28 <ab9rf> i have a friend who lives in a family unit with six adults and four kids
07:30:46 <ab9rf> the sexual relationships are complicated to explain (it's not a panmixia, but it's close)
07:30:47 <simpson> The only assumption you can make is that people are not in their own ancestry through blood; that is, blood lineage forms a DAG.
07:30:56 <simpson> Or at least that's what I've been tol.d
07:31:03 * simpson can't type :T
07:31:03 <mauke> >implying
07:31:03 <ab9rf> some of the kids are related to some of the other kids by blood
07:31:12 <ab9rf> some are full sibs, some are half sibs, others are unrelated
07:31:22 <merijn> Taneb: Ha, sucker. Never should've attempted to model human relationships ;)
07:31:30 <Taneb> ab9rf, as long as each individual person has no more than two parents
07:31:45 <ab9rf> there's also multiple marriage in islam and separatist mormons
07:31:51 <ab9rf> jewish levirate marriage
07:31:56 <mauke> genetic, biological, social
07:32:00 <ab9rf> Taneb: what about surrogacy?
07:32:09 <Taneb> That's when I start screaming
07:32:10 <ab9rf> Taneb: children born by transmen
07:32:23 <Taneb> I don't make any assumption about the gender of the parents
07:32:32 <Taneb> I don't think I explicitly track gender at all
07:32:40 <merijn> mauke: Wait...how is genetic different from biological? sperm + egg from couple brought to term by a surrogate?
07:32:41 <ab9rf> children who are legally the child of a same-sex marriage of two women but where the genetic father is acknowledged and present in the relationship
07:33:10 <simpson> Clearly the ideal datatype here is Pipe. >:3
07:33:23 <Taneb> ab9rf, if you can think of a good, Haskell-y way to represent that
07:33:30 <Taneb> And every other possible relation
07:33:43 <mauke> merijn: yeah
07:33:43 <ab9rf> Taneb: about all you can do is prohibit someone from being their own genetic parent
07:33:44 <Taneb> I will transfer all ownership of family-tree to you
07:33:55 <ab9rf> for social/legal parent you can't make any retrictionss
07:34:06 <ab9rf> because those concepts are capable of infinite mutation
07:34:24 <ab9rf> the problem is that we don't track genetic parentage
07:34:35 <ab9rf> birth certificates record _legal_ parentage, not genetic parentage
07:34:58 <womendezuguo> join #kernelnewbies
07:35:08 <Taneb> This is going to be fun :(
07:35:26 <Cale> Just take DNA samples and arrange everyone into a reconstructed weighted phylogenetic tree.
07:35:38 <ab9rf> Taneb: geneaologists actually have ways to deal with this
07:35:41 <Cale> and if they don't like it, well, whatever
07:35:54 <ab9rf> but it's fairly complicated, and you have to allow the arbitrary addition of "ancestors"
07:35:59 <simpson> Taneb: It's only your job to provide the modelling capabilities; let geneologists do the actual digging.
07:36:02 <mauke> heh, git-style ancestry reconstruction
07:36:04 <ab9rf> Taneb: ever heard of a "royal cousin"?
07:36:24 <Taneb> ab9rf, I have not
07:36:40 <ab9rf> Taneb: it's someone who is declared by edict to be a "cousin" of the crown.  they become a member of the royal family, but with no identifiable lineage within the family
07:36:55 <Taneb> That, I shall choose to completely ignore
07:37:00 <ab9rf> Taneb: you can't
07:37:05 <Taneb> Watch me
07:37:14 <ab9rf> not atn meaningfully provide geneaological track
07:37:24 <ab9rf> such decrees are _very_ important to geneaologists
07:37:50 <fizbin> Huh. It's easy to write a Foldable instance for (Data.Graph.Inductive.Graph.Graph a).  I wonder if that's at all useful, since it'd just be folding over the edges.
07:37:51 <ab9rf> such a person, and all of their descendants, are nobility.
07:39:21 <ab9rf> different cultures have different definitions of family, of ancestry, of legitimacy.  if you wnt a general model, you have to be completely nonspecific and let the genealogist decide what the appropriate relations are.
07:40:13 <Taneb> If you can show me an open genealogy format that supports this, I will happily implement it
07:40:15 <ab9rf> it is possible to end up being your own grandparent
07:40:34 <ab9rf> although that would be seriously strange.
07:40:38 <simpson> Taneb: The popular formats are Mormon-created and as such don't support any, uh, "interesting" families.
07:40:40 <Philonous> ab9rf:  By adopting your father?
07:40:53 <fizbin> ab9rf: And then you get a novelty song.
07:40:58 <Taneb> (and family-tree does allow people to be their own grandparent)
07:41:16 <ab9rf> Philonous: in some places the consanguinity laws don't prohibit marriages where the female is over 50, or only prohibit one generation apart
07:41:25 <ab9rf> in those cases, you can (if you're male) marry your own grandmother
07:41:35 <Taneb> simpson, also GEDCOM is ridiculously complicated
07:42:13 <ab9rf> simpson: the mormons have some support for this because they track the lienages of european nobility, which are remarkably complicated at times
07:42:23 <fizbin> Philonous: In the song "I'm my own grandpa", the way it's done is by a young man marrying an older widow who already has a grown daughter, and then the man's father marries the widow's daughter.
07:42:31 <simpson> ab9rf: This is true.
07:42:56 <ab9rf> simpson: however, they tend to be fairly closemouthed about how to do that beause thy don't want to encourage misbehavior
07:43:12 <ab9rf> simpson: and there's the whole "no, really, we don't practice polygamy, really!" aspect to mormonism
07:43:18 <fizbin> Philonous: This then means that the young man providing the viewpoint for the song, the same woman is his step-mother and step-daughter.
07:43:24 <simpson> ab9rf: Yup.
07:45:23 <ab9rf> Taneb: human relationships are complicated.  go figure.
07:47:16 <fizbin> @hoogle (<|>)
07:47:16 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
07:47:16 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
07:47:16 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
07:47:49 <ab9rf> brr
07:48:30 <pascha> if i do int x = ~0; and int=32bit int is x =0xFFFFFFFF; then?
07:48:56 <ab9rf> :t (~)
07:48:58 <lambdabot> parse error on input `)'
07:49:00 <ab9rf> heh
07:49:02 <mauke> pascha: in what language?
07:49:09 <ab9rf> pascha: what language are you talking about?
07:50:00 <ion> Haskell obviously, for it’s #haskell.
07:50:19 <ab9rf> ion: there's no ~ operator in haskell, it's used for pattern matching
07:51:00 <ab9rf> :t complement
07:51:01 <lambdabot> Bits a => a -> a
07:51:11 <pascha> sorry wrong chan, was a C quesion
07:51:18 <ab9rf> > complement 0
07:51:20 <lambdabot>   -1
07:51:23 <typoclass> pascha: you can use Data.Bits for that
07:51:34 <mauke> > complement 0 :: Int32
07:51:34 <ion> > complement 0 :: Word32
07:51:36 <lambdabot>   -1
07:51:37 <lambdabot>   can't find file: L.hs
07:51:40 <ion> > complement 0 :: Word32
07:51:42 <lambdabot>   4294967295
07:51:42 <ab9rf> race!
07:53:56 <ion> > review (base 32) (complement 0 :: Word32)
07:53:58 <lambdabot>   "3vvvvvv"
07:54:00 <pascha> well C :)
07:54:06 <ion> > review (base 16) (complement 0 :: Word32)
07:54:08 <lambdabot>   "ffffffff"
07:55:04 <alexander__b> in my file I have data Shape = Circle Float Float Float | Rectangle Float Float Float Float
07:55:22 <ab9rf> rectangles float more than circles.
07:55:25 <alexander__b> following :r, should I not be able to do :t Rectangle?
07:55:38 <alexander__b> <interactive>:1:0: Not in scope: data constructor `Rectangle'
07:55:41 <circle> remember me
07:56:30 <mauke> alexander__b: what does your prompt say?
07:56:38 <alexander__b> mauke: ^
07:56:38 <ab9rf> alexander__b: sounds like your file did not load
07:56:49 <mauke> alexander__b: what does your prompt say?
07:57:01 <alexander__b> ohwaitomg
07:57:09 <alexander__b> I :r'd the wrong file
07:57:09 <ab9rf> does it say Prelude> or Prelude YourModule>
07:57:25 <ab9rf> (or something else)
07:57:26 <ab9rf> aha!
07:57:53 <alexander__b> my prompt is ' >' BTW, so that would not help much.
07:58:04 <ion> http://heh.fi/tmp/ghci-prompt
08:00:01 <mauke> zalgoprompt?
08:16:43 <hpaste> “Anonymous Coward” annotated “cabal install array” with “cabal install array (annotation)” at http://hpaste.org/78327#a85598
08:21:18 <johnw> Trustworthy is a GHC 7.4.2 keyword, isn't it?
08:21:34 <johnw> which version of GHC are you using?
08:23:27 <magnap> According to http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/safe-haskell.html#safe-trust it is
08:25:42 <magnap> johnw? Did i answer you question?
08:25:55 <johnw> I was trying to answer Anonymous Coward's paste
08:26:41 * typoclass . o O ( transitive question answering )
08:26:43 <magnap> Oh, sorry about that then.
08:28:04 <magnap> Wait, does what you write here turn into a comment on the paste?
08:28:15 <johnw> I don't think so
08:30:13 <maksbotan> hi guys
08:30:23 <Taneb> Hi, maksbotan
08:30:44 <maksbotan> anyone familiar with concept of groebner basis? (dunno how it's exactly called in english... it's related to ideals in polynomial rings)
08:34:00 <nicoo> maksbotan: It's called Gröbner basis
08:34:18 <maksbotan> nicoo: afaik oe == ö, but still
08:34:25 <maksbotan> nicoo: can you advice me a little?
08:34:38 <nicoo> maksbotan: I can try
08:34:43 <nicoo> Waht do you want to know ?
08:36:14 <maksbotan> nicoo: nice. i'm trying to implement algorithm that builds Gröbner basis. i have function that gives me S-polynom of two given polynoms and function that reduces given polynom on given basis
08:36:39 <maksbotan> but i'm stuck in implementing process of checking s-polynoms of pairs of polynoms in basis
08:36:48 <maksbotan> and adding ones that do not reduce to 0
08:37:37 * nicoo still dœsn't see the question.
08:38:05 <maksbotan> nicoo: well, the question is
08:38:34 <maksbotan> how can i write this 'check all pairs, add all non-zero-reduced s-polynoms to basis, return' thing in haskell?
08:38:46 <maksbotan> s/return/repeat/
08:38:47 * nicoo assumes you want to implement Buchberger's algorithm
08:38:55 <maksbotan> nicoo: yeah, you're right
08:39:23 <dmwit> > let allPairs xs = [(x, y) | x <- xs, y <- xs] in allPairs [1..5]
08:39:25 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
08:40:10 <nicoo> dmwit: You can bruteforce it this way ; I assume maksbotan wants something slightly more clever
08:40:21 <maksbotan> dmwit: but after we add new polynoms to basis and start the process again, we do not need to check already checked pairs
08:41:29 <nicoo> maksbotan: You can partition the basis in « <pairs already checked> , <stuff I'm inserting> »
08:42:24 <maksbotan> then take on polynom from the second part, check it, move to the first, repeat?
08:42:32 <nicoo> While <stuff I'm inserting> is non-empty, extract one, generate the S-polynoms w.r.t. polynomials in <pairs already checked>, ...
08:42:43 <nicoo> Exactly
08:42:51 <maksbotan> nicoo: wow, that's a nice idea, thank you
08:42:56 <maksbotan> i'll give it a try
08:43:03 <nicoo> Since S(f,g)=S(g,f), it ought to work
08:43:16 <nicoo> You are very welcome (though it is quite basic)
08:43:29 <maksbotan> i'd say s(f,g) = -s(g,f), but that does not matter
08:43:55 <dmwit> :t interleave
08:43:59 <lambdabot> MonadLogic m => m a -> m a -> m a
08:44:03 <goodfellow> on the commandline: Warning:
08:44:03 <goodfellow>     -fglasgow-exts is deprecated: Use individual extensions instead
08:44:03 <goodfellow> syntax:  :module [+/-] [*]M1 ... [*]Mn
08:44:12 <nicoo> maksbotan: True, but we don't care (it's still non-zero, and it doesn't change non-zero-ness of future reduction)
08:44:14 <dmwit> erk
08:44:20 <dmwit> I knew I disabled that for a reason.
08:45:04 <maksbotan> nicoo: i study haskell just for three months :)
08:45:24 <nicoo> ;)
08:45:29 <Taneb> Lambdabot has logict?
08:45:34 <maksbotan> nicoo: btw, on what year do they study Gröbner basis in universities at your place?
08:45:53 <dmwit> :t interleave
08:45:55 <lambdabot> MonadLogic m => m a -> m a -> m a
08:46:20 <dmwit> > interleave [1..5] [10,20..50]
08:46:22 <lambdabot>   [1,10,2,20,3,30,4,40,5,50]
08:46:33 <nicoo> maksbotan: I studied them in my first year of Master (in Computer Science)
08:47:04 <maksbotan> nicoo: hm... we study them at first year of bachelor
08:47:10 <maksbotan> in math, i think
08:47:32 <maksbotan> dunno how this thing in Russia corresponds to things in other countries
08:48:14 <nicoo> maksbotan: The order in which you study stuff really depends on the university, sometimes
08:48:58 <nicoo> Of course, there are some rather strong dependencies, sometimes, but Gröbner basis have few prerequisites.
08:49:48 <maksbotan> yeah, we did rings and euclidian rings concepts, ideals and basic number theory in the first term
08:50:22 <merijn> goodfellow: The deprecated warning is because the current correct way to enable extensions is to use the -X commandline flag, or (better!) extension pragmas
08:50:44 <geekosaur> goodfellow's a bot, I think
08:50:59 <nicoo> goodfellow definitely is a bot.
08:51:07 <merijn> >.>
08:51:22 <dmwit> < (==) == (/=) . not -- my favorite introduction to goodfellow
08:51:24 <goodfellow>   True
08:51:42 <nicoo> dmwit: o_O
08:51:58 <dmwit> =D
08:52:07 <nicoo> > not . (==) == (/=)
08:52:09 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
08:52:09 <lambdabot>              with actual type...
08:52:20 <dmwit> < (not .) . (==) == (/=)
08:52:22 <goodfellow>   True
08:52:30 <dmwit> < (==) == (/=)
08:52:31 <goodfellow>   False
08:52:45 <tac> dmwit: Why are we comparing comparators?
08:52:54 <Mortchek> < (==) == (==)
08:52:55 <goodfellow>   True
08:52:58 <Mortchek> :0
08:53:11 <mauke> < not == not
08:53:12 <Mortchek> < (==) == not . not . (==)
08:53:13 <goodfellow>   can't find file: L.hs
08:53:13 <goodfellow>   True
08:53:15 <mauke> haha
08:53:21 <dmwit> < compare compare compare
08:53:23 <goodfellow>   EQ
08:54:04 <Mortchek> < (==) == (not . not . (==))
08:54:05 <goodfellow>   Couldn't match expected type `a0 -> GHC.Types.Bool'
08:54:05 <goodfellow>              with actua...
08:54:08 <Mortchek> Eh woop
08:54:23 <dmwit> Mortchek: (not .) . (not .) . (==)
08:54:29 <Mortchek> Thanks
08:54:37 <niteria> :t (==) `on` (==)
08:54:39 <lambdabot> Eq a => a -> a -> Bool
08:54:58 <Mortchek> < (==) == ((not .) . (not .) . (==))
08:54:59 <goodfellow>   True
08:55:13 <typoclass> < map == (flip map)
08:55:14 <goodfellow>   Couldn't match expected type `[a0]' with actual type `a1 -> b0'
08:55:30 <Mortchek> < map == flip (flip map)
08:55:31 <goodfellow>   No instance for (Data.Universe.Finite [a0])
08:55:31 <goodfellow>    arising from a use of `GHC.C...
08:55:41 <Mortchek> What.
08:55:53 <dmwit> You can only compare functions with finite domains, of course! =)
08:56:03 <dmwit> < (map :: [Void]) == flip (flip map)
08:56:04 <goodfellow>   Not in scope: type constructor or class `Void'
08:56:06 <Mortchek> I see. :P
08:56:11 <dmwit> aww
08:56:31 <dmwit> err... also map does not have type [Void]
08:56:34 <typoclass> < "lolcats" == "lolcats"
08:56:35 <goodfellow>   True
08:56:40 <typoclass> awww :)
08:56:53 <niteria> who is goodfellow?
08:56:53 <Jaak> < (map :: [()]) == flip (flip map)
08:56:54 <goodfellow>   Couldn't match expected type `[()]'
08:56:55 <goodfellow>              with actual type `(a0 -> b...
08:57:02 <dmwit> Jaak: map has a function type =)
08:57:09 <dmwit> Also, [()] is not a finite type.
08:57:16 <niteria> I mean, there's lambdabot already
08:57:18 <typoclass> niteria: a new bot
08:57:32 <dmwit> niteria: It's temporary, until I can send some patches to Cale nad convince him to apply them. =)
08:57:46 <dmwit> Gotta test the patches somehow!
08:57:59 <typoclass> dmwit: i like the "< " shortcut, though
08:58:23 <dmwit> Yeah, I didn't want to conflict with anything lambdabot already does. That's not nice.
08:58:38 <mauke> dmwit: does it have a @type command?
08:58:48 <Taneb> < (1, "hello") & _1 id
08:58:49 <goodfellow>   No instance for (GHC.Num.Num (f0 b0))
08:58:49 <goodfellow>    arising from a use of `e_111'
08:58:49 <goodfellow>  Pos...
08:58:51 <dmwit> No, because the Type module also provides :t.
08:58:55 <Taneb> < (1, "hello") & _2 id
08:58:56 <goodfellow>   [(1,'h'),(1,'e'),(1,'l'),(1,'l'),(1,'o')]
08:59:08 <dmwit> (sorry)
08:59:11 <Taneb> < typeOf $ (1, "hello") & _2 id
08:59:13 <goodfellow>   [(Integer,Char)]
08:59:19 <minopret> I received no answer in #yi for 15 min. Does anyone wish to field my question there (or here)?
08:59:49 <dmwit> ?where justask
08:59:50 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
09:00:37 <niteria> < putStrLn "> 1"
09:00:39 <goodfellow>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
09:00:39 <goodfellow>    arising from a use of ...
09:00:50 <minopret> The question is simple: How to pronounce yi? As [[Yi (Confucianism)]] pinyin: yì, /jeɪ̯/, which is difficult for speakers of European languages? As [http://www.haskell.org/haskellwiki/Yi 義, pronounced yi], whatever that is? Analogous to [[vi]] as /waɪˈaɪ/ or perhaps /jaɪ/? Does anyone pronounce it at all? Does anyone care how to pronounce it? In absence of other advice I suppose I'll say /jaɪ/.
09:01:39 <mauke> < var ">"
09:01:40 <goodfellow>   >
09:01:49 <dmwit> hm
09:01:51 <mauke> < var ">\n>"
09:01:52 <goodfellow>   >
09:01:52 <goodfellow>  >
09:01:59 <dmwit> Oh, there's still a space. Yay.
09:02:33 <sproingie> i pronounce it "yee"
09:03:02 <sproingie> ironically most of the world has never learned to pronounce IPA
09:03:03 <dmwit> minopret: http://www.haskell.org/haskellwiki/Yi#Trivia
09:03:17 <typoclass> minopret: i dunno, i'd just say it to rhyme either with 'me' or with 'bye'. i don't see how it matters
09:03:54 <sproingie> you pronounce it "yi" :)
09:04:48 <minopret> dmwit "pronounced yi" is funny but not helpful. sproingie "yee" /ji/ works fine for me. typoclass sure, it doesn't much matter, unless you want to mention yi in speech without first defining the term. Thanks all.
09:05:21 <dmwit> minopret: I didn't say it was "pronounced yi". I linked to a page which gives the precise Chinese from which it was derived; if you know Chinese this tells you how to pronounce it.
09:05:23 <Cale> dmwit: What are the patches?
09:05:53 <dmwit> Cale: Gotta patch NumInstances to remove the error-based instances, then import Data.Universe.Instances (and bonus points for a qualified Data.Universe as U).
09:06:07 <dmwit> Cale: I'll send some formal darcs patches and diff output in just a bit.
09:06:54 <minopret> dmwit ok, pinyin yì works for me too, but it won't be a useful name when I talk to my local Haskell enthusiasts, none of whom speak in the manner of Beijing. Yeah, whatever. Thanks again though.
09:07:10 <sproingie> if none of them are chinese then does it matter?
09:07:11 <Cale> dmwit: What is Data.Universe.Instances?
09:07:15 <sproingie> if they are i'm sure they'll correct you
09:07:17 <dmwit> ?hackage universe
09:07:18 <lambdabot> http://hackage.haskell.org/package/universe
09:07:30 <dmwit> Cale: Eq, Ord, Show, Read instances for functions with a finite domain
09:07:36 <sproingie> heck they might correct you differently for each dialect
09:07:40 <Cale> ah, cool
09:08:17 <sproingie> anyway i briefly had a chinese coworker whose last name was Yi and it was pronounced yee
09:08:46 <typoclass> sproingie: 'correct you' in the sense of 'bully you pointlessly'
09:08:55 <dmwit> Cale: (Where should I send them?)
09:09:07 <sproingie> all this sturm and drang over a syllable
09:09:30 <typoclass> minopret: i think everyone will understand it if you introduce it as "yi, the editor written in haskell", no matter how you pronounce yi. if you come up with some special exotic way to pronounce it, in my opinion it'd be even more necessary to add an explanatory "the editor written in haskell"
09:09:46 <Cale> Uh, well, a patch to NumInstances should probably go to Conal?
09:10:37 <dmwit> Okay!
09:10:50 <niteria> > ((==) `on` (==)) 10 10
09:10:52 <lambdabot>   *Exception: (==): No overloading for function
09:10:54 <Cale> dmwit: I guess you can send the patches directly to me if you want me to just rebuild the packages for lambdabot use
09:10:55 <niteria> interesting
09:11:20 <niteria> why did it typecheck?
09:12:02 <dmwit> niteria: Because numbers are functions in \bot.
09:12:29 <minopret> O come all yi faithful users of editors written in Haskell. Got it.
09:12:37 <dmwit> Or rather, because functions are Eq instances (in a bad way) to support functions are Num instances (in a good way) in \bot.
09:13:54 <simukis_> Ehmm, a question or two. For example unit has a dimension (Coloumb has a constant dimension of Time*Current). First of all how would one define Dimension datatype so one could easily define dimensions like Time*Current. Another question is how whould one attach that dimension information to an Unit? At least am I going in the right direction? http://hpaste.org/85599
09:14:56 <niteria> dmwit: where is the Eq instance for functions?
09:15:24 <typoclass> simukis_: i haven't used the stuff myself, but several people have done work. check out the packages mentioned here http://www.haskell.org/haskellwiki/Physical_units
09:15:40 <dmwit> \bot's Eq instance for functions is in NumInstances
09:16:02 <dmwit> < ((==) `on` (==)) 10 (10 :: Word8)
09:16:04 <goodfellow>   True
09:16:08 <niteria> oh, it's a lambdabot thing
09:16:24 <dmwit> goodfellow's Eq instance for functions is in universe =)
09:17:17 <simukis_> typoclass: I'm not looking for a library to do the job. I just thought it would be a good exercice to learn haskell. I can already contribute to projects that have API set in stone, but I somehow am unable to create a project from scratch myself.
09:18:27 <typoclass> simukis_: ah i see :-) ok
09:19:50 <niteria> < (1,2) + (1,2)
09:19:52 <goodfellow>   (2,4)
09:20:10 <mauke> < (1,2) + 1 2
09:20:12 <goodfellow>   (2,3)
09:21:00 <niteria> and my mind is blown
09:21:32 <mauke> < deriv (2 * sin) x
09:21:34 <goodfellow>   2 * (1 * cos x)
09:22:29 <niteria> < (x,y) + z q
09:22:30 <goodfellow>   The function `Debug.SimpleReflect.Vars.z'
09:22:31 <goodfellow>  is applied to one argument,
09:22:31 <goodfellow>  but...
09:23:37 <niteria> < (x,y) + 1 2 3 4 5 6 7 8 9
09:23:38 <goodfellow>   (x + 1,y + 1)
09:24:41 <pmade> I need some help removing some redundancy in my code.  For example, I have two records that have the same number of fields, and they are used the same way, except in one record some of the fields are Maybe String and in the other record they are just String (because they are optional in one record, and mandatory in the other).  The redundancy comes from encoding and decoding to formats like JSON and XML.  Lots of co
09:24:42 <pmade> de duplication.  Is there a common patter here with a general solution?
09:25:04 <niteria> < 1 + 2 3 4 + 5
09:25:06 <goodfellow>   8
09:25:47 <dmwit> pmade: parameterized types?
09:26:15 <mauke> data Foo c = Foo{ bar :: c String, baz :: c Int }
09:26:32 <typoclass> pmade: a simple solution could be to have 3 records, one for the common stuff and 2 for the remaining specialized things
09:26:35 <BOY77X> http://www.reddit.com/r/XXXBITCHINBEACHXXX/comments/1c53ca/naked_yoga_with_lyubov_shumeiko/
09:26:59 <dmwit> <3 idoru
09:27:01 <pmade> dmwit, mauke, that's a good option I was overlooking.
09:27:31 <dmwit> I was going to say data Foo a = Foo {bar :: a, baz :: Int}, but mauke's is good, too.
09:27:40 <niteria> @type 1!1!1!1!1
09:27:41 <lambdabot> (Num i, Num i1, Num i2, Num i3, Num (Array i3 (Array i2 (Array i1 (Array i e)))), Ix i3, Ix i2, Ix i1, Ix i) => e
09:27:57 <dmwit> > map 1 [5..10]
09:27:59 <lambdabot>   [1,1,1,1,1,1]
09:28:05 <dmwit> > 1.[5..10]
09:28:07 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
09:28:21 <dmwit> Oh, that's been changed back. ok =)
09:28:22 <pmade> mauke: What would `c' be if it wasn't Maybe?
09:28:25 <niteria> > 1 <$> [5..10]
09:28:27 <lambdabot>   [1,1,1,1,1,1]
09:28:31 <dmwit> pmade: Identity
09:28:39 <pmade> dmwit: Ah, that's a great idea.
09:30:52 <pmade> How do I scale this up to when I have something like 4 records that are almost identical? (I'm working on health care records that have a lot of similar record types).  I can imaging having many type parameters.  Is there a pattern for when you have a lot of parameters?
09:32:54 <dmwit> I think the question may be a bit too abstract at the moment to answer reasonably.
09:33:34 <dmwit> You could make it more concrete by writing some sample records that you'd want to handle.
09:34:26 <pmade> dmwit: I was just thinking that.  I need to think about this a bit more.
09:34:46 <typoclass> pmade: have you thought about this? Foo { common :: Common, individual :: String }, Bar { common :: Common, someOtherIndividualThing :: Int }, Common { ... some fields ... }
09:36:16 <pmade> typoclass: That's also an option.  I need to think about this a bit more.  My only hesitation with your solution is then needing to use something like lenses to make it easy to dig into the nested records.
09:36:41 <typoclass> pmade: that's true, you'd need some boilerplate functions, or lens
09:36:59 <mauke> boilerlens
09:37:07 <niteria> typoclass: wouldn't both commons clash?
09:37:28 <typoclass> niteria: true, if those records are in the same module. good catch
09:37:36 <niteria> what's the typical solution for that?
09:37:47 <niteria> I hate when that happens
09:37:59 <minopret> In case it amuses anyone, I summarized the question of "how to pronounce yi" here (shortest answer: "who cares"): http://en.wikipedia.org/wiki/Talk:Yi_(editor)#Saying_the_name
09:38:00 <typoclass> niteria: different modules, or "bCommon" and "fCommon"
09:39:05 <tac> Yi, the unloved project
09:40:14 <minopret> tac is it? I had no idea. I was just looking for the umpteenth time at text editors, their features and benefits, and which I want to try next.
09:40:36 <Luke> yi is pretty awesome
09:40:40 <Luke> i wish it had more critical mass
09:40:58 <niteria> it'd be nice if lens dealt with that and made I lens that works for both Foo's fCommon and Bar's bCommon
09:41:08 <niteria> s/I lens/a lens/
09:41:35 <Taneb> I lens! I first class data accessor!
09:45:55 <mornfall> Luke: What's awesome about yi? :-)
09:46:29 <mornfall> It seems to be stuck in 2009, more or less.
09:47:17 <mornfall> On the other hand, there doesn't seem to be much going on in xmonad either. :-)
09:47:40 <dmwit> xmonad is a finished product.
09:47:41 <dmwit> ;-)
09:47:42 <goodfellow> Maybe you meant: ft rc
09:48:14 <mornfall> dmwit: There's no compositor... :P
09:48:47 <dmwit> true
09:49:08 <mornfall> And if X really becomes deprecated... well.
09:49:12 <dmwit> I have vaguely wondered what the right model for a compositing, tiling window manager would be.
09:49:30 <mauke> compostiling
09:49:51 <mornfall> composting, approved by the EU
09:50:26 <geekosaur> not x11's model
09:50:27 <Taneb> ;t "test"
09:50:27 <goodfellow> TEST: 0.00 @ N/A N/A
09:50:43 * hackagebot adp-multi 0.2.0 - ADP for multiple context-free languages  http://hackage.haskell.org/package/adp-multi-0.2.0 (MaikRiechert)
09:50:56 <niteria> ;t "> test"
09:50:56 <goodfellow> >: 0.00 @ N/A N/A
09:50:56 <goodfellow> TEST: 0.00 @ N/A N/A
09:51:11 <niteria> ;t ">1--"
09:51:12 <goodfellow> >1--: 0.00 @ N/A N/A
09:51:50 <niteria> ;t "<1--"
09:51:50 <goodfellow> No Result Found.
09:51:55 <dmwit> Oh no! People may be able to abuse goodfellow to artificially inflate their lambdabot karma!
09:52:16 <geekosaur> also, given x11's weirdball compositing model, adding compositing to the window manager is not an especially smart idea. (compiz does it, but because it's not quite a normal window manager; it needs to use compositing so it can get at window contents and load them into opengl textures)
09:52:53 <niteria> >1--
09:53:24 <mornfall> geekosaur: That's an implementation detail. You could fork the window manager and the compositor as separate processes from xmonad.
09:53:28 <dmwit> ?karma >1
09:53:29 <lambdabot> >1 has a karma of -1
09:53:35 <mornfall> The problem is that all compositors nowadays actually are window managers, for all I can tell.
09:53:43 <geekosaur> really?
09:53:48 <geekosaur> I know of only one: compiz
09:53:53 <joe9> I want to check if an element is within a range of expected values: such as elem 10 [8,9,10,11,12] -- a list within 2 elements of 10, the expected value
09:53:59 <mornfall> geekosaur: Add kwin to your list.
09:54:03 <geekosaur> xcompmgr, dcompmgr, compton, and cairo-compmgr are not window managers
09:54:04 <joe9> Is there a way to generate such a list in a simpler manner?
09:54:18 <joe9> I can do [10-2,10-1,10,10+1,10+2]
09:54:20 <mornfall> xcompmgr is very broken and even more unmaintained
09:54:26 <mornfall> You could say it doesn't exist. :-)
09:54:27 <dmwit> > [10-2 .. 10+2]
09:54:29 <lambdabot>   [8,9,10,11,12]
09:54:38 <joe9> dmwit: cool, thanks.
09:54:39 <geekosaur> move those goalposts until it fits your conceit
09:55:17 <dmwit> joe9: but, uh, if all you're going to do is use `elem`, may I suggest using (>) and friends instead?
09:55:23 <geekosaur> how about, go write a compositing manager yourself, and *then* consider whether it's appropriate to sell someone else they should do so
09:55:27 <geekosaur> *tell someone
09:55:27 <mornfall> geekosaur: Yeah, I only happen to be interested in compositors that actually work. :)
09:55:29 <dmwit> :t \x -> x >= 10-2 && x <= 10+2
09:55:31 <lambdabot> (Num a, Ord a) => a -> Bool
09:55:48 <joe9> dmwit, thanks.
09:55:54 <mornfall> geekosaur: I'm not telling anyone to write one. I'm just saying there's none that's useful with xmonad.
09:56:03 <mornfall> Tell me something about moving goalposts.
09:56:12 <dmwit> Um, I'm pretty sure people use cairo-compmgr with xmonad.
09:56:16 <dmwit> And xcompmgr.
09:56:17 <geekosaur> it's really easy to tell someone else how they really ought to code to a completely braindamaged interface
09:56:28 <mornfall> I tried using xcompmgr for a while.
09:56:48 <geekosaur> x11 compositing is a horrible ugly hack, even worse tan its multiscreen model. that's why most compositing managers are broken/buggy
09:57:19 <mornfall> cairo-compmgr seems to have a release from 2010, but I've never heard of it until now
09:57:51 <niteria> ;t "> > >"
09:57:51 <goodfellow> >: 0.00 @ N/A N/A
09:57:51 <goodfellow> >: 0.00 @ N/A 2:-176am
09:57:51 <goodfellow> >: 0.00 @ N/A N/A
09:58:11 <Luke> mornfall: re: yi - it's like a really fast haskell version of emacs. whats' not cool about that?
09:58:21 <dmwit> 2:-176am, eh?
09:58:31 <dmwit> I think you're starting to go off the deep end, goodfellow.
09:58:40 <niteria> what does that do anyway?
09:58:51 <dmwit> I guess it's the ticker module for stock prices.
09:59:00 <dmwit> ;t "ATT"
09:59:00 <goodfellow> ATT: 0.00 @ N/A N/A
09:59:06 <dmwit> ?t "ATT"
09:59:07 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:59:17 <dmwit> ?ticker "ATT"
09:59:17 <lambdabot> ATT: 0.00 @ N/A N/A
09:59:30 <niteria> ?ticker "GOOG"
09:59:31 <lambdabot> GOOG: 787.80 -2.38 (-0.30%) @ 4/11/2013 12:44pm
09:59:44 <dmwit> ;t "GOOG"
09:59:44 <goodfellow> GOOG: 787.94 -2.24 (-0.28%) @ 4/11/2013 12:44pm
10:00:03 <mornfall> Luke: Dunno, I use emacs+viper, but I have a Dvorak layout, and last time I tried yi, I couldn't get anything reasonable without patching the sources to change keybindings. :P
10:00:26 <Luke> mornfall: haha
10:00:30 <mornfall> Luke: I guess I could write an entirely new bindings module, but that seemed wasteful.
10:00:45 <mornfall> And that's where my yi experience ended. :-)
10:02:07 <teamon> Hi. Is there any elasticsearch haskell client or at least a nice REST lib? I've found only https://github.com/ocharles/Elasticsearch which was updated 2 years ago
10:03:20 <Luke> mornfall: still cool ;-P
10:05:43 * hackagebot adp-multi 0.2.1 - ADP for multiple context-free languages  http://hackage.haskell.org/package/adp-multi-0.2.1 (MaikRiechert)
10:10:54 <niteria> ;t "@faq"
10:10:55 <goodfellow>  @FAQ: 0.00 @ N/A N/A
10:11:16 <ryant5000> could anyone here recommend a paper on translating lambda calculus into operations on cartesian closed categories?
10:12:37 <Eduard_Munteanu> ryant5000: what lambda calculus and what do you mean by operations?
10:13:18 <Eduard_Munteanu> Mapping STLC types to objects in a CCC?
10:13:27 <Cale> ryant5000: Awodey has some stuff about that
10:13:28 <ryant5000> Eduard_Munteanu: i'm not too particular - i'm looking for more of an introduction
10:13:38 <ryant5000> Eduard_Munteanu: not mapping types, mapping expressions
10:14:02 <Cale> hmm
10:14:07 <Eduard_Munteanu> Hm, then I'm not sure how that'd work.
10:14:35 <niteria> ;t "?"
10:14:36 <goodfellow> ?: 0.00 @ N/A N/A
10:14:36 <lambdabot> Maybe you meant: . ? @ v
10:14:39 <niteria> finally
10:15:34 <ryant5000> right now i'm looking at it from a fairly concrete perspective - i'm trying to translate simple lambda expressions into equivalent functions using the combinators from ed kmett's 'categories' library
10:17:03 <ryant5000> e.g.: \((a, b), c) -> (a, (b, c)) would turn into Control.Category.Associative.associate
10:17:13 <niteria> ?v
10:17:13 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
10:17:23 <niteria> ?v
10:17:24 <lambdabot> "\""
10:17:47 <Cale> niteria: Could you do that in private?
10:17:54 <niteria> sorry
10:20:17 <pmade> Is there a way to encode values in a type, like: x :: Foo String 1 10 -- which would mean Foo is a string with minimum length of 1 and maximum length of 10?
10:21:07 <johnw> pmade: google for "haskell dependent types", and you should find lots to read
10:21:16 <pmade> johnw: Thank you.
10:21:38 <johnw> there is a way to do what you just asked, but it may not be pretty enough yet, depending on which version of GHC you have
10:21:39 <tromp_> it's possible in http://idris-lang.org/
10:21:39 <Philonous> pmade:  Better yet, learn a dependently typed language and then complain about Haskell not being dependently typed ;)
10:22:21 <Philonous> pmade:  I'm serious about learning a dependetly typed language, btw.
10:22:59 <pmade> Thank you everyone, I'll add that to my list of things to learn ;)
10:23:09 <pmade> But now, in my day job, I have to figure this out ;)
10:23:39 <geekosaur> good luck
10:25:05 <pmade> Are there other options in Haskell I can use to fake it?
10:25:07 <djahandarie> pmade, you can do something like that reasonably easy in Haskell. Of course keep in mind that string literals / normal lists will not give you any length info in the type system, so you'll need to do something more annoying to get the length in the type system for compile-time available strings
10:25:47 <pmade> djahandarie: In this case all of the values will come from IO.
10:26:10 <djahandarie> Ok, so then I assume you want to do a runtime check to see if the string is okay to be lifted into that type?
10:26:24 <pmade> I'm trying to record attribute in the types so when I go to encode the type to a file format I know if I need to pad it or fail if it's too long.
10:26:47 <pmade> Right now I'm using a typeclass and another type Width = Width Min Max
10:26:49 <typoclass> pmade: how about template haskell? it's among the more heavy guns, but it could help in the end
10:27:11 <pmade> typoclass: I was thinking about that too, I just don't have any experience with it yet.
10:27:20 <djahandarie> I would not use TH
10:27:24 <djahandarie> Because I hate TH
10:28:44 <typoclass> pmade: can you get away with not putting the lengths in the type system?
10:29:23 <Hannibal_Smith> Maybe something like this? http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html#promoted-literals
10:29:40 <pmade> Yes, that's what I'm doing now.  I was just looking to make this code a bit more expressive.
10:29:50 <djahandarie> The number literals are hardly the issue
10:30:12 <djahandarie> I'd do something like   {-# LANGUAGE DataKinds #-} data Nat = Z | S Nat; data BoundedList :: Nat -> Nat -> a -> * where ...
10:30:58 <djahandarie> Sorry, that a is suppose to be a *
10:31:06 <typoclass> pmade: how do you mean, expressive? could you put a small example on hpaste.org?
10:31:19 <pmade> typoclass: Sure
10:31:26 <djahandarie> And make sure that when you construct a list, you do it in such a way that the list is guarenteed to be larger than the first n, and smaller than the second n
10:32:04 <someoneelse> how can i make my class subclass Show?
10:32:28 <Heffalump> class Show a => SomeoneElseShow a where ...
10:33:42 <hpaste> pmade pasted “Data ENcoding” at http://hpaste.org/85603
10:33:43 <typoclass> someoneelse: you mean, you want to make an instance of typeclass Show for your type? (this will allow you to call 'show' on values of your type)
10:33:53 <djahandarie> The Fin and Vec types would probably be of interest to you if you want to go down that route
10:34:28 <pmade> That's what I'm doing right now, and it works fine.  I'm just thinking of other ways to accomplish the same thing, ways that read better.
10:34:32 <someoneelse> well, i have a class Vector v where add :: Num s => v s -> v s -> v s  (an example: data Vec3 a = Vec3 a a a)
10:34:57 <someoneelse> i want to supply a generic Vector show
10:35:22 <pmade> What I'm doing right now might be the best way.
10:36:42 <Philonous> someoneelse:  There's no way you can define show in terms of vector addition and scalar multiplication.
10:37:00 <Philonous> someoneelse:  You'll have to define show instances for each type individually
10:37:17 <Philonous> (Or let ghc derive them)
10:37:34 <someoneelse> Philonous, i have a fromList / toList in Vector
10:37:58 <someoneelse> Philonous, So show is show v = let str = unwords $ map P.show $ toList $ v in "{" ++ str ++ "}"
10:37:59 <Philonous> toList :: v s -> [s] ?
10:38:06 <someoneelse> Philonous, yes
10:38:19 <stepkut> has anyone written a raytracer using DPH? That would be a good match, yes?
10:38:29 <pascha> > let rec = { a ::Int, b :: Int } in rec 5
10:38:30 <lambdabot>   <hint>:1:5: parse error on input `rec'
10:38:36 <Philonous> instance Show s => Show (v s) where show = ...
10:39:38 <someoneelse> Philonous, that's instance Show a => Show (Vec3 a) where ...
10:39:43 <someoneelse> Philonous, ?
10:39:54 <Philonous> someoneelse:  Excuse me, I meant instance (Show s, Vector v) => Show (V s) where ..
10:40:01 <someoneelse> Philonous, ah, i see
10:40:25 <Philonous> -typos, but you get my point ;)
10:40:53 <someoneelse> Philonous, i think i do. thanks
10:41:17 <Philonous> someoneelse:  Though that's not really a good idea, because it defines show for _all_ types of the form (v s) for _any_ type constructor v.
10:41:43 <Philonous> someoneelse:  Instance resolution is a bit funky.
10:43:05 <Philonous> someoneelse:  A better Idea is this: newtype VecShow v a = VecShow {unVecShow :: v a} and instance (Show s, Vec v) => Show (VecShow v s) where show (VecShow v) = <show vector>
10:43:40 <Philonous> someoneelse:  You'll have to wrap all vectors in VecShow before showing them, but that's unavoidable, unfortunately
10:43:55 <someoneelse> Philonous, i'm still trying to get the bad idea to work
10:44:43 <someoneelse> Philonous, instance (Vector v) => Show v where show x = "nothing" -- still complains =/
10:45:20 <Philonous> someoneelse:  What's the error message?
10:45:29 <someoneelse> Philonous, `v' is not applied to enough type arguments
10:45:36 <someoneelse> Philonous, hold on, i'll paste the source
10:45:47 <Philonous> someoneelse:  Ah right, it must be (Vector v) => Show (v s)
10:46:05 <someoneelse> Philonous, tried that as well =)
10:46:14 <Philonous> Show wants kind *, Vector is kind (* -> *)
10:46:14 <ab9rf> debugging by mutation
10:46:33 <someoneelse> http://hpaste.org/85604
10:46:38 <pascha> could accesors of Datas be autoderived somehow? data Point = Point Int Int Int // xCoord (Point x _ _) = x // could that be derived by some clas or something?
10:46:44 <hpaste> typoclass annotated “Data ENcoding” with “Data ENcoding (annotation)” at http://hpaste.org/85603#a85605
10:47:37 <niteria> is there a O(n) way of sorting bounded ints in a purely functional setting? like bucket sort in imperative setting
10:47:44 <typoclass> pmade: i don't know if this makes any sense, but here's a suggestion. for inspiration if for nothing else :-) it seems like you really only want to carry around two Ints along with the fields
10:48:01 <niteria> I wonder if radix sort on bits counts as O(n)
10:48:21 <Philonous> someoneelse:  You need {-# LANGUAGE FlexibleInstances #-} on the top of your file
10:48:52 <someoneelse> i'm really trying to avoid the language extensions, but for some reason, i'm not able to...
10:48:58 <pmade> typoclass: That's true, I do.  Thank you.  I think my issue is that what I have doesn't "feel" right.  I don't have enough intuition for Haskell or the problem domain.
10:49:05 <tromp_> niteria: see accumArray
10:49:30 <joe9> this just does not seem right. inRange expected x = and [(x >= (expected-2)), (x <= (expected+2))], it works though. is there a better way to write it?
10:49:48 <typoclass> pmade: sure :-) no worries
10:49:58 <typoclass> pmade: uh wait, my solution doesn't work anyway
10:50:05 <Philonous> someoneelse:  The problem is that the instance you're defining your type at consists solely of type variables
10:50:16 <Philonous> someoneelse:  You need to use the newtype
10:50:19 <niteria> tromp_: well, yes, I can do anything in ST that I can do imperatively
10:50:33 <Philonous> someoneelse:  Otherwise you'll get into trouble anyway, because instance selection will barf.
10:50:42 <tromp_> accumArray doesn't need the ST monad though. it's more "pure"
10:50:46 <pmade> typoclass: I was just thinking about that.  At runtime I wouldn't have a place to input the max and min.  Oh well, what I have works well enough.
10:50:48 <someoneelse> Philonous, hmm, i'll have a look
10:51:37 <niteria> tromp_: but you can't implement accumArray in a functional setting, right?
10:51:40 <typoclass> pmade: anyway, what you can do for starters is pattern-match directly f (Foo a b) = ..., instead of calling "field x" repeatedly inside of f
10:51:43 <tromp_> you just use it to cons each element onto its proper bucket (a list) in constant time
10:51:45 <staafl> question: what's the easiest way to get the cube root of an 'Integer'
10:51:47 <joe9> inRange expected x = and [(x >= (expected-2)), (x <= (expected+2))] -- or -- inRange expected = (\x -> x >= expected-2 && x <= expected+2)
10:51:54 <staafl> a really big one
10:51:54 <joe9> the second version is from dmwit.
10:52:00 <staafl> cryptographically big
10:52:06 <hpaste> Philonous annotated “show woe” with “show woe (annotation)” at http://hpaste.org/85604#a85606
10:52:06 <joe9> which is way cooler than mine
10:52:11 <dmwit> > fromInteger 3 ** (1/3) -- staafl
10:52:13 <lambdabot>   1.4422495703074083
10:52:15 <tromp_> accumArray uses mutable arrays under the hood of course
10:52:18 <dmwit> Oh, cryptographically big.
10:52:20 <Philonous> someoneelse:  see my annotation
10:52:21 <dmwit> Perhaps CReal, then?
10:52:24 <tromp_> but the interface is nicely pure
10:52:31 <dmwit> > fromInteger 3 ** (1/3) :: CReal
10:52:34 <lambdabot>   1.4422495703074083823216383107801095883919
10:52:43 <dmwit> > fromInteger (2^64) ** (1/3) :: CReal
10:52:45 <lambdabot>   2642245.9496291330472378852594747511418551039997
10:52:46 <staafl> dmwit, thanks, I'll try that
10:53:03 <someoneelse> Philonous, thanks again.
10:53:04 <pmade> typoclass: in that example yes.  However my other records have 8+ fields.
10:53:17 <staafl> > fromInteger (2^60) ** (1/3) :: CReal
10:53:18 <lambdabot>   1048576.0
10:54:11 <haskellN00b> hello all
10:54:40 <Philonous> haskellN00b:  Hi
10:55:16 <pascha> haskell is amazing, feels like a dynamic language but has a much better type system, than any other static language!
10:55:43 * dmwit . o O ( feels like I'm wearing... NOTHING AT ALL! )
10:56:04 <hpaste> haskellN00b pasted “Database mapper toy fail” at http://hpaste.org/85607
10:56:41 <Philonous> pascha:  I beg to differ. It has a better type system than C maybe. But it's arguably not the best among all staticly typed languages
10:57:09 <c_wraith> it's certainly better than the 3 most popular statically typed languages
10:57:21 <c_wraith> And few people know of languages other than them.
10:57:33 <ab9rf> i don't find that it feels anything like the dynamically typed languages i've used
10:57:33 <typoclass> pascha: yup, i always think it combines the best of both approaches
10:57:40 <haskellN00b> I'm experimenting with making a "functional relational mapper" (probably a right of passage?) and I've already hit a road block.  I figured before I keep grinding at this, I'd ask if I'm missing a technique that makes this simpler
10:57:42 <ab9rf> _those_ languages don't throw type errors when i try to do something stupid
10:57:46 <dmwit> Philonous: People discuss this endlessly, of course, but Haskell does occupy a very sweet spot between how much can be checked and how much the programmer must say.
10:57:48 <Zylaa> it's 2013 and Haskell is still incapable of having two record fields with the same name in a module?
10:57:55 <Zylaa> wtf?
10:57:55 <ab9rf> they just try to do whatever stupid thing i've asked them to do, and generate nonsense output
10:57:55 <hpaste> applicative pasted “vector with slack” at http://hpaste.org/85608
10:57:57 <niteria> True
10:58:03 <Heffalump> Zylaa: 'fraid so :-(
10:58:24 <applicative_> pmade: here's a perfectly hideous vector with min/max ^^^
10:58:28 <typoclass> Zylaa: there have been various suggestions (type-directed name resolution ...), but as i understood it, none have been convincing enough
10:58:43 <c_wraith> Vinyl looks interesting
10:58:50 <c_wraith> Though it depends on quite-new versions of GHC
10:58:54 <armlesshobo> haskellN00b: paste your concerns
10:58:57 <haskellN00b> The main issue is that at some point I have to have a function that will return something different
10:58:58 <armlesshobo> @where hpaste
10:58:59 <lambdabot> http://hpaste.org/
10:59:05 <haskellN00b> I did, it showed before
10:59:13 <armlesshobo> oh, i missed it. :\
10:59:13 <Philonous> dmwit:  But saying that it is "much better than any other static language" is a far cry (Not that I want to dampen anyone's enthusiasm for Haskell, of course)
10:59:17 <haskellN00b> haskellN00b pasted “Database mapper toy fail” at http://hpaste.org/85607
10:59:26 <joe9> this is my function: http://codepad.org/5U65Adp7 , this is not correct: http://codepad.org/cMRgvpdm
10:59:30 <armlesshobo> haskellN00b: ty
10:59:38 <pascha> why doesn this need to derive show data Person = Person { name :: String, age :: Int } ?
10:59:53 <dmwit> Philonous: The problem here is that the definition of "better" differs drastically from person to person.
10:59:59 <haskellN00b> so anyway, I will need a function somewhere to return something different depending on what the query was.  I know some various of this can be done because Read does it. :)
11:00:09 <pascha> Philonous: really which typesystem is better?
11:00:11 <ab9rf> :t read
11:00:12 <lambdabot> Read a => String -> a
11:00:15 <haskellN00b> I know some variation of this*
11:00:25 <dmwit> haskellN00b: read does not return different types based on the value of its input.
11:00:34 <ab9rf> haskellN00b: you'd have to make a type class that has instances for every possible type you might want to return
11:00:38 <typoclass> Philonous: well, implicitly "any language" meant "any language that on average you're likely to know"
11:00:52 <ab9rf> and read returns the type that its caller expects, not the type that is "required by its input"
11:00:57 <joe9> dmwit, any thoughts, please?
11:00:57 <Philonous> typoclass:  Does Haskell belong to this class?
11:00:59 <ab9rf> haskell is not a dynamically typed language.
11:01:06 <applicative_> haskellN00b: Word32 doesn't have anything below zero
11:01:11 <haskellN00b> ab9rf: right, I'd have to take a similar approach
11:01:43 <dmwit> joe9: Word* is funny because it wraps around at the ends.
11:01:48 <Cale> haskellN00b: Well, you can make a typeclass which works the same way that Read does
11:01:58 <Philonous> pascha:  Agda and Idris for example. Not necessarily languages you want to program in, but your argument was only about types ;)
11:02:00 <applicative_> wait, that was for joe9 -- Word32 doesn't have anything below zero
11:02:10 <Cale> haskellN00b: and if the result of your query wasn't the right type that was demanded by the code, you get a runtime exception
11:02:14 <Philonous> pascha:  Your mileage my vary, of course.
11:02:14 <joe9> dmwit: that makes sense. I can use fromIntegrat to convert Word to Integer?
11:02:19 <Philonous> may*
11:02:43 <dmwit> joe9: Sure, or add a bit of logic to replace (-).
11:02:44 <armlesshobo> @src Word fromIntegral
11:02:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:02:47 <applicative_> they don't have better type system, just different ones, too many properties are lost to declare them simply better
11:02:50 <armlesshobo> @src Word32 fromIntegral
11:02:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:02:51 <Cale> (Many Haskellers would be somewhat dissatisfied with something like that, and would likely want to somehow encode queries in such a way that their type would include the type of result)
11:03:13 <haskellN00b> Cale: I figured that was the solution but I'm wondering how to define them.  I guess I can take a cut at it myself but I figured I'd check if there was some technique I should be using before I started hacking
11:03:15 <Cale> (but that can also be somewhat more awkward to work with)
11:03:26 <staafl> dmwit, darn, it's not enough
11:03:33 <Cale> haskellN00b: So the Read typeclass defines:
11:03:40 <Cale> er, is defined something like:
11:03:42 <dmwit> Philonous: Again, since I'm not sure my point got across yet: it's not clear to me that dependent typing is necessarily a better type system than Haskell's.
11:03:44 <Cale> class Read a where
11:03:46 <staafl> we're talking 1000+ digits
11:03:48 <Cale>   read :: String -> a
11:03:58 <pascha> what about Ada?
11:04:05 <armlesshobo> o.o
11:04:08 <ab9rf> i don't even know what dependent typing is yet so i won't get involved :)
11:04:27 <pascha> Agda and idris, never heard of them. I was comparing to languages that are actually used, not isoteric academic languages.
11:04:43 <Cale> haskellN00b: and then there are instances of that class which say how to read various types out of strings. (I'm ignoring a lot of the details, read actually isn't primitive like this)
11:04:49 <Philonous> pascha:  I'm glad to hear that Haskell is actually used
11:05:02 <haskellN00b> Cale: I agree.  I want to push the types up as far as I can.  For now I just wanted to get anything working and then I'll gradually get the types involved as I can.  The issue is, I want to make this as "native" feeling as I possibly can, comparable to how easy NHibernate is in C# for example
11:05:17 <ab9rf> pascha: haskell was an 'esoteric academic language' for quite a while :)
11:05:33 <Philonous> dmwit:  How not? It subsumes HM.
11:05:35 <typoclass> Philonous: i haven't tried agda myself because i was disappointed when discovering that its type inference had so much less oomph, compared to haskell. but i have heard the opinion in here that haskell is just in a very sweet spot
11:05:38 <dmwit> staafl: ghci handles (2^2048) ** (1/3) with no problem.
11:06:06 <ab9rf> oh, dependent types includes things like subranges of enums?
11:06:14 <dmwit> Philonous: It does not subsume HM, because HM is a type-inference algorithm and not a type system. My point being that if you *restrict* your type system in certain ways, more type inference is possible than in the unrestricted system.
11:06:20 <haskellN00b> Cale: I've been reading up on HList because e.g. right now I have to take a list of the fields the caller wants to use but I want to catch things like:  required field not set on insert, duplicate field, etc.
11:06:21 <typoclass> Philonous: what i'm saying is, it's not clear to me that "more type theory is better"
11:06:23 <dmwit> ab9rf: Any computable predicate, yes.
11:06:35 <ab9rf> dmwit: that presents some serious challenges in type inference, i should think
11:06:39 <dmwit> Yes.
11:06:44 <dmwit> That is my point.
11:06:44 <applicative_> if 'better type system' means, explicit manual recursion for everything and no awesome combinators, ML, Agda and C have much better type systems
11:06:57 <staafl> dmwit, that's just ~600 digits, isn't it?
11:06:57 <haskellN00b> But for now, I just want to get something simple working then I'll tighten it down as much as I can later
11:07:02 <ab9rf> dmwit: you'd have teo work hard to convince me that the expressivity gained is worth that
11:07:19 <staafl> I'm not getting round trip
11:07:48 <Cale> haskellN00b: You might want to take a look at some of the existing DB libraries in Haskell at some point. They all do some kind of mapping between SQL types and Haskell types, but there's a lot of variation in terms of how well-typed the representation of queries is, and the extent to which richer Haskell types can be encoded automatically into collections of SQL tables and such.
11:07:52 <dmwit> staafl: ghci computes (2^4096) ** (1/3) :: CReal in 2.80 seconds here, and 2^4096 has 1000+ digits.
11:08:06 <haskellN00b> As far as defining a "Read" class for all possible return values, that should be easy since I'll have to generate most of this with TH anyway.
11:08:15 <staafl> dmwit, but does it compute it *correctly* :-)
11:08:19 <dmwit> yes
11:08:23 <haskellN00b> Cale: I have.  Every one that was listed on the wikis.  Didn't like any of them for one reason or another.
11:08:31 <Cale> haskellN00b: Note that you can do general things, like make an instance for pairs
11:08:39 <Cale> in terms of the instances for the components
11:08:42 <staafl> dmwit, then I'm doing something wrong
11:08:48 <staafl> could you look at my paste?
11:08:55 <ab9rf> often the mapping between SQL types and Haskell types is application-dependent
11:09:10 <ab9rf> just as it is in virtually all other environments
11:09:20 <Zylaaa> I stopped using Haskell cause the inability to have two fields with same name is so annoying that I could not continue to use the language
11:09:21 <Cale> haskellN00b: Like, despite the fact that nobody ever wrote specific code for reading a pair of an Integer and a list of (Float, Char) pairs, I can do this:
11:09:22 <haskellN00b> Yea, I would probably define a "Read" for all the user defined tables plus take the approach GHC does of defining a "Read" for up to tuple-16
11:09:43 <staafl> which I'll paste in a moment :-)
11:10:09 <ab9rf> Zylaaa: heh, well, that's your choice
11:10:09 <Zylaaa> OCaml = no problem
11:10:17 <Cale> > read "(5, [(3.67e15, 'a'), (3.1415, 'p')])" :: (Integer, [(Float, Char)])
11:10:19 <lambdabot>   (5,[(3.67e15,'a'),(3.1415,'p')])
11:10:25 <dmwit> staafl: err, hm
11:10:36 <Zylaaa> ab9rf: I want to use Haskell again, I'm literally waiting for the change to the language
11:10:47 <ab9rf> Zylaaa: is that change anticipated?
11:10:56 <simpson> Zylaaa: You're talking about records?
11:10:58 <Zylaaa> I've been anticipating it for years
11:11:04 <Zylaaa> simpson: yes
11:11:08 <pascha> how can I do bit operations on an int in haskell? can I have bitwiseOR :: Int -> Hex -> int ? So I can give nput like 0xAF and do myint |= 0xAF; ?
11:11:13 <haskellN00b> Zylaaa: There are alternative record implementation afaik.  Plus, seems like a lot of people are switching to lenses for record access/modification anyway
11:11:14 <simpson> Zylaaa: I suggest learning how to use lens instead.
11:11:22 <typoclass> ab9rf: please don't make unproductive comments like "that's your choice". thanks
11:11:25 <staafl> dmwit, http://pastebin.com/nS0uD0Ue ?
11:11:28 <applicative_> Zylaaa: this is really bizarre.
11:11:31 <mauke> The paste nS0uD0Ue has been copied to http://hpaste.org/85609
11:11:34 <Philonous> pascha:  import Data.Bits, (.|.) is bitwise or
11:11:50 <staafl> dmwit, s/hug/huge/
11:12:12 <Cale> Zylaaa: yeah, a lot of the desire to have better records has been solved at the library level. :)
11:12:14 <applicative_> Zylaaa: you can make a lens associated with a type class, then it can operate on whatever you please
11:12:38 <applicative_> records are for chumps, just like manual recursion
11:12:52 <sproingie> solved several times and with noisy operators
11:13:14 <sproingie> getting to having to lean on my shift key more in haskell than in perl
11:13:21 <applicative_> Zylaaa: the haskell tuple types all have an accessor for the first element etc
11:13:34 <Cale> sproingie: do what I do, and just ignore most of the infix operators that lens defines ;)
11:13:56 <Zylaaa> applicative_: yeah, so why cant I prefix it with the name of the record?
11:14:00 <Zylaaa> like foo:x to access x
11:14:10 <Zylaaa> disambiguate
11:14:14 <applicative_> > (1,'j') ^. _1
11:14:16 <lambdabot>   1
11:14:18 <Philonous> applicative_:  Btw. I'm not sure what you mean "explicit manual recursion everywhere", nothing stops you from writing "foldr" in agda?
11:14:25 <applicative_> > (1,'j',True) ^. _1
11:14:27 <lambdabot>   1
11:14:32 <Cale> > view _1 (1,'j')
11:14:34 <lambdabot>   1
11:14:48 <dmwit> staafl: :t check2? Also, why shouldn't it be huge(ly negative)?
11:15:34 <dmwit> The cube roots of 1000+ digit numbers are 300 digits long; being off by up to one is a big deal.
11:15:45 <applicative_> > (1,'j') & _1 .~ 2
11:15:47 <lambdabot>   (2,'j')
11:15:51 <Cale> As much as I appreciate the '^' in ^. there's still something which seems a little backward to that style of record access to me :P
11:16:01 <dmwit> staafl: Try printing out m^3 - fromInteger m3 instead. =)
11:16:16 <typoclass> Cale: well, you should program more java then ;-)
11:16:22 <staafl> dmwit, it's Integer :-)
11:16:33 <typoclass> "person.name.firstChar()"
11:16:38 <_mr> Cale: why do you appreciate the ^?
11:16:40 <staafl> and m3 is a cube
11:16:50 <ab9rf> Cale: i seem to recall that pointers to records in pascal ended up using ^. a lot
11:17:08 * geekosaur keeps thinking pascal when seeing that, yeh
11:17:16 <Cale> _mr: because it's a nod to the similarity of this notation with exponentiation :)
11:17:41 <ab9rf> it has been a long time since i wrote pascal but that still sticks with me
11:17:46 <applicative_> > (1,'j') & (_1 .~ 2) . (_2 .~ "Zylaaa")
11:17:47 <lambdabot>   (2,"Zylaaa")
11:17:53 <pascha> is there some new "HOT" protocol that would be reasonable to implement in haskell?
11:17:56 <ab9rf> of course, in pascal there is rarely a reason to have a pointer to anything other than a record
11:17:57 <Zylaaa> I emailed Peyton Jones about the records before and he was like oh? Not sure, seems like an issue maybe
11:18:03 <applicative_> > (1,'j',True) & (_1 .~ 2) . (_2 .~ "Zylaaa")
11:18:03 <Zylaaa> kinda strange
11:18:05 <lambdabot>   (2,"Zylaaa",True)
11:18:05 <_mr> Cale: ^_1 makes latex-eyes hurt ;-)
11:18:10 <pmade> Can you write a class such that instances of that class are automatically instances of other classes? e.g. class Foo a where... instance (Foo a) => Bar a where.  You make something a class of Foo and foo knows how to make it an instance of Bar.
11:18:11 <dmwit> staafl: Can you verify that m - fromInteger (floor m) == 0? (Are you double-plus sure m3 is a cube?)
11:18:41 <Zylaaa> applicative_: how about not making any performance compromises
11:18:55 <applicative_> records are a theoretical mess invented by halfwit programmers; sophisticated record systems just pile more fuel on the flames
11:19:17 <Philippa> ...yes, labelling things is bad, mmm'kay?
11:19:18 <applicative_> Zylaaa: what 'performance compromises'
11:19:40 <Zylaaa> applicative_: the theory doesn't bug me, I care about the syntax
11:19:40 <staafl> dmwit, crud
11:19:41 <pascha> yes i guess records are unnecessary when you can just do data Point = Point Int Int Int deriving (Eq, Ord, Show) ; x (Point xCoord _ _) = xCoord
11:19:52 <staafl> it's not
11:19:57 <Cale> pmade: There is a way to do that now, with an extension
11:20:03 <staafl> but it's supposed to be ... :-/
11:20:08 <sproingie> pascha: how about SRP6?
11:20:32 <pmade> Cale: which extension?
11:20:41 <staafl> dmwit, thanks for the help!
11:20:48 <dmwit> You're welcome!
11:21:11 <typoclass> Zylaaa: well, to most people, it just doesn't add up to much pressure, between the obvious solutions ("xField and yField" instead of "field and field"), various record packages on hackage, template haskell, newer things like lenses and vinyl, and the not-really-convincingness of the language-level proposals
11:21:35 <Zylaaa> but time adds up
11:21:37 <Zylaaa> it's 2013
11:21:38 <Cale> pmade: actually, it's not *quite* like that
11:21:42 <Zylaaa> I was bugging on here about this in 2008
11:21:44 <applicative_> Zylaaa: the syntax is fine the moronic demos I made are because _1 and _2 are the only 'accessors' I can remember that are in scope
11:22:12 <Cale> pmade: There's an extension which lets you make a default method implementation with an explicit type signature which may be more constrained than the actual general method is
11:22:16 <dmwit> Zylaaa: How much of those five years have *you* spent solving the record problem?
11:22:24 <applicative_> I hope none of the record-reform proposals are accepted
11:22:27 <Zylaaa> I have other problems to solve for work, dmwit
11:22:33 <typoclass> applicative_: lens has TH magic to auto-generate accessors for any record type, doesn't it?
11:22:33 <pmade> Cale: ah. Okay.  I think I have a way to do what I want.
11:22:41 <Cale> pmade: So you can use that to supply a default implementation in the case that there's an instance of another class available (allowing you to leave the instance declaration blank)
11:22:58 <supki> typoclass: not really "any"
11:23:07 <dmwit> Zylaaa: And that's the way of it. People have more important, useful things to work on. NEXT!
11:23:09 <applicative_> typoclass: yes, but Zylaaa likes ocaml
11:23:24 <ab9rf> no language can be all things to all people
11:24:03 <applicative_> @faq can Haskell be all things to all people?
11:24:03 <lambdabot> The answer is: Yes! Haskell can do that.
11:24:07 <supki> typoclass: well, any if you are in H98
11:24:10 <ab9rf> applicative_: haha
11:24:24 <Zylaaa> I write some little thing that has 30 closely related objects that go into a file. They are not generic and resusable, they are structures and internal details for this thing. And this thing is a file. In haskell, realistically, this thing is a difficult to work with FOLDER
11:24:28 <pmade> Cale: Thank you.
11:24:37 <Zylaaa> I can't read the crap at once and scroll down the text with my eyes like I do in OCaml or C++
11:24:48 <Zylaaa> It turns into a filesystem organizational attack
11:24:51 <Zylaaa> I do not like it at all
11:24:54 <Zylaaa> Because it's wrong
11:25:01 <Zylaaa> these are implementation details local to the thing I am working on
11:25:13 <sproingie> Haskell :: forall things. forall people. things -> people
11:25:14 <typoclass> supki: ok thanks for clarifying. (i didn't phrase this well, i meant "these lens accessors don't just work for a few built-in things")
11:25:33 <Zylaaa> Nor do I like coming up inventive field names or not using names at all in this case
11:26:08 <dmwit> I got trolled. =(
11:26:41 <typoclass> Zylaaa: you can add small prefixes or suffixes to the field names. you don't need to be very inventive
11:26:47 <Zylaaa> No
11:26:49 <Zylaaa> That ruins it
11:26:58 <dmwit> typoclass got trolled. =(
11:27:19 <typoclass> dmwit: i don't think it's trolling to voice a frustration?
11:27:24 <Zylaaa> The field names are expressive with regards to their harmonical function, in this case. I want to use 'b7', for flat7 function, not _piece_of_crap_b7
11:27:35 <Zylaaa> The whole point is short names
11:27:39 <Cale> Zylaaa: You can create a typeclass for each field whose instances are types having a field with that name
11:27:40 <Zylaaa> It's a non issue in OCaml/C++
11:27:54 <dmwit> I think it's trolling to voice it for 30 minutes even after being pointed at the stuff people are trying as solutions.
11:28:01 * ab9rf resists the urge to say "then use OCaml/C++"
11:28:02 <Zylaaa> Cale, too much text
11:28:05 <ab9rf> oops, too late, i said it
11:28:12 <sproingie> dmwit: then to suddenly veer onto a tangent about filesystem organization
11:28:13 <Cale> Zylaaa: not really
11:28:21 <Zylaaa> The text should be expressive for the data only
11:28:30 <Zylaaa> I can do that in JS
11:28:36 <ab9rf> i believe that a programmer should use the language in which s/he can write a solution to the problem at hand most efficiency.
11:28:40 <sproingie> well shee-it, do it in JS then
11:28:48 <ab9rf> (which for me would _never_ be English)
11:29:21 <pascha> i thought i could have scalarProduct :: Point -> Point -> Double and scalarProduct :: P -> P -> Double. what do i need to do? instace class?
11:29:22 <ab9rf> if you can most efficently write a correct solution to whatever problem you're tryig to solve in C++, _then use C++_
11:29:36 <sproingie> i can't believe the hodgepodge hackjob that still goes on in JS.  want to enable a strict mode?  "use strict"; at the beginning of a function.
11:29:44 <sproingie> that's right, a string literal.
11:29:54 <Cale> Zylaaa: Well, there are advantages to this way -- specifically, that things are (1) typechecked, and (2) still polymorphic in such a way that functions written to use these polymorphic labels can be given types which express that polymorphism.
11:29:55 <lispy> Zylaaa: You'll certainly have to read code differently in C++ than in Haskell. I think that's independent of records.
11:30:19 <dmwit> pascha: Yup, sounds like a typeclass to me!
11:30:33 <dmwit> pascha: Bonus points for using one of the ones that's already on Hackage.
11:30:57 <dmwit> ?hackage vector-space for example
11:30:57 <lambdabot> http://hackage.haskell.org/package/vector-space for example
11:31:05 <Cale> Zylaaa: That's usually a big enough advantage that I don't mind the one or two extra lines of code at all.
11:31:25 <lispy> Zylaaa: I go between Haskell, C, and C++ quite a bit and it always takes me a bit to get the mental shift in place. It's not comfortable, but I don't know of any fixes for it.
11:31:30 <totimkopf> Hi, I'm still reading LYAH and I'm totally blown away by this tiny bit of code: let listOfFuns = map (*) [0..]; (listOfFuns !! 4) 5
11:31:34 <Zylaaa> Cale may I please see a few LOC of your example for foo.x and bar.x?
11:31:48 <ab9rf> lispy: for a while i wa sgoing between ruby and C++.  that got seriously confusing at atimes.
11:31:49 <totimkopf> doesn't the !! need for the list to return first?
11:32:01 <Mortchek> sproingie, JS up to ES5 is encumbered by backwards compatibility. A string literal statement didn't already have any meaning, and a new kind of statement would mean your code couldn't be run by engines not implementing it.
11:32:09 <applicative_> > let listOfFuns = map (*) [0..] in (listOfFuns !! 4) 5
11:32:09 <Eduard_Munteanu> :t (!!)
11:32:10 <lambdabot>   20
11:32:11 <lambdabot> [a] -> Int -> a
11:32:17 <Botje> totimkopf: what do you mean by 'return first'?
11:32:25 <tgeeky> Eduard_Munteanu: yes, I did that, but it doesn't tell you, really
11:32:28 <dmwit> totimkopf: Aha! Welcome to laziness. =)
11:32:30 <Zylaaa> lispy: Not reading the program code differently cause I meant I can make structures of data in a local file using hierarchical names (before any program code)
11:32:30 <totimkopf> well the infinite list from the map, the [1..]
11:32:40 <applicative_> > let listOfFuns = map (*) [0..] in zip listOfFuns [5..10]
11:32:42 <lambdabot>   [(*Exception: showsPrec: No overloading for function
11:32:44 <ab9rf> totimkopf: for !! to work you only need the first n element sof the list
11:32:45 <parcs> totimkopf: !! only traverses the list up to the element you want to access
11:32:52 <Eduard_Munteanu> tgeeky: erm... what question are you answering to?
11:32:52 <ab9rf> > [0..] !! 6
11:32:54 <lambdabot>   6
11:32:55 <applicative_> woops
11:33:01 <Mortchek> Haskell is blessed in a way that it's *meant* to be experimented with and hopefully has fewer of those sorts of monkey patches.
11:33:02 <Philippa> Cale: I'd certainly like 'nominal labelling' at times - labels that can be declared somewhere and used in terms of that declaration rather than a single global namespace for them
11:33:03 <applicative_> > let listOfFuns = map (*) [0..] in zipWith ($) listOfFuns [5..10]
11:33:04 <lambdabot>   [0,6,14,24,36,50]
11:33:13 <tgeeky> totimkopf: it will have to wait for the length of the list that you requested. If you do (!! 10^65) you'll be waiting.
11:33:16 <lispy> Zylaaa: So, you want explicit namespaces for Haskell? (as in, separate from the module system)
11:33:30 <ab9rf> i'm vaguely of the opinion that haskell record syntax was a mistake in the first place, and would prefer not to see it made worse by excessive tinkering
11:33:41 <totimkopf> laziness is alien to me
11:33:43 <tgeeky> Eduard_Munteanu: :t (!!) doesn't tell me anything about the strictness, does it?
11:33:43 <Philippa> lispy: I think "separate from the module system" would be the real problem there :p
11:33:45 <Cale> The Haskell module system is basically *only* namespaces, so adding another module system would be weird
11:33:49 <Zylaaa> lispy: hierarchical namespaces, of which a module of course creates one, and a record creates one
11:33:51 <ab9rf> totimkopf: nonstrictness takes a while to get used to
11:34:03 <Philippa> but then, the module system is the kind of problem that you only know is a problem 20 years of research later anyway
11:34:09 <ab9rf> totimkopf: it's even worse when you move back to an eager/strict language and write lots of nonterminating code as a result
11:34:12 <Zylaaa> why is haskell 'flat'
11:34:13 <Eduard_Munteanu> tgeeky: well sure, I had no idea he meant anything about strictness though
11:34:15 <lispy> Zylaaa: I see.
11:34:37 <lispy> Zylaaa: Have you seen how Agda does this?
11:34:38 <Cale> Also, the fact that the module path separator and qualifier were chosen to be '.' is already awkward enough, without overloading it further.
11:34:41 <totimkopf> so if I understand this correctly, (!!) is a lazy function... and that's why this madness is happening?
11:34:51 <tgeeky> Eduard_Munteanu: oh. That was the first thing that popped into my head.
11:34:53 <elliott> hmm, another Oleg interleave argument I don't get the point of. :/
11:34:58 <applicative_> fancy modules would be much nicer than fancy records
11:34:59 <Botje> totimkopf: no, [0..] is a lazy infinite list
11:34:59 <applicative_> maybe
11:35:04 <Philonous> totimkopf:  The list isn't actually a value, it's a thunk, that is, a recipe for creating the value. And it will only ever create as many elements as you demand from it.
11:35:06 <totimkopf> ahh, right
11:35:09 <Botje> totimkopf: map f [0..] creates another lazy infinite list
11:35:19 <Zylaaa> lispy, Agda is amazing to look at and want to learn :) but I never coded in it
11:35:22 <Botje> totimkopf: and map f [0..] !! 5 grabs one element from that list.
11:35:26 <Zylaaa> lispy, tell me
11:35:26 <Mortchek> >> let a = 1:a in take 10 a
11:35:28 <Mortchek> > let a = 1:a in take 10 a
11:35:28 <Cale> Function composition is the most important operator in Haskell, and having its name stolen by lowly record selection would suck :P
11:35:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
11:35:30 <Eduard_Munteanu> > take 5 [0..]
11:35:32 <lambdabot>   [0,1,2,3,4]
11:36:03 <Zylaaa> Cale: Isn't the 'flat' argument valid? Why is haskell flat?
11:36:14 <Cale> What do you mean?
11:36:18 <Zylaaa> the namespacing
11:36:26 <Cale> There are hierarchical modules
11:36:37 <Cale> Use modules for namespacing, that's what they're for
11:36:47 <Zylaaa> That's what I mean
11:36:47 <Philonous> totimkopf:  And it's not so much that (!!) is lazy (it's not), but that lists are lazy. "List" is actually a bit of a misnomer.
11:36:57 <Zylaaa> Cale: The modules are flat
11:37:00 <totimkopf> so if I were to make the list finite, no more thunk?
11:37:05 <Cale> I don't understand what you mean by flat then.
11:37:09 <Philippa> Cale: it's only the names that're hierarchical though, and sometimes that's not a totally unfair complaint
11:37:09 <Zylaaa> a flat graph
11:37:11 <Eduard_Munteanu> totimkopf: that still results in a thunk
11:37:12 <Cale> Could you define it formally?
11:37:17 <Zylaaa> Cale: there's no hierarchy
11:37:19 <ab9rf> totimkopf: haskell is nonstrict (which is not the same as "lazy") by default.  there are some functions that are defined to be strict in one or more of their arguments, and there are some exceptions but in general you can usually safely assume that haskell is lazy
11:37:36 <Cale> What would be different if it weren't flat?
11:37:40 <Zylaaa> A .. Z connect to AA,   never A->Y->AA
11:37:44 <Philonous> totimkopf:  You have to explicitly force the thunk to make it a 'proper' list. Lists are always lazy, even when finite.
11:37:48 <Philippa> module Foo where {module Bar where {...}}
11:37:49 <Cale> I don't understand
11:38:03 <magicman> There should be some sort of notation to denote how much of the arguments is evaluated depending on how much of the function's result is evaluated.
11:38:05 <Eduard_Munteanu> I guess he means first-class, nestable modules?
11:38:06 <Philippa> Cale: our modules would look more like an ML-style system
11:38:07 <lispy> Zylaaa: I haven't taken the time to study their module system, but I know they make distinctions between things like importing versus opening and you can define a module just about anywhere.
11:38:10 <totimkopf> Philonous: what is a 'proper' list?
11:38:16 <Philippa> Eduard_Munteanu: doesn't have to be first-class
11:38:19 <Philonous> totimkopf:  So for example ([1,2, very_expensive_computation] !! 1) will quickly return 1 and not evaluate the expensive computation
11:38:26 <applicative_> you have to explicitly keep forcing the thunks to make it a proper list
11:38:31 <Zylaaa> Cale: For example, a module would be an arbitrary nested system, a file creates a module, you can create modules within modules within modules, and a record creates a module for the record
11:38:39 <lispy> Zylaaa: being able to locally define a module is the part that I think you'd be interested in.
11:38:43 <dmwit> Cale: Perhaps the real complaint here is that GHC only allows each file to contain one module.
11:38:45 <tgeeky> totimkopf: a list of groceries is a proper list.
11:39:01 <Cale> dmwit: I guess that's a practical restriction, but it's... not a big deal
11:39:10 <Zylaaa> Cale it's big
11:39:12 <magicman> That would greatly improve reasoning about runtime complexities as well. Sadly, everything I've come up with is not really expressive enough to be reasonably useful.
11:39:30 <Zylaaa> It's like working in Cubase which has a flat mixer designed from the 1990's when I can use modern stuff that has a graph
11:39:34 <typoclass> Cale: you mean it wouldn't be a big deal to implement?
11:39:36 <Zylaaa> I hate flat stuff
11:39:40 <Zylaaa> It's old
11:39:40 <Philonous> totimkopf:  In this case I mean a fully evaluated list that doesn't contain any deferred computations, like you would have it in a strict language.
11:39:48 <Cale> typoclass: I mean it's not a big deal not having it
11:39:48 <dmwit> typoclass: Correct. Other compilers do not have this restriction.
11:39:58 <ab9rf> Philonous: it's fairly hard to do that in haskell
11:40:01 <Philippa> could be worse. Some of us remember when Cubase didn't mix
11:40:08 <applicative_> tgeeky: i keep adding to my grocery list
11:40:18 <Cale> You just... make another source file, and problem solved.
11:40:34 <totimkopf> I need to do some more exercises to get used to this laziness stuff
11:40:38 <Zylaaa> Cale: The important point there is that the Record should create the same type of module
11:40:41 <Zylaaa> as a Module
11:40:46 <Zylaaa> namespacing should be unified
11:40:49 <Cale> Zylaaa: Why don't you just make a module
11:40:56 <Cale> Namespacing is unified!
11:40:58 <lispy> Zylaaa: I guess it really comes down to this: Haskell was created for research; a common *simple* purely functional language with lazy evaluation for researchers to extend and play with. We haven't had enough researchers come through and work on the modules/records.
11:40:59 <Philippa> Cale: give or take the part where our editors still aren't that good as IDEs so navigation blows up. But it will anyway as your codebase gets big
11:41:00 <Philonous> totimkopf:  It can be mind-boggling, yes.
11:41:01 <Zylaaa> Because there's such a thing as implementation details
11:41:06 <typoclass> Cale: true :-) as far as i could understand, Zylaaa has dozens of records and finds it awkward to have one file (= module) per record
11:41:06 <ab9rf> haskell's flat namespace is a common complaint
11:41:09 <Zylaaa> And reading a text file
11:41:21 <Zylaaa> Cale: I want to read the text file romantically with my eyes
11:41:24 <Philippa> typoclass: quite
11:41:28 <Eduard_Munteanu> I wish we had Agda's module stuff.
11:41:33 <tgeeky> applicative_: that's fine. But it's not infinite. When you add something to your grocery list, it changes.
11:41:33 <Zylaaa> ok but you provided a solution for that
11:41:36 <ab9rf> i'm not sure why, because honestly it's easy enough to deal with if you're a fairly disciplined programmer, and if you're writing in haskell yuo're probably already fairly disciplined in the first place.
11:41:37 <Philippa> which is a shame, because the text file wishes you'd just take it to bed...
11:41:43 <applicative_> Nothing is more pleasant than reading a Haskell file.
11:41:45 <Cale> Get a text editor which can open more than one file side by side?
11:41:45 <lispy> (the run-time and compilation of Haskell are not simple, but the semantics are simple in the sense that they are fairly close to declarative)
11:41:55 <Zylaaa> Cale: Dont argue for the past
11:41:59 <Zylaaa> why do it
11:42:07 <Cale> Why do what?
11:42:08 <magicman> Agda's module stuff is awesome *nod*
11:42:09 <typoclass> Eduard_Munteanu: how does agda's modules work?
11:42:18 <typoclass> Eduard_Munteanu: (if that can be described in 2 sentences)
11:42:20 <Zylaaa> Cale why argue that the way things are is "the answer"
11:42:26 <Philippa> Cale: I dunno about you, but I've worked on several machines I'd really rather not have to do that for in the last year *and I stick to 80 char columns*
11:42:34 <Zylaaa> The answer is being mad about the way things are
11:42:39 <Philippa> Zylaaa: Cale isn't doing that
11:42:50 <ab9rf> Zylaaa: i think you're not winning many converts.
11:42:52 <Philippa> Cale is offering you the answers that are likely to be achievable in, say, the next 5 years
11:42:58 <Cale> Zylaaa: I'm not doing that, I'm arguing that your future is not necessarily that interesting :)
11:42:58 <Eduard_Munteanu> typoclass: if you're asking about the implementation, not sure. But you can declare stuff like parametrized, nested modules and open them up.
11:43:11 <Zylaaa> Fair point Cale
11:43:40 <Zylaaa> Cale, it solves the thingy though, and the required carnage is just syntax
11:43:46 <Zylaaa> Does not break Haskell
11:43:48 <Philippa> Cale: eh. It might not be /interesting/, but it's that little less painful. How would you design the language starting from scratch (but not allowed dependent types), knowing what we know today? In particular, what we know today about the relationship between MLish modules and type classes?
11:44:00 <Cale> There are much more expressive things you can do right now with a very small amount of syntactical noise, most of which can be elided by Template Haskell stuff.
11:44:26 <Philippa> Zylaaa: I'd recommend having a play with lenses, FWIW. I'm still pretty avoidant myself, but not so much so that I can't admit it
11:44:30 <totimkopf> also what is the difference between laziness and nonstrictness, I see these words passed around in the same sentence a lot
11:44:35 <Cale> i.e. use polymorphic lenses instead
11:44:49 <typoclass> Eduard_Munteanu: ah interesting. so i could do something like "open this file; somecode; close the file", and in "somecode" there'd be (say) a function "read" and "write" available, where in haskell you have to pass around a parameter explicitly ("read handle", "write handle")
11:44:51 <Philippa> totimkopf: non-strictness is a semantic property('s absence). Laziness is an implementation strategy that provides it
11:44:53 <Cale> It might be nice to build *that* more into the language
11:45:04 <koninkje> totimkopf: f is strict just in case f undefined == undefined
11:45:14 <Philippa> Cale: yeah, I'd definitely be up for seeing more of the language you get if you start with lenses
11:45:46 <totimkopf> ah, I think I understand enough to move on from asking that question :)
11:45:48 <Zylaaa> I hate to say it, I don't want more text than the data. Cause I can do that in JS.
11:45:50 <koninkje> totimkopf: laziness is a technique for allowing non-strict functions, and also memoization
11:46:06 * typoclass . o O ( "more of the language you get if you start with lenses" <- kmettskell )
11:46:08 <Eduard_Munteanu> typoclass: yeah, you could parametrize modules by handles
11:46:08 <totimkopf> aha
11:46:19 <totimkopf> laziness makes nonstrictness possible
11:46:20 <typoclass> Eduard_Munteanu: very nice. interesting
11:46:31 <ab9rf> parameterization of modules does sound interesting
11:46:37 <applicative_> > const 3 undefined
11:46:38 <lambdabot>   3
11:46:44 <lispy> totimkopf: I usually think of laziness as a form of being nonstrict
11:47:37 <koninkje> totimkopf: "laziness" can mean a few different things. Sometimes it means call-by-need (== call-by-name with memoization). Other times it means the opposite of "eager"
11:47:57 * totimkopf 's head spins around
11:48:00 <shachaf> O'
11:48:03 <shachaf> Er.
11:48:05 <lispy> s/memorization/sharing
11:48:09 <Cale> Zylaaa: You can do that in JS, but you get no typesafety, and no real ability to do type-directed selection of code.
11:48:17 * typoclass waves hello at shachaf
11:48:21 <applicative_> totimkopf: if __ then ___ else ___ is non-strict in most languages ... why not make almost everything like that? ;)
11:48:32 <koninkje> totimkopf: re eagerness, imagine a language where nontermination isn't a problem... now, (f x) must give the same answer regardless of whether we evaluate x now or later
11:48:59 <Cale> Zylaaa: If anything, things are moving more in the direction of accepting being forced to write more type signatures in exchange for more expressiveness about static constraints.
11:49:01 <koninkje> totimkopf: In an eager language (e.g., call-by-value) we must evaluate x before we can evaluate the application in (f x)
11:49:05 <tromp_> the answer may just take a day longer...
11:49:06 <totimkopf> applicative_: how exactly are those non-strict?
11:49:24 <koninkje> totimkopf: in a lazy (==non-eager) language, we can wait and evaluate x whenever it's needed by f
11:49:48 <totimkopf> ok
11:49:55 <koninkje> totimkopf: in languages which allow non-termination (or other side-effects), things get more complicated sine order of evaluation affects the result
11:50:20 <applicative_> totimkopf: you dont evaluate the two dependent things a and b in if p then a else b, before evaluating the whole
11:50:35 <koninkje> so there are at least three different ideas in play: eager vs non-eager, strict vs non-strict, memoized vs non-memoized
11:51:26 <haskellN00b> totimkopf:  Lazyness makes everything "pull" in nature which flips everything around.  e.g.  in C++ you would hate to see something like:   "this " ++ "is " ++ "a " ++ "really " ++ "inefficient " ++ "string." because every application of ++ is going to traverse the entire string (well it would if the string were a linked list as it is in Haskell) before tacking the right hand side onto it
11:52:21 <shachaf> haskellN00b: No, because (++) associates to the right.
11:52:27 <haskellN00b> totimkopf: Haskell, by contrast can do that in one pass because that string ends up on the end of something like:     take 100 ....       which is like saying "give me the next char, ok I got it, now I need another"
11:52:32 <shachaf> a ++ b ++ c is a ++ (b ++ c)
11:53:06 <shachaf> If it didn't work that way you could expect the same efficiency problems, if delayed.
11:53:07 <applicative_> > let ifff !a !b !c = if a then b else c in (ifff True 1 undefined, if True then 1 else undefined)
11:53:09 <lambdabot>   (*Exception: Prelude.undefined
11:53:16 <haskellN00b> shachaf: yes, which is why in Haskell it doesn't have to rerun the whole string to take additional strings on.  But in a strict language it will have to traverse ... oh maybe you wouldn't
11:53:16 <applicative_> ha
11:53:25 <koninkje> haskellN00b: that's not quite right...
11:53:27 <applicative_> > let ifff !a !b !c = if a then b else c in ifff True 1 undefined
11:53:29 <lambdabot>   *Exception: Prelude.undefined
11:53:30 <Cale> argh
11:53:34 <Cale> this discussion...
11:53:39 <ab9rf> heh
11:53:40 <applicative_> > if True then 1 else undefined
11:53:40 <elliott> Cale++
11:53:41 <lambdabot>   1
11:54:06 <haskellN00b> Which discussion?
11:54:07 <Cale> Okay, let me get things straightened out here
11:54:19 <applicative_> uh oh
11:54:23 <Cale> Let's contrast lazy and strict evaluation
11:54:35 <Cale> I'm going to give my favourite little example
11:54:42 <fizbin> Cale: with [1..] ?
11:54:43 <Cale> Suppose we have double x = x + x
11:54:54 <Cale> and we want to evaluate double (double 5)
11:54:56 <applicative_> totimkopf: here comes your well practiced tutorial
11:55:08 <totimkopf> :)
11:55:13 <Cale> Under strict evaluation, we evaluate expressions innermost-first
11:55:20 <Cale> so this reduces like:
11:55:22 * koninkje takes issue with Cale's use of "lazy" vs "strict" above...
11:55:24 <Cale> double (double 5)
11:55:29 <Cale> -> double (5 + 5)
11:55:36 <Cale> -> double 10
11:55:39 <Cale> -> 10 + 10
11:55:41 <Cale> -> 20
11:56:21 <Cale> We could also opt to evaluate expressions in another order, for example, always choosing the outermost (leftmost) reducible subexpression
11:56:32 <Cale> Then we'd get:
11:56:36 <Cale> double (double 5)
11:56:41 <Cale> -> (double 5) + (double 5)
11:56:50 <Cale> -> (5 + 5) + (double 5)
11:56:54 <Cale> -> 10 + (double 5)
11:57:00 <Cale> -> 10 + (5 + 5)
11:57:03 <Cale> -> 10 + 10
11:57:05 <Cale> -> 20
11:57:21 <applicative_> more steps im worried
11:57:33 <Cale> But now we've wasted a bunch of time evaluating double 5 twice, because x occurred twice in the body of  double x = x + x
11:57:48 <Cale> So lazy evaluation makes a refinement to this
11:57:50 <lispy> if only we could compute it once and share the results...
11:58:24 * applicative_ breathes what is called a sigh of relief
11:58:41 <Cale> yes: any variable which is bound to an expression is evaluated at most once, and the results of this evaluation shared between the occurrences
11:58:49 <haskellN00b> You're showing memoization, which is a nice property of non-strict evaluation but that's not something you see while programming.  The "pull" nature of it, though, you see constantly in everything you do in Haskell.
11:59:14 <Cale> We can represent this sharing using let ... in ... and then see what the evaluation looks like in this case:
11:59:18 <Cale> double (double 5)
11:59:23 <elliott> haskellN00b: it's sharing, not memoisation
11:59:27 <haskellN00b> I mean I guess you'll see it if you did:   double (double functionToGetANumberThatTakesTwoHours)
11:59:29 <elliott> and actually, Cale's last evaluation trace had no sharing
11:59:32 <Cale> -> let x = double 5 in x + x   -- note that this is still outermost first!
11:59:46 <Cale> -> let x = 5 + 5 in x + x
11:59:50 <Cale> -> let x = 10 in x + x
11:59:54 <Cale> -> 10 + 10
11:59:55 <Cale> -> 20
11:59:57 <applicative_> haskellN00b: not much need have been calculated yet
12:01:09 <Cale> So: strict (innermost-first) evaluation evaluates each argument to a function exactly once, while normal-order (outermost-first) evaluation evaluates each argument to a function zero-or-more times, and lazy evaluation gets the best of both worlds, evaluating each argument zero-or-one times.
12:01:39 <haskellN00b> shachaf:  Actually, thinking about it the Haskell version of the example I gave is more efficient than the C++ one provided you don't use the whole string
12:01:55 <typoclass> Cale: that way of explaining it is very well thought through, thanks a lot
12:02:00 <Cale> (of course, you pay some cost of having to represent expressions at runtime, while strict evaluators may not have to be able to do that)
12:02:48 <haskellN00b> shachaf:  since even though it binds to the right, Haskell is still going to "pull" from the left-most string first and only start pulling from the next right string when the left most runs out.
12:03:22 <Cale> and that's all there is to lazy evaluation pretty much: it's just outermost first evaluation, plus sharing of evaluation of bound variables
12:03:52 <Cale> The efficiency/inefficiency of (++) has nothing to do with lazy evaluation
12:04:10 <Cale> It has to do with the fact that lists are immutable
12:04:26 <fizbin> I have lst::[Foo] and indexFunc::(Foo -> Bar), and Bar has Eq and Ord instances defined. I want a function that gives Just (Foo, Foo) if there are two Foo in lst that have equal indexes after going through indexFunc. (And Nothing otherwise) I'd like to do this more quickly than my current method which is basically: lst & map (indexFunc &&& id) >>> sort >>> zip `ap` tail >>> find (\x y -> fst x == fst y) >>> liftM (snd.fst &&& snd.
12:04:28 <maksbotan> is there good symbolic computations library for haskell? with automatic similar terms addition and fractions support?
12:04:43 <tgeeky> maksbotan: no
12:04:58 <Cale> So xs ++ ys must take at least O(length xs) time (even given that it can refer to ys as an eventual tail of the list it constructs)
12:05:02 <elliott> haskellN00b: I find this "pull" nomenclature strange.
12:05:13 <maksbotan> tgeeky: no at all?
12:05:18 <haskellN00b> Cale: Surely it does?  Like let's say you're doing:     take 5 $ "abc" ++ "def" ++ "efg"
12:05:25 <maksbotan> that's a pity, yeah
12:05:35 <tgeeky> maksbotan: in this case especially, patches welcome.
12:05:36 <haskellN00b> without looking, ++ must be defined something like
12:05:39 <typoclass> elliott: i read it as something like "things are evaluated only when needed" ...
12:05:44 <maksbotan> oh
12:05:45 <haskellN00b> [] ++ ys = ys
12:05:54 <Cale> haskellN00b: Well, in that case, lazy evaluation certainly helps, but people were talking about how it's bad to associate (++) to the left
12:05:54 <typoclass> elliott: but sure. it's not the usual phrasing
12:06:21 <Cale> lazy evaluation is only going to help things here
12:06:54 <tac> typoclass: So if you're writing Haskell programs for fun, you don't really *need* to be writing them, so they never get evaluated, right? :)
12:06:58 <Cale> (apart from some small amount of overhead cost that you'll pay everywhere throughout the language implementation for having to be able to represent expressions at runtime)
12:07:10 <pascha> does haskell have a hashing lib?
12:07:14 * fizbin sees that clearly he'll want to wait until this discussion is over. Something with Data.Map maybe...
12:07:23 <Cale> pascha: sure, what kind of hash do you want?
12:07:37 <fizbin> tac: Unfortunately, my boss is strictly evaluating my output.
12:07:53 <typoclass> tac: yes, that's the dictionary definition
12:08:03 <pascha> i need a oneway hashing function for SRP6: http://srp.stanford.edu/design.html
12:08:10 <haskellN00b> nevermind, lost it (not enough sleep) but in any case take pulls the first char, that comes from the left most list, which finally creates its first entry.  This continues until xs is exhausted and we finally have to evaluate ("def" ++ "efg")
12:08:41 <haskellN00b> but in c++ the whole thing has to be put together before we can move to the function that is using the result
12:08:50 <Cale> pascha: will this do? http://hackage.haskell.org/package/cryptohash-0.9.0
12:09:07 <fizbin> pascha: Or even http://hackage.haskell.org/package/Crypto-4.2.5.1
12:09:20 <elliott> fizbin: wow, that point-free code...
12:09:48 <elliott> hmm
12:09:55 <fizbin> Yeah, I screwed up the type of the argument to "find", but that's essentially what I'm doing.
12:10:18 <elliott> :t M.fromListWith
12:10:20 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
12:10:46 <elliott> do you need that "sort"?
12:11:13 <fizbin> Except I want to bail as soon as I find any two equal Foos. I only do a sort in mine because, well, I'm just using a list...
12:11:24 <fizbin> I don't care which two Foos I find.
12:11:52 <pascha> isnt cabal install cryptohash correct cabal syntax?
12:12:01 <pascha> Cale: ty
12:12:35 <Cale> pascha: yes, that's correct
12:14:15 <pascha> maybe i need to update cabal...
12:14:24 <fizbin> I was thinking about maybe using foldM over lst with a function that had the signature (M.Map Bar Foo)->Foo->Either (Foo, Foo) (M.Map Bar Foo) and then using Left to signal "found a hit" and Right to pass on an updated map.
12:15:05 <dcoutts> pascha: that's always been the syntax, what error are you seeing?
12:16:03 <fizbin> @pl \x y -> fst x == fst y
12:16:03 <lambdabot> (. fst) . (==) . fst
12:16:15 <Taneb> :t (==) `on` fst
12:16:17 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
12:16:26 <fizbin> :t on
12:16:27 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:16:33 <typoclass> fizbin: yes, you might be interested in 'on' and 'comparing'
12:16:37 <Taneb> (on is in Data.Function)
12:17:16 <typoclass> > sortBy (comparing length) $ words "the cat's meow" -- fizbin, an example
12:17:17 <haskellN00b> Hrm, back to my issue, it's not so easy to make a "Read" like I need because it seems for "Read" to work I need a neutral representation that can then be turned into the concrete representation (e.g. Read is String -> a).  But I'm having trouble coming up with something that would be neutral that I can make an instance for
12:17:18 <lambdabot>   ["the","meow","cat's"]
12:17:57 <fizbin> Well, okay, but still I think I want to rid myself of sort.
12:18:22 <Eduard_Munteanu> haskellN00b: what sort of datatype are you trying to read?
12:18:41 <fizbin> "on" and "comparing" are just going to eliminate the last little bits of point-ness in that code, not make it faster.
12:18:54 <haskellN00b> I can try:    data DBResult = Table1Result Table1 | Table2Result Tabl2 ...            but how would I make instances of such a thing?  If I make a "Read" for DBResult then I'm stuck in the same problem again: I can't return two different types from that, only one
12:19:27 <Boreeas> :t comparing
12:19:28 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:19:41 <haskellN00b> Eduard_Munteanu: I'm actually trying to return a record as the results of a query.  My test code is located at:  http://hpaste.org/85607
12:19:41 <Eduard_Munteanu> haskellN00b: what different types? You have two constructors, each holding a different thing.
12:19:46 <elliott> fizbin: note that taking prefixes of a sufficiently lazy sort is "optimal"
12:19:55 <elliott> fizbin: http://apfelmus.nfshost.com/articles/quicksearch.html
12:21:40 <haskellN00b> Eduard_Munteanu:  Well, in the example I gave, I'd like to define:    class Result a where render :: DBResult -> a              and then      instance Result Table1Result where render (Table1Result r) = r
12:22:03 <fizbin> Hrm. Perhaps except I very strongly don't care that I get the "first" pair of Foos. There ought to be some way to get some mileage out of the fact that I'll take any pair.
12:22:19 <pascha> I managed to install cryptohash but could not find module Crypto
12:22:26 <haskellN00b> but I'm not going to be allowed to make an instance on Table1Result since that's a constructor, not a type.  But if I make an instance on DBResult then how can I return either Table1 or Tabl2?
12:22:35 <pascha> do i need to add some path somewhere as well? this is ghci that is copmplaining
12:23:56 <haskellN00b> likewise, if I make a newtype for Table1 and Table2 then I can't define a class that will take either of those and return the appropriate class.  I'm stuck. :(
12:24:04 <Eduard_Munteanu> haskellN00b: those are constructors, not types
12:24:23 <supki> pascha: well, cryptohash does not include Crypto module
12:24:29 <haskellN00b> Eduard_Munteanu: I know, hence my problem. :)
12:24:30 <Eduard_Munteanu> haskellN00b: data constructors, even.
12:26:38 <Eduard_Munteanu> haskellN00b: well, make that 'a' refer to the type of the stuff contained by that constructor
12:27:02 <Eduard_Munteanu> instance Result Table1 where ...
12:28:20 <haskellN00b> Eduard_Munteanu: I don't see how that will fix my problem.  Have I made it clear what I'm actually trying to do?  Sometimes I don't come accross so clearly even in person, much less in text. :)
12:29:17 <haskellN00b> Eduard_Munteanu:  What I want is, well, if you look at the code I pasted at http://hpaste.org/85607 and look at the foo function.  That's what I'm trying to do.  Notice that the insert function returns a Country record in one case and a State record in another case.
12:30:08 <Eduard_Munteanu> Not really. :)
12:30:20 <Eduard_Munteanu> But maybe I'm tired.
12:30:59 <haskellN00b> No, it's likely me.  But if you have time, have a look at that code.  I think it will be obvious from the foo function what I'm trying to do (note: that code doesn't compile because of the TxtDriver instance)
12:32:16 <pascha> supki: well what do i import then?
12:32:24 <supki> pascha: import what?
12:32:36 <haskellN00b> Oh, I guess I could try Multiparameter type classes, that might actually fix it.  Hadn't even thought of going outside vanilla H98
12:33:31 <tac> Vanilla Haskell 98 is not much to work with
12:34:07 <haskellN00b> (well, to be honest, I figure that stuff isn't on by default for a reason.  Turning it on probably makes certain other things not decidable or something, i.e. advanced users only)
12:34:35 <tac> haskellN00b: most of those reasons are related to the historical development
12:34:48 <tac> There are plenty of extensions people would consider "standard" and totally safe
12:37:00 <haskellN00b> tac: Ok, I'll trust you.  I just read a rant from Luke Palmer about turning off Monomorphic restriction
12:37:22 <tac> heh
12:38:50 <tac> http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid I think this is it
12:39:06 <tac> A list of some safe, good-to-know extensions
12:39:23 <haskellN00b> thanks
12:39:41 <pascha> http://srp.stanford.edu/design.html ;; so N could always be the same? and apparently if q is prime then so is N if N=2q+1?
12:39:56 <pascha> hey, thats not true...
12:40:06 <supki> Undecidable instances should be in The Good =(
12:40:07 <pascha> q=13=>N=27!=prime
12:40:11 <tac> That list seems to be missing Rank2Types / RankNTypes
12:40:15 <tac> which is also super common and useful
12:41:13 <pascha> N    A large safe prime (N = 2q+1, where q is prime)
12:41:13 <pascha>        All arithmetic is done modulo N.
12:41:22 <pascha> can someone explain? that doesnt make N prime...
12:42:43 <typoclass> supki: i have not opinion on this, but i believe what the lambdacats say http://li8-215.members.linode.com/img/lambdacat-undecidable-instances.jpg
12:42:47 <simpson> pascha: He's saying that a large safe prime is a prime n for which n = 2q + 1, where q is some prime integer.
12:42:50 <int-e> pascha: both N and 2q+1 are supposed to be prime
12:43:59 <shachaf> int-e: Well, given that N = 2q+1...
12:44:14 <int-e> like q=3, N=7.
12:44:19 <pascha> ok but the N can always be the same N?
12:44:31 <pascha> so how do i find that...
12:44:37 <pascha> google huge prime table
12:45:00 <simpson> pascha: Well, you'd want to generate a random prime.
12:45:21 <simpson> pascha: http://crypto.stackexchange.com/questions/71/how-can-i-generate-large-prime-numbers-for-rsa
12:46:11 <simpson> pascha: So you'd generate q this way, and then verify that n is prime as well. Or generate n this way and verify that q is prime? I'm not sure which is more effective.
12:48:29 <int-e> playing with gp (which has a cute nextprime() function) ... p = 17557322358563247959 and 2*p + 1 = 35114644717126495919 are both prime.
12:48:59 <hherhold> ghci question- if you make a new module, say "Shapes" and you make a Shapes directory
12:49:15 <hherhold> then you make a "Cubes.hs" and a "Spheres.hs" in Shapes
12:49:41 <hherhold> if you then try to do a :m + Shapes.Cubes in ghci, it fails until the modules have been compiled
12:49:52 <hherhold> is there a way to tell ghci to compile them on the fly?
12:50:56 <pascha> so you do it probabalistically not deterministically?
12:51:05 <pascha> well, apparently, just surprised
12:52:25 <pascha> should i do it in C and then FFI to haskell?
12:52:50 <int-e> shachaf: even  n=10^200+random(10^200);n=nextprime(n);while(!isprime(2*n+1),n=nextprime(n+1));n  finishes in a few seconds in gp. So finding such primes (Sophie Germain primes) is not terribly hard.
12:53:05 <shachaf> int-e: ?
12:53:13 <shachaf> int-e: You said that both N and 2q+1 are prime.
12:53:17 <shachaf> int-e: I said that N = 2q+1.
12:53:25 <pascha> ah interesting, deterministic fails because of hardware also
12:53:37 <int-e> I guess I meant pascha.
12:54:08 <pascha> what is gp?
12:54:24 <int-e> http://pari.math.u-bordeaux.fr/
12:55:55 * hackagebot adp-multi-monadiccp 0.1 - Subword construction in adp-multi using monadiccp  http://hackage.haskell.org/package/adp-multi-monadiccp-0.1 (MaikRiechert)
12:56:30 <hpaste> haskellN00b revised “Database mapper toy fail”: “Winning like Sheen” at http://hpaste.org/85607
12:57:34 <hpaste> haskellN00b revised “Database mapper toy fail”: “Winning like Sheen” at http://hpaste.org/85607
12:57:53 <adimit> is there a package which uses the detailed-0.9 interface for Cabal's test suite driver with quickcheck2? I can only find people using the exitcode one, and I'm starting to wonder if the detailed-0.9 thing is worth it…
12:58:18 <haskellN00b> I tried the multiparam class to do my return types.  Now I can't figure out how to actually return them. heh
13:06:40 <haskellN00b> I think my problem is, I can't figure out how to name the multiparameter type class so as to use it as a constraint.  That is, if I want to say a paramter must be an Eq then I can do   Eq a => a -> ....     But how would I do:  Result a b -> ?
13:06:52 <haskellN00b> google isn't helping me out either. :(
13:07:06 <supki> Result a b =>
13:07:26 <haskellN00b> and what will I use in the function signature after that?  a or b?
13:07:38 <supki> both?
13:07:52 <haskellN00b> so like
13:08:18 <haskellN00b> f :: Result a b => String -> ?     -- I want to return a Result a b here
13:08:42 <supki> you can't return constraint
13:09:22 <ab9rf> you have to return an a or a b
13:09:26 <ab9rf> or a b
13:09:34 <ab9rf> or some other thing that is a type, not a type constraint
13:09:47 <haskellN00b> can I say:     f :: Result a b => String -> a b    ?
13:10:01 <ab9rf> haskellN00b: if a is a type constructor and b is a type, yes
13:10:31 <haskellN00b> would you mind having a look at http://hpaste.org/85607  and tell me where I'm going wrong? :)
13:10:42 <haskellN00b> I put "PROBLEM" in the areas that are failing to compile
13:10:43 <sellout-> haskellN00b: If you want to return some kind of Result a b, then you need to include f in the typeclass definition, and implement it for the various types that are instances of that class.
13:10:44 <ab9rf> :t return
13:10:45 <lambdabot> Monad m => a -> m a
13:11:42 <djahandarie> pmade, that BoundedList thing is actually pretty interesting.
13:12:02 <djahandarie> I have a solution but there are a lot of isomorphic inhabitents of the type I made, so I'm seeing if I can get something nicer.
13:12:40 <djahandarie> Probably Saizan or copumpkin could do it better than me
13:12:45 <pmade> djahandarie: Wow, thanks.  I'd like to see what you have but I'm afraid that I won't understand it.
13:13:30 <djahandarie> Let me roll back my code a little then, moment
13:14:54 <pascha> can types have properties? can they in any lang? what is it called?
13:15:16 <pascha> like miller_rabin :: Int(Odd, >3) -> Double
13:15:38 <Taneb> Not in Haskell
13:15:39 <Eduard_Munteanu> pascha: dependently typed languages are one way
13:15:43 <hpaste> djahandarie pasted “BoundedList” at http://hpaste.org/85614
13:15:47 <sellout-> pascha: Maybe dependent types? Look at Agda.
13:15:53 <djahandarie> pmade, ^
13:16:23 <djahandarie> Another way to construct f would be Cons 1 (Up (Up Eq)) (Cons 2 Eq Empty) for example
13:16:29 <djahandarie> And that's kind of ugly
13:16:42 <pmade> djahandarie: reading it now.
13:17:00 <djahandarie> You can see another in-progress attempt at making the compiler figure it out in the comment, but I don't think it's going to work
13:17:09 <djahandarie> I think there might be a nice solution which I'm not seeing
13:18:15 <pmade> I don't think I can understand this without a concrete example.
13:18:27 <djahandarie> a through f are all examples of lists
13:18:33 <pmade> But don't worry yourself about that, you've already spent way too much time on this.
13:18:41 <djahandarie> Only because it's fun.
13:18:57 <pmade> djahandarie: Ah, I see the examples now.
13:20:48 <djahandarie> I also don't really like how the inhabitent of BoundedList Z (S (S Z)) Int is required to be different from the inhabitent of BoundedList (S (S Z)) (S (S Z)) Int
13:21:32 <djahandarie> (Even though it's representing the same list)
13:21:54 <mjrosenb>     readObj' is not a (visible) method of class `ReadObj'
13:22:13 <mjrosenb> oh...
13:22:18 <djahandarie> The commented out stuff can't really infer everything needed unfortunately, though it can make SOME lists if you tell it enough stuff when you build the list
13:22:21 <mjrosenb> that is a very silly way of phrasing that.
13:22:33 <djahandarie> I think it's useless for anything practical though
13:23:18 <djahandarie> Maybe a nicer way would be to make a Vec and then base BoundedList around Vec, so the proofs are only in one place rather than spread throughout the list, but it still has the problem that the inhabitants are different from one another
13:23:45 <djahandarie> Hmm
13:25:05 <pascha> write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1 // how would i do that easily?
13:25:16 <pascha> 2^s*d
13:26:28 <djahandarie> If you could lift GADTs to the type/kind level that'd certainly make this easier :(
13:28:16 <NemesisD> hi guys. i've got a library i'm using in my test suite. it is compiled from a directory on my machine instead of hackage via cabal-dev because i'm not prepared to release it yet
13:28:37 <NemesisD> yet for some reason whenever i try to use it, the linker barfs and complains about undefined references to closures
13:29:11 <lispy> NemesisD: Have you already tried a clean build?
13:29:13 <hpaste> NemesisD pasted “linker error” at http://hpaste.org/85616
13:29:27 <NemesisD> lispy: i recently nuked the cabal-dev directory
13:29:36 <NemesisD> installed that other lib via cabal-dev ../httpmock
13:30:26 <lispy> NemesisD: and then the command that fails is "cabal-dev install"
13:30:52 <lispy> ?
13:31:06 <NemesisD> lispy: well the install works ok, but then when i try to run my tests for the proj i'm including it in with cabal-dev configure --enable tests && cabal-dev build it dumps that error
13:31:53 <NemesisD> compiling the library itself when installing it into this proj seems to go fine
13:32:29 <lispy> NemesisD: Hmm...I wonder if this is due to something with the 'tests' command
13:34:06 <NemesisD> lispy: hmm yeah. whenever something goes wrong with the linker, it becomes officially over my head
13:34:29 <NemesisD> this id efinitely making me skiddish about releasing the other package on hackage if this is what's going to happen to users
13:34:45 <pascha> The standard way to generate big prime numbers is to take a preselected random number of the desired lengt
13:34:54 <pascha> how can I get a random number of a certain length?
13:35:44 <ab9rf> generate random bits until uou have enough
13:36:13 <dEPy> using <*> with two functions is the same as composition right?
13:37:15 <hpaste> djahandarie annotated “BoundedList” with “BoundedList (annotation)” at http://hpaste.org/85614#a85617
13:37:59 <djahandarie> pmade, ^ has much nicer inhabitants, but is more annoying to use, and I think it's going to break entirely when the lists aren't available at compile time. Good times.
13:38:34 <djahandarie> Because the LTE proofs essentially disappear when they are type families like that.
13:38:45 <NemesisD> lispy: any idea on what my next step should be?
13:39:50 <djahandarie> I think what I want is a GADT that has unique values for proofs that a <= b <= c
13:40:15 <pascha> R.getStdRandom (R.randomR (a, b)) <- is that usign system clock?
13:40:40 <Eduard_Munteanu> dEPy: no
13:40:40 <ab9rf> pascha: the internal randomizer is implementation-specific
13:40:52 <Eduard_Munteanu> :t (<*>)
13:40:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:41:02 <ab9rf> pascha: it might use the system clock or a system entropy source like linux's /dev/random
13:41:15 <pmade> djahandarie: It's going to take me some time to decode and understand this.
13:41:38 <Eduard_Munteanu> (r -> a -> b) -> (r -> a) -> (r -> b)
13:41:48 <djahandarie> (pmade, LTE stands for "less than or equal", btw)
13:41:57 <Eduard_Munteanu> If you mean using the (->) r instance.
13:42:05 <pmade> djahandarie: That's helpful, thank you.
13:42:29 <mjrosenb> ugh.  this is very much not working
13:42:31 <djahandarie> "Vec" is a list with its length stored in the type
13:43:18 <dEPy> Eduard_Munteanu, sry I meant <$>
13:43:29 <djahandarie> So basically what I do is generate a Vec, and then just have the compiler enforce that the Vec's length is between the specified bounds
13:44:01 <mjrosenb> so I want something like ReadS, except rather than returning a list of possible matches, I want the function to take an extra parameter that gives enough context to parse it correctly
13:44:18 <Eduard_Munteanu> dEPy: yeah, that's like fmap for Applicatives, which is like (.) for Reader :)
13:44:23 <djahandarie> There's simply no way this is going to work though, there essentially needs to be proofs getting passed around at runtime for this to work with user-inputed stuff I think
13:44:36 <mjrosenb> where every type that can be read out has a unique bit of context that will allow you to read it correctly.
13:46:16 <pmade> Last question of the day.  Is there a way to write a generic zipper for accessing the fields of any record in order?
13:46:16 <mjrosenb> so for example, reading an integer or a tuple needs a unit context, since that should always be unique
13:46:27 <mjrosenb> but reading a list needs an integer to say how long the list is.
13:48:24 <Eduard_Munteanu> pmade: how would you deal with different field types?
13:48:35 <acowley> pmade: Check out vinyl
13:48:55 <acowley> mjrosenb: Sounds like a class with an associated type family.
13:48:59 <pmade> Eduard_Munteanu: in my case they are all instances of the same class.
13:49:06 <pmade> acowley: Thank you.
13:52:36 <jacob__> I am trying to create a function that will take a list of pairs and using map return just the first of each pair into a new list
13:52:50 <parcs> i think base should be split into two packages, one that is absolutely ghc-version-dependent and one that is not
13:52:56 <jacob__> this is what I am thinking http://codepad.org/kFO4Sx5l but it doesnt seem to work very well
13:55:11 <thetallguy1> so, we just switched to ghci 7.6.2, and now it seems :browse puts the package name and version everywhere in the output
13:55:15 <Eduard_Munteanu> jacob__: first, your type is wrong
13:55:31 <thetallguy1> which makes it way too verbose to read
13:55:42 <thetallguy1> anyone know how to restore the old behavior?
13:55:59 <Eduard_Munteanu> jacob__: then the number of arguments is wrong
13:56:10 <jacob__> I am trying to teach myself as I go along here so I am a noob no doubt
13:56:25 <lispy> NemesisD: make a simpler example of what you're doing that still fails but that you feel comfortable sharing
13:56:41 <lispy> NemesisD: and then file a bug report on the github page for cabal-dev :)
13:56:49 <Eduard_Munteanu> jacob__: ok, fsts takes in a [(x, y)], but the output is supposed to be a list of those x's. Do you see why?
13:57:26 <acowley> thetallguy1: That means you have multiple versions of a package installed, and is often a sign of an impending cabal collapse.
13:57:27 <jacob__> because x is the first of each pair
13:57:53 <Eduard_Munteanu> jacob__: right, so   fsts :: [(x, y)] -> [x]
13:58:17 <thetallguy1> acowley:  hmmm, thank.  don't use cabal, except for exploration.  Perhaps I can just clean my .cabal dir.
13:59:25 <acowley> thetallguy1: I usually remove everything (~/.cabal and ~/.ghc) if I get to that point, but perhaps others have less drastic approaches.
13:59:31 <Eduard_Munteanu> :t fst
13:59:33 <lambdabot> (a, b) -> a
13:59:51 <Eduard_Munteanu> jacob__: now you need to figure out how to use map to extend that to a list
14:01:03 <thetallguy1> acowley: done, but it doesn't fix the problem.  However, it seems to be only one package, so perhaps there is something wrong with it's config
14:01:12 <thetallguy1> acowley: thanks for the hint
14:01:47 <jacob__> map (fsts) [x,x] or something of that nature. because I want to map the output of fsts and create a new list of x of both pairs
14:01:57 <acowley> thetallguy1: np, it's unfortunately an issue that comes up pretty regularly
14:03:11 <NemesisD> lispy: both projects are open source. maybe i can try hsenv though
14:03:13 <Clint> jacob__: you're trying to filter on fst?
14:07:06 <pascha>  if a^(n-1) not congruent with 1 mod n, then return composite. how do i calc the congruence efficiently
14:08:01 <sipa> pascha: http://en.wikipedia.org/wiki/Exponentiation_by_squaring
14:09:38 <pascha> i shouldnt do a^(n-1)?
14:09:57 <sipa> assume a is 2
14:10:17 <sipa> what size will n be?
14:10:21 <jacob__> not filter per say just place the output of my function definition into map and make a new list with the result. so if I give it fsts[(5,6) , (2,7)] it will return (5,2)
14:10:38 <pascha> why?
14:10:39 <pascha> http://en.wikipedia.org/wiki/Fermat_primality_test
14:12:14 <sipa> pascha: yes, for the input you're considering; what will n be?
14:12:21 <sipa> what order of magnitude?
14:12:30 <hpaste> haskellN00b revised “Database mapper toy fail”: “Simplified, still flaming” at http://hpaste.org/85607
14:12:41 <pascha> i dont get the algorithm at all, isnt it missing info? it doesnt sya how to calc prob prime at all
14:12:45 <pascha> http://en.wikipedia.org/wiki/Fermat_primality_test
14:12:58 <haskellN00b> Ok, so I've changed my approach a bit based on reading:  http://stackoverflow.com/questions/8434842/polymorphic-return-types-depending-on-context
14:13:34 <sipa> pascha: you calculate a^(n-1), take the modulus for dividing by n, and check whether the result is 1
14:13:35 <haskellN00b> now my problem is decode is failing because it claims to be ambitious.  But I actually want that to be polymorphic.  I tried removing the Nomonomorphism restriction but that doesn't change anything
14:13:39 <sipa> pascha: that is the naive algorithm
14:14:00 <sipa> pascha: my question to you is, for what sort of N do you want to use this test?
14:14:26 <haskellN00b> There must be some way to do what I'm trying to do, I just can't figure it out. :(
14:14:30 <pascha> yes but is that also the probability? it cant be...
14:14:39 <sipa> pascha: no
14:15:06 <sipa> pascha: it's the number you want to test
14:15:36 <pascha> n yes
14:15:51 <pascha> n will be huge
14:15:56 <sipa> pascha: give an example
14:18:02 <acowley> haskellN00b: It looks like you've got a bit too much return type polymorphism there. Are you trying to have "get" return whatever type of value results from the query?
14:19:23 <hpaste> haskellN00b annotated “Database mapper toy fail” with “Thought this might fix it, but no change” at http://hpaste.org/85607#a85619
14:20:19 <haskellN00b> Tried constraining a further in the get function but it seems to want something concrete.  If it gets anymore concrete it won't be polymorphic anymore. :(
14:20:38 <mjrosenb> acowley: entirely possible.  I was trying to do it with fundeps, and it was not really working.
14:20:38 <acowley> That's the reality, though.
14:21:03 <acowley> haskellN00b: You need to limit the type of values returned by "get". The usual approach is a data type.
14:21:44 <haskellN00b> acowley: that's exactly what I don't want to do.  I want what get returns to depend on context
14:22:18 <zammy> lol
14:22:53 <haskellN00b> acowley: I was hoping I could somehow use a type class to be able to return something different depending on how get was called, as "read" does but I haven't worked out how to do it so far
14:22:58 <merijn> haskellN00b: With your code, the *caller* gets to decide which b they get. Not the redis code
14:23:48 <haskellN00b> merijn: That's still ok.  I realize this will mean a runtime error if they say they want a Country but they did a query for State.  If I can get this working I can try to tighten things like that down later
14:24:00 <merijn> haskellN00b: Hmm, wait, I think I see what you want
14:25:07 <pascha> how do i get Ints? R.getStdRandom (R.randomR (a, b))
14:25:29 <merijn> :t R.getStdRandom
14:25:30 <lambdabot> Couldn't find qualified module.
14:25:45 <geekosaur> someon e's trying to extract the Int from an IO Int, one suspects
14:25:56 <geekosaur> @quote /bin/ls
14:25:57 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:26:17 <merijn> haskellN00b: Why are you using those Country/State Result newtypes?
14:27:12 <haskellN00b> merijn: hrm..., well that may be a hold over from my last approach.  You think I could get what I want without them?
14:27:40 <merijn> Well, they don't seem to do anything, so at least they're not helping
14:27:57 <merijn> haskellN00b: What error are you getting? (if anything)
14:28:04 <haskellN00b> oh!  I'm already returning differen things in sendcommand aren't I
14:28:04 <hpaste> acowley annotated “Database mapper toy fail” with “Thought this might fix it, but no change (annotation)” at http://hpaste.org/85607#a85620
14:28:07 <geekosaur> pascha: you don't "get Ints" from IO Ints, except in the middle of a do block which is in IO. have you studied how IO works in Haskell yet?
14:28:10 <haskellN00b> ambigious a0
14:29:13 <merijn> haskellN00b: The problem it has is that the "a" parameter in the get typeclasses isn't in the typesignature, so it doesn't know which a to pick
14:29:41 <mjrosenb> ok, I have something that compiles, but it requires MultiParamTypeClasses,FunctionalDependencies,UndecidableInstances,FlexibleInstances
14:29:49 <mjrosenb> I feel like not all of these should be required.
14:30:10 <dmwit> Does FunDeps not imply MPTCs?
14:30:12 <pascha> why would i sue the fermatTest?
14:30:28 <mjrosenb> dmwit: oh, I can probably kill that one.
14:30:35 <mjrosenb> dmwit: yeah
14:30:38 <haskellN00b> merijn: arg, I removed the entire decode machinery and all that happened was the ambiguity moved to send command.  *scream*
14:30:45 <hpaste> merijn annotated “Simplified, still flaming” with “why not” at http://hpaste.org/85618#a85621
14:30:48 <mjrosenb> I'm just a bit annoyed by the undecidable instances one.
14:31:00 <dmwit> mjrosenb: Show us!
14:31:25 <pascha> The standard way to generate big prime numbers is to take a preselected random number of the desired length, apply a Fermat test (best with the base 2 as it can be optimized for speed) and then to apply a certain number of Miller-Rabin tests (depending on the length and the allowed error rate like 2−100) to get a number which is very probably a prime number.
14:31:36 <hpaste> haskellN00b annotated “Database mapper toy fail” with “Removing the decode bit” at http://hpaste.org/85607#a85622
14:31:36 <merijn> haskellN00b: Why not the approach I just pasted?
14:31:53 <pascha> I dont get the approach. how do I get from random number to prime? millr rabin is just a test...it cant geenrate a prime can it?
14:32:04 <hpaste> acowley revised “Thought this might fix it, but no change (annotation)”: “cleanup” at http://hpaste.org/85620
14:32:22 <byorgey> pascha: if you find that the number is not prime, you pick another random number and try again
14:32:28 <byorgey> repeat until you find a prime.
14:32:32 <merijn> haskellN00b: You forget to change the b in your get type signature
14:32:55 <merijn> haskellN00b: You have "DBMonad m a" but it returns "m b" instead of "m a" :)
14:33:04 <merijn> That's why that one complains
14:33:08 <byorgey> I have no idea what the word 'preselected' is supposed to mean there.
14:33:53 <mjrosenb> dmwit: https://gist.github.com/5367373
14:33:56 <pascha> byrogey: seems very slow...
14:34:11 <merijn> pascha: Well, yes
14:34:18 <pascha> what are the odds of finding a prime by generating random nbrs...?
14:34:22 <acowley> haskellN00b: Does the code I pasted up there help?
14:34:24 <merijn> pascha: How would you do it faster?
14:34:25 <haskellN00b> merijn: did we just do the same thing, or did I trash yours?
14:34:34 <merijn> haskellN00b: We did approximately the same
14:34:38 <pascha> merijn: i dont have a clue... :)
14:34:40 <dmwit> pascha: Sometimes, things are not what they seem!
14:34:51 <merijn> haskellN00b: http://hpaste.org/85618#a85621
14:34:56 <pascha> but how slow could one expect this to be on average?
14:34:58 <merijn> pascha: afaik there are no faster ways
14:35:07 <armlesshobo> How would I split an Integral into 4 Word8 values?
14:35:29 <merijn> pascha: Fairly slow, generating new keys on my BSD machines can take up to a couple of seconds if the random device is not well seeded with entropy
14:35:39 <dmwit> armlesshobo: Perhaps you would use quotRem and 2^8
14:35:42 <merijn> pascha: Then again, you don't usually have to generate many primes
14:36:05 <haskellN00b> marijn: yes that works
14:36:23 <merijn> haskellN00b: It's basically the same as yours, you just forgot to fix get's type signature
14:36:24 <haskellN00b> acowley: haven't tried yours yet
14:36:39 <armlesshobo> dmwit: like, if i'm given 0xFFEEDDCC, I want 0xFF 0xEE 0xDD 0xCC for each Word8 value.
14:36:54 <Clint> what if you're given something bigger than 32 bits?
14:37:07 <armlesshobo> Clint: i only use up to 32bits
14:37:08 <mjrosenb> dmwit: do you think it would be possible to give an instance of Monad for this class?
14:37:14 <armlesshobo> the rest gets "tossed"
14:37:15 <armlesshobo> Clint: ^
14:37:19 <Clint> ah
14:38:00 <armlesshobo> I (for no real practical reason) am making a Color type
14:38:01 <dmwit> armlesshobo: Yes, I understand what you want. Do you understand what I suggested?
14:38:05 <merijn> armlesshobo: xor with everything 1, except the last 8 bits, convert the result to Word8. Shift 8 bits right and repeat 3 times
14:38:27 <haskellN00b> merijn, acowley:  I went down this approach to solve my problem but now that you all got this working for me I'm not sure this will do what I want.  I'll have to experiment with it some more.
14:38:45 <pascha> so should i do fermattest first then millerrabin? why not just millerrabin? they compensate each other well?
14:38:52 <armlesshobo> dmwit: no, I don't
14:38:53 <merijn> haskellN00b: I think it probably won't, but I'm not really sure
14:39:03 <merijn> pascha: Presumably fermat is a lot faster but less accurate
14:39:07 <Tene> pascha: perhaps fermat is faster to fail?
14:39:20 <dmwit> > (quotRem 0xffaa 255, (0xff, 0xaa))
14:39:22 <lambdabot>   ((256,170),(255,170))
14:39:35 <dmwit> whoops!
14:39:36 <merijn> pascha: So you do fermat first to cheaply throw out the "obvious" primes and only try miller-rabin on the "better" candidates
14:39:41 <merijn> eh
14:39:42 <dmwit> > (quotRem 0xffaa (2^8), (0xff, 0xaa))
14:39:44 <lambdabot>   ((255,170),(255,170))
14:39:45 <merijn> obvious non-primes
14:40:13 <armlesshobo> dmwit: :O thank you :)
14:40:13 <dmwit> mjrosenb: I'm not sure that makes sense.
14:40:16 <haskellN00b> merijn: I'll re-annotate with what I had before.  It's quite a mess but the foo function is the only thing of interest, maybe I'll just annotate that
14:40:34 <dmwit> mjrosenb: But if you're asking whether there are monads that wrap up the type in this class, then yes.
14:40:37 <staafl> dmwit, thanks again for the help
14:40:43 <dmwit> staafl: =D
14:40:52 <staafl> I ended up writing a Newton-Raphson
14:41:06 <hpaste> haskellN00b annotated “Database mapper toy fail” with “Here is what I'm going for” at http://hpaste.org/85607#a85624
14:41:16 <staafl> but I had an algorithm error somewhere else
14:41:18 <dmwit> mjrosenb: readObj :: ReaderT p (State [[String]] a)
14:41:57 <dmwit> mjrosenb: By the way, are you sure you want a class here at all...?
14:42:02 <haskellN00b> Maybe it works, I'm just concerned that by using the instances of the return types like this, I've already locked in what the query has to do before it's even ran.  But maybe that's actually correct
14:43:52 <merijn> haskellN00b: Well, yes, the type inference locks in what a query has to return
14:44:18 <merijn> btw, "x <- foo; return x" (as hlint points out) is identical to just "foo"
14:44:40 <dmwit> mjrosenb: Anyway, a transliteration to type families requires no extensions (other than TypeFamilies, of course).
14:44:43 <dmwit> Are you interested?
14:44:44 <merijn> return is for lifting monadic values, not for returning something from a do block :)
14:45:43 <dmwit> mjrosenb: https://gist.github.com/dmwit/5367461 all code is the same; only the class/instance declarations differ
14:46:26 <pascha> how do I pass IO 2 to a function?
14:46:46 <dmwit> pascha: That's ill-formed. IO is a type constructor, and 2 is not a type.
14:46:59 <mjrosenb> dmwit: ooh, neat.  I didn't know that instances could declare local types like that.
14:47:01 <dmwit> Perhaps you want return 2 :: IO Integer, for example?
14:47:16 <dmwit> mjrosenb: Oh, it's actually just a pretty lie.
14:47:36 <dmwit> mjrosenb: I'll make you a gist showing what it really is, one second...
14:48:50 <merijn> Ha! I sense another TypeFamilies convert coming soon :>
14:49:02 <dmwit> mjrosenb: The updated gist is 100% identical except that the error messages may be a bit worse.
14:49:15 <dmwit> Isn't that funny? =)
14:50:20 <mjrosenb> that looks awful
14:50:30 <mjrosenb> but is basically exactly what I'd wanted
14:50:52 <mjrosenb> icing would be if ((),()) could be collapsed into ()
14:50:53 <dmwit> You are of course welcome to use the pretty version!
14:50:57 <dmwit> mjrosenb: ah, yeha
14:51:05 <dmwit> It can be done, but it's a bit trickier.
14:51:21 <dmwit> I did something like this for edit-lens...
14:51:36 <pascha> how is the C preprocessor invoked?
14:56:04 <dmwit> Is the C preprocessor invoked?
14:56:19 <pascha> is there some way to use >>= with False/True? just continue if true...?
14:56:20 <dmwit> I sort of always assumed GHC just had a self-contained clone of it that knew a bit about Haskell.
14:56:27 <dmwit> :t when
14:56:28 <lambdabot> Monad m => Bool -> m () -> m ()
14:56:46 <c_wraith> dmwit: given how many basic haskell constructs break it, I'm betting it's usually real cpp
14:56:47 <dmwit> ...and its brother, unless.
14:59:54 <otters> :t ((),())
14:59:56 <lambdabot> ((), ())
15:00:00 <otters> the owl type
15:01:42 <hughfdjackson> i could be wrong in this understanding, but does haskell require that i import a function in order to access properties of a datatype?
15:02:35 <geekosaur> what are "proeprties of a datatype"?
15:03:10 <geekosaur> Are you trying to do dynamic typing? Reflection? Pretending there isn't a type system?
15:03:18 <hughfdjackson> geekosaur: nup
15:03:20 <hpaste> haskellN00b annotated “Database mapper toy fail” with “Here I am so far, closer than before” at http://hpaste.org/85607#a85625
15:03:37 <geekosaur> so what are you talking about, then?
15:04:01 <hughfdjackson> specifically, if i have a type declared using the record syntax, and a value of that type
15:04:28 <haskellN00b> marijn: Ok, I just pasted a version that's much closer to what I'm trying to do.  This approach does seem more promising.  It's not compiling at the moment because I think insert is defined wrong and it's too late in the evening for me to have enough brain power left to resolve it
15:04:30 <hughfdjackson> am i right in thinking that i need to use a specific function to inspect each property?
15:04:44 <hughfdjackson> :3 i could be wildly off the mark here - reading simultaniously from lyah
15:04:45 <haskellN00b> marijn: I hope it's clear from this what I'm trying to do
15:05:09 <geekosaur> oh, you may be thinking of a fact that you can import a type without its constructors, which would indeed hide the details
15:05:35 <geekosaur> or export without its constructors in which case the importer can't get at them anyway
15:05:49 <hughfdjackson> aha - i think i've got this a little backwards in my head :D thanks for the sanity check
15:06:01 <geekosaur> constructors must be visible. but, while they act a bit like functions, they are in some sense actually values
15:06:40 <c_wraith> I think the worst is that you can export a function using a data type that isn't exported.  If you expert an appropriate set of them, clients can use them all together - so long as they don't use the types in an annotation
15:06:44 <geekosaur> data Maybe a = Nothing | Just a -- Nothing and Just are data constructors. Just acts like a function, Nothing like a value
15:06:49 <merijn> haskellN00b: Yeah, looks clear what you're trying to do, but I'm not sharp enough to spot any mistakes right now :)
15:06:57 <geekosaur> if you hide them, well then yes, you can't do anything with a Maybe
15:07:36 <haskellN00b> merijn: thanks. :)  Well, insert is definitely defined wrong since the dbInsert should be modifying the state but it's just being passed as state without modification along with the dbInsert call.
15:08:40 <merijn> haskellN00b: Why have "Table = CountryTable | StateTable" in the first place?
15:09:06 <merijn> haskellN00b: Why not have "Table Country" and "Table State" types?
15:12:56 <hughfdjackson> geekosaur: is it uncommon to think it weird that a function has to be imported to inspect each property of a value created by the record syntax?
15:13:04 <hughfdjackson> (i believe that's what RWH is saying here: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html)
15:13:52 <hughfdjackson> a static type system could stop you accessing non-existant data without requiring that you 'pollute' (for want of a better word) a module's namespace with functions for that purpose, right?
15:14:06 <geekosaur> you'r still saying function and I cannot tell if you mean data constructor or something else
15:14:26 <hughfdjackson> ah; i probably mean constructor
15:14:29 <hughfdjackson> :#
15:15:03 <geekosaur> so now I'm trying to understand the confusion here
15:15:14 <hughfdjackson> data Customer = Customer { customerID :: CustomerID } <- creates a `function` that returns a Customer's CustomerID
15:15:20 <hughfdjackson> heh; i think i really do mean function
15:15:24 <haskellN00b> merijn: The Table type is there so I can provide functions for the invidual tables (e.g. T.state would return a wrapped State table).  I may not end up needing this but I'm assuming tables will actually carry some implementation information with them and not be nice for clients to use directly
15:15:34 <pascha> Couldn't match expected type `Bool' with actual type `m0 b0' because of isMillerRabinPrime :: Integer -> IO Bool , b <- MR.isMillerRabinPrime r, why?
15:15:36 <geekosaur> maybe it's just the confusing aspect of records in Haskell, which are kinda known to be annoying
15:16:21 <geekosaur> pascha, if isMillerRabinPrime is a pure function, you need to use let instead of <-
15:16:49 <pascha> it it IO Bool, thats not pure is it?
15:17:05 <geekosaur> hughfdjackson, record accessors are in fact a bit strange in Haskell and there is an ongoing (long ongoing with no resolution in sight) discussion of how to fix it
15:17:30 <haskellN00b> merijn: also, I want clients to use the types they want (e.g. State, Country) but they can't use that for e.g. inserts because they won't be specifying the whole thing.  That is, if I have a table like:            Country { id, name, insertedDate }    the client will probably only want to specify the name, letting the db handle the defaultable fields.  If I don't use some kind of signal class to represent the Country table then I 
15:17:30 <hpaste> hughfdjackson pasted “Record syntax” at http://hpaste.org/85626
15:17:33 <haskellN00b> fields
15:17:36 <pascha> and i cant pattern match against case IO b of ->
15:17:36 <geekosaur> pascha, no, it's not pure, but I haven't seen any other code so I have no other guesses as to what is going on. nor did you include the full error so I can't even be sure what it's complaining about
15:17:44 <hughfdjackson> geekosaur: aha :) okay
15:17:59 <merijn> haskellN00b: Yes, but then you could just have "Table t s" where t is the table type (i.e. Country, State, etc) and s is the data providing functions for the specific table?
15:17:59 <hughfdjackson> i've posted the example i'm playing with on ghci to hpaste
15:18:10 <hughfdjackson> i'm guessing there's no other way to inspect the Customer value I'm creating, right?
15:18:34 <geekosaur> hughfdjackson, you can also pattern match against the constructor by position
15:18:41 <hughfdjackson> ouch :#
15:18:47 <hughfdjackson> devil and the deep blue sea
15:18:59 <geekosaur> if Customer only has customerID in it, you can pattern match (Customer a) and a is the customerID
15:19:03 <merijn> haskellN00b: Sounds like you want to merge values while inserting, rather than doing that in the clients code?
15:19:15 <haskellN00b> merijn: exactly
15:19:20 <hughfdjackson> aye - but in realistic applications, it's bound to be more
15:19:23 <hpaste> pascha pasted “IO Bool” at http://hpaste.org/85627
15:19:34 <hughfdjackson> in my day to day job, it's not *entirely* uncommon for 50+ keys
15:19:55 <hughfdjackson> I guess you just import the module in question as qualified instead
15:20:28 <haskellN00b> merijn: like, "insert T.country [F.name "USA"]"         might return a record like:            Country { id = 1, name = "USA", insertDate = "04.12.2013 12:20:30" }
15:20:57 <hughfdjackson> :p still strikes me as odd, given that if you had some 'symbol' type, you could statically analyse if `get :customerID myCustomer` was valid for the type
15:21:31 <geekosaur> pascha, line 139 of that paste needs to be ```return False```
15:21:49 <haskellN00b> merijn: what I don't like about existing database access solutions is that none of them seem to let you use the power of the db fully without resorting to raw SQL.  I want to allow things like letting the DB fill in default fields and I don't want to have to force clients to wrap all their fields with Maybe to accomplish that
15:21:59 <pascha> ah, ofc
15:22:23 <hughfdjackson> s/symbol type/symbol syntax/
15:23:28 <geekosaur> pascha: I think that error happened because you didn't provide a type signature for millerRabinNTimes so it tried to guess one from what you wrote and guessed wrong due to the missing return
15:24:51 <merijn> haskellN00b: Clients could just pass "undefined" for empty fields that you fill in later
15:25:09 <merijn> haskellN00b: Also, there's the Data.Default typeclass for filling in default values
15:25:25 <hpaste> haskellN00b annotated “Database mapper toy fail” with “Appears to work now (though state does nothing)” at http://hpaste.org/85607#a85628
15:25:42 <geekosaur> hughfdjackson, all I can suggest is you go over the stuff on the haskell wiki about record types
15:26:15 <geekosaur> your symbol thing looks a lot like some of the proposed replacements for haskell's record system... but nobody can agree as to details
15:27:06 <hughfdjackson> hehe - as a javascript engineer watching the ECMAScript committee draw out discussions for what seems like forever, i'm not entirely surprised
15:27:12 <hughfdjackson> i'll take a look - thanks for your patience
15:27:32 <pascha> can i have a do in case x of -> do ?
15:27:40 <geekosaur> yes
15:27:56 <haskellN00b> merijn: first of all, I don't like users filling in dummy fields for extra data instead of only specifying the fields they want.  Second of all, how can I check if they filled in undefined?  That would crash if I tried to look, no?
15:28:08 <ciaranm> do is just a pretty way of writing >>= \
15:28:48 <haskellN00b> merijn: but in any case, thanks very much to you and everyone else who helped me.  I would have never made it this far without help.  Time for me to sleep before the wife gets up and yells at me for being irresponsible. :)
15:31:19 <haskellN00b> merijn: oh, I've looked at Data.Default before.  It doesn't solve my problem because if the user doesn't specify a value then I want to skip it in the insert statement (think "insert (name) into Country values("USA")).  If I use something like data default then all fields will be filled in and I won't know if they are default because the user didn't set them or did the user actually pick the default by coincidence
15:32:12 <haskellN00b> merijn: And if I simply send everything then to get the proper behavior I would have to keep my client code defaults in sync with what the database has set for defaults.  Much nicer if I can just not send values that weren't explicitly set so the db can set them
15:33:35 <haskellN00b> again, thanks for the help.  Night all
15:44:39 <pascha> g    A generator modulo N. what do they mean with a generator? http://srp.stanford.edu/design.html
15:45:07 <simpson> pascha: It's a term from modular arithmetic.
15:45:20 <simpson> pascha: http://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n#Generators
15:45:43 <simpson> pascha: You miiiiight want to sit down and read Applied Cryptography. There's a couple free copies online.
15:48:49 <pascha> @src foldM
15:48:49 <lambdabot> foldM _ a []     = return a
15:48:49 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
15:50:42 <pascha> @hoogle foldM
15:50:42 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:50:43 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
15:50:43 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:52:21 <pascha> How do i fold values from randInRange :: Integer -> Integer -> IO Integer into a string?
15:52:27 <pascha> salt n a b = M.foldM (\ str _ -> str ++ (show $ PG.randInRange a b)) '' [1..n]
15:52:28 <pascha> le fail
15:56:58 <pascha> there muste be a simpelw ay fold it right?
15:58:00 <quchen> Why do you have to fold it? What about "replicateM n $ PG.randInRange a b"?
15:58:08 <quchen> :t replicateM
15:58:09 <lambdabot> Monad m => Int -> m a -> m [a]
15:58:53 <quchen> ... and then show that
16:00:54 <quchen> Also keep in mind that foldM is a left fold, so for a long string that function's going to slow down quite a bit
16:06:16 <pascha> why is left slowrt than right if your going to fold evrything anyway?
16:07:03 <mjrosenb> :hoogle intersect
16:07:22 <mjrosenb> lambdabot: how do I hoogle you?
16:07:44 <typoclass> @hoogle intersect
16:07:44 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
16:07:44 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:07:44 <lambdabot> System.Posix.Files intersectFileModes :: FileMode -> FileMode -> FileMode
16:08:02 <quchen> pascha: (++) is associative in theory, but not in the implementation's speed. If you parenthesize it left-associative, it'll perform much worse.
16:08:28 <quchen> (x:xs) ++ ys = x : (xs ++ ys)
16:08:37 <quchen> So this deconstructs the left list entirely
16:08:54 <mjrosenb> typoclass: you happen to know if intersect assumes that the list is sorted?
16:09:17 <quchen> When you've got something like "(((a ++ b) ++ c) ++ d", each of the parentheses on the left have to be traversed again for each concatenation.
16:09:40 <quchen> With right parentheses, that won't happen.
16:09:49 <typoclass> mjrosenb: not sure, sorry
16:09:52 <quchen> So never left fold a string result.
16:10:10 <pascha> so...what is a generator modulo N?
16:10:15 <pascha> g    A generator modulo N. what do they mean with a generator? http://srp.stanford.edu/design.html
16:10:32 <quchen> mjrosenb: Intersect doesn't haven an Ord constraint. It can't assume sorting.
16:12:01 <quchen> mjrosenb: Also have a look at the source: [x | x <- xs, any (== x) ys] - it's just a list comprehension, no sorting in there
16:13:28 <lightquake> is a `seq` b $ c parsed as (a `seq` b) $ c or a `seq` (b $ c)?
16:14:08 <quchen> lightquake: $ has the weakest possible precedence. It's like an opening parenthesis that reaches to the faaaar right.
16:14:15 <quchen> So it's the first case.
16:14:33 <quchen> Oh, wait. `seq` has a fixity declaration.
16:14:57 <lightquake> i wonder if you can even distinguish those two parses
16:15:27 <quchen> lightquake: I just looked it up with ":i `seq`". Both have infixr 0.
16:15:37 <quchen> So they have the same precedence, and associate to the right.
16:16:00 <lightquake> so it's a `seq` (b $ c)
16:16:15 <quchen> Yep.
16:16:21 * hackagebot toysolver 0.0.4.1 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.0.4.1 (MasahiroSakai)
16:29:37 <lispy> oh man, toysolver looks like the kind of project I would do as a learning project. Very cool.
16:30:10 <lispy> Making a toy implementation in Haskell is such a great way to learn these sort of theoretical things.
16:30:36 <lispy> It's maybe not so great if you want to know how someone would make the architecture in C++
16:56:39 <djahandarie> Does DataKinds give you "free" reification?
16:58:46 <djahandarie> (Seems like it should be easy theoretically-speaking, but I don't seem to see it anywhere in the docs)
17:00:47 <elliott> djahandarie: no, there's infrastructure like the Sing class in GHC.TypeLits and stuff though
17:00:55 <elliott> type erasure makes it more annoying
17:02:53 <Ontolog_> is this a common way of using data: data Vertex a = (Ord a) => a ?
17:03:07 <startling> Ontolog_: no
17:03:08 <Ontolog_> like just to impose some class constraint
17:03:21 <Cale> Ontolog: That isn't even syntactically correct
17:03:30 <simpson> Ontolog: For better or worse, this sort of existential data is not really easy to do.
17:03:35 <simpson> Ontolog: What did you want to build?
17:03:45 <startling> Ontolog: that doesn't usually work out correctly. The better thing to do is impose the class constraint on all the functions working with a Vertex.
17:03:48 <Ontolog> simpson: a graph
17:04:00 <Ontolog> ohh
17:04:09 <startling> I don't think Ontolog wants ExistentialQuantification anyway -- Ord isn't useful at all in that case
17:04:34 <simpson> Ontolog: Do you know about Data.Graph? http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Graph.html
17:04:34 <Ontolog> i'm just wondering if I should even have a Vertex a at all or just deal with an arbitrary a for verticies
17:04:40 <Ontolog> simpson: yes i know about that
17:04:49 <simpson> Er, http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Graph.html
17:05:12 <Ontolog> simpson: yeah i've looked at it, im just building me own for haskell fun
17:05:14 <startling> Ontolog, are these just identifiers for vertices?
17:05:31 <Ontolog> startling: yeah, actually i meant to say Eq not Ord for class constraint
17:06:07 <Ontolog> Cale: what is the correct syntax? data Vertex a = (Ord a) => Vertex a?
17:06:13 <startling> Ontolog: might as well just use Int or whatever for now.
17:07:00 <Ontolog> well i thought it might be useful to make a graph out of arbitrary objects
17:07:14 <Ontolog> also i would have to write the Graph module differently that way too
17:07:48 <Cale> Ontolog: That'll be allowed if you enable ExistentialQuantification or GADTs.
17:07:49 <startling> Ontolog: then the best thing to do would just be "newtype Vertex a = Vertex a deriving (Eq, Ord)"
17:08:23 <startling> Ontolog: and then specifying "Eq (Vertex a) =>" for all the functions that need it.
17:08:31 <Cale> and what it'll do is to store the Ord instance inside the constructed Vertex along with whatever value you apply it to, so that when you pattern match on the Vertex constructor, it will discharge any Ord a constraint.
17:08:54 <startling> Cale, that's not very useful though
17:09:05 <Cale> Um... it could be useful.
17:09:14 <Ontolog> "discharge"?
17:09:21 <startling> Cale, all the methods in Ord are binary
17:09:31 <Cale> startling: So?
17:09:45 <Cale> The 'a' also appears in the type, so you could have two Vertex a values
17:09:53 <startling> oh, didn't realize that.
17:10:00 <Cale> You could then write an unqualified instance of Ord for Vertex a
17:10:08 <Cale> instance Ord (Vertex a) where
17:10:19 <Cale>   compare (Vertex x) (Vertex y) = compare x y
17:10:24 <startling> yeah, you're right. my mistake.
17:11:02 <Cale> (well, you'll need to write an Eq instance too :)
17:12:10 <Cale> What *isn't* particularly useful is   data (Ord a) => Vertex a = Vertex a
17:12:40 <Cale> But it's Haskell 98 and doesn't require any extensions
17:13:28 <Cale> This just artificially changes the type of the Vertex data constructor so that it requires an instance of Ord when you construct values, but it doesn't get rid of the need for an instance when you take them apart again.
17:14:31 <Cale> It was a pretty unfortunate language decision, and in the GHC source code, it's even referred to as the "useless context".
17:16:11 <Ontolog> Cale: ohhh wow so if I pattern match on (Vertex x) in a function definition, I can't rely on x being an instance of Ord?
17:16:59 <Ontolog> Cale: but in that case, I guess since you couldn't create the Vertex in the first place if x was not Ord...
17:18:36 <lightquake> Ontolog: correct.
17:18:51 <lightquake> in particular, you can still do x = undefined :: Vertex SomethingWithoutAnOrdInstance
17:21:11 <dmwit> ;quit
17:21:15 <Cale> Ontolog: Yeah, if you want an operational idea of how it works, there is a dictionary of values storing the methods of Ord, and whenever a function has type  (Ord a) => ...  then the compiler turns it into a function of type  OrdDict a -> ...
17:21:28 <benzrf> hello!
17:21:32 <Cale> Ontolog: and when you make your datatype like that, or perhaps more clearly in GADT syntax:
17:21:38 <Cale> data Vertex a where
17:21:46 <Cale>   Vertex :: (Ord a) => a -> Vertex a
17:21:47 <benzrf> I am /just/ starting to learn Haskell...
17:22:10 <Cale> then it stores the OrdDict a alongside the value of type a when you construct each Vertex
17:22:20 <Cale> and then unpacks and uses it when you pattern match
17:22:27 <Cale> benzrf: Hello!
17:22:38 <Cale> benzrf: Feel free to ask any questions you might have
17:22:46 <benzrf> thanks :)
17:22:51 <benzrf> Somebody here told me that Haskell programs do I/O by generating imperative programs.
17:23:09 <Cale> Yeah, that's not a terrible description of it.
17:23:18 <benzrf> ok
17:23:20 <benzrf> well...
17:23:23 <lightquake> wow, 76MB binary
17:23:29 <djahandarie> Could be kind of misleading I think, though.
17:23:31 <lightquake> i bet this is pandoc's fault
17:23:45 <hpc> benzrf: it's also not a good description of it ;)
17:23:50 <benzrf> I was confused, because I figured that meant that the program had to be fully run before it could be run.
17:23:53 <benzrf> sorta
17:23:54 <benzrf> so...
17:23:57 <benzrf> I think I have figured it out?
17:24:24 <hpc> benzrf: essentially, evaluation and execution are two different things
17:24:24 <djahandarie> You could say it has to be fully evaluated, not "run"
17:24:25 <Cale> benzrf: Basically, there are two processes which you can think of as separate, but interleaved:
17:24:25 <benzrf> Does it use lazy evaluation so that it instantly returns, then whenever the imperative program tries to execute a portion, it gets evaluated?
17:24:28 <djahandarie> That's not entirely true either though.
17:24:35 <Cale> There's evaluation, which turns expressions into values.
17:24:39 <hpc> evaluation is what you typically think of when computing a value
17:24:50 <djahandarie> @quote fugue
17:24:50 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
17:24:53 <hpc> execution is when you take an (IO something) value and do magic to it
17:24:57 <Cale> and there's execution, which is carrying out the instructions which are encoded by values of type (IO t)
17:25:13 <Cale> execution is allowed to have any effects your computer can perform
17:25:22 <benzrf> > Does it use lazy evaluation so that it instantly returns, then whenever the imperative program tries to execute a portion, it gets evaluated?
17:25:24 <lambdabot>   <hint>:1:57: parse error on input `,'
17:25:43 <monochrom> benzrf: if you can write a working program, you have figured it out. if you cannot write a working program, you have not figured it out. essay writing is not an indicator of understanding.
17:25:45 <benzrf> making it 'interleaved'?
17:25:50 <Ontolog> benzrf: what do you mean 'instantly returns'?
17:25:51 <benzrf> :P
17:25:56 <Cale> and the 'main' of a compiled Haskell program will be something of type IO t, i.e. a description of stuff to be performed
17:26:00 <benzrf> Well... I have assumed this:
17:26:23 <Cale> Well, it actually doesn't *require* lazy evaluation, though that helps.
17:26:25 <benzrf> - because of lazy evaluation, nothing actually gets evaluated until it's needed
17:26:39 <benzrf> - anything 'requiring' it can also be put off
17:26:45 <Ontolog> benzrf: if you are fetching some data in Haskell, you will most likely be accessing that data at some point. At that point of access, the actually IO starts to buffer and feed into the functional part of your program (I think).
17:26:55 <Cale> The thing which it requires is that the body of a lambda is not evaluated until it is applied to a parameter
17:27:05 <benzrf> - therefore, the main function can return immediately with a non-evaluated value
17:27:17 <benzrf> - then, when parts of the return value are attempted to be executed...
17:27:17 <Cale> or, applied to an argument, more properly
17:27:29 <benzrf> - it traces backward and evaluates the part that was attempted to be executed
17:27:33 <benzrf> is that mostly right?
17:27:34 <Cale> But yes, that's correct
17:27:53 <benzrf> so it's 'interleaved' because it's evaluated as it's executed
17:27:56 <Cale> (However, it would be about as correct in a strict setting, because of the way that IO actions are built up)
17:28:35 <Cale> One of the primitives for sticking together IO actions is called 'bind', and is written >>=
17:28:40 <benzrf> executing the return value of main requires that it gets up and actually bothers to evaluate it...
17:28:44 <benzrf> so it goes and does that
17:28:47 <benzrf> then it executes it
17:28:49 <benzrf> but...
17:28:53 <benzrf> wait
17:28:54 <benzrf> nvm
17:29:16 <Cale> When x :: IO t is an IO action producing some result of type t when executed, and f is a function of type t -> IO s, then
17:29:18 <Cale> x >>= f
17:29:34 <Cale> is the IO action of type IO s which first executes the action x
17:29:45 <Cale> then applies f to its result
17:29:52 <Cale> and runs the resulting action as well
17:30:11 <Cale> In do-notation, that is written  do v <- x; f v
17:30:18 <benzrf> I don't know much of that yet
17:30:20 <benzrf> :s
17:30:30 <benzrf> don't even know what a monad is, or any of the type system >_>
17:30:33 <benzrf> I just started lyah
17:30:37 <Cale> okay
17:30:45 <benzrf> I just like to know stuff I don't need
17:30:48 <Cale> So, perhaps some examples would help :)
17:30:49 <benzrf> otherwise it nags at me
17:30:49 <benzrf> :p
17:30:51 <hpc> heh
17:30:53 <benzrf> no it's ok
17:30:56 <Cale> getLine :: IO String
17:30:56 * djahandarie notes that Cale never mentioned monads
17:31:10 <Cale> is an IO action which when executed will produce a String result
17:31:23 <Cale> evaluating that IO action does nothing much which is visible
17:31:43 <benzrf> execution and evaluation are interleaved because, as the return value of main is lazily evaluated by the imperative part that kicks in afterward, it executes any return values it gets along the way?
17:31:48 <benzrf> *IO return values
17:31:58 <benzrf> err, or something
17:32:00 <Cale> But when you execute it, it will wait for a line of input on the terminal, and return that as its result
17:32:06 <benzrf> right
17:32:16 <cmccann> benzrf: your current understanding of how IO works strikes me as a pretty good one for someone very new to the language
17:32:24 <benzrf> well I've asked around
17:32:24 <benzrf> :3
17:32:35 <benzrf> I wanted to understand it before I learned much
17:32:41 <benzrf> because I am weird
17:32:52 <monochrom> that requires a time machine
17:32:53 <Cale> benzrf: You're correct, the only thing you're missing is, even in strict functional languages, it's very unusual to evaluate the inside of a lambda before the function is applied
17:33:10 <cmccann> where "pretty good" means "not horribly misleading and as close to accurate as possible given your current knowledge"
17:33:23 * benzrf cheers
17:33:47 <hpc> Cale: it's impossible to evaluate the inside of a lambda before it is applied, isn't it?
17:33:56 <Cale> benzrf: and because compound IO actions are typically built up from lots of unapplied functions which are waiting for the results of previous IO actions (which are only obtained by executing them), even in a strict language, the evaluation wouldn't go very far
17:34:01 <cmccann> more useful as a beginner than the world-passing metaphor, if nothing else...
17:34:11 <Cale> hpc: Well, it's possible to do it on paper, sometimes :)
17:34:19 <benzrf> cmccann: I heard it's misleading
17:34:24 <benzrf> anyway, this version actually seems simpler
17:34:30 <Cale> hpc: You might find some reducible subexpressions inside lambdas in general
17:34:39 <benzrf> the io doesn't block because it isn't actually evaluated because lazy
17:34:48 <Cale> hpc: But usually implementations of programming languages don't ever look inside lambdas for them
17:34:53 <benzrf> ...right?
17:34:54 <cmccann> hpc: consider e.g. (\x -> x + 5 + 3)
17:35:08 <Ontolog> GADTs are not part of core haskell?
17:35:37 <Cale> benzrf: The IO doesn't happen under evaluation just like opening up a program's binary in a hex editor doesn't cause the program to run
17:35:53 <hpc> Ontolog: yes and no; it's a language extension but iirc it's a "standard extension"
17:36:04 <Cale> benzrf: Or looking at some C source code with a text editor doesn't cause it to be executed :)
17:36:06 <hpc> @quote bin/ls
17:36:07 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:36:31 <Ontolog> do I have to pro-actively enable standard extensions?
17:36:36 <benzrf> right, I wasn't thinking
17:36:39 <benzrf> >->
17:36:46 <cmccann> IO String contains a String the same way that @quote contains shachaf
17:37:03 <Cale> benzrf: Evaluation just helps to figure out *which* action it is, and then you can imagine that there's some internal interpreter carrying out the actions which have been described
17:37:19 <Cale> This is actually just a mental model, the actual implementation in GHC is a hack :P
17:37:28 <benzrf> I assumedd
17:37:38 * monochrom rubs @quote, and shachaf appears! he says, "what is your wish?"
17:37:38 <Cale> But it *could* be done this way
17:38:14 <Ontolog> hpc: what does 'standard extension' mean? it's included by default?
17:38:19 <Cale> (and only be a small constant amount per operation slower)
17:38:28 <ion> @remember monochrom * monochrom rubs @quote, and shachaf appears! he says, "what is your wish?"
17:38:29 <lambdabot> Done.
17:38:36 <cmccann> monochrom: go for the gray dragon scale mail
17:38:40 <hpc> Ontolog: it means the behavior is specified
17:38:41 <cmccann> that's always helpful
17:39:08 <benzrf> cmccann: why not the silver kind
17:39:49 <cmccann> 'cause 50/50 chance of getting an "oReflection in sokoban
17:40:02 <cmears> and MR necessary against touch of death
17:40:24 <cmccann> unless monochrom is a wizard and started with a cloak of MR of course
17:41:16 <benzrf> fun fact: I know next to nothing about nethack
17:41:25 <benzrf> or hack
17:41:25 <cmccann> I know entirely too much
17:41:30 <benzrf> I tried it out for a week or so
17:41:36 <cmccann> I got bored after winning a few games
17:41:54 <edwardk> ion/monochrom: hah!
17:42:00 * benzrf bows his head
17:42:03 <cmccann> optimal nethack play for victory is rather dull
17:42:08 <benzrf> it is an honor to meet a victor
17:42:09 <benzrf> :y
17:42:12 <edwardk> cmccann: sadly so
17:42:23 <cmccann> exercising stats and being super-cautious early on
17:42:35 <djahandarie> Man it's been awhile since I've done evil type-level hacking in Haskell
17:42:54 <startling> the protection racket made it a lot less fun for me.
17:42:58 <cmccann> yeah
17:43:00 <hpc> djahandarie: do something with concurrency
17:43:12 <djahandarie> I'm doing some right now, not concurrency though
17:43:14 <startling> then again, it also made it a lot more fun.
17:43:16 <cmccann> after running a protection racket and ascending a tourist I gave up
17:43:22 <djahandarie> Just silly things with lists and such.
17:43:22 <copumpkin> bos: you there?
17:43:38 <benzrf> what's a protection racket?
17:43:54 <cmccann> benzrf: start as a class with extra money, hide behind your pet, rush to minetown
17:44:02 <cmccann> then buy divine protection from the priest there
17:44:09 <cmccann> the donation needed is level-based
17:44:16 <startling> it works as a thief (rogue?) or archeologist too
17:44:31 <cmccann> so if you get there as a level 1 tourist you can get a bunch of free intrinsic AC
17:44:37 <startling> steal from stores, identify gems, and/or dig into vaults
17:44:51 <cmccann> yeah, that works too
17:45:07 <cmccann> tourist is the most obvious because they suck early on anyway and you have the money to start with
17:45:13 <benzrf> neat
17:45:25 <startling> and if you get a silver saber from the minetown guard captain, you're set as an archeologist
17:45:27 <cmccann> I did the hiding behind my pet thing
17:45:40 <benzrf> hm, what's the diff between nethack and nethack-console?
17:46:15 <c_wraith> benzrf: isn't that a better question for #ubuntu?
17:46:15 <cmccann> a fully-grown default pet will slaughter everything in the upper dungeon levels when the player is low level as well
17:46:21 <benzrf> heh, true
17:46:36 <startling> cmccann: and they'll grow faster if you don't kill anything, too
17:46:46 <cmccann> yes
17:46:50 <c_wraith> benzrf: (the difference is that nethack is the common code for the console version and all the graphical versions, nethack-console is the console-specific code)
17:46:51 <sproingie> yes, but polymorphed pets are even better
17:46:53 <startling> isn't it +1hp/kill for pets? that's huge.
17:47:20 <benzrf> ok
17:47:27 <startling> sproingie, eh, imo it's better to wait for a ring of polymorph control, polymorph into a silver dragon or whatever, and lay eggs
17:47:54 <cmccann> yessssssss baby dragons are great
17:48:07 <sproingie> polymorph into ancient grey dragon ... ME: Mr Asindohopo, say hi to Muffin.  MUFFIN: *MUNCH*.  ME: Bad muffin, that's the third shopkeeper today!
17:48:17 <cmccann> magic whistle + small army of dragons = :D
17:48:39 <cmccann> this is pretty off-topic though... D:
17:49:06 <djahandarie> How could you.
17:49:14 <c_wraith> you finally noticed it's offtopic? :P
17:49:28 <cmccann> nethack enthusiasm is a powerful thing.
17:50:37 <startling> hehe
17:51:16 <startling> (also, basically free armor when they die!)
17:51:58 <dmwit> Wow, did I wander into #nethack by accident?
17:52:11 <dmwit> Not that I'm complaining.
17:52:21 <cmccann> sorry, my fault :P
17:52:49 <dmwit> Killing shopkeepers?? A working general store is a resource to be guarded with great might!
17:53:09 <cmccann> also, killing Izchak is unforgivable.
17:53:23 <monochrom> hi, I need help
17:53:32 <ab9rf> i haven't played nethack in ages
17:53:33 <monochrom> how to solve x^2 + 2x + 1 = 0?
17:53:35 <startling> cmccann: who wants a million candles anyway?
17:54:00 <startling> monochrom: alright, so you've got a ring
17:54:37 <dmwit> Okay, so you've got a RNG.
17:55:06 <hpaste> timtom pasted “variadic functions” at http://hpaste.org/85629
17:55:31 <typoclass> okay, so you've got an emerald ring of +3 dexterity
17:55:32 <timtom> I don't understand why the error occurs
17:56:03 <ab9rf> this isn't -blah
17:56:06 <dmwit> timtom: Because GHC refuses to pick instances of different specificity than what it knows.
17:56:20 <timtom> i don't understand
17:56:28 * hackagebot tables 0.3.1 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.3.1 (EdwardKmett)
17:56:34 <dmwit> GHC won't monomorph a type just to allow itself to pick an instance.
17:57:04 <dmwit> The instance "Integer -> b" is more specific than the type "a -> b -> Integer" that it has inferred so far.
17:57:17 * startling monomorphs into a silver dragon
17:57:18 <dmwit> And it won't make the "a" more specific just to allow itself to pick that instance.
17:57:33 <cmccann> sadly, GHC doesn't have wands of monomorph identified.
17:57:40 * dmwit disappears in a puff of smoke
17:57:47 <timtom> ok
17:57:56 <timtom> i think i understand
17:58:17 <timtom> i have an instance but the instance is more specific than the type
17:58:22 <timtom> so it won't pick it
17:58:53 <timtom> is there a way to give a hint to GHC?
18:07:51 <cmears> timtom: you can tell it that 1,2,3 are Integers
18:08:44 <timtom> otherwise it will think that they are Num a ?
18:09:13 <ab9rf> nothing is Num a
18:09:23 <timtom> @type 1
18:09:24 <lambdabot> Num a => a
18:09:50 <ab9rf> the type of numbers is indeterminate
18:09:54 <cmears> Yes, it's trying with Num a => a, but then can't find the Summable instance
18:10:13 <cmears> foo2 = sumOf (1::Integer) (2::Integer) (3::Integer) :: Integer
18:10:14 <cmears> should work
18:10:17 <timtom> but why doesn't the error message say anything about Num a?
18:11:02 <timtom> cmears: indeed it does
18:11:21 <timtom> foo2 = sumOf 1 (2 :: Integer) (3 :: Integer) :: Integer
18:11:21 <timtom> also works
18:11:51 <cmears> What version of GHC are you using (to get that error message)?
18:12:21 <timtom> cmears: 7.4.2
18:12:36 <cmears> The 7.6.2 error message includes some extra useful advice:
18:12:40 <cmears> The type variables `a0', `a1' are ambiguous
18:12:44 <cmears> Possible fix: add a type signature that fixes these type variable(s)
18:13:49 <timtom> ah, good to know
18:15:24 <timtom> so just to check whether i understand this correctly:
18:15:32 <timtom> I don't need the type annotation on the first number
18:15:50 <timtom> because Summable clearly states that sumOf goes from Integer to something
18:16:41 <timtom> whereas for all of the following ones it doesn't know that they are integers
18:16:57 <timtom> so it doesn't pick the instance Summable (Integer -> b)
18:17:12 <timtom> unless I explicitly declare them to be Integers
18:17:15 <timtom> is that correct?
18:18:05 <cmears> I think that is right
18:18:21 <timtom> but then, why does the first declaration work?
18:18:25 <m3ga> is there any portable way to find the number of physical CPUs on a box?
18:18:49 <timtom> because Integral is of course also less specific than Num
18:21:18 <Hermit> Integral less specific than Num? Integral needs Num AND Real, so it's more specific than Num
18:21:37 <timtom> sorry, that's what I meant
18:21:54 <timtom> just like Int is also more specific than Num
18:22:02 <timtom> *Integer
18:22:22 <cmears> I don't understand that well enough to say
18:29:29 <timtom> If GHC thought, that 2 was of type Integral
18:29:35 <timtom> than everything would make sense
18:34:33 <nabilhassein> 9
18:43:49 <Mathnerd626> so Haskell didn't get into GSOC?
18:44:03 <dolio> Haskell did.
18:44:37 <Mathnerd626> oh, I see, it's lowercase
18:44:39 <Mathnerd626> nvm then
18:46:42 <Mathnerd626> oh, that's it, haskell.org isn't tagged with haskell :-)
19:03:07 <[swift]> in a GHC heap profile, what is "SYSTEM"?
19:04:00 <[swift]> also, is "PINNED" generally caused by the FFI (ForeignPtr / StablePtr and such?)
19:04:11 <[swift]> those are my two highest categories alas
19:07:21 <parcs> PINNED is ByteArray which ForeignPtrs may use
19:08:06 <parcs> in particular foreignptrs created by mallocForeignPtr and mallocPlainForeignPtr
19:08:37 <[swift]> parcs: that's what i suspected
19:08:44 <[swift]> memory leak in an underlying library =(
19:10:04 <parcs> "SYSTEM is the RTS in general. all costs for RTS operations apart from garbage collection are attributed to SYSTEM"
19:12:55 <[swift]> thanks parcs, i appreciate the help. one more follow up question: so if i'm seeing in the summary "698,240 bytes maximum residency", i'm a bit unclear as to what that means. that means the maximum size of my actual live resident set at any time during program execution?
19:13:14 <[swift]> i'm guessing that does not include PINNED and SYSTEM, also?
19:16:33 <parcs> i'm not sure
19:17:19 <[swift]> i couldn't figure it out from the docs, either
19:17:23 <[swift]> they're a bit vague
19:18:10 <parcs> yeah this kind of stuff is sorely undocumented
19:18:26 <dmwit> timtom: Yes, type annotations are one way to give GHC a hint.
19:18:44 <dmwit> timtom: There's another way, which is to make your instances "less specific" -- but recover the specificity in the context head.
19:19:03 <dmwit> timtom: For example, instance (Summable b, Integer ~ a) => Summable (a -> b)
19:19:20 <timtom> what is the tilde doing?
19:19:22 <dmwit> I said context head, but I meant instance context.
19:19:26 <dmwit> timtom: ~ is equality
19:19:47 <timtom> cool, i never knew about that
19:19:53 <dmwit> It's like a type class constraint, except the "Integer ~" type class is only instantiated by Integer. =P
19:20:03 <dmwit> It's an extension; you need the TypeFamilies extension.
19:20:11 <dmwit> So it's pretty GHC-specific for the moment.
19:20:13 <timtom> but so why is the type class constraint treated differently
19:20:22 <timtom> than just saying integer directly
19:20:40 <dmwit> The constraint is treated differently to allow instantiation to never backtrack.
19:21:07 <dmwit> So, the process goes like this: first, pick an instance looking only at the head; then check that the context matches.
19:21:30 <timtom> head?
19:21:32 <dmwit> (Note that if the context doesn't match, it's just an error -- we don't proceed on to try another instance head!)
19:21:40 <dmwit> The head is the part after the =>
19:21:51 <dmwit> ...or the whole thing, if there's no =>, of course.
19:21:54 <timtom> and the context is the part on the left?
19:21:57 <dmwit> right
19:21:59 <dmwit> err
19:22:00 <dmwit> correct
19:22:00 <timtom> :D
19:22:16 <timtom> ok, so <context> => <head>
19:22:21 <dmwit> correct
19:22:24 <timtom> ah
19:22:32 <timtom> so, if we have integer in the head
19:22:38 <timtom> it's more specific than our type
19:22:46 <timtom> and as you said, we never backtrack
19:23:06 <dmwit> (Those two sentences are both true, but not related.)
19:23:12 <timtom> so we just fail because we didn't find a proper instance
19:23:56 <hpaste> flebron pasted “How could I speed this program up?” at http://hpaste.org/85631
19:24:09 <timtom> whereas when Integer is part of the context, the head will match
19:24:33 <timtom> and it will then use the context as a "hint" to know which constraints it has to enforce?
19:24:38 <dmwit> Right!
19:24:45 <timtom> ok
19:25:06 <flebron> I've tried using ByteString instead of String (the numbers being read are 64 bits), but it's possible to speed this program up more. Could anyone suggest how?
19:25:32 <timtom> thank you very very much!
19:25:40 <timtom> is this sort of thing documented anywhere?
19:25:41 <dmwit> If you know all your numbers are 64 bits, why not use Word64 or Int64?
19:25:48 <dmwit> timtom: In the Report, I guess. =)
19:26:02 <flebron> Int64 was slower than Integer, for some odd reason :( (The machine that is running this is 32 bits.)
19:26:05 <dmwit> flebron: Also, you only did half a job of switching to ByteString. You input in ByteString, but output in String.
19:26:08 <timtom> ok, I should probably read that then... :)
19:26:27 <flebron> dmwit: How could I output in ByteString?
19:26:35 <flebron> It would seem I need to convert everything to String via show first.
19:26:45 <dmwit> That can't be right.
19:26:50 <flebron> (As in, what would a function [Integer] -> ByteString look like?)
19:27:33 <flebron> There's ByteString -> Integer, in fromJust . fst . readInteger.
19:28:20 <shachaf> fromJust :-(
19:28:40 <flebron> I know, I know. But the input is a predetermined format, it's for a programming competition.
19:28:43 <ion> D-:
19:28:46 <shachaf> @ty fromJust . const Nothing
19:28:48 <lambdabot> a -> c
19:28:53 <flebron> :p :p
19:29:10 <dmwit> shachaf: At least he's using partial patterns in his actual code.
19:29:55 <croikle> flebron: what does the profiler say?
19:29:58 <dmwit> flebron: http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Builder.html#g:12
19:31:02 <flebron> croikle: Unfortunately my input is too small for a profiler. My best profiling data is that, for the tester's input and on the tester's machine, my code runs in 0.23s. The best solution runs in 0.17s.
19:31:12 <flebron> (Can the profiler do much in 0.23s?)
19:31:38 <dmwit> That's, like, a billion instructions.
19:31:51 <flebron> dmwit: "Currently slow." :(
19:32:01 <flebron> I'll try giving Word64 a try.
19:32:42 <dmwit> http://stackoverflow.com/a/10358198/791604
19:34:40 <flebron> Hrm. How can I read a Word64 from a ByteString though, dmwit?
19:36:11 <dmwit> flebron: Read my StackOverflow post? =)
19:37:14 <shachaf> (\b -> if B.unpack b == [104,105] then 1 else 0) :: B.ByteString -> Word64 hth
19:38:36 <flebron> :p
19:40:08 <dmwit> > "\104\105" -- what is this?
19:40:10 <lambdabot>   "hi"
19:40:21 <shachaf> ?
19:40:33 <shachaf> Who said it was a UTF8 ByeString?
19:40:52 <dmwit> I just assumed latin-1!
19:41:49 <dmwit> It can't be EBCDIC, those codes aren't defined.
19:43:56 <shachaf> What if it's UTF-16?
19:44:55 <Clint> or VISCII
19:45:04 <shachaf> 06E9   ARABIC PLACE OF SAJDAH     [۩] or 06F8   EXTENDED ARABIC-INDIC DIGIT EIGHT     [۸], I suppose
19:45:45 <tgeeky> ۩ . o ( Hello, giant people. )
19:45:56 <QinGW> join #emacs
19:47:10 <no-n[6]> I can't find the source code for the compare function
19:47:28 <dmwit> no-n[6]: It's spread out over the various Ord instances.
19:47:29 <shachaf> @src Ord
19:47:30 <lambdabot> class  (Eq a) => Ord a  where
19:47:30 <lambdabot>     compare      :: a -> a -> Ordering
19:47:30 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:47:32 <lambdabot>     max, min         :: a -> a -> a
19:47:47 <no-n[6]> ahh
20:54:54 <dmj> what's the best way to represent graphs in haskell (for BFS, DFS)
20:55:40 <lispy> hello
20:55:51 <rosslazer> Hello I need to write a function call seven that has the type  a -> b -> a
20:56:02 <lispy> dmj: Do you want to use an existing library or implement your own?
20:56:04 <rosslazer> without actually doing seven :: a -> b -> a
20:56:07 <rosslazer> how do I do this?
20:56:34 <andrewsw> rosslazer: do you understand what that type signature mean?
20:56:55 <rosslazer> andrewsw something that can be any type and something b that can be any type?
20:57:14 <lispy> dmj: for general graphs, most people agree that adjacency lists are the best bet to start off. adjacency matricies also being nice but don't work as well for sparse graphs.
20:57:20 <andrewsw> rosslazer: seven is a function which...
20:57:48 <lispy> dmj: If you want to emphasize the inductive structure of the graph there are haskell-specific tricks like the fgl library.
20:58:05 <dmj> lispy: roll my own
20:58:06 <lispy> dmj: if you want a library, chances are you want either igraph or fgl (look them up on hackage)
20:58:10 <rosslazer> andrewsw takes a type a and type b and puts something out that is a type a
20:58:54 <andrewsw> rosslazer: okay. can you imagine such a function? take a stab at something that seems trivially simple that does what you've described.
20:58:56 <lispy> dmj: http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01
20:59:04 <lispy> dmj: that's the paper for the inductive style graph.
20:59:20 <rosslazer> andrewsw eight = someFunc
20:59:20 <rosslazer>     where
20:59:21 <rosslazer>       someFunc a b = a
20:59:33 <lispy> dmj: but adjanccy lists are going to be easiest to understand (for most stuff)
20:59:37 <rosslazer> but that returns t t1 t
20:59:43 <lispy> dmj: for each node you store a list of the immediate neighbors
20:59:45 <tgeeky> dmj: you can also e-mail martin and ask him questions, he's very receptive
21:00:29 <rosslazer> andrewsw that is where I get tripped up
21:00:33 <andrewsw> rosslazer: sure.
21:00:49 <rosslazer> andrewsw : eight :: t -> t1 -> t1
21:00:50 <andrewsw> rosslazer: that type is the same... just different names
21:01:18 <rosslazer> andrewsw: my requirements state it has to be a->b->a
21:02:02 <andrewsw> are you allowed to specify the type signature as well as define the function?
21:02:50 <rosslazer> andrewsw: no I cannot specify a sig by doing  eight :: a->b->a
21:04:06 <andrewsw> rosslazer: ah, well, I don't know how to make it chose a and b instead of t and t1.
21:04:14 <dmj``> lispy: sorry, keep getting kicked off, were all those papers on haskell?
21:04:21 <rosslazer> Does anyone?
21:04:42 <andrewsw> rosslazer: as an aside, why did you define eight = someFunc where.. instead of just defining outright
21:04:47 <lispy> dmj``: the graph paper is on haskell. Most of erwig's papers are on haskell.
21:04:56 <rosslazer> andrewsw I don't know
21:05:00 <lispy> dmj``: http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
21:05:13 <andrewsw> rosslazer: fair enough.
21:05:24 <lispy> dmj``: if you need the logs:
21:05:30 <lispy> dmj``: http://ircbrowse.net/browse/haskell
21:05:36 <andrewsw> rosslazer: sorry I can't be more help...
21:05:45 <rosslazer> andrewsww: I got it
21:05:54 <rosslazer> andrewsw: eight = const
21:06:09 <andrewsw> ah... ha ha! yes...
21:06:32 <dmj``> lispy: thanks for the logs
21:06:46 <rosslazer> andrewsw: now I am back to square one with  a -> [b]
21:06:47 <rosslazer> lol
21:07:58 <andrewsw> rosslazer: troll through the prelude and Data.List docs??
21:10:21 <rosslazer> andrewsw ehhh not for this one
21:11:11 <rosslazer> andrewsw: what could come in as one type and leave as a list of others?
21:13:05 <lispy> :t \_ -> []
21:13:06 <lambdabot> t -> [a]
21:13:24 <lispy> :t const []
21:13:25 <lambdabot> b -> [a]
21:13:36 <lispy> oh, no that has b and a in the wrong places :(
21:13:43 <andrewsw> yeah
21:13:54 <lispy> :t const [] :: a -> [b]
21:13:56 <lambdabot> a -> [b]
21:14:55 <rosslazer> lisp seven = const []
21:15:02 <rosslazer> *lispy seven = const []
21:15:07 <rosslazer> gave me seven :: b -> [a]
21:16:59 <dmj``> does the haskell community have programming competitions like top coder?
21:17:13 <Nisstyre-laptop> dmj``: not that I know of
21:17:18 <Nisstyre-laptop> it's more on the academic side
21:18:05 <dmj``> Nisstyre-laptop: that would be very cool
21:18:06 <ParahSail1n> these are the list of challenges
21:18:10 <ParahSail1n> http://www.reddit.com/r/haskell_proposals/
21:18:18 <rosslazer> lispy: any ideas?
21:18:37 <NemesisD> hey guys. what could it mean when the linker reports an "unknown symbol"? it happens consistently with this library. tried it with hsenv and cabal-dev
21:18:38 <Nisstyre-laptop> ParahSail1n: your nick is brilliant
21:18:59 <cmears> rosslazer, surely the names of the type variables do not matter...
21:19:12 <rosslazer> cmears: They do in these requirements
21:19:28 <Nisstyre-laptop> if you let Haskell infer types then it will use the types it gets from unification
21:19:40 <Nisstyre-laptop> including their type names
21:21:09 <lispy> rosslazer: any ideas about what?
21:21:19 <rosslazer> lisp how to make is a->[b]
21:21:21 <rosslazer> not the inverse
21:21:37 <Nisstyre-laptop> is :: a -> [b]
21:21:59 <lispy> NemesisD: This is a nice explanation: http://www.lurklurk.org/linkers/linkers.html
21:22:05 <lispy> NemesisD: May I see your cabal file?
21:22:37 <lispy> rosslazer: const [] :: a -> [b]
21:22:55 <rosslazer> lispy: seven  =  const []
21:23:03 <rosslazer> lispy: I cannot use type casting
21:23:08 <Nisstyre-laptop> rosslazer: why do you care about the names of the type variables?
21:23:25 <rosslazer> assignment I'm stuck on
21:23:39 <andrewsw> rosslazer: it's not type casting, it's merely giving names to unknown types.
21:23:56 <rosslazer> andrewsw: right
21:23:57 <coppro> a -> [b] is the same type as b -> [a]
21:24:00 <Nisstyre-laptop> they are generic type variables, there's no "casting" going on
21:24:03 <NemesisD> lispy: https://github.com/MichaelXavier/librato-haskell/blob/streaming-result/librato.cabal
21:24:17 <rosslazer> coppro: I was told it has to output a->[b]
21:24:34 <arkeet> so give it a type signature
21:24:35 <arkeet> a -> [b]
21:24:44 <nbouscal> b -> [a] is a -> [b]
21:24:44 <NemesisD> lispy: note that "httpmock" is not released to hackage. that is on my local machiine and i installed using hsenv via: cabal install ../HTTPMock
21:24:45 <coppro> then your assignment is dumb
21:25:05 <m3ga> @hoogle readTQueue
21:25:05 <lambdabot> No results found
21:25:18 <NemesisD> the error when running tests is: Loading package httpmock-0.0.0.1 ... linking ... ghc: /home/michael/src/mine/librato-haskell/.hsenv/cabal/lib/httpmock-0.0.0.1/gh
21:25:46 <NemesisD> erm: Loading package httpmock-0.0.0.1 ... linking ... ghc: /home/michael/src/mine/librato-haskell/.hsenv/cabal/lib/httpmock-0.0.0.1/ghc-7.6.2/HShttpmock-0.0.0.1.o: unknown symbol `httpmockzm0zi0zi0zi1_NetworkziHTTPMockziWebServersziScotty_startServer1_closure'
21:25:48 <rosslazer> akreet: I can't
21:26:29 <andrewsw> rosslazer: the problem is that you'd have to find an existing function with its type named a -> b and then you can use that to make a -> [b]
21:26:40 * hackagebot sscgi 0.2.0 - Simple SCGI Library  http://hackage.haskell.org/package/sscgi-0.2.0 (ChrisForno)
21:26:52 <lispy> NemesisD: I might know the problem
21:27:00 <NemesisD> lispy: !!! yay
21:27:02 <rosslazer> andrewsw: I could make an anonymous function?
21:27:10 <Nisstyre-laptop> either you give it an explicit type annotation, or you find something with that type like andrewsw said, and GHC will give your function the type signature you want when it infers it
21:27:13 <lispy> preflex: zdec httpmockzm0zi0zi0zi1_NetworkziHTTPMockziWebServersziScotty_startServer1_closure
21:27:14 <preflex>  httpmock-0.0.0.1_Network.HTTPMock.WebServers.Scotty_startServer1_closure
21:27:32 <lispy> NemesisD: I've seen a similar problem with a library and an executable in the same file.
21:27:42 <andrewsw> rosslazer: giving and anonymous function won't work because ghc will just make up type names
21:27:46 <NemesisD> lispy: what do you mean?
21:27:57 <lispy> NemesisD: the .cabal file had both library and executable sections
21:27:59 <andrewsw> rosslazer: so... find a function with type a -> b
21:28:20 <rosslazer> andrewsw I found one that is a->b
21:28:25 <rosslazer> but it needs to be a->[b]
21:28:37 <arkeet> I doubt you found one with type a -> b.
21:28:38 <lispy> NemesisD: I can't recall exactly what I did to fix it, but I either didn't specify enough in the executable section or I specified too little (in terms of haskell modules).
21:28:48 <NemesisD> lispy: fraid not. both my main project and httpmock only have a library section and a test-suite section
21:29:20 <NemesisD> lispy: is it possible that enabling tests in my main project is tripping the configure of the other project to enable tests as well or something
21:29:26 <lispy> NemesisD: Yes, but I suspect that test-suite sections are treated similarly (from the linkers perspective) as executable sections
21:29:50 <andrewsw> rosslazer: so now you just have to figure out how to get the output of that function into a list.
21:30:02 <NemesisD> lispy: maybe cabal configure --enable-tests ../HTTPMock && cabal install ../HTTPMock && run my tests?
21:30:19 <andrewsw> rosslazer: what is the function you found?
21:30:20 <lispy> NemesisD: you could try it, but I don't think it will fix your problem
21:30:34 <lispy> NemesisD: I think you need to tweak what is exposed in the test-suite section.
21:30:35 <rosslazer> It's not in the standard lib
21:30:35 <rosslazer> unsafeCoerce
21:30:47 <andrewsw> someone's been to hoogle...
21:30:50 <lispy> NemesisD: and/or possibly move the main-is file in the file system
21:30:51 <rosslazer> Screw that one what about ([a],String) -> [(a,Char)]
21:30:58 <NemesisD> lispy: yeah didn't work. configure doesn't take a dir argument
21:31:03 <Nisstyre-laptop> :t (\a -> a)
21:31:05 <lambdabot> t -> t
21:31:13 <Nisstyre-laptop> :t (\a -> a + a)
21:31:15 <lambdabot> Num a => a -> a
21:31:21 <Nisstyre-laptop> notice how they have different names rosslazer
21:31:28 <Nisstyre-laptop> :t (+)
21:31:30 <lambdabot> Num a => a -> a -> a
21:31:34 <lispy> NemesisD: hang on, I will see if I can find any notes about what happened last time
21:31:35 <Nisstyre-laptop> that's because of the type of +
21:31:50 <NemesisD> lispy: oh snap one thing in common with both is that the main-is in both projects is basically auto-generated. its "hspec-discover", which combs your test dir and generates the main
21:32:04 <Nisstyre-laptop> Haskell takes the type "t -> t" and replaces it with "a -> a" because I used + in the body
21:32:12 <NemesisD> i'll try commmenting the test section in the depedent project for now
21:32:12 <Nisstyre-laptop> (and adds the Num constraint)
21:33:42 <lispy> NemesisD: ah, so I found one thing "from last time".
21:34:04 <lispy> NemesisD: Make sure that all your modules are listed in the .cabal file for the library
21:34:55 <lispy> NemesisD: for example, make sure exposed-modules lists all of the modules you mean to expose. When cabal builds your library it tells ghc to chase dependencies. So when you build the library that part can work fine even though you've forgot to mention them. But later it might be an issue when something goes looking for them.
21:35:34 <NemesisD> lispy: there are some modules that are uused internally but not exposed, perhaps i'm being too conservative
21:35:56 <andrewsw> rosslazer: you can indeed do it with unsafeCoerce, but I highly doubt that is what your instructor intended.
21:36:26 <lispy> NemesisD: you really just need to expose Network.HTTPMock.WebServers at the moment
21:36:37 <lispy> NemesisD: looks like you could put it on line 27 of the HTTPMock.cabal
21:36:43 <rosslazer> any ideas for  (a -> a -> b) -> a -> b
21:36:51 <rosslazer> Hate to bother you guys I am just desperate
21:36:53 <andrewsw> rosslazer: but who am I to claim knowledge of their intent.
21:36:56 <rosslazer> This assignment is solo dumbb
21:37:01 <Nisstyre-laptop> @djinn (a -> a -> b) -> a -> b
21:37:01 <lambdabot> f a b = a b b
21:37:37 <rosslazer> find except it doesn't use a b and c
21:37:41 <rosslazer> it uses t's
21:37:44 <rosslazer> :(
21:37:53 <Nisstyre-laptop> so what?
21:38:00 <rosslazer> assignment wants it exactly
21:38:06 <rosslazer> @djinn (a -> b) -> (b -> c) -> a -> c
21:38:06 <lambdabot> f a b c = b (a c)
21:38:07 <arkeet> assignment is unreasonable
21:38:17 <rosslazer> I agree
21:38:18 <lispy> rosslazer: http://en.wikipedia.org/wiki/Lambda_calculus#.CE.B1-conversion :)
21:38:24 <elliott> i seriously doubt the assignment doesn't allow for alpha-conversion.
21:38:34 <rosslazer> @dkinn (a -> b -> c) -> (a -> b) -> a -> c
21:38:34 <lambdabot> f a b c = a c (b c)
21:39:07 <andrewsw> :t unsafeCoerce
21:39:08 <lambdabot> Not in scope: `unsafeCoerce'
21:39:22 <rosslazer> I will hand it in with t's
21:39:29 <rosslazer> what does it matter it is demonstrating the types
21:39:30 <sellout-> rosslazer: Your teacher can’t possibly be requiring that the same letters be used for the type variables – just that there’s a 1-1 correlation between the variable names they list and the ones you get.
21:41:17 <NemesisD> lispy: you were right. its weird that i have to expose pretty much all of the internal modules of httpmock
21:41:30 <NemesisD> don't quite understand it but it worked so yay!
21:41:34 <lispy> NemesisD: if you don't want to expose them, try listing them as other modules
21:41:48 <lispy> NemesisD: I don't know if it will still work, but it's worth a shot.
21:42:07 <NemesisD> lispy: ah ok. what are the semantics of other-modules. what does cabal do with that information
21:42:13 <andrewsw> rosslazer: maybe the assignment is to learn and understand that a -> [b] is the same type as t -> [t1]
21:42:20 <rosslazer> lol no
21:42:27 <lispy> NemesisD: As a stylistic note, I strongly advocate making everything exposed in your .cabal file but naming them so that people know not to go fooling around with them unless they want their code to break :)
21:42:32 <rosslazer> oh well they use haskell a lot in our CIS dept
21:42:42 <rosslazer> and I love haskell but not as one of the first CIS courses
21:42:50 <lispy> NemesisD: To be honest, I'm not sure what other-modules does but, I think they are not exposed?
21:43:01 <rosslazer> it can discourage a lot of ppl who need to be eased in using OO
21:43:07 <NemesisD> lispy: using other modules worked. why do you advocate for exposed?
21:43:47 <lispy> NemesisD: Sometimes people have a use for your library that you didn't anticipate. Those folks often need access to the internals. The alternative is sending you patches or forking your package.
21:44:22 <NemesisD> hmm ok. ill consider it
21:44:23 <andrewsw> rosslazer: I don't think OO counts as easing in... but regardless, good luck and good night.
21:44:31 <lispy> NemesisD: at least with the internals exposed they can figure out what work they need to do to get their thing implemented and then they can decide if it's worth bugging you with patches :)
21:45:02 <rosslazer> andrewsw: thanks my contention is that it's easier for people to think about concepts using objects
21:45:11 <Nisstyre-laptop> rosslazer: what school?
21:45:18 <lispy> NemesisD: you'll notice that libraries like bytestring do this and mark that part of the module heirarchy as "Internal"
21:45:26 <NemesisD> lispy: in my OO programming i'm a big fan of private methods for setting a defined line between stable api code and code that i'm free to change at any time
21:45:36 <lispy> NemesisD: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Internal.html
21:45:48 <Nisstyre-laptop> when will everything use Text instead of ByteString?
21:46:27 <lispy> Nisstyre-laptop: Not everything should use Text. Just things that work on text. Folks working with bytes should continue to use bytestring :)
21:46:43 <Nisstyre-laptop> lispy: true, although I think the name may be misleading in that case
21:46:58 <rosslazer> night all
21:49:50 <lispy> NemesisD: I guess it's also slightly different than the OO case of private methods. You can still make things private to a module. So the idea being, some things are exposed internal to a package and those are the things I like to expose fully. I still have things that are private within modules.
21:52:51 <startling> edwardk: what does the code block at the immediate beginning here mean? http://hackage.haskell.org/packages/archive/parsers/0.6/doc/html/Text-Parser-Token.html
21:56:42 * hackagebot kansas-comet 0.2 - A JavaScript push mechanism based on the comet idiom  http://hackage.haskell.org/package/kansas-comet-0.2 (AndyGill)
22:08:03 <lispy> NemesisD: https://github.com/haskell/cabal/issues/939
22:18:21 <NemesisD> lispy: bingo! subscribing to that one. thanks
22:19:31 <NemesisD> hmm i thought htere was some way to subscribe to an issue
22:20:37 <cmears> down the bottom, there's a box with "Watch thread"
22:21:43 <NemesisD> ah yes. derp
22:26:19 <sw2wolf> Isnot GHC only ripe Haskell Langauge implementation ? It seems that a standard language should have many implementations ?
22:26:49 <otters> why?
22:27:01 <simpson> sw2wolf: What qualifies as "ripe?"
22:27:33 <sw2wolf> simpson: completely implement Haskell Standard
22:27:59 <simpson> sw2wolf: You mean the Report?
22:28:29 <simpson> sw2wolf: Anyway, there are others, like Hugs and JHC.
22:28:55 <sw2wolf> simpson: it seems haskell just have a 98 report ?
22:29:28 <simpson> sw2wolf: There was a recent Haskell 2010 Report.
22:29:46 <sw2wolf> does GHC implement 2010 Report ?
22:30:43 <sw2wolf> otters: C, C++, Lisp have many implementations for user to choose
22:30:52 <otters> so?
22:31:34 <simpson> sw2wolf: Yes, it does.
22:31:47 <simpson> sw2wolf: Anyway, what's your goal here?
22:32:11 <lispy> sw2wolf: There are some others but they are not generally useful.
22:32:25 <sw2wolf> i hope haskell can be fluent
22:32:34 <lispy> EHC/UHC, hugs, nhc, jhc, and ghc.
22:32:46 <simpson> sw2wolf: That doesn't make sense.
22:33:01 <sw2wolf> oh
22:33:34 <sw2wolf> ghc is dominate
22:33:40 <lispy> yes
22:33:50 <sw2wolf> thx
22:34:08 <lispy> That's true in some of the other languages you mentioned. in lisp sbcl is king.
22:35:45 <sw2wolf> lispy: i use clisp
22:35:50 <startling> lispy: isn't that more true of common lisp than lisp in general?
22:36:24 <startling> some schemes seem roughly as, if not more, popular than sbcl
22:36:59 <lispy> sw2wolf: but clisp isn't hyperspec compliant and the generated code isn't as good :)
22:37:59 <lispy> startling: yes, I mean common lisp. I tend to assume CL whenever someone says just 'lisp'
22:38:13 <sw2wolf> lispy: in fact clisp produced smallest stumpwm which cause me to use it
22:39:23 <sw2wolf> lispy: i know sbcl can produce native code which should be faster than clisp's byte code
22:39:33 <lispy> sw2wolf: I once had a complicated application in lisp. I compiled it with both clisp and sbcl and started it with both as a race. clisp finished compiling over a minute before sbcl, but the one compiled with sbcl was ready to use first :)
22:40:05 <coppro> 1/win 36
22:40:49 <sw2wolf> lispy: have you tries CCL which can produce smaller native code than SBCL ?
22:41:27 <sw2wolf> And CCL has fast compiling speed
22:41:29 <lispy> sw2wolf: no I haven't. It's been at least 5-6 years since I worked with lisp regularly.
22:41:58 <elliott> haskelly
22:42:08 <sw2wolf> ok
22:43:25 <lispy> sw2wolf: In fact, I've never heard of CCL but it seems to have a long history
22:43:56 <sw2wolf> yeah
22:45:37 <lispy> I never realized that data flow analysis was such a hard problem until I started learning about it :)
22:47:18 <mzero> There is just no nice way to write a function that handles a bunch of different Exceptions, is there?!!!
22:48:36 <mzero> like I want    SomeException -> Maybe String      where some exceptions are ignored (Nothing), some are converting to strings in particular ways, and as a catch all, there's Just $ "Error: " ++ show e
22:49:00 <mzero> but I can't come up with a clean way of writing this that is a nested mess of if and case
22:50:26 <arkeet> :t catches
22:50:28 <lambdabot>     Not in scope: `catches'
22:50:28 <lambdabot>     Perhaps you meant `catch' (imported from Prelude)
22:50:43 <mzero> no, I've already caught them
22:51:00 <mzero> this is in a catach all handler --- it's caught SomeException
22:51:04 <mzero> I just want to print it nicely
22:51:09 <lispy> mzero: would view patterns help?
22:51:15 <mzero> yeah, possibly
22:51:27 <mzero> but I haven't used them in this project so far....
22:51:33 <mzero> (or at all, really)
22:51:50 <elliott> lens has exception stuff :p
22:52:10 <arkeet> I'm not sure what you're trying to do then.
22:52:36 <lispy> mzero: can you give us a more concrete example?
22:52:55 <lispy> You must be calling fromException on the passed in value of SomeException?
22:52:57 <hpaste> mzero pasted “reporting errors” at http://hpaste.org/85632
22:53:39 <mzero> there's two attempts
22:53:59 <mzero> I suppose the logger aspect is a red-herring here...
22:55:28 <lispy> mzero: your version with <|> reminds me of pattern guards: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
22:56:37 <lispy> I guess what you're really grappling with is that the 'a' in e :: (Ex.Exception a) => Maybe a
22:57:16 <lispy> mzero: I kind of want to say, 'define a type class over Exception a that does the right thing for each a'
22:57:46 <lispy> class PrettyException a where ...
22:57:55 <mzero> lispy- but I'd still ahve to find a way to coerce err to each type in turn
22:57:57 <lispy> (but that's kind of hamfisted)
22:58:40 <mzero> and, the ThreadKilled one is hard - it is a value of AsyncException -- and the other values should be handled by the catch all at the end!
22:59:00 <startling> does parsers/trifecta not have "try"?
23:04:57 <hpaste> mzero annotated “reporting errors” with “reporting errors (annotation)” at http://hpaste.org/85632#a85633
23:05:09 <mzero> okay, that is prettier at the expense of two GHC extensions!
23:06:44 * hackagebot binary-file 0.15.9 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.9 (YoshikuniJujo)
23:09:02 <lispy> mzero: you could can (pretty easily) use some of the newer extensions to build up a HList (holding the types of exceptions) and then process them in a list-processing fashion :)
23:09:19 <mzero> ew!
23:09:34 <mzero> :-)
23:09:35 <lispy> type literals makes HList stuff much more tolerable
23:09:43 <lispy> But yeah, don't go there if you don't need to
23:11:05 <hpaste> mzero annotated “reporting errors” with “reporting errors (annotation) (annotation)” at http://hpaste.org/85632#a85634
23:11:27 <mzero> that'll work for now - it isn't really general pattern
23:11:41 <mzero> adding more exceptions to handle would just likely make it an indented mess...
23:11:45 <mzero> but... oh well!
23:11:51 <lispy> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html#promoted-literals
23:14:31 <mzero> hmmm... I've been refactoring these three modules for two days, futzing with the code to make it clear .....
23:14:44 <mzero> .... perhaps I should run it and see if it still works!  :-)
23:15:46 <lispy> heh
23:19:55 <Feuerbach> Is there a way to find out which dependency causes a reinstall in cabal?
23:21:04 <cmears> Turning on verbosity usually helps (e.g. cabal install -v3 ...)
23:23:26 <Feuerbach> thanks cmears, it helped
23:23:34 <cmears> You're welcome (:
23:50:09 <piezoid> hi
23:51:00 <piezoid> to get into haskell a bit deeper I try to make a compiler
23:52:34 <m3ga> piezoid: compile for haskell or in haskell
23:52:42 <piezoid> I read a bit about expression problem : syntactic's AST, constrained monad, etc...
23:53:27 <piezoid> but i get stucj to the problem of choosing a strucutre with effect and lower it to hoopl flowgraph
23:55:38 <piezoid> on one side I've a structure tied with immutable data, and on the other, a control flow not aware of data
