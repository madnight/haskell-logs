00:01:14 <kryft> Cale: I should probably take your advice about learning how to use things instead of trying to understand them generally first :P
00:32:03 <cjh`> I have defined an abstract data type via data: data Balanced = Height Int | Unbalanced
00:32:24 <cjh`> I then try to declare a function that operatores on this: balance :: Balanced b => a -> [b] -> b
00:32:42 <cjh`> Haskell gives me an error saying that I have applied Balanced to too many arguments
00:33:16 <cjh`> Where should I read about how to declare Balanced so that I can use this function declaration syntax?
00:33:23 <lightquake> that's because you're trying to use Balanced as a typeclass
00:33:41 <lightquake> what does your balance function do, conceptually?
00:34:23 <elliott> cjh`: chances are very high you want to say balance :: a -> [Balanced] -> Balanced instead.
00:34:30 <cjh`> lightquake: it calculates if the 2 subtrees are considered balanced
00:34:43 <elliott> though that a argument is odd.
00:34:47 <cjh`> elliott: of course, why didnt I consider that syntax.
00:35:13 <cjh`> elliott: we are tasked with writing a treefold, so that a is the value stored within each node of the tree
00:35:46 <Ralith> there don't seem to be any trees involved here, let alone values stored in nodes thereof
00:37:10 <cjh`> lightquake: elliott thanks, I was conflating type class and abstract data types
00:37:14 <cjh`> elliott: why is that a argument odd?
00:37:30 <Ralith> cjh`: because you can't do anything with it.
00:38:11 <elliott> cjh`: you'll find you're unable to use it for much of anything in the function body.
00:38:19 <cjh`> ahh, in the case of balance I dont want to do anything with it
00:38:27 <elliott> ok. I suggest not passing a in then :)
00:38:27 <Ralith> then why is it there?
00:38:48 <cjh`> we are tasked with writing a generic tree fold and these are functions we give to it, in some of them we care about the a
00:39:08 <cjh`> I cant see a tidier way of dealing with this, as I dont want to write a wrapper/lambda to throw away the a
00:39:35 <Ralith> what is the type of a function where you would care about it?
00:40:05 <cjh`> one of the functions we need is to sum all the as in the tree, so in that case I would have Num a
00:41:18 <cjh`> Ralith: or did you want me to write out the functions type declaration?
00:41:54 <Ralith> that was what I asked for, but you conveyed sufficient information in long form
00:42:02 <Ralith> so no need
00:42:58 <cjh`> ok, thanks for your time Ralith, elliott and lightquake :)
00:43:13 <elliott> :)
00:43:25 <Ralith> good luck
00:50:00 <Breadmonster> Can I have a where nested in a for?
00:50:07 <Breadmonster> *nested in a let?
00:52:01 <Ralith> why do you want that?
00:52:39 <SaBer> Breadmonster: like this? http://ideone.com/FtBOlc
00:52:45 <Eduard_Munteanu> Breadmonster: you should be able to, 'where' binds to declarations
00:53:24 <Breadmonster> SaBer: So the where will have to come after the in clause? Okay, thanks.
00:53:55 <Eduard_Munteanu> SaBer: that's not what he asked I think
00:54:20 <Eduard_Munteanu> That 'where' has nothing to do with the 'let'.
00:55:00 <Eduard_Munteanu> > let foo = 1 + bar where bar = 2 in foo * 10
00:55:02 <lambdabot>   30
00:55:07 <Eduard_Munteanu> Breadmonster: ^^
00:55:13 <Breadmonster> Oh, alright.
00:55:28 <Eduard_Munteanu> The 'where' belongs to 'foo'.
00:56:58 <Breadmonster> SaBer Eduard_Munteanu: I was talking about this. http://ideone.com/hDo4Yj
00:57:29 <Eduard_Munteanu> Breadmonster: yeah, that does
00:57:45 <Breadmonster> Eduard_Munteanu: Why is it causing an error?
00:58:02 <Eduard_Munteanu> Breadmonster: what error?
00:58:21 <Breadmonster> Eduard_Munteanu: http://ideone.com/hDo4Yj
00:58:31 <h4199> prog.cpp:5:21: error: stray ‘`’ in program
00:58:39 <h4199> I think is what he means
00:58:45 <Breadmonster> Oh, shit, I compiled under C++ :P
00:58:52 <h4199> yup
00:58:59 <Breadmonster> I feel so dense.
00:59:11 <Eduard_Munteanu> LOL. I saw those, but I had no idea you tested in the pastebin.
00:59:13 <h4199> happens to the best of us :P
00:59:21 <DarkFox> Is there any clean way to without defining a ... a <- x; y a; z a; w a >>= ... ?
00:59:55 <DarkFox> Well... Let me clean that up
01:00:52 <DarkFox> a <- q; b a >>= z "a"; c a >>= z "b"; d a >>= more >>= monad >>= redirections >>= here
01:01:37 <Ralith> @undo a <- x; y a; z a;
01:01:38 <lambdabot>  Parse error at "<-" (column 3)
01:01:44 <Ralith> @undo do a <- x; y a; z a;
01:01:45 <lambdabot> x >>= \ a -> y a >> z a
01:01:49 <Cale> DarkFox: In general, if the number of occurrences of a variable is larger than 1, eliminating it is going to be tricky.
01:02:11 <Cale> DarkFox: There are things you can do involving the function monad
01:02:21 <Ralith> @pl x >>= \ a -> y a >> z a
01:02:22 <lambdabot> liftM2 (>>) y z =<< x
01:02:27 <DarkFox> Cale: I was thinking about infix like with a <$> b <*> c with applicative
01:02:28 <aleator> Anyone have an opinion on data-checked? Is it a good idea or does it just make things awkward?
01:02:36 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
01:02:40 <lambdabot>   mueval-core: Time limit exceeded
01:02:44 <Cale> err
01:02:46 <Cale> > 1
01:02:47 <lambdabot>   1
01:02:51 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
01:02:52 <lambdabot>   ("hello","olleh","HELLO")
01:02:55 <Cale> okay
01:03:21 <DarkFox> Heh
01:03:41 <Cale> DarkFox: and yeah, the applicative instance for functions does basically the same job...
01:04:09 <DarkFox> How could this roll over for monads?
01:04:24 <Cale> I think you'll end up with really awkward code
01:04:35 <DarkFox> Naww
01:04:41 <Cale> because you'll end up using liftA2 or the equivalent on (>>=)
01:04:54 * DarkFox looks at code again and thinks.. why not just move it down to where I am using it :3
01:05:09 <DarkFox> Thanks anyway.
01:05:09 <Cale> @undo do a <- q; b a >>= z "a"; c a >>= z "b"
01:05:10 <lambdabot> q >>= \ a -> b a >>= z "a" >> c a >>= z "b"
01:05:17 <Cale> @pl \ a -> b a >>= z "a" >> c a >>= z "b"
01:05:17 <lambdabot> (z "b" =<<) . ap ((>>) . (z "a" =<<) . b) c
01:05:28 <Cale> there you go :P
01:06:34 <DarkFox> What about two? :P
01:06:44 <Cale> two what?
01:07:47 <DarkFox> @undo do c <- pc; l "a" c >>= ss "a"; l "b" c >>= ss "b" >>= x
01:07:47 <lambdabot> pc >>= \ c -> l "a" c >>= ss "a" >> l "b" c >>= ss "b" >>= x
01:07:55 <DarkFox> @pl pc >>= \ c -> l "a" c >>= ss "a" >> l "b" c >>= ss "b" >>= x
01:07:55 <lambdabot> x =<< ss "b" =<< ap ((>>) . (ss "a" =<<) . l "a") (l "b") =<< pc
01:08:00 <DarkFox> :3
01:09:31 <DarkFox> @undo a b c = do t <- loadBody a; applyTemplateList t b c
01:09:31 <lambdabot> a b c = loadBody a >>= \ t -> applyTemplateList t b c
01:09:51 <DarkFox> Lol no help
01:10:10 <DarkFox> @pl x a b c = loadBody a >>= \ t -> applyTemplateList t b c
01:10:10 <lambdabot> x = (. (flip . flip applyTemplateList)) . (.) . (>>=) . loadBody
01:10:14 <DarkFox> hehehe
01:10:32 <DarkFox> I think no :|
01:10:49 <_d3f> can someone tell my why I get the " Couldn't match expected type `[t0]' with actual type `IO String'" error on line 24? http://sprunge.us/VTGC
01:11:54 <c_wraith> _d3f: that error message usually means you attempted to bind a list as if it was an IO action in a do block.  but let me check the paste..
01:12:08 <DarkFox> _d3f: http://sprunge.us/VTGC?haskell
01:12:19 <DarkFox> _d3f: sprunge supports colours and line numbers :)
01:12:28 <c_wraith> _d3f: ah.  In fact, the problem is the type of getBusList
01:12:41 <c_wraith> _d3f: it needs to return IO [Int], since it uses getLine
01:12:59 <_d3f> oh, thx DarkFox.
01:13:10 <_d3f> I will check it c_wraith, thx.
01:13:19 <c_wraith> _d3f: the error message means it saw that you were binding the result of getLine, which it knows is IO
01:13:50 <c_wraith> _d3f: and then later, you attempted to use getBusList in the same do block, but since you specified it was a list, not an IO action...  you get that error
01:14:57 <Cale> (and then main will have to change so that getBusList busNumber [] is actually executed)
01:15:21 <fruitFly> elliott: I'm not trolling.
01:15:58 <elliott> fruitFly: take it to #haskell-ops
01:16:58 <fruitFly> Where do you think idris is at in applicability relative to haskell?
01:17:00 <fruitFly> elliott: alright
01:17:20 <elliott> and in the meantime don't ban-evade here...
01:18:41 <DarkFox> @hoogle ap
01:18:41 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
01:18:41 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
01:18:41 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
01:22:12 <Cale> fruitFly: It has a somewhat smaller and less practical set of available libraries than Haskell did when I started using it in 2001 or so.
01:22:37 <Cale> fruitFly: But it all depends on what you intend to use it *for*
01:22:48 <Eduard_Munteanu> Somewhat smaller?
01:23:09 <elliott> Cale: this is not the first question they've asked of the form "how does haskell compare to languages X, Y and Z?"...
01:23:30 <Cale> fruitFly is the new protontorpedo?
01:23:32 <elliott> anyway they're ban evading.
01:23:35 --- mode: ChanServ set +o elliott
01:23:37 <Cale> @protontorpedo
01:23:37 <lambdabot> hu me/
01:23:39 <Cale> @protontorpedo
01:23:39 <lambdabot> so haskell is free?
01:23:40 --- mode: elliott set +b *!*2425e945@*.36.37.233.69
01:23:40 --- kick: fruitFly was kicked by elliott (fruitFly)
01:23:40 <Cale> @protontorpedo
01:23:41 <lambdabot> smalltalk is oo
01:23:41 --- mode: elliott set -o Eliel
01:23:42 <Cale> @protontorpedo
01:23:42 <lambdabot> is haskell more powerful than any jedii?
01:23:43 <elliott> um.
01:23:45 --- mode: elliott set -o elliott
01:23:49 * elliott is really bad at the "/deop el[tab]" thing.
01:24:01 * elliott wonders if there's a command specifically for "deop self"
01:24:37 <Cale> I usually just right click myself in the user list and "Take ops"
01:25:32 <t7> i remember mirc used to have $me evaluate to your username
01:25:54 <t7> good old mirc
01:26:12 <elliott> we could just ban everyone else whose name begins with "el".
01:26:15 * Cale looks through the old GHC documentation http://www.haskell.org/ghc/docs/5.00/set/finitemap.html
01:26:17 <elliott> that seems like the most practical solution
01:26:38 <Eduard_Munteanu> Well he also asked something like that in #agda just a tad bit earlier.
01:27:05 <elliott> they've used multiple nicks, no surprise they're also using multiple channels.
01:27:10 <Eduard_Munteanu> < fruitFly> is agda more for theorem proving where as idris is being engineering more for application?
01:27:11 <h4199> A curious predilection
01:28:25 <bitonic> Eduard_Munteanu: I did give a diplomatic reply to that one :P
01:28:31 <Eduard_Munteanu> Yes. :)
01:28:51 <Eduard_Munteanu> Well, you and Cale. :P
01:29:06 <Cale> http://www.haskell.org/ghc/docs/5.00/set/set.html -- type signatures goot documentation
01:29:08 <bitonic> I missed what happened here.  it was Haskell vs what?
01:29:17 <Eduard_Munteanu> bitonic: vs Idris
01:29:21 <bitonic> ah.
01:31:21 <Cale> It's actually interesting to go back to this old documentation and find out how much stuff was there before I knew about it :)
01:31:58 <elliott> Cale: such weird names.
01:32:10 <Cale> http://www.haskell.org/ghc/docs/5.00/set/sec-iarray.html
01:32:13 <elliott> heh, if you go up it mentions Edison
01:32:20 <Cale> I had no idea IArray was quite this old
01:32:43 <Cale> I only realised that IArray existed after it had already been moved to Data.Array.IArray
01:32:56 <Eduard_Munteanu> Unfortunately the suckiness carried on unchanged, at first glance. :)
01:33:30 <Cale> I like how most of the documentation doesn't even bother saying what any of the functions do.
01:34:49 <bitonic> it’s blindingly clear
01:35:40 <Cale> It actually is pretty clear
01:37:46 <elliott> Cale: I hear parametricity means you can deduce everything about a function from its type.
01:37:50 <elliott> so clearly documentation is obsolete.
01:38:29 <Cale> I mean, how many functions of type (Ix ix, IArray a e) => (e->f->e) -> e -> (ix,ix) -> [(ix,f)] -> a ix e  are there anyway?
01:39:40 <Twix> :o
01:39:40 <Cale>   withHandleFor :: Handle -> Handle -> IO a -> IO a
01:39:40 <Cale>   withStdout    :: Handle -> IO a -> IO a
01:39:40 <Cale>   withStdin     :: Handle -> IO a -> IO a
01:39:40 <Cale>   withStderr    :: Handle -> IO a -> IO a
01:39:45 <Cale> ^^ wat
01:39:59 <Cale> I don't think you can even presently do that.
01:40:27 <shachaf> kosmikus = Andres Löh?
01:40:31 <shachaf> I didn't know that.
01:40:43 <Botje> couldn't you just reopen the file descriptors?
01:41:03 <elliott> Cale: I think you can
01:41:49 <kosmikus> shachaf: yes. why?
01:42:02 <mmaruseacph2> @hoogle (Ix ix, IArray a e) => (e->f->e) -> e -> (ix,ix) -> [(ix,f)] -> a ix e
01:42:03 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
01:42:03 <lambdabot> Data.Array accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
01:42:06 <mmaruseacph2> just 2
01:42:33 <shachaf> kosmikus: Just associating names and nicks.
01:42:54 <kosmikus> shachaf: hehe :) why did you figure it out just now?
01:50:51 <shachaf> kosmikus: GSoC email.
01:52:36 <kosmikus> shachaf: I see. Makes sense :)
01:58:58 * hackagebot ghc-heap-view 0.5 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.5 (JoachimBreitner)
02:07:14 <hpaste> rifki pasted “defining a class for a data type” at http://hpaste.org/86359
02:07:28 <rifki> not finished yet, sorry
02:10:43 <hpaste> rifki revised “defining a class for a data type”: “defining a class for a data type” at http://hpaste.org/86359
02:11:02 <rifki> Hi, I posted a question on hpaste, can you have a look at it please?
02:12:10 <merijn> rifki: Well, "Graph m" and "Graph n" are only equal if m and n are equal, right?
02:12:24 <shachaf> Why do you have to define a class?
02:12:31 <merijn> shachaf: homework, probably
02:12:37 <rifki> merjin : yes
02:12:50 <rifki> shachaf : merjin is right
02:13:01 <shachaf> OK, but why?
02:13:04 <shachaf> Are you sure you mean a class?
02:13:32 <merijn> rifki: So you need to start implementing equality for m and n in the function body of "Graph m == Graph n"
02:13:55 <shachaf> If your goal is to make an Eq instance, you don't need a class for that.
02:14:05 <shachaf> Anyway I'm not sure what the question is.
02:14:31 <rifki> merijn : I made the implementations
02:14:37 <rifki> they work correctly
02:14:45 <rifki> but I'm stuck with the class part
02:15:00 <shachaf> Maybe you don't understand your homework.
02:15:03 <rifki> shachaf : yes I need a class, I wrote what it's written in the text
02:15:05 <shachaf> I know I don't. :-)
02:15:27 <shachaf> "newClass" is an invalid name for a class, because a class name starts with an uppercase letter.
02:15:29 <johanneslippmann> Hy there, is there a way to make Haskell code as unreadable as possible?
02:15:49 <quchen> rifki, there's a very clear distinction between classes and class instances. Make sure you understand that difference first.
02:16:06 <Kinnison> johanneslippmann: You can obfuscate it, yes.  However why would you want to?
02:16:06 <bitonic> johanneslippmann: good question.  are you looking for a mechanised way?
02:16:10 <quchen> johanneslippmann, maybe start here: https://github.com/quchen/unmaintainable_haskell/blob/master/README.md
02:16:11 <rifki> shachaf : oh it was NewClass sorry
02:16:48 <johanneslippmann> I hoped for an mechanised way, yes.
02:16:52 <shachaf> OK. I still don't understand your question.
02:16:56 <Kinnison> rifki: Why don't you just derive Eq in your data types?
02:17:06 <quchen> johanneslippmann, compiling the code usually obfuscates it beyond regognition
02:17:22 <johanneslippmann> It is about the Haskell course I am hearing these days - and I want to troll my lector.
02:17:27 <rifki> quchen : I think I know the difference. There is an Eq class, and we give class instances for specific types from that class
02:17:38 <immanuelkant> typeclass
02:17:39 <rifki> Kinnison : I have to do it that way :(
02:18:23 <shachaf> Kinnison: Presumably graph equality isn't the same as equality of the list that represents it.
02:18:55 <johanneslippmann> Is there perhaps a way to decompile already compiled code?
02:19:04 <quchen> johanneslippmann, no.
02:19:36 <quchen> johanneslippmann: You can of course look at the ASM generated and guess what the program does, but that's about as far away from the Haskell source as you can get.
02:19:43 <immanuelkant> may be he is askin for a way to implement eq by himself, a new typeclass without just deriving eq
02:20:04 <bitonic> johanneslippmann: get the GHC core, and reconvert it to Haskell.  that shouldn’t be too hard.
02:20:55 <rifki> I think I want to write another class just like Eq class, but I don't know what it should be like...
02:21:05 <johanneslippmann> Hmm, ok. I'll try to do so.
02:21:20 <johanneslippmann> My lector hopefully didn't read that ;)
02:22:01 <quchen> rifki: You can of course re-implement the Eq typeclass, call it "MyEq" or something.
02:22:13 <typoclass> ... that was odd. he wants to unreadablify his source code to get on the nerves of his instructor?
02:22:15 <Kinnison> rifki: it sounds like a really odd question to be asked
02:22:59 <rifki> the question in the text?
02:23:27 <quchen> typoclass: Sounds like an excellent idea. That'll show his teacher!
02:24:31 <Kinnison> rifki: Are you allowed to assume Ord x ?
02:25:18 <Kinnison> rifki: If so, I'd derive Node from Ord and then do something like (Graph m) == (Graph n) = (sort m) == (sort n)
02:25:27 <Kinnison> But that might not be quite right
02:26:13 <rifki> I handled the right side of the =
02:26:49 <rifki> Kinnison : I couldn't do the class part
02:26:59 <Kinnison> I'm unclear what the class part is asking for
02:27:18 <immanuelkant> rifki: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
02:27:57 <rifki> Kinnison : define a new class and give instances from that class
02:28:41 <quchen> rifki: The "YesNo" type class LYAH develops is a pretty good example of how to do this.
02:29:19 <Kinnison> rifki: I'm confused :-( (and really busy) So I'll let others help you
02:29:37 <rifki> I will read the whole page, thanks all
02:33:47 <immanuelkant> the way Eq typeclass is defined just blew my mind..
02:34:19 <immanuelkant> how does that work..
02:34:27 <shachaf> How does what work?
02:34:32 <immanuelkant> wait
02:36:31 <mr-> The tuples instances are funny
02:37:11 <immanuelkant> https://gist.github.com/syllogismos/5442183
02:37:38 <immanuelkant> it says 'Anyway, we did implement the function bodies for the functions that Eq defines, only we defined them in terms of mutual recursion. We said that two instances of Eq are equal if they are not different and they are different if they are not equal. We didn't have to do this, really, but we did and we'll see how this helps us soon."
02:38:38 <immanuelkant> mutual recursion? it defined == equals not (/=) and /= equals not (==)
02:38:51 <shachaf> Oh, that.
02:38:58 <merijn> immanuelkant: Unless you define either of the two functions you'll infinite loop
02:39:05 <shachaf> You have to define one or both of the functions when you make an instance.
02:39:22 <shachaf> It's just for convenience -- you can define either one and get the other automatically.
02:39:24 <merijn> immanuelkant: They're *default* implementations, so when you define an instance you only need to define one of the two, instead of both
02:39:24 <immanuelkant> yeah, but that is how Eq typeclass is defined..
02:39:32 <quicksilver> immanuelkant: the comment is wrong, incidentally.
02:39:35 <quicksilver> "We said that two instances of Eq are equal if they are not different"
02:39:47 <quicksilver> that comment is confusing (and incorrect)
02:40:02 <immanuelkant> so that is not the complete implementation of Eq?
02:40:08 <merijn> immanuelkant: Try it, "data Foo = Foo; instance Eq Foo", now run "Foo == Foo" in the interpreter and it should infinite loop
02:40:21 <merijn> immanuelkant: (becayse of the mutual recursion)
02:40:25 <elliott> immanuelkant: you shouldn't be learning from whoever wrote that comment, most likely.
02:40:27 <elliott> they sound confused.
02:40:36 <quicksilver> immanuelkant: that is the definition of the typeclass.
02:40:38 <hpaste> gishuel pasted “build balanced binary tree” at http://hpaste.org/86361
02:40:40 <immanuelkant> its in learnyouahaskell
02:40:47 <quicksilver> immanuelkant: the definition of a typeclass doesn't "implement" it.
02:40:53 <quicksilver> immanuelkant: the implementation is left to the instances
02:40:53 <typoclass> immanuelkant: yes. the Eq typeclass is not the complete implementation. you need to look at one or more instances as well
02:41:00 <quicksilver> so there is one implementation per type
02:41:02 <elliott> does LYAH really say "We said that two instances of Eq are equal if they are not different and they are different if they are not equal"?
02:41:05 <elliott> :/
02:41:17 <merijn> immanuelkant: It is the complete definition of the class, but you're supposed to write "instance Eq MyData where x == y = {- whatever -}"
02:41:21 <shachaf> @google "We said that two instances of Eq are equal if they are not different and they are different if they are not equal"
02:41:22 <lambdabot> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
02:41:22 <lambdabot> Title: Making Our Own Types and Typeclasses - Learn You a Haskell for Great Good!
02:41:30 <elliott> terrible.
02:42:10 <merijn> immanuelkant: If your instance declaration doesn't define a function, it'll use the default implementation from the class definition
02:42:32 <immanuelkant> so when deriving Eq i'm not doing anything extra
02:42:38 <merijn> immanuelkant: So defining the class like this means you only have to implement (==) to get (/=) for free, or alternatively implement (/=) to get (==) for free
02:42:41 <true_droid> could someone explain the order of function application in this fragment? "map read `fmap` getArgs" from here http://book.realworldhaskell.org/read/profiling-and-optimization.html#id677609
02:43:02 <shachaf> true_droid: It means: fmap (map read) getArgs
02:43:07 <merijn> true_droid: fmap (map read) getArgs
02:43:20 <merijn> true_droid: infix always has lower binding than prefix application
02:43:23 <true_droid> merijn, shachaf: thanks
02:43:44 <merijn> true_droid: Incidentally <$> is infix fmap
02:44:04 <merijn> :t fmap (+1)
02:44:06 <lambdabot> (Functor f, Num b) => f b -> f b
02:44:20 <merijn> :t ((+1) <$>)
02:44:22 <lambdabot> (Functor f, Num b) => f b -> f b
02:44:23 <true_droid> merijn: so "map read <$> getArgs" would be the same?
02:44:29 <merijn> true_droid: Yes
02:44:36 <true_droid> I see, thanks
02:45:02 <Ghoul_> Anyone know how to completely ignore a symbol using Parsec
02:45:04 <danr> :t (read <$>) <$> getArgs
02:45:05 <lambdabot> Not in scope: `getArgs'
02:45:07 <danr> :(
02:45:10 <Ghoul_> without adding it to the parsing output
02:45:34 <immanuelkant> merijn: but when im deriving a new data type, im not doing anything extra, like implementing (==) just deriving Eq..
02:45:53 <typoclass> immanuelkant: in principle, a typeclass is only a group of function signatures. an instance of a typeclass is an implementation for each of those function. 'deriving Eq' will automate writing an instance and the implementation, but you can always write this by hand
02:46:33 <typoclass> immanuelkant: sometimes, a typeclass will not only have signatures, but also implementations. but that's only a small convenience for when you write an instance. you can't call this code directly; you always need to go through an instance
02:46:43 <typoclass> immanuelkant: (i hope this clears things up :-) )
02:47:23 <quicksilver> immanuelkant: "deriving Eq" is something completely different.
02:47:37 <quicksilver> immanuelkant: "deriving Eq" is compiler magic which has nothing to do with the class definition
02:48:01 <quicksilver> "deriving Eq" means "use the secret GHC recipe to write a nice efficient Eq instance for me so I don't have to"
02:48:16 <quicksilver> that magic is limited to a fixed set of predefined classes.
02:48:23 <immanuelkant> quicksilver: the thing that confuses me is how Eq is defined https://gist.github.com/syllogismos/5442183
02:48:54 <supki> Ghoul_: anyChar
02:49:17 <quicksilver> immanuelkant: that simply provides a default implementation for (/=) so you don't have to define it if you don't want to.
02:49:21 <quicksilver> and vice versa.
02:49:27 <supki> Ghoul_: for example,  string "foo" <* anyChar  will parse string "foo" and whatever character after it and return "foo"
02:49:34 <quicksilver> you are still required to implement one or the other (/=) or (==)
02:49:51 <quicksilver> deriving is something else.
02:50:06 <typoclass> immanuelkant: to reiterate, that's not a complete thing. you an instance to complete this. the instance will have to replace (==) or (/=). or even both
02:50:18 <typoclass> *you need an instance
02:50:22 <immanuelkant> can you show me how default == is defined.. just curious
02:50:49 <merijn> immanuelkant: "deriving" basically makes GHC programmatically write the necessary Eq instance for you
02:51:29 <Ghoul_> supki: thanks
02:51:48 <Ghoul_> I actually got around it with -- optional $ skipMany1 $ symbol ";" in my case
02:53:52 <elliott> immanuelkant: the default (==) is in that paste.
02:54:18 <immanuelkant> typoclass: that makes sense,what you said.. what confused me is that in learnyouahaskell its said that Eq typeclass is defined using mutual recursion and they didnt define == or /=
02:54:28 <immanuelkant> elliott: line no?
02:54:42 <hpaste> merijn pasted “Eq and stuff” at http://hpaste.org/86362
02:54:42 <elliott> immanuelkant: 6
02:54:54 <merijn> immanuelkant: Take a look at that paste
02:54:55 <typoclass> immanuelkant: yeah, in my opinion that's not very clearly written
02:55:52 <typoclass> merijn++, that's good
02:56:35 <merijn> immanuelkant: In both cases if you don't define *any* of the functions (i.e. neither == nor /=) you get an infinite recursion when you try to use them
02:57:57 <typoclass> ('infinite recursion' meaning the instance doesn't work because the programmer made a mistake. your program will loop forever.)
02:58:19 <merijn> It works, it just doesn't do what you want :p
02:59:09 <merijn> immanuelkant: Did that help?
02:59:21 <immanuelkant> so thats not how Eq is defined in prelude..? cause normally i dont do the instance Eq where etc.. i just write deriving Eq
02:59:34 <merijn> immanuelkant: It is, but deriving is different
02:59:42 <immanuelkant> ohh okay
02:59:46 <merijn> immanuelkant: The implementation of Eq is "obvious", right?
03:00:00 <merijn> immanuelkant: It is, in fact, so obvious we can have GHC auto-generate it
03:00:08 <merijn> immanuelkant: Which is what "deriving Eq" does
03:00:09 <immanuelkant> it is obvious..
03:00:23 <merijn> immanuelkant: It just means "I can't be arsed writing obvious stuff, please do it for me"
03:00:25 <immanuelkant> ohhhhhhh
03:01:06 <merijn> immanuelkant: GHC just generates code the compares all constructors, if the constructors have arguments it compares all of those too
03:01:08 <typoclass> immanuelkant: "deriving Eq" will do pretty much the same thing that merijn did by hand. it will basically auto-generate that hpaste
03:01:23 <immanuelkant> can you explain me what the code you wrote, merijn ..
03:01:49 <Zouppen> i have never needed to do my own Eq. I think it is needed only if there are many different internal structures of the same content, like in Trees and lazy ByteStrings
03:01:52 <immanuelkant> merijn: no i understood
03:01:56 <merijn> If you have questions, sure. I'm not really sure what to explain, though :)
03:01:57 <typoclass> immanuelkant: deriving is just a shortcut to save the programmer some typing. the basic mechanics don't change
03:02:07 <shachaf> immanuelkant's type needs a manual Eq instance.
03:02:28 <merijn> Zouppen: Well, you can need to do your own Eq if you want to ignore some "internal" value that just does some caching/whatever
03:02:58 <immanuelkant> no not me, another guy.. im jsut learning and how Eq is defined surprised mem
03:04:57 <Zouppen> merijn: okay, so it may be considered for optimization reasons?
03:05:26 <merijn> Zouppen: That too
03:05:31 <typoclass> Zouppen: yeah, 'deriving' is pretty effective. but still, the situation is that there's the Eq typeclass, and there's instances of it. if you use deriving to auto-generate some instances, then you still have one typeclass and its instances. it doesn't change the mechanics :-)
03:05:38 <merijn> Most people will never have to do that, though
03:06:39 <typoclass> (just to be clear, because it sounded like people were saying "i use deriving, which has nothing to with instances". this isn't the case)
03:10:16 <Zouppen> okay, now I see, I didn't even think the possibility to override just one function of a derived typeclass
03:10:29 <mauke_tmp> ?
03:10:52 <mauke_tmp> you don't derive typeclasses, you derive instances
03:13:03 <shachaf> I,I makeClassy ''Foo
03:13:05 <Zouppen> okay
03:13:26 <no-n[0]> > x^a/x^b==x^(a-b)
03:13:30 <lambdabot>   mueval-core: Time limit exceeded
03:13:34 <Zouppen> i'm not yet too good in haskell terminology
03:13:42 <no-n[0]> > x**a/x**b==x**(a-b)
03:13:43 <lambdabot>   False
03:13:55 <no-n[0]> is there something like Debug.SimpeReflect that's more algebra friendly?
03:14:00 * hackagebot http-streams 0.5.0.1 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.5.0.1 (AndrewCowie)
03:15:58 <typoclass> io-streams, eh? because we don't have enough iteratees and pipes and conduits already
03:16:15 <shachaf> To be fair, most of them are awful.
03:16:34 <shachaf> Life is also awful. Everything is awful.
03:16:37 <typoclass> shachaf: heh. fair point
03:17:34 <typoclass> shachaf: is there a blog post/SO answer/... that gives some reasons why conduits are awful? they're the only ones in that area that i've used
03:18:27 <shachaf> I don't even know what they look like nowadays. Didn't they change completely a couple of times?
03:18:43 <shachaf> Last time I looked at iteratee-ish things, they were all pretty awful-looking. But it was quite a while ago.
03:19:09 <typoclass> shachaf: not sure. i've heard someone say "conduits were good initially, but around version x.y they kind of lost their simplicity and elegance"
03:19:17 <arbn> I failed at learning conduits in the time that I had allotted to look at them. io-streams seemed much easier for a noob like me.
03:20:24 <typoclass> arbn: interesting. i guess i'll have a look at io-streams then
03:20:35 <elliott> io-streams barely does anything at all.
03:20:51 <elliott> it is simpler than all the conduit-y packages because it doesn't do a fraction of what they do
03:20:57 <elliott> it's far closer to something like Handle
03:21:46 <yitz> shachaf: conduits is not an iteratee-ish thing. no iteratees around. i don't think pipes are either.
03:21:59 <yitz> no cps.
03:22:50 <yitz> shachaf: basically, the remaining complexity is similar to the problem with lenses: the types have lots of parameters.
03:23:20 <yitz> shachaf: and as in lenses, you usually don't have to think about those. just use the supplied combinators.
03:24:06 <yitz> typoclass: i think the opposite is true of conduits. at the beginning they were complicated because of cps. now that's gone, and they're pretty simple and intuitive.
03:24:27 <shachaf> It has the same general goal as iteratee-ish things, doesn't it?
03:24:40 <yitz> shachaf: replace lazy io you mean. yes.
03:25:08 <typoclass> elliott: hm. i guess they still might be useful as a minimal replacement for lazy i/o? for the use case "i just quickly need some Handles and hGetContents, but i find it too brittle; i don't want to pay close attention where i'm doing hClose"
03:25:10 <yitz> as opposed to io-streams, which is really something different than conduits and pipes.
03:25:44 <elliott> typoclass: well, it's just the same as doing strict IO, really.
03:25:51 <elliott> that's the option everyone likes to forget :P
03:26:08 <yitz> typoclass: the main feature of conduits is that it is built on top of ResourceT, which gives you fine-grained control over exactly when resources are allocated and released.
03:26:18 <shachaf> elliott: The Prelude doesn't give you a strict I/O option. :-(
03:27:17 <yitz> elliott: no, you can use conduits (and probably pipes) together with things like lazy text and lazy bytestrings, too.
03:28:12 <arbn> http://www.haskellforall.com/2013/04/pipes-and-io-streams.html <-- Hmm. This is interesting.
03:29:02 <typoclass> arbn: thanks for the link, it looks very relevant
03:29:03 <yitz> io-streams is really a replacement for the low-level interface to handles. JaffaCake considered moving to it years ago. however, defining its semantics is very fiddly, and it was never completely worked out.
03:29:52 <yitz> io-streams implements that interface on top of the current one, at a high level. tekmo showed that you can even implement it on top of pipes.
03:30:24 <elliott> yitz: err, when did I say otherwise?
03:30:45 <yitz> < elliott> typoclass: well, it's just the same as doing strict IO, really.
03:31:07 <typoclass> yitz: you mean years ago they considered moving to something pretty much like io-streams, right? because io-streams itself had its first upload like 6 weeks ago
03:31:18 <elliott> yitz: that was re: io-streams
03:31:27 <yitz> typoclass: it's a resurrection of a very old idea, yes.
03:31:45 <typoclass> yitz: ok :-) i was confused for a minute
03:32:33 <yitz> typoclass: and i think the old problems that led to it not being adopted still remain
03:32:40 <Ghoul_> is there a shorthand for this
03:32:42 <Ghoul_> http://puu.sh/2Fv0J/264f6600af.png
03:32:56 <shachaf> IntLit <$> integer
03:32:58 <Ghoul_> like, can I do some composition hacks
03:33:02 <shachaf> StringLit <$> stringLiteral
03:33:07 <Ghoul_> Oh beautiful
03:33:14 <shachaf> @src liftM
03:33:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:33:28 <shachaf> liftM = fmap = (<$>) = (.) = map = ...
03:33:29 <typoclass> Ghoul_: <$> is an alias for fmap
03:33:33 <shachaf> = liftA
03:33:49 <Ghoul_> where does it import from?>
03:33:57 <typoclass> Ghoul_: Control.Applicative
03:34:27 <yitz> Ghoul_: Data.Functor
03:34:42 <yitz> Control.Applicative re-exports it
03:35:01 <Ghoul_> Yeah I have to use Data.Functor otherwise I get like 50 duplicate symbols
03:35:02 <yitz> but you don't need an Applicative instance to use fmap
03:35:02 <shachaf> Ghoul_: You should probably use hpaste.org or something instead of posting screenshots of code, by the way.
03:35:03 <elliott> Ghoul_: consider using hpaste.org rather than screenshots?
03:35:06 <elliott> haha
03:35:08 <elliott> good timing.
03:35:09 <Ghoul_> lol
03:35:20 <Ghoul_> Okay, will do in future
03:35:25 <elliott> now everyone knows I am shachaf's sockpuppet.
03:35:45 <shachaf> I'm the sockpuppet around here!
03:35:52 <yitz> shachaf: consider the Marionette interface, it's more flexible
03:36:24 <shachaf> elliott: @msg #haskell we both reached for the gun
03:37:14 <t7> "How to learn about Monads: 1) Get a PhD in computer science. 2) Throw it away because you don’t need it for this section!"
03:37:24 <lambdabot> I am also shachaf
03:38:14 <yitz> Ghoul_: you should always import a specific list of symbols from Control.Applicative, like import Control.Applicative ((<$>))
03:38:32 <yitz> Ghoul_: or import it qualified, like import qualified Control.Applicative as A
03:38:48 <yitz> Ghoul_: qualified is annoying for operators like <$>, though
03:39:51 <merijn> t7: Reminds me of this "things I wish I knew when I started learning haskell" slide deck
03:39:54 <shachaf> lambdabot: Are not!
03:39:55 <yitz> @nixon who are you?
03:39:55 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
03:39:57 <shachaf> Argue: hi Argue
03:40:06 <Argue> hi shachaf
03:40:15 <merijn> (searching link now)
03:40:15 <shachaf> Any Haskellin' lately?
03:40:56 <lambdabot> shachaf: it's pointless. our cover is blown.
03:40:58 <Argue> no actually
03:41:09 <Argue> what an embarrassing confession
03:41:23 * arbn goes back to his masochistic interactions with HXT.
03:41:28 <merijn> t7: http://dev.stephendiehl.com/hask/#(8)
03:41:33 --- mode: ChanServ set +o elliott
03:41:39 <merijn> "The Eight Fold Path to Monad Satori" :p
03:41:45 * typoclass . o O ( i never import Control.Applicative qualifiedly ... )
03:41:51 --- mode: elliott set +b *!*@106.51.151.62$##fixyourconnection
03:42:00 <merijn> typoclass: Does anyone? >.<
03:42:13 <shachaf> lambdabot: Stop it, you're embarrassing me.
03:42:21 <typoclass> merijn: yitz does! see above
03:42:26 --- mode: elliott set -b *!*@106.51.151.62$##fixyourconnection
03:42:37 <merijn> yitz: You crazy!
03:42:39 --- mode: elliott set -o Eliel
03:42:43 <elliott> (*#*$(!
03:42:47 --- mode: elliott set -o elliott
03:42:51 <shachaf> Poor Eliel
03:42:57 <shachaf> * elliott casts ##fixyourconnection on ananthakumaran1
03:43:13 * merijn is happy to have JOIN/PART disabled for #haskell :p
03:43:23 <elliott> who knew that setting a ban could fix someone's client?
03:43:29 <elliott> uh oh.
03:43:50 <t7> merijn, ah yeah i read this a little while ago :)
03:45:16 <merijn> I like point 8 :p
03:45:49 <typoclass> i think "write code" should be way higher on the list
03:45:53 <augur> someone should make a nice little Write-Yourself-a-Scheme package that encourages custom language design
03:46:40 <t7> all schemes should be pure
03:46:53 <augur> :p
03:47:10 <merijn> t7: And have strong static typing
03:47:20 <t7> amen
03:47:21 <merijn> Maybe some way to write these types down in signatures..
03:47:39 <t7> with runtime parsing
03:47:59 <augur> (:: map (-> (-> a b) (-> (list a) (list b)))
03:48:14 * typoclass giggles
03:48:19 <merijn> @remember MartinDeMello Any sufficiently well-commented Lisp program contains an ML program in its comments.
03:48:20 <lambdabot> Okay.
03:48:20 <t7> delightfully hideous
03:48:21 <augur> actually this might be a case where montague's type notation is better
03:48:31 <augur> (:: map ((a b) ((list a) (list b)))
03:48:53 <augur> even thats kinda sucky tho. maybe just macro it so you get proper ->
03:48:58 <typoclass> augur: still worse than haskell :)
03:49:25 <augur> typoclass: yeah, i think with macro stuff you can do it properly tho.
03:56:06 <merijn> augur: Oh, you were trying to do lisp type signatures?
03:56:15 <merijn> augur: Doesn't Typed Racket already do that?
03:56:15 <augur> merijn: i was faking them
03:56:29 <augur> trying to figure out what the "obvious" notation would be
04:20:10 <czro> Is there a clever way to combine a bunch of nested lambdas where the innermost one need to have access to all arguments from the enclosing lambdas?
04:20:26 <Botje> czro: can you show code? easier to reason about taht way
04:20:37 <czro> (\foo -> \bar -> dostuff foo bar)
04:20:54 <Botje> that's just the same as \foo bar -> dostuff foo bar
04:20:56 <shachaf> What is your question?
04:20:59 <Botje> (or even just 'dostuff')
04:22:10 <Mortchek> @pl \foo -> \bar -> dostuff foo bar
04:22:10 <lambdabot> dostuff
04:22:25 <typoclass> czro: a lambda with several arguments looks like "\arg1 arg2 arg3 -> ...". if that's what you're asking
04:22:38 <czro> I'll try to explain.. I'm calling a c function that needs two ForeignPtrs and a bunch of vectors (double*). I think I can write this with nesting withForeignPtr and Vector.usafeWith...
04:22:59 <Botje> I vaguely remember that you can abuse ContT for that.
04:23:06 <czro> not much clearer I guess... hmmm...
04:23:22 <czro> I was thinking about something abusive like that.
04:23:52 <Botje> http://www.haskell.org/haskellwiki/Bracket_pattern
04:23:55 <shachaf> You want to flatten out "foo $ \x -> bar $ \y -> ...x...y..."?
04:24:56 <czro> no.. trying to do a more descriptive example...
04:26:29 <czro> withForeignPtr x (\xp -> withForeignPtr y (\yp -> Vector.unsafeWith vec1 (\ .... call_c_function xp yp vec1 vec2 ...
04:26:53 <Botje> czro: yeah, see the link above.
04:27:23 <Botje> oh, wait
04:27:30 <Botje> it requires all your stuff to have the same type :(
04:27:45 <Botje> well, two calls is still better than four, i guess.
04:27:47 <shachaf> czro: OK, so it looks like the thing I said.
04:28:55 <czro> shachaf: It seems so.
04:29:34 <shachaf> I bet you can do something clever with ContT, like Botje said.
04:30:28 <Ghoul_> What am I doing wrong
04:30:29 <Ghoul_> intLit, strLit :: Parser Expr
04:30:34 <Ghoul_> I thought that was allowed
04:30:48 <czro> shachaf: I'll give that a try. Thanks. This channel is just amazingly helpful. I hope to contribute back some time.
04:31:37 <shachaf> λ> (`runContT` return) $ do { x <- cforM_ [1..3]; y <- cforM_ [10..13]; lift (print (x,y)) }
04:31:48 <shachaf> Where cforM_ = ContT . forM_
04:32:56 <shachaf> czro: So in your case the same thing with your functions.
04:33:07 <shachaf> There are various caveats, of course. It might not be a good idea in practice.
04:34:20 <czro> shachaf: I'll give it a try. I can always do the thing manually. Thanks again.
04:34:50 <Ghoul_> Is there a way I can declare a heap of functions as the same type without using a new line for each
04:35:03 <Ghoul_> I thought such was valid ; intLit, strLit :: Parser Expr
04:35:19 <shachaf> I thought it was valid too.
04:35:28 <quicksilver> I thought it was valid three.
04:35:39 <shachaf> If your code isn't working, maybe you should show your code.
04:36:37 <mauke_tmp> s/show your code/show the error message/
04:36:41 <hpaste> Ghoul pasted “Errors” at http://hpaste.org/86363
04:36:56 <mauke_tmp> those aren't "errors"
04:37:09 <Palmik> Hmm, is it possible to use base-4.6.* with ghc 7.4.1?
04:37:23 <shachaf> Let's compromise on both the code and the error message.
04:37:25 <yitz> merijn: right. never mind. importing Control.Applicative qualified isn't what people do.
04:37:39 <Ghoul_> ^
04:37:45 <shachaf>     Duplicate type signature:
04:37:49 <shachaf>     Multiple declarations of `strLit'
04:37:52 <mauke_tmp> Ghoul_: show your real code
04:37:58 <Ghoul_> That's the whole thing.
04:38:02 <mauke_tmp> no, it's not
04:38:11 <mauke_tmp> I bet your real code doesn't have compiler errors in the middle of it
04:38:15 <yitz> merijn: i don't think i ever import it without an import list, though. there are just too many things that overlap with other modules.
04:38:25 <typoclass> Palmik: ugh :-/ in general, you should use only the base version that came with ghc. it's unlikely to work otherwise, unless you know very precisely what you're doing
04:38:40 <shachaf> Ghoul_: In particular, that error refers to lines 84 and 87.
04:38:46 <hpaste> Ghoul pasted “This works” at http://hpaste.org/86364
04:38:50 <yitz> hi mauke_tmp. what's the prognosis for preflex?
04:39:02 <merijn> yitz: I tend to just hide the overlapping things I use
04:39:13 <mauke_tmp> yitz: dead until I can get internet
04:39:14 <yitz> ok that works too
04:39:24 <shachaf> Ghoul_: What works isn't so relevant here.
04:39:30 <yitz> mauke_tmp: ohhh. yeah, that would do it. good luck with that.
04:39:32 <shachaf> Ghoul_: You should do what mauke said.
04:39:33 <tdammers> my strategy is qualified imports for things that tend to cause a lot of overlap
04:39:38 <shachaf> Ghoul_: Post your entire code, unedited.
04:39:51 <yitz> tdammers: even Control.Applicative?
04:39:57 <tdammers> yitz: no
04:40:13 <tdammers> for that I actually use an import list most of the time
04:40:34 <typoclass> yitz: which modules does Control.Applicative have significant overlap with?
04:40:36 <Ghoul_> Uh, moment
04:40:41 <Palmik> typoclass: Yeah, well... the reason I'm asking is that I would like to benchmark against a library that does not work on newer versions of GHC, but using older version of GHC means using older version of containers package, which would be unfair to the other libraries.
04:40:47 <yitz> tdammers: i do the opposite. i like to be able to see quickly where functions come from, without grepping, searching haddocks, etc. so i try to use explicit import lists as much as possible.
04:40:48 <Ghoul_> Something magic hapenned
04:40:53 <tdammers> but for things like happstack, cairo, parsec, etc., it becomes unwieldy quite quickly
04:40:54 <Lumpy> Hey all! :)
04:40:55 <Ghoul_> *happened
04:41:28 <Palmik> typoclass: I guess I could have two separate benchmarks.
04:41:36 <Lumpy> Quick question, is anyone free at all to help with a Stack Overflow problem I have posted on there? I can simply ask the question here. And hope for any help at all.
04:41:54 <typoclass> Palmik: i suggest that you look at installing different versions of ghc (which will bring different versions of base). if i've heard correctly that's not too difficult. lots of people do it
04:42:01 <shachaf> Lumpy: No one can help you if you don't ask your question.
04:42:05 <Lumpy> http://bit.ly/17fCHVF
04:42:08 <Ghoul_> Uhm, okay.
04:42:17 <shachaf> Can you post that without a URL shortener please? :-)
04:42:20 <Ghoul_> I can compile the old code and the new code without errors now.
04:42:22 <Ghoul_> Wierd as.
04:42:25 <Lumpy> Yep, one sec.
04:42:31 <Lumpy> http://stackoverflow.com/questions/16165602/haskell-filtering-and-sorting-information-returned-correctly/16167904?noredirect=1#16167904
04:42:33 <Lumpy> :)
04:42:36 <Ghoul_> *weird
04:42:39 <Lumpy> Sorry, wasn't sure of peoples preference.
04:42:44 <shachaf> Ghoul_: What happened is that you didn't take the old strLit :: signature away, you just added the new one in.
04:43:04 <mauke_tmp> duplicate signature and duplicate definition, according to the compiler
04:43:09 <yitz> tdammers: category and functor stuff. and some parser libraries have things named the same as alternative stuff, not even always re-exports of Control.Applicative.
04:43:13 <shachaf> Oh, maybe that's not what happened.
04:43:35 <shachaf> Maybe you just copied something, saved, and then deleted one of the copies.
04:43:37 <shachaf> Lots of possiblities.
04:43:51 <Ghoul_> I think its the latter or something
04:43:53 <shachaf> If you post your whole code as being fed to GHC, people can tell you whether it's valid and why. :-)
04:43:58 <Ghoul_> my fault anyhow, false alarm
04:44:08 <typoclass> Palmik: alternatively, you could change the library that is picky about the base version. if you're lucky, you only need to do a few steps: "cabal unpack thelibrary ; cd thelibrary ; vim thelibrary.cabal", and change "base < 4.1.2.3" to accept other versions, then "cabal install" inside that directory
04:44:54 <hidenori> how do haskell beginners usually practice programming haskell? im solving project euler but it's a little too difficult for me...
04:44:59 <Ghoul_> :t <$>
04:45:01 <lambdabot> parse error on input `<$>'
04:45:02 <tdammers> Lumpy: read the answer on SO again
04:45:08 <typoclass> :t (<$>)
04:45:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:45:11 <typoclass> Ghoul_: ^^
04:45:12 <Palmik> typoclass: It's not a dependency issue, the library (or more precisely its dependency) outright does not compile (http://hackage.haskell.org/package/unpack-funcs)
04:45:27 <typoclass> hidenori: how about "99 problems"?
04:45:32 <tdammers> Lumpy: hint: the "handy functions" are both given inside the same answer
04:45:32 <typoclass> @google haskell 99 problems
04:45:34 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
04:45:34 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
04:45:52 <Ghoul_> is there a way to use it for more than 1 argument
04:46:34 <merijn> hidenori: I tend to think Project Euler is a bad start, as they focus on the wrong things for programming
04:46:35 <yitz> hidenori: there are exercises in many haskell books.
04:46:53 <merijn> hidenori: There's a few subreddits devoted to programming challenges/assignments, I forgot their names, though
04:46:54 <byorgey> Ghoul_: yes, but for that you need Applicative
04:46:56 <hidenori> >typoclass thanks! i'll check it
04:46:56 <mauke_tmp> Ghoul_: in combination with <*>, yes
04:47:08 <hidenori> >lambdabot  thanks :)
04:47:14 <byorgey> :t \f x y -> f <$> x <*> y
04:47:15 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
04:47:18 <byorgey> Ghoul_: ^^^
04:47:33 <Ghoul_> Thaaaat's awesome
04:47:35 <hidenori> >merijn aww what do u mean by wrong things?
04:47:45 <yitz> hidenori: lambdabot is a bot, not a person. but you can give it a treat:
04:47:47 <merijn> hidenori: http://www.reddit.com/r/dailyprogrammer and http://www.reddit.com/r/programingchallenges/
04:47:48 <yitz> @botsnack
04:47:48 <lambdabot> :)
04:48:02 <plhk> hidenori: i just tried solving practical problems i care about
04:48:10 <merijn> hidenori: I mean the project euler focuses on number theory and minimising the code you write, rather than on solving practical problems
04:48:32 <merijn> hidenori: Those two links have a ton of exercises/challenges to solve, the first one even has the colour coded by difficulty
04:48:33 <hidenori> merijn:  i see.
04:48:43 <hidenori> thanks!
04:48:44 <yitz> merijn: if you like doing the math, then whatever programming is left is good practice for haskell.
04:49:06 <typoclass> Palmik: oh i see. (that's why i added "if you're lucky".) this is getting more involved now, but you could try a fix like this https://github.com/liyang/vector-th-unbox/commit/4fb782f . i found it via googling the error message "Not in scope: data constructor `InlineSpec'", mentioned in the build log http://hackage.haskell.org/packages/archive/unpack-funcs/0.3.1/logs/failure/ghc-7.6
04:49:25 <merijn> yitz: Yeah, but you learn more number theory than haskell :p
04:49:46 <mauke_tmp> not if you brute force everything
04:49:55 <typoclass> Palmik: otherwise, think about the route of installing multiple ghc's. i bet people have written about it on their blogs
04:49:58 <shachaf> Then you learn almost no number theory and almost no Haskell.
04:49:59 <Ghoul_> So many conflicts with parsec
04:50:05 <shachaf> Which means you win, I guess?
04:50:21 <merijn> Let's keep a where of 3-5 links with useful exercises for people to practice...
04:50:31 <mauke_tmp> @where exercises
04:50:31 <lambdabot> I know nothing about exercises.
04:50:36 <Palmik> typoclass: I already have the other GHC. I guess InlineSpec used to be part of template-haskell... maybe.
04:50:40 <Ghoul_> @where <*>
04:50:40 <lambdabot> I know nothing about <*>.
04:50:46 <Ghoul_> Damn right.
04:50:48 <mauke_tmp> @where+ exercises http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
04:50:48 <lambdabot> Okay.
04:50:59 <merijn> @where+ exercises http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programingchallenges/
04:50:59 <lambdabot> It is stored.
04:51:28 <merijn> Feel free to replace with better ones (especially the latter might be a bit more advanced), the 2nd seems decent
04:52:04 <hidenori> yea when solving project euler, i dont really program but think of the mathematical way to solve it
04:52:55 <mauke_tmp> @where+ exercises http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
04:52:56 <lambdabot> Good to know.
04:53:15 <shachaf> Maybe there should be a wiki page, Exercises.
04:53:20 <shachaf> It can link to the other pages.
04:53:29 <mauke_tmp> @wiki Exercises
04:53:30 <lambdabot> http://www.haskell.org/haskellwiki/Exercises
04:53:31 <Palmik> typoclass: Yup... TH 2.8 was not backward compatible.
04:59:27 <vlatkoB> Is it possible to define mempty as mempty of type parameter? Something like:
04:59:27 <vlatkoB> instance Monoid a => Monoid (Tok a) where mempty = TSin (mempty :: a)
04:59:55 <jmcarthur> yes
05:00:05 <jmcarthur> it looks pretty much like that
05:00:44 <vlatkoB> I'm getting "Could not deduce (Monoid a1) arising from a use of `mempty'"
05:00:53 <mauke_tmp> remove the type annotation
05:01:02 <shachaf> vlatkoB: Those aren't the same "a".
05:01:12 <mauke_tmp> where mempty = TSin mempty
05:01:18 <shachaf> In particular that's being treated as (mempty :: forall a. a)
05:03:20 <vlatkoB> But when I check :t mempty Tok :: Int, I'm getting error in GHCI, "No instance for (Monoid Int)", and Int is Monoid, isnt it?
05:04:00 <vlatkoB> Same for :t Tok maybe
05:04:21 <quicksilver> (a) Int isn't Monoid
05:04:34 <quicksilver> (b) I don't think mempty Tok or Tok maybe mean what you thinkg they mean
05:04:56 <quicksilver> Tok is a type not a value isn't it?
05:05:38 <vlatkoB> Sorry, I forgot to write ::
05:06:03 <mauke_tmp> show your actual code and error messages
05:06:22 <arkeet> @hpaste
05:06:22 <lambdabot> Haskell pastebin: http://hpaste.org/
05:06:29 <shachaf> hi arkeet
05:06:32 <shachaf> good morning
05:06:38 <arkeet> hi
05:07:11 <quicksilver> vlatkoB: if you meant "mempty :: Tok Int" then, yes, the problem is that Int is not a monoid.
05:07:33 <quicksilver> try "mempty :: Tok [Int]" since lists are a monoid.
05:10:23 <vlatkoB> @quicksilver: Yes, that works. I was trying to check if mempty is correct. How to find out which types are Monoids?
05:10:24 <lambdabot> Unknown command, try @list
05:14:07 <yitz> vlatkoB: our bot interprets @ as meaning a command addressed to it
05:14:52 <vlatkoB> I realized that. Thanks.
05:15:08 * typoclass . o O ( we should really turn off that message, "Unknown command try @list". it seems quite pointless )
05:15:53 <neutrino> what if you mistype and suddenly there's no answer
05:16:07 <neutrino> and you think the bot is broken rather than you mistyped
05:16:42 <typoclass> neutrino: it's fuzzy anyway. @vixen used to be a command, today it works only coincidentally because it autocorrects to @nixon, etc.
05:16:50 <qwr> well, probably you'll learn to recheck what you typed, when there's no answer
05:17:35 <yitz> qwr: an ironic twist. we program users to learn by conditioning, instead of the bot
05:18:05 <typoclass> @list
05:18:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:18:39 <yitz> yeah. if there is a message, suggesting something useless isn't the right message
05:18:44 <typoclass> at minimum, the message should say "Unknown command; see http://code.haskell.org/lambdabot/COMMANDS". it's pointless to tell people another command when you can tell them the url directly
05:19:10 * hackagebot resourcet 0.4.7.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.7.1 (MichaelSnoyman)
05:19:21 <yitz> i don't that url really points to an up-to-date list of lambdabot's commands
05:20:12 <shachaf> Nope.
05:20:21 <shachaf> For an up-to-date list: /msg lambdabot ?
05:20:43 <typoclass> yitz: i don't know about that. but good point. realistically, the best "list of commands and their meanings" will probably be asking in here
05:21:14 <typoclass> in other words, do "@> 1+2", nothing happens, people tell you "have you tried > 1+2"
05:22:03 <mauke_tmp> > 1 (+) 2
05:22:04 <lambdabot>   1
05:23:02 <elliott> the unknown command message has the positive side-effect of discouraging Twitter-style addressing
05:23:33 * arbn has never seen anyone do that on Freenode, anyway.
05:23:56 <arbn> I mean, hopefully they don't... :/
05:24:21 <typoclass> elliott: i don't think that's positive. avoiding "@jeff" is a random convention that realistically has no upshot
05:24:28 <elliott> arbn: they do it plenty. typoclass's remark was sparked by someone doing it just a few lines up
05:24:39 <arbn> elliott: ... Oh. :P
05:25:09 <elliott> typoclass: even to start with, there's the fun you can imagine if someone happens to share the name of a lambdabot command.
05:25:17 <elliott> not as unlikely as you might think given its autocorrection
05:26:00 <typoclass> elliott: @ is common in email addresses as well, and in email body texts, blog comments, and the like. "@Jeff -- could you please ...". i think all of this predates twitter
05:26:26 <shachaf> It does predate Twitter.
05:26:30 <shachaf> It was awful before Twitter, too.
05:27:07 <quchen> At shahaf: You're always so negative.
05:27:15 <quchen> +c
05:28:10 <typoclass> elliott: that's a disadvantage. but i think it'd be limited to lambdabot occasionally outputting a line that was unnecessary. it's not like one person's messages will be swallowed or something
05:28:15 <Lumpy> http://stackoverflow.com/questions/16165602/haskell-filtering-and-sorting-information-returned-correctly
05:28:41 <arbn> > concat <$> return ["Hello ", "World"]
05:28:43 <lambdabot>   No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
05:28:43 <lambdabot>    arising from a use...
05:30:17 <elliott> typoclass: and yet, it all works so much better if we stick to the convention that IRC clients produce and (sometimes) expect (some IRC clients only highlight nickpings in a certain form -- not ideal, yes, but fact), and that everyone is used to reading on IRC...
05:31:55 <parcs> :t join . fmap join
05:31:57 <lambdabot> (Monad m, Functor m) => m (m (m a)) -> m a
05:32:03 <parcs> :t join . join
05:32:04 <lambdabot> Monad m => m (m (m a)) -> m a
05:32:47 <Kinnison> Anyone here know if it's (still?) possible to bootstrap ghc without ghc?
05:33:16 <quchen> Kinnison: Well, you would have to start at some very low GHC version and work your way up
05:33:22 <elliott> if you find a lazy ML implementation and have a lot of time, maybe.
05:33:32 <quchen> I'm not sure what the current GHC needs to be bootstrapped, but it's >= 6.10
05:33:33 <elliott> I doubt all the code you'd need to do so is still around.
05:33:36 <typoclass> anyway, if the bot will keep annoying people for "@jeff", i want a new feature to annoy people who give useless answers like "is it possible to ...? -- yes it is" :-)
05:33:50 <shachaf> typoclass: That's not a useless answer.
05:33:54 <Kinnison> quchen: bleh, there was indication that it was possible to get something going with just a C compiler :-(
05:34:32 <typoclass> shachaf: i disagree, it usually is like saying "could you pass the salt? -- yes i could", then doing nothing
05:34:43 <byorgey> @faq can the bot annoy people who give non-constructive answers to existence queries?
05:34:43 <lambdabot> The answer is: Yes! Haskell can do that.
05:35:13 <no-n[0]> lol
05:35:56 <arkeet> typoclass: not really, usually it's pretty obvious whether one could pass the salt
05:36:44 <quchen> I'm not sure pretending to be a parser/interpreter is a good basis for human interaction.
05:38:36 <arbn> quchen: All my best friends pretend to programming language interpreters...
05:38:46 <arbn> pretend to be*
05:39:23 <magicman> "Do you want to go left or right?" "Yes"
05:39:49 <quchen> arbn: Human answer to that: "Oh, that's odd." Computer answer to that: <terminated>
05:40:32 <parcs> Kinnison: perhaps this may help http://hackage.haskell.org/trac/ghc/wiki/CrossCompilation
05:40:45 <Kinnison> parcs: still implies a need for ghc on the host side
05:41:27 <Kinnison> I'd be satisfied if there were a way on a system with ghc, happy, alex, etc, to create something which then could be compiled with only a C compiler on the target system
05:41:50 <Kinnison> I could use that to build a basic ghc which then could be used to properly bootstrap ghc on the target
05:41:54 <Kinnison> that'd be fine
05:42:00 <elliott> you can do an unregistered build
05:42:03 <isson0926> Since  >>= return = return (only ) = OneTuple  /= 
05:42:04 <elliott> if they're not broken this week
05:42:07 <mauke_tmp> @google unregisterised ghc
05:42:08 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Building/Unregisterised
05:42:08 <lambdabot> Title: Building/Unregisterised – GHC
05:42:11 <isson0926> what is it "" ?
05:42:31 <elliott> isson0926: that looks like an upside down exclamation mark and an N with a ~ on top of it. does your IRC client have encoding problems, or the page you're reading?
05:42:37 <elliott> perhaps link to it?
05:43:02 <isson0926> http://lukepalmer.wordpress.com/2008/10/03/laziness-and-the-monad-laws/
05:43:11 <Ghoul_> I'm having so much fun with this applicator stuff
05:43:19 <Kinnison> elliott: Is that a bootstrapping mechanism, or a way to deal with platforms which there is no native support for?
05:43:22 <Ghoul_> but is there a way to get rid of the surrounding braces? http://hpaste.org/86367
05:43:24 <Lumpy> Does anybody fancy helping me write and complete two functions that i'm struggling with? tdammers has helped me. And his help has been edited and added to the bottom of the Stack OverFlow post.       http://stackoverflow.com/questions/16165602/haskell-filtering-and-sorting-information-returned-correctly
05:43:40 <shachaf> > map ord "¡Ñ"
05:43:41 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
05:43:41 <mauke_tmp> http://dl.dropboxusercontent.com/u/41152078/unicode.html?q=%C2%A1%C3%91
05:43:43 <shachaf> :-(
05:44:15 <mauke_tmp> isson0926: that says ⊥ here
05:44:21 <elliott> Kinnison: it's for porting GHC
05:44:24 <shachaf> > [161,209] ^.. traverse.re (base 2)
05:44:26 <lambdabot>   ["10100001","11010001"]
05:44:30 <elliott> you can do what you want with it
05:44:54 <mauke_tmp> > "\xe2\x8a\xa5"
05:44:56 <lambdabot>   "\226\138\165"
05:44:59 <mauke_tmp> > var "\xe2\x8a\xa5"
05:45:01 <Kinnison> elliott: So I can use that, to produce a pile of code which I can copy over to my target platform which when built, produces a ghc?
05:45:01 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
05:45:53 <isson0926> mauke_tmp, could you explain in english? because encoding error ( i am not good to speak english)
05:46:30 <bourbaki> Greetings
05:46:35 <elliott> Kinnison: well, I think it's fairly involved. you could try it out.
05:46:36 <isson0926> i don't understand  "\226\138\165" means.
05:46:47 <bourbaki> Is there any free shell you happen to know that i can run ghci on?
05:47:00 <bourbaki> -i
05:47:03 <mauke_tmp> isson0926: your browser seems to be broken
05:47:07 <Lumpy> http://hpaste.org/86365  - Bringing back 'fans' as not being in scope.
05:47:16 <mauke_tmp> the page is in UTF-8
05:47:47 <isson0926> ok . i will try now.
05:48:07 <Kinnison> elliott: I shall have to see what happens, thanks for the hint
05:48:19 <qochen> Lumpy: Well, you're writing "fans" in line 2, but there's no such function.
05:48:44 <qochen> Lumpy: What would the type signature of the "fans" function look like? What does it take, what does it produce?
05:52:55 <qochen> Did HPaste just do something weird?
05:53:00 <qochen> It requires authentication here
05:53:33 <mauke_tmp> works here
05:54:19 <qochen> Hm, nevermind then
05:57:03 <aleator> Hi. I'd like to leverage an existing package for vector space operations in the CV machine vision library. Should I go with vector-space or Linear? Or something else entirely?
05:57:06 <hpaste> inauthentic pasted “unauthenticated” at http://hpaste.org/86369
05:57:20 <isson0926> i have a question. pure type(not IO type) always satisfy monad law ? or i alway prove the monad law for my own type for monad ?
05:58:26 <coburrito> isson0926: You prove it for your Monad instance. You can define Monad instances that don't satisfy the laws.
05:58:36 <applicative_tmp> isson0926: if you introduce data Isson0962 a = ..., then if you declare a monad instance, you should first convince yourself that the monad laws work for it
05:58:50 <Asterfield> More noob questions! :P If a float can handle roughtly 6 decimal places, and a double can handle roughtly 15, what would I use if I wanted to handle, say, the first 400 trillion digits of pi
05:59:20 <isson0926> thanks alot. applicative_tmp , coburrito :-)
05:59:23 <mauke_tmp> Asterfield: a string
05:59:28 <applicative_tmp> uh [Char] wouldn't be so bad Asterfield
05:59:37 <applicative_tmp> mauke_tmp: you're too fast
05:59:45 <XexonixXexillion> 400 trillion?
05:59:47 <mauke_tmp> meep meep
05:59:57 <applicative_tmp> and a really big computer?
06:00:00 <XexonixXexillion> [Char] wouldn't do that very well
06:00:02 <Asterfield> XexonixXexillion: Arbitarily chosen number.
06:00:09 <Asterfield> *spelling
06:00:14 <mauke_tmp> XexonixXexillion: only if you look at it
06:00:28 <applicative_tmp> what are you going to do with those digits when you get them?
06:00:45 <qochen> applicative_tmp: Extract the head
06:00:53 <applicative_tmp> > last [1..1000000000000]
06:00:57 <lambdabot>   mueval-core: Time limit exceeded
06:01:05 <coburrito> isson0926: http://www.haskell.org/haskellwiki/Typeclassopedia#Laws <-- They have an example of an instance that doesn't satisfy the functor laws here. I found that interesting when I first saw it.
06:01:21 <Asterfield> applicative_tmp: Oh I have no idea. :P I was reading through Learn you a haskell, and the thought struck me about what happens when more precision than a Double is needd
06:01:29 <Asterfield> s/needd/needed
06:01:47 <qochen> Asterfield: You're doing what you're doing in any other language: look for a library for big numbers. :-)
06:01:48 <ndonaldson> Asterfield: https://www.wolframalpha.com/input/?i=400+trillion+bytes
06:02:00 <applicative_tmp> Asterfield: oh, there is the built in Rationals as well, and things like 'CReal' which is kind of cool
06:02:15 <elliott> mauke_tmp, applicative_tmp...
06:02:21 <elliott> /nick elliott_etc
06:02:24 <applicative_tmp> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
06:02:36 <chrisdone> any osxmonad users?
06:03:00 <Asterfield> So, no built in functionality for super preciseness then :P That's what I was really curious about, more or less
06:03:12 <mauke_tmp> there is, but for rational numbers, not for floats
06:03:35 <Asterfield> thank you very much for your helpfullness applicative_tmp qochen mauke_tmp ndonaldson :)
06:03:38 <applicative_tmp> Asterfield: no, the 'Rational' type is Super Precise, but don't use it...
06:03:55 <Asterfield> mauke_tmp: Oh haha I know about that one. :P I was having run runing factorial 10011 yesterday
06:04:11 <applicative_tmp> Asterfield: needless to say, the classical continuum is a little hard to implement in such a primitive programming language as this
06:04:26 <Asterfield> applicative_tmp: Quite understandable
06:04:40 <mauke_tmp> @src Real
06:04:40 <lambdabot> class  (Num a, Ord a) => Real a  where
06:04:40 <lambdabot>     toRational      ::  a -> Rational
06:04:41 <tdammers> the programming language is not the problem. the hardware is
06:04:51 * mauke_tmp keeps it real
06:05:19 * tdammers stays rational
06:05:20 * applicative_tmp blames the ghc for everything 
06:05:35 <chrisdone> ejsy
06:05:36 <chrisdone> er
06:06:01 <chrisdone> heh, do you ever move slightly and put your hands back on the keyboard at one set of keys to the left? anyway
06:06:04 <chrisdone> what's with all the tmps?
06:06:38 <hpaste> “Anonymous Coward” pasted “LG-CODEJAM: P1” at http://hpaste.org/86370
06:07:03 <thorsten`> how can i tell deriving (Show) to indent the data structure when printing?
06:07:23 <Botje> you can't, you'll have to write your own instanc.
06:07:25 <mauke_tmp> thorsten`: no
06:07:27 <Rarrikins> thorsten`: You'd need to create your own show.
06:08:22 <tdammers> instance Show FreddyMercury where show _ = repeat "the show "
06:09:08 <hpaste> jh revised “LG-CODEJAM: P1”: “LG-CODEJAM: P1” at http://hpaste.org/86370
06:10:23 <coburrito> If I have an IOSArrow Text Text, how would I run it?
06:12:32 <fizbin> coburrito: runIOSLA arrow () inputText
06:13:02 <fizbin> Or, wait. Maybe not quite that.
06:13:17 <applicative_tmp> newtype IOSLA s a b Source  list arrow combined with a state and the IO monad  Constructors IOSLA	  runIOSLA :: s -> a -> IO (s, [b])
06:13:23 <applicative_tmp> oh fizbin is on it
06:13:55 <applicative_tmp> type synonyms ... these are the types that try mens' souls
06:17:02 <hpaste> jh revised “LG-CODEJAM: P1”: “LG-CODEJAM: P1” at http://hpaste.org/86370
06:17:03 <applicative_tmp> hm HXT has an definition for theShowHaskell :: Selector XIOSysState Bool
06:17:25 <coburrito> fizbin: Thanks! That was close enough. Then I can just discard the state I get back from the resulting tuple.
06:17:41 <fizbin> What about runIOSLA arrow (initialState ()) inputText
06:18:30 <fizbin> :t let u = undefined::IOSArrow Text Text in runIOSLA u (initialState ()) undefined
06:18:31 <lambdabot>     Not in scope: type constructor or class `IOSArrow'
06:18:32 <lambdabot> Not in scope: type constructor or class `Text'
06:18:32 <lambdabot> Not in scope: type constructor or class `Text'
06:18:49 <applicative_tmp> is it HXT or XML that gives one so powerful an impression of madness, looking at this documentation?
06:19:19 <coburrito> applicative_tmp: HXT is big and a bit overengineered, but it's pretty nice to use, most of the time.
06:19:48 <fizbin> Well, speaking just for myself I'd have to say HXT. I built stuff on top of Text.XML.Light without going nearly as mad.
06:20:08 <fizbin> :t runIOSLA
06:20:09 <lambdabot> Not in scope: `runIOSLA'
06:20:37 <fizbin> :t Text.XML.HXT.runIOSLA
06:20:38 <lambdabot> Couldn't find qualified module.
06:21:07 * fizbin needs a custom lambdabot instance so that he can decide what modules get loaded.
06:21:51 <fizbin> Then, I guess I connect it to a company-internal IRC server and then have it also load and reload my stuff.
06:22:06 <hpaste> jh revised “LG-CODEJAM: P1”: “LG-CODEJAM: P1” at http://hpaste.org/86370
06:22:25 <FireFly> fizbin: isn't it easier to have a local ghci instance? :P
06:22:49 <coburrito> fizbin: "runIOSLA pageCleaner (initialState ())" gave me the function I needed. Thanks.
06:23:31 <fizbin> FireFly: Well, generally, yes. I'm thinking though that it might help when collaborating with other people on my team here.
06:23:46 <FireFly> Ah, good point
06:36:26 <coburrito> fizbin: FP Complete's future internal stuff may also be an option, depending on your company's budget.
06:36:48 <coburrito> I find IRC kind of a pain to use for team stuff, but that's just me.
06:38:34 <fizbin> Well, it's weird - we've got two larger teams that my team sits in between. One team uses IRC heavily, the other team doesn't use IRC at all.
06:46:37 <Zenol> Hi guys. I'm trying to test Control.Parallel and i'm experiencing some issues. As I increas the number of core with -Nn, it gets slower and slower. I use the paralelised sort (sort2) from RealWorldHaskell with the test example. Might it be caused by something related to the packages / ghc version i'm using? (ghc 7.6.2). I can give you output of +RTS -stderr if you want. Here is the hs file i'm using : http://hpaste.org/86377
06:49:41 <Zenol> any idea ? :/
06:50:52 <FUZxxl> Zenol: Absolutely no plan.
06:51:46 <FUZxxl> It might be possible that you loose speed because your data can not be stored in your processor's cache because it has to be shared among multiple processors.
06:53:33 <solirc> Zenol: I'd ask on the ghc users mailinglist.
06:53:51 <solirc> I'm pretty sure that you will get a useful reply there.
06:56:45 <hseg> quchen: Re: your idea yesterday to apply runState in the inverse order it usually is applied for <*> in State's Applicative instance, while it could work for the Applicative instance, I don't see a way that the Monad instance for a State with those semantics would arise from the definition of State.
06:57:25 <mauke_tmp> oh, is it reverse state time again?
06:57:55 <quchen> hseg: Yes, that's what another user said: reverse State would be an Applicative, but not a Monad
06:59:02 <hseg> Nice. Would it not be a Monad due to State's definition, or due to the fact that this is impossible as a Monad?
07:00:31 <DMcGill_> hseg: it doesn't satisfy the monad laws
07:01:23 <hseg> Ah. Pity. It might have been useful for something. No ideas off the top of my head of what those things might be, though.
07:01:24 <quchen> hseg: I suspect there's a problem with the Monad laws, but I haven't checked it.
07:02:04 <hseg> I suppose it's the law of the associativity of (>=>), right?
07:03:09 <t7> is it one of you guys who run monoidal.net ?
07:03:13 <Cale> What?
07:03:23 <Cale> Reverse state ought to be a monad.
07:03:27 <Zenol> FUxxl > Hum, I was expecting that a simple exemple as this one would, at lest, not decrease the speed. Maybe I should check what happen with a "regular" multithreaded C/C++ program just to check that it isn't my system wich is faulty.
07:03:43 <Cale> At least if you're referring to the same thing I am
07:04:02 <Zenol> solirc > Thanks, if I really can't find anything I'll probably do that.
07:04:06 <quchen> Cale: Reverse State Applicative runs "mx" before "mf" in "mf <*> mx"
07:04:13 <Cale> oh
07:04:21 <quchen> That's our speculation starting point.
07:04:22 <Cale> That's not the same thing I'm talking about
07:04:35 <quchen> What did you mean?
07:04:42 <hseg> Cale: What did you mean?
07:05:11 <Cale> I'm talking about the state monad where your state flows backwards in time, and a get will retreive the value sent by the following put.
07:05:47 <hseg> So the initial state is given to the rightmost computation, and then it flows leftward?
07:06:09 <quchen> Sounds very "co" to me.
07:06:24 <mauke_tmp> what's the difference between that and the applicative instance?
07:06:30 <Cale> yeah, you just swap things around in the definition of >>=
07:06:47 <Cale> If we have:
07:06:56 <Cale> data State s a = S (s -> (s,a))
07:07:04 <Cale> runState (S f) s = f s
07:07:18 <Cale> then the ordinary state monad has something like:
07:07:49 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
07:08:02 <arkeet> a Kleisli arrow for State s looks like (a,s) -> (b,s). how do you let the state flow backwards given that?
07:08:03 <Cale> but we could also do this:
07:08:13 <Cale> x >>= f = S (\s -> let (s'',v) = runState x s; (s',w) = runState (f v) s in (s'',w))
07:08:25 <Cale> and just wire the states up in reverse
07:08:48 <Cale> It is very easy to write infinite loops with this monad
07:08:52 <Cale> But it works
07:08:58 <arkeet> I have a hard time believing that's lawful.
07:09:02 <arkeet> what's x >>= return?
07:09:17 <arkeet> or
07:09:22 <Chousuke> there's also that Tardis thing which is just State + RState :p
07:09:26 <arkeet> something.
07:09:36 <Chousuke> and I still prefer not to think about it too much
07:10:00 <quchen> Cale: Your reverse definition ignores s' entirely, is that intended?
07:10:18 <quchen> It uses the input state (s) twice
07:10:41 <Cale> oh, oops
07:10:42 <hseg> Cale: I assume you meant x >>= f = S (\s -> let (s'',v) = runState x s'; (s',w) = runState (f v) s in (s'',w))
07:10:47 <Cale> yes, that's unintentional
07:10:53 <Cale> x >>= f = S (\s -> let (s'',v) = runState x s'; (s',w) = runState (f v) s in (s'',w))
07:11:48 <Chousuke> quchen: regarding the "co", there's a costate comonad
07:12:02 <quchen> Chousuke: You mean Store?
07:12:04 <edwardk> Chousuke: costate is actually a rather drastically bad misnomer.
07:12:16 <edwardk> Chousuke: it isn't dual to state. it is derived by composing an adjunction the other way around
07:12:31 <quchen> edwardk: Maybe remove that term from the docs entirely
07:12:39 <quchen> (Or has that been done already)
07:12:41 <immanuelkant> Cale++
07:12:48 <edwardk> quchen: i probably should just include that rant ;)
07:12:57 <edwardk> quchen: if i don't already
07:13:10 <quchen> edwardk: "Also known as the Costate Comonad by AWFUL PEOPLE"
07:13:24 <arkeet> oh, it's some awful recursive thing?
07:13:37 <arkeet> er
07:13:40 <edwardk> "by the ignorant masses"
07:13:41 <Cale> arkeet: yes, it's recursive
07:13:42 <Philippa_> no more so than >>= is
07:13:55 <Cale> It is more recursive than the original one here
07:14:17 <Cale> (you can't write something equivalent without a fixed point)
07:14:50 <mauke_tmp> damian conway had a talk about "positronic variables" in perl
07:14:54 <mauke_tmp> it's basically reverse ST
07:16:39 <kstt> hi :)  I want to extract data from a binary file, dumped by a C program. Which package should I use in your opinion ? Binary, cereal or Attoparsec ? Thx
07:19:37 <Cale> kstt: Assuming you have no control over the format of the data, probably attoparsec.
07:19:57 <Cale> kstt: cereal/binary work best when they get to decide on the layout of the binary data
07:21:43 <kstt> hi cale, thx. I have no control over the data, no. It really just is a buch of structs dumped to a file. Poor practice, but that's not in my hands, you know ...
07:22:24 <geekosaur> "a bunch of structs" is actually the sort of thing you'd use them for
07:22:49 <kstt> them ?
07:23:01 <Cale> Well, provided you have all the right instances, cereal will be fine :)
07:23:23 <mauke_tmp> heh
07:23:27 <mauke_tmp> Storable!
07:23:36 <Cale> Yeah, Storable is another good option
07:24:23 * hackagebot ois-input-manager 0.1.0.1 - wrapper for OIS input manager for use with hogre  http://hackage.haskell.org/package/ois-input-manager-0.1.0.1 (GregHorn)
07:24:30 <kstt> Blocks are of varying length, usually specified in the few first bytes. Does that matter ?
07:24:45 <Cale> Probably not
07:25:03 <arkeet> sounds like something to use binary/cereal for.
07:26:22 <quchen> How do you "dump a bunch of structs" in C anyway? You can't just print them after all, can you?
07:26:39 <t7> hex dump
07:26:46 <mauke_tmp> quchen: fwrite
07:26:48 <kstt> Wow, I just read the full documentation of Foreign.Storable in 2 minutes and 7 seconds ...
07:27:00 <tomboy65> hello folks
07:27:03 <kstt> Hope there is more content elsewhere ;)
07:27:03 <Zenol> Same issue with C code. Sorry for disturbing you, ghc might not be faulty :)
07:27:35 <quchen> mauke_tmp: Oh, so when the struct is allocated in one piece, you can actually cast a pointer to it to void* and brute-write it to a FILE?
07:27:54 <mauke_tmp> quchen: all structs are one piece
07:28:00 <quchen> Oh.
07:28:02 <mauke_tmp> and you don't need a cast
07:28:44 <kstt> quchen: I don't know how it is done. I don't own the dumping code, it is from a device owned by company X and run by compagny Y. I just have a .doc data sheet with C structs, supposed to describe the format.
07:28:55 <mauke_tmp> and yes, you can write it to a file or send it over the network. and then any reader has to deal with platform incompatibilities :-(
07:29:10 <mauke_tmp> (sizes of types, padding, endianness, ...)
07:29:14 <geekosaur> as long as there aren't pointers involved, write(fd, (void *) &struct, sizeof struct);
07:29:26 <mauke_tmp> (void *)? you're fired
07:29:29 <geekosaur> but yes, that ignores fun stuff like arch issues
07:29:40 <geekosaur> (and error checking)
07:29:53 <kstt> Indeed, there are hints about indianess in the doc ...
07:29:56 <mauke_tmp> that cast either removes 'const' or it's useless
07:30:01 <mauke_tmp> :-[
07:30:13 * geekosaur would be more likely to write actual marshaling code, but the raw thing works...
07:30:15 <kstt> So, you beleive Cereal or Binary will fit ?
07:30:32 <kstt> (I mean, better than attoparsec ?)
07:31:25 <quchen> The Binary approach would then be writing the instances yourself to match whatever the other compiles makes out of a struct?
07:31:35 <geekosaur> attoparsec would be for where you have to look for a pattern somewhere in the middle of the binary goop to know where to start parsing
07:32:15 <geekosaur> binary/cereal is for when you know the structure, and is more reliable in general (how do you know your pattern doesn't occur in other places, for one?)
07:32:48 <kstt> ok. Does binary provide an "alternate" interface, like : try this <|> try that ?
07:33:26 <mauke_tmp> .oO( attoparse.cx )
07:36:46 <arkeet> kstt: binary isn't a parser.
07:37:37 <arkeet> or is it.
07:38:15 <quicksilver> yes, it is
07:38:20 <arkeet> ok.
07:38:25 <arkeet> it does have an Alternative instance.
07:38:28 <arkeet> I wonder why not MonadPlus.
07:38:37 <quicksilver> but it's not very sophisticated in parsing combinator terms
07:38:41 <arkeet> indeed.
07:38:50 <arkeet> well I suppose "parser" is a pretty general term.
07:38:51 <quicksilver> I'm not sure how the alternative instance can work
07:38:59 <quicksilver> Binary doesn't have a way to signal failure
07:39:00 <quicksilver> does it?
07:39:02 <arkeet> well, it does have a lookAhead thing.
07:39:44 <arkeet> but that doesn't seem to be what you'd want.
07:39:46 <quicksilver> Binary used to be simply ByteString -> a
07:40:03 <quicksilver> no data type to model failure or allow 'retry'
07:40:09 <quicksilver> by design, that is.
07:40:40 <arkeet> well it looks like it can backtrack with <|> or something.
07:41:55 <quicksilver> what type are you finding an alternative instance for arkeet ? Get?
07:41:56 <kstt> indeed
07:41:58 <arkeet> yes
07:42:06 <quicksilver> not here - http://hackage.haskell.org/packages/archive/binary/0.5.1.0/doc/html/Data-Binary.html#t:Get
07:42:11 <arkeet> try a newer version
07:42:25 <kstt> here http://hackage.haskell.org/packages/archive/binary/0.7.0.1/doc/html/src/Data-Binary-Get-Internal.html#Get
07:42:36 <quicksilver> oh
07:42:49 <quicksilver> looks like they changed it quite a bit at some point :)
07:43:21 <kstt> Last choice before I dig my hole : Binary or Cereal ?
07:43:43 <kstt> The data is not huge, I can afford to load everything in memory.
07:43:49 <arkeet> I don't think they're very different.
07:44:00 <arkeet> toss a coin. :p
07:44:24 * hackagebot network-ip 0.1 - Internet Protocol data structures  http://hackage.haskell.org/package/network-ip-0.1 (MikhailVorozhtsov)
07:44:25 <kstt> arkeet: this is precisely my very secret strategy in such case :)
07:45:26 <quicksilver> only 2 months ago
07:45:33 <quicksilver> (according to a github commit message)
07:46:18 <kstt> Where does "cereal" come from ? Is that a pun ? Like "cereal killer" ?
07:46:33 <merijn> kstt: It sounds like serial?
07:46:44 <merijn> Seems like the obvious origin
07:47:40 <quicksilver> no changelog, no announcement to haskell-cafe or haskell
07:47:41 <quicksilver> kolmodin-- # not good at PR :)
07:58:25 <cec24> Hi all, I have a big [[int]] (its a square matrix of ~ 6000 elements). I want to dump it out to a file, I've been doing this by mapping hPutStr (show item ++ " " ) over each sublist then printing a newline and so on, i fear this is massively inefficient
07:58:49 <allenj12> hey could someone give me an example of a tree that would give me the index of the main connective in  a string that holds a logical statement? such as ((A o (B a C) o (B c C )) where the middle o is the main connective
07:59:04 <cec24> i'd like to dump it in ascii if possible as i need to go back and forth with Mathematica and I don't know much about MM's binary read/write capacity
07:59:25 <merijn> cec24: Well, lists are terribly inefficient for matrices anyway, maybe you want to use Array or some of the vector stuff?
07:59:41 <byorgey> it contains 6000 elements, or it's 6000x6000?
07:59:48 <cec24> yes its 6k by 6k ish
07:59:51 <cec24> or bigger
07:59:58 <byorgey> cec24: and how long does it take to write out currently?
07:59:59 <merijn> Definitely don't use lists then
08:00:11 <cec24> merijn: i had this idea that arrays were immutable
08:00:14 <merijn> (assuming you do anything other than printing >.>)
08:00:18 <merijn> cec24: So are lists :p
08:00:30 <byorgey> cec24: Haskell has mutable arrays.
08:00:34 <cec24> merijn: huh, yes ok, i was computing each element and then consing them onto the list
08:00:42 <merijn> ah
08:00:49 <cec24> perhaps the right thing to do is make each element, and output it
08:00:51 <mauke_tmp> cec24: my gut instinct is to generate the string first and then putStr it
08:00:53 <cec24> without actually storing them at all
08:00:59 <merijn> cec24: tbh, without knowing what you're doing it's hard to say what's best
08:01:18 <mauke_tmp> :t unlines . map unwords
08:01:20 <lambdabot> [[String]] -> String
08:01:21 <cec24> mauke_tmp: i was wondering if making a bytestring.char8 of each line and then outputing that would be best
08:01:31 <mauke_tmp> :t unlines . map (unwords . map show)
08:01:32 <lambdabot> Show a => [[a]] -> String
08:02:12 <cec24> ok so perhaps the real issue is: should i think about doing many calculations first and then doing output
08:02:19 <cec24> or should i try and interleave the two, by say computing each element first?
08:02:50 <cec24> in an imperative lang (C is my training ground) i don't think it would make much difference for this size of matrix
08:03:12 <cec24> i realize this is a very general question without much info, i suppose i should put a minimal example somewhere and then ask y'all
08:03:22 <merijn> cec24: hpaste.org is a good place
08:03:37 <cec24> merijn: ok thanks i will look at that
08:04:10 <mauke_tmp> cec24: in Haskell the two may be the same
08:04:19 <mauke_tmp> because laziness
08:04:20 <allenj12> or can someone show me a good resource on trees?
08:04:57 <breed101> hello
08:04:58 <cec24> ok thanks folks, i'll put some more effort into writing up my questions
08:06:21 <Kinnison> Anyone here ever tried building ghc with -keep-hc-files ?
08:06:24 <breed101> i have a simple yesod devel server up, and I am trying to benchmark it.  Right now the page is a simple hello there.  It doesn't look like yesod is using all of the cores.  Can someone point me to a tuning post on how to get best results?  Right now its at 1k req/ s, which is pretty slow.
08:10:01 <allenj12>  hey could someone give me an example of a tree that would give me the index of the main connective in  a string that holds a logical statement? such as ((A o (B a C) o (B c C )) where the middle o is the main connective
08:12:36 <aCube> breed101, Why are you benchmarking the DEVEL server?
08:13:02 <breed101> aCube, cause im a noob
08:14:24 * hackagebot fsnotify 0.0.9 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.0.9 (GregWeber)
08:14:30 <kstt> cec24, have you looked for CSV libraries on hackage ?
08:15:19 <kstt> http://hackage.haskell.org/package/cassava
08:17:00 <breed101> aCube, it's not to clear in yesod how to run without the devel server
08:18:51 <aCube> breed101, I think it should work if you do cabal configure && cabal build. Then there is an executable in dist/build/ that you just run
08:19:24 * hackagebot elm-yesod 0.2 - The Elm language Yesod compatibility module.  http://hackage.haskell.org/package/elm-yesod-0.2 (VincentAmbo)
08:19:35 <breed101> aCube, thank u
08:23:56 <monoidal> allenj12: do you want to parse a string and get an expression tree?
08:25:46 <allenj12> monoidal: all i want is to get the index of the main connective char... if thats what i need then yes. sorry if thats not to clear these were suggestions i got before
08:27:59 <DMcGill_> 3-tupes are commonly called triples right?
08:28:08 <DMcGill_> s/tupes/tuples
08:29:31 <quicksilver> sometimes, perhaps
08:29:44 <quicksilver> I tend to call them 3-tuples in haskell.I might call them triples in maths.
08:30:05 <elliott> I tend to not use them in Haskell!
08:33:43 <quicksilver> elliott: they're handy for literal data sometimes.
08:34:40 <quicksilver> cmds = [('B',bakeCake,'Bake the currently selected cake'),('D',decorate,....)]
08:37:31 <DMcGill_> a little easier than defining a new data type every time
08:37:41 <DMcGill_> although I suppose it'd be better named and documented if I did
08:40:22 <allenj12> hmmm i guess i could use a tree no matter what.... so how would i build a tree from one string such as ((A o B) c B) a (B a A) to a tree where each branch off the main connective repeatidly
08:40:48 <allenj12> within the parenthesis
08:41:25 <donri> DMcGill_: 'pair' is often used to refer to (a,a) so 'triple' might be interpreted as (a,a,a)
08:43:51 <quicksilver> allenj12: by parsing.
08:44:46 <allenj12> quicksilver,  can u give me an example or resource?
08:46:38 <quicksilver> allenj12: parsec is popular although not the only choice
08:46:58 <quicksilver> http://stackoverflow.com/questions/3077207/choosing-a-haskell-parser
08:47:03 <allenj12> quicksilver,  alright thanks ill look hayoo that :)
08:47:20 <allenj12> quicksilver,  and look at that
09:06:39 <yanhong> test
09:11:05 <klrr> how do i write a simple server and client program? ive written one but it simply doesnt work, i found some guides but none use the Network module, i guess i could try follow it and use Network.Socket instead, but i dont wanna reinvent the wheel!
09:11:09 <klrr> ?
09:11:47 <klrr> doesnt work as in compiles, no runtime errors, client connects to server, but then it doesnt send the messages it's supposed to
09:12:20 <Cale> klrr: Are you sure?
09:12:31 <klrr> Cale: i can post source code, bb
09:12:57 <hpaste> flebron pasted “See any obvious inefficiencies?” at http://hpaste.org/86382
09:12:57 <Cale> klrr: You have to be aware that telnet is not a good way to reliably send messages to a server that you wrote, because it messes with line endings.
09:13:03 <edwardk> @remember tgeeky whatever man. Jesus only had twelve or so deciples, lens has 80!
09:13:04 <lambdabot> I will never forget.
09:13:08 <Cale> (If you didn't pick that up the other day)
09:13:35 <klrr> Cale: it doesnt use telnet i use my own client
09:13:39 <Cale> But if it's your own client which is connecting, that should be much less of an issue
09:14:04 <Cale> You just have to make sure that both the client and server handles are in the same mode, which if you do nothing, should be the case.
09:18:36 <flebron> Am I doing something incredibly inefficient in the paste above?
09:19:16 <flebron> (The algorithm should be O(n^3 log n), which should be fast enough, so it's the constants that are killing me.)
09:21:22 <monoidal> flebron: does it improve when you make z argument to merge strict?
09:21:48 <flebron> As a note, n is at most 100.
09:22:04 <flebron> To make it strict, do I add a ! in front of it in all its pattern matchings?
09:22:07 <klrr> Cale: it works ! :DDDDDDDDDDDDDDDDDDDDDDDDDDD i fixed it it was just my stupid logic here's the code https://gist.github.com/klrr/5445037 :)
09:22:10 <monoidal> flebron: yes
09:22:53 <flebron> Like this? merge [] _ !z = z
09:22:58 <monoidal> flebron: yes
09:23:06 <flebron> Hrm... that's not available in older GHCs, is it?
09:23:16 <Cale> klrr: btw, there is a function in Control.Monad called forever which will run an IO action forever
09:23:22 <monoidal> flebron: it should be
09:23:22 <Cale> :t forever
09:23:24 <lambdabot> Monad m => m a -> m b
09:23:31 <Cale> (or an action in another monad)
09:23:33 <monoidal> flebron: add {-# LANGUAGE BangPatterns #-} on top of the file
09:23:33 <flebron> The (ridiculously old, 6.10.4) compiler on the programming contest site I'm using says that's a syntax error.
09:23:58 <c_wraith> 6.10 supports language pragmas
09:24:35 <flebron> Yes yes, I meant the bang pattern :) Adding that language pragma makes it compile. Still getting time limit exceeded though :(
09:24:53 <c_wraith> though I'm sure they've disabled some of them
09:25:04 <c_wraith> since TemplateHaskell allows arbitrary code execution at compile-time
09:25:07 <klrr> Cale: oh thanks!
09:25:37 <monoidal> c_wraith: I guess they don't; simply the compiler and executable are ran in some sandbox
09:27:48 <flebron> Using the radix sort from http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort#Haskell I still get time limit exceeded :(
09:29:56 <c_wraith> flebron: I'm suspicious of that code, given the amount of ++ in it
09:30:06 <monoidal> also there's foldl there
09:30:23 <klrr> is it good practice to only import those functions you use from a module, or the whole module?
09:31:04 <flebron> Is there a better way of doing tuples = map (\xs -> (head xs, length xs)) . group . sort?
09:31:07 <monoidal> flebron: not to discourage you, but have you tried solving it in imperative language? you might make sure your algo is correct
09:31:17 <monoidal> (by correct I mean fast)
09:31:24 <flebron> monoidal: I'll give that a shot. :)
09:33:21 <hpaste> “Ertugrul Söylemez” pasted “Crypto challenge solution” at http://hpaste.org/86384
09:35:03 <Raghs> I would like to connect to an oracle db. what is a good library to use?
09:35:11 <Cale> klrr: It's good practice to selectively import if you only need one or two things, but very annoying if you can see yourself using more.
09:35:32 <chance> hey guys, im wondering if anyone could help me figure out why haskell-src-ext fails during the configure step when installing ghc-mod
09:35:42 <chance> the error is just an ExitFailure
09:36:08 <monoidal> chance: often when you scroll up you'll see something specific
09:36:29 <dmwit> flebron: How about M.fromListWith (+) [(x, 1) | x <- xs]?
09:36:40 <flebron> M being Data.Map?
09:36:43 <dmwit> yep
09:37:07 <chance> hmmm
09:37:28 <flebron> I'll give that a shot as soon as I finish doing the C++ version :)
09:37:36 <chance> The program happy version >=1.17 is required
09:37:39 <chance> that might be it.
09:37:45 <dmwit> flebron: Wait, this is supposed to be a radix sort?
09:37:48 <dmwit> That's not a radix sort.
09:37:48 <monoidal> chance: cabal install happy
09:37:59 <flebron> dmwit: I didn't think so :s Since there's no upper bound, for one.
09:38:02 <chance> yeah, thats what im doing.
09:38:22 <fimad> chance, make sure happy is in your $PATH
09:39:06 * chance wears the tard hat.
09:39:23 <chance> path issues, oh how your so subtle. i should have checked.
09:39:51 <dmwit> Doesn't cabal issue a warning if its install path isn't on your $PATH?
09:40:00 <dmwit> If not, it totally should. =P
09:40:17 <chance> cabal's in my path, but i was installing to $HOME/.cabal/bin which wasnt in my path
09:40:35 <chance> so it was installing things perfectly fine when dependencies werent needed.
09:40:36 <dmwit> $HOME/.cabal/bin is its install path.
09:40:43 <dmwit> So I stand by my statement.
09:40:48 <chance> oh i misread.
09:40:56 <shirt> i'm compiling my haskell program with: cabal configure && cabal build; how should i strip the final executable? is there anything else i should do before distributing the final executable?
09:41:06 <chance> i didnt get any warnings
09:41:32 <dmwit> shirt: Any reason plain old "strip" is no good?
09:41:49 <dmwit> As for distribution, I guess that really depends on what you want...
09:42:19 <dmwit> For most Haskell programs, I think the SOP is just to host the code on Hackage.
09:43:46 <shirt> dmwit: plain old "strip" it is then, thanks. this program is a server program. i don't want to install the haskell toolchain and cabal and compile the program on the server. for now i'll just copy the executable file, but eventually i guess i'll package the program into a .deb or something
09:44:29 * hackagebot monad-control 0.3.2.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.2.1 (BasVanDijk)
09:48:56 <allenj12> hmm can anyone show me a good resource on learning parsec it seems confusing to me
09:51:22 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- this page is *slightly* out of date, but still mostly relevant
09:51:55 <allenj12> ty
09:51:58 <Cale> The biggest change is that the modules have moved a bit and parsec allows for some more generalised parsers
09:57:26 <hpaste> flebron pasted “Translated to C++” at http://hpaste.org/86386
09:57:35 <flebron> monoidal: That algorithm runs in time.
09:58:33 <flebron> Maybe I could do the left and rights thing in one pass, like in C++.
09:59:36 <flebron> I'll construct A^3, and then foldl' over it, constructing a ([Int], [Int]).
10:00:16 <flebron> (And cross my fingers and hope that A^3, meaning [(Int, Int, Int)] gets eschewed at compile time into something more efficient.)
10:10:54 <klrr> fuck i suck, cant even make simple MUD....
10:14:51 <jfischoff> what I am missing about the difficulty of serializing Haskell types to databases?
10:15:22 <jfischoff> From my naive position I would assume a useful general solution could be had
10:18:11 <klrr> anyone got an idea what program to write?
10:18:30 <dmwit> What do you wish you could do more easily?
10:18:38 <klrr> hmm
10:18:45 <jfischoff> I have a bunch of ideas for toolchain stuff
10:18:56 <dmwit> Of course I could propose plenty of my own projects. =)
10:19:00 <klrr> i dont know, as paul graham always say "the user dont know good design, the maker does"
10:19:02 <dmwit> Also: haskell_proposals.reddit.com
10:19:21 <jfischoff> dmwit: I'd listen :)
10:19:34 <klrr> dmwit: plz tell your projects
10:22:09 <dmwit> Well, I've got one for playing go on DGS; I've got a tool for splitting PDFs for Kindle that could use some love; byorgey, vilhelm and I are trying to come up with a port of Lightweight Monadic Programming in ML to Haskell; I could hand off the source code for connexus, a stupid little game; you could hack on yeganesh (maybe it can be ported to xmonad's prompt utility!)...
10:22:29 <dmwit> I'd love some bindings to ghosd for Haskell.
10:23:29 <klrr> dmwit: sounds very difficult i cant even make a simple MUD xD
10:23:53 <dmwit> The best way to learn is to pick something fun and make it happen! =)
10:24:00 <byorgey> MUDs are not very simple.
10:24:23 <klrr> byorgey: they're not? i tried but got stuck when it came to state
10:24:24 <byorgey> i.e., you shouldn't feel bad that you can't make one.
10:24:43 <johnw> dmwit is right
10:24:49 <johnw> bringing fun into the process is essential
10:24:55 <dmwit> State is always fun. Especially when you have to play well with other stuff, like concurrency.
10:24:58 <klrr> okey, still feel kind of bad when ive worked on it since saturday and havent even gotten anywhere
10:25:17 <dmwit> If you still like the idea of making a MUD, I encourage you to keep hacking on it.
10:25:31 <klrr> i donno
10:25:43 <klrr> too difficult not fun to just try find code to copy paste
10:25:48 <klrr> since i cant figure out stuff myself
10:26:00 <dmwit> Oh, well... there's your problem!
10:26:06 <dmwit> You totally can figure stuff out yourself. =D
10:26:21 <klrr> well, i do, but when i write it it's not logical
10:26:27 <dmwit> 'sok
10:26:33 <oconnor0> klrr: it took me 8+ hours to implement a random search algo in haskell in part of an attempt to learn the language. that's substantially simpler than a MUD & yet wasn't as simple as i'd expected. :)
10:26:35 <dmwit> You get better at it.
10:27:04 <dmwit> "Experience is what you get right after you needed it" and all that.
10:27:07 <klrr> okey, first i need something that i can write that is somewhat useful
10:27:17 <johnw> dmwit: haha, great quote! :)
10:27:43 <dmwit> Ray tracers, IRC bots, and lambda calculus interpreters are also popular early projects.
10:27:48 <Zenol> Ok, after some test, multithreaded applications (I mean, ones writen in C) works well on my computer. Some one have a piece of haskell code wich run faster on his machine thant without parallelisation, so that I can test it?
10:27:54 <dmwit> Popular in part because there are also tutorials you can follow along with. =)
10:28:15 <bitonic> GHC doesn’t provide java-style weak pointers right?
10:28:16 <dmwit> Zenol: Sure, I think I have one lying around.
10:28:26 <oconnor0> it's not an original project, but i really liked going thru http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
10:28:31 <klrr> dmwit: written a irc scheme bot(after reading the irc bot tutorial on wiki and the "Write yourself a scheme in 48h" book), what's a ray tracer?
10:28:51 <hpaste> dmwit pasted “parallelism!” at http://hpaste.org/86387
10:29:05 <scalable> klrr: https://en.wikipedia.org/wiki/Ray_tracing_%28graphics%29
10:29:21 <klrr> thanks!
10:29:33 <dmwit> Zenol: I can give you a sample input file, too, let's see...
10:30:35 <klrr> https://upload.wikimedia.org/wikipedia/commons/e/ec/Glasses_800_edit.png <- that's ray tracing =o i would never be able to do any 3d
10:30:59 <dmwit> Well, that's a particularly complicated scene. You start with simpler scenes, of course.
10:31:15 <klrr> should i use FRP and OpenGL?
10:31:22 <Zenol> dmwit > Thanks you very much :)
10:31:46 <luite> klrr: OpenGL woudld probably not help much
10:31:50 <FireFly> A sphere is a good start
10:32:03 <klrr> luite: then how would i be able to print stuff to the screen?
10:32:11 <dmwit> Who needs to print stuff to the screen? =)
10:32:28 <luite> klrr: you're doing lots of ray/object intersections, you could do some of it with opengl fragment shaders, but you'll probably hit recursion limits
10:32:29 <Hafydd> I don't understand the first warning in "parallelism"
10:32:33 <klrr> what, should i make a 3d object that's not visable?
10:32:38 <luite> klrr: you just generate a bitmap usually
10:32:45 <Hafydd> Is that a bug, or did I miss something?
10:32:52 <klrr> aah now i get it
10:32:57 <klrr> i thought it was an animation
10:33:01 <Zenol> You can be shure your first raytraced picture will look a little bit simplier, like a sphere or any quadratic surface.
10:33:11 <dmwit> Hafydd: I suppose it's probably complaining about Namira'sRot
10:33:30 <Hafydd> Oh, I see. Also it suggested DragonSTongue
10:34:30 <luite> klrr: doing that scene realtime with all those refractions would probably require really powerful parallel hardware :)
10:35:27 <klrr> oh okey
10:35:39 <klrr> is it very difficult or medium difficulty level?
10:35:43 <Zenol> klrr > I made my first raytracer using the devIL library to output png picture. It works well and it's not so complicate.
10:35:57 <luite> klrr: raytracing by itself is quite simple, but you can make it as complicated as you want
10:36:04 <Zenol> klrr > I found the part of writing a picture file the hardest part.
10:36:48 <klrr> okey, so i can partly cheat, and then i know everything completely i can rewrite it completely myself and try make it more advanced?
10:36:55 <klrr> and still learn
10:37:16 <dmwit> What part of our suggestions sounded like cheating?
10:37:47 <klrr> taking another ones solution to a problem
10:38:37 <isBEKaml> klrr: considering that you want to improve/advance other's code further, it's _not_ cheating. :)
10:38:49 <klrr> when i wrote my IRC Bot i had to read two tutorials which basically told everything, then i tied them together and then modified it, it felt like cheating but i learned how to write a irc bot and how to implement a simple scheme
10:39:36 <dmwit> Nobody suggested taking another person's solution.
10:39:50 <klrr> no, i just asked if it's harmful
10:40:03 <dmwit> That depends on your goals, I guess.
10:40:12 <klrr> becoming a programmer
10:40:14 <dmwit> But I don't think tinkering with code (even other people's code) is going to make you a worse programmer. =)
10:40:23 <klrr> okey
10:40:38 <dmwit> Lots of people got started by copying code out of magazines line by line before the Internet was around to make that unnecessary. =D
10:40:55 <klrr> that gives me some hope :D
10:41:03 <dmwit> One of my favorite stories involves a guy finally realizing that the parts written in English were actually the *least* important parts of the code...
10:41:05 <isBEKaml> dmwit: then we had C-c and C-v? :D
10:42:17 <koala_man> dmwit: haha, he thought the comments were what defined the logic?
10:42:42 <dmwit> koala_man: Well, he figured, you know, "this is the part I can understand, it must be important". ;-)
10:42:46 <isBEKaml> koala_man: I guess the poor guy turned into a computer - kind of, the narcissus tale. :D
10:43:06 <Mortchek> Sounds more Kafka-esque to me
10:43:30 <Mortchek> Kafkamorphism
10:44:30 <kryft> dmwit: How much do you think one should read before trying to write something 'real'? I've covered most of LYAH and read about 10 chapters of RWH, but I still feel like I should understand more before I actually start a project. :P
10:47:12 <dmwit> kryft: You should stop reading right before you become bored with it.
10:48:02 <Cale> kryft: It all depends on what sort of person you are. I highly recommend at least writing small bits of code as you go.
10:48:34 <hpaste> allenj12 pasted “Parsec help” at http://hpaste.org/86388
10:48:41 <amindfv> kryft: I'd base it not on your knowledge but on having a useful challenge
10:48:41 <allenj12> how do i fix that??
10:48:58 <Cale> allenj12: Import all of Text.Parsec.String
10:49:05 <amindfv> if you have a project you really want to work on, you've covered more than enough to be able to research the rest as necessary
10:49:12 <Cale> and don't import Control.Applicative
10:49:32 * hackagebot fsnotify 0.0.10 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.0.10 (GregWeber)
10:49:33 <Cale> Or import one of Control.Applicative or Text.Parsec.Prim hiding ((<|>))
10:49:53 <dmwit> Control.Applicative.<|> is superior to Text.Parsec.Prim.<|>!!!
10:50:17 <Cale> I'm not sure why they wouldn't be the same thing by now
10:50:17 <Zenol> dwit > Unreadable and uninderstanding javascript an a small magazine \ o / It remembers me old memorys.
10:50:21 <FireFly> @ty (<|>)
10:50:22 <aCube> Is Parsec's (<|>) optimized?
10:50:23 <lambdabot> Alternative f => f a -> f a -> f a
10:50:47 <Cale> aCube: in any case, the (<|>) you get would be defined by the Parsec library, because it would be defined by an instance.
10:50:47 <aCube> @src Parsec (<|>)
10:50:48 <lambdabot> Source not found. You untyped fool!
10:51:05 <Cale> (Of Alternative)
10:51:17 <dmwit> Cale: Yeah, parsec should really just re-export C.A.<|>
10:51:18 <aCube> Yeah, but why does it still exist then?
10:51:20 <allenj12> hmm i still get char not identified after removing control.applicative and import all of Text.Parsec.String
10:51:27 <kryft> Cale: I did write a fair number of small exercises (maybe 120 or so?) as part of the course I took last year, and I did most of the exercises in the first few chapters of RWH. I'm just not sure how deeply I should understand monads and various other things I've heard mentioned before I try to do arbitrary real-word stuff.
10:51:28 <allenj12> or not in scope
10:51:59 <dmwit> understand by doing
10:52:01 <Cale> kryft: don't worry about it
10:52:01 <kryft> real-world, even :)
10:52:15 <Cale> kryft: You don't really need to understand monads to do anything.
10:52:20 <dmwit> Now that I know the context, I have a different opinion. Start now, you don't need any more expertise.
10:52:42 <hpaste> allenj12 pasted “Parsec help update” at http://hpaste.org/86389
10:52:44 <Cale> Any library which could be an instance of Monad could also just be a library without the recognition of that fact
10:52:58 <Cale> and maybe you have to write a few extra functions because of it
10:53:01 <Cale> but whatever
10:53:22 <kryft> Cale: Right, because it's basically just a way to remove boiler-plate?
10:53:46 <Cale> allenj12: ah, import Text.Parsec.Char
10:54:42 <Cale> kryft: Well, it's like a shape that shows up in a lot of libraries, and by recognising that we can write a valid return and (>>=), we get all the stuff in Control.Monad for free.
10:54:52 <kryft> Cale: Right
10:55:43 <Cale> If the Monad class didn't exist, we'd be perfectly fine, we could just have lots of different returns and (>>=)'s or things related to them, or perhaps that structure would go unrecognised and we'd just have some of the stuff we'd otherwise get from Control.Monad
10:55:53 <Cale> But life would go on :P
10:56:41 <Cale> In fact, various monads were being used in GHC before the Monad class existed, and there were combinators like `then` instead of (>>=)
10:57:46 <kryft> Cale: Am I correct in assuming that the other things I've seen mentioned (arrows, lenses, co-monads, etc) are also just libraries in the same way that Control.Monad is?
10:57:51 <Cale> yes
10:58:07 <klrr> ray tracing is too difficult, i dont even understand the formulas on wikipedia, i dont even know how binary trees works (which i  guess i need)
10:58:09 <Cale> They're all just abstractions of things which go on commonly in combinator libraries
10:58:19 <davd> is the 2013.2 release of the haskell platform on-track? not much happening on trac.
10:58:22 <saep> @pl \m a -> f (a*c) m
10:58:22 <lambdabot> flip (f . (c *))
10:58:28 <Cale> klrr: You don't really need binary trees
10:58:41 <FireFly> klrr: you wouldn't need binary trees, but you'd need a fair amount of linear algebra
10:58:43 <Zenol> dmwit > improving come from the Dmwit package? :)
10:58:46 <Cale> klrr: A long time ago, I wrote a ray tracer which was about 1 page of Haskell code.
10:59:06 <kryft> Cale: Right, so if I don't know about them, the worst thing that will happen is that I'll write things less generally or elegantly or more verbosely than would be possible if I did know about them
10:59:26 <Cale> (it only had glossy spheres and lights)
10:59:36 <Zenol> klrr> Wow, do not go too far. You can't need to know anything about that. Just to know how to solve xx^2 + bx + c = 0 :)
10:59:38 <Cale> kryft: right
10:59:39 <klrr> okey, but why does wikipedia have all these difficult math, we dont learn math in sweden, well we do but not enough in my opinion
10:59:45 <arbn> So, with HXT, if I parse something as HTML, are there no text nodes at all?
11:00:12 <Cale> kryft: It helps that you already know that Control.Monad exists though, there are often things in there which will help to use if you're trying to use a library which happens to define a monad.
11:00:19 <FireFly> klrr: well it depends on what education you have..
11:00:34 <Cale> kryft: but mostly you can get by with sequence and forM/mapM and the occasional forever
11:00:52 <klrr> Zenol: elementary school, after summer i start high school (will be 16 then) after that uni
11:00:53 <FireFly> klrr: I learned all necessary maths (and made a raytracer) at 'gymnasium', e.g.
11:01:04 <klrr> FireFly: gymnasium for me next year :/
11:01:52 <klrr> Zenol: xx^2 + bx + c = x^3+bx+c ?
11:01:56 <dmwit> Zenol: Oh, whoops.
11:01:59 <FireFly> Aha, well, until then do whatever you enjoy doing :p
11:02:00 <dmwit> Zenol: I'll post that, too.
11:02:03 <Zenol> I wanted to write x^2 >.<
11:02:32 <klrr> Zenol: was it a equation, then x=0, b=0, x=0,c=0
11:03:02 <Zenol> klrr> A raytracer could be simple or complexe. It depend if you just want to show a sphere with a bit of light, or complexe scene with true light (foton mapping, montecarlo) and optimise big scene (trees) and lot's of other things really complex. If you wan't an horribely powerfull and complex raytracer you have pov ray. But for a simple start, you have to intersecte a straight line with a sphere, defined by a sphere exation : x^2 + y^
11:03:27 <hpaste> dmwit pasted “Dmwit.hs” at http://hpaste.org/86391
11:03:28 <kryft> Cale: Yeah, I think I even have a decent understanding of monads already (for some value of 'decent' :)
11:03:33 <Cale> Zenol: your message was cut off at x^2 + y
11:03:45 <Zenol> klrr > sorry, i'm used to call given values as a, b, c, and so :(
11:04:02 <Zenol> sphere equation : x^2 + y^2 = radius.
11:04:17 <FireFly> You probably want a z too
11:04:21 <klrr> Zenol: okey, and x y is what in this scenario?
11:04:38 <Zenol> FireFly > Err, i'm not shure, do we really live in 3d?
11:05:00 <absence> is anyone familiar with the dover books on maths? wondering which of their topology books is most appropriate for haskelly stuff
11:05:14 <Nisstyre-laptop> absence: none of them?
11:05:26 <Nisstyre-laptop> I mean, why would you need topology for Haskell?
11:05:34 <Zenol> klrr> Maybe you wat a short text explaining how works a raytracer (without any bit of code, but deisnged for learning how to write one) ?
11:05:40 <klrr> raytracer :: Int -> Int -> PNG; raytracer x y = x^2+y^2
11:05:49 <Cale> Nisstyre-laptop: because computable functions are continuous maps
11:05:56 <klrr> Zenol: sure
11:06:09 <Cale> and types are spaces :)
11:06:29 <Zenol> Nisstyre-laptop>Maybe he hexpect to calculate the homology group of the planar curves defined by the code he wrote? ^^'
11:06:35 <Nisstyre-laptop> okay, so there's a strangled way in which it's relevant
11:06:41 <Cale> (but you really don't *need* topology to understand Haskell :)
11:06:45 <absence> Nisstyre-laptop: well, not FOR haskell, but to learn more about the whole theory around it. abstract algebra and topology are often mentioned alongside category theory
11:06:46 <klrr> i think i need to know how to write the program before writing it, i cant really figure out how a ray tracer is implemented in my head since i dont know how to make a light jumping around on a sphere in haskell
11:06:52 <Nisstyre-laptop> Zenol: well yeah it's relevant if you want to do topology with Haskell
11:06:58 <Cale> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ -- this is pretty cool though
11:07:39 <pmade> I have a bunch of types that are instances of a class Foo with one function `foo' that is like read, you are suppose to return an object after parsing an input stream.  There are a couple of types that I can't make into instances because their version of `foo' would need one more parameter to work.  Is there a trick to hiding that parameter in order to make this type an instance of the class?
11:07:41 <Zenol> Oh, just remember the text I as thinking about was writen in french.
11:07:42 <Cale> It turns out to be possible to carry out exhaustive searches over infinite types, due to their compactness as spaces.
11:08:05 <Cale> and http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf is a good introduction to the connection
11:08:18 <dmwit> pmade: make (Input -> Foo) an instance instead of Foo?
11:08:31 <pmade> dmwit: Oh, that's a great idea.
11:08:37 <pmade> dmwit: Thanks!
11:08:57 <kryft> Cale, dmwit: Anyway, thanks for the advice and encouragement!
11:08:57 <Cale> and, that's without even mentioning the homotopy type theory stuff which is going on in systems with dependent types :)
11:09:36 <pmade> dmwit: would my `foo' look like this: foo = \x -> y
11:10:49 <pmade> Or I guess: foo = \x -> y x
11:11:25 <jfmatt> anyone online?
11:12:18 <jfmatt> Would anyone mind looking over a bit of code I wrote last night?
11:12:19 <arbn> jfmatt: No.
11:12:35 <arbn> jfmatt: Paste it with hpaste.
11:12:35 <jfmatt> It works, I just want to know what horrible stylistic/optimization errors I made
11:12:48 <arbn> jfmatt: Don't ask to ask, etc.
11:12:49 <Zenol> klrr> I found that http://devmaster.net/posts/2836/raytracing-theory-implementation-part-1-introduction. I didn't read the text but the rawings could help a lot.
11:12:50 <klrr> I DOPNT WNBUAJWBINKFILANJSFBNKNASFÖP*ASF
11:12:52 <klrr> fsd
11:13:10 <klrr> i cant do those stuff i dont have the iq ffs
11:13:22 <hpaste> jfmatt pasted “Minesweeper” at http://hpaste.org/86392
11:13:24 <klrr> i will never learn fucking progrmaming, ill become an idiot like all others
11:14:10 <parcs> the teenage angst is strong in this one
11:14:33 <Zenol> I didn't want to know his "friends".
11:15:05 <osa1> I'm trying to watch some files with INotify haskell wrapper, but program ends immidiately after creating watcher descriptors. I'm putting "getContents" at the end of program but that doesn't work because getContents runs lazily. any ideas ?
11:15:22 <geekosaur> @paste
11:15:22 <lambdabot> Haskell pastebin: http://hpaste.org/
11:16:32 <hpaste> osa1 pasted “lazy io problem thing” at http://hpaste.org/86393
11:16:37 <osa1> geekosaur: ^
11:17:18 <geekosaur> so, a couple of issues there
11:17:21 <dmwit> This has nothing to do with lazy IO.
11:17:57 <osa1> dmwit: how so? getContents is not waiting for input
11:17:58 <geekosaur> two getContents calls? only the first (which is void-ed) does anything, and do you really want stdin there?
11:18:18 <Zenol> dmwit > Anyway, alchemistry in syrim is fun :)
11:18:39 <dmwit> osa1: getContents is getting run as part of your callback, not at the end of the program in a way that would keep it open.
11:18:42 <osa1> geekosaur: no I don't really want stdin, I just want program to run until C-c
11:18:48 <dmwit> Zenol: yeah =)
11:18:50 <osa1> oh
11:18:57 <geekosaur> so, you seem extremely confused about how I/O works
11:19:13 <geekosaur> getContents operates on stdin, not some other filehandle. and you're calling it twice
11:19:31 <osa1> geekosaur: I called it twice for testing purposes
11:19:35 <geekosaur> the first gets all input, and marks the handle so the second won't do anything
11:19:41 <geekosaur> (it's "half-closed")
11:20:02 <geekosaur> ...hm, maybe it does *something* but I would not want to guess what; it's not something you are ever supposed to do
11:20:32 <osa1> dmwit: moving `getContents` to main's top level doesn't work either
11:20:43 <geekosaur> once you have called hGetContents on a handle (this includes getContents which is hGetContents stdin) you should not touch that handle ever again
11:21:18 <osa1> geekosaur: I know, because it's reading until EOF and reading after EOF ....causes  unspecified behavior ??
11:21:25 <geekosaur> ...
11:21:40 <geekosaur> the "it's half closed" was clearly not at all content-bearing, I see
11:21:47 <geekosaur> nor was:
11:21:54 <geekosaur> [23 14:20] <geekosaur> once you have called hGetContents on a handle (this includes getContents which is hGetContents stdin) you should not touch that handle ever again
11:22:49 <osa1> alright. so now how can I make that program run until reading EOF ?
11:23:01 <geekosaur> once you hGetContents a handle, the handle is managed "automaticaly" and touching that handle in any way other than consuming the string will interfere with that
11:23:22 <geekosaur> I am still trying to figure out what you think you are doing there
11:24:10 <osa1> is it really that complicated ? I'm adding folders recursively to inotify watcher with a dummy handler used for testing
11:24:26 <monochrom> please just don't call getContent twice. please just don't. please.
11:24:32 <geekosaur> yes, and I don't see what getContents is doing at all
11:24:54 <dmwit> I get it.
11:24:54 <osa1> monochrom: I know, I know ....
11:25:08 <osa1> geekosaur: please remove all getContents and read again
11:25:09 <geekosaur> also: it's lazy I/O, it only does actual I/O if you *do* something with the data that getContents returns (which it isn't, at all, because you used void)
11:25:16 <dmwit> Perhaps you should replace "void $ getContents; c <- getContents" with "c <- getContents; print (last c)" or some such thing.
11:25:36 <Zenol> dmwit > Could you tell me how I should use it? It looks "infinitly looping" with an empty inentory.
11:25:48 <osa1> geekosaur: I also realized that and the question I asked was actually how can I overcome this (ie. force that io operation)
11:25:51 <dmwit> Or, you know, just "threadDelay (sleep maxBound)".
11:25:57 <geekosaur> osa1, please show your current code
11:26:11 <dmwit> ugh
11:26:21 <dmwit> osa1: How about "forever (threadDelay maxBound)" instead?
11:26:25 <dmwit> If you intend your program not to exit.
11:26:27 <hpaste> osa1 pasted “lazy io think take 2” at http://hpaste.org/86395
11:27:16 <osa1> dmwit: I want it to exit when EOF is read
11:27:21 <dmwit> Zenol: The program searches for the best combinations of ingredients, where combinations are "better" when they uncover more unknown effects or uncover the same number but use less ingredients.
11:27:33 <dmwit> Zenol: And as you say, there's no terminating condition. But with more threads, it produces good results faster. =)
11:27:40 <monochrom> a simple getChar will do
11:27:42 <osa1> dmwit: I run it in terminal and end it with C-c
11:27:53 <geekosaur> then why read input at all?
11:27:53 <dmwit> C-c is not EOF.
11:28:00 <geekosaur> use the threadDelay thing in that case
11:28:24 <osa1> geekosaur: oh so C-c will still work? let me try
11:28:39 <monochrom> but infinite threadDelay is closer to the intention
11:28:48 <dmwit> Zenol: If you just want some timings, it should be pretty easy to throw in a terminating condition like "scores better than 60 on the metric" or whatever.
11:29:13 <monochrom> why are programming problems always XY problems?
11:29:39 <osa1> dmwit: geekosaur: thanks very much, threadDelay worked with C-c
11:29:43 <hpaste> allenj12 pasted “Parsec help am i on the right track?” at http://hpaste.org/86396
11:29:48 <arbn> On moth terminals, C-d sends EOF, right?
11:29:53 <arbn> On most*
11:30:08 <monochrom> yes. unless windows is most. then no.
11:30:23 <geekosaur> C-d on unix, C-z on windows (probably need return after C-z)
11:31:35 <geekosaur> ...and just to confuse things, *some* (not all) windows programs handle unixy C-d, and on unix C-z does someting that can be mistaken for program exit/interrupt
11:32:34 <arbn> Yeah. I cringe when I see new unix people use C-z to suspect all those processes. :(
11:32:40 <arbn> suspend*
11:34:53 <armlesshobo> :(
11:35:12 <monochrom> fortunately, unix is configurable. stty can re-map those keys.
11:36:27 <geekosaur> osa1, C-c is intercepted by the system's tty driver and sends an interrupt signal
11:36:38 <monochrom> stty eof ^Z susp ^D  :)
11:36:38 <armlesshobo> kill -9 pid
11:36:39 <armlesshobo> :)
11:37:03 <armlesshobo> why not just use C-c?
11:37:18 <tgeeky> copy you way to EOF?
11:38:13 <Zenol> dmwit > Hum, have you an input file that "works well" ? I tried to add some ingredients ramdomly and i only get an empty list.
11:40:30 <hpaste> dmwit pasted “potions.di” at http://hpaste.org/86398
11:42:59 <dmwit> Hm, even that one isn't so amazing.
11:47:29 <dmwit> Okay, here's a machine-generated one. Eight each of the first forty ingredients, and no pre-knowledge.
11:48:02 <hpaste> dmwit annotated “potions.di” with “potions.di (annotation)” at http://hpaste.org/86398#a86404
11:48:11 <dmwit> Zenol: try that one =)
11:51:48 <Zenol> dmwit > Hum, it's hard to benchmark since when i increse the number of core, it seems you are cutting your research in different thread and then new datas appear. And I also swaped to the non random one, cause i want a deterministic behavior.
11:52:37 <dmwit> Oh, ack. You did say you wanted parallelism all the way back when, and I just didn't think.
11:52:39 <Zenol> It's strange that there is only output with -N2 and not with -N1...
11:53:20 <Zenol> I was thinking about Control.Parallel mor than forkIO ^^
11:53:24 <dmwit> yes
11:53:31 <dmwit> You said the right word. It was my mistake.
11:53:41 <dmwit> This is definitely an application with concurrency, not parallelism.
11:54:01 <hpaste> allenj12 pasted “Parsec update” at http://hpaste.org/86405
11:54:03 <dmwit> Hm, I wonder if I have any actually parallel things lying around.
11:54:15 <johnw> i've yet to use parallelism in Haskell; but I use concurrency very often
11:54:57 <allenj12> am i looking at that the right way?
11:56:04 <dmwit> Zenol: Maybe there's something in http://packdeps.haskellers.com/reverse/parallel
11:56:42 <dmwit> or possibly you would like
11:56:44 <dmwit> ?hackage dph-examples
11:56:45 <lambdabot> http://hackage.haskell.org/package/dph-examples
11:56:49 <dmwit> dunno for sure
11:57:11 <Zenol> Oh no, please, please, not dph.
11:57:20 <dmwit> ok =)
11:57:37 <dmwit> allenj12: perhaps you want atomic = many (letter <|> space) >> return ()
11:57:46 <Zenol> I spend 4 how from 00h to 4h trying to make it work with my raytracer :(
11:58:01 <dmwit> allenj12: ...or perhaps you want atomic :: Parser String instead.
11:58:09 <Zenol> (And, it didnt)
11:58:16 <allenj12> dmwit: hmmm ill try both
11:58:21 <dmwit> allenj12: NO!
11:58:24 <dmwit> allenj12: Stop. Think.
11:58:49 <allenj12> dmwit: kk
11:58:56 <tgeeky> Halt! Gadunken Time!
11:58:56 <dmwit> allenj12: Do you understand the error message?
11:59:33 * hackagebot fsnotify 0.0.11 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.0.11 (GregWeber)
11:59:49 <allenj12> dmwit: sry lol tired and yes except i dont know what ParsecT is
12:00:38 <allenj12> dmwit: im pretty sure i want Parser String
12:00:51 <dmwit> allenj12: type Parser = Parsec String (); type Parsec s u = ParsecT s u Identity
12:01:17 <dmwit> allenj12: Yeah, that seems pretty right to me, too. Though I think you will need some other changes to go along with that.
12:01:41 <allenj12> dmwit: ahh ty and yes
12:04:33 * hackagebot operational 0.2.2.1 - Implementation of difficult monads made easy  with operational semantics.  http://hackage.haskell.org/package/operational-0.2.2.1 (HeinrichApfelmus)
12:21:50 <Zenol> Something completely different ; did anyone looked at omegagb ?
12:22:48 <scooty-puff> I was trying to make unboxed refs backed by MutableByteArray# that allowed for custom instances by defining (a, b) and () - the hope was that modifyRef for Ref (a, b) where only a is modified would not result in a useless write to b
12:23:02 <scooty-puff> however, upon inspection of the cmm, this exists
12:23:47 <scooty-puff> would a rewrite rule help here - readRef >>= writeRef where only fst is changed?  it does not seem like it would be particularly robust
12:25:07 <hpaste> scooty-puff pasted “Useless writes” at http://hpaste.org/86406
12:29:33 * hackagebot bound 0.8 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.8 (EdwardKmett)
12:51:04 <hidenori> i just started studying foldl and foldr, and am wondering if foldl f acc xs = foldr (flip f) acc (reverse xs) holds when xs has a finite length
12:52:56 <ab9rf> hidenori: that seems likely, but i can't prove it
12:53:38 <parcs> hidenori: only if f is associative
12:53:42 <hidenori> ab9rf :I see. hmm still not quite sure how they work
12:54:27 <djahandarie> parcs, no, it works for non-associative functions as well
12:54:39 <ab9rf> that won't matter
12:54:56 <ab9rf> the order of application appears to be the same
12:55:01 <gmaggior_> join #emacs
12:55:05 <hidenori> i think so too
12:55:20 <rifki> hi, where can I find all instances of Eq?
12:55:25 <ab9rf> @instances EQ
12:55:26 <lambdabot> Couldn't find class `EQ'. Try @instances-importing
12:55:27 <parcs> oh, yeah
12:55:28 <ab9rf> @instances Eq
12:55:29 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:55:50 <FireFly> hidenori: have you seen Cale's (I think?) visualisation of them? http://en.wikipedia.org/wiki/Foldl#Folds_as_structural_transformations
12:55:53 <djahandarie> > foldr (flip (-)) a (reverse [b,c,d,e])
12:55:55 <ab9rf> that's not "all" instances of Eq, just all the ones lambdabot normally knows about
12:55:56 <rifki> and their implementations :)
12:55:56 <lambdabot>   a - b - c - d - e
12:56:07 <djahandarie> > foldl (-) a [b,c,d,e]
12:56:08 <lambdabot>   a - b - c - d - e
12:56:17 <h4199> > foldl ((^)) 2 [1..3]
12:56:18 <hidenori> FireFly: Not really...
12:56:19 <lambdabot>   64
12:56:21 <jfmatt> right, and hoogle unfortunately doesn't link to implementations, which is silly
12:56:22 <parcs> > foldr (-) a [b,c,d,e]
12:56:23 <lambdabot>   b - (c - (d - (e - a)))
12:56:35 <h4199> > foldl (flip (^)) 2 $ reverse [1..3]
12:56:36 <lambdabot>   1
12:56:50 <FireFly> hidenori: (referring to the pictures in the wikipedia article, in case I wasn't clear)
12:56:51 <ab9rf> h4199: you used foldl in both cases
12:56:56 <FireFly> I probably should've clarified
12:57:00 <h4199> oh oops
12:57:03 <ab9rf> > foldr (flip (^)) 2 $ reverse [1..3]
12:57:04 <h4199> missed that
12:57:05 <lambdabot>   64
12:57:28 <parcs> so foldl f acc xs === foldr f acc xs if f is associative and commutative
12:57:36 <ab9rf> hidenori: i think that lemma holds
12:58:15 <hidenori> parcs: I think by use flip, commutative does not matter
12:58:17 <johnw> parcs: I think you need to add "strict", don't you?
12:58:23 <ab9rf> hidenori: and by reversing xs
12:58:46 <hidenori> ab9rf: yea you are right
12:58:49 <ab9rf> hidenori: flip is needed to avoid requiring commutativity, and reversing xs to avoid requiring associativity
12:59:31 <ab9rf> so the question, is foldl f acc xs === foldr (flip f) acc xs iff f is associative?
12:59:35 <hidenori> ab9rf: does reversing xs really avoid requiring associativity>
12:59:49 <ab9rf> hidenori: i think so, but i can't prove it :)
13:00:05 <hidenori> ab9rf: i see :)
13:00:11 <ab9rf> also, is foldf f acc xs === foldr f acc (reverse xs) iff f is commutative?
13:00:23 <hidenori> i think so
13:00:27 <ab9rf> (then again, are there commutative but nonassociative operators?)
13:00:34 <djahandarie> ab9rf, yes.
13:00:51 <hidenori> at least, i tried some and all of them worked
13:00:58 <parcs> johnw: hmm probably
13:01:08 <ab9rf> djahandarie: yes?
13:01:21 <djahandarie> ab9rf, yes, there are commutative non-associative operators.
13:01:21 <oconnor0> ab9rf: floating point operations, i believe
13:02:04 <ab9rf> oconnor0: hm, good point
13:02:13 <djahandarie> Hardly need to get that complicated.
13:02:18 <danr> ab9rf: exercise: for all finite n, how many such operators does there exists on a set with n elements?
13:02:40 <ab9rf> danr: erk.  that's way too deep into the group theory rabbithole for me
13:03:24 <byorgey> that's not group theory, it's combinatorics =)
13:03:36 <h4199> http://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma
13:03:41 <danr> also groups are associative :)
13:03:48 <FireFly> Wikipedia has articles for everything..
13:03:58 <ab9rf> whichever :)
13:04:02 <Cale> ab9rf: Think about rooted trees
13:04:06 <danr> h4199: good link :)
13:04:11 <Cale> ab9rf: (with unordered children)
13:04:16 <ab9rf> my discrete math ranges from poor to nonexistent, and is stale in any case, not having been used in decades
13:04:30 <sproingie> does Wikipedia have an article about everything except the article about everything?
13:04:47 <ab9rf> wikipedia has an article on everything, but the article may contain unexpected penis
13:04:58 <Cale> Given a pair of rooted trees, we can form a new rooted tree by adding a new vertex to be the root, and attaching the roots of our two original trees to that new root.
13:05:02 <h4199> http://en.wikipedia.org/wiki/Everything
13:05:05 <danr> sproingie: it even has this page http://en.wikipedia.org/wiki/List_of_lists_that_don't_contain_themselves
13:05:18 <ab9rf> danr: hah
13:05:20 <Cale> ab9rf: This operation will be commutative (because we don't care about the order of the subtrees)
13:05:41 <parcs> bah, gnome terminal delimits URLs containing ' :(
13:05:41 <Cale> but it won't be associative
13:05:44 <ab9rf> Cale: yes, i see where you're going with that
13:06:57 <sproingie> parcs: can't you customize that oh wait gnome nevermind
13:07:03 * sproingie hugs urxvt
13:07:05 <djahandarie> > let x % y = x*y - (x+y) in (2 % (3 % 10), (3 % 10) % 2, ((2 % 3) % 10))
13:07:06 <lambdabot>   (15,15,-1)
13:07:34 <johnw> djahandarie: nice!
13:08:00 <johnw> > let x % y = x*y - (x+y) in (2 % (3 % 10), (10 % 3) % 2)
13:08:03 <lambdabot>   (15,15)
13:08:07 <sproingie> just found a neat little binding for urxvt, ctrl-del opens the last url hilighted
13:08:55 <sproingie> ooh better it's actually the bottom-most one currently on the screen
13:11:00 <edwardk> djahandarie: demonstrating a mobile?
13:11:29 * edwardk just tuned in.
13:12:27 <FireFly> mobile?
13:12:38 <dmwit> Suppose I have a set S of sets. Is there anything clever I can do to find the set of minimal sets from S (under subset ordering)?
13:12:55 <edwardk> firefly: http://www.kestrel.edu/home/people/meertens/diverse/calc.pdf
13:13:01 <dmwit> The non-clever thing is to use Set.filter, any, and Set.isSubSetOf.
13:13:28 <edwardk> FireFly: something with commutative but non-associative structure
13:13:32 <absence> is anyone familiar with the dover books on maths? wondering which of their topology books is most related to haskell / category theory stuff (i already know haskell and do not mistakenly believe that i need to learn topology or CT before haskell)
13:14:19 <edwardk> absence: none of the ones i have at least are all that useful in that regard
13:14:19 <djahandarie> edwardk, yup.
13:14:37 <Heffalump> dmwit: that's not unique, is it?
13:14:46 <Heffalump> oh, never mind, it is
13:14:52 <FireFly> edwardk: ah
13:16:17 <danr> dmwit: so if you have {{1},{2},{1,2}}, you want to get {{1},{2}} ?
13:16:18 <absence> edwardk: thanks. which ones do you have?
13:16:23 <dmwit> danr: right
13:19:00 <Heffalump> dmwit: how big are the sets?
13:19:06 <edwardk> absence: i'd have to check my shelf at home when i finish unpacking, but i can't say that i got any deep insight into haskell/CT from any of them. http://www.amazon.com/Introduction-Topology-Third-Dover-Mathematics/dp/0486663523 http://www.amazon.com/Topology-Dover-Books-Mathematics-Hocking/dp/0486656764 http://store.doverpublications.com/0486679667.html http://store.doverpublications.com/0486656330.html http://store.doverpublicat
13:19:06 <edwardk> ions.com/0486668266.html were all useless in that regard
13:19:12 <edwardk> i have a few others, but i'd have to dig
13:19:59 <ciaranm> Counterexamples in Topology is mildly interesting
13:20:11 <dmwit> Hm, probably pretty small. Let's say the outer set has a few hundred elements, and the inner ones 1-5 or so.
13:20:12 <ciaranm> but you really want Topology via Logic
13:20:14 <edwardk> i was just about to mention that one
13:20:19 <Zenol> Hum, if y compile my retracer (wich use lot's of list) with -threaded and that I launch it with -Nn, the time spend increase, although there isn't any parallel code. Why? GC?
13:20:21 <dmwit> I don't really *need* anything clever.
13:20:26 <dmwit> I'm just curious. =P
13:20:26 <edwardk> i liked that book because it gave you lots of examples
13:20:39 <edwardk> things that showed that these classifications meant something
13:20:53 <edwardk> http://store.doverpublications.com/0486678504.html http://store.doverpublications.com/0486665224.html http://store.doverpublications.com/048668735x.html are also ones i have that had no deep categorical insights
13:20:53 <Heffalump> I can't think of anything better than turning it into bitmasks and getting a very cheap subset test - but same complexity
13:21:02 <dmwit> Zenol: The threaded runtime pays a tiny bit extra for its extra bookkeeping.
13:21:07 <edwardk> the latter being the counterexamples one
13:21:21 <bitonic> when running from cabal ‘test-suite’, how can I refer to some data file?  I don’t want to hardcode the dist/ path obviously
13:21:32 <edwardk> that said, i was reading all of these before i was interested in category theory
13:21:38 <edwardk> so i may have missed connections
13:21:40 <latro`a_> ...on this general subject about topology, anyone have a short answer as to why topology is so omnipresent? what's the "fundamental thing" that makes it show up everywhere? lattices?
13:21:41 <absence> topology via logic is the primary book to get?
13:21:47 <dmwit> bitonic: Read about the Paths_package_name module that cabal builds for you.
13:21:53 <absence> edwardk: thanks for the list, no need to dig :)
13:22:09 <latro`a_> (I'm not interested in the fact that it shows up in analysis, that's trivial)
13:22:09 <ciaranm> absence: yeah, or Wilson & Sutherland if you want a more conventional mathematical approach
13:22:14 <dmwit> latro`a_: question is backward
13:22:18 <bitonic> dmwit: thanks
13:22:28 <latro`a_> how so, dmwit
13:22:31 <ciaranm> where & is an A, apparently
13:22:42 <dmwit> latro`a_: If it didn't show up a lot, mathematicians wouldn't have named it. ;-)
13:22:51 <latro`a_> ...
13:22:54 <latro`a_> sure they would've
13:23:03 <latro`a_> the concept in R is useful enough by itself
13:23:25 <edwardk> its funny i only now realized that i've stopped reading dover books completely. i can't think of the last one that was worth the time i spent to read it.
13:23:27 <dmwit> I'm just saying it's not interesting that such and such an algebraic structure gets studied a lot and such and such an algebraic structure shows up a lot in various places.
13:23:57 <dmwit> You make up algebraic structures that model things that show up a lot, not the other way around. =P
13:23:59 <latro`a_> I don't think topology is typically thought of as an algebraic structure
13:24:11 <ciaranm> i don't think dmwit has encountered many pure mathematicians
13:24:14 <edwardk> bitonic: you may want to look at my hyphenation package. it uses the Paths_hyphenation file to read dozens of data files in at runtime
13:24:15 <latro`a_> but yes, I realize; I'm curious why the topology axioms are as universal as they are
13:24:26 <latro`a_> also yeah
13:24:31 <latro`a_> pure mathematicians don't work like that really
13:24:35 <Zenol> dmwit > Ok, so if I expect to see improvement I should launch big computations. Thanks.
13:24:35 * hackagebot crypto-api 0.12 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.12 (ThomasDuBuisson)
13:24:37 * hackagebot DRBG 0.3.2 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.3.2 (ThomasDuBuisson)
13:24:49 <bitonic> dmwit, edwardk: right, I was going to say that reading in the contents of a directory looks tricky with data-files
13:25:06 <edwardk> bitonic: you can get the path tot he directory then read it
13:25:27 <ciaranm> latro`a_: if you want to appreciate why they're so universal, you need three good examples of where topologies come from. metric spaces is one, logic is another.
13:26:13 <latro`a_> to my default intuition (not my only intuition, just the one that comes without any thought), a topology *is* a notion of convergence
13:26:20 <latro`a_> not just specifies one, *is* one
13:26:32 <ciaranm> not so much convergence. it's a notion of wiggle room.
13:26:37 <bitonic> edwardk: wait, I feel like I’m missing something—is the Paths_ module documented somewhere?
13:26:47 <edwardk> bitonic: you can generate one and look at it
13:26:48 <latro`a_> I know that, ciaranm
13:26:49 <bitonic> ahhh wait I remember this
13:26:52 <bitonic> it’s in autogen
13:26:54 <edwardk> bitonic: yeah
13:26:55 <latro`a_> but with nets it's the same thing
13:27:01 <bitonic> edwardk: yeah it just came back now :P thanks
13:27:08 <latro`a_> whereas with sequences it's a weaker but simpler notion
13:27:09 <absence> ciaranm: thanks
13:27:29 <edwardk> foo <- getDataFileName "foo.txt" >>= readFile
13:27:30 <latro`a_> but iirc if you specify which *nets* converge over the class of all nets on a space
13:27:35 <latro`a_> you specify the topology exactly
13:27:49 <ciaranm> nets always struck me as being "not really what you want, but the best we can do in an overly general setting"
13:28:02 <absence> edwardk: is it because the dover books aren't good? i was hoping they weren't cheap for a reason :D
13:28:16 <edwardk> absence: they are generally pretty bad.
13:28:24 <ciaranm> i'm not convinced convergence makes sense unless you're at least hausdorff and probably some more stuff
13:28:40 <edwardk> absence: some of them are cheap because they are just translations of a foreign text, etc. some are just rather light overviews, etc.
13:28:41 <latro`a_> eh
13:28:51 <latro`a_> there's a canonical quotient to a hausdorff space
13:29:15 <edwardk> you do get rare gems, but i can point to maybe only 2-3 on my shelf that i'd ever look at again.
13:29:32 <latro`a_> (granted, that quotient can be the trivial space, but still)
13:29:35 * hackagebot Strafunski-StrategyLib 5.0.0.1 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.1 (JamesKoppel)
13:29:37 * hackagebot commsec 0.2.3 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.2.3 (ThomasDuBuisson)
13:29:42 <edwardk> i wound up with so many because of inheriting collections from retiring professors
13:29:44 <Dodek> latro`a_: you lose lots of important data when you go to quotient
13:29:54 <latro`a_> depends on what you're trying to preserve
13:30:11 <ciaranm> i'm trying to preserve my sanity when reading definitions
13:30:16 <absence> edwardk: i see, no free (or low-cost) lunch after all. how about their CT book? http://store.doverpublications.com/0486469344.html
13:30:28 <Dodek> and the actually are important and interesting non-hausdorff spaces, spectra of rings with zarisky topology being one example, or, more generally, schemes
13:30:40 <edwardk> 3-4 CS and math professors retired while i was binging through academia, and I pretty much glommed onto their entire sets of books
13:30:52 <edwardk> haven't read it
13:31:31 <latro`a_> yeah, see, I don't have intuition for why I would want such a space
13:31:38 <edwardk> i tend to recommend Awodey as a one-size fits all for C.T., Categories for the Working Mathematician if you are a working Mathematician, and Lawvere and Schanuel if you really need drill and to get a sense for them
13:31:39 <saml> hello
13:31:42 <latro`a_> as I said, my *default* intuition is "what sorts of sequences/nets converge?"
13:31:50 <saml> i'm here to teach you haskells
13:31:56 <djahandarie> absence, http://katmat.math.uni-bremen.de/acc/acc.pdf
13:32:04 <latro`a_> if that notion doesn't even make sense in a given context, I have trouble understanding why that context should have a topology associated to it
13:32:13 <edwardk> i tend to steer people clear of Pierce's category theory book, because at last check it didn't stick for _him_, so I don't see it sticking for someone else that way ;)
13:32:27 <ciaranm> pierce has turned to the dark side
13:32:47 <ciaranm> also, isn't topology what's left when you abstract away all the sense?
13:32:57 <oconnor0> edwardk: didn't stick for him?
13:33:07 <edwardk> CftWM is still by far the best category theory book I've read. It is the one book I open up and go back and reread and find something new every time.
13:33:16 <tac> Topology is when you remember your points, but forget your metric at home.
13:34:11 <absence> edwardk: ah, the awodey one has been mentioned several places, had my eyes on it :) what would you recommend for abstract algebra?
13:34:17 <edwardk> oconnor0: Last time I talked to him about it he basically admitted as much that he'd forgotten everything he learned about category theory while writing that book. It may have been a bit tongue-in-cheek, but still ;)
13:34:22 <djahandarie> edwardk, that could also mean it's really bad.
13:34:23 <ciaranm> absence: aluffi!
13:34:23 <johnw> absence: not for abstract algebra, no
13:34:27 <Dodek> absence: aluffi, chapter 0
13:34:35 * hackagebot cipher-aes128 0.3 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.3 (ThomasDuBuisson)
13:34:37 * hackagebot commsec 0.2.4 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.2.4 (ThomasDuBuisson)
13:34:39 <edwardk> absence: if you want to go deeper on category theory Serge Lang's Algebra is a good compromise.
13:34:47 <ciaranm> absence: start with Visual Group Theory or something first, though, if you're not up to speed with the basics
13:34:50 <merijn> @remember SatnamSingh I always thought that category theory was something that happened to other people. (#ICFP)
13:34:51 <lambdabot> Good to know.
13:34:58 <johnw> edwardk: do you have a quality reading list up anywhere?
13:35:30 <absence> djahandarie: that's the dover book? cool, thanks
13:35:40 <edwardk> absence: I use it as another bit of C.T. drill for people, it is good because it as dense as CftWM in many ways but its _much_ thicker and introuces the abstract algebra concepts alongside their categorical analogues as it goes
13:35:51 <djahandarie> absence, yup. It's okay. I haven't read most of it.
13:36:05 <edwardk> the later parts of the book get pretty dense though and want a lot of previous experience, but its another tome you can go back to over and over.
13:36:24 <edwardk> That may have been my rather lopsided math education though.
13:36:42 <john__> hi all friends, I join you in this 'blissful love of mathematics
13:37:20 <SexyTattoos96> hi
13:37:56 <john__> I have a work I wish to shar wih you today: The book on numbers
13:38:43 <john__> I't by connway and guy
13:39:22 <absence> ciaranm / edwardk: ok, i'll check them out and see what i end up with. thanks again!
13:39:35 * hackagebot tagged-transformer 0.3 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.3 (EdwardKmett)
13:39:39 <john__> surreal numbers are something I don't understand. Perhas you can help me?
13:39:58 <vraid> surreal numbers?
13:40:08 <h4199> john__: http://www.amazon.com/Book-Numbers-John-H-Conway/dp/038797993X
13:40:21 <johnw> edwardk: do you have a quality reading list up anywhere?
13:40:22 <simpson> They're well-documented online; do some Googling.
13:40:24 <ciaranm> knuth did a book on them
13:40:41 <edwardk> johnw: not really
13:41:06 <edwardk> johnw: the closest thing to a curated reading list i have to offer is the papers list in analytics and that has a very narrow focus on 'crap i can use to make my database go fast' ;)
13:41:16 <john__> h4199, Yeah, thats the one
13:41:40 <edwardk> i tend to just try to 'read all the things' until i get bored and move on to a more productive vein.
13:41:54 <john__> h4199, love the book, just not surreal numbers
13:41:56 * djahandarie usually gets bored within an hour.
13:43:03 <john__> Any comment on. The haskell road to logic, math and programming?
13:43:11 <ciaranm> john__: avoid
13:44:35 * hackagebot Strafunski-ATermLib 1.6 - An abstract data type designed for the exchange of tree-like data structures  http://hackage.haskell.org/package/Strafunski-ATermLib-1.6 (JamesKoppel)
13:44:53 <john__> ciaranm, Well I already have Real world Haskell. What would you reccomend?
13:45:01 <fedvasu> guys, if I have an URL
13:45:09 <ciaranm> john__: if you want to learn that sort of thing, do a pure maths degree
13:45:17 <ciaranm> john__: and learn it properly. because it is worth it.
13:45:23 <fedvasu> with apache benchmark , i can do concurrent requets like this
13:45:32 <fedvasu> ab -n 100 -c 100 <url>
13:45:43 <fedvasu> how to accomplish this haskell??
13:45:46 <john__> ciaranm, I AM a doctor of Math
13:46:08 <ciaranm> john__: in that case you already know the good stuff that's in that book, and you know it properly
13:46:54 <john__> h4199, love the book, just not surreal numbers
13:47:00 <john__> lol
13:47:21 <h4199> copy paste error?
13:47:47 <john__> Hardly, He is just a dificult author
13:49:06 <john__> Anyone else have any problems with connaway?
13:49:20 <john__> Or is it just me?
13:49:30 <ciaranm> he's not abstract enough
13:49:35 * hackagebot Strafunski-ATermLib 1.6.0.1 - An abstract data type designed for the exchange of tree-like data structures  http://hackage.haskell.org/package/Strafunski-ATermLib-1.6.0.1 (JamesKoppel)
13:50:37 <john__> brilliant
13:51:40 <john__> the less people understand it the more erudite we seem, truly arcane, a masterpiece
13:51:59 <Guest86700>  I'm playing around with implementing a toy language/compiler in haskell, do you know of any good resources on language design?
13:51:59 <john__> lol
13:53:17 <jfischoff> Guest86700:Types and Programming languages. Also check out the lennart blog post simply easier!
13:53:32 <john__> Guest86700, tons, what do you want
13:54:13 <derek_c> Hello! I've compiled my Haskell program and when I run it, it prints this line and terminates: "pagerank: <<loop>>"
13:54:18 <john__> Guest86700, tons, I have been working on a functional compiler for 4 years
13:54:20 <derek_c> pagerank is my program's name
13:54:29 <derek_c> does that mean there is an infinite loop somewhere?
13:54:46 <john__> Guest86700, would you like me to give you my reading list
13:55:01 <Guest86700> john__: I'm just trying to get an overview of the field of design, and I'd really appreciate a list like that, thanks
13:55:24 <Guest86700> derek_c: You're right, ghc has detected a runtime infinite loop somewhere in your code
13:55:35 <ciaranm> Guest86700: look at everything brendan eich ever did, and do the opposite. can't fail.
13:57:23 <tromp__> doing the opposite of Rasmus Lerdorf may prove more fruitful
13:57:39 <ciaranm> lerdorf doesn't understand enough to get things wrong
13:57:46 <derek_c> this is very weird... so what I found is that whenever I try to "show" a Data.Map, the program hangs in a infinite loop
13:57:49 <ciaranm> the opposite of PHP is still a horrible mess
13:57:50 <quchen> derek_c: The minimal example for generating a <<loop>> is "main = let x = x in x". Your program basically does a complicated version of that.
13:57:59 <c_wraith> derek_c: specifically, it's an infinite loop that the runtime can detect.  That means it's one where evaluating an expression depends on having evaluated that expression
13:58:13 <c_wraith> derek_c: that means you probably have an infinite loop somewhere in one of the values in the map
13:58:17 <quchen> derek_c: Maybe paste the source to hpaste.org?
13:58:39 <Cale> john__: The thing about "Haskell Road" is that it's almost too much of a compromise. If you didn't know much mathematics or much Haskell and you weren't specifically out to learn one or the other as quickly as possible, then it would be okay.
13:58:57 <john__> I can't find it. still looking
13:59:03 <tromp__> javascript is one layer away from a decent programming language (coffeescript). php is .... hopeless
13:59:27 <hpaste> “Anonymous Coward” pasted “Pagerank” at http://hpaste.org/86411
13:59:53 <Cale> john__: But if you already know a small amount of Haskell, the Haskell part will be boring -- it doesn't get terribly far beyond the very basics as far as describing the language goes if I recall.
13:59:55 <derek_c> thanks for you guys' help! this is my paste
14:00:07 <derek_c> lol didn't know it will be posted to this channel automatically
14:01:05 <c_wraith> derek_c: wow. That's quite a lot of unnecessary nesting. You know a single let expression can contain multiple bindings?
14:01:26 <armlesshobo> is it better to use parseFromFile than to read a each line and run a parser on it?
14:01:42 <c_wraith> derek_c: and multiple bindings in a single let expression can refer to each other
14:01:55 <h4199> How could PHP have been anything than what it is when the writer's attitude is summed thusly: I don't know how to stop it, there was never any intent to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way.
14:02:13 <quchen> Maybe take the PHP rant to #haskell-blah?
14:02:22 <john__> Guest86700, I complied the list in bibtex at http://codepad.org/TlnEEBz0
14:02:27 <derek_c> c_wraith: oh I actually didn't know that
14:02:37 <derek_c> c_wraith: I didn't know they could refer to each other
14:02:55 <c_wraith> derek_c: it's a handy thing to know about. :)
14:03:00 <derek_c> it should be fine to do something like "let x = f x", right?
14:03:01 <Guest86700> john__: thank you
14:03:17 <c_wraith> derek_c: yes, though it could be mutually recursive bindings
14:03:26 <c_wraith> derek_c: like a = b ; b = a
14:03:44 <quchen> > let x = 1:y; y = 2:x in take 10 x -- derek_c
14:03:46 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
14:03:53 <c_wraith> Or more complex combinations of the two
14:03:56 <john__> Guest86700, There shoud be 26 books in that list
14:04:32 <john__> Guest86700, you got the first 6
14:04:35 * hackagebot Strafunski-Sdf2Haskell 1.0.0.1 - Converts SDF to Haskell  http://hackage.haskell.org/package/Strafunski-Sdf2Haskell-1.0.0.1 (JamesKoppel)
14:04:36 <derek_c> c_wraith: I see. thanks :D
14:04:38 * hackagebot Strafunski-ATermLib 1.6.0.2 - An abstract data type designed for the exchange of tree-like data structures  http://hackage.haskell.org/package/Strafunski-ATermLib-1.6.0.2 (JamesKoppel)
14:04:54 <otters> :t let x = 1:y; y = 2:x in x
14:04:56 <lambdabot> Num a => [a]
14:04:58 <supki> > let f = (1:) in let x = f x in x
14:05:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:05:57 <quchen> derek_c: Also, if you have functions in a "where" clause that could be moved to the top level, do that. For example, your "go" function seems like it doesn't depend on the rest of the code.
14:06:32 <derek_c> quchen: right... I'm not sure why moving it to top-level would be better though
14:06:34 <quchen> derek_c: Also, the definition of "go" shadows multiple variables of the outer scope (i.e. it redefines its own "iEdges" etc.)
14:07:06 <Guest86700> What's your guys' opinion on let vs where in functions
14:07:49 <Shaladdle> Is there a difference besides style?
14:07:53 <derek_c> quchen: right. in that particular instance, it's my intend to shadow them
14:07:53 <quchen> Guest86700: There's a difference between the two. "where" is a special construct you can place at the end of a function, whereas "let ... in" is an expression similar to how "1 + 3" is an expression.
14:07:53 <Cale> There is
14:08:02 <Cale> 'where' scopes over multiple guards
14:08:02 <john__> Guest86700, heres the lot http://codepad.org/47J5q5n1
14:08:09 <Cale> and is part of the syntax of declarations
14:08:10 <Guest86700> john__: thanks
14:08:19 <Shaladdle> cool, good to know
14:08:23 <Cale> 'let' is an expression form
14:08:24 <quchen> derek_c: Shadowing is usually not a very good idea - it's very hard to track where the variables come from.
14:08:40 <derek_c> quchen: that's true. I have noticed that :P
14:08:59 <quchen> derek_c: Compiling with -Wall will even tell you about shadowed variables.
14:09:00 <derek_c> I still haven't found where the infinite loop is...
14:09:27 <quchen> derek_c: I would bet it becomes more obvious when you divide your giant function into more small pieces :-)
14:09:35 * hackagebot commsec-keyexchange 0.1 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.1 (ThomasDuBuisson)
14:10:15 <derek_c> quchen: true. I will try :D
14:10:17 <derek_c> thanks!
14:10:18 <quchen> The other thing about having many small options is that it's much easier to pin down issues. In the current code, I have trouble keeping track of what scope everything is in, there's no way I could find the loop in there.
14:10:49 <quchen> As a rule of thumb, try using only one "where" clause, two in rare special cases maybe. 3 is very likely too many of them.
14:11:36 <donri> i recommend two where's in instance declarations ;)
14:12:43 <dmwit> It's pretty rare that I prefer let to where.
14:12:59 <donri> let is nice in do notation ;)
14:13:14 <derek_c> quchen: I see.
14:14:19 <quchen> derek_c: And in general, stay under 80 characters per line.
14:14:32 <bobry> can someone explain to me how integer-gmp is compiled?
14:15:01 <bobry> there's this 'gmp-wrappers.cmm' file in 'cbits/' which isn't mentioned in 'integer-gmp.cabal'
14:15:05 <quchen> The reason isn't "but my grandma's terminal cannot display more", it's a matter of readability. Also note that many people have multiple windows next to each other (editor, GHCi). Horizontal scrolling is evil.
14:15:21 <derek_c> quchen: I think I found it!
14:15:25 <derek_c> quchen: line 57
14:15:36 <quchen> For the same reason, there's a similar rule in typography. That reason is why newspapers don't print all the way from left to right :-)
14:15:54 <hpc> i am confused by this: http://stackoverflow.com/questions/16115815/ackermann-very-inefficient-with-haskell-ghc
14:16:06 <hpc> how does one compute the ackermann function in constant space?
14:16:09 <Cale> john__: Oh, you're trying to understand surreal numbers?
14:16:32 <john__> Guest86700, heres the lo thttp://codepad.org/HXFa5Wrw
14:16:40 <merijn> quchen: To be precise, humans read most comfortable at line widths of approximately 66-70 characters
14:16:47 <john__> Cale, Ys I am
14:16:51 <quchen> derek_c: I look at line 57 and I really don't feel like reading it.
14:17:08 <quchen> merijn: Right. The exact "typography rule of thumb" varies from region to region, but it's usually in that range.
14:17:16 <derek_c> quchen: so after I changed "let iEdges" to "let iiEdges", all is well
14:17:36 <john__> No It appears my downloading capabillity ha been dwindeling a bit
14:17:39 <derek_c> quchen: seems like I'm using iEdges in the binding itself
14:17:51 <john__> But It seems file now
14:17:52 <quchen> derek_c: Your program compiles now. That's great, but doesn't mean "all is well". Refactor that a bit until you can read the whole thing! :-)
14:18:16 <derek_c> quchen: right it's still not producing right output :P
14:18:23 <john__> refactoring is all sob
14:18:32 <quchen> derek_c: As someone who didn't write that code I have no idea what "iEdges" even means.
14:18:32 <Cale> john__: anything in particular about them? Their construction is sort of a cross between the von Neumann definition of the ordinal numbers, and the original sort of Dedekind cuts (with both an upper and lower set, rather than just the downward-closed one)
14:18:42 <merijn> quchen: Well, it mostly varies with font size/character width
14:18:49 <john__> just rewrite it all over again
14:18:58 <quchen> merijn: Wait, there's another font besides Computer Modern?
14:19:02 <merijn> quchen: Incidentally, this why anyone shrinking the default LaTeX margins should be flogged :p
14:19:14 <Cale> (Dedekind cuts defining the reals)
14:19:24 <john__> Cale, What you are seeingif bibtex
14:19:33 <merijn> quchen: Hoefler Text and some others are pretty nice
14:19:51 <Cale> ?
14:19:54 <quchen> Let's take this to #blah, merijn
14:19:58 <john__> 'bibtex
14:20:10 <derek_c> quchen: right so I had this discovery: this function causes infinite loop: "foo x = let x = x + 1 in x"
14:20:15 * hpc has a question about half a page up
14:20:23 <hpc> about ackermann
14:20:25 <john__> 'bibtex, I'M assuming you mean http://codepad.org/HXFa5Wrw
14:20:25 <derek_c> so when you do foo 3
14:20:30 <derek_c> you might expect it to return 4
14:20:36 <derek_c> but it actually is an infinite loop
14:20:57 <derek_c> because in the binding, "x + 1" actually uses the x in "let x"
14:21:06 <derek_c> and this was exactly the problem with my code
14:21:41 <quchen> Yeah, but that's a feature that's much more frequently awesome than annoying.
14:21:51 <quchen> I got trapped by it as well once though :-)
14:22:04 <Cale> hpc: One generally does not compute the Ackermann function in constant space. Just recording the numbers will consume a great deal of space as it is.
14:22:26 <hpc> ignoring the size of the numbers ;)
14:23:29 <merijn> derek_c: The x on the right hand of "let x = x +1" refers to the x on the left hand of that :p
14:23:44 <derek_c> merijn: right yeah that's what I just found
14:23:46 <merijn> derek_c: Oh, wait, you already figured that out :p
14:24:24 <john__> 'bibtex, Now you understand what a phenomenal job I am doing?
14:25:45 <john__> 'bibtex, Go ahead try for yourself, but you have your job cut out for yo!.
14:26:39 <john__> It took me 4 years to get this far.
14:27:34 <h4199> john__: Those are the books you have read in the last 4 years?
14:27:59 <john__> Does anyone else have any problems with perseemingly endless research
14:28:18 <john__> h4199, yes
14:29:50 <john__> h4199: EXCEPT THERE ARE MORE. sAY ON LINUX
14:30:38 <john__> Just this week a 670 page book on wireless networks
14:31:01 <tcrayford> Is there a good package that implements a fast, pure sorted set in haskell?
14:31:14 <c_wraith> like..  containers?
14:31:25 <Peaker> tcrayford, The standard Data.Set?
14:31:29 <john__> fast nd pure, no
14:31:32 <Peaker> I don't know if it is fast..
14:31:36 <tcrayford> Is that sorted?
14:31:41 <Peaker> Yeah
14:31:41 <c_wraith> definitely sorted
14:31:57 <c_wraith> There wouldn't be Ord constraints all over its type signatures if it wasn't sorted
14:32:05 <john__> you don't want pure for an array
14:32:20 <john__> still interested'
14:32:24 <Peaker> c_wraith, Ord is necessary but not sufficient for it to be sorted.. it could conceivably do something that doesn't make it sorted
14:32:28 <dmwit> What does "sorted set" mean?
14:32:44 <john__> He means sequence
14:33:01 <john__> an ordered sequence
14:33:06 <dmwit> If that's what he means, Data.Set isn't that. But I'm not so confident he means that.
14:33:15 <Cale> hpc: It seems doubtful to me that the Ackermann function is computable in iterated exponential space, but I'm not sure how to prove that.
14:33:21 <tcrayford> With uniqueness, without calling nub or whatever on every insertion.
14:33:22 <c_wraith> Peaker: could be, but if it was it'd be intentionally obtuse
14:33:42 <john__> Uniqueness is a waste of time
14:33:45 <h4199> john__: I am not sure that I could absorb a 670 page technical book in a week, but your reading list would probably be better discussed in #haskell-blah.
14:33:47 <dmwit> What operation do you expect on a sorted set that you don't expect on any old set?
14:34:10 <john__> You have ben spending too much time on math
14:34:27 <dmwit> I am just trying to understand the question.
14:34:32 <john__> SAequence is the order of the day in computers
14:35:01 <dmwit> Why don't you let tcrayford say what he wants instead of trying to guess for him?
14:35:14 <tcrayford> dmwit: I'd like to be able to do take/drop specifically. Those make sense if your set keeps stuff sorted internally.
14:35:20 <h4199> He can choose: http://hackage.haskell.org/package/containers-0.5.0.0
14:35:22 <john__> h4199, perhaps, but now you have it
14:35:36 <Cale> tcrayford: Well, Set isn't a list internally
14:35:48 <tcrayford> Of course :)
14:35:48 <dmwit> tcrayford: Okay. Data.Set offers a partition function, but it won't use the ordering to speed that up.
14:35:50 <Cale> tcrayford: It's a balanced binary tree of some description
14:35:57 <dmwit> tcrayford: You might prefer to use a finger tree or a plain old sorted list for that.
14:36:23 <john__> h4199, I read an average of 200 pages in one day son.
14:36:27 <dmwit> ?hackage data-ordlist
14:36:28 <lambdabot> http://hackage.haskell.org/package/data-ordlist
14:37:26 <john__> h4199, And that is in all fields. CS beeing about 50%
14:37:29 <dmwit> tcrayford: For finger trees, the metric you would want would be (I guess) the product monoid of Max and Sum.
14:37:47 <dmwit> Or perhaps Sum and Max. =P
14:38:00 <john__> what is finger trees?
14:38:08 <h4199> john__: impressive, but we have strayed far afield from talk of haskell
14:38:34 <john__> then shut up
14:38:44 <h4199> http://en.wikipedia.org/wiki/Finger_tree
14:38:48 <Peaker> john__, Trees where every node data has the mconcat of its children datas'
14:38:53 <dmwit> tcrayford: Oh, also, Data.Set has split. So TIL.
14:39:06 <Cale> john__: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
14:39:18 <dmwit> tcrayford: (In case your "take" and "drop" are really "takeWhile . (<)" and "dropWhile . (<)". =)
14:39:44 <scooty-puff> how does a sum of unpacked STRefs (so, MutVar#s) compare to a MutableArray#?
14:40:37 <dmwit> STRefs generally point at boxed things, right? Doesn't unpacking an STRef just unbox the ref, not the thing inside?
14:40:46 <dmwit> I guess I don't know enough to answer, really, so I'll shut up.
14:40:49 <john__> explain this: They have since been used in the Haskell core libraries (in the implementation of Data.Sequence), and an implementation in OCaml exists[1] which was derived from a proven-correct Coq specification;[2] and a C# implementation of finger trees was published in 2008; the Yi text editor specializes finger trees to finger strings for efficient storage of buffer text. Finger trees can be implemented with or without[3]lazy evaluation, b
14:40:50 <john__> ut laziness allows for simpler implementations.
14:41:08 <john__> from wikipedia
14:41:17 <dmwit> What about that is unclear?
14:41:25 <h4199> the paper goes into more detail, what do you want to know?
14:41:26 * gwern recognizes an old wikipedia article of his. good times.
14:41:45 <john__> wherse dit it originate?
14:41:51 <tcrayford> dmwit: with Data.Set it's more like "attempt to grab element 1000, then split at that element". That cant be pure though, because Data.Set.elem calls error on out of bound stuff.
14:42:08 <allenj12> dmwit: can you take a look at my rewrite of the problem you help me with earlier?
14:42:10 <john__> where did it originate?
14:42:13 <dmwit> tcrayford: Data.Set has a free "size" operation.
14:42:17 <sw2wolf> Anybody uses emacs here ? which email clients in emacs do you prefer to use ?
14:42:27 <scooty-puff> for reading from the MutableArray#, i assume its get array, offset, get element, while for the sum of unpacked MutVar#s, its get sum, offset, get MutVar, get element
14:42:31 <Clint> sw2wolf: notmuch
14:42:42 <tcrayford> dmwit: Yeah. That's about as good as I'll get then.
14:42:46 <john__> sw2wolf, yes definitely. The prob
14:43:22 <sw2wolf> john__: what's prob ?
14:43:23 <Cale> john__: did you see my link?
14:43:23 <dmwit> allenj12: Just ask the room. If I'm around, have time, and know a good answer, I'll say so, same as with everybody else's questions.
14:43:32 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
14:43:40 <Cale> ^^ the original paper on finger trees
14:44:10 <john__> Look If you can't find any Emacs experts here Then you might as well lookin Hell.
14:44:10 <__xc> > 2==2 and 2<10
14:44:11 <john__> Look If you can't find any Emacs experts here Then you might as well lookin Hell.
14:44:12 <lambdabot>   Precedence parsing error
14:44:12 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
14:44:23 <__xc> > (2==2) and (2<10)
14:44:25 <lambdabot>   The function `2 GHC.Classes.== 2' is applied to two arguments,
14:44:25 <lambdabot>  but its typ...
14:44:26 <dmwit> > 2 == 2 && 2 < 10
14:44:28 <lambdabot>   True
14:44:32 <c_wraith> I'm sad Data.Sequence doesn't expose the whole interface from that paper.
14:44:33 <h4199>  L. J. Guibas, E. M. McCreight, M. F. Plass and J. R. Roberts. A new representation for linear lists, Proceedings of the 9th Annual ACM Symp. on Theory of computing, 1977, 49
14:44:36 <__xc> ok
14:44:42 <dmwit> c_wraith: There's another library that does.
14:44:44 <h4199> I think that was the first
14:45:03 <john__> > prime 13
14:45:04 <Cale> c_wraith: http://hackage.haskell.org/package/fingertree
14:45:05 <lambdabot>   Not in scope: `prime'
14:45:05 <dmwit> c_wraith: ?hackage fingertree
14:46:13 <__xc> dmwit, just bugged me because erlang need parenthesis, weird fixity for their 'and'
14:46:29 <__xc> @hoogle isprime
14:46:30 <lambdabot> No results found
14:46:34 <john__> They have since been used in the Haskell core libraries (in the implementation of Data.Sequence), and an implementation in OCaml exists[1] which was derived from a proven-correct Coq specification;[2] and a C# implementation of finger trees was published in 2008; the Yi text editor specializes finger trees to finger strings for efficient storage of buffer text. Finger trees can be implemented with or without[3]lazy evaluation, but laziness al
14:46:35 <john__> lows for simpler implementations.
14:46:37 <dmwit> > and [2 == 2, 2 && 10]
14:46:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
14:46:38 <lambdabot>    arising from the literal `2...
14:46:52 <dmwit> um
14:46:55 <dmwit> > and [2 == 2, 2 < 10]
14:46:56 <lambdabot>   True
14:46:57 <hpaste> allenj12 pasted “Parsec ” at http://hpaste.org/86415
14:47:15 <allenj12> anyone help with those errors?
14:47:17 <john__> A finger tree is a purely functional data structure used in efficiently implementing other functional data structures. A finger tree gives amortized constant time access to the "fingers" (leaves) of the tree, where data is stored, and the internal nodes are labeled in some way as to provide the functionality of the particular data structure being implemented. For example, a priority queue can be implemented by labeling the internal nodes by t
14:47:17 <john__> he minimum priority of its children in the tree, or an indexed list/array can be implemented with a labeling of nodes by the count of the leaves in their children. Finger trees can provide amortized O(1) cons, reversing, cdr, O(log n) append and split; and can be adapted to be indexed or ordered sequences.
14:47:20 <__xc> > and [true..]
14:47:22 <lambdabot>   Not in scope: `true'
14:47:29 <__xc> > and [True..]
14:47:31 <lambdabot>   <hint>:1:12: parse error on input `]'
14:47:35 <dmwit> allenj12: uh, did you mean "return answer"?
14:47:45 <Cale> allenj12: letter and space both produce a Char result, yeah?
14:47:45 <dmwit> > and [True ..]
14:47:47 <lambdabot>   True
14:48:07 <dmwit> __xc: True.. is the (.) operator from the module named True
14:48:08 <dmwit> =P
14:48:09 <__xc>  > and [True,True,True, False ..]
14:48:13 <Cale> allenj12: but parenthesisisedStatement (sic) produces a String
14:48:20 <__xc> > and [True,True,True, False ..]
14:48:22 <lambdabot>   <hint>:1:28: parse error on input `..'
14:48:23 <allenj12> cale: it seems so but how would i get rid of thise effectively?
14:48:30 <dmwit> > and ([True, True, True] ++ [False, False ..])
14:48:32 <lambdabot>   False
14:48:41 <allenj12> dmwit: where is return answer?
14:48:46 <__xc> hehe I suck to,igh
14:48:54 <hpc> bug: it should be parenthesisisesisessisesStatement
14:49:00 <dmwit> allenj12: Instead of "return parenthesisisedStatement" [sic].
14:49:15 <allenj12> dmwit: ! OH
14:49:31 <mm_freak> __xc: [True ..] is a finite list
14:49:40 <Cale> allenj12: You also probably want is many (letter <|> space) >> parenthesisisisisisisisedStatement
14:49:42 <mm_freak> > [True ..]
14:49:43 <lambdabot>   [True]
14:49:50 <Cale> -is
14:49:59 <mm_freak> __xc: you probably meant to use 'repeat True'
14:50:02 <derek_c> what other flags can you use to optimize compilation, other than -O2?
14:50:03 <mm_freak> > and (repeat True)
14:50:07 <allenj12> cale: lol kk lemme see
14:50:08 <lambdabot>   mueval: ExitFailure 1
14:50:08 <lambdabot>  mueval: Prelude.undefined
14:50:12 <derek_c> -O2 is all I know
14:50:20 <LoremIpsum_> > take 3 [True ..]
14:50:22 <lambdabot>   [True]
14:50:23 <mm_freak> derek_c: -funbox-strict-fields is commonly suggested and uncommonly used
14:50:24 <dmwit> Is it weird that I can actually read "parenthesisisisisisedStatement" more easily than "parenthesisisedStatement"?
14:50:48 <allenj12> cale: it builds just lemme see if it works!
14:50:55 <mm_freak> derek_c: the reason is that you don't actually need this flag, you can do it in-language
14:51:42 <derek_c> mm_freak: I see. I will check it out.  Thanks!
14:51:45 <Peaker> Does {-# INLINE #-} imply {-# SPECIALIZE #-} for every type it's actually used with?
14:52:13 <Peaker> or rather, is the only use of INLINE+SPECIALIZE for cases the INLINE will not work?
14:52:44 <derek_c> exit
14:52:47 <derek_c> lol sorry
14:53:35 <mm_freak> Peaker: i wouldn't count on INLINE implying SPECIALiZE
14:53:47 <mm_freak> s/SPECi/SPECI/
14:53:54 <mm_freak> hmm
14:54:01 <mm_freak> s/LiZE/LIZE/
14:54:36 * hackagebot bitset 1.4.1 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.1 (SergeiLebedev)
14:55:17 <Peaker> I wonder how a C++ template style strategy for compiling Haskell-polymorphic code, where basically everything is always unboxed, and code is duplicated to handle all the types involved would work
14:55:26 <allenj12> cale: so when i run that with an example like "((abc)aaaa)" i get unexpected ')' am i missing something?
14:55:40 <Peaker> It might imply a lot less pointer chasing and possibly less allocations, though larger code
14:56:12 <hpc> it would make functions that are truly polymorphic have horrifying implementations
14:56:22 <Peaker> why horrifying?
14:56:25 <hpaste> Ankhers pasted “Applicative IO” at http://hpaste.org/86417
14:56:35 <hpc> and it's basically beta reduction on the typeclass dictionaries anyway
14:56:40 <__xc> > head []
14:56:41 <lambdabot>   *Exception: Prelude.head: empty list
14:56:45 <Ankhers> Can anyone tell me why the second line does not work?
14:56:50 <__xc> > tail []
14:56:51 <lambdabot>   *Exception: Prelude.tail: empty list
14:56:56 <Peaker> My intuition tells me that boxing by default is a bad idea, but I'd love to be convinced otherwise
14:57:17 <Peaker> Boxing is basically a technique to reduce the code footprint at the expense of things that seem more important
14:57:31 <__xc> > tail [1]
14:57:33 <lambdabot>   []
14:57:46 <__xc> ^ damn why not returning this on tail []
14:57:55 <Cale> allenj12: oh, you might want to skip letters and spaces *after* parenthesisedStatement as well
14:58:00 <Peaker> __xc, head/tail are like fields of the (:) constructor.. the [] constructor doesn't have them
14:58:02 <thoughtpolice> INLINE doesn't really SPECIALIZE. what SPECIALIZE does is generate a rule from the general version -> specialized version, that the optimizer then uses during simplifying. SPECIALIZE+INLINE is for the case where you want a kind of 'type based unrolling' on code
14:58:22 <__xc> Peaker, k
14:58:28 <dmwit> > drop 1 []
14:58:29 <lambdabot>   []
14:58:30 <dmwit> __xc: ^^
14:58:33 <__xc> right
14:58:35 <Peaker> thoughtpolice, but if you inline, surely it gets specialized because the code is copied to a context with more specific types?
14:58:39 <hpc> Peaker: part of the boxing is thunking
14:58:49 <hpc> you can only unbox when you know it will be strict
14:58:59 <allenj12> cale: so parenthisisedStatement <|> letter....
14:59:00 <__xc> > take 1 []
14:59:01 <Peaker> hpc, Sure, but if you can spare a bit in your unboxed representation, you could represent a thunk in the unboxed thing
14:59:02 <lambdabot>   []
14:59:05 <allenj12> also
14:59:31 <Peaker> hpc, so it might make sense to have Word32# (unboxed) but Word31(boxed)
14:59:40 <Cale> allenj12: x <|> y means parse *either* x *or* y, but not both
14:59:45 <Peaker> or rather s/(boxed)/(lazy)
14:59:46 <hpc> i'd rather let the optimizer take care of it
14:59:51 <thoughtpolice> Peaker: correct, but it's still not exactly analagous to SPECIALIZE, due to the fact there's no rule. just INLINE alone will not allow you to do what SPECIALIZE+INLINE can
14:59:53 <mm_freak> Peaker: simple, it probably wouldn't work
14:59:54 <dmwit> Peaker: Does C++ doe polymorphic recursion?
14:59:55 <hpc> and if it matters later, use strict data
15:00:09 <allenj12> cale: so skipmany?
15:00:21 <mm_freak> Peaker: a C++-like template system doesn't support things like RankNTypes
15:00:47 <Peaker> dmwit, I'm not sure, perhaps boxing can be used to support corner cases like that, and mm_freak when RankN types is used?
15:00:56 <thoughtpolice> Peaker: most specifically, SPECIALIZE+INLINE applies the inline to the specificed version, which you get *after* the rule applies. INLINE is also more special because with SPECIALIZE, GHC will try to inline, even if the definition is recursive
15:01:00 <thoughtpolice> which is another big difference
15:01:11 <Cale> allenj12: though perhaps you want many ((letter <|> space) >> return "") <|> parenthesisedStatement)
15:01:13 <Peaker> but the vast majority of code isn't made of polymorphic recursions and RankNTypes
15:01:35 <Peaker> thoughtpolice, via unrolling N iterations or such?
15:01:42 <allenj12> cale: hmmm makes sense
15:02:22 <mm_freak> Peaker: let me put it this way:  a template system wouldn't be sufficient to compile haskell's base library
15:02:23 <Peaker> hpc, it would be nice to be able to have lazy Word31/Int31 that were also unboxed...
15:02:51 <Peaker> mm_freak, sure, I just said (and meant)  C++ template style strategy -- it doesn't have to be exactly like C++ templates
15:03:12 <mm_freak> Peaker: well, what's the difference between the template system and "template style strategy"?
15:03:31 <Peaker> mm_freak, unbox by default, vs. no boxing at all
15:03:51 <Eduard_Munteanu> Peaker: why 31?
15:03:55 <Cale> allenj12: ah, you'll want to fmap concat the whole thing then
15:04:03 <Peaker> Eduard_Munteanu, to reserve a bit for distinguishing an Int value from a thunk
15:04:04 <Cale> allenj12: because you'll be getting a list of Strings then
15:04:15 <mm_freak> Peaker: think about it:  'id' requires either boxing or replication for every type
15:04:20 <Eduard_Munteanu> Peaker: um... I thought you said unboxed.
15:04:29 <Peaker> mm_freak, in practice, id is compiled to nothing in most cases
15:04:40 <Eduard_Munteanu> Peaker: or do you want to unbox boxed 31s and keep the same semantics?
15:04:46 <allenj12> cale: kk
15:04:48 <mm_freak> Peaker: that's not the point…  consider foldr
15:04:53 <Peaker> Eduard_Munteanu, yes, laziness does not necessate boxing, just stealing a bit and having at least 29/30 for the thunk ptr
15:04:58 <mm_freak> Peaker: or foldl or sum or …
15:05:06 <Peaker> mm_freak, yes, it will be specialized/replicated for every type
15:05:08 <mm_freak> Peaker: basically any value with type variables
15:05:10 <Eduard_Munteanu> Hm.
15:05:23 <Peaker> mm_freak, and that has disadvantages -- but also advantages.. I think GHC will try to inline those in every case by default anyway?
15:05:43 <Eduard_Munteanu> Peaker: still, arithmetic is strict
15:05:58 <Cale> allenj12: oh, you might not want to >> return "" either
15:06:01 <mm_freak> Peaker: as a technical problem it would lead to code explosion, because while GHC can choose to specialize, C++ /must/ specialize
15:06:01 <Peaker> Eduard_Munteanu, Sure, but computing an Int might trigger non-termination or expensive computations
15:06:13 <Cale> allenj12: instead, you may want  fmap (:[])
15:06:40 <hpc> the monkey operator
15:06:45 <Peaker> mm_freak, C++ might have a code explosion issue, but I think it will still beat GHC if you compare the same naive algorithms (without special care to unbox everything in ghc)
15:07:03 <mm_freak> Peaker: second technical problem, did you notice that almost the whole C++ STL is written as header files?  there isn't really an ST-"library" in the sense of a compiled archive or something
15:07:05 <Peaker> i.e:  code explosion is a lesser performance problem than boxing
15:07:21 <Eduard_Munteanu> hpc: robot monkey!
15:07:24 <mm_freak> Peaker: you don't actually /link/ against code that implements C++'s 'vector'
15:07:31 <mm_freak> because those are templates
15:07:32 <Peaker> mm_freak, well, that's just C++ sucking. It could compile to an intermediate representation
15:08:10 <Ankhers> Can anyone explain to me why the second line doesn't work? http://hpaste.org/86417
15:08:25 <Peaker> mm_freak, GHC .hi files are sort of the same as the C++ header files, except less stupid
15:08:26 <mm_freak> Peaker: that intermediate representation would look like what?  bytecode?  this isn't just C++ suckyness, it's a fundamental problem of templates being a macro system…  and the root of that problem is that you don't have boxing
15:08:55 <Peaker> mm_freak, The .hi files GHC has are enough, you don't need to store source form for unboxing
15:09:03 <Eduard_Munteanu> Ankhers: that doesn't look like valid sectioning
15:09:13 <Eduard_Munteanu> :t (++ ", " ++)
15:09:15 <lambdabot> parse error on input `)'
15:09:25 <Peaker> mm_freak, I don't want a "macro system" -- I want unboxing :)
15:09:34 <Eduard_Munteanu> :t ((++ ", ") ++)
15:09:35 <lambdabot> ([Char] -> [Char]) -> [Char] -> [Char]
15:09:39 <mm_freak> Peaker: but you can't compile…  GHC's .hi files are really only needed for types…  there is no technical requirement to have anything but types in there
15:09:51 <Peaker> mm_freak, how does GHC do cross-module inlining?
15:09:55 <allenj12> cale: ahhh yes kk
15:09:58 <Eduard_Munteanu> But interesting, I wonder if you could theoretically section that.
15:10:00 <mm_freak> Peaker: you didn't understand
15:10:13 <mm_freak> Peaker: GHC does include some intermediate form, but that one is only used for optimizing
15:10:18 <Ankhers> Eduard_Munteanu: Awesome, thanks.
15:10:35 <Peaker> mm_freak, optimizing is part of the build process
15:11:02 <Eduard_Munteanu> Ankhers: actually ignore the ((++ ", ") ++), it's not what you mean
15:11:06 <Peaker> mm_freak, GHC could do the unboxing with the .hi files (perhaps more information is needed in the .hi than they have now, I'm not sure)
15:11:09 <Clint> :t (. (", " ++)) . (++)
15:11:10 <lambdabot> [Char] -> [Char] -> [Char]
15:15:11 <mm_freak> Peaker: again that's not the point
15:15:41 <oio> mirror for Haskell platform download getting ridiculously slow speeds?
15:15:45 <mm_freak> Peaker: all a haskell compiler /needs/ in an .hi file is types
15:15:59 <mm_freak> Peaker: everything else, including the intermediate representation is optional
15:16:28 <mm_freak> a C++ compiler absolutely needs some source form of the templates
15:16:40 <mm_freak> be it intermediate bytecode or the source code itself
15:16:42 <Peaker> mm_freak, what's the problem with needing that extra stuff?
15:17:02 <mm_freak> Peaker: nothing, but you would severely limit the type system
15:17:09 <Peaker> Also, only the unboxing needs it, which can be considered an optimization (so you could have unboxing-by-default in -O2 or such)
15:17:16 <john__> How much performance improvement an I expect by compiling via C++?
15:17:27 <mm_freak> Peaker: in particular you couldn't implement GADTs, RankNTypes or anything else that depends on boxes
15:17:30 <Peaker> It wouldn't limit the type system, because it would resort to boxing if the type cannot be specialized (e.g: rankntypes)
15:17:49 <Peaker> the vast majority would be unboxed, and corner cases would be boxed
15:17:51 <mm_freak> Peaker: as a non-typing matter consider laziness
15:18:05 <mm_freak> Peaker: no, the vast majority would be boxed anyway
15:18:14 <mm_freak> main = a >> b
15:18:15 <mm_freak> boxed
15:18:23 <mm_freak> main = print [1..]
15:18:25 <mm_freak> list boxed
15:18:26 <Cale> john__: GHC can't do that.
15:18:44 <Peaker> mm_freak, laziness can be unboxed too, with a stolen bit
15:18:55 <Peaker> mm_freak, why would the list be boxed?
15:19:04 <mm_freak> Peaker: that's boxing
15:19:04 <Peaker> mm_freak, or (a>>b) for that matter?
15:19:13 <mm_freak> boxing doesn't mean that you have to have an actual memory box ;)
15:19:28 <Peaker> I am talking about the extra memory indirection incurred by boxing
15:19:48 <Cale> john__: At one point GHC compiled via C, which at no point produced anything which could be called working C code, but used the result of the C compiler and mangled the output into a runnable form.
15:20:11 <mm_freak> Peaker: you could optimize Int, Word and Char that way
15:20:20 <Cale> john__: But that's gone in favour of direct native code generation or LLVM.
15:20:34 <mm_freak> Peaker: but since GHC has strictness analysis i'm not sure whether there would be a real benefit
15:21:01 <h4199> Cale: Does ghc have a flag to output C-- anymore?
15:21:10 <mikeplus64> h4199: -ddump-cmm
15:21:18 <geekosaur> ...and note that this was done in large part because there wasn't a good way to optimize the generated code (C compilers do not optimize for Haskell, and the output... well, let's just say the postprocessor was called the evil mangler for a reason. And still wasn't very good)
15:21:21 <Peaker> mm_freak, Well, I'm talking about A) unboxing lazy values too, B) -funbox-strict-fields by default  C) Unboxing polymorphic data too
15:21:26 <jfischoff> preflex seen lykahb
15:21:29 <Cale> h4199: sure
15:21:31 <mikeplus64> c-- is still alive and well in ghc
15:21:31 <Peaker> mm_freak, especially due to A,C I think it would be a real benefit
15:21:34 <Cale> -ddump-cmm
15:22:07 <h4199> got it, misunderstood your comment
15:22:53 <mm_freak> Peaker: you can't really unbox lazy values in general…  you must know the exact memory representation to be able to unbox, so you could really only unbox strict fields and a careful selection of the base types like Int
15:23:01 <Cale> C-- is almost but not quite entirely unlike C or C++
15:23:07 <Peaker> mm_freak, but you do know the exact memory representation.. you're the compiler
15:23:44 <mm_freak> Peaker: i'm not saying there would be no benefit at all
15:23:57 <mm_freak> i'm saying that the benefit is probably very small and comes at a price:  code explosion
15:24:12 <mm_freak> unlike C++ almost the whole base library makes extensive use of polymorphism
15:24:22 <Peaker> mm_freak, e.g:  a lazy list can be unboxed to a representation like:  highest-bit in word means is-evaluated, and when it is evaluated, then the rest of the bits point at [] or at a (:)
15:24:31 <Peaker> mm_freak, but it does work with polymorphism
15:24:51 <geekosaur> Peaker, which requires that all the constructors be known. Meaning they must be exported. How do you propose to optimize e.g. Data.Map?
15:24:53 <Peaker> mm_freak, the benefit is very large IME of adding SPECIALIZE pragmas
15:25:06 <Peaker> geekosaur, exported to the optimizer, not to the user
15:25:49 <Peaker> mm_freak, specializing code to all the types its used in would be a nice benefit on its own, besides removing pointer-chasing, cache-missing allocation-thrashing boxes around everything :)
15:26:24 <geekosaur> I think, if that would be a gain, it would be done now (automatic SPECIALIZE)
15:26:34 <mm_freak> Peaker: i'm saying that unboxing everything by default would either resort to boxing all the time, or it would lead to code explosion…  basically you couldn't really use shared objects anymore, unless you accept the boxing fallback
15:26:34 <Peaker> geekosaur, why?
15:26:45 <Peaker> mm_freak, code explosion is not so bad
15:27:04 <mm_freak> Peaker: i'm talking about turning kilobytes into megabytes
15:27:27 <Peaker> mm_freak, which can easily be negligible compared to the gigabytes of data being twice or thrice as large
15:28:20 <geekosaur> I suspect you'll have to ask the ghc folks (see #ghc) for full details. but if there's enough information to process a SPECIALIZE pragma, there's enough to just specialize everything... one problem being that if it's polymorphic, it can apply to types that did not exist when the original was written, so it can't be specialized to those anyway without whole-program compilation (i.e. full source). In other words SPECIALIZE may not be what you thi
15:28:21 <geekosaur> nk it is...
15:28:39 <Peaker> a code explosion is still likely to have hot-spots for the types actually used frequently.. C++ template code does tend to have good performance, regardless of code explosion
15:28:54 <mm_freak> Peaker: at the beginning of when i was a gentoo user i compiled with -O3 -funroll-loops, etc., which led to comparatively large executables…  so large that the loading time actually made me step back from that decision
15:29:00 <Peaker> geekosaur, .hi files are enough, I don't think you need full-source
15:29:08 <geekosaur> nope
15:29:12 <Peaker> geekosaur, esp. since they already facilitate inlining
15:29:18 <geekosaur> so you don't know what SPECIALIZE is
15:29:19 <mm_freak> Peaker: now imagine this in haskell…  no boxing means:  you can't really use shared objects, so /everything/ needs to be loaded /every time/
15:29:26 <geekosaur> maybe you meant something else
15:29:41 <Peaker> mm_freak, loading executables should be an O(1) mmap with lazy-demand-loading.. but it isn't because of poor implementations of shared libraries
15:30:04 <geekosaur> hoo boy
15:30:05 <mm_freak> Peaker: no, loading executables is /always/ O(n) in any modern architecture
15:30:10 <geekosaur> ok, kid, go to school already
15:30:18 <Peaker> mm_freak, why would it not demand-load the executable via page faults?
15:30:18 <mm_freak> O(n) is actually quite optimizistic
15:30:22 <geekosaur> you just also proved you have no idea what the issues in shared objects are
15:30:34 <mm_freak> Peaker: because just putting the executable into memory is far from everything you need to do
15:30:40 <mm_freak> think of relocations, .bss, etc.
15:30:42 <Cale> I personally think that authors of each project are in the best position to be given control over the specific compiler invocations used to build their code.
15:30:43 <Peaker> geekosaur, I understand what SPECIALIZE is, perhaps you could be more specific on what your misunderstanding i?
15:30:52 <mm_freak> Cale++
15:30:55 <Peaker> mm_freak, I don't need to do relocations if I'm not linking
15:31:09 <geekosaur> no you don't, because SPECIALIZE generates specific code *in the original module*
15:31:21 <Peaker> mm_freak, the reason I need to do relocations *every time* I load an executable is exactly because of, as I said above, poor implementations of shared libraries
15:31:22 <geekosaur> not specific code for *users* of that module
15:31:22 <mm_freak> Peaker: because you know where the kernel is?
15:31:27 <Peaker> mm_freak, and .bss can point at demand-loaded zero pages
15:31:35 <geekosaur> it means that an extra copy of every function in the original module is generated, for specific types
15:31:41 <Peaker> mm_freak, executables are not linked against kernel symbols
15:31:56 <mm_freak> Peaker: so you need to link against the libc?
15:32:00 <mm_freak> ;)
15:32:05 <geekosaur> Peaker, people who believed that created COFF and Mach-O
15:32:08 <mm_freak> loading is O(n) at best
15:32:14 <Peaker> mm_freak, yes, that could be either statically linked, or linked in a smarter way than shared objects that do O(N) work at every exec loading
15:32:19 <geekosaur> ELF ditched it *for very, very good reasons*
15:32:44 <Peaker> geekosaur, I know that it means that an extra copy is made for specific types, and..?
15:32:45 <mm_freak> Peaker: also mmap doesn't get rid of the fact that the code is actually executed…  you're just moving the problem, not fixing it
15:32:52 <Peaker> geekosaur, what are the good reasons?
15:32:57 <geekosaur> hoo boy
15:33:00 <geekosaur> keep missing that point
15:33:06 <mm_freak> Peaker: finally we don't live in an ideal world
15:33:12 <geekosaur> maybe it's "original module" that you don't understand?
15:33:34 <Peaker> geekosaur, It seems the misunderstanding is more on your side...
15:33:36 <mm_freak> Peaker: in the world we actually live in ELF loading is turing-complete
15:33:37 <geekosaur> how do you do that on the fly for unknown types without the source to the original module?
15:33:42 <Peaker> geekosaur, but you could be more graceful about it :)
15:33:44 <geekosaur> Peaker, give up now
15:33:48 <geekosaur> really
15:34:01 <Peaker> mm_freak, that's not a good thing
15:34:13 <geekosaur> or maybe: since you know so much more than all the experts, you should show us that you do and show us your perfect system
15:34:18 <geekosaur> *write* it
15:34:45 <geekosaur> actual code that avoids the all the past mistakes will prove that you are not making all those mistakes all over again, which is what it sounds like you are doing
15:34:47 <mm_freak> Peaker: it's bad, but it's the way it is…  as far as i understand it in long mode you do actually need relocations no matter what you do
15:34:50 <Peaker> mm_freak, the code is actually executing, but likely not the whole of the code explosion is executing.. for most executables, code-coverage (especially with code explosion) will be small for any typical run
15:35:21 <Peaker> mm_freak, I think relocations can be done at e.g: install-time in a way that doesn't require O(N) work at each executable invocation.. made especially easier in 64-bit architectures
15:35:23 <mm_freak> Peaker: i understand your point, but your point simply doesn't apply to linux/windows/…
15:35:39 <Peaker> geekosaur, you keep mentioning these mistakes, appealing to authority.. but what are the mistakes?
15:35:40 <geekosaur> Peaker, congratulations, you have reinvented COFF / Mach-O
15:35:45 <geekosaur> reallt
15:35:48 <geekosaur> go look at them, please
15:35:54 <geekosaur> they exist now
15:36:04 <Peaker> geekosaur, You're claiming it's a mistake, but you won't say what the mistake is
15:36:30 <geekosaur> how many books must I read to you in channel, then, O expert?
15:36:49 <Peaker> geekosaur, it's not productive to say: "You're wrong. Go read a book". Just stay out of the discussion if that's what you're going to be saying.
15:36:50 <mm_freak> ok, relax everybody =)
15:37:25 <mm_freak> geekosaur: Peaker has a point, but his point is simply not applicable to any existing operating system except perhaps on some embedded devices
15:37:37 <geekosaur> for starters, that relocate at install time? turns out to require checking every *other* program that also uses the shared object. Again, this has been tried and this has been demonstrated to be necessary; if you know of a way to avoid it, the world is ewaiting to hear it and you need to write the code to show us
15:37:38 <Sausage865> Hey guys, say I have a list of films. They all have "Fans". What function would I write for returning the top five films in descending order: topFiveDesc :: Database -> Database
15:37:57 * Heffalump echos mm_freak's relax call
15:38:02 <Sausage865> Top Five Films being the top 5 films with the most fans.
15:38:57 <arbn> Sausage865: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:39:10 <parcs> Sausage865: use sortBy
15:39:16 <Peaker> geekosaur, Let's imagine each .so gets its own unique range in 64-bit space. Executables get put in a standard place in 64-bit space. Their symbols are relocated for the unique position of the .so's they use.  Why do I need to check other programs when installing a program or shared object and relocating?
15:39:18 <geekosaur> because people have been trying to find solutions to the problems with all the existing shared object systems for some 50 years now, and if you have an insight everyone else has missed, we need to *see* it.
15:39:18 <Heffalump> @type \f -> sortBy (compare `on` f)
15:39:19 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
15:39:30 <hpaste> Ontolog pasted “Trung” at http://hpaste.org/86420
15:39:40 <Ontolog> oops disregard that
15:40:50 <mm_freak> Peaker: that wouldn't work
15:41:03 <mm_freak> Peaker: executables often claim MUCH more memory than they actually use
15:41:14 <Peaker> mm_freak, 64-bit space is pretty large... :)
15:41:14 <mm_freak> some programs actually claim the whole address space
15:41:38 <Peaker> mm_freak, of course if they use .so's they already lost some of the address space anyway
15:41:39 <parcs> Sausage865: please speak here. i don't want to feel obligated to help you :P
15:41:47 <geekosaur> there's other issues too. like the kernel memory accounting gets much more complex (and the kernel's memory tables larger)
15:42:07 <geekosaur> also why are we discussing this in #haskell?
15:42:13 <Sausage865> topFiveDesc :: Database -> Database
15:42:15 <Sausage865> topFiveDesc films =
15:42:22 <arbn> Sausage865: No, I'm not going to do your homework for you...
15:42:41 <Peaker> also, you only need the *static* mappings to get static addresses, and you could over-commit all you want in your dynamic mmap calls (in the non-statically-reserved space)
15:42:49 <mm_freak> Peaker: the problem is that it is expected from a paging operating system to allow programs to claim arbitrarily many pages as long as they don't use all of them…  sort of like laziness in haskell =)
15:43:03 <mm_freak> so some programs go ahead and just claim everything
15:43:11 <h4199> Sausaage865: http://learnyouahaskell.com/modules#data-list
15:43:38 <Peaker> mm_freak, that shouldn't be a problem -- only symbols need to live in the static space so that the relocations don't need to be moved.. you could get more of the address-space for memory without symbols in it
15:44:14 <mm_freak> Peaker: i'm with geekosaur here…  you should try to implement this idea
15:44:23 <Peaker> I'm already implementing a big idea :)
15:44:52 <geekosaur> A great many people have tried and failed; talk means nothing in this space, show working code
15:45:51 <Peaker> geekosaur, I'm not sure how many are "great many".  ELF/COFF/PE and a few others are probably made by a few dozen people -- most of which were focusing on shipping something that works more than avoiding O(N) work at exec start
15:45:55 * cmccann informs mm_freak and geekosaur that $LONGSTANDING_CONJECTURE is clearly $TRUTH_VALUE and awaits their counter-arguments to this sensible idea
15:46:33 <geekosaur> Peaker, that's not an argument, it's a waffle. Show code.
15:46:54 <Peaker> geekosaur, I am -- for a different conjecture :) (Namely, that structural IDE's are better than text editing)
15:47:25 <geekosaur> there's another one people have been trying for years. Good luck
15:47:48 <jfischoff> which is pretty much the argument against functional programming
15:47:48 * geekosaur remembers when Alice was going to transform programming!!!
15:47:54 <Peaker> Thanks, we already have some cool stuff :)
15:48:06 <mm_freak> i'm not taking an extreme position here…  O(1) loading is possible in principle
15:48:09 <jfischoff> lamdu is cool
15:48:11 <mm_freak> it's not possible in linux or windows
15:48:19 <Peaker> jfischoff, :)
15:48:24 <Eduard_Munteanu> That overcommiting is kinda silly at times, might as well have malloc assume an allocation size of 1 petabyte. :P
15:48:34 * geekosaur wonders if the net even remembers that one...
15:48:41 <mm_freak> Eduard_Munteanu: that's what actually happens
15:48:51 <Peaker> geekosaur, alice seems more about graphical programming than about structural programming
15:49:05 <mm_freak> Eduard_Munteanu: write some C code that mallocs half of the address space…  it will work
15:49:06 <geekosaur> wrong alice, I think
15:49:14 <Peaker> geekosaur, which Alice are you referring to?
15:49:22 <geekosaur> "Alice, the Personal Pascal", which featured the first commercial structural IDE
15:49:24 <mm_freak> Eduard_Munteanu: at least in linux
15:49:24 <Eduard_Munteanu> mm_freak: I think I turned off overcommiting here, so no. :P
15:49:36 <Tene> mm_freak: depends on your overcommit kernel settings
15:49:54 <mm_freak> huh?  i don't think so, but let me look
15:49:57 <arbn> Isn't there also an Alice ML?
15:50:26 <Eduard_Munteanu> mm_freak: /proc/sys/vm/overcommit_memory
15:50:26 <Tene> mm_freak: sysctl vm.overcommit_memory
15:50:26 <mm_freak> you can configure how the kernel reacts to overcommitting, but i don't think you can turn it off…  and if you could, you would probably break quite a few applications
15:50:33 <geekosaur> there's a bunch of languages called Alice (and there is also a person named Alice Pascal, just to confound web searches :p )
15:50:46 <Tene> Yes, those applications are broken with strict overcommit.
15:50:56 <Eduard_Munteanu> mm_freak: not really a lot of applications
15:50:58 <mm_freak> Eduard_Munteanu,Tene: how to interpret that value?  it's set to 0 here
15:51:10 <Eduard_Munteanu> mm_freak: then you have it disabled I think
15:51:14 <Peaker> geekosaur, I'd love to see how their structural IDE looked like...
15:51:22 <mm_freak> Eduard_Munteanu: certainly not…  i haven't changed the default
15:51:42 <mm_freak> Eduard_Munteanu: and i know from experience that overcommitting is possible here ;)
15:51:53 <Tene> mm_freak: 0 is "best guess" estimation; 1 is always permit overcommit, 2 is never permit overcommit
15:52:06 <mm_freak> ok, let me try
15:52:07 <Tene> mm_freak: see Documentation/sysctl/vm.txt
15:52:46 <Eduard_Munteanu> I think 0 obeys the overcommit_ratio sysctl
15:52:55 <Tene> mm_freak: see also vm.overcommit_ratio; when vm.overcommit_memory is 2, the committed address space is restricted to swap + that ratio os physical RAM.
15:53:06 <geekosaur> but, well, people have been trying to make structural IDEs practical since at least the mid 1980s... another area where "show us the code" is the answer to any "I have a great idea!" because everyone's burned out over it
15:53:07 <Tene> Eduard_Munteanu: incorrect; check Documentation/sysctl/vm.txt
15:53:44 <Peaker> geekosaur, and showing the code we are :)
15:53:45 <Demos> why is my distribution's GHC package 700MB on disk?
15:54:19 <jfischoff> geekosaur: Just because two things have the same name doesn't mean they are the same approach
15:54:32 <Eduard_Munteanu> Hm, I see.
15:54:40 <jfischoff> if one solution to a problem fails, that doesn't mean another will also fail
15:54:53 <Peaker> geekosaur, there have been quite a few years during which time "non-human cataloging the internet for search" did not seem like a bright/doable idea
15:54:53 <geekosaur> true, but there've been a lot of attempts since 1986
15:54:59 <dEPy> anyone that knows javascript, what do you think of that guys: http://jsfiddle.net/afPrc/57/   do I understand monoid or not? I'm not sure if I got it right in a way.
15:55:07 <geekosaur> are you implying they've all been the same?
15:55:14 <Eduard_Munteanu> Anyway, I think most free software doesn't really trip on lack of overcommiting
15:55:16 <jfischoff> geekosaur: how many where for dependently typed languages?
15:55:25 <jfischoff> how many where for lisp?
15:55:26 <Tene> Eduard_Munteanu: Yes, usually.
15:55:28 <jfischoff> were
15:55:46 <Eduard_Munteanu> Tene: I think it was a problem with proprietary DBs or such
15:55:49 <Tene> Eduard_Munteanu: The common case I've seen is on fork() when a process is using most of the available memory.
15:56:21 <Peaker> geekosaur, most of the structural editing attempts have been for lisp (in that niche they can be considered a moderate success, btw) or focused on some graphic point&click UI which programmers abhor (for good reasons)
15:56:21 <probando> Hi
15:56:26 <probando> I'm having trouble with Haddock
15:56:32 <probando> I want to have a multi line code example
15:56:33 <probando> as
15:56:36 <mm_freak> ok, after testing and almost crashing my system along the way my conclusion is, yes, you can turn off overcommit =)
15:56:40 <probando> >>> let x = asdasdad in
15:56:42 * geekosaur is trying to figure out what that diversion has to do with anything... if types were going to make it possible, pascal's type system was simple enough that it should have worked...
15:56:44 <probando> >>> another line
15:56:48 <Tene> Eduard_Munteanu: For example, Redis relies on copy-on-write pages from fork when writing in its background process.
15:56:55 <probando> Does anyone know how to do that?
15:57:12 <Peaker> geekosaur, It is interesting to look at the Alice Pascal thing and study from it
15:57:25 <mm_freak> never do this when overcommitting is unconditionally permitted:  alloca (1024^5) (const (return ()))
15:58:24 <mm_freak> s/alloca/allocaBytes/
15:58:25 <Eduard_Munteanu> Tene: hm, though not counting COWed pages is somewhat desirable
15:58:39 <Eduard_Munteanu> Tene: after all you COW to save memory (well, time too)
15:58:48 <Tene> Eduard_Munteanu: Yes, it often is, which is why linux lets you permit overcommit
15:58:59 <Demos> problem with visual IDEs is the same problem with word processors, they can be great spome of the time and almost impossible to use in edge cases, by definition they need to narrow the avalible constructs or they just become really slow on screen keyboards
15:59:14 <Eduard_Munteanu> Tene: I guess that's what the '0' setting tries to cater for?
15:59:20 <parcs> Sausage865: and what does that output?
15:59:22 <Peaker> geekosaur, Structural is awesome, but if the UI sucks, the tooling or integrating with existing tooling sucks, or your distribution model sucks (you want a lot of money for a copy and nobody knows who/what you are), it's not going to work.. we hope to not suck at those fronts..
15:59:52 <Peaker> geekosaur, every structural IDE attempt I've seen seriously sucked on at least 1 of those
16:00:15 <Eduard_Munteanu> Still, perhaps one should make such COW pages read-only.
16:00:39 <Demos> to be clare when you say structural IDE are you talking about a lab-view sort of visual programming deal?
16:00:49 <Eduard_Munteanu> Demos: heh, no
16:00:57 <bitonic`> is it possible to hide the ‘match_co baling out ...’ messages deriving from -O2?
16:01:07 <Demos> oh thank god
16:01:32 <Tene> Eduard_Munteanu: See Documentation/vm/overcommit-accounting for more details on how that's measured
16:02:12 <Eduard_Munteanu> I see.
16:02:43 <bitonic`> brilliant, now I get a bug.  should probably update to the last version...
16:02:59 <Peaker> Demos, btw, talking about lamdu to a friend of my dad's, he asked: "Like LabView?", I said "No no.." and he said he loves LabView, that it's awesome you can stick a "scope" anywhere and debug, etc :)
16:03:42 <mm_freak> probando: use bird-style code sections
16:03:48 <Eduard_Munteanu> Peaker: I suspect it might make sense in some cases, like designing AFRP circuits
16:03:55 <Demos> oh dear god, that is bad, on a sidenote I am also annoyed by how every game engine's tooling feels the burning need to have a flowchart based AI tool
16:03:57 <mm_freak> probando: i.e. prefix your code with ">" like in email quotes
16:04:58 <Tene> Eduard_Munteanu: I had to have several conversations at my previous job where people insisted on wildly speculating about overcommit behaviour without reading the documentation.  Very frustrating.
16:04:58 <Eduard_Munteanu> Still, this sort of stuff is usually difficult to reason about.
16:05:36 <Eduard_Munteanu> Tene: yeah, sorry. :)
16:06:05 <cmccann> wild speculation without verification is dangerous. it almost resulted in monochrom underestimating GHC's cleverness.
16:06:07 <Tene> Eduard_Munteanu: No worries.  You haven't done anything wrong; I'm just vaguely griping.
16:07:46 <Tene> There was this one guy who kept blaming overcommit for unrelated issues too.
16:08:37 <Eduard_Munteanu> Tene: does it still make OOM conditions nastier?
16:10:41 <Ghoul_> Hi guys. I'm using parsec and my assignStat function will parse something like "a = (c(1,d(),3) + 3)" correctly but for some reason optionMaybe is playing up and won't parse just a() or b() without a variable assignment part. Looks like a straightforward issue but I've been stressing over it for a while now :/ Here's the code : http://hpaste.org/86421
16:10:52 <Peaker> Eduard_Munteanu, yeah, I don't really like the boxes&arrows UI model for programming, though for certain programs it might be nice
16:11:35 <Tene> Eduard_Munteanu: No, not at all.  Overcommit is only relevant at all at allocation time; either the allocation is permitted or refused.
16:12:07 <h4199> Peaker: How far along is your current work on lamdu?
16:12:33 <Eduard_Munteanu> Tene: yeah, I know, but IIRC reading from some LWN article, it's tougher for the OOM killer to be effective when allocation happens on page faults, or something like that.
16:12:57 <Eduard_Munteanu> Or IOW, no overcommiting makes it less like to freeze in OOM for a long time.
16:13:08 <allenj12> does anyone knows what it means when using parsec when it just says unexpected end?
16:15:17 <tromp__> :t parse
16:15:18 <lambdabot> Not in scope: `parse'
16:15:31 <tromp__> :t Parsec.parse
16:15:33 <lambdabot> Couldn't find qualified module.
16:15:43 <tromp__> :t Text.Parsec.parse
16:15:44 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
16:16:23 <tromp__> > Text.Parsec.parse (char 'a') ""
16:16:24 <lambdabot>   Not in scope: `Text.Parsec.parse'
16:19:45 <Ghoul_> Fixed the issue. Parsec won't backtrack unless you use `try` apparently. Don't let it fool you D:
16:20:00 <Peaker> h4199, we implemented our own gui toolkit, online type system/inference, structural UI for type-assisted editing of the code structure
16:20:12 <Peaker> h4199, but it's still preliminary.. today we are adding record support...
16:20:55 <Ghoul_> :t when
16:20:56 <lambdabot> Monad m => Bool -> m () -> m ()
16:21:06 <dkua> Noob here. What resources do you guys recommend for learning Haskell for someone who's never programmed functionally?
16:21:15 <Ghoul_> learnyouahaskell.com
16:21:47 <ion> @where lyah
16:21:47 <lambdabot> http://www.learnyouahaskell.com/
16:21:50 <ion> (clickable)
16:22:47 <hpaste> allenj12 pasted “Parsec im rly dumb” at http://hpaste.org/86422
16:22:56 <dkua> Thanks!
16:23:13 <allenj12> idk why i have so much trouble with this
16:24:15 <Peaker> h4199, example screenshot of the current way factorial looks like (still not the way we want it..): http://i.imgur.com/qrg7SIh.png
16:24:34 <Peaker> (the help is also expanded to give an idea of the interactivity)
16:24:54 <Sausage865> topFiveDesc films = take 5 $ sortBy (compare `on` (length .fans)) films
16:25:00 <Sausage865> Is currently returning in ascending order.
16:28:53 <h4199> Peaker: Interesting, I assume that "subtext" is the type annotation, yes? And I would navigate through the block with the flynav?
16:29:06 <Peaker> h4199, normally ordinary arrow navigation
16:29:14 <Peaker> h4199, and yeah, it's the inferred type (not explicit annotation)
16:29:26 <Peaker> factorial is actually a shitty example for the subtext :)
16:29:34 <Peaker> arithmetic where everything is int
16:30:47 <h4199> right, so if you expressly declared your type how would it interact with it?
16:32:45 <cschneid> trying to grok maybe and doing stuff with it, can somebody help me with the last version of my maybeSum function here? https://gist.github.com/cschneid/01bb1eccf0a9d229252e I can't quite figure out how I'd use foldM with a working + impl to get sum
16:32:59 <cschneid> (specifically maybeSum4 doesn't typecheck currently)
16:33:28 <allenj12> anyone know parsec?
16:33:35 <allenj12> parsec?
16:34:09 <allenj12> that can help with pasted problem?
16:34:47 <Peaker> h4199, http://i.imgur.com/pkll2cEh.png has some more interesting types
16:35:09 <Peaker> h4199, currently we don't support explicit type annotations, but you do explicitly specify param types
16:35:25 <cschneid> Peaker: what app is that?
16:35:28 <Peaker> h4199, and you can explicitly instantiate type-variables when calling polymorphic functions
16:35:29 <cschneid> Peaker: to make that chart
16:35:37 <Peaker> cschneid, lamdu, it's a structural IDE we're working on
16:35:43 <cschneid> I like it :)
16:36:00 <Peaker> :) it's very preliminary, you can run it from https://github.com/Peaker/lamdu
16:36:51 <h4199> ah, so it will lead you by the nose based on the parameters you choose
16:37:10 <Peaker> h4199, if you do, sure, but usually types can be inferred so let them :)
16:37:35 <Sausage865> is there a way to reverse a query?
16:37:37 <Peaker> h4199, in the euler example, you can see that for top-level definitions, the inferred type can be "accepted" to make it the publicized type
16:37:45 <Sausage865> So, i'm trying to find the top 5 in descending order.
16:38:10 <Sausage865> It's currently returning them in ascending order. From the worst to the best, rather than best to worst.
16:38:21 <h4199> > reverse [1,2,3]
16:38:22 <lambdabot>   [3,2,1]
16:38:25 <Sausage865> I have the function in place, and it's working fairly well. Just wondering if there's an easy fix.
16:38:31 <Sausage865> okay.
16:38:38 <Sausage865> Hmm, i'll try that with my IO one sec.
16:40:06 <aavogt> cschneid: (sequence xs) will be a   Maybe [Int], which won't work as the 3rd argument to foldM no matter what the other functions are
16:40:32 <cschneid> aavogt: yeah, I played with several versions with & without that. Trying to juggle the types in my head isn't working out
16:40:35 <h4199> I notice that list's have an altered syntax
16:40:43 <h4199> err lists*
16:40:57 <cschneid> aavogt: so [Maybe Int] is a valid thing to foldM over?
16:41:05 <aavogt> yes
16:41:15 <cschneid> aavogt: and I want to add, I'd use a Int -> Int -> Int function. Initial can be either 0 or Just 0
16:41:22 <cschneid> 0 I suppose, to feed into the first sum.
16:41:23 <aavogt> :t \f x -> foldM f x [Just 2]
16:41:24 <lambdabot> (Monad m, Num a1) => (a -> Maybe a1 -> m a) -> a -> m a
16:41:55 <merijn> aavogt: You can also abuse ImplicitParams for type checking like that :)
16:42:05 <merijn> :t foldM ?f ?x [Just 2]
16:42:06 <lambdabot> (?f::a -> Maybe a1 -> m a, ?x::a, Monad m, Num a1) => m a
16:42:48 <aavogt> that's the first time somebody's recommended the extension to me
16:42:49 <merijn> Nicer with just one param, I guess
16:42:56 <merijn> :t foldM ?f 1 [Just 2]
16:42:57 <lambdabot> (?f::a -> Maybe a1 -> m a, Monad m, Num a1, Num a) => m a
16:43:04 <cschneid> this definition returns an int instead of a Maybe Int - foldM (+) 0 xs -- how's it extract from the Maybe?
16:43:20 <merijn> :t foldM
16:43:21 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:43:52 <cschneid> ohh sorry. (+) doesn't work
16:43:59 <monochrom> must you use foldM?
16:44:07 <cschneid> Int -> Int -> Int vs. the correct Int -> Int -> Maybe Int
16:44:15 <merijn> :t foldM `asAppliedTo` (+)
16:44:16 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = m0 b0
16:44:16 <lambdabot>     Expected type: b0 -> b0 -> m0 b0
16:44:16 <lambdabot>       Actual type: b0 -> b0 -> b0
16:44:20 <cschneid> monochrom: no, check the gist here - https://gist.github.com/cschneid/01bb1eccf0a9d229252e
16:44:32 <cschneid> monochrom: playing with alternate ways of dealing with Maybe
16:44:51 <aavogt> cschneid: the types we got above would have suggested:    Int -> Maybe Int -> Maybe Int
16:45:23 <aavogt> > foldM (\x -> liftM (x+)) 0 [Just 2, Just 4]
16:45:24 <lambdabot>   Just 6
16:45:27 <merijn> cschneid: Instead of isJust in maybeSum maybe you want maybe?
16:45:29 <merijn> :t maybe
16:45:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:45:53 <cschneid> merijn: instead of the if/else?
16:46:00 <merijn> cschneid: Yeah
16:46:05 <monochrom> it looks like foldl/foldr with your .+. is more to the point, since you already have .+.
16:46:07 <merijn> isJust is generally a code smell
16:46:17 <cschneid> merijn: good to know
16:46:32 <merijn> cschneid: Usually you'd replace it with either maybe or a case-of
16:46:37 <cschneid> maybeSum4 xs = foldl1 (.+.) xs
16:46:55 <Peaker> @src foldM
16:46:55 <lambdabot> foldM _ a []     = return a
16:46:56 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:47:04 <Peaker> @type foldM
16:47:06 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:50:03 <cschneid> thanks guys - gotta head out, your help is always awesome.
17:01:20 <meditans> I have a problem with the compilation of a package through cabal which I don't know how to resolve
17:01:26 <hpaste> meditans pasted “Compilation Error” at http://hpaste.org/86424
17:01:53 <meditans> (hi all, by the way)
17:02:15 <Peaker> meditans, what does ghc-pkg list containers say?
17:02:44 <Peaker> meditans, and ghc-pkg list Cabal   and   ghc-pkg check ? can you paste all of these?
17:03:00 <meditans> yes, I'll paste in a moment
17:05:12 <hpaste> meditans pasted “ghc-pkg varies” at http://hpaste.org/86425
17:07:22 <Peaker> meditans, when cabal asked you if you are sure you want to reinstall, you said yes? :)
17:07:39 <meditans> yes :)
17:07:49 <Peaker> meditans, do a "ghc-pkg unregister" for each broken package mentioned in "check"
17:08:03 <Peaker> meditans, make sure to avoid "shadowing" system packages.. e.g: your user-directory containers-0.4.2.1 is shadowing the system one
17:08:15 <meditans> I was curious to know if it was right to think that these package would be broken :)
17:08:19 <meditans> ok
17:08:20 <Peaker> meditans, and answer "no" to reinstalls
17:08:26 <meditans> ok :)
17:08:36 <meditans> how do i avoid shadowing in general?
17:08:48 <Peaker> meditans, don't reinstall, it causes shadowing
17:09:15 <Peaker> meditans, also ghc-pkg unregister   each package that shadows a system one
17:09:17 <monochrom> more than that. refuse multiple versions and instances
17:09:21 <Peaker> meditans, might want to just nuke your ~/.ghc :)
17:10:08 <meditans> ok, and if i delete ~/.ghc what have I to do then?
17:10:24 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for what is in ~/.ghc
17:10:53 <Peaker> meditans, cabal install the packages you want
17:10:54 <monochrom> you will lose your "user" packages, but it is likely good riddance
17:11:13 <Peaker> meditans, also, if you are ever going to use profiling, nuking .ghc is a good time to enable library profiling in your ~/.cabal/config
17:11:26 <monochrom> but see my article. you can no longer abstract this away.
17:11:32 <Peaker> meditans, because installing the profiling version of already-installed packages is a real PITA
17:12:09 <meditans> monochrom thanks, I will read it in a minute :)
17:12:20 <Peaker> monochrom, why SICP? :) I thought it was surely irrelevant before opening it...
17:12:23 <meditans> peaker how do I enable it?
17:12:48 <Peaker> meditans, library-profiling: True
17:12:59 <thetallguy1> anyone know of an instance of TH.Lift for UTCTime?
17:13:00 <Peaker> meditans, you have a commented out    -- library-profiling: False,  remove the "--" and change to True
17:13:08 <monochrom> I never give you irrelevant urls
17:13:09 <meditans> ok, in which file?
17:13:18 <Peaker> meditans, ~/.cabal/config
17:13:28 <meditans> peaker: thanks
17:13:34 <meditans> i'll do in a minute
17:14:52 <johnw> if I have two functions with view patterns, foo (f -> Left e) = ...; foo (f -> Right r) = ..., will GHC only evaluate f for the argument once?
17:15:09 <monochrom> I heard yes
17:23:33 <monochrom> I just tried: f (uncons -> Nothing) = 0; f (uncons -> Just (x,y)) = f y. that's Data.ByteString.uncons. even without -O, it compiles to "case uncons ds of Nothing ... Just ..."
17:24:32 <Eduard_Munteanu> monochrom: what else could it do?
17:24:40 <meditans> peaker if I delete the .ghc folder, is there still need for a "ghc-pkg unregister" for each broken package?
17:24:46 <monochrom> with -O there is not even a mention of Nothing or Just, bytestring internals get inlined, it's a "if x<=0 then ... else ..."
17:25:21 <meditans> peaker because I still get an error while compiling wxc, even after the folder deletion
17:25:22 <monochrom> it could call uncons twice rather than once, if it's really dumb, like me
17:25:41 <Peaker> meditans, no, if you deleted .ghc then you don't need unregister.. paste the new error & the output of ghc-pkg list ?
17:25:47 <Eduard_Munteanu> Oh, I see.
17:26:28 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/104783  <--- GHC 1, monochrom 0 :)
17:27:43 <hpaste> meditans pasted “error again” at http://hpaste.org/86426
17:29:42 * hackagebot lin-alg 0.1.0.2 - Low-dimensional matrices and vectors for graphics and physics  http://hackage.haskell.org/package/lin-alg-0.1.0.2 (JasonDagit)
17:32:31 <meditans> peaker here it is the paste http://hpaste.org/86426
17:33:18 <Peaker> meditans, ah, it's an uninformative: "setup: failed" now
17:33:38 <Peaker> meditans, you can try: "cabal install -v wxc" ?
17:34:22 <Peaker> meditans, and if that doesn't add information, you can try "cabal unpack wxc ; cd wxc-* ; ghc Setup ; ./Setup configure --user" and hope for more output. If still just a silly failure, you can try digging into Setup.hs to see what atrocity they have there :)
17:34:23 <meditans> peaker yes, in a minute
17:37:06 <meditans> peaker turns out that the -v flag is informative indeed
17:37:10 <hpaste> meditans pasted “with -v flag” at http://hpaste.org/86427
17:37:42 <meditans> peaker i see a lot of "not found" towards the end, have you got any advice?
17:38:57 <Peaker> meditans, the information is noise.. only line 54 relevant
17:39:11 <Peaker> meditans, It seems that the wxc package has a custom Setup script that fails without any diagnostic :(
17:39:35 <Peaker> meditans, if you run Setup.hs directly, maybe you'll be lucky to get more diagnostic. If not, you can try "strace" on it, or digging into the Setup source to figure out why it's failing
17:39:42 * hackagebot persistent-mongoDB 1.1.6 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.6 (GregWeber)
17:39:58 <shachaf> @ty (`runCont` id)
17:39:59 <lambdabot> Cont r r -> r
17:40:03 <meditans> peaker, ok i'll try your precedent solution
17:40:03 <shachaf> @ty (`runContT` return)
17:40:04 <lambdabot> Monad m => ContT r m r -> m r
17:40:13 <shachaf> Maybe these should be provided by the library?
17:40:20 <acowley> How do I pass an argument to cpphs in a cabal file?
17:40:51 <cmccann> I wish I knew how to deal with it when people show up on stackoverflow asking questions about Haskell homework and it's clear they don't understand anything they're doing
17:40:55 <shachaf> At any rate, you can do things like: (`runContT` return) $ do { x <- ContT (withFile "/etc/passwd" ReadMode); y <- ContT (...); lift $ ... }
17:41:50 <cmccann> how do you even help someone like that? just saying "please attempt to actually learn something" is neither polite nor likely to improve the situation but... bluh.
17:41:55 <meditans> peaker what do you mean with the "--user" part in "./Setup configure --user"? Is --user an option?
17:43:07 <geekosaur> yes, it's an option
17:43:30 <geekosaur> it means register with the user db. you want this unless you are creating a distribution
17:43:54 <meditans> geekosaur: thanks :)
17:43:58 <geekosaur> it sets various paths and also makes the user package db availabel for the build
17:45:02 <meditans> peaker: ok, manual compiling and Configuring Setup.hs is completely uninformative, so now i'm going to take a look at setup.hs
17:48:45 <Peaker> meditans, strace on the Setup executable can often expose where an error occurred
17:49:23 <shachaf> strace++ # best program
17:49:42 * hackagebot ref 0.1.0.0 - Mutable references  http://hackage.haskell.org/package/ref-0.1.0.0 (AndySonnenburg)
17:49:59 <Peaker> that's not possible, because strace-plus also gives you stack traces of each syscall
17:50:00 <Peaker> :)
17:50:11 <Peaker> https://code.google.com/p/strace-plus/
17:50:17 <Peaker> strace-plus++
17:50:32 <shachaf> That doesn't sound exactly right.
17:51:05 <shachaf> strace works at a clear well-defined level of abstraction. The userspace-kernel interaction is the same no matter how your program works.
17:51:21 <shachaf> On the other hand stack traces don't really make sense in general.
17:51:50 <Sausage865> How easy is it to implement writeFile and readFile? I've been using testDatabase :: Database       ,  testDatabase = [_,[],_,[]]              Up until now, but I want this to be written into and out of a simple .txt file?
17:51:57 <Sausage865> Will this involve a huge amount of change to my code?
17:52:13 <Sausage865> It really only needs to read and write, when main IO () is called and closed.
17:52:20 <Peaker> shachaf, strace-plus works at the level of abstraction that has both kernel syscalls and stack traces.. which is a pretty common level :)
17:52:20 <Sausage865> Any idea of a simple sollution to this?
17:53:11 <meditans> peaker, I used strace, but I don't know how to make sense of that. Should I paste it?
17:53:15 <shachaf> Peaker: Well, I'll remember it. Or more likely try to remember it and forget it.
17:53:39 <shachaf> Peaker: You should arrange for it to be apt-gettable in Debian!
17:54:37 <Peaker> meditans, sure
17:55:29 <hpaste> meditans pasted “strace ./Setup” at http://hpaste.org/86428
17:56:19 <shachaf> hpaste: You ran ./Setup without giving it a command.
17:56:30 <shachaf> ./Setup is the thing that gets configure/build/etc.
17:58:01 <meditans> shachaf: sorry, I'll do "strace ./Setup configure --user" in a minute
17:58:17 <shachaf> Note that I don't know what's failing or anything.
17:58:45 <htmnilc> How easy is it to implement writeFile and readFile? I've been using testDatabase :: Database       ,  testDatabase = [_,[],_,[]]              Up until now, but I want this to be written into and out of a simple .txt file? I only really need it to be read and written when the main IO() is called and exited. It should then update all data back to the file ready for next use.
17:59:20 <shachaf> htmnilc: What a coïncidence! Sausage865 asked the same question a few minutes ago.
17:59:33 <shachaf> I didn't understand it then either, though.
17:59:51 <cmccann> shachaf: I think he left.
18:00:04 <cmccann> maybe he's going to go ask on StackOverflow, like some of his classmates have.
18:00:37 <shachaf> type Film = (Title, Cast, Year, Fans)
18:00:40 <shachaf> I remember this.
18:00:57 <c_wraith> That's a terrible data structure, semantically
18:01:08 <c_wraith> What the heck is Fans doing with the rest of those things?
18:01:11 <cmccann> yes.
18:01:21 <cmccann> homework assignments like that make me sad.
18:01:34 <shachaf> cmccann: I bet your book will have only good homework assignments.
18:01:35 <shachaf> imo write it
18:02:03 <cmccann> I was about to say "shachaf probably likes it because shit like this is what makes me want to write that book".
18:02:09 <c_wraith> haha
18:03:45 <flebron> What is a reasonable way of reading in an ASCII-art matrix of c columns and r rows, every entry being either '.' or '#', preferrably using a ByteString, into an Array-based matrix? (Such that I can subindex by (i, j)).
18:04:30 <flebron> ByteStrings have O(1) indexing, but if I just grab r bytestrings, indexing into the kth list in order to build the Array will be slow.
18:04:33 <hpaste> meditans pasted “strace ./Setup configure --user” at http://hpaste.org/86429
18:04:55 <c_wraith> flebron: if you just build the array once, it's going to take time proportional to the number of elements in it.  Whatever.
18:04:58 <flebron> (That is, [ByteString] is going to be ugly, because getting its kth element, representing the kth row, is O(n).)
18:05:24 <shachaf> O(k), surely?
18:05:28 <flebron> c_wraith: That's fine, but indexing using a [ByteString] would be O(n^3).
18:05:31 <cmccann> shachaf: Ok!
18:05:40 <flebron> shachaf: Sure, also O(r), r number of rows.
18:05:49 <cmccann> O(r) that.
18:05:50 <shachaf> You just said "kth" element
18:05:54 <flebron> By that I meant "linear", as opposed to "constant".
18:05:55 * cmccann stops
18:05:56 <flebron> Yes, I know.
18:06:04 <c_wraith> flebron: then don't index into it to build the array.
18:06:16 <flebron> OK, how do you suggest I do it then? That's my question :)
18:06:25 <meditans> peaker: here is the past of "strace ./Setup configure --user”, a lot of lines, in fact? What are you in search  for?
18:06:33 <shachaf> Are you asking how to make an array?
18:06:41 <c_wraith> some combination of whatever the array function is that builds from a list, and unpack
18:06:43 <meditans> peaker http://hpaste.org/86429
18:06:59 <c_wraith> and map and various other standard combinators
18:07:01 <flebron> unpack gives me a String... why would I want that?
18:07:11 <c_wraith> No, unpack gives you a [Word8]]
18:07:14 <c_wraith> err, -]
18:07:21 <flebron> I was thinking of .Char8.
18:07:28 <johnw> not if he's using the one from Char8
18:07:33 <flebron> (Since these are either '.' or '#'.)
18:07:44 <c_wraith> Then you concat those lists, and have the necessary list to feed to the function...  uhh..  listArray, I think is the name of it?
18:08:00 <c_wraith> You will have to zip it with something to give it the correct indices, but whatever
18:08:03 <c_wraith> This is all basic stuff
18:08:31 <Peaker> meditans, strace doesn't trace forked child processes by default, -f does so. But maybe it's better to try and see if others encountered "setup failed" for wxc
18:08:39 <flebron> It may, but I'm also a beginner, so basic stuff is still not trivial to me :)
18:09:18 <meditans> peaker, yes, i'm searching the internet, but the solutions I found till now don't do it
18:09:21 <c_wraith> well, I've got to run.  But look at the listArray (iirc) function, and think about how you'd generate the list of indices you want
18:09:29 <flebron> Alright, thanks :)
18:09:33 <meditans> peaker, anyway, i'll let you know :)
18:10:42 <hpaste> “Anonymous Coward” annotated “Program” with “Program (annotation)” at http://hpaste.org/86129#a86430
18:21:22 <hpaste> meditans pasted “new information” at http://hpaste.org/86432
18:21:58 <SoupEvil> i don't get a usefull application of the (*>) operator (from Contro.Applicative), any hints?^^
18:22:08 <shachaf> It's the same as (>>)
18:22:28 <meditans> peaker i somehow got more information on compiling..  http://hpaste.org/86432 now, i think this is a library problem with anything to do with haskell.. but what should I install?
18:22:50 <applicative> oh dear wx problems..
18:24:07 <applicative> meditans: maybe if you add -- what is it ?  -- --verbose=3 there will be a clue at the moment of death
18:24:14 <meditans> applicative I know... :) but, by the way, is wxHaskell actively mantained?
18:24:58 <ion> Is wxWidgets even actively maintained? :-P
18:24:59 <applicative> meditans: I think 'actively' cant be used here.
18:25:36 <ion> According to Wikipedia, 3.0 will be released by the end of 2012.
18:28:05 <SoupEvil> shachaf: k, thx, i think i get it partially
18:28:19 <applicative> oh, check out the github repo meditans  there is recent activity, pertaining in particular to wxc https://github.com/jodonoghue/wxHaskell
18:31:51 <applicative> hm we lost meditans, ... I was about to prove I had built something with wxhaskell recently, unimpressive as it was
18:34:16 <johnw> SoupEvil: it can be very handy
18:34:37 <johnw> SoupEvil: say you have two Maybe values, and you want the second value only if the first value is a nothing
18:34:40 <johnw> > Nothing *> Just 10
18:34:42 <lambdabot>   Nothing
18:34:48 <johnw> > Just 10 *> Just 20
18:34:50 <lambdabot>   Just 20
18:34:59 <johnw> I mean, you only want the second value if the first one is NOT nothing
18:35:12 <johnw> > Nothing <> Just 10
18:35:14 <lambdabot>   Ambiguous type variable `a0' in the constraints:
18:35:14 <lambdabot>    (GHC.Num.Num a0)
18:35:14 <lambdabot>      a...
18:36:02 <SoupEvil> oh i see, yes it's handy
18:37:01 <SoupEvil> i tried to mascade an IO operation in a functor, but this was a misconception in my head, i guess^^
18:37:08 <johnw> it's kind of like a Python-style && for maybe values, in this case (where it gives you the last true value, but only if all are true)
18:37:25 <johnw> you did what now?
18:37:59 <johnw> meanwhile, <|> is like Python-style || for maybe values
18:38:01 <johnw> > Just 10 <|> Just 20
18:38:02 <lambdabot>   Just 10
18:38:04 <johnw> > Nothing <|> Just 20
18:38:04 <SoupEvil> i guess, if i want to mascade a IO operation in a functor i will end at effecful functors aka monads^^
18:38:06 <lambdabot>   Just 20
18:38:21 <johnw> what does mascade mean?
18:38:34 <johnw> and what does it mean to "mascade a IO operation in a functor"?
18:38:40 <johnw> IO is already a functor
18:38:53 * geekosaur .. "masquerade"?
18:38:54 <SoupEvil> sec, i try to extract an example
18:39:09 <applicative> SoupEvil: with parsers it's very nice whitespace *> importantStuff <* garbage
18:39:20 <geekosaur> (and as noted, if so it's not much of a masquerade)
18:39:21 <allenj12> so given a string like ((aaa)bbb)ccc(aaa) how would i seperate each parenthisized statement into a list of strings? i tried parsec but it dosnt seem the way to go
18:39:43 * hackagebot Strafunski-StrategyLib 5.0.0.2 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.2 (JamesKoppel)
18:39:55 <luite> allenj12: what should the result be for that input?
18:41:09 <SoupEvil> i tried to Debug.Trace.trace an output of an Arrow in an Arrow which behaves like the identity arrow
18:41:16 <johnw> > groupBy (/=) "aaabbbcccaaa"
18:41:18 <lambdabot>   ["a","a","abbbccc","a","a","a"]
18:41:22 <johnw> > groupBy (==) "aaabbbcccaaa"
18:41:24 <lambdabot>   ["aaa","bbb","ccc","aaa"]
18:41:53 <allenj12> luite: hmm well like this ["((aaa)bbb)ccc(aaa)","(aaa)bbb)","(aaa)","ccc","bbb"]
18:42:08 <johnw> ah
18:42:36 <applicative> hm, my important patch to Stafunski must have been applied... :
18:42:39 <SoupEvil> still extracting^^
18:42:43 <allenj12> i guess to be more specific it could look like this
18:42:50 <applicative> Strafunski
18:43:04 <allenj12> ((A o B) a C) o (B a C)
18:43:10 <allenj12> if that looks cleaner
18:43:14 <allenj12> as a input
18:45:19 <allenj12> and i guess it would be a mistake cause it would need to be more like this ["((A o B) a C) o (B a C)", "(A o B) a C)","(B a C)",]
18:45:19 <luite> allenj12: hm that looks doable with parsec, produce a tree?
18:46:16 <allenj12> luite: i tried with parsec but it seems like i would need to use sepBy and i dont know how to have a 2 valued seperator like ( something )
18:46:37 <cmears> perhaps combine it with "between"
18:46:42 <applicative> sepEndBy?
18:46:45 <allenj12> luite '(' something ')'
18:46:56 * applicative is rusty
18:47:25 <allenj12> hmmm hold on ill paste what i had so far and try between etc
18:47:47 <johnw> allenj12: trifecta has a "parens" parser
18:48:10 <luite> allenj12: between (char '(') (char ')') or something
18:48:13 <applicative>   braces  = between (symbol "{") (symbol "}")
18:48:16 <allenj12> johnw: rly!?!?!?
18:48:19 <johnw> yeah, that
18:48:45 <hpaste> allenj12 pasted “parsec” at http://hpaste.org/86433
18:48:54 <johnw> in trifecta (now part of "parsers"), it's also called between
18:49:08 <allenj12> ill try fixing for learning if it dosnt work ill try trifecta
18:49:09 <johnw> braces  = between (symbol "{") (symbol "}")
18:49:17 <applicative> it's annoying there isnt some elementary parsec in scope with lambdabot, it would be very useful
18:49:25 <johnw> applicative: that's true!
18:49:27 <chrisdotcode> hi guys :)
18:49:36 <johnw> Cale: by the power of Caleskell!
18:49:55 <chrisdotcode> so how do I make a tuple of a single element? it's not (1,) ...
18:50:19 <tgeeky> chrisdotcode: (1) which is the same as 1
18:50:39 <chrisdotcode> tgeeky: right, that I knew. likewise, (1,) doesn't work (a la python)
18:50:48 <chrisdotcode> tgeeky: oh... wait.
18:50:59 <chrisdotcode> tgeeky: all single elements are automatically tuples in haskell?
18:51:08 <shachaf> No.
18:51:08 <Mortchek> Rather, there are no single-element tuples
18:51:14 <shachaf> chrisdotcode: There's no single-element tuple type.
18:51:20 <shachaf> Maybe there should be, but there isn't.
18:51:32 <Mortchek> What would be the use of a single-element tuple?
18:51:33 <chrisdotcode> right. duh. by definition, there can't be one "tu"ple.
18:51:35 <tgeeky> there is ()
18:51:35 <chrisdotcode> thanks guys.
18:51:48 <shachaf> chrisdotcode: There's Data.Functor.Identity which is similar.
18:51:51 <chrisdotcode> tgeeky: isn't () the no element tuple?
18:52:01 <tgeeky> chrisdotcode: yes
18:52:30 <chrisdotcode> so what's haskell's null type again? cause I"m trying to do something like (x, null)
18:52:41 <shachaf> What's a null type?
18:52:56 <imphasing> you've got void and unit to pick from
18:53:05 <geekosaur> there isn't one, as such. depending on what you mean, void, unit, Maybe a
18:53:13 <Mortchek> Or if you want to append a nothing to some type a, Maybe a
18:53:29 <chrisdotcode> okay, what I"m *really* trying to do is make an zip that doesn't stop until both lists are exhausted
18:53:43 <Mortchek> [] is the empty list
18:53:46 <shachaf> OK. Maybe what you want is These.
18:53:55 * tgeeky thinks he wants []
18:53:56 <shachaf> cmccann can explain, I guess.
18:54:02 <hpaste> “Anonymous Coward” pasted “unevenZip” at http://hpaste.org/86434
18:54:08 <acowley> Maybe's your huckleberry
18:54:18 <chrisdotcode> that's my hpaste I'm trying to do.
18:54:23 <imphasing> would you guys say a constructed type is just something that advertises what tags a piece of data has?
18:54:27 <mm_freak> chrisdotcode: what's yourZip [] (x:xs)?
18:54:35 <shachaf> chrisdotcode: You can make: foo :: [a] -> [b] -> [(Maybe a, Maybe b)]
18:54:35 <imphasing> I'm having a hard time with constructed types vs a type
18:54:41 <shachaf> That type isn't quite right, though.
18:54:41 <luite> chrisdotcode: [a] -> [b] -> [(Maybe a, Maybe b)] could work
18:54:45 <hpaste> allenj12 pasted “parsec” at http://hpaste.org/86435
18:54:49 <Mortchek> Ah, well even if there were 1-tuples, you wouldn't be able to use them if a 2-tuple were expected.
18:54:58 <shachaf> luite: But what you really want is These.
18:55:10 <allenj12> ok so thats what i got now thats better no? im getting some errors but just makin sure im on the right path
18:55:13 <chrisdotcode> yeah, but my code is also wrong.
18:55:20 <shachaf> data These a b = This a | That b | These a b
18:55:31 <cmccann> more to the point: http://hackage.haskell.org/packages/archive/these/0.3/doc/html/Data-Align.html
18:55:32 <chrisdotcode> I was trying to pattern match, but it didn't quite work
18:55:47 <chrisdotcode> maybe seems like a good idea
18:56:01 <cmccann> you need something like These to handle a "structural union", like expanding the shorter list.
18:56:06 <dmwit> zipWithEnd :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]
18:56:06 <luite> shachaf: right
18:56:46 <dmwit> zipThese = zipWithEnd These This That -- ;-)
18:56:58 <shachaf> dmwit's type is good.
18:57:04 * tgeeky agrees
18:57:15 <tgeeky> that type signature looks noice
18:57:25 <chrisdotcode> for my problem?
18:57:30 <luite> yeah
18:57:36 <mm_freak> as a more fundamental note i'm having trouble to find a use case for zipWithEnd
18:57:56 <cmccann> mm_freak: the special case where you pad with mempty is handy
18:58:11 <chrisdotcode> mm_freak: it's an intellectual exercise for me still learning haskell, but also what cmccann said :-)
18:58:19 <shachaf> "That's not my department," / says C. A. McCann.
18:58:40 <cmccann> shachaf: ooh, that actually fits the meter. nice.
18:58:44 <cmccann> I like it.
18:58:49 <chrisdotcode> dmwit: so a function that takes three arguments, two functions and two lists and returns the zipEnded list?
18:58:58 <hpaste> allenj12 pasted “parsec” at http://hpaste.org/86436
18:59:01 <shachaf> cmccann: I think "Casey McCann" fits it better.
18:59:09 <mm_freak> perhaps it's because i think of 'zip' more like 'zipStream', so i don't encounter lists of different lengths in practice =)
18:59:09 <allenj12> updated
18:59:47 <shachaf> @quote syntaxglitch
18:59:47 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
19:00:01 <shachaf> @quote syntaxglitch
19:00:02 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
19:00:07 <chrisdotcode> shachaf: and what is These better than maybe for this scenario?
19:00:11 <dmwit> chrisdotcode: yup
19:00:20 <shachaf> chrisdotcode: Because it rules out the possibility of (Nothing,Nothing)
19:00:27 <shachaf> Which is a nonsense for this type.
19:00:41 <shachaf> value
19:00:44 <shachaf> @quote syntaxglitch
19:00:44 <lambdabot> syntaxglitch says: writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
19:00:52 <cmccann> and avoids a clumsier encoding like (Either a (Maybe a, b))
19:00:59 <chrisdotcode> shachaf: right. I want it to stop when both lists are exausted. so (Nothing, something) and (something, Nothing) should work, but not (Nothing, Nothing)
19:01:25 <chrisdotcode> dmwit: so why is that the correct type signature? I'm having a bit of trouble getting started...
19:01:28 <cmccann> i.e., there's no tidy way to factor X + Y + X*Y
19:01:35 <aavogt> that clumsier encoding doesn't even require that the first elements have an 'a' and 'b' either...
19:01:52 <shachaf> chrisdotcode: So These takes care of that by not having a (Nothing,Nothing) case.
19:02:08 <cmccann> chrisdotcode: compare dmwit's type to http://hackage.haskell.org/packages/archive/these/0.3/doc/html/Data-These.html#v:these
19:02:18 <mm_freak> data These a b = This a | That (Maybe a) b
19:02:21 <shachaf> chrisdotcode: As cmccann mentioned, this is like factoring that expression. (Maybe a, Maybe b) is (a+1)*(b+1), i.e. ab + a + b + 1
19:02:29 <copumpkin> just turn into 1 + X + Y + X * Y
19:02:31 <shachaf> But you want ab + a + b, and there's no nice way to express that.
19:02:35 <copumpkin> then outlaw the 1
19:02:39 <copumpkin> and throw an error when you get it
19:02:45 <copumpkin> >_>
19:02:51 <shachaf> thopumpkin
19:03:04 <cmccann> copumpkin: and then use spoon to clean up the mess after the fact, right?
19:03:05 <mm_freak> a*b + a + b = a + (a + 1)*b
19:03:06 <shachaf> copumpkin is an outlaw himself.
19:03:12 <copumpkin> cmccann: yeah
19:03:20 <shachaf> mm_freak: <cmccann> and avoids a clumsier encoding like (Either a (Maybe a, b))
19:03:24 <cmccann> ok, that is certainly a plan.
19:03:30 * dmwit . o O (Maybe (These a b))
19:03:37 <copumpkin> (Maybe a, Maybe b)
19:03:55 <mm_freak> shachaf: just noting =)
19:03:57 <applicative> These?
19:04:00 <dmwit> chrisdotcode: The type I suggested is the right type because it says what you're going to be doing.
19:04:03 <shachaf> mm_freak: Just Nothing =)
19:04:09 <mm_freak> hehe
19:04:12 * applicative can't keep up with the avant-garde types
19:04:22 <dmwit> chrisdotcode: You're either going to be combining and a and a b somehow, or you're going to be consuming just an a somehow, or you're going to be consuming just a b somehow.
19:04:24 * copumpkin is pretty avant-garde
19:04:29 <mm_freak> shachaf: #haskell encourages me to perform my type experiments publicly =)
19:04:32 <chrisdotcode> dmwit: [x] -> [y] -> [These x y] doesn't work also?
19:04:43 <dmwit> chrisdotcode: (a -> b -> c) is the combiner; (a -> c) is for consuming just an a; (b -> c) is for consuming just a b.
19:04:53 <dmwit> chrisdotcode: It's okay.
19:04:58 <shachaf> It work good.
19:05:15 <dmwit> chrisdotcode: It's good in the same sense that both zip and zipWith are good.
19:05:23 <tgeeky> which is pretty good!
19:05:30 <cmccann> chrisdotcode: if you're immediately going to map over the result and do something with each possible case from These, dmwit's version is more direct
19:05:35 <acowley> good, work it
19:05:43 <mm_freak> btw, you could call zipThese a fold on [These a b]
19:05:44 <applicative> and God saw that zip and zipWith were very good
19:05:55 <copumpkin> I want a Those type
19:06:01 <chrisdotcode> so why doesn't [a] -> [b] -> [(Maybe a, Maybe b)] work?
19:06:03 <shachaf> I,I zipWethe
19:06:04 <johnw> what does Those do?
19:06:21 <tgeeky> chrisdotcode: that's fine if (Nothing, Nothing) is acceptable. Is it?
19:06:22 <dmwit> chrisdotcode: As people have explained several times, you don't expect to output (Nothing, Nothing), and your type should express that.
19:06:35 <applicative> newtype These = These Those; newtype Those = Those These
19:06:44 <cmccann> the ideal type is the one where every possible value makes sense and all the values that make sense are possible.
19:07:09 <chrisdotcode> dmwit: oh, yes. that's right. initially I was going to have (Nothing, Nothing) be a possible value, but then you guys reminded me it's just nonsense.
19:07:19 <shachaf> chrisdotcode: So Void?
19:07:26 <shachaf> s/hrisdotcode/mccann/
19:07:29 <acowley> chrisdotcode also isn't expecting [This x, That y, These w z] as a value
19:07:34 <acowley> how come nobody is addressing that?
19:07:43 * applicative isn't sure thats what max weber meant by 'ideal type'
19:07:46 <tgeeky> acowley: [These w z] was the type
19:07:54 <tgeeky> the result*
19:07:58 <mm_freak> what you really need is this:
19:08:01 <cmccann> acowley: because that's much trickier to exclude without complicating things :[
19:08:02 <mm_freak> @quote tarcieri
19:08:03 <lambdabot> tarcieri says: coal gel bras?
19:08:03 <chrisdotcode> yeah, [x] -> [y] -> [(These x y)]
19:08:10 <acowley> cmccann: :D
19:08:16 <shachaf> acowley: It's true. But These is locally better than (Maybe,Maybe).
19:08:18 <chrisdotcode> or dmwit's type, which I don't think I'm ready for yet...
19:08:29 <dmwit> chrisdotcode: Have you seen zipWith?
19:08:31 <dmwit> :t zipWith
19:08:33 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:08:46 <chrisdotcode> dmwit: yeah, I have :-)
19:08:52 <acowley> It's just that when we start saying noble things like "every possible value makes sense" we should take care
19:08:57 <shachaf> cmccann: How about foo :: [a] -> [b] -> ([(a,b)], Either [a] [b])?
19:09:01 <dmwit> Well, my type is just zipWith, plus a map for the list that's a bit longer. =)
19:09:03 <dmwit> :t map
19:09:04 <lambdabot> (a -> b) -> [a] -> [b]
19:09:08 <chrisdotcode> I wanted to get a simple example to help me understand both recursion and pattern matching
19:09:15 <allenj12> hmmm dosnt seem to like this seperator = between (symbol '(') (symbol ')') says maybe not enough arguments but that dosnt seem right
19:09:19 <shachaf> acowley: That was about the *ideal* type. Haskell types are usually not ideal.
19:09:19 <tgeeky> chrisdotcode: you've failed!
19:09:20 <dmwit> :t map :: (a -> c) -> [a] -> [c]
19:09:22 <lambdabot> (a -> c) -> [a] -> [c]
19:09:25 <shachaf> In fact they're never ideal. See ⊥.
19:09:31 <chrisdotcode> tgeeky: appearently so! haha
19:09:33 <cmccann> shachaf: bottoms ruin everything :[
19:09:57 <applicative> cmccann: the text should read " Now enhanced with deep black magic, courtesy of Control.Lens!  Synopsis ...
19:10:32 <shachaf> Control.Lens is not black magic.
19:10:32 <cmccann> applicative: I am still inordinately delighted that I can map the two types of These using "over here" and "over there".
19:10:39 <applicative> haskell types are perfectly ideal until you contemplate what are called their semantics
19:11:35 <hpaste> chrisdotcode revised “unevenZip”: “unevenZip” at http://hpaste.org/86434
19:11:41 <johnw> lens is only white magic
19:11:45 <chrisdotcode> ^ is that any better?
19:12:37 <ion> johnw: Caucasian magic
19:12:38 <dmwit> ?let dropLazy (x:xs) (y:ys) = dropLazy xs ys; dropLazy _ ys = ys
19:12:40 <lambdabot>  Defined.
19:12:47 <applicative> johnw: my impression was it depended on the week whether it was white or deep black magic, but maybe things have settled down
19:12:57 <jtree> hey all, I'm reading through the typeclassopedia and I'm a little confused about the evil functor example/questions.
19:13:12 <applicative> the Evil functor??
19:13:20 <jtree> section 3.3
19:13:20 <dmwit> :t let zipWithEnd f g h a b = zipWith f a b ++ map g (dropLazy b a) ++ map h (dropLazy a b)
19:13:22 <lambdabot> <no location info>:
19:13:22 <lambdabot>     not an expression: `let zipWithEnd f g h a b = zipWith f a b ++ map g (dropLazy b a) ++ map h (dropLazy a b)'
19:13:26 <dmwit> :t let zipWithEnd f g h a b = zipWith f a b ++ map g (dropLazy b a) ++ map h (dropLazy a b) in zipWithEnd
19:13:28 <lambdabot> (t -> a -> c) -> (t -> c) -> (a -> c) -> [t] -> [a] -> [c]
19:13:29 <cmccann> chrisdotcode: your recursive cases aren't quite right
19:14:16 <Tau> hi.
19:14:16 <jtree> it's just the functor instance for []
19:14:25 <chrisdotcode> cmccann: am I close? :D
19:14:45 <applicative> there's no such thing as a bad functor
19:14:58 <jtree> but exercise 2 in that section says it violates the first law of functors
19:15:06 <shachaf> jtree: It does.
19:15:15 <johnw> applicative: fortunately, it unsafeCoerces itself from black magic to white magic before you can see which one it truly is
19:15:16 <cmccann> chrisdotcode: what would "unevenZip [1,2] []" do?
19:15:16 <allenj12> johnw: would u know why its saying that between may not have enough arguments
19:15:17 <shachaf> jtree: That's not the real instance. It's a broken one to demonstrate how you can violate the laws.
19:15:23 <jtree> why?  it's the same as the example given above
19:15:31 <shachaf> What?
19:15:32 <johnw> allenj12: show me?
19:15:53 <applicative> jtree: whats fmap id "h" on that definition
19:16:01 <chrisdotcode> cmccann: shoot. [These [1,2] []], right?
19:16:09 <jtree> []
19:16:28 <dmwit> What's id "h"?
19:16:28 <applicative> fmap id (h:[]) = id 'h' : id 'h' : [] = "hh"
19:16:30 <cmccann> chrisdotcode: it should be [This 1, This 2]
19:16:41 <cmccann> it's a type error right now anyway
19:16:59 <chrisdotcode> oops, forgot to check it in ghci first
19:17:08 <hpaste> allenj12 pasted “parsec” at http://hpaste.org/86441
19:17:10 <jtree> ah, I think I see
19:17:16 <allenj12> johnw: up there
19:17:44 <johnw> seperator's type should be Parser String
19:18:40 <allenj12> johnw: hmm ill give it a shot
19:19:00 <applicative> "Any Haskeller worth their salt would reject this code as a gruesome abomination." byorgey is taking a pleasantly high moral line about the functor laws
19:19:23 <allenj12> johnw: same result
19:19:26 <dmwit> Really?
19:19:34 <shachaf> Violating the functor laws is not so bad.
19:19:45 <dmwit> I feel like the Functor, Monad, and Monoid laws are pretty well followed.
19:19:54 <applicative> shachaf: you will be turned into a pillar of salt!
19:19:55 <shachaf> Did you know (Prelude..)/Prelude.id isn't a category?
19:20:01 <johnw> ah, between doesn't parse just the separator
19:20:10 <johnw> between X Y parses "X...Y"
19:20:19 <cmccann> some instances follow the spirit of the law more than the letter of it, per se.
19:20:20 <dmwit> ListT is maybe the only thing I can think of that violates the laws, and that's only sometimes, and even then it's so well known that nobody uses it!
19:20:25 <johnw> so, I don't think it makes sense to pass it to sepBy
19:20:29 <mm_freak> btw, most laws are machine-checkable in principle
19:20:43 <Mortchek> shachaf, what's one example of them violating the category laws?
19:20:52 <mm_freak> apply missing arguments, reduce to NF, compare
19:20:58 <cmccann> if you ignore bottoms most things do what they should.
19:21:00 <dmwit> mm_freak: Surely not in a fully automatic way.
19:21:02 <shachaf> > (undefined :: Int -> Int) `seq` ()
19:21:04 <lambdabot>   *Exception: Prelude.undefined
19:21:04 <shachaf> > fmap id (undefined :: Int -> Int) `seq` ()
19:21:05 <dmwit> mm_freak: Some things are inductive.
19:21:06 <lambdabot>   ()
19:21:13 <Mortchek> Should seq really count? :P
19:21:14 <applicative> people have a strange enthusiasm for bashing the Monad instance in blaze-html
19:21:23 <allenj12> johnw: hmmm ill try and restructure  do i keep statement?
19:21:28 <cmccann> but instances that break the law when all inputs and outputs are non-bottom are an abomination against all that is right and good.
19:21:46 <mm_freak> dmwit: not in general, but it's possible sometimes
19:21:58 <mm_freak> for example you could check the functor laws for most functors easily
19:21:58 <dmwit> I still feel kind of skeptical.
19:22:10 <johnw> allenj12: i don't think so
19:22:17 <cmccann> mm_freak: that's why DeriveFunctor exists.
19:22:34 <johnw> you may need: statement <|> separator
19:22:38 <mm_freak> dmwit: if you know how type checking works in a dependently typed language you understand the limits of this…  as long as the code is fully inductive/coinductive you can check the laws
19:22:42 <johnw> many (statement <|> separator)
19:22:43 <cmccann> (DeriveApplicative can't exist because of ambiguity, fwiw)
19:22:43 <allenj12> johnw: o. hmmm ok
19:22:54 <mm_freak> some experimental implementation of this would be lovely
19:22:58 <johnw> that will turn "(aa(bb))bb" into "(aa(bb))" and "bb"
19:23:20 <dmwit> shachaf: Eh, I think most people only consider the laws to be necessary on total values.
19:23:44 <mm_freak> the reason i note this is that checking the MonadBaseControl laws by hand is a nightmare ;)
19:23:47 <applicative> Is there a way of isolating the specifically ziplist-like applicatives?  I was looking at the laws for mzip in Control.Monad.Zip, wondering this
19:24:11 <shachaf> The laws aren't necessary at all. They're only convenient.
19:24:15 <hpaste> allenj12 pasted “parsec” at http://hpaste.org/86442
19:24:18 <applicative>  liftM (f *** g) (mzip ma mb) = mzip (liftM f ma) (liftM g mb) -- 'naturality'
19:24:22 * shachaf is above the monoid law.
19:24:49 <applicative> liftM (const ()) ma = liftM (const ()) mb
19:24:59 <allenj12> johnw: i may be confused in what you were saying lol
19:25:00 <cmccann> shachaf: nobody will associate with someone who breaks the monoid laws!
19:25:13 <cmccann> (*rimshot*)
19:25:21 <applicative> theyre harder to break
19:25:23 <shachaf> cmccann: That's why I go by a secret identity.
19:25:34 <dmwit> Oh my gosh! We could totally name mempty m0 instead.
19:25:37 <johnw> allenj12: between does want a parser for the contents
19:25:43 <mm_freak> instance Monoid Integer where mempty = 0; mappend = (-)
19:25:46 <cmccann> yessssssss, punchline secured.
19:25:51 <johnw> between (symbol "(") (symbol ")") parenStatement
19:26:12 <shachaf> dmwit: "not to be confused with mzero"
19:26:14 <dmwit> m0 and <> would make monoids not totally embarassing to use
19:26:28 <johnw> dmwit: m0 would be quite nice!
19:26:39 <allenj12> johnw: so keep parser and add that?
19:26:43 <shachaf> instance Monoid a => Num a where fromInteger 0 = mempty
19:26:46 <johnw> just add that parameter
19:26:59 <mm_freak> is there a way to multicast a pipes Proxy to multiple consumers?
19:27:14 <ion> It’s difficult to get employed if you have broken monoid laws in the past.
19:27:15 <mm_freak> the (&&&) equivalent for pipes that is
19:27:23 <shachaf> Did y'all see my abomination the other day?
19:27:32 <shachaf> newtype Foo a = Foo { unFoo :: a }; instance Monoid a => Num (Foo a) where Foo x * Foo yf = Foo (x <> y); fromInteger 1 = Foo mempty; timesN n = unFoo . (^ n) . Foo
19:27:43 <shachaf> s/yf/y/
19:28:13 <johnw> is shachaf a monoid felon?
19:28:17 * cmccann contemplates the merits of renaming "repeat" to "zipWith0"
19:28:26 <allenj12> johnw: it still dosnt like it i really hate to ask this but can u edit the hpaste?
19:28:40 <johnw> allenj12: i'm quite buried in something just now
19:28:47 <dmwit> cmccann: yes, and map should be zipWith1
19:28:55 <ion> shachaf: Nice instance. Ninstance.
19:28:57 <allenj12> johnw: its fine ill keep trying sorry to bother so much
19:29:07 <cmccann> dmwit: right.
19:29:15 <cmccann> and pure is liftA0 of course.
19:29:32 <dmwit> yes
19:29:40 <dmwit> I have done this sometimes.
19:29:44 <cmccann> haha
19:29:53 <dmwit> Although I named them zip0, zip1, zip2, etc. not zipWith. =)
19:30:08 <shachaf> lift0 is a good name for pure.
19:30:22 <shachaf> That's the name I use for explaining some things.
19:30:33 <shachaf> join, on the other hand, is the devil.
19:31:03 <cmccann> shachaf: you should write your own book, wherein you categorize which things are and are not the devil.
19:31:13 <hpaste> chrisdotcode revised “unevenZip”: “unevenZip” at http://hpaste.org/86434
19:31:22 <chrisdotcode> cmccann: any better? :D
19:31:26 <shachaf> cmccann: The law of excluded middle states that everything is either the devil or the future.
19:31:53 <cmccann> shachaf: ok. sounds reasonable.
19:32:41 <cmccann> chrisdotcode: looks right to me. though you could simplify it slightly if you wanted.
19:32:59 <chrisdotcode> cmccann: yeah, that's the next step :-) where do I begin?
19:33:00 <cmccann> since every case but the last is just "map"
19:33:31 <dmwit> unevenZip (x:xs) (y:ys) = These x y : unevenZip xs ys; unevenZip xs ys = map This xs ++ map That ys
19:33:38 <dmwit> err
19:33:40 <dmwit> spoilers
19:33:52 <chrisdotcode> dmwit: well thanks :p
19:33:56 <dmwit> (sorry cmccann)
19:33:59 <cmccann> hahaha
19:34:18 <chrisdotcode> dmwit: but that was what I was going to go for next, so it's not that bad :)
19:34:39 <applicative> > let shoo f g m n = (,) <$> (liftM f n) <*> (liftM g n);  goo f g m n = liftM (f *** g) ((,) <$> m <*> n)  in (shoo even odd [1,2][3,4,5] == goo even odd [1,2][3,4,5])
19:34:41 <lambdabot>   False
19:34:45 <cmccann> I'd actually write the This and That cases separately. the concatenation is cute but takes a moment to figure out.
19:35:00 <dmwit> Hah!
19:35:07 <dmwit> This from the guy that likes "over here".
19:35:35 <cmccann> (mostly because it would be a bug if the cases were out of order, whereas matching [] explicitly can't)
19:35:45 <chrisdotcode> cmccann: This x = x ; That y = y; These x y = This x | That y; These x y;?
19:35:55 <dmwit> what?
19:35:56 <shachaf> chrisdotcode: What?
19:36:10 <chrisdotcode> it was worth a try... >_>
19:36:18 <shachaf> What was?
19:36:25 <dmwit> What were you trying for?
19:36:43 <chrisdotcode> cmccann said it was better to split up the This and the That cases
19:36:56 <h4199> he meant in the map
19:36:57 <cmccann> chrisdotcode: I meant in the function cases, not the type :P
19:37:08 <chrisdotcode> oops!
19:37:24 <cmccann> chrisdotcode: e.g. unevenZip xs [] = map This xs
19:37:47 <shachaf> easy as a monoid
19:37:50 <chrisdotcode> by the way, how does that work? "that" and "this" in the "These" type? are they just generic containers with any name?
19:38:12 * shachaf suspects chrisdotcode is skipping ahead a bit for this exercise.
19:38:21 <dmwit> They don't do any work.
19:38:25 <chrisdotcode> shachaf: well the exercise was finished :-)
19:38:37 <dmwit> shachaf: ADTs take a bit of getting used to, so I could imagine this confusion even if there was no skipping ahead.
19:38:37 <cmccann> chrisdotcode: the data constructors?
19:38:46 <chrisdotcode> cmccann: yeah...
19:38:52 <cmccann> @src Either
19:38:53 <lambdabot> Source not found. You type like i drive.
19:38:55 <cmccann> oh come on!
19:38:58 <cmccann> @src Maybe
19:38:59 <lambdabot> data Maybe a = Nothing | Just a
19:39:02 <dmwit> data Either a b = Left a | Right b
19:39:02 <chrisdotcode> like how does the type system know what a "that" is? or a "this", even though they're never declared?
19:39:05 <cmccann> that's just how haskell types are defined
19:39:06 * dmwit is helping!
19:39:14 <dmwit> chrisdotcode: Oh, they are declared!
19:39:33 <shachaf> I,I data Either a b = Right b | Left a
19:39:34 <applicative> hm, even ziplists violate the mzip laws?
19:39:40 <dmwit> chrisdotcode: You declared them in the top line.
19:39:59 <shachaf> chrisdotcode: The identifiers "that" and "this" haven't been mentioned anywhere.
19:40:01 <cmccann> shachaf: that's a disreputable and nonstandard ordering. you should be ashamed.
19:40:02 <chrisdotcode> dmwit: okay, so they were declared there... so they're like labels?
19:40:18 <dmwit> chrisdotcode: Yup. The jargon is "tag", but "label" isn't a bad word for what they do, either.
19:40:20 <shachaf> "That" and "This" have. Haskell is case-sensitive.
19:40:23 <dmwit> or "constructor"
19:40:39 <shachaf> "tag" is implementation jargon more than semantics jargon :-(
19:40:52 <chrisdotcode> shachaf: case sensitive, got it. thanks
19:40:54 <dmwit> Well, it's also maths jargon, as in "tagged unions".
19:40:59 <chrisdotcode> dmwit: got this as well
19:41:02 <chrisdotcode> I'm learning me a haskell! :-D
19:41:31 <shachaf> dmwit: Are you sure that's a mathses jargon?
19:41:39 <cmccann> sounds more like programming jargon.
19:41:44 <cmccann> mathy is "disjoint union".
19:41:54 <dmwit> I dunno. Isn't computer science a brand of math?
19:42:11 <shachaf> That sounds like something a computer scientist would say.
19:42:44 <dmwit> I've been told that I don't know anything about pure math. So take that under advisement.
19:43:07 <cmccann> constructivist mathematics is isomorphic to some subset of computer science.
19:43:13 <hpaste> SoupEvil pasted “Control.Arrow, Control.Applicative and Debug.Tracing” at http://hpaste.org/86444
19:43:24 <SoupEvil> duh! my extraction is really ugly, but okay...
19:43:26 <cmccann> I don't think either field subsumes the other. even under very generous assumptions.
19:43:55 * sw2wolf xmonad is really great. "emacs -geometry ..." can work only in xmonad here :P
19:44:26 * shachaf that's not how /me works.
19:45:03 <sw2wolf> oh,should switch to #xmonad :-D
19:45:21 <shachaf> That too.
19:45:34 <SoupEvil> this is my tryout to hide the tracing in an identity like arrow, but it doesn't work
19:45:40 <chrisdotcode> you know, "uneven-zip" is still nicer to read than "unevenZip"...
19:45:46 <applicative> sw2wolf: no, stay here
19:45:55 * chrisdotcode still wishes haskell supported hypen-case
19:46:21 <applicative> hyphen case, why not 'snake case'?
19:46:23 <sw2wolf> applicative: i have joined both channels
19:46:34 <applicative> ah good
19:46:59 <applicative> uneven_zip is valid haskell, chrisdotcode
19:47:18 <applicative> just don't export it :)
19:47:37 <chrisdotcode> applicative: hahaha! or, like I was saying yesterday, I'll run a vim macro when I'm done...
19:47:39 <johnw> chrisdotcode: I do not find that easier to read
19:47:44 <johnw> what you meant was, it's easier for you to read
19:47:51 * h4199 rides away on a camel
19:48:05 <chrisdotcode> johnw: but-its-easier-parsing-for-longer-names, dontYouThinkSo?
19:48:14 <johnw> no, I don't
19:48:16 <johnw> example:
19:48:22 <johnw> foo-bar-baz - baz-bar-foo - foo-bar-bz
19:48:23 <dmwit> SoupEvil: I'm... a little bit surprised that typechecks.
19:48:23 <johnw> vs.
19:48:31 <johnw> fooBarBaz - bazBarFoo - fooBarBz
19:48:34 <johnw> you tell me which is easier to scan
19:48:34 <dmwit> traceIO, but then you get something polymorphic over arrows?
19:48:34 <shachaf> chrisdotcode: Haskell allows the identifier "don'tYouThinkSo".
19:48:36 <dmwit> doesn't sound right
19:48:38 <shachaf> Don't skimp on the apostrophes.
19:48:43 * applicative defends the use of _-case for locally defined things e.g. in where clauses
19:49:36 <johnw> i've come to love the consistency of an enforced choice
19:49:36 <chrisdotcode> johnw: at that level, they're all the same. but at the semantic meaning level, zip-with looks prettier than zipWith, IMO
19:49:47 <dmwit> SoupEvil: Oh ho! I get it.
19:49:51 <applicative> only things in the top level should be camel cased, this is my new mad stylistic scheme
19:49:53 <johnw> chrisdotcode: it looks prettier to you, you mean :)
19:49:55 <ion> zip with
19:49:55 <dmwit> SoupEvil: You're constructing an IO action and immediately throwing it away. =)
19:50:04 <chrisdotcode> johnw: well I"m a pythonista originally ;-)
19:50:09 <johnw> you can't win an aesthetic argument with absolutes
19:50:11 <SoupEvil> dmwit: yes im too, i tried to extract the netwire behavior of applicative arrows
19:50:12 <applicative> good work SoupEvil
19:50:28 <natnayr> hi, would like to ask anyone about compile time type errors, trying to generate those with my code now..
19:50:31 <chrisdotcode> johnw: dare I say that I wish that haskell preferred spaces? ;)
19:50:35 <chrisdotcode> * tabs
19:50:40 <johnw> you can wish all you like!
19:50:42 <applicative> natnayr: trying to generate type errors?
19:50:52 <johnw> I won't stop you
19:50:55 <natnayr> applicative: doing GADTs now
19:51:03 <applicative> we love spaces ; the space is the most important operator
19:51:04 <chrisdotcode> johnw: I do agree, a consistent, enforced style is much better than different module-level file inconsistencies
19:51:08 <SoupEvil> so my guess is right, because of the use of (*>) it's not evaluated deeply enough to be an effective IO op?
19:51:12 <applicative> ah
19:51:15 <h4199> zIP-_-wITH, the best of all worlds
19:51:22 <dmwit> SoupEvil: totally unrelated to evaluation depth
19:51:24 <natnayr> applicative: any resources?
19:51:33 <chrisdotcode> h4199: you forgot spaces...
19:51:50 <chrisdotcode> ziP-    _    -wITH
19:51:51 <dmwit> SoupEvil: Just having an IO action lying around doesn't mean that IO is done.
19:52:14 <johnw> h4199: awesome
19:52:24 <johnw> z1p-W1th
19:52:33 <applicative> natnayr: you're having trouble generating errors, or comprehending messages?  I guess the former...
19:52:37 <applicative> it's unimaginable
19:53:15 <dmwit> SoupEvil: e.g. you could write [print 3] and it wouldn't print 3 just by evaluating the list. You have to execute it, which is separate from evaluation.
19:53:32 * applicative was reading an old scheme-related paper today, the hyphens did wear, but are somewhat more tasteful than camelcase
19:53:32 <SoupEvil> dmwit: yes, but this is why i tried to sequence applicate it with (*>)
19:53:44 <dmwit> SoupEvil: So, what traceArr is doing is this:
19:53:55 <johnw> applicative: dromedary case demands at least two capitals
19:54:11 <dmwit> 1. construct an IO action that calls traceIO 2. throw it away in favor of using the result from the right-hand-side of (*>)
19:54:25 <dmwit> Because (2) begins with "throw it away", it certainly can never be executed by main.
19:54:50 <SoupEvil> dmwit: oh yes think i get it
19:54:54 <dmwit> I feel that I am not explaining this well, but at a bit of a loss to say how to improve my explanation.
19:55:04 <BMeph_> IO /= I/o
19:55:09 * h4199 wonders if there is a way to convey intent tersely in a way that humans and parsers all understand and love
19:55:11 <cmccann> dmwit: insufficient burritos
19:55:12 <mapreduce> Use the word 'deferred' liberally.
19:55:17 <BMeph_> (or I/O). ;p
19:55:30 <dmwit> h4199: lojban?
19:55:37 <hpaste> natnayr pasted “GADTs” at http://hpaste.org/86445
19:55:50 <natnayr> applicative: here is my code..
19:56:20 <applicative> dromedary case isnt so gave an abomination as violating the monad laws, but enumFromToStepN is beyond the pale surely
19:56:39 <applicative> grave an abomination rather
19:56:46 <dmwit> SoupEvil: Perhaps you could see what's happening a bit by running something like 'map (const 5) [print 3, putStrLn "hi", getLine]' in ghci.
19:56:53 <allenj12> is it even possible to use between to seperate a parens string into a list of parens strings?
19:56:54 <cmccann> applicative: JuSt TyPe In AlTeRnAtInG cAsE!
19:57:04 <dmwit> You could even make sure the list gets evaluated fully by doing, like...
19:57:18 <johnw> let's invent a third kind of case
19:57:19 <dmwit> 'map (const 5) (deepseq [print 3, putStrLn "hi", getLine])'
19:57:21 <dmwit> or something like that
19:57:24 <johnw> lower, upper, middle
19:57:43 <johnw> then we could all compromise
19:57:52 <SoupEvil> dmwit: thx, i get it, your explanation is great ;)
19:58:01 <dmwit> ok, great =)
19:58:10 <cmccann> johnw: lower, upper, file_not_found?
19:58:51 <dmwit> allenj12: GHC parses Haskell. Haskell has parens. QED?
19:59:14 <SoupEvil> maybe i get my tracing arrow done today^^
19:59:52 <allenj12> dmwit: not sure what u are saying. i was talking about the between keyword?
20:00:01 <cmccann> it's not a keyword...
20:00:14 <h4199> dmwit: Ithkuil, the APL of con-langs
20:00:44 <allenj12> sry i ment the parsec between
20:01:21 <cmccann> h4199: what's the COBOL of con-langs?
20:02:22 <h4199> I haven't the foggiest, ζipωith
20:02:24 <bz> 6666555uuuuu
20:02:38 <bz> oops, ssh lag
20:02:53 <Eduard_Munteanu> Hopefully that's not your password. :P
20:03:39 <cmccann> probably not, it isn't "hunter2"
20:04:19 <Eduard_Munteanu> Not much more entropy than that, though.
20:04:44 <dmwit> Entropy isn't a property of a single password.
20:04:49 * hackagebot byteorder 1.0.4 - Exposes the native endianness or byte ordering of the system.  http://hackage.haskell.org/package/byteorder-1.0.4 (AntoineLatter)
20:04:56 <dmwit> For all you know, hunter2 may be drawn from a very well-behaved distribution.
20:04:57 <Eduard_Munteanu> Sure... I just mean it doesn't look random.
20:05:51 <cmccann> dmwit: a distribution like bash.org?
20:07:27 <applicative> ζιπΟυιθ
20:07:44 <parcs> hmmmmmmmmmmm
20:08:14 <applicative> λετ ζιπΟιτη = zipWith
20:08:32 <dmwit> Actually, repeating three alphanumeric characters 1-8 times each has about as much entropy as choosing a 24-character English phrase.
20:08:41 <cmccann> oh, speaking of which... http://www.bash.org/?870063
20:09:10 <dmwit> (Assuming there are 32 alphanumeric characters + 3 bits of repetition = 8 bits each, and English carries about 1 bit per character per the xkcd what-if.)
20:09:16 <Eduard_Munteanu> I wonder how eta or theta are supposed to be h's.
20:09:38 <applicative> > ζιπΟιτη = zipWith in ζιπΟιτη (,) "Πλατον" "Αριστοτες"
20:09:39 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
20:09:54 <applicative> :(
20:10:01 <Eduard_Munteanu> Aristotes? :O
20:10:03 <applicative> > let ζιπΟιτη = zipWith in ζιπΟιτη (,) "Πλατον" "Αριστοτες"
20:10:04 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
20:10:13 <dmwit> applicative: I'll help, wait a tick!
20:10:19 <applicative> so dromedary case is okay but not greek
20:11:07 <h4199> perhaps it means lambdabot wants farsi instead of Greek
20:11:12 <dmwit> < let ζιπΟιτη = zipWith in ζιπΟιτη (,) "Πλατον" "Αριστοτες"
20:11:14 <goodfellow>   [('\928','\913'),('\955','\961'),('\945','\953'),('\964','\963'),('\959','\...
20:11:37 <applicative> > let ζιπΟιτη = zipWith in ζιπΟιτη (,) "Πλατον" "Αριστοτελης" -- ρατηερ
20:11:37 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
20:11:47 <cmccann> use <
20:12:01 <applicative> < let ζιπΟιτη = zipWith in ζιπΟιτη (,) "Πλατον" "Αριστοτελης"
20:12:02 <goodfellow>   [('\928','\913'),('\955','\961'),('\945','\953'),('\964','\963'),('\959','\...
20:12:03 <geekosaur> lambdabot isn't very unicode safe
20:12:13 <dmwit> < let فارسی = zipWith in فارسی "لول" "سالم"
20:12:14 <goodfellow>   Couldn't match expected type `a0 -> b0 -> c0'
20:12:15 <goodfellow>              with actual type...
20:12:19 <applicative> awesome
20:12:23 <dmwit> < let فارسی = zipWith in فارسی (,) "لول" "سالم"
20:12:25 <goodfellow>   [('\1604','\1587'),('\1608','\1575'),('\1604','\1604')]
20:12:25 <Eduard_Munteanu> Θισ σϵϵµσ ρωνγ
20:12:33 <applicative> what arabic letters dont typecheck??
20:12:54 <dmwit> That's Farsi, mate!
20:13:02 <dmwit> Except لول, that was a joke.
20:13:07 <fruitFly> succ works on tuples but isn't when I "succ ('a', 4)
20:13:13 <Clint> yeah, لول is arabic
20:13:16 <johnw> dmwit: how is "first" a joke?
20:13:22 <fruitFly> succ ('f',7)
20:13:22 <fruitFly> error
20:13:27 <johnw> اول is used in Persian too
20:13:29 <tgeeky> @type succ
20:13:30 <dmwit> It's how you would transliterate "LOL".
20:13:30 <lambdabot> Enum a => a -> a
20:13:33 <hpaste> SoupEvil revised “Control.Arrow, Control.Applicative and Debug.Tracing”: “Control.Arrow, Control.Applicative and Debug.Trace (for the sake of completeness)” at http://hpaste.org/86444
20:13:37 <tgeeky> > succ ('f',7)
20:13:40 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Char, t0))
20:13:40 <lambdabot>    arising from a use ...
20:13:44 <tgeeky> fruitFly: I don't believe you.
20:13:48 <dmwit> johnw: اول /= لول
20:13:58 <johnw> oh, hehe
20:14:02 <johnw> I didn't see the joiner
20:14:03 <tgeeky> dmwit: like you know!
20:14:13 <applicative> ρωνγ, like violating the νομοι μοναδ--however you end it
20:14:17 <allenj12> so between in parsec dosnt seem to be able to seperate multi parenthisisized staement into a list of staments is there any other way?
20:14:18 <geekosaur> I don't see an instance for tuples
20:14:27 <Eduard_Munteanu> succ doesn't really make sense for tuples generally.
20:14:33 <johnw> http://en.wiktionary.org/wiki/لول
20:14:33 <geekosaur> ^^
20:14:40 <Eduard_Munteanu> Perhaps only if the components are Bounded too.
20:14:40 <johnw> hehe
20:14:46 <fruitFly> geekosaur: it works with a tuple with 1 member however
20:14:46 <dmwit> < dropWhile (< ('f',7)) universe
20:14:47 <goodfellow>   Couldn't match expected type `[(GHC.Types.Char, t0)]'
20:14:48 <goodfellow>              with act...
20:14:54 <cmccann> the Enum class kinda succs in general.
20:14:55 <dmwit> < dropWhile (< ('f',7)) universe :: [(Char, Word8)]
20:14:55 <geekosaur> fruitFly, there is no such thing
20:14:56 <goodfellow>   Couldn't match expected type `[(GHC.Types.Char, GHC.Word.Word8)]'
20:14:56 <goodfellow>          ...
20:15:02 <Eduard_Munteanu> Haha, lul.
20:15:02 <geekosaur> it's just a parenthesized value
20:15:19 <cmccann> what about 0-tuples
20:15:25 <cmccann> those have the best Enum instance ever
20:15:26 <tgeeky> dmwit: goodfellow is yours? What did you do? fix unicode for mueval?
20:15:27 <geekosaur> it's an oddity of Haskell, there are no 1-tuples
20:15:41 <dmwit> tgeeky: unicode isn't broken, \bot is just running in a funny locale, I think
20:15:50 <tgeeky> dmwit: ok
20:15:56 <dmwit> < dropWhile (< ('f',7)) U.universe :: [(Char, Word8)]
20:15:58 <goodfellow>   [('g',0),('_',128),('`',64),('_',129),('a',32),('_',130),('`',65),('_',131)...
20:16:02 <tgeeky> geekosaur: I don't understand why every value isn't a 1 tuple
20:16:04 <dmwit> There we go!
20:16:18 <dmwit> fruitFly: sorted, use universe instead of succ =)
20:16:24 <applicative> class Μοναδ :: ((k -> *) -> (k -> *)) -> Constraint where ...  I think I know how to get around these stale standard libraries.
20:16:25 <cmccann> tgeeky: for the same reason that (a,b,c) and (a,(b,c)) are different
20:16:37 <tgeeky> cmccann: but there are no alternate parenthizations
20:16:38 <shachaf> fruitFly: Weren't you banned?
20:16:39 <dmwit> < dropWhile (< ('f',7)) U.universeF :: [(Char, Word8)] -- if you're into that kind of thing
20:16:40 <goodfellow>   [('f',7),('f',8),('f',9),('f',10),('f',11),('f',12),('f',13),('f',14),('f',...
20:16:43 <fruitFly> @type universe
20:16:44 <lambdabot> Plated a => a -> [a]
20:16:55 <dmwit> fruitFly: wrong universe
20:16:57 <cmccann> tgeeky: sure there are. (x), ((x)), (((x)))...
20:17:01 <dmwit> ?hackage universe
20:17:01 <lambdabot> http://hackage.haskell.org/package/universe
20:17:05 <tgeeky> cmccann: right, but in Haskell they are all exactly the same
20:17:14 <tgeeky> cmccann: not that I know why, but they ar
20:17:19 <Eduard_Munteanu> χωµοναδ
20:17:32 <dmwit> tgeeky: Anyway, what I did was add universe to lambdabot. The unicode thing was just an accident.
20:17:35 <dmwit> tgeeky: Check this out:
20:17:48 <dmwit> < (==) == (/=) . not
20:17:51 <goodfellow>   True
20:17:58 <fruitFly> so succ )'t') works but not succ ('t',6) but then universe would work?
20:18:18 <applicative> class Κατηγορια :: ( k -> k -> * ) -> Constraint where ....
20:18:18 <dmwit> The simplistic and misleading answer to that question is "yes".
20:18:19 <Eduard_Munteanu> I wonder how one should name the 1-tuple projection... theoneandonly? :P
20:18:30 <cmccann> tgeeky: if there were 1-tuples I wouldn't expect (a) and ((a)) to be the same. why would they be?
20:18:41 <tgeeky> cmccann: I don't know, but they are
20:18:42 <applicative> id?
20:18:58 <Eduard_Munteanu> Well, assuming proper 1-tuples.
20:18:59 <cmccann> tgeeky: they're the same in Haskell because they aren't tuples :P
20:19:18 <applicative> unwrap?
20:19:20 <tgeeky> cmccann: they are tuples with the simplest possible nesting strategy :o
20:19:25 <dmwit> tgeeky: There's no fundamental reason Haskell doesn't have 1-tuples.
20:19:46 <dmwit> It's just not something the committee thought would be useful.
20:19:47 <applicative> it does, data OneType a = OneTuple a
20:19:51 <tgeeky> dmwit: I originally tried to argue that anything with kind * or whatever, is a 1-tuple
20:19:57 <shachaf> dmwit: It's because parentheses are overloaded.
20:19:59 <applicative> it does, data OneTupl a = OneTuple a
20:20:08 <applicative> ach
20:20:11 <dmwit> shachaf: syntax is not fundamental =)
20:20:20 <shachaf> dmwit: Yes, but that's the reason.
20:20:20 <tgeeky> @type ((((('a')))))
20:20:21 <lambdabot> Char
20:20:34 <cmccann> cf. http://hackage.haskell.org/packages/archive/OneTuple/0.2.1/doc/html/Data-Tuple-OneTuple.html
20:20:36 <shachaf> dmwit: If some sort of weird tuple brackets were used, there would be one-tuples.
20:20:38 <Eduard_Munteanu> @type ((()))
20:20:41 <lambdabot> ()
20:20:43 <geekosaur> the type system can surely handle them, there's just no syntactic construct for creating or pattern matching against them
20:20:58 <geekosaur> maybe something like python's (1,)
20:20:59 <applicative> i suupose Int is a one tuple of Int#
20:20:59 <dmwit> > read "((()))" :: ((()))
20:21:01 <lambdabot>   ()
20:21:09 <cmccann> geekosaur: oh gods, I hated that syntax.
20:21:11 <shachaf> Int# is not Haskell
20:21:12 <Eduard_Munteanu> Dayum.
20:21:18 <tgeeky> @type (#Int#)
20:21:19 <lambdabot> parse error on input `)'
20:21:51 <jfischoff> @info Int#
20:21:52 <lambdabot> (Int #)
20:22:00 <cmccann> thx lambdabot
20:22:02 <geekosaur> might even be possible to create them with TH or something
20:22:15 <h4199> ⦇⦈?
20:22:38 <dmwit> thambdabot
20:22:46 <cmccann> tgeeky: anyway, if tuples did not introduce extra non-strictness and indirection it would make some sense to think of all values as implicit 1-tuples
20:23:15 <applicative> @type (# 'a' #)
20:23:17 <lambdabot> (# Char #)
20:23:30 <applicative> nice onetuple
20:23:36 <hpaste> “Ertugrul Söylemez” pasted “Various Lucas-Lehmer primality test variants” at http://hpaste.org/86447
20:23:43 <applicative> @type (# "recursive type" #)
20:23:44 <lambdabot> (# [Char] #)
20:23:52 <tgeeky> cmccann: I suppose that is what you meant earlier. The indirection is exactly the behavior that is discarded when you collapse ((((('a')))))
20:24:21 <cmccann> tgeeky: right, and is why nesting tuples isn't truly associative
20:24:23 <applicative> @type (# (# (# () #) #) #)
20:24:24 <lambdabot>     Couldn't match kind `ArgKind' against `(#)'
20:24:24 <lambdabot>     Kind incompatibility when matching types:
20:24:24 <lambdabot>       t0 :: ArgKind
20:24:41 <cmccann> despite everyone pretending that (,) is a categorical product
20:25:03 <cmccann> or even any sort of monoid
20:25:09 * dmwit mumbles something about totality again
20:25:10 <applicative> it is if you believe it is
20:25:44 <applicative> just dont do anything with (,) that doesn't keep up appearances
20:25:48 <cmccann> you just gotta believe!
20:26:33 <Eduard_Munteanu> cmccann: why isn't it a categorical product?
20:26:33 <dmwit> > 0.029*60
20:26:35 <lambdabot>   1.74
20:27:03 <dmwit> Eduard_Munteanu: Because x /= (fst x, snd x)
20:27:07 <cmccann> Eduard_Munteanu: for reasons that were discussed moments prior. think about it.
20:27:23 <Eduard_Munteanu> Oh, bottomness?
20:27:27 <dmwit> always
20:27:47 <cmccann> figuring out all the picky little ways that _|_ undermines various nice properties is a good exercise.
20:27:49 <Eduard_Munteanu> Hm, fair. I often tend to ignore that aspect of Hask.
20:28:05 <cmccann> that way you know exactly what you are ignoring the rest of the time.
20:28:21 <shachaf> cmccann: Let's play "how many values of type Either () () -> Either () () are there?"
20:28:29 <arkeet> =(
20:28:31 <h4199> I choose ⊤
20:28:43 <cmccann> yes, most of the time "Hask" refers to the category you get by handwaving until enough _|_s go away
20:28:45 <dmwit> That game is hard.
20:28:53 <dmwit> I always lose, even after somebody else tells me how to win.
20:29:03 <arkeet> Eduard_Munteanu: well, Hask isn't a category to begin with.
20:29:19 <Eduard_Munteanu> arkeet: hm, possibly, right...
20:29:35 <Eduard_Munteanu> We usually treat it as such though.
20:29:46 <arkeet> @let foo = undefined :: () -> ()
20:29:48 <lambdabot>  Defined.
20:29:51 <arkeet> > foo `seq` ()
20:29:54 <lambdabot>   *Exception: Prelude.undefined
20:29:55 <arkeet> > foo . id `seq` ()
20:29:57 <lambdabot>   ()
20:30:01 <shachaf> Yep.
20:30:10 <Eduard_Munteanu> arkeet: you mean () isn't terminal?
20:30:16 <arkeet> I mean id isn't an identity.
20:30:24 <Eduard_Munteanu> Erm... oh.
20:30:24 <shachaf> Sure it is.
20:30:31 <shachaf> Just not for (.)
20:30:40 <arkeet> fine.
20:30:47 <shachaf> @let dot !f !g = \x -> f (g x)
20:30:47 <lambdabot>   BangPatterns is not enabled
20:30:52 <cmccann> haha
20:30:53 <cmccann> denied
20:30:58 <tgeeky> And now my brain hurts, and I don't know if any of this will ever be helpful
20:31:00 <shachaf> Fine, I'll give you even more strictness.
20:31:04 <arkeet> @let dot f g = f `seq` g `seq` \x -> f (g x)
20:31:06 <lambdabot>  Defined.
20:31:08 <shachaf> Or not.
20:31:23 <tgeeky> @type dot
20:31:25 <lambdabot>     Ambiguous occurrence `dot'
20:31:25 <lambdabot>     It could refer to either `L.dot', defined at <local>:4:1
20:31:25 <lambdabot>                           or `Control.Parallel.Strategies.dot',
20:31:30 <tgeeky> @type L.dot
20:31:31 <lambdabot> (t1 -> t) -> (t2 -> t1) -> t2 -> t
20:31:32 <shachaf> @undefine
20:31:50 <sw2wolf> @ty second
20:31:51 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
20:31:52 <dmwit> ?let semicolon f g = f `seq` g `seq` \x -> g (f x)
20:31:55 <lambdabot>  Defined.
20:31:56 <shachaf> Hmm, and with the bad Unicode support and all...
20:32:15 <cmccann> tgeeky: this is kinda getting into "how many bottoms can dance on the head of a pin" territory
20:32:19 <sw2wolf> @ty first
20:32:21 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
20:32:26 <dmwit> ?type semicolon
20:32:29 <lambdabot> (t2 -> t1) -> (t1 -> t) -> t2 -> t
20:32:31 <shachaf> @let circle = \f -> f `seq` \g -> g `seq` \x -> f (g x)
20:32:34 <lambdabot>  Defined.
20:32:36 <tgeeky> cmccann: I am just ashamed that it never occured to me that there might not be a one-tuple in haskell.
20:33:02 <arkeet> define "one-tuple"
20:33:09 <dmwit> As has been pointed out before...
20:33:12 <dmwit> ?hackage OneTuple
20:33:12 <lambdabot> http://hackage.haskell.org/package/OneTuple
20:33:26 <tgeeky> dmwit: that just increases the level of shame.
20:33:33 <cmccann> tgeeky: there's also no true identity functor, which is why return has a wonky type
20:33:40 <cmccann> isntead of the natural transformation it should be
20:33:46 <dmwit> And it's hard enough to get right that there have been four releases.
20:34:00 <cmccann> dmwit: just look at how many releases void has.
20:34:03 <Eduard_Munteanu> Lifted tuples are strange, so you shouldn't feel bad it doesn't generalize to 1 automatically.
20:34:30 <cmccann> dmwit: http://hackage.haskell.org/package/void
20:34:37 <applicative> show onetuple be a newtype or a data type?
20:34:39 <cmccann> and that's for a library whose entire purpose is to not provide any values!
20:34:54 <shachaf> cmccann: Huh? void provides several values.
20:34:59 <shachaf> E.g. absurd :: Void -> a
20:35:06 <dmwit> applicative: data type
20:35:07 <cmccann> shachaf: don't be absurd.
20:35:11 <h4199> :t absurd
20:35:14 <lambdabot> Not in scope: `absurd'
20:35:21 <dmwit> applicative: or else it loses its analog with the other n-tuples
20:35:23 <applicative> Hm the OneTuple package thinks its a data type
20:35:32 <shachaf> All the other tuples are data.
20:35:39 * Eduard_Munteanu wants   nowai :: a -> Void
20:35:51 * dmwit gives Eduard_Munteanu nowai :: a -> Void
20:35:52 <applicative> yes, but that's whats special about one tuples.
20:36:06 <dmwit> The whole point of OneTuple is that it shouldn't be special.
20:36:11 <arkeet> there's even a non-bottom value of type a -> Void
20:36:31 <cmccann> huh, void has a Data.Void.Unsafe module now
20:36:33 <Eduard_Munteanu> arkeet: um?
20:36:34 <cmccann> that sounds promising
20:36:43 <arkeet> Eduard_Munteanu: const undefined /= undefined
20:36:44 <shachaf> cmccann: I think that was my fault.
20:36:50 <shachaf> Hmm, maybe it was elliott's fault.
20:36:57 <cmccann> shachaf: that sounds entirely plausible.
20:36:59 <applicative> the idea that there is something that (a,b,c) and (a,b,c,d) both are, and that (a) might also be, is a type error in the mind
20:36:59 <Eduard_Munteanu> *sigh*
20:37:00 <arkeet> I think it's seq's fault.
20:37:01 <applicative> there
20:37:21 <lispy> Is there any reasonable way to make syntax for one tuples in haskell (reasonable in that it fits in the progression of (), ??, (a,b), (a,b,c) ...)
20:37:34 <cmccann> lispy: not really
20:37:39 <shachaf> "This is only safe for valid functors that do not perform GADT-like analysis on the argument."
20:37:39 <Eduard_Munteanu> arkeet: I thought non-bottom meant it had *some* constructor in front, in the sense of WHNF
20:37:44 <shachaf> Is that redundant?
20:37:51 <arkeet> Eduard_Munteanu: yes, a lambda is such a thing
20:37:52 <applicative> template haskell [o| 17]
20:37:55 <shachaf> I mean: Are there any valid functors that perform GADT-like analysis on the argument?
20:38:05 <arkeet> lambdas are in WHNF
20:38:20 <cmccann> shachaf: I don't immediately see why that would be impossible
20:38:21 <dmwit> applicative: Not at all. It's perfectly plausible to define 0-ary and 2-ary products and derive n-ary products from them.
20:38:23 <Eduard_Munteanu> Ah, yeah, it's a lambda.
20:38:37 <dmwit> applicative: (Or to just define n-ary products from whole cloth.)
20:38:53 <applicative> the concept n-ary is a contradiction, according to a standard type system
20:39:10 <dmwit> One might hope that if you set it up right, (a,b,c) is a 3-ary product, and (a,b,c,d) is a 4-ary product, and to hope even that (a) might be a 1-ary product.
20:39:17 <shachaf> cmccann: Is there an example?
20:39:20 <dmwit> applicative: Your type system is insufficiently rich. =)
20:39:27 <Eduard_Munteanu> k-ary?
20:39:41 <shachaf> cmccann: (I was wondering why it uses that phrasing in the first place. Certainly you don't *need* GADTs etc. to make an invalid Functor instance that breaks unsafeVacuous.)
20:39:42 <cmccann> shachaf: I can't think of one.
20:39:50 * hackagebot uuid 1.2.11 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.11 (AntoineLatter)
20:39:54 <applicative> aren't there HListy things indexed by length with enough extensions?
20:39:54 <lispy> If we had proper 1-tuples perhaps we could implement some 0-arity functions.
20:39:58 <Eduard_Munteanu> Perhaps n-ary includes hungry functions too. :/
20:40:02 <lispy> (sorry, trolling)
20:40:26 <johnw> what is the purpose of OneTuple instead of just using Identity?
20:40:32 <applicative> I think there should be negative arity functions
20:40:33 <Eduard_Munteanu> ω-ary
20:40:36 <cmccann> shachaf: actually, I'm skeptical that you could break it without fancy extensions. but maybe.
20:40:46 <shachaf> cmccann: How skeptical?
20:40:47 <dmwit> johnw: Again: OneTuple a has more values than Identity a.
20:40:54 <cmccann> shachaf: 6.3
20:40:55 <applicative> johnw: absolutely none, it a pure syntactic fantasy of our friends :)
20:41:04 <Eduard_Munteanu> applicative: interesting, how do you interpret negative arity? It has to be an argument to something?
20:41:14 <johnw> dmwit: example?
20:41:18 <applicative> hm
20:41:20 <tgeeky> Eduard_Munteanu: holes that need to be filled
20:41:26 <dmwit> johnw: OneTuple undefined
20:41:37 <dmwit> johnw: The corresponding Identity undefined is in reality just undefined.
20:41:44 <johnw> i see
20:41:59 <lispy> I think negative arity would have to correspond to data
20:42:10 <lispy> In the way that functions have a negative position
20:42:12 <applicative> dmwit is really needing that extra 'value'
20:42:20 <cmccann> presumably, nesting a tuple of negative arity inside another should be positive.
20:42:30 <arkeet> laziness is why we can't have nice things. =(
20:42:31 <Eduard_Munteanu> I guess -1-ary stuff should be nothing, if 0-ary is some value with no args?
20:42:31 <dmwit> lispy: Have you seen the "rational types" paper that discusses negative and fractional types?
20:42:41 <lispy> dmwit: oh, I meant to read that
20:42:53 <dmwit> It's a lot of fun. =)
20:43:03 <Eduard_Munteanu> I want to read that sometime too.
20:43:25 <applicative> pi types might be given a new and unusually interpretation
20:43:28 <dmwit> I've got an implementation of the paper on my github, done with a couple other people from in here.
20:43:29 <shachaf> cmccann: data Iso a b = Iso (a -> b) (b -> a); instance Functor (Iso a)?
20:43:32 <applicative> unusually silly
20:43:33 * cmccann personally likes seeing continuations as negated types but that doesn't really work with multiplication here.
20:43:57 <dmwit> jfischoff and tgeeky, I think
20:44:18 <cmccann> shachaf: how would that instance work?
20:44:19 <jfischoff> yep
20:44:24 <shachaf> cmccann: undefined
20:44:44 <cmccann> shachaf: that's a dumb instance then.
20:44:46 <applicative> oh, so Iso a 'is' a functor
20:44:54 <shachaf> cmccann: Yes, but it's undefined-dumb, not unsafeCoerce-dumb.
20:45:23 <dmwit> unsafeCoerce undefined = undefined, surely
20:45:25 <lispy> I ran into an inlining bug in GHC today where compiling with profiling and inlining caused GHC to need gigs of ram
20:45:32 <lispy> anyone heard of anything like that?
20:45:36 <shachaf> dmwit: The definition of fmap isn't even used.
20:45:37 <lispy> I wasn't sure if this was a new bug
20:45:57 <shachaf> dmwit: We have unsafeAbsurd :: Functor f => f Void -> f a; unsafeAbsurd = unsafeCoerce
20:46:07 <shachaf> s/Absurd/Vacuous/g
20:46:11 <dmwit> I see, I wasn't following along.
20:46:12 <dmwit> Sorry.
20:46:53 <cmccann> unsafeAbsurd :: Void -> a; unsafeAbsurd = unsafeCoerce
20:47:15 <dmwit> looks like safeAbsurd to me
20:47:46 <cmccann> maybe I should use unsaferCoerce instead.
20:48:00 <shachaf> @quote unsafeCoerce
20:48:00 <lambdabot> roconnor says: unsafeCoerce isn't even safe
20:48:09 <shachaf> @quote unsafeCoerce
20:48:09 <lambdabot> edwardk says: this breaks my previous record of 6 unsafeCoerce's in a line
20:48:21 <dmwit> reallyUnsafeCoerce = unsafePerformIO (deleteHardDrive >> return undefined)
20:48:42 <Eduard_Munteanu> If f is a cocontinuous endofunctor, I guess that makes sense? f 0 = 0, 0 -> whatever
20:48:42 <cmccann> what package is deleteHardDrive from?
20:49:01 <dolio> dmwit: unsafePerformIO (deleteHardDrive >> return unsafecoerce)
20:49:09 <dmwit> It was patched out of the "safe" package just before they hit 1.0
20:49:17 <cmccann> dmwit: makes sense.
20:49:25 <Eduard_Munteanu> I wonder, are Hask functors all (co)continuous perhaps?
20:51:03 <Eduard_Munteanu> (and sure, feel free to ignore bottoms)
20:53:55 <johnw> what is the best FFI function for initializing a block of Ptr CChar to 0?
20:54:16 <johnw> it seems that alloca is giving me uninitialized memory
20:54:20 <shachaf> memset?
20:54:24 <lispy> johnw: calloc, look in missing-ffi
20:54:36 <shachaf> Ah, not that sort of "FFI function".
20:54:45 <lispy> johnw: oh, sorry wrong name: http://hackage.haskell.org/package/missing-foreign-0.1.1
20:54:52 <johnw> ah, thanks lispy
20:55:02 <dolio> [(a, b)] is not isomorphic to ([a], [b]), so it's not continuous.
20:55:04 <johnw> memset would work too
20:55:05 <twoolie> hey, does anyone know of a site that has haskell practice questions in a range of difficulties?
20:55:14 <johnw> oh, missing-foreign is your package, lispy!
20:55:24 <shachaf> lispy: calloc calls libc "calloc", so it's not a replacement for alloca
20:55:32 <Eduard_Munteanu> dolio: hm, I see, thanks
20:55:33 <johnw> yeah, sadly it's not
20:55:42 <johnw> but I am in ResourceT, so setting up a finalizer is no problem
20:56:10 <lispy> it's not a replacement for alloca but alloca doesnt' zero things out either
20:56:24 <dolio> And r -> Either a b is not isomorphic to Either (r -> a) (r -> b), so it's not cocontinuous.
20:56:41 <lispy> johnw: also, if you're allocating a lot it could overflow the CSize
20:56:54 <dolio> I guess list is not cocontinuous, either.
20:56:55 <cmccann> dolio: it would be pretty handy if that did work though.
20:56:55 <lispy> johnw: real calloc that implements it takes 2 arguments.
20:57:01 <johnw> lispy: statsPtr <- liftIO $ flip allocate free calloc
20:57:10 <johnw> it's a very tiny structure, I could just use poke twice
20:57:21 <johnw> oh, heh, don't need flip
20:57:24 <lispy> johnw: the per item size and the total number of items. I just cheated and say, "eh, item size is 1 byte"
20:57:34 <johnw> (_,statsPtr) <- liftIO $ allocate calloc free
20:57:49 <shachaf> lispy: You should make the number of items be 1 instead!
20:57:54 <lispy> johnw: you'll get better performance writing a wrapper for alloca though.
20:57:55 <johnw> grr, s/liftIO $ //
20:58:03 <johnw> this isn't performance intensive
20:58:08 <lispy> okay
20:58:11 <johnw> if people are writing that many pack files out, they have other problems
20:58:20 <shachaf> "a wrapper for alloca"?
20:58:26 <shachaf> Oh, you mean for Haskell alloca, not for C alloca.
20:58:51 * lispy nods
20:59:02 <shachaf> I would agree.
20:59:05 <johnw> thanks lispy, dependency added
20:59:09 <dmwit> Why does calloc take two arguments?
20:59:18 <johnw> object size, object count
20:59:19 <copumpkin> cause multiplication is hard
20:59:22 <dmwit> Was that just a bad decision?
20:59:23 <shachaf> It is one of the great mysteries of the world.
20:59:30 <johnw> well, that's really a good question
20:59:44 <johnw> i *suppose* it's because objects don't have to be contiguous in all memory models
21:00:02 <copumpkin> http://stackoverflow.com/questions/4083916/two-arguments-to-calloc
21:00:03 <johnw> but who knows, the C committee debates minutae that I can barely comprehend
21:00:14 <lispy> It's for the reason copumpkin mentioned
21:00:21 <johnw> cool
21:01:25 * dmwit feels spoiled by a language with good bignum support
21:01:49 <lispy> Those functions should really be in base somewhere, but I was too lazy to make a library proposal.
21:01:56 <shachaf> dmwit: Which language are you talking about?
21:02:03 * cmccann feels spoiled by a language with good programming support
21:02:17 <shachaf> cmccann: Now you're just making things up.
21:02:30 <dmwit> Oh, I guess there are alignment considerations, too. Not that they apply to calloc, but I definitely would have been tripped by that.
21:02:30 <lispy> cmccann: depends on what type of programming you're doing. I was really struggling to get good numeric performance today :)
21:02:52 <cmccann> lispy: numbers are overrated anyhow.
21:03:02 <cmccann> lispy: anyway you should join the party in #haskell-game.
21:03:09 <cmccann> which is not very party-ish right now I guess.
21:03:59 <dmwit> shachaf: Do you consider Haskell's bignum support lacking?
21:04:29 <shachaf> dmwit: Well, given that all these functions take Int arguments...
21:04:36 <cmccann> pf, it doesn't support large cardinals. you call that big?
21:05:21 <dmwit> Hm. I guess in this context it's hardly fair to divorce the language and the standard library. So maybe you have a point.
21:05:37 <rs0> twoolie: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
21:05:55 <twoolie> thanks rs0
21:05:59 <shachaf> dmwit: In particular we're talking about the FFI here. Nothing in the FFI uses Integer as far as I know.
21:06:32 <dmwit> rs0: I wouldn't really say those have a range of difficulties, though. I vaguely recall that all of those were pretty easy in the grand scheme of things.
21:06:42 <dmwit> shachaf: I wasn't talking about the FFI.
21:06:44 <shachaf> cmccann: I demand that inaccessible cardinals be made accessible as per the ADA.
21:06:49 <dolio> Which parts of the FFI?
21:07:09 <cmccann> shachaf: you should file a complaint.
21:07:12 <dolio> Like, array dereference?
21:07:36 <dmwit> I think I would still make the claim that Haskell makes it relatively easy to pick the right type, so that if you need an unbounded number it's not a lot of programmer overhead to use what you need.
21:07:46 <fruitFly> head' (x:_) = x   why does it have to be in parens?
21:08:00 <dmwit> Instead of hacking it by making your function take two bounded numbers and hoping that's enough. =P
21:08:01 <cmccann> replicate should take an Integer argument, to handle those cases where I want a finite list longer than maxBound::Int.
21:08:17 <rs0> twoolie: there's also http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
21:08:19 <dmwit> fruitFly: So that you can tell where one pattern ends and the next one starts.
21:08:55 <dmwit> fruitFly: e.g. should "x:Foo bar baz" be "(x:Foo bar) baz" or all one pattern?
21:09:03 <fruitFly> dmwit: ? so haskell would get confised by the equal sign following?
21:09:18 <dmwit> Nope, nothing to do with the equal sign.
21:09:40 <hpaste> “Ertugrul Söylemez” pasted “Various Lucas-Lehmer primality test variants (again)” at http://hpaste.org/86449
21:09:53 <dmwit> Everything to do with knowing how to parse a pattern without explicitly knowing how many arguments each constructor takes.
21:10:18 <dmwit> (Since knowing the latter is a context-sensitive thing and that's frowned upon in grammars.)
21:10:19 <fruitFly> dmwit: so without the parens what would it think in that statment
21:10:54 <dmwit> fruitFly: It could think many things. It could think head' was a function of three arguments, binding one to x, matching the other against the constructor :, and throwing away the third.
21:11:00 <cmccann> dmwit: because there aren't any programming languages out there with context-sensitive grammars
21:11:11 <dmwit> I didn't say that! Don't put words in my mouth.
21:11:19 <cmccann> :]
21:11:23 <dmwit> I'm wrong often enough without people lying for me. =P
21:11:59 <parcs> > [ x | !x <-  [1,2,undefined] ] `seq` ()
21:12:01 <lambdabot>   ()
21:12:46 <dmwit> hm
21:12:49 <fruitFly> dmwit: what is the constructor
21:12:56 <dmwit> > let test ((:) x y) = x in test [1..5]
21:12:57 <lambdabot>   1
21:13:01 <dmwit> oh, fun
21:13:17 <dmwit> fruitFly: You haven't learned what constructors are yet?
21:13:39 <fruitFly> dmwit: i'm sure I know... just not by name.. started lyah haskell today
21:14:33 <dmwit> Okay. Constructors are the building blocks of a given data type.
21:14:40 <dmwit> Lists have two constructors, (:) and [].
21:14:58 <fruitFly> ok
21:15:03 <dmwit> Constructors are special (compared to arbitrary functions) because they can be used in pattern matches.
21:15:28 <fruitFly> dmwit: why not just : and [] .. why it in oarens?
21:15:32 <dmwit> So, I could write, e.g. f (x:xs) = ...; but not f (xs ++ ys) = ...; becuase (++) is not one of list's constructors.
21:15:33 <h4199> f (:) x y /= f ((:) x y) and that is the essence of your question
21:16:01 <fruitFly> dmwit: sure ok
21:16:03 <dmwit> fruitFly: Well, that's just a habit I've gotten into. Infix functions go in parens when they're alone. =P
21:16:16 <fruitFly> ok
21:16:30 <dmwit> OK.
21:16:36 <dmwit> Now, you and I know that (:) takes two arguments.
21:16:47 <dmwit> But we'd like to design a parser that can work without this knowledge.
21:16:48 <fruitFly> the head and the tail
21:17:06 <dmwit> So that it can work with ((:) x y z) and ((:) x y) equally well, and signal an error later if one of them is wrong.
21:17:56 <dmwit> ...and, for infix constructors...
21:17:58 <fruitFly> dmwit:  what is ((:)xy)
21:18:11 <fruitFly> what is that trying to sugnify?
21:18:15 <dmwit> That's the prefix version of the pattern (x : y).
21:18:28 <fruitFly> dmwit: oooh ok
21:18:28 <dmwit> All infix functions can be turned prefix by surrounding them with parens.
21:18:29 <johnw> fruitFly: \z -> xy:z
21:18:38 <johnw> unless you meant x y
21:18:41 <dmwit> he did
21:18:58 <fruitFly> got it!
21:19:02 <dmwit> great!
21:19:54 <fruitFly> just got the infix to prefix thing.. but back to the original example..
21:20:19 <dmwit> aha
21:20:34 <dmwit> Anyway, let's discuss a slightly different example.
21:20:43 <dmwit> Let's use the constructor name Foo, which is already prefix.
21:20:44 <fruitFly> ok
21:21:06 <dmwit> Now, the question is why we should write "head' (Foo x y) = ..." instead of "head' Foo x y = ...".
21:21:21 <dmwit> Suppose we allowed the latter.
21:21:51 <fruitFly> hmm.. thinking
21:21:52 <h4199> fruitFly, the pattern you are using has 3 things in it, and without the parens the parser will treat them separately, and you don't want that
21:21:56 <dmwit> There's at least three "good" ways we could insert parentheses on the latter one.
21:22:35 <dmwit> We could convert it to "head' (Foo x y)" (the desired one), or "head' (Foo x) (y)" (making a two-argument function), or "head' (Foo) (x) (y)" (making a three-argument function).
21:22:50 <dmwit> We can disambiguate between these unless we know something more about Foo.
21:22:57 <dmwit> This is a Bad Design Choice.
21:23:20 <dmwit> So instead of allowing "head' Foo x y = ..." and trying to guess which parenthesization the programmer meant, we just require the programmer to say which one he meant by parenthesizing.
21:23:41 <GeneralMayhem> that seems like a hand-wave explanation
21:23:54 <GeneralMayhem> why can't we tell that Foo is a constructor, and treat constructors differently?
21:24:04 <dmwit> We can tell Foo is a constructor!
21:24:10 <dmwit> And we do treat Foo differently.
21:24:20 <GeneralMayhem> i'm confused then
21:24:24 <dmwit> The question is, how do we treat "x" and "y"? Are they arguments to Foo or to head?
21:24:44 <GeneralMayhem> right, and what I'm saying is that the natural (imo) reading is to send them to Foo
21:24:50 <GeneralMayhem> unless otherwise stated
21:25:00 <GeneralMayhem> i.e. (Foo) x y
21:25:10 <dmwit> That's another choice, for sure.
21:25:14 <GeneralMayhem> ah, but i guess that doesn't work, does it
21:25:19 <GeneralMayhem> because (Foo) == Foo
21:25:24 <GeneralMayhem> so that doesn't really disambiguate anything
21:25:26 <GeneralMayhem> nvm
21:25:30 <dmwit> But, as you say, that leads to some oddities. =)
21:25:55 <GeneralMayhem> it just always feels like pattern-matching against a data constructor could be smoother
21:26:09 <GeneralMayhem> it's a common enough thing that having to manually bracket it feels kludgy
21:26:16 <cmccann> just define your function infix.
21:26:20 <cmccann> and have no more than two arguments.
21:26:25 <GeneralMayhem> lol
21:26:33 <cmccann> "Foo a b `bar` Baz c = ..."
21:26:42 <cmccann> problem solved!
21:28:05 <natnayr> >:t *
21:28:41 <fruitFly> dmwit:  GeneralMayhem  cmccann  so basically haskell doesn't prioritize parameters to adjacent functions... you must explicitly parens dat bitch
21:29:17 <natnayr> :t *
21:29:19 <lambdabot> parse error on input `*'
21:29:28 <tgeeky> @kind *
21:29:29 <GeneralMayhem> correct
21:29:30 <lambdabot> parse error on input `*'
21:29:31 <cmccann> application is left-associative and binds very strongly. nice. simple. consistent.
21:29:38 <GeneralMayhem> in your example, Foo is itself a value
21:29:46 <GeneralMayhem> of type a -> b -> Foo or something similar
21:29:49 <natnayr> :t a
21:29:51 <lambdabot> Expr
21:30:04 <GeneralMayhem> so that value is consumed as the first argument to head
21:30:06 <natnayr> ive a provided code with * in it's definition
21:30:07 <fruitFly> head' (x:_) = x
21:30:11 <fruitFly> was the original example
21:30:46 <fruitFly> ^
21:31:48 <GeneralMayhem> looks fine to me
21:31:58 <GeneralMayhem> so long as you also specify something for head' []
21:32:01 <h4199> @kind Expr
21:32:01 <fruitFly> so even if you defined head to be head' :: [a] -> a you still couldn't omit the parens
21:32:02 <lambdabot> *
21:32:13 <dmwit> :t (*)
21:32:14 <lambdabot> Num a => a -> a -> a
21:32:21 <dmwit> All y'all trippin'.
21:32:37 <fruitFly> since it knows it should get 1 parameter
21:32:55 <dmwit> Oh, really?
21:32:56 <fruitFly> dmwit: u c wut i saying
21:32:59 <dmwit> > head [id] 3
21:33:00 <lambdabot>   3
21:33:06 <dmwit> don't look like no one parameter to me
21:33:16 <GeneralMayhem> oh shit
21:33:18 <GeneralMayhem> haskell'd
21:33:18 <fruitFly> head' :: [a] -> a
21:33:36 <dmwit> > let head' :: [a] -> a; head' = head in head' [id] 3 -- same thing
21:33:38 <lambdabot>   3
21:33:54 <dmwit> Anyway, that's not the point.
21:33:57 <fruitFly> head in head?
21:34:05 * tgeeky is beginning to think the 'yo dawg' guys would have a field day with haskell
21:34:11 <GeneralMayhem> he's just saying that your head' is the same as Prelude's head
21:34:12 <h4199> he doesn't know lets
21:34:23 <dmwit> The point is that the less the parser knows the better.
21:34:33 <dmwit> Since you want to parse long before you do scope-checking, type-checking, etc.
21:34:50 <dmwit> So it's a good idea to design your grammar with a really dumb parser in mind.
21:34:55 <fruitFly> head' x:_ = x
21:35:01 <fruitFly> how many inputs does that have?
21:35:02 <fruitFly> ^^
21:35:10 <GeneralMayhem> how many inputs does what have?
21:35:22 <dmwit> fruitFly: Are you asking how that's parsed by Haskell's current parser?
21:35:27 <GeneralMayhem> all functions in haskell take 1 or 0 arguments
21:35:36 <arkeet> things that take 0 arguments aren't functions
21:35:41 <dmwit> If so, the answer is that it's parsed as three separate patterns.
21:35:50 <GeneralMayhem> fair
21:35:51 <GeneralMayhem> ok
21:35:57 <GeneralMayhem> all functions take 1 argument
21:35:57 <fruitFly> ok
21:36:06 <GeneralMayhem> and return either another 1-arg func or a value
21:36:26 <GeneralMayhem> but you could also say that values are a special case of functions
21:36:27 <arkeet> functions are values
21:36:33 <arkeet> no, it's the other way
21:36:34 <dmwit> ...and then we discover that the middle one isn't really a valid pattern later, when we check what the : constructor is supposed to do.
21:36:46 <GeneralMayhem> arkeet: it amounts to the same thing
21:36:49 <arkeet> no
21:36:57 <shachaf> GeneralMayhem: No, it doesn't.
21:37:07 <shachaf> A function is a thing that has type A -> B for some types A and B.
21:37:38 <dmwit> GeneralMayhem: You *can* set up your definitions however you like. However, the overwhelming convention is set up differently than what you're saying.
21:37:42 <fruitFly> dmwit: ok so u just have to be super explicit for this dumb asss parser
21:37:58 <dmwit> That's about the size of it.
21:38:53 <cmccann> being dumb and explicit is pretty much why parsers exist.
21:39:01 <cmccann> that why they're useful.
21:39:34 <dmwit> Yes. If you don't separate things properly, you get TeX.
21:39:35 <fruitFly> so how much can haskell do... do you think it's where one starts in order to save the world?
21:39:38 <dmwit> *shudder*
21:40:01 <lispy> ?faq Can Haskell save the world?
21:40:01 <lambdabot> The answer is: Yes! Haskell can do that.
21:40:02 <dmwit> fruitFly: Perhaps that's a question for a more philosophical channel.
21:40:12 <dmwit> But do continue asking technical questions here, and we'll do our best to answer.
21:40:21 <fruitFly> pff
21:40:35 <fruitFly> i like lambdabot.. i think he knows what's going on
21:40:51 <fruitFly> ?faq can haskell do dmwit
21:40:52 <lambdabot> The answer is: Yes! Haskell can do that.
21:40:58 <dmwit> NICE
21:40:59 <fruitFly> ;)
21:40:59 <goodfellow> Maybe you meant: ft rc
21:41:12 <dmwit> hm
21:41:15 <cmccann> heh
21:41:20 <dmwit> Seems there's no good prefix to choose.
21:41:34 <cmccann> how about ☃.
21:41:44 <dmwit> hah! Would that even work?
21:41:45 <tgeeky> dmwit's wife will be jealous; but once you're hooked on lambdas, you're hooked for life
21:41:46 * dmwit tries it
21:41:54 <fruitFly> so dmwit wut u using haskell for... why u aint exuding more pash bro
21:42:02 <dmwit> < ord '☃'
21:42:04 <goodfellow>   9731
21:42:07 <fruitFly> how powerful is haskell really compared to other spells?
21:42:14 <fruitFly> other types* of spells
21:42:25 <fruitFly> pash = passion
21:43:07 <tgeeky> dmwit is a graduate student. Their passion is leeched away from them systematically.
21:43:16 <dmwit> =(
21:43:26 <dmwit> ;quit
21:43:32 <fruitFly> so how powerful is hask
21:43:40 <Nisstyre> tgeeky: is it a good sign when practically every TA I have did their undergrad at the same place they're doing their graduate degree?
21:43:57 <tgeeky> Nisstyre: depends on if those school suck or not
21:43:58 <fruitFly> ive heard it's one of the best skills if one is interested in computing..... anything
21:44:01 <dmwit> ☃tick W
21:44:04 <Nisstyre> tgeeky: I don't think it sucks at all
21:44:14 <tgeeky> Nisstyre: sounds good to me, then
21:44:17 <h4199> < ord ☕
21:44:19 <goodfellow>   <hint>:1:6: parse error (possibly incorrect indentation)
21:44:33 <dmwit> Hm. Well, it doesn't work. But maybe that's a good thing, too.
21:44:38 <h4199> < ord '☕'
21:44:39 <goodfellow>   9749
21:44:42 <tgeeky> that looks like the java logo to me
21:44:52 * hackagebot warp 1.3.8.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.8.1 (MichaelSnoyman)
21:45:07 <cmccann> dmwit: alas no snowman :[
21:45:17 <dmwit> Nisstyre: I think it's pretty normal to advise students not to do that.
21:45:23 <dmwit> things get a bit incestuous
21:45:34 <Nisstyre> dmwit: yeah it seemed like you'd want some variation
21:45:37 <dmwit> right
21:45:40 <tgeeky> bah!
21:45:50 <dmwit> cmccann: Anyway, I think I'll leave it.
21:45:53 <tgeeky> better stay at a place which has a healthy organization than go to a place with an unknown organization
21:45:59 <dmwit> Not responding to any commands is what I wanted in the first place. =P
21:46:17 <h4199> there will always be ☃
21:46:25 <cmccann> dmwit: all's well that ends well!
21:46:37 <tgeeky> cmccann: except if you sleep with your own grandmother.
21:46:52 <dmwit> And since I'm the only admin, I can make goodfellow ☃quit in... OTHER ways.
21:46:57 * dmwit tries to sound sinister and fails
21:46:58 <fruitFly> is _ a key variable... do things actually not bind to it making it more efficient to use?
21:47:07 <h4199> Oh I thought it was a spider... ignore me
21:47:08 <dmwit> fruitFly: not more efficient, but it is special, yes
21:47:15 <cmccann> tgeeky: I'm sure that somewhere in the world there is someone who would disagree with that statement
21:47:38 <fruitFly> dmwit: does it make a computational difference... or is it just "good practice to use"
21:47:40 <tgeeky> cmccann: I don't think "doesn't matter; had sex" applies in that case.
21:47:41 <cmccann> h4199: http://unicodesnowmanforyou.com/
21:47:43 <dmwit> fruitFly: It is special in that you can have it many times in a single binding.
21:47:48 <dmwit> fruitFly: It makes no computational difference.
21:48:16 <h4199> yay!
21:48:30 <fruitFly> dmwit:  many times in a single binding?!?!?!
21:48:42 <johnw> fruitFly: unless you have some more specific questions to ask, I would ask that you try #haskell-blah; this channel is starting to feel a bit defocused now
21:48:46 <dmwit> > let proof (_:_) = 3 in proof "PROOF!"
21:48:47 <lambdabot>   3
21:49:01 <dmwit> johnw: These questions feel pretty specific to me.
21:49:17 <johnw> asking how powerful Haskell's spells are?
21:49:24 <dmwit> Asking whether '_' is special.
21:50:55 <dmwit> hm
21:51:02 <dmwit> < ord '☃'
21:51:03 <goodfellow>   9731
21:51:04 <GeneralMayhem> :t .
21:51:06 <lambdabot> parse error on input `.'
21:51:09 <dmwit> < 9731 :: Word8
21:51:10 <goodfellow>   3
21:51:12 <GeneralMayhem> :t (.)
21:51:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:51:52 <Nisstyre> :t (.) (.)
21:51:54 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
21:52:18 <Ghoul_> anyone know how to stop parsec from parsing >-x as >- (x) and rather as >(-x) using the expression engine?
21:52:20 <dmwit> I'm having a bit of trouble getting my IRC client to send a 3-byte. =)
21:52:43 <fruitFly> dmwit: let proof (_:_) = 3 in proof "PROOF!"
21:52:57 <fruitFly> how does (_:_) = 3 ?
21:53:05 <Nisstyre> it doesn't
21:53:10 <dmwit> fruitFly: This is defining a function named proof which takes one argument.
21:53:24 <dmwit> fruitFly: Much like "head (x:xs) = x", except using "_" in place of both "x" and "xs".
21:53:28 <Nisstyre> it's a constant function essentially
21:53:30 <fruitFly> dmwit: are you just saying that I can just repeat to mean variables I don't care about?
21:53:37 <dmwit> yes
21:53:57 <fruitFly> dmwit: couldn't I just use z instead of _, right?
21:54:03 <Nisstyre> you could
21:54:07 <fruitFly> and do z:z instead?
21:54:09 <dmwit> fruitFly: You can, but you can only use it once.
21:54:10 <fruitFly> ok
21:54:12 <tgeeky> you can't do that
21:54:13 <GeneralMayhem> but then you have to keep coming up with more letters
21:54:13 <dmwit> fruitFly: No, that you can't do:
21:54:20 <Ghoul_> (z:zs) would only match lists 1 or longer
21:54:20 <GeneralMayhem> z:zs
21:54:21 <fruitFly> but people just think _ is NICE, right
21:54:22 <dmwit> > let proof (z:z) = 3 in proof "PROOF!"
21:54:23 <lambdabot>   Conflicting definitions for `z'
21:54:24 <lambdabot>  Bound at: <interactive>:1:12
21:54:24 <lambdabot>            <i...
21:54:30 <Nisstyre> (z:z')
21:54:30 <fruitFly> there's no computational difference
21:54:30 <Ghoul_> would (_,_) match [] ?
21:54:40 <GeneralMayhem> not with a comma
21:54:40 <tgeeky> if you want: (a:b:c:d:e), but you don't use b,c,d,or e, don't you think your compiler should warn you?
21:54:44 <dmwit> Ghoul_: no
21:54:45 <GeneralMayhem> commas make tuples, not list
21:54:52 <Ghoul_> Oh, right, pretend its a :
21:54:58 <dmwit> Ghoul_: still no
21:55:00 <GeneralMayhem> i think the answer is still no
21:55:23 <GeneralMayhem> []:[]
21:55:27 <GeneralMayhem> > []:[]
21:55:29 <lambdabot>   [[]]
21:55:31 <cmccann> but ~(_:_) will match []!
21:55:33 <Ghoul_> lol
21:55:44 <Ghoul_> > []:[]:[]
21:55:46 <lambdabot>   [[],[]]
21:55:46 <tgeeky> Ghoul_: what do you think []:[]:[] will do?
21:55:54 <Ghoul_> That's ... interesting.
21:56:12 <Nisstyre> > [] : ([]:[])
21:56:14 <lambdabot>   [[],[]]
21:56:21 <fruitFly> ok so you can repeat _ but not the others? ... so then _ does have some inherent use then
21:56:31 <dmwit> > 0:0:[]
21:56:33 <lambdabot>   [0,0]
21:56:36 <GeneralMayhem> you never HAVE to use _
21:56:37 <Nisstyre> > ([]:[]):[]
21:56:39 <lambdabot>   [[[]]]
21:56:44 <GeneralMayhem> it's just easier than making up throwaway var names
21:56:46 <GeneralMayhem> and easier to read
21:57:21 <fruitFly> GeneralMayhem: ok so you can repeat _ but not the others?"
21:57:30 <GeneralMayhem> yes
21:57:33 <dmwit> And, as tgeeky pointed out, it's a piece of documentation to your fellow programmers that happens to be in a machine-readable form.
21:57:36 <GeneralMayhem> that's been said a couple times now
21:57:38 <fruitFly> OK. then man makes sense
21:57:39 <Nisstyre> fruitFly: you can't bind two things to the same name in the same scope
21:57:44 <GeneralMayhem> can be bound multiple times in the same scope
21:57:47 <Nisstyre> but _ doesn't bind anything
21:57:54 <Nisstyre> so it doesn't have that restriction
21:57:54 <GeneralMayhem> which means, you can use it multiple times to match different things
21:58:00 <tgeeky> fruitFly: imagine that "_" stands for "an endless supply of unique variable names that you promise never to actually use, and so can be ignored"
21:58:21 <fruitFly> 100% got it guys... yall r the shits
21:58:23 <dmwit> > '\3'
21:58:25 <lambdabot>   '\ETX'
21:59:10 <dmwit> I feel like I (personally) ought to be capable of sending "\3quit".
21:59:24 <Ghoul_> dude, think back to college or whatever
21:59:26 <Nisstyre> dmwit: are you trying to h4x0r lambdabot?
21:59:29 <Ghoul_> when they give you a really hard paper with blanks
21:59:31 <dmwit> I'm, like, a big bad computer science dude, right?
21:59:36 <Ghoul_> and you just wanna write random shit in them to show you tried
21:59:41 <dmwit> Nisstyre: nah, I'm trying to haxor goodfellow
21:59:59 <Nisstyre> oh ok
22:00:19 <monochrom> < "\3quit"
22:00:21 <goodfellow>   "\ETXquit"
22:00:41 <monochrom> what is the significance of \3 there?
22:00:45 <dmwit> I have a cunning plan.
22:00:50 <monochrom> good!
22:01:04 <cmccann> I have a punning clan.
22:01:15 <dmwit> < fromIntegral (ord '☃') :: Word8 -- monochrom
22:01:16 <goodfellow>   3
22:01:31 <monochrom> hrm, is 3 important?
22:01:42 <Ghoul_>  /nick boo
22:01:44 <dmwit> < chr (ord '☃' + (ord 'a' - 3))
22:01:45 <goodfellow>   '\9825'
22:01:48 <Ghoul_> Yeah, theres a space at the start
22:01:54 <monochrom> but at least, for a change, a bot that accepts utf-8!
22:01:54 <Ghoul_> You can't send any commands from it
22:02:19 <dmwit> monochrom: I have set goodfellow's command prefix to be unicode snowman. It doesn't work. I am wondering what is happening in goodfellow's brain.
22:02:31 <cmccann> it's a good prefix.
22:02:41 <dmwit> Now I will set goodfellow's command prefix to be \9825 and see if a works.
22:02:56 <monochrom> < let 甲 = 4 in 甲+5
22:02:57 <goodfellow>   9
22:03:29 <dmwit> actually
22:03:30 <arkeet> 由
22:03:35 <dmwit> < chr (ord '☃' + (ord ';' - 3))
22:03:36 <goodfellow>   '\9787'
22:03:48 <monochrom> interesting problem
22:03:48 <arkeet> < text
22:03:50 <goodfellow>   No instance for (Data.Universe.Finite [GHC.Types.Char])
22:03:50 <goodfellow>    arising from a u...
22:04:00 <arkeet> < text '\9787'
22:04:02 <goodfellow>   Couldn't match expected type `GHC.Base.String'
22:04:02 <goodfellow>              with actual typ...
22:04:04 <monochrom> Universe.Finite? :)
22:04:04 <arkeet> < text "\9787"
22:04:06 <goodfellow>   ☻
22:04:13 <dmwit> < (==) == (/=) . not
22:04:14 <arkeet> < text "\9825"
22:04:17 <goodfellow>   mueval-core: Time limit exceeded
22:04:17 <goodfellow>   ♡
22:04:21 <dmwit> < min
22:04:22 <goodfellow>   [((),[((),())])]
22:04:25 <dmwit> < (==) == (/=) . not
22:04:28 <goodfellow>   True
22:04:32 <cmccann> no instance for Finite? I know Unicode is huge but that's just silly.
22:04:39 <dmwit> String
22:04:44 <dmwit> not Char
22:04:51 <cmccann> oh
22:04:55 <cmccann> somehow I read that as parens
22:04:59 <cmccann> for unspecified reasons
22:05:02 <cmccann> nevermind.
22:05:30 <dmwit> ;)
22:05:53 <monochrom> < ()
22:05:54 <goodfellow>   ()
22:05:55 <dmwit> hmph
22:06:21 <dmwit> ☻)
22:06:25 <dmwit> ah well
22:06:36 <monochrom> have you saved the files? recompiled?
22:06:36 <dmwit> Good enough for government work.
22:06:45 <dmwit> yes; yes
22:07:04 <monochrom> this is really puzzling
22:07:08 <monochrom> <monochrom>
22:07:10 <dmwit> It's not that puzzling.
22:07:25 <dmwit> I don't really think lambdabot was made with unicode in mind.
22:07:36 <monochrom> that's also true
22:08:19 <dmwit> < U.universe :: [()]
22:08:21 <goodfellow>   [()]
22:08:30 <dmwit> < U.universe :: [[()]]
22:08:31 <goodfellow>   No instance for (Data.Universe.Universe [()])
22:08:31 <goodfellow>    arising from a use of `Dat...
22:08:35 <dmwit> Well, that's a shame.
22:08:39 <dmwit> That seems totally plausible.
22:08:50 * dmwit files a bufg
22:08:57 <monochrom> what is this universe business?
22:09:09 <dmwit> It's a good replacement for [minBound .. maxBound].
22:09:33 <dmwit> < U.universe :: [(Integer, Integer)]
22:09:34 <goodfellow>   [(0,0),(1,0),(0,1),(-1,0),(0,-1),(1,1),(0,2),(2,0),(0,-2),(1,-1),(0,3),(-1,...
22:09:47 <monochrom> I see, interesting
22:10:07 <dmwit> It lets you write Eq, Ord, Show, and Read instances for functions, too. (There's a Finite type class.)
22:10:15 <dmwit> < U.universeF :: [(Integer, Integer)]
22:10:16 <goodfellow>   No instance for (Data.Universe.Finite GHC.Integer.Type.Integer)
22:10:16 <goodfellow>    arising ...
22:10:19 <dmwit> < U.universeF :: [(Int, Int)]
22:10:21 <goodfellow>   [(-9223372036854775808,-9223372036854775808),(-9223372036854775808,-9223372...
22:10:26 <dmwit> < min == max
22:10:27 <goodfellow>   True
22:10:31 <dmwit> =)
22:10:34 <cmccann> you should have a Multiverse class too.
22:10:43 <dmwit> < min 'a' == max 'a'
22:10:45 <goodfellow>   False
22:11:00 <cmccann> heh. that first one defaulted to (), didn't it?
22:11:15 <dmwit> < fromList [((&&), "and"), ((||), "or")]
22:11:17 <goodfellow>   Couldn't match expected type `GHC.Real.Rational'
22:11:17 <goodfellow>              with actual t...
22:11:18 <shachaf> dmwit: How come there's no instance for lists?
22:11:19 <dmwit> cmccann: yeah =)
22:11:24 <dmwit> shachaf: It's a bug!
22:11:26 <dmwit> yeesh
22:11:34 <shachaf> Oh, wait, there's no *Finite* instance for lists.
22:11:44 <dmwit> Yes, that's not a bug.
22:11:56 <dmwit> Not having a Universe instance for lists is a bug, though.
22:12:05 <dmwit> < M.fromList [((&&), "and"), ((||), "or")]
22:12:07 <goodfellow>   fromList [([(False,[(False,False),(True,False)]),(True,[(False,False),(True...
22:12:13 <dmwit> excellent =)
22:12:20 <Ghoul_> anyone know how to stop parsec from parsing >-x as >- (x) and rather as >(-x) using the expression engine?
22:12:35 <coppro> stick a space in
22:12:57 <Ghoul_> you mean the input?
22:13:01 <cmccann> pretty sure that's the solution he doesn't want.
22:13:06 <johnw> Ghoul_: which parser are you using to parse the operator?
22:13:15 <dmwit> ?hackage universe -- monochrom, if you think you might use this ever
22:13:15 <Ghoul_> buildExpressionParser
22:13:15 <lambdabot> http://hackage.haskell.org/package/universe -- monochrom, if you think you might use this ever
22:13:17 <Ghoul_> and a table of operators
22:13:27 <johnw> ah
22:13:32 <johnw> i bet it's a greedy parser then
22:13:41 <monochrom> I am not sure I want min to be a list
22:13:47 <johnw> so, unless it allows exceptions, you can't do what you want to do with that parser
22:13:55 <natnayr> >:t *
22:14:00 <natnayr> :t *
22:14:01 <lambdabot> parse error on input `*'
22:14:06 <Ghoul_> hmm.
22:14:13 <monochrom> try (*)
22:14:13 <Ghoul_> thats inconvenient.
22:14:19 <GeneralMayhem> reminds me of the nested generics issue with c++ up until c++11
22:14:56 <GeneralMayhem> where std::vector<std::vector<String>> would be an error, because >> got parsed as one token
22:15:07 <dmwit> monochrom: Yeah, the Show and Read instances I wrote are pretty lazy (in the programmer sense, not the evaluation order sense).
22:15:17 <h4199> natnayr: are you trying to find the type of multiplication or of haskell kinds?
22:15:25 <Ghoul_> Well, bugger.
22:15:38 <Ghoul_> That means I might have to start over
22:15:47 <GeneralMayhem> or you can take the solution that c++ did
22:15:52 <GeneralMayhem> which is to tell your users not to do that
22:15:53 <dmwit> monochrom: (Of course they're not really lists, that's just how they're Show'n.)
22:15:54 <natnayr> h4199: nope, checking with lambda bot if * can be used as an undefined variable like b or c
22:16:04 <Ghoul_> I dont invent the language
22:16:06 <cmccann> Ghoul_: you mostly need to change the tokenizer I think.
22:16:07 <Ghoul_> I'm just parsing it.
22:16:14 <Ghoul_> I can't really boss anyone around :(
22:16:27 <cmccann> I suspect the problem is that it chops tokens up using haskell tokenizing rules by default.
22:16:28 <dmwit> ah, the plight of the peon
22:16:45 <monochrom> you may copy out the code of buildExpressionParser and modify it to your liking
22:16:53 <cmccann> the expression stuff should be fine otherwise (and is the harder part to deal with anyway).
22:16:55 <dmwit> natnayr: It can be used as a variable. It is already defined, but can be shadowed.
22:16:57 <Ghoul_> oh actually ,maybe its because I haven't defined the reserved operators
22:16:58 <dmwit> natnayr: for example:
22:17:07 <dmwit> > let x * y = x + y in 10 * 20
22:17:09 <lambdabot>   30
22:17:09 <Ghoul_> Maybe that affects the greediness of parsing
22:17:11 <cmccann> Ghoul_: that might also work, depending on how it handles that
22:17:28 <cmccann> if the reserved operators are part of the tokenization
22:17:43 <dmwit> natnayr: Additionally, you can write an instance of Num if you have a type that you want to implement this function name for and you don't want to shadow Prelude's (*).
22:18:44 <johnw> GeneralMayhem: C++11 now parses the ">>" as you would expect
22:19:05 <dmwit> How do you know what GeneralMayhem expects!
22:19:18 <GeneralMayhem> johnw: right, that's why i said "up until c++11"
22:19:22 <cmccann> dmwit: well he certainly doesn't expect the spanish inquisition.
22:19:33 <johnw> ah
22:20:37 <h4199> If he lives up to his name he doesn't know what he expects...
22:21:07 <johnw> dmwit: call it intuition
22:21:33 <johnw> i don't think a C++ user alive hasn't seen that compiler error and scratched his head and then thought, "Shouldn't computers be smarter than that?"
22:21:50 <shachaf> I am alive.
22:21:59 <johnw> I didn't know you used C++, shachaf
22:22:17 <shachaf> I used C++.
22:22:45 <cmccann> congratulations on escaping alive
22:22:51 <Ghoul_> C++ errors are mostly logical
22:22:56 <shachaf> I don't expect computers to be smart, though.
22:22:59 <Ghoul_> except template errors which humans cannot comprehend
22:23:00 <mgsloan> Or did C++ use you?
22:23:07 <johnw> Ghoul_: yes, but mastering that logic takes inordinate time
22:23:39 <Ghoul_> if std::function gives you an error
22:23:43 <Ghoul_> its min. 2 pages long
22:24:02 <cmccann> @quote cmccann difficult
22:24:02 <lambdabot> cmccann says: C++ is dual to Haskell in a sense: it's much too hard for the average programmer to use safely, but they do anyway with disastrous results; whereas Haskell isn't actually that difficult
22:24:02 <lambdabot> to use but people don't even try
22:24:24 <Ghoul_> lol
22:25:11 <johnw> Haskell just optimizes by placing all the difficulty at the beginning
22:25:16 <johnw> C++ spreads it out over decades
22:25:17 <Tau> i wish i had a mundain humour sense.
22:25:21 <cmccann> johnw: that's pretty accurate
22:26:34 <Tau> i think c++ is simpler than haskell.
22:26:47 <dmwit> hm
22:26:52 <sopvop> use c++ like C with templates
22:26:59 <Tau> the fact of haskell needing monads demands you to rewrite a lot of things.
22:26:59 <monochrom> I think the first language you learn is the simplest
22:27:03 <dmwit> Theoretically speaking, should I be able to write instance Universe a => Universe [a]?
22:27:20 <c_wraith> dmwit: why not?
22:27:27 <sopvop> Tau: How do you make proper operator+ in c++? (without googling)
22:27:31 <dmwit> c_wraith: countability problems
22:27:40 <Tau>  sopvop i'm not a c++ programmer.
22:27:53 <Tau> however, i have the impression it is simpler than haskell.
22:27:56 <sopvop> Tau then why you think c++ is simpler?
22:28:04 <cmccann> Tau: C++ is not simple in any way
22:28:08 <Tau>  sopvop because i know c.
22:28:09 <c_wraith> I would guess you don't know much about C++, then
22:28:13 <dmwit> c_wraith: I think I just convinced myself I shouldn't be able to. Integer is okay, but [Integer] aka Real isn't, right?
22:28:15 <Tau> and c sounds simpler than haskell.
22:28:30 <cmccann> monads are actually very simple, people just convince themselves and others otherwise for no apparent reason.
22:28:50 <dmwit> hm
22:28:54 <wereHamster> I ran 'cabal configure --prefix=/something' but then 'cabal install' will not install into /something but instead into $HOME.
22:28:55 <sopvop> C is simple and even beautiful
22:29:14 <dmwit> I guess I have to decide whether the "laws" for Universe demand that infinite inhabitants exist at finite index in the universe.
22:29:21 <cmccann> dmwit: you mean aka computable reals, right?
22:29:30 <Tau> well..
22:29:33 <dmwit> cmccann: I do not mean aka computable reals.
22:29:40 <shachaf> dmwit: Is there a Universe instance for Stream?
22:29:43 <cmccann> I don't think it really makes sense to claim that [Integer] contains uncomputable reals.
22:29:47 <dmwit> I'm talking about the platonic ideal of [Integer]. =P
22:30:19 <monochrom> there is a concept. that concept has a name in Haskell, it's "IO", therefore it is difficult. that same concept is present in all other languages too, but it doesn't have a name there, therefore it is easy.
22:30:21 <cmccann> dmwit: I reject the notion that uncomputable things exist in the platonic sense
22:30:25 <dmwit> shachaf: I don't think so.
22:30:54 <Tau>  monochrom yeah, haskell is a bit artificial in some sense.
22:30:58 <cmccann> monochrom: ergo names make things more difficult, which is why @pl makes programs so easy to understand.
22:31:01 <Tau> due to the concept of IO.
22:31:05 <monochrom> no, not artificial
22:31:37 <cmccann> Haskell forces newcomers to explicitly deal with complications that exist in every languages rather than sweep them under the rug.
22:31:41 <Tau>  monochrom what would you say instead of artificial?
22:31:42 <monochrom> or yes, artificial. what language is not artificial?
22:31:42 <cmccann> this is why it seems difficult.
22:31:46 <shachaf> dmwit: I think all inhabitants should exist at some finite index.
22:31:54 <cmccann> because programming is difficult, even if people like to think otherwise.
22:32:04 <monochrom> what cmccann says
22:32:11 <h4199> dmwit: ℵ⁰ to ℵ¹?
22:32:16 <Tau>  cmccann i find programming simpler than maths.
22:32:26 <Tau> despite the fact that it is purely maths in its backgronud.
22:32:27 <cmccann> Tau: then you don't understand one of them
22:32:45 <dmwit> shachaf: I just read the docs. It says only finite inhabitants have to exist at finite index, and who am I to argue with past dmwit?
22:33:01 <shachaf> dmwit: That doesn't make sense. :-(
22:33:06 <Tau>  cmccann so, you are a math/programmer expert?
22:33:07 <shachaf> What's a finite inhabitant, anyway?
22:33:20 <cmccann> dmwit: my past self is a dumbass, I argue with him all the time.
22:33:54 <sopvop> The wisdom of the ancient dmwits is beyond our understanding.
22:34:15 <Tau>  cmccann what have you done in programming?
22:34:21 <shachaf> cmccann: To be honest, I couldn't stand that guy.
22:34:27 <shachaf> cmccann: I'm glad he's gone.
22:34:49 <dmwit> shachaf: I feel like I could define "finite" carefully if I sat down and tried.
22:35:08 <arkeet> why is tau here :|
22:35:09 <shachaf> dmwit: OK, if you do that then *maybe* I'll buy your law.
22:35:17 <cmccann> Tau: I've spent nearly a decade as a professional programmer, which is enough to see the damage caused by the kind of programmers who think math is hard.
22:35:33 <dmwit> shachaf: I don't know what law I want any more!
22:35:34 <sopvop> Math is hard. Lets go PHPing!
22:35:43 <shachaf> cmccann: Who *doesn't* think math is hard?
22:35:48 <Tau>  cmccann lol, you are just insane.
22:35:54 <dmwit> Maybe I should wait until I've seen a case where I wanted an instance Universe [a] before I decide.
22:36:04 <Tau>  cmccann if math were easy you wouldn't have things that took 300 years to be solved.
22:36:05 * sopvop notices this is not haskell-blah
22:36:10 <arkeet> tau is just a troll.
22:36:12 <shachaf> dmwit: make a finite list type, hth
22:36:13 <Tau>  cmccann unless you are referring to trivial exercises.
22:36:18 <Demos> math is hard, but understanding java gems is harder
22:36:27 <dmwit> Tau: I think there was an implied "and therefore we shouldn't understand math" at the end.
22:36:31 <Tau>  arkeet you are the troll i think.
22:36:56 <pharaun> tau/2
22:37:03 <mgsloan> shachaf: Surely you love maths, aren't they so easy?
22:37:04 <dmwit> If you have just joined a community, and everybody else looks like a troll... you are the troll.
22:37:18 <Tau>  dmwit cmccann is the way arrogant and unknowledgeable to comprehend that math is beyond his knowledge of how solving a x^2 + 2x - 1 = 0 equation.
22:37:30 <pharaun> oh boy
22:37:31 --- mode: ChanServ set +o monochrom
22:37:33 <cmccann> Tau: I have no idea what you're talking about. I don't think you do either.
22:37:35 <Tau> so he thinks that math is easy and offends everyone else who disagrees.
22:37:35 --- mode: monochrom set +b *!*@186.194.53.41
22:37:35 --- kick: Tau was kicked by monochrom (Tau)
22:37:42 <cmccann> welp
22:37:46 <pharaun> welp
22:37:47 <shachaf> thonochrom
22:37:50 --- mode: monochrom set -o monochrom
22:38:07 <shachaf> mgsloan: That's monoids.
22:38:11 --- mode: ChanServ set +o monochrom
22:38:25 <sopvop> Tau is not an entertaining troll. It takes a bit of knowledge to troll haskellers. Like that Harper guy.
22:38:27 <cmccann> that was probably inevitable even without my involvement.
22:38:43 <fruitFly> RealFloat vs float?
22:39:01 <mgsloan> shachaf: adjunctions too! http://ircbrowse.net/browse/haskell?q=they+are+so+easy
22:39:02 <dmwit> apple vs orange?
22:39:12 <dmwit> one is a type, the other is a class (assuming you meant Float instead of float)
22:39:18 <simpson> Oh, Tau was here.
22:39:27 --- mode: monochrom set +b $a:Tau
22:39:36 <shachaf> mgsloan: :☹(
22:39:39 --- mode: monochrom set -b *!*@186.194.53.41
22:39:51 <cmccann> I love how many of those lines are shachaf saying the same thing
22:39:56 <monochrom> (is that the right syntax? $a:Tau ?)
22:40:01 <pharaun> cmccann: i can confirm on the monad thing
22:40:05 <mgsloan> d'aww #haskell is full of love: http://ircbrowse.net/browse/haskell?q=love
22:40:13 <simpson> no_name: Yes.
22:40:14 <dmwit> shachaf: I hate to be the one to tell you this, but your nose has no nose.
22:40:15 --- mode: monochrom set -o monochrom
22:40:18 <simpson> Er, monochrom: Yes.
22:40:24 <cmccann> pharaun: oh?
22:40:29 <pharaun> cmccann: before i got into haskell monad sounded all sorta scary :) then when i got into haskell and understood the basics of monad
22:40:32 <monochrom> thanks
22:40:34 <pharaun> and i was like... that's it? :|
22:40:38 <cmccann> haha
22:40:58 <pharaun> was a pretty big revealation to me
22:41:17 <mgsloan> shachaf: I love join semilattices!  They are so much easier!
22:41:19 <fruitFly> is Float the class and RealFloat the type?
22:41:28 <pharaun> made me want to go after the basics/laws/etc more often :) been starting to find it easier to understand that way
22:41:35 <Demos> yeah I am reading learn you a haskell and my mind was blown by currying
22:41:37 <pharaun> just found it amusing :)
22:41:38 <fruitFly> I'm seeing this in lyah "bmiTell :: (RealFloat a) => a -> String"
22:42:21 <fruitFly> I thought it would just be float and not realFloat
22:42:41 <dmwit> Go with it for now. LYAH will get to classes a bit later, I'm sure.
22:43:05 <cmccann> pharaun: yeah that's pretty much the point of no return for learning Haskell. "holy crap, programming abstractions can be rigorous and well-defined?"
22:43:37 <pharaun> cmccann: yeah, i still struggle with it lots to be frank, but that was just an amazing thing to... see
22:44:10 <Demos> yeah haskell seems to be "well you are gunna need some maths background but trust us, it is worth it in the long run" where most OOP is like "super easy to learn" then you get factoryFactoryFactoryManagerFactoryImpl classes
22:44:25 <fruitFly> dmwit: classes was in cap 2... I'm in chap 3 not... it mentioned nothing of realFloat, jus float and then dropped in realFloat
22:45:06 <Demos> I am on like chap 4 and I think LYAH has talked about classes but not how to define your own
22:45:27 <dmwit> fruitFly: In that case, shall I link to the docs for RealFloat? Will that be enough?
22:45:46 <fruitFly> brb
22:45:47 <fruitFly> i'll check it out later... gone for a swim dmwit  :)
22:45:52 <fruitFly> in the river
22:49:15 <cmccann> Demos: and even so newcomers to Haskell tend to overdo it with creating type classes :T
22:50:09 <TravisD> :( I spent the time to read back through Tau's comments and I was not entertained
22:50:31 <pharaun> i think i am *UNDER* using type classes
22:50:37 <pharaun> i have barely used type classes in most of my code
22:50:51 <shachaf> pharaun: That's OK.
22:51:05 <pharaun> just haven't ran into problems that feels like the right solution for type classes so i just haven't bothered
22:51:14 <shachaf> Using type classes isn't mandatory. Lots of good code can and should be written without type classes.
22:51:18 <cmccann> using them is fine, but often optional. creating new ones is rarely necessary for beginners.
22:51:23 <pharaun> i mean sure i use lots of *other* type classes but myself writing my own
22:51:26 <pharaun> haven't had much need
22:51:55 <monochrom> the most recent legit use of type classes is Oleg's "final tagless" thing.
22:52:07 <cmccann> monochrom: that was fun stuff.
22:52:08 <pharaun> cmccann: been programming this for a while but yeah i guess i just haven't needed what they provide mostly
22:52:53 <cmccann> pharaun: I figure people get mislead into overusing type classes because of the word "class" and how popular OOP is.
22:53:12 <cmccann> even though they're more like a principled way to do statically-typed function overloads.
22:53:34 <pharaun> cmccann: heh yeah when i first read about them i was tempted but in the end found most code easier/simpler to understand and use... usually without them
22:54:00 <allenj12> how do you import <$>
22:54:06 <pharaun> (<$>)
22:54:09 <monochrom> of course the ancient use of type classes for a coherent story of "==", "+" etc is also legit and ingenious
22:54:09 <shachaf> @hoogle (<$>)
22:54:09 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
22:54:09 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
22:55:31 <allenj12> for some reason i get a parse error when i do import Control.Applicative(<$>)
22:55:36 <allenj12> on that line
22:55:39 <cmccann> allenj12: add another ()
22:55:45 <allenj12> oooo
22:55:51 <cmccann> (<$>) is the name, you need ((<$>)) for the import list
22:56:09 <cmccann> e.g. import Control.Applicative ((<$>), (<*>), pure)
22:56:11 <pharaun> cuz you can do ((<$>), (<*>)) for ex
22:56:13 <pharaun> dang it ccxCZ
22:56:22 <pharaun> ccxCZ: mistab sorry
22:56:35 <cmccann> tabs are the devil, clearly.
22:56:42 <cmccann> in haskell we use spaces!
22:56:46 <shachaf> c     : Use spaces!
22:56:54 <cmccann> sha    : good idea
22:56:58 <pharaun> cmccann: haskell *was* what made me setup retab -> spaces :p
22:57:23 <allenj12> awww yes one more question someone showed me some code with `on` but i cant find it on hayoo
22:57:33 <cmccann> I still prefer tabs for indentation. I'm one of the weird people who actually likes assigning distinct semantic interpretation to spaces and tabs so that code looks "right" for any tab size.
22:57:39 <h4199> Data.Function
22:57:45 <monochrom> I learned ML before Haskell. its "+", ".+.", "myplus", "yourplus"... become unbearable after a while. but it has polymorphic "="! but you have to say "eqtype" and you cannot customize it. at this point you see that something is wrong because it is too much special case and too little user-definable.
22:57:54 <shachaf> Crazey McCann
22:58:06 <cmccann> monochrom: that is basically complete bullshit tbh
22:58:23 <allenj12> TY got it
22:58:25 <cmccann> stuff like that really puts me off trying to learn an ML of some sort
22:58:34 <pharaun> cmccann: heh well yes, that's one reason why i still persist in most tabs but i just got tired of various things going weird with the tab/space in haskell ;p
22:58:44 <Ralith> ML seems pretty dead outside of some light industry use
22:58:44 <cmccann> I mean yeah there are definite misfeatures in Haskell but most aren't quite that absurd
22:58:48 * dmwit high fives cmccann 
22:58:56 <Ralith> I don't know why you'd want to learn it to start with
22:59:01 <dmwit> Make spaces and tabs incomparable!
22:59:14 <dmwit> tabs = 8 spaces is stupid and wrong
22:59:18 <cmccann> pharaun: see the thing is tabs are good for indentation. haskell doesn't use indentation, it uses alignment.
22:59:23 <cmccann> it is not indenting. it is ASCII art.
22:59:36 <pharaun> point, yeah
22:59:57 <cmccann> you can adopt a weird style that makes indenting happen to work for alignment in Haskell. some people do, and it works ok.
23:00:20 <shachaf> cmccann: Don't worry: Ocaml allows comparison on any type.
23:00:30 <shachaf> But it might raise an Invalid_argument exception
23:00:33 <TravisD> heh, "it's not indentation. it is ASCII art." should be remembered by the bots
23:00:42 <pharaun> i love that ^,
23:00:56 <shachaf> Unicode art!
23:01:04 <cmccann> dmwit: if it were up to me tabs would indicate lexical blocks and a tab after a space would be an error, and spaces would be ignored and only used for lining things up within the same indentation depth
23:01:13 <monochrom> @remember cmccann see the thing is tabs are good for indentation. haskell doesn't use indentation, it uses alignment. it is not indenting. it is ASCII art.
23:01:13 <lambdabot> It is forever etched in my memory.
23:01:30 <cmccann> shachaf has a point, but ASCII art is the more common term :T
23:01:43 <dmwit> cmccann: aww, why kill tabs after spaces?
23:02:28 <dmwit> I feel like "indenting" things within an alignment block is a perfectly reasonable thing to do.
23:02:46 <dmwit> ack
23:03:36 <cmccann> dmwit: to avoid any ambiguity mostly.
23:03:50 <cmccann> but I can tolerate it so long as they are absolutely incomparable.
23:03:56 <dmwit> making tabs and spaces incomparable also solves that problem, and is less draconian
23:03:59 <dmwit> yes
23:04:31 <cmccann> if a lexical block is indented by a tab, three spaces, two tabs, and a half-width unicode space character then you better use exactly the same thing for the whole block, and a prefix of that for the enclosing block
23:04:42 <dmwit> Yes. I like that rule.
23:05:06 <cmccann> dmwit: I would probably settle for making them incomparable, but mixing them one of those irritating warnings that some people like to turn on
23:05:51 <h4199> Didn't a paper get submitted recently about principled whitespace parsing?
23:06:12 <cmccann> that sounds amusing.
23:07:16 <dmwit> One of the complaints on the Haskell' proposal about this is that explaining the rule is too hard. That makes me want to smash something. The rule is easy: A is indented more than B if B's whitespace is a prefix of A.
23:07:47 <dmwit> ...'s whitespace. =P
23:08:02 <cmccann> it's a remarkably simple rule.
23:08:06 <dmwit> though I guess it's technically right without that correction, too
23:08:25 <shachaf> I liked it before the correction.
23:08:28 <shachaf> imo uncorrect it
23:08:39 <dmwit> s/...'s whitespace. =P//
23:08:42 <shachaf> Though I don't like this rule.
23:08:55 <hpaste> allenj12 pasted “need to learn why this works :)” at http://hpaste.org/86450
23:09:19 <allenj12> can someone explain why this works so i can learn? if that a bad question im sorry
23:09:41 <cmccann> what confuses you?
23:10:54 <allenj12> alot of it sorry i cant be specific i barely know how to use it
23:11:17 <shachaf> allenj12: I suggest this code is too complicated.
23:11:18 <dmwit> I feel like you would benefit a lot from learning a bit of Haskell before you try to use Parsec.
23:11:22 <shachaf> Go understand simpler code first.
23:11:39 <allenj12> o like where does collect come in? and why dont i see it called
23:12:02 <allenj12> yes well im working on this project that requires this although the rest of the project is alot easier
23:12:17 <allenj12> this was kinda a slap to the face
23:12:23 <Ralith> how can a project require parsec?
23:12:47 <Ralith> is this, perhaps, homework?
23:12:56 <allenj12> its for my computabilility and logic class
23:13:05 <dmwit> Oooo, is this where we get to ask for big, tall moneys?
23:13:07 <allenj12> its my own proposed project
23:13:22 <allenj12> but it turns out i needed this
23:13:25 <Ralith> maybe you should amend your proposal
23:13:25 <h4199> found it! http://michaeldadams.org/papers/layout_parsing/
23:13:26 <shachaf> allenj12: The best way to understand this code is to understand Haskell.
23:13:35 <shachaf> The best way to understand Haskell is to understand simpler code first.
23:14:08 * monochrom knew! "whitespace parsing" means layout parsing
23:14:16 <dmwit> bookmark'd
23:14:45 <allenj12> i cant amend my proposal sadly and its not a computer related class in particular i did not think it would require something like this
23:14:57 <monochrom> allenj12: how confident are you with Haskell?
23:15:16 <cmccann> monochrom: as opposed to what, a parser for the Whitespace language?
23:15:17 <allenj12> monochrom: not very
23:15:24 <Ralith> how did you write your proposal so as to specifically require parsec without knowing that it would?
23:15:54 <monochrom> ok, then what shachaf says. you're in for a lot of catching up
23:16:01 <allenj12> well it was not like a thesis... i had to do a goal and it just came up
23:16:19 <allenj12> im mainly use to c++ lol
23:17:27 <arkeet> RWH has a chapter on parsec.
23:17:37 <allenj12> yes indeed
23:19:47 <arkeet> although it's a bit outdated.
23:20:10 <arkeet> since it refers to parsec 2.
23:20:33 <arkeet> which is really old.
23:20:54 <allenj12> hmm and i realise i do understand alot of the code im just a bit confused why i cant call it succesfully in ghci but ill figure it out
23:21:14 <h4199> allenj12: what is the nature of the project/parsing you have to do? If the parsing is not really central to the project and what you have to parse is relatively uniform then perhaps someone has written something you can use or modify
23:21:21 <monochrom> oh, you need some "runParser" or "testParser" for that
23:21:50 <Demos> what do people here think of f#, I really like it in general but I figure that for transitioning from imparitive programming haskell is good since I can not break down and use loops and oop crap
23:22:06 <cmccann> F# is ok from what I've seen.
23:22:26 <Ralith> F# has the serious flaw of not being haskell
23:22:32 <Demos> hehe lol
23:22:43 <allenj12> it is testParser but i run      testParser expr "((A o B) a C)" and dont get much
23:22:54 <cmccann> the .NET libraries are not great for functional-style code and F# feels really limited compared to haskell.
23:23:03 <allenj12> if you guys are interested for the sheer hell of it i can post the entire file to skim
23:23:07 <Ralith> allenj12: maybe you should try doing whatever it is without parsec.
23:23:08 <Demos> this is true, I also like that haskell is staticly compiled and compiled to native code (although with a fairly MASSIVE runtime)
23:23:20 <cmccann> no type classes or even higher-kinded polymorphism is irritating.
23:23:44 <Demos> true cmccan about .net but it does have the type providers and units which are both neat
23:23:54 <Demos> although units kinda fill the same role as typeclasses
23:24:00 <allenj12> i have to generate random logical arguments to be always valid and interesting
23:24:09 <allenj12> can not be made and tested
23:24:16 <allenj12> has to be an algorithm to make valid
23:24:29 <cmccann> if you need to be on .NET for some reason F# is worth looking at
23:24:35 <allenj12> which i know how in general so far but i dont know how haskellish it is
23:24:39 <cmccann> otherwise I'd probably stick with haskell.
23:25:27 <Demos> that is the plan! in any case it is not like I cant call haskell code from anywhere :D
23:25:46 <hpaste> allenj12 pasted “Logical Argument Generator” at http://hpaste.org/86451
23:25:57 <allenj12> if u guys are interested
23:26:00 <allenj12> lol
23:27:34 <mm_freak> this is funny…  netwire actually obsoleted pipes before it even existed, and is more powerful while providing the same categorical soundness =)
23:27:44 <mm_freak> i should probably add some stream processing helpers
23:28:07 <allenj12> monochrome: so i know it is parseTest but im just curious when collect comes into play so id call in ghci       parseTest expr "some string" .... no?
23:29:35 <monochrom> allenj12: I have a design question to ask you
23:30:14 <monochrom> I have defined "data Me = Ctor Int Bool Double". you see, it has 3 fields, an Int, a Bool, and a Double
23:31:16 <allenj12> monochrome: go for it
23:31:28 <allenj12> yes
23:31:51 <monochrom> I now have the task of generating some random values of that type. so, I have to create 10 Me's. each one should have a randomly chosen Int, a randomly chosen Bool, and a randomly chosen Double.
23:32:00 <monochrom> I have two choices.
23:32:11 <allenj12> hmmm k
23:32:41 <allenj12> what are the choices?
23:32:43 <monochrom> Option A: should I generate a random number for the Int, then a random boolean for the Bool, then a random number for the Double?
23:33:05 <monochrom> Option B: or should I generate a random String, then parse it into Me?
23:33:46 <allenj12> hmmm i think i know what your saying.... A?
23:34:00 <monochrom> yeah. and you should choose the same for your project
23:34:37 <allenj12> i was going to do something like that but tbh there are no bools or ints would there be
23:34:38 <allenj12> ?
23:34:55 <monochrom> you can directly pick random operators, and random arguments, and just put them together into an Expr. there is no need to parse anything.
23:35:44 <monochrom> also, your Expr type lacks some place to hold an operator
23:36:59 <allenj12> hmmm well after the conclusion is generated i was gonna assign each atomic (which can also be say (A o B) into a list of a certain randomized size each blank slot would be a helper premise and the other ones would be a goal premise of that makes sense
23:38:44 <allenj12> when i mean helper assuming so if you have A then A->B  therefore B..... A would be a helper premise but more complicated hopefully
23:39:06 <allenj12> im rambling now arent i? sorry
23:39:52 <monochrom> that doesn't change the fact that you would choose to randomize Expr contents directly, rather than randomizing a string of some syntax and then work hard to parse it.
23:40:49 <allenj12> mmmm true
23:41:31 <allenj12> :( lol
23:42:30 <monochrom> Option B really looks silly if I write it out in as much detail as I wrote Option A.
23:43:30 <allenj12> yea
23:44:28 <allenj12> so how would u randomize a conclusion to begin with?
23:44:39 <allenj12> if u dont mind me asking like in what form
23:45:26 <allenj12> instead of just a string
