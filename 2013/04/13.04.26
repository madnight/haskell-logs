00:23:52 <alang> > floor $ 0 / 0
00:23:53 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
00:24:38 <alang> > floor $ 0 / 0 :: Int
00:24:40 <lambdabot>   0
00:24:47 <alang> is that expected?
00:25:47 <arkeet> > toRational (0/0)
00:25:48 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
00:25:56 <arkeet> > denominator $ toRational (0/0)
00:25:57 <lambdabot>   1
00:26:24 <arkeet> > length . show $ floor (0/0)
00:26:25 <lambdabot>   310
00:26:36 <XexonixXexillion> Is there any way to run ST code in safe haskell?
00:26:46 <arkeet> ...yes
00:26:52 <XexonixXexillion> how?
00:26:59 <arkeet> you just do it
00:27:03 <XexonixXexillion> importing Control.Monad.ST.Safe didn't work
00:27:16 <arkeet> no?
00:27:17 <arkeet> hmm
00:27:25 <XexonixXexillion> just a moment
00:27:34 <XexonixXexillion> I think I may have another module importing ST
00:27:37 <arkeet> heh.
00:27:43 <arkeet> because it is marked as trustworthy.
00:29:12 <XexonixXexillion> I had a second module import Control.Monad.ST instead of Control.Monad.ST.Safe
00:29:17 <arkeet> :)
00:31:57 <lightquake> what constraints on f, m, n are necessary to go from f (m a, n b) to (m (f a), n (f b))?
00:33:21 <arkeet> well, Functor f is enough to go to (f (m a), f (m b)), and then you'd be done if m and n were Distributive.
00:34:48 <lightquake> hm. i think this is a sign i'm doing something wrong.
00:44:38 <hpaste> “Anonymous Coward” annotated “uuagc build failed” with “uuagc build failed (annotation)” at http://hpaste.org/75653#a86620
00:45:58 <XexonixXexillion> I seem to be getting strange errors (which I don't get to actually see) My code compiles with Safe Haskell in GHC 7.4.1, but seems to be failing on a server running a more recent version of Haskell. Has safe haskell changed recently?
01:18:11 <blackdog> hey all - sorta sketching something out at the moment, and got a typesig that looks like this:
01:18:14 <blackdog> manageConnections :: MonadIO m => Control -> (m a) -> (a -> m b) -> ([b] -> m ()) -> m ()
01:19:10 <blackdog> with the basic idea that there's some control info in the first arg, a way of seeding computations, a way of processing them, and a reducer stage. I can write it myself, but was wondering if i'm missing some gorgeous abstraction that would make it easy forme.
01:33:09 <b__> does a string from readFile always include a trailing '\n
01:33:42 <pygmalion> Is there some kind of iterateWithIndex function? I have an infinite list that I am dropWhile on to get the first value that meets a certain condition, but I want to also know how many iterations it took to get to that point.
01:34:20 <pygmalion> b__: Only if the file ends in a \n I believe.
01:35:02 <b__> do editors generally (or vim specifically) add a \n at the end of the file?
01:35:42 <b__> ah yes, it seems vim does this
01:36:04 <pygmalion> b__: yep.
01:41:31 <pygmalion> duh answered my own question, just zip with [1..]!
01:42:10 <haasn`vm> why not [0..]? :)
01:42:54 <pygmalion> haasn`vim: a good reason actually! The first value of the list is being constructed differently, I just need to tack the tail on. I promise, no 1-indexing here!
01:43:05 <pygmalion> haasn`vm*
01:43:12 <haasn`vm> okay :)
01:43:35 <haasn`vm> (I have no idea what the problem is)
01:44:56 <arkeet> there's a lens way to do it. :p
01:45:03 <haasn`vm> there's always a lens way to do it
01:45:46 <arkeet> > "abcde" ^@? itraversed . droppingWhile (< 'c')
01:45:47 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Indexed.Indexed
01:45:47 <lambdabot>        ...
01:45:50 <arkeet> uh
01:46:26 <haasn`vm> > "abcde| ^@.. itraversed
01:46:28 <lambdabot>   <hint>:1:24:
01:46:28 <lambdabot>      lexical error in string/character literal at end of input
01:46:28 <haasn`vm> oops
01:46:31 <haasn`vm> > "abcde" ^@.. itraversed
01:46:32 <lambdabot>   can't find file: L.hs
01:46:35 <haasn`vm> silly school keyboard
01:46:36 <arkeet> > "abcde" ^@? itraversed . filtered (>= 'c')
01:46:38 <lambdabot>   Just (2,'c')
01:48:05 <haasn`vm> > "abcde" ^@.. itraversed . filtered (>= 'c')
01:48:06 <lambdabot>   can't find file: L.hs
01:48:09 <supki> > "abcde" ^@? droppingWhile (< 'c') itraversed
01:48:11 <lambdabot>   Just (2,'c')
01:48:18 <haasn`vm> lambdabot hates me today
01:48:27 <arkeet> ah, droppingWhile takes another lens as an argument.
01:48:35 * arkeet should read the types next time
01:49:08 <supki> > 1 ^? droppingWhile (< 10) (iterated succ)
01:49:10 <lambdabot>   Just 10
01:49:24 <supki> uhm
01:49:30 <supki> no iiterated =(
01:49:36 <arkeet> aw
01:49:39 <arkeet> patch!
01:50:01 <haasn`vm> > 1 ^@? droppingWhile (<10) (iterated succ)
01:50:03 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Indexed.Indexed
01:50:03 <lambdabot>        ...
01:50:07 <haasn`vm> worth a try :(
01:50:19 <arkeet> iterated :: (a -> a) -> Fold a a
01:50:29 <haasn`vm> ah okay
01:50:38 <haasn`vm> aren't IndexedFolds back-comptabile with folds these days?
01:50:48 <arkeet> yes
02:28:55 <hpaste> awgn pasted “Template Haskell Problem?” at http://hpaste.org/86625
02:29:27 <awgn> why does the quasi quotation version not work ?
02:31:06 <statusfailed> I want to access my Acid State from both a Snap app and an external thread, what's the best way to do it?
02:31:37 <awgn> it seeems that splice does not work with function name...
02:43:52 <mm_freak> statusfailed: "external thread"?
02:43:59 <mm_freak> another program?
02:54:04 <mm_freak> when i say `class X b a | a -> b` and `class (X b a) => Y b a`, do i have to repeat the fundep?
02:56:05 <antoine__> Hi all
02:57:15 <antoine__> I'm learning Haskell, and to train me I'm doing the exercises of the web page "20 Intermediate Haskell Exercises" (http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/index.html)
02:57:25 <Kinnison> Hi
02:57:52 <antoine__> is the solutions of these exercises available somewhere?
03:02:08 <k00mi> antoine__: Fluffy is Functor, Misty is Monad. You can look up these instances on hackage
03:03:58 <k00mi> antoine__: hm, actually, it is better to look them up in a book since the prelude code isn't really beginner friendly here
03:04:43 <antoine__> ok k00mi.. I'll look for this.
03:05:03 <antoine__> i'm also reading "Learn you a Haskell..."
03:05:30 <k00mi> that has all the instances in question
03:05:56 <antoine__> I just have some doubts about the implementation of "instance Misty ((->) t)"
03:06:56 <k00mi> that is the Reader monad, it's explained in LYAH
03:07:31 <antoine__> ok thank you for your help. I'll see this.
03:07:40 <shachaf> antoine__: If it type-checks and doesn't use recursion/undefined/etc. then it's probably correct.
03:07:48 <antoine__> nice :-)
03:08:07 <antoine__> it type-checks without recursion :-)
03:08:08 <shachaf> Figuring out what it means is a bonus exercise.
03:08:17 <antoine__> lol
03:08:29 <shachaf> (Really.)
03:08:58 <shachaf> You can think of Misty instances as effects, e.g. nondeterminism for the [] instance.
03:09:04 <shachaf> But maybe that can come later. :-)
03:12:09 <antoine__> I have to go. Thanks for your help. I'll come later ;-)
03:12:39 <mauke_tmp> > return x y
03:12:41 <lambdabot>   x
03:12:55 <mauke_tmp> > (g >>= f) x
03:12:57 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:12:57 <lambdabot>    (GHC.Show.Show a0)
03:12:57 <lambdabot>     ...
03:14:13 <supki> > ((g :: Expr -> Expr) >>= f) x :: Expr
03:14:14 <lambdabot>   f (g x) x
03:14:32 <shachaf> > join f x :: Expr
03:14:33 <lambdabot>   f x x
03:15:03 <shachaf> > fmap (f :: Expr -> Expr) g x
03:15:05 <lambdabot>   f (g x)
03:17:36 <johnw> is there a monad which is the inverse of MaybeT?  I.e., short-circuiting on the first Just value?
03:19:03 <magicman> What would (>>=) for such a monad do?
03:19:17 <danr> johnw: there is the monoid First
03:19:41 <arkeet> johnw: maybe you just want EitherT.
03:20:11 <arkeet> @hackage either
03:20:11 <lambdabot> http://hackage.haskell.org/package/either
03:20:26 <supki> johnw: would it satisfy laws?
03:20:43 <Ghoul_> let thing x y = if' x (3-) (2+) $ y > 1 in thing True 3
03:20:49 <Ghoul_> > let thing x y = if' x (3-) (2+) $ y > 1 in thing True 3
03:20:51 <lambdabot>   Not in scope: if'
03:20:51 <lambdabot>  Perhaps you meant f' (imported from Debug.SimpleReflect)
03:21:06 <arkeet> :t f'
03:21:08 <lambdabot> FromExpr a => a
03:21:35 <Ghoul_> okay, actually, why the hell is if' not in prelude
03:21:40 <Ghoul_> It'd be the best function ... ever
03:22:15 <Ghoul_> if' :: Bool -> a -> a -> a
03:22:23 <Ghoul_> if' x y z = if x then y else z
03:22:30 <danr> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:Bool -> a -> a -> a
03:22:32 <arkeet> bool would be a better function
03:22:47 <arkeet> bool :: a -> a -> Bool -> a; bool f t b = if b then t else f
03:23:00 <Ghoul_> oh epic.
03:23:02 <Ghoul_> the more you know
03:23:11 <Ghoul_> should probably update this page then http://www.haskell.org/haskellwiki/If-then-else
03:23:27 <Ghoul_> :t bool
03:23:29 <lambdabot> Not in scope: `bool'
03:27:05 <Ghoul_> So where does `bool` actually come from
03:27:15 <Ghoul_> I can't find it..
03:29:52 <mauke_tmp> <arkeet> bool would be a better function  <- ... if it existed
03:30:56 <veg4n> if i may ask a question; im currently writing a json parser using data.aeson. right now, i need to parse some values i want to store in a data.map. i know it's possible to do this with build in aeson features but i'm not able to find it. any hints would be very appreciated
03:32:57 <Ghoul_> mauke_tmp: IS there something like what I showed
03:34:29 <mauke_tmp> Ghoul_: I'm not aware of any widely used modules with such a function
03:36:57 <aleator_> @tell tommd I think we have a time zone problem I'm at gmt+3.
03:36:57 <lambdabot> Consider it noted.
03:37:13 <Ghoul_> hmm.
03:38:07 <merijn> Ghoul_: if' and bool have been proposed on the mailing list a few time, but so far there hasn't been enough support to add it, I think
04:35:11 <SrPx> I'm a noob in compiled languages so please be kind. Haskell compiles to machine code (assembly, I guess), right? So is it fair to say it can completely replace C in all of it's uses?
04:35:52 <Botje> as long as you have the runtime available, yes.
04:36:26 <Botje> writing a kernel in Haskell would still require the runtime to bootstrap and C to poke the actual hardware
04:36:35 <luite> SrPx: perhaps not all, code size and runtime system tend to be larger, so it might not be suitable for the very smallest embedded systems
04:36:46 <SrPx> Botje: but for example, things like CUDA or Arduino use C, I guess, and this is something I never udnerstood. Why they do it? And how can Haskell replace it?
04:36:58 <SrPx> luite: hmm...
04:37:14 <Botje> SrPx: cuda does not use C. It uses something that /looks/ like C, but is passed through a cuda compiler.
04:37:22 <SrPx> luite: so C is the only language there? Why? What makes it so special?
04:37:31 <Botje> as for arduino: yes, they use C.
04:37:42 <SrPx> oh I see.
04:37:50 <hpc> if i had to guess, C is very easy to write a basic compiler for
04:37:52 <luite> SrPx: though ajhc/jhc can produce relatively small code that works on small systems
04:37:59 <hpc> and it provides access to memory at a very low level
04:38:10 <Botje> SrPx: C has very little requirements of the metal its running on.
04:38:11 <quchen> C is basically a nicer way of writing ASM. It's close to the machine, but doesn't make you throw up (as quickly).
04:38:37 <SrPx> but again, why? what makes it so special? A competition on my college is using C/C++. Only. But it's supposed to be a programming competition, not a C competition. Am I right for thinking this is wrong?
04:38:58 <quchen> SrPx: It's very wrong, yes.
04:39:01 <SrPx> It's meant to make you solve problems. Why I can't use a functional programming language?!
04:39:15 <Botje> SrPx: probably because they do not know about haskell.
04:39:17 <quchen> SrPx: It's probably hosted by people that don't know any other languages
04:39:27 <Botje> I use haskell in our yearly programming contest
04:41:29 <hpc> SrPx: if you want to be a dick, you can compile haskell to C
04:41:31 <quchen> SrPx: Also, Python, Perl etc. are programming languages too. They're (usually) not compiled to machine code, but that doesn't change the fact that they send instructions to a processor.
04:41:41 <hpc> using a non-default backend and one of the -ddump flags
04:41:57 <SrPx> quchen: I really agree with that. So bad those people run my college. And the national competition. Wtf
04:42:12 <hpc> oh, national competition?
04:42:17 <hpc> this wouldn't happen to be acm, would it?
04:42:19 <Botje> SrPx: well, it /does/ level the playing field.
04:42:43 <SrPx> hpc: I want to be a dick if that's the case. Let me just read more on their instructions (and actually try to contact them)
04:43:04 <SrPx> hpc: acm I don't know, hold on a sec
04:43:13 <quchen> On the bright side, "don't be a dick" is part of very few competition rules. I don't see why you shouldn't compile Haskell to C.
04:43:49 <quchen> You'll most likely lose points for coding style then, I'm not sure how beautiful GHC's C output is ;-)
04:44:03 <hpc> it's quite awful
04:44:08 <hpc> and the names are z-encoded
04:44:24 <nand`windows> quchen: simple, just format it into ASCII hart
04:44:29 <quchen> ♥
04:44:34 <nand`windows> art
04:44:35 <nand`windows> !
04:44:37 <nand`windows> stupid keyboard
04:44:50 <SrPx> hpc yes it is ...
04:44:58 <nand`windows> then you'll lose points for coding style but you'll gain them again for code beauty
04:44:59 <quchen> Z-encoded?
04:45:03 <SrPx> hpc what do you know about it? Are you from here?
04:45:11 <quchen> nand`windows: There's no beauty in that I think.
04:45:25 <quchen> nand`windows: Remember, he cannot hand in Haskell source. They'll only accept the C code.
04:45:37 <hpc> SrPx: acm is pretty much everywhere, but they haven't really been relevant for years
04:45:41 <nand`windows> not even if it's an ASCII heart?
04:45:57 <hpc> the way their competition works is they allow individual universities to limit languages based on what they know how to read
04:46:16 <Botje> .oO( system("runhaskell ...") )
04:46:28 <SrPx> hpc oh why? I don't know anything about it really, I just opened an mail from our director talking about it
04:46:47 <hpc> so naturally, it gets run by a student that doesn't care about programming and just wants the extracurricular to look good on a job
04:46:52 <hpc> and that person only knows C or C++
04:46:57 <hpc> or at my uni, also java
04:47:02 <neutrino_> lol: http://beust.com/weblog/2010/07/28/why-scalas-option-and-haskells-maybe-types-wont-save-you-from-null/
04:47:04 <hpc> which didn't really help much :P
04:47:26 <SrPx> hpc actually it's a professor, but I'll mail her. What's ACM point? Is it something about C or was limiting to C her decision?
04:48:07 <quchen> neutrino_: I've never seen Maybe as a weird thing that was made to avoid void. This changes everything!
04:52:41 <Chousuke> neutrino_: that post misses the point by a mile :P
04:53:10 <merijn> neutrino_: I fails to realise that fantom's ? is (almost) isomorphic to Maybe >.>
04:53:14 <merijn> s/I/he
04:55:55 <SrPx> hpc sorry for some reason I wasn't seeing your messages. I see
04:55:57 <neutrino_> Chousuke: hahaha
04:56:09 <neutrino_> merijn: what's fantom?
04:56:21 <merijn> neutrino_: A programming language he mentions at the end of the post
04:56:52 <merijn> He ends with "I don't see how maybe is better than Fantom's approach" which is because Fantom's approach basically *is* Maybe (with one exception, you can't nest them in Fantom)
04:57:15 <merijn> In Fantom String is a non-null value and String? is a value that *might* be null
04:57:43 <merijn> So potentially null values have a ? annotation in their type, which is pretty much what Maybe does, except you can't nest them
04:58:20 <neutrino_> merijn: haha.
04:58:32 <neutrino_> yeah, i don't see how haskell's approach is better either.
04:58:39 <neutrino_> so there you go.
04:59:19 <neutrino_> i think he was right on that point, but in this case it's just that two wrongs make a right.
05:02:23 <hpaste> m_hyperbolic pasted “Weird behaviour” at http://hpaste.org/86628
05:02:47 <shachaf> merijn: Nesting is pretty crucial for it to be considered a proper value.
05:02:48 <m_hyperbolic> Can someone explain what happens in the snippet ?
05:02:58 <Chousuke> option types are not quite as useful without static type checking but probably still better than having everything nullable by default.
05:03:08 <shachaf> m_hyperbolic: The second definition is recursive.
05:03:15 <mauke_tmp> m_hyperbolic: you defined top as consisting of "+" followed by itself
05:03:25 <shachaf> m_hyperbolic: I.e. it's defining top in terms of itself, not in terms of the previous variable also named top.
05:03:52 <m_hyperbolic> ah.. of course. Silly me. Thanks!
05:11:16 <t7> can i reduce this: foo o >>= lift . bar t
05:12:34 <t7> i want     bar t <!?> foo o
05:13:57 <t7> @hoogle (a -> A b) -> (B a) -> B b
05:13:57 <lambdabot> Did you mean: (a -> A) -> B -> B
05:13:57 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:13:57 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:14:15 <t7> @hoogle (a -> A b c) -> (B a) -> B c
05:14:15 <lambdabot> Did you mean: (a -> A) -> B -> B
05:14:15 <lambdabot> No results found
05:14:28 <mauke_tmp> x <!?> y = y >>= lift . x
05:15:00 <ab9rf> @hoogle (a -> m b) -> (m1 a) -> (m1 b)
05:15:01 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
05:15:01 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
05:15:01 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
05:15:01 <t7> i dont wanna make functions willy-nilly, nobody will be able to read my code
05:23:35 <ab9rf> what, you think code should be readable?  how quaint.
05:24:44 <nand`windows> anybody got that example where a String is directly executed in Haskell?
05:24:47 <nand`windows> with unsafeCoerce and whatnot
05:24:58 <nand`windows> as machine code
05:25:19 <mauke_tmp> doesn't require unsafeCoerce
05:25:41 <mauke_tmp> just castPtrToFunPtr
05:25:46 <nand`windows> ah okay
05:49:57 <narens> question: is there any use for using the Cont monad if callCC is not required?
05:50:46 <elliott> narens: if you want to use the Cont constructor
05:51:40 <narens> elliott: i don't follow
05:52:13 <elliott> well, if you don't actually want to do anything that uses continuations, then no you don't need it :p
05:52:19 <elliott> but callCC is implemented in terms of ContT/cont
05:52:20 <elliott> :t ContT
05:52:22 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
05:52:22 <elliott> :t cont
05:52:24 <lambdabot> ((a -> r) -> r) -> Cont r a
05:52:29 <elliott> so maybe you want to do something else that uses those instead of callCC directly.
05:52:47 <narens> oh i see
05:52:55 <elliott> I guess you can also use ContT as a kind of Codensity for the free CPS-ing, but if you want that you should just use Codensity
05:53:10 <elliott> (http://comonad.com/reader/2011/free-monads-for-less/ etc.)
05:55:22 <robde> hello, if I have a type signature like foo :: (x,y) -> x, is that even legal?
05:56:04 <Lethalman> :t fst
05:56:05 <lambdabot> (a, b) -> a
05:56:22 <robde> but how could the function body look like?
05:56:35 <robde> foo (a,b) = a + b
05:56:35 <elliott> foo (x,_) = x
05:56:35 <robde> ?
05:56:46 <elliott> robde: that has the type foo :: Num a => (a,a) -> a
05:56:52 <elliott> or e.g. more simply, foo :: (Int,Int) -> Int
05:58:07 <robde> but I belief I’m not allowed to change the signature
05:58:17 <robde> (this is in the context of an assignment)
05:58:43 <beaky> hello
06:01:29 <Eduard_Munteanu> beaky: hi
06:03:56 <narens> elliot: so the pattern that sends (a -> b) -> (f a -> f b) is a functor but what sends (a -> b) -> (a -> f b)?
06:04:23 <mauke_tmp> that's just a weird wrapper around b -> f b
06:04:29 <dmwit> robde: elliott is saying your proposal is wrong because it has the wrong signature, namely Num a => (a, a) -> a. elliott's proposal does not have that signature.
06:05:09 <Eduard_Munteanu> :t (. pure)
06:05:10 <lambdabot> Applicative f => (f a -> c) -> a -> c
06:05:11 <elliott> if you have to write a function of type (x,y) -> x then there is only one possible (terminating) function you can write and I've accidentally spoiled the answer for you :p
06:05:18 <Eduard_Munteanu> Err.
06:05:35 <dmwit> :t (pure .)
06:05:36 <Eduard_Munteanu> :t (pure .:)
06:05:36 <lambdabot> Applicative f => (a -> b) -> a -> f b
06:05:37 <lambdabot>     Not in scope: `.:'
06:05:37 <lambdabot>     Perhaps you meant one of these:
06:05:37 <lambdabot>       `.' (imported from Prelude),
06:05:47 <Eduard_Munteanu> Yeah.
06:05:58 <dmwit> :t (return .) -- too
06:05:59 <lambdabot> Monad m => (a -> b) -> a -> m b
06:06:10 <narens> of cource
06:06:13 <narens> of course
06:08:06 <robde> elliott: but there is a sample application of the function: foo (5, True)
06:08:33 <elliott> yep
06:08:41 <mauke_tmp> robde: what do you mean, "but"?
06:08:45 <elliott> so say (5, True) :: (Int, Bool)
06:08:49 <elliott> and foo :: (x, y) -> x
06:08:54 <elliott> then foo (5, True) :: Int
06:09:10 <elliott> (by substituting x=Int, y=Bool)
06:09:34 <robde> oh, sry, now I see
06:10:59 <mauke_tmp> btw, @djinn could do your homework for you :-)
06:14:26 <beaky> what is the difference between data and objects in OOP?
06:15:51 <dEPy> objects encapsulate data + behaviour?
06:16:21 <beaky> ah
06:17:13 <beaky> I always thought that "object" was just a fancy word for a bundle of functions + some data members that are shared between those functions
06:17:52 <dEPy> it's basically that yes
06:17:54 <int-e> except for the encapsulation aspect, that's what they are.
06:17:55 <dEPy> afaik
06:18:03 <beaky> ah
06:18:13 <beaky> when should I use objects over data?
06:19:12 <mauke_tmp> in Haskell?
06:19:22 <int-e> :)
06:19:46 <int-e> I was going to say that in Haskell I never use objects and don't particularly miss them.
06:20:14 <beaky> ah I meant in other progamming languages
06:20:33 <int-e> . o O ( Is there a #other-programming-languages ? )
06:20:39 <dEPy> beaky, so you would only use what? strings, arrays, ... ?
06:20:56 <Cale> I sometimes use objects in Haskell, with a pretty simple encoding that disregards a lot of the features that OOP languages like to discuss.
06:21:00 <elliott> int-e: #haskell-blah?
06:21:06 <int-e> beaky: some people talk about "pure" OO where you also don't get a choice; everything is an object.
06:21:21 <beaky> a
06:21:23 <int-e> elliott: I guess :)
06:21:39 <Cale> i.e. just represent objects as records of methods which produce the new state of the object as their result.
06:21:56 <Cale> (or part of their result)
06:23:18 <Cale> and then you have "constructors" for any given type of object which are just functions whose parameters are the "private members" of the object
06:24:03 <dEPy> beaky, which programming language is your main?
06:24:15 <beaky> I like C++
06:24:19 <int-e> Cale: sure ... we can think of Data.Map (say) as implementing a class and the individual Map a b values as objects. I tend not to do that. :)
06:25:10 <int-e> Cale: oh, wait
06:25:22 <elliott> that's not what cale is saying
06:25:22 <dEPy> beaky, did you ever implement a tree data structure?
06:25:24 <Cale> int-e: Well, I like to think of traditional OOP as fundamentally being coinductive, and traditional FP as being inductive. :)
06:25:29 <int-e> Cale: you're implementing the virtual method tables part, sorry. I have to read more carefully.
06:26:00 <int-e> Cale: (as you can see I take a very low level view on OO ;-) )
06:26:03 <Cale> i.e. objects are things determined entirely by their responses to messages
06:26:29 <beaky> dEPy: I will try to someday :D
06:27:21 <int-e> Cale: anyway, good point. it makes sense to call such things objects.
06:28:37 <jagaj> I know this is a terrible divisive question to ask, but given I'm fine editing in either, is there a general preference for vim or emacs in the haskell community (or another editor)?
06:28:42 <Cale> I think the type of an object ought to be entirely determined by types of the messages it is willing to respond to (and the types of the responses)
06:29:01 <Cale> jagaj: anything which will convert tabs to spaces is fine
06:29:31 <Eduard_Munteanu> jagaj: I think I've mostly heard about vim users
06:29:42 <XexonixXexillion> I use emacs with evil
06:29:48 <Cale> I use vim myself for the most part, but I've used emacs in the past.
06:29:51 <Eduard_Munteanu> But emacs is well supported too. (And it might get support for holes and other neat stuff.)
06:30:23 <bitonic> jagaj: emacs and vim have comparable support.  ghc-mod will probably work better with emacs
06:30:39 <dEPy> beaky, I think this explains it quite good: http://www.tutorialspoint.com/cplusplus/cpp_classes_objects.htm
06:31:00 <Cale> I think C++ and Java actually make a mess of OOP rather than supporting it well.
06:31:00 <jagaj> thank you for the answers, this place is always great :)
06:31:43 <Cale> Tying method implementations to the types of the objects involved is ridiculous and crippling.
06:32:00 <dEPy> Yes c++ and Java are not the best role models. :D
06:32:28 <Cale> From that perspective, my simple Haskell translation does a better job :P
06:32:48 <beaky> ah
06:35:00 <statusfailed> mm_freak: re: Acid & snap: I mean a thread within the same program, so I start snap in one thread, and some daemon accessing acid in another
06:35:07 <statusfailed> (sorry about the late reply, was out)
06:35:29 <Cale> Subclasses and inheritance are largely red herrings created as attempts to work around the inconvenience of that attachment of method implementations to the types of objects.
06:35:57 <Cale> There's an extent to which subtyping is really a good thing there, but it's not nearly as important as all the time spent on it would suggest
06:36:39 <Cale> if you can treat objects which respond to the same methods/messages as having the same type, then the need for subclasses is greatly diminished
06:37:01 <danr> Cale: are there languages that support OOP well?
06:37:22 <Cale> Well, my prototypical example of an OOP language is smalltalk, but it's untyped.
06:38:55 <Cale> Haskell with extensible records of some sort would do a fine job.
06:39:11 <bitonic> the mythical Haskell extensible record
06:39:55 <Cale> (but even without extensible records, I think it does a good enough job in practice)
06:40:19 <bitonic> Cale: agreed, I think the Haskell community is obsesses on the record problem a bit too much :P
06:40:35 <bitonic> /s/is//
06:43:02 <neutrino_> hey Cale!
06:43:09 <neutrino_> any idea about the mystery arrows yesterday?
06:45:34 <Cale> neutrino_: bug fixed in head
06:46:12 <mauke_tmp> heh
06:46:49 <mauke_tmp> that sounds like "sorry, I misunderstood how this is supposed to work. not a bug"
06:50:33 <merijn> I run into tons of those :p
06:54:05 <Cale> mauke_tmp: I mean HEAD :)
06:57:09 * hackagebot skein 1.0.2 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.2 (FelipeLessa)
07:12:00 <b__> for calculating Hamming distance I have: hamming x y = sum $ zipWith popDiff (BS.unpack x) (BS.unpack y) where popDiff x y = length $ filter (\i -> testBit x i /= testBit y i) [0..bitSize x - 1], but I feel like I must be missing a more clean way of writing this
07:12:15 <Lethalman> \o/
07:13:09 <Lethalman> b__, i was able to read it
07:13:27 <luite> b__: xor and popCount
07:13:49 <Lethalman> right
07:14:32 <ab9rf> :t popCount
07:14:34 <lambdabot> Bits a => a -> Int
07:14:42 <b__> oh yes, ofc, cheers
07:15:34 <luite> b__: also using bytestrings own zipWith might be more efficient than unpacking first
07:15:52 <Lethalman> @pl f x y = popCount $ xor x y
07:15:53 <lambdabot> f = (popCount .) . xor
07:16:23 <Lethalman> :t popCount .
07:16:24 <lambdabot> parse error (possibly incorrect indentation)
07:16:38 <ab9rf> :t (popCount .)
07:16:40 <lambdabot> Bits b => (a -> b) -> a -> Int
07:16:46 <ab9rf> the parens matter
07:18:24 <Lethalman> :t (id .)
07:18:25 <lambdabot> (a -> c) -> a -> c
07:19:01 <ab9rf> @unpl (id .)
07:19:02 <lambdabot> (\ b e -> b e)
07:19:48 <aCube> @ty id `asTypeOf` (id .)
07:19:49 <lambdabot> (a -> b) -> a -> b
07:20:27 <aCube> @pl (id .)
07:20:28 <lambdabot> id
07:46:17 <klrr> im writing a very minimal lisp, to make implement state and making it possible to decleare variables i will define a type called Env holding all predefined and defined vars and expanding as the program runs, now in the Write Yourself a Scheme it says haskell has a SF Monad for this but instead uses IORef, i wonder what this SF Monad is and if it's good for this use, i also wonder if there might be another type i can use to have a list of pairs holding all varia
07:47:11 * hackagebot binary-conduit 1.1.1 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.1.1 (AlexanderVershilov)
07:47:17 <pharaun> you got cut off at "holding all varia"
07:47:18 * geekosaur wonders if that was supposed to be ST
07:48:51 <klrr> pharaun: cut off? okey, "all predefined and defined vars and  expanding as the program runs, now in the Write Yourself a Scheme it says haskell has a SF  Monad for this but instead uses IORef, i wonder what this SF Monad is and if it's good for  this use, i also wonder if there might be another type i can use to have a list of pairs  holding all variables?
07:48:56 <klrr> "
07:49:27 <pharaun> ahh
07:49:56 <pharaun> i've never done that "write yourself a scheme" yet but the SF sounds like ST to me
07:50:12 <pharaun> and also for variables i would think you would want the state monad
07:51:21 <klrr> pharaun: okey thanks!
08:01:18 <ab9rf> SF?
08:01:39 <klrr> is there a way to simulate state using a list of pairs, and then passing that list to all functions and in the main loop passing it back when recursive occures so it evolves with the program?
08:03:14 <arkeet> klrr: have you seen State?
08:03:27 <ab9rf> that sounds like a description of State
08:04:30 <klrr> arkeet: reading about it now, but if the method that i describes aswell i might use that instead since it's very safe since there's no monads involved
08:04:38 <arkeet> what?
08:04:49 <arkeet> there's nothing unsafe about moands.
08:04:51 <arkeet> or monads.
08:05:10 <klrr> oh, i thought monads was types containing actions which are side-effects
08:05:13 <arkeet> no
08:05:27 <arkeet> a monad is an instance of the Monad typeclass
08:05:27 <klrr> oh crap :x now i have to read about them again ...
08:05:32 <arkeet> :(
08:05:36 <klrr> oh okey
08:05:39 <ChongLi> just don't read analogies
08:05:43 <klrr> actions are side-effects?
08:05:44 <ChongLi> analogies don't help you learn monads
08:05:56 <ChongLi> actions are values representing possible side-effects
08:06:01 <klrr> okey
08:06:10 <arkeet> Monad has nothing to do with side effects
08:06:15 <klrr> is IO a monad that has (Maybe action) in it?
08:06:27 <arkeet> I don't understand the question.
08:06:39 <klrr> i thought Monads iss the way you have side-effects in a purely funtional language
08:06:54 <ChongLi> it's one way
08:07:01 <ab9rf> burrito warning
08:07:02 <geekosaur> monads provide a pattern which can be used that way
08:07:04 <ChongLi> but monads do far more than that
08:07:10 <geekosaur> it does not *defne* monads, thoguh
08:07:20 <arkeet> klrr: no
08:07:21 <geekosaur> they just happen to be convenient for it
08:07:22 <klrr> **test**
08:07:31 <klrr> geekosaur: how do you make text bold?
08:07:33 <arkeet> klrr: IO is the way you do side-effects in haskell.
08:07:43 <klrr> arkeet: okey, so what's monads used for?
08:07:44 <arkeet> IO is just one example of a monad.
08:07:48 <taylorgb> Monads should have been kept a secret
08:07:50 <arkeet> there are lots of monads that have nothing to do with IO.
08:07:52 <ChongLi> klrr: monads are used for a lot of things
08:07:55 <arkeet> klrr: what are classes used for?
08:07:55 <adek> Is there any reason why in MTL there is no MaybeT? I can find on haskell sites complete implementation of this transfromer, but it isn't included in MTL...
08:08:05 <geekosaur> klrr: huh. your client is doing interesting things, I guess. I wrapped one word in *s
08:08:11 <arkeet> adek: it's there
08:08:14 <arkeet> Control.Monad.Trans.Maybe
08:08:17 <geekosaur> didn't come out bold here
08:08:17 <klrr> oh so a monad is just a type deriving Monad, it can basically be anything
08:08:18 <ChongLi> representing optional types, non-deterministic computation, continuations, state values etc.
08:08:25 <adek> arkeet: its transformers package.
08:08:27 <arkeet> adek: er, it's in transformers
08:08:32 <ChongLi> klrr: yes
08:08:38 <klrr> oh
08:08:42 <klrr> that's good
08:08:46 <ChongLi> all it takes to be a monad is to satisfy a few simple laws
08:08:55 <arkeet> klrr: here's an exercise.
08:08:56 <ab9rf> klrr: anything that meets the monad rules is a monad.
08:09:03 <klrr> also, it's barrowed from cathegory theory and that's why it' has so fearful name right?
08:09:03 <adek> One thing which makes transformers not that useful is the amoung of lifting I have to do...
08:09:09 <ab9rf> klrr: lots of things meet the monad rules
08:09:16 <arkeet> yes, we should have not called it "moand"
08:09:19 <arkeet> er monad
08:09:21 <klrr> Maybe isnt a instance of Monad but is a monad?
08:09:22 <arkeet> we should have called it "warm fuzzy thing"
08:09:29 <arkeet> it is an instance of Monad.
08:09:29 <geekosaur> huh?
08:09:29 <ChongLi> I don't get what's so fearful about the name
08:09:30 <ab9rf> arkeet: hehe
08:09:37 <ChongLi> it's just a name
08:09:48 <arkeet> ChongLi: it's a ~category theory~ name
08:10:00 <ChongLi> yeah but you don't have to know that
08:10:02 <ab9rf> arkeet: scary mathematics! math is hard!
08:10:03 <arkeet> all hail the mighty Monad
08:10:08 <ChongLi> and category theory is simple too
08:10:16 <klrr> okey, well gonna watch Oblivion at the theatre, back later guys :D
08:10:22 <arkeet> yes but it's also intimidating to those who don't know it
08:10:24 <ChongLi> bye
08:10:40 <arkeet> aw I was going to give him a series of exercises by the end of which he will have reinvented the State monad.
08:10:43 <ab9rf> arkeet: and not made easier by people casually throwing around terms like 'endofunctor' which honestly to me sounds like a medical device
08:10:56 <arkeet> lol
08:11:28 <arkeet> @quote indexed.monad
08:11:29 <lambdabot> ky3 says: Indexed monads are just categories in the category of endofunctors, what's the problem?
08:12:02 <simpson> Oooooh.
08:12:06 <simpson> Now I understand indexed monads.
08:12:12 <geekosaur> klrr, if your Maybe question is based on the "possible side effects" comment earlier, it's not that kind of "possible". what side effect is (return () :: IO ()) ?
08:12:17 <FireFly> They're so simple?
08:12:17 <arkeet> simpson: no, not quite.
08:12:28 <arkeet> the quote is a bit uh
08:12:40 <arkeet> it should say "categories enriched over the category of endofunctors"
08:12:48 <arkeet> :p
08:13:00 <ab9rf> arkeet: the state monad actually helped me understand monads more than IO did
08:13:06 <arkeet> of course
08:13:11 <arkeet> IO is magical.
08:13:19 <arkeet> State isn't. we can study State.
08:13:31 <arkeet> it's a pretty good example of a monad too
08:13:33 <ab9rf> bah, spam on my business account
08:13:35 <ab9rf> i hate spam
08:13:43 <arkeet> it comes from my favourite adjunction.
08:14:08 <ab9rf> "adjunction" makes me thinkg of the home shopping network
08:14:16 <arkeet> ??
08:14:35 <ab9rf> cuz that's what you get when you join a bunch of ads together in an endless stream
08:15:15 <ab9rf> arkeet: my jargon parsing system is hopelessly polluted
08:15:26 <arkeet> heh
08:15:39 <ab9rf> comes from having gone to law school, i suspect
08:15:46 <parcs> what's the difference between return . unsafePerformIO and unsafeInterleaveIO ?
08:16:27 <arkeet> one is unsafe, and the other is unsafe.
08:17:06 <ion> If you think of the IO monad as something that only generates a pure AST and leave the interpretation of that for the runtime, there’s no magic.
08:17:23 <arkeet> true.
08:17:44 <ab9rf> ion: the magic is "under the hood" where the gremlins live
08:19:23 <Kinnison> unsafeInterleaveIO thunks harder I think
08:27:09 <osa1> anyone knows an alternative for hinotify? I'm looking for something more high level than just inotify bindings(like watchers in nodejs's file_system module)
08:45:47 <chrisdotcode__> hello everyone :)
08:46:49 <orzo> MonadReader seems to be mainly useful for stateful monads.  I used it to set a contextual value on my monad that is required by the bind function, but because I've no state, ask always returns the same thing.  This makes me think that perhaps MonadReader wasn't really apropriate for this
09:05:49 <chrisdotcode> so guys, if I'm getting the head of a reversed list, I'd do: "f = head . reverse". but when you're thinking about it, you reverse the list first, is there anyway to write it this way, something like, "f  l = reverse l >> head"
09:06:11 <chrisdotcode> (where ">>" represents pipe)
09:07:13 <cschneid> page 291 of LYAH has an example written as both a list monad w/ guard, and a non-monad function using filter.  Is there a meaningful difference in performance between the two? Should I naturally prefer one or the other?
09:07:14 <orzo> chrisdotcode: i've never used it, but i think Arrows has something for you
09:07:16 <Iceland_jack> http://hackage.haskell.org/package/reverse-apply
09:07:17 <elliott> f l = reverse l & head with (&) from the lens package
09:07:19 <elliott> or f = reverse >>> head
09:07:23 <elliott> using (>>>) from Control.Category
09:07:35 <orzo> oh ok
09:07:39 <elliott> I actually don't think about it in the reversed way, and I think it gets less common the more experience you have
09:07:50 <elliott> for instance, look at your sentence: "head of a reversed list". "head" comes first there
09:07:50 <chrisdotcode> elliott: ">>>" looks sweet! it looks and reads really naturally. thanks :D
09:08:08 <elliott> thinking in "steps" (i.e. reverse coming up) is sort of reminiscent of the imperative mindset, I think
09:08:12 <elliott> er, *coming first
09:08:21 <chrisdotcode> elliott: so when thinking about the problem, "get the last element of a list", you think "get the head of a reversed list"?
09:08:21 <elliott> (similarly we write functions as (f x) not (x f))
09:08:33 <chrisdotcode> cause I think "first reverse the list, then get the head"...
09:08:39 <elliott> chrisdotcode: well, I wouldn't write reverse that way, but sure
09:08:42 <elliott> ER
09:08:45 <elliott> er
09:08:48 <elliott> wouldn't write last that way
09:08:50 <chrisdotcode> and yeah, I'm still stuck between works (imperative/functional)
09:09:13 <chrisdotcode> elliott: how would you think of/solve the problem?
09:09:14 <elliott> I'd think: the last element of a singleton list is its sole element: last [x] = x; the last element of a cons is the last element of its tail: last (_:xs) = last xs
09:09:20 <ab9rf> functative?  imperional?
09:09:46 <chrisdotcode> elliott: okay, so you're already thinking of a list recursively...
09:09:52 <chrisdotcode> I haven't yet graduated my mind to that...
09:10:07 <orzo> you really think that way habitually, elliott?
09:10:35 <orzo> i dont think i ever will :P
09:10:47 <jfischoff> I wonder if x $ f > g > h would be better for us left to right readers (assuming we had start with that style first)
09:11:39 <jfischoff> h . g . f $ x makes sense to me but that is because I am used to f(x)
09:12:07 <chrisdotcode> jfischoff: so the composition is h(g(f(x))), right? and the former, x(f(g(h))?
09:12:17 <orzo> i typically use a ware clause and bind each step when i have a lot of compositions
09:12:21 <orzo> where clause
09:12:51 <orzo> bindings let you list the steps in any order you want
09:12:53 <jfischoff> chrisdotcode: the former is something I just made up that is meant to be the same as the later
09:13:09 <jfischoff> but yeah that is how to interpret composition
09:13:28 <chrisdotcode> orzo, jfischoff: so how would you initially think of solving the "last element of list problem"?
09:13:39 <Eduard_Munteanu> @hoogle ($$)
09:13:40 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
09:13:40 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
09:13:40 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
09:13:54 <orzo> chrisdotcode: Prelude.last
09:13:59 <Eduard_Munteanu> @hoogle a -> (a -> b) -> b
09:13:59 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:13:59 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
09:13:59 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
09:14:08 <Eduard_Munteanu> Grr.
09:14:30 <chrisdotcode> orzo: hahaha you know what I mean :)
09:14:47 <Eduard_Munteanu> x $$ f >>> g >>> h    -- something like that, if you define a suitable ($$), the other operator is already there
09:15:23 <orzo> I have a recuring pattern in my code where i define an extend function extend [x]=repeat x  and extend (x:xs) = x : extend xs
09:15:30 <orzo> repeating the last element of the list
09:16:12 <orzo> so i guess i solve the problem the way elliott thinks of it?
09:16:15 <jfischoff> chrisdotcode: personally I write : head . reverse but I can see why would might want to do what Eduard_Munteanu just said. Its just not idiomatic, but who knows maybe it should be
09:17:09 <chrisdotcode> jfischoff: well I was asking mostly because I would go with "head. reverse", but I would *think* of it as, "reverse the head of the list", which is "backwards"
09:17:10 <orzo> i don't like to use reverse because i worry it will interfere with fusion
09:17:32 <jfischoff> christdotcode: that's what I end up doing
09:17:38 <Eduard_Munteanu> orzo: it's also slow
09:17:39 <jfischoff> opps
09:17:49 <jfischoff> chrisdotcode i mean
09:17:51 <orzo> Eduard_Munteanu: it's slow because it interferes with fusion
09:18:01 <orzo> heh
09:18:09 <chrisdotcode> Eduard_Munteanu: reverse is slow?
09:18:20 <orzo> yes
09:18:20 <Eduard_Munteanu> As opposed to not needing to reverse at all.
09:18:31 <Eduard_Munteanu> It has to traverse the entire list.
09:19:30 <chrisdotcode> true
09:19:42 <chrisdotcode> but doesn't the recursive strategy have to too?
09:19:59 <orzo> chrisdotcode: yes, except it fuses
09:20:07 <chrisdotcode> orzo: what's fusion?
09:20:10 <Eduard_Munteanu> Ah, that fusion.
09:20:19 <Taneb> reverse goes as fast as reverse can go, doesn't it?
09:20:21 <Eduard_Munteanu> I thought you were concerned about eliminating the list altogether.
09:20:29 <Eduard_Munteanu> Taneb: yeah
09:20:46 <chrisdotcode> Eduard_Munteanu: I was concerned with thinking about the problem in my head, and translating that into the code :)
09:20:56 * chrisdotcode is a haskell newbie
09:21:27 <orzo> look at my extend function, i perform an action to the last element of the list only.  It is O(n) to find it so I could use reverse and have an O(n) version also, but the recursive version is superior due to fusion
09:21:42 <orzo> chrisdotcode: did you used to code in an imperitive language like C?
09:22:10 <chrisdotcode> orzo: I'm was/am Pythonista :)
09:22:29 <orzo> you know how it is better, in those languages to do one loop that performs multiple tasks than it is to start over and do multiple passes?
09:23:20 <chrisdotcode> orzo: yeah, declarative style
09:23:34 <orzo> chrisdotcode: th epoint is that you dont do multiple passes if you can avoid it
09:23:39 <chrisdotcode> orzo: right
09:24:00 <orzo> in haskell, thats what fusion is.  THe compiler is doing in one pass what it would otherwise do in multiple
09:24:35 <jfischoff> where is fusion coming into play with last?
09:24:54 <Eduard_Munteanu> Well, in some cases it can remove data structures altogether.
09:25:23 <tromp> @src comparing
09:25:24 <lambdabot> Source not found. My brain just exploded
09:25:41 <orzo> think of the tail of a list as an unevaluated thunk
09:26:19 <chrisdotcode> orzo: I've heard the term "thunk" in LYAH, but forgot what it means
09:26:39 <orzo> head (map (f . g) xs) can give you the head without doing any evaluation on the tail
09:26:51 <orzo> thunk is simply a function with no arguments
09:27:11 <orzo> its a chunk of code
09:27:30 <chrisdotcode> orzo: so, I had this question, is a function without argument also equivalent to a variable? (x = 4)
09:27:34 <Cale> "thunk" is a name for the the runtime representation of an expression
09:27:45 <chrisdotcode> "x is a function that returns 4" "x's value is equal to 4"
09:27:46 <jfischoff> chrisdotcode: no
09:27:46 <Cale> Personally, I prefer just calling the things expressions anyway.
09:28:05 <chrisdotcode> hi Cale
09:28:09 <Cale> hi
09:28:32 <orzo> its un-evaluated
09:28:37 <chrisdotcode> so a function with no arguments (that's not in point's free style) *isn't* technically equivalent to a variable?
09:28:56 <orzo> meaning to use the value of the thunk or expression, the computer has do some work to compute it
09:28:58 <Cale> um
09:29:09 <geekosaur> the closest thing to a variable in haskell is an IORef, actually. bindings are not variable
09:29:15 <Cale> By a function with no arguments, do you mean a function which has yet to be applied?
09:29:19 <Cale> Like:  map
09:29:25 <chrisdotcode> okay, they're just *bindings*
09:29:30 <chrisdotcode> Cale: I mean, something like "x = 4"
09:29:35 <orzo> my explanation of it as a funciton with no arguments is inferior, probably go with Cale's and other people's explanation
09:29:41 <bitonic> chrisdotcode: that’s not a function
09:29:43 <Cale> chrisdotcode: That's not usually a function
09:29:51 <Cale> (unless there's an instance of Num for functions)
09:29:52 <chrisdotcode> but can't it be *read* as a function?
09:29:58 <Cale> ?
09:30:01 <chrisdotcode> "x takes no args, and returns 4, always"
09:30:05 <tromp> functions are values of type a -> b
09:30:09 <Cale> A function is something whose type is a -> b
09:30:15 <chrisdotcode> by definition?
09:30:15 <Cale> where a and b are some types
09:30:17 <Cale> yes
09:30:20 <chrisdotcode> oh, okay
09:30:43 <chrisdotcode> so ( -> a ) isn't a function, then, right?
09:30:46 <Cale> Otherwise, there's no distinction between the word "function" and the word "value", which makes the whole thing rather pointless.
09:30:47 <chrisdotcode> (it's a functor, right? :D)
09:30:51 <tromp> functions are things that can be applied
09:30:56 <Cale> You mean (->) a?
09:30:57 <orzo> in emperitive languages like C or scheme, there are "functions" that take no arguments, and thats the sense i meant
09:31:19 <chrisdotcode> orzo: yeah, that's what I was talking about
09:31:21 <Cale> That's a type constructor -- you could think of it as a function at the type level, with kind * -> *
09:31:37 <Clint> i had no idea that scheme was emperitive
09:31:39 <bitonic> orzo, chrisdotcode: those roughly correspond to ‘() -> a’ in Haskell, but in Haskell you don’t need them
09:31:40 <Cale> and yeah, it happens to be a functor, but the reason for that involves the fact that there's a suitable definition of fmap
09:31:54 <chrisdotcode> bitonic: "x =4", right?
09:32:04 <bitonic> chrisdotcode: no, ‘x () = 4’
09:32:12 <orzo> scheme is imperitive enough the way i did it, coming from C++
09:32:12 <Eduard_Munteanu> The distinction isn't *really* relevant though, given the first-classness of functions.
09:32:18 <chrisdotcode> bitonic: oh, yes. that makes sense
09:32:42 <chrisdotcode> Eduard_Munteanu: yeah, I don't really see any practical differences, I was just curious.
09:33:14 <tac> orzo: Common Lisp is very imperative. Scheme is a language where you can mix imperative and functional pretty well
09:33:27 <Eduard_Munteanu> There are some technical differences though, e.g. you can trip on the monomorphism restriction depending on how you define things.
09:33:29 <chrisdotcode> tac: clisp is imperative?!
09:33:51 <tac> chrisdotcode: sorry, I meant that looking at the standard library, you see it all over the place
09:34:02 <tac> There's a million different ways to set something
09:34:06 <orzo> everything seems imperative now that i know a pure functional language heh
09:34:22 <bitonic> I don’t see how Common Lisp is ‘more’ imperative than Scheme, they’re both quite imperative in the sense that mutation is well accepted :P
09:34:31 <chrisdotcode> I'm really a fan of purity (even though I don't yet know monads), on a philosophical level.
09:34:40 <bitonic> tac: that’s just because the library is much, much bigger than whatever functions Scheme has
09:34:49 <tac> that could be
09:35:05 <chrisdotcode> so are "pure" and "referentially transparent" exactly equivalent?
09:35:10 <typoclass> chrisdotcode: that's a good intuition. (and don't worry about the monads.)
09:35:22 <orzo> well we are straying from the topic of fusion and why reverse is inferior to recursion, which is something fundamental chrisdotcode should understand
09:35:22 <dolio> chrisdotcode: No.
09:35:23 <Eduard_Munteanu> Not really.
09:35:33 <Eduard_Munteanu> Pure is stronger.
09:35:42 <chrisdotcode> pure also means immutability?
09:35:51 <chrisdotcode> *also includes
09:36:05 <Eduard_Munteanu> You can have referential transparency while having side-effects, as long as they don't affect the result. But that's not pure.
09:36:20 <chrisdotcode> Eduard_Munteanu: right. okay, I got it.
09:36:33 <chrisdotcode> orzo: so yes, tell me please: what is fusion, and why is it so important? :)
09:36:55 <hpaste> “Anonymous Coward” pasted “operator overloading” at http://hpaste.org/86639
09:37:59 <geekosaur> to whoever pasted that, there is no operator overloading as you appear to know it in haskell
09:38:28 <geekosaur> the correct thing to do is to make your Network type an instance of Eq, thereby defining a suitable (==) for it
09:38:39 <orzo> chrisdotcode, consider my extend function that repeats endlessly the last element of a list.  I could write it thus: extend xs = xs ++ repeat (last xs)
09:38:57 <orzo> hm, actually maybe this is a poor example heh
09:38:59 <chrisdotcode> orzo: right
09:39:07 <hpaste> geekosaur annotated “operator overloading” with “operator overloading (annotation)” at http://hpaste.org/86639#a86640
09:39:10 <chrisdotcode> orzo: right to your first statement
09:39:15 <dolio> chrisdotcode: 'Pure' is usually taken to mean that evaluation order doesn't affect results. Referential transparency means that inlining or factoring things in your program doesn't change the results.
09:39:32 <dolio> I'm not really sure that one is stronger than the other.
09:39:40 <chrisdotcode> dolio: right. because you could very well have referentially transperent programs in other language, but possible not pure.
09:40:21 <orzo> chrisdotcode: well, consider what happens when you evaluate this list and you reach the end of the original.  It then must start over again and traverse the original list to find its last element and then it can give you the next item in the list
09:40:26 <dolio> Well, you can have pure things that aren't referentially transparent, too.
09:40:42 <dolio> Depending on how exactly you interpret them.
09:40:48 <cenger> Hi all. I am writing a module, which consists of some graph data types, and operations. I am asked to define a new class called NetworkOp, and give instance of == operator for Network type.
09:41:13 <geekosaur> cenger: can we see this assignment?
09:41:22 <geekosaur> because the way you are interpreting it is not at all correct for Haskell
09:41:28 <geekosaur> http://hpaste.org/86639
09:41:28 <orzo> chrisdotcode: but if i define it thus:  extend (x:xs) = x:extend xs   extend [x] = repeat x   It never has to go back to the beginning
09:42:09 <geekosaur> of course, now that I know it's an assignment, I probably shouldn't have pasted that
09:42:16 <chrisdotcode> orzo: shouldn't the second definition be: extend x = repeat x
09:42:17 <chrisdotcode> ?
09:43:22 <orzo> no, the second defintion means to tell it what to do in the case of a singleton list, and it should actually come first, as the first definition, so that it matches a singleton list and the other case is matched only on lists with more than 1 element
09:43:28 <cenger> geekosaur: thanks for your answer. It's an assignment but it consists of about a hundred lines of code. pasting that a few lines shouldn't be considered as cheating.:)
09:43:35 <dolio> For instance, in ML, if we wrote the equivalent of: 'fac n = let fnm = fac (n-1) in if n <= 1 then 1 else fnm', it would be different from 'fac n = if n <= 1 then 1 else fac (n-1)'.
09:43:40 <refold> Given a list of monadic actions that return Bool, is there a standard function to execute the actions from the list only until one of them returns True?
09:43:53 <dolio> Because the first would never finish.
09:44:10 <geekosaur> cenger, I am trying to understand why you think (==) should be part of NetworkOp
09:44:14 <quchen> refold: You mean something like takeWhileM? Not that I know of
09:44:15 <dolio> Despite the fact that the only change we made was factoring out an expression into a named value.
09:44:27 <dolio> And there are no side effects going on here, really.
09:44:35 <refold> quchen: Yeah, something like that.
09:44:49 <orzo> it was my mistake to give the cases in the wrong order
09:46:04 <orzo> i could have wrote: extend (x:y:ys) = x:y:extend ys  for the more-than-one-element case, so that the order i give the defintions does not matter
09:46:19 <cenger> geekosaur: because it what I am told in the assignment text. quoting exactly: "For the following operator, define a new class called NetworkOp, and give instance of this operator for Network type"
09:47:06 <dolio> chrisdotcode: So even in a pure ML, you will probably end up being more careful about how you factor your programs (and factoring them less).
09:47:20 <dolio> Because there are certain transformations you're not at liberty to do.
09:47:43 <dolio> If you want to preserve termination and such.
09:48:08 <monochrom> don't worry about accidentally solving homework. it is of highest pedagogical value. Piaget's theory: concrete before abstract. therefore, actual code solution before handwaving "guidance"
09:48:18 <orzo> If optimisations are turned high, can ghc refactor simple reverse-based code like extend xs = xs ++ repeat (last xs)  ?
09:48:18 <geekosaur> cenger, if this assignment really wants a new class that takes over (==), it's not actually teaching you useful haskell
09:48:28 <orzo> that question is for the gurus
09:48:30 <orzo> heh
09:49:04 <geekosaur> (well, it could be, but that should really only be for people who do not confuse typeclasses with overloading)
09:49:06 <monochrom> (by the same token, actual verbatim uncensored homework question before student's misinterpretation)
09:51:15 <quchen> refold: I'm not sure how you want your function to behave, maybe give us a type sig? "takeWhileM p = sequence . takeWhile p" seems like it could suit your needs
09:52:18 <refold> quchen: I was just wondering if there's something like that in the standard libs. I can write it myself.
09:52:21 <cenger> anyway, thanks for your help. :) I'll read typeclasses chapter again.
09:53:39 <ab9rf> i think people see that typeclasses enable overloading and think they're Just Like Classes
09:55:50 <cschneid> ab9rf: what's a better way to think of them? I know they're not OO, but when do I make a mySum vs. implement a Summable type class?
09:57:15 <fubaz> hi, i'm trying to wrap my head around contravariant functors but i'm a bit confused about what they can be used for. any insights? :)
09:57:44 <monochrom> alarming trend of going out of their way to thank you, but never post actual code or actual homework question. and when you ask for actual code or actual homework question, they go out of their way to thank you once again and more chit-chat, but never what you ask for. already 3 instances in the last 10 hours.
09:58:22 <typoclass> monochrom: thank you
09:58:52 <dolio> fubaz: Some things just are contravariant functors.
09:58:59 <quchen> cschneid: An instance of a typeclass X is something that supports X's operations. Eq is a typeclass for things that can be equal, providing the (==) function. Functor is for things you can map over using the fmap function etc.
09:59:24 <Eduard_Munteanu> Not sure of any useful examples, but you get stuff like  \a -> (a -> r)
09:59:33 <Eduard_Munteanu> (pseudohaskell)
09:59:44 <cschneid> quchen: so if I have several things in my application that can be "summed" (or whatever), would it make sense to make my own summable typeclass and have each type implement `sum`?  When would I not want to standardize like that.
09:59:45 <dolio> For instance, if you have a channel that you can write Bs to, and a function A -> B, it makes sense to be able to use those two things to produce a channel that you can write As to.
09:59:58 <fubaz> hmm
10:00:18 <cschneid> quchen: as opposed to implementing standalone functions: `sumAs` and `sumBs` and such.
10:00:23 <fubaz> okay :)
10:00:33 <dolio> Whereas the read-end is covariant.
10:00:52 <quchen> cschneid: For things like summation, there's the Monoid typeclass. (Which is a lot more general)
10:00:57 <orzo> dolio: i read channel as "irc channel" and Bs as "bull-sh*t" and thought you were about to make a joke
10:00:57 <fubaz> ok, i'll try to meditate on this. thanks dolio & eduard!
10:01:47 <quchen> cschneid: Got some code you could paste? There are multple "sum" things in Haskell, depending on what you need.
10:01:59 <cschneid> quchen: well, I don't mean that in particular. For instance, in my actual application, we have several message types which go out over different transmitters (paging /internet / other weird things).  Would a Transmitter typeclass that implements a `sendMessage` function make sense?
10:02:00 <quchen> There's (+) in Num, which is for numbers
10:02:03 <quchen> There's monoid
10:02:18 <cschneid> quchen: as I mentioned, sum is just an example, and apparenlty a side-tracking one. I know I can sum in easier ways
10:02:26 <cschneid> just trying to figure out when I do or don't want to be using typeclasses
10:02:38 <cschneid> they seem to get a bad rap around here for the most part
10:02:46 <cschneid> rather, an overreliance on them do
10:04:07 <quchen> The general rule of thumb is that typeclasses shouldn't only be a general interface, but also specify some laws (like fmap id = id). Think of typeclasses as a unified framework for something, not just a bunch of functions.
10:04:53 <quchen> cschneid: Maybe have a look at this article: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
10:06:42 <quchen> cschneid: This article demonstrates how you can transform typeclasses to algebraic data types: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
10:07:30 <mm_freak> statusfailed: there is nothing wrong with using acid-state from multiple threads…  in fact, it's encouraged and gives you better performance
10:08:31 <cschneid> quchen: so in my example: I have the concept of a transmitter. which would easily be a data type - data Transmitter = PagingTransmitter | XMPPTransmitter.
10:08:52 <cschneid> quchen: from there, I suppose I can have a single function `sendMessage` that pattern matches on the type of transmitter....
10:09:14 <cschneid> quchen: would that be the best way to handle a situation similar to that? I suppose I can do "polymorphism" without ever really involving typeclasses huh.
10:10:05 <quchen> I'd probably use pattern matching here, yes
10:10:24 <cschneid> quchen: can you split a pattern match across several files? ie, paging.hs and xmpp.hs
10:10:47 <quchen> Sure
10:11:04 <quchen> handle XMPPTransmitter signal = XmppModule.xmpp signal; handle PagingTransmitter signal = PagingModule.pager signal
10:11:05 <jfischoff> I wonder how Tekmo views have evolved since writing that
10:11:31 <cschneid> quchen: ahh, so handle exists in one file, and just proxies off to the real implementation separated out nicely
10:11:33 <cschneid> close enough :)
10:11:56 <quchen> cschneid: All three modules import the data structure from a module and then brew whatever they feel like out of that
10:12:37 <cschneid> quchen: cool. I'm figuring out haskell from the small scale pretty well, but mapping it to think of what our giant ruby app would look like in haskell is tricky.
10:13:43 <jfischoff> cschneid: Have you tried writing an application with a monad transformers?
10:13:43 <quchen> cschneid: Maybe ask again later and one of the more knowledgeable people here will tell you all I said was wrong though
10:14:14 <cschneid> jfischoff: nope, not required for the small stuff I've done so far. and just thought-experimenting on the large stuff
10:14:36 <cschneid> I just have an extremely non-trivial app that I know very well, so it's good to think about what it'd look like if it was ported to haskell
10:15:00 <quchen> AWESOME
10:15:04 <quchen> That's what it would look like. ;-)
10:15:07 <osa1> is there an easy way to introduce record fields as variables in a module(like RecordWildCards but names should be defined in module scope)?
10:15:21 <cschneid> quchen: it's easy to forget about just using data & pattern matching, rather than trying to get fancy. I think that's a tool I've just got to not forget about the basics as I keep learning
10:15:28 <cschneid> thanks for helping me walk through this
10:15:37 <jfischoff> cschneid: after you write an interactive cmd line app with state and a config file, using MonadReader and MonadState it starts to make more sense how to envision how a large program would work
10:16:10 <cschneid> jfischoff: I'll get there. so far it's non-interactive cmd line (arguments, do work, spit back out).
10:16:12 <cschneid> I'll get there
10:16:34 <jfischoff> cschneid: yeah you will :)
10:17:46 <jfischoff> osa1: have you seen how modular-prelude does it?
10:18:08 <orzo> quchen: If i have a situation where I have two very different data structures that are nevertheless interchangable for my purposes except that one might be more efficient (but i'd like to benchmark it), then is a type class appropriate?  I would think yes, but it violates your rule of thumb.
10:19:39 <quchen> orzo: That's why it's a rule of thumb and not a rule. :-)
10:20:16 <geekosaur> that might be a use of typeclasses.. or of packages (separate into its own module, that module's alternate implementations in different packages, use ghc -package whatever
10:20:18 <orzo> quchen: just cheking to see if you had some kind of cool non typeclass solution
10:20:34 <geekosaur> typeclasses could obscure benchmarking in some cases...
10:23:54 <supki> osa1_: you can pattern match on record at the top level, sure
10:23:55 <dEPy> if I wanted to implement my own list reverse function I should use left fold so I can use cons (:) instead of right fold which would use (++) right? So it's more efficient?
10:24:43 <quchen> Reverse with a right fold? How does that work
10:24:51 <Mortchek> @type foldr
10:24:53 <lambdabot> (a -> b -> b) -> b -> [a] -> b
10:24:56 <Mortchek> @type (:)
10:24:58 <lambdabot> a -> [a] -> [a]
10:25:03 <Mortchek> @type foldl
10:25:04 <lambdabot> (a -> b -> a) -> a -> [b] -> a
10:25:25 <Mortchek> dEPy, (:) doesn't fit foldl's first parameter. You'd have to flip it.
10:25:42 <Mortchek> (:) *does* fit foldr's.
10:25:46 <Mortchek> No need to use (++).
10:25:57 <Mortchek> In fact, (++) can be implemented in terms of foldr and (:).
10:26:03 <quchen> Mortchek: But it won't reverse if you put it in foldr.
10:26:06 <kennyd> it fits foldr's but won't do anything
10:26:16 <quchen> Anyway, when reversing a list, you want to get a list out again, which by definition starts with the first element, the former last element. Thus you'll have to walk through the entire list anyway, hence foldl is fine.
10:26:45 <Mortchek> Right, I'm just remarking on types anyway
10:26:47 <osa1_> supki: how? do you mean pattern matching for every field ?
10:27:13 <dEPy> wait, right fold makes no sense yes. D:
10:27:16 <quchen> In general you want to use foldl only if you're sure that in any possible result, you'll always have needed to evaluate the entire list. Examples: sum, product, reverse.
10:27:57 <mm_freak> it's not even true for sum and produect
10:27:57 <hpaste> supki pasted “for osa1” at http://hpaste.org/86642
10:27:59 <quchen> (I meant "evaluate" as "walk through" there)
10:28:00 <mm_freak> reverse is the only good example there
10:28:12 <supki> osa1_: like that ^
10:28:23 <dEPy> is it even possible to reverse using right fold?
10:28:27 <quchen> mm_freak: Well, modulo seq of course
10:28:38 <mm_freak> quchen: no, literally
10:28:38 <quchen> dEPy: Yes, by implementing foldl with foldr ;-)
10:28:46 <dEPy> quchen, :D
10:29:01 <osa1_> supki: whoa that's exactly what I was thinking, thanks
10:29:02 <elliott> dEPy: yes.
10:29:05 <elliott> and not the way quchen says.
10:29:07 <mm_freak> you don't want to use foldl/foldl' for sum and project in general…  you want to use them for Int, Double, Rational, …
10:29:12 <elliott> you can write any list function with foldr and some ingenuity.
10:29:30 <quchen> mm_freak: Right, for lazy nats it would be bad
10:29:33 <dEPy> elliott, how would you write reverse then?
10:29:58 <elliott> dEPy: there's a good article on it, though I forget where. a common technique when doing this is to make the result of your fold be a function
10:30:20 <mm_freak> > foldr (\x -> (++ [x])) [] "abcdefg"
10:30:23 <lambdabot>   "gfedcba"
10:30:41 <quchen> AAAAAAAAH ;-)
10:30:47 <elliott> mm_freak: that's the boring way. :p
10:30:57 <dEPy> a, :)
10:31:01 <elliott> that doesn't use any trickery at all!
10:31:10 <mm_freak> sorry ;)
10:31:39 <Mortchek> Now try writing in only in terms of list constructors
10:31:42 <haasn> > foldr (\x -> (.(x:))) id "abcdefg" []
10:31:43 <lambdabot>   "gfedcba"
10:31:45 <Mortchek> \o/
10:31:52 <mm_freak> Mortchek: i did
10:31:56 <Mortchek> Or, there's composition in there
10:32:00 <Mortchek> mm_freak, (++) isn't a list constructor
10:32:10 <quchen> The only step down from here would be pointless :s
10:32:16 <mm_freak> Mortchek: but (++) is written in terms of a list constructor
10:32:22 <Mortchek> Sure
10:32:29 <mm_freak> "in terms of list constructors" is transitive
10:32:59 <k00mi> @pl \x -> (.(x:))
10:33:00 <lambdabot> flip (.) . (:)
10:33:35 <pygmalion> What does zipWith do when one of the lists is infinite? I assumed it would just stop when it got to the end of the non-infinite list, but that doesn't seem to be happening.
10:33:51 <mm_freak> pygmalion: that's what happens
10:34:03 <monochrom> > zipWith (+) [1] (repeat 0)
10:34:05 <lambdabot>   [1]
10:34:08 <mm_freak> > zipWith replicate [1..] "abcde"
10:34:08 <monochrom> works for me
10:34:10 <lambdabot>   ["a","bb","ccc","dddd","eeeee"]
10:34:20 <pygmalion> hmm.
10:34:38 <elliott> zipWith's behaviour is actually guaranteed
10:34:39 <pygmalion> I must be doing something else wrong!
10:34:43 <elliott> it has to do what it does to have the type it has
10:34:54 <mm_freak> elliott: no
10:35:06 <Mortchek> zipWith _ _ _ = []
10:35:12 <mm_freak> wrongZipWith f xs ys = zipWith f (cycle xs) (cycle ys)
10:35:17 <elliott> I mean its behaviour when one list is longer than another
10:35:32 <elliott> well, I guess it could case on the lengths beforehand. *sigh*
10:35:40 <elliott> but then it'd break on infinite lists.
10:35:45 <elliott> so it actually couldn't.
10:35:47 <mm_freak> elliott: zipWith's type allows all kinds of weird things like repeating the last element forever or something
10:36:01 <elliott> mm_freak: my claim is something like this:
10:36:22 <elliott> given zipWith's behaviour on lists of equal length (which includes infinite lists), zipWith's behaviour on lists of unequal length is guaranteed
10:36:42 <mm_freak> elliott: i don't understand…
10:36:44 <orzo> elliott: what if it applies my extend function to both lists so that they are always infinite?
10:36:45 <haasn> it could still repeat the last element
10:37:07 <orzo> elliott: extend [x]=repeat x, extend (x:xs)=x:extend xs
10:37:23 <Mortchek> @djinn (a -> b -> c) -> [a] -> [b] -> [c]
10:37:24 <lambdabot> Error: Undefined type []
10:38:07 <mm_freak> i think that zipWith isn't really well-defined for lists…  it's a stream operation
10:38:15 <mm_freak> or a Vec operation
10:38:32 <Mortchek> Do Vecs include length in the type or something?
10:38:36 <elliott> orzo: that does not match my claim.
10:38:38 <mm_freak> Mortchek: yeah
10:38:41 <elliott> mm_freak: what do you find confusing about it?
10:38:44 <elliott> to be more explicit:
10:38:46 <int-e> @type liftM2 ?f
10:38:47 <lambdabot> (?f::a1 -> a2 -> r, Monad m) => m a1 -> m a2 -> m r
10:39:10 <elliott> given that a function f behaves as zipWith on lists of equal length (including infinite lists), f's behaviour on lists of unequal lengths must also match zipWith
10:39:19 <int-e> besides, djinn would likely find  f _ _ _ = [].
10:39:40 <int-e> (if it knew anything about lists.)
10:39:42 <elliott> liftM2 is a bad example since there is no monad for which liftM2 = zipWith :)
10:39:43 <dolio> There's nothing much better about zipWith on Vec or Stream than on list.
10:39:47 <Mortchek> It doesn't always go for stupid solutions like that
10:40:07 <Mortchek> Well, I guess on the other hand there's no fully polymorphic value that always works
10:40:08 <mm_freak> elliott: i'm always wary of functions which could basically do what they want
10:40:11 <Mortchek> (besides undefined)
10:40:19 <mm_freak> elliott: <*> on ZipList is much more sensible
10:40:30 <mm_freak> because it follows a number of laws
10:41:28 * elliott doesn't see what this has to do with my claim...
10:41:32 <elliott> (were you replying to dolio, maybe?)
10:41:37 <mm_freak> ZipList guarantees:  liftA2 const xs ys = xs, liftA2 (const id) xs ys = ys
10:42:06 <Mortchek> The disproof I gave of your claim as originally said was zipWith _ _ _ = []
10:42:22 <elliott> Mortchek: that function does not behave as zipWith on lists of equal length
10:42:22 <Taneb> elliott: I think for fixed-length lists, liftA2 = zipWith
10:42:31 <elliott> Taneb: only if you wrap with ZipList
10:42:38 <Mortchek> Right, you qualified later
10:42:56 <mm_freak> elliott: the point is that zipWith* are arbitraray while liftA* follow from algebraic construction and follow some sensibility soundness laws
10:43:09 <elliott> ok, but I still don't see what this has to do with my claim :P
10:43:11 <mm_freak> s/sensibility//
10:43:14 <elliott> liftA2 on ZipList is identical to zipWith anyway.
10:43:15 <Taneb> elliott: I mean, a list-y thing with a Nat in its type constraining it to a certain length
10:43:40 <mm_freak> elliott: i understood your claim like: "zipWith has a well-defined behavior"
10:43:46 <mm_freak> and that's simply wrong
10:43:51 <Mortchek> s/a/a unique/ ?
10:44:34 <elliott> I don't see how it's wrong at all, given a trivial argument reduces it to liftA2 on ZipWith, which you are promoting... anyway my claim wasn't like that, but rather "if you know how zipWith works on lists of equal length, its behaviour on unequal length lists is guaranteed"
10:44:35 <mm_freak> just like 'reverse' it's pretty much an arbitrary function
10:44:48 <Mortchek> @djinn [a] -> [a]
10:44:49 <lambdabot> Error: Undefined type []
10:44:53 <mm_freak> elliott: i didn't say "wrong"
10:44:55 <Mortchek> Er, woops :P
10:45:02 <elliott> mm_freak: okay: "simply wrong"
10:45:08 <Mortchek> Anyway, id, reverse :: [a] -> [a]
10:45:47 <Mortchek> return . head :: [a] -> [a]
10:46:01 <mm_freak> elliott: when i pretend that bottoms don't exist and look at const's type i know exactly what it does…  when i look at zipWith's type i don't see anything
10:46:08 * elliott sigh
10:46:11 <mm_freak> that's the difference between liftA2 and zipWith
10:46:21 <dolio> Then you're lying to yourself about liftA2.
10:46:43 <mm_freak> dolio: i am…  i'm assuming that ZipList follows the applicative laws
10:47:04 <mm_freak> this allows zipWith _ _ _ = [], but not liftA2 _ _ _ = []
10:48:13 <elliott> this statement out of that two entities which are identical to each other, one of them does not have well-defined behaviour, is absurd
10:48:59 <elliott> if the Applicative [] instance was defined in the standard libraries to be zippy (perfectly valid) and the defn was literally zipWith = liftA2...
10:49:09 <elliott> zipWith would be exactly the same as it is now
10:49:45 <mm_freak> elliott: let me remind you of your original claim
10:49:48 <mm_freak> <elliott> zipWith's behaviour is actually guaranteed
10:49:48 <quchen> mm_freak: liftA2 isn't unique either: consider flipping the evaluation order, liftA2 f m n = do { y <- n; x <- m; return (f x y) }
10:50:02 <elliott> mm_freak: i later clarified that claim
10:50:27 <elliott> anyway, I'm bored of hearing the same statement about liftA2 over and over, so whatever
10:50:57 <mm_freak> elliott: because no matter what i say you still insist on zipWith being sound ;)
10:51:14 <mm_freak> it is in its current form, but there is absolutely nothing that guarantees that…  not the type, nor algebraic properties
10:51:40 <mm_freak> quchen: liftA2 is unique for ZipList
10:52:04 <quchen> mm_freak: Woops, misread the A for M anyway
10:52:30 <elliott> mm_freak: you haven't provided any arguments against my clarified claim, which I believe to be sufficiently precise to be hard to misinterpret
10:52:42 <elliott> that is, "given that a function f behaves as zipWith on lists of equal length (including infinite lists), f's behaviour on lists of unequal lengths must also match zipWith"
10:52:54 <mm_freak> interestingly while ZipList does form a monad, it doesn't have a Monad instance (for good reason)
10:53:01 <elliott> ZipList does not form a monad
10:53:11 <dolio> No, ZipList is not a monad.
10:53:13 <elliott> it is the archetypical example of an applicative that doesn't
10:53:27 <mm_freak> elliott: i provided multiple counterexamples!
10:53:41 <elliott> mm_freak: I don't recall seeing any counterexample that satisfies the claim I quoted
10:53:56 <elliott> what function do you have that behaves as zipWith on lists of equal length (including infinite lists), but differs from zipWith when they are unequal?
10:54:22 <mm_freak> elliott: myZipList f xs ys = originalZipList f (cycle xs) (cycle ys)
10:54:44 <mm_freak> acts like zipList for equal length, acts otherwise if unequal
10:54:55 <elliott> > zipWith (,) [1] [1]
10:54:56 <lambdabot>   [(1,1)]
10:54:59 <elliott> > zipWith (,) (cycle [1]) (cycle [1])
10:55:01 <lambdabot>   [(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1...
10:55:04 <elliott> counterexample refuted
10:55:41 <mm_freak> elliott: no, it's not:  myZipWith (,) [1] [1] /= zipWith (,) [1] [1]
10:55:57 <elliott> ??
10:56:02 <elliott> so it does not behave as zipWith on lists of equal length.
10:56:03 <ab9rf> then it doesn't behave as zipWith on lists of equal length
10:56:07 <elliott> this isn't difficult.
10:56:34 <mm_freak> oh…  sorry
10:56:40 <quchen> I don't like the hostile atmosphere here right now. You're arguing about lists on the internet, guys.
10:56:55 <ab9rf> quchen: what would you prefer we argue about?
10:57:12 <Eduard_Munteanu> We certainly need an array vs list war.
10:57:22 <jagaj> argue about things that will change by talking about them on the internet, like politics and sports
10:57:54 <ab9rf> and unicorns
10:58:04 <Eduard_Munteanu> What if we like our topic referentially transparent?
10:58:12 <quchen> ab9rf: Maybe don't pick only half of my sentence to quote.
10:58:25 <ab9rf> quchen: now who's being hostile?
10:58:29 <jagaj> lol
10:58:36 <Eduard_Munteanu> ME GODDAMN IT!
10:58:45 <Eduard_Munteanu> :P
10:59:18 <mm_freak> elliott: myZipWith f xs ys = zipWith f (cycle xs) ys;  myZipWith f [1,2,3] [4,5,6] = zip;  myZipWith f [1..] [2..] = zipWith f [1..] [2..];  myZipWith f "ab" "cde" ≠ zipWith f "ab" "cde"
10:59:22 <mm_freak> there you go
10:59:30 <quchen> ab9rf: That wasn't hostile, that was stating that you misquoted me. Please don't do that. No offense or hostility taken.
10:59:34 <FireFly> What's the name of the ?foo syntax I've seen used occasionally?
10:59:42 <Eduard_Munteanu> FireFly: implicit parameters
10:59:48 <elliott> @let myZipWith f xs ys = zipWith f (cycle xs) ys
10:59:50 <FireFly> Ah, thanks
10:59:51 <lambdabot>  Defined.
10:59:55 <ab9rf> quchen: i wasn't aware that i had even quoted you
11:00:01 <quchen> Whatever.
11:00:07 <mm_freak> elliott: also i can write a Monad instance for ZipList
11:00:08 <elliott> > myZipWith (,) "ab" "cde"
11:00:12 <lambdabot>   mueval-core: Time limit exceeded
11:00:15 <elliott> > myZipWith (,) "ab" "cde"
11:00:18 <lambdabot>   [('a','c'),('b','d'),('a','e')]
11:00:23 <elliott> > zipWith (,) "ab" "cde"
11:00:25 <lambdabot>   [('a','c'),('b','d')]
11:00:43 <elliott> mm_freak: yes, myZipWith disproves me; I retract my claim.
11:00:50 <dolio> mm_freak: Not one that implements an actual monad.
11:00:52 <elliott> however, I still don't believe you can write a Monad instance for ZipList
11:00:55 <elliott> it will violate laws
11:01:28 <quchen> elliott: Is there a proof for that? The naive implementation fails, but can it be shown that no implementation exists?
11:01:29 <mm_freak> hmm…  i might be wrong about ZipList, but at least ZipStream is a proper monad
11:01:34 <mm_freak> i.e. ZipList sans []
11:01:47 <Eduard_Munteanu> ZipStream
11:01:57 <mm_freak> (or just Stream, if you will)
11:02:01 <elliott> mm_freak: ZipStream is just Reader Nat
11:02:04 <Eduard_Munteanu> Oh, you said that.
11:02:19 <elliott> in fact, ZipList where all the lists have to be a given length n is iso to Reader (Fin n), so a monad
11:02:23 <elliott> but that's not ZipList
11:02:52 <elliott> quchen: I don't know of anywhere with a formal proof, but it's easy to see if you consider how to match the Applicative instance join must "diagonalise", and that the lists can be of unequal length
11:04:24 <mm_freak> but i wonder which law would be broken by teminating early
11:04:44 <mm_freak> just like <*> does
11:06:06 <dmwit> Not really related, but you all might enjoy byorgey's Themes on Streams.
11:06:19 <dmwit> http://byorgey.wordpress.com/2011/05/09/themes-on-streams/ http://byorgey.wordpress.com/2011/05/20/themes-on-streams-part-ii/
11:06:20 <mm_freak> [] >>= _ = []; (x:xs) >>= f = case f x of [] -> []; y:_ -> y : (xs >>= drop 1 . f)
11:07:15 <dolio> Associativity is the rule that's broken.
11:07:43 <mm_freak> dolio: is there an example?
11:07:54 <dolio> I don't have one at the ready.
11:09:12 <dolio> It isn't terribly difficult to design a thrice nested list that causes the local 2D diagonalization to not actually compute the 3D diagonal, though.
11:09:15 <dolio> Which is the problem.
11:09:39 <mm_freak> @let [] >>~ _ = []; (x:xs) >>~ f = case f x of [] -> []; y:_ -> y : (xs >>~ drop 1 . f)
11:09:40 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
11:09:47 <dolio> One of the ways of slicing it up will compute the diagonal, and the other won't.
11:09:49 <mm_freak> @let [] >>~ _ = []; (x:xs) >>~ f = case f x of [] -> []; y:_ -> y : (xs >>~ (drop 1 . f))
11:09:52 <lambdabot>  Defined.
11:11:03 <mm_freak> > [1,2,3] >>~ (\x -> [4,5] >>~ \y -> x : y : [6,7])
11:11:05 <lambdabot>   [1,5]
11:11:56 <mm_freak> > [1,2,3] >>~ (\x -> [4,5] >>~ \y -> y : [6,7])
11:11:58 <lambdabot>   [4,6]
11:12:11 <mm_freak> > ([1,2,3] >>~ \x -> [4,5]) >>~ \y -> y : [6,7]
11:12:13 <lambdabot>   [4,6]
11:12:22 <mm_freak> hmm
11:12:42 <mm_freak> unable to find a counterexample on a quick try, but yeah, that construction kinda feels wrong
11:13:06 <mm_freak> i'd have to actually go ahead and prove the laws
11:14:02 <dolio> You're not making anything with a ragged shape there.
11:14:19 <dolio> You need something concave. Not a rectangular prism.
11:14:36 <dmwit> > [1,2,3] >>~ (\x -> [2*x, 3*x] >>~ \y -> [x..y])
11:14:38 <lambdabot>   [1,3]
11:14:40 <dmwit> > ([1,2,3] >>~ \x -> [2*x, 3*x]) >>~ \y -> [x..y]
11:14:42 <lambdabot>   *Exception: not a number
11:14:51 <dmwit> uh
11:14:54 <mm_freak> huh?
11:15:08 <dmwit> I guess that counts as a counterexample?
11:15:18 <mm_freak> > ([1,2,3] >>~ \x -> [2*x, 3*x]) >>~ \y -> [x..y] :: [Int]
11:15:22 <lambdabot>   mueval-core: Time limit exceeded
11:16:00 <mm_freak> > ([1,2,3] >>~ \x -> [2*x, 3*x]) >>~ \y -> [x..y] :: [Int]
11:16:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:16:03 <lambdabot>              with actual type ...
11:16:08 <mm_freak> lol?
11:16:15 <dmwit> :t (>>~)
11:16:16 <lambdabot> [t] -> (t -> [a]) -> [a]
11:16:26 <mm_freak> og
11:16:33 <mm_freak> > (([1,2,3] >>~ \x -> [2*x, 3*x]) >>~ \y -> [x..y]) :: [Int]
11:16:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:16:35 <lambdabot>              with actual type ...
11:16:49 <dmwit> :t [1,2,3] >>~ \x -> [2*x, 3*x]
11:16:51 <lambdabot> Num a => [a]
11:17:01 <dmwit> oh, lol
11:17:01 <elliott> <dmwit> > ([1,2,3] >>~ \x -> [2*x, 3*x]) >>~ \y -> [x..y]
11:17:06 <dmwit> where is the x bound
11:17:06 <elliott> x is out of scope in the \y -> ...
11:17:10 <dmwit> yes =)
11:17:10 <elliott> yeah
11:17:14 <mm_freak> lol
11:18:03 <dmwit> Yes, this is not a counterexample.
11:18:03 <mm_freak> @let (>~>) f g x = f x >>~ g
11:18:06 <lambdabot>  Defined.
11:18:25 <fizbin> :t (>>~)
11:18:27 <lambdabot> [t] -> (t -> [a]) -> [a]
11:18:35 <dmwit> > [x..y]
11:18:36 <lambdabot>   *Exception: not a number
11:18:49 <fizbin> @hoogle (>>~)
11:18:49 <lambdabot> No results found
11:18:57 <dmwit> It is defined in a ?let above.
11:19:06 <fizbin> Ah.
11:19:28 <quchen> fizbin: @let [] >>~ _ = []; (x:xs) >>~ f = case f x of [] -> []; y:_ -> y : (xs >>~ (drop 1 . f))
11:19:48 <quchen> It's trying to make a Monad ZipList instance
11:20:00 <mm_freak> > ((\x -> [1,2]) >~> (\x -> [1..x])) >~> (\x -> [x..100]) $ 15
11:20:03 <lambdabot>   mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
11:20:08 <mm_freak> > ((\x -> [1,2]) >~> (\x -> [1..x])) >~> (\x -> [x..100]) $ 15
11:20:09 <fizbin> Gotcha. That's… odd.
11:20:09 <elliott> lol
11:20:11 <elliott> good error
11:20:12 <lambdabot>   mueval-core: Time limit exceeded
11:20:17 <mm_freak> come on, lambdabot
11:20:20 <elliott> haven't seen that L one before
11:20:21 <Mortchek> Is (>>~) concatMap?
11:20:22 <dmwit> okay, how about this
11:20:26 <dmwit> Mortchek: No.
11:20:40 * Mortchek was just guessing from the type
11:20:53 <elliott> Mortchek: (>>=) for [] is concatMap
11:20:56 <dmwit> > [1..5] >>~ ensure odd
11:20:58 <lambdabot>   Not in scope: `ensure'
11:21:05 <Mortchek> elliott, yep, I know
11:21:06 <dmwit> ?let ensure p x = guard (p x) >> return x
11:21:07 <mm_freak> > let a _ = [1, 2]; b x = [1..x]; c x = [x..100] in ((a >~> b) >~> c) 3
11:21:08 <lambdabot>  Defined.
11:21:10 <lambdabot>   [1,3]
11:21:14 <dmwit> > [1..5] >>~ ensure odd
11:21:16 <lambdabot>   [1]
11:21:21 <mm_freak> > let a _ = [1, 2]; b x = [1..x]; c x = [x..100] in (a >~> (b >~> c)) 3
11:21:22 <dmwit> > [1..5] >>~ ensure even
11:21:23 <lambdabot>   [1,3]
11:21:24 <lambdabot>   []
11:22:25 <mm_freak> of course it time-limit-dies…  Monad for ZipList being O(n²) is the reason you don't want to have it =)
11:22:34 <elliott> dmwit: ensure p x = x <$ guard (p x)
11:22:39 <fizbin> And I assume "return" for this monad is "repeat"?
11:22:46 <mm_freak> fizbin: yeah
11:23:08 <mm_freak> > [1..] >>~ return
11:23:12 <lambdabot>   [1]
11:23:14 <mm_freak> > [1..] >>~ repeat
11:23:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:23:23 <mm_freak> > [1..10] >>~ repeat
11:23:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:23:28 <dmwit> > repeat 3 >>~ \x -> [5,x]
11:23:30 <lambdabot>   [5,3]
11:24:20 <dolio> > let mat = [[[0],[1,2]],[[],[3,4]]] ; yoin = (>>~id) in (yoin (yoin mat), yoin (fmap yoin mat))
11:24:21 <fizbin> > repeat 1 >>~ \ _ -> repeat 6
11:24:24 <lambdabot>   ([0,4],[0])
11:24:25 <lambdabot>   [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
11:24:41 * elliott rings the monad law violation alarm
11:24:48 <dolio> Voila.
11:24:58 <elliott> the police will be here within minutes.
11:25:30 <dmwit> elliott: Is there a reason to prefer x <$ guard (p x) over guard (p x) >> return x?
11:25:51 <mm_freak> great =)
11:25:58 <elliott> dmwit: well, the former will have a looser constraint in the beautiful future when we fix the Monad hierarchy.
11:26:01 <elliott> also, it is shorter!
11:26:14 <elliott> I guess the former is worse today because you get (Functor m, MonadPlus m) or such
11:26:33 <quchen> elliott: There aren't any plans on fixing that are there
11:26:59 <quchen> elliott: Last thing I heard about that was edwardk saying it's just good for making the mailing list explode every now and then
11:27:21 <dolio> mm_freak: Anyhow, the diagonal of the second inner slice is [], but the diagonal of the outer structure is [[0],[3,4]], and only the latter is compatible with the overall diagonal.
11:27:32 <mm_freak> dmwit: the former may be more efficient
11:27:38 <mm_freak> fmap can be faster than liftM
11:28:24 <dolio> So it's not an issue with implementing the diagonal, it's a problem with finding a 3D diagonal by only looking at 2 dimensions at a time.
11:28:36 <mm_freak> dolio: i see
11:29:06 <elliott> trust geometry to mess things up.
11:29:43 <dmwit> mm_freak: I find it hard to believe that whatever optimization you applied to fmap can't be applied to (>>).
11:30:01 <dmwit> Although not inconceivable, I suppose.
11:30:19 <mm_freak> dmwit: can be, but then you have to make sure that GHC actually matches the RULEs
11:30:25 <mm_freak> for fmap nothing like that is necessary
11:31:05 <mm_freak> (x <$) = fmap (const x)
11:31:20 <mm_freak> liftM (const x) = (>>= return . const x)
11:33:08 <dmwit> mm_freak: I didn't write liftM anywhere.
11:34:58 <mm_freak> dmwit: i just renamed your (>> return x)…  it's just easier to begin with a fully optimized version instead of counting on the compiler to optimize it
11:35:25 <mm_freak> but other than speed i see no reason to prefer (<$)
11:37:08 <dmwit> I'm saying that (>>) can be specialized without pragmas in all the same ways fmap can be with pragmas.
11:37:30 <dmwit> s/saying/claiming/
11:37:57 <dmwit> So changing (>> return x) to liftM (const x) is not just a renaming.
11:40:35 <mm_freak> dmwit: let me put it this way:  if you benchmark with GHC 7.6 you will find that (<$) performs slightly better on average
11:40:49 <mm_freak> at least with -O and -threaded, i.e. my setup
11:41:54 <dmwit> With which monad should I test this claim?
11:42:23 <mm_freak> dmwit: State, Writer, [], …
11:44:52 <ryanakca> Is it possible to have multiple elements in a set comprehension, i.e. [ a, b | P(a,b) ]?
11:45:22 <mm_freak> i didn't even know we had set comprehensions =)
11:45:46 <ryanakca> sorry list comprehension :) http://www.haskell.org/haskellwiki/List_comprehension
11:46:10 <applicative> > [(x,y) | x <- "x", y <- "y"]
11:46:12 <lambdabot>   [('x','y')]
11:46:27 <applicative> > [[x,y] | x <- "x", y <- "y"]
11:46:29 <lambdabot>   ["xy"]
11:46:36 <mm_freak> ryanakca: `concat [ [a, b] | … ]` or `[ r | …, x <- [a, b] ]`
11:47:20 <mm_freak> > concat [ [-x, x] | x <- [1..] ]
11:47:22 <lambdabot>   [-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13,-...
11:47:32 <ryanakca> Alright, thanks :)
11:47:37 <dmwit> < U.universe :: [Integer]
11:48:08 <applicative> U ?!
11:48:24 * elliott is interested int he benchmark results
11:48:41 <dmwit> < U.universe :: [Integer]
11:48:42 <goodfellow>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
11:48:57 <dmwit> applicative: U = Data.Universe, of course ;-)
11:49:12 <dmwit> elliott: criterion is still installing
11:49:22 <dmwit> I feel like I have installed this before, but ghc-pkg disagrees.
11:49:35 <applicative> well, yes, somehow I knew that, but nothing definite was suggested be  Data.Univers
11:49:37 <applicative> e
11:49:51 <mm_freak> is that some acme-* thing?
11:49:51 * applicative begins to compose System.Universe
11:50:02 <dmwit> ?hackage universe mm_freak
11:50:02 <lambdabot> http://hackage.haskell.org/package/universe mm_freak
11:50:03 <applicative> Control.Universe
11:50:27 <dmwit> I am pained that you think it's just a joke. =P
11:51:29 <mm_freak> that thing is serious…
11:52:42 <elliott> too bad it doesn't support uncountable types.
11:52:43 <dmwit> ?index (<$)
11:52:43 <lambdabot> bzzt
11:53:00 <dmwit> elliott: patches welcome =)
11:53:06 <dmwit> ?hoogle (<$)
11:53:06 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
11:53:06 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
11:53:06 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
11:53:31 <tromp> odd that there's no Universe instance implied by Enum,Bounded ?!
11:53:48 <FireFly> @help index
11:53:49 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
11:53:53 <dmwit> tromp: Data.Universe.Helpers defines universeDef :: (Enum a, Bounded a) => [a]
11:54:12 <dmwit> tromp: But if you wrote instance (Enum a, Bounded a) => Universe [a] it would overlap with everything and sometimes be wrong. =)
11:54:21 <elliott> *Universe a, presumably
11:54:28 <tromp> ic. thx, dmwit
11:54:34 <elliott> dmwit: not sure a patch would be easy :P
11:54:35 <dmwit> tromp: (Additionally, if your GHC is new enough to support defSigs, you can write instance Universe a without any body to get universe = universeDef for free.)
11:54:38 <dmwit> elliott: yes
11:56:35 <tromp> in what cases would universe = [minBound..maxBound] be wrong?
11:56:55 <dmwit> elliott: Well, it seems mm_freak is right. dmwit mean 43.8ms, mm_freak mean 35.4ms, filter mean 33.3ms
11:57:01 <dmwit> tromp: Double
11:57:16 <tromp> Double has an Enum instance??
11:57:29 <dmwit> > [0..5] :: [Double]
11:57:33 <lambdabot>   mueval-core: Time limit exceeded
11:57:37 <dmwit> > [0..5] :: [Double]
11:57:40 <lambdabot>   mueval-core: Time limit exceeded
11:57:43 <tromp> > succ 0.5
11:57:47 <lambdabot>   1.5
11:57:51 <elliott> dmwit: hm, and that's with -O2 and all?
11:57:55 <dmwit> > [0.5 .. 2] :: [Double]
11:57:56 <dmwit> elliott: yep
11:57:58 <lambdabot>   [0.5,1.5,2.5]
11:58:03 <elliott> very strange.
11:58:07 <dmwit> tromp: ain't it great? Just stare at that and cry.
11:58:12 <elliott> maybe one of them hsa an INLINE pragma and another doesn't.
11:58:17 * tromp weeps
11:58:24 <Eduard_Munteanu> Technically, Double ~ Int, no? :)
11:58:52 <dmwit> Eduard_Munteanu: Maybe. I haven't written an instance for Double yet because I'm not sure what to think of NaNs.
11:58:56 <Eduard_Munteanu> You can make an Enum instance that goes through all doubles.
11:59:11 <dmwit> No, that's not what Enum is for.
11:59:20 <dmwit> Or rather, you could, but DAMN enumFromThen would be hard.
11:59:22 <applicative> succ  0.5 , awesome
11:59:38 <tromp> I think an Enum instance for Double is morally wrong
11:59:52 <dmwit> tromp: That stance is why Universe exists.
12:00:10 <dmwit> Well, Enum is morally wrong. So.
12:00:33 <earthy> ?
12:00:40 <tromp> Enum is fine and ueful
12:00:42 * dmwit wonders...
12:00:47 <dmwit> > [2.5 .. 2] :: [Double]
12:00:48 <elliott> even Enum Integer is wrong
12:00:49 <tromp> useful
12:00:50 <lambdabot>   [2.5]
12:00:53 <elliott> (fromEnum)
12:00:53 <dmwit> lovely
12:01:23 <tromp> how is Enum Integer wrong?
12:01:33 <dmwit> earthy: It's just a sort of hodge-podge of methods with no real motivation saying why they're the right set to pick.
12:01:43 <dmwit> > fromEnum (2^128)
12:01:45 <lambdabot>   0
12:02:13 <dmwit> < U.universe :: [Rational]
12:02:14 <goodfellow>   [0 % 1,(-1) % 1,1 % 1,(-1) % 2,1 % 2,(-2) % 1,2 % 1,(-1) % 3,1 % 3,(-3) % 2...
12:02:38 <dmwit> < findIndex (67/78 :: Rational) U.universe
12:02:39 <goodfellow>   Couldn't match expected type `a0 -> GHC.Types.Bool'
12:02:39 <goodfellow>              with actua...
12:02:48 <applicative> > pred (succ (0.5))
12:02:50 <lambdabot>   0.5
12:03:04 <dmwit> < findIndex (== (67/78 :: Rational)) U.universe
12:03:04 <Mortchek> > succ succ
12:03:05 <applicative> well, i guess that'd be one of the 'laws'
12:03:05 <goodfellow>   Just 262396
12:03:06 <lambdabot>   No instance for (GHC.Enum.Enum (a0 -> a0))
12:03:06 <lambdabot>    arising from a use of `e_1'
12:03:06 <lambdabot>  ...
12:03:19 <Mortchek> > succ + 1
12:03:21 <lambdabot>   *Exception: show: No overloading for function
12:03:28 <dmwit> < succ + 1
12:03:30 <goodfellow>   Ambiguous type variable `a0' in the constraints:
12:03:30 <goodfellow>    (GHC.Enum.Enum a0)
12:03:30 <goodfellow>     ...
12:03:40 <dmwit> < succ + 1 :: Word8 -> Word8
12:03:42 <goodfellow>   [(0,2),(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10),(9,11),(10,12),(11,...
12:03:46 <typoclass> so the problem with fromEnum is the Int? (Enum a) => a -> Int
12:04:03 <tromp> maybe Enum should be split, so that pred/succ is separate
12:04:15 <dmwit> pred and succ have the wrong types, too.
12:04:28 <dmwit> > pred minBound
12:04:29 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
12:04:31 <applicative> > fromEnum (17 - 400 ::Int)
12:04:33 <lambdabot>   -383
12:04:49 <applicative> > pred minBound :: Int
12:04:51 <lambdabot>   *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
12:05:03 <applicative> ha
12:05:18 <applicative> > pred minBound :: Char
12:05:20 <lambdabot>   *Exception: Prelude.Enum.Char.pred: bad argument
12:05:26 <typoclass> dmwit: you mean it should produce a Maybe?
12:05:27 <applicative> I'll say
12:05:32 <mm_freak> elliott: it's not that strange when you consider that (x <$) starts from a fully optimized version while (>> return x) has to be optimized to it first
12:05:37 <dmwit> typoclass: for example
12:06:05 <mm_freak> elliott: you are using two primitives of the monad that you have to RULE away
12:06:08 <tromp> i'd add maybePred and maybeSucc for those cases
12:06:32 <elliott> I don't see why it would have to RULE away any more than (<$)
12:06:49 <orzo> hello, anyone want to help me understand MonadReader/ReaderT ?  I want to understand the source code, but I'm not used to record syntax...  I have a custom monad that implements MonadReader, but my ask function always returns the same thing which does not seem correct
12:07:32 <typoclass> dmwit: hm ok ...
12:07:45 <scalable> orzo: and what do you expect?
12:07:48 <Mortchek> dmwit, goodfellow can enumerate certain sorts of functions?
12:07:53 <Mortchek> s/enumerate/show/
12:07:57 <dmwit> Mortchek: yes, those with a finite domain
12:08:01 <Mortchek> Ah, right
12:08:07 <dmwit> < \() -> "hiya, Mortchek!"
12:08:08 <goodfellow>   [((),"hiya, Mortchek!")]
12:08:19 <typoclass> is (/) wrong? for certain inputs it produces a div by zero exception
12:08:24 <dmwit> Well, finite domain and showable domain/codomain, of course. =)
12:08:31 <dmwit> typoclass: yes =)
12:08:42 <Mortchek> < fmap not
12:08:43 <goodfellow>   No instances for (GHC.Show.Show (f0 GHC.Types.Bool),
12:08:43 <goodfellow>                    Dat...
12:08:45 <elliott> < succ :: Int -> Int
12:08:45 <typoclass> dmwit: erm ... ok :-)
12:08:46 <goodfellow>   [(-9223372036854775808,-9223372036854775807),(-9223372036854775807,-9223372...
12:08:49 <elliott> < succ :: Integer -> Integer
12:08:50 <goodfellow>   No instance for (Data.Universe.Finite GHC.Integer.Type.Integer)
12:08:50 <goodfellow>    arising ...
12:08:55 <Mortchek> < fmap not :: Maybe Bool -> Maybe Bool
12:08:56 <goodfellow>   [(Nothing,Nothing),(Just False,Just True),(Just True,Just False)]
12:08:58 <elliott> it should be able to produce an infinite String
12:09:01 <elliott> for Integer -> Integer
12:09:24 <typoclass> elliott: starting where? =)
12:09:24 <dmwit> elliott: I like to keep the contract that (read . show) = id
12:09:29 <elliott> typoclass: does it matter?
12:09:29 <Mortchek> elliott, by proceeding 0, 1, -1, 2, -2, etc.?
12:09:35 <dmwit> typoclass: Starting here:
12:09:39 <dmwit> < U.universe :: [Integer]
12:09:40 <goodfellow>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
12:09:44 <applicative> this post of byorgey s about 'Boltzmann trees' wont compile  "    No instance for (MonadRandom (MaybeT (Rand StdGen)))" maybe I have something out of date?
12:09:45 <elliott> dmwit: it could achieve that
12:09:54 <elliott> dmwit: read would just have to be slightly more clever.
12:10:06 * dmwit nods
12:10:11 <byorgey> applicative: ah, whoops!  I forgot I used a locally modified version of MonadRandom
12:10:19 <byorgey> applicative: I plan to upload a new version of MonadRandom soon though
12:10:32 <typoclass> dmwit: ok that's decent. why not. it's just that when elliot asked for succ :: Int -> Int it seemed to start at "minus large number"
12:10:33 <elliott> dmwit: and I don't think it would ever make anything less terminating
12:10:37 <applicative> ah. d
12:10:45 <byorgey> applicative: in the meantime if you want you can just add an orphan instance for  MonadRandom m => MonadRandom (MaybeT m)
12:11:06 <dmwit> elliott: That doesn't sound right to me.
12:11:25 <dmwit> elliott: I can write a function that terminates when given an infinite tree as input, and infinite trees are recursively enumerable.
12:11:46 <dmwit> elliott: But the version of the function you would get from (read . show) would never terminate on an infinite input.
12:12:11 <elliott> dmwit: OK, that's true: you need something in between Universe and Finite.
12:12:28 <orzo> scalable: My monad is an algebriac type consisting of one constructor and two arguments, the first argument is a parameter that is settable via local, but ask always returns a default value for it.  It could not do otherwise as it takes no arguments.  That makes the ask function seem pretty useless and named badly
12:12:45 <tac> < U.universe :: [Bool]
12:12:47 <goodfellow>   [False,True]
12:13:33 <orzo> scalable: its a custom monad that implements MonadReader directly
12:13:46 <orzo> scalable: clearly, i'm doing it wrong... right?
12:13:54 <dmwit> typoclass: Well, that's just because universe for Int starts at "minus large number". But it could adopt a similar order with no problem.
12:13:55 <tac> < U.universe :: [(Integer, Integer)]
12:13:56 <goodfellow>   [(0,0),(1,0),(0,1),(-1,0),(0,-1),(1,1),(0,2),(2,0),(0,-2),(1,-1),(0,3),(-1,...
12:14:00 <dmwit> < U.universe :: [Int]
12:14:01 <goodfellow>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
12:14:31 <tac> dmwit: I like that it gives you a well-founded ordering of (Integer, Integer)
12:14:42 <dmwit> tac: Yes, that's the whole point. =)
12:14:55 <ParahSailin> < U.universe :: [Double]
12:14:57 <goodfellow>   No instance for (Data.Universe.Universe GHC.Types.Double)
12:14:57 <goodfellow>    arising from a...
12:15:00 <dmwit> Actually, the most recent version of universe gives an even better order.
12:15:03 <dmwit> I should upgrade goodfellow.
12:15:25 <Mortchek> Is there a reasonable [(a, b)] -> a -> b where a is known to be finite?
12:15:38 <Mortchek> (total)
12:15:43 <dmwit> Oh, wait, I'm just reading it wrong. Never mind about the "better order" thing.
12:15:44 <elliott> Mortchek: with Eq a.
12:15:46 <elliott> you don't even need a to be finite
12:16:05 <tac> < let pairs = U.universe :: [(Integer, Integer)]; search p (x:xs) | p x = x | otherwise = search p xs in search (\(x, y) -> x * x + y * y == -100) pairs
12:16:06 <dmwit> Mortchek: [(a,b)] -> a -> b -> b is OK.
12:16:07 <elliott> dmwit: actually, if the function is partial then "read" might "miss" later elements.
12:16:08 <goodfellow>   mueval-core: Time limit exceeded
12:16:11 <tac> < let pairs = U.universe :: [(Integer, Integer)]; search p (x:xs) | p x = x | otherwise = search p xs in search (\(x, y) -> x * x + y * y == -100) pairs
12:16:15 <goodfellow>   mueval-core: Time limit exceeded
12:16:17 <tac> :(
12:16:30 <dmwit> elliott: Ah, yeah, I probably do not handle partial functions correctly.
12:16:32 <dmwit> Dang!
12:16:36 <Mortchek> dmwit, ah, true enough. That's basically just combining maybe and lookup I guess
12:16:45 <dmwit> right
12:16:50 <elliott> dmwit: oh I guess you already don't
12:16:53 <elliott> so my proposal doesn't hurt things!
12:17:41 <dmwit> tac: x^2+y^2 is always positive, no?
12:17:57 <tac> lol... no.... why would you think that T__T
12:18:00 <tac> < let pairs = U.universe :: [(Integer, Integer)]; search p (x:xs) | p x = x | otherwise = search p xs in search (\(x, y) -> x * x + y * y == 100) pairs
12:18:01 <goodfellow>   (0,10)
12:18:14 <tac> < let pairs = U.universe :: [(Integer, Integer)]; search p (x:xs) | p x = x | otherwise = search p xs in search (\(x, y) -> x * x + y * y == 21) pairs
12:18:18 <goodfellow>   mueval-core: Time limit exceeded
12:18:19 <tac> err
12:18:23 <tac> sigh. I'll stop now
12:18:29 <scalable> orzo: show some code
12:19:12 * applicative senses something suspicious about instance MonadRandom m => MonadRandom (MaybeT m) where   getRandom   = lift getRandom ; good thing he doesn't pretend to know anything about random numbers
12:24:48 <scooty-puff> i was working on a restricted form of `mapM` for heterogeneous collections
12:24:48 <orzo> scalable: http://hpaste.org/86645
12:24:58 <scooty-puff> i have something close to what i want, but..
12:25:04 <hpaste> scooty-puff pasted “Can 'f' be removed from the type class?” at http://hpaste.org/86646
12:25:22 <johnw> applicative: it just means that MaybeT is transparent to the MonadRandom interface
12:25:49 <scooty-puff> it bothers me that it a data type could declare a less general instance of Heterogeneous..
12:25:51 <johnw> if you look in the mtl, there are likely similar instances for a bunch of the Monad* interface classes
12:25:52 <mm_freak> elliott: because (>> return x) can be a surprisingly complicated expression
12:26:07 <orzo> scalable: the parameter is used internally by the (>>=) operation for Monad (BSP s) .. so all i really needed was a setter, which local provides, but this is a silly way to use MonadReader i think
12:26:15 <mm_freak> elliott: you can't simplify this any further based only on the Monad instance, so there can't be a generic RULE for every monad
12:26:45 <mm_freak> so you need to break into the structure of the individual monads, and now consider StateT s []
12:26:57 <elliott> but fmap (const x) relies on the structure of the Functor instance too
12:27:13 <applicative> johnw: which means my slack-minded instance is okay?
12:27:33 <johnw> applicative: sure; the fact that you need it at all is a flaw in transformers, according to the author of layers
12:29:02 <orzo> from looking at ReaderT source, it's beginning to dawn on me that perhaps I should be implementing Monad for type BSPThing s v = HalfSpaceParameter s -> BSPTree s v
12:29:17 <mm_freak> elliott: yeah, just expand (x <$) for a complicated monad…  most of the time you will get a very simple expression:  fmap f (StateT g) = StateT (fmap (first f) . g)
12:29:25 <mm_freak> elliott: where the inner fmap is just map
12:29:26 <mm_freak> very simple expression
12:30:04 <orzo> or maybe i shouldnt be using MonadReader anyway
12:30:35 <applicative> wow (<$) debates are still on
12:30:44 <johnw> applicative: where?
12:31:02 <applicative> here.
12:31:04 <johnw> :t (<$)
12:31:04 <mm_freak> applicative: not a debate…  i'm just explaining why the benchmark confirmed my claim
12:31:06 <lambdabot> Functor f => a -> f b -> f a
12:32:27 <mm_freak> it's related to the fact that liftM is necessarily more complicated than fmap internally, because you have no control over liftM…  your only option is to RULE liftM applications to the equivalent of fmap applications for individual monads, which is difficult
12:33:21 <mm_freak> in principle (x <$) /can/ be as fast as (>> return x), but you have to rely on the compiler to be very smart, and it's usually not that smart
12:33:52 <applicative> yes that's plain
12:34:11 <applicative> I meant, that you have no control over liftM is plain
12:38:46 <dmwit> :t (>>)
12:38:48 <lambdabot> Monad m => m a -> m b -> m b
12:39:21 * zammy is away: I'm busy
12:39:44 <dmwit> I see. The problem in my thought process was that I was thinking (>> return x) knew more than (liftM (const x)), but that's not true: we would have to tell (>>) to do something special when its second argument was a return.
12:39:55 <dmwit> So you still need a pragma.
12:42:03 <dmwit> That is, the rule you would write for (liftM (const x)) and the rule you would write for (>> return x) are basically the same, and so I now no longer object to the "renaming">
12:42:19 <dmwit> Since I never objected to the remainder of the argument (after the renaming), I therefore buy the argument as a whole now. =P
12:59:14 <klrr> can i make a datatype an instance of both Show and Error in same expression?
12:59:54 * hackagebot MonadRandom 0.1.9 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.9 (BrentYorgey)
13:00:00 <tromp> if you can make deriving (Show,Error) work....
13:00:25 <byorgey> klrr: what do you mean, "in the same expression"?
13:04:23 <klrr> byorgey: like , "instance (Show, Error) RunTimeError where show = showError
13:05:15 <byorgey> klrr: ah.  No, you can't do that.
13:05:26 <klrr> byorgey: so i have to type it two times?
13:05:37 <Clint> type what two times?
13:05:38 <elliott> type what two times?
13:05:43 <elliott> Clint: you suck. :(
13:05:47 <klrr> the instance
13:05:47 <byorgey> hey, I was going to say that.
13:05:52 <Clint> :(
13:06:07 <elliott> klrr: I seriously doubt your Show and Error instances are the same
13:06:30 <klrr> instance Show RunTimeError where show = showError
13:06:37 <klrr> instance Error RunTimeError
13:06:40 <klrr> like that?
13:07:02 <klrr> (im new to haskell and programming)
13:08:21 <elliott> klrr: you need to define noMsg and strMsg in an Error instance
13:08:28 <elliott> also, what is showError?
13:08:31 <elliott> or is this a different Error class?
13:18:26 <erisco> is it always better to use Maybe or, when defining your own data type, is it okay to have a null constructor? The former leverages reuse but the latter seems like less busywork in code, since types don't have to be unwrapped
13:18:46 <elliott> latter may be more busywork if you can't reuse generic machinery on Maybes
13:18:49 <elliott> it depends on the situation
13:24:15 <jfischoff> Null constructors are used all of the time
13:24:42 <jfischoff> if you later want a more generic version make a isomorphism
13:24:45 <orzo> I have a type (param -> f (tree a)) where tree implements Traversable and f implements Applicative.  I'd like to implement sequenceA for this type, is it doable?
13:25:28 <orzo> hm, actually, i'd like to convert (param -> tree (f a)) to (f (param -> tree a))
13:26:11 <cschneid> jfischoff: by null constructor, do you mean the functional language equivalent of a null object pattern in an OO language?  Where it does NOOPs or returns useful defaults in functions that use that data type?
13:27:01 <jfischoff> I'm pretty erisco meant a constructor with fields
13:27:17 <jfischoff> s/fields/no fields
13:27:30 <mietek> @hoogle [Maybe a] -> Maybe a
13:27:30 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
13:27:30 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
13:27:30 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
13:28:07 <mietek> er
13:28:09 <mietek> @hoogle [Maybe a] -> Maybe [a]
13:28:09 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:28:09 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:28:09 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
13:28:15 <dmwit> orzo: That doesn't really look like a type you can implement reasonably.
13:28:33 <byorgey> orzo: (->) e  is not Traversable in general.
13:28:47 <byorgey> though I suppose it could be if e is a finite type with some canonical order.
13:28:56 <dmwit> Oh, hey!
13:28:59 <dmwit> Maybe I should add that...
13:29:00 <byorgey> =)
13:29:01 <jfischoff> it is distributive
13:29:14 <byorgey> instance Universe e => Traversable ((->) e) where ...
13:29:20 <dmwit> yeah =)
13:29:21 <mietek> sequence it is
13:29:25 <jfischoff> I'm not sure if that is helpful
13:29:26 <orzo> Hmm. well I had a traversable monad tree and i wanted to add MonadReader ability, which is how I ended up with the problem.
13:29:29 <dmwit> Maybe Finite e?
13:29:44 <byorgey> oh, I don't know the difference between Finite and Universe
13:30:01 <dmwit> Universe just guarantees recursive enumerability.
13:30:05 <byorgey> oh, I see
13:30:52 <dmwit> Okay, I filed an issue.
13:31:03 <orzo> is MonadReader incompatible with Traversable?
13:36:09 <dmwit> orzo: Maybe not, if your domain is finite.
13:36:30 <orzo> hm, well my domain was Double
13:36:45 <orzo> i mean, my param was Double
13:36:57 <dmwit> That's sort of finite, right? But not in a meaningful way, considering the operation you asked for.
13:37:09 <dmwit> Have fun enumerating all 2^64 inputs during your traversal. =P
13:37:13 <orzo> heh
13:37:17 <dolio> It's not even incompatible if the domain is infinite.
13:37:25 <ekiwok> hi guys, what is good way to learn haskell?
13:37:30 <dmwit> ?where tutorials
13:37:30 <lambdabot> http://haskell.org/haskellwiki/Tutorials
13:37:47 <ekiwok> I know about tutorials but based on own experience
13:37:51 <ekiwok> what projects can help
13:38:21 <dmwit> Pick a project that you think would be fun.
13:38:57 <orzo> well, the param is basically constant and i already had an implementation that simply pairs the param with the tree, but I used the local method of MonadReader to set the param, so I was exploring making an ask method that actually works, rather than the one i had which simply returns a default value for param no matter what.
13:39:05 <dmwit> Language implementations, ray tracers, and IRC bots seem like a popular start.
13:39:25 <dolio> newtype MyAwesomeMonad a = MAM a ; ... ; intstance MonadReader Integer MAM where ask = MAM (2^343 + 2^110)
13:39:45 <dolio> Traversable left as an exercise.
13:39:52 <orzo> but if it means giving up traversable, its probably not worth it and I should just use MonadReader as a simple setter and ignore "ask" or implement a setter directly
13:39:57 <SamB_XP> so an IRC raytracing bot with it's own SDL?
13:40:16 <dmwit> If that doesn't teach you Haskell, nothing will!
13:41:06 <ekiwok> dwmit I know basics but I'm wondering about project that woud show how much functional programing is better then object oriented
13:41:57 <jfischoff> ekiwok: look at plush
13:42:15 <jfischoff> https://github.com/mzero/plush
13:43:32 <erisco> hm, for my case I answered my own question
13:43:50 <ekiwok> jfischoff: thanks
13:47:47 <s778> "putting a value in a monad", is there a name for this kind of action?
13:47:57 <simpson> s778: Sure; `return`.
13:47:59 <orzo> dolio: your ask for MAM returns a constant though which means it will always return the same thing regardless of what you do with local.  That's contrary to what a user of MonadReader would expect, isn't it?
13:49:07 <s778> Oh, right. Thanks
13:50:02 <dolio> orzo: Yeah. I temporarily forgot about local, probably in part because one could argue it should go in its own class.
13:51:37 <orzo> dolio: your MAM exapmle is basically what i did with my parameterized traversable tree where i used local to set the parameter, but ask always returns a default value which seems silly and contrary to the spirit of MonadReader
13:51:37 <flebron> Hi, why am I getting a parse error on GHC 6.10, and not on 7.0? And what's that about a "too strict if"? http://hpaste.org/86650
13:52:12 <orzo> dolio: it was in trying to implemnt a more sensible seeming ask method that i ran into the (->) is not Traversable problem.
13:52:47 <dmwit> flebron: Because in H98, "then" and "else" must not have a semicolon between them and their corresponding "if".
13:53:04 <typoclass> flebron: try indenting lines 12 and 13
13:53:08 <dmwit> flebron: Whereas in the block you wrote, they are indented the same as the if, and hence get a semicolon.
13:53:15 <flebron> Oh, so I should format it as "  then"?
13:53:37 <dolio> orzo: Yeah. If you want to implement it for (->), it's no fun.
13:53:44 <flebron> (And "  else"? What about my not indenting the do block of the "when", is that kosher?)
13:53:46 <orzo> dolio: I'm concluding that reasonable instances of MonadReader are incompatible with Traversable
13:54:03 <dmwit> It is kosher but weird.
13:54:18 <hpaste> flebron annotated “Parse error on GHC 6.10?” with “Parse error on GHC 6.10? (annotation)” at http://hpaste.org/86650#a86651
13:54:23 <flebron> Is that better?
13:54:57 <typoclass> flebron: yes, much better
13:55:08 <flebron> What does hpaste mean by "Too strict if"?
13:55:16 <dolio> orzo: This comes up in other arenas, too. For instance, it's nice to represent syntax with binders by using functions for the binders. But that kills your ability to traverse the structure.
13:55:22 <dmwit> flebron: You should write putStrLn $ if ...
13:55:29 <dmwit> s/should/could/
13:55:33 <flebron> Ohh. Why is that "too strict", though?
13:55:35 <bergey> >xbscr
13:55:49 <dmwit> flebron: (By the way, if you click the error, it says this.)
13:55:49 <flebron> (That is, what does that have to do with lazyness vs strictness? It would seem to be purely a stylistic issue.)
13:55:55 <flebron> Oh it's a link!
13:56:08 <flebron> Sorry, didn't know that, I thought it was just text. Thanks :)
13:56:21 <dmwit> > if undefined then []:undefined else []:undefined
13:56:23 <lambdabot>   *Exception: Prelude.undefined
13:56:33 <dmwit> > [] : if undefined then undefined else undefined
13:56:34 <lambdabot>   [[]*Exception: Prelude.undefined
13:56:41 <dmwit> This is what is meant by "too strict".
13:56:54 <dmwit> In fact, putStrLn isn't lazy enough to matter in this particular case.
13:57:16 <dmwit> But some functions are. =)
13:57:27 <flebron> Ah, so it wouldn't even know that putStrLn was there if the condition was undefined.
13:57:34 <dmwit> right
13:57:49 <flebron> Can I say putStrLn $ if foo then bar else baz?
13:57:54 <dmwit> yes
13:58:04 * flebron is blissfully unaware of the layout restrictions surrounding do and if.
13:58:14 <flebron> (And let.)
13:58:43 <dmwit> Would you like to change your blissful ignorance into miseryful knowledge?
13:58:51 <dmwit> miserable, I guess
13:58:55 <dmwit> naptime, maybe
13:59:03 <dolio> Which are you going to explain, though?
13:59:09 <dolio> The official way or the GHC way?
13:59:20 <flebron> Is that... different?
13:59:23 <dmwit> Isn't GHC's way the official way now?
13:59:28 <dolio> I can't remember.
13:59:35 <dmwit> FUD, all FUD.
13:59:46 <edwardk> dmwit: in general, yes.
13:59:49 <dolio> I just write everything so that it would never matter.
13:59:59 <SamB_XP> but there *is* no R6RS in Haskell
14:00:00 <edwardk> re ignorance, not the official way
14:00:03 <dolio> Because I like it better.
14:00:06 <SamB_XP> or was that R7RS
14:00:16 <dmwit> edwardk: me, too =)
14:00:43 <edwardk> dmwit: did you guys ever announce hac phi?
14:00:50 <dmwit> Oh, right!
14:01:02 <dolio> Did you ever announce hack beans?
14:01:02 <dmwit> We decided to do it today, and I almost forgot to write themails.
14:01:43 <hpaste> orzo pasted “MonadReader for Traversable” at http://hpaste.org/86652
14:01:51 <edwardk> june 7-9? wow i'll be busy all summer. between that, lambdajam, etc.
14:01:53 <orzo> That might do what I want
14:02:10 <edwardk> dolio: i'm trying to secure us space and figure out when all the workshops are around icfp
14:02:24 <edwardk> if we can do it, then i'd _love_ to have a hac boston right before icfp's workshops start this year
14:02:34 <edwardk> (or right after they all end i guess)
14:05:26 <johnw> edwardk: you're going to LambdaJam?
14:05:42 <__xc> Do people know CEP (http://en.wikipedia.org/wiki/Complex_event_processing) ?
14:05:55 <__xc> here*
14:07:19 <edwardk> johnw: giving a workshop on lenses
14:07:30 <johnw> edwardk: OK, I may have to come then
14:07:40 <edwardk> johnw: they pinged me back in january or so, so i figured i'd go do something
14:08:04 <johnw> I doubt they'll let me register for only your talk, though
14:08:13 <johnw> $400 is a little steep
14:08:21 <johnw> oh, +$50 for your workshop
14:09:32 <edwardk> johnw: yeah. and another 50 for bartosz's ;)
14:09:53 <johnw> i may have to drive up to catch you for dinner or something though
14:10:01 <edwardk> hah fair enough
14:10:05 <johnw> too bad I don't live closer, I'd give you a place to crash
14:10:10 <johnw> plus, I'll see you at ICFP
14:10:30 <edwardk> they are setting me up at a hotel and flying me in, so at least that much isn't on my dime
14:10:36 <johnw> ah, nice
14:10:48 <edwardk> thats where (some of) those high registration fees are going i think ;)
14:11:18 <johnw> i'd rather just spent that fee to get a 1 hour private tutoring session on lens
14:11:34 <edwardk> done. when and where? =)
14:11:37 <johnw> haha
14:12:02 <johnw> edwardk tutorials are like seeds that take a few months to come to fruition in my brain
14:12:12 <johnw> oh, am I right in thinking that Yoneda isn't all that exciting in Haskell?
14:12:22 <edwardk> speaking of which i should braindump the state of analytics at some point
14:12:32 <edwardk> its much much cleaner than when we talked before
14:12:33 <johnw> it seems that real power is the ability to project any category into Set, but since Hask is already in Set, there's not too much added value
14:12:37 <johnw> ah, ok
14:12:50 <johnw> we should do that on the phone next week or something, after I get out from under my current deadline
14:13:32 <edwardk> yoneda is great in haskell. every semigroupoid that gives you the yoneda lemma is a category. Yoneda can be used to turn any GADT into something functor like, you can use one of the yoneda variants to make an IORef you can map the result of, etc.
14:13:52 <johnw> it seems to me, for example, that a type Yoneda Identity a is just abstracting the Rank-2 polymorphism implicit in the meaning of Yoneda
14:14:07 <johnw> yeah, I saw the GADT wrapping, that was very cool
14:14:09 <edwardk> It is what makes type inference work for machines, etc.
14:14:20 <johnw> Yoneda does let you normalize the return types of any family of functions
14:14:31 <edwardk> It is all in all a great design pattern to use in Haskell
14:14:36 <johnw> plus you can do isomorphic CPS transformation of arbitrary functions
14:14:46 <edwardk> Yoneda f   gives you a form of type-enforced fmap-fusion.
14:14:48 <johnw> ok, good to hear that
14:14:57 <johnw> yeah, I saw your notes on fmap-fusion
14:15:01 <johnw> need to think about that angle more
14:15:09 <edwardk> just like how Codensity f  gives you a form of type enforced right-association of binds
14:15:23 <johnw> it is fusing fmap in the same way that DList is fusing ++?
14:15:33 <edwardk> you can view Yoneda f as enforced fmap fusion and Codensity f as enforced bind fusion.
14:15:45 <johnw> that's a nice sentence
14:15:53 <acowley> I still struggle with having any useful intuition for Codensity. I've read edwardk's series a bunch of times, and am still fuzzy.
14:16:02 <edwardk> similar. lowerYoneda . fmap g . fmap f liftYoneda = fmap (f . g) is the main result
14:16:34 <johnw> ah, I see
14:16:37 <johnw> it encodes the fusion
14:16:43 <johnw> rather than leaving it to rewrite rules
14:16:54 <edwardk> acowley: janis voightlaender's asymptotic improvement in computations over free monad's paper probably does a better job of giving intuition for its use in practice.
14:17:25 <acowley> I've read that, too. I just don't have a feel for connecting the algebra to specific applications.
14:17:27 <edwardk> johnw: yeah, the result of that initial chain only fmap's once because it only ever calls fmap once ;)
14:17:32 <johnw> @remember edwardk you can view Yoneda f as enforced fmap fusion and Codensity f as enforced bind fusion.
14:18:03 <johnw> and fmap f . fmap (g . h) likewise becomes fmap (f . g .h)
14:18:03 <lambdabot> Good to know.
14:18:14 <edwardk> johnw: yep
14:18:24 <johnw> why isn't GHC just doing that automatically though?
14:18:34 <edwardk> so if you anticipate doing a lot of mapping and then consuming the result once you can Yoneda it
14:18:34 <johnw> that's the 2nd fnuctor law
14:18:56 <edwardk> the second functor law isn't safe to rely on in general if you don't trust people to not write illegal Functor instances.
14:19:17 <johnw> hmm
14:19:23 <acowley> btw, edwardk, the youtube video with the robot and the conveyor belt was my initial target for linear. Everything came out great.
14:19:26 <edwardk> the compiler can't safely rely on that law as it is only valid in the presence of fmap id = id
14:19:38 <edwardk> robot and conveyor belt?
14:19:45 <acowley> I manually fuse my fmaps :(
14:19:54 <edwardk> acowley: i do to in practice
14:20:02 <acowley> edwardk: http://www.youtube.com/watch?v=Zlt6EJVdUN8
14:20:05 <edwardk> but Yoneda works well when they are going to come deep inside combinators i don't control
14:20:26 <edwardk> acowley: nice =)
14:20:28 <acowley> edwardk: The perception system is all Haskell, and built in part on linear and lens… and about 10x faster than the state of the art.
14:20:38 <edwardk> =)
14:20:58 <c_wraith> ... doesn't that make it a new state of the art?
14:21:10 <acowley> c_wraith: Have to wait for peer review, or at least more youtube views :)
14:21:17 <c_wraith> I vote for the latter.
14:21:19 * c_wraith goes to watch
14:21:20 <acowley> me, too
14:21:24 <acowley> that's why we released the video
14:21:31 <madjestic> hey guys, is there a better way of expressing this?: http://hpaste.org/86655
14:21:34 <acowley> it's hard to sell performance and reliability in academia
14:21:41 <acowley> so we're taking our pitch to the people
14:21:42 <edwardk> acowley: that is very impressive looking stuff =)
14:22:08 <acowley> edwardk: thanks! If you know anyone who wants to invest in factory automation, let me know :)
14:22:36 <c_wraith> ok, it chose the most painful looking way it could have to bend its arm there.  Could you make it look less human, so that it's less jarring when it does that? :)
14:23:06 <acowley> It does way worse looking stuff than that sometimes. We always find it really entertaining.
14:23:43 <acowley> Because you watch it and think that it's just injuring itself for now reason, and only eventually understand what pose it's aiming for.
14:24:32 <luite> acowley: what does that rotating thing just above the shouldes do?
14:24:42 <edwardk> hah
14:24:57 <acowley> It's totally unused here, but it's a laser range finder on a tilt mount. The laser scans horizontally, so with the tilt you get good 3D coverage.
14:25:09 <Rembane> Pew pew pew!
14:25:24 <luite> ah of course, all good robots must have lasers
14:25:29 <c_wraith> oh. I thought it was simulating gossiping with its neighbors on the assembly line
14:25:42 <acowley> It has multiple lasers.
14:25:48 <edwardk> acowley: Now, when our robotic overlords at last rule the planet i will know that i contributed in some small part to our downfall, but i'll still blame you for most of it.
14:25:50 <acowley> Everywhere you look on that thing it has some new sensor.
14:26:14 <monochrom> robots like to use lens
14:26:27 <edwardk> the better to focus their lasers
14:26:28 <acowley> edwardk: I thought when you named "machines" you were taking on responsibility for the robot apocalypse...
14:26:30 <johnw> edwardk: why the name Codensity? what does "density" mean in mathematics?
14:26:36 <edwardk> acowley: hah
14:26:45 <edwardk> johnw: its related to the notion of density in topology
14:26:48 <johnw> acowley: look out for his upcoming library, "singularity", which imports machines
14:26:51 <johnw> ah
14:27:13 <acowley> So the end of humanity will be chronicled in edwardk's package names?
14:27:14 <klrr> what's best to parse stuff, ParseCombinators or something else?
14:27:23 <johnw> trifecta!
14:27:26 <acowley> haha
14:27:28 <johnw> depednso n what you're trying to parse
14:27:28 <edwardk> acowley: more or less
14:27:38 <johnw> klrr: trifecta or attoparsec
14:27:45 <johnw> tri for text, atto for binary
14:27:52 <acowley> I'm trying to fit "trifecta" into the end of the world now, but I can't get away from Seinfeld.
14:27:56 <edwardk> attoparsec is fast, trifecta is pretty and nice to use
14:28:00 <h4199> His final library will be Ragnarök
14:28:07 <klrr> okey, not just parsec?
14:28:16 <johnw> parsec is a bit outdated, and trifecta can do more
14:28:23 <johnw> in a lot of ways, it's very much like parsec
14:28:25 <klrr> okey
14:28:30 <orzo> dolio, dmwit, byorgey: any of you care to comment on my pasted solution to the Traversable with MonadReader problem?  http://hpaste.org/86652
14:28:49 <johnw> trifecta will give you great error reporting, for example
14:28:55 <edwardk> klrr: parsec is more like the template for what a parser combinator library should look like than a serious suggestion at this point. its usable, its not too slow, but its errors aren't as nice as trifectas and its speed isn't as good as attoparsec
14:29:19 <orzo> I've been thinking about it with my specific usage in mind, and I don't really see what could go wrong
14:29:25 <edwardk> h4199: right now i'm working on analytics, i need to study _how_ to bring about the apocalypse first, after all.
14:29:40 <acowley> I still sometimes run into laziness problems with attoparsec.
14:29:41 <klrr> edwardk: okey ill try find some info about trifect
14:29:48 <edwardk> 'apocalypses' is probably the more general package name anyways
14:30:07 <johnw> edwardk: or the latin package, 'revelation'
14:30:17 <acowley> You need the rock dots, though
14:30:19 <edwardk> don't want to limit ourself to any one choice of armageddon
14:30:38 <klrr> what does the term "monadic" implies?
14:30:59 <monochrom> it is the adjective for "monad"
14:31:07 <acowley> apöcalypse might be acceptable
14:31:16 <edwardk> 'exegeses' will probably come first anyways
14:31:36 <edwardk> Clearly it'd just be the Apocalisp
14:31:38 <johnw> klrr: it impels the use of a type that implements Monad, usually
14:31:43 <johnw> ^impels^implies
14:31:49 <acowley> Haskell: The Fate of the World is in Your Hands
14:32:00 <byorgey> orzo: it doesn't satisfy the Traversable laws
14:32:00 <Apocalisp> hello, yes
14:32:11 <byorgey> orzo: for example,  traverse Identity = Identity
14:32:12 <acowley> oh look, the Apocalisp is already here!
14:32:41 <Apocalisp> did you see four horsemen come through here?
14:32:42 <byorgey> because the original BSP could have different results depending on the reader parameter, but the result after doing sequenceA just ignores the reader parameter and gives you a default
14:32:58 <edwardk> ...said mostly to rouse the icelandic rune warrior among us. be careful, his parentheses are sharp.
14:32:58 <byorgey> if you are going to ignore the reader parameter, why have it at all?
14:32:58 <monochrom> now we just need armaged dons
14:33:24 <Apocalisp> armageddonsbot
14:35:05 <cmccann> what's this about the end of the world? is edwardk working on some sort of eschatology package now?
14:35:52 <edwardk> cmccann: every universe i've pushed it to hackage in has ended, so i'm somewhat afraid to do so to this one.
14:36:10 <acowley> Eschatology Well Kmett
14:37:05 <johnw> edwardk: so that is the universal basis for quantum coherence
14:37:06 <cmccann> edwardk: hm, maybe you've been using a quantum suicide optimization algorithm to optimize your other packages
14:37:24 <johnw> all the other possible universes collapse because of edwardk pushing stuff to hackage in them
14:38:13 <edwardk> cmccann: yes, quantum bogosort works well for trying out all of the alternatives so long as you expect at least one to work. just use a small series of discrete quantum events to decide which to work on and end the universe whenever it doesn't pan out.
14:38:36 <edwardk> The downside is, if you're wrong and none of them pan out, you end everything
14:38:44 <johnw> now I see the magic behind his speculation library...
14:38:56 <johnw> he fork off the speculative compilation in another universe
14:39:14 <oconnor0> edwardk: ends up being a pretty serious bug.
14:39:37 <edwardk> yes, "this library is fast so long as the infinite worlds hypothesis holds, otherwise it'll end the time-space continuum for all timelines in which this library was written"
14:40:18 <acowley> I'm pretty sure that physicists will keep pulling back layers of the universe until they discover an unsafeCoerce right at the bottom.
14:40:37 <cmccann> edwardk: nah, it's just that quantum suicide algorithms only work if the likelihood of a random success is greater than a random quantum event sabotaging your device implementing the algorithm
14:41:01 <edwardk> cmccann: hah
14:41:13 <monochrom> unsafeCoerce is where the stacked turtles end and the russian dolls begin
14:41:42 <monochrom> @quote monochrom dolls
14:41:42 <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
14:41:44 <monochrom> :)
14:47:45 <Kayexter> In a list of lists how would i obtain the first value from each list into a new list?
14:48:21 <edwardk> > map head [[1,2,3],[3,4,5]]
14:48:22 <h4199> what have you tried so far?
14:48:22 <lambdabot>   [1,3]
14:48:42 <edwardk> note that if one of your lists is empty that'll blow up taking its head
14:48:46 <johnw> Kayexter: will any of the sublists possibly be empty?
14:49:00 <Kayexter> No none will be empty
14:49:09 * johnw notes that Haskellers tend to avoid 'head' where possible
14:49:16 <Kayexter> ive tried stuff like head x : utyed xs)
14:49:19 <edwardk> > head $ transpose [[1,2,3],[4,5,6]]
14:49:20 <lambdabot>   [1,4]
14:49:25 <edwardk> > head $ transpose [[1,2,3],[]]
14:49:26 <lambdabot>   [1]
14:50:21 <c_wraith> most of us will happily use head if we know the list is empty.  And that sometimes leads to bugs when we know the wrong thing.
14:50:52 <cmccann> > concatMap (take 1) [[1,2],[],[3,4],[5]]
14:50:53 <lambdabot>   [1,3,5]
14:52:05 <johnw> > head $ transpose [[1,2],[],[3,4],[5]]
14:52:07 <lambdabot>   [1,3,5]
14:52:10 <johnw> that's a neat trick
14:52:22 <johnw> > take 1 $ transpose [[1,2],[],[3,4],[5]]
14:52:24 <lambdabot>   [[1,3,5]]
14:52:29 <parcs> > head $ transpose []
14:52:31 <johnw> ah, hence the concatMap
14:52:32 <lambdabot>   *Exception: Prelude.head: empty list
14:52:42 <johnw> > take 1 $ transpose [[],[],[],[]]
14:52:43 <lambdabot>   []
14:52:57 <johnw> > concat $ take 1 $ transpose [[],[2],[],[5]]
14:52:59 <lambdabot>   [2,5]
14:53:25 <cmccann> johnw: mine is basically like a head that returns (Maybe a) and catMaybes
14:53:26 <typoclass> c_wraith: i know the backpack is empty! the backpack however is protesting. http://i.imgur.com/51DqQe5.jpg also, i think your statement might be missing a 'not'
14:53:40 <mm_freak> > foldr (const . Just) Nothing [1..]
14:53:42 <lambdabot>   Just 1
14:53:45 <mm_freak> > foldr (const . Just) Nothing []
14:53:46 <lambdabot>   Nothing
14:53:49 <c_wraith> typoclass: no "not" is missing.
14:54:03 <johnw> cmccann: right, I like it
14:55:04 <mm_freak> :t foldr (const . pure) empty []
14:55:05 <lambdabot> Alternative f => f a
14:55:10 <mm_freak> :t foldr (const . pure) empty
14:55:13 <typoclass> c_wraith: hm ok
14:55:13 <lambdabot> Alternative f => [a] -> f a
14:55:44 <cmccann> johnw: of course listToMaybe exists but that involves more letters, especially uppercase ones
14:55:56 <c_wraith> typoclass: err.  Unless I missed it *twice*, which evidence suggests. >_>
14:56:02 <johnw> boo, hiss
14:56:10 * typoclass scratches his head
14:56:24 <c_wraith> typoclass: after more re-readings, I determined you were correct
14:56:28 <mm_freak> > F.fold [1..] :: First Int
14:56:30 <lambdabot>   Not in scope: `F.fold'
14:56:30 <lambdabot>  Perhaps you meant one of these:
14:56:30 <lambdabot>    `M.fold' (import...
14:56:30 <c_wraith> typoclass: that bag is definitely empty
14:56:34 <typoclass> c_wraith: i don't know anymore :-) initially i was wondering "why do we happily use head on empty lists"
14:56:41 <mm_freak> > Data.Foldable.fold [1..] :: First Int
14:56:43 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Monoid.First GHC.Types.Int))
14:56:43 <lambdabot>    arisin...
14:57:08 <mm_freak> > Data.Foldable.foldMap (First . Just) [1..] :: First Int
14:57:09 <lambdabot>   First {getFirst = Just 1}
14:58:04 <mm_freak> :t Data.Foldable.foldr (const . pure) empty
14:58:05 <lambdabot> (Foldable t, Alternative f) => t a -> f a
14:58:14 <mm_freak> > Data.Foldable.foldr (const . pure) empty [1..]
14:58:15 <lambdabot>   No instance for (GHC.Show.Show (f0 a0))
14:58:16 <lambdabot>    arising from a use of `M82393508...
14:58:24 <mm_freak> > Data.Foldable.foldr (const . pure) empty [1..] :: Maybe Int
14:58:26 <lambdabot>   Just 1
15:03:03 <aCube> > getFirst $ foldMap (First . Just) []
15:03:05 <lambdabot>   Nothing
15:03:59 <otters> :t foldMap (First . Just)
15:04:01 <lambdabot> Foldable t => t a -> First a
15:06:25 <vervic> Hi! Why i get the error "not in scope: 'maxOfThree'" when i run this http://pastebin.com/KeD1RTjh in leksah?
15:07:38 <hpc> vervic: module name and file name have to match
15:07:51 <blackmirroxx2> ls
15:08:00 <blackmirroxx2> good evening
15:08:11 <hpc> [sudo] password for blackmirroxx2:
15:13:54 <vervic> hpc: double checked. this doesn't solve the problem
15:14:56 <hpc> that's vexing
15:15:29 <hpc> i have no other idea what it could be
15:27:58 <blackCoder> ..
15:30:20 <blackCoder> hello i'm new to haskell and i have a question i defined my own data type as "data RegEx = Letter Char " but when i try this  "letter = (spot isLetter) `transform` (\x -> Letter (read x :: Char ))" i get Exception Prelude.Read:no parse any ideea why?
15:31:36 <h4199> @ty read
15:31:37 <lambdabot> Read a => String -> a
15:32:13 <ab9rf> :t \x -> Letter (read x :: Char)
15:32:14 <lambdabot> Not in scope: data constructor `Letter'
15:32:19 <ab9rf> oi, duh
15:32:27 <ab9rf> :t \x -> id (read x :: Char)
15:32:31 <lambdabot> String -> Char
15:32:41 <ab9rf> whats transform?
15:32:45 <ab9rf> :t transform
15:32:46 <lambdabot> Plated a => (a -> a) -> a -> a
15:34:17 <ab9rf> blackCoder: "no parse" means that read couldn't make sense out of what you passed it
15:34:26 <ab9rf> > read "'a'" :: Chair
15:34:28 <lambdabot>   Not in scope: type constructor or class `Chair'
15:34:28 <ab9rf> oops
15:34:28 <lambdabot>  Perhaps you meant `Char' (...
15:34:30 <ab9rf> > read "'a'" :: Char
15:34:31 <lambdabot>   'a'
15:34:36 <ab9rf> > read "a" :: Char
15:34:37 <lambdabot>   *Exception: Prelude.read: no parse
15:34:50 <Mortchek> read "123a" :: Int
15:34:50 <blackCoder> mhm i understand
15:34:52 <klrr> i get some strange error with this code http://paste.ubuntu.com/5606380/ , this is the error https://gist.github.com/klrr/5470893 , any ideas?
15:34:52 <Mortchek> > read "123a" :: Int
15:34:54 <lambdabot>   *Exception: Prelude.read: no parse
15:35:04 <blackCoder> thank you
15:35:28 <ab9rf> blackCoder: for read to succeed with a return type of Char, you need to have a single character in single quotes
15:35:38 <ab9rf> for what you're doing, read is probably not what you want
15:35:49 <ab9rf> although i can't guarantee that because i don't reall yknow what you're doing
15:37:44 <blackCoder> well i try to parse a String like "asdasd"  into a data structure like data  RegEx = Letter char | Sequence [RegEx]  and for now i'm at the first step  i want to parse only letters onto the Letter field
15:43:28 <ab9rf> so something like parse [x] = Letter x; parse x = Sequence (map parse x) ?
15:44:02 <ab9rf> although that will identify all single characters whatsoever as a Letter
15:44:07 <ab9rf> which is likely not what you want
15:45:03 <acowley> (Either a) isn't Foldable or Traversable?
15:46:29 <ab9rf> acowley: no
15:46:55 <ab9rf> how would it work as either?
15:47:40 <ab9rf> :t fold
15:47:42 <lambdabot> (Foldable t, Monoid m) => t m -> m
15:47:52 <Mortchek> Either a isn't a monoid because there's no unique identity element
15:47:58 <Mortchek> What about foldr?
15:49:30 <ab9rf> Either a is an incomplete type
15:49:52 <klrr> there's this guy who is kind of jealous on me since im starting earlier programming than him, and now he gave himself a negative statement that if i would learn some language for same amount of time he would be stuck in some sort of "newbie error", this guy is my idol, he is awesome and i wanna write something back but i dont know what i should write i wanna give him a compliment but i dont know him too well, he is a clojure/python programmer if there's any goo
15:50:10 <blackCoder> <ab9rf> http://pastebin.com/MdtkaJVs  these are my functions transform and spot i tryed now something like letter = (spotWhile1 isLetter) `transform` (\x -> Letter (read x :: String))  but i have the same error and i modified data RegEx         = Letter String
15:50:19 <ab9rf> klrr: this is #haskell, not #psychoanalysis
15:50:41 <klrr> ab9rf: this is serious.
15:50:56 <ab9rf> blackCoder: i don't think you want to use "Letter String" as part of your RegEx ADT.
15:51:03 <Mortchek> klrr, you cut off at "if there's any goo"
15:51:15 <ab9rf> there is definitely goo.
15:51:33 <ab9rf> klrr: dude, we are not here to help you resolve your hero worship issues.
15:51:45 <klrr> FUCK AAH
15:51:47 <ijp> klrr: consult your nearest M-x doctor for help
15:51:55 <klrr> sry...
15:52:12 <Cale> Can you encode your problem somehow as a question about typechecking?
15:52:26 <ab9rf> klrr: unless that hero is Simon Peyton Jones, of course
15:52:43 <klrr> ab9rf: he is the future SPJ
15:53:19 <ab9rf> Cale++
15:56:16 <dmwit> ab9rf: I feel I could easily write fold :: Monoid m => Either a m -> m
15:56:34 <dmwit> Is it really so obvious, then, that (Either a) can't be Foldable?
15:56:49 <dmwit> :t either mempty id
15:56:50 <lambdabot> Monoid c => Either a c -> c
15:57:06 <ab9rf> dmwit: heh
15:58:09 <dmwit> That wasn't a joke.
15:58:14 <ab9rf> i realize that
15:58:56 <rod> hey everyone
15:59:34 <acowley> Okay, how do I say this more succinctly: aux f (ErrorT x) = ErrorT $ x >>= either (return . Left) (fmap Right . f)
15:59:37 <dmwit> So, is there a good reason it's not Foldable?
16:00:01 <rod> to determine the size (bytes) of an Integer value , what to do ?
16:00:20 <geekosaur> if you need the Monoid constraint then maybe the same reason Map and Set aren't Monad?
16:00:36 <dmwit> rod: You are looking for an integer logarithm or similar?
16:00:54 <dmwit> geekosaur: No, that's part of the type of fold in the class.
16:00:56 <acowley> The Monoid constraint is part of Foldable
16:01:14 <dmwit> :t (|||)
16:01:15 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
16:01:31 <dmwit> :t (+++)
16:01:38 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
16:02:23 <dmwit> acowley: Is it possible that aux already exists in the ErrorT library? =P
16:02:30 <acowley> dmwit: Yes, it is
16:02:31 <rod> nop working with large numbers , what to have the number of bytes used by these , as of Integer is arbitrary precision these vary from num to num , want a way to see what a concrete number occupies
16:03:27 <acowley> Well, I'm sure it's somewhere in there
16:03:36 <dmwit> rod: There is no implementation-independent way to know this. I don't know if there is an implementation-dependent way to know. But integer logarithm will get you close.
16:03:46 <dmwit> acowley: What does the MonadPlus instance do?
16:04:32 <dmwit> wait
16:04:37 <dmwit> I'm having trouble reading your code.
16:04:37 <acowley> Not what I want
16:04:56 <dmwit> :t \f x -> ErrorT $ x >>= either (return . Left) (fmap Right . f)
16:04:57 <lambdabot> (Monad m, Functor m) => (b -> m a) -> m (Either e b) -> ErrorT e m a
16:05:04 <rod> dmwit, found on google sizeOf function from Foreign.Storable module but could i use it ?
16:05:52 <dmwit> :t \f x -> do { a <- x; lift (f a) }
16:05:54 <lambdabot> (Monad m, Monad (t1 m), MonadTrans t1) => (t -> m b) -> t1 m t -> t1 m b
16:06:07 <dmwit> acowley: ?
16:06:24 <cmccann> :t \f x@(ErrorT _) -> x >>= lift . f
16:06:26 <lambdabot> (Monad t1, Error t) => (a -> t1 b) -> ErrorT t t1 a -> ErrorT t t1 b
16:06:28 <cmccann> pf do blocks
16:06:51 <dmwit> rod: Try it. =)
16:06:56 <dmwit> rod: (But no, I don't think so.)
16:07:02 <Mortchek> rod, no, it requires that the type you're trying is of a fixed size
16:07:09 <Mortchek> Integer is arbitrary-precision
16:07:28 <acowley> hooray!
16:07:42 <rod> exactly Mortchek  , i need the actual bytecount of a stored Integer value
16:07:49 <acowley> Thanks, guys, this is much nicer. I just looked at the type I needed and went crosseyed
16:08:05 <Mortchek> dmwit's log suggestion is a good idea
16:08:13 <cmccann> if you care about counting bytes maybe you don't want to use Integer in the first place?
16:08:21 <Mortchek> You just take the ceiling of the logBase 2, I think
16:08:36 <Mortchek> Or, ceiling . logBase 2 . (+1)
16:08:37 <klrr> I THINK I GOT HIM A LITTLE BIT HAPPIER :DDDDDDDDDDDDDd
16:08:40 <Mortchek> gives you number of bits
16:08:41 <rod> like 1 == whatimlookigforSizeOf(255::Integer)
16:09:06 <dmwit> rod: You're not too good at taking a hint, are you?
16:09:24 <Mortchek> (of a non-negative integer)
16:10:09 <rod> got this fraction : 50306499199116303593227078396988 % 6923769300006923769300006923769
16:10:16 <klrr> good nigth
16:10:32 <cmccann> negative Integers clearly take infinite bytes since all bits past some point will be 1.
16:10:55 <acowley> It's already the HacPhi time of year?!
16:11:05 <cmccann> also, I'm not sure the bits used by an Integer value tells you anything about how many bytes it uses.
16:11:06 <dmwit> yes!
16:11:09 <Mortchek> I think the way I suggested would help you to store naturals only
16:11:09 <rod> it encodes an ascii string , want to know if i preserve memory from this encoding
16:11:12 <kevix> a newbie question: if I make a file x.hs and use ghci and do ":l x", the file loads and the function works. if I type the same file into ghci, it gives parse errors on '='
16:11:17 <cmccann> oh yeah. I should go to hacphi or something.
16:11:41 <Mortchek> Though you could just add a sign bit to that
16:12:13 <dmwit> rod: That question is very different than the one you started with.
16:12:19 <dmwit> And also depends on your encoding.
16:12:33 <dmwit> I have the number 5. Is this a correct encoding of the string "dmwit is awesome"? Maybe.
16:12:50 <dmwit> If I choose 5 to be the encoding of "dmwit is awesome", it is correct. Otherwise, not.
16:13:26 <rod> i encode a string in a fraction. assume the string is length 32 ... the fraction encoding this string is 50306499199116303593227078396988 % 6923769300006923769300006923769
16:13:52 <Mortchek> If your alphabet is ["dmwit is p cool", "dmwit is a cool person", "dmwit is smart", "dmwit knows his way around Haskell", "dmwit is awesome"], I'd say 5 is a pretty reasonable encoding
16:14:11 <dmwit> That looks like a pretty good alphabet to me.
16:14:15 <rod> now, if those integers numerator and denominator use less than 32 bytes i gain compression
16:14:31 <dmwit> wrong
16:14:42 <rod> to check i need the bytecount of those big Integers
16:14:42 <dmwit> You are assuming that a string of length 32 uses 32 bytes. This assumption is wrong.
16:15:24 <dmwit> And we've told you what can be done and what can't. So do what you can do, or move on to something else.
16:16:16 <kevix> anyone can help with a ghci question? why does my single-line function not parse correctly but a .hs file will?
16:16:42 <Mortchek> kevix, what's the code?
16:16:45 <dmwit> kevix: In ghci, definitions must start with "let".
16:16:51 * dmwit uses his psychic powers
16:17:07 <kevix> doubleMe x y = x*2 +  y*2
16:17:16 <kevix> ohhhh 'let'
16:17:22 <kevix> thanks
16:20:56 <rod> ghc-datasize , recursiveSize ... thanx a lot
16:23:27 <mietek> @hoogle Char -> Word8
16:23:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:23:27 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
16:23:27 <lambdabot> Prelude error :: [Char] -> a
16:23:46 <mietek> OverloadedChars anyone?
16:23:46 <cmccann> it suggests unsafeCoerce? really?
16:24:56 <cmccann> @type ord
16:24:58 <lambdabot> Char -> Int
16:25:17 <mietek> Yes, I know I can (fromIntegral . ord)
16:25:22 <luite> cmccann: it works here :)
16:25:27 <dmwit> huh
16:25:37 <cmccann> of course, Char is larger than Word8...
16:25:44 <dmwit> Prelude> unsafeCoerce '\9876' :: Word8 prints out 9876
16:25:45 <vervic> Hi! when i run an module in haskell sometimes the file cabal_macros.h file is missing. how i can determine whats going wrong?
16:25:59 <cmccann> but nobody actually uses non-ASCII text out in the real world, right
16:26:13 <luite> dmwit: it stores the stuff in a machine word, only narrows it if you properly convert
16:26:24 * dmwit nods
16:26:46 <dmwit> It's surprising for half a second until you think about how you would implement it and what would happen if you do the obvious implementation technique.
16:27:23 <dmwit> vervic: Perhaps that module was really only meant to be built with cabal.
16:27:27 <cmccann> @quote isJust
16:27:27 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
16:28:03 <hpc> null = unsafeCoerce
16:28:29 <hpc> safeHead = unsafeCoerce
16:28:29 <cmccann> hpc: that's probably how edwardk would implement it
16:28:36 <hpc> there's quite a few of these
16:30:11 <hpc> i remember there being one for Mu that was especially fun
16:31:05 <Ghoul_> :t performGC
16:31:06 <lambdabot>     Not in scope: `performGC'
16:31:06 <lambdabot>     Perhaps you meant one of these:
16:31:06 <lambdabot>       `perform' (imported from Control.Lens),
16:49:11 <edwardk> cmccann: i don't actually abuse unsafeCoerce for type changing constructor swapping anywhere, it can leak memory
16:49:16 <ab9rf> blackCoder: sorry i missed your PM, i was afk
16:50:05 <edwardk> cmccann: e.g. unsafecoercing to check if something is non-null, gives you a 'truth' that keeps the contents of the list alive if its reachable
16:50:44 <cmccann> yeah I suspected that would happen
16:51:22 <copumpkin> how does that work?
16:51:56 <edwardk> well, pattern matching on Cons as Bool just gives you effectively it is 'True' right?
16:51:56 <edwardk> but its still holding the two pointers in it, and it has a Cons infotable
16:51:58 <c_wraith> the value header contains a bitmap indicating what parts are pointers
16:52:08 <c_wraith> which is what is used by the GC for pointer-chasing
16:52:16 <c_wraith> and unsafeCoerce doesn't change that header
16:52:18 <copumpkin> the GC just looks at the memory
16:52:20 <copumpkin> yeah
16:52:34 <edwardk> gc doesn't know about types beyond the infotable, yeah
16:52:42 <copumpkin> so it's walking over looking at the pointer section
16:52:50 <edwardk> yeah
16:52:58 <copumpkin> regardless of how code is using that memory
16:53:04 <edwardk> hence that 'Truth' also keeps pointers alive while you are using it
16:53:05 <c_wraith> funny, I hadn't thought about this before. But I knew all the information necessary to figure it out.
16:53:13 <cmccann> I figured based on stuff like the output of vacuum that constructors indicated what they used on their own
16:53:40 <copumpkin> edwardk: but wouldn't the alternative do so as well?
16:53:47 <copumpkin> that's what I don't get
16:53:51 <copumpkin> it's just about having a pointer to it
16:53:55 <copumpkin> not about what type you're treating it as
16:53:59 <c_wraith> If it's not forced, yes
16:54:02 <edwardk> once it gets evaluated it becomes the one True True.
16:54:10 <edwardk> this one _is_ evaluated.
16:54:24 <copumpkin> but Cons vs. True is just pointer tag bits
16:54:26 <copumpkin> isn't it?
16:54:35 <edwardk> it'll be an extra truthy value that keeps the contents of the list alive.
16:55:03 <edwardk> it has dynamic pointer tag bits = 2, so it looks like True to case dispatch, etc. but has 2 pointers in it
16:55:23 <copumpkin> hmm
16:55:27 <edwardk> gc will hold those pointers alive so long as your truth is alive
16:55:33 <cmccann> so both (null xs) and (unsafeCoerce xs) use xs before being forced, but after evaluation the former is just True
16:55:46 <cmccann> whereas the latter is still cons and holds onto its tail
16:55:49 <erisco> is there a general way to swap the nth item of a data structure?
16:56:04 <robde> hello, how does Haskell exactly match types for type variables like in foo :: a -> b?
16:56:05 <copumpkin> oh, I see what you mean. It's not the pattern matching, it's actually coercing it to a Bool
16:56:06 <erisco> by 'swap' I mean replace an old value with a new one
16:56:07 <copumpkin> that I buy
16:56:36 <cmccann> erisco: you build a new data structure with a different item at that position
16:56:38 <edwardk> erisco: with Data.Data.Lens ;)
16:56:54 <edwardk> erisco: but thats not a serious answer unless you are very very familiar with lens
16:57:01 <erisco> cmccann, sure, but if there are several items if you only want to change one, it is verbose
16:57:02 <ab9rf> i should look at lens someday
16:57:14 <copumpkin> ab9rf: a friend of mine did that and his eyes turned black
16:57:18 <cmccann> the question is unanswerable in general. there's no common interface to container types.
16:57:18 <copumpkin> you probably shouldn't
16:57:24 <edwardk> erisco: you can use record syntax to cut the boilerplate down
16:57:33 <shachaf> Warning: Do not look at lens with remaining good eye.
16:57:40 <ab9rf> haha
16:57:48 <cmccann> lens is an uncommon interface that applies to many containers whether they like it or not.
16:57:55 <edwardk> erisco: data Foo = Foo { field1, field2, field3 :: Int } ;    bar x = x { field2 = 12 }
16:58:09 <edwardk> erisco: thats the one good thing _about_ the existing record sugar
16:58:23 <erisco> oh, that's nice. thanks
16:58:35 <ab9rf> cmccann: rapist interfaces?
16:58:43 <cmccann> edwardk: looking at that makes me want to eta reduce the "x" away so badly :[
16:58:56 <shachaf> I wonder whether there are complications with the unsafeCoerce trick if you have more than 7 constructors?
16:59:10 <ab9rf> cmccann: i don't really like record syntax that much.  it feels icky.
16:59:14 <edwardk> cmccann: use lens then ;)
16:59:16 * cmccann unsafeCoerces the complications to simplifications
16:59:19 <shachaf> The tag bits are very uniform across types but maybe the memory layout would be different?
16:59:27 <c_wraith> shachaf: why 7? Are there only 7 bits in the pointer map?
16:59:35 <edwardk> bar = field2 .~ 12
16:59:41 <erisco> something that bugs me about the record syntax... don't the field names have to be unique amongst all other data types?
16:59:53 <edwardk> erisco: yes
16:59:54 <shachaf> c_wraith: I was thinking 7 because there are 3 tag bits.
16:59:56 <ab9rf> erisco: pretty much
17:00:00 <edwardk> erisco: (thats another thing lens fixes)
17:00:09 <cmccann> you can use qualified names like anything else of course.
17:00:10 <ab9rf> erisco: there's an exception but it's silly and annoying
17:00:11 <cmccann> but that's annoying.
17:00:12 <c_wraith> shachaf: there are a lot more than 10 bits in a machine word....
17:00:14 <erisco> every time I come here all I hear about is this magical lens thing lol
17:00:28 <ab9rf> erisco: lenses will wash your cat
17:00:29 <shachaf> c_wraith: ?
17:00:35 <jfischoff> > let foo = Foo { y = x foo, x = "woah!" } in print foo
17:00:36 <lambdabot>   Not in scope: data constructor `Foo'
17:00:47 <edwardk> ab9rf: no, thats a catamorphism. cat -> clean cat. thats in recursion-schemes.
17:00:53 <cmccann> haha
17:00:54 <ab9rf> edwardk: haha
17:01:09 <ab9rf> is there an anastrophe?
17:01:12 <shachaf> Wouldn't a catamorphism be (clean cat -> cat)?
17:01:13 <robde> how does Haskell infer the concrete type for the b from a signature like a -> b?
17:01:19 <robde> is that even possible?
17:01:37 <edwardk> shachaf: yes ;)
17:01:40 <Mortchek> robde, depends on where you use it
17:02:06 <edwardk> shachaf: more likely dirty cat -> cat
17:02:29 <Mortchek> If f :: Foo -> Bar and g :: Int -> a, in the expression f (g 10), a unifies with Foo
17:02:55 <robde> Mortchek: it's an assignment. so I only need a hint, not a solution :) so there is a signature foo :: [a] -> b and I’m asked to implement a function for that signature
17:02:57 <c_wraith> robde: more generally, type unification is global, not linear
17:03:30 <robde> and the function is called with [True, False| :: Integer
17:03:34 <robde> *]
17:03:49 <Mortchek> [True, False] can't possibly be an Integer
17:03:54 <ab9rf> Mortchek: why not?
17:04:04 <robde> oh foo [True, False] :: Integer
17:04:10 <c_wraith> Because there's no OverloadedLists in the standard.
17:04:44 <cmccann> you could write a Num instance for [Bool] easily enough. but that won't give you an Integer.
17:05:09 <hpc> F# has linear type inference, iirc
17:05:13 <Mortchek> robde, are you trying to find the input type of foo?
17:05:40 <cmccann> F# has type inference that works sometimes.
17:05:40 <robde> I guess that is [Bool]?
17:05:46 <Mortchek> robde, yep
17:05:52 <hpc> it goes from left to right, leading to such ridiculous things as function composition sometimes working one way
17:05:56 <hpc> sometimes working the other way
17:06:07 <hpc> depending on which side of the composition is polymorphic
17:06:10 <c_wraith> scala has the same thing.
17:06:18 <cmccann> hpc: seems kind of dumb to me.
17:06:24 <cmccann> and needlessly annoying.
17:06:34 <hpc> so you get ridiculous syntactic workarounds like (x |> g |> f)
17:06:53 <c_wraith> it's recommended that if you write a higher-order function, you put the function arguments last so that it's more likely the inference will work.
17:06:58 <Mortchek> robde, so are you saying you have to implement a function that is actually as general as [a] -> b?
17:07:19 <Mortchek> There's only one such function I can think of and it's not a very useful one
17:07:40 <c_wraith> Mortchek: I suspect it's existentially quantified, not universally
17:08:11 <hpc> Mortchek: thanks to the miracle of seq, there are two
17:08:15 <Mortchek> I actually don't fully understand what "existentially quantified" means
17:08:22 <Mortchek> hpc, fair point
17:08:28 * geekosaur suspects [True,False] was a suggested input and Integer a suggested result type. there's one obvious candidate there for the function...
17:08:43 <hpc> geekosaur: unsafeCoerce!
17:08:47 <Mortchek> geekosaur, I can think of three off the top of my head
17:09:04 <c_wraith> length, length . filter id, length . filter not
17:09:14 <Mortchek> Yeah.
17:09:24 <c_wraith> There are certainly more
17:09:26 <geekosaur> Integer, though, so genericLength
17:09:37 <hpc> geekosaur: there are infinite such functions
17:09:40 <hpc> in the consts alone
17:09:41 <c_wraith> concrete types give so many implementations
17:10:04 <cmccann> c_wraith: seems like a misfeature. this is why I want -XPolymorphismRestriction.
17:10:21 <hpc> cmccann: that's called RankNTypes ;)
17:10:36 <geekosaur> yes, but some variant of length is the simplest since you can ignore the type of the list completely, just need to know it's a list which is a given
17:11:09 <c_wraith> you can add or subtract any constant you want to any of those!
17:11:10 <cmccann> I think speculating about the solution to an underspecified assignment is not terribly useful.
17:11:15 <c_wraith> and then you can get more complicated.
17:11:20 <hpc> cmccann: it's fun
17:11:28 <Mortchek> I think cmccann and hpc both have valid points
17:11:33 <Eduard_Munteanu> What if you hit jackpot? What then? Huh?
17:11:38 <acowley> darnit, now I really do want my Foldable/Traversable Either
17:11:40 <hpaste> blackCoder pasted “Parser module” at http://hpaste.org/86665
17:11:43 <c_wraith> "the number of times the sequence True, False, True appears in the first third of the list"
17:11:57 <c_wraith> "plus 37"
17:12:01 <blackCoder> i have a question related to my parser module
17:12:11 <Mortchek> which of course diverges on infinite lists since the first thing you'd need to do is find the length
17:12:22 <c_wraith> I never claimed to have written a total function.
17:12:28 <blackCoder> i want to parse expresions like a|b
17:12:45 <c_wraith> It would be total if list was data, rather than codata
17:13:13 <robde> Mortchek: would the :: Integer in the function call determine the type of b?
17:13:35 <Mortchek> robde, in which?
17:13:40 <blackCoder> i maked a structure data regex = Letter char | seq [regex] | alternation [regex]
17:14:01 <robde> Mortchek: there is a sample function call foo [True, False] :: Integer
17:14:27 <Mortchek> robde, yeah, :: Integer is a statement about foo [True, False], which is the output of foo given [True, False] as input
17:14:39 <blackCoder> now i want to obtain intermediate values like (alternation (letter 'a')(letter 'b')) how should i aproach this task?
17:15:03 <Mortchek> robde, you already observed the input type is [Bool]
17:15:12 <Mortchek> so now you know the type of foo as specialized here
17:15:51 <blackCoder> i don't want a full solution only some hints
17:16:10 <robde> Mortchek: hm, I tried it with foo = toInteger length, but it does not work :/ "Couldn't match expected type `[a] -> b' with actual type `Integer'"
17:17:15 <Mortchek> @type toInteger
17:17:17 <lambdabot> Integral a => a -> Integer
17:17:18 <Mortchek> @type length
17:17:19 <lambdabot> [a] -> Int
17:17:51 <Botje> blackCoder: you need to write a parser for regular expressions?
17:18:03 <Botje> blackCoder: start by noting down the grammar and write a parser based on that, then
17:18:03 <blackCoder> yes
17:18:07 <Mortchek> robde, does seeing those types give you a clue?
17:18:29 <blackCoder> what do you mean by nothing down th grammar
17:18:59 <Botje> the grammar that makes up the regexp language?
17:19:17 <Mortchek> robde, even assuming you had an appropriate Integral instance, what is the type of the expression on the right side of the =?
17:19:53 <Botje> like R = R|R , R+, R*, RR, (R), etc.
17:20:16 <robde> Mortchek: Integer
17:20:44 <Mortchek> robde, right. That doesn't look like [Bool] -> Integer at all.
17:22:19 <blackCoder> i have 3 operations "|"  that means strings that contains a or b    first i want to implement this  and i could have a(b|c). based on my module i want to split it into 2 parts an intermediate one that will return something like sequence((letter 'a')(alternation(letter 'a')(letter 'b'))) and i don t know hot to parse it into this intermediate structure
17:22:59 <Botje> which is why you need to write down the grammar of your regexps first.
17:23:43 <robde> Mortchek: this confuses me. does not toInterger convert a Int to Integer, too?
17:24:34 <Mortchek> @type toInteger
17:24:36 <lambdabot> Integral a => a -> Integer
17:24:48 <hpaste> blackCoder pasted “Example” at http://hpaste.org/86667
17:24:51 <Mortchek> robde, yep, since there is indeed an Integral instace for Int.
17:25:40 <Mortchek> instance*
17:26:03 <clahey> Hey all.
17:26:11 <robde> Mortchek: so length is of type Int which is an instance of Integral, so toInteger can convert it to Integer, which is the needed type, no?
17:26:19 <clahey> Is anyone else here participating in google code jam?
17:28:09 <Mortchek> robde, your first statement is wrong. Look again at the type of length.
17:28:12 <ab9rf> i prefer strawberry jam
17:28:18 <ab9rf> :t length
17:28:19 <lambdabot> [a] -> Int
17:28:35 <hpc> dark helmet! the radar is jammed!
17:29:15 <edwardk> ab9rf: its cheaper than lambda jam
17:29:17 <heath> https://gist.github.com/heath/5471346
17:30:14 * hackagebot hyakko 0.3.2 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.3.2 (JeremyHull)
17:33:03 <robde> Mortchek: I am still confused
17:33:43 <robde> "yep, since there is indeed an Integral instace for Int." isn’t that my statement, too?
17:35:02 <troydm> what does abbreviation in ap functions stands for ?
17:35:10 <troydm> apply?
17:35:19 <edwardk> yeah
17:37:47 <Mortchek> robde, you are confusing the type of a function with its codomain.
17:38:07 <Mortchek> Which is also a type, but it's the type of what you get after applying the function to something (from its domain).
17:38:37 <otters> well, it WILL give you an Integer, but only inside the domain of Ints
17:38:41 <otters> which isn't much use
17:38:47 <otters> depending on your architecture
17:39:37 <Mortchek> robde, either that or you are confused about what the "foo bar" syntax does.
17:40:17 <Mortchek> (It means "apply the function foo to the argument bar")
17:40:45 <Mortchek> robde, do you need a stronger hint?
17:41:53 <ab9rf> i could never confuse a type of a function with its codomain
17:42:00 <ab9rf> this is because i don't know what a codomain is
17:42:22 <Mortchek> ab9rf, in a -> b, b is the codomain
17:42:23 <otters> domain is possible input values, right?
17:42:24 <c_wraith> codomain is the domain of the values returned by the function
17:42:29 <otters> codomain is possible input values
17:42:31 <otters> output*
17:42:54 <ab9rf> Mortchek: ah.  that's called "type" in languages like C
17:43:09 <Mortchek> ab9rf, the return type, specifically
17:43:14 <ab9rf> Mortchek: yes
17:43:29 <Mortchek> Even in C, a function has a type described by its input types and its return type
17:43:50 <ab9rf> Mortchek: yes
17:43:53 <Mortchek> Same idea here, just think input type (there's just one) is domain and return type is codomain
17:45:23 <robde> length is type of [a] -> Int which becomes [Bool] -> Int and toInteger is type of Integral a => a -> Integer, which becomes Int -> Integer, what do I miss?
17:46:34 <Mortchek> robde, what you want is to hand length a [Bool], then take its resulting Int and hand that to toInteger, and get an Integer from that. That is not what the thing you wrote means.
17:47:14 <robde> foo xs = toInteger (length xs) ?
17:47:22 <Mortchek> robde, \o/
17:47:37 <Mortchek> You could also have used (.) and not had to use a parameter
17:47:47 <Mortchek> @type (.)
17:47:49 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:48:13 <robde> Mortchek: but it says: Couldn't match type `b' with `Integer'
17:48:26 <robde> oh
17:48:36 <Mortchek> > let foo xs = toInteger (length xs) in foo [True, False] :: Integer
17:48:37 <lambdabot>   2
17:48:39 <Mortchek> Looks fine to me.
17:49:12 <robde> but the signature is foo :: [a] -> b
17:49:35 <Mortchek> Ah, right, toInteger is not as general as that.
17:49:37 <dmwit> > genericLength [True, False] :: Integer
17:49:38 <lambdabot>   2
17:49:50 <c_wraith> you want toIntegral, not toInteger
17:50:06 <c_wraith> :t toIntegral
17:50:07 <lambdabot>     Not in scope: `toIntegral'
17:50:07 <lambdabot>     Perhaps you meant one of these:
17:50:07 <lambdabot>       `fromIntegral' (imported from Prelude),
17:50:14 <c_wraith> err, yes, fromIntegral
17:50:14 <Mortchek> @type fromIntegral
17:50:15 <lambdabot> (Integral a, Num b) => a -> b
17:50:54 <dmwit> Did I miss some context?
17:51:00 <dmwit> Why are we computing the length with the wrong type first?
17:51:40 <Mortchek> robde, the problem is you will never get as general as that, actually
17:51:55 <Mortchek> (At least not usefully)
17:52:22 <Mortchek> There are only two values of type [a] -> b I can think of, neither of which is likely to be what you want
17:52:37 <Mortchek> I think you've misinterpreted some part of your assignment
17:52:49 <randomclown> Is it possible to put a STUArray in a data declaration?
17:53:08 <dmwit> yes
17:53:22 <dmwit> Now ask the real question. :3
17:53:25 <randomclown> How do I declare the data so that the s matches?
17:53:39 <robde> Mortchek: the professor said that there is one task that is (almost) impossible to solve
17:54:27 <dmwit> randomclown: make it a parameter to the type
17:54:55 <robde> *sigh*, I spent too much time on this one and I didn’t learn anything from it. thanks for your help though
17:55:20 <Mortchek> robde, are you acquainted with undefined, and if not, are you expected to use something you're not acquainted with?
17:55:34 <randomclown> Do I need to use Rank2Types to do that?
17:55:39 <Mortchek> I would rate it more probable you've misinterpreted the assignment than you are legitimately being asked to write a function [a] -> b
17:55:41 <randomclown> dmwit:
17:55:50 <dmwit> no?
17:56:26 <robde> Mortchek: undefined and error are not allowed in the assignment
17:56:37 <Mortchek> robde, then the problem is impossible as you've put it.
17:57:10 <robde> it says "impossible (very difficult)"
17:57:43 <dmwit> It is easy to implement any type without error or undefined.
17:57:52 <robde> i should’ve taken it literally
18:01:28 <Mortchek> dmwit, what do you mean?
18:01:31 <hpc> :t let f = (\x -> f x) :: [a] -> b in f
18:01:32 <lambdabot>     Couldn't match type `b1' with `b2'
18:01:32 <lambdabot>       `b1' is a rigid type variable bound by
18:01:32 <lambdabot>            the inferred type of f :: [a1] -> b1 at <interactive>:1:5
18:01:41 <hpc> noooooo!
18:02:22 <Mortchek> @type let f x = f x in f
18:02:23 <lambdabot> t -> t1
18:02:46 <Mortchek> That's just the identity
18:03:04 <Mortchek> Wait no
18:03:06 <Mortchek> I'm silly
18:03:17 <Mortchek> f x = x would be the identity
18:03:49 <Mortchek> Oh right, t1 can be anything because it fails to terminate
18:04:26 <dmwit> ?type let f = f in f -- even more general still
18:04:28 <lambdabot> t
18:04:33 <Mortchek> hpc, your problem was that :: was binding too tightly
18:04:46 <Mortchek> I think
18:04:51 <hpc> it was binding just fine
18:04:59 <Mortchek> Never mind, I am just confused right now
18:05:13 <hpc> i was careful about that by expanding the lambda
18:06:02 <Mortchek> That is super grody. Why is it doing that?
18:07:58 <troydm> today i was reading RWH programming with Monads part
18:08:18 <dmwit> Mortchek: No matter what type you give hpc's f, it doesn't match the 100% unrestricted type he claims (\x -> f x) has in the body.
18:08:34 <dmwit> Because the one in the body is using *fresh* type variables compared to the type you give the outer f.
18:08:36 <troydm> and the moment he started jungling with types in chapter 15
18:08:43 <troydm> my head started spinning
18:08:48 <hpc> dmwit: oh dammit, that's right
18:08:58 <dmwit> ?google you could have invented monads and maybe you already have
18:08:58 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:09:18 <Mortchek> dmwit, can you illustrate?
18:09:42 <troydm> dmwit: thx
18:09:51 <dmwit> :t let f :: [a] -> b; f = (\x -> f x) :: [c] -> d in f -- hpc already illustrated, but maybe if I give them different names it will be more obvious
18:09:52 <lambdabot> [a] -> b
18:09:57 <dmwit> wait
18:10:02 <dmwit> what
18:10:16 * hackagebot base58address 0.3 - Parsing and serialization for Base58 addresses (Bitcoin and Ripple)  http://hackage.haskell.org/package/base58address-0.3 (StephenWeber)
18:10:30 <Mortchek> [a] and [c] unify, b and d unify, right?
18:10:36 * ab9rf throws gertrude stein at dmwit 
18:10:52 <dmwit> Oh, right, because when you give a type signature it's allowed to be more polymorphic than what you can possibly infer on your own.
18:11:16 <ab9rf> dmwit: you just broke my sarcasm meter.
18:11:35 <dmwit> <- not sarcastic, just stupid
18:11:43 <dmwit> possibly also wrong
18:11:46 <ab9rf> hehe
18:11:50 <ab9rf> i have no idea
18:11:56 <ab9rf> i'm drunk anyway
18:12:26 <ab9rf> i have a lot of upper back pain tonigh and am drinking hoping it will go away
18:13:04 <Mortchek> I still don't understand the explanation for why hpc's version failed
18:13:29 <Mortchek> Where is there claimed a "100% unrstricted type"?
18:13:36 <dmwit> I *think* it's the same reason ScopedTypeVariables are nice.
18:13:38 <Mortchek> unrestricted*
18:13:52 <hpc> Mortchek: it wants f to have a fully polymorphic type, but the value it has is too monomorphic
18:13:55 <hpc> i think
18:13:57 <dmwit> So it might make sense to read GHC's manual's section on that extension.
18:14:26 <ab9rf> NO! DON'T READ THE MANUAL!
18:14:51 <ab9rf> i'm offended by the phrase 'too monomorphic'
18:15:20 <ab9rf> either your monomorphic or you're not
18:16:54 <Mortchek> My favorite part of the error message I get locally is "The function `f' is applied to one argument, but its type `[a] -> b' has only one"
18:17:07 <Mortchek> > 1 == 1
18:17:08 <lambdabot>   True
18:17:39 <dmwit> File a bug.
18:17:48 <Mortchek> > let (==) = const . const False in 1 == 1
18:17:49 <lambdabot>   False
18:17:52 <Mortchek> Much better.
18:18:03 <hpc> Mortchek: that's awesome
18:18:05 <otters> > let _ == _ = False in 2 == 2
18:18:07 <lambdabot>   False
18:18:08 <Mortchek> Hmm, should I file a bug even if I'm lagging behind in version?
18:18:23 <hpc> Mortchek: if it hasn't been seen before, yes
18:18:28 <hpc> worst case, no reproduction
18:18:41 <ab9rf> it might not have bene checked in the current code
18:18:59 <ab9rf> and the bug report will provoke testing of the current codebase
18:19:03 <Mortchek> Okay, where's the official bug tracker? Github?
18:19:23 <Mortchek> Ah, found it.
18:29:15 <liyang> ab9rf: my monomorphic what?
18:29:51 <ab9rf> liyang: that sounds like a personal problem
18:30:01 <liyang> ab9rf: you started it!
18:30:17 <ab9rf> yeha, but i'm drunk.  what's your excuse?
18:30:27 <liyang> It's 10:30 in the morning. :<
18:30:34 <ab9rf> that plays
18:44:04 <acowley> Hmm, I created a temporary file to explore my ErrorT types from earlier. It turns out I named the file ErrorTissue, which came as rather a shock when I cycled past it in emacs.
18:45:20 * SamB_XP imagines a line of facial tissues with error messages printed on them
18:45:45 <Mortchek> There's probably a category theoretic concept called a tissue
18:46:48 <acowley> A Gesundheit is the analogue to an Eigenvalue in the tissue category.
19:11:23 <tswett> So, in Haskell, algebraic data types can be turned into topological spaces in a certain nice way, right?
19:12:41 <tswett> Suppose I have "data TypeZ = X TypeX | Y TypeY". My intuition says that this is the topological space TypeX + TypeY, except that _|_ is also an element, and the only open set containing _|_ is _|_.
19:12:47 <tswett> Is that how it works?
19:14:16 * SamB_XP wonders what happens if you have two data constructors with the same field types and try to apply tswett's intuition
19:14:50 <tswett> Same thing. The sum TypeX + TypeX, with _|_ added.
19:15:46 <johnw> tswett: right, your type is isomorphic to Either () (), or 1 + 1
19:16:03 <tswett> johnw: well, I never actually said what TypeX and TypeY are.
19:16:05 <johnw> so, i'd look up how the category 2 maps to a topo space
19:16:12 <johnw> it doesn't matter what they
19:16:24 <johnw> oh, I misread
19:16:29 <johnw> I saw X_TypeX and Y_TYpeY
19:17:59 <flebron> Say I have a bunch of let bindings, none of which depend on any other. Is there any advantage to declaring them all in a single "let", vs multiple lets, in a do block?
19:18:29 <flebron> (Specifically, will it perform marginally better since it desugars to less functions being called with >>=?)
19:18:51 <geekosaur> a single let is somewhat easier to read, but I don't imagine it generates different code at all
19:19:05 <tgeeky> flebron: the answer is probably: inspect the core and find out
19:19:24 * flebron is not of high enough level to venture in those lands
19:19:31 * flebron would be most likely eaten by a grue.
19:19:44 <tgeeky> flebron: you won't have to understand the code to see that one of them has many more lines
19:19:50 <tgeeky> or not
19:22:47 <mm_freak> flebron: let's assume that the compiler is not smart enough to collapse the individual let-bindings into a single one, then doing that yourself gives a small performance advantage, but that's very unlikely
19:23:24 <mm_freak> to be sure you should check the core representation as tgeeky suggested…  and be sure to check it both with and without -O
19:24:13 <geekosaur> note also that multiple vs. single could just produce the same code *after* core
19:24:42 * tgeeky thought about that, and decided not to care
19:24:44 <geekosaur> if they're all together then there isn't actually a (>>=) involved, it's just let ... = ... in let ... = ... in let ...
19:25:19 <mm_freak> interestingly the original G machine would collapse them as part of its compilation process…  for STG that's optional
19:26:26 <tgeeky> haha @ "the original G machine". that's so inadvertantly gangsta.
19:31:29 <tswett> Hmmm. Are all ADTs compact...
19:32:41 <tswett> Yes, trivially. If S is a type, then any open cover of S must have S as an element; thus, a finite subcover of that open cover is {S}.
19:32:53 <tswett> (Because the only open set containing _|_ is S.)
19:45:20 * hackagebot ofx 0.2.0.0 - Parser for OFX data  http://hackage.haskell.org/package/ofx-0.2.0.0 (OmariNorman)
19:46:53 <Clint> :-O
20:03:24 <BMeph> BBL
20:05:46 <xenocons> potentially very general question but:
20:05:49 <xenocons> Two questions: 1. if you have a BNF  "<x> : <m>? <q> | <p>? <k>", what is the best way to model this as a type? 2. Once the type is modeled, what is the best way of generating all possible permutations?
20:06:15 <xenocons> currently im doing it manually
20:09:44 <sw2wolf> @ty (<*)
20:09:45 <lambdabot> Applicative f => f a -> f b -> f a
20:10:35 <edwardk> dmwit: around?
20:17:23 <mietek> @pl (\x -> [x])
20:17:23 <lambdabot> return
20:20:28 <ParahSail1n> @ty (:[])
20:20:30 <lambdabot> a -> [a]
20:25:22 * hackagebot hosc 0.14 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.14 (RohanDrape)
20:30:22 * hackagebot hosc-json 0.14 - Haskell Open Sound Control JSON Serialisation  http://hackage.haskell.org/package/hosc-json-0.14 (RohanDrape)
20:35:22 * hackagebot postgresql-simple 0.3.1.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.1.0 (LeonSmith)
20:45:22 * hackagebot here 1.2 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2 (TaylorHedberg)
20:52:19 <goganchic> hi2all
20:53:50 <goganchic> I'm a haskell nub. While reading real world haskell I found such instruction: "tidySecond :: [a] -> Maybe a". Can anybody explain me what does it mean?
21:00:22 * hackagebot hosc-utils 0.14 - Haskell Open Sound Control Utilities  http://hackage.haskell.org/package/hosc-utils-0.14 (RohanDrape)
21:00:24 * hackagebot hsc3 0.14 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.14 (RohanDrape)
21:02:57 <flebron> goganchic: You mean you don't understand the type signature?
21:05:23 * hackagebot hsc3-rw 0.14 - hsc3 re-writing  http://hackage.haskell.org/package/hsc3-rw-0.14 (RohanDrape)
21:05:52 <goganchic> flebron, I do not understand what this string do. After this string there are two more: "tidySecond (_:x:_) = Just x" and "tidySecond _       = Nothing" And it is absolutely clear, but If I even remove first string - nothing changes
21:06:07 <johnw> i have a type which is the inverse of MaybeT.  do you think it makes more sense for me to call it HardlyT, or HaystackT?
21:06:30 <flebron> goganchic: What that says is that for every type a, tidySecond takes a list of a, and returns a Maybe a.
21:06:56 <flebron> A "Maybe a" is a type with exactly two constructors. Values of type "Maybe a" can be either Nothing, or Just x, with x a value of type a.
21:07:29 <goganchic> flebron, ok, and why compiler works well event if I remove this line?
21:07:43 <flebron> Because it can deduce the types for you, in most cases.
21:08:01 <flebron> For instance, if I say f x = x + 1, there's not that many things that x could be. x could not be, say, a String, because you can't "+" strings.
21:08:51 <flebron> The only things you can "+" with 1, are Nums, and so Haskell will infer that f takes a Num, and returns a Num.
21:09:38 <flebron> (Note that Num here isn't strictly a type, it's an typeclass. It's similar to "interfaces" in other languages. It defines a set of operations that any type must follow, if it is to be an instance of that interface. For instance, Int is a Num, because you can do +, - and so on with it.)
21:10:23 * hackagebot hmt 0.14 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.14 (RohanDrape)
21:10:25 * hackagebot hps 0.14 - Haskell Postscript  http://hackage.haskell.org/package/hps-0.14 (RohanDrape)
21:10:27 * hackagebot hcg-minus 0.14 - haskell cg (minus)  http://hackage.haskell.org/package/hcg-minus-0.14 (RohanDrape)
21:12:24 <goganchic> flebron, so this instruction says what type of variable function can process and what type of result it return?
21:12:34 <flebron> Yes.
21:13:01 <goganchic> flebron and it work well in this simple case because compile can calculate types without this instruction?
21:13:09 <flebron> Yes.
21:13:16 <goganchic> flebron thanks :)
21:13:21 <flebron> No problem :)
21:13:46 <NickC__> In sequence [x..y], what is correct syntax?  e.g. [1..3] gives [1,2,3], but [LT..GT] is error.  [LT ..GT] and [LT .. GT] are ok.  When is a space needed after the first item?
21:15:23 * hackagebot hls 0.14 - Haskell Lindenmayer Systems  http://hackage.haskell.org/package/hls-0.14 (RohanDrape)
21:15:25 * hackagebot hsharc 0.14 - Haskell SHARC bindings  http://hackage.haskell.org/package/hsharc-0.14 (RohanDrape)
21:15:27 * hackagebot hsc3-db 0.14 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.14 (RohanDrape)
21:15:29 * hackagebot sc3-rdu 0.14 - Haskell bindings to sc3-rdu (sc3 rd ugens)  http://hackage.haskell.org/package/sc3-rdu-0.14 (RohanDrape)
21:15:57 <c_wraith> NickC__: you need a space after a value that starts with a capital letter. This is because of a clash with how module name resolution works
21:16:40 <c_wraith> NickC__: if you say [LT..GT], it thinks you are attempting to apply an operator named . from the LT module to only a left argument, not in a section, which is a syntax error
21:16:40 <NickC__> c_wraith: many thanks
21:17:08 <c_wraith> err, only a right argument. I have trouble with those.
21:17:43 <NickC__> c_wraith: Ah, I see.  Makes sense.
21:20:23 * hackagebot hsc3-cairo 0.14 - haskell supercollider cairo drawing  http://hackage.haskell.org/package/hsc3-cairo-0.14 (RohanDrape)
21:20:25 * hackagebot hsc3-lang 0.14 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.14 (RohanDrape)
21:20:27 * hackagebot hsc3-sf 0.14 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-0.14 (RohanDrape)
21:25:23 * hackagebot hsc3-unsafe 0.14 - Unsafe Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-unsafe-0.14 (RohanDrape)
21:25:25 * hackagebot hsc3-graphs 0.14 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.14 (RohanDrape)
21:30:23 * hackagebot html-minimalist 0.14 - Minimalist haskell html library  http://hackage.haskell.org/package/html-minimalist-0.14 (RohanDrape)
21:30:25 * hackagebot hcg-minus-cairo 0.14 - haskell cg (minus) (cairo rendering)  http://hackage.haskell.org/package/hcg-minus-cairo-0.14 (RohanDrape)
21:30:27 * hackagebot hmt-diagrams 0.14 - Haskell Music Theory Diagrams  http://hackage.haskell.org/package/hmt-diagrams-0.14 (RohanDrape)
21:54:36 <wole> @ty map
21:54:37 <lambdabot> (a -> b) -> [a] -> [b]
21:57:25 <FUZxxl> @t (.)
21:57:25 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:57:30 <FUZxxl> @type (.)
21:57:33 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:57:50 <FUZxxl> wow. they fixed thatr
21:57:56 <FUZxxl> @type (.) . (.)
21:57:57 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:58:26 <FUZxxl> @type (1+) . [ 1  .. 10 ]
21:58:28 <lambdabot>     Couldn't match expected type `a0 -> c0' with actual type `[t0]'
21:58:28 <lambdabot>     In the second argument of `(.)', namely `[1 .. 10]'
21:58:28 <lambdabot>     In the expression: (1 +) . [1 .. 10]
21:59:49 <sw2wolf> @ty (1+)
21:59:50 <lambdabot> Num a => a -> a
22:00:30 <sw2wolf> @ty (1+) .
22:00:31 <lambdabot> parse error (possibly incorrect indentation)
22:01:23 <sw2wolf> > map (1+) [1 .. 10]
22:01:25 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
22:05:20 <randomclown> Is there an integer square root?
22:05:31 <randomclown> Without conversion to floating
22:05:37 <johnw> yes
22:05:37 <johnw> one sec
22:05:46 <johnw> isqrt = ceiling . sqrt . fromIntegral
22:05:56 <johnw> hm
22:05:58 <johnw> sorry
22:06:09 <randomclown> that's a joke right
22:06:24 <johnw> i forgot that it converted to floating
22:06:45 <johnw> actually, edwardk has some I think
22:06:52 <c_wraith> There's on on the wiki
22:07:09 <mietek> @hoogle [Bool] -> Bool
22:07:09 <lambdabot> Prelude and :: [Bool] -> Bool
22:07:09 <lambdabot> Data.List and :: [Bool] -> Bool
22:07:09 <lambdabot> Prelude or :: [Bool] -> Bool
22:07:11 <c_wraith> it's slower than the conversion to Double, though
22:07:21 <c_wraith> So it's really only worth it if you need more precision than Double can give
22:07:24 <johnw> @google fast integer square root approximation
22:07:26 <lambdabot> http://ww1.microchip.com/downloads/en/AppNotes/91040a.pdf
22:13:21 <ma-> Should I bother learning haskell as a first programming language?
22:15:44 <johnw> ma-: what do you want from life?
22:16:43 <ma-> the ability to help and make cool things
22:16:46 <ma-> i guess.
22:16:56 <johnw> then haskell fits just fine
22:17:14 <ma-> Is it unusual for people to learn it as a first language?
22:17:23 <johnw> somewhat
22:17:24 <ma-> and if so, why?
22:17:28 <johnw> but that's becoming more common
22:17:32 <johnw> it's not as popular, mainly
22:17:39 <c_wraith> In the grander sense, it's unusual to learn it at all
22:17:44 <c_wraith> first language or 10th
22:17:55 <ma-> in some circles that im in
22:18:01 <ma-> its all about ruby and python to make webapps
22:18:10 <ma-> and some whisper about haskell as the "elite thing"
22:18:26 <ma-> because it scales the best or something like that
22:18:34 <ma-> i wouldn't know, i just know html and css.
22:19:20 <randomclown> Don't learn haskell for a first language, learn it because it's fun. Haskell had a tendency to shaft you hard when you want performance
22:19:42 <randomclown> Learn C like normal people
22:19:51 <ma-> okay
22:19:59 <Rotaerk> ...
22:20:01 <johnw> don't listen to him, ma-
22:20:02 <ma-> yeah looking at some haskell code is just blowing my mind
22:20:12 <johnw> the mind blowing part is what we like best about it
22:20:25 <ma-> it doesnt even really read like ruby or python do
22:23:55 <ab9rf> haskell only shafts you on performance if you let it
22:24:02 <ab9rf> C will shoot you in the foot
22:24:16 <ma-> why don't more startups and companies use haskell?
22:24:16 <randomclown> ab9rf: said nobody ever
22:24:40 <ab9rf> ma-: because haskell requires more intelligence and more discipline to get results, i suppose
22:24:54 <ab9rf> any fool can write crap in ruby
22:28:08 <ab9rf> ruby has piss-poor performance, quite nearly the worst language in common use
22:28:16 <ab9rf> although it's slowly improving
22:28:41 <randomclown> yeah that's applies to all dynamic typed interperted languages
22:28:44 <randomclown> what is your point?
22:29:01 <ab9rf> randomclown: no, ruby is worse than say python or even php
22:29:50 <randomclown> It's not a order of magnitude difference though, same performance range
22:30:03 <c_wraith> actually, it is an order of magnitude worse than PHP
22:31:04 <hpaste> flebron pasted “Is there a faster way to read two ints and print their product?” at http://hpaste.org/86672
22:31:23 <ab9rf> yeah, it really is
22:31:29 <flebron> (By faster I mean using any tricks you can imagine. The bottleneck in this case really is I/O. This is simply for a programming contest type thing. :))
22:31:39 <ab9rf> ruby is typically about 0.1x the speed of PHP or python.
22:31:53 <flebron> (I'm particularly worried about "print".)
22:32:02 <c_wraith> flebron: if you're not using bytestring-lexing, that's probably the fastest way to parse them
22:32:31 <flebron> What is that? (I can't install package on the online judge's machine, that weren't present in Haskell Platform 2009. :((()
22:32:35 <flebron> *packages
22:33:02 <c_wraith> ah, the terrible things bad ecosystems make you do.
22:33:13 <lispy> heh, I tried to make my code parallel and use all the cores. It ran a fair bit slower.
22:33:14 <c_wraith> You could probably use the code from that package in your submission
22:33:39 <c_wraith> unless it's using some of the dirtier bytestring stuff
22:34:01 <ParahSail1n> bytestring -> int parsing can be pretty bad
22:34:45 <ParahSail1n> i've had programs actually run faster in python than ghc haskell where the parsing was the compute bottleneck, just because python uses c atoi
22:34:54 <lispy> ma-: I think haskell is used/liked by people who enjoy programming and like to focus on programming as an activity. Startups are often focused on some 'cool new idea' that will make them successful.
22:35:31 <lispy> ma-: While they could use haskell, they often want to optimize for getting their tech out there. So they just use whatever has good libraries for what they need.
22:35:31 <ab9rf> lispy: "better is worse" wins again
22:35:38 <ab9rf> er, "worse is better" that is
22:36:45 <lispy> ma-: ergo, I wouldn't worry about what start up use, but I do think the emphasis on "can I produce something useful" is relevant to everyone.
22:37:53 <lispy> (IMO, programming is more like applied math than pure math)
22:41:19 <flebron> my god... https://groups.google.com/forum/?fromgroups=#!topic/fa.haskell/QTP6cc6X6w4
22:41:41 * flebron implements those ridiculously precise ways of reading ints.
22:41:50 <ab9rf> heh
22:42:45 <c_wraith> you'll note he's the author of bytestring-lexing, too
22:45:28 <flebron> I can't decide if this or Arrow is more magical.
23:06:23 <edeast> how do i kill cabal
23:06:53 <edeast> i did this, rm -rf the /.cabal
23:07:40 <edeast> i have package conflicts everywhere, trying to just wipe the slate
23:07:52 <edeast> the rm-rf didn't work
23:10:33 <edeast> found an answer http://stackoverflow.com/questions/7961604/fixing-issues-noted-by-ghc-pkg-check/7961896#7961896
23:11:51 <lispy> edeast: try cabal-dev next time
23:12:06 <lispy> edeast: It should help with reducing package conflicts
23:12:44 <ff323> Hi, I have a homework assignment to write a parser for the programming language "Tiny".  I am abit stuck on where to get started, any help would be appreciated, here is the brief.
23:12:47 <edeast> k.
23:12:49 <hpaste> ff pasted “haskell homework” at http://hpaste.org/86673
23:15:26 * hackagebot free-game 0.9 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9 (FumiakiKinoshita)
23:18:44 <sw2wolf> @djinn [Bool] -> Bool
23:18:44 <lambdabot> Error: Undefined type []
23:19:13 <sw2wolf> @pl [Bool] -> Bool
23:19:13 <lambdabot> (line 1, column 10):
23:19:13 <lambdabot> unexpected '>'
23:19:13 <lambdabot> expecting operator
23:27:31 <Rotaerk> hrm, where is the ((->) r) instance of Functor defined
23:30:03 <Rotaerk> this is weird; :info Functor isn't showing one for functions
23:30:13 <Rotaerk> I thought that was part of GHC.Base
23:31:06 <lispy> Rotaerk: IIRC, :info only shows it if you import the right module
23:31:40 <Rotaerk> ah
23:32:38 <lispy> Rotaerk: http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Monad-Instances.html
23:32:56 <lispy> (amazingly) googling for ((->) r) functor found that :)
23:33:06 <lispy> (I really wouldn't expect a google search to work that well)
23:33:56 <Rotaerk> lispy, think that's deprecated
23:34:01 <Rotaerk> and it's in Control.Monad now
23:34:25 <Rotaerk> and it's in the prelude.. d'oh
23:34:26 <lispy> ah
23:34:53 * lispy demands his money back from google
23:35:24 <lispy> ff323: Did your instructor ask ou to use a specific parsing tool? parsec? happy?
23:35:50 <lispy> ff323: you might find this helpful: http://www.eecs.ucf.edu/~leavens/COP4020/docs/follow-grammar-haskell.pdf
23:49:50 <Rotaerk> @pl
23:49:50 <lambdabot> (line 1, column 1):
23:49:50 <lambdabot> unexpected end of input
23:49:50 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:50:29 <Rotaerk> @pl (Functor f, Foldable t) => t (a->a) -> f a -> f a
23:50:29 <lambdabot> (line 1, column 34):
23:50:29 <lambdabot> unexpected '>'
23:50:29 <lambdabot> expecting operator
