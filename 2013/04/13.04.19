00:00:20 <Cale> mapToGraph m = [Node x xs | (x,xs) <- Map.toList m]
00:01:03 <Cale> func ns ns' = mapToGraph (Map.unionWith (++) (graphToMap ns) (graphToMap ns'))
00:01:51 <Cale> In fact, you probably shouldn't be storing graphs as lists in the first place, because almost all your operations will have bad time complexity
00:02:58 <Cale> You probably actually want to go a little further here
00:03:00 <Cale> as well
00:03:04 <Cale> I just used (++)
00:03:28 <Cale> because your example didn't have any where the edges overlapped -- you might want to add the weights on the edges instead
00:03:52 <Cale> In which case, you'd be better off turning *those* into Maps as well, and combining them with unionWith (+)
00:04:45 <rifki> okey, Thank you :)
00:06:15 <Cale> Or of course, if you're stubborn and want to leave things in list form, you can still use Map to implement the collection algorithm
00:07:53 <Cale> collect f xs = Map.toList (Map.fromListWith f xs)
00:08:18 <Cale> collect :: (Ord k) => (a -> a -> a) -> [(k,a)] -> [(k,a)]
00:13:50 <sordina3> Hey guys. Is there a way to test quickcheck properties with Test.Framework?
00:14:03 <sordina3> There doesn't seem to be a Testable instance for Property
00:14:07 <donri> @hackage test-framework-quickcheck2
00:14:07 <lambdabot> http://hackage.haskell.org/package/test-framework-quickcheck2
00:14:25 <nbouscal> I'm having some trouble trying to understand bytestrings. I'm working with cryptography stuff, taking hex input, and it looks like bytestring treats everything as ascii? so do i want to just readHex and work with Ints?
00:14:39 <nbouscal> and if so, is there an easy way to output in base 64?
00:14:50 <shachaf> nbouscal: No, ByteStrings treat everything as bytes.
00:14:55 <sordina3> donri: that's what I'm using, but testProperty doesnt' test properties...
00:15:03 <shachaf> Bytes aren't text, so there's no ASCII involved.
00:15:14 <nbouscal> right, but when i read in data as a bytestring
00:15:15 <shachaf> (Maybe you're accidentally using ByteString.Char8? That's a broken module.)
00:15:25 <nbouscal> maybe, i have no experience at all with this stuff
00:15:35 <donri> sordina3: Testable prop => Testable (Gen prop)
00:15:46 <donri> sordina3: type Property = Gen Prop
00:15:52 <donri> sordina3: Testable Prop
00:15:59 <shachaf> nbouscal: ByteString is for sequences of bytes, i.e. integers between 0 and 255.
00:16:05 <sordina3> How odd... Maybe I need to import something else...
00:16:06 <shachaf> If you want text, try Data.Text
00:16:41 <sordina3> I seem to get:
00:16:43 <sordina3>     No instance for (QuickCheck-2.5.1.1:Test.QuickCheck.Property.Testable
00:16:45 <sordina3>                        (Gen Prop))
00:16:47 <nbouscal> i think my main problem is figuring out what i want haha. I'm trying to do crypto stuff and don't really know what i'm doing
00:17:15 <shachaf> "I'm trying to do crypto stuff and don't really know what i'm doing"... I hope this isn't actually code that will be used for anything?
00:17:24 <nbouscal> nope, definitely not
00:17:33 <donri> sordina3: ghc-pkg list QuickCheck?
00:17:36 <nbouscal> doing some challenges for learning purposes
00:17:47 <shachaf> Oh, those.
00:18:04 <shachaf> OK, I guess you should just keep in mind not to use .ByteString.Char8
00:18:10 <nbouscal> ok, i will keep that in mind, thank you
00:18:27 <shachaf> Well -- unless you know why you shouldn't use it. Then maybe you can use it. :-)
00:18:42 <shachaf> For these challenges I imagine that [Word8] and [Char] are perfectly adequate, for what it's worth.
00:19:09 <sordina3> donri: I've got 2.5.1.1 and 2.6.
00:19:44 <donri> sordina3: you might be compiling against both. are you using cabal?
00:21:31 <sordina3> Not at the moment. Just ghci
00:21:58 <donri> ah yeah, this problem easily shows up in ghci
00:22:21 <sordina3> Is there a way to get ghci to respect your project's cabal file?
00:22:38 <sordina3> Because that would be totally awesome.
00:22:47 <donri> maybe try passing in the exact package-version with -package, or ghc-pkg unregister the one you don't want (you want what test-framework-quickcheck2 is built against)
00:23:08 <sordina3> I'll give it a go. Thanks for your help :)
00:23:16 <donri> sordina3: not yet, cabal repl is in the works. there's cabal-dev ghci but not perfect
00:23:49 <sordina3> donri: Awesome. I'll check that out.
00:31:16 <vhz> nbouscal: maybe you should have a look at base64-bytestring and base16-bytestring
00:31:59 <nbouscal> i was taking a look, i'm still confused by how reading data into them works.
00:33:20 * hackagebot socks 0.5.1 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.5.1 (VincentHanquez)
00:33:22 * hackagebot language-java 0.2.3 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.3 (VincentHanquez)
00:33:24 <sordina3> Passing -package to ghci works. Cheers!
00:33:33 <nbouscal> i'm a bit out of my depth, i don't usually work this close to the bits, as it were. i'm trying to understand how if i read in '1' with B.getLine, then unpack it, i get 49
00:33:51 <donri> sordina3: may want to ghc-pkg unregister or hide the other one
00:34:11 <donri> then you don't need -package
00:34:48 <dmwit> > ord '1' -- nbouscal ?
00:34:50 <lambdabot>   49
00:36:27 <nbouscal> so it is character ordering, that's why i was i was thinking ascii
00:36:47 <sordina3> donri: I can't unfortunately as a couple of different packages are using each version.
00:37:27 <sordina3> If I could mark one as the default that would work.
00:38:45 <donri> sordina3: you can rebuild them against one version
00:38:59 <dmwit> nbouscal: The question is really how you are looking at the data your code is reading; if there's any encodings involved, that's where it's involved.
00:39:06 <vhz> nbouscal: '1' utf8 encoding and ascii encoding happens to coincide.
00:39:10 <donri> sordina3: cabal install [all the relevant packages plus quickcheck]
00:39:27 <dmwit> ByteString itself doesn't concern itself with encodings; it's bytes before it's read and it's bytes after.
00:39:29 <sordina3> They're not my projects, So I'd have to make some changes to their overspecified dependencies.
00:39:39 <nbouscal> if I have, say, "ff", and i want to get the bytestring corresponding to 255, would i do readHex and then pack, or something like that?
00:41:16 <donri> > '\xff'
00:41:18 <lambdabot>   '\255'
00:42:29 <vhz> nbouscal: do you mean a ByteString "\xff", a ByteBtring "ff" or a String "ff" ?
00:43:07 <nbouscal> vhz: a String "ff"
00:43:27 <nbouscal> or really, an input to stdin of "ff"
00:44:14 <vhz> if you know that it is only hex, you can use Data.ByteString.Char8.pack on it and then use base16-bytestring function to decode it
00:44:46 <vhz> nbouscal: otherwise if you're not sure it's hex, you can use utf8-string module to transform a string into a bytestring, and then use base16-bytestring
00:45:10 <dmwit> That is wrong, because you are not reading carefully.
00:45:22 <dmwit> The correct answer is "yes, use readHex and pack".
00:45:45 <vhz> dmwit: how is that wrong ?
00:45:48 <dmwit> Optionally, use readHex, inRange, fromInteger, and pack for added safety.
00:46:42 <dmwit> It is not wrong. I am just an idiot.
00:47:27 <shachaf> > "abc" ^? hex
00:47:28 <lambdabot>   Not in scope: `hex'
00:47:29 <lambdabot>  Perhaps you meant `lex' (imported from Prelude)
00:47:33 <shachaf> Oh, it's not in lambdabot.
00:47:37 <shachaf> > "abc" ^? base 16
00:47:39 <lambdabot>   Just 2748
00:52:17 <arkeet> > chunksOf 2 "beef" ^.. traverse . base 16
00:52:19 <lambdabot>   [190,239]
00:56:16 <shachaf> @let hex = base 16; binary = base 2
00:56:18 <lambdabot>  Defined.
00:56:44 <shachaf> harkeet
00:57:04 <nbouscal> i think most of my problem is that it's 1 am and my brain stopped working an hour ago. thank you very much everyone for the help, i'll try to figure it out tomorrow
01:05:42 <tsinnema> suppose you have a class declaration that can look like 'class Foo f where ...', and suppose that f would be a type constructor instead of a concrete type, is there any way to specify explicitly that f is a type constructor?
01:06:32 <donri> tsinnema: that's inferred if you have something like "f a" in a type signature in the class body
01:06:41 <tsinnema> donri, yeah
01:06:47 <shachaf> Well, if any of the methods' types use f at a particular kind, it'll be inferred.
01:06:53 <shachaf> With a GHC extension you can give a kind signature.
01:06:54 <tsinnema> that much i'm aware of, but i
01:07:30 <tsinnema> but i was wondering if it can be expressed explicitly, to make it clearer for myself if for no other reason
01:07:56 <shachaf> With an extension, KindSignatures.
01:08:06 <tsinnema> ok got it, thanks
01:10:01 <killy9999> can I somehow express NaN#, that is unboxed Double containing a NaN ?
01:12:42 <shachaf> You can use 0.0## /## 0.0##
01:26:23 <no-n[2]> let (Just x) = lookup 'c' (zip ['a'..'f'] [10..]) in x
01:26:30 <no-n[2]> > let (Just x) = lookup 'c' (zip ['a'..'f'] [10..]) in x
01:26:31 <lambdabot>   12
01:28:46 <no-n[2]> I wonder if you can pattern match with let like that such that you cover it in case of Nothing as well
01:28:56 <shachaf> No.
01:29:00 <shachaf> But you can use case.
01:29:04 <shachaf> That is what case is for.
01:29:14 <no-n[2]> hmm
01:29:38 <no-n[2]> how?
01:29:55 <shachaf> case ... of Just ... -> ...; Nothing -> ...?
01:30:18 <no-n[2]> ah. thanks
01:32:06 <mvb> Can I connect to a listening socket or does it have to call accept before? it seems i should be able to do 1. listen on serversocket 2. clientsocket connects to serversocket. 3. serversocket calls select then accept if there is anything to connect to. 4. success! ?
01:33:11 <Kinnison> that sounds about right
01:33:22 <Kinnison> once you call listen() on the server, the kernel is ready for incoming connections
01:40:24 <merijn> mvb: You have to call accept, because that's what spawns of a new socket descriptor for the connection you just created
01:55:04 <hpaste> “rifki ” pasted “Working with a graph data type” at http://hpaste.org/86119
01:56:10 <rifki> hey I made a hpaste, could you have a look?
01:56:59 <rifki> http://hpaste.org/86119
01:57:59 <latermuse> rifki: I was under the assumption that the hpaste code is opensource and hosted on github. There isnt a reason to make a new hpaste
01:58:26 * hackagebot io-streams 1.0.2.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.0.2.1 (GregoryCollins)
01:58:52 <rifki> oh I am sorry for using wrong term, I pasted a code on hpaste
02:01:01 <vamega_> Hi
02:01:21 <vamega_> Could someone explain why this doesn't work?
02:01:29 <vamega_> f = fst $ fst
02:01:40 <vamega_> but f = fst . fst does
02:01:59 <vamega_> however f x = fst $ fst x works
02:02:15 <tzh> by saying fst $ fst you're saying the second fst should have a type of (a, b), which it doesn't
02:02:16 <vamega_> I thought that by omitting the arguments
02:02:35 <blueonyx> :t (fst $)
02:02:36 <tzh> > (fst .)
02:02:37 <lambdabot> (b, b1) -> b
02:02:38 <lambdabot>   *Exception: show: No overloading for function
02:02:41 <tzh> :t (fst .)
02:02:43 <lambdabot> (a -> (c, b)) -> a -> c
02:02:56 <blueonyx> :t (fst $)
02:02:57 <lambdabot> (b, b1) -> b
02:02:58 <shachaf> vamega_: a $ b = a b
02:03:02 <vamega_> right
02:03:04 <shachaf> vamega_: So fst $ fst = fst fst
02:03:07 <blueonyx> :t fst
02:03:09 <lambdabot> (a, b) -> a
02:03:22 <vamega_> So I guess it goes down deeper than that
02:03:32 <vamega_> by omitting arguments
02:03:49 <shachaf> Maybe you're thinking of: fst $ fst x
02:03:54 <vamega_> does the compiler simply perform a textual substitution on both sides of the equation
02:03:55 <vamega_> right
02:04:04 <vamega_> shachaf, that is what I'm thinking
02:04:05 <shachaf> No, it's not a textual substitution.
02:04:10 <vamega_> I'm thinking that f = a
02:04:26 <shachaf> It's a substitution in the tree/graph.
02:04:29 <shachaf> Pretend it adds parentheses.
02:04:50 <donri> @src ($)
02:04:50 <lambdabot> f $ x = f x
02:04:51 <tzh> $ and . are both functions that do certain things.
02:04:51 <vamega_> is evaluated as f _freeVarName = x _freeVarName when applied to 1 parameter
02:04:52 <donri> @src (.)
02:04:53 <lambdabot> (f . g) x = f (g x)
02:04:53 <lambdabot> NB: In lambdabot,  (.) = fmap
02:04:57 <shachaf> Let's say: f = fst $ fst becomes f = ($) (fst) (fst)
02:05:20 <shachaf> And ($) a b = a b
02:05:41 <vamega_> shachat, how does f = fst $ fst become $ (fst) (fst)
02:05:43 <shachaf> (fst $ fst x), on the other hand, is: ($) (fst) (fst x)
02:05:47 <shachaf> It doesn't.
02:05:49 <vamega_> shouldn't it become simple fst fst?
02:05:54 <shachaf> $ (fst) (fst) is a syntax error.
02:06:03 <latermuse> fst .fst
02:06:08 <arkeet> a # b means (#) a b
02:06:10 <arkeet> for any infix operator #
02:06:23 <vamega_> right
02:06:24 <shachaf> One step at a time. ($) (fst) (fst) becomes fst fst
02:06:25 <vamega_> oh I see
02:06:36 <vamega_> :t ($)
02:06:37 <lambdabot> (a -> b) -> a -> b
02:06:44 <shachaf> But the issue here is parsing. So first get rid of the complicated part: Infix expressions.
02:06:52 <arkeet> note ($) = id
02:07:00 <shachaf> a $ b = a b
02:07:03 <shachaf> dollar a b = a b
02:07:08 <shachaf> Same thing, here.
02:07:11 <vamega_> got it
02:07:16 <vamega_> I'm following you so far.
02:07:34 <shachaf> So which part is confusing now?
02:07:49 <shachaf> hi arkeet
02:07:53 <arkeet> hi
02:07:53 <vamega_> fst fst x
02:07:57 <vamega_> oh I see
02:07:58 <vamega_> Wait
02:08:00 <vamega_> Nevermind
02:08:03 <vamega_> fst fst x
02:08:07 <shachaf> OK.
02:08:12 <shachaf> Do you know what "a b c" means?
02:08:12 <arkeet> fst fst x is (fst fst) x
02:08:13 <vamega_> is trying to apply fst to the function fst?
02:08:17 <shachaf> Yes.
02:08:17 <vamega_> right?
02:08:27 <shachaf> a b c is really (a b) c
02:08:47 <vamega_> that's why selectWin1 x = fst $ fst x works
02:08:59 <vamega_> since it translates to fst (fst x)
02:09:00 <vamega_> ?
02:09:06 <shachaf> Yes.
02:09:09 <vamega_> Great
02:09:11 <shachaf> Well, it turns into ($) (fst) (fst x)
02:09:17 <shachaf> Which turns into (fst) (fst x)
02:09:26 <shachaf> Because ($) a b = a b
02:09:32 <vamega_> Thanks a lot, that actually cleared something up that I didn't really get when reading LYAH.
02:09:39 <vamega_> And has bit me ever since
02:09:43 <arkeet> that's what we're here for.
02:09:44 <arkeet> I think.
02:09:59 <donri> I'm only here for the cookies.
02:09:59 <vamega_> I had thought of it as text insertion sort of thing.
02:10:10 <arkeet> ok, that's what we are here for, except for donri.
02:10:10 <shachaf> arkeet: I thought we were here for the puns?
02:10:22 <arkeet> I'm not.
02:10:25 <arkeet> I think your puns are terrible.
02:10:28 <donri> I love cookies.  They're so easy.
02:10:34 <shachaf> Would you rather I stopped making them?
02:10:40 <arkeet> ...no...
02:11:11 <shachaf> arkeet, pun masochist
02:11:49 <vamega_> Another quick question
02:11:55 <vamega_> when using the . operator
02:12:01 <vamega_> not operator
02:12:02 <vamega_> function
02:12:16 <vamega_> we're changing the direction we things in correct?
02:12:30 <vamega_> so snd . snd . fst
02:12:45 <donri> is the same as \x -> snd (snd (fst x))
02:12:52 <vamega_> right
02:12:52 <donri> no direction changing :)
02:12:54 <shachaf> There is no change of direction.
02:13:06 <vamega_> Well there is if you're trying to sequence operations
02:13:19 <donri> it's different from what you might be used to in OOP languages and method invocation, though
02:13:29 <vamega_> I'm trying to extract the first, from the result extract the second, and then finally from that result extract the third.
02:13:37 <vamega_> It's what I'm used to in math.
02:14:11 <arkeet> except because haskell is lazy, f (g (h x)) really does f first.
02:14:11 <donri> math functions? same as haskell?
02:14:15 <vamega_> I'm doing the exercises on https://www.fpcomplete.com/school/haskell-fast-hard/haskell-fast-hard-part-2
02:14:29 <arkeet> but that's aside from the point. :p
02:14:39 <vamega_> and the solution for selectWin3
02:14:44 <merijn> Well, it's a direction change if you think in terms of shell pipes
02:14:44 <vamega_> when I read the problem
02:15:26 <merijn> vamega_: For what it's worth, you could define your own operator that reads like a pipeline, i.e. "let (|>) = flip (.) in fst |> snd |> snd"
02:15:40 <merijn> It even exists already
02:15:47 <donri> the totally sexy >>> operator
02:15:48 <arkeet> that is >>> from Control.Category
02:15:50 <merijn> :t (>>>) `asAppliedTo` id
02:15:51 <lambdabot> (b -> b) -> (b -> c) -> b -> c
02:16:17 <arkeet> :t (>>>) `asAppliedTo` (undefined :: a -> b)
02:16:18 <vamega_> That's an arrow right?
02:16:19 <lambdabot> (a -> b) -> (b -> c) -> a -> c
02:16:36 <arkeet> it's a function.
02:16:45 <vamega_> Well, yes.
02:16:48 <merijn> vamega_: >>> is actually from Control.Category, with the obscure type
02:16:50 <merijn> :t (>>>)
02:16:51 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
02:16:56 <donri> it's from Category, which is a superclass of Arrow, of which functions have an instance
02:16:56 <arkeet> just take cat = (->)
02:17:26 <vamega_> Ah, alright.
02:17:34 <vamega_> I'll leave that stone unturned for now.
02:18:14 <arkeet> well, whenever you see something that works on Categories or Arrows, it's a good idea to think about what it does just for (->)
02:18:14 <vamega_> Thank you though
02:18:18 <arkeet> :t (&&&)
02:18:20 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:18:25 <arkeet> pretend a = (->), so
02:18:30 <arkeet> :t (&&&) `asAppliedTo` (undefined :: b -> c)
02:18:32 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
02:19:14 <donri> (hey, is (->) to Arrow what Identity is to Monad?)
02:19:21 <arkeet> yes
02:19:39 <arkeet> well, in some sense.
02:20:00 <arkeet> at least in the sense that Kleisli Identity = (->)
02:20:24 <shachaf> You know what's better than Arrow? Profunctor.
02:20:35 <merijn> shachaf: I like profunctors, they're so easy!
02:20:42 <merijn> Oh wait, my bad, that's monoids
02:20:44 <arkeet> they are.
02:20:46 <donri> well but arrow is a generalization of functions, no? so the function instance adds no structure (is that the term?)?
02:20:50 <shachaf> merijn: What's with the "I like X, it's so easy" thing?
02:20:52 <shachaf> I don't get it.
02:21:01 <arkeet> Arrow is kind of ugly.
02:21:06 <arkeet> it does too many things
02:21:17 <shachaf> Is data Foo a b = Foo a valid Arrow?
02:21:28 <arkeet> no, you can't write arr
02:21:32 <nh2> anyone using ghc with the gold linker?
02:21:37 <shachaf> arkeet: Why not?
02:21:41 <merijn> shachaf: Now I'm not sure if you're messing with me or my memory is just faulty :(
02:21:54 <arkeet> shachaf: (a -> b) -> a
02:22:04 <shachaf> Er.
02:22:10 <merijn> :t arr
02:22:11 <lambdabot> Arrow a => (b -> c) -> a b c
02:22:16 <shachaf> arkeet: Look at the grammar there again.
02:22:24 <shachaf> Assume that I know English reasonably well. :-)
02:22:53 <arkeet> I don't know what your point is.
02:23:03 <shachaf> Is "data Foo a b = Foo" a valid Arrow?
02:23:07 <Bor0> where can I find a good example proof of some language being turing complete? so far I've found "brainfuck can be written in language X, therefore language X is turing complete". but is there some detailed (mathematical) proof about this?
02:23:09 <arkeet> ahaha.
02:23:20 <__xc> self learning NNs are the one with feedbacking?
02:23:32 <arkeet> I would expect so.
02:23:43 <__xc> hehe k
02:23:45 <shachaf> I expect so too, now that I looked at the class again.
02:23:55 <merijn> Bor0: Proving turing completeness is rather hard, so people usually proof you can write "known Turing complete language X in it" as proof
02:24:13 <shachaf> Lots of things aren't Turing-complete. Like C.
02:24:17 <merijn> Bor0: Usual values for X would be brainfuck, Turing machines and lambda calculus
02:24:34 <Bor0> what does "hard" mean when proving turing completeness?
02:24:50 <merijn> Bor0: "no one really knows a good way to do it, other than equivalence"?
02:25:15 <merijn> I'm not even sure if there is another way, but I'm no expert
02:25:16 <arkeet> well, something is turing complete by definition if it can simulate a turing machine.
02:25:33 <merijn> arkeet: Yes, but that's just proof-by-equivalence like I just said :)
02:25:58 <vamega_> cellular automatas
02:26:03 <vamega_> are turing complete
02:26:16 <arkeet> which ones?
02:26:16 <vamega_> hence equivalence to one of those would work too.
02:26:24 <merijn> vamega_: Only some, I think
02:26:40 <vamega_> Rule 110
02:26:44 <vamega_> At least
02:26:52 <vamega_> The game of Life
02:26:58 <vamega_> Yeah not all of them are
02:27:12 <Bor0> "something is turing complete by definition if it can simulate a turing machine." was enough I think, thank you guys
02:28:07 <arkeet> sometimes it helps just to look at the definition.
02:28:16 <Bor0> that's what I was just thinking ;D
02:29:00 <merijn> Bor0: By extension, something that can simulate any language capable of simulating a turing machine must also be turing complete
02:29:20 <merijn> Brainfuck is just a well known, easy to proof target, I think
02:29:46 * Kinnison likes BF
02:30:04 <Bor0> so when comparing lambda calculus and turing complete, is it like saying "what came first, the chicken or the egg"? afaik, both were implemented around the same time. or is lambda calc. a subset of turing? or does this question make any sense at all
02:30:21 <vamega_> shachat - you said C wasn't turing complete.
02:30:27 <vamega_> Care to explain that at all?
02:30:28 <Iceland_jack> Bor0: What do you mean by subset?
02:30:52 <Bor0> is it correct to say that any turing complete language is a subset of turing machine? or they are _equivalent_ ?
02:31:45 <Iceland_jack> They are equivalent, that's why Turing completeness is sometimes called Turing Equivalence
02:32:00 <Iceland_jack> Equivalent wrt power
02:32:12 <Bor0> I see. okay then, disregard the question I just asked, since it does not make any sense
02:33:51 <vamega_> (+) ((*) x x) ((*) y y)
02:34:07 <vamega_> lambdabot  (+) ((*) x x) ((*) y y)
02:34:31 <vamega_> wait how do I get to use the lambdabot to make an expression point free
02:34:44 <shachaf> You say @pl ...
02:34:44 <kranius> @pl
02:34:45 <lambdabot> (line 1, column 1):
02:34:45 <lambdabot> unexpected end of input
02:34:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:34:46 <shachaf> But it won't help here.
02:34:49 <vamega_> @pl  (+) ((*) x x) ((*) y y)
02:34:49 <lambdabot> x * x + y * y
02:34:53 <shachaf> That expression is already point-free.
02:35:07 <vamega_> @pl f x y = (+) ((*) x x) ((*) y y)
02:35:07 <lambdabot> f = (. join (*)) . (+) . join (*)
02:35:23 <vamega_> well, I guess you need to give it both sides of the equation.
02:35:41 <shachaf> No. You need to give it a function.
02:35:51 <shachaf> @pl f = (+) ((*) x x) ((*) y y)
02:35:51 <lambdabot> f = x * x + y * y
02:35:58 <shachaf> @pl \x y -> (+) ((*) x x) ((*) y y)
02:35:58 <lambdabot> (. join (*)) . (+) . join (*)
02:36:04 <vamega_> right
02:36:16 <vamega_> I see what it's doing
02:36:23 <vamega_> what I'm trying to do however
02:36:35 <vamega_> is convert (+) ((*) x x) ((*) y y)
02:36:39 <vamega_> into a form
02:36:58 <vamega_> where all operator functions are applied in a prefix form
02:37:05 <vamega_> but without that many parenthese
02:37:18 <vamega_> I came up with f x y = (+) $ (*) x x $ (*) y y
02:37:22 <shachaf> You're allowed more than three words in one line of IRC. :-)
02:37:23 <vamega_> But that didn't work.
02:37:33 <no-n[2]> lol
02:37:49 <shachaf> It doesn't work because $ is infixr. That is, a $ b $ c is a $ (b $ c)
02:37:57 <vamega_> I'm sorry. I'll try to type more in a single line. It's just a habbit of mine to compulsively hit the return key.
02:38:23 <vamega_> The excessive notifications must get annoying. Sorry.
02:40:24 <vamega_> shachaf, so (+) $ (*) x x $ (*) y y is being translated into (+) $ (*) x x  y*y
02:40:30 <vamega_> am I right?
02:40:39 <shachaf> No.
02:40:50 <vamega_> Or rather (+) $ (*) x x  (y*y)
02:41:03 <shachaf> Yes, it's equivalent to that.
02:41:36 <vamega_> is (+) $ (*) x x  y*y equivalent to (+) $ (*) x x  (*) y y
02:41:53 <shachaf> No.
02:41:58 <shachaf> You should try these things out in ghci.
02:41:59 <__xc> I'll try to train a NN to do additions :)
02:42:00 <vamega_> And is there any way I can check things like this using ghci?
02:42:13 <shachaf> I don't think you can get the parse tree.
02:42:26 <shachaf> But you can write in concrete numbers and see whether it type checks and what the result is.
02:43:13 <jerng> Hi! I just figured out how to write a .cabal file for use with cabal-dev.
02:43:18 <shachaf> (+) $ (*) x x  y*y   means   ($) (+) ((*) ((*) x x) y)
02:43:33 <jerng> How do I compile the executable in the sandbox?
02:43:33 <__xc> i said something stupid since additions can be done with one neuron
02:44:10 <shachaf> Er, I messed that up.
02:44:18 <shachaf> (+) $ (*) x x  y*y   means   ($) (+) ((*) ((*) x x y) y)
02:44:26 <arkeet> well, first see how tihngs are grouped.
02:44:30 <shachaf> By the way, you might be less confused if you used prefix functions here.
02:44:35 <arkeet> (+) $ ((*) x x y) * y
02:44:38 <shachaf> plus x y = x + y; times x y = x * y
02:44:47 <shachaf> plus $ times x x y*y
02:44:53 <arkeet> (+) $ (*) ((*) x x y) y
02:44:57 <shachaf> That way there aren't as many parentheses so it's less confusing.
02:45:15 <vamega_> the idea of prefix functions is good.
02:45:18 <vamega_> Thanks for that
02:45:38 <shachaf> Anyway just listen to arkeet.
02:45:43 <arkeet> I'm done.
02:46:06 <arkeet> anyway, chances are (*) x x y is a type error
02:46:10 <jerng> How do I get GHC to use the sandbox package database created by "cabal-dev install" ?
02:46:20 <donri> jerng: "cabal-dev install"
02:46:51 <donri> unless you used --only-dependencies or whatever that flag is called, 'install' build your package too
02:46:58 <jerng> donri: thanks, already did that "cabal-dev ghci" works, but "runghc" and "ghc" can't find the sandbox'd package DB.
02:47:42 <arkeet> indeed.
02:47:54 <donri> jerng: yeah, you'll need to set GHC_PACKAGE_PATH for that (or whatever the name is again)
02:48:05 <arkeet> as an alternative to cabal-dev, you could try hsenv.
02:48:10 <jerng> donri: thanks, let me look that up.
02:48:16 <donri> or that, or sandboxer
02:48:29 <jerng> ok - I'll look into those too.
02:48:30 <arkeet> which fiddles with that stuff for you, so you can just type "ghc" and so on.
02:48:31 <donri> @google cabal-dev sandboxer
02:48:33 <lambdabot> http://hackage.haskell.org/package/cabal-dev
02:48:33 <lambdabot> Title: HackageDB: cabal-dev-0.9.2
02:48:39 <donri> ok not that :p
02:49:03 <vamega_> shachaf, arkeet - Thanks a lot. This has helped enormously.
02:49:36 <arkeet> oh, sandboxer https://github.com/lightquake/sandboxer
02:49:59 <arkeet> I've only used hsenv.
02:50:01 <vamega_> I think my lack of really understanding how the $ and . functions worked severely hampered my learning of other topics
02:50:38 <vamega_> Another question, if you use linux and your distro doesn't provide the latest haskell platform
02:50:41 <vamega_> What do you od?
02:50:54 <shachaf> Download GHC and install it yourself.
02:51:31 <arkeet> you have to do this anyway if you want a newer ghc than the platform.
02:52:28 <shachaf> The Haskell Platform is overrated.
02:52:31 <shachaf> It's just some packages.
02:53:03 <vamega_> Hmm, I've considered that, my worry is that a source install of ghc will interfere with the system xmonad package.
02:53:13 <vamega_> But I'll test this out and see how it goes.
02:53:17 <donri> well, it provides executables you can't depend on with cabal and it provides agreed upon versions to default to
02:53:27 <donri> vamega_: what distro?
02:53:36 <vamega_> fedora 18
02:53:47 <donri> hm that has latest HP i think?
02:53:54 <vamega_> one version old.
02:54:09 <vamega_> so ghc 7.4
02:54:20 <arkeet> the latest HP also uses 7.4
02:54:22 <arkeet> (7.4.2)
02:54:51 <arkeet> although a new HP with 7.6 is due to be released in a couple of weeks.
02:54:57 <vamega_> oh well
02:55:05 <donri> vamega_: http://dag.github.io/blog/2012/07/24/latest-haskell-platform-on-fedora-17/  this might work in f18 too
02:55:07 <vamega_> I guess I'm just going to compile it from source.
02:55:11 <arkeet> you don't have to.
02:55:15 <arkeet> just get a ghc binary.
02:56:10 <vamega_> arkeet - I don't understand that?
02:56:18 <vamega_> Just copy over the binary?
02:56:28 <arkeet> you can download a binary distribution from http://www.haskell.org/ghc/download
02:56:46 <donri> vamega_: haskell.org/ghc provides binary tarballs. but see my blog :)
02:57:33 <shachaf> Don't compile from source.
02:58:03 <arkeet> agreed.
02:58:19 <shachaf> If you compile from source, arkeet will get you.
02:58:26 <arkeet> I will?
02:58:31 <shachaf> Yes.
02:58:34 <merijn> Also, it takes ages
02:58:45 <arkeet> it takes ages and there is no benefit.
02:58:48 <merijn> I know, I had to wait 4 hours for the damn thing to compile last week :(
02:58:53 <merijn> Well, there's one benefit
02:59:14 <merijn> Latest snapshot supports "where" for TypeFamilies! \o/
02:59:26 <merijn> I think I peed my pants a little when I heard :p
02:59:41 <donri> vamega_: if you go with the binary releases you'll need to make a symlink for libgmp to trick it to use the newer version fedora ships
03:00:11 <vamega_> I could do that
03:00:27 <donri> vamega_: and whatever you do it might be wise to [re]move ~/.ghc when you're done and rebuild your local cabal packages ('cabal install world' may or may not work)
03:00:42 <vamega_> right
03:00:45 <donri> vamega_: but easier to do what i suggest in the blog post i linked you!
03:00:51 <vamega_> I was just wondering how I could just grab a binary release?
03:01:08 <arkeet> vamega_: from the ghc webpage, linked above.
03:01:56 <donri> bbl
03:03:47 <vamega_> ah I see
03:03:49 <vamega_> Sorry
03:03:53 <vamega_> I had just gone to haskell.org
03:03:58 <vamega_> and hit the download haskell link
03:04:08 <vamega_> I'll do this later.
03:04:08 <shachaf> "download haskell" :-(
03:04:15 <vamega_> It's almost 6:00 am in the morning.
03:04:18 <shachaf> arkeet should fix it.
03:04:31 <vamega_> I should probably go  to sleep
03:04:57 <arkeet> I don't have the ability to fix it.
03:05:22 <shachaf> arkeet: Please become SPJ and then fix it.
03:05:39 <arkeet> that sounds difficult.
03:06:31 <shachaf> Well, you're being difficult.
03:06:34 <shachaf> So it's a good match.
03:08:33 <jamy> hello anybody! How i can represent graph that easy move vertexes. For example if the inside is based on the lists and if you move one vertex, then no need to rebuild the entire list (like zipper list)
03:09:22 <jamy> its need for perfomance
03:11:56 <merijn> I'm a big fan of graphs as matrices
03:12:42 <arkeet> those are good.
03:12:46 <merijn> value at index i,j is the weight of the vertex from i to j, index at j,i is the weight of the vertex from j to i
03:12:56 <arkeet> oh, I was hoping incidence matrices.
03:13:00 <merijn> You can even do shortest path with just matrix multiplication!
03:13:05 <companion_cube> merijn: but matrices take a lot of memory
03:13:13 <companion_cube> so it's only worth it for dense graphs
03:13:18 <arkeet> not if you use a sparse matrix
03:13:25 <merijn> companion_cube: Sparse matrices
03:13:46 <jamy> maybe i need use monads or functors. I dont't know because i never use they
03:13:53 <arkeet> I guess adjacency matrices are often smaller.
03:13:56 <arkeet> than incidence matrices.
03:14:13 <merijn> arkeet: What's an incidence matrix?
03:14:24 <arkeet> wikipedia
03:14:34 <merijn> I know, but I'm lazy :(
03:14:48 <arkeet> i,j = 1 if edge i meets vertex j
03:14:51 <arkeet> or somtehing
03:15:26 <arkeet> so I guess incidence matrices would have no more ones than adjacency matrices.
03:15:57 <jamy> Anybody know exaple representing tree or graph on monads or functors?
03:15:59 <companion_cube> merijn: are there easy/standard ways to represent sparse matrices efficiently?
03:16:39 <merijn> companion_cube: Maybe? I'm not a matrix guy, I can ask some of my colleagues, they're working on lots of vector, matrix numeric stuff
03:16:58 <companion_cube> looks interesting anyway
03:17:12 <companion_cube> I've been using graphs as matrices recently, to represent partial orders
03:17:58 <jamy> "partial orders" - any example from world?
03:18:39 * hackagebot groundhog-th 0.3.0.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.3.0.1 (BorisLykah)
03:24:52 <vamega_> Is there a function like $
03:24:57 <vamega_> But left associative?
03:25:20 <Rembane_> > :t flip . $
03:25:22 <lambdabot>   <hint>:1:1: parse error on input `:'
03:25:26 <Rembane_> > flip . $
03:25:28 <lambdabot>   <hint>:1:8: parse error on input `$'
03:25:50 <vamega_> > flip . ($)
03:25:52 <lambdabot>   *Exception: show: No overloading for function
03:25:53 <Rembane_> > flip . ($)
03:25:54 <lambdabot>   *Exception: show: No overloading for function
03:25:55 <Rembane_> ^^
03:26:12 <vamega_> :t flip . ($)
03:26:13 <lambdabot> (a -> b -> c) -> b -> a -> c
03:26:14 <merijn> vamega_: No, but you could define
03:26:21 <jamy> in my case matricses not allowed, because the load the entire graph in memory will be very expensive
03:26:41 <merijn> vamega_: flip is not left associative $, btw
03:26:55 <merijn> eh, "flip ($)" I meant
03:27:14 <merijn> If you want "flip ($)" then I think lens defines that as &
03:27:20 <merijn> > 1 & (+1)
03:27:22 <lambdabot>   2
03:28:39 * hackagebot fclabels 1.1.6 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.6 (SebastiaanVisser)
03:34:05 <jamy> anybody heard me?
03:34:38 <no-n[2]> what was the library function that's like head $ filter ? but returns a Maybe?
03:34:47 <no-n[2]> Maybe a *
03:35:00 <Kinnison> jamy: You're asking huge questions -- try and narrow the scope and someone might be able to help
03:35:16 <supki> :t find
03:35:25 <lambdabot> (a -> Bool) -> [a] -> Maybe a
03:35:34 <no-n[2]> ah, that's it :) ty
03:37:21 <arkeet> :t \f -> msum . map f
03:37:23 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
03:37:32 <arkeet> :t \f -> msum . map (guard f)
03:37:34 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `()'
03:37:34 <lambdabot>     Expected type: a1 -> m0 a0
03:37:34 <lambdabot>       Actual type: a1 -> ()
03:37:37 <arkeet> :t \f -> msum . map (guard . f)
03:37:39 <lambdabot> MonadPlus m => (a -> Bool) -> [a] -> m ()
03:37:43 <arkeet> hmm.
03:38:09 <arkeet> :t \f -> msum . map (\x -> guard (f x) >> x)
03:38:11 <lambdabot> MonadPlus m => (m a -> Bool) -> [m a] -> m a
03:38:13 <arkeet> doh.
03:38:15 <arkeet> :t \f -> msum . map (\x -> guard (f x) >> return x)
03:38:17 <lambdabot> MonadPlus m => (a -> Bool) -> [a] -> m a
03:38:20 <jamy> I need answer - can i represent tree or graph on monads? or they quite another to?
03:38:28 <arkeet> :t \f -> Data.Foldable.asum . map (\x -> guard (f x) *> pure x)
03:38:30 <lambdabot> (MonadPlus f, Alternative f) => (a -> Bool) -> [a] -> f a
03:38:36 <arkeet> doh.
03:40:12 <arkeet> @let foo b x = if b then pure x else empty
03:40:15 <lambdabot>  Defined.
03:40:32 <arkeet> :t \f -> msum . map (\x -> foo (f x) x)
03:40:34 <lambdabot> (MonadPlus m, Alternative m) => (a -> Bool) -> [a] -> m a
03:40:39 <arkeet> :t \f -> Data.Foldable.asum . map (\x -> foo (f x) x)
03:40:41 <lambdabot> Alternative f => (a -> Bool) -> [a] -> f a
03:40:44 <arkeet> :t \f -> Data.Foldable.asum . fmap (\x -> foo (f x) x)
03:40:46 <lambdabot> (Functor t, Foldable t, Alternative f) => (a -> Bool) -> t a -> f a
03:41:13 <arkeet> :t Data.Foldable.find
03:41:14 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
03:41:30 <jamy> my goal is to make representation for graph which will be infinity length, but any vertex we can find out if needed
03:44:53 <jamy> i feel that in haskell we can do that through lazyeval/curring/etc but i have very small experience in haskell an cat theory
03:45:46 <arkeet> what does it mean to "find out" a vertex?
03:46:53 <jamy> calculate from some rulls.
03:46:59 <arkeet> calculate what?
03:47:14 <jamy> vertex props
03:47:24 <arkeet> ?
03:49:06 <eikke> does Nathan Howell hang around here?
03:49:22 <jamy> in the beginning we know one vertex, and then we can build from rulles near vertexes
03:52:24 <jamy> like a find a route in an unfamiliar city :)
03:57:03 <jamy> my target is almost the same as find route in city via graph, but i not found examples for this algorithm in haskell
03:57:32 <pettter> so Dijkstras?
04:00:02 <jamy> but in my job also need possibility for moveing vertexes
04:01:05 <vamega_> Hmm, using a binary of ghc-7.6.2 is going poorly
04:01:14 <vamega_> First thing I tried to do was use cabal-dev
04:01:25 <vamega_> And I was unable to build that
04:01:49 <arkeet> can you give a bit more detail?
04:02:00 <vamega_> Yes
04:02:05 <vamega_> Let me see what it said above
04:02:17 <vamega_> at the bottom it said BuildFailure 1
04:02:49 <supki> @hpaste
04:02:49 <lambdabot> Haskell pastebin: http://hpaste.org/
04:02:58 <supki> vamega_: paste the build log
04:03:03 <vamega_> Found it
04:03:08 <vamega_> I don't have the zlib headers
04:03:15 <vamega_> trying again
04:03:59 <vamega_> or the gmp headers as evidenced by my second attempt
04:04:23 <jamy> in imperative dynamic languages i know how this realize (on side effects and mutable data) but there i cant
04:06:26 <vamega_> alright, that fixed it.
04:06:36 <blueonyx> jamy: maybe look at mutable arrays: http://www.haskell.org/haskellwiki/Arrays
04:06:43 <vamega_> is there a reason to use hsenv over cabal-dev or the other way around?
04:08:00 * merijn uses neither, tbh
04:08:25 <jamy> no way! one more time - graph is potentionally infinity of length so i need lazy data structures
04:08:54 <merijn> I think you want a graph zipper for mutable infinite graphs
04:09:48 <jamy> merjin: intresting
04:10:50 <merijn> jamy: See http://en.wikibooks.org/wiki/Haskell/Zippers
04:15:29 <jamy> but i have one more idea, which is based on that: in the beginning we have gragh then i instead of mutable him, collect transformation states of him
04:17:06 <jamy> merjin: how you think?
04:19:09 <Rogach> Hello! I have a problem installing "interpolatedstring-qq" package (it fails with compile error 'Couldn't match expected type `QuasiQuoter' with actual type `(String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter'). How do I debug it?
04:24:13 <jkramer> Ahoy
04:24:46 <jkramer> I'm experimenting with par/pseq and I'm not sure if I'm doing it right. http://dpaste.com/1064743/
04:25:40 <hpc> jkramer: that's the right way to do it
04:25:46 <jkramer> For some reason, when running the program with -RTS -N? it doesn't finish faster. Also time indicates that 99% CPU was used, but I'd except something >100% if multiple cores were used
04:26:10 <jkramer> *faster than without -N that is
04:26:10 <hpc> (evaluate highPrime and highFib at the same time) then (evaluate their sum)
04:26:41 <jkramer> Yes, but are the compile and runtime options correct? How can I check if it actually ran them in parallel?
04:27:38 <hpc> try -N2
04:28:11 <hpc> iirc, on not-new ghc, -N just says "use one thread"
04:28:25 <jkramer> I did, it takes almost exactly the same time as -N1
04:28:42 <jkramer> Actually a tiny bit more
04:28:52 <hpc> what are the timescales involved?
04:29:01 <hpc> is it a microsecond off 5 seconds, 100 seconds?
04:29:30 <hpc> also, is Data.Numbers.Primes pure haskell?
04:29:30 <jkramer> N1 was 6.192, N2 is between 6.197 and 6.206 (seconds)
04:29:54 <hpc> hmm
04:30:03 <jkramer> I would think so: http://hackage.haskell.org/packages/archive/primes/0.1.1/doc/html/Data-Numbers-Primes.html
04:30:12 <hpc> time highPrime and highFib individually
04:30:26 <hpc> ooh
04:31:32 <t7> what is the highest prime under (2^256 - 1)?
04:31:42 <jkramer> highPrime takes about 3.288-3.296 and highFib 2.976-2.982
04:32:03 <t7> @hoogle isPrime
04:32:03 <lambdabot> No results found
04:33:09 <hpc> hmm
04:33:49 <hpc> i am out of ideas
04:35:30 <supki> I think it's +RTS not -RTS ?
04:36:13 <hpc> lol
04:36:45 <hpc> reminds me of https://dl.dropboxusercontent.com/u/37707/IMG_20130226_102443.jpg
04:39:18 <vamega_> Hi
04:39:29 <vamega_> why doesn't fold' (*) 1
04:39:37 <jkramer> supki: +RTS is the parameter for ghc, for the runtime it's -RTS
04:39:48 <vamega_> get read as foldl' (1*)
04:40:05 <vamega_> i.e, why is the function there not applied to the parameter?
04:40:31 <jkramer> Wait a second
04:40:32 <jkramer> lol
04:40:33 <hpc> vamega_: because it's parsed as ((foldl' (*)) 1)
04:40:44 <hpc> or if we replace the infix operator
04:40:45 <jkramer> supki: You're right, it's +RTS at runtime
04:40:51 <hpc> ((foldl' multiply) 1)
04:41:04 <supki> Rogach: that looks like Quasiquoter takes 2 more parameters that are passed
04:41:10 <jkramer> Not sure but -RTS does, but probably the opposite of +RTS, which would mean it diesables multithreading :D
04:41:16 <vamega_> is * defined to be infixl?
04:41:28 <hpc> only if you use it infix
04:41:42 <jkramer> Now the whole computation takes 3.823s, awesome :)
04:41:44 <jkramer> Thanks a bunch
04:41:45 <hpc> surrounding parens like that make it parse like any other identifier
04:41:58 <hpc> specifically for situations like what you describe
04:43:11 <vamega_> isn't function application right associative
04:43:16 <vamega_> so f g x
04:43:26 <vamega_> is f (g (x))
04:43:32 <supki> f g x = (f g) x
04:43:42 <supki> in Haskell that is
04:43:47 <hpc> function application is left-associative
04:43:59 <hpc> the (->) type operator is right-associative
04:44:04 <hpc> f g x = (f g) x
04:44:13 <hpc> f :: a -> (b -> c)
04:44:50 <hpc> i suggest reading up on the syntax and possibly reading some code
04:44:52 <hpc> @where lyah
04:44:52 <lambdabot> http://www.learnyouahaskell.com/
04:45:02 <vamega_> Oh I've been reading that
04:45:11 <vamega_> in fact I'm at the chapter on monads right now.
04:45:22 <vamega_> I've also been doing a whole bunch of reading on the school of haskell
04:45:37 <vamega_> but the language grammar has had me confused for a long time.
04:45:42 <hpc> if you feel like ripping off the bandaid entirely, there's also the haskell report
04:45:59 <vamega_> I've referred to it to look at how things are implemented
04:46:00 <hpc> which is fairly readable once you have a bit of intuition about the language
04:46:35 <vamega_> no, I'm just trying to put together how the $ operator works along with function application
04:46:47 <neutrino> hi
04:46:54 <neutrino> what is the difference between a future and a callback?
04:47:36 <vamega_> Neutrino: a future is a value that will be computed at some point in the future
04:48:19 <vamega_> attempting to use that value will block until that value is available.
04:49:32 <vamega_> A callback is a function f that is passed to another function f1.
04:49:46 <vamega_> which f1 can call upon some conditions.
04:50:15 <vamega_> AFAIK, that's the general difference. I don't know if there is a special meaning to those terms in Haskell.
04:50:31 <typoclass> vamega_: the trick about $ is the line "infixr 0  $". it binds very loosely. the other function application (" ") binds very tightly
04:51:14 <neutrino> vamega_: given haskell's lazy nature, could futures be implemented transparently to have the same types as what they replace, using unsafeperformio etc?
04:52:49 <typoclass> neutrino: i guess in a way, we have that anyway :-) "let x = someExpensiveComputation ; ... pass x around ... ; print x" will block until the expensive computation is done
05:09:02 <vamega_> typoclass
05:09:21 <vamega_> I'm afraid that even after a few minutes analysing what you've said
05:09:28 <vamega_> I'm not able to grasp the concept fully
05:09:48 <vamega_> Any chance you could explain that a little better?
05:09:49 <typoclass> vamega_: don't worry :)
05:10:00 <vamega_> i.e, in a more concrete fasion.
05:10:15 <vamega_> I'm certain I've understood function application.
05:10:35 <vamega_> And I'm mostly sure I understand the $ operator
05:10:49 <vamega_> it's a left associative function
05:11:01 <vamega_> that is simply an alias for function application?
05:11:12 <vamega_> so f $ a = f a
05:11:43 <kranius> :t ($)
05:11:45 <lambdabot> (a -> b) -> a -> b
05:11:54 <vamega_> Yes
05:12:00 <vamega_> I did that too
05:12:16 <vamega_> what I'm trying to understand
05:12:25 <vamega_> is how foldl' (+) 1
05:12:54 <vamega_> does not apply 1 to the + function that is right before it
05:12:56 <typoclass> vamega_: "f x y" will group as "(f x) y". but if you want it differently, you'll have to do "f (x y)". (suppose x is pred, and y is 42.) now, to save a little on parens, there's $, which will let you write "f $ x y" instead of "f (x y)"
05:13:28 <vamega_> whereas + double x 2
05:13:32 <vamega_> generates an error
05:13:39 <arkeet> it's (foldl' (+)) 1
05:13:43 * hackagebot Plot-ho-matic 0.1.0.0 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.1.0.0 (GregHorn)
05:13:45 <vamega_> where double  = (2*)
05:14:16 <tdammers> > let double = (2 *)
05:14:17 <lambdabot>   not an expression: `let double = (2 *)'
05:14:27 <tdammers> > let double = (2 *) in double 4
05:14:29 <lambdabot>   8
05:14:53 <tdammers> I don't really understand what `+ double x 2` is even supposed to mean
05:14:58 <tdammers> anyway
05:15:05 <tdammers> suppose you have add x y = x + y
05:15:10 <typoclass> vamega_: well, a problem with that is that "+ double x 2" is missing something on the left side of "+". you have a chance if it was "123 + double x 2", and if double was a 2-argument function (not a 1-argument function like (2*))
05:15:23 <tdammers> and then you say add 2 3
05:15:26 <tdammers> like this:
05:15:33 <tdammers> > let add x y = x + y in add 2 3
05:15:35 <lambdabot>   5
05:15:50 <tdammers> then 3 is not applied to 2
05:15:54 <vamega_> sorry
05:15:59 <vamega_> that was a typo on my party
05:16:05 <tdammers> it's (add 2) 3, not add (2 3)
05:16:34 <tdammers> and for exactly the same reason, foldl' (+) 1 is (foldl' (+)) 1, not foldl' ((+) 1)
05:17:08 <tdammers> just substitute add -> foldl', 2 -> (+), 3 -> 1
05:17:23 <vamega_>  (+) double x 2 - This parses as (((+) double x) 2)) correct?
05:17:58 <tdammers> ((((+) double) x) 2)
05:18:13 <tdammers> but yes
05:18:17 <vamega_> sorry
05:18:21 <typoclass> vamega_: yes almost, you only missed one parens :-)
05:18:32 <vamega_> I meant what you said.
05:18:37 <tdammers> :D
05:18:39 <vamega_> My typing is worse than usual.
05:18:45 <vamega_> Alright, I think I've understood this.
05:19:05 <vamega_> Would you explain the loose binding statement again.
05:19:11 <vamega_> I'm just not sure where that ties in.
05:19:21 <vamega_> I think I've got a handle on the rest of it.
05:19:34 <tdammers> you know how multiplication binds tighter than addition?
05:19:40 <typoclass> vamega_: the problem with "((+) double) ..." is that you're giving a 1-argument function to (+). that doesn't work (unless you do trickery and know exactly what you're doing)
05:19:49 <tdammers> so 1 + 2 * 3 is 1 + (2 * 3), not (1 + 2) * 3
05:20:11 <vamega_> yes
05:20:13 <tdammers> well, function application binds tighter than anything else
05:20:26 <tdammers> so 1 + f x is 1 + (f x), not (1 + f) x
05:20:36 <tdammers> $, however, binds very loosely
05:20:47 <tdammers> so 1 + f $ x is (1 + f) x
05:21:21 <tdammers> it becomes even more useful when dealing with nested function calls
05:21:32 <vamega_> just hold on for a second
05:21:37 <vamega_> Let me try and digest this.
05:22:09 <vamega_> now if you'll excuse what might appear to be a naive question
05:22:25 <vamega_> Do infix expressions not count as function application?
05:22:36 <tdammers> yes and no
05:22:49 <vamega_> so shouldn't 1 + f bind tight
05:22:59 <tdammers> semantically, they are function applications, but syntactically they're different
05:23:02 <vamega_> and 1 + f x be (1 + f) x
05:23:32 <vamega_> tdammers - yes, so what are the consequences of the syntactic differences
05:23:42 <typoclass> vamega_: yes they count as function application, but prefix function application ("pred 42") binds very strongly always. infix function application ("3 + 7") is more differentiated; each operator does it differently
05:24:10 <vamega_> ahh, so this is where the infixr and infixl definitions come into play
05:24:22 <typoclass> vamega_: yes exactly!
05:24:43 <vamega_> the precendence there determines the priority of binding
05:24:47 <tdammers> yes
05:25:05 <vamega_> so like an RPN calculator would have a lower precendence value for +
05:25:17 <typoclass> vamega_: for "1 + f x" it boils down to -- "f x" binds very tight (cause it's prefix function application), and "... + ..." binds much weaker
05:25:28 <vamega_> than for *, the $ has a lower precendence value than function application
05:25:41 <tdammers> yep
05:26:00 <vamega_> $ is right associative correct?
05:26:19 <vamega_> so a $ b $ c = (a $ (b $ c))?
05:26:55 <merijn> vamega_: Yes
05:27:04 <vamega_> alright
05:27:06 <typoclass> vamega_: here's the definition of a few common operators, with their precedence and if they're "l" or "r" http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#line-59
05:27:08 <vamega_> great, I think I finally get it
05:27:14 <vamega_> :i ($)
05:27:22 <vamega_> :i (+)
05:27:24 <merijn> vamega_: That only works in ghci, not lambdabot
05:27:32 <vamega_> oops, didn't know that
05:27:46 <typoclass> vamega_: they're from Prelude. you can click the "source" link on the right-hand side
05:28:00 <vamega_> okay, so $ has the lowest precendence
05:28:06 <vamega_> with a value of 0
05:28:11 <vamega_> final question
05:28:41 <vamega_> for equal precendence, the binding precendes from left to right?
05:28:55 <vamega_> I'm not sure if that makes sense, I actually don't know if I know what I'm asking.
05:29:07 <merijn> vamega_: That depends on the fixity, "infixl" goes left to right, infixr goes right to left
05:29:09 <vamega_> but something around that area is my last concern
05:29:44 <vamega_> give me a moment to try and collect my thoughts on this.
05:29:49 <merijn> i.e. whether "3 |> 4 |> 5" is "(3 |> 4) |> 5" or "3 |> (4 |> 5)" depends on the fixity of |>
05:30:01 <supki> > True == True == True
05:30:02 <lambdabot>   Precedence parsing error
05:30:03 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
05:31:36 <vamega_> Hmm, I think I have a good way of expressing myself
05:31:46 <typoclass> vamega_: shoot :-)
05:32:12 <vamega_> suppose on a single line I had two functions both with a parsing precendence value of 10 (this is the highest value correct)?
05:32:13 <typoclass> merijn: i wonder if that shouldn't be called "associativity" or something like that. i mean, we say "right-associative", not "right-fixy"
05:32:41 <merijn> vamega_: 9 is the highest you can give to infix operators, prefix functions are 10
05:33:10 <typoclass> vamega_: ... then ghc will tell you that you need to put some parens in. the error message is truncated, but supki just tried to demonstrate :-)
05:33:14 <vamega_> fixity should refer to position, i.e infix, postfix, prefix. Associativity would refer to binding when parsing. I imagine.
05:33:43 * hackagebot concraft-pl 0.2.1 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.2.1 (JakubWaszczuk)
05:34:24 <merijn> vamega_: Basically, in case of doubt or when GHC complains: Add parens
05:34:25 <vamega_> Alright
05:34:47 <vamega_> That mostly covers everything.
05:34:51 <merijn> :t ( # )
05:34:52 <lambdabot> Not in scope: `#'
05:35:02 <vamega_> Thank you for that extraordinary demonstration of patience.
05:35:50 <merijn> > let ( # ) = ($); infixl 0 # in (+1) # (+2) $ 1
05:35:51 <vamega_> final question, before I return to the school of haskel.
05:35:52 <lambdabot>   Precedence parsing error
05:35:52 <lambdabot>      cannot mix `#' [infixl 0] and `GHC.Base.$' [i...
05:35:58 <typoclass> vamega_: you're welcome. please have your five-legged swamp goat ready. sacrifice day is coming up
05:36:16 <merijn> That error is essentially saying "can't mix infixl 0 and infixr 0, add parens"
05:36:38 <vamega_> merijn - thanks, I'm getting it now.
05:36:52 <vamega_> Suprisingly, the hardest problem I'm encountering with haskell
05:37:11 <vamega_> isn't monoids, or any of the typeclasses
05:37:30 <vamega_> it's been ($) and (.)
05:37:39 <merijn> vamega_: Well, it's trickky because at first glance it seems similar to what you know, while it is in fact subtly different
05:38:26 <merijn> Understanding the syntax/precedence rules of ($) and (.) trips up many new people, but once you understand the underlying syntax/rules it should clarify a lot of how things work :)
05:39:00 <merijn> (well, understanding syntax/precedence rules trips up lot of people period, it's just that ($) and (.) often make the confusion evident ;)
05:40:55 <tdammers> I think the reason why $ and . trip people up, but + and * don't, is because we've learned the precedence rules for + and * in elementary school, internalized them, then forget the formalities and apply them intuitively
05:41:09 <Taneb> Is there something like Endo but lifted to an arbitrary category floating about on Hackage anywhere?
05:41:18 <tdammers> function application, by comparison, is a much newer concept to most of us
05:42:27 <tdammers> in most other programming languages, the problem is either removed entirely (lisp) or reduced to the elementary school intuition for 99% of all cases
05:42:45 <Taneb> newtype Endo' k a = Endo' {appEndo :: k a a}; instance Semigroupoid k => Semigroup (Endo' k a) where Endo' a <> Endo' b = Endo' (a `o` b); instance Category k => Monoid (Endo' k a) where mempty = Endo' id; Endo' a `mappend` Endo b = Endo' (a . b)
05:43:46 <Taneb> Possibly instance (Category k, Groupoid k) => Group (Endo' k a) where invert (Endo' k) = Endo' (inv k)
05:58:13 <neutrino> is an actor the same thing as a reactor?
06:04:16 <luite> neutrino: it's equal and opposite :p
06:05:15 <chrisdone> dmwit: check this: https://github.com/projectured/projectured/wiki/Screenshots
06:05:37 <chrisdone> in particular this one, is cool: https://a248.e.akamai.net/camo.github.com/a7d2bc96231b50dbfcb449a3dd63756baf154c1c/687474703a2f2f7331362e706f7374696d6167652e6f72672f6b67326478637071642f6e65737465642e706e67
06:05:58 <luite> cool
06:06:06 <chrisdone> with ghc-mod we can already do the "showing types at nesting" https://dl.dropboxusercontent.com/u/62227452/Screenshots/Screenshot%20from%202013-04-16%2010%3A44%3A21.png
06:06:46 <chrisdone> but the different-nested-languages is something i'd like to try
06:16:30 <aCube> Is it a bug in the compiler when removing something from a instance's context changes the behavior of the program from "endless spinning" to "failing" (with UndecidableInstances, ...)
06:16:30 <lambdabot> aCube: You have 1 new message. '/msg lambdabot @messages' to read it.
06:17:33 <aCube> Also, it only exists in GHC 7.4 and not in GHC 7.6, so I think it is a bug? (In GHC 7.6)
06:17:41 <aCube> 7.4 I mean
06:34:04 <chrisdone> `fogus: hey, you're that guy i've seen on the twittering place
06:35:24 <`fogus> chrisdone: I'm the one who tweets the inane stuff.
06:35:45 <chrisdone> hey, some of that stuff is interesting!
06:35:50 <chrisdone> =p
06:35:56 <`fogus> Thanks!
06:36:24 <chrisdone> `fogus: that interleaving problem, did it ever make it into a book or was it just a mental exercise?
06:37:28 <`fogus> chrisdone: It didn't make it into a book no, but it might. ;-) It was a fun mental exercise for sure.  Not sure that I found an entirely satisfying answer, but I found one that worked for my purposes.
06:40:03 <`fogus> chrisdone: Actually I've been plunking around on a prog langs book for a while and think there might be a place for it there.  I think nice discussion could be had.
06:40:32 <chrisdone> `fogus: you mean some kind of deep survey of all lang approaches/features?
06:41:24 <`fogus> chrisdone: I wouldn't say deep no.  http://blog.fogus.me/2012/08/07/100-languages-in-100-weeks/
06:42:45 <`fogus> chrisdone: I have a nice chunk of an FP chapter written and planned to use Haskell, ML and (maybe) SASL for the examples.
06:44:30 <`fogus> chrisdone: BTW, how's Z coming along?
06:44:32 <chrisdone> `fogus: well even shallow would be interesting. e.g. a book that tells me how ML and Haskell and OCaml differ, or Scheme and Common Lisp or Clojure, or C and C++ and Java, or Python and Ruby, and something explaining Qi and Ur an Clean and Mercury and Prolog, how all the aforementioned are similar or different, what is notable about each one. that would be good
06:45:00 <`fogus> chrisdone: That about sums it up. :-)
06:46:26 <`fogus> chrisdone: It's a labor of love, so it might not be done until circa 2112
06:46:42 <chrisdone> `fogus: i haven't touched z for a while. i'm currently focusing my free time on making a structured editor for haskell
06:46:48 <chrisdone> lol ok
06:46:54 <ChongLi> Qi and Ur?
06:47:07 <chrisdone> ^ see? people need this book
06:47:16 <Six_> hey there, is there someone willing to help a haskell noob with just one question?
06:47:16 <ChongLi> apparently so!
06:47:26 <ChongLi> also: what about Caledon?
06:47:34 <typoclass> Six_: just ask :-)
06:47:35 <chrisdone> i've never heard of caledon =o
06:47:49 <ChongLi> http://hackage.haskell.org/package/caledon-3.2.1.0
06:47:50 <`fogus> Caledon... that's a new one for me
06:48:34 <`fogus> ChongLi: Haven't gone anywhere near the logic chapter, so anything is fair game at this point.
06:48:40 <merijn> ChongLi: Ur is a dependently typed language focussed on webdevelopment
06:48:40 <chrisdone> very cool =]
06:48:52 <ChongLi> merijn: ahhh
06:48:55 <Six_> i'm having troubles with type signatures
06:49:05 <merijn> I haven't gotten it to work yet, because I can't manage to compile milton on my mac :(
06:49:08 <Six_> i know there are variables i can use to get a whole class of types together
06:49:21 <ChongLi> I like the idea of dependent types but they kinda scare me
06:49:28 <Six_> but i have no idea how i can do something like Int -> Int -> String or Int
06:49:53 <chrisdone> Six_: example?
06:50:02 <ChongLi> I think they might be very useful in a specific context as an embedded DSL in Haskell
06:50:11 <ChongLi> I wonder if Caledon might fit that bill
06:50:15 <Six_> when an error occurs and i use the error function it should return a string
06:50:23 <Six_> but when everything works fine it should return an Int
06:50:39 <chrisdone> Six_: one approach could be to use either
06:50:41 <chrisdone> @src Either
06:50:41 <lambdabot> Source not found. You type like i drive.
06:50:53 <merijn> Six_: Sounds like you want Either
06:50:55 <chrisdone> data Either a b = Left a | Right b
06:51:16 <chrisdone> > let go 0 = Left "this is bad"; go n = Right "that's right!" in go 1
06:51:18 <lambdabot>   Right "that's right!"
06:51:23 <`fogus> ChongLi: There are plans to discuss such a thing, but I had only earmarked http://hackage.haskell.org/package/BASIC so far
06:51:23 <ChongLi> are there any other good ways of doing some logic programming embedded within Haskell?
06:51:39 <ChongLi> I mean, something a bit more powerful than the list monad :)
06:52:03 <chrisdone> ChongLi: there's the LogicT monad
06:52:05 <`fogus> ChongLi: I saw a talk on https://github.com/acfoltzer/Molog
06:52:12 <Six_> alright, i'll look into this, thanks :)
06:52:17 <merijn> :t let f x y = if x `div` y == 0 then Right x else Left "Something went wrong!" in f
06:52:18 <lambdabot> Integral b => b -> b -> Either [Char] b
06:52:24 <chrisdone> ChongLi: http://hackage.haskell.org/packages/archive/logict/0.6/doc/html/Control-Monad-Logic.html
06:52:31 <ChongLi> ahh, very good
06:52:45 <merijn> > let f x y = if x `div` y == 0 then Right x else Left "Something went wrong!" in f 10 3
06:52:45 <ChongLi> this stuff might be good to include in the book as well
06:52:47 <lambdabot>   Left "Something went wrong!"
06:52:49 <merijn> > let f x y = if x `div` y == 0 then Right x else Left "Something went wrong!" in f 10 5
06:52:51 <chrisdone> @quote oleg did it
06:52:51 <lambdabot> No quotes match. Wrong!  You cheating scum!
06:52:51 <lambdabot>   Left "Something went wrong!"
06:53:10 <merijn> hmm
06:53:20 <merijn> > let f x y = if (x `div` y) == 0 then Right x else Left "Something went wrong!" in f 10 2
06:53:21 <lambdabot>   Left "Something went wrong!"
06:53:27 <fizbin> > let f x y = if (x `div` y) == 0 then Right x else Left "Something went wrong!" in f 10 3
06:53:29 <lambdabot>   Left "Something went wrong!"
06:53:39 <merijn> > let f x y = if (x `div` y) == 0 then Right x else Left "Something went wrong!" in f 2 10
06:53:41 <lambdabot>   Right 2
06:53:44 <merijn> Ah, there we go
06:53:51 <merijn> I think I wanted mod instead of div
06:54:00 <fizbin> Oh, duh.
06:54:21 <merijn> Six_: This lets the caller use case-of to see if there was an error or not
06:54:50 <merijn> "case f 2 10 of Right x -> {- do something with x -}; Left error -> {- ?? -}"
06:55:30 <merijn> (Or better, the "Either e" monad for composing many possibly error returning functions!)
06:55:43 <Six_> why can't it be as easy as foo :: (String, Int) a => Int -> a :/
06:56:01 <merijn> Six_: How would you know whether the result was going to be String or Int?
06:56:20 <chrisdone> foo :: Int -> Either String Int  -- seems pretty easy to me?
06:56:37 <Six_> yea, now it is :P
06:56:40 <parcs> > ((-7) `div` 2, (-7) `quot` 2)
06:56:41 <lambdabot>   (-4,-3)
06:56:57 <merijn> Six_: Suppose we had your syntax, would this be a type error or not? "foo 5 + 3"?
06:57:15 <merijn> You can't know if that's a type error unless you know whether "foo 5" returns a String or an Int
06:58:04 <Six_> you're right
06:58:04 <fizbin> There's always "foo 5 >>= return . (+3)"
06:58:25 <fizbin> But I'll grant that that notation isn't so great.
06:59:35 <merijn> Six_: If you have many functions like that you can use the Either monad to combine them, the same way you'd use the Maybe monad for combining Maybe computations
06:59:50 <merijn> fizbin: Did you mean fmap? >.>
06:59:53 <fizbin> > let foo x = if (even x) then Right x else Left "Hey, that's odd!" in foo 5 >>= return . (+3)
06:59:55 <lambdabot>   Left "Hey, that's odd!"
07:00:10 <fizbin> > let foo x = if (even x) then Right x else Left "Hey, that's odd!" in foo 4 >>= return . (+3)
07:00:14 <lambdabot>   Right 7
07:00:15 <merijn> > fmap (+3) (Left "An error!")
07:00:17 <lambdabot>   Left "An error!"
07:00:23 <merijn> > fmap (+3) (Right 5)
07:00:24 <Six_> the problem was, that i haven't heard of maybe and either before
07:00:25 <lambdabot>   Right 8
07:00:34 <fizbin> Yeah, but that inverts things.
07:00:46 <fizbin> What we need is an inline "flip fmap"
07:00:53 <Six_> started like 3 days ago for college
07:00:57 <merijn> Six_: What are you using to learn Haskell?
07:01:00 <supki> :t (<&>)
07:01:02 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:01:16 <fizbin> @src (<&>)
07:01:16 <lambdabot> Source not found. :(
07:01:24 <fizbin> @hoogle (<&>)
07:01:25 <lambdabot> No results found
07:01:26 <merijn> fizbin: Control.Lens, probably :p
07:01:37 <merijn> :t Control.Lens.(<&>)
07:01:38 <fizbin> Where all the weird operators come from.
07:01:38 <lambdabot> Couldn't find qualified module.
07:01:39 <Six_> the script of my prof. and a german book for haskell
07:01:54 <merijn> Six_: Oh, then I recommend taking a look at Learn You a Haskell too
07:01:56 <merijn> @where lyah
07:01:56 <lambdabot> http://www.learnyouahaskell.com/
07:02:00 <mauke> Six_: are you using hugs or ghc?
07:02:05 <fizbin> :t (Control.Lens.<&>)
07:02:05 <Six_> ghc
07:02:06 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:02:16 <merijn> Six_: That covers a lot of things like Either and Maybe and how you'd use them
07:02:17 <fizbin> merijn: paren placement.
07:02:26 <Six_> nice, thanks a lot!
07:02:45 <Six_> so hugs is another compiler?
07:02:51 <mauke> hugs is dead
07:03:04 <merijn> Six_: Forget someone mentioned hugs, some instructors insist on using it, but it is effectively dead
07:03:21 <merijn> Six_: If your prof is using ghc that's much better
07:03:33 <fizbin> Six_: Though it's old, I still really think that "A Gentle Introduction…" is the best intro-to-haskell guide out there, and it's short enough to go through the entire thing quickly.
07:03:52 <merijn> I always thought A Gentle Introduction was...quite brutal :p
07:03:57 <merijn> @quote gentle.introduction
07:03:58 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
07:04:18 <fizbin> > let foo x = if (even x) then Right x else Left "Hey, that's odd!" in foo 5 <&> (+3)
07:04:20 <lambdabot>   Left "Hey, that's odd!"
07:04:32 <fizbin> > let foo x = if (even x) then Right x else Left "Hey, that's odd!" in foo 4 <&> (+3)
07:04:34 <lambdabot>   Right 7
07:05:19 <merijn> fizbin: As for the origin of all these weird combinators, as you can see lambdabot has lens support nowadays
07:05:30 <merijn> :t both print
07:05:31 <lambdabot> Show a => (a, a) -> IO ((), ())
07:06:19 <fizbin> merijn: Yeah, lambdabot loads lens but it kind of sucks that it still points @hoogle at a web service that knows nothing about lens.
07:07:16 <fizbin> Also, I read "A Gentle Introduction" while elsewhere getting totally lost in graduate-level algebraic geometry. Trust me, it's gentle.
07:09:09 <merijn> That just means you have a high tolerance for pain :p
07:09:57 <ChongLi> I think "A Gentle Introduction" is rather nice
07:10:04 <ChongLi> but not as an introduction
07:10:14 <ChongLi> it's good to read after you've gone through LYAH and RWH
07:11:41 <Roshan> hello,
07:11:51 <ChongLi> ROSHAN HAS FALLEN TO THE DIRE!
07:12:02 <Roshan> is + an operator or a function?
07:12:07 <Kaidelong> yes
07:12:07 <fizbin> Yes.
07:12:10 <ChongLi> hahaha
07:12:34 <Roshan> what about ||
07:12:39 <Kaidelong> @type (||)
07:12:41 <lambdabot> Bool -> Bool -> Bool
07:12:42 <fizbin> Roshan: Which is to say, the distinction you're asking about doesn't exist in haskell.
07:12:44 <hiptobecubic> ChongLi, maybe you meant xor?
07:12:44 <mauke> Roshan: what's the difference?
07:12:45 <typoclass> Roshan: it's both. if a function has a name that consists only of symbols, then it's infix (i.e. written between the two arguments)
07:12:57 <Kaidelong> unless you surround it in parens
07:13:00 <Kaidelong> then it is prefix
07:13:01 <ChongLi> hiptobecubic: xor?
07:13:07 <fizbin> > (+) 4 5
07:13:08 <lambdabot>   9
07:13:13 <typoclass> Kaidelong: yes. "by default"
07:13:38 <merijn> > 1 `elem` [1..10]
07:13:39 <lambdabot>   True
07:13:42 <fizbin> > (||) (4 == 5) (1 > 0)
07:13:43 <lambdabot>   True
07:13:49 <hiptobecubic> there is a distinction though
07:14:09 <hiptobecubic> but only with regards to which fixity is the default
07:14:19 <Roshan> so, can i made a function infix??
07:14:28 <Kaidelong> yes, surround it with backticks
07:14:39 <Kaidelong> people often use it as a shorthand for flip too
07:14:40 <typoclass> Roshan: the way to override the default behavior is: to make a prefix function infix, surround with `backticks` as merijn demonstrated. to make an infix function (= operator) prefix, surround with parens as fizbin demonstrated
07:14:47 <hiptobecubic> things with operator names are infix unless surrounded by parens, everything else isn't inless surrounded by backticks
07:14:50 <chrisdone> in haskell "operator" means "funny symbols"
07:14:52 <Kaidelong> like instead of "flip f a" they'll write (`f` a)
07:15:05 <fizbin> Can you declare fixity with infixl for names that aren't all symbols?
07:15:12 <chrisdone> yeah
07:15:13 <Kaidelong> yes
07:15:25 <chrisdone> infixl `blah` 2 or w/e
07:15:32 <merijn> fizbin: I think you need to use backquotes when you do, though
07:15:43 <Roshan> good .. @ChongLi what dire?
07:15:44 <merijn> See chrisdone's example
07:16:08 <Roshan> i got that ..i just re-read Real world haskell
07:16:55 <Sixstix> now it's giving me a weird parse error^^'
07:17:08 <fizbin> "it"?
07:17:22 <typoclass> Sixstix: could you paste the code and the error message on hpaste.org?
07:17:22 <ChongLi> Roshan: oh, it's from the game DotA
07:18:36 <Roshan> can u explain  me more about that  ...  ExampleTypeClass m s ...
07:19:13 <Roshan> it means ETC has two type parameter .. then what is that (ETC m) s ..
07:19:43 <hpaste> Six pasted “Program” at http://hpaste.org/86129
07:21:09 <fizbin> If ExampleType has two parameters, that is, if it is a type constructor with two parameters, then "ExampleType m" is a type constructor with one parameter.
07:21:57 <fizbin> E.g. "Either" is a type constructor. Give it two parameter - "Either String Int" - and you have a type. "Either String" is a type constructor that needs one parameter to give you a type.
07:22:11 <Roshan> is class M ==> ETC m s          same as          class m --> (ETC m) s ??
07:23:36 <fizbin> Yes, just as (f a b) is the same as ((f a) b)
07:24:15 <fizbin> You might use the extra parens if you were explaining something to someone, but the compiler doesn't need them.
07:24:52 <Sixstix> pasted it here: http://hpaste.org/86129
07:25:16 <fizbin> Sixstix: First off, what's that "error" variable in the last line?
07:25:50 <fizbin> Sixstix: Second, I think you want parens in line 4: Right (rec 1 1)
07:26:33 <mm_freak> if i have a top-level IORef and put something into it, that thing shouldn't be garbage-collected even if i never otherwise use the IORef, right?
07:26:52 <mm_freak> (or MVar or …)
07:27:33 <Sixstix> isn't error a build in function which raises an error and returns a string?
07:27:36 <fizbin> Sixstix: To be clear, I think you mean line 14 to begin with "   | True = Left (show value " - that is, delete the word "error"
07:27:48 <fizbin> :t error
07:27:50 <lambdabot> [Char] -> a
07:29:00 <fizbin> If you're returning an Either that is supposed to be Right (the value you want) or Left (some error message), then you don't want to use the function "error".
07:29:29 <fizbin> Even if you did wish to use error, you'd want extra parens or a $ over what you have there.
07:30:53 <Sixstix> even with deleting the error it won't work
07:31:00 <Sixstix> still the same parse error
07:31:23 <Sixstix>   | True = Left (show value ++ " ist kein Element von {1, 2, 3}")
07:31:31 <Sixstix>    Right (rec 1 1) where
07:31:39 <Sixstix> is how both lines look like now
07:33:04 <Sixstix> had this error appear in other lines before, indenting fixed it
07:33:06 <Roshan> @ fizbin thank you
07:33:19 <Sixstix> maybe I shouldn't work with editor...
07:35:05 <merijn> mm_freak: It might be if the IORef gets GCed
07:40:03 <Sixstix> is there an ide anyone here can recommend?
07:40:31 <Cale> vim and ghci
07:40:50 <mauke> linux
07:40:56 <adimit> emacs.
07:41:55 <merijn> Sixstix: Most people don't really use an IDE, the usual favorites are vim and emacs, there's some sublime fans too, I think
07:41:57 <Cale> Sixstix: Basically, pick your favourite text editor -- anything is fine as long as it can convert tabs to spaces automatically, and open it alongside ghci
07:42:12 <merijn> Sixstix: Eclipse FP and Yi are more IDE's, but I don't think they're all that popular
07:42:15 <Cale> and then whenever you save your program, tap :r in ghci
07:42:24 <Cale> and it'll typecheck it and let you try out expressions
07:42:44 <Cale> and you can ask for the types of various terms and so on
07:43:01 <ethercrow> yi is not closer to IDE than vim
07:43:16 <adimit> what's up with leksah? has it been progressing recently (not that I'd ever use anything to write code that doesn't have modal editing.)
07:43:51 <ethercrow> adimit: btw yi has modal editing
07:43:55 <gienah> adimit: leksah looks nice, its difficult to compile at the moment since it wants darcs gtk2hs with gtk3
07:44:21 <adimit> ethercrow: I know, I was briefly involved with it years ago.
07:44:29 <merijn> oh, maybe I ment leksah
07:44:43 <adimit> it has vim & emacs modes, and a cua mode. well, it had back then.
07:45:23 <ethercrow> the only thing that changed is that it has two vim modes now
07:45:27 <adimit> gienah: ew. compiling gtk2hs last time I did took me way too long.
07:45:36 <hiptobecubic> everything takes way to long
07:45:39 <hiptobecubic> too*
07:46:21 <gienah> adimit: there are hints here: https://github.com/leksah/leksah/blob/master/.travis.yml
07:47:26 <gienah> (with the gentoo-haskell overlay its: emerge -av =app-editors/leksah-9999 )
07:47:52 <adimit> gentoo. Another thing that takes way too long :-P
07:47:58 <fizbin> Sixstix: I use emacs with haskell-mode.
07:48:30 <gienah> adimit: well there is sabayon.org (a binary distro using gentoo as a meta-distro)
07:51:48 <adimit> there's lots of distros :-)
07:52:22 <armlesshobo> fizbin: would you know how it compares to using vim?
07:52:56 <fizbin> The way I use it, it's essentially identical.
07:53:19 <adimit> armlesshobo: like a bicycle to unicycle — if you ask me.
07:54:14 <adimit> I'm seriously considering ditching vim in favor of emacs over haskell-mode, integrated repls and better latex support :-|
07:54:18 <fizbin> I mainly prefer emacs because my workflow is very much to have multiple terminal windows open with a ghci session in at least two, and others to look at files, run ghc, etc., and I'm frequently using "emacsclient -n file…" to load some file up in emacs.
07:54:38 <dmwit> chrisdone: Really cool.
07:55:33 <fizbin> emacsclient -n is really the kicker - I like being able to have an emacs session open with multiple buffers and, from the command line, say "emacs, also go open a buffer with this file".
07:57:24 <hiptobecubic> adimit, what are the complaints about latex support?
07:59:48 <adimit> hiptobecubic: there's none? That old latex-suite or so is unmaintained. There's some new thing that I didn't like at all. Citing stuff sensibly is awful, and lhs+LaTeX mode is virtually impossible. Nevermind the awesome features of emacs' reftex and acutex, and its integration with org files.
08:00:36 <mm_freak> fizbin: is there a way to use emacsd such that when a client goes away, all its file buffers are killed?
08:00:55 <hiptobecubic> lhs is hopeless for certain. I can't say I've had any trouble at all with latex-suite despite it being old.
08:01:13 <hiptobecubic> I don't know what kind of crazy features are in acutex or reftex
08:01:29 <hiptobecubic> you mean auctex?
08:01:48 <hiptobecubic> I also haven't used that either, mind you.
08:01:52 <adimit> hiptobecubic: I find it totally un-vimmy. lot's of insert-mode shenanigans, which totally pissed me off (I much prefer snippets.) I also got lots of frequent bugs with it, where it'd spew a screenful of red fonts at me.
08:01:55 <adimit> auctex, yeah.
08:02:19 <adimit> I'm just starting to use them. LHS mode in Emacs is just *so* nice. And since I'm writing mostly academic stuff, it's important to me.
08:03:04 <hiptobecubic> are you using one of the vim bastardization modes?
08:03:22 <armlesshobo> adimit: so, one makes you look like a hipster? or a clown?
08:03:24 <adimit> hiptobecubic: one really neat thing is that I can set my cursor on a citation in my tex, org, or what have you file, and can open the pdf corresponding to the citatation at the press of a button.
08:04:00 <adimit> hiptobecubic: evil. it's the jon snow of bastardization. Except less meek, and slightly less pretty.
08:05:42 <hiptobecubic> I do have that installed actually, just never spent any time with it
08:07:24 <dolio> I think evil is still not good enough.
08:08:28 <hiptobecubic> dolio, go on?
08:09:04 <merijn> What happens if you standalone derive a typeclass X for Foo and there's also an implementation of X for Foo, will it just use the implementation or will you get a name clash type thing?
08:09:13 <dolio> Well, I don't use bare vim.
08:09:20 <dolio> So, they have like 6 plugins implemented.
08:10:36 <dolio> I don't want to re-implement a dozen or two text objects that are already done in vim, and such.
08:10:43 <dolio> Etc.
08:11:19 <adimit> yeah, that's what kept me from using it for a while. But tex and lhs, and also haskell are a pain in plain vim, compared to emacs.
08:11:25 <dolio> If there's something big that overrules all that, then yeah.
08:11:33 <adimit> also, org-mode is *sweet*
08:11:56 <adimit> (and vim doesn't have anything close to that. There's a plugin, but it's not even close.)
08:12:14 <dolio> I'm not interested in using emacs or vim for anything but editing.
08:12:24 <adimit> also, elisp is a functional language, vimL a dysfunctional one :-)
08:12:31 <adimit> yay editor wars.
08:12:47 <Kaidelong> elisp is pretty dysfunctional
08:12:57 <FireFly> VimL isn't *terrible*, but I agree that I'd rather have a lisp..
08:13:19 <Kaidelong> plenty of global state everywhere due to the design of emacs and not lexically scoped
08:13:29 <mauke> vim can be scripted in scheme
08:13:45 <dolio> VimL is kind of good (or, okay) as long as you're just writing short editing scripts.
08:14:04 <Kaidelong> lisp languages are not in general good examples of functional languages although some certainly are
08:14:32 <tromp_> some like clojure?
08:14:50 <Kaidelong> no idea about clojure, so far the most "functional" lisp I've used has been ACL2
08:15:10 <hiptobecubic> vim very badly needs asynchronicity
08:15:14 <Kaidelong> which is a total language so it's kind of like agda
08:16:09 <Mortchek> Does totality have any great drawbacks?
08:16:27 <dolio> Also, one thing that annoyed me (maybe it's petty) is that one of the plugins they do implement for evil (surround) works subtly differently on various keystrokes.
08:16:39 <Kaidelong> Mortchek: it's mutually exclusive with turing completeness, for one thing
08:16:55 <Kaidelong> second any total language is either gimped or requires the user to write fancy proof
08:16:56 <Kaidelong> s
08:17:11 <Mortchek> Hmm, that is what I thought. So does a Turing machine generalize some computational model that is still useful for… computing things?
08:17:37 <coppro> Mortchek: well there's LBAs, which are still undecideable
08:17:39 <Kaidelong> all computable problems are turing machines but not all turing machines represent all computable problems
08:17:57 <dolio> You can probably work Turing-complete programs into a total language, similar to IO in Haskell.
08:18:00 <coppro> and you can weaken even further to PDAs, which are decideable
08:18:16 <Kaidelong> however you can't both make a language that only represents the computable programs and prove that it only represents the computable ones and not the uncomputable ones
08:18:37 <coppro> although you can decide, say, the Halting Problem on an LBA
08:18:37 <dolio> The issue is that that's overhead.
08:18:57 <dolio> coppro: Who can? :)
08:20:09 <coppro> dolio: it is possible to write a TM that takes an LBA and a string and tells you whether or not the LBA halts on the string
08:21:27 <FireFly> I wonder if shell languages would benefit from being total (or rather, if they'd lose anything in being total)
08:22:01 <Kaidelong> FireFly: you mean with the assumption that all programs on the system always terminate for all inputs?
08:22:26 <Kaidelong> so that only the glue itself has to be total
08:22:37 <FireFly> Yeah
08:22:55 <dolio> I don't write a lot of recursive shell scripts.
08:23:25 <Kaidelong> making a total shell would take up a lot of memory, would it be worth it?
08:23:36 <Kaidelong> well I suppose it depends on your approach
08:23:43 <dolio> But, shell usually lacks the kind of inductive data structures you'd want to do interesting recursion.
08:24:31 <Kaidelong> with DOS you use goto a lot which means you can write non terminating stuff pretty easily
08:24:57 <Kaidelong> not sure about bash, ksh, sh, csh, zsh
08:25:19 <dolio> I think a lot of the newer ones have moved toward structured programming.
08:25:25 <dolio> Although you still might use some gotos.
08:25:52 <Kaidelong> windows has wpsh now and I suppose administrators are using that now, I never made the adjustment though
08:26:19 <dolio> It's somewhat better than the normal shell if only because it has some unix-like aliases.
08:26:25 <dolio> ls for dir.
08:26:43 <dolio> I'm not really into the .net integration, though.
08:26:47 <Kaidelong> dolio: Well the whole concept was heavily inspired by the design of haskell's IO wasn't it?
08:26:53 <Kaidelong> hence typed commandlets
08:26:59 <Kaidelong> and the code name of the shell being "monad"
08:27:02 <dolio> Was it?
08:28:09 <Kaidelong> from what I remember wpsh was very innovative for the time
08:28:14 <Kaidelong> it might still be
08:28:30 <mauke> s/innovative/undocumented/
08:28:35 <FireFly> I wish they'd make use of the types to visualise data more neatly
08:28:46 <Kaidelong> mauke: Microsoft made it so undocumented is a given
08:29:06 <FireFly> Instead of just having the terminal remain a grid of characters..
08:29:07 <osfameron> wpsh is conceptually brilliant
08:29:52 <taylorgb> Microsoft always seem to forget to productize their innovative technologies. Many recognise it is technically great, but few people are quite sure what to actually do with it
08:30:03 <dolio> Kaidelong: You can hook into all kinds of .net stuff with objects, I hear. But I find that I don't care about that, and the lack of unix stuff and decent tab completion and such is way more important.
08:30:37 <Kaidelong> dolio: Mmm, wasn't wpsh extensible?
08:30:41 <Kaidelong> there might be plugins for that
08:31:17 <mauke> a decision procedure for valid wpsh input would be nice
08:33:21 <Kaidelong> I still remember the jokes about how difficult it'd be to name the "GNU Monad" without naming it "Gonad"
08:33:21 <dolio> Kaidelong: I just use cygwin zsh.
08:33:43 <ab9rf> Kaidelong: haha
08:34:42 <Kaidelong> dolio: I've actually stuck with using cmd.exe amazingly
08:34:57 <Kaidelong> I do have MSYS on here so I suppose I could use bash
08:35:28 <Kaidelong> although for most of the scripts I do unstructured DOS programming isn't really that bad at all
08:35:38 <Kaidelong> since they're so simple
08:37:36 <fryguybob> The benefit of PowerShell is it gives you access to all the windows sillyness easily and makes it easy to make robust reusable scripts.
08:38:32 <geekosaur> it reduces it to the problem of finding documentation...
08:38:40 <dolio> Yeah, I can fully believe powershell is good for scripting. Maybe even better than unix shells.
08:38:54 <dolio> I just don't think it's as good of an interactive shell.
08:39:09 <fryguybob> I've never understood the ubiquitous complaints about MS documentation, never had a problem myself.
08:40:14 <fryguybob> dolio: Indeed, but I find it significantly better then cmd.
08:40:29 <dolio> Yes, that's also true.
08:40:30 <mauke> fryguybob: where can I learn the syntx of powershell?
08:40:33 <mauke> *syntax
08:40:45 <dolio> That's a low bar, though.
08:40:55 <fryguybob> Very low.
08:41:15 <Kaidelong> dolio: I think you caught it on the head
08:41:35 <Kaidelong> powershell was adopted largely for scripting I think
08:41:37 <fryguybob> mauke: If you are looking for enough of a specification that you could recreate PowerShell on your own, I doubt it is out there.
08:41:50 <dgpratt> powershell ise is in certain ways a better shell
08:41:54 <Kaidelong> people who primarily use the shell interactively just stuck with cmd.exe
08:42:31 <mauke> fryguybob: no, just enough to know what's valid input and what isn't
08:42:38 <mauke> fryguybob: and for valid input, what it means
08:43:53 * hackagebot hakyll-agda 0.1.1 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.1 (FrancescoMazzoli)
08:46:00 <JordiGH> Does the author of LYAHFGG hang out here? I wanna shake his hand or something.
08:46:16 <Botje> @seen BONUS
08:46:16 <lambdabot> Unknown command, try @list
08:46:17 <mauke> not anymore
08:46:19 <Botje> aww
08:46:52 <Kaidelong> mauke: Really? Just as in, he hasn't been on here in forever or he announced something about losing interest?
08:47:02 <typoclass> JordiGH: haven't seen him in here for a while. but i bet he'll be glad if you drop him an email :-)
08:47:12 <Botje> his last tweet was end 2011, as well
08:47:27 <mauke> Botje: 'seen' is a preflex command
08:48:35 <JordiGH> Oh well.
08:48:41 <JordiGH> What a great book, I'm enjoying it so much.
08:48:46 <elliott> bonus and mmorrow are just collaborating on the best thing ever
08:49:02 <typoclass> JordiGH: mail address is here http://learnyouahaskell.com/faq
08:50:47 <cschneid> If I have [1,2,3] and want to get back [(1,6), (2,7), (3,8)] -- ie, add 5 to each, and make a tuple with input, and then result -- what's the simplest way to get that done?
08:51:18 <Kaidelong> map (\x -> (x,x+5))
08:51:21 <typoclass> cschneid: how about map?
08:51:40 <merijn> > map (id &&& (+5)) [1,2,3]
08:51:42 <lambdabot>   [(1,6),(2,7),(3,8)]
08:51:46 <merijn> I win :p
08:51:49 <cschneid> ok, my mind immediately goes to zip, but that wasn't quite right.
08:51:53 <ab9rf> merijn: i knew there was a way to do that
08:51:58 <ab9rf> :t (&&&)
08:51:59 <Botje> > map ((+5)`ap`(,)) [1..3]
08:52:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:52:01 <lambdabot>   Occurs check: cannot construct the infinite type:
08:52:01 <lambdabot>    a0 = b1 -> (a0 -> b0, ...
08:52:07 <typoclass> cschneid: another possibility is zip. you would feed the original list into zip, and also into map, giving its result into zip
08:52:14 <quicksilver> merijn: you don't. The winner is the one who does it with traverse and lenses.
08:52:20 <merijn> quicksilver: :(
08:52:23 <ab9rf> hehe
08:52:47 <cschneid> "hey, how do I do something fairly trivial" --> "use arrows and other stuff you haven't heard of".  Ya'll are just showing off.
08:52:56 <ab9rf> @quote fugue
08:52:57 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:52:58 <cschneid> the map solution seems right.
08:53:03 <elliott> > zip [1..] $ map (+5) [1,2,3]
08:53:05 <lambdabot>   [(1,6),(2,7),(3,8)]
08:53:06 <elliott> er.
08:53:10 <elliott> > zip (repeat 1) $ map (+5) [1,2,3]
08:53:12 <lambdabot>   [(1,6),(1,7),(1,8)]
08:53:14 <elliott> or.
08:53:33 <ab9rf> elliott: you have to produce the list twice for that, sloppy
08:53:35 <typoclass> > (\x -> zip x $ map (+5) x) [1,2,3] -- cschneid
08:53:35 <elliott> > getZipList $ (,) <$> pure 1 <*> ((+5) <$> ZipList [1,2,3])
08:53:37 <lambdabot>   [(1,6),(2,7),(3,8)]
08:53:38 <lambdabot>   can't find file: L.hs
08:53:39 <merijn> cschneid: To be fair I thought mine was pretty ok :<
08:53:47 <ab9rf> i like merijn's
08:53:49 <merijn> :t (&&&) `asAppliedTo` id
08:53:50 <elliott> ab9rf: mine is about equally as efficient given laziness
08:53:50 <lambdabot> (c -> c) -> (c -> c') -> c -> (c, c')
08:53:57 <elliott> small constant factor difference at most
08:54:00 <cschneid> I don't know what &&& does. And the name is not too revealing :)
08:54:01 <typoclass> cschneid: there's a way to write this with <*>, but i think that's unnecessary for beginners ^^
08:54:08 <elliott> cschneid: (f &&& g) x = (f x, g x)
08:54:11 <ab9rf> elliott: yeah, but if i want to change it to run on [2,4...] i have to change it in two places
08:54:26 <elliott> oh wait
08:54:29 <merijn> lambdabot: Look at the type signature I just produced :)
08:54:29 <typoclass> cschneid: &&& applies two functions to the same argument, giving you the two results as a tuple
08:54:29 <elliott> it's actually doing a different thing
08:54:31 <merijn> eh
08:54:35 <elliott> :t zip <*> map (+5)
08:54:37 <lambdabot> Num b => [b] -> [(b, b)]
08:54:42 <elliott> > zip <*> map (+5) $ [1,2,3]
08:54:43 <merijn> cschneid: Look at the type signature I just gave you :)
08:54:44 <lambdabot>   [(1,6),(2,7),(3,8)]
08:54:47 <elliott> i win!
08:54:51 <typoclass> > (pred &&& succ) 123
08:54:52 <ab9rf> elliott: ok, that's decent
08:54:52 <lambdabot>   (122,124)
08:54:53 <merijn> cschneid: Should be pretty obvious from that :)
08:55:02 <typoclass> cschneid: ^^ here is an example for &&&
08:55:07 <elliott> p.s. just use map (\x -> (x,x+5))
08:55:19 <cschneid> yeah, the map solution is way clearer :)
08:55:20 <ab9rf> elliott: although i still like merijn's better because it doesn't rely on splitting the streams and then recombining them
08:55:43 <merijn> I like mine better than lambda's :p
08:55:43 <ab9rf> DON'T CROSS THE STREAMS
08:55:45 <elliott> well, they're shared :)
08:56:01 <Kaidelong> id&&&(5+) is fine too
08:56:02 <typoclass> ab9rf: streams are being split?
08:56:24 <typoclass> ab9rf: you mean in "\x -> (x, x+5)"?
08:57:08 <FireFly> :t (&&&) `asAppliedTo` (undefined :: a -> b)
08:57:10 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
09:01:19 <sm> urgh.. morning all. I can't believe I'm struggling with this FAQ again but... how do I convert a UTCTime to ClockTime, to bridge some old code with new libs ?
09:02:05 <sm> surely not TOD (read $ show $ utcTimeToPOSIXSeconds utc) 0
09:04:01 <sm> TOD (read $ init $ show $ utcTimeToPOSIXSeconds utc) 0 rather. Works, but what would a real programmer do ?
09:04:01 <typoclass> sm: possibly with fromIntegral or realToFrac or another general-purpose converter function
09:04:17 <typoclass> sm: (in place of "read $ show")
09:04:39 <sm> no Integral instance for NominalDifftime, alas (odd)
09:05:25 <Philonous> > do{ let Just x = Nothing; return x} -- why doesn't this parse?
09:05:26 <lambdabot>  Terminated
09:05:54 <sm> but TOD (round $ realToFrac $ utcTimeToPOSIXSeconds utc) 0 works well. Thanks typoclass
09:05:54 <mauke> Philonous: let takes a block
09:06:12 <typoclass> sm: ah ok
09:06:28 <Philonous> mauke:  Thanks
09:06:29 <typoclass> sm: i can't find your issue in here at the moment, but in general that page is useful http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html
09:08:28 <sm> thanks. Great as the time libs are, I feel we could do more to make them approachable. This page is nice
09:08:29 <typoclass> sm: in my experience, doing anything with Data.Time usually ends up being 2 simple function calls, but you have a very hard time figuring that out from the haddocks
09:08:59 <typoclass> sm: true. you're reminding me that i wanted to write some stuff about them
09:09:40 <sm> +1
09:11:13 <sm> it might be nice to have some really discoverable aToB functions for all the common time conversions in one place
09:20:27 <typoclass> sm: true
09:22:19 <jfischoff> So how does one install multiple cabal projects at once that are not in hackage?
09:22:41 <jfischoff> obviously if I am in the directory I can just do cabal install
09:23:00 <dcoutts> jfischoff: cabal install ../foo/ ../bar/
09:23:03 <dcoutts> or whatever
09:23:18 <dcoutts> or: cabal install ../libs/foo.tar.gz
09:23:19 <jfischoff> oh cool
09:23:26 <jfischoff> thanks
09:23:35 <dcoutts> or even from http urls! :-)
09:23:46 <dcoutts> (tarballs that is)
09:23:47 <jfischoff> really?
09:23:51 <dcoutts> really!
09:23:56 <jfischoff> cool
09:24:00 <dcoutts> @arr!
09:24:00 <lambdabot> Swab the deck!
09:24:24 <dcoutts> jfischoff: I added that to make it easier for people to put up test/beta versions etc
09:44:43 <parcs> is floating point addition and multiplication symmetric?
09:45:47 <klrr> anyone know a program i could write?
09:46:38 <klrr> please i got no creativity
09:46:46 <armlesshobo> klrr: write one that parses a tags file generated by ctags, and accepts queries.
09:46:53 <mauke> klrr: cat
09:47:01 <armlesshobo> the result should be all possible matches.
09:47:21 <klrr> armlesshobo: gonna consider it, mauke sounds too easy :P
09:47:28 <mauke> try it
09:47:30 <armlesshobo> step 2: allow for filtering
09:47:37 <oconnor0> parcs: no
09:50:45 <dolio> parcs: Do you mean commutative?
09:51:04 <parcs> dolio: oops, yes
09:51:14 <dolio> Yes, it is.
09:51:33 <dolio> It's commutative but not associative.
09:52:37 <parcs> oh, okay
10:02:41 <Jeanne-Kamikaze> configure: error: C preprocessor "/lib/cpp" fails sanity check <- any ideas on this ?
10:03:03 <Jeanne-Kamikaze> the ghc page suggests to remove all paths to visual studio and I have done that already but I still get that error when installing the cuda package
10:03:32 <geekosaur> there isn't a /lib/cpp on most systems these days, so something else failed somewhere before that
10:03:41 <geekosaur> (it should be using gcc -E)
10:04:19 <hpaste> Jeanne-Kamikaze pasted “cpp” at http://hpaste.org/86134
10:04:24 <Jeanne-Kamikaze> there's the full log :/
10:04:38 <c_wraith> Jeanne-Kamikaze: just to confirm, you're on windows? How are you installing it? The platform installer?
10:04:50 <Jeanne-Kamikaze> I am on windows, yes
10:04:52 <c_wraith> Oh, nevermind
10:04:56 <c_wraith> I see the command
10:04:56 <Jeanne-Kamikaze> and no, the platform is flawed
10:05:02 <Jeanne-Kamikaze> I pulled latest ghc and cabal
10:05:11 <c_wraith> One of the things the platform does on windows is install msys
10:05:19 <Jeanne-Kamikaze> oh
10:05:41 <Jeanne-Kamikaze> right, I have mingw but not msys
10:05:54 <c_wraith> You can probably make it work, but I don't know how. I'm not a windows guy.
10:06:12 <Jeanne-Kamikaze> me neither, but every linux is failing on me these days and I need to get work done
10:06:38 <Igloo> Jeanne-Kamikaze: Why is the platform flawed?
10:06:49 <Jeanne-Kamikaze> random ghc errors
10:07:04 <Jeanne-Kamikaze> ambiguous catch, ambiguous try, ambiguous everything
10:07:16 <Jeanne-Kamikaze> not to mention old packages
10:07:22 <typoclass> Jeanne-Kamikaze: there was a change about OldException with ghc 7.6
10:07:37 <Jeanne-Kamikaze> but the platform ships 7.4.2 I think, or am I mistaken ?
10:07:47 <Igloo> I don't think the latest GHC will help with the ambiguity errors
10:07:49 <Jeanne-Kamikaze> anyways, I can't remember exactly what happened, but it just didn't work
10:08:01 <Jeanne-Kamikaze> latest ghc seems to just work
10:08:29 <typoclass> Jeanne-Kamikaze: oh, you mean it's issues with Control.Exception vs. Control.OldException?
10:08:37 <typoclass> Jeanne-Kamikaze: nvm
10:08:37 <Jeanne-Kamikaze> something like that yes
10:14:46 <merijn> Jeanne-Kamikaze: New GHC exports exceptions from only one place (Control.Exception), whereas 7.4 still exports them from System and a few other places (for backward compatibility), which means that code that imports both without using qualified names breaks in older versions
10:15:46 <Jeanne-Kamikaze> merijn, and every single package that I need happens not to qualify the imports
10:16:11 <merijn> I fixed two packages I encountered, maybe fix them and submit a patch to the maintainer?
10:16:34 <Jeanne-Kamikaze> I will when I find some time
10:16:34 <merijn> All it needs is adding "Control.Exception." in front of catch/try
10:16:49 <Jeanne-Kamikaze> I tend to contribute to packages
10:21:48 <ab9rf> i tend to take things out of packages and use them, then throw them away
10:21:51 * ab9rf runs
10:28:51 <jfischoff> I'm trying to tighten the del version on a cabal file. Is there way to print out what versions of packages a cabal project is using to build?
10:29:29 <dcoutts> jfischoff: yes, use cabal configure -v
10:29:37 <jfischoff> cool thanks
10:30:00 <saml> can i write a monad tutorial?
10:31:04 * merijn thwaps saml with a rolled up newspaper
10:31:17 <saml> monad is simple
10:31:30 <saml> no i do't know what it is
10:31:49 <Taneb> A monad m is a thingy such that (a -> m b) is a category
10:32:08 <Eduard_Munteanu> Kleisli m ?
10:32:14 <Taneb> Eduard_Munteanu, yes
10:32:24 <saml> how can a -> m b be a category?
10:32:43 <Taneb> Well, newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
10:32:55 <Taneb> Consider for m = Maybe
10:32:56 <Eduard_Munteanu> instance (Monad m) => Category (Kleisli m) where ...
10:33:18 <saml> Int -> Maybe Char       is category?
10:33:27 <Taneb> No
10:33:34 <Taneb> Kleisli Maybe is a category
10:33:36 <merijn> saml: No "? -> Maybe ??" is, though
10:33:36 <Eduard_Munteanu> id = return; (.) = (<=<)
10:33:37 <Taneb> I'm a crap teacher
10:33:41 <Taneb> And I need to go nwo
10:33:47 <saml> no i dea
10:34:24 <Eduard_Munteanu> saml: Kleisli m  is a Category for any Monad m.
10:35:22 <Eduard_Munteanu> Err, my definitions above require some newtype wrapping/unwrapping.
10:37:48 <finishingmove> how can i filter elements that meet condition1 OR condition2 ?
10:38:04 <Eduard_Munteanu> :t filter
10:38:05 <lambdabot> (a -> Bool) -> [a] -> [a]
10:38:11 <Mortchek> filter (\x -> p1 x || p2 x) xs
10:38:12 <Eduard_Munteanu> :t (||)
10:38:14 <lambdabot> Bool -> Bool -> Bool
10:39:01 <finishingmove> great, thanks!
10:39:35 <dEPy> applicative functors are things that you can map over and get back partialy applies function/s ?
10:39:52 <Mortchek> dEPy, that would be true of plain old functors as well.
10:40:21 <Mortchek> Applicative lets you apply a function contained in one functor to some value contained in another.
10:40:43 <Mortchek> @type (<*>)
10:40:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:41:17 <Mortchek> It also lets you create an applicative value from a "pure" one.
10:41:19 <Mortchek> @type pure
10:41:20 <lambdabot> Applicative f => a -> f a
10:42:01 <dEPy> I guess I'll have to read that part of LYAH again :)
10:42:41 <tac_> applicative functors are weak monads
10:43:01 <dEPy> tac_ that doesn't hhelp me a bit, I'm not that far.. :)
10:43:04 <Mortchek> An example of using just Functor (not Applicative) to get what you originally said:
10:43:10 <tac_> they have return and map... and if you know ap from the Control.Monad library.... but they do *not* have (>>=)
10:43:11 <Mortchek> @type fmap (+) [1, 2, 3]
10:43:13 <lambdabot> Num a => [a -> a]
10:43:15 <tac_> dEPy: ah
10:43:30 <tac_> dEPy: don't worry *too* much about applicatives. They are cool, but I went years without really knowing about them
10:43:50 <tac_> You only really need applicatives when a library calls for it. Otherwise, using monads is more common in haskell
10:44:11 <tac_> most applicatives we use in practice are monads anyway, so you can use either style
10:44:27 <Mortchek> The main use I've got out of Applicative is the occasionally nicer way to phrase something using applicative operations rather than monadic ones
10:44:31 <Mortchek> e.g., <*
10:44:40 <S11001001> and you can compose them
10:44:53 <fizbin> And then there are the few rare Applicatives that aren't Monads.
10:45:04 <fizbin> But they're pretty rare.
10:45:52 <FireFly> How is (<*>) pronounced? (is it pronounced?)
10:46:02 <FireFly> Hm, maybe "apply" I guess
10:46:24 <dEPy> any good real life example of using <*> ?
10:46:47 <fizbin> You could pronounce it "ap" since if the Applicative is a Monad, <*> should be equal to "ap".
10:47:07 <S11001001> I like "ap"
10:47:11 <S11001001> "pizza" also works
10:47:43 <fizbin> dEPy: So I think the best way to view <*> is as a way to do all the lifting that those liftM* functions do.
10:48:02 <S11001001> ⊛
10:48:09 <dEPy> fizbin, no idea what lifting is yet. :)
10:48:11 <k00mi> dEPy: many parsing libraries use Applicative, e.g. http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html
10:48:48 <dEPy> back to books i guess
10:49:22 <FireFly> dEPy: well, "lifting" is what `fmap` does (I think, at least)
10:49:41 <c_wraith> fmap is related, yes
10:49:42 <gh__> hi, who is haskell.org's administrator for the Google Summer of Code? I'd like to contact them on behalf of the darcs project.
10:49:48 <fizbin> > (+) <$> [1,2,3] <*> [10,20,30]
10:49:50 <lambdabot>   [11,21,31,12,22,32,13,23,33]
10:50:19 <dEPy> fizbin, ok I get what that does. Guess I'm not that stupid after all :D
10:50:37 <fizbin> > let plus3 x y z = x + y + z in plus3 <$> [1,2,3] <*> [10,20,30] <*> [100,200]
10:50:39 <lambdabot>   [111,211,121,221,131,231,112,212,122,222,132,232,113,213,123,223,133,233]
10:50:50 <Mortchek> fmap f = (pure f <*>)
10:50:57 <dEPy> you get a list of partially applied functions [(+1), (+2), (+3)] and you apply them to each member of the second list?
10:50:59 <FireFly> pure (+) <*> [1,2,3] <*> [10,20,30]  might be more clear
10:51:28 <fizbin> Or even, since this is the list monad:
10:51:45 <fizbin> > [(+)] <*> [1,2,3] <*> [10,20,30]
10:51:47 <lambdabot>   [11,21,31,12,22,32,13,23,33]
10:52:41 <dEPy> Ok I get it a bit now. :)
10:52:48 <fizbin> Note that the fact you get all the combinations is just because the list applicative instance works that way.
10:52:55 <Mortchek> > [(+), (*)] <*> [1..3] <*> [1..3]
10:52:56 <lambdabot>   [2,3,4,3,4,5,4,5,6,1,2,3,2,4,6,3,6,9]
10:53:38 <dEPy> Ye I get it, if fist list would have only 1 element the result would be the same lenght as last list? (if you have only 2 lists)
10:54:04 <Mortchek> Multiply the three lengths together to find out how big the result will be
10:54:14 <fizbin> > ZipList (repeat (+)) <*> ZipList [1,2,3] <*> ZipList [10,20,30]
10:54:16 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList b0))
10:54:16 <lambdabot>    arising...
10:54:36 <fizbin> :t ZipList (repeat (+)) <*> ZipList [1,2,3] <*> ZipList [10,20,30]
10:54:37 <lambdabot> Num b => ZipList b
10:54:51 <fizbin> > ZipList (repeat (+)) <*> ZipList [1,2,3] <*> ZipList [10,20,30 :: Integer]
10:54:52 <FireFly> Don't get too hooked up on just the list functor though
10:54:52 <lambdabot>   No instance for (GHC.Show.Show
10:54:53 <lambdabot>                     (Control.Applicative.Zip...
10:54:55 <supki> @ty getZipList
10:54:56 <lambdabot> ZipList a -> [a]
10:55:21 <fizbin> > getZipList $ ZipList (repeat (+)) <*> ZipList [1,2,3] <*> ZipList [10,20,30]
10:55:23 <lambdabot>   [11,22,33]
10:55:44 <fizbin> Fine, but ZipList should have a Show instance. That's just silly for it to not have one.
10:56:04 <Mortchek> There's also The Maybe Applicative, where the failure of either the function or any argument to exist results in failure (Nothing)
10:56:04 <supki> > Identity 4
10:56:06 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity a0))
10:56:06 <lambdabot>    aris...
10:56:09 <supki> =)
10:56:24 <FireFly> @info Identity
10:56:28 <fizbin> Also a stupid lack of a Show instance.
10:56:29 <lambdabot> Identity
10:56:30 <FireFly> aw
10:56:33 <Mortchek> > Just (+) <*> Just 10 <*> Just 1
10:56:34 <lambdabot>   Just 11
10:56:37 <Mortchek> > Nothing <*> Just 10 <*> Just 1
10:56:39 <lambdabot>   Nothing
11:06:28 <FireFly> > let ($) f = runIdentity . fmap f . pure in (+2) $ 3  -- I've invented function application!
11:06:30 <lambdabot>   5
11:08:07 <monochrom> will you invent function abstraction?
11:08:10 <Mortchek> I've got one better
11:08:19 <Mortchek> > (+) `id` 10 `id` 1
11:08:21 <lambdabot>   11
11:08:25 <aCube> let ($) = id
11:08:30 <aCube> let ($) = id in 3 $ 5
11:08:35 <aCube> > let ($) = id in 3 $ 5
11:08:37 <lambdabot>   3
11:08:43 <Mortchek> aCube, o/
11:08:53 <Mortchek> We should publish a joint paper on this, clearly
11:09:21 <fizbin> > 1 2 3 4
11:09:22 <lambdabot>   1
11:09:33 <fizbin> Stupid NumInstances.
11:09:59 <FireFly> Mortchek: yeah, id's conceptually prettier
11:10:04 <fizbin> @src ($)
11:10:04 <lambdabot> f $ x = f x
11:10:57 <FireFly> > 2 <*> [1..5]  -- [2,2,2,2,2] I guess?
11:10:59 <lambdabot>   Could not deduce (GHC.Num.Num [a0 -> b])
11:10:59 <lambdabot>    arising from the ambiguity chec...
11:10:59 <fizbin> So ($) isn't technically id because its type is more restricted, but otherwise, yeah.
11:11:03 <FireFly> Hm
11:11:10 <FireFly> er
11:11:16 <FireFly> > 2 <$> [1..5]  -- [2,2,2,2,2] I guess?
11:11:18 <lambdabot>   [2,2,2,2,2]
11:11:22 <fizbin> > [2] <*> [1..5]
11:11:23 <lambdabot>   [2,2,2,2,2]
11:12:46 <Eduard_Munteanu> > (($) (const 5)) ()   -- there you go, recover 'id' up to isomorphism :)
11:12:48 <lambdabot>   5
11:13:21 <fizbin> > :t maximum
11:13:23 <lambdabot>   <hint>:1:1: parse error on input `:'
11:13:27 <fizbin> :t maximum
11:13:27 <otters> @pl \x -> (($) (const x)) ()
11:13:28 <lambdabot> id
11:13:29 <lambdabot> Ord a => [a] -> a
11:13:31 <otters> haha, no way
11:14:06 <fizbin> Huh. I had something that should be id the other day and @pl totally failed to deduce that.
11:14:12 <Eduard_Munteanu> Wow, something sensible out of @pl
11:14:31 <geekosaur> it's not the sharpest crayon in the box
11:14:51 <fizbin> @pl \x y -> ((.) ((.) (uncurry ($))) $ (,)) x y
11:14:52 <lambdabot> (uncurry id .) . (,)
11:14:59 <scooty-puff> are there any data structures that can be used with STRef?  the only thing i can think of is something like data STRefList s a = Nil | Cons {-# UNPACK #-} !(STRef s a) (STRefList s a)
11:15:13 <scooty-puff> i'm thinking of map-like structures
11:16:17 <scooty-puff> given the only instance is Eq, i assume that just leaves an associative list
11:16:25 <Eduard_Munteanu> scooty-puff: you could just use a   STRef s [a]
11:16:39 <fizbin> (That was a side lemma in the proof at http://hpaste.org/86005 that "\f x -> fmap (uncurry ($)) (liftA2 (,) f x)" is just <*> )
11:17:06 <scooty-puff> the particular use i have in mind is for, well, its very in common with: http://stackoverflow.com/questions/13609933/freezing-haskell-strefs
11:17:19 <scooty-puff> except i don't want to drag around the Fix f with the STRef's the whole time
11:18:31 <nicoo> :t liftM
11:18:32 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:18:39 <Eduard_Munteanu> scooty-puff: hm, what's that like, a doubly-linked list?
11:19:01 <fizbin> > (maximum [(+5), (*3), (*2)]) <$> [-3..3]
11:19:03 <lambdabot>   [2,3,4,5,6,7,9]
11:19:06 <scooty-puff> in that particular question, most likely - for my use, its for extracting a value after unifying
11:19:43 <Eduard_Munteanu> scooty-puff: if you need something like a doubly-linked list, consider using a zipper
11:20:33 <fizbin> Doubly-linked structures in haskell need to be fully recreated when mutated and can't share structure with what was there before.
11:20:52 <Sixstix> is there a way to tell a function which value its arguments are allowed to have?
11:20:53 <Eduard_Munteanu> No, I don't mean the tying-the-know doubly-linked list.
11:20:56 <scooty-puff> its not for a double-linked list here
11:21:04 <scooty-puff> more of a tree that contains strefs
11:21:08 <c_wraith> Sixstix: not in the type system.
11:21:15 <scooty-puff> where the strefs contain trees as well
11:21:20 <Sixstix> so instead of Int -> Int something like {1, 2, 3} -> Int?
11:21:25 <Sixstix> okay :/
11:21:47 <c_wraith> Sixstix: unless you can create a type with a sufficiently restricted range of values. Wouldn't work for that case, but it works surprisingly well in other cases.
11:21:50 <fizbin> Sixstix: No, but you can constrain a function that's of type a -> a to be of type Int -> Int.
11:22:01 <scooty-puff> i'm fine with loops - i can deal with that using mfix - the problem is detecting a loop
11:22:01 <Eduard_Munteanu> scooty-puff: ok... there are tree zippers. I'm trying to see if you really need STRefs (sometimes you do, I know).
11:22:17 <scooty-puff> hmm..
11:22:36 <c_wraith> Sixstix: for instance, you can encode the red-black invariants in the type system, such that any attempt to create an invalid red-black tree is a type error
11:22:43 <monochrom> data Mutant_tree s a = Bye | More {cell :: STRef s a, left, right :: Mutant_tree s a} ?
11:22:56 <scooty-puff> more of:
11:23:29 <Sixstix> that seems to complicated for my small problem :P
11:23:55 <c_wraith> Sixstix: yeah, it won't apply for the sort of thing you mentioned
11:24:03 <scooty-puff> data Mutant_tree s f = STRef (STRef (Mutant_tree s f) | Tree :: f (Mutant_tree s f)
11:24:07 <scooty-puff> or as i have it now anyways
11:24:22 <scooty-puff> err, data Mutant_tree s f = STRef (STRef (Mutant_tree s f) | Tree (f (Mutant_tree s f))
11:24:47 <scooty-puff> (this is very similar to unification-fd - the freezing part anyways - though i am open to other options)
11:26:12 <monochrom> ok, so the question is answered then?
11:26:50 <scooty-puff> well, the problem is that i don't know how to efficiently lookup if an STRef's tree has been frozen (to Fix f) yet
11:27:07 <scooty-puff> so it may busy loop, vs. just a structure loop
11:27:35 <monochrom> I don't understand the question. what is frozen? actually, what is lookup too?
11:27:55 <monochrom> (I really haven't heard of "lookup" for an arbitrary tree)
11:27:56 <scooty-puff> freeze :: Mutant_tree s a -> ST s (Fix f)
11:28:38 <scooty-puff> lookup :: STRef s (Mutant_tree s f) -> Map_of_some_sort_maybe -> Maybe (Fix f)
11:30:11 <monochrom> that lookup looks either unsafe or trivial (always answers Nothing)
11:35:01 <hpaste> scooty-puff pasted “STMap” at http://hpaste.org/86139
11:35:58 <scooty-puff> monochrom: for an STMap (STRef s a) (Fix f)
11:37:16 <scooty-puff> the lookup doesn't really have to do with the tree - other than to deal with cycles
11:37:36 <scooty-puff> would probably be better called a graph for that matter..
11:38:50 <hpaste> keep_learning pasted “Error in type” at http://hpaste.org/86140
11:39:02 <keep_learning> Hello all
11:39:24 <keep_learning> Could some one please tell me why this code is giving error.
11:39:32 <keep_learning> http://hpaste.org/86140
11:39:46 <geekosaur> why would you expect that to work?
11:39:52 <keep_learning> I am trying to remember the initial and final state.
11:40:04 <geekosaur> those are values, not types
11:40:06 <keep_learning> geekosaur, I am bit confused with type declaration
11:40:20 <keep_learning> geekosaur, Ops
11:40:42 <keep_learning> geekosaur, Thank you!
11:41:19 <scooty-puff> i'll have the whle thing posted in a second
11:44:37 <gilligan_> evening
11:46:27 <hpaste> scooty-puff pasted “unification - freeze” at http://hpaste.org/86142
11:46:52 <scooty-puff> the "freeze = undefined" is near the bottom - i will annotate it will a few bad versions
11:47:32 <scooty-puff> (the two bad versions: no sharing, inefficient sharing)
11:51:25 <otters> a 157 day streak, nice
11:52:36 <jfischoff> what is the status of cabal's builtin sandboxing?
11:52:50 <dcoutts> jfischoff: it's in the git repo
11:53:16 <jfischoff> dcoutts: how does it compare to hsenv or cabal-dev?
11:53:26 <dcoutts> better obviously ;-)
11:53:29 <jfischoff> haha
11:53:29 <Eduard_Munteanu> otters: a streak of...?
11:53:59 <dcoutts> jfischoff: it's similar to cabal-dev, but because we're doing it inside cabal we can do some things better
11:54:27 <dcoutts> jfischoff: in particular cabal-dev can only take static snapshots of local source packages
11:54:28 <otters> Eduard_Munteanu: commits, sorry, I was reading #haskell-lens
11:54:34 <otters> merged buffers will be the death of me
11:54:38 <Eduard_Munteanu> Ah.
11:54:42 <jfischoff> right, hsenv is going more. Also cabal-dev is a total pain. I've given up on it
11:54:58 <dcoutts> jfischoff: "going more"?
11:55:10 <jfischoff> doing more :p
11:55:22 <dcoutts> is it? I thought hsenv did even less
11:55:28 <dcoutts> is/does
11:55:29 <aristid> dcoutts: does the native cabal sandboxing have cabal ghci? :D
11:55:47 <dcoutts> aristid: no not yet, that's orthogonal, but useful together
11:55:50 <danharaj> edwardk: Is everyone safe and sound up and around at cambridge?
11:55:55 <jfischoff> well it makes copies of the whole tool chain binaries I think
11:56:01 <rmunroe> danharaj: yeah, though locked down.
11:56:16 <danharaj> rmunroe: good to hear. My heart goes out to all of boston.
11:56:37 <dcoutts> jfischoff: oh right ok, but it doesn't do things like helping you with multiple local source packages
11:56:46 <jfischoff> no
11:57:45 <edwardk> danharaj: yeah
11:58:32 <jfischoff> dcoutts: multiple versions of the same package? Or just interconnected packages
11:58:37 <edwardk> danharaj: they robbed the 7-11 i usually walk up to in the middle of the night and had some big shootout about 2 hours before I woke up and wandered down there.
11:58:50 <danharaj> edwardk: that is simply dreadful :(
11:59:05 * hackagebot Range 0.1.0.0 - Data structure for managing ranges  http://hackage.haskell.org/package/Range-0.1.0.0 (ThomasEding)
11:59:13 <dcoutts> jfischoff: no, just the usual situation that your project consists of a bunch of related packages, and so your source tree has several packages, and you're hacking on all of them
11:59:22 <edwardk> danharaj: and the shooting occurred right in the middle of my usual walk route in the middle of the night, etc. so its a bit close to home, but things things happen
11:59:36 <jfischoff> dcoutts: doesn't cabal already support that?
12:00:12 <dcoutts> jfischoff: yes but if you make a change in a package you have to explicitly reinstall that package and the others that depend on it
12:00:14 <edwardk> danharaj: the current standoff/what have you is at inman square and is on the other side of my old apartment that i'm currently moving from between me and the new apartment we're moving to, but both cities are baically on lockdown right now. Kind of inconveniencing my move ;)
12:00:36 <jfischoff> dcoutts: true
12:00:38 <FireFly> Bad timing :P
12:00:53 <danharaj> edwardk: Thank goodness for irc, right? :) I hope life can return to normal for all you Cambridgites soon.
12:01:04 <dcoutts> jfischoff: what you really want is to be able to say "these three local src packages are in my sandbox" and then go and build any component/module in any of them and have it just do the right thing in terms of rebuilding
12:01:20 <jfischoff> right
12:01:26 <dcoutts> jfischoff: just as you would with components/modules within a single package
12:01:47 <edwardk> yeah. right now i'm at the new apartment with a potted plant, an inflatable bed, a kitchen chair and an end-table ;) i'd appreciate things settling down enough to be able to finish up before the movers get here this weekend ;)
12:01:51 <jfischoff> dcoutts: and that is addressed in repo now?
12:01:54 <dcoutts> and if you change any .cabal file, then re-run the solver and re-configure as necessary
12:02:01 <jfischoff> which I guess cabal-dev also does ...
12:02:10 <dcoutts> jfischoff: well, some of that is in
12:02:18 <jfischoff> well I don't think cabal-dev detects changes
12:02:26 <dcoutts> jfischoff: cabal dev forces you to install manually, or take src snapshots again
12:02:45 <jfischoff> yeah exactly there is no dependency management
12:02:54 <jfischoff> which is what you really want
12:03:05 <jfischoff> incremental builds based on changes etc
12:03:10 <dcoutts> jfischoff: https://github.com/haskell/cabal/pull/1256
12:03:21 <dcoutts> jfischoff: right, and that's where we want to end up
12:03:22 <danharaj> edwardk: what a convergence of circumstances. as if moving wasn't stressful enough. :P
12:03:50 <dcoutts> jfischoff: feedback/testing of the current git code would be helpful
12:04:05 <dolio> "We'll get professional movers this time and it won't be so bad."
12:04:10 <edwardk> danharaj: between this and boston haskell it was enough to cause me to break a 160 day streak on github ;)
12:04:21 <jfischoff> dcoutts: cool I take a look this weekend
12:04:26 <sm> ack >:(
12:04:29 <dcoutts> jfischoff: thanks
12:04:31 <jfischoff> dcoutts: ttyl
12:04:43 <danharaj> I wasn't aware there was any force that could stop edwardk from committing :P
12:06:23 <dolio> You should contact github and tell them there were extenuating circumstances, so they can fudge your commits back up to 78 for yesterday or something.
12:06:30 <edwardk> danharaj: it did take people with explosives , 10+ miles a day worth of walking, and boston haskell to finally get me to miss a beat ;)
12:06:57 <edwardk> dolio: well, i _can_ lie with the GIT_COMMITTER_DATE or whatever, but meh
12:07:13 <edwardk> there is no point in being proud of a metric if you have to fudge it
12:07:25 <danharaj> Don't become a politician.
12:07:26 <danharaj> ;)
12:08:00 <edwardk> its like how i've let myself slide from 5th to ~7th in the github top user list, because i can't bring myself to pad my numbers with overly simple commits
12:08:00 <edwardk> while the others in that range have just started commiting every single line of code
12:08:02 <dolio> Maybe you can take this opportunity to start spelling EDWARD.
12:08:10 <edwardk> dolio: hah
12:08:23 <edwardk> move over https://github.com/will
12:08:34 <danharaj> edwardk: to be fair, a line of haskell is probably worth a commit if it were written in Java.
12:11:55 <monochrom> I once did a tiny change of code (tiny in token count anyway, clearly not tiny in analysis and design) that decreased the theoretical time complexity from quadratic to linear, and the practical running time from unknown (but known to be at least 15 minutes) to 2 seconds.
12:12:14 <monochrom> also, it is someone else's code, not mine! :)
12:12:34 <monochrom> http://hpaste.org/85367
12:13:13 <scooty-puff> are strict fields very literally desugared to seq calls, or does the compiler use that knowledge to know it doesn't have to check if a thunk on deconstruction?
12:14:01 <dolio> scooty-puff: Both?
12:14:26 <dcoutts> scooty-puff: I'm not completely sure, but I think even strict fields can be indirection pointers (though not thunks) so there are still checks
12:15:03 <dcoutts> so e.g. looking up a !Int field still isn't just a pointer indirection and offset
12:15:09 <monochrom> in short, it's (("a"++"b")++"c") etc vs (("a"++) . ("b"++)) . ("c" ++)
12:15:25 <scooty-puff> indirection pointers more or less void** (where ideal would be void*)?
12:15:57 <dcoutts> scooty-puff: which is something augustss still teases people about, because in hbc it would be just a pointer lookup and offset
12:16:28 <dcoutts> (but I'm not 100% sure on the details there)
12:16:30 <scooty-puff> the offset being the offset into the boxed Int?
12:16:36 <dcoutts> scooty-puff: right
12:16:39 <scooty-puff> k
12:16:54 <dcoutts> scooty-puff: think of a pointer to a heap object containing an !Int field
12:20:36 <monoidal> scooty-puff: there's UNPACK pragma and -funbox-strict-fields that removes the indirection
12:25:24 <technopredator> Why oh why you had to use the freaking tilde? when the English Language doesn't; why `div` instead of just div?
12:25:59 <elliott> technopredator: because it makes the function infix
12:26:04 <monoidal> technopredator: tilde is ~
12:26:05 <elliott> (p `div` q) is (div p q)
12:26:10 <elliott> (it's actually a backtick)
12:26:25 <technopredator> I know but what¡s wrong with 9 div 5?
12:26:27 <elliott> if it was (p div q), you wouldn't be able to tell what was the function and what was the argument without knowing all the definitions in scope
12:26:36 <elliott> it would also make parsing the program more difficult
12:26:46 <elliott> (you can define your own functions to be used infix)
12:26:54 <elliott> also, how would you refer to the prefix form?
12:27:04 <monoidal> technopredator:  "f div x" - is this a call to f that passes arguments div and x, or a division of f by x?
12:27:17 <technopredator> bathroom emergency, brb
12:29:35 <monochrom> SML allows you to write "5 div 6", after declaring "infixl 5 div" or something
12:30:20 <dEPy> where can I see the definition of Applicative for list?
12:30:36 <monochrom> but I would hate to have forgotten that, write "zipwith div x y", get a strange type error, and then "oh, it has to be zipwith (op div) x y"
12:31:33 <monoidal> dEPy: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html
12:32:13 <monochrom> also, tilde is ~ , backtick is `
12:33:17 <monoidal> dEPy: monads have (<*>) defined as ap ( = liftA2 ($))
12:33:39 <dEPy> monoidal, ye that's why I have now no idea what that does :D haha
12:33:43 <dEPy> I was just curious.
12:33:49 <technopredator> Back. well if div is a reserved word or predefined function then I think that would solve the problem
12:34:32 <monoidal> dEPy: [f1, ..., fn] <*> [x1, ..., xm] = [f1 x1, ..., f1 xm, f2 x1, ..., f2 xm, fn x1, ..., fn xm]
12:34:51 <technopredator> 'f div x' would be just that if f is a function then 'f div x y'
12:35:01 <elliott> > [f,g,h] <*> [x,y,z]
12:35:05 <lambdabot>   mueval-core: Time limit exceeded
12:35:06 <elliott> > [f,g,h] <*> [x,y,z] :: [Expr]
12:35:09 <lambdabot>   [f x,f y,f z,g x,g y,g z,h x,h y,h z]
12:36:21 <technopredator> well backtick or whatever is annoying without any need IMO
12:36:28 <monoidal> dEPy: for lists, f <*> x = [g y | g <- f, y <- x]
12:36:28 <kennyd> technopredator what problem? and div is a function.
12:36:45 <monochrom> I have reserved words
12:36:50 <monochrom> err, typo
12:36:51 <kennyd> `` is a syntax for calling any prefix function as if it was infix. you don't have to use it
12:36:53 <monochrom> I hate reserved words
12:36:57 <technopredator> 9 `div` 5 I don't like it, I want it to be simply 9 div 5
12:36:58 <monoidal> technopredator: predefined is a bad idea. What about, say, elem (2 `elem` [1,2,3]), or mod?
12:37:20 <kennyd> technopredator what's wrong with div 9 5 ?
12:37:23 <dEPy> monochrom, I undestand (I think) <*>, I'm just not that far to understand lifts and monads :)
12:37:24 <monochrom> there is completely no reason to have a reserved word for an arithmetic operation.
12:37:39 <monochrom> monochrom? monoidal?
12:37:39 <kennyd> > div 9 5
12:37:41 <lambdabot>   1
12:37:44 <monoidal> technopredator: note that in haskell very little things are reserved
12:37:47 <monoidal> monochrom: yes, that was me
12:37:55 <js6i> technopredator: why dont you define e.g. (./.) = div ?
12:38:26 <monoidal> technopredator: even operators like + have no special place
12:38:35 <technopredator> I'm a newb Haskell programmer so don't know what 'elem' means, I'm reading LYAH
12:38:56 <monochrom> "arithmetic operations are reserved words" is a 1960s concept
12:39:08 <monoidal> technopredator: it's checking if something is in a list (you can think of mathematical "element of" operator)
12:39:27 <monochrom> along with line numbers and "comments must have the letter C at column 6"
12:39:42 <kennyd> technopredator div, elem etc are normal prefix functions, putting `` around them lets you call them as if they were infix functions.
12:39:55 <dEPy> what do I need to import to be able to use  Expr ?
12:40:04 <quchen> dEPy: Debug.SimpleReflect
12:40:10 <dEPy> tnx
12:40:38 <elliott> technopredator: in general, if the explanation of why something in a language doesn't make sense to you because of inexperience, then learning the language more is a good idea. then you may come to understand why it is the way it is
12:41:22 <monoidal> dEPy: If you have an applicative, you can define liftA2 f x y = f <*> x <*> y. That changes a function a -> b -> c into f a -> f b -> f c  -- effectively "lifting" it to f
12:41:40 <monoidal> whoops - f <$> x <*> y
12:41:55 <dEPy> monoidal, I think I kinda get it. :)
12:42:40 <monoidal> dEPy: for example, liftA2 (,) is rather intuitive: it has type f a -> f b -> f (a,b)
12:42:47 <technopredator> well div is simple and basic that for me is really dum to use it with backticks, it'd be like 9 `+` 5, when we all know + is so common that would be a PIA use backticks to it
12:43:11 <technopredator> why not just add div to the list of basic operands not needing backticks
12:43:37 <monoidal> technopredator: the rule is very simple - things built out of symbols do not need backticks
12:43:39 <monochrom> as I said, SML does exactly that, and I hate it, it requires more of my memory
12:44:00 <monoidal> technopredator: making a special exception for div would be extremely strange
12:44:18 <quchen> We don't have a problem with `div`. Actually, it's probably good there's `div` as a word, because otherwise I'd confuse it with `quot` division all the time.
12:44:21 <monochrom> "div is infix, but map is not. what else?"
12:44:22 <technopredator> I understand it for other function names but please, div exisat in mathematics and every programmins language out there, is not like arbitrary function name, is special, like +
12:44:28 <monoidal> technopredator: also, many things in Haskell are not that hard-wired as in other languages. You can create your own module with a div function
12:44:41 <Nisstyre-laptop> monoidal: but zomg strict evaluation, and Haskell could have undefineds anywhere and they won't get evaluated!!!
12:44:49 <monoidal> Nisstyre-laptop: ?
12:44:58 <Nisstyre-laptop> monoidal: I'm satiring Robert Harper
12:44:59 <monochrom> this is becoming a pointless bikeshed colour argument
12:45:17 <elliott> technopredator: you could easily define an infix operator // that does div.
12:45:24 <elliott> technopredator: this is not defined by the language. div is just a normal function like any other.
12:45:43 <elliott> technopredator: also, non-integer division itself has the standard / symbol.
12:45:49 <elliott> and there are two kinds of integer division (div and quot)
12:46:01 <elliott> it's not as "standard" as you might think
12:46:09 <kennyd> I think technopredator still doesn't realize that `` is not part of the div's function name
12:46:33 <monochrom> > div 50 5
12:46:35 <lambdabot>   10
12:46:41 <geekosaur> I think it's a deeper issue than that, given their `+` example
12:46:49 <dEPy> If I define an applicative functor for my (imaginary) tree structure, then 'pure' should return a provided function wrapped in tree node if I undestand correctly?
12:47:12 <monoidal> dEPy: pure should be a function that takes an element and returns a node
12:48:30 <dEPy> not sure that I get it O_o
12:48:32 <monoidal> technopredator: note that in Haskell you do not need brackets in, say, sin 5 + 3 (compared to sin(5) + 3). savings made by this really trump the fact you need sometimes backticks. if the language did not use backticks, it would be ambiguous
12:48:38 <elliott>  /last technopredator
12:48:42 <elliott> oops :)
12:48:47 * elliott wanted to see context...
12:49:23 * elliott also wonders why IRC clients don't warn when you send a message beginning with " /", it's such a common typo
12:49:59 <typoclass>  /me doesn't know
12:50:14 <monoidal> dEPy: there are two ways you can make trees an applicative (similar to two ways you can make lists an applicative)
12:50:36 <monochrom> you have a space before your /
12:51:02 <elliott> can I get monochrom in my IRC client?
12:51:23 <monochrom> yes, for cdn$1000 per minute
12:51:31 <Nisstyre-laptop> can I get monochrom in my brain?
12:51:40 <elliott> monochrom: surely worth it
12:51:42 <monoidal> dEPy: for lists, one is f <*> x = [g a | g <- f, a <- x] and the other is f <*> x = zipWith ($) f x
12:52:06 <technopredator> I loved the fact that Haskell being functional made writing and calling functions so practical, simple and smart, then it comes this backticks and screws the beauty, well, I know I'm a newbie but I have the feeling II'll never get over it
12:52:23 <elliott> how often do you do *integer* division, really?
12:52:24 <Nisstyre-laptop> technopredator: have you seen records?
12:52:32 <elliott> it's an incredibly minor thing.
12:52:38 <elliott> in Python you have to say (x // y) for it. // is ugly too
12:52:45 <sixillusion>  Is there a good framework for web development (in particular live video streaming) in haskell?
12:52:47 <technopredator> I hove it is
12:52:48 <quchen> If you're looking for ugly warts in Haskell, backticks is the wrong place.
12:52:49 <monoidal> dEPy: in the first one, we take all combinations (like [sin,cos] <*> [1,2] = [sin 1, sin 2, cos 1, cos 2]) while in the other we zip (like [sin,cos] <*> [1,2] = [sin 1, cos 2])
12:52:54 <technopredator> what records?
12:52:56 <geekosaur> technopredator clearly does not understand the concept of passing a function as a parameter
12:53:07 <elliott> technopredator: and if it really bothers you, you can write div 1 2, rather than 1 `div` 2.
12:53:10 <elliott> no backticks.
12:53:22 <t4nk630> howto zip lists with different lenghts?
12:53:22 <Nisstyre-laptop> or you can define your own operator for it
12:53:32 <elliott> t4nk630: what behaviour do you want it to have?
12:53:39 <elliott> for the additional elements
12:53:45 <monochrom> elliott, but perhaps x `elem` xs, f `fmap` m, and g `on` h will cause the same frustration again and again
12:53:46 <t4nk630> zeros
12:53:59 <dEPy> monoidal, why zipping with $  ? :)
12:54:04 <t4nk630> for in the long list
12:54:11 <technopredator> OK, give me an ambiguous use of div? I accept the challenge to disambiguating it
12:54:24 <monoidal> dEPy: those are ziplists, lists with another applicative structure
12:54:37 <elliott> technopredator: zipWith div [1,2,3] [4,5,6]
12:54:45 <leggo> are there any good refactoring tools? for example I would like to change the name of a module, or a function within some module, in all the files in some directory tree
12:54:51 <elliott> (OK, (zipWith div [1,2,3]) [4,5,6])
12:55:35 <monochrom> elliott: you should just use "x div y", and later reveal x, y depending on the answer, in fact to foil the answer
12:55:54 <technopredator> zipWidth is just a function with 2 parameters? I don't know what it is
12:56:08 <Clint> i prefer zipLength
12:57:14 <elliott> if you don't know what zipWith is, then perhaps you should accept that the ambiguity exists and will be more obvious when you learn about Haskell features like higher order functions? :)
12:57:18 <dEPy> monoidal, but zipWith ($) [sin, cos] [1, 2]  returns a list of 2 elements instead of 4 like list comprehension
12:57:26 <elliott> in particular, zipWith takes a function as its first argument.
12:57:40 <elliott> it has "3 parameters" (but actually all Haskell functions only have one parameter)
12:57:42 <monoidal> dEPy: yes, it's Applicative []. But there's also Applicative ZipList
12:57:42 <technopredator> hmm
12:58:04 <dEPy> monoidal, you lost me :D
12:58:54 <monoidal> >  getZipList (ZipList [sin,cos] <*> ZipList [1,2]) --dEPy
12:58:56 <lambdabot>   [0.8414709848078965,-0.4161468365471424]
12:59:03 <leggo> technopredator are you arguing that div should be infix or that ` syntax shouldn't exist?
13:00:23 <technopredator> I don't like the backticks
13:00:36 <technopredator> so the latter
13:00:41 <dEPy> monoidal, ah I see now, I was thinking there are two ways to do the same things
13:00:58 <dEPy> monoidal, I get it now yes
13:01:08 <sixillusion> Is haskell worth learning for web development purposes?  I'm a category theorist who wants to build a website which supports live streaming.  I'm definitely going to learn haskell later on at some point, but I'm trying to get this website up and running soon; so I'm scared I will have to pay for Adobe Flash Media Server.
13:01:13 <geekosaur> higher order functions are clearly not a thing, so they're just noise, uy'know
13:01:29 <technopredator> but OK, I'll take you guys word for now, but I'm not convinced
13:01:31 <elliott> sixillusion: haskell has several practical, mature web frameworks
13:01:33 <elliott> @where web
13:01:33 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
13:01:47 <elliott> sixillusion: whether it's worth learning haskell for a website right now... is less clear
13:01:51 <sixillusion> That's nice to know elliot
13:02:01 <elliott> if you know another language with a decent web framework, probably better to stick with that if you're under time constraints
13:02:24 <geekosaur> maybe once they've had the mental explosion that goes along with discovering the concept of higher order functions...
13:02:33 <monoidal> technopredator: Consider this. Haskell has type inference: often you don't need to write down types of your functions, although it's a good habit to write them.
13:02:36 <sixillusion> I understand.  Thanks for the help.
13:02:42 <leggo> technopredator I wouldn't mind if they didn't exist either. i dont find 50 `div` 10 more readable than div 50 10
13:02:54 <elliott> it won't really magically make things easier because of CT knowledge :) (though knowing CT will let you skip the common beginner phase that involves being convinced monads are scary, which is nice...)
13:03:34 <monoidal> technopredator: Now, let's define f x y = x div y. Should the type of this be Int -> Int -> Int (as if that was division) or ((Int -> Int -> Int) -> Int -> Int) (as if that was taking the division operator as a higher-order function)?
13:03:41 <quchen> elliott: He'll probably have the problem the other way round - monads are so easy in Haskell it's hard to imagine they're useful for him ;-)
13:03:48 <monoidal> technopredator: with this ambiguity, we lose type inference. a really powerful tool.
13:04:13 <elliott> quchen: so easy? you must be thinking of monoids
13:04:33 <ChongLi> monads are simple, not easy
13:04:36 <quchen> elliott: Nah I meant monads. Wasn't trying to make an easy monoids reference here.
13:04:40 <technopredator> leggo: they say is better for disambiguation purposes, but I'm not convinced, I think if the parser were smarter it could disambiguate it and make programming easier but at this point I'm not sure, so I can't prove that
13:04:44 <technopredator> at least not yet
13:04:53 <elliott> so easy to make so easy references unintentionally...
13:05:14 <Nisstyre-laptop> technopredator: how hard a language is for implementors is a good thing to consider
13:05:24 <leggo> technopredator there's nothing to disambiguate if you just use prefix function normally
13:05:30 <Taneb> I like snowclones of memes. They're so easy.
13:05:32 <Nisstyre-laptop> and the relative difficulty for programmers is almost nothing
13:05:54 <elliott> anyway any disambiguation would fail totally when you are trying to use a *higher-order* function infix with backticks.
13:05:55 <monochrom> the parser is smarter, but I am not.
13:06:02 <elliott> and thanks to the magic of overloading, div can be higher-order
13:06:25 <monochrom> if you write me "x y z" I don't want to recall "oh, is that y infix or not"
13:06:39 <leggo> I think his point is that `` syntax is ugly and doesn't make things more readable
13:06:47 <geekosaur> and I don't want it to depend on exact types of the things around it or whatever
13:07:02 <geekosaur> (because then, what if I actually intend the other interpretation?)
13:07:05 <technopredator> For me div is a infix by default like any other language or math. Yeah I was considering if adding disambiguation to the compiler would add a unnecessary overhead time just to check for div, making it less efficient
13:07:11 <monochrom> I am saying for the third time: SML does exactly what you say, it knows that someone declared y to be infix, it has a smart parser.
13:07:28 <elliott> technopredator: okay, seriously: there is no infix "div" operator in standard mathematical notation.
13:07:46 <elliott> "1 div 2" would not be any more standard than "1 `div` 2"
13:07:51 <technopredator> I wouldn't want that, in that case I wouldn't mid writing backticks and as someone wrote, integer divisions are rare
13:07:52 <Nisstyre-laptop> or 12 div
13:07:56 <Nisstyre-laptop> er, 1 2 div
13:08:00 <monochrom> but I say, to hell with that, I want you to write x `y` z to remind me that you're doing infix
13:08:18 <monochrom> at the end of the day, it is all about me, me, me.
13:08:20 <technopredator> well there is mod
13:08:24 <elliott> anyway this is pointless. we've been saying the same thing for about an hour.
13:08:25 <leggo> > x // y = div x y
13:08:25 <technopredator> same thing
13:08:26 <lambdabot>   <hint>:1:8: parse error on input `='
13:08:29 <elliott> technopredator: that's not really infix.
13:08:31 <quchen> You won't see mod in the middle of a line though.
13:08:38 <elliott> 1 + 2 = 0 (mod 3) or whatever.
13:08:59 <leggo> technopredator do this:  x // y = div x y  .  and then you can do  10 // 4
13:09:26 <rifki> hello, are " Eq" and "==" same things in haskell?
13:09:31 <Clint> no
13:09:51 <Eduard_Munteanu> rifki: (==) is a method of the Eq typeclass
13:09:52 <monoidal> There's div, mod, divMod, elem, notElem, compare... many functions are usually used infix. Sometimes gcd, lcm, max, min
13:10:18 <technopredator> isn't better (./.) = div?
13:10:19 <Nisstyre-laptop> monoidal: Data.Function.on
13:10:20 <monoidal> rifki: You can use x == y exactly if x,y are of type that has Eq instance
13:10:25 <rifki> thanks
13:10:27 <Nisstyre-laptop> (my personal favourite)
13:10:31 <elliott> technopredator: if you want that you can define it.
13:10:32 <elliott> and use it.
13:10:39 <leggo> technopredator maybe
13:10:56 <sixillusion> I have another question.  Is there a book or some online resource that teaches Haskell for Category Theorists (maybe even n-category theorists!)?
13:10:59 <Taneb> I sometimes use maybe infix
13:11:17 <quchen> > let (+) = div in 5 + 2
13:11:17 <sixillusion> Something based on the category whose objects are data types and morphisms are programs
13:11:19 <lambdabot>   2
13:11:23 <elliott> sixillusion: not sure. but also not sure it would make sense
13:11:39 <rifki> I want to write a special "=="  for a special data type. But I'm not sure what to do
13:11:40 <elliott> haskell kind of almost forms a category, and certainly there are classes like Functor and Monad and so on based on category theory.
13:11:45 <FireFly> I think there are more resources that teaches Category Theory for Haskellers, for sure..
13:11:53 <Eduard_Munteanu> sixillusion: there is a model of Hask, the category of Haskell types... but that's not a lot of category theory
13:11:54 <elliott> but I suspect most of the things you need to learn to actually program in Haskell are too mundane.
13:11:55 <monoidal> sixillusion: on intermediate level, you might like http://www.haskell.org/haskellwiki/Typeclassopedia
13:11:58 <elliott> and don't benefit much from a CT perspective.
13:12:14 <leggo> rifki write an Eq instance for that type
13:12:18 <quchen> rifki: Have oyu read the LYAH chapter about typeclasses? http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
13:12:24 <sixillusion> I see elliot
13:12:27 <Eduard_Munteanu> sixillusion: you might want to read edwardk's blog, he does a lot of CT stuff
13:12:35 <Eduard_Munteanu> http://comonad.com/reader/
13:12:37 <quchen> rifki: The link above explains it quite well I think.
13:12:39 <sixillusion> Thank you monoidal
13:12:42 <monoidal> rifki: you can write "instance Eq YourType where x == y = <code for comparision>"
13:12:45 <dEPy> If I wanted to write my own implementation ofr Applicative for list, what would it look like (with basic stuff no lifts and such sorcery).   pure = (: [])       is 'pure' correct? I can't figure out <*>
13:12:58 <sixillusion> Cheers, Eduard
13:13:04 <sixillusion> That's very helpful
13:13:10 <monoidal> sixillusion: also http://blog.sigfpe.com/2010/03/partial-ordering-of-some-category.html
13:13:13 <Eduard_Munteanu> sixillusion: also, we have ##categorytheory    </spam> :)
13:13:37 <rifki> thank you people, now I guess I know what to do exactly
13:13:44 <aristid> dEPy: there are two popular instances of applicative for list. you probably don't want spoiles though? your pure does correspond to one of them.
13:14:06 <dEPy> aristid, gimme few min to figure out <*> :)
13:14:11 <leggo> rifki did you define that type?
13:14:25 <rifki> leggo: yes
13:14:26 <aristid> :t liftA2 (,)
13:14:27 <leggo> rifki ie data Something = .. ?
13:14:28 <lambdabot> Applicative f => f a -> f b -> f (a, b)
13:14:44 <leggo> rifki then you can just add deriving (Eq) at the end
13:14:50 <aristid> dEPy: feel free to figure out liftA2 (,) first, maybe that's a little easier :)
13:15:04 <dEPy> aristid, I have no idea yet what lifts are :)
13:15:07 <rifki> leggo : that is forbidden,
13:15:12 <aristid> dEPy: just look at the type
13:15:25 <aristid> Applicative f => f a -> f b -> f (a, b)
13:15:31 <leggo> rifki homework?
13:15:33 <technopredator> (./.) = div this means both parameters will be floats, right?
13:15:38 <elliott> technopredator: no
13:15:38 <dEPy> aristid, that's the farthest I can think of for <*>....      x:xs <*> ys = fmap x ys : xs <*> ys
13:15:39 <rifki> leggo : yes sir
13:15:41 <elliott> > 1 / 2
13:15:44 <lambdabot>   0.5
13:15:45 <elliott> > 1 `div` 2
13:15:47 <lambdabot>   0
13:15:49 <elliott> > let (./.) = div in 1 ./. 2
13:15:51 <lambdabot>   0
13:16:05 <leggo> rifki ok then what we suggested earlier should work
13:16:14 <aristid> dEPy: does it typecheck?:)
13:16:44 <dEPy> aristid, how can I check it?
13:17:00 <monoidal> technopredator: div is used for integral types. for floats, use /
13:17:02 <aristid> dEPy: by putting it into a file, or into ghci?
13:17:21 <monochrom> @type <*>
13:17:23 <lambdabot> parse error on input `<*>'
13:17:28 <monochrom> @type (<*>)
13:17:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:17:31 <dEPy> can't check type of <*> with :T
13:17:34 <dEPy> oh
13:17:36 <dEPy> parens
13:17:46 <aristid> :t let x:xs <*> ys = fmap x ys : xs <*> ys in (<*>)
13:17:48 <lambdabot>     Precedence parsing error
13:17:48 <lambdabot>         cannot mix `:' [infixr 5] and `<*>' [infixl 9] in the same infix expression
13:17:49 <technopredator> OK, I'm lost anyway eventually I'll understand it,  right know I'll continue reading the book and what monoidal wrote above about losing type inference and elliot I take into account your advice about higher order functions
13:17:59 <aristid> :t let x:xs <*> ys = fmap x ys : (xs <*> ys) in (<*>)
13:18:01 <lambdabot>     Precedence parsing error
13:18:01 <lambdabot>         cannot mix `:' [infixr 5] and `<*>' [infixl 9] in the same infix expression
13:18:11 <aristid> :t let (x:xs) <*> ys = fmap x ys : (xs <*> ys) in (<*>)
13:18:13 <lambdabot> Functor f => [a -> b] -> f a -> [f b]
13:18:28 <dEPy> guess not :)
13:18:28 <elliott> did you want ++?
13:18:34 <technopredator> thanks for the assist
13:18:37 <monoidal> dEPy: I recommend to create a file with defn "newtype MyList x = MyList [x]" and define "instance Applicative MyList where ..."
13:18:42 <aristid> dEPy: it does typecheck. the question is if this is the right type ;)
13:19:15 <monoidal> dEPy: you need to change then your pure and (<*>) to use MyList, but that's easy
13:19:29 <rifki> for example my datatype is "something"  And I use things like (Something a xs) Should be the instance like this : instance Eq Something (Something a xs) == (Something b ys)  = <code for comparison>
13:19:50 <rifki> Something = something for this case
13:20:26 <elliott> instance Eq TheType where ... == ... = ...
13:20:33 <monoidal> rifki: you forgot "where", but otherwise correct
13:21:59 <rifki> where should "where" be? :)
13:22:09 <monoidal> instance Eq Something where (Something ...
13:23:26 <rifki> thanks a lot!
13:24:22 <dEPy> monoidal, I have no idea how to do that :)
13:25:08 <monoidal> dEPy: what exactly?
13:25:16 <monoidal> dEPy: Instead of lists, you can use a wrapper
13:25:32 <monoidal> dEPy: the point is, lists already have an instance in Control.Applicative, and you can't "hide" it
13:25:51 <dEPy> monoidal, I get that, but, here's what i came up with O_o  http://hpaste.org/86143
13:26:11 <monoidal> dEPy: but your pure ::  a -> [a] while now it should be pure :: a -> MyList a
13:26:12 <dEPy> monoidal, is it even remotely close?
13:26:31 <dEPy> monoidal, I see, so  (: MyList)
13:26:53 <monoidal> dEPy: no. (: MyList) is the same as \x -> x : MyList which is not what you want
13:27:10 <monoidal> dEPy: remember, (:) takes an *element* and a *list* and it prepends: 2:[3,4] = [2,3,4]
13:27:30 <monochrom> it may be easier to: don't create MyList, but create MyApplicative
13:27:50 <monoidal> dEPy: perhaps you can write a non-pointfree definition and then make it pointless
13:28:33 <dEPy> I'm totally confused now :)
13:28:39 <monoidal> dEPy: if you struggle with newtypes, I'd take monochrom's advice.
13:28:49 <monoidal> dEPy: remove "import Control.Applicative" and "MyList" that I suggested
13:29:11 <monoidal> dEPy: add instead "class MyApplicative f where pure :: a -> f a; (<*>) :: f (a -> b) -> f a -> f b"
13:29:26 <monoidal> dEPy: and below "instance MyApplicative [] where [fill this]"
13:29:51 <monoidal> dEPy: you want a template?
13:30:28 <dEPy> monoidal, yes please :)
13:31:17 <hpaste> monoidal pasted “template for applicative []” at http://hpaste.org/86144
13:31:31 <monoidal> dEPy: ^
13:31:38 <dEPy> tnx! :)
13:37:06 <dEPy> monoidal, something like this? http://hpaste.org/86145
13:37:54 <monoidal> dEPy: yes, correct
13:38:01 <dEPy> \o/
13:38:09 <monoidal> dEPy: that's the standard Applicative instance for lists
13:38:09 <dEPy> haven't had this much fun with programming for a while :)
13:38:31 <monoidal> dEPy: can you write it without recursion, using list functions available in Prelude?
13:38:48 <monoidal> dEPy: um you're missing the base case
13:38:49 <dEPy> monoidal, hm.. not sure O_o
13:39:10 <dEPy> monoidal, for [] <*> _  ?
13:39:28 <shachaf> Just turn on -Wall and let GHC tell you what you're missing.
13:39:31 <monoidal> dEPy: yes
13:39:40 <shachaf> There should be a warning: Not compiling with -Wall
13:39:56 <dEPy>  (<*>) [] _ = []         ?
13:39:59 <quchen> It should be enabled with -Wall
13:40:02 <monoidal> dEPy: yes, correct
13:40:05 <dEPy> cool
13:40:26 <fizbin> > (<*>) [] undefined
13:40:29 <lambdabot>   []
13:40:51 <dEPy> > (<*>) [] 1
13:40:53 <lambdabot>   No instance for (GHC.Num.Num [a0])
13:40:53 <lambdabot>    arising from the literal `1'
13:40:53 <lambdabot>  Possibl...
13:41:02 <dEPy> > (<*>) [] [1]
13:41:04 <lambdabot>   []
13:44:21 <dEPy> monoidal, I could probably rewrite it using folding?
13:44:58 <monoidal> dEPy: yes
13:45:08 <monoidal> dEPy: in fact it's a very specific fold
13:45:51 <Asterfield1> I have a very noobish haskell question, if anyone feels like indulging me
13:46:06 <quchen> Don't ask to ask, ask. :-)
13:46:12 <Asterfield1> Okay :)
13:46:27 <Asterfield1> foobar = 34 seems to assign 34 to foobar
13:46:41 <Asterfield1> But I've also seen the let keyword used. I.e let foobar = 34
13:46:54 <Asterfield1> What's the difference?
13:47:16 <johnw> I wouldn't call it assignment in the sense you might be used to
13:47:24 <johnw> both declarations state that foobar is another name for 34
13:47:34 <sepp2k> Asterfield1: var = value defines a global variable. To define a local variable, it needs to be inside a where or inside a let.
13:47:40 <johnw> there is really no difference you need to care about
13:47:51 <Clint> it's not really a variable
13:47:58 <monoidal> Asterfield1: simplest version: let is used in GHCi, x = y in files
13:48:02 <sepp2k> Clint: That depends on your definition.
13:48:09 <monoidal> Asterfield1: you can also write "let x = y in z" in both places.
13:48:15 <johnw> sepp2k: it's not a variable, because it can't vary
13:48:49 <Asterfield1> so sepp2k answer of let defining local and let-less defining global is more or less correct? :)
13:48:51 <dEPy> monoidal, I have no idea, a little hint plz :)
13:49:14 <johnw> Asterfield1: in some ways; the "global" definition can be exported from your module, while the local one cannot
13:49:43 <Asterfield1> johnw: Ah okay, that makes a bit of sense to my muddled brain :P Thank you ver much johnw and sepp2k
13:49:49 <johnw> but calling them globals, or distinguishing between global & local as if distinguishing between heap and stack, are misleading
13:49:50 <monoidal> dEPy: use concat and map
13:49:52 <skuggi> another difference is that let is used in expressions
13:49:59 <sepp2k> johnw: Sure, it can. "f x = let y = x + 1 in y*y" The value of y will be different in different applications of f. If you don't agree that that's what "varying" means, what exactly varying does mean in mathematics. They certainly don't have a concept of re-assignment.
13:50:07 <skuggi> while the other one is a top-level declaration
13:50:31 <monoidal> Asterfield1: there's a difference between "let x = y in z"  and "let x = y" *without* in
13:50:33 <johnw> sepp2k: well, when people call a global 'x' a variable, they mean it can have a different value at another time.  I didn't realize you were called the *name* 'x' a variable
13:50:53 <monoidal> Asterfield1: the second is used in GHCi and inside do-notation only
13:51:09 <monoidal> Asterfield1: the first one allows to define an extra value in any expression
13:51:14 <johnw> Asterfield1: in reality, we are just talking about names for values, and the scoping of those names
13:51:16 <elliott> johnw: they vary as much as mathematical variables.
13:51:19 <Asterfield1> Ho boy, coming from a C/Java/Python/Ruby/Javascript background, a lot of this is going over my head o.o
13:51:51 <skuggi> elliott: that's not true of a top-level declaration, though
13:52:01 <Asterfield1> So, the simplest answer is that including let changes the scoping of the definition?
13:52:10 <johnw> Asterfield1: exactly
13:52:18 <johnw> Asterfield1: let establishes a new binding in a local scope
13:52:29 <skuggi> that seems a bit too simplified though
13:52:55 <Asterfield1> skuggi: Bear with me :P this is day 1 of "Oh hey, let's learn Haskell. That sounds like a spiffy idea"
13:52:58 <johnw> skuggi: do tell
13:53:08 <elliott> skuggi: well, you can think of those as varying according to all the values you import and so on.
13:53:09 <johnw> Asterfield1: Haskell is _wonderful_, stick with it
13:53:19 <skuggi> let is used in different places than the other one
13:53:23 <elliott> but yes, values that don't depend on function parameters or such are closer to constants.
13:53:39 <Asterfield1> johnw: It's all very confusing at the moment, but I'm sure once I understand it more, I'll begin to see the beauty of it
13:53:48 <johnw> Asterfield1: plan on giving it a few months
13:53:59 <johnw> Asterfield1: there's more confusion ahead
13:54:20 <johnw> some things are worth enduring momentary pain for
13:54:29 <Asterfield1> johnw: I am determined to learn at least 1 functional language :P I don't want to restrict my brain to only c-esque logic
13:54:44 <johnw> well, you picked a good one to start with, owing to Haskell's devotion to purity
13:54:46 <quchen> Asterfield1: Some beauty will come pretty soon. Currying functions will probably make you think "why doesn't every language have this".
13:55:00 * Asterfield1 goes and googles "currying"
13:55:20 <sepp2k> Asterfield1: I should add that it's not syntactically valid to write "x = y" without "let" or "where" inside a function definition. So it's not so much that it changes the scope, but that you need to pick the right syntax depending on which scope you're in.
13:56:19 <dEPy> monoidal, honestly I have no idea how to do it with fold
13:56:34 <quchen> Asterfield1: Don't google it, read a book. Google's results are pretty awful as a first exposure. :-)
13:56:41 <johnw> agreed
13:56:42 <monoidal> dEPy: fix ys
13:57:02 <dEPy> monoidal, ? :D
13:57:08 <skuggi> Asterfield1: well, if you over-simplify it just gets even more confusing.
13:57:10 <johnw> Asterfield1: most of these concepts, like currying, that may seem confusing at first, will have you thinking, "Is it really just that simple?" later on down the line
13:57:16 <monoidal> a <*> ys = g a where a [] = []; a (x:xs) = (fmap x ys) ++ a xs
13:57:18 <Asterfield1> quchen: So I'm finding :P I somehow knew you lot would be infinitely more helpful than google
13:57:30 <monoidal> dEPy: whoops, will fix that
13:57:58 <Asterfield1> skuggi: True, but sometimes the brain has to process the oversimple version before it can throw it out and process the full version. At least in my case :P
13:58:12 <monoidal> x <*> ys = a x where a [] = []; a (x:xs) = (fmap x ys) ++ a xs
13:58:18 <skuggi> Asterfield1: what sepp2k was a good explanation. "x = y" and "let x = y" is used in different places.
13:58:23 <monoidal> dEPy: ^ you see this is equivalent?
13:59:09 * hackagebot zeromq3-haskell 0.3.0 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.3.0 (ToralfWittner)
13:59:14 <Asterfield1> quchen: As for "read a book", I'm currently trying to work my way through "learn you a haskell" :P
13:59:17 <dEPy> monoidal, not really, looks complicated O_o
13:59:33 <quchen> Asterfield1: That's an excellent first book if you ask me.
13:59:39 <johnw> agreed
13:59:40 <skuggi> Asterfield1: that's not going to be the case if it's simplified to the point that it omits some part that's needed to understand it.
14:00:11 <Asterfield1> quchen: Fabulous :)
14:00:17 <Asterfield1> skuggi: Fair enough
14:00:30 <johnw> skuggi: then again, hammering out the finer points of terminology is not always very productive if you're talking to someone on their 1st day of learning
14:02:14 <skuggi> johnw: i just thought it seemed like he was coming away with a misunderstanding about the concept.
14:02:19 <johnw> ah, ok
14:02:26 <Asterfield> Whoop, my laptop kernel panick'd :P
14:02:29 <dEPy> monoidal, but, it's still recursive
14:02:40 <dEPy> monoidal, you said I can write it with folding? :)
14:03:01 <monoidal> dEPy: but now you've got a definition that uses f [] = ... ; f (x:xs) = .. which you should be able to write with fold
14:03:06 <armlesshobo> my laptop, I guess, was overheating and just froze. and as soon as I switched to the nvidia driver the problem went away.
14:03:10 <skuggi> like it was something like the difference between having "static" and not in c definition or something
14:03:33 <Asterfield> skuggi: If you feel like I've misunderstood how "let" works, I'd love to hear your explaination. :) But do try to keep it at the level I can understand?
14:03:48 <johnw> armlesshobo: it's interesting that something can freeze as a result of becoming overheated
14:04:43 * geekosaur seems to recall mech e-s have various circumlocutions to avoid saying that kind of thing
14:07:29 <skuggi> Asterfield: I think the simplest explanation I can come up with is that "x = y" is a top-level declaration and "let x = y" is used in do-notation to define a local variable, and "let x = y in ..." is used to define a local variable in an expression.
14:08:03 <skuggi> Asterfield: The point is that each of the three are used in different contexts.
14:08:44 <johnw> but still, it's not a variable in the "the memory contained here can vary" sort of way
14:08:58 <Asterfield> skuggi: Okay, that makes sense :)
14:09:14 <johnw> it binds an expression to a name, so that the name can be used in place of repeating the expression
14:09:52 <johnw> people coming from the imperative programming world typically do not use the mathematical definitions of terms like "variable"
14:10:27 <skuggi> that's true.
14:10:27 <Asterfield> johnw: the idea that "variables" cannot change is a bit foriegn to me, but I'm sure it will make more sense when I understand how the language works a little better
14:10:42 <johnw> think of them as names, not variable
14:10:43 <johnw> s
14:11:30 <johnw> later, you can think of them as variables again, when that word means something else to you :)
14:11:35 <Asterfield> so, like function names? but with all data types?
14:11:47 <johnw> yes!
14:11:54 <Asterfield> Aha, I think I get it
14:11:57 <johnw> as long as you exclude self-modifying functions :)
14:12:04 <tac_> Asterfield: Variables don't vary :)
14:12:21 <Asterfield> tac_: staticables then :P
14:12:24 <tac_> Asterfield: It's perfectly normal, though. Once you define something, what sense does it make to go back on your word?
14:12:39 <rifki> hi, I'm supposed to declare a class "xyz" and give an instance of Eq, I wrote the instance of Eq without a class, how I can put it inside that class?
14:12:49 <monochrom> C variable means rewritable memory cell. Haskell variable means name. Haskell has mutable references too, that's for rewritable memory cell.
14:13:19 <tcrayford> is there a function for splitting bytestrings into chunks of N size?
14:13:23 <benmachine> @pl \x y -> x `18` y
14:13:23 <lambdabot> 18
14:13:33 <johnw> rifki: you are using the word "class" in a way I don't recognize
14:13:37 <tcrayford> e.g. chunk :: ByteString -> Int -> [ByteString]
14:13:39 <johnw> Eq is the type class
14:13:41 <Asterfield> I do believe I'm beginning to understand the concept
14:13:48 <monochrom> yes tcrayford, it's in the "split" package
14:14:00 <ChongLi> imperative languages have been abusing the name "variable" for decades
14:14:10 <monochrom> the "split" package comes with Haskell Platform
14:14:15 <johnw> > 19 `18` 20
14:14:16 <ChongLi> Haskell uses the proper, mathematical definition
14:14:17 <lambdabot>   <hint>:1:5: parse error on input `18'
14:14:28 <tcrayford> monochrom: I don't see anything about bytestring in that package :/
14:14:45 <skuggi> ChongLi: except in the case of things like MVar :P
14:14:57 <quchen> split is list only
14:15:06 <monochrom> yikes
14:15:10 <tcrayford> ;)
14:15:11 <goodfellow> Maybe you meant: ft rc
14:15:17 <tcrayford> I mean I can write it myself, not too hard
14:15:19 <tcrayford> I'd just rather not
14:15:32 <ChongLi> skuggi: yeah, it should've been called something like a ref or an atom
14:15:34 <ChongLi> a la clojure
14:15:49 <johnw> MMutable
14:16:14 <typoclass> hm, i thought the bytestring package had some Preludeish functions for ByteStrings, but apparently there's nothing like chunks
14:16:43 <rifki> johnw : to be more clear. I need to define a new class "xyz" and give an instance of == for a specific type. I already gave an instance without defining a class. How can I do it with a class?
14:16:49 <shachaf> chunks is not Preludeish.
14:16:51 <monochrom> then sorry, I don't know how to split bytestring into chunks
14:17:08 <shachaf> rifki: Why do you want a class?
14:17:15 <johnw> rifki: can you show me the code as you thought it should be written?
14:17:16 <tcrayford> monochrom: no worries. I'm handwriting it. Like I said, not too difficult
14:17:29 <benmachine> tcrayford: use unfoldr and splitAt
14:17:36 <johnw> rifki: and answer whatever shachaf asks :)
14:17:53 <geekosaur> rifki, classes don't work that way...
14:17:59 <typoclass> shachaf: Prelude has words and lines, so i don't think the functions from the split package are very far off
14:18:04 <ChongLi> rifki: if you want to overload (==), write an instance of Eq
14:18:06 <ChongLi> or derive one
14:18:27 <benmachine> tcrayford: it is a little surprising that it isn't standard though
14:18:32 * geekosaur wonders if rifki thinks they are creating an OOP-ish "class"
14:18:34 <rifki> ChongLi : it has nothing to do with classes right?
14:18:50 <ChongLi> rifki: Haskell's type classes are more like interfaces in Java
14:18:56 <FireFly> rifki: a typeclass is a set of types that share similar functionality
14:18:57 <rifki> for curious ones it's an assignment, so I don't know why either :D
14:18:57 <geekosaur> except not really
14:18:58 <monochrom> if you talk about ==, the class is Eq, it is already defined.
14:19:40 <geekosaur> so, could you show us this assignment? because so far it sounds rather confused about Haskell
14:19:57 <monochrom> please do not spread "Haskell class is like Java interface". it has exactly the same problem with "Haskell class is like Java class". exact same problem.
14:20:08 <ChongLi> I didn't say that!
14:20:13 <ChongLi> I said "more like"
14:20:21 <monochrom> the problem: Haskell class is not a type. Java class is a type. Java interface is a type too.
14:20:34 <rifki> well I think my classes are typeclasses
14:20:35 <johnw> monochrom: http://blog.tmorris.net/type-classes-are-nothing-like-interfaces/
14:20:37 <monoidal> monochrom: well, typeclasses are types too... of kind Constraint
14:20:54 <monochrom> darn you monoidal! :)
14:21:08 <benmachine> monoidal: arguably * is the kind of types and Constraint is the kind of something else
14:21:29 <quchen> johnw: That's a 404 :-(
14:21:48 <monochrom> it is a 404 and then a real web page.
14:21:53 <johnw> http://blog.tmorris.net/posts/type-classes-are-nothing-like-interfaces/
14:22:17 <quchen> Oh, Javascript, I see, the professional way of redirecting.
14:22:41 <johnw> they should build a dedicated Node.js redirector
14:22:45 <monoidal> "Haskell has something like interfaces. They are called data types and are expressed using the data or newtype keywords"
14:23:03 <monoidal> I have a hard time agreeing with this
14:23:10 <quchen> johnw: Or include something for redirects in the HTTP. "Location" may be a good name.
14:23:12 <monochrom> http://blog.tmorris.net/javascript-redirection-is-nothing-like-standard-redirection/ :)
14:23:20 <johnw> lol
14:23:50 <rifki> so how can I change this definition to instance Eq a => Eq (Something a) where .... to the one with typeclasses?
14:24:02 <johnw> rifki: show us the current definition
14:24:23 <monochrom> Eq is already the typeclass
14:24:34 <rifki> instance Eq a => Eq (Something a) where
14:25:03 <rifki> so should I change its name to "xyz"
14:25:11 <rifki> like instance xtz a => Eq (Network a) where
14:25:16 <rifki> xyz*
14:25:27 <johnw> your first instance looked right to me
14:25:31 <johnw> but I'd need to _see some code_
14:25:52 <monochrom> ok, I declare I don't understand the question, or obsession. must you create your own type class?
14:27:35 <shachaf> monoidal: Only nullary classes have kind Constraint. :-)
14:27:40 <shachaf> (And that's only in GHC, not in Haskell.)
14:27:54 <monochrom> "Haskell is like GHC"
14:28:54 <armlesshobo> GHCi*
14:28:56 <armlesshobo> :P
14:29:07 <monochrom> "GHC is like GHCi"
14:29:12 <eikke> is there any sane way to replace "Cons <$> arbitrary <$> arbitrary <$> arbitrary <$> ... (etc)" with something more succint?
14:29:20 <typoclass> i thought when people say that, they mean "a typeclass is a bunch of function signatures, the corresponding implementations are in the instances, so in this regard typeclasses are similar to java's interfaces". but what monochrom said is of course true -- saying "interfaces similar to typeclass" can suggest typeclasses were types
14:29:26 <quchen> eikke: liftAX Cons
14:29:31 <quchen> Where X is the arity of Cons
14:29:36 <monoidal> eikke: you're doing <*> repeatedly, not <$>? in this case, I doubt it
14:29:39 <elliott> eikke: you mean <*> for the second right?
14:29:50 <eikke> oh, yeah, should be <*>
14:30:02 <eikke> quchen: liftA* would still need several 'arbitrary's
14:30:02 <elliott> you could abstract the pattern a bit.
14:30:05 <elliott> but that's basically how it goes.
14:30:16 <armlesshobo> but I thought interfaces were only reserved for things that know what to do with an implementation of an interface, not just an implementation of a function for a given type.
14:30:24 <dEPy> monoidal, this is as far as I got, and it's not even remotely close:   x <*> ys = a x where a [] = []; a (x:xs) = (fmap x ys) ++ a xs
14:30:30 <eikke> elliott: kinda annoying with a constructor with 11 fields :P
14:30:32 <dEPy> ups
14:30:48 <dEPy> monoidal, this:    foldl (\xs f -> fmap f xs) [1,2] [(+), (-)]
14:31:09 <monoidal> dEPy: you need to use ++ somewhere
14:31:27 <typoclass> armlesshobo: i don't know java well. not sure what the java people reserve interfaces for
14:31:48 <monochrom> there is a pair of functions, iI and Ii, such that "iI Cons x y z Ii" = "Cons <$> x <*> y <*> z", and it generalizes to more arguments.
14:32:15 <monoidal> dEPy: but "ys" is in your score. You don't need to pass it.
14:32:22 <monoidal> *scope
14:32:34 <dEPy> monochrom, ys ?
14:32:58 <dEPy> oh your talking about the whole things
14:33:00 <monoidal> x <*> ys = a x where a [] = []; a (x:xs) = [here you have access to ys and you need not pass it]
14:33:29 <monoidal> dEPy: perhaps let's look at it bit differently
14:33:40 <monochrom> one use of Java interface by Java people is to get some resmeblance of multiple inheritance while avoiding problems of multiple implementation inheritance
14:33:45 <elliott> monochrom: the problem is the repetition of arbitrary, though
14:33:49 <monoidal> dEPy: what would be [sin, cos] <*> [1,2]?
14:34:15 <dEPy> monoidal,  [(sin 1), (sin 2), (cos 1), (cos 2)] ?
14:34:27 <monoidal> dEPy: yes. And in steps, how would that computation look like?
14:35:16 <monoidal> dEPy: let's say you only get rid of (<*>) and let with calls to fmap and ++
14:35:16 <dEPy> monoidal, don't know :/
14:35:43 <monoidal> dEPy: fmap sin [1,2] ++ fmap cos [1,2]
14:35:53 <monoidal> dEPy: agree with above?
14:36:01 <dEPy> monoidal, sure
14:36:20 <monoidal> dEPy: if we have a lot of functions, we would use ++ a lot
14:36:35 <monoidal> for example, [sin,cos,tan] <*> [1,2] is fmap sin [1,2] ++ fmap cos [1,2] ++ fmap tan [1,2]
14:37:05 <monoidal> dEPy: which is concat [fmap sin [1,2], fmap cos [1,2], fmap tan [1,2]]
14:37:35 <monoidal> dEPy: do you agree? if so, can you write the last one using a list comprehension?
14:38:33 <monoidal> i.e. the list [fmap sin [1,2], fmap cos [1,2], fmap tan [1,2]] with a comprehension
14:40:40 <dEPy> monoidal, [ fmap f x | f <- [sin, cos, tan], x <- [[1,2], [1,2], [1,2]] ]  ? I have no idea actually
14:41:32 <monoidal> dEPy: [fmap f [1,2] | f <- [sin, cos, tan]]
14:41:49 <dEPy> monoidal, right, stupid me, replicating [1,2] :)
14:41:57 <monoidal> dEPy: so
14:42:09 <monoidal> [sin,cos,tan] <*> [1,2] = concat [fmap f [1,2] | f <- [sin, cos, tan]]
14:42:27 <monoidal> now you should have no trouble generalizing that to f <*> x
14:43:29 <dEPy> monoidal, something likes this:  fs <*> xs = concat [fmap f xs | f <- fs]  ?
14:43:51 <monoidal> dEPy: yes
14:45:00 <monoidal> dEPy: so that's Applicative instance for []
14:45:20 <dEPy> monoidal, so, I still don't get it how to write it using fold?
14:45:22 <monoidal> dEPy: with some experience, you'll identify building blocks such as concat and map and write non-recursive functions first
14:45:28 <tcrayford> @pl (a chunk (b (c chunk)))
14:45:28 <lambdabot> a chunk (b (c chunk))
14:45:54 <monoidal> x <*> ys = a x where a [] = []; a (x:xs) = (fmap x ys) ++ a xs -- dEPy: that's the original
14:46:11 <quchen> @pl \a b c -> (a chunk (b (c chunk))) -- tcrayford: you have to specify the parameters, otherwise it'll just take them as Expr
14:46:11 <lambdabot> (. (. ($ chunk))) . (.) . ($ chunk)
14:46:25 <monoidal> x <*> ys = a x where a = foldr (\x k -> fmap x ys ++ k) [] -- dEPy: that's with fold
14:46:32 <monoidal> hope I did not screw the argument order
14:46:47 <tcrayford> thanks
14:47:10 <monoidal> dEPy: may I recommend reading a tutorial on fold: http://www.cs.nott.ac.uk/~gmh/fold.pdf
14:47:41 <dEPy> monoidal, ofc you may, but it will wait till tomorrow, bed time now :)
14:47:44 <monoidal> dEPy: might look scary, but after reading it you will instantly see the folds
14:48:02 <dEPy> monoidal, thanks for your patience though :P
14:48:10 <tcrayford> @pl \chunk -> a chunk (b (c chunk))
14:48:10 <lambdabot> ap a (b . c)
14:48:15 <monoidal> dEPy: I recommend doing it with pencil and paper, and then checking with GHC
14:48:16 <tcrayford> haha welp
14:51:23 <dan_s28> anyone know any good text games, I'd like to look at their code
14:52:02 <`^_^v> irc
14:54:56 <dEPy> monoidal, I think I know what I was doing wrong, I was trying to use both lists inside fold function
14:55:38 <monoidal> dEPy: indeed. that's what I meant by "fix ys" some time ago.
14:55:39 <dEPy> monoidal, I can basically just use first list (list of functions) and just fmap over ys which if 2nd argument right?
14:55:40 <armlesshobo> is there a resource that lists benefits of monadic typing?
14:56:24 <c_wraith> what is "monadic typing"?
14:56:36 <monoidal> dEPy: you can write fs <*> xs = concat [fmap f xs | f <- fs] = concat (map (\f -> map f xs) fs)
14:57:23 <armlesshobo> c_wraith, putting things in monads
14:58:10 <dEPy> monoidal, better?:  (<*>) xs ys = foldl (\acc f -> (fmap f ys) ++ acc) [] xs
14:58:22 <monoidal> dEPy: I think it's foldr
14:58:22 <quchen> armlesshobo: You don't put things into monads. Certain structures *are* monads, and in Haskell you can give them a unified interface.
14:58:28 <c_wraith> armlesshobo: I'm really trying to understand what your question is. Do you mean "What are the benefits of using the monad abstraction?"?
14:59:10 <armlesshobo> c_wraith, yes, that.
14:59:20 <armlesshobo> i cannot brain today, I has the dumb :\
14:59:31 <dEPy> :t let  (<!>) xs ys = foldl (\acc f -> (fmap f ys) ++ acc) [] xs
14:59:32 <lambdabot> <no location info>:
14:59:32 <lambdabot>     not an expression: `let  (<!>) xs ys = foldl (\acc f -> (fmap f ys) ++ acc) [] xs'
14:59:49 <dEPy> :t let something xs ys = foldl (\acc f -> (fmap f ys) ++ acc) [] xs
14:59:50 <lambdabot> <no location info>:
14:59:51 <lambdabot>     not an expression: `let something xs ys = foldl (\acc f -> (fmap f ys) ++ acc) [] xs'
14:59:55 <c_wraith> armlesshobo: then the answer is "the same as any other abstraction - the ability to write code that works with the abstraction, rather than any specific implementation"
15:00:43 <armlesshobo> I feel like monads are everywhere because they have a secret power that everyone knows about and that I have yet to learn.
15:01:03 <monoidal> armlesshobo: How advanced are you in Haskell?
15:01:28 <monoidal> armlesshobo: if just starting, I would try to stay away from monads for a while
15:01:29 <c_wraith> armlesshobo: nope.  They're everywhere because the abstraction is useful, and lots of tools are already written for working with monads in the abstract.
15:01:35 <armlesshobo> monoidal, I wouldn't now how to answer that question.
15:01:53 <armlesshobo> monochrom, i'm not starting though, :)
15:01:54 <c_wraith> armlesshobo: kind of like asking why Iterators are everywhere in java.
15:02:00 <monochrom> I know!
15:02:03 <quchen> armlesshobo: http://codepad.org/LSAj4XaZ
15:02:06 <Walther> ...infinite list of 1's in haskell?
15:02:14 <c_wraith> > repeat 1
15:02:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:02:20 <armlesshobo> i've written stuff in haskell, using IO, Maybe, and Either monads
15:02:32 <monochrom> monad has no secret power, just wide applicability
15:02:43 <c_wraith> It's just that the monad abstraction is *more* abstract than Iterators
15:02:48 <monoidal> armlesshobo: For example, consider the function "sequence"
15:02:55 <monoidal> armlesshobo: It works on IO, Maybe and Either
15:02:57 <GOMADWarrior> can haskell have knowledge bases?
15:03:04 <monoidal> armlesshobo: but it's implemented in Haskell just once
15:03:26 <arkeet> > [1,1..]
15:03:27 <armlesshobo> right, but that's no more than providing an implementation of the Monad functions for the given types.
15:03:28 <monoidal> armlesshobo: thanks to monad abstraction, we have a single function that can do seemingly different things
15:03:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:03:38 <Walther> c_wraith: that's still not something assignable to something, is it? You can't just define x = repeat 1
15:03:41 <Walther> or can you
15:03:50 <monoidal> armlesshobo: we supply return and (>>=) for monads. For free, you get replicateM, filterM, mapM, sequence...
15:03:57 <armlesshobo> so, right
15:04:01 <c_wraith> Walther: sure you can.
15:04:10 <c_wraith> :t repeat 1 -- Walther
15:04:11 <lambdabot> Num a => [a]
15:04:16 <donri> > cycle . return . unSum $ mempty
15:04:17 <monochrom> Functor is everywhere too. start with that.
15:04:19 <lambdabot>   Not in scope: `unSum'
15:04:19 <lambdabot>  Perhaps you meant one of these:
15:04:19 <lambdabot>    `unSym' (imported...
15:04:19 <armlesshobo> monoidal, right. and that would imply elegance too.
15:04:28 <aCube> > let xs = repeat 1 in xs
15:04:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:04:35 <c_wraith> You can do anything with it that you can with any other list of numbers
15:04:47 <dEPy> monoidal, you were right, this is now working:  (<*>) xs ys = foldl (\acc f -> acc ++ (fmap f ys)) [] xs
15:04:48 <donri> > cycle . return . getSum $ mempty
15:04:50 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:04:54 <dEPy> monoidal, was in reverse order before
15:04:57 <donri> > cycle . return . getProduct $ mempty
15:04:58 <donri> duh
15:04:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:05:03 <Walther> > x = [x] | x <- 1
15:05:05 <lambdabot>   <hint>:1:3: parse error on input `='
15:05:10 <Walther> meep
15:05:13 <monoidal> dEPy: Indeed, although you inverse twice. It's better to use foldr and revert arguments to old order
15:05:32 <dEPy> monoidal, oh, right
15:05:38 <c_wraith> Walther: you can only use expressions with lambdabot, not full statements.
15:05:43 <Walther> > let x = [x] | x <- 1
15:05:46 <lambdabot>   <hint>:1:13: parse error on input `|'
15:06:00 <Walther> ...and just now when i have to be on my windows install
15:06:10 <geekosaur> and that's wrong anyway, is it supposed to be a list comprehension? (the brackets are part of the comprehension)
15:06:23 <geekosaur> also, let expression requires an `in <expr>`
15:06:45 <dEPy> monoidal, <*> xs ys = foldr (\f acc -> (fmap f ys) ++ acc) [] xs       ?
15:07:09 <armlesshobo> in the "Beautiful Concurrency" article, Peyton Jones refers to IO a as an action that, once performed, returns a type t.
15:07:14 <monoidal> dEPy: yes
15:07:25 <armlesshobo> now, do all monads have this characteristic? or just IO/STM?
15:07:28 <dEPy> ok, enough for today, off to bed now for real
15:07:38 <dEPy> tnx all for help and support :P
15:07:39 <monoidal> dEPy: in the tutorial I linked, you'll see a relation between this defn and the map / concat one
15:07:45 <monoidal> bye
15:07:54 <dEPy> monochrom, I have it bookmarked for tomorrow :)
15:07:56 <c_wraith> armlesshobo: that's a property of types that represent computation.  IO/ST/STM are some of the most direct examples of that
15:07:56 <dEPy> bye
15:08:17 <armlesshobo> c_wraith, I see, so I shouldn't assume that all monads are actions.
15:08:30 <armlesshobo> c_wraith, how can I tell if something represents computation or not?
15:08:32 <c_wraith> armlesshobo: though you can find ways to treat other types as if a similar interpretation applies, it's not always natural
15:08:36 <armlesshobo> do I just have to be told this?
15:09:01 <monochrom> I should program my IRC software to echo monoidal. just to add confusion that is already there.
15:09:14 <c_wraith> monochrom: don't forget to echo mauke, too
15:09:19 <monoidal> I, for one, sometimes hate my nick when monoidal categories are discussed here
15:09:52 <Mortchek> monoidal, you at least had the foresight not to name yourself monoid
15:10:08 <Mortchek> (which I think would be more common)
15:10:17 <c_wraith> armlesshobo: if you search really hard, you can probably find a computational interpretation of most types that form monads.  But in general, it's best to look at what the type is used for, and just think of it as doing what it's used for.
15:10:59 <c_wraith> armlesshobo: like, if you really want to, you can see a list as a program representing nondeterministic selection of values.  Sometimes that's useful - oftentimes it's fluff.
15:11:07 <monochrom> I don't know whether "performing action :: m t returns t", because I don't know what it is supposed to mean. (Is it even supposed to mean anything?)
15:11:21 <armlesshobo> so, really, it's how they would individually implement the Monad functions.
15:11:26 <armlesshobo> c_wraith, ^
15:11:28 <typoclass> armlesshobo: theoretically discussing monads is ok, but nothing beats writing code. try writing some haskell involving IO, and some stuff involving the Maybe monad, and maybe the list monad. then check back with the theoretical questions :-) it'll make much more sense
15:11:40 <monochrom> but you are always allowed to write "action >>= \x -> more", and that x has type t, you are assured that much.
15:11:51 <armlesshobo> typoclass, I have already :)
15:12:01 <typoclass> armlesshobo: ok very good
15:12:08 <c_wraith> armlesshobo: have you done any work with parsec?
15:12:11 <aCube> > [1,2,3] >>= \x ->  [x+1, x*3]
15:12:13 <lambdabot>   [2,3,3,6,4,9]
15:12:30 <armlesshobo> c_wraith, i'm actually in the middle of reading about it.
15:12:34 <monoidal> armlesshobo: the "performing" thing is just intuition, you should not look deeply into it
15:13:18 <monochrom> as for "does monad stand for computation", I don't know what computation is supposed to mean, but the popular way out is to define "computation = monad", therefore you get a tautology, monad is computation
15:13:37 <c_wraith> Do some stuff with parsec. I suspect it will give you another perspective.
15:13:52 <monochrom> much like "survival of the fittest". what does "fittest" mean? oh, those who survive, of course, who else.
15:14:25 <scooty-puff> when looking at core, is laziness made explicit with let's, or is it evalutation thats made explicit with case's?
15:14:30 <scooty-puff> *evaluation
15:14:33 <monochrom> both
15:14:51 <aCube> let = allocation, case = evaluation
15:15:00 <scooty-puff> i have a line, case writeMutVar# rb_d18B (I# (+# x_a1lc 1)) ipv_a1Ey, that's making me nervous
15:15:06 <armlesshobo> I guess Monads offer the benefit of guarantee order of execution.
15:15:11 <armlesshobo> also*
15:15:14 <aCube> armlesshobo: not also
15:15:16 <scooty-puff> i assume that ones fine because you can't store a thunk in an Int#
15:15:22 <aCube> armlesshobo: not always*
15:15:37 <armlesshobo> aCube, at least the operations would be called in order, right?
15:15:46 <armlesshobo> I'm not including IO in this, because of it's nature.
15:15:57 <armlesshobo> so I guess I can't say all mondads
15:15:59 <monochrom> when that line is run, the writeMutVar# happens, there is no further delay
15:16:26 <scooty-puff> the +# happens before being written, right?  i.e. not thunk is stored in the MutVar#?
15:16:41 <monochrom> ah, that is false.
15:16:44 <scooty-puff> k
15:17:00 <monochrom> actually, I don't know
15:17:09 <monoidal> good night
15:17:15 <scooty-puff> if it helps, this was emitted by modifySTRef'
15:17:25 <scooty-puff> so i'm leaning towards it being strict
15:17:41 <scooty-puff> but unsure because i would have expected an explicit .. something
15:17:53 <scooty-puff> i guess an explicit case +# x_a1lc 1 of ...
15:19:20 <monochrom> try -ddump-prep. it is annoyingly many more let's, but it is more explicit about evaluation order than -ddump-simpl
15:19:36 <scooty-puff> k
15:20:25 <monochrom> essentially because it flattens out all compound expressions, therefore it must tell you "let" vs "case".
15:20:53 <monochrom> and therefore annoyingly many more "let"s
15:21:15 <scooty-puff> ooo, i do like this version more
15:22:06 <armlesshobo> is TVar only useful in STM?
15:22:08 <monochrom> is your code essentially "modifySTRef (+ 1)"?
15:22:16 <arkeet> TVar is only usable in STM.
15:22:32 <armlesshobo> gotcha, thank you :)
15:23:12 <scooty-puff> monochrom: modifySTRef' ref (+ 1)
15:23:19 <scooty-puff> (the ')
15:24:00 <scooty-puff> the prep version is
15:24:25 <hpaste> scooty-puff pasted “-ddump-prep” at http://hpaste.org/86149
15:25:16 <monochrom> yeah, that does it, the addition happens because the writing
15:25:59 <monochrom> and the number is stored, not an addition thunk
15:26:53 <scooty-puff> k
15:31:58 <eikke> is there some generalization of 'filter'?
15:32:19 <quchen> filterM?
15:32:49 <simpson> eikke: What kind of type signature were you hoping for?
15:33:23 <c_wraith> there's partition
15:33:30 <c_wraith> it's a generalization of filter
15:34:04 <eikke> something like Traversable t => (a -> Bool) -> t a -> t a
15:34:22 <eikke> which might make no sense at all since filter isn't structure-preserving, hmh
15:34:25 <c_wraith> yep
15:34:27 <haasn> :t filtered
15:34:29 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Overloaded' p f a a
15:34:30 <c_wraith> that's exactly the problem with it
15:34:46 <haasn> generalized to all folds, or something
15:36:13 <haasn> > [1..10]^..folded.filtered (>5)
15:36:15 <lambdabot>   [6,7,8,9,10]
15:37:07 <scooty-puff> does ghc operate using a finite amount of optimization fuel, and if so, do manual INLINE's count against this?
15:37:49 <quchen> scooty-puff: Nope, you can easily make it "optimize" an infinite loop in the compilation process.
15:38:06 <scooty-puff> k
15:38:11 <quchen> The INLINE pragma basically says "if there is any reason you may want to inline this, do inline it".
15:38:21 <quchen> (As opposed to "inline when you see fit to do so")
15:39:34 <quchen> Just add {-# RULES "loop" forall x y. loop x y = loop y x #-} to your program and compile
15:39:54 <quchen> When "loop 1 2" is used somewhere in the program, the compiler will keep swapping its arguments forever
15:40:02 <hpc> put just a bit more precisely, it's the difference between "if it's faster" and "if it's possible"
15:40:31 <quchen> Yeah that's probably a better way of saying it
15:40:38 <scooty-puff> so INLINEs should only really be used when you know better than the compiler
15:41:22 <hpc> scooty-puff: same with all optimization pragmas
15:41:22 <scooty-puff> i think i've sometimes used them to avoid dictionaries as well - if i want to avoid dictionaries, have an extremely finite number of instances, but don't want to inline, i assume SPECIALIZE is the way to go
15:41:44 <scooty-puff> i assume those times come up more often with intermodule stuff
15:45:14 <scooty-puff> is the decision to inline made at each all site?  if inline a largish function made up of a few calls to smallish functions, will those smallish functions be inline where the largish function is inlined?
16:01:36 <mvb> whats a good exercise to elarn about tcp/ip? i know sockets and message framing and timeouts. i want to learn more.¨
16:02:09 <shachaf> Maybe #networking is a better channel for that sort of question?
16:06:07 <monochrom> the universal answer is always "write a chat server and a chat client" :)
16:06:25 <haasn> write an operating system, implement TCP/IP
16:06:35 <haasn> some preliminary reading required
16:07:29 <koala_man> implementing a simple tcp-like protocol on top of some suitable abstraction of ip is pretty educational
16:08:17 <mvb> suitable abstraction of ip?
16:08:25 <mvb> can you be a littlre more specific?
16:08:42 <haasn> simulate a perfect layer 1, implement everything on top of it (in haskell)
16:09:11 <mvb> what about implementing http?
16:11:39 <koala_man> you can do that easily on real tcp
16:14:20 <mvb> but will it teach me about tcp?
16:14:41 <koala_man> http? not so much
16:21:38 <mvb> implement TCP on top of raw sockets?
16:30:23 <mizu_no_oto> Is it possible to make an endofunctor in Hask that can't be made a Functor?
16:30:38 <mizu_no_oto> Or isn't isomorphic to an instance of Functor
16:31:26 <haasn> identity
16:31:32 <haasn> oh, isomorphic
16:31:40 <haasn> I'm sure there are examples, but I can't think of any right now
16:33:02 <elliott> mizu_no_oto: do you count stuff with a noncomputable fmap or whatever?
16:33:10 <elliott> stuff that would be functors classically, but not constructively.
16:35:37 <mizu_no_oto> elliott: Yes.  Mostly, I'm starting to read Awodey's Category Theory, and I'm trying to figure out the difference between Functor and functors.  Obviously, Functor is just for endofunctors in Hask, but I was wondering if there was anything else
16:36:08 <elliott> well, if you drop the isomorphism thing, there's the part where you have to map every object to (f a) for some f with a bunch of conditions.
16:36:16 <elliott> like, you can never have fmap :: (a -> b) -> a -> b.
16:36:22 <haasn> well all Functors are injective, A -> F A; you can't have something like A -> B -- which might be a mapping that's part of a perfectly fine functor
16:36:43 <elliott> and also you can't have functors that depend on Haskell values and stuff without tricks
16:36:57 <Eduard_Munteanu> All type constructors... now I'm not sure you couldn't make a non-injective Functor.
16:37:25 <haasn> you can make non-injective type families or something; but not make those instances of Functor
16:37:44 <haasn> I'm thinking it's doable with alternative formulations of Functor apart from the one we have in place
16:37:59 <mizu_no_oto> makes sense
16:38:13 <Eduard_Munteanu> You can define functors from/to categories other than Hash, if you want.
16:38:20 <Eduard_Munteanu> (a new typeclass, of course)
16:38:25 <Eduard_Munteanu> *Hask
16:38:28 <elliott> haasn: yeah you can do a more accurate Functor.
16:38:31 <no-n[3]> think all nouny. no verby.
16:38:32 <elliott> take a look at the data-category package.
16:39:17 <haasn> elliott: yes that looks similar to what I was thinking
16:39:32 <haasn> using tags and associated type families for the mapping
16:40:20 <elliott> it's clever to use (cat x x) as representing an object of cat
16:40:45 <elliott> since it means you can do things like "a category of no objects" just with an empty type without having to do lots of PolyKinds nonsense.
16:40:45 <Eduard_Munteanu> Hm?
16:40:53 <elliott> especially since PolyKinds doesn't really work.
16:41:01 * Eduard_Munteanu looks it up
16:42:37 <Eduard_Munteanu> Hrmpf.
16:43:44 <Eduard_Munteanu> Hm, yeah... isn't it a bit arbitrary though? What's special about identity arrows?
16:43:57 <haasn> every object has one
16:43:57 <ciaranm> they're identities
16:44:00 <ciaranm> that's very special
16:45:28 <elliott> Eduard_Munteanu: well, every object has an identity arrow.
16:45:34 <elliott> you can rephrase that as every identity arrow identifies an object.
16:45:36 <Eduard_Munteanu> Yeah, I think that makes most sense.
16:45:42 <elliott> note how there is no "id" in data-category's categories
16:45:51 <elliott> just a way to go from cat x y -> cat x x and cat x y -> cat y y
16:45:57 <Eduard_Munteanu> Right.
16:45:57 <elliott> i.e. if there is an arrow X -> Y, then both X and Y are objects.
16:46:42 <haasn> when thinking about categories it often makes sense to just ignore the objects, and think of a category solely as the collection of arrows - if you forget about the object, then the identity arrow is the /only/ thing that identifies a type
16:48:56 <Eduard_Munteanu> Interesting Yoneda. Much more explicit, I mean, it seems.
16:52:10 <mvb> if implementing http should i do it on top of sockets?
16:55:14 <Tene> mvb: what else would you do it on top of?
16:56:48 <staafl> what's the point of ByteString when you can keep the same data in a regular string :-)
16:57:17 <geekosaur> staafl, you assume OSes provide some other way to do it...
16:58:07 <geekosaur> (you want to use something other than sockets? start by learning how to add a network stack with a different interface to your kernel...)
16:58:32 <haasn> ByteString is a string of bytes
16:58:37 <haasn> String is a string of unicode codepoints
16:59:26 <staafl> haasn, so isn't the representative range of String is a proper superset of that of ByteString?
16:59:55 <haasn> I wouldn't call unicode codepoints a superset of 8-bit integers
17:00:06 <haasn> also, they have different properties apart from that
17:00:11 <haasn> that's just the first and most obvious difference
17:00:42 <haasn> bytestring has different strictness properties; depending on the flavor, you either get a strict chunk or a lazy list of smaller strict chunks
17:00:55 <haasn> with String you get a lazy list of individual codepoints
17:01:14 <staafl> haasn, that's just a performance consideration
17:01:20 <haasn> a closer analog would be Text instead of ByteString, which is a string of unicode codepoints with similar strictness properties to ByteString
17:01:53 <haasn> staafl: not quite, strictness can be the difference between a program halting or not
17:02:16 <haasn> > head $ 1 : undefined -- try this with a strict bytestring
17:02:18 <lambdabot>   1
17:02:53 <staafl> haasn, I stand corrected
17:03:06 <Mortchek> > let a = 1:a in a
17:03:08 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:04:07 <haasn> staafl: also, on the theoretical side of things, ⊥ is a proper Haskell value that is a member of every data type, so data I = I a -- and newtype I = I a -- are not isomorphic, because one has ⊥ and I ⊥, while the other has only I ⊥
17:05:13 <staafl> I see
17:37:40 <no-n[3]> "there are as many thunks in a list as there are elements. That's what makes them kind of slow for some purposes." -- what purposes in particular? just reading and manipulating large files?
17:38:43 <Eduard_Munteanu> no-n[3]: it is slow for large files because every character also takes up a cons cell as well
17:39:06 * no-n[3] nods
17:39:13 <Eduard_Munteanu> Or large data, generally.
17:39:28 <geekosaur> two dereferences per character, plus another to step to the next character
17:40:05 <Eduard_Munteanu> And a lot of GC garbage.
17:48:58 <startling> no-n[3]: any purpose with really long lists that aren't consumed lazily, really.
17:50:54 <parcs> :O
17:51:05 <no-n[3]> :>
17:51:11 <Eduard_Munteanu> startling: they sorta suck even lazily
17:51:21 <Eduard_Munteanu> Unless they fuse out completely.
17:51:32 <Eduard_Munteanu> (which doesn't usually happen)
17:52:17 <startling> Eduard_Munteanu: they're fun to write code for though!
17:52:45 <no-n[3]> laziness is bad for really long lists?
17:52:54 <Eduard_Munteanu> No.
17:53:02 <no-n[3]> ok
17:56:43 <billymaverick> what is haskells official position on sodomy marriage
17:59:33 --- mode: ChanServ set +o geekosaur
18:01:10 <startling> billymaverick, we think it should be mandatory.
18:01:36 <billymaverick> That makes sense
18:02:03 <billymaverick> I've often thought that Haskell is such a perverse and twisted language that only sodomites could enjoy using it
18:02:22 <Hafydd> What is sodomy marriage?
18:02:25 <no-n[3]> map sodomyMarry [minBound..] :: [Human]
18:02:25 --- mode: ChanServ set +o copumpkin
18:02:36 --- mode: copumpkin set +b *!~letalvis@222-152-142-161.jetstream.xtra.co.nz
18:02:36 --- kick: billymaverick was kicked by copumpkin (go away. Don't try that in #scheme either or I'll ban you there too)
18:02:44 --- mode: copumpkin set -o copumpkin
18:02:47 <Eduard_Munteanu> Yay.
18:04:25 * geekosaur wasn't going to jump right in...
18:06:15 --- mode: geekosaur set -o geekosaur
18:16:19 <eyebloom> Why would the typechecker see a type variable as GHC.Prim.Any *
18:24:23 <saml> is haskell good for mongodb?
18:27:29 <Ghoul_> Off the top of anyones head(s), are there any examples of using Parsec with a non functional language? All the examples outline languages which are not C-like
18:29:25 <startling> Ghoul_, aeson uses attoparsec I think
18:30:04 <h4199> lua http://www.inf.puc-rio.br/~roberto/lpeg/
18:30:06 <h4199> not quite right but the first thing that came to mind
18:30:43 <Ghoul_> startling, h4199: thanks!
18:32:15 <dan_s28> can someone explain the difference between => and -> in type signatures?
18:32:42 <monochrom> -> indicates a function type
18:32:44 <startling> dan_s28, a -> b is a function taking things of type a and returning a thing of type b
18:32:56 <startling> dan_s28: a => b is a value of b with the constraint a
18:33:10 <monochrom> => is separator punctuation between type class constraints and type
18:33:26 <dan_s28> ok that is a bit clearer thanks
18:34:03 <Cale> dan_s28: For example, when you see  sort :: (Ord a) => [a] -> [a]
18:34:33 <dan_s28> ahh gotcha because Ord is a funtion
18:34:36 <Cale> dan_s28: This means that for any type a which has an instance of Ord (which is a typeclass that defines comparison operations like <=)
18:34:51 <Cale> the sort function will take a list of values of type [a]
18:35:00 <Cale> and produce a list of values of type [a]
18:35:21 <dan_s28> that helps a lot
18:35:35 <monochrom> Ord is not a function. Ord is a type class. "Ord a" is a constraint that says, "a has to be an instance of that type class"
18:36:23 <Cale> You don't explicitly pass it a parameter to satisfy the Ord constraint, but if you like to think of things in terms of concrete implementations, you can think of the compiler as implicitly passing in an extra parameter there whenever sort is used, which is a record of all the operations that the Ord class defines.
18:37:03 <dan_s28> ha that made it a bit muddy, but i think i still got it
18:37:09 <bgamari> sambio, There are mongo bindings
18:37:21 <Cale> > sort [4, 8, 2, 5, 1, 7, 9]
18:37:23 <lambdabot>   [1,2,4,5,7,8,9]
18:37:24 <bgamari> saml, rather
18:37:26 <h4199> in Cale's example it means that to sort some things, the things you want to sort must be "orderable"
18:37:37 <Cale> > words "here are a bunch of words"
18:37:37 <dan_s28> gotcha h4199
18:37:38 <lambdabot>   ["here","are","a","bunch","of","words"]
18:37:41 <Cale> > sort (words "here are a bunch of words")
18:37:43 <lambdabot>   ["a","are","bunch","here","of","words"]
18:37:49 <bgamari> saml, Haskell is good for most things
18:38:12 <Cale> > sort [cos, sin, tan] -- it's hard to sort functions...
18:38:13 <lambdabot>   *Exception: showList: No overloading for function
18:38:52 <monochrom> actually, I think it is just hard to display functions, in this case :)
18:38:59 <Cale> (As it happens we don't get a type error there, because lambdabot has a fake instance of Ord for functions... I'm not entirely sure why)
18:39:24 <shachaf> Even Cale doesn't understand Caleskell.
18:39:27 <startling> > const 1 < const 2
18:39:29 <lambdabot>   *Exception: (==): No overloading for function
18:39:31 <shachaf> For some reason (.:) is gone too.
18:39:38 <dan_s28> ha
18:39:42 <shachaf> Cale: Oh, I know the reason.
18:39:52 <shachaf> NumInstances is standard-compliant.
18:40:02 <dan_s28> thanks for all the answers, back to the book (learn you...)
18:40:02 <shachaf> The standard requires an Eq superclass for Num
18:40:13 <Cale> Eq, but not Ord
18:40:20 <monochrom> > map ($ 0.2) (sort [cos, sin, tan])
18:40:22 <lambdabot>   *Exception: (==): No overloading for function
18:40:30 <startling> :t const 1 + const 2
18:40:32 <lambdabot> Num a => b -> a
18:40:32 <monochrom> interesting
18:40:47 <startling> oh, NumInstances are back?
18:40:58 <monochrom> has always been with us
18:41:19 <startling> when there was only one set of footprints, that was NumInstances carrying you.
18:41:30 <monochrom> hehe
18:41:58 <startling> seriously though, I thought it disappeared for a bit.
18:42:11 <Cale> It might've
18:42:28 <Cale> Occasionally I mess around with the imports because people want some thing or don't want some other thing
18:43:27 <shachaf> NumInstances was gone for a while.
18:43:53 <monochrom> I see
18:44:00 <shachaf> Then we got Cale to use Prelude (.), but he put NumInstances back.
18:44:06 <shachaf> Cale giveth and Cale taketh away.
18:44:14 <monochrom> all good things come to an end
18:48:44 <dan_s28> as I learn haskell looking back at CL it makes sense, anyone else feel like that?
18:49:43 <monochrom> CL made sense when I first saw it.
18:51:21 <dan_s28> im not that lucky mono :)
18:56:21 * BMeph_ resolves that, whenever possible, he will replace references of "G-d" with "G-bb-rd"! ;)
18:57:19 <hpaste> ryeguy pasted “wat” at http://hpaste.org/86151
18:58:03 <ryeguy> can someone explain this snippet's behavior? http://hpaste.org/86151
18:58:56 <monochrom> example: there is no G-bb-rd? :)
18:59:27 <Cale> ryeguy: you're using hGetContents inside of withFile, which closes the filehandle
18:59:59 <ryeguy> ok
19:00:01 <Cale> ryeguy: If you apply hGetContents to a Handle, you really mustn't close it unless you really don't care about the resulting String anymore
19:00:20 <Cale> The handle will be closed when the String result is garbage collected.
19:00:32 <ryeguy> this must be all the fuss i hear about lazy io
19:00:57 <Cale> Yeah, this can be annoying if you really want to carefully manage the number of open filehandles, for instance.
19:01:23 <ryeguy> so this basically happens because hGetContents is deferred until i de-thunk the string, but withFile closes it before that, correct?
19:01:29 <Cale> yes
19:01:51 <Cale> hGetContents produces a magic string as its result whose evaluation reads from the Handle
19:02:21 <ryeguy> so if i wanted to still encapsulate open/read/close in this function, but actually make it work, what would i do?
19:02:40 <dolio> Just use readFile.
19:02:59 <ryeguy> oh yeah that exists doesnt it
19:03:00 <Cale> Yeah, just using readFile is probably the right thing for this sort of program
19:03:09 <ryeguy> missed that.
19:03:10 <Cale> (readFile is also lazy I/O)
19:03:10 <ryeguy> thanks guys
19:03:19 <ryeguy> but that wont run into any issue like this will it?
19:03:21 <monochrom> http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
19:03:26 <ryeguy> dangling handles is not an issue in this program
19:03:31 <Cale> right
19:03:35 <ryeguy> cool
19:05:13 <Cale> You could also switch to using strict I/O -- the easiest way to do that when you're serious about it is usually to use something like Data.Text or Data.ByteString (depending on what sort of file it is), which have some strict I/O primitives. It would be nice if at some point System.IO had a strict hGetContents for String, but it's easy enough to make one using one of those libraries
19:06:54 <rck> between beginner and intermediate haskell programmer, why do I get worse performance compiling a very basic warp/WAI application with ghc -threaded?
19:07:23 <rck> ab is about 20% slower when warp runs on more than 1 core
19:07:42 <rck> am I missing some ghc switch?
19:08:10 <shachaf> It's not too surprising, if you're doing something that's not CPU-bound, that it gets slower when running on multiple cores.
19:08:25 <shachaf> I mean, the cores have to talk to each other and all that.
19:08:26 <rck> well ab saturates 1 core
19:08:29 <rck> it's a benchmark
19:08:35 <rck> if I omit -threaded
19:08:36 <shachaf> (Are you actually running it on multiple cores, or just compiling with -threaded?)
19:09:08 <Cale> rck: Are you running the program with +RTS -N2 or something?
19:09:30 <rck> err, I'm not sure what you mean. without -threaded it only uses 1 core. with threaded I see the work distributed but total requests/sec goes down
19:09:39 <shachaf> You can certainly expect -threaded to have a negative performance impact if you don't use multiple cores.
19:09:48 <rck> Cale: I tried +RTS -N but it killleeddddd performance
19:09:49 <shachaf> You need to use +RTS -Nsomething in order to use more than one core.
19:10:01 <shachaf> Anyway, there are lots of reasons your program could be slower.
19:10:33 <rck> is -N good enough? or do I have to specify?
19:11:27 <shachaf> -N will pick a number
19:12:25 <parcs> :O
19:13:20 <rck> somewhat of a tangent but my very simple warp application running on 1 core beats an equivalent nodejs application using cluster across 3 cores by 20%!
19:13:28 <Cale> rck: I think -N will try to use all the processors in your machine, which may cause problems if there's other stuff getting in the way
19:13:39 <rck> Cale: hmm okay. I'll do more testing.
19:13:58 <Cale> Often, one less than the maximum is better
19:21:05 <ekyo> hi, haskell noob here, will be diving into the language for the next few days and was wondering if anyone has some tips for someone coming from a mix of lisp / C / coffeescript. I already got "don't bother with monads early" from a friend.
19:21:30 <startling> ekyo, "don't worry about monads, they"
19:21:34 <shachaf> @where faq has some advice
19:21:34 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:21:36 <startling> "'re not magic""
19:21:38 <numberten> i found learn you a haskell to be a great source
19:21:51 <ekyo> that's what I'm currently reading ;)
19:21:55 <numberten> i think monads can be handled pretty easily, within your first 2 days
19:21:57 <ekyo> its going slow tough
19:22:00 <hpc> ekyo: has anyone explained to you what the monad operations are?
19:22:07 <hpc> (hint: "no" is the preferred answer)
19:22:22 <hpc> ekyo: learn IO without any kind of notion that monads exist
19:22:36 <numberten> if you get burned out just reading, spend time going over the examples in ghci
19:22:36 <hpc> then learn the generality after you can actually get a program running
19:22:46 <numberten> also check these out: http://www.haskell.org/haskellwiki/99_questions/1_to_10
19:22:58 <ekyo> not yet, just got a list of about 20 links that explain it differently
19:23:06 <ekyo> keeping them for the 3rd or 4th day ;)
19:23:10 <numberten> try and read a question and if you feel like you know enough to solve it, take  a break from reading to code
19:23:24 <hpc> ekyo: the way to learn monads is to write a monad tutorial
19:23:26 <hpc> not to read one
19:23:26 <numberten> then go to the next question, and when you are not longer able to solve the questions read some more
19:23:45 <Cale> ekyo: Ask lots of questions here
19:23:54 <monochrom> to a large extent, the way to learn is not to read, universally
19:23:54 <ekyo> thanks ^ ^ that link is what I was missing mostly
19:24:24 <Cale> ekyo: There are almost always people around waiting for beginners to ask questions :)
19:24:32 <monochrom> reading is information transfer. learning is not information transfer.
19:25:00 <ekyo> reading a language's spec and trying out things is what I'd do normally
19:25:11 <Gr_adient> I have heard recursive functions described as "winding" and then "unwinding". This doesn't seem to be how they work in haskell, there is just a "winding" phase which gets smaller and smaller until you can return a value you know
19:25:46 <monochrom> trying out things, destroying old guesses, forming new guesses, that's learning.
19:26:21 <monochrom> to that end, you do some reading just for guidance on what things to try.
19:26:32 <ekyo> any difference between using head on a list and !! 0 ?
19:26:53 <Cale> ekyo: they're equally bad
19:27:07 <tromp_> best is to pattern match
19:27:15 <Cale> ekyo: You should try to use pattern matching / case instead whenever possible
19:27:28 <Cale> (because it'll give you a nice way to handle the case of an empty list)
19:29:51 <ekyo> next on my list after learnyouahaskell I got that http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
19:37:14 <amiller> has anyone used parametric compositional data types as opposed to the finally tagless approach
19:37:35 <amiller> finally tagless is this: http://okmij.org/ftp/tagless-final/index.html#tagless-final
19:38:02 <amiller> compositional datatypes is wrapped up in this package but there's also a paper and slides http://hackage.haskell.org/package/compdata
19:38:30 <amiller> the argument they make is that the finally tagless approach can't be made parametric in the return type but i don't understand that point
19:43:13 <numberten> ekyo: i found the typeclassopedia to be really helpful after lyah.
19:43:39 <ekyo> thanks ^^ I'll check it
19:44:12 <ab9rf> i also heartily recommend the typeclassopedia
19:44:27 <numberten> lyak is good for haskell fundamentals, typeclassopedia great for some of the important underlying parts of the type system. and with both of those you're in a good place to go onto other things and understand them
19:51:42 <arbn> Typeclassopedia is a very good reference. I just discovered it recently, though I've been Haskelling for a while.
19:51:42 <NemesisD> is there an alternative to pointfree? it doesn't build with the latest ghc
19:53:21 <DanielDiaz> NemesisD: really? We should fix that...
19:53:48 <DanielDiaz> NemesisD: I don't know an alternative, but you can use lambdabot!
19:54:06 <NemesisD> DanielDiaz: yeah for me i get not in scope data constructor State
19:54:12 <NemesisD> i think that stuff may have gotten moved around?
19:54:20 <Rotaerk_> automated generation of pointfree code doesn't exactly generate readable pointfree code :P
19:55:06 <NemesisD> Rotaerk_: yeah i'm still trying to figure out reasonable times to go pointfree
19:55:31 <NemesisD> example: foo a b = bar $ baz a b
19:55:54 <NemesisD> i run into something like this every once in a while and i don't know if theres a sensible way to make it pointfree
19:56:04 <Rotaerk_> NemesisD, let (.:) = (.).(.) in foo = bar .: baz
19:56:06 <BMeph_> foo = bar .: baz
19:56:55 <NemesisD> hmm
19:57:06 <NemesisD> not sure if i'd use that
19:57:23 <Rotaerk_> let (.::) = (.).(.).(.) in foo3 = bar .:: baz
19:57:30 <Rotaerk_> equivalent to foo3 a b c = bar (baz a b c)
19:58:13 <DanielDiaz> @pl \a b -> bar (baz a b)
19:58:13 <lambdabot> (bar .) . baz
19:58:39 <Rotaerk_> NemesisD, you definitely  don't want to sacrifice readability for point-free-ness, because that defeats the point
19:58:53 <Rotaerk_> but sometimes it can actually make things more readable
19:59:20 <DanielDiaz> Rotaerk_: But it can be REALLY funny sometimes... For having a good time is amazing. At least, it was for me.
19:59:40 <Rotaerk_> you mean in the same way that C++ as a language is?
19:59:41 <Rotaerk_> :P
20:00:03 <NemesisD> Rotaerk_: i get a pretty good rush when i'm writing this HTTP API client library and all the top level functions are pointfree calls to lower level functions
20:00:06 <Rotaerk_> though that's got more cruelty to it I suppose
20:00:12 <DanielDiaz> Rotaerk_: Can't tell... I have never programmed in C++.
20:00:19 <ekyo> we'd need to add 7 more steps of ambiguity
20:00:19 <NemesisD> also is this known as an "eta reduce" or am i confusing my terms
20:00:24 <Rotaerk_> C++ is the perfect language to torture newbs with
20:00:37 <Rotaerk_> though haskell seems to be pretty good at that too
20:01:04 <DanielDiaz> Rotaerk_: You can use any language for that purpose... It depends on how you show it.
20:01:39 <DanielDiaz> NemesisD: eta-reduce is doing this: \x -> f x === f
20:01:43 <NemesisD> sometimes its sad being a haskeller at work, it makes me feel like a language hipster if i mention how great the language is and how long it may take to become proficient in it
20:02:07 * arbn wonders why Haskell people love to hate on C++ so much.
20:02:07 <DanielDiaz> NemesisD: I know how you feel!
20:02:38 <NemesisD> i could see haskell solving problems better than ruby at work but cannot in good conscience implement them in haskell
20:03:16 <ekyo> the good old "someone else must understand your code" enterprise rule?
20:03:17 <Rotaerk_> arbn, I loved to hate C++ long before I learned anything about haskell
20:04:02 <Rotaerk_> though perhaps it's because people who are drawn to haskell are programming language nerds
20:04:10 <NemesisD> ekyo: not really enterprise, just responsible software engineering. we were a team of 2 devs, just hired a junior
20:04:21 <Rotaerk_> and C++ is a bad programming language (though perhaps circumstantially useful)
20:04:38 <arbn> Rotaerk_: There are so many languages I dislike more than C++, that C++ doesn't seem so bad.
20:05:02 <NemesisD> the other senior dev has a passing interest in go, no interest in haskell. also considering it took us like a year just to find a hireable junior Ruby dev, probably wouldn't be a good idea for us to use it for anything important
20:05:11 * BMeph_ coughs in a way that suspiciously sounds like: *PHP*
20:05:17 <DanielDiaz> saying that "there are worse languages" is not argument for "this language is good"
20:05:31 <Rotaerk_> there are worse ways to die than suffocation
20:05:39 <Rotaerk_> so let's all suffocate
20:05:50 <arbn> Rotaerk_: If he's interested in Go, you should direct his interest toward Rust.
20:05:59 <Rotaerk_> whose?
20:05:59 <arbn> NemesisD: ^
20:06:12 <Rotaerk_> err who is "he"
20:06:17 * BMeph_ prefers Dart! ;p
20:06:31 <arbn> Rotaerk_: Sorry. Meant to highlight NemesisD.
20:06:36 <NemesisD> arbn: i wouldn't feel comfortable recommending rust without learning it and i've got no interest in that ATM
20:06:38 <Rotaerk_> ah k
20:07:18 <Rotaerk_> I'm pretty new to haskell, but I have a feeling I'm going to settle into it as my primary language (outside work)
20:07:35 <Rotaerk_> any limitations it has I think are at an academic level over my head at the moment
20:07:56 <NemesisD> from what i can tell he's interested in go because he believes it to have magical scaling sprinkles because its concurrency model isn't as broken as ruby's
20:09:38 <NemesisD> ruby's concurrency model is a musket that you can shoot yourself in the foot with, whereas go's concurrency model is a machine gun you can shoot yourself in the leg with
20:10:07 <NemesisD> the go part is just from what i've gathered, i have far less experience with it than ruby
20:13:53 <arbn> My favorite half-joking summary of Rust is "C if it were designed today by someone who knew only Haskell."
20:15:47 <no-n[3]> heh
20:16:03 <no-n[3]> does that mean Rust is good? :)
20:16:51 <arbn> I like what I've seen so far. Memory-safe, lightweight concurrency, typeclasses, ADTs, type inference.
20:17:29 * no-n[3] ndos
20:17:36 <arbn> Other than that... it's a lot like C/C++ in that's an imperative language for system programming.
20:17:42 <no-n[3]> currying?, laziness? :)
20:18:06 <simpson> Laziness is not necessarily what you want for systems work.
20:19:20 <arbn> No. No currying or laziness. It takes ideas from Haskell, but it's not Haskell. :P
20:19:45 <doomlord> C with a cleaned up syntax and a sane replacement for classes, and some functional programming ideas
20:20:35 <johnw> simpson: why not?
20:20:36 <Nisstyre-laptop> doomlord: Rust?
20:20:39 <doomlord> yes
20:20:54 <Nisstyre-laptop> doomlord: I dislike Rust. The concept is nice but it's a pain to use.
20:21:00 <Nisstyre-laptop> maybe they can make it easier to use
20:21:39 <doomlord> i'm just trying to decide how much time to put into it.. the thing is it seems my C++ complaints are quite petty
20:21:53 <arbn> Nisstyre-laptop: Do you find it less of a pain than C, C++, Go, or D, though?
20:21:55 <doomlord> i'm happy with C++ so long as i avoid classes
20:22:13 <doomlord> or rather minimize use of classes
20:22:22 <Nisstyre-laptop> arbn: it's harder to use than C, but harder to create bugs I suppose
20:22:34 <johnw> doomlord: the C++-as-a-better-C camp?
20:22:34 <Nisstyre-laptop> I haven't used the other ones enough to say
20:23:14 <doomlord> johnw very much so, the best featuers in C++are templates and overloading(and RAII), but free functions beat class-methods
20:23:27 <johnw> doesn't RAII imply classes?
20:23:44 <johnw> do you include exceptions?
20:23:45 <doomlord> yeah. but free functions wherever possible
20:23:46 <shachaf> This doesn't seem like the right channel for the True Nature Of C++.
20:23:51 <doomlord> not for me
20:24:00 <doomlord> oops
20:24:25 <doomlord> when i tried haskell i didn't really get into typeclasses, maybe after trying rust i should try it again
20:24:44 <Nisstyre-laptop> doomlord: type classes are integral to using Haskell effectively
20:24:48 <johnw> type classes are very, very handy
20:24:52 <doomlord> yeah. i didn't get very far with it
20:24:53 <johnw> they promote polymorphism
20:25:09 <johnw> which tend to reduce the possibility for bugs, by constraining the domain of a function
20:25:10 <doomlord> i gather rusts 'traits' are slightly cut down typeclasses
20:25:18 <doomlord> and i think rusts traits are awesome
20:25:25 <Nisstyre-laptop> lots of libraries have polymorphic return types that are constrained by a type class or classes
20:25:38 <doomlord> i think it just makes compile errors more constrained
20:25:53 <doomlord> the complaint people have with C++overloading is you never know what its expecting to find
20:26:09 <doomlord> but i'm used to it, just adding overloads ad-hoc
20:26:31 <Nisstyre-laptop> overloading isn't the right way to think about type classes
20:27:22 <doomlord> if you had to describe it in another languages' terms, how would you (if you could)
20:27:26 <johnw> doomlord: the problem I have with operator overloading is that it's very hard to know _when_ it's going to happen; in Haskell, there are only functions, and the type signature gives you the clue as the whether it's going to be a single function or a function selected from a type class instance
20:28:08 <Nisstyre-laptop> doomlord: you have the ability to take a class of types and specify that they are related, and they possibly implement a number of methods
20:28:09 <doomlord> its true that navigating code with operator overloading can be hell
20:29:21 <doomlord> Nisstyre-laptop, - the way i'd thought of traits in rust was .. describing a group of functions to be overloaded for a type... my c++ brain puts the word overload in there
20:29:55 <doomlord> rust traits made sense to me when i saw the explanation of the binary layout , and the fact rust needed them before i could do things i took for granted with overloading
20:30:25 <doomlord> but i gather haskell typeclasses can be 'parameterized with other typeclasses' ...
20:30:41 <doomlord> where i gave up with Haskell is the record system
20:30:58 <Nisstyre-laptop> doomlord: you can specify that a type must be an instance of another type class in order to be an instance of a given type class
20:31:01 <Nisstyre-laptop> if that's what you meant
20:31:30 <johnw> yes, a type class instance can induce another constraint; and I think maybe now with constraint kinds you can actually have a type class parameterized on another type class, can't you?
20:31:51 <Nisstyre-laptop> I haven't looked at constraint kinds
20:32:32 <Nisstyre-laptop> I'm still getting familiar with type families and data kinds
20:32:47 <doomlord> c++ .. template<template COLLECTION,typename A,typename B>  MySomething {   COLLECTION<A> someAs; COLLECTION<B> someBs;} <<< you cannot do this in C++ but supposedly haskell can get this effect?
20:32:58 <johnw> http://dorchard.wordpress.com/2011/09/22/constraint-kinds-in-haskell-finally-bringing-us-constraint-families/
20:33:26 <elliott> this rust stuff might be more appropriate in #haskell-blah?
20:33:30 <shachaf> doomlord: Yes, you can do something similar to that in Haskell.
20:34:05 <johnw> doomlord: you can do that in C++
20:34:14 <johnw> doomlord: template<template <class T> COLLECTION...
20:34:30 <shachaf> doomlord: But note that Haskell's parametric polymorphism isn't the same as C++'s templates.
20:34:37 <shachaf> johnw: Read that again. :-)
20:35:11 <johnw> shachaf: I don't get it, what am I missing?
20:35:42 <shachaf> Perhaps I'm the one who misunderstood.
20:37:06 <doomlord> i recall some C++hater/haskell lover explaining this sort of situation and i suggested #definees as a workaround :)
20:37:20 <jmcarthur> doomlord: wait, what is the thing you can't do in C++? the COLLECTION part? i thought you could do that...
20:37:53 <shachaf> Yes, I misread what johnw said.
20:38:19 <jmcarthur> although maybe not with that syntax
20:38:21 <doomlord> you could have MySomething< vector<int>, vector<string> >  but not MySomething< vector,int,string>
20:38:22 <shachaf> Maybe the question about Yoneda-in-Haskell would be more on-topic in here than in ##categorytheory.
20:38:47 <jmcarthur> Yoneda-in-Haskell?
20:39:11 <jmcarthur> the question of wtf the definition of Yoneda in Haskell has to do with the yoneda lemma?
20:39:19 <jmcarthur> if that's it, i would also love to know
20:39:28 <shachaf> No, the question in the other channel. I didn't ask it.
20:39:45 <jmcarthur> well i'm not in there
20:39:58 <shachaf> Right.
20:40:07 <jmcarthur> i think we're talking past each other
20:40:14 <jmcarthur> i mean to be asking what the question is
20:40:38 <shachaf> jmcarthur: johnw asked a question about Yoneda in ##categorytheory which seemed to me to be about Haskell. I'm suggesting that maybe it'd be better placed in here.
20:41:10 <shachaf> But it's up to him. I don't talk in the other channel so I can only answer in here.
20:41:27 <johnw> shachaf: you think?  I'm willing to ask it here
20:41:35 <h4199> What was the question??
20:41:40 <jmcarthur> oh good grief you two are leaving me in suspense
20:41:48 <shachaf> jmcarthur: You deserve it.
20:41:59 <jmcarthur> thanks
20:42:02 <shachaf> jmcarthur: (The joke is that other question you refuse to reveal.)
20:42:07 <jmcarthur> lol
20:42:25 <jmcarthur> i am willing to reveal it as an interview question
20:42:39 <jmcarthur> in the context of an interview, that is
20:42:46 <johnw> (one sec)
20:42:47 <sw2wolf> @type mapM
20:42:49 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:42:56 <shachaf> OK. I will ask my journalist friend to interview you and ask you the question.
20:43:13 <shachaf> Anyway, now people are talking in there.
20:43:17 <jmcarthur> *sigh*
20:43:21 <shachaf> jmcarthur: I didn't actually understand the question.
20:43:41 <shachaf> That's why I mentioned that he could restate it in here. Then I could ask for clarification.
20:44:25 * cmccann wonders if jmcarthur and shachaf are working on some sort of comedy routine here
20:44:33 <cmccann> starting to feel a bit like who's on first
20:44:35 <jmcarthur> i deduce from the talk in ##categorytheory that the question was why Yoneda f and f are isomorphic when f is a functor
20:45:18 <shachaf> No, the question was <johnw> is it also true to say that (forall b. (a -> b)) ≅ a?
20:45:28 <jmcarthur> cmccann: i was as confused as you are up until i realized this was shachaf's way of getting back at me
20:45:38 <jmcarthur> shachaf: ah, thanks
20:45:41 <shachaf> But I think that question indicates some sort of other misunderstanding.
20:45:47 <jmcarthur> yeah
20:45:49 <cmccann> being confusing is shachaf's way of doing many things.
20:45:50 <shachaf> Which is why I would have asked for clarification.
20:46:15 <NemesisD> man i do not know how to use leading comma style syntax
20:46:21 <shachaf> jmcarthur: I wasn't actually intending to get back at you.
20:46:59 <jmcarthur> i did not intend that to sound like either side is being bitter
20:47:44 <shachaf> I'm not bitter.
20:47:46 <dolio> That's the same as asking if a -> ⊥ is isomorphic to a.
20:47:57 <shachaf> dolio: Exactly.
20:49:49 <cmccann> it's not isomorphic to a, and isomorphic to not a!
20:50:36 <jmcarthur> but is "not isomorphic to a" isomorphic to "isomorphic to not a"?
20:50:59 <cmccann> probably not.
20:52:23 <Nisstyre-laptop> jmcarthur: what is "not a"?
20:53:15 <cmccann> Nisstyre-laptop: in this context, a "function" that takes something of type "a" as an argument and never returns
20:53:30 <Nisstyre-laptop> ah okay
20:53:50 <cmccann> in a total language that shows that type "a" is uninhabited
20:54:30 <cmccann> another way to look at it is that "not a" is the type of continuations accepting something of type "a"
20:55:05 <cmccann> in Haskell it's probably just a function that evaluates to _|_ which is lame
20:56:13 <jmcarthur> so... when do we get -XTerminationChecker
20:56:16 <Nisstyre-laptop> cmccann: by continuations, are you including delimited continuations, or?
20:56:28 <dolio> No.
20:56:41 <cmccann> I'm explicitly excluding those.
20:56:45 <Nisstyre-laptop> :P
20:56:46 <cmccann> as well as ContT
20:57:44 <cmccann> however, inside "ContT r" a function of type "a -> r" is similar
20:57:54 <johnw> shachaf: ok, whole bunch of stuff happened here all at once, so I had to disappear for a moment
20:58:53 <cmccann> Nisstyre-laptop: are you now suitably enlightened and/or confused?
20:59:04 <johnw> as I understand it, and please correct me if this is wrong, in category theory we know nothing about objects themselves.  As such, the "meaning" of an object lies in what we know about it's morphisms to and from the other objects in its category.  Thus, "knowing something about some object X" is equivalent to "knowing something about all the morphisms involving X"
20:59:08 <cmccann> or, at very least, not unenlightened and not unconfused?
20:59:43 <Nisstyre-laptop> cmccann: I kind of get it
21:00:52 <johnw> so there's some kind of meaningful a connection between a, and forall b. (a -> b), which in yoneda is expressed through an embedding in some functor F.  I'm wondering why the embedding in the Functor is necessary
21:01:20 <hpaste> orzo pasted “commuteST” at http://hpaste.org/86152
21:01:26 <orzo> hi
21:01:29 <johnw> and I think tomprince just answered me :)
21:02:35 <orzo> i have a commuteST function there that uses unsafe calls.  I'm not clear on how it could cause a problem if it can, but i'm not sure it can't either.  Anyone care to take a look at it and comment?  It's 3 lines of code and a type signature.
21:03:10 <jmcarthur> johnw: in category theory it's not that we don't necessarily know anything about objects, it's just that we explicitly don't *want* to know. it's part of abstracting and generalizing over complicated things to get a simpler way of looking at them
21:05:02 <jmcarthur> orzo: i can't say i feel like that is a good idea
21:05:15 <jmcarthur> orzo: why not:
21:05:23 <jmcarthur> :t sequenceA
21:05:33 <lambdabot>     Not in scope: `sequenceA'
21:05:33 <lambdabot>     Perhaps you meant one of these:
21:05:33 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
21:05:41 <jmcarthur> :t Data.Traversable.sequenceA
21:05:43 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:06:14 <jmcarthur> orzo: ^^ f is your ST s, t is your m
21:06:42 <johnw> jmcarthur: right
21:06:49 <parcs> johnw: i thought i was a and forall b. (a -> b) -> b
21:06:52 <orzo> that might be good for my purposes, but my m is side efecting, does Traversable interfere with that?
21:06:57 <parcs> it
21:06:57 <johnw> parcs: yes, that was clarifiedto
21:07:06 <johnw> and when you take the F to be identity, it is exactly that
21:07:07 <jmcarthur> orzo: what do you mean "interfere"?
21:07:17 <jmcarthur> orzo: and what do you mean "side effecting"?
21:07:29 <orzo> well, some version of my code used to assume Foldable
21:08:18 * cmccann effects some sides
21:08:19 <jmcarthur> in the presence of real side effects, anything could potentially "interfere", but you shouldn't have real side effects in haskell in the absense of unsafePerformIO (barring "benign" side effects like nontermination)
21:08:21 <orzo> which makes a lot of sense, but Foldable lets you access the elements by using toList (for example).  But I was experimenting with an ST-based monad that cannot implement Foldable.  Can it implement Traversable?
21:08:39 <jmcarthur> Traversable requires Foldable
21:08:47 <startling> orzo: if something can't be foldable, it can't be traversable
21:13:28 <orzo> okay, thanks, I think sequenceA will work for me
21:13:51 <orzo> although, the original question is interesting from a curiosity stand point still
21:15:01 <orzo> maybe nothing can go wrong with it
21:15:39 <orzo> and Monad is less of a requirement than Traversable
21:18:05 <startling> I don't think they're comparable
21:19:46 <orzo> traversable might be hard for me to imploement actually
21:19:49 <orzo> i have foldable
21:20:09 <cmccann> > compare "Monad" "Traversable"
21:20:11 <lambdabot>   LT
21:20:12 <cmccann> problem solved!
21:21:45 <orzo> does traversable require you to be able to fold and unfold and get back what you started?  because i can't do that, my fold discards information
21:22:03 <startling> orzo: nah
21:22:11 <shachaf> I don't know what fold and unfold mean here.
21:22:25 <startling> all folds discard information, don't they?
21:22:33 <startling> well, other than foldMap id I guess
21:22:40 <shachaf> No.
21:23:22 <startling> oh, I guess folds on nested things necessarily through out information
21:23:26 <startling> *throw
21:23:37 <cmccann> > foldr (:) [] "information"
21:23:39 <lambdabot>   "information"
21:23:52 <orzo> yes but you can rebuild things by unfolding, like a fold over a list that gives you back the same list is easy enough
21:23:53 <startling> whereas "flat" list-like things don't.
21:24:04 <shachaf> traversable has no concept of "unfold"
21:24:12 <orzo> but a fold over my monad that gives you back what you started with is impossible
21:24:18 <shachaf> There is Foldable but that's just toListable, more or less.
21:24:22 <orzo> you do not have enough information to recreate the original
21:25:01 <orzo> yes, i already implemented Foldable
21:25:05 <shachaf> It's required e.g. that (runIdentity . traverse Identity) = id
21:25:12 <shachaf> Is that what you're asking?
21:25:29 <orzo> dunno, let me read the docs some
21:25:39 <edwardk> preflex: xseen shapr
21:25:40 <preflex>  shapr was last seen on freenode/#haskell 4 days, 4 hours, 6 minutes and 9 seconds ago, saying: Is there already a TH+QC golf module that tries to simplify a given expression?
21:26:52 <startling> orzo: I think I understand you.
21:27:12 <startling> where Foldable x means "x can be made into a list", Traversable x says "x can be made into an x"
21:27:36 <shachaf> I don't follow what startling said.
21:28:18 <startling> maybe I'm confused, then.
21:28:22 <Rotaerk_> hmm just realized I don't understand when to use "X -> Y" versus "(HasX a) => a -> Y" , where "class HasX a where xLens :: Lens' a X"
21:29:18 <elliott> if you can't pick, then the former.
21:29:41 <shachaf> Making your own type classes should be considered advanced.
21:30:27 <cmccann> I love needlessly abusing type classes, it is so easy
21:31:58 <startling> instance HasCMcCann CMcCann where cmccannLens = id
21:32:21 <cmccann> sounds useful!
21:34:07 <no-n[3]> is there some library function that's about the same as "let f x xs = (x `elem`) $ map fst xs"?
21:34:20 <no-n[3]> pretty much Map.Member but for [(a,b)] lists
21:34:42 <shachaf> @ty (isJust .) . lookup
21:34:43 <lambdabot> Eq a => a -> [(a, a1)] -> Bool
21:34:54 <no-n[3]> ah, neato :)
21:35:12 <shachaf> (Note: Don't use the (f .) . g idiom. Just name your parameter.)
21:35:37 <elliott> "idiom"
21:35:42 <no-n[3]> never seen ".) .". looks confusing
21:35:46 <elliott> is there a word for something like an idiom but awful
21:35:56 <sproingie> php
21:36:02 <no-n[3]> ha
21:36:05 <shachaf> elliott: s/m/t/?
21:36:12 <cmccann> elliott: idiotm?
21:36:13 <sproingie> definitely php
21:37:07 <shachaf> sproingie: Is that actually relevant to anything or are you just looking for an opportunity to insult PHP? :-)
21:37:40 <sproingie> just venting at having to have touched it lately
21:38:34 <Rotaerk_> hmm, actually, I guess taking a t where HasX t is preferable to just taking an X when you want there to be only one X for a given t
21:38:54 <johnw> Ralith: ping!
21:39:02 <Ralith> johnw: hullo
21:39:07 <johnw> Ralith: http://www.reddit.com/r/haskell/comments/1cq1w1/are_the_llvmcore_bindings_still_being_maintained/
21:39:12 <Ralith> oo
21:39:13 <johnw> thought you'd be the one to answer that
21:39:32 <shachaf> johnw: Why not just send the Reddit link straight off, instead of the ping? :-)
21:39:41 * shachaf , proponent of don't-ask-to-ask
21:39:47 <Rotaerk_> in my case, I think it makes sense; this is an entity table, and I want an entity-context to only have one table per type of entity, so that a given EntityId entityType would have no ambiguity as to which table it should be looked-up in
21:39:51 <johnw> shachaf: i'm old school like that, I guess
21:40:08 <Ralith> johnw: yeah, thanks for the heads up
21:40:48 <cmccann> everyone should start asking shachaf whether they can ask whether they can ask a question.
21:40:56 <cmccann> you know, to get his permission.
21:41:01 <shachaf> Yep.
21:41:04 <johnw> shachaf: can I ask you something about dont-ask-to-ask?
21:41:15 <latermuse> Is there an easy way to take this input: [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")] and get this output: [("1","ace"),("2","bf"),("3","d")] ?
21:41:16 <shachaf> You are late.
21:41:24 <johnw> sigh
21:41:49 <shachaf> latermuse: Do you care about the ordering?
21:42:05 <startling> latermuse, you could do it with Map a little bit more easily
21:42:09 <shachaf> > M.toList . M.fromListWith (++) $ [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")]
21:42:11 <lambdabot>   [("1","eca"),("2","fb"),("3","d")]
21:42:22 <latermuse> no, it doesnt matter
21:42:26 <johnw> Map.unionWith (<>) $ Map.fromList  [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")]
21:42:40 <shachaf> johnw: ?
21:42:43 <johnw> > Map.unionWith (<>) $ Map.fromList  [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")]
21:42:45 <startling> johnw, that's not what that does
21:42:46 <lambdabot>   Not in scope: `Map.unionWith'
21:42:46 <lambdabot>  Perhaps you meant one of these:
21:42:46 <lambdabot>    `M.unionW...
21:42:56 <startling> :t Map.unionWith
21:42:57 <lambdabot> Couldn't find qualified module.
21:43:01 <johnw> :t M.unionWith
21:43:02 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
21:43:16 <johnw> > M.unionWith (<>) $ M.fromList  [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")]
21:43:18 <lambdabot>   *Exception: show: No overloading for function
21:43:29 <startling> johnw, it unifies two maps
21:43:33 <johnw> oh
21:43:36 <shachaf> johnw: Look a few lines up for the way to do it with Data.Map.
21:43:47 <johnw> ah, fromListWith
21:43:50 <johnw> thanks, that's a new one
21:43:52 <latermuse> Im using the Data.Text library for this
21:43:59 <cmccann> > Map.fromList  [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")]
21:44:01 <lambdabot>   Not in scope: `Map.fromList'
21:44:01 <lambdabot>  Perhaps you meant one of these:
21:44:01 <lambdabot>    `M.fromLis...
21:44:04 <cmccann> > M.fromList  [("1","a"),("2","b"),("1","c"),("3","d"),("1","e"),("2","f")]
21:44:05 <latermuse> Is it possible to do it without converting to a map first?
21:44:06 <lambdabot>   fromList [("1","e"),("2","f"),("3","d")]
21:44:07 <johnw> latermuse: then use <> instead of ++
21:44:07 <startling> latermuse: then use (<>) rather than (++)
21:44:12 <cmccann> see, it's already too late at that point
21:44:40 <latermuse> so convert it to map, then use <>?
21:45:02 <cmccann> converting to a Data.Map is what's actually doing the work
21:45:17 <cmccann> just convert back to a list immediately if you want
21:45:20 <Ralith> latermuse: anything else you might do would be either slower than or isomorphic to converting it to a map first.
21:45:21 <latermuse> I see. so why would I use <> instead of ++?
21:45:28 <cmccann> latermuse: for Text
21:45:31 <cmccann> vs. String
21:45:36 <startling> :t (<>) -- latermuse
21:45:38 <lambdabot> Monoid m => m -> m -> m
21:45:58 <latermuse> ahhhh i understand
21:46:02 <latermuse> thanks guys :)
21:48:13 <latermuse> which library is (<>) imported from?
21:48:18 <johnw> Data.Monoid
21:48:22 <latermuse> thanks
21:48:30 <johnw> is it in the Prelude in 7.6?
21:49:07 <johnw> :i (<>)
21:49:31 * hackagebot hlibgit2 0.17.0.8 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.17.0.8 (JohnWiegley)
21:49:44 <cmccann> lambdabot doesn't do :i
21:50:40 <startling> cmccann: I thought you were saying "lambdabot doesn't do" and :i was an emoticon
21:51:05 <startling> :t do undefined -- lambdabot clearly does do
21:51:06 <lambdabot> a
22:08:16 <BMeph_> I object to that do! >:(
22:30:17 <dmwit> > don't do undefined
22:30:19 <lambdabot>   <hint>:1:7: parse error on input `do'
22:30:24 <dmwit> > don't undefined
22:30:26 <lambdabot>   ()
22:49:32 * hackagebot language-java 0.2.4 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.4 (VincentHanquez)
23:28:02 <latermuse> whenever head annoys me, i just rewrite it. is that common practice?
23:28:21 <latermuse> and by annoy, i mean: *** Exception: Prelude.head: empty list
23:29:08 <coppro> no
23:29:15 <coppro> it's common practice not to give head empty lists
23:29:37 <elliott> latermuse: rewrite it to do... what?
23:29:44 <latermuse> to not give that error
23:30:03 <latermuse> it feels hacky to do it, but it works well in some applications
23:30:07 <geekosaur> common practice is to use pattern matching instead
23:30:14 <coppro> use listToMaybe if you must
23:30:38 <geekosaur> or there's ```take 1```
23:30:42 <elliott> what can it do instead of giving an error?
23:30:44 <elliott> give another error?
23:31:16 <latermuse> for instance, if head [] == error, then I change it to head [] == "". it doesnt give an error then
23:31:31 <latermuse> and as long as "" fits the type for what im using it for, it seems to compile and work just fine
23:31:38 <gienah> @hackage safe
23:31:38 <lambdabot> http://hackage.haskell.org/package/safe
23:31:38 <coppro> of course it will
23:32:04 <latermuse> easier than using pattern matching in some situations
23:32:11 <elliott> latermuse: I think you are mistaken.
23:32:14 <elliott> > head [] == ""
23:32:15 <lambdabot>   *Exception: Prelude.head: empty list
23:32:22 <geekosaur> if you're going to write perl, write it in perl...
23:32:30 <elliott> oh.
23:32:36 <elliott> I see what you mean. you define a local head function.
23:32:42 <latermuse> yes
23:32:52 <latermuse> head' [] = ""
23:32:59 <latermuse> head' (x:_) = x
23:33:02 <gienah> @hoogle safeMay
23:33:02 <lambdabot> No results found
23:33:10 <elliott> latermuse: I have an alternate suggestion: write fromMaybe "" . listToMaybe, or headDef "" (using the safe package).
23:33:20 <dolio> There's something very weird about that Ackermann function on reddit.
23:33:24 <Eelis> latermuse: that's a misleading definition because it doesn't do what the name suggests
23:33:26 <gienah> @hoogle headMay
23:33:26 <lambdabot> No results found
23:33:30 <elliott> latermuse: I have another suggestion: don't think about head and tail at all. then pattern matching will not seem like more of a bother.
23:33:32 <Eelis> latermuse: so you're misleading readers of your code
23:33:33 <dolio>  /stack overflow.
23:33:42 <elliott> latermuse: if you think about pattern matching, then you will better understand the structure of your code.
23:34:08 <elliott> latermuse: and you will likely discover that patching over taking the head of an empty list by, e.g. using "" instead, was actually causing subtly incorrect behaviour in some of your functions.
23:34:27 <gienah> the safe package provides: headMay :: [a] -> Maybe a
23:34:33 <elliott> (better yet, use something like foldr directly. then you're a level of abstraction higher, and it's likely to be the least typing of all.)
23:34:46 <latermuse> elliott: I only use it in very specific scenarios, where it cannot create incorrect behavior
23:34:48 <elliott> gienah: indeed, though that's in base as listToMaybe, so not worth the dependency for
23:35:13 <latermuse> I learned this technique after reading a paper by one of the simons about errors in haskell
23:35:28 * latermuse shrugs
23:36:06 <Eelis> i like to combine  maybeHead :: [a] -> Maybe a  with   orElse :: Maybe a -> a -> a  so that i can write   maybeHead l `orElse` bla
23:36:19 <latermuse> this is the paper, by the way: http://research.microsoft.com/en-us/um/people/simonpj/papers/stack-trace/DebugTraces.pdf
23:37:03 <elliott> Eelis: those are both available in base :)
23:37:07 <elliott> orElse as fromMaybe, though flipped
23:37:10 <Eelis> elliott: with names i don't like :)
23:37:24 <elliott> yeah, listToMaybe is especially a bad name.
23:37:27 <elliott> it's not a conversion at all.
23:38:44 <Eelis> bla `fromMaybe` listToMaybe l   yuck ;)
23:39:33 * hackagebot conjugateGradient 2.2 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-2.2 (LeventErkok)
23:43:51 <arkeet> head (blah : l)
23:44:00 <arkeet> er oops
23:44:09 <arkeet> head (l ++ [blah])
23:47:42 <elliott> arkeet: but that's so partial-looking.
