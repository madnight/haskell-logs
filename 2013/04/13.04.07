00:01:38 <lightquake> computations are functions
00:01:43 <lightquake> sort of
00:02:00 <otters> if there's one thing I've learned in #haskell, it's "your explanation is wrong"
00:02:06 <lewis1711> I mean because haskell is lazy a "Shpider" doesn't exist until it's run so you can't derive show on it? or something
00:02:34 <otters> lewis1711: you can show a Shpider but you can't show any function
00:02:49 <arkeet> what?
00:03:02 <otters> because
00:03:13 <otters> to derive Show for StateT, you'd have to have a Show instance for its constructor
00:03:18 <otters> which is a function
00:03:29 <arkeet> yes
00:04:11 <lightquake> lewis1711: you can't show a Shpider Int because a Shpider Int is equivalent to a function
00:04:51 <lewis1711> and why can't you show a function again?
00:05:04 <otters> how would you go about doing that?
00:05:32 <lewis1711> couldn't it be done the same way as other languages with repls?
00:05:39 <otters> how do they do it?
00:05:40 <lewis1711> "#<procedure:+>"
00:05:50 <augur_> otters: you can show functions perfectly well
00:05:53 <lewis1711> I mean it'd be useless
00:06:03 <lewis1711> but I don't see why it's impossible
00:06:05 <lightquake> lewis1711: you could do that, but generally trying to show a function is an error
00:06:07 <otters> augur_: there's no Show instance for ((->) r) by default
00:06:08 <augur_> otters: what you cant do is show haskell functions because haskell functions dont have a show instance
00:06:17 <otters> ...
00:06:17 <augur_> not for any deep principled reason
00:06:25 <otters> yeah
00:06:26 <lightquake> as in, an error in the correctness of your code
00:06:28 <otters> that's what i'm saying
00:06:32 <augur_> more because its nice to compile functions down, not keep them as lambdas
00:06:48 <ion> Test.SmallCheck contains a Show instance for functions that is actually somewhat useful.
00:06:56 <lightquake> you could do instance Show (a -> b) where show _ = "some function!"
00:06:56 <ion> Well, for a subset of functions.
00:07:03 <lightquake> ion: what's the instance?
00:07:09 <Mortchek> I think it's also nice not to be able to distinguish between two identical functions with different representations.
00:07:12 <elliott> a Show instance for functions that gave any useful information would violate substitution of equals
00:07:37 <augur_> elliott: would it?
00:07:38 <elliott> (well, depending on how stringent your criteria for usefulness is)
00:07:56 <arkeet> an injective show instance for functions cannot exist.
00:08:00 <shachaf> A show instance that would "keep them as lambdas" and use that information certainly would.
00:08:04 <elliott> augur_: yes. construct two functions whose equivalence on all inputs is unknown
00:08:05 <ion> lightquake: It generates a number of inputs and shows a map from the inputs to the respective outputs.
00:08:08 * hackagebot monad-stm 0.1.0.2 - MonadSTM class analogous to MonadIO  http://hackage.haskell.org/package/monad-stm-0.1.0.2 (MiguelMitrofanov)
00:08:14 <elliott> now your Show instance is giving two different results for what may be the same function
00:08:21 <arkeet> because e.g. Nat -> Nat is not countable
00:08:21 <startling> show _ = "today is the 7th of april, 2013.""
00:08:26 <arkeet> and String is countable
00:08:32 <lightquake> if you assume that every type is an instance of Typeable, you could construct a show instance that just shows you the type
00:08:38 <elliott> right, it would also do screwy things from a cardinality perspective
00:08:41 <shachaf> @slap lightquake
00:08:41 * lambdabot is overcome by a sudden desire to hurt lightquake
00:08:44 <augur_> elliott: thats only relevant if you're considering extensional equality
00:08:49 <shachaf> You and I both, lambdabot.
00:08:49 <arkeet> no
00:09:05 <ion> lightquake: I think lambdabot had something like that before. But i may remember incorrectly.
00:09:12 <augur_> elliott: obviously intensional equality will just rule them unequal
00:09:20 <lewis1711> when I want to hit someone on IRC I just yell a swear word very loudly, then respond calmly. I mean they can't hear what I yell.
00:09:24 <arkeet> augur_: ??
00:09:33 <shachaf> You forgot to mention pointer equality!
00:09:35 <elliott> augur_: it absolutely will not...
00:09:47 <elliott> you will be unable to prove equality but you will not be able to prove inequality
00:09:49 <augur_> elliott: well, it will rule them unknown, rather.
00:09:53 <lightquake> shachaf: what was that for? :(
00:10:00 <shachaf> lightquake: Global Typeable.
00:10:01 <elliott> anyway, this is -blah material
00:10:07 <lightquake> isn't that in 7.8?
00:10:10 <augur_> elliott: but i dont see how having a show instance makes a difference there
00:12:14 <augur_> elliott: but if the show instance is giving two results, then the two inputs are not definitionally equally, at the least, so i dont see the issue
00:13:07 <augur_> if we want to be extensional, well, obviously things are different. but extensionality is a pain in the ass anyway
00:13:51 <elliott> if show f /= show g then f /= g. the fact that you may not be able to prove f = g intensionally for two functions that coincide on all inputs is miles away from being able to prove f /= g
00:14:11 <augur_> sure, show f /= show g implies f /= g
00:14:15 <elliott> and breaks important reasoning properties (like optimisation being sound). but this is seriously sidetracked, anyway.
00:14:18 <augur_> so what? how does that cause problems for substitutivity
01:02:15 <hpaste> SaBer pasted “Tree recursion and list concatenation” at http://hpaste.org/85341
01:02:28 <SaBer> Is there any way to get rid of the concatenation there?
01:03:18 <shachaf> @ty let split :: [a] -> ([a], [a]) -> [([a], [a])]; split [] pair = return pair; split (x:xs) (left, right) = split xs (x:left, right) ++
01:03:21 <shachaf> Er.
01:03:21 <lambdabot> parse error (possibly incorrect indentation)
01:03:27 <shachaf> @ty let split :: [a] -> ([a], [a]) -> [([a], [a])]; split [] pair = return pair; split (x:xs) (left, right) = split xs (x:left, right) ++ split xs (left, x:right) in split
01:03:29 <lambdabot> [a] -> ([a], [a]) -> [([a], [a])]
01:03:52 <shachaf> > let split :: [a] -> ([a], [a]) -> [([a], [a])]; split [] pair = return pair; split (x:xs) (left, right) = split xs (x:left, right) ++ split xs (left, x:right) in split "abcd"
01:03:54 <lambdabot>   *Exception: show: No overloading for function
01:04:03 * shachaf sighs
01:04:07 <shachaf> > let split :: [a] -> ([a], [a]) -> [([a], [a])]; split [] pair = return pair; split (x:xs) (left, right) = split xs (x:left, right) ++ split xs (left, x:right) in split "abcd" ([],[])
01:04:09 <lambdabot>   [("dcba",""),("cba","d"),("dba","c"),("ba","dc"),("dca","b"),("ca","db"),("...
01:05:30 <shachaf> Do you want to avoid the concatentation for performance or what?
01:05:37 <shachaf> You could do it DList-style.
01:06:15 <SaBer> yes, the performance blows up around the length of 15. It will probably blow up anyway, but hopefully not that much :)
01:07:12 <shachaf> Well, does something like this help? split [] pair = (pair:); split (x:xs) (left, right) = split xs (x:left, right) . split xs (left, x:right)
01:07:26 <shachaf> Where you apply the final function to []
01:08:47 <finishingmove> if i do :set editor in GHCi it is valid only until i :quit
01:08:55 <finishingmove> how can i set my preferred editor permanently?
01:10:45 <elliott> finishingmove: you can put :set editor foo in ~/.ghci
01:10:50 <elliott> (assuming you are on a unix-like system)
01:11:02 <finishingmove> win 7
01:11:22 <SaBer> shachaf: sorry, I didn't get what you meant in your last comment
01:11:30 * SaBer is trying out DList...
01:11:42 <augur_> elliott: ??
01:11:50 <shachaf> SaBer: You don't need to use the module DList
01:12:03 <shachaf> My one-liner does the same thing.
01:12:15 <mikeplus64> finishingmove: maybe .ghci in hour home directory
01:12:15 <shachaf> > let split [] pair = (pair:); split (x:xs) (left, right) = split xs (x:left, right) . split xs (left, x:right) in split "abc" ([],[]) []
01:12:17 <lambdabot>   [("cba",""),("ba","c"),("ca","b"),("a","cb"),("cb","a"),("b","ca"),("c","ba...
01:12:27 <shachaf> SaBer: Like that.
01:13:58 <klugez> finishingmove: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
01:14:03 <SaBer> shachaf: ok, that helped a lot
01:14:33 <shachaf> With the performance?
01:14:47 <shachaf> Hooray, my 1AM random guesses help people!
01:14:57 <shachaf> Now you should figure out how it works. :-)
01:15:45 <arkeet> it's good to understand why difference lists work.
01:15:56 <SaBer> shachaf: yep, thanks :) I pretty new to haskell...
01:16:32 <arkeet> :t Endo . mappend
01:16:33 <lambdabot> Monoid a => a -> Endo a
01:16:34 <finishingmove> klugez, thanks, that worked
01:16:45 <shachaf> SaBer: This technique applies even beyond Haskell.
01:17:03 <arkeet> :t flip appEndo mempty
01:17:05 <lambdabot> Monoid c => Endo c -> c
01:17:11 <SaBer> shachaf: I'm sill not sure if I can bruteforce the actual problem this is related to, but at least I'm learning :)
01:17:22 <shachaf> is this "project euler"
01:17:28 <SaBer> shachaf: no
01:17:31 <shachaf> Whew.
01:17:40 <arkeet> shachaf really doesn't like project euler.
01:18:38 <shachaf> arkeet: Eh.
01:19:02 <shachaf> It tends to be harmful in the contexts it comes up in in this channel.
01:19:30 <RenJuan> rly, why?
01:19:45 <shachaf> I shouldn't've brought it up.
01:19:46 <RenJuan> I mean what are those contexts?
01:19:47 <shachaf> Never mind.
01:20:07 <RenJuan> isn't it just a set of problems, abstract ones?
01:20:41 <RenJuan> ok, np
01:20:55 <shachaf> hi Argue
01:21:09 <arkeet> @let cayley = Endo . mappend
01:21:11 <lambdabot>  Defined.
01:21:19 <arkeet> @let uncayley = flip appEndo mempty
01:21:21 <lambdabot>  Defined.
01:22:49 <shachaf> arkeet: plz fix ghc to support impredicative lenses thx
01:29:41 <shachaf> elliott: Your head is a terrible place for jokes.
01:29:46 <shachaf> You should let them out into the world.
01:29:49 <shachaf> arkeet: Wouldn't you agree?
01:29:59 <shachaf> Hmm, maybe that should've been #-blah
01:38:06 <shachaf> @unmtl NonDet a
01:38:06 <lambdabot> forall b. ((a -> b -> b) -> b -> b)
01:38:19 <shachaf> @unmtl NonDetT M a
01:38:19 <lambdabot> forall b. ((a -> M b -> M b) -> M b -> M b)
02:08:14 * hackagebot hmemdb 0.2.0.3 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.2.0.3 (MiguelMitrofanov)
02:15:46 <hpaste> “http://johanesgultom.blogspot.com/2013/04/konsumen-cerdas-paham-perlindungan.html” pasted “Konsumen cerdas paham perlindungan konsumen” at http://hpaste.org/85346
02:33:14 * hackagebot terminal-progress-bar 0.0.1.2 - A simple progress bar in the terminal  http://hackage.haskell.org/package/terminal-progress-bar-0.0.1.2 (PetrRockai)
02:34:45 <shachaf> Do you need initial-progress-bar to make that useful?
02:36:19 <Saizan> do you have an initial to use it with?
02:39:06 <aristid> somehow an initial look at hmemdb makes me think it's not that performant.
02:39:45 <aristid> which is a totally unjustified opinion based on how little information i've used to obtain it :D
02:40:05 <aristid> but... tabContent :: TVar (M.Map Integer (TVar (Maybe r))),
02:43:15 * hackagebot terminal-progress-bar 0.0.1.3 - A simple progress bar in the terminal  http://hackage.haskell.org/package/terminal-progress-bar-0.0.1.3 (PetrRockai)
02:52:51 <arkeet> what I don't get is why it depends on base-unicode-symbols.
02:53:20 <shachaf> Because it uses ℤ
02:53:44 <arkeet> yes, why?
02:53:45 <arkeet> :p
02:53:47 <no-n[1]> is there a haskell equivalent to "from Module import function as func"?
02:54:00 <arkeet> no
02:54:04 <osfameron> arkeet: because ZZ would be too easy to type?
02:54:05 <no-n[1]> ok
02:54:58 <elliott> arkeet: base-unicode-symbols is actually Latin for show-off
02:55:24 <arkeet> I'm sleepy.
02:58:49 <ion> no-n: Not per se, but you can import a module qualified and then define a value that calls something the module exports.
02:59:02 <ion> But that may not be worth the trouble.
02:59:58 <xnoise> hello
03:02:40 <typoclass> xnoise: hi
03:03:29 <xnoise> i am just starting learning haskell, but i am getting a little chills because of the math involved in some more complex constructs
03:03:40 <xnoise> later on
03:04:12 <xnoise> so far, is pretty simple and easy to understand. Any ideea wether i should start olooking over math, and if so, where would one start?
03:05:01 <arkeet> I don't think it's exactly necessary
03:05:33 <elliott> xnoise: what mathematics are you referring to?
03:05:40 <xnoise> well, i keep hearing about mon
03:05:47 <xnoise> ads, monoids and so om
03:06:00 <xnoise> sorry, new kb
03:06:20 <shachaf> Nah, don't worry about that.
03:06:38 <arkeet> to the programmer, those are just abstractions of common patterns.
03:06:38 <typoclass> xnoise: it depends on what you mean by math, but in my personal opinion, it's not necessary
03:06:43 <xnoise> and in general haskell does not look like your general variety of programming language
03:06:57 <xnoise> ok :)
03:07:03 <xnoise> thanks
03:07:14 <arkeet> mathematicians are interested in them for different reasons, so I don't know how much you'd get out of learning the math.
03:07:36 <xnoise> ok, thank you for the answers
03:09:37 <typoclass> xnoise: roughly, a monoid is s a thing to which you can append. for example, there's a monoid instance for lists
03:10:58 <xnoise> the thing is i got a little scared, looking through some more advanced presentations and so on in which alot is being discussed in really abstract terms. Learn you a haskell does a pretty nice job so far of keeping things simple
03:11:30 <xnoise> i haven't yet reached monads, i am barely playing with functions, let bindings and so on at the moment
03:11:56 <typoclass> xnoise: i think it may help if you just treat it as "weird names". it's nothing magical. Monad is a typeclass with three or four functions in it; there's various instances of the typeclass; it's used in some places in the standard library; there's a bit of haskell syntax ("do blocks") which is translated into function calls of this typeclass
03:11:58 <xnoise> just wanted to know wether i should also keep in mind some math for the future
03:12:15 <shachaf> The term "monoid" isn't particularly more abstract than the term "abstract base class" or something.
03:12:24 <xnoise> ok, i will do so
03:12:56 <xnoise> @shachaf : never thought at terms like that :)
03:12:56 <lambdabot> Unknown command, try @list
03:13:37 <typoclass> shachaf: i'm not sure about that
03:15:05 <shachaf> I mostly just picked that term because it has the word "abstract" in it and has the right kind. :-)
03:17:16 <vlatkoB>  be wrong with this?
03:17:17 <vlatkoB> yap :: IO [String] -> IO ()
03:17:17 <vlatkoB> yap xs = do s <- xs; mapM_ putStrLn s
03:17:42 <vlatkoB> What would ...
03:18:02 <shachaf> vlatkoB: You tell us!
03:18:50 <vlatkoB> Isn't s [String]?
03:19:15 <Adeon> yes, s is [String]
03:19:16 <Philonous> vlatkoB:  Sounds right
03:19:37 <vlatkoB> I'm getting "No instance for (Show (IO [String] -> IO ()))"
03:19:52 <shachaf> What are you trying to do with it?
03:20:02 <shachaf> It's a function. You can't print a function.
03:20:21 <vlatkoB> Just to print each String in its own line.
03:20:32 <shachaf> Which string?
03:20:39 <vlatkoB> But it is not a function, s is [String]
03:20:48 <Philonous> vlatkoB:  The definition is right, you're using it wrong. The error is at the call site
03:21:20 <vlatkoB> What is "call site"?
03:21:32 <Adeon> the place where you use that definition
03:21:36 <ion> xnoise: (Math, not Haskell) 0+a = a; a+0 = a; (a+b)+c = a+(b+c). (Ditto) 1·a = a, a·1 = a, (a·b)·c = a·(b·c). (Haskell) [] ++ as == as; as ++ [] == as; (as ++ bs) ++ cs == as ++ (bs ++ cs). A monoid means the common part among these (and many others): an identity element (e.g. 0 or []), an associative operation (e.g. + or (++)) and the three laws.
03:23:25 <vlatkoB> I'm testing it from GHCI
03:23:54 <Philonous> vlatkoB:  Can you paste the line you're using for that?
03:23:59 <xnoise> ion: does not look so complicated, might be one of the simplest explanations i have read so far
03:24:04 <xnoise> thanks
03:25:59 <ion> xnoise: Haskell calls the identity element “mempty”, and the operation “mappend” which also has the alias (<>).
03:26:44 <ion> > mempty <> mempty <> "hello" <> mempty <> "jelly"
03:26:45 <lambdabot>   "hellojelly"
03:27:19 <ion> > sortBy (comparing length <> compare) cake
03:27:21 <lambdabot>   ["Alpha resins.","Cranial caps.","Four large eggs.","Fish shaped dirt.","On...
03:27:46 <vlatkoB> Uf, I can't believe what I did. I've been changing the function so much that I forgot to add the parameter (IO [String]). It's working correctly. Thanks for "call site". :-)
03:28:10 <arkeet> :t mconcat
03:28:12 <lambdabot> Monoid a => [a] -> a
03:28:22 <arkeet> :t foldMap
03:28:23 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:28:28 <niteria> > mempty :: Ordering
03:28:30 <lambdabot>   EQ
03:28:37 <niteria> nice
03:28:57 <arkeet> EQ <> y = y; x <> _ = x
03:29:03 <arkeet> er
03:29:05 <arkeet> yeah.
03:29:30 <elliott> weird instance
03:29:38 <arkeet> useful instance.
03:29:54 <arkeet> compare (a,b) (c,d) = compare a c <> compare b d
03:30:05 <ion> Are there others that make sense for Ordering?
03:31:06 <Philonous> ion:  The right-biased version?
03:31:38 <arkeet> sure, the dual monoid.
03:32:25 <niteria> > True <> False
03:32:27 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Bool)
03:32:27 <lambdabot>    arising from a use o...
03:32:35 <elliott> you could also privilege LT or GT instead of EQ, presumably
03:32:37 <ion> That makes as much sense as a right-biased version for Any and All as well. I’d say less than the left-biased one to be a useful default.
03:32:54 <arkeet> niteria: there are Any and All monoids wrapping Bool
03:33:56 <arkeet> > Any True <> Any False
03:33:58 <lambdabot>   Any {getAny = True}
03:34:00 <arkeet> > All True <> All False
03:34:01 <lambdabot>   All {getAll = False}
03:34:19 <arkeet> > foldMap Any [True,False]
03:34:21 <lambdabot>   Any {getAny = True}
03:34:33 <arkeet> > anyOf folded [True,False]
03:34:34 <lambdabot>   Couldn't match expected type `(->) b0' with actual type `[]'
03:34:41 <arkeet> huh?
03:34:44 <arkeet> :t anyOf
03:34:45 <lambdabot> Profunctor p => Accessing p Any s t a b -> p a Bool -> s -> Bool
03:34:55 <arkeet> right.
03:34:58 <elliott> :t andOf
03:35:00 <arkeet> > orOf folded [True,False]
03:35:00 <lambdabot> Getting All s t Bool b -> s -> Bool
03:35:01 <lambdabot>   True
03:36:39 <timthelion> > any id [True,False] -- How are monoids superior?
03:36:41 <lambdabot>   True
03:37:58 <ion> timthelion: Ask beaky.
03:38:17 <timthelion> It seems to me, that almost every type could have an almost infinite number of monoid instances. But how is that better than just applying monoidic functions to the types? I can define an infinite number of a->a->a s for a given a. But that's what functions are for, I don't need a typeclass to tell me that.
03:39:50 <arkeet> but the difference is
03:39:51 <arkeet> monoids are easy.
03:40:02 <timthelion> arkeet: where as functions are hard?
03:40:04 <niteria> monoids have properties
03:40:29 <timthelion> niteria: yet monoidic functions have the same properties.
03:40:29 <arkeet> > foldMap Sum [1..5]
03:40:31 <lambdabot>   Sum {getSum = 15}
03:40:47 <timthelion> interesting
03:40:55 <timthelion> ish
03:41:05 <arkeet> > foldMap show [1..5]
03:41:07 <lambdabot>   "12345"
03:41:26 <niteria> timthelion: you can express this properties in the code by constraining on a typeclass
03:41:26 <timthelion> :t foldMap
03:41:27 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:42:05 <niteria> s/this/those
03:42:53 * timthelion hopes it doesn't lead to such idiocy as we see with the list monad.
03:43:03 <ion> > runWriterT $ do tell "hello"; x <- lift [0..5]; tell (", " ++ show x ++ " jelly"); return x
03:43:05 <lambdabot>   [(0,"hello, 0 jelly"),(1,"hello, 1 jelly"),(2,"hello, 2 jelly"),(3,"hello, ...
03:43:20 <niteria> timthelion: where's the idiocy with list monad?
03:43:32 <timthelion> niteria: poorly named complex behavior
03:43:41 <timthelion> is bad design
03:43:45 <arkeet> :t WriterT
03:43:47 <lambdabot> m (a, w) -> WriterT w m a
03:43:59 <arkeet> right.
03:45:08 <timthelion> niteria: since the monad instance for list is not unique, there is no way to predict what the given instance will do without reading the source code(as it's behavior is not described by either it's type(Monadic) or it's name (bind)
03:45:16 <arkeet> it isn't?
03:45:48 <arkeet> in what other reasonable way could list be a monad?
03:46:00 <niteria> there are 2 sensible instances: nondeterminism and maybe
03:46:01 <[mth]> wat? What other law abiding implementation is there?
03:46:25 <elliott> why have typeclasses at all, if you won't accept that an instance can be the most generally useful or only reasonable one?
03:46:44 <elliott> passing around monad triple objects by hand isn't my idea of fun, personally
03:46:54 <niteria> and there's already a Maybe monad
03:47:01 <elliott> and I don't see why to single out [] here
03:47:31 <elliott> niteria: I don't quite see what you mean by Maybe
03:47:34 <niteria> and by sensible I mean law abiding
03:47:37 <arkeet> me either.
03:47:41 <elliott> the instance i am thinking you might be thinking of would violate (>>= return) = id
03:47:42 <timthelion> elliott: well Maybe is rather clear in it's behavior. But tell me that the code for monadic list cross product is clear...
03:47:51 <arkeet> what would join do for this other instance?
03:48:07 <elliott> timthelion: I find it perfectly clear because I understand the list monad. sure, Maybe is simpler. Maybe is a simpler type than []
03:48:08 <ion> timthelion: Can i tell you that? The code for monadic list cross product is clear.
03:48:24 <arkeet> :t liftM2 (,)
03:48:25 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
03:48:28 <arkeet> this?
03:48:32 <elliott> thankfully, Haskell doesn't shy away from powerful, succint, meaningful concepts, even if they may cause confusion at first sight: everyone has to learn
03:48:46 <elliott> certainly [] is a lot less of a mind-bender than Cont or whatever.
03:50:25 * timthelion would not use it in production code.
03:50:38 <timthelion> the list monad that is
03:50:42 <elliott> ok. you're missing out
03:50:51 <arkeet> :t select
03:50:53 <lambdabot> [t] -> [(t, [t])]
03:51:00 <chrisdone> timthelion: why?
03:51:17 <mauke> timthelion: would you use list comprehensions?
03:51:20 <ion> timthelion: It seems to be so useful that e.g. Python included something with pretty much the exact semantics of the list monad.
03:51:43 <timthelion> ion: yes, but what did they name it?
03:51:53 <arkeet> "list comprehensions"
03:51:55 <chrisdone> yeah well list comprehensions are specially optimized by ghc
03:51:56 <ion> timthelion: How is that relevant?
03:52:07 <elliott> the list monad does not actually have a name.
03:52:15 <elliott> you can think "the list monad" is a bad term to describe the semantics of the instance Monad []
03:52:27 <elliott> but if the problem was with the terminology, there would be no reason to avoid that (unnamed) instance in production code.
03:52:48 <timthelion> chrisdone: It seems to me, that code should be easilly read without having to be knowledgable of the semantics of the API used. The names of things should be enough to understand what they do.
03:53:19 <arkeet> I think most people with a reasonable amount of experience with haskell would know what the list monad is.
03:53:58 * typoclass . o O ( this could equally well defend AbstractFactoryVisitorFactory ;-) "thankfully, java doesn't shy away from powerful, succint, meaningful concepts, even if they may cause confusion at first sight: everyone has to learn" )
03:54:10 <mauke> typoclass: >succinct
03:54:30 <chrisdone> timthelion: well i guess that discards monads and monoids and arithmetic operations
03:54:34 <typoclass> mauke: not my problem
03:54:41 <niteria> that's like not using folds if you come from imperative background
03:54:55 <mauke> timthelion: that's nonsense
03:55:10 <lewis1711> who doesn't use folds? C# even has them. python, ruby... I mean come on. let's all fold
03:55:23 * chrisdone glances around nervously
03:55:24 <arkeet> people use folds  there?
03:55:27 <chrisdone> … I … I fold
03:55:35 <mauke> perl has a foldl but it's called reduce
03:55:48 <chrisdone> scheme and common lisp have reduce too
03:56:09 * timthelion thinks that map and fold are such core features that anyone should know them, but a given typeclass instance for a given type is not.
03:56:25 <arkeet> even for something in the Prelude?
03:56:58 <mauke> timthelion: so foldr is "obvious" but (==) is not?
03:57:10 <timthelion> arkeet: well you do have a point there.
03:57:28 <lewis1711> I think the folds are only in srf1 for scheme.. but that's ot
03:57:46 <timthelion> mauke: well the Eq instances are all very clearly unique. So there is no need to learn them at all.
03:57:53 <mauke> huh?
03:58:03 <timthelion> Just like functor instances, are very easy to learn, since they are all unique.
03:58:09 <mauke> what do you mean by "unique"?
03:58:29 <timthelion> mauke: there is only one correct Eq instance for a given type.
03:58:37 <Philonous> timthelion:  Hardly
03:58:46 <mauke> timthelion: define "correct"
03:58:47 <elliott> that's not true, if you e.g. hide constructors of the type or such to maintain data abstraction
03:58:52 <typoclass> timthelion: i agree on the point that haskell can be hard to read because sometimes, you have to do type inference in your head to figure out if this "fmap f" relates to a Maybe or a list or what
03:58:59 <timthelion> Philonous: if the behavior is different from determining value equality than it is wrong.
03:59:06 <elliott> if (==) was always completely strict structural equality, it would have much more limited use
03:59:25 <elliott> timthelion: even if you cannot distinguish x,y if x == y from outside the module in which the type is defined?
03:59:35 <mauke> timthelion: define "value equality"
03:59:40 <timthelion> elliott: it is true that the implementations may vary, but that doesn't mean they are not unique in their behavior.
03:59:44 <elliott> being able to do optimisation thanks to module abstraction is a good thing
04:00:20 <elliott> timthelion: huh? I'm saying there are reasonable examples of Eq instances not being unique
04:00:51 <timthelion> mauke: Ok if v1 == v2 then for f :: a -> b f v1 == f v2
04:00:52 <arkeet> why are we talking about Eq?
04:00:52 <Philonous> timthelion:  Eq instance take equivalent representation of values into account. Take for example Ratio. The semantics of those values isn't intrinsic to the type
04:01:06 <mauke> timthelion: <<loop>>
04:01:14 <elliott> oh, Rational is a good example.
04:01:18 <elliott> mine were all uglier.
04:02:07 <timthelion> arkeet: well since someone claimed that if I don't like Monad instances since they are non transparent in their behavior, than somehow that means my logic also applies to Eq(which is transparent in it's behavior)
04:02:10 <kryft> You might also want to have different kinds of equality depending on context
04:02:52 <timthelion> kryft: that's a very stupid thing to do in with typeclass instances though, since in haskell type clases are not fist class and thus cannot be "chosen" by context.
04:03:07 * elliott thinks the definition of "transparent" here is equivalent to "familiar"
04:03:23 <mauke> timthelion: no, you said "map and fold are such core features that anyone should know them, but a given typeclass instance for a given type is not."
04:03:24 <arkeet> timthelion: typeclass instances are no less transparent than function definitions
04:03:25 <kryft> Uh, what I said was badly phrased
04:04:12 <timthelion> kryft: but it still holds, that if you want multiple typeclass instances you need to patch GHC first.
04:06:00 <timthelion> mauke: that doesn't mean that some typeclass instances are not completely clear and need no exception to my rule about clarity.
04:06:06 <kryft> I just meant that there can be several different feasible definitions of 'equality' depending on what you're doing. The statement "there is only one valid Eq instance for a given type" sounded like "given a type, there can only be one reasonable way of defining Eq", which I don't think is true, but maybe I misinterpreted the sentence due to proto-migraine haze and ignorance :)
04:06:32 <kryft> s/defining Eq/defining what equality means for this type
04:06:42 <niteria> if you want multiple instances you just wrap in a newtype
04:06:50 <timthelion> kryft: it is still true, that the other Eq instances would be "wrong" enough that they wouldn't belong in a library.
04:07:38 <timthelion> kryft: Since if two things are Eq they should be Equal, that is, they should behave the same in all cases.
04:07:57 <mauke> timthelion: but you can't deduce behavior from the type definition alone
04:08:30 <timthelion> mauke: That is true, unlike with Functor, you can make a mistake in defining Eq.
04:08:48 <mauke> I can also make a mistake with Functor
04:08:52 <timthelion> mauke: but I can also define "reverse" incorectly, and that wouldn't make the name any less clear.
04:09:00 <timthelion> mauke: try :D
04:09:01 <elliott> instance Functor [] where fmap _ _ = []
04:09:14 <elliott> instance Functor [] where fmap f xs = concatMap (\x -> [f x, f x]) xs
04:09:19 <mauke> instance Functor [] where fmap f (x : xs) = [f x, f x]
04:09:22 <elliott> there are many ways to screw up a Functor instance
04:09:39 * timthelion is surprised.
04:09:48 <elliott> i am also surprised
04:09:54 <mauke> instance Functor IO where fmap f x = do x; r <- x; return (f x)
04:10:11 * timthelion was under the impression that functor was truely unique based on the free theorums rule
04:10:21 <elliott> of course these all violate the functor laws.
04:10:28 <mauke> I am not constrained by theorems or laws when writing code
04:10:48 <elliott> well, you are constrained by free theorems.
04:10:55 <mauke> unsafePerformIO
04:10:57 <elliott> but f id = id of course doesn't hold for all functions
04:11:14 <elliott> mauke: well, i think that would obviously be inadmissable in context :P
04:11:23 <typoclass> well laws are a convention between humans. ghc doesn't know about them or check them
04:11:25 <mauke> instance Functor [] where fmap _ [] = []; fmap f (x : xs) = (: map f xs) $! (f x)
04:13:02 <bsrkaditya> Hi, is there an equivalent of accumArray for map? ie, I am looking for a function of type Ord k => (a -> b -> a) -> a -> [(k,b)] -> M.Map k a
04:15:30 <typoclass> timthelion: i think we do need improved haddocks. stuff should be easier to look up, and we need more meaningful explanations. there are some good resources on the web (e.g. typeclassopedia), but they're not linked to from any of the haddocks. so, i agree on the point that haskell is not particularly well discoverable
04:16:00 <timthelion> typoclass: functions are easy enough to look up.
04:16:20 <timthelion> typoclass: it's just type class instances of non unique type classes that give me trouble.
04:16:44 <elliott> bsrkaditya: perhaps mapAccum + fromList or something will accomplish what you want?
04:16:51 <elliott> I admit I don't remember exactly what acumArray does
04:18:35 <bsrkaditya> what does mapAccum do?
04:19:18 <elliott> see http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Map-Lazy.html#v:mapAccum
04:53:23 <no-n[1]> is there are function somewhere that pads a string up with '0's to become a given length?
04:53:32 <no-n[1]> guess it would be easy to make
04:54:19 <mauke> printf?
05:06:55 <typoclass> > let pad c n = head . dropWhile ((< n) . length) . iterate (c :) in pad 'x' 6 "u" -- no-n[1]: don't know of one in the standard library, but you could use an infinite list ...
05:06:56 <lambdabot>   "xxxxxu"
05:07:51 <typoclass> hm, doesn't even need to be a Char, could be a String
05:08:28 <no-n[1]> ah, that's interesting
05:10:01 <int-e> dropWhile ((< n) . length) --> drop (n - length xs)  will be faster (xs being the third argument to pad)
05:12:16 <niteria> > let pad n = reverse . take n . (++ replicate n 'x') . reverse in pad 10 "str"
05:12:18 <lambdabot>   "xxxxxxxstr"
05:12:51 <arkeet> reversing twice is eeevil.
05:13:10 <niteria> and dropWhile on length isn
05:13:13 <niteria> isn't?
05:13:16 <arkeet> it's less evil.
05:14:36 <int-e> I tend to disagree. It's a subtle way to introduce quadratic runtime into a function that should obviously finish in linear time.
05:14:39 <arkeet> > let pad n s = replicate (n - length s) 'x' ++ s in pad 10 "str"
05:14:41 <lambdabot>   "xxxxxxxstr"
05:14:56 <int-e> arkeet: of course :)
05:15:05 <no-n[1]> oh, yeah :)
05:15:14 <arkeet> oh, I didn't actually read int-e's thing.
05:15:15 <niteria> that's a lot better
05:15:37 <arkeet> > replicate (-1) 'a'
05:15:38 <lambdabot>   ""
05:15:42 <arkeet> ok cool.
05:16:35 <arkeet> would be nicer if it worked on infinite lists.
05:16:57 <niteria> what's the length of infinite list?
05:17:10 <int-e> > let pad n c s = replicate (n - length (take n s)) c ++ s in pad 10 'x' (repeat 'a')
05:17:12 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
05:17:16 <no-n[1]> niteria: 4
05:17:50 <arkeet> int-e: oh, alright.
05:31:28 <typoclass> int-e: as far as i can tell, it doesn't seem to be faster http://hpaste.org/85350. it seems to be the same
05:32:53 <int-e> typoclass: in that program, p 'x' 999 "u" is a constant and gets floated out; it's only evaluated once.
05:33:20 <int-e> typoclass: (floated out of the mapM loop at least. which should be mapM_ but never mind.)
05:34:50 <int-e> > let pad c n = head . dropWhile ((< n) . length) . iterate (c :); pad' c n xs = head . drop (n - length xs) . iterate (c :) $ xs in take 10 $ pad' 'x' 1000000 "a"
05:34:52 <lambdabot>   "xxxxxxxxxx"
05:34:55 <int-e> > let pad c n = head . dropWhile ((< n) . length) . iterate (c :); pad' c n xs = head . drop (n - length xs) . iterate (c :) $ xs in take 10 $ pad 'x' 1000000 "a"
05:34:59 <lambdabot>   mueval-core: Time limit exceeded
05:35:28 <arkeet> you should use something like criterion for benchmarking.
05:36:01 <int-e> yeah, but this is asymptotic complexity ... no benchmarking required :)
05:36:45 <int-e> (Not for telling the difference between O(n) and O(n^2) with reasonably small constant factors at least.)
05:36:52 <__xc> > (show pi) !! 50
05:36:54 <lambdabot>   *Exception: Prelude.(!!): index too large
05:36:58 <arkeet> fine
05:37:06 <arkeet> > (show (pi :: CReal)) !! 50
05:37:07 <lambdabot>   *Exception: Prelude.(!!): index too large
05:37:11 <arkeet> er right.
05:37:15 <arkeet> > pi :: CReal
05:37:16 <lambdabot>   3.1415926535897932384626433832795028841972
05:37:28 <__xc> Real -> 32
05:37:33 <niteria> :t (!!)
05:37:34 <lambdabot> [a] -> Int -> a
05:37:54 <arkeet> > showCReal 100 pi
05:37:55 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
05:38:31 <niteria> for a moment I thought it was some typeclassy thing, a lot of things are indexable
05:38:44 <__xc> > (showCReal 100 pi) !! 40
05:38:45 <lambdabot>   '7'
05:38:59 <__xc> > (showCReal 100 pi) !! 90
05:39:00 <lambdabot>   '2'
05:39:15 <__xc> interesting..
05:39:16 <arkeet> > (showCReal 1000000 pi) !! 100
05:39:19 <lambdabot>   mueval-core: Time limit exceeded
05:39:22 <arkeet> not lazy, then.
05:39:42 <arkeet> > head $ showCReal 1000000 pi
05:39:45 <lambdabot>   mueval-core: Time limit exceeded
05:39:52 <__xc> maybe it works on ghci
05:40:49 <int-e> > head $ showCReal 1000000 (37/39)
05:40:53 <lambdabot>   mueval-core: Time limit exceeded
05:41:18 <__xc> weird
05:41:36 <latro`a> lambdabot's time limit is rather stringent
05:42:06 <arkeet> > showCReal 1 pi
05:42:07 <lambdabot>   "3.1"
05:42:16 <__xc> @src showCReal
05:42:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:42:29 <latro`a> @src is extremely limited
05:42:30 <lambdabot> Source not found. My mind is going. I can feel it.
05:42:38 <int-e> > showCReal 3 pi -- 1 or 2?
05:42:39 <lambdabot>   "3.142"
05:42:51 <arkeet> @let blah [] ys = ys; blah (x:xs) (_:ys) = x : blah xs ys
05:42:53 <lambdabot>  Defined.
05:43:05 <arkeet> > foldr1 blah (map (showCReal ?? pi) [1..])
05:43:09 <lambdabot>   mueval-core: Time limit exceeded
05:43:12 <arkeet> hmm
05:43:33 <arkeet> @let blah [] ys = ys; blah (x:xs) ~(_:ys) = x : blah xs ys
05:43:34 <lambdabot>  <local>:17:1:
05:43:34 <lambdabot>      Warning: Pattern match(es) are overlapped
05:43:34 <lambdabot>               I...
05:43:36 <arkeet> right.
05:43:37 <arkeet> @undefine
05:43:39 <arkeet> @let blah [] ys = ys; blah (x:xs) ~(_:ys) = x : blah xs ys
05:43:41 <lambdabot>  Defined.
05:43:44 <arkeet> > foldr1 blah (map (showCReal ?? pi) [1..])
05:43:47 <lambdabot>   mueval-core: Time limit exceeded
05:44:04 <latro`a> :t (??)
05:44:05 <lambdabot> Functor f => f (a -> b) -> a -> f b
05:44:12 <arkeet> oh heh it doesn't work anyway.
05:44:14 <arkeet> ?? is infix flip
05:44:14 <lambdabot>  is infix flip
05:44:55 <latro`a> flip generalizes to Functor, OK, TIL
05:45:14 <arkeet> @let blah' [x] ys = ys; blah' (x:xs) ~(_:ys) = x : blah' xs ys
05:45:16 <lambdabot>  Defined.
05:47:01 <arkeet> @let lazyShowCReal n x = foldr1 blah' (map (showCReal ?? pi) [0..])
05:47:02 <lambdabot>  Defined.
05:47:03 <niteria> ?? is nice, is it packaged somewhere?
05:47:04 <lambdabot> Plugin `compose' failed with: Unknown command: ""
05:47:07 <arkeet> it's in lens
05:47:17 <arkeet> oops
05:47:24 <arkeet> @let foo x = foldr1 blah' (map (showCReal ?? pi) [0..])
05:47:25 <lambdabot>  Defined.
05:47:28 <niteria> of course, everything is in lens
05:47:29 <arkeet> I'm really dumb.
05:47:30 <arkeet> @undefine
05:47:38 <arkeet> @let blah [_] ys = ys; blah (x:xs) ~(_:ys) = x : blah xs ys
05:47:40 <lambdabot>  Defined.
05:47:48 <int-e> > take 20 $ let blah ((x:_):xss) = x : blah (map tail xss) in blah (map (showCReal ?? pi) [1..])
05:47:49 <arkeet> @let lazyShowCReal x = foldr1 blah (map (showCReal ?? x) [0..])
05:47:50 <lambdabot>   "3.141592653589793238"
05:47:51 <lambdabot>  Defined.
05:48:03 <arkeet> > take 20 $ lazyShowCReal pi
05:48:05 <lambdabot>   "3.141592653589793238"
05:48:19 <arkeet> lazy and slow :P
05:48:39 <arkeet> @let lazyShowCReal' x = foldr1 blah (map (showCReal ?? x) (iterate (*2) 1))
05:48:41 <lambdabot>  Defined.
05:48:43 <arkeet> > take 20 $ lazyShowCReal' pi
05:48:45 <lambdabot>   "3.141592653589793238"
05:49:51 <arkeet> > lazyShowCReal' pi
05:49:53 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
05:50:04 <arkeet> > lazyShowCReal' pi !! 1000
05:50:06 <lambdabot>   '8'
05:50:19 <niteria> nice, lazyfication with log n overhead
05:55:48 <dario> @ty (>>>)
05:55:50 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
06:00:04 <int-e> Hmm, CReal gets really slow at computing pi for more than 10k digits.
06:00:57 <arkeet> ah, creal computes pi as 16 arctan(1/5) - 4 arctan(1/239(
06:00:57 <arkeet> )
06:01:32 <arkeet> which it does by a power series
06:01:52 <arkeet> so it's probably quadratic time or so
06:02:44 <int-e> arkeet: but still I think your lazyShowCReal' is wrong with probability 1, because the second-to-last digit of each chunk is incorrect with probability 1/20. (namly when rounding up a last digit that is 0)
06:03:03 <arkeet> oh, I didn
06:03:05 <arkeet> 't know that.
06:03:10 <int-e> ... that is 9
06:03:26 <int-e> (who put 0 right next to 9 on the keyboard anyway?)
06:03:43 <__xc> > lazyShowCReal' pi !! 100000
06:03:45 <arkeet> or hadn't thought of it.
06:03:47 <lambdabot>   mueval-core: Time limit exceeded
06:04:01 <__xc> > lazyShowCReal' pi !! 10000
06:04:05 <lambdabot>   mueval-core: Time limit exceeded
06:04:21 <arkeet> > drop 750 $ showCReal 770 pi
06:04:23 <lambdabot>   "6051870721134999999837"
06:04:29 <arkeet> > drop 750 $ showCReal 767 pi
06:04:30 <lambdabot>   "6051870721135"
06:04:33 <arkeet> heh.
06:05:14 <__xc> 99999, pi is irregular there
06:06:34 <arkeet> I smiled when I learned about that the first time.
06:08:00 <int-e> arkeet: but you can use it to fool people; the first 32768 characters are correct at least; I'm not patient enough to push the calculation further.
06:08:09 <arkeet> haha
06:08:52 <arkeet> > lazyShowCReal pi
06:08:53 <__xc> my password is a sequance of pi, so I don't forget it, no jk
06:08:55 <lambdabot>   mueval-core: Time limit exceeded
06:09:00 <arkeet> bah
06:09:04 <arkeet> > tale 50 $  lazyShowCReal pi
06:09:06 <lambdabot>   Not in scope: `tale'
06:09:06 <lambdabot>  Perhaps you meant one of these:
06:09:06 <lambdabot>    `take' (imported f...
06:09:09 <__xc> that's why I asked you about pi
06:09:10 <arkeet> > take 50 $  lazyShowCReal pi
06:09:11 <__xc> hehe
06:09:11 <int-e> __xc: so it's 99999?
06:09:12 <lambdabot>   "3.141592653589793238462643383279502884197169399375"
06:09:17 <__xc> lol
06:09:22 <arkeet> well those are correct, hm
06:09:46 <arkeet> oh yeah, it could only go wrong if there's a 99 that's rounded up.
06:09:59 <__xc> no it is between the 10000th and 10008 digit of pi
06:10:00 <arkeet> because it doesn't write trailing zeros
06:10:23 <arkeet> __xc: you better change your password now
06:10:32 <arkeet> :p
06:10:32 <__xc> :))
06:11:38 <arkeet> I have a couple random-looking passwords derived from nonsense phrases, and the rest I have a password manager for.
06:11:42 <arkeet> but I guess that's -blah.
06:11:44 <int-e> arkeet: oh. then it's actually correct
06:12:00 <arkeet> int-e: oh, so it is.
06:12:02 <int-e> arkeet: because when 99 gets rounded up, 2 digits are truncated, and so on.
06:12:19 <int-e> wow
06:12:19 <arkeet> cool =)
06:12:38 <arkeet> > lazyShowCReal 1
06:12:41 <lambdabot>   mueval-core: Time limit exceeded
06:12:44 <arkeet> heh.
06:13:02 <arkeet> > lazyShowCReal' (1 - 1/10^100)
06:13:06 <lambdabot>   mueval-core: Time limit exceeded
06:13:10 <arkeet> > lazyShowCReal' (1 - 1/10^10)
06:13:14 <lambdabot>   mueval-core: Time limit exceeded
06:13:19 <arkeet> > showCReal 100 (1 - 1/10^10)
06:13:20 <lambdabot>   "0.9999999999"
06:13:25 <arkeet> right.
06:13:28 <arkeet> > lazyShowCReal' (1 - 1/10^1000)
06:13:32 <lambdabot>   mueval-core: Time limit exceeded
06:13:41 <arkeet> > lazyShowCReal' (1 - 1/10^2000)
06:13:44 <lambdabot>   mueval-core: Time limit exceeded
06:13:56 <dario> lower exponent, not higher..
06:13:57 <__xc> "this is my strong password"
06:14:13 <arkeet> dario: no, lambdabot takes 1024 characters or so from show
06:14:25 <arkeet> so it will fail if it loops before generating that many
06:14:42 <arkeet> > showCReal 2000 (1 - 1/10^2000)
06:14:44 <lambdabot>   "0.999999999999999999999999999999999999999999999999999999999999999999999999...
06:14:48 <dario> so time has nothing to do with it?
06:14:49 <arkeet> > showCReal 1999 (1 - 1/10^2000)
06:14:52 <lambdabot>   "1.0"
06:15:08 <arkeet> dario: it loops if we ask for too many digits.
06:15:28 <arkeet> anyway, that's something to fix.
06:15:34 <arkeet> but I guess we can't fix it.
06:15:34 <dario> "loops" as in doesn't terminate within 1024 characters?
06:15:40 <arkeet> yeah
06:15:43 <arkeet> er
06:15:59 <arkeet> well it has to do with how lazyShowCReal works.
06:16:20 <int-e> > showCReal 1999 (1 - 5.2/10^2000)
06:16:23 <lambdabot>   "1.0"
06:17:16 <int-e> > showCReal 1999 (1 - 5.3/10^2000)
06:17:18 <lambdabot>   "0.999999999999999999999999999999999999999999999999999999999999999999999999...
06:17:30 <arkeet> I don't get it.
06:17:59 <arkeet> why does it do that?
06:18:20 <int-e> It's rounding incorrectly, but that's to be expected, since one cannot pinpoint computable reals exactly.
06:18:38 <arkeet> hm
06:18:44 <int-e> so the comparison to 1 - 5/10^2000 (in this case) cannot be exact.
06:19:02 <arkeet> > showCReal 19 (1 - 5.3/10^20)
06:19:04 <lambdabot>   "0.9999999999999999999"
06:19:05 <arkeet> > showCReal 19 (1 - 5.2/10^20)
06:19:06 <lambdabot>   "0.9999999999999999999"
06:19:11 <arkeet> > showCReal 19 (1 - 5.01/10^20)
06:19:12 <lambdabot>   "0.9999999999999999999"
06:19:17 <arkeet> well whatever.
06:20:34 <int-e> > showCReal 19 (1 - 4.99 / 10^20) -- going wrong in the other direction here
06:20:35 <lambdabot>   "0.9999999999999999999"
06:20:45 <arkeet> heh
06:29:35 <hseg> Trying to install HLint. Getting the error pasted below. How do I diagnose, and how do I fix?
06:29:36 <hpaste> hseg pasted “Errors” at http://hpaste.org/85354
06:30:42 <finnrobi> I'm trying to create a clone of wc using System.Console.CmdArgs (learning purposes) and I want to preserve the semantics that the argument '-' means stdin. Just passing it in on argv makes CmdArgs complain, but what I think I want to do is to just pass it through as a positional parameter (adding it to my [FilePath] field). Is this possible?
06:32:15 <arkeet> hseg: you should show the rest of the build log.
06:32:19 <__xc> hseg, install these packages?
06:32:42 <arkeet> hseg: sounds like hashable might be broken? what does `ghc-pkg check` say?
06:32:45 <hseg> Hashable is installed. At least, in GHCi, import Data.Hashable doesn't give me errors
06:32:49 <arkeet> hmm
06:32:52 <supki> that looks like linker error?
06:33:04 <arkeet> hseg: but do you have multiple versions of hashable installed?
06:33:39 <hseg> Don't think so. Multiple versions of GHC, though...
06:33:43 <arkeet> hseg: anyway, you should show the rest of the build log.
06:33:48 <arkeet> hm...
06:33:58 <no-n[2]> does programming ever make your mind feel weird?
06:33:58 <__xc> ah this is your cabal error?
06:34:28 <hseg> Yes. This is the tail end of the error, after all the "Building foo" lines
06:34:37 <__xc> k
06:35:11 <hseg> Is there any way I can uninstall GHC 7.6 and make cabal remove all packages compiled with it? That way I'll have one GHC on my system.
06:35:15 <arkeet> hseg: you should show the rest of it.
06:35:59 <hpaste> hseg annotated “Errors” with “Full log” at http://hpaste.org/85354#a85355
06:36:05 <supki> hseg: are you sure you can use anything from hashable after you import it?
06:36:37 <arkeet> right, ghci doesn't link until you actually use something from the module.
06:36:56 <arkeet> hseg: what does ghc-pkg check say?
06:37:03 <hseg> Typechecking works. Actually evaluating stuff, not so much
06:37:34 <hpaste> hseg annotated “Errors” with “ghc-pkg check” at http://hpaste.org/85354#a85356
06:38:04 <arkeet> nothing broken according to it.
06:38:13 <arkeet> but maybe a reinstall of hashable would fix it anyway?
06:39:30 <supki> https://github.com/tibbe/hashable/issues/46
06:39:30 <hpaste> hseg pasted “Warnings from cabal on cabal install hashable --reinstall” at http://hpaste.org/85357
06:46:04 <hseg> Should I reinstall despite the warnings?
06:46:20 <timthelion> hseg: it depends on what you are reinstalling
06:46:40 <timthelion> libraries that depend on a library must also be reinstalled so as to not risk type conflicts
06:46:44 <hseg> hashable. The warnings cabal gave are posted here: http://hpaste.org/85357
06:47:03 <supki> hseg: issue I linked to explains the details, I doubt reinstalling will help
06:47:31 <hseg> OK, how do I downgrade?
06:47:47 <timthelion> hseg: you would have to reinstall many things, since everything that rellies on conduit would have to be reintstalled as well.
06:48:04 <supki> hseg: anyway, after you reinstall hashable, all packages that depend on it are broken, and you should reinstall them too
06:48:31 <timthelion> hseg: well, that's not a downgrade, what you try to do their is replace a package with the same version of itself(for the purpose of patching for example)
06:49:33 <hseg> You're confusing me. What do I need to do? From the bug report, I understand the latest hashable doesn't work under windows, and that I should use 1.1
06:50:05 <timthelion> hseg: well you wouldn't want to reinstall 1.2 then, you would want to uninstall 1.2 and then install 1.1
06:50:18 <hseg> OK. How do I do that?
06:50:29 <hseg> AFAICT, cabal can't uninstall stuff
06:50:49 <timthelion> hseg: good question.
06:51:18 <nh2> dependency hell is ... well, hell
06:51:36 <timthelion> https://github.com/haskell/cabal/issues/373
06:51:44 <hseg> :-) Seriously though, this is one *messed-up* system.
06:51:53 <timthelion> hseg: yes it is
06:52:39 <hpc> i vote that you clear your .ghc directory, `cabal install cabal-dev`, and use that for your projects
06:52:42 <timthelion> hseg: there is a list somewhere of things that are fucked up in haskell.  I think it goes "cabal, cross module typeclass instances, data constructor namespacing"
06:53:07 <hseg> The first and last I can attest to being bitten by personally.
06:53:35 <timthelion> hpc: Does that require reinstalling everything for each package you work on?
06:54:12 <timthelion> hpc: it still wouldn't help him, because if he reinstalls everything, he'll just end up with the up-to-date but bad 1.2 version.
06:54:12 <hpc> cabal-dev sandboxes whatever you invoke it on
06:54:20 <hpc> ah
06:55:06 * timthelion would sugest downloading arch linux and installing that, but perhaps this isn't the time.
06:55:12 <hseg> How about I uninstall the Haskell Platform and start over?
06:55:34 * hseg would love to use haskell under linux, but doesn't have his own computer.
06:55:47 <timthelion> hseg: yes, that is what you should do, but FIRST you must figure out how to blacklist hashtable v 1.2
06:55:56 <hseg> BTW, how good is the pacman-cabal interoperability?
06:56:25 <timthelion> hseg: I just use cabal for everything and don't install any haskell libs through pacman
06:56:29 <hpc> hseg: i would trust absolutely nothing that comes from another package manager
06:56:44 <adzeitor> > let pad n s = drop (length $  zip (replicate n '_') s) (replicate n '_')  ++ s in pad 10 "hello"
06:56:46 <lambdabot>   "_____hello"
06:56:48 <hseg> I assume you mean blacklisting hashtable under windows for the second attempt?
06:57:06 <adzeitor> > let pad n s = drop (length $  zip (replicate n '_') s) (replicate n '_')  ++ s in take 20 $ pad 10 (repeat 'A')
06:57:08 <lambdabot>   "AAAAAAAAAAAAAAAAAAAA"
06:57:14 <timthelion> hseg: just blacklist a specific version of hashtag under windows for the seccond attempt
06:57:40 <hseg> hpc: Yes and no. Using a single package manager for the entire system allows you to know to what package each file belongs, etc etc.
06:59:03 <hseg> Can't find how to blacklist packages.
06:59:11 <timthelion> hseg: you can't
06:59:28 <hseg> So how am I going to write/test my code?
06:59:42 <adzeitor> > let pad n s = drop (length $ take n s) (replicate n '_')  ++ s in take 20 $ pad 10 (repeat 'A')
06:59:44 <lambdabot>   "AAAAAAAAAAAAAAAAAAAA"
06:59:56 <jmcarthur> hseg: the main problem with using pacman is that you can only have one version of a package installed at a time
07:00:08 <timthelion> hseg: I would download 1.1, modify it's version to be 1.2, --force-reinstall over 1.2, keeping a list of packages that relied upon 1.2. Then --force-reinstall those, untill I had --force-reinstalled the whole system.
07:00:17 <jmcarthur> hseg: and when you upgrade packages that others depend on, they *all* have to be upgraded
07:00:40 <jmcarthur> hseg: this is especially problematic if you aren't maintaining all of those packages because then you are at the mercy of others to upgrade everything at once
07:00:47 * hseg curls up in a small corner, frightened out of his wits
07:00:48 <supki> timthelion: why not  cabal install whatever --constraint='hashable==1.1' --force-reinstalls ?
07:00:54 <timthelion> hseg: and by modify it's version I mean edit the cabal file
07:01:14 <jmcarthur> hseg: so i, too, recommend just using cabal for most haskell packages
07:01:48 <timthelion> supki: is that possible? I don't really know, I just saw https://github.com/haskell/cabal/issues/373 here that you cannot blacklist so I thought up a hack.
07:02:32 <timthelion> supki: you can always back up ~/.ghc and ~/.cabal first
07:02:34 <hseg> tl;dr cabal is buggy; since ghc is statically linked and performs x-package optimizations most ways of using a package manager from a distro are broken for ghc. HELL
07:03:10 <timthelion> supki: that was meant for hseg actually
07:03:27 <niteria> @where sicp
07:03:28 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
07:03:44 <supki> timthelion: well, --constraint is certainly possible :]
07:03:59 <hseg> I read it.
07:04:07 <niteria> sicp should mention cabal-dev or hsenv
07:04:37 <timthelion> niteria: cabal-dev doesn't help here sadly :/
07:04:38 <jmcarthur> hseg: it has little to do with static linking
07:05:10 <jmcarthur> hseg: it's just that libraries from one version to the next are not source compatible
07:05:16 <jmcarthur> err
07:05:20 <jmcarthur> s/source/binary/
07:05:23 <hseg> actually, it does. x-package optimization means it's hard to construct packages which are portable across machines
07:05:35 <jmcarthur> hseg: even with dynamic linking you have the same problem
07:05:44 <jmcarthur> hseg: (and we do have such a feature)
07:06:10 <jmcarthur> and yes it is in large part due to all the optimizations
07:06:16 <niteria> doesn't 1. cabal install bare minimum; 2. don't install anything from your distro's package manager 3. use cabal-dev solve all the problems?
07:06:43 <jmcarthur> niteria: that would be reasonable, but honestly i rarely use cabal-dev. most of the time cabal does just fine
07:06:49 <hseg> Right. I meant x-package optimization, which causes hard dependencies on versions of libraries that were defined as soft dependencies in the first place?
07:07:21 <jmcarthur> hseg: they are soft dependencies at the source level and hard dependencies at the binary level
07:07:58 <jmcarthur> hseg: from what i hear, gentoo does pretty well here, since it can automatically rebuild reverse deps when you upgrade a haskell package
07:08:21 <jmcarthur> but even that seems like it could be frustrating since you still only have one version installed at a time
07:08:33 <timthelion> jmcarthur: cool. but why did we have to wait for some python folks to write a package manager for haskell ;)
07:08:41 <jmcarthur> timthelion: huh?
07:08:52 <jmcarthur> haskell shouldn't need a package manager at all
07:08:56 <timthelion> jmcarthur: isn't gentoos package manager written in python?
07:09:19 <jmcarthur> timthelion: but what does that have to do with anything?
07:09:53 <timthelion> jmcarthur: ruby has gems, perl has CPAN, python has ??? . it seems most languages that actually have a module system have a method of installing new modules.
07:10:14 <jmcarthur> timthelion: i think for a haskell dev cabal is superior. for a mere user of haskell packages, most existing package managers do fine
07:10:19 <elliott> does GHC actually do cross-package optimisation?
07:10:24 <elliott> I mean, beyond the basic .hi stuff
07:10:27 <timthelion> jmcarthur: it seems to me, that as little as possible should be done in a distro-specific way, that's all
07:10:34 <jmcarthur> elliott: most of that is the basic .hi stuff
07:10:36 <hseg> timthelion: python has setuptools
07:10:44 <jmcarthur> timthelion: cabal is that
07:10:59 <jmcarthur> because it's not a package manager
07:11:29 <arkeet> maybe there should be a package manager!
07:11:39 * timthelion longs for the day when we all compile to asm.js bytecode and pass html files around and never have to worry about package mangement or security.
07:11:42 <jmcarthur> once you have a package manager, you are basically already trying to replicate the functionality of a distro's package manager, which is silly
07:11:45 <hseg> I give up. Uninstalling all of the Haskell stuff here, and going to start afresh tomorrow.
07:11:55 <arkeet> my distro can't manage stuff in ~/.ghc
07:12:10 <jmcarthur> get a nicer distro? or just use cabal!
07:12:12 <arkeet> well, its package manager.
07:12:25 <arkeet> what distro does?
07:12:34 <arkeet> cabal isn't very good at removing/upgrading
07:12:38 <jmcarthur> there are distros that allow you to manage installations in your home
07:12:48 <jmcarthur> all i can think of right now is nix, but i know there are others
07:12:59 <arkeet> but nix is nix. :p
07:13:06 <jmcarthur> well, nix the package manager and nixos because it uses nix)
07:13:11 <hseg> Meaning? It looks quite nice
07:13:32 <jmcarthur> i don't believe this is unique to nix
07:13:57 <timthelion> hseg: if you have slackware, then you can choose your pacage manager. You can choose nix(not sure how this is different from installing nixos)
07:14:19 <jmcarthur> you can use nix with any distro, really
07:14:41 <jmcarthur> although it will typically be sandboxed away
07:14:41 <timthelion> jmcarthur: but what would be the point
07:14:48 <jmcarthur> to try it out
07:15:16 <jmcarthur> you can use portage similarly, with other distros, even other operating systems
07:16:11 <jerry66> http://www.reddit.com/r/xadultxmoviesxdating/comments/1buoth/german_amateur_girl_loves_anal/
07:16:21 <jmcarthur> thanks jerry66
07:16:47 * timthelion wonders how much more disk space would be used if we just kept statically linked single file installs for all applications. No more dependencies, everything self sufficient.
07:17:10 <Kinnison> it's less of a space issue these days than it was
07:17:15 <Kinnison> but it's more of a security issue than ever
07:17:16 <geekosaur> that's fine for applications, but most things are libraries
07:17:26 <timthelion> Kinnison: why is it a security issue?
07:17:41 <jmcarthur> geekosaur: non-devs wouldn't even need all those libraries installed, of course
07:17:45 <timthelion> geekosaur: but those libraries would be statically linked into the applications
07:17:47 <Kinnison> If you have a security update in a library, it's harder to update every app linked to it, rather than just update the lib
07:17:48 <geekosaur> have to rebuild everything impacted if a security issue is found in a dependency
07:17:53 <hseg> timthelion: Because an update to a library isn't propagated to the clients that way
07:18:02 <timthelion> geekosaur: true, that is a problem.
07:18:25 * hackagebot dynamic-loader 0.0 - lightweight loader of GHC-based modules or packages  http://hackage.haskell.org/package/dynamic-loader-0.0 (GaborGreif)
07:18:32 <int-e> so for distributions, we'd have a bandwidth problem
07:18:40 <arkeet> not to mention that there's a reason shared libraries are called that.
07:19:04 <jmcarthur> shared libraries don't just save hd space. they also save memory
07:19:09 <geekosaur> also note that applications are already largely statically linked with ghc (except on a small handful of platforms). and the problem we are trying to solve is at the level of building packages with library deps, i.e. at the very level that needs to work for static linking apps to provide any benefit
07:19:10 <timthelion> perhaps we could make it so that applications would declare dependencies on startup, and the distro would look those dependencies up in a blacklist, and refuse to launch apps with banned dependencies.
07:19:11 <arkeet> exactly
07:20:34 <hseg> perhaps we could compile everything to some bytecode, and distribute the bytecodes. Then, there would be binary that would be generated on first usage with all the optimizations.
07:20:41 <timthelion> I would like to get to the point, where each user has an applications folder in his home, and each application is a single file.  Don't like an application? simply deleted.  No instalation needed.
07:21:01 <Kinnison> I always figured that we went with static linking so much with haskell for a combination of 'People can barely maintain an API from point release to point release, let alone an ABI' and also 'whole program optimisation really matters for Haskell'
07:21:04 <arkeet> hseg: would it be called java?
07:21:40 <int-e> timthelion: it's not just shared libraries. applications come with data files and documentation
07:21:57 <k0001> Guys, do you know of any companies that would hire someone to work remotely doing some functional programming?
07:22:03 <hseg> :-D It would allow for the packages to be independent, and one could remove the binaries without introducing breakage.
07:22:04 <timthelion> arkeet: well, the problem with java, in the early days, is that Sun failled to maintain compatibility between VMs, thus making java the antithesis of it's own goal.
07:22:09 <jmcarthur> int-e: for that, at least, the os x bundle idiom is... okay...
07:22:39 <hseg> k0001: CUFP
07:23:30 <jmcarthur> Kinnison: i agree
07:23:34 <hseg> Think a cached JIT with the usual optimizations GHC does, and the cache can be cleared.
07:23:54 <jmcarthur> Kinnison: however, we do still have dynamic linking, but it still lacks many of the benefits of dynamic linking
07:23:58 <timthelion> hseg: what is the point of JIT
07:24:52 <hseg> As in, you would have the in-package optimizations compile to some IR, and then on first run you would have cross-package optimizations generate a cached binary.
07:25:00 <hseg> s/JIT/IR/
07:25:26 <timthelion> hseg: why on first run, rather than on EXECUTABLE(not library) compile time?
07:25:57 <int-e> hseg: what problem are you trying to solve?
07:26:32 <hseg> timthelion: In the case of executables, full static linking with whole program optimisation could work. But for libraries, I'd rather have them independent
07:27:33 <hseg> int-e: That under status quo, when a package gets installed, whole program optimisation bleeds code of the dependencies into the package, thus creating a hard dependency on that specific version
07:29:51 <k0001> hseg: thanks. I'll look in more detail there.
07:33:04 <hseg> Anyhow, need to go. Thanks guys!
07:37:40 <Kinnison> jmcarthur: Aye, it's hard
07:52:04 <klrr> how do i implement "symbol?" (scheme function) in haskell?
07:52:58 <totimkopf> Hello, how would I write this http://hpaste.org/85360 as a let expression?
07:54:54 <totimkopf> I tried this: let maximum' [] = error "maximum empty list!"; maximum' [x] = x; maximum' (x:xs) = max x (maximum' xs) in [2,5,1]
07:54:57 <geekosaur> I don't understand the question. you want to replace that with something involving a let? (not really possible) you want to use that in a let instead of at top level? (that just works)
07:55:11 <geekosaur> need braces if all on one line, I think
07:55:27 <geekosaur> but the full error message from your attempt would help
07:55:49 <klrr> totimkopf: what's a let expression, you mean like let stuff in expression?
07:55:55 <totimkopf> right
07:56:09 <supki> > let maximum' [] = error "maximum empty list!"; maximum' [x] = x; maximum' (x:xs) = max x (maximum' xs) in [2,5,1]
07:56:10 <lambdabot>   [2,5,1]
07:56:11 <klrr> why would you even want to do that?
07:56:26 <totimkopf> stepeval is complaining : step _: Not implemented: List [Lit (Int 2),Lit (int 5),Lit (Int1)]
07:56:32 <totimkopf> (for stepeval)
07:56:52 <geekosaur> that sounds like you actually have a different problem, then
07:56:59 <totimkopf> my brain has a tough time computing recursion so I use stepeval as a crutch
07:57:33 <geekosaur> so it actually worked but your stepeval is not capable of handling the result for some reason
07:58:15 <totimkopf> geekosaur, let me try with braces
07:58:37 <geekosaur> braces won't help
07:58:44 <totimkopf> oh
07:58:47 <geekosaur> braces would help if it were a syntax error
07:58:58 <geekosaur> this is not a syntax error, this is a problem with your stepeval
07:59:02 <totimkopf> I guess it is a shortcoming of stepeval then
08:02:51 <tomberek> what linux distro seems to be best suited for haskell hacking noawdays?
08:04:30 <Sonderblade> tomberek: all are good
08:05:25 <tomberek> sonderblade: i ran in to dependency problems a while back, so was wondering what he current status was
08:07:02 <Sonderblade> tomberek: haskell has its own package management system called cabal so it mostly doesnt matter what linux distro you choose
08:07:24 <hherhold> does anybody use command-line darcs anymore?
08:07:38 <hherhold> cabal install darcs with the latest haskell platform fails
08:07:39 <tomberek> yes, thanks.... nevermind
08:07:50 <hpaste> aesptux pasted “Digital Root” at http://hpaste.org/85361
08:08:17 <aesptux_> Why is this code http://hpaste.org/85361 somewhat recursive?
08:08:47 <ab9rf> "somewhat recursive"?  is that like somewhat pregnant?
08:09:06 <ab9rf> that code is not recursive
08:10:01 <aesptux_> Digital root of 31337 is 8. Because 3+1+3+3+7 = 17 and 1+7 = 8. Shoudn't that code output 17?
08:10:30 <geekosaur> do you understand modulus
08:10:31 <geekosaur> ?
08:10:51 <aesptux_> I understand the basics
08:11:16 <geekosaur> apparently not, since the most basic thing about it is that if you are going modulus n, the result will never be >= n
08:11:34 <geekosaur> so mod ... 9 can never return 9, 10, 17, 65535, ...
08:11:43 <ab9rf> aesptux_: the key is that the digital root of a positive integer is merely its modulus in the Z9 ring, with 9 replacing 0.
08:12:10 <Hafydd> The fact that it is "modulo" and not "modulus" is even more basic.
08:12:18 <geekosaur> you might also take a hint from the fact that there is no addition in there at all
08:13:37 <ab9rf> that code is strictly incorrect in that it reports the wrong digital root for 0 (and for negative numbers, although digital root is not well-defined for negative numbers)
08:13:58 * geekosaur speaks a language where the operator is "modulus" and "modulo" refers to its application; "modulo" is not itself the name of an operator.
08:14:23 <aesptux_> Oh I see... now i understand, didn't knew about that property of modulus
08:14:46 <ab9rf> aesptux_: the wikipedia page you linked in the paste explains why it works.
08:15:41 <aesptux_> ab9rf: What would be a proper way to handle 0? pattern matching? (as you imagine I'm fairly new to haskell)
08:15:56 <totimkopf> since I'm having issues with stepeval, could someone someone write the steps in parantheses of the maximum' function, please
08:16:25 <totimkopf> oops, s/someone someone/ someone
08:16:26 <ab9rf> aesptux_: that's one way, certainly
08:16:57 <ab9rf> aesptux_: it's really the only way since all of the other ways to do branching devolve to pattern matching at some level
08:17:31 <totimkopf> http://hpaste.org/85360
08:17:43 <aesptux_> ab9rf: Ok, thanks for all the help
08:17:48 <Hafydd> That's a bit demented, because the "modulus" in modular arithmetic is the right-hand argument of the residue function.
08:18:18 <Hafydd> It's like saying "6 denominator 3 = 2"
08:18:36 <ab9rf> there's a lot of weird baggage around the modulus operator because of the multiple meanings it has within abstract algebra
08:18:45 <geekosaur> ^^
08:18:52 <geekosaur> it is strange, but them's the breaks
08:19:18 <ab9rf> this only comes up when dealing with anal-retentive mathematicians
08:19:28 <Hafydd> I refuse to accept it.
08:19:52 <totimkopf> maximum' [2,5,1]: max 2 ( maximum' [5,1] ( max 5 ( maximum' [1] ) ) )   <--does this look right?
08:22:09 <ab9rf> right for what?
08:22:40 <totimkopf> right for swapping out the parantheses for real values..
08:23:57 <totimkopf> ab9rf: I'm just trying to work out the recursion in "steps"
08:28:07 <kartoffe`> what are the Monoid constraints in netwire good for? Is it just to get 'mempty' values, or does it some other stuff with it?
08:28:27 <ab9rf> totimkopf: that depends on the definition of "maximum'"
08:29:45 <totimkopf> ab9rf: oh, sorry, I thought you read the definition I had pasted
08:29:56 <donri> kartoffe`: my understanding is it uses mappend, so you can use [] instead of Last to record inhibits for example
08:30:06 <ab9rf> totimkopf: i missed it, sorry
08:30:24 <totimkopf> http://hpaste.org/85360
08:30:30 <totimkopf> it's the very same one from LYAH :)
08:31:25 <kartoffelbrei> donri: thanks. I guess i should just wirte more stuff with it.
08:31:36 <ab9rf> totimkopf: i'm not sure what you want to represent really
08:31:56 <geekosaur> totimkopf is trying to trace evaluation of that expression
08:32:01 <ab9rf> the "expansion" of maximum' [2,5,1] would be max 2 ( max 5 1 ), but it gets there in several steps
08:32:17 <geekosaur> but showed it rather confusingly
08:32:25 <donri> kartoffelbrei: see the Alternative instance for example http://hackage.haskell.org/packages/archive/netwire/4.0.7/doc/html/src/Control-Wire-Wire.html#Wire
08:32:40 <donri> kartoffelbrei: mempty is used for 'empty' and mappend is used in <|>
08:32:47 <ab9rf> the first would be max 2 ( maximum' [5,1] ), and then maximum' [5,1] is "expanded" to max 5 (maximi,
08:32:57 <ab9rf> er. max 5 (maximum' [1])
08:33:05 <donri> kartoffelbrei: by using the monoid abstraction, which works and makes sense here, you get more control
08:33:06 <ab9rf> and then maximum' [1] evaluates to 1
08:33:39 <totimkopf> sorry for being confusing, I'm still very new to haskell
08:33:50 <ab9rf> i don't recall whether haskell specifies the order in which a function's arguments are reduced or evaluated
08:34:14 <elliott> it sort of does
08:34:32 <elliott> in that "f True False = ..." desugars to "f a b = case a of { True -> case b of { False -> ... }; ... }"
08:34:36 <elliott> so "a" is analysed first
08:34:57 <totimkopf> ab9rf: there wouldn't be a more verbose expansion?
08:35:11 <ab9rf> i seem to recall that compilers have a lot of latitude to reorder evaluation
08:35:38 <totimkopf> ahh
08:35:40 <ab9rf> totimkopf: you can be as verbose as you want. :)
08:36:03 <ab9rf> the real issue is haskell's default laziness of evaluation
08:36:43 <ab9rf> and the whole concept of weak head normal form
08:36:52 <kartoffelbrei> donri: that makes sense. thanks.
08:38:08 <sandybatman> Hi, where can I find an unified archive of functional pearls? I don't have any subscription to JFP or other journals.
08:38:42 <sandybatman> I'm currently looking at haskellwiki linked from LtU.
08:38:58 <ab9rf> totimkopf: i'm not 100% on my own understanding of the reduction and evaluation process so i'm reluctant to try to explain it to you
08:39:20 <ab9rf> since i will almost certainly get it wrong and then shachaf will have to make harumphy noises at me
08:40:09 <andrewsw> http://www.vex.net/~trebla/haskell/lazy.xhtml
08:40:12 <andrewsw> is that relevant?
08:40:12 <donri> sandybatman: are you looking at http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls ?
08:40:20 <kartoffelbrei> nice. i found a bunch of examples on github. i'm gonna try them out and break them.
08:40:27 <totimkopf> well, feel free to query me, I'm curious about your take of the evaluation process. I normally have a tutor who helps me with this but she isn't around at the moment :S
08:40:33 <sandybatman> donri: yes
08:40:51 <donri> kartoffelbrei: where?
08:40:57 <sandybatman> donri: I just read through Bird's sudoku solver this morning and enjoyed it.
08:41:21 <donri> sandybatman: well those mostly look like direct links to pdfs?
08:41:52 <sandybatman> donri: yes, I had to find it with some searching. Asked too soon. :-)
08:42:05 <kartoffelbrei> donri: https://github.com/MaxDaten/netwire-examples these seem to be a bunch of examples from #haskell bundled together.
08:42:12 <donri> ah cool
08:42:24 <ab9rf> andrewsw: that page at least looks helpful
08:45:22 <oio> can all algorithms made functional?
08:46:32 <Starfire> Since you can simulate mutable memory in O(log N) time, yes.
08:46:54 <Starfire> Of course, that might not be very useful.
08:48:06 <oio> why?
08:48:11 <chrisdone> ?faq has anyone really been far even as decided to use even go want to do look more like?
08:48:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:49:05 <sandybatman> ?faq hashhaskell?
08:49:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:49:27 <jmcarthur> Starfire: it's useful at least for the free backtracking
08:49:56 <chrisdone> donri: ha ha! i am using the clay
08:50:08 <donri> any good?
08:50:30 <chrisdone> donri: http://i791.photobucket.com/albums/yy199/Philo-Publius/1234.gif
08:51:03 <chrisdone> seems alright so far. a few pull requests are needed but i ported my ide to it so i can do themes
08:51:12 <donri> cool
08:51:55 <donri> i'm considering porting my thing to idris ;p running into the limits of haskell with it
08:52:05 <chrisdone> your css thing?
08:52:07 <donri> ya
08:52:11 <chrisdone> =)
08:52:16 <donri> mostly for fun/testing
08:52:19 <jmcarthur> Starfire: also, it has only been proven that there are some algorithms that must take a log n penalty when translated to a *strict* functional language. there are some examples where that is necessary for a strict language but not for a lazy language. i don't think it has been proven that a similar constraint exists for a lazy language. (however, i suspect that for common notions of laziness such a
08:52:22 <jmcarthur> constraint also exists)
08:52:49 <chrisdone> donri: i wonder if idris can be competitive with Ur
08:53:00 <jmcarthur> ur has some features i'm pretty sure idris lacks
08:53:03 <donri> no idea, but it does have a js backend
08:53:26 <chrisdone> jmcarthur: which ones?
08:53:27 <jmcarthur> although of course one could probably emulate them with dls
08:53:29 <jmcarthur> *dsls
08:53:48 <oio> has anyone implement the guenter sudoku solver on haskell? http://magictour.free.fr/suexco.txt
08:53:53 <jmcarthur> chrisdone: row types, polymorphic functions over records, etc.
08:54:54 <jmcarthur> i guess the latter is somewhat like syb or something, but there's a lot more type information included
08:55:03 <chrisdone> right
08:55:36 <chrisdone> it seems pretty hard to do an SQL language with syb on plain records (i tried)
08:55:48 <jmcarthur> ah yeah, that makes sense
09:01:45 <Starfire> jmcarthur: I would imagine that for many problems, a dedicated functional algorithm would be better in some sense than emulating a mutating algorithm.
09:02:16 <Starfire> Or perhaps it's "some" instead of "many".
09:02:46 <chrisdone> jmcarthur: here was one hack i tried http://hpaste.org/78401
09:05:16 <godhack> hi
09:06:37 <jmcarthur> i'm trying to think of a way to allow a C function bound as an unsafe FFI call to asynchronously communicate some information back to Haskell land such that the C code doesn't block and some haskell thread can just block until information is available. is there anything i can do?
09:06:40 <chrisdone> jmcarthur: which amounts to basically being able to write data Foo { foo :: Int, bar :: Int } deriving (Data,Typeable) … select [field foo .=. Int 123] more or less. the trouble is it will accept any function of type Foo -> a
09:06:57 <godhack> I've read the paper written by Geoffrey Mainland from http://www.eecs.harvard.edu/~mainland/publications/ with the title: Haskell Beats C Using Generalized Stream Fusion. And since this is old, I'd like to know if the changes have been merged into the haskell platform.
09:07:10 <donri> chrisdone: did you see vinyl
09:07:20 <jmcarthur> godhack: it's old? i thought it was pretty new
09:07:34 <chrisdone> donri: was that Yet Another Record System?
09:07:35 <jmcarthur> godhack: it's only a few months old
09:07:43 <donri> chrisdone: yeah. http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
09:08:22 <jmcarthur> chrisdone: yeah generic programming is tough to get right :\
09:08:56 <jmcarthur> i think i will ask my FFI question in #ghc
09:08:59 <arkeet> jmcarthur: what you need is generic generic programming!
09:09:00 <arkeet> http://dreixel.net/research/pdf/ggp_draft.pdf
09:09:12 <godhack> jmcarthur: Yes it's from November 2012. The flux in the Haskell repo and the commit rate let a period of months appear like many years. Because there are so many changes.
09:10:30 <godhack> Is my question better suited for #ghc aswell?
09:10:41 <chrisdone> donri: right… looks like most other record libraries… really the aim is "just write normal haskell records", like ur, tho
09:11:16 <donri> chrisdone: oh, was just speaking generally because i know you've talked about this stuff before ("has" etc)
09:11:24 <chrisdone> nod
09:11:25 <godhack> Just want to know if I can already start using "Generalized Stream Fusion" with Haskell.
09:11:52 <chrisdone> i think i was one of the people who encouraged the author to call it vinyl =p it's a sexy name
09:11:57 <donri> chrisdone: vinyl looks neat because it uses type literals so you need less boilerplate to define fields
09:12:12 <chrisdone> nod
09:12:28 <monochrom> err, vinyl records?! haha cute name
09:12:32 <donri> chrisdone: haven't looked at ur really. is the records anything like elm records?
09:13:31 <chrisdone> donri: you mean the t-rex style structural stuff?
09:13:36 <donri> maybe
09:14:02 <chrisdone> don't remember if ur has that
09:14:09 <oab> vinyl records, are all haskell developers trolls?
09:14:14 <arkeet> godhack: yes, the vector package does stream fusion.
09:14:32 <arkeet> the paper even refers to this package.
09:15:18 <godhack> arkeet: it refers to other packages aswell. Not sure how broad the changes are and if all of them have been merged into ghc yet.
09:15:54 <elliott> yeah ur has structural records
09:15:57 <oio> Could this be port to haskell? https://github.com/attractivechaos/plb/blob/master/sudoku/sudoku_v1.c
09:16:22 <Taneb> @faw could that be ported to Haskell?
09:16:22 <lambdabot> The answer is: Yes! Haskell can do that.
09:16:35 <chrisdone> elliott: you've used it for some dev right?
09:16:44 <chrisdone> or maybe i'm thinking of thoughtpolice
09:16:59 <elliott> there is a good chance you are even thinking of another elliott, if experience is any indicator
09:17:06 <Kneiva> is possible to use Writer monad with Map, or should I use State?
09:17:16 <oio> it could be donde but if it is by myself ... it is going to be slow
09:18:05 <arkeet> oh, well vector doesn't use *generalized* stream fusion, perhaps.
09:18:19 <godhack> arkeet: Does ghc 7.4.2 include these changes? Or will I have to get the sources from somewhere else? (I'm on gentoo)
09:18:26 <arkeet> I have no idea.
09:18:39 <godhack> arkeet: ok, thank you :) I'll ask in ghc :)
09:19:33 <jmcarthur> the released version of vector does not do generalized stream fusion
09:22:03 <godhack> jmcarthur: well here's his haskell-platform repo https://github.com/mainland/haskell-platform , but I don't know the differences to the main repo and if that repo includes ghc
09:23:12 <jmcarthur> godhack: stream fusion is not a ghc thing
09:23:28 <jmcarthur> godhack: or do you mean the simd primops? that would be a ghc thing
09:23:37 <jmcarthur> godhack: (that's not released yet)
09:24:04 <godhack> jmcarthur: I just found that ghc has a simd branch
09:24:08 <thoughtpolice> godhack: if you're referring to the entirety of the paper, including the SIMD work, none of it is released yet. to be clear, the work squarely sits in vector, GHC and DPH themselves, and nothing else needs to necessarily be changed
09:24:17 <Wobat> Hello, I got a question, are there a lot of jobs in haskell?(in europe
09:24:19 <Wobat> )
09:24:29 <jmcarthur> Wobat: not yet
09:24:36 <thoughtpolice> it won't be available for widespread consumption  until 7.8, which is scheduled for October at this point
09:25:03 <Wobat> jmcarthur: I see, loving haskell atm, so just wondering about that :)
09:25:05 <godhack> Wobat: I've seen some offers only, but I'd be curious about that too.
09:25:16 <thoughtpolice> godhack: you're certainly free to build HEAD yourself, but the support is limited and Geoffrey will expand it further soon
09:25:21 <thoughtpolice> it's fairly rough at the moment
09:25:21 <Iceland_jack> Wobat: If you want to learn a language just to get employment, Haskell is the wrong language ;)
09:25:46 <jmcarthur> Iceland_jack: i slightly disagree with that. employers increasingly are looking for functional languages on resumes even if they don't use them in house
09:25:53 <godhack> jmcarthur: I'm really really new to Haskell, but I want to learn it, if there's a chance to beat C in performance. I really enjoy C btw.
09:26:09 <Wobat> Iceland_jack: no, don't want to learn for employment, I learn for my pleasure(only 16 years) so employment is a problem :)
09:26:50 <jmcarthur> godhack: performance shouldn't be the main reason to use Haskell unless it's the parallelism opportunities you are interested in. i think the main motivation for using haskell is typically a greater understanding of the code your read and write and with higher assurrances that it is reasonable
09:27:07 <jmcarthur> godhack: the performance does happen to be pretty good if you know what you're doing though :)
09:27:15 <Iceland_jack> jmcarthur: I'm not saying knowing Haskell won't benefit you, but if that's all you're after then Haskell would not be the top one
09:28:40 * hackagebot binary-conduit 1.0 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.0 (AlexanderVershilov)
09:28:41 <Philonous> Iceland_jack:  Actually, what would be the best one?
09:28:45 <godhack> jmcarthur: I am mostly interested in writing (web)applications that utilize multiple cores or cpus efficiently and in raw performance.
09:28:57 <godhack> and in writing an OS
09:29:08 <jmcarthur> Iceland_jack: most of my job prospects have actually come about due to haskell-related things
09:29:49 <Iceland_jack> Look jmcarthur, I'm not saying it's not possible to get a Haskell job or even that there aren't many of them
09:29:59 <godhack> Wobat: afaik, haskell people are needed in statistics and aerospace (but they apply statistics there again)
09:30:07 <jmcarthur> godhack: the haskell web app space is small and new but growing and maturing. performance-wise the existing haskell web servers are really nice (and expected to get even nicer)
09:30:09 <Iceland_jack> Or as a result of it, or what ever
09:30:16 <jmcarthur> Iceland_jack: i'm not saying anything about haskell jobs here
09:30:30 <Iceland_jack> Right, even getting non-Haskell jobs as a result of Haskell
09:30:52 <jmcarthur> godhack: raw sequential cpu performance generally is not as great as discussed in that paper, unfortunately, but it's gradually getting better too
09:30:53 <godhack> Wobat: I think python is much more demanded and used when it comes to statistics. It's getting more popular thanks to some excellen "data analysis" frameworks
09:31:04 <finnrobi> is there anywhere I can submit small programs for some code review and get feedback of the type "there's a library function that does this already", "the idiomatic way to do this is X", "this is going to use silly amounts of memory" or the like?
09:31:21 <Heffalump> finnrobi: there's hlint which will do some of that automatically
09:31:32 <finnrobi> Heffalump: cool, I'll check that out
09:31:39 <jmcarthur> Iceland_jack: all i'm saying is not only is it possible but it's not even all that unlikely. my own evidence may be anecdotal, but there is a fair bit of it
09:31:41 <Heffalump> and I guess codereview.stackexchange.com would be the natural place for human review, though I don't know how much haskell activity there is there
09:31:58 <thoughtpolice> people tend to post asking for code reviews on reddit, too
09:32:06 <arkeet> you could also just paste it here and ask, or post to one of the mailing lists
09:32:11 <Heffalump> http://codereview.stackexchange.com/questions/tagged/haskell - a fair bit
09:32:12 <arkeet> -cafe or -beginners maybe?
09:32:26 <Iceland_jack> jmcarthur: Sure: I just said it wasn't the absolute best one, and that is most certainly true. I appreciate your comments
09:32:42 <godhack> finnrobi: you could submit your progams to github and allow opening an issue ticket, then post that in irc. And automate the whole stuff using redmine or bash scripts to post to irc etc. when a special commit message is pushed
09:32:42 <niteria> does haskell have a string syntax that needs no escapes?
09:33:18 <godhack> finnrobi: actually pretty easy to setup. only sounds complicated.
09:33:23 <niteria> I have a blob of text I want to paste in
09:33:32 <finnrobi> plenty of good ideas here, thanks a lot :-)
09:33:46 <finnrobi> hlint seems to be very useful
09:34:17 <arkeet> niteria: http://hackage.haskell.org/package/interpolatedstring-perl6  if you're into TH.
09:34:17 <I_Begin> Q:Leksah . i d like to fire ghci with -fno-ghci-sandbox  for wx. any way to parametrize leksah ?
09:34:32 <mapf> niteria: can you read that from a file?
09:35:55 <niteria> mapf: I can but I don't want to
09:36:07 <arkeet> you could also use TH to read it from a file at compile time.
09:37:30 <niteria> interpolatedstring looks nice, are there any disadventages to using TH?
09:38:09 <mapf> niteria: it's sometimes becomes _slow_
09:38:26 <mapf> compilation time i mean
09:38:54 <arkeet> only if you do slow things, though
09:39:00 <klugez> Probably not a problem for just using it for string interpolation.
09:39:24 <arkeet> it's non-portable
09:39:36 <arkeet> and also there are worries about TH being able to do arbitrary IO at compile time.
09:41:01 <niteria> I wonder how vim deals with it
09:47:49 <XexonixXexillion> Why is type inference so slow...
09:48:31 <elliott> unless you're doing something unusual, it's generally not :)
09:48:31 <tsenart> hello there... would anyone have an insight on why sqrt . fromIntegral $ 3 `mod` 1 == 0.0 ? It should be == 0.7320508075688772
09:48:51 <sipa> 3 `mod` 1 is 0
09:49:06 <XexonixXexillion> elliott: I have an implementation of the wireworld cellular automata in the Haskell type system that I only just refound. It's *really* slow
09:49:19 <elliott> that counts as unusual, yes!
09:49:29 <arkeet> note: it parses as (sqrt . fromIntegral) $ (3 `mod` 1)
09:49:33 <elliott> cool hack
09:49:44 <tsenart> arkeet, sipa: thanks
09:50:06 <tsenart> so I need (sqrt . fromIntegral $ 3) `mod` 1
09:50:11 <arkeet> > sqrt (fromIntegral 3) `mod` 1
09:50:13 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:50:14 <lambdabot>    (GHC.Float.Floating a0)...
09:50:18 <arkeet> > sqrt 3 `mod` 1
09:50:20 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:50:20 <lambdabot>    (GHC.Float.Floating a0)...
09:50:23 <arkeet> > sqrt 3 `mod` 1 :: Double
09:50:25 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
09:50:25 <lambdabot>    arising from a use ...
09:50:34 <tsenart> hmm
09:50:35 <arkeet> well you can't anyway.
09:50:42 <niteria> how would I read it from file at compile time?
09:51:08 <mapf> niteria: you can do arbitrary IO
09:51:09 <elliott> tsenart: what semantics are you desiring from mod?
09:51:11 <arkeet> niteria: you put a suitable IO action in your TH thing
09:51:38 <arkeet> > sqrt 3 `Data.Fixed.mod'` 1 :: Double
09:51:39 <tsenart> elliott: I want to extract the fractional part of the result of sqrt
09:51:40 <lambdabot>   0.7320508075688772
09:51:48 <arkeet> I have no idea why that's in Data.Fixed
09:52:04 <XexonixXexillion> can I get GHC to memoize types? If I have a tuple (transitionWorld world, transitionWorld (transitionWorld world)) it calculates the type of (transitionWorld world) twice
09:52:04 <jmcarthur> XexonixXexillion: type inference is an exponential algorithm, actually
09:52:18 <tsenart> nice
09:52:24 <tsenart> will look into that
09:52:29 <tsenart> thanks everyone
09:52:32 <arkeet> XexonixXexillion: huh?
09:52:50 <jmcarthur> arkeet: XexonixXexillion is doing some weird type level computation
09:52:50 <arkeet> uh
09:52:52 <arkeet> I see.
09:53:55 <elliott> XexonixXexillion: perhaps pass it as an argument to a type family
09:53:57 <mapf> XexonixXexillion: you can try to use type synonims
09:54:01 <elliott> just like (\name -> ...) exp gives you sharing
09:54:16 <XexonixXexillion> I'll give that a shot, but I have to go now
09:55:30 <ab9rf> muh
09:59:04 <niteria> GHC stage restriction: fileq is used in a quasiquote, and must be imported, not defined locally
09:59:11 <niteria> huh? is there a reason for that?
09:59:19 <ab9rf> heh, that is weird
10:03:47 <arkeet> niteria: well, you can't have a module that needs to be already compiled in order to compile.
10:04:32 <arkeet> quasiquoters can be used in the same module, I think.
10:04:38 <arkeet> it's just splices that must be imported.
10:04:46 <arkeet> either that or I'm totally wrong.
10:04:53 <niteria> ok, that makes sense
10:05:42 <dmj> what is the easiest way to sort a map from Data.Map?
10:05:51 <arkeet> sort?
10:06:07 <dmj> Yea, by key
10:06:21 <dmj> arkeet: actually value, in this case my values are Ints
10:06:25 <parcs> a map is already ordered by key
10:06:43 <dmj> fromList [("hey", 3),("dude",4)]
10:06:52 <dmj> to be sorted by the int
10:06:59 <monochrom> sortBy (comparing snd) (fromList your_map)
10:07:16 <parcs> it doesn't make sense for an ordered map to be sorted by value
10:07:23 <arkeet> monochrom: you mean toAscList?
10:07:34 <monochrom> err, toList
10:07:38 <arkeet> or toList
10:07:40 <monochrom> sortBy (comparing snd) (toList your_map)
10:07:54 <arkeet> of course, the result won't be a map.
10:07:56 <arkeet> it wouldn't make sense to be.
10:07:56 <__xc> > 2.5421 `Data.Fixed.mod'` 1 :: Double
10:07:58 <lambdabot>   0.5421
10:08:06 <dmj> toDescList seems to work
10:08:17 <arkeet> "seems to"?
10:08:21 <ab9rf> maps don't even require that their vale type be sortable
10:08:24 <__xc> > 2.5421 `div` 1 :: Double
10:08:26 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
10:08:26 <lambdabot>    arising from a use ...
10:08:26 <monochrom> yes, it works for some examples
10:08:28 <dmj> arkeet: I need to test it fully
10:08:57 <arkeet> yes, it works if your keys happen to be in the reverse order of the values.
10:09:00 <monochrom> fromList (map (\(x,y) -> (y,x)) (toList your_map))
10:09:23 <narens> question: in lens, what is the succint way to write (+1) <$> use _1?
10:09:49 <elliott> :t uses _1 (+1)
10:09:50 <lambdabot> (Num r, MonadState s m, Field1 s t r b) => m r
10:10:10 <narens> thanks, sometimes the types just really confuse me
10:10:20 <arkeet> that's what the documentation is for.
10:10:22 <elliott> they take some getting used to :)
10:10:23 <ab9rf> narens: that is the purpose of types :)
10:10:51 <narens> yea, i just didn't take the time to read the types in the lens package... just jumped in using examples.
10:10:56 <arkeet> e.g. uses :: MonadState s m => Getter s a -> (a -> r) -> m r
10:11:51 <arkeet> narens: the documentation is really helpful for that kind of stuff.
10:11:58 <niteria> @pl (x,y) -> (y,x)
10:11:58 <lambdabot> (line 1, column 9):
10:11:58 <lambdabot> unexpected '>'
10:11:58 <lambdabot> expecting operator
10:12:05 <arkeet> @pl (x,y) -> (y,x)
10:12:05 <lambdabot> (line 1, column 9):
10:12:05 <lambdabot> unexpected '>'
10:12:05 <lambdabot> expecting operator
10:12:06 <arkeet> er
10:12:07 <niteria> @pl \(x,y) -> (y,x)
10:12:07 <lambdabot> uncurry (flip (,))
10:13:26 <narens> maybe I can ask another related qustion. So its clear how to do item %= some_pure_function... but how do i do it if the r.h.s is a monadic function?
10:13:43 <Taneb> lens?
10:13:57 <Taneb> :t (<~)
10:13:58 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
10:14:15 <narens> ah
10:14:26 <Taneb> Well, that's .=
10:15:58 <arkeet> huh, I didn't know <~ existed.
10:19:05 <SaBer> If I patched a package from hackage that doesn't build on a recent ghc (I used cabal fetch to get it), is there some easy way to get a diff of what I did?
10:19:31 <int-e> SaBer: unpack a second copy, then use diff?
10:19:52 <SaBer> int-e: ok, I thought there might be some shortcut...
10:20:08 <mauke> diff -ruN the-package-original/ the-package/
10:20:41 <int-e> SaBer: there's a shortcut for fetching and unpacking the archive though:  cabal unpack <package>
10:21:07 * SaBer wonders if anyone is interested in a patch if the package was last updated in 2009...
10:21:10 <int-e> (though be careful, I think that can overwrite the contents of an existing directory)
10:21:23 <monochrom> cabal absorption law: fetch >> unpack = unpack :)
10:22:34 <dolio> configure >> build >> install = install.
10:22:36 <int-e> monochrom: by "unpacking the archive" I meant tar xzf ~/.cabal/packages/hackage.haskell.org/<package>/<version>/<package>-<version>.tar.gz
10:23:40 <monochrom> eww
10:23:44 <int-e> exactly :)
10:24:05 <int-e> But I did that for a while before I learned about unpack. (And possibly before the command even existed)
10:24:19 <monochrom> also, mind this: configure --prefix=/not/default >> build >> install /= install
10:25:25 <supki> monochrom: what's the difference?
10:25:39 <dmwit> install doesn't keep any options you passed to configure.
10:25:52 <dmwit> (prefix is just one example of the options it doesn't keep)
10:26:07 <supki> well, then it's = ?
10:26:16 <dmwit> Also, install will re-run the constraint solver, and possibly choose a different solution. Though I think this is pretty unlikely.
10:26:51 <int-e> cabal install --prefix=/not/default  should work
10:26:55 <dmwit> Oh. Okay, maybe I'll let monochrom say what he thinks is different, then.
10:26:56 <supki> configure --prefix=/not/default >> build >> install /= install --prefix=/not/default
10:27:23 <int-e> supki: why?
10:27:47 <supki> int-e: for reasons dmwit has mentioned
10:27:50 <dmwit> int-e: See my explanation above, which was mistakenly backing up supki and not monochrom. =)
10:28:13 <int-e> ah wait, correcting monochrom's example
10:28:16 <int-e> right.
10:28:52 <dmwit> Or perhaps he meant configure --foo >> build >> register /= install
10:29:03 <dmwit> I dunno.
10:29:20 <dmwit> /= install --foo even
10:31:00 <parcs> :t let (a + b) c d e f g = () in (+)
10:31:01 <lambdabot> t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> ()
10:31:46 <int-e> configure; build; copy; register ?
10:31:48 <monochrom> the inequation I wrote is exactly right
10:32:27 <dmwit> What's the difference?
10:32:38 <monochrom> and it is mainly because install performs configure
10:34:04 <monochrom> see my http://thread.gmane.org/gmane.comp.lang.haskell.cafe/101796
10:34:55 <dmwit> monochrom: You seem to be supporting supki in that there really should be an '=' there.
10:35:17 <dmwit> or perhaps the inequality should be configure --prefix >> build >> install /= install --prefix
10:35:45 <monochrom> let me write my inequation again
10:35:54 <monochrom> configure --prefix=/not/default >> build >> install /= install
10:36:20 <dmwit> This is not what your email says. Your email says the last install on the left-hand side ignores the prefix from the configure; so what's different between them?
10:36:24 <monochrom> I fully mean this inequation and it is provably correct
10:36:39 <monochrom> oh, wait, my error
10:37:00 <monochrom> you are right. what supki says
10:37:10 <monochrom> I am terribly sorry
10:45:12 <NemesisD> hi guys. i'm curious if this monadic function could be made to be point free and still legible: foo params = do stream <- getMetrics params; liftIO $ S.toList stream
10:45:36 <NemesisD> it feels like i need some sort of monadic composition or something
10:45:54 <mauke> @. pl undo foo params = do stream <- getMetrics params; liftIO $ S.toList stream
10:45:55 <lambdabot> foo = (liftIO . S.toList =<<) . getMetrics
10:47:06 <monochrom> getMetrics params >>= liftIO . S.toList
10:47:07 <geekosaur> monadic composition is (>>=) (or (=<<) which is the flipped version) and do notation is translated into uses of it
10:47:21 <hpaste> niteria pasted “Record hack” at http://hpaste.org/85365
10:47:24 <mauke> @undo foo params = do stream <- getMetrics params; liftIO $ S.toList stream
10:47:24 <lambdabot> foo params = getMetrics params >>= \ stream -> liftIO $ S.toList stream
10:47:39 <niteria> is there anything wrong with this approach?
10:48:11 <NemesisD> hmm. its a little odd looking but if i break the (liftIO . S.toList =<<) into a "where" as consume its quite nice: foo params = consume . getMetrics
10:48:16 <niteria> I imagine you could automate this with TH
10:48:26 <jmcarthur> liftIO . S.toList <=< getMetrics
10:48:58 <mauke> liftM liftIO S.toList <=< getMetrics
10:49:36 <NemesisD> ah yes! <=<
10:50:18 <NemesisD> i've never actually used that function anymore because most documentation on it just calls it klesli composition and leaves it at that
10:51:05 <jmcarthur> @src (<=<)
10:51:05 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:51:14 <jmcarthur> @src (Control.Monad.<=<)
10:51:14 <lambdabot> Source not found. I feel much better now.
10:54:11 <Taneb> f >=> g     = \x -> f x >>= g
10:54:17 <Taneb> (<=<) = flip (>=>)
10:55:21 <Taneb> Can you derive the law that (>=>) is associative from the (>>=)/return monad laws?
10:55:27 <NemesisD> i very rarely use >>=. i don't like how it reads
10:55:39 <Saizan> Taneb: yeah
10:55:55 <NemesisD> it feels more imperative to me than =<<, maybe just how i use it
10:57:13 <narens> question: how come passing cabal test +RTS -N doesn't work? Does it not pass the -N flag to the test program?
10:57:17 <monochrom> >>= is meant to be imperative
10:57:32 <monochrom> =<< is meant to be imperative written right-to-left
10:58:22 <__xc> monads are the imperative part of haskell then?
10:58:30 <Taneb> No
10:58:37 <Taneb> Monads are monads
10:58:40 <geekosaur> the IO monad is the imperative part of haskell, sort of
10:58:42 <monochrom> not necessarily. some monads are meant to be imperative, but not all
10:58:43 * hackagebot clay 0.4 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.4 (SebastiaanVisser)
10:58:47 <geekosaur> but IO is not at all a representative monad
10:58:51 <mauke> (f >=> g) >=> h = \y -> (\x -> f x >>= g) y >>= h = \y -> (f y >>= g) >>= h = \y -> f y >>= (\x -> g x >>= h) = \y -> f y >>= (g >=> h) = f >=> (g >=> h)
10:59:09 <__xc> ok
10:59:23 <NemesisD> *brain explosion*
10:59:30 <geekosaur> the list monad is in many ways anti-imperative, in fact (it's sometimes called the nondeterminism monad)
11:00:31 <mauke> it gets more readable if you replace " = " by newlines
11:00:32 <__xc> > "ok" >>= \x -> [x]
11:00:34 <lambdabot>   "ok"
11:00:42 <mauke> also I'm not sure whether the middle step is actually a monad law
11:00:47 <monochrom> narens: I don't really know about cabal test, but after reading cabal test --help, I don't think there is any way to pass flags to the test program
11:01:37 <narens> monochrom: k, i will just call the test program directly.. doesn't matter much to me
11:01:58 <mauke> I'm just going to assume someone will correct me if I'm wrong on the internet
11:02:25 <monochrom> narens: sorry, I misread, --test-options and --test-option may help
11:02:54 <narens> monochrom: thanks, i'll take a look
11:05:27 <monochrom> I have checked mauke's steps. they are right.
11:06:14 <kartoffelbrei> Is the 'Wire' type of netwire an instance of Num ?
11:06:21 <mauke> \o/
11:06:28 <elliott> monochrom seal of approval
11:06:38 <mauke> is it black and white?
11:08:23 <kartoffelbrei> It is. Should have asked ghci before asking here, sorry.
11:12:46 <ab9rf> no, it's blue on blue.
11:19:50 <dmj`> I'm reading in a text file that is 3MB and printing the word frequencies to the command line. I'm about 3 minutes in and its still churning. Should I use ByteStrings instead of normal strings?
11:22:03 <jmcarthur> something sounds seriously wrong to take three minutes to process only 3MB. more wrong than just using String
11:22:27 <Rembane_> dmj`: Pastebin your code! :)
11:22:28 <Taneb> For word frequencies, I'd use Text
11:23:43 <monochrom> I agree about something less superficial than just string vs bytestring
11:24:20 <monochrom> be prepared to replace 90% of current code
11:24:43 <Taneb> I think the bottleneck might be in the counting rather than the traversing
11:26:24 <hpaste> dmj pasted “File reading at 3min” at http://hpaste.org/85367
11:28:03 <dmj`> So, I'm reading in a file, cleaning the input a bit, then adding it to a map, converting to a list, adding a linear scale, sorting it by frequencies, removing 0 frequencies then mapM_ to IO
11:28:36 <dmj`> From what I've read it seems like attoparsec would be good for this...
11:28:42 <dmj`> This is the stanford homework assignment
11:29:01 <dmj`> monochrom: lol, I'm ready
11:31:03 <dmj> sorry got kicked off
11:31:10 <dmj> did I miss something?
11:31:35 <elliott> nope
11:36:50 <dmj> any suggestions? Or is everyone still in awe at how many linting errors there are
11:37:30 <kurkale6ka> Hi, in newtype Pair b a = Pair { getPair :: (a,b) } what means that the second type parameter represents the type of the first component in the tuple. What happens to a when one writes Pair 2 for instance?
11:37:41 <NemesisD> is there a way in ghci to get the types/info on unexported functions? my code compiles when i don't declare one function's type, and now I want GHCi to tell me what it decided that type should actually be
11:39:09 <dmj> brb
11:39:59 <klrr> can main take arguments? ive written a prompt to my scheme implementation, and i want the main to take a list so i can append the last used command to the list so that you can type up and get the last used command written in the scheme prompt
11:40:14 <Taneb> klrr, no
11:41:06 <monochrom> it is printMap. it essentially does this: (("hello" ++ "hi") ++ "howdy") ++ "greetings"
11:41:40 <dmj> monochrom: so concat'ing strings is expensive?
11:41:50 <monochrom> not always
11:42:23 <monochrom> "hello" ++ ("hi" ++ ("howdy" ++ "greetings")) is tremendously cheaper, for the same answer
11:42:50 <dmj> > :t (++)
11:42:54 <lambdabot>   mueval-core: Time limit exceeded
11:43:08 <dmj> monochrom: Why is that?
11:43:17 <klrr> Taneb: okey
11:43:30 <monochrom> I will let someone else explain
11:44:04 <dmj> monochrom: ok, also did you use a profiler to find that out or just a glance?
11:44:14 <Taneb> klrr, I'd make a second function if I were you
11:44:41 <klrr> well, i dont know how it would work so i cant make it, ill finish the implementation first
11:44:41 <monochrom> neither. I carefully read. not glance.
11:48:15 <dmj> monochrom: I see, it's O(n^2) at least because in order to find the maximum val and longest key I have to scan through the map everytime.
11:48:28 <dmj> for each element in the map
11:52:58 <Mortchek> klrr, foo bar = …; main = foo someDefaultArgument
11:53:10 <Mortchek> s/Default/Initial/
11:58:14 <dmj> monochrom: Is there anything else you see with the code that is glaringly wrong? I won't be offended
12:00:53 <supki> dmj: toList is about the worst name for something that takes a list and produces a map
12:01:13 <monochrom> heh
12:04:45 <crdueck> why is this line of Repa code misbehaving (it stalls, and gets autokilled within a few seconds): R.fromListUnboxed (R.ix2 10 10) . randomRs (0, 1) :: StdGen -> Array U DIM2 Int
12:07:22 <dmj> supki: Good call :)
12:07:36 <dmj> supki: how does toMap sound?
12:07:40 <hpaste> monochrom annotated “File reading at 3min” with “major factor” at http://hpaste.org/85367#a85368
12:08:39 <monochrom> dmj: my paste shows the major reduction of time cost. there are other minor ones I won't go into today
12:09:53 <js6i> How difficult would be to hack mutable arrays for accelerate-cuda? So I could reuse instead of allocating new output array on each kernel execution.
12:10:04 <monochrom> on /usr/share/dict/words (0.98M) it is only 3 seconds
12:12:55 <dmj> monochrom: Just did LesMis.txt (3.2M) in 2.11s. Incredible reduction
12:14:18 <flebron> I'm reading lines from stdin. How can I ignore a line? _ <- getLine still throws a readIO parse error when I try to read the next line.
12:14:30 <flebron> Specifically, I'm trying to ignore a blank line.
12:14:39 <dmj> monochrom: That's a very big performance increase for what seemed like a minor fix. Thanks a lot. I'll try to read up on string appending rules.
12:14:54 <hpaste> DMcGill pasted “Code prototyping” at http://hpaste.org/85369
12:14:56 <flebron> "1\n\n3", for instance. I want to read the 1, skip the empty line, and read the 3.
12:15:19 <DMcGill> I'm a little stuck with the structure of my code, if somebody could take a look I'd be most grateful
12:19:09 <DMcGill> flebron: try something like `allLines <- getContents; let nonEmptyLines = filter (not null) (lines allLines)'
12:19:36 <flebron> I was trying to do this without getContents xP But alright, I'll use that. Thanks :)
12:20:02 <DMcGill> if you have an unknown number of black lines, it's difficult to do it with simply calling getLine
12:20:06 <DMcGill> blank*
12:23:43 <DMcGill> flebron: `let get1st3rd = do {one <- getLine; _ <- getLine; three <- getLine; return (one,three)}' worked just fine for me
12:24:16 <flebron> Yeah, for some reason using readLn :: IO String on the one after the blank one was not working, I needed getLine.
12:25:18 <DMcGill> > read ""
12:25:20 <lambdabot>   *Exception: Prelude.read: no parse
12:25:52 <DMcGill> > (read "" :: Int)
12:25:53 <lambdabot>   *Exception: Prelude.read: no parse
12:25:57 <DMcGill> > (read "" :: String)
12:25:59 <lambdabot>   "*Exception: Prelude.read: no parse
12:26:22 <DMcGill> flebron: `readLn' calls `read', which usually fails on empty strings
12:26:27 <flebron> Not even empty strings
12:27:05 <flebron> sorry, dc'd
12:27:05 <flebron> > (read "abc" :: String)
12:27:07 <lambdabot>   "*Exception: Prelude.read: no parse
12:27:27 <flebron> I guess it would need the quotes around abc for it to be a String.
12:27:32 <DMcGill> yes, exactly
12:27:41 <DMcGill> > (read "\"abc\"" :: String)
12:27:43 <lambdabot>   "abc"
12:28:40 <DMcGill> just to be clear, "abc" = ['a','b','c'] which doesn't look like a String but "\"abc\"" = ['\"',a,b,c,'\"'] which does
12:28:40 <paolino> DMcGill, after you fold interaction of one element against the rest you have the new element and a list of changes you can apply and start with the next element, I think a mapAccumL can do
12:29:12 <DMcGill>  ['\"','a','b','c','\"']
12:33:48 * hackagebot darcs2dot 0.1.0.1 - Outputs dependencies of darcs patches in dot format.  http://hackage.haskell.org/package/darcs2dot-0.1.0.1 (SoenkeHahn)
12:36:10 <Counterspell> Ontolog: yo
12:36:59 <Counterspell> hey, can someone point me to a good resource for doing graphics in Haskell? I am new to both Haskell and graphics, however I did go through a little more than half of Learn You a Haskell and I want to start actually doing something before I lose my motivation
12:38:04 <ChongLi> Counterspell: have you checked out gloss?
12:38:17 <monochrom> the book "The Haskell School of Expression" by Paul Hudak
12:38:19 <Counterspell> ChongLi: nope, i'll check it out now
12:38:24 <Counterspell> just stumbled upon this too: http://www.haskell.org/haskellwiki/OpenGLTutorial1
12:39:25 <Counterspell> monochrom: looks good
12:39:25 <DMcGill> Counterspell: I learnt from http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
12:40:16 <DMcGill> given that OpenGl is an embedded language and the same in most languages, Beautiful Code also shows you reasons for using Haskell over any other embedding
12:40:30 <DMcGill> which is something that simply learning the OpenGl syntax wouldn't
12:44:03 <adzeitor> DMcGill: At first glance "Beatiful Code" looks great. Thanks.
12:45:13 <hiptobecubic> I remember at one point reading an interesting story about a machine that printed coins. The story goes on to say we could make a machine that takes a coin template and then makes coin-making machines. This abstraction continuous until it gets to something like a, "a machine which takes a spec for machine making machines as input and produces a machine a that makes machine making machines" or something crazy
12:45:15 <hiptobecubic> and then says that nothing useful happens beyond that level. Does anyone have any recollection of this at all?
12:45:32 <hiptobecubic> continues* not continuous
12:46:12 <hiptobecubic> I believe the general topic was ostensibly intended to be "compilers"
12:46:16 <crdueck> is there a way to get a visual representation of a Repa array?
12:49:48 <hpaste> paolino annotated “Code prototyping” with “Code prototyping (annotation)” at http://hpaste.org/85369#a85370
12:51:17 <crdueck> > print $ Data.Array.Repa.fromListUnboxed (Data.Array.Repa.ix2 3 3) ([1..9] :: [Int])
12:51:19 <lambdabot>   Not in scope: `Data.Array.Repa.fromListUnboxed'Not in scope: `Data.Array.Re...
12:52:01 <crdueck> :i repa
13:00:43 <nwf> Hey all; I have a strange problem: while running inside a MaybeT State monad, I am calling Data.Foldable.mapM_ on some function and an empty map and getting "<<loop>>" exceptions.  If I replace the function invocation with "undefined" the computation terminates without hitting that _|_.  Help?
13:02:11 <shachaf> Do you have @pasteable code?
13:03:21 <nwf> I don't have a minimized example and there's a lot of cruft to cut through.
13:03:46 <tootooroo> Is there any way to use cabal to query packages whose exact name is a given string?
13:03:56 <shachaf> @src mapM_
13:03:57 <lambdabot> mapM_ f as = sequence_ (map f as)
13:04:02 <dcoutts_> tootooroo: cabal info blah
13:04:03 <shachaf> @src sequence_
13:04:03 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:04:07 <tootooroo> dcoutts_: ty
13:04:18 <hpc> there's also hackage
13:04:24 <shachaf> Well, it's not that mapM_
13:04:40 <shachaf> nwf: Are you sure the <<loop>>s are coming from there?
13:04:48 <shachaf> Did you try xc?
13:04:54 <shachaf> @where rts-xc
13:04:54 <nwf> Yes; I have stuck Debug.Traces around.
13:04:54 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
13:05:05 <shachaf> Hmm.
13:05:17 <nwf> I don't have profiling versions of all of my dependencies handy, so that'd take some time to get, too.
13:05:33 <shachaf> Well, you're surely going to want to do it one of these days, so... :-)
13:05:52 <shachaf> (You should have library-profiling: True in ~/.cabal/config.)
13:05:57 <nwf> But yes, I see the debug trace from entering the function's case arm and then the system "gets quiet" until the GC runs (which may well be forever)
13:06:17 <shachaf> I guess your own mapM_ that ought to be equivalent to the Data.Foldable one and see what happens?
13:06:37 <nwf> The trace in the callback function does not fire; replacing the callback's invocation with undefined allows the code to proceed.
13:06:40 <nwf> Which is startling.
13:06:58 <nwf> (Especially since, as I said, it's a mapM_ over in this case an empty map!)
13:07:09 <shachaf> Right, it sounds odd.
13:07:24 <shachaf> "can't easily debug it over IRC"-odd, at any rate.
13:07:25 <monoidal> @unmtl MaybeT State
13:07:25 <lambdabot> Plugin `unmtl' failed with: `MaybeT State' is not applied to enough arguments, giving `/\A B. Maybe A -> (B, Maybe A)'
13:07:52 <shachaf> I would say try to get an isolated test case.
13:07:59 * nwf nod
13:08:19 <shachaf> (Or put your entire code up somewhere, I guess.)
13:08:33 <shachaf> But probably hunting for the test case will at least discover something.
13:09:09 <Taneb> Remember that djm chap who was hear a few minutes ago?
13:09:50 <Taneb> I was bored so I rewrote his word-county program using Lazy Text and Strict HashMap
13:10:09 <Taneb> It runs relatively quickly
13:16:27 <Taneb> (16 seconds for Richard III, 172420 characters)
13:16:59 <Ontolog> are we not able to `read` functions in Haskell?
13:17:07 <Taneb> Nah
13:17:11 <Taneb> We aren't
13:17:13 <Ontolog> :(
13:17:29 <geekosaur> what does that even mean?
13:17:47 <Taneb> Presumably, you mean something like JavaScript or Python's eval?
13:17:54 <Taneb> Or whatever it's called
13:18:51 <Taneb> That would be quite difficult in a compiled language like Haskell, and would increase the size of the compiled executable a fair bit
13:19:19 <donri> Ontolog: you can do that with hint or plugins though if you really want to
13:19:26 <donri> (those are package names)
13:19:46 <Ontolog> cool thanks was just curious
13:20:05 <monoidal> Ontolog: often Data.Map can be used a substitute, if your function has finite domain
13:20:41 <donri> well not sure about hint
13:21:07 <geekosaur> hint does; XMonad.Actions.Eval uses it
13:21:13 <Taneb> Wow, compiled it's really quick
13:21:13 <geekosaur> (in xmonad-extras)
13:21:16 <Ontolog> i'll setup a map like [("+", (+)), ("-", (-)), ...]
13:21:31 <Taneb> Less than half a second for Richard III
13:21:48 <donri> geekosaur: can hint evaluate to a function type? its eval is String to String
13:21:56 <donri> maybe with "interpret"
13:22:34 <monoidal> Ontolog: yes, that's a common idiom. if the list is not large, you can use Prelude.lookup
13:22:40 <geekosaur> eval is, as I understand it, a wrapper which evaluates an arbitrary expression with a Show-able type
13:23:09 <Ontolog> are there any plans to make Haskell introspective?
13:23:28 <Taneb> If introspective means what I think it means, no
13:23:31 <Ontolog> i think that would make me feel a lot better about using Haskell for real stuff
13:23:33 <Taneb> But see Template Haskell
13:23:39 <jmcarthur> Ontolog: why?
13:23:43 <Ontolog> is Template Haskell a separate build of GHC or something?
13:23:54 <Ontolog> jmcarthur: coming from Ruby-land i rely a lot on introspection
13:23:55 <jmcarthur> no it's just an extension
13:23:59 <Ontolog> cool
13:24:01 <jmcarthur> Ontolog: in haskell land we don't
13:24:06 <Taneb> No, it's an extension that lets you do stuff at compile time
13:24:18 <Ontolog> oh im talking about runtime stuff
13:24:27 <Ontolog> like not knowing the type of something until runtime
13:24:33 <Taneb> Template Haskell isn't what you want, then
13:24:37 <jmcarthur> we have ways of doing that
13:24:48 <jmcarthur> but they are not often used because there are usually far better things to do
13:24:49 <geekosaur> ghc can do introspection via ghc-api (or wrappers thereof like plugins or hint); wiring it into the language would be difficult, as currently it's rather tightly tied to how ghc works and it's not clear how to extend it to uhc, jhc, etc.
13:25:01 <geekosaur> without complicating them
13:25:10 <Ontolog> i see
13:25:10 <taylorgb> Is it really necessary?
13:25:14 <jmcarthur> Ontolog: you can, for example, use Typeable to reify a value's type
13:25:15 <Ontolog> maybe not
13:25:21 <Ontolog> i dont really know haskell enough yet to tell
13:25:26 <jmcarthur> Ontolog: but there are very few applications where it's sensible
13:25:29 <Ontolog> like im thinking about an "ORM"
13:25:41 <Ontolog> or in Haskell's case a TRM
13:25:45 <Ontolog> type relational-map
13:25:46 <jmcarthur> Ontolog: generic programming covers a lot of those cases
13:25:49 <Ontolog> ok
13:25:49 <geekosaur> or via template haskell, which ahs the same problem (it uses GHC's AST, might be difficult to make work with other compilers, would be impossible to make *portable* between compilers without severe limitations)
13:25:57 <tcrayford> you can use typeclasses for a lot of that stuff as well
13:41:01 <Taneb> Heh, I just concatenated Richard III and the Comedy of Errors, and this version runs with that data still under half a second
13:41:20 <Taneb> Well
13:41:26 <Taneb> Sort of about half a second
13:44:39 * typoclass . o O ( 'comedy of errors' refers to pages of ghc messages )
13:45:13 <Taneb> (I'm pretty sure context made clear it was the Shakespeare play)
13:45:22 <Taneb> (one of my favourites)
13:45:46 * monochrom . o O ( why would you combine literature with ghc messages? )
13:46:19 <Taneb> I have been studying how I may compare, this Int64 with this Word16
13:46:33 <Taneb> But for because they are different types, I cannot hammer it out
13:46:48 <geekosaur> but they have something in common. I suggest looking at :info for both
13:47:05 <monochrom> Soldier: The King is dead. Long live the King!
13:47:14 <monochrom> All: The King is dead. Long live the King!
13:47:22 <monochrom> GHC: My brain has exploded.
13:47:25 <typoclass> geekosaur: i think that's not what Taneb meant :-)
13:47:37 <geekosaur> oh, I see
13:47:40 <geekosaur> durr
13:47:40 <typoclass> GHC: The Kind has been garbage-collected.
13:47:47 <monochrom> hehe
13:47:50 <typoclass> Kind, King, whatever
13:47:53 * geekosaur could use some sleep... sadly, not happening any time soon
13:48:28 <derek_c> Hello!  I just saw this piece of code:
13:48:30 <derek_c> \render -> mconcat ["<a href='", render Time, "'>The time</a>"]
13:48:43 <derek_c> can anyone tell me what does the "\" symbol do?
13:49:18 <Taneb> It introduces a lambda, which is an anonymous function that takes an input with a name
13:49:18 <monochrom> it introduces an anonymous function and names its formal parameters
13:49:27 <Taneb> Here, the name is render
13:49:32 <typoclass> derek_c: hello, \ is meant to approximate a lambda. it introduces a ... um, yeah :-)
13:49:47 <monochrom> (\x -> x+1) is like you write "f x = x+1" but without f
13:50:01 <monochrom> therefore, (\x -> x+1) 4 = 4+1
13:50:50 <Taneb> ...and now I have a single file containing a quarter of a gigabyte of shakespeare on my laptop
13:52:08 <typoclass> hm, if you run ghc on the gutenberg richard iii text, it just says one thing, "parse error on symbol ," i hoped it'd be tons of errors
13:52:18 <monochrom> it is called lambda because about 100 years ago, Church wrote λ. (and even then, he didn't meant to, it is the result of negotiation with the typesetting people.)
13:52:43 <monochrom> then in Haskell, they used ASCII art \
13:53:22 <tntc> I'm fairly certain I'm "Doing it wrong", but I wanted to do a list comprehention along these lines: [x | x <- [1..], x < 100]
13:53:42 <uvelichitel>  Taneb: Which editor would you use to open such (250 Mb) file. Just curious?
13:53:50 <monoidal> tntc: you might have wanted takeWhile (<100) [1..]
13:53:53 <monochrom> [1..99] would be much better
13:53:56 <tntc> I understand that I could just do [1..99] in this case or whatever, but the point is to draw from an infinite list, but stop at 100
13:54:00 <Taneb> uvelichitel, I'm not planning to in the near future
13:54:01 <derek_c> Taneb: monochrom: typoclass: Aha I see! Thanks!
13:54:15 <tntc> monoidal: ahHA! takeWhile! I had a feeling there'd be a function for that.
13:54:18 <Taneb> uvelichitel, if I do so accidentally, most likely gedit
13:54:18 <merijn_> tntc: Simpler would be take/takeWhile
13:54:40 <Taneb> Deliberately, probably emacs or nano
13:54:40 <merijn_> tntc: Incidentally, this is the stuff hoogle is good at
13:54:44 <monochrom> I agree about takeWhile
13:54:46 <tntc> I think takewhile is what I want. fantastic.
13:54:53 <merijn_> @hoogle (a -> Bool) -> [a] -> [a]
13:54:54 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
13:54:54 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
13:54:54 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
13:55:10 <tntc> I'm honestly not sure what that means...
13:55:23 <tntc> (the hoogle bit)
13:55:36 <merijn_> tntc: Hoogle is a search engine for haskell functions and types :)
13:55:40 <merijn_> @where hoogle
13:55:40 <lambdabot> http://haskell.org/hoogle
13:55:47 <monoidal> @hoogle a -> a
13:55:47 <lambdabot> Prelude id :: a -> a
13:55:48 <lambdabot> Data.Function id :: a -> a
13:55:48 <lambdabot> GHC.Exts breakpoint :: a -> a
13:56:21 <tntc> oh, that I figured out. It's actually installed. But I'm not sure how to create a query for that yet. How would I know that I want (a -> Bool) -> [a] -> [a], for example?
13:56:21 <monoidal> tntc: often it is possible to guess a function from a type, and hoogle does this.
13:56:24 <ab9rf> @hoogle (a -> b) -> a -> b
13:56:24 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:56:24 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:56:24 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
13:56:54 <ab9rf> tntc: figuring out the type of what you're doing is a key aspect of developing in haskell
13:57:09 <ab9rf> often understanding the type of the function you're writing will tell you how to write it
13:57:16 <monoidal> tntc: http://www.haskell.org/hoogle/, or use lambdabot @hoogle command, or install locally hoogle
13:58:02 <merijn_> tntc: Well, it takes some practice and guessing. In this case you want to get elements from a list while some condition holds "a -> Bool" is the function that decides whether the condition holds, and then it also needs to take an input list and return an output list. So you try several variations of things that seem likely until you find it or get bored and ask here ;)
13:58:05 <monoidal> tntc: in case of takeWhile, we were given a function that tells how long to take elements (a -> Bool) and a list ([a]) and we want a new list ([a])
13:58:18 <typoclass> tntc: over time, you'll get there :-) start by looking at type signatures (e.g. in Prelude) and you'll get the hang pretty soon
13:58:52 <merijn_> tntc: Step one is usually "if I had this function, what would I want it's type to look like?", which is also a good question to ask before writing your own functions
13:59:27 <fxr> hi, I am doing network calls in a State Monad and keep the handles which I am using in my State. How can I close all my handles if some ioexception occurs? Since I only can handle the exceptions in IO monad, I have no chance to access my state. Any ideas?
13:59:33 <tntc> cool! wow. thanks for all the help. This is the friendliest "new to the language" experience I've seen in a loooong time.
14:00:17 <heatsink> fxr, are the network calls in IO?
14:00:42 <fxr> yes, I am lifting them.
14:00:55 <typoclass> tntc: sorry, we have several people on staff for pedantic fights over pointless details, but they are out tonight ;-)
14:01:18 <merijn_> fxr: So you open the handles first and at some point call "runState computation handles"?
14:01:49 <merijn_> Or does the set of handles in the State change over time?
14:01:54 <fxr> merijn_: no, I am opening connections in state monad using liftIO
14:02:09 <heatsink> You can't do that with State.  Is it a StateT monad?
14:02:20 <fxr> yes it is
14:02:25 <tntc> typoclass: HA! They must've all gone to <insert inferior language here>'s channel.
14:02:25 <heatsink> ok
14:03:04 <heatsink> You can write a function similar to 'bracket' to perform some action if an exception occurs
14:03:05 <fxr> (runStateT (runErrorT $ playScenario) myState) `catches` [ Handler ...]
14:03:22 <merijn_> fxr: You could create an IORef and store unclosed handles in the IORef, then the exception handler could read them from there and close them
14:03:48 <merijn_> Although that kinda eliminates the need for State entirely :p (Unless you have more stat than the handles)
14:04:15 <fxr> hmm that means a global state
14:04:22 <merijn_> Why?
14:04:25 <heatsink> Oh, right.  If you're not adding or removing handles during the computation, you just need Reader
14:04:50 <merijn_> The state is only as global as you make the IORef, if you only pass the IORef to your state computation and exception handler, it's hardly "global"
14:04:54 <fxr> well I am adding handles and sockets to my state in the computation
14:05:10 <heatsink> The files or sockets are mutable.  The handles are immutable data, containing references to mutable sockets.
14:05:13 <merijn_> Also, sometimes global state is the simplest solution, it's not like global state will murder your children
14:05:48 <merijn_> fxr: bracket is not really an option for the use of your handles?
14:05:50 <ab9rf> if you're in IO you're already in global state as there is only one IO
14:06:06 <heatsink> unless it's a global totalitarian state
14:06:13 <fxr> yes you're right
14:06:14 <ab9rf> so don't get your purity knickers too twisted, you've already crossed over to the dark side
14:06:15 <merijn_> ab9rf: No, you have a global ordering, there is no global state in IO
14:06:20 <fxr> thanks
14:06:25 <monochrom> avoid global warming. use the warming monad.
14:06:38 <fxr> I better put them in an IORef
14:06:45 <ab9rf> merijn_: just the real world
14:06:46 <derek_c> can anyone tell me what ">>" does?
14:06:54 <ab9rf> @src (>>)
14:06:54 <lambdabot> m >> k      = m >>= \_ -> k
14:07:06 <merijn_> fxr: Sometimes overthinking the clean way to do things is not helpful to getting stuff working in a simple way ;)
14:07:11 <heatsink> a >> b runs computation a, then runs computation b
14:07:31 <heatsink> for example putStr "foo" >> putStr "bar" will print "foo", then print "bar"
14:08:37 <heatsink> Is there a list library that checks list lengths?
14:09:08 <monochrom> does the length function suffice?
14:09:24 <heatsink> For example, a "take n" that requires a list of length >= n
14:09:29 <derek_c> heatsink: oh ok; so that's just like ";" in OCaml
14:09:32 <heatsink> or a "zip" that requires two lists of the same length
14:09:36 <heatsink> derek_c, not quite
14:09:44 <monochrom> then I don't know of one
14:10:09 <heatsink> I think the ; in ocaml is a separator in let blocks and such
14:10:12 <monochrom> my knowledge of hackage is slim. a lot of things are there and I don't know
14:10:32 <jmcarthur> heatsink: it's a sequencer
14:10:42 <derek_c> heatsink: does ">>" itself guarantees strictness?
14:10:54 <jmcarthur> heatsink: you might think of it as having type  () -> () -> ()  but with a specified evaluation order
14:10:54 <derek_c> I mean, if I do a >> b?
14:10:54 <monoidal> derek_c: "a;b" in ocaml _evaluates_ a and then b. In ocaml, evaluation causes side-effects. in haskell, it does not; you have to use >>
14:11:06 <jmcarthur> derek_c: >> has nothing to do with strictness
14:11:07 <merijn> derek_c: No, it's behaviour is dependent on the monad
14:11:10 <monochrom> it depends on which monad
14:11:24 <merijn> derek_c: IO guarantees that the left hand will be executed before the right hand side
14:11:37 <monoidal> derek_c: if you are not doing IO, ocaml's "x;y" is equivalent to Haskell's "seq x y"
14:11:39 <jmcarthur> derek_c: and note that merijn said *executed*, not *evaluated*
14:12:06 * merijn is always pedantically accurate about his IO descriptions ;)
14:12:09 <derek_c> ok that's a lot of information lol, let me read carefully
14:12:22 <jmcarthur> merijn: well now i'm going to watch you like a hark
14:12:25 <jmcarthur> *hawk
14:12:33 <merijn> Aww
14:12:40 <ab9rf> shark
14:12:42 <merijn> 10 dollars says I'll screw up within a week
14:13:01 <jmcarthur> funny how relevant "hark" is
14:14:14 <merijn> Random fact: hark is Dutch for rake, and doesn't parse as English until I reread it :p
14:14:48 <sipa> 'to harken' is english, though
14:14:56 <ab9rf> sipa: no, it's not
14:15:08 <ab9rf> sipa: the verb is hearken
14:15:12 <sipa> ow
14:15:18 <mauke> hearken is a variant of harken
14:15:22 <mauke> says my dictionary
14:15:26 <ab9rf> other way around
14:15:35 <ab9rf> according to mine :)
14:15:39 <typoclass> ab9rf: dictionary.com disagrees with you. anyway, it's pointless pedantry
14:15:41 <sipa> "color is right! no colour is right!"
14:15:47 <mauke> color is right
14:15:52 <sipa> haha :D
14:15:54 <mauke> source: latin
14:15:56 <ab9rf> blah!
14:15:58 <Taneb> Both are right, why care
14:16:08 <hpaste> dmj pasted “ConcatMap issue” at http://hpaste.org/85372
14:16:10 <Taneb> Use what your target audience ueses
14:16:14 <sipa> latin and english are both wrong; it's 'kleur' !
14:16:14 <Taneb> *uses
14:16:42 <dmj> Not sure why I have a type mismatch in the above code.
14:16:59 <ab9rf> aha!
14:17:21 <ab9rf> :t concatMap
14:17:22 <lambdabot> (a -> [b]) -> [a] -> [b]
14:17:39 <Taneb> dmj, not really relevant, but that word frequency thing, how fast did you get it in the end?
14:17:43 <heatsink> "colour" is inconsistent, you should use "coulour" instead
14:17:49 <mauke> sipa: farbe
14:17:58 <dmj> yes, (Element -> String) -> [Element] -> [String]
14:18:25 <Taneb> It's (Element -> [String]) -> [Element] -> [String]
14:18:47 <monochrom> Taneb: down to a few seconds. if you still have the paste url, reload it, I annotated and nailed it
14:18:47 <ab9rf> yeah, i'm not sure render is the right type for concatMap's first argument
14:18:58 <dmj> Taneb: It was around 2-3 seconds for a 3MB .txt file. I need to try to scale it up. Maybe throw together 50 bibles .txt
14:19:48 <Taneb> I modified it a little, still using the same algorithm but different types
14:19:58 <Taneb> Didn't test it on files that large
14:20:14 <ab9rf> (Element -> String) -> [Element] -> String actually works for concatMpa
14:20:21 <ab9rf> because String is [Char]
14:21:03 <ab9rf> dmj: eles is completely free in render
14:21:12 <ab9rf> dmj: oh, nevermind
14:21:15 <Taneb> And, oh brilliant, stack overflow
14:21:33 <ab9rf> that's the probem
14:21:37 <ab9rf> render has to take [SimpleXML]
14:22:14 <ab9rf> you bind it as a partial application of fEle leaving eles unapplied
14:22:33 <ab9rf> so that comes out with an [SimpleXML] as the remanining argument
14:23:50 * hackagebot wai-routes 0.2.3 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.2.3 (AnupamJain)
14:23:54 <dmj> yes, it's defined recursively though, so the first element contains an [element], Users/Dave/Dropbox/Haskell_Study/Meetings/Week1/SimpleXML.hs:22:21:
14:23:54 <dmj>                                                                                                        |    Couldn't match expected type `String' with actual type `SimpleXML'
14:23:54 <dmj>                                                                                                        |    Expected type: String -> [String] -> String
14:23:54 <dmj>                                                                                                        |      Actual type: [Char] -> [SimpleXML] -> [Char]
14:23:57 <dmj>                                                                                                        |    In the first argument of `primRecXML', namely `fEle'
14:24:00 <dmj>                                                                                                        |    In the expression: primRecXML fEle fText
14:24:03 <dmj> my bad
14:25:03 <dimka> ohwow
14:26:16 <dmj> now everyone knows what's in my dropbox
14:36:36 <niteria> Just what do you think you're doing, Dave?
14:36:59 <niteria> Dave, stop.
14:38:21 <ab9rf> daisy, daisy
14:38:52 * hackagebot Win32-services 0.2.1 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.1 (MichaelSteele)
14:45:34 <niteria> @src read
14:45:34 <lambdabot> read s = either error id (readEither s)
14:45:51 <Xaratas> was tut man nicht alles
14:46:17 <ab9rf> @src either
14:46:18 <lambdabot> either f _ (Left x)     =  f x
14:46:18 <lambdabot> either _ g (Right y)    =  g y
14:46:25 <ab9rf> ah, right
14:46:39 <niteria> lies
14:47:12 <niteria> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Text-Read.html#read
14:47:38 <niteria> oh, I was looking at reads
14:47:44 <niteria> I'm tired
14:47:58 <Xaratas> found a case to map a map and have now this :)    map (concatMap permutations) notCollidingLines
14:49:32 <niteria> @ty readEither
14:49:34 <lambdabot>     Not in scope: `readEither'
14:49:34 <lambdabot>     Perhaps you meant one of these:
14:49:34 <lambdabot>       `readLitChar' (imported from Data.Char),
14:54:12 <suiskyz> Was sip yall
14:54:30 <suiskyz> Sup
14:55:12 <suiskyz> Has anyone got the purchase to work
14:57:59 <dmj> Xaratas: map $ map toLower :: [String] -> [String]
14:58:13 <Xaratas> hm
14:58:16 <dmj> Xaratas, used that yesterday
14:58:42 <copumpkin> parcs: that's the best you could come up with?
14:59:09 <parcs> copumpkin: yeah :(
14:59:22 <parcs> it sounded better in my head
14:59:33 * copumpkin shrugs
14:59:45 <nwf> shachaf: I took your advice and built profiling libraries, but all I get is that it's a CAF in my main module. :(
15:00:01 <nwf> I have not been able to replicate it outside the codebase, tho', so I will keep trying.
15:09:23 <pygmalion> Coming from some other functional languages, I would expect to be able to do "{let x = 2; let x = x + 2} and have x be equal to 4... Is it typical to just define some new variable (I've been using x') for the second line? Or am I missing something?
15:09:53 <jmcarthur> pygmalion: lets in haskell are actually let recs
15:10:14 <mauke> pygmalion: you can
15:10:22 <jmcarthur> pygmalion: we often define x, x', x'', and so on
15:10:27 <mauke> > do {let x = 2; let x = x + 2; [x]}
15:10:29 <lambdabot>   <hint>:1:34: parse error on input `}'
15:10:33 <jmcarthur> pygmalion: you can shadow, too, but not that way
15:10:38 <mauke> > do {let {x = 2}; let {x = x + 2}; [x]}
15:10:42 <lambdabot>   mueval-core: Time limit exceeded
15:10:47 <mauke> oh, you can't
15:10:49 <jmcarthur> mauke: you are using the same x on both sides
15:10:51 <pygmalion> jmcarthur: Got it, just checking.
15:10:51 <shachaf> You can also use: let x = 2 + 2
15:11:03 <mauke> yeah, the problem is the 'x = x + 2', not the two let's
15:11:04 <shachaf> jmcarthur: I think mauke may have been commenting on the syntax.
15:11:11 <shachaf> Or not.
15:11:11 <mauke> I misthought
15:11:46 <jmcarthur> pygmalion: you can shadow, but if you do then you can't use the old variable in the definition of the new one
15:12:12 <jmcarthur> pygmalion: shadowing is error prone enough that -Wall warns you about it
15:12:16 <pygmalion> jmcarthur: Yeah, that's why I've found. -Wall is a lifesaver in retraining me...
15:12:20 <pygmalion> jmcarthur: Exactly haha.
15:12:40 <pygmalion> jmcarthur: I was ending up with lots of unexpected infinite loops.
15:13:24 <startling> is it really error-prone? I use it intentionally sometimes, for semantically similar things.
15:13:30 <napping> you were just computing least(defined) fixpoints :)
15:13:53 <jmcarthur> startling: it's error prone in that you can accidentally introduce infinite loops
15:13:57 <napping> sometimes you really do want let xs = 1:xs in ...
15:14:01 <jmcarthur> or finite ones, i guess
15:14:15 <jmcarthur> if we had an explicit letrec this would be less error prone
15:14:25 <startling> I guess shadowing in where clauses might not be warned about.
15:14:25 <pygmalion> jmcarthur: mumble mumble ocaml mumble
15:14:35 <monochrom> I try not to shadow, even if I can shadow. it is for the sake of humans, not computers.
15:14:35 <jmcarthur> pygmalion: right
15:14:54 <jmcarthur> shadowing can be convenient. it took a long time for me to come around to that opinion though
15:15:00 <jmcarthur> but anyway, in haskell, shadowing is error prone
15:15:06 <pygmalion> Duly noted.
15:15:36 <monochrom> it is also pretty easy to not-shadow. instead of a sequence of x, have a sequence of x0, x1, x2, and x3.
15:16:50 <monochrom> I don't use ' for this because ' is too small.
15:16:53 <jmcarthur> i still do it accidentally a lot
15:16:55 <sellout-> x, x', x'', x''', and x'''', of course – I’ve definitely seen code with that many primes.
15:17:10 <napping> sometimes I think it could do with some sugar
15:17:12 <jmcarthur> i've written more primes than that (that's around the time i started using numbers as monochrom suggests)
15:17:32 <jmcarthur> i do still use primes when there will be no more than one or two
15:17:42 <jmcarthur> habit, mainly
15:20:32 <napping> pygmalion: some of this makes more sense in historical context.
15:20:58 <pygmalion> napping: In terms of design choices, etc.?
15:21:13 <napping> yeah - letrec by default is certainly defensible, but it
15:21:43 <napping> but it's arguable if that's the best way to go if you're just aiming for a generic nice functional language
15:22:15 <napping> but Haskell started as an explicit effort to unify a growing collection of non-strict programming langauges
15:24:05 <pygmalion> Yeah that makes sense.
15:24:07 <napping> so picking amonst reasonable choices in ways that make fancy lazy evaluation tricks easier to show off is unsurprising
15:25:09 <pygmalion> Right. When I first started learning OCaml I found the explicit letrecs really ugly (esp. compared to Haskell) but I guess I grew to like them and I hear I am dipping my toes back into the Haskell water with a different mindset...
15:26:00 <napping> As far as general arguments, one thing I like is order-independence of bindings
15:27:23 <jmcarthur> i like order-independence, but i also like scoping rules!
15:28:20 <napping> well, once you've decided the RHS of a binding sees the new value for the LHS of all the other bindings, it seems natural to see also the new value from it's own LHS - especially with lazy evaluation to make this sensible more often
15:30:15 <ab9rf> i had five primes once
15:30:21 <ab9rf> that was ugly
15:30:45 <shachaf> You can get away with only one.
15:31:08 <shachaf> > do { let { x = 0 }; let { x' = x + 1 }; let { x = x' + 1 }; x }
15:31:09 <lambdabot>   2
15:31:09 <monoidal> for more than 2, I prefer x1, x2, x3 etc
15:31:22 <ab9rf> shachaf: that's not even funny
15:31:35 <ab9rf> well, ok, yes it is
15:31:40 <ab9rf> it is, however, evil
15:33:50 <ab9rf> feh
15:35:55 <timbod> When I use bracket, most often I just want the 2nd argument to close the resource. I was considering creating a typeclass for this (Closeable? Resource?) with a single method to release an object of that type. ie
15:36:00 <timbod> class Resource a where
15:36:02 <timbod>    release :: a -> IO ()
15:36:06 <timbod> withResource :: (Resource a) => IO a -> (a -> IO b) -> IO b
15:36:08 <timbod> withResource ma fmb = bracket ma release fmb
15:36:12 <timbod> Does such a typeclass existing already?
15:36:15 <heatsink> If the variable names look silly after changing primes to "new", then you shouldn't use primes
15:36:20 <heatsink> x''' -> newNewNewX
15:36:56 <ab9rf> stupid irssi
15:37:59 <heatsink> timboc, maybe see the resourcet package
15:38:04 <heatsink> timbod
15:38:07 <heatsink> http://hackage.haskell.org/packages/archive/resourcet/0.4.7/doc/html/Control-Monad-Trans-Resource.html
15:39:37 <timbod> heatsink: Thanks.
15:41:07 <timbod> It all looks a bit more ambitious that what I was considering.
15:42:14 <timbod> I was just looking to simplify the bracket calls, and not have to invent names for each of my close functions.
15:50:09 <nwf> Hey everyone, it's me again... so my mysterious bug is now even more mysterious to me, but I have it "solved"... I had written "f a = F.mapM_ (...) >> return $ Just $ ..." (which hangs) but "f a = F.mapM_ (...) >> return (Just $ ...)" does not.  Thoughts?
15:50:35 <nwf> (I'd be happy to continue prying the minimal example down, if that'd be useful to anybody, too)
15:50:57 <nwf> shachaf: ^
15:50:58 <napping> >> binds tighter than $
15:50:59 <monoidal> timbod: often we create new with... functions by partially applying bracket to the resource acquiral & releasing. for example, withFile name mode = bracket (openFile name mode) hClose
15:51:14 <nwf> napping: I suppose I am astounded that it type-checked, then?
15:51:34 <shachaf> nwf: It's with the (r ->) monad.
15:51:57 <shachaf> (>>) is very boring there because there are no real "effects"
15:52:06 <nwf> It... ought not have been able to pick a particular monad, since my signature on the function is "forall m . (Monad m) => ... -> m ..."
15:52:19 <shachaf> No, the (>>) is in a different monad from m
15:52:28 <shachaf> (>>) :: (r -> a) -> (r -> b) -> r -> b
15:52:30 <napping> but it's sequncing together something which is then applied with 4
15:52:35 <monoidal> I am rather unhappy (a ->) is now a monad without imports. I have already seen several bugs due to >> accidentally used for (a->)
15:52:48 <Cale> What?
15:52:54 * shachaf thinks it's a net positive.
15:53:05 <Cale> Oh, is it in the Prelude now?
15:53:08 <monoidal> Cale: yes
15:53:09 <nwf> Oh... dear.  Is there a way to see the desugared form before it's all the way down to Core?
15:53:12 <Cale> cool!
15:53:21 <Cale> (I am happy)
15:53:46 <arkeet> yep, Control.Monad.Instances is now empty.
15:54:02 <monoidal> Cale: since 7.6 to be precise
15:54:15 <Cale> I hadn't noticed somehow :)
15:54:52 <shachaf> nwf: Desugared as in de-infixified?
15:54:59 <monoidal> nwf: probably -ddump-ds
15:55:00 <nwf> Well, ideally and renamed.
15:55:54 <shachaf> There's -ddump-rn
15:56:04 <shachaf> Well, no. That won't do what you want.
15:59:43 <d-snp> my code crashes with "Prelude.undefined", turns out whoever wrote System.Plugins.Load left undefineds all over the code
15:59:57 <d-snp> is there a way to make haskell say on which line it crashed?
16:00:19 <shachaf> @where rts-xc
16:00:19 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
16:00:21 <monoidal> ghc gives a warning on spurious fromIntegeral, and it could do the same with (>>) for (a->) monad. perhaps one day I'll look at it
16:00:29 <d-snp> or shall I curse a bit at woah
16:00:31 <d-snp> woah
16:01:04 <liyang> Just a thought: why on earth doesn't GHC do with undefined what it does with Control.Exception.assert?
16:01:11 <typoclass> d-snp: it may involve some work recompiling stuff with profiling enabled. see also http://www.haskell.org/haskellwiki/FAQ#How_can_I_get_a_stack_backtrace_when_my_program_throws_an_exception.3F
16:01:19 <d-snp> thanks shachaf
16:01:33 <shachaf> Good luck with "plugins".
16:01:52 <d-snp> so this library is from 2005.. does a more uptodate implementation exist? :P
16:02:15 <d-snp> I just want to dynamically load a module and call a function from it
16:02:53 <d-snp> but apparently this is not something many people have attempted
16:02:54 <liyang> d-snp: completely untested, but try adding a line: {-# RULES "undefined" undefined = assert False (error "didn't work") #-}
16:03:35 <timbod> monoidal:
16:03:37 <timbod> withFunctions are inherently more restrictive than a pair of (newfn,releasefn).
16:04:19 <timbod> When applicable, a withFunction is safer, but you can't create the resource in one score, and then free it with another
16:04:26 <d-snp> that doesn't work liyang, parser error..
16:05:01 <typoclass> liyang: i have a feeling that half of all advice of the sort "use pattern matching instead of head" would go away if ghc's error message included a line number
16:05:36 <ByteEater> :t join (fix (??))
16:05:37 <lambdabot> a1 -> a
16:06:20 <liyang> Could someone fix that RULES? Gotta dash.
16:06:21 <shachaf> typoclass: There are two reasons for this advice.
16:06:39 <shachaf> The biggest one is the one that says you should also match on []
16:06:52 <ByteEater> join (fix (??)) - this has the same type as unsafeCoerce, but since it's constructed from normal Haskell pieces, it cannot return any value ever, right?
16:07:05 <liyang> typoclass: unfortunately sometimes one has to make use of Other People's Code.
16:07:13 <shachaf> Regardless of error messages, "case l of [] -> z; x:xs -> f x xs" is much nicer than "if null l then z else f (head l) (tail l)"
16:07:24 <liyang> typoclass: (aka Hell.)
16:07:26 <shachaf> ByteEater: Yes, it's an inifnite loop.
16:07:32 <shachaf> ByteEater: (??) is just flip here.
16:08:07 <ByteEater> :t fix flip
16:08:07 <shachaf> Well, more precisely it returns an infinite loop.
16:08:08 <lambdabot> a -> a -> c
16:08:25 <ByteEater> ah, right, thanks for enlightening me
16:08:25 <shachaf> Easier: const (fix id)
16:09:08 <typoclass> shachaf: yup, there's two reasons. (i tried to indicate that with 'half the advice', but i think it could have been clearer)
16:09:39 <shachaf> Even in the other case I think head should be regarded with great suspicion.
16:12:10 <d-snp> oh I made it not run into undefined :D
16:13:00 <typoclass> shachaf: yes ... sometimes you want the program to crash. "if we get to this point, and we have an empty list, this indicates a bug in some other place". for this, pattern matching is of course better because it gives you the line number
16:13:11 <typoclass> shachaf: iow, i think we agree
16:13:29 <shachaf> No, I don't think that it's better only because it gives you the line number.
16:13:37 <shachaf> But whatever. It doesn't matter.
16:14:55 <d-snp> can I list the haskell symbols in a .o file?
16:15:14 <shachaf> Presumably the same way you can list other symbols.
16:15:15 <d-snp> I have a WaiApplication.o, that defines a function buildApplication :: IO Application
16:15:38 <d-snp> but it says "couldn't find symbol  <<buildApplication>>
16:16:23 <d-snp> its defined as module WaiApplication (buildApplication) where .. that should make it exposed right?
16:17:36 <typoclass> d-snp: just to double-check -- are you sure you need runtime plugin thingies? i've always thought they are complicated and error-prone, and often you can just do it the xmonad way instead
16:17:38 <d-snp> what is the xmonad way?
16:18:24 <d-snp> I'm writing a webserver, it loads a Wai application and runs it
16:19:18 <typoclass> d-snp: it's a window manager, and you configure it by writing an xmonad.hs file which is regular haskell ("import XMonad ; main = xmonad something something"). xmonad is a tiny program that will run ghc on that 'config file' and execute the result
16:20:22 <d-snp> I thought about that
16:21:14 <jmcarthur> pygmalion: oh, btw, i just realized one way that we do still have shadowing.   do { foo <- do { let foo = blah blah; return x }; bar }  -- these two foos are not the same thing
16:21:15 <d-snp> but I think I want to avoid compiling the project if possible
16:21:25 <jmcarthur> this does happen occasionally
16:22:33 <typoclass> d-snp: ok :-) just making sure
16:22:35 <jmcarthur> pygmalion: you have to use mdo if you want to be able to access the outer foo inside the inner do block. so while we don't have a distinction between let and letrec, we do have a distinction between do and mdo
16:23:40 <d-snp> typoclass: yeah I'm not sure myself, our webserver usually servers scripting languages where this is actually the most common way of doing it, this is the first precompiled language I'm trying to make it work with
16:24:24 <d-snp> in my memory C# and Java also compile to libraries that are ran by application servers, but Haskell does it the other way around
16:24:48 <d-snp> the application server is a library that is used by the web application to run itself
16:24:58 <d-snp> which is a bit weird.. so I'm trying to undo that, but it's hard :P
16:25:39 <d-snp> I am actually a bit surprised that dynamic modules are so frowned upon in the haskell world
16:26:02 <d-snp> because I understood it actually has some cool meta features
16:26:05 <merijn> d-snp: I don't think they're so much frowned upon, as they are hard to do well
16:26:59 <d-snp> right
16:27:41 <typoclass> d-snp: so, which package are you using? "wai"?
16:28:20 <d-snp> yeah, wai has the application interface defined nicely
16:28:35 <d-snp> and the most popular webserver already supports it
16:37:32 <tntc> I'm running across something odd:
16:38:26 <NemesisD> hmm. building a project with cabal-dev. I install from a separate directory via: cabal-dev install ../otherpackage. when i try to build my tests, ghc complains about an unknown_symbol httpmockzm0zi0zi0zi1_NetworkziHTTPMockziWebServersziScotty_startServer1_closure
16:38:30 <NemesisD> wat
16:39:29 <tntc> takeWhile (\x -> x < (sqrt 100))[1..100] works. takeWhile (\x -> x < (sqrt someNumber))[1..100] doesn't, where someNumber is an integer input on the function.
16:39:56 <geekosaur> tntc, numeric literals are polymorphic, and sqrt does nto accept integers
16:39:59 <geekosaur> :t sqrt
16:40:01 <lambdabot> Floating a => a -> a
16:40:05 <Cale> tntc: sqrt doesn't work on integers
16:40:09 <Cale> yeah
16:40:15 <tntc> so I have to make it a float first?
16:40:17 <Cale> :t 100
16:40:18 <geekosaur> yes
16:40:18 <lambdabot> Num a => a
16:40:27 <Cale> tntc: Yeah, just apply fromIntegral
16:40:33 <monoidal> or, x<sqrt n <=> x*x < n
16:41:14 <merijn> tntc: Well, make it Integer or change the type of the input to the function :)
16:41:45 <arkeet> alternatively,
16:41:48 <arkeet> \x -> x^2 < 100
16:42:24 <tntc> well, I'm finding prime factors, and I only want to check primes less than the sqrt of the target.
16:42:59 <merijn> Then you indeed want
16:43:05 <merijn> @quote who.do.you.call
16:43:05 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:43:17 <tntc> hahaha!
16:43:22 <arkeet> no!  \x -> x^2 < someNumber
16:43:29 <arkeet> also, that is amazing.
16:43:39 <kennyd> tntc also you don't need lambda there
16:43:43 <kennyd> > takeWhile (< (sqrt 100)) [1..100]
16:43:44 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0]
16:44:09 <tntc> I thought I needed the lambda because of the variable in there, but I think I can skip that, based on what I'm seeing now.
16:44:20 <arkeet> > takeWhile ((< 100) . (^2)) [1..100] -- no sqrt needed!
16:44:22 <lambdabot>   [1,2,3,4,5,6,7,8,9]
16:44:28 <arkeet> or floats, for that matter.
16:44:46 <no-n[2]> what happens if you give lambdabot an infinite list? does it just get cut?
16:44:51 <arkeet> > [0..]
16:44:52 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:45:02 <no-n[2]> coo'
16:45:14 <arkeet> > [0..28] ++ undefined
16:45:16 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:45:39 <arkeet> > [0..28] ++ fix id
16:45:43 <lambdabot>   mueval-core: Time limit exceeded
16:45:49 <arkeet> :/
16:45:52 <no-n[2]> :>
16:46:03 <arkeet> > [0..500] ++ fix id
16:46:06 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:46:20 <hpc> you would have to tell mueval itself to chop output
16:46:20 <heatsink> I don't get it
16:46:31 <hpc> mueval evaluates up to something like 500 characters
16:46:34 <arkeet> iirc, it only looks at the first 1024 characters.
16:46:47 <hpc> don't know if there is an option to tell mueval to evaluate less
16:47:01 <arkeet> > replicate 1023 'a' ++ fix id
16:47:03 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:47:04 <arkeet> > replicate 1022 'a' ++ fix id
16:47:08 <lambdabot>   mueval-core: Time limit exceeded
16:47:08 <heatsink> > 10 ^ 1024 :: Integer
16:47:10 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
16:47:31 <arkeet> yeah, 1024.
16:48:33 <oio> any update on this http://honza.ca/2012/10/haskell-strings ?
16:48:38 <crdueck> with the Repa library, if I have some functions (f :: Array t sh e -> Array t sh e) and I'm going to be composing these to apply the function maybe 4 or 5 times to an array, is it better to use a Delayed array so the composition can get fused, or a strict array like Unboxed?
16:50:51 <heatsink> crdueck, it depends on how many times each individual array element is evaluated
16:50:55 <jmcarthur> crdueck: if it was a clear win either way then there would only be one representation
16:51:11 <jmcarthur> crdueck: if you are unsure and the performance is important then you should just try both ways
16:51:34 <heatsink> If each array element is used at most once, delayed arrays are more work-efficient (but cache effects are harder to predict)
16:52:09 <heatsink> If some array elements are used many times, manifest arrays are more work-efficient
16:52:14 <typoclass> oio: here is some discussion and criticism of that article http://www.reddit.com/r/haskell/comments/120h6i/why_is_this_simple_text_processing_program_so/
16:52:28 <crdueck> heatsink: each array element will be accessed more than once, and it seems like using an Unboxed array is faster in my case. I was curious if there was some general best practices like you've just mentioned
16:54:05 <heatsink> Whoa... google auto-corrects typing errors from your hand being in the wrong position on a qwerty keyboard
16:54:29 <monochrom> that's leet and neat
16:54:54 <typoclass> oio: hm, that thread seems to include several comments that are very good and very relevant. including several improved haskell solutions
16:55:16 <oio> typoclass: Thnaks
16:58:06 <[swift]> so i've noticed a mysterious phenomenon that i'd like to fix, but i'm not sure where to start
16:58:21 <[swift]> if I try to use LibClang in my project, template haskell no longer works
16:58:30 <[swift]> that is: my project won't build if I use any template haskell
16:59:08 <[swift]> LibClang uses the FFI; I assume that's somehow implicated
16:59:41 <typoclass> [swift]: oh hm. you mean, you're telling ghc to use the llvm backend?
17:00:11 <[swift]> typoclass: no, i mean the LibClang package on hackage (for using libclang from Haskell)
17:00:25 <[swift]> should've been more clear =)
17:03:53 <heatsink> swift, it could be a C++ issue
17:04:37 <heatsink> LLVM is a C++, so GHC can't load it in interpreted mode http://hackage.haskell.org/trac/ghc/ticket/3333#comment:3
17:04:45 <heatsink> Template Haskell runs in interpreted mode
17:05:02 <heatsink> so projects that use TH and LLVM don't build
17:08:06 <[swift]> heatsink: bummer =(
17:08:11 <[swift]> heatsink: is there a workaround?
17:08:24 <[swift]> heatsink: (probably confirming what you say, here's the error: Loading package LibClang-0.1.0 ... <command line>: can't load .so/.DLL for: libLLVMAsmParser.dylib (dlopen(libLLVMAsmParser.dylib, 9): image not found))
17:09:02 <[swift]> heh, actually i should probably click on your link before asking more questions =)
17:09:33 <heatsink> If the TH files don't use libclang and they don't import files that use libclang, then TH can run without loading the library
17:10:04 <heatsink> Cabal automatically loads all libraries, though
17:10:11 <heatsink> So you'll have to write your own build scripts
17:10:46 <heatsink> that don't link to libclang during the compile phase
17:11:02 <heatsink> It's pretty awkward
17:11:17 <[swift]> heatsink: yeah, sounds unpleasant =)
17:11:53 <[swift]> heatsink: maybe i can factor my application out into two libraries.. one that uses libclang internally and doesn't expose any libclang types, and one for everything else
17:12:40 <heatsink> It doesn't matter whether libclang types are exposed
17:13:41 <heatsink> All dependences of a library get loaded, regardless of whether they're part of the exported interface
17:14:13 <[swift]> hmm.. so just not having LibClang in build-depends is not enough, transitive dependencies also cause the problem?
17:14:17 <[swift]> drat
17:14:19 <heatsink> yes
17:16:50 <[swift]> hmm.. OK, i guess three separate components will work then? library A uses TH, library B uses LibClang, then application C imports them both. C can't use TH, but it shouldn't matter that A does
17:17:00 <sw2wolf> :t mappend
17:17:02 <lambdabot> Monoid a => a -> a -> a
17:17:03 <heatsink> should work
17:17:21 <[swift]> heatsink: great, thanks for your help!
17:17:24 <heatsink> :t (<>)
17:17:25 <lambdabot> Monoid m => m -> m -> m
17:24:21 <ab9rf> what package is that defined in?
17:25:01 <typoclass> ab9rf: afaik base, but only in newer versions
17:25:11 <ab9rf> how new?
17:25:31 <ab9rf> my 7.4.2 doesn't have it
17:28:28 <typoclass> ab9rf: seems to work for me with 7.4.2. did you do "import Data.Monoid"?
17:28:35 <ab9rf> ah, it's in Data.Monoid
17:29:40 <sw2wolf> @hoogle (<>)
17:29:40 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
17:29:40 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
17:29:40 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
17:30:45 <typoclass> ab9rf: (ok sorry, didn't realize this was what you're asking. 'module' is the term for stuff like Data.Monoid, 'package' is a container of modules, e.g. 'base')
17:30:58 <ab9rf> typoclass: yeah, i misspoke
17:31:12 <ab9rf> and hoogle failed me
17:31:48 <typoclass> ab9rf: all right. just making sure about the terminology :-) no worries
17:34:03 <skyflash_> Anyone installed the llvm cabal package here?  I get "Core.hsc:LL:CC: error: invalid suffix "svn" on integer constant" error during "Preprocessing library llvm-base-..."
17:34:38 <geekosaur> skyflash, sounds like it expects only released versions and you have an unreleased version
17:35:55 <skyflash_> I downloaded the release 3.2 version from the LLVM site and did a based .configure and make.  Maybe that's not enough to avoid non-release labelling?
17:36:42 <jfischoff> skyflash: you need to install llvm 3.0 and then install the llvm haskell package with a flag that says where your llvm package is
17:36:42 <lambdabot> jfischoff: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:36:46 <jfischoff> @messages
17:36:46 <lambdabot> Enigmagic said 1d 17h 18m 30s ago: yep, sounds like a plan. i'd guess that json is more useful than Binary though.
17:36:46 <lambdabot> Enigmagic said 1d 17h 17m 27s ago: yep, sounds like a plan. i'd guess that json is more useful than Binary though.
17:37:26 <jfischoff> Enigmagic: it occurred to me that having a Generic or Data instance is all that is necessary for either of those backend
17:37:58 <skyflash_> jfischoff: Thanks.  So you're saying 3.2 is too recent?  OK, I'll try that and look for this flag.
17:38:24 <jfischoff> skyflash: --configure-option=--with-llvm-prefix=path/to/llvm_3
17:38:51 <skyflash_> jfischoff: Great.  Thanks.  I'll give it a whirl.
17:39:07 <jfischoff> skyflash: fyi, to build llvm 3 requires an old version of clang
17:39:31 <timbod> I am just looking at Network.Wai.Handler.Warp for the first time. This is, I think, the web server that underlies yesod.
17:39:33 <timbod> Is it possble to cleanly shut down a service started with one of the run methods?
17:39:51 <skyflash_> Oh.  Bummer.  I'm building on a Mac, which invariably has a 'late-ish' version, if not the latest per se.
17:39:57 <jfischoff> skyflash: also there is LLVM AST that is part of GHC that might work for your purposes.
17:40:17 <jfischoff> skyflash: It can be done on a mac
17:41:34 <jfischoff> first you download the clang binaries here
17:41:35 <jfischoff> http://llvm.org/releases/download.html#3.0
17:41:54 <jfischoff> then you download the llvm sources and use the old clang to build them
17:42:15 <skyflash_> Phew. OK.
17:42:58 <jfischoff> skyflash: do you need JITing?
17:43:04 <skyflash_> Yes
17:43:38 <jfischoff> then yes you need the llvm package, the GHC stuff is of no use.
17:43:47 <skyflash_> OK.
17:44:06 <geekosaur> you can also install a clean llvm via macports or homebrew
17:44:28 <geekosaur> (you want to get a real llvm anyway, apple typically strips out the parts it doesn't care about)
17:44:31 <skyflash_> geekosaur: is that known to work with the llvm package?
17:44:54 <geekosaur> people have used both with the llvm package, yes
17:44:57 <skyflash_> ...sounds like a plan if it does
17:45:06 <geekosaur> specifically because apple's doesn't work
17:45:16 <jfischoff> geekosaur: I wasn't able to get an old version to install with it anymore, but that doesn't mean it isn't possible.
17:45:27 <skyflash_> OK.  That might save me messing with another compiler.  Thanks.
17:45:31 <geekosaur> even if you don't get that error you'll get one later because apple removed parts of it
17:45:34 <skyflash_> Just googling if seems there's a LLVM_APPEND_VC_REV=OFF option for cmake that should suppress adding extra svn version info.
17:45:49 <skyflash_> Not sure how you assert that in the 'make' make.
17:45:57 <geekosaur> unless you install a good one from somewhere
17:46:11 <skyflash_> Anyway, I'll uninstall this llvm and try macports
17:46:19 <skyflash_> Thanks all.
18:14:34 <strager> How can I show a pointer value (or something stable and unique) of an IORef (for debugging)?  I have a data structure with many IORef's and I would like to distinguish them.
18:15:30 <shachaf> For debuging, maybe you could use unsafeCoerce like Pugs did?
18:16:11 <strager> I tried unsafeCoerce under GHCi and it produced different values sometimes.  I could try compiling to object code.
18:16:21 <monochrom> it may be unstable
18:16:31 <shachaf> Note that there's an Eq instance for IORef.
18:16:50 <strager> I'd imagine the IORef pointer could change as the GC pleased.
18:17:00 <Cale> It will
18:17:11 <monochrom> yes, that makes it unstable
18:17:32 <strager> shachaf: I thought of making a pass over the data structure and gathering IORef's into a list, then indexing that list when showing.
18:17:41 <monochrom> but == still works. you will have to think of a way to use it
18:28:20 <hpaste> Thyrgle pasted “Problem 23 Failed Solution” at http://hpaste.org/85383
18:28:26 <Thyrgle> hello i am having trouble with the random  module... maybe im not getting it.
18:28:53 <shachaf> That's a bizarre indentation.
18:29:04 <Thyrgle> I had trouble indenting with notepad++
18:29:14 <shachaf> You're using tabs.
18:29:19 <shachaf> You should use spaces instead.
18:29:24 <Thyrgle> It auto tabed and i tried not using tabs
18:29:44 <shachaf> I recommend looking in the settings.
18:29:46 <shachaf> It can do it.
18:29:52 <Cale> Thyrgle: there absolutely are tabs in that paste
18:30:11 <shachaf> Anyway, you haven't mentioned the problem.
18:30:11 <Thyrgle> ok
18:30:20 <Thyrgle> should i resubmit w/o tabs?
18:30:39 <Thyrgle> i still get the same errors: Couldn't match expected type `IO t0' with actual type `[c0]'
18:30:45 <shachaf> Nah, but get used to getting indentation right so that other people can read your code. :-)
18:30:59 <shachaf> OK, I think you want "let res = ...", not "res <- ..."
18:31:04 <shachaf> Do you know what <- means?
18:31:19 <Thyrgle> it means put the getState var into gen
18:31:32 <Cale> v <- x means "execute the action x and call its result v"
18:32:06 <Cale> in this case, getStdGen is an IO action, and running it produces a generator gen
18:32:15 <Thyrgle> ok so i execute getStdGen and put the result into gen?
18:32:20 <Cale> But (zipWith ...) is definitely a list, and not an IO action
18:32:59 <ion> Btw, use newStdGen instead of getStdGen.
18:33:02 <skyflash_> Hmm... installed llvm3.0 with MacPorts, ran "cabal install llvm --configure-option=--with-llvm-prefix=/opt/local/libexec/llvm-3.0" and...
18:33:05 <Cale> You don't "put the result into gen", gen is not a "place" where things are stored
18:33:14 <Cale> It's a *name* for the result of getStdGen here
18:33:28 <skyflash_> I get: dyld: Library not loaded: /Users/ian/zz64/ghc-7.4.2/libffi/build/inst/lib/libffi.5.dylib
18:33:35 <Cale> (this is a subtle point)
18:33:50 <Thyrgle> so is it like #define vs actually making a const or something like that?
18:33:51 <skyflash_> Now, why is it trying to load a library from /Users/ian...
18:34:02 <skyflash_> ian who?
18:34:08 <Cale> You can't reassign gen to be something else (but you could bind a variable with the same name, which would shadow the previous one)
18:35:30 <Cale> So, if you want to make a definition in the middle of a do-block without executing an action, you can use let, as shachaf mentioned
18:35:56 <Cale> lol, not sure what happened there, channel closed :P
18:36:09 <Thyrgle> ok. i think i understand.
18:36:22 <Thyrgle> let means you don't execute till you want to?
18:36:46 <Cale> let means that you're simply defining certain things, not executing anything
18:37:01 <Thyrgle> that makes sense
18:37:08 <Cale> It won't even evaluate the things you define, but that's another point.
18:37:23 <Cale> (evaluation of expressions into values and execution of IO actions are two separate processes)
18:38:26 <Thyrgle> ok, but you say i am passing IO val to zipWith...
18:38:32 <Thyrgle> I thought i was passing a list
18:38:49 <Thyrgle> because randomRs' return type
18:39:23 <shachaf> (randomRs x y) is a list.
18:41:11 <Thyrgle> but then shouldn't the zipWith be accepting the correct thing?
18:41:31 <Cale> Sure, if a is a list
18:41:54 <Cale> But the type of this whole zipWith is a list, which isn't the right type of thing to occur on the right side of <-
18:42:36 <shachaf> Not that <-, anyway.
18:42:47 <Cale> (at least in this context -- if you were using the list monad, it would be fine, and would cause res to be selected in all possible ways as an element of that list, but you must be in the IO monad here, because you executed getStdGen
18:42:50 <Cale> )
18:46:48 <Thyrgle> umm...
18:47:00 <Thyrgle> ok... so i tried like deleting gen
18:47:22 <Thyrgle> actually nvm... i need to think  more about this...
18:47:59 <Cale> Thyrgle: Did you try using let to define res?
18:48:45 <Thyrgle> get parse error on let
18:49:24 <Cale> oh, because you're using the braces and semicolons, you'll need to put braces around the declarations inside the let
18:49:30 <Cale> let { res = ... }
18:51:09 <hpaste> Thyrgle pasted “Problem 23 Failed Solution (2)” at http://hpaste.org/85385
18:51:16 <Thyrgle> Do you mean like this?
18:51:30 <Thyrgle> o wait
18:51:39 <Thyrgle> my bad i was trying to change something and forgot to change it back
18:52:00 <shachaf> Thyrgle: Also, you should have a type signature. :-)
18:52:12 <shachaf> But maybe only when you finish figuring out the type of your function.
18:52:20 <shachaf> If you know the type in advance it can make it easier to write the function.
18:52:48 <Cale> You might want (repeat a) in place of a there
18:53:05 <Cale> (depending on your intention here)
18:53:38 <Cale> also, yes, you want to use gen and not getStdGen, since randomRs doesn't take an IO StdGen, it wants a StdGen (which is the result of executing that action)
18:53:52 <Thyrgle> i  believe the type signature is:
18:53:53 <Thyrgle> rnd_select :: [a] -> Int -> [a]
18:54:18 <Cale> btw, you never use the n parameter
18:54:29 <Cale> what is that supposed to be for?
18:54:38 <Thyrgle> oh dang it
18:54:50 <Thyrgle> it was supposed to be for how many elements you selected
18:55:00 <shachaf> The type can't be that, because it does IO.
18:55:20 <Cale> Right, in that case (replicate n a) would be the right parameter to give to  zipWith (!!)
18:55:32 <Cale> and yes, it had better actually produce an IO action
18:56:59 <Cale> another thing that you'll notice once you get this running is that if you execute this action twice in a row, it will produce the same list of elements
18:57:15 <Thyrgle> ok then the return type should be:
18:57:16 <Thyrgle> rnd_select :: [a] -> Int -> IO ()
18:57:22 <Cale> You probably want newStdGen in place of getStdGen here
18:57:42 <Cale> That would imply that running the resulting IO action would produce an empty tuple
18:57:45 <Cale> ()
18:58:05 <Cale> You want the result of running that IO action to be something of type [a]
18:58:17 <Cale> So it'll be  rnd_select :: [a] -> Int -> IO [a]
18:58:48 <Thyrgle> ok that makes sense
18:59:15 <Thyrgle> couldn't for the second arguement of zipWith
18:59:18 <Thyrgle> i do:
18:59:20 <Thyrgle> (take n (randomRs (0,length a-1) gen))
18:59:33 <Thyrgle> instead of (replicate n a)?
18:59:37 <Cale> Did you ever change the first parameter?
18:59:46 <Cale> You could make the first parameter (repeat a) and then do that
19:00:03 <Thyrgle> i tried:
19:00:07 <Thyrgle> res <- zipWith (!!) (replicate n a) (randomRs (0,length a-1) gen)
19:00:16 <Cale> It would also be reasonable to use map here
19:00:17 <Thyrgle> yet it does not work...
19:00:19 <Cale> instead of zipWith
19:00:36 <Cale> You're still using <-
19:00:45 <Cale> zipWith can't ever produce an IO action for you to run
19:00:49 <Cale> It only makes lists
19:01:19 <Thyrgle> let res = zipWith (!!) (replicate n a) (randomRs (0,length a-1) gen)
19:01:44 <Cale> that should work
19:02:00 <Cale> except that if you stick with the semicolons and braces style, you'll need some more of those
19:02:10 <Cale> let { res = zipWith ... };
19:02:30 <Cale> (Or just ditch the semicolons and braces)
19:02:34 <hpaste> Thyrgle pasted “Problem 23 Failed Solution (3)” at http://hpaste.org/85386
19:02:45 <Thyrgle> I tried that...
19:02:58 <Thyrgle> with the example test case:
19:03:07 <Thyrgle> rnd_select "abcdefgh" 3 >>= putStrLn
19:03:23 <ryant50001> does anyone know of a Monoid instance for Map that uses unionWith mappend?  a newtype wrapper or something
19:03:37 <ryant50001> it's easy to write, but i'd rather use a library if there is one with it
19:03:46 <Cale> Thyrgle: and, it should work :)
19:03:48 <Cale> (it works here)
19:04:01 * hackagebot detrospector 0.3 - Markov chain text generator  http://hackage.haskell.org/package/detrospector-0.3 (KeeganMcAllister)
19:04:03 * hackagebot repa 3.2.3.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.3.2 (BenLippmeier)
19:04:41 <Cale> ryant50001: I don't know of one...
19:05:03 <sw2wolf> @ty (<*)
19:05:04 <lambdabot> Applicative f => f a -> f b -> f a
19:05:19 <startling> ryant50001, it's not really a monoid.
19:05:35 <startling> ryant50001: unionWith has an Ord constraint, doesn't it?
19:05:44 <Thyrgle> that's wierd... I keep getting: Couldn't match expected type `[c0]' with actual type `Char'
19:05:46 <ryant50001> startling: sure
19:06:09 <ryant50001> startling: but that would just go into the instance context, no?
19:06:17 <Cale> yeah, it would
19:06:54 <Cale> Thyrgle: Make sure you saved your file and have loaded the most recent version perhaps?
19:07:03 <applicative> the ord instance does keep it from being a monad though, of course
19:07:15 <applicative> constraint rather
19:07:29 <Thyrgle> ok we got it. sorry about that. kept saving it forgeting to reload
19:07:32 <ryant50001> applicative: right; it would need RMonad or one of those other crazy generalizations of monads
19:07:37 <Thyrgle> thank you for the help!
19:07:40 <Thyrgle> Cale++
19:07:53 <Thyrgle> (that's how you award karma right?)
19:07:57 <Cale> yeah
19:08:16 <Thyrgle> ok well thanks so much!
19:09:03 <startling> oh, that's what I'm thinking of. I feel like there's a reason it can't be a monoid but I don't remember it.
19:09:28 <shachaf> What, unionWith mappend?
19:09:36 <shachaf> That certainly makes a monoid.
19:10:02 <startling> I guess I'm more confused than I thought.
19:14:00 <sw2wolf> @hoogle monoid
19:14:00 <lambdabot> Data.Monoid module Data.Monoid
19:14:00 <lambdabot> Data.Monoid class Monoid a
19:14:00 <lambdabot> package monoid-owns
19:14:27 <sw2wolf> @wn monoid
19:14:27 <lambdabot> No match for "monoid".
19:34:40 <Counterspell> hey
19:34:46 <Counterspell> i have a type called Node
19:34:55 <Counterspell> and i want to make another type that's defined as [Node]
19:34:59 <Counterspell> but i'm getting a syntax error
19:35:03 <ludamad> I'm starting to really <3 haskell
19:35:15 <Counterspell> data Node = ...; data Path = [Node]
19:35:25 <ludamad> it wasnt the elegant small examples that convinced me, it was writing a messy server
19:35:29 <shachaf> A data type needs a constructor.
19:35:35 <shachaf> data Path = Somethingorother [Node]
19:35:37 <shachaf> (Or newtype.)
19:35:46 <Counterspell> ohhh
19:35:54 <Counterspell> yeah Path = Path [Node] right
19:36:00 <Counterspell> is that what newtype does?
19:36:21 <shachaf> No.
19:36:31 <shachaf> newtype Path = Path [Node] would be the newtype.
19:36:40 <shachaf> You can look up the difference between them on the wiki.
19:37:07 <BMeph> Wikis are boring - tell us NOW!!!1!11!ichi1!
19:38:48 <hpaste> Ontolog pasted “Duplicate type signature” at http://hpaste.org/85388
19:40:10 <shachaf> You can't overload functions in Haskell.
19:40:18 <shachaf> Not the way C++ does it, anyway.
19:40:40 <Ontolog> lol
19:41:10 <Ontolog> i don't get it, why not
19:41:21 <shachaf> Because of lots of things.
19:41:22 <ab9rf> Ontolog: because you can't :)
19:41:25 <shachaf> Let's say because of type inference.
19:41:29 <zachk> herro
19:41:37 <Cale> Ontolog: because we want type inference to not take exponential amounts of time in the size of the program on a regular basis
19:41:41 <Ontolog> i would think type inference would be the very thing that allows it :/
19:41:54 <shachaf> Ontolog: foo x = distance x + 1
19:42:01 <shachaf> What's the type of foo?
19:42:06 <ab9rf> Ontolog: you ca, however, define an algebraic type that has two constructors, one that takes a Path and one that takes two Nodes, and then defne a function that accepst that type.
19:42:10 <shachaf> Or should it get two overloaded types?
19:42:11 <Ontolog> depends on the type of x
19:42:26 <ab9rf> Ontolog: it has to be defined for _all_ x
19:42:48 <ab9rf> Ontolog: or at least you have to be able to express what sort of x's it can take
19:42:51 <Ontolog> so what are type signatures for...
19:42:59 <ab9rf> :t \x -> x + 1
19:43:00 <lambdabot> Num a => a -> a
19:43:18 <Cale> Ontolog: You could write:
19:43:36 <Cale> class Distance a where
19:43:41 <Cale>   distance :: a -> Int
19:43:53 <Cale> instance Distance Path where distance = ...
19:43:59 <Cale> instance Distance (Node, Node) where distance = ...
19:44:21 * sw2wolf haskell teaches me "function composition" and ...
19:44:29 <Cale> and then  distance :: (Distance a) => a -> Int
19:45:02 <Ontolog> omg it's Cale from #Math
19:45:07 <Ontolog> you rock
19:45:17 <Cale> :)
19:45:33 <Ontolog> you've been a part of my IRC life for years now lol, you are prolific
19:45:53 <Ontolog> well i'll just rename the functions for now
19:46:57 <copumpkin> ab9rf: come back! :(
19:47:36 <Cale> Ontolog: The nice thing about typeclasses as opposed to ad-hoc polymorphism, is that you can write polymorphic functions which have just a single definition, but which operate on many different types because they're using functions or other values which are typeclass polymorphic.
19:48:23 <Cale> Ontolog: So, for example, because (<=) is typeclass polymorphic, and not just ad-hoc polymorphic, we only have to write sort :: (Ord a) => [a] -> [a] once in terms of that
19:48:41 <Cale> Ontolog: and we don't have to repeat it over and over for different types, using the same implementation each time
19:48:42 <dmj> besides hackage how can I distribute my word frequency program? I put it on github, but I want someone to be able to do cabal install http://www.github.com/me/wordfreq or cabal install wordfreq. Is Ross Patterson on here?
19:49:32 <Cale> The thing which allows that to happen is having a name for the class of types over which the type variables in the signature of the polymorphic thing vary
19:49:45 <Ontolog> Cale: in this case, the way distance is calculated is completely different though
19:50:16 <Cale> Right, and of course, the way that (<=) is implemented will be different for different types
19:50:43 <Ontolog> ohh i see what you mean
19:50:58 <Ontolog> yes because if something is Ord, it returns an Ordering
19:51:00 <Ontolog> from compare
19:51:08 <dcoutts_> dmj: besides hackage, you can distribute apps as the source tarball via a http url (so long as the only libs it depends on are themselves on hackage otherwise you need multiple http urls)
19:51:31 <dcoutts_> dmj: e.g. cabal install http://example.com/awesome-2.0.tar.gz
19:51:35 <Cale> So if you used a typeclass here, you could use distance in some function which operated either on Paths or on pairs of Nodes, and wouldn't have to write *that* function twice
19:51:43 <ab9rf> Ontolog: no, it's more that compare only works on things that are in Ord.
19:51:55 <dmj> dcoutts_: cool thanks!
19:52:18 <Cale> and the assumption is that if you don't want that kind of polymorphism, well, you'd probably be better off giving the things distinct names anyway, since they're not really related then
19:52:47 <dcoutts_> dmj: obviously if you host the tarball on github you would need to provide your users with the url to the raw tarball, and not a pretty html page
19:53:14 <Cale> (Or of course, you can put them in separate modules, and solve your namespace problem that way)
19:55:31 <Ontolog> Cale: i have to say that the learning curve for me learning haskell is pretty steep since i've never done any functional programming before, but i suppose it comes more natural to someone who has been steeped in mathematics for many years
19:56:56 <Cale> I don't know. The problem is more that if you already have lots of preconceptions about how writing programs ought to go, then there's a lot of work you have to do to get over those.
19:57:12 <ldgonza> I hear you man; I saw a discussion here about type theory some days ago and I felt really small ^^
19:57:29 <Ontolog> yes, i've been doing OOP for basically the last 10 years :/
19:57:37 <Cale> It took me about 2 months to get to the point where I felt like I could do useful things with Haskell, and about a year to really be comfortable -- though that was back in the time when there were not quite as many resources.
19:57:54 <Ontolog> ah, well that's good to know
19:57:57 <Cale> (I started back in 2001 or so)
19:58:03 <Ontolog> i've been on it for only a few days now
19:58:07 <Ontolog> ah, oldschool
19:59:02 <andrewsw> Ontolog: there are a handful of fundamental mental shifts you have to make and then you'll wonder how you did it before ;)
19:59:20 <ab9rf> Cale: it's taken me almost two years
19:59:26 <ab9rf> Cale: although not all at one go
19:59:59 <Ontolog> andrewsw: cool, that's kind of why im studying it now, since i feel programming (on the job) has become a bit automatic and not really expanding my mind
20:01:35 <monochrom> a Haskell type class is not a type. this trips many people. since they come from Java and C++, where a class is a type, and they just assume.
20:02:06 <monochrom> but then, I am not so sure whether Haskell trips people or people's assumptions trip people.
20:02:08 <ab9rf> some of my early attempts at using typeclasses fell for that trap
20:03:11 <monochrom> in Java, an interface is also a type, very like class. therefore, all helpful-wannabe blogs that say "Haskell type class is like Java interface" are equally broken.
20:05:37 <monochrom> this aspect is specific to Haskell, not functional programming or imperative programming. it is easy to see how to modify an imperative language to have type class.
20:06:22 <monochrom> for functional programming, you have to embrace "substitute equal for equal", which you have denounced after learning imperative programming, since it does not work there.
20:06:53 <andrewsw> a = a + 1
20:07:26 <ab9rf> i was just reading an article earlier this evening on dependency injection in java as a way to avoid the global bvariable antipattern
20:07:40 <monochrom> well, let's be charitable and assume they have corrected that notation back to "a := a + 1"
20:07:40 <ab9rf> and it occured to me that this is so much more obvious after coding in haskell for the last few months
20:08:15 <andrewsw> monochrom: fair enough
20:11:13 * sw2wolf i always regards type class as interface in other language ...
20:11:37 <monochrom> suppose you have in Haskell "f x = x + 1", "g y = y^2". then f (g 2) = g 2 + 1 = 2^2 + 1. equal. subtitute equals for equals. there is no worrying about "what to execute first". it does not quite matter.
20:15:58 <monochrom> whereas, even in SML, you can have "f x = (let tmp = !global_var in global_var := x; tmp + 1)", "g y = (let tmp = !global_var in global_var := y; tmp^2)". now you cannot substitute equal for equal. you must execute in your head, and you must execute in the standard order, any other order may give wrong answers.
20:17:09 <monochrom> you cannot, for example, think f (g 2) = (let tmp = !global_var in global_var := g 2; tmp + 1). wrong order.
20:17:37 <ab9rf> i really wish haskell had been around when i was a CS student
20:17:43 <ab9rf> i might have stayed in the major
20:18:07 <monochrom> in imperative programming, you must forget highschool algebra. in functional programming, you must recall highschool algebra. this is why the switch is so hard for some people.
20:18:53 <heatsink> Can Haskell be viewed as an untyped functional language with a type system imposed on it?
20:18:55 <ab9rf> monochrom: yeah, i see a lot of people who do (in C) "area = radius * radius * pi; scanf (&radius); printf ("%f", area);" and can't figure out why their app doesn't work
20:19:03 <ab9rf> heatsink: no, types are intrinsic to haskell
20:19:49 <heatsink> It's a valid interepretation for the plain Hindley-Milner type system
20:20:11 <heatsink> Where does it break down in Haskell?  Is it because of type classes?
20:20:11 <ab9rf> i'm not sure what an untyped language would _be_
20:20:39 <monochrom> that is actually Church's view vs Curry's view. one of them says, "start with values, then add types". the other says, "start with types, then add values". I forgot which is which.
20:20:40 <Cale> heatsink: Yeah, choosing instances is hard to do without type classes
20:20:56 <ab9rf> monochrom: ah, that makes sense
20:21:04 <Cale> er, without types :P
20:21:24 <Cale> Consider something even as simple as return
20:21:34 <Cale> return :: (Monad m) => a -> m a
20:21:35 <andrewsw> ab9rf: lambda calculus
20:21:44 <Cale> take the types away, and how do you know which m to use?
20:21:53 <Cale> You'd need to take it as an explicit parameter then
20:21:56 <ab9rf> andrewsw: i never formally learned lambda calculus so that doesn't go anywher efor me
20:22:24 <Cale> Same goes for bind, and then bind can't be an infix operator and gets pretty awkward as you repeatedly have to supply the monad instance as a parameter
20:22:25 <monochrom> in a stroke of iron, in many cases we have a confluence theorem that says the order does not matter! XD
20:22:31 <monochrom> s/iron/irony/
20:24:25 <ab9rf> a stroke of wood goes further
20:24:26 <heatsink> ...Since type inference will choose the class instance that will prevent a type error from occurring in the future.
20:24:31 * startling strikes monochrom with iron
20:24:51 <ab9rf> repeat (writeOnBlackboard "i will not prattle on #haskell while drunk")
20:26:57 <Cale> heatsink: Yeah, you can view it as implicitly supplying value parameters that you don't have to put in your code
20:27:36 <Cale> and without that, a lot of the notations we use would be a lot more awkward
20:28:10 <amiller> has anyone used this
20:28:11 <amiller> http://okmij.org/ftp/tagless-final/index.html#call-by-any
20:28:30 <amiller> a semantics for a final-encoded EDSL using a monad parameter
20:28:57 <amiller> i can't figure out how this would extend to a language with data constructors like product and tagged union
20:32:32 <amiller> my approach so far has been to add an extension parameterized by any functor which includes the normal ones like product/tagged union etc
20:33:29 <ab9rf> you lost me at functor
20:36:51 <amiller> probably i'm doing it a more complicated way so the simplest question is how to extend this language with a proudct type
20:37:16 <amiller> i think the fundamental thing is that i'd need to expose a way of having an execution order
20:37:24 <ab9rf> eek
20:42:09 <startling> is there an environment variable I can check for with the CPP stuff to see if this thing is being built with cabal?
20:43:30 <Clint> define a symbol?
20:45:05 <startling> in the cabal file? Yeah, I guess I could do that, but I thought there might be one already.
20:45:14 <monochrom> you may cheat. here is how. cabal doesn't define a symbol for itself. but it defines macros for depended libs. most likely, base is one of them. therefore, MIN_VERSION_base is defined. but it is a predicate, not a symbol.
20:45:36 <monochrom> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
20:47:37 <ab9rf> whee!
20:52:27 <startling> wait, can I define an environment variable for cabal to define during compilation?
20:54:02 <monochrom> it will have to be compiler-specific hacks like ghc-options: -DMy_Cabal_Hack_Symbol
20:55:30 <Ontolog> can a lambda refer to itself?
20:55:38 <monochrom> without knowing your constraints, I will uninformedly recommend: try not to determine whether you're in cabal.
20:56:30 <geekosaur> Ontolog, no
20:56:42 <geekosaur> at least not without something like fix
20:57:00 <monochrom> if I write "f = \x -> f (x - 1)", does that count?
20:57:05 <startling> monochrom: well, I'd like to be able to run this code in ghci without needing that weird data-file path import cabal can provide
20:57:47 <startling> the "import Paths_mypackage" thing
20:58:56 <ab9rf> monochrom: f x = f (x - 1) ?
20:59:02 <ab9rf> monochrom: that's perfectly legal
20:59:22 <ab9rf> monochrom: there's no way to make an anonymous lambda refer to itself without binding it to something first, though
20:59:31 <monochrom> a self-referencing lambda is requested. therefore, I had to stuff a \ somewhere
21:10:20 <AfC> I [think I] need to add some state to an underway attoparsec Parser. Is that doable?
21:11:58 <AfC> The parser is consuming some network traffic; occasionally the chunks (as sent by the server) are huge, and I'd like to deliver them to the app as a series smaller (ie 32kB) ByteStrings, not 10s or 100s of MB.
21:12:50 <AfC> The streaming I/O framework is happy to run the Parser for me, expecting Parser ByteString as the type. But if I know I have more input to consume, I'd like to pass that back in somehow. Seems a typical use of the State monad, but I'm not in MonadState so far as I know
21:25:09 <nwf> Is it worth reporting minor build issues on the 7.6 branch to somebody?  If so, where?
21:26:17 <koninkje> nwf: yes, glasgow-haskell-users@haskell.org is probably the best place
21:30:30 <tertl3> i want to make a potatohead
21:30:52 <nwf> koninkje: Hi!
21:31:12 * koninkje :)
21:31:15 <koninkje> how's it going?
21:31:42 <nwf> OK; trying to be a good academic 'n all that.  You?
21:33:18 <koninkje> same. Can't wait for the end of term
21:33:30 <koninkje> I should be done with classes after this term
21:34:05 <koninkje> nwf: Do you still read LJ/DW?
21:34:20 <nwf> Very occasionally.
22:44:51 <pygmalion> > [1..10]
22:44:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:07:36 <Shin-LaC> what do you call a tree with only one node?
23:09:11 * hackagebot http-conduit 1.9.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.3 (MichaelSnoyman)
23:09:47 <shachaf> Shin-LaC: Maybe "singleton"?
23:10:22 <Shin-LaC> shachaf, that's what "learn you a haskell" uses, but I don't like it
23:10:46 <shachaf> OK, so call it "a tree with only one node".
23:10:53 <shachaf> Or don't call it anything.
23:10:56 <shachaf> Or call it "a tree".
23:12:46 <Ralith> call it joe
23:12:48 <Ralith> joe's a nice name
23:13:27 <cmears> It's just a "leaf"
23:13:44 <cmears> Or maybe a bud, or a seed
23:15:18 <Shin-LaC> stump
23:15:34 <ion> twee
23:17:16 <shachaf> "tree" should be one that has 3 values
23:17:20 <shachaf> Maybe call it a "wun".
23:17:46 <ion> thrue
23:49:09 <lightquake> is there a way to get pandoc to highlight *all* code blocks, including inline ones?
23:50:26 <lightquake> i'd like to be able to say 'all code in this document is haskell'
23:56:08 <lightquake> i guess i could just add the haskell class to every code block
23:56:45 <DarkFox> How would one break at the last occurance of a character?
23:58:38 <startling> DarkFox, you could do it in two passes pretty easily
23:59:26 * DarkFox too tired and can't think :/
23:59:38 <arkeet> I would break at every occurrence and then join stuff.
23:59:46 <lightquake> yeah, i'd do that
