00:00:09 <hpaste> “Anonymous Coward” annotated “2x2 array exception” with “4x4 array working” at http://hpaste.org/86226#a86228
00:00:24 <prkchp_sndwch> BMeph_, working now
00:00:27 <prkchp_sndwch> thanks
00:00:28 <Ralith> lightquake: write a curses-based tetris
00:01:24 * lispy wishes ghc could learn to use less memory when building thigs
00:01:25 <BMeph_> prkchp_sndwch: Ah, forgot to change the second one - good catch. Glad I helped a little. :)
00:02:20 <lispy> make a tty-like abstraction that uses pipes?
00:02:37 <lispy> then you can make a shell or xterm on top of your tty
00:02:48 <lightquake> lispy: hsh, the haskell shell!
00:03:04 * BMeph_ wishes that we could do it all over again and tell the whiners three years ago that "Haskell doesn't need an 'Official' compiler, and can be perfectly acceptable with different compilers for different goals"...but he can't. :/
00:04:05 <lispy> BMeph_: erm. What?
00:04:15 <lispy> BMeph_: you're the reason ghc uses so much memory?! :)
00:05:24 <coburrito> lispy: GHC is the first compiler I've ever seen leak memory.
00:05:43 <cmccann> GHC is finely tuned and optimized for maximum memory consumption
00:05:51 <lispy> coburrito: you've seen ghc *leak* memory or just use a lot of memory?
00:06:19 <coburrito> lispy: Leak memory. I did something stupid with some FFI bindings, and GHC used 12 GB+ at compile time, never halting.
00:06:20 <cmccann> it's like GHC doing calisthenics to warm up before generating code that allocates memory at mind-boggling rates
00:06:21 <lispy> I've seen it use a lot and I've seen it trick gnu ld into using even more, but I can't say I've seen it leaking.
00:07:01 <cmccann> I once crashed my system by making GHC infer a type that took nearly a gigabyte of memory!
00:07:04 <cmccann> that was unwise
00:07:21 <cmccann> protip, they're not joking about the worst-case complexity of H-M
00:07:29 <lispy> yeah :(
00:08:08 <cmccann> fortunately I've never encountered that when writing code intended to do something useful
00:08:22 <Mortchek> cmccann, what type was that? o_0
00:08:35 <djahandarie> It's a good thing I have 32GB of RAM for compiling Agda code already
00:09:10 <cmccann> Mortchek: I forget how it worked exactly but basically you can get an exponential blowup in the number of un-unified type variables or something like that
00:09:38 <cmccann> you're unlikely to see that unless you do it deliberately though
00:10:13 <coburrito> Or you have a fetish for type-level absurdity.
00:10:29 <ijp> just publish a paper about how it is completely useless, and watch someone else provide an application for it
00:10:35 <Mortchek> It's hard for me to imagine a useful type with more than a few type variables.
00:11:05 <hackedy> Mortchek: depends on your definition of "useful" >:)
00:11:54 <ijp> could be useful for DDOS...in an extremely contorted example
00:12:44 <Mortchek> Let's say "being a reasonable choice of representation for a given application"
00:13:52 <mauke> < ()
00:14:16 <Mortchek> ijp, I would say it's highly improbable that the same algorithm is proficient at both unifying types and executing a DDoS
00:14:32 <lispy> http://haskell.1045720.n5.nabble.com/Exponential-complexity-of-type-checking-Was-Type-level-naturals-multiplication-tp3135597p3135598.html
00:14:43 <coburrito> What about type-level programs?
00:14:54 <coburrito> There might be useful type-level programs that manifest this problem.
00:15:10 <coburrito> Using a lambda calculus implemented with type arithmetic, for instance.
00:15:40 <ijp> Mortchek: I believe in the power of humans to do stupid things
00:18:25 <cmccann> :t let foo v w x y z f = f . z . y . x .w $ v; bar = foo foo foo foo foo in bar bar bar bar
00:18:26 <lambdabot> ((((((((((((((((((((((((((((((((a -> (a -> b13) -> (b13 -> b12) -> (b12 -> b11) -> (b11 -> b10) -> (b10 -> c4) -> c4) -> b3) -> (b3 -> b2) -> (b2 -> b1) -> (b1 -> b) -> (b -> c) -> c) -> b16) -> (
00:18:26 <lambdabot> b16 -> b15) -> (b15 -> b14) -> (b14 -> c5) -> c5) -> b6) -> (b6 -> b5) -> (b5 -> b4) -> (b4 -> c1) -> c1) -> b19) -> (b19 -> b18) -> (b18 -> b17) -> (b17 -> c6) -> c6) -> b24) -> (b24 -> b23) -> (
00:18:26 <lambdabot> b23 -> b22) -> (b22 -> b21) -> (b21 -> c8) -> c8) -> b8) -> (b8 -> b7) -> (b7 -> c2) -> c2) -> b27) -> (b27 -> b26) -> (b26 -> b25) -> (b25 -> c9) -> c9) -> b35) -> (b35 -> b34) -> (b34 -> b33) -> (
00:18:26 <lambdabot> b33 -> b32) -> (b32 -> c13) -> c13) -> b20) -> (b20 -> c7) -> c7) -> b38) -> (b38 -> b37) -> (b37 -> b36) -> (b36 -> c14) -> c14) -> b29) -> (b29 -> b28) -> (b28 -> c10) -> c10) -> b41) -> (b41 ->
00:18:26 <lambdabot> b40) -> (b40 -> b39) -> (b39 -> c15) -> c15) -> b9) -> (b9 -> c3) -> c3) -> b44) -> (b44 -> b43) -> (b43 -> b42) -> (b42 -> c16) -> c16) -> b31) -> (b31 -> b30) -> (b30 -> c11) -> c11) -> c12) ->
00:18:28 <lambdabot> c12
00:18:36 <u_> bahaha
00:18:38 <cmccann> to give you an idea :P
00:18:51 <Mortchek> Ow ow ow
00:18:58 <Mortchek> Why would you even need that function? :(
00:19:22 <cmccann> I forget how I did that by accident but it was something that involved a lot of CPS-d functions without newtype wrapper or type signatures
00:19:42 <cmccann> and it blew up in a way similar to that example, only much faster
00:19:55 <lispy> > let dup x = (x,x) in dup . dup . dup . dup . dup 1
00:19:58 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `(t0, t0)'
00:20:13 <lispy> > let dup x = (x,x) in dup . dup . dup . dup . dup $ 1
00:20:13 <Mortchek> let dup x = (x,x) in dup . dup . dup . dup . dup $ 1
00:20:14 <lambdabot>   (((((1,1),(1,1)),((1,1),(1,1))),(((1,1),(1,1)),((1,1),(1,1)))),((((1,1),(1,...
00:20:20 <Mortchek> Woop
00:21:26 <cmccann> Mortchek: it's easy to get exponential growth but when I did it by accident most of the type variables were intended to be the same thing
00:21:45 <Mortchek> Hrm, I see
00:21:46 <cmccann> but I messed something up and an intermediate expression ended up having a horrific type
00:21:50 <lispy> :type let {f0 x = (x,x); f1 x = (f0 x, f0); f2 x = (f1 x, f1 x); f3 x = (f2 x, f2 x)} in f0 1
00:22:07 <lispy> :t let {f0 x = (x,x); f1 x = (f0 x, f0); f2 x = (f1 x, f1 x); f3 x = (f2 x, f2 x)} in f0 1
00:22:11 <lambdabot> Num t => (t, t)
00:22:13 <cmccann> and of course I thought "wow, GHC took a long time to figure that out, what happens if I do the same thing nested a few more times"
00:22:15 <lispy> :t let {f0 x = (x,x); f1 x = (f0 x, f0); f2 x = (f1 x, f1 x); f3 x = (f2 x, f2 x)} in f3 1
00:22:16 <lambdabot> Num t3 => ((((t3, t3), t -> (t, t)), ((t3, t3), t1 -> (t1, t1))), (((t3, t3), t2 -> (t2, t2)), ((t3, t3), t4 -> (t4, t4))))
00:22:26 <cmccann> it chewed up like two gig of memory before I managed to kill GHC
00:22:38 <lispy> :t let {f0 x = (x,x); f1 x = (f0 x, f0); f2 x = (f1 x, f1 x); f3 x = (f2 x, f2 x); f4 x = (f3 x, f3 x)} in f4 1
00:22:39 <lambdabot> Num t7 => (((((t7, t7), t -> (t, t)), ((t7, t7), t1 -> (t1, t1))), (((t7, t7), t2 -> (t2, t2)), ((t7, t7), t3 -> (t3, t3)))), ((((t7, t7), t4 -> (t4, t4)), ((t7, t7), t5 -> (t5, t5))), (((t7, t7),
00:22:39 <lambdabot> t6 -> (t6, t6)), ((t7, t7), t8 -> (t8, t8)))))
00:23:32 <jamil_1_> can't understand how does this work: fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
00:23:45 <jamil_1_> fix :: (a -> a ) -> a
00:24:17 <lispy> fix f = f (fix f)
00:24:39 <lispy> Try expanding that definition out on something simple by hand
00:24:56 <lispy> > fix (\f -> 1)
00:24:59 <lambdabot>   1
00:25:43 <shachaf> > let rek = (\rek n -> if n == 0 then 1 else n * rek (n-1)) rek in rek 5
00:25:45 <lambdabot>   120
00:26:09 <shachaf> "fix f" is just "let rek = f rek in rek"
00:26:28 <shachaf> Hmm, maybe the shadowing makes things more confusing there.
00:26:49 <shachaf> Shadowing a variable with itself! And they said it couldn't be done.
00:27:17 <Mortchek> > let a = 1:a in a
00:27:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:27:33 <Mortchek> > let a = fix (1:) in a
00:27:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:27:59 <shachaf> There you go. Easy as a monoid.
00:28:55 <hpaste> “C. McCann” pasted “uh oh” at http://hpaste.org/86229
00:29:09 <cmccann> Mortchek: try loading that in GHC and asking for the type of "uhoh"
00:29:27 <cmccann> don't worry, I trimmed it down so it won't crash your system
00:30:34 <cmccann> Mortchek: composing more copies "down" makes it get much much worse very fast
00:30:46 <Mortchek> Yeah, I tried it
00:30:55 <Mortchek> That is a complex type :P
00:31:22 <cmccann> did you try adding an extra "down"?
00:31:30 <cmccann> comparing three vs. two is... impressive
00:31:51 <shachaf> cmccann: Please add type annotations in your pastes. Thanks.
00:32:07 <cmccann> shachaf: sorry, I forgot. would you add it for me?
00:32:28 <Mortchek> :D
00:32:43 <shachaf> cmccann: I'm not going to do your work!
00:33:05 <cmccann> shachaf: ok thanks, I needed someone to help not do my work
00:33:24 <cmccann> lispy: did you see my hpaste?
00:33:33 <shachaf> Well, I figured it would be an even trade.
00:34:09 <Mortchek> This sort of reminds me of the types I got as I applied fmap to itself progressively more times
00:34:14 <Mortchek> fmap, fmap fmap, fmap fmap fmap, etc.
00:34:21 <lispy> @pl s f g x = f x (g x)
00:34:21 <lambdabot> s = ap
00:34:37 <shachaf> fmap^6 = fmap^10
00:34:40 <cmccann> yes
00:34:42 <shachaf> It's boring.
00:34:42 <cmccann> it's S
00:34:47 <cmccann> right there in the name :P
00:35:05 <shachaf> cmccann: Get your capitaliszation right, please.
00:35:39 <lispy> and remove the redundant bracket. hlint is offended.
00:35:54 <cmccann> :[
00:35:55 <shachaf> cmccann seeks to offend
00:36:12 <shachaf> Particularly machines. But humans will do as well.
00:36:26 <cmccann> lispy: one of these days I need to trim that code down further and get a nicely golfed snippet of horrific type inference
00:36:58 <lispy> heh
00:37:04 <lispy> "need" :)
00:37:09 <cmccann> yes
00:37:13 <cmccann> very important
00:37:36 <lispy> You'll get like 10 internet points for that, at least
00:39:13 <lispy> I thought it would be nice to a) use hakyll b) edit/compile my blog on my linode. These two things seem to be incompatible if only because ghc is too hungry. :(
00:40:18 * lispy wonders what could be done about it
00:40:52 <lispy> I guess people have looked at it a bit, at least from the point of view of the linker going crazy. I wonder where the other 'hot spots' are.
00:41:30 <osfameron> compile the hakyll binary somewhere else?
00:42:06 <lispy> osfameron: hmmm...yeah, I really don't want to because then updating becomes a hassle IMO.
00:42:17 <lispy> But it would work
00:43:14 <osfameron> ah, I see
00:45:36 <lispy> I think the ideal solution would be to figure out why ghc is so memory hungry and improve the situation.
00:46:06 <lispy> I bet it would have the side effect of improving compile times (well, maybe. Depends on if the GC ends up being less total work)
00:47:06 <arkeet> good thing linode just doubled everyone's* ram
00:47:21 <arkeet> *not mine, mine is in fremont :c
00:52:10 <lispy> arkeet: I'm was in fremont too, so I created a new linode in a different server farm, shutdown my linode, cloned it to the new farm, started it up there, and then deleted the old one.
00:52:22 <arkeet> heh.
00:52:44 <lispy> arkeet: It cost me the prorated old rate (I don't think they've put out the new rates yet) for the new linode but they also refunded the prorated old linode price.
00:52:54 <arkeet> that's cool.
00:53:21 <arkeet> I can wait, and I'd rather keep the same IP and stuff.
00:53:35 <lispy> I use dynamic dns so changing it was fast
00:57:31 * lispy tries building with -O0
01:06:05 <lispy> In anyone cares, this is the module that won't compile for me: http://hackage.haskell.org/packages/archive/regex-tdfa/1.1.8/doc/html/src/Text-Regex-TDFA-NewDFA-Engine_FA.html
01:06:28 <lispy> even with -O0 ghc needs more than 1GB of ram
01:06:48 <shachaf> Turn on swap!
01:08:38 <lispy> shachaf: I don't know if that would help. My previous experiences with swap on linodes shows that ghc goes from segfaulting immediately to taking days to get nothing done.
01:08:54 <hpaste> jfischoff pasted “FileSystem Class Design Suggestions” at http://hpaste.org/86230
01:09:23 <shachaf> lispy: What you need is RAM-over-IP.
01:09:31 <shachaf> RAM-as-a-Service?
01:09:32 <zomg> I have the same problem on low ram linode
01:09:40 <jfischoff> ^ I'm looking for suggestions on how to design a class for basically doing what System.Directory does
01:09:45 <zomg> lispy: I just use mkswap / swapon to temporarily put disk space as ram
01:09:57 <zomg> that fixes any compilation issues with ghc
01:10:02 <jfischoff> I want a simple thing I can make a pure instance of and one for IO
01:10:20 <jfischoff> Any suggestions appreciated
01:12:01 <jfischoff> another possibility is to turn System.Directory into a class essentially
01:12:42 <jfischoff> but I would prefer to make a simpler interface, ideally the simplest
01:12:59 <aristid> lispy: hasn't linode doubled the amount of RAM you get?
01:13:13 <lispy> aristid: yeah
01:13:18 <lispy> aristid: ghc is pretty hungry :)
01:13:24 <aristid> they also doubled their credit card leaking efforts
01:13:34 <lispy> that too
01:14:30 <aristid> i think ec2's bargain is a bit better: you get decent-ish amounts of RAM, but are starved of CPU. which happens to mean you can use ghc, like, at all, if slowly :)
01:14:48 <aristid> (on a m1.small)
01:15:03 <lispy> Trying a build with some swap
01:15:12 <lispy> and I'm also heading to bed
01:15:19 <matthiasgoergens> Do we have ghc for ARM, yet?
01:15:21 <lispy> If lambdabot is unresponsive all night, you know what to blame :)
01:15:22 <aristid> why, it's early morning!
01:15:25 <aristid> matthiasgoergens: yes
01:15:34 <matthiasgoergens> Nice.
01:15:37 <lispy> @localtime lispy
01:15:40 <lambdabot> Local time for lispy is Sun Apr 21 01:15:34 2013
01:15:47 <lispy> aristid: oh no, you're right!
01:15:48 <matthiasgoergens> @localtime me
01:15:50 * lispy heads to bed
01:15:51 <aristid> lispy: see.
01:16:04 <arkeet> @localtime
01:16:05 <lambdabot> Local time for arkeet is Sun Apr 21 01:15:54 2013
01:16:09 <aristid> matthiasgoergens: your nickname sounds german or dutch or so
01:16:10 <arkeet> yep. bye
01:16:18 <aristid> @localtime matthiasgoergens
01:16:46 <matthiasgoergens> aristid, German.  But I'm in Singapore.
01:16:59 <aristid> matthiasgoergens: and you have blocked CTCP?
01:17:21 <matthiasgoergens> Oh, I am using Pidgin, and haven't configured it much.
01:17:48 <aristid> there are free real irc clients, you know? ;)
01:17:59 <matthiasgoergens> Yes, I am just too lazy.
01:18:05 <matthiasgoergens> It's a shame that they block IRC at work.
01:18:32 <aristid> oh i thought we're in #haskell-blah given the off-topic nature of this discussion :P
01:19:07 <hamid> matthiasgoergens, what company is that?
01:19:13 <arkeet> wow, me too.
01:19:36 <matthiasgoergens> hamid, Standard Chartered.
01:19:59 <matthiasgoergens> aristid: We use Haskell at work, so it's on-topic. ;o)
01:20:49 <aristid> matthiasgoergens: i know that standard chartered uses haskell :)
01:21:06 <jfischoff> mu-haskell or ghc haskell?
01:21:11 <hamid> matthiasgoergens, I didn't expect blocking IRC :P
01:22:04 * Ralith tries to imagine what would cause a company to be forward-thinking enough to use haskell, while still being backwards enough to block IRC
01:22:12 <shachaf> Is that why dons isn't around anymore?
01:22:40 <jfischoff> preflex seen dons
01:22:41 <preflex>  dons was last seen on #ghc 290 days, 15 hours, 4 minutes and 33 seconds ago, saying: i don't recall a time that the hetzner's been down before
01:23:21 <aristid> shachaf: or he lives on a hetzner server now
01:24:25 <matthiasgoergens> jfischoff, mostly the Mu dialect, but parts of it are implemented in ghc.
01:24:47 <matthiasgoergens> hamid, banks..
01:25:06 <matthiasgoergens> ralith, companies are not single persons..
01:25:28 <matthiasgoergens> aristid, dons works crazy hours.
01:25:49 <matthiasgoergens> But he probably logs in via his phone or something like that.
01:26:02 <matthiasgoergens> I'm not sure.
01:27:11 <Ralith> matthiasgoergens: nor are they characteristically wildly inconsistent
01:29:02 <matthiasgoergens> Even at Citrix before (where we also used Haskell, and in addition OCaml) we had to go to the IT people to get the irc ports unblocked in the firewall.
01:29:07 <matthiasgoergens> (But at least that was doable.)
01:37:42 <aristid> matthiasgoergens: dons works in NYC, no?
01:54:01 <tew88> I'm working through LYAH, and am getting to grips with type classes.  In the book, the author only makes Int an instance of the YesNo type class, but I wanted to gereralise to all Nums.  Responding to compiler errors, I've ended up with this: http://hpaste.org/86231 -- but my intuition has now broken down and was hoping that someone might be able to explain what's going on with: 1) the language pragmas; 2)
01:54:03 <tew88> the requirement of Num a *and* Ord a constraints.  Cheers!
01:55:36 <shachaf> The trouble is that if you make instance (...) => Foo a, then you can't make any other Foo instance which doesn't overlap.
01:56:32 <shachaf> The constraints aren't used in deciding whether something is an instance. So this like saying "instance YesNo a".
01:56:52 <tew88> Ah, I see
01:57:50 <matthiasgoergens> aristid, Don moved to London.
01:58:24 <Taneb> S expressions are just Free [] or maybe Free NonEmpty
01:58:30 <tew88> shachaf: So presumably this situation presents itself fairly often... are the language pragmas I've used the accepted way to resolve it, or is there a better way?
01:58:52 <matthiasgoergens> tew88, in many situations, using the constraints to decide which instance to use would be great.
01:59:01 <shachaf> It's acceptable to not do it. :-)
02:00:07 <Peaker> tanakh_, why non-empty? You can put empty lists anywhere in S-exrps
02:00:51 <shachaf> Taneb: Aren't S-expressions made of cons cells rather than lists?
02:01:00 <aristid> matthiasgoergens: there's a reason why the constraints are not used, and i see it every time edwardk hacks instance resolution by putting equality constraints in the constraint section instead of the head :)
02:01:01 <tew88> matthiasgoergens, shachaf: Right!  I'm sure this is naive then, but the only solution I see at this stage is to define instances for each concrete numeric type.  Surely that's wrong!
02:01:20 <Taneb> shachaf, this was a breakfast revelation, it may be horribly wrong
02:01:21 <Peaker> I don't think S-exprs expose the cons'ness -- lists are made of cons and s-exprs are above that iiuc
02:01:34 <shachaf> Do you count (a . b)?
02:01:39 <shachaf> tew88: I don't know that it's wrong.
02:01:44 <Peaker> I don't think that's an s-expression
02:01:45 <aristid> (a . b) is a s-expr, sure
02:01:49 <shachaf> tew88: Imagine you made this instance, and then someone else made instance Num Bool
02:01:52 <aristid> Peaker: yes it is P
02:02:02 <Peaker> well, of 3 atoms, not a cons cell
02:02:13 <shachaf> OK, now this is just an argument about words.
02:02:19 <shachaf> I withdraw.
02:02:42 <aristid> clearly wikipedia is all-knowing and a good authority to use here: http://en.wikipedia.org/wiki/S-expression
02:02:54 <tew88> shachaf: That would indeed be problematic.  Thanks =)
02:03:25 <shachaf> Free [] is certainly related to S-expressions: With Foo a = Free [] a, Foo Atom is either an Atom or a list of Foos.
02:04:25 <matthiasgoergens> aristid: In general not using the constraints is the right thing.  That's why I wrote "in many situations". :o)
02:04:54 <aristid> matthiasgoergens: :)
02:05:07 <aristid> matthiasgoergens: not sure how that would work though.
02:11:10 <matthiasgoergens> aristid, I guess with a separate mechanism?
02:11:35 <matthiasgoergens> I.e. you'd need one mechanism to specify constraints, and one for "please derive this for me automatically".
02:13:30 <aristid> matthiasgoergens: closed typeclasses might be cool too :D
02:14:34 <Ralith> aristid: aren't those called ADTs?
02:15:04 <matthiasgoergens> Why would you want a closed typeclass?  And what would that mean?
02:15:17 <aristid> Ralith: you can't do everything with those
02:15:26 <aristid> matthiasgoergens: let me try to find a good example.
02:15:32 <Ralith> well there go my plans to take over the world
02:17:04 <aristid> matthiasgoergens: consider these two classes for example: http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/Data-HList-HListPrelude.html#g:4
02:17:20 <aristid> matthiasgoergens: without the open world assumption, we might get far better type inference for this kind of code
02:17:35 <arkeet> HList could be done with DataKinds though. no?
02:18:26 <alol> How do I write a function that takes two parameters in point-free style? This is my failed attempt http://pastebin.com/cKABe7Ky . Could somebody please explain what I am doing wrong?
02:18:37 <aristid> arkeet: DataKinds give you closed type classes / type families?
02:19:44 <arkeet> no, I'm saying DataKinds could be used to write some HList thing
02:20:24 <shachaf> @pl hammingDistance a b = sum ((map popCount) (xorSum a b))
02:20:24 <lambdabot> hammingDistance = ((sum . map popCount) .) . xorSum
02:20:33 <haasn> sum . map popCount .: xorSum
02:20:41 <shachaf> .: is a lie
02:20:59 <haasn> import Data.Function.Pointless
02:21:04 <arkeet> write your own
02:21:06 <arkeet> (.:) = (.).(.)
02:21:23 <shachaf> haasn: Could not find module `Data.Function.Pointless'
02:21:25 <shachaf> It's a lie.
02:21:40 <haasn> :(
02:21:43 <haasn> cabal install pointless-fun
02:21:47 <shachaf> No thanks.
02:21:50 <shachaf> alol: Note that you're probably better off just naming one argument.
02:22:01 <shachaf> Or both.
02:22:55 <arkeet> hdpf x y = sum . map popCount $ xorSum x y
02:23:02 <merijn> aristid: No, but in HEAD you can get ordered type families, which is almost as good!
02:23:04 <arkeet> er, not pf anymore.
02:23:11 <arkeet> ordered type families?
02:23:11 <shachaf> pointful
02:23:15 <arkeet> oh sure.
02:23:33 <merijn> arkeet: I dunno how to explain otherwise, but this "lexical ordering decide which function is selected"
02:23:36 <haasn> naming just one argument makes it feel so oddly assymetric
02:23:56 <aristid> merijn: ok:)
02:23:56 <haasn> merijn: type instance where { ... }
02:23:56 <arkeet> sounds weird.
02:24:20 <merijn> haasn: That, yes
02:24:32 <arkeet> you can always make a type family of kind K -> * where K is some data kind.
02:24:33 <merijn> But no clue how that should be called :p
02:24:37 <arkeet> or class.
02:24:41 <haasn> basically it lets you write type instance where { a == a = True; a == b = False }
02:24:44 <arkeet> I mean class K -> Constraint
02:25:00 <arkeet> and then it could be closed. I guess.
02:25:13 <arkeet> except Any sucks.
02:26:03 <haasn> with ConstraintKinds you can even write fancy stuff like type family Foo (cs :: [Constraint]) :: Constraint
02:26:24 <alol> shachaf: Thank you. I think I will use the "pointful" version instead :)
02:26:27 <shachaf> Does fusion happen for foldl' f z (foldr φ ω xs)?
02:26:28 <arkeet> alol: basically the point (ugh) is that (.) composes functions of a single argument.
02:26:36 <arkeet> whoa greek letters.
02:26:55 <shachaf> arkeet: I first wrote (foldr g [...] xs), but then I didn't know what to put there.
02:27:02 <arkeet> w
02:27:07 <haasn> y
02:27:13 <shachaf> ω is almost w
02:27:15 <arkeet> no, everyone knows w comes after z.
02:27:17 <merijn> shachaf: The report or manual (I forgot which) has a list of "well-behaved producers/consumers" in the prelude that will fuse
02:27:18 <alol> arkeet: hm. ok. I'm going to think about that untill I get it.
02:27:31 <merijn> shachaf: Might wanna check that list
02:27:32 <arkeet> alol: well, look at the type really.
02:27:35 <shachaf> alol: But @pl is a good way to experiment with point-free things.
02:28:10 <haasn> it's also very good at producing indecipherable results
02:28:26 <haasn> @pl \a b c -> c^2 * (b - a)
02:28:27 <lambdabot> (((. (^ 2)) . (*)) .) . subtract
02:28:48 <haasn> hmm not as bad as I hoped
02:29:05 <shachaf> @pl let f x = (x,x) in f x
02:29:05 <lambdabot> (x, x)
02:29:11 <shachaf> @pl let f x = (x,x); g x = f (f x) in g x
02:29:11 <lambdabot> ((x, x), (x, x))
02:29:42 <danr> @pl \ x -> ((x,x),(x,x))
02:29:43 <haasn> @pl let f x = (x,x); g f x = f (f x) in g (g (g f)) x
02:29:44 <lambdabot> ap ((,) . join (,)) (join (,))
02:29:46 <lambdabot> join (.) (join (.) (join (,) . join (,))) x
02:32:27 <yitz> merijn: i doubt that the report has anything about fusion. the report is supposed to be implementation-independent, and there are many possible implementations for which the ghc concept of fusion makes no sense.
02:38:27 <merijn> yitz: I know, I suspect it was the GHC manual
02:39:38 <matthiasgoergens> aristid: thanks.
02:41:13 <matthiasgoergens> There are a few instances of functions of multiple parameters being useful even in pointfree style.
02:41:16 <matthiasgoergens> e.g.
02:41:24 <matthiasgoergens> (fmap.fmap)
02:41:33 <matthiasgoergens> which applies your function two layers in.
02:44:01 <finnrobi> I'm trying to make my testsuite depend on quickcheck and hunit, but cabal says:
02:44:08 <finnrobi> cabal: At least the following dependencies are missing:
02:44:08 <finnrobi> hunit -any, quickcheck -any
02:44:20 <finnrobi> I have verified that they are installed
02:44:27 <finnrobi> what am I doing wrong?
02:45:51 <Peaker> finnrobi, maybe it tries to find them with profiling enabled or such?
02:46:02 <Peaker> finnrobi, what does ghc-pkg list hunit say? Maybe it's a hidden package?
02:46:09 <ijp> is c-- still developed outside of ghc? or has that ship sailed
02:47:58 <finnrobi> Peaker: it does not make me wiser - it lists some configuration file directories which contains configfiles for the packages
02:48:20 <finnrobi> aha
02:48:22 <finnrobi> now I feel silly
02:48:26 <Peaker> finnrobi, if the output is just one line, maybe you can paste it?
02:48:34 <finnrobi> it's case-sensitive obviously
02:48:39 <finnrobi> /o\
02:48:51 <Peaker> it's not obvious since cabal-install is case-insensitive
02:49:26 <finnrobi> yeah, but seeing the package-names being store like HUnit-*.conf on the file system kind of gave away what happened :p
02:49:29 <finnrobi> thanks for the hint
02:50:41 <Peaker> finnrobi, I wanted that output to see if maybe the package is hidden.. but if your issue is solved that's great :)
03:05:26 <Hail_Spacecake> what status do <- and -> have in the haskell language?
03:05:29 <Hail_Spacecake> they're not functions
03:05:39 <Hail_Spacecake> or at least, I can't do :t (<-) or :t (->)
03:05:59 <shirt> i'm using HDBC with an sqlite3 database. when i open the database, how can i detect if the database is newly created, or if i am opening an existing database?
03:06:04 <awgn> I'm playing with template haskell. Given makeAdd n = [d| add' x = x + n|], how can I use it from a separeted module? Do I need runQ or splice?
03:07:35 <Taneb> Hail_Spacecake, they're syntax
03:10:38 <mel-> hi
03:10:59 <mel-> Hail_Spacecake: these are just syntactic sugar.
03:11:30 <Hail_Spacecake> mel- for whta?
03:11:31 <mel-> Hail_Spacecake: ah, sorry, do you mean '<-' in the context of 'do'? if not, then these are just syntax 'atoms'.
03:11:38 <Hail_Spacecake> yeah
03:11:44 * hackagebot unsafe 0.0 - Unified interface to unsafe functions  http://hackage.haskell.org/package/unsafe-0.0 (HenningThielemann)
03:11:46 <Hail_Spacecake> but also in functoin type signatures
03:11:46 * hackagebot hlint 1.8.44 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.44 (NeilMitchell)
03:11:49 <mel-> hackagebot: then forget my first remark.
03:12:04 <arkeet> <- and -> are unrelated.
03:12:14 <mel-> Hail_Spacecake: then i'm not sure I understand your question correctly. The same way you could ask what does "::" mean?
03:12:23 <arkeet> -> occurs in a few unrelated places
03:12:53 <arkeet> in type signatures, it's just a type constructor
03:12:54 <mel-> Hail_Spacecake: '->' is type signatures is just the symbol for specifying 'functions'.
03:13:00 <arkeet> that happenes to be a binary operator
03:13:01 <arkeet> :k (->)
03:13:07 <lambdabot> * -> * -> *
03:13:09 <Hail_Spacecake> I understand that -> and <- are syntactic atoms in the haskell language itsel
03:13:21 <Hail_Spacecake> wait, -> *is* an operator?
03:13:26 <arkeet> of course you can't ask for the type of (->), since it's not a value.
03:13:29 <arkeet> it's a type.
03:13:30 <Hail_Spacecake> so, why cna't I do something like let a = (->)
03:13:38 <arkeet> it's a type operator.
03:13:42 <Hail_Spacecake> oh
03:13:53 <Hail_Spacecake> I only vaguely understand the kind system in haskell
03:13:54 <mikeplus64> you can do type A a b = a -> b though
03:14:08 <Hail_Spacecake> ah
03:14:37 <Hail_Spacecake> so, can you define (->) entirely in haskell, if you wanted to?
03:14:52 <arkeet> no, it's a bit special.
03:16:38 <merijn> (->) is like Bool and Int a built-in (but type level in this case)
03:16:44 * hackagebot storablevector 0.2.8.3 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.8.3 (HenningThielemann)
03:16:48 <arkeet> Bool is built-in?
03:16:52 <merijn> Hail_Spacecake: You can define your own type operators if you want
03:17:05 <merijn> arkeet: Oh, doh, bad example...
03:17:07 <merijn> Char?
03:17:14 <arkeet> sure.
03:17:26 <arkeet> (well, technically they're not, but they wrap Int# and Char# which are primitive.)
03:17:27 <merijn> Anyway
03:17:35 * merijn kicks arkeet 
03:17:38 <merijn> Shush
03:31:29 <b__> is it practical to have a cabal package with multiple executables?
03:32:03 <ClaudiusMaximus> yes, just have multiple executable sections
03:32:35 <shachaf> That is, multiple executable-sections, not multiple-executable sections.
03:32:37 <ClaudiusMaximus> but personally i found it awkward to have to repeat all the common build dependencies
03:32:59 <ClaudiusMaximus> well not awkward, just tedious...
03:33:26 <arkeet> if your package contains a library, you can have those executables depend on the library.
03:34:19 <arkeet> well
03:34:30 <arkeet> blah
03:49:01 <jamil_1> is there a relation between data Fix f = Fix f (Fix f) and data Free f r = Pure r | Free f (Free f r)
03:49:02 <jamil_1> ?
03:49:34 <shachaf> Yes.
03:49:53 <Cale> jamil_1: the second is the first applied to Either r
03:50:15 <shachaf> (You're missing parentheses in the definition of Free, by the way.)
03:50:23 <Cale> and I suppose the first is the second applied to Void, in a sense
03:50:48 <Cale> Yeah, it needs to be data Fix f = Fix (f (Fix f))
03:50:57 <shachaf> Oh, in Fix too.
03:51:00 <Cale> also in Free, similarly
03:52:21 <shachaf> There's no F such that Cofree F = Fix :-(
04:10:42 <Guest15538> How do I read a function string into a function and apply it. For example, the user enter a string "sum" and the x and y, how can I parse sum?
04:11:19 <shachaf> You're not going to have much luck trying to translate it directly to an arbitrary Haskell identifier.
04:11:45 <shachaf> Keep your own table mapping names to functions. (case input of "sum" -> sum; ... -> ...)
04:13:34 <Guest15538> shachaf: Is there anything like "reflection"
04:13:57 <shachaf> "reflection" is a word that means many things.
04:16:16 <jamil_1> I guess reflection as in java reflection
04:16:17 <Guest15538> something like the java example in http://en.wikipedia.org/wiki/Reflection_(computer_programming)
04:16:46 <Guest15538> clazz.getMethod("hello").invoke(clazz.newInstance());
04:17:23 <maltem> Normally, types are erased at runtime, but there are some type classes that allow fancy things (Typeable, Data)
04:17:57 <maltem> That said, your example isn't typical of their use
04:17:57 <arkeet> and Generic
04:18:07 <shachaf> Like I said, trying to translate a string to the value of a Haskell identifier probably isn't going to go well for you.
04:18:08 <arkeet> er
04:18:13 <arkeet> that's Data
04:18:53 <arkeet> shachaf: what about something like hint.
04:19:06 <shachaf> arkeet: It isn't going to go well for you.
04:19:10 <arkeet> :(
04:19:11 <shachaf> I didn't say it wasn't possible.
04:19:18 <arkeet> true
04:19:43 <shachaf> Will hint find identifiers *in your program*, or just compile some arbitrary Haskell code?
04:20:02 <shachaf> It sounds like this person is after eval() and all the bad things associated with it.
04:20:19 <arkeet> it sounds like it's bedtime.
04:20:45 <Guest15538> :t eval
04:20:46 <lambdabot>     Not in scope: `eval'
04:20:47 <lambdabot>     Perhaps you meant `ival' (imported from Data.Number.Interval)
04:22:47 <mgsloan> Guest15538: http://www.reddit.com/r/programming/comments/122iby/another_nonargument_in_type_systems/c6sfg5n?context=3
04:25:11 <quchen> mgsloan: That is awful.
04:25:39 <mgsloan> quchen: Oh?  I think it turned out quite cleanly
04:26:06 <mgsloan> I mean, of course ShowWrapper is pretty much pointless.  But I wanted to use "print" to make it look as much like munificent's challenge as possible
04:26:07 <quchen> That would make it a good solution to something awful then ;-)
04:26:14 <mgsloan> :)
04:26:34 <mgsloan> I'm not sure what's so awful about having bindings to a haskell interpreter
04:27:37 <quchen> Oh it can be useful of course (scripting capabilities and such), but the example emulates eval specifically
04:27:45 <mgsloan> Now if you want to hear something really awful, I want to be able to change code in a program as its running
04:28:19 <mgsloan> and scheme to possibly do so by having a program transformation that sprinkles "unsafePerformIO $ readIORef someGeneratedGlobal" everywhere
04:28:24 <quchen> mgsloan: Weren't there some ASM challenges like this - at each step, a player could modify an instruction in his opponent's program?
04:28:48 <mgsloan> sounds kinda like core wars
04:29:04 <arkeet> well, you'd get the code to load a new version of itself when appropriate.
04:31:42 <quchen> Data.Data seems scary.
04:32:06 <Cale> Data.Data.Data
04:32:12 <hpc> http://images1.wikia.nocookie.net/__cb20120803173158/memoryalpha/en/images/b/bd/Data_phone.jpg Dammit, what?
04:33:04 <hpc> i am starting to come around to the opinion that dynamic types are as powerful as the programmer using them
04:33:19 <hpc> put say, javascript in the hands of someone with an incoherent understanding of types
04:33:31 <hpc> and you get an incoherent program
04:34:00 <Cale> hpc: A dynamic type system is essentially no type system. The types become the burden of the programmer to manage.
04:34:13 <quchen> Should I try to understand Data and Typeable? Is it something you only need in a very specialized setting?
04:34:38 <quchen> It certainly seems like one of the harder things to learn
04:34:43 <hpc> Cale: there's ways to fake parts of a type system with comments and conventions, but yeah, exactly that
04:34:57 <shachaf> Data and Typeable are not complicated.
04:34:58 <hpc> a programmer that can manage a larger burden has a better "type system" out of it
04:35:21 <Cale> quchen: You should understand Typeable but remember that you'll probably never write an instance of it yourself -- it's actually generally bad to do so (you should use deriving)
04:35:34 <shachaf> Soon enough you won't be able to.
04:35:35 <luite> and GHC 7.8 makes it impossible
04:35:39 <Cale> good!
04:35:42 <quchen> How's that?
04:35:44 <shachaf> new-typeable is the future, man.
04:35:54 <shachaf> Finally you won't have to use undefined.
04:35:55 <Rarrikins> What is new-typeable?
04:36:00 <shachaf> A GHC branch.
04:36:10 <Cale> quchen: Writing bad instances of Typeable lets you break the type system and write programs that crash
04:36:23 <arkeet> well, it's not hard to do that even without Typeable.
04:36:26 <quchen> Cale: Sounds like a typeclass for unsafeCoerce
04:36:49 <Cale> quchen: Yeah, it's basically an attempt to make unsafeCoerce into something more safe, by encoding runtime type information.
04:37:06 <shachaf> Someone should make a proof of concept for http://hackage.haskell.org/trac/ghc/ticket/7634
04:37:07 <Cale> quchen: If you only derive instances of Typeable, then everything is fine
04:37:21 <hpc> shachaf: haha
04:37:25 <hpc> i am... tempted
04:37:30 <Cale> quchen: cast :: (Typeable a, Typeable b) => a -> Maybe b
04:37:45 <shachaf> hpc: As far as I know MD5 isn't broken enough for it to be feasible.
04:38:19 <Cale> quchen: This will give you Nothing when the types a and b don't match, or rather, when their runtime representations computed by  typeOf :: (Typeable a) => a -> TypeRep  don't match.
04:38:29 <Cale> and  cast x = Just x  when they do.
04:38:36 <arkeet> shachaf: it's hard to write something with a given md5 hash.
04:38:42 <arkeet> it's not as hard to write two things with the same hash.
04:38:45 <hpc> shachaf: i think what i would do is get every safe-haskell hash
04:38:56 <Cale> (or cast x = Just (unsafeCoerce x) when the TypeReps match)
04:38:56 <quchen> Cale: So I can use that to safely cast "data Bool = True | False" to "data Yesno = Yes | No"?
04:38:57 <shachaf> arkeet: Yes. All you need is a collision.
04:38:58 <hpc> then enumerate hashes of valid identifiers until i got a single collision
04:39:06 <Cale> quchen: Nope
04:39:14 <Cale> quchen: The types actually have to be the same type
04:39:28 <mgsloan> arkeet: (responding to earlier comment about code reloading) right, but ideally it'd only need to reload the function that changed, and all of the current runtime values would still work, etc
04:39:34 <quchen> Cale: But then why would I cast? :s
04:39:39 <shachaf> quchen: Look at these slides: http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
04:39:42 <arkeet> mgsloan: that's what I mean.
04:39:49 <arkeet> doesn't erlang do this?
04:39:54 <quchen> shachaf: Ah, the SYB slides. Alright, here we go
04:39:55 <Cale> quchen: Because you're pulling something out of an existential, for example, where the type has been forgotten.
04:39:57 <mgsloan> arkeet: It only really makes sense for fairly imperative programs - as it's not like thunks are going to get rewritten to point at the new definition
04:40:02 <shachaf> quchen: https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt
04:40:05 <Cale> quchen: You can use this to implement dynamic types
04:40:07 <arkeet> of course.
04:40:13 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
04:40:18 <Cale> ^^ and this module does
04:40:25 <shachaf> arkeet: But there are specific requirements -- it's a collision in the UTF-32 encoding of a Haskell package-module-identifier string.
04:40:32 <arkeet> Dynamic is a pretty thin wrapper of Typeable.
04:40:48 <mgsloan> arkeet: Not sure if erlang does it, but C# can do it
04:41:01 <mgsloan> arkeet: But only for a very restrictive set of changes
04:41:03 <shachaf> arkeet: UTF-32 means that you have a lot of zeros. Haskell identifiers mean more zeros and a prefix you don't control.
04:41:13 <shachaf> You're very limited in what you can do.
04:41:24 <shachaf> I'd be happy if you figured it out, though!
04:42:16 <arkeet> I don't really know anything about it.
04:43:11 <hpc> shachaf: in any event, these appear to be roughly the same use-case as password hashing; i suggest a few rounds of bcrypt
04:43:47 <hpc> with difficulty increasing every ghc version
04:44:29 <cheeka> What's the editor most used by the community?
04:44:42 <Rarrikins> vim
04:44:43 <hpc> vim
04:44:48 <adimit> emacs
04:44:50 <Cale> cheeka: Probably vim or emacs
04:45:19 <cheeka> and what among emacs and vim?
04:45:27 <Rarrikins> vim
04:45:27 <adimit> ?
04:45:32 <hpc> vim
04:45:35 <adimit> emacs
04:45:40 <hpc> haha
04:45:49 <black_joe> Probably emacs, but I've been happy with Sublime Text or Kate.
04:46:04 <shachaf> cheeka: This is a question that's prone to create unhappiness and anger in a channel.
04:46:18 <cheeka> ehm, It got more confusing ;/
04:46:22 <cheeka> sorry
04:46:26 <shachaf> It's also not really on-topic. If the question is what editor you should use: It doesn't matter. Use whatever you're used to.
04:46:27 <adimit> it's a tool. use what you want. that said, both vim and emacs have great support. I was using vim until recently, I'm using emacs now for better repl integration.
04:46:35 <hpc> i do all my programming in wordpad.exe
04:46:45 <hpc> with a preprocessor that strips out the formatting with carefully designed regexes
04:47:14 <taylorgb> Could be worse, you could use openoffice calc for it
04:47:18 <cheeka> thanks shachaf, I will decide myself..... :)
04:47:45 <black_joe> The absolute worst you could go is ed, or piping cat.
04:48:15 <hpc> https://a248.e.akamai.net/camo.github.com/9c30f8474b9774e8a3623bf7210874d964631621/687474703a2f2f7777772e626c6f6763646e2e636f6d2f7777772e7061776e6174696f6e2e636f6d2f6d656469612f323030392f30362f6361742d7076632d706970652d7265736375652d32343064733036303930392e6a7067
04:48:21 <Cale> quchen: Although for some reason the library doesn't actually seem to do this, we could write  data Dynamic where ToDyn :: (Typeable a) => a -> Dynamic, and then  fromDyn (ToDyn x) a = case cast x of Nothing -> a; Just x' -> x'
04:48:32 <hpc> relevant pipe cat link
04:48:41 <black_joe> One time I was under odd circumstances and had to write an entire source file like this: #include <iostream.h>\nusing namespace std;\nint main etc, etc.
04:48:51 <Cale> Wow, I just had a lag spike that was like a full minute long or something.
04:50:18 <hpc> Cale: welcome to freenode ;)
04:58:56 <hpc> open challenge from #haskell-blah: implement an eval function and submit it as a pull request to acme-php
05:00:30 <shachaf> @ty read . System.IO.Unsafe.unsafePerformIO . System.Process.readProcess "/usr/bin/php" []
05:00:31 <lambdabot> Read c => String -> c
05:04:32 <hpc> http://hackage.haskell.org/packages/archive/plugins/1.5.3.0/doc/html/System-Eval-Haskell.html -- getting mkHsValues to be implicit seems to be the key hurdle to this problem
05:10:41 <hpaste> verma pasted “How to make this strict?” at http://hpaste.org/86232
05:11:01 <verma> I've been struggling with this :)
05:11:24 <verma> for some reason this program eventually takes up all memory and dies.
05:11:49 <verma> I am trying to make parts of it strict (as you can see), but haven't been able to figure how or where the problem is.
05:12:51 <arkeet> done any memory profiling?
05:14:00 <arkeet> the bang patterns on myMax have no effect, since you're matching on the tuple constructor anyway.
05:14:55 <int-e> verma: strictness may not be the issue; the elements of the sequence grow rather large. for starting values up to 100000, the maximum encountered intermediate value is 1570824736
05:16:14 <arkeet> not to mention that stuff like x > y and odd x will force their arguments anyway.
05:17:00 <arkeet> verma: a list is probably also not the structure you want to use.
05:17:35 <arkeet> accessing the 1570824736th element of a linked list is very slow.
05:17:49 <int-e> verma: and in general you shouldn't use a list for memoizing more than a dozen values or so unless they are /very/ expensive to compute.
05:17:51 <verma> arkeet: no I havent done memory profiling, not sure how to do it, will google
05:17:59 <arkeet> well it's not even that, I think.
05:18:02 <int-e> up to 1 million, the maximum is 56991483520
05:18:13 <arkeet> you're running out of memory because your list is just too large.
05:18:31 <verma> hmmm
05:18:35 <verma> ok
05:20:05 <verma> so if I access lets sat the 100th element of a list, it needs to allocate the 99 before it, I was hoping laziness will probably not allow that to happen.
05:21:01 <coburrito> verma: No. Laziness does not have any magic. Look at the list definition... it's a structure for elements that will be accessed in the order of the list.
05:21:27 <verma> coburrito: hmmm, makes sense
05:21:37 <klrr> if im gonna write a MUD(simple text game with multiplayer) where can i find documentation about Network module ?
05:21:50 <klrr> also is there a guide how to write a simple server?
05:22:29 <coburrito> verma: If you want faster search, consider a tree. If you just need faster access at an index, consider an an array. A hashmap is also worth considering.
05:23:34 <verma> coburrito: the memoization here, I just picked up from one of the examples, I should have thought more about it, I was expecting laziness to be some sort of magic :)
05:23:46 <arkeet> if you're using a structure that's going to have tens of billions of elements, consider rethinking your algorithm
05:24:32 <verma> arkeet: yeah, I am thinking non-list or non any kind of sequence is not going to work.
05:24:48 <coburrito> verma: I see. For memoization, I think a map with constant-time access of outputs given inputs makes sense.
05:24:49 <arkeet> maybe only remember lengths up to some fixed n.
05:24:51 <int-e> verma: my solution to that problem just memoized lengths for n up to 1000000, in an array. It's reasonably fast (though ridiculously slow compared to C)
05:24:52 <verma> I mean a list based or sequence based is not going to work
05:25:21 <arkeet> arrays are fine.
05:25:43 <arkeet> an array with 1000000 numbers doesn't take up a lot of space
05:26:36 <verma> arkeet: hmmm, ok, but would it allocate all 1000000 elements if I access the 1000000th element?
05:26:39 <arkeet> int-e: what is faster about the C version?
05:26:46 <arkeet> verma: I did say array, not list.
05:27:20 <ninzine> klrr: maybe you can find something useful here http://mudcode.cryptotoad.com/
05:27:35 <hpc> ALL GLORY TO THE CRYPTOTOAD
05:27:50 <verma> arkeet: got it, sorry about that.  Just that when I do haskell parts of my brain start to shutdown for some reason.
05:27:51 <arkeet> ninzine: doesn't look much like haskell.
05:27:53 <verma> :)
05:28:22 <ninzine> true! thought i was in another channel, hah
05:28:35 <arkeet> klrr: there's documentation for the various modules on hackage
05:28:52 <arkeet> @hackage network
05:28:53 <lambdabot> http://hackage.haskell.org/package/network
05:29:04 <arkeet> although you might want to consider something a bit higher-level?
05:29:14 <int-e> arkeet: easy, we can encode "unevaluated" and "the computed value is n" in a single word, using a flat array.
05:29:49 <int-e> arkeet: besides this code runs inside the cache (is not memory bound) so all the extra jumps and register loads really really hurt.
05:30:19 <int-e> arkeet: and the code is not simple enough for ghc to produce nice loops. (hmm. I should try the llvm backend.)
05:30:30 <arkeet> k
05:31:58 * hackagebot acme-php 0.0.2 - The flexibility of Haskell and the safety of PHP  http://hackage.haskell.org/package/acme-php-0.0.2 (JoeQuinn)
05:34:59 <int-e> arkeet: actually I also have an ST monad / STUArray version of the thing that appears to be within a factor of 3 of C (at runtimes of 0.017s vs. 0.040s, who's gonna be sure? :-) I'm too lazy to wrap it in a loop.)
05:35:51 <arkeet> that sounds better than "ridiculously slow"
05:36:30 <deech> Hi all, What are ways of not creating deeply nested datastructures? Eg. A friend of mine was structuring data using datatypes essentially as objects " data Receipt = Receipt String; data Price = Price Int; data SalesInfo = Receipt Price"
05:37:05 <int-e> arkeet: but the "proper" haskell versions take 7 seconds (Array) and more (Data.MemoTrie).
05:37:19 <deech> And she, a beginner, was asking about updating and I'm trying not to tell her about lens yet.
05:37:56 <int-e> arkeet: at least as I wrote them. :)
05:38:06 <merijn> deech: Maybe try data-lens, it's not as feature rich, but the types are much simpler than lens
05:38:44 <merijn> deech: Or, alternatively "don't do that, then"
05:38:55 <Ghoul_> Where does <|> come from
05:39:00 <Ghoul_> :t <|>
05:39:02 <lambdabot> parse error on input `<|>'
05:39:05 <deech> merijn: So that's what I'm asking, what's the alternative?
05:40:14 <merijn> deech: Not nesting everything ina  billion datatypes
05:40:37 <deech> merijn: Ok, but how do you preserve encapsulation?
05:40:38 <int-e> :t (Text.Parsec.<|>)
05:40:39 <lambdabot> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
05:40:47 <merijn> deech: You don't
05:41:00 <merijn> deech: It's one or the other, I think
05:41:03 <int-e> :t (Control.Applicative.<|>)
05:41:05 <lambdabot> Alternative f => f a -> f a -> f a
05:41:52 <deech> merijn: Thanks!
05:52:46 <int-e> arkeet: Hehe, it's actually funny to look at this old code. It actually contains a check to ensure that the bottom half of the table (entries 1..499999) are rarely used; I must have optimized it for a machine with 1 MB cache :)
05:53:11 <arkeet> eh
05:54:14 <int-e> arkeet: http://hpaste.org/86233 :)
05:54:39 <arkeet> it's too late for my brain to understand that right now.
05:55:27 <int-e> never mind then. I just felt bad talking about code you couldn't see.
05:56:20 <arkeet> heh, so you divide by 4 when possible.
05:58:33 <arkeet> but yeah, looks pretty straightforward.
05:59:44 <SpinGame> http://www.spingame.ru/ New Invest Project with fast money!!!
05:59:50 <Taneb> @where ops
05:59:51 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
05:59:51 <lambdabot> xerox
06:00:07 --- mode: ChanServ set +o Igloo
06:00:12 <SpinGame> http://www.spingame.ru/ New Invest Project with fast money!!!
06:01:25 <Taneb> Igloo++
06:01:34 <arkeet> haha
06:01:45 <arkeet> @karma Igloo
06:01:46 <lambdabot> Igloo has a karma of 3
06:02:47 <int-e> arkeet: but the thing that I mentioned manifests itself in that I don't divide by 4 if the value is between 1000000 and 2000000, even if it is divisible by 4.
06:03:11 <int-e> arkeet: so that the result will be at least 500k :)
06:03:16 <arkeet> oh, I see.
06:03:59 <arkeet> is that actually faster than just never dividing by 4?
06:04:44 <arkeet> hold on.
06:04:47 <arkeet> you're clever.
06:05:09 <arkeet> the otherwise case works both when it's odd and when it's singly divisible by 2.
06:05:36 <arkeet> right?
06:05:37 <shachaf> @where+ ops arjanb bos byorgey Cale conal copumpkin davidhouse dcoutts dibblego dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:05:38 <lambdabot> Done.
06:06:04 <shachaf> preflex: seen davidhouse
06:06:12 <shachaf> Oh.
06:06:15 <int-e> arkeet: right
06:06:17 <shachaf> Anyway, it's dmhouse, isn't it?
06:06:28 <int-e> arkeet: by ... uhm ... magic :)
06:06:39 <arkeet> no, I understand why it works.
06:06:51 <arkeet> still clever.
06:06:51 <int-e> arkeet: it's easy enough to verify.
06:06:57 <arkeet> indeed.
06:09:23 <linduxed> omg
06:09:37 <linduxed> i just read the part in learnyouahaskell about Ordering being a monoid
06:09:39 <linduxed> fuck me
06:09:42 <linduxed> my mind is blown
06:09:44 <arkeet> haha
06:09:53 <linduxed> lengthCompare x y = (length x `compare` length y) `mappend` (x `compare` y)
06:09:58 <linduxed> that's fucking crazy
06:10:02 <linduxed> it's so beautiful
06:10:09 <arkeet> = compare (length x,x) (length y,y)
06:10:34 <int-e> @type comparing (length &&& id)
06:10:35 <lambdabot> Ord a => [a] -> [a] -> Ordering
06:10:49 <arkeet> :)
06:11:10 <Taneb> :t compare `on` length &&& id
06:11:11 <lambdabot> Ord a => [a] -> [a] -> Ordering
06:11:18 <arkeet> comparing = (compare `on`)
06:12:08 <arkeet> ah, I didn't know `on` had such low precedence.
06:12:30 <Taneb> Yeah, it's 0
06:12:32 <arkeet> infixl 0, apparently.
06:12:33 <arkeet> yeah
06:12:35 <Taneb> :t (0$0`on`)
06:12:36 <lambdabot>     The operator `on' [infixl 0] of a section
06:12:36 <lambdabot>         must have lower precedence than that of the operand,
06:12:36 <lambdabot>           namely `$' [infixr 0]
06:38:00 <arkeet> 7.6.3 is out?
06:41:15 <klrr> are there any guides on a basic server?
06:41:32 <klrr> i want to write a simple server but i dont know how, currently trying to understand the network module
06:42:03 <klrr> this is what i got so far
06:42:06 <klrr> http://hpaste.org/86234
06:42:14 <klrr> is it correct?
06:44:29 <hpaste> Xaratas pasted “filter efficiency?” at http://hpaste.org/86235
06:45:05 <Xaratas> Hi, are there things to get this fillter faster?
06:49:41 <klrr> are there a simple example of a server and a client?
06:57:45 <Fuco> how can I reverse 'compare'? I want to sort in descending order
06:58:08 <qnikst> flip compare?
06:58:26 <Fuco> fair enough
06:59:23 <Taneb> :t Down
06:59:24 <lambdabot> Not in scope: data constructor `Down'
06:59:34 <Taneb> Data.Ord.Down, Fuco
07:01:17 <klrr> what does this mean? "*** Exception: bind: permission denied (Permission denied)"
07:04:20 <Taneb> klrr: it looks like you're not in GHCi?
07:04:32 <Xaratas> kirr: you want to use a port < 1024?
07:04:38 <Taneb> No, I'm wrong
07:10:01 <Fuuzetsu> What was the GSOC channel for Haskell again? It seems that I forgot to add it to autojoinâ¦
07:20:43 <mr-> Fuuzetsu: #haskell-gsoc
07:23:42 <Fuuzetsu> Could have sworn I tried that oneâ¦ Thanks.
08:03:56 <ab9rf> someone's encoding is unhappy
08:04:02 <mornfall> Can I tell cabal to not look at *any* existing ghc-pkg databases?
08:04:39 <mornfall> Hm. Probably overriding environment. *tries*
08:07:35 <Mathnerd626> why isn't -funbox-strict-fields the GHC default? It seems like every optimized library turns it on, and I don't see how it could regress performance by much
08:10:54 <Mathnerd626> (default for -O or -O2, that is)
08:11:41 <dolio> There are certain situations for which it's pretty bad.
08:14:58 <dolio> Like, every time you project an unpacked component into something that isn't unpacked, you have to do a heap allocation.
08:19:06 <dolio> So you can, in certain cases, end up doing more allocation with unpacked fields than you would by not unpacking the fields.
08:24:53 <Mathnerd626> but I would expect going from strict to lazy would be relatively rare, usually your code is either fully lazy or fully strict
08:25:16 <Mathnerd626> s/would be/to be/
08:27:51 <Mathnerd626> Int is lazy, Int# is strict, and if someone's using Int# I don't see them returning Int that often...
08:29:28 <Mathnerd626> the question is whether without -funbox-strict-fields, there's any point in making the constructors strict
08:29:44 <geekosaur> how about any time you try to put someone's (unbeknownst to you) strict thing into a collection?
08:30:27 <Mathnerd626> (unbeknownst to you) <- aren't all Haskell programmers smart enough to read the documentation?
08:31:09 <k0ral> could someone be so kind as to take some time to explain how the build chain works for gtk2hs (I'm especially interested in webkit package actually but I guess it's the same mess) ?
08:31:11 <Mathnerd626> actually, that is interesting - {-# UNPACK #-} pragmas don't show up in haddock, but ! annotations do
08:31:33 <Mathnerd626> I guess my question is why they aren't synonymous
08:32:14 <Mathnerd626> is there any reason to go for strict fields that *aren't* unboxed?
08:32:40 <elliott> to avoid repacking overhead
08:32:50 <elliott> there is a flag to unbox all strict fields
08:33:00 <parcs> Mathnerd626: unboxing non primitive fields is usually a bad idea
08:33:34 <parcs> also you can't unbox polymorphic fields
08:34:04 <Mathnerd626> elliott: yes, I started this discussion by asking why it wasn't turned on by default
08:34:11 <jmcarthur> parcs: wait, why is unboxing nonprimitives a bad idea?
08:34:28 <elliott> because you have to rebox them if you want to pass them to a function that wants a boxed one
08:34:33 <jmcarthur> oh, yeah
08:34:43 <elliott> whereas stuff like arithmetic can be done directly on Int#
08:35:56 <Mathnerd626> but why would you mark something strict if you don't want it unboxed? this is the point I've been stuck on
08:36:19 <dolio> Because you want to make sure it's evaluated.
08:36:29 <Mathnerd626> but that's why you unbox it...
08:36:32 <dolio> No.
08:36:37 <dolio> That's why you mark it as strict.
08:37:35 <dolio> You unpack to avoid a little bit of overhead around the thing contained inside whatever you're unpacking.
08:38:36 <Mathnerd626> the manual says " In fact, it is possible that -funbox-strict-fields may worsen performance even with -O, but this is unlikely (let us know if it happens to you)."
08:38:44 <Mathnerd626> are there any bug reports?
08:41:32 <parcs> also if you unpack non-primitive fields you are increasing the size of the record and consequently the amount of bytes allocated each time you update the record
08:42:06 <dolio> If I have 'data Foo = Foo !Int ...', then I'm saying I want to make sure that Int is evaluated, but it's still in a separate heap allocation. So if eight different places in the code pull out the int, and store it in something that can't unpack the int (like, something parametric), that same one heap allocated Int gets used.
08:42:25 <dolio> If I unpack, then eight separate heap allocated Ints get created for the eight situations.
08:43:13 <dolio> Which is probably a net loss if that's about all I do with the things.
08:47:19 * hackagebot cassandra-thrift 0.8.5.1 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.8.5.1 (OzgunAtaman)
08:47:41 <Peaker> In graphics-drawingcombinators, there's a Sprite which is implemented via an OpenGL texture resource that holds the image data.  I wanted to write a program that generates and destroys lots of Sprites, so I had to patch drawingcombinators to release the GL resource when the Sprite is finalized by GC
08:48:02 <Peaker> this is typically considered bad practice, right? Relying on GC to release resources such as video memory
08:48:36 <int-e> yes.
08:48:40 <Peaker> Though having explicit Sprite destruction is going to add unsafety :(
08:49:30 <qnikst> a place for resourcet/regions?
08:50:03 <Peaker> the nice thing about graphics-drawingcombinators is that it is mostly a pure interface, not monadic
08:50:44 <Peaker> my sprites generation/destruction is not nested/lifo -- so I cannot bracket them, so I wouldn't get any safety :(
08:51:05 <Peaker> GC gives the safety I need -- but won't be invoked when GL resources are missing
08:51:43 <klrr> TCP or UDP for a game?
08:52:01 <Sculptor> haskell game?
08:52:05 <Peaker> klrr, if there's any importance of low latency, UDP
08:52:05 <jmcarthur> Peaker: do you have a wish list for drawingcombinators? a few of us in #haskell-game are working on a new library inspired by it
08:52:43 <jmcarthur> klrr: if you don't *know* you need UDP, you probably should just use TCP
08:52:44 <Eduard_Munteanu> Or SCTP... worth thinking about.
08:53:09 <Eduard_Munteanu> No, you usually need UDP for multiplayer stuff, TCP kinda sucks badly.
08:53:27 <Eduard_Munteanu> (in some ways UDP is even easier to use)
08:54:51 <jmcarthur> UDP is easy to use when you can fit your entire shared game state into one packet
08:54:58 <jmcarthur> in any other case it's tougher
08:56:38 <hpc> i could make a UDP joke, but you probably wouldn't get it
08:56:50 <sirspazzolot> would a newbie benefit from anything in the gentoo-haskell overlay?
08:56:51 <int-e> hpc: *groans*
08:56:53 <sirspazzolot> hpc HA.
08:56:54 <Eduard_Munteanu> You hipster...
08:57:01 <jmcarthur> that was awful
08:57:31 <Eduard_Munteanu> But yeah, I didn't get it. :P
08:57:59 <geekosaur> :p
08:58:12 <int-e> luckily IRC uses TCP.
08:58:31 <parcs> UDP is often used in fast paced games (shooters and twitchy stuff), and TCP is used everywhere else i think
08:58:44 <Eduard_Munteanu> Yes, you want to make damn sure you get those join/part messages when Freenode is DDoSed. :P
08:59:00 <sirspazzolot> have you guys heard about mptcp?
08:59:03 <Eduard_Munteanu> parcs: UDP is for anything realtime basically
08:59:20 <Eduard_Munteanu> Sure, if you have a turn-based strategy, then yeah, TCP is nice.
08:59:24 <hpc> those games also tend to have their own stitching code for UDP anyway
08:59:40 <Eduard_Munteanu> sirspazzolot: yes, rings a bell, I should remind myself
09:00:25 <Eduard_Munteanu> Um, not sure that fits here.
09:00:37 <parcs> Eduard_Munteanu: well, some MMOs use TCP, including WoW
09:00:38 <Eduard_Munteanu> I guess that's for multihomed hosts?
09:00:49 <Eduard_Munteanu> parcs: wow, that sucks :P
09:01:01 <Eduard_Munteanu> I've only played on non-official servers though.
09:01:31 <Eduard_Munteanu> SCTP is probably a better idea than any of them, if you want to tradeoff things.
09:03:38 <Peaker> jmcarthur, you don't necessarily have to send the entire game state.. generally game network engines only have to send user input which is very low rate
09:06:18 <monochrom> oh w00t, GHC 7.6.3
09:06:47 <jmcarthur> Peaker: except if you do that then you have to account for failure of transmission
09:07:02 <jmcarthur> Peaker: if you just send the entire game state then you don't have to think about it. failure just means you stutter
09:07:30 <Eduard_Munteanu> jmcarthur: um, not really, the player will readily rehit the buttons if the action is not performed
09:07:56 <Eduard_Munteanu> They will do so even when using TCP, if they run out of patience.
09:08:13 <Eduard_Munteanu> Which means you'll have to drop packets anyway, I think. :)
09:08:24 <jmcarthur> Eduard_Munteanu: whether what you are saying is relevant is highly game dependent
09:09:09 <Eduard_Munteanu> Possibly, yeah.
09:09:37 <jmcarthur> Eduard_Munteanu: for example, the old quake games sent the entire game state. if player input was lost, the player probably would just die
09:09:56 <jmcarthur> Eduard_Munteanu: err, that last sentence was what would be more common if it *didn't* work that way
09:11:17 <jmcarthur> Eduard_Munteanu: anyway, my point is that if you care about latency then the game outcome *is* highly dependent on timely player input, so you can't just wait for the player to input it again if you fail to transmit it because you didn't properly plan it out
09:11:42 <Eduard_Munteanu> Hmm...
09:11:44 <jmcarthur> Eduard_Munteanu: and if latency is *not* such a big deal then TCP is just easier and more reliable
09:12:13 <jmcarthur> also, TCP doesn't necessarily mean you get terrible latency
09:12:30 <Eduard_Munteanu> I sort of disagree on the former. If you already missed a few packets, the player was likely confused too and queued more stuff to be done.
09:12:33 <jmcarthur> UDP can do much better of course, but it's usually not observable except in degenerate circumstances
09:13:11 <jmcarthur> when you fail to receive a state update the game typically just predicts the next frame and then adjusts the next time the state is received
09:13:16 <Eduard_Munteanu> Retransmission is only good if it can happen fast enough.
09:13:19 <int-e> and UDP doesn't mean you get good latency. for some time my provider managed to delay icmp echorequests by 300 seconds and more. (it did that to all packets.)
09:13:20 <jmcarthur> right
09:14:33 <int-e> I have no idea how they did that. (umts; maybe they put them into an SMS processing queue ;-) )
09:15:11 <geekosaur> many routers automatically delay icmp / shunt it to a slow track
09:15:24 <Eduard_Munteanu> That's crap.
09:15:40 <geekosaur> (also note that icmp is not udp...)
09:15:55 <int-e> geekosaur: as I said, it did that to all packets.
09:15:56 <Eduard_Munteanu> Stupid too, since you can DoS someone with any other protocol.
09:15:59 <klrr> ?src withSocketDo
09:15:59 <lambdabot> Source not found. stty: unknown mode: doofus
09:16:06 <klrr> what does withSocketDo ?
09:16:06 <int-e> geekosaur: icmp is just the most convenient for measuring the delays ;)
09:16:27 <geekosaur> klrr, on some Windows platforms it's needed to initialize WinSockets
09:16:45 <klrr> geekosaur: so it's not needed on Unix-like OS:es?
09:16:53 <elliott> you should use it everywhere
09:16:53 <geekosaur> for portability we "require" it everywhere, but on Unix you can get by without it
09:17:06 <klrr> okey
09:17:15 <klrr> so i dont need to know what it does as long as i use it
09:17:16 * elliott wonders why GHC doesn't just always initialised sockets on WIndows
09:17:16 <klrr> ?
09:17:25 <elliott> klrr: yes, just change main = do ... to main = withSocketsDo $ do ...
09:17:27 <geekosaur> yes
09:17:31 <klrr> okey thanks!
09:17:43 <klrr> im writing a multiplayer game, text-based :)
09:21:56 <finnrobi> can I install the documentation base using cabal somehow?
09:22:19 * hackagebot free-functors 0.4 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.4 (SjoerdVisscher)
09:23:26 <elliott> finnrobi: you can turn on the documentation setting in your cabal config
09:23:31 <elliott> then newly-installed packages will have docs
09:24:16 <klrr> are there any examples or documentation how to make a simple server using Network module? i only found one using Network.Socket module
09:26:04 <finnrobi> elliott: okay, thanks
09:30:30 <Eduard_Munteanu> klrr: there was some stuff on the mailing lists, if you Google.
09:39:40 <klrr> Eduard_Munteanu: thanks!
09:47:34 <klrr> i get some strange type errors, anyone got an idea what's wrong? http://hpaste.org/86254 (code and error is in the paste)
09:49:44 <klrr> never mind i found the problem :)
09:50:21 <zebr> hey all. if i have some function (f >=> g >=> h :: a -> Set a), if i were to write that in maths notation for a paper, would each >=> be written ~ $\circ_\text{Set}$, and can i call this a "Kleisli composition over sets"? or am i misunderstanding something? (i'm not a mathematician. :p)
09:53:13 <monoidal> zebr: Kleisli composition associated to the powerset monad?
09:54:23 <zebr> monoidal: hmm, why is it the powerset monad, because join joins sets of sets?
09:54:45 <monoidal> zebr: actually powerset (denoted as P(X)) might be infinite, I don't know about your Set
09:55:02 <monoidal> zebr: but otherwise that's how I would call it
09:56:01 <monoidal> zebr: or "associated to the set monad"?
09:58:00 <Eduard_Munteanu> return = singleton   I suspect
09:58:13 <Eduard_Munteanu> Doesn't look like a powerset.
09:59:00 <monoidal> X -> P(X), return x = {x} and join = union is the powerset monad
09:59:27 <Eduard_Munteanu> Hmm...
10:00:00 <klrr> should i use withSocketsDo with clients too, or only server?
10:00:25 <Eduard_Munteanu> klrr: yes, anything... the docs say you should use it.\
10:01:02 <klrr> Eduard_Munteanu: okey thanks!
10:01:45 <zebr> it is true that in my thing return x = {x} and join = union. so *is* that the 'powerset monad', then?
10:01:47 <monoidal> there are some variants of the powerset monad; for example, Haskell's one is more like P_fin(X); in topology compact subsets can be made a monad with Vietoris topology
10:02:08 <zebr> also the correct terminology is "Kleine composition associated to the powerset monad"?
10:02:26 <monoidal> zebr: For naturals, does your functor lead to all subsets of naturals, or only finite ones?
10:02:33 <Eduard_Munteanu> Kleisli composition.
10:02:48 <zebr> oops. Kleisli, sorry. x.x
10:02:50 <Eduard_Munteanu> Erm...
10:03:00 <Eduard_Munteanu> Composition of Kleisli arrows, rather.
10:03:04 <zebr> monoidal: the resulting set may be infinite
10:03:15 <Eduard_Munteanu> (for a monad ..., I think)
10:03:16 <monoidal> zebr: I'd call it powerset, then
10:03:21 <zebr> monoidal: ok, thanks
10:03:34 <monoidal> not sure whether it's "associated", "for", "over"
10:03:46 <monoidal> we surely say "Kleisli category of a monad"
10:04:48 <zebr> there doesn't happen to be a special name for kleisli composition 'over'(?) the powerset monad? i'd like to keep category theory to a minimum while still having an elegant definition, if possible.
10:05:48 <Eduard_Munteanu> zebr: I guess you could just define the composition of monadic functions and refer to that, namely (<=<)
10:06:12 * zebr nods
10:06:13 <Eduard_Munteanu> zebr: oh, mind f >=> g >=> h is "reverse" composition
10:06:22 <zebr> yeah, just realised i might have to switch them around
10:06:42 <zebr> that way is just more natural in the context. is there a nice syntax for 'reverse' composition, or should i give that up?
10:07:08 <monoidal> zebr: you might say that functions A -> P(B) and B -> P(C) "induce" a function A -> P(C) or something like that, if you want to avoid category-theoretic terminology
10:07:10 <Eduard_Munteanu> zebr: f;g;h is the equivalent for normal functions, usually
10:07:23 <Eduard_Munteanu> (that is, h o g o f)
10:07:42 <zebr> ahh, that works, thanks
10:09:47 <eyebloom> for some reason the first declaration here causes a parse error, the second does not, I'm just trying to figure out if there is something I'm missing? http://hpaste.org/86256
10:10:17 <klrr> i need some help, how do i make so that the server functions prints some string when a client is connecting so i can see if it all works? http://hpaste.org/86257
10:11:23 <companion_square> yaaaa[A
10:11:32 <companion_square> sorry
10:15:46 <int-e> klrr: you're not sending a newline in  sendMessage h "hello"  so you need to  hFlush h  ... I think
10:16:26 <int-e> klrr: a complete example would be better :)
10:22:20 * hackagebot hashable 1.2.0.6 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.6 (BryanOSullivan)
10:32:21 * hackagebot continue 0.2.0 - Monads with suspension and arbitrary-spot reentry  http://hackage.haskell.org/package/continue-0.2.0 (ErtugrulSoeylemez)
10:57:21 * hackagebot algebraic-classes 0.2.1 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.2.1 (SjoerdVisscher)
11:04:22 <xplat> are the arrow types in hxt all actually Kleisli arrows to begin with?
11:05:50 <copumpkin> xplat: at first glance, it appears tso
11:05:50 <monochrom> yes
11:05:53 <Xaratas> are there ways to improve the excecution speed of this filter function? http://hpaste.org/86235
11:05:54 <copumpkin> general
11:06:05 <copumpkin> agggh1
11:06:16 <copumpkin> well, I can't parse that lump of text, but I see !! in it
11:06:33 <copumpkin> and !! is a big no-no, especially in a loop
11:06:55 <monochrom> I have often preferred a monadic hxt instead
11:08:08 <monochrom> I admit that of 100 lines of my hxt-using code, only one line really uses ArrowApply. but the monadic style is still easier to use than the arrow style overall.
11:08:24 <monochrom> well, for this application
11:08:42 <xplat> yeah.  well, then my first act in lensifying hxt will be to monadify it, i think
11:10:22 <xplat> i was kind of disappointed, i didn't think anyone would do a library all in arrow form just because they liked arrows better
11:10:46 <Peaker> I don't really think that Arrow in its Control.Arrow form is ever useful..  If it is generalized (no "arr", ideally general Pair type instead of tuples, and a bunch of extra replacement methods to make for missing "arr") it could be useful
11:10:59 <xplat> i thought it would, like, actually use non-kleisli arrows or something
11:11:31 <monochrom> hxt was an experiment in "what if we go arrow?"
11:11:46 <Peaker> I found hxt to be annoying to use, and ended up using the light "xml" one
11:14:20 <Saizan> the other confusing thing are the huge typeclasses filled with default implementations
11:14:49 <monochrom> I think it went like this. at the beginning, hxt and haxml were both full of "Tree -> [Tree]". now this is clearly Kleisli, and you could just monadify it. but it inspired them to ask "what if we go arrow?". a master thesis was created to arrowize hxt.
11:15:03 <copumpkin> :/
11:15:19 <copumpkin> I kind of resent Arrows, tbh :P
11:15:37 <xplat> a brave experiment that taught us a lot of useful things about Arrows, like 'never ever use them'
11:15:51 <copumpkin> those generalized arrows I can buy
11:16:08 <copumpkin> especially how he talks about how the various flavors give you languages with various properties
11:16:54 <xplat> yeah
11:17:12 <xplat> i think if there are real uses for conventional arrows, they probably have yet to be discovered
11:17:14 <monochrom> now, I want to say, it made sense to them, since for both hxt and haxml, in those days, still at the "Tree -> [Tree]" stage, they already pointfree it left right and centre. therefore, arrow was the natural choice.
11:17:22 <xplat> and will come from the 'promonad' description
11:17:55 <Saizan> uh, i haven't seen promonad yet
11:18:06 <copumpkin> well, I think they didn't know about Applicative at the time
11:18:13 <copumpkin> so in some sense I think they were valuable back then
11:18:14 <monochrom> I think arrow makes a lot of sense for FRP
11:18:18 <xplat> but but >=>
11:18:31 <monochrom> Applicative is too restricted
11:18:36 <monochrom> err, restrictive
11:18:58 <xplat> Saizan: i wish i could remember the reference of the paper, i found it around the time of either the hac boston or hac phi i was at
11:19:26 <xplat> monochrom: what do you do a lot of that you can't do with Applicative?
11:20:10 <monochrom> Applicative cannot chain up f::T->[T] and g::T->[T]. you need at least Arrow.
11:22:43 <Peaker> monochrom, you can chain with Category+Applicative, which is of the same power as Arrow
11:23:28 <carter> acfoltzer i may have very concrete motivations for playing with that concurrency machinery / getting it working this summer
11:23:31 <xplat> it was conencted somehow to luis barbosa's theory of componentized software, iirc
11:23:48 <monochrom> in short, <$> and <*> does not let you "feed the output port of an action to the input port of an action". Arrow lets you do that with a restriction. Monad lets you do that with no restriction.
11:24:07 <monochrom> see Wadler's http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms , completely nails it.
11:24:17 <monochrom> ("idiom" = "applicative")
11:25:21 <Saizan> i think there's some argument in cached computations (like build systems and some FRP) where you can't use a monad because you lose too much control but you can't stick to applicative either because the side effects aren't statically determined
11:25:35 <Saizan> but it's been a while
11:26:24 <Peaker> I'l trying to remember the demo of (Category,Applicative)<=>Arrow...
11:26:25 <Saizan> (not that Arrow is the best fit either)
11:27:01 <Peaker> You can't actually instantiate the Arrow class because there's no forall in a class context
11:27:13 <Peaker> but you can write (***) and arr which cover the full arrow functionality
11:27:31 <monochrom> that argument is right. "the effects aren't statically determined" = the second action needs to know the "output" of the first action
11:28:07 <Saizan> yeah, i was more wondering if you really need more control than Monad offers
11:30:16 <xplat> http://takeichi.ipl-lab.org/~asada/papers/arrStrMnd.pdf http://www-mmm.is.s.u-tokyo.ac.jp/~ichiro/papers/fromComptoComp.pdf
11:30:20 <xplat> Saizan: there you go
11:31:18 <Peaker> Solving the cat,app=>arr exercise is always a nice puzzle :)
11:32:06 <Saizan> xplat: thanks
11:32:50 <Taslem> Are there any tools which can verify whether an instance of a class like Monad or Functor obeys the laws?
11:36:28 <Saizan> Taslem: maybe that refinement types framework which uses Z3
11:36:45 * Saizan doesn't remember the name
11:41:30 <monochrom> Idris?
11:43:57 <hiptobecubic> Taslem, quickcheck has the laws as predefined tests
11:43:59 <hpaste> Peaker pasted “Category,Arrow<=>Category,Applicative” at http://hpaste.org/86260
11:44:00 <hiptobecubic> i think...
11:44:27 <Peaker> monochrom, ^^ you can replace arrow constraints with applicative constraints (for each input type that appears)
11:44:38 <Peaker> (and Category constraints)
11:53:25 <luminous> when learning haskell, how do you deal with the maze / abundance of details like: <$> being the infix version of fmap? as a newb, learning the details of fmap and how to use it properly is great, but we generally learn best by looking at others' code and figuring out something we want to do - but then (as a newb) you're staring at all these funky shortened expressions
11:53:58 <Eelis> luminous: you look up their definitions :)
11:53:59 <luminous> which, I like the idea of :) but again - what are some ways to shorten the learning curve or offload the weight alittle?
11:54:01 <hiptobecubic> luminous, practice :)
11:54:45 <merijn> luminous: Personally I think one of the problems many newbies encounter is that once you get the hang of the language you *still* have to learn all the commonly used libraries and operators. It takes some effort, the best tip is hoogle + ghci and experimenting
11:54:52 <luminous> sure, accepting that haskell is more difficult to learn is one way, but I'm also looking to feel somewhat functional (no pun intended)
11:55:11 <merijn> luminous: Many of the more abstract functions (monad-loops, <$>, etc.) you can know what they do from just looking at the type
11:55:15 <luminous> I have not used hoogle, I will need to add that..
11:55:24 <ab9rf> hoogle is very useful
11:55:26 <hiptobecubic> luminous, there aren't that many that matter really. just >> << !! >>= =<< <*> <* *> <$> <> /= ! $ . and #  :)  just don't look at lenses
11:55:27 <jamil_1> related question: What are the topic one should know to be proficient
11:55:28 <merijn> luminous: Oh, hoogle is a lifesaver!
11:55:33 <ab9rf> plus it encourages you to think about things in terms of types
11:55:38 <merijn> luminous: I couldn't live without it!
11:55:44 <neutrino> luminous: you ask Cale
11:55:49 <hiptobecubic> merijn, indeed.  also hayoo
11:55:56 <ab9rf> you go from "what am i trying to do" to "what's the type of what i'm trying to do" and then hoogle finds it for you
11:56:11 <merijn> luminous: Also, like I said the type of <$> is pretty self-descriptive when you get comfortable dealing with types
11:56:14 <merijn> :t (<$>)
11:56:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:56:21 <luminous> oh wow, yea, hoogle ftw
11:56:33 <neutrino> :t (<*>)
11:56:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:56:39 <neutrino> in case you didn't know
11:56:40 <luminous> neutrino: cale?
11:56:48 <merijn> aww...I was gonna use <*> as hoogle example...
11:56:53 <luminous> hayoo, hah
11:56:54 <merijn> luminous: He's a regular here
11:57:00 <hiptobecubic> hayoo is down :(
11:57:08 <merijn> luminous: Also, just asking here works wonders often too :p
11:57:10 <neutrino> luminous: Cale is a bot that serves automatically personalized tutorials on haskell usage. sometimes it passes the turing test.
11:57:16 <luminous> merijn: :)
11:57:16 <ab9rf> hehe
11:57:19 <luminous> ah ok
11:57:41 <neutrino> j/k Cale is a smart guy
11:57:44 <neutrino> and really nice
11:57:46 <luminous> neutrino: hah! yea, I am looking forward to working with haskell
11:57:49 <neutrino> taught me a lot too and everyone
11:58:00 <hiptobecubic> indeed
11:58:10 <hiptobecubic> Plus it's delicious in salad
11:58:12 <merijn> Similarly dons is a bot that serves automatically personalised performance upgrades in haskell. But recently someone patched him wrong and now he only takes pictures of sunrises/-sets :p
11:58:35 <neutrino> cale in salad?
11:58:45 <hiptobecubic> Well, the german version.
11:58:48 <hiptobecubic> Kale
11:58:49 <neutrino> merijn: yes, that's a waste
11:59:02 <merijn> I'm still awaiting Cale's categories as call of duty analogy...
11:59:15 <merijn> or was it moh? I forget the quote...
11:59:26 <neutrino> there was a gaming quote?
11:59:40 <merijn> @quote analogy.to.call
11:59:40 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
12:00:05 <neutrino> oh.
12:00:10 <luminous> ahah
12:00:13 <neutrino> i guess that makes sense
12:01:03 <ab9rf> kale is insanely green
12:01:24 <merijn> luminous: If you're just starting out trying to write your first real programs, check out the monad-loops package. It's a good library to be aware of, half my mainloops end up already existing :p
12:01:38 <luminous> will do
12:01:46 <hiptobecubic> that's new to me
12:01:54 * hiptobecubic hoogles...
12:02:11 <merijn> luminous: Also, it doesn't hurt to start just writing very simple stuff using fmap and only slowly start using stuff like <$> as you memorise it
12:02:18 <merijn> hiptobecubic: How can you not know monad-loops?!?
12:02:26 <luminous> yea, I started trying to go down the "use haskell for web dev" and I think I'm back at "ok, let's do some silly hello world"
12:02:34 <hiptobecubic> merijn, the things that I don't know would blow your mind.
12:03:05 <hiptobecubic> luminous, hakyll is pretty straightforward i thought
12:03:22 <merijn> snap/happstack would also be good, but slightly more advanced
12:03:30 <luminous> merijn: I had been thinking less about my use, and more about how to deal with all the mapping between those details and all the others you try to pick up as a newb
12:03:45 <hiptobecubic> Can't speak for the dynamic frameworks, snap and ...er... ye...?
12:03:47 <merijn> Yesod is yet slightly more advanced (in the same way that the Gentle Introduction to Haskell is gentle... :p)
12:03:47 <hiptobecubic> yesod
12:04:05 <luminous> yea, I started with snap, then scotty a little, and then yesod
12:04:08 <hiptobecubic> Yesod is just so magical
12:04:17 <hiptobecubic> for better or worse
12:04:18 <merijn> luminous: Like I said, just keep hoogling/using :t in ghci until it sticks :p
12:04:27 <luminous> merijn: yea, I am with you on that
12:04:33 <merijn> luminous: Hell, even now I frequently use ghci to check the types of stuff
12:04:47 <merijn> remembering everything by heart is for suckers, that's what the type checker is for :p
12:04:58 <luminous> I've been using python to do simple reworking text/files/etc, so I'll likely try to apply haskell there for a while instead
12:05:06 <luminous> Ineed use-cases to motivate me..
12:05:23 <merijn> Oh, let me give one more nice tip :p
12:05:25 <luminous> I like yesod a lot, but have not wrapped my head around it enough, and I'm finding that it lacks the ReST stuff I want to see
12:05:26 <dublisk> what is the purpose of the 'let' keyword?
12:05:36 <luminous> let this be that?
12:05:43 <merijn> :t (>>=) `asAppliedTo` (Just 3) -- asAppliedTo is an awesome help!
12:05:44 <lambdabot> Num a => Maybe a -> (a -> Maybe b) -> Maybe b
12:06:05 <Cale> luminous: Did you have questions? :)
12:06:10 <merijn> dublisk: To start a new lexical scope without needing a function
12:06:24 <luminous> doyou like kale?
12:06:34 <dublisk> why is it needed in ghci but not normally
12:06:44 <Cale> I don't really eat it enough to know
12:06:47 <merijn> dublisk: There's two slightly different versions of let, the one in do-notation and the one in expressions
12:06:49 <luminous> :(
12:07:03 <neutrino> hey guys
12:07:08 <luminous> Cale: you ought to grow some and enjoy it in your salads :P
12:07:12 <merijn> dublisk: Because ghci is an line by line interpreter and not a normal source file?
12:07:17 <merijn> s/an/a
12:07:25 <neutrino> what's the function that takes a function and does >>= on it forever?
12:07:30 <neutrino> like f >>= f >>= f ...
12:07:32 * luminous wishes he set window log on
12:07:52 <roconnor> @src mfix
12:07:52 <lambdabot> Source not found. Just try something else.
12:07:54 <neutrino> luminous: set it on now, and then use /lastlog.
12:07:57 <roconnor> @hoogle mfix
12:07:57 <dublisk> merijn: I don't see how that necessitates a difference I suppose
12:07:57 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
12:08:06 <roconnor> @src Control.Monad.Fix.mfix
12:08:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:08:08 <neutrino> roconnor: thanks
12:08:23 <geekosaur> the database used by @src is very incomplete
12:08:31 <neutrino> i'd say
12:08:41 <luminous> neutrino: ooooo. I did not know about lastlog :)
12:08:44 <roconnor> neutrino: sorry mfix is different
12:08:52 <roconnor> neutrino: though possibly what you actually want
12:09:26 <neutrino> i want to loop a monadic function while it produces effects
12:10:09 <klrr_> ?src foldr
12:10:09 <lambdabot> foldr f z []     = z
12:10:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:10:24 <klrr_> ?src (..)
12:10:25 <lambdabot> Source not found. Sorry.
12:10:40 <parcs> q/u :t fix . (>>=)
12:10:45 <parcs> :t fix . (>>=)
12:10:46 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = a0 -> b0
12:10:46 <lambdabot>     Expected type: (a0 -> a0) -> (a0 -> a0 -> b0) -> a0 -> a0 -> b0
12:10:46 <lambdabot>       Actual type: (a0 -> a0) -> (a0 -> a0 -> b0) -> a0 -> b0
12:11:05 <neutrino> i'm not sure what to do with that parcs
12:11:06 <neutrino> :(
12:11:13 <roconnor> neutrino: if f =<< f =<< f ... is waht you want then you can just do fixx (=<< f)
12:11:20 <roconnor> *fix (=<< f)
12:11:22 <roconnor> or er
12:11:26 <roconnor> sorry
12:11:30 <roconnor> fix (f =<<)
12:11:35 <roconnor> @type fix (f =<<)
12:11:37 <lambdabot> (Monad m, Show a, FromExpr (m a)) => m a
12:11:41 <roconnor> @type fix (?f =<<)
12:11:42 <lambdabot> (?f::a -> m a, Monad m) => m a
12:12:12 <neutrino> why would f =<< f =<< ... be what i want?
12:12:59 <parcs> f >>= f >>= f ... is a type error
12:13:06 <neutrino> sure
12:13:10 <neutrino> but i don't see how the other one relates
12:13:11 <roconnor> neutrino: maybe you are looking for "forever"
12:13:18 <neutrino> because i want to preload it with an initial value
12:13:18 <roconnor> @type forever
12:13:20 <lambdabot> Monad m => m a -> m b
12:13:29 <neutrino> hmmm..
12:13:35 <neutrino> i used forever a few times already
12:13:41 <neutrino> but i'm not sure how it works :\
12:13:48 <roconnor> @src forever
12:13:48 <lambdabot> Source not found. You untyped fool!
12:13:53 <neutrino> @type forever ?f
12:13:54 <lambdabot> (?f::m a, Monad m) => m b
12:13:58 <roconnor> forever x = x >> forever x
12:14:06 <neutrino> right
12:14:11 <neutrino> but i want >>=
12:14:15 <roconnor> or more likely forever x = let z = x >> z in z
12:14:35 <roconnor> hmm
12:14:39 <neutrino> and i want to "preload" it with another value
12:15:04 <neutrino> so i want (f a) >>= f >>= f >>= f >>= f ...
12:15:18 <neutrino> i think
12:15:24 <neutrino> unless i'm having my types wrong
12:15:38 <parcs> :t let loop f a = f a >>= loop f in loop
12:15:39 <lambdabot> Monad m => (a -> m a) -> a -> m b
12:15:50 <neutrino> i think i want a >>= f >>= f >>= f actually
12:15:51 <neutrino> sorry
12:16:44 <neutrino> parcs: i seriously don't see how that would work
12:17:26 <neutrino> ohh
12:17:28 <neutrino> @do let loop f a = f a >>= loop f in loop
12:17:28 <lambdabot> let { loop f a = do { b <- f a; loop f b}} in loop
12:17:35 <neutrino> that makes more sense now
12:17:55 <neutrino> ok yes
12:17:59 <otters> :t let loop f a = f a >>= loop f in loop
12:18:00 <lambdabot> Monad m => (a -> m a) -> a -> m b
12:18:10 <neutrino> that actually looks exactly like what i was looking for :)
12:18:15 <otters> haha! it's just like bind
12:18:32 <roconnor> @pl let loop f a = f a >>= loop f in loop
12:18:32 <lambdabot> fix (liftM2 flip ((>>=) .))
12:18:48 <parcs> :t let loop f a = a >>= loop f in \initial f -> initial >>= loop f
12:18:50 <roconnor> otters: it returns m b instead of m a
12:18:50 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = m0 a0
12:18:50 <lambdabot>     Expected type: a0 -> m0 b0
12:18:50 <lambdabot>       Actual type: m0 a0 -> m0 b0
12:18:58 <parcs> fak
12:19:18 <roconnor> @pl let loop f a = loop f =<< f a in loop
12:19:18 <lambdabot> fix ((.) . (=<<) =<<)
12:19:25 <roconnor> O_o
12:19:26 <parcs> anyway you should just write the recursion directly
12:20:36 <eikke> there should be a GSoC: "Merge conduit, pipes & io-streams" :P
12:20:51 <Xaratas> hm, my filter is somehow not fast enough, the programm requires 34sec runtime but does not hit 100% cpu usage
12:21:12 <ab9rf> Xaratas: what are you doooing?
12:21:20 <xplat> Cale: why doesn't lambdabot have MaybeT?
12:21:32 <Xaratas> ab9rf: filtering possible magic squares to get valid magic squares
12:21:58 <arbn> xplat: There are lots of things lambdabot doesn't have.
12:22:13 <Xaratas> ab9rf: or more precise: filtering partial squares in this function, to know if it is a good idea to process them further
12:23:17 <xplat> arbn: i'm just surprised because, mtl
12:23:40 <Xaratas> ab9rf: http://hpaste.org/86235 this is the filter, x is allways a list of 4 numbers, notCollidingPermutations is a list of such lists
12:24:28 <xplat> eikke: ew, who wants io-streams in their pipes?!  X-P
12:25:02 <eikke> xplat: Gabriel? ;) (cfr http://www.haskellforall.com/2013/04/pipes-and-io-streams.html)
12:25:19 <xplat> what srsly?!  *reads*
12:29:35 <ezrios> Hey all, I am looking to learn Haskell over the summer with a previous functional programming background in Racket/PLT Scheme
12:29:40 <ezrios> can anyone recommend a good text?
12:29:50 <Cale> xplat: Well, it could, if you think it would get used... there are so many libraries it's importing already, and each one increases the chances that people get timeouts.
12:30:31 <merijn> ezrios: Learn You a Haskell is nice, but might be a bit slow for you if you are already comfortable writing FP code
12:30:34 <xplat> eikke: it seems the upshot of this is that pipes is already better at io-streams style than io-streams is :P
12:30:49 <merijn> ezrios: Real World Haskell and the Gentle Introduction might be more your speed
12:30:53 <merijn> @where lyah
12:30:54 <lambdabot> http://www.learnyouahaskell.com/
12:30:56 <merijn> @where rwh
12:30:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:31:00 <merijn> @where gentle
12:31:00 <lambdabot> http://www.haskell.org/tutorial/
12:31:03 <Cale> ezrios: Well, there's Learn You A Haskell... it doesn't assume much though. If you're hardcore, you can try the Gentle Introduction, which is only gentle relative to reading the Haskell Report directly.
12:31:27 <Cale> @where yaht
12:31:27 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
12:31:27 <lambdabot> yaht/yaht.p(df|s)>
12:31:31 <ezrios> merijn: I have taken a look at LYAH but as you said I think it's tailored more towards those without FP experience
12:31:39 <Cale> there's also YAHT, which is probably aging by now
12:31:57 <xplat> Cale: probably mueval should really be forking a process that already loaded everything in L.hs
12:32:22 <Cale> ezrios: Probably a quick way to get started is to read the Gentle Intro and just ask lots of questions here.
12:32:25 <merijn> ezrios: RWH haskell is quicker, but imo glosses over some details, which might not be a problem if you're comfortable with Racket already
12:32:46 <xplat> then there's no real limit short of namespace/instance conflict to how many unused libraries can be thrown in there
12:32:52 <merijn> And, as the name implies focusses more and doing "real world" stuff
12:33:13 <xplat> Cale: of course that's not an afternoon project >:)
12:33:37 <ezrios> I think I will start with the gentle intro then, as it's available freely online
12:33:58 <merijn> ezrios: RWH is available online free too
12:34:03 <merijn> Just follow the second link
12:34:07 <Cale> Yeah, all these are available online
12:34:25 <ezrios> ah whoops I missed those links, cheers
12:34:45 <Cale> For stuff you'd actually have to buy, there's Hutton's book Programming in Haskell
12:35:17 <xplat> eikke: i never really thought of using />/ and \>\ to do that, but it's pretty obvious as soon as it's mentioned.  and they work better since you use the same operator for composing filters and applying them.
12:43:24 <donri> hm i'd think pushback is pretty fundamental to io-streams
12:44:11 <donri> well i mean, it's a third of its api ;)
12:45:20 <eikke> xplat: sorry, wasnt following anymore
12:45:33 <eikke> I didnt look into the details yet, not familiar with io-streams either
12:47:12 <lispy> xplat: what problem are you solving by having it fork a process that preloads L.hs?
12:48:08 <lispy> oh I see
12:51:13 <xplat> lispy: yeah, i guess that was ambiguous, i meant 'start a process that preloads L.hs, then fork the evaluators from it'
12:52:16 <xplat> donri: hm, i guess.  supposedly pipes-parse will do that, but i'm afraid pipes-parse will be one of my two least favourite things about pipes
12:52:38 <xplat> donri: well, two or three, but maybe pipes-stm fixed one of them
12:53:06 <donri> :)
12:54:53 <xplat> donri: the other thing is the whole 'whoever terminates first gets the last word', which came back when frames got abandoned
12:56:45 <xplat> (the third thing is the pipes laws completely fix the order of effects which means you can't make a pipeline of things that run concurrently, but i think pipes-stm may fix it up)
12:58:01 <donri> yes, that's why it's renamed pipes-concurrency ;)
13:03:18 <ryeguy> is there some way to do record equality by default?
13:03:25 <ryeguy> other than just comparing each field manually and then and'
13:03:28 <ryeguy> and'ing them
13:03:43 <donri> ryeguy: data ... deriving Eq
13:04:21 <ryeguy> oh man..i had that and thought it didn't work.its because one of the fields didn't derive eq. woops
13:04:24 <ryeguy> thanks
13:04:50 <Eduard_Munteanu> ryeguy: well, of course, your field types must also be instances of Eq, since those values are compared too
13:04:55 <donri> yes, the types of all fields in the record must also have Eq instances
13:08:47 <xplat> donri: i'd like pipes to somehow have (>*>) :: (Monad m, Proxy p) => (b' -> p a' a b' b m (r -> s)) -> (c'_ -> p b' b c' c m r) -> c'_ -> p a' a c' c m s
13:09:10 <finnrobi> that type makes me dizzy :-(
13:09:22 <finnrobi> I was so happy about making a program that actually does stuff just earlier
13:09:37 <xplat> donri: an Atkey-style (twice-)parameterized Applicative, if you will
13:09:48 <xplat> finnrobi: heh, you work up to it
13:09:59 <Chousuke> When I read the pipes blogposts I just look at the type signature and pretend I understand them
13:10:04 <Chousuke> signatures
13:10:21 <donri> there's just a lot of noise in them, not actually very complicated
13:10:35 <xplat> and even experienced haskellers consider pipes takes some getting used to, with all those parameters on the things
13:11:03 <Chousuke> yeah, that's what it looks like. most of the actual code looks pretty intuitive even if I ignore the large types.
13:11:08 <xplat> it's kind of like tensors with einstein notation
13:11:15 <finnrobi> tensors :D
13:12:16 <finnrobi> I guess I'm still kind of where I try to look at my types and try to tell if I'm missing out on some useful abstraction
13:12:25 * hackagebot DTC 1.1.0.1 - Data To Class transformation.  http://hackage.haskell.org/package/DTC-1.1.0.1 (DanielDiaz)
13:12:29 <xplat> it would probably be more readable actually if you had the 'flowing upstream' types as superscripts and 'flowing downstream' types as subscripts
13:12:58 <arkeet> you mean contravariant and covariant?
13:13:24 <xplat> arkeet: not really, the analogy to tensors is not quite that precise
13:13:30 <arkeet> no, functors.
13:14:19 <ab9rf> hm
13:14:24 <arkeet> it's not uncommon to write f_* for F(f) if F is a covariant functor, and f^* if F is contravariant.
13:14:28 <arkeet> at least in math
13:14:47 <arkeet> well, fmap f and contramap f.
13:15:14 <Chousuke> xplat: personally I think it would help if there were a way to indicate how the types relate to each other instead of just a b a' b' with some convention.
13:15:54 <xplat> Chousuke: well, part of the problem is they relate a bit differently to each other in the 6 (?) different categories
13:16:09 <ab9rf> i don't understand what's so confusing about pipes
13:17:02 <arkeet> there are a lot of type parameters.
13:17:04 <arkeet> that's all, really
13:17:10 <xplat> ab9rf: i don't see them as all that confusing either.  but then i learned tensors with einstein notation long before pipes came out
13:17:30 <ab9rf> xplat: i don't even know what einstein notation is so i can't comment :)
13:18:20 <geekosaur> oh, I see
13:18:22 <xplat> ab9rf: ah, you're missing out :)
13:18:23 <arkeet> actually you could probably make a pretty tight analogy
13:18:28 <applicative> this is the pipes/proxy paremeter problem?
13:18:45 <applicative> ah yes
13:18:58 <ab9rf> xplat: i suppose so
13:19:10 <xplat> applicative: the perfidiously prolix pipes/proxy parameter proliferation problem
13:19:11 * applicative looks up einstein notation
13:19:41 <arkeet> tensors <~> profunctors, contraction <~> profunctor composition ("tracing over" an index <~> coend)
13:20:05 <arkeet> well, profunctors between product categories I guess.
13:20:15 <applicative> yeah its a problem. I found that if I did some insane indentation I could read them better
13:20:31 <arkeet> well you kind of need all of them.
13:20:39 <arkeet> but it would be nice to be able to easily tell which is which.
13:20:43 <applicative> breaking  p a' a x' x m b after a, then putting x' below a', somehow you can visualize the upward and downward flow.
13:20:52 <xplat> applicative: ah, lining up positionally-corresponding parameters vertically?  yeah, helps
13:21:06 <xplat> applicative: also using an extra space or two before the base monad
13:21:11 <arkeet> draw pictures for them. http://hackage.haskell.org/packages/archive/pipes/3.2.0/doc/html/Control-Proxy-Tutorial.html#g:3
13:21:17 <applicative> yeah, it doesn't quite fit with the metaphors of up and down and left and right that he's using,
13:22:04 <applicative> arkeet: right, I forgot about those pics, i was preparing a patch a while back where I somehow inverted them, so that the type signature could be more easily read in light of them
13:22:14 <applicative> i'm a little blurry on it at the moment
13:22:17 <arkeet> heh
13:23:07 <applicative> right, looking at the pic you linked, it should be turned counterclockwise 90 degrees
13:23:25 <applicative> woop clockwise
13:23:25 <arkeet> yeah
13:23:49 <arkeet> such that "upstream" actually is at the top
13:23:53 <applicative> then you can actually break the type signatures to correspoind to the diagrams if you're insane enough, as of course I am
13:23:59 <arkeet> heh
13:24:30 <xplat> anyway, i want my '>*>' operator because then everyone gets to return something when they're done, you don't need to unwrap a proxy-level WriterT or StateT to get results from a fold, etc
13:24:36 <arkeet> has anyone abstracted pipes in terms of categories in general?
13:24:38 <applicative> some tool is needed for tutorial pedagogical purposes. everytime i study it, I get there, but cant retain it
13:24:42 <arkeet> xplat: I was just thinking that.
13:25:01 <xplat> also you don't need to match up the return types of all your stages
13:25:21 <arkeet> because it does seem like all the return types ought to be combined in some sort of applicative fashion.
13:25:23 <applicative> are people following his io-streams conquest, I mean in terms of comprehending it
13:25:33 <arkeet> and of course returning () is the identity for that.
13:25:48 <arkeet> hmm.
13:25:58 <arkeet> I'm not sure what the function argument is doing
13:27:06 <xplat> applicative: if you know shell pipes, x \>\ y acts like 'while /bin/true; x >/dev/null; echo $?; done | y'
13:27:09 <arkeet> looks like I have to think about pipes some more.
13:27:52 <xplat> applicative: except it's more precise about not running x more often than demanded, and of course $? doesn't have to be a stupid tiny number
13:30:40 <applicative> -bash: syntax error near unexpected token `done'
13:30:42 <applicative> hm
13:30:47 <xplat> applicative: x />/ y acts like "x | xargs -d $'\n' -n 1 -- y"
13:30:55 <xplat> applicative: i forgot 'do' after the ;
13:31:26 <xplat> applicative: (the first one)
13:32:21 * applicative should get out his shell scripting manual. 
13:33:19 <applicative> i'm presumably dealing with osx curiosa
13:33:34 <applicative> for some reason I thought we didn't have xargs builtin
13:34:08 <xplat> applicative: my second command may or may not work under zsh, which osx uses by default.  i use bash generally
13:34:28 <geekosaur> ...huh?
13:34:34 <geekosaur> os x uses bash by default
13:34:46 <xplat> geekosaur: it does now?  that's news to me
13:34:49 <geekosaur> (and xargs has never been a shell builtin that I know of)
13:34:56 <geekosaur> it never used zsh
13:35:05 <geekosaur> early releases (through Panther) used csh
13:35:14 <geekosaur> Tiget and on use bash
13:35:19 <xplat> csh?!  seriously?!
13:35:20 <geekosaur> *Tiger
13:35:25 <geekosaur> yep
13:35:38 <arkeet> so the x \>\ y one feeds the return values of x as input to y, while x />/ y feeds the output of x as parameters to y. I guess. ??
13:35:48 <applicative> geekosaur: what is the default in Terminal.app?
13:35:48 <xplat> i guess a lot of people i know configured their macbooks to use zsh then ...
13:35:52 <applicative> wait i can answer
13:36:23 <xplat> arkeet: correct
13:36:28 <applicative> hm no i can't
13:36:33 <geekosaur> applicative, should be your login shell, whatever that is
13:36:35 * arkeet uses zsh.
13:37:03 <applicative> yeah, i just use the default login shell
13:37:05 <arkeet> anyway, it seems to work in zsh.
13:38:09 <applicative> Hm I can tell it to go to bash or to zsh but dont know where I am If i just open it
13:38:22 <FireFly> You could echo $TERM
13:38:23 <arkeet> echo $SHELL
13:38:26 <FireFly> er, yes
13:38:40 <geekosaur> $SHELL won't actually tell you, it tells you your login shell not the current shell
13:38:42 <xplat> or echo $0
13:38:44 <arkeet> true.
13:38:44 <geekosaur> ps -fp$$
13:38:56 <applicative> bin/bash
13:39:24 * geekosaur wonders if the bash on os x is rcent enough to grok $'\n'
13:39:28 <applicative> geekosaur: oh I see, it was the login shell I was interested in, since I stay in it anyway, as a unix moron
13:40:00 <arkeet> couldn't you just use "\n" instead?
13:40:01 <geekosaur> it is on 10.8.3 at least...
13:40:03 <applicative> GNU bash, version 3.2.4
13:40:06 <arkeet> er
13:40:20 <geekosaur> no, shells don't expand escapes like \n normally
13:40:28 <geekosaur> that's why bash has the $'xxx' construct
13:40:31 <arkeet> my zsh does.
13:40:38 <xplat> arkeet: i guess so, it seems that xargs will interpret the escape itself
13:40:51 <xplat> at least gnu xargs does
13:41:16 <applicative> is there a brilliant brief bash primer? I am pretty limited in competence
13:41:28 <applicative> i guess I could ask in #bash
13:41:50 <xplat> applicative: if you don't know bash you're probably better off learning what pipes is doing without comparing it
13:42:25 <arkeet> heh
13:42:39 <applicative> i know some of it, i pick it by stages.
13:43:10 <monochrom> don't get bashed in #bash :)
13:43:20 <applicative> xplat: yes, your larger point is correct, I was just irked I couldn't follow the comparison due to a couple swank shell-isms
13:44:50 <monochrom> I have always had to read (and re-read) the bash man page for technical details and corner cases
13:45:15 <applicative> monochrom: yeah i was wondering about getting bashed. i'll stick to my manual wherever it is.  I like shell scripting despite my limited capacity
13:45:31 <monochrom> as for the overview main idea, well, I read an intro unix book a long time ago (bourne shell)
13:45:49 <xplat> oh god i just realized something
13:46:22 <xplat> if >*> comes to be, proxies will suddenly support a huge number of Arrow instances probably
13:46:30 <xplat> oh well, it's worth it :)
13:46:45 <monochrom> I love arrows
13:47:14 <Taneb> monochrom: how easy would you say they are?
13:47:24 <xplat> monochrom: yeah, i have to reread the bash manpage all the time, and i pretty much consider myself a shell scripting wizard
13:47:41 <monochrom> they are not easy. but I'll follow Wadler. they're meticulous!
13:48:11 <xplat> i consider them co-meticulous
13:48:23 <xplat> the person who puts them together needs to be meticulous
13:48:31 <monochrom> haha ok!
13:48:33 <int-e> how nsiderate.
13:48:44 <monochrom> @quote monochrom cola
13:48:44 <lambdabot> monochrom says: Alice: "Bob, you should learn Haskell, it's better!"  Bob: "la la la, I am not hearing you."  Alice: "cola cola cola, I am not talking to you!"
13:49:05 <arkeet> lol
13:49:13 <int-e> @quote cococo
13:49:13 <lambdabot> No quotes match. Take a stress pill and think things over.
13:49:17 <int-e> aww.
13:55:40 <Hail_Spacecake> I have a Maybe that I know is not going to be Nothing
13:55:59 <Hail_Spacecake> and for the purposes of testing some ideas I want to be able to quickly extract the value of the Just out of that maybe in quick lambdas I write in ghci
13:56:08 <Hail_Spacecake> what's the best way to do that?
13:56:13 <Mortchek> @type fromJust
13:56:14 <lambdabot> Maybe a -> a
13:56:46 <Mortchek> > fromJust $ Just a
13:56:47 <lambdabot>   a
13:56:52 <arkeet> don't use fromJust in real code.
13:57:31 <arkeet> you can also pattern match on it
13:57:37 <arkeet> (\Just a -> a + 2) (Just 5)
13:57:43 <arkeet> > (\(Just a) -> a + 2) (Just 5)
13:57:43 <Hail_Spacecake> ooh
13:57:45 <Hail_Spacecake> okay
13:57:45 <lambdabot>   7
13:57:57 <Hail_Spacecake> didn't know that was okay in a lambda
13:58:01 <Mortchek> Which is equally undesirable for cases where you might legitimately have a Nothing
13:58:24 <arkeet> no, it's slightly less bad.
13:58:30 <arkeet> you'll get a more helpful error message.
13:58:41 <arkeet> that tells you what line it failed at
13:59:09 <Mortchek> Good point
13:59:27 <Hail_Spacecake> yeah of course in real code I'd exhaustively pattern match, but I'm just experimenting in ghci and I don't want to have to type all that
13:59:32 <arkeet> :)
13:59:43 <Mortchek> maybe is helpful in such situations too
13:59:44 <Mortchek> @type maybe
13:59:45 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:59:48 <arkeet> :t fromMaybe
13:59:50 <lambdabot> a -> Maybe a -> a
14:00:03 <Mortchek> > maybe x f $ Just y
14:00:04 <lambdabot>   f y
14:00:06 <Mortchek> > maybe x f $ Nothing
14:00:07 <lambdabot>   x
14:00:16 <arkeet> > fromMaybe x <$> [Just y, Nothing]
14:00:18 <lambdabot>   [y,x]
14:00:33 <arkeet> fromMaybe x = maybe x id
14:01:31 <arkeet> hmm
14:01:34 <arkeet> I should use tables.
14:03:02 <Taneb> arkeet: what are you going to use tables for?
14:03:28 <arkeet> I'm giving a try at writing yet another irc bot.
14:03:55 <Taneb> :)
14:04:05 <Taneb> If you want any help with tables, you can probably ask me
14:04:10 <arkeet> ok
14:16:07 <applicative> tables?
14:16:13 <arkeet> @hackage tables
14:16:13 <lambdabot> http://hackage.haskell.org/package/tables
14:16:50 <applicative> ah, l'Empire Kmett
14:16:56 <arkeet> lol
14:17:27 * hackagebot fgl-extras-decompositions 0.1.0.0 - Graph decomposition algorithms  http://hackage.haskell.org/package/fgl-extras-decompositions-0.1.0.0 (ChristianHoener)
14:18:49 <alpounet> arkeet, i suggest simpleirc for handling connection to the IRC server and IRC events handling
14:18:58 <arkeet> no, I want to do it myself.
14:19:16 <NougatRillettes> hi folks, is there any "caracterization" of the functions for which bottom is not a fixed point ?
14:19:20 <tgeeky> that doesn't sound very lazy
14:19:31 <arkeet> for learning.
14:19:44 <simpson> arkeet: What are you hoping to learn? >:3
14:19:45 <arkeet> NougatRillettes: such functions are called non-strict.
14:20:09 <alpounet> arkeet, fair enough :-)
14:20:20 <arkeet> simpson: something, hopefully.
14:20:28 <NougatRillettes> hm, yes but is there anything more... useful ?
14:20:37 <elliott> that's precisely what non-stritc means
14:20:39 <simpson> arkeet: May I humbly suggest learning how to fly a kite?
14:20:43 <elliott> f is strict means f _|_ = _|_
14:20:55 <elliott> f _|_ =/= _|_ <-> f is non-strict
14:21:05 <nbouscal> if you do learn to fly a kite, learn to fly a double-string kite. they're much more fun.
14:21:21 <simpson> And any kind of kite-flying is more fun than implementing IRC.
14:21:24 <casion> nbouscal: dual-line is what it's called
14:22:17 <arkeet> I meant something about haskell.
14:22:18 <arkeet> :p
14:23:38 <simpson> arkeet: Well, IRC is not Haskell either. :3
14:25:45 <mvb> what is THE book on computer security?
14:27:43 <evancz> hello! Does anyone know why (.) and (<<<) do not have the same precedence? http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Category.html#line-20
14:28:14 <evancz> as a corollary, why is the precedence of (.) so high?
14:29:17 <ab9rf> insane dried fruit?
14:30:13 <evancz> is that a metaphor?
14:30:19 <Mortchek> evancz, he's referring to hysterical raisins, of course
14:30:36 <tgeeky> s/he
14:30:42 <tgeeky> unless you know better
14:31:31 <evancz> I am unfamiliar with this term
14:31:42 <Mortchek> Sorry, must have misremembered someone using a masculine pronoun
14:31:50 <tgeeky> evancz: insane dried fruit -> hysterical raisins -> historical reasons
14:32:04 <evancz> lol, gotcha
14:32:27 <tgeeky> what is (.) in Prelude?
14:32:33 <ab9rf> function composition
14:32:39 <evancz> one sec, i'll check
14:32:42 <ab9rf> it has a pretty high fixity
14:32:43 <tgeeky> heh, of course, I mean, what is its precedence
14:32:49 <ab9rf> 9?
14:33:02 <evancz> I suspect it is imported from Control.Category
14:33:29 <simpson> It is not.
14:33:42 <ab9rf> tgeeky: congrats, people rarely get that
14:33:59 <arkeet> it's infixr 9
14:34:03 <arkeet> ghci can tell you with :info
14:34:11 <evancz> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#line-60
14:34:14 <tgeeky> evancz: ok, so (.) is 9 because (.) is 9 in prelude
14:34:52 <arkeet> infixr 1 <<<
14:34:52 <arkeet> heh
14:34:54 <evancz> does (.) ever get used with any operators besides ($)?
14:35:00 <evancz> I have never done that
14:35:05 <ion> sure
14:35:17 <arkeet> it gets used with lens ;)
14:35:19 <evancz> can you give an example?
14:35:19 <tgeeky> evancz: $ and (.) are pretty much the two most general and often used functions
14:35:36 <Mortchek> fmap ((+1) . (*2)) [1, 2, 3]
14:35:40 <Mortchek> > fmap ((+1) . (*2)) [1, 2, 3]
14:35:41 <lambdabot>   [3,5,7]
14:35:42 <evancz> tgeeky: I know, I use Haskell a lot :)
14:35:43 <tgeeky> or operators or whatever they are technically called
14:35:44 <Mortchek> No ($) there
14:35:55 <ab9rf> i use (.) all the time for ll sorts of things
14:36:05 <arkeet> (.) is everywhere in pointfree code.
14:36:23 <ion> (<$>), (=<<), (^.) and other lens operators etc.
14:36:30 <evancz> Wait, I mean specifically using (.) with other infix operators besides ($)
14:36:37 <evancz> ion: can you show an example?
14:36:55 <evancz> oh, I may have used it with (=<<) now that you mention it
14:37:05 <ab9rf> does it count if i use `map` as an infix operator? :)
14:37:25 <ion> > ("hello", (42, "world")) ^. _2 . _1
14:37:25 <simpson> > (1, (2, 3)) ^. _2 . _1
14:37:27 <lambdabot>   42
14:37:27 <lambdabot>   can't find file: L.hs
14:37:35 <simpson> Hahahaha.
14:37:42 <simpson> > (1, (2, 3)) ^. _2 . _1
14:37:44 <lambdabot>   2
14:37:56 <tgeeky> what was that brainfart?
14:39:03 <evancz> So with monad operators and with lenses
14:39:08 <arkeet> with anything, really.
14:39:30 <evancz> then the question is, if 9 works well for those things, why is <<< set at 1?
14:40:11 <evancz> i guess to interact nicely with (&&&) and (|||)?
14:40:19 <tgeeky> evancz: to interact with everything, really
14:40:28 <tgeeky> I think you are just pushing it as low as possible
14:41:35 <tgeeky> evancz: just found this http://stackoverflow.com/questions/6320424/why-does-haskell-precedence-have-only-10-levels-is-the-figure-of-10-enough
14:42:04 <evancz> I looked at that before visiting here :)
14:42:08 <tgeeky> hehe
14:42:45 <evancz> How about this: what is a case where (<<<) is better than (.) or vice-versa?
14:43:25 <evancz> like with the lenses example, I guess (.) is nicer.
14:44:10 <SuperNoeMan> so, haskell has good support for concurrency right?
14:44:27 <tgeeky> SuperNoeMan: yes
14:44:37 <SuperNoeMan> does haskell have a gc?
14:44:41 <tgeeky> yes
14:44:45 <elliott> GHC has both of those
14:45:05 <SuperNoeMan> ok... how does the haskell gc perform well in the context of concurrency?
14:45:12 <elliott> Haskell can be implemented with or without a GC (indeed there are implementations which don't use one, e.g. jhc (or did it start to?))
14:45:14 <SuperNoeMan> from my understanding, memory models currently suck
14:45:27 <elliott> GHC has a nice incremental GC that uses multiple threads
14:45:43 <simpson> SuperNoeMan: Are you looking for a high-level yes-or-no, or something deeper?
14:45:51 <SuperNoeMan> something deepr
14:46:07 * elliott doesn't see how that's a yes or no question...
14:46:28 <cmccann> @faq what's the answer to SuperNoeMan's question?
14:46:28 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:29 <elliott> note that, e.g. Erlang has a GC too, and is certainly famous for its good concurrency/distributed support
14:46:34 <cmccann> see, it's a yes/no question
14:46:37 <simpson> elliott: "Yes, it performs well;" "no, it doesn't perform well."
14:46:38 <cmccann> well more like a yes question
14:46:41 <cmccann> like every other faq
14:46:50 <elliott> having a GC is not a blocker for many things, even things which want concurrency.
14:46:58 <elliott> especially in 2013.
14:47:09 <tgeeky> I think this was actively developed in 7.4 and 7.6
14:47:15 <tgeeky> if my hazy memory serves me
14:48:13 * tgeeky thinks http://community.haskell.org/~simonmar/par-tutorial.pdf paper is a great read and has impressive performance results
14:48:17 <tgeeky> and there's an associated github
14:49:48 <applicative_> tgeeky: you've seen his o'reilly manuscript?
14:50:10 <tgeeky> applicative_: the structure of open source thing?
14:50:34 <applicative_> http://ofps.oreilly.com/titles/9781449335946/
14:50:35 <ypo> Hi there! I dont know why im getting this error:
14:50:37 <ypo> Couldn't match type `a' with `[a]'
14:50:38 <ypo>       `a' is a rigid type variable bound by
14:50:40 <ypo>           the type signature for concInter :: [a] -> [[a]] -> [a]
14:50:41 <ypo>     In the first argument of `f', namely `x'
14:50:43 <ypo> with this function:
14:50:44 <ypo> concInter :: [a] -> [[a]] -> [a]
14:50:46 <ypo> concInter _  []  = []
14:50:47 <applicative_> tgeeky: ^^^ no, it's new
14:50:48 <ypo> concInter _  [y] = y
14:50:49 <ypo> concInter x  ys  = f x ys
14:50:51 <ypo>         where f x (y:ys@(_:_)) = y:x:f x ys
14:50:52 <ypo>               f _  [y]         = y:[]
14:50:54 <ypo> Do you know?
14:50:56 <tgeeky> ypo: never do that again.
14:50:56 <cmccann> ypo: please use hpaste
14:50:57 <geekosaur> don't paste into the channel
14:50:59 <applicative_> too much error put it on hpaste
14:51:01 <cmccann> don't paste into the channel
14:51:10 <tgeeky> ypo: as you were just repeatedly told. Don't paste into the channel
14:51:11 <ypo> sry
14:51:12 <tgeeky> @hpaste
14:51:13 <lambdabot> Haskell pastebin: http://hpaste.org/
14:51:15 <applicative_> well anyway , let us analyze it
14:51:16 <tgeeky> past it there
14:51:30 <ypo> i'll do it
14:51:40 <flebron> I'm trying to read two Ints out of stdin. Is this the reasonable way? Is there a short way to say n and k are both Ints in the bind?     (n, k) <- ((read *** (read . tail)) . break (== ' ')) <$> getLine
14:51:51 * cmccann reflects on the irony that the "don't paste in channel" replies spammed about as many lines as the paste itself
14:51:57 <flebron> (The Ints are separated by a space, as in "4 5".)
14:52:07 <tgeeky> applicative_: /me suspects this is my document, improved somehow
14:52:16 <tgeeky> applicative_: (my link, that is)
14:52:54 <arkeet> flebron: you could write (n::Int, k::Int) <- ... if you turn on ScopedTypeVariables
14:53:07 <flebron> Yeah, saw that in the output when I tried it.
14:53:15 <flebron> (Or even (n, k) :: (Int, Int) <- ...
14:53:16 <flebron> )
14:53:16 <applicative_> tgeeky: yeah, I think yours is the starting point, or maybe he used it to get the contract or whateever
14:53:18 <arkeet> yes
14:53:35 <tgeeky> applicative_: nicer formatting
14:53:37 <arkeet> you could also split the string at spaces and match on the list [n,k]
14:53:45 <ypo> here: http://hpaste.org/86276
14:54:06 <arkeet> map read . splitOn " "
14:54:09 <arkeet> (splitOn is from split)
14:54:10 <cmccann> haha I love how that memory consumption bug mentioned on reddit doesn't happen with heap profiling active
14:54:16 <cmccann> that's the best kind of heisenbug
14:54:25 <arkeet> haha
14:54:34 <monoidal> flebron: [n,k] <- map read <$> words <$> getLine ?
14:54:38 <arkeet> oh yeah, words.
14:54:42 <applicative_> tgeeky: one nice thing that is totally irrelevant to the purpose is the simple use of the debugger that he makes in the first chapter for explaining laziness and so on
14:54:47 <flebron> ... I'm stupid. Thanks.
14:54:53 <arkeet> map read . words <$> getLine looks better, though
14:55:00 <flebron> Yeah :) Way better.
14:55:01 <arkeet> I keep forgetting about words/lines.
14:56:08 <flebron> Hrm.
14:56:24 <flebron> Since map == fmap, perhaps I could read <$> words <$> getLine or something...
14:56:39 <ypo> should i explain what do function does, or doesnt it matter?
14:56:46 <ypo> *the
14:56:47 <monoidal> flebron: (read <$>) <$> words <$> getLine
14:56:50 <tgeeky> ypo: with this error, I would suspect that one of my three function definition lines doesn't have the correct type
14:57:08 <arkeet> that's disgusting.
14:57:08 <tgeeky> ypo: try commenting out the :: [a] -> [[a]] -> [a]
14:57:12 <flebron> Hrm. My idea is bad, and I should feel bad.
14:57:22 <tgeeky> ypo: and let GHC infer the type, and see what happens
14:57:28 * hackagebot fay 0.14.4.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.14.4.0 (AdamBergmark)
14:57:56 <ypo> tgeeky: Then it says: Occurs check: cannot construct the infinite type: a0 = [a0]
14:57:59 <hpaste> applicative revised “title”: “conInter” at http://hpaste.org/86276
14:58:15 <tgeeky> ypo: also; I think the second to last line, = "y:x:f x ys"
14:58:18 <tgeeky> doesn't look right
14:58:42 <applicative_> ypo, maybe this? or am I spoiling the fun. if the return type is [a] you need to be concatenating with ++ somewhere not : ing
14:59:01 <tgeeky> ypo: you have: concInter x ys = "f x ys"  where f x ___ = ____: (f x ys)"
14:59:24 <arkeet> applicative_: you should annotate instead of edit. :p
14:59:37 <applicative_> yeah, i noticed
15:00:34 <applicative_> > let concInter _  []  = []; concInter _  [y] = y; concInter xs  (ys:yys)  =  ys ++ xs ++ concInter xs yys in concInter "hello" (map show [1..10])
15:00:36 <lambdabot>   "1hello2hello3hello4hello5hello6hello7hello8hello9hello10"
15:01:03 <arkeet> @hoogle [a] -> [[a]] -> [a]
15:01:03 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:01:03 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
15:01:03 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
15:01:26 <applicative_> > intercalate  "hello" (map show [1..10])
15:01:27 <lambdabot>   "1hello2hello3hello4hello5hello6hello7hello8hello9hello10"
15:01:31 <tgeeky> ypo: look at all the help you get! Isn't #haskell great? :)
15:01:41 <applicative_> excellent function to define, ypo
15:02:11 <arkeet> exercise: implement all the functions in Data.List
15:02:12 <arkeet> :p
15:02:31 <arkeet> :t filterM (const [False,True])
15:02:32 <cmccann> that's actually not a bad learning exercise
15:02:33 <lambdabot> [a] -> [[a]]
15:02:34 <ypo> tgeeky: Yeah thanks a lot, but i am trying to avoid (++) as long as possible
15:02:40 <arkeet> why?
15:02:54 <applicative_> ypo: I think the little detour by f is unnecessary since you wisely included the singleton case [x], so that when pattern matching falls through to the last case we know its x : y : zs
15:02:56 <ypo> applicative_: thanks but look at my previous post
15:03:11 <applicative_> ypo: yes, i see, I'm thinking
15:04:10 <applicative_> @type intersperse
15:04:11 <lambdabot> a -> [a] -> [a]
15:04:16 <tgeeky> can you un-edit your edit?
15:04:26 <applicative_> that would be more natural to write just with :
15:04:54 <applicative_> oh sorry i didn't see how grave the edit was dammit
15:05:13 <cmccann> @src intercalate
15:05:13 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
15:05:25 <cmccann> intersperse is a good one to implement instead anyway
15:05:58 <ypo> applicative_: Thanks, intersperse is exactly what i am trying to implement. i'll see at its coda
15:06:21 <arkeet> > intersperse '.' "abcde"
15:06:22 <lambdabot>   "a.b.c.d.e"
15:06:27 <hpaste> applicative revised “title”: “unedit” at http://hpaste.org/86276
15:06:52 <applicative_> here is ypo 's original code ^^
15:07:04 <applicative_> no ypo don't at the source, it should be pretty simple
15:07:55 <xplat> arkeet: module Exercise (module Data.List) where import Data.List -- done
15:08:04 <applicative_> sorry, i hadnt noticed the edit function before, or maybe I'm still not getting it
15:08:04 <arkeet> =(
15:08:17 <tgeeky> xplat: the CS equivalent of "I did it in my head"
15:08:31 <arkeet> module Exercise (module Exercise) where import Exercise
15:08:39 <applicative_> well, the syntax for imports is a bit of an exercise
15:09:05 <applicative_> every haskell module is already imported into itself
15:09:58 <applicative_> anything at the top level is in scope anywhere.  Its madness!
15:11:23 <applicative_> so hpaste lets me edit anyone's past pastes?
15:12:10 <arkeet> hpaste has no access control.
15:12:48 * tgeeky was looking at this proof sketch on stackoverflow: http://stackoverflow.com/questions/16123588/what-is-this-special-functor-structure-called
15:13:09 <applicative_> i see, so it is
15:13:14 <tgeeky> and naively typechecking the contents with lambdabot by: @type (\m n -> paste line)
15:13:41 <tgeeky> but lines 4 and 5 don't have the same type
15:13:49 <ypo> applicative_: I fixed it, but i dont know how
15:13:50 <tgeeky> @type (\m n -> pure (.) <*> pure (const id) <*> pure (const ()) <*> n <*> (pure (,) <*> m <*> n))
15:13:51 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
15:13:58 <tgeeky> @type (\m n -> pure const <*> n <*> (pure (,) <*> m <*> n))
15:13:59 <lambdabot> Applicative f => f a1 -> f a -> f a
15:14:44 <arkeet> :t liftA2 (,)
15:14:45 <lambdabot> Applicative f => f a -> f b -> f (a, b)
15:14:51 <arkeet> :t uncurry $ liftA2 (,)
15:14:52 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
15:15:23 <ypo> applicative_: i left out concat before because of debugging
15:15:35 <applicative_> ah
15:16:00 <ypo> Thanks folks and good night!
15:16:40 <applicative_> good luck ypo
15:16:50 <supki> :t both id
15:16:51 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
15:17:01 <ypo> applicative_: you too
15:17:22 <otters> :t over both
15:17:23 <lambdabot> (a -> b) -> (a, a) -> (b, b)
15:17:56 <tgeeky> if someone tried to answer me by :t or whatever, let me know, because I don't understand
15:17:59 <arkeet> :t traverseOf_ both id
15:18:00 <lambdabot> Applicative f => (f r, f r) -> f ()
15:18:15 <arkeet> no, I didn't.
15:18:44 <arkeet> I have a hard time thinking about applicatives in terms of <*> stuff.
15:18:57 <otters> :t (<*>)
15:18:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:19:02 <arkeet> well, harder.
15:19:36 <tgeeky> I'm not actually thinking, I'm just typechecking. I assume if you are trying to prove something like this, to have (same type) several times in a row, and to have a result that is (same type) but have an intermediate step which is not (same type)
15:19:40 <tgeeky> is a problem
15:19:45 <applicative_> @type \n m -> pure (const id) <*> n <*> (pure (,) <*> m <*> n)
15:19:47 <lambdabot> Applicative f => f a -> f a1 -> f (a1, a)
15:19:51 <arkeet> yes, you would have done something funny.
15:20:00 <applicative_> @type (\m n -> pure (.) <*> pure (const id) <*> pure (const ()) <*> n <*> (pure (,) <*> m <*> n))
15:20:06 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
15:20:07 <arkeet> uhh
15:20:17 <applicative_> tgeeky: he left out id
15:20:22 <tgeeky> yep. I just saw it
15:20:24 <tgeeky> at the same time you did.
15:20:55 <cmccann> step 5: undefined -- and then a miracle happens
15:21:09 <arkeet> !
15:21:19 * tgeeky is going to start a stackoverflow account
15:21:24 <cmccann> :D
15:22:35 <applicative_> don't bother d. fisher and cmcann are doing a fine job
15:22:42 <cmccann> I'm slacking off these days
15:22:49 <elliott> I thought cmccann retired. roughly when i started.
15:22:58 <cmccann> dafis is sort of unstoppable though
15:23:06 <tgeeky> cmccann: oh is that you sketching the proof?
15:23:12 <cmccann> seriously holy rolling rolling shitballs how does he keep that up
15:23:23 <cmccann> tgeeky: I answered that question
15:23:30 <elliott> I just binged for months and then crashed.
15:23:39 <applicative_> he's mad.  is he in bed in a sanitarium, waiting for a cure for tuberculosis?
15:23:40 <cmccann> elliott: did you get the Epic badge in all that?
15:24:21 <elliott> cmccann: I did
15:24:46 <cmccann> I still don't have that one
15:24:46 <elliott> huh, it's silver. wasn't it gold?
15:24:48 <cmccann> I pace myself
15:24:50 <cmccann> no, it's silver
15:24:56 <cmccann> there's a gold version as well
15:24:58 <applicative_> i just notice i have the sinister seeming  Citizen Patrol badge.
15:25:09 <applicative_> I'm an anarchist darnit
15:25:09 <elliott> clearly I need to get back into it.
15:25:48 <cmccann> elliott: silver is hitting 200 rep on 50 days, gold is 150 days
15:26:20 * cmccann has almost all of the badges you can get by just using the site and answering questions
15:26:51 <applicative_> pundit, synonymizer and of course sportsmanship.....
15:26:54 <cmccann> and a couple of the linkbaiting badges from when I've referred to SO on reddit or IRC
15:26:59 <applicative_> this is seeming kind of like the girl scouts
15:27:05 <cmccann> haha
15:27:14 <cmccann> girl scouts did gamification before it was cool
15:28:25 <applicative_> i wonder what they signify by 'necromancer'
15:28:37 <cmccann> http://stackoverflow.com/badges describes the badges
15:28:46 <tgeeky> applicative_: do you not even mance necros?
15:28:55 <cmccann> basically that one is post an answer to a question months old that gets voted up several times
15:29:16 <applicative_> i'm sure its all i ever do
15:29:21 <cmccann> Populist and Reversal are the most entertaining gold badges I think
15:29:49 <applicative_> ah that makes sense. I think that happens if you are actually using so as a resource yourself and add something
15:30:02 <applicative_> what is Reversal
15:30:13 <cmccann> applicative_: yeah, rewarding people for adding good answers to old neglected questions is the point there
15:30:46 <hpaste> flebron pasted “Clear inefficiencies?” at http://hpaste.org/86283
15:30:48 <cmccann> "Provided answer of +20 score to a question of -5 score. "
15:31:01 <cmccann> a.k.a. give a great answer to someone who didn't deserve it
15:31:09 <flebron> This is a for a programming contest, the input is specified, so fromJust isn't that terrible :p
15:31:47 <flebron> The problem statement is to find a subset of k Ints such that the difference between the maximum and minimum is minimized. The way I solve this is by sorting, and then using a sliding window of length k.
15:32:11 <cmccann> heh, the most recent Reversal badge was for a Haskell question: http://stackoverflow.com/a/15816093/157360
15:32:14 <flebron> The input to the problem is very large. I am using ByteString because of this. Am I doing something particularly inefficiently?
15:32:26 <applicative_> it seems my only not dime a dozen badge is 'haskell' as one might have expected
15:33:02 <cmccann> the bronze tag badge?
15:33:32 <arkeet> flebron: why are you using bytestring?
15:33:36 <amiller> hey i'm having trouble with the supply monad
15:33:38 <amiller> i want something like
15:33:42 <flebron> arkeet: The input is huge.
15:34:02 <amiller> runSupplyT s m a -> m s -> m (a, m s)
15:34:19 <amiller> rather than runSupplyT s m a -> [s] -> m (a, [s])
15:34:33 <applicative_> oh i see, i guess it's silver cmccann
15:34:34 <amiller> because i want it to have to read something from a stream of some kind
15:35:06 <cmccann> applicative_: tag badges have a silver background and are awarded for getting upvoted answers
15:35:31 <applicative_> i guess thats happened once or twise
15:35:33 <applicative_> twice
15:36:01 <cmccann> 100 upvotes and 20 answers for bronze
15:36:08 <applicative_> yes a tag badge
15:36:11 <cmccann> gold tag badges mean you spend way too much time on SO
15:36:14 <cmccann> :[
15:36:25 <shachaf> cmccann: Or your browser does!
15:36:26 <applicative_> bronze i guess that's the dot
15:36:32 <applicative_> this is like british heraldry
15:36:35 <cmccann> yeah, the dot
15:36:59 <applicative_> well, i should make more popular responses.  No, no way.
15:37:00 <cmccann> applicative_: http://stackoverflow.com/users/157360/c-a-mccann?tab=badges
15:37:34 <applicative_> ah i see the shiny gold in that haskell
15:38:26 <applicative_> well, it seems a good site from the haskell point of view anyway, whatever the wacky infrastructure
15:38:28 <cmccann> and here's the hall of shame for haskell programmers who spend too much time on SO: http://stackoverflow.com/badges/210/haskell
15:38:30 <cmccann> :D
15:39:21 <applicative_> ah, indeed the usual suspects
15:39:28 <cmccann> pretty much
15:39:29 <ab9rf> i only read SO
15:39:36 <cmccann> ehird is elliott btw
15:39:54 <applicative_> ah
15:40:12 <applicative_> i hadnt made the connection
15:40:27 <cmccann> see also the haskell tag highscore table: http://stackoverflow.com/tags/haskell/topusers
15:40:33 <elliott> the question quality seems to have dropped since I gave up. clearly this correlation is causatory
15:40:38 <cmccann> yes
15:41:15 <elliott> my top answer is to a question titled "How do you identify monadic design patterns?" and explains monads using "contexts". :(
15:41:20 <elliott> I should make it not bad.
15:41:23 <cmccann> hahaha
15:41:31 <applicative_> oh, sepp2k  is the real master, I wouldnt have guessed
15:42:08 <cmccann> applicative_: dmwit and tommd are also on the list there but I'm guessing you recognize their names
15:42:10 <elliott> applicative_: that's just total rep
15:42:17 <elliott> if you're looking at the number on the badges page
15:42:20 <applicative_> is sepp2k familiar to us under another name
15:42:29 <applicative_> yeah i recognize them
15:42:49 <elliott> IIRC I've answered ~1 question not in the [haskell] tag
15:42:56 <elliott> most people diversify a bit, I think.
15:43:17 <cmccann> not as much as you might think
15:43:26 * BMeph_ hedges: I only read SO for the articles.... ;)
15:43:32 <cmccann> most of the people on the haskell high score list are almost exclusively active there
15:43:39 <cmccann> dafis and sepp2k being the main exceptions I think
15:44:19 <ab9rf> i imagine SO has peaked its utility and will slowly decline as the karma trolls take over.  happens to all websites that don't charge.
15:44:28 <applicative_> John L is J. Lato?
15:44:32 <cmccann> yes
15:44:41 <cmccann> ab9rf: karma trolling on SO doesn't work very well
15:44:48 <hpc> ab9rf: maybe on P.SE
15:45:10 <cmccann> daily rep gain is capped and the site has steadily become more hostile to the kind of questions that attract lots of fluffy, rep-bait answers
15:45:23 <applicative_> yo augustss
15:45:32 <elliott> in terms of answering, the things you can do to get lots of rep obsessively are things that make the site get really fast, good quality answers for askers.
15:45:34 <ab9rf> cmccann: yes, but it doesn't stop them from trolling, which is why the hostility you note is forming
15:45:41 <augustss> yo!
15:45:51 <ab9rf> cmccann: that'll eventually toxify the social environment and strangle the site
15:46:02 <hpc> it's like recaptcha a bit, that way
15:46:16 <elliott> I mean, I figured out most of the tricks pretty quickly. and it involved answering questions quickly with skeleton answers and then fleshing them out to be high-quality. that's pretty unambiguously a good thing for askers
15:46:20 <hpc> you can use "dirty" tactics to beat the system, but the system still wins regardless
15:46:24 <cmccann> ab9rf: that sort of already happened and the hostility is the remnants of it
15:46:37 <hpc> elliott: asked-and-answered is a good way to get rep too
15:46:47 <hpc> double-dipping on the question and the solution to the same thing
15:46:53 <hpc> and that's encouraged also
15:47:03 <applicative_> augustss: sorry to bother you; I was just marvelling that your name arose.
15:47:04 <hpc> as public documentation of an issue
15:47:17 <augustss> no bother :)
15:47:30 <augustss> has my name arisen?
15:47:31 <hpc> whoa, augustss
15:47:37 <hpc> i remember you from a million years ago
15:47:43 <elliott> it's like two christmasses in a year!
15:47:55 <cmccann> augustss: just not used to seeing you on IRC
15:48:18 <augustss> it's been a while
15:48:39 <applicative_> augustss: no i just say the == augustss  has joined #haskell and responded with impulsive enthusiasm :)
15:48:56 <augustss> haha
15:48:58 <applicative_> saw rather
15:49:28 <cmccann> augustss: I mean you've basically been a member of the Haskell community since before Haskell existed, so it's not surprising you get a bit of recognition :P
15:49:37 <Peaker> @type tell
15:49:39 <lambdabot> MonadWriter w m => w -> m ()
15:49:45 <Peaker> @type Control.Monad.Trans.Writer.tell
15:49:47 <lambdabot> (Monad m, Monoid w) => w -> WriterT w m ()
15:49:51 <augustss> cmccann: That I have.
15:49:53 <Peaker> Why does it need the monad constraint? :(
15:50:14 <elliott> Peaker: return (0, w) presumably
15:50:24 <elliott> as in tell w = WriterT $ return (0, w) or whatever
15:50:37 <Peaker> Yeah :(  Haskell should fix the Applicative=>Monad thing
15:50:43 <applicative_> @unmtl WriterT w m a
15:50:43 <lambdabot> m (a, w)
15:50:57 <elliott> the (a, s) (a, w) ordering is totally broken. it should be fixed
15:51:03 <elliott> doesn't match up with fmap on tuples at all
15:51:44 <Peaker> I now have to choose between   WriterT Any m    and   ((,) Any :. m)   as the latter is properly Applicative.. but doesn't have "tell", and requires a dependency on TypeCompose
15:51:47 * cmccann is still sad about that april fool's post on /r/haskell
15:51:50 <xinube> test
15:52:19 <Peaker> so I'm going to have a superfluous dependency on Monad when I am Applicative :-(
15:52:19 <xinube> Hallo, is this the place where I can ask things about XMonad/XMobar?
15:52:20 <shachaf> Peaker: You can define your own Applicative!
15:52:31 <shachaf> xinube: Try #xmonad
15:52:37 <elliott> Peaker: you could just write your own tell
15:52:50 <shachaf> That works too.
15:53:20 <Peaker> this is the 500,000th paper cut from Applicative =/> Monad
15:53:43 <shachaf> I,I instance Applicative m =/> Monad m where ...
15:55:42 <Peaker> someone suggested a "never" directive to help the type-checker give earlier/better errors
15:55:51 <Peaker> maybe =/> is nicer than never somehow :)
15:57:35 * hackagebot heredoc 0.1.0.0 - multi-line string / here document using QuasiQuotes  http://hackage.haskell.org/package/heredoc-0.1.0.0 (JamesFisher)
15:57:37 * hackagebot heredoc 0.1.0.1 - multi-line string / here document using QuasiQuotes  http://hackage.haskell.org/package/heredoc-0.1.0.1 (JamesFisher)
16:00:17 <xplat> anyone have a good simple example of using a TreeView/TreeModel in gtk2hs?
16:03:46 <tgeeky> hm. I decided to S.M.A.R.T. test a brand new hard drive to record it's initial health. 4TB drive. This is taking a long time.
16:04:20 <Eduard_Munteanu> tgeeky: you mean #haskell-blah? Also, which of those tests?
16:04:46 <tgeeky> Eduard_Munteanu: no, I'm still banned. :/   And I did 'long'.
16:05:09 <haasn> well maybe you should have done ‘short’ then
16:05:18 <Eduard_Munteanu> Oh, hm, I remember asking Philippa about that... wtf happened?
16:05:36 <tgeeky> I realized after one of my two raptors failed that I had never run a SMART long test except post failure. So I wanted it in the drive's memory times time.
16:06:00 <Eduard_Munteanu> SMART tests aren't exactly tests though.
16:06:01 <tgeeky> Eduard_Munteanu: I'm not going to talk about it anymore.
16:06:22 <Eduard_Munteanu> Ok... I can bug them about it if you want. :)
16:06:41 <Eduard_Munteanu> (I've seen other hasty bans, so... who knows.)
16:07:53 <Eduard_Munteanu> I think SMART tests merely spin stuff up and does reads, while SMART firmware is recording events as usual, or something like that. They say it's more like data collection than testing.
16:08:12 <ab9rf> Eduard_Munteanu: basically
16:08:14 <tgeeky> the old drive I had "passed" (by this I mean passed when drive was frozen for 48 hours first, and started as cold as possible) the short smart test but failed the long one quickly (at 88% left)
16:08:25 <tgeeky> Eduard_Munteanu: yes, that is correct
16:08:36 <tgeeky> Eduard_Munteanu: the long test just makes it scan the whole surface
16:09:16 <Eduard_Munteanu> tgeeky: also, smartctl provides estimates for tests (I think the firmware reports it)... so you got what you asked for :)
16:09:34 <Eduard_Munteanu> I think you can cancel it.
16:09:36 <tgeeky> Eduard_Munteanu: yes, I realized too late that the estimate of '255' could be a cut off estimate. :)
16:09:42 <Eduard_Munteanu> Heh.
16:10:06 <amiller> will i be able to use the io-streams library with the Supply monad?
16:11:35 <xinube> I have a stupid question... what "&" does when you run a command?
16:11:48 <elliott> xinube: this channel is about the Haskell programming language :)
16:11:55 <Eduard_Munteanu> xinube: usually 'run in background'
16:11:57 <elliott> try #bash or such?
16:12:03 <elliott> maybe it is ##bash
16:12:13 <xinube> where can i solve general newbie questions
16:12:17 <ab9rf> ##newbie
16:12:24 <Eduard_Munteanu> Heh.
16:12:27 <elliott> uhm, maybe ##linux or something?
16:12:32 <elliott> or you could read the manual :)
16:12:34 <Eduard_Munteanu> xinube: questions about what?
16:12:36 <monoidal> also you can google, i.e. 'ampersand command'
16:12:40 <ab9rf> ##helpmeimlost
16:13:14 <xinube> mainly about linux, but some about arch
16:13:39 <Eduard_Munteanu> xinube: see ##linux and #archlinux
16:13:42 <ab9rf> it's not really a command :)
16:13:53 <Eduard_Munteanu> Or #bash
16:14:40 <xinube> ok thanks...
16:35:59 <flebron> How can I know when something I do breaks stream fusion? That is, when some action I carry out requires all of a list to be kept in memory. Specifically, I'm wondering if I'm doing that here: http://hpaste.org/86283
16:37:09 <Eduard_Munteanu> flebron: mm, you probably mean strictness instead of stream fusion?
16:37:09 <flebron> I would assume sort does, right?
16:37:17 <flebron> Maybe.
16:38:04 <ab9rf> sort requires its entire input be evaluated enough to compare every member
16:38:06 <Eduard_Munteanu> flebron: fusion would eliminate the list *completely*. Laziness lets you process stuff without having it all in memory, as far as IO is concerned.
16:38:06 <flebron> What I'm trying to do is read a list v, sort it, and then for every i in [0, ... n - k], take the minimum of v[i + k] - v[i].
16:38:21 <flebron> Is what I'm doing the most efficient way of doing that?
16:38:56 <xplat> TreeStore sure is ludicrously complicated compared to ListStore
16:39:21 <Eduard_Munteanu> xplat: look for plain old GTK examples, perhaps?
16:39:29 <Eduard_Munteanu> I mean C code.
16:39:29 <ab9rf> no mreaningful way to do a lazy sort
16:39:51 <flebron> Right. Any other way of getting this code to perform better?
16:40:19 <hpaste> flebron pasted “Comparison” at http://hpaste.org/86290
16:40:21 <ab9rf> i don't understand what you're trying to compute here
16:40:26 <flebron> ^-- as compared to that code.
16:41:11 <xplat> flebron: once sorted, do minimum $ zipWith (-) (drop k xs) xs
16:41:12 <flebron> ab9rf: Given a list v, sort it, and take the minimum of (for i = 0, up to n - k, v[i + k] - v[i]).
16:41:26 <flebron> xplat: Is why would that be faster?
16:41:30 <Eduard_Munteanu> I think ab9rf was asking what you need it for.
16:41:32 <flebron> s/Is //
16:42:05 <flebron> Eduard_Munteanu: Programming competition problem. The problem is, given a list of n elements, and an int k, find the subset of k elements of that list that minimizes the difference between the highest and lowest. Return this difference.
16:42:15 <flebron> The solution is to sort and use this sliding window approach.
16:42:29 <flebron> Well, "a" solution.
16:42:34 <xplat> flebron: i'm not absolutely sure it would be faster, but it's way less complicated
16:43:09 <flebron> xplat: Why? I find it less clear to introduce many subexpressions in the same expression :s
16:43:48 <xplat> flebron: everything's an expression in haskell.  if you think it's too much on one line, put the arguments on separate lines.
16:43:59 <flebron> I know :p
16:44:58 <xplat> you can even name subexpressions you want to separate out and drop them in a 'where' or 'let'
16:45:20 <xplat> i don't feel like indenting your code for you in irc :)
16:45:31 <flebron> O.o That's what I had with that "let v' = ...".
16:46:06 <flebron> But you said it's "way less complicated" to eschew that let binding and write the expression inside the expression I'm printing.
16:47:11 <xplat> flebron: ah, i didn't see your original paste, just the C++ comparison
16:47:19 <flebron> Ah, OK.
16:48:15 <xplat> still, i would break out the whole zipWith before i'd break out the drop, the zipWith and drop go together conceptually
16:49:22 <flebron> The problem I'm working on, by the way, is at http://www.spoj.com/status/AMR10G/ . So far, there are no accepted Haskell solutions, they all give time limit exceeded.
16:49:51 <xplat> if you want to see if fusion is working, the best way is probably to look at the generated core
16:50:52 <dmwit> Eduard_Munteanu: (I think TreeStore and ListStore are both Haskell-only.)
16:50:58 <xplat> there's a ghc-core package that gives you a command to dump nice colorized core, the colors make it possible for a human to read despite the otherwise-overwhelming detail level
16:51:23 <shachaf> Much more useful to make Core readable: -dsuppress-all
16:51:38 <shachaf> (The combination is even better, of course.)
16:51:56 <Eduard_Munteanu> Hm.
16:53:49 <xplat> if you don't know what Core is, it's an intermediate language used by GHC that is both high-level enough to retain all the type information and low-level enough to make all memory allocations in the final program explicit
16:54:29 <flebron> Yep.
16:54:40 <flebron> I've never written it, but I know of it.
16:54:43 <xplat> if you see a cons in the Core, then some lists are not being fused away
16:54:46 <arkeet> you don't write core. :p
16:55:00 <dmwit> One does not simply Write Core.
16:55:06 <arkeet> yes, that.
16:55:10 <dmwit> unless one wants to simply dump core
16:55:27 <liyang> please, not in public.
16:55:38 <xplat> dmwit: i thought it was more C-- that had that problem ...
16:55:40 <BMeph_> "One does not simply code into Core." -- Meme alert? ;þ
16:55:53 <dmwit> There we go, that's the phrasing I was looking for.
16:56:26 <cmccann> nerd reference secured, you may continue
16:56:31 <BMeph_> dmwit: "One does not simply code into ...more Core"? ;þ
16:56:40 <dmwit> xplat: I guess Core must be able to do it, too, what with all this "oh, wah, GeneralizedNewtypeDeriving can cause segfaults" whining. ;-)
17:00:44 <xplat> well, sure, if you put in unsafeCoerce you can cause segfaults right from Haskell!  :p
17:02:16 <amiller> what's an efficient way to read sequences of files from a file
17:02:26 <amiller> like i have data.serialize instantiated from the cereal library
17:03:33 <xplat> amiller: sequences of ... files?
17:03:47 <amiller> er sorry sequences of objects
17:03:59 <amiller> i want something like Serialize c => Handle -> IO c
17:08:27 <jagaj> I'm reading through lyah, and I've reached something I don't understand in the modules section, "groupBy (\x y -> (x > 0) == (y > 0)) values", values is a list of floats. What does y correspond to when the function is executed?
17:08:51 <elliott> jagaj: elements of values
17:08:54 <elliott> same for x
17:09:12 <elliott> @src groupBy
17:09:13 <lambdabot> groupBy _  []       =  []
17:09:13 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
17:09:13 <lambdabot>     where (ys,zs) = span (eq x) xs
17:09:17 <elliott> @src span
17:09:17 <lambdabot> span _ xs@[]                     =  (xs, xs)
17:09:18 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
17:09:18 <lambdabot>                   | otherwise    =  ([],xs)
17:09:19 <jagaj> elliott: I suspect I don't understand how group works then
17:09:27 <elliott> > group [1,2,3,3,3,4,5,5,5,6]
17:09:29 <lambdabot>   [[1],[2],[3,3,3],[4],[5,5,5],[6]]
17:09:35 <elliott> > groupBy (==) [1,2,3,3,3,4,5,5,5,6]
17:09:37 <lambdabot>   [[1],[2],[3,3,3],[4],[5,5,5],[6]]
17:09:41 <elliott> > groupBy (\_ _ -> True) [1,2,3,3,3,4,5,5,5,6]
17:09:43 <lambdabot>   [[1,2,3,3,3,4,5,5,5,6]]
17:10:00 <elliott> basically, it considers the predicate you pass as equality, and then groups all sequences of adjacent equal elements.
17:10:01 <dmwit> > groupBy (\_ _ -> False) [1,2,3,3,3,4,5,5,5,6]
17:10:02 <lambdabot>   [[1],[2],[3],[3],[3],[4],[5],[5],[5],[6]]
17:10:15 <elliott> dmwit: that is not valid
17:10:22 <elliott> the argument to groupBy is required to be an equivalence relation, IIRC
17:10:39 <dmwit> Define the equality on which your definition of "equivalence relation" is based.
17:10:48 <jagaj> elliott: so it's considering 2 sequential elements of the list at a time?
17:11:01 <elliott> dmwit: I don't make the rules :)
17:11:06 <elliott> jagaj: sure.
17:11:16 <elliott> jagaj: if you have [1,2,3,3,4], then it gets called on 1 and 2.
17:11:19 <elliott> then 2 and 3.
17:11:31 <elliott> then 3 and 3, then 3 and 4.
17:11:35 <dmwit> jagaj, elliott: Actually, no.
17:11:43 <elliott> if you return True then you get non-adjacent elements though.
17:11:51 <elliott> but they're "the same" according to your equality predicate :P
17:11:55 <arkeet> actually, it's 1 and 2, then 1 and 3, and 1 and 3, and 1 and 4.
17:12:00 <dmwit> The Report's implementation compares the first element of each group with each other element of the group, not adjacent elements in the list.
17:12:04 <elliott> right.
17:12:19 <elliott> never mind me.
17:12:22 <arkeet> > groupBy (/=) [False,True,False,True,True,False]
17:12:23 <lambdabot>   [[False,True],[False,True,True],[False]]
17:12:41 * hackagebot PrimitiveArray 0.5.0.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.5.0.0 (ChristianHoener)
17:13:11 <jagaj> I'm more confused than before now.. hmm
17:13:11 * BMeph_ declares - arkeet WINS!
17:13:13 <dmwit> jagaj: Then again, assuming you follow the rules, this implementation is indistinguishable from the one you proposed. =)
17:14:01 <jagaj> dmarker: when you say 1, you mean the head of the list that is 'being built'
17:14:05 <jagaj> not of the list provided
17:14:10 <jagaj> is that correct?
17:14:30 <jagaj> err, dmwit, sorry
17:14:34 <mietek> http://pastie.org/private/1kq8cpehncq4liekxoqma
17:14:41 <dmwit> I don't recall saying 1. =)
17:15:00 <mietek> Is there something standard I don't know which would serve as nubFold?
17:15:03 <jagaj> ahh darnit
17:15:54 <dmwit> mietek: Map.fromListWith?
17:16:51 <mietek> Ahh, of course
17:16:59 <dmwit> > M.fromListWith (+) [("foo",1),("bar",2),("foo",3),("foo",4),("bar",5),("foo",6),("bar",7)]
17:17:01 <lambdabot>   fromList [("bar",14),("foo",14)]
17:17:09 <mietek> Thanks
17:17:09 <mm_freak> finally i have a use case for first class patterns
17:17:23 <mm_freak> and unfortunately haskell doesn't have them =/
17:17:29 <Peaker> mm_freak, Prisms come close
17:17:30 <mm_freak> so i guess i'll use lenses
17:17:33 <mm_freak> yeah
17:18:01 <dmwit> ?hackage first-class-patterns
17:18:01 <lambdabot> http://hackage.haskell.org/package/first-class-patterns
17:20:19 <mm_freak> thanks, but i guess i'll use lenses instead
17:20:35 <Peaker> Nice library, no TH though like for Prisms?
17:21:09 <mm_freak> they're easy enough to implement…  it's just a bit mechanical
17:21:15 <Peaker> I haven't really used prisms for much pattern-matching.. only like:  case foo ^? myPrism of Just Bar -> ... _ -> ...
17:21:29 <mm_freak> i have a Reply data type for IRC numeric reply messages, and i need a prism for each one
17:21:37 <Peaker> I wonder how the "outside" prism combinator is supposed to be used
17:22:21 <mm_freak> when this is done, fastirc 0.3.0 is ready for release =)
17:22:30 <elliott> mm_freak: derive them?
17:22:47 <mm_freak> elliott: the prisms?  how?
17:22:52 <elliott> TH?
17:23:02 <mm_freak> is there a predefined TH function for them?
17:23:03 <arkeet> :t makePrisms
17:23:05 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
17:23:09 <mm_freak> oh, nice
17:23:30 <djahandarie> mm_freak, fastirc isn't going to have a message parser in it anymore?
17:23:40 <mm_freak> djahandarie: the message parser is done already
17:23:59 <mm_freak> djahandarie: https://github.com/ertes/fastirc/blob/master/Network/FastIRC/Raw.hs
17:24:20 <djahandarie> I mean something that parsers into an ADT right than Bytestrings
17:24:23 <mm_freak> unlike in the last release it's a raw parser…  interpreting a Message is done differently this time
17:24:52 <mm_freak> you get separate types instead
17:26:28 <mm_freak> djahandarie: this release is based on ContinueT, so to get the next privmsg you would write:  privMsgWhere condition >>= …
17:26:43 <mm_freak> and to match on multiple things you just use (<|>)
17:27:21 <xplat> elliott: the spec may in fact say you must provide an equivalence relation to groupBy, but i can't even think of a way to implement it that won't do the same reasonable thing with a PER
17:27:21 <mm_freak> inChannel "#haskell" (privMsgWhere … >>= …) <|> inChannel "##crypto" (privMsgWhere … >>= …) <|> …
17:28:05 <mm_freak> and you can actually write chat sessions like a command line application =)
17:28:22 <mm_freak> getting the next message from a specific person acts like getLine
17:28:29 <elliott> xplat: it's the principle of the thing :)
17:28:32 <elliott> I agree it's a silly requirement.
17:33:07 <ryant5000> is there any way to see a list of the safe-haskell statuses of all the modules/packages on hackage?
17:34:15 <ozgura> wonders if anyone implemented a version of forkIO with a time-out.
17:34:35 <ryant5000> ozgura: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-Timeout.html
17:34:48 <ryant5000> ozgura: that's not specifically related to forkIO, but it might help
17:36:23 <ozgura> ryant5000: thanks!
17:36:29 <arkeet> the async package might be useful too.
17:36:54 <arkeet> I guess you could implement timeout with it.
17:37:00 <ryant5000> ozgura: no problem :)
17:37:03 <arkeet> timeout n = race (threadDelay n)
17:37:29 <ozgura> arkeet: that is even better
17:37:44 <ozgura> I don't know how this didn't come to my mind, really.
17:46:43 <mm_freak> ozgura: if you need more graceful timeout handling you can do that with STM
17:46:50 <mm_freak> see registerDelay
17:47:16 <ozgura> mm_freak: I'll have a look
17:47:46 <mm_freak> if just killing the thread is sufficient, System.Timeout is fine
17:47:54 <ozgura> this is slightly tricky though, what I am trying to do, I want to invoke and external tool in the io action
17:48:02 <ozgura> using System.Process.runCommand or the like
17:48:09 <orzo> I would like an extension that acts on type classes, so for example, *Functor would be a type class such that (*Functor f) implies (Functor (f a)) for all a.
17:48:55 <Eduard_Munteanu> orzo: that's not necessarily true
17:49:03 <orzo> what's not true?
17:49:11 <orzo> its a feature request
17:49:29 <Eduard_Munteanu> Also, it's a kind error.
17:49:42 <Eduard_Munteanu> orzo: it should make sense, though\
17:49:48 <orzo> it does
17:49:56 <Eduard_Munteanu> orzo: example?
17:50:14 <orzo> well, which part makes no sense to you?
17:50:55 <Eduard_Munteanu> I'm not sure what *Functor is supposed to mean, for example.
17:51:14 <tgeeky> op functor?
17:51:32 <orzo> I could write: class Functor2 f where fmap :: (a->b) -> f s a -> f s b
17:52:12 <ryant5000> orzo:  have you looked at this? http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/Data-Constraint-Forall.html
17:52:32 <ryant5000> i'm not sure it solves your problem, but i think it's related
17:53:18 <orzo> i'm not familiar with :- syntax
17:53:29 <Eduard_Munteanu> I suppose that makes more sense, yeah.
17:53:30 <ryant5000> orzo: that's just a type constructor
17:53:43 <ryant5000> it's defined in Data.Constraint
17:54:44 <ryant5000> there have definitely been times when i've wanted to use a forall in a constraint; but i'm not entirely sure what the ramifications would be
17:55:45 <edwardk> ryant5000: you can fake it
17:56:08 <ryant5000> edwardk: yeah, i was just telling orzo about your library
17:56:20 <edwardk> my usual way of getting the forall in a constraint is to rely on a class that gives me access to the property on demand, or to use that Forall hack
17:56:26 <orzo> Eduard_Munteanu: it makes sense, but i'm looking for an extension that will just auto create these classes and have them play well together, for example, Functor and Functor2 have a name conflict and such which shouldn't be.
17:57:04 <ryant5000> edwardk: right; in one case, i just added a class method :: forall a. Dict (C a)
17:57:14 <ryant5000> instead of putting something like Forall C in the class constraint
17:57:32 <edwardk> class Eq1 f where withEq1 :: Eq a => proxy f -> (Eq (f a) => r) -> r
17:57:33 <edwardk> or that
17:57:46 <edwardk> yeah thats pretty much how i'd recommend doing it
17:57:53 <edwardk> the Forall is more or less just a cute hack
17:58:13 <edwardk> it lets me nominally solve the problem once and forall, but the one off version is nicer
17:58:18 <ryant5000> haha
17:58:38 <orzo> I'm not really understanding
17:59:31 <ryant5000> orzo: what's the context where you'd like to write the forall?
17:59:35 <orzo> edwardk: do you understand my *Functor / Functor2 example?  Do you have a good way to accplish what I want?
17:59:46 <orzo> well really, its come up a second time
18:00:02 <orzo> that's why i was thinking it was a good candidate for an extension
18:00:35 <edwardk> orzo: didn't see it
18:01:14 <orzo> current context is that I have something where I have a class of kind * -> * -> * and I would be able to deduce Applicative (mything a) for all mything satisfying my class
18:01:24 <orzo> i tried different approaches
18:02:05 <orzo> er
18:02:53 <edwardk> orzo: you can't and shouldn't.
18:03:18 <orzo> typical answer
18:03:18 <edwardk> it'll overlap with everything else of kind * -> * -> * that is applicative
18:03:20 <orzo> heh
18:03:30 <edwardk> its just a bad idea
18:03:40 <Eduard_Munteanu> I guess all Edwards do that. :P
18:03:40 <orzo> I have a class AList list where ...
18:03:56 <edwardk> =)
18:04:04 <orzo> I want AList list  to imply Applicative (list s)
18:04:17 <elliott> for all s?
18:04:19 <orzo> yes
18:04:25 <elliott> can't really be done, sorry
18:04:35 <elliott> unless you're okay with heavy machinery and awkward use.
18:04:45 <edwardk> orzo: but i'd bet you could instantiate AList for something like ZipList, which would have completely unrelated semantics to the desired applicative semantics you want
18:05:03 <Eduard_Munteanu> The initial question was he had a parametrized functor typeclass... he wanted that to imply the normal functor for all choices of the parameter.
18:05:17 <Eduard_Munteanu>  orzo> I could write: class Functor2 f where fmap :: (a->b) -> f s a -> f s b
18:05:34 <Luke> anyone familiar with DigestiveFunctors? I'm trying to find if I can nest sub views (like dfSubView in heist)
18:05:52 <edwardk> orzo: The problem is what happens someone comes up with a HisList class and instantiates it for your same data type? And he also comes up with the idea that the only instances of Applicative of kind * -> * -> *  out there should be the ones from his class? Which magic Applicative instance wins?
18:05:56 <Eduard_Munteanu> And somehow have fmap share the name
18:06:14 <orzo> yes, if I had a similarly defined Applicative2 for the Applicative class, I could make it a superclass for AList
18:08:21 <orzo> I'd like to write class Applicative2 list => AList list where ... where Applicative2 is just like applicative except that there's an extra parameter everywhere so that it acts on a different kind
18:09:38 <edwardk> orzo: the problem is that the approach where you write instance AList t => Applicative (t s) is inherently brittle. It is making a _much_ broader claim than you want. It is saying that _anytime_ you need an Applicative for something and it takes two arguments, you should use your instance. Regardless of if an AList instance is there or not, it'll chase down this path without backtracking.
18:10:09 <edwardk> it'll overlap with a ton of instances, and overlapping instances across module boundaries are very very brittle and rarely do what you expect or mean
18:11:13 <edwardk> adding backtracking to instance dispatch for the language is not really an option. it leads to all sorts of lack of confluence issues and generally destroys a lot of very nice properties the language enjoys now.
18:11:54 <edwardk> What you _can_ do is make up a newtype SomeList t s a = SomeList (t s a); instance AList t => Applicative (SomeList t s)
18:12:00 <edwardk> and put other instances on that type
18:12:25 <edwardk> that is safe, doesn't end the universe as we know it, and while its a little annoying it easily unambiguous to the type system what instance is being used where
18:12:32 <edwardk> newtypes are used to shape typeclass dispatch like this
18:13:06 <orzo> i can already write AList t => Applicative (t s) and i'm aware it has mega problems.  That's the whole reason for the proposed extension that would let me write Applicative as a superclass for AList instead
18:13:58 <orzo> class *Applicative list => AList list where ... <- notice "class" not "instance"
18:15:26 <orzo> The * on *Applicative is because AList acts on an argument of kind *->*->* but applicative acts on *->*, but there is an implicit class *Applicative that is just like Applicative except it acts on *->*->*
18:16:39 <orzo> The implied *Functor class would be similar to Functor2: class Functor2 f where fmap :: (a->b) -> f s a -> f s b
18:17:00 <orzo> Is there a reason why that extension is impossible or undesirable?
18:17:03 <edwardk> orzo: this proposal actually interacts very poorly with a number of language features in ghc
18:17:38 <edwardk> orzo: note: uhc/ehc already implement what you want
18:17:52 <edwardk> orzo: but this feature doesn't play well with type families
18:18:19 <cmccann> it's easy to overlook just how much work GHC does to figure out instance stuff behind the scenes. things would be a lot less intuitive and automagic if instance resolution was more explicit.
18:18:52 <cmccann> wanting to do stuff like this with instances is exactly an attempt to do something explicitly that GHC can't do itself, and it doesn't play nicely with all those handy implicit bits
18:19:10 <cmccann> to make it work nicely, you have to start by giving up a lot of nice properties that people kinda like having
18:20:03 <orzo> what is uhc/ehc
18:20:20 <edwardk> http://www.cs.uu.nl/wiki/UHC
18:20:52 <orzo> how do they notate the extension?
18:20:53 <cmccann> it's one thing when you just want to do silly type-level computation that results in very predictable instances, but trying to make things more magical in instance selection is not gonna work well :P
18:21:24 <edwardk> my recollection was it was done with just a forall in the constraint
18:21:39 <orzo> i am finding more nad more i prefer FunctionalDependencies to TypeClasses
18:22:42 * hackagebot BiobaseXNA 0.7.0.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.7.0.0 (ChristianHoener)
18:24:00 <elliott> orzo: what? functional dependencies are an extension of typeclasses.
18:24:07 <elliott> er, wait, do you mean typefamilies?
18:24:09 <edwardk> i think he meant type families
18:24:14 <orzo> yes
18:24:18 <orzo> i meant type families
18:25:39 <orzo> how does my proposal present problems for type families?
18:27:01 <orzo> incidentally, there is an extension that lets me write the constraint: forall s. Applicative (list s)
18:27:13 <orzo> but i cannot see any effect of the constraint
18:27:23 <orzo> the extension is ConstraintKinds
18:27:42 <orzo> lets me write things that look like what i want but dont seem to have any effect
18:27:54 <orzo> perhaps that's a bug
18:28:52 <edwardk> orzo: one part is in general there are a lot of problems when type families and their ilk need to resolve to something that includes a quantifier, second currently an expression with a forall in it currently always evaluates out to kind *, so there are all sorts of crazy places in the typechecker that has to change to permit that to vary
18:30:03 <edwardk> orzo: e.g. type family Foo a; type instance Foo Int = forall b. b -- doesn't work, and when you dig into it now it isn't clear what it means in all circumstances
18:30:29 <m3ga> what's the difference between Control.Exception.Base.SomeException and GHC.IO.Exception.IOException? the first seems more general.
18:30:32 <xplat> which introduces the possibility of all manner of entertaining bugs which take a type-level categories library to exercise, but of course the type-level categories library doesn't work because of Any >:)
18:30:38 <edwardk> m3ga: it is
18:31:10 <liyang> Hi lazyIRCs, is there a synonym for flip (.) lying around somewhere?
18:31:14 <edwardk> An IOException is one 'type' of exception, SomeException is broader in scope and can catch more things. IOException is mostly the old system
18:31:19 <cmccann> :t (>>>)
18:31:21 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
18:31:22 <edwardk> :t (>>>)
18:31:23 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
18:31:30 * cmccann was faster!
18:32:04 <orzo> edwardk: im having trouble relating your example to my proposal
18:32:37 <m3ga> i have a function of type IO () where I was using Control.Exception.catch and i now want to change the function to be of type LoggingT IO (), but catch is IO () and i'm not sure what to do.
18:32:43 * hackagebot BiobaseTurner 0.3.0.0 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.3.0.0 (ChristianHoener)
18:32:45 * hackagebot BiobaseVienna 0.3.0.0 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.3.0.0 (ChristianHoener)
18:32:58 <liyang> edwardk: sorry, cmccann was faster. :<
18:33:06 <edwardk> once you start letting forall's drop into the constraint system, they start popping up all over
18:33:16 <liyang> (thanks all.)
18:33:25 <elliott> liyang: there is also (<<<) for flip (flip (.))
18:33:35 <cmccann> elliott: so helpful
18:33:36 <edwardk> elliott: magic!
18:33:47 <elliott> also, there is (.) for (flip (flip (<<<)).
18:33:50 <elliott> ).
18:34:08 <cmccann> :t (<<<) >>> (<<<) >>> (<<<) -- left-biased back-and-forth operator
18:34:10 <lambdabot> Control.Category.Category cat => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
18:34:23 <nbouscal> is <(^_^)> an operator yet?
18:34:29 <cmccann> :t (>>>) <<< (>>>) <<< (>>>) -- right-biased back-and-forth operator
18:34:30 <lambdabot> Control.Category.Category cat => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
18:34:33 <otters> You can't have () in operators
18:34:36 <nbouscal> damn
18:34:38 <otters> :t <(^_^)>
18:34:40 <lambdabot> parse error on input `<'
18:35:06 <edwardk> elliott: mostly just weird how vastly different the fixities are between (.) and (<<<)
18:35:15 <nbouscal> i always enjoyed the penguin subshell notation <() and ()>
18:36:18 <cmccann> edwardk: but (<<<) and (=<<) match
18:37:31 <xplat> if you are going to have an explicit quantifier in the constraint system, though, forall is the one you want, because it goes with the conjunctive-implicational logic that's already there.
18:37:43 <cmccann> edwardk: clearly we should have (<|) and (|>) for regular function application at low precedence, then fix the precedence of ($) to strongly infixl as it should be, to go with (.).
18:37:46 <cmccann> makes sense to me!
18:38:42 <cmccann> that might break some existing code though.
18:38:46 <Eduard_Munteanu> Maybe (.) should be infixr.
18:38:57 <cmccann> not like it matters much
18:39:27 <cmccann> I think infixl is usually more efficient?
18:39:36 <cmccann> or is it the other way around
18:40:00 <cmccann> no, infixl is better
18:40:53 <cmccann> or maybe not. ugh, whatever.
18:40:58 <cmccann> one of them is usually better
18:41:11 <amosr> shouldn't it be inlined anyway..?
18:41:44 <Nisstyre-laptop> So, what good, up-todate sources are there for figuring out Attoparsec, other than the hackage documentation?
18:42:43 <johnw> Nisstyre-laptop: you can use the Parsec docs + Haddocks
18:42:45 <johnw> that's really all you need
18:42:50 <Nisstyre-laptop> fair enough
18:43:04 <Nisstyre-laptop> my grammar is pretty simple anyway
18:47:42 * hackagebot universe 0.3 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.3 (DanielWagner)
18:53:01 <cmccann> dmwit, master of the universe
19:02:43 * hackagebot yesod-auth-account 1.1.0 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.1.0 (JohnLenz)
19:06:36 <liyang> :t lmap :: (a -> b) -> (b -> c) -> a -> c
19:06:37 <lambdabot> (a -> b) -> (b -> c) -> a -> c
19:07:39 <dibblego> Cale: would you mind if I use your fold diagrams on one slide in a presentation?
19:07:43 * hackagebot yesod-auth-account 1.1.0.1 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.1.0.1 (JohnLenz)
19:11:51 <dibblego> would someone mind privmsg me Cale's email address? I appear to have lost it!
19:13:30 <cmccann> just first initial-last name at gmail, innit?
19:14:06 <dibblego> yeah rings a bell
19:15:54 <johnw> cmccann: correct
19:16:14 <dibblego> thanks
19:27:19 <jfischoff> Why do some ghc functions return exceptions as opposed to Either Error ReturnType?
19:27:42 <jfischoff> Are there advantages to exceptions? Are they necessary in some situations?
19:28:16 <cmccann> sometimes it's unavoidable, mostly in IO
19:29:01 <cmccann> sometimes because the error cases are assumed to be so rare that the convenience allegedly outweighs the correctness.
19:29:22 <cmccann> sometimes because people occasionally write stupid code
19:30:38 <jfischoff> cmccann: why would it be unavoidable?
19:31:10 <amiller> anyone used the stream.io.file package?
19:31:13 <amiller> er
19:31:16 <amiller> system.io.streams.file
19:31:33 <amiller> i want to get the whole lazy bytestream from the file
19:31:40 <edwardk> jfischoff: if the error is a potentially transient thing, you don't want an Either result
19:32:09 <edwardk> jfischoff: because that implies that if you re-ran the (pure) ecomputation you'd get the same thing.
19:32:47 <cmccann> jfischoff: well not so much unavoidable as exceptions being the best model of many IO errors
19:33:21 <cmccann> and anyway, in IO you can catch exceptions
19:33:27 <jfischoff> edwardk: so in the case of an IO (Either ..) you would still be against it?
19:33:28 <cmccann> so there's no practical difference vs. Either
19:34:43 <jfischoff> cmccann: in my case I am modeling something that has different pure and IO semantics but I want the same interface
19:35:27 <jfischoff> edwardk, cmccann: I am trying to decide if I need exceptions for FileSystem class: http://hpaste.org/86230
19:35:51 <jfischoff> There would be a pure and IO instance
19:40:18 <jdavis> I am writing a very simple blog application (partly to learn haskell and partly because I really want to get rid of wordpress). Can someone recommend a simple markup language to use that has good haskell libraries and does a good job with code (e.g. syntax highlighting)?
19:40:57 <dibblego> jdavis: you might want to check out hakyll for ideas
19:41:23 <Eduard_Munteanu> I second that. (Perhaps pandoc too, since it's used by hakyll)
19:42:06 <jdavis> Oh, that looks perfect. I'll check it out. Thanks!
19:44:25 <NickC__> Anyone using Slackware?  I'm trying to install cabal-install manually and bomb out with missing dependencies on base and unix.
19:45:22 <jfischoff> NickC_: what version of cabal-install and what version of ghc?
19:45:40 <jfischoff> I bet your cabal-install is too new
19:46:21 <NickC__> jfischoff: cabab-install 0.14.0 and ghc 7.6.2
19:48:21 <jmcarthur> hmmm
19:48:36 <jfischoff> NickC__: you need a newer version of cabal-install. Just get the latest 1.16.0.2 from hackage http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz
19:48:41 <jmcarthur> what would be an appropriate name for this:     data ??? = Continuous | Discrete
19:49:37 <latro`a_> DistType?
19:49:40 <Eduard_Munteanu> jmcarthur: do you need that? Or could you do with an isDiscrete Bool?
19:49:46 <latro`a_> maybe DistTag or something
19:49:46 <NickC__> jfischoff: Thanks, I'll try it.
19:49:52 <copumpkin> eww, Bool
19:50:01 <latro`a_> but yeah, single valued types are kinda kludgy imo
19:50:02 <Eduard_Munteanu> They're isomorphic anyway. :)
19:50:11 <amiller> ok i realized i can't do what i wanted with cereal because i realy expect lazy bytestrings but the modern binary libraires work just fine
19:50:20 <fragamus> Why eew bool
19:50:33 <jmcarthur> Eduard_Munteanu: that's ugly. also, i'm just curious what a reasonable name would be
19:50:36 <Eduard_Munteanu> fragamus: ignore copumpkin and his Agda habits :P
19:50:37 <copumpkin> Bool sucks
19:50:41 <copumpkin> I hate it even in Haskell
19:50:41 <jfischoff> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
19:50:42 <latro`a_> advantage of DistType is that you can add for example Mixed
19:50:45 <jmcarthur> Bool sucks in haskell too
19:50:59 <copumpkin> jmcarthur: have your continuous/discrete designation carry evidence of that!
19:51:01 <copumpkin> >_>
19:51:13 <Eduard_Munteanu> Hehe.
19:51:29 <latro`a_> I'd be inclined to have Continuous and Discrete actually be constructors rather than just flags, anyways
19:51:58 <copumpkin> perhaps he plans on hoisting them to the type level!
19:52:27 <jmcarthur> i actually was thinking along the lines of DataKinds,
19:52:43 <jmcarthur> but i don't think i will actually use DataKinds in this case
19:53:23 <jmcarthur> data Space = Continuous | Discrete   ?
19:54:48 <Rotaerk_> I've got a function for adding an entity to a grid, but the grid supports lookup in both directions, so I'm modeling with Map EntityId Location and Array Location (Maybe EntityId); the function basically does this:  myValue & (myMap . at entityId ?~ location) & (myArray . ix location ?~ entityId)
19:55:16 <Rotaerk_> the problem with this is that it doesn't do proper bounds checking; does anyone have any suggestions for improving on this, apart from just adding an explicit bounds check with an exception on failure
19:57:38 <rodlogic> data Topology = Continuous | Discrete
19:58:25 <jmcarthur> i was thinking about that too but wasn't sure if i was abusing the word. i don't really know much of topology
20:00:20 <nbouscal> I don't think that topology is the proper word there.
20:01:08 <nbouscal> homeomorphisms are necessarily continuous, for starters
20:01:09 <fragamus> Domain
20:04:43 <jfischoff> copumpkin: does spoon have any caveats?
20:04:51 <ab9rf> spoonguard
20:05:14 <nbouscal> jmcarthur: What type of thing is going to be in this datatype? You could have discrete/continuous variables, discrete/continuous distributions...
20:05:22 <copumpkin> jfischoff: it only catches certain kinds of bottoms, but it does most of the ones you'd want to catch in the first place
20:05:38 <Eduard_Munteanu> jfischoff: in fact yes, the caveat is there's no spoon. :P
20:05:59 <copumpkin> yeah, that too
20:06:14 <jfischoff> copumpkin: IO exceptions? (the ones in System.Directory particularly)
20:06:26 <edwardk> jfischoff: depends on how exceptional the behavior is. if you have something that you always want someone to deal with gracefully then Either might be okay, but its inherently more expensive for the success case, and its something that if the user can _ <- … the result meaningfully he might, and then you have an old school c/c++ API sans exceptions where users accidentally omit important error handling and miss that something
20:06:26 <edwardk>  went wrong
20:06:28 <jfischoff> Eduard_Munteanu: =)
20:07:05 <copumpkin> jfischoff: hmm, can't remember. The list of ones we thought of is in the source, which is really short :P
20:07:26 <jmcarthur> nbouscal: it's a property of some euclidean space, hence my earlier idea to call it Space. was wondering if there was a more general word for it though
20:07:26 <cmccann> I thought the idea with spoon was mostly to catch exceptions that are plausible from entirely pure code
20:07:36 <jfischoff> copumpkin: okay that's simple enough
20:07:38 <jmcarthur> nbouscal: well, more general, but precise
20:07:46 <nbouscal> jmcarthur: Space is a pretty general word :)
20:07:50 <jmcarthur> yeah...
20:07:55 <jmcarthur> in context it's okay
20:08:00 <copumpkin> cmccann: it is, but I can't remember if we caved into requests to catch all common catchable exceptions
20:08:03 <jmcarthur> but i don't really like it
20:08:09 <copumpkin> cmccann: it was long long ago :P
20:08:20 <cmccann> haha
20:08:36 <nbouscal> it is weird that we don't have a word for the discrete/continuous dichotomy
20:09:07 <copumpkin> Twenklitude
20:09:09 <copumpkin> duh
20:09:09 <nbouscal> i was thinking something along the lines of 'density' but that doesn't fit either
20:09:11 <nbouscal> hahah
20:09:20 <jfischoff> edwardk: fair enough. In other words there is nothing technically impossible about using Either instead of error. More of a design issue.
20:09:21 <cmccann> pf, continuous things are just discrete things seen from far enough away that it all blurs together
20:09:30 <fragamus> Continuity
20:09:48 <jfischoff> I wasn't sure if because it was doing IO things it had to use exception for some reason
20:09:50 <edwardk> jfischoff: if you want the Either version just use 'try' on the exception version ;)
20:10:12 <nbouscal> cmccann: maths would sure be a lot easier to understand if that were the case :P
20:10:18 <jfischoff> alright cool
20:10:54 <edwardk> jfischoff: there is one technical hurdle. to _use_ the Either version you need to have something you know contains all the exception types you can possibly throw. when the real world starts getting involved through syscalls, etc. it becomes _very_ difficult to classify everything you can get back as an exception
20:12:13 <jmcarthur> and once again i am bitten by the fact that tuples don't have a standard storable instance
20:13:20 <edwardk> jmcarthur: the issue is the 'alignment' requirement in storable
20:13:56 <jmcarthur> hmm
20:14:02 <flebron> read "05e6" :: Int == 5000000. import qualified Data.ByteString.Char8 as C; C.readInt $ C.pack "05e6" == Just (5, "e5"). You can't explain that.
20:14:07 <edwardk> jmcarthur: it makes it awkward to define what the ideal tuple instance would be
20:14:07 <edwardk> e.g. worst case alignment, and then stored with gaps? packed, alignment be damned? etc.
20:14:12 <nbouscal> can you not just say 'true neutral'?
20:14:13 <flebron> Err, "e6" on that last one, not "e5" :)
20:14:27 <jfischoff> edwardk: I don't see how this will affect my particular case. There is a finite number of exceptions that can occur with the System.Directory operations and I can cover them.
20:14:38 <jmcarthur> edwardk: even an arbitrary choice would still satisfy some subset of uses
20:15:03 <cmccann> jmcarthur: what are the tuples for?
20:15:27 <jmcarthur> cmccann: ah just a desire to avoid having to create a type for pixel data
20:16:15 <edwardk> jfischoff: renameDirectory can have EIO, ENAMETOOLONG, ELOOP, ENOENT, ENOTDIR, EROFS, EACCEES, EPERM, EDQUOT, ENOSPC, ENOMEM, EMLINK, EBUSY, ENOTEMPTY, EEXIST, EINVAL, EXDEV, ENOTDIR, EISDIR and anything that the kernel decided to send you today that the ghc guys didn't know about.
20:16:28 <jmcarthur> cmccann: i could reuse the stuff that juicypixels defines, but then i'd depend on juicypixels...
20:16:43 <jmcarthur> cmccann: which is unfortunate since i don't intend to actually put image loading in this library
20:17:03 <jmcarthur> cmccann: only transfering the image data to the gpu
20:17:03 <cmccann> jmcarthur: if it's homogeneous, why not use V3 or V4?
20:17:04 <jfischoff> edwardk: perhaps I am mistaken ;)
20:17:17 <jfischoff> edwardk: okay cool this useful
20:17:26 <jmcarthur> cmccann: because that doesn't make much sense. the rgb components are kind of different from the alpha component
20:17:37 <edwardk> er EACCES
20:18:29 <cmccann> jmcarthur: anyway for uploading to OpenGL I'd just drop the abstraction and go for a vector of whatever type each color value is
20:18:49 <jmcarthur> cmccann: i was going to go even lower and just ask for a Ptr
20:19:09 <jmcarthur> or i was thinking about it anyway
20:19:13 <cmccann> that's pretty much what storable array-ish things are anyway
20:19:16 <edwardk> cmccann: clearly the solution is to finish up all the colorimetry tables in my colorimetry package and turn it into something someone could ship
20:19:37 <fragamus>  Edwardk will you look at my program and make suggestions
20:19:45 <cmccann> oh, you have a colorimetry package?
20:19:51 <edwardk> then use ~500 wavelengths rather than a measely 3-4 coefficients ;)
20:20:03 <cmccann> haha
20:20:14 <jmcarthur> gosh
20:20:14 <edwardk> fragamus: i'm having a hard time finding time to look at my programs let alone other people's this week ;)
20:20:39 <fragamus> K
20:20:40 <edwardk> cmccann: i mostly have datasets at this point, no package per se
20:20:44 <jfischoff> edwardk: so if I understand correctly exceptions are not something that just get thrown by the ghc runtime, they can get thrown by the os?
20:21:28 <edwardk> jfischoff: any time a syscall comes back with an errno set, GHC basically passes that along to you
20:21:48 <cmccann> jmcarthur: anyway the other obvious option is just define a suitable color type and give it a storable instance
20:21:49 <jfischoff> well that's not so bad
20:25:56 <gcr> Hey haskellians, have there been any examples of good games written in haskell?
20:26:17 <Eduard_Munteanu> gcr: hi... I only know about fraps...
20:26:29 <jfischoff> nikki and the robots?
20:26:41 <Eduard_Munteanu> Hm, I think I misremember the name.
20:26:54 <Eduard_Munteanu> It was some procedural content FPS or something.
20:27:43 <copumpkin> speaking of nikki and the robots
20:27:53 <copumpkin> I paid an inordinate amount of money for that if you look at current value of bitcoins
20:28:15 <rohshall_> I am a Haskell beginner. I am writing a simple utility which parses yaml and csv files and generates another set of yaml files. For CSV parsing, I found that there is csv-conduit. But, it uses some advanced constructs which I am not familiar with. How do I get started with understanding it? Here is the github page for csv-conduit: https://github.com/ozataman/csv-conduit
20:28:22 <Eduard_Munteanu> Ah, yes, I do misremember the details: http://www.haskell.org/haskellwiki/Frag
20:29:27 <nbouscal> rohshall_: Are there specific constructs that you're having difficulty with?
20:29:29 <cmccann> copumpkin: sounds more like a matter of not converting enough non-bitcoin currency into bitcoins at the time
20:29:33 <Clint> rohshall_: do you need a conduit or are the convenience functions okay?
20:29:54 <copumpkin> cmccann: I set myself a hard limit and don't feel bad about it :)
20:30:07 <rohshall_> test = runResourceT $
20:30:08 <rohshall_>   sourceFile "test/BigFile.csv" $=
20:30:08 <rohshall_>   intoCSV defCSVSettings $=
20:30:09 <rohshall_>   myProcessor $=
20:30:11 <rohshall_>   fromCSV defCSVSettings $$
20:30:13 <rohshall_>   sinkFile "test/BigFileOut.csv"
20:30:37 <rohshall_> nboucal_: I don't know how $= works
20:31:03 <Eduard_Munteanu> copumpkin: you should've kept paying those Agda bounties :P
20:31:16 <rohshall_> Clint_: I just need CSV parsing. I don't need the rest of conduit, which I believe is for HTML processing
20:31:30 <copumpkin> Eduard_Munteanu: hah no thanks
20:31:40 <Clint> rohshall_: no, conduits are for conduits. but if you just need readCSVFile, you should probably use that
20:32:40 <Eduard_Munteanu> truthpumpkin: speaking of those, did any of them get claimed?
20:32:51 <truthpumpkin> nope, and I'm not gonna pay them :P
20:32:58 <truthpumpkin> I should get around to updating the page
20:33:03 <Eduard_Munteanu> Ok, I got that. :)
20:33:35 <rohshall_> Clint_: where can I find readCSVFile ?
20:33:44 <Clint> rohshall_: http://hackage.haskell.org/packages/archive/csv-conduit/0.5.1/doc/html/Data-CSV-Conduit.html
20:34:37 <fruitFly> how is Haskell network io?
20:34:57 <rohshall_> Clint_: thank you.
20:35:03 <truthpumpkin> fruitFly: ridiculously fast
20:35:57 <fruitFly> is Haskell faster than C in certain areas?
20:36:06 <rohshall_> Clint_: As an side, how can I learn about $= and other advanced Haskell features? I believe it's some custom operator for Monads, but how do I get comfortable reading such code?
20:36:26 <nbouscal> hoogle is great, though it doesn't appear to turn up anything for $=
20:36:27 <Eduard_Munteanu> @quote faster.than.c
20:36:27 <lambdabot> quicksilver says: following 12 pointers could easily be faster than calculating a hash
20:36:27 <Clint> rohshall_: $= is a conduit operator, so read about conduits
20:36:34 <Eduard_Munteanu> @quote faster.than.c
20:36:35 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
20:36:39 <Eduard_Munteanu> That.
20:36:48 <h4199> rohshall_: there is a conduit tutorial on fpComplete's website
20:37:12 <h4199> but conduit operators are specific to that lib
20:37:26 <rohshall_> nbouscal_: thanks for the hoogle tip.
20:37:41 <rohshall_> Clint_: thanks. I will read up on conduits
20:37:45 * hackagebot cabal-db 0.1.1 - cabal-db  http://hackage.haskell.org/package/cabal-db-0.1.1 (VincentHanquez)
20:38:02 <fruitFly> so is nothing faster than  c the?  I remember er a member here showing g
20:38:21 <rohshall_> h4199_: great. fpcomplete tutorials are easier to understand. I will read up.
20:38:22 <Eduard_Munteanu> fruitFly: it can be easier to make faster than C when e.g. parallelism is involved
20:38:46 <Eduard_Munteanu> vs not doing it easily in C at all.
20:39:14 <Eduard_Munteanu> Now sure, if we're talking about best possible, it's hard to beat C or asm.
20:39:20 <nbouscal> lisp can be faster than C in a few areas
20:39:42 <Eduard_Munteanu> (asm much less, considering everything ends up translated to that)
20:40:01 <sw2wolf> nbouscal: lisp faster than c is just a dream ?
20:40:09 <fruitFly> so r there not any functional packages for c?
20:40:21 <fruitFly> . why are you coding Haskell
20:40:31 <nbouscal> sw2wolf: trying to find the source i was thinking of, one moment
20:40:35 <Eduard_Munteanu> We're trolling our employers. :P
20:40:40 <fruitFly> . less coding time but émigré performance?
20:40:49 <flebron> Hi. How can I make GHC use the "count leading zeros" assembly instruction?
20:41:43 <fruitFly> sry hard to type on this phone
20:41:57 * Eduard_Munteanu wonders if C compilers successfully transform plain C code into that
20:42:23 <fruitFly> so why Haskell.. less coding time but practically equal performance for parallelism?
20:42:36 <Eduard_Munteanu> "Oh lookie, he wants LZCNT, let's do it." -- seems rather unlikely or fragile
20:43:01 <Eduard_Munteanu> Or unportable if explicit. :/
20:43:59 <flebron> You could definitely implement it already using Data.Bits.
20:44:03 <jmcarthur> fruitFly: although haskell is one of the faster languages, especially for how high level it is, the best reasons (in my opinion) to use haskell have little to do with performance
20:44:11 <flebron> But it would be interesting if GHC could emit it if the architecture supported it.
20:44:15 <h4199> speed is simply not the only factor in language choice, everyone here probably has their own reasons
20:44:32 <fruitFly> I'm interested in cryptography and networking and have always been interested in Haskell.. but can it also help me take down some evil servers and save the world?
20:44:35 <jmcarthur> fruitFly: i use haskell because it allows me to write high level, declarative, composable code
20:44:35 * Eduard_Munteanu is tired... off...
20:45:44 <nbouscal> sw2wolf: can't for the life of me figure out which book i was thinking of. =/
20:46:04 <nbouscal> fruitFly: coding time is often a lot more important than performance
20:46:10 <fruitFly> jmcarthur I get you... just intelligible looking code
20:46:17 <jmcarthur> fruitFly: well more than that
20:46:22 <nbouscal> computer time is cheap, programmer time is expensive, in a lot of cases
20:46:27 <fruitFly> yes
20:46:34 <jmcarthur> fruitFly: intelligible code, period
20:46:35 <fruitFly> coding time
20:46:40 <h4199> The ability to reason about your code
20:46:44 <nbouscal> also C is dangerous
20:46:50 <fruitFly> y
20:47:03 <jmcarthur> fruitFly: haskell is one of the few languages that largely allow you to use equational reasoning
20:47:28 <jmcarthur> fruitFly: meaning you can do simple substitutions and such like you can in math to derive efficient implementations or prove properties about your code
20:47:41 <jmcarthur> fruitFly: hard to do in a language like C since there is so much state
20:47:44 <jmcarthur> and side effects
20:47:58 <fruitFly> true
20:48:41 <fruitFly> but can Haskell help me take down some evil servers? I'm interested in group and networking
20:49:06 <nbouscal> to me, it's two things: conciseness and reasoning. when you think about it, programming languages exist primarily for those two reasons. We went from machine code to assembler to be able to read and reason about our code. We went from there to C, etc, to write more concise code. That progression has kept going and going, and at the present we have Haskell performing admirably on both counts
20:49:46 <simpson> fruitFly: I, too, am also interested in group.
20:50:22 <fruitFly> Simpson group?
20:50:23 <cmccann> simpson: I prefer monoid
20:50:28 <fruitFly> Haskell?
20:50:33 <jmcarthur> fruitFly: 1. we're not going to help you hack peoples' servers. 2. learning haskell is kind of orthogonal to stuff like that. 3. most security exploits require a lot of low level knowledge, so if it's between haskell and C you are probably better off learning C.
20:50:50 <nbouscal> cmccann: not a fan of inverses?
20:51:00 <cmccann> they're overrated!
20:51:11 <cmccann> also, monoid is so easy.
20:51:16 <nbouscal> might as well be hardcore and just use semigroups
20:51:20 <simpson> fruitFly: Like you said, "group and networking." I don't do networking, but I do like group.
20:51:32 <cmccann> I was just writing some Semigroup instances earlier this evening in fact
20:51:44 <nbouscal> who needs an identity
20:51:51 <truepumpkin> pfft, semigroup is too restrictive
20:51:54 <fruitFly> loll.. auto correct..  I meant crypto
20:52:07 <nbouscal> truepumpkin: just use sets for everything? :)
20:52:12 <truepumpkin> a quasigroup is where it's at
20:52:23 <h4199> How about commutative magmas?
20:52:44 <simpson> fruitFly: Anyway, as somebody who is evil, I won't help you "take down some evil servers."
20:53:01 <simpson> fruitFly: And I'd advise you to not ask for help in public programming channels.
20:53:38 <nbouscal> i like that "Magma in which cubes are well-defined" is apparently the name of something
20:53:44 <nbouscal> we couldn't make up an adjective for that?
20:53:55 <fruitFly> guys.. evil servers are EVIL
20:54:06 <cmccann> must be sturdy cubes. most things melt if you put them in magma. or catch fire.
20:54:07 <simpson> fruitFly: I am also evil!
20:54:12 <fruitFly> anyway.. I'm not seeking technicalities
20:54:22 <nbouscal> cmccann: well-defined doesn't necessarily mean structurally sound :P
20:54:24 <h4199> cubomagmoidal?
20:54:34 <cmccann> heh
20:55:02 <fruitFly> what's the c programming channel #c?
20:55:07 <elliott> ##c
20:55:16 <simpson> fruitFly: You're gonna get insta-banned in there if you ask about this.
20:55:28 <simpson> fruitFly: Maybe you should go outside. Take a walk. Get some fresh air.
20:56:20 <nbouscal> apparently cancellative magmas are a thing. cancellation property but no inverses, no associativity, no commutativity. I can't even imagine how that would be useful
20:56:20 <fruitFly> way too much fresh air for me loll.. just cycled from nam to Cambodia... about to do Thailand... but some of these servers man
20:56:34 <fruitFly> been a real Paine in my butt
20:57:46 * hackagebot robot 1.0 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.0 (ChrisWong)
20:58:46 <simpson> fruitFly: I would like to politely suggest that you have been sitting on tacks, not servers, while bicycling.
20:58:58 <simpson> fruitFly: The simple fix is to remove the tacks from your bicycle seat.
20:59:46 <cschneid> is there a list fun that creates all combinations of an input array of a given length? [1, 2, 3] length2  -> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
20:59:53 <Cale> nbouscal: Well, something which is only slightly less general than that is a quasigroup, and those are iirc, exactly the structures whose multiplication table is a Latin square. So if you're really interested in Latin squares, that might be a way to approach them somewhat more algebraically.
20:59:54 <cschneid> permutation is close, but not quite.
21:00:25 <johnw> cschneid: that question gets asked surprisingly often
21:00:48 <elliott> > replicateM 2 [1,2,3]
21:00:48 <cschneid> I can certainly write it myself, but thats less cool than a library func :)
21:00:50 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
21:01:11 <cschneid> hmm, why the M
21:01:13 <elliott> > filter ((>1).length.group) . replicateM 2 $ [1,2,3]
21:01:14 <nbouscal> Cale: soo… algebraic sudoku generators? or something? haha
21:01:15 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
21:01:15 <cschneid> what monad is happening
21:01:17 <elliott> cschneid: it uses the list monad
21:01:20 <Cale> cschneid: List monad
21:01:27 <elliott> actually, length.groupt here is bad
21:01:34 <cschneid> ahh, cool. Ohh of course. I could have written that with the comprehension syntax
21:01:34 <elliott> > filter (not.null.drop 1.group) . replicateM 2 $ [1,2,3]
21:01:36 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
21:01:48 <johnw> > evalStateT (replicateM 2 $ StateT select') [1..3]
21:01:49 <lambdabot>   Not in scope: select'
21:01:57 <johnw> @let select' [] = []; select' (x:xs) = (x,xs) : select' xs
21:01:59 <lambdabot>  Defined.
21:02:00 <johnw> > evalStateT (replicateM 2 $ StateT select') [1..3]
21:02:02 <lambdabot>   [[1,2],[1,3],[2,3]]
21:02:05 <johnw> hm
21:02:37 <johnw> @let pairs = liftA2 (=<<) zip (tail . tails)
21:02:39 <lambdabot>  Defined.
21:02:41 <johnw> > pairs [1..3]
21:02:43 <lambdabot>   [(1,2),(2,3),(1,3)]
21:02:53 <cschneid> how does that replicateM call know to land itself in the list monad? What type pushes it that way?
21:02:57 <johnw> so much for history diving
21:03:18 <elliott> :t replicateM
21:03:19 <lambdabot> Monad m => Int -> m a -> m [a]
21:03:28 <johnw> because there's a list in the State
21:03:29 <Cale> cschneid: the fact that you're giving it a list
21:03:31 <elliott> m a and you pass it [] Integer
21:03:44 <Cale> > let { pick [] = []; pick (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- pick xs] } in evalStateT (replicateM 2 (StateT pick)) [1,2,3]
21:03:46 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
21:04:11 <Cale> There's a way to use the StateT [] monad to do more precisely what you wanted
21:04:38 <cmccann> > replicateM 2 [1,2,3] \\ getZipList (Data.Traversable.sequenceA . replicate 2 $ ZipList [1,2,3])
21:04:40 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
21:04:42 <cschneid> Cale: as opposed to the create-it-all-then-filter approach?
21:04:42 <Cale> I really think that pick function should be in Data.List, along with a few other related ones.
21:04:45 <Cale> yeah
21:05:03 <cmccann> list applicative minus ziplist applicative :D
21:05:04 <cschneid> for my use, I'm going to stick with the list monad. That's the next one for me to grok
21:05:18 <cschneid> Cale: but I'll copy that impl into a comment and understand it down the line :)
21:05:20 <elliott> there's a good chance you don't have to filter at all.
21:05:25 <elliott> depending on what you're doing.
21:05:56 <cschneid> elliott: I have a function that returns me all hex bytes. [00, 01, 02,03...] and want all 2 or 3 byte pairs
21:06:10 <cschneid> wait a minute, damn it, repeats are fine
21:06:13 <cschneid> haha
21:06:16 <johnw> > filter (\[x,y] -> x /= y) $ replicateM 2 [1..3]
21:06:18 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
21:06:48 <Cale> cschneid: Yeah, in that case, replicateM in the list monad is exactly what you're after
21:06:57 <Cale> cschneid: Also note what sequence does:
21:06:58 <cschneid> Cale: perfect
21:07:01 <johnw> > [ [x,y] | x <- [1..3], y <- [1..3], x /= y ]
21:07:03 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
21:07:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
21:07:04 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
21:07:06 <johnw> that might be the clearest
21:07:33 <Cale> cschneid: Basically, "running" a list in the list monad means to pick an element from it in all possible ways
21:07:54 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return [x,y,z]
21:07:55 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
21:08:14 <cschneid> Cale: ahh, sequence is a shortcut for that same list monad `do` syntax
21:08:20 <Cale> (Just like list comprehensions, but with the benefit that you get all the stuff in Control.Monad for free)
21:08:21 <cschneid> presumably since it was common
21:08:33 <Cale> Well, yeah, sequence :: (Monad m) => [m a] -> m [a]
21:08:38 <Cale> it takes a list of actions
21:08:48 <Cale> and produces an action which runs each in turn
21:08:53 <Cale> giving a list of the results
21:09:42 <Cale> In the list monad, it takes a list of lists, and produces a list which picks an element from each in turn, giving a list of each of the choices.
21:10:01 <Cale> i.e. the Cartesian product of the lists
21:10:27 <cschneid> from what I understand the list comprehension syntax is list monad?
21:10:40 <Cale> Basically, yes.
21:10:50 <Cale> It's not defined like that in the Report, but it could be.
21:11:04 <cschneid> how do you listmonad with the kind of x /= y type restrictions on it?
21:11:11 <Cale> and the MonadComprehensions extension generalises the list comprehension syntax for use with other monads
21:11:12 <cmccann> > (\xs -> zip xs (zipWith (++) (inits xs) (drop 1 $ tails xs))) [1,2,3,4]
21:11:14 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
21:11:21 <Cale> cschneid: Using the function guard
21:11:23 <Cale> :t guard
21:11:24 <lambdabot> MonadPlus m => Bool -> m ()
21:11:46 <Cale> MonadPlus defines an mzero :: MonadPlus m => m a
21:11:55 <cschneid> monadplus huh. it's monad plus a little?
21:12:08 <cschneid> he mzero def?
21:12:15 <Cale> hehe, it's a monad which creates monoids at each type
21:12:27 <Cale> :t mplus
21:12:29 <lambdabot> MonadPlus m => m a -> m a -> m a
21:12:29 <cschneid> welp. I'm sure that makes sense.
21:12:43 <nbouscal> mzero like mempty, mplus like mappend
21:12:49 <nbouscal> i think?
21:12:55 <Cale> So, for each type a, you have mzero :: m a and mplus :: m a -> m a -> m a
21:13:13 <cschneid> sorry, I'm not getting into this now, it's late.
21:13:17 <Cale> and mzero is an identity for mplus
21:13:22 <Cale> and mplus is associative
21:13:23 <johnw> monadplus is a monad with an associated monoid algebra: (Monad m,mzero,mplus)
21:13:24 <cschneid> thank you for solving my problem, and pushing me toward the list monad :)
21:13:33 <Cale> > mplus [1,2,3] [4,5]
21:13:34 <lambdabot>   [1,2,3,4,5]
21:13:40 <Cale> In the list monad, this is just concatenation
21:13:46 <Cale> > mzero :: [Integer]
21:13:47 <lambdabot>   []
21:13:51 <Cale> and mzero is the empty list
21:13:59 <Mortchek> > mplus Nothing (Just 5)
21:14:01 <lambdabot>   Just 5
21:14:08 <Mortchek> > mplus (Just 0) (Just 1)
21:14:10 <lambdabot>   Just 0
21:14:21 <cmccann> johnw: so it's a monoid for monoid objects in a monoidal category
21:14:27 <Cale> hehehe :)
21:14:29 <cmccann> that's a lot of monoids, good thing they are so easy
21:14:34 <johnw> cmccann: ;)
21:14:52 <Cale> cschneid: So, what guard does is just   guard b = if b then return () else mzero
21:15:05 <Cale> cschneid: and in the list monad, this is  guard b = if b then [()] else []
21:15:18 <jfischoff> @quote shachaf
21:15:18 <lambdabot> shachaf says: <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
21:15:27 <johnw> cmccann: is there a special name for a monoidal kleisli category?
21:15:46 <Cale> cschneid: If the condition b is true, there will be a (unique) element of the list guard b for the list monad machinery to choose
21:16:12 <cmccann> johnw: if it's a monoidal category probably its just called that
21:16:18 <Cale> cschneid: and if not, the list will be empty, i.e. will have no choices, which will effectively cut off that branch of the computation
21:16:22 <cschneid> ahh, interesting.
21:16:26 <Cale> (and you'll get something which looks like backtracking)
21:16:28 <cmccann> monoidal closed doesn't have a special term despite being pretty significant
21:16:43 <Cale> > do x <- [1,2,3]; guard (even x); y <- [4,5]; return (x+y)
21:16:45 <lambdabot>   [6,7]
21:16:49 <Cale> > do x <- [1,2,3]; guard (even x); y <- [4,5]; return (x,y)
21:16:50 <lambdabot>   [(2,4),(2,5)]
21:17:21 <cschneid> cool
21:17:28 <cschneid> why am I not using cool features all the time.
21:17:31 <cmccann> > filterM (return [True,False]) [1,2,3,4]
21:17:32 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
21:17:36 <cmccann> > filterM (return [True,False]) [1,2,3]
21:17:38 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:17:52 <Cale> cschneid: In a monad of parsers, mzero will typically be the parser which always fails to parse, and mplus will be disjunction of parsers (i.e. mplus p q will be the parser which succeeds if either p or q can parse)
21:17:53 * cmccann subtly makes it even more cryptic
21:17:57 <ab9rf> cmccann: neet
21:18:37 <ab9rf> :t filterM
21:18:38 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
21:19:50 <cmccann> ab9rf: do you see how it works?
21:20:10 <cmccann> and ignore my obfuscation, the "return" I used is const
21:20:35 <nbouscal> it takes the cartesian product and filters out the falses, giving the power set?
21:20:40 <nbouscal> or something along those lines
21:20:48 <Cale> cschneid: There are a lot of cool things which we get for free from recognising structures like the Monad interface and others along these lines in our libraries. A lot of the time, people try to force the issue a little too much though. Once you know what monads are about, generally, you'll be able to spot them when they're available in the libraries you write, and save yourself writing all the stuff in Control.Monad
21:20:48 <Cale> or whichever other abstraction you spot.
21:21:30 <cschneid> Cale: really my problem is that I'm just not familiar with them, so I don't immediately see that the problem I have is "ohh yeah, List monad"
21:21:32 <Cale> But you generally don't need to set out like that ("I'm going to create a monad today!" isn't typically very effective)
21:21:49 <Cale> But yeah, learning to use specific monads is the first step :)
21:22:00 <cmccann> nbouscal: sort of, it's basically the N-ary cartesian product of [True,False] where N is the length of the input list
21:22:09 <nbouscal> Seems like any time you're using lists there are monady things you can use
21:22:23 <Cale> You can just think of the list monad instance as part of the list library, so you're really just learning an extension of the list library which we get for free from the Monad instance.
21:22:27 <cschneid> Cale: yeah. List, State & Reader seem to be the ones to figure out. IO & Maybe seem to behave well enough for the moment for me.
21:22:32 <cmccann> nbouscal: in the "nondeterministic computation" sense of the list monad, it's basically doing every possible combination of filtering or not filtering each element
21:22:34 <cschneid> Cale: for sure.
21:22:46 <johnw> cschneid: oh, don't forget about Cont :)
21:22:48 <nbouscal> cmccann: right, that's what i was thinking. cool :)
21:22:53 <ab9rf> cmccann: yeah, i figured it out.  neat.
21:22:59 <cschneid> johnw: haven't seen that one around. what.
21:23:14 <nbouscal> i've seen that i'm supposed to learn Cont and still haven't at all
21:23:16 <johnw> Cont has been called the "mother of all monads"
21:23:36 <Cale> cschneid: In the end, the fact that anything happens to be a monad is usually a whole lot less interesting than its other properties, but it's always nice to have when you can get it.
21:24:03 <cschneid> Cale: yeah, it just seems like that list of monads I have is just "libraries I should learn to get stuff done".
21:24:11 <cschneid> moreso than the technical aspects of how they're implemented.
21:24:12 <johnw> yeah, the fact that something is a monad means you get to use a whole bunch of utility functions, do-notation, and rely on some other handy intuitions
21:24:14 <Cale> I still find it a bit funny to talk about the IO *monad*, like the fact that it's a monad is somehow a primary aspect of what it is.
21:25:05 <Cale> It *kind of* is, and without that monad structure, we'd have a bit of a hard time composing bigger programs, but there are other operations that could be used for gluing IO actions together
21:25:23 <johnw> Cale: at the type level, that's the _only_ significant thing about IO, isn't it?
21:25:32 <johnw> otherwise, it's a big old black box
21:25:35 <cmccann> nbouscal: Cont is almost the same thing as Identity! nothing hard there.
21:25:50 <Cale> johnw: Well, there's a whole lot of library functions and primitive IO actions defined
21:26:03 <Cale> johnw: which may not have collective names like Monad does
21:26:06 <johnw> yes, but they don't help you talk about IO per se
21:26:14 <Cale> well...
21:26:22 <Cale> I mean, there's all the exception machinery
21:26:24 <Cale> there's forkIO
21:26:31 <Cale> there's all the terminal IO stuff
21:26:34 <johnw> that's true, I forgot about the exception stuff
21:26:45 <nbouscal> cmccann: except with the whole continuation-passing stuff which i only kind of get
21:26:49 <cschneid> I figure I'll end up learning wtf monadtransformers do at some point too
21:27:00 <nbouscal> cschneid: they let you monad your monads
21:27:05 <cschneid> there's just so many layers of "ohh yeah, we ran into this issue with existing stuff, so we did this new fancy thing"
21:27:06 <johnw> cschneid: monad transformers just take getting used to, but they are not scary
21:27:15 <Cale> cschneid: Yeah, they can be cute sometimes, but I often think they're overused.
21:27:37 <Cale> Maybe not as much now as they were at one point when people were really excited about them
21:28:07 <cmccann> nbouscal: the essential concept is dead simple. you go from a value with type a, to a function that applies a value of type "a" to some other function, like partially applying ($).
21:28:11 <Cale> Monad transformers are type-level widgets that let you turn a monad into another monad.
21:28:20 <cmccann> :t ($ x)
21:28:22 <lambdabot> (Expr -> b) -> b
21:28:29 <cmccann> :t ($ 'a')
21:28:31 <lambdabot> (Char -> b) -> b
21:28:45 <Cale> i.e. they add some structure to your type and redefine the monad operations for a new monad which uses the monad instance on the original one.
21:29:02 <nbouscal> cmccann: so it's just passing around partial applications?
21:29:05 <Cale> and then provide a way to turn computations in the original monad into computations in the new one
21:29:32 <nbouscal> cmccann: what's the benefit over regular composition?
21:29:39 <cschneid> Cale: huh, ok. I'll figure that out later when I'm not sleepy, and when I see an actual use for it. I'm trying to drive my learning by real problems
21:29:56 <cmccann> nbouscal: so Cont r a = (a -> r) -> r
21:29:59 <cmccann> :t flip ($)
21:30:01 <lambdabot> b -> (b -> c) -> c
21:30:04 <cmccann> that's return
21:30:11 <Cale> cschneid: That's a good way to go about it :)
21:30:27 <cmccann> nbouscal: and everything else just juggles stuff around to make everything match up
21:30:31 <Cale> cschneid: At some point, ask me to show you how to make a monadic parser library.
21:30:39 <nbouscal> cmccann: seems easy enough
21:30:52 <Cale> cschneid: I have a reasonably good IRC tutorial for that prepared :)
21:30:55 <cmccann> nbouscal: the benefit is that you can capture that continuation--the function of type (a -> r)--and hang onto it
21:31:00 <cschneid> Cale: :)
21:31:07 <fruitFly> is Haskell the most elegant Shit out there? do any other functional languages compare? what about agda?
21:31:13 <cmccann> nbouscal: since that "r" is the final result type of your computation, that gives you a way to "escape"
21:31:15 <nbouscal> Apparently I need to learn a lot more about parsers, seems like 50% of haskell projects are parsers or layers on top of parsers :P
21:31:35 <nbouscal> cmccann: oh, gotcha
21:31:46 <cschneid> I've been working my way through this: http://www.matasano.com/articles/crypto-challenges/ with haskell. A bunch of number and list manipulation
21:31:51 <cmccann> nbouscal: since a computation in Cont that has a continuation lying around can always ignore the one it's given and call the one it already has
21:31:55 <nbouscal> cschneid: Hey me too!
21:32:08 <nbouscal> cschneid: Except that I just started and haven't yet made any progress. ha
21:32:16 <Cale> fruitFly: Agda is a child of Haskell in a lot of ways. It's Haskell with a more powerful type system, but is less practical for most real world use yet.
21:32:16 <latermuse> when readFile is called, does it put a lock on the file until the readFile is complete?
21:32:23 <cmccann> nbouscal: a continuation represents something like "the rest of the computation"
21:32:27 <latermuse> preventing other programs from reading that file
21:32:31 <cschneid> nbouscal: it's not too hard for the first few. Learned a lot of haskell in it though
21:33:10 <nbouscal> cmccann: huh. ok. i think i might see how that would be useful
21:33:13 <fruitFly> cale e more powerful type system? fundamentally better in some way?
21:33:17 <cmccann> nbouscal: so basically, it's an omnipotent control flow mechanism
21:33:38 <cmccann> nbouscal: because it gives a lifted value total control over what the rest of the computation does
21:33:50 <nbouscal> cschneid: Yeah I'm kind of struggling, but I haven't spent much time on it yet. Having to learn two things at once basically because neither crypto nor Haskell are really in my skillset yet
21:33:53 <Cale> fruitFly: Yeah, in that you can have types parameterised by values (i.e. it is dependently typed)
21:34:01 <nbouscal> cschneid: I've done too much theory reading and not enough actual programming yet :P
21:34:13 <Cale> fruitFly: This quality makes it much more possible to prove useful theorems about your programs in the type system.
21:34:14 <cschneid> nbouscal: luckily it just tells you the solution for the first 7, just for you to implement
21:34:16 <cmccann> nbouscal: the ability to grab and later invoke arbitrary continuations is pretty much a functional version of GOTO
21:34:29 <nbouscal> cmccann: hehe
21:34:32 <cschneid> nbouscal: ping me later if you get really stuck and I can point you in the right direction (I'm always on irc, but often afk)
21:34:44 <Cale> fruitFly: and indeed, you can use it *just* to prove mathematical theorems if you like
21:34:44 <cmccann> except that your GOTOs are first-class so you can juggle them around and do even more confusing stuff
21:34:51 <nbouscal> cschneid: will do. I'm still on problem one figuring out the right types to use and how to use them haha. after I get that sorted properly I imagine I'll make progress
21:35:10 <nbouscal> cmccann: I find that confusing stuff is often powerful stuff
21:35:20 <nbouscal> cmccann: like anaphoric macros in common lisp, for example
21:35:21 <Cale> fruitFly: Proofs are programs and propositions are types :)
21:35:38 <fruitFly> Cale so is agda the pinnacle? anything else? is it only draw back not ready for production?
21:35:51 <Cale> fruitFly: Well, it's certainly *a* state of the art.
21:35:58 <Cale> fruitFly: Haskell is too, in a way
21:36:23 <cmccann> they're both one possible state of different, closely-related arts.
21:36:26 <nbouscal> fruitFly: Different arrows are better for different targets.
21:36:30 <Cale> Haskell has a nicer user interface in a lot of practical ways -- it more often is able to infer types for you than Agda can.
21:36:55 <Cale> and of course, there are lots of handy libraries in Haskell for doing real things that don't yet exist in Agda.
21:37:00 <cmccann> nbouscal: are you familiar with call-cc from other languages?
21:37:19 <Cale> and the Haskell compiler is much farther along in terms of producing more efficient code
21:37:41 <nbouscal> cmccann: I've seen it but haven't used it
21:38:12 <Cale> fruitFly: You can see a lot of the development direction of Haskell as trying to get closer to dependently typed systems like Agda while preserving type inference as much as possible.
21:38:14 <cmccann> :t callCC
21:38:16 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
21:38:27 <cmccann> nbouscal: can you figure out what it does from the type?
21:39:52 <cmccann> nbouscal: in particular, think about where that "b" is and what that requires
21:40:06 <h4199> fruitfly: Idris is another dependently typed child of Haskell, with a slightly different focus
21:40:55 <Cale> Yeah, I like the concrete syntax of Idris better myself. Adga's unicode syntax is cute, but gets obnoxious because people overuse the hell out of it.
21:41:18 <Cale> Agda*
21:41:19 * cmccann starts using unicode in Haskell
21:41:34 <h4199> Does it end up looking like APL or a mathematics/logic textbook?
21:41:46 <nbouscal> cmccann: my brain's getting all bent.
21:42:06 <cmccann> nbouscal: hahaha continuations will do that. want a hint?
21:42:40 <BMeph_> h4199: Yes. ;)
21:42:48 <h4199> Oh dear...
21:43:12 <nbouscal> cmccann: well it looks like it calls the function that it takes. and that function takes a function and returns an m a somehow… so it takes the value and puts it in the context the function would have, but without changing its type
21:43:14 <Cale> http://www2.tcs.ifi.lmu.de/~abel/repos/AgdaPrelude/src/Data/Vec.agda
21:43:14 <cmccann> h4199: it more looks like it's trying really hard to look like one of those, but can't quite manage
21:43:25 <Cale> ^^ there's a typical example of the appearance of Agda code
21:43:41 <Cale> (make sure your browser picks UTF-8 encoding)
21:43:45 <nbouscal> Cale: Oh good, even less readable than Haskell :P
21:44:03 <Cale> nbouscal: It's actually pretty readable
21:44:12 <Cale> It's just kinda obnoxious to write
21:44:17 <nbouscal> i mean pronounceable
21:44:29 <Cale> All the things can be pronounced :)
21:44:35 <nbouscal> haha ok you just have to learn how? :P
21:44:39 <Cale> yeah
21:44:43 <Cale> ∀ is "for all"
21:44:51 <Cale> ∃ is "there exists"
21:44:59 <Cale> (just like in mathematics)
21:45:06 <nbouscal> oh. i know those. my browser must be rendering it wrong
21:45:11 <Cale> ah
21:45:13 <elliott> here's one that should render the utf-8 properly:
21:45:17 <elliott> http://www.cse.chalmers.se/~nad/repos/lib/src/Data/Vec.agda
21:45:17 <Cale> Yeah, check the encoding
21:45:25 <cmccann> nbouscal: that's a good chunk of it, yeah. like I suggested, note that the "b" type is in covariant position, which means that callCC is acting like it has something of type b
21:45:28 <nbouscal> ah yeah, elliott's is better
21:46:02 <nbouscal> pray tell, how do you pronounce _⊛_?
21:46:03 <cmccann> nbouscal: but the implicit quantification means that "b" can be any type, so we know it can't have something of that type (other than _|_)
21:46:13 <h4199> hmm, that isn't as bad as I thought,
21:46:15 <elliott> probably as nothing, given that it's lifting of application
21:46:16 <Cale> nbouscal: 'ap' for 'apply'
21:46:18 <elliott> or as "apply"
21:46:18 <nbouscal> ah
21:46:21 <nbouscal> that works then
21:46:31 <elliott> it's just (<*>)
21:46:45 <nbouscal> ok. that actually is all not too bad
21:46:51 <h4199> no ⧺
21:46:59 <cmccann> nbouscal: so in the (a -> m b) you can conclude that if you apply the function to something of type "a" it will use a continuation to escape because it can't have anything of type "b"
21:47:05 <h4199> they didn't even go all the way
21:47:32 <Ghoul_> Anyone know how to expect either a \n or ; with Parsec?
21:47:37 <nbouscal> overall i like unicode in programming. i even have my vim set to replace lambdas with λs (visually only, not in the actual file)
21:47:54 <nbouscal> cmccann: ohhh. ok
21:47:57 <Ghoul_> Im parsing a language that can and an expression with either a ; (semiSep1) or a newline
21:48:02 <cmccann> nbouscal: so the function you give callCC gives your function a function that takes something of type "a" and then escapes via continuation if applied
21:48:03 <Ghoul_> *end
21:48:25 <Cale> Ghoul_: oneOf ";\n" ?
21:48:41 <cmccann> nbouscal: so the function you give callCC can either ignore its argument, and return something of type "a", or it can apply its argument to something of type "a" which then escapes via continuation
21:48:45 <h4199> λ for lambdas would require a compiler hack unfortunately
21:48:55 <Ghoul_> Cale: ah, yes, thanks
21:49:02 <cmccann> nbouscal: and the whole thing ends up as type "m a"
21:49:38 <cmccann> nbouscal: so basically the function you give it can either return normally, or escape early using a continuation captured at the point where callCC is used. make sense?
21:49:50 <nbouscal> cmccann: I think I get it, theoretically. Actually putting it to use would of course be a whole different story.
21:50:02 <cmccann> nbouscal: yeah no kidding
21:50:10 <aavogt> how in the FFI do you know if a (Ptr a) is nullPtr?
21:50:18 <cmccann> nbouscal: anyway, the name stands for "call with current continuation", which should make sense now
21:50:26 <nbouscal> cmccann: yep
21:50:47 <aavogt> oh I guess it's (==)
21:51:21 <newsham> nbouscal: ever use setjmp/longjmp?
21:51:30 <nbouscal> newsham: Never heard of them
21:51:52 <newsham> then ignore :)
21:52:04 <nbouscal> haha k
21:52:15 <BMeph_> Or rather: "Ever use call/return"? ;þ
21:52:15 <Ghoul_> Cale: looks like if I do that I can't have a list of expressions returned using the regular parsec functions
21:52:26 <cmccann> nbouscal: so basically, when you use callCC it's a sort of checkpoint and the continuation it captures and hands you is a portable GOTO that jumps back to that checkpoint
21:52:47 <Ghoul_> Any idea how to mimic semiSep with something like oneOf ";\n"
21:53:35 <nbouscal> cmccann: Was actually meaning to look into CPS generally since reading something earlier about 'trampolining'
21:54:07 <nbouscal> cmccann: too many things to learn, though. I think I really have to stop learning theory stuff and start actually writing more code.
21:54:09 <cmccann> nbouscal: using a CPS transform is not always the same thing as messing with continuations as such
21:54:42 <newsham> do you write any javascript?
21:54:43 <nbouscal> cmccann: I know way too much now about category theory and algebraic data types and so on and way too little about actually making stuff :P
21:54:51 <cmccann> CPS transform basically switches everything around like Cont does, which can be useful for other reasons such as performance
21:54:52 <newsham> if so, you might know more than you think about continuation-passing-style
21:55:05 <nbouscal> newsham: I use javascript quite a bit, yes
21:55:09 <Clint> Ghoul_: look at how semiSep is defined
21:55:27 <newsham> nbouscal: do you know how in javascript if you want to do anything asynchronous you have to pass in a function that says what to do next?
21:55:33 <newsham> ie. a completion callback
21:55:34 <nbouscal> callbacks, yeah
21:55:42 <newsham> yah, so thats a "continuation"
21:55:52 <newsham> and you're manually writing some code in continuation-passing-style
21:55:56 <nbouscal> there's also deferreds/promises which i need to properly learn about
21:56:11 <cmccann> yep, CPS-ing is a common way to fake asynch stuff
21:56:15 <nbouscal> hm, ok
21:56:33 <nbouscal> yeah i've had to learn a lot of that stuff recently for working with APIs and so on
21:56:44 <newsham> and sometimes you are writing:  setTimeout(1000, function() { doAsyncThing(25, function(x) { console.log("x is", x"); }););
21:57:09 <newsham> a CPS transform makes all your code look kinda like that
21:57:47 <cmccann> I think CPS transform is used for lazy sequences and coroutines in some languages as well
21:58:06 <nbouscal> when i was mucking with coroutines in C# they were kind of similar
21:58:08 <Cale> cmccann: It's actually kind of funny how often GHC is able to compile CPSed code better than it can the original.
21:58:17 <Ghoul_> ohhh SepBy p expr
21:58:19 <Ghoul_> thats much easier
21:58:53 <nbouscal> i have since quit the side project that was causing me to code in C# and my life is so much happier as a result
21:58:54 <cmccann> Cale: isn't there a long tradition of compiling via CPS transform in functional languages?
21:59:01 <Cale> cmccann: there is
22:00:08 <cmccann> it makes a lot of stuff easier for the compiler, assuming tail calls are optimized away
22:00:09 <newsham> nbouscal: so when you're using "callcc" and your code is in CPS form, callcc just gives you the function for "whats next"
22:00:15 <cmccann> it's just horribly painful to write directly in that style
22:00:16 <newsham> and you can call it as you please
22:00:29 <newsham> you get a handle on the callback function
22:00:38 <nbouscal> newsham: that actually does sound much more convenient
22:00:59 <newsham> so yah, javascript already taught you callcc without telling you :)
22:01:09 <nbouscal> hehe
22:01:10 <cmccann> yes, call-cc makes it very convenient to make control flow arbitrarily complicated
22:01:22 <nbouscal> hurrah for arbitrary complexity!
22:01:42 <cmccann> which I gather is kind of a nightmare for API design in languages where call-cc is a baked-in primitive
22:04:09 <cmccann> nbouscal: oh, and also. think about how do notation desugars, and what the second argument to (>>=) looks like
22:04:12 <cmccann> :t (>>=)
22:04:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:05:35 <nbouscal> i actually almost mentioned that
22:05:39 <cmccann> so desugared do blocks end up looking a bit like a CPS transform as well
22:05:47 <nbouscal> when you first posted the type of callcc i almost said, "that function is part of bind"
22:06:06 <nbouscal> but then i got mixed up trying to understand how it fit in
22:06:17 <cmccann> compare the type of flip ($):
22:06:20 <cmccann> :t flip ($)
22:06:22 <lambdabot> b -> (b -> c) -> c
22:06:26 <nbouscal> right
22:06:31 <nbouscal> now it mostly clicks
22:06:33 <Ghoul_> Anyone know how to use parsec to parse an optional reserved keyword, ie: "else" + expr
22:06:56 <cmccann> and yeah, callCC's type looks a bit like a CPS transform on top of code already in a continuation monad D:
22:07:02 <cmccann> :t callCC
22:07:04 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
22:07:26 <cmccann> that expands as something like ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
22:07:59 <Ghoul_> Nevermind, got it! `optional`
22:08:32 <nbouscal> yknow when i was first learning SML, and saw polymorphic types, I thought "these are nifty and natural and easy to understand." And now that I see this stuff I more often think "oh what the hell?"
22:08:39 <cmccann> hahaha
22:08:40 <nbouscal> hehe but i am getting there
22:08:59 <nbouscal> i have been particularly enjoying the lens stuff, with fstab and stab bats and all that silliness
22:09:42 <nbouscal> someone asks what i'm reading and i say "stabby lenses" and they stop talking to me
22:09:48 <cmccann> haha
22:10:33 <cmccann> also, the Lens type looks a bit like Kleisli Cont with the argument order flipped
22:10:49 <nbouscal> for the time being i've just been dodging anything with 'Kleisli' in the name :P
22:11:06 <nbouscal> not that it's any more difficult, just, very category theory-y
22:11:31 <nbouscal> though i do like the fish operators
22:11:49 <cmccann> Kleisli in this context is just the newtype  wrapper over "a -> m b"
22:11:58 <nbouscal> ah, k. easy
22:12:04 <cmccann> so Kleisli Cont is a -> (b -> r) -> r
22:12:34 <cmccann> if you replace the "r"s with weird polymorphic stuff and flip the arguments you get a Lens-y type
22:12:43 <nbouscal> hehe
22:14:55 <nbouscal> i'm trying to find a project that i could be useful to that is also small enough that i could wrap my head around it in a reasonable amount of time
22:15:39 <cmccann> nbouscal: what sort of stuff are you familiar with already?
22:16:15 <cmccann> I mean non-language-specific stuff
22:16:28 <nbouscal> a hodgepodge. my day job is web development
22:16:40 <nbouscal> so i thought yesod, but that's a pretty big codebase to learn
22:16:41 <cmccann> if there's something you know well that isn't covered on hackage rectifying the situation is useful
22:16:52 <cmccann> yeah, general web dev stuff is pretty well covered
22:16:56 <nbouscal> yeah.
22:17:57 <jfischoff> dcoutts: I built HEAD and made a sandbox. Anything in particular you want me to try out?
22:18:25 <cmccann> nbouscal: anything else you're interested in specifically?
22:18:45 <nbouscal> cmccann: i dunno, my interests tend to be pretty broad
22:19:15 <nbouscal> that's probably part of how i ended up learning haskell, i couldn't decide between math and programming :P
22:25:01 <nbouscal> i'm honestly not even that interested in web dev, i just kind of fell into it tbh
22:25:41 <cmccann> nbouscal: yeah I did to, then just as randomly fell into doing other stuff. all C#, though
22:26:21 <nbouscal> i fell into a side project doing C# and just recently dropped it because it was painful and i had no motivation
22:26:42 <nbouscal> it was a phone game project, and i don't play video games heh
22:27:08 <Sonarpulse> I got a project here
22:27:09 <Sonarpulse> https://github.com/Ericson2314/Codec.Archive.CnCMix
22:27:29 <cmccann> I barely play games anymore either but I'm working on improving the gamedev ecosystem in haskell
22:27:35 <cmccann> you could help out with that I suppose :P
22:27:40 <cmccann> but it's in pretty early stages
22:27:42 <nbouscal> yeah i've actually been lurking in haskell-game
22:27:47 <h4199> gamedev ecosystem you say?
22:28:00 <Sonarpulse> I would be interested in cross-platform enet bindings
22:28:01 <cmccann> yeah, wasn't sure how much you'd been listening
22:28:20 <cmccann> h4199: why yes, I do say!
22:28:27 <hpaste> Sonarpulse pasted “Much too slow” at http://hpaste.org/86298
22:28:28 <h4199> That sounds like a tall order sir
22:29:22 <cmccann> h4199: oh yes quite tall, there is a great deal of work to be done
22:29:31 <Sonarpulse> I think the function I just posted is slowing me down, as if I call program (it's like tar) on a single file it runs fine, but if I call it on adirectory it hangs and then over flows the stack)
22:29:41 <nbouscal> cmccann: haven't been listening closely, just observing a bit. mostly coming away with the impression that i would get in the way more than i'd help :P
22:29:57 <cmccann> nbouscal: at this point perhaps
22:30:08 <cmccann> but pretty soon we should have the beginnings of some real code
22:30:17 <cmccann> and it will be easier to jump in and start expanding stuff
22:30:54 <h4199> cmccann: at what level are you working? the tyranny of C++ for "triple A" games seems inescapable
22:31:29 <Sonarpulse> could anybody take a look at the function that I posted?
22:31:30 <cmccann> h4199: I think the goal is something highly practical for indie gamedev
22:32:03 <Sonarpulse> cmccann: I am very much planning on making a game in haskell this summer, actually a new client for an existing game which should help generate traffic but make network much harder
22:32:07 <BonSequitur> Does the Haskell distribution have some searchable manual/documentation functionality, like Perl's perldoc?
22:32:08 <cmccann> shooting for the "triple A" game stuff would be more effort than it'd be worth anyhow
22:32:26 <nbouscal> BonSequitur: Hoogle
22:32:31 <cmccann> @where hayoo
22:32:31 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:32:35 <cmccann> @where hoogle
22:32:36 <lambdabot> http://haskell.org/hoogle
22:32:47 <cmccann> Sonarpulse: what game?
22:32:59 <kthakore> Hello. Good evening folks.
22:33:07 <Sonarpulse> http://aoswiki.rakiru.com/index.php/Ace_of_Spades_Protocol
22:33:08 <cmccann> Sonarpulse: also, join #haskell-game if you want to hear what we're up to
22:33:21 <cmccann> we've kinda commandeered the channel for our gamedev meta-lib project
22:33:32 <nbouscal> kinda?
22:33:34 <nbouscal> :P
22:33:48 <cmccann> kinda insofar as it was basically unused otherwise...
22:33:55 <nbouscal> hehe fair enough
22:33:57 <Sonarpulse> sure I will stop by, I have an ancient C library i want to make a FFI for. at the same time I very much want to use haskell for haskell's asake
22:34:11 <nbouscal> I actually want to write a game too but it's a card game so it's basically an entirely unrelated thing
22:34:15 <cmccann> Sonarpulse: we'll probably be dealing with a fair amount of C bindings as we go
22:34:52 <Sonarpulse> glad to here a major effort is comming about
22:34:54 <kthakore> cmccann: C bindings to SDL perhaps?
22:34:56 <Sonarpulse> actual game: seems good
22:35:03 <Sonarpulse> sorry wrong paste, http://www.youtube.com/watch?feature=player_embedded&v=Fz58zbM-QG0
22:35:05 <kthakore> Which game is this?
22:35:05 <cmccann> we decided not to use SDL for various reasons
22:35:11 <Sonarpulse> interesting
22:35:15 <Sonarpulse> (re sdl)
22:35:30 <Sonarpulse> what about enet?
22:35:39 <Sonarpulse> there is http://hackage.haskell.org/package/HGamer3D-Enet-Binding
22:35:41 <kthakore> I am implementing SDL 2.0 bidings for perl. What reasons for not using it?
22:35:46 <Sonarpulse> but hat is windows only
22:36:13 <cmccann> I'm not sure if we'll be doing anything with network stuff immediately, there are existing networking packages in haskell
22:36:34 <cmccann> feel free to convince us otherwise if you think that's a bad idea
22:36:52 <Sonarpulse> well i have never used enet, but the game I am re-implementing uses enet
22:36:58 <Sonarpulse> so it's very self-serving.
22:37:15 <Sonarpulse> the current client is closed source, but the server is open source ...in python :(
22:37:17 <kthakore> cmccann: oh I don't want to convince otherwise. But the biggest problem I had with launching perl game development was having good cross-platform.
22:37:30 <cmccann> kthakore: cross-platform is a major requirement
22:37:42 <cmccann> enabling commercial indie development is another major requirement
22:37:43 <kthakore> cmccann: so what libraries are you depending on?
22:37:56 <kthakore> cmccann: great! how will you enable developing that?
22:38:05 <cmccann> which, because of murky linker issues and general inconvenience means we rule out anything licensed as LGPL :T
22:38:25 <kthakore> One thing that always makes game dev hard for Indie developers is the packaging and distribution.
22:38:38 <kthakore> How big would a simple Pong game package be?
22:38:53 <kthakore> if it requires all of Haskell + Game scripts + assets
22:38:55 <Sonarpulse> yeah a lot of humble games have quiet shitty everything-in-/opt debian packages
22:40:11 <elliott> cmccann: is there FRP
22:40:16 <kthakore> cmccann: I don't mean to be intrusive. I have been struggling with a lot of this for Perl Game development (http://github.com/PerlGameDev)
22:40:32 <kthakore> and would love to see how you guys are going to solve some of this.
22:40:38 <cmccann> kthakore: no it's fine, just talking in two channels right now
22:40:45 <Sonarpulse> no offence, but I can't there beleive anybody who likes haskell an perl :)
22:40:55 <Sonarpulse> *there exits anyone who..
22:40:59 <cmccann> and I can't answer all your questions well because some of that is filed under "burn that bridge when we come to it"
22:41:01 <Sonarpulse> * and
22:41:04 <cmccann> (that's how the expression goes right)
22:41:26 * BMeph_ thinks Sonarpulse has never heard of Parrot... ;)
22:41:29 <kthakore> Sonarpulse: I like every language equally :) I just want to get better at picking the right language for the job I am doing.
22:41:57 <h4199> may the path forward be lit by the light of your burning bridges*
22:42:19 <cmccann> elliott: official position is "we don't want to prevent people from using FRP"
22:42:28 <kthakore> cmccann: right. One thing I found that could help you get your game development community to kick start itself. Is to write a high quality game and make a book out of it.
22:42:30 <BMeph_> h4199: Would thse Burning Bridges be Jeff or Beau? ;)
22:42:49 <kthakore> cmccann: focus on making a game rather then the tools. I made that mistake with SDLperl and Box2D perl
22:42:51 <h4199> heh
22:43:10 <cmccann> kthakore: I intend to start bashing out simple example games as soon as possible
22:43:11 <kthakore> I am working on a book/game called Zemmings right now
22:43:20 <kthakore> cmccann: simple examples only get so far
22:44:03 <Sonarpulse> that's right, never heard of parrot, but I like my static typing :) Racket would be more of my liking anyways if I wanted some universal dynamically-type language runtime
22:44:28 <cmccann> kthakore: I'll make less-simple games as the library matures
22:44:41 <kthakore> anyway just my two cents. cmccann I just been doing this with perl for about 2 years and getting that community going is the most difficult stage
22:45:00 <kthakore> cmccann: best of luck! I would love to help with the c-bindings
22:45:18 <kthakore> what is the backend library you are binding again?
22:45:32 <cmccann> kthakore: multiple libraries
22:45:39 <kthakore> kk
22:45:48 <cmccann> hammering out a set of dependencies has been our main effort so far actually
22:45:53 <kthakore> well I will keep an eye out at haskell-game
22:45:59 <cmccann> check out the topic links in #haskell-game
22:46:00 <kthakore> I will in the mean time learn more haskel haha
22:46:05 <kthakore> cmccann: will doo
22:46:08 <shachaf> @where game
22:46:08 <lambdabot> I know nothing about game.
22:46:14 <shachaf> @where+ game #haskell-game
22:46:14 <lambdabot> I will never forget.
22:46:17 <Ghoul_> Anyone know how to use parsec to match an expression like (3) as (3 != 0) and (3 < 1) as (3 < 1)
22:46:30 <cmccann> shachaf: sadly someone has "game" as a github project so we couldn't stick with the edwardk naming scheme we wanted
22:46:37 <Ghoul_> The first part seems really tricky..
22:46:38 <shachaf> cmccann: You should add the relevant links to @where.
22:47:52 <Sonarpulse> not to spam, but could anybody help me with figure out why http://hpaste.org/86298 runs so slow?
22:48:17 <shachaf> Sonarpulse: Do you accept help from people who like Perl?
22:49:16 <Sonarpulse> sure
22:49:35 <Sonarpulse> as long as it type checks
22:49:41 <cmccann> perl has a lot in common with Haskell. what other languages egregiously overuse operators and allow overloading on return type?
22:50:02 <Sonarpulse> ha
22:51:53 <Sonarpulse> any idea where the memory leak is shachaf?
22:52:00 <shachaf> Why are you asking me?
22:52:17 <shachaf> I didn't even know there was a memory leak. You didn't mention it.
22:52:28 <Sonarpulse> sorry I did earlier
22:52:42 <Sonarpulse> well sorta
22:52:43 <jfischoff> Sonarpulse: are you filtering  "." and ".." ?
22:52:50 <Sonarpulse> ah shit!
22:52:52 <Sonarpulse> that's it
22:53:11 <jfischoff> I will help you one sec...
22:53:12 <Sonarpulse> I did it in the old version, but then forgot when I rewrote it with maps
22:53:27 <jfischoff> why not do the mapping after?
22:53:39 <Sonarpulse> after the merging?
22:54:01 <jfischoff> write a getDirContentsRecursive :: FilePath -> [FilePath]
22:54:10 <jfischoff> and then do what you want with the filepaths
22:54:26 <Sonarpulse> that would be a nicer signiture
22:54:37 <Sonarpulse> but getDirectoryContents returns a list
22:54:57 <jfischoff> sure mapM over the results
22:55:14 <shachaf> Of course it won't be a lazy list.
22:57:38 <Sonarpulse> well mapping and then unioning should not be that difference
22:58:06 <Sonarpulse> I could strictly never map and just pass the same map around, but I think because of map's efficient union the time-complexity is the same
23:00:44 <hpaste> jfischoff annotated “Much too slow” with “Much too slow (annotation)” at http://hpaste.org/86298#a86300
23:01:09 <jfischoff> Sonarpulse: I just wrote the recursive dir contents part
23:01:40 <Sonarpulse> thanks!
23:02:33 <jfischoff> you could just add a  M.fromList  . map (\x -> (F.stringToId x, x))
23:02:37 <jfischoff> for the other part
23:02:44 <jfischoff> Sonarpulse: np
23:05:02 <hpaste> Rotaerk pasted “Ambiguous type” at http://hpaste.org/86301
23:05:14 <Rotaerk_> is there any way to get something like the entityCount function in there to work meaningfully without adding a functional dependency to HasEntityTable?
23:05:47 <Rotaerk_> I recognize the ambiguity of:  entityCount x, where x is a type with multiple EntityTables in it (and multiple instances of HasEntityTable)
23:06:06 <Rotaerk_> but I would like to be able to somehow specify which instance I mean, for a given call to entityCount
23:06:38 <Sonarpulse> ah yeah I see i was forgetting the subdirectories too
23:06:44 <Sonarpulse> path wise
23:06:59 <Targen> Has anyone noticed strange slowness in HEAD’s GHCi?
23:10:06 <Targen> Any evaluation, however trivial, pauses for about a second before displaying the result.  :set +s (and other tests, such as printing the current time and such) reveals the actual computation was quick and the delay seems to be related to printing.
23:13:28 <jfischoff> Rotaerk_: I think in general those types are ambiguous although in your case they are not.
23:14:06 <jfischoff> Rotaerk_: would like to see if there is a way to get that work but I don't know of one
23:15:31 <jfischoff> wait
23:15:45 <Rotaerk_> jfischoff, well, if I have:  data Foo = Foo (EntityTable Bar) (EntityTable Baz);  --with instances of HasEntityTable Bar Foo and HasEntityTable Baz Foo
23:15:59 <Rotaerk_> and I did this:  entityCount myFoo
23:16:07 <Rotaerk_> it's ambiguous which entity table I want to get the count of
23:16:59 <Rotaerk_> however, it'd be nice if I could somehow resolve that by specifying which I mean, such as redefining entityCount to take an additional (EntityTable entity)
23:17:33 <Rotaerk_> and then calling it like:  entityCount dummyBarTable myFoo, where dummyBarTable is some instance of EntityTable Bar
23:18:41 <Rotaerk_> hmm... maybe I'm working myself in circles and there's a more direct approach to all this
23:23:02 <Zeev> does haskell compiler on windows produce .exe that is dependent on some runtime? (like python27.dll, or .Net redistributable, or it's standalone?)
23:23:05 <Zeev> ?
23:23:27 <shachaf> I think the RTS is statically linked into the executable.
23:23:28 <Zeev> exe that I can run on a fresh installed windows?
23:23:28 <Sonarpulse> I think basically stand alone (besides C libary)
23:23:34 <arbn> Zeev: Haskell, by default, should use static linking.
23:23:36 <Sonarpulse> and other basic stuff
23:23:40 <shachaf> But I don't know how things work on Windows.
23:23:45 <arbn> Zeev: But, test it out for yourself.
23:23:46 <shachaf> Is there some ldd-equivalent you can run on the .exe?
23:23:49 <Sonarpulse> I have distrubuted windows binaries
23:24:05 <latermuse> shachaf: shouldnt it say "Missing ***.dll" when you try to run it?
23:24:11 <Sonarpulse> and people didn't complain (about dynamic linking issues)
23:24:48 <Zeev> ok now imptnt question: can haskell compiler produce a dll with export functions, that I could load and use from a windows application (that might be written in other language) using LoadLibrary() win32 api?
23:24:55 <Sonarpulse> yes
23:24:56 <shachaf> latermuse: Only if you're missing ***.dll.
23:25:11 <shachaf> Yes, but there are caveats.
23:25:20 <shachaf> I think those are mentioned in the user manual and/or wiki.
23:25:21 <Sonarpulse> its not going to be super fun
23:25:49 <Sonarpulse> but hey I'll be doing that soon probably
23:26:55 <Zeev> anyone?
23:27:34 <arbn> Zeev: I know people who compiled call into Haskell DLLs from .NET applications, so yes.
23:27:51 * hackagebot network-simple 0.1.0.0 - Abstract simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.1.0.0 (RenzoCarbonara)
23:27:53 <arbn> who call into Haskell*
23:28:22 <arbn> Zeev: But, you'll need to use the FFI in Haskell to export your Haskell functions as C-compatible, of course.
23:32:51 * hackagebot http-streams 0.5.0.0 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.5.0.0 (AndrewCowie)
23:33:56 <shachaf> @where+ any http://www.vex.net/~trebla/weblog/any-all-some.html
23:33:56 <lambdabot> It is forever etched in my memory.
23:37:52 * hackagebot network-simple 0.1.0.1 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.1.0.1 (RenzoCarbonara)
23:53:39 <monochrom> my new article http://www.vex.net/~trebla/haskell/crossroad.xhtml --- "if null xs then..." vs pattern matching!
23:54:01 <cmccann> :D!
