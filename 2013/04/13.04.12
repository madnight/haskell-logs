00:02:48 <Hannibal_Smith> piezoid, http://www.cs.princeton.edu/~appel/modern/ml/
00:04:45 <piezoid> Hannibal_Smith: yes I should read introductory/general material since I don't have backgrounds on compilers...
00:05:37 <Hannibal_Smith> pib1998, be sure to get che "ML" version of the book, and not the Java one
00:05:43 <Hannibal_Smith> *the
00:07:17 <piezoid> ok thanks, but I would prefer shorter reading, like tutorials
00:08:43 <piezoid> The language I target is quite simple, first order, not functional ...
00:10:11 <Ralith> sometimes hard things take more than a little explaining.
00:16:57 <piezoid> most of the functional implementations of compilers have a fully functional DSL interface with lambda abstractions
00:19:24 <piezoid> maybe I should try to look at some implementations (C--, Sunroof, fay, ...) ?
00:24:34 <neutrino> hi
00:24:40 <neutrino> has anyone here used atom?
00:25:21 <circle> neutrino: reporting in
00:46:40 <huyle`> /nick huyle
00:46:40 <huyle`>  
00:47:51 <huyle`> quit
01:02:28 <neutrino> circle: hi
01:02:38 <neutrino> circle: what hardware have you used for atom?
01:02:50 <neutrino> and what compiler / toolchain?
01:08:23 <huyle> <ignore me>
01:11:42 <huyle> /
01:20:55 <AfC1> m3ga: re your traffic to parallel-haskell, curious why you're focused on such a large set of long running jobs running in a single process. I would have thought distributed (over various systems) would have been a better scaling primitive.
01:23:32 <b__> #blah-ish question: anyone know of EmptySet (the musicians, not the concept), and whether they use Haskell?
01:23:56 <m3ga> AfC: it going to be running on a 16 core machine. when it grows beyond that, it should be trivial to expand it using whatever cloud-haskell is then called.
01:24:36 <AfC> [heh]
01:24:39 <bitonic> is it OK to ask an algorithm question on haskell-cafe?
01:24:48 <shachaf> b__: I feel like there's another channel that would fit better in...
01:24:49 <m3ga> the jobs are also heavily weighted towards 5-10 minutes rather than hours.
01:24:55 <shachaf> If only I could remember its name.
01:25:08 <AfC> m3ga: ah
01:25:16 <b__> let me know when you remember shachaf
01:26:08 <AfC> m3ga: given commodity hardware and where contention is (ie, faster CPUs haven't helped much in many many years, given disk and network and memory bottlenecks), I tend to be thinking in terms of multi-system rather than big iron.
01:26:25 <AfC> (easier said than done, which is why I'm so excited by Cloud Haskell, if we ever get it there)
01:26:52 <m3ga> AfC: i've been given 16 cores to play with and i'm sure 2 is more than adequate for the next 2-3 years
01:27:10 <AfC> m3ga: Fair enough.
01:32:23 <b__> shachaf: the odds of anyone knowing EmptySet here, let alone in #what'sitsname? are tiny, hence asking here first
01:33:25 <bitonic> actually I’ll ask here first.  I need a data structure that let’s me store constraints of the type ‘x < y’ and ‘x <= y’.  now, at each new constraint the consistency of the set of constraints is checked, and the user is notified if the new constraint would make the set inconsistent.  if I have only ‘<’ the problem reduces to building a graph and checking at each step that no cycle is created, but when we add ‘<=’ things are more tricky.
01:33:25 <bitonic> one way I thought is to express ‘x <= y’ as ‘not (x > y)’, and to keep 2 graph, one for the ‘<’ and one for the ‘not >’, and check that there are no overlapping paths.  but that doesn’t seem terribly efficient.  are there known solutions to this?
01:33:33 <b__> some of their tracks are named Function, Return, Monad, Void, etc, which got me wondering
01:34:51 <neutrino> if i have two processes - one is written in haskell and one is written in some other language that has C interop - how can i best communicate between them? this is on linux
01:35:24 <neutrino> some sort of shared memory atomic kind of thing?
01:41:41 <AfC> neutrino: one question you have to ask yourself is how tightly coupled you want them to be. It's always tempting to say "oh, I'm writing both sides, I'll just do something custom" but that makes it hard to debug. You might be better off using something more general (protobuf, json, etc) as the protocol [regardless of the actual transport]
01:42:59 <neutrino> AfC: i'm looking less for a transport protocol, and more for a shared-memory or shared-structure kind of deal
01:47:56 <AfC> neutrino: that's exceptionally hard when you're going cross language, as you've got to attend to memory layout issues. Unless the shared memory code is exclusively in C on both sides and Haskell FFIs out to it.
01:48:28 <huyle> /lastlog
01:48:28 <huyle>  
01:49:14 <AfC> neutrino: even then, your concern needs to be marshelling cost taken as a whole. Shared memory is useless if you have to re-box to use as Haskell objects, or worse have to make zillions of cross boundary calls to access members
01:49:30 <neutrino> AfC: i realize about the memory layout thing
01:49:39 <neutrino> i was hoping there was something like this out there already
01:52:56 <shachaf> huyle: Are you sure a channel with ~1000 people in it is the best one for these tests? :-)
01:59:07 <timbod> neutrino: you said you wanted two processes. But then you say you want shared memory. Why not just have one process and use the FFI to communicate?
02:36:58 * hackagebot xml-conduit-writer 0.1.1.0 - Warm and fuzzy creation of XML documents.  http://hackage.haskell.org/package/xml-conduit-writer-0.1.1.0 (AlexanderBondarenko)
02:46:58 * hackagebot bed-and-breakfast 0.3.1 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.3.1 (JulianFleischer)
02:47:00 * hackagebot clay 0.5.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.5.1 (SebastiaanVisser)
02:49:36 <eikke> BnB, that's a strange name for a package about matrices
02:50:21 <Ghoul_> is MostAwesomeDude around>
02:50:52 <mauke> preflex: seen MostAwesomeDude
02:50:52 <preflex>  MostAwesomeDude was last seen on #haskell 223 days, 9 hours, 47 minutes and 16 seconds ago, saying: Meh. Plane time, I'll figure it out later. Thanks!
02:51:03 <mauke> his plane disappeared
02:52:21 <Ghoul_> lol
02:55:28 <alpounet> eikke, also, no benches
02:59:16 <huyle> /quit
02:59:17 <huyle>  
03:01:11 <Ghoul_> Anyone know exactly how cloud haskell works?
03:01:33 <Taneb> No, it's a complete mystery.
03:01:57 <Ghoul_> Reading the documentation is really confusing. I can't tell if its just a wrapper for network event driven things or whether it actually floats stuff around like most stuff built for the AWS does
03:02:32 <Ghoul_> And, in opinions, would it be useful to implement in a game server, or is it not really designed for that type of thing
03:03:21 <Taneb> (sorry for the sarcasm, but I for one know next to nothing about cloud Haskell)
03:03:48 <Taneb> Possibly best to read http://www.haskell.org/haskellwiki/Cloud_Haskell
03:04:08 <ion> ghoul: Check out this talk from Skill Smatter. http://skillsmatter.com/podcast/scala/cloud-haskell
03:04:49 <Ghoul_> ion: thanks!
03:04:54 <Ghoul_> Taneb: thats just a heap of links \o/
03:05:12 <Taneb> Some of which may have been useful!
03:06:17 <Ghoul_> lol thanks :P
03:06:51 <ouah> hi
03:06:57 <Taneb> Hi, ouah
03:07:05 <ouah> how are tuples implemented in haskell?
03:07:17 <ion> @src (,)
03:07:17 <lambdabot> Source not found. That's something I cannot allow to happen.
03:07:30 <Taneb> ouah, they're built-in
03:07:51 <mauke> as if by: data (,) a b = (,) a b
03:08:02 <ouah> Taneb: but what I mean what the internal implementation, like list is a linked list
03:08:10 <mauke> list is not a linked list
03:08:18 <mauke> list is: data [] a = [] | (:) a ([] a)
03:08:32 <ion> That’s not a linked list?
03:08:35 <Taneb> ouah, I think they're just sort of next to eachother in memory
03:08:37 <mauke> it is :-(
03:08:41 <ouah> mauke: "Haskell lists are ordinary single-linked lists." haskell.org
03:08:50 <Ghoul_> All haskell arrays are linked list
03:08:53 <mauke> ouah: yes, but that's a high-level summary
03:08:55 <mauke> Ghoul_: no
03:08:57 <ion> ghoul: No
03:08:59 <Taneb> Ghoul_, that's very not true
03:08:59 <Ghoul_> slow iteration, fast deletion and insertion
03:09:02 <mauke> ouah: it's not a primitive data structure
03:09:06 <mauke> Ghoul_: no
03:09:11 <Taneb> Ghoul_, [] is a linked list
03:09:14 <Taneb> Array is an Array
03:09:22 <Taneb> Vector is a vector
03:09:24 <Ghoul_> Oh, I meant everything implemented with [ ]
03:09:26 <Ghoul_> Which is list, my bad
03:09:31 <Ghoul_> wrong terminology for haskellians.
03:09:34 <mauke> also, lists have fast iteration but slow deletion/insertion
03:09:47 <mauke> in that they're all O(n) :-)
03:09:56 <ouah> like all linked list
03:09:57 <Ghoul_> Linked lists are slow iteration, fast insertion/deletion afaik
03:10:06 <mauke> what do you mean by "slow"?
03:10:07 <Taneb> ...no?
03:10:14 <Ghoul_> Each link has to be dereferenced
03:10:21 <mauke> O(1)
03:10:23 <Ghoul_> Whereas C-styled lists/vectors have O1 lookup
03:10:30 <mauke> also O(1)
03:10:31 <Ghoul_> Haskell lists are like so:
03:10:36 <Taneb> It's slow lookup, fast iteration
03:10:36 <Ghoul_> [1] -> [2] -> [3]
03:10:43 <Ghoul_> to add between 1 and 2, you break the link and insert
03:10:49 <mauke> you can't break links
03:10:49 <Ghoul_> C arrays are like [123]
03:10:49 <Taneb> Lookup is not iteration
03:10:59 <Ghoul_> to insert, you reallocate and copy.
03:11:12 <Ghoul_> hrrng everything is relative
03:11:16 <Taneb> Ghoul_, you are very misunderstood about Haskell, I am afraid
03:12:11 <Ghoul_> Sigh.
03:12:28 <Ghoul_> You can believe your haskell lists are in-place, if you'd like.
03:12:33 <elliott> iteration is not indexing
03:12:35 <mauke> in place of what?
03:12:45 <Ghoul_> O(n) is much slower than O(1)
03:12:50 <Ghoul_> by n degree.
03:12:50 <mauke> no, it's not
03:12:53 <elliott> [] is very good at iteration because you can consume it incrementally as it is being created, thanks to lazy evaluation.
03:12:55 <mauke> but that's irrelevant
03:13:09 <Ghoul_> When n = 300, its ~300 times slower
03:13:11 <mauke> Ghoul_: both arrays and lists have O(n) interation
03:13:14 <mauke> Ghoul_: nonsense
03:13:14 <Ghoul_> minus the multiplication cost
03:13:19 <elliott> (of course, iteration is never going to be better than O(n) if you need to summarise the entire list)
03:13:25 <elliott> (but in Haskell, you don't always need to)
03:13:30 <ion> ghoul: The O notation isn’t defined like that.
03:13:34 <mauke> heh. s/interation/iteration/
03:13:46 <Ghoul_> ff you're comparing haskell with hasell
03:13:52 <Ghoul_> I'm comparing haskell cost w/ C
03:13:54 <Ghoul_> afk
03:13:57 <mauke> no, you're not
03:14:09 * elliott has no idea what you're comparing, really...
03:14:11 <mauke> you're comparing your misconception of haskell to your misconception of C
03:14:28 <typoclass> Ghoul_: the O() notation rarely tells the whole story
03:14:45 <mauke> and for some reason you think taking O(n) time to visit n elements is "slow"
03:17:10 <staafl> haskellians, what's the best way to read a 'ByteString' from a hex 'String'
03:18:07 <mauke> good question
03:18:19 <Taneb> staafl, if there is no better solution, probably some sort of fold
03:18:55 <mauke> I'd probably do it manually
03:19:03 <Kinnison> I'd be worried about what the encoding was
03:19:20 <elliott> no encoding problems here, it's the other way around
03:20:05 <Kinnison> if the string contains hex chars, presumably pairs of chars encode a byte
03:20:17 <Kinnison> but perhaps quads of chars encode UTF16
03:20:18 <Kinnison> who knows
03:21:45 <staafl> > Data.ByteString.pack $ map (fst.head.readHex) $ chunks 2 "67ae1a64661ac8b4494666f58c4822408dd0a3e4"
03:21:48 <lambdabot>   Not in scope: `Data.ByteString.pack'Not in scope: `chunks'
03:21:48 <lambdabot>  Perhaps you mea...
03:22:06 <staafl> hmm, list processing 101 reminder
03:22:29 <staafl> how do you break [a] into chunks of given length
03:22:29 <typoclass> staafl: how did you end up with hex inside of a String?
03:22:37 <mauke> hexpack (c1 : c2 : cs) = d2i c1 * 256 + d2i c2 : hexpack cs; hexpack _ = []
03:22:39 <staafl> typoclass, the obvious way
03:22:42 <mauke> where d2i = digitToInt
03:22:57 <staafl> it's the has of somebody's password
03:23:01 <staafl> * hash
03:23:52 <staafl> mauke, neat, thanks :-)
03:24:11 <typoclass> staafl: you mean it's bunch of of 0-9a-f? not \123\456?
03:24:30 <staafl> yeah, that's what I meant
03:26:12 <Taneb> > either snd id . foldr (\c -> either (Right . uncurry (B.cons . (+) ((* 16) . fromIntegral $ digitToInt c))) (Left . (,) (fromIntegral $ digitToInt c))) (Right B.empty) $ "C1"
03:26:14 <lambdabot>   Not in scope: `B.cons'
03:26:14 <lambdabot>  Perhaps you meant one of these:
03:26:14 <lambdabot>    `BS.cons' (impor...
03:26:26 <Taneb> > either snd id . foldr (\c -> either (Right . uncurry (BS.cons . (+) ((* 16) . fromIntegral $ digitToInt c))) (Left . (,) (fromIntegral $ digitToInt c))) (Right BS.empty) $ "C1"
03:26:28 <lambdabot>   "\193"
03:26:33 <Taneb> > either snd id . foldr (\c -> either (Right . uncurry (BS.cons . (+) ((* 16) . fromIntegral $ digitToInt c))) (Left . (,) (fromIntegral $ digitToInt c))) (Right BS.empty) $ "23"
03:26:35 <lambdabot>   "#"
03:27:44 <Taneb> That's how I would do it, but it's very messy
03:27:56 <Taneb> There is almost certainly a cleaner solution
03:29:20 <Taneb> It uses Either to swap between ByteString and (Word8, ByteString) to hold the partials. It does not keep partials, I think it drops them from the beginning
03:29:36 <Taneb> It's also O(n^2)
03:29:39 <Taneb> I think
03:29:42 <Taneb> Which kinda sucks
03:30:30 <staafl> any advantages over mauke's approach?
03:30:52 <ion> Convert to a huge Integer using Numeric.Lens.hex, then unfoldr with quotRem and guard (a /= 0), then pack the list to a ByteString. ;-)
03:30:55 <staafl> mauke, btw did you mean  "d2i c1 * 16", not *256?
03:30:56 <Ghoul_> zz
03:31:09 <staafl> or do I need to go drink some coffee
03:31:10 <Ghoul_> I doubt decaying it down to assembly instructions would help anyone here
03:31:20 <Ghoul_> because I doubt anyone dabbles at the machine level
03:31:37 <Taneb> staafl, mine's a bit rubbish to be hones
03:31:38 <Taneb> t
03:31:43 <mauke> staafl: oops
03:31:56 <Taneb> It'd be much more efficient to convert to ByteString once at the end
03:32:02 <staafl> mauke, no biggie :-) it works like a charm anyway
03:32:14 <hpaste> mbuf pasted “Better rewrite?” at http://hpaste.org/85639
03:32:17 <staafl> s/anyway/except for that
03:32:21 <staafl> Taneb, thanks anyway
03:37:45 <edwardk> startling: parsers and trifecta both use try.
03:38:04 <startling> edwardk: yeah, I found it. I didn't have .Combinators imported
03:38:11 <edwardk> startling: re: Token, that snippet shows how you'd make an identifier style for your own language
03:38:37 <edwardk> by taking an existing one, modifying it and then you can make a couple of combinators locally to avoid repeatedly referencing it
03:39:13 <startling> edwardk: but haskellIdentifierStyle doesn't exist anywhere?
03:39:47 <edwardk> startling: woops, it should be haskellIdents
03:40:12 <startling> edwardk: aha
03:40:20 <startling> (where's that?)
03:40:27 <circle> neutrino: reporting in
03:40:52 <Ghoul_> fyi
03:40:53 <Ghoul_> http://pastie.org/private/eug2pi5nmhv1osfljxn3yw
03:40:59 <edwardk> startling: fixed the docs in HEAD just now
03:41:08 <neutrino> circle: hi
03:41:11 <edwardk> i'll push them to hackage when there is something more substantial
03:41:20 <neutrino> circle: so what did you do with atom ?
03:41:21 <Ghoul_> lookup O(n) in haskells loss, iteration equal for both
03:41:35 <startling> edwardk: cool. thanks!
03:57:00 * hackagebot log-domain 0.6 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.6 (EdwardKmett)
04:01:12 <davorak_> I just tried to install pipes-3.2.0 on ghc-7.0.4, it is rejected because of the `Trustworthy` extension.  Is there a flag to tell ghc to ignore certain extensions?
04:01:46 <alpounet> davorak_, you can cabal unpack pipes-3.2.0
04:01:50 <alpounet> edit the cabal file to remove this
04:01:54 <alpounet> and cabal install
04:02:00 * hackagebot compensated 0.3 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.3 (EdwardKmett)
04:02:02 * hackagebot feldspar-language 0.6.0.3 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.6.0.3 (AndersPersson)
04:02:32 <davorak_> aplpounet: yep, I was looking for a solution I could automate though so i do not have do it manually in the future as well.
04:02:33 <alpounet> or ideally, you'd submit a pull request to pipes that only shows the Trustworthy flag if the ghc version installed on the user's computer supports it
04:02:45 <edwardk> davorak_: sadly no. pipes would need to put that pragma inside of a CPP guard
04:02:59 <edwardk> davorak_: i'm careful to do that in all of my packages at least
04:03:07 <edwardk> i'm surprised it isn't done in pipes
04:03:55 <alpounet> edwardk, don't you use 'if impl(ghc >= 7.4)' ?
04:04:06 <edwardk> pretty much
04:04:08 <edwardk> well
04:04:11 <alpounet> davorak_, if impl(ghc >= some_version) is what you're looking for
04:04:13 <davorak_> edwardk: Thanks I thought that might be the method to fix it.  I will put in a pull request on pipes to fix it for future versions.
04:04:13 <edwardk> well
04:04:25 <edwardk> i avoid doing it that way because putting it in the cabal file is more brittle
04:04:31 <edwardk> older cabal versions don't know about that extension
04:04:42 <edwardk> so its more robust for me to put a CPP guard in the file
04:04:55 <alpounet> right, your code is used on quite old installs
04:05:32 <edwardk> alpounet: well, the other problem is that cabal lags pretty far behind GHC in some extensions. i _have_ to do it the other way or cabal whines about unknown extensions at me all the time =(
04:06:02 <edwardk> for instance i tried embracing the other-extensions field in cabal for documentation purposes if nothing else, but its just a minefield of crap it doesn't know about
04:06:05 <alpounet> right, cabal 1.16 is so 2012
04:06:08 <elliott> why on earth doesn't cabal just use strings to represent extensions?
04:06:28 <edwardk> elliott: it does for ones it doesn't know about but it goes out of its way to whine about extensions it doesn't know
04:06:30 <elliott> this kind of compatibility-problem-by-design baffles me
04:06:42 <dcoutts> it's just a warning
04:07:10 <edwardk> dcoutts: yes. and it is a warning i can avoid if do it another way. given that every user of mine sees that warning, screw it. i'll do it the other way
04:07:10 <elliott> won't GHC do its own warnings for invalid extensions?
04:07:59 <dcoutts> elliott: no, it would fail in that situation
04:09:58 <edwardk> In theory you could avoid the whole warning issue by extending cabal to put something on the hackage server like a list of known extensions that it pulls when you cabal update. Then you could be much more liberal about the set of extensions you accept without warning, and I could bring myself to use the feature.
04:10:21 <dcoutts> edwardk: mm
04:10:23 <edwardk> But I accept that I'm one user, and that is a fair bit of implementation effort
04:10:49 <alpounet> edwardk, fortunately, you're very productive heh
04:11:02 <dcoutts> it does seem mad that what's intended to be helpful (avoiding mistakes in extension names) pushes people into using inferior mechanisms
04:11:26 <dcoutts> edwardk: someday we'll start warning if you list extensions in .hs files that are not in the .cabal file ;-)
04:11:34 <edwardk> dcoutts: I tried to pre-emptively embrace the mechanism.
04:11:44 <edwardk> I just found that in practice it drove me nuts
04:12:11 <edwardk> The list in the cabal file always fell out of date because I had no tool other than grep to maintain it with
04:12:20 <mauke> yeah
04:12:29 <mauke> why would I list extensions in the .cabal file in the first place?
04:12:38 <dcoutts> mauke: they're dependencies
04:12:40 <dcoutts> of a sort
04:12:49 <dcoutts> edwardk: so if cabal did that check for you, that'd actually be helpful
04:12:50 <mauke> not really
04:12:52 <edwardk> I did start switching to one LANGUAGE pragma per line so i could easily grep for all of them and sort them
04:13:15 <dcoutts> mauke: they really are, and they're checked at configure time
04:13:34 <dcoutts> mauke: they're not currently used in the solver, but could be (like C libs and tools are not yet considered by the solver)
04:13:37 <edwardk> dcoutts: yeah if there was at least a flag in the meantime to do that missing other-extensions check before you turn it on globally that would be useful
04:13:41 <mauke> dcoutts: so what's the point?
04:14:15 <dcoutts> edwardk: you want to pre-emptively fix :-)
04:14:27 <dcoutts> edwardk: could do it as part of cabal check initially
04:14:31 <edwardk> Of course, then no matter what I do it'll complain at me about the stuff that isn't standardized though. GHCForeignImportPrim, UnliftedFFITypes, etc.
04:14:47 <elliott> edwardk: i didn't know those even existed
04:15:07 <edwardk> hence why i'd like to have some way for cabal to find out about extensions that didn't exist when that version was compiled ;)
04:15:28 <dcoutts> edwardk: there's no particular reason those should not be in the standard list, though UnliftedFFITypes arguably ought to have a GHC prefix, like GHCForeignImportPrim since it really is totally ghc specific
04:15:30 <edwardk> elliott: they arise when writing custom STG code to make things fast
04:15:38 * dcoutts implemented GHCForeignImportPrim
04:15:50 <edwardk> dcoutts: yeah i remember. it has been quite useful =)
04:15:57 <dcoutts> edwardk: you mean cmm code
04:16:02 <edwardk> er sorry, derp
04:16:13 <elliott> hm, you can do that?
04:16:13 <dcoutts> mauke: I don't understand your question
04:16:21 <elliott> edwardk: reflection should be written in Cmm!!!
04:16:22 <edwardk> elliott: yeah check github.com/ekmett/rounded
04:16:25 <elliott> 100% speed
04:16:28 <davorak_> mauke: If you want to be able to track all of your depdencies in the cabal file to make sure it is easy to deterministically reproduce a build environment they you need to include pragma.
04:16:31 <dcoutts> elliott: out of line cmm primops
04:17:07 <mauke> davorak_: what do pragmas have to do with my build environment?
04:17:11 <edwardk> elliott: sadly you can't pass dictionaries or boxed types to cmm with it currently (I prodded JaffaCake to lift the latter restriction a while back though, so I think thats fixed in HEAD)
04:17:45 <randomclown> why is ghc not happy about \case { 0 -> 1; 1 -> 0; x -> x }
04:17:46 <dcoutts> mauke: language extension deps are also kind-of dependencies on the compiler, ie "I work with any compiler but it must do H2010 + foo + bar"
04:17:57 <randomclown> "parse error on input case"
04:17:59 <edwardk> mauke: not every compiler is GHC. By putting the other-extensions in the cabal file you provide more information about what features you require of the compiler to build.
04:18:12 <mauke> dcoutts: and if the dependencies aren't met, will cabal download another compiler for me?
04:18:15 <elliott> edwardk: mm
04:18:16 <dcoutts> and even for ghc, it means you're implicitly putting in a min version dep on ghc
04:18:29 <elliott> randomclown: did you turn on the LambdaCase extension?
04:18:39 <edwardk> mauke: without something like other-extensions you wind up getting and downloading packages you can't build. With other-extensions the system could give you an error much earlier.
04:18:44 <randomclown> elliott: yeah
04:18:49 <dcoutts> mauke: I said it's a dep that's currently not considered by the solver, but it could be (just like it could consider C lib deps)
04:19:05 <Saizan> mauke: it might want to pick a different version of the lib that doesn't need the extra features
04:19:06 <elliott> randomclown: are you typing this into GHCi?
04:19:07 <mauke> dcoutts: define "consider"
04:19:13 <elliott> turning the extension on in your file isn'te nough
04:19:14 <dcoutts> mauke: no it will not change the compiler, but it can influence other choices, or just give you a better error
04:19:22 <davorak_> mauke: If cabal does not know what pragma are used then it does not know what ghc versions are useable, so if I start with a cabalize package cabal has to try to build it with a particular version of ghc to know weather or not it will build.
04:19:37 <dcoutts> mauke: e.g. it might not install an optional dependency, or it might pick an older version of a package
04:19:44 <mauke> davorak_: that is always the case, regardless of pragmas
04:19:52 <luite> dcoutts: is it possible to have conditions based on available extensions with cabal, like what if(impl(...)) things are often used for now?
04:20:13 <dcoutts> luite: it is, but as I said, the solver does not yet look at them
04:20:21 <luite> oh ok
04:20:53 <randomclown> elliott: no I'm using it in a map, like map (\case { 0 -> 1; 1 -> 0; x -> x}) xs, strangely it works in ghci
04:20:56 <dcoutts> luite: like it doesn't look at C libs, or tools
04:21:29 <davorak_> mauke: ? You mean if the package is broken is some other fashion.  I am assuming a working package in all other regards the a pragma ghc version mismatch.  Which is what I just encountered and brought me to irc to found an automatible solution.
04:21:46 <elliott> randomclown: hpaste your file?
04:21:47 <luite> dcoutts: hmm, but can i get some cpp define iff, say, TypeFamilies is supported?
04:22:35 <dcoutts> luite: I think even that we don't do yet
04:22:38 <randomclown> elliott: nvm I deleted the .hi file
04:22:42 <randomclown> recompiled fine
04:23:14 <luite> dcoutts: ah that would be useful to have, i think
04:23:14 <dcoutts> luite: the way it would work is you say: if flag (blah) { other-extensions: blah; cpp-options: -DBlah }
04:23:24 <randomclown> -fforce-recomp everytime
04:23:57 <dcoutts> luite: and we'd consult the known extensions when resolving the conditionals. I think currently we only check the extensions at configure time after resolving all the conditionals.
04:24:15 <dcoutts> luite: but this would have to be done in the solver
04:25:09 <dcoutts> luite: so the project would be to generalise the solver's notion of dependency, and cover C libs, tools, extensions, etc
04:26:25 <davorak_> Thanks for the insights.
04:26:32 <alpounet> that would be awesome
04:27:22 <luite> dcoutts: ah right, sounds useful. i tend to think of flags as input from the user to the build system, but they are already configured automatically aren't they?
04:27:33 <dcoutts> luite: they are
04:28:33 <dcoutts> luite: an independent extension that'd be useful is a syntax for conditions that are a deterministic choice based on the choice of deps, and so no extra user influence is needed
04:29:21 <dcoutts> luite: e.g. we can do things now like:  if flag(foo) { build-depends: foo >= 2; ... } else { build-depends: foo < 2; ... }
04:29:35 <mauke> "The flags mechanism is rather generic, but most of the time a flag represents certain feature, that can be switched on or off by the package user." ಠ_ಠ
04:29:48 <dcoutts> luite: the flag foo there is redundant, it's determined completely by the choice of the version of the foo dep
04:30:19 <dcoutts> and it'd be good to avoid having a named flag there
04:30:25 <luite> ah yeah
04:30:26 <startling> edwardk, the default token parsers seem to treat newlines and spaces the same way. Might I request a parser transformer that only deals with spaces?
04:30:30 <dcoutts> because it doesn't represent a meaningful user choice
04:30:59 <edwardk> startling: throw in an issue. a patch might be a faster way to get it though =)
04:31:26 <startling> edwardk: cool. I *think* I understand the library well enough to do it.
04:31:42 <dcoutts> luite: the flags stuff is a slightly odd-looking logic programming language
04:32:09 <edwardk> dcoutts: can you put an if (foo <= 2) in there?
04:32:25 <dcoutts> edwardk: no, but that's the kind of syntax I've been considering
04:32:47 <luite> dcoutts: i have to admit that i only realized they were resolved automatically to some extent when i started writing patch for the ghcjs compiler flavour and had to look at -v3 output a lot :)
04:32:52 <mauke> who maintains the cabal manual?
04:32:53 <dcoutts> edwardk: and it'd mean exactly the same thing as what I wrote above
04:32:54 <edwardk> dcoutts: so in the meantime if i want to guard behavior based on a version number my only vehicle is a flag or a custom Setup.lhs, no?
04:33:11 <alpounet> where can I find documentation on UnliftedFFITypes and GHCPForeignImportPrim?
04:33:25 <edwardk> Sure. I currently just wind up with a bunch of flags for that stuff
04:33:55 <edwardk> e.g. the lens cabal configuration has become somewhat epic =)
04:34:03 <dcoutts> edwardk: yes, or for simple cases using the cpp macros that cabal provides
04:34:05 <edwardk> fortunately i was able to factor most of them out into smaller packages
04:34:11 <edwardk> sure
04:34:20 <edwardk> i use the cpp macros all over the place
04:34:41 <dcoutts> mauke: it's not very well maintained, but in theory same people who maintain the lib+tool
04:34:56 <dcoutts> mauke: I've got a half-rewritten version of the manual if you want to pick it up
04:34:57 <mauke> as far as I can tell, all flag-related hyperlinks are broken
04:35:14 <dcoutts> oh, someone did patch those up recently
04:35:34 <dcoutts> and changed it so it'd be more robust to ghc manual changes
04:35:48 <mauke> huh? what does the ghc manual have to do with it?
04:35:51 <edwardk> mauke: that is actually why i factored transformers-compat out of lens, because otherwise the 3 modules it exports that don't get compiled on the version of ghc on hackage wind up at the top of the module list for lens. =(
04:36:08 <dcoutts> mauke: oh sorry, I was thinking of extensions
04:36:28 <dcoutts> mauke: which flag links?
04:37:22 <edwardk> dcoutts: if you have modules that are only compiled with a given flag turned on, the cabal main page for the package winds up getting built with hyperlinks to them anyways
04:37:33 <mauke> dcoutts: http://www.haskell.org/cabal/users-guide/developing-packages.html "Note that this value may be [overridden in several ways]."
04:37:35 <edwardk> dcoutts: even if that flag isn't used. so they wind up dead links
04:38:00 <mauke> dcoutts: "If a package descriptions specifies configuration flags the package user can [control these in several ways]."
04:38:02 <dcoutts> edwardk: that's a more general problem, hackage doesn't know what modules have docs at all
04:38:39 <dcoutts> edwardk: but note that libs should not change the modules they provide based on flags, that's changing the api, which isn't allowed
04:38:42 <mauke> dcoutts: http://www.haskell.org/cabal/users-guide/installing-packages.html#controlling-flag-assignments "Flag assignments (see the [resolution of conditions and flags])"
04:38:51 <edwardk> sure, but in that case i wind up with nothing i can do to fix it. so i've taken to just factoring those kinds of modules out into separate packages for a better user experience
04:39:01 <edwardk> dcoutts: Let me give a concrete example.
04:39:10 <edwardk> transformers from 0.2 to 0.3 added 3 modules.
04:39:20 <edwardk> I wind up needing to support older platforms without those modules
04:39:23 <dcoutts> edwardk: which is the right thing to do, you can depend on a separate package, you can't depend on "package foo with flag bar"
04:39:49 <edwardk> So I provided compatibility shims for them in a small package transformers-compat which exports them if its transformers dependency is older than 0.3
04:40:07 <edwardk> then you can use transformers and transformers-compat and you can work perfectly well with older transformers versions
04:40:40 <edwardk> That is an example of such a conditional export that exists solely for backwards compatibility with older versions of a package. In net between transformers and transformers-compat you see the same module set across all version
04:40:53 <dcoutts> edwardk: so the problem there is that the docs for that package are empty right?
04:40:57 <edwardk> I'm not depending on any flag set
04:41:37 <edwardk> Well, originally it was lens itself that was exporting those compatibility modules. I moved them out into a separate package, because that particular compatibility shim was more useful to others
04:42:10 <edwardk> Note: I'm overall pretty much okay with this situation. Unlike the extensions one. ;)
04:42:17 <dcoutts> edwardk: and a solution might be to upload your own docs that you built for that package (since you know that you'll only get anything when it's built against 0.3 of whatever)
04:42:33 <edwardk> dcoutts: yeah. if hackage 2 lets us upload our own docs, etc. this issue goes away
04:42:35 <dcoutts> edwardk: which you can do with the new hackage server
04:42:40 <edwardk> ep
04:42:41 <edwardk> er yep
04:43:12 <edwardk> Custom doc uploads will help out in a lot of ways
04:43:31 <startling> edwardk, is there a reason the TokenParsing (Unspaced m) has a MonadPlus m constraint? looks like it's possible with just TokenParsing m
04:43:39 <startling> oh, empty, never mind
04:43:48 <edwardk> startling: If you can make it work, do it! =)
04:43:51 <dcoutts> mauke: ah, you mean intra-doc links within the manual
04:44:04 <mauke> yes
04:44:07 <mauke> are there any others?
04:44:08 <dcoutts> mauke: patches accepted, it's in the git repo
04:44:49 <mauke> dcoutts: what git repo?
04:44:55 <startling> edwardk: k
04:44:56 <dcoutts> mauke: the cabal one
04:45:21 <dcoutts> edwardk: the related issue is that hackage makes links for all exposed modules, ignoring things like haddock hide pragmas
04:45:38 <edwardk> dcoutts: yeah. i got around that by just never using haddock hide ;)
04:45:52 <dcoutts> we should be able to do something about that in the new server, since we can see what files are in the doc bundle
04:45:58 <edwardk> I'd rather have a doc link go to a suboptimal place than be dead
04:46:05 <mauke> dcoutts: the docs link to trac
04:46:44 <dcoutts> mauke: https://github.com/haskell/cabal
04:56:17 <vincenzo68> ciao
04:56:22 <vincenzo68> !list
04:56:22 <monochrom> vincenzo68: http://hackage.haskell.org/packages/archive/pkg-list.html
04:57:48 <elliott> monochrom serves another happy customer
05:01:10 <bitonic> ehe
05:02:25 <bitonic> I rephrased my previous question here: <http://cstheory.stackexchange.com/questions/17237/verifying-consistency-of-strict-and-non-strict-partial-orders-constraints>.  I wonder if that’s the right place
05:16:37 <startling> edwardk: you have a pull request. :)
05:17:04 * hackagebot xml-conduit-writer 0.1.1.1 - Warm and fuzzy creation of XML documents.  http://hackage.haskell.org/package/xml-conduit-writer-0.1.1.1 (AlexanderBondarenko)
05:17:58 <edwardk> startling: thanks =)
05:18:52 <edwardk> startling: welcome to the repository. you now have commit access
05:19:08 <startling> heh
05:19:15 <startling> wow, I'm #2 in the scoreboards!
05:22:49 <edwardk> startling: shipped as part of 0.7
05:22:56 <startling> edwardkk, great!
05:24:55 <neutrino> hi
05:25:21 <neutrino> how is cabal with different versions of libs nowadays? is this whole cabal-dev-like stuff implemented in cabal now?
05:25:45 <startling> neutrino: nope
05:25:54 <neutrino> hmm
05:26:04 <neutrino> what's the status of that?
05:26:11 <latermuse> how do i pack a string into a ByteString?
05:26:39 <startling> @hackage utf8-string -- latermuse
05:26:39 <lambdabot> http://hackage.haskell.org/package/utf8-string -- latermuse
05:26:52 <plhk> how to do whileM :: Monad m => (a -> Bool) -> m a -> m [a] right?
05:27:05 * hackagebot parsers 0.7 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.7 (EdwardKmett)
05:27:27 <plhk> i can write it with recursion but it feels like i'm reimplementing the wheel
05:29:48 <bitonic> @hackage monad-loops -- plhk
05:29:49 <lambdabot> http://hackage.haskell.org/package/monad-loops -- plhk
05:33:19 <XexonixXexillion> :t fix (\r p m -> m >>= (\m' -> if p m' then fmap (m' :) (r p m) else return []))
05:33:21 <lambdabot> (Monad m, Functor m) => (a -> Bool) -> m a -> m [a]
05:35:18 <bgamari> If I take the same block of code and split it into two modules, it stack overflows with ghc 7.6.1 even with INLINE annotations
05:36:38 <plhk> bitonic: ah, thanks
05:38:52 <bgamari> Anyone see what is wrong with this simple reduction? https://gist.github.com/bgamari/5371720
05:39:19 <bgamari> For the life of me I can't figure out why it would stack overflow
05:39:33 <bgamari> I'm beginning to think it's an unordered-containers bug
05:39:46 <bgamari> lambdabot, tell tibbe ping
05:43:39 <bitonic> bgamari: it’s @tell, and I’d rather use it to deliver an actual message :P
05:43:55 <nand`> dmwit: I've noticed this before, I think the interesting implication of non-associativity (assuming commutativity) is that it can be used to build up ‘complex’ equations
05:43:56 <bgamari> bitonic, Yes, I /msg'd it
05:44:54 <nand`> because otherwise, everything would commute and associate down to two possible scenarios
05:45:27 <nand`> three, actually
05:48:17 <bgamari> Hmm, it seems Data.Map reproduces the issue as well
05:57:38 <bgamari> damn you foldMap
06:02:17 <dmwit> nand`: Wow! That's a continuation of like a two-day-old conversation.
06:02:41 <dmwit> or else there is some WICKED lag on my end
06:02:47 <ion> Is that not allowed?
06:03:01 <dmwit> It is allowed. Am I not allowed to be surprised when it happens?
06:03:02 <dmwit> =)
06:04:06 <ion> You are not. That is forbidden.
06:04:08 * nand` debates replying to dmwit 2 days from now
06:04:16 <dmwit> hehe
06:04:44 <nand`> it's not on your part, though. I've just been dead for about a month. Don't worry though, I got temporarily resurrected
06:08:23 <helmut> hi. in lhs2tex is there a way to have a code environment where the last line is a spec, but aligned with the rest of the code environment? (putting code and spec next to each other breaks polytable-like formatting)
06:09:32 <helmut> this would be useful for developing a function in a few steps where the last line contains things left out to be completed in a later code environment.
06:17:02 <ryant5000> are there any type operators that can still be used as variables?
06:17:58 <Taneb> Only things like `c`
06:18:18 <ryant5000> Taneb: ah, that's unfortunate
06:18:40 <Taneb> I agree, but a lot of people prefer this way because you can make a (+) type
06:19:00 <nand`> you can pre-7.4 or something
06:19:06 <ryant5000> nand`: lol
06:19:08 <nand`> but I wouldn't rely on outdated behavior in your programs
06:19:36 <Taneb> I think using, eg, Arrow (~>) => ... is quite nice
06:19:39 <Facepalm> If I have a list of pairs fsts :: [(x,y), (x,y)]. -> [x] using map how can I make that produce the first of each pair and create a new list with those numbers. For example fsts[(3,5),(7,2)] and it would return [3,7]
06:19:50 <ryant5000> well, i don't see any problem with having a wider variety of type operators that count as uppercase; however, i was hoping there would still be *some* operator variables :P
06:20:29 <ryant5000> Taneb: i agree
06:20:47 <ryant5000> Taneb: however, there was some concern raised regarding the fact that ~ is a constructor
06:20:51 <ryant5000> Taneb: which seems legitimate
06:21:05 <Taneb> Hmm, yeah
06:21:10 <nand`> Taneb: yes I was quite fond of that
06:21:11 <Botje> Facepalm: 'fst' grabs the first value of a pair.
06:21:22 <Botje> Facepalm: given that you know about 'map' already, is that enough?
06:21:30 <nand`> the upside is that now I can define eg. (~>) to be some specific arrow and use that
06:21:37 <nand`> like netwire's WireP
06:21:50 <Facepalm> I don't know how to use in this case is my problem
06:22:06 * hackagebot soap 0.2.0.0 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.0.0 (AlexanderBondarenko)
06:22:31 <Botje> Facepalm: you don't know how to use /what/?
06:22:32 <ryant5000> nand`: pah! specific arrows are for the weak!
06:22:33 <ryant5000> lol
06:22:34 <Facepalm> I'm very new to haskell so I know of map just don't know how I'd finish this particular function
06:22:38 <helmut> answer to my question: \savecolumns & \restorecolumns
06:23:41 <scalable> Facepalm: partial function?
06:23:48 <Facepalm> Would I do map ( fst) [fsts x] ?
06:24:06 <Botje> Facepalm: fsts xs = map fst xs
06:24:54 <Facepalm> Why xs? Sorry I am a noob
06:25:17 <scalable> Facepalm: xs is just a parameter name
06:27:11 <ab9rf> huh
06:31:37 <cathoderay> anyone here from brazil?
06:32:10 <Facepalm> So for the last 2 would I use snds xs = map snd xs ? Defining snds :: [(x,y) , ( x,y)]  -> [y] ?
06:32:28 <mm_freak_> i have a type F which is not exactly a functor, but close…  the following function works:  fmap' :: (a -> b) -> (b -> a) -> F a -> F b
06:32:35 <mm_freak_> reason:  F a contains a function of type a -> a
06:32:46 <mm_freak_> is there some categorical pattern for this?
06:32:54 <Botje> Facepalm: [(x,y),(x,y)] is not a valid haskell type.
06:33:13 <Botje> just [(x,y)] suffices.
06:33:14 <typoclass> Facepalm: "snds xs = map snd xs" looks good
06:33:32 <ab9rf> lists are homogenous, and you can't specify the number of leements in the list as part of its type
06:33:59 <ramses_> mm_freak_: an invariant functor?
06:34:12 <ramses_> @hackage invariant
06:34:13 <lambdabot> http://hackage.haskell.org/package/invariant
06:34:49 <dmwit> cathoderay: There's #haskell-br
06:34:58 <mm_freak_> hmm
06:35:34 <mm_freak_> that package ruins my dependencies
06:36:03 <mm_freak_> but i knew it was something with "variant"
06:36:51 <mm_freak_> seems like Invariant is a generalization of Functor
06:37:02 <mm_freak_> every haskell functor is an Invariant
06:37:09 <cathoderay> dmwit: thanks
06:37:32 <ramses_> mm_freak_: even stronger, any type constructor is an Invariant
06:37:45 <ramses_> (of kind *->*, I mean)
06:38:01 <mm_freak_> hmm
06:38:07 <mm_freak_> i guess i'll go without it
06:38:47 <elliott> ramses_: not true
06:38:51 <elliott> IORef, e.g.
06:39:03 <elliott> any "truly" algebraic data type is though
06:39:43 <Taneb> elliott, what makes an ADT a "true" ADT
06:39:43 <mm_freak_> counterexample:  newtype T f a = T (f a)
06:40:21 <mm_freak_> T f is not an Invariant, but (Invariant f) => T f is
06:40:40 <elliott> ok, ok, but you get the idea :P
06:40:48 <elliott> Taneb: not appealing to weird primitives like IORef
06:40:59 <Taneb> Fair enough
06:41:18 <dmwit> s/weird/
06:41:33 <mm_freak_> in a way i consider most primitive types like Integer algebraic except that you can't pattern-match on the structure of the number
06:42:13 <mm_freak_> but with OverloadedLists you could in principle pattern-match on individual bits of an Integer, which would be great sometimes =)
06:43:02 <Taneb> mm_freak_, I think you can do something like that with ViewPatterns
06:43:16 <dmwit> > let f (bit 3 -> 1) = "bit 3 is on"; f _ = "bit 3 is off" in f 8
06:43:17 <mm_freak_> Taneb: and with pattern guards
06:43:18 <lambdabot>   Could not deduce (Data.Bits.Bits (t -> a0))
06:43:18 <lambdabot>    arising from the ambiguity c...
06:43:27 <dmwit> oops
06:43:56 <dmwit> > let f (flip testBit 3 -> 1) = "bit 3 is on"; f _ = "bit 3 is off" in f 8
06:43:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
06:43:58 <lambdabot>    arising from the literal `1...
06:44:07 <mm_freak_> but i mean something (not well-defined, btw) like:  f (0:0:_) = …
06:44:08 <dmwit> haha, whatever
06:44:16 <mm_freak_> for Integers divisible by 4
06:44:30 <mm_freak_> this would actually be well-defined for types like Word
06:44:40 <mm_freak_> and btw, i'd really like a GMP-powered Nat type
06:44:53 <Taneb> mm_freak_, I don't think GMP has a Nat type
06:44:54 <dmwit> yes plox
06:45:03 <Taneb> (and it should totes be called Wordeger)
06:45:04 <mm_freak_> Taneb: GMP has, mpz_* doesn't
06:45:34 <mm_freak_> as far as i know GHC doesn't use mpz_* anyway (otherwise it wouldn't outperform it)
06:45:41 <dmwit> and sed -i s/fromInteger/fromNat/ base/**/*.hs
06:57:44 <facepalm> I also have the function pastebin.com/9Li1ZdKM and it works for the most part but if i pass it two even numbers or two odd numbers when calling the everyOther function it throws exception but if i pass it an odd and even number or even and odd it works just fine
06:58:04 <facepalm> any idea of what would cause it to throw this exception?
07:00:21 <Eduard_Munteanu> facepalm: that pattern isn't exhaustive
07:00:25 <ramses_> facepalm: didn't you get a warning when loading that?
07:00:53 <dmwit> facepalm: In addition to what Eduard_Munteanu and ramses_ said, I think you're lying.
07:01:15 <Eduard_Munteanu> Lies... damn lies.
07:01:16 <facepalm> nope it compiles just fine
07:01:26 <fizbin> Which is to say, please add to the paste exactly the statements that throw an exception.
07:01:42 <dmwit> I think you're not passing it two numbers at all; I think you're passing it a list, and that the list also does not contain two numbers.
07:02:15 <fizbin> Note that any odd-length list will also throw an exception.
07:02:41 <facepalm> thats my function then when I run the function I do pass it a list such as everyOther[2..20] and it should give me everyother number from 0 to 20
07:02:48 <facepalm> er sorry 2 to 20
07:03:08 <Botje> facepalm: yes, so what is everyOther [5] ?
07:03:09 <dmwit> > [2..20] -- way more than two numbers in this list
07:03:10 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
07:04:03 <fizbin> > length [2..20]
07:04:05 <lambdabot>   19
07:04:25 <fizbin> Note that [2..20] is a list with a length that is odd.
07:05:10 <fizbin> :t flip maybe id
07:05:11 <lambdabot> a -> Maybe a -> a
07:05:24 <fizbin> @hoogle a -> Maybe a -> a
07:05:25 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
07:05:25 <lambdabot> Prelude asTypeOf :: a -> a -> a
07:05:25 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
07:05:25 <Taneb> :t fromJust
07:05:27 <lambdabot> Maybe a -> a
07:05:32 <Taneb> :t fromMaybe
07:05:34 <lambdabot> a -> Maybe a -> a
07:05:41 <dmwit> :t fromNothing
07:05:42 <lambdabot>     Not in scope: `fromNothing'
07:05:43 <lambdabot>     Perhaps you meant `fromWithin' (imported from Control.Lens)
07:05:55 <facepalm> yes so do I need another case?
07:06:00 <dmwit> Yes.
07:06:01 <fry> :info fromJust
07:06:05 <fry> aw
07:06:07 <elliott> fromNothing Nothing = (); fromNothing (Just _) = error "fromNothing"
07:06:08 <Eduard_Munteanu> @hoogle fromJustToJust
07:06:09 <lambdabot> No results found
07:06:19 <elliott> ashesToAshes, justToJust
07:06:20 <ramses_> facepalm: do :set -Wall in ghci, and it will tell you which cases you missed
07:06:25 <Eduard_Munteanu> elliott: exactly :)
07:06:38 <fizbin> faceplam: Yes. You need it to handle a list of length 1.
07:10:05 <facepalm> says pattern not matched [_]
07:10:47 <ramses_> that is a list with one element (called _ here)
07:10:47 <geekosaur> which is what fizbin just told you
07:11:31 <hpaste> “http://pedulibacklink.blogspot.com/2013/04/cipto-junaedy.html” pasted “http://pedulibacklink.blogspot.com/2013/04/cipto-junaedy.html” at http://hpaste.org/85646
07:11:38 <ab9rf> whee
07:12:01 <fizbin> Is that a spammer?
07:12:05 <hpaste> “http://seo-serp-id.blogspot.com/2013/04/cipto-junaedy.html” pasted “http://seo-serp-id.blogspot.com/2013/04/cipto-junaedy.html” at http://hpaste.org/85647
07:12:12 <Botje> yes, it is.
07:12:38 <ab9rf> fizbin: the spammy blogspot id wasn't a dead giveaway?
07:12:39 <Botje> http://support.google.com/blogger/bin/answer.py?hl=en&answer=42577 # take a few seconds to report those blogs
07:12:56 <fizbin> There are IRC channels I can conceivably imagine spamming. #haskell is not one of them.
07:13:26 <ab9rf> fizbin: this channel is one of the larger ones on freenode so it gets spammed a lot
07:13:37 <Botje> reported as spam, yay warm fuzzy feelings
07:16:20 <elliott> it's a persistent problem
07:16:47 <elliott> @ask chrisdone can you do anything about the pastes with spammy titles etc. that get announced in #haskell?
07:16:48 <lambdabot> Consider it noted.
07:18:39 <Eduard_Munteanu> I wonder if that's automated or manual spam.
07:19:00 <Botje> autmated, i'd think.
07:19:08 <Botje> it sees a big box and a couple of smaller ones.
07:19:21 <Eduard_Munteanu> Yeah... I guess a captcha might do.
07:19:34 <Sculptor> hi
07:19:38 <Eduard_Munteanu> Sculptor: hi
07:19:45 <Sculptor> hi eduard
07:24:06 <Kinnison> bleh, am I going to strike out, looking for an OpenID *provider* written in Haskell?
07:24:13 <Kinnison> I can find a few consumers
07:24:29 <startling> what's that library people use to programmatically generate javascript?
07:24:54 <facepalm> I got it...thanks for all the help and patience with my noobness. Greatly appreciated
07:25:15 <startling> language-ecmascript, maybe?
07:31:19 <klrr> hi
07:31:36 <Eduard_Munteanu> klrr: hi
07:32:11 <Eduard_Munteanu> startling: Fay?
07:32:17 <startling> >.>
07:55:02 <asattar> Is Haskell.org not participating in GSOC 2013?
07:55:50 <geekosaur> it is participating, I believe
07:56:20 <luite> it's been accepted yeah
07:57:15 <asattar> Yes I see it now.
08:03:49 <fizbin> @type maybe
08:03:51 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:06:28 <meditans> Hi.. I'd like to ask a question about memoizing, and in particular Data.MemoCombinators
08:06:32 <hpaste> meditans pasted “Data.MemoCombinator” at http://hpaste.org/85649
08:13:49 <eikke> when using cabal-dev, after running install-deps, configure and build (which builds some library), is there an easy way to run 'ghc --make whatever.hs' so that ghc will find the cabal-dev'installed deps and lib?
08:16:28 <supki> -package-db=cabal-dev/packages-GHC_VERSION.conf
08:16:49 <eikke> supki: I know about that one, but that requires the lib to be installed into cabal-dev first, which is kinda annoying
08:17:05 <supki> ah, i see
08:17:22 <cmears> meditans: try calling fib1 from fib
08:17:25 <eikke> (and in this case somehow doesnt work either, might need some more investigation)
08:17:43 <cmears> that is, change line 7 to:   fib n = fib1 (n-1) + fib1 (n-2)
08:24:22 <Taneb> preflex: seen shapr
08:24:22 <preflex>  shapr was last seen on #haskell-blah 10 hours, 12 minutes and 38 seconds ago, saying: I want to build a reduceron!
08:42:07 <nand`> fibonacci must be enjoying his unexpected popularity among memoization experts
08:44:06 <klrr> HASKELL! :D
08:44:09 <klrr> dundundnudundnudnudnudundnudn
08:44:12 <klrr> \m/
08:44:18 <Taneb> > cycle "dun"
08:44:20 <lambdabot>   "dundundundundundundundundundundundundundundundundundundundundundundundundu...
08:45:40 <FUZxxl> nananananananana haskell! nanananannanana
08:45:45 <Rembane_> Big shark?
08:46:39 <thirsteh> so I've seen a common style is to place stdlib imports in a group first, then other packages, then your own, and sorting each group alphabetically. I understand separating your packages from the rest, but what is the point of separating stdlib from third party?
08:46:49 <nand`> > concat $ repeat "na" & ix 10 .~ " haskell! "
08:46:51 <lambdabot>   "nananananananananana haskell! nananananananananananananananananananananana...
08:47:28 <Taneb> thirsteh, I can't think of any, and I don't do that
08:47:28 <nand`> thirsteh: I dunno, I just put Prelude first for.. well, whatever reason; but otherwise I just group things by TLC and sort them alphabetically
08:47:37 <FUZxxl> thirsteh: So that people can immediately tell apart what external (as in not stdlib) dependencies your code has
08:47:38 <nand`> usually I don't import Prelude explicitly though
08:47:47 <nand`> maybe it's first just as a sort of reminder that, beware, Prelude be different!
08:47:55 <thirsteh> FUZxxl: hmm okay, but the cabal file already shows that
08:48:19 <thirsteh> I was thinking it's worth more to have it all alphabetical--I skim for a package positionally way more often than I distinguish between stdlib and thirdparty, especially considering that base is so small
08:48:25 <nand`> also ‘stdlib’ probably best to refer to it as ‘base’ to avoid confusion
08:48:33 <thirsteh> nand`: yes, base
08:48:43 <FUZxxl> thirsteh: It's nice to see this immediately to be able to refactor the code
08:48:55 <FUZxxl> Also, it's cheap to do that and it does not hurt
08:49:14 <thirsteh> I'm saying that it does hurt, because now I have to first consider if something is in base or not before I can identify it in the import list
08:49:21 <thirsteh> I was wondering if there was a good argument for it
08:50:26 <thirsteh> nand`, Taneb: yeah, I think I'm gonna be one of those people who has their own little style
08:50:38 <nand`> everybody has their own little style
08:50:43 <thirsteh> true :)
08:50:45 <nand`> this isn't java :D
08:50:56 <nand`> Haskell - choose your idiom
08:52:05 <hpaste> mbuf pasted “Better rewrite?” at http://hpaste.org/85650
08:52:05 <klrr> when can you call yourself a programmer?
08:52:25 <Taneb> klrr, who knows.
08:52:33 <mbuf> is there a better way to write the main () function in the above hpaste?
08:52:45 <nand`> by the end of this debate, everything will be a program, and subsequently everybody will be a programmer
08:53:20 <Rembane_> Or very small shell scripts.
08:53:56 <Botje> mbuf: liftM3 (\a b c -> a && b && c) (check 3) (check 9) (check 27)
08:54:15 <klrr> Taneb: okey, well when should you call yourself a programmer?
08:54:34 <nand`> Botje: and $ sequence [check 3, check 9, check 27]
08:54:42 <Cale> Botje: that's different :)
08:54:44 <nand`> or whatever
08:54:44 <Taneb> klrr, I'd say when you either program for a living or have built a reputation as a programmer in the community
08:54:46 <nand`> and <$>
08:54:58 <nand`> also what Cale said
08:55:02 <Botje> ohh, right.\
08:55:04 <nand`> doesn't terminate fast
08:55:05 <Botje> the putStrLns.
08:55:08 <nand`> foldrM or something
08:55:12 <Cale> (well, it's the same in this case, because fixed constants)
08:56:03 <nand`> F.foldrM (pure .: (&&)) True [check 3, check 9, check 27] -- ??
08:57:16 <nand`> -> F.foldrM (\a b -> fmap (a &&) (check b)) True [3, 9, 27] -- or something
08:57:34 <nand`> not very pretty
08:57:36 <mbuf> Botje: if check 3 fails, it must stop; everything gets printed with liftM3
08:58:20 <nand`> the prettiest solution might be rolling your own fold
09:00:08 <nand`> at any case, the 3 nested conditionals in ‘main’ can be looped
09:00:16 <nand`> at any rate/in any case*
09:01:22 <klrr> Taneb: very good answer
09:01:27 <klrr> ?src or
09:01:27 <lambdabot> or    =  foldr (||) False
09:02:49 <nand`> you could also scrap your ‘check’ in this scenario and go with something simpler, like takeWhile (>10) ... -- and go from there
09:16:41 <mbuf> nand`: using F.foldrM (\a b -> fmap (a &&) (check b)) True [3, 9, 27] in main gives me "Couldn't match expected type 'Int' with actual type 'Bool'"
09:17:00 <mbuf> nand`: should I return Bool anywhere?
09:17:07 <klrr> udndnunudnudnudnu
09:17:25 <nand`> oh foldlM or something then
09:18:26 <mbuf> nand`: foldlM compiles, but, it still doesn't stop after the first check returns False
09:18:54 <nand`> oh of course
09:19:06 <nand`> fmapping the result defeats the whole purpose, needs a branch
09:19:12 <mbuf> nand`: because fmap continues to run on the remaining arguments
09:19:53 <nand`> (\a b -> if a then check b else return a) -- or something
09:19:56 <mbuf> nand`: sorry, by branch you mean a conditional jump?
09:20:01 <mbuf> merijn: welcome
09:20:25 <nand`> ‘jump’ doesn't make an awful lot of sense in a Haskell context, by branch I mean a logical one ie. if/then/else
09:20:32 <mbuf> nand`: okay
09:21:25 <mbuf> nand`: thanks
09:22:17 <nand`> oh, you should probably also re-use the bool in ‘check’ eg. check a = putStrLn (if b then "1" else "0") b where b = a > 10
09:22:34 <nand`> err >> return b
09:22:39 * nand` is very tired
09:32:49 * hackagebot adobe-swatch-exchange 0.2.0 - parse Adobe Swatch Exchange files and (optionally) output .css files with the colors  http://hackage.haskell.org/package/adobe-swatch-exchange-0.2.0 (JeremyShaw)
09:34:45 <DMcGill> is the only difference between `f = \x -> \y -> x+y' and `f x y = x+y' some monomorphism fuckery?
09:35:27 <nand`> yes
09:35:37 <Eduard_Munteanu> DMcGill: if it's a toplevel definition
09:36:36 <DMcGill> This is for my dissertation, I'm probably going to put that they're the same and then add a footnote saying 'well, not really' like I did with IO and unsafePerformIO
09:36:52 <nand`> that's the most sane approach
09:37:04 <nand`> “ideally, these are the same (but this is not a perfect world)”
09:37:37 <no-n[7]> (>9000)
09:40:09 <DMcGill> also why code purity is important: "for (i = 0; i < strlen(string); i++)"
09:40:43 <nand`> string.each
09:45:59 <Cale> DMcGill: However!
09:46:12 <Cale> DMcGill: be careful if x is a pattern
09:46:25 <Cale> ghci> (\(x:xs) y -> 0) [] `seq` 2
09:46:26 <Cale> 2
09:46:26 <Cale> ghci> (\(x:xs) -> \y -> 0) [] `seq` 2
09:46:26 <Cale> *** Exception: <interactive>:5:2-19: Non-exhaustive patterns in lambda
09:47:23 <DMcGill> > (\~(x:xs) -> \y -> 0) [] `seq` 2
09:47:25 <lambdabot>   <hint>:1:11: parse error on input `->'
09:47:32 <DMcGill> > (\(~(x:xs)) -> \y -> 0) [] `seq` 2
09:47:34 <lambdabot>   2
09:47:38 <DMcGill> so that's what that is for
09:48:42 <ab9rf> that's what what is for?
09:48:56 <Cale> > let f (x:xs) y = 0 in f [] `seq` 2
09:48:57 <lambdabot>   2
09:49:06 <Cale> > let f (x:xs) = \y -> 0 in f [] `seq` 2
09:49:07 <lambdabot>   *Exception: <interactive>:3:5-22: Non-exhaustive patterns in function f
09:50:47 <ab9rf> Cale: i don't begin to understand why those two yield different results
09:50:48 <DMcGill> ab9rf: using '~', known as lazy patterns
09:51:19 <ab9rf> i understand lazy patterns, although i've not personally had a situation where i needed one
09:51:36 <Taneb> ab9rf, I actually have
09:51:40 <DMcGill> because in the second example `f []' can be evaluated by seq while in the first it can't
09:51:45 <Taneb> They're oddly useful when defining Storable instances
09:52:35 <nand`> from what I understand is going on: since ‘f’ is fundamentally a single function, it's already in HNF (or whatever the terminology is) even though you've already applied an argument, it doesn't get immediately reduced
09:53:16 <[swift]> can anyone recommend a good in-process database that has nice haskell bindings and can handle concurrent access by multiple threads well?
09:53:18 <nand`> note: ‘seq’ doesn't do anything if the left-hand side is a function
09:53:25 <DMcGill> lazy patterns are why "let f (x:xs) = \y -> 0 in f [] `seq` 2" crashes and " (\(~(x:xs)) -> \y -> 0) [] `seq` 2" doesn't
09:53:26 <nand`> for some meaning of ‘function’
09:53:39 <[swift]> (it's the last concern, primarily, that sees me ready to abandon sqlite-direct)
09:54:03 <nand`> [swift]: are you thinking of something like acid-state?
09:54:09 <Eduard_Munteanu> [swift]: there's persistent from Yesod
09:54:14 <Eduard_Munteanu> Or yeah, acid-state.
09:54:25 <[swift]> nand`, Eduard_Munteanu: thanks for the recommendations!
09:54:29 <Cale> ab9rf: when you glue the patterns together like that, it matches all of them before producing a result or exception of any kind. If you chain the lambdas, it matches the first pattern and then either returns a function as the result or an exception from pattern match failure.
09:55:28 <Cale> ab9rf: Well, there's a partial application closure which is created to represent (\(x:xs) y -> 0) []
09:55:54 <Cale> I wonder if I can use vacuum to show this...
09:57:04 <ab9rf> Cale: i understand why the nonlazy with the lambda fails, and why the lazy lambda doesn't fail
09:57:17 <ab9rf> Cale: but i'm fuzzy on the semantics of the partial application
09:57:31 <Cale> ghci> closureType ((\(x:xs) y -> 0) [])
09:57:31 <Cale> PAP
09:57:35 <Cale> ghci> closureType ((\(x:xs) -> \y -> 0) [])
09:57:35 <Cale> AP
09:57:59 <ab9rf> i take it it doesn't even attempt the pattern match because the patterrn is only partially applied?
09:58:03 <Cale> yeah
09:58:20 <Philippa> ab9rf: a "full" application would just straight to code, a partial one's basically a closure with some holes waiting to be filled in that does the saturated application when it's full
09:58:49 <Philippa> (the "full" application won't be returning a lambda)
09:58:52 <ab9rf> you can't (in the general case) apply a pattern to an incomplete argument set
09:59:35 <Cale> It's a little weird that the semantics are like this though
09:59:41 <Philippa> hrmm. Might be easiest to throw out the eval-apply paper again?
10:00:20 <Cale> I'm not sure there's really a *great* reason not to make those two things behave the same way in one fashion or another
10:00:39 <Philippa> ab9rf: so in Haskell, it's equivalent to a bunch of individual patterns and you can do each in turn
10:00:47 <Cale> But they don't, and I believe the Haskell spec is actually clear on the fact that they don't.
10:01:22 <ab9rf> Cale: i don't think it makes sense to try to force one into the other
10:01:32 <Cale> (at the higher level of semantics rather than in terms of the types of closures that are being used to represent these functions)
10:02:04 <ab9rf> Cale: i have been wondering how partially applied functions are represented, though, and now i have a slightly better idea.
10:02:54 <nand`> “fork it, patch it, test it, merge it”
10:03:29 <Philippa> ab9rf: there's a paper on a chunk of GHC's RTS you might find helpful - http://research.microsoft.com/apps/pubs/default.aspx?id=67488
10:05:26 <ab9rf> hm, for a function defined by patterns, all of the patterns have to have the same arity, right?
10:05:43 <Philippa> yeah
10:06:31 <Philippa> so it's effectively \x y z -> case (x,y,z) of (Foo, Bar, Baz) -> ...
10:06:59 <Philippa> or something close, I may've missed a ~ or two out
10:07:27 <nand`> I don't see where a ~ would be needed here
10:08:41 <Philippa> nand`: yeah, I was (not) thinking of let
10:11:17 <chrisdotcode> hi all :)
10:15:05 <Eduard_Munteanu> chrisdotcode: hi
10:20:25 <__xc> > flip  (\x y z->x:y:[z]) 1 2 3
10:20:26 <lambdabot>   [2,1,3]
10:22:03 <klrr> what's is macros, and why are they so important in lisp?
10:23:35 <johnw> macros let you create new syntax in lisp, roughly speaking
10:23:43 <johnw> you can use them to implement "if", for example
10:23:52 <Peaker> klrr, source code transformers.. in Lisp, the type of the source code is not string, but also not a rigid AST, so you can define new syntax but not have to work hard to parse strings
10:24:23 <__xc> :t flip
10:24:25 <lambdabot> (a -> b -> c) -> b -> a -> c
10:24:52 <augur> why.. would you do \x y z -> x:y:[z]
10:24:56 <augur> o_O
10:25:02 <augur> why not just \x y z -> [x,y,z]
10:25:10 <hpaste> “Anonymous Coward” annotated “aoeuaoeuaoeuaoeu” with “aoeuaoeuaoeuaoeu (annotation)” at http://hpaste.org/43887#a85652
10:25:13 <__xc> no just randomly testing
10:27:18 <__xc> > flip  ( flip (\x y z->(x,y,z)) 1) 2 3
10:27:18 <klrr> Peaker: okey, you basically create special forms?
10:27:19 <lambdabot>   (3,1,2)
10:27:25 <Peaker> klrr, yeah
10:28:26 <Peaker> klrr, it's not really a big deal because parsing strings is not hard to delegate to reusable libraries (e.g: quasiquoting in TH) and source code transformations are how we solve problems when we don't yet know the correct way to solve it :)
10:29:08 <Peaker> Lisp encourages doing a lot of work at the syntactic level when it can be done at the value level, which is not nice
10:30:17 <klrr> Peaker: so for example, define procedure can be defined as a macro? since it got special syntaxa when defining functions?
10:32:08 <Peaker> klrr, yeah
10:33:34 <Peaker> something like: (defmacro defun (name arglist &rest body) '(setq ,name (lambda ,arglist ,body ...
10:35:42 <klrr> okey i got a problemo, i get this error https://gist.github.com/klrr/5373714 when i try compile https://gist.github.com/klrr/5373716 , the relevant code is at line 97 in the eval function
10:35:47 <klrr> any idea what's the prob?
10:36:54 <klrr> `^_^v:
10:37:33 <no-n[7]> how do you make the ghci prompt stay the same on multilined inputs?
10:38:44 <nand`> no way as of release, there's a patch for it floating around
10:39:09 <no-n[7]> ok
10:39:46 <`^_^v> klrr,
10:40:12 <Peaker> klrr, your line 99 is bad
10:40:22 <clahey> So, is anyone else doing Google Code Jam in haskell today?
10:40:26 <Peaker> klrr, you're giving throwError 3 args
10:40:39 <klrr> oh shit
10:40:43 <klrr> i should use $
10:40:45 <arbn> If I have a list, and I want to partition every three items, what's the most elegant way to do this. For instance, to take [1,2,3,4,5,6,7,8,9] and get [[1,2,3],[4,5,6],[7,8,9]]?
10:40:45 <klrr> thanks! :D
10:40:57 <Peaker> klrr, or () around the arg, yeah
10:41:00 <`^_^v> what time does it start, cla
10:41:06 <`^_^v> clahey,
10:41:21 <arbn> Assuming that the length of the list is 0 mod 3.
10:41:32 <clahey> `^_^v: 7 EST, I think.
10:41:35 <clahey> 19 EST
10:41:57 <supki> > [1,2,3,4,5,6,7,8,9] & chunksOf 3
10:41:58 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
10:42:02 <`^_^v> and the first round lasts for the weekend? or longer
10:42:19 <hiptobecubic> :t chunksOf
10:42:21 <lambdabot> Int -> [e] -> [[e]]
10:42:22 <`^_^v> i might do it in haskell
10:42:41 <`^_^v> but if its only this weekend i wont have time
10:42:44 <arbn> OK, and chunksOf is in split, right?
10:42:48 <supki> yes
10:44:35 <clahey> `^_^v: 24 hours.
10:44:52 <clahey> `^_^v: But it's just the qualifiers, so it probably won't take you that long.
10:45:31 <ab9rf> :t chunksOf
10:45:32 <lambdabot> Int -> [e] -> [[e]]
10:46:08 <`^_^v> well i am going to be out of state this weekend and probably wont have access to a computer i can work on
10:46:36 <`^_^v> actually i'll probably try to install python on it
10:47:35 <dmwit> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..9]
10:47:37 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
10:47:56 <ab9rf> supki: where does (&) come from?
10:48:03 * dmwit bets on lens
10:48:21 <ab9rf> hoogle only have something in dyngraph, which i doubt is what that was
10:48:43 <jfischoff> its in diagrams too, not sure of the context though ...
10:48:50 <supki> ab9rf: yeah, lens
10:49:02 <ab9rf> :t (&)
10:49:04 <lambdabot> a -> (a -> b) -> b
10:49:10 <ab9rf> :t ($)
10:49:11 <lambdabot> (a -> b) -> a -> b
10:49:21 <ab9rf> :t flip ($)
10:49:23 <lambdabot> b -> (b -> c) -> c
10:49:36 <jfischoff> :t <&>
10:49:37 <lambdabot> parse error on input `<&>'
10:49:45 <jfischoff> :t (<&>)
10:49:45 <nicoo> :t (<&>)
10:49:47 <lambdabot> Functor f => f a -> (a -> b) -> f b
10:49:47 <lambdabot> Functor f => f a -> (a -> b) -> f b
10:49:49 <fryguybob> @type flip id
10:49:51 <lambdabot> b -> (b -> c) -> c
10:52:42 <arbn> Woah. I just realized that "split" is in the HP. Weird.
10:52:43 <no-n[7]> hmm
10:54:42 <startling> what I really want is a js dsl that could automatically inline other functions written in the dsl.
10:55:58 <arbn> startling: A "js dsl" in the sense of something similar to JMacro?
10:56:10 <startling> arbn: yeah.
10:56:18 <startling> but less stringy, too.
11:02:52 * hackagebot github 0.6.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.6.0 (JohnWiegley)
11:04:30 <__xc_> http://www.youtube.com/watch?v=iSmkqocn0oQ
11:38:35 <__xc> bad icrosoft
11:43:54 <S11001001> ooh there's an ada 2012, time to upgrade from 95 for all my ada projects
11:52:35 <leino> how would you represent a tree structure which has the ability to go up the tree (i.e. keeps a "reference" to the parent of each node)? as far as I understand, the standard way is to use a zipper.
11:53:05 <Walther> btw, are lists in haskell linked lists or tables?
11:53:17 <quchen> Walther: The former.
11:53:38 <quchen> leino: Zippers sound right.
11:55:13 <leino> quchen: I thought so
11:55:24 <leino> I cannot seem to find anything about zippers on hackage
11:55:38 <quchen> There are zippers in lens
11:55:48 <leino> or I mean: I cannot seem to find a standard interface
11:55:55 <quchen> I think there used to be an individual package which was then fused with lens
11:56:45 <quchen> leino: http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Zipper.html
11:56:46 <leino> I have heard of lenses before (but never investigated a lot). are lenses somehow related to zippers?
11:57:13 <arbn> That sounds wrong. Zippers have little to do with lens. It's just due to popular demand that edwardk put that in, right?
11:58:29 <quchen> arbn: Zippers can use lenses very well. "Zoomming in" is a pretty lens-y operation.
11:58:58 <arbn> quchen: Yes, I know. But that's just due to the support in lens for generic structures.
11:59:06 <jfischoff> arbn: They are related. Lenses traverse a single part of a structure. Zippers have single object and a context.
12:00:16 <arbn> Is the Zipper in lens just the Zipper in uniplate?
12:01:11 <quchen> No.
12:01:37 <quchen> From Lens-Zipper: "The code here is inspired by Brandon Simmons' zippo package"
12:02:32 <quchen> Also, Lens zippers have smiley data constructors as a bonus.
12:03:53 <arbn> OK. So I guess lens, uniplate, and fclabels all offer different approaches to generic zippers.
12:07:45 <Peaker> is there any reason to have fclabels now that we have lens? :P
12:08:27 <quchen> Peaker: I'm not sure how much of Hackage would still be left if everything Lens covers was removed ;-)
12:08:37 <Peaker> quchen, haha
12:09:10 <quchen> Lens always teaches me how good I am at writing boilerplate.
12:09:37 <quchen> Ten lines for modifying some nested stuff? Well, it's one using Lens, and you still get a comment until the 80 char margin
12:13:39 <lmj`> Could a Control.Parallel strategy be written to remove the redundancy in http://stackoverflow.com/a/1800257 ? As I understand it, nothing short of code generation via TH or a GHC extension would suffice. And I'm not aware of any existing tool.
12:14:47 <lmj`> DPH doesn't seem to address that case either.
12:16:30 <acowley> lmj`: be mindful that many PL researchers have crashed their boats on the rocky shoals of automatic parallelization.
12:16:30 <lambdabot> acowley: You have 4 new messages. '/msg lambdabot @messages' to read them.
12:16:57 <Eelis> is there any particular reason lambdabot can't pm people their message notifications? :)
12:17:04 <acowley> lmj`: It's hard to predict how much time something will take, and even a small amount of overhead can be a deal breaker if you're really worried about performance.
12:17:44 <__xc> Eelis, would be useful
12:18:12 <__xc> `/pm lambdabot >1+1`
12:18:13 * geekosaur 's (old and long gone now) lambdabot fork allowed that to be configured
12:18:28 <acowley> Are there any /r/haskell mods here?
12:18:45 <quchen> Did something happen?
12:18:59 <acowley> No
12:19:57 <lmj`> acowley: code-generating that example is presumably possible, though maybe ugly or ultimately useless.
12:20:05 <__xc> >maximum "haskell"
12:20:32 <quchen> __xc: You need a space after >
12:20:54 <__xc> yep.. k back to work anyway
12:21:33 <acowley> lmj`: Perhaps so. For a case like this where the work split is fair, you could automate things.
12:29:52 <lmj`> Am I correct that Data Parallel Haskell doesn't really address the Fibonacci case? I don't see how the problem can be usefully transformed to parallel arrays since there is data dependency at every turn.
12:31:16 <Zylaa> lmj`: You must time travel
12:32:59 <dmwit> lmj`: I dunno. Can't you just define a variant of par and pseq in-line that is par when n is big and const when n is small?
12:33:18 <dmwit> s/in-line/in a where clause/
12:34:23 <dmwit> parFib n = p `npar` q `npseq` (p + q) where npar | n < cutoff = const id | otherwise = par; npseq | n < cutoff = const id | otherwise = pseq; p = parFib (n-1); q = parFib (n-2)
12:35:14 <byorgey> johnw: am I correct that the github package doesn't support POST-y requests (like creating a new issue)?
12:35:20 <byorgey> I couldn't seem to find anything like that
12:37:06 <shachaf> dmwit: Well, that's not DPH.
12:38:26 <dmwit> shachaf: lmj`'s original question was not DPH-specific, so I assumed he was interested in DPH only because it seemed like an appropriate tool.
12:39:23 <shachaf> Ah. Perhaps I missed the original question.
12:39:32 <lmj`> dmwit: have you tried that? I suspect it has the slowdown that acowley warned about.
12:40:07 <dmwit> I haven't. It would surprise me if there was a big slowdown, because the existing code already checks whether n < cutoff in each iteration.
12:40:29 <dmwit> Then again, I've been wrong before and I'm sure I'll be wrong again.
12:40:49 <lmj`> dmwit: but that is only executed a small fraction of the time. Most work is done by the serial fib.
12:41:12 <dmwit> fair point
12:41:22 <lmj`> General rule is 2% slow clone, 98% fast clone, in Cilk terminology.
12:42:56 <dmwit> I think, with a bit of work and breaking the recursion, you could write something which takes a the recursive call to make as an argument and specializes correctly.
12:42:59 <dmwit> Let's see...
12:45:17 <fengshaun_> is there something in haskell analogous to string.format in python or sprintf in C?
12:45:33 <acowley> printf
12:45:42 <__xc> :t printf
12:45:43 <lambdabot> PrintfType r => String -> r
12:46:02 <acowley> It's a fancy function with a less than transparent type.
12:46:07 <acowley> But it does what you expect it to
12:46:42 <fengshaun_> acowley, fair enough, thanks!
12:47:30 <lmj`> dmwit: I think you'll find that you need to replicate the same code twice.
12:48:21 <lmj`> In cilk terminology, you're saying "give me the fast clone, and I'll create the slow clone". But the slow clone needs to have the same structure.
12:50:01 <hpaste> dmwit pasted “serial/parallel fib” at http://hpaste.org/85655
12:50:55 <pascha> > Just 6 >>= return (+)
12:50:57 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
12:50:57 <lambdabot>              with actual...
12:51:03 <pascha> > Just 6 >>= return (+1)
12:51:05 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
12:51:05 <lambdabot>              with actual...
12:51:16 <dmwit> lmj`: What do you think of this?
12:51:23 <pascha> > Just 6 >>= \x -> return $ x+1
12:51:23 <acowley> > Just 6 >>= return . (+1)
12:51:25 <lambdabot>   Just 7
12:51:25 <lambdabot>   Just 7
12:51:34 <pascha> > Just 6 >>= return (+1)
12:51:36 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
12:51:37 <lambdabot>              with actual...
12:51:53 <pascha> @type (>>=)
12:51:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:52:01 <dmwit> lmj`: The interesting bit here being that serialFib and parallelFib are easily generalized to other functions that need a cutoff.
12:52:09 <lmj`> dmwit: I just benchmarked it. It's slower. In practice, in order to gain speedup I don't think there's any way to bypass code generation. At least with present technology.
12:52:41 <lmj`> It's interesting though.
12:53:29 <lmj`> That is, slower than the serial fib.
12:55:47 <niteria> why is fib a benchmark? you can't cheat data dependencies
12:56:12 <pascha> why is (>>=) m a in and mb out? it is just x in and just x out. but it doesnt need to be i a in and a out right? so therefoe the type is a in and b out?
12:56:37 <niteria> what can you hope to gain from parallelizing fib?
12:56:41 <pascha> > Just 7 >>= return . show . (+1)
12:56:43 <lambdabot>   Just "8"
12:56:45 <pascha> aha!
12:56:52 <dmwit> pascha: I'm having trouble parsing your question.
12:56:57 <pascha> lol, i see why
12:57:04 <dmwit> But you might find the type of (=<<) more appealing.
12:57:13 <dmwit> (=<<) :: Monad m => (a -> m b) -> (m a -> m b)
12:57:15 <pascha> @type (=<<)
12:57:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:57:25 <armlesshobo> pascha: it's because it allows you to return a monad of a different type
12:57:30 <lmj`> niteria: If fib can be auto-parallelized then anything can. Much riches to be gained.
12:57:33 <dmwit> It turns functions that don't know how to handle a monadic value into functions that do know how to handle a monadic value.
12:57:35 <pascha> armlesshobo: yeah i figured that out
12:58:35 <lmj`> Meaning, given the low overhead of fib, other functions are easy in comparison.
12:59:24 <niteria> lmj`: if halting problem can be solved then anything can, it seems impossible to paralellize fib in a way that gives a speedup
13:00:06 <niteria> it can be used to measure the overhead
13:00:24 <pascha> niteria: is that relly true? that the halting problem encompasses all problems?
13:00:34 <niteria> not really
13:00:44 <lmj`> niteria: it's certainly possible. look up e.g. cilk.
13:00:49 <pascha> how can fibs not be parallallized to increase speed? if using the naive algo
13:01:01 <niteria> there are other problems harder than halting problem
13:01:58 <lmj`> niteria: no need to introduce the halting problem. Just learn about how cilk parallelization.
13:02:01 <quchen> Problems harder than the halting problem include the halting problem for things that can solve the halting problem. :-)
13:02:15 <lmj`> *parallelizes
13:02:22 <simpson> Example: https://en.wikipedia.org/wiki/Zeno_machine
13:02:43 <niteria> lmj`: I'm on it, never heard of cilk before
13:03:43 <niteria> there is a problem that is impossible to solve in general, yet there is no reduction from/to halting problem
13:03:48 <lmj`> niteria: If you can imagine auto-generating the cutoff-code, then it's possible in Haskell too. You just need macros or TH or whatever.
13:07:10 <niteria> spawn is smart enought to not split small tasks?
13:07:25 <niteria> s/enought/enough/
13:08:02 <dmwit> lmj`: could not reproduce
13:08:14 <dmwit> lmj`: serialFib' mean 1.448s, parallelFib mean 859ms
13:08:29 <dmwit> lmj`: serialFib' is the serial fib in your SO link
13:08:50 <dmwit> standard deviation roughly 300ms for each
13:09:19 <tac_> I once invented an algorithm for solving the halting problem. The problem then was it didn't halt.
13:09:29 <lmj`> dmwit: I have 1.06 for original serial fib, and 1.19 for your parallelFib.
13:09:40 <dmwit> How did you compile? How did you run?
13:09:59 <lmj`> ghc -O3 --make -threaded parallelFib.hs
13:10:09 <lmj`> time ./parallelFib +RTS -N4
13:10:33 <geekosaur> what is this -O3
13:10:42 <geekosaur> ghc is not gcc, there is no -O3
13:10:51 <dolio> Everything above -O2 is equivalent to -O2.
13:10:53 <dmwit> Strange. I did basically the same (just -O2 instead of -O3, since -O3 doesn't exist), and criterion instead of time. But what you said should work fine.
13:10:56 <dolio> Until you get to -O11.
13:11:15 * dmwit shrugs
13:11:21 <dmwit> Different machines behave differently, I guess.
13:11:51 <lmj`> dmwit: how many cores do you have?
13:12:21 <acowley> dmwit: You need to check the script, your line of dialog there was supposed to be, "Works on my machine!"
13:12:29 <dmwit> lmj`: 4
13:12:40 <dmwit> WFM, HTH kthxbai
13:12:54 <acowley> Thank you
13:13:05 <acowley> That's like every other email I send to my advisor
13:13:20 <dmwit> hahaha
13:14:36 <lmj`> dmwit: OS? Intel?
13:14:46 <lmj`> I'm on core-i7 linux
13:14:59 <acowley> Should I submit a link to my robot video to /r/haskell or should I wait until I've written up something about the code?
13:15:04 <johnw> byorgey: hi
13:15:18 <byorgey> hi johnw
13:15:34 <johnw> byorgey: right, there are holes in its support still
13:15:37 <dmwit> Linux; Intel Core-2 Quad Q6600
13:15:43 <byorgey> johnw: OK, no worries, just checking
13:15:50 <johnw> i just took over maintainership from Mike Burns, so I've yet to discover what all is still needed
13:15:58 <byorgey> right, cool
13:16:00 <dmwit> gotta run now
13:16:12 <lmj`> dmwit: in any case it's not even 1.68 speedup on a 4-core machine isn't very good.
13:16:34 <lmj`> my sentences are off today
13:16:56 <lmj`> ... originally was typing "not even 2x speedup"
13:18:05 <acowley> The demos on elm-lang.org are really impressive
13:19:40 <Zylaa> at least elm-lang.org doesn't have the crap problem with record fields not being allowed to have the same name in a module
13:19:43 <Zylaa> elm rather
13:19:50 <Zylaa> http://elm-lang.org/blog/announce/version-0.7.elm
13:20:10 <Zylaa> two x fields!
13:20:14 <Zylaa> amazing innovation
13:21:10 <acowley> I am less tempted by that now that we live in the lens world
13:21:47 <acowley> You can use the _x lens on V2,V3,V4 in linear, for example.
13:22:06 <BOY77X> http://xxxsexygifsxxx.blogspot.com/2013/04/kim-kardashian-hot-collection.html
13:22:24 --- mode: ChanServ set +o johnw
13:22:28 --- mode: ChanServ set +o johnw
13:22:50 --- mode: ChanServ set +o johnw
13:23:11 --- mode: johnw set -o johnw
13:23:23 <dolio> What a letdown.
13:23:37 <dolio> I thought you were charging up your ops dragonball style.
13:23:49 <parcs> wait, there's porn on the internet?
13:23:58 <acowley> Watch yourself, he's not totally discharged yet
13:27:58 * hackagebot bed-and-breakfast 0.3.2 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.3.2 (JulianFleischer)
13:27:59 <pascha> parcs: no. he's just teasing you.
13:29:12 <lmj`> Often when two languages are compared, the best of one is pitted against the worst of another, leading to the author's predetermined conclusion.
13:29:40 <Zylaa> acowley, that's bad. I don't want to make lenses beforehand.
13:29:49 <lmj`> In this light I am afraid to mention GHC wrt automatic parallelism, but there doesn't seem to be anything better than the cutoff solution.
13:30:04 <Zylaa> I won't make a lense for a fieldname that is used twice in 1 file
13:30:06 <lmj`> There's DPH, but it doesn't quite fit this case, it seems.
13:31:13 <lmj`> I should say "implicit parallelism", not "automatic parallelism".
13:31:57 <acowley> Zylaa: Making lenses isn't the hard part, but making type classes arguably is. The example of "x" just jumped out at me because we specifically addressed that in linear. You might be interested in checking out vinyl for another approach that allows more flexibility in record fields.
13:32:26 <znutar> Wasn't there some site benchmarking the B&B stuff against some BLAS libs and getting some surprising results a week or two ago?
13:32:55 <dolio> Making the type class isn't hard, either.
13:32:58 * hackagebot Thrift 0.6.0.1 - Haskell bindings for the Apache Thrift RPC system  http://hackage.haskell.org/package/Thrift-0.6.0.1 (OzgunAtaman)
13:33:39 <acowley> dolio: No, but it's harder than not doing anything at all, I suppose.
13:33:50 <dolio> Yeah.
13:34:22 <dolio> But while some people don't want to make type classes for their overloading, I don't want to have a second, completely separate ad-hoc overloading mechanism in the language. :)
13:36:30 <acowley> I'm hopeful that vinyl is genuinely useful. It's at least zero-overhead for the work I want to put it to.
13:39:12 <fryguybob> znutar: Are you thinking of this: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf ?
13:42:59 * hackagebot sunroof-compiler 0.2 - Monadic Javascript Compiler  http://hackage.haskell.org/package/sunroof-compiler-0.2 (JanBracker)
13:43:01 * hackagebot sunroof-server 0.2 - Monadic Javascript Compiler - Server Utilities  http://hackage.haskell.org/package/sunroof-server-0.2 (JanBracker)
13:43:03 * hackagebot sunroof-examples 0.2 - Tests for Sunroof  http://hackage.haskell.org/package/sunroof-examples-0.2 (JanBracker)
13:50:59 <Saizan> a
13:57:53 <dgpratt> b
13:58:50 <acowley> I think Saizan was giving us an unenthusiastic Fonzie impression
13:59:37 <dgpratt> :)
13:59:46 <Saizan> or i'm just very clumsy with my keyboard, but i'll leave you in the doubt
14:11:42 <klrr> ?src const
14:11:42 <lambdabot> const x _ = x
14:11:48 <klrr> lol
14:15:53 <klrr> does "f :: a -> IO String" mean it returns a string that and may also affect the oustide world?
14:16:40 <Kinnison> Sorta
14:17:02 <Kinnison> certainly (IMO) that's not a bad way to begin thinking about it
14:17:15 <FireFly> It means it returns an IO String, which is a box that you could eventually extract a String from, sort of
14:17:24 <Kinnison> however, remember that klrr won't actually produce its output until it is "unboxed" inside an IO function
14:17:28 <FireFly> ...although I probably shouldn't attempt to help with things I don't fully understand yet
14:17:31 <Kinnison> :-)
14:18:41 <byorgey> an IO String is not a box.
14:18:51 <byorgey> think of it instead as an imperative program
14:19:08 <byorgey> when it gets run, it may have some effects and will eventually produce a value of type a.
14:19:32 <byorgey> @quote ls.contains
14:19:32 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:19:58 <koala_man> I'm stealing that
14:21:30 <donri> byorgey: isn't that assuming termination?
14:22:02 <fengshaun_> is there a URI handling library that can handle making URIs with more than a single query string?  Network.URI and Text.URI are too basic
14:22:07 <byorgey> donri: yes.
14:22:08 <Nisstyre-laptop> FireFly: I don't see a problem with thinking of it as a box
14:22:22 <Nisstyre-laptop> FireFly: remember that IO itself is a type, it doesn't *have* to be an instance of Monad
14:22:30 <koala_man> or a burrito
14:22:31 <FireFly> Yep, sure
14:23:08 <fengshaun_> I don't like making URIs by concatenating string together!
14:23:19 <donri> fengshaun_: is that valid for URIs though?
14:23:33 <quchen> fengshaun_: What would you like to do?
14:23:43 <fengshaun_> yea, like http://mysite.com/?query1=eua&abc=def etc.
14:24:07 <donri> isn't that url_params in Network.URL
14:24:20 <fengshaun_> hmmm let me check again
14:24:56 <fengshaun_> donri, I can't find it
14:24:56 <donri> oh Network.URI
14:24:57 <romm> can i programmatically reference the kind of a type? (that is, not with :k)
14:25:08 <Nisstyre-laptop> romm: not at runtime
14:25:09 <donri> fengshaun_: well i think the syntax of the query string is unspecified
14:25:17 <startling> romm: nope
14:25:22 <fengshaun_> I could easily make something like that for my purposes, but I thought I should reinvent thewheel
14:25:27 <fengshaun_> oh
14:25:37 <startling> you could maybe use hint or something using the ghc api though
14:25:47 <romm> okay, so this becomes more of a theoretical question: is :k Int == :k Char?
14:25:59 <Nisstyre-laptop> romm: they are both * I think
14:26:06 <byorgey> romm: yes
14:26:09 <donri> fengshaun_: you could try the url package, but i don't remember which package is recommended
14:26:31 <romm> okay, so basically the distinction is whether it is concrete or not.
14:26:34 <fengshaun_> donri, Text.URI doesn't have what I'm looking for either
14:26:45 <romm> thanks
14:26:50 <donri> fengshaun_: url, not uri
14:26:50 <Nisstyre-laptop> romm: kinds are the types of type constructors
14:27:00 <djahandarie> I wonder if you could somehow reify kinds down to the value level.
14:27:02 <fengshaun_> donri, whoops, pairsToQuery
14:27:03 <mikeplus64> romm: if kinds are the types of types, then one way of looking at * is data * = Int | Char | Double | Float | ... for all values ...
14:27:34 <Nisstyre-laptop> romm: and you can define new kinds with XDataKinds
14:27:51 <fengshaun_> donri, ohhh Network.URL works! :D  thanks!
14:27:57 <romm> mikeplus64, got it. just wanted to know if there aren't different subsets of the '*' concrete kind.
14:28:07 <Nisstyre-laptop> so instead of * you could have FooBar as a kind
14:28:22 <romm> Nisstyre-laptop, i'll get there :)
14:28:26 <Nisstyre-laptop> then you would only be able to use things of kind FooBar in that context
14:29:02 <djahandarie> :k Int#
14:29:05 <lambdabot>     Not in scope: type constructor or class `Int#'
14:29:05 <lambdabot>     Perhaps you meant one of these:
14:29:05 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
14:29:19 <djahandarie> :k (->)
14:29:20 <lambdabot> * -> * -> *
14:29:52 <Nisstyre-laptop> :k Maybe
14:30:05 <lambdabot> * -> *
14:30:11 <klrr> how does liftIO works?
14:30:17 <Nisstyre-laptop> why is lambdabot lagging so hard?
14:30:28 <quchen> klrr: How familiar are you with transformers?
14:30:50 <quchen> klrr: liftIO basically means "lift this IO action all the way so I can use it in my transformer"
14:31:47 <metaweta> In the type declaration tourist :: (Next from to, Show part)   => from -> part -> IO (Maybe part, to), how does it know which instance of "Next from to" to use?
14:31:53 <klrr> quchen: i dont really know anything about transformers
14:32:04 * djahandarie can't think of a way to get lambdabot to show #
14:32:06 <ab9rf> lots of very thin wire
14:32:23 <quchen> klrr: Then that's the place to start. liftIO is exclusively used for transformers.
14:32:25 <ab9rf> metaweta: source?
14:32:33 <metaweta> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip1/
14:32:38 <klrr> quchen: does LYAH teach transformers?
14:32:49 <quchen> klrr: No. RWH talks about them though.
14:33:15 <klrr> okey
14:33:20 <quchen> klrr: But it's something to look at when you're through LYAH already. You need some understanding of monads first.
14:33:21 <ab9rf> metaweta: instance?  Next from to is a type, not a class.
14:33:55 <ab9rf> ah, i misread that
14:33:59 <ab9rf> that's a type constraint
14:34:03 <metaweta> Yeah
14:34:30 <ab9rf> metaweta: it doesn't use any particular instance.
14:34:46 <klrr> quchen: i dont care about monads, ive followed Wrte YOurself a Scheme in 48 hours without knowing what a monad is, i understand the code fully except this new function liftIO
14:34:49 <metaweta> I read it as, "assuming you can get an instance of "Next from to", use that instance's "next" method
14:34:59 <ab9rf> metaweta: that's a polymorphic type
14:36:05 <metaweta> ab9rf: Just above the declaration of tourist, there's an instance declaration "instance Next Before After where next Before = After"
14:36:14 <ab9rf> metaweta: yes, that's one instance.
14:36:49 <metaweta> ab9rf: and the compiler uses that definition of next in tourist when running "stop Before tourist term"
14:36:52 <ab9rf> metaweta: if you try to use tourist with an argument that doesn't have an instance for Next the compiler will complain that there's no instance of Next
14:37:10 <metaweta> Will it also complain if there are two instances?
14:37:23 <quchen> klrr: Well, you should know a little about monads. They're a very central concept in Haskell. liftIO is only used in a monadic context. If you really want to see it as a black box, then "it's something that lets you execute IO actions out of a non-(direct-) IO context".
14:37:33 <ab9rf> metaweta: overlapping instances?
14:37:50 <ab9rf> i think so, at least by defaulyt, but i think there's n extension tht allows overlappipng instances
14:38:20 <klrr> quchen: well, i know how to use monads, just not what the words means in theory
14:38:28 <metaweta> ab9rf: sorry, I'm a beginner in Haskell.  Is it possible to declare more than one instance of a particular type?
14:38:33 <quchen> klrr: So in your Scheme tutorial, you're in the Error monad, but you want to execute an IO action (e.g. print something). That's why you have to use liftIO.
14:38:43 <quchen> klrr: Oh, you don't need to know about theory to use them at all.
14:38:59 <ab9rf> metaweta: you can have as many instances of a _class_ as you like
14:39:32 <ab9rf> metaweta: but you can't declare the same type (or combination of types) to be an instance more than once
14:39:42 <quchen> klrr: The problem with my explanation above is that leaving away the proper words leads to some dangerous half-truth that makes liftIO sound like unsafePerformIO. liftIO is fine, unsafePerformIO you should stay the hell away from.
14:39:44 <ab9rf> types don't have instances.  types _are_ instances.
14:40:09 <Ontolog_> Why does Haskell's Data.Set.insert :: (Ord a) -> a -> Set a -> Set a require a to be Ord? Is this imposing the particular implementation of Set on the user?
14:40:17 <metaweta> ab9rf: "you can't declare the same type (or combination of types) to be an instance more than once"  That was what I was missing.  Thanks!
14:40:35 <quchen> Ontolog: Sets are ordered trees.
14:40:36 <shachaf> Ontolog: Yes, it's related to the implementation of Set.
14:40:55 <Ontolog> that's unfortunate
14:41:03 <shachaf> Ontolog: You could do it with just an Eq constraint, but it would be much less efficient.
14:41:08 <ab9rf> why?
14:41:11 <Ontolog> if Set is suppose to mean a set from set theory
14:41:12 <shachaf> Ontolog: You couldn't do it with no constraint at all.
14:41:12 <ab9rf> Ord is fairly easy to meet
14:41:25 <ab9rf> Eq is required
14:41:27 <klrr> quchen: well, i dont really know what im doing, but i think im passing a IO [(a,b)] to liftIO
14:41:29 <Ontolog> Eq is required for sure
14:41:32 <ab9rf> it won't be a set witout Eq
14:41:36 <Ontolog> yes
14:41:37 <ab9rf> at best it'll be a bag
14:41:38 <Ontolog> you are correct.
14:41:40 <Ontolog> lol
14:41:45 <Ontolog> not arguing that
14:41:57 <shachaf> You can certainly make a Set-ish type without Eq, but it'll support different operations from Data.Set
14:42:03 <shachaf> type Set a = a -> Bool
14:42:32 <Ontolog> i'm just saying, imposing Ord on set elements makes it not a Set
14:42:45 <quchen> klrr: liftIO always takes an IO action. Its type is "MonadIO m :: IO a -> m a". Your case should typecheck at least, I can't say more without seeing the code though.
14:42:45 <shachaf> I'm sorry.
14:43:05 <DanielDiaz> hi all, I just installed Ubuntu in my machine and tried to install the Haskell Platform. The thing is that it freezes my computer whenever it says "Linking". Any ideas of the source of this problem?
14:43:06 <ab9rf> Ontolog: no, it just makes it a limited domain
14:43:06 <Ontolog> shachaf: oh.. did you build the Set implementation?
14:43:11 <shachaf> No.
14:43:18 <ab9rf> hey're still sets, just not as general as you'd might like
14:43:37 <shachaf> Ontolog: Ord makes sets much more useful.
14:43:42 <ab9rf> DanielDiaz: not enough memory?
14:43:44 <DanielDiaz> I am compiling the HP from source
14:43:44 <Ontolog> ab9rf: sure, thats more accurate. so it should be called SetOfOrds lol
14:43:53 <shachaf> If there was an Eq-based implementation of Set I would probably never use it.
14:43:57 <hpc> Ontolog: among other things, you can't write a Functor instance for shachaf's Set
14:44:00 <klrr> quchen: http://hpaste.org/85657
14:44:06 <ab9rf> an Eq-based Set would be horribly inefficient
14:44:08 <Ontolog> shachaf: im sure it does i actually don't have a problem with it at the moment other than purity of definition :p
14:44:13 <quchen> shachaf: What about HashSet?
14:44:18 <shachaf> hpc: Well, you can't write one for Data.Set either. :-)
14:44:20 <hpc> (you can't write a standard Functor instance for an ord-Set either, but you can if you use your own Functor with a constraint
14:44:22 <DanielDiaz> ab9rf: In Windows, same machine, it works perfectly
14:44:23 <hpc> )
14:44:31 <shachaf> quchen: What about it?
14:44:39 <ab9rf> DanielDiaz: so?  could still be not enough memory.
14:44:57 <quchen> shachaf: Isn't it Set with only an Ord constraint? Well, and Hashable
14:45:00 <DanielDiaz> ab9rf: If you mean hard drive, I have plenty of GBs free
14:45:05 <quchen> Eh, I meant Eq
14:45:05 <hpc> that other Set type admits a... i forget what a "backwards functor" is
14:45:06 <romm> i have to say, the constraint syntax in typeclasses is... an odd choice.
14:45:09 <ab9rf> DanielDiaz: windows will make a pagefile by default.  ubuntu, i'm not so sure.
14:45:28 <ab9rf> DanielDiaz: no, i mean real memory.  check the OS console for OOM killer notices?
14:45:30 <hpc> cofunctor
14:45:46 <hpaste> suppliercraft pasted “Anekahosting.com web hosting murah terbaik di indonesia” at http://hpaste.org/85658
14:45:53 <shachaf> quchen: OK. If there was an implementation of Set that used SetElement a => ..., maybe I'd use that too.
14:46:04 <ab9rf> quchen: if Ord is too onerous, i'm not sure Hashable is much better :)
14:46:24 <shachaf> Whatever "purity" thing Ontolog is after, I'm sure Hashable is much worse than Ord for it.
14:46:27 <DanielDiaz> ab9rf: No idea. In the info about the system it says "Memory 1.7GiB"
14:46:46 <shachaf> Anyway: Set uses Eq+Ord. HashSet uses Eq+Hashable. They're both "Eq-based".
14:47:22 <startling> hpc, contravariant functor?
14:47:30 <quchen> klrr: your type "IOThrowsError" is actually a monad transformer, presumably "ErrorT e IO". Therefore, your do block executes actions of type "ErrorT e IO a". You now want to read an IORef in that block, which means you want to use an IO action. But that won't typecheck - you need an ErrorT... after all! That's where liftIO comes in handy: it maps "IO a -> ErrorT e IO a" in your case, so you can use your readIORef in an ErrorT... context.
14:47:40 <ab9rf> DanielDiaz: does the whole system freeze, or just the compiliation process? d di you check for CPU or IO activity on the compiler?
14:48:22 <DanielDiaz> ab9rf: the whole system freezes. My second day using linux, where do I check that?
14:48:47 <startling> DanielDiaz, on your calendar presumably
14:48:59 <ab9rf> DanielDiaz: i suspect you have a problem with your linux installation, but i can't be sure about that.
14:49:22 <geekosaur> system freeze while linker could be an overzealous oom killer
14:49:29 <geekosaur> *while linking
14:49:37 <startling> linking always takes forever anyway
14:49:40 <ab9rf> DanielDiaz: this is probably not a Haskell-specific issue; my guess is that you don't have a swap file and the system is going grooooonk when it goes to link GHC, which is a fairly large application and probably requires more than 1.7 GB of RAM to link
14:49:41 <startling> could just be paging out
14:49:52 <scalable> startling: lol
14:49:58 <Tene> DanielDiaz: look at the output of: free -m
14:50:11 <DanielDiaz> I am linking executables from libraries, not the GHC itself, which I already have
14:50:23 <Tene> the Swap: line will tell you how much paging space you have available.
14:50:37 <klrr> quchen: thanks!
14:50:40 <startling> DanielDiaz: yep. linking haskell code takes freaking forever
14:50:51 <ab9rf> yeah it really does
14:51:09 <startling> I've got 1gb; I usually go and make coffee or something if it's a big package.
14:51:20 <Tene> DanielDiaz: if you want to watch memory usage over time, run: vmstat 1
14:51:21 <DanielDiaz> startling: At least I should be able of doing something else while linking?
14:51:22 <ab9rf> with 1GB i'd expect considerable swapping
14:51:40 <ab9rf> DanielDiaz: not if you don't have a swap file, which ubuntu doesn't create for you by default
14:51:46 <startling> ^
14:51:47 <DanielDiaz> Tene: That's a cool one. Thanks.
14:51:56 <Tene> The ubuntu installer does set up swap space by default.
14:52:11 <ab9rf> Tene: hm, maybe i told it not to then :)
14:52:18 <DanielDiaz> Tene: Yes. I am trying successfully the vmstat 1
14:52:20 <ab9rf> i haven't used ubuntu in three or four years :)
14:52:23 <Tene> 1 GB is very low for most linux desktop environments today.
14:52:45 <DanielDiaz> Tene: Well, the computer only has some months!
14:53:02 * hackagebot hlibgit2 0.17.0.7 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.17.0.7 (JohnWiegley)
14:53:03 <DanielDiaz> Tene: And in Windows was working just fine.
14:53:06 <ab9rf> Tene: the compute ri'm on has 256 megs :)
14:54:36 <Tene> DanielDiaz: Yeah, a lot of linux desktop stuff really isn't built for "low memory" environments.  You might consider looking into something like enlightenment if you're having memory trouble.
14:54:57 <donri> DanielDiaz: could probably search for System Monitor in the unity dash thing also
14:55:03 <DanielDiaz> Tene: So is it a memory problem for sure?
14:55:23 <Nisstyre-laptop> XMonad is pretty light on memory usage
14:55:24 <Tene> DanielDiaz: That's just a guess, but it's plausible.  You said vmstat doesn't work?
14:55:27 <Nisstyre-laptop> I mean, relatively speaking
14:55:36 <DanielDiaz> Tene: vmstat works fine
14:55:43 <tgeeky> DanielDiaz: you are running Linux in a VM, or natively? Sorry if you've already answered
14:55:50 <Tene> Oh, I misread "unsuccessfully"
14:55:54 <DanielDiaz> tgeeky: natively
14:56:22 <Tene> DanielDiaz: Run your compile again while watching the output of vmstat; that should tell you whether you run out of memory, whether you're swapping to disk, etc.
14:56:27 <DanielDiaz> DanielDiaz: And other programs like web browsers, music and video players, skype... everything works perfectly
14:56:45 <DanielDiaz> Tnee: I'll try that
14:57:18 <donri> DanielDiaz: i recently read that unity is the most memory hungry linux desktop. what windows version btw?
14:57:37 <tgeeky> DanielDiaz: also, FWIW, you can press Ctrl+Alt+[Fn N] where you're probbly starting at Fn 6 or Fn 7
14:57:45 <donri> DanielDiaz: btw why are you compiling haskell-platform, it's packaged for ubuntu
14:57:46 <DanielDiaz> donri: I was using Windows 7.
14:57:50 <tgeeky> DanielDiaz: to switch to a console to determine if the whole computer is frozen, or just X is frozen
14:58:00 <donri> DanielDiaz: sudo apt-get install haskell-platform
14:58:23 <donri> or search for haskell in the Software Center
14:59:00 <DanielDiaz> donri: Well, I have never done it from the source, and I wanted to try. But if it's going to freeze it all each time I am going to link, I am not even interested in installing it!
14:59:37 <donri> are you using an NFS or something
14:59:37 <tgeeky> DanielDiaz: now now. Let's try to understand the problem fully before we assign blame.
15:00:00 <DanielDiaz> tgeeky: yes, I am building again.
15:00:01 <romm> DanielDiaz, the fact that linking freezes your computer might be completely unrelated to haskell, you know.
15:00:10 <tgeeky> donri: he's on day # 2 of linux, he probably doesn't even know what nfs is :o
15:00:27 <donri> also, just because compiling the whole platform eats memory doesn't mean that's true for most haskell packages
15:00:29 <Tene> DanielDiaz: You say that you've never done it before, but you also said that you've done it without trouble in windows?  I think I must misunderstand something.
15:00:54 <romm> day #2 on linux is not the recommended day to build haskell from source. or anything, for that matter.
15:00:57 <DanielDiaz> Tene: Sorry, I meant linking executables using GHC.
15:01:17 <donri> romm: day #2 of LFS? :)
15:01:28 <romm> DanielDiaz, wait, so you already have GHC installed on your Ubuntu?
15:01:56 <romm> donri, hah, well... not much of a choice there, is there? :)
15:02:05 <Tene> DanielDiaz: Haskell platform is really an exceptionally large case; I wouldn't be surprised if it needed more than 1GB to build.
15:02:16 <Tene> I haven't checked personally, though.
15:02:39 <donri> for one it includes compiling ghc
15:06:35 <quchen> Why do linkers need so much memory anyway?
15:06:53 <quchen> You can get a lot of symbols in a gigabyte
15:07:54 <c_wraith> as I understand it, ld is just not designed to be memory-efficient
15:08:17 <c_wraith> Like, it wasn't ever a consideration at any point along the way, so it's kind of too late to retrofit it in
15:08:35 <quchen> c_wraith: Hm. But then I would think it takes megs instead of kilos.
15:08:50 <donri> is the gold linker better at that?
15:08:58 <c_wraith> donri: yes, gold is much better at that.
15:08:59 <DanielDiaz> OK, I am back. I had to reboot.
15:09:00 <hpaste> Ontolog pasted “ Not in scope: data constructor `Set.Set'” at http://hpaste.org/85659
15:09:27 <Ontolog> I'm having trouble with line 14
15:09:58 <donri> Ontolog: can't pattern match on Set
15:10:00 <c_wraith> Ontolog: Set is abstract. It doesn't expose constructors
15:10:04 <donri> there's no data constructor exported
15:10:08 <Ontolog> ok so wtf do i do
15:10:13 <Ontolog> i took out the constructor as well
15:10:14 <Ontolog> lol
15:10:16 <Ontolog> nothing works
15:10:27 <thoughtpolice> well, there's probably room for improvement in ld. it's design was set at one point but ELF etc kept moving in features. this makes some of the things it does awkward, like walking symbol tables
15:10:34 <c_wraith> you need to pattern-match on the *Graph* constructor
15:10:49 <thoughtpolice> gold was designed with like 15+ years of insight and a new codebase, so there's something to say for that too.
15:11:00 <c_wraith> Ontolog: also, it'd help a ton if you flattened Graph a bit. Just make it a two-arg constructor, not a constructor that takes a pair
15:11:24 <thoughtpolice> (ld etc also has to work with libbfd and other parts of binutils to support cross-platform-y-ness, which adds complexity too)
15:11:34 <thoughtpolice> there's a decent paper about the design of gold and all this somewhere
15:11:35 <applicative> similarly with Edge, no c_wraith ?
15:11:49 <klrr> what's a Handle?
15:11:58 <c_wraith> applicative: yes, I didn't even look at it, as I was just scanning stuff I saw along the way
15:12:09 <quchen> klrr: It's like a file pointer.
15:12:10 <applicative> data Edge = Edge !Vertex !Vertex
15:12:17 <romm> klrr, not 100%, but i think it's the haskell file descriptor.
15:12:36 <hpaste> donri revised “ Not in scope: data constructor `Set.Set'”: “something like this” at http://hpaste.org/85659
15:12:42 <Ontolog> wtf is !
15:12:49 <klrr> in a scenario with sockets, what's a Handle?
15:12:56 <applicative> Ontolog: data Graph  = Graph (Set.Set Vertex) (Set.Set Edge) is what c_wraith meant
15:13:03 <Ontolog> applicative: i got that
15:13:06 <Ontolog> applicative: what is !
15:13:22 <quchen> klrr: You can see the socket as something you can write to, similar to a file. (Or read)
15:13:24 <c_wraith> klrr: Handle is an abstraction for doing IO with many different kinds of devices
15:13:27 <applicative> a strictness annotation, it may not matter here
15:13:32 <donri> Ontolog: see my edit
15:13:46 <quchen> klrr: so "hPutStrLn socketHandle" writes data to the socket "socketHandle".
15:13:59 <donri> guess i meant to annotate. is this a new thing in hpaste?
15:14:14 <applicative> Ontolog: its one of the reasons not to use a tuple, it will be lazy, but basically Vertex and Edge for you are numbers, so they should be handled strictly
15:14:33 <klrr> okey, so handle is a variable name for a socket?
15:14:50 <Ontolog> thanks people
15:15:03 <donri> Ontolog: http://hpaste.org/diff/85659/85660
15:15:11 <applicative> with data Edge = Edge !Vertex !Vertex and optimization, Edge will contain two unboxed Ints
15:15:18 <c_wraith> klrr: not really, in the C api sense of the word "socket"
15:15:24 <dmj> Hi, I'm playing with concurrency in haskell, I am generating a file that is 1GB (a billion chars at 1 byte each). I want to do this 5 times from a new thread but it isn't working :(
15:15:28 <hpaste> dmj pasted “Haskell Concurrency Q's” at http://hpaste.org/85661
15:15:28 <quchen> klrr: something like that, yes. 'h <- connect ...; hPutStrLn h "foobar"' would first open a connection, call it h, and then write "foobar" to it.
15:15:41 <klrr> so if something returns a IO Handle, how does that Handle look like?
15:16:12 <c_wraith> klrr: Handle is an *abstract* thing for reading or writing stream IO
15:16:22 <klrr> it's a bad abstarction
15:16:25 <niteria> you probably don't want to look at it, there are some functions that operate on it
15:16:26 <klrr> i dont understand anything
15:16:36 <dmj> oh I think I know my problem, main thread is terminating... killing all others
15:16:39 <quchen> klrr: It's how every single programming language I know deals with files.
15:16:51 <c_wraith> dmj: yeah, programs quit when the main thread finishes.
15:16:59 <klrr> in C it's easy to understand, Handle is hard to understand
15:17:12 <Ontolog> already coming up against the problem of Set requiring things elements to be Ord. Now I need to define an ordering on Edge :p is there a standard ordering for edges in a simple graph?
15:17:24 <niteria> what's the difference?
15:17:26 <dmj> c_wraith: so I should put main at the end? Wouldn't this cause an infinite loop?
15:17:28 <quchen> klrr: It's like *file in C. It points to where the next data is written, sort of.
15:17:42 <klrr> bs
15:17:47 <geekosaur> wat
15:17:47 <donri> Ontolog: add "data Edge = ... deriving Ord"
15:18:13 <Ontolog> donri: i have no idea what that will do though
15:18:16 <c_wraith> dmj: I commonly do something like a takeMVar from an MVar () that will be written to when the other threads are done
15:18:19 <quchen> Careful, some people may read "bs" as "bullshit" and lose interest in helping.
15:18:40 <Rembane_> Bytestring?
15:18:46 <donri> Ontolog: it will derive the ordering from the types used in Edge
15:18:51 <quchen> Rembane_: Good catch :D
15:19:04 <Ontolog> donri: sure i get that but how does it derive the ordering? adding the two ints? lol
15:19:27 <c_wraith> Ontolog: the actual ordering isn't important. Set just requires that there be one
15:19:30 <donri> Ontolog: probably same as (Int,Int)
15:19:38 <dmj> c_wraith: is mvar used only for threads communicating with one another? In this example shouldn't they be able to just work simultaneously?
15:19:40 <romm> in LYAH / making-our-own-typeclasses, Frank is an instance of Tofy, but he writes "instance Tofu Frank where tofu x = Frank x". why not tofu = Frank?
15:20:10 <quchen> romm: Because adding the "x" explicitly might be clearer to new people.
15:20:30 <dmj> romm: instance Monad Maybe where return = Just (could be return x = Just x)
15:20:32 <donri> Ontolog: and what c_wraith said. Set just uses Ord to make a binary tree for logarithmic time complexity
15:20:36 <quchen> romm: Leaving the trailing "x" away is called point-free style.
15:20:37 <niteria> isn't it related to monomorphism restriction?
15:20:38 <romm> quchen, okay. no hidden meaning then.
15:20:41 <c_wraith> dmj: MVars are the most basic cross-thread signaling API in GHC. They do a bit more than that, but it's not overkill to use them for just that
15:20:59 <quchen> romm: Nope
15:21:22 <quchen> niteria: Hmm, that may be. I don't understand that restriction and work it out on a per-case basis.
15:21:28 <Rembane_> quchen: ^
15:21:32 <Rembane_> quchen: ^^
15:21:32 <c_wraith> dmj: the main point of my suggestion is just to have the main thread wait until the rest are done, in some way, especially without busy-looping
15:21:34 <quchen> niteria: LYAH doesn't deal with that though :-)
15:21:45 <dmj> c_wraith: How do I get the main thread to wait until all the other threads that were spawned finish? like a join
15:22:13 <quchen> dmj: Either use a lock (bad) or the async package (good)
15:22:18 <niteria> quchen: same with me, but everytime I see eta expansion I think it must've been monomorphism restriction
15:22:34 <dmj> quchen: what's a good async package?
15:22:44 <quchen> dmj: async, for example :P
15:22:51 <quchen> It's in the current platform
15:23:04 <quchen> http://hackage.haskell.org/package/async
15:23:36 <dmj> quchen: :), I did a cabal install. tanks
15:24:18 <donri> the Concurrently Alternative is cute
15:24:24 <klrr> what does Handle contain, does it contain strings which contain the location of a file, or what is it ?
15:24:42 <applicative> Ontolog: data Edge   = Edge !Vertex  !Vertex deriving (Show , Eq, Ord) for the meantime
15:24:56 <c_wraith> klrr: it's *abstract*. stop asking. (you won't understand the answer anyway...)
15:25:01 <dmj> c_wraith: thank you as well
15:25:12 <applicative> Ontolog: forget it I'm too slow for #haskell
15:25:12 <donri> klrr: i think it's just an abstraction for OS file descriptors
15:25:24 <quchen> klrr: C: FILE *fp;   Haskell: data Handle = ...
15:25:26 <c_wraith> klrr: since the answer is that it's an existential wrapper around reading and writing
15:25:56 <quchen> klrr: C: FILE *fopen(const char *filename, const char *mode); Haskell: openFile filename mode  -->   handle
15:26:09 <Ontolog> well im not using ! until i understand them but yeah it all works now
15:26:11 <Ontolog> Graph (Set.fromList [1..10]) (Set.fromList $ [ Edge x y | x <- [1..10], y <- [1..10] ])
15:26:14 <quchen> klrr: Replace C's FILE with "Handle" and the APIs are basically the same
15:26:20 <Ontolog> ^ creates a fully connected graph of 10 vertices
15:26:56 <niteria> can I use hackage to see reverse dependencies?
15:27:24 <niteria> it would be nice to see what packages use async
15:27:28 <quchen> niteria: I think so, some people happily posted the citation count in here in the past.
15:27:35 <quchen> Not sure how.
15:27:38 <new_one> Hi, I'm trying to write a quick "Hello, world." When ghc compiles, it says /usr/bin/ld: cannot find .: File format not recognized
15:27:53 <new_one> I am not sure what it's looking for/how to fix it
15:28:17 <new_one> Code is from the wiki: main = putStrLn "Hello, world"
15:28:47 <dmj> new_one: might be too obvious, but, does your file have the .hs extension?
15:28:50 <Twisol> new_one: How are you compiling it?
15:29:13 <quchen> new_one: The code is good, so it's not your source code at least :-)
15:29:42 <applicative> Ontolog: now write a function to put it in whatever that graphviz format is called
15:29:53 <quchen> dot
15:29:54 <quchen> .
15:30:06 <new_one> Haha sorry everyone, it was a mistake in the makefile
15:30:08 <romm> why is it that we can specify function signatures, but can't specify type signatures? why do i have to "guess" type variables?
15:30:10 <dmj> new_one: try "ghc Main.hs -o main" or just "ghc Main.hs"
15:30:12 <Ontolog> applicative: actually i was intending on doing some graphics with these graphs so that's a great idea :)
15:30:20 <new_one> thanks for the help :)
15:30:27 <dmj> new_one: what was the issue?
15:30:58 <Twisol> romm: What do you mean?
15:31:16 <new_one> I wrote ARGS = "" at the top, thinking that an empty string wouldn't change anything when compiled ghc -o hello prac.hs $(ARGS)
15:31:31 <new_one> But I forgot that it would look for a file called ""
15:31:36 <new_one> and try to compile that
15:31:37 <quchen> romm: There's no such thing as a "function signature". There are type signatures, and a little more advanced: kind signatures.
15:31:55 <romm> quchen, oh, so there *are* kind signatures?
15:31:59 <quchen> romm: Maybe paste some code where the problem occurs?
15:32:31 <ryant5000> is it possible to disable the typechecking that occurs *before* a splice is interpreted?
15:32:31 <romm> Twisol, quchen, how do i specify the kinds of a and b for "data Foo a b = ..."
15:32:33 <dmj> new_one: cool, glad its working
15:32:46 <ryant5000> when you quote some code, it seems to get (partially?) typechecked
15:33:17 <Twisol> romm: Have you seen this? http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
15:33:46 <quchen> romm: Should be simply "data Foo a b :: * -> * -> * where ..." if I recall correctly
15:34:06 <romm> Twisol, nope, still reading LYAH
15:34:24 <Twisol> romm: It provides some syntax for providing an explicit kind for a datatype
15:34:31 <Twisol> romm: which happens to be what quchen just pasted :)
15:34:57 <quchen> romm: Oh, when you're still in the LYAH phase you really don't need to worry about specifying them.
15:35:15 <quchen> romm: Kinds in LYAH are more or less introduced so you've heard of them if you ask me.
15:35:40 <quchen> Needing to specify kind signatures is somewhat advanced.
15:36:04 <quchen> When you understand that the "f" in functor definitions has kind "* -> *" you should be fine. :-)
15:36:21 <romm> doesn't seem that advanced to me. it seems odd that we need to discuss "guessing" the kinds of type variables.
15:36:38 <romm> which is what he does in LYAH. oh well... i'll skip this for now.
15:36:59 <romm> quchen, that i understood.
15:37:30 <quchen> romm: What's the kind signature of Either?
15:37:35 <romm> although that book is in dire need of exercises.
15:37:44 <quchen> Oooh yes it is.
15:37:52 <applicative> does the print version have exercises?
15:37:57 <quchen> Nope
15:38:05 <applicative> hm
15:38:08 <quchen> Online is what you get in print too
15:38:23 <romm> quchen, hmm... something like (* -> *) -> * -> *?
15:38:31 <romm> no wait
15:38:37 <quchen> RWH has exercises though, so maybe look at those. Maybe you can solve some of them without reading the book just by looking at the description.
15:38:41 <applicative> yeah, you'd think they'd have been clever enough to make him write exercises for them
15:38:42 <quchen> romm: "oh wait" is correct. :-)
15:39:18 <applicative> that's the monad transformer kind signature ...
15:39:24 <Twisol> Isn't it just * -> * -> *?
15:39:26 <romm> isn't it just * -> * -> *?
15:39:29 <Twisol> jinx.
15:39:30 <quchen> Bingo
15:39:31 <quchen> Bingo
15:39:35 <applicative> yes
15:39:43 <applicative> @kind Either -- ?
15:39:44 <lambdabot> * -> * -> *
15:39:52 <applicative> ah it works
15:39:55 <quchen> applicative: Transformers take a monad and make a new monad out of that.
15:40:03 <quchen> What's the Monad kind?
15:40:16 <applicative> right so isn't that (* -> *) -> * -> *
15:40:18 <johnw> @kind ReaderT
15:40:20 <quchen> Eh, I meant "monad" :-)
15:40:20 <lambdabot> * -> (* -> *) -> * -> *
15:40:25 <romm> no idea what a Monad is in haskell.
15:40:35 <Twisol> romm: Oh you're in for a treat :>
15:40:40 <c_wraith> romm: that's fine. It doesn't really matter anwyay :)
15:40:43 <applicative> @kind Maybe
15:40:44 <lambdabot> * -> *
15:40:46 <quchen> romm: It'll come a little later. The hierarchy is Functor->Applicative->Monad, and that's how LYAH does it too.
15:41:11 <romm> let me guess... Monad to math monad is like Functor to math functor? ugh.
15:41:11 <applicative> LYAH is really good on that bit, I think
15:41:39 <applicative> dont worry about it, it's idiot simple once you get to it
15:42:02 <niteria> quchen: found it, http://packdeps.haskellers.com/reverse/async if you wondered
15:42:04 <thirsteh> is there an easy way to get profiling set up without installing all packages from debian repos?
15:42:27 <thirsteh> reinstalling libs with library-profiling: True using cabal feels like a nightmare
15:42:30 <applicative> ah so people are starting to use the async library
15:42:31 <quchen> niteria: Nice! Thanks for telling
15:42:57 <applicative> thirsteh: put it in cabal/.config
15:43:01 <thirsteh> I did
15:43:23 <applicative> oh. well starting over with profiling on is a nightmare yes
15:43:24 <thirsteh> one package after the other fails to install, and --force-reinstall/--reinstall doesn't help, just asks me to run ghc-check
15:43:41 <thirsteh> I don't care if I have to reinstall all packages, I just wonder if there is a way to do it
15:43:50 <thirsteh> I'm fine with uninstalling haskell-platform from debs if that makes it easier
15:44:02 <applicative> thirsteh: yeah, if it's the ordinary case I'm thinking of you should get rid of everything and start over.
15:44:06 <quchen> romm: Don't be scared by monads. Most people don't understand them in the beginning, but after using them for some time they become crystal clear.
15:44:20 <quchen> romm: Prepare some snacks and a boxing sack though :D
15:44:31 <thirsteh> applicative: meaning get just ghc and cabal, and install everything using cabal? Or can you at least get those two from debian repos?
15:45:05 <thirsteh> I have haskell-platform installed, installed haskell-platform-prof, but that made it worse, heh
15:45:21 <applicative> thirsteh: I think the wisdom is or was that you can get stuff from debian before you ever start using cabal install , but then dont go back to debian
15:45:39 <romm> quchen, oh, i'm not scared, really. it's more like trying to understand the point of all this abstraction.
15:45:39 <thirsteh> applicative: yeah, unfortunately that's what I've done
15:45:49 <niteria> it's the first time I hear about cqrs, is it actually good? looks like race condition factory
15:45:51 <thirsteh> or wait, I installed platform-prof after using cabal, I suppose
15:45:59 <thirsteh> gah, time to try removing everything :)
15:46:28 <quchen> romm: You will, you will. It takes some practice to appreciate it though.
15:46:40 <applicative> hm that may be causing problems. you want to unregister everything that's not with profiling, thus everything you locally installed
15:46:52 <klrr> what does hFlush stdout
15:46:53 <klrr> ?
15:47:16 <romm> klrr, i think it's like fflush(stdout)
15:47:19 <quchen> stdout is a Handle (of the standard output). hFlush flushes a Handle.
15:48:29 <quchen> romm: In the beginning, Haskell felt like a playground with nice ideas but strange shackles to me. After some time, you'll find out that the shackles are actually wings. :-D
15:48:33 <applicative> thirsteh: I'm not sure this is up to date, and it's a  little opinionated, but I still go by it: http://www.vex.net/~trebla/haskell/sicp.xhtml
15:49:50 <thirsteh> applicative: thanks!
15:49:57 <romm> quchen, meh... i know this might be the wrong place to say it, but it seems that, empirically, not many people are convinced that the wings are worth the effort.
15:50:01 <Twisol> romm: I actually hardly use Haskell. Instead, I take ideas I learn from Haskell and figure out how to apply them in my other projects. The abstraction really is awesome. :D
15:50:14 <romm> quchen, ^ :)
15:50:30 <Twisol> romm: I think you stopped reading too quickly.
15:51:04 <quchen> romm: Empirically, it seems that PHP is awesome because many people use it.
15:51:28 <romm> Twisol, i haven't stopped. just had my quota of LYAH for today.
15:51:31 <quchen> romm: Lisp has been around for decades, but its syntax doesn't look like C.
15:51:59 <Twisol> romm: I meant you didn't read the rest of what I said. I was actually giving Haskell (and its abstractions) glowing praise, not saying that I don't find the abstractions worth the effort.
15:52:11 <romm> quchen, if PHP allows people to create great software (and it does... i think) then in some way PHP is awesome.
15:52:31 <quchen> romm: Well then prosthetics are awesome legs because people can walk with them?
15:52:41 <quchen> Wouldn't a real leg be better?
15:52:53 <geekosaur> but if you can't have a real leg...
15:52:57 <romm> Twisol, i understand. my point is the Haskell is a brain toy rather than a pragmatic choice for engineers.
15:53:23 <geekosaur> there are in fact places which sue haskell in production
15:53:25 <Twisol> romm: Well, okay. I may have only used it in that capacity so far, but I must disagree anyway. :)
15:53:25 <c_wraith> romm: my company's success using haskell in production indicates that position is, umm... wrong...  at best.
15:53:34 <klrr> quchen: what means flushes?
15:53:50 <quchen> klrr: Do you know about buffering?
15:53:56 <geekosaur> because they want software that doesn't fail due to null pointers or wrong objects or other things you get from other languages
15:54:27 <c_wraith> romm: I assure you, haskell has been a *very* pragmatic choice. We've re-written the product nearly completely at least 5 times now.  And every time has been easy and painless.
15:55:11 <geekosaur> klrr, making a system call for every character you output is very expensive. most I/O libraries buffer file data instead, and flush it when you output a newline (for terminals) or when the buffer fills (for files, pipes, etc.)
15:55:14 <romm> c_wraith, you are still in a minority, mind you. the programming community at large is not yet convinced of this language's usefulness.
15:55:20 <c_wraith> romm: this is totally unlike any attempts to do so with the rails portion of the code base. (my position is now "don't use rails for anything where ability to make it do anything new and interesting is important)
15:55:39 <Ralith> @quote abstract research language
15:55:39 <lambdabot> No quotes for this person. You untyped fool!
15:55:43 <romm> c_wraith, what type of application?
15:55:45 <geekosaur> romm, by that hypothesis everyone should immediately switch to php and javascript and everything else is just a toy
15:55:47 <Ralith> er, what's the command for that
15:55:59 <geekosaur> @quote abstract.research.language
15:55:59 <quchen> @quote Jafet research
15:55:59 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
15:55:59 <lambdabot> s, phone apps, and web services.
15:55:59 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
15:55:59 <lambdabot> s, phone apps, and web services.
15:56:13 <Ralith> romm: ^
15:56:28 <c_wraith> romm: web services.  High performance api services, in particular.
15:57:09 <tgeeky> ab9rf: Tene: donri: romm: startling: RE: DanielDiaz's situation: the fix that seems to have worked, is to pass --reduce-memory-overheads and --no-keep-memory to LDFLAGS, and then use ulimit -Sv 750000 to keep the process from eating 1GB and swapping out everything.
15:57:17 <quchen> romm: All the "we love Haskell here" aside, I think the point about the language is that it harvests much more mathematical knowledge than the standard languages, and math has come a loooong way.
15:57:25 <Tene> My last company was having a lot of success replacing PHP with Haskell.
15:58:08 <quchen> romm: Also, it does this in the background - you don't need to know the math to benefit from.
15:58:17 <c_wraith> heck, Facebook has tools for refactoring their PHP code, written in haskell.
15:58:46 <thirsteh> applicative: I deleted ~/.ghc, and all debs except ghc, ghc-prof and cabal-install, and now it's chugging along nicely. The reference to ~/.ghc was what I was missing (was in the doc, thanks again.)
15:58:53 <ryant5000> c_wraith: why do you think they hired simon? :P
15:58:58 <hpaste> pascha pasted “returning struct” at http://hpaste.org/85663
15:59:02 <donri> ryant5000: or bos?
15:59:07 <applicative> ah, thirsteh sorry, I considered making that explicit
15:59:08 <romm> quchen, i don't know about that... it borrows some abstract notions from math, but it doesn't contain the underlying structures. this really isn't a "math" language.
15:59:11 <quchen> ryant5000: :'-(
15:59:15 <c_wraith> ryant5000: I *really* hope the answer is "to keep improving the GHC runtime". :)
15:59:18 <hpaste> “Anonymous Coward” pasted “should it fail or succeed” at http://hpaste.org/85664
15:59:20 <ryant5000> c_wraith: lol
15:59:31 <thirsteh> applicative: I'd heard about ghc-pkg before but I never really made the connection that it was keeping all of the metadata, not cabal
15:59:43 <quchen> romm: It translates very directly to some pretty mathy concepts, really.
16:00:04 <applicative> thirsteh: yes, you can also unregister directly, ghc-pkg unregister pony
16:00:19 <quchen> romm: For example, "Functor" isn't just a name for something that resembles mathematical functors - they *are* functors.
16:00:20 * thirsteh nods
16:00:24 <bos> c_wraith: the PHP refactoring tools are written in ocaml, actually
16:00:30 <applicative> thirsteh: this will of course leave the unused stuff in .cabal/lib
16:00:50 <c_wraith> bos: hmm.  Then what were you guys doing with PHP parsers and pretty-printers in haskell?
16:00:51 <thirsteh> deleted ~/.cabal too, just to be sure :)
16:01:02 <romm> c_wraith, i think that until i see some large projects in haskell, i'll remain skeptical. i mean no offence -- i'm still interested in the language.
16:01:03 <bos> c_wraith: never heard of them
16:01:19 <quchen> romm: GHC?
16:01:39 <applicative> thirsteh: ah, but that's where your config file is remember --
16:02:09 <thirsteh> applicative: I did. I made a new ~/.cabal and put the config inthere, making sure profiling and documentation were set to True ;)
16:02:28 <applicative> ah, okay; i was anticipating the sort of mistake I might make
16:02:43 <thirsteh> I only did that because I'd already made that mistake before
16:03:29 <quchen> romm: Well, if you think that I guess it's hard to convince you with examples or stories. When you stick with it you'll see the bigger picture, and that will most likely change the view.
16:03:50 <applicative> bos, there were such things https://github.com/facebook/lex-pass.git
16:04:20 <geekosaur> nobody anywhere uses smalltalk --- because you cant see all the huge propretary systems IBM has built with it
16:04:31 <geekosaur> therefore they don't exist
16:04:54 * applicative likes this simple geekosaur epistemology
16:05:01 <romm> quchen, i'm willing to learn, of course. i'm just saying that i don't think i'll ever think "i'd rather write this in haskell than in python"
16:05:17 <quchen> hihihi
16:05:20 <quchen> :P
16:05:24 <Twisol> romm: That's fine, none of us are zealots. (I think.)
16:05:26 <quchen> Wait for it ;-)
16:05:28 <johnw> romm: you'd be surprised
16:05:35 * applicative is a zealot
16:05:38 <thirsteh> romm: then you haven't been bitten by troubleshooting enough times yet
16:05:42 <johnw> romm: i switched my system scripting from Python to Haskell, and haven't looked back yet
16:05:43 <thirsteh> geekosaur: same thing with Erlang
16:05:55 <c_wraith> romm: heh. Spend a couple months in haskell, and python will be offensive to you. I was surprised the first time I went back to it after using haskell for a while. "I don't remember this language having this much *syntax* getting in my way..  Was it always like this?"
16:06:25 <quchen> def class Maybe where ... isNothing = False ...
16:06:35 <thirsteh> hard to get terser, though it does require some discipline
16:06:36 <quchen> DAMN I want my Haskell Maybe back! :-(
16:06:55 <niteria> "type system would've caught that" is the feeling when I use php/js/python
16:07:22 <Twisol> ^niternia - that's what I've been thinking way too often lately in JS
16:07:32 <Twisol> total functions in Haskell turn into partial functions in Javascript. :(
16:07:37 <thirsteh> niteria: yeah. H-M type inferencing is what does it: all the benefits of strong types, but not all the needless verbosity and repetition
16:07:40 <pascha> Is SSL only used with https or can you use SSL wuthout https?
16:07:56 <geekosaur> heck, Jane Street contacted me out of the blue with a Haskell job. (I was very specifically not looking for dev jobs.)
16:07:59 <thirsteh> pascha: SSL and TLS are used with a lot of things
16:08:06 <thirsteh> e.g. IMAP
16:08:11 <romm> c_wraith, i think that's the difference between me and many of you guys. i really care little about syntax.
16:08:16 <thirsteh> or SMTP/Submission
16:08:29 <geekosaur> romm, tcl is for you, then
16:08:36 <pascha> geekosaur: then what are you looking for?
16:08:38 <romm> c_wraith, i mean *part* of the difference, of course.
16:08:40 <quchen> romm: We care about little syntax here :P
16:08:50 <thirsteh> romm: it's not really about syntax--it's about focusing on what you want, not specific steps to get there, and getting a program that works 95% of the time
16:09:02 <geekosaur> pascha, I'm a sysadmin, haven't done serious dev since the 1990s
16:09:18 <adnap> What does "total functions in Haskell turn into partial functions in Javascript" mean?
16:09:51 <Twisol> adnap: you can pass a string to a function that expects an int, and Javascript won't care
16:09:55 <Twisol> until it tries to actually run it, of course
16:10:03 <adnap> That's just dynamic typing
16:10:06 <adnap> Or having no type system
16:10:10 <applicative> well, if there's only five types around it'd be pretty simple
16:10:11 <geekosaur> exactly
16:10:13 <romm> thirsteh, i think i need to read some more before i understand why this is more true for haskell than it is for my combo of python/c++/matlab etc.
16:10:15 <quchen> adnap: In what context? I can tell you what a total function is, but I don't get the Javasript part.
16:10:22 <adnap> quchen: Me either. Twisol said it
16:10:22 <donri> total functions in agda turn into partial functions in haskell :(
16:10:38 <adnap> What is a total function? I have only heard of a total order
16:10:56 <applicative> adnap, it has a value for every argument,
16:10:57 <Twisol> A function with a defined output for all possible input
16:10:59 <geekosaur> you can translate haskell to javascript, or agda to haskell, but you lose type safety in the process because the target is incapable of the type checking in the source
16:11:02 <applicative> adnap: a function, properly so called
16:11:07 <geekosaur> thus the resulting functions are partial
16:11:07 <adnap> https://en.wikipedia.org/wiki/Partial_function#Total_function says it's a function
16:11:12 <donri> applicative: [that isn't bottom]
16:11:16 <thirsteh> romm: learnyouahaskell.com is great
16:11:20 <applicative> > head ""
16:11:21 <lambdabot>   *Exception: Prelude.head: empty list
16:11:22 <adnap> applicative: Oh, okay
16:11:35 <adnap> applicative: every argument in the set of its domain
16:11:45 <Twisol> `head` is partial, as applicative just showed. ;)
16:11:49 <applicative> they missed a case when they defined head
16:12:05 <romm> thirsteh, i know. i'm in ch. 9
16:12:10 <applicative> how could they have failed to notice?
16:12:12 <adnap> But "partial function" wouldn't be the opposite of "total function" I don't think
16:12:16 <quchen> romm: Haskell is quite special, so it definitely takes some time to get and appreciate it. On the other hand that's not surprising, because all imperative languages are pretty much the same. Going from C to Python basically means you have to re-learn loop syntax.
16:12:25 <niteria> they didn't, they just didn't have the type of nonempty list
16:12:29 <quchen> (Exaggerated of course, but the point's valid I think)
16:12:34 <thirsteh> romm: two of the really big things are sum types and isolated effects. It's much easier to know what's going on in Haskell, and being sure that you're handling every/most possible scenarios
16:12:41 <Twisol> adnap: My statement merely says that the possible domain expands when you move a function from Haskell to Javascript.
16:13:04 <Twisol> adnap: and you have to manually restrict it yourself (i.e. via instanceof and throwing a TypeError)
16:13:06 <adnap> Twisol: Sort of, but does it count if the function wont work on all the elements in the domain?
16:13:09 <thirsteh> romm: that is similar to what the others are talking about, "partial functions are bad"
16:13:12 <parcs> :k Num
16:13:14 <lambdabot> * -> Constraint
16:13:36 <cmccann> :k 1
16:13:37 <lambdabot> parse error on input `1'
16:13:38 <cmccann> aww
16:13:49 <parcs> :k Int -> Int#
16:13:51 <lambdabot>     Not in scope: type constructor or class `Int#'
16:13:51 <lambdabot>     Perhaps you meant one of these:
16:13:51 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
16:13:54 <Twisol> adnap: Well, I didn't intend for the relationship to be delved into so much. I just really dislike having to deal with types manually, instead of letting Haskell deal with things. :)
16:14:10 <applicative> romm: by the way, with -Wall the compiler will find a lot of them, the missing cases
16:14:37 <adnap> I think you have to "deal with types" in Haskell
16:14:47 <adnap> You have to understand what the types of functions are
16:14:56 <Twisol> adnap: But the compiler does a lot more for you.
16:15:11 <adnap> I agree
16:15:16 <Twisol> admap: You still have to understand what the types of functions are in Javascript.
16:15:20 <Twisol> but the language gives you no support
16:15:30 <adnap> You basically have to be a type checker in a dynamically-typed language
16:15:36 <Twisol> That's exactly what I mean, yes.
16:15:37 <parcs> :k Num Int => Num Int
16:15:37 <applicative> the compiler performs a miracle for you
16:15:38 <lambdabot> *
16:15:41 <parcs> lol
16:16:00 <quchen> They told me I could become anything
16:16:05 <quchen> So I became a type checker
16:16:19 <parcs> :k Num Int => Num
16:16:21 <lambdabot> *
16:16:39 <romm> thirsteh, that's what i'm trying to get to. IO / Monads... basically the pureness that is unique to haskell. maybe then i'll see the advantages.
16:16:54 <shachaf> :k (Num Int => Num) Int
16:16:56 <quchen> romm: Parallelization is almost ... boring
16:16:56 <lambdabot> Top level:
16:16:56 <lambdabot>     Illegal polymorphic or qualified type: Num Int => Num
16:16:56 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
16:17:07 <Eduard_Munteanu> Wow, I hear typechecking school is tough.
16:17:09 <mikeplus64> parcs: huh? what can that be?
16:17:18 <mikeplus64> > undefined :: Num Int => Num
16:17:20 <lambdabot>   Expecting one more argument to `GHC.Num.Num'
16:17:27 <shachaf> A bug.
16:17:30 <Shou> How do I go about using Vector with Text? Like split a Text by lines but not put it into a list but a Vector? Are there no functions for that already?
16:17:31 <romm> quchen, wouldn't erlang be the better choice then? (i'm not very familiar with it)
16:17:38 <thirsteh> romm: I think you will
16:17:49 <cmccann> erlang's approach is different
16:18:10 <mikeplus64> Shou: use one of the folds in Data.Text
16:18:12 <mikeplus64> probably
16:18:13 <cmccann> for some things erlang probably is better than Haskell, though that's more about the tools and runtime and such
16:18:16 <parcs> :k (Num Int => Num) () => ()
16:18:19 <thirsteh> romm: If you need very low latency for many hundreds of thousands of threads, yes, but you have many more choices in haskell, e.g. STM instead of just message passing
16:18:34 <Shou> mikeplus64: Alright, thanks! I'll check it out!
16:18:48 <thirsteh> (note that's low latency for a thread to be scheduled, not necessarily fast execution time. Haskell tends to be much faster)
16:18:51 <romm> thirsteh, STM as in DB writes / commits?
16:19:14 <quchen> romm: Yep. Atomic transactions between threads.
16:19:15 <thirsteh> romm: yes, except in memory. See http://book.realworldhaskell.org/read/software-transactional-memory.html
16:19:20 <parcs> :k (Num Int => Num) () => ()
16:19:25 <parcs> poor lambdabot
16:19:33 <cmccann> romm: shared mutable references with deadlock-free transactional behavior
16:19:51 <shachaf> cmccann: hi cmccann
16:20:01 * cmccann thinks the "no deadlocks" part is more interesting than just atomic transactions alone
16:20:03 <cmccann> hi shachaf
16:20:11 <parcs> :t let f :: (Num Int => Num Int) => Num Int; f = undefined in f
16:20:12 <lambdabot>     Predicate `Num Int' used as a type
16:20:13 <lambdabot>     In the type signature for `f': f :: Num Int => Num Int => Num Int
16:20:13 <lambdabot>     In the expression:
16:20:26 <shachaf> cmccann: How's that book going?
16:20:46 <romm> hmm... these can be implemented in other languages as well, but the fact that they're already in the runtime is appealing.
16:20:53 <cmccann> I've thought about it exactly 2.3 times since you last asked.
16:21:23 <cmccann> romm: it's actually pretty hard to make STM that's fully functional and pleasant to use work in most languages
16:21:28 <thirsteh> romm: they can't, actually. Not the way they are in Haskell. That's because in Haskell an STM transaction is encapsulated in the STM monad. You can't do anything effectful like writing to disk while you're in a transaction that might be reversed
16:21:34 <cmccann> because of unrestricted side-effects
16:21:37 <thirsteh> romm: I don't know of another STM implementation that can guarantee that
16:21:53 <cmccann> clojure's STM does that on the honor system
16:21:53 <Twisol> The control Haskell gives you over side-effects is nothing short of amazing.
16:21:57 <thirsteh> cmccann: exactly
16:22:03 <parcs> should 'Num Int => Num Int' have the kind Constraint? or is it an invalid type?
16:22:05 <sw2wolf> thirsteh: clojure has STM
16:22:16 <cmccann> which only works at all because clojure favors immutability and such
16:22:17 <thirsteh> but it's not controlled. It's up to you not to do anything with effects
16:22:43 <romm> i... need to finish reading LYAH
16:22:44 <cmccann> yeah. from what I gather it's easy to do the right thing with clojure's STM, but it's still up to you
16:22:52 <Twisol> romm: That's the spirit :>
16:23:00 <cmccann> in most languages it'd just be horrible because of pervasive mutability
16:23:04 <thirsteh> romm: ;) welcome to haskell
16:23:34 <cmccann> if memory serves me clojure has had STM pretty much from the start
16:23:56 <cmccann> so more things are built to work with it
16:24:08 <c_wraith> yeah, clojure's focus on immutable data really helps.
16:24:27 <cmccann> retrofitting STM onto an existing impure language is madness and has never worked
16:24:36 <thirsteh> yeah, there was a big debate between Azul Systems' Cliff Click (concurrenct JVM GC guy) and Rich Hickey about why STM sucks/doesn't on the clojure list some years ago
16:24:53 <cmccann> oh that sounds fun
16:25:17 <thirsteh> https://groups.google.com/forum/#!msg/clojure/XHqWLMcsH-c/sXwYNZ6LoQMJ
16:25:18 <c_wraith> having watched Rich Hickey's presentation on simplicity vs complexity, I'm sort of confused.
16:25:32 <c_wraith> At several points during it, he made jokes about category theory.
16:25:55 <Twisol> About or inspired by?
16:25:55 <c_wraith> He seems to have completely neglected the idea that math might actually be a good place to look for simplicity in
16:26:02 <Twisol> ok, the former
16:26:03 <fengshaun_> how can I re-export only some functions of an imported module?
16:26:20 <Clint> by hand
16:26:20 <quchen> fengshaun_: Like you would export any other function
16:26:28 <thirsteh> c_wraith: I think it's more of a crowd-pleaser to make fun of "that geeky foreign math stuff" and to present something that seems simple enough that people will bother to try it
16:26:29 <fengshaun_> is it: MyModule ( OtherModule (someFunc) ) where import OtherModule ?
16:26:40 <thirsteh> c_wraith: that's the way he's come across when I've seen him talk/talked to him, at least
16:27:03 <Cale> fengshaun_: You don't have to mention the other module's name when exporting
16:27:04 <c_wraith> still seemed unnecessarily dismissive of a really useful source of good ideas for simple organization
16:27:05 <thirsteh> not at all like "Haskell or advanced type systems" suck, just "it's too bad not more people are using it"
16:27:20 <fengshaun_> quchen, Cale: thanks!
16:27:34 <quchen> fengshaun_: You can also reexport an entire module
16:27:40 <thirsteh> c_wraith: yeah, agree
16:27:50 <Twisol> c_wraith: Well, I guess there's a reason why the attempt to do monadic things in Javascript was called "Fantasy Land"...
16:29:04 <parcs> :k Int => Show ()
16:29:05 <lambdabot>     Type of kind * used as a constraint
16:29:06 <lambdabot>     In a type in a GHCi command: Int => Show ()
16:29:23 <parcs> hmm, works4me
16:30:42 <parcs> :k (->) (Show ())
16:30:43 <lambdabot>     Predicate `Show ()' used as a type
16:30:43 <lambdabot>     In a type in a GHCi command: (->) (Show ())
16:30:48 <geekosaur> requires a newer ghc and possibly extensions?
16:31:05 <parcs> what ghc version does lambdabot use?
16:34:03 <hpaste> fengshaun pasted “mismatched type” at http://hpaste.org/85665
16:34:20 <fengshaun_> Can someone take a look at this snippet please?  I can't figure out why I get the mismatched type error!  The types seem to work out. ^^
16:35:04 <c_wraith> fengshaun_: what's the type of ==> ?
16:35:13 <c_wraith> oh, nevermind, I'm blind. hah
16:35:15 <fengshaun_> c_wraith, that's a string
16:35:18 <c_wraith> that's inside the string literal
16:35:22 <fengshaun_> yea
16:35:57 <c_wraith> Well, what you've quoted looks right. Which means that the type checker was probably telling you the wrong place
16:36:15 <fengshaun_> ok, let me repaste then
16:36:28 <c_wraith> In the cases where it does that, I tend to put more type annotations on things until finally it's obvious where the problem actually is
16:36:41 <hpaste> fengshaun pasted “mismatched type” at http://hpaste.org/85666
16:36:47 <fengshaun_> ^^ that's the whole main
16:37:58 <c_wraith> fengshaun_: oh.  I see.
16:38:09 <c_wraith> you need a =<< instead of liftM
16:38:13 <c_wraith> on line 20
16:38:17 <fengshaun_> oh
16:38:20 <c_wraith> that actually *was* in the first paste
16:38:22 <c_wraith> I just missed it
16:38:48 <fengshaun_> oh, liftM make a a function work *on* Monads
16:38:53 <fengshaun_> forgot that
16:38:59 <fengshaun_> thanks a lot
16:39:18 <quchen> fengshaun_: liftM = fmap
16:39:27 <quchen> Think of it more in terms of functors than monads.
16:40:04 <fengshaun_> yes, got it!  I don't know why I thought it was appropriate there
16:40:07 <fengshaun_> thanks!
16:42:44 <parcs> :k (forall a. a) Int
16:42:46 <lambdabot> Top level:
16:42:46 <lambdabot>     Illegal polymorphic or qualified type: forall (a :: * -> *). a
16:42:46 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
16:43:02 <pascha> > 1+3
16:43:04 <lambdabot>   4
16:43:21 <pascha> :t (>>)
16:43:22 <lambdabot> Monad m => m a -> m b -> m b
16:43:25 <pascha> :t (>>=)
16:43:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:43:44 <pascha> > Just 4 >> Just 6
16:43:46 <lambdabot>   Just 6
16:43:53 <pascha> whats the point?
16:44:03 <pascha> > print 5 >> print 6
16:44:05 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:44:05 <lambdabot>    arising from a use of ...
16:44:13 <aavogt> > Nothing >> Just 1
16:44:15 <lambdabot>   Nothing
16:45:00 <ab9rf> pascha: why do things have ot have points?
16:45:20 <ab9rf> > Just 10 >> Nothing
16:45:22 <lambdabot>   Nothing
16:46:04 <startling> what's the best way to escape the contents of a Text?
16:46:11 <startling> I'm printing to a string literal.
16:46:14 <ab9rf> escape from what?
16:47:55 <startling> escape quotes and invisible characters, I guess.
16:48:07 <quchen> concatMap?
16:48:20 <startling> fair enough.
16:49:16 <thirsteh> is there a signal I can send to get a profiled program to dump the .prof (for profiling a daemon process)?
16:49:39 <quchen> -ddump-simpl
16:49:43 <quchen> I think
16:49:58 <quchen> Ah, no, wait.
16:50:01 <quchen> That was rubbish.
16:50:34 <quchen> Compile with RTS options enabled (-rtsopts), then run with +RTS -p [profiler flags]
16:51:02 <thirsteh> yeah, but I don't want to shut down normally
16:51:09 <thirsteh> and if I ctrl+c it doesn't write the prof file
16:51:46 <thirsteh> I was wondering if you could send SIGUSR1 or something, and it'd write it
16:51:46 <quchen> Ah, you want to flush the .prof output so to speak
16:51:49 <thirsteh> yes
16:55:31 <ab9rf> startling: i would think that it would depend on for what purpose you want them escaped
16:55:31 <quchen> thirsteh: Hmm, can't find anything obvious in the manual
16:56:00 <ab9rf> if it's nonspecific just use show
16:56:00 <thirsteh> quchen: oh, it's written now. Excuse me. Don't know why it was empty before
16:56:24 <quchen> thirsteh: Maybe your file listing didn't register the change
16:56:51 <thirsteh> yeah, dunno. thanks anyway :)
17:07:11 <pascha> wha is meant by binary encoding? obv everything is binary in the end...
17:09:01 <geekosaur> context?
17:09:38 <geekosaur> but a binary encoding is usually based on some kind of raw machine word, instead of converting to a text format (which is usually much larger)
17:16:36 <monochrom> it is like squares are rectangles too, but when people say "rectangle", they don't want squares.
17:17:02 <monochrom> similarly, human-readable text is binary too, therefore when people say "binary", they don't want human-readable text.
17:20:28 <Ontolog> there's all this work done to make Data.Set efficient by using binary trees, however there's no implementation of any :(
17:20:55 <shachaf> ?
17:21:42 <shachaf> You can't make "any" more efficient by using binary trees. Without additional information about the Set you just have to check every element.
17:21:49 <Ontolog> so i find my self doing any f (Set.toList s)
17:22:07 <shachaf> Data.Foldable.any will work
17:22:38 <Ontolog> any should be O(log n) but running toList makes it O(n)
17:22:43 <shachaf> It's pretty much equivalent to Data.List.any f . Set.toList, though.
17:22:48 <shachaf> What?
17:22:57 <Ontolog> Set.toList runs in O(n)
17:23:01 <shachaf> What does it mean for it to "be O(log n)"?
17:23:04 <monochrom> I recommend not answering.
17:23:22 <Ontolog> you honestly don't understand what i'm trying to express?
17:23:34 <shachaf> monochrom: Recommending to me?
17:23:36 <Ontolog> the haskell docs even give the time complexity as part of the function definitions
17:23:42 <monochrom> yes
17:24:11 <Ontolog> ...
17:24:55 <sw2wolf> I forget what does "O" mean in O(log n) ?
17:25:12 <sw2wolf> which English word ?
17:25:25 <geekosaur> more a phrase: "on the order of"
17:25:30 <shachaf> No English word.
17:25:40 <geekosaur> ...sort of
17:25:56 <[swift]> i do usually remember it as "order" but that breaks down for omegas and such =)
17:25:59 <centrinia> asymptotically
17:26:02 <shachaf> What Greek work does Θ mean?
17:26:11 <monochrom> big angle :)
17:26:13 <dmwit> Ontolog: How are you supposed to tell whether all the members of a set have some property without inspecting all the members of the set?
17:26:30 <dolio> Θrder
17:26:47 <dmwit> Ontolog: If you're going to inspect all the members of a set, how can you avoid having a runtime proportional to at least the number of members of the set?
17:26:49 <dolio> Ωrder
17:26:53 <sw2wolf> it is used to express Time Complexity but why "O" ?
17:27:24 <Ontolog> dmwit: *any*
17:27:28 <Ontolog> did I say all?
17:27:31 <monochrom> "why O why?" :)
17:27:38 <sw2wolf> :)
17:27:40 <dmwit> Ontolog: any is all . not
17:27:49 <shachaf> Ontolog: You have a Set with 1024 elements. You have some arbitrary predicate. You can check whether the predicate applies to any element of the Set using some constant * 10 operations?
17:27:52 <Ontolog> what?
17:27:55 <byorgey> sw2wolf: according to Wikipedia, it was first introduced by Paul Bachmann in 1894, in is book "Analytische Zahlentheorie"
17:28:05 <shachaf> OK, that's suboptimal phrasing. I'm just trying to figure out what you imagine happening.
17:28:05 <dmwit> Ontolog: any p = not (all (not . p)); likewise all p = not (any (not . p))
17:28:07 <byorgey> so perhaps it stands for a German word
17:28:14 <dmwit> Ontolog: So whether you're discussing any or all makes no difference.
17:28:18 <shachaf> dmwit: What a classicalist.
17:28:18 <Ontolog> why is any defined in terms of all?!
17:28:19 <sw2wolf> byorgey: thx
17:28:35 <shachaf> Ontolog: dmwit is talking about how it behaves, not how it's defined.
17:28:37 <dolio> He didn't say it was defined that way.
17:28:44 <byorgey> "Ordnung" perhaps?
17:28:47 <dmwit> Ontolog: Or, I can rephrase my argument thusly: How are you supposed to tell whether all the members of a set do not have some property without inspecting all the members of the set?
17:29:16 <sw2wolf> byorgey: Ordnung is NOT english ?
17:29:21 <dmwit> Ontolog: Think about this: if "any" is going to return "False", how many of the set elements does it have to know about before it can answer?
17:29:22 <Ontolog> that's not what any does, any is suppose to ask does any member of the set have this property
17:29:30 <byorgey> sw2wolf: no
17:29:31 <Ontolog> oh
17:29:32 <geekosaur> Ontolog, unless the predicate is related specifically to the underlying data structure of the set --- which you cannot know, in general --- how are you to do better than possibly having to inspect every element?
17:29:41 <dolio> dmwit: Absence of evidence is evidence of absence.
17:29:44 <Ontolog> yes
17:29:51 <dolio> dmwit: Checking log n is pretty compelling. :)
17:29:53 <Ontolog> no you are right :p it's worse case is indeed O(N)
17:29:55 <Ontolog> but
17:30:04 <Ontolog> Set.toList is best case O(N)
17:30:14 <dmwit> dolio: heh
17:30:16 <geekosaur> sw2wolf, so its forbidden for English mathematicians to pick up a construction from German?
17:30:19 <Ontolog> sorry
17:30:28 <dolio> Big-O is worst-case.
17:30:33 <ab9rf> geekosaur: damn, what are we going to do with eigenvectors?
17:30:37 <sw2wolf> geekosaur: maybe
17:30:38 <shachaf> Ontolog: Set.toList will generate its list lazily, if that's what you're worrying about.
17:30:45 <dmwit> Ontolog: Set.toList's runtime depends on how many of the list's elements you look at.
17:30:56 <byorgey> "ownvectors" doesn't have the same ring to it
17:30:59 <parcs> any :: Ord a => (a -> Ordering) -> Set a -> Set a
17:31:37 <shachaf> Oh well.
17:31:37 <dolio> Set is probably particularly bad, because best-case is probably log n time.
17:31:43 <dolio> Instead of constant time.
17:34:42 <dmwit> dolio: Wait, why?
17:34:45 <niteria> are there problems that have worse complexity in a purely functional setting (with laziness) than in a imperative setting?
17:34:48 <dolio> That should have been the real complaint.
17:34:51 <dmwit> Can't we visit internal nodes before we get to leaves?
17:35:01 <dmwit> niteria: This question is open.
17:35:12 <dolio> dmwit: Because Set is obligated to produce a sorted list. The complaint was that there's no Set.any.
17:35:31 <dmwit> niteria: There are problems where the best known solution is different by a factor of log n, and you can show that all things can be done with no worse than a factor of log n.
17:35:50 <dmwit> dolio: toList isn't obligated that way; toAscList is
17:35:58 <niteria> what about checking for duplicates in a list of Ints?
17:36:09 <niteria> is there a known O(n) solution?
17:36:20 <niteria> accumArray doesn't count
17:37:49 <dolio> dmwit: toList will give you results that don't respect the equivalence?
17:37:50 <dmwit> dolio: Of course, toList = toAscList doesn't look like a promising definition for my argument. But theoretically toList could do something else...
17:37:58 <dolio> Oh, okay.
17:38:20 <dolio> If toList were actually preorder, then yeah.
17:40:18 <parcs> niteria: what's the O(n) imperative solution?
17:40:36 <dmwit> accumArray
17:41:08 <niteria> array or hashmap depending on the range of elements
17:42:28 <parcs> Data.Sequence is a purely functional data structure with array-like complexity
17:42:32 <shachaf> @farber has over 1800 entries.
17:42:33 <lambdabot> They've dumped you in the briar patch and told you to sink or swim.
17:42:40 <shachaf> Ridiculous.
17:43:20 <parcs> is the imperative solution to create an array with size maximum(list_of_ints) ?
17:43:43 <niteria> yes
17:43:45 <geekosaur> @harper
17:43:46 <lambdabot> Things are getting a little sloppy around the gills.
17:43:57 <dolio> Nice.
17:44:13 <shachaf> There is a list of harrop quotes but no plugin that uses them.
17:44:22 <dmwit> Harper's gonna... farb?
17:44:25 <parcs> niteria: you can do that with Data.Sequence, in O(n) time i think
17:44:26 <dolio> Yeah. All my work for nothing.
17:44:36 <shachaf> You added that list?
17:44:43 <dolio> I built a lot of it.
17:44:56 <niteria> parcs: that would be awesome
17:45:03 <dolio> Skimming comp.lang.functional.
17:45:25 <parcs> niteria: the constant factors on Data.Sequence are bad though
17:45:28 <dolio> It took a great amount of effort to actually read his posts when I came across them.
17:45:39 <niteria> it's a theoretical question
17:46:44 <niteria> I could just use hatm and be done with it
17:47:11 <dolio> I don't think Data.Sequence supports array-like performance on the correct operations for that.
17:47:19 <dolio> Unless I'm guessing the algorithm incorrectly.
17:47:49 <niteria> naive algorithm would be O(n log n), I don't know what parcs has in mind
17:48:06 <dolio> I mean the translation of the imperative algorithm.
17:48:17 <dolio> I think it would still be O(n log n).
17:48:19 <niteria> that's what I mean by naive
17:48:34 <dolio> Oh.
17:49:30 <dmwit> It's easy to show "I can't think of a way to do it fast", but it's hard to show "there is no way to do it fast".
17:49:42 <dolio> Yeah.
17:50:20 <shachaf> Can you publish papers about "I can't think of a way to do it fast"?
17:50:36 <shachaf> I foresee a long and fruitful academic career for my pet rock.
17:50:44 <dolio> You probably can.
17:50:49 <niteria> I've heard find-union can be done functionally with reasonable complexity and find-union looks very imperative
17:51:26 <dmwit> (I think it's normally called "union-find".)
17:55:46 <niteria> oh, you're right
17:56:09 <c_wraith> I dunno. I think all the implementations on hackage are either using ST or suboptimal
17:56:37 <parcs> Data.Sequence.adjust is O(log(min(i,n-i))), where i is index and n is length
17:57:09 <shachaf> Olog Minini
17:58:08 <c_wraith> parcs: that's totally be to expected from a finger tree. Have to replace outer layers inward until you find the element being looked for
17:58:10 <niteria> oh, union-find I had in mind is persistent, not functional
18:01:41 <parcs> what is the complexity of performing 'adjust' n times on arbitrary indices?
18:02:17 <niteria> there should be a sequence of indices that gives O(n log n)
18:02:56 <dolio> It's like: log 1 + log 2 + log 3 + ... + log (n/2) + ... + log 1 ~ log (n!) ~ n log n.
18:03:14 <dolio> Worst case.
18:04:03 <shachaf> dolio: Is there a particular reason to prefer one of Yoneda/CoYoneda to the other one for various specific cases?
18:04:21 <shachaf> (Other than "CoYoneda is more intuitive".)
18:04:30 <parcs> cool
18:04:41 <dolio> You shouldn't use CoYoneda in OCaml because it might stack overflow.
18:05:08 <sw2wolf> @ty adjust
18:05:10 <lambdabot>     Not in scope: `adjust'
18:05:10 <lambdabot>     Perhaps you meant one of these:
18:05:10 <lambdabot>       `IM.adjust' (imported from Data.IntMap),
18:05:12 <parcs> but that means that n! ~ n^n
18:05:17 <sw2wolf> @hoogle adjust
18:05:18 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
18:05:18 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
18:05:18 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
18:05:22 <shachaf> But Yoneda won't?
18:05:38 <dolio> parcs: Yep. That's typically used in results on sorting.
18:06:08 <dolio> shachaf: Right.
18:06:22 <dolio> At least not for the same reasons.
18:08:20 <dolio> parcs: You show that there are O(n!) permutations of the input, and choosing the right one takes O(log n!) decisions, which is the same as O(n log n).
18:08:36 <dolio> For a lower bound on comparison sorting.
18:11:34 <dolio> shachaf: Nope, yoneda's composition nesting doesn't stack overflow.
18:12:42 <augur> hm. laziness is really useful for parsing with a stack backtracking parser :T
18:13:52 <augur> readWord (w:ws) = do l <- lexicalEntries w ; parseWithLex l ws
18:14:25 <ag90> Is there a way for me to have a list that can contain a list of lenses for a state that return different types? So, [forall a. Lens' s a] (where s is in the scope)?
18:15:09 <shachaf> I'm not sure (Forall a. Lens' s a) means what you think it does.
18:15:19 <shachaf> s/F/f/
18:15:23 <ag90> I'm trying to write a generic compare :: [forall a. Ord a => Lens' s a] -> s -> s -> Ordering
18:16:02 <ag90> So, the Ord instance for the type can say, compare = campareOn [attr1, attr2, attr3] (where attr* are attribute lenses)
18:16:06 <shachaf> There are some other issues, which might be solved by using ALens etc., but I'm not sure what you hope for that to mean.
18:16:25 <shachaf> Lens' s a = (s -> a, s -> a -> s)
18:16:30 <dolio> shachaf: There might be performance implications even in Haskell.
18:16:58 <ag90> shachaf: I was going to use a Getter, but I assume the limitation is similar in trying to get a list like that
18:17:02 <dolio> When you repeatedly map Yoneda, you get f . (g . (h . ...)).
18:17:04 <shachaf> So (forall a. Lens' s a) means (forall a. s -> a), among other things.
18:17:14 <shachaf> dolio: Yes, you can get a stack overflow in Haskell with CoYoneda.
18:17:21 <dolio> With CoYoneda you get ((... . f) . g) . h
18:17:52 <shachaf> I ran into it at one point and assumed Yoneda would have the same issue... I should try whatever it is I was trying again.
18:18:18 <dolio> If you got one in Haskell, it didn't come from the function composition.
18:18:39 <dolio> It probably came from CoYoneda being data that you can't lazily match on.
18:19:20 <dolio> Wait, I have that backwards.
18:19:35 <dolio> Yoneda is ((... . f) . g) . h, which is good. CoYoneda is the opposite.
18:19:47 <ag90> shachaf: Yeah, that's around what I'm going for. Basically, with compareOn [attr1, attr2], where attr1 :: Lens' s Int and attr2 :: Lens' s String, it will say, "Given two objects of s, first compare attr1 for both and if that's equal, compare attr2."
18:21:34 <shachaf> ag90: OK. That's not what (forall a. Lens' s a) means. But I think lenses are making things more complicated than they need to be, so you should figure this deal out with plain functions or something first.
18:22:43 <parcs> dolio: i see. thanks
18:23:38 <ag90> shachaf: Okay. I assumed that quantification would mean "all lenses on the type s"
18:25:17 <shachaf> ag90: I suspect that this is one of those problems where when you figure out what you're really trying to do, you also figure out that you don't actually need it.
18:25:21 <shachaf> But I don't know. :-)
18:25:34 <crdueck> is it possible to map a monadic action over a Repa Array with access to its Shape index? I need something like mapMIndexed_ :: (Monad m, Shape sh, Source r e) => (sh -> e -> m b) -> Array r sh e -> m ()
18:25:58 <ag90> shachaf: Well, yeah. I don't need it. It's more for experimentation purposes.
18:27:28 <shachaf> ag90: OK. Then start by simplifying with functions instead of lenses.
18:28:56 <ag90> Okay. In that case, it would have to be a list (s -> a) where a is not the same for all elements in the list.
18:29:09 <ag90> So, it could be [f, g] where f :: s -> Int and g :: s -> Char
18:29:28 <ag90> I probably should've started the question with that.
18:29:39 <shachaf> OK. So let's say I give you such a list.
18:29:49 <shachaf> You have a value of type s. What can you do with the list?
18:29:59 <ag90> Two values of type s.
18:30:08 <shachaf> OK, you have an unlimited supply of values of type s.
18:30:13 <shachaf> What can you do with the list?
18:30:13 <ag90> lol
18:30:20 <Twisol> 0, 1, or many
18:30:21 <Twisol> :)
18:30:39 <dmwit> shachaf: But s is an instance of Finite!
18:30:49 <ag90> Well, the idea is that you compare (f s1) and (f s2), and if they're not equal, return that. If equal, compare (g s1) and (g s2)
18:30:49 <shachaf> dmwit: Finite is a lie.
18:30:51 * dmwit chuckles into his sleeve
18:30:54 * shachaf is an ultrainfinitist.
18:31:11 <ag90> And so on. If the list is exhausted, they're definitely equal. Return EQ.
18:31:45 <dmwit> Okay, so the only thing you want on the results is equality?
18:32:01 <dmwit> Why not store s -> Bool then?
18:32:07 <shachaf> How about this alternative: [s -> s -> Ordering]
18:32:21 <Twisol> He said before, compare (f s1) and (f s2), and if it's LT or GT return that
18:32:22 <dmwit> ITYM [s -> Ordering]
18:32:24 <Twisol> so not only EQ
18:32:42 <shachaf> dmwit: Do I?
18:32:50 <dmwit> Don't you?
18:32:55 <ag90> (s -> s -> Ordering) seems like it might be a good approach -- definitely better than what I'm going for
18:32:57 <shachaf> Maybe I misunderstood the problem.
18:33:01 <dmwit> You don't.
18:33:07 <dmwit> I'm wrong. As usual.
18:33:52 <ag90> Though it would mean that the caller would have to provide [compare `on` attr1, compare `on' attr2], instead of [attr1, attr2].
18:33:57 <shachaf> Yes.
18:34:13 <ag90> That's an acceptable trade-off, I suppose.
18:34:22 <shachaf> Otherwise, the caller would have to provide a wrapper: [Foo attr1, Foo attr2]
18:34:38 <ag90> Oh, I see.
18:34:50 <ag90> So, there's no easy way of having [attr1, attr2]?
18:34:57 <shachaf> Not when they have different types.
18:35:13 <shachaf> There are always ways of unifying them into a common type.
18:35:27 <ag90> But not implicitly. I see.
18:35:40 <shachaf> There's a direct way with existential types. But that needs a wrapper in GHC.
18:35:48 <shachaf> Also I'm not actually sure how you would use existential types to do this.
18:36:10 <shachaf> foo :: exists a. Ord a *> Bool -> a
18:36:23 <shachaf> It seems like I ought to be able to say (compare (foo False) (foo True))
18:36:31 <shachaf> Do existentials have a way of doing that?
18:36:51 <dmwit> data Attr s = forall a. Ord a => Attr (s -> a)
18:37:01 <dmwit> ?
18:37:28 <shachaf> dmwit: Does that actually work? GHC is aware that the two "a" are the same because they come from the same existential wrapper?
18:37:40 <dmwit> No, you only unwrap it once.
18:37:52 <shachaf> Oh, I suppose so.
18:37:57 <dmwit> cmp (Attr f) s1 s2 = compare (f s1) (f s2)
18:38:22 <shachaf> Fair enough, that was a bit silly. :-)
18:38:50 <shachaf> ag90: By the way, you should know about: comparing (which is just an alias for compare `on`) and the Monoid instances for Ordering and (r ->)
18:38:56 <shachaf> Er, (r -> m)
18:39:29 <ag90> Oo. Thanks. I'll look into that.
18:39:37 <ag90> Thanks for your help on the other weird stuff too.
18:39:43 <shachaf> > sortBy (compare <> comparing length) $ words "this is the usual example in this channel, I think. You can use more than two functions, of course."
18:39:45 <lambdabot>   ["I","You","can","channel,","course.","example","functions,","in","is","mor...
18:40:02 <shachaf> > sortBy (comparing length <> compare) $ words "this is the usual example in this channel, I think. You can use more than two functions, of course."
18:40:04 <lambdabot>   ["I","in","is","of","You","can","the","two","use","more","than","this","thi...
18:40:14 <shachaf> I got it a bit backwards there.
18:40:22 <Twisol> That's really nifty.
18:41:09 <Twisol> Opposite direction from function composition?
18:41:25 <shachaf> I wouldn't call it opposite.
18:42:27 <dmwit> Twisol: The result of calling the left function goes to the left of the (<>).
18:42:27 <Twisol> Unless I'm misunderstanding, it seems to use the sorting predicates from left to right, while function composition is right-to-left. No?
18:42:40 <dmwit> Twisol: It depends on the Monoid instance for Ordering. =)
18:42:49 <shachaf> Function composition is left-to-right.
18:43:22 <Twisol> Now I'm confused.
18:44:03 <Kaidelong> is there any reason in haskell to have null instances just for the purposes of enforcing type constraints?
18:44:29 <Kaidelong> like class (Group g) => AbelianGroup g
18:44:32 <Kaidelong> with no methods
18:44:45 <wavewave> Kaidelong: what's wrong with it?
18:44:49 <Kaidelong> but allows you to put on an abelian group constraint that the programmer guarantees and get a type error if they don't
18:45:12 <Cale> Kaidelong: Didn't you just answer your own question? :)
18:45:15 <dmwit> Kaidelong: I feel like you just answered your own question.
18:45:17 <wavewave> Kaidelong : I often use it.
18:45:23 <ab9rf> shachaf: i donm't understand why the first one sorted the list the way it did
18:45:30 <Kaidelong> Okay, I was wondering if it was idiomatic or if it would be dumb
18:45:45 <Kaidelong> if other people do it then I suppose I can too
18:45:45 <dmwit> Kaidelong: gtk2hs uses it
18:45:53 <ab9rf> shachaf: nevermind, i figured it out
18:46:36 <johnw> shachaf: how is composition left-to-right?
18:46:52 <shachaf> How is it right-to-left?
18:46:59 <johnw> i asked first
18:47:04 <Twisol> The composed functions get called in a right-to-left order
18:47:08 <ab9rf> maybe it's top-to-bottom
18:47:32 <Clint> positron flow
18:47:50 <shachaf> johnw: It's left-to-right because to evaluate ((f . g) x) you evaluate f before you evaluate g.
18:48:19 <Twisol> shachaf: In terms of dataflow, the x apparently passes through g before passing through f.
18:48:37 <ag90> shachaf: The comparing and (a -> b) monoid combination is so much better. Thanks!
18:48:51 <johnw> ah yes, (f . g) x = f (g x), I see what you mean.  f can make the choice to evaluate g x or not
18:49:00 <shachaf> > (const 5 . id) undefined -- who's passing what where now?!
18:49:02 <lambdabot>   5
18:49:10 <Twisol> :|
18:49:29 <shachaf> The point is that I have no idea what left-to-right or right-to-left really mean.
18:49:39 <shachaf> So I picked the undefended one.
18:49:44 <Twisol> Point taken.
18:49:46 <ab9rf> you just like underdogs
19:05:52 <tidux> I'm trying to bootstrap a decent haskell environment in Haiku
19:05:59 <tidux> can you build GHC with native Hugs?
19:06:15 <shachaf> No, you can generally only build GHC with GHC.
19:06:49 <tidux> well fuck
19:07:02 <tidux> alright, thanks anyway
20:21:50 <arbn> So, the "dph-lifted-vseg" module is hidden... how do I fix that? Just trying out DPH for the first time, and not sure how to do it.
20:23:22 <randomclown> @pl \(x:y:[]) -> (x,y)
20:23:23 <lambdabot> (line 1, column 7):
20:23:23 <lambdabot> unexpected "["
20:23:23 <lambdabot> expecting "()", natural, identifier, "_" or "("
20:23:40 <randomclown> oh yeah that's right no patter matching in lambda bot
20:26:40 <geekosaur> well, not in @pl because it's kinda hard to remove those kinds of points
20:27:53 <ParahSail1n> :t ap ((. head) . (,) . head) tail
20:27:54 <lambdabot> [b] -> (b, b)
20:34:35 <user317> can someone help me with understand some of these appicative types, in http://hackage.haskell.org/packages/archive/aeson/latest/doc/html/Data-Aeson.html#t:FromJSON, is there a way to add a "read" into the (v .: "x") expression.  like my json is encoding everything in Strings but i want to store Doubles in my data type
20:35:19 <ParahSail1n> read <$> v .: "x"
20:36:37 <user317> so, (Coord    <$>   read <$> v .: "x" <*>  read <$> v .: "y")?
20:38:14 <ParahSail1n> do {x' <- v.: "x"; y' <- v .: "y"; return $ Coord (read x') (read y')}
20:38:34 <user317> yea, i get that
20:39:00 <ParahSail1n> @undo do {x' <- v.: "x"; y' <- v .: "y"; return $ Coord (read x') (read y')}
20:39:00 <lambdabot> v .: "x" >>= \ x' -> v .: "y" >>= \ y' -> return $ Coord (read x') (read y')
20:39:02 <user317> is there a way to combine that code into that applicative expression without the do notation?
20:39:58 <ParahSail1n> the above would probably do that, provided that you have parens in the right places
20:40:59 <user317> cool, thanks
20:42:07 <u_> is it just me are arrays in haskell a huge pain in the ass
20:42:08 <user317> so (Coord <$> (read <$> v . : "x") <*> (read <$> v . : "y") works
20:43:17 <geekosaur> Array is kinda old and not especially easy to use
20:43:30 <geekosaur> if you can get away with 1D stuff, Vector might be more to your liking
20:43:53 <user317> these types are kind of hard to grok
20:44:20 <xpika> how can i write something like this in haskell
20:44:23 <aavogt> @hackage repa
20:44:24 <lambdabot> http://hackage.haskell.org/package/repa
20:44:30 <xpika> > let f g a b = (g a,g b) in f (\x->(x,x)) 1 's'
20:44:31 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
20:44:32 <lambdabot>    arising from the literal `1...
20:45:26 <geekosaur> xpika, you need to provide a type signature for f to tell it that g is polymorphic, I think
20:46:04 <shachaf> > let f :: (forall x. x -> (x,x)) -> a -> b -> ((a,a),(b,b)); f g a b = (g a,g b) in f (\x->(x,x)) 1 's'
20:46:05 <lambdabot>   ((1,1),('s','s'))
20:46:15 <shachaf> That function is unfortunately almost uselessly specific.
20:47:18 <mushi> hi i have some hw instructions which dont seem clear to me anyone have an idea?
20:47:23 <mushi> http://pastebin.com/Z5gLZHkN
20:47:29 <mauke> The paste Z5gLZHkN has been copied to http://hpaste.org/85670
20:48:08 <mushi> am i right to assume moveparticle = delta_r
20:48:14 <mushi> and that fucntion could work?
20:49:19 <xpika> geekosaur: sweet ^^
20:49:30 <xpika> > let f :: (forall x. x -> x) -> a -> b -> (a,b); f g a b = (g a,g b) in f id 1 's'
20:49:31 <lambdabot>   (1,'s')
20:49:46 <geekosaur> thank shachaf, not me
20:50:05 <xpika> shachaf: thanks
20:50:11 <shachaf> thanks geekosaur, not me
20:50:14 <shachaf> s/s//
20:50:31 * geekosaur *eyeroll*
20:50:45 <shachaf> Fine, don't thank geekosaur.
20:55:29 <Hermit> problem: How can I update a Map using an IO value that shouldn't be pre-computed, without doing first a lookup then update (which traverses the Map twice) and without using unsafePerformIO with Map.alter
20:55:34 <monochrom> ♥ geekosaur, ♥ shachaf
20:56:20 <shachaf> Hermit: You want something like alterM (or, actually, alterA with an Applicative).
20:56:45 <shachaf> As far as I know, it doesn't exists, and edwardk said something about it being better to traverse the Map twice rather than do it in one pass.
20:56:46 <Hermit> shachaf: I didn't see alterM in :browse Data.Map
20:56:49 <shachaf> I don't know the details of that.
20:56:49 * Hermit hoogles
20:56:57 <shachaf> Don't Hoogle. It's not there.
20:57:09 <shachaf> lens has something with the right type, which is implemented by traversing twice.
20:57:21 <Hermit> hmm
20:57:40 <Hermit> I have this huge Map (about 50MiB) so I'd like to do it in one pass if possible
20:57:52 <Hermit> lot's of stuff to update
20:59:11 * Hermit sighs
20:59:13 <shachaf> lens has this function: at :: (Applicative f, Ord k) => k -> (Maybe a -> f (Maybe a)) -> M.Map k a -> f (M.Map k a)
20:59:28 <Hermit> hmm
20:59:54 <shachaf> I would say: Use some function that looks like that one, and write your code. Then later see if you can improve it by traversing the map once.
20:59:57 <Hermit> looks like it could work, but if it does 2 traversals, then I'm better off rolling my own do block using lookup then update
21:00:09 <shachaf> Why are you better off rolling your own?
21:00:15 <shachaf> Abstract it, and then you can improve it later.
21:01:26 <shachaf> The implementation is this: https://github.com/ekmett/lens/blob/master/src/Control/Lens/At.hs#L547
21:01:50 <shachaf> (It also passes the index, if you want to use it.)
21:06:04 <Hermit> my familiarity with lenses is close to none at the moment. It seems I could use it though, but I'm short in time, got to deploy by the end of the month and there's a lot of stuff to do
21:06:24 <Hermit> but I'll give it a shot if I feel I have the time to mess with it
21:06:26 <shachaf> OK.
21:06:34 <shachaf> You don't have to use "at".
21:06:42 <Hermit> thanks for the info and the trouble to find the links
21:06:46 <shachaf> The idea is that "at" has the type that you want.
21:06:54 <shachaf> So make your own function which is like "at".
21:06:55 <Hermit> indeed
21:07:18 <shachaf> Then, if it turns out that you need it, you can dig into containers internals to make it do one pass.
21:07:18 <Hermit> I was going to make an alterM
21:07:28 <shachaf> What's the difference between alterM and at?
21:07:34 <shachaf> (I mean, for this type.)
21:07:38 <Hermit> none actually
21:07:47 <Hermit> I meant I was going to use a signature like it
21:07:49 <shachaf> OK, then make alterM.
21:07:52 <Hermit> just monadic, not applicative
21:07:54 <shachaf> Or alterA. :-)
21:07:59 <shachaf> No, keep it Applicative. :-(
21:08:04 <Hermit> why
21:08:22 <shachaf> Because if you can make something Applicative instead of Monad then it's better for it to be Applicative.
21:09:32 <Hermit> I've been writing most of my code using monads without stopping to consider if applicative would do, but guess you are right, I should keep it to the simplest abstraction that does the job
21:11:17 <shachaf> If you have an Applicative thing it's easy to turn it into a Monad thing (not as easy as it ought to be, but still). Not vice versa.
21:44:33 <Hermit> shachaf: still around?
21:52:51 <shachaf> Hermit: Yep.
21:53:54 <Hermit> *sigh* I'll be honest, I don't have any Applicative practice. I wrote the alterM in the blink of an eye but I'm having troubles with alterA. Mind lending me a hand?
21:54:27 <shachaf> I think the link I gave for "at" should give you a clue, though it has some lens noise.
21:54:58 <Hermit> yeah
21:55:03 <Hermit> :t (<&>)
21:55:05 <lambdabot> Functor f => f a -> (a -> b) -> f b
21:55:09 <shachaf> That's just flip fmap
21:55:17 <shachaf> What's the type you're trying to write?
21:55:31 <shachaf> Let's say: What's your current alterM?
21:57:09 <hpaste> Hermit pasted “alterM  -- shachaf” at http://hpaste.org/85671
21:57:52 <Hermit> didn't try it though. I've been more concerned with the applicative translation
21:58:46 <Hermit> the (still type broken) alterA's signature is the same (just replace Monad with Applicative), the val binding still the same
21:59:00 <Hermit> then a helper function taking a value but I'm screwing up the types
21:59:54 <shachaf> Well, going by the link I pasted before, it might be something like at k f m = f mv <&> \r -> case r of Nothing -> maybe m (const (Map.delete k m)) mv; Just v' -> Map.insert k v' m where mv = Map.lookup k m
22:00:42 <shachaf> @ty let foo k f m = f mv <&> (\r -> case r of Nothing -> maybe m (const (Map.delete k m)) mv; Just v' -> Map.insert k v' m) where mv = Map.lookup k in foo
22:00:44 <lambdabot> Couldn't find qualified module.
22:00:55 <shachaf> @ty let foo k f m = f mv <&> (\r -> case r of Nothing -> maybe m (const (M.delete k m)) mv; Just v' -> M.insert k v' m) where mv = M.lookup k in foo
22:00:57 <lambdabot>     Couldn't match expected type `Maybe a0'
22:00:57 <lambdabot>                 with actual type `M.Map k0 a1 -> Maybe a1'
22:00:57 <lambdabot>     In the third argument of `maybe', namely `mv'
22:01:38 <shachaf> @ty let foo k f m = f mv <&> (\r -> case r of Nothing -> maybe m (const (M.delete k m)) mv; Just v' -> M.insert k v' m) where mv = M.lookup k m in foo
22:01:39 <lambdabot> (Functor f, Ord k) => k -> (Maybe a -> f (Maybe a)) -> M.Map k a -> f (M.Map k a)
22:01:54 <shachaf> Hmm, it just needs Functor, not even Applicative, of course.
22:02:37 <ryantanjunming> i need some help with list comprehension, where i have to each element in a list has to apply to itself to the other..
22:05:01 <shachaf> Hermit: The idea is simple: You have (k), (Map k a), and (Maybe a -> f (Map k b))
22:05:29 <ryantanjunming> what does Maybe a -> f do?
22:05:34 <shachaf> Er, sorry.
22:05:40 <shachaf> (Maybe a -> f (Maybe b))
22:05:44 <Hermit> right
22:05:46 <shachaf> You *want* f (Map k b)
22:05:54 <shachaf> You look up the key in the map, so you have (Maybe a). Then you apply the function, so you have f (Maybe b)
22:05:57 <Hermit> once applied I get  f (Maybe b)
22:06:08 <shachaf> Now you fmap a function :: (Maybe b -> Map k b) which does insert or delete as appropriate.
22:06:09 <Hermit> right
22:06:44 <ryantanjunming> hmm, sounds confusing
22:06:46 <Hermit> yeah, it's clear so far, but I keep getting some  a ~ b can't deduce shit
22:06:57 <Hermit> I'll figure it out
22:07:14 <shachaf> Well, I wrote a function that works.
22:07:29 <shachaf> Hermit: Being Functor gives you all sorts of extra guarantees here.
22:07:33 <ryantanjunming> could i see it
22:07:44 <dmwit> ?where rot13
22:07:45 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
22:07:47 <shachaf> ryantanjunming: We're not talking about your list problem. This is unrelated.
22:07:52 <ryantanjunming> ahhs
22:08:05 <shachaf> Hermit: From this one function you can make a bunch of other functions.
22:08:39 <shachaf> Hermit: Oh, wait.
22:08:45 <shachaf> Hermit: I lied.
22:08:50 <shachaf> There's no "a" and "b". There's just "a".
22:09:04 <shachaf> You can't change the type, because the rest of the values will still be "a"s.
22:09:38 <Hermit> aww god! the problem was this: alterA :: (Ord k, Functor f) => (Maybe a -> f (Maybe a)) -> k -> Map k b -> f (Map k b)
22:09:43 <shachaf> Yep.
22:09:45 <Hermit> geez
22:09:47 <shachaf> No "b"s.
22:09:50 <Hermit> right
22:10:23 <shachaf> This alterA function is very powerful, because it lets you extract a large part of the Map API.
22:10:34 <shachaf> You can use it to make alter, lookup, insert, delete, ...
22:10:37 <shachaf> By using the right functors.
22:10:43 <shachaf> I guess it's actually alterF. :-)
22:11:05 <shachaf> The regular alter won't let e.g. do lookup. But alterF does.
22:11:29 <shachaf> This is the basic idea of lens -- you have a bunch of alterF-style functions, and a bunch of utilities that work with them.
22:11:29 <Hermit> yeah
22:11:29 <arkeet> :t at
22:11:31 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
22:11:43 <shachaf> arkeet: Yes, alterF is made of at.
22:12:17 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in view (at 'a') sample
22:12:19 <lambdabot>   Just 1
22:12:24 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in set (at 'a') (Just 100)
22:12:26 <arkeet> :t at :: (Ord k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> M.Map k a -> f (M.Map k a)
22:12:27 <lambdabot>   No instance for (GHC.Num.Num (Control.Lens.At.IxValue t0))
22:12:27 <lambdabot>    arising from ...
22:12:28 <lambdabot> (Functor f, Ord k) => k -> (Maybe a -> f (Maybe a)) -> M.Map k a -> f (M.Map k a)
22:12:48 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in set (at 'a') (Just 100) sample
22:12:50 <lambdabot>   fromList [('a',100),('b',2),('c',3)]
22:12:55 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in set (at 'a') Nothing sample
22:12:57 <lambdabot>   fromList [('b',2),('c',3)]
22:13:24 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in over (at 'a' . _Just) (*10) sample
22:13:26 <lambdabot>   fromList [('a',10),('b',2),('c',3)]
22:13:28 <shachaf> etc.
22:13:41 <Hermit> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in set (at 'a') id sample
22:13:42 <lambdabot>   Couldn't match type `Data.Maybe.Maybe' with `(->) a0'
22:13:56 <shachaf> No, set sets it to a new value, rather than mapping a function.
22:13:59 <shachaf> over maps a function.
22:14:56 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in over (at 'a') (\x -> case x of Just y -> Nothing; Nothing -> Just 100) sample
22:14:59 <lambdabot>   fromList [('b',2),('c',3)]
22:14:59 <shachaf> > let sample = M.fromList [('a', 1), ('b', 2), ('c', 3)] in over (at 'q') (\x -> case x of Just y -> Nothing; Nothing -> Just 100) sample
22:15:02 <lambdabot>   fromList [('a',1),('b',2),('c',3),('q',100)]
22:17:03 <Hermit> thanks shachaf for pointing all this out, I'll keep it in mind and try to use it from now on
22:17:32 <arkeet> lens is great
22:17:37 <shachaf> i love lens
22:17:39 <shachaf> it is so easy
22:18:06 <Hermit> I hope I can say that too soon
22:18:21 <shachaf> arkeet: Do we have any big lens projects left?
22:18:25 <shachaf> Rewriting the TH, I guess.
22:18:29 <arkeet> figuring out Action
22:18:37 <edwardk> mostly whatever is in the issues list
22:18:48 <edwardk> action isn't going anywhere
22:19:02 <edwardk> in that it doesn't have a better end-game from a theory perspective i think
22:19:24 <shachaf> I bet there's something.
22:19:25 <arkeet> we need a better theory then
22:19:30 <shachaf> But I tried it and couldn't figure it out.
22:19:34 <shachaf> It's up to arkeet now.
22:19:37 <edwardk> the extra effective instances that glguy wants might be nice
22:19:38 <shachaf> Only you can save mankind.
22:19:43 <arkeet> we have to do something to keep lens a moving target.
22:20:01 <shachaf> Hey, let's get Applicative m => Monad m into GHC.
22:20:04 <shachaf> How hard can it be?
22:20:07 <edwardk> And I need to write that modified form of reflection to make it so we can still support Control.Exception.Lens on GHC HEAD.
22:20:10 <shachaf> They break compatibility every release anyway.
22:22:07 <shachaf> Oh, and we have to petition for coerce in contravariant.
22:28:27 <mushi> hello i got hw instruction
22:28:30 <mushi> which are confusing me
22:28:33 <mushi> anyone help?
22:28:51 <mushi> http://pastebin.com/LsQr8T4S
22:28:54 <mauke> The paste LsQr8T4S has been copied to http://hpaste.org/85673
22:29:17 <mushi> can i just do moveparticle = delta_r
22:29:20 <mushi> and that will work?
22:30:35 <edwardk> If you get Applicative m => Monad m into GHC you can have coerce in contravariant ;)
22:38:51 <Hermit> I'd appreciate some hint about edwardk's last statement
22:45:06 <lispy> so many people working on haskell homework these days
22:45:31 <lispy> I don't know if it's more than previous years, but it seems like a good tihng :)
22:47:46 <lispy> mushi: we don't have enough information there to help you
22:51:00 <Mortomes> lispy: My university is quite into haskell too.
22:51:15 <Mortomes> Currently taking a master course on compiler construction, all in haskell.
22:51:33 <Mortomes> Well, haskell and attribute grammars
22:51:34 <mushi> hey lispy
22:51:59 <mushi> i could package it all information
22:52:03 <mushi> in a zip?
22:52:15 <mushi> because there is multiple files etc
22:52:54 <luite> Mortomes: utrecht?
22:53:05 <Mortomes> luite: Yes
22:53:23 <luite> yeah they seem to like the attribute grammars :)
22:55:19 <Mortomes> Has been a pretty fun course, too bad it's coming to an end (Exams next week)
22:58:15 <lispy> Mortomes: oh, attribute grammars are kinda cool. I wish I had the opportunity to study them when I was in school.
22:58:59 <lispy> Mortomes: did you use attribute grammars for data flow analysis or abstract interpretation?
22:59:36 <lispy> Mortomes: have you seen this? http://mattr.net.au/articles/attribute_lambda/
23:00:53 <lispy> mushi: Nah. We don't need that much. Right now we don't know how Particle is defined. How would you update it using that formula?
23:09:28 <BabyGGuy> Hi everyone... "I'm a long time listener, first time caller"
23:11:11 <BabyGGuy> As a noob I'm hoping I can ask someone a question relating to "ViewPatterns" and "Non-exhaustive patterns"... I already expect the answer will include Maybe
23:11:40 <arbn> BabyGGuy: You can ask.
23:12:50 <arbn> BabyGGuy: You do not hope in vain. Come forth and ask whatever troubleth thee.
23:14:41 <m3ga> BabyGGuy: its usually better to just ask, rather than ask if its ok to ask.
23:15:49 <_yezariaely> I have x <- getNextVar  where getNextVar :: State Int String. Now I want to prepend a prefix on x. Is there a shorter form than do x <- getNextVar; let x = "X" ++ x --...
23:15:56 <hpaste> BabyGGuy pasted “Metadata” at http://hpaste.org/85674
23:18:00 <BabyGGuy> I'm trying to parse string... you will notice ofcourse there are non-exhaustive functions. A "ViewPattern" of course will throw the non-exhaustive error even if there are other patterns which are not non-exhaustive
23:18:27 <arbn> BabyGGuy: You need an otherwise case in skipEqual.
23:18:39 <BabyGGuy> the error occurs due to the splitAttributes function
23:19:01 <BabyGGuy> yes arbn... the case would probably involve me using the "Maybe" monad?
23:20:04 <BabyGGuy> if that is the best solution I would also have to change the other functions to accept the Maybe monad
23:20:28 <arbn> BabyGGuy: Not really. You just need a default case.
23:21:14 <BabyGGuy> that default case would be some form of error since the string being parsed would be incorrect
23:21:15 <mushi> i8oh lipsy sorry for reply
23:21:29 <mushi> we are using gloss
23:21:36 <BabyGGuy> which I guess could be []
23:22:22 <mushi> data World = World Float Float Float [Particle]            deriving (Show, Read)
23:22:27 <BabyGGuy> and if that solution was taken I would have to check for [] in every function and continue to "throw" the error up until a function decides to handle it?
23:23:26 <BabyGGuy> I guess my frame of mind is very C++ (my background)... So I'm in the mindframe that there must be a way to "throw" until some function somewhere decides to "catch" it
23:23:49 <BabyGGuy> but maybe my mindframe has to change?
23:24:51 <BabyGGuy> which is why my code wants a non-exhaustive error to "catch" and be passed onto the next pattern to test
23:26:08 <arbn> BabyGGuy: Well, the mindset in Haskell-land is that things should be explicit. You can encapsulate things like failure in a monad, of course, to save typing.
23:26:16 <arbn> BabyGGuy: Also, is there a reason you're not using Parsec?
23:26:45 <BabyGGuy> not using Parsec as this is mainly a learning excersize
23:28:46 <BabyGGuy> Ohh, I think I'm overthinking this. If I return a Monad I don't have to "test" the monad, I can just pass it up the chain until a function decides to test it... Alright I think I just had the "ah ha, I'm an idiot" moment
23:28:47 <BabyGGuy> lol
23:30:33 <arbn> BabyGGuy: Yeah. You only need to take the value out of its monadic context when you *care* about the particulars of that context and are prepared to handle it. :P
23:30:48 <aavogt> BabyGGuy: it's a bit shorter if you write  `f | p1 = True | p2 = True | otherwise = False' instead as `f = p1 || p2'
23:31:08 <BabyGGuy> aavogt: true, thx
23:32:37 * arbn goes back to banging head against a space leak.
23:34:56 <BabyGGuy> arbn: great, i think i'm "confusing" myself because I wanted my module to return a non-monadic type (e.g. "Metadata Attributes [Attribute Label "label" Value "value"]") when infact I should just return a monadic version (e.g. "Maybe Metadata Maybe Attributes [Maybe Attribute Maybe Label "label" Maybe Value "value"])
23:35:34 <BabyGGuy> great... thanks everyone... I now feel dumber and smarter at the same time
23:37:02 <arbn> BabyGGuy: You know you can always take something out of Maybe or any other error type, right? Like "fromMaybe" for example.
23:38:57 <BabyGGuy> arbn: Yes, but my realization is I shouldn't try to do that within the module, only when I need to
23:39:18 <arbn> BabyGGuy: Ah. OK.
23:41:03 <BabyGGuy> arbn: this will be my very first "semi useful" haskell program, so my brain needs to be bashed a little before I come to the answers
23:44:34 <latermuse> hoodle is pretty awesome. haskell's killer app?
23:45:35 <beaky> hello
23:46:16 <shachaf> Hundreds of people have mysteriously gone missing after downloading Hoodle. Haskell's killer app?
23:47:57 <ryantanjunming> @paste
23:47:57 <lambdabot> Haskell pastebin: http://hpaste.org/
23:49:28 <hpaste> natnayr pasted “List Comprehension” at http://hpaste.org/85675
23:51:20 <natnayr> i'm having a problem with this.. in a list of "particles" ive to calculate the force of one and another in the list, change its own values and do the same for the rest of the list
23:52:40 <luite> that sounds familiar
23:53:14 <luite> natnayr: can you copy what you have to hpaste.org and explain where you're stuck?
23:54:01 <natnayr> natnayr pasted “List Comprehension” at http://hpaste.org/85675
23:54:12 <natnayr> luite, 3141?
23:54:50 <shachaf> natnayr: Hmm, is this homework? We just had the same question yesterdayish.
23:55:07 <natnayr> that was me also, im still fighting this..
23:55:15 <luite> ah
23:56:17 <natnayr> im missing a step in this..
23:58:00 <luite> natnayr: perhaps you can break it up in multiple parts. you need to know the total force on every particle. that is the sum of the forces excerted on it by all the other particles
23:59:47 <mushi> lispy:
23:59:51 <mushi> data Particle = Particle Mass Position Velocity               deriving (Show, Read)
23:59:55 <mushi> defination of aprticle
