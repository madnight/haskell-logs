00:10:56 <neighbors> playing around with monads in ghci, and something is confusing me about Either
00:11:41 <neighbors> I can do (return "asdf" :: [String]) and (return "asdf" :: Maybe String) but I can't do (return "asdf" :: Either Int String)
00:11:54 <neighbors> it says Either isn't an instance of Monad
00:12:04 <neighbors> I tried loading Data.Either but that didn't supply the instance
00:12:17 <neighbors> what might I be doing wrong?
00:13:02 <efie> data S nt t = NT nt | T t deriving Eq. I have a list of type [[S nt t]] and would like this list to consist  of lists which only consist of T t values. I tried  filter (\ss -> not (elem (NT _) ss) list but it seems I did oattern matching wrong?
00:13:25 <cmears> neighbors, try importing Control.Monad.Instances
00:14:07 <neighbors> that worked cmears
00:14:17 <neighbors> thanks a ton!
00:14:22 <cmears> You're welcome
00:14:49 <cmears> efie, you can't do pattern matching like that
00:15:08 <cmears> write a function "isNT" using pattern matching, then use that function with filter
00:48:15 <efie> cmears: thanks, it worked
01:15:09 <johnw> aristid: ping
01:26:00 <ParadoxMuffin> how do i append the result of a function to a list ?
01:26:08 <ParadoxMuffin> or results
01:29:40 <Lethalman> ParadoxMuffin, ++
01:49:11 <Cale> ParadoxMuffin: If you care about performance, be careful about repeatedly (e.g. recursively) adding elements to the end of a list with xs ++ [x]
01:49:15 <Cale> @src (++)
01:49:16 <lambdabot> []     ++ ys = ys
01:49:16 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:49:16 <lambdabot> -- OR
01:49:16 <lambdabot> xs ++ ys = foldr (:) ys xs
01:50:03 <Cale> xs ++ ys will take O(length xs) steps to fully evaluate (basically one per element of the list you end up with)
01:50:22 <Cale> So, if you nest them, you can get something which takes quadratic time to fully evaluate.
01:50:43 <__xc> :t scan
01:50:44 <lambdabot>     Not in scope: `scan'
01:50:45 <lambdabot>     Perhaps you meant one of these:
01:50:45 <lambdabot>       `scanl' (imported from Data.List),
01:50:52 <__xc> :t scanl
01:50:53 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
01:51:15 <ParadoxMuffin> is it ok to post a line of code here ?
01:51:20 <__xc> > (++) "" "haskell"
01:51:21 <ParadoxMuffin> since i have a nother question
01:51:22 <lambdabot>   "haskell"
01:51:28 <__xc> > scanl (++) "" "haskell"
01:51:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
01:51:29 <lambdabot>              with actual ty...
01:51:53 <__xc> > scanl (++) ' ' "haskell"
01:51:54 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
01:51:54 <lambdabot>    arising from a use o...
01:51:57 <ParadoxMuffin> addFib = (filter(\x -> x<4000000 && x`mod`2==0)[fiblist!!0..fiblist!!34])++ []
01:52:08 <ParadoxMuffin> this is the list, now how do i get the length of it ?
01:52:46 <__xc> lenght ""
01:52:55 <__xc> > length ""
01:52:56 <lambdabot>   0
01:54:13 <kennyd> > scanr (:) [] "haskell"
01:54:14 <lambdabot>   ["haskell","askell","skell","kell","ell","ll","l",""]
01:55:25 <kennyd> > map reverse $ scanl (flip (:)) [] "haskell"
01:55:26 <lambdabot>   ["","h","ha","has","hask","haske","haskel","haskell"]
01:57:56 <Hail_Spacecake> when I type :{ in ghci it replaces my set prompt with a list of every loaded module
01:57:57 <__xc> :t scanl (++)
01:57:58 <lambdabot> Monoid b => b -> [b] -> [b]
01:58:00 <Hail_Spacecake> how do I fix that?
01:58:05 <supki> > let fibs = 0:1:zipWith (+) fibs (drop 1 fibs) in fibs !! 34
01:58:07 <lambdabot>   5702887
01:58:10 <__xc> :t scanr (:)
01:58:12 <lambdabot> [a] -> [a] -> [[a]]
01:58:55 <supki> Hail_Spacecake: there is no setting for multiline prompt afaik
01:59:19 <__xc> :t scanr (++)
01:59:20 <lambdabot> Monoid b => b -> [b] -> [b]
01:59:25 <Hail_Spacecake> oh huh
01:59:29 <Hail_Spacecake> there's a bug report about that
01:59:42 <Hail_Spacecake> about the feature to change multiline prompt not existing
01:59:42 <Hail_Spacecake> that is annoying
01:59:50 <supki> yes
02:00:18 <kennyd> > scanr (\x acc -> [x] ++ acc) [] "haskell"
02:00:21 <lambdabot>   ["haskell","askell","skell","kell","ell","ll","l",""]
02:00:38 <johnw> > tails "haskell"
02:00:40 <lambdabot>   ["haskell","askell","skell","kell","ell","ll","l",""]
02:00:57 <kennyd> that's no fun
02:00:58 <__xc> @src tails
02:00:59 <lambdabot> tails []         = [[]]
02:00:59 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
02:01:05 <johnw> > scanr (:) [] "haskell"
02:01:07 <lambdabot>   ["haskell","askell","skell","kell","ell","ll","l",""]
02:02:08 <kennyd> @pl scanl (\acc x -> [x] ++ acc) [] "haskell"
02:02:08 <lambdabot> scanl (flip (:)) [] "haskell"
02:03:05 <__xc> ok I see
02:03:28 <Hail_Spacecake> by the way
02:03:28 <Hail_Spacecake> is http://legacy.cs.uu.nl/daan/download/parsec/parsec.html this most recent documentation for parsec?
02:03:32 <Hail_Spacecake> becuase this looks 12 years old
02:03:46 <Hail_Spacecake> and I'm running examples that I think might not be working because it's 12 years old and things have since changed
02:05:29 <__xc> > cycle "haskell"
02:05:31 <lambdabot>   "haskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhask...
02:06:12 <arkeet> Hail_Spacecake: the most recent documentation for parsec is in the parsec package
02:06:14 <Cale> ParadoxMuffin: length
02:06:56 <Cale> Hail_Spacecake: Despite its age, that's a pretty good tutorial which I recommend going through regardless.
02:07:30 <aristid> johnw: pong?
02:07:43 <Cale> (the main differences are that the module locations have changed, and some types have been generalised, but other than that, it's a decent intro)
02:07:52 <johnw> aristid: have you given any thought to a dynamodb API library yet?
02:08:00 <Hail_Spacecake> Cale I can't get the second parens example to compile
02:08:27 <Cale> Hail_Spacecake: Perhaps you could hpaste the error you're seeing? (and your code perhaps?)
02:08:58 <Cale> You'll want to import Text.Parsec.String and Text.Parsec.Char
02:09:01 <Hail_Spacecake> Cale hh, it works now
02:09:04 <Hail_Spacecake> must've mistyped something
02:09:06 <Hail_Spacecake> also
02:09:18 <Hail_Spacecake> what is the differnece between Text.Parsec and Text.ParserCombinators.Parsec?
02:09:24 <arkeet> one is older
02:09:29 <mitchell> spacecake you in 313?
02:09:29 <Cale> The latter is just an older location for the modules
02:09:31 <arkeet> for compatibility with parsec 2
02:09:36 <arkeet> yeah, an older name.
02:09:37 <Hail_Spacecake> the latter is what write yourself a scheme suggests
02:09:48 <arkeet> write yourself a scheme is old
02:09:48 <Hail_Spacecake> mitchell no what is 313?
02:10:21 <Hail_Spacecake> oh
02:10:21 <Hail_Spacecake> so, the more up to date is Text.Parsec?
02:10:25 <mitchell> Hail_Spacecake: comp313, just thought you might be.  We are writing a parser in haskell lol
02:10:27 <aristid> johnw: thought, yes. i just haven't done anything on aws recently
02:10:38 <Cale> Hail_Spacecake: After a couple years of typing Text.ParserCombinators.Parsec over and over, I guess parsec users got tired of the length of that module name :)
02:10:44 <Hail_Spacecake> mitchell what school are you going to where you're learning haskell?
02:10:55 <mitchell> University
02:10:57 <aristid> johnw: there are multiple other people interested in that, actually
02:11:06 <Hail_Spacecake> what university I mean?
02:11:08 <mitchell> oh you mean which
02:11:09 <Cale> (but the modules are still there in some form for backwards compatibility)
02:11:09 <mitchell> sorry
02:11:12 <arkeet> there are lots of universities mitchell
02:11:13 <arkeet> :p
02:11:16 <mitchell> Waikato university in new zealand lol
02:11:25 <Hail_Spacecake> I am nowhere near new zealand :)
02:11:28 <Hail_Spacecake> that is cool though
02:11:29 <mitchell> It's a third year paper
02:11:34 <mitchell> i am struggling lol
02:11:45 <mitchell> we have to write a parser for the language "Tiny"
02:11:50 <aristid> johnw: why?:)
02:12:08 <mitchell> Using a bst
02:12:11 <Hail_Spacecake> yeah I'm trying to go through write yourself a scheme and I'm realizing I don't understand Parsec, so I'm trying to learn that
02:12:27 <johnw> aristid: because I need one, and was seeing what collaboration possiblities existed
02:12:32 <arkeet> learn it by writing yourself a parsec :p
02:12:37 <johnw> if you are looking for a new maintainer for aws, btw :)
02:18:13 <Ghoul_> cabal install lambdabot: http://puu.sh/2IEfy/6ce92f3a6d.png
02:18:19 <Ghoul_> ubuntu 12.04 LTS -- any ideas?
02:18:47 <supki> .png?
02:18:48 <arkeet> get lambdabot from git
02:18:53 <__xc> hmm should test 13.04 once
02:19:03 <__xc> (reminds me)
02:19:07 <dcoutts_> Ghoul_: building on a box with very little memory?
02:19:14 <Ghoul_> dcoutts_: amazon ec2
02:19:19 <Ghoul_> should have 600mb
02:19:30 <dcoutts_> that's near the lower limit
02:19:37 <dcoutts_> you can just try it again
02:19:44 <Ghoul_> I've tried twice
02:19:46 <Ghoul_> I'll try again
02:19:52 <arkeet> I don't see any out of memory error.
02:20:15 <supki> ExitFailure 9 can mean oom
02:20:27 <arkeet> oh, warnings.
02:20:31 <dcoutts_> arkeet: no, the kernel OOM killer doesn't tell you much, it just kills things :-)
02:20:42 <arkeet> I thought those were errors and then didn't read them.
02:20:50 <Hail_Spacecake> so I can do parseTest ((string "(a)") <|> (string "(b)")) "mystring"
02:21:16 <Hail_Spacecake> but if I try to do let myParser =  ((string "(a)") <|> (string "(b)")) in ghci I get  ((string "(a)") <|> (string "(b)"))
02:21:20 <Hail_Spacecake> er, No instance for (Stream s0 m0 Char) arising from a use of `string'
02:21:30 <Hail_Spacecake> and a bunch of type error stuff I dont' know how to make sense of
02:21:48 <dcoutts_> Ghoul_: the issue is that gnu ld can take a very large amount of mem for the static linking of large haskell libs
02:21:56 <Ghoul_> ah
02:22:01 <supki> Hail_Spacecake: :set -XNoMonomorphismRestriction
02:22:11 <dcoutts_> Ghoul_: if you're using a sufficiently new ghc and have shared libs, you could do a dynamic lib build
02:22:36 <dcoutts_> Ghoul_: or build on a different box and copy over
02:22:46 <Hail_Spacecake> supki cool. what is that and how did you know that would fix my problem?
02:23:11 <supki> @where dmr
02:23:11 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:23:28 <supki> Hail_Spacecake: I just happen to be familiar with this kind of parsec errors :)
02:23:58 <dcoutts_> Ghoul_: also, if you're just trying again, you can do it by unpacking the source and doing each step, rather than a whole-tarball cabal install, that way you can re-run "cabal build" for the link step without redoing everything else
02:24:13 <PatrickRobotham> How do I generate a uniformly distributed random number between 0 and 1?
02:24:24 <Cale> Hail_Spacecake: The monomorphism restriction is a silly misfeature where if you have a pattern binding (as opposed to a function binding, with parameters), and it doesn't have an explicit type signature, it's not allowed to be type class polymorphic.
02:24:32 <dcoutts_> @hoogle randomR
02:24:32 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
02:24:32 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
02:24:32 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
02:24:33 <Ghoul_> How do I do a dyn build?
02:25:15 <dcoutts_> Ghoul_: first you want to check if your existing core packages have dyn versions, look in the ghc install lib dir, look for .so versions of libs
02:25:26 <Cale> The reason for this is that the translation which implements type classes turns pattern bindings into function bindings, and so things which look like constants syntactically can end up being functions whose values won't be memoised.
02:25:58 <dcoutts_> Ghoul_: if you've got them then you can use cabal install --enable-shared
02:26:01 <Cale> However, I think most people agree that this should have been a warning at most.
02:26:09 <Ghoul_> oh that sounds easy
02:26:34 <dcoutts_> Ghoul_: note that all dependent libs have to have been build shared too, so you might need to reinstall all your user packages
03:10:33 <adnap> How do I add a type signature to a do block?
03:12:43 <johnsonbill> can anyone point me in the direction to decompose a range into a normal distribution of x numbers where the sum of x numbers equals the range?
03:13:58 <wole2> @hoogle [Int] -> [[Int]]
03:13:58 <lambdabot> Data.List inits :: [a] -> [[a]]
03:13:58 <lambdabot> Data.List permutations :: [a] -> [[a]]
03:13:58 <lambdabot> Data.List subsequences :: [a] -> [[a]]
03:14:57 <aristid> > permutations [1,2,3]
03:14:59 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
03:16:16 <lambdadelta> @src permutations
03:16:16 <lambdabot> Source not found. Wrong!  You cheating scum!
03:17:43 <k00mi_> adnap: a do block has the type of the last expression, so you just have to give that a type signature
03:20:32 <merijn> adnap: Can you hpaste the bit where you'd want to add a type signature?
03:21:24 <hinst> []:[]:[]
03:26:57 <adnap> merijn: I'm working on making a simple example. I have a problem with "forall" and I don't understand forall very well, so it's taking me a while
03:27:48 <adnap> I have "forall t." in my function type signature and I'm getting "Could not deduce (t1 ~ t)"
03:28:16 <merijn> adnap: hpaste the function?
03:28:22 <supki> adnap: did you enable ScopedTypeVariables extension?
03:28:25 <adnap> After reading http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do, I think I need to use ScopedTypedVariables, but I'm not sure how yet
03:28:32 <adnap> supki: Yes
03:28:48 <supki> then hpaste =)
03:28:57 <adnap> But my code example is so big
03:33:28 <fdfgdf> hi does anyone have any experience with C++?
03:34:58 <adnap> I think the probllem is my type signature is like "f :: forall a. A a => B a -> IO ()"
03:35:36 <Zeev> going through try haskell
03:35:59 <Zeev> I'd personally replace the in keyword let x = 8 * 10 in x + x
03:36:12 <Zeev> with "and" keyword or with "->" keyword
03:36:12 <supki> adnap: that shouldn't be a problem
03:36:23 <Zeev> it's not intuitive
03:37:08 <Cale> Zeev: I think it's intuitive... but maybe I'm strange :)
03:37:10 <patrikf> Zeev: i think it makes sense... "x" is replaced with the value given, (but only) "withIN" the following statements
03:37:22 <Cale> s/statements/expression/
03:37:42 <Cale> Certain declarations are being made in the scope of a given expression.
03:38:14 <Cale> "let x be equal to 8 * 10 in the expression x + x"
03:39:28 <chairs> Zeev, I remember thinking that was really intuitive when I first encountered it. To each his own, I suppose.
03:40:15 <chairs> part of the reason I found Haskell really readable though was because up till that point the only functional programming I'd done was in J (a sister language to APL).
03:40:52 <merijn> chairs: You must be one of the few persons not complaining about the number of operators in haskell :D
03:41:13 <hpaste> adnap pasted ‚Äúforall‚Äù at http://hpaste.org/86747
03:41:17 <adnap> There
03:42:02 <chairs> merijn: ha! Haven't had much chance to complain anyways, since most of what I do in Haskell is small-scale hobbyist programming. I need to study libraries more.
03:42:20 <merijn> adnap: None of your forall's actually do anything
03:42:35 <adnap> merijn: Blame the person who wrote reactive-banana
03:42:43 <forebar> "f = a >>= b" is the same as "f = do { x <- a; b x }", right?
03:42:45 <merijn> "forall t. Frameworks t => GameNetworkDescription t -> IO ()" and "Frameworks t => GameNetworkDescription t -> IO ()" are identical
03:43:09 <merijn> adnap: You need the forall for ScopedTypeVariables, but you're not using those
03:43:11 <chairs> the only complaint I've had is trying to come up with names for things like >>= when reading LYaH. Since I say things in my head as I read them, that was always awkward until I came up with a name.
03:43:26 <supki> adnap: and the error?
03:43:30 <merijn> chairs: Well >>= is bind, but you probably figured that one out
03:43:35 <merijn> forebar: Almost
03:43:43 <merijn> @undo do { x <- a; b x }
03:43:44 <lambdabot> a >>= \ x -> b x
03:43:51 <adnap> So you're not going to compile it?
03:44:11 <chairs> merijn: not really. Still working on getting a good mental schema of monads. I'd come up with "feed", but "bind" does make more sense and is probably more appropriate.
03:44:18 <merijn> forebar: You can also private message lambdabot with @undo to see how it desugars
03:44:30 <forebar> merijn: oh okay. so what is "f = a >>= b" with do-notation?
03:44:55 <hpaste> adnap annotated ‚Äúforall‚Äù with ‚Äúforall error‚Äù at http://hpaste.org/86747#a86748
03:45:20 <merijn> forebar: See lambdabot's response a few lines back. You can write "a >>= b" directly, because there's no desugaring rule for that
03:45:31 <merijn> eh, *can't* write it directly
03:46:01 <merijn> forebar: The desugaring rules need to account for x being used multiple times, consider this one
03:46:12 <merijn> @undo do { x <- a; b x; c x }
03:46:12 <lambdabot> a >>= \ x -> b x >> c x
03:46:26 <merijn> Without the "\x -> b x" that'd desugar wrong
03:46:32 <forebar> yeah, i see
03:46:40 <hpaste> adnap annotated ‚Äúforall‚Äù with ‚Äúforall (error with "gameLoop :: Frameworks t => GameNetworkDescription t -> IO ()")‚Äù at http://hpaste.org/86747#a86749
03:46:55 <merijn> forebar: other than that they're identical in behaviour, though
03:47:02 <adnap> merijn: ^
03:47:31 <forebar> merijn: thanks :)
03:47:47 <supki> adnap: did you try to annotate ePhysics?
03:48:22 <adnap> supki: No...
03:48:28 <supki> adnap: i.e. (ePhysics :: Event t UTCTime)
03:48:30 <adnap> supki: Did you tell me to do that?
03:48:49 <adnap> merijn said I don't need forall, but...
03:48:56 <adnap> if I remove it I still get errors
03:49:23 <supki> not sure what merijn meant, but you need foralls for scoped type variables at least
03:49:41 <adnap> It is bothersome that I don't know the purpose of the foralls. They're just in a lot of reactive-banana examples
03:49:54 <supki> they introduce variables into scope
03:50:02 <adnap> supki: For example?
03:50:41 <adnap> It seems like the only purpose is to carry around the dummy type "t"
03:50:56 <supki> for example if you have  f :: forall a. ... you can refer to that  a  in function definition as  :: a
03:51:00 <adnap> e.g. "Moment t"
03:51:01 <supki> yes
03:52:01 <adnap> So, I don't understand merijn. I think I need the forall t. for GameNetworkDescription t
03:52:34 <supki> it helps if you have something too polymorphic and you want to constraint it
03:52:35 <merijn> adnap: I didn't say you don't need it, I said it doesn't do anything in the type signatures you showed me
03:52:49 <merijn> So if you need it, you're using them incorrectly
03:53:05 <merijn> supki: He's not actually using SCTV anywhere in the pasted code?
03:53:06 <supki> merijn: there is at least one type annotation with scoped variable on line 60
03:53:07 <adnap> Yeah, I know it doesn't do anything, but the dummy type "t" is in the API
03:53:23 <merijn> oh, I missed that one
03:53:33 <merijn> But then he only needs the forall for that function
03:53:38 <supki> yes
03:54:16 <adnap> I added that
03:54:20 <adnap> only to try to solve my error
03:54:31 <adnap> (the annotation on line 60)
03:55:20 <adnap> i
03:55:20 <merijn> adnap: Try adding an explicit type signature to your definition of loop in gameLoop
03:56:18 <supki> why loop?
03:56:28 <supki> seems problem is with ePhysics
03:56:47 <adnap> Do you just not want to download all the libs to compile the code?
03:57:19 <adnap> This is kind of why I wanted to make a small example, but I don't understand the problem well enough to condense it
03:57:25 <merijn> supki: I'm getting a bit confused by the errors they don't seem to line up with the code
03:58:53 <adnap> Okay, look at this for example: http://hackage.haskell.org/packages/archive/reactive-banana/0.7.1.1/doc/html/Reactive-Banana-Frameworks.html#v:compile
03:59:06 <adnap> See how the "forall t." permeates the whole API?
04:00:24 <supki> yes, it says you must be polymorphic in t in your code
04:01:07 <adnap> Yeah, and I guess that means I have to put "forall t.
04:01:17 <adnap> " in any type signature involving "t"
04:01:44 <supki> no
04:01:57 <adnap> Well, I don't understand
04:02:01 <supki> foralls are implicit in type signatures
04:02:17 <supki> id :: a -> a  is actually  id :: forall a. a -> a
04:02:28 <adnap> Is that true only if I use extensions?
04:02:39 <merijn> No, that is always the case in haskell
04:02:49 <supki> _you_ can write foralls only if you use extensions
04:02:50 <adnap> Well, I don't understand why I get these crazy errors then
04:02:55 <merijn> Any type variable with no forall has an implicit forall on the left hand side
04:03:29 <merijn> i.e. "a -> b -> c -> d" is identicall to "forall a . forall b . forall c . forall d . a -> b -> c -> d"
04:04:49 <adnap> I added ":: Moment t (Event t UTCTime)" to "ePhysics <- ... " and I still get the same error
04:04:55 <supki> and that type annotation on line 60 is wrong, you can't use t there
04:05:24 <adnap> Okay. I removed it. I still get the same error
04:05:28 <adnap> And why?
04:05:35 <adnap> (can't I use it)
04:06:53 <kirillt> Hello.
04:07:26 <supki> adnap: are you familiar with ST?
04:07:37 <adnap> supki: I don't think so
04:08:08 <adnap> supki: No
04:08:16 <kirillt> I am trying to evaluate runCommand / system (from System.Process) in `seq`. But command isn't called. I am trying this: `seq (system "echo test >> log") "ok"`.
04:08:27 <supki> adnap: well, type of  compile  enforces that you can't use t from outside and must be polymorphic in it
04:08:58 <adnap> supki: I don't understand
04:09:07 <Iceland_jack> kirillt: seq evaluates the term, it doesn't run the action
04:09:09 <mauke> kirillt: evaluating (system "...") doesn't do anything
04:09:11 <merijn> kirillt: You can't do IO like that
04:09:19 <Iceland_jack> > print "HI" `seq` ()
04:09:21 <lambdabot>   ()
04:09:48 <merijn> 'system "echo test >> log"' returns an IO action that runs that command, it doesn't actually run it
04:09:57 <arkeet> s/returns/is/
04:10:01 <kirillt> Iceland_jack, doesn't reduction of system produce command call?
04:10:05 <Iceland_jack> kirillt: no
04:10:10 <merijn> The only IO action that gets run is main and whatever main calls
04:10:17 <mauke> what do you mean by "reduction" and "produce"?
04:10:24 <merijn> arkeet: system is a function, ergo "system someString" returns an IO action
04:10:30 <Iceland_jack> In the same way that: (let notUsed = print "won't appear" in 2 + 2) is a pure expression
04:10:43 <arkeet> no, system returns an IO action when given some string.
04:10:44 <kirillt> Iceland_jack, ah, understood, I didn't see IO in annotation; thought that this is unsafe function
04:10:45 <mauke> merijn: not sure I agree
04:10:57 <merijn> :t system
04:10:58 <lambdabot> Not in scope: `system'
04:11:01 <mauke> merijn: system returns something, sure. but system x does not
04:11:02 <merijn> oh, doh
04:11:24 <Iceland_jack> System is a pure function that takes a string and returns an impure IO action
04:11:38 <mauke> s/impure/pure/
04:11:41 <merijn> If I had said "div 2 10" returns an integer then no one would have had any criticism...
04:11:48 <arkeet> false
04:11:50 <mauke> merijn: [citation needed]
04:11:51 <shachaf> I have criticism.
04:12:06 <shachaf> div 2 10 is an Integer. It doesn't return anything.
04:12:11 <merijn> shachaf: Yes, but it probably involves lens and unsafeCoerce
04:12:28 <shachaf> (Unless you have an Integral instance for functions, perhaps.)
04:12:37 <mauke> > div 2 10 "good point"
04:12:38 <lambdabot>   No instance for (GHC.Real.Integral ([GHC.Types.Char] -> a0))
04:12:38 <lambdabot>    arising fro...
04:12:53 <arkeet> which you don't, because you can't write toInteger.
04:13:00 <merijn> :t div 2 10 :: Char -> Int
04:13:01 <lambdabot>     No instance for (Integral (Char -> Int))
04:13:02 <lambdabot>       arising from a use of `div'
04:13:02 <lambdabot>     Possible fix:
04:13:11 <merijn> oh, bollocks
04:13:18 <merijn> That requires Num...
04:13:20 <shachaf> arkeet: I can't?
04:13:24 <mauke> boldilocks
04:13:27 <arkeet> well, you can.
04:13:29 <arkeet> but it'll suck.
04:14:42 <shachaf> What if I make an instance (a ~ (), b ~ Integer) => Integral (a -> b)?
04:14:45 <wole> @hoogle Eq a => [a] -> [[a]]
04:14:45 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
04:14:45 <lambdabot> Data.List inits :: [a] -> [[a]]
04:14:45 <lambdabot> Data.List permutations :: [a] -> [[a]]
04:16:17 <arkeet> shachaf: I was going to say something about that but decided against it.
04:17:40 <wole> is there a built in function that groups repeating values so that [1,2,2,1,3,3,2] -> [[1],[2,2],[1],[3,3],[2]]?
04:17:43 <shachaf> arkeet: You didn't decide very well.
04:17:48 <shachaf> wole: group
04:18:00 <arkeet> shachaf: that's obvious. I'm still awake.
04:18:00 <shachaf> > group [1,2,2,1,3,3,2]
04:18:01 <lambdabot>   [[1],[2,2],[1],[3,3],[2]]
04:18:11 <wole> cool! thank you
04:18:13 <mauke> wole: first search result
04:18:21 <shachaf> @hoogle Eq a => [a] -> [[a]]
04:18:21 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
04:18:21 <lambdabot> Data.List inits :: [a] -> [[a]]
04:18:21 <lambdabot> Data.List permutations :: [a] -> [[a]]
04:18:35 <shachaf> Oh, you just searched above.
04:18:55 <wole> i thought group would yield [1,1,2,2,2,3,3]
04:19:03 <wole> should have tested it first
04:19:08 <wole> anyway, thanks
04:19:27 <mauke> > sort [1,2,2,1,3,3,2]
04:19:28 <lambdabot>   [1,1,2,2,2,3,3]
04:19:54 <arkeet> that would be a difficult thing to do given only Eq.
04:20:00 <mauke> but not impossible
04:20:33 <arkeet> sorting?
04:20:49 <mauke> > let blort [] = []; blort (x : xs) = x : ys ++ blort zs where (ys, zs) = partition (x ==) xs in blort [1,2,2,1,3,3,2]
04:20:51 <lambdabot>   [1,1,2,2,2,3,3]
04:21:11 <arkeet> oh, not sorting.
04:21:36 <aCube> > partiton (==1) [1,2,3,4,1,2,4]
04:21:37 <lambdabot>   Not in scope: `partiton'
04:21:37 <lambdabot>  Perhaps you meant one of these:
04:21:37 <lambdabot>    `partition' (i...
04:21:37 <lambdabot> aCube: You have 1 new message. '/msg lambdabot @messages' to read it.
04:21:48 <aCube> > partition (==1) [1,2,3,4,1,2,4]
04:21:50 <lambdabot>   ([1,1],[2,3,4,2,4])
04:22:09 <aCube> ah, so partition x = filter x &&& filter (not . x) ?
04:22:24 <arkeet> yes, but more efficient.
04:22:29 <shachaf> > let blort [a,b,c,d,e,f,g] = [a,d,b,c,g,e,f]; blort _ = [] in blort [1,2,2,1,3,3,2] -- it's even possbile without Eq!
04:22:32 <lambdabot>   [1,1,2,2,2,3,3]
04:22:41 <arkeet> I can do one better.
04:22:50 <shachaf> With a polymorphic type?
04:22:51 <arkeet> > let blort _ = [1,1,2,2,2,3,3] in blort [1,2,2,1,3,3,2]
04:22:52 <mauke> const [1,1,2,2,2,3,3]
04:22:53 <lambdabot>   [1,1,2,2,2,3,3]
04:23:13 <mauke> the polymorphest type
04:23:30 <shachaf> arkeet: By hard-wiring the return type to a Num instance, you get an Eq superclass (in proper Haskell).
04:23:44 <shachaf> Therefore the return type is still an Eq instance.
04:23:51 <arkeet> but not the argument type.
04:23:59 <hpaste> supki annotated ‚Äúforall‚Äù with ‚Äúforall (annotation)‚Äù at http://hpaste.org/86747#a86751
04:24:07 <shachaf> argument type: silly
04:24:18 <arkeet> only in my version
04:24:23 <arkeet> > let blort :: silly -> [Int]; blort _ = [1,1,2,2,2,3,3] in blort [1,2,2,1,3,3,2]
04:24:25 <supki> adnap: that should compile ^
04:24:25 <lambdabot>   [1,1,2,2,2,3,3]
04:24:42 <mauke> @let blort [] = []; blort (x : xs) = x : ys ++ blort zs where (ys, zs) = partition (x ==) xs
04:24:44 <lambdabot>  Defined.
04:24:49 <mauke> > blort "hello, world!"
04:24:51 <supki> adnap: basically the problem is your  gameNetwork  is insufficiently polymorphic in t
04:24:51 <lambdabot>   "hellloo, wrd!"
04:25:26 <mauke> > blort "http://haskell.org/"
04:25:27 <lambdabot>  Terminated
04:25:51 <adnap> How can I copy from hpaste? When I select-copy and middle-click in vim, there are crazy indentations
04:26:09 <shachaf> adnap: This is a vim question, not an hpaste question.
04:26:24 <patrikf> adnap: "*p, or :set nopaste. (although this really is a vim question)
04:26:24 <shachaf> See :set paste, "*p, and others.
04:26:32 <shachaf> (Ask in #vim for more details.)
04:26:39 <adnap> I hate vim
04:26:45 <shachaf> :set nopaste will do the opposite. :-)
04:26:46 <kwstas> hello there. I'm using test-framework to run my tests, but when I define my [Test] to be executed, I get a warning: Warning: Top-level binding with no type signature: testAll :: [test-framework-0.8:Test.Framework.Core.Test]. However, I cannot define a signature because Test.Framework.Core is a hidden package. Is there a way to overcome this issue?
04:26:59 <patrikf> shachaf: indeed
04:27:16 <patrikf> adnap: it's not exactly the only editor around, so...
04:27:27 <wole> what if I wanted to group a tuple by the second value so that
04:27:28 <wole> [('a',1),('b',2),('c',2),('d',1),('e',3),('f',3),('g',2)] -> [[('a',1)],[('b',2),('c',2)],[('d',1)],[('e',3),('f',3)],[('g',2)]]
04:27:28 <adnap> Yeah. I just haven't learned a bettter one yet
04:27:54 <arkeet> wole: look at groupBy
04:27:58 <merijn> adnap: "set clipboard+=unnamed" add to .vimrc, thank me later
04:27:58 <arkeet> :t groupBy ((==) `on` snd)
04:27:59 <lambdabot> Eq b => [(a, b)] -> [[(a, b)]]
04:28:01 <wole> cool. thanks
04:28:08 <adnap> merijn: black magic
04:28:23 <merijn> adnap: That lets vimy yank/paste from/to the OS/X11 clipboard
04:28:24 <adnap> supki: Thanks! It works. If only I understood why
04:28:39 <merijn> I can use yy to copy and then command-v to paste in my browser, etc
04:28:43 <arkeet> I just paste using "+p
04:28:59 <merijn> Or copy using command-v and paste using p
04:29:12 <arkeet> and copy with "+y or whatever
04:29:17 <supki> kwstas: Test.Framework.Core is a module name, Test is type
04:29:24 <arkeet> it's very easy.
04:29:31 <supki> kwstas: you should be able to use Test in type signature
04:29:33 <merijn> arkeet: " is such an inconvenient key to hit, though
04:29:38 <shachaf> "* is relevant to the question, not "+ . However, neither is relevant to #haskell.
04:29:45 <adnap> arkeet: Wht do you mean "paste using "+p""?
04:29:52 <arkeet> press the keys "+p
04:30:04 <merijn> That pastes from the OS clipboard
04:30:10 <FireFly> also, read the help on registers
04:30:11 <adnap> It does nothing
04:30:16 <merijn> Provided your vim supports that
04:30:18 <supki> adnap: you should read about rank-N types
04:30:18 <merijn> adnap: Which OS?
04:30:20 <FireFly> anyway, => #vim
04:30:26 <merijn> Naah, #-blah
04:30:28 <shachaf> I recommend that you do what FireFly said.
04:30:30 <FireFly> Well, either
04:30:38 <adnap> Now it worked
04:30:38 <FireFly> (but which one is right?!)
04:30:40 <adnap> nevermind
04:30:57 <kwstas> supki: No I cannot. I get this exception: Couldn't match expected type `Test'
04:31:00 <kwstas>                 with actual type `test-framework-0.8:Test.Framework.Core.Test'
04:31:08 <arkeet> anyway, I don't like clipboard=unnamed becuase I don't want deleting and whatever to trample over my clipboard. and that's all I say about vim.
04:31:55 <adnap> Okay, I will remember this crazy "+p
04:32:48 <shachaf> And remember the crazy #vim, too.
04:32:49 <adnap> supki: I read about them here: http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
04:33:05 <FireFly> and also remember to  :h "+
04:34:11 <arkeet> and :h registers really
04:35:29 <kwstas> supki: Ok, my fault, because I used the import: import Test.Framework  (defaultMain, testGroup). I changed it to:  import Test.Framework  (defaultMain, testGroup, Test) and worked fine!! Thanks a lot
04:36:21 <supki> I don't see how this change could fix you error but ok =)
04:38:17 <kwstas> supki: and I also hid Test from Test.HUnit. Maybe this was the culprit ;)
04:45:36 <osa1> is there a way to define a type synonym in `where ...` part of a declaration ?
04:46:15 <donri> osa1: yes. just like normal
04:47:22 <donri> osa1: (align with the rest, aka. indent it)
04:47:38 <donri> osa1: oh, ignore me, i read type signature
04:47:42 <shachaf> donri: What?
04:47:47 <shachaf> Ah.
04:47:52 <donri> heh
04:47:58 <arkeet> osa1: no.
04:48:01 <shachaf> Type synonyms are possible in some situations. module Foo where type ... = ...
04:48:04 <donri> read first think later!
04:48:23 <donri> it's possible in idris i think! :p
04:48:31 <shachaf> instance Foo Bar where type ... = ...
04:48:31 <arkeet> a lot of things are.
04:48:46 <arkeet> do those count as declarations?
04:48:56 <arkeet> I guess so.
04:49:15 <donri> they're Dec in TH anyway
04:49:16 <shachaf> In Idris types are first-class so it doesn't really count.
04:49:32 <donri> :)
04:49:46 <arkeet> I don't think you can define type synonyms in instances can you?
04:49:48 <arkeet> just type family instances.
04:49:50 <osa1> thanks
04:49:56 <merijn> arkeet: What's the difference
04:49:58 <arkeet> associated with the class.
04:50:06 <merijn> arkeet: Any type synonym is a trivial type family
04:50:31 <arkeet> not "is" in the sense of equality, no
04:51:00 <merijn> is in the sense of "can be represented by"
04:51:17 <arkeet> but not in the sense of "is accepted by the compiler in the same way as", which is the discussion
04:51:51 <shachaf> OK, what if I say class instead of instance?
04:52:46 <arkeet> then that's a type family, not a type synonym.
04:53:07 <arkeet> I dunno.
04:53:54 <wole> @pl \x y -> snd x == (snd y)
04:53:55 <lambdabot> (. snd) . (==) . snd
04:54:25 <aCube> @ty (==) `on` snd
04:54:27 <lambdabot> Eq b => (a, b) -> (a, b) -> Bool
04:55:10 <aCube> @ty uncurry $ join liftA2 (==) snd
04:55:12 <lambdabot>     Couldn't match expected type `b0 -> c0' with actual type `Bool'
04:55:12 <lambdabot>     Expected type: (b1 -> b0 -> c0) -> b1 -> b0 -> c0
04:55:12 <lambdabot>       Actual type: (b1 -> b0 -> c0) -> (b1 -> b0 -> c0) -> Bool
04:56:26 <aCube> @ty uncurry $ join (liftA2 (==)) snd
04:56:28 <lambdabot>     Couldn't match expected type `b0 -> c0' with actual type `Bool'
04:56:28 <lambdabot>     Expected type: a0 -> a0 -> b0 -> c0
04:56:28 <lambdabot>       Actual type: a0 -> a0 -> Bool
04:57:47 <aCube> @ty liftA2 (==) snd snd
04:57:48 <skuggi> How is () represented in template haskell? TupT 0?
04:57:49 <lambdabot> Eq b => (a, b) -> Bool
04:58:10 <aCube> How can this function return anything depending on b ?
04:58:38 <aCube> ah, it's const True :P (assuming b == b)
04:59:10 <shachaf> > liftA2 (==) snd snd (1, 0/0)
04:59:12 <lambdabot>   False
04:59:14 <skuggi> TupleT 0, I mean.
04:59:18 <shachaf> Not so const now!
04:59:23 <aCube> > 0/0
04:59:25 <lambdabot>   NaN
04:59:32 <aCube> > 0/0 == 0/0
04:59:34 <lambdabot>   False
04:59:50 <merijn> aCube: NaN is unequal to everything, including NaN
04:59:54 <aCube> shachaf: I said "assuming b == b"
05:00:11 <shachaf> Yes, but what's b?
05:00:19 <skuggi> ÷r
05:00:35 <skuggi> oops, wrong window
05:00:50 <aCube> (I meant "\x -> x == x for all x's of type b (where b is the type in the signature given by lambdabot)) :P
05:01:26 <arkeet> which type?
05:01:28 <arkeet> it's forall b
05:28:20 <`Jake`> Hey guys... I'm currently trying to get gtkh2s working under windows, and it wokrs to some degree, but there'sone problem: If I have the Gtk+ bin directory in my PATH variable, it looks like a native windows 7 app, which is what I want, so that's fine. But for sharing the app, I want to copy the required dlls into the folder where I have the app. If I do that, though, it doesn't look native...
05:28:22 <`Jake`> ...anymore, it looks like this: http://imgur.com/SQXCYZM Does anyone know why that's the case?
05:29:28 <hpc> i don't know much about windows development, but i do know that this is exactly the reason why installshield exists
05:29:39 <shachaf> Probably some configuration/theme/whatever file.
05:30:08 <shachaf> If you had an strace-equivalent I might suggest finding out with that. :-)
05:30:43 <`Jake`> I've never heard of strace...
05:30:54 <shachaf> It's not a Windows program.
05:30:58 <hpc> `Jake`: could you perhaps find a way to put . on your path?
05:31:04 <shachaf> More specifically, it's a non-Windows program.
05:31:04 <hpc> or ./inc or whatever
05:31:22 <`Jake`> I'll try, hpc
05:33:46 <merijn> shachaf: More specifically, isn't it essentially linux only?
05:34:35 <`Jake`> If I have the files from the gtk+ bin folder in .\test and I have .\test in path, it's still not native.
05:35:04 <shachaf> merijn: No.
05:36:25 <shachaf> merijn: I see freebsd/, linux/, sunos4/, svr4/
05:37:00 <`Jake`> I might have found something
05:42:27 <`Jake`> Or maybe not. There's a note in the windows readme saying that in order to use the windows theme engine, one should create a file etc/gtk-2.0/gtkrc (on windows?!) containing the line theme-engine-name = "MS Windows". I tried creating gtkrc in . but that didn't do anything.
05:42:58 <shachaf> Presumably you should create it in etc/gtk-2.0/
05:43:29 <`Jake`> but that's a posix path
05:43:40 <shachaf> There is an etc directory on every modern Windows installation (but presumably that's not the one they're talking about).
05:44:08 <shachaf> Something like C:\windows\system32\drivers\etc\
05:44:26 <`Jake`> I'll try that.
05:44:44 <shachaf> I don't recommend putting the GTK files in there.
05:44:50 <shachaf> It almost certainly won't work.
05:45:07 <`Jake`> I'll try creating a ./ect folder, then
05:45:16 <`Jake`> s/ect/etc
05:45:39 <`Jake`> they should use backslashes for the windows readme, though.
05:46:05 <shachaf> No, I doubt that'll work, either.
05:46:14 <shachaf> But I don't know what will work.
05:47:31 <`Jake`> there is a etc\gtk-2.0 folder in the GTK+ folder, but there's no gtkrc in it
05:47:49 <shachaf> Oh. Then maybe try that.
05:48:36 <Philonous> Is c2hs dead?
05:48:44 <`Jake`> I'm not accessing that folder, so putting gtkrc in there doesn't do anything. I'll try copying the whole GTK+ folder though, if that works, I can delete files to see which one does the magic
05:51:02 <`Jake`> That seems to work. Maybe I'll be able to figure it out now.
05:55:52 <`Jake`> OK, seems like I needed more than one file in ./lib and in ./share. I'm just gonna go through the directories and see which files  can or cannot delete, thanks for your help
05:58:02 <`Jake`> And by the way, there's a gtkrc in share\themes\MS-Windows\gtk-2.0\
06:10:21 <methodius> join #debian
06:17:11 <pxqr> I'm using readline library and getting into some troubles. C-n, C-p, <up-arrow>, <down-arrow> do not list history altrough i make call to addHistory. And C-r didn't work. Did anyone have the same problem?
06:18:57 <arkeet> I don't know, but you may also be interested in the haskeline library.
06:23:07 <pxqr> arkeet: well, yes. but that's yet another transformer :(
06:23:39 <arkeet> you don'to have to
06:23:55 <arkeet> there's System.Console.Haskeline.IO
06:24:25 <pxqr> oh, indeed
07:08:09 <madjestic> hey guys, I would like to call a non-exposed function from a module.  How can I achieve that?
07:12:05 <Shou> Is there a function like `when' or `unless' except it returns `mempty' instead?
07:12:51 <hiptobecubic> madjestic, the point of not exposing that function is to disallow that.
07:13:50 <hiptobecubic> madjestic, you have to edit that package or reimplement it yourself (read: copy-paste the definition). I'd suggest first figuring out why you need a function which is not part of the API, because odds are you're doing something wrong.
07:19:28 <gspr> I'm new to the ST monad, and I'm having some trouble with the following: I have an ST-based data structure. Part of it is a tree based on STRefs, i.e. something like data Node s a = Node a (STRef s (Node s a)). Could someone give me a hint towards how to extract a standard inductive tree (like Data.Tree.Tree a) from this?
07:20:14 <gspr> (Obviously there's more to my data than just a tree - otherwise I'd simply use an ordinary inductive tree - but for the purposes of my question we can pretend there's nothing more)
07:20:34 <wole> @hoogle Integral a => a -> a -> (a, a)
07:20:35 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
07:20:35 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
07:20:35 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
07:21:03 <icarot> Fix my brain: how can a single-recursive and tree-recursive process both consume space linearly with the input? (eg, the fibonacci algorithm). So elusive and un intuitive to me.
07:21:57 <icarot> The fibonacci algorithm (tree-recursive) has space complexity O(n) just like a singly-recursive algorithm like factorial. I am baffled.
07:22:52 <icarot> I would think that for the tree-recursive algorithm, the stack would need to store the state of each call.. Thus exponential space complexity. Hmm
07:23:35 <icarot> Not taking into account memoization. I'm not talking about optimizations (or Haskell in particular)
07:24:51 <Botje> icarot: you're either going down the "left" path or backtracking and going down the right path
07:25:41 <Botje> so for fib n, you go down n times until you hit fib 0
07:26:03 <Botje> at which point you have n-2 "right" nodes pending evaluation
07:27:33 <icarot> For fib n you go down now times? Don't you mean n +1 times? No?
07:27:47 <Botje> depends if you stop at fib 1 or fib n
07:27:54 <Botje> *fib 1 or fib 0
07:29:25 <icarot> *n
07:29:26 <icarot> Fib(1) is a computation just like fib(0)
07:29:39 <icarot> When you say "left path" then, are you saying that all of the redundant computation of that branch is ignored?
07:29:49 <icarot> As if it doesn't exist?
07:29:55 <Botje> assume "left" is the n-1 case, and "right" is the n-2 case.
07:30:24 <icarot> That's what I don't understand. Is why, in other words, the space complexity is not as grossly inefficient as the computation complexity.
07:30:37 <icarot> There is some subtle 'obvious' thing I'm missing here.
07:30:46 <Botje> fib(N) = fib (N-1) + fib (N-2), right?
07:30:54 <Botje> now you're free to expand one of these terms and continue
07:31:01 <icarot> Yes.
07:31:03 <Botje> so let's take the left one
07:31:21 <Botje> fib(N) = fib (N-2) + fib (N-3) + fib (N-2)
07:31:29 <icarot> Hm
07:31:33 <icarot> But that's where you got me
07:31:46 <icarot> You said "you're free to expand one of these terms"
07:31:52 <icarot> Keyword: "one"?
07:31:54 * hackagebot putlenses 0.0.2 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.0.2 (HugoPacheco)
07:32:12 <Botje> definitely one in an eager evaluation system
07:32:36 <Botje> in haskell's case, the implementation of + happens to always evaluate one of the two arguments fully, first.
07:33:27 <icarot> Wait: so then, you're telling me that eager evaluation doesn't completely evaluate each branch? Why on earth is that?
07:33:28 <Botje> in an interpereter geared towards parallellism there is definitely merit to expanding both arguments to + at the same time
07:33:46 <Botje> icarot: no, it completely evaluates one branch before starting on the other one.
07:35:11 <Botje> and haskell happens to do so as well because of + evaluating things left to right
07:36:42 <Botje> for fib to be O(fib n) in space as well you'd need to expand the full evaluation tree first and only then start reducing
07:43:42 <aCube> Is the running time of fib linear?
07:45:07 <Botje> no, only its space use
08:06:36 <wole> @hoogle [a] -> [a] -> [a]
08:06:37 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
08:06:37 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
08:06:37 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:08:32 <parcs> if your goal is to evaluate both branches then you must evaluate one first
08:09:22 <trace30m> what is the "$" and when is it used?
08:09:52 <icarot> O(fib n) in space complexity, that is.
08:10:11 <dolio> trace30m: $ is an operator defined by: f $ x = f x.
08:10:13 <Eduard_Munteanu> trace30m: f $ x = f x
08:10:15 <ab9rf> trace30m: it means "function application" and is mainly used to avoid parentheses
08:10:38 <dolio> But it has the lowest precendence instead of highest.
08:10:42 <Eduard_Munteanu> f . g . h $ x   is like  (f . g . h) x
08:10:51 <ab9rf> there are other clever uses from time to time though
08:10:58 <parcs> icarot: no..
08:11:01 <dolio> So: f x + y = (f x) + y, while f $ x + y = f (x + y).
08:14:00 <icarot> parcs: hmm. I need to reread what Botje said more closely, then..
08:21:04 <gspr> I'm new to the ST monad, and I'm having some trouble with the following: I have an ST-based data structure. Part of it is a tree based on STRefs, i.e. something like data Node s a = Node a (STRef s (Node s a)). Could someone give me a hint towards how to extract a standard inductive tree (like Data.Tree.Tree a) from this?
08:21:09 <gspr> (Obviously there's more to my data than just a tree - otherwise I'd simply use an ordinary inductive tree - but for the purposes of my question we can pretend there's nothing more)
08:22:45 <parcs> if you want to evaluate 'fib n', you have to call 'fib' fib n times. so as Botje said, if you expand the full evaluation tree first, space usage will be O(fib n). but if you evaluate one branch at a time, you'll use O(log(fib n)) = O(n) space
08:24:59 <mm_freak> gspr: well, that's not a tree
08:25:14 <mm_freak> to have a tree you need to have a bit more
08:25:56 <aCube> There needs to be a Leaf
08:25:59 <mm_freak> example:  data TreeST s a = Leaf a | Branch (STRef s (TreeST s a)) (STRef s (TreeST s a))
08:26:10 <Eduard_Munteanu> Not only but that's a list :)
08:26:15 <Eduard_Munteanu> An infinite one.
08:26:16 <gspr> Ah yes, sorry guys, I oversimplified my example
08:26:33 <gspr> mm_freak: That's more like what I have, yes :)
08:27:01 <mm_freak> ok, so restate your question‚Ä¶  what do you mean by "extract"?
08:27:04 <gspr> (I really have a lot more structure, but I tried to peal away as much as possible for the sake of the question, and got a bit eager :P )
08:27:34 <gspr> yes so, suppose I have a TreeST s a in your terminology.. how can I build an ordinary, inductive tree from it?
08:27:43 <Eduard_Munteanu> gspr: you can write a function TreeST s a -> ST s (Tree a) and runST it.
08:27:43 <mm_freak> like a function of type TreeST s a -> Tree a?  or like a function that turns TreeST s a into Tree a (the types)
08:28:05 <gspr> Eduard_Munteanu: Yes, that's exactly what I'm trying to do
08:28:10 <mm_freak> gspr: on value level or type level?
08:28:25 <mm_freak> gspr: one easy way is:  first generalize your type
08:28:42 <Eduard_Munteanu> Not sure where that's going.
08:28:48 <mm_freak> data Tree f a = Leaf a | Branch (f (Tree f a)) (f (Tree f a))
08:29:37 <mm_freak> now all you need is a function of type:  (Monad m) => Tree m a -> m (Tree Identity a)
08:29:56 <mm_freak> (i guess you don't need Monad here‚Ä¶  Applicative is sufficient)
08:30:20 <aCube> mm_freak: Why not a function Tree (m a) -> m (Tree a)? That's what sequenceA would be doing, won't it?
08:30:36 <mm_freak> aCube: because that's not the same thing
08:30:49 <mm_freak> oh, wait
08:30:52 <gspr> mm_freak: I don't think I'm following you
08:30:54 <mm_freak> you actually need a bit more
08:31:10 <mm_freak> gspr: but the idea is simple:  generalize the "ST s" away in your type
08:31:28 <mm_freak> then your function becomes:  Tree (ST s) a -> ST s (Tree Identity a)
08:31:58 <aCube> mm_freak: But you cannot generalize STRef's, can you?
08:32:16 <mm_freak> wait, i'm stupid‚Ä¶  Tree (STRef s) a -> ST s (Tree Identity a)
08:32:33 <mm_freak> aCube: you can, but the name 'f' is not appropriate
08:32:58 <mm_freak> data Tree ref a = Leaf a | Tree (ref (Tree ref a)) (ref (Tree ref a))
08:33:31 <mm_freak> deref :: Tree (STRef s) a -> ST s (Tree Identity a)
08:33:46 <aCube> mm_freak: how is that function simple than TreeST s a -> ST s (Tree a) ?
08:33:48 <gspr> mm_freak: I think I see what you're getting at now
08:34:03 <mm_freak> aCube: the function isn't, it's almost the same
08:34:10 <mm_freak> but you don't need a separate non-ST tree type
08:34:38 <mm_freak> and with the same type you can do this:
08:34:46 <mm_freak> derefIO :: Tree IORef a -> IO (Tree Identity a)
08:34:53 <aCube> ah ok
08:35:03 <mm_freak> derefMVar :: Tree MVar a -> IO (Tree Identity a)
08:35:04 <mm_freak> etc.
08:41:46 <__xc> what do you guys think of Lisp?
08:41:56 * hackagebot handa-gdata 0.6.0 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.0 (BrianBush)
08:42:14 <Eduard_Munteanu> I think it's a nasty impediment to have.
08:43:05 <cmccann> clojure seems like it might be worth learning.
08:43:11 <__xc> it's quite opposite f currying
08:43:30 <__xc> variadic / n-ary
08:44:39 <cmccann> yes, though I don't think that's the most important difference vs. haskell...
08:44:56 <mm_freak> __xc: lisp is nice as an XML replacement
08:45:11 <parcs> i don't think anything of lisp
08:46:07 <FireFly> > printf "Hello %s!" "world" :: String
08:46:09 <lambdabot>   "Hello world!"
08:46:14 <Sculptor> lambdabot
08:50:13 <hpaste> gspr pasted ‚ÄúST Tree painting myself into a corner‚Äù at http://hpaste.org/86758
08:50:40 <gspr> Eduard_Munteanu, mm_freak: I know it makes me look like an idiot, but that's the corner I keep painting myself into
08:54:35 <Eduard_Munteanu> gspr: why not   data STTree s a = Leaf a | Branch a [STRef s (STTree s a)]  ?
08:55:45 <gspr> Eduard_Munteanu: Ugh, yes, that looks better! This is my first foray into ST, and I'm finding it hard to think about :)
08:57:50 <magneticduck> hey, kind of style question here.. I made a data type, "Angle", that is a newtype of Double, and I want it to behave exactly like a double, except that whenever an operation is applied to it, it undergoes a "reset", that puts it back in the 0 - 360 bounds
08:57:54 <magneticduck> any good way of doing that?
08:57:56 <gspr> Eduard_Munteanu: Incidentally though, just to straighten my mind out, could something along the lines of what I pasted work?
08:58:20 <Eduard_Munteanu> gspr: sort of
08:59:00 <gspr> Eduard_Munteanu: Any hints? :/
08:59:03 <Eduard_Munteanu> You could also write a   toTree :: (forall s. STTree s a) -> T.Tree a   instead, so you don't need to runST.
08:59:33 <hpc> magneticduck: newtype Angle = Angle Double
08:59:54 <hpc> magneticduck: instance Num Angle where (+) (Angle a) (Angle b) = Angle (normalize (a + b))
08:59:57 <hpc> etc etc
09:00:04 <magneticduck> I really have to do all that
09:00:06 <magneticduck> hm
09:00:08 <magneticduck> alright
09:00:10 <Eduard_Munteanu> gspr: well, start with the leaf case, that's simple   toTree (Leaf a) = T.Leaf a    (add return when not using the forall-ized toTree)
09:00:14 <hpc> you only need to do it once ;)
09:00:29 <magneticduck> yeah, but I kind of thought there would be some easy way to do that
09:00:32 <magneticduck> :l
09:00:36 <magneticduck> ah well
09:01:07 <Eduard_Munteanu> gspr: then in the branch case, you map (or mapM) with the same function over the list of children
09:01:48 <gspr> Eduard_Munteanu: Right, that sounds close to how I was thinking about it
09:03:16 <ab9rf> is mapping over children permitted by child protection laws?
09:03:25 <Eduard_Munteanu> toTree (Branch a bs) = T.Branch <$> (return a) <*> mapM toTree bs     would be a nice way to write it
09:03:28 <gspr> It's just that the children list consists of STRefs, so I'll have to runST the function that readSTRefs those, right?
09:03:39 <pxqr> is it possible to send input to haskeline?
09:04:02 <Eduard_Munteanu> Erm extraneous parens.
09:04:29 <otters> does there happen to be a readProcessWithExitCode that supports shell pipes and stuff?
09:05:02 <Eduard_Munteanu> Grr.
09:05:15 <Eduard_Munteanu> Yeah, you have to dereference those STRefs.
09:05:18 * Eduard_Munteanu isn't paying attention
09:06:26 <pxqr> I have one thread running haskeline "session". Now then some file updates I have INotify handler and I want to write something to input insead of user.
09:06:54 <pxqr> from handler obvious
09:07:22 <Eduard_Munteanu> toTree (Branch a bs) = let bs' = runST (mapM readSTRef bs) in T.Branch <$> pure a <*> map toTree bs'
09:07:28 <Eduard_Munteanu> gspr: something like that ^^
09:07:58 <Eduard_Munteanu> Bah...
09:08:18 <Eduard_Munteanu> toTree (Branch a bs) = let bs' = runST (mapM readSTRef bs) in T.Branch a (map toTree bs')
09:08:25 <elliott> nested runSTs?!
09:09:15 <elliott> perhaps: toTree (Branch a bs) = T.Branch a <$> mapM (readSTRef >=> toTree) bs
09:10:11 <magneticduck> how do I use modulo on Doubles and Floats?
09:10:53 <magneticduck> uhh
09:10:55 <magneticduck> stupid question
09:10:58 <magneticduck> xD
09:11:09 <magneticduck> ahaha, now it hits me
09:11:15 <icarot> Botje: Thank you. After thinking about your explanation, it makes perfect sense. My deficit was in reasoning about the (combined contexts) here of eager evaluation and operator (left) associativity.
09:11:29 <Eduard_Munteanu> elliott: yeah, if the result type is ST s (T.Tree a)
09:11:39 <icarot> (I say eager, because my question actually had nothing to do with Haskell).
09:12:33 <Botje> icarot: happy to help.
09:12:57 <icarot> :)
09:13:22 <Botje> if you ever decide to write an interpreter that does a breadth-first exploration of the evaluation tree, let me know
09:14:14 <monochrom> I always use this highschool example to put a dent in "operator precedence = evaluation order". 0*(3948549+1938943).
09:14:35 <monochrom> do you honestly evaluate 3948549+1938943 first? do you even bother?
09:15:04 <Heffalump> it would take less time than loading it from memory
09:15:09 <Eduard_Munteanu> I don't bother, I expect the compiler to compute that at compile-time. :)
09:15:10 <monochrom> clearly, operator precedence tells you only how to parse. how to evaluate is a separate story.
09:15:25 <monochrom> yes yes, highschool context
09:15:54 <magneticduck> I guess that's why you evaluate the pattern 0x = 0 first
09:15:57 <magneticduck> :P
09:16:04 <monochrom> highschool calls it evaluation order because "parsing" is too advanced
09:16:42 <Eduard_Munteanu> Besides, branching isn't worth it to check for zeros usually.
09:16:49 <hpaste> gspr pasted ‚ÄúST Tree painting myself into a corner, part 2‚Äù at http://hpaste.org/86759
09:17:16 <gspr> Eduard_Munteanu: Sorry for being so slow, but could you help explain why that shouldn't work?
09:17:49 <Eduard_Munteanu> That newtype hurts my head a bit.
09:18:30 <gspr> Eduard_Munteanu: Yeah that's also a relic from the much more noisy code this comes from. I can remove it if you wish
09:19:20 <Eduard_Munteanu> gspr: rRoot isn't a STRef
09:19:36 <Eduard_Munteanu> Wait, it is.
09:19:53 <Eduard_Munteanu> Looks sort of fine.
09:20:06 <Eduard_Munteanu> gspr: are you having problems with it?
09:20:14 <hpaste> gspr pasted ‚ÄúST Tree painting myself into a corner, part 3‚Äù at http://hpaste.org/86760
09:20:24 <gspr> (removed the newtype)
09:20:29 <gspr> yes I am - lemme get the error
09:20:48 <monochrom> perhaps you should write new demo code, rather than reduce old code for demo. it's cleaner and more focused.
09:20:56 <gspr> Expected type: [forall s. NodeRef s a], Actual type: [NodeRef t0 a
09:21:01 <gspr> ]
09:21:20 <gspr> That's the children, I think
09:21:23 <gspr> yeah must be
09:21:25 <Eduard_Munteanu> Yeah.
09:21:37 <gspr> monochrom: Indeed! I should've done that :)
09:22:40 <Eduard_Munteanu> Predicativity bites again.
09:22:58 <gspr> Come again? :)
09:23:02 <gspr> ah yes
09:23:46 <tsinnema> can someone help my haskell newbie self understand what's going on in http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/src/Data-HList-Record.html -- in particular what this 'Fail' business is on the line "instance ( Fail (DuplicatedLabel l1) ) => HRLabelSet' l1 v1 l2 v2 HTrue r" ?
09:26:03 <gspr> Eduard_Munteanu: Am I fundamentally barking up the wrong tree here, or am I just overlooking something?
09:26:26 <gspr> (pun truly not intended)
09:26:35 <Saizan> tsinnema: Fail is a typeclass that's meant to report errors
09:26:58 <elliott> I don't believe your toTree type
09:26:58 <Saizan> tsinnema: it doesn't have instances, so a Fail constraint is never solvable
09:27:06 <elliott> I would believe:
09:27:16 <elliott> toTree' :: NodeRef s a -> ST s (T.Tree a)
09:27:29 <elliott> toTree :: (forall s. NodeRef s a) -> T.Tree a; toTree x = runST (toTree' x)
09:27:38 <tsinnema> Saizan, many thanks
09:28:23 <Eduard_Munteanu> Ahhh...
09:28:26 <geekosaur> tsinnema, HList is ... somewhat advanced type hackery. probably not the best place for a Haskell newbie to get started
09:28:32 <Eduard_Munteanu> Yeah, elliott is right, this can't work.
09:28:43 <Eduard_Munteanu> I just tried it myself.
09:29:16 <Eduard_Munteanu> gspr: use elliott's toTree'
09:30:28 <elliott> also, toTree' should not call runST (or toTree) at all
09:30:30 <gspr> Eduard_Munteanu, elliott: But herein lies my problem; how do I define toTree? I can't just recurse as in the hpaste example now, can I, since toTree returns ST s (T.Tree a)?
09:30:51 <tsinnema> geekosaur, advanced type hackery is my main motivation for finally learning haskell
09:30:51 <gspr> Sorry, that should be toTree'
09:30:51 <tsinnema> :)
09:31:15 <hpaste> MagneticDuck pasted ‚ÄúWeird!‚Äù at http://hpaste.org/86761
09:31:18 <magneticduck> whyyyy
09:31:20 <magneticduck> xD
09:31:29 <gspr> elliott: There you point at part of my confusion‚Ä¶ how can I write toTree' without runST?
09:31:31 <magneticduck> I just ran into this problem, and I have no idea why haskell is behaving like this
09:31:31 <tsinnema> i've been looking at similar stuff in scala before in the shapeless library
09:32:26 <Eduard_Munteanu> gspr: you don't need runST because toTree' works in the ST monad
09:32:41 <gspr> Eduard_Munteanu: Right, but won't I then build up another ST for each recursive call?
09:32:55 <Eduard_Munteanu> gspr: um, no...
09:32:57 <gspr> So as to end up with ST s (T.Tree (ST s (T.Tree ‚Ä¶
09:33:22 <gspr> ok, this must mean we've hit my main point of confusion then :)
09:33:27 <FireFly> magneticduck: `someString` is bound locally as a variable in the pattern in `stringTransform1`
09:33:29 <nlogax> magneticduck: You have no quotes around "someString", is that it? It will match anything
09:33:37 <dmwit> ST s is a monad; therefore join :: ST s (ST s a) -> ST s a
09:33:59 <magneticduck> ah d'oh
09:34:08 <magneticduck> ty
09:34:13 <magneticduck> x|
09:35:17 <Eduard_Munteanu> toTree' ref = do { (Node a bs) <- readSTRef ref; T.Node a <$> mapM toTree' bs }
09:35:21 <Eduard_Munteanu> Or something like that
09:35:41 <Eduard_Munteanu> gspr: ^^
09:36:17 <gspr> Eduard_Munteanu: Of course! That makes perfect sense :)
09:36:33 <gspr> Ugh!
09:36:59 <gspr> Thanks to both you of you, Eduard_Munteanu  and elliott, for clearing this up for me :)
09:37:24 <Eduard_Munteanu> I kinda took you off course once or twice... :)
09:37:40 <gspr> no worries, I learned a lot from it
09:37:47 <gspr> I've postponed getting familiar with ST way too long
09:38:12 <gspr> I also made it extra hard on you for having a weird STTree definition
09:38:29 <Botje> gah!
09:38:33 <Eduard_Munteanu> #haskell confessionals :)
09:38:35 <Botje> I wish I knew lenses
09:38:41 <tsinnema> hehe
09:40:35 <elliott> :)
09:45:29 <k0ral> Hello
09:45:34 <Hello_> Hello guys! I'm newbie just finished reading <Learn You a Haskell for Great Good>. and I want to write an library for computational geometry like CGAL (www.cgal.org). Anyone tried something related on this area? I googled almost 30 pages of search result, but there is no satisfying one.
09:46:16 <fruitFly> Why does this timeout? http://codepad.org/IJOMFTdo
09:46:30 <hpc> Hello_: that's an awesome project
09:46:57 * hackagebot yaml 0.8.2.4 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.2.4 (MichaelSnoyman)
09:47:01 <Hello_> yeah!
09:47:09 <fruitFly> I'm temporarily on someones mac os x 10.5.8 and am not sure how to set up a haskell environment on this. I'm thinking of just compiling online, any recommendations?
09:47:11 <hpc> Hello_: i know some of those already exist as individual packages
09:47:15 <hpc> like this: http://hackage.haskell.org/package/GeomPredicates-SSE
09:47:49 <hpc> i don't think there's anything that is a combination of that many different things at once though
09:48:17 <hpc> and i can't vouch for speed without having any use for it myself
09:49:36 <Hello_> aha! so here is the question. Geometric computing is not suitable with functional programming? or people just did not do it yet?
09:49:37 <hpaste> ‚ÄúRoxana ISTRATE‚Äù pasted ‚Äúhaskell‚Äù at http://hpaste.org/86762
09:50:04 <hpc> Hello_: i think the answer is "people have done only part of it so far"
09:50:19 <k0ral> I'd like to write "instance (MonadTrans t, Monad m, MyMonad m) => MyMonad (t m) where f = lift . f"
09:50:30 <k0ral> but it gives me overlapping instances
09:50:31 <Hello_> thanks for the answer!
09:51:04 <cmccann> Hello_: it's a huge amount of work that's mostly reimplementing things that already exist
09:51:12 <c_wraith> k0ral: of course it does. You're writing an instance for all types that consist of a type constructor and a an argument with the correct kinds
09:51:57 * hackagebot ghc-vis 0.7 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7 (DennisFelsing)
09:52:11 <k0ral> c_wraith: well, I expected the "with the correct kinds" part to narrow the possibilities
09:52:25 <geekosaur> nope
09:52:34 <geekosaur> they're applied only *after* an instance is selected
09:52:37 <Hello_> cmccann: yes that's right
09:52:44 <k0ral> I don't care where is MyMonad in the stack, as long as it is there
09:53:54 <cmccann> Hello_: so while it'd be nice to have something like that written in haskell, nobody so far has wanted it badly enough to put in the effort to make it happen
09:54:11 <elliott> k0ral: btw, "kind" has a technical meaning that isn't what you meant there... just helping avoid confusion
09:54:50 <k0ral> geekosaur: why is that aaplied only after ? is there a way to achieve what I mean, that is: any stack of monad transformers built on top of MyMonad should also be an instance of MyMonad ?
09:54:59 <k0ral> s/aaplied/applied
09:55:42 <Hello_> cmccann: ok! then I'll try something for geometric computing.
09:56:08 <elliott> k0ral: this is a deliberate design decision in the typeclass system related to subtle things like the open world assumption
09:56:14 <elliott> the closest you can do is write a wrapper type
09:56:21 <ab9rf> what is geometric computing?
09:56:37 <elliott> like newtype MyTrans t m a = MyTrans (t m a); instance (MonadTrans t, Monad m, MyMonad m) => MyMonad (MyTrans t m) where ...
09:56:43 <Eduard_Munteanu> Computational geometry, rather, I think.
09:57:03 <ab9rf> Eduard_Munteanu: oh, i've done that.  not since 1991, though :)
09:57:28 <capisce> Eduard_Munteanu: CSG for 3D rendering?
09:57:28 <hiptobecubic> I didn't realize there was so much that I don't know about computational geometry
09:57:33 <hiptobecubic> http://www.cgal.org/Manual/latest/doc_html/cgal_manual/packages.html
09:57:36 <ab9rf> i was a RA on a computational geometry project two decades ago :)
09:57:39 <Eduard_Munteanu> Dunno, ask Hello_ :)
09:57:57 <Hello_> yeah CGAL is very HUGE library
09:58:10 <ab9rf> i mostly worked on visualization software (on HP-UX 8.3) and on writing a parser that we used for our DSL.
09:58:30 <capisce> Hello_: but how much smaller could it be in Haskell? ;)
09:58:40 <k0ral> elliott: that would have me wrap every transformer stack with MyTrans, just to have the instance work ?
09:59:14 <k0ral> I can't say I'm delighted with the idea of wrapping everything
09:59:36 <Hello_> capisce: I don't know yet. I'm newbie of haskell, about 2 weeks?
09:59:43 <ab9rf> i don't see any reason why you couldn't use a functional language for computational geometry, but many of the established algorithms rely on mutable arrays and would not translate well to functional approaches without reconceptualization
10:00:19 <ab9rf> it would probablybe easier to FFI-wrap the established algorithsm
10:00:28 <elliott> k0ral: yes, the real solution is to not make an instance like this.
10:00:30 <Hello_> ab9rf: yes that's why i'm stucked
10:00:48 <elliott> ab9rf: Hello_: well, ST could be useful
10:00:58 <byorgey> Haskell can use mutable arrays just fine.
10:01:00 <elliott> you don't necessarily have to reinvent algorithms that use mutable state to use them purely functionally
10:01:11 <k0ral> also, "instance (...) => Typeclass Type" seems a very poor syntax choice for something that works the other way around
10:01:17 <hiptobecubic> why not just wrap the C++ calls and assume they are pure then?
10:01:29 <hiptobecubic> if you are just directly going to port array operations into ST
10:01:39 <elliott> hiptobecubic: sure
10:01:42 <elliott> depends on what you want to do
10:02:08 <k0ral> if you tell me that actually, the "Typeclass Type" part is matched before applying the left part "(...)"
10:03:19 <Hello_> anyway, I just want to write purely functional things like Purely Functional Mesh Data Structure, but my brain is stucked with imperative
10:03:25 <ab9rf> byorgey: yeah, but for a haskell newbie to dive directly into haskell's mutable array primitives might not be the best learning experience
10:03:37 <k0ral> elliott: the thing is: I'm using various transformers stack along my code, that all include MyMonad, and I expected Haskell provided something to avoid declaring an instance for each
10:04:06 <aCube> k0ral: just use lift ?
10:05:18 <Hello_> ab9rf: I agree
10:05:23 <k0ral> aCube: I don't want to write lift's everywhere, or have to compute the exact number of lift's I need each time; wouldn't that defeat one of the advantages of mtl over transformers ?
10:06:14 <k0ral> I see the mtl had to declare an instance for each single stackable transformer
10:06:45 <Hello_> elliott: ST means State?
10:06:47 <Eduard_Munteanu> k0ral: you can do that too
10:06:51 <simpson> k0ral: Yes; that was the cost to pay for getting its functionality to be so convenient.
10:06:51 <k0ral> MonadReader r m => MonadReader r (MaybeT m), MonadReader r m => MonadReader r (ListT m), and so on
10:06:58 * hackagebot dbmigrations 0.6 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.6 (JonathanDaugherty)
10:07:00 <ab9rf> Hello_: on the other hand, reexpressing the algorithms functionally might help you understand the algorithms better as well as help you lern haskell :)
10:07:03 <elliott> Hello_: no, means ST
10:07:04 <simpson> k0ral: Being able to `get` and `modify` on all MonadStates is worth it. :3
10:07:12 <elliott> k0ral: it doesn't
10:07:20 <ab9rf> Hello_: they probably won't be as efficient, but "code first, optimize later" applies to haskell too
10:07:27 <elliott> re: "I expected Haskell provided something ..."
10:07:54 <k0ral> elliott: all right then, I'll live with that :)
10:08:05 <Hello_> ab9rf: ok!
10:08:15 <elliott> k0ral: you could use a generics mechanism such as template haskell, though
10:08:18 <elliott> (or maybe even GHC's generics?)
10:08:22 <elliott> to automatically derive tedious instances
10:08:23 <Hello_> elliott: http://www.haskell.org/haskellwiki/Monad/ST ?
10:08:57 <elliott> Hello_: yep, there's only one ST (though I can't vouch for the quality of the explanation on that page)
10:09:02 <ab9rf> Hello_: you may benefit from digging up the papers where the algorithms are explained, often the papers explicate a functional expression first, then explain why it was written as it was to gain efficiency.
10:09:04 <k0ral> are there discussions among the Haskell gurus to improve that particular "feature" ?
10:09:13 <fruitFly> develop haskell online.. recommendations?
10:10:07 <parcs> what does that mean
10:10:07 <ab9rf> at least, i discovered that to be the case for the Bowyer-Watson algorithm for Voronoi diagrams.
10:10:08 <Hello_> elliott: ok i'll digging it
10:10:21 <aCube> k0ral: there are alternative implementations providing some sort of monad transforms that try to be more composable
10:10:27 <tromp> with GeneralizedNewtypeDeriving you can do things like deriving (Functor, Applicative, Monad, MonadPlus, MonadRandom, MonadState Int, MonadReader (Int,Int))
10:11:01 <tromp> and avoid explicit lifting
10:11:14 <elliott> k0ral: well, you can already automate this stuff
10:11:25 <elliott> and it only comes up when defining large boilerplatey typeclass hierarchies, which is generally only in libraries most people don't write
10:11:31 <tromp> (I "lifted" that line from http://byorgey.wordpress.com/2013/04/25/random-binary-trees-with-a-size-limited-critical-boltzmann-sampler-2/)
10:11:59 * hackagebot handa-gdata 0.6.1 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.1 (BrianBush)
10:12:14 <k0ral> aCube: any link/document about this ?
10:12:36 <aCube> http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice contains a list
10:13:11 <Hello_> ab9rf: yeah, i collected lots of papers, books. but there is so few things related on computational geometry. There is an attempt to write CGAL like library (http://dinkla.net/en/programming/haskell-cglib.html) but the paper is written in german
10:13:55 <Hello_> ab9rf: so i'm reading codes only
10:22:19 <osa1> haskell-src-exts has thousands of lines of boilerplate, is there a way to eliminate them? can template-haskell or other metaprogramming tools can help for this kind of situation? (for example, this file: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/src/Language-Haskell-Exts-Annotated-Syntax.html has 1kloc of boilerplate)
10:24:51 <klrr> what's Data.Map?
10:24:57 <klrr> can it be used for state?
10:25:01 <klrr> in a programming language
10:25:04 <Eduard_Munteanu> State?
10:25:09 <klrr> *when making a language
10:25:16 <klrr> Eduard_Munteanu: im writing a lisp
10:25:30 <Eduard_Munteanu> You want to map variables to values?
10:25:38 <Eduard_Munteanu> That works, yeah.
10:25:51 <klrr> no i just saw it in a implementation of lisp, didnt know what it was
10:26:40 <Eduard_Munteanu> Not sure what you mean then.
10:26:46 <monochrom> Data.Map is a key-value store. assumes key has Ord.
10:27:09 <klrr> monochrom: what does that mean? is it like a list of pairs? [(a,b)]
10:27:29 <FireFly> Right, but more efficient to look things up in
10:27:31 <Mortchek> Yeah, that'd be one way to implement it.
10:27:34 <Eduard_Munteanu> klrr: it is an efficient implementation of   Ord a => [(a, b)]
10:27:39 <monochrom> should I answer yes? I don't know what "like" means.
10:27:50 <klrr> okey
10:27:56 <klrr> is strings of typeclass Ord?
10:27:57 <Mortchek> But Haskell's Map is more efficient than that, which is why it needs Ord.
10:28:09 <monochrom> perhaps I should answer no. generally "no" to all "x like y" questions.
10:28:26 <Eduard_Munteanu> klrr: yes, you can use strings as keys.
10:28:33 <klrr> okey
10:28:42 <Taneb> klrr: there is an Ord instance for strings
10:28:42 <lambdabot> Taneb: You have 1 new message. '/msg lambdabot @messages' to read it.
10:28:47 <klrr> what is the diff between using simply a list of pairs and Data.Map?
10:29:02 <klrr> Taneb: okey thanks, i dont know all the terms yet :)
10:29:05 <monochrom> linear search vs logarithmic search
10:29:06 <Eduard_Munteanu> Data.Map is a tree amenable to O(log n) lookups and such.
10:29:29 <elliott> klrr: for a start, [('a',1),('b',2)] is not equal to [('b',2),('a',1)]
10:29:36 <elliott> but the two corresponding Maps are
10:29:54 <elliott> anyway, it is simple as: Map k v maps a finite set of "k"s to corresponding "v"s
10:30:06 <klrr> hmm okey
10:30:07 <klrr> so
10:30:12 <elliott> you can also use [(k,v)] for this purpose, but Map is the abstracted form
10:30:16 <elliott> (and more efficient to boot)
10:30:53 <klrr> this "type Env = [Map.Map String Val]" is this "type Env = [(String, Val)]" except that Map.Map is more efficient?
10:30:56 <elliott> if you have used languages with hashtables or dictionaries or whatever, it is like an immutable version of one of those. (different structure and implementation, but same use)
10:31:10 <Eduard_Munteanu> klrr: no
10:31:13 <elliott> klrr: if anything it would be [[(String, Val)]]
10:31:19 <elliott> but again, ordering information is dropped, etc.
10:31:26 <klrr> okey
10:32:25 <monochrom> I am not sure why I can't just say "dictionary" and you just accept it. it's basic CS.
10:32:57 <monochrom> Map.Map String Val is one dictionary. [Map.Map String Val] is a stack of dictionaries. stack as in stack frames.
10:33:18 <klrr> monochrom: okey now i get it :D
10:33:36 <klrr> so as elliott said it's kinda like [[(a,b)]] 'ish
10:33:38 <klrr> ?
10:33:49 <ab9rf> monochrom: not that many programmers understand basic computer science
10:33:52 <Peaker> elliott, ordering&uniqueness
10:33:57 <Eduard_Munteanu> Clearly Map k a isn't like (k, a).
10:34:15 <Eduard_Munteanu> Adding lists to that doesn't change it.
10:34:20 <klrr> also, im not a programmer im new to programming :D and i wont study computers science till im over 18 and that's far away :/
10:34:27 <monochrom> that's what I don't want to get into. how about I say no. whenever x!=y, "x is kinda like y" is false.
10:34:41 <Eduard_Munteanu> klrr: nice, it's good to start early :)
10:34:44 <Taneb> monochrom: I kinda like Haskell
10:34:45 <Mortchek> klrr, why not? You can study CS anytime you want.
10:34:49 <elliott> you can learn about computer science whenever you like :)
10:35:01 <ab9rf> klrr: why wait until you're 18?
10:35:21 <ab9rf> my daughter is 9 and she's studying it (albeit not very formally)
10:35:26 <monochrom> ok, "dictionary" is a CS term here but it is close enough to the English term.
10:35:37 <Eduard_Munteanu> Nice, ab9rf.
10:35:54 <Eduard_Munteanu> I remember clumsily poking at QBasic when I was 6 or so.
10:36:13 <parcs> because primary school doesn't teach autodidacticism
10:36:19 <Taneb> Also vanilla ice cream
10:36:20 <Taneb> But that's off-topic :P
10:36:22 <elliott> perhaps we should define Map simply in terms of the basic functions it offers and equalities about them
10:36:33 <klrr> ab9rf: Mortchek okey, is there any books you recommend? :) ive already wished "SICP" and "Introduction to Algorithms
10:36:36 <klrr> "
10:36:40 <Mortchek> Wished?
10:36:45 <Mortchek> You can read SICP online.
10:36:46 <klrr> for b-day present
10:36:51 <Eduard_Munteanu> Heh.
10:36:54 <klrr> i know but i like real copy :P
10:37:07 <monochrom> "Introductin to Algorithms" definitely tells you all about dictionary
10:37:08 <LudvikGalois> SICP is *really* good; it taught me how to program
10:37:22 <parcs> go to your local public library
10:37:43 <Eduard_Munteanu> Hopefully, the math doesn't scare you into dropping this.
10:37:46 <klrr> ive tried read it once but i kinda got stuck since i didnt understand the math i was supposed to implement, but im starting new school after summer which is more math-oriented
10:37:50 <monochrom> but SICP is only going to tell me more about lists and how everything else "is like list".
10:37:55 <monochrom> s/me/you/
10:38:08 <Mortchek> klrr, do you know algebra?
10:38:20 <klrr> Mortchek: only the very basics
10:38:42 <Mortchek> Basics are enough for many things, but a decent grasp on algebra is pretty helpful I'd say
10:38:44 <klrr> im in sweden so we dont really learn advanced stuff here, it's a socialistic anti-intelectual country
10:38:50 <Eduard_Munteanu> You can look up stuff online, perhaps ask for pointers.
10:39:00 <parcs> hmmm
10:39:03 <klrr> i got a more advanced math exercises from the school im starting soon in
10:39:14 <klrr> which is mostly algebra stuff
10:39:16 <geekosaur> wut
10:40:15 <mapreduce> klrr: More advanced maths will likely help you as a programmer.
10:40:28 <klrr> we dont even learn the diff between real, natural, integers etc. in school here :/ but i hope learn more soon
10:40:34 <ab9rf> klrr: i haven't used a book to learn anything about computers in at least a decade.
10:40:41 <Eduard_Munteanu> YMMV... quite a bit of programming involves just a tad bit of math.
10:40:53 <ab9rf> i'm trying to convince my daughter to learn algebra
10:41:01 <klrr> i like math though, well not repeating simple exercises but problem solving and learning new concepts
10:41:42 <LudvikGalois> when you people talk about algebra do you mean things like groups and rings or something else?
10:42:01 <farun> I kinda like solving math problems myself, sadly I don't know much about the basics...
10:42:03 <monochrom> depends on context
10:42:49 <Mortchek> I'm talking about what they call algebra that they teach you in school, normally taught in high school at least around here
10:43:04 <Mortchek> Equational reasoning and what comes with it
10:43:12 <klrr> (reading the exercises i got from the new school when i realize i havent learned anything about this :( , starting thinking of becoming a terrorist attacking the swedish government :) )
10:43:16 <monochrom> in one context, I mean substitution and unification. and that context is: "prerequisite for Haskell: algebra skills"
10:43:33 <hpaste> wole pasted ‚Äúusing an expensive list twice in a list comprehension‚Äù at http://hpaste.org/86764
10:44:07 <monochrom> unification is NP-hard for computers. this is why many humans fail at it.
10:44:12 <dmj> I think this is more considered to be abstract algebra
10:44:55 <dmj> http://en.wikipedia.org/wiki/Abstract_algebra
10:45:36 <monochrom> but in another context, I mean rings and fields etc. that context usually has the word "free".
10:45:39 <klrr> me gonna go through khan academy this summer and program my ass off
10:47:26 <Eduard_Munteanu> The downside to learning all this stuff early is school gets really boring, if you're going to do the same stuff. ;)
10:48:08 <Eduard_Munteanu> Though you get to be the popular kid when exams approach. :)
10:48:22 <parcs> and you become unsociable as your social skills start fading away
10:48:25 <Eduard_Munteanu> (unfortunately that tends to be only when exams approach :P)
10:48:28 <dmj> parcs: truth
10:49:07 <klrr> Eduard_Munteanu: school is already boring :/ and im not gonna study CS i think
10:49:11 <klrr> now food bbl
10:49:46 <parcs> klrr: whatever you do, don't neglect your social life! it's way  more important than you think
10:50:14 <parcs> especilaly the younger you are
10:51:33 <osa1> how does DeriveFunctor work? if I have `data SomeData a b = SomeData a b deriving Functor` which part fmap maps to?
10:51:47 <wole> @hoogle [a] -> [(a,a)]
10:51:47 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
10:51:47 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
10:51:47 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
10:51:52 <Eduard_Munteanu> Yeah, I guess that's tougher to "study" from a book.
10:52:15 <ab9rf> reminds me
10:52:27 <ab9rf> i am looking for resources for teaching elementary group theory to a ten year old
10:52:34 <ab9rf> suggestions welcome
10:52:46 <Taneb> osa1: only the b
10:52:55 <Taneb> Otherwise it doesn't fit into the Functor class
10:53:12 <Eduard_Munteanu> ab9rf: is that studied in highschool where you live?
10:53:21 <Taneb> It makes instance "Functor (SomeData a) where fmap :: SomeData a b -> SomeData a c"
10:53:39 <osa1> Taneb: aha, right. thanks.
10:53:40 <ab9rf> Eduard_Munteanu: i don't know, i haven't had any contact with the high school district yet
10:53:44 <Taneb> Anything else is either a kind error or a type error
10:53:45 <EvanR> i am perplexed, i remember using direct-fastcgi with no problems, but now i find that i cant figure out what port my haskell fcgi program is listening on, and theres seems to be no way to configure it? i even read the source
10:53:47 <applicative_test> ab9rf: haha, I had the same thought on my mind last month, they were learning about various kinds of 'symmetries'
10:53:55 <ab9rf> Eduard_Munteanu: i am reaching out to my old high school, i if i can figure out how to do so
10:54:02 <ab9rf> Eduard_Munteanu: it was taught at my high school
10:54:27 <Eduard_Munteanu> Here too. Basic stuff about monoids, groups, rings, vector spaces...
10:54:50 <ab9rf> Eduard_Munteanu: we didn't learn monoids, but we did learn groups, rings, fields, and a few other things
10:54:54 * applicative_test read about them at the library
10:54:54 <gspr> klrr: Although I agree that the Scandinavian school system leaves something to be desired (I went through it myself), I think your earlier comment is way out of line.
10:54:58 <ab9rf> i think semigroups
10:55:09 <EvanR> is there some default port for fcgi programs? i feel surprisingly stupid here
10:55:25 <Michael__> What do you guys think about putting on an online 48h haskell hackathon, similar to Node Knockout/ Rails Rumble
10:55:27 <gspr> EvanR: Don't they use unix sockets by default?
10:55:35 <ab9rf> Eduard_Munteanu: i'm trying to get a copy of he packet that we used in my sophomore algebra class, i think that would work with her
10:55:51 <EvanR> gspr: didnt think so
10:56:04 <EvanR> even so theres no configuration on the haskell side
10:56:49 <applicative_test> Michael__: there was a similar sort of even, I dimly remember.  It was somewhat restricted by size since it was using some google system
10:56:57 <applicative_test> sort of event
10:57:06 <Michael__> applicative_test: How succesful was it?
10:57:35 <gspr> EvanR: Ah no, I'm mistaken then
10:57:38 <applicative_test> that's what I'm wondering, I'm trying to remember who organized it, just a sec, I will use my dubious powers of search
10:58:55 <applicative_test> Michael__: heres the initial announcent http://www.reddit.com/r/haskell/comments/khvrz/virtuahac_an_online_haskell_hacathon_poll_for/
10:59:55 <applicative_test> Michael__: oh, and the wiki page http://www.haskell.org/haskellwiki/VirtuaHac
11:00:49 <EvanR> i also remember direct-fastcgi being a lot more established, now it seems like no one has worked on it, theres no website for it, and the body of code is barely existing, one source file
11:00:51 <Michael__> applicative_test: I'm thinking the standard competition, with finished product at the end might not work out, as Haskell is less conducive to those quick oneoff hacks
11:00:58 <EvanR> do i have the right library
11:01:51 <applicative_test> Michael__: Oh I see, a rather different structure then.
11:02:16 <applicative_test> Michael__: I don't have any wisdom to contribute, but wondered if eg cdsmithus did, now I"m not sure
11:02:38 <klrr> gspr: well, when gymnasiet comes it gets more serious i guess :) sry that i got aggressive we only have one anti-intellectual party in sweden and they're not in charge atm
11:03:35 <applicative_test> oh wait, Michael__ I misunderstood your remark out 'standard competetion'
11:04:24 <Michael__> applicative: I haven't really thought this through much, just tossing the idea around
11:17:25 <Jaxan> I'm trying to build the haskell bindings for llvm on my mac. But I get a build error saying "could not find LLVM C bindings". I found an old thread saying that I should build llvm with UNIVERSAL=1. Is this still the case?
11:17:31 <Jaxan> or are there other workarounds?
11:34:11 <MichaelA_> Hey, I've got a question on functions as monads. I get that the list monad models non-determinism, the IO monad models IO etc. I just don't get what the function monad does. I understand the output of the bind operation of functions, I'm just not sure what it *means* semantically. Anyone feel like explaining?
11:34:42 <ab9rf> the function monad?
11:34:59 <cmccann> aka Reader
11:35:02 <ab9rf> ah
11:35:06 <MichaelA_> (->) when used as a monad. I get what it does as a functor and applicative, just not sure what it means as a monad.
11:35:12 <Taneb> MichaelA_: try thinking of it as the Reader monad and check out Control.Monad.Reader
11:35:25 <MichaelA_> Righto. Thanks.
11:35:26 <cmccann> Michael__: same thing it means as an Applicative
11:35:51 <ab9rf> yeah, its meaning doesn't change :)
11:37:16 <byorgey> values of type  (->) e a  can be thought of as computations which result in a value of type a, and have access to a read-only environment of type e.
11:40:43 <cmccann> you can also think of (->) e a as an implicit container holding values of type a, indexed by keys of type e
11:41:11 <MichaelA_> Read up on reader monad like some people sugested. I think I kinda get what it does. Does anyone have a real world example of using this because I really have no idea what it's good for. I mean it kinda looks like a dictionary to me
11:43:12 <Iceland_jack> MichaelA_: Imagine a compiler that needs to have access to top-level function names, you could pass every function using those function names an environmen/context as an argument or you can use a reader monad
11:43:12 <cmccann> Michael__: anything where you want to have some value available in a bunch of places without manually threading extra arguments through a whole pile of intermediate functions
11:43:30 <cmccann> stuff like global configuration or static resources loaded from disk are common
11:43:49 <Cale> MichaelA_: It can be useful when implementing a lambda calculus interpreter for local bindings. It's good when you have something like stateful computation, but where you always want to "clean up" any changes made to the state after their temporary use.
11:43:50 <MichaelA_> Right. I guess this could also be used for enviroment variables?
11:44:32 <Cale> I don't personally find it better than straight parameter passing for configurations, but yes, it can be used for that.
11:45:52 <MichaelA_> So super powerful global dictionary. Think I got it.
11:46:01 <MichaelA_> Thanks!
11:47:18 <ab9rf> good for implementing the global variable antipattern :)
11:48:16 <ab9rf> there is a risk for things like that to become a God Object
11:48:37 <cmccann> ab9rf: yes, ReaderT BunchaIOVarsInnaRecord IO is the global variable monad
11:49:30 <ab9rf> cmccann: heh
11:53:02 <monochrom> BunchaIOVarsInnaRecord is why camel case is wrong. what is "inna"?
11:53:56 <cmccann> monochrom: it's kinda like http://wiki.lspace.org/mediawiki/index.php/Sausage_inna_bun
11:56:07 <ab9rf> "inna" is a perfectly good word
11:56:34 <cmccann> as good as "buncha", certainly.
11:56:35 <applicative_tmp> lispy: is this stuff dons is saying about the SO post true?
11:58:57 <applicative_tmp> meaning , http://stackoverflow.com/questions/16248600/parallel-computations-with-fast-randomness-and-purity
11:59:33 <tgeeky> applicative_tmp: dons never lies! He has spent some time in Australia, so his answers might be upside down, but lies? No way!
12:01:52 <applicative_tmp> tgeeky: I wasn't thinking he was lying; the other people seem to be interpreting the question differently
12:02:29 <applicative_tmp> in other words, I was wondering if he was in the antipodes on the matter...
12:03:24 <EvanR> i suppose i came to this conclusion in the past a forgot. direct-fastcgi, while working code, is incomplete particularly in the area of providing the main accept loop with a socket to listen on
12:03:33 <EvanR> and i guess i got it to work before by editing the code
12:03:37 <applicative_tmp> lispy: I suppose the answer isn't clear yet...
12:07:03 * hackagebot ghc-vis 0.7.0.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.0.1 (DennisFelsing)
12:07:05 * hackagebot base58address 0.4 - Parsing and serialization for Base58 addresses (Bitcoin and Ripple)  http://hackage.haskell.org/package/base58address-0.4 (StephenWeber)
12:08:42 <farun> Can someone here explain to me why & how exactly this works? http://pastebin.com/09aaXMRg I don't really get the minuscol function. It imports Picture.hs which can be seen here: http://pastebin.com/Gnf15wrG
12:11:04 <hpc> i don't even see how it works
12:11:16 <hpc> the tabs look like they break the code
12:12:51 <farun> might be just my fault with wrongly formating it. The code works
12:15:52 <hpaste> ‚Äúnot - applicative‚Äù pasted ‚Äúpicture.hs‚Äù at http://hpaste.org/86767
12:16:19 <applicative_tmp> here is farun's code the mystery is supposed to be 'minus' ?
12:17:19 <farun> more specifically minuscol, as I'm aware what minusline does.
12:20:32 <klrr> good night haskellers
12:22:12 <mitchell> Hi, bit confused on how "do" works in haskell
12:23:30 <applicative_tmp> farun, I see, it makes a negative image on one band in the middle of a bunch of rows of positive images
12:23:41 <EvanR> mitchell: do is syntactic sugar for >> and >>= operators
12:23:45 <Taneb> mitchell: it's syntax sugar. "foo <- bar" becomes "bar >>= \foo -> "
12:23:57 <byorgey> mitchell: do you understand how to write monadic expressions using  (>>=) and (>>) and return?
12:24:04 <applicative_tmp> mitchell, you've come to the right place, intimate knowledge of do is all around
12:24:34 <mitchell> I am pretty new to haskell, byorgey no i don't =(
12:24:35 <applicative_tmp> byorgey: maybe before we ask that we should ask if he is just trying to do some simple io
12:24:37 <mitchell> i will look that up
12:24:57 <mitchell> It is a homework assignment
12:25:01 <EvanR> > Nothing >> Just 9
12:25:01 <applicative_tmp> if so, the desugaring might actually force us to commit the monad tutorial fallacy
12:25:03 <lambdabot>   Nothing
12:25:03 <ab9rf> it always is :)
12:25:15 * ab9rf throws a burrito at applicative_tmp 
12:25:18 <mitchell> ill paste the code i am trying to understand
12:25:24 <farun> applicative_tmp: Exactly, and I kinda don't get how exactly it does that.
12:25:24 <ab9rf> mitchell: not in channel please
12:25:32 <arkeet> @where hpaste -- paste here
12:25:32 <lambdabot> http://hpaste.org/
12:25:43 <Taneb> Man, I wish I got Haskell homework
12:25:48 * tgeeky intercepts the burrito mid air and eats it, dooming any analogies
12:26:12 <applicative_tmp> I could totally haskell homework!
12:26:17 <applicative_tmp> totally ace it!
12:26:17 <hpaste> mitchel pasted ‚Äúcode‚Äù at http://hpaste.org/86768
12:26:21 <ab9rf> it's clear that any haskell conference ought to feature snack burritos
12:26:36 <applicative_tmp> oooh stylin' mitchell , parsers
12:26:42 <mitchell> lol yeah
12:26:46 <mitchell> for that language "tiny"
12:26:58 <mitchell> oh there is a parsing module
12:27:02 <mitchell> written for us
12:27:08 <ab9rf> ooh parsec
12:27:16 <ion> applicative: I like how you verbed Haskell.
12:27:21 <applicative_tmp> mitchell: the 'do' on line 4 is pointless
12:27:44 <ab9rf> which hlint nicely pointed out for you
12:27:45 <mitchell> really?
12:27:46 <applicative_tmp> where are you studying mitchell ?
12:27:54 <mitchell> waikato university in nz
12:27:56 <arkeet> do x  is the same as  x
12:28:01 <applicative_tmp> oh indeed as ab9rf says
12:28:11 <applicative_tmp> ah, nice
12:28:12 <arkeet> > do 5
12:28:14 <lambdabot>   5
12:28:28 <arkeet> > do ("not a monad",3)
12:28:30 <lambdabot>   ("not a monad",3)
12:28:32 <arkeet> interesting.
12:28:36 <mitchell> so we have to write term
12:28:37 <applicative_tmp> mitchell: but what are you thinking is wrong with this
12:28:52 <mitchell> I am not sure, just trying to understand the code atm
12:28:54 <Taneb> arkeet: that... was a monad
12:29:00 <arkeet> oops
12:29:03 <arkeet> > do '1'
12:29:04 <lambdabot>   '1'
12:29:14 <Taneb> > do {'1'; '2'}
12:29:16 <lambdabot>   Couldn't match expected type `m0 a0'
12:29:17 <lambdabot>              with actual type `GHC.Typ...
12:29:31 <hpc> do do that voodoo that you do so well
12:29:49 <Taneb> arkeet: it's a consequence of it desugaring to valid code
12:29:57 <arkeet> of course.
12:29:58 <ion> > do do do do do do do do do do do do do do do do batman
12:30:00 <lambdabot>   batman
12:30:02 <arkeet> :)
12:30:03 <ab9rf> hahah
12:30:07 <arkeet> :t batman
12:30:08 <lambdabot>     Not in scope: `batman'
12:30:08 <lambdabot>     Perhaps you meant `atan' (imported from Prelude)
12:30:13 <arkeet> uhm
12:30:21 <ab9rf> > batman
12:30:23 <lambdabot>   Not in scope: `batman'
12:30:23 <lambdabot>  Perhaps you meant `atan' (imported from Prelude)
12:30:30 <Taneb> > do batman
12:30:32 <lambdabot>   Not in scope: `batman'
12:30:33 <lambdabot>  Perhaps you meant `atan' (imported from Prelude)
12:30:37 <mitchell> btw Parser is type Parser a -> String -> [(a, String)]
12:30:39 <arkeet> ion, you're so ion.
12:30:43 <hpc> watman
12:30:47 <mitchell> but i think they did it with a monad or something
12:30:52 <mitchell> i don't know what a monad is lol
12:30:56 <arkeet> mitchell: it's probably a newtype or something.
12:30:58 <EvanR> what is a monad really
12:31:00 <ab9rf> haha
12:31:06 <ab9rf> DON'T ASK THAT QUESTION
12:31:09 <Taneb> mitchell: the best thing about monads, is that they aren't
12:31:10 <ab9rf> OR BURRITOS WILL HAPPEN
12:31:15 <hpc> what is a burrito, really?
12:31:16 <arkeet> mitchell: anyway, a monad is just an instance of the Monad class.
12:31:19 <EvanR> monads arent monads
12:31:20 <arkeet> which has operations like return and (>>=)
12:31:23 <EvanR> spoiler
12:31:36 <ion> I only know what a monad is when not laughing out loud.
12:31:42 <mitchell> lol
12:31:48 <mitchell> i sort of understand do
12:31:49 <hpc> monads are just a category in the 2-category of categories
12:31:51 <mitchell> so for example..
12:31:54 <hpaste> ‚Äúnot - applicative‚Äù annotated ‚Äúcode‚Äù with ‚Äúcode (annotation)‚Äù at http://hpaste.org/86768#a86769
12:31:54 <mitchell> you could do this..
12:32:00 * ab9rf throws a burrito at hpc
12:32:05 <EvanR> haha
12:32:17 <mitchell> do x <- readline
12:32:19 <applicative_tmp> mitchell: is something like this more intelligible looking ^^^
12:32:23 <mitchell> print x
12:32:24 <mitchell> or something
12:32:30 * tgeeky silently replaces all burritos with choco tacos, to everyone's enjoyment
12:32:30 <mitchell> wrong syntax
12:32:34 <EvanR> readline >>= print
12:32:42 <ab9rf> ooh, chocotacos
12:32:57 <applicative_tmp> in the context of parsing maybe you could say that 'do' means something like 'recognize' or 'recognize the following'
12:33:14 <applicative_tmp> thats a little inept
12:33:31 <mitchell> do you want to see the parsing module?
12:33:33 <mitchell> ill paste it
12:33:48 <EvanR> forever (read >>= eval >>= print)
12:34:01 <hpaste> mitchel pasted ‚Äúcode‚Äù at http://hpaste.org/86770
12:34:02 <hpaste> arkeet annotated ‚Äúcode‚Äù with ‚Äúcode (desugared)‚Äù at http://hpaste.org/86768#a86771
12:34:04 <tgeeky> Is that like a giant karoake machine? Not really; would you like to see your giant karoake machine? Not really.
12:34:22 <applicative_tmp> the parser must find what accords with each line, you bind to some of them to keep what was recognized for various purposes, the rest must be there but is not relevant to the final result
12:34:23 <arkeet> so when you write   do { x <- blah; <...> }
12:34:26 <arkeet> that just gets transformed to
12:34:32 <arkeet> blah >>= \x -> do {<...>}
12:34:37 <tgeeky> mitchell: just so we're clear, syntactic sugar means "a brainless mechanical replacement of symbols that the compiler does, and that always works"
12:34:44 <arkeet> so the question is just what >>= does for Parser
12:34:50 <arkeet> (it's a typeclass method)
12:35:00 <cmccann> as opposed to programming, which is a brainless mechanical creation of symbols that the user does, and that rarely works.
12:35:07 <ab9rf> heh
12:35:10 <mitchell> Yep, our professor uses "syntactic sugar" every few sentences
12:35:23 <ab9rf> syntactic salt is way more fun
12:35:32 <hpc> @quote sugar
12:35:32 <lambdabot> ghc says: Cannot desugar this Template Haskell declaration
12:35:33 <applicative_tmp> mitchell: yes this implements the classical form of a haskell parser type, and associated combinators
12:35:33 <EvanR> syntactic aspartame
12:35:33 <Taneb> syntactic vanilla essence
12:35:34 <cmccann> what about syntactic MSG
12:35:36 <hpc> @quote sugar
12:35:36 <lambdabot> kmc says: Haskell may have syntactic sugar, but C++ has syntactic strychnine
12:35:39 <arkeet> mitchell: so in the context of parsers,
12:35:41 <hpc> heh
12:35:43 <arkeet> say p1 and p2 are parsers.
12:35:48 <EvanR> syntactic syntax
12:36:03 <mitchell> So a parser doesn't always use a tree?
12:36:04 <cmccann> EvanR: sounds like lisp
12:36:06 <arkeet> then p1 >> p2  is the parser that parses p1 followed by p2, returning the result of p2 if it succeeds.
12:36:12 <ab9rf> syntactic strychnine, obviously someone who has done C++ template metaprogramming
12:36:14 <mitchell> that is i guess why it is in form parser a
12:36:18 <mitchell> duhh
12:36:27 <arkeet> more generally,
12:36:30 <arkeet> if p1 :: Parser a
12:36:35 <arkeet> and p2 :: a -> Parser b
12:36:37 <Taneb> I'm not sure that any parse actually uses a tree, it's just a way of representing them
12:36:39 <ab9rf> mitchell: Parser is a monad.  it even says so.
12:36:49 <arkeet> then  p1 >>= p2  is the parser that does the following:
12:36:50 <ab9rf> mitchell: which is why you can use do-syntax with it
12:37:04 <cmccann> assembly is like a huge plate of syntactic steamed broccoli and you have to eat it all or you get sent to bed without dinner. or something.
12:37:05 <arkeet> first parse p1. take its result and feed it as an argument to p2, which returns another parser.
12:37:08 <cmccann> I kinda lost track of where that was going.
12:37:13 <arkeet> then run the second parser, and return its result.
12:37:25 <EvanR> cmccann: that sounds delicious right about now
12:37:33 <mitchell> Pretty much since we haven't been using haskell for long, our professor just showed us a way to implement it without a monad
12:37:42 <arkeet> (oops, when I say return, that has little to do with the "return" function)
12:37:44 <mitchell> and the gave us that parsing module and said don't look at it lol
12:37:53 <applicative_tmp> mitchell: to go with arkeet s example, suppose a text was valid if it started with a numeral, and then had *that many* of something else following.
12:38:09 <mitchell> then*
12:38:29 <ab9rf> cmccann: in that analogy, what is the equivalent of cheese sauce?
12:38:47 <applicative_tmp> then you would have numeral :: Parser Int , and then blipN :: Int -> Parser [Blip} where blip n succeeds if there are 3 blips
12:38:56 <applicative_tmp> blilp 3 rather
12:39:03 <cmccann> ab9rf: just cheese sauce. cheese transcends analogies.
12:39:15 <hpc> i wear the cheese
12:39:17 <hpc> it does not wear me
12:39:29 <arkeet> where did 3 come from?
12:39:52 <cmccann> arkeet: succ 2
12:39:52 <arkeet> ah
12:39:57 <arkeet> blipN 3 succeeds if there are 3 blips.
12:40:01 <mitchell> so can you have nested do statements?
12:40:16 <arkeet> you can, but they don't really do anything.
12:40:21 <applicative_tmp> youi don't need one there, but of course yes
12:40:23 <bobry> Is it possible to use cmm with Cabal?
12:40:30 <arkeet> do { a <- x; do {b <- y; z}} is the same as do {a <- x; b <- y; z}
12:40:43 <bobry> i. e. is there a way to tell Cabal "this is a CMM file, compile it!"
12:40:57 <tgeeky> bobry: not easily. Setup.hs is probably your only option
12:40:58 <mitchell> this language is complicated lol
12:41:04 <arkeet> do { b <- do { a <- x; y }; z} is the same as do {a <- x; b <- y; z}, assuming the monad is lawful
12:41:09 <ab9rf> mitchell: there's usually no point to nesting do constructs
12:41:15 <bobry> tgeeky: is there an example of such setup?
12:41:23 <applicative_tmp> i was picturing validblips :: Parser [Blip}; validblips = do {n <- numeral; blipN n}
12:41:39 <arkeet> which desugars to
12:41:44 <arkeet> numeral >>= \n -> blipN n
12:41:56 <arkeet> numeral >>= (\n -> blipN n)
12:42:00 <dcoutts_> bobry: yes, just list it in c-sources
12:42:04 * hackagebot io-streams 1.0.2.2 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.0.2.2 (GregoryCollins)
12:42:08 <sw2wolf> @ty (*>)
12:42:10 <ab9rf> @undo do { b <- do { a <- x; y }; z}
12:42:10 <lambdabot> Applicative f => f a -> f b -> f b
12:42:10 <lambdabot> x >>= \ a -> y >>= \ b -> z
12:42:13 <applicative_tmp> numeral >>= blipN
12:42:18 <arkeet> sure.
12:42:19 <bobry> dcoutts_: thanks!
12:42:27 <applicative_tmp> oh hi dcoutts_ !
12:43:26 <ab9rf> there's no way to get lambdabot to declare fixity
12:43:31 <ab9rf> is there?
12:43:37 <applicative_tmp> @info (&&)
12:43:37 <lambdabot> (&&)
12:43:41 <applicative_tmp> hm, no
12:43:47 <dcoutts_> applicative_tmp: hello :-)
12:43:48 <Taneb> > (0$0&&)
12:43:50 <lambdabot>   The operator `GHC.Classes.&&' [infixr 3] of a section
12:43:50 <lambdabot>      must have lower ...
12:43:54 <Taneb> applicative_tmp: :)
12:44:00 <arkeet> @let x $%^ y = 3; infixl 2 ($%^)
12:44:00 <lambdabot>   Parse error: (
12:44:07 <arkeet> @let x $%^ y = 3; infixl 2 $%^
12:44:08 <lambdabot>  Defined.
12:44:28 <arkeet> @let x ^%$ y = 3; infixl 9 $%^
12:44:29 <lambdabot>  <local>:1:23:
12:44:29 <lambdabot>      Multiple fixity declarations for `$%^'
12:44:29 <lambdabot>      also at  <loc...
12:44:32 <arkeet> @let x ^%$ y = 3; infixl 9 ^%$
12:44:34 <lambdabot>  Defined.
12:44:37 <Taneb> > 1 $%^ magic
12:44:37 <ab9rf> i meant report on fixity, not actually assign it, sorry :)
12:44:38 <lambdabot>   Not in scope: `magic'
12:44:40 <arkeet> > (x $%^ y + z; x ^%$ y + z)
12:44:42 <lambdabot>   <hint>:1:13: parse error on input `;'
12:44:46 <arkeet> oh
12:44:50 <arkeet> > (x $%^ y + z, x ^%$ y + z)
12:44:51 <lambdabot>   (3,3 + z)
12:45:14 <arkeet> I don't think so.
12:45:21 <arkeet> ghci :info will do it, of course.
12:45:53 <arkeet> ohhhh
12:45:54 <arkeet> Taneb: smart.
12:46:03 <Taneb> I can't remember who showed me that
12:46:15 <Taneb> But it is a useful trick
12:46:20 <arkeet> > (0$0$)
12:46:22 <lambdabot>   The operator `GHC.Base.$' [infixr 0] of a section
12:46:22 <lambdabot>      must have lower prec...
12:46:25 <Taneb> And a trick I cannot claim credit for
12:46:40 <Taneb> > (0$0>>=)
12:46:42 <lambdabot>   The operator `GHC.Base.>>=' [infixl 1] of a section
12:46:43 <lambdabot>      must have lower pr...
12:47:12 <ab9rf> i found what i was looking for :)
12:47:31 <arkeet> :t (0$0$)
12:47:36 <lambdabot>     The operator `$' [infixr 0] of a section
12:47:36 <lambdabot>         must have lower precedence than that of the operand,
12:47:36 <lambdabot>           namely `$' [infixr 0]
12:47:43 <ab9rf> that works because $ has the lowest precedence, eh
12:47:50 <arkeet> yes
12:50:24 <sw2wolf> Is lowest precedence 0 ?
12:50:28 <ab9rf> yes
12:50:32 <ab9rf> 0 to 9
12:50:35 <ab9rf> there can be no others
12:50:42 <sw2wolf> ab9rf: thanks
12:51:07 <Taneb> ab9rf: I thought it went right up to 20
12:51:21 <geekosaur> nope
12:51:30 <ab9rf> Taneb: i might be wrong, but i am fairly certain it tops at 9
12:51:35 <ab9rf> :t (0$0.)
12:51:36 <lambdabot>     The operator `.' [infixr 9] of a section
12:51:37 <lambdabot>         must have lower precedence than that of the operand,
12:51:37 <lambdabot>           namely `$' [infixr 0]
12:51:40 <Taneb> @let f £ x = f x; infixr 10 £
12:51:40 <lambdabot>   Illegal precedence 10
12:51:43 <Taneb> Aaah
12:51:48 <Taneb> I am misinformed
12:54:17 <cmccann> when I create a language, operator fixities will go to 11
12:55:22 <hpc> http://www.imdb.com/title/tt0088258/?ref_=fn_al_tt_1
12:55:34 <hpc> rating: 8.0/11
12:56:01 <Eduard_Munteanu> cmccann: that's like volume pots going from 0 to 11
12:56:56 <cmccann> Eduard_Munteanu: right. I mean, y'know, most only go to 10.
12:57:16 <ijp> how does user specified fixity even work? Does it require a preparsing step to get all the fixity declarations?
12:57:26 <Eduard_Munteanu> cmccann: yes, it's definitely a bonus when you need that extra stomach punching bass
12:57:38 <cmccann> hpc: also that score being out of 11 is great
12:57:38 <hpc> ijp: parsing is already multipass
12:57:40 <hpc> er
12:57:42 <hpc> compilation
12:57:51 <hpc> so one more pass doesn't hurt
12:58:07 <ijp> right, it's just that I naively think of parsing as usually being one pass
12:58:32 <cmccann> ijp: then you really don't want to know how TH is handled :P
12:58:41 <ijp> no I don't :)
12:58:59 <hpc> knowing TH is the reason i don't use it
12:59:04 <ab9rf> heh
13:05:52 <parcs> ijp: i believe it's all done in one pass
13:07:43 <ijp> if fixity declarations have to precede first use, that's probably fine
13:08:02 <ijp> first infix use anyway
13:08:20 <parcs> ijp: it's fine either way
13:08:21 * ijp goes off to check the standard
13:09:12 <geekosaur> pretty sure they don't. the haskell standard requires compilers to be on the knife edge of insanity
13:09:49 <geekosaur> (and has been known to outsmart itself; see haskell98's brace insertion rule)
13:10:05 <ijp> well, assume for the moment that I have a tiny brain. do you parse (a op1 b op2 c) if the declarations you haven't seen the declarations for op1 and op2 yet?
13:10:48 <parcs> ijp: you assume all operators are infixl with equal precedence and then you reassociate them once you know their fixity info
13:10:51 <tgeeky> geekosaur: in haskell's defense, many of the most impactful people in history have been on a knife edge of insanity
13:11:09 <ijp> parcs: right, but that sounds awkward
13:11:25 <ijp> maybe I just need a third brain cell to go with the other two
13:12:17 <geekosaur> it's awkward, at the very least, yes
13:12:26 <parcs> i think it's neat
13:14:52 <bobry> is it possible to call sizeof(some_struct) in C--?
13:16:45 <ab9rf> sizeof isn't a function that you call in C or its variants
13:16:48 <ab9rf> it's a language feature
13:16:48 <parcs> you'll have better luck in #ghc
13:16:57 <parcs> but i don't think cmm understands structs
13:20:00 <ab9rf> it doesn't
13:20:08 <ab9rf> i'm not even sure that C-- has sizeof
13:21:59 <ab9rf> the only mention of sizeof in the C-- specification is at the very end, in some C (not C--) code used as an illustration
13:41:08 <K_> I have the following function: fctn q = if last q >= 40 then q else 0. I can load this function in the interpreter, but it always fails to run properly, anyone know why?
13:41:38 <Taneb> That looks like a type error
13:41:52 <Taneb> "no instance for Num [a]" or something
13:42:05 <K_> well I always plug in a list for the argument q
13:42:14 <geekosaur> yes, so what were you expecting?
13:42:22 <geekosaur> you try to return either a list, or the value 0
13:42:24 <Eduard_Munteanu> K_: q and 0's types must match
13:42:29 <geekosaur> so what is the type?
13:42:33 <K_> well I was trying to get it to spit the list back at me
13:42:41 <monochrom> "if ... then q else 0" is a case of not making up your mind. do you want a list? then 0 is wrong. do you want a number? then q is wrong.
13:42:57 <K_> oh ok
13:42:59 <K_> thanks
13:43:24 <monochrom> all type errors are not making up your mind. also, all logic errors.
13:43:39 <osa1> how can I link to a data type defined in some other package(for example, parsec) in haddock documentation?
13:43:45 <arkeet> one day, we hope to be able to generalize that to "all errors".
13:44:10 <arkeet> osa1: if it's not visible in the html documentation, you might be able to see it in the source
13:44:16 <arkeet> (which is linked)
13:44:38 <arkeet> but if it it's not visible, that means it's not exported.
13:46:30 <osa1> arkeet: I mean, some types are automatically linked in html documentation generated by haddock, but some types are not(like Parsec's SourcePos)
13:46:30 <ab9rf> meow
13:46:34 <ab9rf> eh
13:47:58 <monochrom> you have to give a lengthy flag to haddock to tell it where to link to. in practice no one bothers to figure it out by hand, since "cabal haddock" computes it correctly
13:48:01 <osa1> arkeet: I'm wondering why, and how can I link those types too
13:48:13 <arkeet> can you show what you mean?
13:48:15 <arkeet> a link
13:48:33 <monochrom> or "cabal install --enable-documentation"
13:48:44 <osa1> arkeet: you can build this project: https://github.com/osa1/language-lua/tree/sourcepos and browse documentation
13:49:00 <osa1> arkeet: you'll see that some types are linked but some are not (even though they're in same package)
13:49:08 <osa1> (they're exported by same package *)
13:49:33 <osa1> monochrom: I'm generating documentation with cabal haddock
13:50:04 <monochrom> ok, then perhaps your parsec lacks docs
13:50:29 <osa1> monochrom: if I upload to hackage, will they be linked ?
13:50:42 <monochrom> most likely yes, but I haven't tried
13:51:25 <osa1> ok, I can't try it on my machine because reinstall (with --enable-documentation) will break too many packages
13:51:54 <osa1> monochrom: I want to indicate to reader that the types are related to Parsec or some other package, that's why I want those links
13:52:06 <monochrom> you should rewind the clock back many days, and edit ~/.cabal/config, and rectify wrong defaults there
13:52:41 <osa1> monochrom: what defaults ?
13:52:48 <osa1> ah, documentatioƒ±n
13:52:57 <arkeet> I get a link.
13:53:10 <osa1> arkeet: for SourcePos ?
13:53:26 <monochrom> library-profiling and documentation
13:53:27 <leggo> hello
13:53:30 <arkeet> where is SourcePos?
13:53:37 <Eduard_Munteanu> leggo: hi
13:53:42 <osa1> arkeet: Language.Lua.Parser
13:53:44 <elmore> hi leggo :)
13:54:01 <leggo> what is wrong with myFoldr1? http://hpaste.org/86779
13:54:20 <arkeet> I see no SourcePos.
13:54:29 <monochrom> f is never used.
13:54:40 <osa1> arkeet: are you sure you pulled correct branch ? you should pull sourcepos not master
13:54:44 <arkeet> oh.
13:55:03 <arkeet> yeah, I do.
13:55:16 <monochrom> also the real base case is myFoldr1 _ [x]
13:55:19 <leggo> myFoldr  seems to work by the way
13:55:34 <arkeet> right, so you just need to install parsec with documentation and such.
13:55:40 <osa1> arkeet: ok, thanks
13:55:41 <leggo> how is f never used?
13:55:46 <osa1> I fixed my .cabal defaults
13:55:57 <monochrom> oh, nevermind, you're delegating to myFoldr
13:56:42 <leggo> yes. I probably should have just used foldr in paste since as far as I can see myFoldr1 is correct
13:56:53 <leggo> myFoldr is correct
13:56:55 <monochrom> that is not the problem
13:58:05 <osa1> jobs parameter in cabal config is still not working, right ?
13:58:23 <arkeet> yes it is.
13:58:27 <dcoutts_> osa1: it works in head version, not in release
13:58:32 <monochrom> myFoldr1 (-) [x,y,z] = myFoldr (-) x [y,z] = y-(z-x) is what's wrong
13:58:32 <arkeet> er, ok
13:58:35 <dcoutts_> oh, hmm
13:58:41 <dcoutts_> maybe I'm forgetting
13:58:50 <dcoutts_> osa1: it might work in latest point release
13:58:58 <dcoutts_> but only with latest Cabal lib too
13:59:02 <dcoutts_> iirc
13:59:29 <leggo> ah, instead of x - (y - z)
13:59:52 <armlesshobo> is there an alternative mirror I can download haskell-platform from?
14:00:04 <armlesshobo> it says it's going to take over a day to download...
14:00:19 <ab9rf> armlesshobo: what sort of connection do you have?
14:00:26 <armlesshobo> cable
14:00:40 <armlesshobo> 25/10
14:00:40 <arkeet> the main download goes plenty fast for me
14:00:48 <ab9rf> it wasn't that slow for me
14:00:54 <armlesshobo> for Mac OSX 64bit
14:00:58 <leggo> so foldr1 can't be implemented in terms of foldr without iterating to the last element first?
14:01:04 <armlesshobo> is what I'm downloading
14:01:08 <ab9rf> maybe you need to find all the people in your neighborhood who are torrenting and kill them so you can have their bandwidth
14:01:14 <arkeet> haha
14:02:02 <elmore> i tried that. didn't work... :/
14:02:31 * elmore is writing from prison
14:03:22 <leggo> I got it
14:03:26 <leggo> myFoldr1 f (x:xs) = f x $ myFoldr1 f xs
14:03:57 <nbouscal> prisons will probably get google fiber before i do
14:04:29 <tromp> unless you go to prison...
14:04:42 * nbouscal begins to formulate a plan
14:04:50 <hpaste> ryanakca pasted ‚ÄúNon exaustive pattern‚Äù at http://hpaste.org/86780
14:05:27 <taylorgb> Maybe violating the monadic laws will become a capital crime
14:05:32 <ryanakca> Any suggestions on why I get "[*** Exception: frobenius.hs:(23,1)-(25,17): Non-exhaustive patterns in function dropWhileMany" with the above?
14:06:06 <monochrom> what happens to dropWhileMany f [] ?
14:06:21 <ryanakca> monochrom: Haha, thanks :)
14:07:29 <applicative_tmp> is there some simple way of taking elements from a list as long as they are , e.g. increasing?
14:08:45 <applicative_tmp> ryanakca: you left out a case, there are at least two with lists, [] and (x:xs)
14:08:52 <monochrom> map fst . takeWhile snd . (\xs -> zipWith (<) xs (drop 1 xs))
14:09:06 <monochrom> err, correction
14:09:15 <lispy> applicative_tmp: re: dons comment. I don't know enough about random number generation to know if he's right. I do know that Carl is right about not being able to control threading when you use parMap (that's the point of parMap).
14:09:23 <monochrom> to hard to correct. nevermind.
14:09:38 <applicative_tmp> > let mono =  map fst . takeWhile snd . (\xs -> zipWith (<) xs (drop 1 xs)) in mono ["aa","bb","cc","aa","cc"]
14:09:39 <lambdabot>   Couldn't match expected type `(b0, GHC.Types.Bool)'
14:09:40 <lambdabot>              with actua...
14:09:43 <lispy> applicative_tmp: I don't think this is a simple so-and-so is write/wrong situation. It's kind of blurry.
14:09:54 <lispy> right*
14:10:09 <monochrom> but this is a write-song situation! :)
14:10:13 <applicative_tmp> yeah i figured, but some people had such clear convictions i was puzzled
14:10:47 <monochrom> most people have clear convictions
14:11:09 <lispy> applicative_tmp: I did discover that the async package has a function like parMap that works with IO. I put stToIO in all the right places and tried it but it ran much slower than before :(
14:11:35 <monochrom> only a minority, which knows better, is willing to be unsure. cf Dunning-Kruger
14:12:16 <elliott> monochrom: are you sure about that?
14:12:30 <monochrom> I'm absolutely sure haha
14:13:32 <monochrom> anyway, when a person is so sure, ask him/her for data.
14:14:43 <lispy> monochrom: does that work? Wouldn't the initiated novice have data (that isn't necessarily correct)?
14:15:23 <lispy> It's probably best to simply not talk to other humans.
14:15:29 <lispy> So many misunderstandings could be avoided.
14:16:54 <monochrom> neither dons nor Carl is a novice
14:17:17 <c_wraith> super-secret fact...  Carl is me.  >_>
14:17:41 <c_wraith> I thought for a while before posting that comment. I couldn't see any clean way to solve the problem. Doesn't mean there isn't one.
14:17:45 <c_wraith> Just that I couldn't find it.
14:18:11 <applicative_tmp> oh yr carl?
14:18:19 <lispy> ohai Carl
14:18:25 <ab9rf> the more you know the less likely you are to have 'clear convictions'
14:18:39 <applicative_tmp> can youi figure out dons' coded response?
14:18:52 <c_wraith> The big issue is that the RandomGen class isn't well-suited to parallel use, because it's inherently linear.
14:19:03 <c_wraith> I feel like any good solution won't be able to use the class
14:19:23 <monochrom> ok, when data is presented, you can study it and determine whether it's correct or incorrect. either way you learn more. it is better than seeing no data, not even allegedly data, and getting stuck at "should I believe contradicting authorities"
14:19:25 <lispy> c_wraith: I think you're right.
14:19:40 <lispy> monochrom: +1
14:19:53 * applicative_tmp wonders what he means by a ' a tree-structured reduction'here
14:20:27 <lispy> c_wraith: did you look at the Dr. Dobbs link in my original question at all?
14:20:40 <lispy> c_wraith: they present a parallel prng
14:20:41 <c_wraith> lispy: yeah, but it was beyond me.
14:21:15 <lispy> I didn't study in carefully, but I got the impression it's about making generators that have good subsequence properties.
14:21:24 <c_wraith> lispy: perhaps more interestingly, you could apply concepts from on-disk encryption here.  A tweakable cipher would function as a PRNG in parallel, in this case
14:21:26 <lispy> so that you can split them and join them freely
14:21:26 <applicative_tmp> yeah that was hopeless
14:21:51 <lispy> c_wraith: I'm not familiar with that
14:22:05 <cmccann> are we talking about splitting PRNGs in a well-behaved way? I thought that was basically an open research problem still.
14:22:41 <lispy> cmccann: that might be part of a solution, but it's not required to solve my problem
14:22:53 <lispy> cmccann: http://stackoverflow.com/questions/16248600/parallel-computations-with-fast-randomness-and-purity
14:23:05 <cmccann> ah
14:23:31 <lispy> tl;dr: I'm writing a ray-tracer and randomness makes it impure which bummed me out. I wanted to use parallel to make it, well, parallel.
14:23:37 <c_wraith> lispy: http://en.wikipedia.org/wiki/Block_cipher#Tweakable_block_ciphers
14:24:06 <c_wraith> hmm, not actually much content there
14:24:18 <lispy> c_wraith: I get the 1000ft view though
14:24:27 <Eduard_Munteanu> lispy: why does randomness make it impure?
14:24:30 <c_wraith> I suspect there are no existing haskell implementations of any of them
14:24:43 <Eduard_Munteanu> lispy: do you really need that kind of randomness?
14:25:11 <c_wraith> also, being cryptographic security, it's going to be slow
14:25:29 <c_wraith> at least compared to PRNGs that just target statistical randomness, rather than unpredictability
14:25:31 <lispy> Eduard_Munteanu: Well, I could make an infinite list of randoms and pass it on to the threads. the random package allows for that but it's sloooow
14:26:28 <Eduard_Munteanu> lispy: I mean using some sort of deterministic PRNG... you just want to *look* random (statistically), no?
14:26:30 <lispy> someone suggested a way to get mwc-random to give me an infinite list of randoms but I haven't tried it yet.
14:26:49 <lispy> Eduard_Munteanu: yeah, I don't need good randomness for this.
14:27:09 <lispy> So using the same seed in each thread is not a big deal
14:27:24 <Eduard_Munteanu> I wonder if the list is making it slow.
14:27:58 <Eduard_Munteanu> (Perhaps you could try harder to make it fuse.)
14:28:24 <lispy> Hang on. It depends on what slowness you're referring to.
14:28:34 <lispy> the random package is slow because, well it is.
14:28:52 <lispy> you can see that by comparing it to mwc-random or one of the packages dons wrote.
14:28:59 <Eduard_Munteanu> I see.
14:29:12 <lispy> I also have the problem that using lots of threads slows down my code.
14:29:16 <cmccann> lispy: just use 7. 7 is a pretty random number.
14:29:30 <Chousuke> 83 is randomer!
14:29:55 <Eduard_Munteanu> lispy: are you doing some crazy stuff like 1 thread per ray? :)
14:30:35 <Eduard_Munteanu> Crazily parallel.
14:30:39 <c_wraith> one spark per ray!
14:30:48 <lispy> Eduard_Munteanu: maybe? I was relying on async to give me multiple threads. I can also get the slow down by not using async/parallel but adding +RTS -N
14:30:52 <Eduard_Munteanu> (spray? :P)
14:31:41 <lispy> the code (without parallization or cleanup) is on my github
14:32:00 <lispy> I was going to refactor this weekend but I've been busy with coursera instead.
14:34:29 <applicative_tmp> ha, what are you going to do with 'language fortran' lispy
14:35:50 <lispy> applicative_tmp: I was building that work related stuff
14:36:47 <applicative_tmp> action_6 (26) = happyGoto action_60  -- of course
14:38:07 <lispy> heh, so I merged a lot of that in from someone else...I wonder if he checked in the .hs file by accident. Just need the .y.
14:40:06 <applicative_tmp> yeah, i wondered about that
14:41:06 <applicative_tmp> the parenthesis "but it looks like mersenne-random  is no longer maintained" seems not to have given dons pause....
14:42:08 * hackagebot uuid 1.2.12 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.12 (AntoineLatter)
14:43:31 <oinkon> is darcs still the standard vcs for the haskell programs?
14:43:51 <lispy> oinkon: I think github won
14:43:58 <cmccann> lots of people use git, mostly because of github.
14:44:19 <cmccann> quite a few people using git because of github seem to still prefer darcs otherwise...
14:44:36 <applicative_tmp> oinkon: it's not the standard; plenty of people use it though.
14:44:37 <nbouscal> we should really make darcshub then hey?
14:44:53 <c_wraith> there are already two of them
14:44:53 <stepcut> nbouscal: hub.darcs.net
14:44:58 <c_wraith> Or more
14:45:01 <nbouscal> oh so it's a marketing issue?
14:45:03 <c_wraith> The issue is network effects
14:45:10 <c_wraith> it's most useful to use the thing everyone else is
14:45:11 <cmccann> the problem is not imitating github, it's imitating it to the same quality and polish
14:45:17 <cmccann> plus the network effects on top of that
14:45:19 <applicative_tmp> nbouscal: but thats not how the 'social internet' works.  nothing exists unless it is a monopoly
14:45:28 <Eduard_Munteanu> I use git but do not prefer github :)
14:45:48 <Clint> i prefer git to github
14:46:30 <Eduard_Munteanu> I prefer kernel.org style web git browsers.
14:46:55 <oinkon> i find github to be a confusing mess. huge improvement over sourceforge though
14:47:01 <oinkon> i'm going to start my new project in git i guess. i've long since forgotten how darcs works
14:47:27 <cmccann> for better or worse, git and github is probably the best choice if you want easy collaboration
14:48:01 <elliott> I should use darcs so my projects seem fancier and more elite
14:48:07 <EvanR> lol
14:48:14 <cmccann> elliott: oh, you have projects?
14:48:15 <applicative_tmp> it is insanely convenient for sending patches, crazy really
14:48:24 <elliott> if you have a github repo then how do your users know you aren't letting just anyone commit? see: edwardk
14:48:25 <nbouscal> it does seem like a much better concept theoretically
14:48:33 <elliott> cmccann: :(
14:48:39 <Eduard_Munteanu> Better collaboration: Linus yelling "I'm not pulling this shit!". :P
14:48:56 <elliott> cmccann: I honestly usually just version stuff with cp.
14:49:04 <cmccann> elliott: old-school!
14:49:12 <elliott> that's how useless everything I do is.
14:49:32 <nbouscal> most of my projects i use git and do regular commits but never actually use them in any way
14:49:46 * applicative_tmp uses *.hs.bk.32
14:49:58 <cmccann> applicative_tmp: ooh, fancy
14:50:00 <Eduard_Munteanu> Bitkeeper? oO
14:50:17 <Eduard_Munteanu> Or "backup"? Makes more sense.
14:50:21 <cmccann> applicative_tmp: that has three file extensions, it must be sophisticated
14:50:31 <elliott> applicative_tmp: I turn foo.hs into foo.before-i-messed-it-up.hs
14:50:38 <elliott> or foo.aaargh.hs
14:51:15 <applicative_tmp> cmccann: actually its better if you start backup with *.hs.zzzzz, then the new one is *.hs.zzzz, ...*.hs.z, then hs.yyyyy
14:51:20 <Eduard_Munteanu> Then, in rage, issue rm *.hs.
14:51:25 <monochrom> use VAX VMS. every file is versioned.
14:51:32 <applicative_tmp> gives you a lot of scope for revision :)
14:52:02 <cmccann> elliott: I use git locally. most of my commit messages look like "changed stuff blah blah" or "meh" or "still doesn't work".
14:52:24 <elliott> applicative_tmp: that one is nice because eventually you will run out of letters.
14:52:31 <elliott> so you have pressure to get things working in time.
14:52:50 <applicative_tmp> elliott: you think youre kidding ;)
14:53:23 * applicative_tmp did this while writing his thesis; but he knew even less then ...
14:53:58 <cmccann> elliott: sometimes I use a more powerful version of your technique though
14:54:27 <cmccann> elliott: where I periodically do a recursive copy of the entire project directory until I have a directory full of "Foo1" "Foo2" &c.
14:54:36 <monochrom> thesis.tex.2012.4.0.0
14:54:48 <cmccann> all of which are usually broken and incomplete in unclear ways
14:55:00 <elliott> cmccann: yes I do that
14:55:06 <elliott> except they get names instead of numbers
14:55:09 <applicative_tmp> monochrom: youre getting the idea.  good thing no one told me about version control, I would have lost everything instantly ...
14:55:12 <elliott> long, unhelpful names
14:55:15 <hiptobecubic> sourceforge was seriously a joke
14:55:16 <cmccann> elliott: names are overrated
14:55:31 <elliott> point-free version control
14:55:37 <cmccann> yes
14:55:37 <monochrom> 2012.4.0.0 is a Haskell Platform version number
14:56:02 <newsham> > 2012 . 4 . 0 . 0
14:56:03 <lambdabot>   *Exception: show: No overloading for function
14:56:06 <monochrom> but wait, how would version control lose everything instantly?
14:56:21 <oinkon> hiptobecubic: source code was fantastic for its time. then it steadily degraded and better options came along.
14:56:35 <applicative_tmp> monochrom: so you add a new paragraph to your thesis whenever a new HP comes out?
14:56:42 <monochrom> hahaha
14:57:07 <applicative_tmp> monochrom: I"m just remembering what happened during my first month fidding with git
14:58:03 <monochrom> do you make weekly backups or something?
14:58:07 <applicative_tmp> its good to have a system like that monochrom, then you don't just sit around waiting for inspiration; in the end the thesis will be written
14:58:43 <elliott> every time someone makes a monoids joke, write a paragraph
14:59:16 <hiptobecubic> Am I only the one that actually uses git and its features? You guys sound like Swedish Chef trying to fix a car.
14:59:20 <BMeph> s/write a paragraph/take a drink/ ;)
14:59:24 <monochrom> "from dBase II to dBase IV: point-free version progression"
14:59:37 <applicative_tmp> oh wait, I remember better now, I had different chapters in different directories, and just called the first one written zzzzz.tex this way the latest would be first in alphabetical order...
14:59:39 <hiptobecubic> Imagine if I actually had something worthwhile to write!
14:59:45 <hpc> hiptobecubic: i use two git features
14:59:47 <hpc> 1. github
14:59:48 <applicative_tmp> I might have inferred the existence of VC ....
14:59:57 <hpc> 2. the ability to "commit" locally without pushing to github
15:00:13 <hpc> 3. the ability to use #2 to delay a release of my personal projects indefinitely
15:00:14 <cmccann> hiptobecubic: I am exaggerating slightly, or at least only talking about how I treat throw-away code
15:00:20 <elliott> hpc: that is three
15:00:23 <applicative_tmp> thats three hpc
15:00:26 <hpc> lies
15:00:37 <applicative_tmp> hpc is a *real* mathematician
15:01:02 * cmccann counts 0, 1, 2... looks like two items in the list to me
15:01:08 <monochrom> I use git, but only for personal use
15:01:21 <BMeph> applicative_tmp: Or a seriously hard-core Monty Python fan! 8D
15:01:29 <applicative_tmp> but darcs for public consumption?
15:01:39 <applicative_tmp> because git is so much better; darcs so much cooler ...
15:01:40 <monochrom> I use add, commit, branch, merge
15:01:53 <hiptobecubic> Do you use any darcs features that aren't one of those big four?
15:01:54 <hpc> add, commit, push
15:01:58 <hpc> and occasionally diff/status
15:01:58 <Eduard_Munteanu> That's not... much.
15:02:39 <hiptobecubic> for example, git bisect is really excellent
15:03:07 <Eduard_Munteanu> I do use stuff like rebase, stash, format-patch, send-email often.
15:03:11 <applicative_tmp> me has taken sometimes to sending a lot of patches by cutting and pasting into the edit window on github, it seems to remove a layer of github nonsense
15:03:16 * applicative_tmp even
15:03:27 * cmccann odd
15:03:30 <Eduard_Munteanu> Oh, git reset too.
15:03:58 <applicative_tmp> ohmigod git cultists! bisect ! bisect -pq
15:04:25 <Eduard_Munteanu> Bisecta the trifecta!
15:05:28 <monochrom> bisecta trifecta. dissecta insecta.
15:06:16 <hiptobecubic> really though. It's marvelous
15:06:52 <Eduard_Munteanu> @quote git
15:06:53 <lambdabot> elliott says: If you encounter an edwardk in the wild: nod reassuringly when he talks about something you understand. Under NO circumstances EVER give your GitHub account name
15:07:02 <applicative_tmp> well it is certainly a fast way to moves around, that's really all that I find remarkable about it
15:07:09 <Eduard_Munteanu> @quote git
15:07:09 <lambdabot> Riastradh says: It's not merely that Darcs has a UI whereas Git doesn't; it's that Git imposes a complex model of operation on you no matter what you are trying to do.  Darcs doesn't: there's a
15:07:09 <lambdabot> pristine tree and a working tree and a set of patches, which you can move from one repository to another; that's all.
15:07:23 <applicative_tmp> move files around, rather
15:07:27 <hiptobecubic> I do wish there had been more than 2 seconds of effort into making the subcommands consistent with each other
15:07:49 <Eduard_Munteanu> @quote detached.head
15:07:49 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
15:07:50 <hpc> imo, version control lives and dies by the verbs it has on the command line
15:07:52 <applicative_tmp> hiptobecubic: its been years now....
15:07:53 <Eduard_Munteanu> Aw.
15:08:07 <monochrom> git cannot be less consistent than ghc and cabal
15:08:20 <applicative_tmp> @quote severed.head
15:08:20 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
15:08:20 <hpc> in this respect, svn would be the clear winner
15:08:28 <hiptobecubic> git branch -d, but git remote rm? why?
15:08:28 <cmccann> Eduard_Munteanu: see here for details on that first quote: https://github.com/ekmett/lens/issues/171
15:08:36 <hpc> except for extenuating circumstances wherein it is a living hell trying to merge two branches
15:08:47 <monochrom> look at these: ghc -package-conf, ghc-pkg --package-conf, cabal ... --package-db
15:09:10 <Eduard_Munteanu> cmccann: hah, yes... I knew it was about something like that though.
15:09:24 <hiptobecubic> I have several aliases to mimic svn
15:09:35 <cmccann> getting elliott to do any work is an open research problem.
15:09:46 <hiptobecubic> co, ci, and st being the obvious ones
15:10:12 <monochrom> what is st?
15:10:13 <elliott> monochrom: ah, but that is its own consistency.
15:10:15 <oinkon> i apologize to the channel for sparking this unending vcs discussion. :)
15:10:16 <hiptobecubic> status
15:10:21 <elliott> if your program is a compiler, people expect its flag scheme to not make sense.
15:10:29 <elliott> they expect -foo style options rather than --foo
15:10:35 <applicative_tmp> no one seems every to come up with any deep new idea about syntax aware vc or whatever we should call it.
15:10:53 <wole> @hoogle String -> [Char]
15:10:53 <lambdabot> Data.Data tyconModule :: String -> String
15:10:54 <lambdabot> Data.Data tyconUQname :: String -> String
15:10:54 <lambdabot> Test.QuickCheck.Text bold :: String -> String
15:11:15 <applicative_tmp> oinkon: it was SO much worse when git was really taking off a couple years ago, then there were darcs v git debates, you wouldn't believe
15:11:26 <hiptobecubic> applicative_tmp, is line based that terrible really? It seems to be pretty easy to understand and very robust
15:11:41 <Eduard_Munteanu> 2 years ago?
15:11:51 <Eduard_Munteanu> I thought Git was older than Darcs.
15:11:59 <Eduard_Munteanu> At least as far as taking off is concerned.
15:12:06 * applicative_tmp evidently fools around with layout and stuff more than other people
15:12:27 <hiptobecubic> applicative_tmp, what's wrong with just making a whitespace commit?
15:12:30 <applicative_tmp> git is more recent than darcs or else i'm insane
15:12:33 <oinkon> would the haskell language be more amenable to to a syntax aware vcs? than most other languages
15:12:54 <Eduard_Munteanu> That's an interesting idea, hm.
15:13:02 <applicative_tmp> every commit is a whitespace commit
15:13:03 <Eduard_Munteanu> Related to structural editing I guess.
15:13:12 <monochrom> #haskell-blah >>= id
15:13:21 <hiptobecubic> How would a syntax aware VCS operate differently, really?
15:13:31 <hiptobecubic> Other than creating patches no one else can use
15:13:42 <Eduard_Munteanu> hiptobecubic: more sensible diffs perhaps? (e.g. changed struct foo's name to bar)
15:14:05 <Eduard_Munteanu> But yeah, I guess #haskell-blah.
15:14:24 <applicative_tmp> it wouldnt serve all the same purposes
15:14:27 <hiptobecubic> that's my cue to get back to pretending to work
15:14:37 <oinkon> yeah. easier to read diffs sounds like a potential big win. i do a lot of code reviews, and it's often unclear what was deleted and added
15:14:57 <Eduard_Munteanu> hiptobecubic: I have a feeling you're pretending to pretend to work!
15:15:02 <applicative_tmp> when writing text, I only commit something that looks nothing like what i edit
15:15:36 <applicative_tmp> what I edit has 60 character lines, what I commit is unwrapped via pandoc
15:15:45 <hiptobecubic> Eduard_Munteanu, no no. I'm genuinely pretending to work
15:15:53 <applicative_tmp> otherwise its a total nightmare
15:16:11 <hiptobecubic> so you commit single, giant lines?
15:16:30 <applicative_tmp> yes
15:16:38 <applicative_tmp> then differences are much easier to take in
15:16:45 <hpc> rofl
15:16:52 <hiptobecubic> what? that makes no sense
15:16:54 <applicative_tmp> it is admittedly a stupid example
15:17:23 <applicative_tmp> but its much easier to manage
15:17:34 <hiptobecubic> I don't see how
15:17:38 <applicative_tmp> i use pandoc to renormalize the text every few seconds
15:17:38 <hpc> oh, i see now
15:17:44 <hiptobecubic> I guess you could put the whole project on one big line
15:17:47 <nolrai25> So which of the FRP libraries should I defininately not use?
15:17:49 <applicative_tmp> reformat I should say
15:17:50 <hiptobecubic> then your diffs will be easy
15:17:59 <hpc> nolrai25: some of them ;)
15:18:00 <monochrom> I did this: I added a newline at the end of each sentence. sometimes after commas and semicolons, too.
15:18:08 <hiptobecubic> applicative_tmp, "reflow" perhaps?
15:18:17 <nolrai25> hpc: XD
15:18:20 <applicative_tmp> so then when I commit it, I keep it in paragraphs so to speak.
15:18:24 <byorgey> nolrai25: you definitely shouldn't use 'reactive'
15:18:30 <hpc> nolrai25: i don't follow frp, but there's a good post on SO that covers the common packages
15:18:42 <nolrai25> hpc: SO?
15:18:45 <byorgey> (it has not been updated since 2010 and only compiles on GHC 6.12 =)
15:18:47 <hpc> stack overflow
15:19:01 <hpc> iirc, the post mostly comes down to "use the one ewardk wrote"
15:19:27 <davean> Will|: 22
15:19:30 <davean> er, sorry
15:19:56 <Ralith> hpc: a good heuristic no matter what kind of library you're looking for
15:22:33 <nolrai25> hpc: the two mentioned in the stack overflow answer I found are written by a "Ertugrul S√∂ylemez" and a "Heinrich Apfelmus"..
15:23:10 <monochrom> actually, which SO post?
15:23:34 <monochrom> or, what keywords should I use to search?
15:24:26 <elmore> Ertugrul S√∂ylemez is mm_freak ;) :D
15:34:56 <flebron> Say I have a very large list. How can I print, for i = 0 to N, length $ takeWhile (<= i) list? (Efficiently, of course :))
15:35:37 <blackdog> flebron: i assume you're going to make that query many times?
15:35:45 <blackdog> have a look at fingertree on hackage
15:35:54 <flebron> Just once, I need to print this once to a file.
15:36:06 <blackdog> oh. well, in that case, you're going to have to look at every element anyway
15:36:26 <flebron> Yes, but doing that with takeWhile is quadratic (linear for every i).
15:36:27 <blackdog> oh, hang on, you want all of them
15:36:30 <blackdog> maybe a scan?
15:36:45 <flebron> What scan would that be?
15:37:11 <hpc> i can't imagine length $ takeWhile (<= i) list being that slow
15:37:13 <hpc> or rather
15:37:20 <hpc> i can't imagine being able to improve on it
15:37:21 <copumpkin> it's for a bunch of i values
15:37:25 <hpc> oh
15:37:42 <copumpkin> it's not really a scan, either
15:38:28 <copumpkin> I could see it working with a mapAccumL but that's kind of ugly
15:38:31 <flebron> I thought maybe a scan over a zipping of some sort...
15:38:32 <blackdog> actually, maybe the fingertree will work, then - if you can make the query in logn each time, you have n of those queries
15:38:38 <hpc> i think what you want is map length $ takeWhiles i list
15:38:51 <copumpkin> you should be able to do it faster than n log n though
15:38:53 <hpc> where takeWhiles :: Int -> [Int] -> [[Int]]
15:39:21 <blackdog> stepping back a second - flebron, is this actually a bottleneck in your program right now?
15:39:30 <flebron> Yes, that's all the program does :)
15:39:34 <blackdog> ha :)
15:39:38 <johnw> copumpkin: only the last result in that list needs length applied
15:39:41 <flebron> It's the expected output of a program that I wrote in C, and I want to compare them.
15:39:47 <hpc> this can get it down to O(nm)
15:39:50 <hpc> where m is length list
15:39:55 <johnw> _last ~. length, or some such
15:39:57 <flebron> (In C I use a probabilistic primality algo, in Hask I use Data.Numbers.Primes.)
15:40:21 <copumpkin> I was just thinking of dropping from the accumulator in mapAccumL and maintaining the length seen so far
15:40:31 <hpc> er
15:40:34 <hpc> O(m)
15:40:36 <copumpkin> it doesn't seem so hard, and should take O(index-of-last(i))
15:41:05 <johnw> \len xs -> bizarreBimappish len length $ takeWhile len xs
15:41:28 <johnw> where bizarreBimappish :: [y] -> x -> (y -> x) -> [x]
15:41:51 <johnw> bizarreBimappish :: x -> (y -> x) -> [y] -> [x]
15:42:05 <johnw> so, it only applies length to the last element, if there is a last element
15:42:45 <K_> I have a problem with the following code: fctn x y = if mod x y == 0 then if x == y then y else fctn (x/y) y else fctn x (y+1)
15:43:08 <K_> it loads in the interpreter but fails to run
15:43:18 <johnw> you mean, it loops infinitely?
15:43:37 <K_> no the interpreter complains about fractional integersx
15:43:58 <johnw> ah
15:44:04 <EvanR> fractional integers always screw things up
15:44:06 <johnw> as well it should
15:44:11 <johnw> EvanR: lol
15:44:20 <johnw> even the greeks hated them!
15:44:30 <K_> any thoughts on what to do?
15:44:52 <johnw> K_: floor (x/y)
15:45:04 <johnw> Haskell doesn't do auto-conversions
15:45:19 <K_> what does floor do?
15:45:26 <EvanR> > floor 3.1415
15:45:27 <lambdabot>   3
15:45:33 <Rembane> > :t floor
15:45:35 <lambdabot>   <hint>:1:1: parse error on input `:'
15:45:38 <Rembane> :(
15:45:45 <geekosaur> no >  prefix
15:45:45 <K_> oh ok
15:45:48 <geekosaur> :t floor
15:45:49 <lambdabot> (Integral b, RealFrac a) => a -> b
15:45:52 <EvanR> floor :: Double -> Int
15:45:54 <K_> thanks
15:45:54 <EvanR> ;)
15:45:55 <Rembane> geekosaur: Thanks.
15:52:21 <K_> I have the following function, which loads in the interpreter but fails to run on account of "ambiguous type variable" : fctn x y = if mod x y == 0 then if x == y then y else fctn (floor(x/y)) y else fctn x (y+1)
15:53:35 <K_> any thougts on the problem in my code posted above?
15:53:41 <monochrom> replace "floor(x/y)" by "div x y"
15:53:47 <dmwit> K_: Give it a type signature.
15:54:01 <K_> sorry what does that mean?
15:54:56 <dmwit> Listen to monochrom and ignore me.
15:55:44 <johnw> oops
15:55:54 <hpc> haha
15:57:11 * hackagebot hangman 1.0.1 - Hangman implementation in Haskell written in two hours.  http://hackage.haskell.org/package/hangman-1.0.1 (HokShunPoon)
15:57:27 <dmwit> hm
15:57:54 <dmwit> "Written in two hours" doesn't seem like a good design goal. Makes maintenance increasingly difficult.
15:58:26 <luite> write it in one hour and every time you do maintenance spend half as much time as the last
15:58:41 <h4199> Zeno's program
15:58:49 <hpc> i wrote a few of my projects in under an hour
15:58:51 <dmwit> I feel that this strategy falls neatly under the "increasingly difficult" umbrella.
15:59:11 <hpc> but that's just the first working version
16:02:45 <cmccann> dmwit: I wrote a tetris clone in 3 or 4 hours once. maintenance was actually really easy, since I never did any.
16:04:30 <hpc> there need to be more haskell throwaway projects, imo
16:04:39 <hpc> do it in an hour or two, say "look what i did" and move on
16:05:04 <Rembane> Haskell dogma competition!
16:07:19 <dmwit> Is Hackage really the place for throwaway projects?
16:08:01 <hpc> no
16:08:05 <hpc> but github is!
16:10:59 <luite> dmwit: oh i have a different kind of throwaway projects. work on something for 2 years, then realize that fpcomplete has done it better, then throw it away ;)
16:11:46 <hpc> lol
16:12:39 <cmccann> hpc: that was pretty much why I wrote that tetris clone. just a "look, a simple game in Haskell written in a few hours, it was not even difficult" thing.
16:12:54 <cmccann> I did not, however, put it on hackage :P
16:13:12 <hpc> cmccann: did you use opengl? i can imagine that singlehandedly taking up those hours
16:13:31 <`nand`> sounds like a use-case for gloss :)
16:13:32 <luite> hpc: i didn't really throw it away though, yet
16:13:38 <cmccann> hpc: graphics-drawingcombinators
16:13:43 <cmccann> so technically opengl but easy
16:13:46 <hpc> heh
16:13:51 <hpc> i need to ever take a look at that
16:13:56 <cmccann> most of the hours was taken up by me not knowing wtf I was doing
16:14:14 <luite> hmm, is gloss better than that now for that kind of project?
16:14:17 <hpc> so far my throwaway projects have been synonyminator and imgur-permutations
16:14:49 <luite> my current throwaway project is a javascript optimizer that throws away unreachable branches
16:15:00 <hpc> sounds painful
16:15:12 <hpc> also lol at "javascript optimizer"
16:15:32 <shachaf> luite: arkeet would be mad at you, if he was here
16:15:45 <arkeet> what for?
16:16:06 <shachaf> The usual.
16:16:13 <arkeet> oh dear.
16:16:14 <ab9rf> isn't a javascript optimizer something that replaces javascript with some other language? :)
16:16:18 <arkeet> that was pretty terrible, yeah.
16:16:21 <luite> hpc: yeah the control flow graph is a bit of an abomination, since it has to be translated back to javascript control structures. but it kinda works now, with constant propagation and liveness analysis (forward and backward dataflow analysis respectively)
16:16:58 <cmccann> hpc: oh, it turns out you were one of the people grumbling about it not being possible to make a quick and simple game in Haskell that motivated me to write a game
16:17:07 <cmccann> so there you go.
16:17:13 <hpc> sounds likely
16:17:42 <Eduard_Munteanu> cmccann: what would that game be?
16:17:48 <cmccann> https://github.com/isomorphism/lazy-tetrominoes
16:17:52 <cmccann> crappy little tetris clone
16:18:01 <cmccann> written when I'd been using Haskell for like a year at most I think?
16:18:04 <luite> ab9rf: if i had the option to output another language, i wouldn't generate javascript at all :)
16:18:07 <cmccann> the code is kinda awful.
16:18:22 <arkeet> https://github.com/fumieval/Monaris :-)
16:19:10 <cmccann> arkeet: oh it's got a cabal file and everything. that is much fancier than mine.
16:19:49 <hpc> oh, i wrote ghc-man-completion in about an hour too
16:19:57 <hpc> been getting a lot of value out of that one
16:44:06 <blackdog> anyone know how to pass profiling options in a cabal file?
16:46:31 <shachaf> ghc-prof-options?
16:47:11 * hackagebot hangman 1.0.2 - Hangman implementation in Haskell written in two hours.  http://hackage.haskell.org/package/hangman-1.0.2 (HokShunPoon)
16:47:54 <h4199> I think someone broke their
16:48:01 <h4199> own rule*
16:48:12 <luite> only 50 minutes time difference
16:48:16 <h4199> hmm
16:50:06 <luite> hm, the github link is wrong
16:50:23 <h4199> Noticed that too
16:50:59 <luite> https://github.com/fatuhoku/haskell-hangman
16:55:42 <blackdog> shachaf: not sure how i missed that -  thanks!
16:57:12 * hackagebot hangman 1.0.3 - Hangman implementation in Haskell written in two hours.  http://hackage.haskell.org/package/hangman-1.0.3 (HokShunPoon)
17:01:21 <luite> 50 minutes between first two updates, 10 between the last
17:01:28 <luite> he appears to be applying my strategy
17:01:34 <edwardk> ?
17:17:12 * hackagebot http-streams 0.5.0.2 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.5.0.2 (AndrewCowie)
17:39:24 <Curry_Boy> hello I'm using attoparsec, its takeWhile requires a function of type (char -> bool). Is there any function in attoparsec which similar but takes a bytestring like takeWhile its not "foobar"
17:42:07 <EvanR> Curry_Boy: so using this parser on "abcfoobar" would be ("abc", "foobar"), but what if its "abcfooba"EOF
17:44:56 <geekosaur> Curry_Boy, maybe you want manyTill?
17:45:39 <EvanR> ah yeah
17:49:36 <Curry_Boy> EvanR: I would assume it would fail.             geekosaur: manyTill is perfect thanks!
18:19:40 <dmwit> hm
18:20:04 <dmwit> cabal rebuilds files once for each executable in your package that uses them =(
18:20:25 <luite> dmwit: you can make the executable in your package depend on the library
18:20:56 <dmwit> Yeah, but I want my one-deep module names and I don't want to clutter the namespace by registering a package with them...
18:21:40 <dmwit> Mostly I'm just whining, I guess.
18:21:42 <luite> ah :(
18:24:23 <DiegoNolan> :q
18:24:38 * tgeeky calls the whaaaaaaaaambulance
18:25:30 <mietek> @hoogle Int -> [a] -> [[a]]
18:25:30 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:25:30 <lambdabot> Data.List drop :: Int -> [a] -> [a]
18:25:30 <lambdabot> Prelude take :: Int -> [a] -> [a]
18:25:40 <cmccann> dmwit: make two versions of the library code, the one with the higher version number having nothing in it and the executable depending explicitly on the older version.
18:25:43 <cmccann> problem solved!
18:25:51 <cmccann> (wow that's a horrible idea)
18:26:05 <dmwit> wow
18:26:10 <dmwit> That really is a horrible idea.
18:26:26 <dmwit> If there were a way to ask cabal to automatically hide a package after registering it, that would work pretty okay, though.
18:26:36 <cmccann> yeah, that was my first thought
18:27:08 <dmwit> But you went with "make two versions"? =D
18:27:13 * hackagebot groom 0.1.2 - Pretty printing for well-behaved Show  instances.  http://hackage.haskell.org/package/groom-0.1.2 (EdwardYang)
18:27:15 * hackagebot cmdtheline 0.2.3 - Declarative command-line option parsing and documentation library.  http://hackage.haskell.org/package/cmdtheline-0.2.3 (EliFrey)
18:27:36 <cmccann> well, I don't know if there is a way to make it hide a package like that. if there is, I don't know how.
18:27:46 <cmccann> so plan B was "suggest a horrible hack"
18:27:58 <dmwit> =)
18:28:01 <dmwit> Thanks.
18:28:21 <cmccann> somewhere around plan E is "read the cabal documentation"
18:28:31 <ddfisher> hey all: I'm getting a "duplicate definition for symbol" linker error when I try to use Control.Lens with GLUT - any thought about what might be going on?
18:28:33 <dmwit> plan F, hack cabal to Not Do That
18:28:47 <ddfisher> thoughts*
18:29:49 <dmwit> ddfisher: yikes
18:30:04 <cmccann> dmwit: personally, my solution would probably be to complain on IRC and do nothing, of course
18:30:15 <dmwit> cmccann: my current plan, too
18:30:19 <dmwit> just wanted some commiseration
18:30:21 <ddfisher> dmwit: I'm not even doing anything fancy in either of them :(
18:30:30 <cmccann> ddfisher: the only times I've seen a message like that it was because I was doing something bizarre. I can't imagine what might be going on to get that in normal use...
18:31:03 <cmccann> (I think I got an error like that when I tried to use the GHC API from a TH splice)
18:31:11 <tgeeky> it's a linking error of some sort, I think
18:31:53 <ddfisher> "Loading package GLUT-2.4.0.0 ...  GHCi runtime linker: fatal error: I found a duplicate definition for symbol _hs_GLUT_getProcAddress"
18:31:59 <geekosaur> the times I've seen that involved some dependency pullinh in a different version
18:32:20 <geekosaur> does it also load some other version of GLUT?
18:32:41 <ddfisher> geekosaur: it does!
18:32:44 <ddfisher> hmm
18:32:47 <ddfisher> I'll look at that
18:33:13 <monochrom> this is another reason why you must not allow two versions to live. one must die. die die die.
18:33:54 <tgeeky> some stackoverflow thing suggests passing -x to ld, which is --discard-all which "delete[s] all local symbols"
18:34:09 * tgeeky thinks some symbol you are creating in GHCi is competing with one in glut?
18:34:10 <geekosaur> tgeeky, not helpful
18:34:16 <cmccann> monochrom presents: cabal-install, Highlander Edition
18:34:24 <geekosaur> read recent scrollback
18:35:06 <tgeeky> geekosaur: oh, i thought if you were asking if it works with another version of GLUT, not if he is loading multiple
18:35:10 <tgeeky> geekosaur: I see.
18:36:58 <hiptobecubic> is there a hangman easteregg in ghc?
18:37:45 <luite> i love hangman eastereggs, they're so easy, you can write one in two hours
18:38:38 <hiptobecubic> nevermind. $PATH was interfering :D
18:38:47 <hiptobecubic> i got all excited over nothing
18:39:21 <ddfisher> Thanks for the help everyone!
18:39:47 <ddfisher> I fixed it by unregistering the older GLUT version that was also installed
18:39:49 <shachaf> hi ddfisher
18:40:14 <ddfisher> hi shachaf!
18:42:52 <shachaf> You're using Control.Lens! Hooray!
18:43:15 <shachaf> lens is pure Haskell so the problem is very likely related to GLUT.
18:44:35 <monochrom> haha
18:45:03 <applicative_tmp> the dirty secret of imperative programming languages is that their principal structures are tropes derived from 50's cookbooks. 'for each potato, peel and quarter it ...' ' 'while the potatoes are boiling...' '...until the surface turns a rich golden brown'
18:45:19 <applicative_tmp> i mean, how else can you compose imperatives
18:45:50 <shachaf> Kant had no trouble applying category theory to imperative programming.
18:45:52 * applicative_tmp has had enough 'awarenesses' for today
18:46:12 * dmwit feels confused
18:46:20 <applicative_tmp> wow thats really giving me conceptual trouble shachaf
18:46:31 <applicative_tmp> any three words in succession are okay....
18:47:02 <dmwit> I believe shachaf was punning.
18:47:19 <shachaf> It's been known to happen.
18:47:30 <applicative_tmp> punning? punning? what library is that defined in?
18:47:46 <shachaf> {-# LANGUAGE RecordPuns #-}
18:47:52 <ddfisher> shachaf: In some sense, the problem was that there were two versions of GLUT installed.  This only caused problems when there was a call to makeLenses for some reason.  Probably an interaction between TH and GLUT somehow
18:48:22 <applicative_tmp> ah a language extension
18:48:56 <applicative_tmp> ddfisher: blame the lens library, it uses unsafeEverything 'under the hood'
18:49:45 <applicative_tmp> not enough FFI in lens, i'd say
18:49:47 <tgeeky> how does that cause linking errors?
18:50:12 <ddfisher> tgeeky: excellent question!
18:50:19 <ddfisher> I'd love to know the answer ._.
18:50:41 <tgeeky> i'd be willing to be it's just a normal GHCi runtime linking problem originating from two copies of a library
18:51:07 <applicative_tmp> ddfisher: everything is linking properly?
18:51:40 <applicative_tmp> i meant everything else is, so there's not some global ghc linking problem
18:52:09 <shachaf> applicative_tmp: That shouldn't cause linking errors, only runtime errors.
18:52:42 * shachaf is somewhat responsible for most unsafeCoerces in lens. :-(
18:53:00 <applicative_tmp> oh unsafeEverything, that was just a, what you say, pun?
18:53:28 <cmccann> unsafeEverything is a new GHC primitive that, when forced, automatically installs the latest version of lens for you.
18:53:37 <applicative_tmp> but i was wondering if the only linking problem ddfisher had has was with glut
18:54:03 <shachaf> ddfisher: If you write the lens manually rather than use makeLenses, does it also fail?
18:54:15 <applicative_tmp> cmccann: yes, the optimizations it can thus make available ... mmmmm
18:55:05 <hiptobecubic> ::w
18:55:39 <shachaf> Somehow making puns doesn't even seem worthwhile anymore when arkeet isn't around.
18:55:56 <arkeet> this is step one of my plan.
18:56:12 <arkeet> (step two is to disappear.)
18:56:50 * tgeeky assumes step 3 is "???" and step 4 is profit
18:58:26 <ab9rf> i could do with a prophet or two
18:58:32 <ddfisher> applicative_tmp: I was only getting errors related to GLUT, oddly
18:58:50 <ddfisher> and the problem went away when I unregistered the excess GLUT installation
18:59:05 <applicative_tmp> ah
18:59:10 <ab9rf> you had a glut of GLUT?
18:59:15 <applicative_tmp> glut glut
18:59:16 <ddfisher> shachaf: I haven't tried, but I would guess that it wouldn't
18:59:50 <shachaf> Sounds a bit odd, but OK.
19:01:14 <applicative_tmp> are the 'components' in PolymorphicComponents components of a record?
19:01:28 <shachaf> Yes.
19:01:52 <tgeeky> applicative_tmp: can you s/_tmp// your name?
19:02:07 <applicative_tmp> s/ tmp for what
19:02:14 <applicative_tmp> nothing i see
19:02:21 * applicative_tmp never went to trade school
19:02:52 <tgeeky> that's almost exactly wrong!
19:03:11 <applicative> well
19:03:23 <applicative> mauke_tmp gets away with it, why not me?
19:03:48 <TODO_name_tmp> Hello, I love you.
19:04:01 <shachaf> hmwit
19:04:06 <applicative_bak> TODO_name_tmp: nice
19:04:11 <TODO_name_tmp> hachaf
19:04:33 <arkeet> @arrr
19:04:33 <lambdabot> Shiver me timbers!
19:04:58 <TODO_name_tmp> s/hachaf//
19:05:35 <_____> how can _____ already be registered, why do they permit it
19:05:40 <cmccann> hahaha
19:06:38 <hiptobecubic> :w
19:06:40 <hiptobecubic> damnit
19:06:40 <ddfisher> @arrr
19:06:40 <lambdabot> I want me grog!
19:06:54 <tgeeky> hiptobecubic: I'm going to write the state of the entire universe on your hard drive if you don't stop it!
19:07:27 <hiptobecubic> tgeeky, the real solution is to fix xmonad's floating window problem
19:07:42 <tgeeky> hiptobecubic: I'm not that smart.
19:07:48 <hiptobecubic> Me either.
19:08:38 <dmwit> < U.universe -- kind of a small threat, tgeeky
19:08:42 <goodfellow>   mueval-core: Time limit exceeded
19:08:46 <dmwit> oh bugger
19:08:49 <tgeeky> dmwit: oh yeah?
19:08:58 <cmccann> haha
19:09:04 <dmwit> < U.universe
19:09:06 <goodfellow>   [()]
19:09:13 <dmwit> goodfellow takes a little while to get warmed up :3
19:09:28 <tgeeky> the universe doesn't have that problem
19:09:32 <arkeet> < U.universe :: [Bool]
19:09:33 <goodfellow>   [False,True]
19:09:35 <tgeeky> it does take a little while to cool down
19:09:46 <dmwit> < U.universe :: [Bool -> Bool]
19:09:47 <goodfellow>   [[(False,False),(True,False)],[(False,True),(True,False)],[(False,False),(T...
19:09:51 <arkeet> heh
19:09:56 <hiptobecubic> What the hell is goodfellow?
19:10:04 <tgeeky> hiptobecubic: lambdabot ++ universe
19:10:09 <cmccann> a good fellow, to be sure.
19:10:18 <hiptobecubic> s/goodfellow/universe/
19:10:23 <dmwit> ?hackage universe
19:10:23 <lambdabot> http://hackage.haskell.org/package/universe
19:10:31 <dmwit> < (==) == (/=) . not
19:10:33 <goodfellow>   True
19:10:38 <dmwit> < (==) == (/=)
19:10:39 <goodfellow>   False
19:10:44 <dmwit> < min max min
19:10:45 <goodfellow>   [((),[((),())])]
19:10:54 <shachaf> < (==) == ((/=) :: Void -> Void -> Bool)
19:10:55 <dmwit> and other fun stuff =)
19:10:56 <goodfellow>   Not in scope: type constructor or class `Void'Not in scope: type constructo...
19:10:58 <shachaf> Aw.
19:11:09 <tgeeky> shachaf: it's a universe, not MAGIC
19:11:13 <cmccann> < (+1) == (succ :: Word8 -> Word8)
19:11:14 <goodfellow>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
19:11:18 <cmccann> pf
19:11:38 <dmwit> shachaf: returns True in ghci =)
19:12:14 * hackagebot commsec-keyexchange 0.1.1 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.1.1 (ThomasDuBuisson)
19:13:38 <dmwit> < (+1) == (subtract 255 :: Word8 -> Word8)
19:13:39 <goodfellow>   True
19:14:13 <parcs> @check
19:14:15 <lambdabot>   <hint>:1:16: parse error (possibly incorrect indentation)
19:14:32 <dmwit> ?check \x -> (x+1 :: Word8) == x-255
19:14:34 <lambdabot>   Not in scope: `myquickcheck'
19:14:36 <parcs> @check liftM2 (==) (+1) (subtract (255 :: Word8))
19:14:38 <lambdabot>   Not in scope: `myquickcheck'
19:14:48 <parcs> why hasn't anybody fixed that yet :(
19:15:40 <tgeeky> why does everyone ask questions like that when the answer is always "because they have finite time and are lazy"
19:16:03 <cmccann> tgeeky: it seems that question answers itself.
19:16:26 <tgeeky> cmccann: I know, rite? I was almost too lazy to even type that.
19:17:05 <dmwit> The other standard answer is "congratulations, you just volunteered to fix that".
19:17:18 <shachaf> The reason is that the only person in a position to fix it is Cale.
19:17:25 <shachaf> No one else can even volunteer.
19:24:15 <dmwit> hm
19:24:20 <dmwit> < (+1) < (+2)
19:24:21 <goodfellow>   Ambiguous type variable `a0' in the constraints:
19:24:22 <goodfellow>    (GHC.Num.Num a0)
19:24:22 <goodfellow>      a...
19:24:52 <arkeet> < (+1) < (+2::Word8)
19:24:53 <goodfellow>   <hint>:1:11: parse error on input `::'
19:24:57 <arkeet> < (+1) < (+(2::Word8))
19:24:58 <goodfellow>   True
19:25:03 <arkeet> really?
19:25:17 <dmwit> < all (\(x, y) -> compare x y == compare (+x) (+(y :: Word8))) U.universe
19:25:18 <goodfellow>   True
19:25:24 <parcs> lambdabot needs a rewrite
19:25:34 <dmwit> parcs: why?
19:25:43 <geekosaur> we've known that for years...
19:25:44 <cmccann> parcs: that sounds suspiciously like you're volunteering
19:26:25 <parcs> dmwit: because @check doesn't work
19:26:36 <h4199> wasn't there a lambdabot 2 in the works?
19:26:47 <parcs> while fixing that issue, you might as well rewrite the whole bot :)
19:26:54 <dmwit> Of all the reasons I can think of, that's probably the worst one.
19:27:00 <Guest24814> http://www.youtube.com/watch?v=K4MCX3LbwJs
19:27:08 <dmwit> <3 idoru
19:27:36 <parcs> i wonder if the mueval stuff in necessary still
19:29:31 <parcs> iirc it was once necessary because you couldn't kill a thread that was in a non-allocating loop
19:29:46 <parcs> but i think that has been fixed
19:30:18 <cschneid> anybody have a guide on using quickcheck in the context of an app?  Do you make a separate file that imports your implementation, and its main is the checks? or is there a smoother way to integrate it?
19:30:41 <cschneid> myapp.hs with its main, then tests.hs with its main being calls out to quickcheck. That best?
19:30:51 <dmwit> That sounds pretty good to me.
19:30:59 <parcs> that's how most testsuites work
19:31:10 <dmwit> I think there's even some TH that will run all the identifiers that start with prop_.
19:31:17 * applicative has just been freaking out another familiar channel having mistaken it for lambdabot
19:31:19 <arkeet> and if you're using cabal, you can specify a test program
19:31:30 <liyang> Maybe doctests so that they get compiled out...
19:31:34 <cschneid> ok, then wrap it all up into a makefile or similar (cabal it sounds like)
19:32:07 <mike4_> hey
19:32:07 <mike4_> does haskell have oop?
19:32:25 <liyang> @faq does haskell have oop?
19:32:26 <lambdabot> The answer is: Yes! Haskell can do that.
19:32:36 <dmwit> Also: Oleg did it.
19:32:43 <dmwit> So you know it's good.
19:32:52 <sellout-> mike4_: Yeah, it just does it differently than you might be used to: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
19:32:53 <liyang> And if not edwardk definitely did.
19:33:06 <parcs> depends. does C have oop?
19:33:18 <liyang> I've seen OOP in assembly.
19:33:36 <mike4_> C and ASM doesn't have OOP.
19:33:42 <arkeet> if you're getting into haskell, the best thing to do with what you know about OOP is to forget it.
19:33:52 <mike4_> C++ and Java have OOP right?
19:34:06 <parcs> i think you're asking whether haskell has good support for oop
19:34:07 <mike4_> ok
19:34:13 <sellout-> mike4_: Sure, but not very good versions of it.
19:34:15 <liyang> mike4_: but you can program in OOP style in C and assembly.
19:34:16 <parcs> the answer is not really
19:34:17 <mike4_> yes
19:34:26 <cschneid> mike4_: the definition of oop is really vague. There's some aspects you can look for, and different languages interpret it differently.
19:34:27 <PatrickRobotham> How would I write m1 <- getLine ; let m = (read m1)::Int more idiomatically?
19:34:41 <mike4_> oh
19:34:46 <parcs> PatrickRobotham: readLn
19:34:46 <applicative> cschneid: you can find examples in the better libraries e.g. https://github.com/bos/text https://github.com/jgm/pandoc etc etc
19:34:51 <arkeet> PatrickRobotham: m <- fmap read getLine
19:34:55 <cschneid> applicative: cool - thanks
19:34:56 <arkeet> or readLn
19:35:05 <arkeet> I forgot about readLn
19:35:12 <parcs> everybody does
19:35:27 <mike4_> well can I do things like Car.StartCar(); ?
19:35:42 <liyang> mike4_: is that really the best way to start a car?
19:35:46 <parcs> define "like"
19:35:48 <applicative> PatrickRobotham: there is the delicate point that something will have to specify the type of m in the following, of course
19:36:00 <mike4_> can I access the member functions of a class object in haskell?
19:36:03 <arkeet> although with ScopedTypeVariables you can just write
19:36:06 <arkeet> m :: Int <- readLn
19:36:10 <liyang> mike4_: what is a class object?
19:36:13 <parcs> haskell has no notion of class object
19:36:17 <parcs> @where lyah
19:36:18 <lambdabot> http://www.learnyouahaskell.com/
19:36:20 <parcs> read it
19:36:27 <arkeet> seconded.
19:36:32 <mike4_> ok.
19:36:41 <cschneid> mike4_: the answer you're looking for is no. It's not strictly true that haskell can't do OOP, but it's close enough for your purposes it sounds like
19:36:42 <applicative> PatrickRobotham: with ScopedTypeVariables on you can write   (m::Int) <- fmap read getLine  ; without it you can write  m <- fmap read getLine :: IO Int
19:36:42 <PatrickRobotham> arkeet: What are ScopedTypeVariables?
19:37:02 <liyang> mike4_: best to lobotomise the OOP bits of your brain and start from scratch. Then later you can draw parallels between Haskell and other languages.
19:37:05 <arkeet> PatrickRobotham: it's an extension that lets you write that, among other things.
19:37:14 <mike4_> liyang, well according to Java and C++ it has been the best way to start a car.
19:37:38 <liyang> mike4_: and Java and C++ is the one canonical way to think about things.
19:37:40 <PatrickRobotham> applicative, arkeet, parcs, thank you.
19:37:53 <arkeet> alternatively,
19:37:57 <arkeet> m <- readLn :: IO Int
19:38:00 <mike4_> ok
19:38:15 <parcs> or specify the type of m at its usage site
19:38:23 <arkeet> sure
19:38:27 <applicative> > ((+1),(*)) ^. _1 $ 2
19:38:30 <lambdabot>   3
19:38:41 <applicative> check it out I accessed a method function
19:38:49 <arkeet> whoa there
19:39:21 <mike4_> yes. they have, I wonder if that canonicallity also is availble inside haskell.
19:39:45 <applicative> liyang: indeed, but I think we're supposed to be somewhat subtler than that
19:40:40 <applicative> > (even, odd, (+1) ^. _2 $ 3
19:40:42 <lambdabot>   <hint>:1:27: parse error (possibly incorrect indentation)
19:40:44 <arkeet> mike4_: haskell doesn't really provide a framework for doing OO stuff. if you really want to, you probably could, but usually there are better, more haskellish ways of accomplishing whatever it is you want.
19:40:49 <applicative> > (even, odd, (+1)) ^. _2 $ 3
19:40:51 <lambdabot>   True
19:41:07 * applicative just cant stop accessing
19:41:21 <arkeet> perhaps a motto for haskell is "everything is a value"
19:41:32 <arkeet> (vs "everything is an object")
19:41:39 <PatrickRobotham> Can I overwrite variables in do notation?
19:41:40 <mike4_> oh
19:41:52 <PatrickRobotham> like, m <- exp ; m <- return $ m+1
19:41:54 <applicative> overwrite?  you can shadow
19:42:07 <arkeet> PatrickRobotham: yes, but you're essentially making a new variable that hides (shadows) the old one.
19:42:15 <applicative> the first m is the one in m + 1, if I understand the desugaring
19:42:28 <mike4_> everything is a value.... hmmm I wonder how that would boost my programming.
19:42:42 <PatrickRobotham> Will this eat up a lot of memory if I do it too much?
19:43:01 <arkeet> PatrickRobotham: not as such.
19:43:11 <applicative> it doesn't pertain to memory, the variables will all be ugly hashes by the time anything is compiled
19:43:12 <arkeet> it makes no difference if you call the second m something else.
19:43:47 <applicative> it will tend more to lead to confusion, terror, nausea, vertigo and alarm PatrickRobotham
19:43:54 <arkeet> mike4_: note that it's not "everything is a function", which sometimes people like to think for some reason.
19:44:20 <PatrickRobotham> applicative: Scary.
19:44:42 <Rotaerk_> hrm, i don't get this...
19:44:42 <PatrickRobotham> applicative: I want to keep track of all the user input to my program.
19:45:06 <arkeet> mike4_: but it's a rather powerful idea. for example, code that has side-effects (i.e. stuff in IO) can be operated on without being executed, so you can define your own control structures very easily and naturally.
19:45:08 <applicative> by calling it all m?
19:45:22 <Rotaerk_> this is working in ghci:  do { et <- use gameEntityTable; return et }   but this isn't:  do { et <- use gameEntityTable; let a = 5; return et }
19:46:06 <arkeet> Rotaerk_: rather than just say "this isn't working", could you give an error message or so?
19:46:15 <PatrickRobotham> applicative: Well, i was thinking of calling it hist (for history) and having inp <- readLn ; hist <- inp:hist
19:46:16 <shachaf> Rotaerk_: Yes. It's ambiguous.
19:46:17 <Rotaerk_> parse error on input `}'
19:46:18 <applicative> @type use _1
19:46:20 <lambdabot> (MonadState s m, Field1 s t a b) => m a
19:46:21 <shachaf> Try let { a = 5 }
19:46:30 <PatrickRobotham> applicative: I was just hoping this wasn't a monumentally stupid idea.
19:46:43 <arkeet> oh, is that what it is.
19:46:44 <applicative> @type do {x <- use _1; return x}
19:46:45 <lambdabot> (MonadState s m, Field1 s t b b1) => m b
19:47:01 <applicative> @type do {x <- use _1; let a = 5 ; return x}
19:47:03 <lambdabot> parse error on input `}'
19:47:10 <Rotaerk_> shachaf, ah, thanks
19:47:12 <applicative> bingo, what's going on there
19:47:29 <applicative> why is it ambiguous
19:47:37 <geekosaur> it can't tell whether what follows the semicolon is more let or more do
19:47:38 <Rotaerk_> yea I don't get it; thought that was basic do-syntax
19:47:39 <arkeet> it's not. it's just surprising.
19:47:48 <geekosaur> you need the braces to tell it the let is done
19:47:56 <applicative> ah okay, how do I resolve it?
19:48:04 <geekosaur> (normally it figures out via layout, but you're suppressing that...)
19:48:05 <arkeet> @type do {x <- use _1; let {a = 5} ; return x}
19:48:06 <lambdabot> (MonadState s m, Field1 s t b b1) => m b
19:48:22 <applicative> ah
19:48:32 <arkeet> otherwise it's like
19:48:34 <Rotaerk_> ah, it's just that braces aren't needed to clarify that when it's multiline...
19:48:36 <geekosaur> [28 22:46] <shachaf> Try let { a = 5 }
19:48:37 <arkeet> do {x <- use _1; let {a = 5 ; return x
19:48:44 <arkeet> and then it's expecting something other than }
19:48:46 <arkeet> like =, perhaps
19:49:03 <tgeeky> byorgey++ -- for http://byorgey.wordpress.com/2013/04/16/beeminding-for-fun-and-profit/
19:49:04 <geekosaur> let a = 5; b = 6
19:49:07 <mike4_> i see.
19:49:07 <geekosaur> would be legal
19:49:18 <Rotaerk_> makes sense
19:50:28 <shachaf> arkeet: OK, "ambiguous" wasn't the right word.
19:51:23 <applicative> PatrickRobotham: well, one customarily adds a layer of State for such things, but maybe that is too much trouble here
19:51:42 <PatrickRobotham> how do I do that?
19:53:12 <applicative> of course since it is in io, the truly depraved thing is to add an IORef [Int] :)
19:54:57 <applicative> do inp <- lift readLine ; st <- get; put (inp:st); etc.   PatrickRobotham <-- though there are more pleasing syntaxes or syntaces
19:56:20 <arbn> Hey, people. I want to move a [Text] across the FFI. The trouble is, there is no (Storable Text) instance that I can find, so what's the best way to do this?
19:56:57 <shachaf> Encode it to a ByteString?
19:57:28 <arbn> shachaf: Hey. That's not a bad idea.
19:57:42 <arbn> shachaf: Thanks.
20:00:22 <applicative> PatrickRobotham: do you have a bit of the program you are working with, people might have an idea how to manage it without too much high tech machinery
20:02:00 <applicative> what no tempests-in-a-teapot on the haskell reddit?
20:02:07 <PatrickRobotham> applicative: I'll upload it on github
20:02:16 * hackagebot DAV 0.4 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.4 (ClintAdams)
20:02:19 <applicative> oh cool
20:04:54 <PatrickRobotham> applicative: https://github.com/PatrickRobotham/aimml
20:05:28 <PatrickRobotham> applicative: It's not much to look at now, but I'm gradually getting there.
20:08:39 <mm_freak_> is there any work going on on parallelizing GHC?
20:08:57 <PatrickRobotham> applicative: I think I've done the random number stuff wrong as well.
20:09:42 <jfischoff> what is a good ftp implementation from a pedagogical perspective?
20:13:02 <PatrickRobotham> applicative: I suspect it would be better to use the state Monad, I'm just not sure how to use it with the IO Monad.
20:16:40 <applicative> PatrickRobotham: here's a shabby way with IORef https://gist.github.com/applicative/5479524
20:17:54 <applicative> PatrickRobotham: I  'initialized' it with [] and called it hist, then I can readIORef hist and writeIORef hist [1,2,3], and modifyIORef hist with a function
20:18:08 <PatrickRobotham> applicative: Thank you.
20:18:14 <PatrickRobotham> applicative: Why is IORef shabby?
20:18:28 <applicative> or maybe I'm getting some arguments in the wrong order.  I mention this approach because it is the closest to what I think you were thinking of
20:18:45 <Hermit> PatrickRobotham: because breaks referential transparecy
20:19:00 <PatrickRobotham> Ok
20:19:11 <applicative> PatrickRobotham: it isn't really shabby in the context of a short main like that, it promptly loses composablility if you are piecing together lots of complicated monadic stuff
20:20:29 <applicative> PatrickRobotham: I can't tell what you were going on to do, some sort of loop? In any case, if you are just making a finite predetermined number of requests for input the method you were using would work.
20:20:52 <mm_freak_> can i run multiple caba-dev installations in parallel or will that cause trouble?
20:20:56 <mm_freak_> cabal-dev
20:20:58 <PatrickRobotham> applicative: I'm currently making a bit guesser.
20:21:05 <applicative> though there isn't any need for shadowing, if there are three requests and three numbers they are all available at any time anyway, as is [a,b,b]
20:21:55 <PatrickRobotham> applicative: The idea is that you follow some algorithm to generate bits, and the program learns how to guess accurately.
20:23:17 <applicative> well, you might try this, for a start -- the names of the operations in Data.IORef are pretty hideous -- then ask someone how to StateT-ify it later.
20:23:41 <PatrickRobotham> applicative: Ok. Thankyou.
20:25:54 <Rotaerk_> hmm... is there a meaning to ($x) which is different from ($ x)
20:26:10 <aavogt> maybe in template haskell
20:26:22 <Rotaerk_> oh.. that could explain it
20:26:42 <Rotaerk_> was getting a stage restriction error, and the fix was to add the space
20:30:41 <PatrickRobotham> applicative: If I make an IORef thing, can I use that in a while loop?
20:31:20 <PatrickRobotham> applicative: Like, will IORef work the way you'd expect in forever?
20:36:23 <parcs> mm_freak_: i have proposed to work on parallelizing ghc for gsoc
20:38:00 <ddfisher> hey shachaf, can I ask you a quick lens question?
20:42:45 <mm_freak_> parcs: ah, great
20:43:38 <johnw> ddfisher: he's going to tell you not to ask to ask
20:44:20 <ddfisher> johnw: thanks: I forgot the etiquette
20:44:49 <mm_freak_> PatrickRobotham: not sure if i'm understanding your question correctly, but the only way to create a new IORef is to perform newIORef
20:44:53 <johnw> some of us are more sensitive about that than others :)
20:45:37 <johnw> edwardk: pingalicious
20:45:43 <edwardk> sup
20:45:47 <johnw> wow, that was fast
20:45:52 <shachaf> ddfisher: Sure. There's also #haskell-lens
20:45:58 <Hermit> PatrickRobotham: think of an IORef as a mutable slot. Once you create one such slot, you are to keep it in scope as long as needed, and then you can update it's content whenever you want
20:45:59 <johnw> i thought you'd have an answer to my question in ##categorytheory
20:46:17 <johnw> edwardk: if you've got time, now would be a great time to review analytics with you again
20:46:23 <ddfisher> shachaf: Thanks!
20:46:28 <edwardk> kk
20:46:30 <shachaf> (In general, like johnw said, you should just ask your question to the channel.)
20:46:36 <edwardk> let me get my phone =)
20:47:09 <ddfisher> shachaf: I seem to be able to add tuples component-wise with += in the State monad.  How do I do so otherwise?
20:47:25 <mm_freak_> PatrickRobotham: in haskell there is the universal rule that "=" means "is equal to", not "is assigned the following", so if you say "ref1 = ref2", then there is absolutely no difference between ref1 and ref2, so they are the same reference
20:48:10 <johnw> mm_freak_: I guess putIORef and poke are the closest things we have to assignment, eh?
20:48:12 <shachaf> Well, there's no Num instance for tuples. (1,2) + (3,4) won't work either.
20:48:29 <mm_freak_> johnw: we have many more things there =)
20:48:40 <mm_freak_> johnw: also you probably mean writeIORef ;)
20:48:41 <johnw> don't they all boil down to those two, though?
20:48:44 <johnw> yeah, writeIORef
20:48:45 <mm_freak_> it's "put" for MVar
20:48:50 <johnw> shows you that I use MVar way more
20:48:50 <shachaf> Depending on what you're doing, you could make a more specialized type with a Num instance or write a function to add tuples.
20:48:51 <mm_freak_> johnw: no
20:48:56 <shachaf> Probably making a Num instance isn't a good idea.
20:49:14 <mm_freak_> johnw: they all boil down to mutable memory, but almost none of them are implemented in terms of IORef
20:49:23 <mm_freak_> thing of MVector, MArray, etc.
20:49:26 <mm_freak_> think
20:49:38 <johnw> true
20:49:39 <mm_freak_> and of course you've got your MVars, TVars, etc.
20:50:00 <johnw> and your TMVars!
20:50:16 <latermuse> is there a library for streaming video or audio via http?
20:50:40 <johnw> latermuse: there are certainly libraries for streaming any byte sequence
20:50:51 <mm_freak_> latermuse: there are HTTP libraries for that support streaming, but you have to handle seeking yourself
20:51:01 <mm_freak_> latermuse: WAI and snap-server both support streaming
20:51:12 <latermuse> i see. thats wonderful!
20:51:33 <latermuse> can http-conduit/pipes do it?
20:51:57 <mm_freak_> latermuse: WAI is based on conduit, and pipes can do it in principle, but there is no HTTP implementation based on pipes yet
20:52:14 <mm_freak_> snap-server is currently based on enumerators
20:52:35 <latermuse> Is there work on http pipes going on?
20:52:46 <mm_freak_> none that i'm aware of
20:53:05 <mm_freak_> currently some basic libraries are missing for pipes, most notably pipes-bytestring
20:53:40 <latermuse> Thats unfortunate. I havent had a chance to play with pipes yet
20:53:47 <mm_freak_> i'm currently working on a pipes-bytestring library, but the author of pipes has a similar project‚Ä¶  i mailed him about merging the projects, but he didn't reply yet
20:54:21 <Rotaerk_> aww, the "cons x to" operator is cute
20:54:23 <Rotaerk_> (x :)
20:54:41 <mm_freak_> Rotaerk_: so is the "finish list" operator, (:[]) ;)
20:54:50 <Rotaerk_> heh
20:55:08 <ddfisher> shachaf: I'm just confused because += appears to work o_0
20:55:14 <mm_freak_> and the "is less than three" predicate is lovely
20:55:17 <mm_freak_> (<3)
20:55:57 <shachaf> ddfisher: Oh, I misread that.
20:56:04 <shachaf> ddfisher: I thought you said it wasn't working.
20:56:17 <shachaf> ddfisher: Do you have NumInstances or something imported, maybe?
20:56:47 <shachaf> > (1,2) + (3,4) -- works with Data.NumInstances
20:56:49 <lambdabot>   (4,6)
20:56:58 <ddfisher> shachaf: Just found it.  It *was* in another library
20:57:20 <latermuse> I like this operator:  (.)(.)
20:57:28 <ddfisher> shachaf: weird, though - I tried in ghci earlier with that library imported and it didn't work
20:57:30 <ddfisher> huh
20:57:41 <ddfisher> well thanks!
20:58:19 <latermuse> > (.)(.) (\x y -> x + y) 3 (\x -> x + 3) 1
20:58:20 <lambdabot>   7
20:58:59 <ab9rf> @pl \a b -> (.)(.) (\x y -> x + y) a (\x -> x + 3) b
20:58:59 <lambdabot> (. (3 +)) . (+)
20:59:12 <ab9rf> @unpl (. (3 +)) . (+)
20:59:12 <lambdabot> (\ e h -> e + (3 + h))
20:59:26 <Rotaerk_> > (.)(.) (+) 3 (+3) 1
20:59:28 <lambdabot>   7
20:59:56 <ab9rf> @unpl (.)(.)
20:59:57 <lambdabot> (\ b c e f -> b c (e f))
21:00:27 <latermuse> boob operator
21:00:53 <ab9rf> @unpl (.).(.)
21:00:53 <lambdabot> (\ i b c f -> i (b c f))
21:01:01 <ab9rf> @unpl (.)$(.)
21:01:01 <lambdabot> (\ b c e f -> b c (e f))
21:01:14 <ab9rf> you can push cash between the boobs if you want but it doesn't change anything
21:01:24 <Rotaerk_> lol
21:01:26 <mm_freak_> my favorite operator is (.)
21:01:59 <ab9rf> @unpl (.)8(.)
21:02:00 <lambdabot> (\ c -> 8 (\ e f -> c (e f)))
21:02:16 <ab9rf> heh, need numinstances for that
21:02:21 <ab9rf> @unpl (.)*(.)
21:02:22 <lambdabot> ((\ a b c -> a (b c)) * \ d e f -> d (e f))
21:02:34 <mitchell> hi, trying to write a do statement for a parser with this grammar: <term> ::= not <expr> | <factor>
21:03:24 <mitchell> oh and here is the data type
21:03:25 <mitchell> data Exp  =  Zero | One | TT | FF | Read | I Ide | Not Exp | Equal Exp Exp | Plus Exp Exp
21:03:32 <latermuse> mitchell: what do you have so far? hpaste.com
21:03:37 <mitchell> ok
21:03:56 <Clint> .org
21:04:03 * latermuse oops
21:04:13 <hpaste> mitchel pasted ‚Äúparser‚Äù at http://hpaste.org/86786
21:04:16 <ab9rf> :t (.)*(.)
21:04:18 <lambdabot> Num c => (b -> c) -> (a -> b) -> a -> c
21:05:03 <ab9rf>  (.)*(.) (+3) (*3) 5
21:05:07 <ab9rf> > (.)*(.) (+3) (*3) 5
21:05:09 <lambdabot>   *Exception: show: No overloading for function
21:05:32 <ab9rf> :t (.)*(.) (+3) (*3) 5
21:05:35 <lambdabot> Num c => (b -> c) -> (a -> b) -> a -> c
21:06:29 <mitchell> latermuse: do you want to see the parsing module?
21:07:06 <latermuse> mitchell: what are you having trouble doing?
21:07:49 <mitchell> writing a do block for term
21:08:11 <mitchell> <term> ::= not <expr> | <factor>
21:08:15 <mitchell> that is the grammar
21:08:26 <monochrom> mitchell: I think it's pretty clear that it should be do { symbol "not"; e1 <- expr; return (Not e1) }? I mean, you have all the rest of the code to draw inspiration from
21:08:30 <mitchell> it's a parser for the language tiny
21:09:22 <mitchell> hmm that is what i had at first
21:09:28 <mitchell> let me try again
21:10:37 <mitchell> ahhh
21:10:40 <mitchell> thankyou
21:10:52 <mitchell> makes sense now
21:15:04 <chrisdotcode_> hello everyone :)
21:15:46 <davidfstr> chrisdotcode_: hello
21:15:59 <chrisdotcode_> hi davidfstr
21:16:16 <davidfstr> my own question for the room...
21:16:18 <davidfstr> Many languages have some kind of killer library or killer app. Python has Django. Ruby has Ruby on Rails. C has trivial access to the OS and is bindable to by the FFI of all other languages. Does Haskell have one or more in your opinion?
21:17:00 <monochrom> @quote monochrom killer.app
21:17:01 <lambdabot> monochrom says: we need a killer app to kill haskell success
21:17:12 <shachaf> No. Haskell has nothing.
21:17:51 <latermuse> davidfstr: haskell has a big learning curve
21:17:53 <blackdog> davidfstr: ok, i'll bite. Incredibly lightweight concurrency.
21:17:53 * latermuse shrugs
21:17:57 <monochrom> Haskell has FFI to C
21:17:59 <johnw> davidfstr: STM
21:18:04 <chrisdotcode_> so I was reading LYAH, and I saw the Monoid implementation of Maybe, and "Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)" was for the associative identity. is there a way to write that using applicative functors instead of pattern matching?
21:18:21 <chrisdotcode_> something like mappend <*> Just m1 <$> Just m2? Is that right?
21:18:41 <davidfstr> johnw: STM = Software Transactional Memory? This is available in certain Haskell implementations?
21:18:58 <johnw> davidfstr: correct
21:19:40 <johnw> davidfstr: Parsec
21:19:40 <davidfstr> interesting - I was reading about STM some time ago - as I recall the C#/NET folks were having a lot of trouble implementing it on their end
21:20:03 <aavogt> chrisdotcode_: mappend m1 m2 = mappend <$> m1 <*> m2
21:20:51 <davidfstr> Parsec does have very nice composable parsers (based on my reading) - I've also heard a colleague mention Parsec too as a potential killer library
21:20:58 <mm_freak_> davidfstr: haskell has three major web frameworks (happstack, snap, yesod) all used in practice, and in one of them (happstack) there is a CMS (clckwrks) coming up soon
21:21:04 <chrisdotcode_> aavogt: so if I wanted the result  wrapped in a maybe, I'm correct?
21:21:15 <mm_freak_> davidfstr: other commonly used applications include pandoc and xmonad
21:21:59 <johnw> and git-annex
21:22:09 <aavogt> chrisdotcode_: it has to be wrapped in a Maybe, if you're still talking about writing instance Monoid a => Monoid (Maybe a)
21:22:30 <latermuse> I enjoy building custom CMS for most of my haskell projects
21:22:33 <chrisdotcode_> aavogt: yeah, I am... so am I wrong in my guess?
21:22:34 <mm_freak_> davidfstr: there is also a not very sophisticated, but easy to use mediawiki clone called gitit
21:23:09 <johnw> there's also Yesod
21:23:19 <mm_freak_> i mentioned that one
21:23:50 <aavogt> chrisdotcode_: you used <*>  and <$> in wrong order... but maybe that's close enough to the definition I gave you to say your guess is right
21:24:11 <mm_freak_> davidfstr: last but not least in my non-exhaustive list is hakyll, a sophisticated static site generator
21:24:29 <mm_freak_> oh, and hledger
21:24:38 <chrisdotcode_> aavogt: confusing <$> and <*> at this stage isn't so bad for me :)
21:24:46 <chrisdotcode_> aavogt: so <$> gives us a pure?
21:25:27 <latermuse> (<$>) :: Functor f => (a -> b) -> f a -> f b
21:25:53 <chrisdotcode_> lambdabot: type <*>
21:25:59 <chrisdotcode_> lambdabot: :t <*>
21:26:07 <chrisdotcode_> er...
21:26:22 <aavogt> :t (<*>)
21:26:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:26:53 <chrisdotcode_> ...right >_>
21:28:11 <aavogt> so you could define (<$>) with this:   f <$> x = pure f <*> x
21:28:34 <lightquake> vinyl scares and excites me
21:28:47 <monochrom> killer app is a double-edged sword, and I see only the pessimistic side of it. it becomes a stereotype. look at Ruby. you say "Ruby", and people are only going to answer "Ruby on Rails!", as though Ruby is no good for absolutely anything else. also, Scala and Clojure do not have killer apps (as far as I've heard), and no one needs one --- people like Scala and Clojure just for how they do OO better, no killer app needed. (and
21:28:47 <monochrom>  oh, "can run on JVM" is not a killer app, because JVM have one itself)
21:29:12 <monochrom> err, s/because JVM have one itself/because JVM doesn't have one itself/
21:29:23 <blackdog> monochrom: "can run on JVM" and "isn't Java" might be though :)
21:29:39 <davidfstr> blackdog: ha ha - true
21:30:26 <lightquake> haha
21:30:56 <mm_freak_> monochrom: to be fair, ruby isn't even good for ruby on rails =)
21:32:30 <davidfstr> Well I think the presence of a killer library or framework is very useful for attracting people to a language. In the particular case of Rails, it appears that a large fragment of the web community was sucked out of PHP (thank goodness) and a lot of support tooling related to dependency management, continuous integration, etc have found its way onto Ruby.
21:32:41 <ab9rf> i'm still unclear on how ruby on rails happened
21:32:52 <ab9rf> ruby languished in obscurity for years before someone glued it to rails
21:33:07 <chrisdotcode_> ...yeah, how *did* something like that happen?
21:33:08 <zomg> I'm sure DHH has written some self important blog about it
21:33:09 <zomg> =)
21:33:34 <mm_freak_> i think that haskell actually benefits from its killer apps without distracting from the language
21:33:39 <davidfstr> As I understand the history, there basically were no good web frameworks before Rails. Rails was the first reasonable framework. That it was written in Ruby I think was pure happenstance.
21:33:56 <mm_freak_> in most cases you have a great app built upon a sucky language, but in the case of haskell you have great apps built on a great language, so i don't really mind
21:34:01 <davidfstr> (Of course I like many other frameworks better than Rails.)
21:34:02 <ab9rf> davidfstr: that's presuming that you consider rails a "good web framework"
21:34:12 <davidfstr> A *reasonable* framework. :-)
21:34:20 <chrisdotcode_> ab9rf: is rails that bad?
21:34:27 <ab9rf> chrisdotcode_: i have no idea, haven't used it
21:34:34 <chrisdotcode_> haha
21:34:36 <Guest19421> currently rails is pretty bad
21:34:42 <mm_freak_> chrisdotcode_: when i tried to learn it it felt like a giant piece of patchwork
21:35:01 <ab9rf> the main problem with rails is that it's implemented in ruby, which has a gawdawful runtime
21:35:04 <mm_freak_> so "ruby languished in obscurity for years before someone glued it to rails" is pretty precise
21:35:19 <davidfstr> Rails has a awful lot of magic in it. If you make a mistake the error messages you get out of it can be quite incomprehensible.
21:35:20 <zomg> Rails seems decent enough. Been using it at current contract work
21:35:21 <Guest19421> its bad in terms of performance, sense-making,
21:35:35 <zomg> but the statement that it was the first reasonable one.. eh, hard to say
21:35:37 <cmccann> rails is like if you took all the magic metaprogramming in yesod, and removed all the type safety and performance
21:35:41 <chrisdotcode_> mm_freak_: yeah, I'll stick with my haskell and python...
21:35:43 <zomg> I'm pretty sure for example Django was around at the time Rails was
21:35:56 <ab9rf> ruby is an interesting language, it's not really any worse than the rest of the gaggle of dynamic duck-typed languages
21:36:04 <chrisdotcode_> django is too "enterprisey" for me.
21:36:05 <ab9rf> but it has a crappy runtime
21:36:08 <mm_freak_> it's fine to get the idea right, before you get the performance right, so i don't measure the general quality of a web framework in terms of its speed
21:36:13 <davidfstr> zomg: Really? I'll have to check that.
21:36:22 <mm_freak_> after all about everything is an improvement over PHP
21:36:27 <davidfstr> Yeah.
21:36:37 <ab9rf> it seems to be getting better simply because of all the attention given to it because of rails
21:36:39 <Guest19421> s/php/cgi c/
21:36:42 <cmccann> Ruby is cute for what it is, which is a goofy mishmash of perl and smalltalk with a bit of lisp
21:36:50 <chrisdotcode_> how many RPS can yesod or snap get?
21:36:54 <chrisdotcode_> * manage
21:37:00 <ab9rf> mm_freak_: it's hard to surpass PHP in terms of suckitude
21:37:08 <Guest19421> php is a strawman
21:37:27 <zomg> it's funny how people still manage to build software in PHP even though it sucks so hard according to everyone
21:37:31 <ab9rf> chrisdotcode_: both yesod and snap can hold their own with other frameworks
21:37:52 <davidfstr> However the one thing PHP got right was it completely solved the deployment problem.
21:37:59 <ab9rf> zomg: yeah, and how many of those apps have SQL injections, XSS vulnerabilities, and generate strange error messages if you click on them wrong?
21:38:05 <mm_freak_> IMO the problem is with OO itself‚Ä¶  the OO paradigm as understood by most languages makes pretty much everything difficult, regardless of whether you're using duck typing, C++ inheritance, etc.
21:38:07 <shachaf> This sounds kind of off-topic by now.
21:38:12 <chrisdotcode_> ab9rf: but then again, that's not saying much... if "holding your own" means "being faster than everything except Node, and *maybe* Go", then that seems quite eeasy...
21:38:22 <copumpkin> @let twice = join (++)
21:38:25 <lambdabot>  Defined.
21:38:34 <ab9rf> chrisdotcode_: there are performance numbers on one of the Snap developer blogs, iirc.
21:38:36 <mm_freak_> OO makes it difficult to identify and enforce sound design
21:38:46 <Guest19421> bringing it back to haskell, direct-fastcgi seems absolutely borked at this point
21:39:04 <chrisdotcode_> ab9rf: not dissing Haskell, of course :-)
21:39:06 <ab9rf> mm_freak_: i'm starting to agree with that point of view
21:39:19 <zomg> ab9rf: how many of badly written programs in any language have those?
21:39:32 <mm_freak_> davidfstr: PHP doesn't solve the deployment problem‚Ä¶  it's simply that you don't have to deploy it in most cases
21:40:15 <davidfstr> mm_freak_: That's good enough to solve it in practice.
21:40:45 <cmccann> php is great for hammering screws in quickly and then moving on before it all falls apart
21:41:08 <applicative> PatrickRobotham: I vanished, here's a half-thought variant with a meaningless sort of loop that keeps 'mutating' an IORef https://gist.github.com/applicative/5479524
21:41:37 <mm_freak_> davidfstr: not really‚Ä¶  every felt that your PHP application is ready for deployment, deployed it and caused irreversible damage?  that's because PHP applications always come with a huge number of environment assumptions
21:41:47 <ab9rf> one downside to the haskell web frameworks is that they're typically deployed as a compiled executable.  this makes hotswapping a bit challenging, although in practice when you're running in a LB environ,ent you'd just down each node in turn and coldswap it.
21:42:07 <zomg> mm_freak_: only if a) the program is written like shit b) your deployment practices are shit
21:42:10 <zomg> :P
21:42:14 <PatrickRobotham> applicative: Thanks. I've got something working now.
21:42:24 <ab9rf> mm_freak_: i don't want to burn channel BW harping on how bad PHP is, we all have a pretty good feel for that, i suspect
21:42:26 <chrisdotcode_> so does hotswapping a la erlang actually work in production? or do you need to coldswap anyway?
21:42:31 <zomg> You can deploy any web app on a server that's differently configured than the one you tested it on
21:42:32 <copumpkin> > ((map last . sort) .) . zipWith (++) <$> tails <*> init . inits $ [1,2,3,1,2,4,3,3,2]
21:42:33 <mm_freak_> zomg: wrong‚Ä¶  turn on magic_quotes and your apps are likely to break
21:42:34 <zomg> and it will break
21:42:36 <lambdabot>   mueval-core: Time limit exceeded
21:42:36 <zomg> no matter if it's PHP or not.
21:42:41 <copumpkin> > ((map last . sort) .) . zipWith (++) <$> tails <*> init . inits $ [1,2,3,1,2,4,2]
21:42:43 <lambdabot>   [2,3,4,1,1,2,2]
21:42:46 <zomg> mm_freak_: so stop configuring your servers badly
21:42:53 <ab9rf> copumpkin: wtf
21:43:03 <zomg> saying it will break if you change a setting that completely changes the behavior of certain aspects is pretty silly
21:43:03 <copumpkin> ab9rf: what?
21:43:11 <zomg> you can change settings like that in many languages and the programs will break
21:43:12 <zomg> :P
21:43:24 <monochrom> isn't it just loading a mod_php on apache? meaning it is no different from mod_perl mod_cgi etc? and if I make a mod_hugs then you can start writing <?haskell unsafePerformIO foo ?> which is just as good? and also doesn't that limit you to apache, so for example you can't deploy on, say, Netscape Server?
21:43:30 <ab9rf> what the hell does that do?
21:43:37 <copumpkin> @let bwt = ((map last . sort) .) . zipWith (++) <$> tails <*> init . inits
21:43:39 <copumpkin> :t bwt
21:43:44 <cmccann> monochrom: mod_hugs hahaha
21:43:58 <mm_freak_> zomg: that's not the point‚Ä¶  it's just the one example that came to my mind‚Ä¶  PHP applications will work fine with reasonableConfiguration1 and fail terribly with reasonableConfiguration2, because handling every possible combination of the giant mess of run-time configuration parameters is next to impossible
21:44:01 <copumpkin> I actually @pl'd that in my head too
21:44:01 <ab9rf> monochrom: PHP has a gazillion configuration settings, the defaults are fairly stupid, and many webhosts change them but not to anything consistent.
21:44:03 <copumpkin> I wonder if it's correct
21:44:06 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
21:44:08 <lambdabot>     Not in scope: `bwt'
21:44:08 <lambdabot>     Perhaps you meant `bit' (imported from Data.Bits)
21:44:15 <ab9rf> monochrom: and some of hem have _huge_ behavioral implications
21:44:17 <chrisdotcode_> E_ALL anyone?
21:44:19 <copumpkin> @let bwt = ((map last . sort) .) . zipWith (++) <$> tails <*> init . inits
21:44:19 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
21:44:23 <copumpkin> wtf
21:44:28 <copumpkin> it just worked
21:44:46 <zomg> mm_freak_: how hard is it to deploy two servers with identical configurations? It's super easy
21:45:03 <lightquake> "mod_hugs" is a phrase that terrifies me immediately
21:45:04 <mm_freak_> zomg: and often impossible
21:45:04 <chrisdotcode_> copumpkin: o_O
21:45:04 <DigitalKiwi> http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
21:45:09 <ab9rf> lightquake: heh
21:45:11 <zomg> mm_freak_: only if your sysadmin is a retard
21:45:17 <lightquake> zomg: don't use that word
21:45:19 <copumpkin> ab9rf: if I got it right, it should be the burrows-wheeler transform
21:45:30 <ab9rf> copumpkin: i suppose i ought to google that
21:45:32 <zomg> lightquake: replace it with your favorite insult indicating lack of brains then ;)
21:45:50 <copumpkin> ab9rf: it's some secret sauce that goes into lots of compression schemes
21:45:52 <mm_freak_> zomg: no, if you have to have different configurations on different hosts‚Ä¶  not every application runs from a single host, and from time to time you may have to change your infrastructure
21:46:16 <ab9rf> it's fairly common for there to be minor differences between different members of the same webfarm
21:46:21 <cmccann> the ability to work around all of php's shortcomings by being sufficiently competent and/or lucky does not really change the fact that writing a solid web app is easier in basically any other language
21:46:27 <copumpkin> ab9rf: it's basically a fancy permutation of the input that tends to put strings of identical elements together if they can be put together, so RLE works nicely
21:46:29 <ab9rf> servers 13-20 are on build 13 but servers 21-40 are on build 14, and so forth
21:46:29 <chrisdotcode_> and let's not mention which PHP version you have to pattern match, er- make sure is the same.
21:46:34 <zomg> mm_freak_: if you can give me a concrete example of that and I can't find anything wrong with it, I'll admit I'm wrong ;)
21:46:36 <copumpkin> ab9rf: but you can derive the input from it
21:46:38 <mm_freak_> zomg: but consider this:  for a happstack application i don't have to care whether my sysadmin is a retard‚Ä¶  when he manages to compile my app, it will work
21:46:41 <ab9rf> copumpkin: interesting
21:46:42 <davidfstr> I think PHP is popular not particularly due to its merits but rather because it was the first popular system to generate dynamic web pages.
21:46:49 <chrisdotcode_> ^
21:47:02 <zomg> mm_freak_: that's like saying if my sysadmin manages to change a few configuration settings that I tell him it will work :P
21:47:31 <ab9rf> davidfstr: sure, network effect.  it's _everywhere_, and therefore people use it.  rater like HTML, CSS, and javascript, even though that combination is _absolutely atrocious_ as a platform for delivering applications.
21:47:49 <mm_freak_> zomg: i can only tell you that i have worked in many large PHP projects in the past, and it would be very arrogant of you to say that all my teammates were idiots
21:47:51 <blackdog> ab9rf: depends how far you push the whole chef/puppet automation sort of thing
21:48:07 <blackdog> when all your boxes are identical and disposable, it does make it a lot easier to spin up and down
21:48:17 <cmccann> pretty much everything involved in web dev is objectively terrible but used anyways because it's what become randomly widespread
21:48:22 <zomg> mm_freak_: as have I and I've never had problems with it when we had control over the servers
21:49:05 <cmccann> php is just the most hilariously and inexplicably awful part of the whole mess that is the web dev ecosystem at large
21:49:09 <h4199> What are you talking about ab9rf? HTML and CSS3 are turing complete, No need for PHP or Javascript!
21:49:32 <mm_freak_> zomg: PHP is simply designed that way‚Ä¶  an unmanageable bulk of global variables, including but not limited to the run-time configuration aka php.ini‚Ä¶  if you program carefully enough you can prevent most bugs, but often you simply can't predict the target system configuration
21:49:46 <ab9rf> cmccann: the whole web app platform is a giant rube goldberg machine, it's amazingany of it works at all.
21:49:56 <davidfstr> Yeah. I'll agree that web dev is pretty much a mess. However that's where commercial app development is headed these days (that and smart phones) - so you typically have to learn it as a dev.
21:49:58 <cmccann> ab9rf: yeah seriously
21:50:23 <applicative> copumpkin: when you figure out a suitable one liner you can update the wikipedia article putting it side by side with the python http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform#Sample_implementation
21:50:25 <cmccann> davidfstr: I've done my own share of it, trust me :]
21:50:27 <ab9rf> i'm kinda hoping that smartphones eventually kill web apps
21:50:31 <zomg> mm_freak_: you don't predict it, you define it ;)
21:50:53 <ab9rf> browsers are so heavyweight these days that they're expensive to run on smartphones, which is why we have so many smartphone apps
21:50:54 <mm_freak_> zomg: from that statement it's hard to believe that you've worked on large projects
21:50:55 <zomg> And if someone in your team uses globals.. well, just fire them
21:50:56 <zomg> lol
21:51:11 <zomg> mm_freak_: Maybe I've just been lucky to work with reasonable people
21:51:16 <cmccann> zomg: if you have that kind of absolute control over how things happen, the real question is why on earth you're using PHP in the first place
21:51:21 <mm_freak_> zomg: yeah, that might be it
21:51:42 <zomg> cmccann: in most cases it was because that's where the skillset of available people for the project was
21:51:51 * applicative is hoping the entire internet will just come crashing down sometimes soon, thats why he loves php so much 
21:52:12 <zomg> Of course I'm exaggerating the "fire them" bit
21:52:21 <zomg> Usually it would just be a stern talk to not use globals
21:52:22 <zomg> ;)
21:52:23 <blackdog> cmccann: there are certainly many smart devs at facebook, for example...
21:52:39 <mm_freak_> zomg: no, you're not exaggerating‚Ä¶  i'd be happy to fire stupid programmers, but the problem is seldomly with the programmers
21:52:54 <zomg> hehe
21:53:07 <lightquake> i'm getting a build error when trying to install cabal-install-1.16.0.2
21:53:10 <lightquake> on ghc 7.6.2
21:53:43 <lightquake> oh, mumble wrong library version
21:54:39 * cmccann has a hard time imagining a development team competent enough to use PHP without screwing up that would actually willingly use PHP at all
21:54:51 <blackdog> cmccann: again: Facebook.
21:55:03 <mm_freak_> the only thing PHP is really good at is what it was originally developed for:  putting a visitor count on your web page
21:55:04 <blackdog> bos is there, for $deity's sake.
21:55:11 <cmccann> blackdog: ok, if you pay people enough I guess so.
21:55:22 <mm_freak_> that's about the only thing you can achieve with less code and less deployment hassle in PHP than in haskell
21:55:28 <h4199> Doesn't Facebook use a rewritten version of the language?
21:55:32 <monochrom> perhaps it was just because Mark Zuckerberg started with PHP and now it's too late to switch
21:55:43 <ab9rf> h4199: they use a PHP translator called HHVM
21:55:46 <chrisdotcode_> h4199: they use PHP, but it's compiled to C++ with the hiphop vm
21:55:52 <chrisdotcode_> ninja'd
21:55:52 <mm_freak_> h4199: because the interpreter sucks they've written a PHP compiler called hiphop
21:55:53 <h4199> Ah
21:55:59 <cmccann> compiling PHP to C++ is still hilarious on multiple levels
21:56:02 <ab9rf> h4199: originally it compiled to C, but now it's a JIT compiler to a virtual machine
21:56:08 <zomg> cmccann: it seems a common problem with many people to understand that people can use tools that aren't perfect :P
21:56:15 <blackdog> there are many fascinating things about deployment at facebook :)
21:56:24 <mm_freak_> funny enough that just reimplementing everything in a real programming language instead of writing a PHP compiler would probably have taken less time
21:56:26 <davidfstr> monochrom: +1. Rewriting a mission critical app can kill your company.
21:56:32 <ab9rf> hiphop would generate a monolithic executable for the _entire_ site
21:56:39 <blackdog> using bittorrent for deploying the multi-gigabyte executables that make up your site, for one
21:56:42 <ab9rf> but the compiler took _forever_ to run and it made deployment insanely difficult
21:56:42 <chrisdotcode_> also ironically, the PHP repl, developed at facebook, is written in python...
21:57:12 <blackdog> chrisdotcode_: has to be, i think - PHP uses exit() liberally
21:57:13 <ab9rf> so they switched to a VM that does JIT compilation of the PHP files
21:57:17 <ab9rf> it's a subset of PHP, actually
21:57:26 <ab9rf> there are some constructs that are illegal in hiphop
21:57:27 <chrisdotcode_> blackdog: yeah, it actually is :)
21:57:43 <chrisdotcode_> I was laughing so hard at "ironically, it is written in python"
21:57:52 <davidfstr> Anyway, I'm done bashing PHP for today. That was a fun romp through languages. Thank you #haskell for the tips on Haskell projects to check out. Particularly, mm_freak_.
21:58:02 <ab9rf> chrisdotcode_: i saw someone on github who is trying to write a static type checker for PHP .... in PHP
21:58:34 <h4199> Stop, I need to catch my breath
21:58:36 <mm_freak_> davidfstr: you're welcome‚Ä¶  if you write papers/presentations/books etc. you can get started with pandoc today ;)
21:58:38 <chrisdotcode_> ab9rf: ...ouh >_>
21:58:42 <dsturnbull> i didn't think that was possible. i saw a preso on someone who tried to write a php compiler, and it's just too shitty.
21:58:43 <chrisdotcode_> *ouch
21:58:46 <ab9rf> PHP's grammar is so convoluted that i get hives thinking about just trying to write a parser for PHP
21:58:50 <cmccann> zomg: oh, I understand that people use shitty tools when better stuff exists. I don't respect that, but I acknowledge that it happens.
21:59:06 <ab9rf> well, writing one in PHP that is
21:59:16 <ab9rf> i _have_ a PHP parser.  written in Haskell (mostly in Happy)
21:59:22 <mm_freak_> writing a PHP parser /in/ PHP?
21:59:25 <mm_freak_> number of bugs squared?
21:59:26 <ab9rf> mm_freak_: yes
21:59:28 <cmccann> zomg: there are reasons why the state of the software development industry is as terrible as it is
22:00:01 <ab9rf> i cheated and sucked the grammar out of PHP's source and mashed it up (mostly by stripping crap out) and made it into a Happy grammar
22:00:03 <chrisdotcode_> alright, about to start the monads chapter of LYAH! wish me Godspeed! :D
22:00:17 <ab9rf> the AST is fairly bad, basically unusable, at this point
22:00:43 <blackdog> ab9rf: i had a PHP job last year.
22:01:06 <blackdog> so i thought "hey, how bad can it be. i can write ruby without gagging. it'll be ok, we'll gradually rewrite to something better"
22:01:10 <ab9rf> dsturnbull: the largest problem with PHP is dealing with the large number of operatins that interact with the local symbol table.  implementing those in a compiler is _hard_
22:01:16 <blackdog> and then you realise that every feature conflicts with every other feature
22:01:33 <dsturnbull> and then you /wrists?
22:01:56 <ab9rf> dsturnbull: i mean, $$$$$$$var1 = $$$$$$$$var2 is entirely legal in PHP
22:01:58 <blackdog> you wanted to use closures _and_ OO? Have i got news for you: every closure call is considered an external access! You don't mind making every method and variable public, do you?
22:02:10 <ab9rf> try to compile _that_
22:02:13 <dsturnbull> what if you hide all the php behind an elaborate OO front, blackdog?
22:02:18 * hackagebot persistent 1.2.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.0 (MichaelSnoyman)
22:02:20 * hackagebot persistent-mongoDB 1.2.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.2.0 (MichaelSnoyman)
22:02:22 <dsturnbull> i.e. java style, make a crappy DSL
22:02:22 * hackagebot persistent-mysql 1.2.0 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.2.0 (MichaelSnoyman)
22:02:24 * hackagebot persistent-postgresql 1.2.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.2.0 (MichaelSnoyman)
22:02:25 <lightquake> my favorite thing about php is that $this = "foo" is illegal but $x = "this"; $$x = "bar" is legal
22:02:44 <ab9rf> lightquake: ugh.
22:02:52 <blackdog> dsturnbull: i got an elaborate OO front for free with the language, cheers.
22:03:10 <blackdog> and worst, WORST, is the PHP dev with pattern envy
22:03:20 <applicative> ab9rf: didn't you write something that could then render the php as haskell modules?  someone did.
22:03:26 <ab9rf> applicative: not me
22:03:32 <ab9rf> applicative: although i've thought about that.
22:03:46 <blackdog> applicative: i remember hearing about that, but then never heard about it again
22:04:04 <ab9rf> applicative: it's damnably hard to do a complete translation of PHP, but most PHP developers don't make much use of the worst constructs
22:04:21 <applicative> maybe I was thinking of this https://github.com/jhartikainen/hs-language-php
22:04:36 <ab9rf> applicative: and the restricted subset of PHP that is fairly easy to translate covers a good portion of PHP code
22:05:11 <ab9rf> applicative: it also depends on how many of PHP's bugs you choose to faithfully implement :)
22:05:11 <applicative> there seem to be a number of haskell 'language-php' s around, may be they all give up in despair in the end
22:05:35 <blackdog> applicative: i wrote a phpskell repo, but purely to bug the other FP guy at work :)
22:07:16 <chrisdotcode_> ab9rf: https://xkcd.com/1172/ :)
22:07:26 * hackagebot persistent-sqlite 1.2.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.2.0 (MichaelSnoyman)
22:07:27 <ab9rf> chrisdotcode_: yes
22:07:28 * hackagebot persistent-template 1.2.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0 (MichaelSnoyman)
22:07:30 * hackagebot pool-conduit 0.1.2 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.2 (MichaelSnoyman)
22:08:07 <ab9rf> chrisdotcode_: i know for a fact that there are PHP developers who rely on buggy behavior in PHP, and the fact that there are people relying on buggy behavior is part of why the PHP devs won't fix obvious bugs.
22:08:24 <chrisdotcode_> ab9rf: right. it's a sad, sad, cycle...
22:08:39 <ab9rf> it's also because the PHP devs are a bunch of gits, but that's aside the point
22:09:40 <zomg> ab9rf: yeah having seem some of the discussions in the php internals mailing list... holy shit
22:11:35 <ab9rf> zomg: they're also idiots.  i'm not sure anybody there understands how to write a bison grammar.
22:12:27 <h4199> buffalo buffalo buffalo buffalo buffalo buffalo buffalo?
22:13:21 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/83292/
22:13:23 <ab9rf> the way they added namespaces to the grammar evinces either that they don't know how to add a new nonterminal to the grammar, or that they're not being allowed to do so
22:14:14 <ab9rf> so namespace parsing is handled by duplicating productions in several different nonterminals depending on which of four namespace syntaxes are being used
22:14:31 <ab9rf> monochrom: hehe, tat's good
22:26:46 <lightquake> why doesn't Identity have Eq or Show instances?
22:30:21 <shachaf> Because you haven't proposed them at libraries@
22:34:25 <chrisdotcode_> funny, I understand monads more than I understand applicative functors...
22:34:43 <chrisdotcode_> well, in terms of the practical. I get them both theoretically.
22:37:25 <cmccann> monochrom: given that type inference already serves as a sort of "name-directed type resolution", I look forward to adding "type-directed name resolution" so that entire programs can be self-resolving without any effort, or comprehension, on the part of the programmer.
23:12:22 * hackagebot conduit 1.0.5 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.5 (MichaelSnoyman)
23:21:53 <adelbertc_> looking for recommendations of a book on haskell? coming from a scala background, familiar with some concepts of functional programming.. a book with exercises in it would be preferred
23:23:12 <aleator> @tell tommd There a still several ref-transparency issues left. It would be nice to get them all.
23:23:12 <lambdabot> Consider it noted.
23:24:39 <cmccann> adelbertc_: LYAH is the standard recommendation for almost everyone but depending on what you've done in scala it might be too basic
23:24:45 <cmccann> @where lyah
23:24:45 <lambdabot> http://www.learnyouahaskell.com/
23:25:00 <cmccann> that said, it's entertaining anyway
23:25:10 <h4199> @where rwh
23:25:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:25:17 <h4199> http://www.haskell.org/haskellwiki/Books
23:25:42 <h4199> http://www.haskell.org/pipermail/beginners/2009-March/001293.html
23:25:53 <cmccann> RWH is a bit dated unfortunately, I think some of the examples don't work as-is anymore? not sure.
23:25:55 <cmccann> it's still solid.
23:26:29 <h4199> depends on the chapter
23:26:51 <h4199> nothing on the newer IO streaming libs
23:27:31 <cmccann> the only chapter I've looked at recently is the profiling stuff
23:28:04 <adelbertc_> ah. that may be a problem. perhaps the best way to jump in then is LYAH, despite there being no exercises
23:28:24 <cmccann> both are pretty approachable I think
23:28:41 <dmwit> Read the Gentle Introduction!
23:28:48 <cmccann> you can probably at least skim through one while/after going through the other
23:29:04 <cmccann> dmwit: that advice seems somewhat suspect.
23:29:20 <dmwit> I loved the Gentle Intro, and I hadn't even done any functional programming before.
23:29:32 <cmccann> it's very no-nonsense as I recall.
23:29:32 <dmwit> For somebody who's already seen ADTs it ought to be a breeze.
23:29:35 <dmwit> yes
23:29:35 <cmccann> nicely to the point.
23:29:42 <dmwit> That is what I liked about it. =)
23:30:12 <cmccann> let me guess, you're the kind of person who prefers reference manuals to drawn-out tutorials when learning something :P
23:30:29 * dmwit smiles a timid smile
23:31:15 <h4199> adelbertc_: did you have a particular kind of exercise in mind?
23:31:36 <cmccann> (to be fair, I've probably spent more time reading the Haskell Report and GHC user guide than anything like RWH or LYAH)
23:32:23 <adelbertc_> h4199: just anything that gives me a self-contained problem (or something that TOO involved)
23:32:56 <dmwit> adelbertc_: You could consider something like "Write Yourself a Scheme in 48 Hours" or whatever that one is called.
23:35:06 <h4199> What about language agnostic problems? project Euler or http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems?
23:36:45 <aleator> material
23:36:45 <lambdabot> aleator: You have 1 new message. '/msg lambdabot @messages' to read it.
23:41:51 <Ralith> I have a program that uses a function :: Int -> Int -> PixelRGB8 to generate an image pixel-by-pixel using JuicyPixels. What's the easiest way to parallelize it?
23:42:53 <latermuse> ralith
23:43:01 <latermuse> split the image in half and do half at a time?
23:43:29 <Ralith> I'm aware of the obvious, yes
23:43:39 <Ralith> what's the easiest way to accomplish that?
23:44:31 <Ralith> I understand that there's several variously-magic parallelism libs which may or may not be applicable
23:45:23 <Ralith> the tricky bit seems to be integrating with JuicyPixels with a minimum of gratuitous copying
23:46:16 <aleator> Ralith: The problem is that juicy manipulates images in ST which is not that easy to parallelize.
23:49:37 <Ralith> aleator: makes sense, but I don't really need to manipulate images in/through juicy.
23:49:47 <Ralith> I'm just using it to encode and write to disk
23:50:56 <aleator> Ralith: If you can live with extra copy on each load/save, then I think easiest way to parallelize is to copy the image to repa.
23:51:40 <aleator> http://hackage.haskell.org/package/JuicyPixels-repa
23:55:40 <Ralith> aleator: this library seems to be exclusively for converting images from juicypixels form to repa; I need the inverse
23:56:53 <aleator> Ralith: If that doesn't have the inverse, I'd go with generateImage from juicy
23:57:20 <Ralith> aleator: generateImage isn't serial?
23:58:22 <aleator> Ralith: It is serial, but I tried to say that you load with juicy, make parallel calculations with repa, and then use generate to get image back to juicy and then save it.
23:58:52 <Ralith> there's copying and then there's pixel-by-pixel copying :/
23:59:00 <Ralith> that's almost as silly as byte-by-byte copying
23:59:45 <aleator> Well, it will anyways take longer for the bytes to hit the platter than to copy.
