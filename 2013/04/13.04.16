00:04:36 <derek_c> davean: are you still here?
00:35:57 <derek_c> :quit
00:46:59 <hpaste> Cale annotated “DP” with “Using Array” at http://hpaste.org/85882#a85886
00:47:06 <Cale> flebron_: ^^
00:47:18 <flebron_> Oh I did it also :)
00:47:37 <hpaste> flebron annotated “DP” with “Using Array (annotation)” at http://hpaste.org/85882#a85887
00:47:42 <flebron_> ^-- mine
00:48:05 <flebron_> The "clean" thing is to clean up input... I am getting some error when trying this over at SPOJ (the problem is TRT).
00:48:48 <flebron_> Thanks :)) (Do you see any obvious inefficiencies in my code?)
00:49:12 <flebron_> (I'm profiling as we speak. Test cases, if you want, are at http://cerberus.delos.com:790/FEB06_9.htm .)
00:49:23 <Cale> Well, we could both do better on the choices of j
00:49:53 <flebron_> :p
00:51:06 <flebron_> Sorry, dc'd.
00:52:46 <Cale> flebron_: also, we could be using smaller arrays indexed from (i+1) to n
00:53:00 <flebron_> So jagged matrices.
00:53:16 <flebron_> The C++ doesn't use those, and runs fine :p
00:53:26 <Cale> sure
00:53:40 <Cale> But it's easy to do :P
00:53:40 <flebron_> (I'm giving Haskell no extra leniency :))
00:53:53 <Cale> This is already a completely different algorithm
00:54:00 <Cale> Once you write it like this
00:54:01 <flebron_> Is it?
00:54:03 <Cale> yes
00:54:16 <flebron_> Well, it's similar to the commented out version in my original one.,
00:54:22 <flebron_> (Recursive, top-down DP.)
00:54:43 <Cale> yeah
00:56:13 <hpaste> Cale annotated “DP” with “DP (annotation) -- tightening some things up” at http://hpaste.org/85882#a85888
00:56:18 <flebron_> Is there a difference between ! by (a, b) vs !a!b?
00:56:30 <Cale> Well, yes
00:56:57 <Cale> The array type is different, and when indexing by a pair, an index into a flat array is computed
00:57:05 <flebron_> (Also, you're using Array vs my UArray)
00:57:56 <Cale> ah, cool, you can get away with UArray
00:58:02 <Cale> hmm
00:58:11 <flebron_> Well not with !a!b
00:58:25 <Eduard_Munteanu> Pair indexing might give you better locality then.
00:58:35 <Cale> Does the UArray version work?
00:59:08 <Cale> Eduard_Munteanu: Your locality will be shit anyway if you're using Array
00:59:20 <Cale> Oh, you're not using UArray
00:59:22 <flebron_> They all work for my test cases, but SPOJ is adding some test case that makes the program return with nonzero
00:59:57 <Cale> You're importing Data.Array.Unboxed, which reexports everything in Data.Array, and then using boxed arrays
01:00:10 <flebron_> Really? I... suck.
01:00:17 <quchen> What's this "<<loop>>" in the recent 7.6.2 bug? Is it a special kind of compilation loop or something? cf http://hackage.haskell.org/trac/ghc/attachment/ticket/7748/GHCLoop.hs
01:00:26 <Cale> I don't think this will work at all with unboxed arrays anyway
01:00:29 <flebron_> How should I use UArray?
01:00:45 <flebron_> Are UArray only indexed by Int, not by Idx?
01:00:49 <Cale> because unboxed arrays get rid of the machinery which allows this recursion to work
01:01:03 <Cale> No, they're indexed by Ix
01:01:10 <Cale> But their element types are restricted
01:02:04 <flebron_> Hahaha, "TRT: <<loop>>" is exactly what I get when I use UArray :)
01:02:14 <Eduard_Munteanu> Cale: yeah, indeed
01:02:22 <Cale> quchen: <<loop>> is what you get at runtime if you try to evaluate the value of an expression which is already in the process of being evaluated
01:02:27 <flebron_> What does restricted element type?
01:02:30 <flebron_> *mean
01:02:59 <quchen> Cale: Ah. So when that occurs, the *same* thunk is evaluated in parallel?
01:03:07 <Cale> flebron_: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Unboxed.html -- look at the list of instances here
01:03:29 <Cale> flebron_: IArray UArray e means that it's okay to store elements of type e in a UArray
01:03:42 <flebron_> We're storing ints, so that's fine, right?
01:03:45 <Cale> yes
01:03:47 <Cale> but!
01:03:47 <flebron_> Or are we storing Int# or something?
01:04:17 <Cale> Yeah, it's more like we're storing Int# (though we don't have to work with Int# directly)
01:04:40 <Cale> It'll just be an array of Int#'s packed together end to end, which is efficient, but doesn't support lazy evaluation.
01:05:14 <Cale> quchen: Well, if you're building with the threaded runtime, you won't get <<loop>>
01:05:23 <flebron_> Ah, so for what we are doing, Haskell would store something like "ptr to unevaluated thunk", instead of an int.
01:06:02 <Cale> quchen: precisely for the reason that if an expression started evaluating in parallel, one might die then. Instead in that case, it just blocks quietly until the computation is done.
01:06:39 <Cale> (which in the case of an actual loop will just mean that the program goes to sleep and uses no CPU instead of 100% CPU)
01:06:50 <Cale> flebron_: yes, that's right
01:07:03 <Cale> flebron_: Int values are pointers to code
01:07:27 <Cale> flebron_: (well, all ordinary values are :)
01:08:04 <dmwit> (even evaluated Ints are pointers to code that doesn't do any computation before "returning")
01:09:57 <luite> the pointers are tagged though, so that code is usually not run
01:11:42 <quchen> Cale: Is there a minimal example to reprouce a <<loop>>?
01:11:48 <quchen> let x = x didn't work :-(
01:12:35 <Cale> quchen: How did you compile it?
01:12:55 <Cale> quchen: Note that GHCi is compiled with the threaded runtime, and so will never <<loop>>
01:13:16 <Cale> (you'll get the grey hole behaviour instead of the black hole one)
01:13:19 <dmwit> luite: can't imagine the tagging doing much for Int
01:13:23 <quchen> Cale: GHCi, yes
01:13:35 <quchen> Grey hole? One that sucks but doesn't yell? :-)
01:14:14 <luite> dmwit: Int is a box, one constructor, if the tag bits are 0 then it's at thunk, if it's 1 it's evaluated
01:14:42 <quchen> Cale: Ah, so when I compile with the threaded runtime, the system is prime for evaluating stuff in parallel, hence it can't detect loops. Non-threaded though can detect when something's done double so it issues a <<loop>>?
01:14:47 <luite> it could save you a jump
01:14:51 <Cale> yeah
01:14:55 <dmwit> luite: How could it save you a jump?
01:14:56 <Cale> exactly
01:14:57 <luite> at the cost of a check... dunno if it's worth it :)
01:15:18 <quchen> Cale: That was directed at me, I assume?
01:15:23 <Cale> quchen: yes
01:15:24 <luite> dmwit: if(tag(myint)) { return stack[sp]; } else { enter(myint); }
01:16:41 <dmwit> Okay... I clearly don't understand GHC's evaluation model, then. Because that just looks crazy to me.
01:17:02 <Cale> case myInt of I# _ -> ... ?
01:17:03 <dmwit> I thought you only got stack frames when entering thunks. If you're not planning to enter the Int's thunk, how did its value get on the stack?
01:17:12 <luite> dmwit: the enter code is slightly more complicted since it has to untag the int first
01:17:15 <luite> oh wait
01:17:21 <luite> that's not true since the tag has to be 0 for that
01:17:57 <luite> dmwit: if you have reduced something to whnf you jump to the top of the stack, where the continuation sits. that expects the whnf-reduced result to be in a register
01:19:13 <luite> so entering a data constructor would just retun to the stack since it's already whnf
01:19:29 <dmwit> ah ah ah
01:19:48 <dmwit> Okay, but it doesn't help most of the time because most of the operations we do on Int's need to know more than just the constructor.
01:19:51 <dmwit> Right?
01:20:04 <luite> Int has just one constructor
01:20:12 <luite> data Int = I# Int#
01:20:21 <dmwit> Right. Which is why we almost always need to know more than just the constructor to do something useful.
01:20:51 <dmwit> :t I#
01:20:53 <luite> yeah but because Int# is primitive we can immediately read its value if our I# is in whnf
01:20:53 <lambdabot>     Not in scope: data constructor `I#'
01:20:53 <lambdabot>     Perhaps you meant `In' (line 124)
01:21:53 <dmwit> case undefined + undefined of I# _ -> "hi" ---> exception
01:22:19 <luite> I# i two machine words, one pointer to the entry point (with the infotable next to it), and one Int#
01:22:32 <dmwit> So I'm imagining there's almost nothing we can do with an Int that doesn't need to do more than look at the constructor, and therefore my original claim (that the tag doesn't help much) still seems reasonable to me.
01:22:39 <luite> dmwit: yeah because + pattern matches on the I#
01:24:26 <quchen> Cale: Hmm, when I compile with -threaded, it still issues a <<loop>>. http://hpaste.org/85889
01:25:01 <luite> dmwit: well, lets make a bigger example, you add two integers, pattern match on the first, myCont expects the first int in whnf: push(secondInt); push(myCont); enter(firstInt);
01:25:35 <Cale> quchen: hmm!
01:25:42 <Cale> quchen: Well, that's interesting :)
01:25:50 <luite> dmwit: if you can check the tag of the first int, you know (without expensive indirections) that it's evaluated
01:26:00 <Cale> quchen: It could be that GHC has gotten more clever
01:26:24 <luite> dmwit: so you can jump immediately to myCont, without pushing it on the stack
01:26:42 <dmwit> Okay, I think I'm starting to get the point.
01:27:12 <dmwit> I was thinking *everything* was just a pointer. But eventually you've got to have more than one word or else you can never deal with product types.
01:27:27 <dmwit> okay
01:27:27 <dmwit> yes
01:27:34 <luite> dmwit: (the second int still needs to be on the stack though, that's where myCont expects it)
01:27:47 <quchen> Cale: How does the threaded runtime differ from the non-threaded one anyway, in case the program doesn't fork/pseq/...
01:27:57 <luite> though you could optimize that by making myCont call something with the ints in registers
01:28:00 <quchen> Is there a substantial difference in how thunks are evaluated?
01:28:03 <luite> and jumping to that directly
01:28:53 <quchen> Cale: Does the non-threaded one not have a scheduler at all maybe, and runs every fork etc. sequentially?
01:29:38 <dmwit> quchen: You might like dmwit.com/gtk2hs (skip the gtk-specific bits, they're not that big) and also the papers linked at the end.
01:30:04 <Cale> quchen: It's basically whether it's capable of running on more than one core.
01:30:10 <dmwit> Even the non-threaded runtime has a scheduler, but it's true that forked things are sequentialized.
01:30:19 <dmwit> err
01:30:26 <dmwit> That is to say, only one forked thing is running at a time.
01:31:27 <quchen> dmwit: Oh. Yes, that's what I was wondering about - forks but no threading. So even without threading, the scheduler "multitasks" the forks then?
01:31:54 <mauke> m:n
01:31:55 <luite> quchen: yep, but blocking foreign calls will block all haskell threads
01:32:29 <quchen> luite: Foreign as in FFI, or also things like GMP calls for Integer?
01:32:36 <dmwit> quchen: Yes, your threads can be pre-empted at any allocation point and another thread chosen.
01:32:46 <luite> quchen: both actually
01:33:14 <dmwit> Any code that doesn't explicitly call into the GHC runtime system will block all other threads.
01:33:17 <quchen> luite: That sounds like a lot of code benefits from -threaded even if there is no parallel programming involved at all
01:33:31 <dmwit> Yes, you should really use -threaded.
01:33:51 <quchen> I thought it introduced some overhead that may sometimes not be worth it
01:33:51 <luite> quchen: well Integer calls ususally don't take that long, but when you interact with many foreign things -threaded is quite useful :)
01:34:21 <dmwit> As always, you need to measure your specific case.
01:34:33 <dmwit> But you're using Haskell; you've chosen convenience over speed already. Use -threaded.
01:34:58 <quchen> Good point :-)
01:35:04 <luite> quchen: note that all the standard Handle IO things are implemented with nonblocking IO, but some things like waitForProcess don't work on the nonthreaded runtime since they do block
01:35:07 <hpaste> verma pasted “Simple code error” at http://hpaste.org/85890
01:35:42 <verma> How can I fix this stack overflow error and get the expected output of 1000000?
01:35:51 <verma> http://hpaste.org/85890
01:35:57 <dmwit> By using a strict maximum instead of the crappy built-in one.
01:36:00 <dmwit> ?src maximum
01:36:00 <lambdabot> maximum [] = undefined
01:36:01 <lambdabot> maximum xs = foldl1 max xs
01:36:08 <dmwit> Use foldl1' instead and you'll be golden.
01:36:24 <verma> dmwit, ah great, thanks
01:36:25 <mauke> verma: are you compiling with -O2?
01:36:40 <verma> mauke: no
01:36:57 <mauke> try it
01:36:58 <mikeplus64> dmwit: hm, why is maximum defined like that by default?
01:37:34 <verma> mauke, I read an article that turning optimizations on will most likely fix this problem, I just wanted to learn more :)
01:37:37 <mikeplus64> i mean, why not just use foldl1' max
01:37:55 <verma> mauke: this one: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/
01:38:03 <dmwit> mikeplus64: hysterical raisins
01:38:04 <quchen> luite, dmwit, Cale: Thanks for the advice! -threaded as default it is.
01:38:16 <mikeplus64> dmwit: dem raisins :(
01:39:00 <mikeplus64> i thought ghc was mostly immune to hysterical raisins
01:39:01 <mikeplus64> @src sum
01:39:01 <lambdabot> sum = foldl (+) 0
01:39:04 <verma> mauke: I just do $ghc -O2 program.hs .. right?
01:39:08 <mauke> verma: yeah
01:39:14 <mikeplus64> weird, not what i remember in GHC.List or whatever
01:39:16 <verma> mauke: still get the error
01:39:31 <mauke> if it didn't say something about compiling program.hs, remove program.o first
01:39:56 <dmwit> ...or use -fforce-recomp
01:40:02 <verma> mauke: yeah it wouldn't, so I deleted it
01:40:19 <mikeplus64> verma: try foldl1' max instead of maximum
01:40:32 <verma> mikeplus64: yeah doing that right now
01:44:11 <johanneslippmann> Hy there! I have a question about defining functiones.
01:44:19 <johanneslippmann> I want to define a function coprime :: Int -> Int -> Bool
01:44:21 <johanneslippmann> (a and b are coprime if the gcd a b == 0)
01:44:44 <Cale> johanneslippmann: and?
01:44:47 <johanneslippmann> So why doesn#t this work: coprime =  (1 == gcd)
01:45:02 <quchen> That compares 1 to the function gcd.
01:45:11 <mikeplus64> coprime a b = gcd a b == 0
01:45:14 <mikeplus64> surely that's what you want?
01:45:26 <Rarrikins> No, it'll give 1 for coprime.
01:45:31 <Botje> johanneslippmann: if you eta-expand that you get coprime a b = (1 == gcd) a b
01:45:37 <Rarrikins> > gcd 3 7
01:45:38 <lambdabot>   1
01:45:52 <Botje> whereas you want coprime a b = 1 == (gcd a b)
01:46:13 <Cale> Three reasons: 1) you need an instance of Num in order to think of 1 as a function, 2) you'd need an instance of Eq for functions to compare whether the functions are equal, 3) even if you did have those instances, that's not what you want to do
01:46:31 <johanneslippmann> coprime a b = (1 == gcd) a b is possible of course. But not beautifull.
01:46:41 <Cale> no, that doesn't work
01:46:50 <arkeet> it does with NumInstances
01:47:00 <Cale> It *compiles* with NumInstances
01:47:13 <Botje> @pl coprime a b = 1 == (gcd a b)
01:47:13 <lambdabot> coprime = ((1 ==) .) . gcd
01:47:13 <Cale> But it doesn't mean what johanneslippmann wants it to mean
01:47:14 <johanneslippmann> Ints are not NumInstances?
01:47:15 <arkeet> wait. never mind.
01:47:17 <dmwit> And it even *runs* with some patches I sent in. =)
01:47:27 <arkeet> NumInstances still doesn't give you Eq on functions.
01:47:32 <Botje> johanneslippmann: if you think /that/ is beautiful, go for it.
01:47:35 <Cale> johanneslippmann: NumInstances is a module which has extra instances of Num for functions
01:47:37 <dmwit> arkeet: It does, but it's a crappy Eq.
01:47:41 <arkeet> heh.
01:47:42 <Cale> (and some others)
01:48:11 <Cale> actually, that one wouldn't compile with NumInstances
01:48:18 <quchen> Time for the dotdotdot operator! coprime = ((.).(.)) (== 1) gcd
01:48:21 <verma> Not in scope: foldl1`
01:48:23 <Cale> Because (1 == gcd), even if valid, would be a Bool
01:48:28 <Cale> and so wouldn't have any parameters
01:48:28 <verma> sorry, foldl1'
01:48:29 <arkeet> true
01:48:35 <Cale> So applying it to arguments doesn't make sense
01:48:42 <verma> is it not in prelude?
01:48:48 <dmwit> It is not in Prelude.
01:48:50 <dmwit> ?index foldl1'
01:48:51 <lambdabot> Data.List
01:48:57 <verma> ah, thanks dmwit
01:49:10 <Cale> johanneslippmann: Does that make sense?
01:49:27 <verma> yay dmwit success! thanks
01:49:35 <dmwit> Anyway, yeah, the main complaint is that gcd is a function, and as a function, you should apply it to some arguments.
01:49:54 <johanneslippmann> I think it does, but I am not satisfied :(
01:50:07 <dmwit> tough
01:50:23 <Cale> johanneslippmann: What was wrong with your original definition of  coprime a b = gcd a b == 1 ?
01:50:48 <johanneslippmann> It is too long
01:52:02 <quchen> It is also readable.
01:52:36 <Cale> Well, (gcd a b == 1) = (==) (gcd a b) 1 = (== 1) (gcd a b) = ((== 1) . (gcd a)) b
01:52:54 <Cale> So coprime a = (== 1) . gcd a
01:52:55 <johanneslippmann> \query quchen Thats what I say! :)
01:53:21 <Cale> and then we can take that a step further...
01:53:43 <quchen> \reply johanneslippmann Oh.
01:54:13 <Cale> ((== 1) . gcd a) = (((== 1) .) . gcd) a
01:54:39 <Cale> So you could write  coprime = ((== 1) .) . gcd
01:54:48 <Cale> But nobody wants to read that
01:55:07 <johanneslippmann> You are a magician!
01:55:32 <Cale> It's also exactly as long as the original
01:55:38 <quchen> Just wanted to mention that :-D
01:55:51 <dmwit> Just for fun:
01:56:00 <dmwit> < (gcd `asAppliedTo` word8) == 1
01:56:01 <goodfellow>   False
01:56:07 <quchen> Cale: However, it's more compressible! ((==1).).gcd
01:56:19 <quchen> You can save 4 spaces, vs only 2 in the long case.
01:56:28 <Cale> that's true
01:56:33 <Walther> code golfing? :D
01:56:45 <quchen> Walther: It's more a thing of environmental conciousness.
01:56:49 <Walther> xD
01:56:53 <Walther> bwhah
01:57:07 <Walther> save all the bits o/
01:57:17 <dmwit> Didn't Google do an April Fool's where they complained that they were running out of white pixels...?
01:57:33 <quchen> dmwit: Isn't that a running gag in the Lisp community and parentheses?
01:57:42 <quchen> s/and/with
01:57:52 <dmwit> plausible =)
01:58:20 <quchen> dmwit: http://imgs.xkcd.com/comics/lisp_cycles.png
01:58:22 <Walther> there's an xkcd comic on that
01:58:30 <Walther> 'here have your fathers parentheses'
01:58:50 <Walther> ...dammit, ninja'd
01:58:54 <arkeet> :t liftA2 (==) (pure (pure 1)) gcd
01:58:56 <lambdabot> Integral a => a -> Bool
01:58:59 <arkeet> oops.
01:59:14 <arkeet> :t (liftA2.liftA2) (==) ((pure.pure) 1) gcd
01:59:16 <lambdabot> Integral b => b -> b -> Bool
01:59:35 <dmwit> Memory is corrupted by nostalgia, even in alternate universes. =P
01:59:42 <dmwit> "a more civilized age" ha!
01:59:56 <quchen> arkeet is playing code golf ... with the moon as an intermediate sand pit
01:59:58 <arkeet> > 1 2
02:00:00 <lambdabot>   1
02:00:04 <arkeet> :t (liftA2.liftA2) (==) 1 gcd
02:00:05 <lambdabot> Integral b => b -> b -> Bool
02:00:59 <dmwit> :t liftA2 `asAppliedTo` (==)
02:01:01 <lambdabot> (Eq b, Applicative f) => (b -> b -> Bool) -> f b -> f b -> f Bool
02:01:20 <dmwit> Oh, whoops, it's the gcd that specializes things.
02:01:24 <arkeet> yes
02:04:42 <adimit> dear god, I just almost wrote "zipWith ($) (repeat f) [1..]". I need a cup of tea.
02:05:43 <tcrayford> what do I have to do to be allowed to post on the haskell-cafe mailing list?
02:06:02 <adimit> tcrayford: register: http://www.haskell.org/mailman/listinfo/haskell-cafe
02:08:23 <latro`a> :t zipWith ($) . repeat
02:08:24 <lambdabot> (b -> c) -> [b] -> [c]
02:08:26 <latro`a> :t map
02:08:27 <lambdabot> (a -> b) -> [a] -> [b]
02:08:29 <latro`a> :p
02:08:50 <adimit> yeah, that's the point. I thought to myself: wait, there's gotta be a library function for that!
02:12:08 <hpaste> Bor0 pasted “string equal check” at http://hpaste.org/85893
02:12:50 <hpaste> Bor0 revised “string equal check”: “string equal check” at http://hpaste.org/85893
02:13:54 <dmwit> yikes
02:14:02 <Bor0> how can I make this code better? http://hpaste.org/85893
02:14:11 <dmwit> Bor0: testString (a,b) = a == b
02:14:28 <Bor0> namely, I want to remove the usage of 3rd input, and make it as a local variable? or something
02:14:31 <dmwit> or don't even define it and just use (==) instead. =P
02:14:38 <Bor0> I'm just playing around with recursino
02:14:57 <dmwit> Okay, the answer to your specific question is to use a where clause to hide the implementation.
02:15:01 <dmwit> So it would look something like
02:15:19 <dmwit> testString (a,b) = go (a,b,length a) where go (a, b, c) = ...
02:15:34 <dmwit> You can of course choose a better name than "go" if you prefer.
02:15:45 <Bor0> I see. is that the best way to do it?
02:15:51 <danr> "go" is the way to go!
02:15:57 <dmwit> It depends how grand your "it" is.
02:16:05 <adimit> the best way is to use (==) …
02:16:06 <dmwit> That is the best way to do the one specific thing you asked about.
02:16:14 <Bor0> can I not initialize it at the start of the function like in procedural languages?
02:16:16 <dmwit> But there's a lot of things about this function that are really bad.
02:16:29 <adimit> the alternative is to use let … in.
02:16:53 <dmwit> Bor0: As a challenge, I propose you try to write this in an idiomatic way (still avoiding (==) if you like).
02:17:05 <dmwit> Bor0: Use pattern matching, and don't use any of length, (!!), head, tail, etc.
02:17:10 <adimit> I guess that's closer to the layout in procedural languages, but it's not used as much in Haskell. You should really try to stop thinking in procedural terms. Haskell is declarative.
02:17:30 <dmwit> (...and don't redefine length yourself and then use that. ;-)
02:18:05 <Bor0> that's what I want to achieve, remove length as an input and compute it automatically
02:18:32 <dmwit> I'm saying you should try to write it without computing it ever, automatically or otherwise.
02:18:48 <dmwit> And without indexing into the list, either.
02:18:53 <dmwit> (!)
02:19:04 <_mr> Bor0: do you know pattern matching?
02:19:28 <Bor0> I guess not, 2nd day @ haskell
02:20:35 <_mr> > let f (x:xs) = x in f [1,2,3]
02:20:37 <lambdabot>   1
02:20:57 <_mr> here is a way to get the first element of a list. Use that to implement your function ;-)
02:21:30 <Bor0> what does (x:xs) mean
02:21:46 <dmwit> Bor0: There are two kinds of lists: empty ones, and ones with some element in and a sublist.
02:21:47 <startling> Bor0: do you know how to make a list with : ?
02:21:49 <dmwit> [] is an empty list
02:21:56 <dmwit> (x:xs) is a list that starts with x and has xs as the sublist.
02:22:17 <Bor0> cool
02:22:29 <dmwit> Bor0: You can also write these on the *left* of an equality, and then what will happen is that there will be a check whether the list is empty or not.
02:22:57 <dmwit> If it's empty, an equation with [] in it will be the one to run; otherwise, an equation with (x:xs) in it will be the one to run, and you can use x as the value of the first element and xs as the sublist.
02:23:04 <dmwit> Bor0: Here's a simple example:
02:23:27 <dmwit> > let f [] = "empty!"; f (x:xs) = "starts with " ++ [x] ++ " and ends with " ++ xs in f "foobar"
02:23:29 <lambdabot>   "starts with f and ends with oobar"
02:24:09 <dmwit> Bor0: For lists, there's only two cases; but since you're writing a function that takes in two lists, you should consider all four cases separately.
02:24:18 <dmwit> (Perhaps you can combine some of them later.)
02:24:21 <Bor0> I see
02:24:51 <Bor0> I probably should start reading some tutorial. right now I'm playing with "thinking recursively" and a lot of trial and error :p
02:27:18 <dmwit> ?where tutorials
02:27:19 <lambdabot> http://haskell.org/haskellwiki/Tutorials
02:27:50 <Bor0> thanks for the help.
02:28:10 <quchen> LYAH!
02:28:15 <quchen> @where lyah
02:28:16 <lambdabot> http://www.learnyouahaskell.com/
02:28:29 <dmwit> LYAH is listed on that wiki page, along with many other suggestions.
02:29:11 <adimit> Bor0: Haskell was a shock for me when I came from procedural/imperative languages. You need to get used to a different way of approaching problems. LYAH and Real World Haskell are probably a must-read nowadays.
02:29:34 <adimit> (I had to start with "A Gentle Introduction to Haskell" which wasn't gentle. At all.)
02:29:48 <Kinnison> Did it introduce you, roughly ?
02:30:15 <adimit> haha. Yeah. That and Hal Daumé's YAHT.
02:30:21 <quchen> Kinnison: It's more like trying to learn to be a carpenter by having someone hit you on the head with a hammer.
02:30:37 <Kinnison> quchen: Sounds.... inefficient.
02:30:39 <Botje> haskell for c programmers was also fun.
02:30:46 <Kinnison> locallycompact: Stop sniggering
02:30:49 <johnw> that's step one: learn to be the wood
02:31:14 <dmwit> I liked the Gentle Introduction.
02:31:22 <startling> I like the gentle introduction too.
02:31:33 <dmwit> It got straight to the point. No rambling nonsense.
02:31:43 <adimit> it's good for people with a formal background. I think nowadays I'd like it, too.
02:31:47 <adimit> Back then… not so much.
02:32:03 <startling> all I really knew before haskell was python, fwiw
02:32:11 <dmwit> The Gentle Introduction is what caused me to acquire a formal background. =)
02:32:18 <startling> ^ yeah
02:32:32 * dmwit high fives startling
02:32:35 <dmwit> We are the same person.
02:32:35 <startling> but it's definitely more dense than e.g. lyah
02:32:44 <adimit> yes, me too. That and Category Theory, Lawvere's books etc.
02:32:48 <startling> dmwit: evidently!
02:33:12 <startling> something something second order logic
02:37:28 <dmwit> too quiet
02:37:33 <dmwit> < min max min
02:37:35 <goodfellow>   [((),[((),())])]
02:38:17 <Stefan_away> Hi.. how can I regain my IRC username, without my password? i forgot it
02:38:47 <sirchurchill> i think you need to email the freenode staff
02:38:53 <jon-shape> Stefan_away: goto #freenode ask for a password reset
02:39:05 <Stefan_away> thanks jon-shape
02:40:31 <dmwit> < max == (||)
02:40:32 <goodfellow>   True
02:43:40 <dmj> why is exitSuccess an exception?
02:44:16 <quchen> I think it just abuses the exception machinery to jump out of a program early
02:45:32 <danr> dmwit: what instances are you using with that max? (and also what is < and goodfellow?)
02:45:34 <dmj> quchen: Is there a way to gracefully exit without seeing *** Exception
02:46:10 <dmwit> danr: goodfellow is lambdabot with a few different imports; < is >
02:46:35 <dmwit> danr: And the imports in particular provide Eq, Ord, Show, and Read for functions with finite domain.
02:46:50 <quchen> dmj: I don't know. I usually let main terminate normally :-)
02:47:09 <danr> dmj: exitSuccess exits cleanly from compiled programs (also programs run with runghc). only in ghci you see the exception
02:47:41 <dmwit> ?hackage universe <- danr, here's the code =)
02:47:42 <lambdabot> http://hackage.haskell.org/package/universe <- danr, here's the code =)
02:47:56 <danr> dmwit: ok then I understand the max == (||), I haven't figured out your min max min yet
02:48:45 <danr> dmwit: oh. I had a look at this package once. It reminded me of http://hackage.haskell.org/package/testing-feat
02:48:53 <hpaste> dmj pasted “gracefully exit?” at http://hpaste.org/85898
02:49:13 <dmwit> Ah, neat link.
02:49:19 <dmwit> I'll take a look at it before long.
02:49:31 <hpaste> danr annotated “gracefully exit?” with “gracefully exit? (annotation)” at http://hpaste.org/85898#a85899
02:50:53 <danr> dmj: I don't know why you get the Exception (I don't). Maybe you can use some function from this package instead? http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
02:52:07 <danr> < :t min max
02:52:08 <goodfellow>   <hint>:1:1: parse error on input `:'
02:52:14 <danr> :(
02:52:25 <danr> < min max
02:52:26 <goodfellow>   [([((),[((),())])],[((),[((),())])])]
02:52:54 <dmwit> min max :: (Ord a, Finite a) => (a -> a -> a) -> (a -> a -> a)
02:52:57 <dmwit> ...I think.
02:53:25 <danr> what's with the lists, tuples and units?
02:53:27 <dmwit> < min max :: (Bool -> Bool -> Bool) -> (Bool -> Bool -> Bool)
02:53:28 <goodfellow>   [([(False,[(False,False),(True,False)]),(True,[(False,False),(True,False)])...
02:53:36 <dmwit> danr: It's defaulting a to ().
02:53:39 <dmj> danr: my problem is that I want to terminate based on the value of getLine and I don't think I can do "when "
02:53:49 <dmwit> < not
02:53:50 <goodfellow>   [(False,True),(True,False)]
02:53:52 <dmj> "when $ null getline $ do"
02:54:00 <dmwit> < id
02:54:02 <goodfellow>   [((),())]
02:54:05 <danr> dmwit: aha Data.Universe.Instances.Show
02:54:08 <dmwit> yep
02:54:48 <danr> ok then I see what's going on in min max min
02:54:55 <dmwit> =)
02:55:08 <dmwit> > (==) == (/=) . not -- my favorite
02:55:10 <lambdabot>   *Exception: (==): No overloading for function
02:55:16 <dmwit> whoops
02:55:20 <dmwit> < (==) == (/=) . not
02:55:23 <goodfellow>   True
02:55:44 <danr> < (==) == (/=) . (not :: Bool -> Bool)
02:55:45 <goodfellow>   True
02:56:36 <bitonic> goodfellow: are you lambdabot?
02:56:51 <danr> maybe it's just dmwit typing in answers in goodfellow
02:56:58 <dmwit> =)
02:57:06 <dmwit> goodfellow is a lambdabot.
03:00:22 <elliott>  /me thinks the (==) would be more exciting if it did the "seemingly impossible functional programs" thing.
03:00:26 <elliott> good /me.
03:00:45 <dmwit> Yes. The problem with the "seemingly impossible functional program" is that it really is impossible.
03:00:55 <dmwit> Because a really, really small fraction of Haskell functions are compact in the required sense.
03:01:32 <dmwit> Almost any damn thing you want to do in a function breaks compactness, and the "impossible" function just loops or gives a wrong answer.
03:07:31 <no-n[10]> http://learnyouahaskell.com/spongedisk.png
03:08:39 <elliott> dmwit: just add a recursion limit. like CReal. what could go wrong?
03:25:48 <haasn> < (==) == (/=)
03:25:49 <goodfellow>   False
03:26:14 <haasn> oh so it doesn't default to () -> () -> Bool
03:26:16 <haasn> how boring
03:28:14 <elliott> huh, that is confusing
03:28:16 <elliott> why doesn't it?
03:28:22 <elliott> oh, because it defaults to Integer, I guess
03:28:32 <elliott> or something?
03:28:44 <mauke> how do you know it doesn't default to () -> () -> Bool?
03:30:25 <haasn> oh, I was thinking of something else, yes; that's totally correct even if it defaults to ()
03:30:55 <haasn> \() () -> True -- not equal to \() () -> False -- for the only possible input (), ()
03:32:32 <mauke> < (<) == (>)
03:32:33 <goodfellow>   True
03:33:10 <mikeplus64> < id == id
03:33:12 <goodfellow>   True
03:33:17 <mikeplus64> < ($) == id
03:33:18 <goodfellow>   True
03:33:55 <mikeplus64> < (id :: Int -> Int) == ((+ 0) :: Int -> Int)
03:33:59 <goodfellow>   mueval-core: Time limit exceeded
03:39:28 <johanneslippmann> Ha! Lambdabot is such a cool thing.
03:39:47 <merijn> goodfellow isn't lambdabot, though
03:40:18 <johanneslippmann> [1..5]
03:40:28 <merijn> Prefix with "> "
03:40:31 <merijn> > [1..5]
03:40:33 <lambdabot>   [1,2,3,4,5]
03:40:45 <johanneslippmann> Ah, thats what I wanted!
03:41:44 <johanneslippmann> What if I said [1..] to lambdabot?
03:41:55 <elliott> > [1..]
03:41:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:42:01 <elliott> the universe would end
03:42:33 <merijn> johanneslippmann: lambdabot has been pretty well tested for exploits over the years :p
03:42:41 <flux> > [1..30,32]
03:42:43 <lambdabot>   <hint>:1:7: parse error on input `,'
03:42:47 <merijn> johanneslippmann: It only runs code for 3 seconds and no IO
03:42:50 <flux> I was expecting a lie :(
03:43:48 <johanneslippmann> I am very impressed.
03:44:19 <merijn> johanneslippmann: Works in private message too if you wanna play with it a bit
03:45:42 <Eduard_Munteanu> s/it/her/
03:46:55 <DMcGill> > readFile "C:\\Users\\Lambdabot\\Desktop\\passwords.txt"
03:46:57 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Base.String))
03:46:58 <lambdabot>    arising f...
03:54:17 <Rarrikins> > unsafePerformIO
03:54:19 <lambdabot>   Not in scope: `unsafePerformIO'
03:56:53 <DMcGill> @src unsafePerformIO
03:56:54 <lambdabot> Source not found. Where did you learn to type?
03:57:24 <Rarrikins> I learned to type in A-merica!
03:59:02 <HugoDaniel> :D
03:59:23 <HugoDaniel> lambdabot is picky
04:01:50 * hackagebot Obsidian 0.0.0.2 - Embedded language for GPU Programming  http://hackage.haskell.org/package/Obsidian-0.0.0.2 (JoelSvensson)
04:51:24 <quchen> HugoDaniel: @src searches a static database
04:51:48 <quchen> Also I think unsafePerformIO is primitive
04:53:06 <quchen> Oh, it's not primitive. unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
04:53:11 <quchen> I'm sure that helps ;-)
04:53:20 <quchen> See http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO.html#unsafePerformIO
05:05:50 <timbod> I need a function: encodeBase64 :: ByteString -> Text. Any suggestions?
05:06:43 <shachaf> @hackage base64-bytestring exists but unfortunately gives you a ByteString for some reason.
05:06:43 <lambdabot> http://hackage.haskell.org/package/base64-bytestring exists but unfortunately gives you a ByteString for some reason.
05:06:45 <timbod> base64-bytestring has encode :: ByteString  -> ByteString, but that doesn't seem that helpful given I am producing Text.
05:07:02 <shachaf> But it should be a well-behaved ByteString so you can pass it to decodeUtf8 or something.
05:07:08 <timbod> Yes. Perhaps it predates Text
05:07:29 <shachaf> It does not.
05:07:53 <shachaf> (And moreover it was written by the maintainer of text... Odd.)
05:09:15 <timbod> Does it seem like ByteString -> Text would be the sensible function to have? I am trying to embed a small amount of binary data in a text document.
05:11:26 <merijn> timbod: base64 encoded data should be 7bit ASCII, which means it's valid Utf8 and thus using decodeUtf8 should work
05:13:24 <ab9rf> merijn: utf8 is not valid 7-bit ascii.  only the first 128 characters encode to octets that fit in 7 bits.
05:13:34 <timbod> Oh. so myencode = Date.Text.Encoding.decodeUtf8 . Date.Text.Base64.encode
05:13:52 <merijn> ab9rf: You read the reverse from what I said
05:14:06 <merijn> ab9rf: I said 7 bit ascci is valid UTF-8, not the other way around, obviously
05:14:25 <ab9rf> merijn: oh, you're talking about reencoding a stream already encoded in Base64 to UTF?
05:14:26 <merijn> timbod: Yeah
05:14:32 <ab9rf> that's an identity transform
05:14:49 <merijn> ab9rf: No, because decodeUtf8 has type ByteString -> Text
05:14:56 <timbod> it's not an identity transform in the types.
05:14:59 <ab9rf> merijn: true
05:15:07 <merijn> ab9rf: Whereas timbod's encodeBase64 has type ByteString -> ByteString
05:15:37 <timbod> merijn: Thanks. I think that will solve my problem.
05:15:38 <merijn> But yes, my point was that that a no-op decode that only change the type is probably exactly what he wants :p
05:16:18 <merijn> timbod: Might wanna shoot an e-mail to the maintainer suggesting that addition
05:16:53 * hackagebot lgtk 0.1.0.2 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.1.0.2 (PeterDivianszky)
05:17:13 <timbod> Might do that. Though I proposed an addition to another of his libraries (aeson) a few weeks back and was knocked back.
05:17:27 <ab9rf> yeah, it would be nice to avoid the cost of running through the whole UTF logic when you can guarantee that it's not needed
05:18:05 <timbod> ab9rfespecially as I'm going to put the text in a json object,
05:18:20 <timbod> and encode it back to a bytestring later :-(
05:18:20 <ab9rf> timbod: whee, more juggling
05:19:06 <ab9rf> that sounds like you might be prematurely encoding, then
05:19:36 <ab9rf> usually a sign of an inadequate API
05:20:22 <ab9rf> the "I have an infinite number of shoehorns and I will make this fit!" antipattern
05:20:22 <timbod> I'm not sure what you mean - my API is inadequate, or the ones I am using?
05:20:52 <ab9rf> timbod: without looking i can't say _whose_ API is inadequate
05:21:35 <ab9rf> it sounds like you are multiply transforming data between where it's produced and where it is consumed, because of API limitations and not because those transformation add value
05:21:51 <timbod> Ultimately I am dealing with JSON. JSON embeds Text. I need to put a small amount of binary data in it, so I need to go bytestring -> base64 bytestring -> text -> json -> bytestring.
05:22:13 <ab9rf> timbod: why can't JSON embed a bytestring directly?
05:22:52 <shachaf> ab9rf: The Text UTF-8 decoder has a special case for things that look like ASCII, at least.
05:23:05 <timbod> Two reasons - binary is  not part of the JSON standard, and it's not in the Aeson library (which is becoming the haskell json standard, I think)
05:24:08 <ab9rf> shachaf: yeah, i would hope that the transformer would be fairly fast in the case of being sent a bytestring that's all <128
05:25:00 <ab9rf> timbod: it's probably unavoidable in this case
05:25:38 <shachaf> It takes the ByteString 4 bytes at a time and &s against 0x80808080, or something like that.
05:25:48 <timbod> I think so. I have to decide whether using JSON is prefereable to a custom serialisation scheme.
05:26:33 <ab9rf> timbod: this comes up a lot when dealing with unicode
05:27:10 <ab9rf> going back and forth between bytestreams and character streams (which is what Text is)
05:28:25 <timbod> ab9rf: Indeed. It seems worse in some ways with Haskell, but I think thats because Haskell has 3 string types.
05:28:37 <timbod> or rather 2 string types and a bytestring type.
05:28:57 <shachaf> If Haskell "has 2 string types" then it also "has 2 bytestring types"
05:30:28 <timbod> shachaf: I mean Text and String. What are the two bytestring types?
05:30:41 <shachaf> ByteString and [Word8]
05:31:07 <sss_> What is the replacement for the deprecated getClockTime?
05:31:11 <timbod> OK. But common APIs don't generally use [Word8]
05:31:25 <timbod> whereas Text and String are used frequently.
05:36:32 <ab9rf> timbod: welcome to the wonderful world of i18n :)
05:37:14 <robstewartuk> If I have a quick check test, how do I make putStrLn statements actually print a string during the execution of a test with `cabal test`? I have a putStrLn in a failing test, but it isn't producing anything on the command line.
05:37:28 <ab9rf> and actually the fact that few APIs use [Word8] can be viewed as a feature
05:37:45 <timbod> ab9rf:  Sure. I think part of the problem is that there's quite a few APIs that use bytestring or string due to their age, which should use text
05:37:51 <ab9rf> it means that there are not as many non-unicode-aware APIs as in so many other environments
05:38:35 <ab9rf> timbod: most of them use ByteString because they're dealing with bytestreams and not character streams.  e.g. Base64, which is explicitly defined as a bytestream to bytestream translation.
05:39:27 <ab9rf> the reality is that the network uses bytes, but conceptually we want to use characters
05:39:57 <timbod> I was mostly referring to String vs Text.
05:40:19 <ab9rf> timbod: that's just efficiency.  both String and Text wrap the same abstract type, but Text does so more efficiently.
05:40:57 <timbod> Yup. But it's annoying and inefficient to have to unpack Text to pass to APIs wanting strings.
05:41:20 <ab9rf> i'll potentially agree with annoying but not necessarily with inefficient :)
05:41:20 <timbod> ab9rf:  When should a function take String rather than Text?
05:42:41 <ab9rf> timbod: i don't have a good answer to that one
05:43:33 <ab9rf> timbod: you lose generality with Text, yu lose efficiency with String
05:44:53 <timbod> ab9rf: and you spend more time packing and unpacking when you have APIs that use both.
05:45:59 <timbod> I'm only complaining a bit  - I don't know what if anything would be an improvement over the status quo. Often it's nice to have a string as a list of chars.
05:46:00 <xplat> an API should take String when it's easily applicable to lists of anything, not just to strings.  otherwise it's pretty much always a lose, i think.
05:46:34 <timbod> xplat: In which case it should have type [a] not String?
05:46:41 <xplat> right
06:08:19 <robstewartuk> hm, which linux variables do I need to modify the values of in order to avoid having to use --extra-lib-dirs and --extra-include-dirs flags with cabal?
06:08:34 <robstewartuk> e.g. my libfoo.so.0 is in /home/me/over/there/
06:08:52 <dcoutts> robstewartuk: see gcc, if gcc can find it with no flags then cabal/ghc will too
06:09:18 <dcoutts> and in turn that usually means setting things up so ld can find it
06:09:35 <dcoutts> and ld has a number of env vars, and standard search paths
06:09:59 <robstewartuk> dcoutts: thanks, I'll take a look..
06:17:23 <Chousuke> if you want it to be permanent you can drop a file in /etc/ld.so.conf.d/
06:24:54 <aCube> @src all
06:24:55 <lambdabot> all p =  and . map p
06:25:17 <arkeet> @src and
06:25:17 <lambdabot> and   =  foldr (&&) True
06:25:22 <arkeet> aw.
06:25:57 <arkeet> :t all id
06:25:59 <lambdabot> [Bool] -> Bool
06:26:32 <shachaf> @ty all
06:26:34 <lambdabot> (a -> Bool) -> [a] -> Bool
06:26:39 <shachaf> all :: [a] -> Cont Bool a
06:26:39 <ab9rf> all id is just and
06:27:36 <quchen> shachaf: Is that just coincidence or does it have a deeper meaning?
06:29:05 <shachaf> Yes.
06:29:46 <shachaf> @let all' = cont . flip all
06:29:48 <lambdabot>  Defined.
06:30:22 <shachaf> > (`runCont` id) $ do { x <- all' [1,2,3]; y <- all' [4,5,6]; return (x * y > 2) }
06:30:24 <lambdabot>   True
06:32:21 <quchen> Hypothetical alls :-D
06:32:22 <soz> How can I convert NominalDiffTime (in Data.Time.Clock) to microseconds?
06:34:31 <arkeet> what happened to hackagebot, anyway?
06:34:58 <arkeet> soz: multiply by 10^6 and round.
06:36:24 <soz> arkeet, multiplying a NominalDiffTime by a number gives a NominalDiffTime
06:36:40 <soz> arkeet, How can I convert it to an integer?
06:36:43 <byorgey> soz: you can use toRational (from the Real instance) to convert to a Rational
06:36:48 <arkeet> round
06:36:48 <arkeet> :t round
06:36:50 <lambdabot> (Integral b, RealFrac a) => a -> b
06:36:54 <arkeet> (or something else from RealFrac)
06:37:14 <byorgey> ah, right, round etc. works as well, cool
06:38:07 <bishboria> Hi folks
06:38:35 <soz> arkeet, thanks
06:39:33 <bishboria> I'm having a chat with someone on twitter and he was asking if there are any studies that show immutability improves reasonability. Does anyone know of such papers/
06:39:34 <bishboria> ?
06:40:04 <bishboria> *Improves developer's ability to reason about the code.
06:41:29 <tromp_> if you need a paper to be convinced of that, then you haven't done much reasoning yourself:(
06:41:49 <bishboria> Well, I did try to tell him that...
06:42:49 <quchen> immutable => parallelizeable. Sounds like a very practical case of "improves reasonability" to me.
06:43:31 <quchen> That parallelization may not be very useful, but don't tell him that. ;-)
06:44:02 <bishboria> I mentioned equational reasoning, not having things change value from afar, provability, etc. Not good enough.
06:44:14 <_mr> quchen: now wrap that into a paper! ;-P
06:45:00 <byorgey> bishboria: I think I heard of a study once that used two simple languages, one functional and one imperative, and asked developers to use them to write a simple program
06:45:09 <fizbin> quchen: In theory immutability improves parallelizability. I think though that the jury's still very much out on whether that works in practice.
06:45:32 <byorgey> bishboria: but I can't find it.  In any case, there is not a lot of research on this, partly because it is really hard to figure out good ways to design experiments that would actually tell you anything.
06:46:15 <bishboria> byorgey: NP.
06:46:33 <fizbin> In any case, immutability hasn't been the parallization magic bullet many people hoped it would be.
06:46:38 <quchen> bishboria: Common subexpression elimination is *always* possible with immutability. More generally, it opens the door to a lot of optimizations on a very high level.
06:46:55 * hackagebot conjugateGradient 1.4 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-1.4 (LeventErkok)
06:46:57 * hackagebot snap 0.11.2.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.11.2.1 (DougBeardsley)
07:10:35 <eikke> if I have an [A], and some function "withA :: A -> (B -> m c) -> m c", is there any way to construct a [B] from [A] (inside the 'last' withA call, so to say)?
07:12:26 <Eduard_Munteanu> eikke: the A there seems useless
07:12:37 <adimit> eikke: no. What 'withA' does with A to make it (presumably B) is entirely opaque to you.
07:12:41 <eikke> Eduard_Munteanu: A is slightly more complicated ;)
07:13:34 <eikke> ok, so given a list of bytestrings there's no way to turn it into a list of CStringLen's (what D.B.Unsafe.unsafeUseAsCStringLen provides for a single BS)
07:16:41 <supki> @ty mapM (flip Data.ByteString.Unsafe.unsafeUseAsCStringLen return)
07:16:42 <lambdabot> [BSC.ByteString] -> IO [Foreign.C.String.CStringLen]
07:19:54 <thirsteh> does anyone here have the tls package installed (e.g. http-conduit client)? Does it work?
07:20:17 <thirsteh> I've tried installing on several different hosts, and get a BadRecordMac on every host, including google.com, yahoo.com, etc.
07:21:30 <thirsteh>  / does anyone mind doing cabal-install tls-debug, and running tls-simpleclient -d -v google.com 443 to see if it works?
07:24:02 <thirsteh> anyone? Would be really helpful. I'm not sure if it's a problem with the tls package or something on my systems yet.
07:24:08 <eikke> supki: I thought about that, but the unsafeBS thing uses withForeignPointer, and I'm afraid that does some magic like pinning 'as long as you're inside the handler'
07:24:19 <eikke> supki: so extracting things like that might not be wise
07:25:55 <parcs> :k forall. ()
07:25:57 <lambdabot> *
07:26:09 <_mr> thirsteh: what does "works" mean?
07:26:25 <_mr> thirsteh: I get some "The document has moved"
07:26:28 <thirsteh> successfully negotiating a TLS handshake without throwing an exception: tls-simpleclient: HandshakeFailed (Error_Packet_unexpected "Alert [(AlertLevel_Fatal,BadRecordMac)]" " expected: change cipher")
07:26:40 <thirsteh> oh, then it must be something with my setup. Odd. Did you install it with cabal?
07:26:45 <_mr> yes
07:26:47 <_mr> just now
07:26:58 <thirsteh> very strange. Maybe it's an issue with Ubuntu 12.10
07:26:58 * hackagebot binary-conduit 1.1.0 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.1.0 (AlexanderVershilov)
07:27:02 <thirsteh> What OS if you don't mind me asking?
07:27:50 <_mr> ubuntu 12.10 ;-)
07:28:07 <thirsteh> Do you have the haskell platform installed, or did you install most of the packages with cabal?
07:28:13 <thirsteh> I did the latter, so that's the only reason I can think of
07:28:52 <thirsteh> also, do you know what version of tls it installed?
07:29:01 <thirsteh> Sorry for all the questions, and thanks. Helps a lot.
07:29:04 <_mr> I have the platform
07:29:33 <thirsteh> ok
07:31:04 <aCube> @src return []
07:31:05 <lambdabot> Source not found. My brain just exploded
07:31:08 <aCube> @src [] return
07:31:08 <lambdabot> return x    = [x]
07:31:24 <_mr> thirsteh: any more questions I can answer? ;-)
07:32:44 <thirsteh> no, thanks again :)
07:32:47 <arcatan> thirsteh: just cabal-installed tls-debug on Ubuntu 12.04 and the tls-simpleclient command you gave worked
07:33:01 <thirsteh> okay, thanks. I'm gonna try blowing out my install and installing the platform
07:33:17 <arcatan> (i didn't have the platform)
07:33:41 <thirsteh> What version of tls?
07:34:10 <arcatan> 1.1.2
07:34:25 <_mr> tls-1.1.2 tls-extra-0.6.1
07:34:46 <thirsteh> well, huh. Same thing here, and I get the error on 3 different ubuntu 12.10 boxes on 3 different networks
07:43:19 <wayne> hi. why is -3 `mod` 5 => -3 and not +2?
07:43:48 <arkeet> because - has lower precedence than `mod`
07:43:52 <merijn> wayne: Because they're -3 and +2 are identical mod 5?
07:43:53 <arkeet> > (-3) `mod` 5
07:43:55 <lambdabot>   2
07:44:08 <wayne> ah sorry. rookie mistake.
07:44:11 <wayne> thank you.
07:44:21 <merijn> oh, it does abs the result?
07:44:21 <typoclass> wayne: no need to apologize :-)
07:44:23 <geekosaur> prefix (-) is a bit weird in haskell
07:44:33 <typoclass> wayne: when in doubt, add some ( ) here and there
07:44:34 <arkeet> merijn: not abs
07:44:41 <wayne> :) kay
07:44:48 <arkeet> that would just be wrong
07:44:53 <merijn> arkeet: Make positive, whatever
07:45:40 <hpaste> aCube pasted “Does return really take 20% of program runtime?” at http://hpaste.org/85910
07:46:57 <aCube> Hello, profiling tells that in that paste, the cost centre return takes 20% individual. Is it really just the line that takes 20% or is the cost of computing s' includeded in the time for return?
07:48:19 <aCube> (The whole snippet is in a do block)
07:51:39 <thirsteh> _mr, arcatan: Removed all packages, installed tls-debug, and it worked. So I must have some constraint somewhere that is installing a newer, incompatible dependency of tls
07:51:42 <thirsteh> thanks again
07:56:40 <latermuse> whats the proper way to use Text.Pack and map it over a list of Strings?
07:57:01 <latermuse> mapM Text.Pack (IO listOfStrings)   isnt working for me
07:57:19 <latermuse> oh woops
07:57:25 <latermuse> haha, im retarded. nevermind
07:58:28 <parcs> do all valid 'deriving' clauses have the kind 'k -> Constraint'?
08:00:03 <arkeet> parcs: indeed
08:00:09 <aCube> parcs: you mean like GenericNewtypeDeriving?
08:00:21 <parcs> yeah or regular deriving
08:00:33 <parcs> ok, just making sure
08:00:51 <arkeet> you can derive stuff like partially applied MPTCs but that's still the same kind.
08:02:00 <arkeet> GHC on generalized newtype deriving: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/deriving.html#id617080
08:22:00 * hackagebot semigroups 0.9.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.9.1 (EdwardKmett)
08:32:49 <facepalm> I was in here a few days ago with this same problem and have yet to resolve it. If anyone could offer some insite or tip that would be great thank you. my problem is the second function does not work correctly I have the details of it all in the pastebin.. Thank you http://pastebin.com/vAG9fH81
08:32:53 <mauke> The paste vAG9fH81 has been copied to http://hpaste.org/85914
08:35:52 <ab9rf> facepalm: "bounds1 l min max = bounds1 l min max" results in unbounded recursion
08:37:00 * hackagebot snap 0.11.2.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.11.2.2 (DougBeardsley)
08:37:07 <Ausprit> Hi everyone. I have a small problem using Haskell to save results of the computations made by a neural net. Since the net takes quite some time and its result is computed only when I need it to be saved, it keeps the file open the whole time. If anything happens, it just terminate with a truncated file, so I lose all past computations. What would be my best bet to prevent this from happening ?
08:37:09 <facepalm> yeah I couldnt figure out what to set that to because if the list isnt empty it is just supposed to simply return the result of the previous function
08:38:11 <facepalm> and I do not think I have the arguments correct in the initial deffinition either
08:38:26 <ab9rf> facepalm: i think you're probably right about tht
08:38:40 <c_wraith> Ausprit: force the whole calculation to finish before writing it to a file.  Or write it to a unique file each time.
08:38:54 <ab9rf> lazy IO FTL
08:39:04 <ab9rf> Ausprit: how are you writing to the file?
08:39:12 <c_wraith> that's not actually a lazy IO problem
08:39:19 <c_wraith> writing the file is strict
08:39:32 <ab9rf> oh, i usee
08:39:34 <c_wraith> It's just slow because the calculation isn't happening until the file is being written to.
08:39:45 <Ausprit> ab9rf, I tried with writeFile and with manually opening and closing a handle
08:39:55 <facepalm> so that is what I am come here to see if I can get help to figure out how to correct it. I have been reading learn you a haskell etc but haven't had any luck
08:40:14 <Ausprit> at least, doing it manually prevent the system from hanging while the handle is released...
08:40:21 <ab9rf> Ausprit: you want it not to write anything until the computation is finished?  or do what c_wraith suggested and not overwrite files
08:41:03 <c_wraith> It's often good policy to not overwrite files anyway. What if you suddenly want the results of three runs back?
08:41:12 <ab9rf> yeah
08:41:14 <c_wraith> much better to append a timestamp to the file name, or something.
08:41:14 <Ausprit> how can I make sure it is all done before. As I see it, using a bang will only evaluate the top most constructor (what is it called, weak head normal form or something)
08:41:46 <Ausprit> problem is that I run this loop for quite a lot of time (>1M)
08:42:11 <aCube> http://hpaste.org/85910 Why does the return cost centre take 20% of the runtime of the program here? It's only return ... [If you need more of the program, just say]
08:43:15 <Ausprit> c_wraith, what I meant by being lazy is more that the computation isn't made before the file is opened. This way, I have a file open for most of the time the program is running, which is really suboptimal for my needs
08:43:19 <ab9rf> you could deepseq it
08:43:45 <c_wraith> :t rnf
08:43:46 <lambdabot> Not in scope: `rnf'
08:43:52 <dolio> Always nice to see that the well is sufficiently poisoned against lazy I/O that people blame it for things its not even involved in.
08:43:53 <c_wraith> blah.
08:43:59 <ab9rf> dolio: heh
08:44:02 <c_wraith> :t deepseq
08:44:04 <lambdabot>     Not in scope: `deepseq'
08:44:04 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
08:44:11 <Ausprit> there is a function that seems promising, give me a sec while I look it up :)
08:44:13 <c_wraith> really, lambdabot?
08:44:14 <ab9rf> http://hackage.haskell.org/package/deepseq-1.3.0.1
08:44:21 <dolio> :t deepSeq
08:44:23 <lambdabot>     Not in scope: `deepSeq'
08:44:23 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
08:44:33 <Ausprit> wait, there is a ghci running on the channel, that's awesome :P
08:44:39 <c_wraith> Ausprit: you are correct that a bang pattern only gives you WHNF. You can either alter your data types so that WHNF requires normal form, or you can make your data types instances of the typeclass needed for deepSeq
08:45:22 <Ausprit> :t Control.deepseq
08:45:23 <lambdabot> Couldn't find qualified module.
08:45:36 <Ausprit> oh, its a library
08:46:15 <latermuse> is it possible to use Data.Text to write to a file without unpacking the text first?
08:46:15 <Ausprit> for my education purpose, how would a constructor be made to insure a normal form when evaluated ?
08:46:41 <c_wraith> data Foo = Foo !Bar
08:47:08 <Ausprit> which needs, if I'm not mistaken a ghc extension, right ?
08:47:14 <c_wraith> that one does not
08:47:23 <c_wraith> The exclamation mark there means "When you evaluate the Foo constructor, the value stored in this slot must also be evaluated"
08:47:49 <geekosaur> latermuse, Data.Text.IO module (part of the basic text package)
08:47:58 <latermuse> geekosaur: thanks love
08:48:05 <c_wraith> putting ! on arguments in a function definition requires an extension. Putting ! in fields in a data type is part of the standard.
08:48:21 <Ausprit> great, thanks a lot for your help c_wraith and ab9rf, it's really appreciated !
09:07:01 <allenj12> hey how would i turn a string "ABCD" to ["A","B","C","D"] would i have to make my own function or is there something that already does that?
09:07:15 <Botje> > map return "ABCD"
09:07:17 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Char))
09:07:17 <lambdabot>    arising from a use o...
09:07:21 <adimit> > map (:[]) "ABCD"
09:07:22 <lambdabot>   ["A","B","C","D"]
09:07:38 <allenj12> kk ty!
09:08:02 <adimit> I like to call (:[]) the 'duck operator')
09:08:30 <osfameron> hehe
09:09:18 <byorgey> adimit: historically it has also been called the "robot monkey operator" =)
09:09:42 <shachaf> @quote eat.a
09:09:43 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
09:09:57 <adimit> byorgey: does it eat functional bananas?
09:10:23 <byorgey> adimit: of course
09:10:59 <byorgey> adimit: http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/960824968_NLLt4fx#!i=960824968&k=NLLt4fx
09:11:42 <adimit> :-D
09:14:42 <Palmik> Hmm, interesting. Inserting element into a map of 200K elements takes almost twice (1.98 times) as much as inserting an element into map of 100K elements.
09:15:13 <ab9rf> Palmik: this is surprising?
09:15:29 <Palmik> Yes, I would not expect linear increase in time.
09:15:39 <Palmik> But perhaps there are some big constants at work.
09:15:40 <adimit> Data.Map has an insertion time of O(log n)
09:16:03 <Palmik> Exactly.
09:16:20 <adimit> but it probably depends a lot on the efficiency of the Ord instance, too.
09:16:30 <Palmik> I used Int as a key.
09:16:57 <adimit> have you used criterion to benchmark it?
09:17:07 <Palmik> Yes.
09:17:15 <Palmik> I will link the benchmark in a second.
09:17:28 <pmk> grr, Data.Foldable.toList on a Map /= Data.Map.toList
09:17:28 <adimit> (generally, if you want performance, I'd recommend IntMap for Int keys, and unordered-containers for anything else.)
09:18:00 <Palmik> Yes, I was using Data.Map.Map because I am comparing it to some data structure that internally also uses Data.Map.Map
09:18:32 <Palmik> Here: https://github.com/Palmik/data-store/blob/v0.2/benchmarks/src/01.hs#L68
09:18:41 <ab9rf> might be worth profiling to see where it is consuming the most time
09:19:58 <Palmik> By the way, does anyone know if it is possible to have a type family F such that F Int = TT and F a = FF for any a that is not Int?
09:20:16 <Palmik> (or rather ~ instead of =)
09:21:01 <Palmik> (and Int is just an example)
09:21:06 <elliott> Palmik: in GHC HEAD, yes
09:21:14 <elliott> type family F a; type instance where F Int = TT; F a = FF
09:21:40 <Palmik> elliott: so it will not complain about overlaps?
09:21:55 <Palmik> And when WILL it complain about overlaps?
09:22:03 * hackagebot snaplet-coffee 0.1.0.2 - CoffeeScript for Snap, auto-compilation and pre-compilation.  http://hackage.haskell.org/package/snaplet-coffee-0.1.0.2 (KevinVanRooijen)
09:22:43 <Palmik> I was asking because I do not want to use the evil OverlappingInstances and such type family would suffice for my purposes (I need special instance for fixed number of before known types)
09:22:57 <Palmik> And such type family would make that possible.
09:23:55 <elliott> Palmik: it will not because you said "type instance where"
09:23:58 <elliott> the syntax specifically for overlaps
09:24:51 <Palmik> Aaah, did not notice. So it's kind of closed. I think I have seen something like that on haskell wiki or somewhere.
09:25:51 <Palmik> elliott: So type family F a; type instance where F [a] = TT; F a = FF would also work?
09:25:59 <elliott> I think so.
09:26:05 <ab9rf> should
09:27:58 <Ausprit> Is it possible to add function types in instance declaration ?
09:31:44 <fizbin> >2 2
09:32:04 <fizbin> > 2 2 2
09:32:05 <lambdabot>   2
09:32:17 <fizbin> > 2 2
09:32:18 <lambdabot>   2
09:34:07 <klrr> GUYS
09:34:14 <klrr> ive written my first program in haskell!!!!
09:34:16 <klrr> https://github.com/klrr/scmbot
09:34:18 <klrr> :)
09:34:26 <typoclass> klrr: heh :) congratulations
09:34:33 <klrr> thanks
09:34:34 <fizbin> With a cabal file!
09:34:41 <fizbin> I should learn cabal...
09:34:46 <kryft> I have yet to get that far :)
09:34:47 <klrr> it's not hard
09:34:57 <klrr> also
09:35:10 <arkeet> just use cabal init, it's easy.
09:35:15 <kryft> My approach to learning programming languages tends to be rather abstract, and haskell's nature isn't helping :P
09:35:16 <arkeet> and then copy paste from others
09:35:18 <klrr> my program has lots of code from both tutorials i mentioned, i didnt implement lisp from scratch
09:37:42 <quchen> Great! Now learn about monads. :P
09:39:14 <hpaste> allenj12 pasted “Help with lists” at http://hpaste.org/85917
09:39:37 <allenj12> can someone help me figure out an easy way to do that?
09:40:30 <Botje> allenj12: why not generate a list of "negatives" from the original list and append it?
09:40:53 <Botje> orig ++ map ('-':) orig
09:41:31 <allenj12> o yes ofc sorry that was kinda a lame question wasnt it must be getting tired
09:41:33 <allenj12> TY
09:41:58 <supki> @ty concat . transpose . map (\x -> [x, '-':x])
09:41:59 <lambdabot> [[Char]] -> [[Char]]
09:49:40 <hpaste> allenj12 pasted “Help with lists again” at http://hpaste.org/85919
09:49:42 <allenj12> hmmm im now getting a parse error i dont understand
09:50:00 <quchen> "in" missing.
09:50:17 <quchen> let <definitions> in <expression>
09:50:23 <quchen> > let a = 2 in a+a
09:50:25 <lambdabot>   4
09:51:30 <geekosaur> note that there is a variant `let' syntax specifically for use with monadic `do'; perhaps that's what you're thinking of.
09:51:51 <geekosaur> (and the compiler rewrites it into the normal `let`)
09:51:54 <allenj12> oooooo ok
09:52:27 <allenj12> i got it to work percectly now i was always a little confused on "in" ty for explaining so nicely
09:52:52 <shachaf> Hmm, Haskell doesn't support "please do" notation.
09:53:55 <quchen> shachaf: let please = id
09:53:56 <quchen> :-D
09:54:11 <sproingie> haskell should support don't notation
09:54:21 <geekosaur> anyone Cont-ed up a come from yet? :p
09:54:23 <otters> what would don't do
09:54:26 <quchen> sproingie: IT DOES!
09:54:52 <quchen> http://new-hackage.haskell.org/package/acme-dont
09:54:57 <shachaf> quchen: If that syntax worked I wouldn't have said what I said.
09:55:29 <quchen> Hm. let plea = id --> plea$ do
09:55:46 <sproingie> aw you still have to give it a do block
09:56:07 * geekosaur semiseriously considers a don't which desugars using (.) and const
09:56:08 <otters> > let plea = id; e = id in plea$e do { return 4 }
09:56:10 <lambdabot>   <hint>:1:33: parse error on input `do'
09:56:11 <quchen> sproingie: Well, it's a "don't do" block.
09:56:15 <otters> rats
09:56:17 <merijn> > let plea = id; e = id in plea$e do return 4 :: Maybe Int
09:56:19 <lambdabot>   <hint>:1:33: parse error on input `do'
09:56:48 <merijn> Oh, I'm not the only one to think of that :p
09:57:11 * hackagebot nsis 0.2.2 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.2.2 (NeilMitchell)
09:57:50 <geekosaur> we could call the underlying abstraction a nonad
09:58:04 <quchen> When in doubt, use CPP
09:58:33 <sproingie> would cpp be able to handle the apostrophe?
09:58:49 <geekosaur> probably not
09:58:52 <quchen> Yeah
09:58:55 <quchen> Damn you English
09:59:30 <geekosaur> maybe cpphs would though...
10:02:21 <lispy> CPP is evil; good thing we use it all the time in our Haskell code :)
10:02:32 <DMcGill> nonad = Control.Applicative.Const
10:02:41 <sproingie> i thought the evil mangler was evil
10:02:59 <c_wraith> they're hard to compare.  Best I can say is they have similar levels of evil
10:03:07 <c_wraith> Though the evil mangler has been excised.
10:03:13 <c_wraith> and CPP has not
10:03:21 <sproingie> exorcised would be a better choice of word
10:03:39 <hpaste> flebron pasted “How can I improve the efficiency of this?” at http://hpaste.org/85920
10:03:40 <flebron_> Hi. I'm reading a very, very large list of Ints from stdin, separated by newlines. The file is preceded by an Int which indicates the number of lines. I want to xor all the numbers together (not including the first one, of course). How can I improve what I currently have?
10:04:12 <flebron_> By improve, I mean use less time. I think I am not exploiting tail recursion, correct?
10:04:33 <DMcGill> flebron_: correct
10:04:47 <flebron_> Alright, I will make it do that then.
10:04:53 <flebron_> Anything else that's glaringly obvious?
10:04:54 <DMcGill> make a readNumbers' :: Bool -> ByteString -> Bool
10:04:57 <c_wraith> flebron_: best to make the function that reads the numbers just return a list of them
10:05:02 <flebron_> Not Bool, but Int.
10:05:07 <c_wraith> flebron_: then make xoring them a separate process
10:05:09 <DMcGill> such that readNumbers = readNumbers' empty
10:05:25 <flebron_> Really, c_wraith? In terms of efficiency, why is that better?
10:05:32 <c_wraith> flebron_: then you can just use whatever fold is appropriate over the list. (foldl' is the correct fold, in this case)
10:05:47 <flebron_> Yes, foldl' would be the right one, due to strictness.
10:05:58 <flebron_> Will writing it that way not incur a performance penalty?
10:06:10 <applicative> flebron_: for one thing, use B.null, or rather C.null .... if C.null bs then 0 else
10:06:14 <c_wraith> benchmark. It might, it might not.
10:06:43 <c_wraith> But it lets you write correct code trivially. I think that's more important until benchmarks tell you otherwise.
10:07:11 * hackagebot data-category 0.5.1.1 - Category theory  http://hackage.haskell.org/package/data-category-0.5.1.1 (SjoerdVisscher)
10:07:13 <ozataman> Anybody aware of a nice trick so that the statement: [(error "So that it can have type 'IO a'") >> print "Hello"] does not raise an exception, but still has type IO a in the first segment with 'error' in it?
10:07:26 <flebron_> Oh, yes, this is for a programming contest, and I'm getting "time limit exceeded", that's why my code is so ugly :)
10:07:37 <flebron_> (Well, that's one of the reasons, the other reason is just being a poor Haskeller :))
10:07:41 <ozataman> essentially making the first IO action lazy, trusting that it won't ever be referenced later
10:08:34 <DMcGill> ozataman: why do you want to?
10:08:51 <c_wraith> ozataman: for what purpose? It's part of the definition of (>>) in IO that the first argument is evaluated to WHNF
10:09:00 <ozataman> I'm writing multiple evaluation functions using the operational library and I don't want to execute some instructions in one of the evaluators
10:09:04 <applicative_> flebron_: not that the Bytestring modules have folds in them
10:09:12 <flebron_> applicative_: Not, or note?
10:09:25 <applicative_> Note
10:09:26 <c_wraith> I don't see how the bytestring folds would help
10:09:27 <klrr> okey, now i've written a irc bot that evaluates scheme expressions, what should i do next?
10:09:35 <flebron_> Yay, making it use tail recursion makes it fast enough :)
10:09:38 <c_wraith> since it's folding over numbers, not bytestrings
10:09:42 <applicative_> oh maybe I'm missing something, just a sec
10:09:42 <DMcGill> klrr: have you gone through typeclassopedia?
10:09:48 <klrr> DMcGill: what's that?
10:09:49 <supki> ozataman: unsafeInterleaveIO?
10:09:50 <ozataman> in one eval function it's fine to call on IO actions and all IO actions will be discarded in the other one, so if you have a function that depends on the output of an IO action, it should raise a runtime error
10:09:55 <DMcGill> @where typeclassopedia
10:09:55 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:10:01 <klrr> ty
10:10:08 <DMcGill> the next step from being able to code in Haskell is being able to code smartly in it!
10:10:17 <applicative_> whats the type of readNumber supposed to be?
10:10:22 <flebron_> I'll try using lists and foldl' for good measure :)
10:10:50 <c_wraith> ozataman: if you want to prevent using the *result* of the IO action, make it return $ error "blah"
10:11:15 <ozataman> c_wraith: that was my first try, but doesn't work. it's not lazy enough - that raises an exception immediately
10:11:33 <ozataman> >>> (error "So that it can have type 'IO a'") >> print "Hello"
10:11:49 <c_wraith> put a return in there, and there will be no exception raised
10:12:37 <c_wraith> Prelude> return (error "foo") >> print 5
10:12:37 <c_wraith> 5
10:12:43 <ozataman> ahha!
10:12:52 <ozataman> perfect
10:12:52 <ozataman> :)
10:13:14 <merijn> klrr: Also, learning lens might be a good next step :)
10:13:17 <ozataman> c_wraith: thank you sir, and "duh" to me!
10:13:29 <c_wraith> I really *should* say it might be better to find a way to do what you want without bottoms. :)
10:13:42 <klrr> Martty: what's lens?
10:13:48 <ozataman> c_wraith: yeah, I suspect I'd have to go to a deeper embedding
10:14:00 <ozataman> c_wraith: I'm just shallow embedding IO actions for now
10:14:20 <Martty> hm?
10:14:25 <klrr> im thinking of studying https://github.com/pedromartins/cuboid that program, but is that too difficult ?
10:14:26 <merijn> klrr: You know record syntax?
10:14:28 <applicative_> flebron_: Vector.foldr xor 0 (Vector.unfoldr C.readInt bytestring)  ?
10:14:31 <klrr> merijn: yeah
10:14:46 * flebron_ tries haha
10:14:56 <flebron_> Using   let nums = map (fst . fromJust . C.readInt) $ tail c was too slow.
10:15:12 <flebron_> Where   c <- liftM C.lines C.getContents, and I say   print $ foldl' xor 0 nums.
10:15:12 <merijn> klrr: Then you that to update a value you do, "foo { updatedField = x }". Now imagine trying to have records nested three or more levels deep, becomes quite ugly and unreadable, right?
10:15:35 <klrr> merijn: yeah
10:15:36 <flebron_> applicative_: Why do I need to create a vector though?
10:15:44 <flebron_> I mean, isn't it better to do this streaming?
10:15:48 <applicative_> to do the xoring
10:15:52 <merijn> klrr: lenses are basically composable getter/setters that let you do stuff like "update (field1 . field2 . field3) value"
10:16:28 <applicative_> vector is in theory streaming, flebron_  ideally there wont be a vector, but maybe it'll be a disaster....
10:16:32 <flebron_> applicative_: Wouldn't the tail recursive version be strictly better, since it uses less space?
10:16:33 <flebron_> Ah.
10:16:34 <fizbin> I need to write up this "Mistakes with Lenses" blog post I've had half-formed in my head for a week or so...
10:16:48 <klrr> merijn: oh okey, well after typeclassopedia that will be my next step then :)
10:16:52 <merijn> klrr: Which was a neat idea and had people implementing a bunch of libraries for this, and then edwardk went a bit overboard and started writing Control.Lens which has about a billion different operators for doing things like updates, setting, traversals and what not
10:17:06 <merijn> klrr: There's a nice talk introducing the whole bunch on youtube
10:17:08 <merijn> @where lens
10:17:08 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
10:17:41 <applicative_> flebron_: I was just worried whether what I wrote was correct, mostly, I'm not sure but a handwritten accumulating loop will probably be best
10:18:02 <klrr> merijn: cool will watch video :)
10:19:02 <flebron_> Hrm, that's weird.
10:19:14 <flebron_> Let's say the bytestring is "2\n8\n9\n2\n8\n".
10:19:15 <merijn> klrr: Be warned it's 2 hours long and you probably want to follow some of the derivations by hand on paper :p
10:19:21 <flebron_> Oh, OK, I get what's happening.
10:19:36 <flebron_> readInt should also C.tail to get rid of the newline.
10:19:44 <flebron_> This is a job for lenses, am I right?
10:20:07 <klrr> merijn: derivations?
10:20:17 <flebron_> (That is, C.readInt "2\n3" == Just (2, "\n3"), but C.readInt "\n3" == Nothing.)
10:20:29 <flebron_> I'll make the trivial fix.
10:21:22 <merijn> klrr: It shows how given a really abstract type some other functionality "magically" falls out if you pick the right type constructor to pass to them
10:21:53 <klrr> merijn: that's sounds scary xD
10:23:39 <flebron_> Aww drat. The online judge I'm using doesn't have Data.Vector (GHC 6.10!). But your code does seem to do the right thing, applicative_. Not sure about efficiency.
10:24:00 <klrr> are these videos good? have someone watched them, ive only experienced crappy content on youtube(except stuff on youtube from conferences etc.) are these worth watching? https://www.youtube.com/user/jekor/videos?view=0&flow=grid
10:25:28 <DMcGill> flebron_: Data.Array is almost as good as Data.Vector
10:25:35 <DMcGill> there's still unboxed versions and so on
10:26:05 <typoclass> klrr: there's all the theory to lenses, but in practice, it all works out to be very straightforward. check these examples https://github.com/ekmett/lens/wiki/Examples
10:26:34 <klrr> typoclass: thanks :)
10:27:30 <DMcGill> is there a tutorial or example on lens zippers anywhere?
10:27:37 <aCube> http://hpaste.org/85910 Why does the return cost centre take 20% of the runtime of the program here? It's only return ... [If you need more of the program, just say]
10:28:00 <sproingie> ask any retailer, processing returns is expensive
10:28:02 * sproingie har har
10:35:54 <klrr> > fmap fmap fmap
10:35:56 <lambdabot>   Ambiguous type variable `f0' in the constraint:
10:35:56 <lambdabot>    (GHC.Base.Functor f0) ar...
10:36:09 <klrr> > fmap fmap fmap [1,2,3,4,5]
10:36:11 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
10:36:37 <klrr> > fmap fmap $ fmap (fmap (+2)) [1,2,3,4,5]
10:36:37 <int-e> > fmap fmap fmap (+) (*) 2 3 4
10:36:39 <lambdabot>   Ambiguous type variable `f0' in the constraint:
10:36:39 <lambdabot>    (GHC.Base.Functor f0) ar...
10:36:39 <lambdabot>   can't find file: L.hs
10:36:45 <klrr> > fmap fmap $ fmap (fmap (+2)) [1,2,3,4,5]
10:36:45 <klrr> > fmap fmap fmap [1,2,3,4,5]
10:36:46 <klrr> > fmap fmap fmap [1,2,3,4,5]
10:36:46 <klrr> > fmap fmap fmap [1,2,3,4,5]
10:36:47 <lambdabot>   Ambiguous type variable `f0' in the constraint:
10:36:47 <lambdabot>    (GHC.Base.Functor f0) ar...
10:36:48 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
10:36:48 <lambdabot>   can't find file: L.hs
10:36:48 <lambdabot>   can't find file: L.hs
10:36:48 <aCube> :t fmap fmap fmap
10:36:49 <klrr> sry!
10:36:51 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:36:52 <aCube> :t fmap fmap fmap
10:36:53 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:36:57 <int-e> > fmap fmap fmap (+) (*) 2 3 4
10:36:59 <lambdabot>   10
10:37:04 <sproingie> keep fmapping like that and you'll go blind
10:37:05 <klrr> wtf!
10:37:08 <aCube> fmap fmap fmap is just fmap . fmap
10:37:12 <klrr> my head expoded
10:37:17 <klrr> exploded
10:37:33 <int-e> @type (.) . (.)
10:37:35 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:37:45 <sproingie> what'll really bake your noodle is that a long enough chains of fmap starts to cycle and become equivalent to shorter ones
10:38:05 <aCube> fmap fmap fmap = fmap . fmap = \x -> fmap (fmap x)
10:38:08 <int-e> @. djinn type (.) . (.)
10:38:10 <lambdabot> f a b c d = a (b c d)
10:38:42 <int-e> @unpl (.) . (.)
10:38:43 <lambdabot> (\ i b c f -> i (b c f))
10:39:32 <aCube> :t foldl ($) id $ replicate 3 fmap
10:39:33 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
10:39:33 <lambdabot>     Expected type: (((a0 -> a0) -> (a0 -> a0) -> a0 -> a0)
10:39:33 <lambdabot>                     -> (a0 -> a0) -> (a0 -> a0) -> a0 -> a0)
10:39:45 <aCube> :t fmap fmap fmap fmap fmap fmap
10:39:46 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
10:39:51 <aCube> :t fmap fmap fmap fmap fmap fmap fmap
10:39:52 <lambdabot> (Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
10:41:26 <aCube> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:41:29 <lambdabot> (Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
10:44:14 <adimit> @unpl (.)
10:44:14 <lambdabot> (\ a b c -> a (b c))
10:45:58 <aCube> @hoogle catch
10:45:59 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
10:45:59 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
10:45:59 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
10:48:10 * aCube 's prelude doesn't export catch ?
10:48:28 <supki> it doesn't in 7.6
10:48:37 <typoclass> aCube: maybe it changed with ghc 7.6, because of OldExceptions being removed
10:49:43 <aCube> it's in Control.Exception, found it :P
10:51:55 <monochrom> a long time ago, Prelude exported catch, but that catch was not general
10:52:47 <monochrom> Control.Exception's catch is more general, and preferred.
10:54:27 <aCube> return of the Codensity monad seems to be slow :(
10:54:35 <arkeet> :t liftA2
10:54:37 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:57:22 <parcs> hi
10:57:24 <hpaste> applicative annotated “How can I improve the efficiency of this?” with “How can I improve the efficiency of this? (annotation)” at http://hpaste.org/85920#a85922
10:57:38 <aCube> @undo x <- a; y <- b ; c x y
10:57:38 <lambdabot>  Parse error at "<-" (column 3)
10:57:42 <aCube> @undo do x <- a; y <- b ; c x y
10:57:43 <lambdabot> a >>= \ x -> b >>= \ y -> c x y
10:57:47 <applicative_> hi parcs
10:58:38 <aCube> @src StateT (>>=)
10:58:38 <lambdabot> Source not found. My mind is going. I can feel it.
11:03:47 <hpaste> “Anonymous Coward” pasted “with transaction” at http://hpaste.org/85925
11:03:52 <aCube> @hackage dlist
11:03:52 <lambdabot> http://hackage.haskell.org/package/dlist
11:07:54 <mgccl> can one use none english characters in Haskell? say somethign like data Relation = 玄孫 | 孫子
11:08:05 <DMcGill> mgccl: ghc has a unicode mode
11:08:11 <dcoutts> @faq can one use none english characters in Haskell?
11:08:11 <lambdabot> The answer is: Yes! Haskell can do that.
11:08:29 <dcoutts> DMcGill: you don't even need that
11:09:02 <dcoutts> DMcGill: that's for things like using a unicode arrow instead of ->
11:09:37 <mgccl> it tells me... not a data constructor when I compile ot
11:09:45 <mgccl> *it
11:10:00 <dcoutts> mgccl: the constraint is that there needs to be a notion of case, upper case & lower case
11:10:17 <dcoutts> ghc uses the unicode properties for that
11:10:43 <_mr> dcoutts: so without "unicode mode" you can define unicode -> as an ordinary function?
11:11:03 <dcoutts> _mr: probably (as an operator)
11:11:12 <_mr> Cool :-)
11:11:18 <mgccl> oh... then Chinese characters can't be used for function names/data constructors...
11:11:38 <dcoutts> _mr: again, depends on the unicode properties, there's a property for being a symbol
11:11:46 <mgccl> this upper/lower case thing seems like an arbitrary constraint.
11:12:11 <mgccl> are there opetions to turn that off?
11:12:14 <dcoutts> mgccl: it's because we need a syntactic way to distinguish data constructors from variables
11:12:25 <dcoutts> and type constants from type variables
11:12:54 <dcoutts> and the method that the language designers picked was upper/lower case of the first letter
11:13:01 <dcoutts> so no, you cannot turn it off
11:13:22 <geekosaur> sadly
11:13:30 <dcoutts> mgccl: I guess you could have a convention, like data Relation = C玄孫 | C孫子
11:13:55 <_mr> dcoutts: I see. For some reason I was expecting symbols that don't have upper/lowercase to _be_ lowercase
11:13:57 <mgccl> yep, that would work. thanks :)
11:15:21 <dcoutts> mgccl: to see the issue, suppose you had a function like:  foo (玄孫  孫子) = ...
11:15:46 <dcoutts> how can we tell which bit of the pattern is a data constructor and which introduces a local variable?
11:16:43 <dcoutts> compare that to: foo (Just x) = ...
11:16:54 <dcoutts> we can see that Just is a constructor and x is a variable
11:17:12 * hackagebot sgd 0.3 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3 (JakubWaszczuk)
11:17:22 <mgccl> that's true, there is no way around that.
11:17:30 <dcoutts> mgccl: obviously the use of case there is very anglo-centric, but that's what they decided
11:18:32 <saml> given two [Ord a], how do I get similarity score?
11:18:33 <liyang> foo (cons var) = … is obvious, no?
11:18:39 <arkeet> @hoogle Monad m => (a -> m [b]) -> [a] -> m [b]
11:18:40 <lambdabot> No results found
11:18:51 <arkeet> hrmpf
11:19:02 <dcoutts> liyang: no, that could be two constructors
11:19:12 <saml> similar "55th street"   "55 th. st."  >  similar "55th street" "55th ave"
11:19:42 <dcoutts> liyang: that doesn't let you distinguish between foo (Just Nothing) = ...  and foo (Just nothing) = ...
11:19:42 <liyang> dcoutts: well, okay, it's obvious that cons is a constructor. Disregard the var part.
11:19:55 <dcoutts> liyang: the var part is the problem
11:20:13 <arkeet> heh, there's a concatMapM in multiple places.
11:20:30 <dolio> foo (just (nothing))
11:20:34 <dolio> Problem solved.
11:20:51 <merijn> mgccl, _mr, dcoutts: afaik Haskell just follows the unicode definition of uppercase/lowercase
11:20:59 <dcoutts> merijn: yep
11:21:03 <liyang> (If only the typechecker knew whether 'cons' or 'var' were in-scope constructors…)
11:21:40 <dcoutts> liyang: that still doesn't help because you don't know if it's supposed to be a definition or a use
11:21:42 <monochrom> I assume similarity score means (\xs ys -> sum (zipWith (\x y -> if x==y then 1 else 0) xs ys))
11:22:00 <arkeet> > generalCategory 'A'
11:22:02 <lambdabot>   UppercaseLetter
11:22:08 <typoclass> saml: i don't think the base package has a levenshtein or something simliar. however, ghc has an implementation for the "Did you mean" feature. at worst, you could copy-paste that
11:22:13 * hackagebot crf-chain1-constrained 0.2.0 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.2.0 (JakubWaszczuk)
11:22:18 <typoclass> > headd []
11:22:19 <lambdabot>   Not in scope: `headd'
11:22:19 <lambdabot>  Perhaps you meant one of these:
11:22:19 <lambdabot>    `head' (imported ...
11:22:19 <dcoutts> > generalCategory '玄'
11:22:20 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
11:22:21 <liyang> dcoutts: Agda does it somehow.
11:22:27 <typoclass> saml: example ^^
11:22:44 <saml> i like copy pasting
11:22:54 <monochrom> you're so lazy
11:23:08 <dolio> The way Agda does it will allow import changes to break previously valid definitions.
11:23:10 <typoclass> saml: yeah well, "at worst"
11:23:11 <merijn> dcoutts: lambdabot doesn't handle unicode over IRC, afaik
11:24:24 <elliott> dolio: well, so does Haskell.
11:24:27 <elliott> for other reasons.
11:24:47 <mewtwo> Hello I am running Haskell 7.4.1 and getting the log http://pastebin.com/Fb4hHpZP while installing CV? What can be possible problem?Thanks in advance
11:24:52 <mauke> The paste Fb4hHpZP has been copied to http://hpaste.org/85928
11:27:03 <dolio> It might not even be an error. Just do the wrong thing.
11:29:17 <dcoutts> liyang: I'm surprised agda does it the way it does, it does seem rather unprincipled not to distinguish clearly between definition and use sites
11:32:29 <Ontolog> > let x = 5; y = 10 in x + y
11:32:31 <lambdabot>   15
11:32:42 <Ontolog> why do I need semicolon and can't use newline instead?
11:33:00 <ion> You can.
11:33:25 <Ontolog> oh yes i can
11:34:01 <int-e> mewtwo: wrong version of OpenCV; the cvDistTransform function used to have 6 arguments; now it has seven.
11:36:04 <liyang> dcoutts: the colours make it clear!
11:36:05 <mewtwo> int-e: Thanks
11:36:11 <dcoutts> liyang: :-)
11:36:22 <applicative_> mewtwo: i was just noticving the type,   cvDistTransform :: ((Ptr ()) -> ((Ptr ()) -> (CInt -> (CInt -> ((Ptr CFloat) -> ((Ptr ()) -> (IO ())))))))
11:36:27 <applicative_> yipe
11:37:15 <geekosaur> seems like a lot of those parens are superfluous
11:37:38 <Taneb> Haskell isn't lisp
11:38:14 <ion> or Russian))))))))
11:38:14 <int-e> geekosaur: it's generated code
11:38:16 <applicative_> yeah, it's generated
11:38:31 <geekosaur> I figured
11:38:44 <ejones> exit
11:39:32 <monochrom> if Haskell were Lisp, you would write (:: map (-> (-> a b) (-> ([] a) ([] b)))))
11:39:55 <Botje> is liskell still alive?
11:40:02 <monochrom> I don't know
11:40:13 <lispy> Botje: I think it's pining for the fjords at this point
11:40:47 <Botje> looks like.
11:41:31 <dolio> All those parens actually make the structure more difficult to determine.
11:42:05 <lispy> When you program in lisp/scheme regularly you kind of adjust
11:42:28 <lispy> Not 100%, but there is some abilility to read things like that without too much effort if you're "used to it"
11:42:28 <int-e> dolio: you should be thinking less like a human and more like a computer ;-)
11:42:30 <monochrom> in reality, I would use line breaks and indentation
11:42:49 <monochrom> s/use/add/
11:43:50 <dolio> lispy: You adjust to being able to tell at a glance that something like cvDistTransform isn't actually higher-order?
11:44:46 <int-e> there is also a fine distinction between "simple" and "easy" that can be explained taking lisp code as an example.
11:45:13 <int-e> sorry, its syntax.
11:47:13 * hackagebot crf-chain2-tiers 0.1.0 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.1.0 (JakubWaszczuk)
11:51:39 <trescenzi> What is the type of a function that does nothing but signals an error?
11:51:49 <danharaj> Signals an error in what way.
11:52:03 <trescenzi> using error("")
11:52:06 <int-e> @type undefined -- ?
11:52:06 <typoclass> @type error -- trescenzi, might be this
11:52:07 <danharaj> :t error
11:52:07 <lambdabot> [Char] -> a
11:52:08 <lambdabot> [Char] -> a
11:52:09 <bahaa> a ?girlfriend
11:52:09 <lambdabot> a
11:52:13 * hackagebot concraft 0.6.0 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.6.0 (JakubWaszczuk)
11:53:21 <aCube> Does the codensity monad bring improvements if I'm only using the do-notation?
11:53:41 <typoclass> trescenzi: here "a" is a type variable that stands for anything at all. this means you can use "error ..." where any value is needed; it will always type-check
11:54:12 <dmwit> aCube: do notation and non-do-notation are interconvertible, so I don't understand how using it or not could matter.
11:54:35 <typoclass> trescenzi: of course you don't really get a useful value, you only get a crash at runtime :)
11:54:56 <trescenzi> ok cool typoclass. it should crash at runtime lol that's my goal lol
11:57:14 * hackagebot happstack-hsp 7.1.2 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.1.2 (JeremyShaw)
11:57:15 <aCube> dmwit: Better question: Can I achieve the same effects of codensity without actually using codensity? Because I found the return operation of Codensity is quite slow
11:57:16 * hackagebot web-plugins 0.2.2 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.2 (JeremyShaw)
11:59:07 <dolio> If everything you write is do notation where any recursive calls are the very last thing, then codensity probably doesn't make anything better.
12:00:12 <aCube> Hmm, it seems like it improves the performace, I'd just like the return operation to be a bit faster
12:00:30 <danharaj> It's probably better to use the less heavyweight Free construction in the free package than full Codensity.
12:00:41 <danharaj> In particular the Church representation.
12:01:59 <dolio> Actually, my rule probably isn't good enough, either, but it's something like that.
12:03:53 <dolio> dmwit: The question is presumably that Codensity tends to make things that look like ((m >>= f) >>= g) >>= h perform better, but do notation desugars to m >>= \x -> f x >>= \y -> g y >>= h, which tends to be the 'well performing' version of the former.
12:04:34 <dolio> But whether codensity matters in the latter depends on f and g.
12:04:46 <dmwit> I'm just saying that there must be some other condition than "just use do notation", since the former can be done with do notation as well.
12:04:46 <dolio> And h, I guess.
12:05:11 <dmwit> And I was encouraging him to think about what that other condition might be (since I know basically nothing about Codensity myself).
12:05:21 <dolio> It can, but no one ever writes it.
12:05:30 <dmwit> =)
12:06:03 <aCube> return is still taking 20% of the runtime of my program, even with the Church monad :(
12:06:52 <dolio> Are you sure you're not profiling some other cost being attributed to return?
12:07:44 <aCube> dolio: yes, I think it is the call to the "continutation" in the return that takes so long
12:09:38 <aCube> dolio: I put a {-# SCC ret #-} just around the return
12:09:57 <aCube> i.e. {-# SCC ret #-} return s'
12:10:17 <dolio> Well then you're attributing the cost of whatever continuation was built up to the return function.
12:10:58 <dolio> Like, 'do x <- return 5 ; contAckermann x'
12:11:04 <dolio> return takes forever.
12:11:09 <ab9rf> heh
12:12:01 <__xc> I guess json is evil in haskell since json arrays mixes any types
12:12:02 <dolio> That might just mean it's an inopportune point to put an SCC.
12:12:14 * hackagebot ghc-vis 0.6.1.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.6.1.1 (DennisFelsing)
12:12:19 <dolio> Although, maybe that makes codensity very hard to profile.
12:12:34 <aCube> so if the return is the last statement in a do block, and I add an SCC, it shows me the cost of all previous SCCs?
12:13:27 <dolio> If it's the continuation call, then it shows the cost of everything that happens after the return.
12:13:40 <dolio> Presumably.
12:13:56 <dolio> I don't know if that's what it is, but it's not out of the realm of possibility.
12:14:29 <aCube> But it's the last statement, so there is nothing happening after
12:15:10 <aCube> ah right, it's called from another function
12:15:13 <dolio> Is there only a single return anywhere?
12:15:20 <dolio> And no sequencing after?
12:15:23 <aCube> So it shows the cost of the statements after the call from the other function?
12:15:29 <dolio> Maybe.
12:15:46 <aCube> Ow, and I'm also using msum there :/
12:16:48 <dolio> My guess is that this is just going to be really hard to profile.
12:17:23 <aCube> Yeah, I got that too now :P
12:18:27 <aCube> So I'll just remove the Church monad for profiling and assume it's better when I turn it on again?
12:19:04 <dolio> Yeah, hopefully you can profile the normal one, and then drop in codensity or what have you and it will get faster.
12:19:51 <aCube> @src [Church [Int]] msum
12:19:51 <lambdabot> Source not found. You speak an infinite deal of nothing
12:20:08 * aCube still hasn't got the syntax of src
12:27:18 * hackagebot skein 1.0.1 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.1 (FelipeLessa)
12:32:28 <parcs> @src [] msum
12:32:28 <lambdabot> Source not found.
12:32:35 <parcs> @src msum
12:32:35 <lambdabot> msum =  foldr mplus mzero
12:32:39 <parcs> @src [] mplus
12:32:39 <lambdabot> mplus = (++)
12:33:12 <aCube> @src StateT [] mplus
12:33:12 <lambdabot> Source not found. You speak an infinite deal of nothing
12:33:15 <aCube> @src StateT mplus
12:33:15 <lambdabot> Source not found. Maybe you made a typo?
12:35:44 <hpaste> arkeet pasted “Attoparsec does not like me.” at http://hpaste.org/85932
12:35:57 <arkeet> I mean Fail, not Fali. oops
12:36:21 <arkeet> I'm tired.
12:36:38 <arkeet> anyway, why does this fail?
12:37:37 <saml> failed reading satisfy
12:37:45 <hpaste> arkeet revised “Attoparsec does not like me.”: “Attoparsec does not like me.” at http://hpaste.org/85932
12:37:49 <Botje> if attoparsec is like parsec, your ( ... <|> ...) succeeds if it parses either of those things once.
12:38:03 <arkeet> I'm told attoparsec always backtracks.
12:38:04 <arkeet> unlike parsce.
12:38:07 <dmwit> It's a lie.
12:38:20 <dmwit> It backtracks more often, but not always. =(
12:38:24 <arkeet> =(
12:38:27 <Botje> even if it always backtracks, that can't work.
12:38:39 <arkeet> well, how do I make it work?
12:38:41 <Botje> you want to parse p1 p2 p1 '!'
12:38:51 <Botje> you're currently (trying to) parse p1 '!'
12:38:52 <dmwit> Botje: eh?
12:38:56 <arkeet> what?
12:38:57 <dmwit> p2 '!' matches
12:39:10 <Botje> oh, grr, misread.
12:39:15 <Botje> I thought p2 was only isLetter.
12:39:18 <dmwit> It's just that attoparsec fails at the laws.
12:39:19 <Botje> *isDigit
12:39:24 <Botje> I call tuesday, sorry.
12:39:28 <arkeet> if I remove the Left alternative, it succeeds.
12:39:58 <__xc> lists:foldl(fun({_,Pid}, _) -> Pid ! {User,Tail} end, '_', Mylist)  <- is it the cleanest way, or a list comprehension looks better?
12:40:02 <__xc> oops
12:40:09 <dmwit> arkeet: I've been fighting this issue in some of my code, too. It sucks. Sorry about that.
12:40:10 <__xc> ^^wrong rool
12:40:20 <__xc> room*
12:40:31 <arkeet> __xc: wrong language ;-)
12:41:15 <arkeet> hmm
12:41:28 <arkeet> if I swap the order of the alternatives, it uh
12:41:39 <arkeet> argh, it works, but it always returns Right.
12:42:17 <arkeet> maybe it's time to give up and use trifecta. ;D
12:42:46 <monochrom> <|> is not commutative. both parsec and attoparsec
12:43:13 <dmwit> It also doesn't distribute over (>>), and that's the real annoyance.
12:43:14 <arkeet> I know.
12:43:22 <arkeet> oh?
12:43:35 <monochrom> it is also unfair. in x<|>y, if x makes some progress, y will be forgotten, even if x has a problem after that some progress
12:43:50 <arkeet> I thought that's what backtracking was supposed to handle.
12:44:06 <int-e> monochrom: right, that's the problem we're seeing
12:44:31 <monochrom> yes, but parsec doesn't backtrack unless you ask for it by "try", and I am not sure about attoparsec but it seems your experiment says the same.
12:45:07 <arkeet> in attoparsec, try = id, and the doc says "Attoparsec parsers always backtrack on failure."
12:45:08 <hpaste> paullik pasted “map” at http://hpaste.org/85934
12:45:37 <arkeet> this seems like false advertising. :(
12:46:02 <paullik> Hi. I'm following YAHT and I get that error when I use map and Char.toUpper:  http://hpaste.org/85934  please note that these are my first lines in haskell
12:46:23 <dmwit> arkeet: It is false advertising, yes.
12:47:08 <monochrom> yikes, that's bad
12:47:18 <geekosaur> paullik, yaht might be a bit out of date there. the module is Data.Char
12:47:34 <typoclass> paullik: hello. since YAHT was written, things have changed a little. "Char" has moved to "Data.Char"
12:47:37 <arkeet> yaht is quite outdated.
12:47:47 <paullik> oh man
12:47:49 <arkeet> uh
12:47:51 <arkeet> @where yaht
12:47:51 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
12:47:51 <lambdabot> yaht/yaht.p(df|s)>
12:48:01 <arkeet> I think it's mostly good, except for stuff like that.
12:48:33 <paullik> I wanted a tutorial for beginners with functional programming and haskell but not beginner with programming in general
12:48:39 <arkeet> @where lyah
12:48:40 <lambdabot> http://www.learnyouahaskell.com/
12:48:40 <hpaste> typoclass annotated “map” with “map (annotation)” at http://hpaste.org/85934#a85935
12:48:45 <arkeet> is a good one.
12:48:49 <paullik> that seemed right
12:49:11 <typoclass> paullik: i've fixed it. i didn't test, but i think it should work ^^
12:49:28 <dmwit> ?where tutorials
12:49:28 <lambdabot> http://haskell.org/haskellwiki/Tutorials
12:49:29 <monochrom> it is already to like YAHT. just ask us for errata :)
12:49:30 <typoclass> (last words of the missile guidance programmer ...)
12:49:38 <monochrom> yikes, typo
12:49:44 <monochrom> it is alright to like YAHT. just ask us for errata :)
12:50:26 <Eduard_Munteanu> I sometimes do that too, as if my internal spellchecker goes mad.
12:50:31 <typoclass> paullik: and yes, i agree with arkeet's recommendation of lyah
12:51:20 <paullik> typoclass, thanks, it works, unfortunately I havend read yet about import, but an analoogy from python right now should do the job
12:52:35 <paullik> arkeet, typoclass, ok, then I'll try that one too
12:52:52 <supki> paullik: import M  is like  from M import *
12:53:20 <typoclass> paullik: yes, 'import' is quite straightforward. you use 'import Some.Module' to bring all the functions and types into scope that are defined in Some.Module
12:53:28 <paullik> it makes sense looking at typoclass' code
12:55:29 <typoclass> paullik: for starters the only things to know are 1) the module Prelude is automatically imported and contains e.g. 'map' and 'print' 2) if you're looking for something, the hoogle web site can help, and failing that, this channel here :-)
12:55:45 <henk> I’m trying to install lambdabot on debian stable, but get a few errors: http://pastie.org/7610962 (how) can I fix them?
12:56:10 <arkeet> henk: you have an ancient version of ghc.
12:56:37 <arkeet> it seems.
12:56:56 <paullik> typoclass, I tried to search on hoogle before I asked but what I found didn't make a lot of sense (toUpper :: Char -> Char) so I asked here, but I'll keep that in minde, thank you
12:57:03 <paullik> s/minde/mind/
12:57:27 <arkeet> that indicates the type of toUpper.
12:57:39 <typoclass> paullik: ah i see. yeah, that's the type signature of the function. it indicates that toUpper is a function from Char to Char. it takes a Char and gives a Char
12:57:46 <arkeet> but below that, you'll see that it is contained in the package 'base', module 'Data.Char'
12:57:52 <henk> arkeet: Yeah, well, I said "Debian stable" :-p
12:57:58 <arkeet> henk: :P
12:59:32 <carlosgaldino> hey guys, can someone tell me how this would be written in haskell? https://gist.github.com/carlosgaldino/884dcc9c1eb7d450fc54 of course the result would be 9, not 12
12:59:48 <dmwit> henk: Building lambdabot is an arcane and finicky process. If you're not a Haskell expert... you might want to try a different first project.
13:00:12 <typoclass> henk: lambdabot is available privately, via "/query lambdabot"
13:00:20 <dmwit> I recently built lambdabot with only about 50 modifications to the source on GHC 7.4. I suspect any earlier version is going to be near impossible.
13:00:47 <Eduard_Munteanu> carlosgaldino: not sure, what happens to 'n' after foo returns?
13:00:58 <typoclass> henk: do you know about tryhaskell.org, and about ghci? if you have ghc installed, you also have ghci available
13:00:59 <Eduard_Munteanu> n = n + 1  seems bogus
13:01:05 <arkeet> it is, even in python.
13:01:11 <Eduard_Munteanu> Ah.
13:01:32 <arkeet> or wait.
13:01:34 <arkeet> ?????
13:01:43 <carlosgaldino> Eduard_Munteanu: python and ruby use the local scope of the method
13:01:54 <carlosgaldino> Eduard_Munteanu: so n + 1 will interfere when calling that lambda
13:01:54 <dmwit> > let foo n x = x * n; foo3 = foo 3 in foo3 3
13:01:56 <lambdabot>   9
13:02:06 <Eduard_Munteanu> Oooh.
13:02:08 <arkeet> well, first of all, 'n = n + 1' doesn't have an analogue in haskell.
13:02:23 * hackagebot concraft 0.7.0 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.7.0 (JakubWaszczuk)
13:02:25 <dmwit> > let foo n x = x * (n+1); foo3 = foo 3 in foo3 3
13:02:27 <lambdabot>   12
13:02:43 <dmwit> NEXT!
13:02:51 <arkeet> ok, I don't understand python anymore :(
13:03:11 <typoclass> > let foo n x = x * succ n; foo3 = foo 3 in foo3 3
13:03:12 <Eduard_Munteanu> It's ok. I never did. :)
13:03:13 <lambdabot>   12
13:03:29 <arkeet> I would have expected some closure to be created on line 2, and then line 3 wouldn't affect the closure.
13:03:29 <carlosgaldino> Eduard_Munteanu: arkeet something like this https://gist.github.com/carlosgaldino/2db1a27190dee4e0ea2a
13:03:52 <arkeet> I don't know clojure.
13:04:27 <Eduard_Munteanu> Seems closer to Haskell.
13:04:36 <dmwit> If you start by asking for mutability in Haskell, you're gonna have a bad time.
13:04:37 <Eduard_Munteanu> To the Haskell solution, I mean.
13:04:55 <arkeet> but from what I am seeing, it makes more sense.
13:05:02 <tdammers> python doesn't even understand itself
13:05:03 <carlosgaldino> arkeet: python and ruby use the local method scope, so the `n` inside the lambda refers to the same outside it, that's why the n + 1 thing affect the lambda
13:05:15 <Eduard_Munteanu> Not sure if he actually meant mutability or some scoping / shadowing tricks.
13:05:17 <arkeet> that makes me sad :(
13:05:43 <carlosgaldino> since it's been three years I wrote a little bit of haskell I came here to get a help in how to write the same example as the clojure one but in haskell
13:05:46 <tdammers> you know what's really sick? impure decorators
13:05:48 <carlosgaldino> just to show some colleagues
13:06:11 <dmwit> If the goal is to show off Haskell to colleagues, this example ain't it.
13:06:17 <carlosgaldino> incrementing the `n` in haskell would mean I'm creating a new `n` right?
13:06:19 <dmwit> If the goal is to write something useful, this example still probably ain't it.
13:06:29 <arkeet> if you write n = n+1 in haskell, you're making a recursive definition.
13:06:35 <arkeet> n = n+1 = (n+1)+1 = ...
13:06:41 <carlosgaldino> dmwit: not to show off haskell, just to show how other languages work with lambdas
13:06:48 <carlosgaldino> it's very silly, I know
13:07:13 <tdammers> an equivalent of n = n+1 inside a MonadState makes perfect sense
13:07:23 <tdammers> there's even a Lens operator for it IIRC
13:07:29 <arkeet> sure, but that's different.
13:07:55 <tdammers> it's semantically as close as you'll ever get
13:08:08 <arkeet> I'll just let n' = n + 1
13:08:14 <dmwit> I think what we're trying to say is that different languages have different idioms, and it doesn't always make sense to translate one language's idiom to another language.
13:08:34 <carlosgaldino> so it's impossible to redefine `n`?
13:08:40 <tdammers> or maybe sth like modifyIORef n (+1)
13:09:00 <arkeet> it's impossible to make the same variable refer to a different value.
13:09:09 <carlosgaldino> like I did in clojure? clojure had one `n` inside the lambda and the other `n`, the incremented one mean a completely different `n`
13:09:13 <typoclass> carlosgaldino: the thing is that in haskell, we consider it more clear if things aren't being redefined over time
13:09:51 <tdammers> best to think of variables as aliases in haskell I reckon
13:09:58 <carlosgaldino> typoclass: makes sense since it's a pure functional language, is that right?
13:10:05 <arkeet> variables are names bound to values.
13:10:29 <typoclass> carlosgaldino: yes exactly, it's pure. we find it easier to reason about code if stuff is defined once, and stays that way
13:11:21 <carlosgaldino> typoclass: got it. something like in erlang, when doing n = n + 1 it will complain that's not possible
13:11:26 <arkeet> you can't change the value a variable refers to. at best could create a new variable with the same name, shadowing the old one.
13:11:33 <eikke> is there any package which contains a crc32c implementation? (the one in 'digest' isnt the right one :) )
13:12:23 <typoclass> carlosgaldino: an obvious thing about haskell you could 'show off' is that things are partially applied implicitly. often, you don't need to bother defining functions that give back functions because that's how it is in haskell anyway. (see dmwit's code above)
13:12:56 <carlosgaldino> arkeet: oh wait. so I can have `n` but its value being `previous_n + 1`?
13:14:43 <paullik> this tutorial lyah.com is pretty funny
13:14:54 <arkeet> > (\n -> let f = (\x -> x*n) in (\n -> f n) (n+1)) 3
13:14:56 <lambdabot>   12
13:15:07 <arkeet> there's some shadowing there.
13:15:07 <henk> dmwit: oh, ok. Thanks.
13:15:10 <carlosgaldino> typoclass: I know. I'm studying the language slowly, but my goal is not to show off haskell, is just give some examples of different languages and how they treat lambda
13:15:18 <typoclass> carlosgaldino: you can (simply) make a new name ... "n = 42; m = n + 1". you can even do "n = 42; n = 37", which will shadow the earlier n, but it'll give you a compiler warning and is generally not what a haskeller would do :-)
13:15:29 <int-e> arkeet: oh I finally understand what attoparsec does in your example.
13:15:37 <arkeet> int-e: ?!
13:15:58 <arkeet> hopefully this means you understand how to solve it.
13:16:09 <carlosgaldino> typoclass: so I could do `n = n + 1` but ok, a haskeller wouldn't do this kind of thing, right?
13:16:44 <latro`a> no, you can't do n=n+1
13:16:51 <arkeet> > let { n = 3; f x = x*n } in (\n -> f n) n
13:16:54 <lambdabot>   9
13:16:59 <arkeet> > let { n = 3; f x = x*n } in (\n -> f n) (n+1)
13:17:01 <lambdabot>   12
13:17:15 <latro`a> ^there the contexts in which the values of n live are different
13:17:17 <arkeet> lexical scope is the only scope that makes sense to me.
13:17:53 <arkeet> yes, the n inside the lambda shadows the n outside.
13:18:15 <int-e> arkeet: (p <|> q)  commits to its choice once p succeeds. So the "full backtracking" claim is wrong.) However, you can turn (p <|> q) <* r into (p <* r) <|> (q <* r) in your example to make it work
13:18:47 <henk> typoclass: Yeah, I know about tryhaskell.org. I also started reading learnyouahaskell.com and realworldhaskell.org.
13:19:36 <arkeet> int-e: oh dear, that makes my real-world parser quite a bit uglier.
13:19:41 <int-e> arkeet: the difference to parsec being, of course, that <|> waits for all of p to succeed before making that commitment.
13:20:23 <arkeet> hm, maybe not. let's see
13:21:25 <arkeet> ok, I didn't have to turn my code completely inside out. thanks.
13:21:36 <carlosgaldino> ok guys, I got it. thanks for the help
13:22:46 <dmwit> arkeet: (This is what I meant earlier when I said (<|>) didn't distribute over (>>).)
13:22:58 <arkeet> right.
13:24:13 <arkeet> I originally had some blah <*> (p1 <|> p2) <* space <*> bunch of stuff, and I was afraid I'd have to duplicate the bunch of stuff.
13:24:25 <arkeet> but I guess only having to duplicate the space is acceptable.
13:24:54 <typoclass> carlosgaldino: here's a summary http://hpaste.org/85939
13:26:29 <typoclass> carlosgaldino: i forgot to put some linebreaks in there :-) i've edited it. you need to reload
13:28:37 <carlosgaldino> typoclass: thanks, appreciate
13:29:14 <danharaj> edwardk: Hey, I have a question about Kan extensions
13:29:26 <carlosgaldino> typoclass: I'm still considering learning more about haskell. it's been three years that I took an introductory course in college. forgot everything =(
13:31:33 <typoclass> carlosgaldino: do it! :-) it's a great language
13:32:35 <typoclass> carlosgaldino: . my approach was to work with different languages (python, perl, shell, etc.), but after i got to haskell, i've really lost interest. for the first time i got the feeling that this language is clearly superior, and i don't need those others anymore (excuse the pompousness) :-)
13:33:34 <carlosgaldino> typoclass: yeah, I remember being fascinated when I took the course. the paradigm as well. nowadays I'm reading the stuff about monads in lyah but just to learn the concepts which I was always curious to learn
13:33:38 <dmwit> ?where tutorials
13:33:38 <lambdabot> http://haskell.org/haskellwiki/Tutorials
13:33:53 <dmwit> I like the Gentle Intro, but LYAH and RWH seem more popular these days.
13:35:46 <carlosgaldino> the approach used by lyah is just fascinating, it makes very easy to understand
13:37:20 <arkeet> I can't remember what I used.
13:37:29 <typoclass> carlosgaldino: just as a heads-up, the "concept of monads" is not mysterious. just write some code involving IO for a while, and some code with Maybe, and the understanding will come
13:37:41 <arkeet> I'm sure I was first exposed to YAHT, but I also remember not making any sense of it at the time.
13:38:22 <carlosgaldino> typoclass: oh, I got the idea. lyah explained very well and I read some other stuff. there's a book called fp-oo. I think it was the best explanation
13:40:18 <carlosgaldino> typoclass: oh, and the type signature. love that
13:40:56 <carlosgaldino> especially after watching this: http://www.infoq.com/presentations/Type-Functional-Design. made me think more about it when writing ruby code, which is what I do at my job
13:42:00 <arkeet> int-e: dmwit: thanks again :)
13:42:17 <arkeet> I need to sleep.
13:46:44 <trescenzi> ok I have an error that I can't seem to wrap my mind around
13:47:11 <trescenzi> In a do block code, that is necessary and that the result of is being used, doesn't seem to be being run
13:49:30 <Cale> trescenzi: Which monad?
13:49:34 <trescenzi> IO
13:49:43 <trescenzi> there isn't output going on here though
13:49:54 <johnw> trescenzi: I think we'll need to see some code
13:49:57 <trescenzi> It's in a function inside the IO monad
13:50:14 <trescenzi> welll... I can point you to a git repo
13:50:19 <trescenzi> got i wish this was simpler
13:50:21 <Cale> Yeah, if an IO action runs, usually it all runs, unless some part of it takes forever, or an exception is thrown.
13:50:31 <trescenzi> the whole thing is huge
13:50:42 <johnw> extract the code that isn't running and use hpaste.org
13:51:53 <Cale> trescenzi: You won't get any result from an IO action which isn't executed. If you can observe the result, then the actions in the block actually executed.
13:52:35 <trescenzi> Cale and johnw: I'm going to try my best to extract what's going on in a simple manner. The code is out of a compiler I'm writing so it's kinda huge and complex
13:53:19 <hpaste> trescenzi pasted “cale johnw: thanks” at http://hpaste.org/85942
13:54:15 <trescenzi> So to give a bit more context what's going on is consumeToken ParenClose isn't being called if and only if it would error.
13:54:17 <monochrom> code reduction for problem reproduction is an important, daily needed skill (as long as you still make mistakes). it is also an intimidating phrase, what with all those "duction"s. or funny. :)
13:54:18 <Cale> trescenzi: okay, so one thing you should be aware of is that 'remaining' won't print its trace until *it* is evaluated
13:54:37 <Cale> trescenzi: and let doesn't in general cause any evaluation to occur
13:54:47 <Cale> (it just makes definitions)
13:55:02 <paullik> good night
13:55:13 <trescenzi> Cale: right but it all gets run, because it all gets printed out in main at some point.
13:56:00 <johnw> is the do block assigned to PrintOp missing a return?   Otherwise, that looks like the (e,) monad
13:56:34 <trescenzi> johnw: yea this is me not really knowing what's going on...
13:56:52 <trescenzi> the result of PrintOp is shown in main
13:57:09 <Cale> In fact, why is that do even there?
13:57:19 <Cale> let remaining = ...
13:57:25 <Cale>     (follow, experTree) = ...
13:57:30 <Cale>     consumed = ...
13:57:36 <Cale>  in (consumed, ...)
13:57:46 <trescenzi> Cale: hmmmmmmmmm
13:57:50 <Cale> I believe is what you intended
13:57:56 <trescenzi> yea i think it is
13:58:21 <trescenzi> the thing that bothers me, and this might jsut be me coming in form another language, is that that's left recursive
13:59:00 <trescenzi> nvm
13:59:15 <trescenzi> You're right Cale that is exactly what I intend and it's exactly right
13:59:34 <Cale> do is for gluing together actions into larger ones
14:00:00 <trescenzi> Thank you. My issue was that I had never seen a let being used to bind to more than one variable in not in a do block
14:00:04 <trescenzi> so I assumed you couldn't
14:00:56 <Cale> By the way, you may want to find out about parser combinator libraries like parsec at some point.
14:01:32 <trescenzi> Cale: Believe me I wish we were allowed to use that sort of thing. It has to be all from scratch. It's for a class
14:02:03 <Cale> Or of course, you could implement your own small monadic parser library :)
14:02:06 <trescenzi> the rest of the class is doing it in JavaScript I decided I'd attempt to better my Haskell skills and do it in haskell
14:02:28 <Cale> Wow, compilers in javascript
14:02:51 <trescenzi> Cale: oh god as you can see by that code I'm not experienced enough in haskell to write a moonad
14:03:10 <trescenzi> and yea javascript compilers sound like hell
14:05:35 <fxr>  there a specific channel for distributed-haskell?
14:05:50 <Cale> I'm pretty sure the point at which I really understood monads was when I first understood monadic parsing.
14:06:02 <Cale> (at least, in the context of programming)
14:06:17 <Cale> fxr: good question
14:07:04 <fxr> yeah with a typo
14:07:10 <trescenzi> Cale: yea I attempted to get it but being that this is a class I didn't have time to struggle with the basics of haskell and comprehending a monadic parser at the same time
14:07:13 <Cale> fxr: I don't see one in the channel list, at least
14:07:42 <trescenzi> Cale: We're just doing it all as a recursive descent parser. Stupidly simple to understand and kinda cool with haskell.
14:07:46 <monochrom> if you can get IO to work, that is good enough for now
14:08:40 <monochrom> recursive descent parsing can be done several ways, and one way is monad, and you can do it without even knowing it is monad
14:08:41 <Cale> trescenzi: right, if you want, when you have some time ask me about writing a simple monadic parser and I'll go over it with you.
14:08:45 <fxr> I read an old "remote" presentation and it says "you cannot run Process monad in forkIO".
14:09:00 <sethroot> is there any good resource that explains how Monad is 'more powerful' than Applicative? I keep reading this but can't grasp the fundamental difference.
14:09:10 <trescenzi> Cale: I'll totally take you up on that at some point thanks
14:09:26 <fxr> I wonder if this limitation still exists.
14:09:37 <Cale> sethroot: Given a Monad instance, you can construct an Applicative instance
14:09:46 <sethroot> I have heard that it is because Monad's structure is more flexible or dynamic than Applicative, is that true?
14:09:47 <Cale> sethroot: by taking pure = return and (<*>) = ap
14:10:00 <monochrom> sethroot: I read Wadler's http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms
14:10:48 <Cale> sethroot: But given only an Applicative instance, it is impossible to construct a Monad instance, because join :: (Monad m) => m (m a) -> m a decreases the number of occurrences of m in the type, and none of Applicative's primitives do that.
14:10:58 <quchen> Cale: Is there something basic about monadic parsers RWH doesn't cover?
14:11:21 <Cale> (or are polymorphic in such a way that would allow for the number of occurrences of it to decrease)
14:11:40 <sethroot> Very interesting thank you
14:11:44 <fxr> hmm forget about it, stupid question. there is forkProcess in Control.Distributed.Process.Node
14:14:45 <Cale> fxr: It's still an interesting question whether it's safe to forkProcess from inside a Process computation (using liftIO)
14:14:57 <Cale> But I haven't heard anything about that being dangerous.
14:15:22 <eikke> GHC keeps amazing me... I wrote the CRC32 I need using a fold over a bytestring and a step function, now checked the asm output (-O3 -fllvm), and it's about the tightest loop I'd get from a C compiler writing more code
14:15:46 <danharaj> GHC is good at loops over type like bytestring.
14:16:05 <Cale> -O3 doesn't exist btw
14:16:07 <lennart__> the only think that is dangerous is (lifted) forkIO inside the Process Monad, afaik
14:16:16 <eikke> Cale: oh :) didnt know that
14:16:28 <eikke> guess I used gcc a bit too much in the past
14:16:37 <Cale> (but at least GHC clips the number into range now rather than simply ignoring you like it used to)
14:16:38 <lennart__> why would you forkProcess inside the Process computation, when you can spawn?
14:17:01 <fxr> hmm do you mean Process can't do IO ?
14:17:11 <lennart__> it sure can
14:17:28 <Cale> fxr: It's an instance of MonadIO which means that you can apply liftIO to turn IO actions into Process actions.
14:18:16 <fxr> It can do IO but can't do it concurrently
14:18:46 <Cale> lennart__: Well, I'm not sure why you would, but it would be good for it to not completely blow up if you did :)
14:18:56 <fxr> since Process is also concurrent there's no need for a concurrent IO.
14:19:09 <lennart__> Cale: yeah.. i have not tested that
14:20:46 <lennart__> you certainly can use multiple concurrent-haskell threads inside one process, according to the '11 paper
14:21:04 <ludamad> how would I rewrite eg do { a <- someIO ; someOtherIo a b } as a one-liner ?
14:21:09 <Cale> actually, I'm pretty sure you won't be able to get a closure of a process computation which does that.
14:21:12 <fxr> one can use spawn instead of fork.
14:21:28 <ludamad> I tried someOtherIO =<< someIO $ b but that isnt quite it
14:21:29 <Cale> Because you'll need to have a LocalNode, and those aren't Serializable.
14:21:47 <eikke> ludamad: somIO >>= flip somOtherIo b ?
14:21:57 <Cale> someIO >>= \a -> someOtherIo a b
14:22:04 <ludamad> ah
14:22:14 <ludamad> maybe I dont want it as a one-liner, then
14:22:15 <ludamad> thanks
14:22:24 <monochrom> I would write do { a <- someIO ; someOtherIo a b }
14:22:31 <monochrom> I am serious.
14:22:48 <ludamad> monochrom: true, that is a one-liner :-)
14:23:19 <Cale> Yeah, I would too, but I think it's good to understand the way things translate :)
14:23:25 <lennart__> but you might run into problems if you access certain constructs (like Channels) from the forked thread
14:25:00 <lennart__> forkIO'ing inside Process is not dangerous in and of itself
14:25:20 <lennart__> (to correct/make clearer what i said earlier)
14:26:18 <fxr> thank you Cale and lennart__
14:26:55 <trescenzi> Cale: how can I force a let binding to be evaluated? I kinda understand how bang patterns work but I don't think you can apply them to a let binding can you?
14:27:08 <johnw> let !a = foo
14:27:10 <geekosaur> sure
14:27:19 <trescenzi> ok!
14:27:24 <danharaj> That is only weak head normal form.
14:27:48 <Cale> trescenzi: you can, though I think it's evil :)
14:27:58 <trescenzi> so do let bindings actually get unfolded into paramater lists?
14:28:23 <Cale> (I've never been happy with how they complicated the translation of bang patterns to make that work)
14:28:45 <Cale> (basically, it turns let into case)
14:28:58 <trescenzi> ohhhhh ok
14:28:59 <danharaj> Cale: For a second I was puzzled at how bang patterns would work in let.
14:29:31 <trescenzi> yea I was asking because it didn't seem like you could based on how they work but if that happens that that makes sense
14:29:47 <monochrom> not so quickly. case-of does not have to force anything, you know. I'm referring to "case your_expression of variable_here ->"
14:29:55 <Cale> trescenzi: You can think of let bindings as being unfolded into parameter lists if you're willing to admit higher rank polymorphism, I think.
14:30:02 <fxr> what about let a = Control.DeepSeq.force foo
14:30:31 <Cale> trescenzi: But it's worth noting that you can define polymorphic things inside a let and use them at many (perhaps even infinitely many) types in the expression that follows.
14:30:57 <danharaj> Cale: In GHC you have to specify a type signature for let bindings that are used polymorphically.
14:31:00 <danharaj> Unfortunately.
14:31:10 <Cale> danharaj: Yeah, now you do
14:31:11 <monochrom> how about this? "let" sets up an alias. there is no need to make it more complicated
14:31:12 <trescenzi> Cale: I don't even want to know how they do that behind the scenes
14:31:20 <danharaj> Cale: Noncompliance is best compliance, am I right?
14:31:22 <trescenzi> it sounds terrifying
14:31:32 <Cale> trescenzi: It's really not so bad. :)
14:31:42 <trescenzi> Cale: that fixed things
14:32:00 <trescenzi> given what you saw do you think it's a bad idea to force strictness on all of my bindings?
14:32:11 <trescenzi> or just the ones where I know things tend to go wrong
14:32:41 <lavorno> my insightful friends : what's the easiest (then best) way to generate haskell source code in haskell ?
14:32:42 <Cale> fxr: That will define a to be something which when evaluated will fully evaluate the data structure foo.
14:32:48 <lavorno> i am looking at generating source code, the input of a function should be some data structure (data IN_DS ) and the output a file containing a data structure (data OUT_DS) and some text source code (app.hs) to convert the structure to/from the defined datatype (OUT_DS). the code can involve regular haskell, libraries, etc.. what's the best way to tackle this ?
14:33:22 <Cale> lavorno: haskell-source-exts is the usual library for generating Haskell syntax
14:33:41 <lavorno> cale: great, tx will take a look
14:33:46 <danharaj> If the problem is simple you could probably also use template haskell and have GHC emit the splices.
14:34:00 <lavorno> danharaj: i looked at template haskel  but didn't look that intuitive
14:34:02 <Cale> http://hackage.haskell.org/package/haskell-src-exts-1.13.5
14:34:08 <Cale> sorry, it's "src"
14:34:22 <lavorno> cale: np, will find it :)
14:34:24 <lavorno> tx
14:34:39 <lavorno> i looked at taemplate haskell but it looks kind of too low level
14:35:01 <lavorno> i think is great for low level stuff but i wander how well it works with large structures ?
14:35:29 <Cale> lavorno: Well, template haskell will work just fine at compile time for generating code, but it's somewhat difficult to extract the generated code directly.
14:35:31 <lavorno> (i mean large structures with many data type fields and potentially involved relationships)
14:35:44 <danharaj> yes, you have to use --ddump-splices and then capture stderr.
14:35:45 <lavorno> cale: makes sense
14:36:15 <lavorno> danhraraj: sounds good - that's after i actually make sense of template haskell :)
14:36:47 <lavorno> i was concerned i've missed something but templ didn't look like the proper tool for the job
14:36:55 <lavorno> will take a look at src-exts
14:37:08 <Cale> Basically, if you're writing the stuff just to dump the splices, TH might not be the way to go unless you have a specific reason to use it.
14:37:32 * hackagebot algebraic-classes 0 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0 (SjoerdVisscher)
14:37:53 <lavorno> cale: is there some "beginner friendly" source code somewhere that is using src-exts  ?
14:37:56 <Cale> Yeah, that's likely the right thing if you want to write a preprocessor of some sort which emits a proper Haskell source file
14:38:01 <Cale> hmm
14:38:55 <Cale> Well, in any case, the place to start is to look through the data structures defined here: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html
14:39:15 <Cale> They're somewhat complicated because Haskell syntax isn't terribly simple.
14:40:50 <Cale> (Especially look at the list of constructors for Decl, and then figure out how to get hold of the parameters to those to construct the declarations you're interested in generating.)
14:41:52 <lavorno> cale: yes, they look lke what i need, just wanted to know if there is some source code known as being well written and using that.. that can help make sense of things much faster
14:42:02 <Cale> You can use  noLoc :: SrcLoc  to fill those parameters when generating code (those fields are only interesting when it parses for you)
14:42:25 <lavorno> cale: i don't want to parse haskell code
14:42:32 <Cale> Right
14:42:32 <lavorno> the code is already in an ast
14:42:44 <lavorno> i mean the input data (not the code)
14:43:02 <Cale> But you'll still have lots of SrcLoc parameters to all the data constructors to fill in
14:43:12 <Cale> (but they don't matter)
14:43:32 <lavorno> if u say so.. :)
14:43:48 <lavorno> (it's over my head at the moment, need to look over the lib)
14:43:58 <Cale> (If you look at the list of constructors to Decl, you'll see what I mean)
14:44:09 <Cale> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html#t:Decl
14:45:33 <Cale> You'll see that the first parameter to basically everything is an annoying SrcLoc that you don't care about, but you can fill that with anything if you're generating code, and the library provides a noLoc for doing that.
14:45:55 <lavorno> got u
14:46:10 <lavorno> yeah, was wandering what u meant - as i don't have a srcloc
14:48:04 <Cale> Anyway, once you build your Module value, all you have to do is apply  prettyPrint :: (Pretty a) => a -> String  to it and you'll get neatly prettyprinted Haskell source code.
14:48:41 <napping> Are there any HTTP libraries which let you supply the socket, or will pick a port for themselves and tell you what it was?
14:48:44 <lavorno> cale: awesome.. that's what i was looking for. is there any higher level lib on top of this ?
14:48:48 <napping> I just noticed warp
14:50:03 <Cale> lavorno: Not that I'm aware of -- this is usually not too far from the level of abstraction you'll usually be working at anyway, but I find it's often handy to define a bunch of simple things -- like infix operators for App and TyApp.
14:50:57 <lavorno> cale: makes sense.. i was hoping there is something avail before i start reinventing the wheel
14:51:06 <lavorno> thanks all
15:01:48 <eikke> hmh. I figured since I kind-of understand conduit I could be a smartass and use Pipes for this new project. Guess I should reconsider
15:03:50 <threedaymonk> I'm working through an exercise from a meetup last week. First part is to write a variadic cat function. I've done that: https://gist.github.com/threedaymonk/5398637
15:04:23 <threedaymonk> The second part is to extend it to handle either String or Integer, and to sum integers as they are, and strings as their length.
15:05:44 <threedaymonk> I'm stuck, so I've gone back to try to do something simple: change cat to sum. But changing String to Integer, "" to 0, and (++) to (+) isn't working as I expected: No instance for (CountType (a0 -> Integer))
15:05:57 <threedaymonk> I'm obviously missing something in my understanding here, but what?
15:06:37 <c_wraith> threedaymonk: that error message suggests you aren't providing enough arguments for a function somewhere
15:07:37 <merijn> threedaymonk: Do you have a paste of your attempt too?
15:07:44 <threedaymonk> c_wraith: sure, one sec
15:10:04 <threedaymonk> c_wraith: https://gist.github.com/threedaymonk/ef44d5df1783cd4ad223
15:10:21 <threedaymonk> it's basically a search-and-replace job on the string version
15:10:44 <merijn> threedaymonk: Just for fun, what happens if you write "(0 :: Integer)" instead of 0?
15:11:26 <threedaymonk> merijn: same error
15:11:27 <c_wraith> threedaymonk: oh.  The problem is that you're applying treating a value as a function when it isn't
15:11:52 <merijn> oh, duh
15:12:01 <threedaymonk> c_wraith: I almost understood what you said there :-)
15:12:27 <geekosaur> "treating" shouldn't be there
15:12:45 <geekosaur> (well, either it or "applying" but I think the latter is more precise)
15:13:14 <threedaymonk> it's wrong in the string case too, then? So why is it working there?
15:13:58 <c_wraith> Hmm.  That's actually kind of subtle. It's inferring the function type incorrectly, and I'm not sure why.
15:15:00 <c_wraith> It's somehow not unifying a0 with Integer
15:15:10 <c_wraith> And so it's looking for an instance that doesn't exist
15:15:33 <merijn> threedaymonk: What if you write "countNext c = c" instead of countNext = id?
15:15:55 <threedaymonk> merijn: oh, I had that before. No change
15:16:00 <merijn> Although, that shouldn't matter I think
15:16:02 <merijn> Ok, good :p
15:17:15 <hpaste> allenj12 pasted “Help with randomization” at http://hpaste.org/85947
15:17:27 <allenj12> can anyone help me tackle that?
15:17:49 <c_wraith> threedaymonk: are you willing to experiment with more ridiculous things?  Like changing the instance declaration for functions to: instance (a ~ Integer, CountType c) => CountType (a -> c) where ...
15:18:40 <threedaymonk> c_wraith: yeah, I'm happy to play around. I'd like to understand this. I'll have to go to bed in an hour or so, though!
15:18:48 <merijn> allenj12: You can call any boolean returning function as a guard, so why not myCheck atom1 atom2 and have the iff, etc. in there?
15:19:06 <threedaymonk> c_wraith: oh, what's the meaning of that ~ in a ~ Integer ?
15:19:06 <cmccann> threedaymonk: "count (1 :: Integer) :: Integer"
15:19:23 <c_wraith> cmccann: I was terrified that might work. :)
15:19:38 <merijn> "myCheck a1 a2 = if a1 == "$" || a2 == "$" then a1 /= a2 else True"
15:19:55 <threedaymonk> cmccann: oh, that *does* work
15:20:06 <threedaymonk> and count (1 :: Integer) (2 :: Integer) (3 :: Integer) :: Integer etc.
15:20:08 <merijn> threedaymonk: I asked you to do that at the start
15:20:18 <c_wraith> threedaymonk: In a type constraint, ~ is the "types are equal" constraint.
15:20:19 <merijn> I *knew* that was it
15:20:25 <threedaymonk> merijn: I changed it in the definition of count
15:20:37 <merijn> To what?
15:20:55 <allenj12> merijn: ahh ok so i will try that
15:20:58 <merijn> Did you mean the a ~ Integer worked or the "count (1 :: Integer) :: Integer"?
15:21:21 <threedaymonk> merijn: you said change 0 to (0 :: Integer). I did that in the defn of count
15:21:38 <merijn> oh, bollocks
15:21:39 <threedaymonk> but it only works when every number is explicitly marked
15:21:48 <merijn> Yeah, nevermind, now I get it
15:22:01 <tapas> hi, i'm pretty new to haskell and i have a question about syntax :D http://pastebin.com/RpkfJ3r8 i'm interested first in the definition of main
15:22:09 <mauke> The paste RpkfJ3r8 has been copied to http://hpaste.org/85948
15:22:10 <c_wraith> I'm pretty sure my suggestion would work too..  But that was the real problem
15:22:11 <hpaste> “C. McCann” pasted “another CountType fix” at http://hpaste.org/85949
15:22:17 <threedaymonk> so, thanks for that help!
15:22:33 <cmccann> threedaymonk: see the hpaste
15:22:37 <c_wraith> Oh.  Yeah, that one's much nicer.
15:22:38 <threedaymonk> now, how do I make it suck less? I mean, I don't really want to have to type :: Integer everywhere
15:22:40 <merijn> threedaymonk: Yes, because in "count 1" "1 :: Num a => a", and there's no instance for (CountType c, Num a) => a -> c, only for Integer -> c
15:22:41 <cmccann> a.k.a. "accept anything you can turn into an Integer"
15:23:12 <tapas> i read through quite a bit of 'learn you a haskell...', but i must have missed what curly braces with things separated by commas mean
15:23:21 <merijn> tapas: It's record syntax
15:23:40 <tapas> merijn: ah ok.. looking that up
15:23:46 <cmccann> yes, the problem here of course is that literals are polymorphic
15:23:47 <merijn> tapas: "data MyRecord = MyRecord { field1 :: Integer, field2 :: String"
15:23:53 <threedaymonk> bugger. That's what I was trying to remember and couldn't, so I just though, ah, Integer will work for now. It didn't.
15:23:54 <merijn> tapas: Add a missing } there
15:24:04 <monochrom> tapas: curry brackets have several unrelated uses. this one is specifying record contents.
15:24:33 <merijn> tapas: "foo { field1 = 1 }" basically means, return a copy of foo with field1 set to 1
15:24:38 <cmccann> threedaymonk: my hpaste is probably the simplest fix that doesn't change anything significant
15:25:00 <tapas> merijn: oh ok..
15:25:20 <merijn> (assuming foo is a value of type MyRecord)
15:25:42 <tapas> merijn: so that value then becomes the second argument to the function xmonad?
15:25:54 <tapas> oops
15:26:07 <tapas> merijn: the first argument (and only)
15:26:15 <merijn> tapas: Yes
15:27:18 <threedaymonk> cmccann: yep, that fixes it nicely. Thank you!
15:27:26 <tapas> monochrom: yeah, i know a little about desugared code.. but i didn't come across this in my research ;D
15:27:36 <cmccann> threedaymonk: do you understand why it didn't work before?
15:27:48 <cmccann> GHC will only commit to an instance if it's a definite match
15:28:11 <tapas> and is <+> special syntax? or is it just some operator?
15:28:37 <monochrom> <+> is an operator defined by one of the modules you import
15:28:45 <cmccann> in other situations an ambiguous Num literal will default to Integer but I guess that doesn't happen until after instance resolution
15:28:56 <Mortchek> > let a <+> b = 2 * a + 2 * b in 10 <+> 2
15:28:57 <lambdabot>   24
15:29:09 <threedaymonk> cmccann: I think I understand enough to see why it didn't work.
15:29:15 <tapas> monochrom: ok
15:30:04 <typoclass> tapas: just some operator that someone defined. if a function name consists of letters, it's prefix (example: foo 1 2). if a function name consists of symbols, it's infix (example: 1 <&&> 2)
15:30:05 <cmccann> threedaymonk: imagine importing that module from somewhere else that defined an instance for "Int -> c"
15:30:11 <tapas> ok, on to the second "thing" i don't yet quite grok..
15:30:30 <cmccann> threedaymonk: see how the polymorphic literal would be objectively ambiguous in that case?
15:30:55 <tapas> myManageHook is defined as the function composition of composeAll and concat applied to a list of lists (which are defined using list coprehensions)?
15:31:34 <merijn> tapas: btw, I found a nice cheat sheet online a few months back, might be handy for you: http://cheatsheet.codeslower.com/CheatSheet.pdf
15:31:41 <threedaymonk> cmcann: ah, yes, that makes sense
15:31:43 <cmccann> threedaymonk: instance selection is cautious enough, and won't commit to an instance if some other possible instance could apply as well
15:31:53 <cmccann> even if that other instance doesn't exist in scope right then
15:31:58 <threedaymonk> because 0 could be Int, or Integer, or ...
15:32:24 <monochrom> tapas: that is right. it is also the same as "composeAll (concat that_list)"
15:32:36 <cmccann> i.e., instance selection is based on the open world assumption and considers instances that could exist, not just the ones that are in scope at the time
15:32:40 <tapas> sadly my xmonad setup is a bit wonky, so the pdf opened, but i can't get the window to the foreground ;D
15:32:56 <monochrom> ah, the chicken-and-egg problem!
15:33:01 <tapas> :D
15:33:09 <typoclass> tapas: have you tried moving it to another workspace?
15:33:16 <threedaymonk> now I've got a bunch of Integers left in function signatures, e.g. countNext :: Integer -> t. Could that be a more general Integral too?
15:33:21 <tapas> typoclass: oh right. it does seem to get focus.. good point
15:33:35 <typoclass> tapas: (you may have a bunch of windows floating. those are always in front of tiled windows)
15:33:37 <tapas> typoclass: good one :D
15:34:06 <allenj12> hey merijn is this what you were talking about?
15:34:06 <cmccann> threedaymonk: you could probably make the whole thing much more generic if you want
15:34:09 <tapas> i shouldn't have just copied and pasted the example config for the kde4config.
15:34:11 <hpaste> allenj12 pasted “Help with randomization again” at http://hpaste.org/85952
15:34:40 <threedaymonk> cmccann: that's what I was hoping (and what I'll need to be able to do for the next part)
15:34:41 <cmccann> threedaymonk: in some ways that would actually make it work more simply; if nothing requires Integer exactly it will accept the polymorphic type up front, then apply the other constraints later
15:34:49 <merijn> allenj12: Well, I would just move the entire if statement into checkAtoms, but otherwise yes
15:35:05 <merijn> allenj12: Wait, you're missing an else there
15:35:23 <tapas> ok, last question. in the list comprehensions i see =? and -->. are thee imported from some modules, too? or standard haskell stuff?
15:35:30 <allenj12> merijn: is an else needed?
15:35:36 <merijn> tapas: I don't know them, so imported :)
15:36:04 <tapas> merijn: hah
15:36:04 <merijn> allenj12: Yes, you must always have an else with if/then/else in haskell, you could just do "else True" or "else False", though
15:36:54 <merijn> tapas: Load the code in ghci and you can run ":i (=?)" to see where they're from and use ":t" to figure out their types
15:36:54 <GOMADWarrior> can I make AI with haskell?
15:36:54 <allenj12> merijn: ahhh k thats why i had problems with that before
15:37:17 <cmccann> threedaymonk: in the general case, c_wraith's suggestion with ~ is a common solution to the problem of wanting a specific instance to be used for more polymorphic types
15:37:31 <cmccann> it's a bit of a hack, but works
15:37:41 <typoclass> tapas: yes they are imported, the stuff is about xmonad's manageHook. it's a hook that runs when a new window appears and xmonad first shows it. you use it for things like "when a firefox window appears, i always want to move it to workspace #3"
15:37:42 <merijn> allenj12: Think of it like this, what's the type of "if False then 1"?
15:37:47 <c_wraith> It's really a lot of a hack..  But yeah, it works.
15:38:13 <tapas> typoclass: yeah, i was aware about the intent, but my haskell fu is weak
15:38:45 <threedaymonk> I tried changing the Integers to Integrals. Change one, and it can't deduce  (a ~ Integer). Change both, and "Constraint is no smaller than the instance head". Is this a dead end?
15:39:25 <typoclass> tapas: the question is really if you want to learn how to *use* the manageHook, which isn't too hard and there's lots of examples, or if you want to learn how it's *implemented*. which i guess would only really help you if you want to replace this part of xmonad with something you wrote
15:39:26 <cmccann> c_wraith: it's a well-defined and well-behaved misuse of a long-standing limitation of instance selection
15:39:30 <merijn> threedaymonk: Well, "(a ~ Integer, Integral a)" amounts to saying "It works for any Integral a, as long as that a is an Integer" :p
15:39:48 <cmccann> it's a hack but the way this all works is no prize itself
15:40:01 <tapas> typoclass: i just wanted to get a handle on the example code, so i know what to look up where :D
15:40:10 <typoclass> tapas: ah i see :-) fine
15:40:12 <tapas> typoclass: i'll decide what to do with it later :D
15:40:26 <tapas> anyways, anyone from hackerspace bielefeld around here?
15:40:36 <merijn> tapas: Like I said, ":i" in ghci lets you know where it is defined and then you can look up that module in the xmonad docs :)
15:40:37 <typoclass> tapas: you know about hoogle and hayoo?
15:40:39 <typoclass> @where hoogle
15:40:39 <lambdabot> http://haskell.org/hoogle
15:40:42 <typoclass> @where hayoo
15:40:43 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:40:49 <merijn> I guess hoogle doesn't index xmonad, though
15:40:52 <typoclass> tapas: i'm pretty sure that doesn't exist
15:41:01 <merijn> And yahoo never returns what I want :<
15:41:02 <tapas> typoclass: :D
15:42:35 * hackagebot algebraic-classes 0.1 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.1 (SjoerdVisscher)
15:42:37 * hackagebot free-functors 0.3 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.3 (SjoerdVisscher)
15:44:15 <[swift]_> does anyone know: when you call back into haskell from c, does the haskell runtime spawn a new thread to handle that inward call?
15:45:00 <johnw> [swift]_: I don't see what that would be necessary
15:45:49 <[swift]_> johnw: i don't really either, but i wanted to be sure
15:46:36 <monochrom> I think yes
15:47:18 <[swift]_> so is it the case that most of the overhead of "safe" FFI calls is in the initial "Haskell -> C" call, and the inner "C -> Haskell" calls you may have are comparatively cheap?
15:47:24 <monochrom> see my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml , it is a "yes"
15:47:45 <monochrom> oh, that one I don't know
15:48:14 <[swift]_> monochrom: well if a thread has to be spawned for the inward calls they are likely fairly expensive..
15:48:25 <allenj12> merijn: Got it Thanks for your patience!
15:48:27 <[swift]_> (reading your link)
15:49:00 <monochrom> ok, fine print. in C -> Haskell, spawn a new Haskell thread, not an OS thread.
15:49:54 <[swift]_> ah ok, that is probably much cheaper
15:50:07 <monochrom> spawning a Haskell thread is cheap. but in C -> Haskell, a lot of other things are done, don't just look at spawning thread, look at re-entry into GHC's RTS
15:50:41 <monochrom> at this point, careful empirical measurement is better than theorizing, since we don't know what to theorize.
15:51:02 <[swift]_> yeah, that's reasonable
15:51:49 <[swift]_> i was thinking of trying to move some intelligence to the C side of some FFI bindings I'm working on to reduce calls back into haskell. basically i was trying to get a sense of whether this would be a microoptimization or something that could produce big gains
15:53:47 <hpaste> threedaymonk pasted “overlapping instances, but why?” at http://hpaste.org/85956
15:54:24 <threedaymonk> I'm puzzled as to why count 1 would match both instances, when they have different signatures
15:57:23 <geekosaur> the contexts do not play any part in instance selection
15:58:32 <geekosaur> so they do overlap. it should however select the more specific one when possible, so OverlappingInstances would allow the right thing to happen, I think
15:59:18 <threedaymonk> Ah, that makes sense: the code I saw that did this also used OverlappingInstances
16:00:16 <ocharles> any ideas for the best way to infinite run a program? I'm using the amqp library and am listening for events
16:00:24 <monochrom> 1 is not clearly non-String. pardon my double-negation. therefore, 1 may be the String in String->c or may be the a in a->c, it is still ambiguous
16:00:29 <ocharles> but I can't use 'getLine' as the examples suggestion, because daemontools doesn't provide any stdin
16:00:40 <ocharles> forever (return ()) seems awfully expensive
16:01:01 <ocharles> reading off an empty chan doesn't work because haskell is clever enough to work out that that is deadlocked
16:02:02 <geekosaur> hm, right, would need to force the type on that
16:02:16 <hpc> forever (threadDelay 1000000)
16:02:43 <Eduard_Munteanu> :t forever ?alone
16:02:44 <lambdabot> (?alone::m a, Monad m) => m b
16:03:16 <ocharles> hpc: i guess that would work
16:05:11 <jmcarthur> monochrom: do you happen to know if the ghc runtime okay with  Haskell -> C -> Haskell  such that when C calls back to Haskell it does so from a new thread that it created?
16:05:15 <jmcarthur> *is okay with
16:06:27 <jmcarthur> oh maybe your page explains this after all
16:06:34 <Eduard_Munteanu> I wonder if you can pass pointers to Haskell functions into C code or something like that.
16:06:42 <cmccann> monochrom has a page for explaining most things.
16:06:45 <jmcarthur> ah it does i think
16:06:52 * Eduard_Munteanu reads backlog
16:07:35 <parcs> Eduard_Munteanu: you can
16:07:47 <jmcarthur> cmccann: i'm thinking of ways around the main-mangling that SDL/Allegro/maybe-others do. the common solutions involve writing main functions in C, which is unfortunate
16:08:23 <jmcarthur> if my reading of that page is correct, GHC is fine with this
16:08:30 <jmcarthur> in which case... woohoo!
16:08:50 <cmccann> jmcarthur: that's what I always did
16:09:06 <cmccann> it really isn't too bad, just a few lines of C in a wrapper
16:09:18 <jmcarthur> yeah but if it could all be done in haskel that would be better :)
16:09:23 <cmccann> indeed
16:09:26 <jmcarthur> and i think it may be doable
16:09:35 <lkuper> Anyone have any idea why I'm getting this error even though test-framework-th is installed? http://hpaste.org/85958
16:09:59 <jmcarthur> at least, allegro provides a way to explicitly call the stuff it normally tries to wrap around your main
16:10:08 <jmcarthur> it takes a function pointer to your real main function as an argument
16:10:18 <cmccann> ah, nice
16:10:19 <jmcarthur> and calls it in a new thread that it creates
16:10:24 <cmccann> I don't recall SDL supporting that
16:10:29 <cmccann> though maybe it does
16:10:32 <jmcarthur> no i think SDL tries to do it silently
16:10:45 <cmccann> which leads to all kinds of excitement!
16:11:04 <jmcarthur> with allegro that magic is all in a different library which you don't have to link if you think you know better
16:11:27 <jmcarthur> which is awesome
16:12:09 <jmcarthur> Eduard_Munteanu: you can do that
16:12:58 <jmcarthur> Eduard_Munteanu: you just use the FFI to create a "convertor" function which takes a Haskell function of the appropriate type and gives you back a FunPtr
16:13:20 <cmccann> jmcarthur: hm, allegro is sounding better and better
16:13:30 <jmcarthur> cmccann: i keep thinking that too
16:13:32 <jbracker_> I would like to do something for GSoC: I have a first idea for a project here: https://gist.github.com/jbracker/6d4f6515fecb117166db Suggestions? Comments?
16:14:07 <jmcarthur> cmccann: it's also very explicit. most things that create state actually give you an object that represents it
16:14:12 <jmcarthur> which i like
16:14:26 <cmccann> jbracker_: supporting GADTs and type families? yes plz
16:14:42 <jbracker_> cmccann: I am missing that for ages
16:14:49 <jmcarthur> i did not even know that functionality was still missing!
16:14:52 <jmcarthur> wow
16:15:04 <cmccann> yeah basically
16:15:25 <cmccann> I can't speak to the scope or pragmatics of actually doing that project, but I'd love to see it happen
16:15:29 <jmcarthur> jbracker_: i wonder if one could "just" add pandoc support for haddock so you can use other markup languages (in some appropriate way) too
16:15:48 <jmcarthur> although markdown is probably all i would ever use
16:15:53 <jmcarthur> maybe latex support would be cool
16:15:54 <jbracker_> jmcarthur: But dependencies are an issue here
16:15:56 <cmccann> jmcarthur: pandoc as a dependency of haddock is a non-starter
16:16:03 <jmcarthur> true
16:16:06 <cmccann> for multiple reasons
16:16:09 <jmcarthur> very true
16:16:20 <cmccann> if there was some way to make it optional that'd be cool
16:16:57 <jmcarthur> well, it would be until you want it to work on hackage
16:17:01 <jbracker_> I think the need for thing more complicated then basic markdown is very low
16:17:37 <cmccann> yeah
16:17:41 <geekosaur> it's already been pointed out on one f the lists that markdown has a conflict with bird-style literate haskell
16:17:51 <cmccann> well, some weird markdown dialect
16:18:02 <cmccann> it's not like markdown implementations are consistent anyway
16:18:17 <jmcarthur> type family support is killer. that alone would make be super happy
16:18:20 <jbracker_> I would not put markdown on top level only inside a haddock comment as it is now for normal haddock
16:18:28 <cmccann> yessssssss type families
16:19:04 <cmccann> jbracker_: you should probably contact someone more familiar with haddock's internals to get their opinion
16:19:18 <cmccann> but I think it's clear there's user interest
16:19:27 <jbracker_> should I put this on reddit or whom should I send this?
16:21:13 <cmccann> I'm not actually sure what the process is, sorry...
16:22:32 <croikle> gwern does something with haskell gsoc, if he's around
16:22:44 <gwern> I just watch. and judge.
16:23:13 * gwern judges the intrinsic worth of all parties involved, rarely praising and often damning
16:23:33 <croikle> I remember that bit :)
16:24:03 <jbracker_> I guess I can be glad not to be damned yet ;)
16:24:14 <gwern> wasn't markdown haddock already discussed on -cafe extensively, with plenty of bikeshedding?
16:24:34 * geekosaur already referred to that
16:25:51 <cmccann> I'd take the "make haddock actually support useful stuff" even without markdown
16:26:09 <cmccann> it's kinda silly that it doesn't handle widely-used extensions still
16:27:41 * hackagebot algebraic-classes 0.2 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.2 (SjoerdVisscher)
16:31:28 <egha> Hey. Quick question: what does "let (num, gen') = randomR (1,100) in the middle of a do block desugar to?
16:32:08 <egha> @undo do gen <- get ; let (num,gen') = randomR (1,100) gen ; put gen' ; return num
16:32:08 <lambdabot>  Parse error at ";" (column 65)
16:32:20 <shachaf> @undo do gen <- get ; let { (num,gen') = randomR (1,100) gen } ; put gen' ; return num
16:32:20 <lambdabot> get >>= \ gen -> let { (num, gen') = randomR (1, 100) gen} in put gen' >> return num
16:32:52 <egha> shachaf: oh. thanks!
16:33:12 <parcs> what does 'Num Int => Show Char' mean?
16:33:19 <shachaf> parcs: Nothing.
16:33:35 * shachaf gets an odd sense of déjà vu.
16:34:08 <typoclass> egha: "let foo = bar" is of course different from "foo <- bar". just to be sure :-)
16:34:50 <egha> typoclass: right. that actually makes sense now. :)
16:37:30 <fryguybob> @type 1 :: Num Int => Int
16:37:31 <lambdabot> Int
16:37:33 <fryguybob> @type 1 :: Num () => Int
16:37:34 <lambdabot>     No instance for (Num ())
16:37:34 <lambdabot>       arising from an expression type signature
16:37:34 <lambdabot>     Possible fix: add an instance declaration for (Num ())
16:37:45 <typoclass> parcs: i don't know what extensions you'd have to enable to make ghc accept "Num Int =>". and it's unclear to me why you'd put a context on something (Show Char) that has no type variables. and i think the only place where Show Char could occur is as "instance Show Char where ..."
16:38:19 <typoclass> parcs: anyway, i have no clue at all
16:42:06 <geekosaur> why do you think it means anything more than the Haskell version of "colorless green ideas sleep furiously"?
16:44:37 <typoclass> geekosaur: yeah, i think it doesn't mean anything, and i gave some reasons why i came to this conclusion. (similar to stating "colorless green" is a contradiction, and therefore chomsky is a poopyhead.) :-)
16:49:41 <Nisstyre-laptop> typoclass: the point of "colourless green ideas sleep furiously" is supposed to be that you can construct a syntactically valid sentence that is semantically invalid
16:50:13 <Nisstyre-laptop> i.e. something that your brain accepts as a valid sentence but it's clearly "wrong"
16:52:57 <parcs> what should 'Num Int => Show Char' mean?
16:53:20 <typoclass> parcs: where are you quoting that from?
16:53:21 <geekosaur> shat should "colorless green ideas sleep furiously" mean?
16:53:26 <geekosaur> *what should
16:53:50 <Nisstyre-laptop> geekosaur: nothing
16:54:00 <fryguybob> @type 1 :: (Num Int => Show Char) => Int
16:54:01 <lambdabot> (Num Int => Show Char) -> Int
16:54:07 <Nisstyre-laptop> a better example is "the current king of France" (used by Russell as an example)
16:54:11 <fryguybob> > let x = 1 :: (Num Int => Show Char) => Int in x undefined
16:54:13 <lambdabot>   Couldn't match kind `*' against `Constraint'
16:54:17 <Nisstyre-laptop> it's a valid sentence, but it doesn't refer to anything
16:54:43 <Ontolog> suppose we have a data T = Int | String; how do we write functions that work on T if T is either an Int or a String?
16:55:02 <Rarrikins> Ontolog: You need constructors.
16:55:13 <geekosaur> Ontolog, if you have that you have a syntax error
16:55:30 <Ontolog> Rarrikins: data T = Int | String is a syntax error? GHC doesn't bark
16:55:31 <typoclass> parcs: it's a bit like asking "what should 'foldr foldl unwords unlines' mean"
16:55:37 <Ontolog> > data T = Int | String
16:55:37 <Rarrikins> Ontolog: data T = ZomgInt Int | ZomgString String (or something like that)
16:55:38 <lambdabot>   <hint>:1:1: parse error on input `data'
16:55:42 <Nisstyre-laptop> Ontolog: you give T two constructors (differently named)
16:55:49 <Nisstyre-laptop> and then you can pattern match on them
16:55:49 <geekosaur> hm, actually that would be correct, it's two nullary constructors
16:56:01 <Rarrikins> Ontolog: Yeah, but it doesn't store any data. It just stores Int and String as symbols.
16:56:06 <Nisstyre-laptop> geekosaur: if Int and String didn't already exist
16:56:07 <Rarrikins> Well, the data you want.
16:56:13 <Ontolog> ohhhhh
16:56:18 <Ontolog> i see
16:56:30 <Ontolog> thank you
16:56:35 <Rarrikins> No problem.
16:57:24 <Rarrikins> Then, for the function, you have two lines:  f (ZomgInt x) = (ZomgInt (x + 1))  and  f (ZomgString x) = (ZomgString (x ++ "!!!"))
16:57:31 <Rarrikins> Or something like that.
16:57:53 <amiller> the basic part is: enumerate n xs = liftM2 (:) xs (enumerate (n-1) xs)
16:58:11 <amiller> that gives me sort of all the search lists
16:58:35 <chrisdotcode> hello everyone :)
16:58:37 <amiller> but now i need an additional step which is to prune some of those results based on local information
16:58:41 <Rarrikins> Hello
16:59:08 <amiller> i want to remove the lists that have a sequential repeat like i should omit [1,1,2,3] and [3,2,2,3] because those have two adjacent repeats
16:59:17 <Rarrikins> amiller: map head . group
16:59:25 <amiller> do i need a different monad other than List to nail this in one line
16:59:25 <Rarrikins> Oh, remove them.
16:59:41 <Rarrikins> It's an [[a]]?
17:00:03 <hpaste> Ontolog pasted “like this” at http://hpaste.org/85960
17:00:19 <chrisdotcode> is there such thing as a subguard, that is, a guard within a guard?
17:00:20 <Ontolog> lol sorry amillernothing to do with your shits
17:00:37 <Ontolog> chrisdotcode: &&
17:00:40 <Rarrikins> chrisdotcode: Maybe && or something.
17:00:52 <Rarrikins> chrisdotcode: Also case or something
17:00:59 <Ontolog> ohh yeah
17:01:19 <Cale> (though if you go with case, you don't get the fall-through)
17:01:20 <chrisdotcode> either I haven't fully wrapped my mind around the haskell mindset yet, or haskell if expressions seems to be reallly short
17:01:24 <Ontolog> or if your gaurds are getting complex, turn some common predicates into their own functions
17:01:56 <Ontolog> or put the predicates into the where clause actually, probably better
17:02:40 <chrisdotcode> cause I have a function with guards, but each condition also have subconditions (I'm actually not working with haskell, but with livescript. I'm trying to make my code more "haskellesque", though)
17:03:12 <Nisstyre-laptop> :t group
17:03:14 <lambdabot> Eq a => [a] -> [[a]]
17:03:17 <Rarrikins> amiller: filter (\xs -> not . any $ zipWith (==) xs (tail xs))
17:03:29 <Rarrikins> amiller: Something like that
17:04:02 <Rarrikins> @pl \xs -> not . any $ zipWith (==) xs (tail xs)
17:04:02 <lambdabot> not . any . ap (zipWith (==)) tail
17:06:40 <Nisstyre-laptop> amiller: http://ideone.com/tFiH2Z
17:19:36 <sw2wolf> @let pktLine msg = printf "%04s%s" (toHex . (4 +) $ length msg) msg
17:19:38 <lambdabot>  <local>:2:32: Not in scope: `toHex'
17:19:48 <sw2wolf> @hoogle to Hex
17:19:49 <lambdabot> No results found
17:19:56 <sw2wolf> @hoogle toHex
17:19:57 <lambdabot> No results found
17:34:15 <trescenzi> Is there a function for selectively merging certain nearby elements within a list?
17:34:26 <trescenzi> I guess zipWith might work?
17:34:39 <typoclass> trescenzi: do you have an example input and output?
17:34:47 <trescenzi> yea
17:34:48 <typoclass> trescenzi: perhaps nubBy
17:35:04 <trescenzi> I'm trying to use words but I need to keep things within " " together
17:35:26 <trescenzi> so i'd like to write a function that takes something like string a = "hello world"
17:35:49 <trescenzi> and turns it into ["string", "a", "\"hello world\""]
17:36:14 <trescenzi> I might steal bits of the source of words and modify it for what I need
17:36:26 <typoclass> trescenzi: so it's like 'words' and then removing the "="?
17:36:31 <trescenzi> ooop
17:36:34 <trescenzi> I missed that
17:36:44 <trescenzi> no it's like words but it leaves the hello world together
17:36:56 <trescenzi> the missing = was a typo
17:39:50 <typoclass> trescenzi: ok ... i've once wanted to do something similar, and i split the input string on ", which would lead to ["string a = ", "hello world", ""], then did 'words' on every second of those. this is admittedly a bit of a cowboy solution. you may want to use parsec instead
17:40:35 <trescenzi> that would work typoclass thanks for the suggestion
17:42:01 <sw2wolf> can cabal use LLVM instead of GCC now ?
17:43:23 <sm> trescenzi: also, here's a quote-aware words: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils.hs#L93
17:43:52 <trescenzi> sm: that's exactly what I wanted. thank you!
17:44:27 <sm> np
17:45:31 <typoclass> sw2wolf: check "cabal help configure", there's a number of "--with-...=/some/path" switches, where "..." can be "gcc" among other things
17:45:51 <typoclass> sw2wolf: (the list is at the very bottom of the "cabal help configure" output)
17:52:45 * hackagebot beamable 0.1.0.0 - Generic serializer/deserializer with compact representation  http://hackage.haskell.org/package/beamable-0.1.0.0 (JohnLato)
17:53:03 <GOMADWarrior> what if it was possible to upload knowledge directly to the brain
17:53:53 <monochrom> then IRC, stackoverflow, and reddit will all be obsolete
17:55:44 <amiller> Rarrikins, Nisstyre-laptop this ended up being my answre
17:55:46 <amiller> http://ideone.com/W9afbd
17:55:51 <amiller> i think i didn't communicate my problem very effectively thouhg!
17:56:05 <shachaf> GOMADWarrior: Weren't you banned in here?
17:56:23 <GOMADWarrior> why would I be
17:56:50 <Nisstyre-laptop> amiller: uh, okay, what was wrong in my version?
17:57:12 <amiller> you removed duplicates from a list
17:57:18 <Nisstyre-laptop> isn't that what you asked for?
17:57:19 <amiller> whereas i wanted to remove all the lists that contained duplicates
17:57:31 <Nisstyre-laptop> okay
17:57:50 <Nisstyre-laptop> that code seems kind of convoluted for that
18:04:08 <napping> amiller: you only care if duplicates are adjancent?
18:05:57 <Nisstyre-laptop> amiller: remDups xxs = filter (\xs -> all (==1) . map length $ group xs) xxs
18:06:24 <Nisstyre-laptop> > filter (\xs -> all (==1) . map length $ group xs) [[1,1,2],[1,2,3],[1,2,3,3],[1,5,6]]
18:06:26 <lambdabot>   [[1,2,3],[1,5,6]]
18:07:29 <Nisstyre-laptop> er, that could be "all ((==1) . length)"
18:07:45 <napping> is there any way to import hidden modules?
18:10:49 <sw2wolf> typoclass: thx
18:12:36 <napping> haxr is nice, but doesn't expose enough to let your print the xml yourself, and I have to deal with servers that don't like the <minimized/> form of empty tags
18:16:38 <chnja> https://boards.4chan.org/sci/res/5684052
18:16:46 <sw2wolf> typoclass: ghc-options=-fllvm doesnot work in ~/.cabal/config ?!
18:17:13 <Eduard_Munteanu> Let's see, should I visit a 4chan link... ?
18:17:24 <chnja> It's the science board
18:17:31 <typoclass> sw2wolf: sorry, i don't know about that
18:17:31 <Eduard_Munteanu> It says "sci/", hm. Ok.
18:17:49 <chnja> Eduard_Munteanu: Quite interesting thread. On cryptography.
18:17:54 <Eduard_Munteanu> Ok, SFW.
18:28:25 <andrew__> Hello, I have this code http://hpaste.org/85966, However it just returns whatevers input, I think its because im using dropWhile with " ", Is there a other char i can use?
18:29:51 <johnw> I don't think ' '> will ever match ' '
18:30:35 <andrew__> why
18:30:47 <johnw> oh, n/m
18:30:57 <andrew__> ('w'>)   returns World from hello world
18:32:47 * hackagebot webserver 0.7.0.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.7.0.0 (JohnLato)
18:32:54 <cmears> andrew__, you're trying to drop whitespace from the front of the string, but there is no whitespace there in your example inputs
18:33:22 <andrew__> http://zvon.org/other/haskell/Outputprelude/dropWhile_f.html
18:33:27 <andrew__> look at example 4 here
18:34:18 <cmears> That works because all the characters in "hello, " are less than 'w'
18:34:36 <cmears> It's not a great example
18:34:44 <typoclass> andrew__: hello. when you do things like 'l' > 'c', it will tell you about the alphabetic ordering (e.g. in the case of 'l' > 'c' you will get False). the ('w' >) thing works only by coincidence because all letters in "hello" come before 'w' in the alphabet.
18:35:08 <andrew__> ohhhh
18:35:09 <andrew__> :(
18:35:10 <Mortchek> > unwords . tail . words $ "foo bar baz quux"
18:35:12 <lambdabot>   "bar baz quux"
18:35:59 <typoclass> andrew__: in haskell, unequals is written "/=". i think you can use that :-)
18:36:00 <Mortchek> > {- but... -} unwords . tail . words $ "foo"
18:36:02 <lambdabot>   ""
18:36:18 <Mortchek> Wait never mind, I had a dumb
18:37:03 <andrew__> I'm actually trying to drop everything after the space
18:37:06 <typoclass> > dropWhile (< 7) [1..10] -- andrew__, just to be sure, this is what dropWhile does
18:37:07 <lambdabot>   [7,8,9,10]
18:37:30 <Mortchek> > head . words $ "foo bar baz"
18:37:32 <lambdabot>   "foo"
18:38:09 <andrew__> typoclass: Yeah, I get it now... That example just confused me
18:39:30 <monochrom> ('w' >) for ridding space makes a great post on dailywtf
18:39:49 <Mortchek> I wonder if they've ever even had Haskell stories
18:39:56 <Mortchek> It's usually stuff like VB and Java and C# I think
18:40:05 <monochrom> people should develop a sense of what makes dailywtf material
18:40:53 <Mortchek> Why do you say that?
18:41:20 <andrew__> haha
18:41:44 <monochrom> if people know what are poor solutions and avoid them, program quality will increase substantially
18:41:45 <typoclass> monochrom: well, if you're a beginner and don't know about haskell's syntax, it's not too far-fetched. ('w' >) could be some kind of dsl thing to "select everything to the right of 'w'"
18:42:38 <monochrom> "select everything to the right of 'w' in order to rid of spaces" is still a great post on dailywtf, do you realize?
18:42:40 <typoclass> monochrom: it was just a misunderstanding. and arguably zvon isn't innocent in this either, because ('w' >) is not as clear as (< 9) or whatever
18:43:54 <monochrom> you have to argue that 'w' looks like notation for the whitespace character class like in regex
18:43:56 <typoclass> monochrom: *shrug* in regexes, \w stands for "word chars", i.e. letters. i always have to look it up because i misremember it as "whitespace"
18:44:00 <andrew__> Thats what i thought, although looking at the examples above it it seems obv
18:44:27 <andrew__> monochrom: I didnt use 'w' though
18:44:36 <monochrom> or what you just said
18:51:13 <andrew__> yay
19:09:38 <sclv> we should really start generating more GSOC ideas for students sniffing around
19:19:08 <andrew__> if i split a string to words, is there a easy way I can grab the first letter of each string
19:19:54 <cjh`> maybe map head over the words
19:20:26 <andrew__> I was thinking that but its mind bending
19:20:49 <andrew__> cause I'd need a map for each string to apply the function with a map in it?
19:21:15 <ab9rf> andrew__: map head $ words
19:21:16 <monochrom> that sentence makes no sense
19:21:24 <ab9rf> :t map head $ words
19:21:25 <lambdabot>     Couldn't match expected type `[[b0]]'
19:21:25 <lambdabot>                 with actual type `String -> [String]'
19:21:25 <lambdabot>     In the second argument of `($)', namely `words'
19:21:27 <cjh`> andrew__: map head [ "hello", "world" ]
19:21:30 <monochrom> use an example, not an essay:
19:21:35 <ab9rf> :t map head . words
19:21:36 <lambdabot> String -> [Char]
19:21:46 <ab9rf> sorry, wrong punctuation
19:21:50 <monochrom> > map head (words "hello kitty are you ok?")
19:21:51 <lambdabot>   "hkayo"
19:22:04 <monochrom> or:
19:22:21 <monochrom> > map head ["hello", "kitty", "are", "you", "ok?"]
19:22:23 <lambdabot>   "hkayo"
19:22:28 <ab9rf> > map head . words $ "help, i'm trapped in a fortune cookie factory"
19:22:30 <lambdabot>   "hitiafcf"
19:22:59 <monochrom> it is [head "hello", head "kitty", etc]
19:23:26 <monochrom> and using the fact ['h', 'k', 'a', 'y', 'o'] = "hkayo"
19:23:42 <ab9rf> monochrom: i kinda wish we had a tool for displaying the evaluation process more readily
19:23:53 <monochrom> I am that tool
19:23:58 <ab9rf> BE THE TOOL
19:24:09 <Javran> how about a list comprehension: [ x | (x:_) <- words "hello world" ]
19:24:31 <monochrom> that also works
19:24:35 <ab9rf> that works, yes
19:25:10 <ab9rf> there is almost never only one way to do anything in haskell
19:25:13 <Rants> >map head $ words "Skidmarks Crabpot Aloysius Tenderness Old-Shoes Lexicography Oinkmeister Grabby Yacht"
19:25:25 <monochrom> you need a space after >
19:25:28 <ab9rf> you need a space afer >
19:25:30 <Rants> true
19:25:36 <Rants> > map head $ words "Skidmarks Crabpot Aloysius Tenderness Old-Shoes Lexicography Oinkmeister Grabby Yacht"
19:25:38 <lambdabot>   "SCATOLOGY"
19:29:17 <Rants> > ['^'..'`']
19:29:19 <lambdabot>   "^_`"
19:29:50 <monochrom> heh
19:30:32 <no-n[11]> > sum . map (\(e,n) -> n*10^e) . zip [0..] . reverse $ [1..9]
19:30:34 <lambdabot>   123456789
19:30:56 <sw2wolf> lambdabot: @list
19:30:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:31:21 <latermuse> no-n[11]: that is badass
19:31:41 <no-n[11]> :}
19:33:58 <Javran> well, I'm new to this channel, is "lambdabot" a repl?
19:34:44 <mikeplus64> yeah
19:35:17 <Javran> > :t id
19:35:18 <lambdabot>   <hint>:1:1: parse error on input `:'
19:35:29 <Javran> lol
19:36:10 <sellout-> :t id
19:36:12 <lambdabot> a -> a
19:36:32 <sw2wolf> Javran: lambdabot is a bot who knows the pre-defind commands and can be extended by plugin
19:36:47 <sw2wolf> @where lambdabot
19:36:47 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
19:36:59 <Rants> @slap Javran
19:36:59 * lambdabot places her fist firmly on Javran's jaw
19:37:22 <cmccann> @botsnack
19:37:23 <lambdabot> :)
19:37:29 <cmccann> @yarr
19:37:30 <lambdabot> Aye
19:39:32 <Rants> there's better @yarrs than thaat
19:39:46 <Javran> ok, I haven't known there's a doc about this bot.
19:39:55 <twoolie> @yarr
19:39:56 <lambdabot> What be a priate's favourite cheese?
19:39:56 <lambdabot> Yarrlsburg!
19:39:59 <Rants> @yarr
19:39:59 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
19:40:27 <twoolie> wow lambdabot, you took it too far
19:40:44 <Rants> earlier she told me to eat maggoty hardtack
19:40:47 <cmccann> haha
19:40:55 <sw2wolf> lambdabot: you make the channel fun :)
19:41:10 <cmccann> @faq can your programming take things too far?
19:41:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:41:53 <Rants> @faq can your programming eat maggoty hardtack?
19:41:54 <lambdabot> The answer is: Yes! Haskell can do that.
19:42:15 <sw2wolf> @faq why isnot haskell fluent ?
19:42:16 <lambdabot> The answer is: Yes! Haskell can do that.
19:42:44 <sw2wolf> haha
19:43:00 <ion> stepcut: Hi. I gather you’re the author of clckwrks? Are there any plans to make it RESTful?
19:43:47 <Rants> I need a project. I'm not good at thinking of projects.
19:44:16 <haasn> Rants: write a haskell -> JS compiler
19:44:20 <haasn> we need more of those
19:44:33 <Rants> MORE?
19:45:02 <Rants> just because javascript sucks doesn't mean we need twenty of those
19:45:03 <Cale> http://hdiff.luite.com/gloss/
19:45:11 <cmccann> you could write a JS -> Haskell compiler instead!
19:45:18 <Cale> we really only need one :P
19:45:19 <sw2wolf> @where mighty
19:45:19 <lambdabot> I know nothing about mighty.
19:45:25 <Rants> hahaha that's a no
19:45:27 <dolio> Write a Haskell -> C++ compiler and then use the C++ -> JavaScript compiler people are working on.
19:45:53 <Rants> there's some okay haskell -> javascript projects going on
19:45:54 <cmccann> how about a Haskell -> C++ template metaprogram compiler
19:45:55 <haasn> write a Haskell -> Haskell compiler and then use that Haskell -> JavaScript compiler people are working on.
19:45:57 <sw2wolf> @where LLVM
19:45:57 <lambdabot> I know nothing about llvm.
19:45:58 <cmccann> actually wait I think that really exists
19:46:06 <sw2wolf> @package LLVM
19:46:07 <lambdabot> http://hackage.haskell.org/package/LLVM
19:46:16 <Rants> I fully endorse them but I don't think I should start my own
19:46:22 <dolio> I'm not aware of anyone writing a template -> js compiler.
19:46:31 <cmccann> dolio: good idea!
19:47:02 <dolio> If you write it in Haskell, you could compiler it to templates, and then it will be self-hosting.
19:47:04 <dolio> Or something.
19:47:07 <sw2wolf> donot re invent wheel . use LLVM as backend ?
19:47:44 <haasn> you should've seen the first iteration of wheels we've been using
19:47:45 <haasn> they were square
19:48:05 <Cale> Write a program which takes the Haskell source code of a Haskell -> Javascript compiler and turns it systematically into an O'Caml -> Lua compiler
19:48:12 <cmccann> hahahaha
19:48:41 <cmccann> Cale: that's just close enough to plausible to be disturbing
19:49:20 <haasn> seems like you'd just have to analyze where text is being read in / printed out in ‘main’ and then slap O'Caml -> Haskell and JavaScript -> Lua around it
19:49:22 <Rants> compile from haskell to C++ to php to javascript back to C and see how unintelligible the result is!
19:49:29 <dolio> I have to say, the C++ -> JS thing makes me a little sad.
19:49:46 <cmccann> dolio: I think I'd rather just use JS at that point.
19:49:49 <haasn> Rants: you should write a program to turn valid Haskell code into ASCII art without destroying the result
19:50:07 <Rants> ermahgerd
19:50:10 <Rants> that would be sweet
19:50:54 <cmccann> Rants: if you want a real project, pick some common-ish file format that nothing on Hackage can read/write, then implement a package to do so
19:51:09 <haasn> think http://search.cpan.org/dist/Acme-EyeDrops/lib/Acme/EyeDrops.pm
19:52:33 <dolio> cmccann: I mean more along the lines of... Once you start doing that, it seems pretty obvious that something is wrong, and some kind of lower level machine is probably a better idea than compiling everything to javascript.
19:52:36 <dolio> If that wasn't obvious before.
19:53:14 <dolio> But we're stuck.
19:53:24 <cmccann> dolio: really there's no shortage of things wrong with the idea of a C++ -> JS compiler
19:53:36 <cmccann> so just take your pick which one you want
19:54:01 <dolio> Well, the point is you can re-compile that subset of JS to something more efficient than arbitrary JS.
19:54:57 <dolio> Although I don't know that 'it came from C++' is the ideal way to express that subset.
19:56:20 * cmccann thinks "It Came From C++" would make a good title for a cheesy retro horror flick
19:56:46 <dolio> I kind of have a larger issue with javascript as a compiler target, really.
19:56:59 <cmccann> but it's what runs in every browser
19:57:04 <cmccann> so we target it because the whole world is mad
19:57:05 <dolio> Yeah.
19:57:19 <haasn> but we're enabling it
19:57:25 <gwern> 'we call them mad, they called us mad, and damn them, they outvoted us.'
19:57:32 <cmccann> haha
19:57:49 <haasn> if you want to process, patch a new language into chromium and firefox HEAD, then start using that exclusively on your web pages
19:57:55 <haasn> progress*
19:58:23 <dolio> Everyone needs to be able to read the compiler-generated javascript, even though it's complete garbage. Because the web is open, man.
19:58:32 <haasn> not like firefox would mind the extra bloat; and if you make it optional at compile time or something most users shouldn't complain
19:58:53 <dolio> Chrome already has something else.
19:59:02 <haasn> that NaCl thing?
19:59:06 <Rants> javascript compiled from haskell-like languages is readable enough but also pretty bulky
19:59:09 <dolio> And everyone else moaned about it, because it's not the Web Way.
19:59:13 <dolio> Yeah.
19:59:18 <haasn> ah
19:59:25 <haasn> I wasn't too sure on its status
19:59:29 <haasn> I thought google abandoned it or something
19:59:41 <haasn> well, then, patch that into firefox and start writing Haskell compilers to target it?
19:59:52 <dolio> I don't think so. I think they use it a lot in chrome os, for instance.
19:59:54 <cmccann> we could invent a lisp-based browser language, that way people would moan about all the parentheses instead
20:00:14 <haasn> cmccann: drawbacks of both, benefits of neither; I like it
20:00:15 <joeyh> how does one write a case statement nested in a do block when not using layout? GHC outputs something like this http://hpaste.org/85967 but refuses to parse it
20:00:45 <cmccann> see another problem here is that the software industry as a whole is not interested in adopting non-shitty languages
20:00:46 <mikeplus64> joeyh: might need ; at the end of print "True"
20:00:48 <dolio> I'm pretty sure everyone but google has vetoed the idea of putting nacl in their browser. So there's no point in implementing it, really.
20:00:50 <monochrom> quick answer: you need more {;}. but let me see.
20:00:57 <haasn> what mikeplus64 said
20:00:59 <Rants> some people legitimately like javascript
20:01:08 <haasn> with explicit layout you have to separate ‘case’'s matches
20:01:09 <Rants> most of those people don't know anything else, though
20:01:19 <joeyh> aha, ok. The "of {" threw me
20:01:44 <dolio> Pretty much no one even executes javascript directly, either. They compile to a vm of some sort that would probably be a better target for code generation.
20:01:51 <dolio> But you can't do that.
20:02:37 <haasn> well, standardize the vm code and you lock down implementation backends; unless you want them to end up using another, different vm for execution internally
20:02:52 * hackagebot logicst 0.1.0.0 - Backtracking mutable references in the ST and IO monads  http://hackage.haskell.org/package/logicst-0.1.0.0 (AndySonnenburg)
20:03:27 <dolio> Anyhow, it doesn't really affect me, because I don't write web stuff. But I think it's a silly situation.
20:04:25 <Rants> but so many of teh web monkeys are happy with javascript ~~~~~
20:04:47 <monochrom> I must have missed the rule that says: if you open with {, you need explicit ;
20:04:51 <dolio> I don't even care if people like javascript. It just isn't a good compiler target.
20:05:26 <Nisstyre-laptop> Could someone explain why this requires UndecidableInstances? http://ideone.com/cnrCH9
20:05:55 <Nisstyre-laptop> that may be a silly way to do that, but I'm just learning about TypeFamilies and I figured I'd try that out without referencing anything else
20:06:56 <Rants> Well, Rule 110 has been encoded in HTML5 and CSS, so HTML5 and CSS can be considered to be turing complete
20:07:04 <dolio> Nisstyre-laptop: My guess would be that GHC doesn't like that the second argument is growing, even though that doesn't matter.
20:07:06 <Rants> therefore we can, and therefore should, compile to html
20:07:15 <Nisstyre-laptop> dolio: ah ok
20:07:47 <haasn> really the solution is so simple
20:07:53 <haasn> we just drop the ‘Script’ bit and embed a JVM in every browser
20:08:24 <Rants> brilliant
20:08:43 <haasn> monochrom: { disables implicit layout entirely, which means \n doesn't trigger anything special, right?
20:08:51 <dolio> Nisstyre-laptop: It's probably not smart enough to figure out that you couldn't later add an 'Add a (Succ b) = Add (Succ a) b' instance, which is only ruled out due to overlapping.
20:08:56 <haasn> the usual rules for separating statements are based on newlines and indentation depth
20:09:40 <monochrom> yeah, interesting
20:09:43 <Nisstyre-laptop> dolio: okay, so it thinks it could possibly get into an infinite loop, when it actually couldn't?
20:10:26 <Nisstyre-laptop> makes sense anyway, thanks
20:10:28 <haasn> Rants: while HTML may be turing complete that doesn't mean you can necessarily get useful output from it, like a game of pong - for all I know, we could be limited to flipping checkboxes
20:10:51 <dolio> Nisstyre-laptop: That'd be my guess.
20:11:18 <haasn> Nisstyre-laptop: also keep in mind GHC can't prove whether something halts or not
20:11:19 <Rants> it's actually not turing complete until you incorporate user input as part of it, for pong the user would have to hit the spacebar for every tick of the game loop
20:11:30 <monochrom> be careful with Turing completeness. it is a very weak requirement.
20:11:32 <haasn> so you may run into plenty of situations where you write halting functions that require UndecidableInstances
20:12:08 <haasn> Rants: on the upside, you don't need to implement a pause feature
20:15:47 <haasn> Nisstyre-laptop: also in GHC 7.6 you could define “data Nat = Zero | Succ Nat” and benefit from kind safety
20:16:07 <Nisstyre-laptop> haasn: could I do it with DataKinds?
20:16:18 <haasn> yes, that's the extension you'd need
20:16:28 <Nisstyre-laptop> ah, cool, could you show me the definition for that?
20:16:36 <haasn> I just did
20:16:37 <Nisstyre-laptop> or is the type family part the same?
20:16:40 <Nisstyre-laptop> okay
20:16:43 <haasn> it is
20:17:09 <mikeplus64> you could write i think type family Add (x :: Nat) (y :: Nat) :: Nat
20:17:09 <haasn> you may need to add kind signatures, I'm not sure
20:17:15 <haasn> yeah that
20:17:24 <Nisstyre-laptop> yeah, so KindSignatures as well
20:17:34 <haasn> DataKinds implies KindSignatures doesn't it?
20:17:37 <Nisstyre-laptop> no clue
20:17:53 * hackagebot conjugateGradient 2.0 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-2.0 (LeventErkok)
20:17:54 <tgeeky> haasn: no?
20:19:18 <haasn> I don't have KindSignatures in my .ghci and I can specify kind signatures just fine; but I have a few more extensions apart from DataKinds
20:19:21 <tgeeky> haasn: PolyKinds implies that
20:20:23 <haasn> oh
20:20:30 <haasn> TypeFamilies implies it
20:32:29 <Guest36654> pl \x y -> x y
20:33:10 <dolio> ($)
20:34:21 <Rants> (id)
20:34:24 <Guest36654> I was testing to see if that worked
20:34:30 <Guest36654> but, thanks!
20:34:36 <parcs> @pl \x y -> x y
20:34:36 <lambdabot> id
20:34:58 <Rants> doesn't do anything
20:35:11 <Guest36654> pl \a b c -> a $ b . c
20:35:48 <cmccann> @pl ($)
20:35:49 <lambdabot> id
20:35:55 <cmccann> that's reassuringly thorough.
20:35:57 <Guest36654> @pl \a b c -> a $ b . c
20:35:57 <lambdabot> (. (.)) . (.)
20:35:59 <Guest36654> ahhh
20:36:47 <Guest36654> @pl \c -> a $ b . c
20:36:47 <lambdabot> a . (b .)
20:37:26 <Rants> @pl \x y z -> x (y z)
20:37:26 <lambdabot> (.)
20:40:10 <Rants> ( \x y -> x y) doesn't give you the grouping $ does
20:41:54 <Rants> > map head (\x y -> x y) words "hello kitty"
20:41:56 <lambdabot>   The function `GHC.Base.map' is applied to four arguments,
20:41:56 <lambdabot>  but its type `(a...
20:43:30 <ab9rf> > map head (\x y -> x y) $ words "hello kitty"
20:43:32 <lambdabot>   The lambda expression `\ x y -> x y' has two arguments,
20:43:32 <lambdabot>  but its type `[[b0...
20:44:18 <Rants> you gave the lambda as an argument to map
20:44:46 <Rants> or I'm stupid, possibly the latter
20:44:48 <ab9rf> indeed :)
20:45:06 <ab9rf> which also failed, for fairly obvious reasons (or are they obvious?)
20:45:15 <Rants> is there any way to specify infixr 0 on a lambda?
20:45:25 <ab9rf> Rants: no
20:45:38 <Rants> posh
20:45:44 <cmccann> monochrom: oh you'll probably like this. I asked someone "why did you expect that code to do anything other than X?" and they reply "because I want it to do Y"
20:46:18 <ab9rf> (\x y -> x y) (map . head) (words "hello kitty")
20:46:21 <ab9rf> > (\x y -> x y) (map . head) (words "hello kitty")
20:46:23 <lambdabot>   Couldn't match expected type `a0 -> b0'
20:46:23 <lambdabot>              with actual type `GHC....
20:46:32 <no-n[11]> how would you do something like (< 1 2 3) or 1 < 2 < 3 in Haskell?
20:46:35 <ab9rf> :t map . hed
20:46:37 <lambdabot>     Not in scope: `hed'
20:46:37 <lambdabot>     Perhaps you meant one of these:
20:46:37 <lambdabot>       `head' (imported from Data.List),
20:46:38 <ab9rf> :t map . head
20:46:39 <lambdabot> [a -> b] -> [a] -> [b]
20:46:52 <ab9rf> > (\x y -> x y) (map head) (words "hello kitty")
20:46:54 <lambdabot>   "hk"
20:47:12 <cmccann> no-n[11]: I don't think there's any concise way to do that, alas
20:47:28 <cmccann> there kinda should be
20:47:40 <no-n[11]> ye
20:47:41 <ab9rf> there's no easy way to do that
20:47:57 <ab9rf> although, hm
20:47:57 <cmccann> I mean, I can think of a couple ways to golf it but they're all opaque and obfuscated
20:48:02 <Rants> >  (map head) (words "hello kitty") -- no good reason to use the do nothing lambda
20:48:04 <lambdabot>   "hk"
20:48:12 <ab9rf> @hoogle (a -> a -> b) -> [a] -> [b]
20:48:12 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
20:48:13 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
20:48:13 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
20:48:28 <ab9rf> > scanr1 (>) [1 2 3]
20:48:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
20:48:30 <lambdabot>    arising from the literal `1...
20:48:39 <ab9rf> oh, right
20:48:46 <cmccann> > let xs = [1, 2, 3] in and $ zipWith (<) xs (tail xs)
20:48:48 <Rants> THIS ISN'T LISP
20:48:49 <lambdabot>   True
20:48:54 <cmccann> > let xs = [5, 2, 3] in and $ zipWith (<) xs (tail xs)
20:48:55 <lambdabot>   False
20:49:15 <ab9rf> cmccann: excellent
20:49:18 <chenwl> > 1 + 1
20:49:20 <lambdabot>   2
20:49:26 <no-n[11]> oh, nice cmccann
20:49:30 <cmccann> a variation on the old zip `ap` tail thing obv
20:49:40 <cmccann> not too opaque if you've seen the pattern
20:49:51 <cmccann> but kinda horrible compared to just (< 1 2 3)
20:50:34 <no-n[11]> zipWith tail, crazy :)
20:51:04 <cmccann> no-n[11]: I assume you see basically how it works
20:51:19 <cmccann> > let xs = [1..10] in zip xs (tail xs)
20:51:21 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
20:51:44 <no-n[11]> mmm
20:52:10 <ab9rf> @unpl \f xs -> zipWith f xs (tail xs)
20:52:11 <lambdabot> \ f xs -> zipWith f xs (tail xs)
20:52:19 <ab9rf> @pl \f xs -> zipWith f xs (tail xs)
20:52:20 <ab9rf> duh
20:52:23 <lambdabot> (`ap` tail) . zipWith
20:52:51 <Rants> > fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . (.) . (.) . (:)) . (flip ((.) . (:)) .)) "hello" "kitty"
20:52:53 <lambdabot>   "hkeiltltoy*Exception: Prelude.head: empty list
20:53:00 <ab9rf> hee
20:53:06 <Rants> ack
20:53:24 <ab9rf> are we abusing pointless today?
20:53:30 <Rants> EVERY DAY
20:53:37 <ab9rf> > fix show
20:53:39 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
20:53:42 <no-n[11]> lol
20:53:57 <cmccann> > fix error
20:53:59 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:54:47 <ab9rf> help, i'm trapped in an endless stream of exceptions, and i can't tell whether or not they're all different
20:55:07 <cmccann> btw, if you want the pointlessly golfed version of my (< 1 2 3) thing above, "and . (zipWith (<) <*> tail)" is the 'nicest' way
20:55:14 <jmcarthur> :t (==) <*> sort   -- not so efficient, but pretty
20:55:15 <lambdabot> Ord a => [a] -> Bool
20:55:33 <cmccann> jmcarthur: yeah that one was a bit too horrible for me to consider
20:55:33 <ab9rf> jmcarthur: ugh!
20:55:52 <ab9rf> jmcarthur: and not the same either
20:56:08 <jmcarthur> why not?
20:56:13 <ab9rf> > ( (==) <*> sort ) [1,1,1,1,6]
20:56:15 <lambdabot>   True
20:56:27 <jmcarthur> oh we're after (<) not (<=)?
20:56:31 <ab9rf> jmcarthur: yes
20:56:35 <jmcarthur> i assumed (<=) was implied. woops
20:57:15 <ab9rf> > (\xs -> all $ zipWith f xs (tail xs)) [1,1,1,1,6]
20:57:17 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
20:57:17 <lambdabot>              with actua...
20:57:21 <ab9rf> feh, i suck
20:57:35 <cmccann> and, not all
20:57:51 <ab9rf> yeah and
20:57:54 * hackagebot combobuffer 0.1 - Various buffer implementations  http://hackage.haskell.org/package/combobuffer-0.1 (JohnLato)
20:58:05 <ab9rf> > (\f xs -> and $ zipWith f xs (tail xs)) (>) [1,1,1,1,6]
20:58:07 <lambdabot>   False
20:58:10 <cmccann> you could do it with all if you uncurry (<) and use zip instead of zipWith
20:58:10 <ab9rf> > (\f xs -> and $ zipWith f xs (tail xs)) (<) [1,1,1,1,6]
20:58:12 <cmccann> but that's uglier
20:58:13 <lambdabot>   can't find file: L.hs
20:58:15 <ab9rf> > (\f xs -> and $ zipWith f xs (tail xs)) (<) [1,1,1,1,6]
20:58:18 <lambdabot>   False
20:58:22 <ab9rf> > (\f xs -> and $ zipWith f xs (tail xs)) (<=) [1,1,1,1,6]
20:58:24 <lambdabot>   True
20:58:28 <ab9rf> yay
20:58:58 <ab9rf> cmccann: indeed.
21:01:37 <dacto> Is there a way to "take" from an /infinite/ list that is within a state monad?
21:02:42 <jbracker_> dacto: (take 10) `fmap` get
21:03:32 <ab9rf> :t fmap
21:03:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:04:32 <jmcarthur> :t (==) <*> map head . group . sort   -- no more efficient, less pretty, but at least correct
21:04:33 <lambdabot> Ord b => [b] -> Bool
21:04:46 <jmcarthur> you can "ugh" me again
21:04:48 * cmccann wonders what would be a good name for \f xs -> zipWith f xs (tail xs)
21:05:06 <cmccann> jmcarthur: there's nothing I can say that would be worse than the code you just wrote
21:05:07 <jmcarthur> mapPairs?
21:05:17 <jbracker_> cmccann: shiftZip
21:05:20 <jmcarthur> cmccann: oh there's plenty of worse code i could write
21:05:22 <jbracker_> cmccann: zipShift
21:05:39 <cmccann> it's not really a zip conceptually
21:06:03 <cmccann> it's a sort of pairwise double map thing
21:06:05 <cmccann> or whatever
21:06:15 <dacto> the trouble i was having is that bind is strict. Would fmap preserve laziness?
21:06:33 <dacto> well in my case the bind is strict
21:06:46 <cmccann> mapPairs is reasonable though
21:07:01 <jbracker_> mapSucc?
21:08:35 <ab9rf> why is the bind strict in your case?
21:09:19 <ab9rf> cmccann: lagmap
21:10:04 <jmcarthur> :t (==) <*> scanl1 max . map head . group
21:10:06 <lambdabot> Ord a => [a] -> Bool
21:10:21 <dacto> maybe monad
21:11:17 <cmccann> ab9rf: cute, but I'd never remember it :P
21:11:48 <jmcarthur> zipApTail
21:11:49 <ab9rf> dacto: maybe doesn't force strictness, unless i missed something somewhere
21:11:50 <jmcarthur> ohwait
21:11:55 <cmccann> heh
21:12:31 <ab9rf> tailchaser
21:12:35 <dacto> ab9rf: i thought when binding maybe you need to look at each element to see if one is nothing
21:12:56 <cmccann> it's (\f -> zipWith f <*> tail) anyway, not zip :P
21:13:00 <cmccann> ab9rf: haha
21:13:02 <ab9rf> dacto: that doesn't force a full recursive evaluation
21:13:41 <dacto> ab9rf: but it still does require traversing the entire list before giving an answer..right?
21:14:04 <jmcarthur> dacto: so what is this, StateT [something] Maybe?
21:14:25 <jmcarthur> @unmtl StateT [e] Maybe a
21:14:25 <lambdabot> [e] -> Maybe (a, [e])
21:15:07 <dacto> jimcarthur: essentially, I'm working with search algorithms and keeping a state along with encountered configurations which maybe be Just config or nothing (invalid moves)
21:15:33 <jmcarthur> sounds like you really want LogicT or something
21:15:52 <dacto> LogicT...hmm never heard of that - I'll have to look into it
21:16:00 <jmcarthur> basically the list monad but fancier
21:17:12 <jmcarthur> and note that the list monad (and LogicT) is expressive enough for impossible stuff (just the empty list), so it kind of subsumes Maybe
21:17:43 <dacto> right
21:18:19 <dacto> Ok, I think for the current problem I'm going to try and get fmap working. And then look into logicT
21:43:56 <allenj12> can anyone tell me why my error reverses here?
21:44:00 <hpaste> allenj12 pasted “Help with lists” at http://hpaste.org/85969
21:50:47 <klugez> allenj12: getConclusion seems to return an IO String while you try to ++ it with Strings.
21:51:41 <allenj12> klugez: awww that makes sense that stumped me for a while lol whats a possible solution?
21:52:32 <Rotaerk> hmm is there some standard operator equivalent to (.).(.)
21:52:56 <Rotaerk> or do people typically just do:  ((.).(.)) f g a
21:53:10 <klugez> allenj12: You should get a String from by executing the getConclusion action and then return the concatenation as IO String.
21:53:37 <sellout-> Rotaerk: Just that I think – http://www.haskell.org/haskellwiki/Pointfree#Dot
21:53:56 <allenj12> klugez: kk ill try that
21:54:03 <klugez> allenj12: Or is the first parameter `conclusion` the same that you get with getConclusion?
21:54:19 <allenj12> klugez: yes it is
21:54:33 <klugez> allenj12: Then use that instead of getConclusion. :P
21:55:03 <derek_c> Hello guys, I want to see the source code of IO monad but apprently the link on Haskell Wiki is broken... can anyone point me to the right page?
21:55:19 <haasn> Rotaerk: usually it's called (.:)
21:55:33 <allenj12> klugez: well that wouldnt exactly work see im taking from a pool of logical atomic statement but if i pull a "$" im gonna recall it for diversity
21:55:35 <haasn> but it's not defined in ‘base’. There's at least one definition in pointless-fun
21:55:48 <allenj12> klugez: i can repost the relevant code hold on
21:56:09 <Rotaerk> hmm thanks
21:56:12 <klugez> allenj12: Ah. No need, I'll have to run anyway, so I won't have time to look at it. :)
21:56:33 <allenj12> klugez aww k thnx for your help tho!
21:56:44 <haasn> < (.:) == ((.).(.))
21:56:45 <goodfellow>   Not in scope: `.:'
21:56:46 <goodfellow>  Perhaps you meant one of these:
21:56:46 <goodfellow>    `.' (line 86), `P..'...
21:56:47 <haasn> aaw
21:56:58 <haasn> hey, goodfellow and lambdabot hash to the same name color here
21:57:02 <haasn> how convenient
21:57:39 <Rotaerk> hmm maybe I'll just define my own, because I can see myself needing (.).(.).(.), (.).(.).(.).(.), etc as well
21:57:59 <haasn> (.::), (.:::) ...
21:58:02 <Rotaerk> yea
21:58:07 <haasn> though it does get silly after 2
21:58:24 <hpaste> allenj12 pasted “Help with lists” at http://hpaste.org/85971
21:58:32 <Rotaerk> not really, just means you're increasing the number of arguments for the right-most function in the chain
21:58:43 <allenj12> this seems to be tricky sorry for re post
21:58:46 <allenj12> paste*
21:59:06 <Rotaerk> I guess it could be used mid-chain, but I think that'd get confusing
21:59:44 <haasn> allenj12: I'm guessing ‘getConclusion’ returns an IO String ?
21:59:56 <allenj12> haasn: yes
22:00:13 <haasn> yes, there's your problem. You can't write a pure function that relies on the result of an IO action
22:00:34 <allenj12> haasn: but if i change it to IO String i get a reverse problem
22:02:08 <allenj12> haasn: Couldn't match expected type `IO String' with actual type `[Char]'
22:02:13 <allenj12> when i make it impure
22:02:41 <haasn> you don't “make it impure”
22:02:43 <haasn> that's not how IO works
22:02:54 <haasn> “IO String” isn't a string
22:03:06 <haasn> anyway I have to go now, school and all
22:03:21 <allenj12> hmmm kk thnx
22:07:57 * hackagebot biophd 0.0.6 - Library for reading phd sequence files  http://hackage.haskell.org/package/biophd-0.0.6 (DanFornika)
22:28:55 <hpaste> allenj12 pasted “Good solution?” at http://hpaste.org/85972
22:31:55 <allenj12> hmm anyone help with above code? i cant seem to figure it out
22:32:13 <allenj12> i see the problem not a good solution tho
22:32:44 <mikeplus64> allenj12: what's runRVar?
22:32:55 <mikeplus64> allenj12: just looking at it, maybe the type for the function is String, not IO String. depending on the type of runRVar
22:33:48 <allenj12> mikeplus64: runRVar help make the special data type that choice produces back into an IO String
22:35:37 <allenj12> mikeplus64: i know its because getConclusion returns an IO string and ys and zs are Strings but is there no way to combine them?
22:36:17 <mikeplus64> allenj12: oh right yeah you need to first run getConclusion operators atoms, and then concatenate the results
22:36:39 <mikeplus64> there are a number of ways of doing this
22:36:50 <allenj12> hmmm what do you recommend?
22:38:36 <hpaste> “Anonymous Coward” annotated “Good solution?” with “Good solution? (annotation)” at http://hpaste.org/85972#a85973
22:38:44 <mikeplus64> allenj12:
22:38:52 <mikeplus64> oops i forgot to add the where replacement = ... in the second one
22:39:06 <mikeplus64> also forgot to change the type of expandDol
22:39:17 <mikeplus64> it should be expandDol :: String -> String -> [String] -> IO String
22:39:39 <mikeplus64> also the do in the second one is superflous
22:39:42 <mikeplus64> oops
22:40:25 <hpaste> “Anonymous Coward” annotated “Good solution?” with “Good solution? (annotation) (annotation)” at http://hpaste.org/85972#a85974
22:40:27 <allenj12> mikeplus64: ill try to get it working lol
22:41:20 <allenj12> mikeplus64: sry to bother u more but can u explain how return works briefly?
22:41:34 <mikeplus64> allenj12: return :: Monad m => a -> m a
22:41:50 <mikeplus64> so it takes something, and "returns" it, in some monad, e.g. IO
22:41:57 <allenj12> ahhh k! i see
22:42:14 <allenj12> ill try that code gimme sec
22:43:15 <allenj12> mikeplus64: it works TY!!
22:43:20 <mikeplus64> no worries
22:54:05 <derek_c> Hello guys, I want to see the source code of IO monad but apprently the link on Haskell Wiki is broken... can anyone point me to the right page?
22:54:37 <simpson> derek_c: You do understand that IO's implementation varies from compiler to compiler?
22:56:27 <derek_c> simpson: I didn't think of that
22:56:38 <derek_c> I guess I wanted the GHC's implementation..
22:56:51 <derek_c> there is a "source" link on Haskell Wiki but it's broken
23:08:14 <derek_c> I'm learning monad and there is a weird behavior that I don't understand
23:08:18 <derek_c> so I defined this type:
23:08:23 <derek_c> data Sheep = Sheep { name :: String, father :: Maybe Sheep, mother :: Maybe Sheep}
23:08:33 <derek_c> now I have this function:
23:09:09 <derek_c> fatherOfFather s = do { f <- Nothing; father f}
23:09:36 <derek_c> so if I call fatherOfFather, "Nothing" is returned
23:10:03 <derek_c> but the thing is, "f <- Nothing" effectively makes f a "Nothing", right?
23:10:17 <derek_c> so how come I can call "father Nothing"?
23:10:26 <c_wraith> it doesn't
23:10:31 <derek_c> this is my fatherOfFather signature
23:10:31 <c_wraith> It terminates the computation
23:10:33 <derek_c> fatherOfFather :: Sheep -> Maybe Sheep
23:10:37 <c_wraith> such that father is never called
23:10:44 <derek_c> oh!!!
23:10:52 <derek_c> that's totally it lol
23:10:55 <derek_c> thank you man
23:28:28 <sw2wolf> @unmtl ReaderT XConf (StateT XState IO) a
23:28:29 <lambdabot> XConf -> XState -> IO (a, XState)
23:29:51 <sw2wolf> what does mtl mean ?
23:30:21 <sopvop> @hoogle mtl
23:30:22 <lambdabot> package mtl
23:30:22 <lambdabot> package mtl-tf
23:30:22 <lambdabot> package mtlparse
23:30:42 <derek_c> mtl is a bunch of standard transformers
23:31:11 <derek_c> I'm trying to use mplus with Maybe, which should be possible since Maybe is an instance of MonadPlus
23:31:15 <sw2wolf> Monad Transformer L?
23:31:26 <derek_c> but how come ghci tells me "mplus is not in scope"?
23:31:54 <sw2wolf> derek_c: what is L in mtl ?
23:31:55 <sopvop> derek_c: import Control.Monad
23:32:04 <sopvop> Library
23:32:40 <sw2wolf> then unmtl converts it to function ?
23:33:12 <derek_c> hmm that's pretty weird... I'd expect since mplus is a function of Maybe, it should always be in the same scope as Maybe?
23:33:28 <shachaf> mplus is not a function of Maybe
23:33:41 <derek_c> mplus is a function of the typeclass MonadPlus
23:33:51 <derek_c> and Maybe is an instance of MonadPlus
23:33:55 <shachaf> OK.
23:33:59 <derek_c> so...
23:34:07 * sw2wolf seems function is clear than transformer ?
23:34:08 <derek_c> they don't have to be in the same scope?
23:34:17 <shachaf> module Foo where class Blah a where ...; instance Blah Maybe where ...
23:34:30 <shachaf> Now Maybe is an instance of Blah!
23:34:38 <shachaf> Shouldn't Blah always be in scope when Maybe is?
23:35:26 <derek_c> oh yeah I see what you mean
23:35:40 <sopvop> derek_c: It is also possible what you have type class in scope and data type in scope, but some bastard put orphan instance in module which you didn't import
23:35:50 <sw2wolf> @ty ap
23:35:51 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:36:03 <derek_c> I just saw that the implementation of Maybe as a MonadPlus and it's in the same file as where MonadPlus itself is defined
23:36:05 <sopvop> @ty (<*>)
23:36:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:36:16 <shachaf> Maybe is a lot of things.
23:36:34 <derek_c> so that's why I need to import Control.Monad
23:36:59 <sopvop> derek_c: you need to import Control.Monad because MonadPlus is not imported into prelude
23:37:06 <sw2wolf> @ty liftM2
23:37:08 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:38:27 <derek_c> sopvop: I seee
23:38:35 <derek_c> sopvop: thank you!
23:38:37 <shachaf> derek_c: Oh, are you thinking "function of" as in OO or something?
23:38:53 <sw2wolf> @ty Endo
23:38:55 <lambdabot> (a -> a) -> Endo a
23:39:17 <sw2wolf> @hoogle Endo
23:39:18 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
23:39:18 <lambdabot> Data.Monoid newtype Endo a
23:39:18 <lambdabot> System.Posix.Terminal EndOfFile :: ControlCharacter
23:39:26 <sopvop> sw2wolf: you can also chat with lambdabot in private
23:39:41 <sw2wolf> sopvop: sure
