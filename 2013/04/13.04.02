00:13:10 * hackagebot keter 0.3.6 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.6 (MichaelSnoyman)
00:28:16 <latermuse> how do i install a haskell package without cabal?
00:28:50 <elliott> without Cabal, or without cabal-install?
00:28:57 <latermuse> without cabal
00:33:52 <gienah> latermuse: runhaskell ./Setup.hs configure --user; runhaskell ./Setup.hs build; runhaskell ./Setup.hs install; # I guess, never tried this, if you use --global then that will break global pkgs which would be *bad*
00:34:20 <latermuse> gienah: Thank you!
00:35:53 <elliott> latermuse: note that that is without cabal-install
00:35:56 <elliott> it still uses Cabal.
00:46:47 <latermuse> im getting this error when I try to install a package. /usr/bin/ld: unrecognized option '--hash-size=31'
00:47:04 <latermuse> Im running freebsd at the moment. Has anyone run into this error before?
00:48:43 <ramses_> latermuse: where does your ld come from? The one on my linux system has that option documented
00:49:27 <latermuse> GNU ld version 2.15 [FreeBSD] 2004-05-23
00:49:32 <latermuse> might be too old? heh
00:49:39 <Ralith> wow that's old
00:50:06 <latermuse> I guess I need to update that then.
00:50:06 <Ralith> surely you have unpatched security vulnerabilities
00:50:07 <ramses_> haha, an update might be in order! :)
00:50:42 <latermuse> ralith: surely
00:51:09 <latermuse> the boys in the data center gave me an old image i guess
00:51:42 <ramses_> maybe they need a wakeup call ;)
00:52:07 <latermuse> luckily its not a public-facing server
00:53:34 <ramses_> I've now people getting into serious problems because they assumed all evil comes from outside the network
00:53:55 <ramses_> s/now/known (what's wrong with me)
00:56:52 <Ralith> indeed, it's not unheard of for attacks to originate from datacenter LANs
01:01:29 <latermuse> Due to licensing problems, freebsd isnt allowed to install a newer version of ld by default.
01:01:41 <latermuse> so im compiling the newest version now. should be fixed up in a few minutes (hours?)
01:03:48 <ramses_> and in those nine years they haven't done anything about that? Not sure if I would count on such a system..
01:11:24 <Chousuke_> why would freebsd use gnu ld?
01:12:47 <mm_freak> what's the default associativity when no infix annotation is given?  left or right?
01:12:52 <Ralith> why wouldn't it?
01:14:14 <Chousuke> Ralith: because it's GPL
01:14:21 <Ralith> so?
01:14:36 <Chousuke> The FreeBSD project doesn't like GPL in the base system
01:14:45 <Chousuke> to the point that they replaced GCC with Clang
01:14:47 <Ralith> and yet ld is hardly the only example of it.
01:17:47 <quchen> I've been hearing about indexed monads a couple of times here in the past, can anyone explain what they are? SO/Google couldn't help much.
01:18:11 * hackagebot yesod-auth 1.1.6 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.6 (MichaelSnoyman)
01:20:37 <donri> aren't they basically plain monads that carry a phantom type?
01:21:32 <quchen> donri: I don't know
01:21:49 <quchen> Could be true telling from the discussions I found online
01:22:05 <donri> do you understand phantom types?
01:22:27 <quchen> The concept yes, but I haven't used them much
01:22:28 <shachaf> Why phantom?
01:22:59 <quchen> I found a 15 page text on "type indexed monads", is that the same thing?
01:23:03 <donri> shachaf: because the index type doesn't appear in the term level does it?
01:23:15 <shachaf> It doesn't?
01:23:19 <shachaf> Which indexed monad are you thinking of?
01:23:20 <donri> i don't know!
01:23:44 <donri> mhm my primary exposure was the earlier pipes version
01:24:23 <shachaf> Oh.
01:24:31 <donri> and IIRC it had a "phantom" type in the monad for stuff like "closed stream" or something
01:24:33 <shachaf> I recommend finding another exposure.
01:24:47 <donri> but now i just remembered indexed monads can be used for type-changing state? IIRC, again :p
01:24:52 <quchen> My primary exposure was nothing so far, that's why I'm asking what an indexed monad is. :-)
01:25:40 <quchen> http://www.cs.ou.edu/tfp2010/files/08.pdf looks promising though.
01:25:59 <quchen> Provided that's the thing I'm looking for and not something with a similar name.
01:29:09 <asdd> Hey general question, what is functional programming mainly used for?
01:29:23 <c_wraith> mainly for writing program
01:29:23 <c_wraith> s
01:29:31 <asdd> o.0
01:29:47 <asdd> in terms of industry
01:29:48 <Taneb> Seriously, pretty much anything except possibly device drivers
01:29:49 <lambdabot> Taneb: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:29:50 <c_wraith> It's kind of a silly question. What is imperative programming mainly used for?  Writing programs.
01:30:18 <donri> @quote obscure.research
01:30:18 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
01:30:21 <c_wraith> The method of expressing the idea does not limit the application domain
01:30:23 <donri> @quote obscure
01:30:23 <lambdabot> goundoulf says: I've been reading a very good tutorial on haskell, because the [XMonad] config file was too obscure for me
01:30:29 <donri> @quote research.language
01:30:30 <lambdabot> No quotes match. Just what do you think you're doing Dave?
01:30:32 <quchen> donri: How is that quote not in this list? :-(
01:30:33 <donri> :(
01:30:40 <Cale> add it?
01:30:45 <donri> it used to be!
01:30:59 <quchen> Googling.
01:31:35 <donri> @remember Jafet Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
01:31:35 <lambdabot> It is forever etched in my memory.
01:32:02 <c_wraith> that appears truncated
01:32:06 <Cale> Something weird happened to the quote file at one point and I had to replace it with a backup.
01:32:06 <donri> in deed
01:32:13 <bergmark> http://ircbrowse.net/browse/haskell?id=14530058&timestamp=1352276569#t1352276569
01:32:25 <quchen> Does @remember add something to the quote database, or just marks it for some log parser so it can be added manually?
01:32:35 * elliott thinks it's better for the truncation
01:32:44 <donri> hehe
01:32:54 <c_wraith> quchen: it adds it directly to the database
01:33:11 * hackagebot network-conduit-tls 1.0.0.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.0.2 (MichaelSnoyman)
01:33:13 * hackagebot keter 0.3.6.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.6.1 (MichaelSnoyman)
01:33:45 <quchen> Can't find the quote in the IRC log database either
01:33:51 <donri> http://ircbrowse.net/browse/haskell?q=abstract+research+language
01:33:57 <donri> i can only find it truncated
01:34:37 <quchen> ... and the second half starts with "s". Great
01:34:54 <quchen> s, phone apps, and web services.
01:34:55 <quchen> Ha
01:34:58 <quchen> Click the timestamp
01:35:15 <donri> oic
01:35:22 <donri> @forget Jafet Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
01:35:22 <lambdabot> Done.
01:35:38 <donri> @remember Jafet Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
01:35:38 <lambdabot> Nice!
01:35:52 <donri> @quote Jafet abstract
01:35:52 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
01:35:52 <lambdabot> s, phone apps, and web services.
01:36:00 <quchen> I could have sworn there was "obscure" in there.
01:36:17 <donri> abstract :)
01:36:19 <bergmark> :> that explains the truncating
01:36:30 <c_wraith> Cale: feel like bumping up lambdabot's max line length so that doesn't truncate?
01:37:05 <quchen> Why does it have a max line length (this short) anyway
01:37:18 <donri> quchen: because IRC does
01:37:26 <quchen> donri: Oh.
01:37:27 <donri> and it's unpredictable
01:37:30 <c_wraith> well, the irc server doesn't notify you when it truncates one of your messages
01:37:36 <c_wraith> So it pays to be conservative
01:37:44 <Cale> That's 200 characters
01:37:45 <c_wraith> But maybe not *that* conservative
01:37:45 <Ralith> the IRC server does, however, announce its maximum line length
01:37:59 <quchen> Wait, so when I type something and it's truncated my client has no way of knowing?
01:38:01 <Ralith> so you don't need to be conservative.
01:38:11 <donri> 512 bytes per command including the CRLF and the channel name plus it has to be 512 bytes still when it's sent to clients including the origin IRC address
01:38:55 <Cale> quchen: that's right
01:39:11 <quchen> Oh 1980s
01:39:19 * Ralith runs an irssi script that takes advantage of this to nicely and optimally break long messages apart with ellipses
01:39:25 <donri> yeah, another great thing about the IRC protocol: you don't get your own messages sent back
01:39:53 <donri> Ralith: i don't think that'll work in every case
01:40:03 <Ralith> donri: it works fine.
01:40:34 <Ralith> perhaps there exist servers that truncate lines without announcing this fact, but I have never seen one
01:40:42 <donri> Ralith: IIRC the server names are even included when broadcasting a message over the network... do you account for all these things?
01:40:54 <Cale> I seem to recall there being some unpredictable portion of the line which is not part of your message that needs to be accounted for?
01:41:02 <donri> exactly
01:42:18 <Ralith> donri: ah, I haven't thought much on the server-server parts of the protocol.
01:42:19 <donri> also you need to measure bytes not characters, which depends on the encoding, and also means your ellipsis varies in byte length
01:42:42 <Ralith> perhaps freenode allows for this in its line length announcement
01:42:56 <Ralith> all I know is that I've never seen nor heard of the script failing
01:43:03 <shachaf> Cale: Did you get my message about the quotes file?
01:43:04 <donri> perhaps. i think they have a bunch of spec uncompliant extensions and work arounds
01:43:19 <Ralith> idk about uncompliant
01:43:34 <Ralith> the IRC spec is not terribly constraining
01:43:49 <donri> i remember it saying specifically exactly 512 bytes
01:43:54 <donri> but i could be misremembering :)
01:43:56 <Cale> shachaf: Maybe? No?
01:44:16 <shachaf> Cale: I sent it via @ask at one point.
01:44:25 <Ralith> donri: it does, iirc.
01:44:36 <shachaf> I wanted to take whatever the latest version of the quotes file that you have is and scan through the logs to add all the missing quotes that were @remembered in #haskell.
01:44:45 <Cale> okay
01:44:55 <donri> you used lambdabot's database to communicate backups for lambdabot's frail database?
01:45:09 <Cale> donri: ?
01:45:17 <Ralith> donri: I meant that networks making a maximum length announcement might incorporate knowledge of the server names.
01:45:19 <donri> shachaf: chrisdone made an export based on his ircbrowse db
01:45:38 <shachaf> donri: Yes, but lambdabot has a lot of quotes that weren't @remembered in this channel.
01:45:49 <shachaf> Some of those are probably gone forever. So it goes.
01:45:53 <donri> aha
01:47:55 <donri> Cale: well the quotes db got lost didn't it? and i've added the same @where thing like 5 times :)
01:48:12 * hackagebot family-tree 0.4.1.0 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.4.1.0 (NathanVanDoorn)
01:48:13 <donri> but we all love lambdabot anyway
01:48:40 <Cale> I don't know, lambdabot's storage seems incredibly unreliable, and it sometimes just zeroes out files without warning
01:48:49 <Cale> I have no idea why
01:49:09 <shachaf> I think publishing the latest lambdabot State somewhere public regularly would be a good thing.
01:49:20 <shachaf> Well, I guess @tell is part of the lambdabot state...
01:49:52 <Cale> I think maybe someone fixing the way that lambdabot stores state would also be good :P
01:50:06 <quchen> I think Lambdabot's quotes that haven't been @quote-d in the IRC logs are probably forgotten not only in the "it's not in the db" sense.
01:50:15 <shachaf> There are many changes that lambdabot could use.
01:50:22 <shachaf> I don't think fixing the state is even the highest-priority one.
01:50:23 <Cale> Yeah
01:54:43 <yezariaely> slightly OT: Anyone knows of a scientific publication where the advantages/disadvantages of untyped/dynamically typed languages are described and investigated which are often named? (rapid prototyping, lot of testing and such …)
01:55:35 <donri> yezariaely: http://evanfarrer.blogspot.ca/2012/06/unit-testing-isnt-enough-you-need.html
01:55:52 <donri> duno about "scientific"
01:56:21 <donri> oh it links a paper at the bottom
01:56:37 <hiptobecubic> yezariaely, I think you'll have trouble finding a peer reviewed paper about what is essentially a religious war :)
01:57:18 <yezariaely> hiptobecubic: well that is exactly my question ;-) is it a religious war or can the advantage in certain situations be proven ;-)
01:57:58 <donri> brb
02:01:04 <yezariaely> donri: thx. The thesis linked at the bottom might be worth a look.
02:01:35 <yezariaely> though it seems to be slightly off focus.
02:02:17 <donri> ah yeah i misread your question
02:02:21 <donri> somewhat relevant though
02:03:02 <ari> Where's lambdabot's Expr defined again? I tried to @info it but that wasn't very informative...
02:03:13 <ari> > a + b -- what lets you do this, that is
02:03:14 <lambdabot>   a + b
02:03:37 <quicksilver> package called numbers I think
02:03:54 <quicksilver> nope, that is CReal
02:03:56 * quicksilver tries again
02:04:01 <quchen> ari: SimpleReflect
02:04:08 <quicksilver> simple-reflect
02:04:20 <quicksilver> http://hackage.haskell.org/package/simple-reflect-0.3.1
02:04:32 <ari> quchen, quicksilver: ty
02:04:54 <quchen> donri: Thanks for the link to the blog post above, seems interesting!
02:35:24 <dncr> Best way to parse heterogenous JSON data?  It's a list (sometimes of lists.. (etc.)) of integers.  E.g. "[1, [2]]".
02:36:12 <Kinnison> use a JSON parser?
02:36:22 <donri> dncr: see the aeson package
02:36:29 <donri> it defines a sum type of the json types
02:37:03 <quchen> Sum type as in "big Either"?
02:37:18 <dncr> Ah
02:37:29 <dncr> Ae.decode (BSLC.pack "[1, [2]]") :: Maybe [Ae.Value]
02:37:46 <dncr> donri: thank you
02:38:47 <dncr> or more recursion friendly just to go to :: Maybe Ae.Value
02:48:37 <quchen> Is there some easy way of converting a ThreadId to an Int?
02:48:47 <quchen> ... or some other integer type at least
02:50:41 <bitonic> jaspervdj: I added this regarding what we talked about yesterday <https://github.com/jaspervdj/hakyll/issues/130>.  I’d do it myself if I had more familiarity with hakyll (which probably will be the case in a bit...)
02:51:26 <kartoffelbrei> quchen: Why do you want that? Besides the only way  can think of is to (ab)use read and show.
02:53:09 <quchen> kartoffelbrei: Right now I basically want to write a nicer way to print it. But beyond that I could imagine it being useful too, e.g. as a RNG seed maybe
02:53:34 <quchen> Provided you want your deterministic RNG to be more deterministic :-)
02:54:26 <bitonic> quchen: you can hack a ThreadId -> Int from the Show instances.  the methods that convert to a CInt are not exported
02:56:14 <quchen> bitonic: That's so hacky I'd rather not convert to Int at all ;-)
02:56:25 <bitonic> quchen: which is probably the better idea to begin with.
02:56:35 <quchen> Reminds me of http://new-hackage.haskell.org/package/acme-php
03:02:23 <kartoffelbrei> that's gruesome
03:03:56 <arkeet> haha, notElem
03:05:15 <arkeet> cos x = sin (x + 90)
03:05:18 <arkeet> my sides.
03:08:46 <quchen> foldl makes me sad.
03:09:19 <quchen> I remember wondering why that's not the way it's defined in the standard, as it is much clearer when I saw it for the first time in LYAH.
03:09:32 <quchen> foldl' is also glorious in the PHP file :-)
03:11:11 <arkeet> quchen: yep
03:11:31 <jaspervdj> bitonic: thanks for creating the issue, I'm gone skating for the whole day but I'll have a look at it tonight :-)
03:12:08 <bitonic> jaspervdj: OK, I’m also having trouble with something else—it seems that after I processed the Agda file I need to re-store it and re-load it to get rid of the metadata, right?
03:14:32 <nh2> what does this mean? Unacceptable result type in foreign declaration: IO CInt
03:15:04 <nh2> most people seem to fix this by importing CInt(..) (with constructors), but I have that already and still get that error
03:15:08 <dmos> is there an easier way to get this: partition' = (,) <$> id <*> drop 1
03:15:12 <bitonic> nh2: hpaste please
03:16:11 <jaspervdj> bitonic: could you mail me about this? I have to go now
03:16:14 <dmos> the effect is the same as: take 2 . tails but as a tuple instead of a list
03:16:18 <bitonic> jaspervdj: sure, thanks
03:16:23 <nh2> bitonic: 1 sec
03:16:50 <nh2> jaspervdj: I'm in Sg now by the way ;)
03:18:22 * hackagebot named-records 0.3.2 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.3.2 (JulianFleischer)
03:20:20 <jaspervdj> nh2: awesome :-D
03:24:30 <bitonic> jaspervdj: you’ve got mail, have fun ehe
03:39:44 <haskell_noob> anyone wanna try this out? http://hpaste.org/85009
03:43:11 <jMCg> I have a build that starts off with cabal-dev clean, then cabal-dev configure and cabal-dev install - the configure step tells me it's missing a bunch of deps: http://apaste.info/hCyT -- how do I make sure they are installed (when running from a Jenkins buildbot)
03:45:54 <nh2> bitonic: garbage, I can't make a minimal example - it works there
03:46:11 <nh2> looks like I have some CInt imported without constructors, but I haven't figured out where yet
03:46:21 <bitonic> nh2: annoying.  I don’t have any guesses.  as you probably know you have to import the constructors since... recently
03:52:32 <nh2> bitonic: ahhh it was the damn hs file not reflecting my changes in the hsc file
03:53:10 <bitonic> nh2: with ‘not reflecting’ you mean that you weren’t processing the .hsc file :P?
03:53:19 <nh2> yes
03:53:24 <bitonic> ehe.  use cabal son.
03:53:54 <nh2> I'm using ghc-mod / hdevtools
03:54:11 <nh2> it's a bit weird
03:54:22 <bitonic> ghc-mod + hsc + cabal should work
03:54:26 <bitonic> I think
03:54:30 <nh2> I don't have the cabal part
03:54:39 <nh2> before it was complaining and it seemed that it couldn't do it with hsc
03:54:46 <nh2> so I generated all .hs from .hsc
03:54:53 <bitonic> well yeah cabal does that part for you
03:55:05 <bitonic> (don’t know what hdevtools is)
03:55:39 <nh2> the same thing as ghc-mod, but as a daemon and 50 times faster
03:55:59 <nh2> now I remove the compiled hs files and it doesn't complain any more, weird
03:56:08 <bitonic> yeah ghc-mod has a bit of a delay
03:58:23 <nh2> gotta go
03:58:26 <nh2> see you in a bit
04:25:39 <alexander__b> I don't really get this: groupBy (\x y -> (x > 0) == (y > 0)) [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3] -- the lambda takes two things, but only a list is passed to it
04:25:51 <alexander__b> what is x and what is y?
04:26:09 <nooodl> @type groupBy
04:26:10 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
04:27:46 <alexander__b> nooodl: I'm sure this is obvious to people who know haskell, but it doesn't become more clear for me by showing me the type definition of groupBy.
04:27:55 <typoclass> > group "Mississipppppi"
04:27:56 <lambdabot>   ["M","i","ss","i","ss","i","ppppp","i"]
04:28:07 <typoclass> alexander__b: it's not *that* obvious
04:28:22 <nooodl> oh yeah i was going to explain it further but i forgot
04:28:42 <quchen> alexander__b: The first parameter of groupBy takes a binary function of the type "when to consider two things equal".
04:28:46 <nooodl> group = groupBy (==)
04:29:00 <typoclass> alexander__b: so, this ^^ is how group works. it groups by using (==), which is a function (a -> a -> Bool). groupBy is similar, but you can pass in your own function to determine what to group by
04:29:17 <quchen> In your case, "\x y -> (x>0) == (y>0)" is a function that considers x and y equal iff they have the same sign.
04:29:31 <alexander__b> yes, but what I'm asking is what is x and what is y?
04:29:59 <quchen> Lambda parameters. Are you familiar with lambda notation?
04:30:06 <alexander__b> when I read " (\x y -> (x > 0) == (y > 0)) [0..10]", I read -- oh a lambda function that takes two parameters. and... one parameter is sent to it.
04:30:18 <typoclass> alexander__b: groupBy will call your function (your lambda) repeatedly with two elements of the list
04:30:18 <alexander__b> quchen: yes. but I probably forgot it from not having the opportunity to look at haskell for a few days now.
04:30:24 <alexander__b> right.
04:30:34 <alexander__b> I'm not sure I understand why it is implicit that it takes two arguments from the list.
04:30:43 <quchen> You're misreading it. groupBy f list = (groupBy f) list, not groupBy (f list)
04:31:00 <quchen> The lambda isn't applied directly to the list.
04:31:14 <typoclass> alexander__b: don't worry :-) in "groupBy (\x y -> ...) [...]", you have two arguments being passed to a function called groupBy. the second argument is a list, the first argument is a function of 2 arguments
04:31:17 <latermuse> quchen: that lambda is just for checking if both x and y are positive. correct?
04:31:26 <merijn> latermuse: Yeah
04:31:40 <quchen> latermuse: No, it checks whether both are simultaneously positive or not positive.
04:31:44 <latermuse> yes
04:31:51 <quchen> latermuse: for example, for -1 and -1, the lambda will be True.
04:31:57 <latermuse> oh neat
04:32:09 <alexander__b> typoclass: thanks.
04:32:11 <quchen> > (\x y -> (x > 0) == (y > 0) (-1) (-1)
04:32:13 <lambdabot>   <hint>:1:38: parse error (possibly incorrect indentation)
04:32:14 <quchen> > (\x y -> (x > 0) == (y > 0) (1) (-1)
04:32:16 <lambdabot>   <hint>:1:37: parse error (possibly incorrect indentation)
04:32:21 <quchen> > (\x y -> (x > 0) == (y > 0)) (-1) (-1)
04:32:22 <lambdabot>   True
04:32:23 <quchen> > (\x y -> (x > 0) == (y > 0)) (1) (-1)
04:32:25 <lambdabot>   False
04:32:26 <quchen> > (\x y -> (x > 0) == (y > 0)) (1) (1)
04:32:27 <lambdabot>   True
04:32:43 <typoclass> i'd call it "neat" with scare quotes. it's a bit nonobvious if you're not used to boolean logic fiddling
04:33:09 <latermuse> yeah, ive never seen boolean used like that before. its pretty neat though
04:33:12 <typoclass> it's more or less using (==) as a xor operator
04:33:23 <quchen> :t (==) `on` (>0)
04:33:25 <lambdabot> (Num a, Ord a) => a -> a -> Bool
04:33:49 <quchen> (I'm still looking for a non-"comparing" case where 'on' makes things more readable.)
04:36:03 <killy9999> I just realized I don't understand one fundamental thing about Vectors
04:36:12 <killy9999> what is an unboxed Vector?
04:36:23 <killy9999> I mean what exactly is "unboxed" in it?
04:36:36 <merijn> The vector elements
04:36:53 <killy9999> merijn: So let's say I have: Vector Int
04:37:04 <killy9999> the Vector stores Int or Int# ?
04:37:12 <killy9999> s/the/this/
04:37:26 <quchen> Boxed things contain Haskell values; a Haskell value is a box that may have a value in it, or another Haskell value (Thunk), or Bottom, or unicorns. On the other hand, an unboxed value contains exactly its value.
04:37:41 <shachaf> What?
04:38:02 <quchen> Oh crap, shachaf intervenes, that's a bad sign
04:38:12 <typoclass> > groupBy (\a b -> signum a == signum b) [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3] -- i wonder if this makes it clearer. uses signum from the Num typeclass
04:38:14 <lambdabot>   [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
04:38:16 <quchen> Eh, I meant "howdy shachaf, time to learn something for me!" ;-)
04:38:19 <alexander__b> quchen: looking at 'on' now, which is supposed to be very readable. I think it looks quite hideous.
04:38:33 <shachaf> killy9999: Vector Int is an array of pointers to heap-allocated values.
04:38:52 <quchen> alexander__b: On is usually awful. The only case it makes sense is when you pair it with "compare" really.
04:39:05 <shachaf> An unboxed Vector is an array of integer values directly in memory. Like int a[n]; in C.
04:39:06 <typoclass> alexander__b: um, 'on' is a little bit of a tricky one with a specific use case :-) not sure where you heard it's readable
04:39:10 <quchen> alexander__b: e.g. "comparing `on` snd" compares tuples based on their second value
04:39:13 <thirsteh> what am I looking for if I want to build a [bar] from an arbitrary Foo where data Foo { bar :: Bar, childFoos :: [Foo] } ?
04:39:29 <quchen> Eh, "compare `on` snd" it is
04:39:31 <alexander__b> typoclass: «An even clearer way to write equality functions for the By functions is if you import the on function from Data.Function.»
04:39:52 <quchen> alexander__b: Yeah, ignore that. ;-)
04:39:53 <alexander__b> «groupBy ((==) `on` (> 0)) values [...], Very readable indeed!»
04:40:08 <killy9999> shachaf: then why is it called "Unboxed" ?
04:40:20 <jMCg> Okay, can someone help me out what's missing here: http://apaste.info/1422 ? when I run cabal-dev configure it says here's the dependencies that are missing, but when I cabal-dev install-deps it can't find any -- how is that consistent?
04:40:40 <killy9999> if it contains pointers to heap objects then I would call that "boxed"
04:40:47 <typoclass> alexander__b: that's debatable. i have my doubts about that quote
04:40:56 <alexander__b> typoclass: it's from learn you a haskell
04:41:11 <shachaf> killy9999: Yes, that's a boxed vector.
04:41:17 <merijn> tbh I think the version with on is more readable than the lambda
04:41:28 <merijn> It's a matter of taste, I guess?
04:41:48 <killy9999> shachaf: but I can declare "Vector Int" for Vector imported from Unboxed module
04:41:48 <latermuse> jMCg: have you tried manually installing dependencies?
04:41:50 <thirsteh> I'm guessing something from lenses :)
04:41:57 <shachaf> killy9999: OK, you didn't specify which Vector.
04:41:58 <killy9999> what do I get then?
04:42:04 <shachaf> Yes, that's an unboxed vector.
04:42:15 <shachaf> You'll have an array of contiguous machine integers in memory.
04:42:19 <killy9999> and the elements from it are unboxed, that is Int# ?
04:42:54 <shachaf> Sort of, yes.
04:43:02 <jMCg> latermuse: yesno. The problem is that this is running on a buildbot. I want this to be automated.
04:43:14 <shachaf> Well, it's possible to implement an unboxed vector thing without every talking about Int# directly. But it's the same idea.
04:43:16 <killy9999> sort of?
04:43:26 <killy9999> hm
04:43:40 <killy9999> you see, I just realized that something is strange when I wrote this code:
04:43:43 <hpaste> killy9999 pasted “Unboxed vectors?” at http://hpaste.org/85034
04:43:46 <typoclass> alexander__b: 'on' comes from the observation that sometimes, you have stuff like "\a b -> aTwoArgumentFunction (something a) (something b)". in these cases, if you want to avoid writing the same "something" twice, they made the shortcut called 'on'
04:43:51 <killy9999> take a look at line 4
04:44:01 <shachaf> killy9999: You probably shouldn't be worrying about Int# yourself.
04:44:02 <onlydnaq> hi, I've been trying to work through olegs finally tagless lecture notes, and I'm running into some problems
04:44:15 <alexander__b> typoclass: I see.
04:44:18 <killy9999> on that line I explicitly unbox an element of the vector, which already should be unboxed!
04:44:18 <shachaf> The fact that it's an unboxed vector doesn't mean that you have to pass Int#s to anything.
04:44:48 <typoclass> alexander__b: so it's fairly specific to this case. but it's somewhat handy, particularly if the "something" is a long complicated expression, and you want to be clear that both times it's exactly the same
04:44:49 <killy9999> let's say I *want* to play with Int# ;)
04:44:54 <shachaf> OK.
04:44:55 <typoclass> @type on
04:44:56 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
04:44:58 <shachaf> Then go for it.
04:45:09 <shachaf> It has little to do with the unboxed vector.
04:45:14 <shachaf> These are two different boxings.
04:45:28 <killy9999> I'm  lost
04:45:31 <alexander__b> BTW they thing I'm having the most trouble not puking over is still reading type signatures.
04:45:38 <killy9999> I *think* I undestand boxing of Int
04:45:41 <shachaf> OK.
04:45:46 <killy9999> but I'm lost about the Vector
04:45:47 <shachaf> Why is you "*want* to play with Int#"?
04:45:52 <alexander__b> s/they/the
04:46:09 <typoclass> alexander__b: ok :-) then let's get the bucket for any emergencies, and maybe we can step through on's signature for exercise
04:46:37 <alexander__b> typoclass: I get them once I sit down and read them. but just glancing over them makes my brain hate me.
04:46:41 <typoclass> alexander__b: if you look at the type, start on the right-hand side with "a -> a -> c". this means it produces something (c), and gets two things of the same type (a)
04:46:52 <killy9999> shachaf: to get efficient assembly and later figure out how to implement a fusion method that will produce such an assembly without the user worrying about using Int#
04:46:54 <typoclass> alexander__b: i think that's true for everyone
04:47:09 <quchen> alexander__b: The type signature of "on" is much more readable when you think about what the function does. It's not as straight forward as filter's for example, where you can almost immediately see what the function does.
04:47:10 <yezariaely> I'd like to map a function on all elements of a tuple. Is this somehow possible? fmap show (1,2) didn't work.
04:47:15 <yezariaely> > fmap show (1,2)
04:47:17 <lambdabot>   (1,"2")
04:47:27 <quchen> yezariaely: uncurry
04:47:28 <yezariaely> hmm
04:47:31 <shachaf> killy9999: Do you know about things like CPR analysis?
04:47:32 <quchen> Oh wait no
04:47:32 <yezariaely> ah sure...
04:47:32 <shachaf> @where cpr
04:47:32 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
04:47:33 <yezariaely> thx
04:47:37 <yezariaely> hmm
04:47:39 <onlydnaq> yezariaely: try both from Control.Arrow
04:47:48 <typoclass> alexander__b: the next element is a function (a -> b). so we can assume that 'on' applies this function on the two 'a' arguments we're giving it. does it make sense so far?
04:47:52 <quchen> yezariaely: Mapping over both elements of a tuple is a little tricky type-wise.
04:47:54 <shachaf> Anyway: These are two unrelated boxings.
04:47:57 <thoughtpolice> killy9999: roughly speaking, Vector pretty much works by using type families (and other things) to specialize particular instances of 'Vector a', for some type 'a'. although a vector may be in memory a contiguous array of integers
04:48:14 <thoughtpolice> foldM' doesn't give you back the unboxed version, it gives you the boxed version (which you can see from looking at the type signature)
04:48:18 <alexander__b> typoclass: yes.
04:48:29 <quchen> yezariaely: If the tuple contains two elements of the same type it's straightforward though.
04:48:37 <killy9999> shachaf: I know there is a paper about CPR for Haskel but I haven't read it yet
04:48:48 <yezariaely> quchen: type is different. Otherwise I just apply show twice.
04:49:00 <yezariaely> my Control.Arrow has no both.
04:49:05 <thoughtpolice> killy9999: in your example, you're not unboxing something already unboxed. foldM' specifically reboxes Int# to Int and gives it back to you
04:49:13 <quchen> both is a lens thing isn't it
04:49:14 <alexander__b> typoclass: well not really because gwargh. it takes two 'a's, then the function is a and operates on a b
04:49:29 <onlydnaq> yezariaely: sorry, forgot the name of it, you're right, it isn't in Control.Arrow
04:49:40 <alexander__b> typoclass: oh right no. now I get it.
04:49:50 <alexander__b> typoclass: I misremembered. too many days without haskell. :-)
04:49:57 <killy9999> thoughtpolice: so despite the type signature "Vector Int", the vector really contains Int#s that are reboxed when needed?
04:50:22 <shachaf> Int# is a concept that exists at a different level from unboxed vectors.
04:50:45 <shachaf> You could have unboxed vectors and use them with Ints, or boxed vectors and use them with Int#s.
04:50:49 <typoclass> alexander__b: ok, so the final (left-most) element in the signature is another function (b -> b -> c). it gets passed the two 'b' arguments that we got because we applied the other function twice, to the two 'a' values. what it produces is c, aka the final result of the whole thing
04:50:58 <yezariaely> @ty both
04:50:59 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
04:51:08 <shachaf> An Int# most likely exists in a register, not in memory anywhere. :-)
04:51:09 <yezariaely> > both show (1,2)
04:51:11 <thoughtpolice> well, technically not due to the fact unboxed types have a different kind
04:51:11 <lambdabot>   [('1','2')]
04:51:18 <killy9999> shachaf: so is the boxed vector something like a list?
04:51:25 <yezariaely> > both show (1,2,3)
04:51:27 <lambdabot>   Couldn't match expected type `(a0, a0)'
04:51:27 <lambdabot>              with actual type `(t0,...
04:51:36 <yezariaely> > both show (1,2)
04:51:37 <typoclass> yezariaely: i think you can either use lens, or you can write your own 'both' function
04:51:37 <lambdabot>   [('1','2')]
04:51:41 <shachaf> But the representation of an unboxed vector of Ints is going to be something like "int foo[100];" in C.
04:51:42 <alexander__b> typoclass: it's also a bit confusing reading it from the right.
04:51:44 <yezariaely> why does it return a list?!
04:52:19 <yezariaely> @ty both show (1,2)
04:52:20 <lambdabot> [(Char, Char)]
04:52:35 <shachaf> The representation of a boxed vector of Ints is going to be closer to "struct haskell_int_value_thing *foo[100];"
04:52:56 <shachaf> (Well, maybe closer to haskell_value_thing *, or void *. It doesn't need to know the type.)
04:53:10 <killy9999> looks like I need to read more about Vectors...
04:53:19 <thoughtpolice> killy9999: yes, it will be boxed. but the point shachaf is making is that you don't really *know* about it. the boxing/unboxing is irrelevant, because the Vector interface doesn't *require* you to represent Int as an Int#
04:53:45 <onlydnaq> yezariaely: join (***) (+1) (2, 3)
04:53:55 <thoughtpolice> when you have a 'Vector Int', it's likely a contiguous array of raw integers. but that's not a detail the interface exposes
04:53:55 <typoclass> alexander__b: yeah. you could also look at (b -> b -> c), and then check "where else is a 'b'". i found it clearest to look at it starting at the two 'a' values
04:54:12 <shachaf> "Data.Vector.Unboxed.Vector Int", that is.
04:54:18 <thoughtpolice> yeah
04:54:22 <shachaf> "Data.Vector.Vector Int" is an array of pointers.
04:54:31 <typoclass> alexander__b: to sum up, 'on' is one of the more tricky ones. it takes some figuring out. luckily, there is always #haskell :-)
04:54:38 <shachaf> Note: I've never actually used Vector. Everything I'm saying is a guess.
04:54:39 <thoughtpolice> killy9999: the idea is that fusion, inlining and CPR will basically boil all that stuff down and allow GHC to 'really unbox' things like Int to Int#, later in the compilation stage. hence why it's a relevant optimization
04:54:49 <alexander__b> typoclass: hehe thanks.
04:54:56 <killy9999> thoughtpolice: I'd like to get below interface
04:55:10 <thoughtpolice> killy9999: and that's why it doesn't matter that foldM gives you an Int, and not an Int# - GHC just takes care of it later
04:55:10 <killy9999> I'm interested with stuff happening under the hood
04:55:26 <onlydnaq> killy9999: do you need an interface for Int#, or do you think you need an interface for Int#
04:55:35 <shachaf> OK, then read the source of Vector, read the source of GHC, read the output of ghc-core.
04:55:51 <onlydnaq> killy9999: before you try to optimize, you should look at the generated core, to see if GHC unboxes what you want it to
04:57:01 <killy9999> onlydnaq: I'm basically looking at the assembly
04:57:10 <thoughtpolice> killy9999: i'd recommend reading about stream fusion papers in this case, since they're obviously relevant. CPR analysis is also important here (and in other libraries like bytestring too, of course.) you don't necessarily need to go looking at GHC, but it might help
04:57:20 <thoughtpolice> really most of the important machinery modulo CPR doesn't exist in GHC
04:57:26 <onlydnaq> killy9999: before looking at the assembly, try to look at the generated core
04:57:33 <shachaf> killy9999: If you really want to understand what's going on, you probably shouldn't start with the assembly.
04:57:34 <onlydnaq> killy9999: ghc -O2 -ddump-simpl
04:57:38 <shachaf> You'll miss the forest for the trees, etc.
04:57:45 <shachaf> Read the Core, read the Cmm.
04:57:49 <shachaf> Read the papers (CPR etc.)
04:57:56 <thoughtpolice> yes, having core and C-- is crucial to being able to see what's going on
04:58:09 <killy9999> no, I meant I went through the core level and now I'm looking at the assembly
04:58:24 <shachaf> The Cmm has pretty much all the information in the assembly other than machine-specific details, and also a lot more information about why things are done.
04:58:26 <thoughtpolice> Cmm is probably still a bit better honestly
04:58:31 <killy9999> as for the papers: I haven't read the one about CPR, but I have it printed so will take a look tomorrow
04:58:31 <thoughtpolice> it has much more rich info
04:58:33 <quchen> yezariaely: Here's a working version of "show both tuple elements", but it's far from being pretty: http://hpaste.org/85035
04:58:34 <shachaf> More than a bit better.
04:58:45 <thoughtpolice> fair :)
04:58:53 * hackagebot warp 1.3.8 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.8 (MichaelSnoyman)
04:59:06 <thoughtpolice> i can't even remember the last time I looked at GHC-generated assembly
04:59:13 <thoughtpolice> since i normally just stare at C--
04:59:32 <killy9999> thoughtpolice: what would you recommend to read in order to understand Cmm ?
04:59:35 <thoughtpolice> (the fact I was staring at assembly from the runtime a week ago doesn't count obviously)
04:59:36 <shachaf> I look at it a lot -- or I did when I was optimizing Haskell things -- but only for specific things.
04:59:45 <killy9999> I mean I understand it more or less, because it's something between C and assembly
04:59:47 <onlydnaq> sorry to repeat myself btw, but is anyone familiar with olegs finally tagless paper?
04:59:57 <shachaf> killy9999: The RTS commentary on the GHC wiki has a guide, I think.
05:00:06 <thoughtpolice> the commentary is now out of date :|
05:00:08 * killy9999 checks
05:00:14 <thoughtpolice> since it covers old cmm, which has been eradicated
05:00:19 <thoughtpolice> but most of the same stuff still applies, really
05:00:22 <shachaf> The commentary is always out of date.
05:00:24 <thoughtpolice> just not the data types in the commentary
05:00:30 <shachaf> It's out of date the day after it's written.
05:01:08 <thoughtpolice> in [C[Csome cases, no! the debugging guides are all still useful, and nobody has seriously edited those pages for quite a while :P
05:01:18 <shachaf> Oh, it's very useful.
05:01:21 <shachaf> Just out of date.
05:01:38 <thoughtpolice> really? all that GDB goodness still works pretty well for me :)
05:01:49 <killy9999> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
05:01:57 <elliott> thoughtpolice: [C[Csome cases, indeed
05:01:58 <killy9999> I suppose you meant this page?
05:01:59 <shachaf> In my experience there is very little GHC documentation that isn't subtly inconsistent with reality.
05:02:13 <killy9999> that has been my experience also...
05:02:24 <thoughtpolice> the reality is that GHC has a lot of documentation. and lots of documentation is a pain in the ass to maintain
05:02:35 <shachaf> I agree.
05:03:05 <thoughtpolice> i'm not really sure how to deal with this, but it's been on my mind recently to try and help people get into GHC hacking, since there's been a surge of interest over the past few months
05:03:25 <shachaf> Can you help get me into GHC hacking by implementing all the things I want in GHC for me?
05:03:28 <thoughtpolice> (some of it presumably spurred by JaffaCake leaving MSR, i imagine)
05:03:35 <thoughtpolice> shachaf: :|
05:03:45 <shachaf> Oh well. Worth a try.
05:03:49 <thoughtpolice> will you fix every lens bug?
05:03:54 <shachaf> THERE ARE NO LENS BUGS
05:03:56 <typoclass> i'd guess that big-picture overview documentation doesn't get out of date so quickly?
05:03:56 <killy9999> who is JaffaCake IRL?
05:04:01 <thoughtpolice> killy9999: simon marlow
05:04:02 <shachaf> Simon Marlow.
05:04:06 <killy9999> ah, ok
05:04:09 <shachaf> I should implement that simple GHC extension I proposed.
05:04:16 <killy9999> didn't know that was his nickname :)
05:04:21 <shachaf> #7633
05:04:27 <thoughtpolice> killy9999: he's mostly in #ghc
05:04:30 <shachaf> By "I" I mean thoughtpolice.
05:04:42 <killy9999> anyway, I started hacking on GHC somewhere in December
05:04:48 <thoughtpolice> shachaf: :|
05:04:55 <alpounet> ghc plugins should also help writing some optimizations
05:05:00 <typoclass> can i please have a ghc extension that turns (doodle _ _ abc) into (\x y -> doodle x y abc)
05:05:01 <killy9999> and I must say that commentary is extremely helpful, even if outdated
05:05:03 <typoclass> :-)
05:05:12 <alpounet> like the strict haskell one
05:05:12 <thoughtpolice> the GHC plugin architecture is woefully simplistic right now however.
05:05:22 <thoughtpolice> i've been meaning to get back to working on it and extending it to be more useful
05:05:27 <thoughtpolice> alpounet: yeah, i maintain it :)
05:05:29 <mauke> typoclass: insufficient spec
05:05:55 <alpounet> thoughtpolice, I know! i keep pointing people to it, it's not well advertised :p
05:06:39 <thoughtpolice> i'm not really sure why. it was mostly a demo by Max like 5 years ago to just show a trivial pass. i'm not actually convinced it's very useful at this point
05:07:01 <thoughtpolice> that's really why i maintained it, it's about as simple as it gets since it just transforms non-recursive let bindings into cases
05:07:07 <typoclass> shachaf: hey, that #7633 is a great idea
05:07:13 <shachaf> Max Bolingbroke?
05:07:20 <thoughtpolice> the one and only!
05:07:21 <shachaf> imo thoughtpolice should get him onto irc
05:07:31 <alpounet> he comes, every now and then
05:07:37 <alpounet> 'batterseapower' I think
05:07:39 <thoughtpolice> shachaf: unlikely. he was on hiatus for several months to write his thesis
05:07:43 <shachaf> preflex: seen batterseapower
05:07:44 <preflex>  Sorry, I haven't seen batterseapower
05:07:44 <ramses_> yezariaely: try "join (***)" if you really want to
05:07:44 <thoughtpolice> and now he's working in finance
05:07:53 <alpounet> only on #ghc
05:07:54 <thoughtpolice> and we all know how -that- goes :P
05:07:58 <ramses_> > (join (***)) (+3) (4,5)
05:07:59 <lambdabot>   (7,8)
05:08:07 <thoughtpolice> although he is still actively hacking GHC. but he's never been much of an IRCer
05:08:08 <alpounet> thoughtpolice, oh he is in finance now?
05:08:13 <thoughtpolice> i just talk to him through twitter these days
05:08:19 <quchen> ramses_: join will only work on tuples of the same type
05:08:27 <thoughtpolice> alpounet: yes, that's the impression i got. i'm not sure if it's standard chartered or somewhere else
05:08:44 <alpounet> hah ok, surprising
05:08:46 <ramses_> quchen: you can only map a function over both components of a tuple if they are the same type
05:08:53 * hackagebot http-reverse-proxy 0.1.1.4 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.1.4 (MichaelSnoyman)
05:09:00 <quchen> ramses_: unless Rank2, yes
05:09:06 <merijn> I campaigned for "both = join (***)" in Control.Arrow on libraries@ but I was denied :(
05:09:20 <quchen> ramses_: He basically had a heterogeneous tuple and wanted to map show over both elements
05:09:26 <typoclass> merijn: urgh. why? sounds handy
05:09:43 <ramses_> quchen: ah, missed that :)
05:09:57 <quchen> Speaking of mailing list denies, what's the usual policy when you propose something and nobody cares? :-S
05:10:12 <merijn> typoclass: Not enough people supported the idea and shachaf and edwardk complained that I should just use both from Control.Lens :<
05:10:18 <quchen> Let it die without notice? Write a new mail after the discussion period is over saying "nobody cared"?
05:10:22 <thoughtpolice> quchen: you bring it back up again, and ask for feedback.
05:10:30 <thoughtpolice> or at least, that's what i would do.
05:10:34 <typoclass> merijn: hm ok
05:10:48 <merijn> But both from lens only works on functions :(
05:10:50 <merijn> :t both
05:10:51 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
05:11:17 <thoughtpolice> shachaf: i do like this bug report!
05:11:34 <thoughtpolice> but unfortunately if i implement it, that means i'll just be reinforcing the idea i'll fix all your GHC woes :(
05:12:23 <elliott> merijn: thankfully nobody uses any other Arrow instances
05:12:40 <elliott> also both works with Kleisli! well, ApplicativeKleisli.
05:12:47 <typoclass> one of these days, i'll check out ghc HEAD and bumble around in the code like an elephant in the china shop
05:13:23 <typoclass> merijn: how do you mean 'only on functions'?
05:13:25 <thoughtpolice> killy9999: oh! and if you want to understand C-- and some of the things the optimizations are doing, i'd perhaps recommend checking out SPJ's Hoopl paper
05:13:44 <merijn> typoclass: join (***) works on any arrow!
05:14:22 <typoclass> merijn: mm ok :-/ i don't know any arrows except (->)
05:14:32 <merijn> Wire!
05:14:52 <quchen> Wire?
05:15:05 <merijn> @hackage netwire
05:15:05 <lambdabot> http://hackage.haskell.org/package/netwire
05:15:15 <shachaf> thoughtpolice: Which one?
05:15:20 <thoughtpolice> shachaf: #7633
05:15:22 <killy9999> thoughtpolice: Thanks, I will
05:15:24 <quchen> Oh, FRP, I'm out ;-(
05:15:26 <shachaf> Oh, the feature request.
05:15:40 <ramses_> quchen: even if I define a both which takes (forall b. b -> c) as the first parameter, you cannot do "both show" since there is no Show constraint :s
05:15:44 <thoughtpolice> killy9999: http://research.microsoft.com/en-us/um/people/simonpj/papers/c--/hoopl-haskell10.pdf
05:15:48 <shachaf> Yes, it's kind of ridiculous that GHC can't catch this error right now.
05:15:58 <quchen> ramses_: http://hpaste.org/85035
05:16:01 <thoughtpolice> killy9999: the paper is more concerned with hoopl than C--, but it'll give you some insight into how the backend is structured
05:16:08 <thoughtpolice> which should help you when you dig into the source a bit
05:16:26 <ramses_> quchen: that's what I'm saying, you need that Show constriant
05:16:27 <thoughtpolice> (well, in a vague "I know what this type does" sort of way, which is often OK :)
05:16:49 <quchen> ramses_: Ah, that's what you meant. Well, yes.
05:17:07 <ramses_> quchen: you should have a different function for every possible combination of constraints with that approach
05:17:15 <quchen> ramses_: In any case it's not very pretty. first show . second show may be a better solution I guess.
05:17:40 <killy9999> thoughtpolice: it happens that I also have the Hoopl paper printed and waiting to be read :)
05:17:48 <killy9999> I guess I will be busy tomorrow with reading...
05:18:34 <ramses_> quchen: yeah, but then the "join (***)" as a combinator gives the same power without repeating the function :)
05:18:49 <quchen> ramses_: No
05:18:53 <quchen> :t join (***)
05:18:54 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
05:19:16 <quchen> Maps (b,b) to (c,c), not (a,b) to (c,c)
05:19:36 <quchen> The "show" in "first show . second show" are different :-)
05:19:48 <quchen> Combining them needs the forall business
05:19:52 <ramses_> quchen: can you write a combinator that does that while parametrising the function to be mapped?
05:20:10 <ramses_> yeah, but that's because you specialise for show
05:20:22 <quchen> "You" as in "quchen"? No. "You" as in "edwardk"? Probably.
05:20:46 * quchen plays canned laughter
05:23:39 <quchen> ramses_: Yeah, my Monte-Carlo-based approach to writing something like this failed
05:25:25 <`cc`> http://jaspervdj.be/websockets/ is a good choice for a  websocket server?
05:25:45 <ramses_> quchen: hehe :) Is there a generator for random well-typed functions then?
05:25:53 <alpounet> `cc`, yes
05:26:10 <`cc`> thx
05:26:19 <`cc`> my other question
05:26:30 <quchen> ramses_: Yes. Create string, feed to GHC, if error then loop. Biased random coding. :-)
05:26:36 <Rembane> ^^
05:27:41 <`cc`> I'm using a (managed) c++ TCP library, how would people here integrate it to haskell (in my case simple websocket server)
05:28:39 <`cc`> it mightt be hard, since the library has event handlers
05:28:48 <ramses_> quchen: that will converge terribly slow..
05:29:08 <quchen> ramses_: that *will converge* terribly slow
05:29:11 <quchen> :-P
05:29:17 <`cc`> the easy way is to make a standalone c++ application tht send udp/tcp messages to haskell
05:29:57 <ramses_> quchen: true, from a theoretic perspective you're fine :)
05:30:01 <`cc`> but if a sort of rpc is possible it could be better
05:30:45 <typoclass> `cc`: a managed c++ tcp library? how do you mean?
05:31:31 <`cc`> http://stackoverflow.com/questions/114238/difference-between-managed-c-and-c
05:31:38 <shachaf> Does "managed" mean .NET?
05:31:49 <`cc`> a crap invented by microsoft
05:31:50 <shachaf> Looks like it does.
05:32:09 <shachaf> Well, you'll have to do it by communicating with .NET, then.
05:32:14 <shachaf> There's probably no simpe direct FFI.
05:32:24 <`cc`> FFI?
05:32:32 <grr> foreign function interface
05:32:47 <shachaf> Oh, and of course "manage C++" is different from "C++/CLI"
05:32:48 <typoclass> `cc`: the ffi is the way that haskell talks to c
05:32:49 <shachaf> d
05:32:52 <shachaf> You're using the former?
05:34:05 <grr> I am looking for a name for `f` in, essentially, `f (x:xs) p = zipWith p (x:xs) xs` (so p would be called with each element and its successor element) Any ideas?
05:34:39 <grr> only thing I've come up with so far is "pairwise", and that doesn't sound very appropriate
05:34:46 <shachaf> @quote zip`ap`tail
05:34:47 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:35:08 <shachaf> > (zipWith (+) <*> tail) [1,2,3,4]
05:35:09 <lambdabot>   [3,5,7]
05:35:15 <byorgey> shachaf beat me to it
05:35:32 <typoclass> grr: pairwise doesn't sound half-bad to me
05:36:42 <grr> Does not convey that the numbers are consecutive in the list
05:37:08 <shachaf> Note that "drop 1" may be slightly preferable to "tail".
05:37:12 <typoclass> grr: neighbors, map2, mapAdj, mapAdjacent, mapBy, mapConsecutives, successive
05:37:32 <quchen> grr: All elements in a list are consecutive.
05:37:43 <quchen> Their values need not be. ;-)
05:37:47 <grr> Well, immediately
05:38:09 <shachaf> quchen: Perhaps you should read again.
05:38:48 <quchen> Did. What now?
05:38:53 <grr> typoclass, yeah, that's the direction... looking at google results for 'zip ap tail' now...
05:39:18 <shachaf> zip`ap`tail is a joke
05:39:35 <shachaf> It's zipWith f l (tail l)
05:39:44 <shachaf> Which you can write as (zipWith f <*> tail), if you like.
05:39:54 <shachaf> (And ap = (<*>).)
05:39:58 <grr> Yeah but references to it come with name suggestions, like http://stackoverflow.com/questions/2546524/how-do-you-write-the-function-pairs-in-haskell calls it "pairs"
05:40:16 <quchen> shachaf: yes, I understand that, but why read again?
05:40:34 <quchen> It's hard to not see something is a joke when it involves gods
05:40:51 <shachaf> quchen: That was directed at grr.
05:41:07 <grr> http://stackoverflow.com/questions/3774247/what-do-we-call-this-new-higher-order-function calls it "pleat"
05:42:04 <shachaf> quchen: What I meant is that "All elements in a list are consecutive." "Their values need not be. ;-)" is both pedantic and irrelevant/wrong, if you want me to clarify.
05:43:07 <shachaf> The question was: foo [a,b,c,d] = [f a b, f b c, f c d]; how do I indicate with the name that only elements that are right next to each other are passed to f?
05:43:07 <quchen> Note the smiley. Talk about being pedantic
05:43:20 <mm_freak> can i make :t expand type aliases?
05:43:23 <shachaf> Anyway I'm getting mean or something so I should go to sleep.
05:43:44 <shachaf> mm_freak: I don't know of a way. But you can use :kind!.
05:44:09 <mm_freak> thanks
05:44:10 <thoughtpolice> which is only in HEAD :)
05:44:17 <shachaf> No, it's in 7.6
05:44:18 <thoughtpolice> (if i remember correctly, anyway)
05:44:22 <mm_freak> can i make a scoped type operator infixr?
05:44:37 <shachaf> Scoped type operator?
05:44:37 <thoughtpolice> hm, clearly i've been spending too much time with HEAD. i can't even remember what's old anymore
05:44:41 <mm_freak> type MyType to = X `to` Y `to` Z
05:45:05 <shachaf> Ah. I don't know of a way.
05:45:12 <mm_freak> too bad
05:45:23 <grr> http://stackoverflow.com/a/3774787 also has `pairwise` ... `meld` wouldn't be that bad
05:46:56 <typoclass> grr: i think my favorite would be map2, to indicate it's dealing with 2-tuples
05:47:14 <typoclass> ... or er, uncurried ones. you know what i mean :-)
05:49:02 <arkeet> @quote zip`ap`tail
05:49:02 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:49:06 <grr> map2 seems to be popular for various purposes
05:49:14 <arkeet> oh, someone else did it.
06:02:59 <alexander__b> filter (not . any isSpace) ["this"," ","is"," ","a"," ","test"," ","with"," ","spaces"] -- TOO MANY FUNCTIONS. can someone step me through this in the correct order?\
06:03:30 <alexander__b> the full thing was filter (not . any isSpace) . groupBy (on (==) isSpace) $ "this is a test with spaces" -- for the record.
06:03:43 <shachaf> Which part don't you know?
06:04:02 <shachaf> Take that part out, replace it with a simpler part. Study it in isolation.
06:04:13 <alexander__b> what happens first. what gets sent where.
06:04:34 <mauke> filter happens first
06:04:53 <`cc`> FFI is like Java JNI?
06:05:04 <typoclass> `cc`: yeah, more or less
06:05:24 <typoclass> alexander__b: don't worry :-) so, isSpace is clear, right?
06:05:28 <typoclass> > isSpace 'L'
06:05:29 <`cc`> I'm pretty sure it will fail for .NET C++, but will try
06:05:29 <lambdabot>   False
06:05:32 <typoclass> @type isSpace
06:05:34 <lambdabot> Char -> Bool
06:05:46 <alexander__b> typoclass: yes. and any takes a function that takes something and gives a bool, and a list eventually gives a bool. isSpace is the procedure sent to any.
06:06:23 <alexander__b> not takes a bool and returns a bool. it gets the result from any, I guess. filter filters based on the result from not.
06:06:55 <alexander__b> I could add "I think" to everything I'm saying here, but choose not to for brevity's sake. please don't think I think I know what I'm talking about. ;-)
06:08:08 <shachaf> The great part about this is that you can figure out each part on its own.
06:08:19 <shachaf> What's filter BLAH ["this","is",...]?
06:08:26 <shachaf> What's (not . any isSpace)?
06:08:40 <mauke> > filter even [1 .. 10]
06:08:41 <lambdabot>   [2,4,6,8,10]
06:08:50 <shachaf> If you don't know (not . any isSpace), figure out the individual parts: not, any, isSpace, (.)
06:08:53 <typoclass> alexander__b: you're guessing pretty well. (we say function instead of procedure, but that's no big deal.) so, "any isSpace ['a', 'x',' ']" runs the function on each of the list's elements
06:09:01 <typoclass> alexander__b: make sense?
06:09:05 <mauke> > filter (\x -> length x > 3) ["this", "is", "not", "sparta"]
06:09:06 <lambdabot>   ["this","sparta"]
06:09:09 <alexander__b> typoclass: right. yes.
06:09:49 <shachaf> (.) is the most important part of (not . any isSpace), if your goal is to learn to read Haskell programs.
06:10:01 <typoclass> alexander__b: good. so as you guessed, this produces a Bool, which is then given into 'not', which just negates it
06:10:12 <shachaf> So find out what it means. First off, this is parsed as (not . (any isSpace))
06:10:15 <shachaf> @src (.)
06:10:16 <lambdabot> (f . g) x = f (g x)
06:10:16 <lambdabot> NB: In lambdabot,  (.) = fmap
06:10:29 <shachaf> OK, I'm just messing everything up.
06:10:31 <typoclass> alexander__b: (.) is similar to a pipe in the shell: "cat | grep" is similar to "grep . cat" in haskell
06:10:33 * shachaf goes.
06:12:02 <alexander__b> typoclass: I'm just confused over the list of strings I guess. because I've usually used filter on a list like [2,3,6,5,8,77] -- not ["foo", "bar"] -- which is [['f', 'o','o'],['b','a','r']], right?
06:12:08 <grr> `cc`, if you are looking for a way to use .NET APIs from Haskell, there are some things like http://haskell.forkio.com/dotnet
06:12:20 <typoclass> alexander__b: yes exactly, it's a [String], a list of Strings
06:12:52 <typoclass> alexander__b: this means, "filter f" will repeatedly call function f with one String
06:13:02 <alexander__b> typoclass: so it's the use of any that threw me off, being used to using filter to operate on one char/num/whatever at the time, not a list of lists.
06:13:10 <South> alexander__b: Filter will filter strings, not chars, since that's what the list contains one level in
06:13:27 <alexander__b> South: yes.
06:14:20 <typoclass> alexander__b: yup. "filter f" passes one element of the list into f, expecting that f will give back True or False. here, one element is one String
06:15:00 <alexander__b> which is syntax sugar for a list of chars. I guess the slew of functions made me blind to how isSpace could possibly operate on a list instead of a char, but it's because of any.
06:15:14 <`cc`> grr, thx, the other problem is how to do the notion of event handler in haskell, things like qc->OnDisconnect+=gcnew DisconnectEventHandler(this,&Main::deconnexion); and the callback ;)
06:15:22 <typoclass> alexander__b: yup, exactly :-)
06:15:23 <alexander__b> I just have to get used to reading a bunch of functions and understanding which way what is going.
06:15:30 <typoclass> > isSpace "lolcat" -- gives an error
06:15:32 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:15:32 <lambdabot>              with actual type...
06:15:37 <typoclass> > any isSpace "lolcat" -- works
06:15:38 <lambdabot>   False
06:16:09 <typoclass> alexander__b: so it can be confusing at the first glance, but usually you can work through it
06:16:18 <South> alexander__b: It usually helps me when I'm confused to look up all of the type signatures in composed functions to see what each thing is doing
06:16:37 <alexander__b> typoclass: it's kind of when I was learning dvorak. if I had to not use it for a few days, it was a big setback.
06:16:49 <`cc`> for all this, I think I'll run a standalone C++ .net shit, that sends udp (presumably faster than tcp)
06:17:02 <alexander__b> South: I did that this time, which was why I figured out a big chunk of it. my main confusion was just wtf was going where, what function happened first, etc.
06:17:23 <grr> `cc`, the problem there is probably more the += than the delegate
06:17:25 <South> alexander__b: Cool! :)
06:18:20 <typoclass> alexander__b: right, but i bet the time to re-learn stuff after the setback is much less than the time you needed to learn it initially
06:18:50 <alexander__b> typoclass: of course. if not, I would probably have either hanged myself or stopped haskell long time ago. and also never switched to dvorak. ;-)
06:19:09 <`cc`> grr,  yes the += would have to be converted to pure c++
06:25:38 <typoclass> `cc`: i'm curious, why do you need this other managed c++ tcp library, and not the regular one available in haskell?
06:27:25 <`cc`> I'm using a Metatrader library written for .NET
06:28:54 <yezariaely> is there a predefined uncurry3 function?
06:30:16 <merijn> I don't think so? but it's trivial to make a lambda for it
06:30:27 <ab9rf> @src uncurry
06:30:27 <lambdabot> uncurry f p = f (fst p) (snd p)
06:30:51 <merijn> :t \f (x, y, z) -> f x y z
06:30:53 <lambdabot> (t1 -> t2 -> t3 -> t) -> (t1, t2, t3) -> t
06:30:55 <yezariaely> just wondering. Otherwise I will change my fundef
06:30:59 <`cc`> typoclass,  reading market quotations from it, and would like to manage them in a haskell websocket server
06:31:02 <yezariaely> thx
06:31:47 <ab9rf> @pl \f (x,y,z) -> f x y z
06:31:48 <lambdabot> (line 1, column 9):
06:31:48 <lambdabot> unexpected "z"
06:31:48 <lambdabot> ambiguous use of a non associative operator
06:32:31 <ab9rf> huh
06:33:26 <geekosaur>  @pl isn't real smart about tuples
06:33:40 <ab9rf> it would seem so ;)
06:33:51 <geekosaur> it knows what to do with 2-tuples, but anything larger it gets confused
06:34:06 <`cc`> doing 1 program in c++ that send a big bunch of events (by udp let's say) to my haskell program, seems to be a good idea not too slow, I think?
06:34:52 <ab9rf> i can't say i approve of C++
06:35:17 <`cc`> hehe, no choice unfortunately
06:35:32 <ab9rf> there are always choices :)
06:35:56 <`cc`> it's a proprietary library, not really possible to reverseengineer
06:37:11 <ousado> I wouldn't use udp if I wanted a reliable transport
06:37:23 <ab9rf> yeah, i don't know why you'd want to use udp
06:37:27 <ab9rf> why not just use the FFI?
06:37:54 <ab9rf> or if you really want them in different processes, a shared memory segment or a unix-domain socket?
06:39:04 * hackagebot names 0.3.1 - Type level names.  http://hackage.haskell.org/package/names-0.3.1 (JulianFleischer)
06:45:20 <`cc`> ab9rf, yes hmm on windows, and how would you write such code http://hpaste.org/85038 with FFIs
06:54:05 * hackagebot named-records 0.3.3 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.3.3 (JulianFleischer)
06:54:20 <hpaste> circle pasted “why” at http://hpaste.org/85039
06:54:35 <circle> that was an example given from my book ^
06:54:40 <circle> I tried it, and it gives an error
06:54:48 <circle> I copied it exactly from the book.
06:54:57 <mauke> what exactly did you do, and what happened?
06:55:04 <finnrobi> can I write a pointfree version of this function? zipWith (
06:55:08 <typoclass> circle: could you click 'annotate' in the paste and add the error messag?
06:55:09 <finnrobi> err, premature return!
06:55:24 <typoclass> circle: sometimes books are a little outdated, but it's usually easy to fix
06:55:38 <circle> typoclass: " Couldn't match type `Char' with `(a0, String)'
06:55:38 <circle> "
06:55:52 <mauke> circle: what's the full error message?
06:55:52 <hpaste> circle annotated “why” with “why (annotation)” at http://hpaste.org/85039#a85040
06:56:08 <finnrobi> can I write a pointfree version of this function? zipWith (\x y -> head $ drop x y) [0..] ?
06:56:26 <mauke> circle: return', not return
06:56:39 <circle> aHH
06:56:42 <circle> damn I' am indiot
06:56:43 <circle> thank you
06:56:44 <mauke> @pl zipWith (\x y -> head $ drop x y) [0..]
06:56:45 <lambdabot> zipWith ((head .) . drop) [0..]
06:56:58 <finnrobi> ah
06:56:58 <ab9rf> yes, you can do that :)
06:56:59 <typoclass> circle: don't worry :-) sometimes the easiest things are the hardest to see
06:57:03 <circle> appreciated
06:57:13 <mauke> @pl zipWith (\x y -> y !! x) [0..]
06:57:14 <lambdabot> zipWith (flip (!!)) [0..]
07:05:15 <nicoo> > zipWith (flip (!!)) [0..] [0..]
07:05:17 <lambdabot>   No instances for (GHC.Enum.Enum [c0], GHC.Num.Num [c0])
07:05:17 <lambdabot>    arising from a u...
07:05:38 <nicoo> :t zipWith (flip (!!)) [0..]
07:05:40 <lambdabot> [[c]] -> [c]
07:11:37 <merijn> How do I stop cabal from deleting tmp files? I'm getting a compile error from a C file in my tmp folder, but when cabal finishes that file no longer exists so I can't inspect it
07:13:16 <typoclass> merijn: ctrl-z?
07:13:22 <merijn> ...
07:13:46 <merijn> And I should just guess when to stop hit hoping for sheer luck to kick in?
07:14:21 <mauke> is it possible to tell cabal which C compiler to use?
07:15:02 <typoclass> merijn: i admit it's not perfect :-) i was thinking in terms of 'try the easiest thing first'
07:15:03 <merijn> I would hope it just uses CC?
07:16:06 <merijn> typoclass: I'm trying to figure out which the unix package is breaking on "undeclared typedefs" when compiling under cygwin when all the header files are in fact just fine. Having to guess when to hit ctrl-z is likely to put me in a murderous rage, so I hope you have a more useful suggestion...
07:17:28 <timthelion> merijn: you have to hit Ctrl-z because cmd.exe doesn't keep scroll history going back that far?
07:17:59 <merijn> timthelion: No, cabal is deleting the temp C files that are erroring on compile
07:18:16 <merijn> I was asking how to stop it from doing that, so I can try to debug wtf is going on
07:18:22 <typoclass> merijn: do you do 'cabal install' or 'cabal unpack' + 'build'? i'd expect that with unpack, it'd keep more of the stuff in dist/
07:18:27 <timthelion> merijn: there is some cabal option to only generate temp files and not continue.
07:18:43 <merijn> I don't even get past cabal configure, because it fails with a "Bad header file HsUnix.h"
07:18:53 <merijn> timthelion: Probably, I was asking what it was
07:19:03 <Vq> Mount a version controlled filesystem at /tmp
07:19:12 <Vq> :o)
07:19:16 <timthelion> Vq: he's under cygwin
07:19:17 <merijn> Vq: Right...on windows...
07:19:40 <Vq> cyg...win... ?
07:19:40 <timthelion> Vq: there are version controlled file systems?
07:19:44 <typoclass> (i do think unpack was the way i used to check the contents of of what hsc2hs was outputting)
07:19:53 <merijn> Somehow the HsUnix.h file is thinking some stuff isn't defined properly, whereas my inspection of the system headers shows they're clearly fine :\
07:20:11 <Vq> timthelion: Yeah, but I wouldn't seriously recommend using them for /tmp
07:20:21 <ab9rf> heh
07:20:54 <mauke> merijn: if you could tell it what to use as a C compiler, you wouldn't need a special option
07:21:21 <merijn> mauke: Why not? I don't expect it's the C compiler that's deleting .c files from tmp...
07:21:46 <mauke> you can just tell it to use a script that copies its input files somewhere safe
07:21:54 <mauke> then maybe calls the real copmiler
07:22:08 <timthelion> merijn: well, what tmp folder is created by ghc or cygwin to hold the files. Are you sure they aren't in dist/
07:23:26 <typoclass> merijn: so, you do cabal configure, and it exits with an error? afaict, cbits/HsUnix.c is included in the package, and include/HsUnix.h is created during cabal configure
07:23:35 <Vq> Since it's on Windows the Ctrl-Z approach isn't actually as far fetched as I first thought.
07:23:49 <Vq> You probably has a relatively large window to hit. :)
07:24:00 <merijn> typoclass: THe header exists, it's just claiming some typedefs aren't defined when they are used
07:24:06 <timthelion> Vq: s/has/have/
07:24:15 <merijn> I want to run gcc with -E to manually inspect what's going on
07:24:24 <merijn> Yay, debugging header file includes \o/
07:24:33 <Vq> timthelion: Realised that as I wrote it, thanks though.
07:24:57 <merijn> It's claiming some system stuff like __ino64_t and id_t are not defined in the system headers, even though they are and are included
07:25:20 <typoclass> merijn: oh i see. so you're doing "cabal configure --with-gcc=-E", and cabal deletes gcc's output file?
07:26:14 <merijn> No, because then autoconf crashes because gcc can't succesfully compile C files
07:26:21 <timthelion> Clearly this file deletion is a sign that we should all use imutable file systems!
07:26:32 <merijn> I just want it to stop deleting shit after it fails to configure :(
07:26:54 <timthelion> merijn: how do you know things are being deleted? is dist/ empty?
07:27:06 <Vq> rm rm
07:27:14 <timthelion> Vq: :D
07:27:33 <timthelion> Vq: that should be # rm /bin/rm
07:27:58 <Vq> timthelion: I know :)
07:28:14 <Vq> timthelion: cabal probably uses the Haskell system API though.
07:28:21 <merijn> timthelion: dist doesn't contain anything beyond setup-config
07:28:44 <merijn> I know it's deleting shit because I see compile errors (I'm running configure with -v3) for files in tmp which aren't there when I look
07:29:41 <geekosaur> um
07:29:51 <geekosaur> configure creates a lot of temp files and removes them after
07:30:11 <geekosaur> config.log often contains the text of a failing configure test program
07:30:19 <timthelion> merijn: and what does the same command with -v=3 give you?
07:30:37 <geekosaur> (that'a ssuming it's configure based but that would not surprise me)
07:31:05 <timthelion> merijn: oops, sorry. I didn't read your message about using -v3 because I was reading cabal help configure
07:31:06 <typoclass> merijn: i don't know. check config.log. about 3-4 files (e.g. confdefs.h) are present when i hit ctrl-z during the million "checking ..." lines. they are absent when i let cabal finish
07:31:21 <geekosaur> see what I just said
07:31:26 <geekosaur> confdefs.h is created by configure scripts
07:31:33 <geekosaur> autoconf configure, not cabal configure
07:32:13 <merijn> The configure errors *after* autoconf finishes
07:32:41 <geekosaur> yet you are looking for files that were created by autoconf-style configure
07:32:53 <geekosaur> confdefs.h is not created, read, managed, or deleted by cabal
07:33:14 <merijn> Who mentioned confdefs.h?
07:33:20 <mauke> geekosaur
07:33:23 <typoclass> merijn: i did
07:33:33 <geekosaur> [02 10:30] <typoclass> merijn: i don't know. check config.log. about 3-4 files (e.g. confdefs.h) are present when i hit ctrl-z during the million "checking ..." lines. they are absent when i let cabal finish
07:34:01 <typoclass> merijn: anyway, it'd help if you could hpaste cabal's output and the contents config.log
07:34:33 <timthelion> typoclass: he's working on a top secret government project and can't.
07:34:56 <hpaste> test pasted “test” at http://hpaste.org/85042
07:35:59 <hpaste> merijn pasted “cabal configure output” at http://hpaste.org/85043
07:36:52 <hpaste> merijn pasted “config.log” at http://hpaste.org/85044
07:39:40 <quchen> There's no "hFlush" in ByteString. Is that because the regular hFlush is sufficient, or because of ByteString's design?
07:40:00 <quchen> (I'm guessing the first case)
07:42:32 <timthelion> merijn: is the configure file generated by autoconf?
07:43:11 <merijn> yes, cabal just calls autoconf
07:43:15 <geekosaur> quchen, hFlush has to do with GHC's I/O buffers, it has nothing to do with where the data in the buffer came from
07:43:42 <merijn> mauke: I'm trying the "replace CC with a bash script that copies the files" approach now, so far that seems the most useful suggestion, thanks
07:43:45 <timthelion> merijn: I would write a program that runs "sh" with it's arguments, and then copies the folder "include" to some place.  Then I would replace cygwin's sh with my hacked sh ;)
07:44:17 <timthelion> merijn: why is it that I say things right after they are said by you?
07:44:38 <merijn> Except that apparently GHC on windows is hardcoded to use the mingw gcc that ships with platform...
07:44:46 <merijn> Which would probably explain my problem
07:44:48 <typoclass> merijn: ok, have you tried running "gcc -E include/HsUnix.h"? i guess you need various -I options for that, but those are listed in http://hpaste.org/85043 , e.g. line 372
07:45:15 <timthelion> typoclass: if he had the include folder ;)
07:45:55 <typoclass> timthelion: as far as i understood, he has include/HsUnix.h, it's just that it refuses to compile
07:46:09 * ion waves back at jfischoff
07:46:24 <jfischoff> :)
07:46:25 <quchen> geekosaur: Makes sense, thanks.
07:47:47 * merijn stabs everything related to C programming
07:47:49 <merijn> )@&%(&(&%(&
07:48:31 <typoclass> i wonder what monstrosity this mysterious Cygwin/usr/include/sys/resource.h file contains in its mysterious line 76
07:48:33 <merijn> GHC calls it's own fucking mingw copy of gcc. Guess what! That copy doesn't define the __CYGWIN__ value that the cygwin headers need to work with the unix header
07:49:04 <timthelion> merijn: I feel your pain.
07:49:08 <typoclass> merijn: yes, ghc has its own gcc for some reason or another
07:49:14 <merijn> Right, now that that is figured out...
07:49:23 <merijn> How do I tell cabal/ghc to use another gcc?
07:49:27 <timthelion> merijn: but please do file a bug report about this.
07:49:28 <mapf> that is faster: Data.Serialize.Put or Data.ByteString.Builder?
07:49:35 <Eduard_Munteanu> merijn: mingw is lighter and nicer than cygwin in a few ways, why cygwin?
07:49:48 <merijn> Eduard_Munteanu: Because I'm trying to compile the unix package?
07:49:49 <timthelion> -w --with-compiler=PATH           give the path to a particular compiler
07:49:56 <timthelion> merijn: -w
07:50:39 <merijn> I figured that was the flag to specify the haskell compiler to use?
07:50:41 <timthelion> merijn: why are you trying to develop on windows at all?
07:50:44 <Eduard_Munteanu> I suspect you want a Cygwin build of the Haskell Platform then. But yeah, this piece of advice is useless. :)
07:51:01 <merijn> timthelion: I'm developing on OSX, but I need this stuff to run on Windows too, eventually
07:51:22 <typoclass> sure, why not install debian? oh, something doesn't work. why not install arch linux? oh, a bunch of things don't work. why not install fedora? ...
07:51:27 <timthelion> merijn: but we already have various flags for the haskell compilers. I don't know, you are probably right :(
07:51:34 <merijn> Eduard_Munteanu: There's a cygwin build of Haskell Platform?
07:51:43 <Eduard_Munteanu> merijn: I don't think so. :)
07:51:58 <merijn> Getting my hopes up for nothing :(
07:52:07 <Eduard_Munteanu> But theoretically that's the Right solution. :P
07:52:51 <timthelion> merijn:     --with-PROG=PATH               give the path to PROG
07:52:55 <Eduard_Munteanu> merijn: I would recommend skipping Cygwin and reimplementing the unix-specific bits, Cygwin is a rather big gun here.
07:53:02 <timthelion> merijn: The flags --with-PROG and --PROG-option(s) can be used with the following programs: alex ar c2hs cpphs ffihugs gcc ghc ghc-pkg greencard haddock happy hmake hpc hsc2hs hscolour hugs jhc ld lhc lhc-pkg nhc98 pkg-config ranlib strip tar uhc
07:53:14 <timthelion> merijn: gcc is in that list
07:53:33 <Eduard_Munteanu> And AFAIK, Cygwin lags quite a bit, assuming they still maintain it properly..
07:53:41 <merijn> Eduard_Munteanu: Reimplementing the unix-specific bits would mean "reimplement a substantial number of libraries that depend on unix"
07:54:18 <timthelion> merijn: reimplement unix then :)
07:54:26 <timthelion> merijn: the package that is...
07:54:26 <Eduard_Munteanu> ^^
07:54:34 <Eduard_Munteanu> That, or add Windows support to it.
07:54:51 <geekosaur> unix-compat?
07:54:53 <timthelion> ^^
07:55:31 <Eduard_Munteanu> Anyway, it kinda sucks depending on Cygwin.
07:56:06 <timthelion> merijn: but I think --with-PROG is what you want...
07:57:01 <merijn> "which gcc" -> "/usr/bin/gcc", 'Cannot find the program 'gcc' at '/usr/bin/gcc' or on the path' :(
07:57:10 <merijn> timthelion: Yeah, but apparently that doesn't work either :\
07:57:22 <timthelion> merijn: sorry :(
07:57:42 <timthelion> merijn: then use unix-compat...
07:58:22 <thoughtpolice> there hasn't been a cygwin build of GHC in a very long time
07:58:55 <thoughtpolice> mostly because the majority of people would rather use a 'native' compiler, a la mingw
07:59:04 <merijn> unix-compat only has some filesystem stuff in it, afaict
07:59:46 <thoughtpolice> of course, once you get to packages that both A) work on windows and B) need ./configure scripts, it's a bit painful to set up. i should really set up a windows GHC build machine
08:00:16 <thoughtpolice> (network is what i'm thinking of in particular, in this case)
08:00:30 * timthelion wonders how long it will take before android replaces Windows.
08:01:41 <Clint> microsoft would post record profits
08:01:56 <timthelion> Clint: why?
08:02:09 <Clint> because they make tons off of android patent licensing
08:02:30 <roshan> Hi! Does anyone know if Gabriel Gonzalez (the author of www.haskellforall.com) is in this channel?
08:03:20 <thoughtpolice> Tekmo is around sometimes, yes
08:03:23 <thoughtpolice> preflex: seen Tekmo
08:03:23 <preflex>  Tekmo was last seen on #haskell-lens 3 days, 19 hours, 29 minutes and 49 seconds ago, saying: I didn't need this after all
08:03:41 <timthelion> He's certainly on /r/haskell
08:03:50 <roshan> Ah, I didn't know Tekmo and he were one and the same :) Thanks
08:06:26 <merijn> Ah, of course GHC can't find cygwin paths, twiddling the path lets it find gcc, but it's still failing, so back to debugging we go...
08:07:10 <armlesshobo> merijn: what issues are you facing?
08:10:29 <typoclass> armlesshobo: check tunes.org (see topic), he described it in some detail. this is his cabal output http://hpaste.org/85043
08:11:35 <armlesshobo> typoclass: ah ok. thanks :)
08:19:25 <troydm> hey functional ppl! i just tried hitting http://comonad.com when OpenDNS suddenly blocked it saying 'Phishing Site Blocked'
08:19:35 <troydm> what in the world is going on?
08:19:58 <Kinnison> OpenDNS is wrong
08:20:09 <byorgey> edwardk is a notorious phisher
08:20:28 <byorgey> he phishes for phunctional programmers
08:20:29 <sleepynate> troydm: or perhaps you have a virus of some kind? :)
08:20:53 <troydm> sleepynate: no viruses, i use OpenDNS as my DNS service
08:21:08 <byorgey> clearly, OpenDNS has an axe to grind against functional programming
08:21:36 <typoclass> troydm: is there a way to alert opendns about a site that is wrongly labeled? or to check why they labeled it as phishing?
08:22:04 <troydm> typoclass: no idea, i'm writing them a message now
08:22:12 <troydm> asking why they labeled that site so
08:22:59 <troydm> i hope i'll get an answer from them
08:24:07 <merijn> armlesshobo: The issue I'm facing is that I'm trying to compile the unix package under cygwin. First it was using the gcc that ships with Haskell Platform, so that was failing with cryptic include errors. Now I changed it to use the gcc cygwin, but now it suddenly can't find the libraries it needs anymore, even though I don't get any errors from gcc when I run with -v3
08:28:06 <merijn> Is there like a -v4 for when -v3 isn't verbose enough? :(
08:29:18 <typoclass> merijn: have you copied the failing gcc command out of cabal's output and run it yourself? with some verbose switches added or some such
08:29:44 <jdnavarro> I'm installing an executable `cabal install --enable-library-profiling --enable-executable-profiling` but when I run it with +RTS -p, it says profiling is not enabled...
08:30:18 <merijn> I'm not even sure if it's failing, there's no errors
08:30:48 <merijn> and copying the gcc command means manually having to edit out a lot of the cabal logging gunk, like quotes, angle brackets and comma's...
08:30:57 <merijn> I'm giving up for today, I can't be arsed...
08:31:19 <Eduard_Munteanu> merijn: I would try other suggestions like unix-compat
08:31:44 <geekosaur> someone already mentioned it is apparently limited to paths and not other parts of the unix package
08:32:25 <typoclass> merijn: then i suspect it isn't failing. in your earlier cabal output, there was stuff like "the following command failed ... the error message was ..."
08:37:14 <danr> jdnavarro: did you install its dependencies with profiling?
08:37:29 <jdnavarro> danr, yeah
08:37:32 <jdnavarro> it's now working
08:37:50 <jdnavarro> I had to pass ghc-options=-prof
08:38:06 <alexander__b> findKey :: (Eq k) => k -> [(k,v)] -> v
08:38:08 <alexander__b> findKey key xs = snd . head . filter (\(k,v) -> key == k) $ xs
08:38:29 <alexander__b> how would I make this not produce an error when it fails?
08:38:30 <danr> jdnavarro: ok, nice
08:38:45 <danr> alexander__b: return a maybe or a default v
08:38:58 <alexander__b> danr: a "maybe" was my first gut feeling.
08:39:00 <danr> @hoogle find
08:39:01 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:39:01 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
08:39:01 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
08:39:14 <danr> actually, lookup is the function you're looking for
08:39:18 <danr> @hoogle lookup
08:39:18 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
08:39:18 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
08:39:18 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
08:39:44 <danr> anyway, the right thing to do is to search for the type in hoogle :)
08:42:00 <ab9rf> Data.Hashtable is wrapped in IO?
08:42:13 <elliott> try Data.Map or Data.HashMap (from unordered-containers)
08:44:27 <alexander__b> danr: scrolling down a few posts I saw the example I just implemented myself, heh.
08:44:32 <alexander__b> s/posts/paragraphs
08:46:33 <dmwit> alexander__b: Just for fun, you should consider also the possibility of returning [v].
08:46:49 <dmwit> as in findKey key xs = [v | (k, v) <- xs, k == key]
08:48:20 <merijn> typoclass: I know, which is why I'm so confused by it concluding "the following libraries are missing and this header file doesn't work", as it seems to report 0 errors
08:50:07 <alexander__b> dmwit: I see.
08:50:14 <alexander__b> dmwit: good idea.
08:54:13 * hackagebot clckwrks-theme-geo-bootstrap 0.1.0 - geo bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-geo-bootstrap-0.1.0 (JeremyShaw)
08:59:13 * hackagebot free-functors 0.2 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.2 (SjoerdVisscher)
09:00:47 <klrr> SRY FOR MY BEHAVIOR LAST NIGHT
09:00:54 <klrr> (wont happen again)
09:04:12 <dmwit> Great! Welcome back. =)
09:04:54 <dange3rdeye> http://www.youtube.com/watch?v=gqj7NSNC224
09:05:41 <elliott> dange3rdeye: spam is off-topic
09:05:56 <dange3rdeye> what if the topic is spam?
09:06:00 <elliott> this channel is about the haskell programming language
09:09:13 * hackagebot clckwrks-theme-geo-bootstrap 0.1.1 - geo bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-geo-bootstrap-0.1.1 (JeremyShaw)
09:18:31 <nicoo> .wg #kerlann
09:19:23 <monsieurlu> hi everyone! I'd like to know if I do something like -> head (my_function xs) + 1 ++ tail (my_function xs)
09:19:49 <monsieurlu> does my_function is call twice ?
09:19:55 <geekosaur> yes
09:20:03 <geekosaur> use a let binding if you want it called only once
09:20:25 <monsieurlu> thanks :)
09:20:45 <monoidal> also you probably wanted head (my function xs) : 1 : tail (my_function xs)
09:21:03 <monoidal> umm (head (my function xs) + 1) : tail (my_function xs)
09:24:16 <ion> Avoid head and tail.
09:25:00 <ion> case myFunction xs of (y:ys) -> (y+1):ys; [] -> something
09:26:22 <klrr> what's the advantages of dynamic type system?
09:26:40 <dmwit> This topic has been covered extensively on the web.
09:26:51 <dmwit> No need to discuss it yet again in-channel.
09:28:18 <liyang> klrr: I think this Google Tech Talk explains it pretty well: http://www.youtube.com/watch?v=Ktbhw0v186Q --- it's a bit long though
09:28:28 <Eduard_Munteanu> klrr: presumably checks that are difficult to do at compile-time, but it's hardly an advantage if you move *all* checks to runtime, like they usually do.
09:29:50 <hiptobecubic> liyang, it's a bit long, no?
09:30:01 <liyang> hiptobecubic: what I said...
09:30:26 <liyang> Save it for when you have a few hours to spare.
09:30:32 <hiptobecubic> liyang, oh oops:)  Just happened to be on a line break
09:38:27 <klrr> "Personally, I think that those who would give up type safety to purchase a little temporary liberty, deserve neither liberty nor type safety" :D
09:38:31 <klrr> found it on stack overflow
09:38:44 <klrr> btw, what is "stack overflow"? (i dont mean the site)
09:38:55 <Eduard_Munteanu> Nice.
09:39:15 <augur> is there a haskell type setting library?
09:39:26 <augur> maybe one that outputs latex?
09:39:43 <Eduard_Munteanu> klrr: overflowing stack-allocated storage, e.g. a local array
09:40:18 <hiptobecubic> augur, why would you want that?
09:40:23 <Eduard_Munteanu> augur: I think you can use 'listing' from Latex
09:40:47 <hiptobecubic> Oh you mean to present haskell source? Not to create latex documents from haskell?
09:40:52 <augur> hiptobecubic: because latex fucking sucks for anything more complicated
09:41:00 <Eduard_Munteanu> augur: erm, 'listings'
09:41:25 <hiptobecubic> pandoc seems to handle things pretty well if you find a format you can live with and then convert it
09:41:52 <Eduard_Munteanu> augur: depends, if you're merely wrapping stuff in a verbatim environment, then yeah, that sucks
09:41:58 <augur> what
09:42:00 <augur> no
09:42:10 <Eduard_Munteanu> listings actually does sensible highlighting and such
09:42:13 <augur> i want to typeset documents using haskell.
09:42:31 <Eduard_Munteanu> Uh...
09:42:42 <augur> im getting very tired of not having the ability to do proper programming in latex
09:42:55 <Eduard_Munteanu> Oh, if you could do that, that would be great.
09:43:04 <augur> i mean
09:43:13 <augur> i want to make a table that's dynamically sized, right
09:43:21 <augur> should be easy, no?
09:43:22 <augur> no.
09:43:47 <augur> apparently theres something called luatex.
09:43:48 <Eduard_Munteanu> Yeah, I sort of pondered on that as well.
09:44:16 <Eduard_Munteanu> augur: still, you don't usually write Lua code in it, documents are still pretty much Latex.
09:44:31 <clahey> Apparently compiling ghc doesn't work on this machine.
09:46:09 <Eduard_Munteanu> I suppose one would design some EDSL from scratch for this purpose, unrelated to Latex (except perhaps as a backend).
09:46:12 <clahey> Any suggestions about who to ask or how to debug it?
09:46:18 <clahey> It seems to give a bunch of warnings and then stop.
09:46:27 <dmwit> preflex: seen jfischoff
09:46:27 <preflex>  jfischoff was last seen on #haskell 2 hours and 3 seconds ago, saying: :)
09:46:33 <jfischoff> yo
09:46:39 <dmwit> Did you get gtk2hs building?
09:46:46 <Eduard_Munteanu> clahey: like what?
09:46:49 <jfischoff> naw
09:46:56 <dmwit> Upgrade gtk2hs-buildtools
09:47:01 <jfischoff> aye
09:47:05 <dmwit> ok
09:47:46 <clahey> Warning: GHC: moduleInfo is exported separately but will be documented under TypecheckedMod. Consider exporting it together with its parent(s) for code clarity.
09:47:46 <clahey> Warning: GHC: renamedSource is exported separately but will be documented under TypecheckedMod. Consider exporting it together with its parent(s) for code clarity.
09:47:54 <clahey> Eduard_Munteanu: A hundred different warnings.
09:47:56 <jfischoff> dmwit: are you familiar with the webkit bindings?
09:48:02 <clahey> And a ton of:
09:48:03 <clahey> Warning: GHC: could not find link destinations for:
09:48:05 <clahey> ...
09:48:16 <dmwit> Not really. In darcs, that's all hamishmack's work.
09:48:29 <jfischoff> ah
09:48:45 <Eduard_Munteanu> clahey: try #ghc, but I think you should pastebin that
09:48:56 <Eduard_Munteanu> (all of them)
09:49:10 <geekosaur> isn't that just haddock noise?
09:54:55 <klrr> is gaurds the name of the "|" or the name of that kind of pattern matching?
09:56:32 <glguy> klrr: That's right, | indicates a guard
09:56:53 <dmwit> I guess the entire chunk from "|" to "=" is the guard.
09:57:39 <GR> Hiya. Does anyone know if there is an algorithm for a finger tree that 'inserts' an element at some index?
09:57:48 <GR> Or removes one for that matter
09:58:01 <GR> An efficient one I mean, more efficient than split + concat.
09:59:03 <dmwit> split+concat is efficient; O(log n)
09:59:19 <GR> More efficient in practice I mean.
09:59:37 <dmwit> There isn't. Next!
09:59:44 <GR> I've written algorithms for those that perform a lot better. I'm wondering if it would be useful.
09:59:51 <GR> They perform as well as an update at index.
10:00:18 <dmwit> Sure, if you have code, send a patch. Maintainers love patches.
10:01:30 <GR> Oh, no, I wouldn't know how to write it in Haskell very well. I was wondering if I could tell them to someone and they would implement it. They are not very complicated.
10:01:46 <GR> My implementation is in a very different language.
10:02:50 <dmwit> hm =)
10:03:17 <GR> Do you know who I should contact?
10:04:14 <dmwit> If true, it might be publishable. =)
10:05:35 <GR> Really? to be honest I was kind of afraid someone beat me to it and I just overlooked it
10:06:09 <carter> GR random access insert on a finger tree seems fundamentally log n  in the worst case....
10:06:18 <carter> (ignoring constants)
10:06:41 <carter> unless you're doing mutable things in secret behind closed doors
10:07:06 <GR> Of course it is. But in a real situation, my algorithm is a lot faster and scales better. I think it performs the minimum possible number of operations.
10:07:25 <carter> GR pray share you code / algorithm with teh community?
10:07:30 <carter> on a finger tree too?
10:07:37 <carter> not a subtely different data structure?
10:07:57 <carter> constant factor better or asymptotically faster?
10:08:31 <GR> The implementation is very different from the source, because it's written in a very different language, but the data structure is identical.
10:08:42 <GR> The algorithms would work as well for any language.
10:08:56 <jfischoff> what language?
10:08:58 <carter> immutable finger trees?
10:09:00 <carter> or packed or?
10:09:10 <carter> could you share the github so we can see it? :)
10:09:19 <klrr> glguy: so gaurds is the name of that kind of pattern matching, not the pipe itself?
10:09:19 <GR> It is written in C#. The finger tree is immutable.
10:09:26 <carter> cool
10:09:30 <carter> share the code please? :)
10:10:00 <dmwit> klrr: It's not a kind of pattern matching, but yes, you're right that it is not the name of the pipe itself.
10:10:05 <GR> https://github.com/GregRos/Solid/blob/master/Solid/Solid/Implementation/FingerTree this is the code for the entire implementation. You wouldn't be able to understand it though, since it's quite... dense.
10:10:17 <glguy> klrr: "In computer programming, a guard is a boolean expression that must evaluate to true if the program execution is to continue in the branch in question." -- http://en.wikipedia.org/wiki/Guard_(computer_science)
10:10:28 <klrr> okey, thanks!
10:11:05 <carter> ooops, lgpl
10:11:08 <carter> i can't read the code
10:11:21 <klrr> if there's any more newbies like me here, this will be of interest http://shuklan.com/haskell/ (ignore the css style, it's april fools joke, the site itself is serious)
10:12:13 <GR> Oh, actually, there is a difference but it's not very important. I allow internal nodes to contain 4 items in the case of an insert, but that's not required. This is because, just like when adding to a digit, a node of 4 + 1 item splits into 2/3
10:12:15 <klrr> im reading trough LYAH and then gonna go trough those lectures
10:12:24 <GR> You could however split 3+1 into 2 + 2
10:12:39 <carter> GR interesting
10:12:56 <carter> those sorts of spltting things do change the workload tuning
10:12:59 <carter> thanks!
10:13:33 <carter> i'll get back to finishing up some haskell packages i'll be releasing soon :)
10:14:44 <GR> In words, you find the node with the right index, you try to add the item directly. If the digit is full, you overflow one of the members of the node and try to insert it into the one on a higher level. At some point you will reach a node that is less than the maximum allowed number of items. Even if the nodes are all maximum at first, the insert operation makes sure to create more nodes that
10:14:47 <GR> can accept additional elements
10:15:24 <carter> GR thats a trick for doing cache obvilous stuff
10:15:41 <GR> for what?
10:16:52 <carter> having a "buffer"  where you can hold multiple values per node
10:17:05 <carter> thats kinda a mutable thing to do
10:17:11 <GR> No, the finger tree implementation, the source, allows for nodes to contain 2 or 3 elements.
10:17:21 <GR> This is important for split/concat
10:17:34 <GR> I use the same mechanism. There is no mutation.
10:17:49 <GR> When you try to insert and a node has 3, it splits into 2 + 2
10:18:17 <GR> And in the end one of the branches overflows up the finger tree, and you push it into the deep tree
10:18:40 <GR> Hmm. I see I need to work on my presentation.
10:18:48 <GR> It's not as straight forward as I thought.
10:19:00 <carter> GR cool
10:19:06 <carter> look forward to a clear exposition
10:19:23 <dmwit> I understood the idea.
10:19:47 <dmwit> I would be interested indeed in seeing a Haskell implementation and some timing numbers to confirm that it is, indeed, faster enough to warrant the extra code.
10:20:17 <dmwit> So you should learn Haskell!
10:20:50 <GR> I've done a lot of benchmarks. It is faster than either because it doesn't need to build a whole finger tree, just rebuild a path.
10:21:29 <carter> GR... have you timed against an Int Map on your worload?
10:22:18 <dmwit> carter: GR hasn't done anything with Haskell, I think.
10:22:24 <GR> Admittedly I've timed it against my own implementation. Timing across different platforms, different languages, and difference implementations isn't really possible.
10:22:31 <carter> dmwit you seem to be right
10:34:21 * hackagebot wai-handler-devel 1.3.0.6 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.3.0.6 (MichaelSnoyman)
10:47:01 <Guest61545> lol... only people joining and leaving in this channel...
10:48:18 * robbe- ignores joins/parts/quits from most channels
10:49:49 <robbe-> On a channel with over 1k nicks, I think it's to be expected that a lot of people are joining and leaving at any time.
10:50:53 * ski_ doesn't see the point in ignoring them
10:56:25 <Kinnison> Okay interactive hooglers, is there a simple function to take a list and drop N from the end?
10:56:49 <supki> @where sneaky
10:56:50 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
10:56:50 <tac> Kinnison: who says there will be an end :)
10:57:11 <Kinnison> tac: Me, given it's a filepath I found by iterating the FS :-)
10:57:49 <tac> a naive way to do it would be reverse . drop n . reverse
10:57:58 <Kinnison> Mmm
10:58:06 <tac> Not efficient in CPU cycles, but very efficient in typing it into your program :)
10:58:06 <ski_> > (zipWith const `ap` drop 3) [0 ..]
10:58:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:58:08 <Kinnison> I like that sneaky use of const :-)
10:58:21 <tac> > (reverse . drop 2 . reverse) [1..10]
10:58:23 <lambdabot>   [1,2,3,4,5,6,7,8]
10:58:51 <tac> plus, that version is a categorical palindrome!
10:59:11 <hpaste> Jambato pasted “initial state problem” at http://hpaste.org/85051
11:00:11 <Jambato> I tried to enforce the GameArea type on the initial state but it won't work
11:00:54 <robbe-> ski_: better SNR
11:01:01 <Kinnison> thanks chaps, I will get the hang of haskell at some point :-)
11:01:20 <ski_> Jambato : it's not clear what `initGameArea3' is meant to be
11:01:43 <tac> Kinnison: as if any of us have :P
11:02:13 <stepkut> any idea how best to do ByteString -> Float ?
11:02:20 <stepkut> bytestring-lexing seems to only support Double
11:02:44 <Jambato> ski_: well I want to initialize a list of Stacks inside a stateful...something
11:02:57 <stepkut> also.. i think bytestring-lexing is for literals.. not the IEEE binary floating point
11:05:01 <ski_> Jambato : .. and then ?
11:05:50 <Jambato> ski_: do I need to do something with it afterwards?
11:06:01 <Jambato> can't I just leave it as a variable?
11:06:13 <Jambato> for example
11:06:37 <ski_> Jambato : normally, you'd not need to make an action to initialize the state, unless you mean to later reinitialize the state (without perhaps initializing other things ? other states ?) and continue
11:07:09 <ski_> iow, you'd usually just need to specify the initial state in the spot in the program where you start and finish the whole stateful computation
11:07:18 <Jambato> ski_: if I want to run a new game perhaps
11:08:04 <Jambato> but is there a problem with building such an action?
11:08:04 <ski_> only if you'd need to keep something from the old game into the new one would you perhaps need such an initializing action
11:08:08 <ski_> no
11:08:15 <ski_>   initGameArea3 :: State GameArea ()
11:08:24 <ski_> initGameArea3 = put initGameArea
11:08:26 <ski_> is fine
11:09:02 <ski_> (iow, don't use `runState' and don't specifiy a (*really*) initial state (your `ga'))
11:09:34 <Jambato> I see
11:09:40 <Jambato> thanks again
11:09:43 <ski_> however, it may be clearer (or maybe not ?) to just write `put initGameArea' instead of `initGameArea3' at the use site
11:10:46 <ski_> Jambato : anyway, usually the times/places you use `runState' (or `evalState' or `execState') will be few, commonly just one
11:11:00 <troydm> OpenDNS replied: The phish tag has been removed from the 'comonad.com' domain.  Thank you for your patience with this matter.
11:11:31 <ski_> iow, only when you want to *interface* the stateful code with non-stateful (in the sense of not using the `State GameArea' monad) code
11:13:15 <aristid> troydm: haha.
11:14:06 <Jambato> ski_: I am not ye to that point
11:14:23 <Jambato> still discovering the State thinky
11:14:27 <Jambato> *thingy
11:15:16 <ski_> Jambato : you can think of it as a glorified way of passing around a state in an accumulator
11:15:27 <ski_> (you do know about accumulator-passing-style, yes ?)
11:17:03 <Jambato> ski_: ok so I use *State functions when I pass the state around
11:17:35 <Jambato> btw the point free version of initAPlayer2 n m = put $ initAPlayer n m
11:17:43 <Jambato> doesn't work
11:17:51 <Jambato> err gonna update the paste
11:18:05 <ski_>   initAPlayer2 n m = put (initAPlayer n m)  -- i'd prefer this version
11:18:46 <Jambato> but isn't point free writing possible since I have the same arguments on both sides?
11:20:00 <ski_>   initAPlayer2 n m = put (initAPlayer n m)
11:20:05 <ski_>   initAPlayer2 n m = put ((initAPlayer n) m)
11:20:16 <ski_>   initAPlayer2 n m = (put . (initAPlayer n)) m
11:20:23 <ski_>   initAPlayer2 n = put . (initAPlayer n)
11:20:33 <ski_>   initAPlayer2 n = (put .) (initAPlayer n)
11:20:34 <c_wraith> point-free rewriting is always possible, if you're not pattern-matching.
11:20:38 <c_wraith> It's not always readable
11:20:40 <ski_>   initAPlayer2 n = ((put .) . initAPlayer) n
11:20:45 <ski_>   initAPlayer2 = (put .) . initAPlayer
11:20:48 <hpaste> Jambato revised “initial state problem”: “initial state problem” at http://hpaste.org/85051
11:21:25 <ski_> (several times using that `f (g x) = (f . g) x', for every `f',`g',`x')
11:21:36 <Jambato> weird currying
11:21:48 <ski_> yes
11:22:22 <ski_> `(x:xs) <- get' can be simplified to `x:xs <- get'
11:23:11 <ski_>   push x = modify (x:)  -- may or may not be more readable
11:24:22 * hackagebot snaplet-sqlite-simple 0.4.3 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.3 (JanneHellsten)
11:24:41 <ski_> `initChips2' looks nonworking
11:24:56 <Jambato> indeed
11:25:14 <ski_> what is it meant to be ?
11:26:56 <Jambato> ski_: hmm it initializes a stack of chips
11:27:06 <Jambato> but I just fixd the type signature
11:27:14 <Jambato> so it's fine
11:27:36 <Jambato> and the same point free rewrite
11:27:45 <ski_> are you sure you want `State Stack' rather than `State GameArea' there ?
11:28:13 <Jambato> ski_: it is for a given player
11:28:33 <Jambato> there are Stacks in both Players and in the GameArea
11:28:37 <Spockz> Is there someone here that is fluent with CSS and wants to help the UHC JavaScript backend site look a bit niftier? (http://uu-computerscience.github.com/uhc-js/)
11:29:37 <ski_> Jambato : so the whole game state will consist of both the current `Player' state for two players, and of the `GameArea' state ?
11:30:11 <ski_> (perhaps `ListPlayers' for the players)
11:30:40 <Jambato> yes
11:30:59 <Jambato> actualy it's for 4 players
11:31:14 <Jambato> but it doesn't really matter
11:32:11 <ski_> it's common then to bundle those up, perhaps as `data GameState = GS {players :: ListPlayers,gameArea :: GameArea}', and then to mostly (or completely) use `State GameState'
11:32:11 <Jambato> the tricky thing is the stateful stack inside Player and the GameArea
11:32:51 <Jambato> I have yet to update the stacks and then update the gameArea and the Player
11:33:16 <ski_> (there may be reasons for using some of `State ListPlayers',`State Player',`State GameArea',`State Stack', though -- but i'm not sure if there is in your case)
11:33:23 <Jambato> ski_: I wondered if putting that as a global state was necessary
11:33:39 <Jambato> with IORef stuff in the main
11:33:51 <ski_> it depends on how you structure the "main game loop" (or what you want to call it)
11:34:05 <ski_> `IORef' is another matter
11:36:06 <Jambato> if I just change the game state, I'm going to need () as a result too
11:36:21 <ski_> yes
11:36:23 <Jambato> unless I want to keep the previous game state or something
11:38:00 <ski_> Jambato : btw, should `deadbox :: Stack' perhaps be `deadbox :: Deadbox' ?
11:38:08 <klrr> i need some help, does this http://hastebin.com/titosovaqe.hs qualify as a correct answer to http://shuklan.com/haskell/lec03.html#/0/21 ?
11:38:14 <ski_> (or what is the point of having `Deadbox' ?)
11:38:25 <Jambato> hmm I'm wondering about encapsulating the ListPlayers inside State
11:39:03 <Jambato> ski_: the deadbox is a Stack anyway
11:39:17 <Nisstyre-laptop> klrr: it looks like you could simplify it
11:39:23 <Nisstyre-laptop> idk if it's correct though
11:39:23 * ski_ can see no code at <http://hastebin.com/titosovaqe.hs>
11:39:30 <Nisstyre-laptop> ski_: I see it
11:39:35 <Jambato> two distincts type for the same [Int] seemed to me kinda confusing
11:40:25 <ski_> Jambato : so perhaps having the type `Deadbox' is unnecessary
11:40:26 <Jambato> it might be clearer
11:40:41 <klrr> Nisstyre-laptop: yes, that would be awesome, but how?
11:41:01 <klrr> Nisstyre-laptop: also, i tested, it's correct, it's just that it's very ugly i wanna improve it :D
11:41:12 <Nisstyre-laptop> klrr: I'll think about it
11:41:20 <Nisstyre-laptop> I'll get back to you with my implementation
11:41:37 <klrr> Nisstyre-laptop: cool :D it was really fun to write, my first "real" program i think :P
11:41:43 <hpaste> “Cyprus Robbery LEAKED” pasted “Cyprus Robbery LEAKED! /w ZIP” at http://hpaste.org/85053
11:41:51 <Nisstyre-laptop> klrr: is this for an intro CS course?
11:45:33 <klrr> Nisstyre-laptop: i donno, a friend linked it to me and i wanna learn programming and haskell so i started reading the slides
11:45:44 <klrr> me too young for cs :P
11:46:38 <atriq> klrr, never too young
11:46:57 <klrr> *too low iq then
11:47:10 <atriq> IQ's just a number
11:47:39 <atriq> Can you come up with ideas?
11:47:56 <klrr> yes, sometimes
11:48:03 <klrr> more when i was younger
11:48:16 <atriq> That's what matters, really
11:49:10 <klrr> go
11:49:12 <klrr> good
11:50:20 <augur> i love discovering new sequences that arent in oeis
11:50:20 <augur> :D
11:50:24 <atriq> That, and perseverance
11:51:00 <klrr> omfg, Nisstyre-laptop look at this  implementation http://hastebin.com/nohuqitasu.hs (i didnt make it)
11:51:22 <Jambato> alright state everywhere
11:51:27 <Jambato> :p
11:51:34 <Jambato> thank you ski_
11:52:31 <klrr> i like how i just like "wow" and "damn, that's fucking right" when i read learn about haskell, everything is so excellent and amazing and awesome, everything is just *right*, not like in other languages where you question everything as a beginner
11:53:03 * ski_ grins
11:55:23 <ski_> `• Int = -2^31 | ... | -1 | 0 | 1 | ... | 2^31-1' isn't quite right
11:56:23 <augur> ski_: ive submitted my first paper! :D
11:56:40 <ski_> oh ?
11:58:49 <Nisstyre-laptop> klrr: here is mine http://ideone.com/0quva7
12:00:12 <ski_> > chr 97
12:00:15 <lambdabot>   'a'
12:00:29 <ski_> Nisstyre-laptop : instead of  97  you could use  ord 'a'
12:00:33 <klrr> Nisstyre-laptop: nice
12:00:34 <Nisstyre-laptop> ski_: sure
12:00:48 <klrr> Nisstyre-laptop: but what happens if there's a . or / in the input?
12:00:54 <ski_> @pl \a -> a - ord 'a'
12:00:54 <lambdabot> subtract (ord 'a')
12:06:09 <Nisstyre-laptop> klrr: you could just use Data.Char.isAlpha
12:06:17 <Nisstyre-laptop> er, isLetter actually
12:06:47 <Nisstyre-laptop> the same function though
12:15:12 <dmwit> ?where rot13
12:15:12 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
12:16:20 <dmwit> klrr: Just change "anz" to "abz" (and "ANZ" to "ABZ") and you've got your implementation of rotate _ 1. ;-)
12:17:01 <klrr> dmwit: what you mean?
12:17:10 <dmwit> Never mind, it's just a joke.
12:17:10 <klrr> what is the equaliant to succ but other way around ?
12:17:14 <klrr> okey
12:17:17 <dmwit> pred
12:17:18 <ski_> @type pred
12:17:19 <klrr> sry for not getting it
12:17:22 <klrr> okey thanks!
12:17:24 <lambdabot> Enum a => a -> a
12:17:36 <dmwit> > (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ"))) "hello" -- "uryyb", as in the exercise
12:17:42 <lambdabot>   "uryyb"
12:17:47 <ski_> > pred 0 :: Word8
12:17:56 <lambdabot>   *Exception: Enum.pred{Word8}: tried to take `pred' of minBound
12:19:08 <danharaj> edwardk: Your post on incremental folds from forever ago has caused me to investigate attribute grammars.
12:20:12 <augur> dmwit: wtf is that o_o;
12:20:23 <dmwit> augur: It's golf'd rot13!
12:20:23 <ski_> @where UUAG
12:20:30 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
12:20:33 <dmwit> I helped write it. =)
12:20:36 <augur> dmwit: golf'd?
12:20:41 <augur> ski_: wut
12:20:47 <ski_> augur : pointless'd
12:20:48 <dmwit> https://en.wikipedia.org/wiki/Code_golf
12:21:01 <augur> oic
12:21:04 <ski_> (or close to, at any rate)
12:21:16 <danharaj> edwardk: I think this is a straightforward treatment of synthesized attributes, but I am not sure how to approach inherited attributes. http://hpaste.org/85055
12:21:38 <augur> ski_: what about it?
12:22:22 <ski_> augur : what about what ?
12:22:57 <augur> ski_: nevermind
12:23:07 * ski_ stares blankly
12:23:31 <dmwit> > let e[a,b,c]=zip[a..c]$[b..c]++[a..] in e "aeg" -- this should demystify things a lot
12:23:34 <lambdabot>   [('a','e'),('b','f'),('c','g'),('d','a'),('e','b'),('f','c'),('g','d')]
12:24:16 <augur> ski_: i misinterpreted the conversation structure in a stupid way.
12:24:43 * hackagebot hmemdb 0.1.0.3 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.1.0.3 (MiguelMitrofanov)
12:27:39 <edwardk> danharaj: an inherited attribute is just a higher order synthesized attribute. pass it the info for the root and go
12:30:31 <LambdaDusk> anyone have a definite guide on VBO's in haskell?
12:30:31 <clahey> Is there a standard Monad type fulfilling Something b a = [a] -> (b, [a]) where Something b is a Monad?
12:30:37 <clahey> And return b = as -> (b, as) and get = a:as -> (a, as)
12:30:52 <clahey> Someone suggested this looked like a State Monad.
12:31:03 <c_wraith> that's not a state monad
12:31:21 <c_wraith> it would be if it was Something a b = [a] -> (b, [a])
12:31:25 <ClaudiusMaximus> there's a 'supply' monad
12:31:38 <clahey> c_wraith: Oh, that is what I meant.
12:32:11 <c_wraith> @unmtl StateT b [] a
12:32:12 <lambdabot> b -> [(a, b)]
12:32:28 <c_wraith> @unmtl ListT (State b) a
12:32:28 <lambdabot> b -> ([a], b)
12:32:38 <c_wraith> Not exactly either of those
12:32:48 <monoidal> clahey: there's kind error in your question, is b :: * or b :: * -> *?
12:33:03 <clahey> SupplyT looks like what I want.
12:33:09 <atriq> @unmtl Compose (StateT a) [] b
12:33:09 <lambdabot> Compose (StateT a) [] b
12:33:14 <atriq> Bah
12:33:20 <atriq> Anyway, it's not that
12:34:04 <clahey> It's State [a]
12:34:15 <clahey> Which is what Supply gives you.
12:34:22 <clahey> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
12:34:43 <byorgey> Supply is on Hackage now!
12:35:04 <byorgey> http://hackage.haskell.org/package/monad%2Dsupply
12:35:15 <clahey> Yep.
12:35:47 <troydm>  unknown HaskellWiki contributor(s).
12:35:58 <troydm> lolol
12:36:07 <troydm> unknown hero saves the day
12:40:16 <mauke> jfischoff!
12:40:45 <jfischoff> mauke:hey!
12:41:25 <mauke> I've been thinking about you
12:41:40 <jfischoff> good things I hope ;)
12:41:55 <jfischoff> what are your thoughts on the big record example?
12:42:05 <mauke> can the default def thing be done in an external module?
12:42:15 <jfischoff> nooo … that's the rub
12:43:16 <mauke> jfischoff: I'm not sure the change is worth it
12:43:24 <mauke> Default is currently H98
12:43:29 <jfischoff> ohhh
12:43:56 <mauke> with this I'd be enabling 5 separate extensions and import a GHC module
12:44:14 <jfischoff> yeah it would be GHC all the way at that point
12:44:30 <jfischoff> fair enough
12:44:47 <jfischoff> it is nice though …
12:44:55 <jfischoff> dmwit: https://github.com/mauke/data-default/pull/4
12:44:56 <monochrom> do you mean telling cabal-install to use Haskell2010? that's "default-language: Haskell2010" in the project.cabal file
12:45:14 <mauke> monochrom: ?
12:45:30 <monochrom> I'm butting in without actually knowing the context
12:45:54 <jfischoff> oh made a pull request I linked to about for data-default
12:46:03 <jfischoff> s /about/above
12:46:17 <jfischoff> I want to add default signatures
12:46:21 <dmwit> jfischoff: Have you seen data-default-th or whatever I called it?
12:46:36 <dmwit> jfischoff: You might pull a similar trick and release a data-default-generics
12:46:55 <jfischoff> dmwit: I could, but I would rather it be a default signature
12:46:55 <dmwit> template-default
12:47:34 <dmwit> jfischoff: Or consider just using template-default instead of generics. =P
12:47:54 <jfischoff> dmwit:Never!
12:48:05 <dmwit> Why not?
12:48:54 <mauke> I made this: https://github.com/mauke/data-default/tree/modularize
12:49:00 <mauke> thoughts?
12:49:13 <jfischoff> dmwit: I use TH, and I would use it don't get me wrong, but I prefer not use TH because it forces an declaration ordering
12:49:22 * jfischoff is looking
12:50:12 <dmwit> jfischoff: I don't understand this complaint. Can you expand a little?
12:50:45 <jfischoff> dmwit: let me make an example ...
12:51:02 <dmwit> great =)
12:51:21 <jfischoff> mauke: I'll pull the generics stuff into its own package. You can add the default signatures later if you want to
12:52:15 <dmwit> mauke: Ah, yeah, I was thinking of some kind of split like this for universe, too. One module per package just seems so gauche, though.
12:52:19 <dmwit> Not that I have a better suggestion.
12:55:33 <clahey> I think I may have just been bit by not all Monads are Applicatives.
12:55:59 <clahey> Can someone remind me how to write <*> using >>=?  My brain is a little tired.
12:56:18 <jfischoff> use ap
12:56:20 <jfischoff> :t ap
12:56:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:56:42 <jfischoff> :t (<*>)
12:56:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:57:11 <clahey> I'll just use liftM2 probably.
12:57:11 <monochrom> you can use "(<*>) = ap", but if you want to do it yourself for learning:
12:57:25 <clahey> Or not.
12:57:55 <monochrom> mf <*> ma = do { f <- mf; a <- ma; return (f a) }  seems to be suggested by the type
12:57:56 <tgeeky> clahey: nope, @type not will prove unsatisfactory
12:58:28 <monochrom> = mf >>= \f -> ma >>= \a -> f a
12:58:40 <monochrom> err
12:58:45 <monochrom> = mf >>= \f -> ma >>= \a -> return (f a)
12:59:09 <monochrom> I am now too scared to @pl it, so I'll leave it there
12:59:19 <shachaf> hi monochrom
12:59:20 <ski_>   = mf >>= \f -> liftM f ma
12:59:21 <shachaf> @hug monochrom
12:59:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
12:59:29 <monochrom> thank you shachaf
12:59:45 * hackagebot data-default-class 0.0.1 - A class for types with a default value  http://hackage.haskell.org/package/data-default-class-0.0.1 (LukasMai)
12:59:47 * hackagebot ajhc 0.8.0.3 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.3 (KiwamuOkabe)
13:00:18 <ski_>   = mf >>= (`liftM` ma)  -- if you prefer
13:01:00 * ski_ suspects `pl' would just answer `ap mf ma'
13:01:56 <DanBurton> @pl mf >>= \f -> ma >>= \a -> return (f a)
13:01:56 <lambdabot> (ma >>=) . (return .) =<< mf
13:02:55 <hpaste> “jfischoff are you happy now ekmett?” pasted “TH ordering issue” at http://hpaste.org/85058
13:02:57 <jfischoff> dmwit: Now that I making the example, I guess the main issue is the order of the splices… for whatever reason I remember it as being a bigger issue.
13:04:45 * hackagebot data-default-instances-base 0.0.1 - Default instances for types in base  http://hackage.haskell.org/package/data-default-instances-base-0.0.1 (LukasMai)
13:04:47 * hackagebot data-default-instances-containers 0.0.1 - Default instances for types in containers  http://hackage.haskell.org/package/data-default-instances-containers-0.0.1 (LukasMai)
13:04:49 * hackagebot data-default-instances-dlist 0.0.1 - Default instances for types in dlist  http://hackage.haskell.org/package/data-default-instances-dlist-0.0.1 (LukasMai)
13:04:51 * hackagebot data-default 0.5.2 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.5.2 (LukasMai)
13:06:52 <GOMADWarrior> hack the planet!
13:07:50 <Breadmonster> http://learnyouahaskell.com/higher-order-functions#composition
13:08:01 <Breadmonster> Look at the type signature of (.)
13:08:08 --- mode: ChanServ set +o monochrom
13:08:10 --- mode: monochrom set +b *!*@187.65.192.206
13:08:10 --- kick: GOMADWarrior was kicked by monochrom (GOMADWarrior)
13:08:18 <Breadmonster> Why isn't it like this?
13:08:40 <Breadmonster> (.) :: (a -> b) -> (b -> c) -> a -> c
13:08:40 <monochrom> (because he/she is saying that in ##math too)
13:08:58 <DanBurton> @type (>>>) `asAppliedTo` unsafeCoerce
13:08:59 <lambdabot> Not in scope: `unsafeCoerce'
13:09:02 <DanBurton> awww
13:09:15 <DanBurton> @type (>>>) `asAppliedTo` (undefined :: a -> b)
13:09:17 <lambdabot> (a -> b) -> (b -> c) -> a -> c
13:09:33 <clahey> Can anyone explain why using parseCase :: MonadSupply String m => m Case   requires   -XFlexibleContexts
13:09:34 <mauke> Breadmonster: because that's backwards
13:09:42 <clahey> And whether it's possible to work around this?
13:09:59 <Breadmonster> mauke: No, shouldn't it be (f . g) x = f(g(x))
13:10:06 <mauke> Breadmonster: that's what it is
13:10:08 <shachaf> mauke: imo function application is the one that's backwards, hth
13:10:15 <mauke> Breadmonster: why do you want to reverse it?
13:10:30 <DanBurton> Breadmonster: g happens "first"
13:10:33 <shachaf> Breadmonster: Give each thing a type, starting with x and continuing to g, g x, f, f (g x)
13:10:33 <otters> :t asAppliedTo
13:10:35 <lambdabot> (t -> b) -> t -> t -> b
13:10:48 <jfischoff> f (g x) <=> (f . g) x
13:10:49 <shachaf> DanBurton: No, if anything happens "in an order", f happens "first"
13:10:53 <ski_> clahey : because not all arguments to `MonadSupply' in the class constraint are tyvars
13:10:54 <otters> oh man asAppliedTo is going to be a lifesaver
13:11:11 <ski_> (s/tyvars/distinct tyvars/)
13:11:15 <shachaf> Breadmonster: By the way you should get used to saying "f (g x)" instead of "f(g(x))"
13:11:24 <ski_> otters : ty
13:11:27 <Breadmonster> shachaf: The way I see it, is that (.) curries it's parameters in this order f then g then x.
13:11:30 <Breadmonster> Am I not right?
13:11:48 <shachaf> You are not right. There is no currying involved here.
13:11:51 <DanBurton> shachaf: it depends on what you are thinking of when you think of things happening "in an order". In this case I am referring to f (g x) meaning that g eats the value x and the result is handed to f (ignoring laziness)
13:11:52 <clahey> ski_: Right, but the first parameter has to be String based on the object, right?  So in order to give the full type information, I need FlexibleContents?
13:11:56 <shachaf> (You probably mean something other than currying but I don't know what you mean.)
13:12:03 <ski_> @type map `asTypeIn` \map -> map ord "foo"
13:12:04 <lambdabot> (Char -> Int) -> [Char] -> [Int]
13:12:28 <Breadmonster> Wait, my question is this.
13:12:31 <clahey> Actually, that's not true.  It just has to be readable.
13:12:33 <shachaf> You can't ignore laziness.
13:12:38 <clahey> So I guess I could just add that as a constraint.
13:13:05 <ski_> clahey : if you need `MonadSupply String m' as the constraint, then you need `FlexibleContexts', yes
13:13:21 <clahey> Oh, no Read is typeclassed on the output, not the input.
13:13:30 <Michael__> What does it mean when haskell stops the execution and just outputs "<<loop>>"?
13:13:42 <mauke> Michael__: you wrote an infinite loop
13:13:48 <monochrom> Breadmonster: say x::a, g x :: b, f (g x) :: c. this makes g::a->b, f::b->c, and overall f.g :: a->c
13:13:48 <Michael__> thanks
13:13:49 <shachaf> Michael__: It means you have a particular kind of infinite loop that GHC can detect.
13:14:20 <ski_> shachaf : alternatively, the function arrow is what's backwards
13:14:20 <Breadmonster> monochrom: Okay, got it.
13:14:22 <Breadmonster> Thank you :)
13:14:29 <DanBurton> monochrom++
13:14:37 <Breadmonster> monochrom++
13:14:40 <Breadmonster> Interesting.
13:14:46 <Breadmonster> Thanks guys, see you :)
13:14:46 <shachaf> ski_: Also possible.
13:14:49 <ski_> @karma monochrom
13:14:49 <lambdabot> monochrom has a karma of 43
13:14:53 <monochrom> I wouldn't say "what happens first", but it is safe to talk about data dependency
13:16:32 <clahey> ski_: I guess I could just make the type be Supply String since I know that's how I'll always use it, but this is prettier to my eyes and works.
13:16:40 <clahey> ski_: So I added the Pragma and done.
13:17:18 <monochrom> Richard Bird therefore likes to write "g :: b<-a" but I don't know whether he goes as far as writing c<-a <- (b<-a) <- (c<-b)
13:17:22 <ski_> clahey : *nod*
13:17:41 <shachaf> (x g) f
13:17:55 <monochrom> someone else writes "g;f" for "f.g"
13:18:17 <monochrom> I think Fokkinga does
13:18:26 <ski_> yes, and also others
13:18:52 <shachaf> I thought only categorists did that.
13:19:03 <aristid> monochrom: lawvere would probably at least sympathise with the idea, not sure if he does it
13:19:14 <monochrom> yes, Fokkinga writes "g;f" in his category theory articles!
13:19:17 <ski_> shachaf : i think it's more common that `x' is a large expression in `f x', than `f' being one
13:19:46 <ski_> also, in a definition `f (..semi-complex pattern here..) = ...', we prefer the name of the defined thing to come first
13:19:50 <aristid> monochrom: doesn't he more like write f;g when he means g.f? :P
13:20:02 <clahey> @hoogle [a] -> [b] -> (a -> b -> Ordering) -> (a, b)
13:20:03 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
13:20:03 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
13:20:13 <monochrom> yeah yeah alpha-rename it...
13:20:19 <ski_> (imo, this is also an argument for writing `instance Show [a] <= Show a where ...')
13:20:23 <clahey> @hoogle [a] -> [b] -> (a -> b -> Bool) -> (a, b)
13:20:24 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
13:20:24 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
13:20:41 <aristid> monochrom: hey we're already into making order significant, so we may as well make the alphas significant :)
13:20:52 <monochrom> I like "instance Show [a] <= Show a"
13:20:55 <clahey> No, I do want it to be an ordering since I want it to do a fast search through ordered list.
13:21:03 <ski_> clahey ?
13:21:36 <clahey> ski_: I want a function that takes two lists and finds a pair of values that returns Equal in that function.
13:21:43 <Hafydd> monochrom: isn't <= an operator name?
13:21:59 <hiptobecubic> less than or equal to, typically
13:21:59 <clahey> ski_: And throws out the lesser of the two values each time it compares the first two.
13:22:14 <clahey> ski_: I've written it, but I was curious if it was available somewhere.
13:22:17 <monochrom> oh, "instance Show [a] <= Show a" is dreamed syntax, not current Haskell syntax
13:22:39 <Hafydd> Okay. How would you reconcile it with the existing usage of <=, in this dream?
13:22:55 * ski_ also prefers the Prolog convention of `=<' for "less than or equal to"
13:22:59 <monochrom> there is no need to reconcile. different context.
13:23:31 <clahey> ski_: If not, I'll just leave it, or perhaps come up with a name and put it in my personal library.
13:23:45 <ski_> clahey : hm, i can't recall seeing it before
13:24:09 <clahey> ski_: Okay.  I'll come up with a name and save it locally.
13:24:29 <ski_> reminds me of merging
13:25:02 <otters> :t gmapAccumQl
13:25:04 <lambdabot>     Not in scope: `gmapAccumQl'
13:25:04 <lambdabot>     Perhaps you meant one of these:
13:25:04 <lambdabot>       `mapAccumL' (imported from Data.List),
13:25:07 <otters> now that is a helpful function
13:25:22 <ski_> @type Data.Generics.gmapAccumQl
13:25:23 <lambdabot> Data.Data.Data d => (r -> r' -> r) -> r -> (forall e. Data.Data.Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
13:26:31 <Hafydd> monochrom: would type signatures still look like Show a => a -> String?
13:27:07 <monochrom> I don't know yet
13:27:14 <ski_> in Clean it's `a -> String | Show a', iirc
13:27:45 <Hafydd> (\_ -> "") :: a -> String <= Show a
13:27:51 <monochrom> hrm, that's interesting
13:28:31 <monochrom> this is one day too late or 364 days too early. Backward Haskell!
13:28:35 <Hafydd> ((\_ -> "") :: a -> String) <= Show a. I suppose it isn't really ambiguous. It might increase the complexity of a parser, but I'm sure other extensions do worse.
13:29:37 <ski_> @type let (=>) = () in ()
13:29:39 <lambdabot> parse error on input `=>'
13:30:00 <Hafydd> The "a -> String | Show a" form is cute, because it resembles set-builder notation.
13:36:38 <ski_> clahey : hmm .. so `firstMatch as bs' won't necessarily give a pair of the first respective elements, in the sense of least minimum of indices ..
13:37:24 <ski_> (hm, s/firstMatch/firstMatch cmp/)
13:38:05 <ski_> e.g. `firstMatch compare [0,1,3] [2,1,3]' won't give `(1,1)'
13:42:46 <clahey> ski_: As far as using indices go, I actually wrote:
13:43:13 <clahey> firstMatch comp where comp a b = compare (items !! a) (total - items !! b)
13:43:32 <clahey> (It turns out I wanted to inverse the value of the items in the second list before comparing.)
13:44:10 <ski_> hm, so elements of the two lists were indices in your application ?
13:44:20 <clahey> Yep.
13:44:31 <clahey> And they were sorted by the value of the indices.
13:44:42 <clahey> I dislike that it uses indices into lists.  I might switch to using arrays.
13:45:12 * shachaf sighs at killy9999's post.
13:45:15 <ski_> perhaps `items' is monotone ?
13:45:25 <clahey> monotone?
13:45:33 <otters> iiiiteeeeeems
13:45:41 <ski_> increasing or decreasing
13:45:48 <clahey> it is.
13:45:54 <ski_> (in some contexts, it only means "increasing")
13:45:54 <clahey> Well, no.
13:45:57 <clahey> Sorry, it's not.
13:46:29 <clahey> zipWith (!!) items indices is monotonic.
13:46:36 <ski_> shachaf ?
13:46:45 <clahey> No, that's not right.
13:46:53 <clahey> map (items !!) indices is monotonic.
13:47:15 <ski_> ok
13:47:24 <clahey> So I was thinking of replacing items with an array so that things would be faster, but I don't see a simple Array.fromList.
13:47:52 <ski_> @type listArray
13:47:53 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
13:48:26 <shachaf> ski_: They were saying they were only using I# and Int# and so on to understand things, when the channel was telling them that it's unrelated to unboxed vectors and most likely unnecessary.
13:48:48 <clahey> Ah, I just have to look up the length.
13:49:10 <shachaf> Now in http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/ they say things like "The bad thing is that to get efficient code you might be forced to sacrifice the elegance and abstraction of functional programming." despite this example not really needing unboxed Ints at all.
13:49:49 <shachaf> I think they decided what point they want the article to make before testing it.
13:50:09 <ski_> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
13:50:11 <lambdabot>  Defined.
13:51:27 <ski_> @type \ix -> tabulate ix . (!!)
13:51:29 <lambdabot> (Int, Int) -> [e] -> Array Int e
13:52:57 <ski_> shachaf : ok
13:53:19 <clahey> Yeah, array made that a lot faster.
13:54:47 * hackagebot prednote 0.6.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.6.0.0 (OmariNorman)
13:56:15 <clahey> Cool.  I now have a little Google Code Jam library for input and output in haskell.
13:56:39 <clahey> So I just need to write a simple parse and solve function for the particular case and my library will do the rest.
13:57:51 * ski_ . o O ( "But of course few people were listening, because it was axiomatic that functional languages are irrelevant. Instead we wasted decades on object nonsense while we the enlightened honed our tools. We win in the end." )
13:58:13 <napping> where is andI# from anyway?
13:58:57 <shachaf> I wonder whether they defined it themselves.
13:59:01 <shachaf> It seems to confuse I# and Int#
13:59:10 <napping> yes, http://hackage.haskell.org/trac/ghc/ticket/7689
13:59:35 <shachaf> Oh, it's HEAD.
14:00:23 <shachaf> I'm not sure why these need to be primops.
14:00:35 <jfischoff> ski_: are you reading something or just thinking?
14:01:08 <clahey> ski_: I can't tell if you're making fun of me or of other people.
14:01:17 <clahey> I have a guess, but I'm not sure.
14:01:19 <ski_> jfischoff : it's a quote from the blag shachaf referred to
14:01:40 <napping> from robert harper replying to the blog, more specifically
14:01:49 <ski_> clahey : not really making fun of anyone
14:03:56 <jfischoff> ski_: its refreshing to see Harper defend Haskell.
14:04:57 <clahey> ski_: Cool.  Sort of saying that haskell is cool and I'm not wasting my time doing this?
14:05:10 <dmwit> jfischoff: Ah, yeah, the FlexibleContexts/UndecidableInstances is a bit annoying.
14:05:17 <dmwit> This could be fixed with a deriveDefaults, though.
14:07:25 <jfischoff> dmwit: Agreed. There are still downsides though. For instance, TH doesn't play nice when cross compiling to iOS, and it slows down builds.
14:07:33 <ski_> clahey : i was pondering the quote, and finding it somewhat amusing
14:08:56 <clahey> ski_: Cool.
14:09:44 <clahey> Is there a way to make -i $HOME/myHaskelldirectory always be added to ghc?
14:10:02 <dmwit> jfischoff: We need a tool that "freezes" splices. =)
14:10:03 <clahey> An environment variable or something?
14:10:09 <notdan> @hoogle Either a b -> Bool
14:10:09 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
14:10:10 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
14:10:10 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
14:10:21 <notdan> Hm, there is no 'isLeft' function?
14:10:25 <dmwit> so th-freeze foo.hs reads foo.hs, fills in all the splices, and overwrites it... or something
14:10:29 <notdan> that is strange
14:10:50 <jfischoff> dmwit: Yeah…I think at one point there was something like that
14:10:59 <dmwit> :t either (const True) (const False)
14:11:01 <lambdabot> Either a b -> Bool
14:11:16 <jfischoff> maybe not that sophisticated
14:11:34 <supki> @ty isn't _Right
14:11:36 <lambdabot> Either c a -> Bool
14:11:47 <jfischoff> It would be nice is TH code was cached somehow. That would really speed things up.
14:12:38 <jfischoff> dmwit: http://hackage.haskell.org/package/zeroth
14:12:46 <jfischoff> I don't know if it works :/
14:12:56 <notdan> dmwit: yeah, well it's trivial to write, but nevertheless
14:13:09 <jfischoff> heh look at the build failures :p
14:13:40 <jfischoff> yeah that thing is bit-rotted
14:13:49 <dmwit> Hm, the dependencies seem a bit outdated, huh? =)
14:13:54 <ski_> @where boolean-blindness
14:13:55 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
14:13:58 <ski_> notdan : see that ^ ?
14:14:08 <ski_> (s/see/seen/)
14:14:31 <dmwit> Tell that to the syntax construct that treats Prelude.Bool as special somehow!
14:14:49 <jfischoff> really?
14:14:58 <monochrom> eh? if-then-else is not that bad
14:15:13 <ski_> guards
14:15:23 <dmwit> Coq's if works with all sum types.
14:15:28 <dmwit> That's the joke.
14:15:51 <eikke> dmwit: rebindablesyntax!
14:15:57 <monochrom> the lack of case-of in other languages is the culprit. it trains people to think of "isJust, then fromJust", and then they come to haskell or sml etc
14:15:57 <notdan> ski_: hm, not really, will take a look
14:16:23 <jfischoff> I remember those days
14:16:32 <notdan> ski_: still I kinda need them for Map.filter
14:18:14 <ski_> @type mapMaybe
14:18:16 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:19:24 <ski_> notdan : <http://math.andrej.com/2005/05/16/how-many-is-two/> might also be fun, unless it's all greek to you (in which case you may safely ignore it)
14:20:41 <LambdaDusk> when is the next installment of haskell-platform for windows to be expected? I would love to be able to compile again...
14:21:41 <dmwit> Perhaps it's better to just ask about what's stopping you from compiling with what you've got.
14:22:01 <LambdaDusk> ./configure scripts
14:22:06 <notdan> ski_: I was talking about Data.Map.filter
14:22:26 <monoidal> LambdaDusk: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
14:22:31 <dmwit> What are you trying to compile? What do you do to try to compile it? What do you expect to happen? What happens instead?
14:22:53 <notdan> Why there are 'isJust' and 'isNothing' but no 'isLeft'/'isRight'?
14:23:23 <jfischoff> I asked myself the same question an hour ago
14:23:31 <LambdaDusk> trying to compile juicypixels-repa which depends on a newer wersion of time (time-1.4.0.2) which fails because it's a core package
14:23:39 <dmwit> notdan: Package errors has Control.Error.Utils.isLeft.
14:23:43 <eikke> notdan: IIRC there was some talk to add those to Data.Either
14:23:49 <dmwit> (and isRight)
14:24:14 <ski_> @type Data.Map.mapMaybe
14:24:15 <lambdabot> Ord k => (a -> Maybe b) -> M.Map k a -> M.Map k b
14:24:32 <jfischoff> although one rarely wants the isBlah functions really
14:25:30 <dmwit> LambdaDusk: What's asking for a new version of time? What happens if you add a constraint for the time package? (e.g. add --constraint "time installed" to your cabal-install line)
14:26:55 <notdan> ski_: that's nice and I know about that but it's not going to help me with Data.Map.filter
14:29:49 * hackagebot dapi 0.2.0.0 - Prints a series of dates  http://hackage.haskell.org/package/dapi-0.2.0.0 (OmariNorman)
14:31:13 <ski_> monochrom : alt.  case variant_record'discriminant is when kind_a => ..(variant_record.a_field_0).. ... end case  as in Ada and Pascal
14:32:18 <ski_> notdan : ok
14:32:41 <monochrom> I feel sad that they are the minority
14:33:04 <notdan> Thanks a lot for those posts, ski_, they are both extremely interesting
14:35:07 <LambdaDusk> dmwit: I just refuses to compile it seems
14:36:51 <edwardk> danharaj: did my earlier reply make sense?
14:40:42 <napping> ski_: anyone going to correct that post? needing a primop from HEAD rather raises the bar, but mocking it up by translating through Word# shows exactly no speed gain from unboxing and strictness
14:41:05 <hpaste> nade pasted “mpuz” at http://hpaste.org/85061
14:41:44 <nade> Hey all, I'm attempting to learn haskell, and have been trying to reimplement the EMACS mpuz game.
14:42:37 <nade> I've been running into a problem, namely in the "showStatus" function, where I cannot coerce an IO Integer to an Int.
14:43:05 <nade> I'd really appreciate a look over my code, and some criticism as well as help.
14:43:07 <nade> thanks
14:44:03 <ab9rf> you can't "coerce" an "IO Integer" to an Int.
14:44:10 <nade> err, yeah
14:44:35 <ab9rf> you need to "extract" the value out of the monadic form with a binding operation
14:44:40 <nade> sorry, I realize that ( i think ). How would I put it? Use it in a monad/
14:44:41 <DanBurton> I'm thinking that instead of "let factors = [randomStream ...]" you want "factors <- sequence [randomStream ...]"
14:44:48 <monoidal> nade: hpaste (hlint actually) gives a lot of small tips on the bottom of the paste
14:45:11 <monoidal> nade: putStr "" can be replaced with return ()
14:45:38 <ab9rf> nade: IO is a monadic type.
14:45:54 <ab9rf> it's already in an monad, you want to get it out :)
14:45:54 <nade> Yeah
14:45:59 <nade> oh
14:46:14 <shachaf> ab9rf: You can't "extract" an Int out of an IO Int either.
14:46:25 <shachaf> There's no Int inside an IO Int.
14:46:35 <ab9rf> shachaf: no, not in som many words
14:46:36 <shachaf> @quote /bin/ls
14:46:36 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:46:44 <ab9rf> which is why i put it in scare quotes
14:47:02 <shachaf> But it's still misleading, even with quotes. :-(
14:47:06 <ab9rf> shachaf: shrug
14:47:20 <nade> well if you look at the function "showStatus" I pass a String and a [IO[Integer]]. I for each IO[Integer] I want to print the letters at the corresponding indexes
14:47:25 <otters> where does the Int come from, then
14:47:36 <monoidal> nade:     let factors = [randomStream [0..9] x | x <- [3,2] ]
14:47:44 <DanBurton> shachaf: teaching a proper understanding of monads takes a much longer time than teaching people how to use <- as "extract", deeply flawed though the metaphor is
14:47:51 <ab9rf> nade: you probably don't want to be "passing" IO values
14:48:03 <monoidal> oh, DanBurton already said this, but if you do factors <- ... then factors will have type [Int] and you should be ok
14:48:21 <nade> ab9rf: Should i not think of it as "passing"?
14:48:23 <shachaf> DanBurton: You don't need a "proper understanding of monads".
14:48:40 <nade> monoidal: isn't that what I have?
14:48:45 <shachaf> You can say that you're running a program. This has little to do with monads -- it's just about IO actions.
14:48:55 <ab9rf> is there a pastebin for this discusion?
14:49:07 <monoidal> nade: I mean you need factors <- [randomStream ...]
14:49:14 <monoidal> ab9rf: http://hpaste.org/85061
14:49:42 <ab9rf> danky
14:49:55 <shachaf> There are occasions where saying wrong things to build an approximate intuition with the plan of eventually correcting them later is a reasonable approach.
14:49:59 <monoidal> nade: also instead of "newCode code guess = ... fst guess ... snd guess ..." it's better to do "newCode code (guess1, guess2) = ... guess1 ... guess2 ..."
14:50:00 <ab9rf> ouch, a list of IO objects :)
14:50:16 <shachaf> Empirically, this isn't one of them. This builds an opposite intuition.
14:51:22 <ab9rf> i'm at a loss why shuffle returns an IO [a]
14:51:36 <nade> monoidal: sorry I don't understand
14:51:46 <monoidal> nade: doWithInput is already a library function, liftM
14:51:46 <monoidal> nade: that guess thing?
14:51:52 <ab9rf> it seems that IO gets introduces way deeper in this code than necessary
14:52:27 <nade> monoidal: yeah
14:52:29 <ab9rf> i suppose you can thread IO through the entire app if you want, and do a lot of lifting
14:52:43 <DanBurton> nade: I suggest the following: showStatus :: [Char] -> [[Int]] -> IO (); game :: [Char] -> [[Int]] -> IO (); and go from there
14:52:45 <nade> ab9rf: heh, not intentional...
14:52:56 <monoidal> nade: your function "newCode code guess" uses "fst guess" and "snd guess". instead, it's better to use pattern matching
14:53:12 <ab9rf> nade: try to push the IO out as far as you can
14:53:19 <monoidal> nade: for example, instead of writing "addPair x = fst x + snd x" in Haskell it's idiomatic to write "addPair (x,y) = x + y"
14:53:34 <nade> monoidal: ah I see
14:54:12 <nade> DanBurton: Okay, I'll give that a shot. Should I reconsider how I'm shuffling? Admittedly, I took it off the haskell wiki...
14:54:13 <shachaf> Note that those functions are subtly different.
14:54:35 <ab9rf> :t \(x,y) = x+y
14:54:36 <lambdabot> parse error on input `='
14:54:38 <DanBurton> nade: randomStream does seem a bit odd
14:54:41 <ab9rf> :t \(x,y) -> x+y
14:54:42 <lambdabot> Num a => (a, a) -> a
14:54:54 <ab9rf> :t \x -> fst x+ snd x
14:54:55 <lambdabot> Num a => (a, a) -> a
14:55:02 <ab9rf> same type at least :)
14:55:07 <shachaf> Same type.
14:55:32 <nade> DanBurton: Well the rationale was to generate a string of Ints to serve as the Factors, and a random String of Characters to map those Factors to
14:55:38 <ab9rf> DanBurton: i think it's because it uses a random number generator from IO
14:55:58 <DanBurton> ab9rf: you think correctly
14:56:16 <monoidal> nade: try to replace "   let factors = [randomStream [0..9] x | x <- [3,2] ]; game code factors" with "factor3 <- randomStream [0..9] 3; factor2 <- randomStream [0..9] 2; game code [factor3, factor2]"
14:56:38 <DanBurton> ^ that sounds right
14:56:49 <ab9rf> i think i concur
14:56:50 <DanBurton> ish
14:57:02 <nade> monoidal: but what if I wanted to change the size of factors, or the number of factors?
14:57:30 <nade> monoidal: create a specialized function to do so?
14:57:30 <monoidal> nade: in this case, you need to execute several things in the monad
14:57:39 <DanBurton> let numFactors = 9; ... [0 .. numFactors] ... [0 .. numFactors]
14:57:53 <DanBurton> standard magic number refactoring
14:57:58 <monoidal> nade: there's a "sequence" function that will do it
14:58:20 <monoidal> nade: "do factors <- sequence [randomStream [0..9] x | x <- [3,2] ]; game code factors"
14:58:52 <monoidal> nade: the point is, "sequence [x1, x2, ..., xn]" is equivalent to "do a1 <- x1; a2 <- x2; ... an <- xn; return [a1, a2, ..., an]"
14:59:03 <nade> monoidal: Yeah Dan suggested that earlier, and I still ran into problems, but I haven't tried to debug much since
14:59:12 <nade> okay ill give that a shot
14:59:21 <monoidal> nade: once you do this change, it should go smoothly
14:59:48 <monoidal> nade: game will no longer take IO values as factors
14:59:50 <DanBurton> the type signatures for the other things will need to be adjusted as I suggested also, for it to go smoothly
15:00:19 <nade> monoidal: also, something that was bugging me earlier, shouldn't "map fromInteger [0..9]" return something of the type [Num] or similar?
15:00:32 <nade> instead of [Integer]
15:00:38 <DanBurton> @type map fromInteger [0..9]
15:00:40 <lambdabot> Num b => [b]
15:00:42 <ab9rf> nade: fromInteger is polymorphic
15:00:47 <shachaf> Num is not a type. But it sounds like it would be Num a => [a]
15:00:53 <monoidal> nade: there's no point in using fromInteger on literals
15:00:57 <shachaf> Bute note that [0..9] is already polymorphic.
15:00:58 <monoidal> ummm sorry here it is
15:01:14 <DanBurton> @type (map fromInteger [0 .. 9] :: [Int]) -- You can ascribe the desired numeric type if you want
15:01:16 <lambdabot> [Int]
15:01:23 <shachaf> But note that your own Num type may have a different Enum instance from Integer, so maybe it's still worthwhile.
15:01:41 <monoidal> nade: problem is, [a..b] requires Enum instance
15:02:15 <monoidal> @type [0..9]
15:02:16 <lambdabot> (Enum t, Num t) => [t]
15:02:49 <nade> monoidal: are you referring to when I say " ['a'..'j']?
15:03:03 <shachaf> > length $ (map fromInteger [12345678912345678..12345678912345700::Integer])
15:03:05 <lambdabot>   23
15:03:06 <ab9rf> @type ['a'..'j']
15:03:07 <lambdabot> [Char]
15:03:07 <shachaf> Er.
15:03:15 <shachaf> > length $ (map (fromInteger :: Integer -> Double) [12345678912345678..12345678912345700::Integer])
15:03:17 <lambdabot>   23
15:03:21 <shachaf> > length $ ([12345678912345678..12345678912345700::Double])
15:03:25 <lambdabot>   mueval-core: Time limit exceeded
15:03:27 <shachaf> ☝ for instance
15:03:42 <monoidal> nade: [0..9] works on things that are Num *and* Enum
15:03:56 <monoidal> nade: if your type has both instances, you don't need fromInteger
15:03:57 <nade> oh
15:04:02 <nade> okay
15:04:05 <nade> i see
15:04:13 <shachaf> monoidal: Maybe.
15:04:23 <shachaf> As mentioned the instance could be different from the Integer instance.
15:04:44 <monoidal> shachaf: agreed, I glossed over this
15:05:13 <jfischoff> ☝is 261d for those who were wondering ;)
15:05:28 <ab9rf> what does it look like, i get a replacement char
15:05:47 <jfischoff> ab9rf: hand pointing up
15:06:06 <jfischoff> like ^
15:06:39 <dEPY> ♥
15:06:42 <ab9rf> jfischoff: ah
15:08:32 <nade> hmm... should i avoid running my code with "runhaskell"? I've been getting "= mpuz.hs: Prelude.read: no parse" after entering the getGuess function
15:08:52 <merijn> nade: You should avoid using read :)
15:08:55 <monoidal> nade: using runhaskell should not cause this
15:09:13 <monoidal> nade: but in general it's better to use ghc
15:09:14 <nade> well the reason I ask is because I've been experiencing a lot of segfaults lately
15:09:22 <nade> with ghci
15:09:25 <merijn> If you're using GHC 7.6 you should use readMaybe from Text.Read, if you're using something older you should be using reads and pattern match
15:09:40 <nade> and runhaskell will quit quitely
15:10:50 <ab9rf> nade: you have pretty vague typing in getGuess, too
15:11:04 <ab9rf> hm, i guess getChar is IO Char, isn't it?
15:11:12 <merijn> Correct
15:11:19 <ab9rf> i don't lie doing IO :)
15:11:22 <ab9rf> like
15:11:45 <ab9rf> erf, read [number]?
15:12:13 <nade> merijn: apparently i'm using 7.4
15:12:16 <monoidal> ab9rf: it's used like read ['3'] == read "3" = 3
15:12:22 <merijn> :t reads
15:12:23 <lambdabot> Read a => ReadS a
15:12:28 <merijn> eh...
15:12:34 <merijn> That's not the right function...
15:12:35 <monoidal> ab9rf: although there should be a function specially for reading digits
15:12:41 <ab9rf> the compiler will get Read :: Int from the function signature of IO Guess
15:13:30 <monoidal> nade: standard practice is compiling with ghc and running resulting executable
15:13:32 <ab9rf> i really prefer to ascribe a type on invocations of read
15:13:49 <nade> monoidal: okay, ill give that a shot
15:13:53 <ab9rf> rather than relying on the compiler figuring it out as read is so promiscuously polymorphic
15:14:09 <ski_> > (reads :: ReadS Int) "3"
15:14:10 <merijn> oh, wait, yeah that's right
15:14:11 <nade> what is runhaskell doing? Loading the script in the interpreter?
15:14:11 <lambdabot>   [(3,"")]
15:14:30 <merijn> nade: ReadS a = String -> [(a, String)]
15:15:01 <merijn> nade: Which will return either empty list, or a list with one element (a tuple with a and empty string)
15:15:26 <merijn> You can use case to check whether it succeeds and implement your own readMaybe that way (i.e. "Read a => String -> Maybe a")
15:15:31 <nade> so it wouldn't be an IO?
15:15:43 <nade> er
15:15:44 <ab9rf> read isn't an IO operation
15:15:45 <nade> wait
15:15:46 <monoidal> nade: read is not IO
15:15:47 <nade> yeah
15:15:52 <ab9rf> read just parses strings
15:15:54 <ski_> @type readIO
15:15:55 <lambdabot> Read a => String -> IO a
15:15:55 <ab9rf> or tries to
15:16:01 <nade> i was think he meant to change the type on my getGuess function
15:16:05 <ski_> @type readLn
15:16:07 <lambdabot> Read a => IO a
15:16:35 <monoidal> nade: getGuess communicates with environment, its type must have IO somewhere
15:16:42 <nade> yeah
15:16:47 <nade> thats why I asked
15:17:05 <merijn> Where is the paste for this discussion? I'm just blindly contributing xD
15:17:27 <ab9rf> getGuess will except if the user enters anything that can't be read into an Int
15:17:43 <ab9rf> > (read "1" :: Int)
15:17:44 <nade> http://hpaste.org/85061
15:17:45 <lambdabot>   1
15:17:47 <nade> : )
15:17:49 <ab9rf> > (read "x" :: Int)
15:17:51 <lambdabot>   *Exception: Prelude.read: no parse
15:18:01 <nade> ah thats my bug
15:18:04 <ski_> > (reads :: ReadS Int) "x"
15:18:05 <lambdabot>   []
15:18:26 <nade> but in ghci getChar doesn't seem to wait for entry
15:18:45 <nade> it seems like I'm entering "a", and then I press enter when nothing happens
15:18:56 <ab9rf> getChar reads one -character-
15:19:10 <nade> yeah
15:19:10 <nade> .
15:19:14 <merijn> nade: Yes, that's why I said you wanted to use readMaybe to detect when the parse is failing
15:19:16 <ab9rf> if the user enters more than one character the remain characters are still there
15:19:21 <ski_> line buffering vs. no buffering
15:19:24 <ab9rf> include the newline after the character
15:19:30 <merijn> nade: Also, if you want to avoid having to press enter, disable buffering on stdin
15:19:34 <nade> which it doesn't seem to be
15:19:36 <monoidal> nade: in GHCI, import System.IO and do hSetBuffering stdin NoBuffering
15:19:50 * hackagebot yesod-markdown 0.7.2 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.7.2 (PatrickBrisbin)
15:19:52 * hackagebot yesod-comments 0.8.3 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.8.3 (PatrickBrisbin)
15:20:29 <merijn> nade: If you press "a" followed by enter, then your second character (i.e. number) will always be line break, and parsing line break as an int throws the no parse exception :)
15:20:30 <ab9rf> nade: i have to suspect that the secnd getChar is getting a newline character
15:21:17 <nade> merijn: shouldn't it print "=" after I provide "a"?
15:21:28 <ab9rf> if you're expecting a letter on a line by itself, yu need to use getLine and extract the part you want
15:21:47 <ski_> or use `readLn'
15:21:54 <monoidal> nade: line buffering means, getting input (even a single character) gives result only after a newline
15:21:58 <merijn> nade: By default stdin and stdout are line buffered
15:22:08 <merijn> nade: i.e. they don't get read/shown until you encounter a line break
15:22:20 <ab9rf> output is also line buffered, usually
15:22:25 <merijn> nade: To avoid this, use hSetBuffering to make stdin/stdout unbuffered
15:22:32 <merijn> (as monoidal mentioned)
15:22:43 <nade> oh i missed that
15:22:54 <ab9rf> putStr " = " won't actually be displayed until subsequent output genreate sa newline, or the buffer overflows
15:23:24 <ab9rf> or you explicitly flush the output buffer (which i admit i don't know how to do in I)
15:23:25 <ski_> or `hFlush stdout'
15:23:27 <ab9rf> er IO
15:23:33 <ab9rf> that :)
15:23:56 <merijn> nade: It's a common mistake :) The default can be a bit confusing, but it's the same as other languages (except C++, I believe, which flushes if you alternate stdin and stdout, I believe?)
15:24:09 <ab9rf> merijn: don't talk about fight club :)
15:24:18 <merijn> -1 believe in the parenthetical
15:24:34 * ski_ . o O ( `hSuck stdin' )
15:25:31 <jfischoff> what is the status of automatic ffi wrapper generators?
15:25:54 <nade> err. I apologize, but I'm having difficulty. NoBuffering is what?
15:26:12 <merijn> :t NoBuffering
15:26:13 <lambdabot> Not in scope: data constructor `NoBuffering'
15:26:16 <nade> i doesn't get imported with Systtem.IO
15:26:16 <merijn> aww
15:26:26 <merijn> No? That's odd...
15:26:43 <ski_> @index NoBuffering
15:26:43 <lambdabot> System.IO
15:26:58 <merijn> Check your spelling? It works for me in ghci
15:27:02 <nade> well it is in GHCI
15:27:07 <nade> but not when I compile
15:27:08 <merijn> λ :t NoBuffering
15:27:09 <merijn> NoBuffering :: BufferMode
15:27:10 <nade> with ghc
15:27:16 <monoidal> nade: do you have "import System.IO" on top?
15:27:22 <nade> yep
15:27:28 <nade> oop
15:27:30 <nade> s
15:27:33 <nade> nope : )
15:27:34 <ski_> (:
15:27:37 <merijn> :p
15:32:52 <nade> hey thanks for the help everyone. its (mostly) working now
15:33:01 <monoidal> nade: you might try to rewrite showStatus using mapM function
15:33:03 <merijn> \o/
15:33:13 <nade> i have to go now, but I really appreciate your patience... : )
15:33:27 <nade> does the M stand for monad?
15:33:30 <monoidal> yes
15:33:36 <monoidal> mapM is a variant of sequence
15:33:37 <merijn> :t mapM
15:33:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:33:52 <merijn> Actually, you probably want mapM_
15:33:59 <nade> whys that?
15:34:23 <merijn> :t mapM `asAppliedTo` putStrLn
15:34:25 <lambdabot> (String -> IO ()) -> [String] -> IO [()]
15:34:30 <merijn> :t mapM_ `asAppliedTo` putStrLn
15:34:31 <lambdabot> (String -> IO ()) -> [String] -> IO ()
15:34:57 <merijn> basically, since putStrLn has type IO () you end up with an "IO [()]" at the end, which is a bit pointless
15:35:01 <monoidal> nade: for example, mapM_ (\factor -> print (factor + 4)) [2,3,5] will print [6,7,9]
15:35:05 <merijn> mapM_ is mapM that throws away the result
15:35:22 <merijn> i.e. it just returns IO ()
15:35:27 <nade> okay
15:35:47 <merijn> @index asAppliedTo
15:35:47 <lambdabot> bzzt
15:35:51 <merijn> aww
15:36:06 <merijn> @hoogle asAppliedTo
15:36:06 <lambdabot> No results found
15:36:44 <nade> also, placing "hSetBuffering stdin NoBuffering" in my 'main' doesn't seem to have the desire effect. I was looking for a way to have it display "a = " after I press "a"
15:36:56 <nade> similar to the emacs version
15:37:06 <monoidal> nade: hSetBuffering stdout NoBuffering?
15:37:09 <merijn> nade: For output you need to do the same on stdout
15:37:26 <merijn> or call "hFlush stdout"
15:37:29 <nade> :t stdout
15:37:30 <lambdabot> Not in scope: `stdout'
15:37:36 <nade> how does that work?
15:37:41 <monoidal> :t System.IO.stdout
15:37:42 <lambdabot> GHC.IO.Handle.Types.Handle
15:38:06 <nade> :t GHC.IO.Handle.Types.Handle
15:38:07 <lambdabot>     Not in scope: data constructor `GHC.IO.Handle.Types.Handle'
15:38:10 <nade> ok
15:38:11 <nade> i see
15:38:13 <nade> maybe
15:38:17 <Duffers> # wget -P ~/.irssi http://static.quadpoint.org/irssi/fear2.theme
15:38:21 <nade> what is a "Handle"?
15:38:22 <v0|d> fxr: re
15:38:50 <merijn> nade: stdin and stdout internally use the normal C functions to read from those files. The C functions are buffered, i.e. they won't actually read or write anything until you try to read or write a newline
15:39:00 <monoidal> nade: it's like a file descriptor, a name you can use to refer a file (including console standard input/output)
15:39:29 <merijn> nade: Basically, doing a syscall every write is expensive, so it assumes that if you write to stdout, but don't write a newline, then you probably intend to write some more soon, so it buffers
15:39:57 <merijn> nade: You can either write a newline to flush it, or manually flush it using hFlush, or set it to unbuffered mode using hSetBuffering
15:40:21 <nade> okay
15:40:37 <nade> Well I must be going. Thanks again for all your help
15:40:43 <nade> and it works now
15:40:45 <nade> : )
15:40:53 <merijn> Your guessing game isn't going to write a lot, so just disabling buffering is fine for this
15:42:46 <luite> it's the haskell side that does the buffering, it calls the write function, not the C stdio ones
15:45:55 <monochrom> GHC doesn't use too much of C's standard I/O functions. certainly not stdio.h
15:46:19 <monochrom> however, GHC strives to give you similar behaviour as C's stdio.h
15:46:40 <merijn> ok, so maybe I'm wrong about it using them internally, but at least the behaviour is identical :p
15:47:06 <quchen> monochrom: Speaking of C, how much of GHC+platform is actually C calls of sorts?
15:47:27 <quchen> I just found out that sockets are C (haven't thought about that before)
15:47:41 <danharaj> edwardk: sorry to keep bugging you. I've been thinking of what you said but I am not quite sure what 'higher-order' means in this context.
15:47:41 <quchen> Integer is C as far as I know
15:48:06 <monochrom> the runtime is written in C
15:48:09 <danharaj> if you are using GHC with default build options Integer is basically gmp Integers.
15:48:27 <quchen> monochrom: Oh, all of it? I knew there was some "C--" in there, but I thought just some essentials
15:48:28 <monochrom> there is some C code that comes with network and bytestring etc
15:48:58 <monochrom> C-- is just an intermediate thing during compilation
15:49:18 <eikke> monochrom: there's quite some C-- code in GHC RTS as well
15:49:22 <quchen> Oh, so the runtime is actual C? Color me surprised
15:49:39 <eikke> runtime is a mixture of C, C-- and Haskell
15:49:42 <edwardk> danharaj: i figured that was where i was ambiguous =)
15:49:49 <eikke> (in no specific order)
15:49:49 <edwardk> danharaj: 'a function' =P
15:50:22 <danharaj> edwardk: If I squint hard enough I can see how maybe you could send attributes down the list in a fold-like way if you tie the knot somehow but I can't write vagueness into a haskell source file :)
15:50:26 <monochrom> unix is, of course, an elaborate C binding
15:50:30 <quchen> Good to know, thanks guys
15:50:40 <quchen> monochrom: But Unix isn't part of GHC (... is it?) ;-)
15:50:45 <edwardk> danharaj: if i give you an attributed result of type (a -> b), you can pass down the info for the root as the arg 'a', and i push that 'a' down in an inherited fashion in the end i'll bubble up synthesized info as b!
15:50:49 <monochrom> unix comes with GHC, yes
15:51:03 <quchen> Neat.
15:51:17 <quchen> ghc --make-os
15:51:39 <merijn> quchen: That's called "house" :)
15:51:51 <eikke> or halvm
15:51:57 <merijn> Or HaLVM, depending on how barebones you want your OS :)
15:52:19 <quchen> merijn: ..?
15:52:35 <merijn> quchen: house is a bare metal haskell framework
15:52:51 <merijn> http://programatica.cs.pdx.edu/House/
15:53:26 <quchen> Wat
15:53:39 <quchen> (I should be careful what I joke about in the future)
15:54:15 <merijn> quchen: HaLVM is the "Haskell Lightweight Virtual Machine", lets you run code directly in Xen
15:55:22 <quchen> I see
15:55:54 <quchen> So this may be skipping many many steps, but why is the runtime C-- and not Haskell as well then?
15:56:15 <geekosaur> part of the runtime is haskell
15:56:46 <quchen> Alright, let's say "the entirety of GHC"
15:56:49 <danharaj> edwardk: I am having difficulty groking that. Are you suggesting combining inherited and synthesized stuff in one roundtrip?
15:56:51 <geekosaur> but much of it needs to be there for haskell code to work at all, so it needs to be coded in something other than haskell
15:57:20 <quchen> geekosaur: Hm. Something along the lines of a BIOS to prepare the execution of Haskell then?
15:57:39 <quchen> i.e. ASM, generated by C?
15:57:49 <geekosaur> something like. you could think of it as the gears for the STG engine
15:57:57 <merijn> quchen: Haskell has no built in notion of pointers and addresses, this makes it hard to implement memory management in haskell
15:58:11 <edwardk> danharaj: yes, with some lazy knot tying in the value. basically synthesized and inherited attributes become one thing when you have functions as attributes
15:58:34 <merijn> quchen: Since the RTS and low level things like house/halvm require explicit memory management of the hardware writing everything in pure haskell becomes tricky
15:58:43 <danharaj> edwardk: hm I think I am starting to see how it works. Let's see if I can write it down now!
15:58:45 <jfischoff> I wonder if the llvm had been around when Haskell started if C-- would exist.
15:58:50 <quchen> merijn: It certainly makes sense that there's something low-level on the low level
15:59:00 <quchen> So I'm guessing it's mostly the "tricky" part that C solves?
15:59:03 <jfischoff> c-- doesn't seem necessary
15:59:09 <lcfrs> hi, i have a question about the codensity transform by ezyang
15:59:13 <merijn> quchen: This is a thing that Habit is supposed to solve (it's a strict dialect of haskell that has support for explicit memory layout/management)
15:59:13 <hpaste> lcfrs pasted “bar2foo” at http://hpaste.org/85062
15:59:25 <merijn> quchen: (Which is being designed by the same group that worked on house)
15:59:32 <eikke> jfischoff: cmm is quite another level than llvm
16:00:05 <merijn> quchen: Well, there's no reason why a high level language can't have explicit memory layouts, it's just that haskell doesn't and implementing that in C is easier than extending the language
16:00:08 <jfischoff> eikke: go on
16:00:13 <quchen> merijn: Does this have any consequences on the end user of GHC, or is a switch to that only internally relevant?
16:00:27 <quchen> (^ HaBit)
16:00:40 <merijn> quchen: Habit is substantially different from GHC, since it's strict (i.e. not lazy)
16:00:58 <arkeet> (i.e. not non-strict)
16:01:04 <eikke> quchen: as an example, IIRC some time ago I read some draft page on rewriting the RTS scheduler in Haskell (scheduling is in C now IIRC), so things move once in a while
16:01:07 <merijn> quchen: So it's unlikely to ever to be merged into haskell
16:01:13 <quchen> arkeet: I couldn't tell the difference anyway ...
16:01:13 <merijn> arkeet: Well, it's also not lazy :)
16:01:19 <arkeet> :)
16:01:36 <eikke> jfischoff: cmm is to llvm what c is to plain assembly (or llvm, so you want), sort-of
16:01:45 <quchen> You guys and your lazy-vs-non-strict ;-)
16:01:57 <merijn> quchen: The logic is that laziness just makes complexity analysis to hard for programmers, which is important for low level stuff. But they do intend to keep the haskell syntax, typeclasses, etc.
16:02:43 <eikke> quchen: http://hackage.haskell.org/trac/ghc/wiki/LightweightConcurrency
16:02:47 <quchen> That's all very reasonable.
16:02:53 <monochrom> for the purpose of Habit and interfacing with OS and hardward, I'm pretty sure you have to nail down the execution order (e.g., "eager"), and not hide behind the "strict" mere denotational semantics
16:03:05 <merijn> quchen: See http://hasp.cs.pdx.edu/
16:03:09 <monochrom> i.e., you have to go all-out operational
16:03:22 <merijn> monochrom: I think that's the plan, yes
16:03:26 <jfischoff> eikke: not really, because assembly is for a particular machine right?
16:03:29 <arkeet> monochrom: your ops are showing. ;)
16:04:04 <quchen> eikke: There's a black hole in my GHC? First C, then THIS?
16:04:47 <eikke> jfischoff: hence the 'sort of' ;-)
16:04:53 <jfischoff> eikke: c-- supports garbage collection better (from what I have heard), but I think if llvm had been around before, the llvm might just have better garbage collection
16:05:03 <monochrom> I'm pretty appalled that even prominent haskellers say "strict" when operational order is the issue, and "lazy" when operational order is not the issue.
16:05:20 <eikke> llvm doesnt have GC, but has some support for precise GC hooks/annotations
16:05:26 <jfischoff> yes
16:05:35 <jfischoff> that's what I meant
16:06:01 <SlickRick> www.youtube.com/watch?v=dzIrDl8M9RI&feature=plcp&list=PL662B922B97B46B18
16:06:39 <lcfrs> jfischoff: hey question (this is neuman, btw)
16:06:45 <lightquake> what's the use case for a Vector vs a Sequence?
16:06:52 <jfischoff> lcfrs: hey hey!
16:07:04 <lightquake> (boxed Vectors, that is)
16:07:11 <quchen> Anyway, thanks for the explanations merijn/eikke/arkeet/..., bedtime for me now. Will look at the links later :-)
16:07:38 <monochrom> if you say "strict", there are still a few different evaluation orders allowed, and they have different memory behaviours, even asymptotically (O(n) vs O(1)). therefore, when the purpose is to save memory, "strict" is completely beside the point.
16:08:09 <lcfrs> remember that codensity thing i was talking about? i'm trying to apply it in scala, but i'm having a problem understanding the type of "improve"
16:08:21 <c_wraith> lightquake: any case where random access speeds matter, where constant factors in traversal matter, or where Vector's fusion framework matters. And that don't expect to change the size
16:08:42 <jfischoff> hmm that's not something I know much about is there a link?
16:08:53 <c_wraith> lcfrs: edwardk is a huge proponent of codensity, and also a frequent scala user. He might be able to help you out, if he's around
16:09:12 <lcfrs> thanks c_wraith, my q is not scala or codensity specific
16:10:24 <mhf> Why am I getting an infinite loop error in my function simulate here? https://gist.github.com/mfine15/3d58408259563a967621.What it should be doing is adding a record of the interaction to the simulate function with one fewer round, until the number of rounds reach zero. I've also tried writing it as an infinite list, but I also get an infinite loop error there.
16:11:52 <c_wraith> mhf: it's probably somewhere in the code you left out.
16:13:05 <mhf> c_wraith: I just uploaded the entire file to the same gist, if that helps. Thank you.
16:15:30 <lightquake> c_wraith: so if i do need to change the size often, i want a Sequence?
16:16:02 <shachaf> Maybe.
16:16:07 <shachaf> There are also other options.
16:16:26 <shachaf> Sequence has pretty bad constant factors, I'm told.
16:16:31 <danharaj> edwardk: I am stuck on 'pushing down the root value'. Let's say I synthesize an attribute of type (a -> b), and I have an a at the root. The only thing I can do is fmap ($ a), but that seems wrong.
16:16:31 <shachaf> Oh, is someone talking about Codensity?
16:16:38 <shachaf> i love codensity. it is so easy
16:17:49 <c_wraith> lightquake: if you want to avoid the full copy vectors require when you change their size.
16:18:40 <c_wraith> mhf: I can't see the problem offhand. It's *probably* a typo, where something is accidentally defined in terms of itself. There's too much code there to quickly spot it, though.
16:18:45 <edwardk> danharaj: why?
16:18:51 <mhf> okay, thanks for the help
16:19:05 <c_wraith> mhf: in fact, that particular error *always* happens when something is defined in terms of itself, if that's any help
16:19:06 <danharaj> edwardk: Well, I want to push a down to the root's immediate neighbors, and then produce a new value at that level to push to their children and so forth.
16:19:15 <danharaj> At least that is how I am understanding attribute grammars.
16:19:25 <danharaj> s/neighbors/children
16:19:37 <c_wraith> mhf: specifically, it means that when it tried to evaluate something, it discovered it needed to know what it was in order to evaluate it.
16:21:12 <hpaste> Gereeter pasted “Guarded Recursion and Impredicative Polymorphism” at http://hpaste.org/85063
16:22:51 <gereeter> So, I'm trying to implement the ideas in Atkey and McBride's paper on guarded recursion
16:23:04 <gereeter> but seem to be hitting a wall
16:23:33 <c_wraith> the ImpredicativeTypes extension doesn't to much by itself. It requires an incredible number of type annotations to work.
16:23:44 <danharaj> and even then it might just break.
16:24:02 <edwardk> danharaj: they can take the argument and split it up as needed to pass it down
16:24:23 <gereeter> Yes, but I put in a rediculous number of type annotations. Also,
16:24:34 <lcfrs> edwardk: hi edward
16:25:01 <gereeter> the error I get seems to be that it wants forall k0 . De k0 (Stream k0), and is getting forall k . De k (Stream k)
16:25:05 <edwardk> preflex: xseen byorgey
16:25:05 <preflex>  byorgey was last seen on freenode/#haskell 3 hours and 50 minutes ago, saying: http://hackage.haskell.org/package/monad%2Dsupply
16:25:08 <edwardk> preflex: xseen dmwit
16:25:09 <preflex>  dmwit was last seen on freenode/#haskell 1 hour, 59 minutes and 38 seconds ago, saying: LambdaDusk: What's asking for a new version of time? What happens if you add a constraint for the time package? (e.g. add --constraint "time installed" to your cabal-install line)
16:25:25 <lcfrs> i have a question about types used in the codensity transform
16:25:28 <c_wraith> gereeter: yep.  That's a common problem with the extension, as danharaj was hinting at
16:25:37 <lcfrs> wondering if i should pm, or just ask here?
16:26:06 <c_wraith> gereeter: have you tried encoding the impredicative type as a newtype instead? It's a bit more verbose when you use it, but the type checker handles it *way* better
16:26:25 <gereeter> c_wraith: Darn. I'll try that.
16:27:01 <Guest27563> hello, world
16:27:06 <edwardk> preflex: xseen ccasin
16:27:06 <preflex>  ccasin was last seen on freenode/#haskell 1 year, 43 days, 7 hours, 42 minutes and 35 seconds ago, saying: dcoutts: thanks
16:27:19 <edwardk> ccasin: don't talk much, eh?
16:29:00 <glguy> edwardk: Are you trying to trick him into losing his streak?
16:29:09 <edwardk> yes
16:29:22 <monoidal> edwardk: I'd like to look at the ad package, but have heard there's ongoing refactoring. should I wait for the new version?
16:29:28 <c_wraith> I didn't realize this channel was a secret idlerpg
16:29:40 <edwardk> I also wanted to introduce dmwit, byorgey or ccasin to someone and get them to answer some questions about upenn's program. ;)
16:29:56 <edwardk> monoidal: the user experience will be mostly unchanged
16:30:12 <edwardk> monoidal: the implementation will just get faster and some type signatures will simplify
16:30:49 <Guest27563> does anyone have much experience with cabal-dev and time for a few questions? I'm having build issues
16:31:07 <monoidal> thanks
16:31:18 <glguy> Guest27563: IRC works best when you just ask
16:31:19 <lcfrs> Can someone tell me how quux f = bar2foo f in http://hpaste.org/85062?
16:31:23 <danharaj> edwardk: I think I am missing something. Is there a blog post I could look at? I found a monoids talk you gave that mentioned attribute grammars but didn't cover them in the slides.
16:32:17 <Guest27563> I'm trying to use cabal-dev install, but it's telling me that a number of functions from one package are not in scope, when they should be
16:32:23 <Guest27563> cabal install works, but not cabal-dev install
16:32:55 <monoidal> lcfrs: the argument to quux is polymorphic value (forall f. FooLike f => f a). So you can use it for any f, and we put f = Bar.
16:33:19 <Guest27563> I'm wondering if is an issue with name collisions, since many seemingly hidden functions may collide with other libraries, but even if I import just the one library into a file that only uses one function, it fails
16:34:05 <gereeter> c_wraith: Thanks. It worked, though I must say it is really ugly. Do you know if there are any plans to improve ImpredicativeTypes?
16:34:50 <c_wraith> gereeter: no plans I know of. It's a hard problem.
16:35:02 <Guest27563> when I use tab completion in cabal-dev ghci (say, :t Graphics.DrawingCombinators. <tab>), only some of the functions show up and not others
16:35:13 <geekosaur> I think ghc hq has pretty much given up on ImpredicativeTypes?
16:35:35 <c_wraith> last time I mentioned it, SPJ had some ideas, but it didn't sound like he had much motivation to try them.
16:35:39 <monoidal> lcfrs: another example, you can give identity the type (forall a. Num a => a) -> Integer. the function gets a polymorphic value, so it can initialize however it wants
16:35:42 <lcfrs> monoidal: so the type effectively becomes Bar a -> Foo a?
16:36:26 <monoidal> lcfrs: yes. We could also write quux :: (forall f. FooLike f => f a) -> (Foo a, Bar a); quux k = (k, k)
16:36:49 <monoidal> whoops! that should be something different
16:37:36 <monoidal> lcfrs: ah, it's correct. look at the above example, it might clarify something
16:37:39 <gereeter> Ok, bye.
16:38:56 <monoidal> lcfrs: there we put "f = Foo" in the first component, and "f = Bar" in the second component
16:39:17 * lcfrs is still parsing it
16:39:31 <monoidal> lcfrs: in the original example, we put "f = Bar", getting a value of type "Bar a", and use bar2foo to convert it to "Foo a"
16:40:04 <edwardk> danharaj: sadly i haven't written anything up. i learned the trick from someone else, there should be a post somewhere
16:42:04 <lcfrs> monoidal: would quux accept another instance of TreeLike?
16:42:54 <monoidal> lcfrs: you mean FooLike? It takes something that has type forall f. FooLike f => f a
16:43:13 <danharaj> edwardk: The most pertinent paper I could find was by Vene and Uustalu, but they use the Zipper monad to do inherited attributes, not this trick. Also, I found a library with types that make lens look conservative ;) http://hackage.haskell.org/package/AspectAG-0.3.6.1
16:43:23 <lcfrs> monoidal: sorry, yes i meant FooLike
16:43:47 <edwardk> (HasField lprd r (Rule lf hof sc ip l' ho' ic' sp' l'' ho'' ic'' sp''), HUpdateAtLabel lprd (Rule lf hof sc ip l ho ic sp l'' ho'' ic'' sp'') r r') => ComSingle HTrue (Prd lprd (Rule lf hof sc ip l ho ic sp l' ho' ic' sp')) r r'	
16:43:50 <edwardk> what is not to love?
16:44:15 <monoidal> lcfrs: if you define somewhere later say data Baz a = Baz a with instance FooLike Baz, you'll be able to do the same thing
16:44:51 <monoidal> lcfrs: the point is, arguments to quux are extremely restricted: they have to be "universal", work as any instance of FooLike
16:45:03 <mikeplus64> edwardk: there's only been a few times i've seen objective beauty in a haskell snippet posted here
16:45:13 <monoidal> lcfrs: the only way to construct such a value is to use function q
16:45:23 <DrChaos> grr I get so bored
16:45:25 <lcfrs> monoidal: but bar2foo :: Bar a -> Foo a, how would it work for Baz?
16:45:26 <edwardk> bbiab
16:45:37 <DrChaos> I don't want to program in C, and I don't want to do math...
16:45:51 <DrChaos> maybe if somebody could suggest something to do in Haskell I might do it
16:45:57 <monoidal> lcfrs: well, you can't use quux (Baz 2), for example
16:46:46 <lcfrs> monoidal: oh ok, i understand that so far. but what did you mean by "you'll be able to do the same thing"
16:46:57 <otters> what l/anguage was that that edwardk just pasted
16:47:07 <monoidal> lcfrs: cast (forall f. FooLike f => f a) to Baz a
16:47:30 <monoidal> lcfrs: perhaps the situation with Num might be clearer
16:47:59 <monoidal> lcfrs: how to create a value of type Num a => a? The only thing you can do, is use Num's methods - for example, 2 + 3 is such a value
16:48:01 <lcfrs> does that mean for Baz a then, quux f = bar2foo will not compile?
16:48:14 <monoidal> lcfrs: I don't understand the question
16:49:20 <jfischoff> lcfrs: do you mean can you call > quux (Baz "1") ?
16:49:39 <lcfrs> yes
16:49:57 <monoidal> lcfrs: Baz "1" does not have type forall f. FooLike f => f a
16:50:21 <lcfrs> oh... but Bar "1" does?
16:50:21 <jfischoff> you need to pass a polymorphic value to the quux
16:50:22 <monoidal> lcfrs: so that would be a type error. defining that function is correct, calling with Baz is not.
16:50:29 <monoidal> lcfrs: no, it won't either
16:51:59 <monoidal> lcfrs: q "1", on the other hand, has type forall f. FooLike f => f a. You can use it anywhere where Foo String, Bar String, Baz String... is expected.
16:53:13 <lcfrs> sorry... "q"?
16:53:20 <jfischoff> from FooLike
16:53:30 <monoidal> lcfrs: q in your code, method of FooLike
16:53:40 <lcfrs> ok
16:57:14 <lcfrs> monoidal: (thanks for your patience), so quux (q "1") works?
16:57:27 <jfischoff> yep
16:58:14 <monoidal> lcfrs: yes
16:58:45 <lcfrs> then bar2foo (q "1") also works?
16:58:50 <monoidal> lcfrs: yes
16:59:24 <monoidal> q "1" is polymorphic regarding the container. Like number 0 is polymorphic regarding to whether it's Int, Double, or some yet undefined instance of Num.
17:02:17 <lcfrs> monoidal: thank you, i think it's starting to come together
17:07:31 <monoidal> lcfrs: you might revisit "quux :: (forall f. FooLike f => f a) -> (Foo a, Bar a); quux k = (k, k)" again if you did not get it first time. I think it's really instructive
17:07:58 <lcfrs> monoidal: ok i'll ponder that
17:10:36 <shachaf> I,I fmap :: CoYoneda f a -> f a; fmap :: f a -> Yoneda f a
17:14:58 <jfischoff> Just so I can be sure myself; there is no way I could use this function. let test x = x; test :: (forall a. a) -> Int?
17:15:28 <monoidal> jfischoff: no way, except undefined
17:15:32 <jfischoff> right
17:15:35 <shachaf> I,I (>>=) :: m a -> Codensity m a; (=>>) :: Density w a -> w a
17:15:55 <jfischoff> I think that is part of what is confusing about higher ranked types
17:16:08 <jfischoff> you can make functions that compile but can't be used
17:16:36 <monoidal> well, with data Void you can also write absurd :: Void ->
17:17:17 <nilsi> hey guys, how would you do a list comprehension that calculates the union of two sorted lists?
17:17:28 <shachaf> nilsi: Why would you use a list comprehension?
17:17:50 <shachaf> List comprehensions are mostly a gimmick. Most interesting list functions aren't comprehensions.
17:18:05 <nilsi> shanse: im studying for an exam and I am stuck on an old question
17:19:27 <jfischoff> monoidal: I don't understand the value of Void. Why not have a empty decl?
17:21:37 <shachaf> What are some other things like Yoneda and Density that work this way?
17:21:41 <jfischoff> oh haskell 98
17:22:00 <monoidal> jfischoff: are you asking for an application of Void?
17:22:09 <shachaf> Void *is* an EmptyDataDecl
17:22:17 <monoidal> shachaf: you might be interested in http://comonad.com/reader/2011/free-monads-for-less-2/
17:22:28 <jfischoff> right right its a haskell 98 thing
17:22:32 <monoidal> no, it's 2010
17:22:38 <jfischoff> 2010
17:22:39 <jfischoff> yes
17:22:51 <monoidal> anyway I saw an example on stackoverflow (now can't find it)
17:23:03 <ludamad> does anyone strive to not use haskell extensions ? or are they an accepted part of writing haskell ?
17:23:28 <jfischoff> ludamad: they are accepted part of writing haskell
17:23:30 <Clint> someone does
17:23:37 <jmcarthur> i just use extensions that i think are "good" and don't use extensions i think are "bad"
17:23:38 <DanBurton> ludamad: depends on the extension
17:23:40 <shachaf> Some people strive not to use them. Most people use at least some, I think.
17:23:42 <dolio> newtype Void = Void Void.
17:23:50 <monoidal> someone had a game, and a 'move' type. he wanted to restrict moves, and put Void in those contexts
17:23:52 <shachaf> The standardization process is slow, and many GHC extensions are de facto standard anyway.
17:24:08 <monoidal> EmptyDataDecls is supported by virtually all compilers AFAIR.
17:24:15 <jmcarthur> newtype Void = Void (forall a. a)
17:24:18 <danharaj> EmptyDataDecls is Haskell2012
17:24:24 <shachaf> No, it's Haskell2010
17:24:24 <danharaj> er 2010
17:24:26 <monoidal> even hugs
17:24:31 <roshan> Are there some extensions in particular that are widely considered to be "bad" or more trouble than they're worth?
17:24:31 <ludamad> ah
17:24:31 <shachaf> I think "virtually all compilers" is a euphemism for "GHC"
17:24:38 <jmcarthur> not sure where RankNTypes stand as far as getting into haskell proper
17:24:39 <dolio> > case 5 of {}
17:24:41 <lambdabot>   <hint>:1:12: parse error on input `}'
17:24:47 <danharaj> ImpredicativeTypes is considered "bad"
17:24:53 <ludamad> they creeped into my code for sure, its a bit daunting when you're first learning the language
17:24:54 <shachaf> :-(
17:24:55 <monoidal> roshan: DatatypeContexts (that is/will be removed in GHC)
17:24:56 <dolio> RankNTypes is a tough nut to crack.
17:25:04 <ludamad> OverloadedStrings I found really hard not to want to use
17:25:19 <jfischoff> what is the deal with ImpredicativeTypes? Is it useful at all?
17:25:26 <shachaf> Yes.
17:25:30 <shachaf> It just doesn't work.
17:25:38 <jfischoff> so I have noticed
17:25:39 <danharaj> In theory it would be useful. In practice it is broken.
17:25:50 <jmcarthur> jfischoff: ImpredicativeTypes would at least make it more feasible for my Void type above to be a type synonym instead of a newtype
17:26:00 <monoidal> I believe impredicative types have some theoretical issues
17:26:09 <jfischoff> interesting
17:26:13 <monoidal> like Set : Set gives russel paradox
17:26:24 <dolio> Impredicative types aren't Set : Set.
17:26:32 <monoidal> yes, I meant only a weak analogy
17:26:41 <jmcarthur> i wish we would just go ahead and correct ghc's implementation of GeneralizedNewtypeDeriving...
17:26:43 <dolio> No one has been able to prove they're inconsistent yet. :)
17:26:50 <jfischoff> ludamad: most people doing Text heavy code use OverloadedStrings, but its contraversial
17:26:59 <djahandarie> Also who cares about Russell's paradox in Haskell anyways
17:27:01 <danharaj> as opposed to coversial
17:27:18 <dolio> And anyhow, ImpredicativeTypes is just adding a certain thing to an already technically impredicative system, paradox wise.
17:27:20 <shachaf> GHC has, like, BOX :: BOX, man!
17:27:20 <monoidal> http://okmij.org/ftp/Haskell/impredicativity-bites.html - impredicativity + some other things
17:27:30 <frsoares> nilsi: union a b = [ x | x<- a, x < head b] ++ b ++ [ x | x <- a, x > last b ]
17:27:30 <jfischoff> danharaj: :p
17:27:38 <dolio> The real problem is what it messes with inference-wise.
17:27:39 <roshan> The trouble with GeneralizedNewtypeDeriving is with type families?
17:27:49 <jmcarthur> no
17:28:01 <frsoares> nilsi: with pattern matching cases for empty lists
17:28:14 <jmcarthur> the trouble with GeneralizedNewtypeDeriving is that GHC doesn't require that it be possible for you to implement the instance my hand to be able to derive it automatically...
17:28:19 <nilsi> frsoares: Thanks a lot!
17:28:22 <jmcarthur> *by hand
17:28:26 <monoidal> frsoares: really? I think they can intersperse
17:28:45 <monoidal> frsoares, nilsi: consider [0,2,4,6,8] and [1,3,5,7]
17:28:47 <shachaf> jmcarthur: If it first generated an instance by hand and then actually used an unsafeCoerce-style instance, would that be sufficient to be safe?
17:28:57 <shachaf> Or are there cases where it would still be broken?
17:29:19 <frsoares> monoidal: you're right. sleepy mistake.
17:29:35 <jmcarthur> shachaf: i think that would be safe as long as the instance it generated without unsafeCoerce type checks and everything
17:30:33 <roshan> jmcarthur: Does that fix the problem where you have some associated type (like AssocType (C Int) == Int and (AssocType (C (IntNewtype) /= IntNewType)
17:30:37 <jmcarthur> shachaf: i think my preference would be for it to implement it the correct way and then use rewrite rules to make it faster
17:31:20 <dolio> roshan: Yes.
17:31:53 <monoidal> nilsi: you can use frsoares's trick on one list and use recursion, perhaps that's what examiners wanted
17:32:01 <roshan> Ah, yes, you just wouldn't be able to write that by hand either
17:32:12 <jmcarthur> roshan: exactly
17:32:27 <nilsi> monoidal: thanks, will check it out
17:32:31 <monoidal> nilsi: i.e. given (a:as) and bs, you put things before a, then a, then call recursively on as and [b | b <- bs, b > a]
17:33:12 <monoidal> nilsi: anyway comprehensions are incredibly awkward to do this job, even normal concat is hard to write
17:33:21 <monoidal> um I meant ++
17:33:37 <monoidal> ... or I'll take last sentence back
17:33:43 <roshan> Somewhat relatedly, is there a way to actually make newtype zero-cost (so things like fmapping a newtype constructor disappears)
17:34:11 <shachaf> SPJ has some proposals but I don't think they're that great for the way people actually use newtypes.
17:34:13 <jmcarthur> roshan: you mean   newtype Foo a = Foo a   sorts of things?
17:34:21 <shachaf> Also they're mostly broken in the same way GeneralizedNewtypeDeriving is broken.
17:34:24 <monoidal> roshan: unsafeCoerce or http://hackage.haskell.org/trac/ghc/wiki/NewtypeWrappers
17:34:40 <jmcarthur> roshan: in that case, ghc should be very eager to inline fmap anyway, so it should basically be free
17:34:44 <shachaf> He originally made that proposal based on a bug report I filed.
17:35:08 <shachaf> Come to think of it, he asked me to take a look in a Trac comment and I never responded. I probably should.
17:35:08 <roshan> jmcarthur: Yeah, you're right. But with more complicated expressions it might not be
17:35:30 <shachaf> jmcarthur: Eager to inline fmap?
17:35:37 <roshan> I was playing around with Free monads the other day, and making a newtype wrapper around them requires you to do various deep traversals of trees just to change newtypes
17:35:38 <shachaf> Oh, you mean instance Functor Foo
17:35:48 <jmcarthur> shachaf: right, not lists of foos or something
17:35:49 <shachaf> I thought this was about things like fmap Foo :: f a -> f (Foo a)
17:36:04 <nilsi> monoidal: Okey, yea when I read the question again he doesn't explicitly say that we shall use list comprehension so maybe I just misinterpreted the question.
17:36:07 <jmcarthur> for collections of newtypes and such it's different
17:36:23 <jmcarthur> roshan: yeah i misunderstood initially
17:37:04 <jmcarthur> roshan: the problem is that it's not really semantics preserving to do this optimization (plus most known proposals for getting around it are unsafe in ways similar to GeneralizedNewtypeDeriving)
17:37:20 <shachaf> I still want to know what a "minimal" extension that gives you (forall p. p Char -> p Int) -> Void is.
17:37:49 <jmcarthur> shachaf: you mean apart from GADTs + empty case or something?
17:38:02 <frsoares> nilsi: with no list comprehensions is a lot easier, just compare the first elements and always add the smaller, then call recursively.
17:38:15 <shachaf> GADTs gives it to you (you don't even need EmptyCase), and so does TypeFamilies.
17:38:21 <shachaf> But those are both huge extensions.
17:38:26 <roshan> jmcarthur: Yeah, that sounds plausible. I'm reading that "newtype wrappers" proposal to see what they say
17:38:38 <shachaf> I think a conclusion was that Haskell is consistent with either (Is Char Int) or (Is Char Int -> Void).
17:38:46 <nilsi> freiksenet: Ah yea, thanks
17:38:59 <nilsi> frsoares: ah yea thanks
17:39:04 <mapf> what is in the io bind?
17:39:42 <jmcarthur> mapf: black magic
17:40:02 <jmcarthur> mapf: (there is a real implementation we could discuss, but it's not really haskell)
17:40:27 <jmcarthur> mapf: ((that is, it's written in "GHC/Haskell" but is completely non-standard and misleading))
17:40:29 <hpaste> mapf pasted “maybe vs IO” at http://hpaste.org/85065
17:40:39 <dolio> shachaf: I don't think Haskell is powerful enough to determine it, no.
17:41:04 <shachaf> dolio: To determine it?
17:41:08 <mapf> jmcarthur: well I just don't understand the results
17:41:37 <dolio> shachaf: In type theory, that would require something like the pigeonhole principle as well as universes/large elimination.
17:41:38 <mapf> how exceptions is made for exsample
17:42:12 <dolio> Otherwise you can have trivial models where both Char and Int denote singleton sets.
17:42:48 <dolio> And GHC not having dependent types can't really do either of those things.
17:42:57 <shachaf> Isn't there a HoTT thing that gives you (Iso a b -> Is a b), or something along those lines?
17:43:13 <dolio> Right.
17:43:29 <dolio> Also, if Char were 32 bits, there'd be no way to prove it, because of that.
17:43:33 <dolio> But it's only 20-something.
17:43:37 <dolio> I guess.
17:43:45 <monoidal> dolio: is it really that complicated? I think that it's just if you have C1 a1 ... an ~ C2 b1 ... bn where C1,C2 are different heads, then you can derive any constraint c
17:43:46 <shachaf> OK, Is Int8 Word8
17:43:48 <dolio> Oh, unless you're on a 64-bit machine.
17:43:55 <shachaf> GADTs *do* give you (Is Int8 Word8 -> Void)
17:43:56 <dolio> In which case Char would have to be 64-bits.
17:44:02 <shachaf> In GHC
17:45:01 <dolio> monoidal: Well, it depends what type theory you're in exactly. But traditional Martin-loef type theory doesn't let you do stuff like that.
17:46:48 <dolio> Agda probably would, but that's because it's predicated on a lot of assumptions about what is provable beyond bare MLTT.
17:46:58 <dolio> And if you turn those off, it won't work.
17:48:50 <dolio> Plain MLTT is consistent with adding the rule that says 'data Bool1 = True1 | False1' and 'data Bool2 = True2 | False2' are identical types.
17:49:40 <shachaf> And is there a simple axiom you can add that contradicts that?
17:50:29 <tromp_> I have a Parsec question: is it possible to get the unconsumd input from a parse?
17:50:37 <Philippa> yes
17:50:43 <roshan> So this is maybe a silly question, but type inference is carried out before code gets translated into System F, right? So even if all sorts of weird universal quantification shenanigans are expressible in System F, there might not be any way to get them through type inference?
17:50:51 <tromp_> how, Philippa?
17:50:54 <Philippa> there's a function somewhere in (IIRC) the primitives module that gets you exactly what hasn't been consumed
17:51:02 <roshan> (I'm trying to understand the root of the ImpredicativeTypes problem)
17:51:10 <Philippa> I'd only have to RTFM for you, so I'll let you do that yourself
17:53:48 <dolio> shachaf: There is a simple rule that contradicts the general homotopy rule. I don't think it's something that makes sense in GHC, though.
17:55:13 <tromp_> i was reading TFM, and it said runParser is the most general way to run a parser, but I don't see it returning unread input
17:56:00 <dolio> MLTT also denies that 'data Two = Zero | One' and 'data Three = Zero | One | Two' are identical, but I don't know that it would translate into GHC.
17:56:04 <Philippa> tromp_: you're not looking for a run* function, no
17:56:10 <Philippa> it's an action within the parsing monad
17:56:34 <tromp_> oh
17:56:46 <jmcarthur> i would expect a run function to be able to do it too
17:57:22 <Philippa> jmcarthur: it's not part of Parsec's original intended use model though, which is why it doesn't
17:57:35 <dolio> Also, there are subtheories of MLTT where you can't prove that the constructors of Two are distinct. And what you have to add is a way to do case analysis on Two to produce a type somehow.
17:58:06 <dolio> Which, if you move it up to proving that two types are distinct, requires you to do case analysis on types, which is one thing TypeFamilies allow.
18:00:04 <tromp_> i can of course do ...<*> many anyChar but i need to be lazy in the rest of input
18:03:01 <monochrom> getInput
18:03:01 <Philippa> monochrom: cheers
18:03:02 <tromp_> thx, monochrom
18:04:55 * hackagebot scgi 0.1.0 - Simple SCGI Library  http://hackage.haskell.org/package/scgi-0.1.0 (ChrisForno)
18:10:58 <lightquake> @unmtl ReaderT Foo (State Bar) ()
18:10:58 <lambdabot> Foo -> Bar -> ((), Bar)
18:11:14 <lightquake> @unmtl StateT Bar (Reader Foo) ()
18:11:14 <lambdabot> Bar -> Foo -> ((), Bar)
18:13:33 <roshan> Hah, lambdabot never ceases to amaze me
18:16:00 <roshan> @unmtl StateT Bar (ContT Foo (Maybe Baz))
18:16:01 <lambdabot> Plugin `unmtl' failed with: `StateT Bar (ContT Foo (Maybe Baz))' is not applied to enough arguments, giving `/\A. Bar -> (A -> Bar -> Maybe Baz Foo) -> Maybe Baz Foo'
18:16:22 --- mode: monochrom set -b *!*@187.65.192.206
18:16:30 <roshan> @unmtl StateT Bar (ContT Foo (Maybe)) Baz
18:16:30 <lambdabot> Bar -> (Baz -> Bar -> Maybe Foo) -> Maybe Foo
18:16:41 --- mode: monochrom set -o monochrom
18:16:53 <sw2wolf> morning
18:17:03 <jef_> morning
18:17:08 <hpaste> “Anonymous Coward” pasted “faster mutable state monad?” at http://hpaste.org/85067
18:17:18 <mikeplus64> oops forgot the author field
18:18:39 <sacundim> can somebody give me some pointers on liyang's comment in this thread: http://www.reddit.com/r/haskell/comments/1bg21c/so_i_accidentally_a_profunctors_tutorial/c96sfmx
18:18:54 <mikeplus64> the mutable version runs about 1/2 of the pure state one for me
18:19:11 <mikeplus64> and the ordinary function runs much faster than either
18:19:50 <sacundim> and by pointers, I mean "look at this haddock and this one"
18:19:53 <mikeplus64> i wonder why that is?
18:24:13 <jmcarthur> mikeplus64: for one it's going to be much harder to optimize an expression with side effects than one without side effects
18:24:40 <jmcarthur> mikeplus64: or did i misunderstand?
18:24:50 <jmcarthur> mikeplus64: did you mean the mutable one is faster or slower than the pure one?
18:25:30 <mikeplus64> jmcarthur: the mutable one is faster than State, and slower than the normal function
18:25:36 <mikeplus64> that explicitly passes around state
18:26:15 <mikeplus64> i guess in the pure one ghc "knows" it's safe to just mutate the one copy of State in the loop?
18:28:31 <jmcarthur> mikeplus64: at first glance it is not clear that your pure implementations are forcing the state as they go at all
18:29:56 * hackagebot matrix 0.2.1 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.2.1 (DanielDiaz)
18:31:24 <jmcarthur> ugh. somehow i don't have criterion installed
18:34:26 <dcoutts_> quick guess: in the table of most frequently occurring words in cabal package descriptions, where do you think 'haskell' occurs?
18:35:11 <dmwit> Right after the usual stop words like "the", "on", "a"...
18:35:18 <dcoutts_> I should note that I'm calculating frequency by only counting 1 occurrence in any package
18:35:24 <tromp_> i'm a little confused by Parsec types
18:35:35 <dcoutts_> so multiple 'a', 'the' etc in one package only count once
18:35:47 <roshan> mikeplus64: I'm having trouble compiling your code
18:35:47 <tromp_> i can typecheck    head <*> many (char '0')
18:36:03 <tromp_> so which <*> is that using?
18:36:20 <dcoutts_> dmwit: any other guesses at our non-standard stop words?
18:36:34 <mikeplus64> roshan: what trouble?
18:36:39 <mikeplus64> maybe i mispasted something
18:36:58 <dmwit> dcoutts_: Oh, hm. Maybe "instance", "class", "type", "data"?
18:37:08 <roshan> mikeplus64: Maybe different GHC versions
18:37:16 <no-n> which is better to use: map snd xs, or, snd unzip xs
18:37:19 <dcoutts_> dmwit: this is from package descriptions, so it's library and package
18:37:22 <mikeplus64> roshan: i mean, what's the error
18:37:23 <dmwit> But I'm always bad at these things.
18:37:25 <dmwit> aaah
18:37:30 <roshan> mikeplus64: It says Ref is applied to too many type arguments (for Ref m a)
18:37:30 <dcoutts_> 10 1280: library
18:37:31 <dcoutts_> 11 1212: package
18:37:31 <dcoutts_> 12 1171: haskell
18:37:45 <mikeplus64> i'm on ghc 7.6.1
18:37:45 <dmwit> heh
18:37:56 <jmcarthur> mikeplus64's code builds fine for me
18:38:13 <hpaste> jmcarthur annotated “faster mutable state monad?” with “faster mutable state monad? (annotation)” at http://hpaste.org/85067#a85068
18:38:24 <ludamad> Why is show $ PortNum 8080 -> 36895 ??
18:38:30 <jmcarthur> mikeplus64: ^^ now the pure state monad is almost as fast as the non-monad one
18:38:32 <dmwit> tromp_: Are you sure? That doesn't typecheck here.
18:38:37 <mikeplus64> jmcarthur: neat
18:38:58 <geekosaur> ludamad: network byte order
18:38:59 <jmcarthur> mikeplus64: and apparently ghc picked up on the non-monad one's strictness already, so that bang i added is redundant in this case
18:39:07 <dmwit> tromp_: Perhaps you meant to type "head <$> many (char '0')" in-channel?
18:39:08 <dcoutts_> other non-standard ones in the top 50: provides, data, functions, type, simple, code, module, file, interface
18:39:11 <ludamad> ah
18:39:19 <geekosaur> it's ... confusing
18:39:22 <tromp_> oh, i got <*> and <$> mixed up:( sorry
18:39:42 <ludamad> geekosaur: So what should I use to get the intended effect ?
18:39:55 <dcoutts_> dmwit: as you might guess, I've been thinking about how to improve the hackage search
18:40:04 <tromp_> ok, now it makes sense
18:40:07 <mikeplus64> jmcarthur: weird that the mutable one is so slow then
18:40:12 <geekosaur> what was your intended effect? (note that a number of people consider that behavior a significant misdesign)
18:40:15 <jmcarthur> mikeplus64: nah that doesn't surprise me at all
18:40:21 <mikeplus64> why?
18:40:27 <ludamad> geekosaur: the port 8080
18:40:27 <jmcarthur> mikeplus64: it has more indirection and is harder to optimize
18:40:46 <monochrom> dcoutts_: then it seems we should add "for electronic computers" to more package descriptions so that it's more like: 8: computer, 9: electronic, 10: library, 11: package, 12: haskell
18:41:07 <mikeplus64> jmcarthur: what makes it have "more indirection"?
18:41:35 <ludamad> geekosaur: Unless this is 8080 and its lying ?
18:41:38 <ludamad> hm
18:41:57 <dcoutts_> monochrom: :-)
18:41:59 <jmcarthur> mikeplus64: the mutable reference itself is another layer of indirection, and i bet ghc can't remove it
18:42:30 <dmwit> dcoutts_: So, does hackage search do Hoogle-like things?
18:42:39 <roshan> mikeplus64: Is modifyIORef' in the library?
18:42:45 <mikeplus64> jmcarthur: wouldn't it use a mutating copy of State for the pure versions anyway?
18:42:51 <mikeplus64> roshan: it's in Data.IORef
18:42:53 <geekosaur> I have no idea how you're supposed to do it except by cheating
18:42:58 <jmcarthur> mikeplus64: with the pure implementations, ghc can just unbox everything for the duration of the computation
18:42:59 <mikeplus64> roshan: what ghc do you use?
18:43:15 <roshan> mikeplus64: 7.4.2
18:43:17 <jmcarthur> mikeplus64: no
18:43:23 <dmwit> dcoutts_: Well, even something very simple would be pretty useful: just searching for identifiers defined by a (library) package.
18:43:26 <jmcarthur> mikeplus64: ghc is not adding mutation here
18:43:29 <dmwit> Though I admit this is a pretty hard thing to do.
18:43:57 <jmcarthur> mikeplus64: there's not really anything to add mutation to in the first place. it's probably not writing intermediates out to the heap in the pure versions at all
18:44:04 <geekosaur> asi I said, widely considered to be misdesigned
18:44:16 <dcoutts_> dmwit: no we're currently looking at searching for packages, rather than searching for functions etc, and only using package meta-data (cabal file, tags, with some ranking based on rev deps and downloads)
18:44:28 <jmcarthur> mikeplus64: whereas the one with explicit mutation has to actually perform the mutation on the heap every time you update it
18:44:40 <mikeplus64> ok
18:44:49 <geekosaur> Prelude Network.Socket> PortNum $ fromIntegral $ PortNum 8080 -- since I know it's 2-byte and byteswapped
18:44:49 <geekosaur> 8080
18:45:02 <roshan> mikeplus64: Ah, it was added in a later version, but it's not in the GHC for the latest Haskell Platform
18:45:16 * dmwit nods agreeably
18:45:19 <mikeplus64> roshan: oops
18:45:20 <dcoutts_> dmwit: hoogle serves a slightly different purpose, though a really good implementation of package search might look more like hoogle in that it'd use package contents in the search too
18:45:26 <ludamad> geekosaur: ha. OK, tyvm
18:45:37 <jmcarthur> mikeplus64: ghc will not generally add mutation to pure code
18:45:44 <dmwit> Since Hoogle and Hayoo exist, that seems like a lower priority, though, yeah.
18:45:52 <dcoutts_> dmwit: right, that too
18:46:03 <jmcarthur> mikeplus64: (some library might make it do so via rewrite rules, but that just depends on the library)
18:46:17 <sw2wolf> @hoogle @unmtl
18:46:18 <lambdabot> Parse error:
18:46:18 <lambdabot>  
18:46:18 <lambdabot>   ^
18:46:26 <sw2wolf> @hoogle unmtl
18:46:26 <lambdabot> No results found
18:46:52 <jmcarthur> mikeplus64: and as you can see, it's not always a win to use mutation anyway ^_^
18:47:38 <jmcarthur> mikeplus64: another reason mutation isn't helping here is that you *still* have to construct the new state every time you update it
18:48:05 <jmcarthur> mikeplus64: because the old state could still be used even though it is no longer pointed to by the ref
18:48:16 <jmcarthur> (although in this case it is dropped immediately)
18:49:05 <roshan> mikeplus64: Anyway, the older GHC also requires some other changes, but running your code I don't see a significant difference between the State version and the pure version (at -O2)
18:49:24 <jmcarthur> roshan: are you using his version or mine?
18:49:28 <mikeplus64> yeah there is no "significant" difference between any of them roshan
18:49:53 <roshan> jmcarthur: Ah, right, I think I was using yours
18:50:08 <jmcarthur> roshan: in the original version, the state monad one was 10 times slower than the non-monadic one, on my machine
18:50:15 <roshan> mikeplus64: I meant significant wrt to the standard deviation
18:50:20 <mikeplus64> jmcarthur: it was only 2x on mine
18:50:45 <mikeplus64> wait i mean the mutable -> pure state
18:50:57 <jmcarthur> ah
18:50:59 <mikeplus64> uh oops nevermind the last 2 lines
18:51:00 <mikeplus64> lol
18:51:16 <jmcarthur> mikeplus64: yeah, mutable vs. pure state was a factor of two for me, too
18:51:48 <ludamad> geekosaur: My server lives ! I owe you a beer.
18:51:49 <jmcarthur> mikeplus64: btw, the llvm backend gets this benchmark even better
18:51:58 <ludamad> Got it working on OpenShift, yay
18:52:28 <jmcarthur> mikeplus64: well, for the pure versions. the one with mutation does even worse with llvm
18:52:35 <roshan> mikeplus64: jmcarthur I can confirm all this, for what it's worth :)
18:52:59 <sw2wolf> How to make ghc use llvm backend in FreeBSD ?
18:53:21 <tromp_> :t <$
18:53:23 <lambdabot> parse error on input `<$'
18:53:31 <dmwit> :t (<$)
18:53:32 <lambdabot> Functor f => a -> f b -> f a
18:53:39 <jmcarthur> sw2wolf: if the ghc on FreeBSD supports the llvm backend at all you should be able to just pass -fllvm (assuming you have llvm installed)
18:53:55 <tromp_> :t ($>)
18:53:56 <lambdabot>     Not in scope: `$>'
18:53:56 <lambdabot>     Perhaps you meant one of these:
18:53:56 <lambdabot>       `$' (imported from Data.Function), `$!' (imported from Prelude),
18:54:05 <ludamad> is the native-code backend the default ?
18:54:14 <shachaf> Yes.
18:54:15 <sw2wolf> jmcarthur: how about using cabal ?
18:54:42 <jmcarthur> sw2wolf: there's some build-options field to pass compiler flags on. not sure if that's the name or something else
18:54:47 <mikeplus64> jmcarthur: huh, with llvm the pure state monad and pure function get the same mean time
18:55:02 <jmcarthur> mikeplus64: that seems roughly true for me, too
18:55:11 <Apocalisp> So in transliterating a mathematical formula to Haskell, what's a good strategy for verifying that I've done it correctly?
18:55:16 <sw2wolf> jmcarthur: thx, i will search it
18:55:17 <roshan> mikeplus64: Also, this doesn't affect you, but apparently on older versions of GHC type synonyms can't be curried, so you have to say "type Ref m a" and "type Ref (ST s) a = STRef s a" and so on, in case you're interested
18:55:46 <mikeplus64> lame
18:56:05 <jmcarthur> roshan: that's not right
18:56:15 <jmcarthur> roshan: it should be doable
18:56:19 <jmcarthur> even on old ones
18:56:55 <roshan> For me, ghc 7.4.2 complained about mikeplus64' code (about Ref having too many arguments) but worked when I changed it to that
18:57:23 <mikeplus64> what if you tried (Ref m) a?
18:57:29 <roshan> That didn't work either
18:57:32 <mikeplus64> weird
18:57:39 <roshan> And this is only for defining them, not for using them
18:57:47 <mikeplus64> oh
18:58:36 <roshan> I think I read in the GHC docs that if you say class Foo where … type Bar, ghc assumes that Bar has kind *
18:58:53 <roshan> But that was probably in the docs for my version
18:58:56 <mikeplus64> oh, perhaps it needs to be type Ref m :: * -> *
18:59:06 <roshan> mikeplus64: Yeah, that would work
19:05:37 <jmcarthur> mikeplus64: btw, the core that ghc generates for both pure versions is almost identical except that the state one performs one of the steps earlier and includes an extra unit value in the result that it just throws away (but only once, not 1000 times)
19:06:09 <jmcarthur> mikeplus64: in my version, that is
19:06:46 <jmcarthur> mikeplus64: i'll paste it for you
19:06:54 <mikeplus64> ok
19:07:38 <hpaste> jmcarthur annotated “faster mutable state monad?” with “faster mutable state monad? (annotation) (annotation)” at http://hpaste.org/85067#a85069
19:08:05 <jmcarthur> mikeplus64: $wgo_r1VA is the main loop of the pure one
19:08:21 <jmcarthur> and $s$wa_r1Vz the main loop of the state monad one
19:08:50 <jmcarthur> as you can see, it doesn't even create that State object every time. just passes the fields around directly
19:09:06 <mikeplus64> neat
19:09:44 <jmcarthur> i forced ghc to not inline those functions so that i could get a pretty output. i think it would normally inline them
19:09:47 <jmcarthur> oh wait
19:09:51 <jmcarthur> not, it can't, since they are recursive
19:09:53 <mikeplus64> i don't have time atm, but maybe try a dumber definition of State and dec; without the {-# UNPACK #-}s and strictness
19:09:55 <jmcarthur> *no, it can't
19:10:01 <mikeplus64> and {-# NOINLINE dec #-}
19:10:18 <jmcarthur> to what end? just to see what it does?
19:10:49 <mikeplus64> so the update done to the State thing is the same for all of them
19:11:03 <jmcarthur> ah, in an attempt to favor the mutation?
19:11:10 <mikeplus64> yup
19:11:37 <jmcarthur> i suspect it will be harder than that to fool it
19:11:49 <jmcarthur> the lack of strictness is going to be the best bet, i guess
19:11:55 <mikeplus64> or just compile with -O0
19:11:58 <jmcarthur> the UNPACK almost doesn't matter since it doesn't construct it anyway
19:12:12 <jmcarthur> -O0 is pretty meaningless :P
19:12:19 <jmcarthur> in that nobody really uses it anyway
19:12:41 <jmcarthur> and "unoptimized" haskell is awfully slow
19:13:47 <sw2wolf> `ghc -fllvm --make xmonad.hs` succeeds with a bit larger executable than `ghc --make xmonad.hs` .
19:22:53 <ctult> What is Haskell's speed comparable to on average?
19:23:28 <shachaf> A speeding bullet.
19:23:31 <luite> to a tortoise or a hare
19:23:39 <ctult> (e.g. a high-level language like Python, Ruby, or Javascript, a VM like the CLR or the JVM, or low-level like C)
19:23:57 <shachaf> Haskell is a language, and languages don't have speeds.
19:24:18 <shachaf> You can't really hope for a better answer than "it depends", anyway.
19:24:29 <ludamad> ctult: I think the real answer is, you can write haskell code that is close enough to C performance
19:24:30 <ctult> A reasonably-optimized game's speed compared to C.
19:24:46 <ctult> ludamad: That is what I wanted to know.
19:24:47 <ludamad> so, you can do real work without leaving the language
19:24:51 <roshan> ctult: Python and Javascript usually have orders of magnitude difference
19:24:52 <shachaf> I don't know if that's the real answer.
19:24:55 <byorgey> ctult: if you know what you are doing you can often get speeds comparable to C.  If you just write some naive code the speed can be all over the map.
19:24:57 <ludamad> ok
19:25:02 <ludamad> hand-wavey answer
19:25:05 <ctult> roshan: JS is usually faster than Python
19:25:19 <roshan> ctu:Yeah :)
19:25:39 <sw2wolf> keep in mind: A reasonably-optimized haskell program will lose its elegancy :)
19:25:52 * shachaf sighs.
19:26:06 <ctult> Is Haskell a good platform for making a game?
19:26:22 <ctult> I would also need to implement some sort of VM so that mods could be supported.
19:26:32 <ctult> like an OpenGL game
19:26:39 <ctult> ~10,000 polys
19:26:40 <ludamad> ctult: Can always script with Lua
19:27:01 <ludamad> the opengl bottleneck wont be cpu
19:27:22 <ludamad> (I mean w.r.t haskell)
19:27:47 <Ralith> the number of polygons you are rendering and the language you write your engine in are completely independent factors in determining the performance of your product
19:27:52 <djahandarie> shachaf, I think no one took your answer seriously because it almost went over the "being pedantic for a good reason" -> "being pedantic to give people a hard time" line.
19:28:16 <shachaf> djahandarie: OK.
19:28:24 <shachaf> By almost maybe you mean actually. :-)
19:28:38 <shachaf> But I object to most of the other answers people are giving.
19:28:47 <djahandarie> Yeah, I object to their answers as well. OBJECTION!
19:28:48 <ctult> Are you telling me that if I ended up making my game in PHP, the bottleneck _wouldn't_ be PHP?
19:29:08 <roshan> ctult: If you did enough work on the GPU, no
19:29:08 <Ralith> no.
19:29:10 <ludamad> ctult: if you properly batch polygon operations
19:29:23 <ludamad> it could very well not matter
19:29:31 <Ralith> I'm telling you that the number of polygons does not in and of itself have any bearing.
19:30:00 <jmcarthur> ctult: most people who make games do not require much from the language they use
19:30:02 <ludamad> Gah. Damn OpenShift only lets you use port 80, I'll have to rewrite my thingy to use HTTP =/
19:30:47 <shachaf> djahandarie: Well, the channel has reached a critical mass of people who aren't me.
19:31:02 <djahandarie> ctult, you may not hear this in the storm of answers, but the only performance issue you may have with Haskell in game programming is garbage collection during your rendering loop. But honestly that is not even too big of a problem on new versions of GHC (the popular Haskell compiler).
19:31:03 <roshan> ctult: imho, unless you're making an AAA title that will stress-test computers that won't be invented for three years, I would decide based on which language is better to use
19:31:27 <roshan> ctult: And Haskell might win on that, but there's also the question of utility libraries and such
19:31:52 <ctult> As a first-time game developer and only an intermediate Haskell programmer, would it be a good language for my first game?
19:32:12 <ctult> I probably will not need that much performance out of my game, anyway.
19:32:22 <djahandarie> It'll be fun to make it for sure.
19:32:24 <jmcarthur> for performance i wouldn't be concerned
19:32:39 <djahandarie> Yeah, performance-wise there's really no issue IMO.
19:32:39 <kvda> someone was making an interesting 2d/3d cross game in haskell
19:32:46 <jmcarthur> for learning to make games for the first time using a language you are okay but not super comfortable with... that's your call
19:32:53 <kvda> i'll see if i can dig it up
19:32:56 <ctult> Would I have a lot of wtfs and pain?
19:33:08 <ludamad> ctult: Depends how much you like programming
19:33:08 <ludamad> :-)
19:33:33 <ctult> I made a concept in Python, but I honestly don't know if I should stick with it given my comparative knowledge of Haskell.
19:33:39 <ctult> or lack thereof
19:33:44 <roshan> ctult: For the libraries issue, maybe more pain than writing in Python, but less than in JS or PHP
19:33:56 <djahandarie> ctult, yes, probably, re: wtfs. Most of the graphics libraries in Haskell are extremely imperative (because they're just simple bindings for the most part).
19:34:37 <djahandarie> So you won't be in super-fun everything-is-a-Fibonacci-function Haskell-land, but it'll still be better than fully imperative languages, IMO.
19:35:03 <jmcarthur> but that point only applies if you have drunk the haskell-is-a-superior-imperative-language koolaid
19:35:10 <ctult> djahandarie: I can get rid of the OpenGL non-functional cruft pretty quickly.
19:35:19 <djahandarie> jmcarthur, yup.
19:35:28 <djahandarie> I personally have. Good koolaid that is.
19:35:33 <jmcarthur> indeed :)
19:35:44 <jmcarthur> but it admittedly takes time to get over that hump
19:35:53 <djahandarie> Yeah.
19:36:15 <ctult> I think it would be easier to write it in Python, not because of the language itself, but because of the VM.
19:36:23 <djahandarie> ctult, I'm not sure how you intend on doing that, it's not terribly easy IMO, because otherwise someone would have just written a library to do it in general
19:36:26 <jmcarthur> what does the VM have to do with it?
19:36:29 <djahandarie> (Re: getting rid of cruft)
19:36:32 <ludamad> jmcarthur, moddability
19:36:41 <ludamad> was one of his goals
19:36:46 <ctult> djahandarie: It would be a high-level type of thing.
19:38:21 <ctult> Is there a haskell dynamic bytecode compiler sort of thing?
19:38:30 <djahandarie> Anywho, the usual argument for "Haskell is the best imperative language" is that the imperative things get as sectioned-off as possible, and you can still do some equational reasoning and such with them to a much higher degree than you can do with other languages.
19:38:59 <jmcarthur> ctult: there are ways to load haskell code dynamically, but it's not as convenient as in python, for sure
19:39:59 <ctult> :/
19:40:15 <ctult> I WANT to use Haskell, but I don't think I CAN.
19:40:28 <ludamad> ctult, sounds like you
19:40:36 <ludamad> 're hammering with a screwdriver, then
19:41:14 <ctult> ludamad: But it's a very good screwdriver, and if I could just find the hammer attachment...
19:41:25 <ludamad> ctult: Sure, you can embed a scripting language
19:41:26 <roshan> ctult: I would say when you start using a language, picking it over other languages is a suboptimal choice, but if you don't make that choice it will always remain the suboptimal choice
19:41:33 <ludamad> if you want to use _some_ haskell at all
19:42:13 <djahandarie> ctult, I think the real point is if you're willing to work around certain annoying kludges, you can reap the benefits of Haskell (lots of type safety, easy equational reasoning, etc.) for large swabs of your program.
19:42:26 <arkeet> there are things like hint that let you load haskell code at runtime (although ghc needs to be installed on the target).
19:42:27 <pharaun> and imho, that ^ is a massive win
19:42:37 <arkeet> there are also bindings to other languages, like hslua
19:42:45 <arkeet> who knows what's more appropriate.
19:44:21 <ctult> But is it worth it as a first project for a previously only hobbyist programmer?
19:44:36 <ludamad> coding is worth it, period 8-D
19:44:48 <roshan> ludamad: Hear, hear!
19:45:05 <arkeet> try it!
19:45:14 <djahandarie> IMO, if your goal is to make a financially successfully game right off the bat without many long nights, it's simply not the optimal choice
19:45:15 <ctult> I mean using Haskell.  I will obviously have to program in some way or another. ;)
19:45:28 <arkeet> you'll learn a lot regardless of whether you actually complete your game or whatever.
19:45:48 <ctult> I think I'll sleep on it.
19:45:55 <ctult> And speaking of which...
19:46:29 <djahandarie> There are many programmers in here that swear by Haskell and would choose it for game programming as well, and would do a great job, so there is nothing wrong inherently with the language for that task, certainly.
19:47:03 <ctult> I must be off.  Goodnight.  Or whatever time it is where you live.  Good-whatever-that-time-is.
19:47:04 <djahandarie> But I think it should be admitted that game programming is one of those things in Haskell which isn't all fun and games and has a higher learning curve than other tasks.
19:47:20 <djahandarie> Cya.
19:47:52 <parcs> for an intermediate haskell user and a beginner game developer i think you would have a hard time making a game in haskell. game development is hard enough even when in safety of ubiquitous imperative languages
19:48:15 <ctult> parcs: duly noted
19:51:06 <finishingmove> hey guys
19:51:15 <roshan> finishingmove: Hey!
19:52:17 <finishingmove> My brother asked me if it was worth it to learn C++ and I helped him come to the conclusion that Haskell is the best choice (indirectly). Do you think it will be OK for him to learn it? (he knows a bit of javascript :x)
19:52:58 <finishingmove> he's 8th grade elementary school
19:53:10 <shachaf> I don't know your brother. But I think Haskell is a perfectly reasonable first language to learn.
19:53:14 <roshan> finishingmove: I would say Haskell is a lot more approachable to a beginner than C++
19:53:15 <parcs> he should learn both
19:53:20 <shachaf> So are a lot of other languages.
19:53:47 <arkeet> the less prior experience you have, the less you have to unlearn when learning haskell?
19:53:56 <finishingmove> Yes I guess that's true
19:54:01 <arkeet> I don't know.
19:54:05 <zmoazeni> Hi folks. Can someone give me a hand and tell me what I'm missing with this statement? empty_test_opts {…} is that somehow calling mappend? https://raw.github.com/batterseapower/test-framework/master/example/Test/Framework/Example.lhs
19:54:26 <zmoazeni> I get that it's sorta overriding defaults, I just don't understand the magic that's happening
19:54:31 * RenJuan suppresses an urge to "troll" in response to that.
19:55:17 <zmoazeni> My gut says it somehow boils down to this function call https://github.com/batterseapower/test-framework/blob/master/core/Test/Framework/Options.hs#L36
19:55:26 <parcs> are people in general truly not predisposed to the imperative way of programming?
19:55:35 <finishingmove> for those of you who came to Haskell from imperative languages (like me and my bro are trying) what advice can you give?
19:56:25 <finishingmove> parcs, i don't know about predispositions, but for example, they didn't teach me anything about functional programming in school
19:56:27 <ludamad> finishingmove: Start with tasks haskell does well
19:56:31 <RenJuan> it's the rare persons whose first lang wasn't imperative, but it does happen, prolog for example
19:56:39 <RenJuan> *person
19:56:40 <roshan> roshan: This is going to be controversial, but I would even suggest starting with Scheme
19:56:46 <geekosaur> zmoazeni, it's not calling mappend, it's a record update
19:56:55 <ludamad> roshan: talking to yourself ?
19:57:01 <parcs> i feel like regardless of whether you have prior programming experience or not, that the imperative style of programming is easier to learn
19:57:01 <geekosaur> "make a copy of this record, but replace this field value with something else"
19:57:09 <zmoazeni> geekosaur: Oh jeez. that simple?
19:57:14 <roshan> Er, I blame my fingers for typing the wrong thing :P
19:57:38 <nh2> can hdevtools display warnings (as opposed to errors)?
19:57:58 <roshan> finishingmove: But yeah, Scheme is a /simple/ language, and the PLT project and others have very good, solid, material
19:58:02 <ludamad> finishingmove, what are some things you want to accomplish ?
19:58:40 <finishingmove> So, to you guys suggesting Scheme, I was playing around with Clojure recently, and I like the LISP style
19:59:12 <zmoazeni> geekosaur: Thanks. As usual. I feel dumb, but thanks for the quick answer
19:59:50 <roshan> finishingmove: It gives you the satisfaction of understanding everything about the system, even as a beginner. I don't know any other languages that feel that way
20:00:12 <parcs> roshan: except for continuations
20:00:37 <finishingmove> I know Scheme is used for educational purposes
20:00:57 <roshan> parcs: Yeah, true. The PLT people have done a good job of creating a "teaching" scheme that also allows for things like showing how your program simplifies, step by step
20:01:31 <finishingmove> So you think LISPs are a good intro to Haskell, sort of ?
20:01:35 <roshan> And from personal experience, it's a good precursor language to Haskell
20:01:40 <roshan> Heh, in my case, yes
20:02:04 <roshan> I vastly prefer Haskell to Scheme now, but I it feels like a natural step up
20:02:32 <finishingmove> the thing that was stopping me for long from picking up Haskell was the complex type system / a lot of syntax
20:02:52 <roshan> finishingmove: Exactly
20:03:04 <finishingmove> So in that sense I can confirm your sentiments
20:03:13 <roshan> I think learning functional programming and typed functional programming in one step is a bit steep
20:03:27 <roshan> But adding types when you already understand FP is a lot easier
20:03:46 <finishingmove> mhm
20:03:58 <ChongLi> I think the types part is a lot harder than the FP part
20:04:45 <zmoazeni> finishingmove: In my case, coming from a dynamically typed OO lang, I have a hard time groking the type definitions hold as much logical value as the functions themselves. They're not just structure.
20:05:14 <zmoazeni> I am having a very hard time with that.
20:05:15 <sw2wolf> lambdabot: hava a rest
20:05:36 <monochrom> I needed types before I understood Lisp. when learning Lisp, I wrote type sigs in comments.
20:05:51 <parcs> one can use c++ as a stepping stone to understand how to program with a powerful type system
20:05:56 <jmcarthur> yeah i think haskell without types would have confused me so much
20:06:11 <ab9rf> the types made haskell easier for me to learn
20:06:15 <jfischoff> I had no idea the llvm bindings let you jit a function you could immediately call. so cool http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
20:06:42 <jmcarthur> jfischoff: this is distinct from the "llvm backend," to be clear
20:06:48 <monochrom> without type sigs in comments, I would understand very little lisp code. it is why I had to write out the type sigs.
20:06:48 <newsham> mono: you never felt like applying a 3 to a + just for fun?
20:06:50 <sw2wolf> jfischoff: seems LLVM linker is faster
20:07:09 <jfischoff> jmcarthur: yeah
20:07:17 <jmcarthur> > 3 (+)
20:07:19 <lambdabot>   3
20:07:22 <jmcarthur> works fine here!
20:07:38 <newsham> > "test" (+)
20:07:40 <lambdabot>   The function `"test"' is applied to one argument,
20:07:40 <lambdabot>  but its type `[GHC.Types...
20:07:41 <parcs> that instance was added back?
20:07:44 <jmcarthur> yeah
20:07:47 <monochrom> I forgot.
20:07:49 <roshan> parcs: I'm afraid I can't quite agree with using C++. It seems a lot of the type stuff in C++ is details of the language, and one can't separate them from typed languages in general. You start worrying about implicit conversions and a lot of C++ books teach OO in a horrible hacky way
20:07:52 <sw2wolf> LLVM is awesome
20:07:58 <jfischoff> sw2wolf: LLVM linker is faster then ...?
20:08:05 <jfischoff> LLVM is awesome
20:08:12 <newsham> jmc: that would have worked in the untyped lambda calculus with all data types defined as lambdas.
20:08:27 <ab9rf> roshan: i've never seen OO taught in a non-"hacky" way that was actually usable in any widely-used OO-based language
20:08:32 <sw2wolf> jfischoff: i will use LLVM to build xmonad first
20:08:45 <geekosaur> sw2wolf, llvm is good for some things but bad for others
20:08:57 <ChongLi> OO is hacky
20:08:59 <sw2wolf> geekosaur: in detail?
20:09:12 <geekosaur> in particular, last I heard ghc CPS-transformed before generating LLVM code, which pretty much breaks LLVM's optimizer
20:09:32 <ab9rf> you end up arguing over multiple inheritance and single dispatch and blah and blah and blah
20:09:46 <roshan> Even by the usual standards, in C++ you have to know the word "vtable" and pointers and references and so on. Compared to Java, where everything is a reference and every class is virtual
20:10:24 <arkeet> C++ is complicated.
20:10:30 <roshan> arkeet: Indeed
20:10:33 <cjh`> very.
20:10:37 <newsham> c++ is simple with complicated bolted on top of it.
20:10:40 <finishingmove> it's not just about being complicated
20:10:45 <ab9rf> newsham: inded
20:10:56 <finishingmove> i wouldn't recommend it to my brother for one main reason: it's too easy to shoot yourself in the foot with it
20:11:10 <roshan> newsham: A lot of that complication means that you have to keep a model of the hardware machine in your head, with all its quirks
20:11:35 <shachaf> The hardware machine?
20:11:39 <newsham> roshan: actually that was the "simple" part I was talking about.
20:11:46 <shachaf> Surely you mean the abstract C++ machine. :-)
20:12:01 <roshan> Well, yes, you're right :)
20:12:11 <monochrom> the abstract hardware ATM machine
20:12:22 <newsham> roshan: as opposed to haskell where you have to work hard after the fact to figure out how it maps to the hardware machine ;-)
20:12:28 <ab9rf> heh
20:12:28 <shachaf> Anyway talking about how C++ is bad seems a bit offtopic to me.
20:12:33 <roshan> newsham: Indeed :)
20:12:35 <ab9rf> there's a machine underneath haskell?
20:12:44 <roshan> newsham: But presumably by the time you do that you aren't a beginner anymore
20:12:45 <newsham> c++ -> #h-blah
20:12:46 <ChongLi> the spineless tagless g-machine!
20:12:47 <ab9rf> i thought it just got executed by gnomes
20:12:51 <cjh`> turtles, all the way down.
20:13:01 <monochrom> do { c <- #haskell-blah; c }
20:13:13 <monochrom> aka: #haskell-blah >>= id
20:13:14 <arkeet> monochrom: you are terrible.
20:13:17 <newsham> mono wants to join #haskell-blah
20:13:22 <monochrom> hehe
20:13:35 <Gracenotes> are those continuation-based gnomes?
20:13:37 <Eotane> hey, does anyone here know how to simulate nested for loops in haskell?
20:13:43 <Eotane> (using recursion obviously)
20:13:57 <newsham> but #haskell-blah is more of a lens
20:13:59 <shachaf> Eotane: Yes.
20:14:13 <Gracenotes> Eotane: it depends on what you're doing inside of the loop
20:14:17 <Gracenotes> but... yes.
20:14:18 <shachaf> Eotane: (I recommend asking a more specific question, such as "how do i do X".)
20:14:39 <monochrom> write a recursion for the outer loop. write a recursion for the inner loop. is that better now?
20:15:01 <newsham> to iterate is illiterate.. to recurse is worse
20:15:51 <newsham> eotane:  [x+y | x <- [1..10], y <- [100..110]]
20:16:19 <newsham> eotane: if you want to do it in IO,  forM_ is a lot like a normal "for"
20:16:53 <Eotane> if i have a list of [a,b,c,d] i want to compare every possible element in the list with every other element in the list i.e. (a,b),(a,c),(a,d),(b,a),(b,c),(b,d),(c,a),(c,b),(c,d),(d,a),(d,b),(d,c)
20:17:13 <newsham> > forM_ [1..10] (\n -> writeFile ("/tmp/foo" ++ show n) "hello\n")
20:17:14 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
20:17:14 <lambdabot>    arising from a use of ...
20:17:26 <Eotane> is recursion not the best solution for that problem?
20:17:30 <Gracenotes> Eotane: you have both (a,d) and (d,a)?
20:17:51 <Eotane> yes, as they produce different results in my program
20:17:53 <shachaf> > replicateM 2 "abcd" -- first approximation
20:17:55 <lambdabot>   ["aa","ab","ac","ad","ba","bb","bc","bd","ca","cb","cc","cd","da","db","dc"...
20:17:56 <Eotane> *the should
20:17:59 <Eotane> *they should
20:18:12 <newsham> > let xs = "aha!" in [a == b | a <- xs, b <- xs]
20:18:14 <lambdabot>   [True,False,True,False,False,True,False,False,True,False,True,False,False,F...
20:18:22 <ab9rf> filter (\(x,y) -> (x/=y)) ....
20:18:33 <juhp> maybe a silly question - any lib function that can check and output "command not found"?
20:18:36 <shachaf> ab9rf: :-(
20:18:50 <shachaf> ab9rf: That would be generating extra elements and then filtering them out, rather than just generating the right thing to start with.
20:18:59 <ab9rf> shachaf: mmm, i suppose so
20:19:09 <shachaf> It would do extra comparison work and it wouldn't work for non-Eq types, like functions.
20:19:11 <ab9rf> shachaf: i'm not sure i care though
20:19:11 <Gracenotes> shachaf: not sure about it generating lists rather than pairs, though...
20:19:19 <niteria> is there a haskell based shell?
20:19:19 <ab9rf> shachaf: ok, that's fair
20:19:36 <Gracenotes> partiality is like whatevs
20:19:48 <ab9rf> shachaf: not working for types not in Eq is a problem
20:19:53 <niteria> it's annoying I can't do flip scp in bash
20:20:07 <jfischoff> niteria: plush shell I think?
20:20:23 <shachaf> You are not going to be able to flip scp.
20:20:38 <jfischoff> niteria: mzero works on this https://github.com/mzero/plush
20:20:48 <Eotane> if I reword my question it might be more clear
20:21:00 <Eotane> how do i calculate the cartesian product of an array with itself?
20:21:03 <Eotane> (in haskell)
20:21:03 <Gracenotes> the real magic in bash happens with stdin/stdout, to be honest, not so much cmdline arguments
20:21:10 <roshan> Eotane: I guess the idea is that a lot of the time, if you're just going to loop over a datastructure, you can avoid writing anything that looks like a loop
20:21:10 <shachaf> That is a different question from the one you asked.
20:21:24 <shachaf> The answer to that question is probably one of the things we've mentioned.
20:21:28 <Gracenotes> Eotane: newsham had that.
20:21:31 <shachaf> > (\x -> liftA2 (,) x x) "abcd"
20:21:33 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('b','a'),('b','b'),('b','c'),('b'...
20:21:34 <Gracenotes> effectively
20:21:49 <ab9rf> the cartesian product is just liftA2
20:21:50 <Eotane> ill look into liftA2
20:21:52 <Eotane> thanks
20:21:55 <niteria> shachaf: I can imagine a shell where I can do that
20:22:02 <shachaf> ab9rf: Oh, even bigger problem: You might have duplicates in the list.
20:22:09 <mikeplus64> niteria: ghci? :)
20:22:12 <ab9rf> shachaf: pffft
20:22:15 <shachaf> ab9rf: You may not want the diagonal but that doesn't mean you don't want any equal pairs.
20:22:19 <Eotane> duplicates are fine
20:23:07 <ab9rf> shachaf: i didn't see if, frex only one of (a,b) and (b,a) was wanted; i rather assumed that the generator list did not contain duplicates
20:23:31 <geekosaur> niteria: flip() { local cmd="$1"; shift; local a1="$1"; shift; local a2="$2"; shift; "$cmd" "$a2" "$a1" "$@"; }
20:23:56 <Gracenotes> oof
20:24:09 <geekosaur> might need a semicolon after the { depending on bash version
20:24:24 <roshan> And if you want to (temporarily, of course :) ) defer learning about applicative functors, shachaf's nice and easy [(a,b) | a <- list, b <- list]
20:24:29 <roshan> would do the trick :P
20:24:37 <niteria> geekosaur: nice, but don't you find writing bash code painful?
20:24:52 <ab9rf> shachaf: as i understood the problem it was to create a flattened list of the cartesian self-product less the diagonals, but perhaps i misunderstood
20:25:08 <Clint> geekosaur: takes effect after globbing, which may be problematic
20:25:12 <geekosaur> not really, but I've been doing shell for a lot longer than haskell and i'm kinda used to it by now :)
20:25:22 <shachaf> ab9rf: I assume there's only one diagonal involved here.
20:25:24 <geekosaur> well yes, everything takes effect "after globbing"
20:25:38 <shachaf> ab9rf: Anyway, I mean something like "aba" * "aba"
20:25:38 <sproingie> i love using flip cp
20:25:42 <ab9rf> shachaf: by 'diagonals' i meant 'elements on the diagonal"
20:25:44 <Clint> in bash, maybe
20:26:09 <ab9rf> shachaf: i assumed that the source list contained no duplicates, and thus such elements would only occur on the diagonal.
20:26:25 <sproingie> i actually call mine "rot" because it sticks the first arg alllll the way on the end
20:26:41 <geekosaur> yeh, that's not hard to do
20:26:44 <shachaf> And also that the source list was Eq, and various other things. :-)
20:26:45 <sproingie> find foo | xargs rot cp destdir
20:26:51 <ab9rf> shachaf: yes, well :)
20:26:55 <roshan> As far as I can tell Eotane just wanted a cartesian product, which includes the diagonal elements
20:27:06 <sproingie> rot's actually a script, not a function
20:27:08 <ab9rf> roshan: apparently so.  which is much easier
20:27:11 <niteria> mikeplus64: yeah, I think ghci could be hacked to be a nice shell
20:27:28 <ab9rf> niteria: setting aside the fact that it weighs as much as a hummer
20:27:53 <Eotane> it doesnt affect my program if there are diagonal elements
20:28:22 <shachaf> Eotane: People have already said how to do a cartesian product a few times; is there a problem with those solutions?
20:28:37 <shachaf> > [(x,y) | x <- "abc", y <- "abc"] -- for example this
20:28:39 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c'...
20:28:46 <shachaf> > liftA2 (,) "abc" "abc" -- or this
20:28:48 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c'...
20:28:54 <niteria> ab9rf: I don't care about memory and disk space (within reasonable limits)
20:28:56 <Gracenotes> It is somewhat rare you'll need an actual Cartesian product, unless you reuse the same list twice...
20:29:14 <ab9rf> niteria: yes and you people make my life a living hell sometimes :)
20:29:19 <arkeet> > join (liftA2 (,)) "abc"
20:29:21 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c'...
20:29:34 <shachaf> tharkeet
20:29:38 <Eotane> shachaf: no i'm just figuring out which of these i should use
20:29:49 <ab9rf> Eotane: whichever you like, they're all the same thing basically
20:30:12 <Eotane> ok. thanks
20:30:22 <ab9rf> Eotane: although i'd suggest using one that you understand over one that you don't
20:30:50 <Eotane> of course
20:31:10 <niteria> ghci's startup time isn't so bad either, I guess it depends on number of modules loaded
20:31:30 <xenon> hi everyone.
20:31:31 <xenon> i'm installing happstack using "cabal install happstack-server"
20:31:34 <Eotane> thanks for the help!
20:31:36 <xenon>  but cabal says massage like cannot configure threads-0.5.0.2. It requires base >=4.4 && <4.7 .
20:31:40 <xenon> what should i do?
20:32:40 <roshan> xenon: What does ghc --version say?
20:33:00 <xenon> 7.0.4
20:33:38 <roshan> xenon: That came with base 4.3, apparently
20:33:51 <roshan> You'll probably need a newer compiler
20:34:11 <roshan> Perhaps upgrade to the latest haskell platform, if possible?
20:34:33 <xenon> thx. roshan
20:34:34 <xenon> I will try:)
20:34:51 <roshan> xenon: good luck!
20:35:12 <shachaf> Perhaps instead of "threads" you should use "async"
20:35:16 <shachaf> @hackage async
20:35:16 <lambdabot> http://hackage.haskell.org/package/async
20:35:20 <shachaf> Oh, this is happstack.
20:52:15 <monochrom> current Haskell Platform comes with async
21:07:13 <Apes> Hello, I am learning Haskell, and I would like to get some feedback on some Haskell code I wrote.
21:07:19 <Apes> https://gist.github.com/apeschel/5298370
21:11:04 <ab9rf> Apes: what sort of feedback would you like?
21:11:41 <ski_> perhaps you wanted to use `isDigit' rather than `isNumber'
21:12:22 <ski_> is `"1,2.3,4"' admissible input to `convert' ?
21:12:31 <ab9rf> Apes: i notice that you don't seem to actually use split_char in your split function
21:12:43 <me2> Hi all.
21:12:49 <ab9rf> it gets passed around but is never actually used for any purpose
21:12:54 <Apes> ab9rf: Ah, nice catch
21:13:10 <ski_> if not, you might consider using `span' or `break'
21:13:13 <cmears> Compiling with the warnings turned on would also catch that I think
21:13:44 <me2> So I have a curious problem. In GHCI, runQ [d| data X = X |] works, but runQ [d| data X = X deriving Show |] fails with an error. Is this supposed to be the case?
21:13:47 <ski_> Apes : also, rather than having `buf' be an accumulator, it would be better to add to it "upwards"
21:14:03 <Apes> ski_: I was having trouble thinking of a way to get it to work like that
21:14:08 <ab9rf> accumulators are usually suboptimal
21:14:17 <ski_> (especially as you currently add to the end of it, repeatedly, which is seldom a good idea)
21:14:25 <ab9rf> especially using ++ to do the accumulating :)
21:14:57 <ab9rf> @src break
21:14:57 <lambdabot> break p =  span (not . p)
21:15:02 <ab9rf> @src span
21:15:02 <lambdabot> span _ xs@[]                     =  (xs, xs)
21:15:02 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
21:15:02 <lambdabot>                   | otherwise    =  ([],xs)
21:15:08 <ski_> Apes : call recursively in a `where (ys,zs) = helper ...' and add to the correct portion of the pair
21:15:22 <ski_> (or `let'-`in', if you prefer)
21:15:37 <ski_> > span isDigit "123.45"
21:15:38 <lambdabot>   ("123",".45")
21:16:14 <ski_> > span isDigit "1,2.3,4"
21:16:16 <lambdabot>   ("1",",2.3,4")
21:16:49 <ab9rf> of course, you could drag out parsec and clobber this fly with a sledgehammer
21:17:09 <ski_> me2 : hm, sounds weird to me. i dunno much TH details, though
21:17:50 <niteria> for this particular function wouldn't it be easier to just (read $ filter (isDigit) str) :: Integer
21:18:01 <ski_> ab9rf : heh, i was initially thinking of using `ReadS' and `lex' -- until i noticed the split on `.' :)
21:18:47 <ski_> (hm, or i suppose it might work, since we're reading `Integer' ..)
21:19:17 <ab9rf> > read "123.45" :: Integer
21:19:19 <lambdabot>   *Exception: Prelude.read: no parse
21:19:42 <ab9rf> thought so
21:20:08 <niteria> > (read $ filter (isDigit) "$12,345.90") :: Integer
21:20:10 <lambdabot>   1234590
21:20:26 <ab9rf> niteria: interesting but not terribly useful in this context :)
21:21:08 <ab9rf> i suppose it genreates 'correct' results when the user has conveniently specified the correct number of decimal places after the punkt
21:21:14 <ski_> > [ ((d*100 + c :: Integer,s)) | let s0 = "123.45",(d,s1) <- reads s0,(".",s2) <- lex s1,(c,s) <- reads s2]
21:21:15 <lambdabot>   []
21:21:17 <ski_> > [ ((d*100 + c :: Integer,s)) | let s0 = "123 . 45",(d,s1) <- reads s0,(".",s2) <- lex s1,(c,s) <- reads s2]
21:21:19 <lambdabot>   [(12345,"")]
21:21:24 <ski_> right, doesn't work
21:22:19 <niteria> ab9rf: yeah and accepts inputs like "1.2.3.4"
21:22:45 <ab9rf> niteria: woukldn't want to confuse your IP address for your bank balanace
21:23:09 <niteria> where in the original implementation it just crashes
21:23:25 <ab9rf> indeed
21:23:26 <ski_> Apes : btw, i often like making the accumulator the first argument, since it enables me to write stuff like `split split_char = helper []'
21:23:33 <ab9rf> incorrect output is always better than an exception :)
21:24:27 <niteria> :t many
21:24:29 <lambdabot> Alternative f => f a -> f [a]
21:24:39 <niteria> @src many
21:24:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:24:44 <niteria> :t parse
21:24:45 <lambdabot> Not in scope: `parse'
21:25:04 * hackagebot data-default-instances-old-locale 0.0.1 - Default instances for types in old-locale  http://hackage.haskell.org/package/data-default-instances-old-locale-0.0.1 (LukasMai)
21:25:14 <mauke> many p = some p <|> pure []
21:25:28 <ski_> ab9rf : i disagree with that :)
21:25:43 <niteria> regexp would be easiest
21:26:01 <ab9rf> niteria: UUUUUUGH
21:26:53 <ab9rf> i _hate_ regular expressions
21:27:06 <niteria> regexps are best dsl ever
21:27:21 <ab9rf> they're useful for end-user purposes to allow an end user to specify a pattern
21:27:27 <ab9rf> they should *never* be used in a program
21:28:04 <ab9rf> write a recognizer already
21:28:20 <niteria> you shouldn't let an user specify a regexp
21:28:33 <niteria> s/an/a
21:28:41 <paintcan> what if you need to recognize a regular language
21:30:03 <andrewsw> writing perl in my day job, we use regexps all the time. I hate it.
21:30:25 <ab9rf> regexps are massively overused, espeically in languages like perl, php and python
21:30:34 <ab9rf> PCREs are especially abominable
21:30:45 <andrewsw> it makes me feel lazy -- it's just so easy I don't have to think about what I'm actually trying to recognize.
21:30:57 <ab9rf> not only do they have virtually unbounded time and space complexity, they are also damnably difficult to maintain
21:31:02 <niteria> people tend to take regexps too far, mostly because that's the only thing they know
21:31:27 <mauke> ab9rf: the same thing could be said about Haskell
21:31:35 <ab9rf> mauke: true enough :)
21:31:43 <mauke> in conclusion: don't write unreadable regexes
21:31:57 <mauke> use formatting and comments if things get too hairy
21:32:05 <mauke> build them up from smaller reusable parts
21:32:13 <ab9rf> don't try to solve problems using regexps that aren't recognition problems
21:32:14 <sproingie> powerful tool is abusable, not news
21:32:15 <luite> hm i do sometimes miss easy regexps in haskell
21:32:23 <ab9rf> yes, you can use PCREs to do math.
21:32:37 <ab9rf> anyhow, i digress
21:32:39 <mauke> math is a recognition problem
21:33:03 <ab9rf> poor Apes is not getting any closer to nirvana
21:33:06 <niteria> SAT is a recognition problem
21:33:58 <hpaste> “Joey Adams” pasted “Very simple monadic parser aimed at regex-like usage” at http://hpaste.org/85072
21:34:13 <ab9rf> Apes: i see you fixed your split_char problem at least :)
21:34:28 <ab9rf> Apes: what happens if the user types $1000.4123
21:34:52 <JoeyA> ^ kinda like Attoparsec, but very spartan error handling, and supports using a parse to "match" text within a parser.
21:36:12 <JoeyA> I'm writing a connection API for an application, and want to have a separate type for the connection prior to authenticating the client.  What's a good name?
21:38:57 <JoeyA> I guess Entrant, Connection would work.
21:44:21 <ski_> ab9rf : should `,' occur, and only occur, separating groups of three digits, counting from the `.' ?
21:44:24 <ski_> er
21:44:27 <ski_> Apes ^
21:46:02 <ab9rf> or is $1,,,,,,,,9,9.,,,,,,9,9 acceptable input? :)
21:55:05 * hackagebot hmemdb 0.1.0.4 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.1.0.4 (MiguelMitrofanov)
22:32:58 <sw2wolf> (defparameter +FOO+ (namestring (asdf:system-relative-pathname 'MyModule "bar.txt"))) , no matter where i start lisp REPL, it can use +FOO+ to locate bar.txt.  What's the corresponding way in haskell ?
22:35:05 * hackagebot hmemdb 0.1.0.5 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.1.0.5 (MiguelMitrofanov)
22:53:13 <SuperNoeMan> so, recently, an employer said that they had had a project that relied on haskell some number of years back that flubbed out
22:54:14 <SuperNoeMan> because there wasn't enough developers and because haskell didn't produce fast enough code.
22:55:14 <SuperNoeMan> But from what I understand, haskell's compiler has sped up significantly, and profiling can be used to identify what's slow
22:55:29 <SuperNoeMan> and then the programmer can do some low level work to optimize that back out
22:55:49 <c_wraith> that's rarely even necessary
22:55:54 <SuperNoeMan> And, furthermore that haskell has grown significantly. Can someone comment on this? Provide any additional information?
22:56:00 <c_wraith> usually, slowness is caused by flat-out bad code
22:56:22 <c_wraith> and just replacing it with reasonable code is fine.  No need to go low-level
22:56:30 <shachaf> Sometimes...
22:56:53 <luite> SuperNoeMan: it has grown. it can still be too slow if performance demands are really strict. optimizing haskell takes some experience, can take a while before you can write fast code
22:57:01 <luite> it's different from optimizing imperative code
22:57:16 <SuperNoeMan> luite: ok...
22:57:33 <c_wraith> and then sometimes I'm re-writing an RC4 library to perform reasonably and need to use every low-level trick in the book. >_>
22:57:42 <SuperNoeMan> so, as a completely functional language, there are some data structures which certain operations just do not lend themselves to tail recursion so well
22:58:02 <SuperNoeMan> would the compiler be so smart that it could make non tail recursive calls better? or optimal?
22:58:03 <c_wraith> tail recursion isn't so important in haskell.
22:58:10 <luite> SuperNoeMan: tail recursion is not as important in haskell as in many other languages because of laziness
22:58:15 <c_wraith> Knowing the evaluation model is way more important
22:59:09 <luite> SuperNoeMan: you can still stackoverflow with non-tailrecursive calls in haskell
23:00:47 <Apes> ski_: Sorry about the delay. The problem is ambiguous, so I decided to allow weird inputs like $1,,,,,9,xyav44.9
23:00:48 <SuperNoeMan> ok
23:00:49 <luite> SuperNoeMan: but in many cases it won't matter. for example:  f n = n : f (n+1)  is not tail recursive, it produces a list of [n,n+1,n+2, ....], but it will not stack overflow
23:00:57 <luite> SuperNoeMan: because of laziness
23:01:24 <c_wraith> I could make that stack overflow. >_>
23:01:24 <SuperNoeMan> luite: would the compiler optimize that out anyway?
23:01:30 <SuperNoeMan> I thought I saw exactly that example...
23:01:46 <luite> c_wraith: yeah i should've seqqed the n
23:02:14 <luite> and !! might still overflow?
23:02:42 <luite> no it wouldn't i guess
23:02:43 <c_wraith> no, if you use seq, !! won't make it overflow
23:04:02 <SuperNoeMan> also, not all cases lend themselves to tail recursion. You say that it doesn't always matter, but
23:04:28 <SuperNoeMan> sometimes it does
23:04:41 <SuperNoeMan> in haskell, are there constructs to get around these cases? I mean
23:05:30 <luite> SuperNoeMan: yes, you can often make calls tailrecursive by converting something to extra arguments, or pass a continuation
23:05:32 <c_wraith> Anything that doesn't lend itself to tail recursion doesn't lend itself to a loop in an imperative language..
23:05:44 <luite> but you have to watch out with strictness, like i just didn't :p
23:06:05 <SuperNoeMan> ah ok
23:06:13 <SuperNoeMan> right, I mena
23:06:29 <SuperNoeMan> recently I had a data structure that was a list by doing
23:06:31 <SuperNoeMan> (in ocaml)
23:06:44 <c_wraith> GHC is able to convert things into tail calls rather cleverly in some cases, though.  Like, infinite IO actions don't blow up the stack.
23:07:00 <c_wraith> Even though a naive interpretation of them might assume they would
23:07:10 <SuperNoeMan> ('a ('a ('a ('a ...
23:07:22 <c_wraith> > fix (0:)
23:07:23 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:07:42 <SuperNoeMan> but you could only get to the next element by doing...
23:07:51 <SuperNoeMan> well hold on, that was from memory, I don't remember exactly what it was
23:08:43 <ski_> by doing... what ?
23:08:54 <SuperNoeMan> I 'm just trying to show that you
23:09:05 <SuperNoeMan> could only go from the front of the list to the back
23:09:23 <SuperNoeMan> so doing things like append, when you only had cons element list
23:09:34 <SuperNoeMan> was not optimal.
23:09:56 <c_wraith> like, seriously..  « let x = print "hi" >> x in x »...  That's not technically a tail call, but GHC sorts it out properly anyway.
23:11:00 <SuperNoeMan> yeah, of course you would just change the data structure, but I wonder if there are ever cases where you can't make something tail recursive that can be done in a while loop
23:11:10 <SuperNoeMan> but I also thought some famous mathematician proved that
23:11:23 <c_wraith> If you can do it in a while loop, you can do it tail recursively. The two are equivalent
23:11:49 <SuperNoeMan> yeah
23:12:02 <SuperNoeMan> ok, so my exmple was bad, I just thought about it at the spur of the moment
23:13:54 <SuperNoeMan> and that was bad, I'm just investigating haskell
23:14:05 <SuperNoeMan> overall, I really really want to learn it, but I have limited time.
23:14:22 <SuperNoeMan> sorry about the poor example, I'm doing two things at the same time, and just wanted to get my point across rather quickly
23:14:56 <luite> c_wraith: hm isn't it? if you unwrap the IO type it becomes something like this: x s = let (s',_) = print "hi" s in x s'
23:15:26 <luite> add a ! to the let though
23:15:29 <SuperNoeMan> luite: isn't it? -> a poor example?
23:15:39 <c_wraith> unwrapping IO? surely you jest! :)
23:16:18 <SuperNoeMan> uhh... I haven't started to learn haskell
23:17:14 <SuperNoeMan> not following you guys
23:17:16 <luite> SuperNoeMan: yeah don't look at that sample, i just wanted to point out that GHC doesn't have to be particularly clever here to not blow the stack
23:18:43 <SuperNoeMan> someone told me that frequently, with functional languages like haskell and ocaml, if you can get your program to pass the compiler test, you almost never have to deal with run time errors
23:18:54 <SuperNoeMan> and when they occur, you're able to fix it with print statements
23:19:03 <luite> SuperNoeMan: all things that interact with the outside world, have some IO (often called actions) in their type, this example relied on how those IO actions are implemented in GHC
23:19:44 <arkeet> SuperNoeMan: that's more to do with the expressive type system you get :p
23:20:06 * hackagebot mega-sdist 0.2.0.9 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.0.9 (MichaelSnoyman)
23:21:28 <SuperNoeMan> I'm very experienced in debugging, and honestly, finding the source of a C++ bug is hellacious hard
23:21:38 <SuperNoeMan> even java can be incredibly hard, even with tons of tools
23:21:44 <mm_freak> instance (MonadBase b m, Monoid e, Plus f) => MonadBase b (Continue e f m) where
23:21:55 <mm_freak> this one is undecidable despite the functional dependency m -> b
23:21:58 <SuperNoeMan> So, I look forward to what I've been told is an incredibly sophisticated type system that helps catch most errors at compile time
23:22:00 <mm_freak> why and how do i solve it?
23:23:09 <mm_freak> SuperNoeMan: http://www.haskell.org/haskellwiki/Why_Haskell_just_works
23:23:17 <SuperNoeMan> I've read that
23:23:27 <arkeet> I haven't read that :o
23:23:41 <luite> me neither :p
23:24:01 <SuperNoeMan> How expressive would you say the compiler errors are?
23:24:05 <mm_freak> SuperNoeMan: i seldomly get any run-time bugs with haskell at all…  with that in mind i feel more secure writing pages of code without compiling even once
23:24:13 <SuperNoeMan> One of the things that makes me grit my teeth is the C++ gnu compiler
23:24:16 <SuperNoeMan> its a complete piece of shit
23:24:18 <mm_freak> SuperNoeMan: super-expressive as soon as you're used to them =)
23:24:26 <SuperNoeMan> sometimes not even giving you the right file or line
23:24:47 <mm_freak> understanding haskell type errors requires understanding the type system…  some errors can be very cryptic to a beginner
23:24:52 <arkeet> I dread reading C++ code sometimes.
23:25:05 <SuperNoeMan> ok... so, with one set of compiler output, complaining about a single bug, you can go directly to that bug
23:25:10 <SuperNoeMan> and immediately know what is wrong-
23:25:14 <SuperNoeMan> true/false
23:25:24 <mm_freak> SuperNoeMan: mostly true, sometimes false
23:25:28 <SuperNoeMan> oh god yeah, C++ is fucked in so many ways
23:25:41 <SuperNoeMan> I can't believe industry ever based anything on that stupid POS
23:25:50 <SuperNoeMan> even the template system is turing complete
23:26:16 <mm_freak> SuperNoeMan: you know that your thought process was wrong, and you know where it clashed with the code you wrote…  that point in the source code is not necessarily the source of your wrong thought process
23:26:17 <SuperNoeMan> hacking essentially exists to continually pwn problems that manifest themselves of an origin that is about 3 decades + old
23:26:39 <SuperNoeMan> mm_freak: ok, acceptable
23:26:49 <SuperNoeMan> I was thinking i wouldn't get a straight answer to that one
23:27:08 <SuperNoeMan> but in *general cases
23:27:21 <sw2wolf> @ty (*>)
23:27:22 <mm_freak> SuperNoeMan: i recommend that you just write a program
23:27:23 <lambdabot> Applicative f => f a -> f b -> f b
23:27:23 <SuperNoeMan> is kind of what I was thinking. I agree, not always in the same source/line
23:27:37 <mm_freak> SuperNoeMan: get a feeling for the language =)
23:27:52 <SuperNoeMan> Well, I'm a masters student in college
23:27:56 <SuperNoeMan> I'm very stretched for time
23:27:57 <arkeet> me too!
23:28:04 <SuperNoeMan> There are incredibly many things I wish to study
23:28:18 <mm_freak> SuperNoeMan: solve your college problems in haskell
23:28:19 <SuperNoeMan> I'm deeply interested in a lot of things, but I have limited time
23:28:22 <mm_freak> write small command line helpers
23:28:23 <arkeet> me too!
23:28:52 <SuperNoeMan> ok... sooo...
23:28:59 <SuperNoeMan> I think I had one more question
23:29:16 <SuperNoeMan> I'm about to start with my last year of college at the U that I'm currently at
23:29:18 <mm_freak> SuperNoeMan: one thing you may want to get into immediately is optparse-applicative…  it allows you to write nice command line interfaces quickly and composably…  you will experience how your program either works or does not compile =)
23:29:20 <SuperNoeMan> finishing up a masters
23:29:37 <SuperNoeMan> and then I have to work, but I want to do a phd in using interactive theorem provers.
23:29:56 <luite> in using them?
23:30:48 <SuperNoeMan> as I understand, the language Coq allows one to export to haskell programs for which proofs have been made...
23:30:57 <SuperNoeMan> does anybody have any experience pertinent to this?
23:31:24 <mm_freak> anyone have an idea about my problem?
23:31:59 <mm_freak> instance (MonadBase b m, Monoid e, Plus f) => MonadBase b (Continue e f m) where  -- this one is undecidable despite the m -> b fundep (transformers-base library)
23:32:16 <mm_freak> why?!
23:33:56 <mm_freak> is this one of the many cases, where UndecidableInstances is safe?
23:35:18 <mm_freak> let me simplify the description:  data M :: (* -> *) -> * -> *
23:35:29 <mm_freak> class T b m | m -> b
23:35:46 <mm_freak> instance (T b m) => T b (M m)  -- undecidable…  why?
23:37:24 <mm_freak> snoyberg: as a advocate of monad-control you probably know the answer =)
23:37:57 <snoyberg> i think i walked in on the middle of the discussion :)
23:38:15 <mm_freak> btw, your argument on SO convinced me to try again with monad-control instead of MonadCatchIO =)
23:38:53 <snoyberg> sorry, my gears are still warming up... which argument was that?
23:38:56 <mm_freak> snoyberg: you got everything…  there was no discussion so far…  again i'm running into a likely-safe undecidable instance with fundeps
23:39:23 <mm_freak> the original question:  instance (MonadBase b m, Monoid e, Plus f) => MonadBase b (Continue e f m) where  -- this one is undecidable despite the m -> b fundep (transformers-base library)
23:40:02 <snoyberg> i'll admit ignorance on this one
23:40:32 <snoyberg> i'm not quite certain why it requires undecidables
23:40:33 <mm_freak> snoyberg: you noted that not being able to write a MonadTransControl instance suggests that a possible MonadCatchIO instance is probably wrong
23:40:39 <mm_freak> hmm
23:40:45 <snoyberg> ahh, yes, that one, i remember now
23:41:10 <mm_freak> and yes, indeed my instance was unsound
23:41:40 <mm_freak> oh, it wasn't on SO…  it was on haskell-cafe
23:41:48 <snoyberg> the reason i'm so wary of MonadCatchIO is that the unsound ContT instance caused a double-free bug in a production site of mine once that caused segfaults
23:41:50 <mm_freak> in the thread about deprecating MonadCatchIO
23:42:11 <snoyberg> but tbh, i preferred monad-control before it used monad-base
23:42:50 <Shin-LaC> Occurs check: cannot construct the infinite type: a0 = [a0] <- what
23:43:45 <ski_> Shin-LaC : probably confusing an element with a list of elements, somewhere
23:44:19 <mm_freak> Shin-LaC: writing type signatures will turn this occurs check error into a regular type mismatch
23:44:35 <mm_freak> that helps you localize the error
23:44:53 <Shin-LaC> http://pastebin.com/sm2rsF4n <- I have this
23:44:59 <mauke> The paste sm2rsF4n has been copied to http://hpaste.org/85075
23:44:59 <ski_> perhaps you meant `[x]' instead of `x', or `++' instead of `:', or vice versa
23:45:24 <Shin-LaC> oh
23:45:27 <sw2wolf> @ty (>=>)
23:45:29 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:45:41 <ski_> @src concat
23:45:41 <lambdabot> concat = foldr (++) []
23:46:02 <Shin-LaC> it should be f (Single a) = [a]
23:46:10 <ski_> indeed
23:46:15 <Shin-LaC> the error was actually reported on the next line, though
23:46:25 <Shin-LaC> because it assumed the type of f based on the first line, I guess
23:46:42 <Shin-LaC> how could I fit a type signature for f in there?
23:46:44 <ski_> yes, i suspect type error slicing would have reported sites on both those lines
23:47:06 <ski_> Shin-LaC : align it with the start of the defining equations for `f'
23:47:37 <Shin-LaC> thanks
23:47:40 <ski_> (with `where' on the same line as the type signature, or on the line after `where', as you prefer)
23:48:20 <ski_> @src replicate
23:48:20 <lambdabot> replicate n x = take n (repeat x)
23:48:32 <ski_> Shin-LaC : also that ^ one, in addition to the `concat' one
23:48:41 <arkeet> unrle2 = (>>= f)
23:48:42 <arkeet> :p
23:48:46 <Shin-LaC> oh
23:49:19 <arkeet> @src concatMap
23:49:19 <lambdabot> concatMap f = foldr ((++) . f) []
23:49:24 <arkeet> :t concatMap
23:49:25 <ski_> @pl concat . map f
23:49:25 <lambdabot> (f =<<)
23:49:25 <lambdabot> (a -> [b]) -> [a] -> [b]
23:49:26 <arkeet> :t (>>=)
23:49:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:49:43 <arkeet> errr
23:49:53 <arkeet> :t (=<<)
23:49:54 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:50:12 * hackagebot cryptohash 0.9.0 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.9.0 (VincentHanquez)
23:50:14 * hackagebot hmemdb 0.2.0.0 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.2.0.0 (MiguelMitrofanov)
23:52:52 <sw2wolf> @ty ($!)
23:52:53 <lambdabot> (a -> b) -> a -> b
23:53:19 <sw2wolf> @ty ($)
23:53:20 <lambdabot> (a -> b) -> a -> b
23:57:39 <arkeet> @ty id
23:57:41 <lambdabot> a -> a
23:58:07 <shachaf> @ty undefined
23:58:09 <lambdabot> a
