00:06:00 * hackagebot crypto-pubkey-types 0.3.2 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.3.2 (VincentHanquez)
00:33:29 <realitygrill> has anyone used smt-lib
00:33:31 <realitygrill> ?
00:34:13 <realitygrill> cabal install is showing a whole crapload of packages that will be broken if i try :/
00:34:52 <yitz> realitygrill: try cabal-dev
00:36:34 <yitz> realitygrill: if you're not using a sandbox, you should be prepared to re-installed the haskell platform from time to time when your package database gets mucked up.
00:36:49 <yitz> realitygrill: which isn't really as bad as it sounds
00:36:56 <realitygrill> oh, hm
00:43:23 <fruitFly> what's wrong with this?
00:43:32 <fruitFly> sum [x|x<-[1..999], x`mod`(3||5)==0]
00:44:33 <sw2wolf> > 100 `mod` (3 || 5)
00:44:34 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Bool)
00:44:35 <lambdabot>    arising from a use of...
00:44:39 <mauke_tmp> 3 is not a Bool
00:44:48 <mauke_tmp> > 3 || 5
00:44:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
00:44:49 <lambdabot>    arising from the literal `3...
00:44:54 <mauke_tmp> > True || False
00:44:55 <lambdabot>   True
00:45:03 <coppro>  /win 11
00:45:35 <fruitFly> o right.. thanks
00:48:48 <killy9999> I'm running GHC with options -ddump-rule-firings -ddump-inlinings -ddump-simpl -ddump-simpl-iterations
00:48:55 <killy9999> and redirecting output to a file
00:49:18 <killy9999> for some strange reason inlining information still displays on the terminal
00:49:21 <killy9999> any idea why?
00:49:49 <mauke_tmp> what output are you redirecting and how?
00:50:54 <killy9999> mauke_tmp: at the end of command line I add this: 2>&1 > comp-iters-7.6.2.hs
00:51:05 <killy9999> or this: > comp-iters-7.6.2.hs
00:51:22 <mauke_tmp> so you're only redirecting stdout
00:51:46 <killy9999> shouldn't 2>&1 redirect stderr as well?
00:52:10 <killy9999> I mean redirect stderr to stdout, which in turn is redirected to a file
00:53:21 <killy9999> oh, &> works
00:54:15 <mauke_tmp> no, you're doing it in the wrong order
00:54:28 <mauke_tmp> you're first redirecting stderr to stdout, then reassigning stdout to a file
00:54:29 <stoned> for someone who was never good at math to begin with, functional is harder to grasp than others
00:54:38 <mauke_tmp> you need > comp-iters-etc 2>&1
00:54:41 <stoned> it's been weeks and I'm still trying to make sense of haskell
00:55:44 <stoned> in fact perhaps you guys might could help me find something
00:56:02 <h4199> stoned: ?
00:56:02 <teodor98> hey
00:56:15 <stoned> would there by any examples of say C/C++ or Java and the same functionality replicated in haskell, so I can see the different approaches etc.
00:56:23 <stoned> oh and a question mark :)
00:58:12 <stoned> so far my googling has only returned stuff related to why haskell is better than C
00:58:20 <h4199> Perhaps you might find this helpful: http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers
00:59:33 <stoned> fantastic
00:59:38 <stoned> thanks a bunch
01:04:07 <h4199> I believe this lecture series is aimed at C# programmers, but uses primarily haskell. http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
01:23:10 <tdammers> h4199: I think Haskell is primarily a research platform for C#, at least as far as MS is concerned
01:25:13 <h4199> I think that Erik does was he does to make the world better for working programmers, I think your intuition about Microsoft may be correct, but oftentimes I wonder if eventhey know their own intention.
01:28:24 <tdammers> h4199: I think they do. They fund Haskell (and particularly, GHC) with the intention of harvesting the good parts and putting them into C#. I think so far this strategy has paid off rather well.
01:28:57 <tdammers> That Haskell itself has turned out such a nice programming language is a side product, from a business perspective
01:29:04 <h4199> Is SPJ funded directly by them?
01:29:24 <tdammers> I don't know what the official construct is, really
01:33:44 <tdammers> AFAIK spj works at Microsoft Research
01:33:49 <tdammers> http://research.microsoft.com/en-us/people/simonpj/
01:33:58 <h4199> http://en.wikipedia.org/wiki/Microsoft_Research: It looks like they take the shotgun innovation approach.
01:34:27 <h4199> Oh he has a new paper
01:37:34 <danr> tdammers: he does :)
01:53:47 <Dodek> Microsoft Research does tons of research project without any business objective whatsoever.
01:58:13 <refold> Hackage seems to be down again :-(
01:58:40 <shachaf> Nope.
01:58:41 <mm_freak> refold: works for me
01:59:11 <h4199> 404 here
02:00:05 <refold> mm_freak: isup.me agrees with you
02:00:25 <arkeet> hackage worksforme
02:00:52 <arkeet> :c
02:03:05 <Cale> yeah, it's up for me too
02:03:29 <Cale> hackage.haskell.org has address 66.193.37.204
02:03:34 <h4199> working again here
02:15:52 <ReleaseCandidate> hi all
02:16:05 <zammy> hi
02:24:16 <killy9999> repost from #ghc
02:24:51 <killy9999> I recompiled GHC with -DDEBUG option but when I compile a program with -debug option I don't get any debugging messages
02:25:07 <killy9999> does anyone have any idea what could I have done wrong?
02:28:46 <shachaf> mauke_tmp: What do "expression" and "value" mean?
02:29:06 <mauke_tmp> context?
02:29:17 <shachaf> A discussion about Haskell.
02:29:31 <shachaf> You gave some meanings for the words a while ago, or hinted at some meaning, but I don't remember exactly.
02:29:36 <companion_cube> isn't a value a fully-evaluated expression?
02:29:45 <shachaf> Do values and expressions both have types?
02:29:47 <mauke_tmp> I'd say an expression is from the world of programs while a value is from the world of data
02:30:00 <mauke_tmp> i.e. one is code and the other is a runtime thing
02:30:31 * mauke_tmp disappears
02:32:09 <turtil> Would there happen to be a good book/video/tutorial if i wanted to play around or prototype a small game in haskell?
02:36:00 <merijn> turtil: I remember a blogpost that uses FRP to write a breakout in haskell and compile it to JS
02:36:04 <killy9999> turtil: http://keera.co.uk/blog/2013/03/19/creating-board-games-in-haskell/
02:36:13 <merijn> Also, I think lens has a pong example?
02:36:28 <shachaf> @where game
02:36:29 <lambdabot> #haskell-game | http://www.haskell.org/haskellwiki/Game_Development | http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game | https://github.com/haskell-game
02:36:50 <merijn> turtil: https://github.com/ekmett/lens/blob/master/examples/Pong.hs
02:36:55 <turtil> oh thanks, yeah im currently looking at the game development page etc
02:37:25 <merijn> turtil: That's also a lens example, though, so depending on how comfortable you are with haskell that might make the code more tricky to follow
02:38:52 <turtil> again, thanks for this, i wont say im a very good haskell developer, but in an effort to learn i decided i would try to make a small game for my daughter (shes 4), something to do, and hopefully she will enjoy it for more then 20 seconds :)
02:39:30 <merijn> turtil: Oh, if you want to do simple things like number guessing/board game that's considerably easier
02:40:17 <merijn> turtil: I've been using vty-ui for simple terminal UI's, it's reasonably easy to use for that
02:40:29 <turtil> awesome, this is something i would normally turn to js and html5 canvas or something, but there is no fun in that
02:40:41 <turtil> thanks i will check that out
02:40:51 <merijn> (I couldn't be arsed to figure out the many GUI frameworks, the downside is that it only runs on linux/osx, windows has been tricky)
02:41:28 <turtil> didnt like QT/GTK? :)
02:41:38 <shachaf> js and html5 canvas! http://hdiff.luite.com/gloss/pong/
02:41:39 <merijn> turtil: If you do web stuff, maybe take a look at http://jshaskell.blogspot.co.uk/ ?
02:41:53 <merijn> turtil: That's compiling haskell to JS :)
02:43:04 <turtil> :o i did want to ask if that could be done
02:43:39 <shachaf> It's pretty experimental.
02:43:54 <turtil> still looks awesome, i will certainly have to give this a go
02:45:39 <merijn> turtil: Yeah, there's several active developments in compiling haskell to the browser (hi luite! :p), but they're not very suitable beyond "neat little hacks for fun", I think
02:46:06 <quicksilver> on the other hand there is no higher purpose than "neat little hacks for fun"
02:47:06 <luite> turtil: wait a few more weeks before trying ghcjs, the new code generator (which did the pong example you saw) requires GHC HEAD and some Cabal patch which are not quite ready
02:47:27 <turtil> hopfully in the next 6 months i can have my own neat little project i can hack away at that doesnt involve work.
02:47:48 <turtil> luite: ok cool, thanks for the heads up
02:48:13 <luite> merijn: how so?
02:50:46 <Spockz> dreixel__: is it possible to automatically derive Generic for a GADT with `non-vanilla' constructors?
02:53:38 <dreixel> Spockz: no, I don't think so.
02:55:12 <merijn> luite: How so "not very suitable"? That was just my guesstimate? If you say some stuff is more stable, then I bow to your superior expertise :)
02:57:39 <Elision> hey I'm trying to make a matrix GADT
02:57:59 <Elision> i.e. (Num a) => Matrix a
02:58:35 <Elision> but ... I still can't really figure out what I'm doing
02:58:43 <Elision> is there a good unified source of info about them?
02:58:48 <Cale> Elision: Why a GADT specifically?
02:59:02 <luite> merijn: oh ghcjs is still pre-alpha (hackage release should coincide with ghc 7.8), but fay is already used in production by several companies. ghcjs is heavier (and therefore takes more time get into a usable state...) but not inherently less suitable for production work
02:59:40 <Elision> Cale: I'd heard they were the way of the future :P
02:59:42 <Elision> is there something easier?
02:59:46 <Eduard_Munteanu> Heh.
03:00:20 <merijn> luite: Oh sure, I just meant not very suitable beyond neat little hacks *right now*
03:00:30 <Cale> Elision: Well, GADTs provide you with certain flexibilities that ordinary algebraic datatypes don't, but the difference only matters in certain cases.
03:00:38 <luite> merijn: ah i guess you're right than
03:00:39 <luite> then
03:00:41 <merijn> luite: Clearly a proper stable ghcjs will be very nice
03:01:07 <Cale> Elision: Is there a reason *not* to just use Arrays?
03:01:11 <merijn> i.e. if he wants to hack together a game for his 4 year old kid, by all means do so, just don't bet your company on it :)
03:01:22 <Spockz> dreixel: ok, is there any literature on that?
03:01:31 <luite> or pay me to make sure ghcjs is stable enough for your company :p
03:01:38 <merijn> I guess that works too
03:01:42 <Eduard_Munteanu> Also (Num a) => Matrix a doesn't do what you think in a data declaration.
03:01:49 <Elision> Cale: well, I want to make Matrix a an instance of Num
03:02:05 <Cale> Elision: instance Num a => Num (Matrix a) where ...
03:02:28 <Cale> (So we know they'll have to be square matrices at least...)
03:02:56 <Elision> I *think* so
03:03:04 <Cale> Or maybe not, perhaps you could have an explicit representation of size failures
03:03:08 <Elision> yeah
03:04:25 <Cale> (But it's perhaps not a great idea for the sake of writing something usable to try to encode the sizes of the matrices in the types, at least, not until type level natural numbers are easier to work with)
03:05:16 <dreixel> Spockz: http://dreixel.net/research/pdf/gpid.pdf is one way to go...
03:06:15 <Eduard_Munteanu> Even if you do encode the size at type-level, you can't really get multiplication working for non-square matrices.
03:06:35 <Elision> yeah
03:06:52 <Eduard_Munteanu> I mean, if you want   Matrix m n a * Matrix n p a = Matrix m p a
03:07:30 <merijn> Eduard_Munteanu: That wouldn't typecheck as instance of Num anyway
03:07:32 <shachaf> My matrices have fractional sizes, anyway.
03:07:37 <Elision> hehe
03:07:46 <Eduard_Munteanu> merijn: yeah, exactly what I meant
03:07:53 <Elision> my plan is to just have an Error value for invalid products or sums
03:07:59 <Elision> deal w/ it
03:08:28 <Eduard_Munteanu> Ugh.
03:08:54 <xraycat> I'd appreciate it, if someone could have a look at: http://hpaste.org/86547 It's probably hard to make any suggestions, but nontheless...
03:09:22 <Elision> hey, I'm only *planning* on having square matrices
03:09:49 <Elision> wait, that doesn't help. hm.
03:10:08 <Eduard_Munteanu> It would in the nat-indexed approach.
03:10:50 <Elision> okay, I have no idea how to use type-level natural numbers
03:10:56 <Elision> and I think that's outside the scope of this project
03:11:13 <Eduard_Munteanu> Yeah, I'm not suggesting it... like Cale said, it's not quite standard practice.
03:12:01 <Elision> I'm also reconsidering even making them instances of Num, since the only thing I need them for immediately is gauss-jordan elimination
03:12:34 <Eduard_Munteanu> Elision: oh... do you insist on implementing it yourself? You should look at hmatrix.
03:12:39 <Eduard_Munteanu> @hackage hmatrix
03:12:40 <lambdabot> http://hackage.haskell.org/package/hmatrix
03:13:05 <Eduard_Munteanu> They also have a reasonable matrix representation already.
03:13:49 <Elision> oh huh
03:13:53 <Elision> I hadn't found anything particularly nice
03:14:43 <Eduard_Munteanu> See e.g. http://hackage.haskell.org/packages/archive/hmatrix/0.14.1.0/doc/html/Numeric-LinearAlgebra-Algorithms.html
03:15:35 <Elision> I'll think about it then
03:15:53 <merijn> There's also VectorSpace, right?
04:01:56 <ClaudiusMaximus> is there a shorter way to write fundeps like  class C a b c d | a -> b c d, b -> a c d, c -> a b d, d -> a b c where ...
04:03:40 <merijn> Maybe you could do it using TypeFamilies instead of fundeps?
04:04:02 <merijn> (I have no fundeps experience, so that's a question not backed by any experience)
04:04:05 <ClaudiusMaximus> probably, but i have no clue about type families :)
04:04:42 <merijn> The GHC manual has some good examples and so does the "Fun with Type Functions" paper
04:04:49 <xraycat> if someone is interessted, regarding: http://hpaste.org/86547 my bottleneck seems to be the communication via TBQueue, I'm passing my graph now directly to the worker (without deconstructing it and passing it via the queue) which leads to extra work in the process; but the speed up is enormous: prior: -N1: ~7min, -N8: 20+ min, now: -N8: 2m20s
04:05:44 <ClaudiusMaximus> merijn: thanks, will take a look
04:06:37 <quchen> xraycat: What do you mean with "not deconstructing and passing via queue"?
04:07:18 <quchen> xraycat: Oh, you were basically flattening the graph to a list-like structure, put that into a queue element-wise, and reconstructed the graph per worker?
04:07:38 <xraycat> quchen: well, I can delete node x from the graph if it has already been processed
04:10:35 <xraycat> quchen: I'm basically iterating over every subgraph of size k which includes node x
04:10:59 <xraycat> and is connected
04:11:12 <quchen> Ah, okay.
04:11:53 <quchen> I didn't see the original code so I wasn't sure what exactly was happening
04:12:16 <NetBat> folks: what's the base value in the log function?
04:12:40 <mauke_tmp> how is that a haskell question?
04:13:00 <mauke_tmp> http://en.wikipedia.org/wiki/Logarithm
04:13:13 <NetBat> because this is a Haskell function
04:13:16 <quchen> mauke_tmp: Well, there's "log" in Haskell too, and the docs don't mention a base
04:13:40 <mauke_tmp> ooh, that way
04:13:49 <mauke_tmp> sorry, I misunderstood your question
04:13:51 <quchen> > log 2.71
04:13:53 <lambdabot>   0.9969486348916096
04:13:54 <mauke_tmp> NetBat: e
04:13:55 <quchen> Tadaa
04:14:05 <mauke_tmp> :t logBase
04:14:07 <lambdabot> Floating a => a -> a -> a
04:14:53 <quchen> mauke_tmp: There's no law making it base e though, is there?
04:14:57 <quchen> Haskell-wise I mean
04:15:56 <mauke_tmp> I don't understand the question
04:16:18 <quchen> mauke_tmp: Well, I could roll my own data type where the "log" function is base 2 for example
04:16:40 <quchen> That's certainly not a good idea, but the docs don't mention a law "log should be base e in all implementations"
04:16:41 <mauke_tmp> ah
04:17:27 <quchen> Nevermind that, the report says it's base e.
04:17:33 <quchen> (Page 84)
04:17:47 <mauke_tmp> "The one-argument exponential function exp and the logarithm function log act on floating-point numbers and use base e. logBase a x returns the logarithm of x in base a."
04:18:02 <tdammers> I'd consider it rather stupid if the base were unspecified
04:18:45 <mauke_tmp> you can always normalize via log x / log (exp 1) :-)
04:19:50 <quchen> You'd probably lose 4 digits floating precision doing that, but yes ;-)
04:23:28 <kartoffe`>  /nick kartoffelbrei
04:32:31 <hpaste> “forum jnr” pasted “Keretamini.com Pabrik Kereta Mini No 1. Ready Stock” at http://hpaste.org/86551
04:32:54 <czro> Anyone know if it is possible to use libraries that link to c++ in ghci? I keep getting unknown symbol `___dso_handle'
04:34:00 <quchen> czro: If you want to use the FFI with C++, the easiest way is probably writing a wrapper module
04:34:11 <quchen> (In C)
04:35:23 <czro> quchen: Already did that, but since the wrapped code uses c++ internally I need to link with libstdc++ and I think its there somewhere that `___dso_handle' gets lost.
04:44:20 <Botje> wow. was that really spam for 3d printing material?
04:45:14 <Botje> ah, no. boo, spammers.
04:50:17 <hpaste> flebron pasted “Stack overflow using foldl'?” at http://hpaste.org/86552
04:51:01 <flebron> Hi. I am using foldl' as a pattern to try to use constant stack space. I am still getting a stack overflow. What am I doing wrong? How could I fix this?
04:52:06 <flebron> (The reason for the map, even though all calls are to numbers less than i, is that I will be calling this function many times with different arguments. I would like to preserve already-done computations, by reusing that map as a cache in the following computations.)
04:55:24 <scalable> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/bang-patterns.html
04:56:00 <scalable> and similar example:
04:56:03 <flebron> What should I be forcing evaluation on?
04:56:03 <scalable> http://book.realworldhaskell.org/read/profiling-and-optimization.html
04:56:12 <flebron> k?
04:56:13 <xplat> dmwit: compact is a property of types viewed as topological spaces (the topology per se is the lattice of subsets distinguishable by total predicates, or something like that)
04:56:43 <supki> @src foldl'
04:56:44 <lambdabot> foldl' f a []     = a
04:56:44 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:56:45 <flebron> Woah. That seemed to work.
04:57:01 <flebron> Are you a wizard?
04:57:02 <supki> flebron: foldl' means you are strict in the tuple - that won't help much
04:57:30 <supki> !(thunk, thunk) = (thunk, thunk)
04:58:03 <flebron> Ah, what I want to make sure is first evaluated is their contents.
04:58:09 <supki> yes
04:58:10 <flebron> So should I unpack the tuple and bang the contents?
04:58:18 <xplat> dmwit: my main interest in this wrt universe isn't so much in it being implemented right there so much as logically, every finite type should be compact
05:01:03 <flebron> supki: Thanks! :)
05:05:45 <Shou> When I evaluate the `A.endOfInput's it just returns a fail instead of continuing to take characters with `manyTillKeep'.
05:07:11 <Shou> Without seq, trace or !bangs it matches it and returns a Done, but not with ideal data. It ignored all `opers'.
05:11:16 * hackagebot NetSNMP 0.2.0.2 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.2.0.2 (PavloKerestey)
05:16:16 * hackagebot NetSNMP 0.3.0.1 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.3.0.1 (PavloKerestey)
05:19:02 <flebron> This may be stupid but, I'm reading http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-IO.html#t:IOUArray , and don't really understand how one creates an IOUArray.
05:19:39 <flebron> It only shows "data IOUArray i e", so... it has no public constructors, and I see no functions that return one :s
05:20:30 <mauke_tmp> flebron: it's an instance of MArray
05:20:43 <t7> why no syntax highlighting in real world haskell? even the shell command are highlighted ...
05:20:44 <flebron> So it's not a type, it's just a typename?
05:21:13 <flebron> (It's weird that it says "data", when it's not such an actual type.)
05:21:16 * hackagebot hflags 0.1.3 - Command line flag parser, very similar to Google's gflags  http://hackage.haskell.org/package/hflags-0.1.3 (GergelyRisko)
05:21:51 <mauke_tmp> flebron: huh?
05:22:27 <flebron> mauke_tmp: You say "it's an instance of MArray". Being an instance of a typeclass doesn't justify not having a ctor. Many things are instances of Functor, and still have ctors.
05:22:52 <mauke_tmp> what
05:23:01 <flebron> I don't think I can make that statement clearer, sorry.
05:23:05 <mauke_tmp> this is a double non sequitur
05:23:19 <flebron> I said I do not see a ctor in that link.
05:23:20 <mauke_tmp> IOUArray is an actual type
05:23:32 <flebron> You responded with "it's an instance of MArray".
05:23:32 <mauke_tmp> IOUArray is an instance of MArray
05:23:38 <mauke_tmp> one of the methods in MArray is a constructor
05:23:58 <mauke_tmp> Functor does not provide a constructor (it only has fmap)
05:24:03 <flebron> So the constructor is not listed there, but listed in one of the instances?
05:24:08 <mauke_tmp> no
05:24:14 <mauke_tmp> the instances are listed there
05:24:22 <mauke_tmp> the constructor is listed in the class
05:24:24 <flebron> Are the constructors?
05:24:25 <flebron> So the constructor is not listed there, but listed in one of the instances?
05:24:37 <mauke_tmp> what does "in one of the instances" even mean?
05:24:44 <flebron> That is, it's not listed there, being the page, but in one of the pages for one of the classes it is an instance of.
05:24:45 <mauke_tmp> instances don't have separate documentation
05:25:19 * flebron thinks you're being needlessly pedantic :(
05:25:32 <mauke_tmp> you're being needlessly obtuse
05:25:53 <mauke_tmp> your link has a section "Instances"
05:26:07 <mauke_tmp> when you click on MArray, you get to http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray.html#t:MArray
05:26:20 <mauke_tmp> one of the methods listed there is newArray
05:26:37 <flebron> I know, but I had never seen a type without any listed constructors, and had to go into one of the classes it is an instance of to find such a constructor.
05:26:48 <mauke_tmp> flebron: you've never seen IO?
05:27:03 <flebron> I've never had to do that with IO, no.
05:27:09 <Cale> (It is unusual to look up IO in the documentation :)
05:27:13 <flebron> The page for IO lists a bunch of functions that return an IO.
05:27:42 <mauke_tmp> but the main constructor is 'return'
05:27:47 <mauke_tmp> (or 'pure')
05:28:15 <flebron> I don't see that as being the case (your use of the word "main"). I certainly do not use return as the most frequent way to create an IO value.
05:28:28 <mauke_tmp> point
05:28:40 <Cale> return can't be a constructor because it starts with a lowercase letter ;)
05:28:51 <typoclass> flebron: hello, here's an example: when you look at the Functor typeclass, it has a function fmap and it lists various instances, among others Functor Maybe. this means, whenever you have a Maybe from whatever source, you will be able to use fmap on it. it's not necessary in haskell to have constructor that turns a Maybe into a Functor Maybe, or something like that
05:29:01 <mauke_tmp> Cale: smart constructor :-)
05:29:13 <mauke_tmp> typoclass: ?
05:29:19 <kongyang> k
05:29:24 <mauke_tmp> Maybe has public constructors, Nothing and Just
05:30:25 <merijn> mauke_tmp: He's saying there's no constructor to turn Maybe into "Functor Maybe"
05:30:43 * elliott is baffled beyond belief and I know this stuff.
05:30:55 <merijn> mauke_tmp: If you're thinking "that doesn't make any sense" then that is because you're not fluent in "newbie confusion" :p
05:31:36 <elliott> here is my best interpretation: flebron did not realise the constructors were internal and hidden, instead thinking (due to their unlisted nature) that they did not exist, that it was just a "dummy" type name used to give an instance of the typeclass
05:31:52 <mauke_tmp> hmm
05:32:10 <flebron> Something like that, yes. :)
05:32:46 <elliott> ok. I'm glad we have found precision as to exactly how we are confused.
05:34:40 <typoclass> flebron: does that make any sense? i tried to show how Functor itself has no constructors, but still is a useful typeclass
05:35:38 <merijn> Are there even typeclasses that have constructors?
05:35:41 <flebron> Sure, but I was confused by seeing "data IOUArray i e", since that usually means we have some sort of constructors (there's no "data Functor f", because Functor isn't a type, but a typeclass).
05:36:03 <typoclass> flebron: right, ok
05:36:15 <mauke_tmp> IOUArray has some constructors, but we don't :-(
05:36:16 <typoclass> merijn: it seemed like he was asking about them
05:36:21 <mauke_tmp> because the module doesn't export them
05:36:22 <elliott> I think it might have been less confusing if not for mauke_tmp's use of "constructor"?
05:36:41 <elliott> mauke_tmp was using it to just mean "something that constructs a value", as opposed to the richer sense of a fully-fledged data constructor, I think
05:38:04 <merijn> btw, am I the only one that finds the IOU in IOUArray amusing?
05:38:37 * elliott finds nothing amusing about Data.Array. :(
05:40:53 <fruitFly> what's wrong with this?
05:40:54 <fruitFly> > max [c|a<-[1..999], b<-[1..999], let c = a*b, reverse (show c) == show c]
05:40:55 <lambdabot>   *Exception: show: No overloading for function
05:41:30 <fruitFly> testing for largest 3 digit * 3 digit palindrone
05:41:51 <magicman> @type max
05:41:52 <lambdabot> Ord a => a -> a -> a
05:42:01 <mauke_tmp> fruitFly: max takes 2 arguments
05:42:12 <flebron> @type maximum
05:42:13 <lambdabot> Ord a => [a] -> a
05:42:18 <fruitFly> aaaaah
05:42:35 <fruitFly> so why does error say something about show?
05:42:48 <fryguybob> @quote IOUArray
05:42:48 <lambdabot> elliott says: <Cale> Array is immutable boxed  <Cale> UArray is immutable unboxed  <Cale> IOArray is mutable boxed  <elliott> IOUArray is an array of debts.
05:42:55 <magicman> @type max [1,2,3]
05:42:57 <lambdabot> (Num t, Ord t) => [t] -> [t]
05:43:01 <Cale> > maximum [c|a<-[1..999], b<-[1..999], let {c = a*b}, reverse (show c) == show c]
05:43:05 <lambdabot>   mueval-core: Time limit exceeded
05:43:11 <Cale> > maximum [c|a<-[1..999], b<-[1..999], let c = a*b, reverse (show c) == show c]
05:43:15 <lambdabot>   mueval-core: Time limit exceeded
05:43:38 <fruitFly> maximum [c|a<-[1..999], b<-[1..999], let c = a*b, reverse (show c) == show c]
05:43:43 <mauke_tmp> fruitFly: because the result of your expression is a function
05:43:43 <Cale> > maximum [c|a<-[1..9], b<-[1..9], let c = a*b, reverse (show c) == show c]
05:43:46 <lambdabot>   9
05:43:49 <mauke_tmp> and it doesn't know how to display functions to you
05:43:55 <Cale> > maximum [c|a<-[1..11], b<-[1..11], let c = a*b, reverse (show c) == show c]
05:43:56 <lambdabot>   121
05:44:04 <flebron> > 906609
05:44:06 <lambdabot>   906609
05:44:12 <flebron> ;)
05:44:19 <merijn> fruitFly: simple answer why it complains about functions not being showable, watch
05:44:22 <merijn> :t max []
05:44:24 <lambdabot> Ord a => [a] -> [a]
05:44:42 <merijn> fruitFly: It wants to compare two lists and return the maximum of the two
05:44:47 <dario> > max
05:44:48 <merijn> But you only give it one list
05:44:50 <lambdabot>   *Exception: show: No overloading for function
05:45:12 * flebron wonders why [a] is Ord...
05:45:43 <merijn> flebron: instance Ord a => Ord [a]"
05:45:47 <flebron> Reminds me of the time I found out std::vector<int> had an operator<... *shiver*.
05:45:59 <merijn> Why?
05:46:01 <mauke_tmp> flebron: because sometimes you want to compare strings
05:46:06 <merijn> because you want to do things like
05:46:10 <mauke_tmp> > sort ["foo", "bar", "baz"]
05:46:11 <merijn> > max "foo" "bar"
05:46:12 <lambdabot>   ["bar","baz","foo"]
05:46:13 <lambdabot>   "foo"
05:46:53 <mauke_tmp> and operator< for vector is useful for when you want to use vectors as keys in std::map
05:46:59 <flebron> Maybe in Haskell it's not that weird. In C++ you usually have a very verbose lexicographical_compare.
05:48:00 <fruitFly> I see that max takes two lists... but what is outputting a function in my expression? I'm on a friends mac and dn't have haskell on it... the dmg for it doesn't seem to be working from haskell.org
05:48:21 <merijn> fruitFly: "max" with your list comprehension is partially applied max :)
05:48:35 <mauke_tmp> fruitFly: every function takes exactly one argument
05:48:44 <mauke_tmp> max x y is equivalent to (max x) y
05:48:44 <merijn> fruitFly: So the result is a function that takes another list and returns the maximum list :p
05:49:01 <mauke_tmp> that is, it calls max with x (which returns a function), and calls the result with y
05:49:09 <merijn> fruitFly: The Haskell Platform should work on OSX...
05:49:33 <typoclass> flebron: anyway, to sum up, use newArray from http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray.html . its signature says it'll produce an "m (a i e)". from the "Instances" list you can see that newArray is able to produce all kinds of things. e.g. there's an instance MArray IOUArray Int16 IO, meaning in "m (a i e)" you'll get m = IO, a = IOUArray, e = Int16
05:49:34 <merijn> fruitFly: Can you be more specific than "it doesn't work", maybe we can help
05:49:55 <fruitFly> merijn: I get it... but on tryhaskell.org it was telling me something about "show"... the command I used in the predicate?
05:49:58 <flebron> typoclass: Yep, I'm using that. It was a bit weird writing IO (IOUArray Int Int), but it works :)
05:50:18 <merijn> fruitFly: tryhaskell and ghci by default try to output the result of an expression
05:50:19 <fruitFly> merijn: the installer... install is greyed out
05:50:32 <fruitFly> mereit says it's from 2010
05:50:56 <merijn> fruitFly: But if the result is something that's not printable (like a function!) then it'll produce an error that it doesn't know how to "show" a function
05:51:10 <merijn> i.e.
05:51:12 <merijn> > max []
05:51:15 <lambdabot>   *Exception: show: No overloading for function
05:51:33 <mauke_tmp> > getLine
05:51:35 <fruitFly> merijn: ooh.. you mean they'll prioritize that over the the maximum function.. I say someone put my let c = a*b in brackets... was that necessary?
05:51:36 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Base.String))
05:51:36 <lambdabot>    arising f...
05:51:48 <fruitFly> merijn: i get that thanks
05:53:52 <fruitFly> what's the right installer for os x 10.5.8?
05:55:01 <merijn> Oh, there isn't one for 10.5 apparently...maybe you want to just install GHC and cabal-install directly and go from there
05:56:15 <flebron> How can I know if a package existed at a given version of the Haskell platform, and what state it existed in (i.e. the state of its API at that version)? I'm trying to see if MArray existed at version 6.10.4, and what functions I have available from that version.
05:56:16 * hackagebot ghc-heap-view 0.5.0.1 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.5.0.1 (JoachimBreitner)
05:56:45 <fruitFly> merijn: link? cabal install?
05:56:46 <flebron> And by "version 6.10.4", I mean the version of the platform that shipped with that GHC version.
06:00:40 <merijn> hmm, looks like 10.5 might require building from source
06:00:58 <merijn> fruitFly: If you use something like macports/homebrew that might be the best way to go
06:01:26 <fruitFly> ooh my... merijn  thanks... might just use online ide for now
06:01:32 <typoclass> random idea -- suppose http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray.html would detect if you moused over (say) the line "MArray IOUArray Float IO", and plug those values into the 3 function signatures in the typeclass, so you can see the concrete resultant type
06:01:39 <elliott> what, you're back _again_?
06:01:41 --- mode: ChanServ set +o elliott
06:01:44 <killy9999> what are package flags in GHC ?>
06:01:45 --- mode: elliott set +b *!*2425dabc@*.36.37.218.188
06:01:45 --- kick: fruitFly was kicked by elliott (ban evasion)
06:01:48 --- mode: elliott set -o elliott
06:02:01 <typoclass> elliott: what was that?
06:02:10 <elliott> typoclass: ban evasion, like it says in the kick message
06:02:44 <elliott> (trollish behaviour here under multiple nicks a few days ago, repeatedly ban evading since then, apparently repeat behaviour in other channels/networks for years)
06:03:12 <typoclass> elliott: hm. the guy didn't seem very disruptive today
06:16:21 <hpaste> Rob pasted “deriving instances within abtract type definition in typeclass” at http://hpaste.org/86561
06:17:28 <robstewartuk> What I am trying to do should be obvious. Is there a way derive classes when defining abstract types in typeclass definitions? e.g.  http://hpaste.org/86561
06:18:08 <flebron> ugh. the impurity. it taints my soul :( http://hpaste.org/86560
06:18:35 <Peaker> flebron, isn't vector supposed to supercede Data.Array?
06:18:55 <flebron> Stylistic question, in C I would do if t1 < 0 || m[t1], in Hask I have to do the ugly things from line 40 to 50... is there a better way?
06:19:13 <flebron> Peaker: It may, but I didn't see it. Can I have unboxed, IO-modifiable vectors?
06:19:28 <Peaker> flebron, yes
06:19:58 <flebron> Then I may very well use Vector :) Are they available in 6.10.4 by any chance? (It's not my install, it's the install on the programming competition site I'm using.)
06:20:00 <Peaker> flebron, firstly, use $ to avoid () around do blocks
06:20:16 <flebron> Oh thanks, that was driving me kind of crazy. The ))) felt like lisp.
06:21:17 <flebron> Hrm. It seems I can't replace it. At least, not the ony on line 45. Is that the one you meant?
06:21:21 <Peaker> flebron, http://hpaste.org/86560
06:21:28 <Peaker> (the annotation)
06:22:11 <flebron> Ah OK, I have to tab it in a certain way. I assume Hask doesn't care between \t and ' '?
06:22:44 <Peaker> flebron, you could write:  p <- ((t1 < 0) ||) <$> readArray m t1
06:22:48 <Peaker> flebron, if p ...
06:23:06 <Peaker> flebron, Don't use tabs.. some Haskeller might come to your house with an axe
06:23:17 <ab9rf> tabs are eeeeeevil
06:23:30 <merijn> Peaker: You don't need "$ do" after then/else
06:23:43 <merijn> You could just write "then do ..." en "else do ..."
06:24:04 <Peaker> oops :)
06:24:07 <merijn> Also, yeah, don't use tabs!
06:24:15 <Peaker> you can't use "$" after then, actually :)
06:24:28 <merijn> Peaker: I was wondering whether that was a syntax error
06:24:33 <Peaker> editing code in a web browser text box :P
06:24:37 <flebron> Yeah, I dislike tabs anyway :)
06:24:49 <ab9rf> i am finding myself rarely using if these days
06:24:51 <ab9rf> more likely to use case
06:25:37 <flebron> Peaker: You are using that if || is true, it won't even read its other operand, meaning it won't carry out the computation?
06:25:52 <Peaker> flebron, well, it won't short-circuit the readArray monadic computation
06:25:56 <flebron> Is that the common idiom for array/vector index access?
06:25:57 <flebron> Ah.
06:26:07 <Peaker> flebron, you would need to write a combinator for short-circuiting monadic or/and
06:26:27 <ab9rf> what?
06:26:40 <merijn> Peaker, flebron: monad-loops to the rescue? :p
06:26:55 <flebron> What is that?
06:27:04 <Peaker> http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
06:27:11 <merijn> flebron: A package with a bunch of common monadic loops
06:27:18 <merijn> including things like andM and orM
06:27:27 <flebron> Oh interesting, orM :)
06:27:43 <merijn> orM :: Monad m => [m Bool] -> m Bool
06:27:47 <flebron> Is there any way to know if this package was available in GHC 6.10.4?
06:28:05 <merijn> I think it's pretty basic, so it should work
06:28:10 <Peaker> flebron, so something like:  orM [return (t1 < 0), readArray m t1]
06:28:12 <flebron> I could just return $ t1 < 0 for the first operand. :)
06:28:30 <flebron> :))
06:28:40 <ab9rf> what is this code attempting to do?
06:29:24 <Peaker> flebron, your branching on it would still need a separate line for the extracted value to "if" it.. unless you also write an if/then/else monadic combinator
06:29:54 <flebron> Oh right, that's IO Bool, because it may need to carry out that operation.
06:30:15 <flebron> ab9rf: See the "Definition of the sequence f" comment in the paste.
06:30:39 <Peaker> ifThenElseM mp t f = mp >>= \p -> if p then t else f
06:30:53 <ab9rf> why is there IO all over the place for this function?
06:30:55 <Peaker> @type let ifThenElseM mp t f = mp >>= \p -> if p then t else f in ifThenElseM
06:30:56 <lambdabot> Monad m => m Bool -> m b -> m b -> m b
06:30:58 <flebron> "    Could not find module `Control.Monad.Loops':" :( And if I don't have it, it's fat chance the contest site will :s
06:31:05 <flebron> ab9rf: Because it's using IOUArray.
06:31:10 <ab9rf> flebron: why?
06:31:13 <flebron> I can try it anyway :)
06:31:20 <Peaker> flebron, in the URL there you can see it's coming from the "monad-loops" package, cabal install it
06:31:25 <flebron> ab9rf: Because it's modifying unboxed values.
06:31:29 <ab9rf> flebron: why?
06:31:35 <flebron> Peaker: Yeah, I will :)
06:31:50 <flebron> ab9rf: To compute the function.
06:31:58 <flebron> I know of no other way to reply to your "why".
06:32:06 <ab9rf> flebron: why is it necessary to modify unboxed values to compute this function?
06:32:08 <Peaker> flebron, btw, this computation doesn't need to be in IO, it could be in ST s
06:32:17 <flebron> ab9rf: It is not necessary, but it is the fastest.
06:32:25 <ab9rf> flebron: mmm
06:32:25 <flebron> And yes, it could be in State as well.
06:32:29 <pxqr> Peaker: why monad-loops doesn't implement something like mapAccumM ?
06:32:30 <Peaker> ab9rf, imperative algorithms are sometimes faster than their functional counterparts
06:32:36 <ab9rf> Peaker: i am aware of that
06:32:36 <flebron> I previously had used State with IntMap, but it was too slow.
06:32:37 <Peaker> flebron, in State it would be slow/not same algorithm
06:32:47 <Peaker> flebron, In ST it will be just as fast as IO
06:32:56 <Peaker> flebron, but it will have a pure interface
06:33:03 <ab9rf> i don't understand why you/re using IO when you could use ST
06:33:06 <flebron> I'm half scared of the copying around that state would need to do.
06:33:16 <Peaker> flebron, ST is not State
06:33:23 <flebron> Ah, what is it then?
06:33:25 <flebron> StateT?
06:33:26 <Peaker> flebron, ST is like IO where the only effect possible is mutating inplace
06:33:40 * flebron has never seen this typeclass.
06:33:46 <Peaker> it's a type, not a type-class
06:33:50 <Peaker> Control.Monad.ST
06:33:57 <pxqr> flebron: ST state is State Token
06:34:01 <Peaker> flebron, and it has type-level trickery to make sure that different ST computations are segregated, that they can't share mutable state
06:34:20 <Peaker> flebron, which makes each ST computation completely deterministic/pure as it only depends on its input
06:34:26 <Peaker> flebron, which allows having the function:
06:34:28 <Peaker> @type runST
06:34:29 <flebron> Cool :)
06:34:31 <lambdabot> (forall s. ST s a) -> a
06:34:41 <Peaker> (which is safe)
06:35:08 <Peaker> flebron, so like you have IOUArray, there is STUArray
06:35:22 <ab9rf> is there a STFUArray? :)
06:35:27 <Peaker> @type runSTUArray
06:35:29 <lambdabot> Not in scope: `runSTUArray'
06:35:59 <flebron> I'll check that out, then. I'm sort of limited in that the version of GHC in the contest site is ancient, so a bunch of things don't exist (State still exports its ctor, as opposed to having state :: (s -> (a, s)) -> State s a, for example. I think that is something about MTL.)
06:36:20 <Peaker> runSTUArray  :: Ix i => (forall s. ST s (STUArray s i e)) -> Data.Array.Base.UArray i e
06:36:54 <Peaker> flebron, there used to be State and StateT data-types with their own data constructors.. they were unified into StateT, and State is a type alias for StateT with Identity
06:37:22 <flebron> Hence the lovely error messages I've seen about that when I screw up my types, and Identity shows up in places :)
06:37:35 <flebron> Thanks for the info :)
06:40:38 <klrr> ?src map
06:40:39 <lambdabot> map _ []     = []
06:40:39 <lambdabot> map f (x:xs) = f x : map f xs
06:42:19 <hpaste> ocharles pasted “Phantom types and type classes” at http://hpaste.org/86563
06:42:34 <ocharles> Hello
06:42:44 <ocharles> Is there anyway to get the above to compile without bringing 'phantom' into the type class?
06:43:13 <ocharles> the error is that ghc can't prove that the two phantom type variables are actually the same
06:44:24 <ocharles> the error certainly makes sense, but in the actual code I have I was hoping to not crowd the type class with phantom types. If unavoidable I can introduce it
06:44:47 <pxqr> ocharles: nice question. But why does you need that?
06:45:07 <ocharles> The phantom type?
06:45:14 <arkeet> what if you add an associated type instead of an extra parameter?
06:45:15 <hpaste> ocharles revised “Phantom types and type classes”: “Phantom types and type classes (with ghc error)” at http://hpaste.org/86563
06:45:48 <ocharles> arkeet: hmm, that might be possible
06:45:59 <ocharles> for context:
06:46:23 <ocharles> I'm writing a general OAuth implementation for Snap, and I want to have pluggable backends (PostgreSQL, SQLite, etc)
06:46:46 <ocharles> I have type class, OAuthBackend, which amongst other methods has storeToken :: AccessToken scope -> IO ()
06:47:03 <ocharles> scope is a phantom type that the actual application developer providers, which defines the set of possible scopes for that specific application
06:47:32 <ocharles> So i'm not sure if this is the right place for the type family to belong
06:47:51 <ocharles> the backend doesn't define scope, the end-user of the library does
06:48:15 <ocharles> (I need a phantom type to convert to/from text that comes over http and to provide something with a bit stronger typing)
06:48:17 <supki> why not  foo :: a  foo = Bob X ?
06:48:54 <ocharles> Let me refine my question with real classes, I think that'll be easier :)
06:49:28 <pxqr> ocharles: well, you can actually cheat. Can you repack data in X, so typechecker can change fantom type to the one inferred?
06:49:34 <pxqr> in the 'foo'
06:50:22 <hpaste> ocharles revised “Phantom types and type classes”: “Phantom types/OAuth” at http://hpaste.org/86563
06:50:27 <pxqr> or it will break something?
06:50:28 <ocharles> How's thatL
06:50:32 <ocharles> ?
06:50:57 <merijn> ocharles: You can force the compiler to check phantom types properly using GADTs
06:51:17 <ocharles> merijn: I had a feeling some more complex type machinery would let me pull this off
06:52:10 <merijn> The problem is that "normal" data declarations like "data Foo a = Foo String Int" (or whatever) don't stop you from writing "Foo "" 1 :: Foo Bool" or some other nonsensical type
06:52:53 <ocharles> I do get GADT's (at a basic level) as I use them in other bits of my project
06:52:56 <pxqr> ocharles: i mean something like:   foo X  = Bob X
06:52:58 <ocharles> I'm just not sure how they apply here
06:53:15 <ocharles> pxqr: I'm afraid I'm not following your suggestion
06:53:22 <merijn> {-# LANGUAGE GADTs #-} lets you do "data Auth a where AuthFoo :: String -> Bool -> Auth SomeAuth; AuthBar :: Int -> Int -> Auth OtherAuth"
06:54:27 <merijn> ocharles: Using DataKinds you could even define "data AuthTypes = SomeAuth | OtherAuth" and write it as "data Auth :: AuthType -> * where ..." which would make "Auth Bool" (or any type other than SomeAuth or OtherAuth) a kind error
06:54:36 <ocharles> sure, but that still doesn't help here
06:54:43 <ocharles> The set of constructors is not defined by my library
06:55:10 <merijn> Maybe I'm miss understanding the problem...
06:55:21 <ocharles> The idea is someone might do  data BlogScope = AddComments | WritePosts | DeletePosts  and plug that into the OAuth stuff later
06:56:06 <merijn> Actually
06:56:08 <ocharles> but I can't figure out how to tell GHC that given   instance OAuthBackend (InMemory scope)   that the 'scope' in  storeToken :: AccessToken scope -> ...  has to match the scope bought in earlier
06:56:14 <merijn> Looks like you want a data family?
06:56:31 <ocharles> I have an idea of how it could be done with data families, but I haven't yet tried it
06:56:48 <merijn> Or maybe a fundep would work too
06:57:24 <merijn> the problem is that a is separate from phantom in "X phantom -> a"
06:57:30 <ocharles> I know that :)
06:58:07 <ocharles> so I need to somehow figure out how to tie them together
06:58:46 <ocharles> I could say that a :: * -> *, then I can do X phantom -> a phantom
06:58:51 <merijn> data family would let you write like "class Blah a where type Blah a :: * -> *; foo :: X phantom -> Blah a phantom"
06:59:20 <merijn> Then when you define an instance of blah you can specify that "Blah a = Bob"
06:59:52 <merijn> Which means that "foo :: X phantom -> Bob phantom" for Blah a
07:00:02 <ocharles> you've used Blah twice, is that correctL
07:00:03 <ocharles> ?
07:00:10 <ocharles> (a type class and a type)
07:00:20 <merijn> ocharles: Yes, I think. I'm not 100% sure on syntax
07:00:29 <merijn> ocharles: Google "Fun with Type Functions" that has some examples
07:00:36 <ocharles> yea, I've used type families before
07:00:49 <merijn> Which will actually be correct, unlike my half guessed example :p
07:01:40 <ocharles> I think I'm just going to make a :: * -> *   and then I can have   storeToken :: oauth scope -> AccessToken scope -> IO ()
07:01:57 <pxqr> someone tried to use overlapped type families from the new ghc? According to git log it seems like they have been implemented a half year ago.
07:02:04 <merijn> pxqr: I have
07:02:11 <merijn> pxqr: And it's *sweet*
07:02:24 <pxqr> merijn: heh
07:02:26 <merijn> pxqr: You're referring to "type instance where", right?
07:02:30 <pxqr> yes
07:02:33 <ocharles> I guess doing this means that you can only implement a backend once, not once per scope
07:02:36 <ocharles> which seems nice
07:02:58 <merijn> pxqr: Working fine so far
07:07:37 <ocharles> yay, compilation
07:38:09 <ryantanjunming> :t Char
07:38:10 <lambdabot>     Not in scope: data constructor `Char'
07:38:11 <lambdabot>     Perhaps you meant `Chr' (imported from Text.PrettyPrint.HughesPJ)
07:38:16 <Iceland_jack> :i Char
07:38:25 <ryantanjunming> :i Char
07:38:28 <ryantanjunming> nothing...
07:38:39 <Iceland_jack> @info Char
07:38:40 <lambdabot> Char
07:38:47 <ryantanjunming> @info String
07:38:48 <lambdabot> String
07:38:52 <Iceland_jack> @kind Char
07:38:54 <lambdabot> *
07:39:02 <ryantanjunming> @kind String
07:39:07 <lambdabot> *
07:39:25 <ryantanjunming> @
07:41:36 <parcs> :k (# , #)
07:41:37 <lambdabot> ArgKind -> ArgKind -> (#)
07:41:39 <hseg> How does fix work? I don't see how GHC infers the correct result from the definition.
07:41:44 <parcs> :k (# Int, Char #)
07:41:45 <lambdabot> (#)
07:42:00 <parcs> hseg: do you mean correct type?
07:42:22 <mauke_tmp_> the result is computed, not inferred
07:42:32 <hseg> No, the result. fix f = let x = f x in x. How do you compute fix f from that?
07:42:58 <mauke_tmp_> by running 'let x = f x in x'
07:42:59 <elliott> laziness
07:43:10 <elliott> hseg: do you understand how
07:43:12 <parcs> hseg: it's probably easier to think about fix f = f (fix f)
07:43:13 <elliott> fix f = f (fix f)
07:43:13 <elliott> could work?
07:43:17 <elliott> the let form is just an optimisation.
07:43:27 <elliott> > fix f :: Expr
07:43:30 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
07:43:34 <mauke_tmp_> I don't like that explanation :-/
07:43:35 <elliott> > fix (1+) :: Expr
07:43:37 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
07:43:47 <hseg> So basically you're lazily evaluating f . f . f . f . f . ... ad infinitum?
07:44:25 <parcs> you can think of it that way
07:44:49 <hseg> so basically it's foldr1 (.) $ cycle [f] ?
07:45:04 <mauke_tmp_> :-(
07:45:06 <danr> or repeat f
07:45:16 <danr> and foldl perhaps
07:46:31 <parcs> > foldr1 (.) (repeat (+1)) undefined :: Expr
07:46:35 <lambdabot>   mueval-core: Time limit exceeded
07:47:03 <danr> you probably want fix of a function that is not strict :)
07:47:24 <Mortchek> > foldr' (.) id (repeat (1 :)) undefined
07:47:28 <lambdabot>   mueval-core: Time limit exceeded
07:47:30 <Mortchek> Err
07:47:33 <Mortchek> > foldl' (.) id (repeat (1 :)) undefined
07:47:37 <lambdabot>   mueval-core: Time limit exceeded
07:48:05 <parcs> hseg: do you understand how let x = 1:x in x works
07:48:10 <Mortchek> > foldr (.) id (repeat (1 :)) undefined
07:48:10 <danr> > foldr (.) id (repeat (1:)) undefined
07:48:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:48:12 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:48:14 <danr> ^^
07:48:16 <danr> high five
07:48:23 <Mortchek> o/
07:48:27 <danr> \o
07:48:29 <parcs> > foldr (.) id (repeat (+1)) undefined :: Expr
07:48:33 <lambdabot>   mueval-core: Time limit exceeded
07:48:37 <parcs> stupid reflection
07:49:13 <parcs> > foldr1 (.) (repeat (1+)) undefined :: Expr
07:49:14 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
07:49:29 <hseg> parcs: I guess GHC lazily constructs the infinite list (repeat 1), where it only evaluates the finite prefix accessed by the program.
07:50:09 <hseg> I think I got it.
07:50:35 <parcs> yeah, you have a (:) constructor with a pointer to a 1 and a pointer to itself
07:50:58 <hseg> Also, I was wondering the other day whether it would be possible to have multiple values of differing types bound to the same name in the same scope, and have GHC disambiguate between them based on their type?
07:51:31 <danr> hseg: only for record fields, see the DisambiguateRecords extension
07:51:34 <mauke_tmp_> > (pi :: Float, pi :: Complex Double)
07:51:36 <lambdabot>   (3.1415927,3.141592653589793 :+ 0.0)
07:52:02 <hseg> Why can't this be done with arbitrary names?
07:52:12 <danr> DisambiguateRecordFields
07:52:28 <danr> hseg: something similar to what you want is done with type classes
07:52:37 <danr> well the functions of a type class
07:52:37 <merijn> hseg: It can be done, type directed name lookups, but it's a bit controversial and so far people haven't decided whether they want that in GHC or not
07:52:43 <geekosaur> hseg, the general case.. you can choose either that, or type inference
07:52:48 <merijn> Because it means you break type inference
07:52:53 <geekosaur> you can't do both at the same time
07:53:04 <parcs> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution-
07:53:08 <hpaste> “COVERT AGENDA TO BAN AMMUNITION” pasted “COVERT AGENDA TO BAN AMMUNITION” at http://hpaste.org/86566
07:53:09 <parcs> oops remove the -
07:53:32 <hseg> Ah. Because it means that you usually need explicit type signatures to disambiguate?
07:53:56 <parcs> imo it's not worth the effort
07:54:20 <parcs> just give the two things distinct names and get on with it
07:54:59 <merijn> hseg: Yes
07:55:13 <hseg> OK. You mentioned it's possible using type classes. How so?
07:56:03 <parcs> @src Floating
07:56:03 <lambdabot> class  (Fractional a) => Floating a  where
07:56:03 <lambdabot>     pi                                                      :: a
07:56:03 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
07:56:03 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
07:56:03 <lambdabot>     (**), logBase                                           :: a -> a -> a
07:56:34 <parcs> e.g. class ThingName a where thingName :: a
07:57:36 <hseg> Ah. Isn't it possible to solve the record namespacing problem that way?
07:58:14 <klrr> > read "2"
07:58:16 <lambdabot>   *Exception: Prelude.read: no parse
07:58:18 <hseg> i.e. class hasFieldFoo r where foo :: r -> fooType
07:58:21 <klrr> why doesnt it work?
07:58:36 <parcs> klrr: how does lambdabot know you want an Int?
07:59:12 <klrr> parcs: aa true
07:59:17 <klrr> > read "2" :: Int
07:59:19 <lambdabot>   2
08:00:16 <Mortchek> It feels like type directed name resolution is at odds with the parameter you usually want because of currying
08:00:37 <Mortchek> e.g., you want to say myMap.lookup for the former but lookup key value myMap for the latter
08:00:51 <Mortchek> parameter order*
08:02:31 <hseg> Wait. Isn't it possible to make {foo :: Foo, bar :: Bar} desugar to class hasFoo r where foo :: r -> Foo, and similarly for bar, then make the record an instance of both?
08:02:54 <parcs> anything is possibel
08:02:55 <hseg> And replace the record by a product of Foo and Bar?
08:03:15 <hseg> Right. But why wouldn't we redefine records this way?
08:05:59 <parcs> well that restricts all fields named 'foo' to have the type Foo
08:06:35 <parcs> you probably want 'class HasFoo a b where type FooResult a; foo :: a -> FooResult a'
08:06:59 <hseg> Right.
08:07:02 <magicman> (what's that b for?)
08:07:09 <parcs> oops
08:07:28 <parcs> but that doesn't fix the tangential issues of how to conveniently update record fields
08:07:42 <parcs> nobody has put in the effort to make a solid records overhaul
08:08:58 <hseg> Right, but at least you would have some freedom in defining record field names
08:09:36 <parcs> but what does that buy you?
08:09:53 <parcs> in the big picture it's hardly a big deal
08:10:31 <klrr> ?src pzero
08:10:32 <lambdabot> Source not found. Are you on drugs?
08:10:35 <klrr> what does pzero?
08:11:28 <hseg> Hm. It's just that I ran into the namespacing problem recently, and type-directed name resolution and typeclass-based records seemed the best solutions at the time.
08:11:33 <Mortchek> @hoogle parserZero
08:11:33 <lambdabot> Text.Parsec.Prim parserZero :: ParsecT s u m a
08:12:22 <Mortchek> klrr, it's this: http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:parserZero
08:22:42 <parcs> hseg: in general you give each field a distinct name (usually by prefixing it with the initials of the data constructor or something like that) and if you have data types that share a common field, it may be worth it to write a typeclass for accessing and modifying that field
08:23:05 <parcs> multiple data types*
08:23:47 <hseg> Thanks.
08:32:24 <ryantanjunming> whats the type definition of lists?
08:32:48 <Iceland_jack> ryantanjunming: What do you mean by that?
08:33:03 <mauke_tmp> @src []
08:33:03 <lambdabot> data [] a = [] | a : [a]
08:33:18 <ryantanjunming> thanks, i'll try that
08:33:22 <ab9rf> try?
08:33:37 <mauke_tmp> haha
08:33:40 <Eduard_Munteanu> ryantanjunming: you can't try
08:33:47 <tromp__> they're not user definable with this syntax
08:33:49 <Eduard_Munteanu> ryantanjunming: that's not an actual definition
08:34:07 <Eduard_Munteanu> It's a pseudohaskelly way to describe it.
08:34:13 <tromp__> they're built-in by necessity
08:34:26 <ryantanjunming> data Format :: * -> * where
08:34:26 <ryantanjunming>   X :: Format Nil
08:34:26 <ryantanjunming>   L :: Format [Char]
08:34:26 <Eduard_Munteanu> data List a = Nil | Cons a (List a)      would do, on the other hand
08:34:27 <ryantanjunming>   S :: Format Char
08:34:29 <ryantanjunming>   I :: Format Int
08:34:31 <ryantanjunming> (L "Hello " (S (L "! You are " (I (L " years old!" X)))))
08:34:33 <ryantanjunming>   :: Format (String ::: (Int ::: Nil))
08:34:39 <ryantanjunming> https://gist.github.com/anonymous/965f2cf383de983d2811
08:34:43 <ab9rf> please don't paste code in the channel
08:34:45 <ryantanjunming> sry, pasted wrongly..
08:35:18 <Eduard_Munteanu> (or more precisely, don't paste anything longer than 2-3 lines or so, YMMV)
08:36:10 <Eduard_Munteanu> (in the channel; pastebin is fine for anything :D)
08:36:25 <ryantanjunming> yeah, my chatapp.. pressed the wrong button
08:36:32 <ryantanjunming> ive pasted it there
08:36:39 <ryantanjunming> https://gist.github.com/anonymous/965f2cf383de983d2811
08:37:29 <slack> you can also paste it in hpaste and it will be annunciated automagically
08:37:45 <ab9rf> as well as linted :)
08:37:48 <ryantanjunming> ok
08:37:57 <ryantanjunming> need help with GADTs
08:38:32 <ryantanjunming> the S needs to be a string type, the I an Int, and X a Nil.. I'm guessing that L is a list format but its wrong there..
08:38:52 <Eduard_Munteanu> I'm sure they appreciated the announcing and linting in this case: < hpaste> “COVERT AGENDA TO BAN AMMUNITION” pasted “COVERT AGENDA TO BAN [...]
08:38:58 <Eduard_Munteanu> :P
08:39:51 <ryantanjunming> @hpaste
08:39:51 <lambdabot> Haskell pastebin: http://hpaste.org/
08:41:05 <ab9rf> ryantanjunming: L is "literal", not list
08:41:25 <ryantanjunming> like?
08:42:44 <ryantanjunming> :t Literal
08:42:46 <lambdabot> Not in scope: data constructor `Literal'
08:42:55 <ryantanjunming> @like Literal
08:42:55 <lambdabot> Maybe you meant: dice elite list time wiki
08:44:11 <ryantanjunming> ab9rf: u sure? i changed it to Format Literal and it doesnt compile..
08:44:45 <ab9rf> ryantanjunming: i mean that L represents a string literal
08:45:22 <ryantanjunming> ab9rf: what do u think S represents then?
08:46:56 <geekosaur> Char is not [Char]; S looks like a character constant?
08:47:07 <ab9rf> ryantanjunming: probably a string interpolation
08:47:27 <ab9rf> at least, that fits with the sample invocation
08:49:20 <oio> gettig this
08:49:22 <oio> failed during the building phase. The exception was: ExitFailure 1
08:50:47 <hpaste> natnayr pasted “GADTs” at http://hpaste.org/86567
08:51:22 <ryantanjunming> ab9rf: ive pasted more examples there, including the diff between those of L & S...
08:51:38 <oio> haddock-0.9
08:51:57 <ryantanjunming> this confuses me, knowing that String = [Char] but String is already an accepted definition....
09:04:21 <ab9rf> ryantanjunming: it's just a type equivalence for convenience
09:06:23 * hackagebot curl-aeson 0.0.3 - Communicate with HTTP service using JSON  http://hackage.haskell.org/package/curl-aeson-0.0.3 (JoelLehtonen)
09:06:58 <erisco> I am a little confused. Why can a tuple type not be substituted for a type variable?
09:07:34 <arkeet> where?
09:09:04 <erisco> hm, seems more nuanced that I thought
09:10:32 <erisco> linkie: http://hpaste.org/86571
09:10:49 <erisco> signature on line 4 is invalid
09:11:20 <sgronblo> Has anyone watched this monad talk by Douglas Crockford on youtube? I am not sure if he's mistaken on some points or not.
09:11:20 <erisco> yet I can do something like this fine: http://hpaste.org/86572
09:12:05 <JordiGH> Would Haskell be a good language for automating a diagram chase?
09:12:09 <elliott> sgronblo: he's mistaken on roughly every point.
09:12:17 <elliott> (I haven't watched it but I've heard enough from others.)
09:12:39 <erisco> also the signature on line 1 should be invalid I suppose, but I don't quite understand what is wrong with 4
09:13:22 <erisco> my reasoning is getting twisted somewhere
09:13:49 <arkeet> erisco: it looks quite wrong, indeed.
09:14:16 <arkeet> erisco: when you are given c as an argument, you cannot choose its type.
09:14:24 <arkeet> c 2 has type a, for some fixed a.
09:14:31 <ab9rf> a tuple is not a function\
09:14:33 <arkeet> if c :: Int -> a
09:14:34 <erisco> why can I not restrict its type?
09:14:44 <ab9rf> nevermind, i'm asleep
09:15:59 <sgronblo> elliott: did anyone write something about it or?
09:16:03 <arkeet> erisco: what we have is that
09:16:08 <erisco> arkeet, I don't follow. Is there something about currying c2?
09:16:17 <arkeet> no, it's not even that.
09:16:22 <arkeet> what we have is "there exists a type a, such that c :: Int -> a"
09:16:40 <erisco> why?
09:16:50 <arkeet> because c is an argument
09:17:02 <arkeet> it's on the left side of ->
09:17:04 <erisco> I don't understand what you've put in quotes
09:17:12 <arkeet> it means
09:17:18 <arkeet> someone might give you c :: Int -> Char
09:17:25 <arkeet> or c :: Int -> [(Bool,String)]
09:17:26 <arkeet> you don't know
09:17:29 <arkeet> so you can't assume
09:17:31 <erisco> okay, so?
09:17:35 <erisco> where do I assume?
09:17:41 <arkeet> c3 takes a tuple as a first argument.
09:17:44 <arkeet> you can't assume that c returns a tuple.
09:17:53 <erisco> oh
09:17:56 <erisco> right, thank-you
09:18:05 <ab9rf> yeah, that's it
09:18:25 <arkeet> you should smell something wrong when you see a type like that of f1 or f2.
09:18:51 <merijn> sgronblo: You might get more constructive feedback if you have some examples of things you're wondering about, as it seems unlikely people will go watch an entire talk to answer that question for you :)
09:18:52 <arkeet> the type of f1 basically implies that f1 can produce a value of type 'a', for any a. out of thin air.
09:19:11 <arkeet> and f2 can produce a 'b' only using stuff that, in general, has nothing to do with b.
09:19:16 <erisco> arkeet, right, I've acknowledged that f1's signature is wrong
09:19:31 <arkeet> so when someone uses your f2
09:19:35 <awgn> Hi. By means of Template Haskell, I need to create a top level function whose name depends on a parameter Any example available?
09:19:36 <arkeet> they can specialize it to whatever they want.
09:19:55 <arkeet> like f2 :: (Int -> Char) -> [String]
09:19:57 <arkeet> or something
09:20:06 <arkeet> in particular they may pick b to be a type with no values.
09:20:20 <erisco> this is tricky to establish... perhaps I could use some guidance
09:20:34 <arkeet> basically,
09:20:46 <arkeet> when you write a polymorphic function, the caller is free to choose what the type variables represent.
09:20:52 <ab9rf> arkeet: yeah, i thought that f1 type seemed fishy.
09:21:00 <arkeet> and you, the implementer, must be able to handle any types you're given.
09:21:19 <awgn> I was trying something like makeFun name = [d| $name .. |] but I get Parse error in pattern: $name
09:21:20 <erisco> arkeet, agreed. I just didn't realize where the conflict was happening, but you've pointed it out on c3
09:21:29 <arkeet> ok
09:23:00 <sgronblo> merijn: yeah i just wondered if it was a known fact that it was flawed or something. i am still not comfortable enough with monads to say why the video seems strange to me. but reducing monads to method calls that return this seems like missing the point to me somehow.
09:23:31 <sgronblo> and the description of the maybe monad seemed strange too
09:24:54 <elliott> people have already watched it.
09:25:19 <elliott> the answer is really just as simple as: he is hopelessly confused. if he understands monads, which is questionable, he definitely doesn't understand how to explain them
09:25:30 <ab9rf> sgronblo: that can't be right
09:25:38 <elliott> and his choice of javascript as a setting clouds his thinking, presentation, /and/ what people get out of it.
09:25:51 <ab9rf> "method calls that return this" is not a meaningful definition of a monad
09:25:51 <merijn> sgronblo: The general consensus is that the best way to get comfortable with monads is this http://dev.stephendiehl.com/hask/#(8)
09:26:30 <merijn> sgronblo: Optionally, you can also add reading "You Could Have Invented Monads (And Maybe You Already Have!)"
09:26:31 <ab9rf> javascript is a terrible language to talk about programming language concepts in
09:26:38 <merijn> Which is the only worthwhile monad tutorial
09:26:54 <merijn> They're just not that complicated, tbh
09:27:07 <arkeet> lots of things aren't complicated once you figure them out.
09:27:39 <merijn> arkeet: IMO the general problem with monads is that people try to understand them before understanding type signatures and typeclasses
09:27:48 <arkeet> ah. that is a problem.
09:27:57 <merijn> And then get confused into thinking they're some really complicated magical thing
09:28:05 <sgronblo> hehe yeah i have had those slides open in my browser for a while without having had time to read through, also read the you could have.
09:28:29 <arkeet> but once you have the prerequisites, it's a matter of playing with them and reading/thinking about them until you get some intuition for them.
09:28:37 <merijn> sgronblo: I usually recommend trying to implement your own Monad instance for Reader/State/Maybe and List
09:28:39 <sgronblo> i think my main problem right now is i havent had a lot of time to actually try to use monads.
09:28:51 <arkeet> Maybe and State are good ones.
09:29:07 <sgronblo> just absorbing information about them
09:29:14 <merijn> sgronblo: Another tip
09:29:20 <arkeet> well, more exposure is better.
09:29:21 <arkeet> :p
09:29:23 <merijn> sgronblo: Until you feel comfortable, avoid do-notation
09:29:32 <sgronblo> and i havent really internalized how do notation gets desugared into >>=
09:29:46 <merijn> sgronblo: I think it's better to write monadic code using >>= and >> until that all makes sense *then* switch to do notation
09:30:42 <sgronblo> merijn: ah thanks for the tip, i guess this fits the case where if you havent done something the "hard way" you cant appreciate the "easy way".
09:31:05 <arkeet> I wouldn't call it hard.
09:31:07 <arkeet> just more explicit.
09:31:25 <sgronblo> yeah i used quotes because i couldnt think of a more appropriate adjective
09:31:29 <merijn> sgronblo: Yeah, a lot of things people think are weird/quirky make perfect sense if you see them written using >>=
09:31:30 <arkeet> :)
09:31:57 <arkeet> there was one question on -cafe not long ago regarding confusion about scoping rules when mixing do and where or something.
09:32:09 <arkeet> turns out that the answer was obvious once the do notation was desugared.
09:34:36 <klrr> can someone explain why i get these strange errors? http://hpaste.org/86574 (code and error in paste)
09:35:08 <sgronblo> i think i'd need to find some nice exercises to do to get me more comfortable with using monads
09:36:08 <Cale> klrr: show is meant to produce a String
09:36:25 <klrr> Cale: where do i have show?
09:36:33 <Cale> instance Show Value where
09:36:37 <Cale>   show value = ...
09:36:46 <Cale> and you have a case there with  Bool x -> x
09:36:55 <Cale> x :: Bool in that branch
09:37:01 <Cale> and so it's the wrong type
09:37:06 <klrr> yes, then it will return real bool which is already of typeclass Show
09:37:16 <Cale> You'd still need to apply show
09:37:30 <Cale> i.e.  Bool x -> show x
09:37:33 <merijn> sgronblo: Write a number guessing game without do-notation? That's as good a start as any...
09:37:33 <klrr> okey
09:38:00 <Cale> The next one comes from type signatures scoping over the entire expression to which they're applied
09:38:08 <Cale> You can solve that just using parens
09:38:30 <klrr> Cale: how, i tried "read (num ++ "." ++ frac) :: Double" in ghci and it worked fine
09:38:31 <Cale> return $ Number (read (num ++ "." ++ frac) :: Double)
09:38:37 <klrr> oh thanks!
09:38:56 <Cale> It's because the type signature you wrote applied to the whole line, including the  return
09:39:12 <Cale> and similarly in the other cases
09:39:55 <dmj> simple question, given data D = A { num :: Double }, let g = A { num = 5.0 }, how do I get the 5.0 out of g and assign it to something else? D is not a functor
09:39:55 <dmj>  
09:39:55 <dmj>  
09:39:55 <dmj>  
09:40:45 <Saizan> dmj: num g
09:41:24 <merijn> Saizan: I think you meant lens :D
09:42:20 <erisco> how do I make a 0 explicitly an Int?
09:42:28 <elliott> (0 :: Int)
09:42:41 <erisco> thanks
09:42:49 <dmj> Saizan: thanks
09:46:13 <erisco> how might you define a function which can be called an arbitrary number of times?
09:46:40 <arkeet> ??
09:46:45 <quchen> "f = ..."?
09:46:47 <arkeet> any function can be called an arbitrary number of times.
09:46:52 <quchen> "f = ...".
09:46:54 <geekosaur> I have no idea what that question means
09:46:57 <merijn> erisco: what does that mean?
09:47:11 <ab9rf> it would be harder i should think to write a function that can only be called once :)
09:47:22 <erisco> that was vague, sorry
09:47:29 <arkeet> ab9rf: it could be useful though
09:47:39 <quchen> ab9rf: error will do
09:47:39 <gspr> erisco: Do you mean perhaps a function that can be composed with itself an arbitrary number of times?
09:47:42 <ab9rf> quchen: heh
09:48:09 <otters> an idempotent function?
09:48:19 <ab9rf> arkeet: i think that's the singleton (anti)pattern
09:49:27 <merijn> otters: All haskell functions are idempotent, since they're pure...
09:49:44 <otters> right
09:49:52 <arkeet> uhhhhhh
09:50:02 <arkeet> f being idempotent means f (f x) = f x.
09:50:22 <merijn> arkeet: It depends on context
09:50:33 <erisco> I guess what I meant is equivalent to a function which accepts an arbitrary number of arguments
09:50:35 <arkeet> I am not aware of any other context.
09:50:42 <merijn> arkeet: At least, I've never encountered that context
09:50:47 <erisco> but, never mind, I don't think that is what I need to do
09:50:58 <arkeet> erisco: it's possible but ugly.
09:51:09 <merijn> arkeet: In distributed/concurrent programming it's that "f(); f();" is identical to "f();"
09:51:12 <arkeet> and, unless you know what you're doing, unnecessary.
09:51:13 <quchen> erisco: That's known as the "vararg problem" and you shouldn't solve it. http://www.haskell.org/haskellwiki/Varargs
09:51:26 <quchen> You should rather define more sensible functions in most cases. :-)
09:51:27 <merijn> arkeet: i.e. if you drop a message/whatever repeating the message is safe
09:51:42 <arkeet> merijn: I wouldn't call f() an function, then ;)
09:51:44 <arkeet> a
09:51:59 <merijn> arkeet: Hence my observation that all haskell functions are by definition idempotent
09:52:18 <arkeet> no.
09:52:29 <arkeet> I would still not say that.
09:52:32 <quchen> let f = const (modify (+1)) -- ;-)
09:52:34 <arkeet> I might say that evaluation is idempotent.
09:52:44 <ab9rf> arkeet: that follows from purity
09:53:13 <arkeet> but certainly the function itself is not.
09:53:18 <merijn> Only IO execution isn't idempotent by default
09:53:22 <merijn> arkeet: Why not?
09:53:23 <arkeet> and indeed, what you want to say also makes sense for non-functions.
09:54:39 <arkeet> merijn: because what it means for a (mathematical) function to be idempotent has nothing to do with evaluation.
09:54:59 <arkeet> "idempotent" makes sense in any semigroup.
09:55:13 <merijn> arkeet: A pox on you mathematical nonsense
09:55:31 <arkeet> when you say "function", the only semigroup I can see around is the one whose operation is function composition.
09:56:26 <erisco> quchen, ah, that is a clever way to overcome the problem
09:56:39 <arkeet> but you probably shouldn't.
09:56:48 <quchen> erisco: It's not recommended.
09:57:45 <quchen> erisco: That page is mostly a proof of concept. (The only base/platform module that uses it is Printf, where it arguably makes sense)
09:57:46 <arkeet> I just noticed it's ugly too.
09:58:02 <arkeet> since it gives an instance PrintAllType (IO a), not just IO ().
09:58:06 <quchen> Also it gives you weird error messages.
09:58:10 <arkeet> and Text.Printf does the same.
09:58:15 <arkeet> or does it?
09:58:40 <quchen> Yes it's IO a
09:58:51 <arkeet> and the only reason for the IO a is to make type inference work.
09:59:30 <arkeet> in exchange for scariness.
10:04:58 <abc22134> @djinn (a,b)->a
10:04:59 <lambdabot> f (a, _) = a
10:05:29 <erisco> quchen, I don't know how they avoid an infinite type, so even so, it seems worth me looking at
10:05:49 <abc22134> @djinn (a -> d -> e) -> a -> (f -> d) -> f -> e
10:05:50 <lambdabot> f a b c d = a b (c d)
10:09:59 <erisco> what they're doing looks like this to me: http://hpaste.org/86577 so I don't know where the secret sauce comes in
10:10:50 <arkeet> erisco: time to read about polymorphic recursion, then.
10:11:14 <erisco> will do
10:21:55 <otters> @djinn (a -> (c -> d) -> b) -> r -> (f -> c) -> (d -> b)
10:21:56 <lambdabot> -- f cannot be realized.
10:26:05 <neutrino> hey guys
10:27:38 <neutrino> i have data Tree a = Leaf | Node a (Tree a) (Tree a). It's filled with Int's. How can I get the node which has the largest number?
10:27:39 <hpaste> awgn pasted “Haskell Template function declaration” at http://hpaste.org/86582
10:28:05 <awgn> what's wrong with such a snippet ?
10:28:50 <ramses_> neutrino: simple recursion? What's the issue exactly?
10:30:28 <neutrino> ramses_: let me post my code
10:30:35 <neutrino> it feels very big
10:30:58 <hpaste> neutrino pasted “largest node” at http://hpaste.org/86583
10:31:08 <ramses_> neutrino: because there are no values in the leaves, you'll need four patterns I think
10:31:24 <neutrino> look here
10:31:43 <neutrino> can i make this much smaller than that?
10:32:34 <ramses_> neutrino: I'd pattern match like "Node a l Leaf", "Node a Leaf r", "Node a Leaf Leaf" and "Node a l r"
10:32:50 <ramses_> that'll get rid of all those nested cases
10:33:57 <neutrino> aha
10:35:46 <neutrino> let me try that
10:36:21 <jfischoff> dolio: Noticed you are the maintainer of CC-delcont. Do you use delimited continuations much?
10:36:56 <bobry> When does it make sense to mark a function as {-# NOINLINE #-}?
10:37:55 <sproingie> when it has sneaky side effects
10:38:14 <bobry> and what if it's pure?
10:38:23 <sproingie> then you shouldn't need to
10:38:35 <bobry> like `orInteger` in 'GHC.Integer.Type'
10:38:46 <bobry> actually most of the functions there are marked as noinline
10:39:03 <sproingie> not really sure on that one
10:39:36 <sproingie> maybe ghc goes back over them and replaces them with some kind of intrinsic.  i'm just spitballing, i don't know ghc guts
10:40:50 <jfischoff> noinline gets repa code too. No idea what the reason is
10:41:02 <jfischoff> s/gets/gets sprinkled around
10:42:01 <erisco> arkeet, so the idea of polymorphic recursion is to take a recursive type, extract the type from its own definition, and replace it with a type variable? this is interesting but I am not sure where this connects with the example
10:42:29 <arkeet> no
10:42:49 <erisco> arkeet, then I have missed the point
10:42:50 <arkeet> the point of polymorphic recursion is when it calls itself but with a different type.
10:43:37 <arkeet> so in that varargs example,
10:43:39 <erisco> what is a short example? I don't follow what that would mean
10:43:41 <dolio> jfischoff: Not really. I was just interested in them a while back.
10:44:20 <arkeet> say we're writing printAll' [] "hello"
10:44:30 <arkeet> er
10:44:35 <hpaste> neutrino pasted “tree search with partial functions” at http://hpaste.org/86585
10:44:44 <arkeet> so here printAll', say, has type [String] -> String -> IO ()
10:44:49 <jfischoff> dolio: after messing around with them what's your opinion now?
10:44:50 <neutrino> i can come up with this but i'm not happy about using partial functions
10:45:03 <neutrino> what else could i do?
10:45:08 <arkeet> so, given a [String], it calls itself, but now with a different type printAll' :: [String] -> IO ()
10:45:17 <erisco> arkeet, it didn't have this type when I inspected it
10:45:39 <arkeet> these are specializations of the general type PrintAllType t => [String] -> t
10:45:55 <arkeet> the first where t = String -> IO ()
10:45:58 <arkeet> the second where t = IO ()
10:46:15 <erisco> arkeet, when it recurses is it recursing on the definition given in the printalltype instance?
10:46:38 <dolio> jfischoff: Well, I guess obviously I didn't come to the conclusion that they, or at least that implementation, are worth using all the time. But they're fun to think about.
10:46:43 <arkeet> when it calls itself at a different type, yes, it uses a different instance.
10:46:46 <dolio> Also, they're better than undelimited continuations.
10:47:02 <hpaste> ramses_ annotated “tree search with partial functions” with “tree search with partial functions (annotation)” at http://hpaste.org/86585#a86586
10:47:23 <ramses_> neutrino: I had a fast go at it, no partial functions
10:47:32 * jfischoff nods
10:47:41 <erisco> arkeet, how can two functions of the same name exist with different type signatures?
10:47:56 <geekosaur> typeclasses
10:48:00 <arkeet> polymorphism
10:48:08 <dolio> There's a way to use delimited continuations that's a little less crazy than CC-delcont, though.
10:48:11 <arkeet> :t show
10:48:12 <lambdabot> Show a => a -> String
10:48:13 <arkeet> :t show :: Int -> String
10:48:15 <lambdabot> Int -> String
10:48:16 <arkeet> :t show :: [Bool] -> String
10:48:18 <lambdabot> [Bool] -> String
10:48:19 <jfischoff> how so?
10:48:25 <geekosaur> or from different modules, and you would need to qualify one or both to distinguish
10:48:29 <arkeet> these are specializations of the polymorphic type Show a => a -> String
10:48:53 <arkeet> where a = Int and [Bool], respectively
10:49:01 <dolio> shift :: ((a -> r) -> r) -> Cont r a; shift = cont; reset :: Cont r r -> r ; reset = (`runCont` id)
10:49:02 <arkeet> another example (with no type classes):
10:49:03 <arkeet> :t id
10:49:05 <lambdabot> a -> a
10:49:06 <arkeet> :t id :: Int -> Int
10:49:07 <lambdabot> Int -> Int
10:49:45 <dolio> Which, if you think about it, kind of enforces type-wise the various 'no effects escape' bits of shift and reset.
10:49:55 <arkeet> polymorphic recursion doesn't have much to do with typeclasses, really.
10:50:15 <jfischoff> dolio: that is what I am using actually… ripped from oleg zipper code
10:50:16 <neutrino> ramses_: looking
10:50:35 <jfischoff> I will try to think about it now ;)
10:51:04 <erisco> arkeet, is this what Haskell calls "ad-hoc polymorphism"?
10:51:11 <arkeet> that's typeclasses
10:51:55 <neutrino> ramses_: what does this mean? tmax :: Ord a => Tree a => Maybe a
10:52:00 <neutrino> why are there two =>'s ?
10:52:01 <arkeet> @let funnyShow :: Show a => Int -> a -> String; funnyShow 0 x = show x; funnyShow n x = funnyShow (n-1) [x]
10:52:02 <erisco> then I am most certainly confused. Why can't I write two functions with the same name in any other case?
10:52:04 <lambdabot>  Defined.
10:52:08 <arkeet> > funnyShow 5 "hello"
10:52:11 <lambdabot>   "[[[[[\"hello\"]]]]]"
10:52:27 <geekosaur> erisco, haskell does not have unprincipled overloading
10:52:36 <thoughtpolice> jfischoff: this is the same implementation i use in my delimited continuations library, based on oleg's 'genuine' shift/reset
10:52:44 <ramses_> neutrino: huh, that's a typo.. but ghc didn't complain!
10:52:46 <arkeet> erisco: typeclasses don't *really* let you write two different functions with the same name.
10:52:56 <thoughtpolice> (really i kept the Rank2 type to play around and keep it close to his original code, but it should probably go, tbh)
10:52:56 <ramses_> how weird is that?!
10:52:57 <neutrino> ramses_: weird, isn't it?!
10:52:58 <geekosaur> haskell does type inference; random functions with the same name but different types would break type inference
10:53:00 <neutrino> yeah
10:53:06 <neutrino> Cale: any ideas?!
10:53:07 <arkeet> you get one function. instances specify partial definitions for that function for different specialized types.
10:53:11 <ramses_> neutrino: did you try to compile that as well?
10:53:12 <jfischoff> thoughtpolice: what is that library called?
10:53:15 <flebron> What is a decent way to transform an [a], of length > n, into [[a]], each of length n, except possibly the last one?
10:53:20 <jfischoff> is it on hackage?
10:53:26 <arkeet> flebron: Data.List.Split.chunksOf
10:53:26 <thoughtpolice> jfischoff: 'asai', but it is not on hackage. i could upload it, though
10:53:30 <flebron> (I'm thinking length, quotRem, etc)
10:53:37 <flebron> I'll try that, thanks :)
10:53:41 <thoughtpolice> (just not at this exact second)
10:53:50 <jfischoff> cool
10:53:53 <arkeet> > chunksOf 3 "abcdefgh"
10:53:55 <lambdabot>   ["abc","def","gh"]
10:53:59 <thoughtpolice> jfischoff: https://github.com/thoughtpolice/hs-asai <- the name from Kenichi Asai :)
10:54:03 <thoughtpolice> *is from
10:54:19 <erisco> arkeet, so... if my function is f :: a -> a  then I can have different definitions for different specialisations of 'a'?
10:54:20 <jfischoff> thoughtpolice: did you see my final response after looking the binary generic code?
10:54:21 <flebron> arkeet: You wouldn't happen to know if that came by default on the haskell platform 2009, would you?
10:54:35 <thoughtpolice> there's also a port of a few of dolio's examples in there, too. no transformers though, since i use an indexed monad to get 'do' notation back
10:54:39 <arkeet> erisco: not for a -> a. you need to have some typeclass involved
10:54:40 <thoughtpolice> which is somewhat unfortunate.
10:54:50 <thoughtpolice> jfischoff: i did not, what was the result?
10:54:52 <arkeet> flebron: no, split was introduced in platform 2011.4 I think
10:54:57 <arkeet> or 2012.4
10:54:59 <arkeet> or something.
10:55:03 <ramses_> > let tmax :: Ord a => [a] => Maybe a; tmax = Nothing in tmax [1,2,3]
10:55:03 <arkeet> the last one.
10:55:04 <lambdabot>   Type of kind * used as a constraint
10:55:06 <flebron> Ah, unfortunate. (The contest site I'm using has a really old version of Hask :))
10:55:13 <Mortchek> @type succ
10:55:15 <lambdabot> Enum a => a -> a
10:55:17 <ramses_> lambdabot does complain, as expected
10:55:50 <arkeet> constraints are basically implicit arguments.
10:56:02 <ramses_> > let tmax :: Ord a => [a] => Maybe a; tmax a = Nothing in tmax [1,2,3]
10:56:03 <arkeet> where the implicit values are determined by the instances.
10:56:04 <lambdabot>   Type of kind * used as a constraint
10:56:13 <arkeet> ramses_: stuff on the left of => must be a constraint
10:56:17 <arkeet> [a] is not a constraint
10:56:29 <ramses_> arkeet: I know, but ghc here accepts that type
10:56:36 <arkeet> where?
10:56:41 <ramses_> locally
10:56:44 <jfischoff> thoughtpolice: you definitely can get the index of the constructors. I was wrong about that. However you are dependent on the encoding of sum types by the compiler, which is not explained anywhere, so I see no reason why it can't change and break your data.
10:56:47 <arkeet> what version? any extensions?
10:56:54 <sproingie> [a] is a type, yes.  it's not a type class.
10:57:27 <jfischoff> the benefits of generics still out way template haskell in that case though I think
10:57:29 <ramses_> arkeet: 7.6.2, it's in ghci, only monomorphism is turned off, no other extensions
10:57:40 <arkeet> interesting, I get the same.
10:58:02 <arkeet> works without the Ord thing too
10:58:08 <sproingie> so it's magically turning => into -> somehow?
10:58:23 <sproingie> (haskell's getting scala syntax apparently)
10:58:34 <Sculptor> hello
10:58:34 <arkeet> it seems to only work when you have a type constructor there.
10:58:40 <ramses_> should I report this as a bug?
10:58:47 <arkeet> see if there's an existing one already
10:58:48 <thoughtpolice> jfischoff: ah, i see. that is unfortunate but about the same with TH in a way i guess i guess, if you use direct literals to construct parts of the AST. sometimes things break :/
10:59:23 <neutrino> ramses_: hadn't tried compiling it
10:59:32 <jfischoff> thoughtpolice: yeah but it is your code that broke it. This would break when you upgraded your complier with no indication of what went wrong
10:59:42 <neutrino> ramses_: either way, yeah, that's easy, but it's not what i want - I want the return type to be Maybe (Tree a)
11:00:00 <ramses_> neutrino: huh? and what tree would that be?
11:00:16 <jfischoff> which would not be bad if you are user (like me) that understands this behavior, but otherwise you would be very confused that all your data isn't loading
11:00:31 <neutrino> it would be the tree with a root which is the largest node.
11:00:47 <thoughtpolice> ah yes, i see what you mean. you'd really want something like safecopy built in, in a way
11:00:56 <ramses_> neutrino: ah
11:00:58 <thoughtpolice> this is perhaps something worth brining up
11:01:27 <jfischoff> I think just publishing the the encoding and making it clear if it changes would be good enough
11:02:53 <ramses_> isn't there a simple keyword search on trac? I seem to be overlooking it
11:03:15 <ramses_> ah, nm, found it
11:05:56 <Cale> erisco: Actually, Haskell has no ad-hoc polymorphism, though people will use typeclasses for the sorts of thing that you might use ad-hoc polymorphism for in another language.
11:06:43 <neutrino> Cale: any idea why this doesn't error out? foo :: Ord a => Tree a => Maybe a
11:06:45 <Cale> erisco: For example, consider sort. You might initially want  sort :: [a] -> [a],  except that this type actually doesn't make sense, because for many types we have no notion of ordering that we can apply
11:06:50 <neutrino> (two =>'s)
11:07:09 <Cale> neutrino: Probably a small infelicity in the grammar. It makes perfect sense for it to work anyway
11:07:11 <erisco> :t sort
11:07:13 <lambdabot> Ord a => [a] -> [a]
11:07:28 <arkeet> Cale: no it doesn't =(
11:07:28 <neutrino> Cale: i'm queasy.
11:07:42 <arkeet> (=>) ought to have kind Constraint -> * -> *
11:07:43 <Cale> erisco: So, we have a typeclass, Ord, which can be used to constrain the types over which a ranges.
11:07:48 <arkeet> this is a clear kind error.
11:08:21 <Cale> arkeet: It doesn't quite make perfect sense for (=>) to ever be first class
11:08:33 <Cale> well...
11:08:38 <arkeet> sure it does.
11:08:44 <arkeet> but in any case it doesn't make sense for the thing on the left of => to have kind *
11:09:00 <arkeet> and then for the => to magically become ->
11:09:38 <erisco> => isn't built in to the language?
11:09:46 <Cale> It is built in.
11:09:53 <monochrom> it is punctuation
11:10:18 <monochrom> like comma and ::
11:10:35 <Cale> arkeet: oh, your Tree is a data type?
11:10:37 <otters> ooh, comma is weird
11:10:42 <arkeet> not mine
11:10:53 <arkeet> but yes
11:11:12 <neutrino> Cale: yeah
11:11:18 <arkeet> let f :: [a] => (); f _ = ()
11:11:27 <neutrino> Cale: see annotation here: http://hpaste.org/86585#a86586
11:11:28 <arkeet> :t f   -->  f :: [a] -> ()
11:12:01 <Cale> Well! That's very interesting.
11:12:35 <neutrino> isn't it!
11:12:36 <arkeet> quite
11:13:20 <ramses_> trac search is weird, any query like "description contains " returns no results..
11:15:19 <dmj> quickCheck $ quicksort [1,2,3,2,1] requires an instance for Testable?
11:15:49 <dolio> arkeet, Cale: Fixed in teh head.
11:16:04 <arkeet> I was wondering.
11:16:04 <byorgey> arkeet: what version of GHC is that with?
11:16:08 <arkeet> 7.6.2 here
11:16:11 <Cale> myId :: forall (a :: *). a => a
11:16:12 <Cale> myId x = x
11:16:18 <arkeet> I don't have a recent HEAD build to play with.
11:16:21 <byorgey> arkeet: with what extensions turned on?
11:16:23 <arkeet> none
11:16:50 <byorgey> hm, with 7.6.1 I get "Type of kind * used as a constraint"
11:17:01 <dolio> It's still broken in 7.6.3.
11:17:51 <dolio> But, yeah, fixed in head.
11:17:56 <ramses_> ah indeed, fixed in head, no need to file a bug then
11:18:39 <byorgey> dmj: quicksort [1,2,3,2,1] does not sound like a property.
11:18:53 <byorgey> dmj: quickCheck expects you to give it a testable property.
11:19:06 <byorgey> like "for all input lists xs, quicksort xs is sorted"
11:19:56 <byorgey> dmj: what were you expecting  quickCheck $ quicksort [1,2,3,2,1]  to do?
11:20:05 <arkeet> "for all input lists xs, quicksort xs does what I want it to do."
11:20:24 <Eduard_Munteanu> That's harder... proving it correct.
11:20:36 <Eduard_Munteanu> Oh, quickcheck, pfft. :P
11:21:46 <mm_freak> is there any good example of using a very unsafe language together with a theorem prover to write correct programs?
11:21:59 <mm_freak> like PHP + idris or C + coq
11:24:03 <Eduard_Munteanu> mm_freak: yes, but it sucks
11:24:12 <mm_freak> Eduard_Munteanu: i just need to get started
11:24:17 <Eduard_Munteanu> mm_freak: look at seL4 for example
11:24:39 <Eduard_Munteanu> Oh you want a working environment? Not sure then.
11:25:15 <harrison> PHP + idris or C + coq: obv troll
11:25:50 <monochrom> there is Larch with C++
11:26:07 <monochrom> ACL2 and Java
11:26:09 <merijn> mm_freak: I got some complicated questions :p
11:26:29 <Eduard_Munteanu> Java is less dirty, though.
11:26:52 <mm_freak> Eduard_Munteanu: i have to use a bad language, so i want to at least combine it with a theorem prover
11:27:00 <mm_freak> merijn: go ahead =)
11:27:20 <Eduard_Munteanu> mm_freak: if you fancy writing 100k lines of proofs for 5k lines of code, go ahead. :)
11:27:25 <monochrom> coq is seldom used outside functional programming
11:27:32 <merijn> mm_freak: So I've been thinking how to model the behaviour of "objects" with multiple input/output event types, this seems like a simple multiplex a bunch of Wires (like nested Either or whatever), but then if I want to hook up multiple objects to eachother I'm unsure how that'd work
11:27:33 <znutar> The mars rover validation paper(s) are reasonably interesting in that vein http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.911
11:27:53 <ab9rf> i'm not sure that PHP's semantics are well-enough defined for that :)
11:28:12 <znutar> they used Polyspace and Java Pathfinder and somehing else
11:28:37 <Eduard_Munteanu> ab9rf: fortunately I think PHP might be easier than say C... at least you don't have to mess with the underlying machine
11:28:39 <ab9rf> i mean, there are constructs in PHP whose behaviors will vary depending on hashcodes, because of the insane way that PHP implements iteration
11:28:41 <arkeet> merijn: sounds like operads!
11:28:44 <mm_freak> merijn: one way is to write the receiver as a wire combinator
11:28:47 <merijn> mm_freak: Suppose I have object A producing output events that should go to both object B and C, or, vice versa, objects A and B both feeding events to object C, now updating the behaviour of any object becomes tricky
11:29:34 <ab9rf> Eduard_Munteanu: yes, true, you're dealing with deterministic-but-complicated behavior instead of actually indeterminate behavior as you can get in C
11:29:35 <monochrom> and where is this week's Haskell Weekly News?!
11:30:02 <mm_freak> merijn: well, there is this:  (fmap f a <|> fmap g b) . c
11:30:02 <Eduard_Munteanu> seL4 was a mess to verify, AFAICT.
11:30:14 <mm_freak> merijn: and there is this:  a . (b <|> c)
11:30:40 <Eduard_Munteanu> And even if you do manage to do it, there's a big chance making small changes entail large changes to the proof.
11:30:51 <Eduard_Munteanu> Disproportionately large.
11:31:43 <mm_freak> merijn: if you actually need both, one somewhat ugly way is: c . (event a &&& event b)
11:31:44 <merijn> mm_freak: mmm, maybe I need to work out a more concrete example, I'm not even remotely sure the netwire approach is a good match at all for what I'm doing...
11:32:20 <merijn> The Wire type just seems so close to what I have in mind and reinveing from scratch seems like a waste
11:32:27 <saml> acid state is discontiuned? http://acid-state.seize.it/
11:32:45 <mm_freak> merijn: if Wire doesn't work, chances are that Continue does
11:32:50 <mm_freak> see the 'continue' library
11:33:08 <merijn> oh, lemme check that out
11:33:11 <merijn> @hackage continue
11:33:12 <lambdabot> http://hackage.haskell.org/package/continue
11:34:39 <Eduard_Munteanu> mm_freak: btw, do you actually mean to prove that stuff correct, or merely check certain invariants? The latter would be a lot easier.
11:34:57 <Eduard_Munteanu> s/check/prove/
11:35:00 <mm_freak> Eduard_Munteanu: not sure, depends on how much time i get
11:35:08 <mm_freak> i just want to be prepared
11:35:43 <merijn> What stuff are you wanting to check?
11:35:51 <mm_freak> Eduard_Munteanu: i consider this:  debugging is so difficult and for a good reason takes 90% of the development time
11:36:04 <Eduard_Munteanu> I think I've seen stuff like Hoare pre/post conditions applied to C code.
11:36:17 <Eduard_Munteanu> Yeah.
11:36:19 <mm_freak> if i need 500% of the development time for theorem proving, i'm still faster than hunting down bugs
11:36:52 <Ralith> mm_freak: you're aware of idris?
11:36:54 <Eduard_Munteanu> mm_freak: unfortunately, that would be cheap... seL4 seems to imply it's much more difficult
11:36:55 <mm_freak> merijn: as much as possible
11:37:02 <merijn> mm_freak: No, I mean what sort of code?
11:37:14 <dmwit> xplat: Right. The problem is that damn near none of the predicates you typically write in Haskell are total in the required sense.
11:37:16 <mm_freak> Ralith: i've even contributed a patch to idris ;)
11:37:32 <mm_freak> Ralith: i'm just not sure what using idris together with an unsafe language to prove program properties would look like
11:37:34 <merijn> very concurrent code? distributed/networked code? sequential code? low level stuff?
11:37:53 <mm_freak> merijn: likely web stuff, so i'll mainly be proving algebraic laws
11:37:53 <Ralith> mm_freak: the idea would be to write your program in idris and prove the properties naturally
11:38:07 <merijn> mm_freak: Have you looked at Ur/Web?
11:38:07 <xplat> dmwit: all the ones you intend to be used on infinite structures are, and the ones you use on finite universes are as well (trivially)
11:38:13 <mm_freak> Ralith: if that would be an option i would take it (or use haskell)
11:38:16 <Ralith> mm_freak: if you're going to write your program in an external language, you might as well use the substantially more mature agda.
11:38:21 <Ralith> mm_freak: why is it not an option?
11:38:26 <Eduard_Munteanu> I know, verified software is a rather depressing enterprise. :(
11:38:35 <mm_freak> Ralith: because customers are stupid
11:38:35 <xplat> dmwit: it's the ones you intend to be used only on finite structures from an infinite universe that aren't
11:38:39 <Ralith> mm_freak: aw.
11:38:55 <Ralith> well, people do use agda/coq to prove things about C software.
11:39:03 <mm_freak> merijn: yes, i'm aware of ur/web and would prefer haskell in that case
11:39:12 <Eduard_Munteanu> Ralith: which people?
11:39:13 <merijn> Ah
11:39:15 <mm_freak> Ralith: any simple example to get started?
11:39:17 <Ralith> mm_freak: you might also be interested in some of Functor AB's work, if it's in your budget.
11:39:24 <mm_freak> i'd be happy with agda
11:39:27 <merijn> I still haven't gotten Ur to work, I can't get milton working on my macbook :(
11:39:31 <Ralith> mm_freak: not that I know of; I've just seen it referenced in abstracts
11:39:37 <monochrom> mm_freak: take a look at the last several VSTTE conferences and accompanying competitions
11:39:50 <xplat> Ralith: agda is pretty low on the list of languages to build a working webserver in, although you could use it as a metalanguage
11:39:50 <monochrom> (hint: Coq and Agda are seldom used)
11:39:51 <mm_freak> ok, thanks
11:39:56 <Ralith> Eduard_Munteanu: you might be better off asking #agda
11:40:05 <Ralith> xplat: as I said, the idea is to prove things about one written in an external language
11:40:22 <xplat> Ralith: oh, then yes, that's a possibility
11:40:45 <xplat> Ralith: although depending on the outside language you still might be better off with coq
11:40:53 <Eduard_Munteanu> That sucks, really. First you have to formalize the language, you know...
11:40:59 <Ralith> mm_freak: an alternative approach, viable in idris and probably agda as well, is to write a dependently-typed DSL which you can easily prove things about in a natural fashion and for which you write a proven compiler that targets the real language.
11:40:59 <dmwit> xplat: Nothing you've said so far has convinced me to change my stance: patches welcome.
11:41:15 <Ralith> xplat: I wouldn't know
11:41:36 <mm_freak> Ralith: that's a nice approach, but i doubt that i'll have that much time =)
11:41:41 <xplat> dmwit: well, it's a pretty good stance, i suppose :)
11:41:46 <mm_freak> i'll probably use haxe anyway
11:42:09 <Ralith> mm_freak: I don't know that it's substantially more time-expensive than proving things directly
11:42:20 <Eduard_Munteanu> Then you have to be able to express desirable properties meaningfully. Which might sound like "this pointer always comes from these other hundred places and it's a (Foo *)".
11:42:24 <Ralith> mm_freak: basically, you're just building a formal model of the subset of the target language you want to use.
11:42:37 <Ralith> the 'compiler' is just a translator of that subset to the target language.
11:42:43 <Ralith> nothing but a weakener.
11:43:13 <merijn> mm_freak: Ok, before continuing with my updating questions, maybe I should start basic and implement something that is multiple input/multiple output. Would you recommend doing that by using (+++) (i.e. ArrowChoice) or handwriting my own wrapping/unwrapping and distpatcher
11:43:46 <xplat> mm_freak: the DSL approach can actually be a lot quicker if you want to get total code coverage, especially if a formal semantics of the full target language isn't already available in your chosen metalanguage
11:43:53 <merijn> I guess the downside of ArrowChoice is that the relevant either leaks the path that was taken...
11:43:58 <Eduard_Munteanu> mm_freak: easier stuff that works already: e.g. C got static asserts, with some heinous magic you can check a few things.
11:44:12 <Eduard_Munteanu> But it's bits and pieces.
11:44:34 <xplat> Eduard_Munteanu: after you've done the heinous magic do you still know what it is you proved?
11:45:30 <xplat> mm_freak: (and of course, if all your code hasn't already been written, which makes the dsl approach a lot more costly)
11:45:30 <Eduard_Munteanu> xplat: well, in simple cases, yeah... e.g. you can assert the sizeof a struct is a known value
11:45:34 <Eduard_Munteanu> Nothing fancy though.
11:45:51 <Peaker> nice form for:  Maybe (a,b) -> (Maybe a, Maybe b)   (or generalization of unzip)?
11:45:55 <Peaker> @type fmap fst &&& fmap snd
11:45:57 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
11:46:36 <xplat> Eduard_Munteanu: what's that supposed to accomplish, proving your nonportable jpeg loader is portable enough for the platform you're building it on?
11:46:38 <dmwit> :t maybe def (Just *** Just)
11:46:39 <lambdabot>     Not in scope: `def'
11:46:39 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
11:46:41 <Eduard_Munteanu> I think in some cases you can depend on conditionals and get other assertions working, e.g.   if (x > 3)   _Static(x > 1);
11:46:54 <dmwit> :t maybe (Nothing, Nothing) (Just *** Just)
11:46:56 <lambdabot> Maybe (a, a1) -> (Maybe a, Maybe a1)
11:47:55 <Eduard_Munteanu> xplat: no, it's just very basic inference machinery provided by the compiler
11:48:09 <Eduard_Munteanu> Not sure what a good use would be.
11:49:31 <Eduard_Munteanu> Perhaps in time we might get additional annotation & checking machinery.
12:03:16 <aCube> Is there something like aseon but for xml instead of json?
12:04:17 <arkeet> aCube: something like xml?
12:04:50 <Clint> xml-conduit?
12:05:08 <merijn> xml-conduit is pretty nice in my experience
12:06:02 <aCube> ok thanks, I will look at it
12:10:09 <Peaker> MonadPlus : msum    Alternative : ??
12:10:41 <supki> @ty Data.Foldable.asum
12:10:43 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
12:11:16 <Peaker> @type (^? traverse . _Just)
12:11:18 <lambdabot> Traversable t => t (Maybe a) -> Maybe a
12:22:12 <tdammers> I wonder how I can get better error reporting out of Aeson
12:22:24 <tdammers> I'm parsing a huge JSON file, and it seems to be malformed
12:22:33 <tdammers> but I can't figure out where
12:22:41 <tdammers> it's probably missing a comma somewhere or something
12:31:10 <tac> tdammers: Do you need to be able to do it programmatically? Otherwise, check it online with a JSON format verifier
12:31:20 <supki> tdammers: aeson uses attoparsec for parsing
12:32:27 <supki> tdammers: and I think parser is exported
12:32:46 <supki> http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-Parser.html#v:json
12:37:50 <tdammers> heh, yeah, I went with an online verifier
12:37:59 <tdammers> as I suspected, I had an excess comma
12:38:00 <tdammers> :P
12:40:01 <danr> check out jsonlint in nodejs
12:41:38 <tdammers> will do
13:23:10 <Ankhers> Would anyone be able to help me understand applicative functors? I'm reading through LYAH, and I'm about to hit Monads, and I just don't fully understand Applicative Functors...
13:25:05 <sproingie> it's a functor that lets you apply a function inside that functor.
13:25:51 <sproingie> > Just (* 2) <*> Just 123
13:25:53 <lambdabot>   Just 246
13:26:25 <sproingie> so <*> is like fmap except the first arg is also a functor
13:26:39 <Taneb> It means you can do...
13:26:41 <sproingie> there's also <$> which *is* fmap
13:26:55 <Taneb> > (*) <$> Just 2 <*> Just 3
13:26:59 <lambdabot>   Just 6
13:27:38 <sproingie> and so on for 3-arg functions
13:27:57 <Peaker> Ankhers,    fmap :: (a -> b) -> (f a -> f b)    is nice, it lets you apply functions inside an "f".   "fmap" doesn't touch the "f" itself. It also doesn't let you combine two "f"s
13:28:48 <sproingie> yah you have to see fmap in the curried form to see how it fits in
13:28:49 <Peaker> Ankhers, so for example, you can think of an   IO a    value as being composed of 2 parts: A bunch of effects (IO)   and a result value (a).     fmap only talks about the second, whereas (<*>) :: f (a -> b) -> f a -> f b          lets you compose both parts simultaneously
13:29:31 <Peaker> Ankhers, Functor:  Apply functions inside "f" type constructors.    Applicative: Also compose together "f" type constructors
13:29:36 <sproingie> i.e. think of fmap as taking a function and returning another function from functor to functor
13:30:49 <sproingie> which is really the meaning of fmap, it's defining a mapping
13:32:11 <Ankhers> So applicative functors are just allow to you apply two or more arguments to whatever function you are mapping?
13:32:27 <Ankhers> Or is there something more?
13:32:30 <sproingie> nope, that's just a useful fringe benefit
13:32:54 <sproingie> it lets you apply your functions with the functor's context itself
13:33:22 <sproingie> > Nothing <*> Just 123
13:33:24 <lambdabot>   Nothing
13:33:46 <sproingie> > [(+ 1), (* 2)] <*> [1,2,3]
13:33:50 <lambdabot>   mueval-core: Time limit exceeded
13:33:55 <sproingie> bother
13:34:06 <sproingie> > [(+ 1), (* 2)] <*> [1,2,3]
13:34:09 <lambdabot>   [2,3,4,2,4,6]
13:34:24 <Peaker> Ankhers, it's not about the number of arguments, it's about the ability t compose values of the form "f a".  in [] Applicative, you get cartesian multiplication. In IO applicative, you get to compose effects from multiple IO values
13:34:26 <sproingie> lists actually have two interpretations as applicatives, LYAH gets into the other one (ZipList)
13:34:27 <Peaker> Ankhers, and so forth
13:35:13 <sproingie> basically, the benefits functors provide for your data are now given to your functions
13:35:28 <sproingie> makes it all nice and uniform
13:35:58 <Ankhers> > :t <*>
13:36:02 <lambdabot>   <hint>:1:1: parse error on input `:'
13:36:14 <jfischoff> :t (<*>)
13:36:16 <sproingie> @type (<*>)
13:36:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:36:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:36:29 * sproingie ponders a single-char alias for <*> ala caleskell's . for fmap
13:36:38 <sproingie> @ maybe?
13:36:43 <Peaker> Ankhers, If you consider functions of the form:    mapN :: (a0 -> a1 -> ... -> aN) -> f a0 -> f a1 -> ... -> f aN     then you can say what you said is correct, that it's "just about the number of arguments".   Functor lets you implement map1(=fmap) only.  Applicative has "pure = fmap0", and lets you also implement map2, map3, for all N
13:36:47 <sproingie> oh wait that's pattern syntax
13:36:59 <s778> `?
13:37:23 <sproingie> backticks are also syntax.  `ap`
13:37:38 <s778> ~?
13:37:47 <Peaker> Ankhers, so you could express:   class Map0 f where map0 :: a -> f a         class Map1 f where map1 :: (a -> b) -> f a -> f b        class Map2 f where map2 :: (a -> b -> c) -> f a -> f b -> f c
13:38:17 <Peaker> Ankhers, Functor=Map1.   Applicative=(Map0, Map2), and via Map2, you also get map3, map4, etc...
13:38:34 <sproingie> that could work.  some lib or another tries to grab all the useful punctuation but i dont see bare tilde used that much
13:38:51 <Ankhers> I think I may need to see and example of applicative that you couldn't do with normal functors.
13:39:02 <Peaker> Ankhers, but a motivating example is nice..  imagine you want to add 5 to a number wrapped in some type which is a Functor
13:39:14 <Peaker> Ankhers, you can do:    fmap (+5) myWrappedNumber,   right?
13:39:22 <sproingie> applicatives get really handy when you do monads, because monads are a fairly minor tweak on applicatives
13:39:32 <Peaker> sproingie, don't bring up monads yet :)
13:39:32 <sproingie> tho a lot of things using monads could actually use applicatives
13:39:53 <Ankhers> Peaker: Yes, that I understand.
13:40:04 <Peaker> Ankhers, now imagine you have two different wrapped numbers, and you want to add them up, how do you do that?
13:40:13 <supki> sproingie: ~ is syntax
13:40:26 <sproingie> ah crap just remembered yeah.  irrefutable pattern
13:40:46 <sproingie> i like !, i never use it for lists anyway
13:41:32 <Ankhers> Peaker: (+) <$> Just 5 <*> Just 7
13:41:53 <Peaker> Ankhers, Yeah, so you need Applicative's <*> to do it
13:41:57 <Ankhers> I think I get it... I didn't realize I couldn't just do something like (Just 5) + (Just 7)
13:42:54 <tac> > Just (+) <*> Just 1 <*> Just 7
13:42:56 <lambdabot>   Just 8
13:42:59 <Peaker> Ankhers, Haskell could in theory "auto-lift" things to make that work. But what happens when you do  (Just 5, Just 7)   Do you want a tuple of Maybes or a Maybe of a tuple?
13:43:21 <Peaker> Ankhers, (,) <$> Just 1 <*> Just 2      is not the same as     (Just 1, Just 2)
13:43:38 <Peaker> > (,) <$> Just 1 <*> Just 2
13:43:41 <lambdabot>   Just (1,2)
13:43:45 <Ankhers> Peaker: Maybe Tuple makes more sense.
13:43:57 <sproingie> which can actually be pretty handy
13:44:27 <Peaker> Ankhers, (Just 1, Just 2) :: Num a => (Maybe a, Maybe a)    and thankfully not:   Num a => Maybe (a, a)
13:44:47 <sproingie> > (,) <$> [1,2,3] <*> [4,5,6]
13:44:50 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:45:01 <Peaker> > (,) [1,2,3] [4,5,6]
13:45:04 <lambdabot>   ([1,2,3],[4,5,6])
13:45:32 <Peaker> Ankhers, the <$> and <*> in the expression are said to be "lifters", and you could "Auto-lift" but then you'd get ambiguities between the above 2 examples, as an example
13:45:55 <Peaker> Ankhers, instead of ambiguity and guessing, Haskell chooses not to auto-lift and you need to auto-lift things yourself, which also makes things significantly simpler
13:46:14 <Peaker> I wonder how the Applicative Brackets handle this ambiguity
13:46:42 <Peaker> need to lift, not auto-lift :)
13:47:26 <sproingie> > (,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:47:28 <lambdabot>   No instance for (GHC.Show.Show
13:47:28 <lambdabot>                     (Control.Applicative.Zip...
13:47:39 <Peaker> @type getZipList
13:47:43 <lambdabot> ZipList a -> [a]
13:47:56 <Peaker> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:47:56 <sproingie> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:47:58 <lambdabot>   [(1,4),(2,5),(3,6)]
13:47:58 <lambdabot>   can't find file: L.hs
13:48:14 <sproingie> which is a pretty verbose way of saying zip, but it generalizes to any arity
13:48:50 <Peaker> > let z=ZipList in getZipList $ (,) <$> z[1,2,3] <*> z[4,5,6]
13:48:54 <lambdabot>   mueval-core: Time limit exceeded
13:49:02 <Taneb> > getZipList $ (,,) <$> ZipList "one" <*> ZipList "two" <*> ZipList "ten"
13:49:04 <lambdabot>   [('o','t','t'),('n','w','e'),('e','o','n')]
13:49:15 <sproingie> what is this z[1,2,3] sorcery?
13:49:40 <Ankhers> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [1..]
13:49:42 <lambdabot>   [(1,1),(2,2),(3,3)]
13:49:50 <Ankhers> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [12..]
13:49:51 <lambdabot>   [(1,12),(2,13),(3,14)]
13:51:40 <sproingie> > getZipList z[1,2,3]
13:51:42 <lambdabot>   The function `Control.Applicative.getZipList'
13:51:42 <lambdabot>  is applied to two arguments,...
13:52:11 <sproingie> i'm guessing this z[1,2,3] thing is some pragma magic?
13:52:14 <Ankhers> Alright...
13:52:52 <Ankhers> So, basically, applicative functors allow me to make maybe tuple, instead of creating a tuple of maybes?
13:53:26 <sproingie> that's one major use of them, joining like that
13:53:37 <sproingie> there's a lot of uses, sometimes surprising
13:53:45 <sproingie> it's a very abstract pattern
13:54:12 <Ankhers> Indeed, but I think I understand it now.
13:54:29 <Ankhers> Thank you Peaker and sproingie
13:54:30 <sproingie> hold on to that "joining them together into one functor" thought, it'll come back later in new and fun ways
13:54:40 <Ankhers> moands?
13:54:53 <sproingie> you guessed the secret woid :)
13:55:05 <Peaker> Ankhers, that's of course one little use-case out of the general case of allowing you to compose together Maybe values, IO values, etc.
13:55:38 <Ankhers> Aye. I'm reading LYAH and I just came to the monad chapter. so I wanted to understand them before trying to understand monads.
13:56:07 <shachaf> sproingie: "into one functor" doesn't make any sense. A value of type "F A" isn't a functor; F is a functor.
13:56:26 <Ankhers> Peaker: Aye, I just wanted to be sure that is basically what is happening. That I have the context on the outside as opposed to on the inside of whatever I'm doing. Or is that still not correct?
13:56:40 <shachaf> Ankhers: If you understand "lift"/"fmap": Functor gives you lift1 :: (a -> b) -> f a -> f b
13:56:53 <Peaker> Ankhers, Functor: f a    touch the "a", not "f".     Applicative:  Compose together pre-known "f a" values.      Monad:  Compose together "f a" values, even ones that hide inside the "a".   While Applicative can compose "f a" and "f b",    Monad can compose the two f's that appear in:   f (f a)  into   f a
13:56:59 <shachaf> Applicative adds on top of that lift0 :: (a) -> f a and lift2 :: (a -> b -> c) -> f a -> f b -> f c
13:57:13 <pantsman> functor: (a -> b) -> f a -> f b; applicative: f (a -> b) -> f a -> f b; monad: (a -> f b) -> f a -> f b
13:57:13 <Peaker> Ankhers, the outside/inside thing is probably not a good intuition there
13:58:27 <Peaker> Ankhers, Of course you can treat an "f a" value as an opaque black box and place it in a tuple with another "f b" value (tuple on the outside), that's a given...  Applicative lets you fuse together multiple "f" values, composing values of the form (f a, f b, f c) using any pure composition on the "a,b,c" that you'd like
13:59:02 <fizbin> Applicative effectively gives you lift<n> for arbitrary n.
13:59:07 <Ankhers> How about applicative IO? Can someone show me an example of that?
13:59:34 <Peaker> @type (++) <$> getLine <*> getLine
13:59:36 <lambdabot> IO String
13:59:46 <Peaker> Ankhers, get two lines, and yield their concatenation in the result value
14:00:09 <Ankhers> Peaker I understand that. I just don't see how that is actually useful...
14:00:22 <sproingie> shachaf: yah the container interpretation probably wasn't a good thing to bring into it
14:00:27 <Peaker> Ankhers, not useful to concat lines, or not useful as opposed to "do" notation, or what do you mean?
14:00:27 <sproingie> sorry bout that
14:00:32 <amiller> i need something of the form Monad m => (m a -> m b) -> m (m a -> m b)
14:00:35 <amiller> but not return.
14:00:46 <Taneb> It works much the same as any other applicative
14:00:55 <amiller> something f = \x -> x >>= f . return     works
14:00:56 <Peaker> Ankhers, is this example better:   parseCmdLine <$> getArgs <*> getPlatformName
14:01:00 <johnw> a monad is a container about as much as my mind contains ideas
14:01:01 <amiller> but is there a simpler way of writing that?
14:01:02 <Ankhers> Peaker: Not useful as in I could just ask for a single line of input.
14:01:18 <Peaker> Ankhers, but that reads two lines, not one
14:01:47 <Peaker> Ankhers, you might want to print out the first two lines as a single concatenated one, it is conceivable :)
14:02:39 <shachaf> sproingie: It doesn't even have to do with containers -- just don't call (Just 5) a functor. It's a value.
14:02:47 <amiller> @hoogle (m a -> m b) -> m (m a -> m b)
14:02:47 <lambdabot> Prelude showParen :: Bool -> ShowS -> ShowS
14:02:47 <lambdabot> Text.Show showParen :: Bool -> ShowS -> ShowS
14:02:47 <lambdabot> Network.URI uriToString :: (String -> String) -> URI -> ShowS
14:02:51 <shachaf> But I see the container jokes have started anyway.
14:02:56 * shachaf sighs.
14:03:17 <johnw> jokes?  do tell
14:03:24 <johnw> i love a good container laugh
14:03:39 <monochrom> johnw: how do I extract ideas from your mind? :)
14:03:53 <johnw> I give you a conversation algebra
14:04:03 <sproingie> shachaf: it's 5 in the context of Maybe
14:04:35 <shachaf> sproingie: Yes. It's a value whose type is (F A) where F is a functor.
14:04:35 * sproingie waits for the inevetable burrito joke.  or since it's functors maybe they're just tacos?
14:04:43 <Ankhers> Alright, I just clearly don't understand it...
14:05:15 <Peaker> Ankhers, you did get the example about adding two wrapped numbers together, right?
14:05:20 <monochrom> http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
14:05:23 <Peaker> Ankhers, which cannot be done with Functor alone
14:05:23 <Ankhers> Peaker: Aye
14:05:34 <Peaker> Ankhers, so you understand why Applicative is necessary for that example, and how it solves it?
14:05:54 <Ankhers> Yes
14:06:14 <Peaker> Ankhers, so you do understand :)  Understanding why it is the way it is, the usefulness of the particular things it allows/disallows comes later
14:06:17 <amiller> :t \f -> return . (f :: m a -> m b)
14:06:20 <lambdabot>     Could not deduce (t ~ (m2 a1 -> m2 b1))
14:06:20 <lambdabot>     from the context (Monad m)
14:06:20 <lambdabot>       bound by the inferred type of
14:06:29 <int-e> ah! monads are like salad! suddenly it all makes sense ...
14:06:33 <amiller> :t Monad m => \f -> return . (f :: m a -> m b)
14:06:35 <lambdabot> parse error on input `=>'
14:06:36 <Clint> mmm... monad dressing
14:07:03 <johnw> shachaf: see what you started? :)
14:07:15 <int-e> (I never got the burrito analogy. ;-) )
14:07:28 <amiller> :t \f -> (\x -> return (\x -> x >>= f . return))
14:07:31 <lambdabot> (Monad m2, Monad m1, Monad m) => (m2 a -> m1 b) -> t -> m (m1 a -> m1 b)
14:08:00 <monochrom> the burrito is an anti-analogy
14:08:02 <Ankhers> Peaker: So... Applicatives take the values out of their context, applies whatever function you asked it to use, and wraps that value into the original context?
14:08:05 <shachaf> johnw: No, you started it.
14:08:10 <shachaf> And I really wish people wouldn't.
14:08:13 <Peaker> Ankhers, you could view them that way
14:08:13 <int-e> monochrom: I know :P
14:08:29 <Peaker> Ankhers, another way to view them is that they take the function you give them and lift them into the context
14:08:30 <monochrom> haha ok!
14:08:42 <Peaker> Ankhers, lift the function, not "them"
14:09:11 <Peaker> Ankhers, in many kinds of contexts, taking the value "out of the context" is not actually possible, so the latter view may be preferred
14:10:54 <Shaladdle> ghci
14:10:57 <Shaladdle> herp derp
14:11:05 <monochrom> command not found
14:11:10 <ab9rf> the real problem with the burrito analogy is that it makes me want a burrito
14:11:33 <Clint> only one?
14:11:37 <Ankhers> Peaker: In the (+) <$> Just 5 <*> Just 7 example, how is (+) lifted into the Maybe context?
14:11:52 <monochrom> "the first one is free"
14:12:24 <shachaf> Ankhers: What do you mean by "lifted into the Maybe context"?
14:12:40 <Peaker> Ankhers, first, (+) :: Int -> Int -> Int   becomes:   (+) :: Maybe Int -> Maybe Int -> Maybe Int
14:13:03 <Peaker> Ankhers, oops, becomes that latter type (which is no longer (+))
14:13:20 <Peaker> Ankhers, a -> b  is an ordinary function..   f a -> f b   is a "lifted function" in the "f" context
14:13:34 <shachaf> Well, there's no subexpression there that has that type.
14:13:47 <Peaker> that's true
14:14:00 <Peaker> perhaps liftA2 is a better way to explain Applicative when starting off
14:14:03 <shachaf> I guess what Ankhers meant is the type of each piece. ghci can probably answer that question. :-)
14:14:08 <shachaf> @ty (+) <$> Just 5
14:14:09 <js6i> hm
14:14:10 <lambdabot> Num a => Maybe (a -> a)
14:14:17 <shachaf> I agree about liftA2.
14:14:36 <hpc> Ankhers: the expression parses as ((+) <$> (Just 5)) <*> (Just 7)
14:14:58 <hpc> Ankhers: (+) <$> (Just 5) applies (+) to the "inside" of (Just 5)
14:15:07 <hpc> yielding (Just (5 +))
14:15:24 <hpc> then (<*>) applies the inside of the first argument to the inside of the second argument
14:15:31 <hpc> yielding (Just (5 + 7))
14:15:36 <Peaker> Ankhers, <$> lifts (+) into the Maybe context, but not completely..  it becomes   Maybe Int -> Maybe (Int -> Int)        and then <*> finishes the job by lifting the Int->Int inside the Maybe to be Maybe Int -> Maybe Int
14:17:31 <hpc> Ankhers: sorry, afk
14:17:57 <hpc> Ankhers: in the specific case of Maybe, for all f, (f <$> Nothing) is Nothing
14:18:18 <hpc> and for all fs, (fs <*> Nothing) is Nothing
14:18:53 <hpc> (in the first, f is a plain function, in the second fs is a (Maybe SomeFunctionType))
14:18:55 <shachaf> > "hello" <*> Nothing
14:18:57 <lambdabot>   Couldn't match expected type `a0 -> b0'
14:18:57 <lambdabot>              with actual type `GHC....
14:19:46 <Ankhers> Alright, I think I may understand. Could someone write a simple example of an applicative, and I can try and discern the output type?
14:19:48 <cschneid> I just read through the LYAH explaination of functor => applicative => monad. Pretty clear once you've played with some code. The combo of actual code plus the theoretical finally clicked for me
14:19:50 <hpc> Ankhers: the specifics of (<$>) and (<*>) vary depending on the type they are being used on
14:20:09 <hpc> Ankhers: (++) <$> getLine <*> getLine
14:20:28 <Ankhers> hpc: IO a
14:20:42 <hpc> IO String, specifically
14:20:54 <Ankhers> yes, I thought about that after I wrote it.
14:21:00 <hpc> :P
14:21:16 <hpc> how about
14:21:29 <hpc> compare <$> [1,3,5] <*> [2,4,6]
14:21:52 <hpc> feel free to run these in ghci or lambdabot, btw
14:22:10 <Ankhers> [Eq]?
14:22:20 <GeneralMayhem> >:t compare
14:22:24 <hpc> :t compare
14:22:28 <lambdabot> Ord a => a -> a -> Ordering
14:22:40 <Ankhers> So, [Ordering]?
14:22:41 <GeneralMayhem> [Ordering]
14:22:46 <hpc> yep
14:22:51 <GeneralMayhem> and it should have 9 elements, yes?
14:22:53 <cschneid> > compare <$> [1,3,5] <*> [2,4,6]
14:22:55 <lambdabot>   [LT,LT,LT,GT,LT,LT,GT,GT,LT]
14:23:04 <Ankhers> What is the Eq type class?
14:23:09 <hpc> > (\x y -> (x, y, compare x y) <$> [1,3,5] <*> [2,4,6]
14:23:11 <lambdabot>   <hint>:1:53: parse error (possibly incorrect indentation)
14:23:12 <cschneid> > (,) <$> [1,3,5] <*> [2,4,6]
14:23:14 <lambdabot>   [(1,2),(1,4),(1,6),(3,2),(3,4),(3,6),(5,2),(5,4),(5,6)]
14:23:15 <GeneralMayhem> Ankhers: things that can be equal to each other
14:23:17 <hpc> > (\x y -> (x, y, compare x y)) <$> [1,3,5] <*> [2,4,6]
14:23:19 <lambdabot>   [(1,2,LT),(1,4,LT),(1,6,LT),(3,2,GT),(3,4,LT),(3,6,LT),(5,2,GT),(5,4,GT),(5...
14:23:27 <sproingie> Ankhers: :i Eq
14:23:32 <Ankhers> :i Eq
14:23:40 <sproingie> doesn't work in channel i dont think
14:23:53 <hpc> @info Eq
14:23:53 <lambdabot> Eq
14:23:58 <Ankhers> Oh okay.
14:24:00 <sproingie> well that was useful
14:24:11 <GeneralMayhem> Ankhers: Eq only defines ==
14:24:18 <sproingie> and /=
14:24:23 <hpc> @src Eq
14:24:23 <lambdabot> class  Eq a  where
14:24:23 <lambdabot>     (==), (/=)   :: a -> a -> Bool
14:24:29 <sproingie> the cute thing is defines them in terms of each other
14:24:38 <GeneralMayhem> yes, but (==) is just not . (==)
14:24:38 <Ankhers> Aye, I kinda liked that.
14:24:53 <Peaker> I find it pretty annoying rather than cute
14:25:06 <Peaker> Eq a should only have had (==) in it, (/=) should have been a function
14:25:20 <hpc> it has its uses
14:25:36 <hpc> they missed a few crucial places for it though, imo
14:25:41 <hpc> like (>>=) / join
14:25:48 <Ankhers> hpc: To your last example, [(Num, Num, Ordering)]
14:26:46 <hpc> Ankhers: you seem to have it figured out
14:27:58 <Ankhers> hpc: Awesome. Thanks for all the help. As well as everyone else that helped me.
14:28:44 <cschneid> > do a <- [1,2,3]; b <- [7,8,9]; return (a,b)
14:28:46 <lambdabot>   [(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9)]
14:29:01 <cschneid> given that, how do I get the same ordering 3rd arg as the applicative example
14:29:04 <DMcGill> hpc: that requires a Functor instance though right?
14:29:18 <DMcGill> since (>>=) = fmap . join
14:29:21 <hpc> DMcGill: which is also missing
14:29:34 <DMcGill> exactly
14:29:45 <amiller> :t \f -> return ((=<<) f . return)
14:29:46 <DMcGill> although if you're saying that they should add both then fair enough
14:29:46 <lambdabot> (Monad m1, Monad m) => (a -> m1 b) -> m (a -> m1 b)
14:29:57 <amiller> i think that's what i was looking for
14:30:03 <cschneid> > do a <- [1,2,3]; b <- [7,8,9]; let c = compare a b; return (a,b)
14:30:05 <lambdabot>   <hint>:1:65: parse error (possibly incorrect indentation)
14:30:15 <cschneid> > do a <- [1,2,3]; b <- [7,8,9]; c <- compare a b; return (a,b)
14:30:17 <hpc> > (\(x, y) -> (x, y, compare x y)) <$> $ do {a <- [1,2,3]; b <- [7,8,9]; return (a,b)}
14:30:18 <lambdabot>   Couldn't match expected type `[t0]'
14:30:18 <lambdabot>              with actual type `GHC.Type...
14:30:20 <lambdabot>   <hint>:1:38: parse error on input `$'
14:30:35 <hpc> > (\(x, y) -> (x, y, compare x y)) <$> do {a <- [1,2,3]; b <- [7,8,9]; return (a,b)}
14:30:37 <lambdabot>   [(1,7,LT),(1,8,LT),(1,9,LT),(2,7,LT),(2,8,LT),(2,9,LT),(3,7,LT),(3,8,LT),(3...
14:31:02 <cschneid> sure, but can I do that inside the monad, as opposed to doing it after
14:31:05 <ab9rf>  > (\(x, y) -> (x, y, compare x y)) <$> do {a <- [1,2,3]; b <- [7,8,9]; return (a,b)}
14:31:08 <hpc> yep
14:31:08 <ab9rf> erk
14:31:10 <ab9rf> mouse fail
14:31:53 <hpc> cschneid: hint: change (a,b) to something else
14:32:03 <cschneid> > do a <- [1,2,3]; b <- [7,8,9]; c <- compare a b; return (a, b, c)
14:32:06 <lambdabot>   Couldn't match expected type `[t0]'
14:32:06 <lambdabot>              with actual type `GHC.Type...
14:32:36 <cschneid> that's where I got to in ghci, the types in compare don't work for me there.
14:33:39 <hpc> cschneid: it thinks that (compare a b) is a list of some sort
14:33:50 <hpc> we could be evil and do "c <- [compare a b]"
14:34:10 <hpc> which is also (: []) (compare a b)
14:34:18 <hpc> and (: []) is return
14:34:34 <hpc> and "x <- return y" is better written as "let x = y"
14:35:07 <hpc> (in the sense that both of them are equal and frivolous application of monad laws is tedious for programmers reading it)
14:35:19 <cschneid> how do I one-line this so ghci takes it.
14:35:20 <cschneid> >do a <- [1,10,3]; b <- [7,8,9]; let c = compare a b; return (a,b,c)
14:35:29 <cschneid> > do a <- [1,10,3]; b <- [7,8,9]; let c = compare a b; return (a,b,c)
14:35:32 <lambdabot>   <hint>:1:68: parse error (possibly incorrect indentation)
14:35:45 <otters> use the brackets!
14:35:51 <hpc> > do {a <- [1,10,3]; b <- [7,8,9]; let {c = compare a b}; return (a,b,c)}
14:35:52 <lambdabot>   [(1,7,LT),(1,8,LT),(1,9,LT),(10,7,GT),(10,8,GT),(10,9,GT),(3,7,LT),(3,8,LT)...
14:36:00 <hpc> i have no idea how many of those brackets are needed
14:36:09 <otters> you don't need let brackets iirc
14:36:10 <hpc> also, don't do complicated one-liners in ghci
14:36:24 <monochrom> the minimal bracket is around {c = compare a b} because of the "let"
14:36:32 <otters> oh mb
14:36:35 <cschneid> so the brackets say "the scope of the let is the next block"
14:36:40 <cschneid> and without indents I have to say that manually
14:36:45 <hpc> it's not worth it when you can use a file
14:36:53 <Boreeas> > [(a, b, compare a b) | a <- [1,2,3], b <- [4,5,6]]
14:36:55 <lambdabot>   [(1,4,LT),(1,5,LT),(1,6,LT),(2,4,LT),(2,5,LT),(2,6,LT),(3,4,LT),(3,5,LT),(3...
14:36:56 <oconnor0> how is "do {a <- [1,10,3]; b <- [7,8,9]; let {c = compare a b}; return (a,b,c)}" different than "do a <- [1,2,3]; b <- [7,8,9]; let c = compare a b in return (a, b, c)" ?
14:37:25 <hpc> oconnor0: cultish adherence to do-notation ;)
14:37:34 <shachaf> oconnor0: The let-in means that the "return" part is no longer do-notation.
14:37:52 <shachaf> Which happens to not matter here. It would matter if you had more statements -- you'd need a second "do".
14:37:57 <hpc> (i am occasionally guilty of pointless do-notation)
14:38:16 <cschneid> thanks guys - gotta stop getting sidetracked by interesting haskell, and get back to day job
14:38:17 <hpc> and you would indent more
14:38:41 <oconnor0> thanks
14:46:00 <earspliT> exit
14:53:29 <neighbors> I'm playing around a bit with Haskell, and I have a program giving this:
14:53:33 <neighbors> Stack space overflow: current size 8388608 bytes.
14:53:33 <neighbors> Use `+RTS -Ksize -RTS' to increase it.
14:53:49 <neighbors> but I'm not really sure how to diagnose what might be the issue
14:55:12 <neighbors> anybody happy to take a glance at the code to see if anything obvious sticks out? (warning, the code is ugly, I'm sure)
14:55:32 <cmccann> neighbors: just hpaste the code
14:55:35 <cmccann> @where hpaste
14:55:36 <lambdabot> http://hpaste.org/
14:56:15 <cmccann> though getting a stack overflow without doing anything fancy probably means you're doing something recursive that's building too many nested thunks
14:56:17 <hpaste> neighbors pasted “code that has a stack failure” at http://hpaste.org/86600
14:56:24 <neighbors> thanks
14:56:29 <jfischoff> looking at the code will probably be the fastest way, but profiling will probably point out what is looping
14:57:12 <neighbors> this is the second incarnation of this, the first used Data.Map instead of Data.HashTable
14:57:24 <neighbors> I thought that would help but actually made it worse
14:57:41 <cmccann> looks like you have a lot of non-lazy recursion going on in there
14:57:58 <cmccann> are you compiling with optimizations or just doing this in GHCi or what?
14:58:10 <neighbors> so this version fails with or without -O
14:58:16 <neighbors> the version with Map works with -O
14:58:21 <neighbors> but fails without it
15:00:26 <ab9rf> buildTrigramHash does recurse a lot
15:00:49 <ab9rf> it's tail recursive, though
15:01:03 <neighbors> I should also mention that I'm passing in the entire text of Moby Dick into it
15:01:08 <cmccann> tail recursion that isn't strict enough is typically the problem
15:01:11 <neighbors> with smaller inputs it is fine
15:01:17 <cmccann> like with foldl
15:01:30 <ab9rf> there are probably unevaluated thunks being stuffed into the map
15:01:57 <neighbors> where would be the proper place to introduce strictness?  And would I do it with ! ?
15:02:16 <cmccann> neighbors: easiest thing is probably to start by testing each function individually since you only have a few
15:02:22 <cmccann> see which one is blowing up
15:02:50 <cmccann> then make it strict in any arguments that will need to be evaluated by the end regardless and see if that helps
15:03:00 <ab9rf> it's probably in buildPhrase
15:03:04 <ab9rf> that has a non-tail recursion
15:03:16 <neighbors> yeah buildPhrase does have a non-tail recursive call
15:03:23 <neighbors> same in the Map version I also had that
15:03:25 <ab9rf> two of them in fact
15:03:35 <ab9rf> although you could probably change it so it's tail-recursive
15:03:41 <cmccann> tail recursion isn't really the same thing in Haskell it is in other languages though
15:03:56 <ab9rf> cmccann: true
15:05:06 <monochrom> I tempt you with unsafeInterleaveIO
15:05:09 <cmccann> normalizeWord is probably fine other than probably being a reinvented wheel
15:05:19 <ab9rf> heh
15:05:23 <monochrom> next <- unsafeInterleaveIO (buildPhrase ...)
15:05:35 <ab9rf> monochrom: heh
15:05:36 <hpc> don't do it! mixing execution and evaluation is the first step to the dark side
15:05:59 <ab9rf> IO is only used there because of stdRandom
15:06:06 <cmccann> buildTrigramHash consumes input and does IO operations on the hashtable so I suspect it's fine
15:06:30 <neighbors> in the Map version buildPhrase is pure
15:07:00 <monochrom> my angelic side says: don't even use hashtable, use hashmap (e.g., package "unordered-containers"), or generally any pure data structure. when you stay pure and outside IO, non-tail recursion makes sense.
15:07:30 <monochrom> which is what neighbors also says
15:07:44 <neighbors> monochrom: I first wrote this with Map and other than a couple lines in main, everything else was pure
15:08:00 <neighbors> in that version compiling with -O was fine but without would also fail due to a stack overflow
15:08:10 <neighbors> changing to Hashtable was an attempt to fix that but made the situation worse
15:08:16 <neighbors> I could paste the Map version as well
15:08:29 <monochrom> they overflow for very different causes
15:08:40 <monochrom> very different. unrelated.
15:09:02 <cmccann> and the Map version apparently overflows for a cause that the strictness analyzer understands
15:09:44 <hpaste> neighbors pasted “map version of trigram code” at http://hpaste.org/86602
15:11:44 <neighbors> that's the Map version, which I prefer, but tried HashTable (without success) due to the overflow
15:11:44 <monochrom> in the pure version, line 11, add "$!" before "(insertTrigram ...)"
15:12:20 <monochrom> the pure version is exactly the foldl problem
15:12:37 <monochrom> the impure version is exactly the mapM problem
15:13:11 <neighbors> I guess I need to read up on the foldl problem, I often see foldl' or something recommended but haven't investigated the concept
15:13:12 <monochrom> and they are exactly opposite problems
15:13:32 <cmccann> monochrom: what's the "mapM problem" specifically?
15:13:50 <neighbors> good call, monochrom, adding $! fixed it
15:13:59 <neighbors> I need to read up on why as I'm curious
15:14:14 <cmccann> > foldl (+) 0 [1..1000000]
15:14:16 <lambdabot>   *Exception: stack overflow
15:14:17 <cmccann> > foldl' (+) 0 [1..1000000]
15:14:19 <lambdabot>   500000500000
15:14:25 <jfischoff_> @src foldl'
15:14:25 <lambdabot> foldl' f a []     = a
15:14:26 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:14:44 <oconnor0> @src foldl
15:14:44 <lambdabot> foldl f z []     = z
15:14:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:15:01 <monochrom> mapM looks like "action = do { y <- something; ys <- action; return (y : ys) }"
15:15:10 <monochrom> this is a stackoverflow for IO
15:15:46 <monochrom> the recursive call to action is eager and non-tail. that combination is a stack overflow
15:16:08 <monochrom> it is also what everyone runs into with C, Java, ML
15:16:43 <cmccann> monochrom: ok that makes sense. I guess I usually don't recurse that deep in IO because I don't think I've seen that happen before...
15:16:59 <cmccann> I figured it was something along those lines but wasn't sure
15:17:31 <monochrom> try "mapM return (repeat ()) >>= print" some time
15:17:35 <__xc> > "five commit msgs: "++concatMap show [1..5]
15:17:38 <lambdabot>   "five commit msgs: 12345"
15:17:43 <jfischoff> monochrom: In the pure version, would forcing evaluation of t in buildTrigramMap on each call fix the issue?
15:17:49 <__xc> +first*
15:18:22 <monochrom> yes, that's one small step away from what I did
15:18:38 <jfischoff> oh I didn't see what you did.
15:18:49 <monochrom> I put a $! somewhere.
15:19:14 <monochrom> the two ways differ by O(1)
15:19:40 <monochrom> http://hpaste.org/77374 enjoy! :)
15:19:48 <mmmmmmm> What is the meaning of this error    (Type of kind * used as a constraint) ?
15:20:02 <monochrom> it means wrong constraint
15:20:07 <cmccann> it means you used a type of kind * as a constraint, heh
15:20:09 <cmccann> what's the code?
15:20:19 <mmmmmmm> wait
15:20:23 <cmccann> you probably used Frational instead of Rational or something
15:20:26 <cmccann> that's what I usually do
15:20:31 <monochrom> for example "Bool m => Monad m"
15:20:38 <cmccann> (er, or the other way around)
15:20:40 <hpaste> mmmmmmm pasted “nw” at http://hpaste.org/86604
15:21:04 <monochrom> I don't know what is "Network"
15:21:09 <monochrom> (do you?)
15:21:31 <monochrom> and you lack required indentation
15:21:39 <hpaste> mmmmmmm pasted “network” at http://hpaste.org/86605
15:21:56 <monochrom> and "==" is unlikely a good name.
15:22:18 <monochrom> Network is a type, not a class.
15:22:50 <monochrom> but in "class (X a) => Y a", X has to be a class. non-negotiable. no but. no if.
15:23:09 <mmmmmmm> i got it thank you
15:23:29 <jfischoff> monochrom: I just learned you can case match on strings like that :o
15:23:46 <monochrom> sorry, like which?
15:23:49 <ab9rf> True && .... ?
15:24:16 <jfischoff> using string literals
15:24:35 <jfischoff> case xs of "yo" -> 1
15:25:00 <ab9rf> jfischoff: first time i tried that i didn't know if it would work, but it did :)
15:25:21 <monochrom> the benefit of learning from the gentle introduction, as opposed to watered down tutorials!
15:25:30 <tromp> > product [3/4,8/9,24/25,48/49]
15:25:33 <lambdabot>   0.6269387755102039
15:25:37 <jfischoff> :)
15:25:38 <ab9rf> in afterthought i realized it was obvious that it would work
15:26:28 <jfischoff> also discovered this weak that I can do this data Thing = Foo { x :: Int } | Bar { x :: Int, optional :: String }
15:26:36 <jfischoff> s/weak/week
15:26:43 <hpc> be careful, optional is partial
15:27:00 <jfischoff> I though it would complain about x
15:27:02 <monochrom> that one I forgot whether it's in the gentle introduction or I had to read the standard
15:27:07 <jfischoff> hpc: I was using it in a GADT
15:27:08 <hpc> no, x :: Thing -> Int
15:27:21 <kate_r> hi
15:27:36 <jfischoff> kate_r:hello
15:27:45 <hpc> jfischoff: heh; i wonder if it infers a sufficiently unpolymorphic type for optional
15:27:53 <kate_r> just wondering, is type class typically used to handle ad-hoc polymorphism?
15:27:54 <cmccann> jfischoff: do you know about how tightly record syntax binds, syntactically?
15:28:02 <cmccann> kate_r: that's what they're for
15:28:04 <jfischoff> actually wait I didn't try it
15:28:06 <johnw> shachaf: actually, what I said wasn't a joke at all
15:28:14 <kate_r> cmccann: how about parametric polymorphism?
15:28:17 <jfischoff> I just planned on using it in a gadt
15:28:22 <jfischoff> let me see
15:28:26 <neighbors> thanks monochrom cmccann jfischoff for the help
15:28:34 <monochrom> just use a type variable for parametric polymorphism
15:28:42 <jfischoff> cmccann: the tightest right?
15:28:49 <kate_r> monochrom: no need for type class?
15:28:51 <cmccann> jfischoff: tighter than function application, yes
15:28:54 <monochrom> no
15:29:13 * jfischoff nods
15:29:13 <monochrom> "fst :: (a,b) -> a" uses no type class
15:29:29 <cmccann> jfischoff: so "foo bar { x = y}" parses as "foo (bar { x = y})"
15:29:56 <jfischoff> right
15:30:16 <cmccann> jfischoff: and I'm pretty sure you've seen my thing about the extent of lambdas and type annotations
15:30:22 <cmccann> @quote cmccann Int -> Int
15:30:22 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
15:30:44 <jfischoff> heh
15:31:10 <jfischoff> that's odd
15:31:42 <quchen> Sometimes things like formal fixities would be really nice to have for symbols like :: and ->
15:31:54 <cmccann> :t (4 * 5 +) -- this also surprised me the first time I saw it
15:31:56 <lambdabot> Num a => a -> a
15:32:26 <monochrom> and type class doesn't completely kill parametric polymorphism, just weakens a tiny little bit. "f :: (Monad m) => m Int" says that all you can do is return and >>=. you can't getLine (m may not be IO), you can't get (m may not be State). effectively, f has no effect and must give the same Int every time.
15:32:43 <jfischoff> cmccann: that one seems natural, what was confusing?
15:33:21 <Ralith> monochrom: insofar as that type classes can be trivially rewritten as record-pasing, they don't weaken it at all
15:33:35 <monochrom> yeah
15:33:46 <cmccann> jfischoff: I dunno, I just didn't expect it to work for whatever reason
15:34:15 <jfischoff> hpc: oh wait it doesn't work in GADT which makes sense :(
15:36:03 <jfischoff> in other discovers lambda case is becoming an integral part Haskell style
15:36:35 <jfischoff> foo = \case {newline} [match]
15:36:51 <stepkut> is there anything like:
15:36:52 <stepkut> untry :: IO (Either e a) -> IO a
15:36:55 <stepkut> untry = fmap (either error id)
15:36:58 <stepkut>  
15:37:16 <hpc> there's one thing that's exactly like that
15:37:39 <hpc> 18:36 < stepkut> untry = fmap (either error id)
15:37:41 <hpc> ;)
15:38:01 <arkeet> probably better to use ioError or something
15:38:05 <hpc> jfischoff: i am a big fan of lambda case
15:38:12 <arkeet> if you're in IO
15:38:12 <jfischoff> wah wah
15:38:22 <hpc> i would do something like
15:38:25 <pxqr> i have ghc 7.4.1 and then i running `setNumCapabilities (-1)' i have the folling message "malloc: failed on request for 18446744073709551104 bytes; message: moreCapabilities"
15:38:27 <hpc> (Right x) <- action
15:38:29 <hpc> ...
15:38:37 <pxqr> is it bug and is it fixed?
15:38:46 <arkeet> hmm
15:38:50 <arkeet> not ioError
15:38:53 <hpc> pxqr: the bug is using negative capabilities, arguably
15:39:03 <arkeet> I mean throwIO
15:39:04 <pxqr> hpc: heh
15:39:06 <jfischoff> hpc: yeah its great
15:39:08 <monochrom> stepkut: untry is not in the libs. but interesting thing. you may like to s/error/throwIO/
15:39:09 <arkeet> :t (>>= either throwIO return)
15:39:10 <lambdabot> Not in scope: `throwIO'
15:39:23 <arkeet> :t (>>= either (?throwIO :: Exception e => e -> IO a return)
15:39:25 <lambdabot> parse error (possibly incorrect indentation)
15:39:25 <arkeet> :t (>>= either (?throwIO :: Exception e => e -> IO a) return)
15:39:26 <lambdabot>     Not in scope: type constructor or class `Exception'
15:39:31 <arkeet> :t (>>= either (?throwIO :: e -> IO a) return)
15:39:32 <lambdabot>     Unbound implicit parameter (?throwIO::e -> IO a1)
15:39:33 <lambdabot>       arising from a use of implicit parameter `?throwIO'
15:39:33 <lambdabot>     In the first argument of `either', namely `(?throwIO :: e -> IO a)'
15:39:36 <arkeet> ??
15:39:41 <arkeet> I guess I can't do that.
15:40:05 <pxqr> hpc: well but thats not exception or something; just crush
15:40:51 <cmccann> yeah it shouldn't crash hard. if that's not an exception catchable from IO it sounds like a bug
15:41:17 <hpc> @src IO fail
15:41:18 <lambdabot> fail s  = failIO s
15:41:22 <hpc> @src failIO
15:41:23 <lambdabot> failIO s = ioError (userError s)
15:41:29 <hpc> poof!
15:41:31 <hpc> catchable error
15:41:42 <monochrom> yes, it is catchable in IO
15:41:58 <cmccann> also, clearly negative capabilities should uncompute things previously computed things while creating extra cores on your cpu.
15:42:03 <pxqr> cmccann: not catchable;
15:42:13 <pxqr> cmccann: heh
15:54:10 <Ghoul_> how can I use parsec to match 1 or more whitespaces
15:55:10 <hpc> space >> many space
15:55:10 <hpc> ?
15:55:23 <stepkut> hpc: no
15:55:27 <Ghoul_> uh
15:55:29 <stepkut> many1 space
15:55:38 <hpc> why?
15:55:41 <stepkut> well, space >> many space would work
15:55:42 <Ghoul_> does that include comments and stuff
15:55:46 <supki> @ty some
15:55:47 <lambdabot> Alternative f => f a -> f [a]
15:55:50 <monochrom> both are good. but many1 is shorter
15:56:04 <monochrom> no comment
15:57:05 <arkeet> @src some
15:57:05 <lambdabot> some v = some_v
15:57:05 <lambdabot>   where many_v = some_v <|> pure []
15:57:05 <lambdabot>         some_v = (:) <$> v <*> many_v
15:57:22 <stepkut> hpc: do you care about how much space you parsed?
15:57:24 <monochrom> use stuff in Text.Parsec.Language and Text.Parsec.Token to skip comments. at which point you don't deal with space yourself
15:57:44 <hpc> stepkut: does Ghoul_ care?
15:57:49 <stepkut> 'space >> many space' would parse 1 space, through it away, and then parse 0 or more spaces and return a string
15:57:53 <stepkut> oh, oops
15:57:54 <stepkut> sorry
15:58:02 <Ghoul_> Not at all
15:58:04 <monochrom> see my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements for examples
15:58:20 <Ghoul_> But it turns out I can't use space because it only parses whitespace
15:58:29 <Ghoul_> and a/* */b is valid syntax
15:58:39 <monochrom> see what I said
15:59:10 <hpc> Ghoul_: that's horrifying and you should just ignore that edge case ;)
16:01:17 <cmccann> > f{- WHAT NOW -}x :: Expr
16:01:19 <lambdabot>   f x
16:01:44 <Ghoul_> hpc: the language im parsing actually has a C syntax and a delphi variant nobody uses
16:01:59 <Ralith> monochrom: those aren't very useful for parsing things that aren't more or less (subsets of) haskell syntax.
16:02:00 <Ghoul_> I was thorough and implemented both as an edge case including mixing both in the same file
16:02:06 <Ghoul_> so I may as well implement this too
16:04:19 <arkeet> > f{-NOSPACE-}x :: Expr
16:04:21 <lambdabot>   f x
16:04:30 <cmccann> comments are whitespace in Haskell
16:04:44 <cmccann> like, literally so if I remember the Report correctly
16:04:50 <arkeet> even in layout?
16:05:04 <cmccann> I'm not sure how they count for column position
16:05:27 <Ghoul_> `many1 whiteSpace` work fine, or does that look ineffecient
16:05:53 <cmccann> arkeet: ok looks like comments count as whitespace by their actual width in characters
16:05:56 <cmccann> for layout purposes
16:06:04 <arkeet> heh
16:06:31 <cmccann> so if you have a layout block you can put comments in the otherwise empty space to the left of the code
16:06:32 <cmccann> that's
16:06:34 <cmccann> interesting
16:07:02 <Clint> that's wacky
16:07:18 <arkeet> what about tabs in comments?
16:07:31 <cmccann> those get parsed as a slap upside the head
16:07:32 <Ralith> oh dear
16:07:35 <arkeet> haha
16:07:54 <Ralith> IOHCC contest participants, you better be take notes
16:08:17 <Ralith> s/contest // s/take/taking/
16:09:18 <hpaste> “C. McCann” pasted “this is just terrible” at http://hpaste.org/86610
16:10:03 <arkeet> :D
16:10:22 <cmccann> on the bright side that could actually be useful
16:10:23 <johnw> i find it pretty annoying that you can do f `catch` const (return Nothing)
16:10:33 <johnw> it always gives type ambiguity warnings
16:10:36 <cmccann> reclaim space in deeply indented layout blocks by adding useful comments
16:10:55 <cmccann> rather than using -- on the right side
16:11:20 <monochrom> http://hpaste.org/81623
16:12:37 <Ghoul_> where does << import from
16:13:09 <Ralith> @hoogle (<<)
16:13:09 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
16:13:09 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
16:13:10 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
16:13:25 <cmccann> I don't think (<<) exists.
16:14:09 <Ghoul_> hmm
16:14:19 <arkeet> what would it do?
16:14:25 <arkeet> is it flip (>>), or is it (<*)?
16:14:31 <Ghoul_> bracesStmt = between (symbol "{" <|> (string "begin" >> many1 whiteSpace)) (symbol "}" <|> (string "end" >> many1 whiteSpace)) (Braces <$> many stmt)
16:14:48 <Ghoul_> I get unexpected () expecting Char type
16:14:55 <Ghoul_> so I think I just need to flip the >> arund
16:15:53 <Ghoul_> so it'd be do { x <- string "begin"; whiteSpace; return (x) }
16:15:58 <Ghoul_> I think.
16:17:04 <Ghoul_> but there is probably an infix operator to do it that I don't know about ;)
16:18:00 <Ghoul_> :t <*
16:18:02 <lambdabot> parse error on input `<*'
16:18:07 <Ghoul_> :t (<*)
16:18:09 <lambdabot> Applicative f => f a -> f b -> f a
16:20:06 <arkeet> <* will still parse the first argument before the second, it will just return the result of the first.
16:20:18 <arkeet> flip (>>) would parse the second argument before the first, which is probably not what you want.
16:22:14 <Ghoul_> Works perfectly at compile time, except I get a runtime error about whiteSpace also accepting null and hence (many "") is undefined
16:22:50 <Ghoul_> looking at the docs and source code atm to see if I can re-invent the wheel
16:23:42 <tommd> aleator: Ping
16:28:28 <Ghoul_> Anyone know how to remove "" from a parser so that it can be passed through many without a runtime error?
16:29:34 <Clint> what
16:30:59 <Ghoul_> Clint: I get this error at runtime when using many1 whiteSpace. It's a logical error, and I know what it means, but I wouldn't like to reinvent whiteSpace all over again. It'd be nice if I could just remove its ability to parse nothing
16:31:13 <Ghoul_> http://puu.sh/2H86b/019c79a9a5.png
16:33:59 <Clint> Ghoul_: what is "many1 whiteSpace" supposed to do
16:35:01 <cmccann> Ghoul_: how is whiteSpace defined?
16:35:57 <Ghoul_> Clint: one or more spaces or comments
16:36:00 <Ghoul_> cmccann: sec
16:36:48 <Ghoul_> whiteSpace is defined as skipMany (simpleSpace <|> oneLineComment <|> multiLineComment <?> "")
16:37:05 <cmccann> ditch the skipMany
16:37:22 <cmccann> or rather, make the rest of it a separate parser
16:37:27 <Ghoul_> whiteSpace is part of parsec
16:37:28 <Ghoul_> :P
16:37:54 <cmccann> ...it is? oh, that's the expression module thingie.
16:38:04 <cmccann> I think I already told you I've not used that much, heh.
16:38:07 <Ghoul_> yeah turns out simpleSpace uses isSpace
16:38:16 <Ghoul_> which I think matches "" as a space
16:38:18 <Ghoul_> which is a mess.
16:39:30 <cmccann> anyhow, there's no real way to repeat a parser that can consume nothing and succeed
16:39:34 <cmccann> for hopefully obvious reasons
16:39:40 <cmccann> since it can happily parse nothing forever
16:40:45 <Ghoul_> if spaces is really defined as including nothing and there isn't an alternative thats a really big library oversight if you ask me
16:41:26 <cmccann> Text.Parsec.Char has "space" and "spaces" if memory serves me
16:41:39 <cmccann> the latter being "skipMany space"
16:41:52 <cmccann> so you can use "space" for stuff like what you're doing
16:44:15 <monochrom> please don't speak of "oversight" until you have completely read the docs. completely. please. pretty please.
16:44:30 <monochrom> (why do people bother to give uninformed opinions?)
16:45:57 <BMeph> monochrom: Because getting and staying informed takes hard work? ;þ
16:46:16 <monochrom> (if it is one of those provocative tactics of saying "xxx sucks" until people teach you how to use xxx, shame on you)
16:46:17 <cmccann> well he did say "if (statement that might be false) then that's an oversight"
16:46:51 <monochrom> screw the if-statement. read the doc or shut up. really. I am impatient with such people.
16:47:18 <Ghoul_> I cant see anything that isnt privately scoped for skipping comments
16:48:12 <Ghoul_> space does work, but has the odd side-effect that something like `begin//hello` parses incorrectly expecting /
16:48:26 <Ghoul_> singleLineComment and multiLineComment (seem) to be inaccessible.
16:48:36 <Ghoul_> or I dont understand how to access them
16:50:38 <augur> monochrom: but xxx DOES suck. it was a horrible movie. :|
16:50:50 <monochrom> haha
16:51:31 <augur> monochrom: :)
16:51:52 <augur> this message brought to you by the department of intentionally misinterpreted acronyms
17:01:42 <johnw> xxx isn't an acronym ;)
17:02:31 * johnw schedules augur's transfer to the department of intentionally misinterpreted abbreviations
17:03:18 <neighbors> I thought it stood for X-rays of Xenu's Xylophone
17:04:20 <augur> johnw: its not an abbreviation either!
17:05:30 <augur> its actually just a proper name
17:06:22 <johnw> haha
17:07:54 * Ralith cracks knuckles, starts working on the llvm bindings' Great Merge
17:11:24 <Ghoul_> well, my "solution" to my problem was to use an abuse `reserved`: between (reserved "{" <|> reserved "begin") (reserved "}" <|> reserved "end") (Braces <$> many stmt)
17:11:40 <Ghoul_> maybe that helps someone in the future, idk.
17:13:33 <armlesshobo> anybody here try downloading the 64bit OSX version of the Haskell Platform?
17:13:37 <armlesshobo> tried*
17:14:28 <armlesshobo> because it's taken me 2 hours (on a 25MBit line) to download about half of it.
17:15:55 <johnw> armlesshobo: I haven't tried today, but I have in the past
17:16:12 <armlesshobo> johnw: has it ever taken you this long to download it?
17:16:41 <johnw> to tell you the truth, I background downloads that sometimes take months, so I'm not really sensitive to those issues
17:16:50 <johnw> it could have been slow, yeah
17:17:44 <luite> is it served from the hetzner server?
17:17:50 <armlesshobo> hehe ok
17:19:02 <hpc> johnw: that's painful
17:19:22 <johnw> hpc: I'm doing it from a desktop, honestly I forget the transfers are there sometimes
17:19:33 * johnw restarts a transfer he's been waiting on since march
17:19:39 <hpc> how does it take so long?
17:19:52 <johnw> it's a torrent for the In Our Time series, and there is no seed
17:20:01 <johnw> i just end up uploading all the bits I have, over and over
17:20:14 <hpc> ow
17:20:23 <hpc> is it at least available?
17:20:34 <johnw> ask me this winter :)
17:21:22 <pxqr> ghc lastest commit message: "Fixed moer tyops"
17:21:53 <hpc> $ ghc --version
17:22:01 <hpc> The Glorious Glasgow Haskell Compliation System, version 7.4.1
17:22:06 <luite> armlesshobo: is this just as slow? http://hdiff.luite.com/tmp/Haskell%20Platform%202012.4.0.0%2064bit.pkg
17:23:07 <armlesshobo> luite: yeah, around 2hrs 45min
17:23:47 <luite> armlesshobo: hmm, must be some bad connection between your isp and hetzner (this is another server at hetner)
17:24:34 <armlesshobo> if the other bundles for the other platforms are hosted there, then this must be a new thing.
17:24:44 <armlesshobo> I've never experienced this ever
17:25:55 <luite> probably some overloaded link or bad routing... i sometimes have a bad connection to hetzner, switching to ipv6 sometimes helps
17:34:45 <ab9rf> once in a while the IPv4 stack on my laptop just stops working for no apparent reason
17:46:51 <orzo_> hi
17:47:12 <amosr> hello
17:47:13 <orzo_> i am bumping against the "possibly not injective" type function problem
17:47:45 <orzo_> is there any page with advise on dealing with that?
17:47:57 <orzo_> regarding type families
17:49:03 <parcs> use data families
17:49:09 <orzo_> okay
17:49:22 <orzo_> thanks
17:51:42 * hackagebot happstack-heist 7.1.0 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.1.0 (JeremyShaw)
17:54:31 <orzo_> worked for one case, but in another case i had to make a pseudo-argument to help it infer type since i really do have a non-injective type function
17:58:54 <hpc> it might help to have the problematic code
17:59:01 <hpc> and what it's being used for
18:01:07 <bscarlet> How can I reason about something like "f x = (Map.fromList someList) Map.! x" ? Under what circumstances can I count on the map not being rebuilt for different invocations of f?
18:02:03 <monochrom> very likely rebuilt
18:02:06 <hpc> bscarlet: the general rule of values is, if you like it put a name on it
18:02:26 <hpc> let v = f m in (blah v blah blah v blah)
18:04:04 <monochrom> if you alias something, it is computed at most once. if you don't alias, usually the things are re-computed, but -O may alias some of them for you. read GHC core to find out
18:04:40 <bscarlet> so is "f = let m = Map.fromList someList in (m Map.!)" different from "f x = let m = Map.fromList someList in (m Map.! x)"?
18:04:50 <hpc> and then if you find yourself reading ghc core
18:04:55 <monochrom> alias means "let x=1+1 in x*x*x" or "(\x -> x*x*x) (1+1)" or "let x=1+1; y=x; z=y; ..."
18:04:56 <hpc> alias it anyway
18:05:27 <monochrom> yes, they are different, unless -O makes them the same, sometimes it happens
18:07:01 <hpc> imo, you should never have to read ghc core to optimize a program
18:07:20 <bscarlet> monochrom: if they're different, is the former preferable? Should I think I'm making one definition which can share an "m" vs. the latter which is making a separate "m" for each "x"?
18:08:18 <Eduard_Munteanu> Also let vs where. :/
18:08:29 <monochrom> I don't know which one is preferrable. I don't know whether spending memory is preferrable to spending time. that is your call, not mine.
18:08:59 <monochrom> I prefer spending neither, if you ask me :)
18:09:19 <Shaladdle> anybody have experience doing haskell + opengl + os x?
18:09:31 <Shaladdle> I tried a glut example but that doesn't work with runhaskell/ghci
18:09:40 <Shaladdle> and I tried following this http://stackoverflow.com/questions/5868916/haskell-graphics-library-that-works-in-ghci-on-macos-x
18:09:47 <Shaladdle> but the link to EnableGUI.hs is broken :(
18:09:56 <bscarlet> monochrom: yeah, sorry. By preferable, I meant spending memory as opposed to time.
18:10:39 <monochrom> there is insufficient difference between let and where
18:11:31 <bscarlet> I remember seeing something related to my question and let vs. where, but I don't remember the details.
18:11:31 <Eduard_Munteanu> I thought 'where' was more likely to result in sharing, because it binds to the entire definition.
18:11:41 <bscarlet> ah.
18:11:58 <hpc> Eduard_Munteanu: let-in binds exactly where it is placed
18:12:06 <hpc> Eduard_Munteanu: where binds between pattern match and guards
18:12:10 <monochrom> I do not believe it. but I am glad to see evidence (not hearsay).
18:12:20 <mm_freak> bscarlet: the rule of thumb is:  if you want to share a value, give it a name
18:12:36 <hpc> mm_freak: i like my pithy truism better ;)
18:12:41 <amosr> I am looking at what I think is a ghc SpecConstr bug, and trying to write a test case
18:12:49 <mm_freak> bscarlet: examples:  "let x = …", "where x = …", "f x = …", "module Blah where x = …"
18:13:36 <Eduard_Munteanu> Also I guess f = \x -> ... makes sharing more likely, no?
18:13:37 <amosr> I have "let x = (let a = expensive in a, simple)" and don't want the 'expensive' floated out of the tuple… any tricks how I might achieve that?
18:13:52 <mm_freak> bscarlet: the last example is noteworthy, because it introduces global sharing…  don't put anything big there, if you need it only in a single function a single time
18:14:10 <bscarlet> mm_freak: yeah. I think my following question demonstrates the problem with that rule of thumb. The scope of the name seems to be pretty important.
18:14:53 <mm_freak> bscarlet: it is…  if it goes out of scope and isn't used anymore, it gets garbage-collected
18:15:21 <mm_freak> bscarlet: that's why this is a common style (at least for me): "f = loop where x = …; loop = …"
18:15:38 <mm_freak> for the duration of the evaluation of 'loop' the 'x' is shared
18:18:06 <bscarlet> How likely is ghc to transform "\x -> let m = thingIndependentOfX in g m x" to "let m = … in \x -> g m x"?
18:18:50 <cmears> With optimization turned on, it has happened to me
18:18:50 <Eduard_Munteanu> Damn... I sort of wish this had more reliable semantics.
18:18:56 <amosr> seems likely
18:19:05 <Eduard_Munteanu> Was it a full moon or not? :P
18:19:41 <amosr> but maybe it'll float it back in afterwards if it feels like it…?
18:19:55 <bscarlet> Eduard_Munteanu: Not a full moon at the day of compilation, but a blue moon for the month overall.
18:20:16 <mm_freak> bscarlet: unlikely, unless it doesn't change the sharing behavior
18:20:32 <mm_freak> in some very special cases GHC will introduce sharing, but it will not do so in general, and it will never eliminate sharing
18:21:24 <bscarlet> Okay. Thanks all.
18:22:24 <monochrom> Oleg knows a case of increasing sharing (against his will)
18:22:37 <hpc> oleg knows lots of things
18:22:54 <monochrom> -fno-full-laziness stops most of the unwanted sharing
18:23:41 <cmears> You get (sometimes unwanted) sharing in the definition of "sequence"
18:24:21 <mm_freak> cmears: huh?  how?
18:24:50 <mm_freak> i don't see any opportunity for sharing there
18:24:54 <cmears> http://stackoverflow.com/questions/3190098/space-leak-in-list-program
18:24:56 <cmears> Have a look at that
18:25:49 <cmears> and in RD1's answer, how to introduce a fake dependency that tricks the compiler into not doing the sharing
18:27:25 <mm_freak> interesting
18:27:44 <cmears> That particular problem with sequence bit me recently |:
18:27:51 <monochrom> and also https://groups.google.com/forum/#!msg/comp.lang.haskell/nKDULVCjj74/vCq-NxV2DkgJ
18:27:52 <mm_freak> i think i'
18:28:05 <mm_freak> i think i've never encountered it, but that's probably because i seldomly use 'sequence'
18:28:20 <sw2wolf> @ty sequence
18:28:22 <Eduard_Munteanu> And these are the accounts of seeing the werewolf during the full moon...
18:28:23 <lambdabot> Monad m => [m a] -> m [a]
18:28:37 <mm_freak> except perhaps for demonstrating haskell's conciseness =)
18:28:53 <mm_freak> > sequence (transpose ["BLAH", "blah"])
18:28:55 <lambdabot>   ["BLAH","BLAh","BLaH","BLah","BlAH","BlAh","BlaH","Blah","bLAH","bLAh","bLa...
18:36:12 <monochrom> http://okmij.org/ftp/Haskell/misc.html#memo-off
18:36:38 <monochrom> (it takes forever to get search engines to work)
18:38:18 <monochrom> -fno-full-laziness helps with most cases, including oleg's, but there is still one unsolved case (the comp.lang.haskell one)
18:38:49 <hpc> yeah, search is hard
18:39:17 <monochrom> if you ask "so how do I predict this", give up, cannot be predicted.
18:40:21 <cmears> Isn't the comp.lang.haskell case the same as the others -- you just can't use the default definition of "sequence"
18:41:02 <Eduard_Munteanu> Sorta sad for a stdlib function
18:41:25 <cmears> Yes
18:41:49 <cmears> But then there must be cases where the let floating in sequence is beneficial
18:44:48 <monochrom> cmears: see my (Albert Lai) reply, actual experiments, try to use one single theory to explain them all
18:45:40 <cmears> Ah, thanks for the pointer
18:46:31 <cmears> You mean the program that takes exponential memory with and without optimization?
18:47:14 <monochrom> I mean both programs and all 4 results. can you explain them using 1 theory?
18:47:30 <monochrom> I know an easy way of using 4 theories, but that clearly isn't scientific.
18:47:58 <monochrom> also, -fno-full-laziness doesn't work for some of them
18:48:46 <monochrom> granted, I still haven't tried the "fake argument for fake dependency" trick
18:54:29 <monochrom> well, perhaps you are right that the comp.lang.haskell case is essentially the same phenomenon as the stackoverflow.com case
18:54:50 * RenJuan wonders why everything has to work in Haskell. I'd rather do stuff in other lengs like that search where they've already adapted for it.
18:56:50 <RenJuan> and maybe didn't have to climb down from something to do so in the first place
18:57:01 <cmears> monochrom, I'm not sure
18:57:05 <cmears> I don't see why the second program eats memory even without optimization
18:57:27 <ab9rf> is this another thunk explosion issue?
18:57:57 <Eduard_Munteanu> *thunk*
18:59:21 <monochrom> it is not thunk explosion. it is already-evaluated-data explosion
18:59:25 <ab9rf> ah
18:59:58 <cmccann> "thunk" is the sound a newbie's head makes, hitting the keyboard after foldl produces a stack overflow
19:00:17 <Eduard_Munteanu> Heh.
19:00:56 <Eduard_Munteanu> But only until said overflow magically disappears because he added -O. :(
19:01:18 <neighbors> is it generally better to use foldl' and not compile with -O?
19:01:24 <Eduard_Munteanu> To optimize or not to optimize... those are the semantics.
19:01:25 * cmccann recalls the actual meaning of thunk as something to do with the computer needing to think about it more and "thunk" being the past tense of "think" at 3am
19:01:28 <neighbors> or is it preferable to use foldl and -O?
19:01:39 <Eduard_Munteanu> neighbors: foldl' and -O   :)
19:01:44 <mercuryrising> can anyone help me out with this palindrome finder (what am I doing that's making it run so poorly), in Python it runs under .1 seconds, in Haskell (my script) takes ~30 seconds - paste of both here -> http://pastebin.com/RCYzmvvS
19:01:45 <neighbors> ah, OK
19:01:50 <monochrom> what Eduard_Munteanu says
19:02:42 <Eduard_Munteanu> It's quite annoying that -O makes such a difference... it's almost entirely different semantics, one could argue.
19:03:23 <Eduard_Munteanu> Maybe worse with sharing, given there's no sanctioned, specific sharing annotation.
19:05:00 <Eduard_Munteanu> cmccann: heh... I guess past tense forms aren't that irregular after all. They spring up out of nowhere.
19:05:32 <monochrom> (length list)==1 takes forever. use pattern matching. therefore also screw "tail list" and "head list".
19:05:47 <monochrom> read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
19:06:11 <Eduard_Munteanu> You mean that for mercuryrising, I guess.
19:07:06 <monochrom> but I suppose list is really short
19:07:35 <monochrom> no, nevermind, list is long
19:08:02 <Eduard_Munteanu> mercuryrising: did you enable -O (at least)?
19:08:16 <mercuryrising> no, that's compiler optimization?
19:08:22 <Eduard_Munteanu> mercuryrising: yes
19:08:34 <neighbors> I'd imagine list is relatively short (like 8 or so) unless that file has some monsterous numbers in it
19:08:37 <monochrom> an O(n^2) algorithm is slow with -O or not
19:08:52 <Eduard_Munteanu> I wouldn't take a result of running GHC without optimizations as representative.
19:09:01 <mercuryrising> list is 1:10010
19:09:13 <mercuryrising> takes about the same with -O enabled
19:09:41 <neighbors> I wonder if in isPal it might be worth doing let numString = show num in instead of having it in two places, unless haskell catches that and optimizes it
19:09:51 <neighbors> since isPal is called so deeply nested
19:09:57 <monochrom> enumRange is O(n^2). if list has 10000 items, enumRange takes 10000*10001/2 steps. or something
19:10:02 <luziiann> hello
19:10:04 <Eduard_Munteanu> mercuryrising: did you make sure it recompiled it? You usually need to touch the file or add -fforce-recomp if you want to change that.
19:10:15 <Eduard_Munteanu> luziiann: hi
19:10:23 <monochrom> ok, no one sees me.
19:10:24 <neighbors> mercuryrising: was your algorithm virtually identical in the python version?
19:10:32 <luziiann> need learn haskell
19:10:45 * Eduard_Munteanu is a bit tired to read all that now :/
19:10:59 <Eduard_Munteanu> luziiann: you might want to start by checking out LYAH
19:11:01 <Eduard_Munteanu> @where lyah
19:11:02 <lambdabot> http://www.learnyouahaskell.com/
19:11:04 <luziiann> is good channel
19:11:14 <mercuryrising> no, this one has recursion, the other one doesn't
19:11:17 <ab9rf> tastes great AND less filling
19:11:31 <Eduard_Munteanu> luziiann: yes, this is a help channel for Haskell
19:11:47 <monochrom> Eduard_Munteanu, if you have a list [1,2,3,4], this algorithm computes length [1,2,3,4], length [1,2,3], length [1,2], and length [1]
19:12:10 <Eduard_Munteanu> Hm.
19:12:18 <monochrom> or maybe the other way round. length [1,2,3,4], length [2,3,4], length [3,4], length [4]
19:12:30 <Eduard_Munteanu> Yeah, I guess it's pretty bad... though I can't stare at the Python code right now.
19:12:34 <monochrom> look at "(length list) == 1"
19:12:57 <Eduard_Munteanu> Probably fewer pitfalls there, though.
19:12:57 <monochrom> I don't think you need read the python code. I haven't read it.
19:13:14 <monochrom> well, clearly, "length list" in python is O(1)
19:13:15 <luziiann> thanks
19:13:38 <ab9rf> python keeps the list length in a property?
19:13:39 <neighbors> yeah no point in traversing the whole list to see if it has 1 element, do pattern matching like monochrom said
19:13:45 <neighbors> what's this all about?  getList [x,y] = [x..y]
19:14:10 <mercuryrising> i wanted to make a range from two numbers
19:14:30 <monochrom> oh, that's just the program assuming that certain lists have length 2. that one is a minor issue
19:14:31 <neighbors> I see
19:14:31 <mercuryrising> im guessing it was the implementation differences, doing it without recursion in haskell gets to ~.7 seconds (sum (map isPal list))
19:14:58 <neighbors> so the file has two numbers on each line, and the program is to test all the numbers inbetween for palindromes
19:15:22 <neighbors> I wonder if incrementing would be faster than constructing a list
19:15:32 <neighbors> I'm guessing in python you didn't construct a list?
19:15:34 <mercuryrising> succ X until hitting the end?
19:15:40 <monochrom> well, currently, because of "head lin", only one input line matters
19:15:50 <mercuryrising> no, xrange is an iterator that grabs only the next value each time
19:16:12 <monochrom> [x..y] is a lazy list that does the same thing as xrange. problem is not here.
19:16:19 <Eduard_Munteanu> neighbors: it might be if there's no fusion, but it hardly makes any difference here, I think
19:16:25 <neighbors> I see
19:16:51 <neighbors> I should probably butt out a bit as I can't even find the inefficiencies in my own haskell programs yet :)
19:17:38 <ab9rf> don't butt out
19:17:43 <ab9rf> just watch and ask questions
19:18:08 <Eduard_Munteanu> Eh... well, fusion can help, but it's not the first thing I'd look at. Especially if you're not competing with slightly efficient C code.
19:19:24 <Eduard_Munteanu> If you're benchmarking something like   sum [1..1000000]    it can show a large difference.
19:20:11 <mercuryrising> pattern matching helped a ton! cut it down to ~.5 seconds unoptimized
19:23:23 <hpaste> “Anonymous Coward” pasted “tutorial error” at http://hpaste.org/86617
19:23:37 <mercuryrising> thanks a lot for the help guys, i didn't know you could pattern match like enumRange [num] count
19:23:41 <twobitsprite> good evening/etc, I'm trying to follow the haskell openGL tutorial on the haskell wiki and I'm getting ambiguity errors: http://hpaste.org/86617
19:23:45 <monochrom> "map" also uses pattern matching. this is why it's fast enough when unoptimized.
19:23:57 <twobitsprite> the tutorial is here: http://www.haskell.org/haskellwiki/OpenGLTutorial1
19:24:25 <monochrom> (and when optimized? "sum (map f [x..y])" doesn't even use lists.
19:24:28 <monochrom> )
19:24:31 <twobitsprite> is the tutorial out of date, or am I just doing something wrong? I copied the code from the example and ran the exact compile command listed...
19:25:00 <Eduard_Munteanu> monochrom: it doesn't? I remember this sort of fusion rarely happening with Prelude stuff
19:25:32 <Eduard_Munteanu> They do stuff like   map f . map g  --->  map (f . g)
19:26:03 <Eduard_Munteanu> @hackage stream-fusion
19:26:03 <lambdabot> http://hackage.haskell.org/package/stream-fusion
19:26:13 <Eduard_Munteanu> ... is nice if you want to improve on that aspect.
19:26:20 <twobitsprite> or... it seems like it's importing the same packages from different locations? I installed the ubuntu package haskell-platform, then cabal installed the OpenGL package... could that be causing package ambiguity?
19:26:25 <monochrom> I don't remember what time they started doing list fusion, but they certainly do today. also, it is not stream fusion
19:27:12 <RenJuan> twobitsprite, y
19:28:02 <Eduard_Munteanu> monochrom: hm, that provides Data.List.Stream and they say "This library is a drop in replacement for Data.List.". I should benchmark, maybe they indeed improved Prelude.
19:28:38 <Eduard_Munteanu> I mean on newer GHC/base versions.
19:28:38 <pqmodn> twobitsprite: try compiling without -package GLUT
19:28:42 <monochrom> read GHC core
19:28:59 <Eduard_Munteanu> Mm.. perhaps later, I want to sleep well. :)
19:29:31 <twobitsprite> pqmodn: same error
19:29:35 <mercuryrising> optimized sum is ~.05 seconds, optimized recursive is ~.05, almost identical
19:29:53 <pqmodn> twobitsprite: i ran through the tutorial just yesterday, perhaps we're on different versions of haskell platform?
19:30:16 <twobitsprite> pqmodn:  2012.2.0.0ubuntu1
19:32:08 <twobitsprite> maybe I should just uninstall the hackage version and stick with the one that ubuntu ships with haskell-platform
19:32:14 <pqmodn> i have 2012.4.0.0, installed via homebrew (on Mac). you might try *not* importing one of the two modules, or adding a "hiding (($=), ColorBuffer, clear, flush)" to one of them
19:32:17 <mercuryrising> up to 1 million, sum is ever so slightly slower than the recursive one, but that's pretty awesome, a bit faster than python!
19:32:39 <RenJuan> i guess there's like an expectation that stuff is supposed to "just work" if something is distributed targetting ubuntu
19:32:47 <RenJuan> specifically
19:33:21 <twobitsprite> pqmodn: well, the problem seems to be that it's finding two instances of the *same* module... I don't think it's because it's finding the same function in the two different modules
19:33:39 <twobitsprite> RenJuan: eh?
19:34:03 <twobitsprite> RenJuan: was that supposed to be a jab at ubuntu users?
19:35:16 <RenJuan> no, an observation based on work with another package, bigbluebutton which targets (successfully) Ubuntu 10.4.something with a large load of software.
19:35:21 <pqmodn> twobitsprite: i think the error you pasted indicates it's found ($=) in two different modules, why do you think it means it's found two instances of the same module?
19:35:25 <Clint> twobitsprite: why did cabal install opengl?
19:35:35 <RenJuan> and the general computing culture of the moment
19:36:18 <pqmodn> oh, OpenGL-2.2.3.1 is the cabal-installed version?
19:36:30 <RenJuan> but yeah a jab, cause I don't wanna use Ubuntu, I prefer debian
19:36:44 <twobitsprite> pqmodn: look at the "originally defined in" lines... it looks like it's seeing it in "Graphics.Rendering.OpenGL.GL.StateVar" but then GLUT imports OpenGL, but finds "OpenGL-2.2.3.1:Graphics.Rendering.OpenGL.GL.StateVar"
19:36:54 <twobitsprite> Clint: I told it to :P
19:36:58 <RenJuan> more of a poke I guess
19:37:10 <Clint> twobitsprite: good reason. why'd you do that?
19:37:18 <twobitsprite> RenJuan: lol... :P
19:37:42 <RenJuan> :)
19:37:56 <monochrom> Eduard_Munteanu: I just read the core for "hrm f x y = sum (map f [x..y])". it produces 1 list. but at least not 2. between "sum" and "map f [x..y]" there is 1 list. but [x..y] does not exist as a list.
19:37:56 <twobitsprite> RenJuan: I guess I'm a bit defensive because often times I tell the self-righteous uber-geeks on IRC that I'm running Ubuntu and they immediately assume I'm a helpless noob :P
19:38:31 <Eduard_Munteanu> monochrom: hm, interesting... I actually expected more of the opposite.
19:38:43 <twobitsprite> Clint: well, honestly I didn't realize the ubuntu haskell-platform came with opengl libs :P
19:38:49 <Clint> ok
19:38:49 <Eduard_Munteanu> [x..y] being an actual list
19:39:06 <Clint> twobitsprite: having packages installed in both places will make everyone cry. you'll want to remove one.
19:39:22 <RenJuan> well I think specifically, effectively *reguiring* ubuntu the way bigbluebutton does prolly won't go over well in the haskell culture
19:39:42 <twobitsprite> Clint: yeah, it seems so... but still seems odd that ghc can't just pick one, preferably the installed for the current user...
19:40:13 <monochrom> "foldr (+) 0 (map f [x..y])" contains 0 lists. but of course, foldr(+) has its other problems
19:40:50 <Eduard_Munteanu> That is a bit weird.
19:40:51 <twobitsprite> RenJuan: oh, I don't know anything about this bigbluebutton thing... but from what you're tellling me I find it a tasty piece of irony for all the packages that the fedora folks put out that pretty much are built only for fedora... :P
19:41:30 <Eduard_Munteanu> Actually it isn't, it just keeps making the thunk bigger.
19:41:59 * Eduard_Munteanu flips table and demands lazy hardware integers
19:42:09 <Eduard_Munteanu> NAO!
19:42:36 <monochrom> in GHC.Base, GHC.List etc., they use the "foldr/build" fusion rule. all producers can be rewritten to a call to "build". all producers can be rewritten to a call to foldr. (and for tranducers like "map", both are done.). and then there is a rule to cancel "foldr k z (build g) = g k z". therefore, "foldr (+) 0 (map f [x..y])" works like a charm.
19:43:07 <Eduard_Munteanu> Yeah, I think that's sort of what Data.List.Stream does too.
19:43:20 <twobitsprite> Eduard_Munteanu: I just wish we had hardware stack support and data types like the old lisp machines :P
19:43:28 <monochrom> perhaps base swallowed Data.List.Stream
19:43:46 <Eduard_Munteanu> Hm.
19:44:10 <monochrom> I haven't read that one
19:44:18 <jfischoff> dcoutts would know
19:44:43 <jfischoff> http://community.haskell.org/~duncan/thesis.pdf
19:45:03 <monochrom> no, stream fusion is something else
19:45:19 <jfischoff> he talks about stream fusion
19:45:22 <Eduard_Munteanu> monochrom: mm, fusion for streams instead of lists? :)
19:46:20 <Eduard_Munteanu> I mean, is it really that different?
19:46:27 <jfischoff> or are you saying stream fusion is different then foldr/build fusion (which I hear it is)?
19:46:38 <monochrom> "stream" involves this "data Step a s = Done | Yield a s | Skip s" thing
19:46:46 <Eduard_Munteanu> Oh.
19:47:18 <Eduard_Munteanu> So not just infinite lists.
19:49:44 <dolio> foldr (+) 0 (map f [x..y]) works like a charm except for overflowing the stack? :)
19:49:58 <monochrom> yeah :)
19:50:13 <monochrom> "but it doesn't touch the heap!"
19:50:34 <twobitsprite> ohh yeah... forgot there's no easy way to uninstall cabal packages... do I just rm the package from my ~/.cabal?
19:51:07 <monochrom> not just that. read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
19:51:35 <monochrom> in fact, read the whole thing. cabal is no longer a black box. you must know.
19:53:26 <twobitsprite> monochrom: will do, thanks :)
19:55:08 <twobitsprite> yay, it compiles now! :)
20:15:16 <whysocomplicated> Hi there... i am hoping that someone might be able to help.  I have a list of tuples that contain two strings and five integers in each tuple and I am trying to sort the tuples using the value of the 2nd string only, but not having much luck.
20:16:56 <Eduard_Munteanu> whysocomplicated: ok, where's the trouble, exactly?
20:16:56 <tromp> :t sortBy
20:16:58 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
20:17:08 <Ralith> Enigmagic: you around?
20:17:12 <tromp> :t on
20:17:14 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:17:35 <Ralith> whysocomplicated: I might apply your name to your tuples.
20:18:03 <Ralith> perhaps you would be better served to define a record type with its own Ord instance?
20:18:20 <tromp> try sortBy (comparing `on` \(_,a,_,_,_)->a) ?!
20:18:38 <whysocomplicated> not able to use a record type unfortunately...
20:18:50 <whysocomplicated> i have declared my own type called student
20:18:54 <whysocomplicated> which is a tuple
20:19:03 <whysocomplicated> that includes all the details for that student
20:19:13 <whysocomplicated> i also have a function called a getstudents
20:19:20 <whysocomplicated> which takes as input a list of students
20:19:23 <monochrom> what is the exact code for your student type?
20:19:29 <whysocomplicated> now i need to sort that list by surname
20:19:45 <whysocomplicated> which is the 2nd string value in each tuple that is a student
20:20:12 <whysocomplicated> type Student = (String, String, Int, Int, Int, Int, Int, Int)
20:20:48 <monochrom> the 2nd String is surname? then what tromp says
20:21:25 <monochrom> also I see 6 Int's, not 5
20:21:48 <monochrom> do you see why I just don't believe programmer's English?
20:21:51 <ryant5000> are there any haskell-based charities?
20:22:00 <whysocomplicated> ok.. i did the following:  sortBy (compare 'on' snd) getStudents
20:22:16 <ryant5000> a non-profit for the promotion of the language or something like that
20:22:21 <monochrom> snd is good for (x,y) only. not (x,y,z,a,b,c,d,e,f)
20:22:30 <whysocomplicated> sorry my bad... it is actually 6
20:22:49 <whysocomplicated> ok so what should I use now??
20:23:06 <monochrom> what tromp says. (for the 3rd time)
20:24:01 <ab9rf> ryant5000: i'm a haskell-based charity!
20:24:09 <ryant5000> haha
20:24:11 <Clint> ryant5000: i'm not sure this answers your question, but you can donate to "haskell.org" through spi-inc.org
20:24:24 <whysocomplicated> sorry monochrom... already used on and it didn't work...
20:24:38 <ab9rf> whysocomplicated: did you use `on` or 'on'?
20:25:03 <whysocomplicated> should i enter the whole line in the command line in Winhugs or can I write this in my script directly
20:25:03 <monochrom> @type comparing
20:25:04 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:25:19 <ab9rf> winhugs?  you're using winhugs?
20:25:31 <whysocomplicated> I know about the types.. I just need to write the function!
20:25:40 <monochrom> I see, don't include `on`. sortBy (comparing (\(_, a, _, _, _, _, _, _) -> a))
20:26:00 <ab9rf> @type on
20:26:02 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:26:02 <Eduard_Munteanu> Winhugs deserves no hugs.
20:26:18 <monochrom> the @type was for myself
20:26:24 <cmccann> more like LOSEhugs amirite
20:26:43 <Eduard_Munteanu> Indeed. :)
20:26:46 <cmccann> wow my code is spending about 50% of its time in GC :T
20:27:02 <Eduard_Munteanu> I guess it's not really green code.
20:27:54 <monochrom> what's wrong with winhugs?
20:28:12 <ab9rf> cmccann: union garbage colletors?
20:28:13 <Eduard_Munteanu> monochrom: nothing in itself, it's just stale and rotten
20:30:31 <whysocomplicated> monochrom..... look sorry for the confusion but your suggestion didn't work...I need to write a function that I can use to sort my whole list of students by surname in a haskell script.
20:32:19 <cmccann> hm turning off heap profiling reduced the GC time by about 20%. that is probably a sign the trivial test code is skewing things by not having anything interesting to think about other than allocating.
20:32:54 <cmccann> whysocomplicated: I am pretty sure that monochrom's suggestion works just fine if you use it correctly.
20:33:09 <cmccann> also "doesn't work" is completely uninformative.
20:33:39 <ab9rf> well, not _completely_ :)
20:33:46 <whysocomplicated> cmccann - i am sure your probably right but could you then suggest how exactly I should be using this code in my Haskell script..
20:34:14 <whysocomplicated> again... I apologies.. I am learning and my explanation about not working meant that it didn't give me the correct results... I received an error
20:34:15 <ab9rf> is there a paste for this discussion?
20:34:21 <cmccann> no, I'm kinda busy
20:34:44 <whysocomplicated> cmccann... apppreciate your time.. thank you
20:34:51 <monochrom> here is a smaller example
20:35:44 <monochrom> > sortBy (comparing (\(_, a, _) -> a)) [ ("kitty", "hello", 5), ("jonny", "english", 6), ("mono", "chrome", 7) ]
20:35:45 <cmccann> whysocomplicated: btw, you'll probably have better luck with the advice given by monochrom if you put more thought into *why* something does or does not work.
20:35:46 <lambdabot>   [("mono","chrome",7),("jonny","english",6),("kitty","hello",5)]
20:36:10 <cmccann> monochrom: it seems you've misspelled "chrom"!
20:36:11 <ab9rf> without seeing code it's hard to offer much insight on why it 'doesn't work'
20:36:32 <monochrom> I have shown my share of working code. now I am afk.
20:36:56 <Enigmagic> Ralith: yeah
20:37:04 <ryant5000> who runs haskell.org?
20:37:08 * ab9rf is starting to wonder if this is a thirsty equine issue
20:37:17 <Ralith> Enigmagic: some time ago you volunteered to work on the high-level LLVM bindings
20:37:28 <Ralith> Enigmagic: are you still willing?
20:37:40 <Enigmagic> Ralith: yeah
20:38:40 <Ralith> Enigmagic: I have the commit bit and no idea what to do with the high level bindings. There are a million forks all doing various things. Now would be a good time to start sorting it out
20:38:47 <whysocomplicated> thanks for that monochrom i do appreciate your help... I understand how to use the sortby function on the command line in WinHugs however I need to write the function to sort my entire list of students by surname in my Haskell script.
20:38:48 <Ralith> are you on the haskell-llvm mailing list?
20:38:54 <Ralith> whysocomplicated: why can't you use a record type?
20:39:22 <Enigmagic> Ralith: i have commit access too, just been slammed for a few weeks. i can start piecing things together this weekend.
20:39:25 <whysocomplicated> I have to use tuples and my own type unfortunately...
20:39:51 <Eduard_Munteanu> whysocomplicated: what's next then?
20:40:04 <Ralith> Enigmagic: oh, are you the other guy who volunteered?
20:40:09 <Enigmagic> yes
20:40:10 <Ralith> awesome
20:40:23 <Ralith> in that case, refer to my post on the ML
20:41:15 <Enigmagic> will do
20:42:26 <realitygrill> good lord
20:42:48 <realitygrill> which lens libraries should i use?
20:42:59 <Ralith> lens
20:43:00 <Clint> lens
20:43:01 <cmccann> all of them
20:43:05 <cmccann> at once
20:43:06 <ab9rf> hey
20:43:09 <ab9rf> i was going to say that
20:43:27 <realitygrill> iirc didn't lens change like.. 3x in the past 6 months?
20:43:29 <mgsloan> realitygrill: If lens looks too scary, I was always partial to fclabels back in the day
20:43:29 <lambdabot> mgsloan: You have 1 new message. '/msg lambdabot @messages' to read it.
20:43:32 <realitygrill> or something..
20:43:39 <realitygrill> hmm
20:43:39 <realitygrill> ok
20:43:50 <cmccann> lens is good if you want more expressive data accessors in general
20:44:02 <mgsloan> And then you can later dip into the full awesomeness of lens :)
20:44:09 <cmccann> if you really just want bare-bones lenses and nothing more it doesn 't matter that much which you use
20:44:10 <Ralith> realitygrill: most of the changes seem to concern the deep internals and more arcane uses
20:44:15 <Ralith> realitygrill: also, better rapidly changing than dead.
20:44:20 <realitygrill> true
20:44:32 <cmccann> lens really is nice once you get the hang of the basics though
20:44:37 <realitygrill> having sat through a lens talk or two, must admit was a bit intimidated
20:44:50 <whysocomplicated> Ok.. another much friendlier Haskell community helped me sort this out... appreciate your time monochrom..
20:46:05 <Eduard_Munteanu> ...
20:46:23 <realitygrill> much friendlier? ouch
20:46:27 <cmccann> in other words someone gave him code to use that he didn't need to understand
20:46:31 <cmccann> sigh
20:47:00 <Eduard_Munteanu> I had a feeling it was homework or something like that.
20:47:07 <cmccann> yes, clearly
20:47:24 <cmccann> that sort of "I need to use ___" restriction with no explanation is almost always homework
20:47:27 <h4199> Only homework could be that arbitrary
20:47:40 <Eduard_Munteanu> Ah, I guess I missed that.
20:47:41 <realitygrill> the restriction on using tuples and own type, more of a tipoff
20:47:41 <Eduard_Munteanu> Heh.
20:48:02 * Eduard_Munteanu is probably slow to catch on :P
20:48:27 <Eduard_Munteanu> Nothing sleep can't fix... *out*
20:51:47 <realitygrill> hmm. what does "make a Getter out of a pure function with 'to'" mean?
20:52:22 <realitygrill> hell, what's a Getter?
20:53:00 <realitygrill> (i get the basic idea of a getter, but considering i don't understand this sentence i think i am missing something)
20:53:03 <Ralith> realitygrill: not a thing you need to worry about initially.
20:53:13 <realitygrill> hm. k
20:55:49 <ab9rf> there's a friendlier haskell community?  where?
20:56:09 <realitygrill> they must have ponies
20:56:18 <ab9rf> it was fairly obvious that that was homework
20:56:21 <ab9rf> especially using Hugs
20:56:44 <realitygrill> oh, i missed that
20:56:51 <ab9rf> sadly, the poor guy isn't learning anything
20:57:01 <ab9rf> except how to scam for homework answers on the internet
20:57:36 <Clint> a useful skill in the workplace
20:57:49 <realitygrill> hm. a school that teaches haskell?
20:58:07 <ab9rf> realitygrill: it's not that uncommon for haskell to appear somewhere in a CS curriculum
20:58:21 <realitygrill> hmm... ok
20:58:37 <ab9rf> Clint: sadly, yes
21:05:41 <realitygrill> what's this '' i see sometimes? is that TH?
21:07:29 <mikeplus64> realitygrill: yeah, it is to turn something into a TH usable "name"
21:18:12 <Krimi> Hey I wrote a tree fold operation for an assignment, the next question is to pass it a function that will compute the hight of the tree, I really have no idea how to go about this (passing functions & currying confuses the hell out of me). Would anyone be able to steer me in the right direction? http://hpaste.org/86619
21:19:55 <ab9rf> eh, rose trees
21:20:22 <parcs> @where e
21:20:22 <lambdabot> I know nothing about e.
21:21:06 <ab9rf> > fix error
21:21:08 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:21:50 <ab9rf> Krimi: what part are you stuck on?
21:22:20 <copumpkin> > fix show
21:22:22 <luite> Krimi: the height of the whole tree is one plus the maximum of the height of the children of the root node
21:22:22 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:22:27 <ab9rf> Krimi: you seem to hve figured out how to count the nodes
21:23:00 <Krimi> i have but i sort of just got lucky, im not exactly sure how it works
21:23:05 <ab9rf> computing the height is not really that much different, instead of 1 + sum, it's 1 + max
21:23:13 <realitygrill> mikeplus64: cool. how do i turn on TH? (looking up also)
21:23:39 <ab9rf> Krimi: well, a lot of my early haskell code was 'debugged by mutation' :)
21:24:13 <mikeplus64> realitygrill: with {-# LANGUAGE TemplateHaskell #-} at the top of your code
21:24:22 <mikeplus64> realitygrill: or compile with -XTemplateHaskell
21:24:26 <realitygrill> oh
21:24:26 <realitygrill> hmm
21:24:29 <realitygrill> okay, thanks
21:24:42 <pygmalion> So I'm using cabal to build a project for the first time and have a maddening issue. I have some source files in a subdirectory called Common, each containing a module named Common.Something (where Something varies obviously). cabal insists that the file names and module names don't match but then when I change the modules to not include Common, cabal insists that the module names don't match the filenames. Am I crazy?
21:24:44 <ab9rf> Krimi: the only partial application i see is in the defintion of treeFold itself
21:24:54 <Krimi> what do you mean?
21:25:03 <ab9rf> in the map, treeFold is partially applied
21:25:12 <ab9rf> Krimi: i'm not sure why you'are asking about currying
21:25:21 <pygmalion> Including the directory with "hs-source-dirs: ".", "Common"
21:25:31 <Krimi> im just confused about the sum function that passed
21:25:37 <Krimi> in the previous two questions
21:25:45 <Krimi> what exactly is it being called with
21:25:58 <Krimi> empty lists?
21:26:04 <Krimi> I have no idea how my code works T_T
21:26:27 <ab9rf> Krimi: it's passed two arguments: the value on eaeceh node, and a list of the results of applying that function to the children of that node
21:26:38 <cmears> Krimi, the "ys" argument is the result of calling treeFold over the children of that node
21:27:00 <Krimi> oooh
21:27:22 <Krimi> so whats x?
21:27:34 <ab9rf> Krimi: x and ys are arbitrary placeholders
21:27:52 <ab9rf> Krimi: the first argument is the value in the root of the tree
21:27:55 <eyebloom> @Djinn ((g -> a -> (g, b)) → g → c → (g, d)) → (g → a → b → c→ (g, d))
21:27:55 <lambdabot> No output from Djinn; installed?
21:28:19 <copumpkin> use real arrows
21:28:44 <eyebloom> Thank you. My apologies.
21:28:52 <copumpkin> :)
21:29:00 <ab9rf> it took me  awhile to figure out why the function was a -> [b] -> b
21:29:13 <Rotaerk> there an efficient way to remove a Set of keys from a Map?
21:29:33 <copumpkin> not that I know of
21:29:51 <ab9rf> Rotaerk: not any beter than just removing them serially
21:30:06 <Rotaerk> hmm k
21:30:56 <djahandarie> > elemIndicies '"' (fix show)
21:30:58 <lambdabot>   Not in scope: `elemIndicies'
21:30:59 <lambdabot>  Perhaps you meant one of these:
21:30:59 <lambdabot>    `elemIndic...
21:31:07 <djahandarie> > elemIndices '"' (fix show)
21:31:11 <lambdabot>   mueval-core: Time limit exceeded
21:31:18 <djahandarie> > take 5 $ elemIndices '"' (fix show)
21:31:20 <lambdabot>   [0,2,6,14,30]
21:31:30 <djahandarie> > take 8 $ elemIndices '"' (fix show)
21:31:32 <lambdabot>   [0,2,6,14,30,62,126,254]
21:31:45 <ab9rf> djahandarie: i sense a pattern
21:31:49 <djahandarie> > take 8 . map (+2) $ elemIndices '"' (fix show)
21:31:51 <lambdabot>   [2,4,8,16,32,64,128,256]
21:32:13 * Rotaerk mind blown *
21:32:58 <copumpkin> oh that's a cuter way than the approach I posted on twitter
21:33:04 <copumpkin> I didn't even know about elemIndices
21:33:09 <djahandarie> > take 8 . map((\x -> log x / log 2) . fromIntegral) . map (+2) $ elemIndices '"' (fix show)
21:33:12 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0]
21:33:14 <ab9rf> djahandarie: probably one of the strangest ways i've seen yet to genereate powers of two
21:35:54 <djahandarie> I'm somewhat surprised there is no integer base-2 logarithm anywhere in the platform.
21:37:38 <copumpkin> djahandarie: there's unsafeCoerce, right? just implement http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float
21:40:02 <djahandarie> copumpkin, what'd you do on Twitter by the way? I didn't see it.
21:40:06 <djahandarie> Something like this?
21:40:14 <djahandarie> > unfoldr (\xs -> fmap (\x -> (x, drop (x+1) xs)) $ elemIndex '"' xs) $ fix show
21:40:17 <lambdabot>   mueval-core: Time limit exceeded
21:40:25 <djahandarie> > take 8 $ unfoldr (\xs -> fmap (\x -> (x, drop (x+1) xs)) $ elemIndex '"' xs) $ fix show
21:40:28 <lambdabot>   [0,1,3,7,15,31,63,127]
21:40:40 <copumpkin> https://twitter.com/copumpkin/status/321469983332892674
21:40:58 <djahandarie> Ah, heh.
21:41:13 <Hermit> djahandarie: what about logBase
21:41:51 <djahandarie> It's not an integer logarithm
21:44:15 <Krimi> ab9rf: I tried 1+maximum, but I got the error Prelude.maximum: empty list
21:48:50 <ab9rf> :t maximum
21:48:53 <lambdabot> Ord a => [a] -> a
21:49:28 <ab9rf> Krimi: a leaf with no children has an empty child list.  you have to deal with that
21:50:02 <Krimi> il give it a shot
21:50:22 <ab9rf> Krimi: you could just prepend ys with 0
21:50:34 <ab9rf> maximum (0:ys) instead of maximum ys
21:51:41 <Krimi> what does that do?
21:52:12 <ab9rf> Krimi: it adds a 0 to the front of the list, so if the list is empty it taks the maximum of a list containing just 0, which is 0
21:52:26 * applicative_tmp is trying to prove a theorem, for every way of calculating powers of 2 in Haskell there is a much much worse one
21:52:27 <ab9rf> Krimi: a height will never be negative so if there are children it doesn't affect the result
21:52:27 <Krimi> ooh
21:52:58 <liyang_> applicative_tmp: worse by a factor of 2?
21:53:45 <applicative_tmp> liyang is my conjecture already coming to grief?
21:53:55 <applicative_tmp> I haven't made it precise yet!
21:54:39 <ab9rf> @src maximum
21:54:40 <lambdabot> maximum [] = undefined
21:54:40 <lambdabot> maximum xs = foldl1 max xs
21:55:10 <ab9rf> you could also use 'foldl max 0 ys', but really that's essentially the same thing
21:55:36 <ab9rf> why is maximum defined with foldl and not foldr?
21:56:48 <applicative_tmp> kinda freaky, huh.  but then why is foldl' not properly strict either?
21:56:48 <antoine__> hi all
21:56:58 <applicative_tmp> hi antoine__
22:02:22 <applicative_tmp> ab9rf: hm, it seems that a rule replaces minimum with strictMinimum for [Int] and [Integer], though.  of course strictMinimum is defined with the not actually strict foldl'
22:02:41 <applicative_tmp> and likewise with maximum
22:03:11 <applicative_tmp> @src foldl'
22:03:11 <lambdabot> foldl' f a []     = a
22:03:11 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:05:03 <ab9rf> applicative_tmp: i wonder if max and min are eager
22:09:42 <lispy> ?src max
22:09:42 <lambdabot> max x y = if x <= y then y else x
22:10:17 <lispy> ab9rf: It depends on how (<=) works
22:10:27 <ab9rf> yeah
22:10:35 <ab9rf> which i don't know offhand
22:10:41 <ab9rf> probably is for Int
22:10:43 <lispy> and (<=) will (in almost all cases) have to force x and y
22:11:28 <ab9rf> lispy: not copletely for [a], it only has to evaluate until a difference is found
22:11:39 <ab9rf> > [2..] < [1..]
22:11:40 <lambdabot>   False
22:12:04 <lispy> > [2..] < [undefined]
22:12:05 <lambdabot>   *Exception: Prelude.undefined
22:12:32 <lispy> > [2..] < [1]
22:12:35 <lambdabot>   False
22:12:38 <lispy> > [2..] < (1:undefined)
22:12:40 <lambdabot>   False
22:13:10 <ab9rf> > [2..] < [2..]
22:13:14 <lambdabot>   mueval-core: Time limit exceeded
22:14:08 <ab9rf> @src (<=)
22:14:09 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
22:14:22 <ab9rf> ha
22:14:31 <lispy> @src compare
22:14:31 <lambdabot> compare x y | x == y    = EQ
22:14:32 <lambdabot>             | x <= y    = LT
22:14:32 <lambdabot>             | otherwise = GT
22:14:55 <ab9rf> @src (<=) Int
22:14:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:15:00 <ab9rf> @src Int (<=)
22:15:01 <lambdabot> Source not found. Are you on drugs?
22:15:07 <lispy> @src (==)
22:15:08 <lambdabot> x == y = not (x /= y)
22:15:14 <lispy> @src (/=)
22:15:14 <lambdabot> x /= y = not (x == y)
22:15:18 <lispy> so many loops
22:20:02 <krzysz00> @src (+)
22:20:02 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:25:34 <Rotaerk> :t (.~)
22:25:36 <lambdabot> ASetter s t a b -> b -> s -> t
22:29:07 <Rotaerk> :t listArray
22:29:09 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
22:32:05 <Rotaerk> > foldr (.) id (fmap ((.~ 1) . ix) [2,3,4]) $ listArray (0,5) (repeat 0)
22:32:08 <lambdabot>   array (0,5) [(0,0),(1,0),(2,1),(3,1),(4,1),(5,0)]
22:32:30 <Rotaerk> hmm is there an easier way to do that
22:36:58 <applicative> > foldl' (flip const) undefined [1]
22:37:01 <lambdabot>   1
22:37:26 <applicative> ab9rf: there ^^^
22:37:41 <ab9rf> applicative: what does that demonstrate?
22:38:05 <applicative> that foldl' isn't strict
22:38:12 <ab9rf> applicative: ah, yes
22:38:55 <applicative> so neither is strictMaximum for example, or anyway, the compiler cant see it
22:39:26 <applicative> i mean, the definition is defective
22:40:18 <applicative> admittedly you're not supposed to use an operation like const with a would be strict left fold anyway
22:40:46 <Rotaerk> hmm I think what i want is something that turns a list of setters into a single setter
22:41:01 <ab9rf> irish setter
22:45:09 <applicative> > let foldll op a xs = loop a xs where loop !a [] = a; loop a (x:xs) = let !a' = op a x in  loop a' xs in foldll (flip const) undefined [1]
22:45:11 <lambdabot>   *Exception: Prelude.undefined
22:45:44 <applicative> ^^^ I think thats the intended definition of foldl'
22:46:49 * hackagebot github 0.7.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.7.0 (JohnWiegley)
22:52:23 <Rotaerk> oh, I'm dumb... can just do it simpler with (//) >_>
22:54:37 <XexonixXexillion> can I derive Ord if the data type is defined in another file?
22:55:59 <applicative> XexonixXexillion: its a little alarming, but you can use StandaloneDeriving
22:56:37 <applicative> Or am I wrong?   you would write at the top level deriving instance Ord ForgotOrd
22:57:09 <applicative> Or   deriving instance Ord a => Ord (ForgotOrd a) or whatever
22:57:36 <XexonixXexillion> I can't do that... I can't use language extensions
22:58:36 <Ralith> XexonixXexillion: why not?
23:00:52 <XexonixXexillion> It's being run on a server that filters anything between {-# and #-} out before compiling it
23:01:57 <applicative> wow, a Haskell 98 server
23:02:18 <XexonixXexillion> is that valid haskell 2010?
23:03:04 <arkeet> no
23:03:06 <applicative> oh, i meant no extensions, not sure how to put it now....
23:05:40 <applicative> I think you're lost XexonixXexillion but maybe you should just define the type for yourself? or is it from a giant library?
23:06:50 * hackagebot io-choice 0.0.3 - Choice for IO and lifted IO  http://hackage.haskell.org/package/io-choice-0.0.3 (KazuYamamoto)
23:06:52 * hackagebot mighttpd2 2.8.4 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.4 (KazuYamamoto)
23:06:53 <XexonixXexillion> It's just me being lazy and not wanting to write a real hashing function
23:07:05 <applicative> if you define your own Ord instance (or StandaloneDerive it) it will be an 'orphan', so, if your neighbot has the same problem, when I import from both of you it will be unpleasant, but not as unpleasant as writing C
23:07:35 <applicative>  neighbor or neighbot
23:09:12 <sw2wolf> @hoogle orphan
23:09:13 <lambdabot> No results found
23:10:26 <sw2wolf> @ty choice
23:10:28 <lambdabot> Not in scope: `choice'
23:16:50 * hackagebot hlibgit2 0.18.0.5 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.5 (JohnWiegley)
23:40:55 <Rotaerk> seems to me there should be a function like (a->b)->a->(a,b)  or  (a->b)->a->(b,a)  but hoogle doesn't find
23:41:39 <arkeet> there is, if you write it!
23:42:08 <carter> Rotaerk you mean like  \f -> \a -> (a,f a)
23:42:13 <arkeet> :t ap (,)
23:42:14 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
23:42:30 <Rotaerk> :t ap
23:42:32 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:42:41 <Rotaerk> ah neat; thanks
23:42:45 <Nisstyre-laptop> @djinn (a->b)->a->(a,b)
23:42:45 <lambdabot> f a b = (b, a b)
23:42:47 <shachaf> @ty (id &&&)
23:42:48 <lambdabot> (c -> c') -> c -> (c, c')
23:42:53 <arkeet> that works too
23:43:06 <arkeet> that's better actually.
23:43:07 <Rotaerk> :t (&&&)
23:43:08 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
23:43:59 <Rotaerk> thanks; writing it would be easy, I just try to find existing solutions when it seems so generic and reusable that it HAS to exist already...
23:45:41 <sw2wolf> Now i know Control.Arrow, Control.Monad,Control.Applicative,  what's the usage of Control.Lens ?
23:45:47 <mm_freak> :t liftA2 (,) id
23:45:49 <lambdabot> (a -> b) -> a -> (a, b)
23:46:25 <mm_freak> sw2wolf: functional references, i.e. "pointers" into data structures
23:46:30 <Nisstyre> @pl f a b = (b, a b)
23:46:31 <lambdabot> f = ap (,)
23:47:30 <sw2wolf> mm_freak: thanks
23:47:46 <sw2wolf> @package Control.Lens
23:47:46 <lambdabot> http://hackage.haskell.org/package/Control.Lens
23:47:57 <mm_freak> @hackage lens
23:47:57 <lambdabot> http://hackage.haskell.org/package/lens
23:51:51 * hackagebot ghc-core-html 0.1.1 - Core to HTML display  http://hackage.haskell.org/package/ghc-core-html-0.1.1 (VincentHanquez)
