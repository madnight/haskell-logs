00:43:36 <tsinnema> hey -- i've read some discussion on record types that end up giving up row polymorphism and i believe someone said on #haskell that it is 'teh hard'. what are some of the problems that come up?
00:44:04 <tsinnema> i.e. problems with row polymorphism
00:44:44 <AfC> tsinnema: have you read the paper on van heuven lenses? Anyway, Edward Kmett's lens work pretty much subsumes the problem space.
00:45:27 <tsinnema> AfC, no, i hadn't -- also didn't know of such an aspect of lenses
00:45:35 <tsinnema> i'll look those up, thanks
00:46:14 <AfC> I may have spelled that wrong. Anyway, they're polymorphic. And, s/paper/blog post/ in all possibility
00:46:33 <tsinnema> ok
00:48:58 <tsinnema> AfC, atm i'm having trouble finding the lens stuff you referred to -- google magic fails to correct the spelling it seems
00:56:30 <Kinnison> tsinnema: start at lens.github.com and go from there
00:56:49 <Kneiva> maybe this: http://comonad.com/reader/2012/mirrored-lenses/
00:56:56 <quchen> I'm having problems with Exceptions. Due to their nature, they're hard to catch in custom types; I always have to lift around some form of IO for that. What do you guys think of converting IO-based Exceptions to Either-based ones using some form of catchall? I feel like an EitherT IO would give me much more control.
00:57:48 <Kinnison> quchen: I'd suggest ErrorT IO
00:58:02 <Kinnison> quchen: and then you can use throwError with your error type
00:58:32 <Kinnison> quchen: I've done that in the past when I wanted to do error handling with a custom error type
00:58:36 * hackagebot raw-strings-qq 1.0.2 - Raw string literals for Haskell.  http://hackage.haskell.org/package/raw-strings-qq-1.0.2 (MikhailGlushenkov)
00:59:16 <quchen> Eh, ErrorT is what I meant
00:59:58 <quchen> Kinnison: I'd have a couple of blocks of the form "readFile f `catchAllToEither` blabla" then I assume?
01:00:36 <quchen> i.e. manually wrap everything that should fail as a unit in ErrorT
01:00:41 <Kinnison> I think I was using try to turn it into an Either IOError a
01:00:57 * Kinnison can't recall clearly and doesn't have the code to hand
01:01:17 <quchen> That sounds like what I had in mind. Good to know someone has done it already and it was useful. :-)
01:02:30 <tsinnema> Kinnison, thanks
01:02:46 <Kinnison> and now for breakfast
01:02:59 <tsinnema> happy eatings
01:03:26 <tsinnema> AfC, might 'van laarhoven' be what you were recalling?
01:05:16 <AfC> tsinnema: yeah, that sounds about right
01:06:04 <mgsloan> tsinnema: Yeah, because twan wrote a blog post about the idea first.  "Van Laarhoven" is a pretty awesome academic title for something, though, I hope it sticks for centuries
01:06:42 <AfC> {chortle}
01:07:15 <mgsloan> (because clearly our programming for the next few centuries will be shaped by lenses ;) )
01:10:05 <luite> mgsloan: that's why i added a lens example: http://hdiff.luite.com/reduce/lens/
01:10:33 <mgsloan> luite: Hahaha, oh man, that's awesome!
01:11:22 <Kinnison> tsinnema: thanks, I have porridge with chocolate bits. nommy
01:11:38 <mgsloan> luite: It's still crazy to me that you can run polymorphic code in the browser.  I'm still used to Fay's monomorphism
01:11:41 <Saizan> luite: no way to associate some definition to the thunks?
01:13:02 <mgsloan> luite: The printing out of what the dictionary is is nice! I didn't notice that before
01:13:19 <luite> mgsloan: oh I added that later
01:13:46 <luite> and removed all the fields from the graph, since that clutters the one for lens a lot
01:13:52 <luite> the dictionary fields
01:14:28 <luite> Saizan: they do have names, but they're automatically generated, so not very useful
01:14:36 <luite> perhaps some SrcLoc can be used, dunno
01:14:53 <luite> Saizan: that's not yet in the generated code
01:16:35 <cads> luite: I'm going to attempt to implement a bitcoin/litecoin exchange service this summer
01:16:43 <cads> the trading core will be written in haskell
01:17:20 <cads> do you think I should really start learning lenses with the intent of using them in the project?
01:18:05 <cads> since the probject could be doing some bidirectional data transformations, it could be conceptually useful
01:18:59 <cads> luite: its also okay if you don't wish to speculate on what would be a good personal choice for me to make
01:19:13 <luite> cads: could be useful, but if you're not doing manipulation of deep data structures it might not gain you that much
01:19:34 <cads> nothing very deep
01:20:03 <luite> still they have some interesting concepts and many things are quite simple with them, even if you don't know the details
01:20:58 <luite> so if you're comfortable with typeclasses and Foldable, Traversable, Functor, Applicative from base, give them a go
01:21:25 <cads> I can use functor, lol
01:21:40 <cads> but sure, I'll play around
01:22:10 <cads> I have about a month before I expect my team-mate's ruby reference implementation to appear
01:22:48 <cads> I think haskell could be a good engine for executing orders very quickly
01:28:37 * hackagebot besout 0.2.0.0 - Extended GCD of polynomials over F_p[x]  http://hackage.haskell.org/package/besout-0.2.0.0 (AbdelwahebMiled)
01:30:02 <sdodson1> Hello. Is this an appropriate place to ask beginning Haskell questions?
01:30:16 <sw2wolf> sure
01:31:55 <sdodson1> Great! Would you please explain what an underscore is used for? I thought I could find the last element of a list with let {myLast [x] = x; myLast [x:xs] = myLast xs}, but I need to replace the [x:xs] with (_:xs). Why is this?
01:32:23 <sipa> you don't have to
01:32:57 <sipa> but _ means an argument that is pattern-matched but not bound to any variable, so it is great for ignoring parts
01:33:11 <sipa> perhaps the compiler warned you that x was not used?
01:33:17 <sdodson1> Okay. So the output from ghci was only a warning?
01:33:29 <sipa> i assume so
01:33:29 <sdodson1> Yes; I think you are right.
01:34:11 <sdodson1> Thank you, sipa, for the explanation.
01:34:15 <sipa> you could also use _x if you still want a 'descriotive' name but one that will not produce a warning
01:34:21 <sipa> descriptive
01:34:41 <sdodson1> Is it better practice to use an underscore?
01:35:41 <ryant50001> sdodson1: yeah, if you're not going to use the variable, it's usually best to just use an underscore
01:35:43 <danr> sipa: will _x give a warning if you actually use it though?
01:36:04 <sipa> danr: unsure
01:36:05 <sdodson1> Thanks, ryant50001.
01:36:11 <ryant50001> sdodson1: no problem
01:37:25 <danr> sipa: it doesn't seem like it from a small test I did =/
01:37:40 <ryant50001> sipa, danr: i just checked in GHCi 7.6.2; unused names starting with underscore don't seem to cause a warning
01:37:47 <ryant50001> (but unused names that don't start with an underscore do)
01:38:14 <danr> ryant50001: that's true, but it also seems that used variable names starting with underscores don't yield a warning!
01:38:17 <danr> I would have suspected otherwise
01:38:18 <joker_89> hi
01:38:27 <Eduard_Munteanu> joker_89: hi
01:38:46 <danr> oh well. there might be occasions where it is actually reasonable to name something starting with an underscore
01:38:50 * danr looks at the lens library
01:38:53 <ryant50001> danr: well, names that just begin with an underscore are valid names
01:39:05 <ryant50001> danr: i'm kind of surprised that they suppress the warning, actually
01:39:26 <joker_89> i have a list of lists like [[Element]] where are 4 lists inside, and then i have a list [Element] of 4 elements. I want to add each of the 4 elements to their respective list.
01:39:28 <danr> ryant50001: I find it quite useable
01:39:48 <danr> I always use -Wall, and sometimes I want to remember what a variable is even thought I'm not going to use it (I might use it later)
01:40:16 <joker_89> so: first element to the first list, second element to the second list... 4th element to the 4th list
01:40:17 <Eduard_Munteanu> :t zipWith (:)
01:40:18 <lambdabot> [a] -> [[a]] -> [[a]]
01:40:27 <ryant50001> danr: hm; i haven't run into that
01:40:40 <joker_89> Eduard_Munteanu for me?
01:40:43 <Eduard_Munteanu> joker_89: yes
01:41:06 <quchen> sipa, danr: Haskell report page 10: Underscore alone is a reserved identifier for wildcard patterns. For any other use it's a letter, although clients "are encouraged" not to issue unused variable warnings for identifiers starting with "_".
01:41:06 <joker_89> oh no sorr, remove, not add
01:41:20 <joker_89> remove each element of each respective list
01:41:46 <danr> ryant50001: maybe not. I grepped through some of my code and I actually never uses it
01:41:51 <danr> s/uses/use/
01:41:56 <danr> quchen: aha, thanks
01:42:34 <Eduard_Munteanu> joker_89: same idea basically, just figure out how to remove an element from a list
01:42:52 <sipa> quchen: thanks
01:43:25 <sdodson1> Here's a second quick question: I tried let {myLast [x] = x; myLast [_:xs] = myLast xs} and ghci gave me a warning that it expected a list within a list, [[t0]], but the actual type was [t0]. Why would my code produce a list within a list? Am I reading the warning incorrectly? Should I use a tuple (_:xs) instead of a list [_:xs]. Thanks again for your help.
01:44:12 <sipa> [a,b] is syntactic sugar for (a:(b:[]))
01:44:46 <Cale> sdodson1: [_:xs] is a list with one element whose only element is a nonempty list whose tail is xs
01:44:54 <quchen> sdodson1: (_:xs) is a list (the parentheses are just parentheses like in (1+2)*3). [_:xs] is a list containing a list.
01:45:37 <quchen> sdodson1: Unless you're matching a list of a known size, such as [x], I don't think you ever use [...] in patterns.
01:45:42 <sdodson1> Cale and quchen: Oh! I got it. Thanks!
01:46:17 <quchen> sdodson1: I remember making that mistake myself. I think everyone did at some point ;-)
01:47:23 <sdodson1> quchen: Thanks; I appreciate your help.
01:58:38 * hackagebot hen 0.0.3 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.0.3 (FedorGogolev)
02:00:03 <xpika> does anyone know if haskell can be compiled to asm.js?
02:01:28 <ryant50001> xpika: i'm not sure, but the guys in #ghcjs are working on compiling it to regular javascript
02:01:52 <Kinnison> presumably once one has JS one can compile that to asm.js
02:03:38 * hackagebot binary-file 0.14.3 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.14.3 (YoshikuniJujo)
02:07:11 <alpounet> xpika, you should ask luite about these stuffs
02:10:13 <joker_89> Eduard_Munteanu but if i want to do all in one?
02:10:25 <Eduard_Munteanu> joker_89: what do you mean?
02:10:46 <joker_89> all 4 lists and the list of 4 elements to remove of each list
02:11:35 <Eduard_Munteanu> joker_89: remove the 4 elems from each of the 4 lists?
02:11:45 <joker_89> yes
02:11:51 <Eduard_Munteanu> Just use 'map' then.
02:15:30 <joker_89> but using a map
02:16:39 <joker_89> i have 2 lists, not 1 Eduard_Munteanu
02:17:39 <Lethalman> joker_89, transpose?
02:18:03 <Lethalman> > transpose [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
02:18:05 <lambdabot>   [[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
02:18:35 <neena> ~,
02:18:36 <neena> ~>
02:18:41 <Lethalman> ah "remove"
02:18:42 <neena> ~<
02:19:02 <joker_89> yes remove
02:19:47 <typoclass> joker_89: i think it'd help if you could give us an example input, and the desired output. (please use hpaste.org if it's > 1 line)
02:20:02 <Eduard_Munteanu> joker_89: if you map over the lists of lists, then you can combine each of those lists with the list of the elements you want to remove
02:21:14 <Eduard_Munteanu> joker_89: so figure out how to remove multiple elements from a single list first
02:23:59 <joker_89> an example removeElements [[A,B,C],[G,S,D],[I,D,A],[Q,W,R]] [B,D,A,Q] = [[A,C],[G,S],[I,D],[W,R]]
02:27:05 <quchen> > let removeElements r = map (filter (`notElem` r)) in removeElements [1,4] [[1,2,3], [4,5,4], [3,2,1]]
02:27:07 <lambdabot>   [[2,3],[5],[3,2]]
02:27:12 <quchen> Something like that?
02:28:01 <quchen> joker_89: ^
02:28:14 <typoclass> joker_89: ok, so in the [I,D,A] list, only A is removed and D stays in
02:29:16 <danr> homework?
02:29:43 <Eduard_Munteanu> Possibly, I stopped giving the answer away at some point. :D
02:38:32 <typoclass> joker_89: you could start by using zipWith. this will walk through the two lists in parallel
02:39:04 <typoclass> > zip [0..] "lolcats" -- joker_89
02:39:05 <lambdabot>   [(0,'l'),(1,'o'),(2,'l'),(3,'c'),(4,'a'),(5,'t'),(6,'s')]
02:40:30 <meryy78> http://amateurgirlfuckedhard.blogspot.com/2013/04/the-best-amateur-and-pornstar-collection.html
02:45:57 <t7> wut
02:48:17 <typoclass> t7: it's random spam
03:07:03 <neothemachine> quick question, I somehow have the feeling that the following expression can be shortened: `if isNothing maxY1 || isNothing maxY2 then Nothing else max maxY1 maxY2` am I wrong?
03:07:49 <merijn> neothemachine: liftM2
03:07:53 <merijn> :t liftM2
03:07:54 <MasseR> neothemachine: if I'm not mistaken, (max) <$> maxY1 <*> maxY2
03:07:54 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:07:56 <MasseR> Or litM2
03:07:57 <quicksilver> liftA2 max maxY1 maxY2
03:08:20 <typoclass> > let maxY1 = Just 4 ; maxY2 = Nothing in max <$> maxY1 <*> maxY2 -- neothemachine: check this out
03:08:22 <lambdabot>   Nothing
03:08:24 <merijn> > liftM2 max Nothing (Just 5)
03:08:26 <lambdabot>   Nothing
03:08:32 <merijn> > liftM2 max (Just 4) (Just 5)
03:08:34 <lambdabot>   Just 5
03:09:08 <supki> > max Nothing Nothing
03:09:08 <neothemachine> definitely shorter, thanks!
03:09:09 <lambdabot>   Nothing
03:09:44 <merijn> The Maybe monad is your friend :)
03:10:06 <supki> > max (Just 4) (Just 5)
03:10:08 <lambdabot>   Just 5
03:10:10 <merijn> (and isNothing and isJust are almost always design flaws)
03:10:13 <merijn> oh, right
03:10:14 <typoclass> neothemachine: this requires the Maybe instance of Applicative (respectively, liftM2 needs the the Maybe instance for Monad). if you want to be more beginner-friendly, you can always do "case (maxY1, maxY2) of (Just y1, Just y2) -> Just (max y1 y2) ; _ -> Nothing"
03:10:20 <supki> so, that's just max maxY1 maxY2
03:10:31 <merijn> I guess there's "instance Ord a => Ord (Maybe a)" too
03:10:59 <neothemachine> > max Nothing (Just 4)
03:11:01 <lambdabot>   Just 4
03:11:19 <neothemachine> @supki should return nothing
03:11:19 <lambdabot> Unknown command, try @list
03:11:34 <supki> oh, then not
03:11:46 <quicksilver> merijn: isJust is a more reliable indicator than isNothing, but the killer is when they're coupled with fromJust.
03:11:50 <typoclass> merijn: yeah. it sounds a bit weird, doesn't it
03:12:29 <quicksilver> the Ord instance is the same one you'd get if you wrote Maybe yourself and had 'deriving Ord' on it.
03:12:54 <quicksilver> most of the standard types have all the instances that GHC's deriving mechanism would provide, if you wrote them yourself.
03:13:48 <typoclass> hm. so, "Nothing < Just x", whatever x may be. "Just x < Just y" depends on x and y
03:13:56 <quicksilver> rightly.
03:14:03 <quicksilver> because of the order of the constructors in the type definition.
03:14:15 <quicksilver> automatic derivations break program transformation.
03:14:20 <quicksilver> @src Maybe
03:14:20 <typoclass> quicksilver: well, i don't have those memorized :-D
03:14:20 <lambdabot> data Maybe a = Nothing | Just a
03:14:29 <quicksilver> typoclass: that's why I'm here, so you don't have to.
03:15:37 * typoclass purrs in the general direction of quicksilver
03:16:24 <eikke> did someone every read the "One vote for type families in Haskell" paper?
03:16:56 <merijn> Presumably at least the reviewers did ;)
03:17:14 <quchen> merijn: If only.
03:17:28 <typoclass> @type max (?x :: Maybe Int) (?x)
03:17:30 <lambdabot> (?x::Maybe Int) => Maybe Int
03:17:36 <quchen> I just got a review back - 10 lines, yeah super interesting I support publishing stuff about this blabla.
03:17:37 <typoclass> @type liftM2 max (?x :: Maybe Int) (?x)
03:17:38 <lambdabot> (?x::Maybe Int) => Maybe Int
03:17:41 <quchen> Made me question the peer review process.
03:17:43 <eikke> I assume at least some people did read it indeed, but rather wondering wether some of those readers are around so I can ask something :)
03:18:09 <merijn> quchen: Submit to better conferences if you want better reviews ;)
03:18:18 <typoclass> ^^ same type, different meaning, just by adding 'liftM2' at the front
03:18:44 <typoclass> quchen: yeah it has its flaws
03:19:17 <merijn> The reviews I got from PLDI were pretty decent, but the bastards still turned me down due to lack of implementation/benchmarks. Even though I had a nice correct proof and analysis that made benchmarks redundant and shows how I could create a benchmark to show arbitrary approvement. *shakes fist*
03:19:27 <t7> can i get cabal to tell me the directory its running from?
03:19:49 <dcoutts_> t7: context?
03:20:05 <merijn> Time to further formalise using mu-calculus and aim for POPL next year :p
03:20:27 <t7> well i think its running from somewhere other than \Users\Me\Appdata\roaming\cabal\bin
03:20:36 <t7> in program files or something
03:20:54 <eikke> t7: so you're looking for 'which cabal'?
03:21:07 <t7> yeah but windows
03:21:23 <t7> stupid stupid windows
03:21:25 <quchen> Arrrgh. How can I catch an IO error and make it an ErrorT IO action?
03:21:38 <quchen> Is there a combinator to spare me the trial and error?
03:22:05 <t7> oh 'where' works
03:22:06 <t7> cool
03:22:12 <eikke> quchen: unsafeCoerce? ;)
03:22:14 <typoclass> t7: there's a cool thing on the interwebs called 'google'. check it out. http://stackoverflow.com/questions/304319/is-there-an-equivalent-of-which-on-windows
03:22:14 <dcoutts_> quchen: use Control.Exception.catch, with type IOException
03:22:27 <t7> too slow typoclass
03:22:46 <t7> maybe next time your sarcy comments will make you look cool
03:23:29 <quchen> dcoutts_: That'll catch IO to IO, not IO to ErrorT
03:23:52 <vlatkoB> What is the syntax to map pure function on a list of IOs?
03:23:53 <vlatkoB> inputs :: IO [String]
03:23:53 <vlatkoB> inputs = mapM readFile paths
03:23:53 <vlatkoB> outputs :: (String -> String) -> [String]
03:23:53 <vlatkoB> outputs f = map (\x -> x >>= f) inputs  -- doesn't work
03:24:02 <dcoutts_> quchen: use liftIO, and then you use the throwError to throw it in the ErrorT
03:24:45 <dcoutts_> quchen: there's no magic, you just need to think about the layers and conversions
03:24:53 <hpaste> quchen pasted “Catch me if you can” at http://hpaste.org/85239
03:25:11 <notdan> So while checking my program on big sizes I've enountered a stack overflow, while I thought that I only used tail calls
03:25:24 <notdan> is there a way to find out which function/module is causing the trouble?
03:25:29 <quchen> ^ conceptual paste.
03:25:36 <quchen> dcoutts_: Hm. More trying then I guess.
03:25:53 <merijn> notdan: Haskell isn't strict, stackoverflows and tail recursion are mostly orthogonal
03:26:19 <notdan> merijn: ah, yeah, that is true
03:26:28 <eikke> vlatkoB: something like outputs f = inputs >>= \l -> return (map f l) ?  (which has a different type than what's defined in your snippet)
03:26:30 <quchen> foldl is tail recursive and does happily overflow
03:26:45 <notdan> Well still I want to find out what is the problem
03:26:54 <merijn> notdan: As for how to debug these things, Debug.Trace.trace is always a good place
03:27:06 <dcoutts_> quchen: um, you're running the readFile outside the error handler, and then trying to run its result (which is an Int) with an error handler
03:27:17 <quchen> notdan: Do you know the corresponding RWH chapter? It talks about heap profiling
03:27:19 <notdan> merijn: well but I don't know where to put the trace calls
03:29:22 <merijn> I usually do binary search start with two traces/prints far apart and when the crash is in between, start halving to narrow down the codepath
03:29:39 <vlatkoB> eikke: Getting "Couldn't match expected type `[a0]' with actual type `IO [String]'"
03:29:46 <merijn> There's also the profiler, but I don't know much about how it works, the RWH chapter might be a good place
03:30:00 <typoclass> t7: i was just annoyed that you were bitching about windows, which seemed pointless to me
03:30:34 <quchen> dcoutts_: Yeah that code was rubbish, I just wanted to sketch what I wanted. The problem I'm having right now is that catching always removes the exception, and results in a value of same type as the throwing action. I can't figure out how to change exception types.
03:31:05 <quchen> If I catch the IO error in the "read file" block, then I'll get a regular IO value back, losing the conotation that something failed.
03:31:38 <dcoutts_> quchen: but the point is that you rethrow in your ErrorT monad, so it never returns anyway
03:31:41 <quchen> Catching outside also doesn't work as it's ErrorT, and the IO error just propagates outward uncaught
03:31:51 <eikke> :t \(f :: String -> String) (inputs :: IO [String]) -> inputs >>= \l -> return (map f l)
03:31:53 <lambdabot> (String -> String) -> IO [String] -> IO [String]
03:32:16 <eikke> vlatkoB: ^^
03:32:47 <vlatko_> got reconnected, so I'm now vlatko_
03:33:06 <quchen> What I would have to do is catching the IO thing in the IO block, and then invoke the ErrorT throw in the handler.
03:34:14 <eikke> :t \(f :: String -> String) (inputs :: IO [String]) -> (fmap . fmap) f inputs
03:34:15 <lambdabot> (String -> String) -> IO [String] -> IO [String]
03:35:13 <notdan> merijn: the profiler didn't help me a lot to be honest
03:36:37 <hseg> I'm currently using mtl in my code (at least, it seems so, as I'm importing Contol.Monad.{Reader,State}). Is there any reason to switch to transformers?
03:36:52 <vlatko_> GHCI suggest I should use -XScopedTypeVariables. Have to figure out how.
03:38:27 <vlatko_> But is it possible to keep the signature of "outputs" pure? (outputs :: (String -> String) -> [String])
03:39:26 <klrr> is "str@(x:xs)" valid?
03:39:35 <zzo38> I think continuations with law of excluded middle is more clearly. What do you think? Also see: http://sprunge.us/WVKY
03:42:32 <typoclass> klrr: yes, it will match the first element as 'x', the rest of the list as 'xs', and all of the list as 'str'
03:42:44 <hseg> Also, I don't understand how to use mapState as suggested yesterday to convert a function :: State Integer foo into :: State (Integer,String) foo
03:43:56 <notdan> zzo38: Hm, I don't see how lemCC represents the LeM
03:44:08 <notdan> could you explain it to me please?
03:44:23 <BlairA> join ##bam-2013
03:44:32 <notdan> I read Harper's paper on how continuations are LeM, but I didn't manage to port the code to haskell
03:44:50 <zzo38> notdan: Classical implication is (Kleisli (Cont r)). Does that help explain it?
03:45:05 <zzo38> I have never read Harper's paper, or even heard of it until now.
03:46:15 <notdan> zzo38: I was refering to this: http://www.cs.cmu.edu/~rwh/courses/logic/www-old/handouts/callcc.pdf
03:46:21 <notdan> not really a paper, but still
03:46:39 <notdan> zzo38: I don't understand what monads have to do with this
03:46:55 <klrr> typoclass: that's cool, haskell is AMAZING FUCKING AWESOME :D
03:48:52 <zzo38> notdan: The only thing that monads have to do with this is that the Cont type which allow to make continuations in Haskell, forms a monad (therefore its Kleisli category is functions including continuations, i.e. classical).
03:49:00 <klrr> why doesnt this work http://hpaste.org/85240 ?
03:50:03 <notdan> zzo38: oh, Right
03:50:31 <zzo38> notdan: Look up Control.Monad.Trans.Cont (in the "transformers" package) if it helps to do so, since the proof I give involves that.
03:50:38 <mauke> klrr: you're calling print with 2 arguments
03:50:41 <mauke> print only takes 1
03:50:55 <hseg> Why transformers over mtl?
03:51:42 <klrr> mauke: ok thanks!
03:52:17 <zzo38> hseg: Use mtl if you prefer. I used transformers.
03:52:35 <hseg> But what are the pros/cons?
03:53:19 <klrr> mauke: lol im dumb, my program is 11 lines, but can be written with simple "main = interact reverse" haha, HASKELL IS AWEOMSE!!!
03:53:41 <mauke> :-)
03:54:26 <klrr> i dont understand, but haskell is simply amazingly designed
03:54:37 <klrr> i hope i dont die when learning monads though ^^
03:54:53 <mauke> you're already using 3 monads in your code
03:54:58 <typoclass> klrr: you won't, there's nothing much to it
03:55:00 <mauke> [], (e ->), IO
03:55:17 <notdan> zzo38: I know Cont a little bit and I was even reading about it today, but I still have a question
03:55:28 <zzo38> OK, What question?
03:55:29 <notdan> zzo38: shouldn't it be the case that 'b' in the lemCC type signature is Void
03:55:33 <notdan> eg: empty type?
03:55:36 <klrr> well, i dont find it difficult to use IO, i have difficult time understanding what a monad is, from what ive understood it's a typeclass is that correct?
03:55:54 <mauke> print scalar reverse readline STDIN;
03:56:06 <mauke> klrr: Monad is a typeclass. "a monad" would be an instance of that class
03:56:37 <zzo38> notdan: It doesn't matter. Void implies anything. The type could be changed and it would still work the same.
03:56:39 <klrr> mauke: okey, and what extra "properties" would a type deriving from that typeclass be?
03:56:58 <chrisdone> ( ﾟ▽ﾟ)/ ahoy
03:57:00 <mauke> klrr: types can't derive from classes
03:57:03 <hseg> Also, is a StateT a (Reader b) c :: MonadReader ? I can't explain the typechecker not screaming at me otherwise, but I also can't find this instance in the docs.
03:57:04 <mauke> types implement classes
03:57:09 <klrr> hmm
03:57:16 <mauke> klrr: do you know Show?
03:57:20 <klrr> mauke: yeah
03:57:29 <mauke> klrr: Eq?
03:57:32 <klrr> yeah
03:57:36 <mauke> klrr: Functor?
03:57:38 <klrr> i thought they were type classes
03:57:39 <klrr> yes
03:58:15 <mauke> oh, do you understand Read?
03:58:16 <klrr> data MetricUnit = Meter | Liter deriving (Show,Eq)
03:58:20 <chrisdone> hseg: that'll be an instance of MonadReader if (probably) there's an instance like MonadReader m => MonadReader StateT a m
03:58:29 <klrr> mauke: hmm, i donno
03:58:36 <mauke> klrr: sure, but do you know how to define Show by hand?
03:58:49 <klrr> nope
03:59:05 <klrr> ?src Show
03:59:06 <lambdabot> class  Show a  where
03:59:06 <lambdabot>     showsPrec :: Int -> a -> ShowS
03:59:06 <lambdabot>     show      :: a   -> String
03:59:06 <lambdabot>     showList  :: [a] -> ShowS
03:59:06 <notdan> zzo38: ok, I am really confused now. LeM when written as a type signature is Either a (a -> Void), right?
03:59:18 <chrisdone> hseg: see here: http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-State-Lazy.html#t:StateT see there's the line: MonadReader r m => MonadReader r (StateT s m)
03:59:31 <typoclass> klrr: roughly, it's a list or sequence, as in "do print 42 ; print 37", with the addition that a value can be passed from one action to the next. (print doesn't pass on a useful value, but other functions do). you may have seen stuff like "getLine >>= print" or "getChar >>= (\c -> ...)"
03:59:32 <danr> notdan: yes
03:59:36 <zzo38> notdan: Yes, although (->) is intuitionistic implication. Classical implication is (Kleisli (Cont r)).
03:59:47 <mauke> klrr: for simplicity, assume 'class Show a where { show :: a -> String }'
03:59:52 <tdammers> mauke: Show might not be the best example
03:59:58 <zzo38> And LeM does not apply in intuitionistic logic.
03:59:58 <mauke> Show is the best example
04:00:07 <tdammers> OK carry on ;)
04:00:12 <danr> ;)
04:01:09 <notdan> zzo38: but it doesn't matter. In intuitionistic logic we define ~a = a -> _|_ using intuitionistic implication
04:01:17 <klrr> okey, i kind of get it now
04:01:21 <mauke> the (simplified) Show class has only a single method, taking a single parameter of the type in question
04:01:31 <mauke> and it's easy to explain what it does
04:01:47 <mauke> from there you can generalize to Eq and Ord
04:02:04 <mauke> and then Read, which introduces return-type-based overloading
04:02:05 <zzo38> notdan: Yes, but LeM does not apply in intuitionistic logic, therefore you have to use classical implication! Doesn't it understand?
04:02:22 <mauke> and then we get constructor classes with Functor
04:02:46 <hseg> Right. Stupid me.
04:03:32 <danr> zzo38: I don't entirely agree. I think it's fine to say that lem is a + ~a in intuitionistic logic too. that it isn't a theorem is another thing
04:04:05 <hseg> I need to convert code from MonadState Integer foo to MonadState (Integer,String) foo. Someone suggeseted using mapState, but I don't understand how to use it.
04:04:32 <zzo38> danr: Well, yes, it is, but it isn't a theorem, and I am writing it in terms of classical logic, not intuitionistic logic, anyways.
04:04:43 <notdan> zzo38: what danr said; harper in his handout proves exactly that
04:05:08 <mauke> hseg: I bet lenses can do that
04:05:28 <zzo38> notdan: When you have continuations, though, you are using classical logic, not intuitionistic logic.
04:05:41 <chrisdone> using tuples for state almost always leads to using a record
04:05:52 <hseg> No. I'm *not* abstracting my code *that* much.
04:05:52 <hseg> Although it could be really cool.
04:05:53 <danr> zzo38: I disagree! You're embedding classical logic inside intuitionistic logic.
04:06:11 <mauke> :t mapState
04:06:12 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
04:06:23 <danr> notdan: what does Harper prove?
04:06:51 <notdan> danr: that if you have first-class continuations, you can express the law of excluded middle http://www.cs.cmu.edu/~rwh/courses/logic/www-old/handouts/callcc.pdf
04:06:57 <zzo38> danr: Yes, you can embed classical logic inside intuitionistic logic; to do so, you have to translate the classical implication into another form, so you cannot use the intuitionistic implication directly.
04:07:20 <hseg> Right. I have a function :: foo -> MonadState Integer bar. I need to use it within a chain of binds in MonadState (Integer,String). I don't see my types up there.
04:07:25 <chrisdone> oh btw don't think i shared this here: http://haskellnews.org/
04:07:31 <danr> notdan: aha, thanks
04:08:27 <mauke> :t runState
04:08:28 <lambdabot> State s a -> s -> (a, s)
04:09:11 <zzo38> notdan: Yes, **if you have first-class continuations**, i.e. classical logic. Haskell does not have continuations so you have to embed them using the Cont type (this is a way to embed classical logic into intuitionistic logic).
04:09:49 <hseg> Still has the issue of requiring that the code remain within the same State monad instance
04:09:51 <mauke> :t \f x -> do { (si, ss) <- get; let { (y, si') = runState (f x) }; put (si', ss); return y }
04:09:53 <lambdabot>     Couldn't match expected type `(t0, t1)'
04:09:53 <lambdabot>                 with actual type `s0 -> (a0, s0)'
04:09:53 <lambdabot>     In the return type of a call of `runState'
04:10:00 <mauke> :t \f x -> do { (si, ss) <- get; let { (y, si') = runState (f x) si }; put (si', ss); return y }
04:10:01 <lambdabot> MonadState (t1, t2) m => (t -> State t1 b) -> t -> m b
04:10:25 <mauke> :t modify
04:10:26 <lambdabot> MonadState s m => (s -> s) -> m ()
04:10:29 <zzo38> How is this difficult?
04:11:27 <mauke> :t \f -> modify (first (execState f))
04:11:28 <lambdabot> MonadState (b, d) m => State b a -> m ()
04:12:27 <hseg> I'm guessing I can't do this without modifying the code in State Integer foo?
04:13:47 <zzo38> I do not understand Harper's report, but I can also see how to make law of excluded middle using continuations, and I have done so already, anyways.
04:16:11 <zzo38> If you called lemCC at first, it is Right, and is another function. If that function is then called later on, it go back, and makes lemCC to be Left instead, and will have whatever the right function parameter was. Therefore there is no return value of that function so the type doesn't matter.
04:17:15 <zzo38> Is this understandable to you now?
04:18:26 <notdan> yes, thanks
04:18:32 <zzo38> OK
04:24:40 <hpaste> quchen pasted “Exceptions driving me nuts” at http://hpaste.org/85241
04:25:04 <quchen> ... that problem's bugging me for hours now. I can't get any work done thinking about it.
04:39:09 <typoclass> quchen: isn't the ErrorT from mtl the one that everyone hates? also, have you looked at MonadError? it has an instance MonadError IOException IO http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error.html
04:40:21 <quchen> ErrorT is in that package
04:40:29 <quchen> It's what I'm using right now
04:41:00 <quchen> The MonadError instance for IOException/IO is just a wrapper around the usual throw/catch
04:42:05 <hseg> Is there a better way to have two values of global state than: A) A pair of both values B) A record of both values C) A State of one wrapped around a State of the other?
04:42:39 <quchen> hseg: Not that I know of
04:42:53 <mcstar> id go with a mutable state of a record of 2
04:43:11 <quchen> Yeah
04:43:20 <hseg> Then among the three options above, what is the best, assuming that there most likely won't be any more global state?
04:43:24 <typoclass> quchen: otherwise, if you want to do it yourself, Control.Exception.catch is type Exception e => IO a -> (e -> IO a) -> IO a. the action that may throw and the handler need to give the same type (IO a). so i guess with catch, you'd have to use IO (Either IOException a), run the action, unwrap the Either, and in the ErrorT monad do throwError or return accordingly
04:43:32 <Eduard_Munteanu> hseg: B sounds best
04:43:40 <typoclass> 'do it yourself' in the sense of 'if you want to use catch yourself'
04:43:54 <Eduard_Munteanu> hseg: use lenses if you need to access stuff more nicely
04:44:07 <hseg> Seriously? Record syntax seems ugly to me...
04:44:31 <ab9rf> this sounds like a job for lenses to me
04:44:41 <typoclass> hseg: you could have a tuple in the State
04:44:57 <mcstar> but it is better to name the fields of the record imho
04:45:00 <quchen> typoclass: Oh, I haven't tried manually wrapping all that stuff yet.
04:45:28 <Eduard_Munteanu> If you go that way, might as well use the constructor directly, you still can even if you declare field name.s
04:45:54 <hseg> A) Why lenses? B) True, records would lead to more readability
04:46:06 <mcstar> Eduard_Munteanu: you are an object oriented programmer in disguise
04:46:14 <hseg> Eduard_Munteanu: What do you mean by using the constructor directly?
04:46:44 <quchen> hseg: Lenses make accessing record fields nice.
04:46:50 <Eduard_Munteanu> data Foo = Foo { .... }, you can still create values like this: Foo a b
04:47:07 <Eduard_Munteanu> So you don't really need a plain pair.
04:47:16 <hseg> TF? Why would that work?
04:47:36 <mcstar> whats TF?
04:48:06 <Eduard_Munteanu> WTF without the W, I guess. :)
04:48:17 <mcstar> in that case, why wouldnt it work?
04:48:21 <hseg> Correct.
04:49:58 <hseg> Why would data Foo = Foo {foo :: Integer, bar :: Integer} allow me to do Foo 2 4?
04:50:01 <mcstar> data GlobalState = GS { getA::, getB::}; GS a b; gs { a = a'}; let GS a b = ; getA gs; you can use this any way you like
04:50:29 <ocharles> hseg: because 'Foo' is still a data constructor
04:50:36 <ocharles> the record fields are just sugar
04:50:49 <ocharles> in your case, Foo 2 4 == Foo { foo = 2, bar = 4 }
04:51:27 <hseg> Awesome. So that means I can construct records using positional syntax.
04:51:38 <mcstar> yes, and deconstruct
04:51:57 <mcstar> it just gets cumbersome for too many fields
04:52:05 <mcstar> thats why there is record update syntax
04:52:08 <ocharles> you can destruct using record syntax btw
04:52:13 <mcstar> gs { a = a' }
04:52:26 <Eduard_Munteanu> hseg: if you used lenses, you could do stuff like "foo <- use foo" or "foo .= 123"
04:52:26 <ocharles> for example wibble Foo{..} = ... will bring the values 'foo' and 'bar' into scope
04:52:36 <ocharles> with an extension
04:52:41 <mcstar> i think lenses are a little early for him
04:52:59 <ocharles> them*
04:53:06 <ocharles> :)
04:53:17 <mcstar> her?
04:53:24 <ocharles> still presumptious
04:53:29 <mcstar> yes
04:53:44 <ocharles> english sucks for not having gender neutral terms
04:53:45 <mcstar> im not a native speaker, so excuse my presumptiousness
04:53:58 <hseg> Thanks. I will look into Lenses when some time frees up. Along with porting my code to use DLists.
04:54:07 <mcstar> ocharles: it XD
04:54:15 <ocharles> haha
04:54:26 * FireFly finds singular 'they' works well enough
04:55:12 <Eduard_Munteanu> It's only semantically singular, grammer-wise it's still plural.
04:55:21 <ocharles> the one person i know who doesn't consider themselves to have a gender prefers 'they' too
04:55:24 <ocharles> but... #haskell-blah
04:57:24 <hseg> Wait. Can I use the record deconstructors as functions in their own right? e.g. for the above definition, could I write something like showFoo = show . foo
04:57:25 <hseg> ?
04:57:34 <mcstar> yes
04:58:34 <mcstar> those are functions that take something of type that was given after 'data' and give something of type that you specificed for the record field
04:59:02 <hseg> Also, is there a way to write the following point-free: \(Foo a b) -> Foo (a + 1) b ?
04:59:14 <mcstar> showFoo wont show a Foo though
04:59:38 <hseg> Right, it will show the foo field of a Foo record.
04:59:43 <mcstar> yes
04:59:57 <hseg> @unpl \(a,b) -> (a+1,b)
04:59:57 <lambdabot> \ (a, b) -> ((a + 1), b)
05:00:04 <hseg> @pl \(a,b) -> (a+1,b)
05:00:05 <lambdabot> first (1 +)
05:00:34 <mcstar> incr_foo f = Foo (getA f + 1) (getB f)
05:00:51 <mcstar> pretty ugly
05:00:58 <Eduard_Munteanu> hseg: lens!
05:01:06 <mcstar> yay, lens
05:01:39 <hseg> OK, how does lens help here?
05:01:54 <mcstar> you woke up edward.k
05:03:04 <hseg> It is *hard* writing good code without an interpreter/compiler on hand to test stuff on.
05:03:28 <mcstar> are you comparing haskell with your previous language?
05:03:59 <hseg> Nope. I'm complaining about this computer not being mine, thus I'm stuck writing code blindly
05:04:09 <mcstar> oh
05:04:21 <quchen> Set up a SSH server somewhere?
05:04:28 <mcstar> i dont understand thouhg
05:04:38 <mcstar> why are you writing haskell at all then?
05:04:52 <hseg> Situation would be better if GHC were portable in the sense of being able to run on a pendrive.
05:04:52 <mcstar> also there is tryhaskell or something
05:05:07 <Eduard_Munteanu> hseg: you'd write something like  over first (+1)
05:05:13 <mcstar> and you can talk privately with lambdabot too
05:05:19 <hseg> Because I'll have access to a comiler/interpreter on Sunday.
05:05:22 <Eduard_Munteanu> s/first/foo/
05:05:30 <Eduard_Munteanu> Or however you call your first field.
05:05:57 <mcstar> getA
05:06:49 <quchen> > (1,12) & _1 +~ 1 & _2 +~ 24
05:06:51 <lambdabot>   (2,36)
05:07:15 <mcstar> so.... excuse me but i personally find that close to horrible
05:07:31 <mcstar> i dont want my haskell to look like apl
05:07:43 <Eduard_Munteanu> > over _1 (+1) $ (3,4)
05:07:45 <lambdabot>   (4,4)
05:07:47 <hseg> :source &
05:08:07 <quchen> & = flip $
05:08:10 <hseg> :t &
05:08:11 <lambdabot> parse error on input `&'
05:08:12 <quchen> Defined in Lens
05:08:25 <mcstar> hseg: you need to wrap your operators in ()
05:08:29 <quchen> > 3 & (*2)
05:08:31 <lambdabot>   6
05:08:38 <mcstar> :t (+)
05:08:39 <lambdabot> Num a => a -> a -> a
05:08:53 <hseg> OK. It's official. People who write Haskell are crazy. Fun crazy, but crazy.
05:08:59 <hseg> Right, I forgot.
05:09:11 <mcstar> no, they are stupid
05:09:22 <mcstar> let me explain
05:09:38 <mcstar> they are too stupid to write code the hard way, thats what i meant
05:09:55 <hseg> The hard way being?
05:09:59 <Eduard_Munteanu> like Real Programmers(tm)
05:10:05 <mcstar> yeah
05:10:07 <quchen> ™
05:10:17 * ocharles is a Real Programmer for his day job and would much rather be a crazy programmer
05:11:11 <hseg> :-). Real Programmers(tm) only code in machine code. When goofing off, they genetically engineer butterflies to write the code for them.
05:11:32 <ocharles> nono, Real Programmers use factories, and interfaces, and observers, and and and
05:11:50 <mcstar> there are two kinds of real programmers then
05:12:04 <mcstar> the old kind, that is almost extinct and the new kind that ocharles talks about
05:12:12 <b_jonas> hseg: hehe, that reminds me to those bacteria breeded to be collectively intelligent in Stanislaw Lem's writing
05:12:13 <oab> hey, in GHC.Prim. Does the narrow8Word# just zero out bits 8->30+
05:12:33 <mcstar> b_jonas: you mean a human being?
05:12:42 <b_jonas> mcstar: no
05:12:45 <aCube> Is there really no instance (Enum a, Enum b) => Enum (a,b) ?
05:12:55 <b_jonas> a different kind
05:12:55 <mcstar> i read that we are mostly bacteria... :)
05:13:06 <oab> eg is equivalent to masking with and?
05:13:42 <Eduard_Munteanu> aCube: how would you implement that?
05:13:45 <aCube> > [(0,0)..(10,10)]
05:13:45 <mcstar> got to get back to my marching tetrahedrons...
05:13:47 <lambdabot>   No instance for (GHC.Enum.Enum (t0, t1))
05:13:47 <lambdabot>    arising from a use of `e_100101...
05:14:24 <mcstar> > [(a,a) | a <- [0..10]]
05:14:25 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
05:14:32 <quchen> hseg: Lens is quite simple as long as you don't read the error messages.
05:14:48 <Eduard_Munteanu> aCube: you mean what mcstar just said? ^^
05:14:49 <mm_freak_> :t dup
05:14:51 <lambdabot>     Not in scope: `dup'
05:14:51 <lambdabot>     Perhaps you meant one of these:
05:14:51 <lambdabot>       `du' (imported from Numeric.AD), du' (imported from Numeric.AD),
05:15:03 <mm_freak_> > map (\x -> (x, x)) [0..]
05:15:04 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
05:15:08 <aCube> No
05:15:13 <hseg> Why? What horrors do the error messages reveal?
05:15:30 <mcstar> (i guess they DONT reveal...)
05:15:36 <aCube> > [0..10] >>= \x -> map (\y -> (y,x))  [0..10]
05:15:38 <lambdabot>   [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0),(0,1),(...
05:15:42 <Cale> > range ((0,0),(10,10))
05:15:43 <aCube> Something like that
05:15:44 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(...
05:15:48 <Cale> > range ((0,0),(3,3))
05:15:49 <Eduard_Munteanu> aCube: then I don't think you can implement it
05:15:50 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
05:15:54 <aCube> Thanks Cale :)
05:16:02 <Cale> (That's from Data.Ix)
05:16:07 <quchen> hseg: Lens is very complicated internally so that it can be very simple to use on various data structures.
05:16:17 <quchen> hseg: The errors reflect the internals.
05:16:17 <FireFly> Does the 'Ix' in Data.Ix stand for anything?
05:16:17 <Eduard_Munteanu> Sounds like you also want a Bounded constraint and such.
05:16:20 <Cale> Index
05:16:24 <FireFly> Oh
05:16:30 <mcstar> anything that can be used as an index
05:17:07 * aCube needed it to iterate over all fields of a 2D Array with the index (That reminds me: Maybe I could use lens?)
05:17:09 <Eduard_Munteanu> (since succ is obviously partial for finite types)
05:17:33 <Eduard_Munteanu> Ah, then Ix is indeed appropriate, I guess.
05:17:45 <aCube> > arrayList ((0,0), (10,10)) [1..] ^@.. traversed
05:17:47 <lambdabot>   Not in scope: `arrayList'
05:17:54 <aCube> > listArray ((0,0), (10,10)) [1..] ^@.. traversed
05:17:56 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
05:18:18 <aCube> > listArray ((0,0), (10,10)) [1..] ^@.. itraversed
05:18:20 <lambdabot>   Could not deduce (Control.Lens.Indexed.TraversableWithIndex
05:18:20 <lambdabot>                ...
05:18:20 <Cale> Some of Ed's infix operators remind me of a certain sort of Mathematica code for some reason.
05:18:35 <mcstar> really?
05:18:43 <mcstar> because of the _ pattern matcher?
05:18:43 <aCube> Why does that not work :(
05:18:48 <quchen> Cale: #&@2 -- Valid code. Greetings, Stephen
05:19:05 <quchen> Also, what the hell is ^@..
05:19:07 <FireFly> It mostly reminds me of J..
05:19:13 <aCube> quchen: itoListOf
05:19:16 <mcstar> i just hate Mathematica and at the same time like its graphics capabilities
05:19:16 <Eduard_Munteanu> quchen: snail leaving a trail :P
05:19:16 <aCube> indexed to list of
05:19:17 <Cale> mcstar: It's just how Mathematica has infix operators for many things which I'd usually write prefix.
05:19:20 <aCube> @ = index
05:19:27 <quchen> ^?
05:19:30 <aCube> > [1..10] ^@.. traversed
05:19:32 <quchen> "^"?
05:19:32 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
05:19:35 <Cale> mcstar: and so does the lens library :)
05:20:04 <mcstar> Cale: you can write stuff infix as '~ Fun ~', i find it cumbersome
05:20:05 <Eduard_Munteanu> Maybe he could've done better with unicode chars.
05:20:16 <aCube> > (M.fromList $ zip [2..10] [0..8]) ^@.. itraversed
05:20:18 <lambdabot>   [(2,0),(3,1),(4,2),(5,3),(6,4),(7,5),(8,6),(9,7),(10,8)]
05:20:42 <mcstar> Cale: what would you write prefix, rather than infix, im curious
05:20:44 <aCube> Cale: lens has also prefix operators
05:21:04 <Eduard_Munteanu> I'd also write mixfix, if I could. :)
05:21:09 <Cale> mcstar: I mean things like /@ for Map
05:21:16 <Cale> In the case of Mathematica
05:21:17 <aCube> > itoListOf itraversed $ M.fromList $ zip [2..10] [0..8]
05:21:19 <lambdabot>   [(2,0),(3,1),(4,2),(5,3),(6,4),(7,5),(8,6),(9,7),(10,8)]
05:21:35 <mcstar>  /@ is handy, as well as apply @@, or ./ .//
05:21:51 <quchen> Not to forget //@
05:22:06 <quchen> And @@@
05:22:11 <aCube> > hoggle @
05:22:12 <mcstar> Cale: i just really hate its evaluation model, and the many kinds of values, up/down/own value...
05:22:13 <lambdabot>   <hint>:1:9: parse error (possibly incorrect indentation)
05:22:15 <Cale> I tend to use very few of Mathematica's infix operators -- mostly just the ones which are present in mathematical notation already :P
05:22:32 <Cale> and I tend to use Function rather than #/&
05:22:49 <quchen> Cale: Problem is Function can give you scoping issues
05:22:56 <Cale> oh?
05:22:56 <quchen> Oh well, this isn't #mma
05:23:01 <mcstar> everything can give you scopeing iossues
05:23:07 <mcstar> this is mathematica we are talking about
05:23:14 <Cale> lol
05:23:57 <Cale> Isn't the #/& syntax directly represented by applications of Function?
05:24:48 <mcstar> Cale: you can not easily nest pure functions
05:24:56 <mcstar> without Function, i.e. named parameters
05:26:19 <quchen> mcstar: Yes you can. #blah
05:27:15 <Cale> mcstar: I think quchen is inviting you to join #haskell-blah
05:27:42 <quchen> It's #haskell's /dev/null
05:29:58 <aCube> > scanr (+) [a,b,c]
05:29:59 <lambdabot>   No instance for (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
05:30:00 <lambdabot>    arising fr...
05:30:05 <aCube> > scanr1 (+) [a,b,c]
05:30:06 <lambdabot>   [a + (b + c),b + c,c]
05:30:19 <Cale> > scanr (+) z [a,b,c]
05:30:21 <lambdabot>   [a + (b + (c + z)),b + (c + z),c + z,z]
05:30:33 <Cale> > scanl (+) z [a,b,c]
05:30:35 <lambdabot>   [z,z + a,z + a + b,z + a + b + c]
05:31:17 <aCube> Is there a function that takes a function f and a list a, b, c and returns [a `f` b, b `f` c] ?
05:31:59 <hseg> foo f l@(x:xs) = zipWith f l xs
05:32:25 <hseg> Probably could make that neater.
05:32:45 <aCube> > let l = [a,b,c] in zipWith f l $ tail l
05:32:46 <lambdabot>   Ambiguous type variable `c0' in the constraints:
05:32:46 <lambdabot>    (GHC.Show.Show c0)
05:32:46 <lambdabot>     ...
05:32:59 <aCube> > zipWith f [a,b,c] $ tail [a,b,c]
05:33:01 <lambdabot>   Ambiguous type variable `c0' in the constraints:
05:33:01 <lambdabot>    (GHC.Show.Show c0)
05:33:01 <lambdabot>     ...
05:33:22 <aCube> > zipWith (+) [a,b,c] (tail [a,b,c])
05:33:24 <lambdabot>   [a + b,b + c]
05:33:35 <aCube> Why doesn't it work with f Cale?
05:33:57 * hackagebot hmatrix-svdlibc 0.1.0.0 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.1.0.0 (BenGamari)
05:34:25 <aCube> > zipWith f [a,b,c] (tail [a,b,c])
05:34:27 <lambdabot>   Ambiguous type variable `c0' in the constraints:
05:34:27 <lambdabot>    (GHC.Show.Show c0)
05:34:27 <lambdabot>     ...
05:35:01 <Cale> > zipWith (f :: Expr -> Expr) [a,b,c] (tail [a,b,c])
05:35:03 <lambdabot>   Couldn't match expected type `b0 -> c0'
05:35:03 <lambdabot>              with actual type `Debu...
05:35:08 <Cale> > zipWith (f :: Expr -> Expr -> Expr) [a,b,c] (tail [a,b,c])
05:35:10 <lambdabot>   [f a b,f b c]
05:35:17 <Cale> there we are :)
05:35:18 <Cale> :t f
05:35:20 <lambdabot> FromExpr a => a
05:35:24 <Cale> ^^ it's polymorphic
05:35:42 <Cale> So if you don't specify the type enough, it won't know which instance of Show to use
05:36:06 <aCube> :t (+)
05:36:08 <lambdabot> Num a => a -> a -> a
05:36:27 <aCube> :t a
05:36:29 <lambdabot> Expr
05:36:37 <aCube> :t f'
05:36:38 <lambdabot> FromExpr a => a
05:37:24 <Cale> :t g
05:37:26 <lambdabot> FromExpr a => a
05:37:46 <Cale> A few of the letters were left polymorphic for use as functions, while the rest are just Expr
05:38:17 <aCube> So there is g,h,f, f' and f'' as functions?
05:38:31 <aCube> > map (
05:38:33 <lambdabot>   <hint>:1:6: parse error (possibly incorrect indentation)
05:38:41 <aCube> > map (++) [a,b,c] -- This one is confusing
05:38:44 <lambdabot>   *Exception: showList: No overloading for function
05:38:48 <aCube> :O
05:39:04 <hseg> :t map (++) [a,b,c]
05:39:05 <lambdabot> [Expr -> Expr]
05:39:18 <aCube> I meant
05:39:19 <aCube> > foldl1 (++) [a,b,c] -- This one is confusing
05:39:21 <lambdabot>   (a <> b) <> c
05:40:02 <hseg> (<>) = mappend
05:41:41 <Philonous> :t (++)
05:41:43 <lambdabot> Monoid m => m -> m -> m
05:42:53 <Kinnison> Where does that type come from?
05:43:03 <Kinnison> base defines ++ in terms of [a]
05:43:29 <Philonous> Kinnison:  Yes, that's lambdabot specific
05:43:41 <Kinnison> I see
05:43:47 <Kinnison> something to do with how it deals with partial expressions?
05:43:52 <Philonous> Kinnison:  Though you can redefine (++) to be mappend in you code as well, just don't import (++) from base
05:43:58 * hackagebot hmatrix-svdlibc 0.2.0.0 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.2.0.0 (BenGamari)
05:44:14 <Philonous> form Prelude, I mean
05:44:24 <Kinnison> Philonous: well, indeed.  I was just interested in where lambdabot got it from
05:44:33 * Kinnison is ever increasingly impressed by lambdabot's capabilities
05:44:44 <aCube> Kinnison:
05:44:46 <aCube> > 3 4 5
05:44:48 <lambdabot>   3
05:45:11 * hseg is increasingly astounded by the gap between what GHCi does and what \bot does
05:45:12 <Philonous> :t (.) -- Lambdabot has some funky definitions
05:45:14 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:45:20 <Philonous> Oh
05:45:26 <Philonous> Since when is (.) not fmap?
05:45:31 <aCube> > id + id $ 4
05:45:33 <lambdabot>   8
05:45:47 <aCube> > fst 4
05:45:49 <lambdabot>   4
05:45:53 <aCube> > snd 4
05:45:54 <lambdabot>   4
05:46:03 <Kinnison> aCube: Now you're just confusing me :-)
05:46:39 <Philonous> Kinnison:  instance Num a => Num (a,a) where fromIntegral x = (x,x)
05:46:52 <aCube> And also the function instance
05:47:13 <Philonous> (fromIntegral x, fromIntegral x) even
05:47:42 <hseg> Wait, wait. How does fst 4 typecheck?!
05:47:43 <Philonous> And fromInteger...
05:48:00 <Philonous> hseg:  Num instance for pairs
05:48:04 <aCube> :t 4
05:48:06 <lambdabot> Num a => a
05:48:18 <Philonous> > 4 :: (Int, Int)
05:48:20 <lambdabot>   (4,4)
05:48:22 <hseg> :t 4 :: (Integer, Integer)
05:48:24 <lambdabot> (Integer, Integer)
05:48:27 <Kinnison> croiky
05:49:06 <hseg> My thoughts exactly.
05:49:07 <aCube> > True
05:49:09 <lambdabot>   True
05:49:33 <hseg> Somewhat like when I found out that everything you type is in the Reader Applicative by definition.
05:49:36 <aCube> > (4 :: Bool -> Int) $ True
05:49:37 <lambdabot>   4
05:51:01 <bourbaki> edwardk: Ping
05:52:07 <hseg> It's kinda annoying that identifiers aren't unique based on type - i.e. that I can't have foo :: Integer and foo :: String inside the same scope, with any occurence of foo checked for unification with Integer and String, and if precisely one of them matches, that instance is bound to the occurence.
05:53:03 <hseg> OK, aCube, now you're just screwing with my brain. How is Bool -> Int an instance of Num?
05:53:26 <aCube> instance Num a => Num (b -> a) where fromIntegral = const I think
05:53:51 <glutamate> @help
05:53:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:53:52 <hseg> > (4 :: Bool -> Int) $ False
05:53:54 <lambdabot>   4
05:54:00 <hseg> > (4 :: Bool -> Int) $ undefined
05:54:01 <lambdabot>   4
05:54:07 <aCube> @hackage numInstances
05:54:08 <lambdabot> http://hackage.haskell.org/package/numInstances
05:54:18 <glutamate> @help djinn
05:54:18 <lambdabot> djinn <type>.
05:54:18 <lambdabot> Generates Haskell code from a type.
05:54:18 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:54:43 <eikke> lambdabot: djinn a -> b
05:54:44 <aCube> hseg: http://hackage.haskell.org/packages/archive/NumInstances/1.2/doc/html/src/Data-NumInstances-Function.html
05:54:50 <glutamate> @djinn [[[(a,b)]]] -> ([[[a]]],[[[b]]])
05:54:51 <lambdabot> Error: Undefined type []
05:54:55 <FireFly> @djinn a -< b
05:54:55 <lambdabot> Cannot parse command
05:55:00 <FireFly> @djinn a -> b
05:55:00 <lambdabot> -- f cannot be realized.
05:55:05 <glutamate> @djinn ([[[(a,b)]]] -> ([[[a]]],[[[b]]]))
05:55:05 <lambdabot> Error: Undefined type []
05:55:08 <aCube> @djinn a -> b -> (a,b)
05:55:08 <lambdabot> f a b = (a, b)
05:55:22 <glutamate> bummer
05:55:24 <hseg> Wait. That module doesn't export anything.
05:55:24 <aCube> djinn cannot handle lists (or other recursive types)
05:55:29 <eikke> @djinn m (m a) -> m a
05:55:29 <glutamate> thanks
05:55:30 <lambdabot> -- f cannot be realized.
05:55:38 <aCube> instances don't need to be exporteed
05:55:51 <aCube> @djinn-show
05:55:51 <lambdabot> Unknown command, try @list
05:55:51 <Taneb> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
05:55:52 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
05:56:18 <aCube> @djinn (Monad m) => m (m a) -> m a
05:56:18 <lambdabot> -- f cannot be realized.
05:56:25 <aCube> @djinn-env
05:56:25 <lambdabot> data () = ()
05:56:25 <lambdabot> data Either a b = Left a | Right b
05:56:25 <lambdabot> data Maybe a = Nothing | Just a
05:56:25 <lambdabot> data Bool = False | True
05:56:25 <lambdabot> data Void
05:56:27 <lambdabot> type Not x = x -> Void
05:56:28 <FireFly> @pl \a b c -> b (\d -> a (\e -> c (e d)))
05:56:29 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
05:56:31 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:56:33 <hseg> Nice. Also, I really don't understand those instances
05:56:33 <lambdabot> flip (.) . (. ((. flip id) . (.))) . (.)
05:59:11 <aCube> @djinn m (m a) -> m a
05:59:11 <lambdabot> -- f cannot be realized.
05:59:14 <hseg> Where does he import Data.NumInstances.Util from?
05:59:30 <aCube> Who?
05:59:47 <hseg> That package you linked above
06:00:00 <aCube> Data.NumInstances.Util seems like it is not exported, so it doesn't appear in the haddocks
06:00:33 <hseg> Ah. I don't understand the code. It is slightly too dense for me.
06:01:19 <Taneb> Is there a way, with ConstraintKinds, make a constraint "c is either equal to or a superclass of Monoid"?
06:01:30 <Taneb> subclass, rather
06:01:43 <quchen> Taneb: (Monoid c)? :-)
06:01:58 <Taneb> quchen, c is of kind Constraint
06:02:06 <quchen> Oh I see
06:02:21 <quchen> (And don't have an answer)
06:02:51 <Taneb> Well, it's of kind * -> Constraint
06:05:05 <aCube> @hoogle Array (i,i) v -> Array i v
06:05:05 <lambdabot> No results found
06:05:15 <aCube> @hoogle Array (i,i) v -> [Array i v]
06:05:15 <lambdabot> No results found
06:05:21 <Taneb> :t ixmap
06:05:22 <lambdabot> (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
06:05:29 <Taneb> No, it's not that
06:05:37 <aCube> Is there a function to return all rows of an Array?
06:05:55 <aCube> (and for columns?)
06:07:42 <Cale> aCube: there isn't a specific function for that, but it's easy to write
06:08:03 <Cale> (because the array library doesn't actually have a specific notion of rows or columns)
06:08:10 <aCube> Cale: How would one write a function like that? Manually traversing over the indicies?
06:08:14 <Cale> yes
06:10:05 <Taneb> :t ixmap ((,) (3 :: Int))
06:10:07 <lambdabot>     Couldn't match expected type `(i0, i0)'
06:10:07 <lambdabot>                 with actual type `b0 -> (a0, b0)'
06:10:07 <lambdabot>     In the return type of a call of `(,)'
06:10:16 <Taneb> :t ixmap undefined ((,) (3 :: Int))
06:10:17 <lambdabot> Ix i => Array (Int, i) e -> Array i e
06:11:41 <aCube> > splitEvery 10 $ Data.Foldable.toList $ listArray ((1,1), (10,10)) [1..]
06:11:43 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,...
06:11:53 <klrr> > 1 + 2
06:11:55 <lambdabot>   3
06:12:04 <klrr> > let b = 2
06:12:05 <lambdabot>   not an expression: `let b = 2'
06:12:10 <hseg> Is there a way to import an entire module, and then import one data constructor qualified?
06:12:19 <klrr> > let b = 2 in b+2
06:12:21 <lambdabot>   4
06:12:31 <hseg> s/and then import/such that/
06:12:41 <aCube> hseq: import M hiding (<Constructor>); import qualified M (Constructor) as X
06:13:26 <hseg> So in that case, everything in M except for Constructor will be unqualified, and Constructor can only be accessed as X.Constructor?
06:13:48 <aCube> yes
06:14:13 <hseg> It's a pity that disambiguation isn't done based on types. That would solve my problem, as both of my identifiers have different types.
06:14:20 <dmj> I'm attempting to print HTML using primitive recursion, and cannot seem to find the right way to align these functions. Any help is appreciated
06:14:26 <hpaste> dmj pasted “Print HTML, Recursion problems” at http://hpaste.org/85242
06:15:02 <hseg> i.e. given foo :: A and foo :: B, any occurence of foo is typechecked, and if it can be unified with precisely one of A,B, that instance is bound.
06:15:03 <dmj> esp in the primRecXML portion
06:15:23 <aCube> hseq: You could also define a class Foo a where foo :: a and then instance Foo String where foo = "Hello world"; instance Foo Int where foo = 42
06:15:35 <Zenol> Hi guys. I need your help. I have a function that take an integer and a list of length k, and build a new line of length k. I want this fonction to be called 1 000 000 times, each time with the index and the last computed list. How should I do? I tried a simple recursion bu the stack explode...
06:16:13 <hseg> Right, but that would overcomplicate things.
06:16:20 <hiptobecubic> Zenol, show some code. Paste at hpaste.org
06:16:34 <aCube> hseg: are the types / functions where you need this standard functions?
06:16:51 <quchen> dmj: That code is very haed to read without any comments. Also the lines are very long.
06:17:05 <hseg> In what sense? I'm defining two types with the same data constructor.
06:18:15 <aCube> I thought maybe you could use some predefined type classes (like Traversable or something), but in that case you have to use qualified imports if you don't want to rename the constructors
06:19:15 <hseg> Wouldn't make sense, as there is no other sensible name to give the constructor.
06:20:20 <ramses_> Zenol: you could try with until, I'd think that would use constant stack space
06:20:24 <ramses_> :t until
06:20:26 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
06:20:59 <Zenol> ramses_ > http://hpaste.org/85243 :)
06:21:19 <Zenol> ramses_ > I'll try this.
06:22:29 <ramses_> Zenol: you probably don't want to explicitly create that huge closure you mention in the comment
06:23:29 <hseg> It doesn't make sense that two identifiers with different types are considered indistinct if given the same name.
06:24:06 <hseg> Shouldn't it be possible to distinguish between two identically-named identifiers based on their type?
06:25:12 <marekw2143> hello, how can I check installed package version in ubuntu ?
06:26:29 <ramses_> @faq can Haskell check installed package version in Ubuntu?
06:26:29 <lambdabot> The answer is: Yes! Haskell can do that.
06:26:41 <ramses_> marekw2143: use Haskell ;)
06:27:43 <bartavelle> marekw2143, dpkg -l
06:27:56 <Clint> @hackage dpkg
06:27:56 <lambdabot> http://hackage.haskell.org/package/dpkg
06:28:32 <Breadmonster> I've been working through LYAH.
06:28:42 <Breadmonster> How do I implement trees in Haskell?
06:29:06 <ramses_> Breadmonster: lyah defines a binary tree somewhere
06:29:45 <hpaste> “slidegossip.com Pusatnya Pencarian Profil Artis, Model dan Talent” pasted “slidegossip.com Pusatnya Pencarian Profil Artis, Model dan Talent” at http://hpaste.org/85244
06:29:54 <hseg> GHCi chokes on the following line: import qualified Syntax.VM  (VMInst(Label)) as VM
06:32:15 <Breadmonster> Can Haskell be used for compilers?
06:32:37 <eikke> Breadmonster: of course
06:32:38 <hseg> What I'm trying to do is import the Label constructor for the VMInst type from the Syntax.VM module, where all references to it must be of the form VM.Label
06:32:54 <chrisdone> Breadmonster: haskell is especially good for compilers
06:32:57 <ramses_> Breadmonster: GHC is implemented in haskell
06:33:28 <Breadmonster> ramses_: Sure, that's because Haskell is Turing complete.
06:33:38 <Zenol> Out of memory, again...
06:33:44 <Breadmonster> chrisdone: Is it? I can't even figure out how to set up a binary tree, let alone parse.
06:33:49 <hpaste> “keretamini.com pabrik kereta mini no 1. ready stock” pasted “keretamini.com pabrik kereta mini no 1. ready stock” at http://hpaste.org/85245
06:33:56 <hseg> Breadmonster: I'm currently writing a compiler for a Java lookalike in Haskell. It's loads of fun.
06:33:57 <bscarlet> Could anyone out there with Cabal experience tell me if there's a "right" way to convey information from the configuration step to later steps?
06:34:11 <ramses_> Breadmonster: ? of course haskell is turing complete, but they wouldn't implement ghc in haskell if it wasn't suitable for it
06:34:18 <eikke> Breadmonster: actually I'm looking into creating a project to implement an ML-style compiler using Haskell, taking several research topics into account, and using some of the latest GHC features alongside
06:34:51 <hpaste> “Acer Iconia PC tablet dengan Windows 8” pasted “Acer Iconia PC tablet dengan Windows 8” at http://hpaste.org/85246
06:34:54 <ramses_> Zenol: stack or heap?
06:35:15 <chrisdone> Breadmonster: hmm perhaps that's your problem, not haskell's?
06:35:17 <eikke> looks like hpaste suffers from some pastebin-spam-bot?
06:35:20 <hpaste> “Mau Bikin Website + Hosting Murah AbizZ? Ke Rajawebhost.com aja!” pasted “Mau Bikin Website + Hosting Murah AbizZ? Ke Rajawebhost.com aja!” at http://hpaste.org/85247
06:35:27 <chrisdone> eikke: yeah, it is. hang on
06:35:49 <chrisdone> i'll ban the ip
06:36:16 <Zenol> ramses_ > stack.
06:36:20 <dmwit> bscarlet: What later steps?
06:36:32 <hiptobecubic> I don't even understand what these pastes are about
06:36:40 <hiptobecubic> bikini's *and* webhosting?
06:36:43 <Breadmonster> Okay, can someone guide me through it?
06:36:48 <aCube> > Node 1 [Node 2 [], Node 3 []]
06:36:50 <lambdabot>   Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []},Node...
06:36:55 <dmwit> bscarlet: Also, what does "right" way mean? It should just be automatic -- there's no choices, really.
06:37:00 <bscarlet> dmwit: build
06:37:11 <Breadmonster> eikke: How do you do parsing? I can't think of something that does parsing without side effects.
06:37:32 <dmwit> bscarlet: Can you make the question a bit more concrete? What problem are you having? What command do you run, what do you expect to happen, what happens instead? etc.
06:37:48 <eikke> Breadmonster: do some reading about parsec or uu-parsinglib
06:37:51 <bscarlet> dmwit: I have information that doesn't seem to fit into the types I've got.
06:37:56 <eikke> or alex/happy
06:38:12 <hseg> Breadmonster: By encapsulating the side effects in a monad/applicative instance. Have a look at Parsec.
06:38:19 <dmwit> bscarlet: I see, you are creating a cabal package?
06:38:49 <chrisdone> ok, bot banned
06:39:15 <bscarlet> dmwit: I'm working on LLVM bindings (more fleshed out than "llvm" on hackage). I want to run "llvm-config", a binary which can emit the various paths needed to build against llvm, and save them for use during building.
06:39:26 <bscarlet> dmwit: the problem is a path which doesn't belong in a flag.
06:39:33 <Breadmonster> eikke: Isn't parsec like yacc?
06:39:41 <chrisdone> Breadmonster: haskell's more 'controlled side effects' than 'no side-effects'
06:40:08 <Zenol> ramses_ > The whole code is here, if you wan't to have a look. It's pretty short and most of the code is just a uninteresting probabilistic calc. http://hpaste.org/85250
06:40:17 <hseg> No. Happy ~ yacc. Parsec is a parser combinator library - it allows you to combine smaller parsers into larger ones.
06:40:24 <eikke> bscarlet: you could check how bos/llvm does it
06:40:45 <Breadmonster> Okay.
06:41:42 <eikke> bscarlet: care to share what you intend to change compared to bos/llvm (next to 'make sure it works with latest LLVMs')?
06:41:57 <bscarlet> eikke: it uses autoconf, which I'm currently trying to avoid.
06:42:40 <bscarlet> eikke: Just to make sure of myself, by bos/llvm, you mean Brian O'Sullivan's package "llvm" on hackage, right?
06:42:48 <eikke> yes
06:43:07 <eikke> (or github.com/bos/llvm, hence)
06:45:38 <Zenol> How could the stack grow so much? Is it the use of list?
06:46:45 <dmwit> bscarlet: Probably the simplest thing is to write a custom Setup.hs that generates a file with whatever extra data you need, and reference this file as necessary during the build.
06:47:49 <dmwit> Zenol: I don't know the context, but typically a large stack is the result of too much laziness.
06:48:09 <bscarlet> eikke: That package has some interesting weaknesses: Firstly, because it attempts to use Haskell's typechecking to validate pointer math, it's actually impossible to emit some programs. Secondly it's a fairly thin lair on top of LLVM's interface, so it passes a whole lot of awkwardness of LLVMs c/c++ api structure through. Thirdly it (and LLVM's current C bindings) don't address consuming LLVM, only producing it. I've built
06:48:10 <bscarlet> pure haskell ADT to represent an LLVM module, and written all the goop to convert it to and from LLVM c++ objects.
06:48:45 <chrisdone> Zenol: 'stack' grows from function application. a lazy value is more or less a box that contains more function application, and more laziness. if your code is producing a bunch of laziness, stack overflow's likely. even x+y is a lazy value. (x+y)+z is one more layer of laziness. ghc does strictness analysis, but only in specific cases
06:49:11 <eikke> bscarlet: interesting
06:50:20 <chrisdone> Zenol: from a quick look, sum could be the problem, that's not strict in the addition
06:50:28 <chrisdone> (iirc)
06:50:30 <dmwit> Zenol: Personally, I suspect this use of until.
06:50:46 <dmwit> You're building an k-deep thunk which only gets forced at the very end.
06:50:57 <Zenol> dwit > I was using a simple recusion before, and that's why I tryed with until.
06:51:04 <chrisdone> where's until from?
06:51:07 <chrisdone> @src until
06:51:07 <lambdabot> until p f x | p x       = x
06:51:07 <lambdabot>             | otherwise = until p f (f x)
06:51:37 <chrisdone> well i be damned. how long's that been there?
06:51:48 <dmwit> Zenol: Shipping your recursion out to somebody else doesn't suddenly make your recursion strict...
06:52:00 <bscarlet> dmwit: Could I interpret that very loosely to mean that if information doesn't have an obvious place to live inside the Cabal datatypes, I should roll my own serialization/deserialization to carry it from one step to another? I was optimistically hoping there was some generic mechanism that did it for me. (Perhaps that'd require undesirable extensions (RankNTypes or such)).
06:52:31 <dmwit> bscarlet: It depends very much on what the information is. Generating header files (for example) and #include'ing them is very common.
06:53:02 <zmoazeni> Hi folks, I'm trying to install the "hoogle" cabal, but I'm running into a dependency issue. I'm trying to grok what the real issue is without much success https://gist.github.com/zmoazeni/bd9dec6fd5dc74f36940
06:53:06 <dmwit> Others may have better advice, too. I'm not an expert. But I'm here. =P
06:53:11 <bscarlet> eikke: My aim is to make using LLVM for a compiler backend or for JIT as simple as one might naively wish it to be.
06:53:29 <Zenol> The sum is over 4 values (made with zipWith) :/
06:53:42 <chrisdone> Zenol: ah, ok
06:53:49 <zmoazeni> resourcet needs mtl (≥2.0 & <2.2) and parsec doesn't seem to have a restriction on mtl. I'm not sure why I'm getting this error
06:53:49 <Zenol> http://hpaste.org/85251 Here is what I was doing at the begining.
06:53:53 <eikke> bscarlet: then I'd be very interested since I intend to use LLVM as a target for my ML thing :) (and having issues with bos/llvm not building without patches lately, or working at all)
06:54:43 <chrisdone> Zenol: well until is strict in its application. so it may be these: (m + 1, 0 : 0 : compute_next_step k (m+1) l)
06:54:43 <hseg> Is there a way to make GHC disambiguate between identifiers based on type? i.e. foo :: Int is distinct from foo :: Char, and both can exist in the same scope
06:55:07 <dmwit> zmoazeni: Your installed version of parsec depends on your installed version of mtl.
06:55:18 <dmwit> hseg: Yes, that is what typeclasses are.
06:55:38 <bscarlet> dmwit: Being here is a fantastic qualification as far as I'm concerned at the moment. My particular information is a path for use as an (DY)LD_LIBRARY_PATH, which needs to be available not only when producing final executables, but when running hsc2hs intermediate executables also.
06:55:47 <chrisdone> Zenol: if you have 10000 interations, then your m + 1 will be a thunk like
06:55:47 <chrisdone> > "(m + " ++ cycle "1) "
06:55:49 <lambdabot>   "(m + 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) ...
06:56:07 <dmwit> chrisdone: My bet is the problem is in the other half of the tuple.
06:56:09 <hseg> I don't see how I can solve the problem using typeclasses.
06:56:19 <zmoazeni> dmwit: Sorry, trying to understand. I have both "Installed versions: 3.1.2, 3.1.3" and according to http://hackage.haskell.org/package/parsec-3.1.3 it doesn't have any version requirements on mtl
06:56:20 <dmwit> chrisdone: The first half is getting forced by the predicate in until; the second half isn't.
06:56:25 <quicksilver> chrisdone: (where your first '(' is an infinite number of very thin (s pressed together ;)
06:56:34 <Zenol>  I want to apply 1 000 000 times the function compte_next_step on a list (each time with the right m values from 1 to 1 000 000. I don't know how to do it well.
06:56:35 <chrisdone> dmwit: on the recursion part, yeah
06:56:38 <chrisdone> quicksilver: yeah =p
06:56:43 <hseg> Basically, I have two data constructors named identically, for two different types.
06:56:49 <chrisdone> dmwit: good call =)
06:56:56 <quicksilver> chrisdone: it's really hard to put those in place without tearing, I find.
06:57:03 <dmwit> zmoazeni: Haskell is statically linked. Your installation of parsec is therefore dependent on exactly one version of mtl, regardless of what Hackage says about what versions you can choose to link it to when you build it.
06:57:35 <Zenol> In imperativ language it should be a simple for to compute the next array from the previous one, but here I'm stick with recursion that seems to not being optimised as a tail rec...
06:57:52 <dmwit> hseg: Data constructors can be part of a type class by turning on associated types.
06:57:53 <zmoazeni> dmwit: Oh I see. So even though parsec.cabal doesn't require a specific version of mtl, it gets locked down when I install (and it becomes linked)
06:58:04 <dmwit> zmoazeni: correct
06:58:06 <chrisdone> quicksilver: quality infinite parentheses are harder to find these days
06:58:12 <dcoutts> zmoazeni: no, that's not how it works
06:58:23 <bscarlet> eikke: Well, I've got enough working that you'd probably be able to use what I've got, but I've still got to get it rolled up into a Cabal package that works for someone other than me. In the (unfortunately indefinite) meantime, there are some forks of bos/llvm on github that might help you.
06:58:39 <dcoutts> zmoazeni: well, yes installed ones need specific things, but cabal can look at source versions and rebuild if necessary
06:58:59 <dmwit> Oh yeah, we didn't get to the "how to fix it" part yet. =P
06:58:59 <zmoazeni> dcoutts: Any reason why cabal isn't rebuilding in this case? I would assume it should be able to
06:59:17 <eikke> bscarlet: I know about those, but it's a pita to work that way :) I hope bos finds some maintenance time soon'ish to get things in shape again
06:59:26 <dcoutts> zmoazeni: can you run with --max-backjumps=-1 and see if the log looks any different?
06:59:34 <zmoazeni> dcoutts: sure. trying now.
06:59:44 <dmwit> bscarlet: Hm, tricky.
07:00:00 <quicksilver> dmwit: (I hesitate to insert asides into this, but static linking is neither here nor there. Even if the libraries were dynamically linked, the knowledge of each other's ABI would be compiled in; haskell libraries don't have stable ABIs in that sense)
07:00:27 <bscarlet> dmwit: What's tricky? Passing my information, or the generic mechanism I wish I had?
07:00:39 <dmwit> quicksilver: Aha. I was nervous about the "statically linked" part of my explanation. I'm interested to learn that the same situation would happen with dynamically linked world.
07:00:42 <hseg> I don't get it. I have data A = A | S; data B = B | S. How do I make GHC disambiguate between S :: A and S :: B ?
07:00:51 <dmwit> bscarlet: Needing to pass things to hsc2hs is tricky.
07:00:53 <dmwit> I think.
07:01:08 <dmwit> Because cabal does magic with a few particular preprocessors.
07:01:16 <Taneb> hseg, you don't
07:01:24 <quicksilver> dmwit: for example, a constant might be fully inlined. Even in a dynamically linked library. That's just the most trivial example, but the point is that GHC compilation couples tightly.
07:01:24 <zmoazeni> dcoutts: Looks like this will work https://gist.github.com/zmoazeni/edfbf9e7c465c1732434 not sure why leveldb would be broken, but I can dig into that - is this because a "dependency of my dependency" needs updating and by default it doesn't dig that far?
07:01:24 <Taneb> Put them in different modules and qualify
07:02:04 <hseg> I tried. GHC choked on the following line: import qualified Syntax.VM  (VMInst(Label)) as VM
07:02:24 <hseg> Something about 'as' being unexpected
07:02:31 <dcoutts> zmoazeni: it does look like that'll work.
07:02:46 <dmwit> hseg: Right, I think qualified imports can't specify an import list.
07:03:12 <dcoutts> zmoazeni: so here the solution was above the default search size, so it reported the initial error
07:03:22 <narens> question: what library do I use if I want a mutable bytestring?
07:03:40 <dcoutts> narens: array or vector
07:03:48 <dcoutts> both have mutable versions
07:03:58 <bscarlet> dmwit: Ah. Yes. Cabal does a bit more magic that I, personally, like. I have successfully gotten information to hs2hsc by setting an environment variable to a hardcoded variable at the beginning of the build hook. It's getting the information from the configure step to there that's giving me trouble.
07:04:01 <hseg> OK. Now I have more fun problems
07:04:09 <narens> dcoutts: but I want to have a bytestring after mutating
07:04:16 <bscarlet> dmwit: s/hardcoded variable/hardcoded value/
07:04:22 <narens> dcoutts: is there a way to freeze vector into a bytestring?
07:04:36 <supki> hseg: import qualified M as N (...)  not  import qualified M (...) as N
07:04:42 <zmoazeni> dcoutts, dmwit thanks a bunch. that would have taken me forever
07:05:06 <dcoutts> narens: then you have to convert or copy. You might be able to do it without copying if you use a foreign array
07:05:21 <dcoutts> narens: or if you do something much more ugly and low level
07:05:22 <dmwit> bscarlet: I'm not sure, but I think extra-lib-dirs and include-dirs get passed on to preprocessors.
07:05:27 <Taneb> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
07:05:27 <lambdabot> f a b c = a (\ d -> b d c)
07:05:29 <dmwit> bscarlet: (The documentation at least seems to suggest this.)
07:05:38 <dmwit> bscarlet: So perhaps you can use the API to set those during configure...?
07:05:49 <narens> dcoutts: that's crazy... why!!! The reason i need bystring is because all the hashing libraries i can find work on bytestring
07:05:49 <dmwit> oops, fire drill, gotta run
07:05:52 <dmwit> ask dcoutts, he's the expert
07:06:36 <bscarlet> dmwit: Those don't get used in quite the right place.
07:06:48 <dcoutts> narens: are you just trying to build one efficiently?
07:07:18 <narens> dcoutts: I want to do a simply swap of two word positions in a bytestring... like i can do in a mutable vector
07:07:34 <dcoutts> narens: starting with a bytestring?
07:07:41 <narens> dcoutts: yes
07:07:53 <dcoutts> narens: then you have to do it by copying anyway
07:08:01 <dcoutts> mutablity will not help you
07:08:02 <bscarlet> dmwit: extra-lib-dirs can get hsc2hs to find the libraries during linking, the problem is when the hsc2hs binary runs to produce the haskell code.
07:08:05 <eikke> narens: you might be able to use unsafePackAddressLen to create a bytestring from an addr/pointer, and get a pointer from your unboxed vector somehow
07:08:30 <Zenol> How to write {type data; for (i = 0 ; i < n; i++) {data = somework(i, data);}} in haskell? Isn't it {apply_somework 0 = data; apply_somework n = somework n (apply_somework (n-1))} ?
07:08:33 <narens> that's messed up... why this lack of orthogonality?
07:08:48 <dcoutts> narens: because if your output has to be a bytestring (immutable) and your input is a bytestring (immutable) then you can only do that by copying
07:09:05 <dcoutts> even if we provided a separate mutable bytestring type
07:09:05 <metaweta> Hi.  I'm very new to Haskell and Scala and have been tasked with getting Oleg's generic zippers working under Scala
07:09:11 <eikke> narens: using Vector.Storable & unsafeToForeignPtr0
07:09:15 <dcoutts> you'd still have to pay one copy
07:09:17 <metaweta> In this line: f a = shift (\k -> return $ Z a (k . maybe a id))
07:09:36 <dcoutts> narens: I suggest you build the result bytestring using the new builder, that will be efficient
07:09:52 <narens> dcoutts: the only other way is to use usafeconvert of bytestring to cstring and modify that ... but i'd lose ref transparency
07:10:10 <dcoutts> narens: that would break the immutability of the type, so don't do that
07:10:14 <metaweta> it uses "maybe"; that's not the type constructor.  What is it?
07:10:33 <geekosaur> it "un-Maybe"s
07:10:50 <geekosaur> you provide a thing to do to a Just and a default if it's Nothing
07:10:52 <geekosaur> :t maybe
07:10:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:10:58 <dcoutts> narens: take a look at the bytestring builder monoid, that lets you make new bytestrings efficiently
07:11:00 <bscarlet> dmwit: Anyway, I think you've convinced me to try just running the llvm-config binary again at the beginning of the build. It's barely more than a file with the necessary information in it anyway.
07:11:20 <metaweta> Ah, it's scala's getOrElse.  Thanks!
07:11:21 <narens> dcoutts: well, i personally like the vector package for this kind of manipulation but I just don't want to convert vector to bytestring just to hash it...unless that conversion is done lazily then it might be okay
07:12:30 <eikke> narens: there was someone working on a bytestring version based on unboxed word8 vectors
07:12:35 <eikke> @hackage vector-bytestring
07:12:35 <lambdabot> http://hackage.haskell.org/package/vector-bytestring
07:13:35 <narens> thanks, I think converting vector to bytestring should be just fine since that process doesn't need to allocate any space for my case since it will be consumed lazily anyhow.
07:16:07 <Zenol> Again, Maybe it's because I'm using list, and as they are lazy, to build the last one, at has to go through the 1 000 000 list I was talking about, and that's too much thunks...
07:17:48 <Breadmonster> What's the difference between let and where?
07:18:43 <bscarlet> Breadmonster: http://www.haskell.org/haskellwiki/Let_vs._Where
07:25:04 <dmwit> Zenol: Yes, I believe that description is accurate.
07:26:01 <dmwit> Zenol: You might like to write deepSeqIterate or something like that. e.g.
07:26:45 <aCube> also, C     time      82.8% :O
07:26:49 <aCube> also, GC     time      82.8% :O
07:26:55 <dmwit> :t let strictify xs@(x:_) = x `deepSeq` xs in \f x -> strictify (iterate f x)
07:26:56 <lambdabot>     Not in scope: `deepSeq'
07:26:56 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
07:27:06 <dmwit> :t rdeepseq
07:27:07 <lambdabot> NFData a => Strategy a
07:27:10 <dmwit> :t deepseq
07:27:11 <lambdabot>     Not in scope: `deepseq'
07:27:11 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
07:27:15 <dmwit> ?hoogle deepseq
07:27:15 <lambdabot> Control.DeepSeq module Control.DeepSeq
07:27:15 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
07:27:15 <lambdabot> package deepseq
07:27:30 <Zenol> NFData?
07:27:33 <dmwit> :t let strictify xs@(x:_) = x `Control.DeepSeq.deepseq` xs in \f x -> strictify (iterate f x)
07:27:34 <lambdabot> NFData a => (a -> a) -> a -> [a]
07:27:46 <Zenol> Maybe just using some non-lazy list?
07:27:49 <dmwit> NFData is data that can be evaluated to normal-form.
07:28:11 <dmwit> No, the laziness of the values contained in the iteration is not the really important thing here.
07:28:18 <dmwit> The laziness of the iteration itself is the problem.
07:28:37 <dmwit> I guess that's not 100% accurate.
07:28:45 <dmwit> The laziness of the values contained in the iteration matters, too.
07:29:03 * hackagebot cmdargs 0.10.3 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.3 (NeilMitchell)
07:29:07 <dmwit> Oh, that's a crappy strictify, too.
07:29:16 <Zenol> It's the laziness of the values and the iteration together?
07:29:30 <dmwit> :t let strictify (x:xs) = x `seq` (x:strictify xs) in \f x -> strictify (iterate f x)
07:29:31 <lambdabot> (a -> a) -> a -> [a]
07:29:44 <dmwit> Zenol: yeah
07:29:50 <dmwit> :t let strictify (x:xs) = x `deepseq` (x:strictify xs) in \f x -> strictify (iterate f x)
07:29:52 <lambdabot>     Not in scope: `deepseq'
07:29:52 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
07:29:56 * dmwit sighs
07:29:58 <dmwit> You get the idea.
07:31:20 <Zenol> And, it's easy to remov the "laziness" using something that will make sure something was evaluated bofore semething else?
07:31:58 <dmwit> Sure.
07:32:26 <Zenol> Actualy, I'm a beginner at haskell, I don't know what you can/can't do x)
07:32:41 <dmwit> =)
07:32:57 <shallowthought> to paraphrase zombocom... you can do anything with haskell
07:33:04 <dmwit> Anyway, yes, I suggest you use a strict iteration like the one above, and skip "until" entirely.
07:35:23 <Zenol> not sure to understand how to use it ...
07:35:50 <dmwit> > iterate (*2) 1 !! 30
07:35:51 <lambdabot>   1073741824
07:36:45 <dmwit> That iterates the step function (*2) 30 times starting at 1.
07:37:17 <hseg> I'm getting a Non type-variable argument in the constraint error in the following code:
07:37:20 <hpaste> hseg pasted “Type signature woes” at http://hpaste.org/85255
07:37:42 <dmwit> > let strictify (x:xs) = x `Control.DeepSeq.deepseq` (x:strictify xs) in strictify (iterate (*2) 1) !! 30 -- same, but each iteration is strict
07:37:44 <lambdabot>   Not in scope: `Control.DeepSeq.deepseq'
07:37:49 <dmwit> yes =)
07:38:36 <dmwit> hseg: The error should suggest the correct fix here.
07:39:00 <dmwit> Like, the error literally contains a suggestion which is also the correct fix.
07:39:07 <hseg> It's suggesting FlexibleContexts. But I have no idea what that is nor why what I wrote is wrong.
07:39:27 <dmwit> To use an extension, add {-# LANGUAGE FlexibleContexts #-} at the top of your file.
07:39:49 <dmwit> The reason what you wrote is wrong is nothing deep; there's just a stupid syntactic constraint on Haskell that was put in place before it was known how hard typeclasses would be to implement.
07:40:30 <dmwit> (It turns out it wasn't too hard, and so GHC relaxed this constraint. But it's not in the standard, so you have to explicitly ask for the relaxed version.)
07:41:29 <hseg> OK. From looking around, it's basically because I used a non-type variable as a parameter to one of the typeclasses?
07:42:45 <dmwit> correct
07:43:19 <hseg> Seems like a rather arbitrary restriction to place on the constraints, as you already noted.
07:43:48 <quicksilver> it's not actualy arbitrary
07:43:55 <quicksilver> it just turned out to be shortsighted :)
07:44:18 <quicksilver> a fairly simple view of polymorphism suggested that "all useful instances" would naturally take a particular simple form
07:44:32 <quicksilver> because of the universal properties of polymorphism
07:45:00 <quicksilver> but various changes to the language since then, and just interesting programming ideas, proved that actually plenty of useful instances don't take that form after all.
07:45:04 <dolio> It's almost exactly like limiting yourself to one level of matching in each case statement.
07:45:28 <dolio> Except that you can't nest the matches with type classes.
07:45:37 <dolio> Which makes it a lot more inconvenient.
07:46:17 <quicksilver> you hit the problems much much more often with MPTCs though
07:46:25 <quicksilver> and they didn't have MPTCs when they were making the rule.
07:47:06 <quicksilver> (well, I'm conflating FlexibleContraints and FlexibleInstances in my head a bit - they're related restrictions)
07:48:16 <jdnavarro> I have a simple zipper for manipulating rose trees that lets me do anything I need to do efficiently
07:49:00 <jdnavarro> but the rose trees I need to work on are huge and won't fit in memory, is there any way to use a zipper with data stored in disk?
07:50:05 <jdnavarro> should I just avoid the zipper pattern in this case and go with a key-value store?
07:50:13 <dmwit> http://hackage.haskell.org/package/swapper ?
07:54:56 <jdnavarro> dmwit, swapper looks like what I want, unfortunately it has obsolete dependencies
07:55:04 <dmwit> ah, dang
07:55:19 <dmwit> You could try just bumping the numbers. If it builds, it probably still works.
07:57:10 <jdnavarro> I'll try that and have a look to the code, it looks like it's trying to solve the same problem I have
08:00:49 <hseg> OK, thanks a lot guys. Need to go.
08:09:18 <Zenol> dwit > Thanks, I think it's working :)
08:16:07 <Sculptor> yo
08:16:14 <Taneb> Hey
08:22:52 <latermuse> hey I made a game using GHCI as the engine
08:22:56 <hpaste> latermuse pasted “GHCI Game Engine” at http://hpaste.org/85256
08:23:41 <latermuse> this 'game' doesnt work correctly when it is compiled. it only works in ghci. do you guys have any idea how to get it working after compiling it?
08:24:03 <Cale> latermuse: It's probably just because the buffering on stdin is different
08:24:34 <Cale> Try hSetBuffering stdin NoBuffering at the start of main.
08:24:50 <Cale> and  import System.IO  at the top under the module declaration
08:26:14 <Cale> latermuse: yep, that works
08:26:51 <latermuse> cale: Thanks cale!
08:28:31 <latermuse> is there any way to build a haskell binary and have it run on a machine without GHC installed?
08:29:07 * hackagebot crypto-conduit 0.5.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.1 (FelipeLessa)
08:29:12 <Cale> It should do so normally.
08:29:40 <Cale> If it's on linux, you can run ldd on the executable to see what's required.
08:30:22 <latermuse> Cale: Let me give that a try real quick.
08:30:25 <Cale> (it's not much)
08:31:14 <latermuse> Cale: this changes everything. thanks again cale
08:31:21 <Cale> no problem
08:31:36 <latermuse> installing haskell on my bsd machines is such a pain. now ill just compile once then distribute to all the machines
08:32:37 <Cale> Yeah, also if you're compiling GHC yourself, you should probably try to avoid that unless you're actually hacking on it.
08:33:30 <Cale> (or if you can't get a current binary, but then... you should probably contribute whatever binary you ended up with to the GHC folks so others don't have to compile)
08:33:34 <geekosaur> Cale: bsd ports installs pretty much everything from source
08:33:58 <Cale> geekosaur: That's a really dumb policy when it comes to GHC, because you need a binary GHC to compile GHC.
08:34:00 <latermuse> geekosaur: yeah unfortunately
08:34:14 <geekosaur> yeh, last I checked there was an older ghc binary port just to bootstrap
08:34:18 <latermuse> cale: yes, i have to install a lot of GHC until i finally get the version I want
08:34:39 <latermuse> install 6.1 or something, then you can use that to bootstrap up to 7.4
08:34:40 <Cale> geekosaur: Which in itself is pretty stupid, because then why not just have the current binary? :P
08:35:07 <geekosaur> there are packages, they're just not updated as often. as for the bootstrap binary, it's minimal
08:35:53 <Cale> Even if you're going to compile, you'd likely be better off starting from a current GHC, in the hopes that it produces better code than the older ones.
08:36:38 <Jambato> hm how can I make State an instance of Show? as if I wanted to print the state
08:36:40 <Cale> (well, I believe it rebuilds itself as part of the process anyway, but still)
08:36:54 <Cale> Jambato: What is State?
08:37:17 <Cale> Jambato: Is that a type you defined?
08:37:35 <Jambato> Cale: it's the State monad
08:37:35 <Cale> Or do you mean make State monad computations showable?
08:37:46 <Jambato> that's it
08:37:52 <Cale> That's not really possible because they're internally functions
08:38:10 <Cale> which are pretty much inscrutable, apart from applying them to a bunch of values and seeing what comes out
08:38:42 <Jambato> so I have to runState something before printing its result
08:38:47 <Hermit> yep
08:38:58 <Cale> That's right
08:39:47 <Cale> If there were a way to print the computation, it would have to be displayed as a function of the input state
08:40:07 <Cale> (i.e. it would involve a big lambda)
08:40:35 <Cale> But the machinery necessary to make lambdas printable would slow down every program horribly.
08:41:28 <Cale> That is, printable in a really meaningful way -- it's easy to make a Show instance which turns them into "<function>" or something
08:41:37 <ocharles> Cale: well, there are techniques to reify some functions, I thought?
08:41:46 <Cale> some, for sure
08:41:47 <ocharles> they are probably not general though
08:41:58 <ocharles> general enough*
08:42:07 <Cale> If the domain is finite, you can enumerate all the values
08:42:12 <Cale> (and the function is total)
08:42:14 <ocharles> right
08:42:53 <hiptobecubic> Does anyone remember that library that could give you an implementation of a function based on test output?
08:43:00 <bscarlet> Cale: What approach are you thinking of for printing lambdas that would work but would slow things down? Is there no way to be sufficiently lazy about the slowness that it wouldn't matter?
08:50:29 <Cale> bscarlet: At best, it'd involve keeping track of an additional pointer everywhere
08:51:20 <tsinnema> hey -- i've read some discussion on record types that end up giving up row polymorphism and i believe someone said on #haskell that row polymorphism is 'teh hard'. what are some of the problems that come up?
08:51:29 <tsinnema> i was pointed to edwardk's lens work possibly dealing with these but after some looking, if there's a connection, i need more elaborate hints to what it is
08:51:29 <Cale> bscarlet: But also, there's the semantic problem, that we don't actually want the code to be able to tell apart functions which are the same but implemented differently
08:51:45 <Cale> bscarlet: So you'd be taking a performance hit in order to be able to ruin your semantics
08:52:00 <fryguybob> Cale: I looked into that STM issue you were looking at the other night, and I think it is a bug.  You didn't report it right?
08:52:28 <Cale> fryguybob: I didn't report it
08:52:40 <Cale> fryguybob: I was fairly convinced that it was a bug too
08:53:03 <fryguybob> Cale: Ok, I'll write it up.  I have a way to fix it, I just need to be sure it is right :D.
08:53:10 <Cale> fryguybob: But sufficiently distracted that I wasn't quite sure enough that there wasn't just something I had overlooked at the time.
08:53:37 <Mortchek> Cale, is it proven that there is no general method of discovering if two given functions behave identically?
08:53:38 <Cale> fryguybob: Oh cool, what exactly is going wrong?
08:53:43 <fryguybob> You can also avoid it by using Int's instead of Bool and making both the cat and dog transactions write both variables.
08:53:49 <Cale> Mortchek: yeah
08:53:51 <bscarlet> Cale: How would the semantics be ruined?
08:54:03 <Mortchek> Cale, what's the proof called?
08:54:37 <fryguybob> Cale: The validation read phase thing is a little funky.  It appears to historically come from algorithms that were more involved, killing off other transactions.
08:54:58 <fryguybob> Haskell doesn't do that, so it isn't clear why some of that machinery is around still.
08:55:10 <djahandarie> tsinnema, I think it may have been me that said that. I'm actually not sure how hard it is, I just remember seeing a bunch of more-complicated-than usual inference rules for the type system edwardk & co. came up with that does row polymorphism.
08:55:24 <djahandarie> I only saw them for a total of like 5 minutes though so maybe it's not so bad.
08:56:24 <Cale> bscarlet: You could have a functions f, g, h, such that f x = g x for every x, but where h f is not equal to h g
08:56:49 <Cale> bscarlet: i.e. you'd destroy extensionality
08:57:41 <bscarlet> Cale: Got it. Thanks.
08:57:53 <tsinnema> djahandarie, ok. fwiw (this is old) http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html talks of how polymorphic extension is not implemented without going into specifics, and none of the haskell record libraries i've come across so far do row polymorphism
08:58:23 <tsinnema> even though it'd seem like a very nice feature to have
08:58:29 <Cale> Mortchek: hmm, not sure it has a name -- incomputability of function equality?
08:58:58 <tsinnema> so i would also presume that some degree of teh hardness is involved
08:59:31 <edwardk> tsinnema: its nice. its also hard to assign good semantics for that are efficient, and for the kinds of row polymorphism that i want, inference is quite difficult
09:00:26 <tsinnema> ok yeah, i hadn't even thought of inference yet
09:00:50 <Cale> Mortchek: Oh, maybe you could say that it's a corollary of Rice's theorem.
09:03:46 <Cale> http://en.wikipedia.org/wiki/Rice%27s_theorem#Formal_statement
09:04:00 <Cale> (the formal statement is much easier to understand than the informal one)
09:07:40 <Mortchek> What does it mean for an algorithm to compute a function?
09:07:51 <Cale> Mortchek: Suppose you give me a way to compute equality on functions. Then I can write  halts f = (\x -> f x `seq` 1) == (const 1), and I have a program to solve the halting problem.
09:08:37 <xj54y> cale, may I PM you?
09:08:47 <Cale> xj54y: I suppose
09:09:09 * hackagebot tableaux 0.2 - An interactive theorem prover based on semantic tableaux  http://hackage.haskell.org/package/tableaux-0.2 (PedroVasconcelos)
09:09:34 <Mortchek> Cale, I don't see why that wouldn't just diverge if f diverges.
09:09:37 <Cale> xj54y: Are you just wondering, or are you actually going to send me a pm? :)
09:10:59 <Cale> Mortchek: Because you were supposed to have provided an equality test for functions which terminates
09:11:15 <Mortchek> Where did we imply termination?
09:11:36 <Cale> Well, if it doesn't have to terminate, then it could just always not terminate
09:11:40 <Cale> Is that satisfying?
09:13:09 <Mortchek> Not really, but we take that risk in Haskell anyway. Removing bottom is non-trivial.
09:16:23 <Cale> Well, what are we trying to do? Compute equality of total functions? That's also not in general possible (but it is possible of course for certain domains, and even certain infinite ones!)
09:18:11 <Mortchek> I notice Rice's Theorem says "effective" method. Is that as opposed to, say, iterating over every mapping from argument to result, as we could easily do with finite domain and codomain?
09:18:28 <Mortchek> Or finite domain, anyway.
09:19:08 <Philippa> isn't that usually another way of saying computable?
09:19:25 <Mortchek> Is it?
09:19:30 * Mortchek doesn't know.
09:19:56 <dmwit> Yes, it is. Some other comments about your question:
09:20:44 <dmwit> Rice's Theorem is an intensional one. It's asking about a property of Turing machines, not a property of functions. Iterating over every mapping is not iterating over every Turing machine.
09:21:11 <dmwit> And, anyway, the domains and codomains involved if we were to talk about things in that way aren't finite.
09:21:31 <dmwit> s/aren't/aren't necessarily/
09:21:53 <Mortchek> Sure, we're talking about potentially infinite domains, which means the method I proposed of comparing for equality wouldn't work for *all* functions.
09:22:34 <dmwit> Please refer back to complaint one. =)
09:22:50 <Mortchek> Yep.
09:23:51 <int-e> dmwit: But it's both extensional and intensional. The properties that it talks about are defined extensionally; if two programs define the same function, they should either both have the property or both not have it.
09:24:10 <int-e> excluding properties like "this turing machine has an odd number of states."
09:24:28 <dmwit> You're right. My wording was a bit sloppy.
09:24:42 <Cale> Well, if you want to be picky in that particular way, then equality comparison of *functions* is something which isn't necessarily even a computational consideration, because functions are part of our mathematical model of the behaviour of these programs, and there might not be a notion of what's computable which really applies out there.
09:26:11 <Mortchek> What's a model that's almost a Turing machine but for which you can assert whether it halts?
09:27:00 <hpaste> Jambato pasted “ ” at http://hpaste.org/85259
09:27:24 <Jambato> I feel like I put too much stateful things in there
09:28:03 <TheMG> what's a good word for the type of function you give map?
09:28:04 <Jambato> how can I update nested state monadic values?
09:28:19 <dmwit> TheMG: "function"?
09:28:26 <Jambato> TheMG: Functor?
09:28:33 <Mortchek> @type map
09:28:34 <lambdabot> (a -> b) -> [a] -> [b]
09:28:35 <dmwit> (You can give map *any* function. What do you mean?)
09:28:42 <Mortchek> The first argument to map is any function whatsoever
09:28:51 <Mortchek> That's literally the most general case of function
09:29:02 <TheMG> in the same way you might call the function given to filter "predicate"
09:29:09 * hackagebot git-annex 4.20130405 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130405 (JoeyHess)
09:29:14 <Mortchek> "mapper", perhaps?
09:29:35 <geekosaur> sounds like someone may not have figured out the pointof "functional" in "functional language"
09:29:35 <TheMG> is there not already a word for this? i feel like there's a word
09:29:39 <dmwit> TheMG: Right, but "the function given to filter" is more specific than "the function given to map".
09:29:48 <geekosaur> there are words for it... in languages where it is not a first class operation
09:29:57 <TheMG> such as?
09:29:58 <geekosaur> s/in/for/
09:30:37 <dmwit> Seriously, just call it a function. There's no better word for it.
09:31:07 <geekosaur> but, I'm not sure which aspect of it you're trying to capture. it's a function. it may be a partially applied function or a section or a lambda
09:31:24 <TheMG> the aspect of it being given to map
09:31:26 <Cale> Jambato: map *itself* is half of a functor
09:31:42 <hiptobecubic> TheMG, it makes "map" a higher order function?
09:31:43 <Cale> Jambato: (the other half being the list type constructor)
09:31:45 <hiptobecubic> maybe that's it?
09:32:05 <Cale> Jambato: but the parameter to map isn't a functor, it's just a function.
09:32:06 <hiptobecubic> TheMG, in C++, the function given to map would be called a 'functor'. But that's just because they are idiots.
09:32:07 <geekosaur> in objective C you would usually use a block
09:32:09 <TheMG> i think functor is the closest there is
09:32:26 <dmwit> Mortchek: That's a good question. I can't think of any where the decision procedure isn't the trivial "always return True" one.
09:33:04 <Cale> TheMG: Calling representations of functions "functors" is a horrible practice because it directly conflicts with the common notion of functor from mathematics
09:33:27 <Mortchek> Like the language that computes the result of adding numbers together :) halts(1+2) = True, halts(3+8+10) = True, halts(_) = True
09:33:29 <dmwit> Mortchek: Except perhaps the HQ9+ machine. ;-)
09:33:47 <Mortchek> Haven't heard of that, I shall look it up.
09:34:10 <Mortchek> Ahaha, nice.
09:34:20 <dmwit> Mortchek: HQ9+ has four commands, h (print "hello world"), q (be a quine), 9 (print "99 bottles of beer"), and + (infinitely increase an accumulator).
09:34:36 <dmwit> halts s = '+' `elem` s
09:34:37 <dmwit> ;-)
09:35:23 <Mortchek> dmwit, that's partial. :P
09:35:25 <Mortchek> halts(10) = ?
09:35:32 <Mortchek> Wait no
09:35:35 <Mortchek> s/partial/incorrect/
09:35:42 <Jambato> Cale: ah yeah. misunderstood what TheMG asked
09:35:46 <Jambato> my bad
09:36:05 <dmwit> > let halts s = '+' `elem` s in halts "10"
09:36:06 <quchen> It's total for finite programs
09:36:06 <lambdabot>   False
09:36:11 <geekosaur> halts _ = "answer hazy, ask again later"
09:36:26 <dmwit> Mortchek: You're right, it should be notElem.
09:36:32 <dmwit> > let halts s = '+' `notElem` s in halts "10"
09:36:34 <lambdabot>   True
09:36:43 <dmwit> There we go. Looks perfectly cromulent to me.
09:37:04 <Mortchek> The language I described halts regardless of the program's contents, as long as the program is well formed.
09:37:42 <dmwit> The language I described halts exactly when '+' is in the program's contents.
09:37:47 <dmwit> Your move, Mortchek.
09:38:00 <Mortchek> Oh I see, we were describing separate languages. :P
09:38:28 <Mortchek> Well, trying to describe.
09:38:43 <Mortchek> ("describing" was true regardless)
09:39:55 <Mortchek> > let run s | '+' `elem` s -> True | _ -> run s in run "foo"
09:39:57 <lambdabot>   <hint>:1:26: parse error on input `->'
09:40:13 <Mortchek> Oh woop
09:40:20 <Mortchek> > let run s | '+' `elem` s = True | _ = run s in run "foo"
09:40:22 <lambdabot>   Pattern syntax in expression context: _
09:40:29 <Mortchek> I am silly.
09:40:33 <Mortchek> > let run s | '+' `elem` s = True | otherwise = run s in run "foo"
09:40:36 <dmwit> let _ = otherwise
09:40:37 <lambdabot>   mueval-core: Time limit exceeded
09:40:40 <Mortchek> \o/
09:46:10 <wabash> Holy shit.
09:46:13 <adek> I have enumerated type qualified imported. When I try to do [Q.A..Q.Z] it fails to compile. When I do [(Q.A)..(Q.Z)] its ok, but hlint complains about parenthasis. Can it be done better?
09:46:18 <wabash> How did this channel get so many people???
09:46:25 <wabash> It was like 500 people 3 years ago.
09:46:30 <oab> most are trolls
09:46:54 <oab> ^^
09:47:17 <wabash> haha
09:47:18 <geekosaur> [Q.A .. Q.Z] ?
09:47:24 <wabash> Wish I knew Haskell!
09:47:25 <wabash> :)
09:47:30 <wabash> How is the job market in Haskell?
09:47:31 <Mortchek> @where lyah
09:47:31 <lambdabot> http://www.learnyouahaskell.com/
09:48:20 <adek> geekosaur: So easy.. Thanks!
09:48:44 <oab> Well at least there are some. Would be nice with more. The market will be flooded with haskell jobs any time now.
09:48:54 <oab> Surely.
09:49:04 <wabash> hehe
09:49:06 <wabash> cool thanks.
09:49:20 <quchen> oab: Flooded?
09:49:22 <glguy> oab: Got any hot stock market tips?
09:49:26 <quchen> Why's that
09:49:49 <oab> Well Haskell has 3 web frameworks now
09:49:51 <oab> or more
09:50:07 <oab> Any minute now everyone will start using them :)
09:50:12 <jfischoff> any idea why when a coworker runs an executable I wrote he is getting the error: warning Could not find object file … /libHSrts.a(darwin64.o) ?
09:50:20 <quchen> Not sure if joking
09:50:31 <oab> Well they ought to anyway
09:50:50 <adek> jfischoff: He doesn't have library your binary is linking to?
09:51:03 <geekosaur> jfischoff, are you using ghc-lib / hint in there?
09:51:15 <jfischoff> I don't think so...
09:51:27 <jfischoff> GHC.float
09:51:56 <jfischoff> I thought the GHC runtime was bundled with the app?
09:52:06 <geekosaur> adek: that's a member of a *static* archive, it should not be needed at runtime
09:52:20 <geekosaur> unless it's being run under a debugger which is trying to load symbols
09:52:35 <jfischoff> ah
09:52:51 <geekosaur> (or unless this is older AIX, but that's kinda its own punishment)
09:52:59 <armlesshobo> I really wish hackage would specify if the package can be built for dynamic linking.
09:53:03 <jfischoff> the app was set faulting so I had him run it under gdb to get more info
09:53:12 <jfischoff> so that is not the issue
09:56:48 <geekosaur> oh, so this is the float/double issue on OS X, sounds like.
09:56:52 <geekosaur> not a problem with your code
09:57:11 <jfischoff> really?
09:57:32 <geekosaur> or was that mentionof GHC.Float spurious?
09:57:41 <jfischoff> probably spurious
09:58:13 <jfischoff> what is the float/double issue though?
10:00:04 <geekosaur> lemme see if I can find the bug
10:02:49 <geekosaur> http://hackage.haskell.org/trac/ghc/ticket/7043 appears to be the bug they're using as the reference (various other bug reports are closed as dups of it)
10:15:07 <root____6> Hello , can anyone respond to my query regarding Haskell dynamic module loading
10:15:19 <simpson> root____6: One sec, looking for it.
10:15:31 <root____6> http://stackoverflow.com/questions/15824756/ghc-7-4-2-dynamically-calling-modules
10:15:40 <simpson> Oh, you hadn't asked yet.
10:16:03 <[swift]> so is it me or is cabal configure --enable-executable-profiling broken on the current haskell platform?
10:16:12 <simpson> root____6: Well, let's take a step back. Why do you want this?
10:16:15 <tootsie> Hello. I'm learning sockets. I wrote a simple protocol on top of TCP to handle message framing(sent the length of the message first in the stream) and it works. But I'm a little confused on what a port really is. How is this mapped to something physically? And how is it resolved what data belongs to which socket if you have several connections on the same address and port? It all comes down
10:16:16 <tootsie> to the same physical connection right?
10:16:17 <fryguybob> @tell napping I reported the issue you pasted with STM here: http://hackage.haskell.org/trac/ghc/ticket/7815
10:16:17 <lambdabot> Consider it noted.
10:16:48 <simpson> tootsie: In TCP and UDP, the port is merely a number.
10:17:02 <simpson> tootsie: It doesn't have any physical equivalent.
10:17:46 <simpson> tootsie: As for your second question...you're talking about a server, right? You've listened on a port, and now you have many connections on that port?
10:17:57 <tootsie> I know it is represented by a number but how is that possible. since TCP is just a stream how can data be sent to a specific port?
10:18:06 <tootsie> or socket rather
10:18:08 <root____6> I want to load Modules and invoke from configuration files for some  framework implementation
10:18:20 <tootsie> simpson: yes a server
10:18:26 <root____6> yes
10:18:30 <simpson> tootsie: Underneath the stream, TCP sends a lot of framing data, including the port numbers.
10:18:55 <simpson> root____6: Sounds complex. Why not start with something simpler?
10:19:09 <root____6> :)
10:19:23 <simpson> tootsie: So, a single socket connection is determined by five things: Source IP, source port, destination IP, destination port, and protocol.
10:19:53 <simpson> tootsie: Since the clients all have different IPs and are connecting on different ports, it's not hard for your networking layer (the kernel) to keep connections separate.
10:21:52 <root____6> is it something very difficult ? I tried to boil down the issue to simplest possible, calling a one liner function,
10:23:06 <simpson> root____6: Maybe http://stackoverflow.com/questions/9198140/ghc-api-how-to-dynamically-load-haskell-code-from-a-compiled-module-using-ghc will help.
10:23:16 <simpson> root____6: Also, there's the hint package if you want to *compile* code dynamically.
10:31:08 <tootsie> simpson: all my clients are from one computer so should have the same IP. they also connect tot he same port id. im using python on the client side and i dont hand it a port nbr.,.
10:31:41 <simpson> tootsie: Your lowest level of socket stuff (deep inside libc) automatically picks a super-high free port.
10:31:49 <lightquake> I need a one-to-many map that's easily invertible; is there something like that in the libraries?
10:31:51 <simpson> tootsie: Use netstat on your client computer.
10:32:10 <geekosaur> when you accept a connection it is given an ephemeral port number. you might want to study how sockets work in general
10:33:37 <tootsie> simpson: ok ty. very helpful answers.
10:33:52 <simpson> tootsie: Sure.
10:53:34 <root____6> simpson: thanks but I have written exactly as stated in SO question you referenced , also regarding hint package, I am not sure if we can load precompiled modules using that ?, I see examples which load onlly from source
10:53:49 <simpson> root____6: hint is a Haskell INTerpreter.
10:54:17 <simpson> root____6: Anyway, my question would still be: If you're gonna compile the code, and you have all the code, why does it need to be dynamically loaded?
10:57:17 <root____6> simpson: I am designing a framework which reads the congiguration file and loads the modules without their source
10:58:08 <root____6> simpson: the TestModule I have written onlly for testing
10:59:06 <simpson> root____6: I'm guessing you're coming from Rails- or Django-land?
10:59:42 <root____6> simpson: :) I am java programmer
10:59:52 <simpson> root____6: Ah.
11:00:21 <simpson> Well, this isn't very Haskelly, but best of luck. I can't think of much that will help besides going and reading GHC's docs about those functions.
11:01:06 <gentleben> there is a haskell plugins thing floating around somewhere that allows loading
11:04:29 <lispy> hsplugins
11:04:40 <lispy> (sometimes just known as plugins)
11:06:01 <tootsie> simpson: why is TCP implemented as a stream and not as packages? if the info is already there, why not use it? what is the advantage of it?7
11:06:41 <simpson> tootsie: I'm not sure what you mean by "packages". Are you talking about datagrams?
11:06:52 <tootsie> yes
11:06:56 <simpson> tootsie: TCP provides a stream because a stream is a useful abstraction.
11:06:58 <geekosaur> I think (a) they mean packets (b) they need to read Stevens
11:29:12 <tootsie> http://www.amazon.com/UNIX-Network-Programming-Networking-Sockets/dp/013490012X
11:29:21 <tootsie> geekosaur ^^ that one i assume?
11:29:55 <geekosaur> yes
11:30:17 <geekosaur> although for an overview of concepts instead of programming details you may want TCP/IP Illustrated
11:31:07 <tootsie> tanenbaum any good for learning tcp/ip?
11:33:47 <geekosaur> Most of Tanenbaum's stuff is more about designing networking than about details of existing protocols (e.g. original Minix preferred Tanenbaum's own Amoeba protocol to TCP/IP)
11:33:59 <lispy> if you just need an introduction, Beej is decent: http://beej.us/guide/bgnet/
11:38:53 <joker_89> hi i have a tuple (X,Y), how can i apply muy fuction to the both elements of the tuple like (*2)
11:39:03 <joker_89> and the result (2*X,2*Y)
11:40:19 <glguy> joker_89: just like you wrote. There isn't a standard function for doing that. If you are using the lens library you can use the "both" function
11:40:43 <glguy> ?type over both (*2)
11:40:44 <lambdabot> Num b => (b, b) -> (b, b)
11:40:51 <eikke> :t \f (a, b) -> (f a, f b)
11:40:52 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
11:41:03 <elliott> or join (***) from Control.Arrow works too
11:42:02 <glguy> elliott: if you're writing one-liners for #haskell, at least :-p
11:42:15 <elliott> I've defined both = join (***) locally before
11:42:20 <elliott> before lens
11:53:56 <notdan> Hi!I have a very stupid question, but I don't understand why my program does not work. http://paste.lisp.org/display/136524 I tried debugging it and it never goes past the first trace call if I pass (Right ..) to the mark function
11:54:12 <notdan> I completely don't understand why wouldn't it work
11:54:46 <notdan> Actually sorry, the second trace() call is never getting evaluated
11:56:13 <Cale> notdan: hmm
11:56:13 <Ralith> notdan: I'm not sure how trace interacts with your monad. Have you tried wrapping trace around values that are known to get evaluated instead?
11:56:58 <bscarlet> notdan: I don't know the monad you're working in, and you haven't provided the context in which you're evaluating your function. Depending on your monad, it might never be necessary that the thunks with the traces in them get evaluated.
11:57:03 <Cale> notdan: btw, let p' = p st involves no evaluation step, and so whenever you see the 2nd trace, you'll see the 3rd immediately
11:57:45 <notdan> bscarlet: sorry, you are absolutely right
11:57:49 <notdan> I am working in a State monad
11:59:08 <Cale> notdan: Well, does this action actually complete when you use runState to supply it with an initial state?
11:59:20 <Cale> I assume NPNConstrM is actually a type synonym?
11:59:58 <notdan> Yes. Well I do run that monad
12:00:08 <LambdaDusk> so I open up htop and had to see that the GHC leaves every llc process as a zombie once used
12:00:12 <notdan> but I've boiled down the problem to this piece of code
12:00:17 <LambdaDusk> zombie apocalypse, it's come
12:01:31 <Cale> notdan: I mean, if you write  runState (mark something (Right somethingElse)) someInitialState
12:01:38 <Cale> notdan: with the blanks filled it
12:01:39 <Cale> in*
12:01:45 <Cale> what happens in ghci?
12:02:49 <Cale> Given that the first trace runs, you should at least get appropriate parameters, if not an appropriate initial state
12:03:05 <Cale> I honestly don't see how this code could be problematic on its own
12:04:28 <Cale> However, building up a map like this could result in some shitty performance when you finally take the map out and you have a million inserts to calculate before you can look up whatever it is, assuming that you never do lookups while the algorithm builds it.
12:05:17 <Cale> (stack overflows could happen at that point, and in the meantime, multiple inserts to the same key will build up on the heap)
12:05:39 <Cale> But that's mostly performance related stuff
12:05:55 <Cale> rather than "the program stops running without a message here" stuff
12:06:17 <notdan> Yeah, you are right
12:06:30 <notdan> I keep forgetting about the downsides of non-strict evaluation
12:06:46 <Cale> It's mostly okay if you're aware of it :)
12:06:52 <notdan> I guess I have to add strictness annotations to the 'put' thing?
12:07:11 <notdan> I am actually terrible at understanding how Haskell evaluation works
12:07:12 <Cale> yeah, you could even just p' `seq` put ...
12:07:22 <notdan> I know it's more complicated than call-by-name
12:08:01 <monochrom> it is not more complicated than call-by-name. unless, "complicated" is subjective
12:08:06 <Cale> which will at least force the Map to be evaluated, which since Map is strict in the keys, will force the inserts to actually be evaluated
12:12:12 <monochrom> call-by-name is an adequate assumption, until you have to ask:
12:12:18 <monochrom> in "x = 0 : x" and "print (take 10 x)", does it generate 10 cons cells (and discards them right away), or 1 cons cell.
12:26:13 <nexx> Is proudness about "side-effect-free-free" the "I'm proud that I cannot calculate" of programmers? https://github.com/hayeah/rantly
12:27:11 <Eelis> nexx: heh
12:27:55 <Philonous> nexx:  I think he's joking
12:31:20 <hiptobecubic> I don't know, it seems like something that someone who doesn't do "alien mathematics" would say
12:31:58 <nexx> I think it is intended to be funny but also to be true
12:32:36 <nexx> at least sort of
12:34:40 <hiptobecubic> I think it's right in line with the usual sentiment of "Immutability is great and all, but some of us need to actually write real programs that actually do things," that is so popular.
12:34:56 <Rogach> Hello! Is there some cli arg to ghci, that will permit me to :load some file automatically?
12:35:08 <hiptobecubic> Rogach, ghci <file>
12:36:15 <Rogach> hiptobecubic: Thanks!
12:36:23 <hiptobecubic> Rogach, you're welcome.
12:37:01 <pala2> I'm currently learning about η-conversion: http://en.wikipedia.org/wiki/Lambda_calculus#.CE.B7-conversion . But I don't get what it means, that "x must not be a free variable in f"?  What about this example: λx. x  and  λx. f z x   η-equivalent?
12:37:15 <__xc> is it possible to do some evaluations over (in)finite set: like x = x^2 on [0,1]
12:37:33 <__xc> hmm any
12:37:37 <__xc> :t any
12:37:38 <hiptobecubic> pala2, if it's free that means it's not the argument
12:37:39 <lambdabot> (a -> Bool) -> [a] -> Bool
12:37:54 <simpson> __xc: Well, what makes this different from a map?
12:37:59 <hiptobecubic> pala2, \x.xy  has y free, for example
12:38:12 <simpson> > map (\x -> x * x) [0..] -- __xc
12:38:14 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:38:22 <__xc> simpson, and fold it at the end with &
12:38:41 <__xc> yes was thinking with Boolean return
12:38:56 <simpson> __xc: Oh.
12:39:00 <__xc> 'predicate'
12:39:03 <Xaratas> I have a function like this: if something then return a list else return an empty list for type correctness, is there a common way to modify such cases? currently i would throw away the empty lists with a filter, but i would feel better not to generate them at all
12:39:08 <__xc> if it's the right term
12:39:11 <quchen> > any (> 10) [0..]
12:39:13 <lambdabot>   True
12:39:17 <hiptobecubic> __xc, if you're asking for an enumeration of an uncountably infinite set like [0,1], then I don't think haskell is your biggest problem.
12:39:19 <simpson> > any odd [0..]
12:39:21 <lambdabot>   True
12:40:31 <pala2> hiptobecubic: And where I know that f is binding x in my example? f isn't defined anywhere...
12:41:08 <__xc> something like "each (\x -> (x < x+1) [0..]"
12:41:49 <tootsie> the type IO () cant be assigned right? like a <- someIO()_returning_function ?
12:41:52 <quchen> That won't terminate.
12:42:11 <hiptobecubic> pala2, your example is  \x.(f z) x, because it associates to the left. So it's equivalent to just (f z) i think.
12:42:53 <Cale> tootsie: If you have an IO action of type IO (IO Integer), and you run it, then the result will have type IO Integer
12:42:54 <quchen> tootsie: You can do that. IO is just some monad like all the others.
12:42:58 <simpson> tootsie: You can certainly draw from IO (), but you're just gonna get a ().
12:43:03 <quchen> It's special on the inside.
12:43:23 <__xc> > fold (&) $ any (>0) [1..10]
12:43:25 <lambdabot>   Couldn't match expected type `a0 -> b0'
12:43:25 <lambdabot>              with actual type `GHC....
12:43:47 <hiptobecubic> __xc, any returns a bool. you cannot fold over that.
12:43:48 <__xc> > fold (&) $ map (>0) [1..10]
12:43:49 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[b1]'
12:43:59 <Cale> tootsie: If you have a function which produces an IO action, of type IO (), then you can apply it to parameters and run the resulting value of type IO (), and you'll get an empty tuple as the result.
12:44:03 <__xc> yes ouch
12:44:18 <hiptobecubic> :t fold
12:44:19 <lambdabot> (Foldable t, Monoid m) => t m -> m
12:44:28 <simpson> :t and
12:44:29 <lambdabot> [Bool] -> Bool
12:44:43 <ab9rf> vots all dis?
12:44:51 <simpson> > and $ map (< 10) [0..]
12:44:53 <lambdabot>   False
12:44:54 <hiptobecubic> > fold (words "Here we go!")
12:44:56 <lambdabot>   "Herewego!"
12:44:59 <ab9rf> @src and
12:44:59 <simpson> __xc: ^^
12:44:59 <lambdabot> and   =  foldr (&&) True
12:45:28 <tootsie> to use UDP i just create a socket and then use send sock addr ?
12:45:38 <__xc> > fold (+) [1,2,3,4,5]
12:45:40 <lambdabot>   No instances for (GHC.Num.Num [t0],
12:45:40 <lambdabot>                    Data.Foldable.Foldab...
12:45:51 <__xc> wtf it's the example http://www.haskell.org/haskellwiki/Fold
12:46:01 <ab9rf> __xc: fold only takes one argument
12:46:21 <__xc> hmm
12:46:47 <hiptobecubic> __xc, fold assumes you have a monoid in a traversable data structure. Monoids, by definition, already have their (+) defined, it wouldn't make sense to pass it in again.
12:46:52 <quchen> > fold (Just 1)
12:46:54 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:46:54 <lambdabot>    (GHC.Num.Num a0)
12:46:54 <lambdabot>      a...
12:47:08 <hiptobecubic> Numbers can be monoids in more than one way
12:47:17 <quchen> Yeah :-(
12:47:19 <hiptobecubic> fold (map Sum [0..10])
12:47:20 <hiptobecubic> fold (map Sum [0..10])
12:47:26 <hiptobecubic> > fold (map Sum [0..10]) -- oops :)
12:47:28 <lambdabot>   Sum {getSum = 55}
12:47:29 <quchen> > fold (Just (Sum 1))
12:47:30 <lambdabot>   Sum {getSum = 1}
12:47:40 <__xc> :t foldl
12:47:41 <lambdabot> (a -> b -> a) -> a -> [b] -> a
12:48:00 <hiptobecubic> __xc, there is a *great* package called simplereflect to help you visualize this stuff
12:48:10 <__xc> k
12:48:17 <hiptobecubic> > foldr f 0 [x,y,z]
12:48:19 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:48:20 <lambdabot>    (GHC.Num.Num a0)
12:48:20 <lambdabot>      a...
12:48:23 <hiptobecubic> damnit. :D
12:48:33 <hiptobecubic> > foldr f 0 [x,y,z] :: Expr   --crosses fingers
12:48:35 <lambdabot>   f x (f y (f z 0))
12:48:39 <osa1_> is there a toList function for IOVector ?
12:48:41 <hiptobecubic> there we go.
12:48:50 <__xc> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29 is not bad maybe also
12:49:24 <hiptobecubic> ah yes. Are those Cale's diagrams?
12:50:12 <LambdaDusk> anyone knows of a pre-built ghc-7.6 for the raspberry?
12:50:25 <quchen> LambdaDusk: Nope.
12:50:30 <dmj> How do I import modules into an .lhs file? like import Data.Char (isLower)
12:50:34 <quchen> LambdaDusk: Gave up and used Raspbian's 7.4.1
12:51:04 <hiptobecubic> dmj, the same way you do anything in an lhs file i think
12:51:23 <hiptobecubic> If i recall, ghc just throws out the parts that aren't code and then runs it normally
12:53:23 <LambdaDusk> quchen: Which lacks ghci
12:53:40 <LambdaDusk> quchen: which seems to come wiht 7.4.2
12:53:44 <quchen> LambdaDusk: Yes.
12:53:53 <quchen> LambdaDusk: Why do you need GHCi though?
12:54:12 <quchen> You'd hardly develop on the RasPi directly would you
12:54:19 <dmj> hiptobecubic: In the .lhs I do \begin{code} import Data.List (isLower) countLower = length . filter isLower \end{code}
12:54:29 <LambdaDusk> quchen: then profunctors packages says "no dice without ghci, sucker"
12:54:34 <quchen> Write a scp script and let that do the deployment
12:54:45 <dmj> "Not in scope 'isLower'"
12:54:47 <quchen> LambdaDusk: Oh.
12:54:57 <dmwit> dmj: isLower is in Data.Char, not Data.List
12:55:18 <LambdaDusk> quchen: also I for some reason prefer to compile on the target machine
12:55:41 <hiptobecubic> dmj, this is a nice resource:  http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=isLower
12:55:43 <dmj> dmwit: Sorry about that yea, I have it in Data.Char. I get now "parse error on import"
12:56:04 <dmj> don't all imprts have to be at the top and below the module declaration?
12:56:07 <dmwit> dmj: Paste a complete file to hpaste. What you wrote there works for me, after inserting newlines.
12:56:08 <quchen> LambdaDusk: Oh sure you compile on the raspi
12:56:10 <dmwit> ?hpaste
12:56:10 <lambdabot> Haskell pastebin: http://hpaste.org/
12:56:25 <quchen> LambdaDusk: But you can develop locally and then upload+compile
12:56:31 <dmj> lol I know isLower is in Data.Char. I just don't know how .lhs files work
12:56:44 <quchen> LambdaDusk: That or get GHC to compile on the RasPi :\
12:57:11 <tgeeky> dmj: literate haskell essentially ignores everything not in bird tracks >
12:57:28 <dmwit> tgeeky: or \begin{code}/\end{code}
12:57:39 <tgeeky> dmwit: ^ yes, that too, which I forget.
12:57:43 <tgeeky> dmj: ^
12:57:44 <LambdaDusk> quchen: Am doing that now... it's been on it for 2 hours but it is almost done with the first package
12:58:12 <quchen> LambdaDusk: Haha. Make sure to tell me how long it took :D
12:58:12 <LambdaDusk> and it leaves llc as zombies
12:58:20 <quchen> Afterwards: compile platform
12:58:30 <quchen> And Lens :D
12:58:31 <dmj> tgeeky: Do .lhs files need to imports at the top of the file or can your intersperse throughout the file?
12:58:48 <dmwit> dmj: .lhs files have the same rules as .hs ones in that regard.
12:58:48 <dmj> I assume at the top
12:58:58 <dmj> dmwit: k thanks
12:59:05 <dmwit> dmj: .lhs files have all the same rules for everything as .hs files; except that where the code occurs must be in code blocks or bird tracks.
12:59:32 <tootsie> i understand udp is unreliable over the internet but what about a closed environment? sure it doesnt guarantee deliviery which sound adangerous fro critical applications but lets say you have some closed industrial network, could you reliably just use UDP then?
13:00:48 <stephenjudkins> tootsie: unsure why this question is here, but packet loss is critical for congestion control. ethernet is designed to drop packets; dropped packets are the only way TCP knows to back off.
13:00:55 <LambdaDusk> quchen: after it went through cabal just now, it seems good
13:00:59 <dmj> > :i (&&)
13:01:01 <lambdabot>   <hint>:1:1: parse error on input `:'
13:01:14 <dmwit> \bot doesn't have an analog to :i.
13:01:39 <simpson> tootsie: *Because* UDP is not guaranteed, your kernel is probably prepared to drop UDP traffic if it has too many packets waiting to leave.
13:01:52 <simpson> tootsie: UDP is never reliable.
13:03:54 <LambdaDusk> quchen I actually do all this to find out  if GLFW can start a gl app without X
13:04:11 <typoclass> tootsie: it depends on your application. if you can stand losing a few packets, udp is a choice. (suppose it has to do with updating a value every second, and suppose it's no big deal if some updates are lost, it'll just mean that the displayed value momentarily is a little older than usual)
13:04:46 <__xc> > foldl (++) "" "haskell"
13:04:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:04:48 <lambdabot>              with actual ty...
13:04:58 <typoclass> tootsie: it's different if you're loading a web page or a zip file over http, you wouldn't want to lose some parts at the beginning, because then the entire file would be corrupted
13:05:03 <sproingie> stephenjudkins: tcp can lower window sizes and delay acks to back off as well
13:05:07 <geekosaur> streaming is a good exple, usually more important to stay in sync than to lose some packets
13:05:17 <tootsie> ok, ty. so i was told in school, and i probably misunderstood, by a gang of programmers working as consultants(they were here to talk about working as an engineer) that they were usign UDP as a protocol for an application where they were steering a wagon load things in and out of a factory. Sounds like a poor match...?
13:05:34 <sproingie> i wouldn't design an industrial control protocol on UDP, no
13:05:40 <__xc> > foldl (++) [""] "haskell"
13:05:41 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
13:05:41 <lambdabot>              with actual ...
13:05:42 <sproingie> not without reinventing all the reliability mechanisms of TCP
13:05:57 <typoclass> tootsie: who knows what they were doing ...
13:06:16 <geekosaur> it depends. you probably want to flush any buffered stuff in that case, which tcp won't do
13:06:33 <sproingie> SCTP would be pretty ideal but it seems to have gone nowhere
13:06:49 <hiptobecubic> :t (++)
13:06:50 <lambdabot> Monoid m => m -> m -> m
13:06:53 <hiptobecubic> ugh
13:06:57 <sproingie> caleskell
13:06:58 <quchen> Nope.avi
13:07:20 <stephenjudkins> sproingie: true. but unless I am mistaken, if a TCP connection has negotiated a certain speed, then the connection becomes more congested, dropped packets are necessary for the connection to renegotiate down.
13:07:22 <LambdaDusk> @vixen
13:07:22 <lambdabot> Politics would be a helluva good business if it weren't for the goddamned people.
13:07:34 <typoclass> tootsie: imho, the key thing is that the protocol is designed for it. geekosaur brought up streaming video or audio. if the video thingy is designed to handle lost packets, then great, run it over udp
13:07:35 <hiptobecubic> __xc, you are folding over a string there
13:07:36 <LambdaDusk> meh
13:07:44 <sproingie> stephenjudkins: there's also ECN, though it's hard to rely on that
13:07:46 <hiptobecubic> __xc, so the arguments to (++) will be....?
13:07:55 <tootsie> ok,ty
13:08:14 <stephenjudkins> the bittorrent folks had issues with TCP, so they wrote their own reliable, ordered protocol layered on top of UDP: http://en.wikipedia.org/wiki/Micro_Transport_Protocol
13:08:48 <sproingie> there's nothing wrong with making new protocols on top of UDP, just make sure that what you're reinventing isn't TCP
13:09:12 <stephenjudkins> sproingie: or that you have a very good understand of why TCP isn't the right choice for you, and how you would do it better.
13:09:18 <pala2> hiptobecubic: hmmm.... What about if we let f=\z.(1+x)?   x is a free variable here then. So there is a special f for which my example ["λx. x  and  λx. f z x   η-equivalent?"] isn't η-equivalent?
13:09:18 <__xc>  > foldl (flip cons) [] "haskell"
13:09:20 <sproingie> i suspect the BT folks could have done fine with TCP on some platforms, but not others
13:09:31 <__xc> > foldl (flip cons) [] "haskell"
13:09:33 <lambdabot>   "lleksah"
13:09:39 <hiptobecubic> pala2, that's a different x
13:09:44 <__xc> (reverse..)
13:10:04 <hiptobecubic> pala2, oh i see what you're doing.
13:10:28 <stephenjudkins> i'd love to see a TCP stack implemented in a relatively pure FP language
13:10:33 <sproingie> stephenjudkins: usually the problem is approached with all the intellectual rigor of a minecraft hacker
13:10:45 <simpson> sproingie: I resent that.
13:10:46 <hiptobecubic> pala2, that's what they mean when they say "does not appear free"
13:10:48 <sproingie> "TCP is slow LOL"
13:10:55 <hiptobecubic> pala2, in that example. x appears free in f
13:11:10 <hiptobecubic> pala2, so (f z) will not be equivalent to \x. f z x
13:11:14 <stephenjudkins> of course galois did it: http://hackage.haskell.org/package/hans
13:11:17 <hiptobecubic> because that x changes f
13:11:29 <__xc> hiptobecubic, well for foldl ok, but if I make foldr works on "haskell" the I will start to understand better
13:11:47 <quchen> > foldr (:) [] "haskell"
13:11:48 <lambdabot>   "haskell"
13:11:49 <sproingie> simpson: hey if you're a minecraft hacker, i suspect you're even more keenly aware of the median skill of much of the community
13:12:02 <__xc> quchen, damn you
13:12:08 <__xc> ;)
13:12:18 <sproingie> simpson: this channel would i suspect self-select above the median
13:12:27 <quchen> __xc: It's not a very spectacular thing to do ;-)
13:12:36 <quchen> Sorry, didn't think I'd spoil something with that
13:13:13 <hiptobecubic> __xc, you could try to implement foldl with foldr.
13:13:26 <simpson> sproingie: I wrote Bravo and it has haunted me ever since. :3
13:13:36 <typoclass> sproingie: yes, but everyone thinks they are hugely better than the median
13:13:37 <__xc> @src foldr
13:13:37 <lambdabot> foldr f z []     = z
13:13:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:13:41 <hiptobecubic> but that's relatively a difficult one, I think.
13:13:44 <quchen> hiptobecubic: Yeah that'll teach him
13:13:50 <quchen> Double meaning intended
13:13:55 <hiptobecubic> :D
13:14:18 * hackagebot linux-mount 0.1.0.0 - Mount and unmount filesystems  http://hackage.haskell.org/package/linux-mount-0.1.0.0 (NicolaSquartini)
13:14:20 <__xc> I wish google understood "hoogle foldr" directly
13:14:33 <quchen> It's a fairly useful thing to understand though hiptobecubic
13:14:45 <tdammers> __xc: duckduckgo does
13:14:45 <quchen> But not something to do as an exercise
13:14:55 <sproingie> typoclass: i think i'm in the minority who knows they're a worse than average driver.  my self-evaluation skills must be above average ;)
13:14:58 <__xc> well "haskell foldr" does it
13:14:59 <hiptobecubic> i have it as a keyword search already
13:15:00 <edwardk> I have a function, it looks a lot like log but it isn't. Lets call it lag: lag(x) = logBase 2 (x / lag(x))
13:15:03 <Xaratas> ok permutations [1,5,9] are 6 elements, i want the not mirrored part. So only 3, nice would be take 3 (correctSortedpermutations [1,5,9]), but i have no idea
13:15:06 <tdammers> at least if you prepend a !
13:15:06 <edwardk> I can't solve for it analytically, but i can solve for it numerically. Has anyone seen it before? It is slightly below log for any given input and as x goes to infinity it converges towards log.
13:15:30 <tdammers> https://duckduckgo.com/bang.html
13:15:32 <edwardk> > let n = 2^32 in iterate (\y -> logBase 2 (n / y)) 1 !! 30
13:15:33 <lambdabot>   27.232730275033873
13:15:46 <__xc> tdammers, seen it once, but I'm can't really switch between 2 search engine
13:15:50 <edwardk> any ideas?
13:15:56 <tdammers> __xc: you don't have to
13:16:06 <edwardk> it arises when i start calculating some recurrences involving optimal search and insert times in analytics
13:16:14 <edwardk> I've just never seen it before
13:16:19 <tdammers> there's also !g for google
13:16:34 <quchen> edwardk: Looks like Lambert W business
13:16:35 <rrckrd> i just realized that the meaning of life, 42, is actually sex and more than sex (sex is swedish for six and more than sex is 7). Does that explain the swedish sin?
13:17:08 <edwardk> quchen: hrmm
13:17:14 <simpson> rrckrd: Please be on-topic.
13:17:19 <tootsie> are sockets non blocking by default?
13:17:30 <sproingie> i'd hope not
13:17:40 <rrckrd> sorry simpson
13:17:53 <elliott> tootsie: the runtime system uses non-blocking IO under the hood, but exposes a blocking threaded interface to the language
13:17:55 <tootsie> https://groups.google.com/forum/?fromgroups=#!topic/haskell-cafe/aqaoEDt7auY
13:18:02 <simpson> tootsie: Sockets block. You are expected to use forkIO threads in order to do multiple things at once.
13:18:23 <arkeet> or possibly some abstraction over forkIO.
13:19:18 * hackagebot mount 0.2.1 - Mounts and umounts filesystems  http://hackage.haskell.org/package/mount-0.2.1 (NicolaSquartini)
13:19:20 * hackagebot linux-mount 0.1.0.1 - Mount and unmount filesystems  http://hackage.haskell.org/package/linux-mount-0.1.0.1 (NicolaSquartini)
13:19:39 <rrckrd> what is the best way to learn haskell for a relatively smart non-programmer? I found the 'learn a haskell for a greater good' and the 99 haskell problems
13:19:58 <edwardk> quchen: basically it arose when i started considering what i could do if i only sorted my tables down to chunks that are of some polylog(n) size and then just appended it to the chunk. then insert is O(log (N/f(N)))  and search os O(log (N/f(N)) + f(N))   in the latter if f is log then that comes out to log (N/log N) + log N but then the second term dominates. To balance them I want log (N/f(N)) = f(N)
13:20:07 <osfameron> rrckrd: those sound like a good start
13:20:16 <edwardk> i'm fully expecting the result to be trivial
13:20:17 <hiptobecubic> rrckrd, this question is on SO
13:20:25 <edwardk> i just got stumped by never having seen it before
13:21:01 <edwardk> quchen: so then i started just calculating examples numerically
13:21:02 <rrckrd> i want to learn haskell, but strange enough, I don't know why I want to learn haskell
13:21:05 <hiptobecubic> rrckrd, http://stackoverflow.com/questions/1012573/getting-started-with-haskell
13:21:08 <typoclass> rrckrd: yup, that's a good start
13:21:20 <ciaranm> edwardk: it's probably in sedgewick and flajolet's book, which i don't have with me
13:21:22 <typoclass> rrckrd: well, it'll broaden your mind :-)
13:21:31 <ab9rf> or flatten it
13:21:31 <edwardk> @let lag n = iterate (\y -> logBase 2 (n / y)) 1 !! 30
13:21:32 <quchen> edwardk: /q'd you
13:21:33 <lambdabot>  Defined.
13:22:20 <rrckrd> thanks for the reminder hiptobe^3
13:22:35 <edwardk> from quchen's query: f(x) = LambertW(e^x * x * log(2)) / log(2)    -- that looks right actually
13:23:01 <rrckrd> getting into recursive thinking took a while, and that is not even a start\
13:23:36 <rrckrd> so I started getting into recursive thinking
13:27:35 <rrckrd> i find mathematics fascinating and beautiful, especially complex things that can be written tersely. haskell seems to be similar. Have anyone here drawn a fractal with haskell? Is that within reach for newbie?
13:27:59 <quchen> rrckrd: Verily.
13:28:07 <quchen> rrckrd: The hard part is basically the output. :-)
13:28:19 <quchen> rrckrd: But then in what language is Mandelbrot difficult
13:28:46 <rrckrd> quechen: yes, no side effects, that is the good thing, wasn
13:29:02 <tootsie> @src when
13:29:02 <lambdabot> when p s = if p then s else return ()
13:29:12 <ab9rf> quchen: brainfuck.
13:29:28 * hackagebot halipeto 2.4.1 - Haskell Static Web Page Generator  http://hackage.haskell.org/package/halipeto-2.4.1 (PeterSimons)
13:29:40 <quchen> ab9rf: Brainfuck *is* a fractal.
13:29:45 <elliott> quchen: https://github.com/isomorphism/esoteric-fractals/blob/master/Make/Makefile
13:29:52 <ab9rf> quchen: and then there's malbolge
13:29:53 <hiptobecubic> malbolge?
13:30:01 <hiptobecubic> malbolge is excellent
13:30:22 <quchen> malbolge is silly. INTERCAL is excellent.
13:30:25 <rrckrd> quechen: I have actually never written a program to generate a fractal, but the algorithm seems simple: for all pixels - map them to numbers and calculate how many iterations it takes to divergate or color it black if it converges
13:30:43 <quchen> rrckrd: Yes, that's basically it for Mandelbrot
13:30:44 <typoclass> rrckrd: it's not really math, but i like how terse it can be when you write quicksort in haskell: http://hpaste.org/85268
13:30:54 <arkeet> I don't like quicksort :(
13:30:56 <ab9rf> typoclass: that's not really quicksort
13:30:57 <hiptobecubic> is that the 'not really quicksort' quicksort?
13:31:32 <sproingie> quicksort is defined as an in-place sort
13:31:42 <quchen> That *is* quicksort. For singly linked lists.
13:32:09 <Philonous> Oh, is it this time again?
13:32:15 <ab9rf> indeed
13:32:21 <ab9rf> time for the weekly quicksort debate
13:32:26 <ab9rf> popcorn, anyone?
13:32:31 <hiptobecubic> please
13:32:42 <__xc> > sort "haskell"
13:32:44 <lambdabot>   "aehklls"
13:33:15 <typoclass> in my opinion, it's tersely written and a sort. i don't know if it can be called quicksort, and i don't think it's very important
13:33:20 <rrckrd> typoclass: elegant
13:34:05 <rrckrd> since it's friday. shouldnt quantum computers be really quick at sorting?
13:34:18 * hackagebot chuchu 0.4.3 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.4.3 (FelipeLessa)
13:34:20 * hackagebot hopenssl 1.6.2 - FFI bindings to OpenSSL's EVP digest interface  http://hackage.haskell.org/package/hopenssl-1.6.2 (PeterSimons)
13:34:33 <Rotaerk_> hmm in a type family, if I have:  class C a b where { data D a :: * }
13:34:42 <Xaratas> rrckrd: only on mondays
13:34:46 <Rotaerk_> what are the implications of excluding the "b" from the declaration of D
13:35:27 <Rotaerk_> at first I thought maybe it's the same for all instances of C that share the same a, but that doesn't make sense..
13:36:30 <rrckrd> Xaratas: great, then it works on any day. Since mondays in one place can be tuesday or a sunday elsewhere. The same is true for both sundays and tuesdays
13:36:35 <arkeet> Rotaerk_: you will get an error if you try to define multiple instances for the same a
13:36:47 <tdammers> it does fit wikipedia's description of quicksort
13:36:55 <Rotaerk_> ah
13:36:59 <Rotaerk_> k, thanks
13:37:26 <__xc> http://www.youtube.com/watch?v=FBWeO2HYEc0 I'd propose Haskell erlang and company rather
13:37:57 <typoclass> tdammers: yeah it seems to say "quicksort can be implemented with an in-place thingy"
13:39:19 * hackagebot hsemail 1.7.6 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.6 (PeterSimons)
13:40:08 <Xaratas> ok, how to get the not mirrored permutations of a list?
13:40:21 <int-e> "not mirrored"?
13:40:38 <int-e> maybe an example would help
13:40:44 <Xaratas> throw in [1,5,9], get [1,9,5]
13:40:50 <Xaratas> but not [9,5,1]
13:41:18 <Xaratas> > permutations [1,5,9]
13:41:20 <lambdabot>   [[1,5,9],[5,1,9],[9,5,1],[5,9,1],[9,1,5],[1,9,5]]
13:41:27 <arkeet> Rotaerk_: well, really you could have tested this yourself :p
13:41:33 <Xaratas> of these 6 only 3 are "not mirroed"
13:41:41 <arkeet> what does "mirrored" mean?
13:41:46 <int-e> > map reverse . tail . permutations $ [2,3,4]
13:41:47 <lambdabot>   [[4,2,3],[2,3,4],[2,4,3],[3,2,4],[3,4,2]]
13:42:00 <int-e> Xaratas: just that?
13:42:04 <ab9rf> Xaratas: you need to defined "not mirrored"
13:42:04 <Xaratas> but i could not easily do "take 3 (permutations x)
13:42:45 <Xaratas> 4,2,3 is the mirror of 3,2,4
13:42:46 <simpson> > filter (\xs -> reverse xs \= xs) $ permutations [1,5,9]
13:42:47 <lambdabot>   Not in scope: `\='
13:42:47 <lambdabot>  Perhaps you meant one of these:
13:42:47 <lambdabot>    `/=' (imported from ...
13:42:58 <simpson> > filter (\xs -> reverse xs /= xs) $ permutations [1,5,9] -- doh
13:42:59 <lambdabot>   [[1,5,9],[5,1,9],[9,5,1],[5,9,1],[9,1,5],[1,9,5]]
13:43:00 <hiptobecubic> only take one of palindromes
13:43:04 <tootsie> name an interesting protocol to implement in haskell. a bigger one. preferrably one that hasnt been done
13:43:10 <simpson> Oh, wait, I see. Derp.
13:43:11 <int-e> Xaratas: so which of 4,2,3 or 3,2,4 do you want?
13:43:12 <ion> tootsie: Skype
13:43:22 <hiptobecubic> ion, :D
13:43:23 <parcs> > nubBy ((==) <*> reverse) $ permutations [1,5,9]
13:43:24 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
13:43:24 <lambdabot>              with actua...
13:43:42 <Xaratas> any one ist good, i would prefer the lower one but it should not matter for my programm
13:43:43 <arkeet> > nubBy ((==) . reverse) $ permutations [1,5,9]
13:43:44 <lambdabot>   [[1,5,9],[5,1,9],[5,9,1]]
13:43:47 <tootsie> ion: i was just reading on VoIP!
13:43:55 <simpson> Xaratas: What are you using these for?
13:43:57 <int-e> > filter (\xs -> reverse xs < xs) . permutations $ [2,3,4]
13:43:59 <lambdabot>   [[4,3,2],[3,4,2],[4,2,3]]
13:44:16 <tootsie> ion: haskell woudlnt be to slow? does programming lang even matter with internet network code ?
13:44:19 * hackagebot streamproc 1.6.2 - Stream Processer Arrow  http://hackage.haskell.org/package/streamproc-1.6.2 (PeterSimons)
13:44:20 <arkeet> > filter (\xs -> reverse xs < xs) . permutations $ [2,2,2]
13:44:21 <lambdabot>   []
13:44:24 <parcs> int-e: nice
13:44:29 <arkeet> > nubBy ((==) . reverse) $ permutations [2,2,2]
13:44:29 <Rotaerk_> arkeet, hmm true
13:44:30 <lambdabot>   [[2,2,2]]
13:44:31 <Rotaerk_> sorry
13:44:32 <hiptobecubic> tootsie, haskell isn't slow, first of all. Secondly, no.
13:44:38 <Xaratas> i am calculationg magic squares and want to get rid of the mirroed squares to speed up the algo in the first place
13:44:48 <int-e> I guess that should be <= :-)
13:44:55 <rrckrd> Xaratas
13:44:57 <int-e> (to make it work for singleton lists)
13:45:10 <rrckrd> Xaratas: are you doing Project euler problems?\
13:45:14 <arkeet> yeah, I'd go with <=
13:45:18 <__xc> tootsie, good luck with the 300 pages of rfc
13:45:25 <Xaratas> rrckrd: no
13:45:44 <tootsie> rfc=?
13:45:47 <Xaratas> rrckrd: the magic square thing is yust for learning a little haskell
13:46:02 <hiptobecubic> tootsie, miserably boring spec
13:46:09 <hiptobecubic> mbs
13:46:15 <edwardk> > lag (2^32)
13:46:17 <lambdabot>   27.232730275033873
13:46:30 <tootsie> the spec is 300 pages?
13:46:32 <ion> “<hiptobecubic> ion, :D” – more like “D:” given that it’s proprietary in the first place and not reverse-engineered yet.
13:46:35 <arkeet> > filter (\xs -> head xs <= last xs) . permutations $ [1,2,3]
13:46:36 <lambdabot>   [[1,2,3],[2,1,3],[1,3,2]]
13:46:36 <rrckrd> Xaratas: ah! that is what makes learning programming fun. Solving problems. Haskell seems to be very adept at that
13:46:50 <hiptobecubic> ion, that makes it even better.
13:46:53 <ion> @type lag
13:46:54 <lambdabot> Floating a => a -> a
13:46:55 <int-e> arkeet: heh, I just typed that, too\
13:46:57 <arkeet> heh
13:47:14 <arkeet> > filter (\xs -> head xs <= last xs) . permutations $ [] -- oops
13:47:15 <lambdabot>   *Exception: Prelude.head: empty list
13:47:27 <ion> > map (lag . (10^)) [0..]
13:47:29 <lambdabot>   [-Infinity,2.1905956819481687,4.480270387268562,7.131565480963866,9.9701038...
13:47:31 <Xaratas> > filter (\xs -> head xs <= last xs) . permutations $ [1,2,15,16]
13:47:33 <lambdabot>   [[1,2,15,16],[2,1,15,16],[15,2,1,16],[2,15,1,16],[15,1,2,16],[1,15,2,16],[1...
13:47:40 <arkeet> > length it
13:47:41 <__xc> whole networking is a pain of protocols, that's why the SDN /openflow could be great
13:47:41 <lambdabot>   Not in scope: `it'
13:47:42 <lambdabot>  Perhaps you meant one of these:
13:47:42 <lambdabot>    `id' (imported from ...
13:47:56 <hiptobecubic> > map sort . filter ((==) . reverse) . permutations # [1,2,15,16]
13:47:57 <lambdabot>   Not in scope: `#'
13:48:02 <hiptobecubic> > map sort . filter ((==) . reverse) . permutations $ [1,2,15,16]
13:48:04 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
13:48:04 <lambdabot>              with actual type...
13:48:09 <hiptobecubic> damn
13:48:09 <arkeet> hiptobecubic: uh no :)
13:48:10 <edwardk> > lag (2^20)
13:48:13 <lambdabot>   16.0
13:48:27 <arkeet> hiptobecubic: why would you sorting the permuted lists?
13:48:30 <arkeet> er, sort.
13:48:46 <hiptobecubic> arkeet, for beauty
13:48:54 <hiptobecubic> the most important aspect of programming
13:48:56 <arkeet> but you'll just get a bunch of copies of the same list.
13:49:17 <rrckrd> hipt2b^3: that's a perfetly good reason
13:49:48 * elliott wonders what that "t" is doing.
13:49:49 <hiptobecubic> arkeet, well sure. Function follows form, I always say.
13:49:57 <armlesshobo> hiptobecubic: vanity is a deadly sin.
13:50:00 <armlesshobo> i think
13:50:15 <hiptobecubic> armlesshobo, you're thinking of tax evasion
13:50:19 <tootsie> the skype spec is 300 pages? is there a voip spec?
13:50:25 <armlesshobo> hiptobecubic: ah, my bad. always mix the two up
13:50:26 <hiptobecubic> tootsie, there is no skype spec
13:50:38 <Xaratas> hm, beauty, yes there i have an other thing of code
13:50:50 <Xaratas> that could need it
13:51:12 <arkeet> hmm
13:51:19 <arkeet> there must be a nice way to generate all the even permutations.
13:51:31 <hiptobecubic> 'even'?
13:51:34 <tootsie> what spec is 300 pages?
13:51:58 <rrckrd> |
13:52:02 <arkeet> http://en.wikipedia.org/wiki/Even_permutation
13:52:06 <__xc> > nub "aazza"
13:52:07 <lambdabot>   "az"
13:53:03 <hiptobecubic> arkeet, well this is new to me
13:54:01 <hpaste> Xaratas pasted “Permutation search” at http://hpaste.org/85270
13:54:26 <arkeet> a nice definition: the parity of a permutation is the determinant of the corresponding linear map that permutes the coordinates
13:54:41 <__xc> > nub $ map sort $ permutations [1..3]
13:54:42 <lambdabot>   [[1,2,3]]
13:54:43 <arkeet> well, the sign
13:54:53 <hiptobecubic> yes, that's by far the most intuitive way to think about this....
13:55:07 <Xaratas> so here i have many [[]] in the result, but i would have more beauty if they were not generated at all
13:55:09 <arkeet> why not?
13:55:12 <arkeet> a transposition is just a reflection.
13:55:18 <arkeet> reflections have determinant -1
13:55:28 <meyersh> > :t (..)
13:55:30 <lambdabot>   <hint>:1:1: parse error on input `:'
13:56:08 <hiptobecubic> arkeet, that is true yes. But I hadn't considered it.
13:56:19 <__xc> (PigNose a) => a -> a
13:58:38 <arkeet> ok, I'll stop myself before I start talking about exterior products and stuff.
13:58:47 <int-e> > let perm p [] = [[] | p]; perm p xs = go p xs [] where { go _ [] _ = []; go p (x:xs) ys = map (x:) (perm p (reverse ys ++ xs)) ++ go (not p) xs (x:ys) } in perm True [1,2,3] -- too clumsy?
13:58:49 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2]]
13:59:28 <arkeet> @let perm p [] = [[] | p]; perm p xs = go p xs [] where { go _ [] _ = []; go p (x:xs) ys = map (x:) (perm p (reverse ys ++ xs)) ++ go (not p) xs (x:ys) }
13:59:30 <lambdabot>  Defined.
13:59:32 <quchen> __xc: nub is quite slow, but requires only Eq. If you have Ord, use "map head . group . sort"
13:59:51 <hiptobecubic> Isn't there a hamming hammond hammy something distance function that computes the transpositions in two lists?
14:00:02 <hiptobecubic> filter by odd . that
14:00:07 <arkeet> int-e: so what's it supposed to do?
14:00:22 <ab9rf> :t that
14:00:24 <lambdabot> Not in scope: `that'
14:00:29 <int-e> arkeet: perm True = even; perm False = odd permutations
14:00:30 <ab9rf> ok, didn't think so
14:00:37 <arkeet> right.
14:00:38 <pala2> thanks hiptobecubic, got that now ;-)
14:01:42 <arkeet> @where select
14:01:42 <lambdabot> select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
14:01:47 <arkeet> @@ @let @where select
14:01:49 <lambdabot>  Defined.
14:02:10 <arkeet> hmm, not quite.
14:02:52 <Xaratas> oO
14:03:09 <arkeet> > select [1..4]
14:03:11 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
14:03:58 <int-e> ah you can zip that with cycle [True,False] :)
14:05:31 <hiptobecubic> or filter on (odd . fst)
14:05:33 <Xaratas> int-e: how the hell?
14:06:42 <int-e> > let perm p [] = [[] | p]; perm p xs = concat [map (x':) (perm p' xs') | (p', (x', xs')) <- zip (cycle [p, not p]) (select xs)] in perm True [1,2,3]
14:06:44 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2]]
14:06:59 <arkeet> I'd rather use False for even.
14:07:13 <Xaratas> interesting observation: all 4 nomirrorpermutate versions result in a different set
14:07:58 <tootsie> > take 10 $ scanr (+) 0 [0..]
14:08:00 <lambdabot>   [*Exception: stack overflow
14:08:04 <arkeet> @let selectS [] = []; selectS (x:xs) = ((1,x),xs) : map ((first.first) negate . second (x:)) (selectS xs)
14:08:05 <tootsie> > take 10 $ scanl (+) 0 [0..]
14:08:06 <lambdabot>  Defined.
14:08:07 <lambdabot>   [0,0,1,3,6,10,15,21,28,36]
14:08:07 <arkeet> > selectS [1..4]
14:08:09 <lambdabot>   [((1,1),[2,3,4]),((-1,2),[1,3,4]),((1,3),[1,2,4]),((-1,4),[1,2,3])]
14:08:48 <int-e> Xaratas: note that [1,2,3,4] and [4,3,2,1] are both even permutations. so generating even permutations does not solve your problem.
14:10:47 <__xc> quchen, yes I know intersecting, and.. on lists is much more efficient after sorting, thx
14:11:20 <tootsie> @src scanl
14:11:20 <lambdabot> scanl f q ls = q : case ls of
14:11:20 <lambdabot>     []   -> []
14:11:20 <lambdabot>     x:xs -> scanl f (f q x) xs
14:11:58 <tootsie> @src scanr
14:11:59 <lambdabot> scanr _ q0 []     =  [q0]
14:11:59 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
14:11:59 <lambdabot>     where qs@(q:_) = scanr f q0 xs
14:13:59 <tootsie> > let fibs = scanl (+) 0 (1:fibs) in take 5 $ fibs
14:14:01 <lambdabot>   [0,1,1,2,3]
14:14:07 <tootsie> > let fibs = scanl (+) 0 (1:fibs) in take 10 $ fibs
14:14:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
14:14:10 <arkeet> there, permutations with signs
14:14:20 <tootsie> 2src iterate
14:14:24 <tootsie> @src iterate
14:14:24 <lambdabot> iterate f x =  x : iterate f (f x)
14:14:42 <arkeet> @let permsWithSign l = let n = length l in map (product . map fst &&& map snd) $ replicateM n (StateT selectS) `evalStateT` l
14:14:42 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
14:14:56 <tootsie> > take 5 $ iterate (+1) 10
14:14:58 <lambdabot>   [10,11,12,13,14]
14:14:59 <arkeet> @let permsWithSign l = let n = length l in map (product . map fst &&& map snd) . evalStateT l $ replicateM n (StateT selectS)
14:15:00 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
14:15:06 <arkeet> where?
14:15:18 <arkeet> @let permsWithSign l = let n = length l in (map (product . map fst &&& map snd) . evalStateT l $ replicateM n (StateT selectS))
14:15:18 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
14:15:26 <arkeet> what?
14:15:36 <int-e> . vs &&&, I guess?
14:16:03 <int-e> > ?a . ?b &&& ?c
14:16:04 <lambdabot>   mueval-core: internal error: PAP object entered!
14:16:04 <lambdabot>      (GHC version 7.4.2 fo...
14:16:10 <int-e> what!
14:16:38 <arkeet> > 5
14:16:44 <lambdabot>   5
14:16:53 <arkeet> @ty ?a . ?b &&& ?c
14:16:57 <lambdabot> (?a::b1 -> c, ?b::b -> b1, ?c::b -> c') => b -> (c, c')
14:17:04 <ski_> @wn PAP
14:17:04 <lambdabot> *** "pap" wn "WordNet (r) 3.0 (2006)"
14:17:04 <lambdabot> pap
14:17:05 <lambdabot>     n 1: worthless or oversimplified ideas [syn: {pap}, {pablum}]
14:17:07 <lambdabot>     2: a diet that does not require chewing; advised for those with
14:17:09 <lambdabot>        intestinal disorders [syn: {soft diet}, {pap}, {spoon food}]
14:17:11 <lambdabot>     3: the small projection of a mammary gland [syn: {nipple},
14:17:13 <lambdabot>        {mammilla}, {mamilla}, {pap}, {teat}, {tit}]
14:17:35 <arkeet> @let permsWithSign l = map (product . map fst &&& map snd) $ replicateM (length l) (StateT selectS) `evalStateT` l
14:17:36 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
14:17:36 <int-e> "Partial APplication"
14:17:52 <arkeet> @let permsWithSign l = map ((product . map fst) &&& map snd) $ replicateM (length l) (StateT selectS) `evalStateT` l
14:17:54 <lambdabot>  Defined.
14:18:00 <arkeet> well uh ok
14:18:04 <arkeet> > permsWithSign [1..3]
14:18:05 <ab9rf> i like parp better
14:18:09 <lambdabot>   [(1,[1,2,3]),(-1,[1,3,2]),(-1,[2,1,3]),(1,[2,3,1]),(1,[3,1,2]),(-1,[3,2,1])]
14:18:46 <arkeet> > permsWithSign [1..3] ^.. folded . filtered ((==1) . fst) . _2
14:18:47 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2]]
14:18:56 <armlesshobo> @wn lin
14:18:57 <lambdabot> *** "lin" wn "WordNet (r) 3.0 (2006)"
14:18:57 <lambdabot> Lin
14:18:57 <lambdabot>     n 1: United States sculptor and architect whose public works
14:18:57 <lambdabot>          include the memorial to veterans of the Vietnam War in
14:18:57 <lambdabot>          Washington (born in 1959) [syn: {Lin}, {Maya Lin}]
14:19:02 <arkeet> > permsWithSign [1..4] ^.. folded . filtered ((==1) . fst) . _2
14:19:04 <lambdabot>   [[1,2,3,4],[1,3,4,2],[1,4,2,3],[2,1,4,3],[2,3,1,4],[2,4,3,1],[3,1,2,4],[3,2...
14:19:26 <Xaratas> ?
14:19:33 <arkeet> ?
14:19:35 <armlesshobo> ?
14:19:42 <arkeet> ??
14:19:50 <Xaratas> what was this?
14:19:57 <arkeet> you disconnected.
14:20:03 <int-e> @kind (->)
14:20:04 <lambdabot> * -> * -> *
14:20:33 <arkeet> I don't understand why lambdabot thought that was ambiguous.
14:20:36 <Xaratas> strange, only on freenode
14:20:43 <arkeet> infixr 9 . and infixr 3 &&&
14:20:49 <int-e> @type (.)
14:20:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:21:01 <arkeet> @let what = (.) in what
14:21:01 <lambdabot>   Parse error: in
14:21:03 <arkeet> :t what
14:21:04 <lambdabot> Not in scope: `what'
14:21:05 <arkeet> @let what = (.)
14:21:07 <lambdabot>  Defined.
14:21:08 <arkeet> :t what
14:21:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:21:10 <arkeet> hmm.
14:22:10 <arkeet> oh sure, I don't have to generate all permutations and then filter by the even ones.
14:23:47 <Xaratas> hm
14:24:02 <Xaratas> @hoogle selectS
14:24:02 <lambdabot> No results found
14:24:06 <Xaratas> :(
14:24:21 * hackagebot hsdns-cache 1.0.2 - Caching asynchronous DNS resolver.  http://hackage.haskell.org/package/hsdns-cache-1.0.2 (VladimirShabanov)
14:24:23 <ski_> looking for ?
14:24:39 <Xaratas> yes, and google is no help too
14:25:07 <ski_> what was `selectS' supposed to do, i meant ?
14:26:20 <typoclass> Xaratas: someone defined selectS above with @let. you could check the logs on tunes.org if you want
14:27:45 <ski_> i see, `@let selectS [] = []; selectS (x:xs) = ((1,x),xs) : map ((first.first) negate . second (x:)) (selectS xs)' apparently
14:27:45 <arkeet> > let perms' s [] = guard (s==1) >> [[]]; perms' s l = selectS l >>= \((s',x),xs) -> map (x:) (perms' (s*s') xs) in perms' 1 [1..3]
14:27:47 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2]]
14:28:04 <arkeet> > selectS [1..4]
14:28:06 <lambdabot>   [((1,1),[2,3,4]),((-1,2),[1,3,4]),((1,3),[1,2,4]),((-1,4),[1,2,3])]
14:28:12 * typoclass wonders what you people are doing ...
14:28:18 <int-e> arkeet: guard (s==1) >> [[]] == [[] | s==1]
14:28:22 <arkeet> fine.
14:28:27 <vlatkoB> What is type/kind of value extracted from IO action? In c <- readFile "", what the c actualy is? I know it is a string, but is it a function or a value? Can it be stored, say, in list?
14:28:42 <arkeet> vlatkoB:
14:28:45 <arkeet> :t readFile
14:28:47 <lambdabot> FilePath -> IO String
14:28:54 <ski_> > (guard (s==1) >> [[]]) == [[] | s==1]
14:28:55 <lambdabot>   True
14:29:00 <arkeet> vlatkoB: readFile "" is IO String, so after c <- readFile "", c is a String.
14:29:17 <arkeet> ski_: that doesn't really show what you want to show.
14:29:21 <arkeet> > s==1
14:29:22 <lambdabot>   False
14:29:25 <ski_> i know
14:29:27 <arkeet> :p
14:29:32 <typoclass> vlatkoB: yes, you can store it in lists and everything. it's a regular String value
14:29:44 <vlatkoB> arkeet: Yes, I know that. But if I store it in a list, I do get IO String, but c is actualy a String, isn't it?
14:30:21 <arkeet> vlatkoB: c is really a function argument.
14:30:22 <monochrom> "it" = what?  "it" = readFile "xxx"?  "it" = c?
14:30:24 <vlatkoB> I mean, it can be used in (map toUpper), so it must be a real String
14:30:33 <arkeet> do { c <- readFile ""; stuff }
14:30:35 <arkeet> is the same as
14:30:40 <arkeet> readFile "" >>= (\c -> stuff)
14:31:04 <arkeet> so inside stuff, you can use c as a String however you want
14:31:05 <ski_> vlatkoB : how did you attempt to "store it in a list" ?
14:31:27 <vlatkoB> It seems to me that if I store it in a list, it acts as c = readFile.
14:31:34 <arkeet> what?
14:31:46 <vlatkoB> list = map (readFile) somePaths
14:31:47 <typoclass> vlatkoB: yes, there's a difference between "=" and "<-". it'll produce a String if you do "x <- readFile ...", which is only available inside of do-blocks. if you do "x = readFile ..." or "let x = readFile ...", you'll have an IO String
14:31:50 <monochrom> ok, time to show actual code, natural language is not helping
14:32:00 <arkeet> vlatkoB: there's no c <- in map (readFile) somePaths.
14:32:04 <ski_> vlatkoB : that can't be the case, so you must be misunderstanding something somewhere. please provide more context
14:32:05 <arkeet> vlatkoB: but maybe you want mapM.
14:32:10 <Xaratas> @src first
14:32:11 <lambdabot> Source not found. There are some things that I just don't know.
14:32:26 <Xaratas> > :t first
14:32:28 <lambdabot>   <hint>:1:1: parse error on input `:'
14:32:32 <arkeet> vlatkoB: map readFile somePaths  just gives you a list of IO actions that read each file.
14:32:37 <ski_> @type first
14:32:38 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
14:33:03 <ski_> @type first `asAppliedTo` (undefined :: a -> b)
14:33:04 <vlatkoB> With map I get [IO String], but with mapM I get IO [String]
14:33:05 <lambdabot> (b -> c) -> (b, d) -> (c, d)
14:33:09 <arkeet> vlatkoB: indeed.
14:34:01 <tootsie> what is the advantage of little endian? there must be one right? or why woudl you do it the less logical way?
14:34:17 <Clint> it's trendy
14:34:18 <ski_>   map  :: (a ->    b) -> ([a] ->    [b])
14:34:25 <ski_>   mapM :: (a -> IO b) -> ([a] -> IO [b])
14:34:30 <arkeet> tootsie: it's easy to truncate a large word to a smaller word.
14:34:53 <arkeet> :t sequence . map
14:34:54 <lambdabot>     Couldn't match expected type `[m0 a0]'
14:34:55 <lambdabot>                 with actual type `[a1] -> [b0]'
14:34:55 <lambdabot>     Expected type: (a1 -> b0) -> [m0 a0]
14:34:56 <monochrom> also, map and mapM do very different things
14:34:58 <arkeet> :t sequence .: map
14:34:58 <elliott> tootsie: is this a haskell question?
14:34:59 <lambdabot>     Not in scope: `.:'
14:34:59 <lambdabot>     Perhaps you meant one of these:
14:34:59 <lambdabot>       `.' (imported from Prelude),
14:35:05 <arkeet> whaaat?
14:35:13 <elliott> haskell doesn't really specify anything about endianness of Int or whatever.
14:35:16 <monochrom> to some extent, you could even say, map doesn't do things at all
14:35:18 <arkeet> @let (.:) = (.).(.)
14:35:19 <arkeet> :t sequence .: map
14:35:20 * ski_ sobs
14:35:20 <simpson> tootsie: You don't have to do any pointer arithmetic when doing mixed-size reads from a single address in memory.
14:35:20 <lambdabot>  Defined.
14:35:20 <lambdabot>     Not in scope: `.:'
14:35:21 <lambdabot>     Perhaps you meant one of these:
14:35:21 <lambdabot>       `.' (imported from Prelude),
14:35:25 <arkeet> what??
14:35:33 <quchen> Ha.
14:35:40 <arkeet> what??
14:35:40 <arkeet> er
14:35:42 <arkeet> :t sequence .: map
14:35:43 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
14:35:51 <arkeet> I guess I was too fast for it.
14:35:55 <monochrom> the advantage of little endian is you can mock big endian
14:36:04 <Xaratas> hmm
14:36:20 <arkeet> does big-endian have any advantages?
14:36:25 <Clint> it's network order
14:36:31 <Clint> so you don't need an efficient xchg function all the time
14:36:33 <typoclass> tootsie: i don't think there's any big advantages. it's mostly tradition and technical reasons. at the processor/electronics/bit-fiddling level, this or that might be slightly easier, or might have been at one point
14:36:36 <arkeet> that's not an intrinsic advantage.
14:36:39 <monochrom> yes, you can mock small endian :)
14:36:40 <elliott> arkeet: you can, um, round, sort of.
14:36:40 <arkeet> why isn't network order little-endian?
14:36:53 <tgeeky> monochrom: i was going to blurt out that you couldn't mock little endian
14:36:56 <geekosaur> because Sun defined it and was using big-endian CPUs
14:37:05 <arkeet> heh.
14:37:14 <arkeet> I suppose big-endian is easier to sort.
14:37:17 <tgeeky> monochrom: becuase otherwise, how would mocking be an advantage as listed above
14:37:18 <arkeet> or compare
14:37:20 <geekosaur> (mind, it was sorely needed; look up the history of the "talk" protocol)
14:37:33 <arkeet> geekosaur: what was needed?
14:37:40 <vlatkoB> I'm trying to make a list that I can send to pure functions, but the list is outside of that function
14:37:40 <vlatkoB> inputs = map readFile paths
14:37:40 <vlatkoB> outputs :: (String -> String) -> [String]
14:37:40 <vlatkoB> outputs f = map (\x -> do c <-x; f c) inputs  -- doesn't work
14:37:41 <geekosaur> some kind of convention for network data
14:38:11 <geekosaur> "talk" was written before there was a convention, and it only worked between machines that had the same byte order
14:38:13 <monochrom> a long time ago, I used the "talk" program a lot
14:38:40 <arkeet> vlatkoB: of course. outputs does some IO, so there better be "IO" somewhere in its type.
14:38:50 <simpson> IIUC big-endian's primary advantage was that it was easier to read on core dumps.
14:38:59 <arkeet> heh.
14:39:02 <simpson> Or so an oldbeard at IBM once told me.
14:39:10 <geekosaur> Sun needed a convention so they could specify XDR (for NFS) in a way that would work on any platform, so they declared their native big-endian a de facto standard
14:39:11 <tootsie> "You don't have to do any pointer arithmetic when doing mixed-size reads from a single address in memory." Not sure what is meant here
14:39:25 <vlatkoB> In fact, it does not, it just takes the string value.
14:39:29 <ski_> vlatkoB : since `inputs' invokes `readFile', it must be "in" `IO'; and similarly for `outputs', since it invokes `inputs' -- so you need to revise the type signatures of those two (and also change the implementations slightly)
14:39:37 <geekosaur> if you read a (long) as a (short), the same address works
14:39:40 <simpson> tootsie: Say you have an address which is aligned to word size. On an x86, something like 0xc.
14:39:47 <geekosaur> (if little endian)
14:39:53 <arkeet> vlatkoB: no...
14:39:57 <simpson> tootsie: If you wish to read a byte, short, int, or long out of that address, you don't have to alter the address.
14:40:00 <arkeet> it seems like you have some misunderstanding of IO.
14:40:18 <simpson> tootsie: If you want to read a big-endian byte, you'd need 0xc+0x3.
14:40:18 <Xaratas> could lambdabot show the righth part of a defined let?
14:40:23 <arkeet> no
14:40:34 <arkeet> (it would be nice if it did, though!)
14:40:42 <typoclass> tootsie: the story is that the terms 'little' and 'big endian' are a reference to gulliver's travels. he visits a country where everyone is tiny, and their political problems are also tiny. most of their political discussion is about whether to eat breakfast eggs starting at the little end or at the big end
14:40:47 <Jambato> how can I update records with some inner state inside?
14:40:51 <vlatkoB> I meant that if f take any string and returns string that it is not really involved in IO. Doesn't matter where the string comes from.
14:41:02 <Jambato> is record update just fine or do I need lenses?
14:41:12 <arkeet> vlatkoB: sure, but outputs claims to give a list of strings.
14:41:15 <arkeet> where do those strings come from?
14:41:31 <ski_> vlatkoB : `inputs' can't be a list of strings. it can be an `IO'-action which when executed yields a list of strings, or (probably less useful here) a list of `IO'-actions each when executed yielding a string
14:41:33 <tootsie> typoclass: lol
14:41:56 <arkeet> inputs :: IO [String]
14:42:02 <arkeet> inputs = mapM readFile paths
14:42:27 <arkeet> outputs :: (String -> String) -> IO [String]
14:42:28 <arkeet> outputs f = do { c <- inputs; return (map f c) }
14:42:29 <arkeet> perhaps.
14:42:33 <vlatkoB> Hm, so it means even the function is pure, if input comes form impure source, the function output must be considered impure too?
14:42:40 <arkeet> outputs is not pure.
14:42:47 <arkeet> it has to do some IO to get some strings.
14:42:55 <arkeet> f is pure, and that's fine.
14:43:30 <elliott> vlatkoB: outputs f could not always give the same results for the same f.
14:43:40 <elliott> it would change depending on what the contents of the files are.
14:43:43 <elliott> orw hatever.
14:43:51 <elliott> so of course it has to declrae in its type that it does IO (returns an IO action)
14:44:19 <vlatkoB> I see. Thanks a lot. Been banging my head all day around it. Everything that touches IO, must declare itself as IO. Correct?
14:44:21 * hackagebot daemons 0.1.2 - Daemons in Haskell made fun and easy  http://hackage.haskell.org/package/daemons-0.1.2 (AlexandruScvortov)
14:44:27 <typoclass> Jambato: could you paste some example code? it's hard to tell what you mean by "internal state"
14:44:35 <ski_> (strictly speaking, it always gives the same `IO'-action, when given the same function `f' -- executing that `IO'-action in different states of the world may of course result in different answers, though)
14:44:44 <elliott> ski_: I meant a version of outputs that resulted in [String]
14:44:56 <elliott> (the impossible desired version)
14:45:04 <ski_> elliott : ok, fine
14:45:06 <elliott> vlatkoB: right.
14:45:10 <arkeet> nothing is impossible with unsafePerformIO!
14:45:25 <vlatkoB> :-)
14:45:40 <typoclass> vlatkoB: try thinking of it this way -- you start in 'main', fetch some input or files or whatever, then you use pure functions to process those Strings
14:45:40 <hpaste> Jambato revised “ ”: “sucker” at http://hpaste.org/85259
14:45:51 <Jambato> typoclass: there
14:45:55 <quchen> arkeet: unsafeCoerce is more flexible though
14:46:08 <ski_> @faq can you break the type system of Haskell, if you allow the use of `unsafePerformIO' ?
14:46:08 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:25 <typoclass> arkeet: could you please not mention that casually to beginners. or alternatively, make it clear that it's meant as a joke
14:46:33 <armlesshobo> @faw but, can Haskell help me get away with murder?
14:46:34 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:38 <armlesshobo> D:
14:46:42 <armlesshobo> faw?
14:46:54 <quchen> @faq Are there any other FAQ entries?
14:46:55 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:57 <ski_> (perhaps i should have s/break the type system of/dump core in/ or s/break the type system of/segfault in/ ..)
14:46:58 <quchen> I see.
14:46:59 <arkeet> typoclass: ok, pretend I put a ":p" on the end of it.
14:46:59 <int-e> armlesshobo: faq.
14:47:07 <seliopou> typoclass: are you a proponent of security through obscurity as well?
14:47:11 <arkeet> I thought it was pretty clear, though.
14:47:11 <monochrom> faw is spelling-corrected to faq
14:47:38 <monochrom> snap is spelling-corrected to slap, as you will see...
14:47:41 <monochrom> @snap monochrom
14:47:41 * lambdabot would never hurt monochrom!
14:47:54 <quchen> Frequently Asked qWestion.
14:47:59 <monochrom> that's very nice of lambdabot!
14:48:39 <monochrom> anyway, sometimes you want to convert IO String -> IO S
14:49:03 <typoclass> arkeet: fair enough
14:49:04 <typoclass> seliopou: i think it's a matter of giving people bad advice
14:49:38 <ski_> .. `S' ?
14:49:43 <typoclass> Jambato: so, which lines do you want to simplify?
14:49:46 <taesoo> I got 'magic number mismatch: old/corrupt interface file?' errors when installing ghc7.4.2/7.6.2 i386 on x64 machine, and tweaking .cabal doesn't help. Any help?
14:49:56 <monochrom> I was hoping for iOS
14:50:33 <elliott> taesoo: probably you have old packages installed?
14:50:37 <elliott> packages are GHC-version specific
14:50:40 <elliott> you must recompile them all
14:51:15 <monochrom> but GHC doesn't even see packages built for another GHC version
14:51:22 <taesoo> elliott: you mean in my host? I have 7.6.2 64bit installed in my machine.
14:51:52 <elliott> well, hmm. I was confused by you saying "ghc7.4.2/7.6.2"
14:52:13 <monochrom> I don't understand the question, and I think no one does
14:52:15 <taesoo> I've tried installing both i386.
14:52:48 <Jambato> typoclass: it was more of a design question actually
14:53:00 <taesoo> I basically want to cross-compile ghc i386, in x64, so wanted to install i386 binary dist.
14:53:22 <monochrom> ok, but it will not cross-compile to x86
14:53:29 <monochrom> err
14:53:31 <Jambato> 1. I'm wondering if I put too much state in my records
14:53:43 <monochrom> the i386 version will not cross-compile to x64
14:53:56 <seliopou> typoclass: a mention isn't advice
14:53:59 <Jambato> 2 . if I want to extract inner state from the records what would be the most convinient way to do so?
14:54:06 <taesoo> no I am using x64. I want to build i386.
14:54:07 <monochrom> the x64 version will also not cross-compiler to i386
14:54:10 <seliopou> but even so, it's a good way to learn
14:54:34 <taesoo> I know. that's why I need to install i386 ghc from the binary dist.
14:54:48 <arkeet> Jambato: how come you are storing state actions in a record?
14:55:14 <arkeet> I don't think that's what you want to do.
14:55:51 <__xc> hiptobecubic, foldr f x l  should be foldl f x (reverse l)
14:55:54 <monochrom> ok, but when installing ghc, ".cabal" does not matter, whatever that means
14:55:58 <typoclass> Jambato: you could have a single State (Player, GameState, Stack). depending on what additional code you'll be writing, this could simplify things
14:56:23 <taesoo> one record from the mailing list said that the problem is in the cabal pkg.
14:56:27 <tootsie> > (Just 5) >>= \a -> return $ a + 1
14:56:29 <lambdabot>   Just 6
14:56:29 <armlesshobo> typoclass: wouldn't they be able to use netwire for that?
14:56:34 <tootsie> > (Just 5) >>= (+1)
14:56:36 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
14:56:36 <lambdabot>    arising from a use o...
14:56:50 <tootsie> > (Just 5) >> (+1)
14:56:52 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
14:56:52 <lambdabot>              with actual...
14:57:03 <monochrom> that record comes with its peculiar context and may or may not apply to you
14:57:04 <typoclass> armlesshobo: i don't know much about netwire. not sure what the context is
14:57:05 <quchen> tootsie: +1 has type a -> a, not a -> m a.
14:57:12 <armlesshobo> (Just 5) >>= return $ (+1) . fromJust
14:57:17 <arkeet> oh god
14:57:19 <arkeet> :p
14:57:25 <arkeet> > (+1) <$> Just 5
14:57:27 <lambdabot>   Just 6
14:57:28 <armlesshobo> :P
14:57:30 <tootsie> @src fromJust
14:57:30 <lambdabot> fromJust Nothing  = undefined
14:57:30 <lambdabot> fromJust (Just x) = x
14:57:34 <monochrom> in general, everything said on the internet comes with its peculiar context and does not apply to other context
14:57:40 <ab9rf> > fmap (+1) (Just 5)
14:57:42 <lambdabot>   Just 6
14:57:47 <armlesshobo> that wouldn't work :\
14:58:08 <arkeet> it wouldn't.
14:58:24 <donri> > Just (fromJust (fmap succ (return 5)))
14:58:25 <hiptobecubic> > foldr f 0 [x,y,z] :: Expr
14:58:26 <lambdabot>   Just 6
14:58:27 <lambdabot>   f x (f y (f z 0))
14:58:36 <hiptobecubic> > foldl f 0 (reverse [x,y,z]) :: Expr
14:58:37 <lambdabot>   f (f (f 0 z) y) x
14:58:47 <donri> > foldr f 0 [x,y,z]
14:58:48 <ski_> > return . (1 +) =<< Just 5
14:58:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:58:49 <lambdabot>    (GHC.Num.Num a0)
14:58:49 <lambdabot>      a...
14:58:50 <lambdabot>   Just 6
14:58:52 <arkeet> > foldl (flip f) 0 (reverse [x,y,z]) :: Expr
14:58:54 <lambdabot>   f x (f y (f z 0))
14:59:13 <ski_> tootsie ^
14:59:14 <taesoo> I see, then how can ghc-cabal think the .hi files bad interface?
14:59:20 <otters> :t f `asAppliedTo` 0
14:59:21 <hiptobecubic> arkeet, you ruined it
14:59:22 <lambdabot> (Num t, Show t, FromExpr b) => t -> b
14:59:26 <arkeet> =(
14:59:33 <ab9rf> poor lambdabot
14:59:49 <ski_> @botsnack
14:59:49 <lambdabot> :)
14:59:50 <armlesshobo> > Just 5 >>= return . (+1)
14:59:51 <typoclass> seliopou: i disagree. i don't think it's "a good way to learn" if a beginner uses unsafePerformIO to solve his for beginner-level issues about being trapped in the IO monad and String vs. IO String
14:59:51 <lambdabot>   Just 6
14:59:55 <armlesshobo> :)
14:59:55 <taesoo> monochrom: only difference is that I have ghc 64bit installed and my machine is 64bit.
15:00:03 <monochrom> I have never heard of ghc-cabal. is it ghc or is it cabal?
15:00:18 <arkeet> monochrom: yes ;)
15:00:19 <taesoo> 'ghc-cabal: Bad interface file: dist-install/build/GHC/Classes.hi'
15:00:22 <taesoo> is the error
15:00:29 <ab9rf> typoclass: unsafePerformIO is not the sort of thing a beginner ought to be using milly vanilly
15:00:43 <monochrom> what command did you enter before getting that error?
15:00:44 <taesoo> 'magic number mismatch: old/corrupt interface file?' follows.
15:00:54 <typoclass> ab9rf: sure
15:00:54 <ab9rf> taesoo: are you mixing architectures?
15:01:01 <sproingie> ab9rf: but when your program fails you can blame it on the rain
15:01:12 <taesoo> (ghc-7.6.2-i386-unknown-linux.tar.bz2) ./configure & make install
15:01:27 <taesoo> ab9rf: yes.
15:01:47 <ab9rf> taesoo: you probably have unclean files, make clean first
15:01:56 <typoclass> ab9rf: yes, taesoo's trying to cross-compile
15:02:06 <ab9rf> sproingie: you are a naughty person
15:02:10 <taesoo> unclean what files?
15:02:13 <hiptobecubic> __xc, if you didn't see. you weren't quite right.
15:02:15 <ab9rf> typoclass: och, down that road lies madness
15:02:47 <taesoo> the ghc-.7.4.2 Makefile doesn't even have unclean?
15:02:52 <monochrom> I would be happy to say "corrupted download", but perhaps there is something else
15:03:05 <ab9rf> taesoo: you are probably trying to use intermediate compilation results that were made for the wrong architecture
15:03:06 <tootsie> @type unsafePerformIO
15:03:07 <lambdabot> Not in scope: `unsafePerformIO'
15:03:17 <tootsie> what does unsafePerformIO do?
15:03:18 <otters> where is asAppliedTo?
15:03:20 <otters> @where asAppliedTo
15:03:20 <lambdabot> I know nothing about asappliedto.
15:03:29 <ab9rf> taesoo: it does magic
15:03:40 <monochrom> you mean tootsie
15:03:45 <taesoo> ab9rf: basically the magic interface number should match to the host machine?
15:03:47 <ab9rf> sorry, yes
15:03:53 <quchen> otters: asAppliedTo = const
15:04:10 <ab9rf> taesoo: a magic number mismatch means that the file's magic number is not as expected, and so the file is not valid.
15:04:25 <typoclass> tootsie: it's an advanced thing for when you know exactly what you're doing. it's an escape that lets you circumvent the regular haskell way of doing things
15:04:26 <ab9rf> taesoo: if you got that on an .hi, it means the .hi is corrupted or written for a different architecture.
15:04:35 <Jambato> typoclass: it doesn't seem very elegant to pass such a big chunk of state around like that
15:04:43 <ab9rf> Jambato: it's perfectly elegant.
15:04:59 <monochrom> ab9rf: and if you got that .hi file straight from a binary tarball from ghc's website?
15:04:59 <taesoo> ab9rf: I guess the magic number is put by i386 ghc which I downloaded from the bin dist? why they mismatch themselves?
15:05:05 <ab9rf> Jambato: it beats having it lurking in the shadows
15:05:23 <ski_> tootsie : in case `act' of type `IO a' is declaratively equivalent to `return x' for some `x' of type `a', then `unsafePerformIO act' evaluates to `x'; otherwise, anything at all can happen (including crashes, segfaults, silently corrupted data, missiles launched, demons flying out of your nose, &c.), iow UB (Undefined Behaviour)
15:05:23 <ab9rf> monochrom: then you should file an incident report :)
15:05:28 <taesoo> monochrom: precisely, what I wanted to say.
15:05:53 <__xc> hiptobecubic, yes indeed with (-) for example
15:05:56 <monochrom> I'm just going to conclude "corrupted download" unless further evidence proves otherwise
15:06:05 <hiptobecubic> __xc, right
15:06:07 <ab9rf> monochrom: it's either a corrupted download or a build error
15:06:24 <taesoo> I double the corrupted download. many other arch32 users use ghc i386.
15:06:25 <typoclass> Jambato: true. you could use a "type ... = ...", or another record, to save on typing
15:06:31 <ski_> tootsie : iow, using `unsafePerformIO' comes with a proof obligation on the user to ensure only semantically pure actions are passed to it
15:06:39 <ab9rf> i use ghc i386, it works fine :)
15:06:41 <Jambato> I will explore that path then
15:06:51 <monochrom> oh, there is a better conclusion. 32-bit ghc is not meant to run on 64-bit OS. at all.
15:06:59 <taesoo> umm. I suspect that x86 env somehow affects the behaviour of i386.
15:07:05 <__xc> hiptobecubic, could I ask you to fetch&hpaste some lines 30 minutes ago, concerning *fold*, my stupid client erased them
15:07:13 <__xc> please
15:07:32 <typoclass> __xc: tunes.org has logs of this channel (see topic)
15:07:33 <taesoo> then x64 ghc can generate i386 binary?
15:07:36 <ab9rf> monochrom: i use the 32 bit build of GHC on a 64 bit platform :)
15:07:45 <taesoo> I doubt that my rts is only compiled as x64.
15:07:46 <__xc> ah perfect
15:07:48 <Jambato> typoclass: but still; if I were to keep my current stateful records, how would I update them?
15:07:49 <tootsie> so what is unsafePerformIO needed for?
15:07:56 <__xc> typoclass, thx
15:08:15 <ski_> __xc : perhaps check <http://tunes.org/~nef/logs/haskell/13.04.05> ?
15:08:19 <hiptobecubic> tootsie, the most reasonable use is when the programmer can guarantee purity (libc.math comes to mind) but ghc cannot
15:08:32 <ab9rf> tootsie: when you want to reach inside the looking glass :)
15:08:47 <quchen> tootsie: FFI functions for example. Pointers in C are malloc'd in a nondeterminstic way, even though the value contained may be deterministic
15:09:09 <quchen> That and Debug.Trace
15:09:17 <ski_> tootsie : e.g. for FFI things, where you `foreign import' an imperative interface, but then can manage to wrap it safely with a pure declarative interface
15:09:45 <__xc> perfect ski_
15:10:33 <tootsie> i c
15:10:59 <mikeplus64> :t f
15:11:00 <lambdabot> FromExpr a => a
15:11:02 <tootsie> what comes next n project mayhem?
15:11:17 <tootsie> > f 1
15:11:19 <lambdabot>   Ambiguous type variable `a0' in the constraints:
15:11:19 <lambdabot>    (GHC.Show.Show a0)
15:11:19 <lambdabot>     ...
15:11:29 <ski_> > f 1 + 0
15:11:31 <lambdabot>   Ambiguous type variable `a0' in the constraints:
15:11:31 <lambdabot>    (GHC.Num.Num a0)
15:11:31 <lambdabot>      a...
15:11:42 <ski_> > f 1 :: Expr
15:11:44 <lambdabot>   f 1
15:12:07 <typoclass> Jambato: there is e.g. 'record update syntax'. if you have a "g :: GameState", you can do "x = g { players = someNewValue }". x will be a new record with the same contents as g, only with the 'players' field changed
15:13:23 <taesoo> ah! while 'make install', it invoted my cc without -m32 flag (by the way, I don't know why they need cc to install)
15:16:39 <taesoo> so "CFLAGS=-m32 ./configure --prefix=bla" works!
15:16:54 <typoclass> taesoo: how strange!
15:18:36 <taesoo> also to cross-compile i386, I need to add extra args like, ./bin/ghc -optc-m32 -opta-m32 -optl-m32 x.hs
15:18:46 <taesoo> but it works hehe
15:22:06 <thirsteh> is there a way to get multiline string literals without using Template Haskell? (I know you can use unlines or \n\ -> \, but I'd like to be able to copy-paste some text, a la Lisp strings or Python """foo\nbar"""
15:22:10 <armlesshobo> check self `before` wreck self
15:22:45 <thirsteh> if not, is there some simple TH module for this?
15:23:23 <thirsteh> (plus points if it's compatible with IsString/OverloadedStrings)
15:24:14 <quchen> thirsteh: Not that I know of. Batch edit all the lines to include "++" in your editor?
15:24:15 <ski_> > "\ \"
15:24:17 <lambdabot>   ""
15:24:18 <supki> @hackage string-quote
15:24:19 <lambdabot> http://hackage.haskell.org/package/string-quote
15:24:36 <supki> thirsteh: this, perhaps? ^
15:24:46 <monochrom> thirsteh: string-quote or string-qq, I don't know the difference
15:24:50 <thirsteh> yes, that looks exactly like what I want, thanks!
15:25:44 <monochrom> the user-side just needs QuasiQuotes
15:25:56 <thirsteh> perfect
15:26:18 <geekosaur> also the here package, although I can't tell if it's IsString-friendly
15:27:24 <Xaratas> wosa, so many stuff to learn
15:30:17 <thirsteh> string-quote worked perfectly
15:32:12 <tootsie> does haskell have something like twisted?
15:32:31 <ab9rf> tootsie: the python framework?
15:32:53 <hpc> what is twisted?
15:33:16 <monochrom> what do you look for, when you think "twisted"?
15:33:35 <hpc> a tarantino movie ;)
15:33:37 <Jambato> typoclass: okay. thanks for everything
15:33:41 <monochrom> I mean this:
15:34:00 <monochrom> twisted solves problem X by approach B
15:34:02 <hpc> nvm, it's an event-driven network stack
15:34:06 <typoclass> Jambato: you're welcome
15:34:06 <tootsie> yes sorry, the python eventdriven networking framework
15:34:35 <monochrom> some people, when mentioning "twisted", think "problem X". perhaps there is a haskell lib that also solves X.
15:35:15 <monochrom> some other people, when mentioning "twisted", think "approach B". it is unlikely that there is a haskell lib that also uses approach B.
15:35:17 <hpc> oleg solved problem X in the type system years ago
15:35:26 <typoclass> hpc: ... in python
15:35:33 <tootsie> monochrom: as i understand it eases the implementation of protocols? so if i were to write a torrent client i could use twisted and save some work(but maybe interesting work)...?
15:36:14 <ab9rf> tootsie: twisted is mostly just a bunch of templates that you shove your specific application into, combined with a main loop
15:36:29 <monochrom> then I dare say netwire eases implementing network protocols. but it is not going to use twisted's approach.
15:37:16 <typoclass> tootsie: haskell has a high-performance threads, so it might be the most natural approach to have a bunch of blocking threads, where in other languages you'd have to use something event-driven
15:38:13 <hpc> a lot of effort went into making multithreading into a problem of keeping that many references in memory at once
15:38:43 <hpc> on my dinky laptop at least, i don't start seeing slowdown until i exhaust my gig of RAM
15:47:39 <staafl> what is the most eloquent way to compare two tuples by their fst's?
15:47:48 <hpc> :t comparing fst
15:47:48 <elliott> :t comparing fst
15:47:50 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
15:47:50 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
15:47:54 <hpc> @quote stereo
15:47:55 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
15:47:58 <hpc> :(
15:48:01 <hiptobecubic> :(
15:48:04 <ion> :(
15:48:08 <hiptobecubic> hpc, you're striking out
15:48:09 <arkeet> :(
15:48:32 <arkeet> comparing should take a getter.
15:48:34 <monochrom> Hmm, Tyvski?
15:48:39 <typoclass> why is this quote causing widespread unhappiness?
15:48:50 <staafl> elliott, hpc, many thanks :-)
15:48:52 <hiptobecubic> can we throw that one out? @quote stereo should definitely be the other one
15:49:02 <arkeet> @quote stereo
15:49:02 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
15:49:03 <ion> typoclass: Because lambdabot failed us irredeemably by giving the wrong one. :-(
15:49:05 <hpc> or add @stereo
15:49:14 <hpc> arkeet: getter?
15:49:15 <monochrom> because they were looking for "welcome to #haskell, where questions are answered in stereo"
15:49:18 <arkeet> hpc: from lens
15:49:25 <hpc> ah, perhaps
15:49:26 <typoclass> hpc: 'majestic' seems unique
15:49:35 <elliott> that quote was removed
15:49:37 <elliott> (afaik)
15:49:47 <ion> why?
15:49:48 <elliott> and anyway, lambdabot's quote database got reset to some ancient version.
15:49:50 <arkeet> :t comparing (view _1)
15:49:52 <lambdabot> (Ord a, Field1 b t a b1) => b -> b -> Ordering
15:49:52 <monochrom> @quote fugue
15:49:52 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
15:50:11 <hpc> :t view _1
15:50:13 <lambdabot> (MonadReader s m, Field1 s t a b) => m a
15:50:14 <quchen> Contracrostipunctuous fugues!
15:50:15 <monochrom> mine is retained (even restored) because I have a fan :)
15:50:19 <ion> @type comparing . view
15:50:21 <lambdabot> Ord a => Getting a b t a b1 -> b -> b -> Ordering
15:50:22 <arkeet> :t view _1 :: (a,b) -> a
15:50:23 <lambdabot> (a, b) -> a
15:50:31 <typoclass> i've tried "@quote majestic" four times now, it always gives the right quote ("answered in majestic stereo")
15:50:33 <hpc> oh, so (->) works for that
15:50:35 <ion> @type view _1 `asAppliedTo` (undefined :: (a,b))
15:50:37 <lambdabot> (a, b) -> a
15:50:37 <arkeet> yes
15:50:44 <hpc> i need to learn lens
15:51:03 <ion> @type view _1 `asAppliedTo` (undefined :: (a,b,c,d))
15:51:05 <lambdabot> (a, b, c, d) -> a
15:51:23 <hiptobecubic> > comparing (view _1) (1, 2) (3,4)
15:51:25 <lambdabot>   LT
15:51:51 <tootsie> typoclass: but netwire is reactive
15:52:18 <elliott> @auote majestic
15:52:18 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
15:52:24 <elliott> typoclass: not the right quote :)
15:52:29 <amiller> hmm, does anyone recognize a slicker way of doing this:
15:52:30 <amiller> shapp :: Monad m => m (m a → m b) → a → m b
15:52:30 <amiller> shapp f a = f >>= \f → f (return a)
15:52:40 <amiller> i think i can do it easier by using fmap.
15:52:42 <typoclass> elliott: prankster :-)
15:52:44 <arkeet> join . fmap ap
15:52:45 <arkeet> er
15:52:49 <arkeet> errrr
15:52:52 <Xaratas> ok, all supplied normal and overkill versions tested. result: the easy ones are faster
15:52:52 <arkeet> :t join . fmap ap
15:52:54 <lambdabot> Monad m => (m a -> m (a -> b)) -> m a -> m b
15:52:56 <arkeet> nope.
15:53:02 <typoclass> tootsie: i don't know much about netwire. i thought it was for user interfaces and such
15:53:09 <elliott> amiller: that is a strange function
15:53:12 <elliott> why do you need it?
15:53:19 <arkeet> m (m a -> m b) sounds like a strange thing to have.
15:53:24 <amiller> call by name semantics
15:53:38 <ion> @type let f `onLens` l = f `on` view l in compare `onLens` _1
15:53:40 <lambdabot> (Ord b, Field1 a t b b1) => a -> a -> Ordering
15:54:01 <elliott> ion: onGetter, you mean
15:54:05 <arkeet> :p
15:55:05 <ion> elliott: onGarryGum
15:55:21 <amiller> i didn't know about ap that helps me though
15:55:29 <typoclass> Xaratas: yup :-) that's often the result. shows how important measuring is (instead of theorizing that the complicated clever thing will be faster)
15:57:37 <tootsie> > let analyze method data = (+) method data in method `analyze` data where method = 5; data = 9;
15:57:39 <lambdabot>   <hint>:1:20: parse error on input `data'
15:57:46 <amiller> shapp :: Monad m => m (m a → m b) → a → m b
15:57:46 <amiller> shapp f = join . ap f . return . return
15:57:53 <amiller> that's slightly more pointless
15:58:00 <tootsie> > let analyze method data = (+) method data in 7 `analyze` 9
15:58:02 <lambdabot>   <hint>:1:20: parse error on input `data'
15:58:07 <elliott> slightly more unreadable
15:58:11 <edwardk> > lag (2^32)
15:58:14 <lambdabot>   27.232730275033873
15:58:16 <amiller> yeah not a net win
15:58:20 <monochrom> "data" is a reserved word. use another word
15:58:25 <otters> :t lag
15:58:26 <lambdabot> Floating a => a -> a
15:58:38 <otters> ):
15:58:40 <edwardk> lag = lambert's W / log 2
15:58:40 <tootsie> > let analyze method dt = (+) method dt in 7 `analyze` 9
15:58:42 <lambdabot>   16
15:58:45 <Xaratas> typoclass: it took me a while to figure out what i have all to import to get the overkill things to work
15:58:58 <edwardk> it came up earlier when i was analyzing some asymptotics
15:59:25 <edwardk> i called it that because it seemed like log but a little slower
15:59:43 <hiptobecubic> Does anyone have some nice example code using mutable vectors in ST?
15:59:51 <hiptobecubic> Doesn't matter what it's doing
16:11:41 <tootsie> > how would haskell fare for distributed internet stuff like google?
16:12:11 <hpc> not in scope: `how'
16:13:33 <Nisstyre-laptop> what's the best way to parse Text into UTCTime?
16:13:40 <Nisstyre-laptop> is there something that does this already?
16:14:42 <hpc> Nisstyre-laptop: to string, then use the formatted read function
16:14:54 <Nisstyre-laptop> hpc: is there a performance overhead?
16:15:08 <hpc> probably
16:15:10 <Nisstyre-laptop> ugh
16:15:14 <hpc> shouldn't be much since the strings are short
16:15:18 <Nisstyre-laptop> I guess
16:15:41 <Nisstyre-laptop> hpc: speaking of converting it to string though, is the only way to do it to convert it to ByteString first?
16:15:49 <Nisstyre-laptop> or can I directly convert Text to String?
16:15:56 <hpc> you have to go directly from Text to String
16:16:05 <hpc> Text is text, String is text, but ByteString is bytes
16:16:14 <Nisstyre-laptop> yeah, what is the function for converting Text to String?
16:16:18 <hpc> uh
16:16:29 <hpc> (hoogle is slow)
16:16:41 <Nisstyre-laptop> yeah it's slow for me too
16:16:55 <hpc> unpack
16:17:03 <hpc> subject to fusion, sayeth the docs
16:17:03 <Nisstyre-laptop> ah okay
16:17:34 <hpc> and there's a pre-defined format string for rfc 822 or something like that
16:17:52 <Nisstyre-laptop> hpc: I'm doing "parseTime defaultTimeLocale "%c" $ T.unpack t"
16:22:50 <Philonous> Nisstyre-laptop:  Text.unpack
16:22:50 <Philonous> Err, Data.Text.unpack
16:39:12 <hpaste> glguy pasted “folding tuples” at http://hpaste.org/85275
16:41:31 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
16:41:31 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
16:41:57 <gwern> @quote vector
16:42:14 <ab9rf> i've been hunting for ages for a nontrivial, nondemonstration use of the pause() system call.
16:42:20 <ab9rf> never found one
16:42:28 <ab9rf> so i know what you're talking about
16:44:43 <arkeet> "Usually, the pause system call is used in pair with the alarm system call. For example, the sleep(3C) function call may be implemented by combining these two system calls together."
16:44:49 <arkeet> hmm
16:45:37 <geekosaur> yeh, it's rarely useful by itself
16:47:13 <__xc> > and $ map (>10) [0..]
16:47:40 <__xc> to overkill it
16:47:56 <arkeet> all (>10) [0..]
16:48:06 <arkeet> > all (>10) [0..]
16:48:16 <arkeet> hello lambdabot.
16:48:37 <arkeet> __xc: it would return False immediately
16:52:07 <ab9rf> arkeet: although most often sleep is implemented with select
16:54:32 <__xc> it means the lazyness is specially optimized for foldr (&&)?
16:55:12 <ab9rf> i dunno if "specially optimized" is an accurate description
16:55:12 <monochrom> no, I don't think that's a right thought
16:56:27 <monochrom> just by following normal lazy evaluation rules, foldr (&&) already stops as soon as it sees False
16:57:02 <arkeet> False && _ = False
16:57:06 <monochrom> "False && _ = False" is part of the definition of &&
16:57:21 <arkeet> so as soon as it sees False on the left, it doesn't have to evaluate the stuff on the right.
16:57:21 <__xc> yes... indeed
16:57:34 <monochrom> foldr (&&) blah (False:whatever) = False && (foldr (&&) blah whatever)
16:57:46 <__xc> the _ is a the Big lazy stack
16:57:53 <int-e> > foldr (flip (&&)) (False : repeat True) -- something was "optimized", perhaps.
16:58:04 <arkeet> haha
16:58:16 <monochrom> it's just definition of &&, foldr, and mundane lazy evaluation. no special treatment
16:58:46 <monochrom> _ is not the big lazy stack
16:59:01 <int-e> (so there's a *very* good reason why && should evaluate its first argument first :)
16:59:42 <monochrom> when the computer changes "foldr (&&) blah (False:whatever)" to "False && (foldr (&&) blah whatever)", that is done literally
17:00:13 <monochrom> literally means the memory holds exactly a representation of those expressions unexpanded
17:01:15 <monochrom> the representation is as short as "False && (foldr (&&) blah whatever)". the part "(foldr (&&) blah whatever)" does not stand for a huge data structure.
17:01:40 <monochrom> perhaps read me http://www.vex.net/~trebla/haskell/lazy.xhtml
17:01:47 <int-e> too lazy.
17:02:27 <arkeet> well, you don't even need to talk about graphs to see it
17:02:29 <__xc> ok
17:02:42 <arkeet> since there isn't really anything that's shared.
17:03:14 <arkeet> > 0
17:03:20 <arkeet> well
17:03:26 <arkeet> freenode is having network issues right now anyway, so maybe it's that.
17:03:39 <monochrom> that is right and I already use no graph in my examples where there is no sharing to show
17:03:51 <arkeet> i.e. a netsplit
17:04:04 <int-e> services are absent, and I believe lambdabot does not see messages from unidentified users ... may be wrong.
17:05:12 <geekosaur> something is severely lagged, but responding enough to not actively trigger a netsplit
17:05:22 <geekosaur> (like, half an hour pagged apparently)
17:05:26 <geekosaur> *lagged
17:05:29 <geekosaur> they're working on it
17:07:00 <monochrom> during these dark times, relativity is most valuable
17:07:12 <Ontolog_> simple question
17:07:19 <Ontolog_> I don't understand the result of this: scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
17:07:30 <Ontolog_> which is [3,4,5,5,7,9,9,9]
17:07:37 <arkeet> do you understand what scanl1 does?
17:07:39 <Ontolog_> why is 3 included in the result?
17:07:42 <Ontolog_> apparently
17:07:45 <__xc> > foldr (flip (&&)) True (True:False:repeat True)
17:07:50 <Ontolog_> I would expect 3 to not be included
17:07:50 <elliott> I miss when freenode's netsplits were obvious and explosive.
17:07:58 <monochrom> scanl1 always includes the head
17:08:12 <Ontolog_> ah ok so that explains it
17:08:19 <int-e> > scanl max 3 [4,5,3,7,9,2,1]
17:08:24 <Ontolog_> and scanr1 always includes the tail?
17:08:31 <monochrom> I forgot
17:08:48 <__xc> int-e, missed your msg
17:08:48 <int-e> Ontolog_: sure
17:09:16 <Ontolog_> int-e: sure as in 'why not'? lol
17:09:26 <int-e> Ontolog: sure as in "of course."
17:12:10 <int-e> hmm, so  scanl1 max . scanr1 max == \xs -> map (const (maximum xs)) xs  for law-abiding Ord instances
17:12:39 <BMeph> Ontolog_: If by "the tail," you mean "the last," then yes. int-e: "UR DOIN IT RONG" ;)
17:13:11 <Ontolog> yeah i meant the last element i guess tail is everything except the head right?
17:13:20 <arkeet> yes
17:13:30 <int-e> BMeph: I'm using an error correcting natural language parser ;)
17:13:48 <monochrom> I use an error-correcting modem
17:14:06 <BMeph> int-e: "UR USIN IT RONG" ;)
17:14:15 <Ontolog> int-e's answer was to the point
17:14:18 <Ontolog> kind of
17:14:36 <BMeph> I'm using an IRC channel with error-correcting participants! ;)
17:15:18 <monochrom> they are the most annoying
17:15:43 <int-e> BMeph: How you can abide all the nitpicking I'll never know.
17:15:46 <BMeph> monochrom: channels or participants? ;)
17:15:58 <monochrom> participants
17:16:21 <BMeph> monochrom: Or did you mean servers? ;p
17:16:46 <monochrom> servers are not annoying yet
17:17:55 <BMeph> int-e: My secret? I'm one of the nitpickers! 8D
17:17:59 <arkeet> monochrom: well, they are right now!
17:18:48 <monochrom> my secret is adding more errors to overwork them
17:21:10 <int-e> BMeph: Congratulations! You gave the intended answer! :_P
17:21:37 <int-e> (Aw. Poor nose. This is better: :-P)
17:22:11 <geekosaur> @bot
17:22:16 <geekosaur> hm, not yet
17:22:25 <geekosaur> some stuff coming unstuck finally
17:31:18 <ARCADIVS> http://hackage.haskell.org/package/hstats-0.3 How do I install this even though it depends on haskell98?
17:32:14 <geekosaur> cabal unpack hstats; cd hstats; edit hstats.cabal to remove base; cabal install (no package name)
17:33:15 <monochrom> I am looking at its source code. it seems to have no reason to depend on haskell98, but every reason to depend on base.
17:33:24 <monochrom> that is, it imports Data.List rather than List
17:35:09 <ARCADIVS> Thank, you, geekosaur. :)
17:35:22 <geekosaur> see what monochrom said though
17:35:32 <geekosaur> sounds like your eally want to leave base and remove haskell98
17:36:15 <ARCADIVS> I'm learning some statistics and figured it would be useful to have Haskell/ghci on my side for quick calculations.
17:36:37 * hackagebot hspec 1.5.3 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.5.3 (SimonHengel)
17:37:37 <lightquake> is there a (potentially unsafe) way to take an arbitrary value and either call show on it or return a string "cannot be shown"?
17:38:02 <jtbandes> lightquake: shows
17:38:03 <shachaf> Yes: const "cannot be shown"
17:38:03 <lightquake> shows requires the Show typeclass
17:38:06 <lightquake> i'm looking for something that doesn't (yes i know this is bad, i'm using it for debugging only)
17:38:09 <jtbandes> I've been wondering, is there any way to do something like this: foldl (,,) ($) [1,2,3] ?
17:38:11 <arkeet> lightquake: probably another class and some OverlappingInstances.
17:38:23 * hackagebot fay 0.14.3.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.14.3.0 (AdamBergmark)
17:38:24 * hackagebot fay-base 0.14.3.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.14.3.0 (AdamBergmark)
17:38:24 <quchen> jtbandes: What should that do?
17:38:30 <arkeet> class C a where ...; instance C a; instance Show a => C a
17:38:34 <arkeet> with different definitions
17:38:36 <arkeet> ?
17:38:38 <jtbandes> quchen: the same as  (,,) 1 2 3
17:38:45 <quchen> Oh. That won't work due to the type system.
17:38:46 <quchen> What would foldl (,,) ($) [1,2,3,4] do?
17:38:47 <jtbandes> preferably, it would produce (1,2,3) and ignore 4 :)
17:38:50 <seliopou> :t foldl (,,,) ($) [1, 2, 3, 4]
17:38:50 <lambdabot>     Occurs check: cannot construct the infinite type:
17:38:50 <lambdabot>       b1 = ((d0 -> b1) -> d0 -> b1, b0, d0 -> b1, d0)
17:38:50 <lambdabot>     Expected type: ((d0 -> b1) -> d0 -> b1)
17:38:50 <quchen> I mean you can define such a function but it'll be very un-total and horrible in general.
17:38:50 <seliopou> :t foldl (,,) ($) [1, 2, 3, 4]
17:38:50 <lambdabot>     Occurs check: cannot construct the infinite type: c0 = b0 -> c0
17:38:50 <lambdabot>     Expected type: ((b0 -> c0) -> b0 -> c0)
17:38:50 <lambdabot>                    -> b0 -> (b0 -> c0) -> b0 -> c0
17:38:59 <quchen> > let apply f [a,b,c] = f a b c; apply _ xs = xs in apply (,,) [1,2,3]
17:38:59 <lambdabot>   Couldn't match expected type `[t0]' with actual type `(t0, t0, t0)'
17:39:00 <typoclass> jtbandes: there's not really any way to convert them, because tuples and lists just have different roles
17:39:00 <ab9rf> noting :)
17:39:04 <jtbandes> seliopou: it doesn't work that way because it expects the type of (,,) to be the same type as ((,,) 1)
17:39:04 <seliopou> quchen: you need to match on the rest of the list
17:39:04 <quchen> seliopou: Did.
17:39:12 <quchen> Problem's the type mismatch.
17:39:12 <typoclass> (... not completely different roles, just somewhat different)
17:39:12 <seliopou> jtbandes: I know, just demonstrating that it doesn't work
17:39:15 <seliopou> quchen: you are correct
17:39:19 <jtbandes> typoclass: but theoretically one might be able to "promote" a list to a tuple
17:39:19 <jtbandes> lists are homogeneous, tuples don't have to be
17:39:21 <quchen> jtbandes: Problem is tuples are of fixed size.
17:39:22 <jtbandes> in any case, I think the general "foldl with functions" is interesting, not just this specific example
17:39:31 <jtbandes> I mean, foldl is always used with functions... the interesting ones are the ones that aren't a -> a
17:39:34 <quchen> foldl is pretty much only used with a->a->a.
17:39:35 <seliopou> jtbandes: what do you mean by that?
17:39:35 <quchen> foldr is the folding function.
17:39:35 <seliopou> quchen: that's not the case
17:39:41 <ab9rf> a 2-tuple is a different type than a 3-tuple, and so forth
17:39:42 <glguy> You can do something like this if you have to have that fold behavior :) http://hpaste.org/85275
17:39:50 <quchen> You can do interesting stuff with foldr, like all that function-as-data folding etc. Foldl is boring.
17:40:00 <seliopou> :t mconcat
17:40:00 <lambdabot> Monoid a => [a] -> a
17:40:01 <arkeet> hmmm.
17:40:09 <quchen> glguy: Nice example code :-)
17:40:15 <quchen> That's basically Auto, right?
17:40:24 <arkeet> hmm.
17:40:25 <glguy> Could be. What is Auto?
17:40:26 <quchen> Automaton arrow
17:40:28 <ab9rf> quchen: you can do pretty much anything you can do with foldr with foldl, but the foldl version is likely to be inefficient :)
17:40:29 <glguy> Ah, so I was on the right page :)
17:40:29 <quchen> Thing that givey you a value and modifies itself
17:40:29 <quchen> Your Func doesn't result in a value, but apart from that it looks similar.
17:40:32 <arkeet> maybe that doesn't work.
17:40:56 <ARCADIVS> geekosaur, monochrom: if you're curious the package installed and works fine after just removing haskell98. :)
17:41:23 <arkeet> no one should use haskell98.
17:41:36 <geekosaur> it's an ancient package from back when that made a certain amount of sense
17:41:57 <monochrom> time flies like an arrow
17:42:21 <monochrom> burritos fly like a monad
17:42:33 <arkeet> hah
17:42:35 <arkeet> :(
17:43:03 <arkeet> lightquake: ok, I guess what I was thinking won't work.
17:51:59 <ab9rf> monochrom: boo
17:52:28 <monochrom> booritos, you say?
17:52:41 <monochrom> booritos fly like a moonad
17:52:59 <ab9rf> moo
17:53:47 <monochrom> http://bigzaphod.org/cow/
17:54:42 <ab9rf> i once spent three weeks implementing cow
17:54:45 <lambdabot> :)
17:54:58 <monochrom> oh, there she is!
17:55:52 <__xc> boom it blasts all pending requests ;)
17:59:04 <lambdabot> :)
17:59:38 <lambdabot> :)
17:59:46 <monochrom> hahaha
18:00:39 <monochrom> this is like you're on the subway and you see a passenger who burst out laugh spontaneously
18:01:06 <ab9rf> monochrom: that's less strange these days, though, because of smartphones
18:01:57 <monochrom> yes but imagine this passenger has no smart phone and not reading or watching anything in particular, just stares blankly and then occasionally laughs
18:02:14 <ab9rf> monochrom: that's common enough in chicagoland
18:02:37 <monochrom> that is creepy
18:07:58 <lambdabot>   0
18:08:31 <monochrom> that was, finally, my "> 0"
18:08:57 <monochrom> this is so "we are receiving answers from the Mars rover"
18:09:00 <Ralith> it always confuses me when zero evaluates to zero.
18:11:22 <seliopou> :t 0
18:11:22 <lambdabot> Num a => a
18:15:49 <shapr[> ab9rf: oh hi!
18:16:14 <monochrom> a shapr with an unmatched bracket!
18:16:20 <shapr[> ab9rf: How's the PHP parsing project going?
18:16:20 <ab9rf> heh
18:16:27 <shachaf> hi shapr[
18:16:31 <shapr[> hi shachaf
18:16:33 <shapr[> hi monochrom
18:16:36 <monochrom> perhaps I should try this too
18:16:57 <shapr[> :-P
18:16:58 <ab9rf> shapr[: i've not been working on it, i had a client project for a week and then i got distracted by something else and now it's tax time
18:17:00 <shachaf> monochrom[:] Now I'll have to address you like this.
18:17:09 <monochrom[> yeah]
18:17:33 <shapr[> ab9rf: student loans make tax time easy for me. Are you self-employed? Do you get to use Haskell for work?
18:17:49 <ab9rf> i also got diverted into writing something to transform YACC grammars :)
18:17:58 <shapr[> that sounds exciting, what does it do?
18:18:53 <shapr[> I haven't written any Haskell lately, but I have more free time now, I hope to do more with Haskell on my Raspberry Pi
18:19:44 <shapr[> oh hai copumpkin
18:19:46 <ab9rf> shapr[: the idea of the grammar transformer is so i can take php's grammar (YACC) and smoosh it into a Happy grammar without having to spend hours manually editing it
18:19:58 <shapr[> sounds sensible to me
18:20:01 <Kaidelong> if there's a copumpkin, where is the contrapumpkin?
18:20:08 <shapr[> monochrom: That square bracket was painful, yah?
18:20:19 <shapr[> Kaidelong: long time no see! How's life?
18:21:00 <shapr[> ab9rf: Is it working?
18:21:08 <Kaidelong> admittedly I could definitely be doing better, but it'd be more appropriate to discuss that in -blah
18:21:14 <ab9rf> shapr[: sorta :)
18:21:35 * shapr[ checks ab9rf's github repos
18:22:03 <ab9rf> shapr[: check my gistst instead, the grammar abuser is only a gist at this point
18:22:04 <shapr[> Huh, dartmouth basic?
18:22:12 <ab9rf> shapr[: yeah that was a diversion
18:29:53 * ] thinks these could be known as shapr brackets
18:31:10 <copumpkin> ohai2u shapr[ and Kaidelong
18:32:37 <shapr[> ]: haha
18:35:47 <lispy> shapr[: that was fun, but I should get going :)
18:35:56 <shapr[> lispy: bye! nice to see you again!
18:39:25 <lambdabot> ivanm says: < Cale> Finite dimensional vector spaces over a field F are algebras for the monad of F-linear combinations of elements of a set. < ivanm> oooohhhhh.... _now_ I get you!
18:39:26 <hiptobecubic> ab9rf, hm ?
18:39:33 <hiptobecubic> It always feels weird to me to talk about "algebras" like there's more than one
18:39:36 <shapr[> ab9rf: I haven't checked the other PHP parsers written in Haskell, have you considered stealing one and munging it for your own purposes?
18:39:36 <hiptobecubic> Algebra was always just algebra
18:39:36 <hiptobecubic> then *you people* came along with all this garbage
18:39:40 <Ralith> arkeet: seems perfectly comprehensible to me.
18:39:42 <Ralith> it's just 'suspend indefinitely'
18:39:46 <typoclass> gwern: hehe, nice quote
18:39:46 <hiptobecubic> you could fork() and then pause() instead of calling exit() :)
18:39:47 <lambdabot>   False
18:39:49 <lambdabot>   False
18:40:20 <ab9rf> shapr[: i found a couple but all of them only parsed subsets
18:40:26 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
18:40:26 <lambdabot>              with actual type...
18:40:32 <lambdabot>   0
18:40:33 <ab9rf> shapr[: and none of them supported 5.4 or 5.5
18:40:36 <lambdabot>   *Exception: stack overflow
18:40:37 <lambdabot>   [3,4,5,5,7,9,9,9]
18:40:53 <lambdabot> :)
18:42:17 <hiptobecubic> Why did everything move from * to Data.* and Control.*?
18:42:18 <hiptobecubic> Everything is in one of those two. It doesn't seem like you gain much in exchange for breaking every script written up that point.
18:43:40 <lambdabot> :(
19:01:41 <genisage> how hard is it to tell if two functions are the same without plugging in every possible value?
19:02:08 <shapr[> genisage: I think that's about it.
19:02:36 <sipa> unless you know some restricting property of the functions
19:02:42 <genisage> What about classes of functions that are easier?
19:02:50 <sipa> like if you know they are linear, comparing two points suffices
19:03:12 <genisage> Yes, what restrictions can you place on the functions to make them more manageable?
19:03:39 <sipa> assuming they are constant is about the easiest case possible :p
19:03:43 <genisage> And if you know they're polynomial, the degree plus one points is enough.
19:04:02 <genisage> But those aren't very interesting.
19:04:30 <shapr[> genisage: I've seen Paul Hudak construct functions from a datatype and prove their equality that way, but that's the only thing I've ever seen work.
19:05:19 <napping> fryguybob: thanks for reporting the thing and tracking it down a bit
19:05:25 <niteria> for any interesting class of functions you can't
19:05:43 <genisage> I lambdabot also proves functions are equal, but not in the same way.
19:05:57 <shapr[> Paul Hudak's approach also lets you find recursion and loops and all that sort of thing.
19:06:01 <simpson> She does?
19:06:05 <niteria> it transforms a function
19:06:07 <genisage> Yes, with pl.
19:06:08 <napping> Given code you can prove functions equal
19:06:36 <genisage> But I expect that's just using a list of identities.
19:06:42 <jmcarthur> shapr[: what's with the [?
19:07:03 <shapr[> jmcarthur: My home desktop is online and nickserv wasn't
19:07:09 <genisage> And if the functions weren't equal it probably wouldn't terminate if you tried to transform one into the other.
19:07:26 <jmcarthur> woo!
19:07:26 <shachaf> napping: Even without code you can prove functions equal sometimes!
19:07:32 <genisage> But I'll look up Pual Hudak, thanks.
19:07:55 <shapr> genisage: He demonstrated that approach in a haskell-cafe message about eight years ago.
19:07:55 <niteria> yeah, some types have only one inhibitant
19:08:04 <shapr> Not sure I can track down the exact message.
19:08:17 <shapr> jmcarthur: How's code?
19:08:48 <jmcarthur> salright. same as usual. can never stick with one project long enough to make it awesome
19:09:33 <niteria> I never understood that article, what was the inherent reason that could be done
19:09:58 <jmcarthur> my last success was last november and it was a 150-line project...
19:10:13 <niteria> I assume you mean this http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
19:10:14 <shapr> jmcarthur: but in Haskell, that's SO MUCH MORE!
19:10:39 <jmcarthur> well, i'd call it interesting and useful but not a *lot*
19:10:53 <jmcarthur> brb
19:13:14 <jmcarthur> shapr: what have you been up to?
19:14:11 <shapr> jmcarthur: writing C++ and IBM 360 assembly, but the wounds are healing
19:14:24 <jmcarthur> both can be fulfilling, IMO
19:14:25 <shapr> Today I'm writing DrScheme and Haskell for a talk I'm giving in AI class
19:15:03 <jmcarthur> nice. i've *still* not given scheme much attention. i've never felt like i would get much out of it after haskell
19:15:16 <shapr> I'm still a fan of SICP.
19:15:35 <shapr> Homoiconicity is certainly nice, especially compared to Template Haskell.
19:15:37 <jmcarthur> seems like everything i can think of in sicp is doable, perhaps even *more* elegant, in haskell...
19:15:41 <monochrom> macro is the only significant value you'll get
19:15:41 <jmcarthur> that i agree with
19:15:49 <jmcarthur> macros are pretty great
19:15:53 <pharaun> i have mixed feeling on macros
19:15:58 <monochrom> @quote monochrom syntax
19:16:00 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
19:16:02 <jmcarthur> on the other hand, inlining is great, too
19:16:19 <jmcarthur> which has many (but of course not all) of the benefits
19:16:20 <pharaun> seems like it could be a real horror, but i would like to have it... TH is kinda awkward for me so far
19:16:20 <shapr> pharaun: Why so?
19:16:42 <pharaun> then again shitty macro is just like shitty api *shrugs* :)
19:16:56 <pharaun> shapr: just fearing my own sanity if i fall into some insane macro traps
19:17:37 <shapr> I've only done macros in elisp, but I agree it can get weird.
19:17:55 <jmcarthur> macros are a slightly different flavor of ways to design nice DSLs
19:18:19 <jmcarthur> they feel more like writing a compiler than writing an interpreter. the latter is what most haskell DSLs feel like
19:18:27 <shapr> That makes sense to me.
19:21:38 <fryguybob> napping: No problem.  Was this just a case you were curious about or something you ran into from some other code?
19:22:08 <napping> just curious after running across a claim that GHC allowed write skew
19:22:18 <napping> certainly isn't supposed to!
19:23:19 <fryguybob> Yeah, I'm not sure where that claim is from.
19:24:50 <fryguybob> I see sclv states it in http://stackoverflow.com/questions/4560605/how-does-clojure-stm-differ-from-haskell-stm
19:25:46 <fryguybob> sclv: Is this claim from experience or something else?
19:26:08 <sclv> sloppily writen sentence
19:26:16 <sclv> meant that mvcc allows write skew
19:26:18 <sclv> not ghc
19:26:23 <sclv> but clojure
19:26:31 <fryguybob> Ah, ok.
19:26:33 <napping> well, it seems you were actually correct about GHC allowing write skew!
19:26:38 <fryguybob> hehe
19:26:46 <monochrom> there was a demonstrating experiment posted on hpaste. let me find it.
19:26:57 <napping> I posted it a night or two ago
19:26:58 <fryguybob> monochrom: It is a bug
19:27:03 <napping> and fryguybob make a ticket for it
19:27:06 <fryguybob> http://hackage.haskell.org/trac/ghc/ticket/7815
19:27:24 <monochrom> ok then that's it
19:28:14 <sclv> just edited it to make it more clear.
19:30:52 <sclv> fryguybob: wow. that's some really subtle stuff going on
19:31:05 <sclv> good detective work tho
19:31:23 <fryguybob> Thanks.  Also, I don't know enough about ARM's memory model to be sure, but I think there would need to be some more protection to avoid bugs there.
19:32:03 <fryguybob> sclv: I'm burried right now in STM internals for my grad work so it wasn't too much extra effort for me to look into it.
19:33:20 <sclv> haha. i love this stuff but if i bury myself in it my head will start spinning around like exorcist and i will start spitting blood
19:35:35 <hiptobecubic> what a bug
19:37:10 <djahandarie> @remember sclv haha. i love this stuff but if i bury myself in it my head will start spinning around like exorcist and i will start spitting blood
19:37:11 <lambdabot> It is forever etched in my memory.
20:03:40 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
20:03:40 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
20:59:55 <hpaste> “Konsumen Cerdas Paham Perlindungan Konsumen” pasted “Konsumen Cerdas Paham Perlindungan Konsumen” at http://hpaste.org/85276
21:00:29 <hpaste> “Keretamini.com pabrik kereta mini no 1. ready stock - Peduli BackLink Indonesia” pasted “Keretamini.com pabrik kereta mini no 1. ready stock - Peduli BackLink Indonesia” at http://hpaste.org/85277
21:00:54 <hpaste> “Sekolah Belajar Forex FBS Indonesia - Peduli Backlink Indonesia ” pasted “Sekolah Belajar Forex FBS Indonesia - Peduli Backlink Indonesia ” at http://hpaste.org/85278
21:00:57 <shachaf> preflex: seen chrisdone
21:00:58 <preflex>  chrisdone was last seen on #haskell-blah 14 hours and 58 seconds ago, saying: 〈(゜。゜)
21:01:21 <hpaste> “Sekolah Belajar Forex FBS Indonesia - Peduli Backlink Indonesia ” pasted “Peduli BackLink Indonesia Selamat datang di Peduli BackLink Indonesia” at http://hpaste.org/85279
21:06:09 <mbuf> is there a way to call multiple functions with the same argument, in a sequence?
21:06:09 <lambdabot> mbuf: You have 1 new message. '/msg lambdabot @messages' to read it.
21:06:38 <arkeet> mbuf: map ($ x)
21:07:20 <mbuf> arkeet: for example if I want to call add, sub, mul for an argument x
21:08:34 <arkeet> map ($ x) [add, sub, mul]
21:09:00 <arkeet> hmm
21:09:06 <arkeet> \fs x -> map ($x) fs = sequence.
21:09:15 <arkeet> > sequence [(+1), (*2)] 5
21:09:17 <lambdabot>   [6,10]
21:11:51 <arkeet> TIL that \fs x -> map ($x) fs = sequence.
21:14:13 <mbuf> arkeet: sorry, how do I use it in ghci
21:14:17 <arkeet> use what?
21:15:00 <mbuf> arkeet: \fs x -> map ($x) fs = sequence
21:15:13 <napping> the function is sequence
21:15:26 <arkeet> no
21:15:29 <arkeet> I'm saying two things are the same.
21:15:42 <arkeet> > sequence [(+1), (*2)] 5
21:15:43 <napping> > map ($12) [(*2),(+10),(/3)]
21:15:44 <lambdabot>   [6,10]
21:15:45 <lambdabot>   [24.0,22.0,4.0]
21:15:45 <arkeet> > map ($ 5) [(+1), (*2)]
21:15:47 <lambdabot>   [6,10]
21:16:06 <napping> it's the Monad (r->) instance
21:16:11 <mbuf> arkeet: napping okay
21:16:58 <shachaf> @ty Data.Traversable.sequenceA -- Now it's the Applicative (r ->) instance!
21:17:00 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:18:15 <napping> I guess flip is obsolete
21:18:52 <napping> ah, no traversable?
21:18:57 <arkeet> napping: it's not flip
21:19:01 <arkeet> :t (??) -- this is flip
21:19:02 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:19:37 <shachaf> @ty Data.Distributive.distribute
21:19:39 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
21:21:28 <arkeet> that's flip.
21:21:36 <arkeet> ((r ->) isn't traversable)
21:25:02 <copumpkin> > [(+1), (*2)] ?? 5
21:25:03 <lambdabot>   [6,10]
21:27:43 <napping> what's libCffi?
21:27:56 <prophile> a library for a C foreign function interface
21:27:57 <prophile> at a guess
21:29:48 <tgeeky> @google libCffi
21:29:50 <lambdabot> https://github.com/Kalimehtar/gtk-cffi/blob/master/g-lib/g-lib-cffi.asd
21:30:53 <root____1> Hey, can someone help me with this, http://stackoverflow.com/questions/15824756/ghc-7-4-2-dynamically-calling-modules
21:31:16 <napping> that's not the one my stage 2 ghc can't find :)
21:32:52 <napping> There are problems in package rts-1.0: cannot find any of ["libCffi.a","libCffi.p_a","libCffi-ghc7.7.20130329.so","libCffi-ghc7.7.20130329.dylib","Cffi-ghc7.7.20130329.dll"] on library path
21:59:24 <jfischoff> Enigmagic: seems easy enough to add Binary and (To|From)JSON instances to the Haddock Interface type. Sound like a plan?
22:49:50 * hackagebot hydra-print 0.1.0.0 - NCurses interface to view multiple ByteString streams in parallel.  http://hackage.haskell.org/package/hydra-print-0.1.0.0 (RyanNewton)
23:39:02 <applicative> hmm
23:46:34 <beaky> hello
23:46:47 <beaky> if a function can throw an exception, is it still pure?
23:46:58 <beaky> or is it like using unsafePerformIO?
23:47:03 <beaky> or both?
23:47:31 <elliott> it's pure.
23:47:33 <beaky> ah
23:47:38 <Cale> Um
23:47:46 <elliott> (for some notion of purity, anyway)
23:47:52 <elliott> it's not total, so some people like to avoid them -- they are less predictable/reliable
23:48:06 <beaky> so it's 99% pure except in exceptional cases
23:48:12 <Cale> unsafePerformIO isn't pure, it's a low level hook for screwing around with things that you should take with similar gravity to modifying the compiler.
23:48:13 <elliott> e.g. there are usually strong stylistic/code reasoning arguments to avoid head, tail, fromJust, etc.
23:48:35 <beaky> ah
23:48:46 <shachaf> Cale: I don't think beaky said it is pure.
23:49:18 <Cale> Exceptions on the other hand you can just think of as being like nontermination
23:50:39 <Cale> Every type has an element which represents all the programs of that type which don't terminate, called bottom, or undefined, and exceptions are just lumped in with that.
23:58:19 <Saizan> beaky: if you lump exceptions with non-termination you don't break referential transparency
23:58:35 <beaky> ah
23:58:57 <beaky> I like that view of exceptions
