00:06:56 <Cale> y knw prb svrl reps alrdy n rm rnd ltrs fm wrds mks thm dfclt rd
00:07:50 <ion> nthng wrng wth spkng lk ths.
00:10:00 <Kinnison> I'd argue that while "nthng wrng wth spkng lk ths." can be decoded reasonably unambiguously, it's not easy to read, esp. for non-native english speakers.
00:10:52 <ion> i ws bng srcstc
00:10:59 <Kinnison> o rly?
00:11:13 <Kinnison> :-)
00:12:17 <yacks> guys, sorry if this discussion happening bcoz of hs org instead of haskell.org.
00:12:33 <amosr> qll srprs
00:12:38 <Kinnison> :-)
00:12:39 <yacks> Kinnison, point taken.
00:13:03 <Kinnison> yacks: given that I regularly refer to netsurf-browser.org as ns-b.o, I can't complain that much :-)
00:14:12 <ryantanjunming> hello
00:14:42 <yacks> :)
00:15:07 <ryantanjunming> haskell channel? sry im new to IRC..
00:16:50 <t4nk957> test test, is this the haskell chanell?
00:17:34 <Cale> t4nk957: yes
00:17:44 <Cale> ryantanjunming: yes
00:17:58 <ryantanjunming> thanks
00:18:20 <ryantanjunming> was thinking that there would be alot more traffic
00:18:26 <yacks> And point taken, Cale
00:18:53 <Kinnison> > putStrLn $ map toEnum $ map (`rem` 256) $ map (+90) [255, 11, 25]
00:18:55 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
00:18:55 <lambdabot>    arising from a use of ...
00:19:00 <Kinnison> bleh
00:19:10 <Kinnison> > (map toEnum $ map (`rem` 256) $ map (+90) [255, 11, 25]) :: String
00:19:12 <lambdabot>   "Yes"
00:19:14 <Kinnison> heh
00:19:29 <Kinnison> there's probably a quicker neater way of doing that, but I still haven't had breakfast
00:21:44 <Cale> ryantanjunming: Well, there are 988 people here right now, but it's quiet partly because of the time.
00:22:03 <ion> kinnison: There is one indeed:
00:22:04 <ion> > "Yes"
00:22:06 <lambdabot>   "Yes"
00:23:00 <Kinnison> ion: But that's less convoluted
00:23:04 <Kinnison> ion: ruining the point :-)
00:23:15 * Kinnison may have been doing RSA by hand on paper last night :-)
00:39:30 <amosr> if I just want to output some sound (ALSA or jack?)... should I just use alsa-pcm?
00:40:01 <amosr> all I want is to register a callback to fill a buffer or something I guess
00:42:19 <hamid> what's the different between !String and String. I just heard first one in unboxed. but why is it like that? what's use of it?
00:42:35 <hamid> s/one in/one is/
00:43:22 <amosr> hamid: they're called strictness annotations I believe, they change the semantics and can be much faster
00:43:36 <amosr> although if you're worried about speed I'm not sure you'd want to use String
00:44:00 <mikeplus64> hamid: for !String, it won't be much different at all. the ! only forces it to be head/nil
00:44:56 <mikeplus64> in fact it might be bad - without it a String might be stored as the thunk unpackCString# <whatever>, but with it it's forced to evaluate that thunk
00:45:33 <mikeplus64> hamid: if it were !Text, or !ByteString, then it has the meaning you expect of just forcing the string completely
00:45:39 <Cale> hamid: That ! can only occur at the start of a type of a record field, and it indicates more or less that evaluating an application of that constructor to that field will result in the evaluation (up to determining the topmost constructor) of that field.
00:46:47 <Cale> The report defines the notation by replacing occurrences of the constructor in expressions with lambdas that have strict applications in them.
00:47:08 <Cale> (I would link the report, but haskell.org is down)
00:47:53 <mikeplus64> hamid: (also amosr is right, use Text or ByteString if you want very good string performance)
01:03:08 <hamid> thanks you guys :) I like this community :)
01:05:57 <latermuse> any idea when hackage will be back up?
01:06:12 <Taneb> Hackage is down?
01:06:25 <Kinnison> seems to be up
01:06:58 <vodik> up for me
01:07:02 <latermuse> oops, i mean haskell.org
01:07:04 <latermuse> sorry about that
01:08:20 <Kinnison> Mmm, looks like it's (a) in hetzner and (b) not contactable over either v4 or v6
01:08:56 <amosr> in hetzner?
01:08:59 <Kinnison> I can't see it from hosts in hetzner either, so I'd guess at the HW
01:09:10 <Kinnison> amosr: a hosting/server rental place in germany
01:09:29 <amosr> ah
01:25:35 <finishingmove> is there some convention for defining type signatures (is that the term?)
01:25:44 <finishingmove> for example if i wanted to define my identity function
01:25:53 <finishingmove> myIdentity :: a -> a
01:26:13 <hpaste> marekw2143 pasted ‚Äústate monad definition error‚Äù at http://hpaste.org/85529
01:26:14 <finishingmove> does it matter if i write a -> a or b -> b or t -> t or T -> T ?
01:26:28 <Botje> T -> T is wrong, the rest are fine.
01:27:06 <finishingmove> Botje, k thanks
01:27:18 <Botje> sometimes it makes sense to give your type variables better names
01:27:29 <marekw2143> hello, why does http://hpaste.org/85529 doesn't compile?
01:27:29 <Botje> the only one i can think of right now is State s a
01:27:41 <Botje> which makes it clear that the 's' parameter is the one your state takes
01:28:50 <Botje> marekw2143: did you mean (State run) >>= action = ... on line 9?
01:29:13 <Botje> that makes it compile for me, didn't run it
01:29:33 <marekw2143> Botje: yes, thanks!
01:31:38 * hackagebot clay 0.5 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.5 (SebastiaanVisser)
01:36:02 <quchen> finishingmove: There are some loose naming conventions. Ordinary types are usually called a, b ... Type constructors are often initials of the type, e.g. "f" for Functor, "m" for Monad, "t" for transformers
01:36:38 * hackagebot binary-file 0.15.0 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.0 (YoshikuniJujo)
01:41:13 <finishingmove> quchen, thanks for the insight
01:42:59 <frelux> hi guys! is there any straightforward way to get a monadtrans instance from a newtype'd monad transformer stack? (e.g. say I have a crazy stack like DatabaseMT m a = DatabaseMT { unDatabaseM :: ErrorT String (StateT [Double] (ReaderT [Integer] (ResourceT m))) a })
01:43:52 <frelux> (I get "Can't make a derived instance of `MonadTrans DatabaseMT'
01:43:53 <frelux>       (even with cunning newtype deriving):
01:43:54 <frelux>       cannot eta-reduce the representation type enough" with GeneralizedNewtypeDeriving)
01:43:58 <edwardk> frelux: just write it yourself. instance MonadTrans DatabaseMT where lift = DatabaseMT . lift . lift . lift  . lift
01:44:24 <frelux> ah, fantastic : ) thanks so much edward
01:44:28 <edwardk> np
01:46:19 <quchen> frelux: Alternatively you can use -XGeneralizedNewtypeDeriving, and then just write "newtype Foo = Foo {...} deriving (MonadTrans)"
01:47:05 <frelux> quchen: I tried that first and got "cannot eta-reduce the representation type enough"
01:47:08 <quchen> frelux: Also I'm not sure about the performance of State+Reader, but I usually think using RWS(T) is easier to read
01:47:09 <edwardk> quchen: don't think it works there, because the lift isn't the derived one
01:47:24 <quchen> Oh.
01:47:32 <edwardk> he has no writing component
01:47:51 <quchen> edwardk: Isn't that why () is a monoid?
01:47:53 <edwardk> adding a writer just means introducing a needless space leak for ()'s ;)
01:48:08 <quchen> That leaks?
01:48:23 <quchen> Hmm. Right, it's a non-strict <> of ()
01:48:29 <edwardk> RWS isn't strict in the monoidal arg, so you get a big lazy think build up
01:48:33 <edwardk> er thunk
01:48:41 <quchen> Damn you RWS
01:48:49 <quchen> But thanks for the pointer, never thought of that
01:48:53 <edwardk> np
01:50:29 <edwardk> personally what i tend to do for things like that case is roll my own in cps'd form =)
01:50:57 <quchen> edwardk: Of RS?
01:51:40 <quchen> And why CPS?
01:51:42 <edwardk> newtype DatabaseMT m a = DatabaseMT { runDatabaseMT :: forall r. (a -> [Double] -> ResourceT m r) -> (String -> ResourceT m r) -> [Integer] -> [Double] -> r }
01:51:47 <edwardk> er
01:51:52 <edwardk> newtype DatabaseMT m a = DatabaseMT { runDatabaseMT :: forall r. (a -> [Double] -> ResourceT m r) -> (String -> ResourceT m r) -> [Integer] -> [Double] -> ResourceT m r }
01:52:07 <edwardk> because then i'm not making up a tuple just to wrap it in a monad every step
01:52:32 <frelux> edwardk:¬†are there any docs outlining that transformation off the top of your head?
01:52:42 <frelux> i'll likely have to do it eventually.
01:52:45 <edwardk> it tends to evaluate faster as long as you use each generated monadic value once.
01:53:16 <edwardk> but you'll need to roll all the instances manually
01:53:48 <edwardk> frelux: i learned to do it by writing monad-ran back in the day. that in theory shows each one of the monads that people use transformed into the form of a 'right kan extension' or 'right kan extension transformer'
01:54:10 <edwardk> frelux: also the material out there on codensity and the yoneda lemma are useful
01:54:26 <edwardk> as the version i wrote there is in the form of a right kan extension
01:54:43 <edwardk> and its what you'd get if you ran through the conversion using monad-ran
01:55:51 <frelux> rad, that should give me a good start. hadn't seen monad-ran. you're the best : )
01:56:21 <_mr> ah.. ran as in Ran :-)
01:56:27 <edwardk> i don't recommend actually using the package, but as documentation its quite handy
01:56:31 <edwardk> _mr: yep =)
01:57:54 <Saizan> poor package, not enough love
01:58:00 <edwardk> frelux: also the fmap for that version i pasted has the same body as the one for Cont, but since its not a codensity monad the monad takes some work to write
01:58:59 * edwardk gives saizan commit access to it out of spite ;)
01:59:18 <frelux> gotcha.
01:59:42 <shachaf> I say edwardk should just publish his github password.
02:01:42 <quchen> shachaf: Reminds me a little about German smoking-in-bars policy: since you're not allowed to smoke in bars they register as a private club, and you gain membership by ordering a beer or something.
02:01:46 <Saizan> damn!
02:01:58 <mauke> quchen: oh, is that still legal?
02:02:29 <strebe_> i'm next to a berlin bar that advertises that smoking is allowed...
02:02:35 <quchen> mauke: The situation changes on a monthly basis, therefore: "Maybe, probably."
02:03:43 <mauke> also, wasn't this bavaria only?
02:04:01 <hpaste> ‚Äúhttp://pedulibacklink.blogspot.com/2013/04/konsumen-cerdas-paham-perlindungan.html‚Äù pasted ‚Äúhttp://pedulibacklink.blogspot.com/2013/04/konsumen-cerdas-paham-perlindungan.html‚Äù at http://hpaste.org/85530
02:04:15 <Spockz> I have a question regarding RebindableSyntax and arrows: https://gist.github.com/spockz/e7bb82c2520f8615eecd. I believe that the haskell code generated from the Arrow notation should type check without effort. Am I doing something wrong?
02:05:32 <quchen> mauke: -> -blah
02:06:26 <hamid> @src throwError
02:06:27 <lambdabot> Source not found. stty: unknown mode: doofus
02:06:57 <madjestic> hmm.  haskell.org seems to be down
02:07:11 <hpaste> wereHamster pasted ‚ÄúShow a‚Äù at http://hpaste.org/85531
02:07:11 <hamid> yes
02:08:02 <wereHamster> could someone explain why that hpaste doesn't work? (Could not deduce (a ~ Int))
02:08:40 <wereHamster> is it not possible to have such a list (of Show a instances)?
02:08:44 <shachaf> wereHamster: Because the type of foo is not Show a => [a]
02:08:53 <shachaf> Or, rather, that's not an acceptable type for foo.
02:09:22 <ion> werehamster: The type signature of bar means that the caller of bar is free to dictate the ‚Äúa‚Äù.
02:09:29 <mauke> s/caller/user/
02:09:30 <shachaf> If you give me bar :: Show a => [a] that means "a" can be any type I like, as long as it's an instance of Show.
02:09:44 <alpounet> wereHamster, you can't from 'foo' obtain a list of any type that is Show-able
02:09:49 <wereHamster> shachaf: exactly, what's wrong with that?
02:10:00 <shachaf> wereHamster: For example, it means I can choose a = Char.
02:10:07 <shachaf> But foo :: [Char] is an error.
02:10:08 <nh2> what's up with haskell.org?
02:10:28 <shachaf> nh2: You'd be better off asking what's down with haskell.org.
02:10:36 <shachaf> The answer is "all of it".
02:10:40 <nh2> precisely
02:10:46 <alpounet> imagine: how would you get me a NeuralNetwork from "foo"? NeuralNetwork can have a Show instance.
02:10:50 <nh2> so do we call the power rangers or what?
02:10:51 <alpounet> wereHamster, ^^^
02:11:12 <shachaf> whoa, dude, when did this turn into NeuralNetworks?
02:11:32 <alpounet> err, a list of neuralnetworks*
02:11:40 * hackagebot wai-extra 1.3.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4 (MichaelSnoyman)
02:12:05 <alpounet> shachaf, right?! these numbers grow up so fast
02:12:32 <wereHamster> hm, so it's not possible to make a list of something where the only constraint is that each element is a instance of a certain class?
02:13:11 <shachaf> Your question is a bit vaguely-phrased but the short answer is "no".
02:13:12 <wereHamster> I have to create my own type (data Showable = SInt Int | SChar Char | S??? ..) and use :: [Showable] ?
02:13:29 <shachaf> But look into existential types. But don't look too deeply into them, because they're probably tempting-but-not-what-you-want.
02:13:39 <shachaf> wereHamster: In this case what you actually want is probably a list of Strings.
02:13:53 <alpounet> wereHamster, when haskell.org is up again, read http://www.haskell.org/haskellwiki/Heterogenous_collections
02:14:09 <wereHamster> that was just an example. It's actually more like (HasPosition a) => [a]
02:14:49 <shachaf> See also the FAQ.
02:14:53 <shachaf> @where faq -- sadly, it's also down
02:14:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:15:23 <wereHamster> who would've thought that's a FAQ? :P
02:15:45 <shachaf> At any rate, there's a thing called existential types that sort of lets you do this.
02:15:50 <shachaf> But in practice it's very often a bad idea.
02:15:56 <shachaf> What is the definition of HasPosition?
02:15:59 <ryantanjunming> how does \\ work?
02:16:06 <ion> @src (\\)
02:16:07 <lambdabot> (\\) = foldl (flip delete)
02:16:10 <shachaf> Let's say it's class HasPosition a where position :: a -> Position
02:16:30 <shachaf> Then a list of things whose type is an instance of HasPosition is like a list of Positions.
02:17:10 <wereHamster> shachaf: it can also be relocated/moved (relocate :: POsition -> a -> a)
02:17:29 <wereHamster> anyway, I'll have a look at the website once it's up again
02:17:55 <shachaf> OK, but then what?
02:18:07 <quchen> ryantanjunming: \\ basically takes a list [a,b,c...] and converts it to a long chain of "delete" applications a la "delete a (delete b (delete c (...)))"
02:18:31 <ryantanjunming> quchen: thanks
02:18:47 <shachaf> Let's pretend you had this list. Take an element from it. You don't know its type; all you know is that it's an instance of HasPosition.
02:18:48 <quchen> Eh, a/b/c are reversed in the delete chain.
02:18:52 <shachaf> What can you do with it?
02:18:52 <Spockz> What is powering haskell.org? Maybe I can donate some server power
02:19:07 <wereHamster> shachaf: you can get its position and relocate it :)
02:19:09 <shachaf> Unicorns and bug reports.
02:19:17 <shachaf> wereHamster: Right, but what can you do after you relocate it?
02:19:21 <wereHamster> shachaf: that's what the type tells you, doesn't it?
02:19:28 <ion> Maybe haskell.org could take a free plan from https://www.cloudflare.com/
02:19:33 <shachaf> The only thing you can do with the relocated value is get its position or relocate it again.
02:19:41 <wereHamster> shachaf: you can put it back into another (HasPosition a) => [a] list.
02:19:55 <shachaf> OK, and then what?
02:19:55 <wereHamster> shachaf: aha, you got me there :)
02:19:59 <mauke> wereHamster: so ... it's equivalent to a plain Position?
02:20:36 <shachaf> I,I equivalent to a plane position?
02:22:03 <ion> instance HasSnake Plane
02:22:31 <ryantanjunming> how do i make quickCheck pass through more than the default 100
02:22:44 <shachaf> The documentation specifies how.
02:23:00 <ryantanjunming> main = quickCheck $ prop_test testee
02:23:05 <ryantanjunming> given i have that line
02:23:29 <ryantanjunming> this gives me errors "main = quickCheck stdArgs { maxSuccess = 100 } $ prop_insert_on_empty_tree insertBST"
02:23:47 <shachaf> Yes, you'll need to use a different function instead of quickCheck
02:23:50 <shachaf> One that takes Args
02:25:08 <ryantanjunming> make file?
02:25:51 <ryantanjunming> any doco relating to how i should go about with configuring the quickcheck?
02:26:07 <shachaf> Probably the main QuickCheck haddocks.
02:28:29 <ion> ghc -e ':m + Test.QuickCheck' -e ':browse Test.QuickCheck' | grep Args
02:34:41 <marekw2143> http://hpaste.org/85532 -  what's wrong with line 38?
02:35:12 <Ralith> you tell us
02:35:58 <supki> ew, tabs
02:36:54 <marekw2143> supki: so I should change tabs to spaces?
02:37:16 <shachaf> Yes, and you should add type signatures to everything when you paste code. It's polite.
02:37:23 <shachaf> But that's probably not directly related to your problem.
02:38:19 <supki> marekw2143: your immediate problem is "Sate" on line 33 I think
02:38:52 <supki> that hints you did not copypaste the whole thing
02:41:14 <hpaste> marekw2143 revised ‚Äúcase pattern problem‚Äù: ‚ÄúCase pattern problem‚Äù at http://hpaste.org/85532
02:41:39 <marekw2143> supki: I've defined my own State monad
02:42:30 <supki> marekw2143: yes, but Sate isn't State
02:42:38 <supki> marekw2143: you should paste code you are actually running
02:42:47 <supki> and also error message
02:43:16 <Botje> marekw2143: also, line 26 is missing a do.
02:43:36 <Botje> (or line 25, depending on style)
02:48:36 <hpaste> marekw2143 revised ‚Äúcase pattern problem‚Äù: ‚Äústate nod transfered?‚Äù at http://hpaste.org/85532
02:48:53 <marekw2143> supki: thansk for help - code now compiles, but state doesn't seem to be propagated in depth
02:49:59 <marekw2143> Botje, shachaf ^^
02:53:06 <marekw2143> ok, i know
02:53:12 <marekw2143> should get state after call to g
02:55:07 <ocharles> haskell.org down for anyone else?
02:55:24 <ocharles> oh, I see people have already mentioned that
02:55:36 <ryantanjunming> same
02:55:43 <ryantanjunming> sam
02:55:46 <ocharles> Drat, I needed cabal documentanion on how to use shared directories
03:15:17 <hpaste> mbuf pasted ‚Äúthread blocked indefinitely in an MVar operation‚Äù at http://hpaste.org/85535
03:20:42 <tdammers> design question here
03:21:03 <tdammers> I am mapping SQL result sets onto typed records
03:21:07 <tdammers> using a typeclass
03:21:20 <tdammers> now I want to generate suitable queries based on the desired return type
03:21:25 <merijn> mbuf: eh...you don't give your MVar to any other thread?
03:21:43 <merijn> Of course it's going to block indefinitely
03:22:01 <mbuf> merijn: no
03:22:06 <tdammers> so what I did is create a dummy record, from which I derive the correct table name and columns
03:22:07 <mbuf> merijn: I see
03:22:26 <tdammers> and then I have a weird function that I chain into the return value
03:22:35 <tdammers> to force the dummy row to the function's return tyep
03:22:39 <tdammers> type*
03:22:39 <mbuf> merijn: I just use it to block the runTagKoji function until it completes
03:22:43 <merijn> mbuf: "blocked indefinitely" = trying to read from empty MVar which no other thread has a reference too
03:22:52 <tdammers> it works, but it feels wrong
03:23:02 <merijn> mbuf: Nothing can ever write to that MVar, so how will "takeMVar" ever return?
03:24:06 <merijn> mbuf: How did you think it would wake up when the runTagKoji function finishes?
03:24:16 <hpaste> tdammers pasted ‚ÄúWeird type magic‚Äù at http://hpaste.org/85536
03:24:53 <mbuf> merijn: so something needs to be written to in runTagKoji function?
03:24:55 <tdammers> especially the feedbackType function in that paste
03:25:00 <tdammers> feels wrong
03:25:34 <merijn> mbuf: Yes, you probably want to do this (hold on, lemme annotate)
03:26:31 <hpaste> mbuf revised ‚Äúthread blocked indefinitely in an MVar operation‚Äù: ‚Äúadded runTagKoji function‚Äù at http://hpaste.org/85535
03:30:10 <hpaste> merijn annotated ‚Äúthread blocked indefinitely in an MVar operation‚Äù with ‚Äúthread blocked indefinitely in an MVar operation (annotation)‚Äù at http://hpaste.org/85535#a85538
03:30:55 <merijn> mbuf: There, now what it does is that every thread writes "()" to the MVar when it's done. Then the function just reads one () for every thread you started
03:31:07 <merijn> mbuf: Once you read the last () all threads must be finished
03:31:30 <mbuf> merijn: what does >> do?
03:32:03 <merijn> eh, "takeMVar mvar" instead of "takeMVar str"
03:32:11 <merijn> mbuf: Do you know what >>= does?
03:32:31 <mbuf> merijn: some bind operation
03:32:43 <merijn> :t (>>=)
03:32:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:32:46 <merijn> :t (>>)
03:32:48 <lambdabot> Monad m => m a -> m b -> m b
03:33:01 <merijn> For the IO monad >> is just "first do a, then do b"
03:33:15 <mbuf> merijn: okay
03:33:39 <tdammers> a >> b is the same as a >>= \_ -> b
03:33:43 <merijn> In this case "first do runTagKoji, then writeMVar mvar ()" (actually, maybe that should be putMVar?)
03:33:46 <merijn> :t putMVar
03:33:48 <lambdabot>     Not in scope: `putMVar'
03:33:48 <lambdabot>     Perhaps you meant `putChar' (imported from Prelude)
03:34:14 <merijn> Yeah, should be putMVar instead of writeMVar
03:34:37 <merijn> Anyway, I hope you get the general idea
03:43:09 <mbuf> merijn: works; thanks!
03:45:13 <fizbin> Is there a www.haskell.org mirror? Specifically of haskellwiki?
03:46:44 <ryantanjunming> where do i paste stuff?
03:46:49 <ryantanjunming> paste code
03:47:12 <ryantanjunming> where do i paste code?
03:47:18 <mbuf> ryantanjunming: hpaste.org
03:47:35 <ryantanjunming> thanks, wonder how to activate the lambdabot
03:47:59 <mbuf> ryantanjunming: prepend with @ or >
03:48:11 <fizbin> @paste
03:48:12 <lambdabot> Haskell pastebin: http://hpaste.org/
03:48:18 <ryantanjunming> @paste
03:48:19 <lambdabot> Haskell pastebin: http://hpaste.org/
03:48:26 <ryantanjunming> thanks lambdabot
03:50:50 <hpaste> ryantanjunming pasted ‚ÄúBinaryTree Algos and quickChecks‚Äù at http://hpaste.org/85539
03:51:34 <ryantanjunming> i'm getting a "19:35: parse error on input `='"
03:51:42 <ryantanjunming> keep getting them somehow..
03:52:23 <supki> ew, tabs
03:52:48 <merijn> ryantanjunming: Indented wrong
03:53:00 <supki> ryantanjunming: you shouldn't mix spaces and tabs
03:53:10 <merijn> ryantanjunming: All the lines of "allTree" should be indented equally far
03:53:37 <merijn> (also, the haskell standard defines tabs to indent "until the next 8 space tabstop", iow, don't use tabs!)
03:53:58 <Kinnison> tabs suck, just don't use them ever
03:54:12 <Kinnison> (except for Makefiles :-( where they're mandatory)
03:54:16 <merijn> Kinnison: word
03:54:54 <merijn> ryantanjunming: Which editor are you using? You should probably configure it to use softtabs
03:55:03 <tdammers> tabs are fine, just not for languages with syntax-relevant whitespace
03:55:14 <Kinnison> tdammers: I think tabs suck in C too
03:55:20 <ryantanjunming> @merijn softtabs
03:55:20 <lambdabot> Unknown command, try @list
03:55:30 <ryantanjunming> how do i list u again?
03:55:33 <ryantanjunming> @list
03:55:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:55:46 <ryantanjunming> eh
03:55:52 <tdammers> Kinnison: not if you use them right and let go of the desire to control exactly what your code looks like in someone else's editor
03:55:57 <ryantanjunming> merijn, im using chocolat
03:56:16 <merijn> Ah, never heard of that
03:56:21 <tdammers> but in C, the problem isn't very interesting. You can safely reindent as you like, completely automatically too.
03:56:22 <Kinnison> tdammers: Typically I find that everyone's code looks shit in my editor if they use tabs, because I configure my editor for 3 space tabs
03:56:35 <tdammers> then everyone else sucks at using tabs correctly.
03:56:57 <alexander__b> > data Shape = Circle Float Float Float | Rectangle Float Float Float Float
03:56:59 <lambdabot>   <hint>:1:1: parse error on input `data'
03:57:02 <alexander__b> halp?
03:57:10 <Kinnison> tdammers: Everyone *full stop* sucks at using tabs because tabs suck :-)
03:57:22 <merijn> Everyone's code using tabs looks like shit since tabs look like bright red ""
03:57:24 <merijn> eh
03:57:39 <merijn> Bright red ¬ª¬ª¬ª¬ª¬ª¬ª¬ª¬ª
03:57:42 <tdammers> tabs for indentation, spaces for alignment. I don't see the problem except for people who cannot tell the difference.
03:58:03 <Kinnison> tdammers: :-)
03:58:12 <Kinnison> anyway, time for lunch
03:58:30 <tdammers> if you use tabs for indentation, you can have 3-space indents, I can have 4-space indents, and some bearded unix hippie can have 12-space tabs or sth
03:59:06 <alexander__b> to be more specific, the learnyouahaskell chapter I just turned to is about making types, and it does data foo = bar, but I get parse error on 'data'.
03:59:11 <Kinnison> tdammers: it's very rare that people who use tabs for indentation don't then end up with tabs in their "alignment" space.  if you manage it, then I'm impressed and your code probably wouldn't suck in my editor
03:59:26 <Kinnison> alexander__b: Did you accidentally indent the whole line?
03:59:35 <tdammers> I tend not to align a lot, really
03:59:39 <alexander__b> Kinnison: wat? I didn't indent anything
03:59:39 <merijn> tdammers: Beareded unix hippies know 8 space is the one true tab width
03:59:58 <merijn> alexander__b: Is that exactly how you typed it?
04:00:00 <tdammers> if at all possible, I structure my code so that indentation alone conveys the structure
04:00:03 <alexander__b> merijn: yes
04:00:11 <merijn> foo is lowercase...
04:00:12 <tdammers> merijn: I was exaggerating. Poetic license.
04:00:14 <Kinnison> alexander__b: can you hpaste the whole ifle?
04:00:16 <tdammers> anyway, lunch.
04:00:19 <alexander__b> merijn: oh
04:00:21 <Kinnison> but yes, lunch
04:00:22 <merijn> Also, bar is too
04:00:29 <alexander__b> merijn: no I did the example
04:00:33 <marekw2143> does in "business" applications written in haskell, constructions like: iterate (scanl (+) 1 . tail) (repeat 1) !! 20 !! 20    are used widely?
04:00:45 <alexander__b> see my first paste
04:00:49 <alexander__b> > data Shape = Circle Float Float Float | Rectangle Float Float Float Float
04:00:50 <merijn> alexander__b: Oh, wait in lambdabot?
04:00:51 <lambdabot>   <hint>:1:1: parse error on input `data'
04:01:00 <merijn> Lambdabot doesn't support data
04:01:13 <merijn> Neither does ghci, afaik
04:01:16 <alexander__b> merijn: ghci doesn't seem to use it either, because I get the same error there.
04:01:18 <alexander__b> yeh.
04:01:29 <alexander__b> maybe the book should mention that the code I'm looking at suddenly won't work in the interpreter.
04:01:38 <merijn> alexander__b: The best way is to write your code in "somefile.hs" and then use ":l somefile.hs" in ghci
04:01:45 <supki> ghci supports data declarations
04:01:47 <merijn> or "ghci somefile.hs"
04:01:55 <merijn> supki: Only *really* recent versions
04:01:56 <getost> Hello. We are porting a communication stack( OPC UA) to an embedded system. OPC UA uses raw sockets and the Berkely socket library is ported to our system, however raw sockets are not implemented, just TCP and UDP. If someone has built a system on top of raw sockets then there is no way we could use TCP and still achieve the same thing?
04:02:05 <supki> probably not in ancient ghc versions though
04:02:06 <alexander__b> merijn: I use :r most of the time, but just to try out one or two lines I tend to input them directly.
04:02:23 <alexander__b> supki: I have ghc 7.4.2
04:02:31 <merijn> alexander__b: Yeah, that doesn't work in older ghci versions (I'm not 100% sure it works in newer versions)
04:02:32 <typoclass> marekw2143: what does that code do?
04:02:48 <merijn> alexander__b: When I said really recent I meant 7.6 or HEAD :)
04:02:49 <marekw2143> typoclass: solves some algorithmic problem
04:03:23 <marekw2143> typoclass: calculating lattice paths ( code from http://stackoverflow.com/questions/3379805/memoization-project-euler-problem-15-in-haskell)
04:03:24 <supki> alexander__b: yeah, 7.4.2 is from stone age :)
04:04:12 <alexander__b> ok thanks
04:04:14 <merijn> alexander__b: Anyway, the simplest solution is to only write data declarations in the file and :r, if you have some fancy-shmancy setup you could probably even automate that in emacs/screen/tmux
04:04:39 <alexander__b> my fancy schmancy setup is limited to tiling vim and ghci beside each other. ;-)
04:04:44 <merijn> (Personally I just have tmux split screen my terminal and have vim in one half, ghci in the other)
04:07:46 <typoclass> marekw2143: ok. which parts are confusing you?
04:07:57 <typoclass> > scanl (+) 7 [1,2,3] -- marekw2143, here is an example of what scanl does
04:07:59 <lambdabot>   [7,8,10,13]
04:08:15 <marekw2143> I know what scanl does, what !! does, what iteratee does
04:08:31 <marekw2143> but don't see a corespondence of the equation to the roblem
04:08:58 <alexander__b> is there a way to do "data minint = -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5" less... verbose?
04:10:18 <askalski> hi
04:10:25 <askalski> how to import a file to ghci?
04:11:00 <kgadek> hi. Is it just me or haskell.org is down? Is it scheduled maintance or something?
04:11:12 <kgadek> askalski: :load filename.hs
04:11:14 <askalski> kgadek, I can't use it as well
04:11:22 <askalski> kgadek, the website
04:11:36 <Cale> alexander__b: I'm not sure what you mean, but that declaration you wrote isn't valid.
04:11:45 <alexander__b> Cale: oh
04:12:13 <alexander__b> right big M
04:12:22 <Cale> alexander__b: You might have been confused by some pseudocode for expressing how you might think about Integer
04:12:40 <alexander__b> oh ok so it's not really like that
04:12:53 <Cale> But data constructors also have to start with uppercase letters, just as type constructors do.
04:13:47 <Cale> also, every data constructor belongs to exactly one data declaration -- you can't define a type whose members already belong to another type
04:14:47 <Cale> (You can define a type with similar structure, and you can use the module system to name things the same way if you want, but they'll still be different, new things introduced by the data declaration)
04:19:01 <ryantanjunming> i've done the following: main = quickCheck $ prop_searchTrees
04:19:12 <ryantanjunming> with main :: IO ()
04:19:21 <ryantanjunming> how do i run quickCheck in main?
04:19:30 <ryantanjunming> so that it outputs 100 passed test
04:19:46 <ryantanjunming> or does it already run when i load?
04:19:57 <quchen> ryantanjunming: Just call "main" in GHCi. It's a normal function.
04:20:20 <quchen> The only thing special about "main" is that when you compile your program, the runtime calls it automatically.
04:20:32 <getost> can a raw socket and a tcp socket communicate at all?
04:21:42 <ryantanjunming> THANKS YOU
04:29:33 <Philonous> getost:  You'd have to implement TCP by hand on the raw socket
04:31:24 <ocharles> Is there a GHC Generics implementation of QuickCheck's arbitrary?
04:40:33 <Taneb> Okay, my emacs ghc-mod isn't working
04:41:30 <kgadek> is there a mirror of haskell.org ? I'd like to read a bit and now since it's down‚Ä¶
04:42:42 <typoclass> marekw2143: i'm not sure what yitz is doing there, but i guess he is thinking something like this: you have some rectangle (let's say 3x4), and you know how many paths are through it (let's say it's 42 paths), and you want to know about 3x5 rectangles. you can then just add 3 + 42 because there's 3 more paths you could take
04:44:39 <mauke> kgadek: http://web.archive.org/web/20130226003600/http://www.haskell.org/haskellwiki/Haskell
04:44:42 <marekw2143> typoclass: anyway, is code like that used widely in business apps :) ?
04:46:06 <shanse> depends on your business
04:49:35 <kgadek> mauke: thank you :)
04:51:42 <typoclass> marekw2143: i don't know. but the code doesn't seem to be especially sneaky to me. it's using (.), it's using infinite lists. he could have given more documentation, maybe drawn a picture. but it seems kind of reasonable
04:52:35 <marekw2143> well, I think that I just nead to learn and train a lot to begin understanding such code
04:54:48 <typoclass> marekw2143: i think the key issue is that the author took some time to think about the problem, and it could be hard to follow that thinking
04:54:53 <Taneb> Okay, installing with cabal rather than apt works
05:03:10 <snoyberg> what's the state of the art re: UTCTime -> EpochTime conversions?
05:04:28 <ivanm> one of the best things about using Cabal to package Haskell packages: explicit listing of required dependencies
05:04:37 * ivanm glares at a2ps that doesn't specify any deps that it needs
05:06:04 <typoclass> snoyberg: http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html recommends "fmap utcTimeToPOSIXSeconds getCurrentTime"
05:08:36 <snoyberg> typoclass: thanks for the pointer, i'll have a look
05:09:24 <typoclass> snoyberg: it's quite a nice page. i wonder why the haddocks for the time package don't include all of that :-)
05:09:52 <typoclass> ... relatedly, i should start working on some patches and suggest them to someone
05:44:10 <killy9999> haskell.org down again?
05:45:03 <typoclass> killy9999: yes, seems so
05:50:47 <no-n[5]> Hoogle is down :(
05:51:22 <no-n[5]> all of haskell.org *
05:53:24 <killy9999> at least GHC repo is mirrored by github
05:57:21 <fizbin> Time to read haskellwiki through the wayback machine, I guess...
05:58:18 <Philonous> no-n[5]:  You can use hayoo
05:58:43 <no-n[5]> I used wayback machine
06:00:17 <printer> hello, could someone tell me please why is haskell.org down, or when it's gonna be up again?
06:03:46 <ocharles> a fairly trivial question, but how do people here pronounce Haskell?
06:04:15 <ocharles> some people at work keep saying "hask al" (al like ALan), but I stay "hass kull" personally
06:05:37 <bitonic> ocharles: h√¶sk…ôl, clearly
06:05:49 <fegu> i concur
06:06:18 <bitonic> I also pronounce it ‚ÄòJavaScript‚Äô
06:06:30 <ion> i c√¶nc…ôr
06:07:52 <ocharles> bitonic: I shake my fist at you, sir
06:08:08 <ocharles> or madam
06:08:40 <Spockz> Could someone help me with https://gist.github.com/spockz/e7bb82c2520f8615eecd ? I think it is a bug but I'm not sure. I suspect that the compiler type checks against some hard-coded type instead of the types of the functions actually in scope
06:09:47 <bitonic> ion: you mean k…ônÀàk…úr
06:11:32 <ion> bitonic: no
06:14:20 <Chelsea> Hi all, Is there a way to have Pandoc's code-block export nicely to doc/docx ? (can't seem to find #pandoc, it was suggested i tried here)
06:14:41 <bitonic> Spockz: ‚ÄòArrow notation (see Section 7.13, ‚ÄúArrow notation ‚Äù) uses whatever arr, (>>>), first, app, (|||) and loop functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!‚Äô
06:14:52 <bitonic> Spockz: from the manual for GHC 7.4.2
06:15:01 <bitonic> can‚Äôt get the latest manual since haskell.org is down
06:15:42 <Spockz> bitonic: yes I know, so that's why I'm asking :)
06:15:56 <Spockz> bitonic: in my opinion I should be able to add constraints
06:16:02 <bitonic> Spockz: well at least they know it.
06:16:14 <bitonic> (haven‚Äôt looked closely at your code)
06:16:15 <HugoDaniel> hi
06:16:28 <bitonic> Spockz: I suppose that expanding the arrow syntax manually makes things work?
06:16:33 <Spockz> bitonic: yes
06:16:58 <geekosaur> lines 29+30 of error.txt make it clear that the compiler is forcing additional type constraints
06:17:24 <bitonic> geekosaur: you mean forcing a type with no constraints :P
06:18:34 <bitonic> Spockz: in any case, I wouldn‚Äôt call it a ‚Äòbug‚Äô.  but complain if you think you should be able to
06:18:49 <Spockz> bitonic: yes I'm typing that in a mail to ghc-devs now
06:20:30 <bitonic> mail which will be bounced until haskell.org comes up again :(
06:20:55 <bitonic> unless they keep the lists somewhere else
06:23:32 <fizbin> How bad should I feel about LANGUAGE NoMonomorphismRestriction
06:24:08 <bitonic> fizbin: not bad at all
06:24:24 <bitonic> some would say you should feel worse about not having it...
06:24:26 <fizbin> I feel bad enabling it when I don't understand what it means or wtf the compiler is complaining about without it.
06:25:16 <fizbin> I seem to remember running across a haskellwiki page that talked about this, but that isn't too useful at the moment.
06:25:23 <bitonic> fizbin: ah.  basically the monomorphism makes it so that local variables (‚Äòwhere‚Äô and ‚Äòlet‚Äô) get a monomorphic type instead that a polymorphic one.  this is for reasons of efficiency, and somewhat unelegant
06:25:42 <bitonic> (efficiency of the generated code, not of the compiler)
06:26:26 <fizbin> Um‚Ä¶ okay, but why does adding an explicit type to the top-level variable (which type expands to something polymorphic) make the error vanish?
06:26:49 <Spockz> bitonic: do you know how I can dump the code generated after desugaring the Arrow notation?
06:27:50 <supki> fizbin: because you explicitly say "I'm okay with that polymorphic type"
06:28:20 <fizbin> Hrm.
06:28:32 <bitonic> Spockz: --ddump-something... wait
06:30:03 <bitonic> Spockz: -ddump-ds
06:30:51 <fizbin> It appears that if I have a top-level function foo :: String -> B where "B" is some polymorphic type, then later anytime I have a top-level declaration like (baz = foo "baz") then I need an explicit type declaration on baz as well to avoid the monomorphism error. The explicit type on foo isn't sufficient.
06:31:15 <fizbin> Does this correspond with other's experience of the monomorphism restriction?
06:31:24 <Iceland_jack> Hey, is there an idiomatic way of summing up values from a [Maybe Int]? Possibly [Maybe Int] ‚Üí Maybe Int
06:31:39 <dmwit> fizbin: When you write a value that has a constraint, like foo :: Foo a => ..., you should read this as being a *function* from the methods of the Foo typeclass to whatever ... is.
06:31:59 <Botje> Iceland_jack: sum . catMaybes ?
06:32:02 <dmwit> fizbin: This means in particular that each invocation of foo must recompute the ..., because it is a function and Haskell doesn't implicitly cache functions.
06:32:20 <dmwit> fizbin: This can be a surprise to people who wrote something in the ... that doesn't look like a function and therefore are expecting something to be cached.
06:32:53 <Iceland_jack> I feel like there is a more idiomatic solution, I'm fine with returning Nothing upon finding a single Nothing
06:33:06 <dmwit> fizbin: The monomorphism restriction prevents this problem by forcing types of this form on top-level definitions to be monomorphic; essentially specializing the first argument to the "function" and "caching" the one output.
06:33:23 <fizbin> hrm. This is especially confusing when the "TypeClass a =>" bit is hidden behind type declarations pulled in from another library.
06:33:24 <typoclass> Botje: good idea. though i think jack is looking for result Nothing on the input []
06:33:25 <Spockz> bitonic: does that only work when the code typecehcks? Because I see nothing
06:33:31 <dmwit> fizbin: The canonical example is primes :: Num a => [a]; this will be recomputed each time its used whereas primes' :: [Integer] won't.
06:33:37 <bitonic> Spockz: I‚Äôd expect it to work even if it doesn‚Äôt type check
06:33:43 <dmwit> s/its/it's/
06:33:55 <typoclass> Iceland_jack: how about using sequence or some such to turn [Maybe Int] into Maybe [Int], then using fmap sum
06:33:57 <bitonic> Spockz: but reality beats my expectations :(
06:34:17 <typoclass> Iceland_jack: wait, you wanted result Nothing if any list element is Nothing
06:34:21 <dmwit> fizbin: So, the monomorphism restriction makes you choose: monomorph your code so that it won't be recomputed, or explicitly make it polymorphic and acknowledge that you know it may be recomputed a lot.
06:34:30 <bitonic> Iceland_jack: sum <$> sequence xs
06:34:39 <dmwit> fizbin: Now you should know enough to feel comfortable turning the restriction off if that's appropriate. =)
06:34:56 <Iceland_jack> sum <$> sequence xs is fine
06:34:58 <fizbin> dmwit: The part that catches me is that (Lens' a b) is polymorphic.
06:35:11 <fizbin> It'd be one thing if I'd written a => in there myself.
06:35:21 <Iceland_jack> thanks bitonic
06:35:44 <bitonic> typoclass beat me ehe
06:35:47 <typoclass> Iceland_jack: where is my thanks? :-)
06:36:02 <dmwit> fizbin: uh
06:36:12 <dmwit> fizbin: ah, yes
06:36:25 <typoclass> bitonic: more like, typoclass is a chatty talky verbose kind of guy, while bitonic just writes down the code :-)
06:36:53 <Iceland_jack> Thank you typoclass!
06:37:04 * typoclass purrs and looks friendly
06:37:07 <parcs> 'sum <$> sequence xs' can cause a stack overflow
06:37:29 <fizbin> dmwit: So I have a function fooLens :: Foo -> Lens' Bar Bool and then whenever I do something like (baz = fooLens foo1) I need to then declare (baz :: Lens' Bar Bool)
06:37:41 <fizbin> Which is a bit surprising.
06:37:49 <Spockz> is there a tool to go from Core to Haskell?
06:38:01 <fizbin> So I'll turn it off in my code.
06:39:51 <bitonic> Spockz: the Core dumped for should be fairly readable, you can post it here if you‚Äôre having trouble
06:39:55 <dlind> 3
06:40:07 <dlind> woah, misclick
06:40:24 <dlind> .. mispress
06:40:58 <Spockz> bitonic: https://gist.github.com/spockz/beb49a9c87ae61af3934 < I want to get that to compile again, I should probably remove type applications but I'm not sure what is exactly needed
06:41:57 <JordiGH> Does Haskell have a FFI? How can I call arbitrary external object code from Haskell?
06:42:05 <bitonic> Spockz: it looks like it‚Äôs using a >>> for starters
06:42:14 <ab9rf> @faq can haskell use foreign functions?
06:42:14 <lambdabot> The answer is: Yes! Haskell can do that.
06:42:22 <bitonic> JordiGH: yes Haskell 2010 specifies a FFI and GHC lets you call C
06:42:45 <geekosaur> JordiGH, it has an FFI, yes, but if you want arbitrary stiuff at runtime that's harder because what type does it have? but see hint and plugins packages on hackage
06:42:50 <bitonic> Spockz: *it looks like it‚Äôs using some internal >>>
06:43:13 <Spockz> bitonic: this is *without* rebind able syntax
06:43:35 <JordiGH> bitonic: Ah, it's a newish feature, I see.
06:43:36 <bitonic> Spockz: oh, OK.  if it doesn‚Äôt typecheck with, I‚Äôm not sure you can read the output of the desugarer...
06:43:37 <Spockz> bitonic: and yes that I found, $fArrowR is the dictionary of R for the Arrow instance I presume
06:43:42 <bitonic> JordiGH: it‚Äôs been in GHC for ages
06:44:00 <Spockz> bitonic: without rebind able syntax it compiles
06:44:22 <ab9rf> do you need rebindable syntax?
06:44:39 <bitonic> ab9rf: the whole point is that he wants Typable constraints on arrow operators
06:44:47 <Spockz> ab9rf: I have a DSL that gives deep-embedding for Category and Arrow but I want to add Typeable constraints
06:44:54 <ab9rf> ah
06:44:58 <bitonic> Spockz: yeah as I said in that case I don‚Äôt know if you can get the desugarer output
06:45:02 <Spockz> ab9rf: so I think the answer is yes
06:45:22 <Spockz> bitonic: I could of course remove the constraints and check it output then!
06:45:25 <ab9rf> Spockz: i thnk you're likely right.  so why oes it compile withoit it? :)
06:45:30 <bitonic> Spockz: you could.
06:45:48 <Spockz> ab9rf: because I gave the Arrow/Category instances
06:45:58 <ab9rf> Spockz: ah
06:46:06 <ab9rf> bad haskell.org
06:46:12 <ab9rf> come back to the real world
06:50:55 <fizbin> Infix operators with no fixity declaration are what by default?
06:51:15 <geekosaur> 5
06:51:46 <fizbin> infixl 5 or infxr 5 or infix 5?
06:52:17 <mm_freak> > let (##) = (+) in x ## y ## z
06:52:19 <lambdabot>   x + y + z
06:52:24 <mm_freak> infixl
06:52:35 <Spockz> bitonic: this is the code without the constraints but *with* rebindablesyntax https://gist.github.com/spockz/beb49a9c87ae61af3934
06:52:38 <mm_freak> wait
06:52:44 <mm_freak> > let (##) = (-) in x ## y ## z
06:52:46 <lambdabot>   x - y - z
06:52:59 <fizbin> > let (##) = ($) in x ## y ## z
06:53:01 <lambdabot>   Couldn't match expected type `a1 -> a0 -> b0'
06:53:01 <lambdabot>              with actual type...
06:53:10 <mm_freak> > let (##) = ($) in f ## g ## x
06:53:12 <lambdabot>   Ambiguous type variable `a0' in the constraints:
06:53:12 <lambdabot>    (GHC.Show.Show a0)
06:53:12 <lambdabot>     ...
06:53:22 <mm_freak> > let (##) = ($) in f ## g ## x :: Expr
06:53:23 <lambdabot>   Ambiguous type variable `a0' in the constraints:
06:53:24 <lambdabot>    (GHC.Show.Show a0)
06:53:24 <lambdabot>     ...
06:54:06 <fizbin> > let (##) a b = "(" ++ (show a) ++ " " ++ (show b) ++ ")" in 1 ## 2 ## 3
06:54:09 <lambdabot>   "(\"(1 2)\" 3)"
06:54:22 <fizbin> Okay, infix
06:54:27 <fizbin> infixl, rather
06:54:33 <merijn> fizbin: I think they're infixl 9 by default
06:55:12 <mm_freak> > let (##) = (+) in x ## y * z :: Expr
06:55:14 <lambdabot>   (x + y) * z
06:55:28 <merijn> It's simple, give a fixity declaration to a function and call :i on it in ghci, it won't report fixity for the default
06:56:03 <mm_freak> yeah, and that really sucks
06:56:50 <merijn> ok, just checked it is indeed infixl 9
07:00:28 <ion> > let foo = (+) in x `foo` y * z :: Expr
07:00:30 <lambdabot>   (x + y) * z
07:06:55 * hackagebot toysolver 0.0.4 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.0.4 (MasahiroSakai)
07:11:43 <totimkopf> I'm a little confused about Chapter 5 page 66 of LYAH: "In this new version of flip', we take advantage of the fact that functions are curried. When we call flip' without the paramters y and x, it will return an f that takes those two paramters but calls them flipped." BUT here lies my confusion: flip' zip [1,2,3,4,5] "hello"  -- isn't f = zip; x = [1,2,3,4,5]; y = "hello" ?
07:13:25 <Taneb> Yes
07:13:28 <armlesshobo> @type flip
07:13:30 <lambdabot> (a -> b -> c) -> b -> a -> c
07:13:50 <totimkopf> Ok, then next question, how are we taking advantage of currying here?
07:14:16 <ab9rf> totimkopf: flip' and flip are the same function, just expressed differently
07:14:23 <armlesshobo> totimkopf: how is flip' defined?
07:14:46 <Taneb> It's f that's currried, not flip
07:14:48 <armlesshobo> @src flip'
07:14:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:14:52 <totimkopf> flip' :: (a -> b -> c) -> b -> a -> c
07:14:55 <totimkopf> flip' f y x = f x y
07:15:11 <ab9rf> @src flip
07:15:11 <lambdabot> flip f x y = f y x
07:15:24 <merijn> totimkopf: You're taking advantage of the fact that it gets parsed as "(((flip' zip) [1,2,3,4,5]) "hello")"
07:15:53 <ab9rf> totimkopf: in some sense, all functions in haskell take one argument
07:16:06 <merijn> totimkopf: Instead of having to do, say "flip(zip)([1,2,3,4,5], "hello")" like you would in python
07:16:51 <merijn> Make sense?
07:17:06 <totimkopf> yes.
07:17:12 <totimkopf> thanks merijn
07:17:53 <merijn> I guess the confusing thing is that it sounds like there's some deep insight, while it's actually mostly obvious :)
07:17:56 <typoclass> totimkopf: if you want, you could do ¬´let f = flip' zip in f [1..5] "hello"¬ª. that's always possible in haskell. although on the page http://learnyouahaskell.com/higher-order-functions i don't see an example like that. i don't know what "here" he's referring to when he says "here we take advantage" :-)
07:18:19 <ab9rf> typoclass: yeah, that's not well-expressed
07:19:03 <totimkopf> oh, so I'm not the only one who got confused about this bit? :D
07:19:10 * totimkopf feels less like a totimkopf today
07:20:29 <totimkopf> I'm going to move on then!
07:20:58 <supki> > let (@@) = undefined in (@@ 0 $ id)
07:20:59 <lambdabot>   The operator `@@' [infixl 9] of a section
07:21:00 <lambdabot>      must have lower precedence t...
07:22:32 <elliott> > let (@@) = undefined in (0$0@@) -- shorter
07:22:34 <lambdabot>   The operator `@@' [infixl 9] of a section
07:22:34 <lambdabot>      must have lower precedence t...
07:24:40 <bitonic> Spockz: sorry I was out, did you find out what you wanted to in the end?
07:26:06 <totimkopf> oh, before I move on, the type singature with parantheses (a -> b -> c) -> b -> a -> c does not imply that haskell stops currying, right? It is just to emphasize that it takes a function as a parameter, right?
07:26:43 <totimkopf> in LYAH it says that this is mandatory, it kind of makes me think that haskell stops doing what it always does for some reason
07:26:56 <tdammers> haskell doesn't really "do" anything
07:27:02 <tdammers> in this context at least
07:27:07 <geekosaur> all it does is indicate a function type, yes
07:27:23 <totimkopf> ok, thanks :)
07:27:29 <fizbin> Is there something in base that means "iterate with this f :: (a -> Maybe a), repeatedly applying it to the inside until it returns Nothing, returning the inside of the last Just?"
07:27:31 <tdammers> it's more a matter of grouping: -> associates to the right
07:27:44 <tdammers> so a -> b -> c is (a -> (b -> c))
07:27:57 <fizbin> tdammers: yes
07:28:01 <tdammers> the parentheses are mandatory if you want a different kind of grouping
07:28:06 <tdammers> ((a -> b) -> c)
07:28:08 <typoclass> totimkopf: yes, that has nothing to do with currying. that function has 3 arguments. the first of them is a function a -> b -> c
07:28:25 <tdammers> in fact, a function only ever has one argument
07:28:33 <fizbin> :t let f = undefined :: (a -> (b -> c)) in f
07:28:35 <lambdabot> a -> b -> c
07:28:50 <tdammers> a -> b -> c is a function that takes one argument and returns a function that takes one argument and returns a c
07:28:50 <fizbin> :t let f = undefined :: ((a -> b) -> c) in f
07:28:52 <lambdabot> (a -> b) -> c
07:29:57 <totimkopf> gotcha.
07:30:59 <Kinnison> totimkopf: Also, I think you're saying currying where perhaps you mean partial application
07:31:19 <totimkopf> Kinnison: yes, I caught myself mixing those two up earlier.
07:31:27 <Kinnison> :t curry
07:31:29 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:31:41 <totimkopf> ooo, there is a curry function?
07:31:44 <Kinnison> see what currying "really" is
07:31:48 <Kinnison> curry and uncurry exist
07:31:55 <ryantanjunming> @paste
07:31:55 <totimkopf> :t uncurry
07:31:55 <lambdabot> Haskell pastebin: http://hpaste.org/
07:31:56 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:32:22 <hpaste> ryantanjunming pasted ‚Äúline 112‚Äù at http://hpaste.org/85550
07:32:57 <ryantanjunming> line 112, my quickcheck needs to check insert functions to see if insert[1,2,3,4] must produce errors
07:33:44 <ryantanjunming> im not too familar with my syntax for quickcheck properties
07:33:44 <totimkopf> it looks like uncurry takes a function as its first parameter and a tuple as its second paramter?
07:34:12 <typoclass> totimkopf: yup, that's exactly right
07:34:16 <typoclass> @type uncurry
07:34:18 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:37:06 <typoclass> totimkopf: there's some more to it -- both the 'a's need to refer to the same type, so the function that you pass into uncurry needs to accept the same type as its first argument as the tuple has as its left member. similar for b. and the two 'c's indicate that uncurry's final result will be the same type as the function's result
07:37:27 <typoclass> totimkopf: but you probably already know that :-) just to spell it out again
07:39:43 <tom__> any nixos users out there: trying it out, what is current best practice to avoid 'hell'? any chance of getting a sample configuration.nix?
07:39:44 <totimkopf> what is uncurry useful for?
07:39:50 <tom__> :t uncurry
07:39:52 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:40:21 <totimkopf> why would anyone want to undo what haskell does by default?
07:40:22 <tom__> totimkopf: if you have a binary function, it applies it to a tuple
07:40:32 <totimkopf> ah
07:40:38 <elliott> > map (uncurry (+)) [(1,2),(3,4)]
07:40:40 <lambdabot>   [3,7]
07:40:41 <mjga> totimkopf: uncurry (+) . zip a b
07:40:43 <geekosaur> zipping a list of parameters against asecond list f parameters and then running a function on the result
07:40:46 <tom__> uncurry (+) (1,2)
07:40:48 <geekosaur> pairwise
07:40:53 <elliott> mjga: you mean map (uncurry (+)) $ zip a b
07:40:54 <typoclass> totimkopf: it's just a tiny shortcut for when you have a tuple and you want to give it to a 2-argument function
07:40:58 <elliott> though that can be written simpler as zipWith (+) a b
07:41:02 <mjga> elliott: indeed
07:41:15 <elliott> oh, I suppose (uncurry (+) . zip a b) works with the old lambdabot (.) :)
07:41:20 <elliott> how confusing...
07:41:48 <tom__> i have also found a few instances when it has been helpful to unpack a tuple instead of pattern matching
07:42:35 <tom__> no nix users?
07:43:32 <typoclass> > (\(a,b) -> a + b) (42,37) -- totimkopf, here you might save a tiny bit of typing by saying "uncurry (+) (42,37)"
07:43:34 <lambdabot>   79
07:44:59 <Kinnison> totimkopf: remember, haskell does not "curry" or "uncurry" automatically -- it does have partial application as part of the language though
07:45:49 <Kinnison> the {un,}curry functions are a lovely example of why/how all functions take one argument in haskell IMO
07:47:10 <elliott> the beauty of that is that it doesn't even have to have partial application as part of the language, since it's just application :)
07:47:20 <Kinnison> indeed :-)
07:47:55 <Kinnison> elliott: Although in that context, I'd think of the way you define functions which "take multiple arguments" as where partial application turns up as language sugar
07:48:04 <ryantanjunming> hi, with anyone familiar with BSTs.. Could ya help me out and explain to me what i should check for insertions? Like in-ordered, balanced
07:48:07 <ryantanjunming> etc
07:48:11 <elliott> Kinnison: yeah, that makes sense
07:48:11 <ryantanjunming> would greatly help
07:49:45 <fizbin> @hoogle (a,b) -> (b,a)
07:49:45 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
07:49:46 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:49:46 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
07:50:38 <fizbin> @hoogle [a] -> [(a,a)]
07:50:38 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:50:39 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:50:39 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
07:51:08 <fizbin> @pl \x -> zip x (tail x)
07:51:08 <lambdabot> ap zip tail
07:51:56 * hackagebot http-client-auth 0.1.0.0 - HTTP authorization (both basic and digest) done right  http://hackage.haskell.org/package/http-client-auth-0.1.0.0 (MiguelMitrofanov)
07:52:48 <fizbin> :t listToMaybe
07:52:49 <lambdabot> [a] -> Maybe a
07:53:49 <typoclass> fizbin: you can also do "zip <*> tail", involving the (->) instance for Applicative
07:54:06 <fizbin> True...
07:54:45 <fizbin> Unfortunately, other people need to read this code so I think I'm just going to define a local "pairUp x = zip x $ tail x"
07:54:54 <quchen> The pun won't work with Applicative though.
07:54:57 <quchen> @quote zip`ap`tail
07:54:57 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
07:55:29 <typoclass> fizbin: sure, why not
07:56:03 <quchen> I think "zip <*>" isn't that uncommon.
07:57:09 <fizbin> I am using some obscure operators but only where it doesn't overly impeed understanding. E.g., >>> used to build up functions that behave sort of like a unix pipeline.
07:57:52 <typoclass> fizbin: if the goal isn't to produce lists of type [(a,b)], but to process them somehow, you could even do this --
07:57:53 <typoclass> > let pairwise f = zipWith f <*> tail in pairwise (+) [7,3,9]
07:57:55 <lambdabot>   [10,12]
07:58:21 <fizbin> Hrm.
07:58:54 <armlesshobo> @type >>>
07:58:56 <lambdabot> parse error on input `>>>'
07:59:09 <RichyB> (>>>) is (flip (.))
07:59:15 <typoclass> fizbin: or of course "pairwise f xs = zipWith f xs $ tail xs" for better clarity
07:59:18 <boily> :t (>>>)
07:59:19 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
08:00:17 <typoclass> Kinnison: do you agree with answer #1 on this page? http://stackoverflow.com/questions/218025/what-is-the-difference-between-currying-and-partial-application
08:00:39 <fizbin> So my actual use case is that I've created something of like f::(a -> a -> Bool) and I want to take an [a] and return Just (a1,a2) if there are two consecutive values such that (f a1 a2) and Nothing otherwise.
08:01:07 <armlesshobo> :O
08:01:19 <fizbin> :t catMaybes
08:01:20 <lambdabot> [Maybe a] -> [a]
08:01:56 * hackagebot bed-and-breakfast 0.2.3 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.2.3 (JulianFleischer)
08:02:16 <armlesshobo> > catMaybes [Just 4, Just 6, Nothing, Just 7]
08:02:18 <lambdabot>   [4,6,7]
08:04:51 <donri> > [Just 4, Just 6, Nothing, Just 7] ^.. folded.folded
08:04:53 <lambdabot>   [4,6,7]
08:08:31 <XexonixXexillion> :t (\f -> (curry (liftM3 if' (uncurry f) Just (const Nothing))))
08:08:32 <lambdabot>     Not in scope: if'
08:08:32 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
08:09:12 <XexonixXexillion> :t let if' p x y = if p then x else y in (\f -> (curry (liftM3 if' (uncurry f) Just (const Nothing))))
08:09:14 <lambdabot> (a -> b -> Bool) -> a -> b -> Maybe (a, b)
08:11:39 <typoclass> > let search f = listToMaybe . filter (uncurry f) . (zip <*> tail) in (search (==) [4,9,7], search (==) [4,9,9,7,7]) -- fizbin, have you tried this
08:11:41 <lambdabot>   (Nothing,Just (9,9))
08:12:27 <fizbin> Oh, duh. Right - filter.
08:17:25 <McManiaC> does haskell work with cygwin libraries or does it need libraries build with mingw on windows?
08:19:00 <geekosaur> the usual build process is mingw, I think there are cygwin build rules but they haven't been tested recently?
08:20:52 <typoclass> McManiaC: you could check the logs on ircbrowse. merijn has been trying things with cygwin the last few weeks and had a lot of pain. not sure if he managed in the end
08:24:26 <dgpratt> mingw seems to be the lighter weight thing -- what are the advantages of the cygwin path?
08:24:38 <ryantanjunming> https://gist.github.com/anonymous/f93e3692a1edf7b35886
08:25:08 <ryantanjunming> can anyone tell me what line 2 represents?
08:25:10 <ryantanjunming> its ==> deleteFunction i1 (Branch i2 Leaf Leaf) == Branch i2 Leaf Leaf
08:25:24 <ryantanjunming> especially for ==>
08:25:27 <ryantanjunming> @==>
08:25:27 <lambdabot> Unknown command, try @list
08:26:30 <Spockz> a year of two ago I ran into something called like flexible case patterns. I cannot find it anymore but I know it was in the Functional Pearl. Does this ring a bell for someone?
08:26:35 <parcs> ryantanjunming: ==> is implies
08:26:50 <parcs> ryantanjunming: False ==> y = True; True ==> y = y
08:26:56 <dgpratt> ryantanjunming: isn't that supposed to be suggestive of implication? in other words, if i1 /= i2 then...
08:27:49 <parcs> x ==> y = not x || y
08:28:54 <typoclass> ryantanjunming: check this page http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck-Property.html#v:-61--61--62-
08:29:01 <Cale> ryantanjunming: it's mainly confusing in that it really ought to be indented by at least a space
08:29:10 <typoclass> ryantanjunming: i've found it by searching "==>" with hoogle
08:29:13 <Cale> since it's part of the definition that begins on the previous line
08:29:38 <Cale> (though I dunno, you might be able to get away with that insanity for some reason)
08:30:36 <parcs> i think think you can
08:30:40 <parcs> don't think*
08:31:23 <parcs> welp, never mind..
08:31:46 <Cale> Yeah, the fact that it's an infix operator makes it possible that things are a little different
08:32:01 <Cale> (but I still think it's a bit funny not to indent)
08:32:05 <ryantanjunming> thanks guys
08:33:02 <flebron> So, I'm trying to solve a programming competition problem with Haskell. The time constraints are pretty tight. Though my algorithm works, my program spends too long on I/O and the online judge calls a time limit exceeded. The input format is pretty simple (and purely numeric), but it can be quite large. Could I ask for some help using Bytestrings correctly?
08:34:03 <hpaste> rifki pasted ‚Äúgraph‚Äù at http://hpaste.org/85553
08:34:21 <Cale> btw, you could make that test a good bit more robust perhaps by making it   prop_delete_detect_error deleteFunction i1 i2 l r = i1 /= i2 ==> deleteFunction i1 (Branch i2 l r) == Branch i2 (deleteFunction i1 l) (deleteFunction i1 r)
08:34:23 <rifki> hi, I made a hpaste, can you help me with that?
08:35:30 <Cale> rifki: tab warning -- there are tabs in your source file, you should really configure your editor to insert spaces when you press tab
08:35:55 <rifki> Cale : okey, thanks
08:36:26 <Cale> rifki: I'm not sure what you're asking how to do exactly. If you have a list of nodes, you can use everything which works on lists
08:36:41 <Cale> :t find
08:36:43 <lambdabot> (a -> Bool) -> [a] -> Maybe a
08:36:49 <typoclass> rifki: have you tried something like ¬´filter ((== "a") . label) [Node 'a' ..., Node 'b' ...]¬ª?
08:37:02 <Cale> (or yes, filter)
08:37:41 <rifki> yeah, I should have tried list functions at first, thanks!
08:37:42 <typoclass> Cale: heh, i just realized, find and filter are the same modulo some listToMaybe, aren't they
08:37:47 <Cale> yes
08:38:00 <Cale> To get the nth node, you could use !! but I wouldn't generally recommend using !! unless it's absolutely necessary from the description of what you need to do.
08:39:51 <Cale> This is for multiple reasons: 1) inappropriate indices produce an error that can't (easily) be handled, 2) xs !! n takes O(n) steps to evaluate, 3) if you need a lot of lookups of that sort, you'd probably be better off with something other than a list, like an IntMap
08:45:26 <flebron> I'll go ahead and ask, then. The input format is first an int k, the number of cases, Before each test case, a blank line. Each test case consists of an int n, and then n ints following n.
08:46:01 <flebron> So for instance, the lines could be ["2", "", "3", "5", "3", "9", "", "2", "7", "3"]
08:46:20 <flebron> (That is, those are the lines in the file, each one as a string in that list.)
08:46:38 <flebron> I'm using Bytestring to read that as follows: http://ideone.com/r7jevh . Does this make sense? Am I being particularly inefficient?
08:46:57 * hackagebot Obsidian 0.0.0.1 - Embedded language for GPU Programming  http://hackage.haskell.org/package/Obsidian-0.0.0.1 (JoelSvensson)
08:47:05 <flebron> The goal of the program is to compute the number of pairs (i, j) in the given list of numbers, such that A[i] > A[j], with i < j.
08:47:24 <Kinnison> typoclass: Sorry I was in a meeting
08:47:25 * Kinnison looks
08:47:44 <flebron> The algorithm itself seems to be fast enough. The IO, on the other hand, isn't. I'm installing profiling tools on this machine to post the prof results, but last time I checked, IO was the bottleneck.
08:49:38 <aCube> Can I tell GHC not to shorten the Cost Centres generated by -auto-all?
08:50:28 <typoclass> Kinnison: sure :-) i'm trying to determine what the curring vs partial application distinction means in haskell
08:51:04 <Kinnison> typoclass: It's not how I'd have described it, but it seems about right.  It's a very mathematical explanation
08:51:14 <Kinnison> Basically what http://en.wikipedia.org/wiki/Currying says
08:51:36 <croikle> flebron: If you are taking too much time in IO, just read the whole input as a bytestring
08:52:13 <Kinnison> typoclass: Basically I'd say that haskell function definitions are implicitly curried in that every function takes one arg only
08:52:24 <croikle> you can ignore k and n, and just get cases based on the empty lines
08:52:30 <flebron> croikle: Is that going to be better than reading it with getLine?
08:52:34 <flebron> Yes, I can.
08:52:34 <rifki> for the data type in  http://hpaste.org/85553  I made this function  which is supposed to give me the label: giveLabel (Node a,[(b,c)]) = a;  but it gave error. How can I write the correct one?
08:52:48 <armlesshobo> a -> (b -> (c -> d))
08:52:48 <flebron> So I would do something like B.split "\n\n"?
08:52:55 <bitonic> is there a name for a functional graph data structure that stores the graph topologically sorted so that I can detect if inserting an edge creates a cycle efficiently?
08:53:12 <flebron> bitonic: I would use a disjoint sets datastructure for that
08:53:15 <armlesshobo> it takes in an arg, and returns a function that takes an arg, and returns a function that takes in an arg and returns a value.
08:53:32 <bitonic> flebron: can you elaborate that?
08:53:45 <fizbin> What's the easiest way to do (Maybe a, b) -> Maybe (a,b) ?
08:54:02 <croikle> flebron: I could imagine it would be faster. Yeah, that would work, or split the lines output on ""
08:54:24 <flebron> bitonic: Sure. http://en.wikipedia.org/wiki/Disjoint-set_data_structure
08:54:43 <flebron> It's the best possible structure for detecting whether a series of edge additions creates a cycle, or connects two components.
08:55:01 <armlesshobo> fizbin: you'd have to define your own functions, most likely.
08:55:04 <bitonic> fizbin: ‚Äò(, snd x) <$> fst x‚Äô with tuple sections
08:55:13 <bitonic> fizbin: oh right, thanks.
08:55:23 <armlesshobo> fizbin: you'd need to check for Nothing, I imagine.
08:55:27 <flebron> (It's commonly used in Kruskal's algorithm.(
08:55:51 <bitonic> > let f (x, y) = (, y) <$> x in f (Just 1, 2)
08:55:52 <flebron> croikle: Hrm, Bytestring.Split seems to want a Word8 (in other words, a Char) to split by, not "\n\n" :(
08:55:52 <lambdabot>   Illegal tuple section: use -XTupleSections
08:56:15 <bitonic> > let f (x, y) = (\x' -> (x', y) <$> x in f (Just 1, 2)
08:56:16 <lambdabot>   <hint>:1:38: parse error on input `in'
08:56:24 <bitonic> > let f (x, y) = (\x' -> (x', y)) <$> x in f (Just 1, 2)
08:56:25 <lambdabot>   Just (1,2)
08:56:44 <armlesshobo> > let f (x, y) = (\x' -> (x', y)) <$> x in f (Nothing, 2)
08:56:45 <bitonic> fizbin: with TupleSections is nicer
08:56:46 <lambdabot>   Nothing
08:57:45 <bitonic> Cale: is there a reason for not having TupleSections in lambdabot?
08:57:46 <croikle> flebron: oh, yeah. you could write your own with breakSubstring, but probably splitting on lines and then on empties is easier
08:57:57 <typoclass> fizbin: how about "f (Just a,b) = Just (a,b) ; f _ = Nothing" ?
08:58:01 <fizbin> It's still an improvement on what I had: \(x,y) -> x >>= return . (flip (,) y)
08:58:55 <flebron> Ah, OK. I can tail . dropWhile null.
08:58:56 <supki> > (Just 3, 4) & _1 id
08:58:58 <lambdabot>   Just (3,4)
08:59:02 <supki> > (Nothing, 4) & _1 id
08:59:04 <lambdabot>   Nothing
08:59:14 <bitonic> lenses lenses.
08:59:26 <fizbin> :t _1 id
08:59:27 <lambdabot> (Functor f, Field1 s t (f b) b) => s -> f t
08:59:56 <Taneb> > _1 id ("hello", 8)
08:59:56 <edwardk> > sequenceOf _1 (Nothing, 4)
08:59:57 <lambdabot>   can't find file: L.hs
08:59:58 <lambdabot>   [('h',8),('e',8),('l',8),('l',8),('o',8)]
09:00:01 <edwardk> > sequenceOf _1 (Nothing, 4)
09:00:03 <lambdabot>   Nothing
09:00:08 <edwardk> > sequenceOf _1 (Just 5 , 4)
09:00:09 <lambdabot>   Just (5,4)
09:00:13 <elliott> fizbin: f (m,b) = (,b) <$> m
09:00:34 <bitonic> elliott: what was my proposal but lambdabot doesn‚Äôt have TupleSections :(
09:00:45 <bitonic> bad, bad bot
09:01:34 <rifki> has anyone seen my question?
09:01:55 <armlesshobo> rifki: no, what is it?
09:02:03 <armlesshobo> rifki: did you misplace it? :P
09:02:36 <typoclass> rifki: i've only seen the eariler one about how to get Nodes out of a list
09:02:40 <Cale> rifki: You mentioned getting an error in a piece of code that you didn't seem to paste?
09:03:45 <typoclass> rifki: oh i see it now, sorry, i scrolled past it. your Node type has a function "label" already. it's declared in line 3 of your paste
09:08:54 <bitonic> flebron: do you have any other material on using that data structure to detect cycles?  the wiki page is kinda dry
09:17:13 <aCube> What does * mean in a heap profile broken down by type?
09:20:34 <typoclass> i wonder what this distinction currying vs partial application is good for
09:21:54 <S11001001> typoclass: `uncurry' is a function for doing partial application
09:21:57 <Eduard_Munteanu> typoclass: you can have currying without partial application
09:22:11 <S11001001> typoclass: sorry, I mean `curry' is a function for doing partial application
09:22:24 <typoclass> Eduard_Munteanu: right, but not in haskell
09:23:21 <S11001001> typoclass: but you do not use the `curry' function when you merely wish to use currying normally
09:23:29 <typoclass> S11001001: yeah ... i dunno. "let f = map succ in ..." is partial application as well, and didn't need the 'curry' function
09:23:48 <S11001001> no, it's normal application
09:25:21 <typoclass> S11001001: well i'll give you that partial application is the normal thing in haskell (partial application is normal application), but how is it wrong to call "map succ" partial application?
09:25:46 <Eduard_Munteanu> (I guess you can have partial application without currying, too, if you stretch it a bit)
09:25:46 <S11001001> it is tantamount to proposing that sometimes passing (>>=) two args is partial application and sometimes it is not
09:26:03 <geekosaur> wat
09:26:15 <S11001001> or that "it is indeterminate whether this is a partial application"
09:26:54 * geekosaur cannot rightly apprehend the confusion of ideas that would lead to such an assertion
09:27:14 <typoclass> S11001001: i'm not sure what you're saying. i thought haskell there was no syntactic difference between giving map only one argument, and giving map two arguments. i.e. partial application and complete application
09:27:18 <S11001001> geekosaur: precisely why I am asking that it not be asserted
09:27:26 <adamh> Hi people!
09:27:32 <Eduard_Munteanu> adamh: hi
09:27:42 <geekosaur> S11001001, it is *your*( assertion that is incomprehensible
09:28:00 <geekosaur> :t (>>=)
09:28:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:28:18 <S11001001> geekosaur: m = (->) r, m = []
09:28:37 <geekosaur> it still makes perfect sense
09:28:42 <osa1> any ideas why does hakyll removes javascript code fromt template files ?
09:28:42 <geekosaur> it returns a function
09:28:52 <S11001001> geekosaur: so does "map succ"
09:29:04 <geekosaur> if this confuses you, perhaps you do not fully understand functional programming where returning functions makes perfect sense
09:29:16 <geekosaur> yes, and?
09:29:41 <Eduard_Munteanu> Returning a function isn't the same thing as partial application in other languages, though.
09:29:45 <geekosaur> I think you are getting confused because you want things to fall into imperative-based pigeonholes
09:30:15 <oab> what's the confusion?
09:30:16 <S11001001> geekosaur: it does *not* confuse me.  But if you call "map succ" partial application, I do not see how you can claim that (xs >>= f) isn't sometimes partial application.
09:30:33 <geekosaur> S11001001, (>==) itself is fully applied
09:30:38 <geekosaur> it returns a function type
09:30:42 <geekosaur> er, >>=
09:30:59 <S11001001> so does "map succ".
09:31:09 <S11001001> :t map succ
09:31:11 <lambdabot> Enum b => [b] -> [b]
09:31:19 <S11001001> looks like it returns a function type to me.
09:31:20 <geekosaur> but map is not fully applied
09:31:26 <geekosaur> you are still confused
09:31:30 <typoclass> oab: i was wondering if the distinction "currying vs partial application" is important, as far as haskell in concerned. it seems everything is curried anyways, and it seems there's no distinction between partially applying and completely applying
09:31:43 <typoclass> *as far as haskell is concerned
09:32:12 <S11001001> geekosaur: Is the distinction you are making observable in the type system?
09:32:21 <geekosaur> :t map
09:32:23 <lambdabot> (a -> b) -> [a] -> [b]
09:32:36 <Eduard_Munteanu> Yeah, you get partial application for free in Haskell.
09:32:38 <Philippa> typoclass: it's possible to recover a notion of 'fully applied', but it's not always the one you want
09:32:38 <S11001001> yeah I don't care about the universally quantified version, it's gone, we monomorphized it
09:32:42 <geekosaur> fully applied means you supplied both (a -> b) and [a]
09:32:53 <geekosaur> :t (>>=)
09:32:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:33:14 <Iceland_jack> :t id id
09:33:15 <typoclass> Philippa: hm! interesting, do you have a link or something?
09:33:15 <lambdabot> a -> a
09:33:16 <Philippa> but it's definitely the notion of 'fully applied' (as opposed to just 'applied') that's interesting there
09:33:35 * elliott thinks that before trying to define "fully applied", the situation and meaning that it is desired for should be established first
09:33:37 <Philippa> typoclass: it's just the 'obvious' one - run the currying isomorphism the other way, apply 'til the outermost type constructor isn't ->
09:33:58 <geekosaur> fully applied means you supplied an m a and a (a -> m b). whether *those* are fully applied or not is not relevant to (>>=) being fully applied
09:34:26 <Eduard_Munteanu> geekosaur: or whether the result is fully applied
09:34:28 <Philippa> typoclass: you can also have a useful notion of 'arity' and 'saturation' that's more operational, but it's orthogonal to the type system
09:34:35 <Eduard_Munteanu> I think that was your point.
09:34:38 <typoclass> Philippa: oh. "call this until it returns something that's not a function"
09:34:43 <oab> typoclass: Ah, thanks for repeating. I see no difference immediately.
09:34:48 <geekosaur> well, yes
09:34:52 <liyang> What if m is (->) r ? Is it really fully applied?!
09:35:09 <elliott> geekosaur: so is (id >>=) fully applied when given one or two arguments?
09:35:22 <geekosaur> but in any case you're still trying to force it into nice neat pigeonholes that are not at all appropriate to Haskell
09:35:24 <liyang> (cue: "so where are you *really* from?" I get this a lot.)
09:35:26 <elliott> the function (id >>=), that is
09:35:33 <Philippa> typoclass: quite. Whereas I effectively want two 'modes' for fmap for example
09:35:36 <S11001001> geekosaur: that means in the expression (>>=) `asTypeOf` x, I can supply an `x' that causes the result to require 3 args before being "fully applied"
09:35:42 <Philippa> (one parm: inline it. Two parms: *really* inline it :p)
09:35:50 <ski_> `type Foo t = Either [t]', is `Foo Int' fully applied ?
09:35:55 * geekosaur just accepted correction of terminology, is it now necessary to accept it again every timer someone else sees it in scrollback?
09:36:01 <Eduard_Munteanu> liyang: certain languages may distinguish 'f x y = 1' and 'f x = \y -> 1'
09:36:11 <Philippa> Eduard_Munteanu: for example, GHC's innards
09:36:19 <liyang> Eduard_Munteanu: GHC does! At least for inlining purposes.
09:36:22 <typoclass> elliott: i was thinking in terms of a hypothetical map function in javascript. you'd partially apply it by doing "partial(map, succ)" or some such. you'd fully apply it by doing "map(succ, [stuff,stuff])"
09:36:22 <Philippa> liyang: urgh, yeah
09:36:45 <Eduard_Munteanu> Well, yeah, and sharing-wise, but I didn't mean that.
09:37:29 <liyang> So what do you *really* mean?
09:37:37 <Eduard_Munteanu> ski_: sure, why not?
09:37:54 <ski_> Eduard_Munteanu : well, the kind is `* -> *'
09:37:55 <typoclass> Eduard_Munteanu: he means, the Either is expecting another argument
09:37:55 <midfield> is chris done hanging out here?  i have some emacs questions...
09:38:12 <Eduard_Munteanu> liyang: I mean in some languages you might not get the latter from the former
09:38:15 <ski_> preflex: xseen chrisdone
09:38:15 <preflex>  chrisdone was last seen on freenode/#haskell 18 hours, 47 minutes and 4 seconds ago, saying: i'm afraid i can't do that, dave
09:38:19 <typoclass> midfield: sometimes. his name is chrisdone. but there's also other emacs fans, e.g. johnw
09:38:21 <ski_> midfield : not here atm
09:38:26 <liyang> Eduard_Munteanu: only trolling. :)
09:39:06 <Philippa> Eduard_Munteanu: and others might be polymorphic in it. I alluded to mode systems in logic languages because they do something related
09:39:25 <Eduard_Munteanu> No, he's not Done hanging out here. :P
09:40:00 <midfield> thanks peops, i'm an irc noob
09:41:14 <oab> I would give the troll answer that in haskell functionas are always fully applied as they only take one argument and return a function that do the same or a value
09:41:36 <ski_> > seq ((\False _ -> ()) True) ()
09:41:37 <ski_> > seq ((\False -> \_ -> ()) True) ()
09:41:39 <lambdabot>   ()
09:41:39 <lambdabot>   can't find file: L.hs
09:41:45 <ski_> > seq ((\False -> \_ -> ()) True) ()  -- ..
09:41:47 <lambdabot>   *Exception: <interactive>:3:7-24: Non-exhaustive patterns in lambda
09:42:12 <oab> I see the haskell wiki talks about partial application http://www.haskell.org/haskellwiki/Partial_application
09:42:24 <ski_> (that's a simple example when `\<pat 0> <pat 1> -> expr' isn't equivalent to `\<pat 0> -> \<pat 1> -> <expr>')
09:43:50 <ski_> Eduard_Munteanu : .. anyway, i wasn't really saying yea or nay, just wondering in what sense "fully applied" was being used here, or what distinction was meant to be drawn
09:45:14 <Philippa> oab: right. Regardless of whether it's part of the language per se, it's part of the way people think and talk about using it - and for good reason
09:45:31 <Philippa> (See also: not a lot of mathematicians /really/ work directly in a given set theory most of the time)
09:46:03 <typoclass> with the caveat that i didn't completely understand what S110 meant, so far the distinction seems to be not very important. in the sense that if someone sloppily says "i curried by saying 'map succ'", we don't need to yell extensively because it's clear, and haskell doesn't have currying as such in the first place
09:47:36 <typoclass> tangentially, what is this from the wiki page supposed to mean? "Functions are not partial, you can partially apply a function". partial functions are something else, aren't they (head etc.)
09:48:19 <Kinnison> partial functions are functions which may result in bottom given some inputs
09:48:22 <Kinnison> e.g. head []
09:48:34 <typoclass> Kinnison: sure
09:56:29 <Kaligule> Am I right to the haskell channel here?
09:56:38 <hvr> Kaligule: depends
09:56:45 <ab9rf> Kaligule: you might be left to the haskell channel, depends on where you are sitting.
09:56:50 <Eduard_Munteanu> Kaligule: yep :)
09:56:50 <fizbin> @hoogle find
09:56:50 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:56:51 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
09:56:51 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:57:49 <Kaligule> Ah, great! This is my first IRC chat
09:57:56 <Kaligule> @ab9rf :P
09:57:57 <lambdabot> Unknown command, try @list
09:58:04 <ab9rf> i am not a command!
09:58:04 <Eduard_Munteanu> Welcome then.
09:58:15 <ab9rf> and this isn't twitter :)
09:58:27 <Eduard_Munteanu> Kaligule: use tab completion like we did, not the @ thingy
09:58:52 <Kaligule> I see. So lets get see.
09:58:58 <Kaligule> ab9rf: :P
09:59:15 <Kaligule> I see. So lets get serious.
10:00:01 <Eduard_Munteanu> How seerious?
10:00:05 <ab9rf> do we have to?  i don't really enjoy being serious.
10:00:15 <hvr> Haskell *is* serious business
10:00:21 <adamh> It is?
10:00:36 <hvr> yes! just look at all those lamdbacats
10:00:40 <adamh> I've always thought it was nice and fluffy :3
10:00:53 <adamh> or at least, fun
10:01:02 <adamh> I tend to associate seriousnuss with unenjoyable stuff
10:01:05 <hpaste> rifki pasted ‚Äúgraph question‚Äù at http://hpaste.org/85557
10:01:07 <adamh> so not haskell
10:01:08 <hvr> let's compromise on serious fun
10:01:22 * typoclass . o O ( i wish lambdabot didn't produce that weird message, it seems not really necessary )
10:01:24 <rifki> hey, I made a hpaste, can you read and help me please?
10:01:38 <hvr> rifki: where is it?
10:01:49 <rifki> http://hpaste.org/85557
10:02:01 * hackagebot BNFC 2.5.0 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.5.0 (GregoireDetrez)
10:02:06 <rifki> there is something wrong with my connection tonight, sorry about that :(
10:02:31 <elliott> typoclass: it discourages the wrong style of nick reference :)
10:02:51 <hvr> rifki: maybe you need brackets: i.e. "deGraph (Graph [Node ...]) = ...'
10:03:16 <adamh> There doesn't seem to be any difference between what you're getting in, and putting out?
10:03:27 <ab9rf> that only matches for a graph of one node
10:03:31 <typoclass> rifki: you need parens, and also you can just write "deGraph (Graph x) = x"
10:03:35 <typoclass> rifki: hope this helps
10:03:50 <ab9rf> what typoclass said :)
10:04:09 <hvr> typoclass: but it Just see, it's a 2-field constructor so that won't work
10:04:17 <ab9rf> hvr: yes, it will
10:04:34 <hvr> ab9rf: right, nevermind
10:04:40 <rifki> typoclass : deGraph Graph [ ( Node 'a' [ ( 'b' , 3 ) , ( 'c' ,2 ) ] ) , ( Node 'b' [ ('c' , 3 ) ] ) , ( Node 'c' [] ) ] ERROR - Type error in application *** Expression     : deGraph Graph [Node 'a' [('b',3),('c',2)],Node 'b' [('c',3)],Node 'c' []] *** Term           : deGraph *** Type           : Network d -> [Node d] *** Does not match : a -> b -> c
10:04:40 <Eduard_Munteanu> typoclass: or you can do   data Network a = Graph { deGraph :: [Node a] } deriving Show
10:04:45 <Eduard_Munteanu> Erm.
10:04:50 <Eduard_Munteanu> rifki: ^^
10:05:19 <typoclass> rifki: in this case it was obvious, but in the future, it always helps when you put ghc's error messages into the hpaste
10:05:44 <rifki> okey, I can do that right now if you like, sorry
10:06:14 <typoclass> rifki: yeah, the thing to remember is that " " binds tighter than (almost) everything. so "deGraph Graph [...]" groups as "(deGraph Graph) [...]". what you need here is "deGraph (Graph [...])"
10:07:57 <rifki> typoclass: I tried deGraph (Graph [x]) = [x] and it gave same error
10:08:53 <typoclass> rifki: if you use [x], it will match a list of length 1, and call the list's only element "x"
10:09:09 <typoclass> rifki: to match a list of any length, use "x" with no square brackets
10:09:20 <Kaligule> A friend of mine forced me to read learnyouahaskell.com but for learning I do need some exercise, too. Can you help me there?
10:09:38 <ab9rf> rifki: you have to deGraph (Graph ....)
10:09:47 <typoclass> @google 99 haskell problems
10:09:50 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
10:09:50 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
10:09:54 <typoclass> Kaligule: how about this ^^ ?
10:10:23 <ab9rf> Kaligule: forced you to? :)
10:10:29 <ab9rf> Kaligule: sound serious.
10:10:35 <rifki> typoclass : I guess I didn't understand what you said
10:10:52 <Kaligule> Thanks.
10:11:30 <Kaligule> Yes, forced me for my own good :)
10:13:39 <aCube> What does * mean in a heap profile broken down by type?
10:14:50 <Kaligule> quit
10:14:59 * geekosaur reads oleg's rant about unsafeInterleave{O,ST}, wonders who was asserting they weren't unsafe
10:16:33 <ab9rf> you'd thnk the "unsafe" would be a hint
10:17:21 <elliott> getContents is generally considered safe
10:17:36 <Philippa> ...ish
10:18:12 <c_wraith> isn't http://hpaste.org/85488 morally the same problem?
10:18:25 <c_wraith> But without all the complexity?
10:18:36 <ab9rf> 'morally'?
10:18:49 * geekosaur considers getContents pretty damn unsafe, actually
10:18:49 <typoclass> elliott: well, everyone has at least once done "c <- hGetContents h ; hClose h ; print c" and wondered why that doesn't print anything ...
10:19:12 <elliott> geekosaur: not everyone does
10:19:14 <c_wraith> ab9rf: meaning "technically different, but sharing all the same key aspects"
10:19:26 <elliott> anyway I don't buy Oleg's example, roconnor's reading of it as a race condition seems right to me
10:19:29 <tdammers> typoclass: I've done a variation
10:19:33 <elliott> though I avoid lazy IO for other reasons
10:19:35 <ab9rf> c_wraith: i've never seen 'morally' used to impart that meaning :)
10:19:38 <c_wraith> ab9rf: see the paper "fast and loose reasoning is morally correct"
10:19:52 <ab9rf> c_wraith: ah, so an in-joke
10:19:55 <tdammers> c <- hGetContents h; hClose h; someWebRoute c
10:20:05 <tdammers> and then wonder why it fails to send more than 4096 bytes
10:20:21 <quchen> ^ What happens in that case anyway?
10:20:23 <typoclass> tdammers: urg, that's even more sneaky
10:20:24 <quchen> Exception?
10:20:29 <quchen> Silend cutoff?
10:20:34 <Philippa> ab9rf: it's not an in-joke, it's a pretty common usage 'round my neck of the woods
10:20:43 <quchen> "Silent", woops
10:20:53 <c_wraith> quchen: yeah, it's a silent cutoff
10:20:58 <quchen> Ewww.
10:21:20 <ab9rf> Philippa: it's still an in-joke if it's only common within a limited community.
10:22:04 <geekosaur> lazy I/O has no way to report errors, so it just stops
10:22:22 <ab9rf> geekosaur: well, it could do worse :)
10:22:31 <Philippa> not if it's not a joke, not if the "limited community" is, say, a large proportion of Commonwealth English speakers
10:22:32 <ab9rf> geekosaur: at least it doesn't set fire to the computer
10:22:40 <typoclass> geekosaur: that's actually a good question. why doesn't it throw an exception? OmgHandleClosed
10:22:40 <Philippa> it's just an idiom you're not familiar with
10:22:45 <quchen> geekosaur: In some predictable way at least? Like after reading k bytes or something, or is it completely arbitrary
10:22:48 <tdammers> silent cutoff. Nasty.
10:23:04 <quchen> geekosaur: I'm just asking because that may help debugging one day :-)
10:23:15 <geekosaur> typoclass, because you can't trap an exception in pure code and there is no way to control where such an exception gets thrown
10:23:15 <tdammers> And the length, I figured, depemds on whatever caching the system provides
10:23:54 <geekosaur> it would mean all pure code can potentially throw IO exceptions and the only way to deal is to run it in IO, defeating the purpose of pure code
10:24:06 <typoclass> quchen: iirc my example cuts of at 0 bytes, so you notice very quickly. those 4096 bytes with his network socket are pretty evil
10:24:32 <quchen> typoclass: Hm. I guess you just have to look out for magic numbers then.
10:24:36 <typoclass> geekosaur: i see :-/
10:24:52 <quchen> That bug is especially devious when you're used to bracketing, hence you're not really aware of it anymore :s
10:25:09 <typoclass> quchen: well, more like "lazy i/o is always something to think twice about"
10:25:31 <quchen> That's easier said than done
10:25:44 <typoclass> quchen: in particular, "how soon i can close the handles is something to think twice about"
10:25:52 <typoclass> quchen: yep, absolutely
10:26:52 <typoclass> quchen: some people advise against lazy i/o entirely. there's various alternatives, conduits and iteratees and all that stuff, but i don't know which is the recommended one
10:27:05 <quchen> typoclass: Was about to ask about that
10:27:14 <quchen> There's so many libs dealing with that problem
10:27:28 <quchen> *So* many there's a comic about it! ;-)
10:29:09 <Philonous> typoclass:  I like conduits. It's pretty mature and there's a lot a supporting code written already
10:29:54 <typoclass> Philonous: that's true, i've used http-conduit and it's pretty easy
10:29:55 <quchen> Philonous: Do you know how they work?
10:30:09 <quchen> Like how do you disable IO's laziness conceptually
10:30:37 <armlesshobo> just hSetBuffering <handle> NoBuffering
10:30:40 <armlesshobo> and you're good to go
10:30:55 <quchen> Except that doesn't perform that well
10:31:13 <dmwit> Also that wouldn't even help.
10:31:16 <quchen> (Also you could still run into cutoff)
10:31:17 <quchen> Yeah
10:31:46 <dmwit> Buffering has no effect on the order your lazily-deferred IO actions run.
10:31:59 <armlesshobo> yeah, i was trying to be sarcastic :(
10:32:06 <ski_> typoclass : "we don't need to yell extensively because it's clear" -- i think in this (simple) case it's clear what is meant, but the terminology being used is still confused
10:32:09 <dmwit> ...oh
10:32:12 <quchen> ...oh
10:32:14 <armlesshobo> there's gotta be a lib for that
10:32:15 <armlesshobo> ahahah
10:32:25 <armlesshobo> i can't seem to convery sarcasm well on IRC
10:32:35 <armlesshobo> convey, even.
10:32:45 <ski_> S11001001 : .. i would say that you can use `curry' (in Haskell) to curry a function taking a pair, as well as use it to partially apply such a function in one component of the pair (normally the first one)
10:33:23 <pascha> Hi! So raw sockets are for designing your own protocol based on IP? would it be a good exercise to implement TCP on top of it if you want to learn TCP/IP? Im looking for the next step in learning TCP/IP and what I hav done so far is write a simple protocol on top of the Socket API, using SOCK_STREAM and the protocol was just handling timeouts with a ping-pong message every X milliseconds and
10:33:23 <pascha> solving message framing by sending the message length in the first byte. Maybe I should write a network game. Something simple.
10:33:51 <bartavelle> hello, I wan't to write a Functor instance for something that has a HashMap in it and where fmap will work on the key. Where should I put the Hashable instance ?
10:33:54 <pascha> Can you crosscompile with ghc? Can you compile to MAC OS?¬®
10:34:53 <quchen> pascha: Some cross-compilation is apparently doable, but it's not too easy. http://hackage.haskell.org/trac/ghc/wiki/Building/CrossCompiling
10:34:54 <Philonous> quchen:  I do understand how it works, but I'm not sure how to convey it succinctly. Instead of lazy IO you have coroutines and your iteratee/conduit/pipes monad interleaves stages of the computation for you
10:35:00 <ski_> typoclass : i think "currying" is the process of turning a function of multiple arguments into one that takes some of the arguments, returning a new function that takes the rest of them (and we can allow iteration of this process); and "partial application" is the process of taking a function of multiple arguments and apply it with actual parameters for some of the formals, getting back a function that awaits the rest of them
10:35:43 <ski_> typoclass : afaics, these two aren't directly comparable (one takes one function, the other a function and also a couple of arguments), so i don't see how one could not distingush between them
10:36:20 <Philonous> quchen:  Whenever a stage of the pipe needs more input it is suspended (think shift or callCC) and control is transfered upstream so the part above it can produce more input.
10:36:42 <bartavelle> hum it seems I can't do this
10:37:05 <bartavelle> can I write a Functor instance for something where the "type variable" must be Hashable ?
10:37:09 <typoclass> ski_: yes, but in haskell, everything is curried to start with, isn't it? we have only partial application
10:37:18 <dmwit> bartavelle: Nope, you're hosed.
10:37:21 <c_wraith> bartavelle: you are correct. It can't be done for the standard Functor class
10:37:26 <bartavelle> ok thanks
10:37:30 <bartavelle> same for Monad I suppose ?
10:37:34 <dmwit> bartavelle: You'll have to use another typeclass, or generally name your function something other than Prelude.fmap.
10:37:37 <dmwit> bartavelle: indeed
10:37:40 <dmwit> bartavelle: you might like
10:37:42 <dmwit> ?hackage rmonad
10:37:43 <lambdabot> http://hackage.haskell.org/package/rmonad
10:38:00 <bartavelle> the point of doing this is getting the syntactic sugar of the do notation
10:38:19 <dmwit> In that case, you'll want the RebindableSyntax extension, too.
10:38:27 <bartavelle> hum
10:38:33 <quchen> Philonous: Hmm. Well, that's not very specific. Do you know the general idea, like what's disabling the laziness? Something constantly requesting data as it's read? Massive amounts of hacks?
10:38:33 <bartavelle> I'll just use a list ;)
10:39:22 <dmwit> quchen: There's nothing to disable because it's not using lazy IO in the first place.
10:39:25 <bartavelle> actually I can't even use a list
10:39:30 <dmwit> (if we're still talking about conduits, iteratees, and friends)
10:39:31 <bartavelle> I'll figure something out
10:39:33 <bartavelle> thanks !
10:39:41 <quchen> dmwit: Oh. (And yes)
10:39:51 <ski_> typoclass : also "everything is curried anyways" is incorrect, see e.g. `Ix a => (a, a) -> [a]'. it's "just" a matter of convention and simple syntax (with sugar) available
10:40:02 <dmwit> quchen: (Not all values of type IO a use lazy IO.)
10:40:22 <Philonous> quchen:  IO is not inherently lazy, you have to make it so with unsafeInterleaveIO
10:41:18 <typoclass> ski_: not sure what you mean. that's a function that takes a tuple and gives a list?
10:41:22 <ski_> typoclass : see e.g. "In Haskell, all functions are _considered_ curried" at <http://www.haskell.org/haskellwiki/Currying> -- note the "considered". i would prefer saying something like "can be considered" or "are usually considered" instead of "are considered"
10:41:32 <dmwit> The "lazy" in "lazy IO" is referring to the execution strategy, not the evaluation strategy.
10:41:39 <quchen> dmwit, Philonous: Ah, that sounds good.
10:42:14 <ski_> typoclass : obviously you can think of `range' as a function that takes two arguments (a lower and an upper bound), and returns a list of array indices ranging from the lower bound to the upper bound
10:42:48 * elliott thinks lazy IO is unfortunately named. causes all this confusion.
10:42:50 <ski_> typoclass : and if you do, i hope you'd agree that it's not to be considered as curried
10:42:58 <elliott> though it would cause all this confusion even if it were not misnamed :P
10:43:06 * ski_ thinks of lazy I/O as akin to concurrency
10:43:20 <armlesshobo> Lazy I/O? More like Crazy I/O, am I right?
10:43:33 <ski_> (in that you don't know exactly when the reads will happen)
10:44:10 <ski_> typoclass : i disagree with "in haskell, everything is curried to start with" and "we have only partial application"
10:44:31 <typoclass> ski_: so you're saying that "r :: a -> b -> c" is not curried?
10:44:32 <ski_> typoclass : strictly speaking, we only have application, period
10:44:38 <dmwit> Chuck Norris knows when reads will happen, and instantiates books at just the right moment.
10:45:24 <typoclass> "not curried" or "not considered as curried", if you want
10:45:26 <elliott> the thing that makes lazy IO weird is that the timing of the concurrency is based on evaluation. you can argue this as an implementation detailt hough
10:45:46 <pascha> why is crosscompiling so hard?
10:45:46 <ski_> typoclass : however, there's an informal concept of "function with multiple arguments" which we can *encode* in Haskell -- one way of encoding it is as a curried function, another is as a tupled function (meaning : taking a tuple of arguments) -- you can of course also mix this, ior use records (or lists or ...) instead of tuples
10:46:08 <pascha> @src curry
10:46:09 <lambdabot> curry f x y = f (x, y)
10:46:31 <ski_> typoclass : i would say that the currying of `r :: a -> b -> c' doesn't lie in `r' itself, but in how we encode a "function taking one argument of type `a' and one of type `b'" in Haskell
10:46:59 <pascha> > let myadd (a,b) = a+b in curry myadd 5 3
10:47:01 <lambdabot>   8
10:47:24 <pascha> @src partial
10:47:24 <lambdabot> Source not found. Maybe you made a typo?
10:47:51 <ski_> typoclass : however, typically we use curried functions (not tupled ones) to encode multi-argument functions, in Haskell, and then we can say "`r :: a -> b -> c' is curried" as a shorthand
10:48:35 <pascha> @src uncurry
10:48:35 <lambdabot> uncurry f p = f (fst p) (snd p)
10:48:38 <ski_> > let myadd (a,b) = a + b in map (curry myadd 5) [0,3,6]
10:48:39 <lambdabot>   [5,8,11]
10:48:58 <pascha> > uncurry (*) (7,8)
10:48:59 <lambdabot>   56
10:50:43 <pascha> > uncurry (*) (7,8)
10:50:45 <lambdabot>   56
10:51:37 <pascha> > foldr ((+) . uncurry (*)) 0 [(1,2),(3,4)]
10:51:39 <lambdabot>   14
10:51:59 <pascha> > foldr ((+) . uncurry (*)) 0 [(1,2),(3,4),(5,6),(7,8)]
10:52:01 <lambdabot>   100
10:57:36 <ski_> that `curry' (in Haskell) can (easily) be used both for converting a tupled function-of-multiple-arguments into a corresponding curried function-of-multiple arguments, and for partially applying a tupled function-of-multiple-arguments on an argument is due to the fact that since the function `curry' itself is encoded in a curried way in Haskell, you can use it in two (main) ways :
10:58:04 <ski_> (a) `curry f', `curry' considered as a function taking one argument (a tupled function-of-multiple-arguments), and returning a curried function-of-multiple-arguments
10:58:14 <ski_> (b) `curry f x', `curry' considered as a function taking two arguments (a tupled function-of-multiple-arguments, and an argument) and returning a partially applied function
10:59:00 <finishingmove> is there something like printLn that i can use in GHCi ?
10:59:22 <Philonous> finishingmove:  putStrLn ?
10:59:28 <ski_> (you could of course, if you wanted to, also consider `curry' as a curried function taking three arguments -- but why write `curry f x y' when you can just write `f (x,y)' ?)
10:59:41 <dmwit> print?
11:00:05 <Philonous> finishingmove:  print = putStrLn . show
11:00:09 <djahandarie> finishingmove, technically, ghci will simply show any string values so you don't neccessarily need to do anything at all.
11:00:40 <ski_> typoclass : did any of what i said make any sense ? -- or perhaps you're too bored of the issue to think about it now ? :)
11:01:00 <finishingmove> what if i wanted to map a function to a list, that prints out the element
11:01:07 <finishingmove> ?
11:01:20 <ski_> how can a list print out an element ??
11:01:56 <typoclass> ski_: i don't know. it doesn't sound immediately convincing to me, but let me think about it for a while :-)
11:02:11 <ski_> finishingmove : perhaps you meant to apply a printing function to each element in a list ? -- like `mapM_ putStrLn strings' or `mapM_ print elements' ?
11:03:03 <djahandarie> finishingmove, well, if I understand your question correctly... map putStrLn ["a", "b", "c"] will give you a list of IO actions, and then you can combine them into a single action with sequence:  sequence $ map putStrLn ["a", "b", "c"]
11:03:22 <anthezium> hello
11:03:27 <Mortchek> :i mapM_
11:03:31 <finishingmove> something like that yeah
11:03:43 <djahandarie> And mapM will simply do the sequence and the map all in one go
11:03:47 <djahandarie> :t mapM
11:03:49 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:04:04 <djahandarie> :t \f -> sequence . map f
11:04:05 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
11:04:17 <djahandarie> Stupid variable renaming
11:04:20 <anthezium> I'm trying to create a monoid instance for a type that wraps another monoid instance
11:04:30 <anthezium> i can't figure out the syntax
11:04:33 <anthezium> right now it looks like
11:04:43 <anthezium> https://gist.github.com/anthezium/5356960
11:04:47 <ski_> typoclass : apart from how simple the concrete syntax for function application is in Haskell, and for some syntactic sugar (`\x y -> ...' instead of `\x -> \y ->', and `f x y = ...' instead of `f = \x y -> ...'), Haskell functions (in this respect) behave basically like functions in most other well-known programming languages that support returning functions from functions
11:04:48 <anthezium> but i'd like something like
11:05:03 <Mortchek> @src mapM_
11:05:03 <lambdabot> mapM_ f as = sequence_ (map f as)
11:05:54 <anthezium> https://gist.github.com/anthezium/5356999
11:06:35 <pascha> @type ((+) . uncurry (*))
11:06:36 <lambdabot> Num b => (b, b) -> b -> b
11:07:03 <ski_> typoclass : one difference is that many of those other languages have a primitive concept of "multi-argument function" in the language (which Haskell doesn't have) -- but you don't *have* to use that when you encode your (informal / intuitive) multiple-argument functions into the language
11:07:06 <pascha> > ((+) . uncurry (*)) (3,4) 5
11:07:08 <lambdabot>   17
11:08:43 <finishingmove> how would i get a square of a number? without defining my own function.. is there some function for that or an idiomatic way to use * ?
11:08:49 <Mortchek> anthezium, did you know there's a Monoid instance for (a, a)?
11:08:57 <quchen> finishingmove: (^2)
11:08:59 <ski_> typoclass : so, it's about conventions (partially language-favored such) for how to encode multiple-argument functions
11:09:01 <typoclass> ski_: yeah ... but just to be sure, those tiny bits of syntactic sugar are as important as anything. nobody would be happy if we had to write "\x y -> x + y" as "function (x) { return function (y) { return x + y;};}"
11:09:05 <ab9rf> finishingmove: join (*)
11:09:08 <pascha> > 3^2
11:09:10 <lambdabot>   9
11:09:14 <ab9rf> join (*) 3
11:09:19 <ab9rf> > join (*) 3
11:09:21 <lambdabot>   9
11:09:22 <anthezium> Mortchek: yeah
11:09:25 <Mortchek> Err, sorry - (Monoid a, Monoid b) => Monoid (a, b)
11:09:26 <pascha> ab9rf: why not ^``
11:09:29 <pascha> ?
11:09:32 <finishingmove> ah ofc...
11:09:32 <ab9rf> pascha: you can do that too :)
11:09:35 <anthezium> i guess i'm pretty much reimplementing that
11:09:36 <Mortchek> but then you can specialize that
11:09:38 <pascha> @src join
11:09:39 <lambdabot> join x =  x >>= id
11:09:46 <finishingmove> i tried (^) and expected it to work, so i was confused afterwards
11:09:47 <ab9rf> pascha: like there's only one way to do something in haskell :)
11:09:54 <pascha> i dont get join
11:09:59 <pascha> @type join
11:10:01 <lambdabot> Monad m => m (m a) -> m a
11:10:03 <djahandarie> join, exactly the function you want to use when teaching someone how to square a number
11:10:04 <ab9rf> (^) has some difficult semantics
11:10:07 <ski_> typoclass : e.g. SML doesn't have a primitive in-language concept of "multiple-argument function", and does have the above sugar that i mentioned, but *still* many of the functions in the standard library are written (encoded) in the "tupled" style, and *not* in the "curried" style
11:10:13 <ab9rf> djahandarie: hee
11:10:20 <pascha> which monad is (*) 3 ?
11:10:26 <c_wraith> ski_: that sounds terrible
11:10:36 <pascha> @type ((*) 3)
11:10:37 <ski_> typoclass : indeed (hence the "language-favored conventions" bit)
11:10:37 <lambdabot> Num a => a -> a
11:10:40 <ab9rf> pascha: the monoid of integers with multiplication
11:10:47 <supki> anthezium: did you try your second paste?
11:10:47 <anthezium> Mortcheck: so i guess i should just look at the tuple instance and see how they do it or wrap it in a newtype or something
11:10:58 <anthezium> supki: yeah it's like o no this is recursive
11:11:00 <Philonous> pascha:  It's not a monad
11:11:02 <anthezium> i'll try it in isolation
11:11:07 <pascha> > let f = ((*) 3) in f 3
11:11:09 <lambdabot>   9
11:11:09 <ab9rf> :t join
11:11:11 <lambdabot> Monad m => m (m a) -> m a
11:11:14 <supki> anthezium: how is it recursive?
11:11:23 <ski_> c_wraith : at the time, the available implementations implemented functions in the tupled style more efficiently than in the curried style -- however, this has changed (and hence, preferences as well)
11:11:25 <anthezium> it thinks it's the wrong mempty
11:11:34 <anthezium> just a sec i'll get the error
11:11:39 <monochrom> pascha means: which monad does (*) 3 belong to
11:11:41 <supki> that's strange, it should work
11:11:49 <ab9rf> pascha: one of the strange idioms in haskell is that join f x is the same as f x x
11:12:00 <ski_> c_wraith : also, `map' and some (but not all) other common higher-order functions that are commonly partially applied are still present in the curried style in the standard library
11:12:13 <ab9rf> so you can get squaring by joining (*) to get a function that multiplies its argument by itself
11:12:30 <c_wraith> ski_: do they just use a combinator like "curry" all the time, then?
11:12:49 <hpaste> supki pasted ‚Äúfor anthezium‚Äù at http://hpaste.org/85561
11:12:54 <ab9rf> :t (^2)
11:12:55 <lambdabot> Num a => a -> a
11:13:10 <djahandarie> It's not so much an idiom. Just the canonical (r ->) Monad instance.
11:13:30 <ab9rf> djahandarie: true enough, but if you don't knw what a monad is.... :)
11:13:39 <bartavelle> I tried the rmonad package, but they do not document the set of extensions to be enabled (kind of brute forced this), the example in http://hackage.haskell.org/packages/archive/rmonad/0.8/doc/html/Control-RMonad.html is wrong (constraints doesn't have an argument), and I still don't have my Hashable thingie :(
11:14:02 <bartavelle> using this library is non obvious
11:14:26 <Philonous> pascha:  the join in (join (*) 3) is the join from the ((->) r) or reader monad
11:14:41 <ski_> c_wraith : for which cases ?
11:15:05 <djahandarie> @type \(f::a->a->c) -> join f
11:15:06 <lambdabot> (a -> a -> c) -> a -> c
11:15:07 <pascha> @type join
11:15:08 <lambdabot> Monad m => m (m a) -> m a
11:15:14 <ab9rf> @src join
11:15:14 <lambdabot> join x =  x >>= id
11:15:15 <LOGAN> hello, im installing haskell because I found a source I need to compile, how easy would that be for a lamer like me? :D
11:15:16 <c_wraith> ski_: oh, I totally misread what you said.  Nevermind.
11:15:19 <anthezium> supki: You're right, it does work :)
11:15:20 <ski_> c_wraith : though, i *think* (in case they need to), they more commonly write an explicit lambda than use a `curry' function
11:15:24 <pascha> > join Just (Just 6)
11:15:26 <lambdabot>   Couldn't match expected type `a1 -> a0'
11:15:26 <lambdabot>              with actual type `Data...
11:15:36 <pascha> > join (Just (Just 6))
11:15:37 <lambdabot>   Just 6
11:15:38 <ab9rf> > join $ Just $ Just 6
11:15:40 <lambdabot>   Just 6
11:15:57 <anthezium> Mortchek: Thanks
11:15:58 <c_wraith> > join $ Just Nothing
11:15:59 <anthezium> supki: Thanks
11:16:00 <lambdabot>   Nothing
11:16:05 <pascha> @src (>>=)
11:16:05 <lambdabot> Source not found. Wrong!  You cheating scum!
11:16:07 <supki> anthezium: np :)
11:16:16 <pascha> @src joi
11:16:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:16:18 <pascha> @src join
11:16:18 <lambdabot> join x =  x >>= id
11:16:22 <Philonous> pascha:  (>>=) is a member of the Monad class
11:16:24 <djahandarie> pascha, >>= has a different definition per mOnad.
11:16:28 <pascha> @type (>>=)
11:16:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:16:41 <c_wraith> That definition of join is entirely too clever.
11:16:56 <Philonous> c_wraith:  Is there another one?
11:17:06 <ab9rf> @quote fugue
11:17:06 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:17:07 <LOGAN> hmm wait, does haskell have an IDE?
11:17:14 <elliott> LOGAN: there is Leksah
11:17:21 <Taneb> And eclipse-fp
11:17:22 <ski_> @src Maybe (>>=)
11:17:22 <lambdabot> (Just x) >>= k      = k x
11:17:23 <lambdabot> Nothing  >>= _      = Nothing
11:17:24 <c_wraith> Philonous: only ones that are equivalent but less clever.  \x -> do { x' <- x ; x' }
11:17:26 <ski_> pascha ^
11:17:34 <pascha> > (>>=) (Just (Just 6))
11:17:35 <ab9rf> LOGAN: there are several IDEs for haskell.  leksah, eclipse-fp, and emacs are probably the most commonly used.
11:17:36 <lambdabot>   *Exception: show: No overloading for function
11:17:50 <LOGAN> as I downloaded a source on windows and installed haskell, now I wonder how to compile the source :)
11:17:51 <pascha> > (>>=) (Just (Just 6)) id
11:17:52 <lambdabot>   Just 6
11:18:03 <ab9rf> LOGAN: ghc file.hs
11:18:06 <LOGAN> normally I use notepad++ for editing
11:18:14 <pascha> @type id
11:18:16 <lambdabot> a -> a
11:18:24 <pascha> how can id be (a -> m b) ?
11:18:25 <Philonous> c_wraith:  Less clear, rather. And syntactic sugar causes cancer in the semi-colon.
11:18:29 <pascha> when it is not :)
11:18:36 <ski_> pascha : unify `a' and `m b'
11:18:39 <ab9rf> LOGAN: i use notepad++ a lot for haskell, works fine.  but change the options that makes it replace tabs with spaces, otherwise layout issues will drive you batty.
11:18:41 <monochrom> id can be m b -> m b, you know
11:18:52 <pascha> aha
11:19:09 <Philonous> Heh, I remember wondering about that same thing myself.
11:19:41 <monochrom> if you like tabs, change it to "8", it is the next best thing
11:19:47 <ski_> learning a little Prolog logic variable unification to understand how types with type variables unify can be useful
11:19:54 <LOGAN> I used rightclick open with ghci and now I see window prelude>
11:20:01 <ab9rf> ski_: ugh, that brings back memories
11:20:06 <ski_> how so ?
11:20:20 <djahandarie> mgsloan, you're in Hawaii?
11:20:36 <monochrom> unification can be learned without prolog. in fact, every highschool algebra students are supposed to learn it
11:20:44 * djahandarie agrees with monochrom
11:21:17 <Philippa> monochrom: wait, you can have equations on things that aren't numbers?!
11:21:30 <sproingie> i learned unification writing a unification pattern matcher in emacs lisp
11:21:40 <ab9rf> ski_: i tried to learn prolog about 20 years ago :)
11:21:42 <Philippa> (exactly the way I taught it last time I did, of course)
11:21:48 <ab9rf> ski_: never got very good at it
11:21:48 <sproingie> took it from an old lisp tutorial.  it used maclisp so it managed to work in elisp too
11:22:04 <hpaste> bartavelle pasted ‚Äúrmonad test‚Äù at http://hpaste.org/85562
11:22:12 <bartavelle> if somebody has a clue on how to make this work
11:22:14 <bartavelle> I am interested
11:22:15 <ab9rf> for me it was some exercise in the dragon book that finally made it make sense (type unification, of course)
11:22:25 <ski_> monochrom : yes, though i think they are more supposed to learn it implicitly (in the sense of deriving correct answers), not necessarily explicitly
11:22:29 <sproingie> i never could get through the dragon book
11:22:29 <edwardk> preflex: xseen sclv
11:22:29 <preflex>  sclv was last seen on freenode/#haskell-lens 4 hours, 51 minutes and 45 seconds ago, saying: @tell edwardk an extremely cache-aware approach -- http://continuum.io/blog/blz-format
11:22:31 <mgsloan> djahandarie: Ayup!
11:22:39 <ski_> ab9rf : Prolog is lots of fun :)
11:22:42 <bartavelle> I suppose I didn't sprinkle the right list of extensions
11:22:54 <sproingie> dragon book dove into things like LALR(1) almost immediately and i felt stupid for not being able to follow it
11:23:01 <ab9rf> ski_: i managed to write a mastermind game with it
11:23:06 <ab9rf> ski_: but never anything more interesting
11:23:13 <ab9rf> ski_: i think i did n queens, too.
11:23:17 <mgsloan> djahandarie: It's pretty great here, though the Coqu√≠ frogs are going to take getting used to
11:23:21 <ab9rf> ski_: but everyone does n queens :)
11:23:24 <simpson> sproingie: Have you seen dash's Pycon talk on parsing?
11:23:30 <Philippa> sproingie: *nod*. It's... very much of its time, amongst other things
11:23:35 <simpson> sproingie: The Dragon Book is *not* the best way to learn parsers.
11:23:42 <ab9rf> simpson: no, it's not :)
11:23:50 <djahandarie> The nicest way to understand unification is the structurally recursive unification algorithm
11:23:54 <sproingie> simpson: as i learned later.  unfortunately, at the time, everyone was saying it was *THE* way
11:23:57 <ab9rf> simpson: but if you survive it, you will know them :)
11:24:12 <Philippa> eh, I don't recall it being that hot on LL methods
11:24:15 <ab9rf> i've written three LALR parsers by hand
11:24:34 <simpson> ab9rf: But who wants to know LALR(k) and CFG when you could know PEGs instead?
11:24:37 <Philippa> admittedly you get a different class of "knowing parsers" around #haskell
11:24:40 <ab9rf> Philippa: no, the dragon book dismisses LL parsers fairly quickly and spends two chapters on LALR
11:24:58 <Philippa> simpson: there're some good reasons to be wary of PEGs still
11:25:09 <sproingie> i found the tiger book by appel much more approachable
11:25:19 <simpson> Philippa: Yeah, but over in Python-land, where the memory usage is made-up and speed doesn't matter, we're enjoying them. :3
11:25:19 <djahandarie> mgsloan, nice... one day I will leave Connecticut, that'll be the day
11:25:24 <Philippa> *nod*. The tiger book's good, even if you don't know ML where you go in
11:25:30 <ski_> sproingie : that one is nice, yes
11:25:38 <Philippa> simpson: neither of those're the reasons I have in mind
11:25:45 <ab9rf> hehe
11:25:48 <c_wraith> My compilers course ran on a variant of the tiger book that assumed implementing in java.
11:25:53 <sproingie> Philippa: actually i got the red tiger book, which uses java.  astonishingly it still does well with it
11:25:55 <Philippa> Parsec pretty much nets you higher-order PEGs, but there're still ways to trip yourself up
11:26:03 <c_wraith> java is not a good language to implement a compiler in
11:26:16 <Philippa> c_wraith: that's an understatement and a half
11:26:17 <ab9rf> i thought the big problem with PEGs is that they can easily descend into exponential hell, and controlling this is challenging
11:26:26 <c_wraith> But yeah, the material does transcend the implementation language, in this case
11:26:33 <c_wraith> the tiger book's material was still excellent
11:26:33 <ab9rf> c_wraith: i haven't found amything for which java is a good language to implement it in
11:26:36 <sproingie> meh.  it's a good enough language to start a language that you bootstrap to its own compiler
11:26:37 <Philippa> ab9rf: packrat parsing helps there, but they're still a PITA to analyse
11:26:44 <simpson> Philippa: I would love to hear about the problems with PEGs.
11:27:08 <companion_cube> what are PEG?
11:27:15 <Philippa> simpson: left-biased choice meets the same problems CFGs give you for general analysis - it becomes hard to know you're parsing the language you think you are
11:27:17 <c_wraith> Partial Expression Grammars
11:27:19 <sproingie> wish i still had my copy of the tiger book :p
11:27:25 <mgsloan> djahandarie: Yup!  Well, I'm only here for a week
11:27:29 <sproingie> tho i might snag the ML one now
11:27:30 <ski_> c_wraith : i think the course here let the students choose language (assuming "reasonable choice") -- i bought the ML version book (before taking the course), since it looked interesting, and i was more interested in ML than in C or Java ..
11:27:32 <companion_cube> is it new?
11:27:39 <ab9rf> companion_cube: 1970s
11:27:42 <companion_cube> :D
11:27:44 <ab9rf> companion_cube: so, no :)
11:27:46 <companion_cube> ok, my bad
11:27:56 <simpson> Philippa: Ah, yes. Have you seen ometa's answer for this? Basically, all left recursion is memoized hard, and any detected left recursion fails if it hasn't advanced in the input stream.
11:28:06 <ab9rf> companion_cube: to be fair, i hadn't heard of them either
11:28:20 <Philippa> simpson: that's cute, but it doesn't solve the general problem
11:28:23 <companion_cube> I heard of this recently, but didn't pay much attention
11:28:27 <c_wraith> That's ok..  When's the Early parser date back to? the 50s?
11:28:34 <c_wraith> How many people know anything about it?
11:28:38 <simpson> Philippa: Yeah, I guess we just gave up on the general problem. :c
11:28:50 <sproingie> havent heard of ometa in a while ... wonder where STEPS is at these days?
11:28:50 <c_wraith> *Earley
11:28:56 <Philippa> simpson: yeah, I suspect it's provably intractable
11:29:22 <Philippa> now, you can do some fun things with visibly pushdown languages, but I never did sit down and bash out the analyses I wanted
11:29:22 <simpson> Philippa: Stupid undecidability ruining our fun. :c
11:29:46 <Philippa> which is a shame, because Haskell gives us good ways to talk about doing what'd normally be 'hacky' things on top of them in a principled manner
11:29:46 <klrr> do i have to return a monad instead of a normal type the return value is supposed to be of type Either?
11:29:51 <ab9rf> PEGs use a lot of memory (or a lot of time, if you don't packrat); they have issues with left recursion; getting grammars that are fundamentally ambiguous to be nonambigious can be difficult or lead to difficult-to-predict mis-parses
11:30:32 * ski_ thinks we probably need static analysis for choice, so you can have both unbiased choice and efficiency (or know when you don't have it)
11:30:36 <ab9rf> the last is a problem in all parsers, but LR parsers are usually fairly easy to disambiguate in a manner that is predictable
11:30:44 <Philippa> mmm. That's the appeal of visibly pushdown for me: it should be possible to figure out how much lookahead you need where for them
11:31:18 <Philippa> a lot of tricks for regular languages extend cleanly to them
11:31:32 <klrr> when i write a function that return a Either, do i need to use "return" ?
11:31:32 <LOGAN> hmm I think ill ask the original coder to supply a compiled version. maybe he knows how to compile it
11:32:20 <typoclass> klrr: nope, you just need to do "f ... = Left 42" or "f ... = Right 123"
11:32:39 <LOGAN> root folder has setup.hs, then the src subfolder has some stuff. but im to noob to simply know what to compile and how
11:33:28 <klrr> typoclass: hmm, but what happens if you use (return)? does it automatically becomes a Either?
11:34:15 <ab9rf> @src Either return
11:34:15 <lambdabot> return        = Right
11:34:29 <ab9rf> that's what happens if you use return in a function that returns an Either :)
11:34:30 <LambdaDusk> what are my options when I commited a patch to a package but the owner does not update it on hackage or react to my pleas?
11:34:30 <klrr> okey thanks ab9rf
11:34:52 <ab9rf> LambdaDusk: contact the media
11:34:54 <typoclass> klrr: well, return in haskell is not what you expect from other languages. you don't write it in every function to give something back. you just do "f x = result", not "f x = return result"
11:35:11 <ab9rf> LambdaDusk: belittle the package maintainer on twitter
11:35:34 <LambdaDusk> let's skip that
11:35:39 <ab9rf> LambdaDusk: heh
11:35:49 <LambdaDusk> mostly because I am serious here =/
11:36:13 <djahandarie> LambdaDusk, what package?
11:36:14 <typoclass> LambdaDusk: there's a procedure for taking control of a package. i don't recall the details, i think it involves posting to -cafe
11:36:17 <ab9rf> LambdaDusk: ask around, find out if the maintainer is still alive and interested?
11:36:47 <klrr> typoclass: i dont know other languages me new idiot :)
11:37:01 <klrr> also is this statement correct? data is functions, functions is data
11:37:17 <LambdaDusk> it's this package: http://hackage.haskell.org/package/Hipmunk
11:37:43 <typoclass> klrr: it's ok :-) i just wanted to make sure, because it can be confusing
11:37:44 <LambdaDusk> it imports a module that has been changed in GHC 7.6 so I can't compile it there
11:38:01 <djahandarie> LambdaDusk, http://www.haskell.org/pipermail/libraries/2011-May/016397.html is worth reading if you want to consider taking over the package
11:38:01 <Philippa> klrr: not in Haskell, for a couple of reasons - 1) we have data-that-isn't-functions, 2) we often use 'data' to mean "[generalised] algebraic datatypes"
11:38:13 <typoclass> klrr: that statement sounds very abstract and weird :-/
11:38:37 <LambdaDusk> djahandarie: I don't really want to take responsibility for it, I merely want to be able to put it as a dep on my project =/
11:39:00 <djahandarie> You can do a non-maintainer upload instead of taking over
11:39:15 <djahandarie> But again only if the maintainer is totally unaccessable
11:39:24 <djahandarie> (Or totally uninterested)
11:39:30 <ab9rf> 'data is functions, functions is data' seems pithy and fails to relaly capture any useful statement
11:40:03 <djahandarie> 'all functions are values, not all values are functions'
11:40:09 <Philippa> it's the sort of thing people who're getting high on the untyped lambda calculus or lisp say
11:40:22 <djahandarie> Pass the untyped lambda calculus bong
11:40:44 <typoclass> "i have a ghc available at runtime. all data is functions!"
11:40:46 <LambdaDusk> djahandarie: I dunno, tried to email them but no reaction, so I guess they not interested...
11:41:16 <ab9rf> in a way 'data is functions, functions is data' just means you have a von neumann architecture instead of a harvard architecture :)
11:41:16 <klrr> typoclass: Philippa: what i mean is that they both have very similiar properties, they're all curried etc. a type also can have args etc.
11:42:14 <djahandarie> LambdaDusk, there has been an upload in the past year so I'd definitely give them a few weeks and then announce somewhere publically that you're doing the non-maintainer upload
11:42:18 <Philippa> klrr: data constructors are functions, yes. And there are definite similarities between the term and type levels
11:42:29 <Philippa> (there are even languages that unify their syntax but still have a typing relation)
11:42:46 <LambdaDusk> djahandarie: I sent the patch in 3 weeks ago =/
11:43:40 <ab9rf> LambdaDusk: could be on vacation
11:43:51 <djahandarie> LambdaDusk, send another email like 'since you don't seem to responding, I will do a non-maintainer upload to Hackage to fix this bug, please respond within 2 weeks if you're still alive and kicking'
11:43:53 <typoclass> klrr: yeah, Philippa is right. many things are functions or look like functions. i'd call that 'functional programming language', but not 'all data is functions', nor 'everything is a function' :-)
11:44:08 <djahandarie> I hate the term 'functional programming language'
11:44:14 <djahandarie> Really, who came up with that and what's their address!
11:44:18 <ab9rf> djahandarie: i prefer dysfunctional programming languages
11:44:35 <monochrom> I think he is dead
11:45:11 * typoclass purrs at djahandarie
11:45:12 <ab9rf> probably murdered by an imperativist.
11:47:03 <djahandarie> Value-oriented programming would be closer I think
11:47:21 <djahandarie> But we have types too! And some other things. So who knows.
11:47:36 <LambdaDusk> I propose a result-oriented programming language
11:47:39 <typoclass> djahandarie: hm, interesting suggestion
11:47:54 <LambdaDusk> would be a new thing
11:48:14 <klrr> is haskell the only truth?
11:48:22 <typoclass> djahandarie: though that would probably apply as much to OO languages. "values are objects, many (or all) things are objects", etc.
11:48:34 <zomg> klrr: no, also scientology
11:48:46 <klrr> i know haskell is a scam
11:48:52 <monochrom> yes
11:48:57 <klrr> simon peyton jones doesnt even have phd
11:49:00 <klrr> :P
11:49:02 <klrr> i think
11:49:17 <monochrom> actually, Tony Hoare doesn't either
11:49:21 <klrr> MUHAHAHAH ive uncovered the secret, haskell is actually created by java programmers
11:49:47 <klrr> mega corporation will take over everything, oracle will destroy the world
11:49:49 <djahandarie> He's an honorary profressor though, I think that outranks having a PhD.
11:49:57 <klrr> djahandarie: i know ^^
11:50:05 <klrr> how do you become a professor btw?
11:50:11 <klrr> (also sry for trolling before)
11:50:34 <typoclass> klrr: it's ok, it was clear it was humorous
11:52:16 <klrr> typoclass: good, i get a bit oversteer sometimes sry, i think it's something wrong with my brain
11:52:36 <monochrom> every error is something wrong with the brain
11:52:46 <LambdaDusk> @faq can haskell solve all problems of the world?
11:52:47 <lambdabot> The answer is: Yes! Haskell can do that.
11:52:48 <monochrom> I used to say, debug your brain, not your program
11:53:09 <djahandarie> Why'd you stop?
11:53:44 <monochrom> because I have lost hope. people refuse to debug their brains.
11:54:44 <ab9rf> brains are nonrestartable anyway
11:55:28 <ab9rf> typoclass: i was actually thining of smalltalk back a bit, because in smalltalk absolutely everything is an object.
11:55:47 <typoclass> ab9rf: yeah, that's the example everyone has for "everything is an object"
11:56:03 <Ontolog_> so i have 3 functions that work together but are separate. they all share a large chunk of their where clause though. is there a way to DRY up the where clause?
11:56:04 <ab9rf> typoclass: the problem with languages in which everything is an X, is that typically you end up with performance penalties from being too flexible.
11:56:31 <amiller> kosmikus, i just now realized that most of what i've been using for the last while is a watered down version of multirec
11:56:37 <typoclass> Ontolog_: move it to top level in your module? stick it all in its own module if necessary
11:56:39 <amiller> i think i'd gain a lot by switching over to multirec
11:56:49 <Ontolog_> typoclass: what's it?
11:56:53 <amiller> and in particular i think you have a solution to one of the problems i have specifically
11:57:07 <amiller> but i had a hard time my first go... i have two questions now
11:57:09 <typoclass> Ontolog_: the common part of the 'where' clause
11:57:30 <amiller> 1. is the extra layer of indexing necessary and if so how can i convert code that uses simpler hfunctors to using multirec
11:57:38 <Ontolog> typoclass: im not sure how that works
11:57:56 <amiller> let me give an example, the 'simpler' hfunctors i use are what are described here http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
11:58:09 <Ontolog> typoclass: i move them out of the where clause into the same scope as the function and it just all works?
11:58:10 <amiller> they're more complicated than the functors in Regular, but they're not the same as in multirec
11:58:19 <Ontolog> *functions
11:58:23 <amiller> data ExprF  :: (* -> *) -> * -> * where    and so on
11:58:29 <typoclass> Ontolog: i mean, if you have two functions which both have "where x = 42", you can also at the top level do "x = 42", right?
11:58:31 <Ontolog> i'll paste my shit so you can see
11:58:39 <typoclass> Ontolog: yup, thanks
11:59:58 <hpaste> Ontolog pasted ‚ÄúOntolog‚Äù at http://hpaste.org/85563
12:00:01 <amiller> ah this isn't coming out too clearly anyway.... anyway the second question is 2. for heterogeneous lists and serialization i keep wanting to have something where i can say define a Binary instance for all the indexes used in a gadt
12:00:34 <amiller> but i don't actually want to qualify over for all a of any possible haskell type, i only want to refer to the data family of types actually used, say Tree and Nat if say those are the two indexes i use in a gadt
12:00:47 <Ontolog> typoclass: it's the shits on the bottom
12:01:16 <amiller> is it possible to use type families or something to get that directly without needing the extra-structured hfunctor
12:02:13 * hackagebot debian 3.70.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.70.1 (DavidFox)
12:02:33 <Bitwich> join #bitcoin - we are aiming for 2,000 users... currently at 1,975
12:02:42 <klrr> TMUX FTW! MOTHADICK YEAH, good night foks'
12:03:08 <Ontolog> typoclass: yoyo don't leave me hanging bro
12:03:22 <typoclass> Ontolog: yes, looking at it
12:03:56 <Ontolog> typoclass: basically the 3 variables graphA, graphB and graphC
12:04:08 <Ontolog> typoclass: they are derived from the function input
12:04:28 <Ontolog> all in the same way
12:04:32 <Ontolog> but different functions
12:07:22 <hpaste> typoclass annotated ‚ÄúOntolog‚Äù with ‚ÄúOntolog (annotation)‚Äù at http://hpaste.org/85563#a85564
12:07:38 <typoclass> Ontolog: here's a suggestion. i suspect more could be done, but it's a start
12:08:25 <typoclass> Ontolog: ("g@(...)" means that you do the pattern match (...), but you can also refer to the entire thing with the name g)
12:10:24 <Ontolog> typoclass: interesting, i was hoping for something different though, like somehow being able to create a scope over a set of functions or something
12:10:55 <typoclass> Ontolog: yeah, a 'scope over some functions' is generally a module :-)
12:11:23 <Ontolog> typoclass: not like that :p i mean something else
12:12:00 <Ontolog> typoclass: how about this, if in the where clause of shortestPath, i define the other two functions (shortestPathFromA,B)
12:12:33 <Ontolog> typoclass: would those 'embedded' functions have access to the where definitions of shortestPath?
12:12:35 <typoclass> Ontolog: yeah that's a good idea. well done. if shortestPathFromA/B aren't called from anywhere outside
12:12:56 <Ontolog> typoclass: cool i'll try that
12:13:35 <Ontolog> typoclass: if i define them in the where clause, it can only happen as a lambda?
12:14:54 <typoclass> Ontolog: no, it's fine to do "where f x = x + 3"
12:15:43 <Ontolog> typoclass: sweeeeet
12:15:55 <Ontolog> i don't know where to find the right reference for my needs at this point
12:16:07 <Ontolog> like how where works, using the standard API docs its not clear that I could do that
12:22:37 <ab9rf> Ontolog: more than once i've written a function as function x y z = f x where f x = .... and a long string of stuff all in the where clause
12:23:40 <ab9rf> epsecially useful whe you want to return a function
12:23:49 <benzrf> hello!
12:23:55 <benzrf> variables are just syntactic sugar, right?
12:24:38 <alanz> I have a question about GHC.nameUnique for identifiers exported from one module and used in another. Does anyone know anything about this?
12:24:40 <ab9rf> benzrf: not sure what you mean by that
12:24:53 <Iceland_jack> benzrf: Not in Haskell, no
12:25:27 <ab9rf> local bindings are transient, and to that end you could call them "sugar", but i wouldn't tend to agree with that statement
12:25:37 <benzrf> well...
12:25:45 <ab9rf> writing haskell without variable bindings would be Hard.
12:25:48 <typoclass> benzrf: do you have an example?
12:25:59 <benzrf> using variables is basically just giving an expression an alias, right?
12:26:09 <ab9rf> no, not really
12:26:11 <benzrf> it adds no real functionality
12:26:14 <benzrf> oh
12:26:16 <benzrf> how so?
12:26:20 <ab9rf> @src fix
12:26:20 <lambdabot> fix f = let x = f x in x
12:26:26 <elliott> benzrf: you have to think about function arguments
12:26:31 <elliott> id x = x
12:26:36 <elliott> how can you write that without giving x a name?
12:26:38 <benzrf> true
12:26:50 <benzrf> I meant variables other than parameters I guess
12:26:55 <ab9rf> recursive bindings are specially hard to do without names
12:27:21 <benzrf> they are, but there's no actual adding of functionality at an abstract level, is there?
12:27:24 <ab9rf> benzrf: but that's basically the ony wya to bind a variable
12:27:28 <elliott> benzrf: in ab9rf's example, you can do: fix f = f (fix f), it's true that "let" is theoretically superfluous...
12:27:32 <typoclass> benzrf: it definitely is one use to give a name to expressions. if you couldn't do that, you'd get tired of the language very soon :-)
12:27:36 <elliott> but the let form is more efficient in practice because you get sharing
12:27:40 <elliott> and of course they are really convenient to have :)
12:27:52 <benzrf> not denying their usefulness
12:27:53 <benzrf> just asking if I understand it right :p
12:27:59 <ab9rf> we coud write everything in pointless form
12:28:05 <ab9rf> but that would rapidly become quite painful
12:28:07 <benzrf> yeah
12:28:18 <ab9rf> and harder to optimize
12:28:26 <elliott> well, you'd lose the ability to define the primitives that are used for point-free in haskell
12:28:27 <benzrf> but if I say x = [expr] and then use x elsewhere, that's no different from just using [expr] everywhere, right
12:28:44 <elliott> sure, assuming [expr] is non-recursive
12:28:45 <ab9rf> elliott: they'd have to be defined outside the language, at least some of them
12:28:45 <geekosaur> um
12:29:01 <elliott> (oh, my fix example still needs a binding. but it is a global binding.)
12:29:03 * geekosaur also points to the monomorphism restriction
12:29:07 <ab9rf> elliott: it would be a vaguely amusing but probably unproductive exercise to identify the minimal set that would have to be externally defined :)
12:29:09 <elliott> (a better example: you can define a recursive *type* instead)
12:29:10 <geekosaur> and MonoLocalBinds
12:29:16 <elliott> (giving you a fix that is non-recursive on the value level)
12:29:56 <ab9rf> geekosaur: good point
12:30:05 <ab9rf> if [expr] is polymorphic, it could be different in differen places
12:30:25 <ab9rf> bu binding it to a variable forces it to a monomorphic type (unless you've disabled the monomorphic restriction)
12:41:09 <Ontolog> ab9rf: can those functions defined in your where clause have their own where clause?
12:43:43 <pascha> do you actually learn anything about networking by writing a webapp?
12:44:03 <Ontolog> pascha: no
12:44:13 <pascha> do you learn anything about tcp/ip if you write a webserver? I assume you must...?
12:45:07 <typoclass> pascha: the question is also what you want to know about tcp/ip
12:48:28 <ab9rf> Ontolog: not normally.
12:48:43 <ab9rf> pascha: you will learn a bit about networking, but probably not much.
12:49:05 <Clint> you might not even learn anything about http
12:49:07 <ab9rf> pascha: most webapps use OS-level abstractions that avoid exposing any of the deep details of TCP/IP to the developer
12:51:27 <armlesshobo> pascha: tcp is it's own protocol. any webapp you write might make use of it, but you wouldn't necessarily need to know anything about it.
12:55:25 <ab9rf> pascha: you won't need to know about any of the complicated stuff that i get paid to do :)
12:55:46 <ab9rf> it's unlikely you'll need to understand even so much as what a sequence number is
13:00:44 <mauke> even if you're writing a network program that deals with sockets, all you really need to know is that a socket connection is like a pipe that goes over the internet
13:03:30 <uvelichitel> unix socket not about internet, seems
13:03:51 <mauke> what?
13:04:19 <sipa> unix sockets are local
13:04:28 <mauke> well, duh
13:04:42 <uvelichitel> seems, unix socket just like a file
13:04:57 <Botje> very much so.
13:05:08 <mauke> yes, a unix socket uses a file instead of a network port
13:05:32 <mauke> also, I was implicitly referring to stream sockets, not datagram
13:12:58 <adamh> Hi again all
13:18:07 <oab> strange, the CPP was messing up a multi line string
13:20:29 <oab> oh it's a known problem too
13:20:57 <oab> and not strange at all
13:21:14 <ab9rf> mauke: a unix socket does not use a file.  it uses a socket.
13:22:04 <mauke> ab9rf: sockets are files
13:22:13 * Mrblue -- Meet the GooBot #goo --
13:22:38 <ab9rf> mauke: no, they're not files.  they're inodes, but that doesn't make them files.
13:23:25 <mauke> ab9rf: what's your definition of "file"?
13:24:17 <ab9rf> mauke: using the filesystem namespace to identify sockets does not make them files
13:24:50 <mauke> ab9rf: what's your definition of "file"?
13:25:16 <ab9rf> mauke: a stored byte stream contained on a block storage device.
13:25:20 <shachaf> mauke: Why didn't you just ask that in the first place?
13:25:24 <ab9rf> (in this context)
13:25:32 * geekosaur sides with ab9rf, actually; most systems with AF_LOCAL sockets in the filesystem require use of connect()/bind(), not open()
13:25:46 <ab9rf> geekosaur: they also have a different "type" code in the inode
13:25:47 <mauke> geekosaur: how is that relevant?
13:25:52 <mauke> shachaf: why would I?
13:25:57 <ab9rf> they don't have backing store into the file system
13:26:08 <ab9rf> the file system is only used for naming, not for storage
13:26:36 <mauke> ab9rf: so what do you call the things you see with 'ls'?
13:26:37 <geekosaur> mauke, also a socket node becomes unusable once the thing bound to it goes away; it must be removed to be rebound
13:26:43 <ab9rf> mauke: directory entries
13:26:56 <ab9rf> mauke: or file system objects
13:27:01 <geekosaur> mauke, most things in the filesystem at least try to act like files (directories being an exception on some but not all OSes)
13:27:02 <ab9rf> mauke: what do you call /dev/null?
13:27:02 <mauke> even if they're not actually part of a directory?
13:27:05 <ab9rf> it's not a file
13:27:10 <mauke> a device file
13:27:15 <geekosaur> I cannot use file operations on a socket node at all
13:27:17 <ab9rf> it's a character special device
13:27:19 <ab9rf> it is not a file
13:27:24 <mauke> geekosaur: unlink()
13:27:38 <geekosaur> so unlink is your definition of a file?
13:27:40 <mauke> ab9rf: I reject your definition
13:27:49 <ab9rf> mauke: you're welcome to do so :)
13:27:50 <geekosaur> mauke: I reject your definition
13:27:55 <ab9rf> mauke: i reject yours :)
13:28:04 <mauke> geekosaur: no, more like "I can use ls and rm with it"
13:28:05 <ab9rf> mauke: how much kernel programming have you done? :)
13:28:09 <mauke> ab9rf: none
13:28:17 <geekosaur> also: rename() and unlink() don;t actually operate on the node, they operate on the directory
13:28:19 <ab9rf> mauke: i started in 1985
13:28:40 <ab9rf> geekosaur: well, unlink actually affects the inode
13:28:50 <mauke> ab9rf: cool story, bro. do you know what 'man null' says on my system?
13:28:57 <ab9rf> geekosaur: it decrements the ref count, and if that causes it to drop to zero the file system deallocates the inode and any backing blocks
13:29:01 <geekosaur> yes
13:29:17 <geekosaur> also it updates ctime in any case (because the link count changed)
13:29:34 <ab9rf> mauke: shrug, i don't care what some manual author said
13:29:49 <mauke> "Data written to a null or zero special file is discarded."
13:29:49 <ab9rf>  /dev/null is a character special device.  it doesn't even have an inode.
13:30:00 <mauke> "Reads from the null special file always return end of file (i.e., read(2) returns 0)"
13:30:01 <geekosaur> it doesn't, however, support the "file API" but requires a different one
13:30:08 <geekosaur> I had the same issue with xenix name files
13:30:25 <ab9rf> geekosaur: yeah, the lower half driver for BSDs is different from FSOs
13:30:26 <geekosaur> completely different set of syscalls had to be used with them
13:30:46 <ab9rf> /dev/null isn't even a file syste object
13:31:02 <ab9rf> it's a directory entry that refers to device rather than an inode
13:31:22 <geekosaur> bzzt
13:31:23 <ab9rf> at least a named socket has an inode, just not any backing store
13:31:36 <geekosaur> directory entry is a map from a name to an inode
13:31:45 <geekosaur> a device node is an inode
13:31:52 <shachaf> Proposal: The word "file" is dangerous and no one should ever use it again.
13:31:56 <jamy_> http://youtu.be/ZhuHCtR3xq8
13:32:09 <ab9rf> geekosaur: hm, i'l hav eto pull my BSD ref man out, i don't think it's always been tht way
13:32:14 <ab9rf> shachaf: haha
13:32:22 <geekosaur> I would be surprised if BSD changed it that much
13:32:44 <geekosaur> BSDish directory entries hold a little more information, but only for directory entry accounting purposes
13:32:46 <ab9rf> geekosaur: somewhere i have the design and implenmentaiton of the unix operating system, frim 1985 :)
13:32:57 <geekosaur> a directory entry maps a name to an inode. this is how hard links work
13:33:20 <shachaf> And this book is relevant to knowing the True Meaning of the word "file"?
13:33:26 <geekosaur> you should be able to verify this directly, many bsds still allow a directory to be read as a file, you can od it
13:33:32 <shachaf> This sounds off-topic to me at this point.
13:34:12 <ab9rf> geekosaur: you're right mknod allocates an inode
13:34:17 <ab9rf> geekosaur: it's symlinks that don't have inodes
13:34:27 <geekosaur> no,symlinks also have inodes
13:34:44 <ab9rf> geekosaur: they were scribbled into the directory without an inode in at least one UNIX i used
13:34:46 <geekosaur> *hard* linksdon;t get extra inodes because they are names that point to the same single inode
13:35:01 <geekosaur> then they were not standard (i.e. BSD) symlinks
13:35:16 <ab9rf> geekosaur: wel, that's possible, i used to use HP-UX :)
13:35:31 <shachaf> This conversation should probably move to #-blah
13:35:35 <ab9rf> yes, hard links are the same inode
13:37:27 <fizbin> @hoogle [[a]] -> [a]
13:37:28 <lambdabot> Prelude concat :: [[a]] -> [a]
13:37:28 <lambdabot> Data.List concat :: [[a]] -> [a]
13:37:28 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
13:37:33 <ab9rf> oik
13:38:00 <fizbin> @type foldr union []
13:38:01 <lambdabot> Eq a => [[a]] -> [a]
13:41:57 <jamy_> About monads http://youtu.be/ZhuHCtR3xq8
13:42:59 <shachaf> jamy_: Yes, you mentioned.
13:48:22 <jamy_> Yes, but they realy good lesson. You should see this necessarily
13:56:32 <quchen> Is there some known issue when importing Data.ByteString and Network.HTTP at the same time? Getting this linker error: http://hpaste.org/85569
13:57:23 * hackagebot vector-space-map 0.1.0.1 - vector-space operations for finite maps using Data.Map  http://hackage.haskell.org/package/vector-space-map-0.1.0.1 (ChristianConkle)
13:57:52 <dmwit> quchen: Perhaps you are trying to load a different version of ByteString than Network.HTTP was built against for some reason. Or something like that.
13:58:11 <geekosaur> bytestring's a bootlib, no? that's a local cabal library
13:58:15 <dmwit> You might look into ghc-pkg check.
13:58:27 <dmwit> ByteString can be installed locally.
13:59:12 <dmwit> Ah, I see what you're saying. You're backing me up, and using the fact that it's installed locally as evidence that what I suggested may indeed be the problem. Right?
14:00:02 <quchen> That may be possible
14:00:32 <quchen> Just installed a new version of Aeson, maybe that shadowed the old ByteString?
14:00:58 <dmwit> That seems like a possibility.
14:01:37 <quchen> Hmpf. Time to learn how to clean this up then I guess.
14:02:24 <dmwit> It may be as easy as "cabal install aeson http".
14:02:31 <quchen> Ah yeah. ghc-pkg list shows two instances of Bytestring
14:02:32 <dmwit> Assuming Network.HTTP came from a package named http.
14:02:41 <dmwit> quchen: That in itself is not a problem.
14:03:01 * dmwit suggests ghc-pkg check again
14:04:24 <quchen> Lots of Haddock warnings
14:04:32 <quchen> (And nothing else)
14:04:46 <quchen> Tried installing HTTP, but didn't help :-/
14:05:22 <quchen> Or do I have to build them at the same time?
14:05:26 <quchen> i.e. issue a --reinstall
14:05:32 <dmwit> Yes, same time.
14:05:55 <dmwit> cabal install foo && cabal install bar is in general quite different from cabal install foo bar
14:06:27 <quchen> Oh.
14:06:56 <thirsteh> any easy way to round a UTCTime up to the nearest millisecond (so that Data.Time.Format.formatTime will only show e.g. .017 with %Q, or is there any way to truncate %Q beside something like reverse $ trunc $ reverse on the output?
14:07:15 <quchen> thirsteh: printf?
14:08:18 <dmwit> :t round
14:08:20 <lambdabot> (Integral b, RealFrac a) => a -> b
14:08:33 <dmwit> Ah, that Integral b constraint is a pain. =P
14:08:36 <dmwit> :t modf
14:08:37 <lambdabot>     Not in scope: `modf'
14:08:38 <lambdabot>     Perhaps you meant one of these:
14:08:38 <lambdabot>       `mod' (imported from Prelude), mod' (imported from Data.Fixed),
14:08:38 <dmwit> :t mod'
14:08:40 <lambdabot> Real a => a -> a -> a
14:08:53 <thirsteh> quchen: yeah, good point--my date is always the same length, so I can just 'take' the chars I need
14:09:07 <thirsteh> but obviously I would prefer if I weren't truncating
14:09:25 <ExternalReality> > let collection = [1,2,3]
14:09:27 <lambdabot>   not an expression: `let collection = [1,2,3]'
14:09:54 <quchen> ExternalReality: Use "@let definitions" (and maybe a private session)
14:10:45 <dmwit> thirsteh: Just pull out the utctDayTime, use mod', and stick it back in.
14:11:38 <thirsteh> dmwit: ah, nice! Thanks
14:11:45 <quchen> dmwit: If the reinstall didn't help, what's the next easier solution attempt?
14:12:04 <dmwit> I dunno! I'm not even 100% sure what's broken.
14:12:07 <aggd> I saw these two digramms for foldl/foldr at http://www.haskell.org/haskellwiki/Fold and I thought I came across a big picture containg these two diagramms and a lot more for other functions ... maybe someone can provides a link for this?
14:13:33 <dmwit> The Google Images results for "scanl haskell" are not what I expected.
14:13:41 <hpaste> anthezium pasted ‚Äúghc build broke‚Äù at http://hpaste.org/85571
14:13:50 <anthezium> oh that works
14:13:54 <anthezium> hey i'm trying to build ghc
14:14:02 <anthezium> i think i'm just missing some native library it links to
14:14:14 <anthezium> but idk which one it is, or even if that's the problem
14:14:28 <carter> alpounet would you be ok with scoutess dev being more github based?
14:14:44 <anthezium> it says it's missing link targets for things like "X86.Instr.JumpDest"
14:17:25 <donri> carter: it might be prudent to move to github and rewrite the thing without arrows to make things more approachable and encourage participation. personally i like darcs and arrows ;)
14:17:31 <donri> stepcut: thoughts?
14:17:40 <carter> whats the dig about arrows?
14:17:42 <donri> carter: we have a #scoutess channel btw
14:17:45 <carter> oh
14:18:09 <donri> carter: currently scoutess's api is based on Kleisli
14:18:22 <carter> so applicative would work too?
14:18:23 <Taneb> (I'm not familiar with scoutess, what is it in 10 words or fewer?)
14:18:31 <carter> its a build bot for cabalized things
14:18:41 <carter> that needs awee bit more love before being really used
14:18:42 <Taneb> ...right
14:18:48 <donri> carter: which suggests that the arrows don't really add anything technically, but the idea was that it makes the build recipes clearer, showing dependencies in the arrow syntax
14:18:55 <carter> ok
14:18:59 <carter> i've not really dug into it much
14:19:13 <carter> donri keep on being nerdsniped by higher priority near temr stuff
14:19:35 <donri> :)
14:20:10 <Guest13202> > mapM_ print [[1],[1,1]]
14:20:11 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:20:11 <lambdabot>    arising from a use of ...
14:21:26 <ExternalReality> :q
14:21:28 <ExternalReality> exit
14:21:31 <ExternalReality> exit
14:21:32 <Botje> try /quit
14:21:38 <Botje> this is not GHCi :)
14:22:42 <Guest13202> I have: mapM_ print [[1],[1,1]] - it prints: [1] and [1,1] but I want just 1 and 1 1 to be printed. How can I do this?
14:23:33 <dmwit> Guest13202: Step one is to write a function which prints [1] as 1 and [1,1] as 1 1.
14:23:52 <eikke> > mapM_ (putStrLn . Data.List.intercalate " " . map show) [[1], [1, 1]]
14:23:54 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:23:54 <lambdabot>    arising from a use of ...
14:24:10 <c_wraith> :t mapM_ (mapM_ print)
14:24:12 <lambdabot> Show a => [[a]] -> IO ()
14:24:12 <dmwit> eikke: how about unwords
14:24:21 <eikke> dmwit: hmh, right
14:24:23 <c_wraith> totally useless answer!
14:24:34 <eikke> not very used to such text handling
14:24:55 <dmwit> :t putStrLn . unlines . map (unwords . map show)
14:24:57 <lambdabot> Show a => [[a]] -> IO ()
14:25:02 <dmwit> oops, putStr
14:33:58 <thirsteh> dmwit: hmm, can't seem to actually get it to print a whole number of milliseconds
14:37:54 <crdueck> i'm getting ridiculous memory allocation using Prelude.floor. Apparently its a known problem that floor is inefficient, but how can i fix this
14:38:32 <c_wraith> with what types?
14:38:56 <crdueck> i have a simple function: f !a = floor $ a + (x + y + z) / 3 :: Int -> Int, thats allocating %69.1 of 146K bytes
14:38:57 <hpaste> rifki revised ‚Äúgraph question‚Äù: ‚Äúgraph question‚Äù at http://hpaste.org/85557
14:39:15 <rifki> hey, can you have a look at my revised hpaste?
14:39:22 <Eduard_Munteanu> No need for the bang pattern.
14:39:45 <c_wraith> yeah, that bang pattern doesn't do anything except maybe slow things down
14:39:50 <ab9rf> why are you banging that?
14:40:10 <skyflash> Which generic zipper?  As happens from time to time, I want to a new feature/library, but google suggests a cornucopia of choice.  What's the wisdom of the channel on this one?
14:40:21 <crdueck> that was only there because I thought i was leaking space somehow, removing it doesnt help
14:40:41 <Eduard_Munteanu> rifki: you don't say   f g x   for   f (g x)
14:41:26 <Eduard_Munteanu> rifki: Graph is a function too, it's not special
14:41:28 <rifki> I'm just trying to make a graph a list :/
14:41:36 <rifki> oh
14:41:51 <rifki> so what should I do then? :/
14:42:07 <Eduard_Munteanu> deGraph (Graph ...)
14:42:55 <Eduard_Munteanu> Just like when you pattern-match, same reason.
14:43:22 <Eduard_Munteanu> rifki: btw, is that Hugs? oO
14:43:31 <rifki> yes it is!
14:44:00 <Eduard_Munteanu> Ok. Just know that it's really old, you should use the Haskell Platform if you can.
14:44:50 <Eduard_Munteanu> (I mean if you ever care about performance, features, ...)
14:45:28 <rifki> well, my boss makes me use hugs, I know it's old and not updated anymore but I have to use that
14:46:02 <crdueck> here is a paste, if you run it with -prof -auto-all you can see that the skew function is doing a LOT of allocation: http://sprunge.us/EiPj
14:46:21 <Eduard_Munteanu> Interesting, if it's an actual job. I've seen teachers pressing students into using Hugs usually.
14:46:31 <eikke> we had to use hugs at uni
14:46:44 <rifki> Eduard_Munteanu : boss = professor same stuff :D
14:46:52 <Eduard_Munteanu> Heh.
14:47:50 <crdueck> also, i'm compiling with ghc -O2 -fllvm -optlo-O3 -prof -auto-all
14:48:40 <rifki> Eduard_Munteanu : can you tell me how come Graph is a function there?
14:49:15 <Eduard_Munteanu> rifki: constructors are functions too
14:49:23 <Eduard_Munteanu> @src Either
14:49:24 <lambdabot> Source not found. stty: unknown mode: doofus
14:49:29 <Eduard_Munteanu> @src Maybe
14:49:29 <lambdabot> data Maybe a = Nothing | Just a
14:49:33 <Eduard_Munteanu> :t Just
14:49:35 <lambdabot> a -> Maybe a
14:49:51 <Eduard_Munteanu> :t Nothing
14:49:53 <lambdabot> Maybe a
14:51:01 <rifki> Eduard_Munteanu : so is deGraph (Graph nodes) = nodes supposed to work?
14:51:24 <Eduard_Munteanu> Yes.
14:51:38 <Eduard_Munteanu> As long as you call it correctly when you actually use it.
14:53:41 <crdueck> hmm, explicitly typing (floor :: Float -> Int) removed the memory allocation problem. I guess floor converts through Integral as a default
14:54:22 <eikke> crdueck: compiler can warn about those things
14:54:45 <crdueck> eikke: i get those warnings if I do something like (2^3), but i didnt get a warning here
14:54:57 <crdueck> and I'm not sure those are even the same type of warning
14:55:12 <Eduard_Munteanu> crdueck: or type your local definitions as well
14:55:54 <rifki> you can see my hpaste, can you say what I'm doing wrong there?
14:56:21 <Eduard_Munteanu> rifki: well, I told you, you're calling it wrong: deGraph Graph ...
14:56:58 <Eduard_Munteanu> That parses to  (deGraph Graph) ...
14:57:12 <eikke> crdueck: main = print $ floor 1, compiling using -Wall gives 2 related warnings (one for the '1', one for the output type)
14:57:27 <rifki> what should it be? please explain it in a bit more detail if you can :)
14:58:12 <Eduard_Munteanu> deGraph (Graph [ ( Node 0 [ ( 1 , 2 ) ] ) , ( Node 1 [] ) ])
14:59:12 <rifki> thank you very much!
14:59:13 <Eduard_Munteanu> You also have useless parens inside that list, so you could clean it up to : deGraph (Graph [ Node 0 [ ( 1 , 2 ) ] , Node 1 [] ])
15:01:07 <rifki> yeah, but the input is supposed to be that way, but you are right they are totally useless
15:04:12 <rifki> one more question : if I want the function work like this : deGraph Graph [ ( Node 0 [ ( 1 , 2 ) ] ) , ( Node 1 [] ) ] = [ ( Node 0 [ ( 1 , 2 ) ] ) , ( Node 1 [] ) ] What would the function should be like?
15:06:51 <Eduard_Munteanu> rifki: you can't
15:07:10 <rifki> okey :)
15:08:16 <Eduard_Munteanu> Unless you make something totally stupid like  deGraph :: ([Node a] -> Network a) -> [Node a] -> [Node a]    deGraph _ x = x    :)
15:09:15 <rifki> yeah that would be totally stupid :)
15:19:11 <lmj`> Is it fair to criticize Haskell for overuse of Int? I see it as a premature and unsafe optimization in most cases. Is there a plan to transition to a new Prelude?
15:19:56 <Eduard_Munteanu> Haskell itself doesn't use Int much, some programmers do.
15:20:23 <Eduard_Munteanu> But yeah, that complaint is valid.
15:21:07 <alszar> Things like length do use Int, though
15:21:08 <Eduard_Munteanu> As for the Prelude, there's stuff like genericLength and such, you can use those.
15:21:09 <alszar> Which is annoying
15:21:28 <Eduard_Munteanu> @hoogle genericLength
15:21:29 <lambdabot> Data.List genericLength :: Num i => [b] -> i
15:21:54 <Eduard_Munteanu> I mean the defaulting rules are rather sane.
15:22:04 <tac_> > genericLength [1,2,3]
15:22:06 <lambdabot>   3
15:22:23 <tac_> > genericLength [0..256] :: Word8
15:22:24 <lambdabot>   1
15:22:25 <Eduard_Munteanu> :t genericLength [1,2,3]
15:22:26 <lambdabot> Num i => i
15:22:28 <tac_> ehehehe
15:22:31 <Eduard_Munteanu> Bah.
15:23:23 <lmj`> How do I get DPH running? It doesn't seem to be part of Ubuntu's ghc ("unrecognised flags: -fdph-par"). Shall I compile my own ghc, then?
15:24:34 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúpp‚Äù at http://hpaste.org/85574
15:25:12 <TimS> Ah, didn't realize it would put in here for me
15:25:16 <TimS> I am an Anonymous Coward
15:25:35 <ab9rf> TimS: what is this supposed to be?
15:25:47 <TimS> Is there a better way of writing that? I'm using a fold but I never actually touch the base case (apart from calling pp [])
15:26:09 <ab9rf> what are you trying to do?
15:26:20 <TimS> Basically, want to concat some strings with " -> " between them
15:26:30 <TimS> but avoiding the fence post problem
15:26:36 <ab9rf> :t intercalate
15:26:37 <lambdabot> [a] -> [[a]] -> [a]
15:26:45 <lmj`> Anyone here use Data Parallel Haskell?
15:27:03 <ab9rf> intercalate " -> " ["my","cat","has","fleas"]
15:27:10 <ab9rf> > intercalate " -> " ["my","cat","has","fleas"]
15:27:12 <lambdabot>   "my -> cat -> has -> fleas"
15:27:18 <TimS> Ah, perfect, thankyou
15:27:44 <ab9rf> @src intercalate
15:27:45 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
15:27:52 <ab9rf> @src intersperse
15:27:53 <lambdabot> intersperse _   []     = []
15:27:53 <lambdabot> intersperse _   [x]    = [x]
15:27:53 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
15:28:24 <ab9rf> for what you're doing you actually need intercalate "->" $ map show
15:28:55 <ab9rf> > intercalate " -> " $ map show $ ["my","cat","has","fleas"}
15:28:57 <lambdabot>   <hint>:1:58: parse error on input `}'
15:28:57 <ab9rf> bah
15:28:59 <ab9rf> > intercalate " -> " $ map show $ ["my","cat","has","fleas"]
15:29:00 <lambdabot>   "\"my\" -> \"cat\" -> \"has\" -> \"fleas\""
15:29:20 <TimS> Yeah, I had got to pp x = intercalate " -> " (map show x)
15:29:27 <TimS> but I suck with $ and .
15:29:37 <ab9rf> TimS: so do i :)
15:29:56 <Kinnison> pp = intercalate " -> " . map show
15:29:57 <Kinnison> no?
15:30:03 <ab9rf> Kinnison: $
15:30:30 <ab9rf> :t intercalate " -> " . map show
15:30:31 <lambdabot> Show a => [a] -> [Char]
15:30:38 <ab9rf> :t intercalate " -> " $ map show
15:30:40 <lambdabot>     Couldn't match expected type `[[Char]]'
15:30:40 <lambdabot>                 with actual type `[a0] -> [b0]'
15:30:40 <lambdabot>     In the return type of a call of `map'
15:31:07 * Kinnison is confused now
15:31:10 <ab9rf> hm, you need . to get a partially unapplied function
15:31:13 <Kinnison> was I wrong or right?
15:31:18 <TimS> Ah, interesting, intercalate " -> " . map show gives me a monomorphism issue
15:31:28 <TimS> so it will work with explicit typing
15:31:30 <lmj`> Any idea what to do about this compile error? Failed to load interface for `Data.Array.Parallel' It is a member of the hidden package `dph-lifted-vseg-0.6.1.2'.
15:32:00 <koninkje> lmj`: add dph-lifted-vseg to your project's cabal file
15:32:07 <ab9rf> > let pp = intercalate " -> " . map show in pp (words "help, i'm trapped in a fortune cookie")
15:32:08 <lambdabot>   "\"help,\" -> \"i'm\" -> \"trapped\" -> \"in\" -> \"a\" -> \"fortune\" -> \...
15:32:43 <TimS> It gives me Possible cause: the monomorphism restriction applied to the following:
15:32:48 <ab9rf> > let pp = intercalate " -> " . map show in pp [1..]
15:32:50 <lambdabot>   "1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 ->...
15:33:03 <TimS> Maybe lambda bot has -XNoMonomorphismRestriction
15:33:10 <ab9rf> probably doe
15:33:23 <ab9rf> the monomorphism restrition is a performance issue
15:33:28 <lmj`> koninkje: is there a command-line equivalent? I'm trying to compile the first example in http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
15:34:10 <lmj`> I may have a greater problem since -fdph-par is not recognized.
15:36:57 <dmwit> I bring you all the following lovely Haskell puzzle!
15:37:02 <dmwit> < (==) == (/=) . not
15:37:04 <goodfellow>   True
15:37:32 <lmj`> Is it still true that in DPH "vectorisation does not handle type classes at the moment"?
15:37:47 <shachaf> dmwit: What's the puzzle?
15:38:00 <dmwit> What's needed to make it work?
15:38:37 <cmccann> dmwit: an absence of common sense
15:39:17 <dmwit> < (==) == (/=)
15:39:19 <goodfellow>   False
15:39:24 <dmwit> < (==) == (==)
15:39:25 <goodfellow>   True
15:39:26 <dmwit> =)
15:39:52 <dmwit> < (==) < const not
15:39:54 <goodfellow>   True
15:40:02 <dmwit> < (==) > const not
15:40:03 <goodfellow>   False
15:40:52 <elliott> < f < g
15:40:54 <goodfellow>   Ambiguous type variable `a0' in the constraints:
15:40:54 <goodfellow>    (GHC.Classes.Ord a0)
15:40:54 <goodfellow>   ...
15:41:04 <elliott> < const 1 < const 2
15:41:06 <goodfellow>   Ambiguous type variable `b0' in the constraint:
15:41:06 <goodfellow>    (Data.Universe.Finite b0...
15:41:13 <cmccann> Finite, eh
15:41:14 <elliott> dmwit: i think i spoiled it
15:41:19 <dmwit> < const 1 < (const 2 :: () -> Word8)
15:41:21 <goodfellow>   True
15:41:30 <dmwit> cmccann: Now you got it. =)
15:41:42 <elliott> actually goodfellow got it :P
15:41:47 <cmccann> I wrote something like that once
15:41:57 <elliott> f > g = compare (map f universe) (map g universe), presumably
15:41:58 <dmwit> elliott: spoilers welcome, it's the whole point =)
15:42:00 <elliott> er
15:42:02 <elliott> compare f g = ...
15:42:20 <dmwit> Pretty much, yup.
15:42:46 <dmwit> also fun:
15:42:53 <cmccann> though mine "serialized" functions of small-ish finite types to Integer which was rather more horrible
15:43:02 <dmwit> < [(==), const not]
15:43:04 <goodfellow>   [[(False,[(False,True),(True,False)]),(True,[(False,False),(True,True)])],[...
15:43:21 <elliott> it should give valid lambda syntax.
15:43:22 <dmwit> < not
15:43:24 <shachaf> Oh, goodfellow is a bot.
15:43:24 <goodfellow>   [(False,True),(True,False)]
15:43:38 <elliott> show not == "\\b -> case b of { False -> True; True -> False }"
15:43:45 <dmwit> elliott: that sounds like effort to me
15:44:04 <elliott> hey, you set up lambdabot
15:44:14 <dmwit> yeah =)
15:44:19 <cmccann> yeah, I didn't know that was even possible.
15:44:20 <tootooroo> What exactly does the Eq instance for functions do? :-| I mean... how is that even possible?
15:44:25 <shachaf> @help
15:44:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:44:26 <goodfellow> help <command>. Ask for help for <command>. Try 'list' for all commands
15:44:27 <cmccann> I thought only Cale knew all the magic incantations to make lambdabot work
15:44:36 <shachaf> cmccann: Making lambdabot is easy: cabal install lambdabot
15:44:37 <shachaf> hth
15:44:41 <shachaf> word
15:44:42 <shachaf> work
15:44:44 * shachaf sighs
15:44:44 <dmwit> tootooroo: Experiment! Then peek in ?hackage universe for spoilers. =)
15:45:16 <dmwit> shachaf: Oops, maybe I should disable that module...
15:45:23 <cmccann> shachaf: I love spelling words correctly, it is so easy
15:45:48 <elliott> it's OK, we can just tell lambdabot to @quit
15:45:56 <shachaf> dmwit: should i ?where ?where
15:46:03 <dmwit> ?where ?where
15:46:03 <lambdabot> ?where ?where
15:46:04 <goodfellow> Unknown command, try @list
15:46:04 <goodfellow> Unknown command, try @list
15:46:13 <shachaf> Aw.
15:46:16 <tootooroo> > ((==) :: a -> a -> Bool) == ((==) :: a -> a -> Bool)
15:46:18 <lambdabot>   No instance for (GHC.Classes.Eq a)
15:46:18 <lambdabot>    arising from a use of `GHC.Classes.==...
15:46:19 * dmwit sticks his tongue out
15:46:33 <dmwit> < ((==) :: a -> a -> Bool) == ((==) :: a -> a -> Bool)
15:46:35 <goodfellow>   No instance for (GHC.Classes.Eq a)
15:46:35 <goodfellow>    arising from a use of `GHC.Classes.==...
15:46:46 <tootooroo> > ((==) :: Bool -> Bool -> Bool) == ((==) :: Bool -> Bool -> Bool)
15:46:47 <lambdabot>   *Exception: (==): No overloading for function
15:46:48 <dmwit> tootooroo: Gotta use the other bracket for goodfellow.
15:47:02 <dmwit> okay, gotta run for a bit
15:47:04 <ski_> @where @where
15:47:04 <lambdabot>  @where
15:47:04 <tootooroo> Oh.
15:47:05 <goodfellow> Unknown command, try @list
15:47:25 <tootooroo> < ((==) :: Bool -> Bool -> Bool) == ((==) :: Bool -> Bool -> Bool)
15:47:29 <goodfellow>   True
15:47:54 <ski_> < and == or
15:47:55 <goodfellow>   No instance for (Data.Universe.Finite [GHC.Types.Bool])
15:47:55 <goodfellow>    arising from a u...
15:47:59 <otters> < ((==) :: Int -> Int -> Bool) == ((==) :: Bool -> Bool -> Bool)
15:48:00 <goodfellow>   Couldn't match expected type `GHC.Types.Int'
15:48:01 <goodfellow>              with actual type ...
15:48:04 <shachaf> dmwit: Hmm, you turned off most of the plugins.
15:48:08 <tootooroo> @type ((==) ==)
15:48:09 <goodfellow> Unknown command, try @list
15:48:10 <lambdabot> Eq a => (a -> a -> Bool) -> Bool
15:48:41 <dmwit> shachaf: Maybe I should ask it to quit. You think?
15:49:02 <Philonous> dmwit:  Isn't that just smallcheck?
15:49:07 <shachaf> lambdabot: @slap dmwit
15:49:08 * lambdabot slaps dmwit
15:49:08 <ski_> bah, should be something like `instance (Compact a,Overt a,Eq b) => Eq (a -> b)' ..
15:49:31 <NemesisD> is there a noticeable speedup with cabal -j
15:49:35 <dmwit> Philonous: pretty much
15:50:07 <Philonous> It's neat though. lambdabot should have it, to confuse newcomers :>
15:50:38 <shachaf> dmwit: :-(
15:52:32 <shachaf> dmwit: What happened to goodfellow?
15:52:55 <quchen> dmwit: What's -j for? --help doesn't help
15:53:03 <quchen> Parallel builds or something?
15:53:04 <Kinnison> parallelism in build
15:53:18 <Kinnison> it will build more than one pkg at once, if the dependency tree allows for it
15:53:22 <alpounet> quchen, yes, it'll build packages in parallel
15:53:30 <quchen> Ah, that was added with 7.6 or something right
15:53:43 <kosmikus> amiller: saw your question only now. could you send me an email, please?
15:53:44 <alpounet> nah, it's just in cabal
15:53:51 <alpounet> came with 1.17 i think
15:53:56 <shachaf> quchen: Good ol' cabal 7.6.
15:53:57 <amiller> kosmikus, yes i'll collect my thoughts a bit and plan on doing that
15:54:04 <alpounet> err, 1.16
15:54:31 <quchen> Well then I wasted a lot of time watching my CPU mostly being bored while building.
15:54:49 <kosmikus> amiller: great. I'm quite busy teaching this week and will hopefully have a bit more time once I'm back home (on Friday).
15:55:09 <amiller> ok, cheers :)
15:56:36 <elliott>   lambdabot: @slap shachaf
15:56:39 <elliott> aw.
15:57:54 <Kinnison> I want ghc --make -j
15:57:59 <Kinnison> but apparently that's "harder" :-(
15:59:08 <NARMYNNA> http://bitchinbeach.com/videos/young-german-girl-sabrina-loves-sperm-in-her-face/
15:59:24 <quchen> Kinnison: Have you looked at Shake?
15:59:50 <Kinnison> quchen: No, although mostly because I was unreasonably prejudiced against it by some outlandish and blatantly incorrect claims one of its authors made in a video
16:00:38 <quchen> Haven't used it myself, but maybe have a look at it anyway? I can send you a renamed version without any claims if you want ;-)
16:01:25 <lmj`> I just deleted ~/.cabal, reinstalled ghc-platform, and reinstalled cabal packages again, yet ghc-pkg check shows many broken packages. Is there something else I need to delete?
16:01:47 <Kinnison> ~/.ghc
16:02:11 <lmj`> oh right, I knew that once but forgot
16:02:19 <lmj`> thanks
16:02:30 <Kinnison> :-)
16:03:13 <monochrom> deleting .cabal is of low priority. also, it loses your .cabal/config
16:03:26 <Kinnison> indeed
16:04:00 <cmccann> just drop some thermite on the hard drive, you're bound to get everything that way
16:04:11 <monochrom> please don't tell me you have not modified .cabal/config. it has wrong contents. you must modify it. http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction
16:05:07 <Kinnison> :-)
16:05:57 <shachaf> ski: What is Compact and Overt?
16:06:00 <jamy_> anybody knows how to make syntaxhighlight in vim?
16:06:18 <Fuuzetsu> edwardk: We had a lecture about shooting yourself in the foot with a programming language and Haskell had: `You spend several hours creating a new copy of the Universe which is identical to the existing one except your foot has a hole in it. You then hear that it can be done more elegantly with Dyadic Functile Hyper-Arrows, but the very act of reading some of the included sample code causes one of your metatarsals to explode.'
16:06:43 <Fuuzetsu> I asked my lecturer whether he knows who you were because it Dyadic Functile Hype-Arrows sounds like your thing.
16:06:43 <edwardk> hah
16:06:50 <edwardk> =)
16:07:37 <djahandarie> That does not sound like a real thing
16:07:56 <djahandarie> But on the other hand, thanks to snarXiv, I know that it very well could be a real thing
16:08:02 <Fuuzetsu> djahandarie: Neither does 50% of the stuff edwardk writes.
16:08:18 <Fuuzetsu> Hmm, probably more than 50%...
16:08:35 <cmccann> you can only shoot yourself in the foot with edwardk's help if you can extract the original bullet afterwards and the gun can be composed with other firearms
16:08:42 <hpc> snarxiv may be the greatest thing to come out of the academic community :D
16:08:49 <djahandarie> Well, his stuff is mainly pulled from other fields. "Functile" is not a word in any field as far as I know
16:09:16 <edwardk> In analytics you just write a representation of the hole in the foot sans foot into a new file, and it'll eventually merge with your other foot to great pain and it'll appear to be there in the meantime if you look before its merged, because any attempt to peek at your foot until then will have to pass through the hole.
16:09:19 <elliott> they would be dyadic functile hyper-profunctors
16:09:25 <elliott> if edwardk was doing them
16:10:03 <djahandarie> Maybe it's a portmanteau of "function" or "functor" and "quantile"
16:10:24 <sproingie> functile dysrection
16:10:43 <edwardk> This is good if you need to deal with shooting many feet. I can then count up how many you shot quickly so long as you don't have them entangled with too many other body parts
16:12:01 <hpc> i hear this is how they get ghc so fast
16:12:03 <Fuuzetsu> I expect that Dyadic Functile Hyper-foot Profunctor library will make its appearance on cafe before next week then.
16:12:16 <hpc> get a bunch of grad students to line up, then see how quickly you can shoot all of them in the foot
16:13:04 <companion_cube> and its glorious abstractions will make lenses already deprecated
16:13:13 <edwardk> elliott: nah, its all wavelet trees now. who needs profunctors?
16:13:23 <elliott> edwardk: ooh, wavelet tree lenses
16:13:39 <edwardk> elliott: i already started building a variant on Vector for them.
16:13:53 <edwardk> If it works then I get an unboxed vector that can handle tree-like structures!
16:13:53 <hpc> i bet conal has a blog post from 2008 saying wavelet tree lenses are the future
16:14:00 <ski_> shachaf : a type `a' is compact when there is a semi-computable universal `forallS :: (a -> Sierpinski) -> Sierpinski' -- similarly for overt and existential
16:14:36 <edwardk> hpc: i usually skip that benchmark
16:14:40 <companion_cube> I'd like blog posts that say that futures are the future
16:14:47 <edwardk> companion_cube: =)
16:14:56 <hpc> edwardk: you're teaching at MIT, right?
16:15:06 <companion_cube> or futures of future blog posts are described in past blog posts as the future
16:15:07 <hpc> use harvard grad students
16:15:09 <ski_> shachaf : also see Mart√≠n Escard√≥'s "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)>
16:15:35 <companion_cube> +that
16:16:09 <tac> ski_: that's an awesome topic :)
16:17:18 <lmj`> OK I've managed to get all the way to a link error for the DPH example on the wiki. I guess this is caused by -fdph-par not being recognized.
16:17:42 <ski_> tac :)
16:17:56 <lmj`> Actually several hundred link errors looking something like (.data+0xbc): undefined reference to `vectorzm0zi9zi1_DataziVectorziMutable_uninitialised_closure'
16:18:17 <ski_> preflex: zdec vectorzm0zi9zi1_DataziVectorziMutable_uninitialised_closure
16:18:17 <preflex>  vector-0.9.1_Data.Vector.Mutable_uninitialised_closure
16:21:45 <lmj`> Is -fdph-var mentioned on the wiki now obsolete, or is my not having it the cause of the link errors?
16:25:42 <Fuuzetsu> lmj`: #ghc might be of more use
16:26:35 <ski_> preflex: zenc `vectorzm0zi9zi1_DataziVectorziMutable_uninitialised_closure'
16:26:36 <preflex>  z60Uvectorzzm0zzi9zzi1zuDatazziVectorzziMutablezuuninitialisedzuclosurezq
16:26:51 <ski_> hm, exponential growth
16:42:29 * hackagebot parsers 0.6 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.6 (EdwardKmett)
16:43:48 <NARMYNNA> http://bitchinbeach.com/videos/young-german-girl-sabrina-loves-sperm-in-her-face/
17:04:12 <Tene> ... not quite what I expected to see in #haskell.
17:04:21 <c_wraith> it's a huge channel.
17:04:24 <c_wraith> huh, over 1k now
17:04:30 <c_wraith> it's an obvious spammer target
17:04:55 <lunarjar> can anyone point me to a good haskell intro with lambda calculus?
17:05:30 <c_wraith> most good haskell intros probably won't cover the connection to lambda calculus immediately.  Why are you looking for that?
17:05:54 <lunarjar> I want to learn how to compute normal forms for lambda expersions
17:06:12 <c_wraith> That really has very little to do with haskell
17:07:20 <lunarjar> something like (Œªx y z.(2 √ó x √ó x + 4 √ó z) / (3 √ó x ‚àí 5 √ó z)) 3 ((Œªy. y y) (Œª x. x x)) ((Œªx. x √ó x)((Œªx. x √ó x) 2))
17:07:31 <lunarjar> this is quite a dark forest for me now
17:07:31 <tromp_> u want to learn how to do it manually, or how to program it?
17:07:39 <lunarjar> both
17:08:14 <monochrom> keep plugging in, and be mechanical. that is important. most human learners fail to be mechanical, it's why they're stuck
17:08:45 <lmj`> Does anyone have experience with Data Parallel Haskell? I'm realizing that it doesn't quite do what I wanted, which is nested parallelism without introducing arrays.
17:08:49 <c_wraith> Yeah..  The "trick" with evaluating lambda expressions is that there is no trick. You just follow the rules.
17:09:08 <lmj`> I guess I can try to express things as arrays, but it's awkward.
17:09:46 <lmj`> Assuming that I get DPH running at all.
17:11:50 <tromp_> google for lambda calculus normal form haskell shows top hit http://yiopposite.blogspot.com/2009/05/lambda-calculus-interpreter-in-haskell.html
17:12:30 * hackagebot secret-santa 0.1.0.0 - Secret Santa game assigner using QR-Codes  http://hackage.haskell.org/package/secret-santa-0.1.0.0 (RodrigoSetti)
17:14:07 <lmj`> Is there anything similar to the Cilk algorithm in Haskell? The only reference I found was "pH" which was "back in the mid/late 90's".
17:15:15 <tromp_> also see the 3rd hit http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
17:17:23 <monochrom> it is easy to read too much and do too little
17:18:16 <tromp_> you can also reduce with so called higher order abstract syntax, bascially letting haskell do the work for you. i wrote about that at http://www.reddit.com/r/haskell/comments/qplvu/evaluating_higher_order_abstract_syntax/
17:18:31 <monochrom> the more time you read Chopin piano scores, the less time you drill on finger skills for playing them
17:23:19 <monochrom> I went to a seminar on how to fight writing block. it gave good analysis and practical advice. the most impressive advice IMO: "there are many books on writing block, but I'm not going to list any. do you see why?"
17:34:28 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚ÄúFunctor?‚Äù at http://hpaste.org/85576
17:34:54 <wollw> I have a data declaration that looks like the above... Given that MemoryValue doesn't have the king "* -> *" i assume I don't want a functor...
17:35:10 <wollw> (considering that doesn't compile)
17:35:29 <shachaf> MemoryValue is not a functor, indeed.
17:35:52 <wollw> Is there some other class i should put it in to map functions on it?
17:36:28 <shachaf> You can just use a regular function.
17:36:36 <shachaf> What type do you want it to have, though?
17:37:21 <wollw> well, it's fine without the instance.  i was just attempting to use the Functor typeclass to make things neater if I could
17:37:30 <wollw> Just not sure what to call it other than fmap
17:38:41 <shachaf> First, figure out what it is.
17:38:45 <shachaf> What is its type?
17:38:57 <monochrom> you have a strange requirement on f. it has to be simultaneously Word8->Word8 and Word16->Word16. Functor does not do this. Functor misses the point completely.
17:39:13 <shachaf> Yes.
17:40:47 <wollw> yeah, i need to think about this some more
17:45:21 <jmcarthur> wollw: maybe you are looking for a function with a type similar to   (forall a. Integral a => a -> a) -> (MemoryValue -> MemoryValue)  ?
17:45:44 <jmcarthur> wollw: (like fmap but more restricted)
17:45:51 <wollw> yeah, i think so
18:13:22 <lemao> hi all! I need to use haskell to create a shared library exporting 2 simple C functions: int start() and void stop(). These 2 functions are defined in a .h files that is part of a C/C++ executable
18:14:10 <lemao> the shared library will be dynamically loaded by the C/C++ exe. What is the best way to structure a Haskell package? Should I use c2hs, hsc2hs, greencard, etc?
18:14:24 <lemao> the simpler the better
18:17:05 <newsham> is there a ctags-like generator for haskell that works with modern haskell (including unicode support)?
18:17:51 <cmears> lemao: I only have experience in the other direction (calling C++ from Haskell), but for only two functions you might not need any fancy tools
18:18:03 <cmears> Because you can write the FFI glue manually
18:18:16 <aavogt> newsham: I'm not sure about unicode, but at least this deals with qualified names properly http://hackage.haskell.org/package/hothasktags
18:20:23 <lemao> cmears: what would that look like? Just ffi exports using some basic types?
18:21:15 <lemao> cmears: there is a single exe and I will be creating N DLLs using haskell so it should be something simple I can easily replicate in diff packages and that conforms to the expected .h interface (start/stop)
18:21:49 <newsham> Parse error: SrcLoc {srcFilename = "Exception.hs", srcLine = 219, srcColumn = 26}: Parse error: ‚àÄ
18:22:37 <lemao> cmears: I basically want to pre-build the exe so it shouldnt have any deps such as hsffi.h or ffi.h (as I have seen in some tutorials) just a plain .h.
18:23:38 <cmears> lemao: I think you're going beyond what I know about the FFI (:
18:24:16 <cmears> But there might be someone on haskell-cafe who has done something similar before
18:29:50 <ryantanjunming> is there a stored haskell function to remove an item from a list?
18:30:20 <cmears> > delete 3 [1..5]
18:30:22 <lambdabot>   [1,2,4,5]
18:30:32 <tromp_> delete () [(),(),()]
18:30:38 <tromp_> > delete () [(),(),()]
18:30:40 <lambdabot>   [(),()]
18:30:52 <ryantanjunming> thanks
18:31:54 <ryantanjunming> how should i proceed in deleting all elements from one list off another?
18:32:42 <cmears> Depends on whether it is an practice exercise or not
18:32:46 <danpalmer> hi, I'm trying to do some transformations on some JSON, would you recommend Data.Aeson for this? I'm having trouble with the sample code from it.
18:32:50 <aavogt> > [1 .. 5] \\ [2,4]
18:32:50 <lemao> cmears: thanks. hard to find concise info on this use case
18:32:51 <lambdabot>   [1,3,5]
18:33:06 <Cale> > "mississippi" \\ "imps"
18:33:08 <lambdabot>   "sissipi"
18:33:12 <cmears> lemao: good luck, I wish I could have helped more
18:33:24 <ryantanjunming> so (x:xs) \\ (y:ys)
18:33:26 <ryantanjunming> will work?
18:33:41 <Cale> yes, though it's okay for either of the lists to be empty
18:33:59 <djahandarie> > [] \\ undefined
18:34:00 <lambdabot>   *Exception: Prelude.undefined
18:34:14 <djahandarie> > undefined \\ []
18:34:16 <lambdabot>   *Exception: Prelude.undefined
18:34:19 <djahandarie> :(
18:34:24 <Cale> > [] \\ [undefined]
18:34:26 <lambdabot>   []
18:36:48 <ryantanjunming> checkTreeInsert i [] [i] = True
18:36:48 <ryantanjunming> checkTreeInsert i xs ys = checkTreeInsert i [] ( xs \\ ys )
18:36:56 <ryantanjunming> something is wrong here..
18:39:58 <ryantanjunming> @\\
18:39:59 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
19:04:00 <ryantanjunming> https://gist.github.com/anonymous/d5164f1f7546c2871b10
19:04:28 <ryantanjunming> i'm supposed to delete one list from another, and check that the integer i is left in the second one..
19:04:39 <ryantanjunming> somehow the syntax is wrong
19:06:37 <geekosaur> that code doesn't make a lot of sense
19:07:08 <geekosaur> ```xs = ordered xs``` is not doing to do what you think...
19:07:44 <shachaf> Assuming you think it does something.
19:07:56 <geekosaur> haskell bindings are recursive. the xs on the right is not the one from the parameter list; it's the same one as on the left
19:08:13 <geekosaur> and yes, it's not even going to get used so you wouldn't notice
19:08:59 <ryantanjunming> oh i have an ordered function that sets the list into a nice ordered list
19:09:03 <monochrom> delete "xs = ordered xs" and "ys = ordered ys". you don't need intermediate definitions for simple tasks. simply "ds = ordered xs \\ ordered ys"
19:09:16 <geekosaur> additionally, ```i [] [i]``` is not a valid guard
19:09:38 <monochrom> however, \\ works without requiring you to sort anything. therefore, "ds = xs \\ ys" is just as good and no slower
19:09:58 <geekosaur> a guard is an expression producing a Bool
19:10:07 <monochrom> I have no idea what "i [] [i]" is supposed to mean
19:10:19 <ryantanjunming> i `elem` ds = True
19:10:24 <ryantanjunming> ive changed it
19:10:45 <ryantanjunming> means that the integer i is supposed to be int the second list only, and the first has to be empty
19:10:47 <geekosaur> you seem to be expecting a pattern (and even there it's wrong; were it actually used as a pattern, the [i] would bind a new i that shadows the first one)
19:11:01 <ryantanjunming> icic
19:11:15 <sw2wolf> @ty (\\)
19:11:16 <lambdabot> Eq a => [a] -> [a] -> [a]
19:12:12 <ryantanjunming> geekosaur ur right, i didnt need ordered function at all
19:12:29 <geekosaur> ```i [] [i]```, as a pattern, matches the first thing and binds whatever it is to ```i```, matches an empty list, then matches a list with a single item and binds that item to ```i``` (shadowing the first one which is therefore never visible)
19:13:21 <ryantanjunming> hmmm, i get what u mean
19:13:33 <ryantanjunming> only after an = thus i become a valid reference??
19:13:55 <geekosaur> no
19:14:12 <ivanm> I'm looking at some C code trying to see if I can fix a bug that's annoying me; I wonder if it's so lacking in abstractions because a) C doesn't let you deal with abstractions well; b) C _programmers_ don't deal with abstractions well; c) it's old when you didn't have the resources to deal with abstractions and needed to minimise RAM usage, etc.; d) ZOMG IT NEEDS TO BE _FASTER_!!!
19:14:29 <geekosaur> not exactly, at least; patterns do not do comparisons (except against constructors), they bind things
19:15:52 <heatsink> You can sometimes tell when a programmer had an abstraction in mind but didn't write it down in the code
19:16:12 <geekosaur> any lowercase name is going to be bound to something if the pattern match succeds; existing bindings will be shadowed (invisible). so I suppose if you try to think about it the wrong way "only after a = does it become a valid reference", but if you think about it that way then you are not really understanding pattern matching
19:16:21 <heatsink> from how the programmers use comments, typedefs, variable names, and so forth
19:17:18 <monochrom> I abstract everything to void*
19:17:31 <ryantanjunming> sry, how do i like "pm" you in this convo geekosaur
19:17:44 <heatsink> use /msg
19:17:51 * geekosaur is not going to be around much longer, unfortunately
19:17:52 <ryantanjunming> also thanks, it makes sense.. thats pretty intuitive
19:19:43 <natnayr> hello
19:19:54 * sw2wolf Pattern Matching is very convenient as in Prolog and Erlang.
19:19:54 <ivanm> heatsink: specifically in this case, they're generating postscript whilst also doing markup, adding line numbers, etc.
19:20:01 <heatsink> It's convenient how you can do addition and subtraction in void*, but multiplication and division are super awkward
19:21:06 <ivanm> natnayr: why are you sending messages off-channel?
19:21:26 <natnayr> how do u do that thing where u have my name highlighted?
19:21:38 <natnayr> im new to IRC sry bro
19:21:45 <heatsink> My first guess is that the right abstractions would involve using recursive data structures of temporary data, but managing recursive data structures is a pain in C
19:22:11 <heatsink> so they avoided it
19:22:28 <geekosaur> natnayr, we're not doing anything special; clients look for your nick in incoming messages and highlight when it's there
19:22:48 <geekosaur> most clients let you configure a list of names to highlight on
19:23:23 <natnayr> ahhhhh okok
19:23:27 <natnayr> makes alot of sense
19:23:48 <heatsink> I ran into a weird bug
19:24:06 <heatsink> My program gives me a segmentation fault if I use error "foo" in a certain place
19:24:26 <heatsink> If I use return $! error "foo" instead, it raises an exception like you'd expect
19:24:34 <ivanm> :o
19:28:35 <kristof> http://www.andrew.cmu.edu/user/awodey/preprints/astIntroFinal.pdf
19:29:09 <kristof> If one wanted to work on topics like this, would graduate work in mathematics be more applicable than graduate work in computer science?
19:39:30 <SuperNoeMan> can you extract from agda to haskell?
19:39:33 <SuperNoeMan> compile fully and use?
19:40:51 <sw2wolf> case () of _ | W.member w s && W.peek s /= Just w -> windows (W.focusWindow w) | Just new <- mnew, w == root && curr /= new -> windows (W.view new)  | otherwise -> return ()      why uses "case () of here "?
19:41:11 <sw2wolf> @ty ()
19:41:12 <lambdabot> ()
19:41:30 <ivanm> sw2wolf: because you need a case statement to use guards in a do-block?
19:41:44 <ivanm> the alternative would be nested if statements, or use the new MultiWayIf extension (which doesn't nest well)
19:42:16 <lazydancer> I am having trouble understanding how solution 26 the of 99 Haskell Questions Works. I was wondering if someone could help
19:42:24 <sw2wolf> ivanm: it will check each guards ?
19:42:50 <ivanm> yes
19:43:55 <sw2wolf> "case () of" seems make code cleaner than nested if ?
19:44:27 <ivanm> yes
19:47:20 <dmwit> shachaf: goodfellow will be back when I figure out how to make him less annoying
19:47:21 <arkeet> MultiWayIf is the same as using case () of _ with guards, I thought.
19:47:32 <dmwit> (complaining after every ? or @ command is no good)
19:48:06 <ivanm> arkeet: I saw a bug report the other day, where if you used nested MultiWayIf GHC couldn't tell whether guards are for the outer or inner if
19:48:12 <ivanm> i.e. layout issues
19:48:16 <arkeet> hmm
19:48:44 <arkeet> well it's no big loss not to use it anyway.
19:49:31 <ivanm> the other issue with MultiWayIf is that not haskell-indent for the emacs haskell-mode doesn't understand it :p
19:50:04 <shachaf> dmwit: Just change the prefix.
19:50:26 <shachaf> commandPrefixes = ["@","?"],
19:50:32 <dmwit> I just tried that. lambdabot refuses to start after I make that change. (!)
19:50:41 <ivanm> :o
19:50:42 <shachaf> Refuses to start?
19:50:46 <dmwit> Yup!
19:50:53 <dmwit> It says all the servers disconnected.
19:51:04 <shachaf> Maybe you need to change online.rc to use the new prefix?
19:51:14 <shachaf> Oh, it doesn't use a prefix.
19:51:24 <shachaf> Maybe you set the prefix to something that's used internally for some other IRC thing?
19:51:34 <dmwit> I set it to "goodfellow: ".
19:51:38 <dmwit> I thought it was a pretty good one.
19:51:44 <dmwit> I'm going to try ";".
19:51:44 <shachaf> Oh. I think maybe it has to be a character.
19:52:00 <shachaf> Also lambdabot also handles messages sent to its own nick somehow.
19:52:05 <shachaf> Also lambdabot is a huge mess.
19:52:21 <dmwit> But its type isn't [Char], it's [String]!
19:57:07 <shachaf> I just wanted to try the thing. :-(
20:02:53 <dmwit> < text "shachaf!!!"
20:02:54 <goodfellow>   shachaf!!!
20:03:06 <shachaf> ;help
20:03:07 <goodfellow> Unknown command, try @list
20:03:12 <shachaf> ;list
20:03:13 <goodfellow> http://code.haskell.org/lambdabot/COMMANDS
20:03:23 <dmwit> It's going to have to run on my laptop for a little while until I figure out what the heck is up with lambdabot on my desktop.
20:03:31 <dmwit> So no guarantees on uptime. =P
20:03:46 <shachaf> Aw.
20:03:56 <shachaf> Are you reading the logs?
20:04:00 <dmwit> Anyway it should be up at least until I wake up in the morning.
20:04:03 <shachaf> ;type 1
20:04:03 <goodfellow> Unknown command, try @list
20:04:06 <dmwit> There are logs?
20:04:07 <shachaf> :t 1
20:04:09 <lambdabot> Num a => a
20:04:18 <shachaf> goodfellow: ;
20:04:19 <goodfellow> Maybe you meant: activity activity-full admin bid choice-add echo flush ft ignore irc-connect join karma karma+ karma- karma-all leave let list listall listchans listmodules listservers more msg
20:04:19 <goodfellow> offline part poll-add poll-close poll-list poll-remove poll-result poll-show pretty quit rc reconnect run ticker undefine uptime version vote
20:04:42 <dmwit> Oh, type seems reasonable, especially now that he has a different prefix.
20:04:45 <dmwit> Let me turn that back on.
20:04:58 <shachaf> What version of GHC is it?
20:05:06 <dmwit> 7.4.1
20:06:10 <shachaf> Hmm.
20:07:00 <dmwit> Hmm?
20:08:21 <dmwit> < U.universe :: Word8
20:08:22 <goodfellow>   Couldn't match expected type `GHC.Word.Word8'
20:08:23 <goodfellow>              with actual type...
20:08:30 <dmwit> < U.universe :: [Word8]
20:08:32 <goodfellow>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:08:43 <shachaf> > U.universe :: [Integer]
20:08:45 <lambdabot>   Not in scope: `U.universe'
20:08:53 <shachaf> < U.universe :: [(Integer,Integer)]
20:08:55 <goodfellow>   [(0,0),(1,0),(0,1),(-1,0),(0,-1),(1,1),(0,2),(2,0),(0,-2),(1,-1),(0,3),(-1,...
20:09:15 <dmwit> You think you're so clever. =P
20:09:51 <shachaf> I think it's worth trying!
20:09:55 <dmwit> Me too!
20:10:03 <dmwit> < U.universe :: [Rational]
20:10:05 <goodfellow>   [0 % 1,(-1) % 1,1 % 1,(-1) % 2,1 % 2,(-2) % 1,2 % 1,(-1) % 3,1 % 3,(-3) % 2...
20:10:23 <shachaf> I mostly expected it to work, since that would be the point of having this Universe class and all.
20:10:32 <shachaf> < U.universe :: [Double]
20:10:33 <goodfellow>   No instance for (Data.Universe.Universe GHC.Types.Double)
20:10:33 <goodfellow>    arising from a...
20:10:37 <shachaf> Pft.
20:10:39 <copumpkin> < U.universe :: [Int -> Int]
20:10:40 <copumpkin> :(
20:10:40 <goodfellow>   *Exception: stack overflow
20:10:49 <dmwit> Yeah, I considered adding an instance for Double.
20:10:49 <copumpkin> < take 5 U.universe :: [Int -> Int]
20:10:50 <goodfellow>   *Exception: stack overflow
20:10:57 <copumpkin> < head U.universe :: [Int -> Int]
20:10:58 <goodfellow>   No instance for (Data.Universe.Universe
20:10:58 <goodfellow>                     [GHC.Types.Int ...
20:11:05 <dmwit> err, hm
20:11:07 <copumpkin> < head (U.universe :: [Int -> Int])
20:11:09 <goodfellow>   [(-9223372036854775808,*Exception: stack overflow
20:11:14 <copumpkin> wat
20:11:29 <shachaf> There's a Show instance for functions.
20:11:33 <shachaf> Using universe.
20:11:39 <shachaf> (And Finite or something.)
20:11:46 <copumpkin> I mean why is it stack overflowing
20:11:51 <shachaf> Oh.
20:11:55 <shachaf> < id :: Int -> Int
20:12:00 <goodfellow>   mueval-core: Time limit exceeded
20:12:09 <shachaf> < id :: Word8 -> Word8
20:12:13 <goodfellow>   mueval-core: Time limit exceeded
20:12:16 <copumpkin> do you have the world's worst Ord instance for functions?
20:12:19 <shachaf> < id :: Bool -> Bool
20:12:22 <dmwit> Um, mueval may complain about time limits for a little bit because I just started swapping.
20:12:23 <goodfellow>   [(False,False),(True,True)]
20:12:35 <dmwit> After testing the Universe instance for Int -> Int in ghci to see what's going on.
20:12:39 <dmwit> copumpkin: yes
20:12:42 <shachaf> < let u x = y where y :: a; y = x where z = id x in u 'a' :: Bool
20:12:43 <goodfellow>   Couldn't match type `t' with `a1'
20:12:43 <goodfellow>    `t' is a rigid type variable bound by
20:12:43 <goodfellow> ...
20:12:46 <shachaf> dmwit: :-(
20:12:49 <dmwit> copumpkin: Not that it should matter for this...?
20:12:49 <shachaf> Why is it broken?
20:12:50 <copumpkin> dmwit: is it the kinda stupid one or the really fucking stupid one?
20:12:55 <copumpkin> oh, I was just curious
20:13:13 <dmwit> I don't really know, therefore it's probably the really fucking stupid one.
20:13:29 <copumpkin> :)
20:13:33 <dmwit> Perhaps you can ask the question in a slightly more answerable way...
20:13:43 <copumpkin> that might be possible
20:14:21 <copumpkin> well the one I consider really fucking stupid is where you basically do (compareing (flip find universe))
20:14:23 <copumpkin> -e
20:14:27 <dmwit> Oh, I know why it stack overflows. I'll file a bug.
20:14:50 <dmwit> :t find
20:14:52 <lambdabot> (a -> Bool) -> [a] -> Maybe a
20:14:57 <copumpkin> oh wrong one
20:15:11 <dmwit> Here, I know another way to answer.
20:15:32 <copumpkin> but basically, take the two functions you're comparing, test each one of them for equality against the entire universe of functions until you find a match, then see which match came earlier
20:15:34 <dmwit> 	f `compare` g = mconcat [f x `compare` g x | x <- universeF]
20:15:47 <copumpkin> oh that's much smarter :(
20:17:28 <dmwit> >  let u x = y where y :: a; y = x where z = id x in u 'a' :: Bool
20:17:30 <lambdabot>   Couldn't match type `t' with `a1'
20:17:30 <lambdabot>    `t' is a rigid type variable bound by
20:17:30 <lambdabot> ...
20:17:38 <shachaf> @ty let u x = y where y :: a; y = x where z = id x in u
20:17:40 <lambdabot> a -> a1
20:17:50 <shachaf> @google unsafe coerce without extensions
20:17:53 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7453
20:17:53 <lambdabot> Title: #7453 (unsafe coerce without extensions) ‚Äì GHC
20:18:07 <shachaf> lambdabot's evaluator stops it by sheer accident
20:18:12 <shachaf> But I was hoping yours wouldn't.
20:18:21 <dmwit> ...mine *is* lambdabot.
20:18:24 <dmwit> Why wouldn't mine?
20:18:55 <shachaf> An accident involving the version of GHC that happened to be installed on that machine at the time mueval was compiled etc.
20:19:06 <dmwit> oh
20:19:30 <dmwit> Well, to be honest, I don't really know whether mueval is using 7.4 or 7.6 or what.
20:20:22 <shachaf> imo fix it so it works
20:20:34 <dmwit> "fix it so it's broken plox"
20:20:55 <dmwit> forgeeeeeet that
20:21:12 <shachaf> how else will i segfault goodfellow??
20:21:29 <shachaf> Anyway that's the only thing I was curious about, so feel free to leave the bot on or off or whatever now.
20:24:21 <elliott> < let u x = y where y :: a; y = x where z = id x in u 'a' :: Bool
20:24:23 <goodfellow>   Couldn't match type `t' with `a1'
20:24:23 <goodfellow>    `t' is a rigid type variable bound by
20:24:23 <goodfellow> ...
20:24:27 <elliott> oh, good, it's broken.
20:26:33 * dmwit pats his poor trodden laptop
20:32:29 <scooty-puff> is there a library providing only newtype Fix f = Fix { getFix :: f (Fix f) } (or that and little more)
20:32:37 <scooty-puff> hayoo gave data-fix
20:32:40 <shachaf> @hackage recursion-schemes has it
20:32:40 <lambdabot> http://hackage.haskell.org/package/recursion-schemes has it
20:32:42 <scooty-puff> but wasn't sure if others as well
20:32:44 <scooty-puff> k
21:13:30 --- mode: ChanServ set +o shachaf
21:13:59 --- topic: set to '["Hackage down; @where hackage-mirror", "Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]' by shachaf
21:14:13 --- mode: shachaf set -o shachaf
21:14:17 <shachaf> Oh, it's already listed at the end.
21:14:40 <shachaf> Oh well. People still tend to come in asking whether it's down.
21:15:51 <copumpkin> anyone have a good approach to plotting the output of kde from statistics?
21:15:59 <copumpkin> (kernel density estimate)
21:17:04 <alang> copumpkin: you can just do a linear interpolation, I think
21:17:26 <copumpkin> yeah, I mean just common packages or lightweight ways to get a picture out of my pair of vectors
21:17:50 <alang> oh
21:18:37 <alang> I don't have any good suggestions
21:19:17 <dmwit> diagrams!
21:19:40 <dmwit> I have no idea what a KDE is or what you would want to draw, but I bet diagrams is the answe.r
21:19:41 <copumpkin> does that work nicely on my mac? and I never really thought of it for charts
21:20:03 <dmwit> It... should do. It has a pure Haskell SVG backend, I think.
21:20:07 <copumpkin> sort of like a continuous histogram :)
21:20:16 <kristof> Kernel density estimates have to do with chaos theory, don't they?
21:20:23 <kristof> That, or topological mixing in deterministic processes
21:20:25 <dmwit> It also has a cairo backend, and you can install cairo without installing the rest of gtk2hs, which shouldn't be *too* painful.
21:21:05 <kristof> No, I was wrong about both. I suck!
21:22:09 <aavogt> using Chart shouldn't be too bad if you have the x,y points calculated
21:23:01 <aavogt> there are a couple bindings to gnuplot too
21:28:35 <adnap> http://downorisitjustme.com/res.php?url=hackage.haskell.org
21:30:53 <[swift]> does haskell.org go down every night or what?
21:31:05 <adnap> [swift]: No
21:31:19 <[swift]> adnap: really? coulda fooled me
21:32:10 <[swift]> actually i guess it's only hackage tonight
21:33:10 <ivanm> @where hackage-mirror
21:33:10 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
21:34:50 <Quadrescence> what is the name of a combinator f such that  f g x y == f (g x) (g y)?
21:35:27 <otters> @pl f g x y = f (g x) (g y)
21:35:28 <lambdabot> f = fix (join . ((flip . ((.) .)) .) . (.))
21:35:36 <otters> oh, I thought it was ap for a sec but clearly not
21:35:44 <shachaf> Quadrescence: Is that meant to be recursive?
21:36:08 <dmwit> :t on
21:36:09 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:36:10 <Quadrescence> no, i messed up what I meant.   f g h x y === g (h x) (h y)
21:36:16 <shachaf> Ah. Then what dmwit said.
21:36:26 <Rarrikins> @unpl ap
21:36:26 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
21:37:03 <dmwit> :t generalCategory
21:37:05 <lambdabot> Char -> GeneralCategory
21:37:13 <dmwit> < (==) `on` generalCategory
21:37:14 <goodfellow>   [('\NUL',[('\NUL',True),('\SOH',True),('\STX',True),('\ETX',True),('\EOT',T...
21:38:32 <NemesisD> @where hackage-mirror
21:38:32 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
21:38:48 <Quadrescence> dmwit, thanks
21:38:53 <NemesisD> is  someone assaulting our poor hackage?
21:39:06 <otters> :t generalCategory
21:39:08 <lambdabot> Char -> GeneralCategory
21:39:13 <otters> > generalCategory 'c'
21:39:15 <lambdabot>   LowercaseLetter
21:39:28 <otters> > generalCategory '‚Ñ¢'
21:39:29 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
21:39:31 <otters> oh
21:39:38 <shachaf> < generalCategory '‚Ñ¢'
21:39:39 <goodfellow>   OtherSymbol
21:39:43 <shachaf> dmwit++
21:39:43 <arkeet> non-ascii stuff makes lambdabot sad.
21:39:50 <dmwit> I didn't do it on purpose.
21:39:51 <arkeet> < generalCategory '‚òÉ'
21:39:52 <goodfellow>   OtherSymbol
21:40:01 <dmwit> > generalCategory '\8482'
21:40:03 <lambdabot>   OtherSymbol
21:40:03 <otters> that sounded all category-theoryish
21:40:06 <otters> but it's just a Char thing
21:40:39 <dmwit> (...does this mean Cale did something by hand that breaks Unicode?)
21:41:03 <dmwit> Oh, I bet it means I have a different locale than whatever machine runs the real \bot.
21:41:12 <arkeet> that would be my guess.
21:41:27 <shachaf> Cale hates Unicode and unicorns. :-(
21:41:35 <shachaf> And universe.
21:41:41 <shachaf> That's why dmwit had to make a bot for it.
21:41:50 <dmwit> I'll send patches when I'm not so tired. =)
21:42:03 <shachaf> < over id (+1) 5
21:42:04 <goodfellow>   Not in scope: `over'
21:42:09 <dmwit> uh
21:42:14 <shachaf> :‚òπ(
21:42:14 <dmwit> > over id (+1) 5
21:42:17 <lambdabot>   6
21:42:19 <dmwit> hum
21:42:27 <dmwit> This should be fixed before patches.
21:42:27 <shachaf> import Control.Lens
21:42:59 <dmwit> That's not imported in \bot's repository.
21:43:01 <dmwit> So it's not my fault.
21:43:03 <shachaf> Correct.
21:43:11 <shachaf> Well, you could import it.
21:43:14 <dmwit> yes
21:43:17 <shachaf> And you didn't.
21:43:29 <dmwit> THAT'S WHAT REPOSITORIES ARE FOR
21:43:32 <dmwit> =(
21:44:12 <shachaf> dmwit: Cale doesn't even manage the repository.
21:44:19 <shachaf> And he hasn't published lambdabot changes for years.
21:44:24 <shachaf> Which is why we lost the quotes file.
21:44:44 <dmwit> < over id (+1) 5
21:44:44 <goodfellow>   Could not find module `Control.Lens'
21:44:44 <goodfellow>  Use -v to see a list of the files sea...
21:44:51 <dmwit> ick
21:44:52 <shachaf> cabal install lens -w ghc-7.4.1
21:44:58 <Cale> oh, oops!
21:45:02 <Cale> err
21:45:03 <Cale> wat
21:45:14 <shachaf> < map ord ":‚ò∫)"
21:45:15 <goodfellow>   Could not find module `Control.Lens'
21:45:15 <goodfellow>  Use -v to see a list of the files sea...
21:46:05 <dmwit> Cale: I'm testing out some patches to add universe support to lambdabot, don't panic. =)
21:46:14 <dmwit> < (==) == (/=) . not
21:46:17 <goodfellow>   True
21:46:46 <arkeet> is that defaulting to () ?
21:46:51 <dmwit> no, because "not"
21:46:52 <shachaf> No, to Bool
21:47:00 <shachaf> It's saying (\x y -> x == y) == (\x y -> not x /= y)
21:47:01 <arkeet> oh duh.
21:47:02 <dmwit> < (==) == (/=) -- this one is defaulting to ()
21:47:04 <goodfellow>   False
21:47:18 <arkeet> for some reason I uh
21:47:20 <arkeet> never mind. :p
21:47:26 <shachaf> < ((==) == (/=)) /= ((==) /= (/=))
21:47:27 <goodfellow>   True
21:47:32 <shachaf> That's the spirit.
21:51:45 <dmwit> wait
21:51:57 <dmwit> How come defaulting is happening?
21:52:06 <dmwit> There should be a constraint involving a class not in Prelude.
21:54:06 <dmwit> oh, dang it, this isn't building lens at all because Hackage is down and I forgot
21:56:45 --- mode: ChanServ set +o elliott
21:57:01 --- topic: set to '["Hackage down; @where hackage-mirror","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]' by elliott
21:57:06 --- mode: elliott set -o elliott
21:57:18 <shachaf> Yay, you got rid of my space.
21:58:27 <dmwit> That's why we have ?topic-cons!
21:58:51 <dmwit> Oh ho! ghci doesn't do the defaulting
21:58:55 <shachaf> But then we need to op lambdabot.
21:58:57 <dmwit> So it's mueval's fault somehow.
21:59:05 <NemesisD> anyone read tekmo's article on defaults and monoid?
21:59:12 <dmwit> No! Nobody read it.
21:59:18 <dmwit> ?where justask
21:59:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
21:59:20 <shachaf> Sorry, NemesisD.
21:59:25 <shachaf> dmwit's right.
21:59:31 <ChongLi> dmwit: why not?
22:00:15 <NemesisD> after reading it i feel like it is eschewing the use of the Default typeclass, but how is there a sensible instance for Monoid for something like configuration datastructure
22:00:17 <dmwit> ChongLi: Because it's bad and you should feel bad!
22:00:29 <dmwit> or something
22:00:45 <shachaf> I already feel bad.
22:00:48 <shachaf> Does that count?
22:01:07 <NemesisD> i.e. data Configuration = Configuration { authToken :: String, username :: String }, is there a sensible mappend for that? why is using Default not preferable?
22:01:26 <shachaf> Maybe the article isn't sensible.
22:02:10 <NemesisD> i don't think im experienced enough to say. what do you think?
22:02:16 <dmwit> There's no sensible mappend. But there's no sensible default, either.
22:02:51 <dmwit> (There's probably an implementation of Default that's worth writing. But it's not a sensible default -- you wouldn't want to ever use the default value without overriding both fields, I would guess.)
22:02:58 <NemesisD> dmwit: i realize i chose a really poor example, how about data ClientConfiguration { baseUrl :: String, apiVersion :: String }
22:03:19 <adnap> Will smartphones ever be made with x86 architecture so it is easy to compile (haskell) programs for them?
22:03:23 <dmwit> That doesn't seem significantly different to me.
22:03:34 <dmwit> adnap: My goodness, I hope not.
22:03:34 <NemesisD> dmwit: there's a sensible default there
22:03:40 <dmwit> The sooner we drop x86 on the floor the better.
22:03:47 <adnap> x86_64
22:04:01 <dmwit> RISC is the future, maaaaan
22:04:13 <NemesisD> but i fail to see the sensible mappend
22:04:21 <adnap> I just want GHC to compile to ARM then
22:04:23 <dmwit> What is the sensible default?
22:04:45 <dmwit> adnap: Oh, yes, that's coming soon.
22:05:00 <dmwit> I think you can already do some bits of it if you're okay with compiling GHC yourself.
22:05:03 <NemesisD> dmwit: say ClientConfiguration "production-api.example.com" "V2", that being the target api version and known production sever of an api
22:05:14 <dmwit> Like they have GHC running on the Raspberry Pi. So.
22:05:14 <adnap> I hope it will be the newest GHC that can do it
22:05:15 <NemesisD> dmwit: the default being overridden for say testing purposes
22:05:23 <adnap> GHC 7.4
22:05:47 <dmwit> 7.4 isn't even the newest released GHC right now, let alone the newest GHC
22:06:02 <adnap> Oh
22:06:17 <adnap> Well, a lot of haskell packages require newer versions of GHC. That's my only concern
22:06:39 <adnap> Because old versions don't support certain language extensions I guess
22:07:09 <dmwit> NemesisD: I bet I can invent a sensible mappend for that.
22:07:51 <shachaf> NemesisD: I would say that strings like this don't belong in type class instances.
22:07:55 <shachaf> But maybe I'm just a h8r.
22:08:14 <NemesisD> dmwit: what would your mappend be for that?
22:08:54 <dmwit> mappend a a' | a' == "V2" = a | otherwise = a'
22:08:57 <dmwit> likewise for the URL part
22:09:10 <dmwit> and then the obvious monoid product
22:09:18 <shachaf> Some people use Last a instead of a for their configuration.
22:09:30 <NemesisD> shachaf: the actual values could be constants but for the end user, using def is pretty nice. i guess the alternative is to not define a default and just have a defaultConfiguration :: Configuration
22:09:43 <dmwit> Exactly; like Last a but with something other than Nothing as the mempty.
22:10:39 <shachaf> Anyway the trouble with Default is that you know pretty much nothing about it -- no laws or anything like that. With Monoid you at least get something. I suppose that's his point.
22:10:42 <dmwit> < over id (+1) 5
22:10:44 <goodfellow>   6
22:11:03 <dmwit> < (==) :: Word8 -> Word8 -> Bool
22:11:05 <goodfellow>   [(0,[(0,True),(1,False),(2,False),(3,False),(4,False),(5,False),(6,False),(...
22:11:10 <shachaf> On the other hand maybe you should take anything that Tekmo says involving associativity with a grain of salt. :-)
22:11:37 <NemesisD> dmwit: seems like for records with just a few more fields that will turn into lots of boilerplate. why is this better than the typeclass Default, whose stated goal is to provide defaults?
22:12:16 <dmwit> I'm pretty sure I never claimed Monoid was "better" than Default.
22:12:21 <dmwit> I use Default all the time, and I love it.
22:12:28 <NemesisD> oh ok
22:12:50 <mauke> it's so easy
22:13:03 <NemesisD> the article just seemed to take it for granted that Default is antipattern and im not sure why
22:13:33 <dmwit> But I also think it's more or less fair to say that any instance of Default where there's no sensible mappend probably also isn't a sensible default.
22:14:06 <dmwit> (Note that I'm keeping "sensible" and "worth writing" as independent characteristics, as I mentioned above!)
22:14:13 <NemesisD> lol
22:14:23 <Kaidelong> which article was this?
22:14:56 <NemesisD> i guess what i'm trying to say is: guys, I disagree with someone on the internet. is there something wrong with me?
22:14:56 <dmwit> shachaf: 'k, lens is in, are you happy now
22:15:11 <shachaf> dmwit: I'm never happy!
22:15:11 <NemesisD> http://www.haskellforall.com/2013/04/defaults.html
22:16:20 <dmwit> Hm, I wonder if it's actually possible to write a Universe instance for Double.
22:16:28 <dmwit> NaN probably screws up the promise, doesn't it?
22:16:34 <shachaf> What's the promise?
22:16:44 <shachaf> x `elem` universe?
22:16:49 <dmwit> Every (defined) inhabitant occurs at a non-infinite index in universe.
22:16:52 <shachaf> For all non-‚ä• x?
22:16:56 <dmwit> right
22:16:58 <shachaf> If it's defined with Eq then yes.
22:17:07 <shachaf> Is it?
22:17:21 <dmwit> I don't understand the question.
22:17:32 <shachaf> What does it mean to say that it occurs?
22:17:39 <shachaf> (==)-equal?
22:17:44 <dmwit> ah
22:18:04 <shachaf> > isNaN (0/0) -- NaNs are distinguishable, at least
22:18:11 <lambdabot>   True
22:18:18 <dmwit> I'm looking at what the current haddocks say, but I don't think I thought about it before carefully, so...
22:19:44 <dmwit> I think I'm too tired to make a sane decision about what kind of equality to use.
22:20:33 <Kaidelong> all that article seems to say is to make a monoid typeclass before you make a default typeclass
22:20:48 <Kaidelong> rather than saying that default is opposed to monoid
22:21:05 <shachaf> The author is a big fan of associativity.
22:21:08 <dmwit> < U.universe :: (Int, Int)
22:21:08 <Kaidelong> because if your monoid's mappend is overcomplicated then you've chosen a bad default
22:21:09 <goodfellow>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
22:21:09 <goodfellow>              ...
22:21:16 <dmwit> < U.universe :: [(Int, Int)]
22:21:18 <goodfellow>   [(-9223372036854775808,-9223372036854775808),(-9223372036854775807,-9223372...
22:21:25 <dmwit> ugh
22:21:32 <dmwit> < U.universe :: [(Word8, Word8)]
22:21:34 <goodfellow>   [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0...
22:21:42 <dmwit> < U.universeF :: [(Word8, Word8)]
22:21:43 <goodfellow>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),...
22:21:52 <Kaidelong> I suppose I am too because commutativity implies it and I'm a fan of that
22:24:25 <mzero> yikes - what is up with our infrastructure?
22:24:43 <shachaf> mzero: You should rather ask what is down with our infrastructure.
22:25:31 <mzero> "Yo dawg! If I wuz down with our infrastructure, I wouldn't be askin' whass'up, ya dig?"
22:25:39 <elliott> Kaidelong: it does?
22:25:56 <dmwit> Kaidelong: yeah, what?
22:26:24 <dmwit> < let commutative f = and [f x (f y z) == f (f y z) x | (x, y, z) <- U.universe]; associative f = and [f x (f y z) == f (f x y) z | (x, y, z) <- U.universe] in length [f | f <- U.universe :: [Ordering -> Ordering -> Ordering], commutative f && not (associative f)]
22:26:26 <goodfellow>   666
22:26:40 <elliott> one might say: I hate commutativity. it's not as easy as I thought.
22:27:06 <shachaf> Commutativity implies associativity. Proof: If it didn't, wouldn't there be some interesting algebraic structure that was commutative but not associative?
22:27:11 <shachaf> But there isn't. QED
22:27:56 <cmears> Addition/multiplication on floating point numbers
22:28:12 <shachaf> I said "algebraic".
22:28:40 <cmears> it's not algebraic?
22:28:47 <shachaf> No. It's floating point.
22:29:10 <ryant50001> shachaf: https://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma
22:29:48 <dmwit> Hah, the two functions of type Bool -> Bool -> Bool that are commutative but not associative are nand and nor.
22:29:52 <Kaidelong> oh I see
22:30:11 <shachaf> ryant50001: You've discovered the only flaw in my proof.
22:30:16 <Kaidelong> I suppose if something is both commutative and there is some element of what I've been calling monotonicity
22:30:21 <dmwit> I therefore conclude that functions that are commutative but not associative are the most interesting of all! They're the ones that give you Turing completeness.
22:30:32 <mzero> aw c'mon - nand is interesting, right? I'm mean, who'd use that to build anyth.... oh never mind
22:30:46 <ryant50001> shachaf: lol
22:31:02 <shachaf> dmwit: Turing completeness is boring.
22:31:07 <shachaf> Can't prove nothin' about it.
22:31:15 <shachaf> (Well, you can. But not in general.)
22:31:20 <dmwit> Nonsense. You just can't write an algorithm to...
22:31:20 <dmwit> yeah
22:32:12 <Kaidelong> Anyway I've been working on an exercise where commutativity did actually imply associativity but that's because the result of the appending operation had to preserve information about all its operands
22:32:29 <Kaidelong> a git-like version control system where forks can be represented as queries
22:32:46 <shachaf> You're setting yourself up for failure (or success) by calling it an appending operation.
22:33:06 <dmwit> Yeah, call it composition instead!
22:33:17 <Kaidelong> I've been calling it patching
22:33:19 <shachaf> I,I concatenation
22:33:31 <dmwit> I,I I,I is overused by shachaf
22:33:33 <Kaidelong> although specifically patches have to be commutative
22:33:53 <Kaidelong> which means I don't really get to work with plain text as an actual version control system
22:34:00 <shachaf> Ai-yai-yai.
22:34:11 <Kaidelong> application I am making is java-specific
22:34:24 <Kaidelong> although I think you could apply the general idea elsewhere
22:34:26 <dmwit> Kaidelong: Have you seen the "editing is dual to exceptions" blog post?
22:34:39 <Kaidelong> I do not believe I have
22:34:59 <dmwit> http://bosker.wordpress.com/2012/05/10/on-editing-text/
22:36:10 <Kaidelong> one big problem with the whole patching thing was that it was possible to come up with queries of the form ab/c where ab = 0 but ab/c doesn't
22:36:21 <Kaidelong> I am not sure if that's really a problem
22:36:25 <Kaidelong> but it's a little bit unsettling
22:36:26 <mzero> too much Haskellin' to do: talk on 4/19, HP releases 4/22 ~ 5/13, BayHac 5/17.... and all I really want to do is code on my project.... OY!
22:36:52 <Kaidelong> (the requirement being that either a or b divides into c)
22:37:10 <shachaf> mzero: What talk?
22:37:26 <Kaidelong> actually the whole edifice would collapse if that wasn't true so I suppose it's a problem of notation, not a problem of the design
22:37:40 <mzero> At Haskell Hackers at Hacker Dojo on the 19th I'm talking about Plush
22:37:47 <sacundim> hmmm
22:37:51 <shachaf> That's on the 19th?
22:37:53 <shachaf> Did it move?
22:38:00 <mzero> d'oh
22:38:01 <mzero> 18th
22:38:08 <sacundim> hacker dojo is that place in mountain view?
22:38:10 <shachaf> Ah, OK.
22:38:16 <shachaf> sacundim: Yes.
22:38:16 <shaladdle> Hi folks, a bit of a newb here. Wondering why when I type 1-0.9 into ghci I get 9.999999999999998e-2 and not 0.1..
22:38:19 <sacundim> oh
22:38:21 <mzero> yup (though it moved recently if you were there last year)
22:38:34 <shachaf> shaladdle: Because floating points.
22:38:38 <shachaf> @google floating point
22:38:39 <lambdabot> http://en.wikipedia.org/wiki/Floating_point
22:38:40 <lambdabot> Title: Floating point - Wikipedia, the free encyclopedia
22:38:42 <mzero> shaladdle: for the same reason you do in any language with floating point
22:38:43 <dmwit> shaladdle: Google "what every programmer absolutely needs to know about floating point".
22:38:44 <shaladdle> but
22:38:47 <sacundim> bah, 18th is a weekday
22:38:49 <shaladdle> haskell haves infinite precision
22:38:50 <shaladdle> ?
22:39:00 <mzero> not for floats it does not
22:39:01 <shaladdle> or was that a lie I was fed?
22:39:03 <sacundim> or, alternatively, bah, my work schedule sucks
22:39:04 <dmwit> shaladdle: Sure, give it a type signature.
22:39:07 <shachaf> Not with the default type for 0.9
22:39:08 <dmwit> shaladdle: 0 - 0.9 :: Rational
22:39:14 <dmwit> > 1 - 0.9 :: Rational
22:39:16 <lambdabot>   1 % 10
22:39:22 <shaladdle> ermemremrme
22:39:25 <shaladdle> is there ::Real or something?
22:39:33 <shachaf> Yes, but real numbers are tricky.
22:39:35 <dmwit> Yes, but why do you ask?
22:39:42 <shaladdle> why limit myself to rational numbers?
22:39:46 <shaladdle> doing calculations for probability things..
22:39:52 <shaladdle> I guess they will all be rational
22:39:54 <dmwit> Why not limit yourself to rational numbers?
22:39:57 <shaladdle> but I don't see why I should limit myself
22:40:01 <shaladdle> :P
22:40:03 <shachaf> dmwit: Because you wnt to take square roots?
22:40:10 <dmwit> Because rationals enjoy many decidable algorithms that computable reals do not.
22:40:12 <dmwit> Like equality.
22:40:17 <mzero> shaladdle: because "unlimited precision" and "irrationals" don't go together in finite computers
22:40:27 <shaladdle> but lazy
22:40:31 <shaladdle> :(
22:40:32 <shaladdle> my dreams
22:40:34 <shaladdle> are all being killed
22:40:38 <dmwit> mzero: pft, your imagination is just too small
22:40:42 <dmwit> > pi :: CReal
22:40:44 <lambdabot>   3.1415926535897932384626433832795028841972
22:40:58 <shaladdle> wait but why is :: Real complicated?
22:41:00 <sacundim> what happens if i try > pi == pi
22:41:05 <shaladdle> or is that not a thing
22:41:06 <mzero> dmwit: - I'm certain my imagination is finite ... but fortunately big enough that I can't see the end
22:41:07 <sacundim> oh, wait, types
22:41:08 <shaladdle> CReal != Real?
22:41:14 <shachaf> sacundim: It'll compare about 40 digits in and then give up.
22:41:30 <dmwit> shaladdle, sacundim: As I said: :: Real is complicated because it doesn't have as many decidable algorithms.
22:41:35 <dmwit> Like (==).
22:41:35 <Kaidelong> so it's not infinite precision
22:41:48 <sacundim> does "give up" mean True or bottom?
22:41:52 <shachaf> It means True.
22:41:54 <dmwit> It is infinite precision. But (==) is incorrect, and can't be correct at the type it has.
22:41:59 <sacundim> > pi == pi :: CReal
22:42:01 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
22:42:02 <lambdabot>              with ac...
22:42:05 <shaladdle> I mean seems like if you're not doing integers/rationals you want to do |a-b| < epsilon
22:42:07 <shaladdle> not ==
22:42:08 <dmwit> > pi :: (pi :: CReal)
22:42:10 <lambdabot>   Illegal kind: `Data.Number.CReal.CReal'
22:42:10 <lambdabot>    Perhaps you intended to use -XDa...
22:42:12 <dmwit> > pi == (pi :: CReal)
22:42:14 <lambdabot>   True
22:42:31 <dmwit> shaladdle: (<) is also not decidable for computable reals.
22:42:38 <shaladdle> wat
22:42:40 <shaladdle> why not?
22:42:47 <shachaf> Because you could use it to decide (==). :-)
22:42:48 <Kaidelong> what's pi < pi
22:42:49 <dmwit> shaladdle: Well, try to think about how to do it. =)
22:43:00 <shaladdle> false
22:43:04 <dmwit> shaladdle: Think out loud in-channel if it will help.
22:43:08 <sacundim> shaladdle: try implementing a terminating (<) for infinite lists
22:43:19 <Kaidelong> but maybe the 3042349067548934769th digit is different shaladdle?
22:43:25 <Kaidelong> did you calculate it that far
22:43:57 <shaladdle> well, like if they are really similar it won't terminate for forever
22:44:05 * sacundim thinks of all the things he could do if he could compare arbitrary computable reals
22:44:11 <shaladdle> if they are different it will though
22:44:20 <dmwit> shaladdle: If they are not different? Will it terminate then?
22:44:28 <shaladdle> seems like it hsould
22:44:29 <shaladdle> should*
22:44:37 <dmwit> How would it terminate?
22:44:47 <Kaidelong> sacundim: I think you theoretically may be able to but you'd need a black hole as a component of your computer
22:44:51 <sacundim> shaladdle: a computable real number is a real number such that a computer program can generate all of its digits.
22:44:54 <dmwit> At which digit would it stop and say "yup, they're equal!"?
22:45:04 <shachaf> dmwit: 40, hth
22:45:07 <sacundim> this is getting into computing whether two programs always produce the same result
22:45:25 <Kaidelong> I think that is something that a hypercomputer could theoretically actually decide, but not for its own program
22:45:41 <lispy> sacundim: You could think about assigning numbers to all possible programs ...
22:45:43 <shaladdle> wait
22:45:46 <Kaidelong> and a hypercomputer might be buildable using a black hole
22:45:48 <shachaf> Kaidelong: You'd need a black hole as a component of your computer because if you had one of those, you would die, and then you wouldn't care?
22:45:49 <sacundim> yup
22:45:52 <shaladdle> why is this important to me?
22:45:53 <dmwit> Anyway, yeah, Rational is nice, and the cyclotomic numbers are nice if you want some more algebraic things and maybe complex numbers.
22:45:56 <shaladdle> I don't want to use ==
22:46:09 <shaladdle> I Just want 1 - 0.9 to be 0.1 :(
22:46:22 <dmwit> If that's all you want, Rational seems like more than enough for you. =)
22:46:26 <dmwit> Plus you get (==)!
22:46:28 <shaladdle> lulz
22:46:31 <mzero> what dmwit said
22:46:35 <shaladdle> wat
22:46:37 <Kaidelong> shachaf: I actually don't remember the details, but it had something to do with being able to do infinitely long computations in constant time
22:46:53 <Kaidelong> due to an interaction of quantum entanglement and time dialation that is theorized
22:47:00 <Kaidelong> and probably doesn't actually exist
22:47:11 <lispy> Rational isn't that nice simply because innocuous calculations can blow up and give you ratios where either the denominator or numerator are quite large
22:47:13 <Kaidelong> and only illustrates that people don't actually know the physics of black holes
22:47:14 <mzero> please tell me, shaladdle, that you didn't run accross this problem while trying to represent currency....
22:47:22 <dmwit> data ShaladdleNumbers = One | PointNine | PointOne
22:47:24 <lispy> (at least, when it's a Rational over Integers)
22:47:37 <shaladdle> roflroflrofl
22:47:43 <shaladdle> You guys are out of control
22:47:48 <voxpopuli> I can't even handle this irc channel
22:47:49 <mzero> yes, yes we are
22:47:55 <dmwit> lispy: (type Rational = Ratio Integer)
22:48:50 <mzero> all this fun here in this channel, I'm stuck catching IOExceptions while doing socket binding.....
22:48:51 <Kaidelong> I think it was something like
22:48:52 <dmwit> Anyway, CReal isn't exactly nicer than Rational in that regard. It still has big numbers, they're just hidden in a closure.
22:49:47 <lispy> Double has really nice properties when it comes to predictability of run-time.
22:50:03 <lispy> But that pesky "approximate" part is still a pain.
22:50:03 <dmwit> Yup. On the other hand... it's Double.
22:50:04 <dmwit> =(
22:50:12 <no-n[5]> http://hpaste.org/85578 <-- this does what's described in line 4 AFTER doing what's described in line 5 for me.
22:50:24 <dmwit> Oh, there's another choice that nobody has mentioned, which is to do fixed-point arithmetic.
22:50:29 <dmwit> There must be a library for that on Hackage.
22:50:32 <no-n[5]> I want the input to be on the same line as the "What do you want? "
22:50:33 <Kaidelong> http://en.wikipedia.org/wiki/Malament-Hogarth_spacetime
22:50:37 <Kaidelong> it looks like the idea is
22:50:39 <mzero> no-n[5]: that's because your streams are line buffered
22:50:44 <Kaidelong> drop a computer down a black hole
22:50:53 <lispy> dmwit: what is the significant difference between fixed point and double?
22:50:55 <shaladdle> is the 1-0.9 thing a rounding error in the 32 bit IEEE float or whatever? I feel like that's a number it should be able to do, but I don't quite remember back to that part of intro to systems
22:50:56 <no-n[5]> mzero: how do I fix it?
22:50:58 <mzero> or rather, stdout is line buffered by default
22:51:04 <Kaidelong> and get a result of something that should take forever
22:51:07 <mzero> :t hSetBuffering
22:51:08 <lambdabot> Not in scope: `hSetBuffering'
22:51:27 <lispy> dmwit: fixed point, what little I know of it, seems like how I would emulate double if I didn't want to implement all the craziness.
22:51:41 <cmears> no-n[5]: you can use hFlush to flush the output
22:51:47 <dmwit> lispy: I suppose I'm thinking of decimal fixed-point representations. So the difference is that it looks a bit better for numbers I type in at ghci.
22:52:01 <no-n[5]> ok
22:52:06 <Kaidelong> so yeah, with a black hole you can perhaps solve the halting problem apparently
22:52:10 <mzero> no-n[5]:    hSetBuffering stdout LineBuffering
22:52:22 <mzero> no-n[5]:    hSetBuffering stdout NoBuffering
22:52:24 <mzero> rather
22:52:41 <dmwit> shaladdle: 0.9 isn't exactly representable as a Double. Neither is 0.1. It turns out that the not-quite-exact representation of 0.1 computed by 1-0.9 isn't quite the same as the not-quite-exact representation of 0.1 that's closest to 0.1.
22:52:42 <mzero> personally, I find code littered with hFlush ugly
22:52:57 <sacundim> bah, that black hole stuff is too physical for my taste.  i just like to think of the amazing leaps of logic i could take with the help of a hypercomputer
22:53:07 <no-n[5]> hmm. what module is that in? HOogle is down
22:53:14 <mzero> System.IO
22:53:17 <no-n[5]> ty
22:53:19 <shachaf> Note that NoBuffering in Haskell is going to be much less efficient than you'd expect given NoBuffering in most other languages.
22:53:22 <mzero> np
22:53:27 <shachaf> @where hayoo
22:53:28 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:54:14 <mzero> sell, dmwit & shaladdle - had we all listened to Collinshaw sooner, we'd have decimal based floating point in all our HW and libs, and..... shaladdle never would have noticed!
22:54:15 <shaladdle> hrm
22:54:21 <dmwit> shaladdle: Again, a read through http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html will do you much more good than experimenting in ghci or asking tons of questions here, if you absolutely must know what the deal with Double is.
22:54:24 <no-n[5]> doesn't seem to be fixing it
22:54:39 <no-n[5]> oh
22:54:39 <shaladdle> cool, thanks dmwit!
22:54:41 <mzero> did you do that BEFORE line 4
22:54:46 <no-n[5]> that's because I ran the wrong .hs file sorry :P
22:55:11 <Kaidelong> that article also mentions the idea of the observer of the solution crossing the inner event horizon
22:55:18 <mzero> actually, the one successful language system I designed and built *did* have decimal floating point numbers
22:55:23 <Kaidelong> which I suppose somewhat limits the utility of any such a machine
22:55:41 <mzero> It was kinda fun implementing all those floating point algo.s in Knuth .....
23:28:30 <coppro> man, google is creepy
23:29:04 <Ralith> what'd they do this time
23:29:28 <coppro> type in "exam schedule" into google
23:29:51 <coppro> is your first hit the univetrsity of waterloo final examination schedule?
23:30:22 <Kaidelong> University of Washington
23:31:01 <coppro> Kaidelong: do you live anywhere near and/or go to the university of Washington?
23:31:22 <Kaidelong> define "near".
23:31:23 <Kaidelong> also no
23:31:23 <shachaf> This sounds off-topic.
23:31:28 <Kaidelong> yes it does
23:31:38 <Kaidelong> -blah bitte
23:31:38 <coppro> oh, crap, this is the wrong channel
23:31:39 <coppro> my bad
23:31:43 <coppro> sorry!
23:56:12 <circle> what does "deriving eq" mean
23:56:37 <shachaf> I think most introductions to Haskell cover it. Is there any introduction that you're reading?
23:57:09 <shachaf> It's a syntax error. But "deriving Eq" means "use magic to make this type an instance of Eq", which in turn lets you compare values with (==).
