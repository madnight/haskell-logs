00:00:02 <Ralith> circle: filter composed with (map (fromMaybe x))?
00:00:25 <Ralith> er, not filter
00:01:26 <circle> if not filter then what?
00:01:44 <flebron> map (\x -> if f x then x else y)
00:03:33 <circle> thank you flebron
00:14:11 <shachaf> pdxleif: Well, why not annotate your types?
00:15:32 <dolio> Annotate your types, or annotate things with type?
00:15:50 <dolio> Do you apply functions to arguments or apply arguments to functions?
00:16:00 <shachaf> I think the former.
00:16:07 <shachaf> dolio: I think this is about annotating types with kinds.
00:16:14 <dolio> Oh, okay.
00:16:39 <dolio> I think people use 'apply' both ways.
00:18:26 <Ralith> I only use it the first way
00:19:03 <shachaf> Perhaps you apply force to a thunk, until it's evaluated.
00:20:20 <flebron> is it likely we'll ever have an extension that allows dependent types?
00:20:26 <flebron> or would that need deep changes to Core?
00:22:58 <pdxleif> shachaf: Yeah, I was thinking kind annotations.  I have two type aliases right next to each other, was wondering if it might be easy to overlook that they have different kinds.
01:26:23 <drbean> I found .cabal/bin in my PATH, but I thought it had to be put there manually.
01:26:42 <drbean> What could have put it there?
01:28:35 <CADD> drbean: lol, computers dont do things on their own you know
01:28:47 <CADD> drbean: you probably put it there some time ago and forgot about it
01:28:56 <CADD> drbean: i hsvr .cabal/bin in my $PATH
01:29:18 <drbean> It's in my .bash_profile.
01:29:56 <elliott> "computers don't do things on their own" has to be one of the most manifestly false things I've read this month
01:30:58 <sipa> elliott: they don't do things on their own, unless you tell them to :p
01:31:21 <elliott> my computer does lots of things just because I feed it electricity
01:31:29 <elliott> at most you can argue I told it to do them because I installed an operating system
01:32:50 <CADD> sipa: precisely
01:33:16 <elliott> in particular, it would be very easy for cabal-install's installation process to add a PATH-extending snippet to bashrc
01:33:21 <elliott> and plenty of software does similar stuff
01:33:38 <elliott> it *doesn't* do that, but a distro package might... but still, it's not obviously ridiculous
01:34:12 <CADD> elliott: you are right, there should be no reason why an install should change your bashrc
01:34:26 <CADD> but screw bash, zsh is where its at
01:35:03 <kryft> What's so great about zsh?
01:35:06 <adnap> qP<G
01:35:08 <adnap> OMG
01:35:12 <adnap> Yes, please tell me
01:35:19 <kryft> (Actually nevermind, this is clearly OT :P)
01:35:30 <adnap> I always hear saying zsh is great, and I don't know what is so wrong with bash
01:35:35 <supki_> create thing about zsh is that it's offtopic here
01:35:38 <adnap> *people saying
01:35:42 <supki_> s/create/great/
01:35:55 <adnap> Okay, nevermind
01:36:48 <CADD> adnap: go to haskell-blah, ill tell you all about it
01:39:34 <BoR0> how can I beautify treeToList here ? http://lpaste.net/90799
01:44:41 <supki_> BoR0: I did annotate with how I would do it (untested)
01:45:13 <BoR0> oh, cool, very nice
01:45:16 <BoR0> thank you
01:45:51 <supki_> :)
01:49:06 <banister`gym> is function composition more analogous to addition or multiplication?
01:50:13 <mauke> banister`gym: no
01:50:25 <mauke> it's all monoids
01:50:40 <banister`gym> mauke: hehe, im just porting composition to another language and wondering whether i should use the + or * for composition
01:50:47 <banister`gym> mauke: which do u think is the more apt symbol
01:51:09 <mauke> neither
01:51:51 <banister`gym> mauke: if forced to choose however since the language supports nothing else
01:53:19 <tero-> uh, using one of those could be very confusing
01:53:29 <mauke> what is this, C++?
01:54:25 <banister`gym> mauke: ruby https://github.com/banister/funkify
01:58:59 <mstksg> *
01:59:15 <mstksg> considering the mathematical copmposition notation
01:59:17 <mstksg> is a circle
01:59:28 <circle> n
01:59:34 <mstksg> also if you consider linear algebra
01:59:42 <mstksg> if a matrix is a function on a vector
01:59:51 <mstksg> matrix compositoin is matrix multiplication
02:00:28 <mstksg> er
02:00:32 <mstksg> function composition is matrix muiltiplcation
02:01:35 <shachaf> * is better for composition but neither is that great.
02:02:28 * mauke ponders * for string concatenation
02:04:35 <shachaf> mauke: Free monoid! Sounds good to me.
02:04:45 <shachaf> 1 for the empty string might be stretching it a little bit.
02:05:05 <mauke> I love it
02:05:24 <mauke> if you can use 0 for null pointers, you can use 1 for empty strings
02:06:06 <Hafydd> If Node.js is suicide, what is Haskell?
02:06:43 <supki> banister`gym: you can compose binary and unary operators to get sort of custom operators like <-
02:06:49 <CADD> Hafydd: lol
02:06:55 <CADD> Hafydd: nirvana
02:07:48 <diabel232> why main command is called cabal ?
02:07:59 <CADD> mauke: speaking of monoids, i remember the day when i leared that a category with one object is a monoid. holy bawls
02:08:00 <quchen> supki: I think you just chose the only operator you cannot define yourself there :P
02:08:25 <banister`gym> supki: i have a find of do-notation implementation in ruby too, i'll probably save <- for that ;)
02:08:51 <quchen> (Well, not the only one, but one of the few reserved ones.)
02:09:04 <Hanyou> Can I ask a newbie question here?
02:09:17 <MasseR> Of course
02:09:34 <Hanyou> :) I have this function that I think ought to be type Integral t => (t, [t]) -> (t, [t]), but GHCi says it's type (Floating t, Integral t, RealFrac t) => (t, [t]) -> (t, [t]).
02:10:13 <Hanyou> And when I try to use it it gives me an error about Floating Integers and RealFrac Integers and I have no idea what that is.
02:10:14 <quchen> Hanyou: Could you paste your function?
02:10:16 <quchen> @where paste
02:10:16 <lambdabot> http://paste.tryhaskell.org/new/haskell
02:10:43 <mauke> Hanyou: because you used /
02:11:23 <Hanyou> http://lpaste.net/90802
02:11:40 <mauke> oh, you used sqrt
02:11:41 <Hanyou> whoops
02:11:43 <mauke> :t sqrt
02:11:44 <lambdabot> Floating a => a -> a
02:11:49 <mauke> :t floor
02:11:50 <lambdabot> (Integral b, RealFrac a) => a -> b
02:11:51 <Hanyou> but then I floor
02:11:54 <Hanyou> ohhh
02:12:00 <quchen> Hanyou: sqrt requires Floating
02:12:07 <mauke> floor requires RealFrac
02:12:24 <Hanyou> how do I make the floor into an Integer
02:12:59 <mauke> wrong
02:13:09 <mauke> you can't use sqrt on integers
02:13:15 <Hafydd> Use sqrt . fromIntegral instead of sqrt.
02:13:42 <Hanyou> ahh, that makes sense.
02:14:23 <Hafydd> But there might be a better way of expressing your inequality, that doesn't involve fractional numbers...
02:15:01 <quchen> What Hafydd said.
02:15:41 <Hanyou> I'm writing a simple primality tester so I only want to test divisiblity up to the square root of the number.
02:15:42 <quchen> Calculating a square root is computationally intensive compared to other operations.
02:16:25 <Hafydd> n < sqrt(a) if and only if n^2 < a or n < 0
02:19:11 <Hanyou> oh, of course. So I could just change the line to: n ^ 2 < a
02:19:47 <Hanyou> n is never less than 0.
02:21:09 <Hanyou> yay it worked! thanks guys!
02:21:59 <Hanyou> I was thinking that as long as the output was an Integer it would be alright, but the input needed to be an Integer too.
02:22:13 <Hafydd> However, it can be that n = floor(sqrt(a)), but n < sqrt(a) (e.g. n=1, a=2), so n < floor(sqrt(a)) is not equivalent to n < sqrt(a). You either intended to use <= instead of =, or didn't intend to use floor.
02:22:20 <Hafydd> <= instead of <, I mean.
02:23:18 <Hanyou> I was only using floor to make it an Integer.
02:24:22 <Hanyou> For my purposes I could have also used ceiling and it would be correct, but less efficient.
02:26:30 <BoR0> if I have data Test = MyType Integer deriving (Show). then when I try >MyType 3. can I get just the 3 instead of "MyType 3" ?
02:26:47 <BoR0> when typing "MyType 3" that is, not through a function
02:26:53 <quchen> BoR0: No, the automatically derived Show instance can't be influenced.
02:26:57 <BoR0> I see
02:27:17 <quchen> You can of course write your own "showMyType (MyType x) = show x" function.
02:27:27 <quchen> That one would only print "3".
02:27:45 <Hafydd> instance Show MyType where { show (MyType x) = show x }
02:28:41 <mstksg> sometimes i do wish there was a way to specify deriving show on a specific field of a record syntax data type and such
02:29:08 <quchen> Note that the Show typeclass is not thought for prettyprinting, but for showing data structures. A "MyType 3" should look different than a "3", unless you're just hacking around of course.
02:29:11 <mstksg> but if you think of "show" as the inverse of "read", then the way it's derived makes sense
02:29:14 <BoR0> Hafydd, for that I get Not in scope: type constructor or class `MyType'
02:29:31 <mstksg> it should be instance Show Test
02:29:36 <Hafydd> Yes.
02:30:00 <chrisdone> :t let bind x y = \z -> y >>= flip x z in bind
02:30:01 <lambdabot> Monad m => (a -> b1 -> m b) -> m a -> b1 -> m b
02:30:09 <BoR0> cool!
02:30:10 <chrisdone> does this exist anywhere?
02:30:49 <mstksg> why the lambda expression?
02:31:00 <chrisdone> who cares?
02:31:13 <mstksg> jw
02:31:50 <Hafydd> The monomorphism restriction, maybe?
02:32:08 <mstksg> i genuinely don't know; just wondering
02:32:26 <chrisdone> no, i just wrote it like that for style. it makes no difference to the type system
02:32:38 <chrisdone> this is the interesting part: Monad m => (a -> b1 -> m b) -> m a -> b1 -> m b
02:39:51 <chrisdone> > flip runState [1,2,3] $ runWriterT $ bind forM_ get $ \x -> tell [x*2]
02:39:55 <lambdabot>   mueval-core: Time limit exceeded
02:40:02 <chrisdone> > flip runState [1,2,3] $ runWriterT $ bind forM_ get $ \x -> tell [x*2]
02:40:05 <lambdabot>   (((),[2,4,6]),[1,2,3])
02:41:02 <chrisdone> > flip runState [1,2,3] $ runWriterT $ bind forM get $ \x -> do tell [x*2]; return x
02:41:06 <lambdabot>   mueval-core: Time limit exceeded
02:41:17 <chrisdone> bah, lambdabot is pretty useless at the moment
03:02:14 <banister`gym> technically haskell does not support partial application right? since all functions are in fact curried you're not partially applying arguments but just providing arguments for each successive function ?
03:02:28 <banister`gym> providing the single argument for*
03:07:30 <yitz> banister`gym: that is exactly what partial application means. so yes, Haskell supports partial application.
03:12:41 <mauke> banister`gym: correct
03:12:55 <mauke> yitz: I don't think that's what partial application means
03:13:40 <shachaf> @quote partial.application
03:13:40 <lambdabot> ddarius says: (f x) is a partial application iff f x == (curry (uncurry f) x)
03:14:53 <mauke> consider: function sort(compare :: a -> a -> Ordering, list :: [a]) :: [a]; ... let f = sort(list = ["foo", "bar", "baz"]) in f(compare = comparing length)
03:15:09 <merijn> banister`gym: You're right for some value of right ;)
03:15:09 <mauke> isn't that partial application?
03:15:36 <merijn> mauke: THose are default arguments, not partial application
03:15:43 <mauke> whoa
03:15:50 <mauke> I disagree
03:19:24 * hackagebot helm 0.1.0 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.1.0 (ZackCorr)
03:26:01 <benmachine> I think that while it's true Haskell doesn't really have a thing in the language that is partial application
03:26:17 <benmachine> I think it's at least misleading if not downright wrong to say it "doesn't have partial application"
03:26:30 <shachaf> ddarius's definition seems to be a great one.
03:27:01 <benmachine> we are encouraged, both informally and syntactically, to think of a type a -> b -> c as a type of two-argument functions
03:27:02 <shachaf> It covers the type, nontermination, other effects (if Haskell had any).
03:27:36 <benmachine> I don't think this is wrong; it's *also* a type of one-argument functions, but no-one said those had to be different
03:28:09 <benmachine> anyway if you accept that a -> b -> c is a type of two-argument functions then you must surely also accept that Haskell allows you to partially apply them
03:28:55 <shachaf> a -> b -> c might be the type of three-argument functions too, if c = d -> e :-)
03:32:17 <mauke> benmachine: yes, but only in a particular order
03:32:38 <mauke> my view is that haskell has primitive one-argument functions
03:32:57 <benmachine> mauke: you think that \x -> f x y doesn't count as a partial application?
03:32:57 <mauke> on top of those are multi-argument functions, but those live in the mind of the programmer; they're not a language feature
03:33:32 <mauke> in that view, the Haskell core doesn't support partial application of its functions
03:33:50 <benmachine> mauke: right, I don't disagree with you so far
03:34:09 <mauke> benmachine: \x -> f x y might be called partial application on yet another level
03:34:33 <mauke> basically you'd have to implement your own "functions" on top of what haskell offers
03:34:57 <mauke> but it depends on how far you're willing to go
03:35:17 <benmachine> mauke: would you agree with the statement that haskell allows you to do anything that you might want partial application of functions for?
03:35:52 <mauke> yes, but only trivially
03:36:13 <mauke> in the sense that anything can do anything because turing
03:36:56 <mauke> IIRC HList or OOHaskell offers named arguments with partial application?
03:36:57 <benmachine> mauke: when I say "do anything" I don't just mean "compute anything"
03:37:00 <mauke> or at least reordering
03:37:09 <benmachine> I don't want Haskell merely to compute things :P
03:37:21 <mauke> but that's a relatively heavy layer on top of core haskell
03:37:54 <benmachine> mauke: so when I say "allows you to do anything" I mean more "has at most a minor syntactic barrier to expressing the exact same concept"
03:38:36 <benmachine> mauke: perhaps a better question would be how you know partial application when you see it
03:39:24 * hackagebot constructible 0.1.0.1 - Exact computation with constructible real numbers  http://hackage.haskell.org/package/constructible-0.1.0.1 (AndersKaseorg)
03:40:10 <benmachine> ooh
03:40:12 * benmachine follows link
03:40:28 <mauke> my brain doesn't understand how it works
03:40:52 <benmachine> mauke: in that case, why do you assume it does work? :P
03:40:55 <merijn> benmachine: That made you look the mathematician's version of the dog from Up :p
03:41:51 <typoclass> "ooh package, i have just met you and i already love you!"
03:42:49 <benmachine> yeah unfortunately I was thinking of constructive rather than constructible, but it's still pretty cool
03:43:20 <mauke> I just met you and this is crazy / but here's my gödel number, so call me maybe
03:44:02 <shachaf> Hmm, how does constructible compare to cyclotomic?
03:46:18 <benmachine> shachaf: I am also interested in this question
03:46:34 <benmachine> shachaf: cyclotomic can only take square roots of rationals, it looks like this package is actually closed under square roots
03:49:19 <shachaf> benmachine: cyclotomic has a bunch of other things, though.
03:49:40 <shachaf> Though being closed under operations is nice.
03:50:09 <shachaf> Hmm, cyclotomic requires base <4.6.
03:50:32 <benmachine> shachaf: yes, cyclotonic has other nice things
03:50:41 <benmachine> like sines and cosines of rational degrees
03:51:10 <merijn> ಠ_ಠ
03:51:11 <banister`gym> https://gist.github.com/serialhex/2424975
03:51:20 <merijn> Why is exitFailure not IO a instead of IO () :(
03:52:47 <shachaf> banister`gym: That definition won't work with infinite sets, which I think are pretty important for surreal numbers to be interesting.
03:53:02 <shachaf> (Also, you don't need Zero.)
03:53:09 <shachaf> Er.
03:53:22 <shachaf> Does that even parse?
03:54:18 <typoclass> so is 0 a Construct or cyclotomic number?
03:54:49 <shachaf> typoclass: Yes.
03:55:03 <shachaf> (It is both. 0 is pretty important.)
03:55:11 <shachaf> merijn: Why would it be IO ()?
03:55:33 <mauke> :t exitFailure
03:55:35 <lambdabot>     Not in scope: `exitFailure'
03:55:35 <lambdabot>     Perhaps you meant `expectFailure' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
03:55:42 <mauke> :t expectFailure
03:55:43 <lambdabot> Testable prop => prop -> Property
03:55:51 <mauke> @hoogle exitFailure
03:55:51 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
03:55:51 <lambdabot> System.Exit exitFailure :: IO a
03:55:57 <typoclass> merijn: this indicates IO a http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html maybe it was changed lately?
03:56:15 <mauke> @hoogle exitWith
03:56:15 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
03:56:17 <shachaf> Oh, I didn't see the "not".
03:56:36 <mauke> how about IO Void?
03:56:41 <typoclass> shachaf: i see ...
03:57:17 <CADD> banister`gym: http://ofb.net/~wnoise/haskell/surreal/Surreal.lhs
03:57:19 <shachaf> IO a seems more convenient than IO Void. But maybe less explicit.
03:57:32 <shachaf> Should e.g. forever have type IO a -> IO Void?
03:57:58 <shachaf> (If it's IO a -> IO Void, why not go for IO () -> IO Void?)
03:58:05 <shachaf> (And by IO I mean m, of course.)
03:58:57 <merijn> oh
03:59:03 <merijn> Silly me, I was being lazy
03:59:16 <mauke> let forever be = be >> forever be  -- how does it feel like to let forever be?
03:59:19 <merijn> And using hdevtools to report the type, but it reported the type in context
03:59:46 <merijn> Back to using ghci instead of these fancy things again
04:00:03 <shachaf> merijn: Just use the :i binding in hdevtools instead.
04:00:06 <typoclass> using cyclotomic numbers, presumably "42 / 0" throws a runtime error? in other words, they are not really closed as far as division is concerned? (i'm probably misreading the term 'closed under')
04:01:08 <shachaf> typoclass: That is true of the real numbers also.
04:01:31 <byorgey> typoclass: they are "closed under" division to the same extent as any field.
04:02:10 <byorgey> so the term "closed under" is not actually inappropriate, but you're right that there are some assumptions/conventions hiding behind it.
04:02:42 <typoclass> ah ok thanks. i was unaware
04:03:03 <mauke> ¹ some restrictions apply
04:03:48 <mr-> (usually, one does not think of '/' as an operation, even. It is composed of taking the inverse and multiplication)
04:03:50 <typoclass> ⁰ Some restrictions regarding 0 apply
04:04:24 <shachaf> And I would say that fields are indeed not "closed under multiplicative inverse".
04:04:39 <mauke> 0 ˢᵒᵐᵉ ʳᵉˢᵗʳⁱᶜᵗⁱᵒⁿˢ ᵃᵖᵖˡʸ
04:05:16 <mr-> shachaf: right
04:05:28 <shachaf> (In general.)
04:05:40 <mr-> (without exception)
04:06:02 <shachaf> Do you count {0} as a field? :-)
04:06:09 <mr-> Of course not
04:06:20 <elliott> people got no love for base cases
04:06:38 <mr-> It barely is a ring, for many people
04:06:47 <Peaker> does bos still maintain aeson? who maintains wx?  I have outstanding pull requests to both that are just sitting there, bugs still on hackage :(
04:07:12 <typoclass> mr-: right right. though the announcement said 'The cyclotomic numbers form a field: they are closed under addition, subtraction, multiplication, and division'. i guess they listed that just to be complete and explicit
04:07:14 <shachaf> mauke: Restriction, eh? As in the restriction of multiplicative inverse to nonzero elements?
04:07:55 <shachaf> typoclass: "(except for 0)" is usually implied in a context like that.
04:08:20 <typoclass> shachaf: yes. right
04:09:03 * typoclass hacks ghc in some magic way so that div by zero is a compile-time error, not runtime
04:10:16 <shachaf> typoclass: Not a hard thing to do in itself, exactly, but now every time you get a number from anything you have to prove to GHC that it's not 0 before dividing by it.
04:10:22 <CADD> typoclass: im pretty sure you can with a dependently typed language
04:10:57 <CADD> typoclass: atleast more trivially than a non-dependently typed lang
04:12:19 <shachaf> "On a scale of very to non, how trivial is it?"
04:12:43 <CADD> shachaf: inverse
04:12:45 <CADD> :)
04:13:17 <ocharles> well _/_ : Real -> (denom : Real) -> not (denom == 0) -> Real is one way, right?
04:13:23 <typoclass> shachaf: that's true. though i was assuming type inference and the unspecified magic would do the proving in most cases. "it was a literal 7, and he only ever added to and divided the value, so it couldn't be 0"
04:13:45 <CADD> you can definatly say that it would be much more trivial than attempting to have it added to say java
04:14:19 <typoclass> ... i wonder what i'm really asking for. probably that Integer would be split into different types Pos, Zero, and Neg, or something
04:15:10 <typoclass> ... this was another one of my ill-thought-out confused ideas to start with. hope you don't mind :-/
04:15:19 <CADD> typoclass: i dont think that would help much for determining whether or not it will be zero at runtime
04:16:14 <CADD> typoclass: although i can see it helping if you want to determine whether someting is one of those three cases
04:16:22 <shachaf> ocharles: Apartness inequality is better than denial inequality!
04:16:31 <CADD> typoclass: but then you can just use pattern matching
04:16:44 <ocharles> shachaf: I have no idea what that means, but I'll take your word for it
04:16:46 * shachaf wonders whether the latter term is new or something.
04:16:57 <shachaf> ocharles: http://ncatlab.org/nlab/show/apartness+relation
04:17:01 <shachaf> Or, rather, http://ncatlab.org/nlab/show/inequality+relation
04:17:07 <shachaf> (And also http://ncatlab.org/nlab/show/denial+inequality )
04:17:13 <ocharles> thanks
04:17:21 <ocharles> I'm just learning Agda at the moment
04:17:29 <CADD> shachaf: you're a goldmine
04:18:09 <ocharles> "A set S equipped with an apartness relation is a groupoid (with S as the set of objects) enriched over the cartesian monoidal category TV op, that is the opposite of the poset of truth values, made into a monoidal category using disjunction". Woosh. Looks like I have a bit of material to get through first ;)
04:18:23 <CADD> ocharles: thats the ncatlab for you
04:19:11 <CADD> http://mycroftproject.com/search-engines.html?name=ncatlab
04:19:21 <CADD> just saying, that is super awesome
04:19:28 <typoclass> CADD: hard to say how much it would help in practice. i started from the vague feeling that in other languages, the null pointer is folded into all pointers, leading to errors. haskell of course solves this by separating it out into an extra type (Maybe), basically so that the compiler can easily distinguish nullable objects and actual ones, without heaps of static analysis
04:19:33 <CADD> its surprising how often i seem to use it
04:19:37 <SSim> Of all IRC this one seems to be hidden from search
04:19:55 <typoclass> CADD: anyhoo, i vaguely thought that division by zero could be separated out in a similar way
04:20:31 <CADD> typoclass: i can see the relationship
04:20:58 <typoclass> CADD: thanks :-)
04:21:50 <CADD> typoclass: you know what really blew me away? i saw a dependent type that created a list that only allowed prime numbers
04:22:11 <CADD> let me see if i can dig that article up
04:22:17 <typoclass> CADD: yeah ... but i want my type inference :-(
04:22:30 <elliott> you can make a dependent type that creates a list that only allows elements that satisfy any predicate you desire.
04:22:35 <merijn> typoclass: Why? Don't you write top-level typ signatures already?
04:22:41 <elliott> but you'll have to provide proofs when constructing them.
04:22:53 <typoclass> merijn: yes, but not for all the other stuff
04:22:54 <elliott> of course, for decidable propositions like primality you can solve that.
04:22:56 <CADD> elliott: exactly
04:23:11 <merijn> typoclass: So? You probably won't have to write them for all the other stuff, only for some
04:23:34 <merijn> typoclass: Dependent types aren't arbitrarily inferrible, but they can be partially inferred
04:23:57 <merijn> typoclass: i.e. if your main type signature provides enough context you should still be able to infer local declarations
04:24:14 <merijn> You might need to explicitly type one or two ambiguous ones, but certainly not all of them
04:24:35 <typoclass> merijn: hm! ok
04:24:38 <ocharles> In fact, due to so much type refinement, you might even need *less* type signatures in top level definitions
04:24:45 <ocharles> citation very much needed there though
04:24:52 <CADD> typoclass: not what i was looking for but close enough: http://permalink.gmane.org/gmane.comp.lang.agda/1200
04:25:35 <merijn> typoclass: Many people read "dependent types don't let allow a complete solution to type inference" and interpret "dependent types can't be inferred", which is just confused
04:25:37 <elliott> ocharles: I dispute that claim.
04:25:50 <merijn> typoclass: Think of RankNTypes, RankNTypes in haskell aren't inferrable either
04:26:04 <merijn> typoclass: (Or rather, RankNTypes aren't inferrable, period :p)
04:26:20 <ocharles> elliott: you write more dependently typed stuff than me, so that's justified :)
04:26:31 <merijn> typoclass: But providing a type signature for the one or two higher ranked functions is enough to make the rest of the inference work
04:26:46 <elliott> ocharles: the problem is that the fancy specific types you write are generally highly-dependent stuff
04:26:56 <elliott> and you basically just have to write those out.
04:27:51 <MasseR> 10
04:28:01 <CADD> 9 8 7 6 5 4 3 2 1
04:28:06 <CADD> blastoff
04:28:18 <typoclass> merijn: right. i don't have an opinion on the whole thing myself; i only looked briefly at agda some years ago (hoping it was some kind of super-concentrated haskell), and kinda lost interest after a few minutes when a ton of signatures were in sight and people said "no you can't omit those"
04:28:28 <merijn> typoclass: If it can be inferred in haskell it should be able to infer in dependent types (modulo some stuff that's unambiguous in haskell but becomes ambiguous in the presence of dependent types, which is where top level type signatures help disambiguate for the "simple" cases)
04:30:27 <shachaf> Why would you want the compiler to infer your types from your programs when you could have it infer your programs from your types?
04:30:55 <CADD> shachaf: lol, pretty much
04:31:37 <mr-> shachaf: why is that better than just writing the program?
04:32:02 <merijn> shachaf: iknorite
04:32:11 <CADD> mr-: you usually your dep typed langs for theorm proving, more than anything else
04:32:18 <typoclass> shachaf: yes, that's pretty much what people have told me the other night as well. conal's ideas about starting with the types, and so on
04:32:30 <merijn> mr-: Because the latter gives better guarantees
04:32:37 <CADD> mr-: you can use them for "real world" stuff, but it really hasnt crossed over
04:32:41 <merijn> typoclass: Go read McBride's thesis
04:32:49 <merijn> :p
04:32:56 <CADD> mr-: that too
04:32:58 <CADD> ff
04:33:01 <CADD> merijn: that too
04:33:06 <typoclass> shachaf: it's certainly plausible that that's the way forward. though i'm not sure if it's here already?
04:33:36 <merijn> typoclass: It's the goal behind epigram, iteratively refine your program from the type with help of the compiler
04:33:37 <shachaf> mr-: Why have the computer do something automatically when you could be doing it by hand instead?
04:33:53 <CADD> shachaf: /thread
04:34:11 <mr-> shachaf: Does that make the type system just another (high level) programming language?
04:34:43 <mr-> Which the compiler translates to a program which is translated to (say) machine-code?
04:35:13 <shachaf> mr-: Type classes in Haskell are an example of inferring programs from types, sort of.
04:35:26 <shachaf> Did you see pigworker's answer at http://stackoverflow.com/a/13241158 ?
04:36:27 <mr-> No, but I'll have a look. Thanks
04:36:39 <merijn> hmm
04:37:30 <merijn> @pl \x -> f <$> g x
04:37:30 <lambdabot> (f <$>) . g
04:37:40 <merijn> Is there a nicer way to write this?
04:38:03 <shachaf> fmap f . g is probably nicer than what @pl said.
04:38:04 <jesyspa> fmap f . g?
04:38:43 <merijn> I guess, I'm disappointed of the lack of >=> for composing with pure functions :(
04:39:04 <merijn> I guess I could use the Kleisli arrow, but that's unlikely to be nicer
04:39:17 <JuanDaugherty> @pl refers to lambdabot?
04:39:17 <lambdabot> (line 1, column 21):
04:39:17 <lambdabot> unexpected end of input
04:39:17 <lambdabot> expecting white space or simple term
04:40:05 <CADD> JuanDaugherty: its one of lambdabot's many builtin functions
04:40:15 <JuanDaugherty> i c
04:40:19 <typoclass> JuanDaugherty: yes, everything starting with @ is a lambdabot command. some others are ":t" and of course "> "
04:40:30 <JuanDaugherty> i know, just didn't get pl
04:40:56 <merijn> There should be a nicer way to write "  fileInput <- concat <$> mapM (fmap (map read . lines) . readFile) files"
04:41:26 <benmachine> I reckon a concatMapM wouldn't go amiss
04:41:47 <CADD> JuanDaugherty: pl is for points free refactoring
04:41:47 <merijn> benmachine: I looked for that, but I don't think it exists?
04:42:04 <benmachine> merijn: sorry, yes, I meant, "I think it should exist"
04:42:06 <merijn> I guess I could make it
04:42:19 <benmachine> unless it's secretly derivable from monad transformers or something
04:42:35 <typoclass> JuanDaugherty: oh it means 'pointless', as in point-free style. in other words, 'try to rewrite e.g. \x -> f (g x) into f . g'
04:42:43 <merijn> "concat . map (map read . lines) <$> mapM readFile files"
04:42:51 <merijn> eh
04:42:58 <merijn> "concatMap (map read . lines) <$> mapM readFile files"
04:42:59 <CADD> @pl \x -> f (g x)
04:42:59 <lambdabot> f . g
04:43:03 <CADD> there you go
04:43:15 <merijn> :t \xs -> concatMap (map read . lines) <$> mapM readFile xs
04:43:16 <lambdabot> Read b => [FilePath] -> IO [b]
04:43:18 <benmachine> @pl \x -> f x (g x) (h (g x))
04:43:18 <lambdabot> ap (ap f g) (h . g)
04:43:27 <merijn> That looks decent enough
04:43:46 <CADD> benmachine: i qould probably do it infix
04:45:31 <CADD> JuanDaugherty: If you are interested: http://code.haskell.org/lambdabot/COMMANDS
04:45:39 <JuanDaugherty> ty
04:45:50 <CADD> np
04:46:42 <CADD> wait wat?
04:47:05 <CADD> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
04:47:06 <lambdabot>   Hello world
04:47:07 <CADD> lol
04:47:08 <CADD> nice
04:47:10 <simukis_> @karma-all
04:47:11 <lambdabot>  blah                 31338
04:47:11 <lambdabot>  nobody               2000
04:47:11 <lambdabot>  C/C                   523
04:47:11 <lambdabot>  (                     211
04:47:12 <lambdabot>  +                     150
04:47:14 <lambdabot>  g                     149
04:47:16 <lambdabot>  shachaf                59
04:47:20 <lambdabot>  dmwit                  57
04:47:22 <lambdabot>  libc                   57
04:47:24 <lambdabot>  monochrom              57
04:47:28 <simukis_> I shouldn't have done that -.-
04:47:28 <lambdabot> Plugin `karma' failed with: <<timeout>>
04:47:53 <shachaf> Yep.
04:47:55 <BoR0> @karma BoR0
04:47:55 <lambdabot> You have a karma of 0
04:48:09 <shachaf> lambdabot can be queries in /msg
04:48:18 <simukis_> yup, I know.
04:50:47 <BoR0> what does @pl do?
04:51:13 <CADD> BoR0: points free translation
04:51:17 <CADD> @pl \x -> f (g x)
04:51:17 <lambdabot> f . g
04:51:18 <merijn> BoR0: It makes code point free (i.e. eliminates names)
04:51:18 <typoclass> @pl \x -> f (g x)
04:51:19 <lambdabot> f . g
04:51:27 <BoR0> oh, okay
04:51:48 <typoclass> BoR0: it's moderately useful, i would say
04:51:57 <BoR0> is it within ghci or just lambdabot
04:52:07 <typoclass> BoR0: just lambdabot
04:52:08 <CADD> hlint i think
04:52:18 <CADD> which lambdabot uses
04:52:20 <JuanDaugherty> the latter is in the former to an extent I believe
04:54:18 <alpounet> CADD, i think there's a pl tool somewhere on hackage
04:54:27 <alpounet> or some other name
04:54:50 <CADD> alpounet: you may be right, i was just having a guess. i was actually just looking at the appropriate source in lambdabot
04:56:34 <CADD> alpounet: it actually seems to be completely written for lambdabot, it just uses pretty standard libs
04:56:44 <CADD> alpounet: although i did find this with a bit of searching
04:56:45 <CADD> http://wiki.di.uminho.pt/twiki/bin/view/Personal/Ze/Bic
04:57:33 <shachaf> benmachine: *ahem*
04:58:00 <shachaf> Oh, waiat.
04:58:07 <shachaf> Maybe you updated it.
04:58:38 <shachaf> OK, benmachine++
04:58:41 <shachaf> @hackage pointfree
04:58:41 <lambdabot> http://hackage.haskell.org/package/pointfree
04:59:07 <CADD> ty shachaf
05:04:26 * hackagebot hfann 0.4.1 - Haskell binding to the FANN library  http://hackage.haskell.org/package/hfann-0.4.1 (DavidHimmelstrup)
05:04:28 * hackagebot gray-extended 1.5 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5 (AmyDeBuitleir)
05:04:52 <CADD> neat good to see work on FANN bindings
05:08:16 <CADD> soo.. is anyone at the international category theory conf right now?
05:10:10 <CADD> either way i hope they post videos of the talks
05:18:43 <kingugo> hey bben, can i chat with you?
05:19:53 <mauke> kingugo: do you know where you are?
05:20:21 <kingugo> yea sauke
05:20:40 <kingugo> haskell irc channel
05:21:48 <kingugo> can we chat sauke?
05:22:41 <typoclass> kingugo: hello, this channel is for discussing the haskell programming language. it's not a general chat channel
05:23:33 <kingugo> i know typoclass
05:24:04 <kingugo> can you refer me to an irc where i can get info about zeus bot and stuffs like that? its for edu purpose
05:24:26 * hackagebot SDL 0.6.5 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.5 (DavidHimmelstrup)
05:24:45 <CADD> kingugo: https://en.wikipedia.org/wiki/Zeus_(trojan_horse)
05:24:53 <typoclass> kingugo: sorry, i don't know what zeus bot is. but feel free to ask if you have any questions related to haskell
05:24:56 <CADD> kingugo: wiki is usually a good starting point
05:25:48 <kingugo> alright CADD. thanks. just checked the link. can i  chat with you for some mins?
05:26:25 <CADD> sure
05:26:33 <CADD> uhh ill meet you in haskell-blah i guess
05:27:20 <typoclass> kingugo: you can just do "/query someone", you know. usually you don't need to ask publicly
05:28:38 <CADD> kingugo: hey im waiting for you in #haskell-blah
05:29:03 <merijn> typoclass: Eh, that's generally considered rather rude if there's no previous context
05:29:23 <jxport> considered rude
05:29:24 <jxport> lol
05:29:43 <jxport> anyone who takes issue with that is probably the kind of person who can't pee at a urinal if someone else is in the bathroom
05:29:45 <merijn> Personally I tend to ignore people that privmsg unless the message has somewhat private content and is related to an active discussion
05:29:53 <CADD> jxport: lol
05:30:18 <mauke> jxport, CADD: you are not making me happy
05:30:27 <mauke> I advise you to drop it
05:30:30 <jxport> mauke: sorry, I'll leave the bathroom :x
05:30:33 <typoclass> people, please keep it on topic, i.e. technical discussion about haskell
05:31:35 <CADD> mauke: srry
05:31:44 <quchen> And maybe don't judge people based on their ability to pee in company.
05:32:19 <CADD> quchen: ok ok, we get it mauke doesnt need to get any angrier
05:34:03 <merijn> quchen: Not really helping
05:35:45 <kingugo> pls am sorry guys. seems am the problem
05:39:13 <nomeata> Hi. What is a nice and simple Haskell test framework when I want my tests to also cover things like „This module should fail compilation with a certain error message“?
05:40:19 <Eduard_Munteanu> Suppose some module doesn't export a few functions and types I need. Is there any way to get at them?
05:40:24 <CADD> nomeata: quickcheck is pretty much the standard
05:40:42 <merijn> Eduard_Munteanu: download source, change it, compile. iow, not really
05:40:50 <CADD> ok, homotopy type theory; anyone doing anything interesting with it?
05:40:55 <Eduard_Munteanu> I see, I'll do that, thanks.
05:40:57 <nomeata> CADD: how and why would I use randomized testing if I want to assert that certain code is _not_ accepted by the compiler
05:41:00 <CADD> it is intersting in and of itself, i know. Just wanna know if anyone has started a project using it.
05:41:19 <sordina1> Hey haskellers.
05:41:23 <typoclass> Eduard_Munteanu: 'cabal unpack' is your friend
05:41:34 <CADD> nomeata: oh sorry i kinda glazed over your message a bit
05:41:43 <typoclass> sordina1: hello
05:41:49 <CADD> sordina1: hello
05:42:19 <sordina1> Is anyone aware of some high level zip-style functions in the pipes Control.Proxy package that work more like regular zips?
05:42:59 <sordina1> In fact, any of the Writer style functions are confusing me a lot.
05:44:21 <merijn> sordina1: Which package is that in?
05:44:27 * hackagebot haste-compiler 0.2.1 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.1 (AntonEkblad)
05:46:09 <sordina1> merijn: pipes
05:46:44 <sordina1> I'm also not sure if that's the package I should be using... There seem to be a lot of similarly named ones.
05:46:56 <merijn> sordina1: And you just want something similar to "zip :: [a] -> [b] -> [(a, b)]"?
05:47:56 <merijn> I suspect you want to use the Applicative instance to get that
05:48:06 <sordina1> merijn: yep. I'd like something that I can use like " ... >-> f (idD &&& tailD) >-> ..."
05:48:26 <merijn> :t liftA2 (,)
05:48:27 <lambdabot> Applicative f => f a -> f b -> f (a, b)
05:48:51 <quchen> nomeata: Why would you randomly want to check whether your code compiles? What you're asking for is sort of a QuickCheck that produces Haskell code and tries to compile it.
05:49:14 <nomeata> quchen: I don’t want to do random testing, I was just confused by CADD to suggest it.
05:49:37 <sordina1> merijn: thanks I'll give that a go
05:49:41 <quchen> nomeata: Then what did you mean with "This module should fail compilation with a certain error message"?
05:49:46 <sordina1> Didn't notice the applicative instance.
05:49:57 <sordina1> Although I guess that makes sense if it's a monad :)
05:50:06 <nomeata> quchen: I have code that does not compile, and I want to check that the error message is as expected.
05:50:20 <nomeata> (Assume I’m writing a library with strange type hackery)
05:50:58 <quchen> nomeata: I'm still not sure what you mean. Do you want to look at invalid code, formulate an error message why it should fail to compile, and then compare it to the compiler's error message?
05:51:29 <quchen> nomeata: It's usually the other way round, compiler complains, programmer fixes code at the designated location
05:51:34 <quchen> ... hence I'm confused.
05:52:33 <guerrilla> quchen: i guess you could wrap HUnit around something that runs the build
05:52:40 <nomeata> quchen: assume a feature of my library is that certain uses are statically prevented, and I want my test to ensure that they stay impossible in furture versions, so I should test that.
05:53:25 <nomeata> guerrilla: test-framework-golden ist close, but still lacking a bit: https://github.com/feuerbach/test-framework-golden/issues/3
05:53:30 <guerrilla> quchen: like HUnit + Shake or something
05:53:35 <guerrilla> ok
05:54:08 <guerrilla> HUnit + Cabal? i dono. i can't remember ever doing this, but vaguely doesn't seem like the worst idea
05:54:24 <nomeata> it is not hard to hack someting that does this; I guess I have done it a few times with bash etc. But I wanted to see if someone else has maybe done it already.
05:55:54 <nomeata> ah, http://hackage.haskell.org/packages/archive/HTF/0.9.0.0/doc/html/Test-Framework-BlackBoxTest.html might be what I’m looking for
06:04:08 <justincampbell> im trying to build a simple http api and all i want is a routing library/framework, what would you all suggest?
06:04:12 <justincampbell> im looking at snap and yesod
06:04:22 <justincampbell> but i noticed they have sub-packages that might fit too
06:04:49 <justincampbell> also, the yesod docs say to type yesod init, but i dont have yesod in my $PATH
06:05:11 <bennofs> Is there a simple package that provides a monad instance for a newtype over s -> (a, Maybe s)?
06:06:09 <Fuuzetsu> I wrote s -> Maybe (a, s) the other day if that interests you
06:06:44 <elliott> isn't that StateT Maybe?
06:06:52 <bennofs> @unmtl StateT Maybe
06:06:52 <lambdabot> Plugin `unmtl' failed with: `StateT Maybe' is not applied to enough arguments, giving `/\A B. Maybe -> A (B, Maybe)'
06:06:59 <elliott> bennofs: what semantics?
06:06:59 <bennofs> @unmtl StateT Maybe Int Int
06:06:59 <lambdabot> Maybe -> Int (Int, Maybe)
06:07:16 <bennofs> @unmtl StateT String Maybe Int
06:07:16 <lambdabot> String -> Maybe (Int, String)
06:09:03 <elliott> what I said was re Fuuzetsu, btw
06:09:12 <elliott> about StateT Maybe
06:09:36 <Fuuzetsu> elliott: Yep, except without having to import a bunch of libs…
06:09:37 <bennofs> Ok, I think I need a -> (a, Maybe a)
06:10:36 <elliott> Fuuzetsu: you mean the single library transformers that is probably the most depended-on package in Haskell and is portable Haskell 98?
06:11:25 <Fuuzetsu> Possibly.
06:11:37 <bennofs> Or maybe a -> (b, Maybe a), where it is possible to somehow access b in a monadic computation (in addition to a)
06:12:03 <mauke> bennofs: what would this type do?
06:13:35 <merijn> justincampbell: Make sure the binary install path of cabal is in $PATH to fix that
06:14:25 <merijn> justincampbell: What that path is, is OS dependent (it's ~/Library/Haskell/bin on OSX, but I'm clueless about linux' install location)
06:14:28 * hackagebot hsbencher 1.3.8 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.3.8 (RyanNewton)
06:14:36 <justincampbell> merijn: thanks!
06:21:14 <bennofs> I see, what I wanted doesn't make any sense
06:22:39 <bennofs> I have a function splitKind :: Kind -> (Kind, Maybe Kind) that splits of the rightmost kind of a kind (Example: it splits of (* -> *) in the kind * -> (* -> *))
06:22:56 <bennofs> and returns the rest (in the example: *)
06:23:40 <namoamitabuddha> I have no idea about the reasoning of the (informal) proof of the correctness of a haskell program.
06:25:00 <bennofs> @hoogle (a -> (b,Maybe a)) -> a -> [b]
06:25:01 <lambdabot> No results found
06:25:23 <bennofs> Is there really no such function?
06:25:35 <shachaf> @hoogle (a -> Maybe (b, a)) -> a -> [b]
06:25:35 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:25:35 <lambdabot> Data.ByteString.Builder.Prim primUnfoldrFixed :: FixedPrim b -> (a -> Maybe (b, a)) -> a -> Builder
06:25:35 <lambdabot> Data.ByteString.Builder.Prim primUnfoldrBounded :: BoundedPrim b -> (a -> Maybe (b, a)) -> a -> Builder
06:26:21 <namoamitabuddha> Such as assertion boxes for imperative programming languages.
06:27:52 <bennofs> shachaf: But with that function, when the function given returns Nothing, the last value is discared
06:27:58 <bennofs> discarded*
06:28:10 <latermuse> I get giddy when Im about to start a new project with haskell.
06:28:22 <latermuse> haskell is the best friend i never had
06:28:43 <shachaf> bennofs: Yes. unfoldr follows the structure of a list exactly.
06:30:48 <bennofs> @hoogle (a -> (Maybe a,b)) -> a -> [b]
06:30:49 <lambdabot> No results found
06:32:04 <fryguybob> @type unfoldr
06:32:04 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:34:48 <bennofs> :t \f x -> x >>= \x' -> let (y,xm) = f x' in (\x'' -> (y,x'')) <$> xm
06:34:49 <lambdabot> (Monad m, Functor m) => (a -> (t, m t1)) -> m a -> m (t, t1)
06:35:19 <mauke> :t \f a -> unfoldr (fmap f) (Just a)
06:35:20 <lambdabot> (a1 -> (a, Maybe a1)) -> a1 -> [a]
06:35:52 <bennofs> :t \x y -> unfoldr ((\f x -> x >>= \x' -> let (y,xm) = f x' in (\x'' -> (y,x'')) <$> xm) x) y
06:35:52 <lambdabot> (a1 -> (a, Maybe (Maybe a1))) -> Maybe a1 -> [a]
06:35:56 <bennofs> :O
06:36:31 <namoamitabuddha> :t const
06:36:32 <lambdabot> a -> b -> a
06:37:34 <mauke> > map (const "yes") [1 .. 5]
06:37:36 <lambdabot>   ["yes","yes","yes","yes","yes"]
06:38:28 <osfameron> I'll have what lambdabot's having
06:38:37 <CADD> osfameron: lol
06:39:16 <bgamari> Does anyone know why the setenv (https://github.com/sol/setenv) package exists?
06:39:22 <bgamari> What's wrong with System.Environment?
06:40:26 <mauke> bgamari: it doesn't have setenv
06:40:34 <bgamari> mauke, I see now
06:40:39 <bgamari> or rather, it didn't until 7.7
06:40:51 <mauke> System.Posix.Env does, though
06:40:54 <bgamari> http://ghc.haskell.org/trac/ghc/ticket/7427
06:45:58 <dzelzs> hey everybody, I have a trouble with leksah. I'm trying to configure leksah-welcome but it show me this message:
06:46:02 <dzelzs> Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal
06:46:04 <dzelzs> update' to download it.
06:46:07 <dzelzs> cabal: At least the following dependencies are missing:
06:46:09 <dzelzs> QuickCheck -any
06:46:10 <dzelzs> Resolving dependencies...
06:46:12 <dzelzs> Configuring leksah-welcome-0.12.0.3...
06:46:49 <dzelzs> I've tried to "cabal update" but it does nothing at all
06:47:05 <dzelzs> well, not at all, but message remains
06:47:36 <hamishmack> try Package -> Install Dependancies
06:48:26 <dzelzs> Resolving dependencies...
06:48:28 <dzelzs> Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal
06:48:30 <dzelzs> update' to download it.
06:48:32 <dzelzs> cabal: Could not resolve dependencies:
06:48:34 <dzelzs> trying: leksah-welcome-0.12.0.3 (user goal)
06:48:37 <dzelzs> next goal: QuickCheck (dependency of leksah-welcome-0.12.0.3)
06:49:04 <dzelzs> quickcheck was installed via cabal
06:49:42 <dzelzs> Resolving dependencies...
06:49:45 <dzelzs> All the requested packages are already installed:
06:49:46 <dzelzs> QuickCheck-2.6
06:49:48 <dzelzs> Use --reinstall if you want to reinstall anyway.
06:49:52 <dzelzs> it is from terminal
06:49:59 <jxport> dzelzs: ...done yet?
06:52:01 <dzelzs> Didn't catch. I'm very weak in English
06:52:12 <dzelzs> what did you mean?
06:53:41 <hamishmack> dzelzs: What version of cabal (cabal --version)?
06:54:16 <dzelzs> 1.14.0
06:55:42 <hamishmack> what OS? leksah version? ghc version?
06:56:17 <dzelzs> wait a sec please :)
06:57:02 <dzelzs> Linux dzelzsdeb 3.2.0-4-amd64 #1 SMP Debian 3.2.46-1 x86_64 GNU/Linux
06:57:18 <dzelzs> Leksah the Haskell IDE, version 0.12.0.3
06:57:22 <HugoDaniel> :D
06:57:28 <dzelzs> what?)
06:58:08 <dzelzs> stop laughing, I'm ashamed :)
06:59:02 <dzelzs> Glasgow Haskell Compiler, Version 7.4.1, stage 2 booted by GHC version 7.4.1
06:59:05 <dzelzs> and ghc :)
06:59:29 * hackagebot special-keys 0.1.0.1 - Simple data types that help me here and there.  http://hackage.haskell.org/package/special-keys-0.1.0.1 (HugoGomes)
07:00:14 <namoamitabuddha> I'm in trouble.
07:00:30 <hamishmack> I have to go, but if you cd to where leksah-welcome is stored and do "cabal configure" you should get the same error without leksah
07:00:55 <dzelzs> I'll try :) thank you)
07:01:11 <hamishmack> You could try this… cabal install cabal-install
07:01:15 <hamishmack> it may help
07:01:34 <dzelzs> ok
07:02:55 <lemao> does anyone know how to get auto-completion working with emacs+flycheck?
07:03:14 <hamishmack> leksah-welcome includes a library and and tests.  The test depend on the library to build and I think that might be where the problem is.
07:03:18 <hamishmack> but I am not sure why
07:03:34 <hvr> lemao: what's autocomplete supposed to do for flycheck?
07:04:03 <CADD> lemao: try #emacs?
07:04:38 <hvr> CADD: if it's related to haskell-mode, then #emacs might not help much
07:04:46 <lemao> hvr: good question :-) trying to setup emacs + haskell-mode + flycheck + autocompletion. The part that is not working is auto completion
07:05:04 <bitonic> lemao: doesn’t ghc-mod provide autocompletion?
07:05:12 <CADD> hvr: oh ok
07:05:13 <hvr> lemao: auto-completion while editing source-code, or auto-completion while in the REPL?
07:05:20 <lemao> source-code
07:05:42 <hvr> lemao: ok, for that as bitonic said, ghc-mod might be your best option for the moment
07:05:51 <bitonic> ghc-mod also gives you flymake
07:05:54 <bitonic> and other goodies
07:06:07 <bitonic> and most of the times It Just Works (tm)
07:06:11 <lemao> hvr: and if I understand that correctly it is either haskell-mode OR ghc-mod correct?
07:06:20 <hvr> lemao: ghc-mod extends haskell-mode
07:06:51 <bitonic> lemao: wrong, ghc-mod works with haskell-mode
07:06:59 <lemao> hvr: so I should install only ghc-mod or both?
07:07:02 <hvr> both
07:07:15 <hvr> ghc-mod hooks into haskell-mode
07:07:51 <lemao> I have haskell-mode and ghc packages installed
07:08:12 <lemao> I guess the issue here is that I am trying to use flycheck and ghc-mod works with flycheck
07:08:19 <lemao> sorry, flymak
07:08:59 <hvr> tbh, I haven't used ghc-mod yet myself, so I can't help more than pointing you there
07:09:17 <bitonic> lemao: ghc-mod sets up the flymake infrastructure for you
07:09:27 <bitonic> you don’t have to configure anything
07:09:31 <hvr> and I hope than at some point in the future, ghc-mod and haskell-mode will converge in some way
07:09:47 <bitonic> well the thing is that ghc-mod is an Haskell program as opposed to a lump of elisp
07:10:28 <hvr> yeah, that too
07:10:44 <lemao> bitonic: but doesn ghc-mode have an emacs front end?
07:10:46 <hvr> some of the things that ghc-mod does, could be done with ghci as well
07:10:52 <bitonic> lemao: yes
07:11:06 <lemao> bitonic: and afaik it is called 'ghc'?
07:11:15 <lemao> bitonic: in package manager
07:11:47 <lemao> I have the built in flymake. should I install the flymake-haskell?
07:11:53 <hvr> lemao: yes, it's called "ghc" in the elisp package manager
07:11:54 <bitonic> lemao: what package manager?  but no, it’s not going to be called ‘ghc’
07:12:00 <bitonic> ah.
07:12:04 <hvr> lemao: on MELPA at least
07:12:04 <bitonic> well, apparently it is :P
07:12:10 <bitonic> in debian it’s “ghc-mod”
07:12:31 <lemao> I am using starterkit for emacs24
07:12:38 <CADD> lemao: there is also this package
07:12:41 <CADD> lemao: https://github.com/auto-complete/auto-complete
07:12:43 <lemao> hvr: yes, MELPA, ELPA, marmelade
07:12:54 <hvr> oh, ELPA has it too?
07:13:04 <lemao> and I install everything using package-install
07:13:05 <CADD> lemao: which has the haskell language completes included
07:13:34 <lemao> CADD: does it auto complete modules too?
07:13:55 <bgamari> Does anyone understand why Trac is so broken?
07:14:02 <CADD> lemao: hmm, i havent tried
07:14:22 <CADD> lemao: if you have a module open you can always give it a whirl
07:14:49 <lemao> CADD: I will try. It is definitely not working for haskell-mode
07:15:13 <lemao> bgamari: what is broken about it?
07:15:27 <lemao> bgamari: I ask because I have a bit of experience with trac in our own infra
07:15:40 <bgamari> lemao, It took me eight refreshes before I could submit a comment on a bug
07:15:56 <bgamari> lemao, It would fail with "the database is locked" every time
07:16:16 <bgamari> and each round-trip would take 30 seconds or so
07:16:17 <lemao> bgamari: I see now. We had issues like this in the past and it came down to (1) a plugin causing exceptions at the wrong moment and (2) an apache2 restart
07:16:20 <CADD> lemao: ok and if it works, tell me ok?
07:16:53 <lemao> CADD: what is the auto-complete command? Or should it just show up?
07:17:04 <nomadmonad> I'm sorry this got so long… I have about 3-5 Haskell books, and I've read most of them. I've never written real Haskell programs, just simple exercises to use or write your own implementation of map etc. That means I'm almost a complete newbie.
07:17:17 <nomadmonad> Now, I have a great real-world problem I'd love to learn real-world Haskell (I liked most Real-World Haskell of my books :). Problem is quite simple: 1) read in few pictures (X and Y), 2) optimize N point curve (as in Curves in Photoshop) to map each R, G and B channels so that 3) error( mapPicWithCurve( X, optimizedCurve(X, Y))) gets minimized, where error is for example RMSE( histogramOnChannel(X, "Red"), histogramOnChannel(Y,
07:17:18 <nomadmonad> "Red")). Then finally 4) output the picture X mapped through optimized curve. Later on, I'd love to wrap this functionality into 5) web proxy server that does image transformation if LRU buffer doesn't have the pic. Now, what I don't know is how to proceed in a trivial, step by step way.
07:17:54 <nomadmonad> what tutorials would you point me into? Newbie level, image IO and transformations, and optimization libs. Which other libs I should know to start as painlessly as possible?
07:18:01 <CADD> yeah it just shows up
07:18:06 <Lethalman> nomadmonad, juicypixels for reading images
07:18:44 <lemao> bgamari: fwiw, considering the lack of resources vs the amount of work in the haskell ecosystem I wish that this was offloaded to something hosted (Github, etc)
07:19:10 <namoamitabuddha> Who is focused on formal/informal verification for computer programes?
07:19:16 <nomadmonad> Lethalman: looks great! Thanks!
07:20:30 <bgamari> lemao, Yes, I agree
07:22:39 <lemao> bgamari: the quickest solution for the short term is to restart apache2 (assuming trac is being served from it).
07:23:11 <bgamari> lemao, sadly I don't have access to the system
07:23:23 <nomadmonad> is there some easy to use optimization lib? Perhaps genetic algo?
07:23:49 <lemao> hvr: on MELPA, ghc-mod emacs front-end is called 'ghc'
07:24:33 <hvr> lemao: yes, which imho is a sub-optimal name
07:25:30 <lemao> hvr: yes, it confused me at first and http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html doesnt mention the actual package name in the download section
07:26:12 <hvr> I'd expect a package named 'ghc' to interact with the ghc compiler suite
07:26:33 <lemao> I will create an issue there
07:26:52 <hvr> but ghc-mod only offers a small subset of what ghc offers
07:27:22 <CADD> nomadmonad: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:ai
07:27:50 <hvr> I wonder why the package wasn't simply called 'ghc-mod'
07:27:53 <nomadmonad> CADD: thanks! There also seems to be http://hackage.haskell.org/packages/archive/pkg-list.html#cat:optimisation
07:28:24 <CADD> nomadmonad: i was just about to link you to it
07:28:31 <CADD> nomadmonad: check out numerical and math as well
07:28:39 <nomadmonad> now, the hard part for a newbie is to try to read the API description and understand which one of these would be actually easy to use
07:28:51 <CADD> nomadmonad: the types help A LOT
07:29:58 <nomadmonad> CADD, how can I deduce ease-of-use-for-newbieness from looking at the types?
07:30:31 <CADD> nomadmonad: the types pretty much document exatly what the functions arguments are
07:30:41 <CADD> nomadmonad: which is essentially 99% of the info you need
07:31:35 <chrisdone> > execWriter (when True (tell "yay!"))
07:31:36 <lambdabot>   "yay!"
07:31:37 <chrisdone> > execWriter (join (fmap when (return True)) (tell "yay!"))
07:31:38 <lambdabot>   "yay!"
07:31:40 <chrisdone> =)
07:32:53 <CADD> lemao: any luck?
07:32:54 <nomadmonad> CADD, ok. Thanks. In many other languages the key thing for ease of use is the question how much chores you need to do before you get to pass the arguments to the magic call. If it's near-zero it's usually easy to start with. If it's few screenfuls, that means you need to understand a lot before you get to the interesting stuff. How do I guesstimate the required housekeeping and it's complexity from the types?
07:33:24 <CADD> nomadmonad: haskell usually has a very dense syntax
07:33:41 <CADD> nomadmonad: most things that would take pages of code can be expressed in a couple of lines in haskell
07:33:51 <CADD> nomadmonad: that is if you are very familiar with haskell
07:34:00 <CADD> nomadmonad: since it is such a deep langauge
07:34:29 <CADD> nomadmonad: most of the time you should try hoogle before you write your function and a lot of the time it is already written for you
07:34:48 <CADD> @hoogle (a -> b -> a) -> a -> [b] -> a
07:34:49 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
07:34:49 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
07:34:49 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
07:35:23 <lemao> CADD: auto-complete works nicely, BUT it seems to be file based only. I would like to go a bit further with haskell and autocomplete module names, types, reserved words
07:35:34 <CADD> lemao: aw, darn
07:35:46 <CADD> lemao: im sure there is someting somewhere
07:36:24 <CADD> nomadmonad: you know what that funtion i just hoogled is, right
07:36:25 <CADD> ?
07:37:08 <nomadmonad> CADD: gotta read a book to my kid in between. Yes, foldl is easy and fun. : ]
07:37:35 <CADD> nomadmonad: great so you know the basics
07:37:45 <CADD> nomadmonad: so you should really have no trouble with haskell then
07:40:41 <nomadmonad> CADD, yes, I know the basics. Thanks for the encouraging words. However, I have a tremendous chasm from basics of functions to fluent IO and useful data structures. I'm sure I can cross it by following along the examples, but I don't know much of good example code. There are shitloads of monad tutorials, but very few how to build a useful non-trivial data processing apps step by step, and by finding and using existing libraries.
07:42:15 <CADD> nomadmonad: ignore the monad tutorials
07:42:21 <CADD> nomadmonad: there is only one you need
07:42:23 <CADD> nomadmonad: about:blank
07:42:24 <CADD> ff
07:42:28 <CADD> nomadmonad: http://www.haskell.org/haskellwiki/Typeclassopedia
07:42:45 <CADD> nomadmonad: learn and understand that page and you will be well on your way
07:42:49 <merijn> nomadmonad: I haven't personally read it, but you might wanna take a look at, for example Xmonad? It's only about 1.2k lines of code and a "real world" program
07:42:57 <merijn> nomadmonad: There's some good tutorials on its design too
07:43:56 <ocharles> nomadmonad: my advice is always "stop trying to learn, and start trying to build". You need a project that you care about enough that is both: reasonable for you to achieve, complex enough to stretch you, and important enough for you to jump over hurdles
07:43:56 <merijn> Any reactive-banana experts around?
07:44:29 <merijn> nomadmonad: Oh, there's also "Build Yourself a Scheme in 48 Hours", which covers building a simple Scheme compiler/interpreter
07:44:34 <nomadmonad> yes, I liked Typeclassopedia a lot too (back in the days when I was reading about Haskell). But none of that helps me understand how to read data into Skip list, and serve it through a web server.
07:45:28 <nomadmonad> merijn: great example to check, thanks!
07:46:20 <nomadmonad> ocharles: that's exactly what I try to do! Thanks! However, getting stuck on line two does not really help me to learn anything.
07:47:02 <CADD> nomadmonad: highly recommend the sheme tutorial that merijn mentioned
07:47:11 <CADD> s/sheme/scheme/
07:47:12 <nomadmonad> merijn: the scheme compiler exercise could be fun in many other ways too.
07:47:52 <CADD> nomadmonad: you are right the typeclassopedia is much more of a fundamental thing
07:47:57 <shachaf> nomadmonad: You want a "read data into skip list and serve through web server" tutorial? I'm afraid we don't have those.
07:47:59 <lemao> CADD: aha, I think it now works
07:48:02 <CADD> nomadmonad: there is a brilliant tutorial on happstack
07:48:09 <CADD> lemao: nice, what did you do?
07:48:34 <CADD> nomadmonad: http://happstack.com/docs/crashcourse/index.html
07:48:40 <shachaf> nomadmonad: (And I doubt many other languages have them, either. Presumably this sort of thing is the realm of library documentation.)
07:48:44 <nomadmonad> CADD: sounds promising, can you remember some keywords for me to search?
07:48:45 <nomadmonad> thanks!
07:48:52 <merijn> nomadmonad: Also, it gets better :p I hit a wall when I started to try and write real code at first, but once you get past that you rapidly progress
07:48:54 <lemao> CADD: many things, some possibly redundant, many restarts and a few changes to the init.el. Let me try to retrace
07:48:55 <CADD> nomadmonad: i kind of perfer happstack over the other webframeworks
07:49:16 <CADD> nomadmonad: much more "hakelly" than all the other web frameworks
07:49:22 <CADD> nomadmonad: that and acidstate is amazing
07:49:26 <CADD> lemao: awesone
07:49:27 <ocharles> scotty is the simplest web framework
07:49:29 <ocharles> maybe start there
07:49:36 <ocharles> (and I'm a Snap'er at heart)
07:49:53 <nomadmonad> shachaf: that was just an example. But last time I tried to use a priority queue I got stuck for three days and got nothing that even compiled. Quite disheartening...
07:50:18 <CADD> nomadmonad: ah yes the compiler can be quite sadistic at times
07:51:07 <shachaf> nomadmonad: The answer is probably either to learn Haskell the core language better (e.g. how purely functional data structures work) or to use a better library, if you happened to choose a bad one.
07:51:10 <lemao> CADD: I will try from scratch to see if I can reproduce
07:51:58 <CADD> ocharles: ive taken i very quick look at snap, what has it got going over the other frameworks?
07:52:35 <ocharles> CADD: no idea, never used the others :)
07:52:48 <ocharles> CADD: I guess nothing else really has Snaplets, at least not executed in the same form as Snap
07:52:58 <CADD> ocharles: hmm, yeah i have some experience with yesod and happstack
07:53:06 <CADD> ocharles: and i liked happstack better by far
07:53:29 <CADD> ocharles: yesod has tons of template haskell stuff going on, its like you are learning a completely new language
07:53:50 <CADD> ocharles: happstack just seems like an extension of haskell to a web framework
07:53:57 <ocharles> The dependency on TH (which it seems is the idiomatic way to write stuff with Yesod, even if you can avoid it) feels very un-Haskelly
07:54:11 <CADD> ocharles: indeed
07:54:14 <ocharles> so that turned me away from it, which is pretty irrational but hey, that's life
07:54:27 <CADD> ocharles: lol, to each their own. it turned me away too
07:54:45 <CADD> ocharles: even though i do own the yesod book, lol
07:54:49 <Breadmonster> Guys, where do I find the definition (>>=) in the list monad?
07:55:29 <Breadmonster> Actually, where do I find the whole monad instance?
07:55:49 <CADD> @source (>>=)
07:55:49 <lambdabot> Unknown command, try @list
07:56:02 <ocharles> in Prelude, probably
07:56:37 <ocharles> oh wait no, that'd make it an orphan instance
07:57:11 <Breadmonster> I can't find the instance anywhere.
07:57:21 <CADD> @src >>=
07:57:21 <lambdabot> Source not found. Whoa.
07:57:25 <CADD> @src (>>=)
07:57:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:57:31 <CADD> wow
07:57:36 <CADD> lambdabot fail
07:57:46 <mauke> no, user fail
07:57:51 <CADD> must be :)
07:57:57 <CADD> whats the right command?
07:58:05 <CADD> @src Prelude.>>=
07:58:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:58:19 <Breadmonster> @src Data.List.>>=
07:58:19 <lambdabot> Source not found. :(
07:58:33 <merijn> There is no single implementation for >>=
07:58:34 <Breadmonster> @src Control.Monad.>>=
07:58:34 <lambdabot> Source not found. Are you typing with your feet?
07:58:35 <applicative_> how could there be source for >>= ?
07:58:51 <armlesshobo> you need the instance definition?
07:58:51 <Breadmonster> applicative_: I mean the instance of >>= for the list monad.
07:58:54 <Sculptor> yo
07:59:04 <ocharles> he's asking for the list monad
07:59:05 <mauke> Breadmonster: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#line-73
07:59:06 <applicative_> isnt there a command for that
07:59:17 <nomadmonad> shachaf: yes, there's a lot to learn of the core language, and libs. I do need good tutorials for purely functional data structures too. And yes, there needs to be a nice split between lib docs and tutorials. This gives a good overview that priority queues were not trivial to choose between a while ago http://stackoverflow.com/questions/6976559/comparison-of-priority-queue-implementations-in-haskell
07:59:22 <applicative_> (>>=) = flip concatMap
08:00:39 <Breadmonster> And what about (>>)?
08:00:47 <mauke> same link
08:01:20 <mauke> @src [] (>>=)
08:01:21 <lambdabot> xs >>= f     = concatMap f xs
08:01:22 <mauke> @src [] (>>)
08:01:22 <lambdabot> xs >> ys      = concatMap (const ys) xs
08:01:30 <shachaf> Perhaps someone should write a learning-things-without-tutorials tutorial.
08:01:35 <applicative_> ah there's the command
08:01:44 <shachaf> Of course, no self-respecting tutorial-writer would sabotage their profession like that.
08:01:47 <chrisdone> is it just me or is concatMap really an unhaskelly function? it only saves once character from concat.map—which i'd expect is fused anyway—and unlike concat.map you can't just grab the map (…) and put it elsewhere
08:01:49 <CADD> mauke: whats the reason for the empty list in front?
08:01:50 <mauke> "how to become an autodidact"
08:01:53 <Breadmonster> @src Maybe (>>=)
08:01:53 <lambdabot> (Just x) >>= k      = k x
08:01:53 <lambdabot> Nothing  >>= _      = Nothing
08:01:54 <mauke> CADD: wrong
08:01:58 <Breadmonster> Alright, fine it works.
08:02:02 <CADD> mauke: i tried :P
08:02:11 <applicative_> mauke: you're giving us two different answers.  the definition in GHC-Base uses foldr, I guess for optimization by it's scheme
08:02:11 <mauke> CADD: it's not an empty list, it's a type
08:02:33 <CADD> mauke: ah yeah, i noticed that with all the extra calls after that
08:02:36 <mauke> applicative_: I'm not. lambdabot is giving you the other one
08:02:38 <CADD> mauke: that makes sense
08:02:41 <mauke> and everyone knows lambdabot is lying
08:02:43 <Breadmonster> Where do I learn advanced Haskell?
08:02:47 <Breadmonster> Like what comonads aer?
08:02:56 <applicative_> mauke: right
08:03:10 <Breadmonster> Or at least enough advanced Haskell to read Bob Harper's blog and the Comonad Reader?
08:03:13 <mauke> and by "lying" I mean lambdabot just has a text file of definitions
08:03:15 <chrisdone> Breadmonster: just read the API's types and check out the instances?
08:03:17 <applicative_> Breadmonster: I don't know if comonads are typical 'advanced Haskell'
08:03:19 <mauke> it's not what's actually used in ghc
08:03:33 <applicative_> what does ghc use mauke , the foldr one?
08:03:35 <CADD> Breadmonster: there is the haskell wikibook, get through that first
08:03:38 <Breadmonster> chrisdone: Isn't there a book?
08:03:43 <CADD> Breadmonster: then memorize the typeclassopedia
08:03:56 <CADD> Breadmonster: then head over and read through Prelude
08:04:07 <mauke> applicative_: yes
08:04:08 <applicative_> have you read the typeclassopedia, Breadmonster ?
08:04:08 <CADD> Breadmonster: not just the docs, open up the source too
08:04:11 <Breadmonster> I have.
08:04:15 <mauke> applicative_: I linked to the actual source code
08:04:24 <mauke> ok, not quite
08:04:28 <ParahSailin> not sure why these dinosaur ghc 6.12.2 are always top google hits for standard libs http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Traversable.html
08:04:29 <chrisdone> Breadmonster: is there a book for monads? :-)
08:04:30 <mauke> an html processed version of it
08:04:39 <applicative_> mauke: yes, we were on the same page at the outset
08:04:54 <CADD> Breadmonster: There is no royal road to Haskell. -Euclid -Brent Yorgey
08:05:03 <applicative_> ah ghc-6.12 monster of 'split-base'; I remember it well
08:05:12 <chrisdone> ParahSailin: agreed, i think old versions should have anti-google-bot directives
08:05:12 <Breadmonster> Ah, alright.
08:05:54 <applicative_> with Hackage, google seems to be doing better
08:06:18 <geekosaur> I thought there was already a <meta> that allowed pages to indicate that what should be indexed is the latest version instead
08:06:24 <ParahSailin> ui've said that before that the robots.txt should just have that 6.12.2 crap in there
08:06:50 <ocharles> 'Options True True True True True True True True True True True True True True <$' -- I think that's my code snippet of the day
08:07:12 <chrisdone> ocharles: kill it with fire
08:07:25 <ocharles> there's nothing wrong with it!
08:07:33 <applicative_> Options True True True True True True True True True True True True True True <$ string "options"
08:07:57 <chrisdone> magic bools are just magic numbers with posher names
08:08:13 <ocharles> applicative_: close, it's actually Options True True ... <$ Optparse.switch (Optparse.long "bootstrap")
08:08:30 <applicative_> ah
08:08:32 <ocharles> chrisdone: record syntax really does not play well with applicative syntax
08:08:40 <chrisdone> get a better editor =p
08:08:45 <ocharles> (Options is a Record)
08:09:07 <CADD> ocharles: oh god, dat code
08:09:19 <ocharles> chrisdone: How would you get a function that is (String -> Options) using record syntax? you can't partially apply record syntax, can you?
08:09:23 * chrisdone wonders how many code decisions are made based on the "but my editor is crap" heuristic
08:09:29 <ocharles> I would have to introduce an anonymous function
08:09:35 <ocharles> I don't see what my editor has to do with this
08:10:03 <applicative_> your editor is wrong, if it isnt chrisdone 's
08:10:08 <ocharles> (\files -> Options { createDatabase = True, ..., files = files }) <$ foo -- is a little better, I suppose
08:10:13 <chrisdone> applicative_ knows what's up
08:11:16 <elliott> ocharles: (\files' -> def { files = files' }) <$ foo
08:11:32 <applicative_> i was going to say, you could do with a defaultOptions
08:11:36 <elliott> ocharles: (set files ?? def) <$ foo
08:11:46 <applicative_> ooo
08:12:03 <elliott> might not need the parens
08:12:07 <ParahSailin> how do i make "type CF = Foldable f => f (V.Vector a) -> (V.Vector a, V.Vector a)" a legal type synonym
08:12:10 <ocharles> I don't want to provide a default without files though, so it's basically what I just said
08:12:20 <ocharles> (\files -> Options { ..., files = files })
08:12:31 <ocharles> elliott: is set a lens thing?
08:12:32 <applicative_> ParahSailin: where's the a on the lhs?
08:12:34 <elliott> yes
08:12:40 <ocharles> not seen that one, let me look that up
08:12:42 <chrisdone> ocharles: i asked mauke to allow def to take args a while back but i don't remember being happy afterwards
08:13:07 <applicative_> ParahSailin: if it is 'existential' then it wont work.  if it's type CF a = ..., then RankNTypes, no?
08:13:07 <ParahSailin> applicative_: ah, the a needs something?
08:13:24 <ParahSailin> applicative_: thanks
08:13:33 <elliott> I think youy can put forall a. at the start
08:13:35 <elliott> well
08:13:37 <elliott> forall f a.
08:13:41 <elliott> since you'd lose the implicit quantification of the f
08:14:26 <ParahSailin> "type CF = Foldable f => f (V.Vector Int) -> (V.Vector Int, V.Vector Int)", still needs RankNTypes it looks like
08:14:49 <chrisdone> ocharles: instance Default (Bool -> Options) where def files = Options { …, files = files } would've worked otherwise
08:14:50 <ParahSailin> is RankNTypes a scary language extension?
08:15:03 <applicative_> no, it's excellent for various purposes
08:15:16 <applicative_> it's all the rage now that lens has made such sterling use of it
08:15:25 <ocharles> chrisdone: that looks even worse, that's way too implicit for my liking
08:15:27 <chrisdone> it was the rage for years before that
08:15:38 <chrisdone> ocharles: ic
08:15:51 <merijn> ParahSailin: The only problem with RankNTypes is that it breaks type inference (i.e. you will need to explicitly write down type signatures for all values that make use of it)
08:15:52 * applicative_ has a more robust conception of a 'rage'
08:16:01 <ocharles> I will introduce mkOptionsWithDefaults :: String -> Options, I thinks
08:16:21 <applicative_> ParahSailin: and your users will frequently be baffled not realizing they are likely to need it
08:16:30 <CADD> merijn: dont you usually explicitly state types anyway?
08:16:58 <CADD> merijn: from what ive heard its good practive just to do it for the next person that will read your code.
08:17:02 <merijn> CADD: Only for top-level declarations, usually. But yeah, it's not a big problem
08:17:15 <merijn> CADD: It's just a catch to be aware of
08:17:18 <CADD> merijn: ah, yeah i see
08:17:22 <CADD> merijn: good to know :)
08:17:38 <CADD> merijn: i havent used rankNtypes yet, so the more you know..
08:18:01 <merijn> RankNTypes are pretty obvious/simple once you actually need them
08:18:29 <chrisdone> hmm, i used them for something pretty obvious recently, i'll see if i can find it
08:18:50 <applicative_> CADD: the failure of inference shows up in various irritating ways, though.  as when you are writing something first and querying the type later
08:19:10 <applicative_> it will tend to misinterpret what you wrote
08:30:15 <applicative_> ocharles: what mad pipes project do you think is wanted? I was looking at the current 'ecosystem'
08:30:59 <lpvb> why can't I import a .cabal file into eclipsefP?
08:31:21 <ocharles> applicative_: we're still sorely in need of a http client
08:31:44 <ocharles> applicative_: there is some progress in that area, but not much
08:32:24 <ocharles> applicative_: ok, I don't think anything exists there yet :)
08:32:51 <ocharles> Our general plan is to reuse types and code from http-streams
08:33:13 <applicative_> oh. i was wondering about the http-conduit or whatever its called
08:33:23 <ocharles> If you're interested in the other side of HTTP, jeremy (stepcut) needs help on hyperdrive - https://github.com/stepcut/hyperdrive
08:33:56 <Clint> does that mean warp is not trustworthy
08:34:01 <ocharles> applicative_: I couuld use a bzip pipe too, but that's not very interesting
08:34:05 <ocharles> but it's very useful for me ;)
08:34:44 <ocharles> applicative_: pull requests welcome for pipes-crypto and pipes-random, which are mine (http://github.com/ocharles/pipes-random and https://github.com/ocharles/pipes-crypto )
08:35:42 <applicative_> yes, I know about hyperdrive
08:36:08 <applicative_> oh i see, http-streams has iostreams-independent types for the requests and so on
08:36:30 <ocharles> Yea
08:36:43 <applicative_> manages https unlike the standard library
08:36:47 <ocharles> And we want to reuse the parser there (it's an attoparsec one, so we should be able to just plop that on top of pipes-attoparsec)
08:37:09 <ocharles> basically, enough people have written general http code, so we want to only write the pipes specific stuff
08:37:37 <applicative_> it's very amusing that pandoc can't fetch a file that is posted via https "Error: https not supported"
08:37:53 <ocharles> ha
08:38:24 <applicative_> how am I supposed to read the newspaper these days?
08:38:29 <ocharles> applicative_: so, I dunno if any of that tickles your fancy?
08:39:27 <ocharles> You'll want to grab pipes from Github and compile the latest HEAD. Version 4 should be out soon, but the API is a bit different (and waaaay simpler)
08:39:33 <CADD> codesoup: No soup for you!
08:39:45 <ocharles> it's just 4 modules now, and it's lost a type parameter (and an entire type class along the way)
08:40:22 <CADD> codesoup: even though ive never seen sinefield, i somehow know about that episode.. O.o
08:41:03 <dgpratt> is that a math show?
08:41:54 <Clint> *rimshot*
08:42:11 <dgpratt> :)
08:42:11 <CADD> dgpratt: exactly
08:42:14 <CADD> :)
08:42:15 <lemao> CADD: these are the steps I took from scratch to get to Emacs24 to auto-complete and flycheck syntax errors - http://pastebin.com/tJyyEBAS
08:42:23 <mauke> The paste tJyyEBAS has been copied to http://lpaste.net/90806
08:42:26 <CADD> lemao: you are the man
08:43:07 <lemao> CADD: there is only one prob: I am not sure how to auto enable flycheck-mode on haskell files: I have to M-x flycheck-mode RET by hand
08:43:34 <CADD> hmmm.. did you try set-default?
08:43:40 <lpsmith> Has anybody given any thought about bindings that support multiple versions of a given C library,  and the PVP?
08:43:43 <lemao> CADD: how do I do that?
08:43:54 <CADD> (set-default 'truncate-lines t)
08:44:06 <CADD> s/truncate-lines/flycheck-mode/
08:44:11 <ofan> lpsmith: what's PVP?
08:44:12 <lpsmith> e.g.  I'd like for postgresql-libpq to support libpq versions 8.4, 9.0, 9.1, and 9.2
08:44:20 <lpsmith> ofan, Package Version Policy
08:44:47 <lpsmith> but there are some useful functions added to later libpq versions,  like escaping table names and whatnot
08:45:01 <lemao> CADD: what does truncate-lines do?
08:45:12 <quicksilver> packages shouldn't present a different API depending how they are compiled, lpsmith
08:45:27 <quicksilver> but you could have some functions return errors
08:45:33 <quicksilver> and some functions to query capabilities?
08:45:35 <lpsmith> quicksilver, I tend to agree
08:45:42 <lpsmith> but uck
08:45:44 <CADD> lemao: iirc, it sets screenwrap
08:45:57 <CADD> lemao: so the code doesnt go off the screen, it just stays on the page
08:45:58 <joshc> really? I would rather fail at compile time than runtime
08:46:15 <applicative_> ocharles: yes, i have the pipes-4.0 material, i sent in a patch update for pipes-bytestring though it turned out you had done this too...
08:46:20 <lpsmith> joshc, I agree
08:46:27 <CADD> lemao: however i set my font to a lot smaller so it doesnt happen pretty much ever
08:47:05 <lpsmith> I suppose one could create different versions for the haskell bindings that support later libpq versions
08:47:24 <lpsmith> which still,  yuck, but that might be less worse than the alternatives
08:47:31 <quicksilver> if you want the API to vary between libpq versions
08:47:38 <quicksilver> then you need separate (related) hackage packages
08:47:41 <quicksilver> IMO
08:48:34 <quicksilver> postgresql-libpq84-1.0.0
08:48:38 <quicksilver> postgresql-libpq92-1.0.0
08:48:39 <quicksilver> etc
08:48:41 <lpsmith> well, then that propagates up to higher level packages too,  then some versions of say postgresql-simple would support some features depending on which versions of postgres you are using
08:49:01 <quicksilver> as long as the API doesn't change, lpsmith
08:49:06 <quicksilver> if it does, then no no no :-)
08:49:07 <ocharles> applicative_: oh, oops :)
08:49:28 <lpsmith> quicksilver, some api change is unavoidable,  in some sense
08:49:35 <quicksilver> in what sense?
08:49:50 <applicative_> so much for my imaginativeness in coming up with productive labors, ocharles
08:49:54 <quicksilver> if I write a program which compiles against postgresql-simple on my machine
08:50:03 <quicksilver> then it must compile against postgresql-simple on your machine
08:50:08 <lpsmith> Well,  even now you can easily write code using postgresql-simple that requires version say, 9.2,  if you consider the SQL to be part of the API
08:50:13 <quicksilver> irrespective of libpq versions.
08:50:15 <lpsmith> that might be a bit of a stretch though
08:50:19 <quicksilver> lpsmith: ah, but I don't
08:50:23 <quicksilver> the API is something very specific :)
08:50:25 <quicksilver> in the sense I mean it.
08:50:30 <quicksilver> it's what GHC uses to compile.
08:50:40 <quicksilver> if the set of compilable programs is the same, then the API is the same.
08:52:07 <lpsmith> quicksilver, that doesn't quite seem to capture the issue;  eventually I'd like to be able to (optionally) check the SQL queries against a schema at compile time.
08:52:34 <lpsmith> So obviously something that compiles on my machine might not compile on yours,  if you don't have the right schema loaded
08:53:50 <CADD> lemao: well thats obvious
08:53:54 <CADD> lemao: ff sorry
08:54:01 <lpsmith> that's a tricky problem though, especially considering where and how you are checking the schema.    Some apps connect to multiple instances of postgresql with different schemas for example.
08:54:09 <CADD> lpsmith: well thats obvious, of course it wouldnt work if you dont have the right schema
08:54:46 <lpsmith> CADD, well taking quicksilver's criterion literally,  that doesn't include that behavior
08:55:25 <CADD> lpsmith: ok, you are right. gotta cover all the bases
08:55:26 <lpsmith> I'm just being pendantic and saying the definition of what an API is would need to be a bit more precise in this case.
08:55:27 <quicksilver> lpsmith: yes. My criterion doesn't really scale to TH-style work done at compeil time.
08:55:45 <quicksilver> lpsmith: I don't really know how to extend it; I don't think the PVP had that case in mind.
08:56:07 <lpsmith> quicksilver, I don't think so =)
08:56:44 <quicksilver> I guess the schema-checking is just a convenience over preprocessing and writing out actual schema source files
08:56:53 <quicksilver> and if you did that then *those* would compile on any machine.
08:57:06 <quicksilver> (you might want to be able to recompile the code on a machien without access to the Pg database, indeed)
08:57:13 <CADD> quicksilver: or you can always use a schemaless database
08:57:36 <CADD> quicksilver: but sql is a very well supported standard
09:02:08 <lpsmith> quicksilver, but then you'd need to duplicate a lot of postgres logic in haskell.  Yes, it would be more convenient for the user,  but assuming access to a postgres database for schema-checking purposes would be a lot saner for the implementor
09:02:33 <lpsmith> although there is something on hackage that can already do a lot of that
09:02:53 <ocharles> what is that?
09:03:10 <lpsmith> Jake Wheat wrote it,  hsqlppp or something like that
09:03:13 <lpsmith> let me look
09:03:48 <lpsmith> ocharles, http://hackage.haskell.org/package/hssqlppp
09:04:11 <quicksilver> lpsmith: sure. That was a thought experiment, that's all.
09:04:23 <quicksilver> there are issues with revision control and so on, too
09:04:37 <quicksilver> it can be convenient to have the actual generated schema files around.
09:04:57 <lpsmith> Another alternative is not to check the schema at compile time, but generate functions to check schemas at run-time
09:05:13 <lpsmith> quicksilver, it's a good thought experiment =)
09:05:19 <lpsmith> It's a thorny issue
09:05:20 <ocharles> lpsmith: cool
09:05:48 <lpsmith> there is something on hackage that assumes access to a postgresql database for syntax and type checking as well
09:06:00 <lpsmith> I forget what it's called,  it would take a bit of hunting
09:06:03 <quicksilver> (disclaimer: thought experiments may adversely affect future criminal liability)
09:06:37 <quicksilver> (see : http://what-if.xkcd.com/52/ )
09:06:40 <CADD> ocharles, lpsmith: there is always: https://github.com/hdbc/hdbc/wiki
09:07:13 <CADD> oh nvm, hssqlppp is a parser
09:07:14 <lpsmith> CADD, yes, I was a former HDBC user
09:07:33 <CADD> lpsmith: yeah i just realized what i said doesnt apply
09:07:40 <lpsmith> it doesn't provide any syntax or schema checking
09:07:48 <CADD> lpsmith: i should follow links before i comment.. :)
09:08:31 <lpsmith> HDBC has some advantages over postgresql-simple, but if you are willing to commit to postgresql,  postgresql-simple has many upsides and only a few downsides versus HDBC
09:09:04 <ocharles> I love postgresql-simple, my only dislike there is FromRow assumes a specific column ordering
09:09:16 <ocharles> I need to stop bitching about that and submit a pull request, of course
09:09:33 <lpsmith> Much broader featureset,  ability to add support for postgresql types in application code without changing the library,  higher performance,  etc.
09:09:42 <lpsmith> ocharles, yeah I agree
09:09:49 <lpsmith> (That it's a problem)
09:10:00 <ocharles> And you agree that a pull request would be nice, I'm sure ;)
09:10:13 <latermuse> what is the function to convert a Data.Map fromList into a normal list? Convert back to list from map
09:10:16 <lpsmith> maybe, I'm a little more ambivalent on that =)
09:10:29 <ocharles> :)
09:11:13 <latermuse> it cant be toList can it?
09:11:25 <namoamitabuddha> hoogle fromList
09:11:31 <namoamitabuddha> @hoogle fromList
09:11:32 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
09:11:32 <lambdabot> Data.IntMap.Strict fromList :: [(Key, a)] -> IntMap a
09:11:32 <lambdabot> Data.IntMap.Lazy fromList :: [(Key, a)] -> IntMap a
09:11:54 <ParahSailin> would "Vector.foldl' (\ax bx -> ax * ax + bx) 0 $ Vector.zip (-) p q" get streamfusioned?
09:12:18 <mauke> > M.toList
09:12:19 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
09:12:19 <lambdabot>    arising from a use ...
09:12:33 <mauke> > M.toList (M.fromList [("a", 1), ("b", 2)])
09:12:34 <lambdabot>   [("a",1),("b",2)]
09:12:50 <mauke> > M.toList (M.fromList [("b", 1), ("a", 2)])
09:12:51 <lambdabot>   [("a",2),("b",1)]
09:12:55 <mauke> thought so
09:29:37 * hackagebot universe 0.4.0.2 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.4.0.2 (DanielWagner)
09:37:36 <ParahSailin> @src concatMap
09:37:36 <lambdabot> concatMap f = foldr ((++) . f) []
09:39:40 <josephle> quick style question: when is it appropriate to use (<>) versus a type-specific function (e.g. (++))?
09:43:26 <dmwit> josephle: go with your heart
09:43:43 <josephle> sounds like a plan!
10:20:27 <nologinitems> Hey all, I've got an issue I've been trying to wrap my head around.  I'm in the middle of a function, one of the parameters for which is a list of tuples.  I'd like to assign to a new variable the last tuple in that list, modified if a certain condition is met.  I'm not sure how to do this.
10:21:12 <rul> Hi. Is there any shortcut for using the "any" and "all" functions with IO? I want to do something like: all doesDirectoryExist ["dir1", "dir2"]
10:21:19 <mcstar> you can create a new tuple
10:21:33 <Fuuzetsu> :t liftIO any
10:21:33 <lambdabot>     Couldn't match expected type `IO a0'
10:21:33 <lambdabot>                 with actual type `(a1 -> Bool) -> [a1] -> Bool'
10:21:34 <lambdabot>     In the first argument of `liftIO', namely `any'
10:21:39 <Fuuzetsu> :t liftIO
10:21:40 <lambdabot> MonadIO m => IO a -> m a
10:21:54 <geekosaur> liftIO isn't the right thing here
10:22:02 <Fuuzetsu> no, apparently it isn't
10:22:11 <pentace> :t (any <$>)
10:22:12 <lambdabot> Functor f => f (a -> Bool) -> f ([a] -> Bool)
10:22:22 <mcstar> :t lift
10:22:23 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:22:30 <Fuuzetsu> :t liftM
10:22:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:31:36 <rul> if there was an answer to my question, I couldn't catch it
10:31:50 <cdk> it's possible to fold a list of endofunctors with `foldr (.) id`. is it possible to fold a list of binary functions? something like binFold :: [a -> a -> a] -> a -> a -> a?
10:32:23 <nologinitems> Hey, I've simplified my question and made it into a paste at http://lpaste.net/90807
10:32:33 <nologinitems> I'm having trouble with the pattern matching in assignment
10:33:03 <nologinitems> I would be extremely grateful if someone could take a quick look at it and point me in the right direction
10:33:11 <pentace> :t fmap or .: mapM
10:33:11 <lambdabot>     Not in scope: `.:'
10:33:12 <lambdabot>     Perhaps you meant one of these:
10:33:12 <lambdabot>       `.' (imported from Data.Function),
10:33:15 <pentace> aww
10:33:24 <pentace> :t (fmap or.) . mapM
10:33:25 <lambdabot> (Monad f, Functor f) => (a -> f Bool) -> [a] -> f Bool
10:33:37 <pentace> rul: ^ Is that what you want?
10:35:36 <mcstar> > let dde :: String -> IO Bool; dde _ = return True in or <$> mapM dde ["dir1","dir2"]
10:35:38 <lambdabot>   <IO Bool>
10:35:45 <pentace> nologinitems: You could use Control.Arrow.first for that
10:35:47 <rul> pentace: I want to do something like this: 'all doesDirectoryExist ["dir1", "dir2"]'
10:36:12 <pentace> rul: Okay, that use "and" instaed of "or" in my example
10:36:14 <mcstar> pentace: what you wrote wont work if doesDirectoryExist :: String -> IO Bool
10:36:15 <pentace> *then
10:36:24 <cdk> nologinitems: getT (_,t) = t is snd
10:36:28 <cdk> :t snd
10:36:28 <lambdabot> (a, b) -> b
10:36:33 <merijn> nologinitems: btw, your getT function is just snd
10:36:34 <pentace> mcstar: Why not?
10:36:44 <mcstar> (any <$>) has the wrong type
10:36:46 <nologinitems> I actually simplified; the real tuple has about 5 elements
10:37:04 <rul> mcstar, pentace: thanks, I'll work with your answers
10:37:13 <pentace> mcstar: I meant that one:  (fmap or.) . mapM
10:37:29 <merijn> pentace: Because it'd return [IO Bool]
10:37:38 <mcstar> hm, i used or too, not and vis. all
10:37:54 <pentace> merijn: No O.o
10:37:55 <merijn> oh, wait
10:38:04 <merijn> pentace: I wasn't paying attention
10:38:18 <josephle> all this scramble, for want of an "allM"
10:38:24 <merijn> pentace: I thought mcstar was referring to a different bit of code, but that wasn't yours :p
10:38:38 <merijn> What's wrong with just "all <$> sequence stuff"
10:38:50 <merijn> Or even "all <$> mapM foo bar"
10:39:00 <danr> do you mean and?
10:39:05 <merijn> :t all
10:39:06 <lambdabot> (a -> Bool) -> [a] -> Bool
10:39:27 <merijn> :t \x -> all <$> mapM doesDirectoryExist x
10:39:28 <lambdabot> Not in scope: `doesDirectoryExist'
10:39:45 <mcstar> merijn: i suggested the same solution
10:39:50 <merijn> :t \x -> all <$> mapM (undefined :: String -> IO Bool) x
10:39:51 <lambdabot>     Couldn't match type `[Bool]' with `a0 -> Bool'
10:39:51 <lambdabot>     Expected type: IO (a0 -> Bool)
10:39:51 <lambdabot>       Actual type: IO [Bool]
10:39:52 <mcstar> with or->and
10:39:53 <cdk> nologinitems: this code is full of syntax errors, I'm not sure how its supposed to work. could you try cleaning it up so it compiles and pasting it again?
10:40:13 <danr> :t and
10:40:14 <lambdabot> [Bool] -> Bool
10:40:20 <latermuse> simpleHTTP from Network.HTTP seems to return a String. Is there any way to have it return a bytestring instead? Or perhaps a different library that can?
10:40:24 <pentace> anyM = (fmap or .) . mapM;  allM = (fmap and .) . mapM; that's how I would do it
10:40:42 <merijn> nologinitems: Also, I would recommend using more helper functions and shorter lines
10:40:48 <merijn> latermuse: http-conduit
10:40:59 <josephle> :t \x -> and <$> mapM (undefined :: String -> IO Bool) x
10:41:00 <lambdabot> [String] -> IO Bool
10:41:20 <latermuse> merijn: hmm okay
10:41:52 <latermuse> merijn: actually that looks exactly like what im looking for. thanks!
10:41:56 <merijn> latermuse: it has a "simpleHttp :: String -> IO ByteString"
10:42:14 <latermuse> merijn: exactly! thanks a ton
10:42:17 <merijn> latermuse: Extra bonus, you can hook it up easily to xml-conduit or html-conduit for parsing
10:42:26 <cdk> nologinitems: also, if you're often modifying the last element in your list, a list is probably not the best data structure to be using. I'd suggest Data.Seq which has O(1) access to the first and last elements
10:42:31 <pentace> rul: Apparently, the monad-loops package already has these functions
10:42:40 <latermuse> mouth watering now ... excellent
10:42:56 <nologinitems> Ok, thanks all.  I'll try cleaning up the code a bit and reposting
10:43:10 <cdk> nologinitems: Data.Seq will let you pattern match on the first and last elements with "views" to the left and right ends of the sequence
10:43:55 <S_J> is UML usable for functional programming/haskell?
10:44:04 <rul> pentace: ok, I'll search in that package
10:44:05 <S_J> is there any other modeling language that is suitable?
10:44:09 <merijn> S_J: Is UML usable for any type of programming?!?
10:44:27 <S_J> merijn: isnt it good for OO? what is your criticism?
10:45:00 <dmwit> merijn, mcstar: But and/mapM doesn't short circuit properly.
10:45:10 <klrr_> morning
10:45:25 <aristid> merijn: UML sequence diagrams don't suck completely :D
10:45:36 <merijn> dmwit: oh, right
10:45:51 <merijn> S_J: I've done OO before, I think they're terrible there too
10:46:16 <josephle> dmwit: so is there a solution to rul's problem, short of implementing allM?
10:46:24 <merijn> josephle: monad-loops
10:46:28 <dmwit> I don't know, I wasn't paying attention.
10:46:45 <dmwit> What's rul's problem?
10:46:50 <aristid> merijn: which kind of "OO"? was it java? if not, UML just wasn't designed for your crazy kind of OO
10:47:01 <pentace> dmwit: What do you mean by "doesn't short circuit properly"?
10:47:02 <merijn> aristid: Java, Python, C++
10:47:11 <merijn> pentace: It will evaluate all actions
10:47:16 <dmwit> pentace: It runs the effects of all the actions, even if some early action returns False.
10:47:20 <merijn> pentace: Because mapM uses sequence
10:47:29 <rul> josephle, dmwit: importing allM worked as a charm
10:47:31 <josephle> dmwit: he basically wanted "allM", so he could write something like "allM doesDirectoryExist ["dir1, "dir2"]"
10:47:31 <pentace> Ah
10:47:31 <merijn> pentace: And sequence will always evaluate all actions in the list
10:47:39 <josephle> rul: so there *is* an allM
10:47:46 <rul> josephle: right
10:47:49 <dmwit> The solution is not to call doesDirectoryExist.
10:47:49 <josephle> didn't know that
10:47:50 <merijn> josephle: Yes, I just said, in the monad-loops package
10:47:51 <dmwit> It's a race condition.
10:47:55 <aristid> merijn: just to be sure not to be misunderstood: the class inheritance/membership diagrams (no idea what they're called) in UML really suck
10:48:01 <dmwit> Just do what you want to do with the directory and catch the exception when it doesn't exist.
10:48:19 <merijn> aristid: Most UML diagrams suck and the non-sucky ones exist outside UML anyway
10:49:13 <aristid> merijn: i guess i was also abusing sequence diagrams when i used them to describe the operation of a network protocol :D
10:49:35 <merijn> aristid: That's what flowcharts were invented for
10:49:40 <aristid> no.
10:49:58 <aristid> the nice thing about the sequence diagram i used was the visual stratification
10:50:10 <aristid> each network agent had one vertical line
10:50:18 <aristid> makes it way easier to parse the image IMHO
10:50:52 <merijn> oh, those things
10:51:00 <merijn> I don't think they're a UML invention
10:51:04 <dmwit> "This other tool is better for the task" does not contradict "flowcharts were invented for that task".
10:51:15 <aristid> merijn: probably not, but UML included them :)
10:51:44 <aristid> dmwit: you're right, but i think merijn also meant the thing he didn't write that i did respond to.
10:51:51 * josephle realizes he's in a channel full of logicians
10:51:53 <dmwit> ...I take it back. What I said is true but stupid.
10:52:02 <dmwit> aristid: agreed
10:52:44 <merijn> Just stolen by UML
10:53:23 <aristid> merijn: on the whole i think we do agree that UML sucks. :)
10:53:31 <merijn> aristid: Well, I thought you were describing modeling one nodes in a protocol, which is where you'd use flowcharts
10:53:39 <merijn> i.e. to model the FSM of a node
10:54:08 <dmwit> Do you think there's a formal model of being a deity?
10:54:13 <dmwit> If so, perhaps somewhere out there is the FSM FSM
10:54:17 <aristid> nah the focus were the network messages, with only an informal description of the state of the nodes
10:54:19 <merijn> @quote theomorphism
10:54:20 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
10:54:20 <lambdabot> object in the category of religions and theomorphisms.
10:54:44 * hackagebot unm-hip 0.0.0.1 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.0.0.1 (JosephCollard)
10:54:52 <merijn> heh
10:54:53 <klrr_> mm_freak: ab9rf and all others, didnt mean to offend anyone, sry but i was in a bad mood, thanks for trying to help me and stuff, i gonna go with learning curve you guys suggested
10:55:00 <merijn> I parsed that as "un-hip" initially :)
10:55:01 <mcstar> dmwit: indeed it does not short circuit, but i dont see why atm :S
10:55:03 <klrr_> sry mm_freak ab9rf ...*
10:55:17 <merijn> mcstar: It uses sequence
10:55:21 <dmwit> mcstar: First you mapM. Then you and.
10:55:36 <dmwit> mcstar: and short-circuits. But it doesn't matter because you've already done all the effects and shot yourself in the foot.
10:55:54 <mcstar> is this because something is strict?
10:55:59 <merijn> mcstar: no
10:56:03 <merijn> :t sequence
10:56:04 <lambdabot> Monad m => [m a] -> m [a]
10:56:05 <dmwit> This has nothing to do with strictness, no.
10:56:07 <merijn> @src sequence
10:56:08 <lambdabot> sequence []     = return []
10:56:08 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:56:08 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:56:21 <dmwit> Well.
10:56:25 <dmwit> It has a bit to do with strictness.
10:56:35 <merijn> mcstar: look at the second line, "sequence xs" is evaluated before "return (v:vs)" happens
10:56:47 <dmwit> Specifically: we don't realize we've got a (:) in (return (v:vs)) until we've already sequenced the remainder of xs.
10:56:54 <aristid> dmwit: short-circuiting monad combinators are certainly a nice thing, but i found a library for them just doesn't cross the fairbairn threshold</digging out ancient terms>
10:57:19 <merijn> aristid: Clearly it does, because monad-loops is a thing and it's great!
10:57:22 <bennofs> How silly do you rate this hack: #if not(MIN_VERSION_template_haskell(2,8,0,0)) #define StarT StarK #define ArrowT ArrowK
10:57:27 <bennofs> #endif
10:57:45 <aristid> merijn: monad-loops does more than that, but i didn't realize it has short-circuiting combinators, must have missed that.
10:58:36 <dmwit> short-circuiting monad combinators would be an amazing thing. But I don't know of any.
10:59:05 <dmwit> monad-loops is more of a "hope the actual loop you're thinking of is available" thing than a "build your loop out of these basic building blocks" thing.
10:59:26 <merijn> We already have "build your loop out of these basic building blocks"
10:59:30 <merijn> It's called haskell
10:59:32 <aristid> dmwit: it does have andM
10:59:41 <aristid> and orM
10:59:56 <dmwit> Yes. I would not exactly call those combinators, though.
11:00:04 <dmwit> There are plenty of other short-circuiting binary operators that are not covered.
11:00:14 <aristid> fair enough.
11:00:37 <nologinitems> cdk: I've repasted the code.  Still some problems with compilation that I can't figure out but it should be a *lot* clearer now
11:00:41 <nologinitems> merijn: I've repasted the code.  Still some problems with compilation that I can't figure out but it should be a *lot* clearer now
11:00:44 <nologinitems> http://lpaste.net/90807
11:01:07 <SrPx> How do I print a random list of floats? main = do seet <- newStdGen; putStrLn (show (take 10 random)) ... ?
11:01:24 <aristid> dmwit: i did in fact write a package trying to do something like that, but no longer use it myself. http://hackage.haskell.org/packages/archive/shortcircuit/0.1/doc/html/Control-Shortcircuit.html
11:02:29 <dmwit> hm
11:02:41 <dmwit> I'm not sure there's only two good ways to short-circuit per type.
11:03:01 <merijn> SrPx: You might want randoms
11:03:07 <aristid> dmwit: which others do you think of?
11:03:08 <merijn> :t randoms
11:03:10 <lambdabot> (RandomGen g, Random a) => g -> [a]
11:03:23 <merijn> SrPx: It generates an infinite list of random values
11:03:55 <mcstar> dmwit: so what would be the proper short circuiting solution? use a monad like Maybe or Either?
11:04:05 <merijn> "main = do { seed <- newStdGen; print . take 10 $ randoms seed }"
11:04:07 <dmwit> aristid: e.g. for Ordering I could imagine GT, LT, or EQ all being good places to short-circuit for various operators.
11:04:16 <dmwit> aristid: I don't know!
11:04:37 <aristid> dmwit: if you find something that's actually generic and usable, that'd be interesting:)
11:05:24 <dmwit> shortM :: (a -> b -> Either a c) -> a -> [m b] -> m c -- perhaps
11:05:29 <merijn> nologinitems: What's wrong with "modify (x,y) = (x+1, y+1)"?
11:05:52 <merijn> nologinitems: Then you can just use "modify (last model)"
11:06:24 <SrPx> merijn: mbiguous type variable `a0' in the constraints:Probable fix: add a type signature that fixes these type variable(s)     In the first argument of `(.)', namely `print'     In the expression: print . take 10
11:06:34 <SrPx> I don't understand what is this telling me?
11:06:47 <mcstar> you didnt specify what kind of random things want
11:06:50 <latermuse> anyone know how to get this to match correctly? Couldn't match type `T.Text' with `Data.Text.Lazy.Internal.Text'
11:07:00 <SrPx> mcstar: how do I specify that I want a float?
11:07:15 <aristid> dmwit: a basic building block shouldn't take lists :P
11:07:17 <dmwit> latermuse: Perhaps T is Data.Text.Strict.
11:07:22 <mcstar> you can fix the type of 'randoms'
11:07:25 <dmwit> aristid: You might be right!
11:07:27 <latermuse> dmwit: ah! makes sense. thanks
11:07:37 <cdk> nologinitems: your `isPulseTime` is still incorrect. Heres a much clearer version `any ((==) (getT (last model))) pulseT`
11:07:44 <latermuse> dmwit: it compiled. thanks!
11:07:55 <SrPx> mcstar: but how? (randoms :: Float) doesn't work, maybe because of the seed?
11:08:12 <dmwit> aristid: In any case, I don't know, and I don't really intend to think about it now because I think it's a hard problem. Hence "would be great" in my opening statement. ;-)
11:08:22 <mcstar> :t randoms
11:08:23 <lambdabot> (RandomGen g, Random a) => g -> [a]
11:08:39 <merijn> SrPx: "randoms seed :: [Float]"
11:08:43 <mcstar> you need to tell the type of that stands for a
11:08:45 <merijn> :t randoms
11:08:46 <lambdabot> (RandomGen g, Random a) => g -> [a]
11:08:49 <merijn> :t randoms undefined
11:08:50 <lambdabot>     Could not deduce (RandomGen g0) arising from a use of `randoms'
11:08:50 <lambdabot>     from the context (Random a)
11:08:50 <lambdabot>       bound by the inferred type of it :: Random a => [a] at Top level
11:08:56 <merijn> blah
11:09:52 <SrPx> Well, thanks, that works. I'm not sure why, though. macph , could I do (randoms :: RandomGen, [Float]) instead? Just for curiosity
11:10:17 <SrPx> macph: sorry, meant to merijn
11:10:50 <mcstar> what you see in the paren, is a type predicate
11:11:06 <merijn> SrPx: The reason why is that type inference is saying it should produce a list of "Random a => [a]" and it's giving that to "print :: Show a => a -> IO ()"
11:11:09 <mcstar> you should do as merijn suggested, plug in the first hole of randoms, and fix the type then
11:11:32 <merijn> SrPx: There are, however, many different types that are both Random and Show instances, so how does it know which to pick?
11:11:56 <SrPx> merijn: oh, I see, makes absolute sense
11:12:01 <merijn> SrPx: If you had given the result to a function that had type "[Float] -> Foo", type inference would've figured out you wanted a list of Float for you
11:12:20 <merijn> SrPx: So you only have to do this annotation if there's not enough info to infer it
11:12:42 <SrPx> I see, interesting
11:13:35 <thoughtpolice> johnw: ping
11:14:25 <SrPx> merijn: so well, how to fix directly randoms instead of (randoms seed)? Just for learning
11:15:22 <SrPx> merijn: I have tried some things such as (randoms :: RandomGen -> [Float]) seed
11:15:33 <SrPx> I'm not sure what's the right notation, though. And what is the difference of => and ->
11:16:00 <alexander__b> I have a function that returns a Maybe [Double]. now I want to putStrLn either that or "bork bork!" or something to that effect if Nothing is returned. can anyone point me to an example or explain how to do this?
11:16:33 <mcstar> randomsF :: (RandomGen g) => g -> [Float]; randomsF = randoms, i think
11:16:56 <mcstar> i forgot which module contains random
11:16:59 <mcstar> @hoogle randoms
11:17:00 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
11:17:00 <lambdabot> Test.QuickCheck.State randomSeed :: State -> StdGen
11:17:04 <cdk> alexander__b: print $ maybe "borked" id (f :: Maybe [Double]
11:17:14 <cdk> > print $ maybe "borked" id (Just [1,2,3])
11:17:15 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:17:15 <lambdabot>    arising from the literal `1...
11:17:19 <mcstar> weird
11:17:20 <cdk> > print $ maybe "borked" id (Just [1,2,3] :: Just [Int])
11:17:21 <lambdabot>   Not in scope: type constructor or class `Just'
11:17:21 <lambdabot>  A data constructor of that ...
11:17:25 <mcstar> i dont have System.Random
11:17:25 <cdk> > print $ maybe "borked" id (Just [1,2,3] :: Maybe [Int])
11:17:26 <lambdabot>   Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
11:17:26 <lambdabot>  Expected type: D...
11:17:34 <alexander__b> you are spamming too much for me to keep up
11:17:43 <cdk> sorry, silly type errors
11:17:44 <merijn> SrPx: "f :: a -> b" means "f is a function from type a to type b"
11:18:05 <alexander__b> cdk: thanks for the pointer.
11:18:23 <merijn> SrPx: "f :: Num a => a -> a" means "if, and only if, type a is an instance of Num, then f is a function from type a to type b"
11:18:24 <mcstar> how can i not have a System.Random module? doesnt it come with ghc?
11:18:40 <merijn> mcstar: No, I think it's from the randoms package?
11:18:50 <mcstar> ok
11:18:50 <SrPx> merijn: makes sense!
11:19:26 <klrr_> okey im watching this https://www.youtube.com/watch?v=-IpE0CyHK7Q , i dont really get how AFRP works, but when those values started printing in ghci i was like WOW :D
11:19:55 <SrPx> merijn: but I still don't see how that could be used to fix randoms. (randoms :: StdGen -> [Float]) still makes sense ("random is a function that receives a StdGen and returns a list of floats")
11:20:34 <merijn> :t randoms :: RandomGen g => g -> [Float]
11:20:36 <lambdabot> RandomGen g => g -> [Float]
11:20:47 <SrPx> oh wait, it actually worked as I did. cool
11:21:11 <mcstar> you are making the function less and less polymorphic
11:21:34 <SrPx> mcstar: I know, this was just an exercise to see if I got it
11:21:41 <cdk> > maybe (putStrLn "borked") print (Just [1,2,3]) -- alexander__b
11:21:43 <lambdabot>   <IO ()>
11:21:58 <alexander__b> cdk: thanks I'll try that on for size
11:22:10 <klrr_> > \_ -> putStrLn "hello"
11:22:11 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:22:12 <lambdabot>    arising from a use ...
11:22:22 <klrr_> > \_ -> "hahhahah"
11:22:23 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:22:23 <lambdabot>    arising from a use ...
11:22:26 <mpu> Hi, I always see finding a solution to D = D->D in Set is impossible by "simple cardinality argument", where can I find a short writeup of this simple argument?
11:22:34 <klrr_> > (\_ -> "hahhahah") 2
11:22:35 <benmachine> > putStrLn $ maybe "borked" show (Just [1,2,3])
11:22:35 <nabilhassein> is there no online documentation of the API for the haskell llvm package?
11:22:35 <alexander__b> cdk: is this not a case for fromMaybe though?
11:22:35 <lambdabot>   "hahhahah"
11:22:36 <lambdabot>   <IO ()>
11:22:36 <nabilhassein> http://hackage.haskell.org/package/llvm
11:22:38 <klrr_> > (\_ -> "hahhahah") 2
11:22:39 <klrr_> > (\_ -> "hahhahah") 2
11:22:39 <nabilhassein> i don't see any links
11:22:39 <lambdabot>   "hahhahah"
11:22:40 <lambdabot>   "hahhahah"
11:22:50 <klrr_> > \ -> "hahah"
11:22:51 <lambdabot>   <hint>:1:3: parse error on input `->'
11:22:56 <klrr_> > (\ -> "hahah")
11:22:57 <benmachine> klrr_: don't do that
11:22:57 <lispy> it's funny how often people compare languages to me
11:22:57 <lambdabot>   <hint>:1:4: parse error on input `->'
11:23:01 <roboguy_> klrr_: why all the const functions?
11:23:02 <cdk> alexander__b: benmachine's version is better
11:23:18 <mcstar> klrr_: talk to lambdabot in private, or just use local ghci
11:23:18 <lispy> I'm frequently getting highlights in my irc client :)
11:23:33 <alexander__b> cdk: OK
11:23:35 <alexander__b> benmachine: thanks
11:23:37 <mcstar> ofc, use lambdabot here for demonstration, but not for spamming
11:23:48 <alexander__b> benmachine: what is "maybe" with lowercase 'm'? I'll have to look that up.
11:23:50 <klrr_> mcstar: okey
11:23:51 <klrr_> sry
11:23:55 <benmachine> mpu: the short version is, D -> D is at least as big as D -> 2, which is the same size as the powerset of D, which is bigger than D by Cantor's argument
11:23:55 <cdk> @src maybe
11:23:56 <lambdabot> maybe n _ Nothing  = n
11:23:56 <lambdabot> maybe _ f (Just x) = f x
11:23:59 <roconnor> @type maybe
11:24:00 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:24:09 <mpu> benchmachine, thanks
11:24:11 <roconnor> @. djin type maybe
11:24:11 <lambdabot> Plugin `compose' failed with: Unknown command: "djin"
11:24:16 <roconnor> @. djinn type maybe
11:24:17 <lambdabot> f a b c =
11:24:17 <lambdabot>     case c of
11:24:17 <lambdabot>     Nothing -> a
11:24:17 <lambdabot>     Just d -> b d
11:24:20 <benmachine> mpu: if you want elaboration on any part of that, I can provide it
11:24:30 <mpu> benchmachine, I need to find about Cantor's argument though...
11:24:43 <benmachine> mpu: incidentally you are spelling my name wrong :)
11:24:54 <alexander__b> cdk: interesting.
11:25:00 <mpu> sorry, no tab completion here
11:25:22 <mpu> I still need to implement it :)
11:25:36 <SrPx> How do I force haskell to compute something? I'm trying to find out how much time it takes to sort a random list, but it always returns instantly, regardless of the size of the list, because I'm not using the results
11:26:04 <SrPx> Except if I print them, but then printing itself takes some time so it'll screw my results
11:26:06 <roboguy_> SrPx: $! is the strict function application operator, maybe that would help
11:26:16 <benmachine> mpu: do you know what a bijection is, and how they relate to set sizes?
11:26:21 <alexander__b> benmachine: could you show me that example when doing f x?
11:26:21 <c_wraith> SrPx: since the result is a list, you probably want deepseq
11:26:26 <mpu> benmachine, I do
11:26:28 <roconnor> SrPx: mapM evaluate
11:26:28 <Eduard_Munteanu> :t foldr seq ()
11:26:29 <lambdabot> [a] -> ()
11:26:31 <alexander__b> benmachine: so "bork" or f x (which would be a Just [Double])
11:26:39 <roconnor> :t mapM evaluate
11:26:40 <lambdabot> [b] -> IO [b]
11:26:41 <klrr_> roboguy_: $! how does it work? :D
11:26:47 <SrPx> 	let rs = qsort $! take 20000000 $ (randoms (mkStdGen 1) :: [Float])
11:26:51 <alexander__b> benmachine: that is, my f x would return Just [Double] or Nothing.
11:26:52 <SrPx> I think this worked.
11:27:08 <benmachine> alexander__b: so what do you want to do in the Just case, and what do you want to do in the Nothing case?
11:27:09 <roconnor> SrPx: no it doesn't.
11:27:16 <SrPx> Yea, it doesn't.
11:27:36 <mcstar> SrPx: you could ask for the sum of the list, and just print that
11:27:45 <mcstar> it will need to evalute the whole list
11:27:46 <roconnor> SrPx: mapM evaluate
11:27:57 <alexander__b> benmachine: I want to print "bork" if Nothing, and print the [Double] in the Just case. I will likely convert the function to just return a String later though, so printing "bork" or Just String would be my intention.
11:28:17 <SrPx> roconnor: thanks, but what do those do exactly?
11:28:28 <mpu> benmachine, no need to go further, I think I can figure the rest out with diagonalization
11:28:43 <benmachine> mpu: ah, okay
11:28:55 <benmachine> mpu: except by the time you'd said that I'd basically typed it all out anyway
11:28:56 <mpu> benmachine, thanks
11:29:09 <benmachine> mpu: okay, here's the basic idea: suppose you have a function f from D to D -> D. construct the function g : D -> D that takes a d : D and returns any D that is not f(d)(d). then g can't be f(d) for any d, because it differs on argument d
11:29:13 <benmachine> something like that
11:29:18 <benmachine> note you need D to have size at least 2
11:29:26 <roboguy_> klrr_: f $! x is the same as x `seq` f x
11:29:44 * hackagebot nitro 0.2.2.5 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.2.5 (ErinDahlgren)
11:29:49 <benmachine> (when D has size 1 it is Set-isomorphic to D -> D)
11:29:53 <mpu> benmachine, yes, I 1 = 1 -> 1.
11:30:17 <roconnor> SrPx: (evaluate x) forces x into (weak) head normal form when this IO action is executed.
11:30:26 <benmachine> @type putStrLn . maybe "bork" show
11:30:27 <lambdabot> Show a => Maybe a -> IO ()
11:30:28 <benmachine> alexander__b: ^^
11:30:30 <roconnor> SrPx: mapM evaluate executes evaluate on every element of a list.
11:30:52 <SrPx> roconnor: it still is returning instantly :l
11:30:54 <benmachine> alexander__b: so putStrLn . maybe "bork" show $ thing will do what you want
11:31:00 <alexander__b> benmachine: hm. looks nice. thanks! I'll try to work it out. thank you for your patience.
11:31:07 <SrPx> 	let rs = mapM evaluate . qsort . take 2000000 $ (randoms (mkStdGen 1) :: [Float])
11:31:16 <mcstar> SrPx: have you tried the sum?
11:31:23 <benmachine> alexander__b: the idea of "maybe" is the first argument is what to do in the Nothing case, and the second argument is what to do in the Just case
11:31:32 <SrPx> mcstar: I will, but that will screw the results a little
11:31:37 <alexander__b> benmachine: I see. thanks.
11:31:41 <mcstar> it shouldnt matter
11:31:55 <SrPx> mcstar: it works, but ...
11:32:03 <alexander__b> benmachine: I'm introducing error handling to my first "real world" haskell application, so baby steps here. thanks a lot for the help. :-)
11:32:19 <benmachine> alexander__b: no problem :
11:32:20 <cdk> alexander__b: well, the first argument is a default value for the Nothing case, the second argument is a function that takes a (Just x) and does something with the x
11:32:20 <benmachine> :)
11:32:49 <cdk> the function should return a value of the same type as the default value you gave for the Nothing case
11:32:54 <mcstar> SrPx: it is not like evaluate or deepseq does not have additional cost
11:33:02 <benmachine> yeah, the idea is that case x of Nothing -> n; Just x -> f x -- is the same as maybe n f x
11:33:13 <mcstar> pls, someone confirm me, but i think they cost at least around an addition operation
11:33:38 <alexander__b> benmachine: I have seen the former construct in learn you a haskell. that makes it very clear for me what maybe does. thanks.
11:34:05 <alexander__b> (and I thought haskell was elegant and clever *before* I learned any of these utility functions!)
11:34:24 <roconnor> @index mkStdGen
11:34:24 <lambdabot> System.Random
11:34:48 <cdk> :t either -- alexander__b: if you've seen the Either type, its a more informative way to handle errors than Maybe and it has a similar function.
11:34:49 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:35:07 <roconnor> why don't I have System.Random?
11:35:10 <tathougies> say i have a module defining a datatype and I want to specialise it, but i want to specialise it for a datatype that is defined outside the module, is that possible?
11:35:10 <alexander__b> cdk: I have seen it. I should read up on that again. thanks for reminding me.
11:35:24 <mcstar> roconnor: i had the same problem, install package 'random' :)
11:35:33 <mcstar> i thought it came with ghc
11:35:38 <tathougies> i thought all i would have to do is declare the functions i want to specialise as 'inlinable', but that doesn't seem to do it from the core output...
11:35:44 <quchen> roconnor: It's not part of GHC, but the Platform.
11:35:53 <roconnor> guerrilla: It's fucking Haskell 98!!
11:36:39 <mcstar> the sound of silence
11:36:42 <cdk> tathougies: this might help: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma
11:37:07 <tathougies> :o
11:37:09 <tathougies> hmm...
11:37:12 <alexander__b> roconnor: install the random number library? worked for me...
11:38:09 <roconnor> did they remove it from haskell 2010 without even mentioning it?
11:38:13 <tathougies> should the specialised function be output in the core?
11:38:28 <quchen> There was never a random package in Haskell 98.
11:38:47 <quchen> "Is Haskell 98" means "compatible with 98".
11:39:06 <roconnor> hello
11:39:19 <roconnor> http://www.haskell.org/onlinereport/random.html
11:40:05 <cdk> yes, GHC will generate a seperate function that uses the specialized types.
11:40:51 <ion> I take it there is no guarantee that, say, randoms (mkStdGen 0) :: [Word32] will generate the same output with all versions of all Haskell compilers?
11:40:59 <dmwit> I think it's fine that the H2010 report doesn't contain references to the H98 report.
11:41:55 <quchen> roconnor: Well, the Haskell 98 report is split into a "language" and a "libraries" report, and I think "H98" usually refers to the language part.
11:42:09 <roconnor> I give up
11:42:10 <quchen> There is the libraries part, which seems to be an early attempt at the Platform.
11:42:21 <quchen> That being said, install the Platform, which is where random numbers are.
11:43:17 <dmwit> roconnor: I mean, if you're so into H98, you can depend on the haskell98 package and you will then have System.Random...
11:43:22 <quchen> roconnor: " The original Haskell Report covered only the language, together with a standard library called the Prelude. By the time Haskell 98 was stabilised, it had become clear that many programs need access to a larger set of library functions (notably concerning input/output and simple interaction with the operating system). If these program were to be portable, a set of libraries would have to be standardised too. A separate effort was
11:43:22 <quchen>  therefore begun by a distinct (but overlapping) committee to fix the Haskell 98 Libraries. "
11:43:44 <dmwit> Or maybe I don't understand what it is that you wish were different.
11:44:29 <dmwit> ...or rather, you'll have Random. No hierarchical libraries for you!
11:45:18 <dmwit> ion: I dunno. The code doesns't look terribly compiler-specific to me. Then again I doubt, as you say, that it's a guarantee the library is consciously trying to maintain.
11:45:34 <robde> hello. in what way is newtype strict opposed to data? I tried this one: newtype T = T String;  let x = T (map (\ _ -> 'r') [1..]) in (\ (T s) -> take 5 s) x   but that seems to evalutat in the same way as data T
11:45:42 <tathougies> cdk: wasn't compiling with -O2 :$
11:45:47 <alexander__b> learn yuo a haskell has the following function. does it already exist in haskell/can I do it easier/shorter?
11:45:49 <alexander__b> readMaybe :: (Read a) => String -> Maybe a
11:45:51 <alexander__b> readMaybe st = case reads st of [(x,"")] -> Just x
11:45:51 <tathougies> i think it's fixed now
11:45:53 <alexander__b>                                 _ -> Nothing
11:46:10 <dmwit> robde: compare "seq (T undefined) 3" between newtype and data.
11:46:19 <quchen> alexander__b: readMaybe is in the standard libraries now I think
11:46:47 <alexander__b> quchen: oh. my hoogle doesn't show readMaybe.
11:46:57 <dmwit> robde: Or, if you're not into seq, compare "case T undefined of T _ -> 3" between the two.
11:46:59 <alexander__b> quchen: :t readMaybe fails
11:47:00 <quchen> alexander__b: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#v:readMaybe
11:47:02 <alexander__b> > :t readMaybe
11:47:03 <lambdabot>   <hint>:1:1: parse error on input `:'
11:47:10 <alexander__b> >:t readMaybe
11:47:23 <alexander__b> I suck at the bot apparently.
11:47:23 <dmwit> Don't use readMaybe. =(
11:47:35 <quchen> dmwit: Don't use read :-)
11:47:37 <alexander__b> :t readMaybe
11:47:39 <lambdabot> Not in scope: `readMaybe'
11:47:41 <dmwit> quchen: agreed
11:47:46 <dmwit> quchen: reads is superior to both.
11:48:02 <Saizan> case T undefined of T _ -> 3 == 3 both with newtype and data T, unless you have a strict field
11:48:10 <quchen> dmwit: Even that is a bit of a drop-in for a proper parser
11:48:10 <alexander__b> well suggestions are welcome. I'm learning, heh.
11:48:16 <robde> dmwit: the one with case.. evaluates the same way
11:48:19 <dmwit> Saizan: ...yikes, yes. Man.
11:48:31 <dmwit> newtypes are subtle. =(
11:49:03 <dmwit> robde: Okay, try this one instead: case undefined of T _ -> 3
11:49:08 <dmwit> robde: =)
11:49:47 <Saizan> that shows how newtype is lazier though :)
11:50:19 <dmwit> yep
11:50:24 <alexander__b> how do you guys usually do licence headers in haskell?
11:50:26 <Saizan> anyhow the bottom line is that a newtype constructor is not there
11:50:36 <merijn> alexander__b: What do you mean by headers?
11:50:37 <quchen> alexander__b: ""
11:50:37 <klrr_> wait, is IO monad a cheat, is some IO functions implemented with unsafePerformIO ?
11:50:43 <Saizan> so it doesn't help delaying nor forcing things
11:51:01 <quchen> alexander__b: Until you finish LYAH, using Read is alright. But keep in mind that reading "01234" may have multiple different interpretations, and you should take care of which one to choose yourself. Read picks one or more somewhat arbitrarily. Using a parser you know (and can influence the baviour of) is something I'd rather recommend. (Also the error messages are better.)
11:51:10 <dmwit> I can't really imagine much of a reason to use unsafePerformIO when defining an IO action.
11:51:12 <alexander__b> quchen: how does that work? come to think of it, learn you a haskell only uses -- heh
11:51:17 <merijn> > read "0123" :: Bool
11:51:18 <lambdabot>   *Exception: Prelude.read: no parse
11:51:32 <quchen> alexander__b: The problem gets more obvious when you're reading nested data types, such as "Just [1,2,3]" etc.
11:51:36 <Saizan> klrr_: there are fine models of IO that don't need impurity, GHC under the hood does otherwise though
11:51:37 <alexander__b> quchen: OK. I have finished that book. I' mtrying to write my first app to test.
11:52:14 <FreeFull> alexander__b: I think usually people just have a separate LICENSE.txt or something similar
11:52:23 <quchen> alexander__b: Think of Read as a very ad-hoc serialization typeclass, similar to Show (which is not for prettyprinting but to print data structures so you can reconstruct them ...ish)
11:52:24 <dmwit> s/.txt//
11:52:28 <alexander__b> quchen: I thought I'd stick in a licence header and pastebin/upload it to get feedback here, if that's OK. it's only 40 lines. I know it sucks, but that's why I wanna paste it. :-)
11:52:44 <alexander__b> FreeFull: well I will have COPYING and a licence header like in every other language I've ever used.
11:53:12 <quchen> alexander__b: You have a file to paste here that requires a licence header?
11:53:21 <FreeFull> alexander__b: You could use {- -} comments to make multiline easier on yourself
11:53:32 <alexander__b> quchen: well "requires" is a stretch. but I want to put the app on github later on anyway.
11:53:58 <quchen> alexander__b: No header means "all rights reserved". That should do for a first release :-)
11:54:01 <alexander__b> FreeFull: I'm trying to figure out how that works, but duckduckgo is mysteriously void of results for how to use comments in haskell, heh.
11:54:21 <alexander__b> quchen: I have never released a line of proprietary code in my life. I won't start now. :-P
11:54:25 <dmwit> -- is to // as {- is to /*
11:54:31 <dmwit> except {- does nesting properly
11:54:33 <quchen> alexander__b: (Well, US law might be different though. In any case, before pasting 40 lines in front of any source file you write, read up on your local copyright law.)
11:54:36 <alexander__b> dmwit: cool
11:54:48 <dmwit> ...FSVO properly
11:54:49 <alexander__b> quchen: I know the law. I am an avid GPL-user.
11:54:53 <dmwit> comments and strings are always fun
11:54:55 <ski> klrr_ : what matters is really how things behave, how you can reason about them, not how they're implemented
11:55:04 <FreeFull> > {- {- a -} -} 3
11:55:05 <lambdabot>   3
11:55:26 <FreeFull> > -} 3
11:55:28 <lambdabot>   <hint>:1:2: parse error on input `}'
11:55:29 <alexander__b> dmwit: {- -} was very... concise and nice. I like it.
11:55:57 <dmwit> > " -} "
11:55:58 <quchen> alexander__b: All your belongs to you, no matter what licence you publish it with. That license may choose to grant certain liberties to readers, but that doesn't change that the program is your property and yours alone. If someone re-publishes the GPL-released code under a different license, then that violates your (!) copyright.
11:55:59 <lambdabot>   " -} "
11:56:03 <dmwit> > {- " -} " -}
11:56:04 <lambdabot>   <hint>:1:13:
11:56:04 <lambdabot>      lexical error in string/character literal at end of input
11:56:28 <dmwit> It's a pretty rare gotcha, but important to know.
11:56:29 <klrr_> ski: well, i see a lot of C hackers arguing that Haskell is bad due since it's unnatural, that's maybe what they mean, that haskell might not be real so to speak, it cant be "properly implement in its own terms" or sth
11:56:29 <FreeFull> > {- " -} " -} 3
11:56:30 <lambdabot>   <hint>:1:15:
11:56:30 <lambdabot>      lexical error in string/character literal at end of input
11:56:32 <alexander__b> quchen: I know how copyright and the GPL works.
11:56:40 <dmwit> > {- " -} " -} "
11:56:41 <lambdabot>   " -} "
11:56:48 <FreeFull> dmwit: Seems it doesn't do strings
11:56:53 <dmwit> > {- " -} " -} this part is a string lollerskates"
11:56:54 <lambdabot>   " -} this part is a string lollerskates"
11:57:02 <FreeFull> So not 100% perfect for commenting code out
11:57:06 <dmwit> FreeFull: Correct.
11:57:07 <b2coutts> > " this {- is -} a test"
11:57:08 <lambdabot>   " this {- is -} a test"
11:57:16 <FreeFull> I see -- around more often anyway
11:57:18 <ski> klrr_ : some things will have to be primitive, in any language, e.g. `Int' in Haskell, or `int' in C -- or `IO' in Haskell
11:57:30 <dmwit> It's pretty easy to deal with, though. Just separate your end-comment string literals with string gaps or similar.
11:57:30 <FreeFull> > "This \         \is pretty interesting"
11:57:31 <lambdabot>   "This is pretty interesting"
11:57:46 <ski> > "&\&&"
11:57:47 <lambdabot>   "&&"
11:57:55 <b2coutts> > "\\\\\\\\\\\\\\"
11:57:56 <lambdabot>   "\\\\\\\\\\\\\\"
11:57:57 <merijn> klrr_: C can't be implemented in its own terms either
11:58:08 <alexander__b> anyone have ideas what I should call my program? heh
11:58:09 <roboguy_> klrr_: pretty much anything above assembly has things that can't be "implemented on it's own terms"
11:58:11 <FreeFull> ski: Int doesn't have to be primitive
11:58:16 <b2coutts> > "\#/32\/2\343\4/3\4/33\34\23\4\\42\3\4\\334\2\!"
11:58:17 <lambdabot>   <hint>:1:3:
11:58:17 <lambdabot>      lexical error in string/character literal at character '#'
11:58:23 <FreeFull> You could implement it in terms of naturals + a sign type
11:58:25 <alexander__b> clac is my working title. it's not very clever or good.
11:58:41 <FreeFull> Well, and a way to enforce the upper limit
11:58:43 <FreeFull> And lower limit
11:58:51 <ski> sure
11:59:01 <b2coutts> I find it kind of unfortunate that programming languages are so punctuation-heavy, since it's faster to type regular english characters
11:59:11 <Gracenotes> depends on your keyboard
11:59:19 <alexander__b> b2coutts: not with programmer dvorak
11:59:24 <Gracenotes> it can be especially hard for some European keyboards
11:59:36 <FreeFull> It's alright with the UK keyboard
11:59:36 <dmwit> > "\#"
11:59:37 <lambdabot>   <hint>:1:3:
11:59:37 <lambdabot>      lexical error in string/character literal at character '#'
11:59:41 <ski> b2coutts : lispy languages tend to not use as much punctuation
11:59:44 <dmwit> > "\/"
11:59:45 <lambdabot>   <hint>:1:3:
11:59:45 <lambdabot>      lexical error in string/character literal at character '/'
11:59:46 <FreeFull> > "\#da"
11:59:47 <lambdabot>   <hint>:1:3:
11:59:47 <lambdabot>      lexical error in string/character literal at character '#'
11:59:58 <b2coutts> yeah, if you just put brackets somewhere reasonable lisp would be nice
12:00:01 <FreeFull> > "\3333da"
12:00:03 <lambdabot>   "\3333da"
12:00:05 <b2coutts> s/brackets/parens
12:00:13 <dmwit> > "\3333\&da"
12:00:14 <lambdabot>   "\3333da"
12:00:23 <dmwit> whoop
12:00:26 <Gracenotes> b2coutts: that might be a bit too far
12:00:32 <dmwit> > "\33\&33da" -- just to make sure it's not too many digits
12:00:36 <lambdabot>   mueval-core: Time limit exceeded
12:00:40 <dmwit> > "\33\&33da" -- just to make sure it's not too many digits
12:00:44 <lambdabot>   mueval-core: Time limit exceeded
12:00:45 <alexander__b> https://secure.plaimi.net/~alexander/tmp/clac.hs -- here is my first iteration of error handling. does someone have ideas on how to make this further foolproof?
12:00:46 <FreeFull> Lol
12:00:47 <ski> > map (: []) "\SO\&H\SOH"
12:00:48 <roboguy_> b2coutts: I'm not sure that putting that parens somewhere else would look better
12:00:51 <lambdabot>   mueval-core: Time limit exceeded
12:00:57 <dmwit> *poke*
12:00:59 <Gracenotes> okay, lambdabot has had enough of your character funny business.
12:01:17 <alexander__b> readMaybe will bork, as someone pointed out earlier.
12:01:32 <alexander__b> ./clac "0 2 +" will die. =/
12:01:38 <b2coutts> roboguy_: well, it would make LISP much easier to type if the two most common characters weren't hard to reach keys that require SHIFT
12:01:47 <alexander__b> b2coutts: they're not here
12:01:55 <alexander__b> () are very nice to reach and requires no shift
12:02:06 <b2coutts> at one point I started to learn dvorak
12:02:21 <roboguy_> b2coutts: oh you mean somewhere different on the keyboard
12:02:36 <dmwit> > read "0" :: Double
12:02:37 <lambdabot>   0.0
12:02:49 <b2coutts> and decided that it probably wasn't worth the effort, since I decided that dvorak wasn't better than qwerty by enough to make up for being a non-standard keyboard layout
12:02:59 <b2coutts> maybe I'll reevaluate that decision at some point
12:03:35 <dmwit> alexander__b: oh, just drop the quotes
12:03:40 <dmwit> ./clac 0 2 +
12:03:42 <dmwit> works fine
12:03:44 <alexander__b> dmwit: you mean just ignore readMaybe altogether and use read?
12:03:49 <alexander__b> dmwit: ... try 0 2 *
12:03:52 <klrr_> merijn: roboguy_ ski okey, thanks
12:03:59 <alexander__b> dmwit: in a BASH
12:04:09 * dmwit shrugs
12:04:13 <dmwit> That is very much not read's fault.
12:04:21 <dmwit> By the time it gets to read, you already shot your own foot.
12:04:27 <alexander__b> dmwit: no but that means that readMaybe borks
12:04:33 <dmwit> ...no
12:04:37 <alexander__b> or -- is not sufficient the way it is.
12:04:42 <dmwit> very no
12:04:54 <alexander__b> because I'd need to use ""s, and it borks with "0 2 +"
12:05:05 <dmwit> It is not readMaybe's fault that you sent your program a file name instead of something it knows how to deal with.
12:05:21 <dmwit> ./clac 0 2 '*'
12:05:22 <alexander__b> dmwit: no, but you are missing the point.
12:05:22 <dmwit> works fine
12:05:43 <alexander__b> I want the user to be able to use "2 2 *" and "0 2 +".
12:05:52 <alexander__b> that's fairly standard for cli calculators.
12:06:04 <erisco> left to right RPN? =\
12:06:19 <alexander__b> some, like pcalc, even let's you do 3 3 *.
12:06:23 <quchen> erisco: That's how RPN works.
12:06:26 <dmwit> alexander__b: um
12:06:33 <dmwit> alexander__b: Even with quotes it works fine here.
12:06:41 <quchen> erisco: The other way would be prefix notation. :-)
12:06:54 <alexander__b> dmwit: dmwit uhm here as well suddenly
12:07:03 <alexander__b> dmwit: it didn't but uh now it uh what. OK. problem solved? lol
12:07:37 <erisco> quchen, I see, hm
12:08:06 <alexander__b> well OK that's "solved". but ideas for other things I can do to make this program better? I'm sure there are more advanced haskellisms that would make this more concise and better.
12:08:10 <erisco> quchen, if you are used to reading right to left on such things, then that version looks like prefix ;)
12:08:28 <quchen> heh :-)
12:09:02 <dmwit> alexander__b: I would define something like
12:09:04 <alexander__b> erisco: do you mean Polish Notation? what I pasted is Reverse Polish Notation.
12:09:12 <alexander__b> erisco: Lisp uses Polish Notation.
12:09:27 <dmwit> binOp (+) (x:y:rest) = return ((x+y):rest)
12:09:39 <dmwit> alexander__b: So that you could write e.g. f xs "*" = binOp (*) xs
12:09:41 <quchen> erisco: Haskell helps with that, with its bazillion of left-to-right-inverting symbols. m >>= return . f  --  :-)
12:09:49 <dmwit> alexander__b: and similarly an unOp.
12:09:50 <erisco> alexander__b, I wasn't aware that the R referred to reading direction
12:10:23 <dmwit> alexander__b: ...and then I'd switch the argument order to f so that I could write f "*" = binOp (*)
12:10:26 <dmwit> ;-)
12:10:31 <alexander__b> dmwit: I have to go but I'll copy that into my code as a comment and read it tomorrow. :-P
12:11:47 <ski> alexander__b : why `f (_:xs)   "pi"   = return (pi:xs)' ?
12:11:48 <alexander__b> dmwit: thanks!
12:12:20 <cdk> @where hpaste
12:12:20 <lambdabot> http://lpaste.net/new/haskell
12:12:29 <erisco> oddly I just found a use to use Nothing as a success condition and Just as failure. Never thought of Maybe in that way before
12:13:05 <quchen> erisco: data Result a = Success | Fail a?
12:13:33 <cdk> http://lpaste.net/90815 -- alexander__b
12:13:50 <erisco> quchen, basically yes
12:14:04 <quchen> erisco: Don't use inverted Maybe as a Monad though, otherwise if one thing in your chain succeeds everything that might also fail will be skipped :>
12:14:33 <quchen> erisco: I'm not sure how others see it, but maybe you should use Either a () instead of "inverted Maybe"
12:14:33 <dmwit> cdk: foldM f [] >=> listToMaybe doesn't do *quite* the same thing.
12:14:46 <quchen> erisco: "Nothing" as failure is a fairly common assumption
12:14:52 * ski recalls using `Left' for success and `Right' for failure
12:14:58 <dmwit> cdk: Yours only fails if the stack is empty; his also fails if the stack is too long.
12:15:04 <quchen> (Especially one expects Nothing to represent failure without further information)
12:15:13 <cdk> dmwit: whoops, you're right
12:15:19 <erisco> quchen, I know. I can likely define better names, such as you have suggested, when it comes to implementation
12:16:29 <dmwit> mconcat acts a bit like Maybe-as-failure
12:16:42 <erisco> quchen, but it is also about context, right? when asking "is anything wrong?" then Nothing is obviously a good answer, and Just is the bad answer indicating what is wrong
12:16:53 <dmwit> mconcat :: [First a] -> First a
12:17:06 <Philippa> Either Error () ?
12:18:12 <SrPx> Does anyone know a tool to profile a haskell program, outputing the average execution time, deviation etc?
12:18:47 <hiptobecubic> SrPx, did you search at all?
12:19:13 <SrPx> hiptobecubic: I've been searching for some time already, but mainly for a tool that will profile a generic command
12:19:51 <hiptobecubic> generic command?
12:20:09 <SrPx> so I see, ghc has a tool for it.. well
12:20:22 <SrPx> that's a good start, thanks and sorry
12:20:40 <SrPx> hiptobecubic: yea, I would like to compare a haskell program to a python program, so I'd need something to profile both the same wa
12:20:52 <SrPx> it's for a paper I'm writing
12:22:04 <Gracenotes> SrPx: well, make sure you get both programs looked at by people who are really good in the respective languages
12:22:27 <SrPx> Gracenotes: I've taken the examples from rosetta code (:
12:22:47 <Gracenotes> rosetta code tends to emphasize elegance over efficiency.
12:23:04 <Gracenotes> there might not be strictness annotations most Haskell programmers would write in code that needs to be remotely performant
12:23:43 <SrPx> Gracenotes: yea but the purpose is to compare linguistic code in both languages and show that there is not an obrigatory performance loss for using haskell's abstractions
12:24:07 <SrPx> Gracenotes: so I don't have to prove which is faster, just that one isn't necessarily slower
12:24:09 <Gracenotes> I'm not sure if anyone is seriously arguing that, especially if you look at the proglangs shootout
12:24:28 <Gracenotes> Haskell is in the same 'class' as C/C++, although on the slower end within that class
12:24:40 <Gracenotes> at least for hyper-optimized programs
12:24:49 <hiptobecubic> well both ghc's timer and the timeit module in python work great. If you want to go nuts with it, then use criterion or something
12:24:56 <SrPx> Gracenotes: I hope so... it's not like I'm supposed to show new findings in an introductory cs class ^^
12:25:23 <hiptobecubic> The problem with the shootout is that most of the code in most of the languages is nothing like code in the wild
12:25:27 <Gracenotes> SrPx: if you're not making formal arguments, it is always good to show that code can be both intuitive and performant at the same time
12:25:41 <Gracenotes> as will be the case with Rosetta Code, as I mentioned
12:25:50 <hiptobecubic> it's poked and prodded and squeezed using every trick possible, down to exploiting implementation details
12:26:10 <SrPx> Gracenotes: yes, that's my point... i can show it if you want. But yea, I just need a way to profile them now. I'm using "time" command, but I guess my prof. will complain it's not statistically meaningful or something
12:26:18 <Gracenotes> Python is prototypical imperative psuedocode, and I would say Haskell is prototypical functional psuedocode.
12:26:35 <SrPx> Gracenotes: that's a cool way to look at it
12:27:13 <b2coutts> yeah, haskell is very pseudocode-y
12:27:20 <b2coutts> the first time I saw it I didn't think it was a programming language
12:27:33 <Gracenotes> The difference between an elegantly naively written program and a well-performing program, asymptotically speaking, is not too great in either language. (in Python, maybe throw in a few dicts; in Haskell, perhaps some memoization or a monad)
12:28:08 <Gracenotes> at least for the kinds of programs exhibited in Rosetta Code
12:28:22 <SrPx> Gracenotes: so a question should fit here: why isn't haskell memoizing it's functions by default, if they are deterministic?
12:28:31 <c_wraith> memory
12:28:38 <Gracenotes> SrPx: so, yeah, pick the best-of-the-best timing programs in each language, and hopefully no one will complain :)
12:28:47 <c_wraith> it's usually *way* faster to recompute than to fill memory with billions of values that won't be re-used.
12:29:39 <ion> shachaf: /me sees something familiar in http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
12:29:59 <c_wraith> For the cases where it is faster to store things in memory, it's easy to add
12:30:09 <klrr_> is arrows a class that introduces a new notation of writing computations? is that a correct way to reason about it or define it?
12:30:58 <S_J> any good design documents on happstack and yesod out there?
12:31:48 <erisco> also, there is no general best way to memoise a function
12:32:11 <erisco> though I presume some fairly reasonable assumptions can be made
12:32:11 <quchen> erisco: Have you seen data-memocombinators? :-)
12:32:21 <merijn> Any reactive-banana users that know why there is an "apply :: Behavior t (a -> b) -> Event t a -> Event b" but no version that's "Event t (a -> b) -> Behavior t a -> Behavior t b"?
12:32:47 <erisco> quchen, nope
12:32:54 <klrr_> is arrows a class that introduces a new notation of writing computations? is that a correct way to reason about it or define it?
12:32:58 <banister> does haskell have anything like compose but it goes the other way? i.e: addFiveAndNegate = (+5) | negate
12:33:06 <banister> instead of negate . (+5)
12:33:18 <dmwit> merijn: I wouldn't be surprised if you could lift Events into Behaviors and Behaviors were Applicative or something like that.
12:33:19 <aristid> banister: (>>>)
12:33:27 <banister> aristid: cool, waht's it called?
12:33:33 <conal> merijn: i think you could build either one from the other.
12:33:34 <aristid> banister: (>>>)
12:33:35 <hiptobecubic> & or # is often used for that as well i think
12:33:37 <dmwit> ...but I'm not a reactive-banana user.
12:33:38 <banister> aristid: hehe
12:33:39 <S_J> :t (>>>)
12:33:40 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
12:33:43 <quchen> erisco: I'm not claiming it's the "best" way of memoization, but it's pretty impressive in simplicity, implementation and ease of use.
12:33:50 <banister> aristid: is it possible to feed in values from the left hand side there too?
12:33:52 <Gracenotes> banister: no one really uses compose from left-to-right in idiomatic code.
12:33:53 <S_J> hmm, category? how do I define one?
12:33:53 <roboguy_> man, haskell-mode for emacs is not too stable. I found a (pretty common) sequence of commands that consistently makes my computer crash so hard it restarts
12:34:02 <aristid> S_J: functions already are one
12:34:10 <banister> aristid: i.e: 5 >>> (+5) >>> negate   #=> -10
12:34:10 <quchen> erisco: There is also MemoTrie or something, which uses essentially the same idea, but the code is more complicated.
12:34:19 <sm> roboguy_: nice :(
12:34:20 <merijn> conal: Oh, sure, but it's a bit of scaffolding and I was unsure how much inefficiency that'd introduce, it seemed a curious function to be missing as it seems fairly common to use
12:34:24 <aristid> S_J: if you want your own, define id and (<<<) and make sure the category laws hold.
12:34:33 <dmwit> merijn: Yep, see stepper for the first part, and the second part is true.
12:34:45 <pentace> :t (<<<)
12:34:46 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
12:34:46 <hiptobecubic> roboguy_, emacs should not be making your computer restart no matter how bad it is. are you sure it's set up right?
12:34:57 <roboguy_> hiptobecubic: pretty sure
12:35:02 <aristid> (<<<) is just generalised (.)
12:35:05 <ski> > map ((+5) >>> negate) [-3 .. 3]
12:35:06 <lambdabot>   [-2,-3,-4,-5,-6,-7,-8]
12:35:15 <Gracenotes> banister: is there a particular reason why you'd want this? it makes code harder to read, to be honest.
12:35:18 <erisco> quchen, I was responding to the idea of including memoisation automatically as part of the runtime
12:35:20 <S_J> aristid? where can i find these categoy laws?
12:35:23 <Gracenotes> over the simple composed version, anyway.
12:35:30 <banister> Gracenotes: no, just curious
12:35:33 <klrr_> is arrows a class that introduces a new notation of writing computations? is that a correct way to reason about it or define it?
12:35:44 <conal> merijn: iirc, i used snapshot to build these things. snapshot :: E a -> B b -> E (a,b)
12:35:50 <quchen> erisco: Oh, was in the shower when the rest of the conversation happened, apologies
12:35:56 <Gracenotes> banister: yeah... to abstract over direction and flow of functions, arrows tend to be used. or, they don't tend to be used, but they could be.
12:36:06 <aristid> S_J: ah, sadly the docs are a bit unhelpful in Control.Category
12:36:11 <Gracenotes> and you can always define your own :)
12:36:18 <erisco> quchen, no worries
12:36:21 <roboguy_> hiptobecubic: it seems to happen if I try to close it with C-x C-c when GHCi is running in on of the buffers
12:36:38 <dmwit> S_J: The category laws say (.) is associative and id is its identity. Or something to that effect with different names for (.) and id.
12:36:44 <eacameron> due to laziness: how can I be certain my forever loop in main is actually performing tasks
12:36:44 <aristid> S_J: (<<<) has to be associative, and id <<< x = x and x <<< id = x
12:36:51 <roboguy_> hiptobecubic: I'm not really sure where it would put relevant error logs, so I sort of try to avoid it. but that's a pretty big problem, still
12:36:55 <sm> roboguy_: is emacs using up all memory ? what's your os ?
12:37:01 <roboguy_> OS X
12:37:02 <sm> and emacs version
12:37:10 <roboguy_> emacs 24.3
12:37:30 <ski> S_J : `forall g. id <<< g = g',`forall f. f = f <<< id',`forall f g h. (f <<< g) <<< h = f <<< (g <<< h)'
12:37:33 <S_J> > id []
12:37:35 <lambdabot>   []
12:37:40 <S_J> > id [5]
12:37:42 <lambdabot>   [5]
12:37:46 <ski> @type Control.Category.id
12:37:47 <lambdabot> Category cat => cat a a
12:37:54 <eacameron> I just had a program silently do nothing when I would have expected it...when does the laziness stop?
12:38:13 <dmwit> It's laziness all the way down.
12:38:27 <merijn> conal: I don't know of any combinator like that? Anyway, I think I can implement it by lifting the Event into a behavior using stepper, that just means I have to somehow go from Behaviour to an event, which is probably possible
12:38:58 <eacameron> dmwit: so do I need to tell it at some point: ok, at this point you MUST do something
12:39:11 <quchen> But speaking of memoization: those memo packages essentially build up a long "case x -> ...; y -> ..." list during runtime, don't they? How is lookup handled in those cases, is it O(n), or does GHC optimize it to a binary search? In other words, how fast is lookup in a looooong memo table?
12:39:13 <dmwit> merijn: Behavior to Event seems less likely to be possible in a reasonable way.
12:39:20 <dmwit> perhaps by sampling or something?
12:39:21 <dmwit> dunno
12:39:32 <merijn> dmwit: That was my problem
12:39:40 <FreeFull> eacameron: You could paste the program to http://lpaste.net/ so we find what's wrong with it
12:39:43 <dmwit> eacameron: Your question is too abstract at the moment. Could you give us some concrete code?
12:40:03 <conal> merijn: you can implement snapshot easily with either of two combinators you mentioned.
12:40:11 <dmwit> quchen: Most memo packages build a trie, not a linear lookup.
12:40:14 <roboguy__> haha it just happened again because I was messing with it. frustrating
12:40:19 <Gracenotes> some memo packages also cheat
12:40:21 <dmwit> quchen: or a normal balanced tree, though that's trickier
12:40:30 <eacameron> FreeFull: it's decently large...it listens for Redis entries and then sends an HTTP request once it sees one
12:40:41 <conal> merijn: and yeah, event->behavior would get you further from snapshot, not closer.
12:41:04 <dmwit> merijn: Behaviors are Applicative...
12:41:23 <FreeFull> eacameron: You could use Debug.Trace.trace  to find out where it infinitely loops
12:41:40 <quchen> dmwit: Isn't the trie part for nested data types? I thought if I use the memo packages (say data-memocombinators) that promise a trie approach, the "Trie" part will come in when I apply functions to nested datatypes, such as [[Maybe [a]]]
12:41:42 <sm> roboguy__: similar set up here. My mac will freeze if something has a memory leak and exhausts ram. If yours is resetting.. may flaky hardware ? overheating ?
12:41:58 <eacameron> dmwit: well I'm not exactly sure how to explain it...but it looks like *sometimes* decides not to send the HTTP post
12:42:00 <FreeFull> eacameron: Where trace is basically Haskell's way of printf debugging
12:42:04 <dmwit> quchen: You can build tries for Integer and other base types, too. =)
12:42:13 <klrr_> is arrows a class that introduces a new notation of writing computations? is that a correct way to reason about it or define it?
12:42:16 <dmwit> quchen: e.g. Integer ~ [Bool]
12:42:16 <conal> quchen: or even for Bool
12:42:58 <roboguy__> I doubt it eats through the memory. I checked a little while ago and I had about 1 GB free. also it restarts right away
12:43:00 <dmwit> klrr_: It's an okay description, yes.
12:43:12 <roboguy__> it seems like some kind of kernel panic
12:43:17 <roboguy__> ^ sm
12:43:32 <quchen> dmwit: Right, there's a separate "IntTrie" section in data-memocombinators, which has a very suggestive name. I guess I'll have to go through the Maybe/List implementation again to find out how the memoization happens (and whether/how it's a trie).
12:43:35 <eacameron> I geuss my question is: as a Haskell programmer, do you find yourself having to tell your programs when to start actually doing things or does it normally magically work?
12:43:37 <roboguy__> sm: also, I should point out, I think it only does it when I run emacs in Terminal
12:43:53 <roconnor> eacameron: it always magically works
12:43:55 <roboguy__> I don't think it happens in the graphical emacs
12:44:20 <FreeFull> eacameron: I'd use trace to find out where in the code it stops
12:44:24 <eacameron> My program runs forever ... so I don't know how Haskell decides when to start doing things
12:44:24 <roboguy__> it's a good thing I always save files obsessively...
12:44:33 <sm> roboguy__: interesting, sounds like it's for emacs' maintainers, not haskell-mode's
12:44:38 <merijn> dmwit, conal: Actuall, I think the the thing to do is just "fmap (flip ($))" on my Behavior to go from "Behavior a" too "Behavior (a -> b)" then I can apply that to "Event a" to get "Event b", then I just need to use stepper to get a Behaviour back
12:44:39 <FreeFull> eacameron: Haskell starts doing things as soon as you run the program
12:44:45 <roboguy__> sm: actually, that's probably true
12:44:46 <roconnor> eacameron: when it prints things
12:44:49 <eacameron> FreeFull: I can't reproduce it...I am at the "hunch" point
12:45:19 <roboguy__> sm: for now, I think I'll just avoid using emacs in the terminal all together, haha
12:45:23 <FreeFull> eacameron: You could also try to compile it with profiling and terminate it forcefully when it doesn't terminate by itself
12:45:27 <conal> merijn: oh. you're wanting to end up with a behavior?
12:45:30 <sm> :(
12:45:49 <sm> roboguy__: or try some other emacs versions
12:46:00 <roboguy__> sm: yeah, hmm
12:46:15 <merijn> conal: Yeah, basically I want to change an existing Behavior with a function generated by an Event
12:46:49 <eacameron> roconnor: would "sending an HTTP post qualify as 'printing'"?
12:47:19 <conal> merijn: ah. okay. you could also use stepper on the behavior and then use liftA2 (assuming reactive-banana is anything like i imagine it to be). with a simple equivalence proof, thanks to the simple denotational semantics -- assuming reactive-banana has one.
12:48:12 <dmwit> conal: s/behavior/event/
12:48:33 <conal> dmwit: yes, thanks.
12:48:49 <dmwit> But if merijn didn't like that idea 15 minutes ago, I don't think he'll like it now. =)
12:48:59 <eacameron> how does Haskell decide when a thunk must be evaluated?
12:49:09 <dmwit> eacameron: main gets evaluated.
12:49:26 <merijn> dmwit: Did I miss that 15 mins ago?
12:49:27 <conal> s/evaluated/executed/
12:49:28 <dmwit> Or rather, main gets executed. All evaluation stems from this fact.
12:49:34 <conal> :)
12:49:36 <stepcut> eacameron: when it needs the value to compute the result of another thunk that is being evaluated
12:49:44 <eacameron> dmwit: but that is a shallow execution...
12:49:47 <dmwit> merijn: very first thing I suggested =)
12:50:16 <dmwit> eacameron: I'm not sure I understand that point. What does "shallow" mean?
12:50:17 <conal> thunk forcing *could* happen more often, however, e.g., driven by the garbage collector.
12:50:48 <dmwit> conal: wow, really?
12:50:52 <conal> there's really no haskell answer to operational questions like these. just compiler(-version)-specific answers.
12:51:01 <eacameron> dmwit: well if main was deep exec then Haskell would not be lazy at all
12:51:02 <dmwit> I had no idea thunks could be forced by the garbage collector. That seems... really dangerous.
12:51:05 <S_J> is (.) composition here(Control.Category) too?
12:51:10 <conal> dmwit: yes, and it'd be darn handy. we wouldn't need hacks like foldl'
12:51:17 <dmwit> eacameron: Again, I don't understand the point. What does "deep" mean?
12:51:38 <eacameron> dmwit: main is simply a bunch of thunks
12:51:43 <dmwit> conal: Oh, okay, you mean "could" in some hypothetical implementation as opposed to "could" in some funky situation but with GHC.
12:51:46 <conal> as long as only finite computation is done, we could (partially) force thunks at any time.
12:51:46 <dmwit> got it
12:51:58 <conal> dmwit: yes, exactly. sry for the ambiguity.
12:51:58 <merijn> dmwit: I completely missed what you meant
12:52:30 <conal> i anticipate doing such things in the haskell compiler i'm working on now.
12:52:37 <merijn> conal, dmwit: Thanks for the help, lifting the Event to Behavior and then using Applicative is obviously much simpler, I just completely overlooked it >.<
12:52:45 <conal> merijn: :) !
12:52:54 <merijn> "stepper id myEvt <*> myBehavior" problem solved
12:53:07 <dmwit> hooray!
12:53:21 <conal> gotta love Applicative.
12:53:21 <dmwit> conal: oh, cool
12:53:21 <dmwit> New implementations are always fun. =)
12:53:31 <Gracenotes> lots of traffic on freenode today
12:54:15 <eacameron> dmwit: I'm confused because on one hand main must be executed, but not all of it otherwise there would be no laziness: everything would be demanded immediately. But if not all of it is demanded, then why is ANY of it demanded?
12:54:28 <conal> dmwit: we're aiming at massively parallel, hardware-based execution. with classes non-strict semantics but not a classic lazy implementation.
12:54:56 <acowley> conal: What target platform(s)?
12:55:27 <dmwit> eacameron: Don't confuse evaluation and execution.
12:55:34 <monochrom> output actions (e.g., putStrLn) and the "evaluate" action drive demands. (if you use FFI, it does too)
12:55:36 <dmwit> conal corrected me on that earlier, because it's an important distinction.
12:55:40 <eacameron> dmwit: too late?
12:55:50 <conal> acowley: FPGA and more flexible variants. in particular, Tabula's Spacetime architecture.
12:56:11 <benmachine> eacameron: so the idea is that the run time system evaluates 'main' to work out what to do, and then does it
12:56:29 <dmwit> eacameron: A pretty good mental model is that the runtime evaluates just what it needs of main to know what execution steps it needs to take, and nothing more.
12:56:33 <benmachine> "doing it" being execution
12:56:50 <monochrom> conal! may I suggest the name "crazy evaluation" for that? :)
12:56:50 <dmwit> eacameron: e.g. consider main = putStrLn "foo" >> main
12:57:08 <conal> monochrom: you may. thanks.
12:57:10 <apples> /help save
12:57:28 <mgsloan> or, "completely fair evaluation" :)
12:57:46 <dmwit> eacameron: The execution engine comes along and says, "Okay, current thunk is main. What do I execute next?" and then evaluates "main" a bit, specifically
12:58:04 <mgsloan> Hrmm, I guess that'd be more like removing the bias from the short circuiting of (||).. eh, ohwell
12:58:09 <dmwit> eacameron: It evaluates it to ((>>) (putStrLn "foo") main).
12:58:27 <dmwit> eacameron: Then it says, "aha! (>>) is at the front. I know how to execute (>>): I execute its first argument, then its second."
12:58:44 <dmwit> eacameron: So now it says "Okay, current thunk is  (putStrLn "foo"). What do I execute next?"
12:59:05 <monochrom> I like "crazy" because it rhymes with "lazy" and denotes the frenzy of many workers competing to finish. I suppose "frenzy evaluation" is good too.
12:59:12 <dmwit> eacameron: That's already fully evaluated, so it executes it and puts "foo". Then the state is "Current thunk is main. What do I execute next?".
12:59:45 <dmwit> eacameron: Now "main" is already fully evaluated from the last time, so it doesn't have to do any evaluation at all before it can execute the next bit.
13:00:12 <dmwit> eacameron: So now it's in a tight loop putting "foo" over and over, doing no further evaluation -- only execution.
13:00:22 <eacameron> dmwit: so it's always *trying* to do more and always asking what do actually execute next
13:00:33 <benmachine> dmwit: actually, I think evaluating putStrLn "foo" turns in to putChar 'f' >> putStrLn "oo" or something; possibly not important to your point
13:01:06 <dmwit> benmachine: Yes, that's right. (putStrLn "foo") actually has some evaluation to do before it can be executed.
13:01:11 <eacameron> benmachine: I think a hand waive is fair at that point
13:01:42 <dmwit> eacameron: Well, "always trying to do more" is mostly right, but possibly misleading.
13:01:51 <benmachine> eacameron: sure, but it might also be interesting to talk about how the string has to be deconstructed
13:01:55 <benmachine> and sutff
13:02:02 <dmwit> eacameron: At some point the top-level evaluated action may be "return blah" instead of "(>>) foo bar", and in that case the runtime exits.
13:02:02 <acowley> What's the explanation for the name of the "hc-pkg" subcommand in cabal sandbox?
13:02:44 <dmwit> eacameron: And then there's also some more fun when it comes time to talk about threads. =)
13:02:47 <quchen> dmwit: So in a nutshell, execution is the ASM-like thing a program does, while evaluation is the lambda calculus-y part?
13:03:04 <dmwit> eacameron: If you found this discussion helpful, the more formal version of it in "Tackling the Awkward Squad" might be a good next step for you to read.
13:03:16 <dmwit> quchen: right
13:03:55 <eacameron> dmwit: haha I actually read that already...somehow didn't recall this part
13:03:59 <quchen> dmwit: Great, now I need a way to memorize that so I don't mix up the words evaluation and execution. :-) Thanks for the info!
13:04:37 <dmwit> eacameron: Do you remember the bit where there's a rewrite system for IO?
13:04:47 <dmwit> With evaluation contexts and all that?
13:04:57 <Clint> oh crap
13:05:25 <eacameron> dmwit: no...perhaps a reread is called for ;)
13:05:55 <benmachine> acowley: haskell compiler package manager, perhaps?
13:06:17 <eacameron> dmwit: that has been very helpful. Thanks for fleshing that out
13:06:25 <acowley> benmachine: Sounds plausible
13:06:37 <jfischoff> is anyone familiar with cabal's sandbox feature? specifically what does the hc-pkg
13:06:38 <jfischoff> do?
13:06:45 <acowley> haha
13:06:54 <acowley> jfischoff: It's a local ghc-pkg command
13:06:58 <acowley> afaiu
13:07:07 <jfischoff> ah
13:07:30 <jfischoff> yeah
13:07:48 <acowley> I do wish there was better documentation for everything cabal related. I often find myself piecing things together from --help output, the user guide, and SO
13:08:05 <dcoutts> acowley: I started rewriting the cabal user guide
13:08:11 <dcoutts> it's a lot of work :-(
13:08:24 <acowley> dcoutts: I believe it. It's not a short document.
13:08:49 <lispy> dcoutts: It would be great if the cabal user guide were a wiki.
13:08:55 <lispy> dcoutts: then everyone could contribute
13:08:56 <benmachine> there's a cabal wiki
13:09:08 <jfischoff> is there a way to `cabal get` all of the dependencies of a package?
13:09:12 <dcoutts> lispy: it's in the git repo, people can contribute
13:09:27 <acowley> jfischoff: cabal install --dependencies-only
13:09:32 <dcoutts> jfischoff: yes, cabal fetch
13:09:39 <benmachine> acowley: isn't that --only-dependencies?
13:09:47 <lispy> dcoutts: I noticed yesterday that there are a lot of things not documented about package descriptions. Hackage won't let you put non-absolute paths in extra-lib-dirs, for example
13:09:50 <acowley> benmachine: I always get it backwards, so you're almost certainly right
13:09:58 <dcoutts> jfischoff: fetch command downloads all the sources but doesn't build any
13:10:06 <jfischoff> perfect!
13:10:19 <dcoutts> lispy: patches welcome
13:10:35 <acowley> withTempDirectory in cabal is giving me grief now
13:10:39 <lispy> you said it's on the github wiki?
13:11:13 <acowley> I updated Cabal because cabal-install failed to build due to a change in withTempDirectory. With new Cabal and cabal-install in hand, entropy won't install because of withTempDirectory
13:11:14 <benmachine> lispy: no it's in the source repository
13:11:16 <S_J> so the set of Integers (without 0) and multiplication forms a Monoid since it is assosicative(for all a,b in Int (a*b)*c=a*(b*c)), and for all a, a * 1 = 1 * a = a and finally closure since for all a*b the result is an Int.
13:11:17 <S_J> ?
13:11:38 <benmachine> lispy: Cabal/doc I think
13:11:47 <benmachine> S_J: yes
13:11:50 <dcoutts> lispy: it's markdown, in the cabal repo, not the github wiki
13:11:55 <acowley> Why can't we have 0?
13:12:03 <benmachine> we can
13:12:09 <benmachine> but we can also exclude it if we want
13:12:29 <S_J> but 0 doesnt qualify for the id operation
13:12:36 <benmachine> S_J: yes, it does :)
13:12:43 <benmachine> S_J: 1 * x = x for every x including 0
13:12:44 <S_J> oh wait it does :)
13:13:00 <lispy> dcoutts: is there any reason to not make the cabal user guide into a wiki?
13:13:07 <jfischoff> hmm does fetch work with sandboxes? When I fetch it is saying that I already have the sources locally. I would assume with a fresh sandbox I could pull them down regardless of my user state.
13:13:17 <merijn> gah
13:13:19 <acowley> benmachine: Ah yes, like the Integers ala acowley which are just like the normal Integers, but exclude 73 because that number is lame.
13:13:34 <dcoutts> lispy: no but it does not remove the main effort of doing a big overhaughl
13:13:41 <benmachine> acowley: you have to be a bit careful – if you've got -73 and -1 you need 73 too
13:13:47 <dcoutts> wiki will help for the small fixes
13:13:50 <S_J> but lets see, i for got my linear algebra, is (A*B)*C == A*(B*C)? yes i think so. however A*B*C != A*C*B (necessarily)
13:13:58 <benmachine> S_J: correct
13:14:07 <merijn> Why is doing something as simple as managing focus of a Widget so hard in FRP style :(
13:14:24 <acowley> benmachine: Yes, the foundation of spite upon which I have erected my new math is perhaps a bit unsound.
13:14:35 <monochrom> jfischoff: fetch only cares about your ~/.cabal/packages
13:14:41 <benmachine> acowley: you can throw out primes as long as you also throw out their negatives
13:14:57 <benmachine> acowley: you can throw out non-primes as long as you throw out their nontrivial factors (and negatives)
13:14:59 <conal> merijn: one reason (not the only) could be lack of a clear model of Widgets, including focus.
13:15:02 <S_J> so multiplivation and integers are also a category?
13:15:13 <benmachine> S_J: in a fairly uninteresting way, yes
13:15:14 <Cale> quicksilver: unfortunately there is not a new location for that article, because the disk for the machine I was using as a webserver died.
13:15:16 <conal> S_J: every monoid is
13:15:31 <S_J> is every category also a monoid?
13:15:36 <ski> no
13:15:38 <lispy> merijn: FRP tends to be good at describing things that are a direct consequence of an event
13:15:42 <jfischoff> monochrom: yeah. That's too bad
13:15:45 <S_J> ski: example?
13:15:48 <benmachine> S_J: no, because morphisms with non-matching domains and codomains can't be combined
13:15:54 <Cale> quicksilver: actually, I don't know if it's *quite* dead, but it's dead enough that I can't boot off of it, and I don't have another machine old enough to plug that hard drive into or an adapter :P
13:15:55 <byorgey> S_J: you can think of categories as monoids-with-types
13:15:59 <S_J> benmachine: ok, hand me an interesting category then!?
13:16:01 <lispy> merijn: and less good at describing things were you want to observe the current state and act on it
13:16:09 <benmachine> S_J: um, the category with two objects :P
13:16:14 <benmachine> and only their identities
13:16:14 <ski> S_J : category with two objects and one non-identity morphism between them ?
13:16:15 <byorgey> every monoid is a category with only one "type" (i.e. object)
13:16:34 <lispy> merijn: in the case of focus, you might be able to accumulate the current focus from an event stream
13:16:45 <benmachine> S_J: or, well, if you just want a list of interesting categories, there are quite a few :P
13:17:02 <conal> merijn: have you read the "genuinely functional UIs" paper? it's dated, but does start to look at denotative UI construction. i still think it's a great research direction.
13:17:06 <benmachine> (most are not monoids)
13:17:27 <merijn> conal: Probably, my current design used the Applicative of Behavior to combine "Behavior Widget" into bigger "Behavior Widget", I then fmapped a zipper in there so I'd end with "Behavior (Cursor Widget)", an Event that produced "Cursor -> Cursor" functions and then used the Applicative of Behavior again to apply the Cursor manipulation function
13:17:33 <Ralith> What's the best way to handle data files generated at buildtime with cabal?
13:17:49 <conal> merijn: if we're trying to clearly model things for which we have no clear understanding, we're likely to have difficulty.
13:17:54 <merijn> conal: I don't think so? I think the only relevant thing I read was your TV stuff?
13:18:10 <Cale> There are two nice ways that you can simplify the definition of a category and end up with another familiar mathematical structure. One is to require that the category have exactly one object, in which case, the arrows from that object to itself form a monoid under composition (and every monoid can be turned into a category in this way). The other is to require that there be at most one arrow between any ordered pair o
13:18:10 <Cale> f objects, and this results in the objects being preordered by the relation of having an arrow between them.
13:18:28 <conal> merijn: check it out. it's the first afrp paper. quite a while back. see my pubs page (http://conal.net/papers)
13:19:00 <Cale> A preorder <= on a set S is a relation which is reflexive (i.e. a <= a for every a in S) and transitive (i.e. for every a,b,c in S, if a <= b and b <= c then a <= c)
13:19:06 <dmwit> Ralith: Does cabal need to get involved?
13:19:10 <merijn> lispy: Well, whether an Event should change focus depends on the Behavior that's consuming the events
13:19:21 <byorgey> or you cana require that there be at most zero arrows between any pair of objects, in which case you get a set ;-)
13:19:32 <conal> merijn: btw, it was john hughes who first suggested (to me at least) packaging ftp via Arrow. at ppdp '00.
13:19:49 <Ralith> dmwit: cabal's the thing that manages building files, and installing regular datafiles
13:19:59 <monochrom> be careful there, your category may have too many objects to be a set
13:20:00 <Cale> Every preordered set can then be turned into a category with an arrow x -> y whenever x <= y, and every category with a set of objects and where there's at most one arrow between any pair of objects can be turned into a preordered set.
13:20:07 <dmwit> Ralith: Oh, installation. Right.
13:20:31 <Ralith> dmwit: basically, I want the "data-files" category except without the "included in sdist" part.
13:20:39 <dmwit> right
13:20:53 <statusfa1led> is there a library with functions like factorial, binomial coefficient, etc.?
13:20:53 <Cale> monochrom: I'll steal a line from one of Awodey's lectures and say that they'll be a set in *some* set theory ;)
13:20:54 <merijn> conal: I initially started with an arrow based attempt at writing this code, but I quickly got completely lost in all sorts of implementation details, rather than thinking about what I *meant* to write
13:21:08 <conal> merijn: ack :/
13:21:27 <byorgey> monochrom: well in that case it certainly has too many objects to be a preorder, and maybe too many arrows to be a monoid =P
13:21:34 <monochrom> the category of set theories is too large to be a set :)
13:21:56 <byorgey> you only noticed because I used the word "set".
13:22:36 <lispy> merijn: That sounds like one of the cases frp struggles with.
13:22:57 <monochrom> yeah
13:23:01 <benmachine> there are set theories with a universal set
13:23:24 <benmachine> so you can take your limitation of size and shove it up your jumper
13:23:50 <dmwit> byorgey: You're right, "you can require that there be at most zero arrows between any pair of objects, in which case you get a" sounds much better. =D
13:23:56 <Cale> benmachine: Well, there's the weird NF thing, is that what you mean?
13:23:57 <merijn> conal: The problem is that I have a vision of the code I'd like to write and the operational behaviour I'd like it to have, but I haven't figured out what (if any) model I have for that, I just know I want to able to describe continuous behaviour too, without forcing myself into a tarpit of imperative timers, etc.
13:23:58 <conal> my speculation: if GUIs themselves had an precise & elegant mathy/denotative theory, we'd be in a much better position to program them elegantly & denotatively.
13:24:26 <benmachine> Cale: I don't think that's the only one, but yeah
13:24:32 <Cale> yeah
13:24:45 <benmachine> Cale: I knew some people working on a consistency proof
13:24:51 <benmachine> then I graduated, much to my dismay
13:24:56 <merijn> conal: True
13:25:14 <benmachine> but NFU is already relatively consistent so that's close enough for me
13:25:18 <monochrom> conal: I believe it. at least, I would apply that theory.
13:25:58 <merijn> conal: I like the tangible values inspired approaches, but I'm unhappy with the level of layout control obtainable with the TV approach
13:26:23 <quicksilver> Cale: that is bad news indeed.
13:26:26 <conal> so maybe we're chasing the wrong in of the problem here, in trying to program conventional GUIs in Haskell. with inevitably messy results.
13:27:24 <merijn> conal: Oh, I've already written off the option of writing conventional GUIs. I'm trying to develop a GUI framework that I can map to openGL/terminal, without trying to be compatible with existing guis
13:27:24 <aristid> conal: perhaps conventional GUIs are not the be-all-end-all, but as a benchmark of expressiveness they at least form a non-moving target.
13:28:06 <quicksilver> Cale: however it can be retrieved from http://web.archive.org/web/20070224024824/http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
13:28:06 <merijn> I don't care about writing something works with existing GUI toolkits, as long as I can write something that produces a GUI in some way
13:28:18 <acowley> aristid: I think they also suggest a baseline level of functionality.
13:28:27 <Cale> Oh, wow
13:28:39 <Cale> I didn't realise that it had been indexed by archive.org
13:29:04 <aristid> Cale: did you want it to vanish? :P
13:29:17 <Cale> Well, that means that they expressly disobeyed my robots.txt.
13:29:23 <conal> merijn: i'm glad to hear. you might also work on a semantic model, leading to an elegant API and clearly defined specification for your implementation. not an easy task, but the most clarifying one i know in software design.
13:29:46 <aristid> Cale: why did you have a robots.txt on How To Use Monad Transformers/!
13:29:48 <aristid> ?!
13:29:49 <lambdabot> Maybe you meant: v @ ? .
13:30:37 <quicksilver> they claim to obey robots.txt
13:30:38 <Cale> aristid: I blocked all robots from everything, because my webserver was also my personal machine, and they'd randomly start trying to download everything.
13:30:57 <quicksilver> but the fact that the tutorial is safe is good news imo
13:31:08 <S_J> I dont get how to "implement" my own category though, how do i implemnt the category of integers and multiplication?
13:31:18 <Cale> Perhaps this was just before I got fed up and wrote one :)
13:31:19 <dmwit> Cale: I thought archive used some sources that were not robots.
13:31:23 <S_J> class Category cat where       id x = x;       (.) ?
13:31:32 <Cale> or that, yeah
13:31:39 <dmwit> Cale: e.g. a browser add-on that would download pages as people browsed them.
13:31:46 <benmachine> S_J: well, categories are a thing outside of Haskell, they exist whether or not you implement them
13:31:47 <dmwit> Which I would class as "not disobeying robots.txt".
13:32:08 <Cale> Yeah, that I'd be okay with :)
13:32:37 <aristid> archive.org is the last organization i actually donated money to.
13:32:45 <Cale> benmachine: Of course, the sort of existence is a purely formal one. :)
13:32:59 <benmachine> Cale: most sorts of existence are :P
13:33:15 <quicksilver> dmwit: they claim, however, that the mere presence of a robtos.txt will cause them to retroactively dlete everything
13:33:21 <quicksilver> dmwit: http://archive.org/about/exclude.php
13:33:24 <dmwit> wow
13:33:32 <quicksilver> well not the mere presence
13:33:40 <quicksilver> I mean, one which contains appropriate disallow's in it
13:33:58 <aristid> quicksilver: cale.yi.org no longer servers a robots.txt, so that's not the case either:)
13:34:02 <dmwit> Oh, okay.
13:34:11 <quicksilver> this does seem to allow a certain kind of historical terrorism by new owners of an old domain though
13:34:14 <quicksilver> which I don't like
13:34:18 <Cale> aristid: yeah, but it also doesn't serve anything much from its root
13:34:47 <Cale> (also, I don't think my webserver is running right now)
13:35:12 <aristid> Cale: the robots.txt that used to be, was served from the root though?
13:35:21 <ipuustin> is it just me or does anyone else find it inconvenient that do-blocks dont have a "type" indicating which monad they are executing?
13:35:49 <ipuustin> I understand that it's just sugar and >>= doesn't have that, but still...
13:35:54 <aristid> ipuustin: but they do, type inference works just fine for them, and you can :: them like any expression.
13:36:00 <merijn> conal: One of the main difficulties I seem to run into, is that it's really desirable (from an operational point of view) to be able to generate events from within the FRP network, but this (as far as I can tell) not possible (and not even sensical) with the semantics you propose. reactive-banana provides you some ways to do this, but unfortunately the current implementation is either buggy or its semantics don't work th
13:36:12 <Cale> aristid: yeah
13:36:40 <tgeeky> merijn: your message cut off after "don't work th". please re-submit.
13:36:54 <S_J> " structure-preserving mapping from one mathematical structure to another" - so that math struct has to be from one type to the same time? if it is stucture preserving? a Int->Double function isnt a morphism but Int->Int is?
13:37:16 <tgeeky> S_J: homomorphism?
13:37:18 <benmachine> S_J: okay there are some confusions here
13:37:21 <conal> merijn: from our past chats, by "generate events", i assume you mean something imperative/non-denotative. in which case, i hope you find another way to think about what you're doing.
13:37:26 <merijn> don't work the way I'd need them too
13:37:33 <tgeeky> S_J: retype your statement, you said "from one type to the same time"
13:37:54 <benmachine> S_J: it seems like we're only hearing half a conversation here, maybe you want to restart from the beginning and tell us what you are trying to work out
13:37:55 <Cale> aristid: and it had unlines ["User-agent: *","Disallow: /"] in it
13:38:47 <aristid> merijn: have you enraged conal? :P
13:38:49 <S_J> same type
13:38:49 <Cale> S_J: the notion of structure that you're preserving is encoded by which functions you choose to include
13:38:57 <aristid> ah, no.
13:39:05 <ipuustin> aristid: sure, the result value has a type. Still, reading code, it would be very nice if the syntax was "do Maybe { ... }" or similar...
13:39:18 <ski> S_J : "math struct has to be from one type to the same time" -- the "type of structure" here isn't thinks like `Int' and `Double', but `monoid',`group',`set',`vector space'
13:39:23 <aristid> ipuustin: other people's code?
13:39:32 <Cale> But it could be like Int or Double
13:39:52 <Cale> Arrows in the category of Haskell types preserve the definedness ordering, for example.
13:40:15 <aristid> ipuustin: you could do (do {... }) :: Maybe Int, for example.
13:40:27 <FreeFull> Are Functor instances implementable for GADTs?
13:40:49 <ipuustin> aristid: yeah. I find my own code easier to read ;-P
13:40:53 <merijn> conal: Like I said, my last attempt had a Zipper of Widgets, the focus of the zipper being the "focussed" widget, but you'd want the decision whether a given input event from the keyboard changes focus to be based on the state of the focussed Widget. Alternatively you might want some Widget to grab focus after X amount of time.
13:40:55 <Cale> FreeFull: yes, sometimes
13:40:59 <benmachine> FreeFull: the situation with GADTs is not different from the usual situation
13:41:09 <ski> FreeFull : sometimes, if the GADT is an abstract data type
13:41:13 <benmachine> FreeFull: some things are functors and some aren't; some GADTs belong to each of those two cases
13:41:26 <ipuustin> aristid: but sure, you're right that you can add the type that way.
13:41:40 <ski> (or if you wrap in a `CoYoneda' existential)
13:41:44 <S_J> class Category mul where , how do I go on? Im trying to implement the category of mul over integers in haskell
13:41:59 <aristid> ipuustin: perhaps loading these mysterious modules in ghci can help you explore their meaning
13:42:18 <merijn> conal: Modelling this whole notion in pure FRP seems to be rather complicated, though. Originally I had something like a Behavior specifying which Widget was active, but that still means you have a Behavior that should be updatable from several different places, which is where thing start to break down in my mental model
13:43:11 <benmachine> S_J: why are you trying to do that?
13:43:13 <ipuustin> aristid: that's right, and often it's clear which monad is used. Sometimes, especially with nested do-blocks, I just find it difficult...
13:43:31 <benmachine> S_J: I'm asking so I can work out what exactly you want to do
13:43:34 <aristid> ipuustin: yes, some authors like to overrely on type inference.
13:43:50 <lispy> Something that I couldn't figure out how to do in FRP (and I was sort of surprised) was that I couldn't have event generators within the FRP desription.
13:44:01 <quicksilver> merijn: "Behaviour updated 'from' several places" is backwards
13:44:06 <merijn> lispy: Yes
13:44:14 <lispy> merijn: and I think that could handle your case. Different inputs could be converted into a single event type "update focus"
13:44:15 <merijn> lispy: That's exactly the problem
13:44:26 <quicksilver> the Behaviour is built up by composing the effects of the different places
13:44:40 <acowley> Why isn't "update focus" just a union of all its potential sources?
13:44:49 <merijn> quicksilver: That runs afoul of one thing, though
13:45:14 <Cale> conal: It's barely worth mentioning, but when I was working on the game, I came up with an Applicative structure on our UI Widgets (over top of an arrowy FRP system), which was almost-but-not-quite a monad, because the bind required an additional parameter to serve as an initial value, i.e. a -> Widget a -> (a -> Widget b) -> Widget b. This would cause the Widget a to run, and at the same time, switch between Widgets i
13:45:15 <Cale> n the image of the given function, according to the events of type a which came from the first widget.
13:45:22 <merijn> quicksilver: It means your GUI specification resembles the interrelation of things, which is fine. But it makes it very hard to specify the layout of things
13:45:54 <Cale> conal: Of course, if Widget had produced something more like your Reactive as a result, this would be a proper monad.
13:45:54 <acowley> Does anyone here use or work on git-annex?
13:45:55 <merijn> The fundamental trade-off I keep bumping in is, either I combine things based on Behaviour (which FRP really wants you to do), but then specifying layout becomes a pain.
13:46:07 <merijn> Or specify things by layout, but then interraction becomes a pain
13:46:46 <lispy> acowley: johnw does a lot of git stuff but I don't know if he uses git-annex
13:46:48 <Cale> (A somewhat funny sort of monad though, where all the actions are running simultaneously)
13:46:52 <quicksilver> merijn: shouldn't layout be more-or-less independent of behaviour?
13:46:58 <merijn> quicksilver: Yes
13:47:02 <quicksilver> merijn: View vs Controller?
13:47:21 <acowley> merijn: I know you've been working at this for a while, have you been able to distill down a relatively small program for folks to ponder over?
13:47:36 <merijn> quicksilver: But how do you write that without horribly duplicating all sorts of things or running into the use of identifiers which can't be type checked)
13:47:37 <kylcarte> how should I solve the perpetual haddock warnings from 'ghc-pkg check'?
13:47:44 <johnw> acowley: I use git-annex heavily
13:47:53 <acowley> johnw: Are all the tests expected to pass?
13:47:54 <Cale> also, the monad structure wouldn't quite have agreed with the applicative structure due to the switching
13:48:02 <johnw> acowley: for git-annex?  that I don't know
13:48:19 <Cale> (even if it had been properly a Monad instance)
13:48:26 <merijn> acowley: Having a small program would require some form of intuition of how to write that program
13:48:26 <acowley> johnw: Because they don't, for me. I don't know if I should debug the tests, give up, or pretend I didn't find out the tests fail.
13:48:41 <johnw> post a question on the git-annex forums
13:49:31 <conal> lispy: no "event generators"? there's a whole algebra of them.
13:49:32 <Cale> conal: But I did find it pretty nice to work with -- there were some fiddly bits about creating the right kinds of feedback loops in some cases, but for sufficiently tree-like GUIs, it was quite simple to work with.
13:50:05 <merijn> Cale: I don't suppose any of that code is open for anyone to see?
13:50:10 <quicksilver> merijn: I don't know. I think I need to try to write that program to find out :)
13:50:16 <Cale> merijn: not atm
13:50:28 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:quasiqoutes <-- lol oops
13:50:59 <acowley> merijn: Understood, I just feel like there's a lot of undirected good-will to help here that's getting diffused by the vagueness of words.
13:50:59 <conal> merijn: i wouldn't worry first about modeling guis via frp. instead, understand what guis mean. i.e., model them via math.
13:51:34 <merijn> acowley: If I had non-vague words I know whether this stuff is implementable :p
13:51:46 <mcstar> :T (-<)
13:51:49 <conal> Cale: ah.
13:51:55 <mcstar> :T (-<)
13:52:00 <mcstar> :t (-<)
13:52:01 <lambdabot>     Not in scope: `-<'
13:52:01 <lambdabot>     Perhaps you meant one of these:
13:52:01 <lambdabot>       `-' (imported from Prelude), `<' (imported from Data.Ord),
13:52:14 <aristid> @hoogle -<
13:52:14 <lambdabot> Unknown flag: -<
13:52:19 <aristid> @hoogle (-<)
13:52:20 <lambdabot> keyword -<
13:52:20 <lambdabot> keyword -<<
13:52:24 <merijn> conal: I'm, unfortunately, rather terrible at modeling via math, I tend to end up with really operational models
13:52:31 <merijn> mcstar, aristid: That's Arrow syntax
13:52:35 <aristid> mcstar: it's from proc notation.
13:52:37 <mcstar> is there syntactic extension just for arrows?
13:52:41 <lispy> conal: There are certainly ways to process events and transform them into new events. And there are ways to observe behaviors and produce an event that represents the current value of the behavior. What I wanted was a way to take the current state and have my frp system produce something that feeds back in as a new event.
13:52:45 <merijn> mcstar: Yes
13:52:52 <aristid> merijn: yes, as soon as i saw the "keyword", i remembered.
13:52:59 <byorgey> merijn: it is certainly an acquired skill.
13:53:28 <lispy> conal: so far, yampa's notion of a switch is as close as I have come
13:53:43 <merijn> I don't even want to write GUI libraries, it's just that without a proper GUI I can't show the stuff I do want to implement to other people, making it rather useless >.>
13:53:57 <conal> lispy: not sure what you mean ("current state … new event"). do you have a math/semantic understanding of what you wanted.
13:54:10 <aristid> merijn: command line all the things!
13:54:21 <merijn> aristid: Even my command line needs a UI
13:54:27 <lispy> conal: OTOH, I've only tried two frp libraries reactive-banana (which had terrible performance and was completely unusable for me) and yampa (good performance but arrows that lack an ArrowApply instance can be a pain at times)
13:54:28 <aristid> merijn: but not a GUI
13:54:36 <merijn> aristid: I do, actually
13:54:46 <aristid> merijn: huh?
13:54:57 <acowley> texture-mapped, fragment shaded blinking cursor
13:55:04 <aristid> merijn: does that mean i won't be able to use your command line over ssh?! :P
13:55:06 <S_J> benmachine: because i want to, i want to implement one Catwgory to see how it is done, i think it would help me to spot an opportunity where I can use it later on. I want to understand how it can help me in my programming.
13:55:22 <benmachine> S_J: oh, um, I'd say don't worry about it
13:55:25 <merijn> aristid: why? ncurses type things work over SSH
13:55:36 <aristid> merijn: i don't consider ncurses a GUI
13:55:41 <benmachine> S_J: categories aren't nearly as useful in Haskell as, say, monoids or monads
13:55:45 <lispy> conal: Honestly, I find the denotational emphasis to be really distracting in this discussion.
13:55:46 <merijn> aristid: What would you call it, then?
13:55:51 <aristid> merijn: TUI! :D
13:55:56 <b2coutts> I think the G in GUI implies not text-based
13:56:32 <benmachine> S_J: I'd say get a good solid understanding of the other concepts in Haskell first
13:56:35 <aristid> b2coutts: i suspect that to merijn it implies "visually oriented layout" or something like that. which makes sense, in a way.
13:56:49 <b2coutts> I guess
13:57:07 <b2coutts> really every UI is a visually oriented layout
13:57:14 <benmachine> S_J: the Category typeclass is not that important by comparison to most others
13:57:16 <b2coutts> well, every visual UI
13:57:31 <b2coutts> anything on a screen
13:57:59 <S_J> can you at least tell me how to implement the Categoy Int and (*) ?
13:58:13 * benmachine designs a user interface that operates by a series of modulated sound pulses
13:58:18 <S_J> an example of a monoid in haskell?
13:58:27 <conal> lispy: i'm sorry to hear that. for me, the denotational basis leads to sound & compelling answers to these questions, rather than hacking & hand-waving. and, more importantly, to improving the questions.
13:59:12 <benmachine> S_J: it's unclear to me what you mean by "implement"
13:59:26 <conal> lispy: and it's a useful discussion filter for me. when people want to talk about implementation or API and resist discussing what it means, i know i can use my time better elsewhere.
13:59:52 <merijn> conal: What I (and probably lispy) mean is that inside the definition of a "Behavior a" we want the value of an "Event b" at time t to depend on the value of a at t minus epsilon
14:00:02 <benmachine> S_J: if you want to write programs that use the fact that there is a category with one object whose morphisms are integers and composition is given by multiplication, you... can't really do much interesting with that
14:00:28 <benmachine> S_J: if you want to write programs that use monoids, that's much more hopeful, but not really using the category theory at all
14:00:42 <S_J> so what math struct is this: 2-dimensional images and rotation. 360egree rotation  is the identity operator and all rotations are still in the set of 2-dimensional images!
14:00:44 <cesc> hey, n00b question here...  I am defining a data type "Projectile" as follows: data Projectile = Electron {energy :: Energy} | Photon {energy :: Energy} deriving (Show).  Then I say "p1 = Electron 500".  Is there any way to retrieve the value constructor "Electron", other than defining: ptype (Electron _ _ _) = "Electron" ?   If I say ":t p1" I get Projectile.  Damn! =) Thanks in advance.
14:01:14 <byorgey> S_J: that is a monoid.
14:01:21 <merijn> conal: i.e. the Behavior has itself as an argument/input, or depends on itself, however you want to call it
14:01:24 <geekosaur> cesc: show?
14:01:38 <conal> merijn: for what epsilon?
14:01:39 <benmachine> S_J: notice that a 360 degree rotation is the same as a 0 degree rotation :)
14:01:41 <geekosaur> you can;t get *just* the constructor though
14:01:43 <S_J> So what does it help me? By implementing a type class i get a lot of functions for free? a typeclass is an interface(basically)?
14:01:51 <cesc> geekosaur, but this shows a lot of crap (full declaration), indeed.
14:01:59 <benmachine> S_J: yes
14:02:09 <geekosaur> well, yes. the data constructor is not particularly useful by itself
14:02:30 <S_J> htere is no "a rotate b", it is the rotate operator and one arg
14:03:05 <cesc> geekosaur, I thought it would be cool at some point in the code to query a Projectile and check whether it is an Electron or a Photon. Or maybe I should just have a type constructor for each. But they are both Projectiles! :D
14:03:09 <conal> merijn: i suspect what you want was in the original fran and the semantic model i still use.
14:03:12 <merijn> conal: Actually, maybe not even "t minus epsilon", just the value a at time t would probably suffice (with the operational note that Event b hasn't been accounted for)
14:03:21 <benmachine> S_J: right, but if you have a 30 degree rotation and a 60 degree rotation, then you can combine them to make a 90 degree rotation
14:03:28 <ski> cesc : `data Projectile = Particle {particleType :: ParticleType,energy :: Energy}; data ParticleType = Electron | Photon', mayhaps ?
14:03:37 <benmachine> S_J: by doing one and then the other
14:03:57 <geekosaur> cesc: isElectron (Electron _) = True; isElectron _ = False
14:04:01 <conal> merijn: my semantics was/is designed to make that case meaningful and useful. and my original fran implementation handled it correctly.
14:04:03 <cesc> ski, oh! of course!!  That works just fine.  Thx.
14:04:14 <geekosaur> or that, I gyess
14:04:16 <cesc> geekosaur, also.  Uhu.    Thanks a bunch, guys.
14:04:28 <merijn> conal: hmm, it's been awhile since I read the fran paper, maybe I should take another look at that
14:04:29 <conal> merijn: see the fran and push-pull papers. it's in there.
14:05:33 <geekosaur> you may be thinking in terms of ontrospection, which is somethingt hat some languages do well but Haskell not really intended for (since introspection is usually geared toward referential-integrity-violating things)
14:05:48 <conal> merijn: i did a *lot* of these self- and mutually-recursive definitions in fran. there is a critical "<" (not "<=") in the semantics of switcher to support it.
14:09:57 <merijn> conal: Right, I see how you could accomplish something like that with a 'fix' type of approach combined with switcher
14:10:11 <merijn> Although I find myself frequently having enormous difficulties with thinking like this
14:10:39 <conal> merijn: yes. and probably express fix only implicitly, as we usually do (recursion).
14:11:15 <conal> merijn: it's a sort of discrete counterpart to ODEs, which are also defined recursively.
14:11:39 <S_J> benmachine: but mappend for Integers is (+), how could it then be done with rotate?
14:12:15 <benmachine> S_J: depends how you think of rotations
14:12:31 <S_J> rotate degrees image, but it should if i understood it correctly, rotate typeA typeA not rotate typeA typeB
14:13:05 <benmachine> S_J: I have no idea what you mean by rotate typeA typeA
14:13:21 <S_J> (+) take Int Int or Double Double, not Int Double
14:13:50 <merijn> conal: If you used this approach a lot in fran, is that source online somewhere? The MSR link at http://conal.net/fran/ seems dead
14:14:28 <benmachine> S_J: okay, sure, so?
14:15:04 <conal> merijn: it's been a while since i've looked. poking around now ...
14:15:34 <S_J> lets try another example. instance Monoid Matrix where... mempty = IDENTIYmATRIX... but the indetity matrix can have different sizes so how would that be done if mempty cant take an arg?
14:18:22 <anon123> http://www.haskell.org/haskellwiki/Data_declaration_with_constraint Can anyone explain why this is considered a bad idea?  (This wiki page is written in pseudo-english and I'm not getting it)
14:18:38 <acowley> S_J: Is your concern that you might use the wrong mempty as an argument to mappend?
14:19:01 <merijn> anon123: Because even if you add it to your datatype, all functions working on your datatype still need the constraint too, so it doesn't get you anything
14:19:30 <Gracenotes> more details: http://ghc.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
14:19:47 <merijn> anon123: "data Show a => Foo a = Foo a" "foo :: Foo a -> String; foo (Foo x) = show x" <- this is a type error
14:20:11 <merijn> It'll only work if you write "foo :: Show a => Foo a -> String"
14:21:26 <anon123> merjin: thanks, that makes perfect sense.  ...Care to add it to the wiki?
14:22:20 <conal> merijn: see conal.net/fran/Fran1.16.zip . it's the implementation described in http://conal.net/papers/padl99/ . very old code. don't expect it to compile. the file timestamps range from 1996 to 2002. i don't think i would have touched it much after 1999.
14:22:22 <Gracenotes> if you parameterize over all a, you still need to have a runtime way of accessing the typeclass functions for a. It becomes an albatross around the neck of the annotated type.
14:23:04 <S_J> @src (***)
14:23:04 <lambdabot> f *** g = first f >>> second g
14:23:17 <S_J> @src (&&&)
14:23:18 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:23:21 <lcfrs> Does anyone have experience using data-dir in cabal?
14:23:29 <merijn> Clearly there is only one way to make things make more sense...get closer to the Ballmer peak
14:24:17 <S_J> which function transforms liek this: f (x,y) = f x y ?
14:24:20 <lcfrs> I'm using ekg and read that I need to use data-dir (https://github.com/tibbe/ekg/pull/13) if I want to make the assets available to the binary.
14:24:33 <S_J> > (+) uncurry (3,4)
14:24:34 <lambdabot>   Couldn't match expected type `(a0 -> b0 -> c0) -> (a0, b0) -> c0'
14:24:34 <lambdabot>          ...
14:24:42 <S_J> > uncurry (+) (3,4)
14:24:44 <lambdabot>   7
14:25:02 <byorgey> S_J: matrices do not form a monoid, because you can't take any two matrices and multiply them.
14:25:21 <byorgey> S_J: if you take, say, the set of all NxN matrices for some particular N, those form a monoid
14:25:56 <byorgey> S_J: however, the set of all matrices do form a category!
14:26:19 <byorgey> the objects are natural numbers, arrows from M to N  are  MxN matrices
14:26:26 <byorgey> composition is multiplication.
14:26:54 <jfischoff> I assumed if I add-source with a cabal sandbox it would compile the sources if I projected needed that dependency, but I am wrong. What exactly does add-source do?
14:28:24 <rul> Hello. I'm a bit lost with monads. I would like to convert a list of IO to a IO list, something like this: [IO String] -> IO [String]... can anyone give me a clue? Thanks!
14:28:34 <companion_cube> :t sequence
14:28:35 <lambdabot> Monad m => [m a] -> m [a]
14:28:35 <merijn> rul: sequence
14:28:56 <rul> ohh, that's what I was looking for... thanks!
14:29:12 <jfischoff> rul: are you familar with hoogle and hayoo?
14:29:30 <jfischoff> @hoogle [IO String] -> IO [String]
14:29:30 <lambdabot> No results found
14:29:33 <jfischoff> heh
14:29:43 <Gracenotes> @src sequence
14:29:43 <lambdabot> sequence []     = return []
14:29:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:29:43 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:30:34 <S_J> byrogey: matrices and (+)  is a monoid if the matrice shave the same shape
14:30:49 <koala_man> @hoogle [IO Int] -> IO [Int]
14:30:50 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:30:50 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:30:50 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
14:30:59 <byorgey> S_J: yes, that's true too
14:31:02 <koala_man> freaky
14:32:21 <roboguy__> jfischoff, koala_man: I have a feeling that has to do with String being a type synonym for a [Char]
14:32:59 <S_J> http://lpaste.net/90817 <- help please!
14:33:11 <S_J> why is Monoid in Data and Category in Control?
14:33:15 <jfischoff> roboguy_: maybe
14:33:57 <roboguy__> @hoogle [IO [Int]] -> IO [[Int]]
14:33:57 <lambdabot> No results found
14:35:01 <resnik_> @src mconcat
14:35:01 <lambdabot> Source not found. Do you think like you type?
14:35:36 <dcoutts_> jfischoff: I think you may have to build it at least once
14:35:40 <johnw> :t mconcat
14:35:42 <lambdabot> Monoid a => [a] -> a
14:35:52 <S_J> solved
14:35:54 <anon123> GraceNotes: I'm still trying to parse your statement.  Currently, you must supply the constraints in all functions that take the constrained data type.  Your link says "the dictionary is not stored in the constructor, but simply discarded."  So why is the solution to use GADTs (or other extensions) rather than simply store the dictionary in the data type?
14:35:59 <johnw> mconcat = foldr (<>) mempty
14:36:51 <resnik_> ty
14:37:24 <jfischoff> dcoutts_: yeah I just figured out how it works :p. And its working!
14:37:37 <Hugh_> hi - I am working through some JSON examples and came across this ...
14:37:38 <ParahSailin> "Couldn't match type `s' with `s1' -- `s' is a rigid type variable bound by a type expected by the context: ST s (..); `s1' is a rigid type variable bound by the type signature for derp :: ST s ..."
14:37:41 <Hugh_> {-# LANGUAGE OverloadedStrings #-}
14:38:00 <Hugh_> ... could someone enlighten me please? never seen this before in any literature
14:38:07 <ParahSailin> is there any way around this other than commenting out the type signature?
14:38:18 <Gracenotes> anon123: if you have a datatype D a, it's conceivable you might have a function a -> D a, or D a -> a.
14:38:19 <shachaf> Does the GHC manual count as literature?
14:38:22 <Cale> ParahSailin: Maybe ScopedTypeVariables?
14:38:25 <shachaf> ParahSailin" Around what?
14:38:31 <shachaf> s/"/:/
14:38:41 <Hugh_> not sure what that is shachaf
14:38:48 <ParahSailin> "Expected type: STRef s1 Thing; Actual type: STRef s Thing"
14:38:58 <Gracenotes> anon123: you will need to have a typeclass 'dictionary' from somewhere, so to do it in a uniform way, you'd have to have 'T a =>'
14:39:01 <Cale> ParahSailin: It's hard to be certain of what the problem is, but if the issue only happens when you have the type signature, and your code works otherwise, then likely ScopedTypeVariables will help.
14:39:18 <S_J> instance Monoid Matrix where so that cant be qualified like M.Monoid apparently?
14:39:32 <Cale> ParahSailin: So that you can use a forall to bind the s type in the function signature, and then use the same s type in some local signature.
14:39:58 <shachaf> ParahSailin: That error means you have mismatching types in youor code, so don't mismatch them, I guess? It's hard to say without making a random guess, without seeing your code.
14:40:22 <shachaf> (You should hpaste your code.)
14:40:26 <Cale> ParahSailin: But the issue might actually be a real issue with what you're trying to do, it's really hard to say without looking at your code as shachaf says.
14:40:30 <ParahSailin> shachaf: if i delete the explicit type signature, the error is gone
14:40:50 <Gracenotes> anon123: strictly speaking you don't need a 'T a =>' for either of those two functions if you store the dictionary with the datatype, but weird inconsistencies are introduced. In the first case, it's actually required; in the second case, you can't use it polymorphically with any T (it has to be specialized)
14:40:53 <Cale> aha, in that case, you almost certainly want ScopedTypeVariables like I've been saying
14:41:00 <shachaf> ParahSailin: The issue is almost certainly what Cale says, but I'm trying to encourage you to hpaste your code when you ask a question like this.
14:41:09 <shachaf> Hugh_: What what is?
14:41:16 <ParahSailin> damn wheres hpaste.org
14:41:22 <shachaf> Hugh_: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ ?
14:41:24 <shachaf> ParahSailin: See topic.
14:41:28 <Hugh_> I don't understand what {-# LANGUAGE OverloadedStrings #-} is
14:41:31 <Cale> apparently we're using http://lpaste.net/new/haskell for now
14:41:44 <geekosaur> until he decides to change it again...
14:41:46 <Hugh_> ahh, thanks ok.
14:41:47 <benmachine> Cale: possibly for good
14:42:14 <benmachine> Cale: chrisdone has had faff trying to get use of domains he doesn't control, and reasoned that the paste wasn't just used by haskell these days
14:42:22 <Gracenotes> anon123: anyway, the proper way to store a dictionary with a datatype is to use existential quantification, which is generally sound but is much more restrictive to ensure this.
14:42:36 <Cale> Hugh_: It's an extension which allows you to define a translation from String to other types in order to allow string literals to be polymorphic.
14:43:00 * Gracenotes just rambling about typeclass dictionaries, vaguely correct hopefully
14:43:38 <Hugh_> thanks Cale - is it part of the official Haskell or is it something 'hacky' not recommended
14:43:54 <Cale> Hugh_: somewhere in between
14:43:55 <byorgey> it is neither.
14:44:24 <anon123> GraceNotes: that sounds like a good enough reason to me.  However, my understanding was that existential types are somewhat 'dangerous' and to be avoided.  Is there a reason existential types are the preferred workaround (rather than GADTs)?
14:44:25 <Cale> Hugh_: It's an easy extension to implement, and really, GHC is the main implementation anyone has to worry about for now.
14:44:49 <byorgey> existential types are not dangerous.
14:45:07 <Cale> anon123: They're not dangerous at all, but it's easy to construct a design which uses them and doesn't need to.
14:45:12 <byorgey> it's just that people tend to reach for them more often than they should (especiall those coming from an OOP background)
14:45:13 <Gracenotes> they are a workaround. GADTs tend to be more elegant than putting foralls everywhere.
14:45:19 <Hugh_> so is it a bit like casting a char representation of "100" to an Int 100 ?
14:45:22 <Gracenotes> emphasis on 'a', rather than 'preferred' :)
14:45:26 <merijn> anon123: They're not dangerous, they're just a common antipattern for ex-OO people
14:45:33 <Cale> Regardless of whether you're using GADT syntax for them or not.
14:45:34 <byorgey> let's not confuse "existential types" with "that notation using forall".
14:45:42 <byorgey> GADTs can have existentials too.
14:45:47 <merijn> anon123: See: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:46:16 <merijn> anon123: There are valid usecases that can't be implemented otherwise, though
14:46:17 <byorgey> In fact GADTs = ADTs + type equality constraints + existential quantification.
14:46:22 <S_J> should mconcat be autoderivable from mempty and mappend or sometimes you have to implement it rourself?
14:46:33 <byorgey> S_J: it is always autoderivable.
14:46:39 <Gracenotes> I did use the phrase 'existential quantification', but yes, GADTs unify things
14:46:48 <byorgey> S_J: in fact, it has a default implementation in terms of mempty and mappend.
14:46:53 <merijn> byorgey: The rhs doesn't seem sufficient to control the return type of constructors
14:46:54 <Cale> Existential types allow you to have datatypes with values in them of a type which is to be forgotten -- possibly apart from knowing that there are certain operations on them, like that the type must be an instance of a given typeclass, or that there are certain functions stored alongside them which act on them.
14:47:12 <Gracenotes> anon123: Anyway, the usual solution to a parametric type that often accompanies a typeclass is just to add typeclass annotations on all of the functions that use the type and require the typeclass
14:47:15 <byorgey> S_J: it's only there in case you can give a more efficient implementation.  But you are never required to.
14:47:17 <Cale> However, you can *usually* just store the results of the operations in place of the values themselves.
14:47:21 <byorgey> merijn: the rhs of what?
14:47:29 <Cale> which won't require forgetting the type of anything
14:47:35 <Gracenotes> anon123: Maybe not the most elegant, but so much clearer to the client of that function
14:47:44 <Gracenotes> In 99% of cases
14:47:58 <merijn> byorgey: of the "GADTS = ADTS +..." equation
14:48:07 <Cale> For example, if the only thing you knew about a piece of data was that it was of some type that was an instance of Show, then all you can do with it pretty much is to apply show to it to obtain a String
14:48:09 <shachaf> Cale: That depends on when you "usually" feel like using existential types. :-)
14:48:15 <Cale> but then, why didn't you do that initially?
14:48:28 <byorgey> merijn: oh.  controlling the return type of constructors is precisely what type equality constraints gets youl
14:48:50 <shachaf> Cale: Also I'm kind of annoyed at how an existential lets you do vtable-style sharing but a record of values does not.
14:48:54 <merijn> byorgey: How so?
14:49:01 <byorgey> merijn: for example   data Foo a where  Bar :: Foo Int   is really   data Foo a where  Bar :: (a ~ Int) => Foo a
14:49:16 <merijn> byorgey: oh, right
14:50:33 <shachaf> Cale: E.g. if you have [exists a. (a, (a -> Char, a -> Bool, a -> String, ...))], you can share the "dictionary" among all the tuples.
14:50:41 <lispy> conal: I'm having trouble putting it into words, but the reason I call it distracting is that it seems to somehow take us out of the discussion about what people want to express in FRP and into a discussion about other things.
14:50:45 <shachaf> And add "methods" for free.
14:51:05 <lispy> conal: I agree that we need to find clear ways to express ourselves and to clarify what we want to do.
14:51:09 <shachaf> Cale: Whereas if you have  [(Char, Bool, String, ...)], you're going to be using space linear in the number of "methods".
14:51:11 <wole> @t chr
14:51:12 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:51:20 <lispy> conal: But the emphasis on denotations isn't it for me.
14:51:29 <Gracenotes> @tic-tac-toe
14:51:29 <lambdabot> how about a nice game of chess?
14:51:30 <S_J> so if mconcat gives you a different result than your own implementation you have done somethign wrong?
14:51:37 <wole> @t: chr
14:51:38 <lambdabot> Maybe you meant: wn v thx rc pl id do bf @ ? .
14:51:38 <lispy> conal: perhaps because I'm not as well versed in semantics as you are.
14:51:40 <ski> @type chr
14:51:41 <lambdabot> Int -> Char
14:51:47 <byorgey> S_J: correct.
14:52:14 <wole> :t chr
14:52:15 <lambdabot> Int -> Char
14:52:52 <lispy> conal: I doubt anyone here wants the discussion to be about hacks :)
14:53:14 <S_J> http://lpaste.net/90818 <- need helpsy
14:53:38 <S_J> actually mempty is wrong
14:53:52 <S_J> i gues mconcat is a fold with mempty as starting value?
14:53:59 <S_J> @src mempty
14:53:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:54:08 <S_J> @src mconcat
14:54:08 <lambdabot> Source not found. That's something I cannot allow to happen.
14:54:14 <S_J> @src Data.Monoid.mconcat
14:54:15 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:54:19 <monochrom> hrm! no Haskell Weekly News yesterday!
14:54:26 <benmachine> S_J: yes
14:54:31 <benmachine> S_J: mconcat = foldr mappend mempty
14:54:32 <S_J> ah yes, foldr mappend mempty
14:56:27 <S_J> so mempty cant take args right?
14:56:43 <Gracenotes> matrics form a monoid over multiplication
14:56:48 <S_J> you cant give set sizes to a Data either
14:57:00 <Gracenotes> (well, fixed-sized ones)
14:57:08 <S_J> Gracenotes: yes and the same for addition
14:57:15 <Gracenotes> yep
14:57:25 <S_J> Gracenotes: square ones for mult only
14:57:38 <Gracenotes> S_J: but the identity matrix is mempty for multiplication
14:57:42 <S_J> but i cant implement it in haskell (i think)
14:57:47 <conal> lispy: thanks. i don't know whether there's a communication disconnect or really different interests here. when i read your words "discussion about what people want to express", i immediately want to know more clearly what it is that they want to express. and the clearest and most revealing way i know to investigate is via denotations. not of FRP, but of their own intention.
14:57:47 <S_J> Gracenotes: yes
14:57:52 <S_J> but mempty doesnt take args
14:57:58 <Gracenotes> okay... yeah, you know this :)
14:58:22 <Gracenotes> well, plenty of linear algebra libs have different types for different sizes. works for stuff like graphics at least.
14:59:07 <jfischoff> for cabal sandboxing is there a way I can create a cabal config that is different from my user config? Specifically I want prevent the sandboxed cabal from looking to hackage for packages at all.
14:59:11 <S_J> so an infiite amount of matrix types? works if you only have a limited amiunt i guess
14:59:14 <conal> lispy: i.e., if they can express their intention clearly, it's math, i.e., a denotation. it's really my effort to understand what they're asking. probably much clearer than they understand it themselves.
15:00:33 <statusfailed> www.foldl.com / www.foldr.com <-- when did these happen? :D
15:02:06 <Gracenotes> S_J: but you see why [[]] as mempty is a problem in either case, yeah
15:02:16 <Gracenotes> when using zipWith
15:02:59 <S_J> yes i fixed i9t with a set size for mempty [[1,0,0]...]
15:04:12 <anshul> Any help on the following issue appreciated: (RedHat5.5, ghc7.6.3, network-2.4.1.2) I am able to use the `network` package when compiled into an executable, but when I load it in ghci I get the following error: "Loading package network-2.4.1.2 ... linking ... ghc: /lib/network-2.4.1.2/ghc-7.6.3/HSnetwork-2.4.1.2.o: unknown symbol `ghc_wrapper_d2dh_fcntl"
15:04:18 <Gracenotes> singly linked lists might have some limitations with matrices, too, but those aren't too worth worrying about
15:04:34 <conal> lispy: s/clearer/more clearly/
15:04:55 <anshul> hello conal
15:05:04 <conal> anshul: hey! nice to see you here. :)
15:05:29 <conal> anshul & i work together at Tabula.
15:08:21 <S_J> so (+0) is a homomorphism over the Monoid (Integers, *) ? since (+0) 1 = 1 and (+0) (x mappend y) == ((+0) x) * ((+0)y) ? a very unintersting one and maybe im cheating adding with 0?
15:08:43 <osa1> I wish there is an easy way to parse left-recursive expression grammars with parsec
15:10:02 <S_J> f mempty          = mempty // length []         = 0// so beween one mempty and another type mempty, not the same mempty...?
15:10:18 <ParahSailin> @ty liftM repeat
15:10:19 <lambdabot> Monad m => m a1 -> m [a1]
15:10:36 <ParahSailin> seems like that should be repeatM in the std lib
15:11:28 <ParahSailin> or is that not defined because it might not be obvious whether repeatM would be a -> m [a] vs m a -> m [a]
15:14:54 <roconnor> ParahSailin: how sould a -> m [a] be reasonable?
15:14:59 <roconnor> *would
15:15:33 <ParahSailin> roconnor: i agree, that wouldnt make much sense
15:15:34 <roconnor> anyhow, I *think* repeatM isn't there because some unimaginative people think it isn't very useful.
15:16:03 <roconnor> there is however, forever
15:16:05 <roconnor> :t forever
15:16:06 <lambdabot> Monad m => m a -> m b
15:16:26 <roconnor> which is close to repeatM_
15:17:04 <roconnor> arguably is repeatM_
15:18:45 <merijn> roconnor: isn't repeatM just "sequence . repeat"?
15:19:06 <merijn> Although, I guess you can never use the result list :p
15:19:12 <roconnor> @src mapM
15:19:13 <lambdabot> mapM f as = sequence (map f as)
15:19:27 <roconnor> merijn: that is not true
15:19:51 <merijn> roconnor: What is not true?
15:19:51 <k00mi> merijn: sure you can for monads with lazy (>>=)
15:19:53 <roconnor> > runIdentity (sequence . repeat $ 5)
15:19:54 <lambdabot>   No instance for (GHC.Show.Show a0)
15:19:54 <lambdabot>    arising from a use of `M590219606.sho...
15:20:08 <roconnor> > runIdentity (sequence . repeat $ return 5)
15:20:10 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
15:20:25 <merijn> k00mi: Right
15:20:36 <merijn> roconnor: That doesn't hold for many more interesting monads, though
15:21:09 <roconnor> > evalWriter (sequence . repeat $ return 5)
15:21:10 <lambdabot>   Not in scope: `evalWriter'
15:21:10 <lambdabot>  Perhaps you meant one of these:
15:21:10 <lambdabot>    `execWriter'...
15:21:19 <roconnor> @type execWriter
15:21:20 <lambdabot> Writer w a -> w
15:21:41 <roconnor> > runWriter (sequence . repeat $ return 5)
15:21:43 <lambdabot>   ([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
15:22:11 <roconnor> > runReader (sequence . repeat $ return 5) 17
15:22:12 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
15:22:24 <roconnor> had to find a monad it doesn't work for. :D
15:22:28 <roconnor> *hard
15:22:36 <k00mi> well, IO
15:22:38 <shachaf> > T.sequenceA (repeat ('a',5))
15:22:39 <lambdabot>   Could not deduce (Data.Monoid.Monoid GHC.Types.Char)
15:22:39 <lambdabot>    arising from a use ...
15:22:48 <shachaf> Er.
15:22:49 <shachaf> > T.sequenceA (repeat ("a",5))
15:22:51 <lambdabot>   *Exception: stack overflow
15:22:55 <shachaf> Hmph.
15:24:28 <roconnor> > runWriter (sequence . repeat $ tell "a" >> return 5)
15:24:29 <lambdabot>   ([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
15:24:35 <roconnor> > execWriter (sequence . repeat $ tell "a" >> return 5)
15:24:37 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
15:24:53 <FreeFull> It indeed doesn't work with IO
15:24:58 <FreeFull> Doesn't return anything
15:25:50 <c_wraith> IO isn't lazy
15:26:00 <FreeFull> It's only fake-lazy
15:26:05 <roconnor> merijn: anyhow mapM is "just" (sequence .) . map ... I suppose that is more complex than sequence . repeat
15:26:23 <anon123> merijn: I just read your link.  I can see how that is an anti-pattern, but I don't see how it's related to existential types.  (The quantifier 'exists' does not appear anywhere in the code.)
15:26:37 <roconnor> my free monad model of IO also says that it won't return anything.
15:26:49 <merijn> anon123: Because haskell has no exists keyword
15:27:24 <roconnor> sorry, I was joking when I said it was hard to find a monad it doesn't work for.
15:27:56 <merijn> anon123: This line has an existential type in the post: "data AnyWidget = forall w. Widget w => AnyWidget w"
15:28:09 <anon123> merijn: I could've sworn I've seen it used elsewhere... hmm
15:28:28 <tac> Is this that old post on Luqui's blog?
15:29:00 <merijn> tac: Yes
15:29:08 <S_J> instance Monad (Perhaps x) where trying to implement Maybe. I know my functions are correct but how do I writ the instance part? data Perhaps x = Nada | Only x deriving (Eq, Ord, Show)
15:29:48 <anon123> merijn: So AnyWidget is existential?
15:29:52 <roconnor> S_J: you need to define return and >>=
15:29:54 <roboguy_> wouldn't the name "forall" make more sense for universal quantification? I always wondered about that
15:29:54 <tac> I read that a while ago and wasn't convinced by it.
15:30:04 <merijn> S_J: You just write "instance Monad Perhaps where return x = {- something -}; m >>=f = {- something -}"
15:30:06 <merijn> anon123: Yes
15:30:19 <S_J> So in OO, you could have an interface Monoid and you implement 2 operations. simple!
15:30:20 <merijn> anon123: It hides the presence of the w
15:30:29 <tac> Perhaps it makes sense when writing Haskell, but if haskell had better support for existential types, I'm not convinced the issue is so clear-cut
15:30:30 <ski> anon123 : "existential" is a concept. this concept can be encoded in Haskell using an "existential data type" -- one could also imagine an extension of Haskell which allowed direct uses of an `exists' keyword (which could be useful even in the presence of the former)
15:30:32 <anon123> Oh, I thought 'forall' meant universal quantification
15:30:39 <roconnor> S_J: note that it is "instance Monad Perhaps"  not "instance Monad (Perhaps x)"
15:30:53 <merijn> anon123: You could read it as: "AnyWidget (exists w . Widget w => w)"
15:30:53 <geekosaur> doesn't uhc have exists?
15:31:14 <shachaf> merijn: No, "exists" and "=>" don't mix.
15:31:20 <merijn> shachaf: Yeah, yeah
15:31:26 <ski> anon123 : `forall' does mean "universal quantification"
15:31:26 <merijn> shachaf: Tell that to someone who cares
15:31:30 <shachaf> You want exists w. Widget w *> w, or something.
15:31:42 <tac> merijn: Rude!
15:31:43 <shachaf> geekosaur: Yes, though not with type classes (last time I checked).
15:32:12 <merijn> That wasn't meant as rude as it reads >.>
15:32:30 <merijn> But I don't care for pedantism in my burrito analogies!
15:32:33 <ski> anon123 : but `forall a. (Foo a -> Bar)' is essentially (logically, if you like) the same as `(exists a. Foo a) -> Bar', which should help make plausible that one can use the `forall' keyword to express the concept of existential quantification
15:33:09 <shachaf> merijn: But it's as if you wrote a tuple with ->...
15:33:34 <shachaf> hi ski
15:33:39 <shachaf> long time no ski etc.
15:34:09 <merijn> What's wrong with the interpretation "there exists a w, where w is an instance of Widget and this is a value of type w"
15:35:09 <anon123> ski: I don't see how that follows
15:35:49 <merijn> anon123: if something works for *all* a's, then by definition it must also work for *some* a's, no?
15:35:59 <anon123> right
15:36:09 <Cale> Uh, no, that's not why they're equivalent
15:36:19 <ski> anon123 : more specifically, if you say `data T = forall a. MkT (a,a -> a,a -> Bool)', then this means that `MkT' will have type `a -> (a -> a) -> (a -> Bool) -> T' for every type `a', iow
15:36:20 <merijn> Cale: I'm not saying that
15:36:23 <ski>   MkT :: forall a. (a,a -> a,a -> Bool) -> T
15:36:44 <Cale> They're equivalent for essentially the same reason that  not (forall x. P(x)) is logically equivalent to exists x. not P(x)
15:37:34 <tac> merijn: I see your burrito and raise you a "they're adjoint, so they should actually all be exactly my way"
15:37:42 <Cale> or that not (exists x. P(x)) is equivalent to forall x. not P(x)
15:37:55 <ski> for any type `a', you can package a value of type `a', a function over that type, and a predicate over that type together, getting a value of type `T'
15:38:31 <ski> and because `a' doesn't appear in the return type `T', this means that if you're given a `T', you can't in general know what the type `a' is
15:38:35 <roconnor> or that (exists . P(x)) -> Q is equivalent to forall x. (P(x) -> Q) which is what ski said
15:38:54 <companion_cube> err
15:38:56 <shachaf> merijn: Well, "C => T" has a particular meaning. The person using it has to provide an instance.
15:38:58 <tac> The nice thing about existentials is that they don't bleed variables into your scope. AnyWidget does not create a new type variable.
15:39:04 <ski> the only thing you know is that it's the same `a' in the four places it occurs in `(a,a -> a,a -> Bool)' -- but that's only for *this* value of type `T'
15:39:18 <ski> for another `T' value, the "hidden" `a' could be completely different
15:39:25 <shachaf> merijn: In this case the person using it doesn't know the type, so they can't provide an instance. The person *producing* it has to provide the instance.
15:39:57 <ski> anon123 : anyway, `MkT :: forall a. (a,a -> a,a -> Bool) -> T' really means `MkT :: forall a. ((a,a -> a,a -> Bool) -> T)' (desugaring brackets), and this is logically the same as
15:39:59 <anon123> ski: this is starting to make sense
15:40:00 <ski>   MkT :: (exists a. (a,a -> a,a -> Bool)) -> T
15:40:21 <ski> (because "`forall a. (Foo a -> Bar)' is essentially (logically, if you like) the same as `(exists a. Foo a) -> Bar'")
15:41:08 <ski> so, another way to think about `MkT' is that it only requires there to *exist* some type `a' such that you have a value of that type, a function over it, and a predicate over it, for you to be able to package them together to a `T' value
15:41:57 <ski> and this also explains why when unpacking a `T' value, you only get to know that there is *some* type `a' (the same in all the three components), but you don't (in general) know *which* type `a' this is
15:42:05 <S_J> so could input range safety be added to haskell somehow in the type?
15:42:16 <S_J> http://lpaste.net/90819 <- Monoids in Python
15:42:20 <ski> anon123 : does this help ?
15:42:29 <anon123> ski: yes, this is good. thank you
15:43:16 <ski> anon123 : we can't (currently at least) write `exists a. Foo a' in Haskell -- so we have to *encode* this, using an auxilary wrapping data type, like the `T' above
15:43:44 <ski> if we want to express `(exists a. Foo a) -> Bar', then we could just as well say `forall a. (Foo a -> Bar)' (which is no problem)
15:44:21 <ski> but if we want to express `Baz -> (exists a. Foo a)' (iow *returning* an existential thing), then we have to say `Baz -> T' (after defining `T' as above)
15:44:35 <merijn> conal: Right, thinking about the I'd need to implement those semantics I end up with something along the lines of "(Event a -> Event (Behavior (a -> b))) -> Event a -> Behavior b", i.e. every input Event produces a new Behavior that consumes an input event and produces an output.
15:45:00 <ski> lo shachaf
15:45:27 <merijn> conal: Although that requires some pondering on implementation, as switcher requires an initial behavior, which I don't really have and, if I want to use the Applicative of Behavior, I need an initial a for stepper to turn the Event a into a Behavior
15:45:44 <anon123> ski: this kind of looks like a way to parameterize a type without parameterizing it
15:45:47 <ski> anon123 : a more interesting example might be `data Queue a = forall q. Q {queueState :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)}'
15:46:24 <ski> anon123 : yes, it's a way to introduce type variables "inside" a (data) type without having to mention them as parameters of the defined data type
15:46:53 <anon123> ski: and to this I just rewrote a bunch of code and introduced a lot of type parameters to solve this exact problem...
15:46:57 <anon123> *think
15:48:38 <ski> (another way to do that is "polymorphic components", like e.g. `data MonadDict m = MD {return :: forall a. a -> m a,bind :: foralll a b. m a -> (a -> m b) -> m b}'
15:48:41 <ski> )
15:51:14 <ski> merijn : perhaps one would sometimes want to be able to say `Foo a => ..a..' (as well as `Foo a *> ..a..') without immediately universally (resp. existentially) quantifying `a' outside
15:52:16 <ski> `forall a. Foo a => T a -> Baz a *> U a' or something, perchance
15:52:43 <bryanvick> beginner here, I think laziness might be biting me, any help is appreciated: http://lpaste.net/90820
15:53:35 <monochrom> what is your observation, and why is it unsatisfactory?
15:54:35 <bryanvick> when I log to stdout, characters are dropped, replaced.  "Client sent: 'foobar'" becomes "'lient sent: 'foobar"
15:55:06 <bryanvick> I log like this putStrLn $ "client sent: '" ++ cmd ++ "'"
15:55:14 <monochrom> then it is not laziness. laziness may delay a suffix, but not a prefix.
15:55:30 <bryanvick> monochrom: ah, I see
15:58:08 <merijn> bryanvick: Is your terminal/shell confused, by any chance?
15:58:13 <koala_man> bryanvick: it's because cmd ends with a carriage return
15:58:15 <monochrom> I can test this program
15:58:46 <monochrom> oh, interesting
15:58:48 <merijn> koala_man: Oh! Good one!
15:58:58 <merijn> I forgot what telnet specifies as line seperator
15:59:10 <merijn> bryanvick: Which OS are you running the telnet client from?
15:59:31 <monochrom> it happens on linux telnet too
15:59:35 <bryanvick> merijn: linux
15:59:55 <monochrom> I'm trying nc now
16:00:29 <monochrom> nc is better
16:00:45 <merijn> bryanvick: In general, connecting with telnet to a raw socket is a huge red flag
16:01:00 <merijn> bryanvick: telnet is *not* a raw TCP socket and expecting it to behave like one is wrong
16:01:48 <bryanvick> merijn: I was trying to explore the Network module, and just wanted a simple echo server
16:01:51 <monochrom> yeah, telnet sends out hahaha\r\n. GHC hGetLine on linux knows the \n but not the \r
16:02:09 <ezrios> pesky CRLF
16:02:15 <monochrom> ues nc :)
16:03:10 <geekosaur> telnet does what it does because most of the text-based internet protocols (e.g. SMTP, HTTP, ...) specify that a new line is \r\n
16:03:28 <monochrom> telnet chat.freenode.net 6667 :)
16:04:00 <monochrom> (IRC wants \r\n too, at least on paper, probably actual servers and clients don't mind either way)
16:04:00 <merijn> bryanvick: In the future you'd probably want to use netcat/nc
16:04:52 <merijn> bryanvick: nc *does* behave like a raw socket without any escaping
16:04:56 <bryanvick> merijn: how is the CR causing the ++ "'" to be printed first?
16:05:04 <geekosaur> because that;s what CR means
16:05:12 <geekosaur> cursor to the far left of the same line
16:05:16 <bryanvick> geekosaur: thanks
16:05:24 <geekosaur> "carriage return" as in old printing terminals
16:05:25 <c_wraith> all these people who never used a typewriter
16:05:43 <monochrom> it prints "client" etc just fine, then \r tells it to overwrite the c
16:05:58 <geekosaur> or yes, typewriters, but KidsTheseDays don't know typewriters :)
16:05:58 <monochrom> I used a typewriter
16:06:12 * tabemann has used a typewriter
16:07:00 <ion> I made something resembling ASCII art on my parents’ typewriter when i was a kid.
16:07:03 <bryanvick> very interesting
16:07:07 <monochrom> I am a typewriter-awing, fountain-pen-carrying capitalist
16:08:19 <c_wraith> bryanvick: just about any terminal program that provides a progress bar uses \r to continually update the same line
16:08:28 <Cale> I wrote with a fountain pen with a fine-point calligraphy nib for years, but it's too hard to get replacement nibs, you end up having to purchase entire sets.
16:08:28 <koala_man> I remember seeing a typewriter rendered face in a newspaper as a curiosity. these days you can view high res movies in ascii art. technology sure does change
16:09:06 <Cale> Other than that, I much prefer it to any ballpoint pen.
16:09:11 <ezrios> Cale: thanks for pointing me towards your monad tutorials
16:09:16 <ezrios> they are excellent
16:09:22 <Cale> ezrios: no problem, and thanks!
16:09:51 <monochrom> photocopiers and laser printers implement static typing :)
16:10:07 <ezrios> ohoho
16:10:45 <bryanvick> as someone who lives in vim+tmux+lynx, I'm emberassed I didn't realize CR was used to manipulate the terminal like that. thanks everyone
16:11:18 <Cale> Using a fountain pen with a flat nib every day is the easiest way to develop good handwriting. You're almost forced to produce nice shapes :)
16:11:44 * tabemann is used to CR as only being the other half of CRLF, as used in Windows and internet protocols, but was aware of its original function to move the cursor to the left edge of the line
16:12:32 <zebr> Cale: i don't know, i've seen a *lot* of fountained handwriting being completely illegible. mine is simple but nice and very readable. i suck with fountain pens though :p
16:12:59 <mserrano> zebr: but if it's illegible to you, it's probably illegible to the author too
16:13:02 <mserrano> at least with fountain pens
16:13:18 <kryft> Oo, fountain pens
16:13:39 <kryft> I didn't expect to see them discussed here, but perhaps that's not surprising :P
16:16:27 <FreeFull> tabemann: In unix, that's still what it does
16:16:27 <bryanvick> \quit
16:18:00 <zebr> people have a lot of trouble getting their slashes the right way round
16:18:09 <zebr> i see '/n' in example code all the time
16:18:15 <tabemann> FreeFull: yeah
16:19:23 <zebr> actually kinda curious. how would you rate this handwriting on the legibility and attractiveness scales? :p http://i.imgur.com/0NkygeJ.jpg
16:19:28 * geekosaur was doing that earlier today. normally gets it right, but still recovering from a nasty cold and somewhat more spaced out tham usual
16:19:38 <zebr> (old picture)
16:19:47 <Cale> zebr: Re: bad fountain pen writing, maybe... there's definitely some amount of effort involved in it still. But the flat nib makes a big difference just in terms of producing the right sort of curves, I find, while a ball-nib fountain pen isn't much better than a ballpoint in that regard.
16:19:50 <geekosaur> funny thing, <\a> doesn't work so well...
16:20:28 <Philippa> zebr: probably not ideally legible for some people, but too legible to be a doctor!
16:20:34 * tabemann can read much, but not all, of that
16:24:11 <koala_man> like http://xkcd.com/727/
16:24:31 <zebr> lol
16:26:07 <Cale> The reason that backslash is in ASCII is because it allows for /\ and \/ for easy meet and join symbols.
16:27:16 <Cale> (or logical AND and OR)
16:27:42 <Cale> http://www.bobbemer.com/BACSLASH.HTM :)
16:27:43 <zebr> oh my god, is that actually why? wikipedia agrees. that's .. wow. did backslash as a punctuation mark not predate that?
16:28:48 <koala_man> is "\" ever used as punctuation?
16:29:24 <Cale> Obviously, it would be hard to make the claim that nobody had ever written a downward sloping line before that point.
16:29:37 <zebr> well, yeah
16:29:44 <Cale> But it would be nowhere near as commonplace.
16:29:59 <zebr> koala_man: of sorts, on computers.
16:30:19 <koala_man> zebr: like when?
16:34:54 <ezrios> koala_man: \t
16:35:11 <ezrios> sometimes used as a delimiter, similar to a comma in that sense
16:35:39 <koala_man> ezrios: backslash-t is never used as a delimiter. the tab character is.
16:36:23 <ezrios> koala_man: is \t not interpreted as a tab
16:37:25 <geekosaur> ezrios, C made it somewhat popular but it's not inherently translated (say, at a command line)
16:37:51 <geekosaur> bash provides a $'...' construct whch accepts and translates those escapes
16:38:04 <ezrios> or alternatively I think just double quotes?
16:38:12 <koala_man> if it's not translated, it's not a delimiter. if it's translated, it's not a backslash.
16:38:14 <ezrios> # echo "Hello\t\t\tWorld"
16:38:20 <ezrios> koala_man: fair play
16:38:21 <koala_man> no
16:38:32 <ezrios> no?
16:38:32 <geekosaur> some (not all!) versions of echo translate
16:38:36 <geekosaur> translate \-escapes
16:39:07 <geekosaur> (somewhat infamously: http://everything2.com/title/The+UNIX+and+the+Echo )
16:39:45 <geekosaur> although that page lacks the context, which is that System V's echo interpreted \ and BSD's didn't
16:40:27 <ezrios> hm, I guess I am not old school enough to have messed around with other UNIX flavors
16:40:31 <zebr> koala_man: i have seen it before. i tried to find an example, but of course that is the most impossible thing to search for ever.
16:40:54 <monochrom> yikes, what have I done :)
16:43:53 <geekosaur> btw, an early prototype of ASCII didn't have \ (or underscore); it had arrows on those and a couple other codepoints. there used to be a programming language that used _ for assignment because, when they chose it, there was a left arrow on that codepoint
16:44:25 <zebr> oh, i think i remember reading about that
16:44:30 <chrisdone> zebr: your handwriting is hideous! F- poor! and you hold your pen like you're not sure which end is which =p
16:44:39 <chrisdone> </grade>
16:45:34 * ski . o O ( `http:\\blah\blah' )
16:45:53 <zebr> chrisdone: yeah, the reason i originally took that picture was to demonstrate that i hold pens in a totally weird way. >.> i learnt to write way before anyone tried to teach me, so weird way kinda stuck. had the same thing with typing, sadly. >.>
16:46:20 <ski> (also left-division)
16:46:54 <chrisdone> zebr: that's one way to approach things… :p
16:48:04 <tabemann> geekosaur: Smalltalk was it
16:48:16 <tabemann> they eventually changed it to accept := for assignment, though
16:48:16 <geekosaur> that sounds right
16:49:24 <tabemann> (arrows for such things makes me think of the idea of using arbitrary Unicode characters in code, e.g. in Agda and an extension to GHC Haskell...)
16:49:29 <ski> hm, i think some systems used an up arrow in place of `^'
16:49:38 <tabemann> ski: there was that too, yeah
16:49:46 <geekosaur> trs-80!
16:49:52 <ski> (e.g. PETSCII)
16:54:29 <LuxuryMode> Following (an outdated) tutorial that shows "import IO"..whats the full, correct IO import?
16:54:39 <chrisdone> System.IO
16:54:52 <LuxuryMode> thanks chrisdone
16:54:57 <chrisdone> welcome
16:56:55 <chrisdone> http://imageshack.us/a/img269/3640/haskell.png
16:58:50 <ski> .. ought to be `f b' at the end
16:59:48 <chrisdone> found it in some old archives =p
17:02:40 <Cale> :t let loeb x = fmap ($ loeb x) x in loeb
17:02:41 <lambdabot> Functor f => f (f b -> b) -> f b
17:02:53 <Cale> The image gets the type wrong.
17:03:28 <Cale> ah, ski already mentioned that :)
17:03:35 <chrisdone> i guess the author wasn't beginning to understand haskell after all =p
17:03:53 <c_wraith> well, he was about to get eaten by a velociraptor.  (loeb)
17:04:17 <c_wraith> loeb's type seems to be sort of related to fix, at some level.
17:04:31 <Cale> It would be extremely surprising to find a function of the type suggested by the comic.
17:04:58 <Cale> (which was anything but undefined everywhere)
17:06:57 * chrisdone . o O ( or maybe the raptor didn't understand haskell )
17:07:24 <chrisdone> silly velociraptor, you're a dinosaur, step away from the compiler, you can't even type
17:08:41 <LuxuryMode> trying to 'import Random' getting Could not find module `Random' It is a member of the hidden package `haskell98-2.0.0.1'.
17:09:09 <josephle> chrisdone: considering his signature for loeb, I'm pretty sure that velociraptor can type
17:09:13 * josephle runs away
17:09:40 <chrisdone> LuxuryMode: System.Random?
17:09:47 <LuxuryMode> hehe again
17:09:58 <LuxuryMode> i see..anything in "language" is just "System"?
17:11:01 <chrisdone> it's a bit arbitrary, but if it's in haskell98 but not haskell2010 it's a decent bet it's now System.*
17:11:03 <c_wraith> LuxuryMode: pretty much everything that was renamed when hierarchical module names were added was made System.*
17:11:13 <randomlogin> Can anyone explain how does widgetDestroy from gtk2hs work? Here is example code that doesn't work correctly: http://lpaste.net/90822.
17:11:28 <ski> c_wraith : yes, it's related to <http://en.wikipedia.org/wiki/L%C3%B6b%27s_paradox> and <http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem>
17:11:52 <chrisdone> LuxuryMode: check out http://www.haskell.org/ghc/docs/latest/html/libraries/
17:12:55 <ski> c_wraith : which is related to `(\x. x x) (\x. x x)' and `(\x. x x) (\x. f (x x))' for a given `f'
17:13:11 <LuxuryMode> chrisdone yeah, thanks. ive had that tab open for a while. come from a java/scala background so still getting used to the package system and docs
17:18:06 <chrisdone> LuxuryMode: cool =)
17:20:15 <chrisdone> LuxuryMode: welcome to haskell
17:20:19 * chrisdone waves lazily
17:20:37 <LuxuryMode> hehe thanks
17:21:31 <LuxuryMode> this is my 2nd foray into it. it seems like any other path to FP is more circuitous
17:27:51 <chrisdone> LuxuryMode: took many of us a couple times, too =)
17:29:29 <ClaudiusMaximus> randomlogin: the table at the start of your button callback is always the one created at the start of the program, because scoping purity etc - you could use an IORef (or STM, which is nicer for more complex programs) to store the current table
17:31:23 <randomlogin> ClaudiusMaximus: thanks
18:34:48 <ericmoritz> hi; newbie here.  I'm trying to create a record that I can fold over but I'm getting an error that I can't decipher.  https://gist.github.com/ericmoritz/5980747
18:36:20 <nerrz> what is the ghc flag to set the main function?
18:36:38 <Cale> --main-is
18:36:43 <nerrz> where would that go?
18:36:48 <Cale> The commandline
18:36:51 <nerrz> like ghc -- make -main-is
18:36:55 <nerrz> or after
18:37:02 <Cale> anywhere on the commandline
18:37:05 <nerrz> okay
18:37:24 <Cale> ah, yeah, it's -main-is
18:37:41 <Cale> But, why do you need to set that?
18:37:46 <roboguy_> ericmoritz: Config doesn't have any type arguments and Foldable needs something that has exactly one
18:37:52 <Cale> It usually shouldn't be necessary.
18:38:05 <roboguy_> ericmoritz: For example, Maybe has one type argument but Int has none
18:38:34 <Cale> You can name your executable's .hs file anything and simply not include a module declaration at the top of it, and compiling that with ghc will produce an executable with the same name.
18:38:38 <nerrz> well, it is just for a little project and I am adding something to compile and run stand alone function
18:38:39 <nerrz> s
18:38:46 <nerrz> as a feature
18:38:53 <Cale> ah, hmm, okay
18:39:08 <roboguy_> ericmoritz: incidentally, there's a pretty important builtin function called "seq" so I might also choose a different name for that field
18:40:54 <ericmoritz> roboguy_: oh, you're right; I know of the seq function
18:41:22 <nerrz> it is a little library to save snippets of code, to search for them with regex and by language and title, and I am adding a way to execute them if they are valid functions
18:41:34 <nerrz> so, ty
18:42:17 <roboguy_> ericmoritz: does the other thing (about the kinds) make sense?
18:45:53 <ericmoritz> roboguy_: no. not really.  I am a bit in the dark about type classes.  So do I need a "class Config ConfigRecord" or something?
18:46:25 <ericmoritz> where ConfigRecord is the record that I'm currently using
18:46:42 <roboguy_> ericmoritz: No, it's because Config doesn't have any type variables. You can't have a type like this, for instance, "Config Int". You can only have "Config"
18:47:31 <roboguy_> ericmoritz: here's an example of something that could work with Foldable: data GeneralConfig a = GeneralConfig { dir :: String, sequence :: Seq a } deriving Show
18:47:46 <ericmoritz> ah ok
18:48:13 <ericmoritz> I'm confusing the left and right sides of the data expression
18:49:06 <roboguy_> ericmoritz: the reason that Foldable is like this is because if we look at the type of, for example, foldr we see it's foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
18:49:22 <roboguy_> ericmoritz: when we make an instance of the type class, it replaces that "t" with the type (in this case Config)
18:49:40 <roboguy_> ericmoritz: and it applies it to a type argument, which you can't do with the Config you have right now
18:50:05 <ski> ericmoritz : why do you think you need/want to make `Config' an instance of `Foldable' ?
18:50:29 <ski> (iow, what are you trying to accomplish by making such an instance ?)
18:51:00 <ericmoritz> I want to call (fold f z config) to fold over the queue
18:51:30 <ericmoritz> I'm probably expressing this in a silly way
18:51:51 <ericmoritz> or just not thinking in the Haskell way ;)
18:52:11 <ski> why not something like `fold f z (Config.seq config)' ?
18:52:50 <ski> in any case, you can't return values of shape `Config ... ...' from `foldr' and `foldMap' there
18:53:03 <ericmoritz> ski: yeah, that's where I ended up going with it.  I was trying to hide the implementation details of the config; but it's not that important
18:53:07 <ski> @type Data.Foldable.foldr
18:53:08 <ski> @type Data.Foldable.foldMap
18:53:08 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:53:08 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:53:18 <ski> note the final `b' respectively `m' there
18:54:07 <ski> those two operations are promising to return values of types *arbitrary* types `b' and `m', types which the *caller* of `foldr' and `foldMap' will choose -- you have no say in what those types will be
18:55:02 <ski> and since `Config ... ...' has type `Config', which is a concrete type, it would usually not match the type `b' or `m' that the caller wanted the operation to return, so the type system therefore doesn't allow this
18:56:00 <ericmoritz> ski: oh yeah, I'm really not thinking of this correctly.  fold takes a (a -> b -> b) and iterates over t a
18:56:50 <ski> you *could* possibly just ignore the `dir' part of a config (and then *not* rewrapping the results of `foldr' and `foldMap' with `Config (dir c) ...' again) -- if you do what roboguy_ suggested
18:56:53 <ericmoritz> I'm basically trying to express a function that is (a -> Config -> Config) -> Config -> Config
18:57:54 <ericmoritz> i.e. take a config, apply a function that returns a config over each item in the Seq.  That's not really a fold at all
18:58:50 <ericmoritz> I'm just going to do what roboguy_ said and take the Seq out of the Config; it shouldn't be in there anyway
18:59:12 <benzrf> ugh
18:59:25 <benzrf> I more or less understand what monads are, mechanically...
18:59:33 <ski> well, `foldr :: (a -> Config c -> Config c) -> Config a -> Config c' would be a valid instance of `foldr :: (a -> b -> b) -> b -> Config a -> b' (setting `b' to `Config c', for some type `c')
18:59:39 <benzrf> but I can't find a satisfactory definition in my head of what they 'represent'
18:59:46 <roboguy_> ericmoritz, ski: well, I'm not sure it would make sense to generalize it in that way. it depends on what you're looking for, though
19:00:06 <ski> but `foldr' itself isn't allowed to make use of any knowledge about that the type `b' may be the type `Config c'
19:01:03 <ski> (it's not allowed to make any use of such knowledge, *except* from calling the function argument, i.e. -- the function argument may make use of such knowledge -- but that code can't be written inside `foldr')
19:02:14 <benzrf> btw, do-notation is built into the language and cannot be replicated in pure haskell, right?
19:02:21 <ski> benzrf : familiarity with common examples probably breeds more understanding
19:02:31 <ski> benzrf : nope, `do'-notation is pure syntactic sugar
19:02:31 <benzrf> ski: that's the thing
19:02:34 <benzrf> ok
19:02:38 <benzrf> well I mean
19:02:44 <benzrf> the syntax is built into the language
19:02:49 <benzrf> I know what do-notation is
19:03:01 <ski> early versions had monads (e.g. `IO' monad) without having `do'-notation
19:03:01 <benzrf> like, you can't have a similar syntax for. say.
19:03:04 <benzrf> applicatives
19:03:15 <JuanDaugherty> so is a lot of stuff backed up from neither of the main hs guis supporting 7.6?
19:03:19 <ski> probably depends on what you mean by "similar"
19:03:19 <ericmoritz> I understand my confusion now.  A fold needs to fold over a thing that has the same kind as the function being applied
19:03:33 <roboguy_> benzrf: well, you don't really need that syntax for applicatives. the infix operators work pretty well on their own, I think
19:03:43 <benzrf> ok
19:03:46 <benzrf> just an example :P
19:03:49 <roboguy_> or, I should say, infix functions
19:03:58 <benzrf> I mean that do notation is exclusively for monads and monads are getting special treatment
19:04:01 <benzrf> yes?
19:04:15 <roboguy_> benzrf: yes
19:04:18 <benzrf> like, there's no general form of it or way to make a new notation
19:04:18 <benzrf> ok
19:04:23 <benzrf> so
19:04:37 <ski> ericmoritz : well, a `foldr' needs to fold over a *"collection"* of things, each having the same type as the things being passed to the function argument
19:04:47 <benzrf> the thing is, for any inidivual instance of Monad, I can understand what it means for it to be a Monad... more or less
19:04:59 <benzrf> but I can't get a good picture in my head of what Monads are meant to represent in general
19:05:09 <ski> benzrf : .. there could be ways to make new notations
19:05:16 <ericmoritz> ski: yeah I was being overly general; I collection of things of the same kind
19:05:18 <benzrf> ski: without ghc extensions
19:05:22 <roboguy_> ericmoritz: well, it needs something that takes a type argument. so, in the case of lists for example, it can turn a list of "a"s into a list of "b"s
19:06:11 <ski> ericmoritz : yes .. where also the collection has no say in what the element type should be -- it must be allowed to be any type the user chooses
19:06:32 <ski> (which is why you'd need `data Config a = ..a..', with a parameter `a')
19:06:33 <geekosaur> @where SugarHaskell
19:06:33 <lambdabot> I know nothing about sugarhaskell.
19:06:35 <geekosaur> mrf
19:06:38 <roboguy_> benzrf: I don't know if this is a completely correct way to look at it (I'm still learning too), but I think of monads as composable computations
19:06:47 <benzrf> roboguy_: I tried that...
19:06:54 <benzrf> it just doesn't seem to completely cover them
19:06:54 <benzrf> :\
19:07:06 <benzrf> idk
19:07:14 <ski> benzrf : probably depends on how you define "computation" ;)
19:07:20 <enthropy> benzrf: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.2/doc/html/Language-Haskell-Meta-QQ-ADo.html if you want ghc extensions
19:07:36 <roboguy_> benzrf: which ones don't fit?
19:07:46 <benzrf> urgh
19:07:53 <benzrf> now that you ask all of the examples fly out of my head :D
19:07:57 <ski> (if you define "computation" as "monadic action", it's easier ;)
19:08:00 <benzrf> I meant more like
19:08:08 <benzrf> it doesn't seem to cover the whole definition
19:08:12 <benzrf> like, that's PART of it
19:08:46 <benzrf> in any case...
19:09:28 <benzrf> infix type constructors (i.e. ->) aren't possible to make without an extension, right?
19:09:50 <roboguy_> benzrf: (->) is a type constructor that takes two arguments
19:09:58 <benzrf> yes that's what I said
19:09:59 <roboguy_> benzrf: and ((->) a) takes one
19:10:00 <benzrf> it's infix
19:10:10 <benzrf> it's an infix type constructor
19:10:18 <geekosaur> benzrf: in at least some ghc versions, an operator starting with : is an infix type constructir
19:10:25 <benzrf> hmm
19:10:31 <roboguy_> benzrf: I don't think you need a extension for that, but I'm not sure
19:10:53 <roboguy_> benzrf: for example, ((->) r) is a Functor
19:10:53 <benzrf> Prelude> data (::::) a b = Foo a b
19:10:54 <benzrf> <interactive>:2:6:
19:10:54 <benzrf>     Illegal declaration of a type or class operator `::::'
19:10:54 <benzrf>       Use -XTypeOperators to declare operators in type and declarations
19:10:54 <ski> roboguy_ : you used to need an extension for it
19:11:02 <roboguy_> oh
19:11:26 <benzrf> why, though?
19:12:01 <benzrf> obviously there's language support for it; functions use an infix type constructor and you can make infix value constructors
19:12:14 <ski> hrm, well rather, it used to be that infix type constructors had to start with `:' (apart from the exception `->')
19:12:16 <benzrf> what gives?
19:12:24 <roboguy_> I guess it's not in the Haskell 98 standard
19:12:30 <benzrf> huh
19:12:31 <ski> (and other symbolic ones would be infix type variables)
19:13:14 <geekosaur> benzrf, pattern matching. when is it a constructor name (hence matchable) and when is it a variable?
19:13:15 <ski> now you still need an extension, but they become infix type constructors (rather than tyvars) even if they don't start with `:'
19:13:27 <benzrf> geekosaur: oh, hm
19:13:29 <ski> (which is sometimes irritating, when you want infix tyvars)
19:13:47 <slack1256> The idea of WrappedMonad is to give free aplicative instances to monad right?
19:13:56 <geekosaur> for prefixes, the distinction is uppercase. there's no such concept for symbols, so they standardized list's (:)
19:14:03 <slack1256> so in ghc 7.8 with the AMP it should be redundant right?
19:14:40 <benzrf> anyway, atm I feel that I understand haskell well enough that I can comprehend most non-advanced code if I stare at it for long enough, but I don't feel like, given a program to make, I could sit down and code it.
19:14:56 <benzrf> and I don't really have many reasonable applications for haskell.
19:15:08 <mapreduce> benzrf: I feel the opposite way, I can get stuff done but can't read arbitrary code very well.
19:15:15 <benzrf> huh
19:15:58 <slack1256> mapreduce: I was like that also until I started to read projects with really good documentation to understand arbitrary code.
19:16:33 <benzrf> I think the big problem is that, with most of the languages I've learned, I could keep writing my previous language in them and gradually adapt to thinking in the new one
19:16:41 <benzrf> i.e. procedural stuff in java
19:16:47 <benzrf> java-y stuff in python
19:16:55 <benzrf> but with haskell it shares too little to have a good starting stop
19:16:57 <benzrf> *spot
19:17:08 <benzrf> it feels more like being thrown into the ocean vs. slowly walking in
19:17:10 <benzrf> o_o
19:18:43 <inf-groupoid> benzrf: I was stuck like that, too, until I realized the solution was to learn to program from scratch.
19:18:48 <mapreduce> slack1256: Sounds like a good topic for a closed-as-offtopic stackoverflow question, "Which Haskell projects have code that is easy to read?" :)
19:19:12 <slack1256> benzrf: then how was your first introduction to programming? your first language experience?
19:19:18 <benzrf> slack1256: I barely remember
19:19:26 <slack1256> for everybody is difficult but you can replicate the processes here, dont?
19:19:30 <benzrf> my dad showed me BASIC when I was 7
19:19:31 <benzrf> :|
19:19:45 <slack1256> cool dad ;)
19:19:47 <inf-groupoid> Poor you.
19:19:47 <benzrf> I've been thinking in code for too long to remember how I got started
19:19:53 <benzrf> :p
19:20:11 * geekosaur is still kinda in the "not so good with writing new code" place, actually, but manages to contribute to xmonad okay. (mostly because you need to know more X11 than Haskell, though)
19:20:14 <ericmoritz> I'm learning Haskell from a Python / Erlang background; I found I can right Haskell like Python with excessive use of do blocks
19:20:40 * benzrf slaps ericmoritz 
19:20:45 <inf-groupoid> ericmoritz: But that kinda defeats the point to using a purely functional language. :-|
19:21:10 <mapreduce> I started with BASIC when I was 5 because I was too impatient to wait 20 minutes for a game to load from cassette.
19:21:12 <slack1256> geekosaur: core stuff or -contrib stuff (if so which modules are yours?)
19:21:18 <benzrf> hehe
19:21:31 <ericmoritz> inf-groupoid: I know but it is that starting spot that benzrf speaks of
19:22:00 <benzrf> I recently downloaded cmatrix and tend to leave it on and zone out while staring at it
19:22:04 <mapreduce> I'm pretty sure that first language doesn't have a lot of bearing on future programming.
19:22:09 <benzrf> and I started thinking about how I'd implement it
19:22:26 <benzrf> it was about that time that I realized I have no idea how to start any reasonably-sized program in haskell
19:22:29 <benzrf> :\
19:22:42 <Demos> BASIC was a fine little language, being able to immediately run a program was a pretty big deal
19:22:54 <Demos> hell I prefer BASIC to javascript
19:22:54 <slack1256> reimplement a prgram you have already done on another language in haskell
19:23:02 * ericmoritz doesn't know what he's doing at all ;)
19:23:02 <Hafydd> < ericmoritz> I'm learning Haskell from a Python / Erlang background; I found I can <s>right</s>wrong Haskell like Python with excessive use of do blocks
19:23:06 <Hafydd> Fixed.
19:23:36 <benzrf> ericmoritz: you have to think F U N C T I O N A L L Y
19:23:41 <inf-groupoid> Hafydd: lol
19:23:59 <ericmoritz> Hafydd: I am well aware that I'm doing this poorly but it is my first Haskell program ;)
19:24:09 <benzrf> I was *thinking* that I could do something like
19:24:22 <Demos> think of the do block as a the chocolate sauce on top of your pure functional ice cream
19:24:26 <benzrf> store each falling string as a list of characters spanning the screen, and a pair of start/stop points currently
19:24:31 <benzrf> or maybe just start/length
19:24:57 <benzrf> then... during a constant loop, map an update function over the list of falling strings?
19:25:04 <benzrf> and then draw them somehow?
19:25:22 <ericmoritz> Unfortunatly it is full of IO so I am not sure how I can get around having a bunch of functions that return IO x
19:25:25 <benzrf> gah thinking too procedually
19:25:42 <benzrf> ericmoritz: completely separate the IO and the processing
19:25:47 <benzrf> do as much processing as possible before doing IO
19:26:08 <geekosaur> slack1256, contrib modules are XMonad.Hooks.Debug* and XMonad.Util.DebugWindow, XMonad.Hooks.FadeWindows, XMonad.Layout.OnHost; no actual code in the core but a fair amount of its ICCCM support is *because* of me (in fact pretty much the first thing I did involving xmonad was teach sjanssen how to "think like the ICCCM" so the window manager protocol actually made sense to him)
19:26:21 <inf-groupoid> benzrf: Do no processing in IO, as a matter of fact. IO is for, well... IO.
19:26:31 <benzrf> mhm
19:26:32 <ericmoritz> so basically it is a dependancy management tool.  Read a file full of urls, download those urls, read a similar file in each dependancy, download those urls
19:26:52 <benzrf> what library will allow me to place an arbitrary character at an arbitrary point in the terminal?
19:26:55 <benzrf> curses?
19:27:15 <ericmoritz> so it is a big tree of IO calls
19:27:25 <geekosaur> it will, but not nicely. might look at vty/vty-ui
19:27:46 <Demos> benzrf, printing spaces and /r
19:27:48 <benzrf> oh wow I JUST realized that evaluating random program input is mostly safe since it can't execute arbitrary code if you do so
19:27:48 <geekosaur> (curses / hscurses is a wrapper for the curses library. it works, but it's named that for a reason...)
19:27:50 <benzrf> o:
19:27:55 <benzrf> Demos: oh god please no
19:28:13 <Demos> benzrf, I be that is what curses does
19:28:19 <Demos> *bet
19:28:27 <benzrf> looking now o:
19:28:43 <mapreduce> benzrf: Depending on what it's for you might look for a wrapper for dialog or whiptail instead.
19:28:46 <geekosaur> Demos: no
19:29:05 <benzrf> mapreduce: I want to be able to place an arbitrary character at an arbitrary x/y
19:29:05 <Demos> geekosaur, what I only have a 25 year old terminal
19:29:08 <benzrf> that is all
19:29:16 <Demos> *what if
19:29:25 <geekosaur> it does far more than "spaces and \r"
19:29:28 <benzrf> termcap?
19:30:11 <geekosaur> dude, pretty sure there's still adm3a terminfo entries in the standard terminal database :)
19:30:25 <slack1256> geekosaur: Oh so you were involved inXMonad.Hooks.DebugKeyEvents? if so 'thank you' you were of much help 2 months ago
19:33:55 <ski> benzrf : basic haskell <http://augustss.blogspot.se/2009/02/is-haskell-fast-lets-do-simple.html>
19:34:58 <benzrf> waait wtf
19:35:16 <lpsmith> Hmm,  does fay have a strictness analyzer?  How good is it?
19:35:20 <benzrf> o_o
19:36:23 <ski> (also see <http://augustss.blogspot.se/search/label/BASIC>)
19:40:13 <benzrf> can chars be coerced to Word32?
19:40:33 <benzrf> that is, can I pass a char to a function that takes a Word32
19:40:51 <inf-groupoid> You cannot pass anything but a Word32 to a function that takes a Word32.
19:41:09 <benzrf> wait
19:41:10 <benzrf> ugh
19:41:11 <benzrf> yes
19:41:12 <benzrf> -.-
19:41:18 <Hafydd> There is no such concept of "coercion" in Haskell.
19:41:19 <benzrf> how can I convert a char to one?
19:41:28 <geekosaur> perhaps you are thinking of ord (or, more generally, fromEnum and toEnum)
19:41:32 <benzrf> I know, I was mistakenly thinking of typeclasses
19:41:33 <benzrf> :|
19:41:42 <benzrf> i.e. how you can pass most kinds of numbers to a lot of functions
19:41:44 <benzrf> I'm sleepy >_>
19:41:48 <Cale> benzrf: fromIntegral . ord
19:41:48 <benzrf> thanks geekosaur
19:41:53 <xilo> is there anything like codeacademy but for haskell
19:42:25 <benzrf> Cale: where do I get ord from, again?
19:42:37 <Demos> rwh is kinda like codeacademy, but better
19:42:38 <inf-groupoid> Data.Char ?
19:42:47 <benzrf> ugh
19:42:48 <benzrf> thanks
19:43:20 <inf-groupoid> benzrf: Perhaps it is in Prelude as well, in which case you do not have to import Data.Char.
19:43:21 <xilo> Demos: i prefer by doing, not a book describing examples :/
19:43:29 <benzrf> inf-groupoid: it isn't
19:43:45 <benzrf> xilo: then follow along in ghci
19:43:53 <xilo> benzrf: that's not how i learn
19:44:10 <benzrf> xilo: how then?
19:44:11 <Cale> benzrf: You could also use fromEnum if the import bothers you
19:44:17 <Demos> and do something slightly different, haskell is so different that something like Go's Tour Go would not work too well
19:44:45 <xilo> bezik: a mix of giving examples and also exercises... exactly like codeacademy does it.
19:44:59 <benzrf> xilo: read LYAH and follow along in ghci
19:45:13 <xilo> benzrf: that's the same thing as following rwh
19:45:17 <xilo> i got bored going through both
19:45:22 <benzrf> oh really?
19:45:28 <xilo> yep
19:45:31 <benzrf> doesn't it contain suggestions for what to figure out how to do?
19:45:40 <Demos> is codeacademy any good these days, last I saw it just taught you mechanics
19:45:49 <Demos> and how do you get board reading leyah!
19:45:54 <Demos> *lyah
19:46:03 <xilo> it teaches you the mechanics of the language
19:46:04 <benzrf> how do I install a package again?
19:46:05 <xilo> which i like
19:46:05 <benzrf> >_>
19:46:14 <benzrf> cabal?
19:46:20 <xilo> cabal install foo
19:46:23 <benzrf> right
19:46:45 <Demos> try your local package manager first though!
19:46:52 <inf-groupoid> xilo: Machines have mechanics, languages have semantics.
19:46:54 <xilo> Demos: no idea if they don't... i read through several chapters and it was just describing stuff
19:47:04 <xilo> inf-groupoid: technicalities
19:47:15 <benzrf> xilo: pfft
19:47:26 <benzrf> xilo: calling out a PROGRAMMER on a technicality?
19:47:28 <xilo> i always prefered using the languages package manager to the distro package manager
19:47:35 <benzrf> programming is all about technicalities
19:47:39 <inf-groupoid> xilo: No, it is not a technicality.
19:47:44 <Demos> inf-groupoid, well yes but I meant like this is a while loop, this is how you use it. Not like why to use it and that sort of thing
19:48:03 <inf-groupoid> xilo: Using programming languages is waaay more convenient than directly working with the machine's mechanics.
19:48:23 <Demos> real programmers use a magnet and a steady hand :D
19:48:35 <benzrf> Demos: try m-x butterfly in emacs
19:48:37 <benzrf> it Really Works
19:48:43 <benzrf> also, import antigravity in py3
19:48:43 <edwardk> be nice =P
19:49:00 <xilo> inf-groupoid: don't be so butt hurt. we know what we meant
19:49:21 <ezrios> xilo: perhaps you could try some challenges on HackerRank
19:49:28 <ezrios> they do indeed support Haskell
19:49:36 <ezrios> or at least, the ones I tried did
19:49:36 <xilo> ezrios: let me check it out
19:49:56 <ezrios> they have a pretty wide array of interesting problems
19:51:42 <xilo> doesn't really teach you how to learn language features tho
19:51:44 <xilo> neat site tho
19:52:59 <Demos> hm neat site, but not so great on 27kbps
19:53:09 <ezrios> xilo: yeah, it's not really an instructional site
19:53:44 <Guest34097> does anybody know Th0masR0ss?  which channel is he in?
19:53:46 <ezrios> @t =<<
19:53:46 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
19:53:58 <ezrios> @type =<<
19:53:59 <lambdabot> parse error on input `=<<'
19:54:02 <xilo> think i'm just screwed in learning a FL lol
19:54:08 <ezrios> I guess I don't understand how to use this bot
19:54:12 <ezrios> back to ghci
19:54:30 <Demos> xilo, just get coding!
19:54:38 <ezrios> oh pff I forgot the parens ._.
19:55:06 <ezrios> xilo: Demos has the right of it
19:55:16 <xilo> Demos: kinda hard to when you you've been ingrained with OO and procedural programming your entire life and no FP has decent tutorials akin to code academy to get you going
19:55:31 <ezrios> xilo: Perhaps you could look into a Lisp?
19:55:42 <xilo> lisp made my head explode
19:55:43 <ezrios> Racket was actually my first venture into FP, not a bad language for learning
19:55:47 <ezrios> hm
19:56:08 <Demos> well learning FP is about learning how to think in terms of functions
19:56:28 <Demos> hell you can do functional programming in C++ if you really want to
19:56:49 <xilo> well i meant language wise
19:56:56 <xilo> FP language wise
19:57:12 <Demos> haskell's purity means that just hacking on some project in haskell will teach you quite a lot about FP
19:57:44 <ezrios> I think FP is more about a paradigm shift/change in thinking more than about language features
19:57:51 <ezrios> I mean Lisp is amazingly simple syntactically
19:58:16 <Demos> haskell is as well compared to many things
19:58:28 <Demos> and both let you define your own language constructs
19:58:37 <benzrf> well, *Python* is amazingly simple semantically
19:58:42 <benzrf> :y
19:58:50 <pharaun> benzrf: you can rewrite *everything* in python :D
19:59:09 <pharaun> __code__, stack and various other fun stuff
19:59:12 <pharaun> go look it up
19:59:16 <Demos> pharaun, you can rewrite anything in anything (no agda does not count)
19:59:30 <benzrf> pharaun: I'm already quite well versed in python's amazing level of introspection thanks
19:59:33 <pharaun> Demos: aw :)
19:59:33 <benzrf> o:
19:59:48 <pharaun> benzrf: haha me as well, i work on python for a living
19:59:58 <pharaun> half of the time i like it, half of the time i hate it for the very same reason
20:00:13 <ezrios> pharaun: I am the same
20:00:15 <benzrf> I was more referring to how most of the language is based around the behaviors of the core types vs. being baked into the language
20:00:19 <ezrios> except instead of working on python it's Perl
20:00:21 <ezrios> ._.
20:00:21 <benzrf> and therefore simulable and overridable
20:00:24 <benzrf> ezrios: :(
20:00:30 * JuanDaugherty don't wanna hear about pythong
20:00:43 <benzrf> JuanDaugherty: but this is #python, you have no choice
20:00:46 <pharaun> benzrf: ahh i see :) fair enough
20:00:56 <ezrios> wat
20:01:24 <Demos> I work in javascript during the week
20:01:27 <benzrf> in closing norvig.com/python-lisp.html
20:01:50 <ericmoritz> is there a easy way to take a list of maybes and return the values of the Just values?  i.e. [Just 1, Nothing, Just 2] -> [1,2]?
20:01:53 <ezrios> benzrf: bookmarked, looks like a good read
20:02:27 <benzrf> ericmoritz: errrm how about map over it with a function that converts Just n to [n] and Nothing to []
20:02:30 <benzrf> then concat?
20:02:47 <ezrios> ericmoritz: or maybe pattern match and recurse onto an accumulator?
20:03:08 <benzrf> help I don't know what that means
20:03:29 <benzrf> oh wait I think I do
20:03:31 <ezrios> benzrf: that was poorly worded, I will hack up some code (if I can >.>)
20:03:31 <benzrf> clever
20:03:55 <benzrf> no, you have a standard recursive function that builds up a list
20:04:01 <benzrf> and it pattern matches on Just or Nothing
20:04:02 <ezrios> foldr
20:04:08 <benzrf> and adds an element or not
20:04:08 <benzrf> ugh
20:04:10 <benzrf> folds
20:04:20 <benzrf> pfft I always forget about the most basic stuff
20:04:23 <ezrios> benzrf: yah, that's what I was getting at
20:05:05 <ericmoritz> nm; map fromJust $ Prelude.filter isJust
20:05:16 * benzrf headdesks
20:05:21 <benzrf> blug
20:05:22 <whaletechno> > [ x | Just x <- [Just 1, Nothing, Just 2]] -- ericmoritz
20:05:23 <lambdabot>   [1,2]
20:05:24 <benzrf> too obvious
20:05:31 <ericmoritz> ha
20:05:44 <ezrios> gah
20:05:47 <Gracenotes> fail
20:05:48 <ezrios> I need to actually read through the Prelude
20:06:02 <ezrios> and figure out what functions come standard with Haskell ._.
20:06:15 <ezrios> every day there is some magical gem I can't believe I've lived without for so long
20:06:21 <whaletechno> or you can use catMaybes
20:06:27 <whaletechno> @hoogle catMaybes
20:06:27 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:06:35 <ezrios> like that one
20:07:03 <benzrf> :(
20:07:10 <benzrf> ok I'm starting to fall asleep
20:07:12 <benzrf> goodbye
20:07:50 <slack1256> @type unsafeCoerce
20:07:51 <lambdabot> Not in scope: `unsafeCoerce'
20:08:41 <Gracenotes> a -> b
20:09:17 <slack1256> Yes, but I got a weird result on ghci with unsafeCoerce and wanted to print the session here to check it out.
20:10:22 <geekosaur> unless you know exactly what you are doing, weird results are pretty likely
20:10:47 <slack1256> what should be the result of 'unsafeCoerce (128 :: Int16) :: Int8'
20:10:58 <Gracenotes> what is your result?
20:11:05 <Gracenotes> that is what the result should be
20:11:06 <slack1256> it should be -128 right? but I got '128 :: Int8'
20:11:21 <geekosaur> no
20:11:24 <shachaf> slack1256: Why "should" it be anything?
20:11:27 <shachaf> You unsafeCoerced.
20:11:56 <slack1256> Ha, yeah, but I was thinking on term of 'shifting' bytes.
20:12:04 <slack1256> but 128 isn't even a Int8
20:12:05 <geekosaur> no
20:12:09 <geekosaur> it doesn't shift anything
20:12:16 <slack1256> Int8 = [-128, 127] right?
20:12:17 <geekosaur> it reinterprets the contents of memory as something else
20:12:42 <Gracenotes> if you want an answer "why", though, because Int16 and Int8 are both boxed, so a word is used to represent the value of both.
20:12:53 <slack1256> OH
20:12:57 <slack1256> right!
20:12:59 <Gracenotes> this is not guaranteed in the implementation
20:13:02 <slack1256> boxed representations
20:13:11 <Gracenotes> unsafeCoerce could well return 0xF00F
20:13:39 * Gracenotes is being very pedantic or something
20:13:44 <inf-groupoid> unsafeCoerce is basically what C++ calls reinterpret_cast, right?
20:13:55 <geekosaur> yes and no
20:14:04 <Gracenotes> that's kinda what GHC does.
20:14:04 <slack1256> Is okey, I am trying to get intuition on unsefaCoerce
20:14:07 <geekosaur> yes because it is that, viewed from a very low level
20:14:44 <Gracenotes> > :i Int8
20:14:44 <Gracenotes> data Int8 = GHC.Int.I8# GHC.Prim.Int# 	-- Defined in `GHC.Int'
20:14:45 <lambdabot>   <hint>:1:1: parse error on input `:'
20:14:56 <geekosaur> but you also have to consider that a boxed value has a constructor associated with it, and *that* is also reinterpreted. if the thing you;re coercing from and the thing you're coercing to have a single constructor each, things might be sane. if not...
20:15:22 <inf-groupoid> Ah.
20:15:25 <inf-groupoid> If the type system hole that makes unsafeCoerce possible specific to GHC?
20:15:41 <geekosaur> (I think ghc just uses a number counting from 0 for the constructor tag; it could use a pointer, in which case g-d alone knows what would happen)
20:16:10 <geekosaur> huh? unsafeCoerce *is* the hole. and it's outside of the type system, as it were
20:16:25 <Demos> it is the escape pod
20:17:01 <inf-groupoid> geekosaur: It is my understanding that there has to be a hole in the implementation of the core language itself to make this stuff feasible in libraries.
20:17:04 <geekosaur> unsafeCoerce is not specified by a standard though, and some Haskell implementations conceivably might not be able to implement it
20:17:27 <inf-groupoid> Ah, okay!
20:18:11 <geekosaur> inf-groupoid, I don'[t think it's ever *necessary*. there are libraries that use it as an optimization because they know that the way GHC represents things will allow it
20:19:25 <Demos> well it is for when you know something is safe but the type system can not express it
20:19:42 <geekosaur> unsafePerformIO, now there are a few things that require it (notably the FFI, which in the standard "hides" it as unsafeLocalState)
20:19:47 <Demos> although in haskell that is much rarer than in a language like say c++
20:20:12 * tabemann has heard of people using unsafeCoerce as an optimization to get around the expense of pattern-matching newtypes to get at their contained type
20:21:31 <b6> on osx, does -frameworks Cocoa cause ghci to link cocoa-related stuff?
20:21:54 <Demos> can ghci deal with objective-c?
20:22:43 <b6> Demos: well, i made bindings to a library that uses objc on osx. but we get a weird error when we run it in ghci.
20:22:54 <b6> Demos: but i think -framework Cocoa might fix it.
20:22:54 * geekosaur would expect problems, because some things just plain don't work right if you don't have a proper app bundle
20:23:19 <geekosaur> linking frameworks wouldn't help unless you;re getting missing symbols
20:23:39 <geekosaur> you *might* be seeing issues because of how ghci sandboxes things (try -fno-ghci-sandbox)
20:23:46 <b6> well, it seems related to missing symbols. here it is: https://gist.github.com/dagit/5980438/raw/2e92a63135008921040478566e56ac7c0556d116/gistfile1.txt
20:23:58 <b6> -no-ghci-sandbox seems to make no difference. :(
20:24:19 <geekosaur> no, that's not a missing symbol
20:24:28 * Demos can not even get OSX to boot, and when it does he does not have a working keyboard :D
20:24:30 <geekosaur> missing symbols = ghci fails to link your program
20:24:59 <geekosaur> and reports a load failure, so you can't even run your program
20:25:02 <Fuuzetsu> Is there a function ‘foo p x y = if p then Just x else Nothing’ somewhere?
20:25:28 <tabemann> yess
20:25:28 <Fuuzetsu> @pl foo p x y = if p then Just x else Nothing
20:25:29 <lambdabot> foo = (const .) . flip flip Nothing . (. Just) . if'
20:25:30 <geekosaur> (or in this case the import would fail)
20:25:35 <tabemann> :t maybe
20:25:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:25:40 <b6> geekosaur: ok. but everyone seems perplexed why that basic NSAutoreleasePool init functionality is not there.
20:25:46 <tabemann> whoops
20:25:47 <tabemann> that's not it
20:25:51 <Fuuzetsu> nope~
20:26:22 <geekosaur> b6, sounds to me like the objc runtime has not been initialized. I don't know what you need to call to do that though; I'm not an objc programmer
20:26:39 <geekosaur> (similar to, if you want to run haskell from C, you need to call hs_init())
20:26:54 <b6> geekosaur: hmm, ok. thanks for the ideas. i'll check on this.
20:27:44 <tabemann> Fuuzetsu: just checked with Hoogle - there doesn't seem to be anything like what you're looking for
20:30:22 <Gracenotes> unsafeCoerce "\n" :: Maybe Int ==> Just 10
20:30:49 <Gracenotes> unsafeCoerce ""  :: Maybe Int ==> Nothing
20:30:51 <Fuuzetsu> I imagine that I'd get shot on sight for rthat
20:30:59 <Fuuzetsu> for that*
20:31:01 <Gracenotes> and people say safeHead isn't in the standard library!
20:31:04 <shachaf> Quote unsafeCoerce
20:31:07 <shachaf> Er.
20:31:09 <shachaf> @quote unsafeCoerce
20:31:09 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
20:31:10 <geekosaur> heh
20:31:14 <shachaf> @quote unsafeCoerce
20:31:14 <lambdabot> ddarius says: isJust . unsafeCoerce
20:31:20 <shachaf> ?
20:31:26 <Fuuzetsu> :t isJust
20:31:26 <lambdabot> Maybe a -> Bool
20:31:32 <shachaf> Hmm.
20:31:36 <shachaf> @quote unsafeCoerce
20:31:36 <lambdabot> roconnor says: unsafeCoerce isn't even safe
20:31:38 <shachaf> @quote unsafeCoerce
20:31:38 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
20:31:40 <shachaf> @quote unsafeCoerce
20:31:40 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
20:31:48 <shachaf> Sigh. Too many unsafeCoerce quotes.
20:31:50 <Gracenotes> so, you see: safeHead = unsafeCoerce
20:32:25 <Fuuzetsu> I'll add that right to my list along with ‘safeHead = id’
20:32:41 <slack1256> so unsafeCoerce is a tool for generalisation?
20:32:43 <shachaf> id isn't right.
20:32:50 <slack1256> cool I got to tell palmer
20:34:04 <Gracenotes> it is the closest thing Haskell has to checking referential equality
20:34:38 <shachaf> @quote unsafeCoerce
20:34:38 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
20:34:41 <shachaf> @quote unsafeCoerce
20:34:42 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
20:34:45 <shachaf> Hmph.
20:35:12 <shachaf> unsafeCoerce isJust isn't good GC-wise, by the way.
20:35:17 <geekosaur> reallyUnsafePointerEq :p
20:35:40 <Gracenotes> people talk about space leaks in Haskell, but maybe you also want a memory leak
20:35:57 <Fuuzetsu> I bet we'd still see it if it was called horriblyUnsafeThinkOfTheChildren
20:36:00 <roconnor> putEnv leaks memory
20:36:05 <roconnor> stupid posix
20:36:24 <Gracenotes> this is one of the reasons why it's hard to write a GC for C
20:36:29 <Gracenotes> a precise one
20:36:35 <blume> what's the best way to map my integer function onto a grid?
20:36:38 <inf-groupoid> What does putEnv do?
20:37:02 <tabemann> inf-groupoid: it sets an environment variable
20:37:07 <inf-groupoid> Ah!
20:37:10 <Gracenotes> You can easily use DWARF to introspect your own code, sure, but imagine a way to manipulate memory ownership and libc probably does it.
20:37:51 <geekosaur> adds a string to the process environment. but it allocates memory for the string, in case you're using a C stack variable; if you change or unset that variable, that allocated memory is leaked
20:38:06 <Gracenotes> So you have to be very selective about which mallocs from libc you track and which you don't
20:38:20 <inf-groupoid> Whoa, sounds like fun.
20:39:56 <tabemann> hmm... they really should have implemented unsafeCoerce as, say, class Coerceable a b where coerce :: a -> b, and only made pairs that were actually safe to coerce members of that
20:40:35 <Gracenotes> what's "safe"?
20:40:44 <shachaf> Gracenotes: a ~ b
20:42:11 <Gracenotes> that seems neither necessary nor sufficient
20:42:46 <Gracenotes> although newtype wrapping/unwrapping is a good use case of unsafeCoerce
20:42:49 <Gracenotes> in GHC
20:43:05 <tabemann> well, you could have had GHC automatically add newtypes as instances of Coerceable
20:43:20 <tabemann> or at least allow it with deriving
20:43:43 <inf-groupoid> How can deriving even work for multiparameter type classes?
20:44:35 <shachaf> unsafeCoerce :: Is a b
20:45:11 <tabemann> well... you could add "deriving" to the newtype, and have it automatically generate instance Coerceable MyOriginalType MyNewType where ... and instance Coerceable MyNewType MyOriginalType where ...; of course, that would kind of modify how deriving works at a language level...
20:46:37 <inf-groupoid> Doesn't newtype exist primarily so that you can have morally multiple instances of the same type class for the same type?
20:47:21 <danharaj> It also exists so you can give instances to some types that otherwise would be impossible to give instances to.
20:47:28 <inf-groupoid> I have no idea how this Coerceable thing would interact with code that relies on these multiple instances for "morally" the same type.
20:47:47 <slack1256> newtype (as previously said) is just a type with a coat, a mask, a fedora and a sign that says "You haven't seen me before"
20:48:38 <tabemann> inf-groupoid: it would allow you to automatically convert between sets of instances while maintaining the same underlying representation without the expense of pattern matching
20:50:28 <tabemann> and the advantage of Coerceable is you *know* that what you
20:50:36 <tabemann> 're doing is safe, unlike with unsafeCoerce
20:50:54 <tabemann> where if, let's say a type pair really *isn't* a newtype-contained type pair, oh fuck
20:51:00 <tabemann> if you're using unsafeCoerce
20:51:01 <inf-groupoid> tabemann: Sure, it is indeed superior to unsafeCoerce from a safety point of view.
20:51:40 <NemesisD> anyone know if it is feasible to compile a 32 bit executable on a 64 bit system? i tried staticly linking my executable but once I got it to production it just hangs. strace shows it in a tight loop stuck between read() and fork()
20:52:27 <tabemann> inf-groupoid: and with proper support from GHC, it can be equivalent performance-wise as well
20:52:59 <dmj> NemesisD: Are you able to use a 32-bit VM? Like compile in virtualbox then deply?
20:53:55 <dolio> I'm not sure what is hoped to be gained by Coercible.
20:54:02 <NemesisD> dmj: well my current build process is to deploy code to production there, this is only a win if it is less of a pain than that. and my dev box is a bit hard disk constrained because of the ssds
20:54:16 <ericmoritz> I've got the basic structure of my program done but I'm sure it isn't very idiomatic: https://github.com/ericmoritz/deps/blob/develop/src/DepTool.hs
20:54:31 <dolio> Using newtype wrappers don't cost anything, they become coercions in the backend.
20:54:59 <dolio> What is costly is mapping with newtype (un)wrappers and such. But mapping with 'safeCoerce' is just as expensive.
20:55:24 <dolio> And it is not safe to have a coerce that works inside of arbitrary containers.
20:55:41 <dolio> Or, under arbitrary type functions, that is.
20:57:33 <tabemann> the main thing that would be *gained* by Coercible is safety
20:57:35 <dmj> NemesisD: Why not spin up another ec2 instance as a build box and compile there? Then git push to your production repo.
20:57:58 <dolio> Gained over what?
20:58:03 <tabemann> unsafeCoerce
20:58:09 <dolio> In what situations?
20:58:50 <tabemann> well, by restricting the situations in which coercion can be used to those in which it is known to be safe, thus disallowing unsafe cases
20:58:52 <NemesisD> dmj: i've never done the ec2 thing. i wonder how reliable/scriptable that is and if people have images for 32 bit oses with recent ghc
20:59:46 <tabemann> of course, one can argue that coercion should simply not be allowed in the first place
20:59:50 <NemesisD> dmj: the more remote stuff i have to do the less reliable/slower my build system is going to be, though i understand if there's just no way to build it on my dev box
21:00:06 <inf-groupoid> tabemann: Well, GHC's rather weak module system is a problem in this sense. Many times have I wanted to say "types a and b are equal, but only this module shall be aware".
21:00:14 <inf-groupoid> s/GHC's/Haskell's/
21:00:38 <inf-groupoid> Type class instances are global.
21:00:43 <tabemann> yeah
21:01:12 <tabemann> Coerceable wouldn't help there
21:01:46 <dmj> NemesisD: It's worked for me in the past. Setup snap on an ubuntu instance. Just yum install, sudo-apt get, or pacman -s, depending on your distro. The free tiers give you 8GB of space.
21:02:27 <dmj> NemesisD: AMI ID: "ami-5a896233" has happstack and haskell-platform 2010-07-10
21:02:35 <NemesisD> dmj: i wonder if that FP Complete haskell cloud ide thing will have a cloud build system
21:02:37 <tabemann> s/Coerceable/Coercible
21:02:45 <NemesisD> i have no interest in the editor per se
21:03:19 <NemesisD> dmj: i'll hunt around for 2013.2.0.0
21:04:12 <dmj> NemesisD: I can try the FPComplete cloud ide. Is this a webapp?
21:04:51 <NemesisD> dmj: nah. just a command line app
21:06:23 <dmj> NemesisD: It looks like the FPComplete IDE lets you download a tarball with the binary in it. Unsure what platform, doesn't run on Darwin.
21:12:20 <dmj> NemesisD: You should try to FP Complete IDE, it actually lets you deploy apps as background workers to an ec2 instance. Not sure what your application does though.
21:16:18 <ChongLi> anyone here tried flycheck for emacs?
21:16:52 <ChongLi> if so, how do I get it to use my cabal-dev pacakge archive?
21:22:25 <dmj> ChongLi: I use emacs and ghc-mod
21:22:56 <dmj> sometimes stuff lights up red and blue
21:26:31 <nerrz> Hi, I am getting this error when I try to load a simple hello world like program that I compiled with gcc: *** Exception: readProcess: /home/joejev/#.tempsnip  (exit 4): failed
21:26:44 <nerrz> however, when I just do ./ it works
21:26:57 <dmj> nerrz: With gcc or ghc?
21:27:21 <nerrz> the program #.tempsnips is written in c
21:27:28 <dmj> ChongLi: try flymake-haskell-multi-load if its installed
21:28:00 <nerrz> what's that?
21:28:13 <dmj> nerrz: just some compiler
21:29:14 <dmj> nerrz: In unix when you prefix with a period, it will give you access to all binary files that can be executed. So, "./a.out" should execute your program in C.
21:29:53 <dmj> nerrz: in the respective folder that is
21:30:29 <nerrz> what I mean is that I can run the program from terminal fine, but when I try to open it in haskell with the readProcess function it doesn't work and returns that error
21:31:14 <dmj> nerrz: Can you post your code
21:31:47 <dmj> also, you should be compiling with ghc, its haskell's compiler not gcc
21:33:21 <nerrz> sec
21:33:40 <nerrz> http://pastebin.com/q6rvAjLz
21:33:41 <mauke> The paste q6rvAjLz has been copied to http://lpaste.net/90829
21:33:45 <geekosaur> I think they meant the thing they are trying to run is gcc
21:34:55 <nerrz> yeah, I am using this as part of a little program that saves snippets of code to a searchable library, and I am working on implementing a way to execute stand alone functions
21:35:34 <nerrz> like, I have an exec_haskell working, but I am trying to get one for c for my friend, but I don't know anything about c
21:38:04 <NemesisD> dmj: not a big IDE fan
21:38:50 <dmj> NemesisD: ha, me neither, and that's after using Visual Studio for 3+ years.
21:39:02 <NemesisD> my condolences, lol
21:41:12 <NemesisD> i've done pretty well in my ruby day job on vim and tmux. i've been doing my best to rig a sane dev environment without resorting to IDEs
21:41:28 <NemesisD> but archlinux doesn't exactly reflect a stable server environment
21:43:13 <zomg> NemesisD: if you work with Ruby stuff, give RubyMine a shot. They got vim keybindings on it too :)
21:43:24 <dmj> NemesisD: Yea, I'd trade pacman for homebrew anyday though. Spent a whole weekend trying to get arch working on my macbook. That install was pretty painful, learned a lot though.
21:44:31 <NemesisD> zomg: you troll
21:45:01 <NemesisD> my coworker refused to use our dev environment when we hired him and insisted on using windows and ruby mine, drove me nuts to pair with him
21:45:41 <Demos> dude arch is a much better install than OSX, just saying
21:45:47 <joelteon> w0w vim keybindings
21:46:03 <joelteon> does it read my vimrc and plugins
21:46:13 <dmj> Demos: Like easier to install? Or just an overrall better OS?
21:46:29 <Demos> easier to install, all OSs suck
21:46:31 <joelteon> heh, I'm sure arch is an easier install than OSX, you don't install OSX
21:46:42 <joelteon> arch only took me 2-3 days the first time
21:46:57 <Demos> with macOS you have an XML based init system and non-deterministic(seemingly) driver loading
21:47:44 <Demos> and a broken ACPI implementation but that is beside the point
21:48:14 <dmj> Demos, OSX? .. Are you installing on Apple Hardware?
21:48:30 <Demos> err... almost
21:48:37 <joelteon> yeah, hackintosh is hard
21:48:43 <joelteon> and i'm pretty sure they broke ACPI on purpose
21:49:09 <Demos> well it would be eaiser if anyone who posted questions, answers, or guides spoke English in whole sentences.
21:49:59 <Demos> I bet they were just lazy
21:50:03 <roboguy_> nerrz: did gcc compile it without errors
21:50:07 <joelteon> yeah
21:50:11 <nerrz> yes
21:50:18 <joelteon> Demos: i prefer to rely on apple to install OSX
21:50:18 <nerrz> it runs from terminal fine
21:50:39 <dmj> nerrz: If you're just trying to compile C code, use gcc "filename.c" -o "binaryname". Is your intention to put a wrapper around the C compiler?
21:51:45 <nerrz> system $ "gcc " ++ temp_c ++ " -o" ++ temp_proc ++ " -lm" that is what I have where tempproc and temp_c are FilePaths
21:51:48 <nerrz> and that works fine
21:51:52 <nerrz> it fails on the next line
21:51:55 <nerrz> where
21:52:02 <Demos> joelteon, hehe yeah, OSX is certainly modern, in good ways and bad
21:52:09 <joelteon> yeah, i agree
21:52:22 <joelteon> I'd love to be able to build my own computer and put OSX on it, but I just know it would be a mess
21:52:39 <Demos> Arch actually /feels/ more modern, with the exception of like termcap and X
21:52:48 <johnw> Demos: this is all rather off-topic for the channel
21:52:59 <joelteon> oh yeah whoops
21:53:00 <Demos> he started it :D
21:53:08 <johnw> aha
21:53:08 <joelteon> #haskell-blah
21:53:11 <Demos> why dont we move this to #MacOSX
21:53:16 <joelteon> i'm in #macdev
21:53:22 <joelteon> not adding another buffer to the list
21:58:53 <roboguy_> nerrz: try putting a return 0; in
21:58:59 <roboguy_> nerrz: if you don't have one
21:59:05 <nerrz> okay
21:59:21 <roboguy_> for some reason it didn't work for me until I did that
21:59:39 <nerrz> then it works?
21:59:41 <geekosaur> that would make sense
21:59:50 <geekosaur> so it throws an exception on a non-zero exit code
21:59:55 <roboguy_> well, I got exit code 10 before I did that and it seems to work now
22:00:10 <geekosaur> you aren't setting an exit code, for historical reasons you get something random (whatever happens to be on the stack)
22:00:20 <geekosaur> C is ... not a very smart language
22:00:35 <roboguy_> incidentally, you should probably have "int main()" instead of "main()"
22:00:42 <roboguy_> I think they made the implicit int invalid in C99
22:00:55 <roboguy_> probably won't make any practical difference though
22:01:31 <mauke> C99 added implicit return 0 from main
22:01:35 <nerrz> thanks
22:01:43 <roboguy_> did it work?
22:02:38 <roboguy_> mauke: I think you have to explicitly ask gcc to use c99 with -std=c99
22:03:58 <dmj> is Cale around?
22:04:31 <dmj> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
22:06:38 <slack1256> @seen Cale
22:06:39 <lambdabot> Ca13
22:06:43 <slack1256> @seen cale
22:06:43 <lambdabot> (4|E
22:06:49 <Cale> hi
22:07:16 <dmj> Hi Cale! Was really interested in reading your article on monad transformers, but I can't seem to find it
22:07:19 <Cale> dmj: yep, I don't have that article anymore, but apparently it's in the wayback machine
22:07:45 <Cale> http://web.archive.org/web/20070224024824/http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
22:07:55 <Cale> The hard drive that my webserver was on failed.
22:08:25 <Cale> and I can't boot from it, and I don't have an appropriate adapter to try plugging it into any of my other computers, because it's old.
22:09:12 <Cale> Perhaps I should transplant its text to the Haskell Wiki
22:09:44 <dmj> Oh, failed hard drives are no good :(
22:10:22 <dmj> Cale: yea, the only other articles are the step-by-step guide, RWH, and Dan Piponi's article.
22:11:07 <Cale> My article is more about how to use them correctly if you're going to use them at all
22:12:25 <dmj> Yea, I'm still trying to get a good feel for when to use them. It seem they'd be perfect for writing compilers.
22:14:10 <dmj> Cale: Do you use them a lot day-to-day?
22:14:32 <Cale> I use monads which were constructed from them in my daily work.
22:15:03 <Cale> But, like I suggest in the article, I don't have to know that the monads that I'm using were constructed with a monad transformer.
22:20:35 <johnw> dmj: you mean, when to use monad transformers?
22:21:10 <dmj> johnw: yes, when to use them
22:21:28 <johnw> well, right now maybe 95% of all the code I write is in one monad transformer or another, so I'd say they're extremely useful
22:21:36 <Gracenotes> it's like, when do you use monads?
22:21:49 <dmj> johnw: or good canonical examples of them being used
22:21:58 <slack1256> even the "basic" monads are transformers like State
22:21:59 <Gracenotes> but if you buy into one, why not use a couple at once
22:22:22 <Cale> I think monad transformers *might* be slightly overused though.
22:22:37 <johnw> dmj: ResourceT is a very handy transformer that lets you deal more sanely with freeing resources when using code in some other Monad
22:22:40 <Cale> When I wrote the article, they were definitely overused.
22:23:34 <Cale> If you're transforming IO with something like ReaderT or StateT, you really have to ask yourself if it's something you actually want to be doing.
22:23:56 <Gracenotes> people use computational abstractions other than monads these days
22:24:32 <Cale> You might avoid a certain amount of parameter passing, at the cost of being forced to liftIO, and IO itself already has unbounded amounts of statefulness.
22:24:38 <johnw> I find EitherT handy too
22:25:31 <johnw> Cale: I don't use Monad transformers all that much where the base monad is fixed.  It more when we want to write code that ranges over "any base Monad which supports X"
22:26:11 <lispy> I think monad transformers are mostly for rapid prototyping.
22:26:21 <lispy> For anything where I know what I want they add a lot of inefficiency
22:26:30 <Gracenotes> A lot of libraries are also of the form "My job is to run X, provide me an X."
22:26:42 <johnw> so, not so much ReaderT r IO a, but rather Monad m => ReaderT r m a, or in some cases MonadIO m => ReaderT r m a.  It's more about letting the caller decide if he wants his Monad under mine, since simply lifting might not work
22:26:48 <mgsloan> Yeah, the inefficiency bugs me.  It'd be neat if newtype deriving could actually create specialized / inlined instances
22:26:59 <Gracenotes> Monads are an easy thing to create and combine. Plus, you can unmtl everything and implement it yourself, though that's not particularly fun.
22:27:05 <Cale> johnw: Why not just r -> m a ?
22:27:26 <johnw> Cale: I may not have access to his code to ensure that the r is passed around
22:27:44 <johnw> Cale: but I agree, they shouldn't be used as a default setting
22:28:10 <mgsloan> better yet would be to statically find opportunities for instance dictionary specialization, but doing it for newtypes seems like a good start.  Maybe this already happens to some extent and I just don't realize it?
22:28:20 <johnw> in gitlib, for example, all the backends use a ReaderT to maintain information like the path to the repository being used
22:28:41 <mgsloan> It seems like if this were happening then there wouldn't really be overhead for using monad transformers
22:29:40 <johnw> Cale: a lot of why I use monad transformers has to do with Yesod
22:30:36 <johnw> originally gitlib didn't use any transformers at all, but there were cases where it became difficult to use in Yesod code, because you couldn't "lift" to run gitlib, and then lift inside gitlib to access the Yesod environment (which had been lifted away).  It made for cumbersome code, which a transformer fixed quite nicely
22:30:45 <joelteon> yesod is awesome
22:31:55 <johnw> instead, via transformers you get to pick your base monad, and I'll run on top of it, allowing you to lift back into the surrounding environment anytime you need to
22:32:01 <Gracenotes> also in theory, it's a stack of functors, but try manipulating the stack in any way other than automatically using typeclasses... a bit all-or-nothing...
22:34:21 <slack1256> So what is the alternative to transformers when you really care about performance (profiling revealed)?
22:34:30 <slack1256> Write your own monad?
22:34:43 <Cale> That works
22:34:44 <slack1256> Well that doesn't seem to bad now and then.
22:34:47 <Cale> It's not really about performance
22:34:57 <Cale> Though transformers *do* tend to harm it
22:35:12 <slack1256> That is the only problem I see with the use of transformers.
22:35:20 * slack1256 recheck the discussion above
22:35:23 <slack1256> *rechecks
22:35:45 <Cale> The main thing I dislike about monad transformers is that some of them buy you very little
22:35:48 <mgsloan> Yeah, it seems to boil down to manual inlining.  Which really shouldn't be too bad.  It does puzzle me that such manual inlining would be necessary though
22:35:49 <johnw> Cale: what is the nature of the performance degradation, typically?
22:36:16 <mgsloan> (it's not so bad because the monad instances involved are usually trivial)
22:36:37 <Hafydd> @quote onions
22:36:37 <lambdabot> Japsu says: data Ogre = Ogre [Layer] -- onions have layers! ogres have layers!
22:36:53 <slack1256> heh
22:37:01 <Hafydd> @quote transformers
22:37:01 <lambdabot> BMeph says: The Id monad is used to express subliminal desires to make Monad Transformers act like Monads... ;p
22:37:09 <Hafydd> Okay.
22:37:11 <Hafydd> "Monad transformers are like onions. At first, they make you cry but then you learn to appreciate them."
22:45:00 <dmj> Anyone have any good ideas for a final project in haskell? I was thinking a web server, even if it has been beaten to death, think it would be relevant and would be good for learning.
22:46:25 <shachaf> A final project? That sounds a bit worrying.
22:46:41 <k0001> It is the last project, ever.
22:46:45 <mapreduce> A program that cures your terminal illness might be useful.
22:46:52 <DrSyzygy_> dmj: You could always try writing an http/2 server. ;-)
22:47:16 <dmj> mapreduce: hahaha :)
22:47:19 <dmj> shachaf: why?
22:47:35 <shachaf> What happens afterwards?
22:47:48 <shachaf> No more Haskell? No more projects?
22:48:08 <joelteon> @faq can haskell cure cancer?
22:48:09 <lambdabot> The answer is: Yes! Haskell can do that.
22:48:19 <bb010g> Found a bug in lambdabot: it responds to @pong with pong, not ping.
22:48:21 <bb010g> @pong
22:48:22 <lambdabot> pong
22:49:04 <shachaf> Not a bug.
22:49:27 <shachaf> Hmm, I suppose every illness leads to a terminal illness, but probably in more than one way.
22:49:31 <Cale> shachaf: He's on death row, it's like a last meal.
22:49:42 <shachaf> Perhaps they should call it "weakly terminal illness".
22:50:14 <dmj> shachaf: It gets refined hopefully :)
22:50:30 <dmj> shachaf: No more haskell? How dare you
22:50:52 <shachaf> I'm confused.
22:52:50 <dmj> shachaf: I'm confused, why does a final project sound worrisome?
22:55:29 <Cale> A weakly terminal illness is an illness which every other illness leads to in a way which is unique up to coherent illness iso-2-morphisms.
22:58:15 <Gracenotes> "Unable to deal with the grim inevitability of his mortality, he turned to category theory to escape."
22:58:56 <Gracenotes> "He had a very elegant funeral and was mourned abstractly."
23:00:37 <johnw> in the category of life, death is a final object
23:01:10 <Gracenotes> Some would argue life is isomorphic to a 1-category
23:01:10 <johnw> i mean, terminal
23:02:04 <Gracenotes> ashes to ashes
23:09:14 <dmj> DrSyzygy_: an http2 server, hahaa
23:09:14 <dmj>  
23:09:14 <dmj>  
23:09:32 <juhp> how to use cpp with ghci?
23:10:39 <Cale> {-# LANGUAGE CPP #-}
23:10:43 <Cale> at the top of your file
23:11:18 <Cale> Or ghci -XCPP should work
23:11:26 <Cale> but mostly the language pragma
23:12:25 <Rotten194> Can someone help me with a weird problem?
23:13:03 <juhp> Cale, thanks but I still get:      error: missing binary operator before token "("
23:13:03 <juhp>      #if MIN_VERSION_Cabal(1,16,0)
23:13:22 <juhp> maybe I should rename the file to .hsc?
23:13:25 <johnw> Rotten194: just ask
23:14:12 <juhp> (funnily enough I get the exact same problem with fpc ide;)
23:14:21 <Rotten194> I have the {-# LANGUAGE NoMonomorphismRestriction #-} in my file, but I'm still getting the classic `No instance for (Stream s1 m1 Char)` from some functions
23:14:46 <Cale> Rotten194: That's not *necessarily* an MR issue...
23:15:03 <johnw> Rotten194: can you show us code and the full error?
23:15:06 <Rotten194> Yeah, but this code should compile fine which is why I suspected it
23:15:13 <johnw> see the topic for the paste server's url
23:15:14 <Rotten194> yeah one sec
23:15:39 <juhp> nope that does work
23:15:46 <juhp> (doesn't)
23:16:05 <ski> hm, `hpaste.org' is dead ?
23:16:31 <Rotten194> http://lpaste.net/90830 (it's not the cleanest code, but I'm just trying to get it working atm)
23:18:52 <Rotten194> Oh sorry, I cut off part of the error, it's the same for where assmSign is called as well (but assmDigits is fine)
23:36:04 <ski> (btw, `number' is unused in the definition of `term')
