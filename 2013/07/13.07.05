00:00:58 <MasseR> fragamus: The command or the algorithm?
00:01:08 <fragamus> command
00:01:11 <MasseR> @pl
00:01:12 <lambdabot> (line 1, column 1):
00:01:12 <lambdabot> unexpected end of input
00:01:12 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:01:15 <MasseR> 'whoops'
00:01:18 <fragamus> thanks
00:01:20 <Kinnison> elliott: But won't I run the risk of racing readTVar >>= mutate >>= writeTVar if I'm in multiple threads?
00:01:29 <fragamus> @pl ((filter (\x->3 == length x)) . (inits <=< tails))
00:01:29 <lambdabot> filter ((3 ==) . length) . (inits <=< tails)
00:01:37 <MasseR> Kinnison: That's the atomicity doing the work for you
00:01:40 <fragamus> woo hoo i love this thing
00:01:43 <elliott> Kinnison: no... that's why you wrap things in "atomically"
00:01:48 <elliott> Kinnison: perhaps you're thinking of IORef vs. MVar
00:01:52 <Kinnison> elliott: Hmm, someting new to learn.
00:01:57 * Kinnison looks up atomically
00:02:04 <elliott> transactions are the whole point of STM/TVars :)
00:02:28 * Kinnison sees where he was confused
00:02:38 * Kinnison was seeing 'STM' and thinking 'ST'
00:03:45 * Kinnison decides to take a side-track to learn STM it looks very useful
00:03:46 <Kinnison> thanks elliott
00:04:10 <elliott> :)
00:04:14 <elliott> it's pretty cool.
00:05:42 * hackagebot posix-paths 0.1.0.0 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.1.0.0 (JohnLato)
00:06:23 <johnw> Kinnison: STM is well worth the time
00:06:30 <johnw> it's at once interesting, useful, and fun
00:07:11 <johnw> i remember the countless hours I spent debugging libpthread code, and it makes me cry in comparison
00:08:07 <Kinnison> I, generally, refuse to use threads.  I'm looking forward to learning threading in a language which doesn't fill me with deadlock hate
00:14:57 <hpaste> knrafto pasted “applyMaybe” at http://paste.tryhaskell.org/90688
00:15:27 <knrafto> can I write this function without pattern matching? http://paste.tryhaskell.org/90688
00:16:03 <MasseR> knrafto: There's probably pattern matching at some level
00:16:20 <MasseR> But yes, yes you can
00:16:25 <knrafto> I mean, with applicative or traversable or something more general
00:17:25 <adnap> > (+) <$> (Just 3) <*> Nothing
00:17:25 <lambdabot>   Nothing
00:17:33 <adnap> > (+) <$> (Just 3) <*> (Just 4)
00:17:34 <lambdabot>   Just 7
00:17:46 <adnap> Oh, that's not what you want
00:18:09 <knrafto> right, i'd like applyMaybe (+) (Just 3) Nothing == Just 3
00:18:54 <MasseR> Maybe something with MonadPlus? I'm not too certain myself anymore
00:19:02 <johnw> > let x = Just 3; y = Just 4 in ((+) <$> x <*> y) <|> x <|> y
00:19:03 <lambdabot>   Just 7
00:19:06 <johnw> > let x = Nothing; y = Just 4 in ((+) <$> x <*> y) <|> x <|> y
00:19:07 <lambdabot>   Just 4
00:19:12 <johnw> > let x = Just 3; y = Nothing in ((+) <$> x <*> y) <|> x <|> y
00:19:13 <lambdabot>   Just 3
00:19:32 <johnw> just needs Alternative
00:19:47 <knrafto> nice, but i'd hardly say that's elegant. I'll probably stick to pattern matching
00:19:49 <adnap> Cool. I've never heard of that
00:20:22 <johnw> knrafto: well, you can always make a helper function
00:20:38 <johnw> knrafto: f g x y = liftA2 g x y <|> x <|> y
00:21:23 <knrafto> johnw: cool, thank you
00:23:04 <adnap> > many (Just 3)
00:23:07 <lambdabot>   mueval-core: Time limit exceeded
00:23:22 <adnap> > some (Just 3)
00:23:26 <lambdabot>   mueval-core: Time limit exceeded
00:23:33 <adnap> > some Nothing
00:23:34 <lambdabot>   Nothing
00:24:12 <adnap> I don't get it
00:24:22 <johnw> some and many repeat the argument
00:24:29 <adnap> What's the point of that?
00:24:30 <johnw> so, since Just 3 always succeeds, it never ends
00:24:46 <johnw> normally you are invoking a function
00:25:03 <johnw> they make a lot more sense when you're writing parsers
00:25:10 <adnap> Ohh
00:25:19 <adnap> I have used these with Parsec before
00:25:25 <johnw> yep
00:25:34 <adnap> I don't really understand them though
00:25:43 <adnap> They're not making any sense right now
00:25:48 <johnw> the parsers?
00:25:58 <adnap> "some" and "many"
00:27:16 <johnw> many (char 'b')
00:27:29 <johnw> continues running the parser (char 'b') until the character isn't b
00:27:59 <adnap> So, it only makes sense when you're doing IO, basically
00:28:18 <johnw> i can't think of a case where you'd ever use many with Maybe
00:28:35 <adnap> It doesn't make sense if the value of the applicative isn't changing
00:28:37 <johnw> but it can make sense with STM, for example
00:28:46 <johnw> keep running a transaction until it retries
00:30:02 <elliott> adnap: well, there's no IO involved in the parser example.
00:30:04 <bartavelle> adnap, your parser can be pure, and many will make perfect sense in that case
00:30:06 <elliott> depending on your definition of IO.
00:30:18 <adnap> The parser has to read input from somewhere
00:30:27 <bartavelle> fmap parse (readFile x)
00:30:41 <bartavelle> your parser can work on any stream
00:30:46 <elliott> adnap: it can read from a pure string.
00:31:18 <adnap> Okay. I don't understand how the value of the applicative changes for a parser.
00:32:16 <adnap> I am imagining that somehow many changes an applicative and eventually that results in a "bad" value which stops evaluation
00:32:22 <adnap> That's all I understand
00:32:26 <johnw> adnap: it's changing within a stateful environment; state can be modelled without IO
00:32:38 <adnap> Okay
00:32:51 <johnw> it time you run the parser, it parses the next chunk of input
00:32:52 <adnap> I just don't understand anymore. I'll just leave it alone for now
00:33:01 <johnw> the act of parsing moves the state of the input cursor forward
00:33:04 <johnw> :)
00:33:07 <adnap> Right
00:33:17 <adnap> I just don't understand specifically what happens
00:33:28 <adnap> I don't understand the implementation
00:34:52 <johnw> if you really want to know, build your own Parser alternative based on State
00:34:59 <johnw> it shouldn't be very difficult, actually
00:35:05 <adnap> I want to understand lens
00:35:15 <johnw> i'd do the parser thing first, WAY easier
00:35:16 <adnap> I'm not going to get distracted
00:35:27 <johnw> yeah, but it pays to build on a solid foundation
00:35:46 <johnw> if you don't grasp Alternative yet, going after lens may be frustrating
00:35:53 <adnap> Why?
00:36:05 <adnap> I don't think I'm incapable of understanding Alternative
00:36:05 <johnw> because Alternative is much more fundamental
00:36:10 <johnw> not ata ll
00:36:16 <adnap> Fundamental to what?
00:36:16 <johnw> you just need to work with it for a little while
00:36:24 <johnw> it's a more fundamental concept than lenses
00:36:27 <adnap> You said it's mostly used in parsers
00:36:41 <adnap> And I'm not interested specifically in lenses
00:36:44 <adnap> I'm interested in lens
00:36:48 <adnap> (the package)
00:37:17 <johnw> i think you're putting the cart before the horse, but that's up to you
00:37:19 <elliott> well, some/many are pretty wacky.
00:37:23 <elliott> they shouldn't be in the Alternative class.
00:37:36 <johnw> are they in the class?  I thought they were just combinators
00:37:38 <adnap> If I don't apply what I learn, I forget it
00:37:43 <killy9999> how can I get a value out of Just inside IO monad?
00:37:54 <adnap> From what you said, I probably wont apply "some" and "many"
00:37:56 <johnw> killy9999: you can use fmap fromMaybe
00:38:02 <Gracenotes> F = ma. Now, what is special relativity?
00:38:14 <CaptainK> how do I make functions access variables inside main?
00:38:20 <johnw> Gracenotes: is that a Haskell question?
00:38:25 <Gracenotes> no :p
00:38:29 <alpounet> no, he was joking
00:38:35 <killy9999> johnw: thanks
00:38:43 <alpounet> an illustration of putting the cart before the horse
00:38:47 <johnw> ah
00:38:49 <Gracenotes> lens is kind of the opposite of application, too; it's abstraction
00:39:17 <adnap> Lenses is better than using record syntax; I can apply it right away
00:39:19 <adnap> *are
00:39:26 <adnap> *them
00:39:44 <Gracenotes> it is true you can use it as a client without understanding its internals. some of the combinators it provides depends a bit on the structure of typeclasses, at the corners
00:40:17 <Gracenotes> so worst case, just read a bunch of examples and you'll learn it, in the same sense that someone who reads a lot of C++ could write C++ code that compiled :)
00:40:20 <adnap> So cague...
00:40:25 <adnap> *vague
00:40:37 <adnap> I'm tired of being talked down to
00:40:44 <Gracenotes> okay, I am sorry about that.
00:40:55 <johnw> adnap: I sincerely apologize if I gave you that impression
00:41:11 <adnap> johnw: You want me to learn Alternative
00:41:12 <Gracenotes> It do still stand by my advice that using lens is as simple as seeing it being used and replicating that, though.
00:41:12 <adnap> Fine
00:41:21 <CaptainK> I'm passing variables through the function definition, but I have some variables that need pass everything and not be mapped, how do you access global variables inside a function?
00:41:24 <johnw> learn what interests you!  don't listen to me
00:41:33 <adnap> Sure, go back on what you said
00:42:00 <adnap> I'm sorry for being stubborn
00:42:04 <Gracenotes> CaptainK: there are no mutable global variables in Haskell
00:42:06 <Cale> CaptainK: I don't understand your question. Whatever variables are in scope are in scope.
00:42:23 <Gracenotes> at least not if you don't make a deal with the devil.
00:42:26 <adnap> Gracenotes: There's IORef's
00:42:27 <Cale> CaptainK: If you want to pass values to a function, they need to be parameters to it.
00:42:29 <Lethalman> CaptainK, maybe using partial function application or the reader monad
00:42:37 <Gracenotes> you need unsafePerformIO
00:42:47 <Cale> Wait, why are you guys talking about unsafePerformIO?
00:42:58 <Gracenotes> ...to use IORefs I mean
00:43:06 <Gracenotes> as globvars
00:43:07 <Cale> or IORefs, for that matter
00:43:16 <adnap> Now I don't even know what to learn...
00:43:16 <Cale> "I have some variables that need pass everything and not be mapped" -- I have no idea what this means
00:43:19 <Gracenotes> yeah, it's not a great idea
00:43:28 <Gracenotes> except when it's necessary, of course
00:43:46 <Cale> But CaptainK's question doesn't suggest that he's even talking about mutable state.
00:44:02 <Gracenotes> well, not neccessarily mutable state, but just... variable state.
00:44:21 <Gracenotes> I was distracted perhaps by the mention of global variables.
00:44:26 * Gracenotes fades away
00:44:28 <CaptainK> let processedWords = map stuff words
00:44:53 <CaptainK> words is feed from a list
00:44:59 <Cale> CaptainK: Perhaps you want 'stuff' to be a function which makes use of other values in scope?
00:45:07 <adnap> You don't need unsafePerformIO to use IORef's
00:45:10 <CaptainK> yes
00:45:18 <Cale> CaptainK: Just use that stuff :)
00:45:26 <Cale> well, use those values :P
00:45:33 <CaptainK> no not inside the scope, outside it
00:45:44 <Gracenotes> adnap: http://www.haskell.org/haskellwiki/Top_level_mutable_state
00:45:50 <Cale> If they're not in scope, then pass them as parameters so that they are
00:45:53 <CaptainK> and one that is a complete list not just mapped
00:46:19 <CaptainK> Cale: yes that is what I want, but one variable is an entire list
00:46:24 <Cale> that's okay
00:46:32 <Cale> You can pass a list as a parameter
00:46:40 <adnap> What Cale said
00:46:42 <CaptainK> don't want it being mapped,  but the other variable is to be mapped
00:46:47 <CaptainK> one word at a time
00:46:48 <Cale> Yeah, that's fine
00:46:49 <adnap> That's what I was imagining
00:46:52 <Cale> ...
00:46:59 <Cale> Maybe you should show us your program
00:47:12 <adnap> Why wouldn't you pass the IORef?
00:47:15 <CaptainK> let processedWords = map stuff words bigasswordlistnottomap
00:47:18 <Cale> no IORefs
00:47:23 <johnw> I think we want to avoid talking about IORefs here
00:47:32 <adnap> Censorship!
00:47:39 <Gracenotes> I think there was a separate conversation that split off here :p
00:47:39 <Cale> CaptainK: map (stuff bigasswordlistnottomap) words
00:48:05 <adnap> Gracenotes: Well, you linked me to some page where the idea is to have an IORef that you don't pass. WTF
00:48:10 <Gracenotes> adnap: you would in most sane circumstances, although if you want global variables, it's gotta be top level.
00:48:23 <CaptainK> ah ok, so pass it  inside the ()
00:48:30 <johnw> adnap: her link was a trick for when you truly need a global variable
00:48:37 <adnap> Why not just use functions
00:48:40 <Cale> CaptainK: Or if "stuff" was a lambda, just use it
00:48:40 <johnw> a trick I think I've used twice in total
00:48:42 <adnap> "global" functions
00:48:56 <johnw> sometimes you don't want to thread a certain variable through your whole program
00:49:03 <adnap> Yeah
00:49:07 <adnap> You can just define a function
00:49:14 <johnw> like, I used a global variable this week for a queue that accumulates debug messages
00:49:15 <adnap> var = 2
00:49:17 <Gracenotes> adnap: you were the only who mentioned IORefs, and CaptainK was the one who mentioned global variables. I brought up the intersection, of two things, neither of which you'll usually want to do :p
00:49:27 <Gracenotes> that doesn't look that mutable to me
00:49:34 <johnw> there was no reason to make debugging a "proper" aspect of the program, it was really an ancillary thing, so a global fit the bill
00:49:35 * elliott thinks we should stop talking about IORefs immediately.
00:49:36 <Gracenotes> ...which is usually not what you want
00:49:37 <adnap> Oh, mutatble... I forgot
00:49:58 <adnap> Yeah, well when he initially said what he wanted, I knew we were already into "bad idea" territory
00:50:04 <CaptainK> so...map (stuff globalvariablehere) wordshere
00:50:07 <adnap> So I was just suggesting all the dirty stuff I could think of
00:50:18 <Cale> CaptainK: I don't think your variable is global?
00:50:27 <Cale> CaptainK: But whatever
00:50:29 <johnw> CaptainK: can you show us code?
00:50:48 <Cale> http://paste.tryhaskell.org/new/haskell
00:50:54 <CaptainK> I would have to kill everyone here to show the code :P
00:51:01 <Gracenotes> before or after?
00:51:15 <johnw> lol
00:51:16 <adnap> top seekrit
00:51:17 <CaptainK> well after, so I could at least get it fixed
00:51:27 <mr-> CaptainK: can you explain when you call a variable global?
00:51:50 <Cale> I think CaptainK just means the variable from the larger scope
00:51:58 <CaptainK> well inside the main = do there are variables getting set
00:52:16 <Gracenotes> or, rather, defined. you could say.
00:52:19 <CaptainK> when I call me function it need to be passed one word at a time from a lilst
00:52:28 <Cale> CaptainK: right, and you can pass those values into whatever function you want
00:52:44 <Cale> CaptainK: Or use them inside of a lambda to define a function based on their value
00:52:55 <Cale> (if you want the function which you're mapping over the list to depend on them)
00:52:58 <CaptainK> BUT it also needs another variable which contains the whole list and that needs to be passed without mapping it one word at a time
00:53:09 <Cale> What are you actually computing?
00:53:38 <adnap> Can you just make an abstract version of the code?
00:53:57 <CaptainK> ya that would be better...looking for pastebin
00:54:38 <johnw> there is one linked in the channel topic
00:54:50 <Gracenotes> see, if this were Java, you could just access the list without thinking about it
00:55:09 <Gracenotes> repeat 30 times, get bug, spend 5 hours debugging.
00:55:15 <Gracenotes> mm.
00:56:02 <Gracenotes> I'm not being constructive tonight.
00:56:05 <Cale> Gracenotes: Even Java has scope
00:56:22 <Cale> This has nothing to do with mutation as far as I can tell
00:56:46 <Cale> It's just about how variables are bound and what their scope is.
00:56:49 <Gracenotes> well, the list is presumably the result of some computation.
00:57:12 <Cale> Yeah, you'd still want to get it somehow to where it needed to be in Java :P
00:57:16 <Gracenotes> a poor Java programmer might just make something-or-another into a singleton. I can't say without seeing the example, though.
01:00:30 <hpaste> CaptainK pasted “EatMyWords” at http://paste.tryhaskell.org/90690
01:01:19 <hpaste> elliott annotated “EatMyWords” with “EatMyWords (annotation)” at http://paste.tryhaskell.org/90690#a90691
01:01:23 <elliott> CaptainK: ^
01:01:31 <elliott> um.
01:01:36 <elliott> except "map stuff words" doesn't really make any sense.
01:01:38 <elliott> but whatever.
01:02:04 <CaptainK> well no, not the logic, its just an abstract example.
01:02:33 <Gracenotes> so why not pass both words and wordsall?
01:02:35 <CaptainK> take out wordy to make it run...it fails like I expect
01:02:48 <CaptainK> because I want ALL the words in the list
01:03:03 <CaptainK> at once
01:03:34 <Gracenotes> yes... why not pass both all of the words, and also just some of them?
01:03:41 <Gracenotes> as separate arguments
01:03:58 <CaptainK> Gracenotes: can you show an example?
01:04:48 <Gracenotes> well, so make stuff :: [String] -> String -> Whatever, and then do: map (stuff wordsall) words
01:05:05 <CaptainK> ok, cool trying
01:05:09 <Gracenotes> if you do a map operation, it doesn't just have to be on functions that only take an argument
01:05:12 <Gracenotes> a single argument
01:06:11 <Gracenotes> often it's on closures that only need one more argument to produce some kind of value, but such is partial application; LYAH (and other places) goes into it, I believe.
01:07:17 <adnap> I understand ion's examples (https://gist.github.com/ion1/5924946). What should I learn next?
01:08:24 <adnap> I found this example which I thought was pretty cool: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
01:08:44 <CaptainK> map (stuff wordsall) words
01:08:50 <adnap> But I didn't completely understand it because I don't understand monad transformers
01:09:31 <CaptainK> what does the call look like then?  stuff wordsall words?
01:09:43 <Gracenotes> yes, basically
01:10:19 <Gracenotes> even when you write map (+1) [1..3], that's the same thing as (map (+1)) [1..3], as far as semantics
01:11:07 <Gracenotes> (although when you make a saturated call to a known function, it's a lot faster than the alternatives, which is a nice bit of optimization mainly)
01:11:31 <tdammers> adnap: do you understand Monads?
01:11:37 <adnap> tdammers: Yes
01:11:51 <tdammers> well, then monad transformers shouldn't be *that* much of a leap
01:11:53 <Gracenotes> or f a b c, is the same as ((f a) b) c. or, let x = f a; y = x b in y c.
01:11:59 <Gracenotes> that's a little abstract, though.
01:12:07 <tdammers> consider State
01:12:09 <adnap> tdammers: Well, what is a good tutorial?
01:12:11 <adnap> Or
01:12:21 <adnap> Yes, I would like to learn StateT
01:12:22 <tdammers> idk, there really isn't that much to monad transformers
01:12:26 <tdammers> :t runState
01:12:27 <lambdabot> State s a -> s -> (a, s)
01:12:31 <tdammers> :t runStateM
01:12:32 <lambdabot>     Not in scope: `runStateM'
01:12:32 <lambdabot>     Perhaps you meant one of these:
01:12:32 <lambdabot>       `runState' (imported from Control.Monad.State),
01:12:32 <adnap> which is used in the Lens example I posted
01:12:36 <tdammers> pfff
01:12:39 <tdammers> :t runStateT
01:12:40 <lambdabot> StateT s m a -> s -> m (a, s)
01:12:49 <tdammers> observe the difference in the type signatures
01:12:56 <tdammers> this should give you a decent hint
01:13:06 <adnap> I get it
01:13:15 <tdammers> the other monad transformers are similar
01:13:30 <tdammers> the only thing you need to add to the mix, really, are the various lifts
01:13:42 <adnap> I have used monad transformers before
01:13:49 <Gracenotes> CaptainK: so this is called partial application, which is related to currying, if you're interested in other infos
01:14:06 <adnap> But I didn't really know what I was doing except that I could do things like liftIO to do IO inside some other monad
01:14:09 <Gracenotes> http://learnyouahaskell.com/higher-order-functions
01:14:17 <tdammers> ah
01:14:26 <CaptainK> Gracenotes: ok gtk, almost have my program working...newbie difficulties
01:14:39 <tdammers> have you ever implemented State yourself?
01:14:41 <Gracenotes> cool
01:15:16 <tdammers> (or any of the other standard monads)
01:18:02 <adnap> tdammers: Yes
01:18:32 <adnap> tdammers: I implemented State two days ago, but I didn't really understand it
01:18:49 <adnap> tdammers: It just seemed like there was only one way to do it given the type signatures
01:19:05 <startling> adnap, what didn't you understand?
01:19:13 <adnap> What the point of State is
01:19:31 <adnap> How it works
01:20:00 <adnap> I think the LYAH tutorial I read a long time ago made sense
01:20:05 <startling> adnap: well, its point is to keep state in between sequence operations
01:20:09 <adnap> Perhaps I'll re-read that
01:20:16 <startling> *sequenced
01:20:19 <johnw> adnap: are you familiar with Reader?
01:20:24 <adnap> johnw: Not anymore
01:20:29 <startling> yeah, Reader might be easier to understand.
01:20:30 <adnap> I also learned about that in LYAH
01:20:42 <adnap> I learned a bunch of monads, but I never used them
01:21:32 <johnw> I use Reader a lot more than I use State
01:21:42 <elliott> adnap: do you have a project you can apply these things to? it helps to use them in practice once you know how it's made
01:22:03 <adnap> I have a project
01:22:09 <adnap> I'm not sure how I would use them
01:22:47 <adnap> Maybe I should just keep working on my project until I need this stuff
01:23:09 <adnap> I wanted to kind of take a break and "get better at Haskell", but...
01:23:46 <adnap> Well, I keep reading people talk about lens, so I thought maybe it would be useful
01:25:51 <tdammers> lens is incredibly useful, but if you don't fully grasp State, I think it might be a bit, uhm, overwhelming
01:26:02 <Gracenotes> it's definitely nice for an idiomatic toolbox, but it doesn't exist in a vacuum.
01:26:14 <tdammers> exactly
01:26:18 <Gracenotes> there are other Haskell idioms that it interacts well with, and builds up on
01:26:52 <Gracenotes> plus, all the stuff lens does, you could do the same in Python much easier, right :p
01:27:01 <tdammers> you can comfortably write pseudo-imperative code with lens, but you'll have a shitty time if you don't understand the underlying mechanics of State and do sugar
01:28:57 <nschoe> adnap : What helped me understand Monads (and make me try to use them) is the LazyFoo SDL Haskell tutorial : https://github.com/snkkid/LazyFooHaskell
01:29:15 <adnap> I use IO all the time. lol
01:29:16 <Gracenotes> I'm not sure there's any special sauce in lens that can be easily transferred to other languages with less expressive type systems... the higher-level you go, the more you miss it :p
01:29:57 <nschoe> I just followed the C examples and tried to implement them in HAskell, then I read snkkid's implementation.
01:30:31 <johnw> :)
01:30:35 <johnw> oops
01:31:00 <adnap> I just want to learn more stuff in the lens package
01:31:02 <apriori_> hey carter.. finally I met you :)
01:31:34 <apriori_> a few days ago johnw told me your name.. topic is optimized vector (3d, 4d) primops.. do you have any hints for me?
01:38:31 <ksf> is there some library extending GHC.Generics to write functions from Rep a to Rep b?
01:39:03 * ksf has the feeling that he's going to end up using uuagc
01:39:11 <Cale> Gracenotes: You could probably do lenses in anything with parametric polymorphism... you don't *really* need the Functor stuff.
01:40:03 <ksf> (also, why doesn't GHC.Generics have show instances for all those generic types?
01:40:34 <eikke_> ksf: there's a Trac ticket about that, they'll be added IIRC
01:42:11 <supki> adnap: do you understand Foldable/Traversable?
01:42:32 <supki> adnap: if yes, Derivation page on lens wiki could be helpful
01:42:39 <supki> adnap: if no, I would start with those
01:43:05 <adnap> supki: I understand Traversable
01:43:14 <adnap> supki: And not Foldable
01:43:19 <arkeet> foldable is strictly easier than traversable
01:43:37 <arkeet> especially since it involves monoids
01:43:51 <adnap> Oh, I understand Monoids
01:43:58 <adnap> They're just like an additive group
01:44:21 <arkeet> most monoids aren't =(
01:44:22 <Aetherspawn> is it possible to make a data structure that is inline like a C struct
01:44:22 <Cale> monoids are groups without the requirement for inverses
01:44:47 <Aetherspawn> consider C struct { int a, b, c; } versus data Struct = Struct { a :: Int, b :: Int, c :: Int }
01:44:53 <Cale> (or more properly, groups are monoids where every element has an inverse)
01:45:12 <curning> Aetherspawn: inline? do you mean local?
01:45:18 <Aetherspawn> curning: I mean contiguous in memory
01:45:22 <Aetherspawn> sorry, my bad
01:45:30 <curning> Aetherspawn: Haskell has no memory
01:45:35 <Cale> Aetherspawn: The language definition guarantees nothing about memory layout
01:45:36 <curning> so I'm not sure what contiguous means
01:45:50 <Cale> Aetherspawn: If you care about memory layout, you make an instance of Storable and use poke
01:45:50 <Aetherspawn> Well, I have loads and loads of this one data
01:45:55 <Aetherspawn> and the smaller I can make it, thebetter
01:46:01 <arkeet> unboxed strict fields?
01:46:11 <curning> unpacked arrays?
01:46:11 <Aetherspawn> but i need to store it in a Trie so I can't do anything too fancy with it
01:46:16 <curning> oh
01:46:19 <Aetherspawn> is unboxing the same as unpacked?
01:46:35 <curning> I actually meant unboxed
01:46:47 <Aetherspawn> oh, thanks I'll take a look at that
01:58:43 <Moggle_> oh look, webkitgtk+ failed to compile after *three hours*. :D
01:59:08 <Moggle_> oh well.
02:00:37 <notdan> yeah it takes a load of time to compile :(
02:02:46 <osa1> where can I learn more about this: "This is why F-algebras and F-coalgebras are pervasive in high-performance Haskell libraries like vector, because they transform recursive code to non-recursive code, and the compiler does an amazing job of optimizing non-recursive code" ?
02:03:39 <johnw> osa1: google for haskell and recursion schemes, f-algebras, catamorphisms
02:03:42 <johnw> that should you get you started
02:04:21 <osa1> johnw: I know recursion schemes, falgebras etc. I mean their use in high-performance code
02:04:31 <Gracenotes> Haskell stops doing optimization (like iniline, peephole-type stuff) when it reaches recursion
02:04:35 <Gracenotes> in some sense
02:05:01 <johnw> you abstract the algebra from the recursive application of it, which then allows certain fusion optimization to take place that might not be possible when composing regular recursive functions
02:05:15 <Gracenotes> if you express pure things without using explicit recursion, sometimes it can be easier to reason about
02:05:40 <shachaf> What is the relation between vector and f-algebras?
02:05:54 * elliott doesn't think that quote makes much sense.
02:05:55 <osa1> hmm. can I observe that effects by myself? is there a simple code example for demonstration?
02:07:37 <Gracenotes> for context... quote here. https://www.fpcomplete.com/user/bartosz/understanding-algebras
02:08:01 <Gracenotes> their commutative diagrams have pigs.
02:08:06 <osa1> heh
02:10:27 <CaptainK> is this sequencing? ["TEN","MOM","THREE"] + ["ONE","TWO"] = ["TEN","ONE"],["TEN,"TWO"],["MOM","ONE"] and so on
02:11:12 <ion> That’s what sequence does in the list monad.
02:11:22 <osa1> I also can't see a use of Fix in vector's source
02:11:58 <johnw> i couldnt' find anything either before I gave up
02:12:27 <adnap> Using x <- s in do notation for State returns the state value (a). Why is that?
02:12:49 <ion> adnap: “s”? It does that if s = get.
02:13:07 <Gracenotes> it could just be that it uses rules about fusing together various morphisms.
02:13:12 <bitonic> is there a typeclass for inhabited types somewhere?  something like ‘class Empty a where; absurd :: a -> b’
02:13:14 <adnap> ion: No...
02:13:25 <elliott> "the state value (a)" -- in State s a, the type of the state is s.
02:13:32 <adnap> a
02:13:37 <Gracenotes> that is a state value
02:13:38 <Gracenotes> *what
02:13:39 <elliott> perhaps that is from where the confusion derives. but, you haven't told us what "s" is.
02:13:45 <ion> Ah, the result value. The s is the “state value”.
02:13:50 <adnap> Okay, let me...
02:13:53 <adnap> http://learnyouahaskell.com/for-a-few-monads-more#state
02:14:07 <adnap> pop :: State Stack Int
02:14:08 <adnap> pop = State $ \(x:xs) -> (x,xs)
02:14:20 <adnap> a <- pop
02:14:23 <adnap> a is an Int
02:14:24 <adnap> Why?
02:14:32 <elliott> because pop is a computation using a state of a Stack and resulting in an Int.
02:14:43 <elliott> like it says, in State s a, "s is the type of the state and a the result of the stateful computations."
02:14:46 <adnap> Yeah, why does the <- get only the result?
02:14:57 <shachaf> I think Mu and Nu are more interesting in thinking about initial/terminal algebras/coalgebras than Fix.
02:14:59 <elliott> well, that's the point of the state monad. the state is invisible in the background.
02:15:04 <elliott> it's only there if you explicitly access it.
02:15:05 <adnap> Yeah, but how...
02:15:10 <shachaf> Even though they're all the same thing in Haskell.
02:15:13 <elliott> perhaps the do notation is confusing you?
02:15:19 <adnap> In general, yes
02:15:21 <elliott> it desugars into use of return/(>>=)
02:15:25 <ion> “do …; a <- pop; …” is the equivalent of “let …; (a,s') = pop' s; … in …” where s is the previous state, s' is the new state and pop = state pop'
02:15:26 <adnap> So
02:15:32 <elliott> do { a <- pop; ... } is actually pop >>= \a -> ...
02:15:33 <adnap> I thought the LHS of <-
02:15:38 <adnap> is the LHS of bind
02:15:53 <adnap> Oh, it is...
02:15:56 <elliott> which is actually \stack -> let (a,stack') = runState pop stack in ...
02:15:58 <elliott> er
02:16:02 <adnap> Nevermind
02:16:03 <elliott> which is actually State (\stack -> let (a,stack') = runState pop stack in ...)
02:16:04 <adnap> I get it
02:16:06 <elliott> or whatever.
02:16:06 <quicksilver> adnap: no, the LHS of <- is the parameter for the function on the RHS of bind.
02:16:09 <Gracenotes> there are three parts of <-... the LHS, the RHS, and everything after that.
02:16:10 <adnap> Wait, no I don't
02:16:29 <Gracenotes> do { lhs <- rhs; blah } becomes rhs >>= \lhs -> blah
02:16:40 <adnap> I mean the LHS of the function on the RHS of bind
02:16:45 <Gracenotes> as elliott said basically
02:16:47 <adnap> (a -> m b)
02:16:50 <adnap> a
02:16:54 <adnap> And it is
02:17:05 <adnap> I was just confusing (a -> m b) and (s -> (a, s)
02:17:07 <adnap> )
02:17:32 <Gracenotes> when you specialize m b to State, this becomes equivalent to (a -> s -> (b, s))
02:17:55 <adnap> I get it now
02:18:06 <Gracenotes> this probably doesn't help much, because there's a newtype anyway, and the key point is that this function takes an 'a', not an (a, s)
02:18:16 <Gracenotes> if that is what you get
02:18:26 <adnap> The confusing part was just
02:18:35 <adnap> That State is s -> (a, s)
02:18:51 <adnap> Er, I already said already
02:18:57 <adnap> I was just confusing (a -> m b) and (s -> (a, s)
02:19:06 <Aetherspawn> is it possible (or necessary) to specify an Int as being unpacked when dealing with an unpacked struct
02:19:15 <Aetherspawn> as to avoid to the struct from being boxed during comparisons and/or matching?
02:19:25 <Aetherspawn> /s/Int/constant int/
02:21:08 <osa1> okay, another question. I understand generalized fold(catamorphism) but I don't understand how is unfold(anamorphism?) useful, can anyone give me some ideas to be implemented using unfold?
02:23:03 <Lethalman> osa1, I believe iterate can be implemented using unfold
02:23:15 <Lethalman> or replicate
02:23:51 <Gracenotes> codata. [1..] can be.
02:24:08 <johnw> osa1: http://news.anarchy46.net/2013/03/anamorphism.html
02:24:26 <Gracenotes> an infinite tree of unique rational numbers.
02:24:48 <Gracenotes> ..some other more practical things
02:25:08 <adnap> > runState get 42
02:25:09 <lambdabot>   (42,42)
02:25:56 <Fubar^> osa1: I have used unfold to do an intToHex :: Int -> String
02:27:42 <adnap> > runState (get >> put 42) undefined
02:27:43 <lambdabot>   ((),42)
02:27:54 <Cale> osa1: You might use an unfold to build a game tree.
02:28:21 <osa1> Cale: now that sounds interesting :-)
02:32:57 <adnap> > runState (modify (+2)) 40
02:32:58 <lambdabot>   ((),42)
02:33:16 <johnw> > runState (modify (+2) >> get) 40
02:33:17 <lambdabot>   (42,42)
02:34:03 <adnap> I don't know what I would ever use this for...
02:34:31 <tomejaguar> Can I get reverse dependencies on hackage?
02:34:56 <adnap> tomejaguar:
02:35:00 <adnap> tomejaguar: Do you use Gentoo?
02:35:04 <tomejaguar> No
02:35:26 <shachaf> Hackage doesn't do it but I think there's a website that does.
02:35:36 <shachaf> @google hackage reverse dependencies
02:35:36 <lambdabot> http://packdeps.haskellers.com/
02:35:36 <lambdabot> Title: Hackage dependency monitor
02:36:59 <tomejaguar> Oh well, I guess I should have tried Google first :)
02:37:03 <tomejaguar> Thank you.
02:37:22 <elliott> adnap: you could replace your IORefs with it :p
02:38:38 <adnap> elliott: Huh
02:39:23 <adnap> Next time I use an IORef, I will try to figure out how
02:41:03 <johnw> adnap: here's a little example: i'll show you an example
02:41:09 <johnw> adnap: here's a little example: https://gist.github.com/5933365
02:41:26 <johnw> i'm using state over a fold to maintain a counter
02:41:44 <johnw> there are better ways of writing that, of course, which wouldn't use State at all
02:42:13 <adnap> :t foldM
02:42:14 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
02:42:35 <johnw> if I had used foldr, I wouldn't have access to the surrounding state
02:43:19 <Walther> Just curious. (this will be a weird question) Is there a way to write haskell and transform the code in another language? :P
02:43:36 <johnw> Walther: you mean like Fay does for Haskell->Javascript?
02:43:38 <arkeet> yes, that's called a compiler.
02:43:50 <Walther> I will be having yet-another-compulsory-beginner-course in programming due changing uni
02:43:57 <adnap> johnw: This is just so weird though
02:44:01 <Walther> this time it would be Java, and I'm not all that interested
02:44:11 <johnw> adnap: beat on it until it's obvious
02:44:12 <adnap> > zip [0..] "abcde"
02:44:13 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e')]
02:44:19 <johnw> i didn't say it was elegant
02:44:24 <johnw> it was just a use of State
02:44:27 <adnap> It's already obvious
02:44:32 <johnw> ok
02:45:20 <tdammers> Walther: can't you just exam out of it?
02:46:16 <Walther> tdammers: well, having taken the same course but in Python, probably not - i'd fail at the syntaxes
02:46:30 <danr>  :t \ f x xs a -> runState (foldM (\ u v -> state (f u v)) x xs) a
02:46:46 <Walther> but yeah, most probably cross-language translation is out of reach with current means
02:46:48 <arcatan> Walther: which uni are you in?
02:47:48 <Walther> arcatan: been "studying" in Aalto university for a year via open university while having a year off after IB, now applied and got admitted to Helsinki university for compsci
02:47:59 <tdammers> Walther: well, why not take a month or so to learn Java, and *then* exam out? Still beats a whole semester of mandatory coursework
02:48:36 <arcatan> Walther: oh, congrats
02:48:37 <tdammers> (and honestly, I really don't understand why universities use Java, of all things, to teach CS)
02:48:37 <Walther> yeah, i'll have to look into that. But I'm still kinda curious how possible the cross-language translation would be
02:48:52 <merijn> Walther: "cross-language translation" is just a fancy way to say compiler
02:48:59 <Walther> yeah, at least Aalto used python and now moves to was it scala or scheme
02:49:08 <arkeet> merijn: that's what I said. :p
02:49:11 <merijn> Walther: Nothing says a compiler has to generate assembly, it could generate python, lua, or whatever you like
02:49:11 <arcatan> Walther: if you're interested in Haskell and functional programming, see http://lambda.cs.helsinki.fi/
02:49:17 <arcatan> Walther: mostly we just drink beer, but anyway
02:49:31 <Walther> merijn: do language-to-language compilers work, where neither language is assembly / other low-level? :
02:49:44 <merijn> Walther: Yes, many people write things like that fulltime
02:49:45 <tdammers> Walther: there is no reason why they wouldn't
02:49:48 <Walther> arcatan: well beer is good!
02:50:09 <tdammers> assembly is just another machine language - it's less human-readably, but that's about it
02:50:09 <merijn> Walther: I'm working in two projects that compile high level languages to C
02:50:34 <Walther> hm, somehow I had the impression weird compilers only existed from higher level to low-level
02:50:38 <arcatan> there are quite a many to-javascript compilers nowadays, as not that many people like it but it's the language of the web
02:50:39 <merijn> Walther: Compiling to python or lua or java would be trivial (we don't, for performance reason, but there's no reason you can't)
02:50:40 <tdammers> Walther: I have a project that compiles templates into PHP, JavaScript and a JSON-encoded DSL
02:50:45 <arkeet> wallmani: ghcjs compiles haskell to javascript :-)
02:50:52 <merijn> Walther: I know people who are working on assembler to high level compilers, actually
02:51:02 <Walther> merijn: that just sounds backwards :P
02:51:13 <Walther> arcatan: thanks, that actually seems *very* interesting
02:51:28 <tdammers> Walther: it's not "backwards", really - you're just translating from one formal language to another
02:51:34 <merijn> Walther: It's to translate handcoded assembly code written for banks in the 70s and 80s to higher level code that can actually be maintained/ported
02:51:37 <Walther> tdammers: nod, still sounds like it
02:51:37 <tdammers> that's all a compiler does, really
02:51:47 <Walther> merijn: ah, an actual usecase
02:51:58 <elliott> merijn: oh, i assumed reverse engineering
02:52:11 <merijn> Walther: Big companies with legacy assembly code are actually willing to pay a lot for stuff like that
02:52:23 <merijn> elliott: I know people doing reverse engineering too, in a different group
02:52:42 <merijn> elliott: But this seemed a more appropriate example
02:52:49 <tdammers> there's also this thing where they implement a virtual machine in JavaScript and run a native linux kernel on it - in the browser.
02:53:05 <merijn> Walther: Learning how to write a compiler is A) not that different and B) will change how you think about languages forever
02:53:10 <merijn> ah
02:53:10 <Walther> But really, it is a shame that many of the uni compsci courses *kinda* enforce a language even if in theory you could use any language
02:53:12 <tdammers> http://bellard.org/jslinux/
02:53:19 <merijn> Instead of different I meant difficult
02:53:25 <Walther> you just wouldn't get any help and grading could be sketchy
02:53:47 <merijn> Walther: In general many typical uni languages are easy once you know one of them
02:53:49 <tdammers> grading is sketchy by definition
02:53:53 <Walther> merijn: I think writing a compiler will be one of compulsory course projects in near future
02:54:08 <tdammers> oh, and writing compilers is fun
02:54:27 <Walther> merijn: That's true though. But it would be so much better still to both learn the useful stuff taught on the courses and while at it, learn the language you actually want to learn
02:54:32 <Walther> namely, haskell
02:54:47 <tdammers> Walther: you should learn more than one programming language anyway
02:54:57 <merijn> Walther: Do both!
02:55:05 <tdammers> Walther: in fact, you should learn so many of them that one more or less won't make any difference
02:55:12 <Walther> I have in the past had courses for basics of java and basics of python, and I'd really be eager to learn Haskell now
02:55:27 <merijn> tdammers: Well, if they're sufficiently different it might take a while
02:55:30 <Walther> Nod. More languages -> more diverse understanding and "thinking outside the box"
02:55:45 <tdammers> merijn: sure. But the more languages you learn, and the more different they are, the easier it becomes to learn yet more
02:55:49 <Walther> or like on a picture linked at another channel, inside the box because it's bigger on the inside
02:56:05 <merijn> Walther: Start reading Learn You a Haskell and don't worry about your courses, two years of hanging around in here and you'll be smarter than 90% of your fellow students :p
02:56:19 <tdammers> I'm currently learning Ruby; I got from zero to "command line program that converts an .OBJ file to svg" in two days
02:56:34 <Walther> merijn: heh
02:56:43 <merijn> tdammers: I actually had to put my "learn more languages" list on hold to actually write some code in the stuff I know
02:56:57 <tdammers> merijn: heh, yeah, good point
02:57:16 <Walther> merijn: bad thing is, though, I kinda want to actually get the damn degree in some time, and that requires completing courses, which requires working out all the compulsory projects and tasks
02:57:23 <tdammers> I have an abundance of spare time right now, that's why I'm tackling Ruby *now*
02:57:38 <merijn> tdammers: Oh, I consider myself as "already knowing" ruby/C#/lua even though I've only written like a couple 100 lines of lua and no code in ruby/C# :p
02:57:41 <Walther> Though, I've been thinking of a ninja strategy of doing all the exercises thrown at me both in the recommended language and in Haskell
02:58:02 <merijn> Walther: That might be tricky until you get more up to speed with haskell, though
02:58:08 <tdammers> merijn: by that logic, I "know" Scheme and Common Lisp
02:58:14 <merijn> Some things that are easy in haskell are not in other languages vice versa
02:58:35 <merijn> tdammers: Racket, Forth and APL/J/whatever are high on my list to learn after I finish some more haskell stuff
02:58:43 <adnap> I never see anyone talk about big-O in here
02:58:48 <tdammers> I could even put CL on my resume - I have exactly one commit to a production system in CL on my name
02:58:52 <tdammers> it removes one line of code
02:59:02 <Bor0> what is there to talk about big-O
02:59:08 <merijn> tdammers: Hah, I have two commits in the GHC repos and 1 in cabal \o/
02:59:10 <Walther> merijn: Well of course. I'm still taking baby steps, like reading on Yesod and Snap, having tried out a bit of Hakyll, and written a couple small things for project Euler
02:59:17 <adnap> Like, the time/space performance of functions
02:59:18 <merijn> tdammers: Adding a grond total of 6 characters
02:59:28 <tdammers> merijn: \o/
02:59:34 <tdammers> removing beats adding though!
02:59:50 <merijn> Walther: I personally think Project Euler is not very good for learning languages, I tend to recommend
02:59:54 <merijn> @where exercises
02:59:54 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
02:59:55 <Bor0> I know what big-O is :)
03:00:17 <merijn> tdammers: I fixed 3 (build breaking!) bugs, though :p
03:00:23 <tdammers> nice
03:00:25 <Walther> merijn: but Euler is very good for math learning, and you get the programming exercise for free as a side
03:00:26 <elliott> tdammers: what did it remove? :)
03:00:47 <tdammers> a link to the job ads page on a custom website
03:01:00 <Walther> But mostly, I just need to grab my lazy ass and start punching together some code, that's the only real way to learn any programming at all
03:01:05 <merijn> Walther: I think it teaches the wrong kind of programming, it promotes golfing and difficult unreadable code over "realistic" code
03:01:06 <tdammers> (and yes, there are custom websites written in common lisp)
03:01:20 <Walther> Learn Haskell the Hard way looked like a very interesting tutorial, it seems to have wide coverage in a dense package
03:01:43 <tdammers> anyone with basic reading comprehension and a 5-minute tutorial on matching parens could have made the change though
03:01:51 <Walther> merijn: then again, I'm not reading Euler forums or anything, I've just solved a couple for own interests and trying out Haskell
03:02:04 <notdan> How can I get the number of bytes in the bytestring?
03:02:14 <tdammers> Euler focuses on programming-in-the-small
03:02:45 <merijn> @hoogle ByteString -> Int
03:02:45 <lambdabot> Data.ByteString length :: ByteString -> Int
03:02:45 <lambdabot> Data.ByteString.Char8 length :: ByteString -> Int
03:02:45 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
03:03:05 <merijn> notdan: Hoogle is your friend :p
03:03:22 <notdan> is 'length' returns the actual length in bytes? I mean, does every character in the bs is represented by a byte?
03:03:33 <tdammers> notdan: that's the very definition of a bytestring
03:03:38 <tdammers> a string of bytes
03:03:40 <merijn> notdan: Ignore the String part of ByteString
03:03:46 <notdan> Ok, thanks
03:03:48 <merijn> notdan: ByteString is just bytes
03:04:04 <merijn> notdan: Text is the encoding aware datatype for dealing with files, etc.
03:04:28 <luite> notdan: don't use the C8 ByteStrings by the way, they're horrible :)
03:04:42 <merijn> Data.ByteString.HorriblyUnsafe.Char8
03:04:55 <quchen> luite: I've heard that before. What's the reason for that?
03:04:59 <elliott> Data.ByteString.Upsets.Shachaf.Char8
03:05:01 <quchen> (The statement, not the hearing.)
03:05:11 <merijn> quchen: It treats everything is ASCII
03:05:13 <opqdonut> bytestring is bytes
03:05:17 <merijn> s/is/as/
03:05:20 <opqdonut> if you want text, use Data.Text
03:05:21 <notdan> I am only using pack/unpack from C8
03:05:28 <merijn> notdan: :((((
03:05:32 <opqdonut> bytestring is for binary IO
03:05:46 <quchen> merijn: Oh, Char8 isn't Word8, it's a Word8 that stores explicit characters?
03:05:58 <quchen> merijn: hence ASCII hence why does this even exist?
03:05:58 <luite> quchen: they cut off char codepoints, are an indication that you're either using the wrong data type or doing encoding wrong
03:05:58 <tdammers> > minBound :: Char8
03:05:59 <lambdabot>   Not in scope: type constructor or class `Char8'
03:06:00 <lambdabot>  Perhaps you meant `Char' (...
03:06:08 <merijn> quchen: Exactly
03:06:34 <merijn> quchen: People to lazy to properly decode use it, and they obviously shouldn't
03:06:36 <elliott> notdan: those are possibly the worst functions in Char8.
03:06:42 <elliott> they have the most lying types.
03:06:43 <quchen> So why does it exist? Are there horrible hacking situations in which they could be useful?
03:06:44 <luite> notdan: use decodeUtf8 / encodeUtf8 from Data.Text.Encoding instead
03:06:46 <ion> Char7 would be enough for ASCII.
03:06:55 <merijn> quchen: Because people are awful :(
03:07:05 <notdan> Well, I want to put/get an Int to/from a Handl
03:07:10 <notdan> *Handle
03:07:29 <notdan> I am doing (BS8.pack . show $ int) right now
03:07:33 <quchen> merijn: That's not very satisfying. :-(
03:07:38 <elliott> Char8 isn't *totally* useless. it's just overused.
03:07:42 <notdan> is that terribly bad?
03:07:48 <luite> notdan: use binary or cereal, and their putInt32le or similar
03:07:48 <elliott> sometimes you really are dealing with ASCII. like some network protocols.
03:07:53 <merijn> quchen: Well, I've used them occasionally while dealing with file names, as there is no sane way to do encoding there anyway
03:07:59 <elliott> erm, show isn't very binary :)
03:08:08 <tdammers> I guess sometimes you want to process textual data without being able to determine the encoding, and slightly incorrect results are acceptable and a better choice than outright failing on incorrect input
03:08:17 <elliott> depends if there is control over the format I guess
03:08:48 <quicksilver> it's quite common especially with unix command-line utilities to deal with 8-bit data which approximates text
03:09:00 <quicksilver> and it's much faster than dealing with encodings correctly
03:09:06 <tdammers> indeed
03:09:09 <quicksilver> so, there's a case for its existence - but it's a niche.
03:09:18 <luite> tdammers: using utf8 with lenient decoding might be a better default choice nowadays
03:09:31 <quicksilver> it is partly historical, too
03:09:48 <quicksilver> we didn't have a good story for dealing efficiently with encoded text when bytestring.char8 was written.
03:09:52 <tdammers> luite: usually, I'd agree, but I guess sometimes passing the "wrong" bytes through unchanged instead of trying to fix things might be a better choice
03:10:01 <merijn> quchen: Basically, the unix FS doesn't deal with encoding, it only deals with bytes and the same goes for the C file calls, so no reason to bother with encoding there. But like many things it's easier to say "never use it", because the people with a legitimate reason already know why and when to ignore the "never use it" command
03:10:10 <luite> tdammers: ah good point
03:11:17 <quchen> merijn: But Word8 and Char8 are still isomorphic, right?
03:11:33 <elliott> Char8?
03:11:37 <quicksilver> Char8 doesn't actually exist
03:11:40 <elliott> I don't know of any type called Char8
03:11:43 <quicksilver> it's just used in the name of the bytestring module
03:11:47 <merijn> quchen: Char8 is a module, not a type
03:11:51 <quchen> Oh.
03:11:53 <quicksilver> to indicate that pack/unpack will have strange types
03:11:59 <merijn> Data.ByteString.Char8
03:12:01 <quicksilver> (and some other functions also)
03:12:30 <quchen> Well then what's the difference between normal BS and Char8-BS? The API functions do what ASCII-specific things exactly?
03:12:31 <elliott> it encodes the assumption that Char is 8 bits. of course, this assumption is patently false, but that's the moral value of that module for you.
03:12:31 <merijn> quchen: Word8 is just the representation of a byte, which has tons of valid uses
03:12:43 <elliott> quchen: IsString instance, using Char instead of Word8.
03:13:09 <elliott> the former is wrong because ByteStrings are not strings of text. the latter is wrong because ByteStrings do not store Chars.
03:13:13 <merijn> quchen: There's no "unpack :: ByteString -> String", "pack :: String -> ByteString" in the non Char8-BS
03:13:14 <luite> quchen: the ByteString is actually the same in both, it's a reexported internal thing
03:13:25 <luite> quchen: but the encoding/decoding stuff is different
03:13:30 <merijn> quchen: Normal BS have "unpack :: ByteString -> [Word8]"
03:13:55 <quchen> merijn: Ah, I see.
03:15:45 <quchen> So if I wanted to serialize a String, I should probably use Text and encodings. (Which is probably equivalent to what Binary does.)
03:16:00 <zvrba> why do people say that SML/Ocaml functors are more "powerful" than type classes? powerful in which way?
03:16:12 <quchen> The brutal way would be using the Char8-BS, getting scolded by shachaf and emergent bugs, and promising to not repeat that mistake.
03:17:04 <quchen> zvrba: "Powerful" has multiple uses, I feel like the main translation is "I'll just throw something random out there".
03:17:20 <zvrba> :)
03:19:34 <elliott> it's more that our module system is deficient compared to the ML functor/module system.
03:19:39 <elliott> though there is some overlap with typeclasses.
03:19:47 <zvrba> right. but in what way is it deficient?
03:20:02 <curning> no first class modules
03:20:07 <elliott> well, Haskell's module system is very weak and ML's is very powerful. that's pretty much all there is to it.
03:20:24 <zvrba> curning: but what (more) can you do with 1st-class modules?
03:20:43 <curning> you can do everything with everything
03:22:14 <zvrba> sure :p
03:25:45 * Walther is reading some slides on haskell, tries to resist an urge to make a joke about lambdas and "we are the anonymous! we only use lambdas in our code"
03:26:02 <Walther> (anonymous functions)
03:32:47 <zvrba> any opinions on using SPOJ online judge to practice Haskell?
03:32:58 <zvrba> i'm really empty of real-world ideas
03:33:04 <ksf> compdata looks very promising and capable, but also unfathomably intimidating.
03:35:58 <zacts> what does one gain by using a functional style over a "series of actions" style of programming?
03:40:14 <b_jonas> zacts: the latter is often called imperative programming
03:40:40 <merijn> zacts: Easier concurrency and better ability to reason about your code (thus helping to prevent bugs)
03:41:00 <zacts> b_jonas: ah thanks
03:41:01 <b_jonas> the advantages are (a) functional programming is more declarative in that you tell more what result you want, not how to compute it,
03:41:07 <merijn> zacts: Also, the "series of actions" style of programming works *really* well in haskell, once you get use to programming in haskell
03:41:34 <b_jonas> (b) it's easier to reduce bugs if there can't be unexpected side-effects everywhere,
03:41:40 <b_jonas> and possibly more
03:41:59 <merijn> As someone who writes a lot of C for work and tends to write very IO heavy haskell, I much prefer haskell for my imperative code to any other language I know (python/lua/java/C/C++)
03:42:02 <Lethalman> b_jonas, I'm sorry, but maybe that's logic programming not functional programming
03:42:42 <Lethalman> I don't see almost anything declarative in functional programming, you want to specify how things are computed
03:42:42 <b_jonas> that is, in functional style code (even in languages that allows both functional and imperative code) what depends on what is more obvious
03:43:10 <Lethalman> if not, please show me some declarative code where you actually don't depend on how the computation must be performed
03:43:12 <b_jonas> Lethalman: it _is_ more declarative than the imperative programs I think. think of a map versus a for loop.
03:43:23 <acube> Maybe that's also "functional style", representing "actions" as "values" that can be operated on by pure functions?
03:43:26 <Lethalman> b_jonas, that is not declarative
03:43:35 <b_jonas> you do still tell how the computation is performed, but the intent is more obvious from functional code usually
03:44:03 <b_jonas> don't call it declarative if you don't want to. everyone uses these terms differently, I'm almost used to it.
03:44:35 <Lethalman> declarative means you define the goal and the requirements, with map you're just changing how the loop looks
03:44:36 <merijn> Dammit
03:44:46 <b_jonas> acube: that's different, and partly orthogonal from non-imperative functional programming I think
03:45:02 <b_jonas> you can have first-class functions in imperative code too
03:45:07 <zacts> I guess a question is what is the metaphor of functional programming?
03:45:13 <merijn> Hackage timed out while uploading my package and now it's stuck in limbo, i.e. not showing up but I'm not allowed to reupload my package because it already exists?
03:45:16 <zacts> how is functional programming analagous to OOP?
03:45:17 <b_jonas> and pass them around and call them and get even more unexpected side effects
03:45:24 <merijn> zacts: It isn't
03:45:47 * hackagebot transformers-supply 0.1.0 - Supply applicative, monad, applicative transformer and  monad transformer.  http://hackage.haskell.org/package/transformers-supply-0.1.0 (MerijnVerstraaten)
03:45:49 <elliott> you gain whatever you gain from it.
03:45:49 <typoclass> merijn: upload again with different version? (poor man's solution ...)
03:45:50 <zacts> analogous
03:45:53 <merijn> ah, there we go!
03:45:55 <elliott> it's a different way of doing things.
03:46:01 <elliott> you should try it out and see if it's to your liking.
03:46:05 <zacts> ok
03:46:07 <elliott> that'll be more convincing than an IRC argument :)
03:46:22 <merijn> elliott: There you go, MonadSupply for you :p
03:46:25 <supki> merijn: hackage web ui almost always hangs on uploads for me
03:46:29 <supki> I guess that's normal
03:46:43 <Lethalman> \o/
03:46:48 <elliott> merijn: excellent, another step further in world domination. btw, you have one too many spaces after "and" there.
03:47:32 <merijn> elliott: I don't, there's a newline there and apparently Hackage deals with that oddly
03:48:14 <zacts> how is haskell basically different than programming scheme? in a nutshell?
03:48:36 <merijn> Oh, I forgot to make the mtl dependency optional
03:48:38 <zacts> can I easily transfer my scheme knowledge over to haskell?
03:49:19 <typoclass> zacts: first of all, it's got a powerful type system :-)
03:49:36 <elliott> scheme knowledge will help; it won't be sufficient, however.
03:50:13 <zacts> is learn you a haskell for a great good a good start?
03:50:36 <typoclass> zacts: yes it is! also see tryhaskell.org . and later you may want to have a look at rwh
03:50:39 <typoclass> @where rwh
03:50:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:50:47 * hackagebot yesod 1.1.9.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.9.4 (MichaelSnoyman)
03:50:53 <sanjoyd> Any idea what is wrong with this: http://pastebin.com/vdCziGyS ?
03:50:56 <zacts> and will haskell transform the way I program in other languages such as perl?
03:51:01 <zacts> (last question I promise)
03:51:16 <sanjoyd> Why is T an "Unacceptable result type"?
03:51:33 <supki> where is mauke???
03:51:44 <lasticot> merijn: hi, what should I do now to further my understanding?
03:51:47 <merijn> sanjoyd: You're foreign exporting it
03:51:56 <sanjoyd> merijn: what kinds of types can I foreign export?
03:52:36 <merijn> sanjoyd: I don't remember exactly, it's in the GHC manual, for custom datatypes you would have to create a Storable instance and return "Ptr T"
03:52:40 <typoclass> zacts: i think it will :-) it did for me. i hope this doesn't sound too cult-ish, but i always made a point of using several languages. but that stopped after i'd learned some haskell. going back felt just like going back
03:53:00 <merijn> sanjoyd: It also depends, does C land need access to you data structure? Or will it just treat it opaquely?
03:53:08 <typoclass> zacts: and i think learning some haskell will make you a better programmer no matter if you end up using haskell or another language
03:53:17 <zacts> interesting! well, thanks..
03:53:19 <sanjoyd> merijn: hmm, okay.  I didn't know what to google; I'll have a look at the ghc manual.
03:53:22 <merijn> sanjoyd: (Also, newtyped foreign exportable types do work, so "newtypte T = M Int" should work
03:53:23 <sanjoyd> merijn: thanks!
03:53:44 <merijn> Since Int is foreign exportable, although you'd probably want to convert to CInt
03:53:55 <sanjoyd> merijn: okay; but I do need a proper sum type.  Was just trying to get a minimal case that fails. :)
03:54:22 <merijn> sanjoyd: Does C actually need to change your data? Or does it just get a handle and pass that back to Haskell later?
03:54:29 <sanjoyd> merijn: I'd like to be able to change it.
03:54:29 <zacts> I guess I've kinda been a bit skeptical, I don't really believe in magic bullets so to speak.
03:54:48 <zacts> but new ways of thinking, I like that
03:54:49 <b_jonas> it's not a magic bullet
03:54:57 <sanjoyd> Rather, I'd like to be able to create an instance, pass it to haskell; and then read back what haskell returns.
03:54:58 <merijn> sanjoyd: Ok, then you need a Storable instance and define a C struct for your data structure
03:55:05 <b_jonas> but I agree that it allows you to code better
03:55:18 <merijn> sanjoyd: Creating the instance should happen in C?
03:55:37 <mm_freak_> zacts: let me warn you though, haskell ruins you for most other languages =)
03:55:41 <merijn> Oh, you mean pass back a modified version of what you created
03:55:43 <sanjoyd> merijn: ideally; but I'm open to interesting workarounds. :)
03:56:09 <zacts> I have to check this out. cool. /me reads tryhaskell.com and learn you a haskell.
03:56:14 <quchen> mm_freak_: Give an example of one it doesn't ruin. :>
03:56:21 <mm_freak_> quchen: agda
03:56:34 <merijn> sanjoyd: Well, there's StablePtr which turns any arbitrary haskell value into an opaque pointer, when you pass it back to haskell, haskell can then dereference it and work with it, without C having to understand it
03:56:36 <mm_freak_> quchen: idris
03:56:49 <quchen> mm_freak_: Haskell on steroids, basically.
03:56:50 <sanjoyd> merijn: yes, but can I create a StablePtr in C?
03:56:50 <merijn> sanjoyd: But it sounds like that's not good enough for what you want
03:56:52 <typoclass> zacts: yep, i'm against magic bullet thinking as well. i think it's silly in general, and i wouldn't call haskell a magic bullet. there's a number of drawbacks, imho starting with the state of our documentation (although learn you a haskell made quite an improvement in that area)
03:57:03 <merijn> sanjoyd: No, so that's probably no good for you
03:57:16 <mm_freak_> quchen: no, i don't think haskell and agda can be compared…  haskell is much more powerful than agda in certain respects and vice versa
03:57:25 <merijn> sanjoyd: (Unless you call haskell to make it, get the result in C and then pass it back to haskell, but that might not be useful to you :p)
03:57:33 <mm_freak_> quchen: however, haskell and idris can be compared, and idris has the potential to be the next big thing after haskell
03:57:34 <sanjoyd> merijn: actually, a workaround could be to pass in the raw info that I'll use in C to create the data structure.
03:57:45 <merijn> sanjoyd: Yes, that'd work
03:57:48 <sanjoyd> So I'll only have to pass in simple types like integers etc.
03:58:11 <merijn> sanjoyd: That'd be a lot easier than messing with Storable instances (as that is still a bit hairy, imo)
03:58:18 * typoclass didn't look at agda very much after learning that it doesn't do much type inference :-(
03:58:33 <quchen> mm_freak_: Oh, I haven't seen it this way. Isn't Idris a beefed up version of Haskell that allows a certain amount of dependent types?
03:58:41 <sanjoyd> typoclass: it _can't_ do much type inference.
03:58:49 <mm_freak_> quchen: full dependent types, not just a certain amount
03:58:50 <typoclass> sanjoyd: right
03:58:51 <merijn> quchen: afaik Idriss has full-blown dependent types
03:59:08 * shachaf is tempted to use 0395   GREEK CAPITAL LETTER EPSILON     [Ε]
03:59:11 <shachaf> But it's probably a bad idea.
03:59:43 <typoclass> shachaf: what tempted you?
03:59:48 <mm_freak_> typoclass: you don't need much type inference in agda…  it's pretty close to my haskell style anyway, write type signatures for everything top-level, rest inferred
03:59:50 <Rembane_> shachaf: Think no more, just do it! :D
03:59:55 <quchen> mm_freak_, merijn: Oh, I thought Idris is about halfway between Agda and Haskell.
04:00:03 <quchen> According to some metric.
04:00:04 <shachaf> I need an uppercase version of ε.
04:00:08 <mm_freak_> typoclass: in fact agda allows you to write incomplete type signatures:  f : ? -> ? -> ?
04:00:12 <mm_freak_> uhm
04:00:17 <mm_freak_> typoclass: in fact agda allows you to write incomplete type signatures:  f : _ -> _ -> _
04:00:19 <typoclass> mm_freak_: hm ...
04:00:27 <sanjoyd> I wrote a post sometime back on moving from Haskell to Agda: http://playingwithpointers.com/haskell-to-agda.html
04:00:47 <typoclass> sanjoyd: oh thanks, interesting
04:00:50 <sanjoyd> mm_freak_: well, ? would work too; if you ask Agda to search for you. :)
04:00:52 <mm_freak_> quchen: no, technically idris is more powerful than agda
04:00:57 <sanjoyd> mm_freak_: how?
04:01:12 <ryant5000> is there a library that can estimate the memory cost of a haskell datstructure?  i don't especially mind if it is sharing-aware, and i'm happy to reduce everything to normal form
04:01:16 <mm_freak_> sanjoyd: but you still need to fill in the holes to make the type-checker completely happy
04:01:22 <mm_freak_> "_" rather means "fill this in for me"
04:01:34 <mm_freak_> sanjoyd: for one thing idris has type classes
04:01:45 <mm_freak_> agda doesn't and is unlikely to get them any time soon
04:01:59 <mm_freak_> the most powerful thing about agda is the emacs mode it comes along with
04:02:39 <ryant5000> oh, nvm, found ghc-datasize; that seems to get the job done
04:03:12 <sanjoyd> But agda has something you can use to mimic typeclasses, crudely -- I don't remember what they're called, but they have the syntactic form \{{  and \}}.
04:03:16 * sanjoyd tries to look it up.
04:03:26 <typoclass> shachaf: not sure what you're doing, but how about "Latin capital letter open e", Ɛ
04:04:05 <sanjoyd> Yes, http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.InstanceArguments
04:06:56 <mm_freak_> sanjoyd: i wasn't aware of that feature, but it's really just a loose approximation of haskell's type classes
04:07:09 <mm_freak_> using it with record types should get you pretty close though
04:07:53 <mm_freak_> what i really miss in haskell is agda's module system…  it's extraordinarily powerful
04:08:14 <mm_freak_> even more than dependent types
04:11:35 <quchen> mm_freak_: Can you describe it?
04:11:47 <quchen> Or is it one of those things that one has to experience to value
04:12:35 <mm_freak_> quchen: agda blurs the line between functions and modules…  modules can take arbitrary arguments and be imported multiple times with different arguments…  scoping is very flexible
04:12:50 <mm_freak_> you get submodules, too
04:12:58 <zacts> is let x = 4 in x * x analogous to ((lambda (x) (* x x)) 4) ?
04:13:02 <quchen> mm_freak_: Oh, so you can have a "Data.List.OfLength n" module?
04:13:08 <mm_freak_> zacts: yes
04:13:24 <zacts> cool
04:13:28 <mm_freak_> zacts: except that let-bindings can be recursive
04:13:36 <shachaf> But note that that's not the case with let in general.
04:13:39 <mm_freak_> > let ones = 1 : ones in ones
04:13:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:13:44 <shachaf> mm_freak_: Also polymorphic.
04:14:05 <zacts> ah cool
04:14:28 <int-e> > let i = id in i i i ()
04:14:29 <lambdabot>   ()
04:14:40 <mm_freak_> > fix (\ones -> 1 : ones)
04:14:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:15:25 <therp> mm_freak_: does agda support modules loaded with different versions at the same time?
04:15:26 <typoclass> zacts: the form is "let ... in ...". you can have several bindings in there, separated by semicolon or newline. (note indentation; we say let triggers layout.) after "in", you have one expression
04:15:39 <mm_freak_> therp: "versions"?
04:15:50 <zacts> ah ok
04:16:09 <therp> mm_freak_: versions as in release versions, aka 1.6.1 vs 1.8.1 vs 2.0.4
04:16:09 <mm_freak_> therp: package versions?
04:16:12 <therp> yes
04:16:18 <typoclass> > (\x -> x * x) 4 -- zacts: here is a more direct translation of (lambda (x) (* x x)). we write \ for a corny ascii-art approximation of λ :-)
04:16:19 <lambdabot>   16
04:16:20 <mm_freak_> therp: agda doesn't have packages
04:16:28 <int-e> @type \a b c -> let i = id in (i `asTypeOf` a) (i `asTypeOf` b) (i `asTypeOf` c) ()
04:16:29 <lambdabot> (((() -> ()) -> () -> ()) -> (() -> ()) -> () -> ()) -> ((() -> ()) -> () -> ()) -> (() -> ()) -> ()
04:16:37 <therp> mm_freak_: I don't mean packages then.
04:16:41 <typoclass> int-e: thanks for clearing that up :-)
04:16:59 <int-e> typoclass: ;-)
04:17:15 <mm_freak_> therp: there are no module versions…  you have module search paths and then modules are contained in files of the same names
04:17:19 <mm_freak_> nothing fancy
04:17:33 <therp> mm_freak_: x depends on y-1.0. z depends on y-2.0. assume you want to use x and z. most module systems can't do that..
04:17:40 <typoclass> zacts: (oh excuse me, when i said 'form', that's not a technical term (like in lisp i think?). i meant it just colloquially)
04:17:49 <zacts> oh cool
04:18:20 <therp> mm_freak_: ok. got it
04:18:46 <zacts> so far haskell seems very lispy
04:19:17 <mm_freak_> zacts: that impression is misleading…  haskell is really nothing like any of the lisps
04:19:19 <typoclass> :t map
04:19:20 <lambdabot> (a -> b) -> [a] -> [b]
04:19:28 <typoclass> zacts: lisp can't do this ^^
04:19:28 <mm_freak_> zacts: and that's not about syntax, but the way you write programs
04:19:30 <therp> my favorite module system is nodejs'. granted javascript doesn't require much as a language statically, but the usability of it the easyness of deployment is just remarkable slick.
04:19:53 <zacts> oh I see
04:19:56 <mm_freak_> therp: does it have any advantages over haskell's?
04:20:08 <therp> typoclass: you are saying that lisp can't do map?
04:20:17 <quchen> therp: It can't do a type-safe map.
04:20:39 <typoclass> therp: what's an advantage of the module system? (i'm not familiar with nodejs)
04:20:45 <mm_freak_> typoclass: racket has a typed dialect, so it's not strictly correct what you say
04:20:54 <typoclass> therp: no, sorry. i meant most lisps don't have types
04:22:39 <quchen> Haskell: map isTrue [True, False, "True"] -- BEEP that list has different things in it  --  Scheme: (map isTrue (#t #f "#t") ==> (#t, #f, #t)
04:22:42 <therp> so nodejs first is clever where to search for its modules. if you put a "require('module')" into a file it will take that files location and look for a node_modules/ subdir. if it can't find it, it will do one step up directory wise and redo. if it fails it goes to some global search dir. the neatness of this is that module can have local copies of the dependencies in the versions that they need
04:23:28 <therp> yes this gives lower reuse, but in ages like these code size vs. data size doesn't really matter anymore. it is great to deploy in server type situations as you get guaranteed working configurations as intended by the module authors
04:23:37 <zacts> thanks, bye
04:24:18 <merijn> typoclass: Let me drop a historical knowledge bomb on you
04:24:30 <merijn> typoclass: w.r.t "we write \ for a corny ascii-art approximation of λ "
04:24:52 <therp> ah, and I forgot to tell, you need to reference moduels by a variable, so most nodejs files will start out with "var http = require('http')"  and then you would use the functions/objects within the http module as http.get http.put, etc.
04:25:02 <quchen> Speaking of deployment: Is LLVM still portable, or already platform-dependent? Hence, would distributing programs in LLVM intermediate form be an option for deploying Haskell programs to different platforms?
04:25:06 <merijn> typoclass: \ is the original Church notation, the printer didn't have a proper/good looking \ so they picked λ as a closest subsitute
04:25:14 <mm_freak_> therp: i don't see any advantages over haskell's module system there
04:25:21 <elliott> merijn: not quit.
04:25:22 <elliott> e
04:25:27 <elliott> the original notation was ^-accent, I believe.
04:25:28 <elliott> and then caret.
04:25:32 <mm_freak_> (much less over agda's)
04:25:54 * quchen decides to ignore elliott's facts because merijin's story sounds very nice.
04:26:25 <therp> mm_freak_: haskell nor agda can load multiple revisions of the same module.
04:26:26 <merijn> ok, Church's notation (not original) for the paper used \
04:26:43 <elliott> do you have a source? I've never heard that
04:26:51 <therp> mm_freak_: that's pretty important if you want to use it for production.
04:27:01 <typoclass> merijn: hehehe :-) not sure what to do with that information, but that's a cute story
04:27:04 <merijn> elliott: I'm a credible source :)
04:27:05 <mm_freak_> therp: maybe that's important in nodejs
04:27:23 <elliott> merijn: ok, well I don't believe you :)
04:27:27 <mm_freak_> therp: then haskell can actually do it, but you get linker warnings, because it's an unsafe thing to do
04:27:32 <therp> mm_freak_: no, nodejs in important for production because it can do that. not the other way round :)
04:27:50 <mm_freak_> therp: and the comparison doesn't even apply to agda, where you can load from pretty much where you want, including the same module of the same version 100 times
04:28:05 <Lethalman> luite, hi, what about blaze-html in ghcjs? is there any possibility to get such libraries working in ghcjs seamlessly or things are hard?
04:28:19 <typoclass> therp: hm! interesting. "var http = ..." sounds vaguely like "import qualified Something as Http" :-)
04:28:30 <mm_freak_> therp: are you saying that haskell is not important for production, because it emits compiler warnings?
04:28:54 <therp> typoclass: almost yes, but the part the goes after as is not a variable, but what, an environment qualifier?
04:29:19 <therp> typoclass: in nodejs, it's a plain variable that can be passed around. for instance to higher order function. in fact, it's just an object.
04:29:25 <typoclass> therp: yes, it's not a variable in haskell, it's syntactically different
04:29:46 <mm_freak_> therp: the equivalent in haskell is to write a function, not a module
04:30:09 <mm_freak_> and that function can even take arguments =)
04:30:17 <merijn> elliott: That's a shame, cause I wasn't right :<
04:30:20 <quchen> merijn: I'm looking at "A set of postulates for the foundation of logic" right now, and it uses properly typeset lambdas.
04:30:21 <therp> mm_freak_: how can I import multiple versions of something?
04:30:27 <mm_freak_> therp: you don't
04:31:04 <mm_freak_> therp: you're asking a question along the lines of:  "how do i destructively update a variable?  haskell must be stupid, because i can do this easily in javascript!"
04:31:42 <therp> I fail to see how I asked that.
04:31:52 <merijn> quchen: I'm a big fat liar: http://technicae.cogitat.io/2012/12/the-secret-history-of-lambda.html
04:32:49 <mm_freak_> therp: well, you're declaring nodejs' module system as superior by a feature you wouldn't even use in haskell if it existed
04:32:59 <mm_freak_> (it exists, but nobody uses it)
04:33:00 <typoclass> quchen: well he was mentioning how church's manuscript looked before the typesetters got their hands on it
04:33:21 <mm_freak_> therp: what you are describing may make sense in nodejs, but not in haskell
04:33:30 <quchen> typoclass: Ah, dammit, I guess there's no Arxiv for 1930 preprint Latex :-(
04:33:54 <mm_freak_> therp: that's why it's related to the destructive-update-question
04:34:14 <typoclass> mm_freak_: as a clarification, i asked therp what's special about nodejs' modules. i don't think there was any intent of questions on destructive updates, or complaints
04:34:28 <merijn> First thing I do when I invent a time machine is going back to before Knuth writes TeX and say "for the next 50 years this program will be used, unchanged, to typeset mathematical texts. Are you sure you don't want to spend some time generating better errors?"
04:34:42 <taylorgb_> Hah
04:34:49 <mm_freak_> typoclass: "nodejs is better" is hardly a complaint…  it's a declaration =)
04:35:16 <merijn> mm_freak_: nodejs and JS don't really (read: really don't) have a module system in the first place
04:35:17 <quchen> merijn: Latex doesn't report errors. It reports.
04:35:30 <merijn> mm_freak_: You just have objects with associated methods that you pass around
04:35:39 <mm_freak_> merijn: indeed
04:36:12 <mm_freak_> if you really feel like it, you can emulate nodejs' "module system" through plugins or hint
04:36:15 <typoclass> mm_freak_: i can't find any claim of "nodejs is better"
04:36:41 <mr-> merijn: do you believe it is easier to build a time machine than to give tex nicer errors now?
04:36:43 * elliott is unsure of the point of this argument about an argument about module systems.
04:36:58 <merijn> mr-: Yes
04:37:04 <mm_freak_> typoclass: i'm fine with that =)
04:37:13 <quchen> cycle "meta" ++ "argument"
04:37:16 <merijn> mr-: TeX is still implemented in pascal!
04:37:34 <merijn> mr-: It ships with a pascal to C compiler just to be able to compile it
04:38:11 <typoclass> therp: anyway. it seems interesting that a module can have local modified copies of dependencies. need to think about that. i can see sometimes you want that; although (as you note) if overused, it might get confusing and hurt reusability
04:39:06 <mr-> merijn: too bad you are a "big fat liar"
04:40:25 <mr-> looks like it's not a lie.. amazing ;-)
04:40:36 <typoclass> elliott, quchen: not sure if it's a meta-argument; i just found it odd that mm_freak started criticizing therp for all kinds of things that (as far as i could tell) therp didn't say
04:40:36 <merijn> mr-: Well, I'm not 100% sure that it was pascal, but something equally old, at least
04:40:46 <Entroacceptor> merijn: web IIRC
04:40:59 <merijn> Entroacceptor: I'm pretty sure web came after TeX
04:41:13 <elliott> typoclass: I think if you look at your own message just now you will see that if it wasn't a metaargument before it is now :)
04:41:39 <merijn> Ah, you're right, it's WEB, which is a literate subset of pascal
04:43:27 <Rembane_> Thus, even more strange than Pascal.
04:43:29 <sanjoyd> Is there a clean way to pass in strings from C to Haskell without using the IO monad?  (clean == not using usafePerformIO)
04:43:50 <typoclass> sanjoyd: you mean in the ffi?
04:43:57 <merijn> sanjoyd: Yes, use the CString type
04:44:06 <luite> Lethalman: i think it already works, but that's probably a lib that you'd want to reimplement with a native js backend
04:44:11 <merijn> sanjoyd: Although you can't do anything with them without IO
04:44:19 <merijn> sanjoyd: So, really, no
04:44:51 <typoclass> is the question about calling haskell functions from c?
04:45:07 <sanjoyd> typoclass: essentially.
04:45:13 <sanjoyd> I'm trying to find out what kind of restrictions are there.
04:45:39 <merijn> sanjoyd: You have http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-String.html#t:CString
04:45:52 <merijn> sanjoyd: But reading the string will have to be IO
04:46:06 <merijn> sanjoyd: By why do you want no IO? You're calling from C anyway
04:46:23 <sanjoyd> Good questions. :)
04:46:32 <merijn> sanjoyd: FFI functions are allowed (and mostly expected) to have an IO a return value
04:46:58 <sanjoyd> merijn: just that I will have to have another thing to massage into whatever types I'm using.
04:48:00 <sanjoyd> typoclass: ref. your link -- I'm looking for a CString -> String; which doesn't seem to exist.
04:48:10 <merijn> sanjoyd: No, the FFI treats "IO CInt" as being CInt
04:48:26 <merijn> i.e. you don't have to care about the IO when calling it
04:48:38 <merijn> since C can only do IO actions anyway
04:49:03 <merijn> from C's perspective calling "Int -> Int" and "Int -> IO Int" are identical
04:49:19 <sanjoyd> But in a Haskell function foo :: CString -> XYZ, either XYX ~ IO x or foo has unsafePerfIO in it.
04:49:26 <merijn> sanjoyd: Yes
04:49:37 <sanjoyd> Which is what I want to avoid (for reasons not very clear to me atm).
04:49:48 <merijn> sanjoyd: C has IO everything, so really "Int -> Int" gets lifted into IO to be called from C
04:50:30 <merijn> sanjoyd: The IO distinction only makes sense from within haskell
04:50:35 <sanjoyd> Yes.
04:50:56 <merijn> sanjoyd: C can mutate state whenever it wants, so if the haskell function you export has type "CString -> IO Int" then why would C care?
04:51:12 <sanjoyd> Ah, I get what you're saying now. :)
04:51:49 <merijn> sanjoyd: So converting "foo :: CString -> IO Int" to "int foo(char *input)" is perfectly normal from C's perspective
04:52:58 <sanjoyd> So I don't really need to take care of the IO monad -- I can just let it propagate upwards and have C take care of it.
04:53:05 <merijn> sanjoyd: Yes
04:53:18 <sanjoyd> merijn: that'll work, thanks!
04:53:55 <typoclass> sanjoyd: in c, everything is in IO automatically. pure functions (functions that aren't in IO) are an invention of haskell :-)
04:54:16 <shachaf> No, they've been around long before Haskell.
04:55:25 <typoclass> shachaf: yeah, it was tongue in cheek. i meant most (all?) earlier programming languages don't make the IO-or-not distinction like haskell do
04:55:54 * hackagebot persistent 1.2.1.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.1.1 (MichaelSnoyman)
04:56:07 <merijn> typoclass: Lisp traditionally shows IO by ! in the name for destructive updates! (since thye had not typesystem to do it for them)
04:56:27 <typoclass> merijn: oh right, 'set!' and so on. good point
04:56:57 <merijn> jesus
04:57:06 <merijn> that last sentence has abysmal spelling
04:59:43 <typoclass> merijn: please refer to http://wordandimage.files.wordpress.com/2008/04/lolcats-kitty-pidgin.jpg?w=450
05:00:41 <elliott> thye lisperes had not typesystem, and yea verly, they suffered
05:00:45 <elliott> *verily
05:01:16 <kryft> much gnahsing of teeth
05:03:33 <merijn> argh!
05:03:46 <quchen> merijn: Writing docs again? :-)
05:03:47 <merijn> A pox upon the lack of proper ImpredicativeTypes!
05:04:25 <merijn> No
05:04:57 <merijn> Apparently I'm not allowed to runReaderT a value of type "forall t . ReaderT (Foo t) SomeMonad a"
05:06:10 <merijn> Why not :(
05:06:16 <merijn> Haskell, why you make me so sad :(
05:06:17 <quchen> Was about to ask that.
05:06:26 <quchen> Looks reasonable.
05:10:39 <shachaf> !list
05:10:40 <monochrom> shachaf: http://hpaste.org
05:10:59 <shachaf> monochrom: You should fix your links. hpaste.org has a new domain for now.
05:25:41 <Shou> Hi, how do I go about figuring out what's causing CPU usage spikes in Haskell software?
05:26:00 <typoclass> Shou: in general, profiling?
05:27:34 <quchen> Shou: What do you mean with "spikes"? Do you have a program that uses lots of CPU in short bursts, or just one where you'd like to know which parts use how much time?
05:29:28 <Shou> quchen, yeah, it uses lots of CPU in short bursts. It's just an IRC bot too, so I must have done something horribly wrong. I'm looking into profiling right now.
05:29:49 <int-e> Shou: could it just be the garbage collector?
05:30:19 <rootnode> hi
05:30:23 <lasticot> merijn: should I implement something else? do you have anything else I could implement that would give me some experience at coding with haskell ?
05:31:00 <Shou> int-e, well it could be, but I have no idea.
05:31:20 <merijn> lasticot: Eh, you could take a look at
05:31:23 <merijn> @where exercises
05:31:24 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
05:31:38 <merijn> lasticot: It depends what you want to program? :)
05:32:21 <merijn> Is there like an "mfix" that takes an initial value?
05:32:26 <quchen> Shou: For a first look, try the standard profiling approach. Compile with "-prof -auto-all", and run with "+RTS -P", then have a look at "*.prof" generated.
05:33:02 <elliott> merijn: is there a fix that takes an initial value?
05:33:27 <quchen> Shou: For a little bit more info, have a look at the RWH chapter on profiling. If that's still unhelpful, try criterion.
05:33:30 <merijn> elliott: I guess iterate?
05:33:36 <elliott> @hoogle iterateM
05:33:36 <lambdabot> No results found
05:33:38 <elliott> hmm.
05:33:41 <elliott> monad-loops has it probably
05:34:00 <merijn> oh, there we go
05:34:01 <merijn> iterateM_ :: Monad m => (a -> m a) -> a -> m b
05:34:05 <lasticot> merijn: thank you! that is exactly what i needed !
05:36:35 <elliott> merijn: much closer to forever than mfix
05:36:40 <elliott> mfix is quite a different beast indeed, hence my question
05:36:42 <Shou> quchen, I'll try those. Thanks~!
05:37:14 <acube> @hoogle mfix
05:37:14 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
05:37:14 <lambdabot> Data.ByteString.Builder.Prim primFixed :: FixedPrim a -> (a -> Builder)
05:46:49 <mm_freak_> lambdabot hangs
05:46:49 <mm_freak_> > ()
05:46:54 <lambdabot>   ()
06:11:43 --- mode: calvino.freenode.net set +o ChanServ
06:12:45 <int-e> wow, services running amok.
06:35:55 * hackagebot computational-algebra 0.2.0.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.2.0.0 (HiromiIshii)
06:47:20 <lasticot> how do I know which module to import when I want to use a specific function? In particular which module should I import if I want to use hGetContent?
06:47:40 <merijn> lasticot: Usually I just search hoogle and look what module that finds
06:47:51 <merijn> @hoogle hGetContents
06:47:52 <lambdabot> System.IO hGetContents :: Handle -> IO String
06:47:52 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
06:47:52 <lambdabot> Data.ByteString.Lazy hGetContents :: Handle -> IO ByteString
06:48:40 <lasticot> merijn: ok thank you
06:51:21 <klrr> anyone know a project that needs contibutors?
06:52:06 <ion> lens!
06:52:47 <klrr> i dont get what a les is or is useful for though :P
06:56:22 <typoclass> klrr: lenses are essentially getter and setter functions, as far as i can tell
06:56:41 <Botje> lenses are great for turning haskell into perl.
06:57:20 <elliott> "lens" isn't about lenses, though.
06:57:36 <Sculptor> yo
06:58:31 <typoclass> elliott: is it about keeping edk off the street, roaming day and night and scaring the townsfolk?
06:59:23 <elliott> yes.
07:00:42 <ion> lenswardk
07:01:06 <typoclass> elliott: well the townsfolk are a bunch of dynamically typed fellow. let them eat cake
07:05:20 <sopvop> class HasStorableKey ( a :: (* -> *) -> *) where   type StorableKey a; storableKey :: Lens (a f) (a g) (f (StorableKey a)) (g (StorableKey a))
07:05:27 <sopvop> How close to edwark am I?
07:08:51 <pxqr> that's a modern approach to configure long running (for e.g. daemon) haskell applications?  configurator, dyre, something else?
07:13:21 <AfC> pxqr: are you asking how you would pass initial configuration parameters? i.e. a file in ~/.config/ , etc
07:14:47 <pxqr> I'm asking how to do this nice and at the same time to not reinvent things already done
07:15:24 <pxqr> and, yes I want dynamic reconfiguration; the both libraries do that
07:16:25 <pxqr> however I doubt I need Haskell for configuration;
07:17:01 <pxqr> any projects that uses dyre? except hbro
07:17:55 <Kinnison> I think Taffybar uses Dyre
07:18:16 <pxqr> yes
07:18:28 <typoclass> pxqr: dynamic as in, restart the daemon with the new config if changed?
07:18:42 <elliott> yi uses dyre
07:18:57 <pxqr> typoclass: I don't think it's a good idea for bittorrent client
07:19:34 <typoclass> pxqr: erm. right :-)
07:20:02 <typoclass> pxqr: ... well, xmonad is slightly more clever about it. it passes a bunch of old state into the new instance as a command line parameter
07:20:20 <pxqr> however Haskell scripting might be useful for things like categorization (e.g. this is video -> store to video folder)
07:20:57 * hackagebot HaTeX 3.6.1.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.6.1.0 (DanielDiaz)
07:21:09 <typoclass> pxqr: but open tcp connections that should be carried over from the old to the new process would require ... i don't know what. probably doable with exec instead of fork?
07:21:37 <klrr> jaspervd1: how do i write <link rel="stylesheet" href="/public/css/highlight.css" >
07:21:45 <klrr> jaspervd1: in Blaze-html?
07:23:31 <merijn> typoclass: exec and fork are completely unrelated things and neither touch open network connections
07:23:44 <merijn> (exec doesn't create a new process)
07:23:51 <pxqr> typoclass: there are some params which we can't change dynamically as well
07:23:57 <typoclass> merijn: yes
07:25:11 <typoclass> merijn: well i wouldn't say they are quite that unrelated. the standard way (only way?) of starting a program in unix is fork then exec, isn't it
07:25:45 <typoclass> merijn: but yes, i thought for a moment that with fork the child would not have access to the tcp connections. yes that's wrong afaik
07:26:57 <merijn> fork keeps all open filedescriptors open
07:27:17 <typoclass> merijn: yes it does. i misremembered
07:27:44 <Kinnison> Does anyone know of a more up-to-date comparison of happstack, snap, yesod etc than http://www.haskell.org/haskellwiki/Web/Framework_survey ?  Particularly I'm looking at websocket support etc.
07:27:47 <merijn> Which means you can do cool things! Like reboot a server, loading new code without clients noticing!
07:27:56 <merijn> Unfortunately ZMQ doesn't support that :(
07:31:00 <luite> Kinnison: yesod supports websockets (but it feels a bit tacked on), i think snap does too (no idea about the api). last time i heard, happstack would get websockets when they switch to the new webserver
07:32:43 <luite> Kinnison: most of that info there is not terribly relevant htough. all web frameworks can use acid-state for example, it's just a haskell library
07:33:56 <Kinnison> luite: Aye, I'm just pondering a framework and I know I'm *likely* (but not guaranteed) to want websockets
07:37:29 <luite> Kinnison: hmm, yesod and snap should do then. perhaps ask stepcut about happstack's new server
07:39:41 --- mode: calvino.freenode.net set +o ChanServ
07:57:30 <pentace> As far as I can see the Text.Parsec module re-exports Text.Parsec.String and -.ByteString which both define the type Parser. But then why is no such type visible? I guess there even should be a naming conflict.
07:58:32 <Peaker> pentace, it's only a conflict if they're from different definitions
07:58:51 <pentace> Well they are, no?
07:59:09 <Peaker> pentace, Text.Parsec probably re-exports the same definition it imports from Text.Parsec.String?
07:59:37 <pentace> It re-exports the complete module
08:00:10 <pentace> so "type Parser = Parsec String ()" and "type Parser = Parsec ByteString ()" but neither is visible
08:01:08 <quchen> pentace: It hides the "Parser" data from the submodules. http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/src/Text-Parsec.html
08:01:40 <quchen> You'll have to import Parsec.* manually if you want to parse something, depending on what your source is
08:02:02 <pentace> hm, that's even more confusing
08:02:29 <quchen> Well, if you want to parse String, import Parsec and Parsec.String.
08:02:30 * Philippa_ always feels guilty about how this particular set of hysterical raisins got handled
08:03:04 <pentace> Such, but why are these modules exported at all when all types and functions are hidden?
08:03:09 <pentace> *Sure
08:03:40 <Philippa_> pentace: Parsec.String and relatives there are essentially backwards compatibility imports for people with code written for Parsec 2
08:03:41 <pentace> Ah, there's a Stream instance
08:03:52 <Philippa_> older versions only worked on String
08:04:24 <Philippa_> the type synonyms let you add an import and use your old Parsec 2 type annotations as-was
08:04:41 <quchen> Parsec is pretty quirky in some places, but it's not bad enough to make someone write a NewParsec. :-)
08:05:09 <pentace> I guess that's also the reason for the export of <|>, many, etc which is also very annoying :S
08:05:39 <quchen> Yeah, that's another thing. Parsec's <|> has different fixity than Alternative's.
08:05:56 <quchen> We had a discussion here yesterday where someone pointed out that Parsec.many is not Alternative.many
08:06:42 <pentace> So hiding Parsec's many would make the parser fail?
08:07:21 <Philippa_> quchen: oh, ouch
08:07:37 <Philippa_> pentace: the problem's mostly that Parsec 3 predates Control.Applicative's popularity
08:07:41 <quchen> Philippa_: I'm secretly hoping the AMP gets rid of that
08:07:48 <Philippa_> *nod*
08:08:03 <quchen> ... but I feel like "import Prelude hiding (...)" is coming
08:08:05 <quchen> :-s
08:08:12 <Philippa_> quchen: one reason we don't get a NewParsec is that last time someone made that happen everything went to shit on hackage for a while :p
08:08:27 <quchen> Philippa_: I wasn't around for that.
08:08:41 <quchen> Maybe I should use my naive noobieness again to do something like that. Worked well last time.
08:08:48 <Philippa_> it was the first time a really commonly-used library had two major versions extant with the newer one underdeveloped
08:09:13 <quchen> Parsec feels pretty large though.
08:09:16 <Philippa_> thankfully most of the flames didn't get sent my way despite the fact I proposed and mentored the SoC project responsible :p
08:09:19 <Philippa_> it is, yeah
08:09:26 <quchen> I have no idea how much code it actually is.
08:09:32 <quchen> My gut tells me writing it again is a pain though.
08:09:52 <quchen> And since it's a standard lib it needs to be super stable and performant etc
08:10:11 <quchen> And this is where having two <|> and "many" starts being not so bad :>
08:10:13 <Philippa_> oh, I'm not sure it's actually >10KLoC large? It's "you're not gonna do it in a weekend" large, though you can certainly get an inefficient-but-not-that-bad set of core prims and some basic combinators in that time if suitably caffeinated
08:10:31 <Philippa_> quchen: yeah, many is in the Alternative class precisely because of cases like that!
08:10:58 <quchen> The semantics defined for some/many are pretty weird though
08:11:14 <quchen> "Least solution for ..." - ugh
08:11:17 <Philippa_> pentace: sorry, I'm probably derailing quchen from actually helping you here? It's been a while here, I've forgotten enough to be dangerous
08:11:23 <Philippa_> (I'm *not* the maintainer!)
08:12:07 <elliott> I don't think Parsec is particularly well optimised or anything.
08:12:22 <elliott> my mental model of Parsec is "the most boring input-type-generic parser combinator library you can think of".
08:12:41 <quchen> It's also very useful :-(
08:12:45 <Philippa_> so these days that's almost true?
08:12:47 <pentace> So the answer is import Text.Parsec hiding ((<|>)), import Control.Applicative hiding (many), I guess :p
08:12:50 <CaptainK> when you have lists within lists, mapM_ works great on the first pass, but does it work nested?
08:13:05 <Philippa_> CaptainK: yes
08:13:14 <Philippa_> also: you have ghci, use it? :p
08:13:31 <quchen> pentace: In my experience, you can use either (<|>). I'm just using Alternative's because I'm on a rebellion.
08:13:32 <CaptainK> mapM_ (mapM_ print lines)
08:13:46 <CaptainK> to get words
08:13:55 <CaptainK> for example
08:14:07 <Philippa_> elliott: so Parsec is moderately optimised for a library that's as "powerful" as it is?
08:14:09 <supki> @ty (mapM_ . mapM_)
08:14:10 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m ()
08:14:14 <pentace> quchen: Yes, but I'm getting in trouble as I need <|> for other things too
08:14:28 <quchen> :t mapM_ . mapM_  -- CaptainK
08:14:29 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m ()
08:14:34 <Philippa_> if I didn't know edwardk I might use a stronger word than "moderately": substantially beating it while retaining the power level is still research work, though
08:15:13 <Philippa_> its niche is definitely "if all you need is a basic parser, if you can't write it in this you can't write it in anything" though
08:15:24 <CaptainK> I need to format my data properly, its complaining
08:15:40 <Philippa_> with a side-order of "if you're willing to get creative with effects you can factor all kinds of weird shit, uh, effectively"
08:16:43 <Philippa_> ...y'know, someone should dig up an IRC stats analyser just so I can check what percentile I'm in for swearing and swearing per line these days. What with the responsibility of being an op and all that
08:16:44 <c_wraith> I really hate Parsec's try, though
08:16:54 <Philippa_> c_wraith: yeah, it's the best and worst thing about it
08:17:01 <sopvop> remind me which class does :: (b -> a) -> f a -> f b
08:17:04 <elliott> Philippa_: fair
08:17:11 <typoclass> sopvop: Functor?
08:17:14 <ocharles> sopvop: Contravariant
08:17:23 <sopvop> ocharles: thanks!
08:17:27 <typoclass> sopvop: wait wait, i did it wrong
08:17:31 <elliott> Philippa_: some of the choices it makes are kind of hostile to any kind of low-level optimisation in the first place though, so that's not necessarily saying much :)
08:17:40 <Philippa_> c_wraith: I do wonder if you could effectively let parsers switch between LL(1)-by-default and LL(omega)-by-default within themselves in a NewParsec
08:17:40 <sopvop> bonus points for package it lives in
08:17:46 <ocharles> sopvop: contravariant
08:17:51 <sopvop> haha
08:17:54 <ocharles> these are easy questions, I just have to type the same thing!
08:18:19 <Philippa_> elliott: right, the parsing strength hits you pretty hard and the generality of streams means that if you want to do smart things there you'd best be good with rewrite rules
08:18:44 <Philippa_> that said: edwardk *has* made substantial improvements on what can be done at that level
08:19:16 <typoclass> Philippa_: i (for one) have always enjoyed your way of talking :-) i never noticed anything regarding swearing being a problem
08:19:24 * typoclass purrs
08:20:02 <ocharles> Philippa_: improvements in trifecta?
08:20:08 <ocharles> or in general research?
08:20:08 <Philippa_> typoclass: I try to be moderately careful about when I swear /at/ people, but I'm definitely outside many people's notion of "professionality"
08:20:45 <Philippa_> ocharles: the former for certain. I haven't done the archaeology to know how much of trifecta is novel technique vs novel recombination
08:21:08 <Philippa_> (the latter often involves noticing that a technique is more general than the originator realised: edwardk is *good* at that stuff)
08:21:17 <quchen> Philippa_: This is not a business meeting with 50 year old bosses.
08:21:28 <typoclass> "ach crivens!"
08:21:41 <Sonarpulse> I'm trying to use the Statistics package (http://hackage.haskell.org/package/statistics)
08:21:57 <elliott> oh fudge, one of these days I'm going to have my ops revoked for all my gosh darned swearing. fiddlesticks.
08:22:01 <ocharles> Philippa_: *nod*
08:22:06 <Philippa_> quchen: it's not, no. OTOH, I do know people who find my casual use of language hard going until they knew me, and some who've not bothered because of that. It'd be a shame to do that about an entire chan
08:22:07 <Sonarpulse> anyone know if there is any built-in support for a numerical distrubtion?
08:22:17 <ocharles> elliott: can you tone that down? I find that offensive
08:22:30 <typoclass> elliott: you sound like a 1950s housewife desperately trying to be "proper"
08:22:35 <Sonarpulse> (on a finite set)
08:22:46 <mapreduce> oh, sugar!
08:23:00 <Philippa_> though in fairness, I'd be more worried about my tendency to play "if I'm one step above your level I still have the moral high ground" in flamewars :p
08:23:28 <Sonarpulse> alternatively, any way to find the *nearest* key in a Data.Map in log(n) time?
08:23:34 <Philippa_> (I do it by way of lampshading and playing to the audience, but still: it'd be entirely reasonable for other ops to ask me to not do it!)
08:24:06 <Philippa_> Sonarpulse: huh. I don't know of it myself, but good question
08:24:18 <quchen> Sonarpulse: Maybe split is for you? http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map-Lazy.html#v:split
08:24:34 <elliott> I hereby grant Philippa_ a one year unrevokable license to continue acting as a Philippa_ acts.
08:24:50 * typoclass . o O ( must not paste lolcat that has its head in a lampshade ... )
08:24:51 * elliott performs the Ritual.
08:24:55 <Philippa_> quchen: applied recursively? Beats nothing, I guess
08:25:05 <quchen> Sonarpulse: Or maybe the lookup* functions
08:25:24 <Philippa_> does IntMap have equivalents?
08:25:26 <Sonarpulse> split is good
08:25:30 <Philippa_> if so, that might be helpful/useful
08:26:52 <gspr> This might be a stupid question, but: Is  convert :: (Vector v a, Vector w a) -> v a -> w a  from vector O(n) also if v and w happen to be the same?
08:28:15 <Philippa_> gspr: probably - it has no way to check
08:28:24 <Sonarpulse> interesting, I feel like iwas reading some very old map docs
08:28:29 <Sonarpulse> which didn't have lookupGT
08:28:41 <Sonarpulse> which is *exactly * what I want
08:29:06 <CaptainK> getting [[Char]] -> IO () where I need [[Char]] -> [()]
08:29:16 <CaptainK> (mapM_ print (mapM_ print lines))
08:29:38 <ion> mapM_ print =<< mapM_ print lines
08:29:41 <typoclass> Sonarpulse: if the key space is not too big, you could do it at insertion (not retrieval). e.g. if i have the map (0, "sharp"), (15, "quarter past"), (30, "half past"), (45, "quarter to"), then why not create a map that has all 60 keys (0..59) and those 4 values
08:29:43 <ion> @type (=<<)
08:29:44 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:29:46 <Eduard_Munteanu> CaptainK: [[Char]] -> [()]  would be rather useless
08:29:54 <Botje> CaptainK: err, why do you want to print a bunch of () ?
08:30:11 <CaptainK> that is from the eror message what it is expecting
08:31:30 <quchen> (mapM_ . mapM_) print [[1,2,3]]  -- CaptainK
08:31:59 <ocharles> :t (mapM_ . mapM_) print
08:32:00 <lambdabot> Show a => [[a]] -> IO ()
08:32:07 <ocharles> nmo
08:32:09 <ocharles> nom*
08:32:31 <quchen> Glad you corrected that typo, otherwise it would've been incomprehensible. ;-)
08:35:13 <Sonarpulse> typoclass: problem is I'll be generating random numbers, so the keys are doubles
08:35:22 <Sonarpulse> well bounded doubles, but still
08:39:03 <qoph418> Hi everyone. I just recently discovered Haskell through John Macfarlane and his apps and Xmonad. Also, I'm an org-mode user and inevitably learned about the incredible concept of functional programming while reading material on org-babel. The problem is... I'm not a programmer. Not really anyway. I do some TSQL, HTML and Bash/Csh scripting at work/home but I do not properly have a real development language under my belt. Can I... sh
08:39:03 <qoph418> I... start with Haskell? Please :)
08:39:39 <elliott> you got cut off at "Can I... sh", fwiw
08:39:48 <taylorgb_> of course you can
08:40:11 <typoclass> qoph418: sure! :-) welcome. here is some introductory reading
08:40:13 <typoclass> @where lyah
08:40:13 <lambdabot> http://www.learnyouahaskell.com/
08:40:14 <elliott> haskell is a pretty good first language, I think, in that it's probably easier to learn Haskell the less imperative programming experience you have
08:40:34 <CaptainK> > (mapM_ . mapM_) print [[1,2,3]]
08:40:38 <lambdabot>   mueval-core: Time limit exceeded
08:40:43 <gspr> Philippa-: I guess I was just imagining there'd be some rewrite rule or something that'd fire when you use convert on some concrete instances
08:40:52 <qoph418> elliott: ... Start with haskell :D
08:41:07 <typoclass> qoph418: oh, also have a look at tryhaskell.org
08:41:10 <qoph418> typoclass: Thanks ^_^
08:41:57 <qoph418> typoclass: I will! But could you briefly tell me why you think it's a good idea, please? Haha.
08:41:57 <blume> what about real world haskell?
08:42:07 <blume> that's the book i just started reading.
08:42:32 <elliott> blume: that's good too. I personally generally recommend people read LYAH first since I think it's slightly better as a first introduction, but there are people who feel the opposite way.
08:42:38 <qoph418> lambdabot: Thank you. :)
08:43:02 <elliott> @botsnack
08:43:03 <lambdabot> :)
08:43:09 <blume> alright, i'll have a look into it then
08:43:10 <ion> @botsmack
08:43:10 <lambdabot> :)
08:43:15 <haasn> oh my
08:43:15 <typoclass> qoph418: tryhaskell lets you play around directly in the browser (with no installing). it also has some lessons
08:43:20 <qoph418> elliott: Do you recommend that book to non-programmers?
08:43:44 <blume> 'real world haskell' is not aimed at non-programmers, qoph418
08:43:46 <elliott> qoph418: I think it's intended to be readable even if you have little programming experience
08:43:50 <elliott> (talking about LYAH)
08:43:54 <haasn> Aren't language introductions sort of by definition aimed at non-programmers (of the language)?
08:44:11 <ion> qoph418: While you’re reading LYAH, be sure to ask here when you need clarification with anything.
08:44:25 <elliott> also, I think Hutton's Programming in Haskell (paid book, not online or anything) is aimed at non-programmers and comes highly recommended by a lot of very smart people. I haven't read it myself though.
08:44:59 <qoph418> typoclass: Neat! I 'pacman -S'd haskell last night and I'm pretty sure I got the "platform" package with that.
08:45:04 <qoph418> elliott: Thank you.
08:45:24 * qoph418 quickly copy/pastes into his notes
08:45:25 <typoclass> qoph418: right, the platform is most likely what you want
08:45:51 <blume> also, -Syu please <3
08:45:54 <CaptainK> quchen: thanks, that configuration of mapM properly unzips the data!
08:47:45 <Bor0> consider I have something like p = Point {x = 4, y = 3}. how can I extract p.x ? and my second question is, can I use pattern matching for Point::x ?
08:47:53 <elliott> x p
08:47:57 <Sonarpulse> is there any vector-based map with lookupGT (I assume that rules out hash tables)? I don't need to modify the map, and could therefore benefit from some cache locality
08:47:58 <elliott> and you can pattern match like
08:48:07 <elliott> foo Point{x = theX} = ... theX ...
08:48:38 <qoph418> Lost my connection :(
08:49:16 <Bor0> hmm, so when I define Point {x, y} I get x and y as functions too
08:49:31 <typoclass> Bor0: true
08:49:31 <Eduard_Munteanu> Bor0: yes
08:49:38 <qoph418> Pacman -Syu? Facepalm. I'm too nub. Thought that was a maintenance command (update package dbs every so often)
08:49:39 <Bor0> hah, neat! thanks
08:49:57 <qoph418> Arch-bro-fist :p
08:50:56 <typoclass> qoph418: here is the logs of the channel, by the way tunes.org/~nef/logs/haskell/?C=M;O=D
08:51:07 <merijn> Bor0: You can see it in ghci, just import the definition of Point and type ":t x", the downside is that you do get name clashes if you have the same field in different records
08:51:22 <pentace> Bor0: You can also pattern match (Point x _ ) = ... x ... I think
08:51:40 <blume> ^_^
08:51:54 <merijn> pentace: Related point, you can pattern match any normal constructor with "Constructor {}" too!
08:52:05 <pentace> yep
08:52:22 <Bor0> pentace: yes, but I needed something like Point{x = theX} in case when Point has a lot of attributes
08:52:29 <merijn> > (\Just{} -> 1) (Just 5)
08:52:30 <lambdabot>   1
08:52:32 <qoph418> typoclass: :o how incredibly generous... Thanks!
08:52:40 * typoclass purrs
08:52:53 <ion> The third Google result: <http://sources.haskell.cz/Programming%20in%20Haskell.pdf>. “Draft: not for distribution”.
08:53:14 <qoph418> Switching to my PC now! bbiab
08:54:11 <ion> Haskell je moderní, čistě funkcionální programovací jazyk, založený na lambda kalkulu a teorii kategorií. Je to jazyk silně typovaný a referenčně transparentní s líným vyhodnocováním.
08:54:23 <ion> lambda kalkulu a teorii kategorií ftw.
08:54:29 <Eduard_Munteanu> Heh, yeah.
08:55:09 <Eduard_Munteanu> I'll remember "referenčně transparentní" too. :D
08:55:36 <ion> In Finnish: lambdakalkyyli ja kategoriateoria
08:56:16 <typoclass> ion: urgh, is that how the book starts?
08:56:43 <ion> There’s also a preview of the non-draft version here. http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695
08:57:20 <Nisstyre-laptop> Is there a general pattern of using lenses to unify the values of two identical types? Say I have data Foo = Foo Int Int, and I have two Foo's, and I know what a "default" Foo is, is there an easy way to use lenses to combine the two and unify if one of the value is a "default" value? Assume I have a function called "def" that is polymorphic in its return type and always returns the default value of that type.
08:57:43 <elliott> the introduction seems perfectly fine, skimming it. though maybe I should buy a copy rather than looking at this probably-illegal draft.
08:57:54 <Bor0> I can't get this to work: asdf' = \(Point{x = theX}) -> T
08:58:03 <ocharles> Nisstyre-laptop: what does "unifying" mean?
08:58:11 <ocharles> Nisstyre-laptop: because you seem to be describing a monoid
08:58:15 <Nisstyre-laptop> ocharles: merging them
08:58:18 <osa1_> I have a function defined in a `where ...` syntax and I want to learn it's type, is there a way to do that?
08:58:28 <elliott> hah, maybe this is where Cale got his "double" evaluation trace example from
08:58:28 <typoclass> ion: that looks vastly better than the earlier text!
08:58:35 <ocharles> Nisstyre-laptop: well mappend :: a -> a -> a and mempty :: a
08:58:49 <ion> bor0: It takes the value of the theX field of the Point parameter and binds it to x.
08:59:01 <ocharles> Nisstyre-laptop: not sure how lenses would come into this though
08:59:10 <Bor0> I had -> T instead of theX. sorry
08:59:12 <Bor0> it works.
08:59:15 <Nisstyre-laptop> ocharles: okay, but I still have to write an instance where I check if every constructor is the default of that and replace it with the other one right?
08:59:20 <typoclass> osa1: i don't really think so, but you could always do "where f x y = ... ; f :: String" and the compiler will tell you "was suposed to be String, but actually it was ____"
08:59:24 <typoclass> *supposed
08:59:40 <Nisstyre-laptop> ocharles: it comes into it in the actual "setting" of the fields or whatever of the type
09:00:04 <ocharles> Nisstyre-laptop: yes, but if every field in your structure is an instance of monoid, you can derive a monoid instance "for free" with generics
09:00:06 <osa1_> typoclass: that's what I'm doing right now but I couldn't figure out the type error in my case
09:00:16 <ocharles> Nisstyre-laptop: http://ocharles.org.uk/blog/posts/2013-04-09-data-type-generic-programming.html
09:00:17 <Nisstyre-laptop> ocharles: okay, I'll think about doing it that way
09:01:36 <ion> http://naucte-se.haskell.cz/
09:02:25 <typoclass> osa1_: maybe some type synonyms are interfering ...? if all else fails, put the code and error on hpaste and ask here
09:02:28 <typoclass> @where paste
09:02:28 <lambdabot> http://paste.tryhaskell.org/new/haskell
09:02:57 * ksf imagines a library based upon transformations between GHC.Generics enabled near-equivalent ADTs
09:03:35 <ksf> things like adding and removing cases, adding and removing fields from the products.
09:03:46 <osa1_> hpaste is down?
09:04:09 <enthropy> ksf: have you seen http://www.andres-loeh.de/GenericGenericProgramming/ ?
09:04:10 <elliott> hpaste is relocatd
09:04:11 <elliott> e
09:04:36 <osa1_> typoclass: http://paste.tryhaskell.org/90692
09:04:41 <ksf> enthropy, nope
09:05:20 <osa1_> unrelated: is there a way to specify socket file in vim-hdevtools plugin? for some reason my hdevtools doesn't run with default socket file(I'll try removing it but I don't know default socket path)
09:05:48 <Nisstyre-laptop> ocharles: I'm not sure if all of my field types are actual instances of Monoid. I can do an identity that's just def `mappend` a = a or a `mappend` a = a, but b `mappend` a should "fail" since they can't be unified/merged
09:06:32 <CaptainK> any know of an irc channel for Sublime?
09:06:37 <tac> What is the standard way to wait on a therad in Haskell?
09:06:37 <typoclass> osa1_: i think you have ScopedTypeVariables turned on or some such. the 'a' inside of the where block, and the 'a' in line 1 of the paste, aren't independent. they are the same thing. try writing 'x' or some other unused letter
09:06:40 <ocharles> Nisstyre-laptop: then you can't write a -> a -> a
09:06:47 <ocharles> Nisstyre-laptop: only a -> a -> Maybe a
09:06:51 <Nisstyre-laptop> ocharles: true, it would have to be wrapped in a Maybe
09:06:53 <Nisstyre-laptop> yeah
09:07:06 <ocharles> Nisstyre-laptop: I don't know a general way of capturing that
09:07:10 <Nisstyre-laptop> fair enough
09:07:14 <osa1_> typoclass: then I'm getting Couldn't match expected type `x' with actual type `a'
09:07:47 <osa1_> typoclass: I have DeriveFunctor, FlexibleInstances and ViewPatterns enabled
09:08:16 <typoclass> tac: possibly the stuff they're doing at the end of http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html ?
09:08:19 <typoclass> osa1_: oh
09:08:20 <ksf> enthropy, is the library online yet?
09:08:28 <ksf> "structured" has abysmal googlability.
09:08:40 <osa1_> typoclass: bug?
09:08:55 <osa1_> it works if I remove the type annotation
09:09:03 <tac> typoclass: :<
09:09:10 <enthropy> ksf: there's "Code bundle accompanying the paper" http://www.andres-loeh.de/GenericGenericProgramming/ggp.zip
09:09:27 <tac> There's really no legitimate waitForThread? :(
09:10:16 <merijn> In a library, possibly
09:10:22 <merijn> It's not very hard to implement
09:11:12 <typoclass> osa1_: hm ... maybe try pulling f out of the where block, to top level? you need to add an argument 'fn', but that shouldn't be hard
09:11:27 <typoclass> osa1_: (then you can do ":t f")
09:11:30 <ocharles> tac: I just tend to use a semaphore
09:11:57 <osa1_> good idea
09:12:44 <ocharles> tac: start with 0 and immediately wait, have the other thread signal when it's done
09:12:55 <ocharles> does require implementing a bit of machinery though
09:13:06 <osa1_> typoclass: uh, it shows fff :: (a -> l) -> a -> ListF a l, which means my type annotation is correct
09:13:09 <osa1_> a == l in my case
09:13:14 <osa1_> because f :: a -> a
09:13:16 <lasticot> hello, I've got this error:  Illegal datatype context (use -XDatatypeContexts): Show a =>
09:13:22 <osa1_> I mean fn :: a -> a
09:13:25 <hpaste> lasticot pasted “wcdata.hs” at http://paste.tryhaskell.org/90693
09:14:03 <lasticot> can someone explain me what I is my mistake ?
09:14:28 <typoclass> tac: you could use something like this? http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html in general, i don't really know why you'd want to wait for threads, apart from the use case "my main thread has no job except to wait until all threads are finished"
09:14:37 <geekosaur> lasticot, using a context in a data declaration doesn't do anything sensible
09:15:23 <lasticot> geekosaur: so I should use the contaext when declaring the data type an instance of show ?
09:15:42 <geekosaur> yes
09:15:50 <ocharles> typoclass: oh yea, I forgot about async. good suggestion
09:15:58 <tac> typoclass: I'm playing with STM, so I think if I have to roll my own, I can probably manage with a TVar
09:16:05 <geekosaur> the problem with datatype contexts is they're only available when making a value, not when using it
09:16:11 <tac> (Although another strange missing function: modifyTVar :( )
09:16:44 <lasticot> ok
09:16:58 <typoclass> tac: other than that, either the thread computes something and puts it in an MVar (or the like), which means you can do your work and then wait for the MVar to be filled, for which there are functions. or thread 1 spawns thread 2, then waits until t2's work is finished, in which case t1 might just as well do the work itself, without spawning anything
09:18:03 <enthropy> Nisstyre-laptop: I think your different cases for values which may-or-may not be an instance of Monoid can be handled by syb-with-class
09:18:39 <enthropy> but that has it's own Data class to be derived with template haskell
09:19:02 <typoclass> osa1_: how weird. turn off the dmr, just to be sure?
09:19:27 <osa1_> typoclass: dmr?
09:19:48 <typoclass> osa1_: also, have you tried changing fff so that it doesn't call fn, it calls id?
09:19:52 <typoclass> @where dmr
09:19:52 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:20:11 <typoclass> osa1_: sorry, i meant turning on NoMonomorphismRestriction
09:21:33 <osa1_> typoclass: didn't work. I think it's a bug, I'll post it to mailing list
09:23:03 <typoclass> osa1_: be sure to include the variants of the code you tried to compile, and the accompanying full error messages
09:23:09 <osa1_> yes
09:23:34 <osa1_> typoclass: I have to leave now, could you please send me a message via channel bot if you find out that this is not a bug? otherwise I'll post it to mailing list when I returned
09:25:18 <typoclass> osa1_: i'm out of ideas on that :-) which isn't saying much, but anyway
09:25:44 <erisco> this. http://www.willamette.edu/~fruehr/haskell/evolution.html
09:26:03 <fryguybob> tac: There are  modifyTVar  and  modifyTVar'  in Control.Concurrent.STM.TVar
09:26:06 <typoclass> erisco: yes :-) a classic
09:26:43 <lasticot> I just came across another error, that let me think that it wasn't possible to declare a datatype an instance of Ord without declaring it an instance of Eq before. I understand that being an instance of Ord implies being an instance an instance of Eq. This is actually why I thought it wasn't needed.
09:26:58 <hpaste> lasticot revised “wcdata.hs”: “wcdata.hs” at http://paste.tryhaskell.org/90693
09:28:57 <lasticot> Have I misunderstood something or is this just how it is ?
09:30:33 <typoclass> @src Ord
09:30:34 <lambdabot> class  (Eq a) => Ord a  where
09:30:34 <lambdabot>     compare      :: a -> a -> Ordering
09:30:34 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:30:34 <lambdabot>     max, min         :: a -> a -> a
09:31:05 <typoclass> lasticot: note the first line, "(Eq a) => Ord a". in other words, you're right, it's just how it is
09:31:11 <ksf> I doesn't seem possible to write transformations directly over GHC.Generics Rep a type, simply because it's impossible to get hold of those data types GHC generates.
09:31:34 <lasticot> typoclass: ok thank you, I get it now :-)
09:32:47 <ksf> wasn't that context removed some time ago?
09:32:58 <ksf> I vaguely remember people complaining about breakage.
09:33:07 <geekosaur> lasticot, typeclasses are not OOP classes. rather than reading `class Eq a => Ord a where` as subclassing, read it as "to do the `Ord` role, a type must do the `Eq` role"
09:34:06 <typoclass> ksf: i think some context was removed from Num about 1-2 years ago, but i don't recall
09:34:08 <geekosaur> that's still inaccurate, but less so than thinking of it as subclassing
09:34:27 <geekosaur> Eq and Show
09:35:21 <benmachine> yeah, it was Num whose superclasses were changed
09:35:24 <benmachine> and Bits, I think
09:35:44 <lasticot> geekosaur: ok ok, thank you
09:35:57 <typoclass> lasticot: how about writing "class ... => Ord (Countable c) where (<=) (Countable _ a) (Countable _ b) = (a <= b)"? the docs for Ord say you can have a complete definition by only implementing (<=) http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html
09:39:08 <lasticot> typoclass: I'm sorry, I don't understand what you mean or what is meant by "class ..."
09:39:16 <supki> typoclass: -XScopedTypeVariables does not change code behaviour without explicit foralls
09:40:06 <robde> how could I call a type that is instance of Eq and Num? Eq-Num-type?
09:40:27 <typoclass> supki: oh, interesting
09:40:51 <benmachine> supki: that's almost true, iirc there are some other ways of introducing variables
09:41:38 <hpaste> typoclass annotated “wcdata.hs” with “wcdata.hs (annotation)” at http://paste.tryhaskell.org/90693#a90695
09:42:07 <typoclass> lasticot: what i meant is, i think this ^^ does the same as what you wrote, and i find it clearer :-)
09:42:56 <lasticot> typoclass: ok ! it's just that I got confused by the fact that you actually used the keyword class. sorry :p
09:43:25 <lasticot> typoclass: but indeed it's clearer
09:46:24 <acube> robde: Is that really the only thing that this type is for? Doesn't it have any other meaning?
09:51:05 <acube> cabal install happy alex :P
10:01:22 <ofan> hi, is there a way to get inferred type(no type signatures) using GHC API?
10:03:46 <acube> ofan: I know there is (hdevtools has a typeof command), but I don't know how it works :|
10:03:47 <luite> ofan: you can get types from identifiers with idType
10:07:19 <ofan> luite: which package is it in?
10:07:50 <ofan> luite: searched it in hoogle, but no results
10:08:09 <luite> ofan: the GHC API
10:08:11 <luite> the ghc package
10:08:14 <luite> which is hidden by default
10:09:47 <acube> and appears in neither hoogle nor hayoo, so it's a nightmare to search a function in it :(
10:10:03 <acube> But there is at least an index on the haddock docs
10:11:20 <ofan> hmm, i think i've exposed it, let me check again
10:12:50 <luite> ofan: you don't need to expose it globally if you start ghci -package ghc
10:13:26 <luite> acube: indexing it in a local hoogle installation is really helpful :)
10:13:38 <ksf> maybe I should use uuagc, after all.
10:13:45 <ksf> but that wouldn't really be haskell.
10:16:35 <CaptainK> my first haskell project is complete and a great success, thank you for all that helped here, great support
10:16:48 <CaptainK> Haskell rocks!
10:17:32 <josephle> yay!
10:17:48 <hiptobecubic> CaptainK, what did you make?
10:18:07 <ofan> luite: ahh yes, but I still don't know which module it is in
10:18:35 <CaptainK> a palindrome finder
10:19:00 <CaptainK> Just thought it would be a great way to jump in and learn haskell.
10:19:28 <luite> ofan: Id
10:19:35 <CaptainK> where to I submit my code for critical destruction...err peer review?
10:20:12 <ofan> luite: thanks!
10:20:27 <nubbb> upvote this on HN to provide give Haskell some exposure https://news.ycombinator.com/item?id=5995760
10:20:30 <CaptainK> I'd like to see some hard core programmers tear it apart and show me the power of this "fully operational death star!"
10:21:09 <ksf> sentences starting with "upvote this" are in conflict with intergalactic law
10:21:18 <hiptobecubic> CaptainK, if it's relatively short, codereview.stackexchange.com is pretty good I think.
10:21:31 <josephle> nubbb: so is it html, js, *and* jquery?
10:22:15 <nubbb> josephle: it is a html manipulation tool, useful for templating, scraping etc
10:22:15 <CaptainK> ok, will check that out ... and thanks to haskell its short and seriously efficient compared to what it woulod have been in other languages
10:22:17 <luite> nubbb: why not use the real jquery bindings ;p
10:22:18 <nubbb> josephle: pure haskell
10:22:33 <josephle> nubb: I mean it translates to both html, js, and jquery?
10:22:33 <nubbb> luite: no dependencies i guess?
10:22:40 <josephle> erm not both
10:22:50 <nubbb> josephle: it is strictly for manipulating dom inside haskell
10:22:57 <josephle> nubbb: ah, cool
10:23:33 <nubbb> haskell has way too few template engines compared to how cool Haskell is
10:24:02 <nubbb> but I guess Haskell has way too few anything compared to how cool is it :D
10:24:02 <nubbb> :D
10:24:13 <CaptainK> and is there a process to add the code into a hoolgeable?
10:25:10 <luite> nubbb: it doesn't quite look like jquery?
10:25:52 <CaptainK> or better asked...Is there a Haskell library where everyone stores their work or functions?
10:25:53 <luite> nubbb: i mean the api works mostly on Tag, not on a selected set
10:26:56 <nubbb> luite: well currently yes, however the lion share of the work is already done (crazy selectors implemented)
10:27:13 <CaptainK> I think this is what I am looking for: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
10:28:42 <CaptainK> ok, will work on getting this project up for review and look forward to its teardown...cyl!
10:28:46 <josephle> someone needs to write a cabal tutorial that isn't buried deep in other stuff like RWH and not as dense and technical as the User's Guide
10:29:09 <josephle> like an intro to writing cabal files
10:29:20 <CaptainK> josephle: ya I just came to that conclusion...looks like a lot of work.
10:29:24 <luite> nubbb: would you run the selector again everytime when modifying something? for example how would you implement 'wrap'?
10:32:08 <nubbb> luite: no, selecting is only to obtiain data (due to immutability)
10:32:13 <nubbb> luite: use alter
10:32:24 <nubbb> luite: and the like. i almost forgot it myself, i have written it months ago lol :D
10:33:18 <nubbb> luite: but it works quite well imho i used it for templating a lot
10:33:55 <nubbb> and now I am going to use it for a scraper I write
10:37:33 <merijn> josephle: I think the intro is just "cabal init", follow instructions
10:37:53 <merijn> josephle: I never really read anything, I just did that and then proceeded to read the cabal user guide
10:38:02 <josephle> merijn: that...is a good idea
10:38:13 * josephle remembers to use cabal init from here on out
10:38:41 <merijn> josephle: I prompt you for stuff like license, version, name, etc. and then fills in everything together with commented common fields
10:38:51 <merijn> s/I prompt/It prompts
10:40:33 <josephle> that's nice
10:41:10 <merijn> josephle: Which is I think the main reason for no one bothering to write a tutorial
10:44:26 <merijn> Any reactive-banana users around? Using reactimate to perform an IO action that generates another event should be fine, right?
10:44:35 <S_J> which GUI lib do you recommend on windows for haskell? gtk?
10:56:51 <halvorgb> I'm having trouble passing along an IO DataSomething as a parameter. If you see the two functions main and gameLoop (lines 22,24,27,35-37) in https://github.com/halvorgb/axisofX/blob/master/Main.hs. Why does one way work and the other crash? (without an error message)
11:00:00 <ksf> you need more type annotations
11:00:27 <merijn> Yeah, I have no clue what the types of things here are
11:00:43 <halvorgb> yeah I'll add some
11:00:58 <ksf> halvorgb, that looks like a SDL problem
11:01:07 <Gracenotes> in general, not a bad idea to have them
11:01:36 <josephle> type inference is overrated, higher-order polymorphism is fun!
11:01:49 <ksf> though granted, that looks like a *strange* bug.
11:02:14 <merijn> The fact that I've fixed peoples bugs countless times based on types alone without understanding what the hell they were doing should tell you type signatures are useful
11:02:27 <ksf> halvorgb, does the AI start or the player? maybe you're doing something in think
11:02:37 <halvorgb> The player starts
11:03:27 <merijn> Line 35 reloads every loop, while the other one doesn't, maybe that's the problem?
11:03:35 <merijn> I have no clue what loadAssets does, though
11:04:34 <halvorgb> loadAssets loads some images into memory, it seems really silly to have to do it every loop
11:04:46 <halvorgb> but yeah thats the only difference I can see aswell
11:04:47 <merijn> hmm
11:06:10 <halvorgb> Probably me misunderstanding the SDL_image library, was hoping you guys would see some glaring error
11:06:17 <halvorgb> thanks for the effort : )
11:06:48 <merijn> halvorgb: Superficially it looks reasonable, so you might wanna double check the API of loadAssets for info
11:20:38 <anon123> Does anyone know if there's a library for Binary Space Partitioning trees?
11:21:11 <t7> like halflife maps?
11:25:45 <astor`> anon123: couldn't find exactly that, but possibly related: spacepart, QuadEdge, and various trees like splaytree.
11:32:17 <halvorgb> Mystery solved, I freed the images inside the SDL logic. Duh...
11:41:25 <stevejb`> hello. Beginner question here. I am trying to figure out the right way to apply a list of arguments to a list of functions. https://gist.github.com/stephenjbarr/7819769c3a5ae276fbe6 lines 73-77 describe what I want to do
11:44:56 <FreeFull> stevejb`: You probably want to use zipWith
11:45:25 <merijn> :t zipWith ($)
11:45:26 <lambdabot> [b -> c] -> [b] -> [c]
11:45:34 <FreeFull> stevejb`: By the way, (muu my_InputSt) - my_var   is the same as   muu my_InputSt - my_var
11:53:37 <augur> FreeFull: why use zipWith ($) when you could use (<*>)!
11:55:36 <stevejb`> FreeFull: oh okay
11:55:39 <stevejb`> zipwith
11:55:43 <supki> (<*>) is different
11:55:45 <twanvl> augur: because (<*>) does something else without a ZipList warpper
11:56:03 <supki> and ZipList is a pain
11:57:14 <stevejb`> zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] seems like what I want. So, there is nothing restricting [a] to be a list of functions and [b] to be a list of inputs to that function?
11:57:36 <augur> does (<*>) not zipWith ($)? hm.
11:57:38 <circle> so I'm pattern matching some data structure (Say Tree a b c), how do I refer to the whole data structure in my function?
11:57:41 <circle> (not just its components)
11:57:55 <augur> oh thats right, it does all the possible combos, not the pointwise ones
11:58:09 <dmwit> circle: You can use @ patterns.
11:58:14 <augur> i wonder if zipWith ($) is also an applicative application for lists.. hmm
11:58:19 <augur> anyone know offhand?
11:58:20 <circle> is that the best way, do you think dmwit?
11:58:22 <dmwit> > let xs@(h:t) = [1,2,3,4] in (h, t, xs)
11:58:23 <lambdabot>   (1,[2,3,4],[1,2,3,4])
11:58:23 <circle> seems kind of ugly
11:58:33 <mcstar> 'as pattern' the correct name, isnt it?
11:58:38 <supki> augur: yes, zipWith is liftA2
11:58:58 <dmwit> circle: You haven't given enough detail yet to say whether that's the best way. Show us some code if you want more targeted advice.
11:59:04 <augur> supki: no i mean zipWith ($)
11:59:11 <augur> is that a valid definition for (<*>)
11:59:14 <supki> yes
11:59:34 <Gracenotes> augur: there are two possible applicative instances for lists
11:59:35 <augur> interesting that there are two very similar, but not identical, list applicatives
11:59:39 <Gracenotes> the non-deterministic one, and the zip ones
11:59:47 <Gracenotes> yeah, former is default
11:59:57 <Philippa> but ziplist is the interesting one on account of how it's not a monad
12:01:48 <Fuuzetsu> @where hpaste
12:01:49 <lambdabot> http://paste.tryhaskell.org/new/haskell
12:02:01 <astor`> is there some lens-magic for expressing \x -> map (^.field) x ?
12:02:26 <Fuuzetsu> I think that asking ‘which lens spell do I cast?’ is more accurate.
12:03:32 <dmwit> ?pl \x -> map (^.field)
12:03:35 <lambdabot> const (map (^. field))
12:03:35 <lambdabot> optimization suspended, use @pl-resume to continue.
12:03:35 <dmwit> derp
12:03:38 <dmwit> ?pl \x -> map (^.field) x
12:03:38 <lambdabot> map (^. field)
12:03:46 <c_wraith> astor`: well, you can start with an eta reduction, as dmwit just pointed out
12:04:04 <ion> x ^.. folded . field
12:05:18 <Fuuzetsu> Can someone have a look at http://paste.tryhaskell.org/90697 ? I have a pattern I'd like to stop repeating in my program.
12:07:01 <merijn> Fuuzetsu: No, you can take a constructor as argument in a pattern match
12:07:16 <Fuuzetsu> Did you mean ‘you can't’?
12:07:26 <dmwit> Yes, you can!
12:07:32 <eikke> I was recently thinking about using typelits (symbols/strings) to mark layers in a monad transformer stack, and have some kind of 'lift' operation which takes such label, and then lifts the number of times as required. anyone ever seen something in that direction?
12:07:36 <dmwit> There's the lens way, and there's the first-class patterns way.
12:07:45 <ion> fuuzetsu: Prisms might help. case t ^? _SomeConstructor of Just x -> f x; Nothing -> empty
12:07:50 <Fuuzetsu> dmwit: Lens is not an option.
12:08:06 <dmwit> http://hackage.haskell.org/package/first-class-patterns
12:08:13 <dmwit> And there's the catamorphism way, of course.
12:08:22 <ion> Well, you could NIH the (^? prism) style.
12:08:24 <dmwit> But that's not really better, I think.
12:08:27 <merijn> dmwit: \o/
12:08:35 <merijn> dmwit: You corrected my wrong typo to be correct!
12:08:35 <ion> without importing lens
12:08:47 <Fuuzetsu> I'll have a read through that but I'm stuck with ‘base’ so that package is out as well ;)
12:08:57 <merijn> Why are you stuck with base?
12:09:18 <Fuuzetsu> hacking on Haddock
12:09:22 <dmwit> Solution: put Data.Pattern into base ;-)
12:09:33 <Fuuzetsu> put Data.Text in base while you're at it!
12:09:47 <ion> and lens
12:09:58 <dmwit> Not using libraries is a sucky place to be.
12:10:11 <Fuuzetsu> Indeed.
12:11:46 <Fuuzetsu> What's happening with the docs for first-class-patterns? There doesn't seem to be any for the modules even though the package description seems to imply otherwise.
12:12:34 <dmwit> I'm not sure. But if you go back to 0.2.0 the docs are visible.
12:12:55 <Fuuzetsu> ping byorgey_
12:13:08 <dmwit> I've tried (and failed) before to work out exactly how you're supposed to debug issues with Hackage not building docs.
12:13:33 <merijn> The issue is simple
12:13:39 <dmwit> Usually it means haddock error'd out somewhere (or GHC did before haddock even got on the scene) but it's not really possible to reproduce those things locally.
12:13:51 <merijn> haddock requires the package builds (or at least configures)
12:14:04 <merijn> If you depend on C libraries/whatever that are not installed, haddock fails too
12:14:13 <wallmani> oh my
12:14:15 <dmwit> merijn: "Built on: ghc-7.4", according to Hackage
12:14:28 <merijn> hmmm, that's odd
12:14:29 <dmwit> So perhaps it is not so simple after all. =)
12:14:33 <merijn> Does it use DataKinds?
12:14:46 <merijn> Or any form of type level literals?
12:14:55 <merijn> Because haddock 7.4 trips and dies from those
12:15:18 <pentace> What does the ' mean in "var :: Pattern '[a] a"?
12:15:19 <merijn> (even when GHC compiles it succesfully)
12:15:33 <merijn> pentace: disambiguation to show it's a type level literal
12:16:00 <pentace> What is that?
12:16:01 <dmwit> merijn: According to http://hackage.haskell.org/packages/archive/first-class-patterns/0.3.1/logs/success/ghc-7.4 everything succeeded (even haddock).
12:16:19 <dmwit> Oh, no, a little higher it says
12:16:22 <merijn> pentace: i.e. '[a] is a type level list, not "the type constructor [] applied to a"
12:16:28 <dmwit> "haddock: internal error: renameType"
12:16:39 <mr-> eikke: I really like that idea, but I am not aware of something in that direction ;-)
12:17:36 <pentace> merijn: I don't understand what a type level list is, a list of kinds?
12:17:51 <dmwit> Close. It's a list of types.
12:17:52 <merijn> pentace: a list with kind "[*]"
12:18:15 <merijn> Like [Int, Double, Bool]
12:18:19 <haasn> or [anything], really
12:18:26 <haasn> merijn: '[Int, Double, Bool] you mean
12:18:41 <pentace> Oh
12:18:45 <josephle> merijn: that's horrifying. What would you use such akind for?
12:18:53 <josephle> first class module systems?
12:18:55 <merijn> haasn: No, it's optional
12:19:13 <haasn> merijn: huh, I somehow can't believe that. [Int] is a valid type and distinct from '[Int]
12:19:14 <merijn> josephle: Checking function arguments vs a heterogeneous list
12:19:23 <haasn> I would think [Int, Char] is a syntax error
12:19:26 <merijn> haasn: Yes, but [Int, Double] is not
12:19:28 <dmwit> josephle: How about a type-safe environment-indexing function for a lambda calculus interpreter?
12:19:40 <haasn> indeed you're right
12:19:40 <merijn> λ :kind! [Int,Double, Bool]
12:19:41 <merijn> [Int,Double, Bool] :: [*]
12:19:41 <merijn> = (':) * Int ((':) * Double ((':) * Bool ('[] *)))
12:19:46 <haasn> still confusing as heck to omit the ' imo
12:20:25 <merijn> josephle: In fact, I actually use it to statically type check applying a FFI imported function (of unknown, but fixed arity) to a heterogeneos list of arguments
12:20:51 <merijn> "apply :: FfiFun l -> ArgList l -> IO ()"
12:20:52 <haasn> I've used them in the past for some type-level metaprogramming
12:20:54 <josephle> so it's useful for typechecking
12:21:16 <merijn> josephle: It lets your write types and functions you otherwise couldn't
12:21:34 <haasn> (*) :: Num a => a :@ (u :: Unit) -> a :@ (v :: Unit) -> a :@ (u * v :: Unit)
12:21:35 <merijn> josephle: Or rather, it lets you write them in a type safe way, without unsafeCoerce :p
12:22:04 <haasn> where Unit ≈ [(Symbol, Exponent)]
12:22:12 <josephle> hmm the unsafeCoerce is a good point
12:22:22 <eikke> mr-: :)
12:22:26 <merijn> josephle: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L73
12:22:29 <eikke> I'll try to hack something up I think
12:22:37 <merijn> josephle: That has apply + the type family to generate it's type
12:24:04 <hpaste> merijn pasted “type level lists” at http://paste.tryhaskell.org/90698
12:24:13 <merijn> josephle: It also lets you write neat things like that
12:24:36 <merijn> foo is the identity function that doesn't accept () or Int as arguments
12:25:06 <merijn> You might need 7.7 to compile that, though
12:25:41 <josephle> merijn: that's pretty cool. I really should start looking into the type-level programming stuff that haskell has.
12:26:35 <mr-> merijn: that's extremely cool
12:27:03 <josephle> merijn: I concur with mr- the coolness has been upgraded to 'extremely'
12:27:21 <merijn> The only real downside is that the typecheck errors can be a bit...intimidating
12:27:34 <merijn> Hence why I switched the failure case to the Symbol type equality
12:27:49 <merijn> So it prints that string when the type check fails
12:28:45 <vibee> Hi. Can someone help me with this cabal install leksah error ? http://pastebin.com/788bEyLv
12:28:45 <merijn> It also fails if you apply it to "1" without a type annotation (or things like maxBound) since ghc can't proof that you're not using the () instance of Num
12:29:01 <eikke> > () + ()
12:29:03 <lambdabot>   No instance for (GHC.Num.Num ()) arising from a use of `GHC.Num.+'
12:29:03 <lambdabot>  Possibl...
12:29:16 <merijn> eikke: There's no Num instance for (), but GHC can't prove that either
12:29:17 <pentace> merijn: What is the ~ doing in your example?
12:29:19 <josephle> It always seems like reasonable type errors for more advanced type systems is somewhat of an open problem :)
12:29:29 <eikke> merijn: you were confusing me :)
12:29:39 <merijn> pentace: ~ is type level "equality" (or rather, unification)
12:29:55 <merijn> pentace: "a ~ b" is true if 'a' and 'b' can be unified to the same type
12:30:16 <pentace> wow
12:30:25 <merijn> "Int ~ Int" is true, "Int ~ Bool" is true, "Maybe a ~ Maybe Int" is true, if and only if, a == Int
12:30:35 <merijn> eh
12:30:39 <merijn> Int ~ Bool is false >.<
12:30:39 <dmwit> vibee: Somebody was mentioning that last night, too. Dunno what the resolution was.
12:30:47 <eikke> merijn: confused me again. stop!
12:30:48 <merijn> stupid mistake >.>
12:30:53 <dmwit> vibee: Anyway, have you tried getting the latest ltk from its repository and/or pestering the ltk maintainer?
12:30:56 <merijn> eikke: I suck at typing!
12:31:02 <pentace> merijn: But it's applied to a value, not a type
12:31:02 <merijn> That's why I need a good type system!
12:31:17 * hackagebot direct-sqlite 2.3.5 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.5 (IreneKnapp)
12:31:19 * hackagebot llvm-general 3.2.3.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.3.0 (BenjaminScarlet)
12:31:32 <merijn> pentace: No, Restrict is a type family (think of them as type level functions)
12:31:54 <pentace> I meant the string
12:31:55 <merijn> So the arguments of restrict are types
12:32:08 <dmwit> pentace: That string is actually a type. =D
12:32:19 <dmwit> but disguised
12:32:21 <merijn> pentace: DataKinds lets you have type level literals, including strings (types of kind Symbol) and numbers (types of kind Nat)
12:32:42 <pentace> O.o
12:32:50 <merijn> pentace: Try this in ghci: ":set -XDataKinds" then ":kind! '"test""
12:33:04 <dmwit> 'a' :: 'Char :: Symbol
12:33:06 <pentace> I can't, my GHCi is too old
12:33:14 <merijn> oh
12:33:19 <merijn> The ' is wrong
12:33:24 <merijn> At least in ghci
12:33:32 <mr-> merijn: curious.. Maybe a ~ Maybe Int is false if a ~ Int?
12:33:45 <merijn> mr-: No, Maybe a ~ Maybe Int is true if a ~ Int
12:34:30 <mr-> merijn: Ah, maybe I misread your statement
12:34:45 <circle> maggot
12:35:04 <merijn> mr-: If you read typeclasses as "foo :: Num a => a -> a" meaning "foo is a function of type a -> a, if and only if a is an instance of Num", then "bar :: a ~ Int => a -> a" reads as
12:35:15 <merijn> "bar is a function of type a -> a, if and only if a is Int"
12:36:04 <haasn> dmwit: huh?
12:36:18 <merijn> What my example is doing is, if the type a matches something in the list, then it returns the constraint "a ~ "that error string"", which is obviously a type error, unless you typed in exactly that string as argument to Restrict :p
12:36:25 <dmwit> haasn: What's the full question?
12:36:40 <merijn> If the argument matches none of the list types, then it returns the constraint () (which is obviously always true)
12:36:54 <haasn> dmwit: 'a' :: 'Char :: Symbol <- I'm confused
12:37:03 <vibee> dmwit: trying to install from git shows another error message: http://pastebin.com/wnb0r5vg
12:37:11 <dmwit> haasn: DataKinds lets you make a type-level copy of all term-level values.
12:37:16 <mr-> merijn: Ok, I assumed ~ is weaker than "equal". But stuff like String ~ [Char] is true?
12:37:29 <dmwit> haasn: So in that chain, 'a' is a type-level object; 'Char is a kind
12:37:34 <merijn> mr-: Yes, type aliases are expanded (kinda like macros) by GHC
12:37:53 <haasn> wait, isn't that a syntax error?
12:37:56 <merijn> mr-: type aliases are just a short way to type things, GHC considers them completely identical to actually typing out the entire thing
12:38:00 <merijn> haasn: It's also wrong
12:38:15 <merijn> haasn: 'a' :: Char :: *
12:38:20 <haasn> Right
12:38:25 <merijn> haasn: That is, 'a' has type Char and Char has kind *
12:38:29 <dmwit> vibee: Does ltk gave a gtk3 flag or similar?
12:38:32 <mr-> merijn: I guess the real question then is: Is ~ equality after alias expansion?
12:38:35 <merijn> But "foo" :; Symbol
12:38:36 <haasn> merijn: yeah, that's what I'd say as well
12:38:50 <merijn> mr-: There is no such thing as alias expansion from GHC's point of view
12:39:05 <merijn> mr-: In other words, yes
12:39:44 <mr-> merijn: great, thanks
12:39:47 <merijn> anyhoo, time to go
12:40:03 <haasn> dmwit: as far as I'm aware, 1. there's no syntax for type-level characters, and 2. primes in front of a kind are still a syntax error
12:40:10 <slack1256> Maybe this isn't right. When implementing a data structure how do you decide what is the invariant to preserve to make the amortized purerly functional implementation efficient?
12:40:14 <dmwit> vibee: So, it does have a gtk3 flag, and you should probably turn it off.
12:40:19 <slack1256> Let's say for a Red-Black tree?
12:40:19 <dmwit> vibee: e.g. cabal install -f-gtk3
12:40:45 <dmwit> haasn: Okay. I haven't played with the extension at all myself.
12:40:50 <dmwit> Sorry for the misinformation.
12:41:17 * hackagebot llvm-general 3.3.3.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.3.0 (BenjaminScarlet)
12:41:45 <dmwit> slack1256: You hack on the proof that the amortized time is low and the invariant in parallel until they mesh.
12:44:22 <slack1256> dmwit: you hack on the proof?... until they mesh?. sorry my english isn't good.
12:44:33 <dmwit> s/hack/work/
12:44:36 <dmwit> s/mesh/work together/
12:45:20 <dmwit> It would probably be easier to parse if I swapped the argument order, too. So, take two:
12:45:37 <slack1256> oh ok.
12:45:39 <dmwit> You work on the invariant and the proof that the amortized time is low in parallel until they work together.
12:47:24 <slack1256> that way you obtain the invariant. Well okasaki present's you the solution the other way (the invariant to preserve and the corresponding implementation) so maybe not knowing the invariant a priori seems weird to me.
12:47:46 <slack1256> *s/present's/presents/
12:47:58 <dmwit> Yes, mathematics has an unfortunate tradition.
12:48:14 <dmwit> Namely: hide the scaffolding and only show the finished product in as polished a form as possible.
12:48:21 <dmwit> That's great if you want the final polished form.
12:48:25 <dmwit> But terrible if you want to build something new yourself.
12:49:02 <slack1256> that right.
12:49:06 <slack1256> *that's
12:49:54 <josephle> this is why we want things like HoTT right? Ever edging towards the goal of a universal constructive mathematics aided by a typechecker.
12:52:07 <slack1256> constructive proof can also hide the scaffolding. what dmwit was saying (correct me if wrong) is that showing the result doesn't help you to develop the intuition to obtain the results.
12:53:21 <dmwit> As slack1256 says.
12:53:30 <dmwit> Proof is not enough: I sometimes want to see the development process.
12:53:35 <josephle> I see what you mean.
12:53:37 <dmwit> I want to see the failed attempts, and how to fix them.
12:58:21 <slack1256> The things is, maybe the development process isn't intuitive to the reader. as he has his own way to aproach problems
12:58:37 <dmwit> Of course.
12:58:46 <slack1256> although maybe that is a little problem. not as big I am thinking
12:59:00 <dmwit> And for most papers, it is probably too much effort for too little reward. =)
12:59:21 <dmwit> Still, I love "You Could Have Invented Monads" and other tutorials written in that style. =)
12:59:32 <Dodek> dmwit: this approach is more likely to work for less advanced stuff
13:00:02 <dmwit> I don't know about that.
13:00:04 <Dodek> dmwit: for cutting edge research, or even just modern stuff, people who know enough math to understand what's going on, also know what are failed approaches and promising ideas
13:00:21 <dmwit> Oh, now that I don't believe at all.
13:00:31 <Dodek> you don't?
13:00:35 <dmwit> nope
13:00:39 <slack1256> isn't that just being part of the same medium?
13:01:19 <slack1256> algebraist speak often with other algebraists, so they know what are they working on and the hidden asumptions.
13:01:21 <flebron> For instance, no serious reviewer will look at a P != NP proof that does not discuss relativization, because it's a known barrier for proof styles.
13:01:46 <flebron> Same if the proof does not differentiate between 2SAT and SAT.
13:02:18 <flebron> There are thousands of corpses by the wayside on the path to proving P != NP, so it's cautious to see if this is likely to be a waste of time before starting to read.
13:02:41 <dmwit> Failed, polished approaches and the mundane, day-to-day failures you have while working on a successful approach are very different beasts.
13:02:58 <vibee> dmwit: yes it has a gtk3 flag. sorry for delay, phone.. i am going to try now
13:04:18 <dmwit> For example, one full day's arguing about one of my recent papers resulted in the placement of a single additional prime in the basic lens laws we were drawing up.
13:04:36 <dmwit> We would never discuss that day's argument, because in retrospect it's obviously wrong.
13:04:44 <vibee> dmwit: unfortunately, another error message: http://pastebin.com/Xsvuuejj
13:04:46 <dmwit> But it's the kind of wrong you might do yourself if you were inventing things for the first time.
13:05:17 <dmwit> vibee: You will really need to take it up with the ltk maintainers, I'm afraid.
13:05:37 <vibee> dmwit: Ok, anyway thank you
13:07:38 <b52> how can i specify which package to use for an import statement?
13:08:01 <b52> Ambiguous module name `Crypto.Cipher.AES': it was found in multiple packages: cipher-aes-0.1.8 cryptocipher-0.5.0
13:10:56 <supki> b52: -XPackageImports
13:12:18 <slack1256> and hopefully speak with the maintainers of both packages explaining that their names clashes.
13:15:11 <vibee> dmwit: shouldnt i rather contact cabal maintainers, as it oviously is broken?
13:15:33 <dmwit> I don't think so?
13:15:39 <dmwit> It's not cabal's fault that ltk doesn't build.
13:16:08 <dmwit> It's a bit like contacting the maintainers of "make" when you made a syntax error in your C code.
13:16:20 <vibee> who is maintaining the cabal repos?
13:16:29 <dmwit> ENOSUCHENTITY
13:16:48 <vibee> i see :)
13:17:07 <vibee> ok, darn I need a google account :/
13:17:08 <dmwit> Hackage is a place to host source code. Nothing more.
13:17:16 <vibee> okay
13:22:28 <b52> External exception: modToPkg: Crypto.Cipher.AES: [("cipher-aes-0.1.8",True),("cryptocipher-0.5.0",True)]. Local exception: user error (too few bytes. Failed reading at byte position 1) any ideas?
13:24:01 <EvanR> fix user error
13:26:52 <b52> hm, i don't get it
13:29:13 <b52> i enabled PackageImports, specified the according package in front of the import, the error remains ..
13:30:12 <joelteon> > fix error
13:30:13 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:30:20 <joelteon> bad things happen if you try to fix errors in haskell
13:31:11 <Demos> hehe
13:31:42 <b52> anyone running into the same problem using fpcomplete center?
13:32:05 <slack1256> Ha
13:33:29 <vibee> dmwit: It seems like there have not been any issues accepted for 2 years now :(
13:39:09 <mgsloan> b52: Good catch!  Unfortunately for now that's broken, but it's been fixed, and it should work in a few days
13:41:43 <mgsloan> b52: The feedback form is also a good place to report such things (bugs / feature requests / etc etc)
13:41:45 <b52> mgsloan: I just filed a bug report
13:42:02 <josephle> mgsloan: oh, you work for fp complete now?
13:42:50 <mgsloan> b52: Cool, thanks!  This particular thing has already been addressed, but keep 'em comin!
13:42:55 <mgsloan> josephle: Yup!
13:43:16 <b52> mgsloan: btw. do you know why my font looks so weird? https://reaktor42.de/~b52/shots/2013-07-05-223719_1280x800_scrot.png on my desktop machine it looks good though
13:46:39 <mgsloan> b52: in the trees on the left, or in the code?
13:46:50 <b52> both
13:47:09 <mgsloan> It's probably falling back to your default sans-serif font
13:47:39 <mgsloan> and your default monospace font for the code
13:48:03 <mgsloan> not sure though, possibly the fonts lists could do with some additions / removals
13:50:48 <dmj> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
13:50:50 <mgsloan> b52: Thanks, I've noted it down!  Maybe we'll use some web fonts for consistency orso
13:51:05 <dmj> what is that squiggle in unzip?
13:51:10 <dmj> "~"
13:51:29 <dmj> special pattern match syntax in lambas for lists?
13:51:48 <dmj> lambdas*
13:54:30 <luite> dmj: it's a lazy pattern match, it does not fail (or force the tuple) until you actually use as or bs
13:58:32 <erisco> what is ⊥
13:58:38 <dmj> luite: interesting
13:58:55 <erisco> insert pipe? :)
13:58:57 <johnw> erisco: it's pronounced "bottom", and is an inhabitant of all types
13:59:06 <johnw> so, Bool is the set {True, False, ⊥}
13:59:15 <johnw> in general it means "undefined"
13:59:36 <johnw> attempting to evaluate it causes an exception
14:00:13 <erisco> huh ... I wonder why bother
14:00:48 <johnw> it's best to avoid its use, but sometimes it good for filling temporary holes until you have a real definition
14:01:26 <erisco> I am seeing it notationally used here: http://blog.plover.com/prog/springschool95-2.html
14:01:30 <kylcarte> dmj: http://www.haskell.org/tutorial/patterns.html -- look for "irrefutable pattern"
14:01:41 <dmj> kylecarte: Thanks!
14:01:51 <erisco> when talking about finding the fixed point of a function ... which by the way is a tad confusing as well to me
14:01:52 <johnw> erisco: it becomes important when reasoning about the non-strictness of functions
14:02:04 <johnw> > fromMaybe undefined (Just 10)
14:02:05 <lambdabot>   10
14:02:09 <johnw> > fromMaybe undefined Nothing
14:02:10 <erisco> why is repeated application of the function going to converge on a fixed point?
14:02:10 <lambdabot>   *Exception: Prelude.undefined
14:02:11 <kylcarte> dmj: np
14:02:29 <erisco> the only knowledge I have of this iterative method is for root finding, and it is not a guaranteed thing
14:02:36 <johnw> erisco: it may never converge
14:02:42 <johnw> another meaning of ⊥ is "non-termination"
14:03:08 <erisco> 'This actually finds the least fixed point of f, for a certain definition of "least"'  <-- then I don't understand what is meant by this claim
14:03:35 <shachaf> johnw: No, the fixed point of the function *is* ⊥.
14:03:45 <johnw> shachaf: ah, thank you
14:04:05 <johnw> is it true to say that the least fixed point for f is when f ⊥ = ⊥?
14:04:21 <shachaf> ?
14:04:28 <shachaf> Every function has a least fixed point.
14:04:31 <johnw> i thought I had read that definition of fixed points before
14:04:43 <shachaf> If a function is strict, then its least fixed point is ⊥.
14:04:51 <shachaf> If it's not strict, then its least fixed point is something else.
14:05:12 <erisco> um... so the "least fixed point" is that the function, given undefined, returns undefined?
14:05:30 <shachaf> The "limit" of [⊥, f ⊥, f (f ⊥), ...]
14:05:34 <shachaf> erisco: No.
14:05:56 <johnw> erisco: the least fixed point for "const 5" is 5
14:05:56 <shachaf> The least fixed point is the least defined value x such that f x = x
14:06:33 <erisco> okay, so what does saying that this fixed point IS "bottom" ?
14:06:48 <shachaf> I don't understand that question.
14:06:58 <johnw> 16:04 <shachaf> If a function is strict, then its least fixed point is ⊥.
14:07:04 <johnw> sorry, wrote line
14:07:05 <erisco> yeah that one sorry
14:07:08 <johnw> 16:03 <shachaf> johnw: No, the fixed point of the function *is* ⊥.
14:07:23 <shachaf> Yes, for a strict function.
14:07:43 <johnw> and the "least defined value" for any x is always ⊥?
14:07:56 <shachaf> If you're asking what "bottom" is, that's a different question and you should figure out the answer to that question first. :-)
14:08:02 <shachaf> johnw: Yes.
14:08:02 <johnw> oh no, it's the least defined value that, for that function, returns itself
14:08:35 <erisco> okay, so "bottom" is our least 'x' in f x = x
14:08:45 <shachaf> A value doesn't return itself. The "least defined value" is always ⊥. But for some functions, f ⊥ is not ⊥.
14:08:50 <shachaf> No.
14:08:54 <shachaf> @wiki Bottom
14:08:54 <lambdabot> http://www.haskell.org/haskellwiki/Bottom
14:09:06 <johnw> shachaf: ah, ok, that's clearer
14:09:13 <erisco> this is why I can never be a computer scientist
14:09:41 <johnw> shachaf: so is the least fixed-point for a given f the value that f returns when passed ⊥?
14:10:00 <acowley> This conversation is confusing, erisco, I'm sure things will become clearer as you think about it and encounter more descriptions.
14:10:16 <shachaf> johnw: No.
14:10:21 <johnw> I'm confused again, and I thought I understood this before
14:10:32 <shachaf> Take your example, (1:)
14:10:38 <shachaf> 1:⊥ is not ⊥
14:10:44 <johnw> right
14:10:51 <shachaf> 1:(1:⊥) is not 1:⊥
14:11:48 <shachaf> Each of those is "closer" to the real fixed point of (1:), namely an infinite stream of 1s, though.
14:12:32 <erisco> shachaf, given the definition of bottom on that page, I don't remotely see how it has anything to do with fixed points
14:12:55 <erisco> it just looks like a convenient compiler trick to make error reporting convenient
14:12:56 <shachaf> erisco: It doesn't, it's its own thing, and very important to understand before figuring out this fixed point business.
14:13:07 <johnw> I still have trouble seeing how an infinite series represents a least fixed point of (1:)
14:13:07 <shachaf> Hmm, it's not a compiler trick.
14:13:29 <johnw> i know how "fix" is defined, I mean in terms of f x = x
14:13:31 <erisco> "trick" here meaning invisible to the programmer
14:13:52 <shachaf> johnw: I'm sure you've seen this example:
14:14:01 <shachaf> @let mkfact self 0 = 1; mkfact self n = n * self (n - 1)
14:14:02 <lambdabot>  Defined.
14:14:05 <shachaf> > fix mkfact 5
14:14:09 <lambdabot>   mueval-core: Time limit exceeded
14:14:16 <shachaf> > fix mkfact 5
14:14:20 <lambdabot>   120
14:14:23 <johnw> yes
14:14:46 <shachaf> > let fakeFix f = (f . f . f . f . f . f) undefined in fakeFix mkfact 5 -- What about this?
14:14:50 <Fuuzetsu> Only now have I realised why I tend to get linker errors after moving stuff around in projects… Not updating the modules section of the project's cabal file is what causes it…
14:14:50 <lambdabot>   mueval-core: Time limit exceeded
14:14:52 <acowley> johnw: Can you distinguish let ones = 1:ones in 1:ones =?=  ones
14:14:53 <shachaf> > let fakeFix f = (f . f . f . f . f . f) undefined in fakeFix mkfact 5 -- What about this?
14:14:57 <lambdabot>   120
14:15:09 <erisco> shachaf, and you can use it to terminate an infinite sequence, but evaluating it is an error
14:15:24 <johnw> but, self 5 != 5
14:15:40 <erisco> shachaf, I dunno, I'm not seeing much else from it
14:15:41 <shachaf> Yes. "fact" is the fixed point of "mkfact"
14:16:00 <acowley> erisco: Not just terminating sequences
14:16:04 <johnw> oh, wait
14:16:06 <acowley> > [1,2,undefined,4,5] !! 3
14:16:08 <lambdabot>   4
14:16:12 <shachaf> erisco: ⊥ exists not as a compiler trick -- though individual implementations of it, like error and undefined, do -- but as a fundamental thing given that Haskell is Turing-complete and we have the halting problem.
14:16:59 <johnw> shachaf: wait, are you saying that  it's not just values that can be fixed points of functions, but *functions* can be fixed points of HOF like "fix"?
14:17:14 <shachaf> We're not talking about a fixed point of fix here.
14:17:22 <FreeFull> error and undefined are a trick, but bottom itself isn't
14:17:23 <erisco> okay ... lets talk halting problem then. Why is undefined necessary to make the halting problem unsolvable?
14:17:28 <shachaf> We're talking about a fixed point of mkfact, which is a perfectly reasonable, well-behaved, non-recursive functions.
14:17:37 <sclv> erisco: that's backwards!
14:17:42 <sclv> the halting problem is unsolvable
14:17:44 <shachaf> erisco: The halting problem is already unsolvable.
14:17:45 <sclv> therefore we have undefined
14:18:01 <sclv> honestly we'd have undefined anyway, though. halting is overkill
14:18:05 <johnw> you said "fact" is the fixed point of mkfact, but I don't see a definition for fact anywhere in what you typed
14:18:10 <shachaf> undefined is just there for convenience. You could also say: "let x = x in x", and that's indistinguishable from undefined except it takes a bit longer to evaluate and generates more heat.
14:18:16 <erisco> sorry, I worded that poorly I suppose. What I meant was, the description said that without undefined, that the compiler could determine if the program would halt
14:18:16 <shachaf> sclv: Maybe we'd have holes instead.
14:18:31 <sclv> i.e. we have it when things don't terminate full stop. the fact that we can't disallow terminating things while retaining turing completeness is where halting enters.
14:18:31 <FreeFull> Well, you can distinguish between bottoms in IO I think
14:18:34 <erisco> which is what I meant to reference by stating the converse
14:18:40 <geekosaur> only some of them
14:19:05 <sclv> its better to discuss bottom sans halting.
14:19:16 <sclv> halting is really just about what you have to sacrifice to get a bottom-less semantics
14:19:17 <monochrom> I solve the halting problem for breakfast
14:19:19 <Fuuzetsu> :t fix fix
14:19:20 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
14:19:20 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
14:19:20 <lambdabot>       Actual type: (a0 -> a0) -> a0
14:19:45 <shachaf> erisco: What description are you talking about?
14:19:50 <johnw> shachaf: you said "fact" is the fixed point of mkfact, but I don't see a definition for fact anywhere in what you typed
14:19:52 <erisco> monochrom, you must be quite malnutritioned oO
14:19:59 <sclv> we ned to start by introducing a semilattice of meaning
14:20:02 <monochrom> unfortunately, it means that on some days I don't get breakfast. yeah :)
14:20:03 <shachaf> > let fact = fix mkfact in fact 5
14:20:06 <lambdabot>   120
14:20:07 <shachaf> There you go.
14:20:29 <johnw> so, mkfact fact = fact?
14:20:33 <shachaf> Yes.
14:20:39 <shachaf> > mkfact (fix mkfact) 5
14:20:44 <lambdabot>   mueval-core: Time limit exceeded
14:20:44 <monochrom> perhaps, I should change to: I eat the halting problem for breakfast :)
14:20:48 <erisco> "If it were not [bottom being a member of all types], the compiler could solve the halting problem and statically determine whether any computation terminated"
14:20:50 <johnw> ah, that sounds very familiar
14:21:03 <johnw> like how Cons a (List a) ~ List a
14:21:05 <shachaf> erisco: undefined is just one implementation of bottom. There are many others.
14:21:23 <johnw> I mean, Cons a (List a) :: List a
14:21:36 <sclv> erisco: yeah that was a somewhat confusing explanation w/r/t causality
14:21:38 <shachaf> > mkfact (mkfact (mkfact (mkfact (mkfact (mkfact undefined))))) 5
14:21:42 <lambdabot>   120
14:21:43 <shachaf> > mkfact (mkfact (mkfact (mkfact (mkfact undefined)))) 5 -- oops
14:21:44 <acube> > let undef = undef in undef -- oneOther
14:21:46 <lambdabot>   *Exception: Prelude.undefined
14:21:47 <lambdabot>   mueval-core: Time limit exceeded
14:21:51 <erisco> everything said so far has felt like smoke and mirrors. I don't have anything concrete that we are talking about
14:22:07 <acube> @ty mkfact
14:22:08 <lambdabot> (Eq a, Num a) => (a -> a) -> a -> a
14:22:09 <sclv> ok think about the language C
14:22:17 <johnw> shachaf: very interesting, that may be the most clarifying thing I've read about fixed-points yet
14:22:19 <sclv> actually just stay in haskell
14:22:30 <sclv> and have foo = 5 :: Int
14:22:32 <johnw> mkfact fact = fact.  Will need this as a poster on my wall
14:22:32 <sclv> foo is of type Int
14:22:39 <sclv> now have foo = foo :: Int
14:22:42 <sclv> and foo is of type int
14:22:52 <sclv> but we can't actually look at foo otherwise we get an infinite loop
14:23:01 <sclv> that's where bottom "comes from" semantically
14:23:05 <shachaf> johnw: fix mkfact = mkfact (mkfact (mkfact ...
14:23:22 <sclv> is we want to give meaning to all expressions, but some expressions can take "any" meaning because they loop forever
14:23:25 <shachaf> You can see how that looks like a limit of [⊥, f ⊥, f (f ⊥), ...]
14:23:34 <johnw> yes
14:23:37 <sclv> so we need some way of denoting those things that are not fully defined
14:23:39 <monochrom> "Fact: fact = mkfact fact" :)
14:24:08 <shachaf> fun fact 0 = 1
14:24:15 <shachaf>   | fact n = n * fact (n - 1)
14:24:25 <sclv> bottom arises when we begin to ask "what does it mean to assign mathematical denotations to languages with general recursion"
14:24:28 <monochrom> haha, SML wins
14:24:29 <erisco> sclv, okay, so before we step further.. why do we care about sticking in some assumed definition for foo = foo? why not simply reject it outright?
14:24:43 <sclv> erisco: and that's where halting comes in!
14:24:44 <acube> fun fact = not . fun
14:24:58 <sclv> we have no way of disallowing all nonterminating programs, without also disallowing general recursion
14:25:07 <erisco> for what I can tell, foo = foo doesn't define a damned thing, so I do not understand what we're gaining
14:25:07 <shachaf> erisco: We can reject it outright. But do we disallow general recursion in general?
14:25:20 <sclv> if you look at C it might help
14:25:23 <shachaf> This is the part where the halting problem comes in.
14:25:33 <shachaf> I think I'm just repeating what sclv is saying a few seconds after he says it.
14:25:36 <shachaf> So I'll let him say it.
14:25:40 <sclv> functon int wtf() {return wtf();}
14:25:50 <johnw> > fact 5
14:25:51 <sclv> that's the imperative version of our definition of foo
14:25:52 <lambdabot>   Not in scope: `fact'
14:25:52 <lambdabot>  Perhaps you meant `fcat' (imported from Text.PrettyPr...
14:26:06 <johnw> > let fact = fix mkfact in fact 5
14:26:10 <lambdabot>   120
14:26:11 <sclv> can you imagine a "common" language that didn't let you write that?
14:26:14 <johnw> > let fact = fix mkfact in (mkfact fact) 5
14:26:18 <lambdabot>   120
14:26:24 <johnw> will you look at that
14:26:39 <sclv> in fact, if we introduce effects, something like wtf is a very common sort of function
14:26:45 <monochrom> erisco: if you want to design a language that other people understand, you have to articulate a criterion of what you reject and what you accept. there are many choices, but you have to pick one and articulate it. it'd better be something more systematic and helpful than just "I reject x=x"
14:26:48 <erisco> sclv, no, but I wasn't looking for extra confirmation that it is being used. I was asking why it is used
14:27:00 <erisco> sclv, it is necessary for recursion in general?
14:27:01 <sclv> what do you mean "why is it used"
14:27:13 <sclv> if we wish to give _meaning_ to recursion in general, it is necessary
14:27:18 <josephle> shachaf: foo = foo :: Void is not valid, right?
14:27:19 <shachaf> monochrom's answer is the best.
14:27:21 <sclv> i.e. i can define C without using the concept of bottom
14:27:29 <josephle> making sure bottom doesn't inhabit Void
14:27:33 <shachaf> @let data Void
14:27:35 <lambdabot>  Defined.
14:27:35 <shachaf> > let foo = foo :: Void in foo
14:27:37 <lambdabot>   No instance for (GHC.Show.Show L.Void)
14:27:37 <lambdabot>    arising from a use of `M856209988...
14:27:39 <shachaf> josephle: It sure does.
14:27:40 <sclv> but I can't say what a function like wtf() means without it
14:27:54 <josephle> shachaf: but wasn't the point of Void to have no inhabitants?
14:28:00 <erisco> monochrom, I don't understand what you're implying
14:28:08 <acube> > let foo = foo :: Void in 42
14:28:09 <lambdabot>   42
14:28:10 <sclv> so the fact that we have an explicit thing like "undefined" is just a compiler trick
14:28:21 <sclv> but the ability to write something _like_ "undefined" is inescapable
14:28:29 <shachaf> josephle: Yes, but this is Haskell. We don't have true Void, just a cheap plastic imitation thereof.
14:28:34 <sclv> (in a turing complete setting)
14:28:36 <josephle> :(
14:28:52 <erisco> sclv, don't base cases mean anything, in the sense that you can establish convergence? what is "general" recursion mean then?
14:29:34 <monochrom> I am implying: what exact rule in your head do you use to reject certain recursions but accept others? one example of "I reject x=x" is not enough.
14:30:29 <acube> > let x f = x x in x :: String           -- Not x=x
14:30:30 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = t0 -> t1
14:30:33 <acube> :O
14:30:40 <josephle> shachaf: I assume this is due to the call-by-need semantics?
14:30:43 <shachaf> monochrom: I reject recursions iff they do not halt.
14:31:00 <erisco> monochrom, I am not asserting the claim here. It was said that such a definition needs special handling, and I am asking why it should even be considered
14:31:10 <sclv> erisco: general recursion is just any sort of recursion that's not necessarily primitive recursion.
14:31:12 <shachaf> josephle: Call-by-need is an implementation, really. :-)
14:31:12 <sclv> cf http://en.wikipedia.org/wiki/Ackermann_function
14:31:27 <acube> What is another easy implementation of undefined other than let undef = undef in undef ?
14:31:35 <sclv> erisco: we don't need special handling for anything?
14:31:39 <shachaf> josephle: You could say it's due to non-strictness but that doesn't really get to the core of the problem exactly.
14:31:53 <shachaf> In a strict language you could still have a non-terminating function :: () -> Void
14:31:56 <josephle> shachaf: tell that to Bob Harper. He has an entire chapter on the dynamics of Call-by-need :P
14:32:04 <monochrom> ok, bring that author here, I have much to interrogate, grill, and criticize him/her
14:32:06 <osa1_> can anyone help me, is my intuition correct:  http://www.haskell.org/pipermail/haskell-cafe/2013-July/109050.html ?
14:32:16 <erisco> sclv, your entire explanation is about why we need "bottom", right? that is what I am meaning by "special", since the concept is being introduced for this purpose
14:32:57 <sclv> erisco: what is the meaning of let foo = foo in foo if we don't have "bottom"?
14:33:08 <bos> ghc trac is so terrible :-(
14:33:09 <monochrom> even GHC's famous runtime loop detection is explainable and not as trivial as "x=x"
14:33:10 <sclv> you answer "don't consider it"
14:33:27 <sclv> but then i tell you i can write things that are equally "not considerable" in your conception
14:33:33 <sclv> and which you have no way of discovering what they are
14:33:37 <sclv> due to the halting problem.
14:33:50 <sclv> and the fact that we cannot know in general what programs do and don't terminate
14:34:00 <acowley> I actually think while(true) {} is a more relatable divergence to most programmers.
14:34:03 <sclv> so now you either say "some things have no meaning, but i can't tell you what things"
14:34:25 <sclv> acowley: yr probably right. i'm too fp brainwashed for it to come to mind easily :-)
14:34:43 <sclv> _or_ you say "i will come up with a way to give meaning even to those things"
14:35:14 <sclv> bos: are there concrete issues you're having with it that one could fix? or is it just irritating software?
14:35:17 <erisco> okay, so upon further thought I can see that statically determining if a recursive function terminates can't always be done
14:35:24 <acowley> sclv: I know, suggesting it felt shameful :) But when you start typing imperative languages, the issue of divergence has a very tangible operational meaning.
14:35:37 <bos> sclv: it gets filled with spam repeatedly, and it is terribly slow
14:35:46 <josephle> for a fun time, in any dynamically typed language, run the equivalent of 1 + while(true) :)
14:35:58 <erisco> the example foo = foo confused me a bit because it lacked any meaning, which is why I questioned the purpose
14:36:02 <sclv> oh absolutely. den sem came from looking at predecessors to C
14:36:37 <erisco> okay, so we have recursive functions and we cannot determine if they terminate. now where is the bottom?
14:36:41 <acowley> Yes, foo = foo doesn't leap out as an immediately valuable direction of inquiry
14:37:10 <sclv> erisco: we can create a systematic procedure to assign meaning to any recursive function
14:37:21 <sclv> regardless of if it terminates or not.
14:37:41 <monochrom> bottom comes from denotational semantics. and to a large extent, denotational semantics doesn't care about the halting problem.
14:38:34 <sclv> this procedure involves assigning the values we can to the portions we know, and reoccuring. we can capture this mathematically then by pulling out the reoccurance bit and taking the "fixpoint" of the skeleton, so to speak
14:38:38 <erisco> okay, and so, bottom becomes a member of all types ... and recursive functions return some type, so they might return bottom ... how does this fit together?
14:38:41 <sclv> i understand i'm using very conedensed language here.
14:38:41 <monochrom> or perhaps doesn't worry? choose your favourite wording.
14:39:20 <sclv> we then introduce a notion of "ordering" on information
14:39:30 <sclv> so we have structures with increasing amounts of information filled in
14:39:55 <sclv> and we can say the strucuture we're producing is the structure with the least information that nonetheless satisfies what our formulae require.
14:40:34 <sclv> if you know calculus, there's a very rough analogy to saying that we can define the integral of any function of a certain sort in a uniform way
14:40:45 <sclv> even if we can't necessarily get a closed-form version of it.
14:41:13 <sclv> and the proof of the existence of such integrals in fact also uses a recursive fixed-point formula.
14:41:40 <sclv> so if we wanted a "proof" of the validity of _that_ proof -- i.e. that the recursion itself was defined
14:41:46 <erisco> really? I've seen rectangles and limits myself
14:41:50 <sclv> then we could use our cs tools
14:42:39 <erisco> sclv, sorry this has become a bit detached again for me. maybe it is all the horrific memories from calculus courses, but
14:42:49 <sclv> here's some points on it: http://en.wikipedia.org/wiki/Picard%E2%80%93Lindel%C3%B6f_theorem
14:42:56 <sclv> the analogy is very rich to me
14:43:03 <sclv> but if you don't like calc, then feel free to disregard :-)
14:43:30 <acowley> that seems like a pretty demanding way to motivate bottom
14:43:47 <erisco> hey, differential equations didn't do anything to me. It's the bloody courses that were onorous.
14:44:06 <sclv> acowley: yeah, it depends on yr background i guess
14:44:11 <tac> Peaker: What was the one library you suggested I need to download from your repository if I want to install lamdu?
14:44:16 <sclv> i mean in general we should introduce any old fixed point theorem: http://en.wikipedia.org/wiki/Fixed_point_theorem
14:44:24 <Peaker> tac, https://github.com/Peaker/FTGL
14:44:36 <tac> ty
14:44:57 <sclv> the point being that in general, its not always the case that if you iterate something over and over you get a "convergent" answer
14:45:03 <sclv> and fixed point theorems tell us when you do.
14:45:17 <hpaste> “_justjust” pasted “Netwire object trying to jump” at http://paste.tryhaskell.org/90699
14:45:37 <_justjust> how can i make the object jump? :)
14:45:39 <sclv> and to define a notion of convergence in a PL setting you need a least-defined type in yr semilattice
14:45:58 <erisco> sclv, sorry I don't think this is going to click in any way for me, but thanks for trying
14:45:59 <sclv> i know that i'm ratcheting up the jargon here, sorry
14:46:06 <sclv> yeah i'm not doing a good job :-(
14:46:11 <shachaf> https://en.wikipedia.org/wiki/Tarski%27s_fixed_point_theorem is maybe more relevant here, as fixed point theorems go.
14:46:24 <acowley> sclv: I think you started out great
14:47:16 <sclv> ezyang's blog posts are very good on this: http://blog.ezyang.com/category/computer-science/denotational-semantics/
14:47:47 <erisco> sclv, math land is not my forte. I wilt under equations and symbols and theorms called after last names so so forth.... but since "bottom" is needed for Haskell to work, I think the entire conversation can stay internal to Haskell, just my assumption
14:47:59 <sclv> and we had a very nice talk at the ny haskell users group if you have the time: http://blog.ezyang.com/category/computer-science/denotational-semantics/
14:48:05 <acowley> Yes, I was just trying to dig up http://blog.ezyang.com/2010/12/omega-i-m-lubbin-it/
14:48:21 <sclv> erisco: you can get very far in haskell ignoring this stuff
14:48:30 <sclv> outside of just the fact that we have this thing around
14:48:39 <shachaf> sclv: Your NY HUG group looks suspiciously like ezyang's website.
14:48:44 <sclv> and we shouldn't be able to tell the difference between bottom and not-bottom outside of IO
14:48:48 <shachaf> s/group //
14:48:59 <sclv> shachaf: doh. here's the video http://vimeo.com/67174266
14:49:11 <shachaf> Even inside of IO we can't tell the difference, usually.
14:49:18 <shachaf> Just in weird cases like error.
14:50:27 <sclv> w/r/t explanations, i think you just hit a point where you need to introduce "semilattice"
14:50:38 <sclv> and then you go all in like ezyang or the video and spend some time with it
14:50:43 <sclv> or you have to just stop :-(
14:51:08 <monochrom> yikes, "omega I'm lubbing it" haha
15:01:02 <tac> Peaker: that's pretty trippy!
15:03:27 <erisco> acowley, have I convinced you yet that I can't be a computer scientist? :)
15:03:44 * erisco is hunting for at least one victory here
15:04:32 <monochrom> to some extent, until the day you die, we don't know yet. (think of it as another halting problem!)
15:04:34 <acowley> erisco: No. We all have different backgrounds and strengths, and I think you just took a tentative step into what looked like a puddle but turned out to be a sarlacc pit.
15:05:18 <acowley> For example, my strength is tenuous analogy and questionable humor.
15:05:34 <erisco> :P
15:06:21 <acowley> Also, that page that was linked earlier is, I think, somewhat clearer about fixed points. I find them easier to understand at the type level because I don't think about general recursion there.
15:06:39 <Peaker> tac, you running lamdu? :)
15:06:48 <tac> yeah
15:06:55 <tac> I got the fact example all typed in
15:07:05 <tac> don't know how to run it.... but at least I know I couldn't get the types wrong
15:07:15 <Peaker> tac, can't run stuff yet :)
15:07:29 <tac> You can just be like agda and never run anything anyway
15:07:52 <Peaker> tac, it's still preliminary, and you can break the types in various ways (which are simply implemented parts of the UI)
15:08:00 <Peaker> unimplemented*
15:08:34 <tac> Peaker: Have you considered trying to make it work on the browser, rather than messing with a windowing toolkit?
15:08:56 <Peaker> tac, try writing the infinite fibs sequence: http://i.imgur.com/vtNLmwn.png
15:09:08 <Peaker> tac, yeah, we have
15:09:29 <Peaker> tac, couldn't get smooth animations going on when we tried, or even have full control over rendering/placements
15:09:30 <FreeFull> Peaker: That's ugly
15:09:47 <tac> FreeFull: it's the idea that's beautiful
15:09:47 <Peaker> FreeFull, what would you improve?
15:09:50 <FreeFull> I much prefer   fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:10:05 <Peaker> FreeFull, you mean the definition or the UI/rendering?
15:10:36 <FreeFull> Peaker: I would find reading the actual source much clearer, I think
15:10:40 <Peaker> FreeFull, we prefer the iterate definition... we feel it's more straight-forward
15:11:01 <luite> hmm smooth animation should be possible in the browser with some care
15:11:22 <luite> perhaps not if you want to compile your stuff to js
15:11:23 <tac> what are the red vs green brackets?
15:11:32 <luite> and if it is big :)
15:11:34 <Peaker> luite, 60fps like in OpenGL?
15:11:36 <erisco> certainly. no reason you can't, unless you are moving gobs of dom elements without absolute positioning
15:11:41 <Peaker> tac, green are values, red are types
15:11:45 <luite> Peaker: yeah, with requestAnimationFrame
15:11:56 <anon123> astor`: the spacepart library is long dead, and it doesn't look like there's any other existing libraries.
15:12:02 <Peaker> luite, what if there's much to draw?  Would JS handle it?
15:12:13 <tac> oh, so green are records?
15:12:31 <Peaker> tac, both are -- green are record values, red are record types
15:12:47 <tac> gotcha
15:12:49 <tac> how do you type them in?
15:12:50 <Peaker> tac, green{x:5, y:6} : red{x:Int,y:Int}
15:12:54 <tac> ok
15:12:57 <Peaker> tac, '{' in hole
15:13:02 <luite> Peaker: it will likely be slower then. is there really too much to draw though? browsers have pretty well optimized rendering and compositing. browsers automatically slow down the requestAnimationFrame frame rate when the code takes lonker
15:13:03 <Peaker> and then ',' to add a field
15:13:06 <luite> longer
15:13:20 <Peaker> luite, I want smooth 60fps animation, we indeed have much to draw
15:13:50 <luite> Peaker: hmm, but it looks all relatively simple to draw
15:14:05 <Peaker> luite, let me record a screenshot
15:14:53 <tac> Peaker: I'll take it over to blah since this isn't strictly haskell
15:15:16 <startling> is there not a thing in pipes for reading a file and then streaming chunks from it?
15:16:12 <Peaker> luite, when you press space on the iterate, to wrap it with map, you get this: http://i.imgur.com/76F6qzJ.png
15:16:20 * hackagebot MFlow 0.3.0.0 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.3.0.0 (AlbertoCorona)
15:16:27 <Peaker> luite, it's full of nonsense results because we dont have type-classes yet to filter them
15:16:35 <Peaker> luite, but it can easily explode to a lot of drawing
15:16:58 <luite> Peaker: ah that's quite a bit
15:16:58 <acowley> startling: If there's not, it's a quicky
15:17:22 <luite> Peaker: do you need fast zooming of the whole interface?
15:17:24 <startling> acowley: sure, but what a pain in the ass
15:17:27 <Peaker> luite, we want an awesome IDE first, browser support later :)
15:17:36 <Peaker> luite, yeah, we have zoom support via OpenGL
15:18:20 <luite> Peaker: oh i'm not saying you should do browser, i'm just wondering if it would be possible to work around the limitations
15:18:21 <erisco> Peaker, IDE in a browser? I fear compute power just might not be enough =\
15:18:49 <startling> ah, it's in pipes-extra
15:19:40 <luite> Peaker: i expect that to still render acceptably if you don't zoom too much btw (and with better looking fonts), the browser will use the glyph cache to quickly composite them
15:19:47 <luite> oh sorry i thought this was -blah
15:20:45 <Peaker> luite, we can use any font ttf we'd like, so can probably steal a browser one if it's nicer. we like this one though and it has lambdas/etc that we need
15:20:49 <startling> er, pipes-binary
15:21:20 * hackagebot TCache 0.10.0.10 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.10 (AlbertoCorona)
15:21:49 <luite> Peaker: yeah but i mean it looks like your ide rasterizes first, then scales?
15:21:55 <startling> uh maybe not
15:22:02 <startling> what the hell is pipes-core?
15:22:11 <Peaker> luite, ah, yeah we ought to be doing better font rendering :)
15:22:47 <acowley> startling: Are you using v4.0?
15:22:50 <startling> oh, it's an incompatible library with different compatible libraries
15:22:51 <startling> nice.
15:22:58 <Peaker> luite, graphics-drawingcombinators uses font size hard coded to 72 and then GL scaling
15:23:07 <luite> Peaker: yuck
15:23:16 <Peaker> luite, probably better to use some sort of "mip mapping" scheme for differing sizes
15:23:33 <startling> acowley: v4.0 of what?
15:23:40 <acowley> startling: pipes
15:23:48 <luite> Peaker: even then it's worse than native rendering with subpixel hinting
15:23:54 <erisco> Peaker, there is a brlliant distance mapping technique if you can use a pixel shader :)
15:24:02 <luite> Peaker: a lot faster though, i guess :)
15:24:03 <startling> acowley: the highest version I see on hackage is 4.0
15:24:08 <startling> er
15:24:11 <startling> *3.3.0
15:24:25 <acowley> Hm, okay
15:24:30 <Peaker> luite, maybe it's a solved problem with FTGL?
15:24:40 <acowley> I was playing with 4.0 from github the other day and wrote a bytes chunker Producer
15:25:13 <acowley> So I was going to gist it in case you couldn't find it in a library somewhere. But I don't think it's compatible with 3.*
15:25:24 <luite> Peaker: i don't think it supports that, not sure
15:25:35 <Peaker> luite, every app for itself?
15:25:40 <startling> acowley: ah
15:27:14 <startling> oh, "pipes-bytestring" is "upcoming". cool.
15:29:31 <luite> Peaker: i mean hinting and subpixel rendering
15:29:48 <johnw> Data.TCache looks interesting
15:30:05 <luite> but curve rendering with opengl is quite cool, would at least make it look crisper :)
15:36:54 <zacts> what would a haskell inspired UNIX look like?
15:39:14 <sclv> @remember byorgey now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
15:39:14 <lambdabot> Nice!
15:39:45 <troydm> haha
15:39:50 <monochrom> hehe
15:40:29 <Peaker> when I pair program, we use "monkey" to refer to (:[]) all the time
15:42:40 <sclv> i realized it was never in the quotes file
15:42:53 <sclv> did some archaeology to find a good quote for it
15:43:04 <sclv> Pseudonym coined it as ninja robot monkey back in '07
15:43:09 <sclv> but the ninja got dropped relatively quickly
15:43:17 <erisco> :t <^(++)^>
15:43:18 <lambdabot> parse error on input `<^'
15:43:28 <erisco> lies
15:43:48 <sclv> yeah that was in reference to something in a library, not base
15:43:54 <sclv> i think something by conal
15:43:55 <johnw> :t (<^(++)^>)
15:43:56 <lambdabot> parse error on input `)'
15:45:11 <sclv> or it mighta been some weirdo applicative toy someone defined inline
15:46:37 <geekosaur> :t (<^)
15:46:38 <lambdabot>     Not in scope: `<^'
15:46:38 <lambdabot>     Perhaps you meant one of these:
15:46:38 <lambdabot>       `^' (imported from Prelude), `^^' (imported from Prelude),
15:46:43 <geekosaur> ah well
15:48:11 <monochrom> I suggest this name for the library with the pig operator: Animal Farm
15:48:49 <erisco> gah I'm just too daft to reason about this.... so if I am writing a parser (using parser combinators) and I have   s = token 'a' \> s \> token 'a'    where  (\>) :: Parser a -> Parser b -> Parser (a, b)   then I run into an infinite type problem
15:48:58 <monochrom> Hey! Animal Farm univalence says: all types are isomorphic... :)
15:48:59 <luite> where all operators are equal
15:49:19 <erisco> which I get, because the tuples would go on an unknown number of times, so the idea would be to wrap in a recursive data type
15:50:06 <erisco> (or self-referential, however is named). it seems silly to define    data S = ...    for this rule, and a data type for all other recursive rules
15:50:39 <josephle> monochrom: but some types are more isomorphic than others
15:51:24 <erisco> so I was looking at mu, which as I understand is the name given to a particular lambda function, and when talking about type kinds, it applies as well
15:51:39 <erisco> which is the lambda function of self-application
15:52:53 <erisco> but... it doesn't seem Haskell actually makes use of mu explicitly (ie: data Mu = ...) so is there no convenient way to resolve the infinite type problem?
15:53:00 <monochrom> erisco: first you should decide: what should s "return"? that is, s :: Parser (____) fill in the blanks. then, second, based on that, you will have to design a combinator based on that decision and \>, and it is unlikely to be just \> itself.
15:53:28 <josephle> "The types outside looked from Monad to Applicative, and from Applicative to Monad, and from Monad to Applicative again; but already it was impossible to say which was which."
15:55:06 <erisco> monochrom, what do you mean "just \> itself"? you mean my expression will change?
15:55:33 <monochrom> Gah, am I so incomprehensible always?
15:55:54 <erisco> I probably just can't comprehend
15:56:27 <johnw> monochrom: only the day after US national observances
15:56:46 <monochrom> you cannot limit yourself to simple uses of \> and shoehorn all types it fit simple-minded uses of \>
15:56:53 <monochrom> err, typo
15:56:57 <monochrom> you cannot limit yourself to simple uses of \> and shoehorn all types to fit simple-minded uses of \>
15:57:38 <monochrom> you will use \> but it is not going to be exactly token 'a' \> s \> token 'a'
15:59:07 <erisco> not 100% sure what you mean, but I do know, at least when considering the return type, that I am probably screwed for any general solution (without involving extra compilation or something)
15:59:52 <erisco> since each parser has a different return type (potentially), so I can't reason any way to make the recursive data type seeing that it depends on self-similarity
15:59:59 <monochrom> ok, fill in the blank: s :: Parser (____). this is independent of how to implement s. do you understand this much?
16:00:23 <monochrom> this is independent of how to implement s because this is part of the requirement specification of s.
16:00:26 <erisco> yeah I'm talking about the blank
16:00:55 <erisco> I was intially thinking one thing but now I think I was looking for something impossible
16:01:18 <monochrom> ok, until you make up your mind on that, I have no further comment.
16:01:42 <monochrom> (and if you make up your mind on it but you choose something nonsense, I still have no further comment.)
16:02:46 <erisco> if I had    data S = S1 S         then I'd have  s:: Parser S
16:03:10 <monochrom> why "data S = S1 S"? what good is it?
16:03:19 <pentace> Is there some kind of sizeof operator in Haskell? Or is it possible to calculate the internal size of memory allocated for a certain value?
16:03:28 <acowley> Put another way, what  are some values of type S?
16:03:40 <johnw> pentace: yes, if the type is an instance of Storable
16:03:46 <johnw> pentace: see Foreign.Storable
16:03:47 <acowley> pentace: the Storable typeclass has a sizeOf member
16:03:55 <pentace> Ah, thanks
16:04:09 <acowley> pentace: But that's only for Storables, and quite possibly not what you want
16:04:26 <acowley> It's more of a serialization detail
16:04:32 <erisco> monochrom, not sure how to answer that exactly... it just corresponds with the grammar rule
16:04:41 <erisco> monochrom, token 'a' is constant and so can be inferred
16:05:00 <pentace> acowley: Not sure, sounds like it is what I want :)
16:05:31 <acowley> pentace: Great! The other variations of that question are more complicated (e.g. http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects)
16:06:05 <acowley> Or, more summarily, http://stackoverflow.com/questions/3254758/memory-footprint-of-haskell-data-types
16:06:14 <pentace> Oh wait, no list or tuple instances ...
16:06:28 <erisco> monochrom, so if I had    s a b = a \> s \> b     then I'd have    data S a b = a S b
16:06:38 <erisco> monochrom, make sense?
16:07:06 <monochrom> no
16:07:12 <monochrom> and I have to go
16:07:21 <erisco> okay sorry
16:07:23 <pentace> acowley: That first link looks like a pretty interesting read
16:07:44 <acowley> pentace: http://hackage.haskell.org/package/vacuum-graphviz may be useful for you depending on what you're trying to do
16:08:45 <pentace> Actually, this is not a real programming problem but just out of curiosity
16:09:20 <oio> could someone explain me this?
16:09:23 <oio> s >>= flip when r
16:09:41 <josephle> @type when
16:09:42 <lambdabot> Monad m => Bool -> m () -> m ()
16:09:57 <johnw> if s yields a True value, do r
16:10:11 <zRecursive> :t flip when
16:10:12 <lambdabot> Monad m => m () -> Bool -> m ()
16:10:13 <johnw> do { x <- s; when x r }
16:10:18 <S_J> How does quickCheck check code coverage? Is there a debugger available for Haskell btw?
16:10:47 <startling> S_J: I don't think quickcheck does anything with coverage.
16:10:48 <S_J> (never felt like i needed one really though.)¨
16:10:59 <zRecursive> @undo do { x <- s; when x r }
16:10:59 <lambdabot> s >>= \ x -> when x r
16:11:10 <S_J> startling: well then there is some additional program that does that.
16:11:15 <geekosaur> ghci has a debugger
16:11:58 <oio> so when gets passed around as a curried functions ? :S
16:12:32 <startling> S_J, I have no idea what you're talking about.
16:12:54 <acowley> http://www.haskell.org/haskellwiki/Haskell_program_coverage
16:12:55 <johnw> S_J: hpc checks code coverage for Haskell
16:17:03 <zRecursive> Is there newest GHC binary available on FreeBSD  ?
16:18:21 <m3ga> zRecursive: 7.6.3 recent enough? http://www.haskell.org/ghc/download_ghc_7_6_3
16:18:58 <zRecursive> m3ga: it is newer than ports, thx
16:21:41 <erisco> okay so I'll try asking this again in a different way... I really feel like I'm missing something so...  say I have   S a b c d :: S (Either (a, (S a b c d, b)) (c, d))    but this introduces a new data type 'S', which has to be done explicitly by the programmer
16:22:11 <erisco> the type  Either (a, (?, b)) (c, d)   is constructed programmatically by using combinators
16:22:34 <erisco> and Haskell chokes on ? because it ends up a recursive type, and the only way I know to resolve that is by creating a new type manually
16:24:16 <erisco> so I have   s = (token 'a' \> s \> token 'a') // (token 'a' \> token 'a')    where  the combinators \> and // are being used. I am imagining some way to better define the operators such that I don't have this infinite type problem
16:24:22 <erisco> when I want to make a recursive call
16:25:03 <erisco> I can post complete source if that is of any interest. it is a little parser project I am working on to grok Haskell and parsing
16:27:53 <erisco> perhaps I am still being obscure
16:28:11 <enthropy> erisco: you don't need 4 parameters to S:   newtype S a b c = S (Either (a, (S a b c, b)) c)  will do the job too
16:29:18 <erisco> well c must be a tuple in this case, because that is how the \> combinator works
16:29:55 <erisco> but I get what you're saying
16:31:05 <erisco> I dunno, I see patterns like mu and omega and intuition says there ought to be a better way to do this
16:31:58 <enig_> is there any obvious reason why ghci would tell me it loaded a module but not recognize any of the function names?
16:32:04 <erisco> like instead of (\>) :: Parser a -> Parser b -> Parser (a, b)   it is   (\>) :: Parser a -> Parser b -> Parser (Magic (a, b))
16:32:10 <enig_> i'm working off of this: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/loading-source-files.html
16:32:36 <enthropy> if you don't really care about requiring the (c,d) to be at the end (and different kinds of undefined), you could also use the type    [Either (a,b) (c,d)]
16:33:19 <enthropy> enig_: if the module is compiled (no * after the module name in your prompt), you don't get to see names that aren't exported
16:33:42 <enthropy> err, the * comes before the module name
16:36:28 <enig_> enthropy, even when i delete the compiled version and use ":l myfile.hs" it still tells me it imports but doesn't have any functions
16:37:27 <enthropy> enig_: and you do get the *Main> prompt?
16:37:27 <fetter_oml> good evening. I have a problem using the Data Constructor "State" from Control.Monad.State: http://pastie.org/8114143 (tl;dr: ist just tells me that there isnt such a thing, recommends StateT)
16:37:51 <enig_> i get just plain "Prelude Main>"
16:37:52 <acube> fetter_oml: There is a function called "state"
16:37:56 <acube> @hoogle state
16:37:56 <lambdabot> Control.Monad.State module Control.Monad.State
16:37:57 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
16:37:57 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar module Graphics.Rendering.OpenGL.GL.StateVar
16:38:02 <acube> @ty state
16:38:03 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:38:59 <fetter_oml> but right now im just copypasting code from: http://learnyouahaskell.com/for-a-few-monads-more#state
16:39:12 <stolaruk> > let (x,y) = (5,10) in x + y
16:39:13 <lambdabot>   15
16:39:18 <enthropy> enig_: :l *myfile.hs
16:39:33 <enig_> thanks
16:39:41 <fetter_oml> he uses State as a Constructor there, it does make sense, but ghci doesnt load (same excuse)
16:39:52 <stolaruk> ^^ How is this possible? I would think that I would have to do "let x = fst (5, 10) in ..."
16:40:09 <fetter_oml> im far from understanding, i just wanted to play with it :|
16:40:54 <fetter_oml> @ty StateT
16:40:54 <lambdabot> (s -> m (a, s)) -> StateT s m a
16:41:09 <enthropy> enig_: the other option is to name your file Myfile.hs, and at the top of the file put   module Myfile where
16:41:14 <fetter_oml> he knows that one, why not
16:41:14 <fetter_oml> @ty State
16:41:15 <lambdabot>     Not in scope: data constructor `State'
16:41:15 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
16:41:33 <enthropy> then compiled code loaded in ghci will have all the top-level definitions in Myfile.hs
16:41:39 <acube> fetter_oml: he's using an older version of mtl
16:42:01 <acube> fetter_oml: in newer versions, you have to use the state function instead of the State constructor (they do the same)
16:42:04 <acube> @ty state
16:42:05 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:42:25 <monochrom> fetter_oml: the library has changed after the book. change "State (\x -> ...)" to "state (\x -> ...)" etc. the types are alright, just change the expressions
16:42:35 <fetter_oml> ah, ok
16:42:46 <fetter_oml> tried exchanging it with StateT, didnt go well
16:42:54 <acube> @src state
16:42:54 <lambdabot> Source not found. Just try something else.
16:43:29 <enthropy> :t \f -> StateT $ \s -> return (f s)
16:43:30 <lambdabot> Monad m => (s -> (a, s)) -> StateT s m a
16:44:04 <monochrom> erisco: I agree that the type S can be designed corresponding to the grammar. but right now you haven't set up a correct correspondence, or even understood the grammar.
16:44:21 <fetter_oml> acube: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-State-Lazy.html here it is.
16:44:35 <fetter_oml> I find the error message quite misleading, btw
16:44:43 <erisco> monochrom, I understand the grammar. I also meant    S a b = a (S a b) b
16:44:55 <fetter_oml> but it works with state instead of State. thank you very much :)
16:44:59 <erisco> monochrom, I am trying to break down what I'm thinking into small bits so I might figure it out =\
16:45:09 <fetter_oml> now i can go and understand wtf is happening.
16:48:26 <erisco> okay, so this might be a start. I don't totally understand this discrepency: http://paste.tryhaskell.org/90700
16:49:21 <erisco> I guess that  (1,) isn't of kind * -> * but then I don't know what it is... not sure how it relates to the data type 'A'
16:50:30 <ion> (1,) :: b -> (a,b), not (1,) :: * -> *
16:50:51 <ion> Imagine data (,) a b = (,) a b
16:50:55 <erisco> okay I might have said  (,)Char :: * -> *
16:51:25 <ion> If it was data (,) a = (,) a ((,) a), it would work just like your data A a.
16:52:08 <dmwit> data B a b = B a b; a3 = B 1 a3 -- yes problem
16:52:34 <dmwit> Alternately: recursive types are fine; you just have to break all cycles in the dependency graph with a constructor.
16:52:44 <dmwit> e.g. here A
16:53:14 <erisco> I seem to be muddling things then... must be developing a brain tumour
16:53:32 <dmwit> (It doesn't help that both (,) and A are overloaded to be both value constructors and type constructors.)
16:53:48 <dmwit> (Meaning, it doesn't help the clarity of discussion. =)
16:54:18 <erisco> well, I understand the difference between the two. that isn't my confusion... and pointing out   data (,) a b = (,) a b  makes sense
16:54:44 <erisco> even taking b = (,) a b  you have infinite type because you have to take the next b to (,) a b as well
16:55:15 <dmwit> correct
16:56:07 <dmwit> Your type A essentially satisfies that equation for b; namely A a = (,) a (A a)
16:56:14 <dmwit> but the constructor is named A, not (,) ;-)
16:56:22 * hackagebot vector-functorlazy 0.0.1 - vectors that perform the fmap operation in constant time  http://hackage.haskell.org/package/vector-functorlazy-0.0.1 (MikeIzbicki)
16:56:58 <ion> @type let a :: Fix ((,) Integer); a = In (1,a) in a
16:56:59 <lambdabot> Not in scope: type constructor or class `Fix'
16:57:11 <ion> @let newtype Fix f = In { out :: f (Fix f) }
16:57:12 <lambdabot>  .L.hs:128:30:
16:57:12 <lambdabot>      Ambiguous occurrence `out'
16:57:12 <lambdabot>      It could refer to either ...
16:57:28 <ion> @let newtype Fix f = FixIn { fixOut :: f (Fix f) }
16:57:29 <lambdabot>  Defined.
16:57:37 <ion> @type let a :: Fix ((,) Integer); a = FixIn (1,a) in a
16:57:38 <lambdabot> Fix ((,) Integer)
16:58:52 <enig_> how do i "unpack" values from a list? for example, if i have a function of type Bool -> Bool -> Bool but i get passed [Bool, Bool]
16:59:12 <ion> foo [a, b] = bar a b
16:59:33 <ion> And remember to compile with -Wall
16:59:38 <erisco> maybe what I am thinking of is data A a b = A a (A b)  let's see o0
16:59:49 <dmwit> erisco: looks ill-kinded to me
16:59:57 <erisco> oh oops
17:00:07 <ion> @type let a :: Fix ((,) Integer); a = FixIn (1,a) in fix (\f (FixIn (a,b)) -> a : f b) a
17:00:07 <lambdabot> [Integer]
17:00:13 <ion> > let a :: Fix ((,) Integer); a = FixIn (1,a) in fix (\f (FixIn (a,b)) -> a : f b) a
17:00:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:00:21 <erisco> dmwit, well damn =\
17:00:36 <erisco> ion, doing some mental flexing? ;)
17:00:41 <shachaf> ion: Mu and Nu are the true Fixes. :-(
17:01:05 <dmwit> Perhaps you meant data A a b = A a (A a b) {- no different than what you already had -} or data A a b = A a (A b a) {- quite fun, but of limited use -}
17:01:20 <ion> erisco: Just demonstrating how you can use type-level (,) self-recursively with Fix.
17:01:43 <ion> shachaf: Where are the definitions?
17:01:45 <erisco> dmwit, of course then I thought  A a b = A a (A b c)  and then  A a b c = A a (A b c d)  then realized I was in trouble :P
17:01:57 <shachaf> ion: newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
17:02:05 <shachaf> ion: data Nu f = forall x. Nu x (x -> f x)
17:02:11 <ion> thanks
17:02:17 <dmwit> erisco: You may also like: HList
17:02:25 <shachaf> ion: Nu problem.
17:02:33 <erisco> hetrogenous lists?
17:02:45 <erisco> I don't know ... I'm just confusing myself at this point really
17:02:51 <shachaf> ion: In Haskell all these types are the same. So write functions to convert between them.
17:03:10 <ion> shachaf: No, really, I’mu very grateful.
17:03:10 <erisco> :t Fix
17:03:11 <lambdabot> Not in scope: data constructor `Fix'
17:03:29 <erisco> :t FixIn
17:03:30 <Gracenotes> what's up with your apostrophe, ion
17:03:30 <lambdabot> f (Fix f) -> Fix f
17:03:50 <ion> gracenotes: It’s the one the English language uses.
17:03:51 <dmwit> smart quotes!
17:04:19 <Gracenotes> I don't know what weird dialect of English you speak
17:04:36 <erisco> ion, Fix looks like mu is it?
17:04:48 <shachaf> Gracenotes is a Mu/Nu expert these days.
17:04:57 <Gracenotes> oh *blushes*
17:05:41 <Gracenotes> Both the first argument to Mu and the fix constructor strip off a layer of 'f'
17:05:57 <Gracenotes> however, Mu strips it off of any r, and Fix only strips it off of Fix f
17:07:00 <Gracenotes> Not that the two are that distinct, if you're trying to convert between them.
17:13:53 <byorgey> Fuuzetsu: were you looking for me?
17:15:07 <Fuuzetsu> byorgey: We were just wondering why there were no Haddocks generated for first-class-patterns but Haddock it was concluded to be a Haddock error somewhere.
17:15:23 <Fuuzetsu> s/but Haddock//
17:15:34 <Fuuzetsu> … but*
17:17:15 <Fuuzetsu> glguy: Here?
17:17:20 <stolaruk> In "let (x,y) = (5,10) in x + y", are x and y bound via everyday pattern matching?
17:17:22 <byorgey> Fuuzetsu: "haddock: internal error: renameType"  -- from the logs
17:17:31 <Fuuzetsu> Yes, we found that ;)
17:17:33 <byorgey> stolaruk: yep
17:17:36 <byorgey> Fuuzetsu: ok =)
17:17:53 <stolaruk> byorgey: That's cool, thanks.
17:17:58 <shachaf> stolaruk: There's a small difference from case, namely that it's lazy.
17:18:05 <shachaf> > let (x,y) = undefined in "hi"
17:18:06 <lambdabot>   "hi"
17:18:10 <shachaf> > case undefined of (x,y) -> "hi"
17:18:11 <lambdabot>   "*Exception: Prelude.undefined
17:18:56 <stolaruk> So case is NOT lazy?
17:19:28 <Hermit> stolaruk: deppends on the type, how it treats bottom
17:19:44 <shachaf> In general, yes.
17:21:08 <Gracenotes> > case (undefined, undefined) of (x, y) -> "bye"
17:21:09 <lambdabot>   "bye"
17:21:22 <Gracenotes> > case ~undefined of (x, y) -> "bye"
17:21:23 <lambdabot>   Pattern syntax in expression context: ~undefined
17:21:42 <Gracenotes> > case undefined of ~(x, y) -> "bye"
17:21:43 <lambdabot>   "bye"
17:21:45 <Gracenotes> yes. that.
17:21:58 <Gracenotes> ..probably did not help too much
17:22:07 <Gracenotes> ignore ~
17:22:41 <meretrix`> I have a long-running Haskell process that I would like to control by calling a few functions from a ghci session.  I have it working with ZeroMQ and MessagePack, but would like something more type-safe.  Is there a better alternative?
17:22:54 <stolaruk> > (let (x:_) = "Hello" in x) == head "Hello"
17:22:55 <Gracenotes> you can think of let and case as operationally different things. 'let' is similar to allocation, of functions, data values, etc.; and 'case' is what forces computation to happen.
17:22:55 <lambdabot>   True
17:22:59 <startling> which EitherT package am I supposed to use again?
17:24:33 <erisco> still hunting for ane xample... how does Parsec implement a recursive grammar rule?
17:24:44 <erisco> I should probably say self-referential instead
17:25:09 <erisco> one that isn't trivially reduced to 'many' or something
17:27:41 <startling> erisco, it's not clear what you're asing
17:27:43 <startling> k
17:28:17 <erisco> A -> B A C    for example
17:28:33 <startling> what do those letters mean?
17:28:43 <erisco> names of grammar rules
17:29:40 <dmwit> erisco: You would write parseA = pure A <$> parseB <*> parseA <*> parseC; but first you would look at your whole grammar and make sure this was an okay thing to do.
17:29:54 <Gracenotes> erisco: that language is empty
17:29:59 <dmwit> And you would refactor the grammar if not.
17:30:06 <Gracenotes> er, unless there's another case for A
17:30:18 <erisco> Gracenotes, I purposefully left out B and C because I didn't want someone to reduce it to an altnerative grammar: it isn't about that
17:30:46 <Gracenotes> in which case, gotta backtrack or somethin
17:30:53 <dmwit> erisco: (Gracenotes is observing that B and C don't matter.)
17:31:00 <erisco> I'm just talking about types
17:31:04 <zRecursive> I just download GHC from http://www.haskell.org/ghc/download_ghc_7_6_3 for FreeBSD x86, it seems there is no cabal install ?
17:31:06 <dmwit> erisco: (As it stands, the language of A is empty.)
17:31:58 <dmwit> zRecursive: cabal is not a part of GHC, no
17:32:10 <erisco> dmwit, I suppose I should figure out how to install Parsec and look at the type signatures of that then
17:32:19 <dmwit> cabal "knows" about GHC; but it also "knows" about nhc and yhc and some others
17:32:35 <zRecursive> dmwit: then are there any binary of cabal install ?
17:32:46 <enig_> is (\x [a, b] -> x a b) a Prelude function?
17:32:55 <dmwit> zRecursive: I don't know!
17:32:56 <dmwit> enig_: nope
17:33:03 <Gracenotes> what if it fails :o
17:33:09 <monochrom> Example grammar rule: X ::= '(' X ')' | emptystring. Example parsec code: x = char'(' >> x >> char')' <|> return (). I'm returning (), i.e., runParser will only tell you "success" or "failure". if you want a more interesting answer, that can also be arranged.
17:33:41 <dmwit> (minor nitpick: it will have to be char '(' >> x >> char ')' >> return ().)
17:33:51 <monochrom> oh yikes, yeah
17:34:16 <monochrom> x = char'(' >> x >> char')' >> return () <|> return ()
17:35:01 <erisco> I need something of a parse tree. If I could just reduce to a bool then I wouldn't have any of these questions
17:35:11 <erisco> turns out cabal already had it installed for me... taking a look
17:36:10 <erisco> dmwit, neither of those operators were defined :p
17:37:07 <erisco> ghci suggested <|> or <!>
17:37:19 <dmwit> :m + Control.Applicative
17:37:45 <enig_> using foo _ = should match any list that isn't length two, right?
17:37:47 <dmwit> Also, import parsec hiding <|>.
17:37:57 <enig_> assuming i have foo [a, b] = before it
17:38:01 <dmwit> enig_: right
17:38:04 <enig_> or do i need _:[]
17:38:16 <dmwit> _:[] matches any list with exactly one element.
17:38:20 <dmwit> See if you can understand why.
17:38:24 <erisco> prompt line is awfully long now :o
17:38:31 <enig_> dmwit, if i use the error function it should print the error, right?
17:38:39 <dmwit> mu
17:38:45 <enig_> because it's giving me *** Exception: circuits.hs:9:1-19: Non-exhaustive patterns in function or'
17:39:00 <dmwit> ?hpaste enough stuff that we can reproduce your problem locally
17:39:01 <lambdabot> Haskell pastebin: http://hpaste.org/
17:39:13 <geekosaur> oops
17:39:23 <geekosaur> @where hpaste
17:39:23 <lambdabot> http://paste.tryhaskell.org/new/haskell
17:39:32 <Gracenotes> is there a particular reason why you're using [a, b] and not (a, b), or two separate arguments?
17:39:40 <monochrom> I'm too lazy to make a parse tree. I'll make a parse tower. data Tower = More Tower | Done deriving Show. x = char'(' *> (More <$> x) <* char')' <|> return Done. I'm using Applicative operators <$> and <*>. if you want to see just Monad operators and do-notation, that can be arranged.
17:39:41 <dmwit> geekosaur: Oh, is hpaste down or something?
17:39:50 <Gracenotes> the differences between them night not be initially clear
17:40:02 <monochrom> domain name problem. use paste.tryhaskell.org for now
17:40:13 <dmwit> I guess it is down. bummer
17:40:56 <enig_> http://pastebin.com/w2jyjGBd
17:41:12 <dmwit> > "or'" == "or"
17:41:13 <lambdabot>   False
17:41:16 <erisco> hang on I'm still way back at dmwit's first parser there
17:41:24 <dmwit> enig_: You spelled it wrong. =)
17:41:33 <monochrom> I may need more parentheses. x = (char'(' *> (More <$> x) <* char')') <|> return Done
17:41:34 <enig_> what?
17:41:46 <monochrom> or' vs or
17:41:49 <erisco> you guys and gals race on and leave me in the dust ;) I appreciate the enthusiasm
17:41:54 <enig_> just realized i should have used `, anyway
17:42:03 <enig_> can you see why error won't trigger?
17:42:08 <monochrom> and yeah, ' vs `
17:42:19 <dmwit> Yes. Two people have told you why the error won't trigger.
17:42:41 <monochrom> you have a typo, or' vs or
17:42:55 <monochrom> third line
17:44:14 <enig_> ah, lost that on the last edit :P
17:44:16 <enig_> oops
17:44:20 <enig_> i feel dumb
17:44:22 <enig_> anyway
17:45:17 <monochrom> I should have recommended a hex editor.
17:46:07 <dmwit> "Your editor does too much rendering. Don't be weak. Look at the bytes."
17:46:10 <dmwit> I like your style.
17:46:27 <Gracenotes> the quotes are too smart for the users.
17:46:30 <dmwit> I think you invented "go with your heart", too.
17:46:44 <Gracenotes> expect singularity soon
17:46:59 <monochrom> programmers should be the kind of people who understand the most that what you see is not what you get. ironically, they understand it the least.
17:47:12 <monochrom> there are lies, damn lies, and text editors.
17:47:42 <monochrom> yes, I invented "go with your heart" :)
17:48:21 <merijn> I recently saw this version: There are lies, damned lies, big data and big data in the hands of middle management.
17:48:44 <dmwit> ?where hpaste does where ignore extra stuff or do I have to use the other trick?
17:48:44 <lambdabot> http://paste.tryhaskell.org/new/haskell
17:48:48 <dmwit> good for me
17:49:30 <Gracenotes> programming is pretending that what you see is what you get
17:50:10 <erisco> s/programming/abstraction/   I think :)
17:50:24 <erisco> not that Haskell draws many differences
17:51:10 <dmwit> Wizards are the folks that don't get what they thought the saw, but then instead of seeing something else they change what they got.
17:51:24 <Gracenotes> So we beat on, boats against the current, borne back ceaselessly into the*** glibc detected *** node: free(): invalid pointer: 0x00007afd43321e00 ***
17:51:41 * dmwit feels deep
17:54:34 <erisco> then again, even assembly gets changed, rearranged, and executed in mysterious ways, so maybe programming is a fine subject
17:59:26 <monochrom> http://paste.tryhaskell.org/90625 --- there are lies, damn lies, and Show instances
18:01:09 <erisco> (<*>) :: f (a -> b) -> f a -> f b   what does f (a -> b) even mean in fmap :: (a -> b) -> f a -> f b ? how does (a -> b) ->  (a0 -> b0) a -> (a0 -> b0) b  make any sense?
18:02:10 <erisco> am I substituting incorrectly?
18:03:52 <c_wraith> try f = Maybe
18:04:00 <monochrom> ok, consider ( (++) <$> getLine ) <*> getLine. some parentheses are redundant and just for emphasis.
18:04:12 <c_wraith> (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
18:04:56 <monochrom> ( (++) <$> getLine ) :: IO (String -> String)
18:04:58 <erisco> when you substitute f = Maybe in the functor defintiion, that is what I don't understand
18:05:20 <monochrom> therefore, ( (++) <$> getLine ) <*> getLine :: IO String
18:05:48 <monochrom> <$> is synonym of fmap
18:05:49 <erisco> I ... am not there to understand that yet. I'm just trying to make sense of the type signatures
18:05:54 <Gracenotes> <*> is, among other things, a generalization of fmap to many arguments.
18:06:30 <Gracenotes> so maybe you don't just want (a -> b) -> f a -> f b, you also want (a -> b -> c) -> f a -> f b -> f c. This can't be done with plain Functors.
18:06:43 <monochrom> if you don't plug in concrete examples, you will never make sense of the general abstract type sig.
18:07:05 <erisco> I just did a substitution... not sure where I failed to "plug in"
18:07:24 <erisco> and the substitution looks absurd, and I am asking what I did incorrectly. I presume I misunderstood what needs to be substituted
18:07:41 <benmachine> erisco: your substitution is indeed not correct
18:07:50 <benmachine> erisco: you have put a type in for f
18:08:01 <benmachine> but f wants to become a type *constructor*
18:08:02 <benmachine> not a type
18:08:10 <benmachine> e.g. Maybe
18:08:12 <benmachine> or IO
18:08:16 <monochrom> my example uses f=IO, a=String, b=String etc
18:11:02 <erisco> okay so.... lets start with Functor. fmap implies that (Functor f) => f must have kind * -> * right?
18:11:12 <Cale> yes
18:11:27 <Cale> f must have kind * -> * in any instance of Functor
18:12:43 <Cale> class Functor f where
18:12:50 <Cale>   fmap :: (a -> b) -> (f a -> f b)
18:13:09 <erisco> okay, so I read  f ( a -> b)  in <*>  where  f is a Functor, so if we talk about kind * -> **  (like Miranda :D) then * = (a -> b) in this instance, yeah?
18:13:19 <erisco> I am very confused with how fmap looks then
18:13:34 <Cale> f is a type constructor and a -> b is a type
18:13:37 <merijn> @kind Maybe --does this work?
18:13:38 <lambdabot> * -> *
18:13:42 <Cale> so f (a -> b) is a type
18:13:42 <pentace> I want to store a list of values of type Map String t where each map stores different values for the same keys. Would GHC store all the keys several times or share the instances?
18:13:43 <merijn> It does!
18:13:47 <merijn> @kind (a -> b)
18:13:48 <lambdabot> Not in scope: type variable `a'
18:13:49 <lambdabot> Not in scope: type variable `b'
18:13:50 <monochrom> no, a->b has kind *
18:13:50 <merijn> aww
18:13:58 <merijn> @kind forall a b .(a -> b)
18:13:58 <shachaf> λ> let foo :: forall f a b. (a -> b) -> (Functor f => f) a -> (Functor f => f) b; foo f x = fmap f x
18:13:58 <lambdabot>     Illegal symbol '.' in type
18:13:59 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
18:13:59 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
18:14:00 <pentace> Or maybe there's a better way to store the values
18:14:01 <shachaf> ghc: panic! (the 'impossible' happened)
18:14:07 <shachaf> Does someone have a working HEAD to test that in?
18:14:21 <erisco> @kind Maybe id
18:14:22 <lambdabot> Not in scope: type variable `id'
18:14:29 <erisco> @kind Maybe (a -> b)
18:14:29 <Gracenotes> give that type constructor a type argument. type constructors love type arguments.
18:14:30 <lambdabot> Not in scope: type variable `a'
18:14:30 <lambdabot> Not in scope: type variable `b'
18:14:37 <Cale> pentace: It'll store pointers to all the keys multiple times...
18:14:39 <monochrom> f has kind *->* throughout. Functor or Applicative. just accept this.
18:14:42 <merijn> erisco: That makes no sense, "Maybe" is a type constructor, id is a function
18:15:04 <erisco> well a -> b is a function, I dunno
18:15:05 <Cale> @kind Int -> Char
18:15:06 <lambdabot> *
18:15:11 <Cale> @kind Maybe (Int -> Char)
18:15:12 <lambdabot> *
18:15:15 <erisco> this is supremely confusing to me ;)
18:15:23 <merijn> erisco: (a -> b) is the *type* of a function
18:15:25 <monochrom> your mind's kind inference is likely botched
18:15:27 <merijn> id *is* a function
18:15:33 <pentace> Cale: But to the same instance in memory?
18:15:56 <Cale> pentace: So long as when you constructed them, you used the very same strings as keys
18:16:06 <merijn> shachaf: type error in my 7.7
18:16:16 <pentace> I do
18:16:19 <shachaf> merijn: OK, sounds reasonable.
18:16:23 <Gracenotes> It is a good distinction to make, though, that 'Maybe' is not a type.
18:16:47 <erisco> Maybe is n ot a type? what?
18:16:55 <merijn> erisco: It is a type constructor
18:17:10 <Gracenotes> 'Maybe' is not a type; 'Maybe Int' is a type.
18:17:15 <erisco> okay great, evidently I've missed the boat on what a type is too
18:17:17 <Pip> Does Haskell code run faster than C++?
18:17:21 <Cale> pentace: Because of the polymorphism of the definition of, say, Map.fromList, there's no way that it could look inside the Strings in order to pick apart their structure to "copy" it, even. It can only deal with the strings abstractly and compare them using the Ord instance.
18:17:45 <b2coutts> erisco: think about it this way; what value has type 'Maybe'?
18:17:47 <Cale> Pip: Depends which Haskell code and which C++ code.
18:17:48 <merijn> Pip: It depends on which haskell implementation, which C++ implementation, which program, which programmmer, the alignment of the constellations
18:18:00 <geekosaur> erisco: types have kind *. Maybe kas dkind * -> *; that is, if yu apply it to a type, it produces a type
18:18:02 <merijn> Pip: In other words, your question is meaningless without context
18:18:07 <Pip> damnit
18:18:10 <Cale> (and choices of implementation, etc as merijn points out...)
18:18:13 <geekosaur> *has kind
18:18:19 <monochrom> Does Haskell code run faster than C++? I don't know. I only know: my code runs faster than yours.
18:18:36 <Gracenotes> todo: set up astrological programming consultancy
18:18:37 <erisco> I didn't realize * -> * wasn't a type... it was described to me as "a type that returns another type"
18:18:42 <pentace> Cale: I get the strings as values from another map, so they really should be the very same instances
18:18:52 <Cale> Pip: It tends to be hard to get a Haskell compiler to compile C++ code or a C++ compiler to compile Haskell code, so it's tricky to compare implementations straightforwardly.
18:19:15 <merijn> erisco: * -> * is the *kind* of a *type constructor* that returns a *type* (although sometimes people will call type constructors types too
18:19:15 <benmachine> erisco: how people use terminology may differ depending on who you ask, but certainly it is at least the case that Maybe is not the type of any value
18:19:56 <Cale> erisco: Every ordinary value has kind *
18:19:58 <merijn> "Just :: a -> Maybe a", "Maybe :: * -> *"
18:20:01 <Cale> er, has a type with kind *
18:20:02 <Cale> rather
18:20:04 <Gracenotes> * -> * is "a type constructor that returns another type"
18:20:08 <merijn> "1 :: Int", "Int :: *"
18:20:25 <erisco> not "another type", just "some type"
18:20:39 <Cale> If t :: * -> *, then there is no x such that x :: t (and indeed, this will be a kind error to write)
18:20:44 <Gracenotes> well, a type different from the one passed in.
18:20:56 <merijn> Gracenotes: Not necessarily!
18:21:12 <Gracenotes> Different to Haskell, non-unifiable. They may be isomorphic.
18:21:22 <merijn> "type instance Id x = x" "Id :: * -> *", "Id Int ~ Int"
18:21:44 <Gracenotes> well that's some weird stuff :p
18:21:58 <Gracenotes> but yes, isomorphism may be the best you can hope for.
18:22:11 <Gracenotes> also interesting: Maybe Nat ~ Nat.
18:22:13 <merijn> Gracenotes: That's not isomorphism, those types are equal
18:22:23 <merijn> Gracenotes: ~ is type equality in haskell
18:22:34 <erisco> okay ... so....
18:22:44 <Gracenotes> oh, I am using it for isomorphism here. anyway... that is not stock Haskell, not even 2010.
18:23:00 <merijn> Gracenotes: The "different type is returned" restriction seems an unnecessary extra constraint
18:23:12 <Cale> erisco: So, whatever type-level thing f is, it had better be something that can accept a type parameter
18:23:58 <Cale> erisco: "(s -> t) a" makes no sense as you pointed out, and so this will be a kind error if you tried to make an instance of Functor (s -> t)
18:24:01 <erisco> what in the world does  f (a -> b) mean =\  if f is * -> * then (a -> b) is a type ... so ... fmap becomes  ((a -> b) -> (a0 -> b0)) -> f (a -> b) -> f (a0 -> b0)  ?
18:24:16 <merijn> erisco: huh
18:24:25 <erisco> merijn, taking a stab in the dark here
18:24:35 <merijn> "f :: * -> *", "Maybe :: * ->*"
18:24:41 <merijn> replace f with Maybe
18:24:42 <Gracenotes> merijn: you'll notice my phrasing was based off of another phrasing, though... as far as data/newtype go, it's a bit inconsequential. anyway tho.
18:24:44 <erisco> I've given up on understand and have started stabbing things
18:24:51 <merijn> "fmap :: (a -> b) -> Maybe a -> Maybe b"
18:24:56 <Cale> you could use fmap at that type, sure
18:25:14 <Cale> fmap's type certainly specialises to the type that erisco gave
18:25:42 <merijn> Sure, but I think that's mostly by accident
18:26:02 <merijn> erisco: "a -> b" is a type, why wouldn't it be?
18:26:06 <erisco> okay so with <*> is it not giving the type signature ((a -> b) -> (a0 -> b0)) -> f (a -> b) -> f (a0 -> b0)  with   f (a -> b)  ?
18:26:27 <Cale> If x :: f (a -> b), and you apply  fmap f x  then  f :: ((a -> b) -> c)
18:26:33 <Cale> (for some c)
18:26:38 <merijn> erisco: Once again, replace f with Maybe and get "<*> :: Maybe (a -> b) -> Maybe a -> Maybe"
18:26:39 <wleslie> How do people normally search for constructor applications or definitions across large projects?  I'm using emacs and it would be really nice to do that within the editor
18:26:59 <Cale> wleslie: mostly grep
18:27:07 <erisco> merijn, I don't see what the is relevant. I am asking how that carries over into Functor
18:27:15 <erisco> I may be grossly misunderstanding
18:27:23 <Gracenotes> how do you get a Maybe (a -> b)? Well, if you have an (x -> a -> b) and a Maybe x, you figure it out :)
18:27:37 <merijn> erisco: Let 's take (+)
18:27:44 <merijn> And specialise to Int
18:27:50 <wleslie> ah, that's what I've been doing. hm
18:27:52 <Cale> > Just (+5) <*> Just 5
18:27:53 <lambdabot>   Just 10
18:27:57 <Cale> > Just (*5) <*> Just 5
18:27:58 <lambdabot>   Just 25
18:28:05 <Cale> > Just (*5) <*> Nothing
18:28:06 <merijn> "(+) :: Int -> Int -> Int"
18:28:06 <lambdabot>   Nothing
18:28:13 <Cale> > Nothing <*> Just 5
18:28:14 <lambdabot>   Nothing
18:28:18 <Cale> > Nothing <*> Nothing
18:28:20 <lambdabot>   Nothing
18:28:34 <Gracenotes> How do you get a Maybe (a -> b) from a (z -> y -> x -> a -> b)? well, if you have a Maybe z, Maybe y, and Maybe x., ... etc.
18:28:57 <monochrom> let's start with (x->a->b) first :)
18:29:03 <Gracenotes> fursure
18:29:23 <Cale> Why are people considering functions of more than one argument here?
18:29:30 <Cale> :t (<*>)
18:29:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:29:33 <merijn> "fmap :: (a -> b) -> f a -> f b" "(+) :: Int -> (Int -> Int)" so f=Maybe, a=Int, b=Int->Int
18:29:58 <Gracenotes> Well, that's what applicative lets you do, thinking in terms of idiom brackets. but, jumping ahead a bit.
18:30:09 <merijn> "fmap (+) :: Maybe Int -> Maybe (Int -> Int)"
18:30:25 <merijn> How do we add one more argument to "fmap (+)"? by using <*>
18:30:41 <monochrom> Cale, because probably it is requested to use Functor and Applicative together. therefore, the smallest example has to be f<$>x<*>y
18:30:55 <erisco> okay guys, again the enthusiasm is great, but I can't follow three people at once
18:31:02 <merijn> "<*> :: Maybe (a -> b) -> Maybe a -> Maybe b" a=Int, b=Int (because "fmap (+) 1 :: Maybe (Int -> Int)"
18:31:24 <merijn> eh
18:31:28 <erisco> or all these examples, most of which fly over my head =\ I can't understand the simple semantics of how substitution is happening with the type signatures, so I am still working on that
18:31:32 <merijn> "fmap (+) (Just 1)" there
18:31:47 <merijn> erisco: The a and b in the fmap and <*> signatures are not the same a and b
18:31:55 <Cale> Yeah, let's not worry about more complicated examples until erisco at least understands how (<*>) works
18:32:19 <Cale> erisco: Did you have a look at the Maybe examples I gave above?
18:32:26 <Cale> Especially Just (*5) <*> Just 5
18:32:35 <Cale> Does it make sense what's going on there?
18:32:54 <erisco> I get what <*> is doing, but I don't .... here maybe this will help
18:33:03 <erisco> @src (<*>)
18:33:03 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:33:08 <erisco> wait it is a class -.-
18:33:14 <Cale> instance Applicative Maybe where
18:33:17 <Cale>   pure = Just
18:33:27 <Cale>   Just f <*> Just x = Just (f x)
18:33:44 <Cale>   Nothing <*> v = Nothing
18:33:55 <Cale>   f <*> Nothing = Nothing
18:34:13 <Cale> (I could also have combined those last two into  _ <*> _ = Nothing )
18:34:37 <erisco> is that legit Haskell?
18:34:40 <Cale> yes
18:35:08 <erisco> oh, neat ... seems rather bizarre to handle with the parser
18:35:27 <Cale> You mean defining the infix operator like that?
18:35:29 <erisco> I suppose it already has the signature and does pattern matching on the left anyhow
18:37:45 <monochrom> it's infix notation. you could write "(<*>) (Just f) (Just x) = Just (f x)", at the expense of more compulsory parentheses, you know...
18:37:56 <Cale> yeah
18:38:04 <Cale> We also have:
18:38:09 <Cale> instance Applicative [] where
18:38:17 <Cale>   pure v = [v]
18:38:33 <erisco> ya know, with all the help you guys provide, you should start up an online course for $500/4mo 1 mentor per 15 students and away you go
18:38:33 <Cale>   fs <*> xs = [f x | f <- fs, x <- xs]
18:38:47 <erisco> just an idea ;)
18:39:25 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [5,6,7]
18:39:27 <lambdabot>   [5,6,7,7,8,9,10,12,14,25,36,49,32,64,128]
18:39:53 <Cale> (see how that works?)
18:40:29 <erisco> okay like I said, I understand what <*> does .... I don't understand the relation between Applicative and Functor
18:40:52 <erisco> Applicative requires Functor and I don't get it. obviously fmap is used somehow, somewhere
18:40:58 <Cale> Well, for every instance of Applicative you are also required to provide an instance of Functor
18:41:29 <shachaf> But liftA is a valid implementation.
18:41:38 <Cale> So any type signature which has a constraint (Applicative f) => ... is allowed to assume that f is also an instance of Functor
18:41:51 <erisco> why
18:41:53 <monochrom> pure f <*> x = fmap f x.
18:42:02 <Cale> Furthermore, there is a law which ought to always hold, and monochrom has already typed it ;)
18:42:30 <erisco> is that why?
18:42:34 <Cale> > [(^2)] <*> [1,2,3,4,5]
18:42:35 <lambdabot>   [1,4,9,16,25]
18:42:40 <Cale> > pure (^2) <*> [1,2,3,4,5]
18:42:41 <lambdabot>   [1,4,9,16,25]
18:42:46 <Cale> > fmap (^2) [1,2,3,4,5]
18:42:47 <lambdabot>   [1,4,9,16,25]
18:43:09 <Cale> You can always implement a perfectly good fmap if you have pure and <*>
18:43:34 <Cale> and there's a definition: liftA f x = pure f <*> x
18:43:46 <Cale> So that if you write your Applicative instance first, you can always write:
18:43:55 <Cale> instance Functor MyThing where
18:43:56 <byorgey> (in fact, that law is guaranteed to hold as long as   pure id <*> x = x)
18:43:57 <Cale>   fmap = liftA
18:44:39 <Cale> (and in fact it doesn't matter which order you actually write them in the file, so long as you provide both)
18:44:47 <erisco> sorry I thought it was a fairly simple question. Why class Functor f => Applicative f  and not just  class Applicative f?  I presume the exclusive reason for the Functor contraint on 'f' is because some implemention of pure, <*>, *>, <* would require use of fmap
18:45:34 <Cale> erisco: Because it keeps type signatures smaller. If something knows that f has an instance of Applicative, it's allowed to use fmap without additionally having a Functor f constraint
18:46:44 <erisco> so replace fmap/Functor with any other fun/class in your argument and why isn't that valid too?
18:46:45 <Cale> and since you always *can* provide a good Functor instance which operates nicely in conjunction with your Applicative instance, there's not much reason that you shouldn't be required to do so
18:47:37 <Cale> All that the superclass constraint does is force you to provide an instance of Functor whenever you write an instance of Applicative (which you can always do easily as I showed above)
18:47:52 <erisco> I understand what the constraint does
18:48:03 <Cale> and polymorphic things which demand an Applicative will be able to assume that thing is also a Functor
18:48:25 <byorgey> erisco: absractly, all applicatives are also functors, so we might as well have all Applicatives be Functors.
18:48:56 <erisco> byorgey, right, okay, I think that is what Cale was getting to especially with the equivalence between pure <*> and fmap
18:49:01 <Cale> Monad should *also* have an Applicative superclass constraint, and it only doesn't because of hysterical raisins.
18:49:04 <byorgey> erisco: right
18:49:17 <byorgey> but it might be getting one soon...?
18:49:22 <byorgey> we'll see
18:49:23 <erisco> Cale, sorry I just can't go faster than one baby step at a time ;)
18:49:23 <Cale> yay
18:50:01 <Cale> byorgey: It's good to see that the least controversial changes to the Prelude are finally seeing some traction after all these years ;)
18:50:02 <tswett> Is there a Haskell implementation out there designed primarily to be simple?
18:50:02 <erisco> historical raisins? what meme have I stumbled on?
18:50:05 <tswett> I'd like to try modifying it.
18:50:30 <Cale> erisco: yeah, historical reasons <-> hysterical raisins
18:50:34 <Cale> ancient meme
18:50:55 <erisco> I misread the first word oO definitely brain tumour I think
18:51:45 <byorgey> Cale: yep =)
18:52:31 <erisco> so it doesn't bother Haskellers that these classes assume kinds * ->  *?
18:53:02 <Cale> uh, it can't bother us?
18:53:23 <Cale> fmap :: (a -> b) -> (f a -> f b) -- there's no way f could *possibly* have any kind other than * -> * here
18:53:26 <erisco> it just seems incomplete, to me, from a design standpoint, to have n-ary type constructors and then neglect them in classes
18:54:15 <monochrom> it doesn't bother me. why should I be? in fact, most other languages disallow classes for *->*, their limitation shows.
18:54:30 <Cale> Well, if you wanted to define some other operations on types with more parameters, then those operations would themselves have quite different types most likely
18:54:38 <Cale> For example, you can define:
18:54:45 <Cale> class Bifunctor f where
18:55:17 <Cale>   bimap :: (a -> c) -> (b -> d) -> (f a b -> f c d)
18:55:32 <erisco> I just don't see why you wouldn't have, say,   Foo (+1) (++"heya") (id) <$> Foo 1 "hiya" 6
18:55:57 <Cale> Not every type with multiple type parameters is isomorphic to a tuple of those
18:55:58 <erisco> seems like a simple extension of the idea
18:56:19 <Cale> and... it's unclear how this generalises
18:56:33 <shirt> is there something like mapM_ that returns the number of elements that were in the list?
18:56:41 <erisco> Cale, why is it unclear?
18:56:42 <Cale> shirt: length?
18:56:58 <geekosaur> erisco: you're assuming a particular generalization
18:57:06 <erisco> yes I am
18:57:10 <Cale> erisco: Well, what would your typeclass look like?
18:57:11 <shirt> Cale: i want to avoid traversing the list twice
18:57:16 <geekosaur> erisco: Haskell supports quite a bit more than that single generalization
18:57:31 <erisco> Cale, that isn't what I'm saying. I am asking from the perspective of how the language is designed
18:57:58 <geekosaur> if we assume your generaliation then we lose all the others
18:58:00 <erisco> the concepts Haskell has are odd to me so I think the discussion is relevant
18:58:00 <Cale> erisco: Well, it's hard to say what the types of the operations you're talking about would be more generally.
18:58:09 <startling> erisco, I think you need dependent types for that to work
18:58:25 <Cale> There's probably *something* you can do
18:58:34 <thoughtpolice> shirt: you can use foldM_ over a tuple and increment the counter?
18:58:45 <erisco> well it sounds like code gen type stuff (aka compiler duct tape)
18:58:45 <startling> yeah, just after I said that I was thinking fundeps and maybe datakinds. 8)
18:59:08 <startling> you'd need type-level lists anyhow
18:59:24 <Cale> Type level vectors, more likely
18:59:27 <tswett> @type (<$>)
18:59:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:59:34 <dmwit> shirt: Don't think there's anything in a library, but it's easy to write yourself.
18:59:38 <Cale> (i.e. lists of exact lengths)
18:59:57 <erisco> Cale, as it stands, if I have a record with many fields, I would have to choose which one of the fields I can modify in my Applicative instance for that record
19:00:03 <thoughtpolice> oh, i guess you can't use foldM for that, sorry
19:00:18 <thoughtpolice> well, it might be a little awkward
19:00:19 <monochrom> @type foldM
19:00:19 <erisco> data Student = Student { name :: String, age :: Int, gpa :: Float }
19:00:20 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:00:21 <Cale> erisco: You likely don't have an Applicative instance for some random datatype
19:00:23 <startling> Cale, I was thinking class NTraversable x | x -> [Type] or something
19:00:32 <shachaf> Would you be OK with traverse_, rather than mapM_?
19:00:40 <monochrom> foldM does something different
19:00:52 <dmwit> erisco: Perhaps you are wishing for lenses rather than an Applicative instance if your goal is to modify fields of a record.
19:01:04 <Cale> erisco: That can't be an instance of Applicative because it's the wrong kind.
19:01:12 <erisco> ... I know
19:01:15 <shirt> yeah, foldM doesn't seem like it will work
19:01:32 <dmwit> erisco: Use Google to find twanvl's wonderful blog post on functional references, or wait a bit while I bring up my system and send you a link.
19:02:12 <dmwit> erisco: http://twanvl.nl/blog/haskell/overloading-functional-references
19:02:23 <Cale> erisco: Perhaps it will be clearer once you've seen more examples of these things
19:02:28 <enthropy> shirt: you do the mapM_ using  StateT Int m, instead of your current m
19:02:32 <shirt> shachaf: i guess... but i can't quite see how traverse can be used here
19:02:34 <erisco> I'm just pointing out something that appears strange, to me, and I'm not necessarily looking for any solution. I was just interested if there was any conventional knowledge
19:02:40 <Cale> erisco: A good example would be Parser
19:02:57 <tswett> erisco: I have difficulty imagining how else things could be.
19:03:00 <dmwit> There is conventional knowledge.
19:03:12 <shirt> enthropy: hm... that seems a bit complicated
19:03:14 <dmwit> Records don't make good Applicatives, but do make good lens fodder.
19:03:35 <dmwit> enthropy: Yes, much too complicated; should use WriterT (Sum Int) instead. ;-)
19:03:55 <tswett> I guess we could somehow make Functor polymorphic, so that bifunctors, trifunctors, and whatnot can also be instances of the Functor class. But I'm not sure if that would be useful, or easy to use.
19:04:04 <shachaf> λ> fst . getCompose $ traverse_ (\x -> Compose (Sum 1,putChar x)) "hello"
19:04:04 <shachaf> Sum {getSum = 5}
19:04:08 <shachaf> λ> snd . getCompose $ traverse_ (\x -> Compose (Sum 1,putChar x)) "hello"
19:04:08 <shachaf> helloλ>
19:04:43 <shachaf> (Probably there are nicer ways to express that, but that's the idea.)
19:04:49 <Cale> (<*>) :: Parser (a -> b) -> Parser a -> Parser b -- If you can parse the initial part of the input and construct from it a function of type a -> b, and then parse the initial part of the remainder and construct from that some result of type a, then you can apply the function to the argument and get a parser whose result has type b.
19:04:50 <erisco> tswett, Haskell perhaps has designed itself into a corner in this aspect. It seems so.
19:04:56 <erisco> I was just curious as to why this was
19:05:11 <erisco> but I see it is rooted in "that is how it is" so, no worries then
19:05:34 <tswett> erisco: well, to be frank, I don't know what you're talking about.
19:05:48 <enthropy> :t \f xs -> flip execStateT 0 $ mapM_ (\x -> do modify (+1); lift (f x)) x
19:05:49 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Expr'
19:05:49 <lambdabot>     In the second argument of `mapM_', namely `x'
19:05:49 <lambdabot>     In the second argument of `($)', namely
19:05:54 <enthropy> :t \f xs -> flip execStateT 0 $ mapM_ (\x -> do modify (+1); lift (f x)) xs
19:05:55 <lambdabot> (Monad m, Num b) => (a -> m b1) -> [a] -> m b
19:06:31 <Cale> erisco: Any generalisation of this idea which works for other kinds is also likely going to be much more annoying and complicated to actually use, in the cases where we really do want it.
19:06:49 <erisco> dmwit, that is an interesting idea
19:06:52 <shachaf> Or Writer, rather than State.
19:07:08 <shachaf> Applicative is more general because you don't need a transformer, but I guess that doesn't matter much here.
19:07:11 <Cale> erisco: 99% of the reason that Applicative exists is so that we have a certain kind of nice notation for composing computations in a certain style of library.
19:07:31 <pentace> shachaf: Where is traverse_ defined?
19:07:35 <shachaf> Data.Foldable
19:07:41 <Cale> erisco: and are able to generalise over that, in order to write a handful of things which can work over any Applicative
19:07:47 <shachaf> It's more or less the same as mapM_, except more general.
19:07:55 <Cale> But *mostly* it's the notational aspect.
19:08:03 <shachaf> pentace: Really, this might be simpler written as a fold or something.
19:08:24 <Cale> So if you start generalising things in a way where you have to more carefully specify how the operation is to be applied, you're likely ruining things.
19:09:19 <pentace> I've never noticed that module
19:09:30 <Cale> (and people will just go back to using pre-specialised operations from their given libraries -- there's no *real* need for Functor/Applicative/Monad to exist, apart from the fact that they save us effort redefining things of the same shapes in multiple libraries)
19:09:49 <Cale> as with any abstraction
19:10:06 <erisco> Cale, is their existence not the essence of code reuse?
19:10:23 <erisco> is that not the prime objective of classes?
19:11:16 <erisco> Haskellers seem to downplay the significance of classes, but afaik, they are the most important part of the whole thing
19:11:25 <Cale> Yes, for the most part, the whole reason they exist is to be able to reuse this notation and the definitions in terms of that notation in Control.Applicative and Control.Monad and other places where you have code which is generalised over the choice of such.
19:11:43 <Cale> But! They're not a *huge* deal
19:11:57 <Cale> We could *easily* live without these particular classes if we had to.
19:12:26 <enthropy> there's almost twice as much notation as needed though, considering  mapM_ == traverse_ and similar
19:12:32 <Demos> I am finding Network.HTTP somewhat painful, is there anything better?
19:12:51 <erisco> I don't understand how that could be true. If you have 3rd party modules A and B, and they happen to use the same interface X, then you can trivially use them together
19:12:57 <Cale> and each library that would otherwise define an instance of Monad would end up with a little version of Control.Monad inside itself -- probably not quite with *all* the operations, but whichever ones made the most sense in context.
19:13:23 <erisco> if A and B use X1 and X2 respectively, instead, then you're boned with conversions that may or may not even be possible
19:13:27 <Cale> Some stuff would kind of suck
19:13:48 <tswett> erisco: that does sound like a good point.
19:14:16 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html -- for instance, my aStarM here is an algorithm written to be generalised over a choice of monad.
19:14:36 <tswett> But I can't actually think of an example of when that would happen.
19:14:38 <Cale> and that kind of thing wouldn't be possible -- you'd have to choose which monad(s) to implement it in up-front
19:14:49 <Cale> But there aren't many examples of that sort of thing, really.
19:15:12 <Cale> and tbh, I have *never* used aStarM except to test it, and I don't know whether any of my users have either :P
19:15:23 <erisco> also, afaik (which is only hearsay), concepts in C++ are supposed to attempt to infer that X1 == X2 so that you can use the libraries together anyways
19:15:52 <tswett> erisco: do keep in mind, by the way, that as Haskell isn't an object-oriented language, classes are significantly less important in Haskell than in other languages.
19:16:12 <Cale> erisco: anyway, it doesn't necessarily apply to every type class, but these particular ones serve more of a notational purpose than one of generalisation in a lot of cases
19:16:31 <Cale> There are some *really* cool examples of generalising over a choice of monad though, don't get me wrong.
19:17:20 <tswett> Types, on the other hand, are extremely important in Haskell, and I'd argue that for the most part, Haskell's types are a better analogue of "interface" than Haskell's classes.
19:17:22 <startling> I think it's mostly a code readability thing
19:17:46 <startling> "this code is monadic (I see do or >>=) so I can understand vaguely what it'll do"
19:17:49 <Demos> OO style classes become much less useful when you don't have state
19:17:57 <tswett> Third-party modules using the same sorts of types are going to be interoperable. Classes are just a small, somewhat imporant part of the type system.
19:18:46 <Cale> Another example which sticks out in my head was the time several years ago when I wrote an L-systems generator with Paolo Martini (xerox), and we ended up realising that our use of the list monad in unfolding nondeterministic L-systems had nothing really special about the list monad in it, and factored that out, and were immediately able to use a random distribution monad instead in order to pick expansions at random.
19:19:04 <Cale> (and have probabilistically-weighted rules)
19:20:32 <Cale> So, there are definitely some very nice things about the abstraction -- but sometimes people make a bigger deal about it than is really deserved -- it usually realistically saves you about 10 or 15 minutes of work per library.
19:22:06 <Cale> erisco: Does that make sense? :)
19:22:09 <shachaf> preflex: seen xerox
19:22:10 <preflex>  xerox was last seen on #css 314 days, 20 hours, 6 minutes and 6 seconds ago, saying: http://dev.w3.org/html5/spec/rendering.html#rendering here figure appears but not img
19:23:12 <Cale> Yeah, I wonder where he's been
19:23:47 <Cale> There've been a lot of people over the years who have vanished or changed nicks in a way that I'm not sure about.
19:23:55 <erisco> Cale, the L-systems? I haven't implemented one myself but I am curious why nondeterminism was necessary ... as far as why classes are not too important, I haven't written much Haskell, so it is hard for me to take the anecdotes as evidence
19:24:08 <Cale> erisco: Nondeterminism was necessary for fun :)
19:24:44 <Cale> erisco: Deterministic L-systems tend to produce much more regular-looking images than nondeterministic ones can.
19:24:49 <erisco> does that mean anything special in Haskell? many RNG algorithms are deterministic, so I presume in Haskell they'd be pure
19:25:01 <Cale> Nondet L-systems are really good at getting organic-looking output.
19:25:53 <Cale> Well, nondeterministic in the sense that there are multiple possible expansions for each rule, and we were actually computing *all* of the combinatorially-many expansions initially
19:26:02 <erisco> and from the experience I have with other languages, you're lucky if all you have to do is write a lot of glue code
19:26:10 <erisco> worst case it isn't possible
19:26:17 <Cale> i.e. nondeterministic in the same sense as nondeterministic Turing machines.
19:27:23 <Cale> So, we wrote out this algorithm for one iteration which figured out which rule applied for each symbol, and picked one of its right hand sides in all possible ways, using the list monad
19:27:33 <erisco> Cale, yes but if the decision mechanism is deterministic, that definition of nondeterminisim really loses its meaning
19:27:47 <Cale> Nondeterminism just means "multiple results"
19:27:58 <Cale> So, you can do it using lists
19:28:01 <erisco> yeah, and there isn't if the decision maker is deterministic :P
19:28:02 <dmwit> erisco: The decision mechanism here is "pick all of them".
19:28:04 <Cale> and that's what we did first
19:28:23 <Cale> We were computing all possible ways of expanding every rule
19:28:58 <dmwit> erisco: Think of [Int] not as a bunch of Ints, but as a single Int chosen nondeterministically.
19:29:08 <Cale> and then were able to reuse that very same code, but with a different monad in place of the list monad in order to choose randomly rather than nondeterministically
19:29:29 <dmwit> erisco: That is what Cale means by "nondeterministic" here.
19:29:50 <erisco> if you are expanding all paths then again I don't see what is nondeterministic about that
19:30:15 <Cale> I mean nondeterministic in the technical CS sense of the word
19:30:23 <Cale> Not the usual English language meaning
19:30:40 <dmwit> erisco: Yes, what the computer is doing is deterministic.
19:31:10 <dmwit> erisco: And yes, you can get useful intuition for the computation that's being done by taking a step of abstraction away from what the computer is doing and thinking of it as a nondeterministic thing.
19:31:27 * hackagebot threadmanager 0.1.7 - (deprecated in favor of 'threads') Simple thread management  http://hackage.haskell.org/package/threadmanager-0.1.7 (BrianLewis)
19:32:40 <erisco> well, on a technical definition, okay ... certainly not happy with the word choice ;)
19:34:05 <dmwit> You get used to it.
19:34:44 <shachaf> I am happy with the word choice.
19:35:19 <shachaf> I write: do { x <- chooseOneOf [1,2,3]; y <- chooseOneOf [4,5,6]; return (x * y) }
19:35:27 <dmwit> (Or, trying at the value level: should I think of [3,4,5] as a single, deterministic list, or should I think of it as a nondeterministic choice between three possible values, namely 3, 4, and 5?)
19:35:44 <shachaf> x and y are chosen nondeterministically. I don't care much how, just that I get one of them.
19:36:10 <dmwit> (And once you've chosen a side, why should I think of it that way?)
19:37:02 <erisco> in the complete picture, I don't get it. as a local abstraction, I understand
19:37:31 <erisco> but a whole lot of things can be described as nondeterministic in that light
19:37:36 <shachaf> The point of abstractions is that they stand on their own, hopefully. :-)
19:39:05 <erisco> when Cale said nondeterministic I was thinking something like /dev/rand or whatever which I think includes external inputs
19:39:22 <dmwit> We're not big on hidden external inputs around here.
19:39:34 <shachaf> An external input is fine, though.
19:39:42 <dmwit> And I don't see that "a whole lot of things can be described as nondeterministic" is a particularly good complaint. So what? =)
19:39:55 <shachaf> You can implement chooseOneOf in such a way that it reads /dev/random, if you want to.
19:40:07 <shachaf> Or you can implement it as id, and that's a good implementation too.
19:40:24 <shachaf> But it isn't relevant to whether you think of it as nondeterminism.
19:41:42 <erisco> dmwit, I suppose I am just crippled by wanting to relate it to reality, rather than as a conceptual model
19:41:50 <erisco> just one of those words
19:42:00 <dmwit> [] is real
19:42:09 <shachaf> The model is better than reality.
19:44:32 <erisco> okay... so back to the Parsec parser :)   parseA = pure A <$> parseB <*> parseA <*> parseC
19:44:44 <erisco> this is clearly using a type constructor A, yeah?
19:44:56 <erisco> where is that coming from?
19:45:17 <startling> erisco, where is that code from?
19:45:30 <erisco> um dmwit maybe
19:45:34 <erisco> I forget
19:45:42 <startling> erisco, it was probably just an example I guess?
19:45:49 <erisco> yes
19:46:03 <startling> erisoc, so what's the problem?
19:46:46 <enthropy>  parseA = A <$> parseB <*> parseA <*> parseC -- shouldn't this make more sense?
19:47:31 <startling> ^ yeah, I think someone confused "A <$>" and "pure A <*>"
19:47:40 <dmwit> Yes, I am bad at Haskell.
19:47:57 <dmwit> And yes, you will of course need to write a suitable AST data type for the language you are parsing.
19:48:14 <erisco> join the club dmwit :) though you'll be good enough for the president position surely
19:48:55 <erisco> "of course" ... what troubles me is that I don't see why this is an "of course"
19:49:09 <enthropy> if the pure is to drop one argument (pure = const sometimes), it's probably clearer to write   parseB *> (A <$> parseA <*> parseC)
19:49:12 <dmwit> Okay. What type of information did you want to get out of the parse?
19:49:16 <erisco> which is why I was pondering around like a lost dog looking for what I was looking for
19:49:35 <dmwit> (If not an AST, I mean?)
19:49:35 <enthropy> or maybe it's not
19:49:36 <startling> enthropy: I don't think that's what was meant
19:50:03 <dmwit> enthropy: I have already admitted that I am bad at Haskell. No need to invent crazy ways I could have been right. ;-)
19:50:09 <enthropy> it's common to have parsers whose results are useless
19:50:13 <erisco> dmwit, an AST is fine. some tree of sorts
19:50:26 <dmwit> Okay. If you want an AST, then of course you need a data type that represents an AST.
19:50:31 <startling> erisco, okay, so write out a data type for it
19:50:33 <dmwit> Now is the "of course" reasonable to you?
19:50:35 <enthropy> but you have to put them in to discard some input
19:51:14 <erisco> dmwit, a reasonable compromise, perhaps ... something deeply dissatisfying though
19:51:27 <startling> haha
19:51:37 <dmwit> ...you want an AST without having a type for ASTs?
19:51:42 <dmwit> O_o
19:51:59 <erisco> I didn't want types to construct the tree
19:52:15 <startling> I find writing code as a whole deeply unsatisfying. I think erisco and I are on the same wavelength.
19:52:30 <erisco> the types themselves aren't pleasant
19:52:33 <dmwit> I'm not sure I understood this last complaint.
19:52:51 <startling> erisco, what kind of type would be pleasant?
19:53:11 <dmwit> Well, to be specific: I'm not sure I understood the "types to construct the tree" comment.
19:53:24 <erisco> dmwit, I imagine you are thinking of something fairly specific when you say AST and maybe that is one misunderstanding
19:54:07 <startling> erisco, what are you trying to parse?
19:54:07 <erisco> I need a parse tree, and I need to identify, for each node, what  production rule it uses
19:54:19 <startling> erisco, is this homework?
19:54:21 <erisco> so that can be as simple as an Int
19:54:43 <erisco> startling, this is not homework. how dare you suggest my school do anything so interesting
19:54:44 <dmwit> Okay. If you want to encode your parse tree in an Int, more power to you.
19:54:56 <dmwit> Int sounds like a crappy type for this to me, but if that's what you want, no problem.
19:55:34 <erisco> I feel like these tires have no traction... okay
19:55:35 <startling> dmwit: if it's good enough for goedel it's good enough for you, god damn it
19:55:37 <dmwit> Instead of "A" use "foo", where "foo" is the function you wrote that takes an Int produced by your B production rules, an Int from your A rules, and an Int from your C rules and produces an Int.
19:56:12 <startling> erisco, I'll ask you again: what are you trying to parse?
19:56:16 <erisco> if I have   data A = B A C   where B and C are more rules, then I am constructing the tree by introducing my own types
19:56:31 <erisco> startling, I am trying to build a parser
19:56:39 <startling> erisco, you're thinking of this the wrong way
19:56:47 <dmwit> I agree with you so far.
19:56:51 <startling> you don't write types for production rules.
19:56:57 <dmwit> Under the assumption that you meant something like data A = ConstructAnA B A C
19:57:08 <erisco> startling, I am not saying to write types for construction rules .... it is precisely what I don't want to do
19:57:10 <startling> you write types for the things that get produced.
19:57:15 <startling> erisco: OK.
19:57:33 <startling> erisco, I think you would be better served here by focusing on a concrete problem
19:57:46 <erisco> startling, but you agreeing with me is so against the norm at this point we're probably agreeing on different things =\
19:58:02 <startling> erisco, heh
19:58:17 <startling> erisco, how about I give you homework
19:58:28 <erisco> and I'll give you mine?
19:58:52 <startling> erisco, try parsing the language of matched parentheses, like "()" and "((()))" but not like "("
19:59:10 <dmwit> What's your stance on "()()"?
19:59:26 <startling> ^ that's fair game too
19:59:38 <erisco> startling, I have some experience from writing parsers in other languages
19:59:45 <hiratara> @pl \b -> f b >> return b
19:59:48 <lambdabot> liftM2 (>>) f return
19:59:48 <lambdabot> optimization suspended, use @pl-resume to continue.
19:59:54 <startling> erisco, good! maybe that will help.
20:00:08 <erisco> startling, this is more of an exercise in Haskell, since I am basing this parser off one I've already made
20:00:17 <erisco> mind you, Haskell has tended it to something rather different
20:00:21 <startling> erisco, yep.
20:00:22 <dmwit> Why is lambdabot suspending so much more than ever before?
20:00:36 <Demos> is there a nice function that is like (a, Either b c) -> Either b (a, b) yes I did look on hoogle
20:00:37 <erisco> okay, well, the parser I wrote can do matching brackets fine, so
20:00:45 <dmwit> What rewrites could possibly apply to liftM2 (>>) f return?
20:00:53 <startling> Demos, _2 id
20:01:11 <startling> (_2 is from lens)
20:01:48 <dmwit> :t Control.Lens._2
20:01:49 <lambdabot> (Functor f, Control.Lens.Internal.Indexed.Indexable Int p, Control.Lens.Tuple.Field2 s t a b) => p a (f b) -> s -> f t
20:02:10 <startling> > Control.Lens._2 id (1, Right 2)
20:02:11 <lambdabot>   Not in scope: `Control.Lens._2'
20:02:28 <dmwit> :t Control.Lens._2 id
20:02:28 <lambdabot> (Functor f, Control.Lens.Tuple.Field2 s t (f b) b) => s -> f t
20:03:07 <dmwit> :t Control.Lens._2 id (1, Right 2)
20:03:07 <lambdabot> (Num t, Num b) => Either a (t, b)
20:03:10 <startling> > let _2 f (a, b) = (,) a <$> f b in _2 id (1, Right 2)
20:03:11 <lambdabot>   Right (1,2)
20:03:25 <startling> > let _2 f (a, b) = (,) a <$> f b in _2 id (1, Left "x")
20:03:26 <lambdabot>   Left "x"
20:04:12 <startling> erisco, you wrote a parsec parser already?
20:04:39 <dmwit> uncurry strength -- ?
20:05:15 <erisco> well, to be totally honest, a RDP using B -> (B) | ()  for brackets I can't parse directly, but neither can Parsec
20:05:40 <dmwit> B -> (B) | epsilon is better
20:06:05 <dmwit> then B' -> (B) if you really must have at least one pair
20:06:07 <erisco> my sentences don't form well today =\ but yes, I made a sort of bizarre state machine type parser in Java and then a parser combinator library in C#
20:06:26 <startling> erisco, okay, so write it in parsec too. that's what you're asking how to do, right?
20:07:00 <erisco> no I was looking to parsec to figure out what it does about self-referential rules
20:07:27 <erisco> because if you just use the combinators (well, at least the ones I wrote), you'll end up with an infinite type error
20:07:38 <startling> erisco, oh, you wrote it wrong
20:08:10 <erisco> well if the best Parsec can do is what dmwit suggested, then I didn't do anything different in that regard
20:08:12 * dmwit throws his hands up in the air
20:08:34 <dmwit> All this time you were asking abstract questions about how Parsec does this and that when you had a concrete code question??
20:08:37 <dmwit> erisco--
20:08:51 <erisco> what do you mean?? I've posted code more than once
20:09:07 <startling> I haven't seen it!
20:09:10 <dmwit> Me neither!
20:09:56 <erisco> what do you mean by concrete?
20:10:12 <dmwit> "This code gives this error, when I expected it would compile." or similar
20:10:44 <dmwit> Or just in general an instantiation of the "I did X, expecting Y to happen, but Z happened instead" template.
20:10:58 <erisco> yes, correct. I wish to write my Haskell code briefly, but cannot do so due to an infinite type error. therefore I look for alternative approaches, find none. ask here, none suggested (lots of other interested stuff though)
20:11:11 <dmwit> Show us the code.
20:11:14 <erisco> so then I look to Parsec to see what it does (since it also uses combinators). haven't found its solution
20:11:47 <startling> what is up with lambdabot? lots of stuff is working in :t now but not >
20:11:59 <dmwit> startling: :t and > use completely different code paths
20:12:03 <startling> ugh
20:12:08 <erisco> sure, I can paste the whole thing (only 88 lines). just be prepared for some noobish Haskell :)
20:12:09 <startling> erisco, show us the code
20:12:09 <dmwit>  :t pipes through ghci, > uses mueval
20:12:15 <dmwit> ?where hpaste
20:12:15 <lambdabot> http://paste.tryhaskell.org/new/haskell
20:12:15 <startling> ugh what
20:12:39 <erisco> startling, it is hard to give a snippet since it will use definitions I define elsewhere
20:12:51 <erisco> http://paste.tryhaskell.org/90702
20:12:53 <startling> erisco, 88 lines is fine
20:12:57 <dmwit> startling: This is not new... it's just that > used to have a lot more stuff imported, so you noticed less.
20:13:29 <erisco> so line 86 is where I am mucking around with the self-referential rule. that is the infinite type error
20:13:35 <startling> dmwit, sure
20:14:26 <erisco> I know how to fix it by introducing a data type. I find that to be a lot of unfortunate work, especially since I have to also finagle the "default" types out of the combinators and into my data type
20:14:45 <startling> erisco, your data types are crazy
20:14:46 <dmwit> What a weird type for many. I would have expected a return type of Parser t [n].
20:14:46 <stevejb`> greetings, I have a question on the following code that I am working on: http://paste.tryhaskell.org/90703
20:14:58 <erisco> startling, both of them?
20:15:07 <startling> erisco, you're actively workin against parsec
20:15:18 <stevejb`> the question is embedded into the hpaste
20:15:21 <dmwit> The data types seem okay. I wouldn't go as far as saying "crazy".
20:15:26 <dmwit> startling: He's not using Parsec.
20:15:28 <startling> oh
20:15:40 <startling> what
20:15:48 <erisco> startling, well there are some design differences in the parsing approaches, afaik, so I would expect that
20:15:53 <dmwit> He's trying to implement his own parser library.
20:16:01 <pentace> erisco: What do you need RankNTypes for?
20:16:14 <erisco> pentace, I dunno, might be cruft from earlier experimentation
20:17:25 <dmwit> erisco: But my complaint stands. I would expect many to return a Parser t [n], not a Parser t [ParseMatch t n], which expands to blah blah blah [ParseMatch t [ParseMatch t n]].
20:17:39 <erisco> dmwit, that is the type, essentially, but 'n' gets wrapped up in extra parse info stored in ParseMatch. 'n' acts as the label so I can distinguish the parts I am parsing
20:17:40 <dmwit> still looking, though
20:18:04 <dmwit> Forget essentially. I said exactly the type I expect, not essentially the type I expect.
20:18:12 <erisco> dmwit, the type is intentional. my actual implementation of many isn't ideal yet. I am still working on the details
20:18:23 <erisco> dmwit, well too damn bad :P my parsing library ;)
20:18:45 <erisco> unless you have a better way to carry along parsing information and the label
20:19:03 <erisco> which I wish weren't entangled but I'm not sure how to really get out of that
20:19:25 <erisco> seeing as the job of parsing, at least if you want a useful tree, is to identify what parts of the tree are what
20:19:40 <dmwit> Anyway, I get "not in scope: S".
20:19:45 <dmwit> If I comment out that line, everything compiles cleanly.
20:20:03 <erisco> yeah like I said 86 is the problem zone :)
20:20:13 <dmwit> Well, you need to give us enough code to reproduce your problem.
20:20:24 <erisco> but 86 is the problem
20:20:38 <erisco> just remove 'nas S $' sorry
20:20:40 <dmwit> What are you expecting "S" to do if you haven't defined "S"?
20:20:46 <dmwit> okay, I'll try that
20:22:18 <dmwit> erisco: If you want a parse tree, you're gonna need a recursive type.
20:23:04 <erisco> agreed. do I have to define it manually? the nice thing about the combinators is that they build up a fairly ugly type but it all gets hidden by inference
20:23:25 <erisco> as soon as I have to start doing things manually, all that ugliness surfaces
20:23:37 <dmwit> Up to you. If you want your type to represent only things that can be successfully parsed, you'll have to define it yourself.
20:23:42 <dmwit> Otherwise, you can use a type like Tree.
20:24:12 <dmwit> Or you can use Mu, though I'm not *too* sure how well it would work here.
20:24:38 <erisco> can I have a combinator that is specifically designed to allow a recursive type? \> uses (a, b), which obviously isn't suited
20:25:02 <erisco> that is what I am looking for... to be able to write as little as I have, with minor changes, and have the types still inferred for me
20:25:23 <erisco> without having to create my own data type ... just like I can ignore what the combinators are doing to collect the results
20:25:43 <erisco> maybe it isn't possible... just had this hunch all damn day that it might be :)
20:28:51 <erisco> of course I ran into the exact same problem with C# ... combinators and type inference was wonderful right up until I had a self-referential rule
20:29:07 <erisco> then explosions of angle brackets everywhere =\
20:29:38 <erisco> enough to cause VS to hang and crash ;)
20:31:41 <dmwit> Personally, I think your ParseMatch type should be recursive.
20:31:56 <dmwit> So that you can really return a Parser t [n] that still has all the appropriate data.
20:32:08 <erisco> hmm... maybe I can somehow "build it in" so that the resultant parser (after going through all the combinators), is looking for a type constructor
20:32:19 <dmwit> And likewise have a Parser t (a, b) instead of this crazy Parser t (ParseMatch t a, ParseMatch t b).
20:32:27 <dmwit> I think that is where your problems are coming from.
20:33:00 <erisco> how do I make ParseMatch recursive in the way you suggest?
20:35:03 <erisco> dmwit, by the way, though you may have figured it out, the design idea for this parser is that each parser returns a list of all possible matches it can make
20:35:51 <erisco> dmwit, by doing this, I can solve some back tracking problems because the combinators can exhaustively try everything
20:36:07 <erisco> I think ... I didn't go through any formal proof of the idea ;)
20:36:27 <erisco> anyways, that is why the parsers are returning lists of ParseMatch
20:36:27 <stevejb`> anyone have a chance to look at my hpaste?
20:36:31 <dmwit> (Can I once again point at ReadP?)
20:38:16 <erisco> dmwit, if my primary interested was getting something in particular parsed, I wouldn't be making my own parser or using Haskell ;) that isn't my point
20:39:37 <erisco> dmwit, ReadP has an interesting approach but ... exponential growth? really? doesn't seem that practical
20:40:21 <erisco> I had an approach somewhat like that at one point in C# (minus the parallel) and it certainly was impractical (I was forcing all options by demanding to know which was the longest match, so that I could pick it)
20:40:21 <dmwit> Okay. Sorry for being dense, but please explain to me again why (/>) has the return type it does.
20:40:28 <dmwit> Sorry, (\>).
20:41:21 <erisco> was /> originally but I kept typing \> so changed it :P  why I am using a tuple or why the tuple has two ParseMatches or what?
20:41:45 <dmwit> Why Parser t (ParseMatch t a, ParseMatch t b) instead of Parser t (a, b)?
20:41:49 <enthropy> stevejb`: it's pretty hard to tell whats going on there. You have  yak_integrable :: [Double -> Double -> x]; yak_upper :: [Double]; and want a    [x]?
20:42:06 <stevejb`> enthropy: I can paste in the whole thing, one sec
20:42:29 <stevejb`> http://paste.tryhaskell.org/90704
20:42:30 <enthropy> what you mean by "1-1 correspond" might be zipWith
20:42:44 <stevejb`> enthropy: I was looking into that
20:42:48 <erisco> dmwit, because when I process the tree after parsing, or I encounter an error, it might be helpful to know what the matched source actually was
20:43:05 <stevejb`> yak_integrable :: [Double -> Double -> Double]
20:43:22 <erisco> I don't have any other reason, I don't think
20:43:27 <dmwit> erisco: Shouldn't it be the parser-writer's job to do that?
20:43:44 <dmwit> I mean, what if he wants to track semantic location information rather than just a token count or something?
20:43:48 <erisco> well the combinators don't use themselves
20:44:07 <stevejb`> I want to run the following: quad2 function_in_yak_integrable 0 T (const x) (const yak_upper)
20:44:28 <stevejb`> where function_in_yak_integrable is an element in yak_integrable and x is an element of yak_lower
20:44:35 <erisco> well, firstly, I haven't written a complete compiler, so I don't know. its on the roadmap. at this point it is extra information that is, at least, useful for debug output
20:44:36 <stevejb`> they are both lists with the same length
20:44:44 <erisco> and I don't see any reason to discard it
20:45:59 <erisco> possible it could be (a, b) and the user can elect to store the same sort of information in their a and b
20:48:10 <enthropy> stevejb`: well if you were to write it with loops, would there be one loop or two?
20:48:28 <stevejb`> one
20:48:30 <erisco> dmwit, I don't particularly need help on the concept of the parser, but I keep hitting little stumbling blocks in this foreign language
20:48:38 <erisco> and I'
20:49:10 <erisco> m stuck between "I know this kinda ugly way to do it" and "maybe I don't know magical ability X that Haskell has"
20:49:45 <enthropy> stevejb`: probably you can do something like:  zipWith (\f ub -> quad2 f ... (const ub)) yak_integrable yak_upper
20:49:57 <stevejb`> enthropy: I was thinking of zipping yak_integrable and yak_lower together and then using a map
20:50:15 <stevejb`> enthropy: thank you
20:50:32 <enthropy> that would give the same result
20:51:52 <dmwit> Okay, I have s compiling.
20:51:58 <dmwit> Let me polish a bit first.
20:52:30 <carter> enthropy whats this maths you're talking about?
20:52:40 <carter> ohhh
20:52:43 <erisco> I'd say don't bother, but my Haskell is quite frail, so perhaps you should
20:53:10 <enthropy> carter: no idea
20:53:23 <stevejb`> enthropy: this is what I came up with
20:53:27 <stevejb`>     yak_d = zip yak_integrable yak_lower
20:53:27 <stevejb`>     yak_integrals = map (\x -> quad2 (fst x) 0 my_T (const (snd x)) (const yak_upper)) yak_d
20:53:29 <carter> stevejb` enthropy  i'll be rolling out version zero of my hmatrix alternate in a few weeks it looks lik e
20:53:54 <carter> stevejb` numerical integration and fun
20:54:05 <carter> stevejb` have you seen numerical integration before?
20:54:21 <carter> soryr
20:54:25 <carter> i mean auto differentiation
20:54:40 <stevejb`> carter: I have read a bit about it but never used it
20:55:02 <carter> stevejb` its worth playing with the "ad" package on hackage
20:55:04 <carter> @hackage ad
20:55:04 <lambdabot> http://hackage.haskell.org/package/ad
20:55:31 <enthropy> carter: does your alternative hmatrix also rely on the FFI?
20:55:41 <carter> enthropy yes and no
20:55:49 <carter> it can if you want
20:56:01 <carter> there will be some "naive haskell backend"
20:56:03 <carter> s
20:56:16 <carter> i'm not going to play with ghc's SIMD support till it goes gold
20:56:32 <carter> though i am adding 256bit simd to ghc's llvm  machinery soon
20:56:53 <stevejb`> carter: do you mean AVX?
20:56:53 <enthropy> do you make 'ad's mesh with Storable?
20:56:55 <carter> yes
20:57:02 <carter> enthropy not yet
20:57:05 <carter> thats on the task list
20:57:14 <dmwit> erisco: I'll paste two versions of s, one with a custom type and one where the recursion is pushed into the parser combinators in the way I suggested.
20:57:23 <stevejb`> carter: I would definitely like to keep that on my radar. Do you have a repository yet?
20:57:31 <carter> stevejb`  nothing public yet
20:57:39 <erisco> dmwit, the latter sounds quite intriguing
20:57:42 <carter> will be *soon*
20:57:57 <carter> theres been a lot fo ecosystem engineering i've been up to lately
20:58:15 <carter> like getting the ok to patch the ghc calligng convention
20:58:25 <carter> now i need to get the patch ok'd by LLVM folks
20:58:25 <stevejb`> I saw the following blog post on ad a while ago, but haven't time to look through it: http://idontgetoutmuch.wordpress.com/2013/05/31/neural-networks-and-automated-differentiation-3/
20:58:47 <enthropy> carter: regarding Storable and ad, I guess it's the same issue as "making Set a Monad" which is apparently a solved problem
20:59:00 <carter> @hackage hnn
20:59:00 <lambdabot> http://hackage.haskell.org/package/hnn
20:59:08 <carter> enthropy i'll deal with it when i deal with it
20:59:13 <carter> theres enough other things i need to do in the near term
20:59:20 <hpaste> dmwit annotated “wtf am I thinking?” with “wtf am I thinking? (annotation)” at http://paste.tryhaskell.org/90702#a90706
20:59:34 <dmwit> erisco: ^^
20:59:55 <carter> enthropy stevejb`  unboxed support for AD is going to be easier than storable
21:00:24 <enthropy> http://hackage.haskell.org/package/ipopt-hs has a bad workaround for that incompatibility (do the calculations on the normal Vector, then convert)
21:00:37 <carter> enthropy dont' worry, i've a roadmap already
21:00:48 <carter> i've been working on some of the bits and pieces for over a year now :)
21:01:06 <carter> but theres a bunch of things that need to happen before i spend time working on the AD story
21:01:12 <dmwit> whoops
21:01:19 <dmwit> erisco: Naturally, Token Char should be Token t.
21:01:22 <dmwit> derp
21:01:23 <stevejb`> carter: I am looking forward to seeing what you have. I am fairly new to Haskell but looking forward to incorporating it in my research
21:01:29 * hackagebot ajhc 0.8.0.7 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.7 (KiwamuOkabe)
21:01:35 <carter> stevejb` what sort of research?
21:01:40 <erisco> dmwit, yeah that's fine. wow, quite interesting
21:02:20 <erisco> dmwit, you might see why I hesitate to use the former method, because defining the types is a pita and harder to change
21:02:27 <stevejb`> carter: I am an operations management PhD student. Looking to incorporate machine learning and online optimization into operations
21:02:35 <dmwit> The parallel can be made even more precise by changing the ChoiceL/ChoiceR constructors into
21:02:37 <stevejb`> carter: what is your field?
21:02:44 <dmwit> Choice (Either (AST t) (AST t))
21:02:58 <dmwit> and then p1 /// p2 = nas Choice (p1 // p2)
21:03:13 <dmwit> I didn't polish enough, I guess. =)
21:03:14 <carter> stevejb` right now, fixing the crap that is numerical computing / data analysis tools as they current exist
21:03:17 <erisco> and how the AST thingie trickles into it... all quite fascinating
21:03:23 <carter> i'm rolliing out some open source bits soon
21:03:41 <carter> and hopefully getting 1-2 commercial customers for the "pro" bits that are a bit more fiddly
21:04:17 <stevejb`> carter: cool! I would agree that it seems like in the numerical world, you spend way too much time thinking about mechanics of moving numbers around and it is distracting from the problem at hand
21:04:36 <carter> yeah
21:04:41 <carter> stevejb` yes
21:04:51 <carter> heres one cool thing you'll like when i roll out my numerics package:
21:04:55 <erisco> dmwit, so I get what is happening with \>> and /// and so forth ... but the underlying AST ... it will take me a bit of time to understand exactly what is going on
21:04:57 <carter> i've "solved" memory locality
21:05:04 <carter> or at least, i've made it really really easy to reason about
21:05:07 <stevejb`> carter: :) excellent
21:05:10 <erisco> dmwit, but can't this be rolled right into \> and // ?
21:05:31 <hpaste> dmwit annotated “wtf am I thinking?” with “the two bits of polish mentioned so far” at http://paste.tryhaskell.org/90702#a90707
21:05:32 <carter> theres some refinements i'll add later that will make certain types of reasoning easier
21:05:39 <dmwit> erisco: Yes, of course.
21:05:53 <dmwit> erisco: I did it this way for clarity; it's harder to see what changed when you're changing a multi-line thing.
21:06:00 <carter> but i've already got like 5 type parameters in the core data types
21:06:06 <DiegoNolan> Can you put the flag for bangpatterns in your source, Like the template haskell one and if so what is the exact syntax
21:06:36 <stevejb`> carter: plans to support something like Xeon Phi at some point?
21:06:44 <erisco> dmwit, well, thank you greatly for this. It certainly looks like the result I want ... it'll be like slowly unboxing an xmas present :)
21:06:58 <erisco> dmwit, but tonight is xmas eve and I must sleep first ;)
21:07:07 <dmwit> Sleep well. =)
21:07:11 <carter> stevejb` my current answer GPU will be "yes" once i've some custome money
21:07:19 <carter> and xeon phi once it has an llvm backend
21:07:24 <carter> at least in the near term
21:07:29 <carter> stevejb` do you NEED
21:07:31 <dmwit> erisco: And before you rule out the first solution, you should notice that ASTs can hold "too many" things.
21:07:35 <carter> gpu / phi powers?
21:07:43 <dmwit> erisco: i.e. they can hold the results of *any* stupid grammar, not just the one given by s.
21:07:48 <dmwit> erisco: That's the tradeoff you make.
21:07:58 <stevejb`> carter: I can see the need arising in the near future
21:08:04 <erisco> dmwit, not exactly sure what you mean
21:08:31 <stevejb`> carter: I am currently porting some code matlab code that my advisor wrote. Any way to get it faster would be amazing
21:08:48 <dmwit> erisco: The value "Token 'b'" is a fine inhabitant of the "AST Char" type, but can't be produced by any run of the 's' parser.
21:09:04 <dmwit> erisco: On the other hand, all the inhabitants of Foo can be produced by some run of the 's' parser.
21:09:21 <erisco> dmwit, what is Foo?
21:09:24 <dmwit> (Up to the invariants maintained by ParseMatch's, of course; I'm only talking about the tree structure of it here.)
21:09:27 <dmwit> erisco: Foo in the paste.
21:09:51 <stevejb`> carter: what I have been doing so far is trying to apply monad par. Its my first Haskell project so going slowly but it has been good
21:10:10 <carter> stevejb` how many cores?
21:10:12 <erisco> dmwit, oh. I don't precisely see how this is an issue... perhaps an annoyance when pattern matching cases?
21:10:21 <stevejb`> I have a dual six-core xeon
21:10:44 <stevejb`> carter: once I have this running, I will probably run this on the dual 8 core xeons on Amazon
21:10:52 <carter> ok
21:10:54 <dmwit> erisco: Well, typically when you write the function that consumes the result of parsing, you want to make some assumptions about the value you're consuming.
21:11:02 <dmwit> erisco: Like that it came from the grammar you parsed with. =)
21:11:42 <dmwit> erisco: You can make those assumptions via partial pattern matches on the AST type; but this is a runtime check and the compiler can't help you much.
21:11:52 <erisco> right ... so I suppose you'd end up with runtime stuffs for convenience
21:11:58 <dmwit> erisco: With a custom type, you can get the compiler to tell you when you screw up.
21:12:10 <erisco> hrm. that is certainly a significant sacrifice
21:12:32 <carter> stevejb` i think i have a decent way to use accelerate or related things as plug in able backends
21:12:37 <carter> though it may be a funny fit
21:12:46 <erisco> you can also name the parts :)
21:13:07 <dmwit> That is another benefit of using a custom type, yes. =)
21:15:00 <erisco> I'd really like to keep static type checking, so I might have to work on making the custom type more pleasant in some way
21:15:34 <dmwit> The usual way is really not so bad.
21:16:46 <erisco> well I would want more brevity so perhaps an alias PM for ParseMatch Char and such
21:17:29 <dmwit> Yes, you would want to parameterize Foo a bit, as I mentioned in the comments I think.
21:17:57 <dmwit> And likely you wouldn't care about all the details of a ParseMatch in most custom types.
21:18:03 <erisco> but what if, some how, instead of needing nas (either L R), the combinators spit back a function which expects a certain type of constructor
21:18:20 <dmwit> That is the core idea of Applicative, yes.
21:18:21 <erisco> then that'd be real slick... but I'll have to experiment with how that might work
21:18:32 <dmwit> :t (<*>)
21:18:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:18:44 <dmwit> This is the Applicative analog to (\>).
21:18:54 <dmwit> Give me two parsers and I'll do them in sequence.
21:18:54 <erisco> because then it'd be like   (token 'a' \> blah blah // blah blah) Foo
21:18:58 <erisco> and that's the end of it
21:19:22 <dmwit> Remember when I said A <$> parseB <*> parseA <*> parseC?
21:19:32 <erisco> yes I have it copied
21:19:43 <dmwit> That is exactly what you're proposing now.
21:19:46 <dmwit> no?
21:19:50 <erisco> iunno
21:19:55 <dmwit> Just with different names.
21:20:00 <dmwit> A is the constructor you named Foo.
21:20:13 <dmwit> parseB, parseA, parseC are token 'a', s, and token 'a'.
21:20:21 <dmwit> (<*>) is (\>)
21:20:37 <dmwit> (<$>) is the only one with no analog in your proposal, but you'd have gotten to that, I'm sure. ;-)
21:20:57 <dmwit> and (<|>) is your (//), FWIW
21:21:00 <dmwit> :t (<|>)
21:21:01 <lambdabot> Alternative f => f a -> f a -> f a
21:21:25 <erisco> I'll have to puzzle that one out ... I know Foo is   a -> Foo  where 'a' is whatever type has been accumulated by the combinators
21:21:40 <erisco> so    a \> b  would then look for   (a, b) -> Foo
21:22:10 <erisco> and   (a \> b) //  (c \> d)   looks for   Either (a, b) (c, d) -> Foo
21:22:35 <dmwit> Making an Either (a, b) (c, d) just to break it down and turn it into a Foo is silly.
21:22:50 <dmwit> Expecting an (a -> b -> Foo) and an (c -> d -> Foo) is better.
21:23:22 <erisco> I don't know if I can end up with multiple arguments like that
21:23:25 <erisco> if I can then great
21:23:45 <dmwit> I'm telling you an API that you can build that ends up looking like that. -_-
21:23:59 <dmwit> I'm confident that you can implement this API, because you essentially already have.
21:24:13 <dmwit> You just need to wire things up ever-so-slightly differently.
21:24:22 <erisco> *sniff* someone believes in me :D
21:24:44 <erisco> but seriously, I need some sleep first and I'll dick around with Applicative tomorrow and figure out what I can make it do
21:24:52 <dmwit> g'luck
21:25:11 <erisco> right now I understand the idea of Applicative in a vacuum and am not sure how to apply it
21:25:14 <erisco> g.night
21:46:35 <DiegoNolan> Do mappend and mconcat have any inline aliases like applicative for functors?
21:46:43 <DiegoNolan> infix*
21:49:34 <pdxleif> <>
21:51:47 <dmwit> There's no infix operator for mconcat (since it's only got one argument!), but you might like "fold" as a shorter name for it.
21:51:57 <dmwit> In rare cases, mconcat may be more efficient.
21:52:37 <pdxleif> Isn't mconcat like foldMap id?
21:52:53 <dmwit> Yes. So is fold. =)
21:53:02 <pdxleif> Oh, fold
21:54:13 <pdxleif> Would "sum" be a good name for that, too?
21:55:03 <startling> :t msum
21:55:04 <lambdabot> MonadPlus m => [m a] -> m a
21:55:06 <startling> oh
21:57:11 <dmwit> pdxleif: I think sum could be a good name for it. =)
21:57:40 <dmwit> (or product, depending on how you feel about your monoid!)
22:00:09 <startling> > fold [(+ 1), (+ 2)]
22:00:10 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
22:00:10 <lambdabot>    arising from a use of `e_112'
22:00:10 <lambdabot>  T...
22:00:12 <startling> aw
22:00:31 <startling> can I get GHC to tell me whether it's 32- or 64-bit?
22:01:44 <dmwit> startling: Maybe maxBound :: Int will help.
22:02:05 <dmwit> Also: no Num instance for Sum/Product is stupid.
22:02:29 <dmwit> > fold [Sum 1, Sum 2]
22:02:31 <lambdabot>   Sum {getSum = 3}
22:02:49 <startling> dmwit, it'd be hard to disambiguate
22:02:57 <dmwit> Would it?
22:03:00 <startling> what is fold [1, 2] ?
22:03:06 <startling> (well, 2)
22:03:07 <dmwit> 3
22:03:15 <dmwit> Sorry, ambiguity error.
22:03:29 <startling> dmwit, if there's both, it could be either Sum or Product, I mean
22:03:32 <dmwit> I said 3 because I thought for just a second that there was a monoid instance for Integer. =)
22:03:39 <startling> heh
22:03:57 <dmwit> But yes, it's an ambiguity error.
22:04:14 <dmwit> But either getSum (fold [1, 2]) or getProduct (fold [1, 2]) would clear up the ambiguity just fine.
22:04:32 <dmwit> Or using them in any other way that indicates what type you wanted.
22:04:48 <startling> that's true.
22:08:17 <dmwit> > getSum (fold (unsafeCoerce [1,2]))
22:08:18 <lambdabot>   Not in scope: `unsafeCoerce'
22:08:22 <dmwit> pfft
22:11:00 <DiegoNolan> got distracted, yeah not i realize that mconcat only has one argemunte
22:11:07 <DiegoNolan> but yeah mappend is long
22:11:14 <DiegoNolan> so is fromIntegral
22:11:19 <DiegoNolan> never should have made that so long
22:15:21 <sclv> ?quote fromIntegral
22:15:21 <lambdabot> Cale says: [Cale] > map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135 [lambdabot]  "Get a calculator"
22:15:25 <sclv> ?quote fromIntegral
22:15:26 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
22:15:34 <sclv> that's the one
22:17:56 <startling> my maxBound :: Int is 9223372036854775807, am I 64-bit?
22:18:23 <Cale> startling: yes
22:18:29 <startling> thanks
22:18:34 <Cale> > 2^64
22:18:35 <lambdabot>   18446744073709551616
22:18:38 <Cale> > 2^63
22:18:39 <lambdabot>   9223372036854775808
22:18:44 <Cale> > 2^63 - 1
22:18:45 <lambdabot>   9223372036854775807
22:19:12 <startling> > toInteger (maxBound :: Int) == toInteger (maxBound :: Word64)
22:19:13 <lambdabot>   False
22:19:29 <startling> > toInteger (maxBound :: Int) == toInteger (maxBound :: Int64)
22:19:30 <lambdabot>   False
22:19:54 <geekosaur> > maxBound :: Word64
22:19:55 <lambdabot>   18446744073709551615
22:19:59 <startling> :D exciting
22:20:07 <geekosaur> > maxBound :: Int64
22:20:09 <lambdabot>   9223372036854775807
22:20:13 <startling> looks like they fixed the stupid snow leopard bug.
22:20:46 <joelteon> which one was that?
22:21:48 <Gracenotes> are there any instances of unsafeCoerce being, well, unsafe for newtype adding/stripping?
22:22:16 <pdxleif> Is there some IDE people use?
22:22:34 <pdxleif> I'd like for ctags to be able to browse through into the source of libraries I use...
22:23:53 <pdxleif> In Scalaz the default Semigroup / Monoid instance for Int is +.  I think that's kinda handy.  Dunno why that couldn't just be the default, and then do what you do now to get other instances.
22:26:30 * hackagebot oeis 0.3.5 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  http://hackage.haskell.org/package/oeis-0.3.5 (BrianLewis)
22:29:56 <Gracenotes> + also forms a full group in the integers, both full integers and mod n.
22:31:26 <Gracenotes> * has issues with 0 and things not coprime to n, respectively
22:45:06 <joelteon> GHC won't magically parallelize two IO operations by any chance, will it
22:47:57 <startling> joelteon: course not
22:48:18 <joelteon> phew
22:55:01 <bitonic> startling: why ‘of course’?
22:55:35 <kwos> perhaps not just yet but one day :)
22:59:27 <startling> bitonic, IO (barring things like unsafeInterleaveIO) is strictly sequenced
22:59:47 <bitonic> startling: oh, I missed the ‘IO’ part :)
23:00:06 <startling> I don't know if "magically parallelizing stuff from IO" would ever be a good solution
23:00:11 <joelteon> it would not
23:00:35 <bitonic> yeah, it wouldn’t.  but one could which for GHC to parallels pure operations automagically
23:04:08 <pdxleif> Isn't there some magic parallelization sauce?
23:04:13 <pdxleif> Would `par` help?
23:04:32 <pdxleif> (++) <$> getLine <*> getLine ?
23:04:33 <Gracenotes> GHC might be able to parallelize combinations of IO values
23:05:40 <Gracenotes> not that it's that useful, since the worth of an IO is in executing it.
23:07:29 <pdxleif> Say I wanna kick off a list of http requests and aggregate the results, not caring about execution order...?
23:07:52 <pdxleif> Like if their results forms a commutative monoid
23:08:07 <shachaf> There are IO things for that, like async.
23:08:13 <pdxleif> Also, is there a difference between Map.toList and assocs?
23:08:17 <shachaf> par is pretty much unrelated.
23:08:34 <shachaf> assocs :: Map k a -> [(k, a)]
23:08:38 <shachaf> O(n). An alias for toAscList. Return all key/value pairs in the map in ascending key order. Subject to list fusion.
23:08:58 <shachaf> toList isn't guaranteed to be an ascending list, I *think*.
23:09:06 <pdxleif> Ooo, async looks cool - thanks!
23:09:32 <pdxleif> Ah, so a sub-case of toList
23:10:49 <pdxleif> Remind me to never leave an "undefined" without explanation in code I'm not going to look at for a while... :/
23:11:45 * pdxleif should look more into that "holes" stuff
23:12:17 <arcatan> holes, they're for looking into
23:13:30 <pdxleif> :J
23:13:35 <solidus-lake> hey all, where is the best place for someone who knows haskell to get a broad idea of functional reactive programming?
23:13:43 <solidus-lake> is it here? http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana#A_broader_view_of_FRP
23:13:49 <solidus-lake> or is there a better resource than that
23:14:47 <kwos> solidus-lake: I think that reactive programming is a very broad idea and you have to look at a few different approaches before you can make up your mind about it
23:15:21 <solidus-lake> well, lets say going off of the wikipedia article
23:15:23 <zRecursive> using emacs, after 'M-x run-haskell' , in *haskell* buffer, why doesnot "<TAB> auto complete" work ?
23:15:59 <kwos> solidus-lake: read through one or two years worth of research papers and have a look at two or three libraries and that's a good start
23:17:13 <pdxleif> Ah, there's a Concurrently type w/ Applicative & Alternative instances - woo
23:18:10 <solidus-lake> heh, didn't want to spend 2 years on it, just a good overview
23:18:17 <pdxleif> I was thinking of looking into Elm, maybe learn some FRP that way?
23:20:29 <nwf> Anyone here familiar with the internals of Trifecta?
23:20:58 <nwf> I'd like to have it parse across multiple files as if they were concatenated but while it will cheerfully accept the first line of a second file, it then fails.
23:27:58 <shachaf> I am not familiar. But do you have a small example?
23:29:28 <nwf> shachaf: Gimme a sec.
23:34:17 <adnap> > mplus (Just 3) (Just 4)
23:34:19 <lambdabot>   Just 3
23:34:33 <nwf> shachaf: https://gist.github.com/nwf/88d0974f0af7c3db7a4a contains parts of my efforts so far.
23:35:12 <osa1_> hi all, I sent a email to cafe but got no response after some point, can anyone help me with this: http://www.haskell.org/pipermail/haskell-cafe/2013-July/109050.html
23:35:30 <nwf> I think this is going to require patching Text.Trifecta.Util.It.feedIt or something thereabout, but I cannot read ekmett's code very well.
23:38:29 <shachaf> A runnable Main.hs would be easier for someone who's never used this library before. :-)
23:38:35 * shachaf tries to figure out imports etc.
23:39:11 <nwf> Oh, sure, sorry... this is pasted out of my "should be upstreamed" work in progress.
23:39:11 <Ralith> > (+) <$> Just 3 <*> Just 4
23:39:12 <lambdabot>   Just 7
23:39:17 <Ralith> adnap: ^
23:39:41 <shachaf> Hmm, I don't even have it installed.
23:41:40 <nwf> shachaf: Updated.
23:42:17 <nwf> (And again; forgot some imports)
23:42:28 <adnap> :t liftM Just
23:42:29 <lambdabot> Monad m => m a1 -> m (Maybe a1)
