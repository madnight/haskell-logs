00:03:29 <dacdave> cabal install text fails with error - Could not find module `GHC.CString'   Any ideas? I've found nothing on Google.
00:04:16 <kosmikus> Spockz: I wouldn't do classic footnotes in code listings. But some more clearly visible "annotations" (i.e., symbols that are clearly not part of the code) might work. You can then refer to them in the main text below a code listing. I do that from time to time.
00:05:52 <dacdave> ghc version is 7.4.1, cabal-install version is 0.14.0 using version 1.14.0 of the Cabal library.
00:06:53 <dacdave> I did not have these problems before I upgraded to a newer version of Ubuntu/haskell-platform
00:11:49 <hpaste> dacdave pasted “error installing text” at http://paste.tryhaskell.org/90640
00:13:48 <shachaf> dacdave: Sounds like you're missing some profiling packages.
00:14:39 <shachaf> Maybe they'll have names like libghc-something-prof
00:15:24 <dacdave> Wish I knew what that meant. I have tried apt-get install and cabal install. What command do I use to install these missing packages? Thanks for the help.
00:17:09 <shachaf> It might be the package ghc-prof. I don't know.
00:18:39 <codesoup> why do you need to cabal install text?
00:18:40 <arkeet> but it doesn't look like he's installing profiling things.
00:19:28 <shachaf> True.
00:19:31 <shachaf> Maybe the error is misleading.
00:19:37 <codesoup> it's already in the ubuntu repo as libghc-text-dev
00:20:17 <arkeet> but text is in the platform
00:20:29 <codesoup> it's also depended on by the haskell-platform package
00:21:49 <jfischoff> how do I figure out where cabal installs documentation?
00:22:53 <dacdave> I was actually trying to add xml, but its dependency on text was failing.
00:22:56 <codesoup> otoh, the latest version of ubuntu does not have a haskell-platform package because they synced from debian when it was broken, so maybe he is using the platform tarball. does that involve cabal install?
00:23:50 <dacdave> apt-get install ghc-prof seems to have fixed the problem. I do not understand why this was not installed as part of apt-get install haskell-platform.
00:23:58 <johnw> has anyone else found that building and installing from the haskell-platform tarball does not install documentation?
00:24:38 <shachaf> It installs documentation if you enable documentation, I would assume.
00:24:42 <shachaf> Just like cabal packages in general.
00:24:57 <johnw> well, I'm looking at the configure options; I see how to enable profiling, but not documentation
00:25:36 <johnw> i'm trying to fix the homebrew recipe for haskell-platform
00:25:51 <shachaf> @where cabal-cabal
00:25:51 <lambdabot> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
00:26:47 <johnw> shachaf: https://gist.github.com/5907362
00:27:20 <johnw> if there's a way to hack a cabal config file within the working tree of the tarball, that could work
00:27:29 <johnw> but I can't edit ~/.cabal/config, not from a recipe
00:28:59 <johnw> interesting, in scripts/build.sh of the haskell-platform tarball, it has a build_pkg macro which should be running Setup haddock
00:29:01 <johnw> i'll debug further
00:29:28 <newsham> nsa walks into a bar, orders a beer, bartender says "domestic or imported?" nsa says "whats the difference?"
00:29:32 <newsham> oops, wrong channel
00:29:47 <b6> there is no wrong channel for talking about that threat.
00:29:58 <b6> it's a threat to every human.
00:32:01 <shachaf> johnw: It builds documentation with no options.
00:32:21 <johnw> just discovered that, thank you
00:32:49 <b6> is there some way to export certain internal functions for unit testing, but ensure they're not exported in the "real" library?
00:33:15 <shachaf> You could use CPP.
00:33:21 <shachaf> Alternatively you could use a .Internal module.
00:33:26 <shachaf> Probably a .Internal module is better.
00:33:33 <johnw> b6: you can create an internal module, that exports everything, and then a public facing module which imports that module and re-exports just the public symbols
00:34:45 <b6> johnw: that's looking most likely. thanks.
00:35:42 <b6> shachaf: if i use CPP, and someone prepares a package for a distribution or something, and enables tests, won't the internal functions be exported?
00:36:22 <b6> it's as if i need my test-suite to depend on a -DTESTING version of the library.
00:40:14 <johnw> shachaf: aha, hombrew didn't install hscolour as a prerequisite, so no documentation was being generated
00:40:41 <shachaf> b6: Well, I don't recommend doing the first thing I said anyway. Do the second thing I said.
00:40:55 <b6> shachaf: ok, thank you.
01:41:48 <Spockz> kosmikus: so you wouldn't use the classical footnote marker because not distinct enough from the code?
01:54:08 <DarkFox> Anyone here have a lhs/markdown syntax file for vim?
02:07:33 <tomboy64> can i patternmatch for the first element of a list? e.g. let testor 2:_ _ = True  gives me an error in ghci, but i've been able to patternmatch constants, hence i'm a little confused.
02:07:51 <mauke> precedence
02:07:55 <Taneb> try putting brackets around the pattern match?
02:08:04 <Taneb> let testor (2:_:_) = True
02:09:54 <tomboy64> ahh, thanks :-}
02:14:16 <yesthisisuser> hello.. i have a question about applicative style. maybe someone could help me.
02:14:40 <yesthisisuser> if i do something like (/) <$> (Just 3) <*> (Just 2)
02:15:10 <yesthisisuser> that's fine.. i get a Maybe Float
02:15:37 <yesthisisuser> but what if i want to sequence say 3 / 2 / 2
02:15:49 <yesthisisuser> (Just 3) / (Just 2) / (Just 2)
02:16:06 <shachaf> Does that mean (3 / 2) / 2 or 3 / (2 / 2)?
02:16:56 <flux> who wouldn't agree it means ((3 / 2) / 2) ?-o
02:16:57 <mcstar> > let x=1; y=1; z=1 in do x<-mx; y<-my; z<-mz; return (x/y/z) :: Just Int
02:16:58 <lambdabot>   Not in scope: `mx'
02:16:58 <lambdabot>  Perhaps you meant one of these:
02:16:58 <lambdabot>    `x' (line 1), `x' (i...
02:17:05 <shachaf> Anyway, the simple way to write that would probably be (\x y z -> x / y / z) <$> Just 3 <*> Just 2 <*> Just 2 or something like that.
02:17:17 <shachaf> Or liftA3 (\x y z -> x / y / z) (Just 3) (Just 2) (Just 2)
02:17:22 <yesthisisuser> in do notation.. i know i can do do x <- 3 /// 2; y <- x /// 2; return y
02:17:29 <mcstar> > let mx=Just 1; my=Just 1; mz=Just 1 in do x<-mx; y<-my; z<-mz; return (x/y/z)
02:17:30 <lambdabot>   Just 1.0
02:17:36 <Lethalman> :t (/) . (/)
02:17:37 <yesthisisuser> if (///) is a fail safe (/) on Maybe Float
02:17:37 <lambdabot> (Fractional (a -> a), Fractional a) => a -> (a -> a) -> a -> a
02:19:58 <yesthisisuser> thanks
02:20:45 <yesthisisuser> honestly i feel like using <*> and <$> is just more confusing sometimes. as opposed to fmap etc ...
02:21:00 <merijn> yesthisisuser: It depends on the number of arguments
02:21:31 <merijn> yesthisisuser: Something like "(,) <$> getLine <*> getLine" reads much nicer than "liftM2 (,) getLine getLine", imo
02:22:22 <yesthisisuser> merijn: yes you are right. it depends i guess
02:22:44 <Lethalman> yesthisisuser, when reading <$> <*>, just read it blank, and you'll see straight function application: (,) getLine getLine
02:23:02 <merijn> yesthisisuser: Alternatively (I only just scrolled up to your earlier question, I would probably avoid that lambda and create a wrapper
02:23:10 <Lethalman> quite the same
02:23:36 <merijn> i.e. "let (//) = liftA2 (/) in Just 3 // Just 2 // Just 2
02:23:39 <merijn> man
02:23:48 <merijn> I need to work on balancing my quotes and parens...
02:23:49 <Lethalman> :t liftA2 (/)
02:23:50 <lambdabot> (Fractional c, Applicative f) => f c -> f c -> f c
02:24:57 <merijn> yesthisisuser: The nice thing about the entire applicative approach is that if you lift it once you can use it as normal on the Applicative values as if the Applicative wasn't there
02:26:09 <yesthisisuser> merijn: could you show an example?
02:26:53 <merijn> I just did, 6 or so lines back :p
02:27:39 <yesthisisuser> merijn: sorry... i was thinking about <*> <$> still
02:27:42 <merijn> > let (//) = liftA2 (/) in Just 3 // Just 2 // Just 2
02:27:43 <lambdabot>   Just 0.75
02:27:49 <merijn> > let (//) = liftA2 (/) in Just 3 // Nothing // Just 2
02:27:50 <lambdabot>   Nothing
02:28:06 <yesthisisuser> i get it.. i was reading " the nice thing about using <*> and <$> ." etc
02:28:50 <merijn> yesthisisuser: Whether you should use <*> and <$> depends on the circumstance. Here creating a single lifted wrapper is nicer. If you need to apply a function of N arguments then <$> and <*> tends to be nicer
02:41:26 <Moggle_> I don't get it, but despite the fact that there's an error every second paragraph of Real World Haskell, and it's occasionally dated (QuickCheck 1.0?), Real World Haskell is incredibly engrossing
02:41:33 <Moggle_> why couldn't Learn You a Haskell go into half of this stuff?
02:41:42 <merijn> elliott: Curse you and your complaints, now I'm writing the instance you want and it's much harder to implement!
02:42:08 <merijn> Moggle_: Because it already had a ton of stuff to cover?
02:42:31 <merijn> Moggle_: What (if anything) would you cut from LYAH to make room for the RWH stuff?
02:42:49 <Moggle_> merijin: Nothing, I would just add a chapter on Parsec and a chapter on FFI at least.
02:43:23 <Moggle_> merijin: It's not like there's a limit as to how long a textbook can be. RWH is frickin huge.
02:43:37 <merijn> Moggle_: Sure, but that's a lot of writing work and maybe those aren't parts the author was comfortable with?
02:44:13 <Moggle_> merijin: that's reasonable!
02:49:14 <merijn> ugh, there must me a better way to write "    (More g) >>= h = More (g >>= \f -> return (\s -> f s >>= h))"
02:50:34 <supki> well, _ >>= \_ -> return _ is fmap
02:51:16 <merijn> elliott: Also...sad times, you're Supply requires Applicative, mine worked for any f :\
02:51:22 <merijn> s/you're/your
02:51:50 <yesthisisuser> isn't \s -> f s the same as ($) f
02:53:27 <supki> \s -> f s >>= h is f >=> h
02:54:14 <merijn> supki: I thought it would be fmap, but it's not, because that doesn't typecheck
02:54:19 <ksf> is there something like a failure monoid?
02:54:35 <merijn> supki: Oh, I know why
02:54:47 <ksf> I've got an identity, an element, an error and composition in my data type.
02:54:49 <merijn> supki: Using fmap would require a Functor constraint, mine works with just a Monad
02:54:55 <merijn> supki: Blame the absence of AMP
02:55:28 <merijn> At least "f >=> h" works :)
02:55:32 <supki> liftM to the rescue!
02:56:23 <merijn> Right, some improvement: "(More g) >>= h = More (liftM (\f -> f >=> h) g)"
02:56:53 <merijn> Which I guess could be "liftM (>=> h) g"
02:57:52 <ksf> *brrr* monoid-transformer is full of henningisms.
03:02:47 <Lethalman> I'm reading http://hackage.haskell.org/packages/archive/diffarray/0.1.1/doc/html/Data-Array-Diff.html#t:IOToDiffArray
03:03:06 <Lethalman> does the array get created in IO but then further changes can be done outside of IO?
03:03:59 <Lethalman> is this the pure functional array with fastest read and write operations?
03:06:30 <quicksilver> last I heard it didn't work very well
03:06:33 <quicksilver> but that was the idea
03:06:51 <merijn> @hoogle Applicative f => (s -> f a) -> f (s -> a)
03:06:51 <lambdabot> No results found
03:06:53 <quicksilver> I mean, last I heard it was slower than you'd hope and better just to use a persistent structure (Map, IntMap)
03:07:33 <LordBrain> what is a henningism?
03:07:38 <ksf> actually, there are two sensible error monoids. one that succeeds upon combining failure with sucess, and one that fails.
03:07:40 <mm_freak_> merijn: that seems to require Monad
03:08:30 <merijn> mm_freak_: Yeah, blah
03:09:17 <merijn> mm_freak_: I had a nice completely Applicative definition and elliott complained it wouldn't work for Monads, so now I changed it so that it does work for Monads, but now all instances have become a major pain in the ass to write :(
03:09:24 <mm_freak_> actually i'm not even sure Monad suffices
03:09:45 <merijn> Also, my unwrap function has gone from requiring nothing to needing an Applicative constraint :(
03:12:08 <Lethalman> quicksilver, by persistent structure you mean copying the whole of it?
03:14:57 <quicksilver> Lethalman: no.
03:15:20 <quicksilver> Lethalman: a persistent data structure is a normal immutable one which, typically, manages to share large portions when you change small parts.
03:15:42 <Lethalman> quicksilver, and isn't that the purpose of DiffArray?
03:15:45 <quicksilver> no
03:15:48 <quicksilver> well
03:15:53 <quicksilver> depends on your level of abstraction?
03:16:01 <quicksilver> at a high level, yes, that's the *purpose* of DiffArray
03:16:06 <Lethalman> quicksilver, well diffarray is supposed to only store differences and share the old array
03:16:13 <quicksilver> but it does it by cheating and hiding mutation behind the scenes.
03:16:30 <quicksilver> and although it's probably a good idea in principle I'm not sure it works as well in practice.
03:16:47 <quicksilver> the conventional haskell approach is just to use data structures like lists, trees, fingertrees
03:16:55 <quicksilver> which have good space and time behaviour for your needs
03:17:08 <Lethalman> quicksilver, what's the difference with Map?
03:17:18 <quicksilver> well Map is just a tree
03:17:31 <Lethalman> I mean Map shares the old map, and DiffArray shares the old array, or not?
03:17:32 <benmachine> merijn: put f = IO, what do you get when you pass readLine?
03:17:36 <quicksilver> so naturally when you change one branch the other branch is shared
03:18:08 <benmachine> er, readFile
03:18:09 <merijn> :t readLine
03:18:09 <lambdabot>     Not in scope: `readLine'
03:18:09 <lambdabot>     Perhaps you meant one of these:
03:18:09 <lambdabot>       `readFile' (imported from Prelude),
03:18:13 <merijn> :t readFile
03:18:13 <lambdabot> FilePath -> IO String
03:18:31 <Lethalman> :S I'm confused on why that's not possible with arrays
03:18:40 <Lethalman> that is, to have the same advantages of Map
03:18:53 <quicksilver> Lethalman: is it possible
03:18:56 <quicksilver> it doesn't work very well
03:19:04 <merijn> benmachine: Yeah, I realised. I'm just really annoyed that my nice flexible implementation had to be butchered just to accomodate those stupid Monad things
03:19:23 <quicksilver> Lethalman: how much do you understand about how GHC stores data structures in memory?
03:19:42 <benmachine> merijn: I'm trying to say the typesig you presented can't work with anything that IO is, so in particular can't work with Monad either
03:19:56 <Lethalman> quicksilver, don't know about ghc specifically, but I know the basis in other languages I believe
03:19:58 <merijn> benmachine: I know
03:20:52 <quicksilver> Lethalman: GHC is quite different, probably.
03:21:00 <merijn> benmachine: It's just that I had a nice "(s -> f a) -> SupplyT s f a", but elliott wasn't happy that it would allow interleaving of monadic effects when you used it to transform a monad, so I changed it to allow that. Unfortunately, as a result that function is no longer possible
03:21:02 <quicksilver> immutability is a big difference from (almost all) other languages)
03:21:06 <Lethalman> quicksilver, is it this? http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
03:21:11 <quicksilver> yes, that is it
03:21:14 <quicksilver> although that's quite detailed
03:21:15 <merijn> benmachine: Which might actually render the transformer completely useless to me...
03:21:21 <quicksilver> I was looking around for something slightly higher level
03:21:38 <Lethalman> quicksilver, that's fine
03:21:50 <merijn> benmachine: So I'm slightly miffed
03:22:34 <Lethalman> quicksilver, also because I'm lately trying to read some ghc code, so...
03:26:13 <Lethalman> quicksilver, mh right, that doesn't quite say how/when objects are copied, only how they are represented
03:26:18 <Lethalman> that doesn't help much I guess
03:26:33 <Lethalman> quicksilver, the representation is quite standard like in other languages as I can see
03:39:11 <merijn> Given a "a -> f b" and "f a" I can't obtain "f b" without Monad, right?
03:39:35 <shachaf> Well, maybe for specific f/a/b.
03:39:40 <merijn> (i.e. using only Functor/Applicative
03:39:51 <merijn> Dammit
03:39:51 <shachaf> But in general this requires Monad, yes. That's why (>>=) has that type. :-)
03:40:18 <merijn> This means I just spent 2 hours trying to make elliott happy, only to figure out that what he wants is fundamentally incompatible with what I need
03:40:32 <quicksilver> you can of course get f f b
03:40:41 <merijn> quicksilver: Yes, which is useless
03:40:44 <quicksilver> and there might be a weaker version of join which works for some cases
03:40:46 <alpounet> without join, at least
03:40:46 * quicksilver shrugs
03:40:50 <quicksilver> it's not useless at all
03:40:59 <quicksilver> f f b is a perfectly useful thing :)
03:41:10 <mauke> f f b is a kind error
03:41:13 <quicksilver> it might not be what you want
03:41:22 <quicksilver> it's not, mauke, it's just a different notation system
03:41:44 <quicksilver> that might be unhelpful in this channel though
03:41:57 <merijn> quicksilver: It is for my usecase, I started writing this transformer because StateT doesn't have an Applicative. Now I just ended up with another transformer that doesn't support Applicative only
03:43:00 <merijn> Now I need to figure out a way to implement it so that I can support both...
03:43:07 <shachaf> merijn: It's especially not useless if f is a monad!
03:43:18 <merijn> shachaf: f is not a monad
03:44:24 <kryft> merijn: Sounds like you just had a significant insight into your relationship with elliott
03:44:35 <kryft> #haskell-counseling
03:46:43 <benmachine> merijn: StateT surely should have an Applicative
03:47:24 <merijn> benmachine: It's Applicative requires Monad
03:47:34 <Taneb> merijn, I believe that is necessary
03:47:41 <merijn> benmachine: "(Functor m, Monad m) => StateT s m"
03:47:49 <merijn> Taneb: So do I, but that does make it useless to me
03:48:15 <merijn> Since I'm trying to transform an applicative
03:48:25 <merijn> I'm now running into a similar issue
03:49:14 <merijn> I'm not 100% sure about StateT needing Monad, but I haven't really looked into it yet
03:49:47 <hpaste> merijn pasted “SupplyT” at http://paste.tryhaskell.org/90644
03:50:18 <Moggle_> Apparently you can use the Cont monad to make more efficient monad transformers, can anyone explain how this works? I just read an article on the Cont monad and I'm not sure where exactly efficiency pops up. It seems to be a nice way of adding callbacks, not efficiency.
03:50:19 <merijn> There's no way to do anything useful with the "More f" in runSupplyT without join
03:50:33 <shachaf> merijn: What are you doing to make elliott happy?
03:50:47 <shachaf> Oh, you just said.
03:50:52 <ksf> do we have a library to unparse infix operators?
03:51:05 <benmachine> unparse?
03:51:09 <merijn> shachaf: I initially had "SupplyT s f a = Done (f a) | More (s -> SupplyT s f a)"
03:51:10 <ksf> pretty print
03:51:11 <mauke> generate
03:51:20 <ksf> coparsing.
03:51:36 <merijn> But elliott complained that that definition didn't allow interleaving if you tried to use a monad instance
03:51:43 <benmachine> Moggle_: it's similar to the DList trick for concatenating strings
03:51:44 <shachaf> Yes.
03:51:48 <shachaf> You want FreeT (s ->), presumably.
03:51:58 <merijn> i.e. "a <- supply; lift (print ()); b <- supply"
03:52:10 <shachaf> merijn: If you're just using Applicative, you don't need to make a transformer.
03:52:14 <merijn> shachaf: That's what elliott said yesterday, but that doesn't have an Applicative only either
03:52:19 <shachaf> merijn: Because Applicative composition gives you an Applicative.
03:52:43 <PeterNor> I'm new to Haskell ..I'm familiar with C , Node.js ... How to see haskell ??
03:52:46 <Moggle_> benmachine: I understand difference lists, but I'm not sure how it applies to monad transformers.
03:52:49 <ksf> Moggle_, google "codensity transformation"
03:53:01 <Moggle_> ksf: it shall be done
03:53:27 <merijn> shachaf: How would I implement this without defining SupplyT?
03:53:27 <benmachine> Moggle_: you end up reassociating all your >>=s which is... sometimes what you want
03:53:37 <Moggle_> PeterNor: What do you mean by seeing haskell?
03:53:39 <merijn> shachaf: I don't see which Applicative I'd wrap my Applicative with?
03:53:43 <shachaf> merijn: Compose Supply f
03:53:53 <shachaf> Where newtype Compose f g a = Compose (f (g a))
03:54:00 <ksf> PeterNor, ideally with eyes an vim.
03:54:02 <ksf> *and
03:54:16 <merijn> shachaf: Sure, but if I'm defining Supply anyway I might as well do away with the newtype wrapper
03:54:19 <Lethalman> (flame inc... :P)
03:54:35 <PeterNor> :D ... I meant there are lot of functional programming language out there
03:54:39 <shachaf> merijn: Well, you get the same Applicative instance.
03:54:55 <merijn> shachaf: Sure
03:55:06 <shachaf> You don't need to make a transformer and then apply it to Identity or whatever it is you do.
03:55:11 <shachaf> It's simpler to not have to do it. :-)
03:55:21 <Moggle_> benmachine: I hate to be thick, but do you know of any example code that shows a monad being sped up with the use of the ContT monad or something?
03:55:29 <ksf> of those that are typed, the only other relevant ones are f# and ocaml, scala if you count it as functional.
03:55:33 <merijn> shachaf: That's trivial anyway and might make things work out over Monads
03:55:42 <shachaf> Eh. OK.
03:55:51 <ksf> Moggle_, do the exercises: http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
03:55:52 <shachaf> But you're not going to get your "interleaving" this way.
03:55:56 <gspr> Does base provide a platform-independent way of obtaining an Fd to the current platform's sink-everything file (i.e. /dev/null on POSIX, NUL on Windows)?
03:56:05 <Moggle_> ksf: I am currently on that page and going for it :D
03:56:06 <PeterNor> for Example Javascript has closures as well as functional .. How is haskell is different ?
03:56:07 <benmachine> Moggle_: you're not being thick, I'm not giving a full explanation, this is because it's not my area of expertise
03:56:11 <merijn> shachaf: Why not?
03:56:19 <benmachine> Moggle_: ksf's advice sounds good :)
03:56:25 <shachaf> merijn: Well, not with this type.
03:56:26 <Moggle_> :D
03:56:30 <merijn> shachaf: (I won't for non-monads, no)
03:56:41 <shachaf> Right.
03:56:48 <luite> PeterNor: for a funcional language, javascript sure makes functional rather inconvenient :)
03:57:00 <ksf> PeterNor, haskell is statically typed, pure and lazy.
03:57:02 <luite> PeterNor: oops, i ment to say, programming in functional style
03:57:07 <ksf> ...and that.
03:57:13 <merijn> shachaf: I don't care about the interleaving, I just need a "unique name" generator which I can get from my Applicative
03:57:38 <merijn> shachaf: Whether they interleave or provide all names up front is irrelevant to me. elliott wanted interleaving for Monad
03:57:39 <benmachine> luite: you can do worse than javascript, its anonymous functions don't suck as much as Python's
03:57:42 <shachaf> OK, so what you have works?
03:58:04 <merijn> shachaf: Yeah, I'm just trying to see whether I can turn it into something generically useful
03:58:10 <luite> benmachine: oh i haven't done much python, what's wrong with them?
03:58:12 <ksf> benmachine, beats lambdas in java.
03:58:27 <benmachine> luite: lambdas in python can only return expressions, can't execute statements
03:58:34 <ksf> especially when there's oh so enterprisey bosses around that don't allow anonymous classes.
03:58:42 <merijn> shachaf: I might just implement "Control.Applicative.Supply" and "Control.Monad.Supply" separately or something
03:59:41 <shachaf> Hey, benmachine is back in #haskell.
03:59:44 <shachaf> hi benmachine
03:59:53 <benmachine> shachaf: hi! I got a degree
04:00:01 <benmachine> in a month's time I'll have a job and probably be gone again :P
04:00:13 <luite> benmachine: oh that's annoying... although does a single statement work? lambda x: print(x) ?
04:00:26 <shachaf> benmachine: Hooray!
04:00:58 <luite> hooray, he will be gone again soon ;)
04:01:09 <benmachine> luite: that works in python3 now print is a function
04:01:17 <benmachine> didn't work in python2 when print was a statement
04:01:30 <shachaf> E.g. (lambda x: y = x) doesn't work.
04:01:38 <mcstar> it is important to appreciate that someone gets a degree/graduates, so good work benmachine!
04:01:40 <luite> assignment isn't an expression?
04:01:51 <benmachine> mcstar: thanks
04:01:56 <benmachine> luite: indeed
04:02:01 <shachaf> Yep.
04:02:03 <luite> ack :/
04:02:10 <mcstar> benmachine: happened to me too on friday :)
04:02:14 <benmachine> (which I think is kinda sensible actually)
04:02:15 <Eduard_Munteanu> Should we wish you good riddance? :P
04:02:17 <benmachine> mcstar: hi5
04:02:19 <luite> so does x = y = z not work at all, or is that parsed differently?
04:02:20 <t7> doesnt python have a seq function or something?
04:02:36 <benmachine> luite: parsed differently, I think
04:02:50 <luite> ok!
04:02:59 <shachaf> benmachine: The only thing that's left is to move to San Francisco.
04:03:00 <luite> #haskell, the best channel to learn pythong
04:03:04 <luite> python
04:03:05 <luite> argh
04:03:21 <thoughtpolice> shachaf: how many Haskellers have you gotten to move to SF?
04:03:30 <shachaf> luite: On the other hand (x < y in z) means (x < 7 and y in z)!
04:03:48 <luite> shachaf: have the forest fires reached SF yet?
04:03:56 <shachaf> thoughtpolice: No true Haskeller lives outside the SF bay area.
04:04:18 <eikke> shachaf: will you pay my rent? :P
04:04:20 <merijn> shachaf: :(
04:04:33 <shachaf> Anyway, #haskell-blah
04:04:35 <Entroacceptor> > true Haskeller
04:04:36 <lambdabot>   Not in scope: `true'Not in scope: data constructor `Haskeller'
04:14:45 <Spockz> I'm trying to abstract over two very similar looking lines of code but I'm stuck, maybe someone here has an epiphany? https://gist.github.com/spockz/84b083329e811595bd92
04:20:21 * hackagebot llvm-general 3.3.0.7 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.7 (BenjaminScarlet)
04:24:20 <benmachine> Spockz: so the problem with your code is that t -> (c,c') -> (c,c') is not the type of the functions you give it
04:24:39 <benmachine> Spockz: because you pass x and replace one of the components with it, getting either (t,c') or (c,t)
04:29:25 <Eduard_Munteanu> Is cabal supposed to check/get signatures securely for packages?
04:29:44 <Eduard_Munteanu> (assuming there are any, but I also mean checksums)
04:29:51 <eikke> thats work-in-progress afaik
04:31:20 <Eduard_Munteanu> Actual sigs would be nice, but checksums are quite important (assuming one could get them e.g. over https).
04:32:31 <bakibour> Moin, is there any library with which i can write a 3d mesh in Haskell?
04:35:21 * hackagebot llvm-general 3.2.0.9 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.9 (BenjaminScarlet)
04:36:14 <ksf> for output or in general? you could have a look at how lambdacube does things.
04:38:08 <bakibour> ksf: For output i have written some code that models (as i hope) a simple FEM. I just want to see if the values it prints out are correct by looking at the plot.
04:42:14 <Spockz> benmachine: hem, yes
04:42:32 <Spockz> benmachine: so I imagine I have to make that distinction in the type somehow by using Either
04:44:03 <ksf> bakibour, I'd say just output straight to gl, then.
04:44:48 <ksf> unless there's some specialised library for such stuff, but I wouldn't know of it.
04:47:05 <bakibour> Id love to print it as svg.
04:47:19 <bakibour> Isnt there anything like gnuplot for Haskell?
04:47:26 <ksf> there's gnuplot bindings.
04:47:43 <ksf> http://hackage.haskell.org/package/gnuplot
04:47:49 <byorgey> bakibour: also check out the 'Chart' library
04:47:56 <bad_alloc> Hi, I'm trying to reimplement the list monad. The problem is that my definition conflicts with the one in GHC.Base. How do I hide this single monad? I need to keep the others though. So far I've got   import Prelude hiding (Monad(..))   which hides all monads from prelude
04:48:07 <mauke> you can't
04:48:18 <bakibour> kk
04:48:31 <ksf> bad_alloc, just make your own list type, that's the most stressfree thing.
04:48:43 <ksf> data List a = Cons a (List a) | Nil
04:49:10 <byorgey> also,  hiding (Monad(..))  doesn't hide all monads from the Prelude.  It just hides the Monad type class.
04:49:34 <bad_alloc> ksf: The I just say "instance Monad List where..." ?
04:49:43 <ksf> bad_alloc, yep
04:49:52 <bad_alloc> Ok will do. Thanks :)
04:49:55 <ksf> and use cons instead of : etc.
04:50:09 <ksf> you could also use
04:50:21 * hackagebot oeis 0.3.3 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  http://hackage.haskell.org/package/oeis-0.3.3 (BrianLewis)
04:50:23 <ksf> data List a = a :- (List a) | Nil or something like that.
05:07:59 <akegalj> i am using gtk2hs api for some gui work. I'm having problems with treeview search (type ahead gtk builtin search), it seams kind of laggy/slow. Can anyone confirm this?
05:11:45 <supki> merijn: I've encountered a weird behaviour in indenting: http://paste.tryhaskell.org/new/haskell Is it a feature?
05:11:51 <supki> oops
05:12:02 <supki> http://paste.tryhaskell.org/8049971922022170624
05:12:21 <supki> merijn: I'd rather like the inverse of that :)
05:12:58 <merijn> supki: It indents a full indent if add something on the same line, and half when you leave it on one line, i.e.
05:15:29 <merijn> I could make that an option, I guess
05:16:14 <supki> merijn: well if I write "case () of" instead of "where " it's still one space
05:17:11 <merijn> supki: When you write that on the line after the = or if you write that on the new line?
05:18:37 <supki> merijn: I've edited the paste
05:19:12 <merijn> Yeah, it treats that as a line continuation and those are indented by half an indent
05:19:44 <supki> aha
05:20:08 <supki> I want an option to set it to full indent :)
05:20:54 <merijn> The where and case things are different, though. So I guess the question is whether you want that to change for one or both of those
05:23:42 <merijn> ugh
05:23:45 <supki> I usually indent line continuations with full indent and wheres with half indent
05:23:49 <merijn> Monad doesn't have a Functor superclass either?
05:23:57 <supki> so that thing does eveything wrong!
05:23:59 <supki> nope
05:24:03 <merijn> bah
05:25:36 <tomboy64> i am trying to optimize a recursive search-routine for numbers. it works over [1..] and is allowed to pick only lower numbers in each loop. so, search 500 -> 450 -> 475 -> 300  is legal. search 500 -> 450 -> 720 ... is not. hence i test only for lower numbers.
05:27:04 <tomboy64> now when i arrive at 800, i want to do 800 -> 500 -> 450 -> 720 (which would be legal now), but since i only have evaluated 500 with the predicate "don't go over 500", it does the whole search all over again, e.g. testing for the lower values that had already been examined.
05:27:29 <tomboy64> how would i go about designing an algorithm in haskell that avoids this superfluous work?
05:28:02 <tomboy64> (i managed to implement quite a bit of memoizing so far, but this bit eludes my grasp :( )
05:28:23 <tomboy64> (at least i hope it memoizes ...)
05:36:35 <yitz> tomboy64: i guess you want your predicate to be "don't go over 500 if not already memoized"
05:37:40 <tomboy64> hm
05:38:46 <tomboy64> yitz: yes, i guess so. but how do i implement that :-/
05:44:43 <merijn> shachaf: Actuall, there is an argument to write the Applicative in transformer style, even though simple composition makes the Applicative work
05:45:35 <elliott> btw, the form you had was FunList
05:45:44 <elliott> aka lens's Bazaar
05:45:46 <merijn> shachaf: I have "demand :: Supply s s", if I implement it directly and use compose, then there I have to implement a separate "demandT :: Applicative f => Supply s (f s)" to make it work like I want
05:45:51 <elliott> oh
05:45:52 <shachaf> Wait, FunList? Where?
05:45:54 <elliott> not quite actually
05:46:01 <elliott> http://twanvl.nl/blog/haskell/non-regular2
05:46:04 <elliott> it's isomorphic to uh
05:46:05 <shachaf> FunList is a non-regular type.
05:46:11 <elliott> ok never mind
05:46:13 <elliott> i was wrong
05:46:32 <shachaf> What was the type merijn had?
05:46:32 <merijn> shachaf: Whereas, if you have "demand :: SupplyT s f s" and "type Supply s a = SupplyT s Identity a", then things "Just Work"
05:46:54 <merijn> Since demand can then unify with both "SupplyT s f s" and "Supply s s"
05:47:10 <shachaf> Hm.
05:47:15 <merijn> elliott: btw, your proposed version sucks
05:47:20 <merijn> elliott: It requires Monad
05:47:32 <shachaf> You can still write the simpler Applicative, and then make "demandT" work on a composed version or something.
05:47:46 <elliott> merijn: well, don't call yours Supply then :P
05:48:03 <merijn> shachaf: I don't want to have demandT, I just want demand to work on both Supply and lifted Supply :p
05:48:05 <elliott> the one true supply Monad!!!
05:48:13 <merijn> elliott: I'm making separate monad and applicative instances
05:48:32 <merijn> i.e. Control.Applicative.Supply and Control.Monad.Supply
05:48:51 <merijn> Where the former does no interleaving and the latter does
05:49:36 <tomboy64> hmm
05:49:55 <tomboy64> i guess i'll reverse the search order and try implementing a tree
06:00:50 <dropdrive> What is an efficient way to store (the equivalent of) a finite list [(Int, Maybe Double)] to disk?  No need to make "take n" faster as n decreases.
06:01:10 <mauke> a file
06:02:06 <merijn> Is there a way to check whether an extension is available? (In cabal, that is)
06:03:54 <dropdrive> mauke: What format?
06:04:35 <mauke> what properties do you want?
06:05:25 <dropdrive> mauke: Not sure what you mean by "properties".  Fast to load?
06:06:23 <mauke> sereal or binary maybe
06:06:30 <mauke> er, *cereal
06:08:38 <quicksilver> binary wouldn't give you fixed length records
06:08:49 <quicksilver> well its automatic instance wouldn't
06:08:51 * bakibour thinks about binary cereals, that should be the next big thing in nutrition
06:08:55 <quicksilver> clearly you could write your own instance which did.
06:09:16 <quicksilver> you might want fixed length records, but who knows? you haven't told us much about your requirements :)
06:09:52 <dropdrive> quicksilver: Hmm, not sure what else I can say?  It's [(Int, Maybe Double)].
06:10:02 <quicksilver> how do you plan to access the data?
06:10:08 <quicksilver> will you save/load it all at once?
06:10:14 <dropdrive> quicksilver: Yes, always.
06:10:18 <quicksilver> are you storing billions or records? quadtrillions?
06:10:20 <quicksilver> or around seven?
06:10:41 <dropdrive> quicksilver: Oh.  Good point.  Maybe around 100K "rows".
06:11:44 <quicksilver> either binary or cereal should be fine
06:11:50 <mauke> if you don't need Just NaN, you can map Nothing to NaN and save a byte
06:12:00 <quicksilver> and you can use the standard built in instances
06:12:19 <quicksilver> mauke-- # immature optimization
06:12:23 <dropdrive> mauke: Thanks, I might do that.
06:12:36 <mauke> this assumes fixed-length records
06:12:49 <mauke> on the other hand, if you have a lot of Nothings, variable-length might be smaller
06:13:02 <dropdrive> So maybe it's actually better to have (unboxed int array, unboxed double array) but then I don't get the assurance that the arrays are the same length, right?
06:13:24 <dropdrive> mauke: (I have small numbers of Nothing.)
06:18:18 <merijn> If I want to pretend to care about portability, should I just check for the GHC version and disable any extensions if there's anything other than GHC?
06:31:09 <byorgey> merijn: if you only want to *pretend* to care about portability, then you can do anything you want as long as it looks good
06:31:14 <byorgey> otherwise, I don't understand your question
06:32:15 <gspr> Is it a known bug that Hoogle returns bad links relating to ForeignPtr?
06:32:25 <elliott> byorgey: I think "pretend" may have beena joke :)
06:33:08 <byorgey> I know, so was my response =)
06:33:17 <vlatkoB> Why is compiler complaining "Couldn't match expected type `a0 -> Bool' with actual type `Bool'"
06:33:17 <vlatkoB> if
06:33:17 <vlatkoB>   a :: String
06:33:17 <vlatkoB>   fun :: x -> String
06:33:17 <vlatkoB>   let q = filter ((a == fun)) xs
06:33:18 <vlatkoB> a == fun is partialy applied/reduced, or?
06:33:20 <merijn> byorgey: I'm willing to put in a token effort
06:33:20 <vlatkoB> (\x -> a == fun x) works fine
06:33:27 <haasn> @paste vlatkoB
06:33:27 <lambdabot> Haskell pastebin: http://hpaste.org/
06:33:33 <byorgey> vlatkoB: please don't paste code in the channel
06:33:44 <merijn> byorgey: I have a MPTC and some functions using it, which are optional
06:33:49 <vlatkoB> ups, will remember
06:34:05 <haasn> vlatkoB: ‘a == fun’ <- you're comparing something of type String and something of type (x -> String)
06:34:08 <haasn> :t (==)
06:34:08 <lambdabot> Eq a => a -> a -> Bool
06:34:09 <merijn> byorgey: So if FunDeps and MPTC are available, I wanna export them, else I wanna #ifdef them out
06:34:33 <haasn> also, (a == fun) returns a Bool, while filter expects something of type (a -> Bool)
06:34:49 <haasn> :t filter
06:34:50 <lambdabot> (a -> Bool) -> [a] -> [a]
06:34:51 <vlatkoB> haasn: I thought I was supplying reduced function which takes one param
06:34:57 <byorgey> merijn: ah.  well, keep in mind that you can't comment out LANGUAGE pragmas using CPP
06:35:03 <byorgey> since CPP itself is a LANGUAGE pragma.
06:35:26 <haasn> vlatkoB: ‘a == fun’ is (==) a fun <- you're applying the (==) function to the parameters ‘a’ and ‘fun’
06:35:31 <byorgey> so you could conditionally comment out the actual MPTC and related stuff, but not the MPTC pragma itself
06:35:39 <merijn> byorgey: That's what I meant
06:36:01 <haasn> vlatkoB: (==) takes two parameters of the same type, and returns a Bool; your parameters are not the same time. I'm not sure what else you're trying to partially apply
06:36:06 <haasn> not the same type*
06:36:07 <shachaf> merijn: You can't?
06:36:10 <shachaf> s/merijn/byorgey/
06:36:30 <byorgey> I don't think so.  I could be wrong though.
06:36:32 <haasn> byorgey: maybe you could move the pragma to GHC options
06:36:48 <haasn> and exclude those based on some .cabal logic
06:36:50 <vlatkoB> haasn: Is there a way to write that without lambda?
06:36:56 <shachaf> lens does it
06:37:00 <shachaf> E.g. https://github.com/ekmett/lens/blob/master/src/Control/Lens/Lens.hs
06:37:08 <haasn> vlatkoB: I'm not sure what you're trying to do
06:37:25 <byorgey> shachaf: huh, what do you know
06:37:27 <thoughtpolice> you can use CPP in a file to control LANGUAGE pragmas, yeah
06:37:32 <thoughtpolice> i did it for Control.Category too
06:37:36 <byorgey> cool, I was wrong
06:37:44 <thoughtpolice> although some extensions are kind of 'infectuous' like PolyKinds.
06:37:47 <mauke> @pl (\x -> a == fun x)
06:37:48 <lambdabot> (a ==) . fun
06:38:21 <byorgey> merijn: in any case, I think a more robust solution would be to put the MPTC etc. stuff in a separate module, and have some conditional stuff in the .cabal file to check for the compiler and include that module or not
06:38:28 <byorgey> that seems a lot cleaner than using CPP
06:38:44 <vlatkoB> I'm still learning. Filter is working if I write the bool function as lambda, but I thought it should work in that shorter way.
06:39:02 <haasn> vlatkoB: what's the form that works?
06:39:28 <vlatkoB> filter (\x -> a == fun x) xs
06:39:36 <haasn> aha!
06:39:42 <haasn> now that's a different function =)
06:39:59 <vlatkoB> Is it possible to write it without lambda?
06:40:33 <haasn> here's how to reduce the lambda, if you really wanted to do so: (\x -> a == fun x)  =  (\x -> (==) a (fun x))  =  ((==) a . fun)  =  ((== a) . fun)
06:40:40 <haasn> (the last step is just cosmetic)
06:40:50 <byorgey> all the steps are cosmetic =)
06:40:56 <haasn> heh, true
06:41:39 <haasn> byorgey: not necessarily, we don't know what kind of ⊥-related evil (==) and ‘fun’ are doing here :)
06:41:54 <merijn> byorgey: ewww...orphan instances
06:42:01 <merijn> oh, wait
06:42:02 <merijn> No
06:42:05 <merijn> I'm an idiot
06:42:13 <byorgey> haasn: if you want to go to that level, then note that (==) a = (a ==),  not (== a)
06:42:17 <vlatkoB> Niceee. Thanks. Haskell roks.
06:42:25 <byorgey> == might not be symmetric! ;-)
06:42:28 <haasn> byorgey: d'oh! I double-checked that and still messed it up
06:42:42 <haasn> (==) a -> (== a) just looks so right =D
06:42:50 <byorgey> it does, doesn't it
06:43:17 <shachaf> Just like (/) 5 -> (/ 5)
06:43:24 <quchen> {-# RULES forall a. (==) a = \x -> (==) x a #-}     -- There, I fixed it
06:43:32 <haasn> yeah, or (-) 5 -> (-5)
06:43:35 <haasn> (wait what?)
06:45:53 <eacameron1> Using Aeson, why deos this work "visitType   <- (liftA visitTypeFromFk) <$> (v .:? "visit_type_fk")" but not this "visitType   <- visitTypeFromFk <$> (v .:? "visit_type_fk")"? Shouldn't fmap apply a normal function inside the Maybe without me having to lift it?
06:48:29 <vlatkoB> haasn: works both (== a) and (a ==)
06:48:37 <haasn> vlatkoB: yes :)
06:49:02 <haasn> vlatkoB: (==) should be commutative, we were simply being silly
06:49:46 <quchen> eacameron1: The <$> you're using is to fmap into the Parser that (.:?) returns (more specifically, .:? fully applied gives you a `Parser (Maybe a)`). If you want to map something over the "a" contained in there, you have to go 2 levels deep, hence you need to use fmap.fmap.
06:49:49 <haasn> (== a) is literally just \x -> x == a
06:49:52 <shachaf> Commutativity is the dual of mutation, I guess.
06:50:16 <vlatkoB> haasn: In first def, (==) is used as a function, and in the second it is infix. But param is added to the right always. Right?
06:50:55 <eacameron1> quchen: Wow! You deciphered my question perfectly. Awesome, thank you so much. That makes complete sense.
06:51:03 <haasn> vlatkoB: In the first it's used infix as well, just with special syntax (I forget the name for it)
06:51:20 <haasn> (== a) <- ‘==’ is still parsed as an operator, it's not quoted, you just supply only one operand
06:51:21 <quchen> eacameron1: And I would recommend using fmap instead of liftA, it's more general. :-)
06:51:37 <haasn> unless you meant something else
06:51:47 <eacameron1> quchen: got it...will do
06:52:10 <vlatkoB> I'm bit confused how compiler knows on which side the param should be placed
06:52:45 <haasn> Well, if you write (a ==) then you've supplied the left side, if you write (== a) then you've supplied the right side. I'm not sure what you're asking
06:53:22 <haasn> these are just simple translation rules; (a ==) literally parses as (==) a; and (== a) literally parses as \x -> (==) x a
06:53:55 <vlatkoB> I see, thanks.
06:54:38 <shachaf> haasn: No, it doesn't parse as that, and it also doesn't mean that (in standard Haskell, anyway).
06:55:16 <haasn> huh?
06:55:33 <quchen> shachaf: What's the problem with the "meaning" part? That it introduces a new variable x?
06:55:39 <haasn> If I'm spreading misinformation, please correct me
06:56:23 <quicksilver> erm
06:56:36 <haasn> Translation: The following identities hold:
06:56:39 <haasn> (op e)  =  \ x -> x op e
06:56:41 <haasn> (e op)  =  \ x -> e op x
06:56:45 <quicksilver> well haasn's use of the word 'parse' is technically incorrect but leaving that aside, I think what he wrote was fine.
06:56:48 <quicksilver> shachaf: ?
06:56:52 <haasn> looks like my (a ==) case was incorrect
06:57:01 <elliott> I assume shachaf is referring to the fact that ((==) a) isn't quite the same as (\b -> a == b)
06:57:10 <shachaf> Yes, what elliott said.
06:57:17 <elliott> though frankly I think we'd all like to forget that that isn't true, and I believe we usually act as such
06:57:18 <merijn> Which one do I want? "Ambiguous module name `Control.Monad.Trans.List': it was found in multiple packages: List-0.5.1 transformers-0.3.0.0"
06:57:25 <elliott> so I don't think the pedantry is necessary here, personally
06:57:46 <quchen> elliott: Pedantry or not, what's the difference between the two?
06:58:24 <elliott> quchen: _|_
06:58:34 <elliott> > (undefined :: () -> ()) `seq` ()
06:58:35 <lambdabot>   *Exception: Prelude.undefined
06:58:37 <haasn> > let (==) = undefined in seq ((==) ()) ()
06:58:38 <elliott> > (const undefined :: () -> ()) `seq` ()
06:58:39 <lambdabot>   *Exception: Prelude.undefined
06:58:39 <lambdabot>   can't find file: L.hs
06:58:45 <haasn> > let (==) = undefined in seq (\x -> () == x) ()
06:58:46 <lambdabot>   ()
06:58:50 <shachaf> But there was already a lot of pedantry.
06:58:57 <haasn> oh, sorry for conflicting with elliott, but you get the idea
06:59:05 <shachaf> Like byorgey said, "if you want to go to that level"
06:59:14 <elliott> "can't find file: L.hs" is the worst message.
06:59:18 <haasn> yes
06:59:23 <elliott> OK, I'm going to work on the new @run right now.
06:59:27 <elliott> you motivated me, haasn.
06:59:33 <haasn> @faq Can Haskell fix L.hs?
06:59:33 <lambdabot> The answer is: Yes! Haskell can do that.
06:59:40 <haasn> s/fix/find/
06:59:45 <quchen> elliott: Ah, the ability of seq to distinguish between bottom and (const bottom)
06:59:45 <shachaf> Can you work on the the @faq while you're at it?
06:59:58 <shachaf> quchen: There is also the type.
07:01:05 <merijn> elliott: I'm taking all this effort for you, so which List transformer do I want? :p
07:01:30 <elliott> merijn: what do you mean?
07:02:34 <merijn> I was implementing MonadSuplly, so I just copied all the transformers from MonadReader, but cabal complains there's two possible Control.Monad.Trans.List's
07:03:55 <merijn> Oh, that seems to just be hdevtools that's complaining, looks like cabal is ok with it
07:04:10 <shachaf> quicksilver: GHC used to translate (a `op`) into (op a) and explicitly switched to the lambda translation.
07:04:21 <shachaf> And now requires an extension for the old behavior.
07:04:22 * quicksilver nods
07:04:26 <quicksilver> interesting
07:05:43 <deech> Hi all, why do I have to 'liftIO' to use the IO monad in a transformer but call to the other ones in the stack can be inferred?
07:06:52 <elhask> Hi, I want to write a small Haskell library that manages a complex data structure (doen't matter which, e.g. a graph) whick will be callable from C. The C part will not perform any modifications/side effects on the data structure but will need to be able to receive some kind of (opaque) handle to the Haskell managed structure in order to be able to pass it in when Haskell fucntions are called. In other words, can I make something like
07:07:11 <bscarlet> deech: The "call to the other ones" are functions in typeclasses. The uses of IO which require liftIO are not.
07:07:18 <quicksilver> elhask: you got cut off at 'something like'
07:07:23 <elhask> to the C via a (void *)?
07:07:29 <elhask> In other words, can I make something like the State monad but which I can pass to the C via a (void *)?
07:07:33 <quicksilver> but the answer is probably "yes" - C strutures can be given an opaque handle to haskell objects.
07:07:37 <deech> bscarlet: Ah, thanks!
07:08:31 <merijn> elliott: The answer is probably "You want StablePtr"
07:08:32 <merijn> eh
07:08:36 <elhask> BTW, I don't want serialisation/marshalling, due to the complexity of the structure and the fact that it will be opaque to the C part
07:08:36 <merijn> s/elliott/elhask
07:08:47 <merijn> elhask: See above
07:09:22 <elhask> OK, I had searched and read the FFI and saw StablePtr but I didn't understand that it would be usable
07:09:51 <merijn> elhask: StablePtr is explicitly for things that need to be passed to C land and back, but C doesn't have to touch them
07:10:05 <elhask> Thank you very much for the help merijn and quicksilver!
07:10:18 <elhask> I will read up
07:10:40 <elhask> BTW, has anyone got their beta at FPComplete activated yet?
07:11:41 <elhask> I'm using EclipseFP ATM but I'm looking forward to testing out FPComplete's offering
07:12:34 <merijn> elliott: hmm, the suggestion you had yesterday of "data SupplyT s m a = Done a | More (m (s -> SupplyT s m a))" is doomed as a transformer implementation. You can't even properly implement lift, I think
07:12:57 <elliott> that was not my suggestion
07:13:03 <elliott> I said it was broken when I thought that's what you had
07:13:11 <deggis> eclipsefp looked (again) lot more promising than 6-12 months ago. i'm not even sure if the quirks i found were standard eclipse things or plugin's
07:13:22 <merijn> elliott: pfft, so I tried to make that work for nothing >.>
07:13:40 <elliott> you could have a separate Lift constructor or do it like FreeT (latter is slightly more strictly compliant with the laws)
07:14:13 <merijn> hmmm
07:14:19 <elhask> deggis: I've just reinstalled and I aggree. Foe ppl wanting an IDE (and I understand that many don't) it's quite nice, esp. if you've got the RAM to spare
07:14:44 <shachaf> merijn: That SupplyT isn't the regular FreeT of (s ->).
07:14:45 <elhask> deggis: I'm running it on tmpsf and it's faste nough
07:14:49 <elhask> deggis: I'm running it on tmpsf and it's fast enough
07:15:08 <shachaf> Or maybe the regular FreeT (s ->) is just m of that SupplyT? Not sure.
07:15:37 <merijn> shachaf: That's not the one I wanted anyway
07:15:45 <merijn> shachaf: I think I misunderstood elliott yesterday
07:16:09 <merijn> shachaf: The one I wanted initially was "SupplyT s m a = Done (m a) | More (s -> SupplyT s m a)"
07:16:28 <bor0> @src filter
07:16:28 <lambdabot> filter _ []     = []
07:16:28 <lambdabot> filter p (x:xs)
07:16:28 <lambdabot>     | p x       = x : filter p xs
07:16:28 <lambdabot>     | otherwise = filter p xs
07:16:34 <deggis> elhask: i should try that. it had even support for cabal-dev now
07:18:33 <elhask> deggis: yeap, cabal-dev support seems ok, but I haven't had enough time to really test it out.
07:18:35 <bor0> what is the real difference between recursive filter and this oneliner? (\l f -> [ x | x <- l, f x ])
07:18:55 <bor0> besides one using recursion and the other list comprehension, is there any difference in speed say?
07:19:13 <djahandarie> Hmm, is there a good way to iterate over the search space of parListChunk?
07:19:36 <mauke> @undo [ x | x <- l, f x ]
07:19:36 <lambdabot> concatMap (\ x -> if f x then [x] else []) l
07:20:16 <bor0> > (\l f -> [ x | x <- l, f x ]) [1,2,3,4,5] (>=3)
07:20:17 <lambdabot>   [3,4,5]
07:20:20 <Saizan> bor0: GHC in particular might be better at fusing the latter, unless you add a RULE for the former (like the stdlib does i thin)
07:21:12 <bor0> what is a RULE?
07:23:13 <bor0> @undo [ x * x | x <- l ]
07:23:13 <lambdabot> concatMap (\ x -> [x * x]) l
07:24:01 <tomboy64> yitz: thank you for your input, i think i've devised a workable improvement based on Data.IntMap
07:24:14 <tomboy64> now to implement it :-}
07:24:37 <quchen> bor0: You can write custom rewrite rules that are applied during compilation. The compiler will use them to simplify the code.
07:25:17 <quchen> bor0: The syntax is {-# RULES ... #-}, and that's why they're called RULES in all caps. :-)
07:26:55 <osa1> do I need to pass cabal-dev `--flags=-fprof-auto` after --enable-library-profiling --enable-executable-profiling?
07:28:11 <elliott> they're RULES because you're in big trouble if you violate them
07:28:45 <quchen> Or that, yes.
07:29:37 <Taneb> You know how GHC tends to generate large executables? Like, 700KB for a hello world program?
07:29:43 <byorgey> osa1: if you want cost centers to be automatically generated for the libraries and executables being built, yes
07:29:43 <Taneb> Is that a constant factor?
07:29:53 <elliott> it's library linking usually
07:29:56 <elliott> you can use dynamic linking nowadays
07:30:23 <osa1> byorgey: ok. for a second I thought maybe cabal-dev automatically passes that to ghc when --enable-xyz-profiling is used
07:32:52 <bor0> okay, thanks guys
07:34:30 <bor0> @src enumFromTo
07:34:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:36:04 <osa1> seems like my --flags are not passed to ghc
07:41:22 <osa1> byorgey: cabal-dev doesn't pass --flags flags to GHC. I'm calling it with `cabal-dev install --enable-library-profiling --enable-executable-profiling --flags=-fprof-auto -v3` and it's clear from the output that -fprof-auto is not passed to GHC. any ideas?
07:44:42 <quchen> bor0: enumFromTo is part of the Enum typeclass. It doesn't have "a" source, but one for each instance.
07:45:01 <quchen> i.e. it's different for Bool, Int, Integer and so on.
07:45:20 <Saizan> osa1: try --ghc-option=-fprof-auto
07:46:53 <osa1> Saizan: thanks, that worked
07:50:11 <bor0> that's interesting to know, thanks
07:59:07 <Luke> can someone explain the semantics of a conduit "fuse" (=$=) function?
08:00:40 * hackagebot yaml 0.8.3 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.3 (MichaelSnoyman)
08:07:50 <kamatsu> hi all
08:07:56 <kamatsu> if i want to use data.lens with data.vector
08:08:10 <kamatsu> sorry, control.lens, ekmett's package
08:08:20 <Taneb> Look in the Data.Vector.Lens module
08:09:03 <kamatsu> yeah, but i'm still floundering a bit with the lens library. I can see how to get the nth element traversal, but will that efficiently get/set the vector or will it traverse up to the nth element each time
08:09:36 <Taneb> It's efficient, lenses have O(1) access I believe
08:10:17 <elliott> "traversal" here just means that it can possibly not be present
08:11:20 <kamatsu> right, so is that the difference between a traversal and a lens?
08:11:38 <elliott> well, a lens is a traversal that always has one result.
08:11:44 <elliott> a traversal can have any number of results.
08:11:46 <merijn> kamatsu: There's a really nice (and long...) talk on youtube explaining these things
08:11:54 <elliott> here, the specific kind of traversal is an "affine traversal". that means either 0 or 1 results.
08:11:57 <merijn> @where lens
08:11:57 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
08:11:58 <elliott> hence, you can think of it as a partial lens
08:12:01 <elliott> because the index might be out of bounds.
08:12:13 <kamatsu> ah, i understand
08:17:40 <igstan> @where comonad
08:17:40 <lambdabot> http://hackage.haskell.org/packages/archive/comonad/latest/doc/html/Control-Comonad.html | http://comonad.com/
08:19:48 <kamatsu> hm? could not deduce Traversable Vector
08:27:09 <sclv__> @remember emeijer It must me said on the other hand compiler writers seem to ignore the existence of formal semantics completely, probably because they don't like greek letters.
08:27:09 <lambdabot> I will never forget.
08:29:18 <kamatsu> vector is not an instance of traversable, so i can't seem to use lens' element traversal to get an element.
08:29:19 <mauke> sclv__: s/me/be/?
08:30:13 <kamatsu> furthermore, i'm struggling to see how lens could efficiently implement that so generally on the basis of traversable.
08:30:14 <elliott> kamatsu: you want to use ix or at
08:30:19 <elliott> from Control.Lens.At
08:30:49 <kamatsu> ah, i missed that module
08:30:55 <kamatsu> thanks
08:33:38 <eacameron1> what's the easiest way to transform nested Maybes into a single Maybe?
08:33:54 <elliott> join
08:34:21 <bartavelle> there are several ways to do that though
08:34:35 <elliott> there are?
08:34:43 <elliott> I can think of only one Maybe (Maybe a) -> Maybe that doesn't "throw away information".
08:34:45 <bartavelle> Monoid a => [Maybe a] -> Maybe a
08:34:46 <elliott> *Maybe a
08:34:54 <elliott> well, ok.
08:34:57 <elliott> those aren't nested though.
08:35:04 <bartavelle> ahhhhh
08:35:17 <bartavelle> ok disregard my intervention
08:36:29 <mauke> :t (=<<)($)
08:36:30 <lambdabot> (a -> a -> b) -> a -> b
08:36:37 <eikke> :t Data.Foldable.asum
08:36:38 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
08:36:43 <eacameron1> elliott: thank you! That's been driving me mad
08:37:21 <elliott> :)
08:37:34 <eacameron1> so join is the same as (<-) ?
08:37:55 <igstan> is it a good way to think of co-stuff, e.g. comonads, as the same function but with recursively reversed function signatures?
08:38:13 <igstan> at least, that's how it looks when I compare monad and comonad
08:39:12 <merijn> eacameron1: join is just "join :: Monad m => m (m a) -> m a"
08:39:25 <merijn> eacameron1: In case of Maybe "join :: Maybe (Maybe a) -> Maybe a"
08:39:39 <TheLemonMan> hrm, i have a problem with cabal...hsndfile requires c2hs, but c2hs is provided only as a bin and isn't registered in the package list. I'm stuck here
08:39:56 <merijn> TheLemonMan: Make sure the cabal binary dir is in your path
08:40:08 <mauke> @src join
08:40:08 <lambdabot> join x =  x >>= id
08:40:12 <eacameron1> merijn: It seems similar to (<-) except one level deeper
08:40:41 <mauke> eacameron1: join x = do { y <- x; y } = do { y <- x; z <- y; return z }
08:41:04 <eacameron1> mauke: ahh...yeah that makes sense
08:41:14 <elliott> igstan: a co-X is usually an X with all the arrows swapped. but these are the arrows that define X in category theory
08:41:21 <elliott> igstan: so for instance you don't get comonads from swapping the arrows in (>>=)
08:41:24 <elliott> but instead in join
08:41:43 <TheLemonMan> merijn: it's there, i can invoke c2hs from the term successfully
08:42:32 <merijn> TheLemonMan: That's odd...
08:42:50 <dropdrive> In applicative land, is there a nicer way to write: (+) <$> a <*> b ?
08:43:03 <merijn> TheLemonMan: You'd have to read the docs/contact the maintainer
08:43:11 <elliott> dropdrive: you can liftA2 (+) a b
08:43:12 <merijn> dropdrive: "liftA2 (+) a b"?
08:43:23 <merijn> I prefer <$> and <*>, tbh
08:43:29 <dropdrive> elliott, merijn: Thanks, I had that, thought it was uglier.
08:43:45 <elliott> idiom brackets would let you say (| a + b |)
08:43:48 <elliott> too bad we don't have them.
08:44:41 <byorgey> but we do!  cabal install she
08:44:50 <merijn> dropdrive: Well, you could do something silly like "let (<+>) = liftA2 (+) in a <+> b"
08:44:53 <igstan> elliott: but you have to swap arrows for >>= as well, right? that's what extend looks like to me http://hackage.haskell.org/packages/archive/comonad/latest/doc/html/Control-Comonad.html#v:extend
08:45:30 <mauke> :t (=<<)
08:45:32 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:46:20 <elliott> igstan: sure
08:46:24 <elliott> it depends how you define "swap" :)
08:46:32 <elliott> byorgey: if you can deal with the errors she emits...
08:46:35 <igstan> elliott: right
08:55:18 <archblob> hello
08:55:42 <archblob> i think GHC is playing a trick on me :-(
08:56:37 <bscarlet> archblob: do tell
08:56:40 <archblob> you see, i have a function, let's call it f :: ( Ordering -> Bool) -> a -> b -> b with {-# INLINABLE f #-}
08:57:10 <archblob> and another function g :: a -> b -> b with {-# INLINE g #-}
08:57:59 <archblob> when i define f as f k m = g  (GT ==) (*or whatever) k m
08:58:01 <archblob> all is fine
08:58:12 <archblob> but when i eta-reduce f
08:58:21 <archblob> i see a 20x slowdown
08:58:29 <archblob> is this normal?
08:59:58 <archblob> in the documentation for {-# INLINE #-} it is stated that this is not applicable partial application
09:00:23 <archblob> but what does that have to do with eta-reduction ?
09:02:03 <archblob> i would put the code on hpase but it's on a local branch and it's part of a library
09:02:38 <Saizan> archblob: i assume that means g will only be inlined when it appears fully applied
09:03:23 <Saizan> but when you eta-reduce then you have just g, with no arguments, rather than the 2 it expects
09:03:33 <archblob> yes, but it is fully aplied, but somehow beacause of the eta-reduction GHC can't figure that out,
09:03:59 <Saizan> it's not fully applied in the body of f
09:05:08 <archblob> but isn't f = g the same as f k m = g k m assuming that f and g have the same arity?
09:05:42 <Saizan> not to GHC's optimizr
09:05:51 <Saizan> *optimizer
09:06:29 <byorgey> archblob: they are guaranteed to have the same denotational semantics, but not the same operational semantics.
09:06:30 <Saizan> because if it has compiled g as taking two arguments at once, then g alone is a partial application
09:06:55 <osa1> only dependencies for a Haskell executable are those listed in ldd output, right? as far as these are supplied it works
09:07:03 <archblob> ok but shouldn't it be?
09:07:14 <merijn> elliott: Does MonadFix for Supply make sense? No, right?
09:07:53 <Saizan> GHC has to figure out the proper operational arities to make function calls faster
09:07:59 <byorgey> archblob: when you say "should", do you mean (1) you think the behavior you are seeing is a bug with respect to GHC's documented behavior, or (2) it "should" be the case in some moral sense?
09:08:06 <byorgey> I don't know the answer, just trying to clarify
09:08:11 <Saizan> sometimes it's going to be less than optimal about it
09:08:38 <elliott> merijn: um, not sure.
09:09:21 <archblob> i am not a native english speaker and this "moral" sense just confused me
09:09:33 <archblob> :-P
09:09:49 <merijn> elliott: Me neither...I'll leave it as a future issue :p
09:11:50 <byorgey> archblob: sorry
09:12:27 <byorgey> but if you think it is a bug then (2) doesn't matter =)
09:13:12 <archblob> ok, but it is a bug or it is not, i came here to find an answer and clarify my understaning
09:13:41 <Saizan> a similar situation is how let x = f y in (x,x) is denotationally the same as (f y, f y) but they have different performance
09:15:15 <Saizan> archblob: i'm pretty sure it's not a bug
09:17:04 <archblob> Saizan : ok , but can you give me a reason why GHC would not want do do this in the context of eta-reduction ?
09:18:58 <archblob> i don't see how this particular case should have anything to do with semantics
09:19:16 <Saizan> archblob: eta-expanding stuff, like it'd have to do to get a fully applied g, can be a pessimization too
09:20:30 <Saizan> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html <- e.g. in the INLINE example itself, if we eta-expand comp1 we get comp2, which is not the best one for the call below
09:22:50 <c_wraith> I wonder how much it would slow down compilation if GHC made inlineable versions of functions with each possible arity, and just used the correct one whenever it wanted one.
09:23:05 <Saizan> GHC uses the arguments appearing in the source as hints of how you're going to use the function
09:25:18 <Saizan> anyhow you might still want to post on the mailing list to get the opinion of someone more familiar with GHC's optimizer
09:25:55 <archblob> well, thank you guys and i will try to do that for a better understanding
09:26:51 <c_wraith> the really tricky thing, from a compiler standpoint, would be automating stuff like the « f x y = h (g x) y » -> « f x = let expensive = g x in \y -> h expensive y » transformation.  That's one of the most annoying manual optimizations necessary for helping optimize partial application.
09:28:47 <c_wraith> (in that case, optimizing repeated application of a partially applied f to many different second arguments)
09:29:02 <archblob> well, after another reading i think i got my answer "fully applied" means applied to as many arguments as appear (syntactically) on the LHS of the function definition
09:29:19 <archblob> and the important word here is syntactically
09:29:19 <c_wraith> I think GHC actually uses the term "fully saturated" for that
09:29:28 <c_wraith> But yes, it is purely syntactic
09:30:33 <archblob> thank you guys for the conversation
09:30:58 <c_wraith> There are lots of things that GHC could, in theory, optimize better with regards to partial application. But the reason it takes the shortcuts it does is that the fully general solution is *hard*, and the shortcuts are easy, and pretty good if you understand their consequences.
09:32:38 <ocharles> c_wraith: half of the benefit (to me) about functional programming is that I shouldn't have to be aware of consequences. Much like a good database, I should be able to write fairly naive code and have the compiler do the necessary rewriting to produce more efficient code with the same semantics
09:32:46 <ocharles> so I don't entirely buy that argument, even though that's how it is
09:34:10 <elliott> I think a view of FP that is predicated on sufficiently smart compilers is a view bound to disappoint.
09:34:33 <c_wraith> I would cheer if any of the related optimizations made it into GHC.  Or any other theoretically-possible optimization that we currently end up doing by hand, like worker-wrapper transforms.
09:35:02 <c_wraith> But I don't begrudge GHC not having those things.  They're just plain a lot of work.
09:35:43 <luite> hm, GHC does have worker/wrapper transforms, do you mean a specific kind that's not implemented?
09:37:47 <TheLemonMan> hrm, does mallocForeignPtrArray size argument refers to the overall size or does it refer to the number of elements ?
09:38:05 <TheLemonMan> the documentation doesn't say anything about this aspect
09:44:45 <c_wraith> luite: GHC can handle simple cases of worker/wrapper transform.  But andy gill has developed a theoretical framework for much more involved ones.
09:45:09 <merijn> @hoogle (Monad m, Monad f) => m (f (m a)) -> m (f a)
09:45:09 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:45:10 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:45:10 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
09:48:09 <Luke> how can I cast an Integer to an Int?
09:48:27 <Gracenotes> call fromInteger
09:48:49 <merijn> or fromIntegral
09:49:13 <Gracenotes> = fromInteger . toInteger
09:49:15 <Luke> fromIntegral wasn't working for some reason. from (fromInteger.fromIntergral) is
09:49:38 <Gracenotes> wasn't working? what error message did you get...?
09:49:42 <elliott> that's just fromIntegral.
09:50:08 <Luke> oh its' wroking now... musta been some other errors
09:50:13 <Luke> thanks
09:50:18 <Gracenotes> 'fromInteger . fromIntegral' == 'fromInteger . fromInteger . toInteger'
09:50:25 <Gracenotes> on the right hand side, two of those functions are identity :)
09:51:58 <Gracenotes> Luke: yeah, type inference can lead you down voodoo-y paths...
09:52:04 <Gracenotes> especially with typeclasses
09:52:07 <ksf> Am I correct in the assumption that we have about 2^10 parsing libraries, but not a single one that generalises mixfix parsing?
09:52:07 <Luke> yeah =)
09:54:42 <merijn> ksf: Complain to edwardk that his library isn't general enough
09:54:50 <ksf> good idea.
09:55:16 * ksf downloads yet another thesis
09:56:23 <hpaste> heckler0077 pasted “Could not deduce question” at http://paste.tryhaskell.org/90646
09:56:42 <heckler0077> Hi, could someone help explain my problem
09:56:45 <ksf> It's always eerie to read english papers written by germans with proper, but not idiomatic, english.
09:57:04 <Gracenotes> heckler0077: what is your problem?
09:57:25 <Gracenotes> (chances are, it is related to the monomorphism restriction, which is pretty fun)
09:57:40 <heckler0077> The use of my exponentiation function is causing the "Could not deduce (a ~ Double)
09:57:40 <heckler0077>     from the context (Floating a, Ord a)" etc etc error
09:57:52 <heckler0077> I pasted a brief code snippet
09:57:56 <heckler0077> http://paste.tryhaskell.org/90646
09:57:59 <Gracenotes> The issue is that e has type Double, and so expr has type Double -> Double
09:58:03 <Gracenotes> *expe
09:58:13 <Gracenotes> But you apply it to v, which is Floating a
09:58:40 <Gracenotes> also, if that's the only thing in the where clause, you can get rid of the where clause, but I assume it's a simplified testcase
09:58:52 <heckler0077> Yes, it's simplified
09:59:06 <heckler0077> Forgot to remove that part
09:59:19 <Gracenotes> So do you see the issue? You promise to do the thing for any Floating a, but can actually only do it for a = Double.
10:00:22 <heckler0077> Yes, I see that.  How might I get around the problem without changing the typeclasses in the step function then?
10:00:41 <Gracenotes> are the 'e' and 'expe' functions also simplified?
10:00:47 <Gracenotes> @where monomorphismrestriction
10:00:47 <lambdabot> I know nothing about monomorphismrestriction.
10:00:51 <Gracenotes> was worth a shot
10:00:54 <heckler0077> No, I just needed a concise way to perform an e^something operation
10:01:21 <Gracenotes> the 'exp' function already does that... if you replace 'expe' with 'exp', your problem will be solved, as such
10:01:24 <Gracenotes> http://www.haskell.org/haskellwiki/Monomorphism_restriction
10:01:28 <ksf> @where+ monomorphismrestriction Don't ask, just -XNoMonomorphismRestriction
10:01:28 <lambdabot> Good to know.
10:02:07 <Gracenotes> The reason why expe is shoehorned into Double is because e is shoehorned into Double, because a top-level thing taking no arguments is set to the 'default' typeclass wherever possible
10:02:11 <ksf> needs a @faq ; "Just disable it"
10:02:27 <ksf> "Yes! You can just disable it."
10:02:28 <Gracenotes> eh, I'm not a huge fun of littering pragmas all over
10:02:37 <Gracenotes> or flags
10:02:55 <elliott> I don't agree with that entry.
10:03:03 <elliott> you should understand how the DMR works before turning itoff.
10:03:11 <ksf> I'm not going to be arsed into typing the type myself instead of letting ghc+vim insert it just because the restriction is enabled.
10:03:20 <elliott> I've seen major performance problems caused by people who just turned it off without thinking after the first time they ran into it
10:03:40 <Gracenotes> The way to declare 'e' while making it fully general is to give it the explicit type signature 'Floating a => a'. However, this means that it will be recomputed every time you have it anywhere in your program.
10:03:46 <ksf> it should be a warning.
10:04:15 <Gracenotes> You can't have it both ways, making it work for any type (even a potentially insane one) and storing it for free.
10:04:21 <heckler0077> Ok, I'll look into the monomorphism restriction.
10:04:24 <Gracenotes> What do we do with warnings? We ignore them!
10:04:26 <heckler0077> Ahh, that makes sense
10:05:02 <heckler0077> Gracenotes++
10:05:04 <heckler0077> Thank you!
10:05:35 <Gracenotes> sure. lots of fun tradeoffs :)
10:07:56 <dacdave> I have a Haskell app that talks to a PostgreSQL database on a remote server. It is running fine from a windows laptop, but I just rebuilt it on an Ubuntu server with ghc 7.4.1 and it fails with the error: hPutBuf: resource vanished (Broken pipe)  -  Any ideas where to look?
10:09:31 <dacdave> Could it be a problem with the local PostgreSQL client? I am having trouble connecting to the local database with psql, but this code connects to a remote database.
10:11:37 <dacdave> Actually, I just started psql with the -h parameter to dorect it to the remote database, and that works fine. So, I am stuck where to look in my code. Any help?
10:14:50 <dacdave> Sorry, looking more closely at this it appears it may have nothing to do with the database access, since it appears from Hoogle that hPutBuf is about writing to file. My code dos write files in the local directory. Still not sure where to look.
10:15:43 * hackagebot module-management 0.11 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.11 (DavidFox)
10:15:53 <adimit> dacdave: hPutBuf isn't necessarily writing to a file, it could be writing to a socket, or similar.
10:15:59 <adimit> everything that can be a Handle.
10:16:08 <adimit> (which is actually just a pointer IIRC.)
10:16:17 <ksf> dacdave, broken pipe means that the haskell runtime got an error from the operating system regarding the unexpected closing of the connection.
10:16:30 <geekosaur> use strace to see what file descriptor it's using and where it came from?
10:17:27 <adimit> dacdave: what geekosaur said would probably be your best bet. Try to get an idea of the data flowing. Somewhere sometihng vanishes unexpectedly. Then your App tries to write to it, resulting in the error message.
10:18:46 <hpaste> NemesisD pasted “xmonad dupkeys” at http://paste.tryhaskell.org/90647
10:20:27 <dacdave> Never mind. My problem is not the database or creating files - it is sending email from my code. Sorry for the extra traffic.
10:23:05 <ksf> edwardk, your parser library is insufficiently general :)
10:23:19 <ksf> in particular, it doesn't deal with generalised mixfix expressions
10:24:24 <ksf> edwardk_, your parser library is insufficiently general :)
10:24:25 <ksf> in particular, it doesn't deal with generalised mixfix expressions
10:24:37 <elliott> you made him quit
10:24:41 <edwardk> of course not
10:24:52 <edwardk> it is focused on doing what parsec does a little bit better
10:25:04 <edwardk> it also is very char-focused
10:25:33 <ksf> that I noticed, yet. I expected factorial monoids from you.
10:25:40 <ksf> *yes
10:26:00 <edwardk> it was originally designed to be all but haskell 98
10:26:12 <erisco> curiously   instance (Show a) => Foo a b where    and   instance (Show a, Show b) => Foo a b where     conflict
10:26:31 <erisco> so how does one behave differently depending on whether 'b' can be constrained to Show?
10:27:20 <elliott> you can't
10:27:41 <erisco> :( so I have to choose? darn
10:27:52 <ksf> ...not without fixing the types, that is.
10:30:43 <startling> erisco, you can have a wrapping newtype
10:33:10 <tomboy64> okay, i'm out of my depth with that error message:
10:33:13 <tomboy64> isRel :: Int -> Int -> IntMap -> (Bool, IntMap)
10:33:17 <tomboy64> err
10:33:27 <tomboy64> Expecting one more argument to `IntMap'
10:33:29 <tomboy64>     In the type signature for `isRel':
10:33:43 <tomboy64> that is a data constructor
10:33:57 <tomboy64> and the type sig is what i feed it and what i get out
10:34:16 <elliott> it's expecting one more argument to IntMap.
10:34:20 <applicative> IntMap Char , IntMap Int
10:34:22 <elliott> it's (IntMap a), where a is the type of values you're storing in the map.
10:34:33 <tomboy64> -.-
10:34:36 <tomboy64> yay
10:34:44 <tomboy64> *headdesks*
10:34:46 <tomboy64> thank you
10:36:00 <bscarlet> tomboy64: not sure what you meant by "that is a data constructor". In the context you wrote, IntMap is a type constructor.
10:36:37 <tomboy64> erm, sorry, not too sure with haskell vocabulary yet :/
10:37:45 <bscarlet> tomboy64: No need to apologize. When someone asks a question here, it usually helps to get terminology straight; asking questions and confusion like that are a big part of what this channel is for.
10:56:13 <elliott> > lines ""
10:56:14 <lambdabot>   []
10:57:35 <Luke> anyone know how to convert a LocalTime from the time package to an epoch microsecond Int?
11:00:13 <benmachine> Luke: at a guess, you'll need to give a timezone to interpret it in first
11:00:32 <benmachine> Luke: a given local time might refer to a number of different epoch times, depending on which timezone it's in
11:00:35 <benmachine> hence "local"
11:00:42 <Luke> unfortunately I don't have a timezone... the source really just gives it as a local =(
11:01:25 <monochrom> you can build your own TimeZone. it is not abstract.
11:01:39 <benmachine> Luke: well then you don't have a epoch time, but you can guess at one
11:01:48 <Luke> no i mean I don't know what it is
11:02:02 <benmachine> Luke: right, if you don't know what it is then you don't know what epoch time you should get
11:02:09 <Luke> the DST status isn't given for example
11:02:10 <monochrom> it is in the same module as Data.Time.LocalTime
11:02:12 <benmachine> you *have* to provide a timezone otherwise there just isn't an answer
11:02:39 <Luke> benmachine: makes sense. thanks
11:02:41 <benmachine> you could just pretend it was UTC or EST or whatever seems most likely
11:02:54 <benmachine> then use localTimeToUTC
11:02:56 <benmachine> http://hackage.haskell.org/packages/archive/time/1.4.1/doc/html/Data-Time-LocalTime.html
11:03:14 <Luke> thanks
11:03:46 <benmachine> probably leave a comment explaining the situation
11:03:52 <monochrom> is it an XY problem? perhaps you could circumvent LocalTime altogether
11:04:23 <Luke> monochrom: XY?
11:04:46 <monochrom> XY problem means solving the real problem by an indirect route
11:05:21 <monochrom> it is just odd that you have some kind of local time but not some kind of time zone
11:05:25 <Luke> benmachine: what function gives you epoch micros from UTC?
11:05:37 <bel3atar> how do I run a script from the book learn you a haskell ?
11:05:55 <monochrom> it's like me telling you "hi it's 2AM here and I'm not going to tell you what means here!"
11:06:15 <c_wraith> Not every day you find a freaking huge bug in one of bos's libraries!  woo!
11:07:03 <monochrom> bel3atar: some are to be entered into ghci directly, some other are to be saved in a file and then use :load in ghci
11:07:22 <applicative> bel3atar: you can type some of it in the terminal in ghci. the rest put in a file
11:07:23 <applicative> like monochrom says
11:07:27 <benmachine> Luke: oh right, um, try http://hackage.haskell.org/packages/archive/time/1.4.1/doc/html/Data-Time-Clock-POSIX.html
11:07:27 <bel3atar> monochrom: is there a way I could just do ./script.hs ?
11:07:42 <eikke> bel3atar: yes, but that's not very common
11:07:47 <benmachine> c_wraith: :O
11:07:47 <Luke> monochrom: knowing the location isn't enough. you also need to know whether the location was in DST or not to get the correct offset.
11:08:37 <tomboy64> bel3atar: i think there is an interpreter, runghs or something
11:08:40 <applicative> bel3atar: uninterpreted runhaskell script.hs
11:08:40 <applicative> compiled, ghc -O2 script.hs -o myexecutable
11:08:43 <tomboy64> not sure about that
11:08:48 <monochrom> the internet may know DST dates for that location
11:09:00 <eikke> applicative: you most likely want --make as well
11:09:01 <applicative> you should have runhaskell aliasing runghc unless you have hugs aroun
11:09:14 <applicative> eikke: you dont need it anymore
11:09:17 <eikke> oh
11:09:39 <monochrom> bel3atar: most examples in LYAH are meant for entering into ghci, not ./script.hs
11:09:49 <applicative> strangely ..
11:10:04 <applicative> bel3atar: by all means, make script.hs
11:10:37 <applicative> import Data.Char ; main = interact $ map toUpper
11:10:50 <bel3atar> I can't ./ this one http://ix.io/6sV
11:11:07 <bel3atar> Parse error: naked expression at top level
11:11:15 <mauke> well, yes
11:11:24 <monochrom> I give up.
11:11:28 <mauke> you need a 'main' symbol if you want to write a program
11:11:29 <applicative> it's a script, it needs main to do anything
11:11:45 <applicative> its not a script rather, its just a definition
11:17:35 <applicative> bel3atar: you need a line like main = print $ qs [2,31,23]  or main = interact $ unwords . qs . words
11:18:12 <applicative> bel3atar: inside ghci the effect of typing qs [1,2,3] followed by return is to print, in such cases
11:21:50 <bel3atar> applicative: when I do func :: a -> a in ghci it complains
11:24:29 <S_J> isnt tail O(n) ?
11:24:38 <joelteon> no
11:24:41 <joelteon> O(1)
11:24:56 <tromp_> u'r thinking of last
11:24:59 <S_J> can you iterate over a list backwards?
11:25:01 <tac> S_J a "cons" cell is just a head-tail pair
11:25:05 <S_J> ah
11:25:09 <S_J> yes
11:25:13 <tac> S_J: You have to reverse the list to iterate backwards
11:25:26 <tac> > map (+1) $ reverse [1,2,3]
11:25:27 <lambdabot>   [4,3,2]
11:25:35 <benmachine> S_J: if you want to access both ends of a list quickly, you might be interested in Data.Sequence from the containers package
11:29:24 <S_J> unionsWith is a fold?
11:29:30 <S_J> @src unionsWith
11:29:30 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:34:22 <bartavelle> I am encountering what I believe is a GHC bug : I get "No instance for (Pretty Expression) arising from a use of `pretty'", but I have defined this instance in another module that is included
11:34:25 <bartavelle> is that a known gotcha ?
11:34:54 <mauke> yes, ghc doesn't support instances
11:35:13 <roconnor> mauke: huh?
11:35:55 <b_jonas> roconnor: mauke is being ironic
11:35:56 <roconnor> bartavelle: it should work.  I suspect you have made some sort of error.
11:36:02 <roconnor> mauke: not helpful.
11:36:04 <roconnor> mauke--
11:36:14 <bartavelle> I suspect too, but everything compiles and I get no warning other than this error
11:36:17 <magneticduck> QUESTION: RealFloat does NOT need Enum?!?!?! What kind of crazy person would make a sophisticated number type that does not support equality or < >??
11:36:23 <bartavelle> that's why I am asking if this is a known gotcha
11:36:33 <bartavelle> (everything ELSE compiles)
11:36:36 <roconnor> mauke: < belongs to Ord not Enum
11:36:38 <roconnor> er
11:36:40 <mauke> roconnor: seriously, how do you answer "is that a known gotcha?"?
11:36:47 <roconnor> magneticduck:   < belongs to Ord not Enum
11:36:49 <magneticduck> oh, then what's the difference between then again?
11:36:50 <roconnor> mauke: like I did
11:36:52 <bartavelle> mauke : by yes or no I suppose
11:37:03 <mauke> I did say "yes"
11:37:04 <b_jonas> bartavelle: perhaps try to reduce it to a minimal testcase, and if you can still reproduce the error in a small testcase, show all its code to us so we can help
11:37:25 <bartavelle> b_jonas, yeah I suppose that's the only way to go from here, thanks
11:37:29 <tomboy64> i want a graphical debugger
11:37:30 <mauke> roconnor: I feel you didn't answer the question they asked
11:37:37 <tomboy64> with opengl and particles :-}
11:37:42 <roconnor> magneticduck: Enum defines a successor operation and a partial bijection with Int
11:37:51 <b_jonas> magneticduck: try looking Ord and Enum up in the typeclassopedia perhaps
11:38:00 <magneticduck> you see, I'm trying to make an arithmitic sequence via the [n1, n2 .. u] syntax in the context ((RealFloat a) => [a])
11:38:06 <magneticduck> I'd think I would be able to do that
11:38:15 <roconnor> mauke: OTOH, I know that you did not help.
11:38:15 <b_jonas> magneticduck: http://www.haskell.org/haskellwiki/Typeclassopedia
11:38:22 <b_jonas> hmm no
11:38:23 <b_jonas> sorry
11:38:32 <b_jonas> magneticduck: the typeclassopedia doesn't seem to answer this
11:38:33 <mauke> roconnor: that depends on your point of view
11:38:40 <magneticduck> alright, but I still have the problem that I can't make an arithmitic sequence
11:39:23 <b_jonas> magneticduck: perhaps add an Enum instance requirement as well
11:39:28 <roconnor> magneticduck: Enum plays very badly with Floating point.
11:39:41 <bartavelle> ok the gotcha was : Expression was ambiguous, coming from two imports
11:39:47 <b_jonas> yeah, it has somewhat different semantics too than for integers
11:39:52 <magneticduck> > [1, 2 .. 10] :: [Double]
11:39:53 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
11:39:57 <startling> roconnor: which sucks, because there's no reason it has to. :(
11:40:02 <magneticduck> > [1, 2 .. 10] :: [CReal]
11:40:04 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
11:40:11 <roconnor> magneticduck: I often use map (fromRationa) [0.1,0.2 .. 1.0] to workaround
11:40:17 <roconnor> *fromRational
11:40:28 <b_jonas> > ([2,4..9]::[Int],[2,4..9]::[Double])
11:40:30 <lambdabot>   ([2,4,6,8],[2.0,4.0,6.0,8.0,10.0])
11:40:32 <magneticduck> yeah.. there are no RealFloats that aren't Enum, technically
11:40:35 <magneticduck> so....
11:40:44 <magneticduck> maybe somebody should do something about that? ..
11:40:49 <b_jonas> > ([10,20..91]::[Int],[10,20..91]::[Double])
11:40:50 <lambdabot>   ([10,20,30,40,50,60,70,80,90],[10.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0])
11:40:58 <b_jonas> > ([10,20..99]::[Int],[10,20..99]::[Double])
11:40:59 <lambdabot>   ([10,20,30,40,50,60,70,80,90],[10.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0...
11:41:04 <b_jonas> argh
11:41:12 <b_jonas> > ([10,20..89]::[Int],[10,20..89]::[Double])
11:41:13 <lambdabot>   ([10,20,30,40,50,60,70,80],[10.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0])
11:41:26 <magneticduck> mm
11:41:26 <b_jonas> the int one rounds the endpoint down, the float one rounds the endpoint to nearest
11:41:27 <roconnor> magneticduck: I'd like to see Double and Float removed from Enum
11:41:30 <b_jonas> no wait
11:41:42 <b_jonas> the int one rounds the endpoint towards the starting point I think, the float one to nearest
11:41:44 <magneticduck> lol, we have different points of view then; honestly, I don't see what the problem is there
11:41:52 <b_jonas> roconnor: me too, but it's too late
11:42:04 <byorgey> it seems it's time for the weekly #haskell discussion of Enum!
11:42:08 <magneticduck> I think they work the same way; they just keep growing until the element is higher than the range
11:42:12 * byorgey turns off the monitor until it's over
11:42:16 <magneticduck> imo that's a terrible definition ..
11:42:22 <magneticduck> > [0, 0 .. 0]
11:42:23 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:42:27 <roconnor> magneticduck: the problem is when you are successfully adding 0.1 to floating point numbers, because of binary rounding you often do not hit your endpoint exactly, ... so what do you do?
11:42:34 <roconnor> *successively
11:42:43 <mauke> > [0, 0.2 .. 0.5]
11:42:44 <lambdabot>   [0.0,0.2,0.4]
11:43:10 <mauke> > [0, 0.2 .. 0.59]
11:43:11 <lambdabot>   [0.0,0.2,0.4,0.6000000000000001]
11:43:15 <applicative> [0,0.2..0.8]
11:43:23 <magneticduck> this is a problem.
11:43:24 <applicative> > [0,0.2..0.8]
11:43:25 <lambdabot>   [0.0,0.2,0.4,0.6000000000000001,0.8000000000000002]
11:43:28 <magneticduck> let me check my code
11:43:44 <roconnor> magneticduck: when the top of your range is 1.0 but you hit 1.0000000001 due to accumulation of rounding errors, do you include it or not?
11:44:05 <magneticduck> how about using CReal to generate the series and then shifting it back to your own type with realToFrac>
11:44:07 <magneticduck> ?
11:44:17 <magneticduck> or something a bit prettier perhaps; that a kind of slow approach
11:44:17 <benmachine> or better still, Rational
11:44:19 <roconnor> magneticduck: that's what I suggested with map fromRational
11:44:22 <benmachine> because that's, you know, not mad
11:44:24 <magneticduck> yeah, Rational
11:44:27 <benmachine> :P
11:44:27 <haasn> CReal isn't really needed if you just need fractions
11:44:33 <magneticduck> yeah
11:44:37 <b_jonas> > ([10,20..89]::[Int],[10,20..89]::[Rational Int])
11:44:38 <lambdabot>   `GHC.Real.Rational' is applied to too many type arguments
11:44:39 <haasn> overkill, and also keep in mind CReal is really slow
11:44:41 <b_jonas> > ([10,20..89]::[Int],[10,20..89]::[Rational])
11:44:44 <lambdabot>   ([10,20,30,40,50,60,70,80],[10 % 1,20 % 1,30 % 1,40 % 1,50 % 1,60 % 1,70 % ...
11:44:48 <b_jonas> > ([10,20..89]::[Integer],[10,20..89]::[Rational])
11:44:49 <lambdabot>   ([10,20,30,40,50,60,70,80],[10 % 1,20 % 1,30 % 1,40 % 1,50 % 1,60 % 1,70 % ...
11:44:50 <magneticduck> I just fell in love with the fact that ((sqrt 2 :: CReal) ^ 2) == 2 a while ago
11:44:53 <b_jonas> damn, line too long
11:44:53 <roconnor> so Double and Float should be removed from Enum and force everyone to use map fromRational :)
11:45:00 <haasn> magneticduck: that's misleading
11:45:00 <b_jonas> > ([10,20..39]::[Integer],[10,20..39]::[Rational])
11:45:01 <lambdabot>   ([10,20,30],[10 % 1,20 % 1,30 % 1,40 % 1])
11:45:07 <benmachine> magneticduck: uhm. that's only because CReal equality lies
11:45:07 <magneticduck> and now I suggest using CReal for everything from cleaning the deck to making an arithmitic series
11:45:09 <haasn> magneticduck: they're only equal up to 40 digits, as far as CReal is concerned
11:45:14 <haasn> it just stops checking after that
11:45:20 <roconnor> magneticduck: don't get too cosy.  the (==) for CReal is a lie.
11:45:24 <benmachine> magneticduck: check out the cyclotomic package, though
11:45:30 <magneticduck> yeah, that's another probem
11:45:31 <haasn> > (0 :: CReal) == 10^^(-100)
11:45:32 <lambdabot>   True
11:45:34 <b_jonas> it's not just a matter of precision. the definitions differ. it's the same member function of Enum meaning different things for integer and floating point
11:45:43 <applicative> haasn if you adjust the crucial number from 40 to 400, its the same
11:45:57 <magneticduck> somebody needs to make a quasi-algebraic type that handles stuff like that, and doesn't use an infinite series
11:46:12 <benmachine> magneticduck: http://hackage.haskell.org/package/cyclotomic
11:46:21 <magneticduck> mm, I was suprised it hasn't been done before
11:46:26 <magneticduck> I guess it has
11:46:32 <applicative> with == you exit the CReal system, as with show
11:46:33 <benmachine> cyclotomic doesn't get you everything
11:46:41 <benmachine> but it's an impressive start
11:46:53 <magneticduck> very cool
11:47:02 <magneticduck> meet Cyclotomic: my new favorite Number type
11:47:05 <magneticduck> xl
11:47:22 <magneticduck> alright, then fromIntegral it is, thanks guys
11:49:36 <roconnor> CReal's show should produce infinite strings requiring the user to do a take :->
11:50:00 <applicative> that would be much more amusing
11:50:13 <benmachine> agreed
11:50:17 <benmachine> well
11:50:18 <benmachine> no
11:50:19 <benmachine> well
11:50:21 <benmachine> maybe
11:50:24 <roconnor> heh
11:50:38 <benmachine> it goes wrong when you start thinking about Maybe CReal and (CReal, String)
11:51:18 <applicative> cyclotomic needs updates
11:51:32 <djahandarie> Hmm, I want a tuple where (x, y) == (y, x), does this have a name?
11:51:35 <roconnor> applicative: any hackage user can update cyclotomic
11:51:56 <erisco> djahandarie, reflective?
11:52:02 <roconnor> djahandarie: I think there was a blog post about how to derive such a type generically
11:52:07 <roconnor> erisco: symmetric
11:52:11 <Taneb> Unordered?
11:52:20 <haasn> unordered tuple
11:52:27 <roconnor> djahandarie: but it wouldn't be generic.
11:52:28 <erisco> roconnor, that depends on interpretation... not sure what was meant :)
11:53:29 <djahandarie> Is it possible to have a sane Ord instance for unordered tuples?
11:53:44 <benmachine> roconnor: I'm not sure I /recommend/ just uploading whatever to Hackage on a whim
11:54:01 <roconnor> benmachine: well, not on a whim
11:54:16 <roconnor> djahandarie: I don't know about sane.
11:54:52 <benmachine> djahandarie: so, observation: if you want an Ord instance, the underlying set must be ordered
11:55:08 <benmachine> in which case unordered tuples can be modelled as (a,b) where a < b
11:55:14 <benmachine> ≤, I mean
11:55:21 <djahandarie> Yeah. That was my thought.
11:55:26 <djahandarie> Now, does this already exist in a package? :P
12:00:34 * applicative likes this cyclotomic thing
12:02:36 <Luke> benmachine: how do I go from a NominalDiffTime to Int or Int64?
12:02:50 <benmachine> Luke: probably using the instance of the Integral typeclass
12:02:55 <benmachine> fromIntegral, perhaps
12:02:58 <Luke> ah
12:03:00 <Luke> nice
12:03:02 <Luke> thanks
12:03:06 <benmachine> that's just from memory, so I might be wrong
12:03:52 <monochrom> it is fractional. floor or ceiling.
12:04:00 <monochrom> or trunc or round
12:04:01 <benmachine> oh, fair enough
12:04:14 <roconnor> benmachine: I think round
12:04:21 <roconnor> oh monochrom said it already
12:04:42 <Gracenotes> number type conversions really aren't that great
12:05:03 <roconnor> Gracenotes: how so?
12:05:05 <monochrom> "have just convert 1 way when you can convert 4 different ways!"
12:05:09 <Gracenotes> they exist, which is good, but are about as ad-hoc as the typeclasses that are used to organize them.
12:05:15 <byorgey> djahandarie: just curious, what do you want unordered tuples for?
12:05:31 <byorgey> I'm collecting examples of places where one would want such things
12:05:39 <monochrom> also, I can never remember whether it's ceil or ceiling
12:05:56 * hackagebot snap-predicates 0.3.1 - Declarative routing for Snap.  http://hackage.haskell.org/package/snap-predicates-0.3.1 (ToralfWittner)
12:12:04 <CaptainK> what function does this? ["HELLO"] to ["H","E","L","L,"O"]
12:12:12 <mauke> map (: [])
12:12:16 <mauke> hmm, no
12:12:26 <mauke> map (map (: []))
12:12:55 <CaptainK> > map (map (:[])) ["HELLO"]
12:12:56 <lambdabot>   can't find file: L.hs
12:13:04 <roconnor> > map (map return) ["HELLO"]
12:13:05 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Char))
12:13:06 <lambdabot>    arising from a use o...
12:13:07 <byorgey> map map ROBOT
12:13:18 <mauke> > transpose ["HELLO"]
12:13:19 <lambdabot>   ["H","E","L","L","O"]
12:13:25 <roconnor> mauke: ouch
12:13:26 <byorgey> mauke++
12:13:27 <CaptainK> ah thats the one
12:13:38 <aristid> :t ((return <$>) <$>)
12:13:39 <lambdabot> (Monad m, Functor f, Functor f1) => f (f1 a) -> f (f1 (m a))
12:13:43 <roconnor> > map (map return) ["HELLO"] :: [String]
12:13:44 <lambdabot>   Couldn't match type `m0 GHC.Types.Char' with `GHC.Types.Char'
12:13:44 <lambdabot>  Expected typ...
12:13:53 <CaptainK> > concat ["H","E","L","L","O"]
12:13:54 <lambdabot>   "HELLO"
12:14:02 <CaptainK> ok, gtk
12:14:06 <CaptainK> thanks!
12:14:58 <roconnor> CaptainK: what is supposed to happen to ["HELLO","WORLD"]?
12:15:17 <CaptainK> whatever you want?
12:15:42 <mauke> > const ["H","E","L","L","O"] ["HELLO"]
12:15:43 <lambdabot>   ["H","E","L","L","O"]
12:15:56 <roconnor> CaptainK: ... I have the feeling something is wrong with your data types
12:16:11 <benmachine> :t let f ["HELLO"] = ["H","E","L","L","O"]; f _ = repeat "BZORK" in f
12:16:11 <lambdabot> [[Char]] -> [[Char]]
12:16:24 <CaptainK> what module do I have to import for "transpose", my GHCi Prelude doesn't find it?
12:16:34 <c_wraith> Data.List
12:16:40 <roconnor> @index transpose
12:16:40 <lambdabot> Data.List
12:16:41 <CaptainK> ah ok,
12:17:13 <byorgey> > let f ["HELLO"] = ["H","E","L","L","O"]; f _ = repeat "BZORK" in   f ["HELLO", "WORLD"]
12:17:14 <lambdabot>   ["BZORK","BZORK","BZORK","BZORK","BZORK","BZORK","BZORK","BZORK","BZORK","B...
12:17:17 <byorgey> seems reasonable
12:17:21 <roconnor> byorgey: ship it
12:18:16 <CaptainK> @index
12:18:16 <lambdabot> bzzt
12:18:20 <CaptainK> :P
12:22:50 <CaptainK> > map (map (:[])) ["HELLO"]
12:22:51 <lambdabot>   [["H","E","L","L","O"]]
12:23:16 <CaptainK> how do I get rid of the extra "[ ]" ?
12:23:30 <Clint> > map return "HELLO" :: [String]
12:23:31 <lambdabot>   ["H","E","L","L","O"]
12:23:43 <byorgey> Clint: concat
12:23:45 <tac> > join [[]]
12:23:45 <CaptainK> thats nice to read too
12:23:46 <lambdabot>   []
12:23:47 <roconnor> > (map return) =<< ["HELLO"] :: [String]
12:23:48 <lambdabot>   ["H","E","L","L","O"]
12:23:49 <byorgey> er, CaptainK
12:24:03 <tac> You know you've been doing category too long when "join" seems more natural than concat....
12:24:09 <benmachine> μ
12:24:21 <josephle> tac: is that a problem?
12:24:25 <tdammers> > concat $ map (map (:[])) ["HELLO"]
12:24:26 <lambdabot>   ["H","E","L","L","O"]
12:24:32 <tdammers> > headSafe $ map (map (:[])) ["HELLO"]
12:24:33 <lambdabot>   Not in scope: `headSafe'
12:24:37 <tdammers> > head $ map (map (:[])) ["HELLO"]
12:24:38 <lambdabot>   ["H","E","L","L","O"]
12:24:41 <roconnor> concat $ map ... why not concatMap
12:24:46 <Hafydd> > concatMap (map return) ["hello"]
12:24:47 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Char))
12:24:47 <lambdabot>    arising from a use o...
12:24:52 <tdammers> > concatMap (map (:[])) ["HELLO"] -- sure
12:24:52 <lambdabot>   ["H","E","L","L","O"]
12:24:56 <Hafydd> > concatMap (map return) ["hello"] :: [String]
12:24:57 <lambdabot>   ["h","e","l","l","o"]
12:25:45 <Hafydd> But really, why do you want this?
12:25:58 <Hafydd> If your data is only ever going to be a single value in a list, don't use a list.
12:26:44 <tdammers> > concatMap (map (:[])) ["HELLO", "WORLD"] -- maybe this is more realistic?
12:26:45 <lambdabot>   ["H","E","L","L","O","W","O","R","L","D"]
12:27:28 <CaptainK> doesn't haskell store ["HELLO"] as ['H','E','L','L','O'] ?
12:27:39 <Hafydd> No,
12:27:45 <tdammers> CaptainK: well, "store" is maybe the wrong word
12:27:47 <byorgey> CaptainK: no, it stores it as [['H','E','L','L','O']]
12:27:53 <merijn> CaptainK: No, you have a list with a String in it
12:28:06 <tdammers> "HELLO" is the same as ['H', 'E', 'L', 'L', 'O'] though
12:28:11 <merijn> CaptainK: A String is a list of characters, however, you have [String]
12:28:19 <tdammers> > ['H', 'E', 'L', 'L', 'O']
12:28:20 <lambdabot>   "HELLO"
12:28:39 <merijn> > [['H', 'E', 'L', 'L', 'O']]
12:28:40 <lambdabot>   ["HELLO"]
12:28:45 <Hafydd> > "HELLO", ['H','E','L','L','O'], 'H':'E':'L':'L':'O':[]
12:28:46 <lambdabot>   <hint>:1:8: parse error on input `,'
12:28:48 <applicative> (:) 'H' ((:) 'E' ((:) 'L' ... is more like it
12:28:49 <merijn> Notice the difference
12:28:52 <Hafydd> > ("HELLO", ['H','E','L','L','O'], 'H':'E':'L':'L':'O':[])
12:28:53 <lambdabot>   ("HELLO","HELLO","HELLO")
12:28:54 <S_J>  lets say i have a map like this: ("is",fromList [("a",1),("hello",2)]) so i want to calculate the probability of the words that come after "is" so it should ne ("is",fromList[("a", 0.33),("hello",0.67)]). easy way?`
12:30:46 <byorgey> S_J: first, compute the sum of the values using functions like  elems, snd, and sum.  Then, divide every number in the map by the sum using fmap.
12:31:05 <carter> what are the different algebra type class libs on hackage?
12:31:56 <applicative> carter: my impression was that everyone interested made his or her own
12:32:24 <carter> applicative well, unless theres one that makes sense, i need to use my own
12:32:35 <benmachine> carter: what do you want precisely?
12:32:42 <benmachine> carter: "algebra" covers quite a lot
12:32:42 <carter> benmachine rings and things
12:32:46 <benmachine> ah
12:32:52 <carter> eg http://hackage.haskell.org/package/algebra might be ok, if it fits
12:33:01 <carter> but for writing the numerical stuff i'm doing right now
12:33:12 <carter> i'm hitting the point where the standard type clases mean i can't write nice things
12:33:16 <carter> and have them be extensible
12:33:17 <applicative> well a left right backward iso semi ... is a left iso semi iso with a zero
12:33:25 <applicative> so I'll make a new type class. ....
12:33:36 <carter> eg: you can't define the L2  norm over rational vectors
12:33:47 <carter> only Rational vectors with some approximation parameter
12:34:06 <benmachine> ...what do you mean by L2 norm?
12:34:13 <applicative> my impression is they end up with a gruesome pile of type class extensions
12:34:17 <carter> square root of the sum of squares
12:34:20 <carter> applicative thats ok
12:34:27 <benmachine> carter: oh, fair enough
12:34:38 * benmachine usually calls that "euclidean norm" or l_2
12:34:43 <benmachine> or l^2, I forget
12:34:43 <carter> hehe
12:34:47 <carter> all good
12:34:56 <benmachine> \ell_2 possibly
12:35:05 <carter> if you have a version of the paramters equiped with a "epislon"
12:35:13 <carter> you can define a square root function then
12:35:25 <carter> a version of rationals equipped with an epsilon
12:35:32 <benmachine> carter: representing square roots is kind of hard in general, isn't it?
12:35:43 <carter> benmachine only if you want it exactly
12:35:48 <benmachine> right
12:35:50 <applicative> oh i see, edwardk has one to rule them all.  I remember one had tons of quick check propositions associated with each class, that you could run with your instance
12:35:56 <benmachine> but approximations are faff :P
12:36:10 <carter> benmachine not really, if you dig into defining this stuff
12:36:14 <carter> float actually is pretty good
12:36:33 <applicative> that is, the point wasnt to define a hierarchy, but associated tests on instances
12:36:33 <carter> because you have a notion of "representable number closest to true answr"
12:36:59 <benmachine> carter: but you tend to not have (sqrt x)^2 == x
12:37:06 <carter> benmachine thats ok
12:37:13 <benmachine> for you, maybe :P
12:37:24 <carter> your measurements in your input are wrong anyways
12:37:33 <carter> so as long as you have numerical stability its all ok
12:37:41 <CaptainK> map map
12:38:08 <carter> benmachine so some solve algorithms require being able to scale things by l2 norm
12:38:11 <carter> *solver
12:38:14 <carter> but others dont
12:38:27 <carter> the latter i can provide algs that work for rationals
12:38:29 <carter> former i cant
12:38:40 <applicative> google thinks the haddocks for the algebra package are in Spanish "Would you like to translate it?"
12:39:10 <carter> heheh
12:39:19 <mauke> click "yes"
12:39:43 <carter> lets see what happenes :)
12:40:04 <applicative> hm, it seems just to be the word 'Monoidal'
12:40:11 <applicative> with translation lower-cases??
12:40:19 <applicative> http://hackage.haskell.org/packages/archive/algebra/3.1/doc/html/Numeric-Decidable-Zero.html
12:40:48 <applicative> and Word8 it uppercases.  Nice work google.
12:41:38 <applicative> somewhere I saw mention of how translate.google makes amusing mincemeat of Lorem Ipsum
12:41:42 <applicative> why not Haskell?
12:43:17 <S_J> > fromIntegral 5
12:43:18 <lambdabot>   5
12:43:28 <S_J> > (fromIntegral 5) / 2.0
12:43:29 <lambdabot>   2.5
12:43:35 <dropdrive> In emacs with haskell-mode, when I call inferior-haskell-type with my cursor here: p = lif[]tA3 foo bar baz , all I get is the "generic" type of liftA3 (i.e. same as from Hoogle), not the type of liftA3 as used in my code.  Is this possible?
12:44:00 <S_J> why does that not work in ghci?
12:44:12 <Cale> S_J: it does
12:44:14 <applicative> that would a little harder
12:44:40 <applicative> is haskell-mode that fancy??
12:44:44 <byorgey> dropdrive: that sounds very difficult
12:45:02 <byorgey> dropdrive: inferior-haskell-type just calls  :t liftA3  in a ghci process, that's all
12:45:03 <elliott> I think the ghc-mod type things can do that
12:45:09 <elliott> not sure
12:45:10 <byorgey> can it?
12:45:26 <geekosaur> S_J, if you're having issues with it in ghci, I'll guess that you are not directly doing that but using a local binding that trips over the monomorphism restriction
12:45:30 <applicative> oh I have *that* feature in my much more moronic editor
12:45:40 <dropdrive> byorgey: Okay, thanks.  I was also wondering about: p = liftA3 foo bar baz ... where foo a b = ...   and I wanted to see the type of foo.
12:45:44 <byorgey> ah, maybe so, ghc-mod actually wraps the GHC API
12:46:01 <byorgey> dropdrive: yeah, that's not really possible
12:46:16 <dropdrive> byorgey: Okay :)
12:46:19 <byorgey> dropdrive: as a cheat, however, you can put  foo :: (); foo a b = ...   and then inspect the error message =)
12:46:21 <CaptainK> >how do you pluck just a letter ["HELLO"]? say H or E?
12:46:38 <dropdrive> byorgey: Smart, thanks.
12:46:38 <benmachine> CaptainK: chosen on what basis?
12:46:39 <CaptainK> have to map first then use !!
12:46:40 <applicative> you can do various things dropdrive oh like byorgey says
12:47:02 <applicative> you can also make liftA3 a parameter in suitable cases ...
12:47:10 <benmachine> CaptainK: I've still never understood why you're using a singleton list containing a string
12:47:10 <CaptainK> Just want to pick a letter from a word in numerical order
12:47:48 <CaptainK> well its coming from dictionary words so that is how they get read in
12:48:15 <CaptainK> Then I wan to compare letters
12:48:41 <applicative> dropdrive: I meant in that case, comment out foo, and make foo an argument
12:48:45 <benmachine> CaptainK: ok so what is the type of the operation you want?
12:48:58 <CaptainK> so does ["H"] from ["HELLO"] match ["HOPE"]'s first letter?
12:49:20 <dropdrive> applicative: I see.
12:49:26 <CaptainK> compare the letters of different words
12:49:46 <benmachine> CaptainK: I mean type like String -> Int -> Char or whatever
12:50:03 <applicative> dropdrive: theres also some way to use the ghci debugging machinery to figure out such things
12:50:07 <CaptainK> Char to Char from a String to String
12:50:13 <Cale> CaptainK: Is there a reason you're working with one-element lists rather than Strings directly?
12:50:39 <CaptainK> In logic yes, but I can convert it now that I'm done
12:51:16 <CaptainK> should be using putChar or something
12:51:23 <chrisdone> benmachine: elliott: did you build hpaste?
12:51:46 <benmachine> chrisdone: haven't tried since you fixed it
12:51:55 <Cale> CaptainK: I mean, you're referring to ["HELLO"] instead of "HELLO"
12:51:59 <CaptainK> so take ["hello"] and compare the first character to ["test"] do they match? no, so move onto next
12:52:04 <elliott> chrisdone: didn't get around to it, sorry; have been lambdabot-hacking today -- perhaps later
12:52:13 <Cale> The first element of ["hello"] is "hello"
12:52:20 <Cale> The first element of "hello" is 'h'
12:52:24 <CaptainK> because the [] are words cycling through
12:52:29 <chrisdone> benmachine: http://2.bp.blogspot.com/-4m-3C6IUMMk/TjE6WZnnroI/AAAAAAAAAXE/y4cDCdHkYaw/s1600/EE6Hb.jpg
12:52:34 <chrisdone> benmachine: http://i45.tinypic.com/2rxazwx.jpg
12:52:44 <chrisdone> benmachine: i'll be watching you
12:52:44 <S_J> is there syntax for writing computations from left to right? do A --> do B with result from do A etc ?
12:52:48 <CaptainK> ah ok
12:52:54 <benmachine> chrisdone: noted
12:53:21 <acube> S_J: maybe you're searching for sequence [A,B]
12:53:23 <chrisdone> elliott: mmk
12:53:32 <acube> > sequence [Just 3, Just 4]
12:53:33 <lambdabot>   Just [3,4]
12:53:35 <Cale> S_J: depends on what type of computations you're talking about?
12:53:40 <acube> > sequence [Just 3, Nothing]
12:53:41 <lambdabot>   Nothing
12:53:58 <benmachine> chrisdone: is there a particular reason you were asking about sandboxes before? can I just cabal install?
12:54:12 <CaptainK> Cale: would prefer to work with "hello"
12:55:04 <chrisdone> benmachine: you should be able to just cabal install
12:55:18 <CaptainK> how can you change ["HELLO"] to ('h','e','l','l','o')?
12:55:38 <chrisdone> benmachine: some (i.e. me) tend not to cabal install anything outside of a sandbox =)
12:55:40 <Cale> CaptainK: You really want a tuple?
12:56:10 <tac> tuples are nice sometimes
12:56:14 <CaptainK> well all I need to do is a fst and snd on it then, but I can work with what is best
12:56:15 <CaptainK> :P
12:56:21 <tac> CaptainK: In Haskell, there's no good way to do that
12:56:23 <Cale> fst only works on pairs
12:56:30 <tac> You need to know the length of the tuple up front
12:56:32 <Cale> :t fst
12:56:33 <lambdabot> (a, b) -> a
12:56:36 <Cale> :t snd
12:56:36 <S_J> [("is",fromList [("a",1),("hello",2)]),("it",fromList [("is",1)]),("there",fromList [("is",1)])]. I find this a bi hjard. I want to divide each nuimber with the total number for each Map. so for "is" I want "a"->1 + "hello"->2 = 3. then divide 1/3=0.33 and 2/3=0.67 and store that instead of the nbr 1 and 2
12:56:37 <lambdabot> (a, b) -> b
12:56:52 <CaptainK> indeed
12:57:11 <tac> > let to5Tuple [a,b,c,d,e,f] = (a,b,c,d,e,f) in to5Tuple "Hello"
12:57:11 <lambdabot>   *Exception: <interactive>:3:5-42: Non-exhaustive patterns in function to5Tu...
12:57:15 * CaptainK hacks into haskell home page to change fst behavior
12:57:26 <tac> > let to5Tuple [a,b,c,d,e] = (a,b,c,d,e) in to5Tuple "Hello"
12:57:27 <lambdabot>   ('H','e','l','l','o')
12:57:38 <Cale> CaptainK: What would you replace it with?
12:57:58 <CaptainK> ah ok....that I can use ...looking
12:58:16 <Cale> CaptainK: Actually, you probably can't (or shouldn't) use tac's code here.
12:58:24 <chrisdone> Cale: with ghc's type nats, and associated types, you could have a generic index lookup that works on tuples?
12:58:39 <Cale> Tuples are almost certainly the wrong type for what it sounds like you're doing.
12:58:55 <tac> (right, don't use that code because tuples aren't what you want for this job)
12:59:06 <benmachine> chrisdone: such things tend to not work quite as well as you thought they were going to :P
12:59:11 <chrisdone> i.e. if we could have: 1 :: 1 and 2 :: 2, etc
12:59:23 <S_J> hello
12:59:34 <acube> chrisdone: we have that, don't we?
12:59:48 <chrisdone> i'm pretty sure one based on Z/Succ would work
12:59:51 <chrisdone> acube: we do?
13:00:10 <CaptainK> ok, so I only need to compare the first two characters of words.
13:01:08 <CaptainK> > letter= ["HELLO"]  !! 0
13:01:09 <lambdabot>   <hint>:1:7: parse error on input `='
13:01:18 <acube> oh right, we only have 1 :: Nat
13:01:25 <chrisdone> right =(
13:01:35 <chrisdone> but we do have "foo" :: Thingie "foo"
13:01:41 <acube> What would 1 :: 1 get you?
13:01:43 <chrisdone> where Thingie is some name in the GHC module that i can't remember
13:02:07 <chrisdone> acube: well then you could specify different types for every natural number
13:02:36 <Cale> S_J: map (\(s,m) -> let total = sum (Map.elems m) in (s,Map.map (/total) m)) [("is",fromList [("a",1),("hello",2)]),("it",fromList [("is",1)]),("there",fromList [("is",1)])]
13:02:46 <chrisdone> ah wait, we DO have it, it seems
13:03:07 <acube> yes, I can write :kind! Test 1
13:03:12 <acube> :: *
13:03:41 <chrisdone> reading the DataKinds docs now
13:03:45 <acube> and we have "foo" :: Symbol
13:04:20 <chrisdone> ah, yeah, that's it
13:05:06 <acube> chrisdone: just do :k "foo" in GHCi :P
13:05:07 <chrisdone> so Symbol is a kind, "foo" is a type, and also "x" is a value of type "x" of kind Symbol. or something. i never upgraded to ghc 7.6 because we don't use it at work
13:05:37 <S_J> ("hello",fromList [("is",2),("it",1),("world",1)]). how can I update the nbrs so instead reach number is the nbr divided by 4?
13:05:38 <acube> chrisdone: there are no values of kind other than *
13:05:53 <chrisdone> acube: i didn't say values of kind?
13:06:08 <acube> ehm, I mean values of types other than kind *
13:06:11 <benmachine> chrisdone: Could not find module `Hpaste.Types.Announcer' in src/Main.hs
13:06:15 <acube> of kind ... :P
13:06:24 <chrisdone> acube: i didn't say values of types? i meant "x" is a type of kind Symbol
13:06:30 <Botje> S_J: look at the Data.Map documentation, search for map.
13:06:44 <Cale> S_J: Did you look at my line?
13:06:46 <acube> chrisdone: ok, were did the values come into play then? :P
13:06:54 <Cale> S_J: I gave you a piece of code to do that
13:06:55 <chrisdone> benmachine: ah, looks like the cabal file isn't complete
13:07:02 <benmachine> mm
13:07:25 <benmachine> oh, yeah
13:07:31 <benmachine> you need Other-modules
13:07:36 <chrisdone> acube: hm?  With -XDataKinds, GHC automatically promotes every suitable datatype to be a kind, and its (value) constructors to be type constructors
13:07:39 <benmachine> otherwise cabal doesn't know what to package
13:07:46 <benmachine> because regrettably ghc --make doesn't tell it
13:07:48 <benmachine> (yet)
13:07:53 <chrisdone> benmachine: ja, i know how it works, just forgot to do it, hold up
13:08:00 <benmachine> cool
13:08:17 <Cale> > map (\(s,m) -> let total = sum (M.elems m) in (s,M.map (/total) m)) [("is",M.fromList [("a",1),("hello",2)]),("it",M.fromList [("is",1)]),("there",M.fromList [("is",1)])]
13:08:18 <lambdabot>   [("is",fromList [("a",0.3333333333333333),("hello",0.6666666666666666)]),("...
13:08:33 <acube> chrisdone: yes, if you only mean that it's right ... I still need to learn DataKinds, it's nearly the only extension that I haven't really used yet
13:09:09 <merijn> acube: Combine with TypeFamilies and GADTs for maximum enjoyment
13:09:21 <Cale> > (\(s,m) -> let total = sum (M.elems m) in (s,M.map (/total) m)) ("hello",fromList [("is",2),("it",1),("world",1)])
13:09:22 <lambdabot>   Not in scope: `fromList'
13:09:22 <lambdabot>  Perhaps you meant one of these:
13:09:22 <lambdabot>    `IM.fromList' ...
13:09:25 <Cale> oops
13:09:30 <Cale> > (\(s,m) -> let total = sum (M.elems m) in (s,M.map (/total) m)) ("hello",M.fromList [("is",2),("it",1),("world",1)])
13:09:31 <lambdabot>   ("hello",fromList [("is",0.5),("it",0.25),("world",0.25)])
13:09:58 <chrisdone> acube: but there's also promotion, which means the value you put also gives you a type: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html so you an have a value like "foo" and its type will be "foo", and same for Nat: you can have, er, Ze or Su Ze and its type will be that. didn't play with it much. but it's sweet stuff
13:10:12 <Cale> S_J: If you want, I can explain how that code works.
13:11:17 <Cale> S_J: but it's pretty straightforward -- we define total to be the sum of the elements of the Map m, and then use M.map to apply the function (/ total) to all the elements, which divides them by that total.
13:12:58 <jonkri> why do i have to use >>= with nullDir in `msum [ method GET >> nullDir >>= \_ -> ok $ toResponse "" ]'. if i try to use >>, i get an error saying `No instances for (MonadPlus ((->) Response), ServerMonad ((->) Response)) arising from a use of `nullDir''. (nullDir :: (ServerMonad m, MonadPlus m) => m ())
13:13:28 <chrisdone> benmachine: uploading now
13:13:55 <Botje> jonkri: random guess: the $ parses wrongly.
13:13:58 <chrisdone> benmachine: uploaded
13:14:07 <Botje> try method GET >> nullDir >> ok (toResponse "")
13:14:08 <benmachine> chrisdone: updating
13:14:56 <jonkri> Botje: thanks :) what a coincidence that i saw you in #perl earlier :>
13:15:00 <benmachine> chrisdone: compiling :O
13:15:14 <benmachine> chrisdone: installing
13:15:21 <S_J> > map ( \(s, m) -> let total = fromIntegral $ sum (M.elems m) in (s, M.map (/total) m) ) [("is",M.fromList [("a",1),("hello",2)]),("it",M.fromList [("is",1)]),("there",M.fromList [("is",1)])]
13:15:22 <lambdabot>   No instance for (GHC.Show.Show b0)
13:15:23 <lambdabot>    arising from a use of `M1298626281.sh...
13:15:30 <chrisdone> benmachine: yaaay
13:15:34 <benmachine> $ hpaste
13:15:34 <benmachine> hpaste: user error (Pattern match failure in do expression at src/Main.hs:35:3-9)
13:15:40 <chrisdone> benmachine: READ README
13:15:41 <chrisdone> =p
13:15:47 <benmachine> the README wasn't installed :P
13:15:48 <benmachine> $ hpaste --help
13:15:48 <benmachine> hpaste: --help: openFile: does not exist (No such file or directory)
13:15:57 * hackagebot hpaste 1.2.0 - Haskell paste web site.  http://hackage.haskell.org/package/hpaste-1.2.0 (ChrisDone)
13:16:02 <jonkri> Botje: removing the $ made it work
13:16:03 <benmachine> luckily I have it anyway
13:16:17 <chrisdone> benmachine: i might have to give you a sample config. there's a hpaste.conf, but it could be out of date
13:16:22 <chrisdone> sec i'll paste
13:16:27 <Botje> jonkri: I think it parsed as  (method GET >> nullDir >> ok) (toResponse "") otherwise.
13:16:44 <benmachine> chrisdone: hold on, might not be worth bothering if I haven't got postgres
13:16:49 <chrisdone> ah
13:16:54 <S_J> whats up with hpaste
13:17:01 <benmachine> chrisdone: well, I could set it up but that's an after-dinner job :P
13:17:12 <chrisdone> you're always eating dinner!
13:17:28 <S_J> http://ideone.com/f6gaM9 GAh!
13:17:29 <chrisdone> benmachine: that's good that it compiles though. thanks =)
13:17:35 <monochrom> jonkri: you could also, you know, a >> b >> (c $ f x)
13:17:36 <benmachine> chrisdone: nah, I'm always saying I'm about to eat dinner
13:17:38 <benmachine> and then carrying on hacking
13:17:39 <chrisdone> @where hpaste
13:17:39 <lambdabot> http://paste.tryhaskell.org/new/haskell
13:17:46 <benmachine> and then saying it again in two hours' time when I still haven't :P
13:18:01 <chrisdone> benmachine: yeah, last night it was more like 8ish
13:18:07 <chrisdone> i'm on to you. bewatchingyou.jpg etc
13:18:16 <jonkri> monochrom: thanks :)
13:18:35 <benmachine> my kitchen where I'm staying atm is crappy so cooking is kind of a chore
13:18:37 <chrisdone> so i'm not sure what's happening with the paste.haskell.org domain either
13:18:46 <monochrom> the irony of using $ to force more parentheses
13:18:47 <chrisdone> seems i'm just waiting for everybody these days :<
13:18:49 * benmachine gets to it anyway
13:19:00 <hpaste> Yoda pasted “Fractional Integer insanity1” at http://paste.tryhaskell.org/90651
13:19:08 <S_J> Cale ^^
13:20:08 <Cale> S_J: (/) doesn't work on Integer values, you have to convert them to another numeric type using fromIntegral
13:20:21 <nabilhassein> in quickcheck (or, if applicable, another testing framework such as HUnit), is there any way to perform a check analogous to that run by (==>), but testing pattern matching success rather than the truth of a predicate?
13:20:25 <S_J> i tried but got another error
13:20:53 <Cale> S_J: (Fractional b, Integral b) isn't a constraint which is satisfied by any standard type b
13:21:03 <Cale> (probably shouldn't be satisfied by any types at all)
13:21:12 <S_J> probabilities freqList = map ( \(s, m) -> let total = fromIntegral $ sum (M.elems m) in (s, M.map (\x -> (fromIntegral x) / total) m) ) freqList
13:21:25 <S_J> still error
13:21:29 <byorgey> nabilhassein: no, you just have to make a function like  matches (Foo (Bar _)) = True; matches _ = False
13:21:31 <Cale> Well, what error?
13:22:07 <nabilhassein> byorgey: ah. thanks yet again! i've barely started my project and i'm already deep in your debt
13:22:29 <byorgey> nabilhassein: just repay it to someone else later =)
13:22:53 <tomboy64> -.-
13:22:56 <tomboy64> finally
13:23:01 <tomboy64> my program runs
13:23:11 <byorgey> tomboy64: congrats =)
13:23:16 <tomboy64> just sad it produces utter garbage :}
13:25:30 <CaptainK> let words2letters [a,b,_,_,_] = (a,b) in words2letters "HELLO"
13:25:54 <CaptainK> Why does this work in GHCi but not .hs?  even using let
13:26:37 <CaptainK> > let words2letters [a,b,_,_,_] = (a,b) in words2letters "HELLO"
13:26:38 <lambdabot>   ('H','E')
13:26:39 <byorgey> CaptainK: because you type expressions at the GHCi prompt, and declarations in an .hs file.  You cannot just write a bare expression in an .hs file.
13:27:05 <CaptainK> so how would that be entered?
13:27:17 <byorgey> however, in an .hs file you could write e.g.    example = let words2letters ..... in words2letters "HELLO"
13:27:34 <byorgey> then when you load the .hs file you could just type  example  at the ghci prompt
13:27:34 <CaptainK> yes with the let
13:28:06 <byorgey> let ... in ...  is an expression, just like  5  or like  (29 + 37)  or like  (\x -> x ^ 2)
13:28:21 <CaptainK> if you use let it should work because we are in a do block
13:28:40 <elliott> "let ... = ..." as a statement is not the same as "let ... = ... in ..." an expression
13:28:43 <byorgey> at the ghci prompt you can write  let ....    without an 'in' part, because it is like a do block
13:29:02 <CaptainK> but I'm in a do block in .hs
13:29:23 <byorgey> well, then you can write   let blah = foo   with no 'in' part
13:29:26 <elliott> but you have an "in", presumably.
13:29:34 <elliott> though we can't tell for sure because you haven't shown your file :)
13:30:13 <CaptainK> > let words2letters [a,b,_,_,_] = (a,b) in words2letters "HELLO"
13:30:14 <lambdabot>   ('H','E')
13:30:25 <CaptainK> as so exactly in the .hs file
13:30:28 <S_J> sometimes in haskell i feel totally stupid. and i could do things in python in 1minute that takes half an hour to figure out in haskell. am i just stupid?
13:30:34 <elliott> yes, but lambdabot is not a .hs file.
13:30:46 <CaptainK> its like GHCi
13:30:52 <elliott> ...
13:30:53 <CaptainK> Prelude with more stuff
13:30:58 * hackagebot rollbar 0.1.0.0 - error notification to rollbar.com  http://hackage.haskell.org/package/rollbar-0.1.0.0 (GregWeber)
13:31:13 <CaptainK> but why can't you have that in an .hs file under main = do?
13:32:08 <elliott> because let statements are not let expressions
13:32:10 <S_J> Just (fromList [("is",0.5),("it",0.25),("world",0.25)]). I guess what i want to do now is sum up each so "is"->0.5" "it"->0.75 and world"->1. then if a random nbr is less than "is" choose is, if not but less than 0.75 choose "it" etc...
13:32:24 <elliott> using that expression verbatim will either have the wrong type or indentation issues depending on the surrounding context.
13:32:25 <Peaker> S_J, it takes practice...
13:32:25 <S_J> scanl somehow?
13:32:51 <Peaker> S_J, I had 7 years of Python experience when I started with Haskell, it took more than a year before I was nearly as comfortable in Haskell as I was in Python
13:32:54 <zum90> hello. I have a question concerning the empty tuple (): what is an example where it makes sense to use it?
13:33:02 <CaptainK> so hard, all I want to do is compare the first and second letters of a word?
13:33:11 <utj> S_J: you're talking about sampling from a multinomial disitribution
13:33:21 <Peaker> S_J, there are still certain one-off short throwaways which are a bit of a PITA in ghci and nice in python, and I use python for those.. but generally, when I use Python, I curse for lack of Haskelly things :)
13:33:24 <CaptainK> gotta import awk and sed
13:33:35 * elliott doesn't think statements in do blocks not being the same thing as expressions is all that complicated...
13:33:36 <eikke> zum90: check the type if e.g. "putStrLn"
13:33:48 <Eduard_Munteanu> S_J: there's often an impedance mismatch when you change fields or paradigms.
13:34:41 <zum90> eikke: so IO () is an empty IO action?
13:34:47 <Eduard_Munteanu> Like math people going into programming and wondering why they can't talk about stuff without tediously describing every step to compute it.
13:34:50 <utj> Eduard_Munteanu: well put!
13:35:06 <elliott> zum90: an IO action which returns a () when executed
13:35:09 <elliott> like None in Python or void in C.
13:35:16 <elliott> because there's no useful result, you use it for its side effects.
13:35:39 <eikke> zum90: it's an action which yields nothing useful
13:35:43 <ksf> Eduard_Munteanu, they should be forced to. do everything they do in coq. that way, we can get rid of those formalists.
13:35:58 * hackagebot module-management 0.11.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.11.1 (DavidFox)
13:36:00 * hackagebot pushme 1.4.0 - Tool to synchronize multiple directories with rsync, zfs or git-annex  http://hackage.haskell.org/package/pushme-1.4.0 (JohnWiegley)
13:36:04 <eikke> zum90: () is mainly used in situations where 'only side-effects are of interest'
13:36:19 <eikke> zum90: because the value () in itself is rather uninteresting
13:36:44 <elliott> though when only side-effects are of interest, they are not side- at all, they are just effects :)
13:36:56 <ksf> zum90, as an example, in the last monadic computation I wrote, getting () just meant "everything's fine, nothing to see". elsewise, I'd throw an error.
13:37:03 <CaptainK> elliott: how would I rewrite that expression to fit into a statement?
13:37:20 <merijn> "(Applicative m, Monad m) =>" <- http://herbedisdeadly.files.wordpress.com/2011/08/soon_owl.jpg
13:37:50 <elliott> CaptainK: well, the let part is just "let words2letters [a,b,_,_,_] = (a,b)".
13:37:56 <elliott> and then you can use words2letters in the rest of the do block.
13:38:11 <eikke> merijn: for some definition of 'soon'
13:38:46 <merijn> zum90: Btw, () is commonly called "unit" or "unit type" since there is only one constructor for it "()", I tend to use it as placeholder for "empty" when using phantom types
13:38:50 <merijn> eikke: I know :(
13:39:34 <eikke> merijn: wouldn't you use Void there?
13:39:48 <merijn> eikke: Meh, I'd have to import it
13:39:54 <merijn> It depends
13:40:58 <merijn> ugh, I just realised I need to add that extra Applicative constraint on like 10 classes :9
13:41:09 <merijn> Time to degeneralise to Monad...
13:43:55 <Peaker> merijn, or use the MonadA trick
13:44:21 <merijn> Peaker: Which is?
13:44:23 <Peaker> https://github.com/Peaker/lamdu/blob/master/bottlelib/Control/MonadA.hs
13:44:34 <Peaker> pass around a MonadA constraint
13:44:44 <Peaker> We use MonadA in lieu of Monad
13:45:33 <merijn> Peaker: If you use ConstraintKinds you can simplify that too "type MonadA m = (Monad m, Applicative m)"
13:45:54 <Peaker> ConstraintKinds are all kinds of trouble
13:45:58 * hackagebot rollbar 0.2.0.0 - error notification to rollbar.com  http://hackage.haskell.org/package/rollbar-0.2.0.0 (GregWeber)
13:46:16 <Peaker> Well, TH trouble, specifically :) And they require adding a LANGUAGE pragma to all the modules
13:46:18 <merijn> I might just do that, I already use MPTC/FlexibleInstances/UndecidableInstances/FunDeps, so portability is out the window anyways
13:46:22 <Peaker> whereas this requires it only here
13:48:31 <merijn> Just to check, r' and r in "MonadReader r' m => MonadReader r' (ContT r m)" are completely unrelated and the choice of r there is a bit unfortunate, right?
13:49:02 <c_wraith> they are completely unrelated, and both just called "r" by convention
13:49:40 <merijn> ok
13:49:49 <merijn> Confusion averted
13:50:58 * hackagebot terminal-size 0.2.1.0 - Get terminal window height and width  http://hackage.haskell.org/package/terminal-size-0.2.1.0 (MatveyAksenov)
13:51:16 <Peaker> "r"ead data, "r"esult of continuation, I think
13:51:22 <c_wraith> yeah
13:51:56 <c_wraith> I really think the MonadReader one should be e for "e"nvironment, but then it'd clash with MonadError's e for "e"rror
13:52:12 <merijn> Unrelated, any vim users of hdevtools that know how I can get rid of this error? "Ambiguous module name `Control.Monad.Trans.List': it was found in multiple packages: List-0.5.1 transformers-0.3.0.0"
13:52:43 <c_wraith> well, you can hide one of them with ghc-pkg
13:52:51 <c_wraith> That's not ideal, but it'll work
13:53:34 <supki> merijn: there is -XPackageImports also
13:53:35 <hughfdjackson> i know this must be asked a lot - but where would/does one find out about haskell jobs?
13:53:50 <S_J> :t scanl'
13:53:51 <lambdabot>     Not in scope: scanl'
13:53:51 <lambdabot>     Perhaps you meant one of these:
13:53:51 <lambdabot>       `scanl' (imported from Data.List),
13:54:02 <S_J> can i scan without the first arg?
13:54:14 <c_wraith> :t scanl1
13:54:15 <lambdabot> (a -> a -> a) -> [a] -> [a]
13:54:16 <supki> merijn: i.e.  import "transformers" Control.Monad.Trans.List
13:54:23 <S_J> > scanl1 (+) 0 [0.33,0.67]
13:54:24 <lambdabot>   Couldn't match expected type `[t1] -> t0' with actual type `[a0]'
13:54:27 <S_J> > scanl1 (+) [0.33,0.67]
13:54:28 <lambdabot>   [0.33,1.0]
13:54:34 <S_J> > scanl1 (+) [0.25,0.25,0.50]
13:54:35 <lambdabot>   [0.25,0.5,1.0]
13:55:15 <Tritlo> hey, I'm taking a Data Mining course and we have a free choice of language for the project. Is haskell a feasible language, or should I stick with R or Python, for their plotting capabilities etc?
13:55:33 <merijn> hughfdjackson: Make a profile on haskellers.com, I've been approached twice :p
13:55:40 <rootnode> I think it depends on your knowledge of haskell
13:55:57 <rootnode> if you are very familiar with it, then go ahead and use it
13:56:02 <Tritlo> Hackage doesn't have a promising amount of Data Mining libraries
13:56:10 <S_J> Tritlo: datamining doesnt sound like something for haskell. Python has a lot of olibs for it. And C for crunching nbrs?
13:56:15 <hughfdjackson> merijn: oOo i may well do, later in the course of my learnings :)
13:56:41 <Tritlo> yeah, that's what I thought
13:57:18 <Tritlo> On the other hand, it could be a great chance to learn more haskell, and maybe add more DM libraries to hackage
13:57:37 <Tritlo> If I'd produce something decent
13:58:02 <S_J> Cale rescue me! how do I go from ("hello",fromList [("is",0.5),("it",0.25),("world",0.25)]) to ("hello",fromList [("is",0.5),("it",0.75),("world",1.0)]) ? I dont know how to think about htese things
13:58:44 <rootnode> S_J: ZipList maybe?
13:59:38 <S_J> :t zipList
13:59:39 <mserrano> no
13:59:39 <lambdabot> Not in scope: `zipList'
13:59:40 <mserrano> that's a scan
13:59:46 <merijn> supki: Oh, good, that worked :)
13:59:50 <S_J> yes it is a scanl
13:59:52 <S_J> yes it is a scanl1
14:00:02 <S_J> but then i need to reinsert
14:00:19 <hpc> :t scanl1
14:00:19 <lambdabot> (a -> a -> a) -> [a] -> [a]
14:00:20 <Cale> S_J: you probably want to work with your value as a list
14:00:27 <Cale> S_J: and then convert it back at the end
14:00:56 <c_wraith> Tritlo: you can easily dump your results to any external plotter you want.  There are gnuplot bindings, for instance.
14:01:12 <Peaker> Yesod is losing even to nodejs in http://www.techempower.com/benchmarks/#section=data-r6 .. ??
14:01:29 <c_wraith> Tritlo: but performance-sensitive numerical code in haskell requires knowing what the common mistakes are, so as to avoid them.
14:01:46 <c_wraith> Tritlo: and that can be a lot to learn if you're trying to do something else at the same time
14:02:01 <luite> Peaker: and snap 3x slowr than that :(
14:02:04 <CaptainK> how can I write this in .hs     let letter2 [_,x,_,_,_] = x
14:02:28 <Botje> CaptainK: use the !! function
14:02:54 <Tritlo> c_wraith: right
14:02:55 <Cale> CaptainK: What is your program meant to be doing?
14:03:09 <Cale> CaptainK: (overall)
14:03:29 <merijn> Peaker: That could just be crappy database bindings (in fact, that seems likelier than node.js beating yesod)
14:03:43 <CaptainK> matching dictionary words with letters common to each
14:04:02 <CaptainK> so ["HELLO"] as read from a dictionary file
14:04:31 <hpc> Peaker: single-request performance is a useless metric
14:04:33 <CaptainK> now I want to find all letters who have a matching "E" in their third letter position
14:05:13 <Cale> CaptainK: Are you trying to find the longest common prefix of two words?
14:05:25 <Tritlo> I'm also thinking that because Data Mining is very imperatively defined, then translating that into Haskell while simultaneously learning the material would be a little heavy
14:05:36 <CaptainK> no, just words with matching letters
14:05:55 <CaptainK> so "HELLO" as an E at position 2
14:05:58 <Peaker> hpc, why?
14:06:06 <luite> hpc: but none of the haskell frmaeworks have shown really impressive results on any of the tests, also in the other rounds. perhaps they're all not terribly useful, but still
14:06:07 <CaptainK> find a word that has an "E" at position 3
14:06:20 <Cale> uh, okay...
14:06:30 <merijn> luite: I can't find a reference to the implementations used
14:06:40 <luite> merijn: they're on github
14:06:56 <Cale> CaptainK: One trick which may be useful is that zip [0..] will pair each of the elements of a list with its position in the list.
14:07:00 <CaptainK> would love to use this: let w1 [_,x,_,_,_] = x
14:07:04 <Cale> > zip [0..] "hello"
14:07:05 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
14:07:16 <CaptainK> ah that might work
14:07:25 <Cale> Also note that:
14:07:29 <Cale> > "hello" !! 1
14:07:30 <lambdabot>   'e'
14:07:42 <Peaker> merijn, https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/yesod/bench/src/yesod.hs this seems to be the code
14:07:43 <Cale> But (!!) is a pretty unnatural operation on lists
14:07:45 <Cale> and can fail
14:07:49 <Cale> > "hello" !! 5
14:07:50 <lambdabot>   *Exception: Prelude.(!!): index too large
14:07:50 <CaptainK> yes I have that, but its a bit messy using word !!
14:08:00 <luite> merijn: whoah the fastest framework is on sourceforge, that almost like hipster-level retro ;)
14:08:01 <Peaker> > "hello" ^? index 5
14:08:02 <lambdabot>   Couldn't match type `GHC.Types.Int'
14:08:02 <lambdabot>                with `[GHC.Types.Char]
14:08:02 <lambdabot>  ...
14:09:07 <Peaker> > "hello" ^? element 5
14:09:09 <lambdabot>   Nothing
14:09:37 <luite> Peaker: the code looks reasonable, and i think snoyberg already tweaked it a bit
14:10:08 <Peaker> luite, I see the setup.py script builds everything, I hope they don't measure that or such :)
14:10:32 <CaptainK> > if ("HELLO" !! 1 == "TESTY" !! 1) then putStrLn "Yes!"
14:10:34 <lambdabot>   <hint>:1:55:
14:10:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
14:11:13 <c_wraith> CaptainK: lambdabot doesn't do IO *and* that's a syntax error
14:11:14 <kostya_> > if ("HELLO" !! 1 == "TESTY" !! 1) then putStrLn "Yes!" else putStrLn "No!"
14:11:14 <lambdabot>   <IO ()>
14:11:17 <luite> Peaker: bos mentioned on reddit that haskell should perform much better than this, but i'm not sure if he already looked at this
14:11:41 <luite> or perhaps he just underestimates the power of C++ server pages
14:11:49 <kostya_> > if ("HELLO" !! 1 == "TESTY" !! 1) then "Yes!" else "No!"
14:11:50 <lambdabot>   "Yes!"
14:11:51 <Peaker> and nodejs!
14:11:51 <ChongLi> lens still doesn't show up on hoogle
14:11:55 <ChongLi> what's the deal?
14:12:17 <Peaker> hoogle website only indexes base package and a few more iirc
14:12:31 <ChongLi> it has data-lens and lenses
14:12:38 <luite> Peaker: well v8 is a pretty impressive js engine, perhaps second only to luajit for a dynamic language?
14:12:39 <c_wraith> actually, it indexes most packages. It just doesn't search them by default
14:12:55 <luite> Peaker: and node.js has lots of native stuff under the hood, for buffering and io management
14:13:04 <bscarlet> c_wraith: Is there a way to search more packages?
14:13:18 <Peaker> luite, GHC has a few of those too :)
14:13:45 <c_wraith> bscarlet: not at in the large. You can tell it to include specific packages in its search, but there's no shortcut for "all packages"
14:14:01 <luite> Peaker: haskell is at a disadvantage with its immutability burning through cache faster though
14:14:18 <luite> perhaps more RTS tuning can improve the results
14:14:32 <bscarlet> c_wraith: Did it change at some point? In my vague memories it returned what I needed more often, once upon a time.
14:14:57 <c_wraith> bscarlet: I don't think so, though you could ask nm about it.  I think people are just more comfortable using more of the ecosystem now
14:15:32 <Peaker> luite, there are +RTS flags there
14:15:56 <Peaker> luite, snoyman used to show results that put node-js to shame.. maybe this test is too narrow indeed
14:17:14 <luite> Peaker: or perhaps node.js improved ;)
14:18:45 <S_J> I can pass a random value to a pure function right? if I fmap or ake it out 0of whatever monad it is in with <.
14:18:47 <S_J> <-
14:19:10 <S_J> how do I get a random value between 0 and 1
14:19:11 <S_J> ?
14:19:18 <ParahSailin> @ty randomR
14:19:19 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
14:19:28 <tac> S_J you can pass in a value. Whether or not its random depends on what you mean by random :)
14:19:30 <ParahSailin> @ty stdGen
14:19:31 <lambdabot> Not in scope: `stdGen'
14:19:37 <ParahSailin> @ty randomIO
14:19:37 <lambdabot> Random a => IO a
14:19:51 <ParahSailin> @ty mkStdGen
14:19:52 <lambdabot> Int -> StdGen
14:20:03 <tac> S_J: Numbers are randomly created either using IO or using a random number generator object
14:20:17 <tac> You can't make random numbers in "pure" code
14:21:00 <S_J> ok, esiest way to get random nbr?
14:21:44 <S_J> isnt there some really easy function?
14:21:46 <Peaker> @type randomIO
14:21:47 <lambdabot> Random a => IO a
14:21:47 <Twiceler> You need to work with the IO monad… Basically something like
14:21:51 <tac> My answer is always Google "random number generator haskell"
14:21:54 <Twiceler> newStdGen >>= random
14:22:05 <ChongLi> S_J: what do you mean by easy?
14:22:31 <Tritlo> S_J: Check out the Randomness on LYAH: http://learnyouahaskell.com/input-and-output
14:22:48 <Peaker> S_J, main = putStrLn . ("Your random number is: " ++) . show =<< (randomIO :: IO Int)
14:23:53 <tac> > fst $ randomR (1, 6) (mkStdGen 0)
14:23:54 <lambdabot>   6
14:23:55 <tac> > fst $ randomR (1, 6) (mkStdGen 0)
14:23:57 <lambdabot>   6
14:23:58 <tac> > fst $ randomR (1, 6) (mkStdGen 1)
14:23:59 <lambdabot>   6
14:24:01 <tac> > fst $ randomR (1, 6) (mkStdGen 3)
14:24:02 <lambdabot>   6
14:24:10 <tac> that doesn't look too random
14:24:26 <Hafydd> > randomR (1, 6) (mkStdGen 2)
14:24:28 <lambdabot>   (6,120042 40692)
14:24:36 <Tritlo> The thing is though that you'll always get the same random number from the same generator, since the function being pure necessitates that every call with the same arguments returns the same result
14:24:40 <S_J> so how do i get one between 0 and 1, uniform
14:25:01 <tac> > randomR (0.0, 1.0) (mkStdGen 234234234)
14:25:03 <lambdabot>   (0.20275671273822993,754552447 2103410263)
14:25:20 <Twiceler> > newStdGen >>= randomR (0,1::Double)
14:25:21 <lambdabot>   Couldn't match type `(,) GHC.Types.Double' with `GHC.Types.IO'
14:25:21 <lambdabot>  Expected ty...
14:25:45 <ChongLi> > randomRs (0.0, 1.0) (mkStdGen 23124012)
14:25:46 <Peaker> S_J, randomRIO (0, 1) :: IO Double
14:25:46 <lambdabot>   [0.5292415087749648,0.30640371713143755,1.1084541845632123e-2,0.71302632554...
14:26:25 <ChongLi> probably the easiest (if you need a lot of numbers in the same range)
14:27:02 <merijn> Does anyone know how I can insert whitespace/non-breaking spaces in Haddock documentation?
14:27:18 <quchen> "&nbsp;"?
14:28:13 <merijn> quchen: Nope
14:28:30 <quchen> Color me surprised.
14:28:34 <merijn> That prints "&nbsp;" in characters in the HTML
14:28:57 <Botje> how about an actual NBSP?
14:29:40 <Botje> (a U+00A0 character, that is.)
14:29:53 <quchen> merijn: http://www.haskell.org/haddock/doc/html/ch03s08.html#id565986
14:30:39 <quchen> &#20;  <--  talk about readability. Now look up what hex NBSP corresponds to and retry.
14:30:43 <Botje> aha. so &#xA0; or &#160; should work
14:32:10 <merijn> Botje, quchen: <3
14:33:38 <merijn> In other words, documenting is boring and hard :(
14:34:15 <Botje> surely there's an emacs plugin that submits a "document this code plz" job to rentacoder.net
14:34:34 <quchen> There's a sweet spot between no docs and writing very good docs. Which is a very awkward place for a sweet spot.
14:34:55 <bscarlet> between a doc and a hard place?
14:35:08 <orzo>  how do i catch exceptions from within a MonadIO ?
14:35:27 <Peaker> orzo, I don't think you can, but you can catch if you have MonadCatchIO (iirc the name)
14:35:30 <quchen> orzo: You mean you're in an IO-based transformer stack?
14:35:39 <orzo> quchen: yes
14:35:59 * hackagebot ty 0.1.4 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.1.4 (ConalElliott)
14:36:08 <quchen> orzo: I had a similar problem, and someone recommended lifted-base to me. http://hackage.haskell.org/packages/archive/lifted-base/0.2.1.0/doc/html/Control-Exception-Lifted.html
14:36:27 <quchen> I didn't use it though, and instead changed half of my program. Now it's broken :>
14:36:39 <quchen> (Just saying I don't have much experience with that package)
14:37:31 <orzo> My particular case is a ConduitM, so there is possibly a conduit-specific method for handling exceptions
14:39:04 <orzo> i think i can possibly get by by replacing a yield with a yieldOr
14:40:12 <orzo> ConduitM is an instance of MonadBase and MonadThrow and some other things
14:40:23 <orzo> maybe one of those has exeption catching
14:43:52 <nabilhassein> using quickcheck, is there a simple way to generate a list [a] of a certain length, given that a is an instance of Arbitrary?
14:44:09 <Botje> replicateM n arbitrary
14:44:20 <nabilhassein> Botje: thanks very much!
14:45:30 <djahandarie> Anyone here live in Baltimore?
14:48:06 <shachaf> I vaguely remember that the answer is yes.
14:48:46 <Tene> I think I drove through Baltimore once.
14:52:08 <ion> djahandarie: I live in the same local group.
14:53:46 <acowley> So we've basically got Baltimore blanketed in Haskellers.
14:55:24 <djahandarie> ion, do you take couchsurfing Haskellers? :P
14:56:54 <ion> djahandarie: That could be arranged. Will you be visiting Finland? :-) https://en.wikipedia.org/wiki/Local_Group
14:57:22 <nabilhassein> is there a helper function to convert a (small) Int to Word8? my hoogle-fu and google-fu have both failed me
14:57:31 <ion> fromIntegral
14:57:32 <Botje> nabilhassein: fromIntegral
14:57:33 <djahandarie> Haha. The trip might be a little far in that case.
14:57:44 <nabilhassein> ion, Botje: doh. Thanks!
14:57:47 <elliott> djahandarie: no. it turns out nobody at all lives in baltimore
14:57:49 <elliott> freaky, I know
14:58:03 <armlesshobo> if f: X -> Y and g: Y -> Z, and g o f: X -> Z, then does (g o f)^2 = f^2 + g^2?
14:58:33 <monochrom> strange question
14:59:49 <monochrom> X->Y, Y->Z, X->Z are unlikely to be Num instances. therefore, ^ and + are unlikely to be defined.
15:00:45 <merijn> elliott: Should I have "supply :: Supply s s", "demand :: (s -> a) -> Supply s a" and "demandT :: (s -> f a) -> SupplyT s f a" (not sure about that last name), or should I go with "demand :: Supply s s", "supply :: (s -> a) -> Supply s a" and "supplyT :: (s -> f a) -> SupplyT s f a"?
15:01:08 <merijn> The former looks more logical, but I'm unhappy with the name "demandT"
15:01:25 * elliott doesn't see that the (s -> a) -> Supply s a version is overly useful
15:01:33 <elliott> I mean, it's just a free liftM. I guess gets is precedent
15:02:38 <merijn> elliott: It avoids having to manually wrap your function with "Identity" if you have "s -> a" instead of "s -> f a"
15:03:03 <elliott> oh, is this for the Applicative version?
15:03:08 <elliott> I really don't know anything about that one.
15:03:08 <merijn> elliott: Yes
15:03:28 <FreeFull> I've been reading the Homotopy Type Theory book
15:03:35 <FreeFull> I haven't gotten to the Homotopy bit yet
15:03:43 <merijn> elliott: I'm more trying to brainstorm good names right now
15:03:58 <merijn> Like I said, demandT is ugly, but I dunno what else to use
15:04:50 <merijn> elliott: The good news is that I do have a full SupplyT monad now too, including a "MonadSupply s m" wrapper (I still need to clean that code up, though and document everything)
15:04:57 <ion> freefull: I haven’t got to the first paragraph bit yet.
15:06:38 <acowley> I don't really understand the computability story of HoTT.
15:07:41 <merijn> Oh well, time to grab a thesaurus and lookup synonyms for "demand"
15:08:33 <ion> petition
15:08:46 <elliott> acowley: there is http://homotopytypetheory.org/2011/07/27/canonicity-for-2-dimensional-type-theory/
15:08:51 <ion> want
15:09:00 <joehillen> implore
15:09:08 <ion> beseech
15:09:23 <FreeFull> ion: It starts with an explanation of standard type theory first
15:09:33 <monochrom> a synonym for "demand": "co-supply"
15:09:49 <ion> cos̈upply
15:10:04 <FreeFull> What's a cosynonym?
15:10:36 <merijn> elliott: I think I actually want "demand" to be "(s -> f a) -> Supply s f a", as that oughta be the more common use, but then I still have no clue what to call "Applicative f => (s -> a) -> Supply s f a" (also known as "sneaky Identity wrapper")
15:11:03 * elliott personally doesn't think the Applicative transformer form deserves the name Supply ;)
15:11:12 <merijn> elliott: Why not?
15:12:26 * elliott is horribly biased in favour of the monad form -- perhaps because I explored it first
15:12:31 <monochrom> hmm, does "apply" sound better?
15:12:56 <monochrom> supplicative : supply :: applicative : apply
15:13:01 <merijn> Actually, I think want the alternate naming scheme anyway
15:13:14 <S_J> if i do r <- (fun returning IO Double) ; now r is pure right? I can pass r to a f :: Double->Double ?
15:13:14 <Twiceler> I'm actually just starting to read about type theory now! I'm reading Type Theory & Functional Programming by Simon Thompson
15:13:27 <merijn> Since "supply f" means "get an s to f", while "demand f" seems an odd naming scheme
15:13:49 <acowley> elliott: Thanks! I was aware of that paper, but that writeup is fantastic.
15:13:55 <merijn> I guess I can live with supplyT
15:14:37 <elliott> acowley: it makes ignorant me believe that it's not implausible to expect a full computational story in the future :)
15:15:01 <acowley> elliott: I'm still kind of sketchy with higher dimensional type theory, but that that writeup almost has me convinced
15:15:07 <acowley> elliott: Yeah!
15:15:21 <Twiceler> S_J: sort of; the variable r is just a variable from a lambda expression
15:15:28 <Cale> S_J: the thing on the right of <- will rarely be a function
15:15:55 <Cale> S_J: but if you write r <- x and x :: IO Double, then r :: Double
15:16:30 <Cale> (you might have meant that it's not a function, but an application of one which results in an IO Double, in which case, that's okay :)
15:16:32 <FreeFull> Cale: Could be a function if you're in the reader monad I suppose
15:16:39 <Cale> FreeFull: right
15:16:59 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
15:17:01 <lambdabot>   ("hello","olleh","HELLO")
15:17:09 <Cale> ^^ there is a monad of functions from a fixed type
15:17:18 <FreeFull> I wonder if that would actually be useful for something
15:17:19 <Cale> (but usually that's not the one you're using)
15:17:29 <Cale> It is occasionally useful
15:17:47 <FreeFull> That one would be the same as this:
15:17:50 <ion> > sequence [pred, id, succ, (*10)] 42
15:17:51 <lambdabot>   [41,42,43,420]
15:17:58 <Cale> It's useful for the same reasons the reader monad is. It's a bit more syntactically lightweight.
15:18:16 <FreeFull> > ((,,) <$> id <*> reverse <*> map toUpper) "hello"
15:18:17 <lambdabot>   ("hello","olleh","HELLO")
15:18:24 <joelteon> yeah it's just like the reader monad but without asks
15:19:00 <FreeFull> The reader monad is good for join
15:19:01 <ion> > (do x <- asks id; y <- asks reverse; z <- asks (map toUpper); return (x,y,z)) "hello"
15:19:02 <lambdabot>   ("hello","olleh","HELLO")
15:19:27 <FreeFull> :t asks
15:19:28 <lambdabot> MonadReader r m => (r -> a) -> m a
15:33:04 <Twiceler> What happens if you give lambdabot an infinite computation? Does it explode?
15:33:14 <roconnor> > fix error
15:33:15 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:33:32 <Twiceler> Nice :)
15:34:23 <roconnor> > let rats = 1:[1/(x+1), x + 1 | x <- rats] in rats
15:34:24 <lambdabot>   <hint>:1:30: parse error on input `|'
15:34:25 <monochrom> it has timeouts and similar guards
15:34:51 <roconnor> > let rats = 1:(concat [[1/(x+1), x + 1] | x <- rats]) in rats
15:34:52 <lambdabot>   [1.0,0.5,2.0,0.6666666666666666,1.5,0.3333333333333333,3.0,0.60000000000000...
15:34:58 <roconnor> > let rats = 1:(concat [[1/(x+1), x + 1] | x <- rats]) in rats :: [Rational]
15:34:59 <lambdabot>   [1 % 1,1 % 2,2 % 1,2 % 3,3 % 2,1 % 3,3 % 1,3 % 5,5 % 3,2 % 5,5 % 2,3 % 4,4 ...
15:35:06 <tac> Twiceler: It runs for about 5 seconds in a separate process, no IO allowed
15:35:09 <tac> > print "hello"
15:35:10 <lambdabot>   <IO ()>
15:35:17 <adnap> > ("hello","world")^._2
15:35:18 <lambdabot>   Not in scope: `_2'
15:35:39 <Twiceler> tac: Thanks! Good to know.
15:40:00 <DanielDiaz> hello, how can I use ghc to evaluate expressions with "ghc -e" where the included expressions requires to import a module?
15:40:56 <DanielDiaz> what is the required flag so I can say, for example, import Data.List, and then evaluate the expression
15:40:59 <DanielDiaz> ?
15:41:07 <merijn> elliott: btw, on the topic of the applicative transformer not deserving the name Supply, as far as I can figure out the applicative one lets you write many more interesting things than the monadic one (or rather, it might be possible to implement the same things for the monadic one, but it's complicated to such a degree that I'm having a hard time doing so)
15:41:12 <FreeFull> adnap: Lens isn't currently available in lambdabot due to hashable
15:42:48 <roconnor> oh man, I should really finish my lightweight lens library so lambdabot can have it.
15:44:47 <acowley> DanielDiaz: ghc -e "import Data.List" -e "foldl' (+) 0 [1,2,3]"
15:45:36 <FreeFull> acowley: Ah, I tried  ghc -e 'import Data.List; print $ sort [1,2,3]'  and it just exited silently for some reason
15:46:10 <acowley> FreeFull: That's what I tried first, too.
15:46:52 <adnap> FreeFull: What problem is caused by hashable?
15:47:34 <zq> are there any compilers written in haskell?
15:47:38 <sipa> yes, ghc
15:47:40 <adnap> GHC
15:47:42 <zq> bof
15:47:56 <zq> anything else? possibly a tad simpler?
15:48:20 <DanielDiaz> acowley: thank you, I will try
15:48:35 <adnap> Does anyone have advice on learning the lens package?
15:48:51 <Peaker> adnap, learn what "traverse" is
15:48:55 <josephle> I believe there are some compilers on hackage. Most of them are probably simpler than ghc.
15:48:55 <FreeFull> adnap: https://github.com/tibbe/hashable/issues/69   This, seems to have been closed now though
15:49:27 <Peaker> adnap, and then learn the "Const" and "Identity" Applicative/Monads, and then see what happens when you use "traverse" with "Const" and "Identity" as the "f". And also see what happens when you compose: traverse f . traverse g
15:49:55 <adnap> I don't know much about the Data.Traversable. I am comfortable with Monad and Applicatives
15:50:01 <ion> adnap: You might want to watch edwardk’s talk on Youtube.
15:50:06 <Peaker> adnap, Data.Traversable is extremely useful in general
15:50:11 <adnap> I will start there
15:50:25 <ion> adnap: traverse is equivalent to mapM.
15:50:26 <Peaker> adnap, it can be seen as a generalization of "mapM" or as a generalization of "Functor" to add effects
15:50:30 <adnap> I watched about half of edwardk's lecture and followed the slides
15:50:49 <adnap> I slowly followed the examples, but I couldn't connect them to anything useful
15:50:57 <S_J> how do I compile MyModule to an exe? if i remove midule it seems i need a module main?
15:51:08 <adnap> And I thought I was learning about lenses to begin with
15:51:13 <Peaker> adnap, fmap :: (a -> b) -> f a -> f b        what if "f" is some container, and you want to apply an effectful function to all of them, rather than a pure function (in an applicative "g", not "f")
15:51:24 <Peaker> adnap, if f=[], then you can use mapM
15:51:26 <Peaker> @type mapM
15:51:26 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:51:53 <adnap> I don't know what you mean by "effetful function"
15:52:02 <Peaker> adnap, something like: (a -> IO b)
15:52:09 <Peaker> or any other applicative instead of IO there
15:52:27 <rootnode> ion: do you have a link to the talk?
15:52:28 <Peaker> adnap, imagine you want to apply an IO-effectful function to a value within a Maybe
15:52:40 <adnap> Then I would use fmap
15:52:54 <adnap> > fmap print $ Maybe 2
15:52:55 <lambdabot>   Not in scope: data constructor `Maybe'
15:53:06 <Peaker> @type fmap print $ Just 2
15:53:06 <lambdabot> Maybe (IO ())
15:53:09 <adnap> Oops
15:53:10 <adnap> Ueah
15:53:12 <adnap> Yeah
15:53:14 <merijn> zq: Were you interested from a learning perspective?
15:53:16 <Peaker> adnap, and then what, you get Maybe (IO ())
15:53:21 <adnap> Yeah
15:53:21 <Peaker> adnap, what do you do with it?
15:53:22 <zq> merijn: very very much so
15:53:32 <adnap> Peaker: I don't know. I don't understand the motivation of this hypothetical
15:53:43 <zq> merijn: i searched for haskell versions of the llvm kaleidoscope tutorial
15:53:53 <merijn> zq: In that case maybe you want to look at "Write Yourself a Scheme in 48 Hours"? It's a tutorial on implementing Scheme using haskell
15:53:59 <zq> merijn: but haskell-kaleidoscope on gh is pretty derelict
15:54:10 <zq> merijn: let me look into that
15:54:32 <ion> @hackage lens
15:54:33 <lambdabot> http://hackage.haskell.org/package/lens
15:54:38 <ion> rootnode: It’s linked from there.
15:54:38 <Peaker> adnap, Let's say you have:  data Tree a = ... for a typical binary tree
15:54:45 <rootnode> thanks
15:55:13 <Peaker> adnap, let's say you want to write a program that tags each node in the tree with an index/position
15:55:24 <Peaker> adnap, indexPos :: Tree a -> Tree (Int, a)
15:55:32 <adnap> In what order?
15:55:41 <Peaker> adnap, Let's say, in-order
15:56:11 <Peaker> adnap, you'd just do a manual recursion to pattern-match the tree, and then manually rebuild the tree, right?
15:56:15 <adnap> Peaker: Okay, the only way I could do that is with pattern matching and recursion
15:56:24 <adnap> I don't know how to use any packages to do that
15:56:28 <Peaker> adnap, With {-# LANGUAGE DeriveFoldable, DeriveTraversable #-}   you can do:
15:56:49 <Peaker> (and DeriveFunctor): data Tree a = Empty | Node a (Tree a) a deriving (Functor, Foldable, Traversable)
15:56:55 <Peaker> adnap, and then you can do:
15:57:34 <Peaker> (`runState` 0) $ traverse (\val -> do { counter<-get ; modify (+1) ; return (counter, val) })
15:58:16 <Peaker> @type @type (`runState` 0) . traverse (\val -> do { counter<-get ; modify (+1) ; return (counter, val) })
15:58:16 <lambdabot> parse error on input `@'
15:58:20 <Peaker> @type (`runState` 0) . traverse (\val -> do { counter<-get ; modify (+1) ; return (counter, val) })
15:58:21 <lambdabot> (Num s, Traversable t) => t t1 -> (t (s, t1), s)
15:58:36 <Peaker> adnap, The nice thing is this would work on any "t", t=Tree, t=[], or anything
15:58:49 <Peaker> adnap, let's see how traverse looks like:
15:58:53 <adnap> Peaker: Sorry, I don't understand this yet
15:59:01 <Peaker> adnap, I'm giving motivation first :)
15:59:35 <Peaker> adnap, we now see that "traverse" solves an actual problem nicely, by saving us from having to deconstruct our data structure and reconstruct it in a manual recursion
15:59:48 <adnap> I don't understand how it does that
15:59:51 <adnap> But I believe you
16:00:14 <merijn> argh
16:00:18 <S_J> Io String >>= return . unwords, shoudlnt that work?
16:00:26 <merijn> I hate it when I'm stuck voodoo programming...
16:00:44 <c_wraith> :t fmap unwords -- S_J
16:00:45 <lambdabot> Functor f => f [String] -> f String
16:00:49 <ion> adnap: “_1 f (a,b) = (,b) <$> f a” is a function that lets you apply a Functor effect to the first element of a tuple without modifying the second element. “both f (a,b) = (,) <$> f a <*> f b” lets you apply an Applicative effect to both elements of a tuple. We can use these to implement getters:
16:00:52 <Peaker> adnap, So let's look at the "traverse" function
16:00:52 <ion> > let _1 f (a,b) = (,b) <$> f a; both f (a,b) = (,) <$> f a <*> f b; view l x = getConst (l Const x) in (view _1 ("foo", "bar baz"), view both ("foo", "bar baz"))
16:00:53 <lambdabot>   Illegal tuple section: use -XTupleSections
16:00:55 <merijn> I'm just trying arbitrary mixes of fmap, <*> and >>= until the compiler is pleased >.>
16:00:57 <Peaker> @type traverse
16:01:02 <ion> > let _1 f (a,b) = flip (,) b <$> f a; both f (a,b) = (,) <$> f a <*> f b; view l x = getConst (l Const x) in (view _1 ("foo", "bar baz"), view both ("foo", "bar baz"))
16:01:03 <lambdabot>   ("foo","foobar baz")
16:01:05 <adnap> Ahhh
16:01:08 <ion> as well as modifiers:
16:01:11 <Peaker> adnap, Let's implement our own "traverse" for the Tree type
16:01:20 <adnap> To much clutter
16:01:35 <Peaker> @type traverse
16:01:52 <adnap> ion: I'm going to ignore what you're writing for now
16:01:55 <adnap> ion: Sorry
16:01:56 <ion> > let _1 f (a,b) = (,b) <$> f a; both f (a,b) = (,) <$> f a <*> f b; over l f x = runIdentity (l (Identity . f) x) in (over _1 length ("foo", "bar baz"), over both length ("foo", "bar baz"))
16:01:57 <lambdabot>   Illegal tuple section: use -XTupleSections
16:02:06 <ion> > let _1 f (a,b) = flip (,) b <$> f a; both f (a,b) = (,) <$> f a <*> f b; over l f x = runIdentity (l (Identity . f) x) in (over _1 length ("foo", "bar baz"), over both length ("foo", "bar baz"))
16:02:07 <lambdabot>   ((3,"bar baz"),(3,7))
16:02:10 <alpounet> @type Data.Traversable.traverse
16:02:11 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:02:12 <Peaker> ion, please less flooding
16:02:29 <ion> adnap: You might want to take a look at these simple examples later, though.
16:02:48 <adnap> ion: I have read some of the examples here: https://github.com/ekmett/lens#lens-lenses-folds-and-traversals
16:02:53 <adnap> Seems pretty cool
16:02:54 <Peaker> adnap, so traverse takes an "effectful function" (a -> f b)  (it's a function from a to an effect with a resulting b)
16:03:10 <Peaker> adnap, and it "lifts" it to effectfully transform a "t a" into a "t b"
16:03:20 <ion> peaker: I think the examples were rather good to demonstrate some of the basics.
16:03:27 <adnap> Peaker: But it's stuck in the effect f
16:03:43 <adnap> I guess it has to be
16:03:46 <Peaker> ion, yeah, just too many lines with too much content
16:03:53 <Peaker> (in too short a time)
16:04:11 <adnap> I just want to focus on one thing so I can get it faster
16:04:26 <Peaker> adnap, ok, so for our Tree type it is:
16:04:27 <adnap> ion: I will read what you wrote once Peaker is done explaining
16:04:40 <Peaker> traverse :: (a -> f b) -> Tree a -> f (Tree b)
16:04:49 <merijn> I found the right join/liftM voodoo combination \o/
16:04:53 <adnap> Yeah
16:04:57 <ion> adnap: Sure. Feel free to ask for clarification.
16:04:58 <Peaker> adnap, let's try to write this:  traverse f Empty = ??
16:04:58 <adnap> And a is a and b is (Int, a)
16:05:16 <adnap> Is that right?
16:05:35 <adnap> Peaker: Okay, I will try to write that
16:05:44 <ion> adnap: And perhaps evaluate the expressions step by step manually in a text editor, too.
16:05:47 <Peaker> adnap, well, in our case a=a, f=State Int, b=(Int, a) yeah
16:05:53 <zq> @def putStrLn
16:05:54 <lambdabot>  Parse failed: TemplateHaskell is not enabled
16:05:59 <zq> @source putStrLn
16:05:59 <lambdabot> Unknown command, try @list
16:06:06 <zq> .msg lambdabot @ist
16:06:27 <S_J> ^^ I wrote some thoughts on Monads... http://paste.tryhaskell.org/90652 what do you think?
16:06:29 <ion> putStrLn xs = putStr (xs ++ "\n") or something like that. putStr is mapM putChar or something like that.
16:06:32 <adnap> @type Data.Traversable.traverse
16:06:33 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:06:45 <zq> yeah, i was more looking for the lbot command to show source
16:06:50 <adnap> What is Empty?
16:06:53 <Peaker> S_J, it looks like a wall of text... no paragraph breaks
16:06:58 <ion> s_j: Thost blocks of text are very difficult to read.
16:07:06 <Peaker> adnap: data Tree a = Empty | Node a (Tree a) a
16:07:12 <merijn> zq: The best way to see the source is search on Hoogle and click the source link
16:07:31 <adnap> I guess traverse f Empty = pure Empty
16:08:15 <S_J> ion: it just flowed out of me
16:08:21 <Peaker> adnap, yep
16:08:22 <zq> merijn: very nice, thank you
16:08:28 <Peaker> adnap, and the Node case
16:09:18 <Peaker> S_J, you need to format it into sane readable paragraphs
16:10:05 <banister> can someone tell me what i'm doing with my toList and fromList such that when i go: fromList $ toList [4, 3, 5, 1, 2]     the list comes out in reverse? https://gist.github.com/75b69a06ed91f6faf068
16:10:27 <roconnor> adnap: traversable functors need not be empty
16:10:33 <alpounet> banister, stick a call to reverse in the middle
16:11:04 <banister> alpounet: hehe yeah, but is that the canonical solution? seems like there should be a more natural way for it to come out in the right order
16:11:07 <roconnor> adnap: But yes you can prove that traversals preserve the "size" of a traversable functor
16:11:37 <roconnor> adnap: oh crap you are refering to a specifc traversable
16:11:43 <Cale> banister: In toList, you're pre-ordering the elements of the tree
16:11:48 <roconnor> Sorry, I'll leave you allone
16:11:57 <Cale> banister: You want an in-order traversal, presumably?
16:12:07 <S_J> http://paste.tryhaskell.org/90653 <- It was just a joke, There is the code. It is text generated by a Markov chain generated from some text
16:12:14 <banister> Cale: can u show me how that should look?
16:12:35 <Cale> toList (Node x left right) = toList left ++ [x] ++ toList right  ?
16:12:42 <ion> s_j: Add paragraph breaks to the chain. :-P
16:12:50 <banister> Cale: it behaves the same way, strangely
16:12:54 <lemao> How does Haskell's type system relates to (or distinguishes from) Martin-Löf’ Type Theory?
16:13:02 <S_J> banister: yes and some '.'
16:13:02 <adnap> traverse f (Node l xs r) = Node <$> f l <*> traverse xs <*> f r
16:13:24 <Moggle_> I'm working on the Codensity Transform problem set and frankly I'm not entirely sure what it means to abstract over the leaves of a leafy tree. The definition given is newtype CTree a = CTree { unCTree :: forall r. (a -> Tree r) -> Tree r }. Can someone give me a hint as to what it means?
16:13:33 <banister> S_J: what?
16:13:48 <banister> S_J: sorry, not quite getting u
16:13:50 <adnap> Peaker: ^
16:14:06 <Peaker> adnap, missing an "f" after traverse there, but seems right
16:14:17 <Peaker> adnap, this traversal has the order l, children, r
16:14:42 <Peaker> adnap, this traversal is reusable -- whenever you would other "deconstruct" the entire Tree manually, do some effectful thing, and reconstruct it
16:15:08 <Cale> banister: I assure you that it does not behave the same way
16:15:16 <Cale> banister: Instead, it sorts the list.
16:15:22 <Cale> ghci> toList (fromList [4, 3, 5, 1, 2])
16:15:22 <Cale> [1,2,3,4,5]
16:15:50 <adnap> Peaker: I don't understand why I'm missing an f. Can you give the correct definition?
16:15:59 <banister> Cale: ah, so what should i do so that the same list comes out as the one that went in?
16:16:19 <Cale> banister: Tree insertion destroys that information.
16:16:21 <Cale> (in general)
16:16:23 <Peaker> adnap, you call "traverse xs"
16:16:34 <Peaker> adnap, but traverse takes 2 arguments there
16:17:40 <Cale> banister: You could avoid that "problem" by redefining treeInsert so that it always adds new elements on the left end of the tree. But you wouldn't have a binary search tree then.
16:18:21 <banister> Cale: but the information ALWAYS comes out reversed, so surely the order is preserved, just backwards
16:18:32 <Cale> It won't *always* come out reversed
16:18:35 <FreeFull> Cale: Or you could index the list beforehand
16:18:36 <banister> oh ok
16:18:36 <adnap> Peaker: Oh
16:19:07 <Peaker> adnap, so, can you imagine what happens if the "f" (of the type, not the function) is "Identity"?
16:19:24 <Peaker> adnap, I mean the f in:  traverse :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)
16:19:40 <adnap> Is a data constructor called Identity"
16:19:42 <adnap> ?
16:20:16 <Peaker> adnap, newtype Identity a = Identity { getIdentity :: a}
16:20:22 <FreeFull> map fst . sortBy (compare `on` snd) . toList . fromList $ zipWith [4,3,5,1,2] [0..]
16:20:22 <adnap> Okay, sure
16:20:39 <Peaker> adnap, you can think of it as the "no-op" effect
16:20:41 <FreeFull> Although that's a bit hackish
16:20:48 <adnap> Then you can get the traversable out of the Identity at the end
16:21:15 <prophile> :t ((*>), (<*))
16:21:16 <lambdabot> (Applicative f, Applicative f1) => (f a -> f b -> f b, f1 a1 -> f1 b1 -> f1 a1)
16:21:26 <Peaker> adnap, if f=Identity, the type becomes isomorphic to the type without the Identity wrapper.. can you write the type of traverse with f=Identity, and then without the Identity wrappers?
16:22:48 <ChongLi> any way to automatically derive an instance of Hashable for simple data types?
16:23:06 <Cale> banister: One improvement which can be made in toList is that since xs ++ ys takes O(length xs) steps to fully evaluate, certain trees will take quadratic time to convert to lists.
16:23:32 <S_J> banister: I meant some punctuation.
16:23:42 <Bor0> @src foldl'
16:23:42 <lambdabot> foldl' f a []     = a
16:23:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:23:43 <Cale> banister: You can avoid this by writing toList' :: Tree a -> ([a] -> [a]) which produces a function that adds the elements to another list.
16:23:48 <Bor0> @src foldl
16:23:48 <lambdabot> foldl f z []     = z
16:23:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:24:06 <Cale> banister: i.e. use id in place of [], and (x:) in place of [x], and (.) in place of (++)
16:24:23 <Cale> Since (.) takes O(1) time, this will be an asymptotic improvement
16:24:37 <Cale> and you can just apply the result to an empty list at the end to get an ordinary list
16:24:48 <Peaker> adnap, you there?
16:25:13 <adnap> Peaker: Yes
16:25:14 <prophile> Cale: that sounds suspiciously yoneda
16:25:35 <Cale> It's a standard trick
16:25:41 <Peaker> adnap, so, what's the type of our traverse on a Tree? Then with f=Identity? Then without the Identity wrappers?
16:25:43 <adnap> Peaker: Sorry it's taking me a bit. I decided to copy everything we are doing in IRC to a file
16:25:53 <prophile> it's rather clever
16:25:56 <Cale> In fact, it's embodied in the Prelude with 'shows'
16:26:00 <Cale> :t shows
16:26:01 <lambdabot> Show a => a -> ShowS
16:26:13 <ChongLi> duh, I should've scrolled down on the docs :)
16:26:16 <Cale> type ShowS = String -> String
16:26:20 <ChongLi> deriving generic
16:26:51 <banister> Cale: is it hard to implement <*> for a tree?
16:27:03 <Peaker> and DList generalizes it to [a]->[a],  and some other package I forget generalizes it to Monoid m => m a -> m a
16:27:15 <Cale> banister: Hard to say. What do you want it to do?
16:27:34 <Cale> DList is just a silly wrapped up version of this trick
16:27:43 <Bor0> looking at the implementation of fold', is it okay to say that seq can be used in general to evaluate expressions, in cases we need to avoid laziness?
16:27:44 <banister> Cale: you mean there's more than one possible implementation of <*> for trees?
16:27:58 <johnw> Peaker: which package offers generalized difference monoids?
16:28:07 <adnap> Peaker: I don't know if I understand your question. if t :: Tree a, traverse Identity t :: Identity (Tree a), and getIdentity . traverse Identity :: Tree a -> Tree a
16:28:13 <Cale> banister: There are zero standard implementations for the sort of trees you're working with.
16:28:14 <Peaker> johnw, I don't remember :)
16:28:35 <Peaker> adnap, not func arg being Identity data constructor
16:28:44 <adnap> Peaker: wat
16:28:45 <banister> Cale: isn't this just a standard binary tree?
16:28:46 <Peaker> adnap, the "f" in the *type* of traverse being the Identity type constructor
16:28:54 <Peaker> adnap, unfortunately we have 2 different things called "f" here
16:29:00 <Cale> banister: If the values were at the leaves, it would be another matter
16:29:18 <hashcat> hi, did anyone familiar with plugins package?
16:29:25 <Cale> But with the values in the branches, it's a bit trickier to obey the laws
16:29:26 <Peaker> traverse :: Applicative foo => (a -> foo b) -> Tree a -> foo (Tree b)
16:29:33 <Peaker> adnap, I'm talking about "foo"
16:29:46 <Peaker> adnap, imagine that "foo" is the Identity type
16:30:04 <Peaker> adnap, rather than traverse being applied with the "Identity" data constructor
16:30:06 <adnap> traverse :: (a -> Identity b) -> t a -> Identity (t b)
16:30:07 <Cale> hashcat: That package is really old and I'm not sure I'd expect it to work.
16:30:12 <hashcat> I'd like to know how to get a list of exports of an module
16:31:17 <adnap> Peaker: I'm not sure if I understand you, but your signature with foo looks similar to mine with Identity
16:31:17 <johnw> hashcat: haskell-src-exts can do that for you
16:31:20 <hashcat> Cale:but I see that it can be build on ghc 7.6
16:31:20 <Peaker> adnap, right, now you can remove these Identity wrappers
16:31:31 <adnap> Huh?
16:31:47 <Peaker> adnap, since "Identity a" is isomorphic to "a"
16:31:51 <adnap> traverse' :: (a -> b) -> t a -> t b?
16:31:59 <Peaker> adnap, yeah, which looks a lot like ... ?
16:32:04 <adnap> fmap
16:32:18 <Peaker> exactly -- so traverse with its effects neutralized away becomes fmap
16:32:42 <adnap> Peaker: By "neutralized away" you just mean invisible, not absent, right?
16:32:53 <banister> Cale: but this tree is a functor, and afaik it's also possible to make it an applicative functor, im just curious how i'd do that
16:32:54 <Peaker> adnap, "Identity" can have no effects,
16:33:03 <adnap> The effects with Identity are benign, but are you generalizing to other types?
16:33:04 <Peaker> adnap, so the effects are absent (but the type constructor is there)
16:33:10 <Cale> banister: Why do you expect that to be possible?
16:33:17 <Peaker> adnap, Identity has no effects, benign or not
16:33:24 <adnap> What's the point then?
16:33:25 <Cale> banister: It might be possible...
16:33:44 <adnap> Peaker: The type constructor is where?
16:34:11 <Peaker> adnap, the point is to show that "fmap" is a special case of "traverse", similarly to the way "fmap" is a special case of (>>=) (if you have return)
16:34:31 <adnap> Okay
16:34:36 <Peaker> adnap, IOW, traverse is a generalization of "fmap" when you don't apply a pure function to each position, but an effectful function to each position
16:34:47 <hashcat> johnw: thanks for help. but i'm looking for get it from object code or interface file now.
16:34:53 <banister> Cale: well, i just assumed it was :) do you know of any implementations for <*> for this kind of tree?
16:34:56 <Cale> no
16:35:04 <adnap> Peaker: Okay
16:35:12 <Peaker> adnap, so now we can go back and try to understand the counter thing
16:35:16 <Cale> Well, actually, maybe I do :P
16:35:25 <Peaker> @type (`runState` 0) . traverse (\val -> do { counter<-get ; modify (+1) ; return (counter, val) })
16:35:25 <Cale> We could go by analogy with ZipList
16:35:26 <lambdabot> (Num s, Traversable t) => t t1 -> (t (s, t1), s)
16:35:33 <Cale> and zip the trees together
16:35:41 <Peaker> adnap, do you understand the contents of the "do" block?
16:35:48 <banister> Cale: haha im not the first one to ask: http://www.haskell.org/pipermail/beginners/2010-March/003856.html
16:35:48 <Cale> That would give an instance which was incompatible with becoming a monad.
16:35:58 <Bor0> looking at the implementation of foldl', is it okay to say that seq can be used in general to evaluate expressions, in cases where we need to avoid laziness? I'm trying to get a grasp of seq, and avoiding laziness as well
16:36:08 <Cale> but I believe it would work
16:36:27 <adnap> Peaker: I need to go read about the State monad again. I never use it
16:36:35 <Cale> Bor0: yes
16:36:44 <Peaker> adnap, it's a very useful monad :)
16:36:46 <johnw> adnap: State is awfully useful, but frankly I find more use for Reader
16:36:48 <adnap> Not for me
16:36:58 <Bor0> even if seq is as simple as (\a b -> b) I still want to understand how haskell does things in background. will a be evaluated in this case?
16:36:59 <merijn> Bor0: Assuming that neither f and g are bottom, then evaluating "f `seq` g" will evaluate both 'f' and 'g' in an unspecified order
16:37:10 <hashcat> Cale: did you mean i have to give up plugins and use hint?
16:37:15 <Cale> hashcat: I would
16:37:16 <adnap> I don't know what I must be doing to avoid using all these useful things
16:37:29 <adnap> Probably writing code that is way too long
16:37:39 <Cale> hashcat: I'm not sure if hint has an easy way to list the things in scope
16:37:45 <Peaker> adnap, counter<-get  gives current counter.  modify (+1)  applies (+1) on the current state.  ret
16:37:52 <Cale> hashcat: I'm sure it can be done with the GHC API
16:37:56 <Peaker> adnap, return (counter, val) just returns the counter we had and the old val
16:38:03 <adnap> Peaker: Yeah, I get the basic idea. I just need to check out the types
16:38:10 <Cale> hashcat: You might look to see how GHCi implements :browse
16:38:22 <Bor0> ok, that helps. thanks
16:38:36 <Peaker> adnap, get :: State s s   (It's a stateful computation in "State s" monad, and its result is the current state, so the result type is also "s")
16:38:38 <Bor0> merijn, can you also tell me what does bottom mean?
16:38:45 <finishingmove> does anyone have an idea what's the best way to calculate the prime factors of a given number?
16:38:59 <Peaker> adnap, modify :: (s -> s) -> State s ()      (applies (s->s) function on the current state, has no result)
16:39:11 <hashcat> Cale: ok, thanks
16:39:12 <prophile> finishingmove: if you find a way, do let me know :)
16:39:31 <merijn> Bor0: The simplest explanation is "undefined is bottom", more generally, "bottom" is a non-terminating computation (i.e. crash, infinite loop, etc)
16:39:39 <Cale> Bor0: Bottom is a value which represents nontermination of all sorts (including stopping the program entirely with an error message)
16:39:48 <finishingmove> OK
16:39:58 <Cale> Bor0: It is an element of every type
16:40:21 <Bor0> I see, great. that's good to know. thanks again
16:40:22 <Cale> (because Haskell has general recursion, you can't prevent people from writing infinite loops of any type)
16:40:23 <Peaker> adnap, so   (\val -> do { counter<-get ; modify (+1) ; return (counter, val) })   <-- is:  a -> State Int (Int, a)
16:40:36 <prophile> Cale: is that necessarily true?
16:41:03 <prophile> I mean, halting problem and all, but one could just put that unbounded recursion is undefined behaviour in a language spec and leave it at that
16:41:15 <adnap> Peaker: Please stop
16:41:16 <merijn> Bor0: Basically, I was just adding a disclaimer that you can't say anything useful about which value gets evaluated if one of the values crashes or infinite loops
16:41:30 <adnap> Peaker: I really want to understand MonadState first
16:41:49 <Peaker> adnap, don't study the class -- study the concrete type
16:41:50 <merijn> adnap: MonadState is separate from State, and not that interesting, tbh
16:42:01 <adnap> Peaker: You're using MonadState
16:42:01 <Cale> seq x y is bottom when x is bottom, and is y otherwise.
16:42:02 <johnw> MonadState is only useful if you are working with transformer stacks
16:42:07 <merijn> adnap: Look at Control.Monad.Trans.State
16:42:09 <adnap> Peaker: You're using get, modify, etc
16:42:13 <Bor0> merijn, what would be a good and easy way to test that (\a b -> b) will still evaluate a?
16:42:20 <Bor0> besides foldl' and foldl implementation
16:42:23 <Peaker> adnap, well, sure, but in a degenerate way, these could have been direct State primitives
16:42:36 <Cale> prophile: The definedness ordering on values tends to be important for analysis of nonstrict programs anyway
16:42:37 <merijn> adnap: There are two versions of get/modify/etc, one from Control.Monad.State, the other from Control.Monad.Trans.State. Look at the latter
16:42:56 <Peaker> adnap, It would be good practice to implement the State monad
16:42:57 <Cale> prophile: The theory is nice enough that you wouldn't want to just say that the behaviour is undefined altogether.
16:43:00 <adnap> merijn: There is no Control.Monad.Trans.State
16:43:02 <ion> get = state (\s -> (s, s)); modify f = state (\s -> ((), f s)); put x = state (\_ -> ((), x))
16:43:06 <prophile> Cale: fair enough
16:43:07 <merijn> adnap: uh...
16:43:10 <adnap> http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-Trans.html
16:43:21 <merijn> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State.html
16:43:34 <merijn> adnap: Wrong package, it's defined somewhere else
16:43:46 <merijn> Actually, you probably want: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html
16:43:53 <adnap> Ahhhh
16:43:59 <Peaker> adnap, "transformers" is the lower-level package, with the concrete monad transformers
16:44:03 <Cale> adnap: Don't worry if you never use the State monad, it's pretty rare that you actually need the plain one.
16:44:12 <Peaker> adnap, "mtl" wraps that with ugly-as-heck classes that do auto-lifting
16:44:14 <adnap> I'm so lost
16:44:31 <Cale> adnap: Would you like an introduction to the State monad?
16:44:32 <Peaker> adnap, write the State monad
16:44:46 <Cale> I can go over it with you in #haskell-overflow or something :)
16:44:51 <adnap> I have read about the State monad in LYAH, but I have never seen MonadState or...
16:44:56 <merijn> Bor0: tbh, I don't really know
16:44:57 <adnap> StateT
16:45:01 <Peaker> adnap, newtype State s a = State { runState :: s -> (a, s) } ; instance Monad (State s) where ... <fill this in> ...
16:45:05 <Cale> adnap: Okay
16:45:07 <ion> adnap: Ignore MonadState and StateT for now.
16:45:20 <adnap> And I never use State, so I don't remember it well
16:45:23 <merijn> adnap: StateT is a generalisation of State and MonadState is ugly boilerplate to make working with StateT simpler/nicer
16:45:24 <ion> Just think of the plain State with non-polymorphic get/put/modify.
16:45:36 <Bor0> merijn, I'm just following lyah and he mentions how foldl can cause stack overflow while foldl' shouldn't. I just want to see a simple example of this
16:45:54 <Bor0> his example in the book with foldl doesn't cause a stack overflow on my machine
16:46:09 <merijn> Bor0: Just increase the numbers by a bit :p
16:46:22 <merijn> Anyway, it's about bed time for me, so I can't help you atm
16:46:23 <adnap> ion: The plain state doesn't seem to have get, put, modify
16:46:28 <johnw> Cale: I bet that execState + traverse_ could make it easy to write some pretty complex folds that would be horrendous looking otherwise
16:46:36 <Bor0> ok, good night. thanks for all the help :)
16:46:46 <adnap> Is http://hackage.haskell.org/package/mtl-2.1.2 the wrong package to look at?
16:46:54 <Cale> Bor0: oh, sure
16:46:56 <johnw> adnap: I'd look at the transformers package
16:47:05 <johnw> mtl is some higher-level stuff on top
16:47:11 <adnap> I'm looking for the basic State with get, put, and modify
16:47:14 <Cale> Bor0: let's consider  foldl (+) 0 [1,2,3]  and see what evaluation does
16:47:17 <johnw> yeah, transformers has it
16:47:18 <Cale> @src foldl
16:47:18 <lambdabot> foldl f z []     = z
16:47:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:47:22 <Cale> foldl (+) 0 [1,2,3]
16:47:31 <Cale> -> foldl (+) (0 + 1) [2,3]
16:47:40 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
16:47:42 <adnap> Also, why is Google always returning old versions of Hackage docs. It's so annoying
16:47:46 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
16:47:53 <ion> adnap: This may or may not be helpful: http://heh.fi/state-monad
16:47:53 <Cale> -> ((0 + 1) + 2) + 3
16:48:02 <johnw> adnap: State is essentially (s -> (a, s)).  If I give you that type, can you figure out how to write get/put/modify?
16:48:17 <Cale> Up to this point, the stack space which will have been used is pretty much none
16:48:31 <Cale> (or maybe one space, while foldl pattern matches on the list)
16:48:51 <adnap> get f s = runState f s
16:48:53 <johnw> @unmtl State a b
16:48:53 <lambdabot> a -> (b, a)
16:49:00 <johnw> @unmtl State s a
16:49:01 <lambdabot> s -> (a, s)
16:49:07 <Cale> But now we have (...) + 3, and (+) going to have to match both its arguments before it can produce its result
16:49:11 <adnap> Er...
16:49:11 <johnw> adnap: without using runState :)
16:49:20 <johnw> using *only* the knowledge of that type
16:49:34 <adnap> get (State f) = snd . f
16:49:38 <Cale> So this pattern match goes on the stack while we evaluate (0 + 1) + 2
16:49:45 <adnap> Err
16:49:48 <adnap> get (State f) = fst . f
16:49:56 <johnw> for example, the type of get would be: get :: s -> (s,s)
16:50:06 <Cale> and then similarly, that (+) will pattern match its arguments, and the match will go on the stack while we evaluate (0 + 1)
16:50:08 <Peaker> adnap, get isn't a function, it has no argument
16:50:19 <adnap> I don't know what it is
16:50:21 <Bor0> Cale, excellent, can you please show analogous example with foldl'
16:50:24 <Gracenotes> well, get is a function just by merit of being a State
16:50:25 <Peaker> adnap, get :: State s s
16:50:26 <Cale> and finally that will evaluate to 1, and then 1 + 2 will evaluate to 3, and then 3 + 3 will evaluate to 6
16:50:26 <adnap> I thought it gets the a in s -> (a, s)
16:50:33 <johnw> no
16:50:38 <adnap> I need the documentation...
16:50:39 <johnw> i'm just unwrapping the type to show the concept
16:50:44 <johnw> but maybe you should do the wrapped version
16:50:46 <adnap> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-State-Lazy.html
16:50:46 <johnw> get :: State s s
16:50:50 <adnap> This just has StateT!
16:50:53 <Cale> If the list had been a million elements long, the large expression which built up would consume a lot of stack space to evaluate
16:51:04 <johnw> State s a = StateT s Identity a
16:51:09 <Peaker> adnap, ignore it, just use:  newtype State s a = State { runState :: s -> (a, s) }
16:51:11 <adnap> Ahhhh
16:51:23 <johnw> yeah, what Peaker said
16:51:23 <adnap> What am I doing?
16:51:25 <Peaker> adnap, and first, try to write the Monad instance
16:51:36 <adnap> I don't even know the types of get, put, and modify
16:51:38 <Peaker> adnap, and then, try to implement:  get :: State s s ; put :: s -> State s ()
16:51:47 <Cale> @src foldl'
16:51:47 <lambdabot> foldl' f a []     = a
16:51:47 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:51:47 <Peaker> adnap, modify :: (s -> s) -> State s ()
16:51:54 <johnw> adnap: I'll start the first one for you: get = State $ \s -> (s,s)
16:51:58 <johnw> now try put
16:52:04 <adnap> Is there just a web page of them for the basic State? I don't want to have to copy everything from IRC to a file
16:52:23 <Cale> A little lie we can tell ourselves is that the a' parameter to foldl' will be evaluated before recursing
16:52:34 <Cale> This isn't necessarily quite true
16:52:38 <Gracenotes> adnap: Monads are all about combining expressions of type State s a, for a bunch of different 'a', and then running what you get when you combine every thing (which is also a State s something)
16:52:40 <johnw> the role of get is to pass the state value through as the result value
16:52:45 <Gracenotes> well, state monads.
16:52:55 <johnw> adnap: https://gist.github.com/5914311
16:53:02 <johnw> that's the implementation I wrote when I was learning State
16:53:08 <Cale> It's valid for the compiler to evaluate the foldl' first, but the seqs in any case will ensure that the expression is evaluated in an order which makes the stack usage low.
16:53:15 <Gracenotes> So everything interesting you do want to do in the State monad should be of type 'State s a', for some a. a could be (), like it is for put, or s, like it is for get.
16:53:21 <Bor0> Cale, now that confused me even more :)
16:53:22 <adnap> :(
16:53:29 <hpaste> Peaker pasted “State exercise” at http://paste.tryhaskell.org/90654
16:53:35 <Peaker> adnap, ^^
16:54:12 <Bor0> so seq basically does stack magic behind the scene? it is not correct to say that a `seq` b will always evaluate a then b?
16:54:19 <Peaker> adnap, don't look at the solutions, solve the exercise I pasted
16:54:30 <Peaker> Bor0, it isn't correct
16:54:35 <Cale> Bor0: It could evaluate b, then a, before producing the result of evaluating b.
16:54:49 <Peaker> Bor0, I think pseq does have that guarantee
16:55:08 <adnap> Peaker: Thanks, I will work on this
16:55:09 <Cale> Bor0: The important thing is just that it ensures a is evaluated prior to the result of evaluating b being available to pattern match on.
16:55:19 <adnap> I get overloaded when I can't focus on one thign
16:55:43 <Moggle_> suddenly the mists of haskell part from my mind and RankNTypes makes a glimmer of sense
16:55:49 <Cale> Bor0: This is kind of annoying to think about sometimes, so it can be a nice simplification to just pretend that it means "evaluate a first, then b"
16:55:56 <Moggle_> progress! slow, slow progress on the codensity transform.
16:56:02 <Gracenotes> seq essentially ensures that a case statement you run on 'a' will be more of a lookup, rather than a lot of computation. (i.e. it does that computation)
16:56:14 <Bor0> oh, I see, but, if the order of evaluating doesn't matter, won't that remain haskell being lazy? that is, if we have (seq a (seq b (seq c))) and we are not sure of order of evaluation
16:56:20 <johnw> Moggle_: where are you at with understanding codensity?
16:56:23 <Cale> Bor0: But it's important to note that:  seq x (seq y z) is the same as  seq y (seq x z)
16:56:26 <Bor0> or are you saying that it guarantees evaluation before pattern match
16:56:30 <Cale> and seq x x is the same as x
16:56:59 <Moggle_> johnw: doing this problem set, and it wants me to write a CTree with abstracts the leafs into functions. It used a rank 2 type signature and it confused me and it still sort of does, thinking on it.
16:57:11 <Moggle_> http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
16:57:14 <Moggle_> I'm getting there slowly!
16:57:15 <Cale> and seq x (seq y z) is the same as seq (seq x y) z
16:57:26 <johnw> Moggle_: one way to think of rank 2 is that the callee decides the type, instead of the caller
16:57:46 <Peaker> Bor0, "seq" is a hint to ghc that a value is safe to be strict about at some point, so it can avoid laziness (or if it can prove it is non-bottom, not avoid it)
16:58:06 <Cale> Bor0: and so the compiler is allowed to do whatever it likes to rearrange evaluations on us, if it thinks it knows better
16:58:10 <Gracenotes> [4~if you run a case statement on 'b' in (a `seq` b), Haskell will basically do a one-level pattern match on 'a', regardless of the type... but if you don't, it won't.
16:58:25 <Moggle_> johnw: yes, I think I see what you mean.
16:58:39 <Bor0> oh, right, optimization tricks. ok great, one more thing, can we really define seq as (\a b -> b) or it has some scary implementation behind?
16:58:41 <Gracenotes> At least it will in the ideal world in which everything is a command rather than a hint
16:59:00 <Cale> Bor0: (\a b -> b) wouldn't have the right semantics when a is bottom
16:59:09 <Cale> > (\a b -> b) undefined 1
16:59:10 <lambdabot>   1
16:59:11 <adnap> It is so annoying that the order of the types in the State type is backwards from the order of the values in the tuple
16:59:14 <Cale> > seq undefined 1
16:59:15 <lambdabot>   *Exception: Prelude.undefined
16:59:31 <Cale> adnap: It *is* annoying
16:59:48 <Cale> adnap: It's a little mistake in mtl
16:59:53 <Gracenotes> Bor0: I mean, it matches constructors, or numbers. so seq on a list will reduce it to either (:) or []; seq on an integer will reduce it to 0, 1, 2, 3, 4, ...
17:00:09 <Gracenotes> if you just have a named argument, that doesn't do anything to evaluation directly
17:00:14 <Peaker> Cale, in transformers
17:00:24 <Cale> Peaker: Well, okay.
17:00:36 <Cale> Peaker: transformers didn't exist when the mistake was made :P
17:00:45 <Bor0> @src seq
17:00:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:00:53 <Cale> Bor0: seq is primitive
17:00:55 <Peaker> someone in #haskell once defended that order by appealing to (>=>)   looking like: (a, s) -> (a, s)
17:01:06 <Cale> Bor0: It could be implemented for specific types by pattern matching
17:01:19 <Gracenotes> foldl' is especially useful for numbers, because you have guaranteed constant space on the accumulator (once you get to 0, 1, 2, etc., there's nothing else you need to know about it)
17:01:26 <Bor0> Cale, can you please show me such a small example?
17:01:27 <shachaf> Peaker: And why not (s, a) -> (s, a)?
17:01:30 <Cale> For example, you could implement it for Maybe by  seq x y = case x of Nothing -> y; Just v -> y
17:01:57 <Peaker> shachaf, because >=> is defined in terms of >>=,  and >>= is (s -> (whatever you choose here)), >>= forces "last" arg to be "s"
17:02:05 <Cale> Bor0: However, this wouldn't work for function types
17:02:07 <Bor0> Cale, and case is what evaluates stuff in that case?
17:02:11 <Cale> Yeah
17:02:28 <Bor0> great! ok, I think I have a basic clear of it now, thank you both Cale and Gracenotes
17:02:42 <Cale> At some level, case expressions can be seen as the fundamental reason why any evaluation happens.
17:02:49 <Gracenotes> case is what evaluates stuff in most cases :) you're forced to pick one of the options. But.. yeah.. there is the distinction between WHNF and HNF, etc.
17:02:52 <shachaf> Peaker: You're uncurrying anyway, so it's not as if it's anything other than an isomorphism.
17:02:52 <Gracenotes> that's a bit messy though
17:02:56 <johnw> Moggle_: Say you have foo :: (a -> b) -> b.  When when I call foo, I have to pass it a specific function, like String -> Int, in which case a ~ String and b ~ Int.  But if I have bar :: (forall a. a -> b) -> b, then I *have* to pass in a polymorphic function, like a -> Int.  bar can then call that with any function that yields a 'b'.  This is sort of a contrived example, but you can see that rank 2 means that bar is a polymorphic
17:02:57 <johnw> function (in b) that accepts a polymorphic function (in a), whereas without rank 2, bar is a polymorphic function that simply accepts a non-polymorphic function
17:03:00 <Peaker> shachaf, I agree
17:03:06 <Cale> (You need to evaluate the scrutinee to determine which pattern matches)
17:03:39 <Cale> adnap: Would you like to go over the State monad and its friends?
17:03:39 <shachaf> Peaker: My counterargument is that, like, adjunctions and stuff, man.
17:03:57 <ion> dude!
17:04:02 <shachaf> Peaker: More importantly, Writer is forced into this order.
17:04:22 <Cale> ion: dude?
17:04:31 <shachaf> newtype Writer w a = Writer { runWriter :: (a,w) } -- i mean, like, come on, man
17:04:39 <Cale> aw man
17:04:47 <Peaker> yeah, I know
17:04:49 <Gracenotes> that's pretty deep, shachaf
17:04:55 <byorgey> woah
17:05:22 <Peaker> shachaf, devil's advocate would throw "you're unwrapping a newtype anyway, so it's just an isomorphism", but I'm actually on your side
17:05:31 <ion> newtype WriterT w m a = WriterT { runWriterT :: m (a,w) } -- They’re all out of order. D-:
17:05:37 <Bor0> would this naughty hack remove laziness: foldl f z (x:xs) = if z == z then foldl f (f z x) xs else foldl f (f z x) xs
17:05:41 <Moggle_> johnw: Sense is made! Thank you. RankNTypes seems fairly simple to understand after that, it just lets you go deeper as it were.
17:05:52 <johnw> Moggle_: yep
17:06:03 <Cale> Bor0: that would work, but it would induce an Eq constraint and lots of extra work
17:06:32 <prophile> if z == z?
17:06:35 <Cale> Bor0: for example, if z happened to be an infinite list, that would not terminate
17:06:37 <Bor0> yeah I thought of that, just trying to get a grasp of how if/case work in background. this raised so much questions to me but I think I'm okay now :P
17:07:01 <shachaf> Peaker: The newtype doesn't even have to exist, though.
17:07:13 <acowley> the 'impossible' happened: kindFunResult
17:07:13 <Cale> While seq z ... would terminate (it would only evaluate up to the first cons cell)
17:07:22 <shachaf> > do { ("hi",()); ("ho",()) }
17:07:23 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
17:07:23 <lambdabot>    arising from a d...
17:08:06 <shachaf> @let instance Monoid w => Monad ((,) w) where { return x = (mempty,x); (w,x) >>= f = let (w',y) = f x in (w <> w', y) }
17:08:07 <lambdabot>  Defined.
17:08:09 <shachaf> > do { ("hi",()); ("ho",()) }
17:08:12 <lambdabot>   mueval-core: Time limit exceeded
17:08:23 <shachaf> thanks lambdabot
17:08:27 <hpaste> adnap annotated “State exercise” with “State exercise (annotation)” at http://paste.tryhaskell.org/90654#a90655
17:08:28 <Gracenotes> you're really letting us down
17:08:34 <shachaf> > do { ("hi",()); ("ho",()) }
17:08:37 <lambdabot>   ("hiho",())
17:09:04 <Cale> adnap: You're missing a runState or two in the definition of (>>=)
17:09:15 <adnap> Cale: Oh
17:09:21 <byorgey> just because people were being silly and saying things like "like, adjunctions and stuff, man." "dude." etc.
17:09:30 <acowley> If I have a pipe over IO, and I want to lift it to be over (WriterT [Foo] IO), I thought I'd write hoist (WriterT . fmap (,mempty))
17:09:30 <byorgey> oops, wrong window =)
17:09:36 <acowley> But that didn't work
17:09:52 <acowley> byorgey: Your windows are too similar in content
17:09:52 <Gracenotes> riiiight
17:10:11 <johnw> acowley: I thought I'd missed something really deep when I saw byorgey say "woah", so I asked directly :)
17:10:14 <shachaf> byorgey: Hmm, I wonder what window that was supposed to go to.
17:10:26 <shachaf> Ah.
17:10:35 <byorgey> acowley: probably.  I should lurk in ##c or something to get more of a variety
17:10:36 <adnap> http://paste.tryhaskell.org/90654
17:10:41 <acowley> Well that's not nearly as exciting as I'd hoped
17:10:48 <adnap> Er... whatever
17:11:02 <acowley> I assumed byorgey was in ##CategoriesYouProbabalyHaventHeardOf
17:11:02 * hackagebot hatex-guide 1.0 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.0 (DanielDiaz)
17:11:12 <adnap> Now, I'm an Anonymous Coward
17:11:17 <ion> #haskell-meta?
17:11:43 <byorgey> the category whose objects are IRC channels and whose morphisms are mispastes
17:12:09 <adnap> Peaker: ^
17:13:23 <byorgey> adnap: looks good to me
17:13:40 <shachaf> Cale: Did you ever prove that isomorphism?
17:14:09 <Cale> shachaf: no, I didn't really work on it any further
17:14:14 <acowley> I answered my own question
17:14:21 <shachaf> You should do it by proving the uniqueness of cata.
17:14:28 <shachaf> (cata the F-algebra morphism.)
17:14:32 <acowley> I needed to write "hoist g . oldproxy"
17:14:48 <acowley> My old code, gooby = hoist g oldproxy, made GHC panic and die
17:15:29 <Peaker> adnap, you can define infix methods with infix syntax:
17:15:36 <Peaker> adnap, x >>= f = ...
17:15:48 <Cale> shachaf: But I don't know that the fmap is an application of cata
17:16:00 <Peaker> adnap, did you try compiling this?
17:16:05 <Cale> shachaf: That might work for specific functors...
17:16:16 <Peaker> adnap, oh I see there's another annotation
17:16:16 <shachaf> Cale: ?
17:16:41 <adnap> Peaker: No, I didn't compile it
17:16:43 <Peaker> adnap, if you use: State x >>= f = ... you save a runState, and it's prettier
17:16:48 <shachaf> Cale: I mean by proving that (Mu F, addMuF) is an initial algebra.
17:16:54 <adnap> I never write infix functions, so I forgot about this
17:16:58 <Peaker> adnap, your put is broken
17:17:27 <adnap> Peaker: Oh, that's a typo
17:17:34 <adnap> I meant x instead of s
17:17:35 <Cale> shachaf: oh, hmm
17:17:46 <Peaker> adnap, try to build it to make sure it's type-checked
17:18:05 <Peaker> adnap, add to that our "data Tree a = .." from above and your "traverse f .." on the Tree
17:18:14 <Peaker> adnap, and see if you can tag a Tree with those running indexes
17:18:37 <adnap> Huh?
17:18:50 <Cale> Peaker: I disagree that it's prettier
17:19:04 <Cale> Much nicer to consistently use runState, imo :)
17:19:08 <adnap> I wish I could understand people who don't communicate everything specifically
17:19:31 <adnap> I'm so bad at carrying the context through a conversation
17:20:09 <ion> runState = unsafeCoerce
17:20:09 <Cale> adnap: That's why you should have taken my advice at the beginning and joined #haskell-overflow so that I could go over this construction without flooding the channel :P
17:21:06 <adnap> Cale: I missed you saying that
17:21:18 <Cale> It's okay :)
17:22:02 <Cale> If you want, I can still go over how I'd think about the process, but it looks like you've done an okay job of defining the stuff yourself.
17:22:02 <adnap> I'm glad I'm free to be an idiot in this channel
17:22:16 <johnw> no, we charge
17:22:54 <johnw> we require that you help others understand the things you had trouble with when the time comes :)
17:23:04 <ion> sa >>= f = unsafeCoerce $ \s -> let (a, s') = unsafeCoerce sa s in unsafeCoerce (f a) s'
17:23:28 <adnap> I don't mean not understanding things. I mean failing at IRC etiquette
17:23:33 <johnw> ion: ahh, the days of defining (>>=) using unsafeCoerce, what a time that was :)
17:23:57 <adnap> Well, people seem to be more tolerant of others not understanding things in here too
17:24:20 <johnw> adnap: that is part of what this channel is about
17:24:43 <Cale> adnap: Actually, let's do parsers and then StateT, in #haskell-overflow
17:25:18 <adnap> I have to go... dammit
17:25:31 <Cale> Well, if you'd like, when you get back, ping me :)
17:25:43 <adnap> I'm not sure where Peaker was going with all this
17:26:02 <Cale> oh, your put was broken
17:26:07 <adnap> Cale: I fixed it
17:26:09 <Cale> oh, right, yeah
17:26:18 <adnap> I saved Peaker's Tree/State example though
17:26:32 <adnap> So when I come back, I'll ask what the hell this has to do with the lens package
17:26:45 <adnap> Which was my original interest
17:27:11 <ion> adnap: You might already figure it out from my examples. They should look familiar now, since you have defined a traverse.
17:27:44 <adnap> ion: Oh crap. I'm going to have to go through my logs to dig out everything you said
17:29:11 <ion> adnap: Note the similarity between _1, both and your traverse.
17:34:21 <bel3atar> is Maybe a keyword?
17:34:31 <byorgey> nope
17:34:49 <byorgey> it's a type which is defined in Data.Maybe, and also re-exported by the Prelude
17:35:09 <byorgey> but it's not a keyword, just a plain old Haskell definition
17:35:29 <Hafydd> do { maybe print "hello"; maybe print "world" } -- nondeterministic programming
17:35:41 <johnw> bel3atar: Haskell has surprisingly little real syntax, and very few keywords
17:35:46 <ion> @type maybe print "hello"
17:35:46 <lambdabot>     Couldn't match expected type `a0 -> a1 -> IO ()'
17:35:47 <lambdabot>                 with actual type `[Char]'
17:35:47 <lambdabot>     In the second argument of `maybe', namely `"hello"'
17:39:27 <johnw> bel3atar: what Hafydd wrote was a joke, not valid Haskell
17:41:22 <DanielDiaz> hello, I am getting error doing "cabal install" in my package saying that "could not find module `Paths_my_package`"
17:41:45 <DanielDiaz> the thing is that I have included `Paths_my_package` in the Other-modules section
17:41:49 <DanielDiaz> in the cabal file
17:41:49 <mapreduce> Given that every function in http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html is deprecated, saying that Lazy's api and some of Strict's api are exported, how can I see what exactly is available?
17:42:22 <DanielDiaz> so... I do not know what I am doing wrong
17:42:42 <DanielDiaz> funny fact: it was building successfuly some minutes ago...
17:44:42 <DanielDiaz> mapreduce: well... according to that module... it looks like (apart from deprecated functions) you have exactly the same that Data.Map.Lazy
17:44:42 <johnw> DanielDiaz: did you cabal clean and try again?
17:44:43 <enthropy> mapreduce: that link to 'Lazy' should have pointed to http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html
17:45:21 <DanielDiaz> johnw: interestingly, "cabal clean" gives me the same error
17:45:35 <mapreduce> enthropy: I see.. well it doesn't. ;)
17:45:42 <enthropy> DanielDiaz: I think you get Paths_my_package without including it in Other-modules
17:46:02 <johnw> DanielDiaz: whoa
17:46:20 <mapreduce> DanielDiaz: Are you seeing that from the source code, or from the documentation I linked to?
17:46:40 <enthropy> the source code has -- This module re-exports the value lazy 'Data.Map.Lazy' API,
17:46:42 <DanielDiaz> mapreduce: from the documentation you linked to
17:46:50 <enthropy> it should have been    "Data.Map.Lazy"
17:47:15 <mapreduce> DanielDiaz: "This module re-exports the value lazy Lazy API, plus several value strict functions from Strict."
17:47:35 <mapreduce> How can I see which things from strict, given that there's nothing mentioned on that page besides deprecated functions?
17:48:04 <DanielDiaz> mapreduce: OK, but if you look below, you see the things that are actually exported... between them, "module Data.Map.Lazy", insertWith' , etc
17:48:39 <mapreduce> Ah, I didn't get that where it says module Data.Map.Lazy that was the export list.  Thanks.
17:48:40 <DanielDiaz> mapreduce: I guess that all these functions with a prime (') are the "strict functions" the text above refers to
17:56:43 <Guest55594> Can someone explain to me how I would use free monad transformers. I tried to use FreeT f IO but I have no way of really escaping it, like is it possible to convert FreeT f IO a to IO (FreeF f a) with known type?
17:56:47 <Guest55594> *s
17:57:33 <Guest55594> On the haskell for all post about free monads he used it to collect output by printing things but didn't really keep anything
17:58:50 <Guest55594> and then instead of addressing it it seems like he goes off on a tangent
17:59:50 <Twiceler> I have a quick convenience question. I have functions f :: a -> b -> c and g: c-> d and I want to compose them with a function dot2 where (g `dot2` f) x y = g (f x y). I've defined it myself, but is there a built in version of this?
18:00:50 <Guest55594> I believe you can make one out of combinators like (.).(.) or something like that (probably not it)
18:01:07 <Guest55594> yeah flip (.).(.) should be it
18:01:09 <Demos_> presumably known as the boob combinator
18:01:16 <Cale> Just (.) . (.) is it
18:01:20 <Guest55594> or not
18:01:32 <Cale> @pl \g f x y -> g (f x y)
18:01:33 <lambdabot> (.) . (.)
18:01:49 <Cale> @pl \x y -> g (f x y)
18:01:49 <lambdabot> (g .) . f
18:02:14 <Cale> You can do that in specific cases, but usually I'd just use a lambda
18:02:17 <Twiceler> Yep, it's (.) . (.), thanks! And I see how that generalizes to functions of more variables
18:02:46 <prophile> Twiceler: the owl operator
18:02:47 <Twiceler> Cal: Yeah, I just defined it "pointwise" before I guess
18:03:09 <DanielDiaz> if I am using a custom Setup.hs build... how do I add the Paths_my_package.hs module so it is available from other modules?
18:03:32 <Hafydd> @pl \u v w x y z -> j (i (h (g (f u v w x y z)))
18:03:32 <lambdabot> (line 1, column 45):
18:03:32 <lambdabot> unexpected end of input
18:03:32 <lambdabot> expecting variable, "(", operator or ")"
18:03:38 <Hafydd> @pl \u v w x y z -> j (i (h (g (f u v w x y z))))
18:03:38 <lambdabot> ((((((j . i . h . g) .) .) .) .) .) . f
18:04:06 <Guest55594> :t (.).(.).(.).(.).(.).(.).(.).(.)
18:04:06 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> c
18:26:03 * hackagebot shelly 1.3.0.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.0.2 (GregWeber)
18:39:15 <CaptainK> how can I take a ["HELLO"] and make ["OLLEH"]
18:39:31 <CaptainK> reverse only works on "HELLO"
18:40:15 <codesoup> > reverse . head $ ["HELLO"]
18:40:16 <lambdabot>   "OLLEH"
18:40:35 <codesoup> oh you want it in a list
18:40:47 <codesoup> > map reverse ["HELLO"]
18:40:48 <lambdabot>   ["OLLEH"]
18:40:59 <CaptainK> ah map of course
18:41:07 <CaptainK> still a newbiw to the map function
18:41:43 <CaptainK> > map reverse ["NEWBIE"]
18:41:44 <lambdabot>   ["EIBWEN"]
18:41:51 <CaptainK> :))
18:42:35 <mapreduce> > map reverse ["also","available","on","longer","lists"]
18:42:36 <lambdabot>   ["osla","elbaliava","no","regnol","stsil"]
18:42:44 * CaptainK thinks more that as a newbie its best to stay inside PRELUDE for a while
18:42:55 <mapreduce> My favourite Eastern European tennis player ^^
19:01:08 <shachaf> What's a good name for gcast Refl?
19:01:09 <shachaf> :t gcast Refl
19:01:10 <lambdabot> (Typeable a, Typeable b) => Maybe (Is a b)
19:03:48 <CaptainK> I have a block of code i'd like to run for every element in a list, ithinking cycle or takewhile, is there a nice way to loop?
19:04:18 <orzo> forM_
19:04:33 <orzo> map
19:12:22 <CaptainK> > sequence map ["TEST","HELP","WOW"]
19:12:23 <lambdabot>   Couldn't match expected type `[[[GHC.Types.Char]] -> a0]'
19:12:23 <lambdabot>              with...
19:14:43 <edvardkk> what kind of code block, CaptainK?
19:16:07 <edvardkk> sequence is for monadic code, like, say, if you have a list of printing actions that you want to combine to one :)
19:17:49 <CaptainK> I would like that also, (combine print statements)
19:18:27 <edvardkk> then you can use sequence!
19:19:01 <edvardkk> fex. sequence_ (replicate 5 $ print "meh")
19:19:11 <CaptainK> say I have a value ["TEST","HELP"...nth] when the list is finished I want to stop calculating my block of code
19:19:58 <edvardkk> hmm, I don't understand exactly what you mean
19:21:53 <Nisstyre> CaptainK: maybe there's something here you could use http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html
19:23:08 <c_wraith> I get the feeling CaptainK is really looking for mapM_
19:23:39 <Nisstyre> c_wraith: maybe
19:23:50 <Nisstyre> I don't know the context well enough, but that seems like a fit
19:23:52 <CaptainK> I've used mapM_ in putStrLn
19:24:06 <CaptainK> this is also used to loop some code?
19:24:13 <edvardkk> yes. maybe you should look at sequence, mapM, forM, the _ variants, and forever first CaptainK
19:24:14 <c_wraith> mapM_ is a loop
19:24:38 <CaptainK> looking at it, looks powerful
19:24:40 <c_wraith> forM_ is equivalent, but sometimes easier to work with
19:24:58 <CaptainK> and formM_ is sequence map?
19:25:10 <c_wraith> like, if you want to do something like...  forM_ allValues $ \val -> do ....
19:25:24 <johnw_> CaptainK: mapM ... is sequence $ map ...
19:25:43 <c_wraith> it lets you nicely write a little IO action in-line, that works on each element in a list
19:25:46 <CaptainK> and return?
19:26:00 <Lamen> @ty sequence
19:26:00 <lambdabot> Monad m => [m a] -> m [a]
19:28:00 <CaptainK> that collection of loop operators is comprehensive to say the least
19:28:41 <johnw_> CaptainK: and in various libraries there are many more
19:29:14 <carter> johnw_ you may like this trac ticket i just posted http://hackage.haskell.org/trac/ghc/ticket/8033
19:29:48 <johnw> sweet!
19:30:16 <johnw> does this mean SHA256 can be computed using a single register? :)
19:31:24 <carter> johnw …. idk
19:31:33 <carter> if haswell has it, sure
19:31:48 <carter> you can do AESNI
19:31:50 <carter> whatever that is
20:07:11 <shachaf> Hmm, ScopedTypeVariables is kind of weird. The type oughtn't really be related to the definition at all.
20:13:29 <Rarrikins> What's a function that gives every possible choice of one element from each of several input lists?
20:14:16 <Rarrikins> Like [[1, 2], [3, 4]] -> [[1, 3], [1, 4], [2, 3], [2, 4]]
20:14:32 <ion> shachaf++ for oughtn’t
20:15:22 <nimish> Rarrikins: you could probably contort the list monad into something that gets what you need
20:15:29 <bscarlet> > [ (a,b,c,d) | a <- [1,2], b <- [3,4], c <- [5,6], d <- [7,8] ]
20:15:31 <lambdabot>   [(1,3,5,7),(1,3,5,8),(1,3,6,7),(1,3,6,8),(1,4,5,7),(1,4,5,8),(1,4,6,7),(1,4...
20:15:50 <bscarlet> nimish: it's not a contortion
20:16:09 <ion> > sequence [[1,2], [3,4]]
20:16:10 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
20:16:17 <Rarrikins> Ahh, thanks :)
20:16:20 <nimish> bscarlet: now do it with input lists that aren't the same size
20:16:49 <bscarlet> > [ (a,b,c,d) | a <- [1,2,10], b <- [3,4], c <- [5,6], d <- [7] ]
20:16:50 <lambdabot>   [(1,3,5,7),(1,3,6,7),(1,4,5,7),(1,4,6,7),(2,3,5,7),(2,3,6,7),(2,4,5,7),(2,4...
20:16:51 <ion> nimish: The size won’t affect it.
20:18:30 <nimish> ion: your approach won't be affected but bscarlets would
20:18:45 <bscarlet> nimish: no
20:18:55 <ion> nimish: Ah, you meant the top-level list, not the inner ones.
20:19:54 <nimish> but the implementation of sequence is some pretty slick monadery
20:20:25 <bscarlet> nimish: I gave the example, what's the problem?
20:20:38 <nimish> now do it with 5 sublists or 6
20:20:40 <nimish> or 3
20:20:50 <nimish> ion's works with any number of inner lists
20:22:00 <edvardkk> > sequence [[1,2], [3,4], [5,6]]
20:22:01 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
20:22:13 <kamatsu> hm
20:22:33 <kamatsu> i find myself reaching for something like: also :: Lens' a b -> Lens' a c -> Lens' a (b,c)
20:22:37 <bscarlet> nimish: Sure. They both use the list monad, and if the goal is to flexibly handle a variable number of lists, that's the way to do it.
20:22:47 <kamatsu> assuming that the two input lenses are not overlapping.
20:23:00 <kamatsu> but this is in general unsafe, because if they do overlap the lens laws are not satisfied.
20:23:10 <kamatsu> is there a more principled way to get what I want?
20:24:23 <bscarlet> nimish: One way or the other, the point is that taking all choices from various lists is the essence of the list monad.
20:25:36 <nimish> bscarlet: yeah i like to think of it as the nondeterminism monad
20:26:38 <bscarlet> nimish: yep
20:33:52 <seydar> so i've been reading through basic category theory for computer scientists, and i've got a few questions about how it all relates to haskell
20:34:16 <seydar> not that i'm daring to call category theory "applicable", but...
20:34:44 <seydar> a functor is something that takes one category and turns it into another category. is that correct?
20:35:14 <ninegrid> it is "applicable" ;)
20:35:36 <johnw> seydar: correct
20:35:43 <johnw> it maps between categories
20:35:49 <seydar> ok cool. this is good news.
20:36:06 <seydar> actually lemme grab my book. instead of going to bread i will ask you all quesitrons
20:36:09 <johnw> I wouldn't say it "turns into another category", since the destination category may be larger than the image of the functor
20:38:28 <seydar> ooh that's a good point. i was totally on board with the cardinality business in the land of theory, but in the land of the real world i'm a lil confused
20:38:44 <johnw> well, in Haskell you're going to be dealing with endofunctors
20:38:57 <johnw> functors that map from the category of Haskell types, Hask, back to that same category, Hask
20:39:23 <johnw> and Hask has its oddnesses, many of which you can ignore for a little while, but they are there
20:39:43 <dolio> 'Turning things into other things' may be a suspect way of thinking about mathematical functions in general, too.
20:40:08 <seydar> ok so let's correct my intuition
20:40:24 <seydar> how is a better way to phrase it?
20:40:41 <ninegrid> relates
20:40:47 <johnw> one way of thinking of it is that it associates objects and morphisms in one category, with the image of those objects and morphisms in the other categories
20:40:54 <dolio> Well, for instance (\x -> x + 1) doesn't 'turn 1 into 2'.
20:40:58 <Cale> seydar: A functor F: C -> D consists of two things: a mapping which sends objects X in C to objects FX in D, and a mapping which sends each arrow a: X -> Y in C, to an arrow Fa: FX -> FY in D, such that for every object X in C, we have F(id_X) = id_(FX) and for every composable pair of arrows a, b, we have F(a.b) = Fa . Fb
20:41:13 <dolio> 1 and 2 are just things that exist, and when given 1, the function gives back 2, or something of the sort.
20:41:18 <dolio> Or it relates 1 to 2.
20:42:01 <dolio> Maybe it builds 2 out of 1.
20:42:07 <seydar> ninegrid, johnw, dolio, Cale: thank you
20:42:08 <dolio> But it doesn't change 1 into 2.
20:42:22 <Cale> Another way to think about this last condition is that the image of any commutative diagram in C (applying the functor to each of the objects and arrows in the diagram), will be a commutative diagram in D.
20:42:30 <dolio> In the sense that your existing 1s don't become 2s.
20:42:44 <seydar> i need to practice speaking with immutability
20:43:13 <Cale> I like the terminology "sends 1 to 2"
20:43:20 <ninegrid> seydar: this might be suspect as well, but i originally come from database programming... sometimes i think of a function as looking up a value based on a key (not necessarily a unique one)... i think of it that way because the function has a "full spectrum" to it, and not just the mechanics of relating two literal values
20:43:30 <ion> kamatsu: Hmm. Would this not satisfy the Traversal laws? Can’t make it a Lens, though, due to the (<*>). foo :: Applicative f => LensLike f s t0 a b -> LensLike f s t1 a b -> LensLike f s (t0,t1) a b; foo la lb f x = (,) <$> la f x <*> lb f x
20:43:47 <dolio> Sends is good.
20:44:03 * monochrom turns 1+3=4 into 2+3=4 :)
20:44:45 <shachaf> A postal service is a function from letters to addresses.
20:45:51 <seydar> so next question, since we're doing the back-to-basics thing: what role do monomorphisms, epimorphisms, and isomorphisms play? specically, i have never heard those terms outside of this book. will i ever?
20:45:56 <ion> Turning the letter cover to face you composed with character recognition is a function from letters to addresses.
20:46:02 <monochrom> but a letter already has the target address written on it. think of it as getting a field from a record.
20:46:06 * hackagebot llvm-general 3.3.1.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.1.0 (BenjaminScarlet)
20:46:08 * hackagebot llvm-general 3.2.1.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.1.0 (BenjaminScarlet)
20:46:12 <monochrom> therefore, a postal service is a lens? :)
20:46:38 <shachaf> monochrom: Perhaps it is people who are functions from letters to people.
20:47:14 <johnw> seydar: in my experience, you will encounter isomorphisms (especially if you play with the lens library) and endomorphisms (see the Monoid instance Endo), but not most of the others (in Haskell packages)
20:47:16 <shachaf> You would say "monochrom sends this letter to dolio".
20:47:22 <ninegrid> seydar: those terms are quite a bit more general than just programming
20:47:41 <ninegrid> seydar: for now, just try and write some haskell code
20:49:36 <seydar> so what's an F-algebra?
20:50:49 <ninegrid> seydar: it is referring to the abstract structure of F (an endo-functor)
20:51:05 <monochrom> let F be an endofunctor, X be an object in the category of question. then an arrow F X -> X is an F-algebra.
20:51:09 <Cale> If F: C -> C is a functor, then an F-algebra is an object A in C together with an arrow a: FA -> A
20:51:27 <seydar> wait, what's an endofunctor?
20:51:38 <monochrom> when it maps from and to the same category
20:51:40 <ninegrid> a functor that relates a category to itself
20:51:43 <applikativ> F : C -> C
20:52:00 <seydar> in retrospect the 'endo-' sorta gave that away
20:52:06 <Cale> All instances of the Functor class in Haskell are endofunctors.
20:52:25 <applikativ> you can't get out of haskell
20:52:26 <Cale> (on the category whose objects are Haskell types and whose arrows are Haskell functions)
20:52:44 <seydar> Cale: watwatwat
20:52:55 <seydar> Cale: can you explain how all instances of the Functor class are endofunctors?
20:52:57 <applikativ> :k Maybe
20:52:58 <lambdabot> * -> *
20:53:07 <Cale> The mapping on objects is the type constructor itself
20:53:08 <johnw> seydar: btw, if you are interested in category theory specifically, there is also ##categorytheory, but this is a good place for asking about how it relates to Haskell
20:53:08 <applikativ> there it is ^^ C -> C
20:53:22 <Cale> For example, Maybe sends types to types
20:53:30 <Cale> and the mapping on arrows is provided by fmap
20:53:49 <Cale> e.g. fmap :: (a -> b) -> (Maybe a -> Maybe b)
20:53:51 <ninegrid> seydar: it is because not all possible categories are in haskell, only the category Hask... therefore all functors in haskell are F : Hask -> Hask
20:54:44 <seydar> ok, ok, i follow with the Maybe and fmap examples, but what if I wrote a functor that took A -> B? wouldn't that not be an endofunctor?
20:54:51 <Cale> ?
20:55:04 <applikativ> Haskell -> SML
20:55:09 <Cale> Where A and B are other categories than the category of Haskell types?
20:55:20 <shachaf> What does it mean to write such a functor?
20:55:25 <seydar> well, they're haskell types so i guess it's an endofunctor
20:55:32 <seydar> gah i'm so confused
20:55:48 <seydar> wait no i'm not
20:55:52 <Cale> seydar: A functor takes *every* object of the first category to *some* object of the second
20:55:52 <seydar> no i am
20:55:59 <Moggle_> mini-http is marked as deprecated on hackage, and is recommend by RWH for doing stuff with HTTP. can anyone recommend a good alternative?
20:56:06 <seydar> Cale: i follow. keep going
20:56:13 <Cale> and *every* arrow X -> Y in the first category to *some* arrow FX -> FY in the second
20:56:41 <Cale> For any type t, we have a corresponding type Maybe t
20:56:52 <Cale> and for any arrow f :: a -> b
20:57:02 <Cale> we have a corresponding arrow fmap f :: Maybe a -> Maybe b
20:57:19 <applikativ> Moggle_: mini-http?
20:57:48 <Moggle_> applikativ: http://hackage.haskell.org/package/network-minihttp
20:58:03 <kamatsu> (there are other functors in Haskell, they're just not captured by the functor class. For example, any monoid is itself a category of one element, and a monoid morphism is a functor)
20:58:15 <seydar> Cale: ok, but i'm a little confused on the idea of a Haskell type and a non-Haskell type
20:59:15 <applikativ> Moggle_: what kinds of operations do you need, getting a webpage or...?
20:59:56 <Cale> seydar: Are you familiar with the definedness ordering on Haskell values? I can use that to define a functor Hask -> DCPO
20:59:57 <Moggle_> applikativ: given an url, grab the file there. preferably be able to inspect the header for the response code. lazy streaming is a huge requirement
21:00:15 <Moggle_> applikativ: for the RWH chapter, they're building a podcast, so you don't want to download an hour or audio or so strictly into memory. laziness is ideal.
21:00:32 <Cale> seydar: Or actually, we could be even more basic
21:00:59 <Cale> seydar: A semantics for Haskell would assign to each Haskell type, a set of values (i.e. an object in the category of sets)
21:01:01 <kamatsu> You could also imagine some translator from Hask into System F as a functor.
21:01:33 <Cale> and to each Haskell function f :: A -> B, some set-function from the set of values of type A to the set of values of type B.
21:01:34 <applikativ> Moggle_: the HTTP library http://hackage.haskell.org/packages/archive/HTTP/4000.2.8/doc/html/Network-HTTP.html
21:02:05 <ninegrid> im gonna go out on a limb here... do you guys think it would be better if he looked at some elementary examples of category before thinking about functors and Hask?
21:02:11 <seydar> Cale: sorry, i'm not familiar with the definedness ordering
21:02:53 <Cale> seydar: yeah, basically, we could do this same thing I'm talking about, but instead of using sets, we could use partial orders of a certain sort
21:02:57 <Moggle_> applikativ: RWH says not to use that because it downloads things strictly :P i guess if that's all there is, it's enough.
21:03:13 <kamatsu> seydar: it's reasonably simple to understand. "undefined" is the most undefined thing. You could also say a nonterminating function is similarly undefined. But, what about 3 : undefined? That's more defined than undefined, cos I can get the head, but the tail is undefined.
21:03:17 <seydar> so right now i'm imagining categories as OOP classes. i know i'm going to be jumped on for thinking that, so i'm ready; do your worst
21:03:18 <kamatsu> seydar: this gives rise to an ordering.
21:03:41 <applikativ> lazy bytestring is one of the types it can get.  it wont work with RWH but http://hackage.haskell.org/packages/archive/http-conduit/1.9.4.1/doc/html/Network-HTTP-Conduit.html
21:03:54 <Moggle_> applikativ: :O thanks
21:03:57 <seydar> Cale, kamatsu: ah, partial orders. i read about that in the cat theory book
21:03:59 <monochrom> there is no morphism between objects in an OOP class.
21:04:10 <Moggle_> seems like an error in RWH then?
21:04:11 <seydar> kamatsu: and that's a really good example of a partial ordering, thank you
21:04:12 <Cale> Where basically, x <= y if we can replace some occurrences of _|_ in x with other values in order to obtain y
21:04:15 <applikativ> Moggle_: hm, the HTTP lib can return a lazy bytestring as far as I can tell
21:04:15 <Moggle_> or just RWH is dated.
21:04:22 <johnw> seydar: as ninegrid implies, you may get rather confused if you try to learn category theory using Haskell.  You may want to learn category theory, and then later apply it to Haskell; or learn Haskell, and then later apply it to category theory.  Otherwise, the differences between the two will continue to trip you up
21:04:39 <seydar> monochrom: i'm pretending i can take a Dog object and turn it into a Cat object via a functor
21:04:41 <Moggle_> applikativ: my fault for taking RWH at its word then :(
21:04:45 <applikativ> Moggle_: the conduit one is pretty simple
21:04:47 <Cale> _|_ (read bottom) is a value we use to represent all forms of nontermination
21:04:56 <Moggle_> yeah, it looks nice. thanks!
21:05:01 <applikativ> Moggle_: no, it's just that hackage is better than a couple years ago...
21:05:06 <Cale> (including the sort where a call to error is made and the program exits abnormally)
21:05:29 <monochrom> ok, but I am not even bringing up functors, or two categories. just one category, no functor, no nothing else, just one category.
21:05:35 <applikativ> Moggle_: o'sullivan has hinted from time to time he might make a second edition
21:05:47 <ninegrid> seydar: all the abstract algebra can be confusing if you're not comfortable with it... just look at a category as a very simple model that unifies seemingly different structures...  for example, in mathematics you have structures ... sets or groups for instance.... in programming (say haskell) you have its type system... if you look at these structures with "category theory glasses" then for the category Set, the objects in the cate
21:06:23 <ninegrid> seydar: going further than that requires learning/memorizing some algebraic laws
21:06:34 <ninegrid> seydar: and the benifit will not be apparent until you've learned quite a bit of it
21:06:39 <Cale> ninegrid: your message there was likely cut off at "the objects in the cat"
21:06:49 <ninegrid> Cale: ah... great...
21:07:15 <ninegrid> seydar .. the objects in the category are sets and the morphisms are functions
21:07:29 <seydar> so i'm currently still struggling to get endofunctors. i mean, i get them, but i don't get why every functor in haskell is an endofunctor
21:07:37 <monochrom> Dr. Seuss's latest invention: the objects in the cat in the hat :)
21:07:50 <seydar> and i mean, i get the reasoning you guys said: it's going from a haskell type to a haskell type, so like, victory for team haskell
21:08:05 <ninegrid> seydar: if you really want to learn the subject, start with the most elementary examples... functors are like chapter 3 or something
21:08:45 <seydar> ninegrid: i read chapter 1 and was happy with what i got from it, though if you quiz me on pullbacks i will fail
21:09:18 <Moggle_> ninegrid: apologies for jumping in here, but which textbook is this? i'm interested in learning category theory, at least the basics.
21:09:18 <ninegrid> seydar: im not a category theorist myself... but if i recall correctly it has been used to generalize all or most of mathematics, and problems that were intractible in one branch became solvable through the notion of Functor... by taking the problem in one branch and mapping it to another branch and solving it with the tools over there
21:09:25 <Cale> The reason that category theory is interesting is that in every sort of mathematical endeavour we take on, we're never just content to study one structure in isolation. We always want to understand a general class of structures and the relationships between them, in order to understand more complicated examples through various simpler ones. The kinds of things we do in order to relate structures to one another tend to
21:09:25 <Cale> produce categories.
21:10:34 <seydar> to jump back to endofunctors: all haskell categories are subcategories of the main Hask category. True or false
21:10:36 <ninegrid> Moggle_: i wasnt referring to a text book... sorry i was just saying that you should play with the elementary notions of category first, learn the algebraic laws there
21:10:45 <ninegrid> Moggle_: excersize by finding categories in your daily life
21:10:47 <Cale> seydar: What are Haskell categories? :)
21:10:54 <ninegrid> Moggle_: get good at that before moving on the the topic of functors
21:11:17 <applikativ> seydar means instances of class Category a
21:11:47 <applikativ> by 'the main Hask category' people mean the instance Category (->)
21:12:12 <seydar> i'm going to pretend i never received y'all's warning not to learn category theory through haskell and instead wade right through
21:12:13 <Cale> seydar: If you mean instances of the Category class, that class is a bit funny, but it lets you define categories whose objects are the same as the objects of Hask (i.e. all types), but whose arrows and composition are different.
21:12:22 <Moggle_> ninegrid: ah, sorry. i don't suppose you do have a textbook to recommend on it though? i know next to nothing on categories, except (maybe) that they are kinda like groups but far more general.
21:12:26 <applikativ> whats so funny about that??
21:12:46 <Cale> seydar: If you want to learn category theory properly, I can send you a rather good book.
21:12:47 <seydar> Moggle_: i'm using "Basic Category Theory for Computer Scientists"
21:12:55 <ninegrid> Moggle_: toposes, triples and theories maybe?
21:13:02 <applikativ> Cale:  now that it's using PolyKinds, this isn't true anyway
21:13:08 <Cale> seydar: Have you seen Awodey's Category Theory?
21:13:15 <Moggle_> seydar: ooooh, I'll go look that up. thanks!
21:13:23 <Moggle_> ninegrid: another nice suggestion, thanks!
21:13:29 <ninegrid> Moggle_: http://www.case.edu/artsci/math/wells/pub/pdf/ttt.pdf
21:13:39 <Moggle_> a link! even better. you're the best :D
21:14:06 <ninegrid> although... there may be better ones... in fact I'm supposed to learn category theory myself but I keep putting it off
21:14:11 <applikativ> Cale, it will be that Category :: forall k . (k -> k -> *) -> Constraint
21:14:16 <codesoup> wrt category through haskell, i think there's a book that implements a bunch of categorical constructs in ml. it may or may not be interesting: http://www.cs.man.ac.uk/~david/categories/
21:14:18 <ninegrid> i have some other ones here that ski recommended to me
21:14:22 <ninegrid> but no links for them
21:14:53 <applikativ> bah, this category nonsense is getting out of control!
21:14:56 <seydar> Cale: ok, so when i talk about my own types in haskell, do those not count as categories?
21:15:12 <ninegrid> seydar: no
21:15:14 <Cale> seydar: A category consists of the following bunch of stuff:
21:15:26 <Cale> 1) A collection of objects.
21:15:31 <monochrom> you don't normally say that one type is a category. more often, all the types together is one category.
21:15:31 <ninegrid> two collections... objects and arrows
21:15:47 <Cale> 2) For each pair of objects X, Y, a collection C(X,Y) of arrows
21:16:18 <Cale> When f is an arrow in C(X,Y), we write f: X -> Y
21:16:44 <seydar> right, i have the definition of a category in front of me
21:16:45 <ninegrid> seydar: lets say you had a language that only had integers and strings.... then there is no category integer and some seperate category for strings... there is just the category whos objects are integers and strings, and the morphisms are the mappings between the two... it is the properties of those mappings that are of interest
21:16:45 <Cale> 3) For each three objects X, Y, Z, and arrows f: Y -> Z, and g: X -> Y, an arrow (f . g): X -> Z
21:16:52 <Cale> Such that:
21:17:58 <Cale> 4) For every object X, there is an arrow id_X: X -> X such that for any arrow f: X -> Y, we have f . id_X = f, and for any arrow f: Y -> X, we have id_X . f = f
21:18:41 <Cale> 5) For every four objects, X, Y, Z, W, and composable arrows: f: Z -> W, g: Y -> Z, h: X -> Y, we have f . (g . h) = (f . g) . h
21:19:07 <ninegrid> (he has typed this hundreds of times a year for the past decade)
21:19:12 <Cale> haha
21:19:20 <seydar> so i was sorta under the assumption that types were categories and that the collection of arrows was just all the functions that took one type and returned the same type
21:19:31 <ninegrid> no types are objects in a category
21:19:38 <ninegrid> functions are arrows in a category
21:19:38 <seydar> so then what categories are there in haskell?
21:19:48 <ninegrid> there isn't one IN haskell
21:19:48 <Cale> So, when you define a category, you get to (and have to) say what the objects are, what the collection of arrows between each pair of objects is, and how the arrows that line up end to end compose with each other
21:19:53 <ninegrid> haskell is THE category Hask
21:19:57 <applikativ> for each of 1 , 2 , 3 we have arrows 1 <= 2, 2 <= 3 and composition so 1 <= 2 . 2 <= 3 is 1 <= 3, id is 1 <= 1 etc
21:20:06 <monochrom> you cannot do both. you can do one.
21:20:11 <applikativ> there's a perfectly good category in Integer
21:20:18 <monochrom> err nevermind
21:20:23 <Cale> Normally, we consider Haskell itself to be a category, whose objects are types, and whose arrows are Haskell-definable functions between those types
21:20:33 <Cale> and where composition is provided by (.)
21:21:33 <Cale> and that's enough to start to apply the definitions of category theory to it
21:22:02 <seydar> i just felt my int increase by 1
21:22:22 <Hafydd> I just felt my integer increase by 1.
21:22:31 <relrod> Cale: is Awodey's Category Theory the "rather good book" you mentioned, or was that a separate question? I buy grab a copy, if it's good.
21:22:45 <applikativ> its good
21:22:45 * relrod is interested in this too
21:23:05 <Cale> Yes, that's the one I'd recommend starting with
21:23:20 <seydar> so what's an example of defining a category in haskell?
21:23:33 <seydar> slash, is that something i would ever reasonably do?
21:23:44 <Cale> seydar: So, we don't have a *great* way to define categories inside Haskell, and it's not something that we tend to do all that often.
21:23:45 <applikativ> you mean an instance of class Category? thats not something one does much
21:24:00 <ninegrid> Moggle_: btw, this is another link I have that was interesting http://www.cs.man.ac.uk/~david/categories/book/book.pdf
21:24:03 <seydar> ok cool, let's pretend i didn't ask then
21:24:18 <seydar> because it will only get me more confused and send us all down four different rabbit holes
21:24:19 <Cale> But if the category we're interested in happens to have as its set of objects exactly the set of Haskell types
21:24:48 <seydar> so NOW i get why all functors are endofunctors
21:24:51 <Cale> and we can define a parametric datatype whose values are the arrows between a pair of objects
21:25:00 <ninegrid> *applause*
21:25:05 <Cale> and we can define the composition as a polymorphic function
21:25:12 <Cale> then the Category class can be used
21:25:25 <Cale> but... it's a little bit rare to have all those conditions satisfied
21:25:36 <seydar> wait, sorry, i spoke too soon. i no longer know what a functor is in haskell
21:25:38 <Cale> But categories of various sorts are hanging around in how we think about programs
21:25:41 <seydar> are all objects functors?
21:25:45 <Cale> no
21:25:47 <ninegrid> rarer still to have someone recognize when they are
21:25:55 <seydar> shit, i mistyped. are all functions functors?
21:25:58 <Cale> no
21:26:11 <seydar> so then what is a functor?
21:26:14 <Cale> Remember: If C and D are categories
21:26:23 <applikativ> seydar: you are mixing up the general idea of a functor and class Functor which is internal to haskell
21:26:23 <ninegrid> seydar: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
21:26:29 <Cale> then a functor F: C -> D assigns to each object X of C, some object FX in D
21:26:31 <applikativ> :k Functor
21:26:31 <lambdabot> (* -> *) -> Constraint
21:26:42 <Cale> and to each arrow a: X -> Y in C, an arrow Fa: FX -> FY in D
21:27:02 <seydar> applikativ: god dammit. thank you for that
21:27:10 <Cale> So, a functor Hask -> Hask will consist of two parts: a mapping which sends Haskell types to Haskell types
21:27:18 <monochrom> a functor maps an object to an object, an arrow to an arrow, and there are other requirements
21:27:20 <Cale> (which we implement as a type constructor)
21:27:46 <Cale> and, a mapping which sends an arbitrary Haskell function (a -> b), to another function (F a -> F b)
21:27:50 <Cale> where F is our type constructor
21:28:18 <applikativ> @type fmap
21:28:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:28:22 <Cale> and that gets implemented by the fmap method of the Functor class
21:28:26 <monochrom> the type class Functor is a further special case, and you are not ready for that
21:28:41 <finishingmove> does Haskell ever sleep? :)
21:28:54 <ninegrid> no
21:29:01 <Cale> I'd like to parenthesise that type as  (a -> b) -> (f a -> f b)
21:29:03 <ninegrid> it's world wide
21:29:03 <monochrom> yes, Haskell always sleeps.
21:29:19 <finishingmove> what a lazy bastard
21:29:23 <Cale> You can leave off the last parens, but this emphasises the fact that we're taking a function a -> b and producing a function f a -> f b
21:29:24 <finishingmove> :)
21:30:25 <Cale> In addition, functors are required to satisfy some laws. We don't have a way to enforce these laws in Haskell, but you should consider it a bug if a library defines an instance of Functor which disobeys them.
21:30:35 <zRecursive> @djinn (a -> b) -> (f a -> f b)
21:30:35 <lambdabot> -- f cannot be realized.
21:30:36 <Cale> Specifically, that  fmap id = id
21:30:43 <Cale> and that  fmap (f . g) = fmap f . fmap g
21:31:07 * hackagebot markdown 0.1.5 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.5 (MichaelSnoyman)
21:32:11 <Cale> zRecursive: There's no completely polymorphic one like that... fmap will be implemented separately for different functors.
21:32:28 <seydar> Cale: is that about the general idea of a functor or about class Functor which is internal to haskell?
21:32:38 <Cale> The laws?
21:33:07 <Cale> The laws are general -- part of the definition of a functor between two categories (though I translated them into Haskell-speak there)
21:33:43 <Cale> In category-speak, they'd be that  F(id_X) = id_(FX) and F(f . g) = Ff . Fg
21:33:48 <seydar> i know if i say i'm comfortable with the idea of a functor i'll jinx it, but i think i'm comfortable now with the idea of a functor
21:34:12 <Cale> Let's look at some other fun examples of categories
21:34:31 <seydar> they take objects X -> F(X), and arrows to F(a) : F(C) -> F(D)
21:34:39 <seydar> can you explain the functor class in haskell now?
21:34:52 <seydar> or we can do fun examples of categories, whichever
21:35:00 <Cale> Oh, well, I just did kind of
21:35:09 <Cale> (explain the Functor class)
21:35:14 <Cale> class Functor f where
21:35:21 <Cale>   fmap :: (a -> b) -> (f a -> f b)
21:35:22 <ninegrid> maybe he means why he would use one
21:35:34 <Cale> when we define an instance, we choose a type constructor f
21:35:43 <Cale> i.e. a type-level function from types to types
21:36:02 <Cale> (which is the "mapping on objects" part of the definition)
21:36:16 <Cale> and we also provide an implementation of fmap, which is the "mapping on arrows" part of the definition
21:36:52 <seydar> wait, does the functor class exist beyond fmap?
21:36:53 <Cale> (and we check that the laws hold by hand, or else the Haskell police come and take us from our beds at night)
21:37:13 <Cale> fmap is the only method of the class, and the only thing we need to define to provide an instance (along with the choice of f)
21:37:27 <Cale> It's actually really simple in most cases
21:37:52 <Cale> For example, the list type constructor (written [] at the type level) is an instance like:
21:37:56 <Cale> instance Functor [] where
21:38:00 <Cale>   fmap = map
21:38:05 <ninegrid> seydar: no... you instance the class by defining fmap, and then you use it for your own nefarious purposes... often to "fmap" some structure that can be mapped
21:38:20 <Cale> or Maybe is an instance:
21:38:24 <Cale> instance Functor Maybe where
21:38:32 <Cale>   fmap f Nothing = Nothing
21:38:37 <Cale>   fmap f (Just x) = Just (f x)
21:38:40 <prophile> as long as fmap id is the same as id
21:39:18 <seydar> aw dude guys that's awesome, i get how instance and class and functor are used in haskell! intelligence +3!
21:39:30 <Cale> generally most types we think of as "containers" will be instances where we apply the given function to all the elements (though some sorts of containers can't be instances when they impose extra constraints on the types of their elements, like sets do)
21:40:07 <ninegrid> seydar: sweet... now ask what applicative is
21:40:09 <Cale> and most of the types we think of as "computations" will be instances where we apply the given function to the results of the computation
21:40:17 <Cale> e.g. like with IO
21:40:19 <seydar> ninegrid: jeez no are you crazy do you want me to die
21:40:35 <Cale> Better yet, ask what natural transformations are ;)
21:40:48 <ion> What are natural transormations?
21:40:56 <Cale> But let's look at some more example categories
21:41:20 <Cale> I don't think it'll be helpful to go into that *right* away -- ion if you're interested I can explain them after
21:41:22 <seydar> k more example categories and then applicative and natural transformations
21:41:39 <Cale> So, preorders...
21:41:59 <ninegrid> what is a category of categories of categories ... of categories
21:42:09 <Cale> A preorder is a set S together with a relation <= on S such that
21:42:20 <Cale> 1) For every a in S, we have a <= a (reflexivity)
21:42:31 <CaptainK> found that page on "do" s and doN'Ts http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
21:42:38 <ion> seydar: Functor lets you fmap :: Functor f => (a -> b) -> f a -> f b, Applicative lets you liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c, which also lets you define the equivalent for any number of parameters.
21:42:38 <Cale> 2) For every a,b,c in S, if a <= b and b <= c, then a <= c (transitivity)
21:42:57 <ion> cale: Thanks. I’m going to sleep anyway, i’ll ask you about it later.
21:43:23 <Cale> You probably already know a bunch of examples of pre-orders -- pretty much anything you'd usually think of as an ordering will also be a preordering.
21:43:50 <ninegrid> haskell is the only computer language where its users are quite literally willing and prepared to write individualized books for new users
21:43:50 <Cale> Whenever (S, <=) is a preorder, we can form a category, whose objects are the elements of S
21:44:00 <Cale> and where there is exactly one arrow x -> y whenever x <= y
21:44:05 <Cale> and no other arrows
21:44:32 <copumpkin> I have a preorder too
21:44:44 <copumpkin> for my hott book
21:44:53 <copumpkin> I wonder when it'll turn into a total order
21:45:21 <Cale> the identity arrows on each object are provided by reflexivity, and composites are provided by transitivity (we don't have to worry about anything more than their existence, because there's at more one arrow between any pair of objects here)
21:45:36 <Cale> (in each direction)
21:45:42 <relrod> Cale: Thanks for explaining this publicly, btw. I've been idling and reading (I'm really really new to CT), and it's helping.
21:46:06 <Cale> seydar: follow that?
21:46:47 <Moggle_> ninegrid: this may be a delayed response but thanks for this computational category theory link :D
21:47:28 <ninegrid> np
21:47:41 <Cale> If we have a category whose objects form a set (they may not in certain cases because technicalities), and where there's at most one arrow between any (ordered) pair of objects, we also have a preorder
21:47:42 <seydar> Cale: yeah, preorders are covered in the book i'm reading so i've had prior exposure before now. namely, yesterday.
21:47:48 <Cale> great :)
21:48:15 <seydar> so why are preorders intredasting?
21:48:50 <Cale> Mostly because there are a lot of examples of them, and they correspond to categories of a sort in the way I just mentioned
21:49:20 <Cale> e.g. the natural numbers, or integers, or the real numbers with their usual orderings are all examples of preorders
21:49:29 <seydar> well it's good to see that my understanding of preorders is the same as your explanation
21:49:53 <seydar> and yeah, thanks again for explaining all this stuff for the past hour to me and everyone else here. it's awesome and i really appreciate it
21:50:00 <seydar> next quesitron: applicative
21:50:06 <seydar> lolwtfbbq is applicative
21:51:03 <Cale> Or, we could define a preorder on Olympic results of various countries, where (g,s,b) <= (G,S,B) when g <= G, and g + s <= G + S, and g + s + b <= G + S + B
21:51:03 <h4199> soon to be a proper superclass of monad!
21:51:27 <Cale> i.e. whenever we could perform some bunch of medal additions or medal upgrades to go from (g,s,b) to (G,S,B)
21:51:58 <slingamn> is this the place to ask questions about cabal?
21:52:13 <Cale> http://tartarus.org/simon/2008-olympics-hasse/hasse.png -- you can see a diagram here (where the arrows are in the opposite direction I've been using and the composites aren't shown) of the results for 2008 :)
21:52:32 <Cale> slingamn: sure :)
21:53:33 <slingamn> i'm having trouble with "cabal install taffybar" and i'm not sure about next steps: https://gist.github.com/slingamn/6fd0b63ca613677fff4a
21:53:33 <Cale> seydar: Okay, so what are the functors between two preorder categories?
21:54:02 <Cale> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
21:54:08 <Cale> slingamn: Did you do that step?
21:54:18 <seydar> Cale: shit. ok. i can recite the definition of a functor to you but i'm not sure that's the answer you're looking for
21:54:27 <Cale> seydar: Well, okay
21:55:19 <Cale> So, we want to send objects to objects by some function, and whenever there's an arrow a: x -> y in the first preorder category, that is, whenever x <= y using the first ordering
21:55:35 <Cale> we want an arrow Fa: Fx -> Fy in the second preorder category
21:55:40 <Cale> i.e. Fx <= Fy
21:55:49 <Cale> (using the second ordering)
21:56:06 <seydar> right
21:56:06 <Cale> So, it's an order-preserving function between the two ordered sets
21:56:09 <seydar> but what does it all mean
21:56:49 <Cale> These are known as monotone functions, and they're the sort of function you're allowed to apply to both sides of an inequality. :)
21:58:01 <Cale> Another example of simple categories is provided by monoids.
21:58:11 <seydar> so if i have a two preorders, one of olympic medals and one of approximate goats per capita
21:58:17 <seydar> and i have a functor between them
21:58:43 <Cale> Then the people who won more medals had more goats
21:58:50 <seydar> does that simply mean if i prove something about olympic medals and stuff, i can use the functor to say "look it holds for goats per capita as well"?
21:58:53 <Cale> (or better medals)
21:58:59 <Cale> yeah
21:59:30 <seydar> cool. intelligence +1
21:59:47 <Cale> Any non-decreasing function on the real numbers gives an example as well.
22:00:02 <Cale> (that's just another way of saying the same thing)
22:00:32 <Cale> Okay, so recall that a monoid consists of a set M with a binary operation *: M x M -> M such that
22:00:39 <seydar> but functors aren't necessarily bijective, so i can't REALLY prove something about medals and then claim it holds for goats, can i?
22:00:53 <seydar> ok, onto monoids. information: recalled.
22:00:57 <Cale> 1) There is an element 1 in M such that for every a in M, we have 1*a = a = a*1
22:01:14 <Cale> Oh, the implication only works one way
22:01:21 <johnw> seydar: I've seen you use "functor" several times where I think you meant to say "function"
22:01:34 <johnw> goats wouldn't be a category, it would likely be a set
22:01:38 <Cale> 2) For any a,b,c in M, we have a*(b*c) = (a*b)*c
22:01:43 <copumpkin> goats form a category
22:01:56 <johnw> oh, ok, I didn't realize it was a category in this discussion
22:02:03 <Cale> I was thinking the countries form a category ordered by the number of goats
22:02:20 <copumpkin> oh, I have an ordering on goats themselves, à la http://www.youtube.com/watch?v=ctTVcKNx8Rk
22:02:35 <Cale> Where there's exactly one arrow from country X to country Y whenever Y has more goats than X
22:02:43 <ninegrid> Goat -> Goat -> Goat
22:04:10 <seydar> Cale: wait, that's not a function. because it sends X to multiple Ys
22:04:37 <slingamn> Cale: thanks. after installing that tool and many packages ending in -devel, i'm down to this: https://gist.github.com/slingamn/7643caf27ebc9e41f81e
22:04:51 <Cale> seydar: What do you mean? What's not a function?
22:04:54 <slingamn> i suspect my distribution (Fedora) may not package that library at all...even thought that seems odd
22:04:57 <slingamn> *though
22:05:28 <seydar> Cale: the arrow from country X to country Y whenever Y has more goats than X
22:05:43 <seydar> orrrrrrrr are arrows not necessarily functions in the literal mathemagical sense of the word
22:05:44 <Cale> slingamn: I tend not to like using my distribution's packages for any Haskell stuff at all
22:06:26 <slingamn> Cale: yeah, i'm trying to figure out the separation of concerns between cabal and the system. it looks like at most, cabal provides haskell bindings --- i needed the system packages to get the underlying libraries
22:06:42 <Cale> seydar: arrows are not necessarily functions, and there is also not necessarily a function which sends objects to objects such that there is an arrow X -> Y if and only if f(X) = Y
22:06:55 <slingamn> but, wait, i wasn't supposed to get gtk2hs-buildtools as a system package?
22:07:04 <Cale> slingamn: no
22:07:10 <Cale> slingamn: as a cabal package
22:07:24 <Cale> slingamn: but maybe it's fine
22:07:29 <slingamn> yeah, that one's probably ok
22:07:32 <seydar> Cale: so in the world of arrows, we can have a single X go to multiple Ys?
22:07:38 <Cale> slingamn: What happens when you  cabal install libxml-sax-0.7.4  ?
22:08:05 <applikativ> slingamn did you install libxml2 from fedora?
22:08:24 <Cale> seydar: Given any set S, we can form the "indiscrete preorder" on S where x <= y for every x, y in S.
22:08:55 <slingamn> argh, i had fedora's libxml2 but not libxml2-devel
22:09:12 <Cale> seydar: and this gives us a preorder category, where for any objects X and Y, there's exactly one arrow X -> Y
22:09:25 <slingamn> `cabal install libxml-sax` eventually asked me for the missing C library, libxml2
22:09:46 <slingamn> but i installed libxml2-devel from yum and `cabal install taffybar` finally worked!
22:09:55 <Cale> seydar: So, if there are 5 objects, for instance, we'll have 5 arrows out of each object (one going back to that object itself)
22:09:56 <slingamn> thanks Cale and applikativ
22:10:03 <Cale> (it'll look a bit like a pentagram)
22:10:09 <seydar> ahh, ok ok
22:10:35 <Cale> slingamn: no problem :)
22:11:17 <relrod> Cale: see PM if you have a sec ;)
22:12:10 <Cale> seydar: Okay, so monoids can also be viewed as categories, where instead of restricting the number of arrows between each pair of objects to 0 or 1, we restrict the number of objects to exactly one, and we have an arrow from that single object to itself for each element of the monoid
22:12:25 <Cale> and then composition is defined by the monoid's multiplication
22:12:42 <Cale> (we can compose any two arrows here because they all have the same source and target)
22:13:10 <seydar> are elements and objects different?
22:13:17 <Cale> Elements?
22:13:25 <Cale> Sets have elements...
22:13:26 <seydar> you said "each element of the monoid"
22:13:33 <Cale> oh, right, the monoid is a set
22:13:43 <Cale> with a multiplication defined on the elements of that set
22:13:56 <Cale> (I gave the definition above, but we were also talking about other things at the time)
22:14:13 <Cale> "Okay, so recall that a monoid consists of a set M with a binary operation *: M x M -> M such that
22:14:20 <Cale> 1) There is an element 1 in M such that for every a in M, we have 1*a = a = a*1
22:14:25 <Cale> 2) For any a,b,c in M, we have a*(b*c) = (a*b)*c
22:14:27 <Cale> "
22:14:51 <seydar> schnitzelwagon, this is confusing now
22:14:59 <Cale> So, we can make a category, with one object
22:15:09 <Cale> and the arrows from that object to itself will be the elements of M
22:15:31 <Cale> and when we compose any two of the arrows, we multiply the elements
22:15:48 <Cale> For example, M might be the natural numbers
22:16:04 <Cale> and multiplication might be, say, addition of natural numbers
22:16:12 <Cale> and the "1" will be 0 in that case
22:16:23 <Cale> i.e. 0+a = a = a+0
22:16:39 <Cale> and addition is associative, a+(b+c) = (a+b)+c
22:17:02 <Cale> So, we can make a category with one object, with an arrow from that object to itself for each natural number
22:17:15 <Cale> and when we compose 2 and 3, for instance, we'll get 5
22:19:23 <Cale> Or similarly, we could do this with the positive real numbers (we could do it with all real numbers too, but I want the positive ones for a further example), and the usual multiplication of real numbers
22:19:29 <seydar> thank you very much, Cale
22:19:54 <seydar> i'm going to have to ask for more information on the monoid of the natural numbers tomorrow
22:20:11 <seydar> but for now, my head is going to explode and i'm confused and i'm tired
22:20:11 <Cale> okay, we'll want to look at what functors between these categories defined by monoids are as well
22:20:22 <seydar> i'm so tired that i'm tiblue
22:20:24 <Cale> :)
22:20:33 <Moggle_> seydar: that, i've noticed, is my natural state when learning haskell in general
22:20:37 <ninegrid> seydar: check this out http://yannesposito.com/Scratch/en/blog/Category-Theory-Presentation/
22:20:46 <seydar> i wish i could learn haskell at like 11am
22:20:52 <seydar> but noooooo it's always 1am
22:20:58 <Cale> haha
22:21:06 <ninegrid> yes <3
22:21:14 <seydar> Cale, i can only hope you have no life and will be on IRC tomorrow
22:21:57 <Cale> Yeah, I will be
22:21:59 <seydar> thank you everybody, i look forward to doing more with haskell and learning category theory
22:22:20 <ninegrid> caturday
22:22:45 <Cale> I find it kind of funny that most presentations about categories by programmers like to consider these small examples with just a few arrows and objects and ask whether there's a definition of composition which makes it a category
22:22:53 <NihilistDandy> Though thinking about monoids as "String-like" is kind of a goofy way of thinking about it
22:23:02 <Cale> It's sort of a reasonable thing to do, but it's not something that's usually given in most other introductions to category theory.
22:23:52 <Cale> Yeah, there are a bunch of things in that presentation which I'm a little iffy about.
22:23:56 <ninegrid> nice use of 'solarized' theme outside of a text editor
22:24:05 <Cale> (overall it's not terrible though)
22:24:45 <johnw> actually, I think "string" in the word the Catsters uses for the free monoid
22:24:57 <Cale> That theme is okay, but a little low-contrast for my taste.
22:25:07 <matematikaadit> just because. http://www.adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
22:25:21 <johnw> (or rather, morphisms in the free monoid category)
22:25:26 <ninegrid> Cale: i use the light version of that theme personally
22:26:53 <ninegrid> Cale: http://texas.ircgeeks.us/~dan/terminus.png here it is with some random code thrown up in vim
22:28:16 <Cale> yeah, too low-contrast for me
22:29:10 <relrod> I use tomorrow-night
22:31:17 <relrod> http://images.srv1.elrod.me/tomorrow-night-emacs.png (random sample, ignore the fact that it's Scala :P)
22:32:29 <ninegrid> im curious, what does category theory say about things that aren't categories
22:33:08 <mserrano> Basically everything is a category
22:33:57 <ninegrid> thats what i was thinking, but i haven't studied it in depth enough to know for sure... if that is the case then, whey would this presentation give examples like this and ask if it could be a category?
22:34:26 <mserrano> So, some objects aren't categories necessarily, but you can still reason about categories of those objects
22:34:34 <mserrano> Basically that is just asking you to verify the definition
22:34:56 <mserrano> The real message of category theory is that instead of looking at the structure of a given object, we should look at the relationship between it and other objects of its "type"
22:35:12 <ninegrid> right
22:35:56 <Cale> ninegrid: Yeah, that's kind of a weird thing to do
22:36:16 <Cale> ninegrid: (ask whether a particular graph of arrows and objects could potentially be a category using some composition)
22:36:29 <Cale> But it's an okay exercise to see if you understand the definition well
22:36:41 <quicksilver> I thought the real message of category theory was "Yes, you're right, structures and formalisation in one area of mathematics often are related to structures in another area. Here is a notion for understanding the analogies..."
22:37:15 <quicksilver> (... and the real payoff is when it lets us transfer theorems...)
22:38:47 <mserrano> quicksilver: right; but this notion relies on understanding that we are focusing not on the structures of objects themselves, but rather on the relationships - often, structure-preserving maps - between them
22:39:56 <quicksilver> mserrano: quite often, yes
22:39:59 <ninegrid> i like how it ends on catamorjphism... it reads like: here's some stuff i found on the web and... bewm! here's one thing i know now
22:40:37 <quicksilver> there are examples of categories in which "morphisms" are not maps or even relationships, really, they're just some thing you're studying. But often they are.
22:40:53 <mserrano> Right.
22:49:57 <shachaf> Oh, Codensity (U : Mon -> Hask) a ~ forall (r : Mon). (a -> U r) -> U r ~ forall r. Monoid r => (a -> r) -> r
22:53:33 <shachaf> But I think I'm missing something there or something. Is one of those arrows in another category or something?
22:53:36 <shachaf> Well, that doesn't make sense.
22:53:48 <shachaf> How does it work for the forgetful functor from Kleisli M?
22:59:39 <dolio> shachaf: The second arrow is a 'power'.
23:00:15 <CaptainK> how do you combine ["TEN","ONE"] and ["TEN","TWO","THREE"] to make [["TEN","TEN"],["TEN","TWO"],["TEN","THREE"]..so on for all combinations?
23:00:36 <dolio> Where, if C is enriched in V, you can take the power of objects in C by objects in V.
23:02:15 <dolio> > (\x y -> [x, y]) <$> ["TEN", "ONE"] <*> ["TEN, "TWO", "THREE"]
23:02:17 <lambdabot>   <hint>:1:63:
23:02:17 <lambdabot>      lexical error in string/character literal at end of input
23:02:44 <dolio> I missed a quote on the second TEN, but that's it.
23:03:18 <Lamen> > (\x y -> [x, y]) <$> ["TEN", "ONE"] <*> ["TEN", "TWO", "THREE"]
23:03:19 <lambdabot>   [["TEN","TEN"],["TEN","TWO"],["TEN","THREE"],["ONE","TEN"],["ONE","TWO"],["...
23:04:04 <zRecursive> > [[x,y] | x <- ["TEN","ONE"],y <- ["TEN","TWO","THREE"]]
23:04:06 <lambdabot>   [["TEN","TEN"],["TEN","TWO"],["TEN","THREE"],["ONE","TEN"],["ONE","TWO"],["...
23:08:40 <CaptainK> ok, thats what I have but getting only the first two letters.  must be missing something in the dataset
23:09:19 <CaptainK> thanks guys!
23:10:42 <ion> captaink: sequence
23:43:08 <astor> what is the O(n) version of nub called, that assumes the argument is already sorted?
23:44:17 <c_wraith> map head . group
23:44:30 <johnw> astor: there's a nub in data-ordlist that does that
23:44:30 <caper> Would learning to program in haskell as a first programming language be a bad idea or should I start with some other language?
23:46:21 <m3ga> caper: a number of universities use haskell as a first programming language. it puts people who have programmed in other languages on the same footing as people who have never programmed.
23:46:22 <johnw> caper: it would be a bit more difficult than other languages, but if your goal is a career, it's not a bad choice at all.  It emphasizes some great principles
23:47:16 <astor> thanks
23:52:18 <caper> Thanks for the input. I'm just not much for mass convention, such as everyone would say to start with python or c, so I am going to get some books about haskell and see where it takes me.
23:58:32 <finishingmove> I think Haskell would be a great first language.
23:58:47 <finishingmove> I started learning it recently (coming from PHP & JS), and I recommended it to my brother as well (who originally wanted to learn C++ as a first language).
23:59:24 <finishingmove> It's really a well-designed language.
23:59:28 <johnw> omg, I can't imagine learning C++ as a first language nowadays, when there are so many others options
