00:00:11 <shachaf> To me it looks like you put a bunch of symbols next to each other. I know what a category but I have no idea what you mean.
00:00:18 <shachaf> is
00:00:25 <adnap> Well, I just took an English sentence and gave a Haskell denotation for each term
00:00:45 <adnap> And the Haskell was consistent with the English, so it made sense to me
00:01:16 <shachaf> What you wrote isn't valid Haskell or valid English.
00:01:25 <shachaf> What is your question, again?
00:01:41 <shachaf> Let's take Maybe instead of lists because the syntax is less confusing.
00:01:51 <adnap> "A functor F : C -> D is a mapping of the objects of C to the objects of D and the morphisms of C to the morphisms of D..." Can someone explain what C, D "morphisms of C" and "morphisms of D" are in the context of the list functor? (reference: http://vimeo.com/67174266)
00:02:14 <shachaf> I didn't mean for you to quote it. I can scroll up. But OK.
00:02:29 <shachaf> C is the same as D. It's the category of Hasell types and functions.
00:02:29 <adnap> Then why did you ask what my question was?
00:02:39 <shachaf> Because I wanted to see what you're actually trying to figure out.
00:02:50 <adnap> Why didn't you scroll up if you can?
00:03:31 * shachaf sighs.
00:04:34 <shachaf> OK, more generally: what's your goal in this channel right now?
00:04:46 <adnap> I just told you!
00:04:55 <adnap> I just reposted the question
00:05:51 <shachaf> If your goal is to get help with understanding things, I recommend not making the lives of the people who are trying to help you unpleasant.
00:05:55 <shachaf> But whatever. I'll try again.
00:05:59 <adnap> How am I doing that?
00:06:19 <shachaf> Maybe is a functor, which means: There's a type constructor -- Maybe -- which turns types into types.
00:06:27 <shachaf> So, for example, it turns the type Int into the type Maybe Int.
00:06:38 <shachaf> That's the object-to-object part.
00:06:52 <shachaf> Note that Int and Maybe Int are both Haskell types. So we're dealing with the same category here.
00:07:09 <shachaf> Then there's an arrow part -- fmap -- which turns Haskell functions into Haskell functions.
00:07:22 <shachaf> So it turns the function chr :: Int -> Char into the function fmap char :: Maybe Int -> Maybe Char
00:07:43 <shachaf> s/char/chr/
00:08:08 <shachaf> Do you understand that?
00:10:13 <adnap> Yes
00:10:37 <shachaf> OK. Then your question is answered.
00:10:45 <shachaf> But I already gave this answer and you weren't happy with it.
00:11:37 <adnap> I'm happy with it now
00:11:51 <shachaf> OK.
00:12:15 <adnap> I just had to get over my stupid wrong intuition. Sorry for making your life unpleasant
00:12:35 <haasn> don't worry, shachaf's life was unpleasant before
00:14:43 <Jimi`> can I type a command in ghci that will give me back the instance definition of something
00:15:21 <Ghoul_> can an "a" be an "m b"?
00:15:34 <adnap> Ghoul_: Yeah
00:15:35 <Ghoul_> if I have a thing a -> a
00:15:38 <Ghoul_> oh wow.
00:15:43 <joelteon> a can be anything
00:15:56 <Ghoul_> can it also be a function?
00:16:01 <adnap> Ghoul_: Yeah
00:16:09 <adnap> :t id
00:16:09 <lambdabot> a -> a
00:16:10 <joelteon> <joelteon> a can be anything
00:16:13 <Ghoul_> so (a -> b) could be (a -> (a -> b))
00:16:15 <Ghoul_> cool!
00:16:21 <adnap> > id "hi"
00:16:22 <lambdabot>   "hi"
00:16:24 <shachaf> Ghoul_: No, (a -> b) can't be (a -> (a -> b))
00:16:58 <Ghoul_> Why not?
00:18:13 <shachaf> I think the answer to your original question should really involve figuring out what unification is.
00:18:27 <johnw> it could be (a -> (a -> c)), I think
00:18:53 <shachaf> If b = a -> c, then a -> b = a -> (a -> c)
00:19:05 <johnw> right
00:19:06 <Ghoul_> Oh, I think I see what's going on
00:19:21 <Ghoul_> it'd be an infinite type or something if b was the same as before
00:19:25 <johnw> and wouldn't b have to be forall a. a -> c?
00:19:30 <adnap> if (a -> b) is (a -> (a -> b)), then (a -> (a -> b)) is (a -> (a -> (a -> b))) ...
00:19:33 <shachaf> johnw: No.
00:19:59 <shachaf> a, b, c are all free here, sort of. We don't know what they are.
00:20:13 <shachaf> But we're saying: Whatever they are, if b = a -> c, then a -> b = a -> (a -> c)
00:20:19 <johnw> ok
00:20:53 <shachaf> This is always true, whatever a,b,c are. If the things on the left are equal then the things on the right are equal.
00:21:17 <shachaf> For example: If b = Int -> c, then Int -> b = Int -> (Int -> c) -- works fine
00:21:21 <johnw> ah, I see
00:22:11 <haasn> Jimi`: No. But you can look them up on hackage generally
00:22:21 <shachaf> Unification is very important to understand. You don't understand Haskell's type system if you don't understand unification.
00:22:31 <shachaf> Jimi`: :i will tell you what module the instance is defined in.
00:22:31 <haasn> Jimi`: you can use :i (on either the type or the instance) to see what the exact instance is though, sans definitions
00:22:56 <haasn> on either the type or the class, I mean
00:27:23 <bitonic> shachaf: by that logic, very few pepole understand Agda/Coq type system :P
00:27:42 <shachaf> bitonic: Maybe I shouldn't say "understand unification".
00:28:04 <shachaf> But you need at least a bit of intuition for it or something.
00:31:17 <Jimi`> is there a fast way to read the definitions?
00:31:21 <bitonic> shachaf: right
00:32:25 <bitonic> tbf, understanding first order unification is easy and totally worth it
00:32:35 <shachaf> Yes.
00:32:53 <shachaf> People do something like it all the time, intuitively, even outside of Haskell.
00:33:42 <shachaf> But for a question like «can an "a" be an "m b"?», I'd say "understand unification". Or maybe "understand variables". Or "understand quantification"? I don't know.
00:34:46 <bitonic> yeah scoping in Haskell has to be understood too.
00:35:16 <shachaf> But Haskell 2010 scoping is straightforward.
00:35:26 <shachaf> On the other hand, maybe it'd be *more* straightforward if it was explicit...
00:35:39 <bitonic> shachaf: that’s what I meant
00:35:45 <bitonic> those type variables out of nowhere
00:35:52 <shachaf> In everyday conversation we do a lot of implicit scoping, though.
00:36:00 <shachaf> (And even in informal mathematics.)
00:36:29 <bitonic> but in fact in everyday conversation and informal mathematics we’re not fully rigorous.  the Haskell type checker is
00:36:37 <bitonic> anyway
00:36:49 <bitonic> I’m not saying that’s not convenient syntax, it’s a very simple rule as well
00:36:52 <bitonic> but you need to know
00:38:34 <arnsholt> Oh, right. Type inference is essentially a form of unification, isn't it? I knew learning Prolog would come in handy one day
00:39:14 <bitonic> arnsholt: well the powerful tool in type inference is unification.  it’s not only that, Haskell also automatically quantifies over types
00:39:25 <bitonic> and other systems do other things :P
00:42:50 <arnsholt> Where does the quantification come into the picture? My understanding of the type system is mostly ad hoc
00:43:26 <shachaf> arnsholt: When you have something like "id :: a -> a", there's an implicit "for all a".
00:43:46 <bitonic> arnsholt: the type of each untyped thing starts as a “metavariable” and then gets progressively refined depending on how the thing is used
00:43:48 <shachaf> It comes with the :: (in Haskell 2010, with a couple of exceptions).
00:44:13 <arnsholt> Right, right. That makes sense
00:44:45 <bitonic> e.g. in “\x f -> f x”, it starts out with, say, “x :: a” and “f :: b”, then the application generates the equation “b = a -> c”, where “c” is a new metavariable, etc.
00:45:08 <bitonic> the process of resolving those equations is unification basically
00:46:27 <bitonic> obviously the process can fail, where you have “rigid” mismatches like “Int = Bool”, “Maybe a = [b]”, or when you have equations that would need infinite types to be solved, like “a = a -> a”#
00:47:09 <bitonic> arnsholt: standard Haskell’s type system is cool because these simple tools are enough to have near full inference
00:47:14 <bitonic> GHC Haskell isn’t
00:47:28 <arnsholt> Neat
00:47:35 <bitonic> if you into things like dependent types, it’s damn complicated
00:48:45 <shachaf> bitonic: What about when you add univalence?!
00:49:02 <bitonic> shachaf: I’d like to figure out how to make that compute first :P
00:49:17 <bitonic> well inference is the same with the univalence axiom anyway
00:50:11 <shachaf> Even the "rigid" mismatches?
00:50:36 <adnap> What are some mathematical denotations for a list? Is a sequence a good one?
00:51:00 <bitonic> shachaf: sure
00:51:31 <bitonic> I mean if you add the univalence axiom as an axiom it’s just another abstract variable
00:51:45 <bitonic> maybe when you give computational meaning to univalence things could change, but we don’t know how to do that
01:47:08 <petapetapeta> Hello, I am trying to use the replace function in Data.String.Utils, but I get the message "Perhaps you haven't installed the "dyn" libraries for package `MissingH-1.2.0.0'". How do I install these dynamic libraries?
01:59:29 <test_> @help
01:59:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:01:02 <hamid> no (well working) highlighting syntax for haskell in vim?
02:02:09 <haasn> well working?
02:02:20 <haasn> I use vim and it highlights my haskell code to within my expectations
02:02:28 <haasn> It did it out of the box
02:03:37 <merijn> haasn: I've noticed many people prefer very busy colour schemes, like colouring function names, etc.
02:04:33 <haasn> Oh okay. My setup doesn't color known function names, but I guess you could add the Prelude manually to get some of the common ones in there. The thing is, in practice, my ‘neutral’ color ends up as ‘what function names are colored’
02:04:34 <shachaf> I don't actually care what's coloured. I just like some variety on the screen.
02:04:35 <merijn> The vim highlighting is actually surprisingly good, unlike github's highlighting it doesn't break on ' in names and datakinds
02:04:40 <haasn> because really, besides literals and syntax, what else do we have?
02:04:42 <hamid> haasn, hmm. out of the box? I've this vim2hs things that only colorize the function names! no standard functions or arguments.
02:05:08 <merijn> Mine only colours syntax and operators
02:05:15 <haasn> okay that's a silly question, everything is syntax; also we have comments and operators too. But I think you get my point
02:06:06 <merijn> hamid: Which standard functions would you want it to hilight?
02:06:22 <hamid> merijn, prelude is enough.
02:06:38 <mauke> so you want to highlight foldr, but not sort
02:06:39 <alexander__b> haasn: I use vim2hs and it works OK for me
02:06:48 <alexander__b> but I would also like standard functions highlighted
02:06:53 <mauke> > def def def
02:06:54 <lambdabot>   Could not deduce (Data.Default.Class.Default a0)
02:06:54 <lambdabot>    arising from a use of `...
02:07:01 <alexander__b> mauke: I'd like both if you know a vim plugin that does that
02:07:04 <merijn> haasn: I've started using rainbow parenthesis for my code too and so far <3
02:07:06 <shachaf> mauke: You gotta highlight "lex".
02:07:09 <mauke> alexander__b: I don't see the point
02:07:21 <mauke> I mean, it's trivial to write
02:07:21 <alexander__b> preferably different colours for prelude and others.
02:07:23 <haasn> merijn: interesting. Actually, parentheses aren't highlighted at all in my code unless I hover over them with my cursor, it seems
02:07:32 <haasn> I would love to add a bit of flavor to that
02:08:12 <shachaf> I'd like Hallu mode for my Haskell highlighting.
02:08:13 <merijn> haasn: basically, they change colour as you nest them, the first level is the same as normal code, after that they cycle through colours, makes it very clear to see groupings
02:08:14 <hamid> I'd rather to find all other functions by color but it doesn't seem possible just because of 'function as data thing'.
02:08:15 <haasn> I'd like a plugin that highlights everything ‘lens’ exports
02:08:17 <shachaf> "Oh wow! Great stuff!"
02:08:20 <mstksg> anyone know if i can export threadscope images via command line?
02:08:31 <alexander__b> https://secure.plaimi.net/~alexander/tmp/2013-07-26-110750_870x61_scrot.png -- example of how it looks in my vim
02:08:34 <mstksg> threadscope renders
02:09:08 <haasn> merijn: it is a very descriptive name, I think I understood the premise from that :)
02:09:13 <merijn> haasn: github.com/kien/rainbow_parentheses.vim
02:09:18 <haasn> merijn: thanks
02:09:22 <merijn> Configurable colours!
02:09:36 <hamid> finding function arguments by their color is my least expectation.
02:11:11 <petapetapeta> How can I make a function which satisfies the following specification? I am currently thinking about stacking up case statements, but I'm not sure it's the idiomatic way of doing it
02:11:11 <petapetapeta> -- "single"   		- should remove "
02:11:11 <petapetapeta> -- one	                           - should not do anything
02:11:11 <petapetapeta> -- "two words" 		- should not remove "
02:11:11 <petapetapeta> -- two words 		- should surround with "
02:11:21 <merijn> I just end up with https://dl.dropboxusercontent.com/u/1841232/vim.png
02:11:25 <merijn> minimalism, yay!
02:11:30 <mauke> petapetapeta: tabs :-(
02:12:14 <petapetapeta> ah :/ actually haven't tried using them in IRC before. Sorry about the mess. Is it readable or should I redo it?
02:12:18 <petapetapeta> -- "single"   		- should remove "
02:12:18 <petapetapeta> -- one				- should not do anything
02:12:18 <petapetapeta> -- "two words" 		- should not remove "
02:12:18 <petapetapeta> -- two words 		- should surround with "
02:12:26 <petapetapeta> -.-
02:12:31 <haasn> alexander__b: here's mine http://sadpanda.us/images/1754898-9046OBI.png =)
02:13:13 <mauke> petapetapeta: you still have embedded tabs
02:13:15 <petapetapeta> That's kinda embarrassing -.- Really sorry about that :/
02:13:26 <merijn> haasn: Needs more Monaco :p
02:13:31 <mauke> also I'd parse your format into a list and reserialize it
02:13:40 <alexander__b> haasn: we have similar except mine has other colours for type signatures and for the name/parameters of a function.
02:13:41 <petapetapeta> -- "single"         - should remove "
02:13:41 <petapetapeta> -- one              - should not do anything
02:13:41 <petapetapeta> -- "two words"      - should not remove "
02:13:41 <petapetapeta> -- two words        - should surround with "
02:13:56 <alexander__b> i.e. foo bar = foo+bar -- the left side will be a different colour than the right
02:14:17 <alexander__b> mauke: rainbow parens look really nice
02:14:31 * hackagebot ddc-base 0.3.2.1 - Disciplined Disciple Compiler common utilities.  http://hackage.haskell.org/package/ddc-base-0.3.2.1 (BenLippmeier)
02:14:33 * hackagebot ddc-core 0.3.2.1 - Disciplined Disciple Compiler core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.3.2.1 (BenLippmeier)
02:14:35 * hackagebot ddc-core-eval 0.3.2.1 - Disciplined Disciple Compiler semantic evaluator for the core language.  http://hackage.haskell.org/package/ddc-core-eval-0.3.2.1 (BenLippmeier)
02:14:37 * hackagebot ddc-core-simpl 0.3.2.1 - Disciplined Disciple Compiler code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.3.2.1 (BenLippmeier)
02:14:55 <merijn> I like it because it's unintrusive and helps scanning parenthesised expressions just that little bit quicker
02:14:56 <hamid> haasn, still no colored argument :/
02:15:01 <babybum> hello
02:15:23 <merijn> Solution, program pointfree and never have arguments on your functions :)
02:15:24 <haasn> alexander__b: now that I think about it, different colored type signatures would be a nice thing to have
02:15:35 <petapetapeta> mauke: Not sure what you mean. Can you elaborate?
02:15:52 <mauke> petapetapeta: write a function parse :: String -> [String]
02:16:06 <mauke> and another function stringify :: [String] -> String
02:16:26 <haasn> merijn: that only works if the only program you ever want to write is ⊥
02:16:30 <alexander__b> haasn: I think mine is fairly nonintrusive, https://secure.plaimi.net/~alexander/tmp/2013-07-26-111543_796x210_scrot.png
02:16:33 <merijn> haasn: Why?
02:16:38 <mauke> parse "foo \"bar\" \"baz quux\"" => ["foo", "bar", "baz quux"]
02:16:59 <haasn> merijn: main = putStrLn "Hello, world!"  <- that function still has an argument despite being point-free
02:17:09 <haasn> hmm maybe there's more than one program you can write. main = getLine for example
02:17:11 <merijn> haasn: I was talking of definions
02:17:20 <haasn> ah!
02:17:23 <haasn> that makes more sense
02:17:50 <petapetapeta> mauke: Ahh :) I think I see how that could work. Clever :) Thanks a lot
02:18:12 <petapetapeta> Then in the end I can just run parse . stringify
02:18:26 <alexander__b> merijn: I don't think the rainbowparens work here. they're all red.
02:18:36 <haasn> alexander__b: I'm guessing you have to configure the colors first
02:18:43 <alexander__b> merijn: never mind. the first two colours are just very similar.
02:19:31 * hackagebot ddc-core-flow 0.3.2.1 - Disciplined Disciple Compiler data flow compiler.  http://hackage.haskell.org/package/ddc-core-flow-0.3.2.1 (BenLippmeier)
02:19:33 * hackagebot ddc-core-llvm 0.3.2.1 - Disciplined Disciple Compiler LLVM code generator.  http://hackage.haskell.org/package/ddc-core-llvm-0.3.2.1 (BenLippmeier)
02:19:35 * hackagebot ddc-core-salt 0.3.2.1 - Disciplined Disciple Compiler C code generator.  http://hackage.haskell.org/package/ddc-core-salt-0.3.2.1 (BenLippmeier)
02:19:37 * hackagebot ddc-core-tetra 0.3.2.1 - Disciplined Disciple Compiler intermediate language.  http://hackage.haskell.org/package/ddc-core-tetra-0.3.2.1 (BenLippmeier)
02:19:40 <alexander__b> here's how they look "out of the box" for me https://secure.plaimi.net/~alexander/tmp/2013-07-26-111854_422x39_scrot.png
02:19:45 <merijn> alexander__b: Actually I just changed the just 2 seconds ago :p
02:19:58 <alexander__b> merijn: is it your repo?
02:20:11 <merijn> alexander__b: No
02:20:13 <alexander__b> oh you meant locally?
02:20:27 <haasn> the best thing is, I only need to configure 2 colors, since I never nest more than that either way
02:20:28 <merijn> Yeah
02:20:50 <merijn> haasn: Well, I go up to 3 or 4 in real code, up to like 7-8 in hackey shell script haskell :p
02:20:51 <alexander__b> haasn: don't you ever write lisp? :-P
02:21:10 <haasn> alexander__b: please don't mention that language to me, I still have )-shaped scars
02:21:41 <mauke> http://mauke.hopto.org/stuff/lisp/implinest.lisp
02:21:56 <mauke> (foo #$ bar #$ baz)
02:22:16 <alexander__b> I'm going to get the vim-plugin guy to add rainbowparantheses to portage. :-)
02:22:23 <alexander__b> thanks for the suggestion, merijn !
02:23:20 <haasn> mauke writes good comments
02:24:11 <mauke> it's a quote
02:24:31 * hackagebot ddc-build 0.3.2.1 - Disciplined Disciple Compiler build framework.  http://hackage.haskell.org/package/ddc-build-0.3.2.1 (BenLippmeier)
02:24:33 * hackagebot ddc-code 0.3.2.1 - Disciplined Disciple Compiler base libraries.  http://hackage.haskell.org/package/ddc-code-0.3.2.1 (BenLippmeier)
02:24:35 * hackagebot ddc-driver 0.3.2.1 - Disciplined Disciple Compiler top-level driver.  http://hackage.haskell.org/package/ddc-driver-0.3.2.1 (BenLippmeier)
02:24:35 <haasn> but do lisp programmers really use like 5 different lines to close a bunch of s-exprs? Personally I would have them all on one line like ))))) and aligned to the outermost block they close
02:24:37 * hackagebot ddc-interface 0.3.2.1 - Disciplined Disciple Compiler user interface support.  http://hackage.haskell.org/package/ddc-interface-0.3.2.1 (BenLippmeier)
02:24:39 * hackagebot ddc-tools 0.3.2.1 - Disciplined Disciple Compiler command line tools.  http://hackage.haskell.org/package/ddc-tools-0.3.2.1 (BenLippmeier)
02:25:07 <shachaf> mauke does.
02:25:17 <mauke> haasn: they don't but they're wrong
02:25:20 <merijn> mauke is a rebel
02:25:23 <shachaf> Is mauke a lisp programmer? Well, that looks like a lisp program to me.
02:25:42 <mauke> when they complain, I always tell them to just use lisp for a few weeks and they won't even notice the parens anymore
02:25:44 <haasn> shachaf: you can pull that joke *after* somebody questions whether or not mauke is a lisp programmer
02:25:45 <mauke> then they kickban me
02:26:07 <alexander__b> mauke: I quite like parens from common lisp
02:26:51 <shachaf> haasn: I did.
02:26:59 <haasn> shachaf: excellent response
02:27:05 <merijn> I need to institute an "evil genius" coder channel on freenode, basically #haskell, but with less newbie questions and haskell and more god awful hacks and genius
02:27:36 <mauke> ooh, I've got tons of awful hacks
02:27:58 <shachaf> I have some awful hacks.
02:28:13 <Placinta> Hi. Is it possible to have a function to do division if its argument is a Float, and div if its Integral?
02:28:23 <merijn> Because all the generic "programmer" and "hacker" channels so far were filled with dunces
02:28:30 <merijn> @quote who.do.you.call
02:28:30 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
02:28:38 <mauke> Placinta: no
02:28:41 <merijn> oh, wait
02:28:44 <merijn> I misparsed
02:28:45 <merijn> Nope
02:28:53 <Placinta> Even with TemplateHaskell?
02:29:12 <merijn> Well, actually the answer is "yes, but you really, really shouldn't"
02:29:19 <shachaf> I like mauke's answer because you just know he wouldn't have given it if the question had said "Integer".
02:29:31 <mauke> >implying
02:29:42 <shachaf> Or maybe you're just wrong.
02:29:46 <mauke> :-(
02:29:49 <shachaf> By "you" I mean me.
02:29:55 <shachaf> As in "you just know".
02:30:13 * shachaf sighs. Not doing very well at phrasing things presently.
02:30:17 <mauke> I didn't even notice that the question was about a type vs. a class
02:30:20 <haasn> shachaf: lacking sleep?
02:30:22 <johnw> can I force cabal to choose the static version of a particular lib in my extra-libraries section?
02:30:23 <merijn> mauke: I'm pretty sure I could write that if I was allowed to use Typeable and TypeFamilies
02:30:30 <shachaf> haasn: Somewhat.
02:30:34 <Placinta> merijn: Can you elaborate how I would do that which I should not?
02:30:40 <mauke> merijn: the question is inconsistent. what if Float is an instance of Integral?
02:30:54 <merijn> mauke: Then there is someone in need of stabbing :)
02:31:05 <shachaf> mauke: Then clearly instance Integral Float where div = (/)
02:31:16 <haasn> @src Integral
02:31:16 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:31:16 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:31:16 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:31:16 <lambdabot>     toInteger           :: a -> Integer
02:31:21 <haasn> neat
02:31:22 <shachaf> (Assuming "division" means (/). Maybe it means "div", in which case it's even easier.)
02:32:02 <Placinta> I am sorry I meant Floating and Integral, not Float and Integral
02:32:14 <haasn> now it's even less possible!
02:32:19 <mauke> Placinta: that doesn't change the issue
02:32:27 <mauke> Placinta: what if Float is an instance of both?
02:32:31 <merijn> Placinta: You can do it in much the same way you can have templates in C by using CPP, which is to say. You can't and if you do it everyone will hate you
02:32:34 <mauke> game over, man. game over!
02:32:56 <Placinta> But Float is an instance of Floating only.
02:32:57 <shachaf> Float vs. Int you can do. But it's a bad idea.
02:33:13 <mauke> Placinta: how do you know?
02:33:18 <haasn> Placinta: I wonder why you want this function. There's probably some clean, elegant alternative that doesn't require sacrificing a cat
02:33:24 <haasn> we don't like sacrificing cats around here
02:33:26 <Placinta> That's what learnyouahaskell says
02:33:43 <haasn> Placinta: I could make it an instance of Integral though. I'd be breaking some laws, but the compiler doesn't stop me
02:33:50 <Placinta> True
02:33:53 <shachaf> haasn: "laws". Right.
02:33:58 <haasn> Yes. “laws”
02:34:08 <merijn> Placinta: My answer was a joke and I don't want to be responsible for you doing things that you really shouldn't :)
02:34:13 <shachaf> „laws”
02:34:28 <Placinta> Esentially I wanted to divide a list of numbers by a number. And if it was integral, I wanted to do div, if Floating then (/)
02:34:31 * hackagebot repa-series 1.0.0.1 - Series Expressionss API  http://hackage.haskell.org/package/repa-series-1.0.0.1 (BenLippmeier)
02:35:19 <Placinta> But I guess you can't have a list of numbers with different types
02:35:33 <merijn> Placinta: Indeed
02:36:24 <mr-> Placinta: you could have [Either Int Float], if you really liked
02:36:26 <Placinta> But... you could have a tuple of different types, and maybe use templatehaskell to parse each number, and do it?
02:36:32 <integral> Data.Dynamic/existential types...
02:36:41 <shachaf> integral: Almost certainly the wrong answer.
02:36:41 <merijn> integral: You are not helping
02:36:53 <haasn> if you really need a mixed list and Either Int Float seems like a good idea; then you don't even need trickery to make this work
02:37:01 <merijn> haasn++
02:37:28 <Placinta> Dynamic looks nice...
02:37:38 <merijn> integral: Look what you've done
02:37:53 <shachaf> If you think Dynamic looks nice, then you probably don't know enough to be allowed to use Dynamic.
02:37:58 <haasn> something like bimap (`div` 100) (/ 100) -- would do the mapping
02:38:00 <shachaf> Which isn't to say that it doesn't have its uses.
02:38:05 <merijn> Placinta: No, Data.Dynamic is bad and you should feel bad
02:38:11 <integral> woops.  Sorry, I haven't read up before saying that
02:38:32 <Placinta> merjin: why? languages like C++ that are static typed developed variants, and use them succesfully
02:38:36 <mr-> Placinta: the real question is: Why would you want to do something like that?
02:38:56 <Placinta> mr-: Just to see if it's possible...
02:39:00 <shachaf> Placinta: It isn't that it doesn't work. It's that it's often not what you really want.
02:39:03 <merijn> Placinta: C++ might be statically typed but it's certainly not strongly typed
02:39:19 <shachaf> You have a "real question" hiding somewhere, and probably Dynamic is not the answer to that.
02:39:27 <shachaf> And not existential types, either.
02:39:30 <Ralith> shachaf: merely 'often'?
02:39:31 * hackagebot repa-plugin 1.0.0.1 - Data Flow Fusion GHC Plugin.  http://hackage.haskell.org/package/repa-plugin-1.0.0.1 (BenLippmeier)
02:39:36 <shachaf> Ralith: Yes. Not always.
02:39:36 <merijn> Placinta: Unlike haskell, which is. Breaking the strong typing is...is a terrible idea
02:40:04 <shachaf> "strong typing" is mostly a meaningless phrase. :-) I wouldn't really use it to support an argument.
02:40:27 <merijn> Placinta: It's only slightly less terrible than using unsafeCoerce. They're the kind of tools you should only use if you know enough not to have to ask why they're bad
02:40:33 <shachaf> Placinta: The classic example is this: You want a list of things whose types are all instances of Show.
02:40:36 <merijn> shachaf: oh? Why?
02:40:44 * haasn has yet to come across a genuine use case for Dynamic
02:40:50 <merijn> haasn: I have
02:40:58 <haasn> care to elaborate?
02:40:59 <shachaf> Placinta: You *could* say [exists a. Show a *> a], if GHC supported first-class existentials. And it would work.
02:41:08 <haasn> shachaf: or, yknow, [String]
02:41:12 <shachaf> Placinta: But [String] is simpler and better in just about every way.
02:41:20 <shachaf> haasn: Yes. iknow.
02:41:32 <Ralith> shachaf: lots've room between 'often' and 'always'
02:41:50 <mr-> merijn: would you care to explain why unsafeCoearce is bad? ;-)
02:41:56 <shachaf> lots've, eh?
02:41:56 <Placinta> Ok, sorry for creating confusion.
02:42:00 <merijn> haasn: It involves abuse of existentials, TypeFamilies, GADTs and phantom types, which let me encode stuff in the types that the compiler doesn't know, so you use Dynamic to force the compiler to do what you know is right
02:42:26 <haasn> merijn: ok. I think I've heard enough to get the general gist of the situation :)
02:42:26 <Ralith> merijn: I thought people mostly used unsafeCoerce for that
02:42:54 <merijn> Ralith: That's not safe! :p
02:43:12 <haasn> (of course, Dynamic uses unsafeCoerce)
02:43:18 <merijn> haasn: Nope
02:43:23 <shachaf> We should have a taking unsafeCoerce out of lens competition.
02:43:25 <Ralith> merijn: :p
02:43:27 <merijn> haasn: It uses Data.Typeable
02:43:42 <haasn> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
02:43:44 <merijn> haasn: And existential storing of the typeclass dictionary
02:43:48 <shachaf> merijn: Nope.
02:43:50 <haasn> fromDyn (Dynamic t v) def
02:43:53 <haasn>   | typeOf def == t = unsafeCoerce v
02:43:53 <merijn> No?
02:43:55 <haasn>   | otherwise       = def
02:43:57 <merijn> I thought it did
02:43:59 <shachaf> merijn: That *could* be an implementation of Dynmiac but it's not.
02:44:00 <merijn> Now I'm sad
02:44:08 <Placinta> shachaf: Is there a haskell compilr that supports first-class existentials?
02:44:15 <haasn> shachaf: isn't it just there for performance?
02:44:17 <shachaf> Placinta: Yes, but not with type classes.
02:44:26 <shachaf> haasn: Is it? I don't know.
02:44:26 <haasn> or are there some type hacks that the compiler legitimately wouldn't be able to understand otherwise?
02:44:31 <shachaf> -- Copyright   :  (c) The University of Glasgow 2001
02:44:37 <shachaf> Did GHC even have existentials back then?
02:44:50 <haasn> uh.. okay, if even shachaf doesn't know what's going on in the lens codebase, I'm at a loss for words
02:45:01 <shachaf> haasn: Oh, wait, I thought you were talking about Dynamic.
02:45:04 <haasn> oh
02:45:19 <shachaf> haasn: These unsafeCoerces weren't the usual (.#) business.
02:45:20 <haasn> that was rather unclear on my part, I just realized
02:45:29 <merijn> oh, it just stores the Typeable results and then unsafeCoerces based on that
02:45:35 <shachaf> They were the Data.Data.Lens business.
02:45:38 <merijn> Which is just the ghetto approach
02:45:46 <Adeon> I've used Dynamic to make sure some resources are only created once in an OpenGL context
02:45:57 <shachaf> haasn: Er. I mean the five I took out recently.
02:46:00 <Adeon> I wanted modules to be able to define they have some per-context resources but not having to write that anywhere else
02:46:03 <haasn> shachaf: ah
02:46:05 <merijn> Adeon: oh? Do you have a link to the approach you took?
02:46:10 <shachaf> haasn: Those were completely unnecessary. So maybe there are more.
02:46:15 <haasn> shachaf: lots of unsafe* in Data.Data. Where's ‘upon’ anyways?
02:46:26 <Adeon> merijn: no, I don't
02:46:33 <shachaf> haasn: Also I think GHC 7.8 will make a lot of the (.#) business unnecessary, maybe?
02:46:33 <haasn> ah, Data.Data.Lens
02:46:42 <shachaf> Yes.
02:46:42 <merijn> Adeon: :(
02:46:43 <Ralith> Adeon: did you need a distinction between 'per context' and 'global'?
02:47:10 <haasn> shachaf: That would be a nice change
02:47:25 <Adeon> Ralith: I'm not sure what you mean but I have some OpenGL resources that should only be created once and they are specific to one OpenGL context or several shared OpenGL contexts in different threads
02:48:20 <Adeon> I used Typeable and Dynamic to register these per-context in a manager that checks from a Map of Typeables if a resource has already been created
02:48:27 <Adeon> Dynamic is involved to get the resource from the map
02:48:37 <Ralith> Adeon: your use of 'per context' suggests that you were using multiple contexts; I'm curious what the motivation for that was, if it was indeed the case
02:48:48 <Adeon> multithreaded rendering
02:48:58 <Adeon> different OpenGL contexts can share some things
02:49:12 <Ralith> why not use mapped memory?
02:49:15 <merijn> There's no pretty name for "flip runStateT" and friends, I guess?
02:49:26 <Ralith> I understand that it is much better-behaved
02:49:55 <Adeon> hmm, what would I use it for?
02:49:55 <haasn> merijn: none that I know of
02:50:06 <Ralith> Adeon: well, what does "multithreaded rendering" mean?
02:50:25 <Adeon> it means I can have several threads all running OpenGL commands
02:50:40 <Ralith> why do you want that?
02:50:47 <Adeon> because I can
02:50:52 <Adeon> it's interesting
02:50:53 <haasn> > execStateT ?? 0 $ do id += 1; id *= 2
02:50:53 <lambdabot>   Not in scope: `??'Not in scope: `+='
02:50:54 <lambdabot>  Perhaps you meant one of these:
02:50:54 <lambdabot>    `+...
02:50:58 <haasn> :(
02:51:13 <Placinta> > :t (??)
02:51:14 <lambdabot>   <hint>:1:1: parse error on input `:'
02:51:31 <Adeon> I've heard the Wonderful commercial engines routinely use multithreaded rendering
02:51:34 <haasn> If it's not in scope, calling :t on it wouldn't help much. :) and the omit the ‘>’ for that syntax
02:51:35 <Adeon> so I thought I might as well try that
02:51:48 <Ralith> if you're interested in doing amusing things and apathetic about optimal performance, I suppose that's fine
02:51:51 <haasn> Placinta: (Control.Lens.Combinators.??) = flip
02:52:13 <haasn> oh, but it's the Caleskell flip
02:52:34 <Placinta> :t (??)
02:52:35 <lambdabot> Not in scope: `??'
02:52:49 <Placinta> I suppose import doesn't work
02:53:04 <Placinta> > import Control.Lens.Combinators
02:53:05 <lambdabot>   <hint>:1:1: parse error on input `import'
02:53:10 <Ralith> "multithreaded rendering" is a very vague term. There are no circumstances I know of in which a well designed renderer is limited by the ability of a CPU to push OpenGL commands quickly enough.
02:53:38 <Ralith> indeed, well designed renderers tend to issue very few OpenGL commands in their main render loop.
02:54:11 <haasn> Placinta: lambdabot's ‘> ’ feature isn't related to GHCi. It will only evaluate expressions
02:54:20 <Placinta> I see
02:54:30 <haasn> there is actually a way to add definitions/imports to lambdabot, but I personally wouldn't do that
02:54:32 <shachaf> haasn: Should be "distribute".
02:55:07 <Placinta> What is Caleskell?
02:55:21 <haasn> shachaf: where's that from?
02:55:29 <shachaf> Data.Distributive, I think?
02:55:32 <shachaf> @hackage distributive
02:55:32 <lambdabot> http://hackage.haskell.org/package/distributive
02:55:54 <haasn> yeah
02:56:51 <Jimi`> how does one pronounce -:
02:57:13 <shachaf> However one likes.
02:57:17 <Ralith> Adeon: as far as I'm aware, the only case where it's actually useful to have multiple threads talking to the GPU is when you want to upload bulk data to video memory without interrupting rendering--thus mapped memory and a single context.
02:57:22 <shachaf> I like "grunt" or "minus colon".
02:57:28 <haasn> I love it when edwardk creates classes like these only for the only instances being ‘Identity’, ‘Reader’ and variations/newtypes/compositions thereof
02:57:46 <dalaing1> it's pronounced exactly like it sounds
02:57:52 <Adeon> Ralith: you may be right
02:57:55 <shachaf> haasn: Hey, this is, like, the dual of Traversable and stuff, man!
02:57:58 <Adeon> I'm doing things for amusement and curiosity
02:58:29 <haasn> shachaf: the best bit “However, there appears to be little benefit to allow the distribution via an arbitrary comonad so we restrict ourselves to Functor” <- as if that would somehow enable more instances
02:58:37 <Ralith> Adeon: fair enough. I was just curious if you knew something I didn't.
02:59:12 <haasn> wait, more like the opposite
02:59:20 <Ralith> The issue's a bit close to home since I'm dealing with a mess resulting from legacy code's decision to use the multiple context approach at work
03:01:24 <haasn> Placinta: ‘Caleskell’ refers to some overly generalized versions of Prelude functions that were defined in lambdabot a while ago, when Cale was maintaining it. I'm not sure if it was Cale himself who introduced those alternatives
03:02:09 <haasn> Placinta: for example, (.) :: Functor f => (a -> b) -> f a -> f b; flip :: Functor f => f (a -> b) -> a -> f b; and I can't actually think of any more
03:02:35 <haasn> (++) :: Monoid m => m -> m -> m -- but that almost doesn't count
03:02:54 <Placinta> :t (.)
03:02:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:03:00 <shachaf> haasn: Clearly the Right Type for (++) is :: MonadPlus m => m a -> m a -> m a
03:03:19 <haasn> clearly ‘mappend’ shouldn't even exist
03:03:36 <shachaf> haasn: Isn't it great how instance Comonoid r => Reader (r ->)?
03:04:04 <mr-> clearly the right type for (++) involves semigroup
03:04:26 <haasn> instance Reader?
03:04:36 <shachaf> Er.
03:04:45 <shachaf> Monad
03:05:34 <haasn> that joke is still beyond me
03:05:41 <shachaf> It's no joke!
03:05:48 <shachaf> E.g. http://stackoverflow.com/questions/15418075/the-reader-monad
03:06:13 <shachaf> Comonoid r => Monad (r ->), Monoid r => Monad (r,)
03:06:17 <shachaf> Comonoid r => Comonad (r,), Monoid r => Comonad (r ->)
03:07:29 <haasn>     delete :: m -> () -- is the most useful Haskell function I've ever seen
03:08:18 <haasn> shachaf: yeah, that makes sense now
03:08:27 <haasn> I still think it's a joke
03:08:40 <shachaf> It still thinks you're a joke.
03:09:43 <haasn> class instances can be so cruel sometimes
03:09:51 <haasn> especially Enum
03:10:29 <shachaf> The Bird is Cruel!
03:11:12 <haasn> shachaf: so does edwardk have a comonoid package?
03:11:41 <shachaf> haasn: No.
03:11:51 <shachaf> But comonads are just comonoids in the category of endofunctors!
03:12:26 <haasn> I wonder what the dual of “lax 2-functor from a terminal bicategory” is
03:12:58 <shachaf> @quote bicategory
03:12:59 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
03:14:07 <haasn> (would it be a lax functor from an initial bicategory?)
03:14:24 <shachaf> I don't think so...
03:14:25 <haasn> keeping in mind I have no idea what a lax functor or a bicategory is
03:15:07 <shachaf> I think it'd be an oplax functor from a terminal bicategory.
03:15:23 <shachaf> I mostly think that because nlab says it...
03:15:29 <shachaf> But it makes sense.
03:15:30 <merijn> Someone got category theory in my haskell again :(
03:15:52 <shachaf> haasn: A strong functor has f(ab)=f(a)f(b), f(1)=1
03:16:01 <shachaf> haasn: With a lax functor you just have ->, not =
03:16:08 <shachaf> (In the right category.)
03:16:08 <haasn> ok
03:16:48 <haasn> that is much simpler than the ncatlab explanation
03:16:50 <haasn> “See the definition at pseudofunctor, and let the natural isomorphisms in that definition be merely natural transformations.”
03:17:08 <shachaf> Right, those arrows are natural transformations/isomorphisms.
03:17:17 <shachaf> Now, a terminal bicategory is, I assume, a lot like a terminal category, i.e. one with one object and one arrow.
03:17:20 <haasn> it makes sense now that I've seen your version
03:17:36 <shachaf> So a strong -- ah, OK, I won't keep working it out in here, then. :-)
03:18:02 <shachaf> Anyway it pretty much comes out as a monad.
03:18:10 <Ghoul_> I can't make pureOpt typecheck ; http://lpaste.net/91225 . Can someone help?
03:18:32 <haasn> shachaf: yeah, I've looked up the definitions and worked it out before, just forgotten everything in the meantime
03:19:24 <mauke> pureOpt :: AnyOptimization -> (forall a. (Optimization a, Show a) => a -> r) -> r
03:20:11 <Ghoul_> mauke: thanks
03:20:20 <shachaf> Ghoul_: It's probably in your best interest to figure out how to make that work without an existential, for the reasons I outlined above.
03:20:22 <mauke> the whole thing is crazy, of course
03:20:27 <shachaf> But I'm not going to dwell on it.
03:20:47 <shachaf> The FAQ also talks about what you're doing and why you probably shouldn't do it.
03:20:51 <mauke> data Optimization = MakeSmaller | MakeFaster
03:21:33 <shachaf> Or newtype Optimization = Opt { runOpt :: [Expr] -> [Expr] }
03:21:35 <haasn> or data Optimization = Optimization { [Expr] -> a -> [Expr] } -- depending on which way you want to extend stuff
03:21:48 <haasn> err yeah, what shachaf said
03:22:17 <shachaf> It's known as the "Expr" problem, just for you.
03:22:31 <haasn> for me?
03:22:41 <Ghoul_> data Optimization = a | b feels less "pluggable"
03:22:48 <haasn> Ghoul_: see: what shachaf said
03:23:00 <shachaf> See also: The expression problem.
03:23:26 <Ghoul_> I don't know what the thing shachaf proposed means, but I'll figure it out, thanks
03:23:33 <shachaf> But I've given up already. I'm quick to give up.
03:23:34 <haasn> I remember a good stackoverflow thread on the expression problem but I seem to have lost it in my history
03:27:50 <merijn> I'm guessing the most efficient way to implement a cyclic list with insertion would be "data Window a = Window [a] [a]", popping from the first list and then consing to the socket and reversing the second once the first list hits []?
03:28:20 <haasn> digging through logs.. 2013-04-24 14:02:41 Cale beaky: You can solve the expression problem using them <- now I sort of want to know what beaky asked here, but I don't have him in my logs
03:28:46 <shachaf> merijn: You mean like a zipper?
03:29:11 <haasn> most of the ‘expression problem’ hits in my log seem to be by shachaf
03:29:19 <dalaing1> there's always tagless final encoding for the expression problem
03:29:43 <shachaf> haasn: It's not a great name for it because it isn't really a problem.
03:30:00 <shachaf> (You have beaky on /ignore? You have no idea what you're missing!)
03:30:25 <mauke> haasn: we have public logs
03:30:38 <haasn> mauke: good point! forgot about those
03:31:03 <taylorgb> haasn: beaky was asking about type classes
03:31:59 <haasn> I'd sort of think he asked “what are type classes?” except I don't see why Cale would respond that way in particular
03:32:19 <shachaf> Well, the logs are in the topic.
03:32:43 <taylorgb> I guess this was the prompt: 12:55 < beaky> how do Typeclasses solve the expression problem?
03:33:04 <haasn> oh. I see it now, which makes the response a bit more amusing
03:33:05 <taylorgb> To which Cale says that you can solve the expression problem using them
03:37:07 <dalaing1> Ghoul_:  for typeclass / expression problem info, see homework 5 here http://www.seas.upenn.edu/~cis194/lectures.html for a taste, and for the full treatment -> http://okmij.org/ftp/tagless-final/course/index.html
03:37:13 <ousado> hum
03:38:28 <ousado> wouldn't that be just certain implementations of type-classes that "solve" the expression problem?
03:39:33 * hackagebot katt 0.2.0.1 - Client for the Kattis judge system.  http://hackage.haskell.org/package/katt-0.2.0.1 (DavidNilsson)
03:40:55 <ousado> .. in e.g. felix there are typeclasses, and they require recompilation.
03:43:30 <Placinta> Is there a way to get the source code of a function from inside ghci?
03:43:37 <shachaf> No.
03:43:47 <shachaf> You can use :i to find out where it's defined, though.
03:44:24 <Placinta> I could never understand why a good docs feature isnt implemented in gchi : (
04:03:44 <Ghoul_> dalaing1: thanks!
04:04:53 <dalaing1> Ghoul_: not a problem
04:20:40 <Ghoul_> :t pure
04:20:41 <lambdabot> Applicative f => a -> f a
04:21:07 <mauke> :t puree
04:21:08 <lambdabot> t -> ()
04:21:25 <hpc> you forgot the accent
04:21:41 <mauke> sacre bleu
04:21:47 <Ghoul_> I couldn't find the reason for not using ExistentialQuantification in what shachaf said or on the wiki
04:22:01 <merijn> mauke: You forgot the accent there too
04:22:09 <merijn> @where existential-antipattern
04:22:09 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
04:22:25 <Ghoul_> cheers
04:23:34 <jophish_> Yo yo yo
04:24:54 <Ghoul_> Ooh, I get it now.
04:25:39 <Ghoul_> Yeah, it doesn't really make sense to make all your types super complex when it's quite easy to just do it like that, I guess.
04:27:26 <merijn> Ghoul_: There's usecases for existential quantification (obviously, else it wouldn't exist!), but, like making your own typeclasses, they are rather rare
04:28:30 <Ghoul_> is it more memory efficient to use existential quantification? Do you know if it decays down to RTTI-like stuff, or whether they are equivalent
04:28:31 <jophish_> I have a library which parses a C like language, and uses LLVM to JIT this code and run in. Much like a scripting language. The parser I've written in C++ is great, but the code is overly complicated and full of boilerplate. I'd really like to use Haskell for parsing and AST construction (at the least), but I do want to keep the C++ interface to this library. What can people suggest for this? Ideally I'd l
04:28:31 <jophish_> ike to have some Haskell which compiles to a static library and a C header to which I can link my C++ interface to get Haskell to do the heavy lifting. Is this at all possible?
04:29:09 <merijn> Ghoul_: No, actually existential quantification is probably worse, as it has to store the typeclass dictionary with your values everywhere
04:29:18 <Ghoul_> oh dear
04:29:50 <merijn> jophish_: You can compile haskell to a library that is callable from C no problem
04:30:11 <merijn> jophish_: I'm not sure how C++ and C interact, but calling haskell from C++ should be as easy as calling C from +
04:30:23 <jophish_> merijn: I'd also have to link in the Haskell runtime too I guess
04:31:05 <merijn> jophish_: I think it already gets linked into your library
04:31:26 <shachaf> merijn: There are some cases where I think existentials have better memory usage (sadly), but I'm too tired to go into detail right now. :-)
04:31:30 <merijn> jophish_: Minimal example on the wiki is: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
04:31:34 <shachaf> Remind me tomorrow or something if you care.
04:31:45 * shachaf >=> sleep
04:31:53 <merijn> shachaf: Oh, probably, but probably *in general* EQ is worse
04:32:12 <jophish_> merijn: yeah, I was looking at that, it seems to use ghc to compile the C. I'm using clang for my c++. I'll have a little play with things and see where I get to
04:32:25 <merijn> jophish_: No, ghc just calls gcc to compile C code
04:32:42 <merijn> jophish_: Actually, no
04:32:54 <merijn> jophish_: cabal can call gcc for you, ghc doesn't compile C at all there
04:33:16 <merijn> ugh, I should just shutup and stop wrongly correcting myself
04:33:39 <merijn> jophish_: ok, final attempt, ghc call gcc to compile the C file and then calls ld to link the C object code with the haskell library
04:33:46 <thoughtpolice> sure it does, you can compile a C file with GHC that correcly has all the includes and whatnot set
04:33:56 <thoughtpolice> you may need linker options aside from that, but you can provide those too
04:34:30 <thoughtpolice> the reasoning is if you do 'ghc foo.c', you probably want GHC to set the include paths correctly (because it's error prone to do it yourself.) cabal happens to know this anyway and does it itself
04:34:45 <merijn> jophish_: If you just use cabal (as you should for any real project!) you can specify all the gory C compilation/linker flags in your cabal file and cabal will deal with it
04:34:45 <jophish_> ah, I see
04:34:48 <thoughtpolice> you need this in order to do things like start the haskell runtime
04:34:52 <thoughtpolice> since you need to call hs_init
04:35:19 <jophish_> I'm using CMake for the C++ at the moment. Hopefully I can just call out to cabal from that
04:36:16 <merijn> jophish_: It's a bit trial and error to get working the first time, but once you figure it out it's actually really easy
04:36:19 <Yaniel> sure you can, it doesn't have support for custom commands for nothing
04:37:03 <jophish_> In the end I'd like to have a "lite" version of my library which reads in binary files, and doesn't require haskell for parsing. The "heavy" version will be able to read in human-written scripts
04:37:40 <jophish_> Finding an appropriate split between Haskell and C++ will probably require a bit of thought
04:37:51 <jophish_> and how to pass data between the two efficiently
04:38:41 <merijn> jophish_: If only one side ever needs to work on the data it's easy, haskell already supports pointers for all primitive types and there is StablePtr for handing haskell values to C
04:39:07 <merijn> jophish_: If both sides need to update/mutate data you will need a Storable instance, which is a bit messy to get going at first, but not very hard
04:39:35 <jophish_> I don't think that both sides will ever need to modify the same data
04:40:05 <merijn> jophish_: Oh, then you can party, because Storable is the only really hairy part of the FFI IMO
04:40:34 <jophish_> C++ will give some parameters to Haskell needed to parse the file correctly, and Haskell will either write the binary result to disk, or send it straight back to C++
04:40:50 <dlackili> How can a linear congruential generator such as x' = 17 x + 6, mod 340282366920938463463374607431768211447 be written in haskell?
04:41:00 <dlackili> If x' = 3, find x.  That is, find the value that is output just before 3.
04:42:00 <allsystemsarego> jophish, have you considered named pipes for transferring JSON data back and forth between Haskell and C++?
04:42:22 <jophish_> allsystemsarego: nope, that's not crossed my mind.
04:42:47 <jophish_> I'm not sure that JSON is really the right tool for the job
04:42:51 <allsystemsarego> it's all in unix-land, right?
04:43:17 <jophish_> allsystemsarego: There's no reason why it shouldn't run on Windows in the end
04:43:47 <jophish_> It would be nice to have this on iOS too, so loading this from a binary file should be as speedy as possible
04:44:43 <merijn> I need a queue that supports fold, any recommendations? The typical double list approach doesn't work to well as I'd have to reverse + append the second list on every fold...
04:44:52 <haasn> dlackili: I don't know enough about the mathematics of what you're doing to be of much use but note that you can totally implement modulo 340282366920938463463374607431768211447 calculations.
04:45:08 <opqdonut> merijn: Sequence?
04:47:00 <merijn> opqdonut: I guess that's probably the best approach
04:48:26 <haasn> dlackili: (does that number have an actual solution, by the way, or did you just make it up?)
04:48:41 <dlackili> haasn: It has a solution
04:49:43 <shachaf> dlackili: #haskell is not the place for your puzzles.
04:50:20 <dlackili> shachaf: Where is?
04:50:25 <dlackili> #esoteric?
04:50:29 <shachaf> I don't know. But not here.
04:55:46 <merijn> :(
04:55:53 <merijn> I want foldMap for MonadPlus...
04:56:22 <YoungFrog> dlackili: ##math might be a good place
04:56:49 <dlackili> YoungFrog: Do they discuss programming there?
04:56:58 <dlackili> math programming
04:57:08 <YoungFrog> IDK, but it looks more like a math puzzle than a programming one
04:58:00 <YoungFrog> it is trivial to solve using a computer, given enough time.
04:58:07 <YoungFrog> (at least if a solution exists)
04:58:15 <mauke> merijn: isn't existentials equivalent to objects in C++?
04:58:28 <mauke> I mean, objects store a pointer to a vtable of methods
04:58:40 <mauke> and an existential value bundles a typeclass dictionary with the value
04:59:48 <merijn> mauke: I have no clue
05:00:05 <shachaf> I don't think it's "equivalent" but it's certainly related.
05:00:50 <haasn> (but you can still cast things in C++)
05:00:51 <shachaf> Objects are existential, at least.
05:01:28 <shachaf> For one, existentials don't need type classes.
05:01:59 <shachaf> s/For one/By the way/
05:02:06 <merijn> blah
05:02:26 <mauke> I mean, regarding memory use
05:02:36 <merijn> Sequence doesn't have "pop :: Sequence a -> Maybe (a, Sequence a)"
05:02:42 <shachaf> Oh. Yes, more or less.
05:02:53 <shachaf> That was my objection before I pretended to myself I was going to be able to go to sleep.
05:03:27 <shachaf> You can have that without a type class, too: [exists x. (x, (x -> Int, x -> Char, x -> Bool, ...))] vs. [(Int, Char, Bool, ...)]
05:03:30 <mauke> merijn: viewr?
05:03:42 <shachaf> In the former case you can share the entire tuple of functions between cases.
05:04:13 <shachaf> In the latter you pay more memory the more "methods" you have.
05:04:42 <merijn> mauke: Well, I think viewl, but oh well
05:04:46 <merijn> I must be blind
05:04:50 <mauke> that's shift, not pop!
05:04:58 <haasn> merijn: (cons ^?) -- wooh
05:05:05 <haasn> err
05:05:07 <haasn> (^? cons)
05:05:53 <haasn> not cons, actually
05:06:00 <haasn> _Cons
05:06:06 <shachaf> :t preview _Cons
05:06:07 <lambdabot> (MonadReader s m, Cons (->) (Control.Lens.Internal.Getter.Accessor (First (a, s))) s s a a) => m (Maybe (a, s))
05:06:12 <shachaf> good type
05:06:14 <haasn> I keep forgetting that name!
05:06:26 <haasn> :t preview _Cons `asAppliedTo` [1,2,3]
05:06:26 <shachaf> > preview _Cons "beep"
05:06:27 <lambdabot> Num t => [t] -> Maybe (t, [t])
05:06:29 <lambdabot>   Just ('b',"eep")
05:06:34 <shachaf> > preview _Snoc "beep"
05:06:36 <lambdabot>   Just ("bee",'p')
05:09:11 <timbod> Just experimenting with ghc-mod+emacs - it's pretty cool. Any other users here?
05:09:29 <timbod> I'm having a tools experimentation kind of day...
05:09:30 <Guest60363> What can it do thats cool?
05:09:48 <Guest60363> Can somebody try to compile the code from: http://lpaste.net/91226
05:09:58 <Guest60363> its just from the PersistentSQL tutorial
05:09:58 <timbod> Recompiles the file as I type, and has tooltips for the ghc errors.
05:10:15 <Guest60363> I'm getting a compile error that I don't understand
05:10:18 <Guest60363> cool
05:10:25 <haasn> :t preview _Cons `asAppliedTo` Seq.fromList [1,2,3] -- oh, we actually have this here
05:10:26 <lambdabot> Num a => Seq.Seq a -> Maybe (a, Seq.Seq a)
05:10:28 <Guest60363> didn't the haskell-mode just get updated?
05:10:47 <Yaniel> :t repeat
05:10:48 <lambdabot> a -> [a]
05:10:56 <Yaniel> :t take
05:10:57 <lambdabot> Int -> [a] -> [a]
05:11:05 <timbod> Maybe - I'm relying on the elisp that comes with ghc-mod (which extents haskell-mode I think).
05:11:53 <Guest60363> I'll have to try all those things. I also want to try using HLint via haskell-mode as well
05:13:30 <Guest60363> @timbod: If you don't mind, could you use your new ghc-mod fancy to help figure out my compile error I pasted?
05:13:30 <lambdabot> Unknown command, try @list
05:14:31 <timbod> Guest60363: Probably not - it looks like it depends on a whole bunch of database packages....
05:14:47 <Guest60363> ok
05:14:54 <HugoDaniel> how can i change a class like this or datatype so that it has less-rigid type vars: class MyClass a where myFunction :: MyData a b c d e f g  ?
05:15:11 <Guest60363> i think its just
05:15:45 <Guest60363> timbod: cabal install persistent persistent-sqlite persistent-template
05:17:48 <timbod> Guest60363: I don't know anything about those packages, but looking at the code and the error, can't you just evaluate the print in the IO monad of main,  outside the runSqlite call?
05:18:34 <Guest60363> timbod: I could, but I was hoping to figure out why the compiler is giving me a hard time about liftIO. From reading other examples online it seems like it should go
05:19:10 <timbod> ie: http://lpaste.net/91227
05:19:17 <Guest60363> I'll keep googling and see if anyone else has had that problem.
05:26:51 <jkoppel> I need a function that escapes Haskell characters. That is, foo '\\' = "\\\\" but foo 'a' = 'a'
05:27:16 <jkoppel> Neither showLitChar nor show work
05:27:26 <tulcod> jkoppel: basically show, but drop the first and final char
05:27:28 <tulcod> ?
05:27:50 <jkoppel> tulcod: Already thought of that. The thought makes me cringe
05:28:04 <tulcod> jkoppel: why does it?
05:28:16 <tulcod> it's what you asked for, except for the quote at the beginning and the end
05:28:54 <merijn> jkoppel: "Your example is a type error anyway
05:29:01 <jkoppel> tulcod: Because that's complicated, high-information behavior, but this task is common and Haskell-y enough that I expect the function to already exist
05:29:21 <merijn> "\\\\" is a string, but 'a' is a char :)
05:29:23 <jkoppel> merijn: foo 'a' = "a" . A typo-error more than a type error
05:29:40 <tulcod> jkoppel: what do you mean by "high-information behavior"? you're asking to escape haskell characters!
05:29:43 <mauke> jkoppel: why do you need that?
05:29:44 <merijn> jkoppel: Why do you need to escape these Char?
05:30:15 <jkoppel> I'm trying to print Java string literals
05:30:17 <tulcod> jkoppel: also, fuck complicated. if it works, it works.
05:30:30 <jkoppel> tulcod: Please remind me never to hire you
05:30:39 <tulcod> jkoppel: never hire me.
05:30:46 <jkoppel> :D
05:30:50 <mauke> jkoppel: java doesn't understand haskell escape sequences
05:31:02 <jkoppel> mauke: Exactly
05:31:09 <mauke> so you have to write your own anyway
05:31:10 <jkoppel> That's why I want it per character
05:31:19 <jkoppel> So I can override the ones where they differ
05:31:21 <tulcod> jkoppel: but i'm not joking man. if you'd be looking for a perfect and elegant solution, you would just rewrite the java stuff to haskell.
05:31:33 <jkoppel> tulcod: What Java stuff?
05:31:48 <mauke> because "serialize characters into java syntax" is not a common or haskelly task
05:31:49 <tulcod> jkoppel: well i dunno, for some reason you need to interact with java
05:31:49 <petapetapeta> jkoppel: Can't you use intercalate?
05:32:30 <jkoppel> tulcod: Not interact with Java; act on Java :)
05:32:40 <petapetapeta> jkoppel: oh misread what you wanted to do. nvm
05:33:09 <jkoppel> mauke: Yep. I'm serializing characters into Haskell syntax, except where Haskell syntax differs from Java
05:33:20 <tulcod> jkoppel: well clearly you have a reason to do that, and it's never going to be perfect or elegant, because in the end it's java.
05:33:38 <jkoppel> tulcod: This has nothing to do with Java
05:33:48 <tulcod> huh :o
05:33:49 <jkoppel> I just want to print out a character the way it's escaped in Haskell
05:34:05 <tulcod> no you don't?
05:34:13 <merijn> There's no way to toggle of 1 specific instance of a warning, right?
05:34:30 <jkoppel> merijn: You can do it per file
05:34:33 <jkoppel> tulcod: ???
05:34:33 <merijn> i.e. I wanna silence one orphan instance warning without silencing them all
05:36:07 <tulcod> jkoppel: if that's what you wanted, why did you start about java?
05:36:11 <tulcod> <jkoppel> I'm trying to print Java string literals
05:36:24 <jkoppel> tulcod: Because people asked what I'm trying to do
05:36:41 <tulcod> <jkoppel> tulcod: This has nothing to do with Java
05:36:49 <tulcod> i mean, wth?
05:37:05 <jkoppel> The question I asked has nothing to do with Java
05:37:14 <jkoppel> The program that this is going into has a lot to do with Java
05:37:26 <tulcod> what you asked for is show
05:38:31 <jkoppel> I want a function foo such that (show :: String -> String) is equivalent to (map foo)
05:38:39 <jkoppel> This is the kind of thing that should exist
05:39:00 <mauke> jkoppel: can't
05:39:07 <mauke> that's not how Haskell syntax works
05:39:12 <jkoppel> Modulo start and end quotes
05:39:35 <jkoppel> I just want to show a single character the way Haskell does
05:39:41 <mauke> > '\14'
05:39:42 <lambdabot>   '\SO'
05:39:45 <mauke> > ['\14', 'H']
05:39:46 <lambdabot>   "\SO\&H"
05:39:53 <mauke> it's not composable
05:40:08 <jkoppel> mapcat (or whatever it's called in Haskell), not map, sorry
05:41:04 <tulcod> jkoppel: the closest you'll get is show :: Char -> String
05:41:44 <tulcod> @ map show ['\14', 'H']
05:41:46 <jkoppel> *sigh*
05:41:54 <tulcod> uh... how does lambdabot work again? :P
05:41:58 <jkoppel> Fine, init.tail.show it is
05:42:06 <mauke> > let ho = init . tail . show in ho '\14'
05:42:06 <lambdabot>   "\\SO"
05:42:16 <mauke> > let ho = init . tail . show in concatMap ho ['\14', 'H']
05:42:17 <lambdabot>   "\\SOH"
05:42:20 <mauke> and that's broken
05:42:32 <merijn> Can anyone clarify the difference between -fno-warn-unused-do-bind and -fno-warn-wrong-do-bind? (http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/flag-reference.html)
05:43:40 <mauke> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/options-sanity.html
05:43:51 <merijn> Oh! Is the latter just a special case of the former when throwing out monadic actions?
05:44:41 <mauke> probably
05:44:58 <jkoppel> A few weeks ago I saw a website where you can type in a few input-output pairs and it will synthesize a Haskell function that does that. Anyone know what it's called?
05:58:29 <HugoDaniel> how can i do this: class MyClass a where f :: MyData a b c d e f ?
05:58:45 <HugoDaniel> and let b c d e f be any kind
06:01:51 <supki> HugoDaniel: should work as is
06:02:21 <supki> assuming MyData is defined somewhere
06:03:12 <HugoDaniel> it is, but i get this errors saying that Couldn't match type `i1' with `UUID' `i1' is a rigid type variable bound by
06:03:15 <HugoDaniel> ...
06:03:32 <Placinta> Why is Happstack.Foundation grayed out at the bottom of the page? Is there a specific reason the source is unavailable? http://hackage.haskell.org/package/happstack-foundation-0.4.0
06:04:22 <supki> HugoDaniel: OK. Then you need to paste real code with error message instead
06:06:11 <HugoDaniel> its a rigid type variable
06:06:16 <HugoDaniel> how can i make it not ?
06:06:22 <HugoDaniel> its a load of code :/
06:06:44 <HugoDaniel> a generic
06:07:06 <sopvop> HugoDaniel: maybe lpaste.net?
06:14:18 <HugoDaniel> here: http://lpaste.net/91228
06:16:09 <HugoDaniel> meh, lpaste broke the input or something
06:16:51 <HugoDaniel> screw this
06:23:35 <supki> HugoDaniel: I suggest making much smaller example with the same problem
06:25:30 <HugoDaniel> ok: class MyClass a where myFunc :: MyData a b c; instance MyClass Stuff where myFunc = MyData Stuff Int ()
06:27:15 <bscarlet> HugoDaniel: two things
06:28:02 <bscarlet> HugoDaniel: : first, in "MyData Stuff Int ()", Int is a type constructor, not a data constructor, so it doesn't work where you put it.
06:28:32 <HugoDaniel> yes, sorry, MyData1 0 :: MyData Int ()
06:28:41 <HugoDaniel> that
06:29:48 <bscarlet> HugoDaniel: second: the declaration for myFunc as MyData a b c means that the first parameter must be "a", the type for which you're definining an instance - and "b" and "c" must be free - able to be any type - not something specific but unknown.
06:30:05 <HugoDaniel> yes exactly
06:30:13 <HugoDaniel> how can i make them less rigid ?
06:30:26 <HugoDaniel> there must be an easy way to this
06:30:49 <bscarlet> bscarlet: does the type "a" determine what the types "b" and "c" should be?
06:31:13 <HugoDaniel> no
06:31:18 <HugoDaniel> they are related, but not determined by a
06:31:36 <HugoDaniel> it can be any type you want
06:32:06 <bscarlet> HugoDaniel: any type who wants? The writer of the instance, or the caller of myFunc?
06:32:16 <HugoDaniel> the writer
06:33:05 <taylorgb> Perhaps if you provided an example of how you would use the myFunc/MyData then it might be easier to identify the problem you're trying to solve
06:33:40 <bscarlet> HugoDaniel: sorry to re-ask a question, but I want to be sure I don't take you in a bogus direction. Might there be multiple instances of MyData, each with the same "a", but with different "b" & "c"? If not, then "a" does determine "b" and "c"
06:36:05 <HugoDaniel> then a determines b and c
06:36:08 <HugoDaniel> yes
06:36:49 <HugoDaniel> for a given a, there is always going to be the same b and c, but b and c are two types that can have no other relation to a besides that one
06:37:08 <bscarlet> HugoDaniel: there are two different approaches, each an extension of Haskell, which are probably what you want.
06:37:15 <HugoDaniel> cool
06:37:41 <bscarlet> HugoDaniel: multi-parameter type classes, and type families.
06:37:53 <HugoDaniel> multi-parameter type classes wont work
06:38:01 <bscarlet> HugoDaniel: why not?
06:38:29 <HugoDaniel> well at least not the way i tried
06:38:30 <luite> i guess bscarlet means mptcs with fundeps
06:39:00 <HugoDaniel> because i have other type class instances depending on this definition, but i can change those too
06:39:15 <bscarlet> HugoDaniel: if the depencency of b and c on a exists, then you could use a functional dependency and that might help.
06:39:58 <HugoDaniel> ive read the ghc manual about those
06:40:03 <HugoDaniel> but i couldn't understand it
06:40:27 <bscarlet> HugoDaniel: well, here's the place to figure it out.
06:40:54 <HugoDaniel> :D
06:43:55 <HugoDaniel> http://lpaste.net/91229
06:44:02 <HugoDaniel> this is the simplest i can make
06:44:03 <HugoDaniel> i think
06:44:32 <HugoDaniel> sorry
06:44:33 <HugoDaniel> http://lpaste.net/91229
06:47:28 <bscarlet> line 8 looks weird.
06:47:39 <bscarlet> do you mean one more ()?
06:48:45 <HugoDaniel> sorry, just edited, i had the data declaration wrong
06:49:44 <HugoDaniel> http://lpaste.net/91229
06:49:53 <bscarlet> HugoDaniel: is "c" supposed to be () for MyData? Now it could be anything.
06:50:29 <HugoDaniel> its just supposed to be ignored
06:50:33 <dmwit> class Indexable a b c | a -> b c where ...
06:50:59 <dmwit> instance Indexable MyData Int (); instance Indexable MyOtherData Double Double
06:51:02 <HugoDaniel> i used () because i dont know better i guess :/
06:52:31 <bscarlet> http://lpaste.net/91233
06:52:35 <bscarlet> example with type families
06:53:12 <HugoDaniel> wow this is amazing flexibility
06:53:40 <HugoDaniel> let me try it out
06:53:59 <bscarlet> http://lpaste.net/91234
06:54:05 <bscarlet> example with multiparam type classes
06:54:53 <yesthisisuser> is there a standard combinator g f x = f x x ?
06:55:29 <Rarrikins> @pl \f x -> f x x
06:55:29 <lambdabot> join
06:55:29 <HugoDaniel> is there any way to avoid having to write all those () types when they are supposed to be ignored ?
06:55:47 <bscarlet> HugoDaniel: the multiparam typeclasses, as written, does _not_ require b & c to be dependent on a. As such, the typechecker won't be able to figure out b & c given a, for fear there might be other instances with the same a but different b or c.
06:56:00 <bscarlet> HugoDaniel: Will MyData never use Index2?
06:56:34 <HugoDaniel> yes, that is guaranteed
06:56:38 <HugoDaniel> it will never use it
06:56:52 <Rarrikins> > join (*) 7
06:56:53 <lambdabot>   49
06:57:04 <merijn> If I want fairness when dealing with multiple Chan's I guess I will need to have a set of Chan's and round-robin reading from them, rather than having multiple clients write to a single Chan, right?
06:57:34 <bscarlet> HugoDaniel: Then perhaps you don't want the class declaration to specify SimpleIndex for both, but rather different types for each.
06:57:51 <HugoDaniel> bscarlet: let me show you the whole module
06:57:55 <yesthisisuser> thanks Rarrikins
06:58:39 <HugoDaniel> bscarlet: http://lpaste.net/91235#line118
06:58:49 <dmwit> merijn: depends what "fair" means, I guess
06:59:13 <HugoDaniel> the class is in 246
06:59:15 <HugoDaniel> but yes
06:59:42 <merijn> dmwit: fair means any TChan that has readable info, will be read
06:59:44 <HugoDaniel> bscarlet: so i can use a newtype to avoid the () ?
07:00:11 <merijn> dmwit: i.e. if one thread writes 1000 messages per second it shouldn't be able to drown out/hurt responsiveness for others
07:00:29 <bscarlet> HugoDaniel: I don't know what approach you mean by that.
07:00:44 <HugoDaniel> yes true, sorry, it wouldn't work
07:00:44 <dmwit> round-robin doesn't make that promise...
07:01:25 <bscarlet> HugoDaniel: what I'm saying is that rather than having "Indexed" with as many parameters as you might ever need, only one constructor in use for any given "a", you might have Indexed1, Indexed2, etc, each with one constructor.
07:01:34 <merijn> dmwit: The simplest way I could think of implementing it is a queue of TChan's, use fmap readTChan and "foldr (<|>)" to select the first readable TChan, then pop it and move it to the end of the queue
07:01:59 <merijn> dmwit: That means that *if* others have data they will be read before the last read one
07:02:41 <merijn> But that seems a rather expensive implementation
07:02:47 <merijn> I was wondering if there was a more efficient approach
07:03:48 <dmwit> I see. That seems reasonable.
07:04:29 <HugoDaniel> bscarlet: yes but then could i also use the strategy of defining functions like _ixInsertData4 (ln 60)
07:07:05 <Sculptor> yo
07:07:24 <bscarlet> HugoDaniel: 'fraid that's more code that I can completely internalize right now. We're talking about design decisions rather than language questions. Sorry I can't be more help at this point. I can just say it seems weird to have the type with many constructors, only one of which you will use for any given concrete type.
07:07:56 <HugoDaniel> yes, thank you :)
07:16:38 <jophish_> sorry, distracted by board games. Thanks for the advice merijn, Yaniel thoughtpolice
07:34:53 <merijn> There's no "non-empty list" type, right? Like "data Foo a = Tail a | Cons a (Foo a)"
07:36:24 <bergmark> merijn: semigroups and NonEmptyList defines it
07:37:42 <chrisdone> lambdadoodledoo
07:37:51 <bscarlet> Suppose I want to write the type for an action which consumes and/or destroys something. Is (IO a -> IO b) (for something consuming an a and producing a b) a decent way to do it? I haven't seen such a pattern, but it seems to avoid the problem of escaping invalid values that goes along with approaches like the one used by "bracket".
07:38:05 <bergmark> ohai chrisdone!
07:38:16 <chrisdone> y halo thar!
07:39:04 <merijn> bscarlet: "IO a -> IO b" would be "a function that takes an "a producing action" and returns a "b producing action""
07:39:43 <bergmark> chrisdone: doing well in fpc land?
07:40:06 <chrisdone> bergmark: yup, thanks
07:40:11 <merijn> bscarlet: Whether that's a decent way to do it depends on what exactly you want to do
07:40:17 <chrisdone> bergmark: doing well in hol land?
07:40:30 <bergmark> :3 yeah just got back from vacation
07:40:43 <chrisdone> where'd you go?
07:41:03 <bergmark> sweden, i built a moose fence to complete the experience
07:41:05 <merijn> bscarlet: Is it supposed to only produce an 'a' once?
07:41:06 <bscarlet> merijn: right. Hence it seems to encapsulate the lifespan of any "a"s it chooses to make in a way which doesn't let the user of the function hang onto them after it (presumably) consumes them.
07:41:40 <chrisdone> bergmark: notbad.jpg
07:41:53 <bscarlet> merijn: only once? That'd likely be common but is not encoded in the type, so no. It might make more than one.
07:42:01 <merijn> bscarlet: Or is it supposed to repeatedly produce a's and do something with it?
07:43:23 <merijn> bscarlet: Well, if it's only supposed to produce an a once you probably want "a -> IO b" so you can use >>= to combine the production of one a with the production of one b. If, however you intend to produce multiple a's for every b (for example, a loop that consumes lines until you reach an empty line) then "IO a -> IO b" is a lot more sensible
07:44:07 <merijn> bscarlet: It's certainly not "wrong" to pass IO actions to functions, it's rather common, even. Yay for first class IO!
07:45:00 <Ghoul_> type metaprogramming, kinda. courtesy of simon. https://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/axioms-extended.pdf
07:45:24 <bscarlet> merijn: the problem with (consume :: a -> IO b) is do { a <- make; b0 <- consume a; b00m <- consume a; }
07:45:47 <merijn> bscarlet: Why is that a problem?
07:46:50 <bscarlet> merijn: as an encoding for an underlying IO action which makes the "a" unusable or even unsafe to use, it allows reuse of a "bad" a.
07:47:39 <merijn> bscarlet: The only solution to that problem is "be very, very careful"
07:48:00 <merijn> Or, use indexed monads, but I don't think haskell has nice support for those yet :\
07:48:10 <bscarlet> merijn: yet I have this nifty tool called the Haskell type system to help me be very very careful.
07:48:43 <adnap> Could you use an MVar?
07:48:54 <merijn> bscarlet: Using the type system for this is significantly harder than you think
07:49:02 <adnap> Or IORef?
07:49:15 <merijn> adnap: How would that help?
07:49:39 <adnap> merijn: Well, you're not guaranteed to get the same thing out of an IORef when you read it, right?
07:49:51 <merijn> adnap: So?
07:49:57 <bscarlet> merijn: why do you think I don't think it's hard? :-)
07:50:00 <merijn> bscarlet: Actually, I think I know what you want
07:50:28 <merijn> bscarlet: You just want "Monad m => m a -> (a -> m b) -> m b"
07:50:43 <adnap> So, a function IORef a -> IO b would be able to take an a and also mess it up
07:51:35 <merijn> bscarlet: Consume an a to produce a b, no possibility to leak said a
07:51:48 <merijn> bscarlet: Incidentally, that function is also known as >>= ;)
07:52:17 <merijn> Although you could do "let consume = (>>=)"
07:52:28 <Cale> bscarlet: Haskell's type system doesn't have uniqueness types... you can't really do something at the type level to prevent a variable from being used in more than one place in the code.
07:53:01 <merijn> Unless you use indexedmonads, which is not very convenient (yet?) in haskell
07:53:24 <merijn> I would actually <3 do-notation for indexed monads :>
07:53:37 <merijn> While we're at it, add idiom braces too :>
07:54:23 <adnap> That wouldn't work
07:54:24 <Cale> Well, yeah, you *can* arrange for various combinator libraries where you compose actions together in some other way which doesn't let you bind the values being passed around to a reusable variable.
07:54:44 <bscarlet> Cale: yes
07:55:02 <Cale> e.g. a restricted state monad which only has operations that you want, and not get/put
07:56:10 <adnap> make >>= (\a -> consume (return a) >> cosume (return a)) ?
07:56:34 <adnap> Oh, that's wrong
07:57:30 <adnap> What is the function (a -> m b) that one would pass to consume?
07:57:51 <Cale> What's the type of consume?
07:58:22 <adnap> Well, originally it was a -> m b I think, but then it became m a -> (a -> m b) -> m b
07:58:34 <bscarlet> merijn: I think your interpretation of the relationship between (>>=) and consume isn't quite right. It's not that (>>=) is consume, rather that (=<<) is the function which turns a consumer of escaped things (a -> IO b) into a consumer of yet-to-be-made things (IO a -> IO b).
07:58:38 <adnap> ...per merijn's suggestion
07:59:01 <merijn> bscarlet: No, because the IO monad can't encode what you want
07:59:12 <Cale> bscarlet: Perhaps you could be more specific about your use case?
07:59:17 <merijn> bscarlet: "a -> IO b" could use a 15 times if you like
07:59:38 <adnap> I wonder if IO is even necessary
08:00:07 <bscarlet> merijn: It's not what's inside the (a -> IO b) that I'm worried about. It's letting the "user" of that function have unfettered access to an "a".
08:01:25 <Gracenotes> hm. GHC doesn't really have C main, does it.
08:01:28 <adnap> How is the person calling the function and passing in a not going to have access to a?
08:01:50 <Cale> bscarlet: What are you actually using this for?
08:02:07 <Cale> Maybe with a concrete example, it'll be more obvious what sort of thing might be done.
08:02:37 <bscarlet> I'm working on my LLVM bindings. I've got an IO action which translates a pure haskell AST for an LLVM module into a (mutable) C++ representation of the same, and various nifty things I want to represent that one can do with those C++ representations.
08:03:35 <bscarlet> Right now I'm using a bracket-like pattern
08:04:37 <bscarlet> e.g. withModuleFromAST (someHaskellAST) (\cppModule -> emitTheModuleAsAnObject cppModule)
08:05:25 <bscarlet> where withModuleFromAST deletes the C++ object after running the second argument (the emit in this case).
08:05:25 <brisbin> can anyone tell me why the second example doesn't work? http://sprunge.us/IKSP?hs
08:06:20 <bscarlet> It's idiomatic, but not safe - (withModuleFromAST ast return) would produce a bogus C++ module.
08:06:53 <bscarlet> It's okay as far as it goes, but now I'm trying to expose LLVM's ability to link modules.
08:07:05 <klrr> morning
08:07:24 <Gracenotes> you want combinators to do chaining, but only want things to be chained in a particular order?
08:07:50 <bscarlet> And the LLVM module linker, for the sake of efficiency, can cannibalize the input modules.
08:07:52 <Gracenotes> (chaining with taking care of resources)
08:08:24 <bscarlet> Gracenotes: That's one way I've thought about it. I'm not 100% sure that that idea fully encapsulates what I'm trying to do, but it feels right.
08:09:34 <merijn> hmm
08:09:53 <merijn> Is it insane to make (via newtype) "a -> IO b" an instance of Exception?
08:10:41 <chrisdone> you trying to implement conditions? :)
08:10:48 <Gracenotes> is cppModule itself immune to modification, or is it e.g. a filename that could be accessed by some interleaved action in the second arg?
08:11:12 <Cale> brisbin: maybe put a space between p and #big-goal?
08:12:24 <Cale> brisbin: hmm, no, that doesn't seem like it should be required...
08:12:35 <Cale> http://hackage.haskell.org/packages/archive/HandsomeSoup/0.3.1/doc/html/src/Text-CSS-Parser.html -- this is the parser it's using
08:12:37 <merijn> chrisdone: No, just an IO action that has a notion of "retryable" error, so it will throw a "resume" function. Depending on context I can either let the propagate and let the thread die or wrap in a "keep retrying" thread that basically loops "allocate resource, run functionality, on error free resource"
08:12:40 <brisbin> Cale: even just "#big-goal" doesn't find it
08:13:14 <merijn> chrisdone: i.e. if my socket disconnects I want to implement "stateful" resume that lets me continue as soon as I've managed to reconnect the socket
08:13:21 <bscarlet> Gracenotes: it's a pointer to a compex C++ object, for which there are many possible C++ functions, some of which use it in a beautifully clean functional manner (e.g. emit it as bitcode), others of which mutate it to other interesting states, yet others of which mangle it beyond usability.
08:14:10 <Gracenotes> and you're also allowed to mangle it beyond usability if you were coding in C++, imaginably
08:14:18 <brisbin> Cale: do you know if Parsec's alphaNum supports "-" ? that might be it
08:14:31 <Cale> Oh, right, haha, it does not.
08:14:44 <brisbin> so that's the bug :(
08:15:16 <klrr> intel doing haskell research =o
08:15:27 <chrisdone> merijn: nod
08:15:51 <bscarlet> Gracenotes: yes. e.g. make two Modules, then link one into the other. All the abstract value of the one is transfered to the other, so LLVM will happily mangle the one in the process.
08:16:07 <Cale> klrr: Intel wants to be able to sell machines with many many cores, and languages like Haskell provide some measure of hope for being able to program such things :)
08:16:22 <klrr> Cale: awesome :D
08:16:44 <Adeon> why can't I hold all these cores
08:16:53 <klrr> havent done any parrarel or concurrent stuff though :P, oh well, i used forkIO when i wrote a simple chat program :P
08:16:56 <merijn> klrr: Intel does lots of things many people don't realise :)
08:17:16 <Gracenotes> bscarlet: have you some kind of low-level and high-level interface from the point of view of this client code? So one that operates entirely in IO and do arbitrary bad things, and a nicer high-level client API implemented in terms of that.
08:17:17 <merijn> Like patching up fortran support in gdb :p
08:17:44 <bscarlet> Gracenotes: essentially, though I'm mostly focused on the latter.
08:17:45 <ocharles> Is it bad form to post a link hacker news here asking for upvotes to help haskell evangelism? :P
08:17:51 <Gracenotes> both with the same pipeline, but one with more specialized types
08:17:56 <bscarlet> Gracenotes: and how to make it nice.
08:18:48 <Gracenotes> I'm even thinking of this IO a -> (a -> IO b) -> ... function as potentially belonging to the former
08:19:25 <bscarlet> Gracenotes: That function wasn't mine. I don't think it particularly helps. As merijn noted, it's actually just >>= anyway.
08:20:10 <merijn> bscarlet: The way to make this safe is to not export the unsafe bits in your API
08:21:07 <klrr> chrisdone: sry if #haskell might not be appropriate but i didnt find you in #haskell-blah so i ask here, im not in univ yet but im studying the school you go to before that (not sure if it's called "high school" or "college"), is that enough to get free account at fpcomplete? :)
08:21:21 <Gracenotes> how should the main of a client application at that level look? should it be: do { clientStuff; runLLVM $ yourBracket f g h }
08:21:44 <bscarlet> merijn: right. Yet I do want to enable linking. So I'm looking for a way to design the API to allow what is safe.
08:22:40 <Ghoul_> not badmouthing fpcomplete or anything, because I know its an excellent infrastructure, but I wasn't that impressed with the online IDE
08:22:46 <chrisdone> klrr: i think probably you have to have a .edu email. not sure
08:22:48 <bscarlet> Gracenotes: I don't really have something like "runLLVM" now.
08:23:18 <chrisdone> Ghoul_: didn't like it?
08:23:30 <klrr> chrisdone: oh okey
08:23:30 <Ghoul_> chrisdone: I just feel it lacks sublime/vim-power
08:23:43 <klrr> does the yesod author also work at fpcomplete?
08:23:57 <Gracenotes> klrr: yes
08:23:57 <chrisdone> yep
08:24:04 <Ghoul_> so I tend to prefer my local editors. The tutorials with the runnable code are very impressive though!
08:24:08 <Gracenotes> bscarlet: at the lowest level, you have things like AST -> IO CPP, CPP -> IO BC, BC -> IO (), yes? and for cleanup, things like cleanup CPP -> IO () etc.
08:24:19 <chrisdone> Ghoul_: did you try the vim mode?
08:24:21 <bscarlet> Gracenotes: yes
08:24:32 <Ghoul_> No, I haven't. Let me go search for it :)
08:24:57 <klrr> cool, fpcomplete has so many cool haskell people :D
08:24:59 <chrisdone> Ghoul_: the setting's in an awkward place, you have to go to your account settings and choose the editor mode in there
08:25:07 <klrr> is fpcomplete europe based?
08:25:35 <chrisdone> klrr: it's california based
08:26:26 <klrr> chrisdone: okey
08:26:44 <chrisdone> but people work from wherever they live ;)
08:26:49 <Gracenotes> bscarlet: there has got to be a Monad that makes >>= non-tail-recursive, i.e., doing cleanup after executing f.
08:27:11 <Gracenotes> It might not actually follow the monad laws
08:27:17 <bscarlet> Gracenotes: ContT
08:27:28 <chrisdone> ContT, mother of all monads
08:27:44 <Gracenotes> okay, maybe something with a more specialized type to LLVM stuff :p
08:28:08 <Gracenotes> I don't like continuations much
08:28:28 <klrr> i wish my next summerjob will be programming in haskell , next summer ill have learned much more :D
08:28:42 <bscarlet> I actually do a lot of that in the bindings. I use it to encapsulate the memory management goop I have to do to use LLVM through FFI.
08:28:50 <chrisdone> klrr :D
08:28:52 <Gracenotes> bscarlet: anyway, you might only export a handful of ways to get values in that monad
08:30:00 <Gracenotes> something like linear types, in a sense.
08:30:03 <bscarlet> Gracenotes: yeah. I gotta think about this more.
08:30:16 <bscarlet> merijn, Cale, Gracenotes: thanks
08:30:43 <Gracenotes> So rather than making a bracket function, make a bunch of puzzle pieces, and only one way (modulo additional low-level things) for the client to glue them together
08:30:46 <Ghoul_> the vim bindings are neat
08:31:07 <Gracenotes> okay, hopefully my ramblings were of some use.</rubber duck> :D
08:31:09 <chrisdone> Ghoul_: i heard they've improved with a more recent CodeMirror version
08:36:58 <mr_max> Any Emacs users? Is it possible to use "cabal-dev ghci" from within Emacs?
08:38:26 <chrisdone> mr_max: yeah
08:38:48 <mr_max> Oh. I've been trying your haskell-mode "process" thing
08:38:59 <Ankhers> If nothing else, you can always open a terminal within emacs and call it manually
08:39:25 <mr_max> Yeah. I want "C-c C-l" to work though..
08:39:25 <chrisdone> mr_max: did you set haskell-process-type to cabal-dev?
08:41:13 <mr_max> chrisdone: I actually have that working, but I was getting some errors when trying to load some stuff from "Persistent"
08:41:53 <chrisdone> mr_max: what errors?
08:42:13 <mr_max> err
08:42:39 <mr_max> basically compilation errors I didn't get when building normally, but now I'm having a hard time reproducing it
08:42:57 <merijn> And now, an ode to the (ab)use of first class IO "IO (Handle -> IO (), IO () -> IO (IO ()))" :D
08:44:49 * hackagebot amqp 0.4.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.4.1 (HolgerReinhardt)
08:44:53 <mr_max> chrisdone: its actually working now I thiink
08:45:02 <mr_max> chrisdone: thanks though!
08:45:07 <chrisdone> mr_max: mmk =)
08:45:39 <mr_max> chrisdone: I'm basically fighting a bit with Persistent and what seems to be occasionally weird TH errors
08:46:08 <mr_max> chrisdone: I'm still a haskell newbie/intermediate, and I'm experiencing my first trouble with "cabal hell"
08:47:43 <chrisdone> mr_max: cabal-dev/hsenv definitely required to avoid cabal hell
08:47:53 <chrisdone> =)
08:48:10 <mr_max> chrisdone: 1 more question: Normally in "standard ghci" line errors are clickable. For some reason right now they aren't. Any ideas?
08:49:52 <merijn> "cabal hell" == "I wanna be on the bleeding edge, but complain if I get so close I fall over"
08:49:52 <chrisdone> you can put your cursor on and press RET. or just hit C-x ` which uses the normal "next error" function
08:50:17 <merijn> chrisdone: Why do you think so? I've never used cabal-dev/hsenv in all my time coding haskell and never broke a thing
08:50:22 <chrisdone> merijn: what's "bleeding edge" in haskell?
08:50:35 <chrisdone> merijn: you've probably never done anything interesting then =)
08:50:35 <merijn> Not even when I was playing with Yesod...
08:50:40 <mr_max> got it
08:51:19 <merijn> chrisdone: I only update cabal when platform is released or when I need a newer version of a library than ships with platform
08:52:02 <chrisdone> merijn: good for you, wish i didn't rely on anything too?
08:52:08 * dcoutts runs cabal head
08:52:36 <merijn> dcoutts: I meant the package database, my cabal-install is head too, because I wanna be cool like you :x
08:52:44 <dcoutts> ;-)
08:53:15 <merijn> dcoutts: Or rather, because it allows me to type "cabal build" without configuring manually and allows C files as hs-main <3
08:53:29 <dcoutts> and lets you build specific targets!
08:53:37 <dcoutts> cabal build blah
08:55:12 <chrisdone> that whole "i don't have any problems in my particular use-cases so no one else's problems are legitimate" attitude is so eye-rolly
08:57:22 <merijn> chrisdone: I'm not saying no one has problems, I'm just curious. "cabal-dev is required" is a rather strong statement
08:57:55 <mr_max> merijn: What platform are you running?
08:58:10 <merijn> chrisdone: So I was just curious which use case you have that makes it required,
08:58:20 <merijn> mr_max: haskell platform or OS?
08:58:37 <mr_max> merijn: Haskell platform (2012/13)
08:58:49 <merijn> mr_max: Latest
08:59:00 <mr_max> merijn: actually.. are you on linux?
08:59:05 <merijn> mr_max: No, OSX
08:59:35 <mr_max> merijn: ok. I think some of my problems I'm having right now could be fixed with 2013, but I wasn't sure how to install it on ubuntu
09:00:44 <merijn> mr_max: The fact that stuff like platform just has a 1-click binary installer for OSX is part of the reason I prefer to use it :)
09:01:27 <shoret> at least on fedora, you can just "yum install haskell-platform" and be done
09:01:29 <b2coutts> merijn: but it takes several clicks to get to that 1-click stage :)
09:01:54 <b2coutts> I would argue that the "$package_manager install haskell-platform" method is much easier
09:02:34 <joelteon> like "brew install haskell-platform"?
09:02:37 <mr_max> does anyone here use ubuntu?
09:02:54 <merijn> b2coutts: Yet all the questions I see here with problems installing come from linux, not OSX and windows :)
09:03:10 <b2coutts> merijn: sampling bias :P
09:03:29 <shoret> mr_max: "apt-get install haskell-platform" doesn't work?
09:03:44 <merijn> b2coutts: Are you sure? I know quite a lot of people in here use OSX. Anyhoo, me trolling linux users if off-topic, so back to coding
09:04:00 <b2coutts> the set of people who use haskell, and would ask question on #haskell on freenode, and do things that will expose installation problems filters pretty strongly for linux users I think
09:04:14 <mr_max> shoret: It does, but I was hoping to upgrade to 2013, which I didn't updated in the package manager
09:04:18 <mr_max> unless i'm wrong
09:14:25 <mr_max> chrisdone: I'm actually have a new problem with the "process" way to launch ghci
09:14:33 <mr_max> chrisone: If you have a few minutes
09:23:31 <klrr> is there a "\x y -> fmap (fmap x) y" function?
09:25:26 <Gracenotes> :t \x y -> fmap (fmap x) y
09:25:26 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:25:28 <Gracenotes> @pl \x y -> fmap (fmap x) y
09:25:28 <lambdabot> fmap . fmap
09:27:24 <klrr> > ((\x y -> fmap (fmap x) y) (+ 2) [[3]]) == (fmap . fmap (+ 3) $ [[3]])
09:27:25 <lambdabot>   Couldn't match type `[[t0]]' with `a0 -> b1'
09:27:26 <lambdabot>  Expected type: [[t0]] -> a0 -...
09:27:29 <klrr> :/
09:27:29 <Gracenotes> this is kind of just fmap, if f∘f1 were a functor. see also: lenses
09:27:44 <Gracenotes> > (fmap.fmap) (+2) [[3]]
09:27:45 <lambdabot>   [[5]]
09:28:20 <tswett> Ahoy. I just installed a new version of the Haskell Platform. If I use uninstall-hs to uninstall all of the older versions (three of them!), is anything likely to explode?
09:28:42 <Gracenotes> > (fmap.fmap) (+1) [[3,4],[9000],[]]
09:28:43 <lambdabot>   [[4,5],[9001],[]]
09:29:13 <klrr> is theere any function in Elerea that can apply a normal function to the values inside a signal like lift in elm?
09:30:27 <bergmark> tswett: should be fine
09:45:23 <geekosaur> tswett, most stuff should continue to work since static linking is still default. if you are using something which uses compilation for configuration (example, xmonad) then you will need to remove the old version (using ghc-pkg) before removing its compiler version, then reinstall with the new compiler
09:45:45 <tswett> *nod*
10:15:04 <Chousuke> klrr: fmap? Signal seems to be a Functor
10:24:04 <klrr> Chousuke: aa great :D
10:24:54 <Sherman> I am trying to write an efficient depth-first search algorithm for directed graphs (as an exercise). This involves keep track of state (most notably a heap). Is this something that I could do efficiently in the ST monad? Or should I use the State monad (i.e., just handle the state functionally)?
10:26:20 <LovePuff>  18 F from Italy :) sellin' shows and pics :D Skype: ancuta.loredana
10:27:22 <shiona> :D
10:29:09 <c_wraith> I like how idoru never talks, but apparently watches this channel for spammers anyway
10:29:18 <djahandarie> It's a bot.
10:29:39 <c_wraith> How does it recognize spam?  Look for repeated messages across a bunch of channels?
10:30:36 <djahandarie> Presumably. Could be more advanced too perhaps (hidden markov models). Who knows.
10:31:57 <Chousuke> Sherman: I'd write it using State first and see how it performs.
10:32:24 <Chousuke> then you can try converting a working State implementation to ST or somethign
10:38:32 <Sherman> Chousuke: Okay, thanks for the advice! If I do end up using the ST monad, for the heap, would it be a good idea to use an STRef'd list for the stack?
10:40:33 <Chousuke> you'll want some data structure that's natively mutable or it likely won't help at all.
10:41:12 <Chousuke> all you'd be doing is adding a layer of indirection to your use of an immutable list.
10:43:51 <finity> Sherman: You probably want a State monad. I bet that will perform just fine.
10:47:29 <finity> Sherman: Be mindful about strictness though. You may end up "put"ing bigger and bigger thunks.
10:49:12 <dagano> can I ask basic haskell questions here? or is this channel devoted to researchers and the super-brilliant?
10:49:45 <tswett> dagano: you can definitely ask basic questions here.
10:50:02 <shoret> dagano: the researchers and super-brilliant people in haskell are amazingly happy to help newcomers
10:50:24 <shoret> and so's everyone else
10:50:45 <dagano> ok .. from an early projecteuler question . I naively came up with *Main Data.List> head [x | x <- [1..], sum (map (\d -> rem x d) [1..10]) == 0] 2520
10:51:02 <dagano> to be the first integer which is 'cleanly' divisible by all #'s 1 to 10
10:51:12 <dagano> the problem asks same for all #'s up to 20
10:51:15 <dagano> and I am timing out
10:51:23 <dagano> any hints on a more clever implementation?
10:51:35 <tswett> So, I have a header file /opt/local/include/gmp.h. ~/.cabal/config contains the line "extra-include-dirs: /opt/local/include".
10:51:42 <tswett> When I try to cabal install idris, I get "error: gmp.h: No such file or directory".
10:51:46 <tswett> Did I configure cabal wrong?
10:52:00 <dagano> head [x | x <- [1..], sum (map (\d -> rem x d) [1..10]) == 0]
10:52:32 <mr-> dagano: that possibly requires a little more thought. Think about prime factorizations
10:52:40 <tswett> dagano: have you heard of the Euclidean algorithm?
10:52:45 <dagano> yep
10:53:19 <tswett> The smallest integer cleanly divisible by m and n is lcm(m,n), right? And lcm(m,n) = m * n * gcd(m,n).
10:53:43 <mr-> dagano: i.e. all the prime factors of every number between 1 and 20 has to appear, and in its highest power
10:53:46 <dagano> as far as i remember
10:54:12 <mr-> s/has/have/ s/its/their/ ... or something, sorry
10:54:20 <dagano> oh yeah ... why would I need to check if it is divisible by 10 if i already checked 5
10:54:24 <dagano> is that close to the right idea
10:54:24 <dagano> ?
10:55:03 <tswett> dagano: well, do you know how you could use the Euclidean algorithm to find the least common multiple of 6 and 10?
10:56:14 <dagano> 6 * 10 * gcd(6,10) ?
10:56:43 <tswett> Uh, whoops, I made a typo. 6 * 10 / gcd(6,10), in fact.
10:56:53 <dagano> that makes a bit more sense then
10:56:54 <dagano> :)
10:57:00 <dagano> 60 / 2
10:57:02 <dagano> right ok
10:57:17 <mr-> (yes, gcd + lcm = m*n)
10:57:27 <c_wraith> *
10:57:32 <tswett> Okay, suppose that x is the least common multiple of 6 and 10. How might you find the least common multiple of 6, 10, and 21?
10:58:32 * dagano thinking
10:59:01 <dagano> lcm (x, 21)?
10:59:18 <c_wraith> correct
10:59:20 <dagano> lcm(lcm(6,10),21)
10:59:54 <tswett> Right. So then to find the least common multiple of all the numbers from 1 through 20, you'd just do the same thing, but with all the numbers from 1 through 20.
11:00:00 <dagano> aaah yes
11:00:29 <dagano> wow
11:00:38 <dagano> my version was stupid wasteful
11:00:59 <c_wraith> Eh, whatever.  learning! :)
11:01:14 <dagano> prelude probably doesn;t have lcm or gcd right?
11:01:16 <tswett> The first step towards doing anything well is doing it badly. :D
11:01:35 <tswett> Looks like it does have them, actually.
11:01:44 <tswett> I didn't check for lcm, but it has gcd.
11:01:47 <c_wraith> it has gcd
11:01:56 <dagano> nice .. be back with my solution
11:02:03 <dagano> thanks for thhe help
11:04:58 <dagano> foldr (lcm) 1 [1..20] 232792560
11:05:56 <shachaf> dagano: It's very confusing when you write the result right next to the expression like that.
11:06:05 <shachaf> Looks like you're applying a number to another number.
11:06:48 <dagano> yep
11:07:03 <dagano> is there a ghci bot here?
11:07:10 <tswett> > 3 + 4
11:07:11 <lambdabot>   7
11:07:23 <dagano> foldr (lcm) 1 [1..20]
11:07:24 <tswett> Not actually GHCi, but close enough.
11:07:34 <tswett> > foldr (lcm) 1 [1..20]
11:07:35 <lambdabot>   232792560
11:07:49 <c_wraith> dagano: technically, foldl' is more correct than foldr there.  But the difference is subtle, and doesn't matter in this case.
11:07:51 <dagano> > 4
11:07:51 <lambdabot>   4
11:08:14 <shachaf> dagano: (You can also /msg lambdabot to experiment.)
11:08:18 <dagano> i know it has to do with associativity ... but i will look into it
11:08:39 <tswett> I don't know about "more correct", but it will work better for large values of 20.
11:08:55 <c_wraith> like 20.999
11:08:56 <hpaste> tswett pasted “Idris isn't building for some reason” at http://lpaste.net/91237
11:08:56 <dagano> what is a large value of 20? lol
11:09:00 * Maior hasn't been following, but giggles hard at lvot
11:09:01 <dagano> ah ok
11:09:26 <tswett> foldl' often works better than foldr for very large lists.
11:09:28 <c_wraith> tswett: I consider it more correct because it's a calculation with an accumulator, not a transformation of a stream
11:09:55 <shachaf> tswett: That's not a good rule of thumb to give. :-(
11:10:29 <shachaf> c_wraith: Hmm, I'd say that foldr is the natural fold for a list.
11:10:40 <shachaf> The "accumulator" business is only for efficiency.
11:11:03 <c_wraith> yes, but efficiency (potentially) matters with that kind of calculation
11:11:10 <shachaf> The whole "replace every : with lcm and [] with 1" idea works fine here. So I wouldn't say it's not correct.
11:11:42 <shachaf> Sure, efficiency (potentially) matters everywhere. But claiming something isn't correct is a big claim. :-)
11:12:26 <c_wraith> I didn't say foldr was incorrect.  I just said foldl' is more correct.  Its operational semantics are a better match for the operation being performed.
11:13:41 <Gracenotes> foldl' numerical fold is best numerical fold
11:14:00 <shachaf> :-(
11:14:05 <shachaf> Oh well. Whatever.
11:14:13 <shachaf> Words, words, words. As they say.
11:27:10 <tswett> shachaf: I did say "often", not "usually".
11:27:45 <joelteon> what indexed monad implementation do you guys generally use? the one from category-extras?
11:28:20 <joelteon> oh, wait, that's old
11:28:20 <edwardk> i have an 'indexed' package on github but i haven't released it yet (it needs fully flushed out polykinds/datakinds for me to ship it)
11:28:33 <edwardk> use the one that tekmo is using for now
11:28:35 <joelteon> ok
11:29:55 <edwardk> the one-parameter indexed version that conor defined and that tekmo uses and my indexed package uses is in many ways more fundamental. it works better in that you can swap in more argument kinds and use it in more situations
11:30:03 <edwardk> even if its a little counter-intuitive at first
11:31:23 <edwardk> it also forces the right choice of direction for things that are otherwise not obvious, and showcases why certain other constraints like having something be both an indexed monad and indexed comonad are generally impossible
11:31:36 <joelteon> ok, question
11:31:51 <joelteon> why does ireturn have :: a -> m i i a
11:31:52 <tswett> So does anyone have any ideas as to why Idris isn't building? http://lpaste.net/91237 It says it can't find gmp.h, and I'm telling it to look in /opt/local/include, and /opt/local/include/gmp.h exists.
11:31:54 <joelteon> instead of just m i a
11:32:04 <joelteon> a -> m i a *
11:32:23 <mr-> tswett: have you sought help in #idris yet?
11:32:31 <tswett> Nope.
11:39:59 * hackagebot apache-md5 0.5.0.0 - Apache server specific MD5 digest algorighm.  http://hackage.haskell.org/package/apache-md5-0.5.0.0 (PeterTrsko)
11:44:36 <klrr> anyone know how to solve these type errors? http://lpaste.net/91238
11:44:51 <klrr> im using Helm and Elerea FRP lib
11:45:18 <tswett> Woohoo, got it to install. I had to set the C_INCLUDE_PATH environment variable, since cabal doesn't pass whatever to whatever.
11:45:51 <tswett> klrr: lemme take a look.
11:45:54 <applicative> tswett: your using  --extra-lib-dirs= and  --extra-include-dirs= etc
11:46:01 <applicative> oh you got
11:46:02 <applicative> it
11:46:02 <klrr> tswett: thanks
11:46:16 <klrr> hi tac
11:46:28 <dwcook> klrr, looks like you're missing an argument somewhere
11:46:36 <klrr> i do?
11:46:41 <tswett> klrr: perhaps you want to say main = bar >>= print?
11:46:56 <klrr> LOL im stupid xD
11:47:07 <applicative> klrr: oh
11:47:18 <applicative> man I'm too slow
11:47:21 <klrr> now i get longer error, just a sec
11:47:47 <applicative> bar will have the type IO (IO something)
11:48:07 <klrr> applicative: that's why im using >>=
11:48:18 <dagano> > :t round 6.5
11:48:19 <lambdabot>   <hint>:1:1: parse error on input `:'
11:48:24 <applicative> klrr: it's looking like youll need it twice, so to say
11:48:28 <tswett> @type round 6.5
11:48:29 <lambdabot> Integral b => b
11:48:35 <dagano> ah thx
11:48:41 <applicative> do {iox <- bar ; x <- iox ; print x}
11:48:51 <klrr> http://lpaste.net/91238
11:48:57 <klrr> now with error message for bar >>= main
11:49:02 <monochrom> join bar >>= print. which is equivalent to twice >>=
11:49:02 <klrr> bar >>= print*
11:49:09 <klrr> thanks
11:49:16 <klrr> which module is it in
11:49:25 <monochrom> Control.Monad.join
11:49:26 <applicative> ah, monochroms solution is simpler
11:49:57 <klrr> hmm i dont have that module
11:50:06 <monochrom> the module name is Control.Mond
11:50:11 <monochrom> err, Control.Monad
11:50:11 <applicative> sure you do
11:50:28 <klrr> now it works kinda
11:50:32 <applicative> klrr: monochrom was giving the 'fully qualified' name of the function, join
11:50:41 <klrr> it doesnt get my mouse position though
11:50:47 <klrr> :t join
11:50:48 <lambdabot> Monad m => m (m a) -> m a
11:50:53 <klrr> ?src join
11:50:53 <lambdabot> join x =  x >>= id
11:51:12 <applicative> what is M.x and what is transfer
11:51:49 <klrr> transfer is some kind of FRP combositor from eleara and M.x gives a singal of mouses' x positin
11:51:49 <applicative> well evidently tranfer a b c yields a SignalGen (Signal a1)
11:52:41 <klrr> hmm
11:53:13 <klrr> FRP is weird
11:53:32 <ion> and onomatopoetic
11:54:00 * applicative likes the idea of an FRP combositor
11:55:36 <chrisdotcode_> chrisdone: on ircbrowse, what determined what quote is picked under the user's nick?
11:56:12 <ion> combo breaker
11:57:00 <shachaf> chrisdotcode_: The RNG.
11:57:22 <chrisdotcode_> shachaf: was thinking that at first, but after a page refresh, it was the same
11:57:38 <shachaf> Yes.
11:57:41 <chrisdotcode_> it must be modulo hours, then
11:57:52 <chrisdotcode_> * is it modulo hours, then?
11:58:00 <shachaf> No.
11:58:12 <chrisdotcode_> so how does it work, then? >_>
11:58:30 <shachaf> Does it matter?
11:58:48 <shachaf> I'm going to go with "it's cached, and only regenerated at most once a day, or something like that".
11:59:06 <chrisdotcode_> not really, no. I was just curious; I guess I'll go to the source now; although it's probably modulo'd by days
11:59:11 <shachaf> I don't remember why I'm going with that.
11:59:23 <shachaf> I don't think "modulo'd" has much of anything to do with it.
11:59:44 <shachaf> Anyway, doesn't matter.
12:00:13 <chrisdotcode_> well when you said RNG first, but didn't refresh the page, I was assuming it was doing some mod... but okay
12:00:16 <chrisdotcode_> thanks :)
12:00:59 <shoret> chrisdotcode_ you can look it up, too: https://github.com/chrisdone/ircbrowse
12:01:33 <chrisdotcode_> yeah, that's where I was heading now
12:03:50 <joelteon> where's the module with GHC's IO implementation
12:03:53 <applicative> chrisdotcode_: https://github.com/chrisdone/ircbrowse/commit/f107abe116a97413bc04645c8b890e685039f781#static/css/ircbrowse.css seems to have the relevant patch for everything
12:04:37 <chrisdotcode_> applicative: thanks for that! :)
12:05:47 <applicative> joelteon: I wonder you mean exactly maybe google "RealWorld" and "deeply magical"
12:05:58 <applicative> @google RealWorld "deeply magical"
12:06:00 <lambdabot> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Monad-ST.html
12:06:00 <lambdabot> Title: Control.Monad.ST
12:06:06 <mietek> http://www.techcast.com/events/bigtechday6/odeon-1130/?q=odeon-1130 -- does anyone have just the slides for this?
12:06:10 <applicative> well there's one thing
12:06:16 <mietek> "
12:06:16 <mietek> ﻿From High-level Haskell to Efficient Low-level Code"
12:06:49 <mietek> Cause browsing the slides on the bottom there is the most annoying thing ever
12:06:52 <applicative> the slides are at the bottom of the page, I notice, but i couldn't grab them, mietek, but ...
12:06:55 <applicative> oh as you say
12:07:12 <applicative> it was pretty irritating
12:07:17 <joelteon> no, I want the IO Monad instance and the docs don't link to it
12:08:04 <chrisdotcode_> > let ☹ = 4
12:08:06 <lambdabot>   <hint>:1:5: parse error on input `☹'
12:08:12 <chrisdotcode_> > let ☹ = 4 in ☹ + ☹
12:08:13 <lambdabot>   <hint>:1:5: parse error on input `☹'
12:08:28 <mietek> applicative: they just stop loading after some point
12:08:42 <chrisdotcode_> > let x = 4 in x + x
12:08:43 <lambdabot>   8
12:08:45 <mietek> And then you have to play the video for a bit, and start again...
12:09:03 <mietek> Unbelievably bas UI
12:09:04 <shachaf> joelteon: I'm tempted to say that if you don't know how to figure it out then you shouldn't be reading it. But I won't say that. Instead I'll say that you can find out where it is with :i in ghci.
12:09:05 <mietek> bad*
12:09:15 <joelteon> ok
12:09:28 <joelteon> shachaf: thanks for not saying what you said
12:10:53 <applicative> hah
12:10:55 <shachaf> joelteon: No problem.
12:11:20 <shachaf> What I mean is that people often get misled by reading GHC's implementation of IO into thinking that things that aren't going on are going on (and vice versa).
12:11:55 <applicative> well, you'd think theyd have to read it in order not to be misled too
12:12:07 <applicative> but there arent 27 possible monad instances for newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:12:16 <applicative> in any case
12:12:23 <shachaf> I don't think you should read the source of that newtype.
12:12:43 <shachaf> I think most good ways of understanding IO (the abstract type), so far as it can be understood, don't involve the hack GHC uses to implement it.
12:12:44 <applicative> joelteon: this is famously a bit of a nightmare
12:13:06 <joelteon> yeah
12:13:35 <applicative> its clear that the author or authors of these modules don't think it's a hack, exactly
12:13:48 <Cale> GHC *could* largely implement IO as a GADT with higher order abstract syntax of IO actions, and the runtime system would then be an interpreter for that abstract syntax.
12:13:57 <scottj> is there a common reason why import Text.JSON would work in ghci but fail with could not find module in ghc?
12:14:01 <chrisdotcode_> joelteon: your name, (in addition to meaning your name) is also referencing jolteon, the pokemon, yes?
12:14:07 <joelteon> chrisdotcode_: yeah
12:14:17 <Cale> But it doesn't, and it's quite possible that just doing that naively would result in much more poorly optimised code.
12:14:53 <shachaf> Cale: Or even as a non-GADT. I think that implementation would be much better pedagogically.
12:15:06 <applicative> scottj: if they are looking at different regristries of packages, but that would be strange.  You weren't inside a directory for the json package were you?
12:15:19 <shachaf> But I don't care that much what implementation GHC uses. IO is an abstract type.
12:15:32 <scottj> applicative: nope
12:15:55 <applicative> and ghc-pkg list json shows it's installed?
12:17:26 <scottj> applicative: didn't know about that command, looks like some of my packages are broken due to missing dependencies
12:18:33 <applicative> scottj hm, are any broken packages in the 'global' database or are they local? ghc-pkg list , in normal circumstances, give two lists from the two pkg registries
12:18:59 <chrisdotcode_> :t unsafeCoerce
12:19:00 <lambdabot> Not in scope: `unsafeCoerce'
12:19:03 <applicative> in any case, if it's all local, it is just a question of ghc-pkg unregister blah for broken values of blah
12:19:29 <applicative> scottj: there are several expedients for doing this
12:20:34 <scottj> applicative: local, and just ghc-pkg list doesn't list json
12:23:07 <applicative> scottj: oh did you get a lot of haskell libraries from your package manager>
12:23:20 <scottj> applicative: probably. cabal install json appears to have fixed it
12:23:28 <applicative> oh ok
12:23:48 <scottj> applicative: thanks for the help
12:24:08 <applicative> scottj: if you haven't you might take a look at  http://www.vex.net/~trebla/haskell/sicp.xhtml
12:27:41 <shoret> scottj aeson is generally way-preferable to json
12:38:54 <klrr> can audio be repreasented as a signal in haskell? with it's time-varying value being the volume or sth?
12:39:15 <jfischoff> sure
12:39:20 <klrr> good
12:39:31 <klrr> i gonna try get sdl-mixer into helm somehow :P
12:39:45 <klrr> but sdl-mixer bindings in haskell got no docs xD
12:39:51 <jfischoff> how is helm by the way?
12:40:18 <klrr> not figured out how to do any cool stuffs yet , but it seems very cool :D
12:40:27 * jfischoff nods
12:41:13 <klrr> you are supposed to do stuff like this https://github.com/evancz/elm-lang.org/blob/master/public/examples/Intermediate/Mario.elm ish
12:41:19 <klrr> which is kinda low loc
12:41:45 <klrr> then, elm might be a bit less verbose and got some other stuff helm and erealea dont but somehow it should be able to do it i think :P
12:42:24 * jfischoff nods
12:42:30 <klrr> jfischoff: nods?
12:43:04 <klrr> what's haskell - "ask"?
12:43:18 <klrr> some C programmer told me to figure it out what it is -.-
12:43:25 <jfischoff> I don't have a response but I read your comment
12:43:31 <jfischoff> ask?
12:43:37 <klrr> i donno what he mean
12:43:44 <jfischoff> from monadreader maybe
12:43:55 <jfischoff> @hoogle ask
12:43:56 <lambdabot> Control.Monad.Trans.RWS.Lazy ask :: (Monoid w, Monad m) => RWST r w s m r
12:43:56 <lambdabot> Control.Monad.Trans.RWS.Strict ask :: (Monoid w, Monad m) => RWST r w s m r
12:43:56 <lambdabot> Control.Monad.Trans.Reader ask :: Monad m => ReaderT r m r
12:44:14 <enthropy> > take 3 . drop 1 $ "Haskell"
12:44:15 <lambdabot>   "ask"
12:44:25 <klrr> enthropy: yup but inverted
12:44:27 <klrr> aka "hell"
12:44:55 <ion> > (\\) <*> (take 3 . drop 1) $ "Haskell"
12:44:56 <lambdabot>   "Hell"
12:45:56 <tac> @type (\\)
12:45:57 <lambdabot> Eq a => [a] -> [a] -> [a]
12:46:06 <klrr> ?src (\\)
12:46:06 <lambdabot> (\\) = foldl (flip delete)
12:46:17 <b2coutts> :t delete
12:46:17 <lambdabot> Eq a => a -> [a] -> [a]
12:46:33 <jfischoff> the magic is in (a ->)'s Applicative instance
12:46:38 <b2coutts> > delete 'k' "k1 and k2"
12:46:39 <lambdabot>   "1 and k2"
12:46:47 <b2coutts> cool
12:47:48 <b2coutts> > delete 'k' "asdf"
12:47:49 <lambdabot>   "asdf"
12:48:20 <klrr> 21:47 <@Samual> I can write an engine in less lines of code than that with any language
12:48:23 <klrr> 21:47 <@Samual> all I have to do is not use any newlines
12:48:26 <klrr> LOL
12:48:57 <roboguy_> > "Haskell" \\ "ask"
12:48:58 <lambdabot>   "Hell"
12:49:01 <applicative> > runReader (do {n <- ask; return (n*2)}) 18
12:49:02 <lambdabot>   36
12:49:22 <ion> > (do { n <- ask; return (n*2) }) 18
12:49:23 <lambdabot>   36
12:52:09 <applicative> > runReader (do {str <- asks show; return (text (str ++ " is my current configuration"))}) 18
12:52:10 <lambdabot>   18 is my current configuration
12:56:59 <applicative> > runReader (do {n <- ask; return $ text ("I was called with " ++ show n) $$ text (" thats why I print " ++ show n ++ " asterisks") $$ text (replicate n '*')}) 18
12:57:00 <lambdabot>   I was called with 18
12:57:00 <lambdabot>   thats why I print 18 asterisks
12:57:00 <lambdabot>  ******************
12:58:11 <tac> > text "Hello" $$ text "World"
12:58:11 <lambdabot>   Hello
12:58:12 <lambdabot>  World
12:58:35 <applicative> there is an obnoxious additional ' ' for the first line
12:58:52 <tac> why is that?
12:59:05 <applicative> just something lambdabot
12:59:11 <tac> I thought the extra space was for preventing bot chain abuse or something like that
12:59:15 <tac> but having two extra doesn't make sense
13:07:59 <ion> I like all the horrible kluges to prevent bot loops when the IRC RFC specifies actual functionality for exactly that.
13:13:55 <Crockeo> > scanl (*) 1 [1 .. 5]
13:13:56 <lambdabot>   [1,1,2,6,24,120]
13:14:03 <chrisdotcode_> :t scanl
13:14:04 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
13:17:07 <platzhirsch> A synonym for preprocessing?
13:20:03 * hackagebot amqp 0.4.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.4.2 (HolgerReinhardt)
13:22:46 <Cale> ion: If you try to implement what the RFC says to implement, you find out that there's a lot of really bad IRC clients out there which handle notices very obnoxiously.
13:23:22 <Cale> e.g. one (I forget which) will even open a separate window to display each notice in its own dialog box
13:23:28 <ion> cale: And it’s just a matter of, like, five mouse clicks to fix the configuration.
13:23:42 <Cale> Well, or change IRC clients.
13:23:48 <ion> It would be nice if at least some of those people also sent a bug report.
13:24:01 <Cale> But if you put a bot like that in a channel with 1000 people, you'll get a lot of whining.
13:24:34 <ion> But nobody seems to do that, they just complain to bot developers/maintainers until they cave in.
13:25:14 <chrisdotcode_> well irssi and quassel are pretty nice, IMO
13:25:28 <ion> IIRC irssi’s default config is also broken wrt. NOTICEs.
13:25:46 <ion> But mIRC users seem to be the noisiest offenders. :-P
13:25:49 <chrisdotcode_> ion: yeah, sadly =/
13:26:03 <chrisdotcode_> but there's some python script to remedy that, iirc
13:26:25 <ion> In Irssi? You don’t need a script, changing a couple of settings is enough.
13:26:33 <parcs> the conventional idiom of 'bracket (forkIO action) killThread $ \_ -> ...' is not ideal because it keeps the thread alive longer than necessary
13:27:38 <jfischoff> go on
13:28:15 <parcs> that's all :P
13:28:52 <JuanDaugherty> am I being harsh or would only an idiot use the expression "Data Scientist" to refer someone other that a statistician or the like?
13:29:21 <jfischoff> parcs: what is a better alternative?
13:29:22 <shachaf> You're being harsh and also offtopic.
13:32:24 <parcs> jfischoff: i don't know. the problem is that when you keep a ThreadId alive you also keep its stack alive which can be up to 8M big
13:32:44 <jfischoff> interesting
13:36:15 <chrisdotcode_> guys, what does unsafeCoerce do?
13:36:59 <shachaf> chrisdotcode_: What's unclear about the documentation?
13:37:40 <chrisdotcode_> shachaf: "The highly unsafe primitive unsafeCoerce converts a value from any type to any other type"
13:37:48 <chrisdotcode_> like Int -> Float, or like Int -> String?
13:37:57 <shachaf> :t Unsafe.Coerce.unsafeCoerce
13:37:58 <lambdabot> a -> b
13:38:17 <joelteon> chrisdotcode_: *any* type to *any other type*
13:38:21 <shachaf> You shouldn't be using it if you don't know what you're doing.
13:38:33 <joelteon> and you generally shouldn't use it, unless you're edwardk
13:38:55 <joelteon> which you're not
13:38:57 <shachaf> Hey! Most of the unsafeCoerces in lens are indirectly my fault!
13:39:05 <dmwit> chrisdotcode_: Yes, like Int -> Float or like Int -> String.
13:39:11 <joelteon> or shachaf I suppose
13:39:19 <chrisdotcode_> joelteon: haha. I was actually reading some quotes from the wiki, and edwardk and shachaf kept talking about unsafeCoerce, and I wanted to know what it did
13:39:30 <joelteon> it does exactly what it sounds like, and what the type signature implies
13:39:35 <chrisdotcode_> * quotes from ircbrowse
13:40:10 <edwardk> chrisdotcode_: we use it down in the bowels of lens in terribly evil ways to eke out a bit of performance that 99% of haskell users should never have to care about
13:40:33 <shachaf> edwardk: I'm hoping that 7.8 will make it unnecessary.
13:40:38 <shachaf> (Not sure, though.)
13:40:45 <shachaf> I mean the .# business.
13:41:00 <joelteon> speaking of terribly evil ways, I just finished my indexed IO monad
13:41:01 <edwardk> using it requires you to understand how everything is represented on a low level inside of GHC, and then it basically is you lying to the type system and saying 'trust me'
13:41:02 <dmwit> S unsafeCoerce(T i) { return *(S*)(&i); }
13:41:09 <edwardk> if you get it wrong everything segfaults and blows up spectacularly
13:41:21 <joelteon> simple solution: don't get it wrong
13:41:24 <chrisdotcode_> edwardk: so meta-black magic, then?
13:41:34 <chrisdotcode_> s/-//
13:41:42 <dmwit> It is the opposite of magic. It is id with a funny type.
13:41:43 <Cale> ghci> (unsafeCoerce ((*2) :: Int -> Int) :: Float -> Float) 1
13:41:44 <Cale> 1.7014118e38
13:41:44 <edwardk> chrisdotcode_: yeah. its basically telling GHC that you know better than it does.
13:41:49 <edwardk> unsafeCoerce :: a -> b
13:41:51 <shachaf> dmwit: Maybe more like S *unsafeCoerce(T *i) { return (S*)i; }
13:41:51 <Cale> WHEEE
13:41:54 <Gheyboy_Advance> I am gay
13:41:55 <Gheyboy_Advance> Gay
13:41:56 <Gheyboy_Advance> gay
13:41:58 <Gheyboy_Advance> Is me
13:42:00 <Gheyboy_Advance> I am pretty gay
13:42:01 --- mode: ChanServ set +o Cale
13:42:02 <Gheyboy_Advance> Very gay
13:42:03 <dmwit> ?where ops
13:42:03 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
13:42:03 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:42:04 <Gheyboy_Advance> A gay is me
13:42:04 --- mode: Cale set +b *!*@c-24-10-24-153.hsd1.ca.comcast.net
13:42:04 --- kick: Gheyboy_Advance was kicked by Cale (Gheyboy_Advance)
13:42:06 --- mode: ChanServ set +o edwardk
13:42:17 <jonsterling> *sigh*
13:42:19 <chrisdotcode_> <_<
13:42:26 <joelteon> anyway, so now that i'm done with this thing, i want some help to make it better
13:42:40 <chrisdotcode_> shachaf: so how will 7.8 make them unecessary?
13:42:43 <Cale> ghci> (unsafeCoerce ((*2) :: Int -> Int) :: IO Float)
13:42:44 <Cale> Segmentation fault
13:42:46 <joelteon> for whoever is inclined
13:42:56 <joelteon> what happened to hpaste?
13:42:59 <joelteon> or is it on my end again
13:43:00 <dmwit> ?where hpaste
13:43:00 <lambdabot> http://lpaste.net/new/haskell
13:43:05 <joelteon> of course
13:43:15 <shachaf> chrisdotcode_: Some bug or another that I filed a while ago. strict composition with id or something.
13:43:22 <joelteon> oh hey, and that url is now blocked here
13:43:32 <joelteon> gist time
13:43:38 <Cale> joelteon: blocked?
13:43:42 <joelteon> yeah, at work
13:43:48 <chrisdotcode_> huh, that's interesting.
13:44:01 <Cale> Why would a paste site be blocked?
13:44:08 <joelteon> that's what I'm about to ask support
13:45:09 <yosemite_newbie> I have a question, i'm created a class for an infinite stream, but i don't know how to create an instance of an infinite data type
13:45:36 <jonsterling> yosemite_newbie: Can you elaborate a bit?
13:45:45 <yosemite_newbie> code is on http://pastebin.com/rRwTZphx
13:45:49 <mauke> The paste rRwTZphx has been copied to http://lpaste.net/91246
13:46:25 <yosemite_newbie> the data type is defined as --- data Stream a = Stream a (Stream a)
13:46:34 <dmwit> yosemite_newbie: Use recursion, as you did in the other infinite values in that file.
13:46:36 <yosemite_newbie> something followed by a stream of seomthing
13:46:38 <jonsterling> yosemite_newbie: Ah, you'll want to use recursion. streamRepeat a = Stream a (streamRepeat a)
13:46:40 <shachaf> [05:10] edwardk: if you want to bang out an appropriately typed unsafeCoerce I might be able to convince myself to switch ;)
13:46:46 <shachaf> From https://github.com/ekmett/lens/issues/75
13:46:49 <shachaf> Good old days.
13:47:07 <joelteon> https://gist.github.com/joelteon/bc3fc48e9ebc55b12463
13:47:22 <joelteon> in the ibind definition, I'm basically doing unsafePerformIO
13:47:24 <yosemite_newbie> ah
13:47:32 <yosemite_newbie> Stream a (streamRepeat a)
13:47:35 <yosemite_newbie> Thanks dmwit
13:47:39 <joelteon> but I couldn't think of an alternative solution :(
13:47:53 <edwardk> shachaf: then you led me down the road to perdition
13:48:17 <yosemite_newbie> streamRepeat a = Stream a (streamRepeat a)
13:48:42 <shachaf> edwardk: I think the phrase is "following you in front of you".
13:49:08 <edwardk> well, yes, you did lead me down the road because i was holding you at gunpoint, but still
13:50:33 <chrisdotcode_> "edwardk: this breaks my previous record of 6 unsafeCoerce's in a line"
13:51:02 <edwardk> worse that package with the 6 is actually unsafe ;)
13:51:12 <chrisdotcode_> edwardk: what package? >_>
13:52:38 <edwardk> it was in a version of stablemaps iirc
13:52:47 <edwardk> and stablemaps is unsound because of GADTs
13:53:08 <edwardk> so you can use it to turn an illegal Functor into an unsafeCoerce
13:54:21 <bscarlet> edwardk: could you elaborate that?
13:55:21 <edwardk> bscarlet: i prefer to leave it as an exercise for the reader. but you can make stablemaps give unsafeCoerce for you if you use a GADT for the 'f' argument for the map
13:56:17 <edwardk> [] :: [a], so a stable entry for it will be instantiable at many types, this is fine because [] is parametric in its argument, but you can get some rather interesting failures when your GADT isn't
13:57:57 <lunchtime> seems interesting!
14:00:01 <edwardk> in practice i left the module as unsafe because it is still useful when you know the wrapper type you are using is a legal Functor and/or doesn't do anything hinky ;)
14:00:17 <edwardk> but its not something you can safely expose to SafeHaskell
14:08:37 <JuanDaugherty> shachaf, harsh off topic and mistaken, the job descriptions were mostly data analysis oriented
14:10:04 * hackagebot reform-hamlet 0.0 - Add support for using Hamlet with Reform  http://hackage.haskell.org/package/reform-hamlet-0.0 (JeremyShaw)
14:12:46 <hpc> :(
14:12:51 <hpc> hackage has hamlet, but not yorrick
14:13:18 <hpc> or even horatio
14:15:12 <joelteon> alas, poor yorrick
14:18:36 <tswett> Ahoy. I don't suppose there's a library for Haskell that performs type checking?
14:19:01 <tswett> HM type inference, to be specific.
14:19:08 <shachaf> Does ghc count?
14:19:24 <shachaf> You can certainly find Haskell code around that does type checking for many different kinds of type systems.
14:19:58 <eyebloom> Why would this cause a parse error on the second line of the let expression: http://pastebin.com/uRQjbQ1t
14:20:04 <tswett> I'm pretty sure my type system is just STLC.
14:20:04 <mauke> The paste uRQjbQ1t has been copied to http://lpaste.net/91248
14:21:30 <monochrom> eyebloom: I don't even think that λ can be used this way
14:22:02 <eyebloom> Oh sorry that's just sugar from Leksah
14:22:22 <eyebloom> Er.. candy I mean
14:23:12 <hpaste> eyebloom pasted “Parse Error” at http://lpaste.net/91249
14:23:23 <eyebloom> Here it is decandied.
14:23:44 <tswett> It looks like "in" isn't at the correct level of indentation.
14:23:55 <tswett> It should be two spaces to the right. I'm not sure, though.
14:24:15 <monochrom> then it's misalignment. "xy =" and "(P g1 uw) =" must be aligned. "(" under "x".
14:24:26 <monochrom> "in"'s position is fine
14:24:49 <eyebloom> Ok I see, the error was coming from the Candifier in Leksah.
14:24:57 <eyebloom> Thanks for bearing with me.
14:26:22 <eyebloom> It does look pretty though doesn't it.
14:30:04 * hackagebot web-routes-wai 0.22.3 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.22.3 (JeremyShaw)
14:32:53 <yyyyy> quick question: can you get type information 'reasonably fast' from emacs' haskell-mode autocompletion list? i have been using sublimehaskell for this reason alone, but everything else i do is on emacs, and i miss the 'one editor for your entire life needs' that comes with it :)
14:33:15 <yyyyy> (i am using ghc-select
14:33:37 <yyyyy> completion-symbol for this purpose. wrong RET, sorry)
14:37:37 <yyyyy> e.g. when typing 'i', 'id :: a -> a' would appear on the autocomplete listing
14:44:20 <zzing> Is there a way to build ghc with gcc 4.8 explicitly, and ensure afterwards that everything is built with 4.8?
14:44:28 <zzing> (i.e. stuff I install with cabal)
14:44:36 <zzing> I am on a mac with clang
14:45:20 <hvr> yyyyy: you might want to keep an eye on https://github.com/haskell/haskell-mode/issues/178
14:50:50 <dunkel> hey
14:52:21 <dunkel> can someone explain a typeerror im getting with this: http://pastebin.com/DJeHRrHs ?
14:52:26 <mauke> The paste DJeHRrHs has been copied to http://lpaste.net/91250
14:54:19 <mauke> dunkel: what's the type of eliminateJust supposed to be?
14:54:45 <dunkel> anything kinda xD jsut wanted to kick that just
14:54:57 <mauke> that makes no sense
14:55:01 <dunkel> because i need to get back a tuple (p, h)
14:55:15 <dunkel> oh no w8
14:55:34 <dunkel> Maybe (e, Heap p e)
14:55:55 <dunkel> so i want the expression found in the map and the map nback as a tuple
14:56:04 <shachaf> dunkel: I recommend answering mauke's question.
14:56:11 <dunkel> but lookup gives me a maybe
14:56:49 <dunkel> mh probably the expression i get from the map?
14:56:52 <dunkel> so e in this case?
14:57:24 <shachaf> The type of eliminateJust is e?
14:57:56 <dunkel> ah xD
14:57:56 <Cale> dunkel: The inferred type of eliminateJust would be Maybe (Maybe a) -> Maybe a
14:57:59 <dunkel> i get it
14:58:33 <mauke> * dunkel is now known as helle
14:58:33 <jbetzend> My GHCI gives me "eliminateJust :: Maybe t -> Maybe a"
14:58:48 <mauke> jbetzend: you only used the last line
14:58:52 <nabilhassein> is there a design reason that typeclass imports are anonymous?
14:59:14 <nabilhassein> my google-fu can only find information about how import Foo () operates, not why it operates this way in the first place
14:59:45 <dunkel> ;)
15:00:05 <dunkel> is there a more elegeant way to get this value out of the Just ?
15:00:36 <ciaranm> you don't want to get the value out of the Maybe. you want to lift up all your functions so they're inside the Maybe.
15:00:37 <quchen> jbetzend: I think there's an error in what you typed in GHCi then.
15:00:40 <quchen> :t let foo (Just x) = x; foo Nothing = Nothing in foo
15:00:41 <lambdabot> Maybe (Maybe a) -> Maybe a
15:00:50 <ciaranm> :t join
15:00:50 <lambdabot> Monad m => m (m a) -> m a
15:01:11 <Saizan> nabilhassein: you mean instances? it's for confluence of instance resolution
15:01:13 <Cale> dunkel: lookupHeap key h = do v <- Map.lookup key h; return (v,h)
15:01:30 <zzing> Can anyone confirm that the april 2013 developer tools on the mac is compatible with ghc?
15:01:39 <Cale> dunkel: That'd be using the fact that Maybe is a monad.
15:01:52 <`Jake`> if I have    do { a <- f x; b <- g x; ... }   can I combine those two things into one line?
15:01:57 <`Jake`> wait
15:01:58 <`Jake`> wring
15:02:01 <`Jake`> wrong*
15:02:15 <`Jake`> do { a <- f x; b <- g a; ... }
15:02:30 <dunkel> ok thanks i will look that up ;)
15:02:34 <mauke> that is one line
15:02:47 <mauke> :t (<=<)
15:02:48 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:02:50 <`Jake`> yeah, I mean without the semicolons and curly braces
15:02:52 <quchen> Depends on what (...) is.
15:02:56 <`Jake`> thanks
15:02:57 <Cale> If a is unused, then b <- g =<< f x
15:03:08 <`Jake`> ok
15:03:19 <quchen> mapM looks like what you've written, `Jake`.
15:03:22 <nabilhassein> Saizan: yes, that's what i mean
15:03:27 <quchen> Eh, the first one.
15:03:29 <`Jake`> @type mapM
15:03:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:03:32 <nabilhassein> what do you mean by confluence of instance resolution?
15:03:50 <yyyyy> hvm: thanks. you might want to look into how sublimehaskell does it. it seems to build a database out of your cabal modules (globally, not in the project) and provide the types there as information. it takes quite some time to do it when starting up, but the payoff is worth it (IMHO)
15:03:57 <k00mi> nabilhassein: see first answer: http://stackoverflow.com/questions/8728596/explicitly-import-instances
15:05:13 <yyyyy> hvr: see above :)
15:05:30 <nabilhassein> k00mi: very interesting. thank you!
15:05:31 <Saizan> nabilhassein: essentially the guarantee that you'll always get the same instance for the same type across your whole program
15:08:27 <nabilhassein> Saizan: yes, that makes sense now. It does make sense, but it is also annoying sometimes. Thanks for the explanation!
15:09:46 <hvr> yyyyy: does sublime also take into account the current import statements in scope?
15:10:27 <hvr> yyyyy: i.e. does it offer only the symbols that are currently visible?
15:11:00 <wavewave_> hi
15:12:52 <yyyyy> hvr: yes. i think it checks dynamically. i haven't yet looked into detail, but seems to be defined here: https://github.com/SublimeHaskell/SublimeHaskell/blob/master/symbols.py . there's some other apparently related preparations at CabalInspector.hs in the same part of the tree.
15:14:18 <k00mi> is there some way to make fields optional in derived Aeson instances?
15:14:41 <k00mi> e.g. my type has a Maybe field, so the json doesn't require that field
15:19:12 <hvr> yyyyy: judging from the code, sublime haskell has some interesting features
15:23:12 <yyyyy> hvr: it is. its two main drawbacks are being non-free and not being emacs :) . i've uploaded an example of how it shows up here: http://imgur.com/ebXmJxy
15:24:18 <hpc> yyyyy: you misspelled vim ;)
15:24:23 <hvr> lol
15:24:43 <yyyyy> hvr: in this example i have Database.HDBC.Sqlite3 (connectSqlite3), System.Environment (getArgs), Database.HDBC and Data.Text (split) imported.
15:25:02 <hpc> that does look quite nice, though
15:25:05 <yyyyy> hpc: i take pity on your penance, brother.
15:25:13 <yyyyy> hpc: :)
15:25:51 <hvr> yyyyy: and completion does properly handle 'qualified ... as' imports?
15:26:03 <hpc> yyyyy: eh, my main issue with emacs is that it somehow takes 30 seconds to start up on my laptop
15:26:08 <hpc> even in no-gui mode
15:26:16 <yyyyy> hvr: ah! i haven't tried that! let me check.
15:26:48 <hvr> hpc: even with 'emacs -Q' ?
15:26:52 <yyyyy> hpc: start it up in daemon mode upon boot and client into it afterwards. instant joy.
15:28:17 <geekosaur> you can make it a lot faster by turning off desktop mode (that is, reloading every file it's ever seen on startup)
15:28:31 <geekosaur> I exaggerate but only slightly
15:29:02 <yyyyy> hvr: it does take that into account. look at http://imgur.com/0OCd9Ix.
15:30:11 <yyyyy> hvr: i do have to go now, but i'm pretty sure that the author of that plugin lurks here or in the mailing lists. his code seems like a good bet to implement something similar in elisp, maybe even using the JSON-backed CabalInspector.hs as loader as well.
15:30:38 <hvr> I'm not against it, but it'd be yet another way to do the same thing
15:30:43 <yyyyy> hvr: in any case, thanks for the update and the issue link.
15:31:04 <hvr> (and we already have the problem with haskell-mode, that there's feature-overlapping facilities)
15:32:30 <yyyyy> well, i'll have my hopes high :). cheers, bye.
15:37:01 <yosemite_newbie> back with another question...
15:37:04 <yosemite_newbie> given the data type --- data Stream a =  Stream a (Stream)
15:37:23 <yosemite_newbie> what is this --- nats :: Stream Integer
15:37:39 <hvr> shouldn't that be "data Stream a =  Stream a (Stream a)"?
15:37:47 <yosemite_newbie> i mean, nats is not a function, correct? or is it?
15:37:56 <hvr> nats is a value
15:38:17 <yosemite_newbie> yes, you are right
15:38:20 <hvr> c.f. with "nats :: [Integer]"
15:38:24 <yosemite_newbie> data Stream a = Stream a (Stream a)
15:38:48 <Gracenotes> "And my Haskell fan-friends ask why didn't I just start with Haskell? And I tell them if I had known seven years ago what I know now I would have started with Haskell, and pushed it a tenth of the way toward Fortran, instead of starting with Fortran and pushing it nine-tenths of the way toward Haskell." -- http://www.infoq.com/presentations/Thinking-Parallel-Programming
15:39:10 <yosemite_newbie> what is nats?
15:39:14 <Gracenotes> oh, and the punchline, "But this is where we've ended up and that's why it's research"
15:41:38 <elliott> Gracenotes: fortress?
15:41:44 <Gracenotes> yes
15:41:59 <dmj> something in WHNF is still technically a thunk correct?
15:42:14 <Gracenotes> "In July 2012, it was announced that active development on Fortress would cease after a brief winding-down period, citing complications with using Fortress's type system on existing virtual machines."
15:42:18 <Gracenotes> hm
15:42:22 <hpc> dmj: no
15:42:27 <hpc> but it may contain thunks
15:42:35 <Gracenotes> that's quite a reason to stop
15:43:14 <hpc> for instance, if you seq a list, you end up with [] (an evaluated constructor), or (thunk:thunk) (also an evaluated constructor)
15:46:26 <dmj> hpc: if we take the factorial example, seq stops build up of excess thunkage, but seq evaluates to WHNF. Which stops at the outermost constructor, head. So head here is not a thunk?
15:49:06 <Gracenotes> a thunk is something that will hopefully evaluate to a constructor eventually.
15:49:43 <Gracenotes> it might take some work, though.
15:50:23 <Gracenotes> well
15:50:25 <Gracenotes> @wiki Thunk
15:50:25 <lambdabot> http://www.haskell.org/haskellwiki/Thunk
15:50:33 <dmj> Gracenotes: I'm just trying to understand how seq stops build up of thunks
15:50:49 <dmj> Gracenotes: In this image, it looks as if WHNF always contains thunks. http://commons.wikimedia.org/wiki/File:Thunk-layers.png
15:51:12 <monochrom> not always. sometimes.
15:53:29 <Gracenotes> WHNF is defined in terms of reduction of expressions, and Haskell can be thought of that way (although sharing makes that a bit more complicated)
15:54:34 <dmj> http://lpaste.net/91251
15:55:18 <Gracenotes> imagine the Haskell runtime as a ravenous monster that loves constructors. It is always finding where you use them in code and consuming them.
15:55:56 <Gracenotes> everything it does is based on finding constructors. All it wants to do to the expression 4*3 + 2^4 is get to a single Int constructor before it'll be happy
15:56:00 <Gracenotes> and find other victims
15:56:08 <dmj> Gracenotes: My understanding, from the lpaste above. In this example, every recursive call in factorial creates a new thunk since data is immutable, but seq should stop this by forcing evaluation (opening up a thunk), but WHNF still contains thunks... So who is winning?
15:56:59 <dmj> Gracenotes: ravenous monster :) does seq trigger GC ?
15:57:00 <jmcarthur_mobile> WHNF *may* contain thunks, but does not necessarily
15:57:19 <Gracenotes> However, it's not always great at choosing a good ordering for which constructor to find. So in foldl, it'll ravenously consume (:) constructors until it gets to a [], then get all of the Int constructors, whereas in actuality it should probably alternate (:), Int, (:), Int, etc.
15:57:42 <dmj> jmcarthur_mobile: In the above example can you tell if it will contain thunks? or is my best bet compiling and looking at the heap profile?
15:59:03 <dmj> Gracenotes: From the tutorials I've looked at, it seems the progression is naive foldl (no accumulator), foldl (with accumulator), then foldl' (with seq).
15:59:36 <jmcarthur_mobile> That example looks okay to me. The accumulator will be evaluated as you go.
15:59:39 <Gracenotes> with foldl instead of foldl', it puts off the work of evaluating the integer multiplications and whatnot until it's done going through the list's spine. Well, with the list despined, all of the to-do work must go *somewhere*. So it goes on the heap. All of it.
15:59:45 <Gracenotes> dmj: foldl without accumulator?
16:00:00 <jmcarthur_mobile> dmj: I'm not sure what foldl without an accumulator would look like
16:02:13 <Gracenotes> one interesting thing about this is that (n-1) might be a thunk until n>1 is evaluated in the recursive call
16:02:25 <Gracenotes> hopefully the strictness analyzer outsmarts that
16:06:58 <Gracenotes> (it is not at all worth worrying about)
16:07:27 <Gracenotes> saying that something is in WHNF is just a guarantee that running a case statement on it will do no work, basically
16:08:13 <Gracenotes> (or a seq.) This definition is a bit low-level to be useful.
16:08:16 <dmj> Gracenotes: http://lpaste.net/91252, here is what I think is a non accum version of foldl
16:09:07 <zzing> With goa, what do I set setLambdabotHome to in .ghci on the mac? The wiki says .cabal/bin  but that does not exist.
16:09:08 <Gracenotes> dmj: that's foldr
16:09:27 <dmj> Gracenotes: ah
16:09:46 <dmj> foldr f y (x:xs) = f x (foldr f y xs)
16:10:11 <geekosaur> zzing, Library/Haskell/bin
16:10:22 <hpc> Gracenotes: a more semantic definition might be that a statement in whnf is not bottom
16:10:40 <hpc> or, one that's statically guaranteed to not be bottom
16:10:42 <hpc> or something like that
16:11:16 <dcoutts_> hpc: there's already a perfectly reasonable formal definition of NF and WHNF
16:11:20 <zzing> I always get *** Exception: : changeWorkingDirectory: does not exist (No such file or directory)   when I try to do a :src foldr
16:11:43 <dmj> Gracenotes: Thanks for clearing that up for me. I'll read the thunk wiki, and go reimplement foldl :)
16:12:11 <Gracenotes> something about outer innermost redexen
16:12:37 <Gracenotes> right-leftmost innermost outer?
16:12:43 <zzing> geekosaur, do you know what is supposed to be in the directory?
16:12:48 <dcoutts_> Gracenotes: something like that :-)
16:12:56 <dcoutts_> but yes, all about reductions
16:13:40 <Gracenotes> <Gracenotes> WHNF is defined in terms of reduction of expressions, and Haskell can be thought of that way (although sharing makes that a bit more complicated)
16:13:51 <Gracenotes> then something about runtime monsters.
16:14:04 <geekosaur> zzing, it's the binary directory exactly equivalent to ~/.cabal/bin on linux; it contains all cabal-installed binaries (such as lambdabot)
16:14:12 <geekosaur> as opposed to libraries
16:14:22 <zzing> geekosaur, that directory has no cabal installed binaries
16:14:46 <geekosaur> hm
16:15:08 <geekosaur> but you also have no ~/.cabal/bin?
16:15:14 <zzing> no
16:15:23 <zzing> found it
16:15:28 <zzing> ~/
16:15:56 <geekosaur> that seems wrong
16:16:12 <zzing> Its ~/Library/Haskell/bin
16:16:15 <zzing> Now I get Plugin `source' failed with: state not initialized
16:16:24 <geekosaur> oh, so it doesn't like relative paths
16:16:47 <geekosaur> and that one means you need a State directory, which I thought was part of the lambdabot package at one point
16:16:55 <geekosaur> although it may be named differently
16:17:03 <zzing> How do I find where it should be
16:17:40 <geekosaur> it's been like 3 years since I worked with lambdabot, not sure what has changed
16:21:19 <zzing> Apparently 'goodfellow' had the same problem on june 5th
16:22:18 <zzing> I have the source for what is throwing the error, just not sure why: http://code.haskell.org/lambdabot/Plugin/Source.hs
16:24:32 <geekosaur> so in whatever directory has online.rc (if it's still called that) there is normally a subdirectory named State with various files and subdirectories
16:24:50 <geekosaur> a lambdabot install may ship such a subdir but named State-example or something similar
16:25:33 <zzing>  /Library/Haskell/ghc-7.6.3/lib/lambdabot-4.3/share/scripts/online.rc
16:25:54 <geekosaur> oh, that looks reorganized...
16:26:11 <geekosaur> may be a subdir of lambdabot-4.3 or lambdabot-4.3/share
16:26:43 <geekosaur> http://code.haskell.org/lambdabot/State/ is the distribution one
16:27:15 <zzing> There exists  ~/Library/Haskell/ghc-7.6.3/lib/lambdabot-4.3/share/State
16:27:40 <geekosaur> ok, that should have a file named "source" in it which is similar to http://code.haskell.org/lambdabot/State/source
16:27:49 <zzing> It does
16:28:23 <geekosaur> so, it's there but we need some way to point lambdabot to it. unfortunately I don't know anything about how goa is set up :/
16:31:17 <zzing> I just took some stuff from goa for .ghci config
16:31:23 <zzing> does not work though
16:31:25 <zzing> Somethings do
16:31:29 <zzing> :bs for instance
16:32:07 <zzing> @bs
16:32:07 <lambdabot>  Done.
16:32:18 <zzing> Does that actually do anything?
16:36:07 <lispy> zzing: bs is getting autocorrected to bf
16:36:14 <lispy> @bf +++>--+++
16:36:14 <lambdabot>  Done.
16:36:26 <lispy> Anyway, the point is that it's trying to run a brainfuck program
16:36:34 <lispy> (but I/O is disabled)
16:36:40 <lispy> or at least I is
16:38:05 <zzing> ok, now I need to figure out how to get src to work
16:47:33 <MPS> Hi
