00:00:02 <ezyang_> "Dependent types are considered an essential component of modern, expressive type systems."
00:00:08 <edwardk> =)
00:00:28 <ezyang_> "However, giving up dependence can result in certain benefits for other parts of program construction, and in this article, we'd like to talk about a few of these features."
00:00:34 <edwardk> you're a couple of months too late for an April 1st post ;)
00:00:40 <ezyang_> *siiigh*
00:00:56 <startling> shachaf: it's true.
01:06:27 * hackagebot adict 0.4.1 - Approximate dictionary searching  http://hackage.haskell.org/package/adict-0.4.1 (JakubWaszczuk)
01:23:22 <epta> Is there a way to recognize tab and non-space?
01:24:04 <Kinnison> In what sense?
01:26:08 <epta> such f, that returns True for '\t' and False for '\n'
01:26:17 <epta> such f, that returns True for '\t' and False for ' '*
01:33:04 <Taneb> > '\t' == '\t'
01:33:05 <lambdabot>   True
01:33:10 <Taneb> > '\t' == '\n'
01:33:11 <lambdabot>   False
01:33:14 <Taneb> > '\t' == ' '
01:33:15 <lambdabot>   False
01:33:18 <Taneb> > '\t' == 'q'
01:33:19 <lambdabot>   False
01:33:23 <Taneb> epta, yes
01:33:26 <t7> > let f = (== '\t ') in (f '\t', f '3')
01:33:27 <lambdabot>   <hint>:1:16:
01:33:27 <lambdabot>      lexical error in string/character literal at character ' '
01:33:36 <t7> > let f = (== '\t') in (f '\t', f '3')
01:33:37 <lambdabot>   (True,False)
01:34:28 <simukis_> f ch =  (not isSpace ch) || ch == '\t'
01:34:33 <simukis_> something like that?
02:07:10 <John____> New user question: I've found a library I would like to use. I used cabal to build and install my package (succeeded) but when I want to import it, it says <no location info>: Could not find module `GeomAlgLib': Use -v to see a list of the files searched for. It's probably something silly on my side, but what prevents me from importing this package?
02:11:43 <jkoppel> @john___: If you are using Cabal, you'll need to add it to the build-depends section. If you are using ghc/runhaskell directly, you'll need to use the use-pkg argument
02:11:43 <lambdabot> Unknown command, try @list
02:16:28 <epta>     :old_account => old_account,
02:16:30 <epta>     :old_account => old_account,
02:16:31 <epta>     :old_account => old_account,
02:16:47 <epta>     :old_account => old_account,
02:17:07 <epta> sorry :[
02:19:46 <John____> @jkoppel: Where can I find the build-depends of cabal?
02:19:47 <lambdabot> Unknown command, try @list
02:20:43 <jkoppel> john___: Here's an example .cabal file : https://github.com/ekmett/mtl/blob/master/mtl.cabal
02:20:48 <jkoppel> Note the build-depends section
02:22:45 <John____> jkoppel: In the .cabal file of the library I'm interested in, it says :"Build-Depends:    base, haskell98, array"
02:23:15 <jkoppel> john___: No. If you are using cabal to build *your own* program, then you will need to specify all dependencies in the .cabal file
02:23:48 <jkoppel> If you are using ghc/run-haskell directly, you will need to specify external dependencies using the use-pkg argument
02:24:37 <jkoppel> I'm not sure it's called "use-pkg"; something like that
02:24:49 <jkoppel> I always use Cabal, so I never need it
02:27:11 <John____> jkoppel: I'm not yet looking to package my own code. I simply want to use the library in my .hs files
02:27:13 <abc22134> @pl \a d = a + (4*) d
02:27:13 <lambdabot> (line 1, column 6):
02:27:13 <lambdabot> unexpected "="
02:27:13 <lambdabot> expecting pattern or "->"
02:27:22 <abc22134> @pl \a d -> a + (4*) d
02:27:25 <lambdabot> flip ((.) . (+)) (4 *)
02:27:25 <lambdabot> optimization suspended, use @pl-resume to continue.
02:27:36 <abc22134> @pl-resume
02:27:42 <lambdabot> flip ((.) . (+)) (4 *)
02:27:42 <lambdabot> optimization suspended, use @pl-resume to continue.
02:27:44 <jkoppel> john___: Then use the use-pkg argument or whatever it's called
02:27:59 <jkoppel> Though you don't need to package your own code to use Cabal as a build system
02:28:02 <abc22134> @pl-resume
02:28:02 <John____> thanks... I'll go dive into the manuals
02:28:14 <lambdabot> flip ((.) . (+)) (4 *)
02:28:14 <lambdabot> optimization suspended, use @pl-resume to continue.
02:28:19 <jkoppel> john___: :)
02:28:52 <abc22134> @pl-resume
02:29:07 <lambdabot> Plugin `pl' failed with: <<timeout>>
02:30:32 <abc22134> @pl \k a d -> a + k*d
02:30:35 <lambdabot> flip ((.) . (+)) . (*)
02:30:35 <lambdabot> optimization suspended, use @pl-resume to continue.
02:31:31 <blueonyx> hey, doesnt ghci use readline? can i make it read my .inputrc like bash?
02:31:51 <supki> no, it doesn't
02:31:58 <supki> it uses haskeline
02:32:25 <blueonyx> ok, but C-r works, how can i bind it to arrow up?
02:32:45 <supki> oh, no idea :(
02:36:13 <merijn> What's the recommended way to write magic byte sequences in code? "pack [255,0,255]" type things?
02:38:50 <blueonyx> :t pack
02:38:51 <lambdabot>     Not in scope: `pack'
02:38:51 <lambdabot>     Perhaps you meant one of these:
02:38:51 <lambdabot>       `BS.pack' (imported from Data.ByteString),
02:39:14 <blueonyx> > putStrLn "\200\0\255"
02:39:15 <lambdabot>   <IO ()>
02:39:26 <blueonyx> > "\255\0\255"
02:39:28 <lambdabot>   "\255\NUL\255"
02:48:47 <hape02> There is a haskell binding for 0mq (zeromq) that means if haskell wanna talk to python and vice versa, I could do this via 0mq instead of REST Services... what do You think?  http://www.zeromq.org/bindings:haskell
02:50:20 <merijn> hape02: You can use lots of other ways to, unix sockets, TCP, UDP, etc.
02:50:56 <hape02> yes
02:51:03 <deggis> if a msg queue is what suits your needs then i think that would work well
02:51:14 <merijn> hape02: 0mq is nice, but the current bindings aren't very convenient to use from haskell, because the C library's sockets aren't threadsafe.
02:51:35 <hape02> that is interesting
02:51:41 <merijn> (Which, incidentally, is why I'm working on a native haskell implementation of 0mq)
02:51:41 <hape02> didn't know this
02:52:18 <hape02> merijn: your work hasn't been published yet?
02:52:22 <deggis> (oh, nice to know indeed)
02:54:32 <HugoDaniel> hape02: i would use protocol buffers
02:55:03 <hape02> HugoDaniel: I'll have a look on these
02:58:47 <merijn> hape02: No, I only just started
02:59:03 <merijn> hape02: And I'm focussing on ZMTP3.0 which isn't even fully implemented in libzmq yet
02:59:21 <merijn> HugoDaniel: How do protocol buffers help, they're completely unrelated
02:59:27 <HugoDaniel> zmq has some serious design problems :(
02:59:46 <merijn> protocol buffers are a serialisation format, not a communication protocol
02:59:46 <HugoDaniel> they are not safe
02:59:58 <merijn> HugoDaniel: What do you mean not safe?
03:00:11 <HugoDaniel> merijn: exactly, protobuffers are perfect to pass datatypes between two languages, either that or go the ffi way
03:00:21 <merijn> HugoDaniel: ...
03:00:37 <HugoDaniel> zmq is not safe to be used on the open
03:00:39 <merijn> HugoDaniel: He was asking for a way to communicate, not a way to serialise data
03:00:47 <merijn> It's a completely orthogonal problem
03:01:21 <merijn> HugoDaniel: I know, I've been vocal about this on the mailing list, ZMTP3.0 (the new protocol version, still in development) supports multiple authentication mechanisms and control
03:01:33 <HugoDaniel> and encryption ?
03:01:36 <merijn> Yes
03:01:59 <merijn> I believe ZMTP3.0 plus the CurveZMQ authentication mechanism will make ZMQ safe to be used on the internet
03:02:14 <HugoDaniel> allright, thats cool
03:02:16 <merijn> HugoDaniel: http://curvezmq.org/page:read-the-docs
03:02:30 <HugoDaniel> thats very good
03:02:32 <merijn> HugoDaniel: Hence, another reason why I'm working on an implementation of ZMTP3.0
03:02:37 <HugoDaniel> yes
03:02:52 <HugoDaniel> can it work with tun or ice ?
03:03:28 <merijn> I dunno what either of those are?
03:03:58 <HugoDaniel> stun and ice are two ways to do nat traversal
03:04:24 <shiona> how do I get stuff out of records? Like subForest out of "Node {rootLabel = 875709, subForest = []}"
03:04:40 <merijn> shiona: The fieldnames are functions that returns the value
03:04:48 <shiona> doesn't seem to work here
03:05:02 <merijn> "subFoest (Node {rootLabel = 875709, subForest = [] }) = []"
03:05:31 <HugoDaniel> shiona: yeah, like: let a = Node { rootLabel = 123, subForest = []}; then if you do "rootLabel a" it will return 123
03:05:38 <shiona> sorry, forgot that even though I have Trees, I had not imported them
03:05:45 <HugoDaniel> :|
03:06:04 <shiona> thanks
03:06:10 <HugoDaniel> merijn: this new ZMTP3 looks amazing
03:06:31 <merijn> HugoDaniel: Yes, it's basically everything I complained about and pointed out a few months back on the mailing list :)
03:06:52 <HugoDaniel> i havent been following the mailing list
03:07:54 <HugoDaniel> sill with zmq the approach of first defining a protocol and only then an implementation should be the correct one
03:08:08 <HugoDaniel> not an implementation and then some doc on that :/
03:09:03 <merijn> HugoDaniel: Eh, the RFC exists but the implementation doesn't yet, so that's what they're doing?
03:09:22 <merijn> Or rather, the implementation is still in development
03:10:33 <HugoDaniel> still i feel nothing beats a properly tunned tcp implementation... zmq is convenient for fast dev.
03:10:50 <HugoDaniel> are you trying to implement it in haskell ?
03:12:24 <merijn> HugoDaniel: Yes, so sockets are threadsafe and I can make a nicer interface that lets you poll on ZMQ sockets and haskell Chan's using STM
03:13:07 <merijn> HugoDaniel: Not just fast dev, doing PUB/SUB, PUSH/PULL in TCP is a pain
03:13:42 <merijn> I think ZMQ is a superior protocol, from a semantics perspective
03:14:10 <tomboy64> okay
03:14:15 <HugoDaniel> great! :)
03:14:16 <tomboy64> i'm in a brain-deadlock here
03:14:24 <HugoDaniel> i should definetely try that
03:14:41 <HugoDaniel> have looked at the async lib ? maybe it helps
03:14:45 <tomboy64> i have a function assembleList = ... where aL' = nextElement
03:14:59 <tomboy64> how do i turn assembleList into an infiniteList?
03:15:20 <tomboy64> i have done this before, i know how it works, but i just don't get it
03:15:40 <tomboy64> (aL' takes the whole assembledList so far)
03:16:12 <tomboy64> e.g. assembleList = ... where aL' x = nextElement x
03:16:30 * hackagebot fclabels 1.1.7.1 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.7.1 (SebastiaanVisser)
03:26:30 * hackagebot monadplus 1.4.2 - Haskell98 partial maps and filters over MonadPlus.  http://hackage.haskell.org/package/monadplus-1.4.2 (HansHoglund)
03:41:53 <Ghoul_> Anyone else getting this ad?
03:42:03 <Ghoul_> I've had nothing but this ad in gmail for the last few days.
03:42:04 <Ghoul_> http://hostr.co/file/2hYyWq7xXGOl/wat.png
03:42:26 <tdammers> I get no ads at all
03:42:38 <tdammers> but then, I read my gmail with mutt
03:42:53 <Ghoul_> it bothers me because I can't click it :|
03:43:04 <tdammers> First World Problem...
03:43:11 <Ghoul_> :P
03:44:01 <YoungFrog> Ghoul_: perhaps it is google hiring haskell programmers ?
03:44:22 <Ghoul_> that'd be cool, but then it'd be clickable
03:45:06 <YoungFrog> the source doesn't have any more info ?
03:45:17 <nexx> lol
03:45:18 <YoungFrog> or maybe, the link on the right ..
03:46:43 <haasn> Ghoul_: “Why this ad?” does nothing?
03:47:20 <Ghoul_> its just stuff about "This ad is based on emails in your mailbox" and such
03:47:32 <nexx> haha top google result is this chat
03:47:33 <Ghoul_> and no, it doesn't seem clickable anywhere
03:47:34 <haasn> Ghoul_: It would sort of be really sweet if some haskell lover out there is actively paying money in order to display welcoming messages to haskell programmers in place of advertisements
03:47:43 <Ghoul_> ^
03:51:30 * hackagebot labyrinth 0.1.6.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.1.6.0 (AlexeyKotlyarov)
03:58:57 <merijn> If I have a datatype "Foo a" and a function that works for some a, but not all, should I just use a typeclass to encode this?
03:59:46 <merijn> I know type family tricks to do that, but that might be a bit gratuitously incompatible with old GHCs?
04:00:13 <hpc> what's your definition of "old"?
04:00:45 <hpc> nobody in their right mind cares about ghc 6.* for instance
04:01:12 * quicksil1er still runs GHC 6.*
04:01:16 <quicksil1er> an excellent vintage.
04:01:21 <merijn> hpc: "won't work with anything pre 7.6 or maybe 7.8"
04:01:31 * hackagebot hlint 1.8.49 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.49 (NeilMitchell)
04:01:33 * hackagebot labyrinth 0.1.6.1 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.1.6.1 (AlexeyKotlyarov)
04:01:36 <Ghoul_> what trick doesn't work with pre-7.6?
04:01:57 <haasn> merijn: I'm more interested in what your use case is
04:02:00 <hpaste> merijn pasted “Restrict TypeFamily” at http://lpaste.net/91143
04:02:22 <merijn> That typefamily works, but is not very portable
04:02:27 <haasn> ie. what kind of functions you're writing that works for “some a, but not all”
04:02:30 <merijn> The only alternative I can think of is a typeclass
04:03:00 <merijn> haasn: a Socket type with a phantom type encoding the type of socket, since some operations are only valid on some sockets, whereas others work on all sockets
04:03:45 <merijn> So most functions would be "Socket a -> IO ()" but some might be only work for specific sockets
04:04:09 <Lethalman> merijn, but that's not a type class, right?
04:04:22 <Ghoul_> isn't that kind of like people building stuff atop MonadState with FunctionalDependencies?
04:04:22 <merijn> Lethalman: No
04:04:26 <Lethalman> ah, now I had a question about phantom types
04:04:28 <merijn> Lethalman: A typeclass would be the alternative
04:04:41 <Lethalman> would that be Proxy a => Socket a  ? is that the right proxy usage?
04:05:08 <haasn> merijn: interesting. I don't know of a way to solve this elegantly off-hand; type-classes have the problem of being open
04:05:25 <merijn> Lethalman: huh?
04:05:50 <haasn> Lethalman: the ‘Proxy’ I know isn't a typeclass
04:05:52 <merijn> haasn: Well, the type family is mildly elegant, but not very portable
04:06:14 <merijn> The typeclass would require a separate data type for each socket and then having a Socket typeclass and writing functions using that typeclass
04:06:15 <Lethalman> errrr right
04:06:36 <merijn> Also Proxy has pretty much nothing to do with phantom types
04:06:51 <Lethalman> how not?
04:06:53 <Lethalman> http://hackage.haskell.org/packages/archive/tagged/0.2.3.1/doc/html/Data-Tagged.html#t:Tagged
04:06:59 <haasn> merijn: I think the most elegant haskell98 way would be either using a different newtype (with a non-exposed constructor and certain monomorphic isomorphisms only); or adding an extra phantom parameter that essentially distinguishes the two categories
04:07:16 <merijn> Lethalman: That just says it uses phantom types
04:07:26 <merijn> haasn: I'm assuming haskell2010 anyway
04:07:27 <Lethalman> ah
04:07:32 <haasn> but the latter can get unwieldy especially if you have more than two categories
04:07:40 <haasn> (so can the former)
04:07:41 <Ghoul_> anyone here on linux with a working llvm/ghc who wants to contribute like 10 minutes to a good cause
04:08:02 <merijn> Lethalman: A phantom type is just "a type that doesn't appear in the value"
04:08:14 <merijn> Lethalman: "data Foo a b = Foo a" <- b is a phantom type
04:08:15 <Lethalman> "Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments"
04:08:36 <Lethalman> I thought it was something to enhance phantom types
04:08:36 <merijn> It's a phantom, because it's not really there
04:08:39 <merijn> Oh, maybe
04:08:55 <merijn> But I've never used that and I use phantom types all the time
04:09:07 <haasn> merijn: Is this something like where you have different kinds of connections (fan-in, fan-out, etc.) that can support different types of message sending/receiving modes?
04:09:52 <merijn> haasn: Yes, and different types can have different settings toggled, but the majority of all functionality is shared, so having to reimplement everything in a Socket typeclass would be sucky
04:10:34 <merijn> Ah, screw it, I'll just say "suck it" and use the state of the art approach
04:10:50 <merijn> That'll teach people to upgrade
04:10:51 <haasn> when in doubt, assume ghc 7.6!
04:11:07 <merijn> haasn: Probably this'll assume 7.7 >.>
04:11:17 * haasn is guilty of writing production code that assumes 7.7
04:13:56 <merijn> It could be 7.6 if I had a way to determine type equality, which I don't think is possible
04:14:09 <merijn> Actually, I guess then it'd be 7.4
04:16:03 <haasn> hmm
04:18:44 <haasn> merijn: do you need type equality though?
04:19:31 <haasn> type family SupportsX (t :: k) :: Constraint; type instance SupportsX SocketA = (); type instance SupportsX SocketB = ()
04:19:47 <haasn> foo :: SupportsX t => Socket t -> ()
04:20:25 <haasn> then again, there's nothing stopping the end user from adding a new type isntance
04:21:14 <haasn> (but that's sort of like saying there's nothing stopping the end user from adding illegal type class instances or using unsafeCoerce or whatever else - a stern warning not to add instances lest the user desire breakage should be enough imo)
04:22:34 <haasn> oh, I just realized your example is the other way round; you're excluding () and Int
04:22:45 <haasn> not restricting it to those two
04:23:31 <haasn> the example I gave has to be inclusive without 7.7
04:24:05 <shiona> should fgl (or some other graph library) be able to handle scc of a somewhat large (n=~2^20, m=~2^22) graph? I don't seem be to able to get (correct) results
04:27:02 <merijn> haasn: oh, I was actually thinking of doing
04:27:18 <int-e> shiona: are you saying that you get incorrect results?
04:27:31 <merijn> haasn: "Restrict a [SocketA, SocketB] => Socket a -> IO ()"
04:28:23 <shiona> int-e: I'm getting wrong results with Data.Graph and unable to get any results with fgl
04:29:23 <shiona> fgl will just eat my memory (I guess I don't know how to handle laziness there) and die on itself.
04:30:56 <int-e> shiona: yeah I'm more interested in the wrong result :) (and sorry, I can't answer your actual question)
04:32:30 <shiona> int-e: unfortunately I'm unable to say more than that it's incorrect :D I'm working (and maybe cheating a little, depending on how you look at it) on a coursera exercise
04:35:26 <ocharles> aristid: thanks for your aws library!
04:44:31 <supki> Lethalman: what that means is instead of passing undefined to functions like  sizeOf :: Storable a => a -> Int  you could pass Proxy if sizeOf was  :: Storable a => p a -> Int
04:46:32 * hackagebot yesod-platform 1.2.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.3 (MichaelSnoyman)
04:48:36 <isomorphic> If I have a set of functions that define integers values, what's the best way for me to make an enum instance based on them?  The problem that I have is that when I introduce the functions, they are not evaluated, but just matched….
04:49:42 <isomorphic> eg: I have foo = 4, and I want to do instance Enum Bar where toEnum foo = SomeConstructor
04:49:56 <isomorphic> … and have foo evaluated to 4
04:57:10 <kuribas> Will ghc calculate an identical calculation twice, or will it optimize it, for example: (calc1 x ^ 2, calc1 x + calc2 x) instead of let c = calc1 x in (c^2 , c+calc2 x)?
04:57:34 <kuribas> Is the second better?
04:58:15 <merijn> kuribas: The second is guaranteed to be only computed once
04:58:47 <merijn> kuribas: The first *may* be optimised to be computed once, but that depends on the GHC optimiser
04:59:05 <merijn> kuribas: In short, if you wanna be sure, use let/where like the second one to make sure it is shared
04:59:37 <merijn> (At least in GHC, I'm not sure whether that's guaranteed by the haskell standard)
04:59:57 <kuribas> I see.
05:00:24 <tdammers> the `let` version also allows for easy introduction of strictness if needed
05:00:34 <kuribas> how?
05:00:42 <tdammers> let c = calc1 x in c `seq` (c^2, c + calc2 x)
05:01:11 <tdammers> this evaluates c strictly before passing it into the calculation
05:01:31 <tdammers> the whole thing is still lazy as a whole, but as soon as the entire expression needs to be evaluated, c is also evaluated right away
05:02:02 <kuribas> yes
05:03:21 <merijn> tdammers: *bzzt*
05:03:36 <merijn> tdammers: The evaluation order of seq is unspecified
05:04:30 <hape02> oops
05:04:38 <merijn> The only thing you can say about "a `seq` b" is: "if neither a nor b are bottom then at the end of evaluating "a `seq` b", both a and b will be evaluated"
05:05:03 <tdammers> right
05:05:06 <merijn> If either are bottom, then the behaviour depends on the evaluation order of a and b, which is not specified
05:05:26 <tdammers> shame on me then
05:05:55 <|apriori|> hey guys, I currently try to build the simd branch of ghc and end up gettign an error following the respective howto
05:06:11 <hape02> why is the function seq called seq then... :-| ?
05:06:12 <|apriori|> the error is: http://lpaste.net/91145 ... does anyone have any idea? the respective primitive package is of course installed (also globally)
05:07:19 <kuribas> Is it possible that a simple calculation is faster than storing it, because of reading from RAM?
05:07:46 <|apriori|> hm, ok, I just verified the inplace ghc is indeed missing the right version of primtive.. question is now, how I could provide it
05:08:41 <Quadrescence> hape02, Ancient astronaut theorists believe it might not have been added to the library by humans.
05:08:43 <int-e> shiona: I should probably aks how you know that the result is incorrect. the implementation in Data.Graph looks fine.
05:09:11 <hape02> Quadrescence :-)
05:10:59 <jmcarthur_mobile> merijn: what you said earlier doesn't sound right. Evaluation order is specified to be non-strict, so the presence of bottom somewhere should not effect the result. I admit I didn't read the full scrollback. Perhaps you were talking about some sort of uncaptured effect
05:11:08 <shiona> int-e: Oracle will tell me that the five largest SCC's of my graph arent of size 76,20,20,20,20 respectively. But that's what I get from my program
05:11:40 <merijn> jmcarthur_mobile: We were talking about seq
05:12:05 <jmcarthur_mobile> Oh, so you are precisely talking about evaluation order itself. Nevermind me then
05:12:12 <merijn> jmcarthur_mobile: :)
05:14:11 <shiona> int-e: the results are .. interesting, to say. I would assume there is a mistake in how I've thought this
05:15:19 <hape02> seq does return the "sec"ond value
05:17:54 <tdammers> "seqond"... :P
05:18:03 <hape02> :-)
05:18:13 <merijn> I guess my earlier question boils down to "how to best do subtyping in haskell?"
05:18:26 <merijn> To bad we don't have structural subtyping :\
05:18:27 <tdammers> seriously though... if it guarantees that the first arg gets evaluated, and the second arg has the first one as a subexpression...
05:18:50 <tdammers> then it should, under normal circumstances, boil down to evaluating the first argument before the second
05:19:09 <merijn> tdammers: Why?
05:19:21 <merijn> The second argument might not even look at the first
05:19:54 <tdammers> no, but if it does, evaluating the first argument last wouldn't make a lot of sense, would it?
05:20:12 <hape02> ⊥ `seq` b = ⊥
05:20:32 <merijn> tdammers: Why? If it does then the first argument will be evaluated anyway
05:20:38 <tdammers> yes
05:20:47 <merijn> haasn: It might evaluate b before returning _|_, though
05:20:49 <merijn> eh
05:20:55 <merijn> s/haasn/hape02
05:21:00 <tdammers> and it will be evaluated before the second one can be evaluated completely
05:21:13 <tdammers> simply because the second one requires the first
05:21:22 <tdammers> of course, it could be evaluated more than once
05:21:27 <merijn> tdammers: Yes, but that also means seq is redundant there
05:21:39 <merijn> If b already forces a, then why bother with seq
05:21:48 <isomorphic> Hrmm - I'm trying to use ViewPatterns to allow me to pattern match on a function - should i be able to construct a new integer using GHC.Prim.Int#?
05:21:53 <tdammers> well, it's what I've been told
05:22:35 <tdammers> use `seq` to force evaluation
05:22:45 <tdammers> oh wait, the point is not sequencing of course
05:23:13 <tdammers> let z = f x in z + x
05:23:15 <tdammers> vs.
05:23:23 <tdammers> let z = f x in z `seq` z + x
05:23:50 <tdammers> what exactly *is* the difference? we need z to evaluate z + x anyway
05:24:13 <merijn> tdammers: *bzzt* :)
05:24:23 <tdammers> awww, not again
05:24:33 <merijn> + is strict for builtin types like Int, Double, etc. but may not be for other types
05:25:14 <tdammers> hmm, so the point is to force evaluation of the *second* argument?
05:25:25 <merijn> If + is strict then, yes z will be forced when "z + x" is forced
05:25:41 <merijn> Lemme provide another example
05:26:22 <merijn> Let's take "z `seq` x + z" and assume we're working with a peano arithmetic instance of Num
05:26:40 <merijn> Clearly, if + recurses in x, then we don't need to evaluate z at all to evaluate "x + z"
05:26:52 <merijn> Just add all x's successors around z
05:27:06 <tdammers> right
05:27:18 <merijn> Now, later someone tried to use the result of "x + z", but surprise! Part of it (z) isn't evaluated yet!
05:27:31 <merijn> Suddenly you're busy evaluating z
05:28:19 <merijn> "z `seq` x + z" means z will be forced at the end of forcing "z `seq` x + z", so the result of "x + z" can't have an unevaluated 'z' in there
05:28:23 <merijn> Without seq it could
05:29:03 <tdammers> ok
05:29:07 <tdammers> just wondering
05:29:11 <merijn> My formulation is off
05:29:22 <tdammers> how would one evaluate `x + z` without evaluating `z` first?
05:29:25 <merijn> It implies z is forced second, whereas seq doesn't specify
05:30:22 <tdammers> but "doesn't specify" still means any order is valid
05:30:25 <hpaste> merijn pasted “peano addition” at http://lpaste.net/91147
05:30:39 <merijn> tdammers: Voila, second argument isn't forced in add
05:30:46 <merijn> tdammers: Yes
05:30:53 <tdammers> yes, I understand peano numbers
05:31:12 <merijn> tdammers: Well, that doesn't "add x z" doesn't force z
05:31:26 <merijn> "z `seq` add x z" does
05:31:38 <tdammers> yes, of course
05:31:54 <tdammers> only thing I'm having a bit of trouble wrapping my head around is this:
05:31:55 <merijn> It doesn't specify whether it evaluates "add x z" first or "z" first,
05:32:02 <supki> I wonder if seq is allowed to not evaluate its first argument if ghc can statically prove it's not _|_
05:32:12 <tdammers> if "add x z" gets evaluated first, and "z" second
05:32:15 <merijn> supki: No, seq guarantees it is evaluated
05:32:36 <tdammers> then the evaluated 'z' later makes its way into 'add x z'
05:32:38 <shiona> int-e: I think I may have gotten it. I think I understood the internal representation wrong
05:32:39 <mauke> supki: I think it is
05:32:39 <merijn> tdammers: That's why you need a name to make seq useful
05:33:04 <tdammers> right, of course
05:33:15 <tdammers> otherwise some sort of common-subexpression-voodoo would be required
05:33:17 <merijn> supki, mauke: The docs specify that after evaluating "a `seq` b", both are evaluated (assuming no bottoms)
05:33:21 <merijn> tdammers: Yeah
05:33:38 <merijn> So of course it's not allowed not to evaluate a
05:33:58 <tdammers> make sense, I guess
05:34:19 <merijn> supki: Not evaluating the first argument makes seq useless
05:35:38 <merijn> tdammers: I mean, "1 + 2 `seq` (1 + 2) + 3" is valid, it's just silly :)
05:35:59 <tdammers> yes, that's what I mean
05:36:00 <merijn> You'd effectively add useless work
05:36:03 <supki> merijn: I don't see why given the equations  seq _|_ b = _|_; seq a b = b  ghc needs to evaluate a if it can prove it's not bottom
05:36:17 <supki> also docs also imply the order, which is not the case
05:36:24 <merijn> supki: Because the semantics of seq guarantee both are evaluated
05:36:45 <tdammers> it would make sense if the compiler were to see that (1 + 2) is a subexpression of the RHS and move it to a name, or some such
05:36:45 <merijn> supki: The fact that haskell can't encode those semantics is irrelevant
05:37:27 <merijn> tdammers: Sure, but GHC has limited support for that
05:37:38 <tdammers> yes, I figured
05:37:47 <tdammers> not enough support in any case to be able to rely on it
05:37:58 <supki> merijn: I don't understand what semantics then
05:38:42 <merijn> supki: the semantics of "a `seq` b" are "evaluating the result of "a `seq` b" will evaluate both 'a' and 'b' in unspecified order"
05:39:20 <merijn> supki: If either 'a' or 'b' are bottom, then the result is bottom, but *which* bottom depends on the order, which is unspecified
05:40:03 <merijn> See also my peano example above to see when/why this is relevant
05:40:36 <FreeFull> When I have something like   seq (error "a") (error "b")
05:40:37 <Heather> hi
05:40:41 <FreeFull> I expect (error "a")
05:40:46 <merijn> "optimising" seq to ignore 'a' if 'a' is not bottom means you might as well just write 'b' rather than "a `seq` b"
05:40:52 <Heather> How can I ignore method out ? alike ignore out from getChar ?
05:40:57 <shiona> sure did, now it works. Although it's still painfully slow, around 2 minutes to calculate
05:41:02 <FreeFull> > seq (error "a") (error "b")
05:41:13 <Heather> e.g. how to make getChar to return nothing but IO()
05:41:14 <FreeFull> Oh, lambdabot is gone
05:41:34 <mauke> Heather: getChar >> return ()
05:41:38 <FreeFull> Prelude> seq (error "a") (error "b")
05:41:39 <FreeFull> *** Exception: a
05:41:46 <merijn> FreeFull: Fun fact, not only is the order of seq unspecified (so it could return either error depending on evaluation order), the order of an expression capable of returning multiple exceptions is unspecified too
05:41:50 <LordBrain> i thought that a `seq` b would result in a being evaluated prior to b
05:42:11 <Heather> mauke thanks
05:42:17 <merijn> FreeFull: "case 1 of 1 -> error "a"; 2 -> error "b"" is allowed to return "error "b""
05:42:50 <merijn> LordBrain: Nope, unspecified. For guaranteed order, see pseq
05:43:08 <mauke> merijn: wait, what?
05:43:17 <FreeFull> merijn: But if you replace the right hand side of  2 ->  with anything non-bottom, it's guaranteed to be error "a"?
05:43:17 <merijn> mauke: Lemme look up the SO answer from SPJ
05:43:22 <mauke> merijn: what's the type of 1 here?
05:43:23 <merijn> FreeFull: Yes
05:43:28 <merijn> mauke: Just a number
05:43:32 <mauke> which one?
05:43:41 <LordBrain> say Integer
05:43:44 <mauke> because if it's Integer, I don't think it can error "b"
05:44:01 <FreeFull> merijn: What if you replaced the right hand side of  1 -> with something non-bottom, but kept the right hand side of  2 ->?
05:44:22 <merijn> mauke: Maybe the second one has to be _ for my example
05:44:39 <merijn> Oh, wait it's not an SPJ answer, but dons
05:44:44 <merijn> http://stackoverflow.com/questions/11070690/how-do-exceptions-in-haskell-work
05:44:47 <merijn> See the first answer
05:45:27 <enthropy> merijn: the controversy seems to be that your first 1 should be an x
05:45:51 <enthropy> or maybe the difference doesn't matter
05:45:58 <mauke> merijn: several people disagree
05:46:07 <mauke> e.g. Peaker, augustss
05:46:08 <merijn> enthropy: It doesn't matter, although my example will probably be optimised to discard the second branch
05:46:53 <merijn> mauke: augustss just says that ghc *shouldn't* do that
05:47:16 <merijn> For a definite answer someone will have to look at the GHC/RTS implementation
05:47:36 <mauke> not just "shouldn't" but "shouldn't if they don't want to break laws"
05:48:13 <merijn> I don't think he's right
05:48:21 <merijn> Because all bottoms are the same to GHC
05:48:25 <merijn> See shachaf's answer
05:49:12 <merijn> 'error "One"' and 'error "Not one"' are identical to GHC as the standard (afaik) doesn't require the compiler to distinguish bottoms
05:49:36 <merijn> Which means GHC is allowed to collapse the 1 branch into the _ branch
05:49:47 <merijn> (common subexpression elimination)
05:50:27 <merijn> So I'm (with my limited language lawyering) siding with dons and shachaf here
05:53:08 <LordBrain> interesting
05:54:16 <LordBrain> we don't expect that behavior
05:54:33 <merijn> LordBrain: See also the SO answer for reasoning *why* :)
05:54:43 <LordBrain> i did
05:56:04 <ClaudiusMaximus> is there a sane combination of MonadRandom, MonadSupply, and MonadLogic ?  i've got a deterministic backtracking search algorithm using [] but I'd like to get the same results in a pseudorandom order without space/time explosions..
05:57:33 <LordBrain> i understand why, but it limits the usefulness of that string
05:57:56 <LordBrain> doesn't it?
05:58:07 <merijn> LordBrain: Yes
05:58:28 <merijn> LordBrain: You shouldn't be using error for exceptions anyway, proper IO exceptions are better
05:58:35 <merijn> As you can actually catch them
05:58:51 <mauke> inb4 spoon
05:59:01 <Quadrescence> spoon
05:59:17 <merijn> All in favour for renaming to acme-spoon >.>
05:59:42 <mauke> @let dı̣ןɟ = flip
06:01:36 <htau> Quick question for anyone who has used Edk's parsers library, what does "reservedOp" in the documentation here:
06:01:37 <htau> http://hackage.haskell.org/packages/archive/parsers/0.8.3/doc/html/Text-Parser-Expression.html
06:01:39 <htau> refer to?
06:02:13 <JuanDaugherty> htau: usually means to be supplied later
06:02:44 <JuanDaugherty> and/or arbitrary room for expansion/internal detail not part of an API
06:02:45 <LordBrain> merijn, this applies to throw too right? only throwIO as a non-bottom value wouldn't be subject to this
06:04:13 <merijn> LordBrain: Good question, I'm not sured
06:05:22 <veryrandomname> if monad binds are lazy, why are IO () actions executed at all?
06:05:53 <merijn> veryrandomname: They aren't, they produce one single big IO () action
06:06:04 <JuanDaugherty> IO happens
06:06:05 <merijn> veryrandomname: The runtimes is responsible for executing IO
06:06:10 <tdammers> JuanDaugherty: IO is
06:06:46 <tdammers> main is just a name bound to a lazily-constructed IO action
06:07:00 <tdammers> the runtime runs it, which may trigger various depths of evaluation
06:07:23 <JuanDaugherty> tdammers, I meant the real world shit
06:07:38 <tdammers> JuanDaugherty: what is this real world you speak of?
06:07:42 <tdammers> :x
06:07:54 <veryrandomname> so monad binds are lazy, but the runtime is free to do any magic it wants to do?
06:08:14 <tdammers> whether >>= is lazy or not doesn't really matter
06:08:37 <supki> merijn: I don't believe you, the report defines seq with those equations only
06:08:53 <tdammers> as long as the runtime needs to evaluate them in order to run the compound action, both sides will be evaluated one way or another
06:08:54 <supki> so it's really an implementation detail whether to evaluate a if it's not a _|_
06:09:04 <supki> (statically)
06:09:24 <merijn> supki: I refer back to my previous argument that then you might as well not use seq then
06:09:27 <JuanDaugherty> "magic" or references thereto are anti-rational, contrary to prevailing ethos
06:09:31 <supki> merijn: yes
06:09:48 <tdammers> or rather, the runtime wants to evaluate the last action in a chain of binds, but because it takes the previous action's output, that one has to be evaluated first
06:09:50 <veryrandomname>  JuanDaugherty: in adventure time magic is just misunderstood science
06:09:57 <merijn> supki: The report states the behavior of seq is implementation defined, afaik
06:10:00 <tdammers> executed, even
06:10:50 <merijn> There's no "or" for type equality, right?
06:11:18 <merijn> i.e "(Or (a ~ b) (c ~ d)) => ..."
06:12:22 <LordBrain> are you using type families, type functions?
06:12:37 <merijn> Yes
06:13:03 <merijn> I just wanna be sure there's no <7.7 way to do what I want
06:13:47 <Lethalman> is it possible to say f :: a such that a is not SomeData ?
06:14:00 <enthropy> merijn: you could take the same approach as HList which has classes HOr and TypeEq
06:14:03 <merijn> Lethalman: Yes
06:14:23 <Lethalman> merijn, oh! awesome, could you give me some pointer?
06:14:23 <merijn> Lethalman: In fact, I pasted code (7.7 and newer only) for that not so long ago
06:15:04 <enthropy> it'd end up looking like    (TypeEq a b ab, TypeEq c d cd, HOr ab cd HTrue) =>
06:15:08 <merijn> Lethalman: http://lpaste.net/91143
06:15:53 <merijn> Lethalman: That has "foo :: a -> a" for any a that's not () or Int
06:16:05 <enthropy> and that approach should work with pretty ancient GHCs (6.8 and maybe a release or two earlier)
06:16:09 <merijn> Be warned that it doesn't play nice with typeclasspolymorphism
06:16:11 <Lethalman> mh I'm not familiar with * families :P
06:16:22 <Lethalman> I thought there was some syntax for that
06:16:26 <Lethalman> thanks merijn
06:19:04 <yesthisisuser> it is not possible to write a case statement in one line or?
06:19:21 <LordBrain> using { ; } it is
06:19:42 <FreeFull> yesthisisuser: All haskell code is writeable in one line
06:19:49 <LordBrain> case x of { 1 -> 'a'; 2 -> 'b'}
06:19:58 <yesthisisuser> ah. ok. sorry. it was a different mistake
06:20:23 <yesthisisuser> the error was something else..
06:20:26 <enthropy> you can probably leave out the { }
06:21:35 <yesthisisuser> yes case x of 1 -> 'a'; _ -> 'b' works fine also
06:21:35 <mauke> is it possible to write haskell without whitespace?
06:22:02 <opqdonut> I think so yes
06:22:11 <LordBrain> merijn, how's your experience been with them, type families and functions?  i've read they're supposed to obsolete functional dependencies, but in practice i have found they are not as restrictive on the types as i expect and the old functional dependency notation is more straight forward when it works... ymmv
06:22:37 <yesthisisuser> no space: case(x)of{1->'a';_->'b'} hehe
06:22:54 <mauke> I don't think you can use modules, though
06:24:00 <LordBrain> maybe they've improved since i last tried them
06:26:53 <merijn> LordBrain: I mostly use them with GADTs, not so much with typeclasses
06:27:08 <quchen> mauke: Yes, you can write Haskell without spaces. S = (<*>), K = const, and parentheses aren't whitespace.
06:27:22 <merijn> LordBrain: And to write type signatures for typeclasses that are otherwise unwritable
06:28:06 <quchen> mauke: And don't mention there's no <*> in the Prelude or I'll start crying :>
06:28:10 <tromp_> you cannot freely combine S and K due to types though
06:28:33 <mauke> quchen: that can't even do I/O
06:29:05 <quchen> Well, delete some whitespaces off this: https://gist.github.com/shangaslammi/3438688
06:30:03 <mauke> quchen: parse error on input `\'
06:30:16 <quchen> There is no \ in that file
06:30:30 <mauke> yes, there is
06:30:33 <quchen> Oh, except that one \
06:30:48 <quchen> Works here.
06:30:57 <mauke> succ'\n'?
06:31:02 <quchen> Aaah.
06:31:03 <quchen> Hm.
06:31:10 <quchen> succ(asc(...))?
06:31:18 <mauke> (succ)'\n'
06:32:12 <quchen> That still leaves us with getting rid of the newlines in the code.
06:33:59 <mauke> replace by ;
06:34:32 <|apriori|> what would be the current way of trying out the ghc simd branch? so far http://ghc.haskell.org/trac/ghc/wiki/SIMD is wrong and outdated and so apparently is https://github.com/mainland/ghc-simd-tests
06:36:30 <quchen> mauke: ; is cheating! :D
06:38:00 <mauke> isn't!
06:38:32 <LordBrain> why are we trying to get rid of whitespace?
06:38:42 <mauke> because I like doing weird stuff with syntax
06:39:02 <mauke> my survey so far: whitespaceless C is possible as long as you don't use preprocessor directives (#include, etc)
06:39:11 <quchen> LordBrain: Saving HDD space
06:39:26 <mauke> whitespaceless Perl is relatively trivial (syntax that requires it (like 'use') can be desugared to alternatives)
06:39:45 <mauke> whitespaceless Haskell is possible with restrictions: you can't use modules
06:39:53 <mauke> but you're still turing complete
06:40:51 <LordBrain> it's not clear that you save space really, you end up puting extra symbols in too
06:41:01 <nooodl> mauke: whitespaceless Perl sounds very easy if you just do, eval"\x__\x__\x__...";
06:41:06 <mauke> yes
06:41:16 <nooodl> same for Python
06:41:32 <mauke> yeah, that's pretty much the only thing that saves python :-)
06:41:35 <mauke> otherwise you'd be screwed
06:43:44 <isomorphic> mauke; nooodl :  Let's not forget pure whitespace perl - http://search.cpan.org/~dconway/Acme-Bleach-1.150/lib/Acme/Bleach.pm
06:44:05 <mauke> that's double cheating
06:44:27 <mauke> 1) it's not really perl  2) you still need 'use Acme::Bleach' at the top
06:45:07 * isomorphic doesn't believe that there exist strings which aren't valid perl
06:45:12 <nooodl> whitespaceless scheme sounds doable, too
06:45:14 <quchen> mauke: https://gist.github.com/quchen/6062440
06:45:21 <LordBrain> lol
06:45:29 <nooodl> just change stuff like (+ 3 4) into (+(car'(3))(car'(4)))
06:45:31 <quchen> In retrospect I could've left b and c in there, I discovered the "where" trick too late :-(
06:45:32 <mauke> isomorphic: )
06:45:51 <taylorgb> I suppose whitespaceless whitespace could pose a problem
06:46:40 <isomorphic> taylorgb:  not from the perspective of brevity
06:46:42 <mauke> I only know two languages that don't allow syntax errors
06:47:36 <LordBrain> dna
06:47:53 <mauke> (teco and ploki)
06:48:13 <merijn> LordBrain: dna certainly has syntax errors
06:48:16 <isomorphic> mauke:  How does that work?
06:48:24 <merijn> It even has error correcting codes to fix semantic errors
06:48:38 <mauke> isomorphic: well, perl sees the unbalanced ) and throws a syntax error
06:48:48 <isomorphic> mauke:  I would have thought something like brainfuck was a candidate
06:48:58 <nooodl> there's a ton of syntax-error-less esolangs out there. like brainfuck
06:49:17 <mauke> isomorphic: ]
06:49:24 <nooodl> oh right not brainfuck
06:49:46 <Yaniel> <obligatory malbolge mention>
06:50:36 <nooodl> befunge, though: i think the spec mentions the instruction pointer should just turn 180° when passing over any instruction it doesn't recognize. which is cute
06:51:18 <quchen> befunge is this 2D language, right?
06:51:53 <quchen> nooodl: [] have to matchin Brainfuck, don't they
06:52:37 <nooodl> yep
06:53:31 <isomorphic> Oh good point.
06:53:34 <nooodl> a version of brainfuck that just adds [[s and ]]s around your program until it's valid, though, would be a candidate
06:54:03 <isomorphic> In that case I think we might be able to throw perl back in ;)
06:54:27 <mauke> I have a brainfuck->OISC compiler written in perl
06:54:34 <mauke> http://mauke.hopto.org/stuff/perl/bfc.pl
06:56:12 <yesthisisuser> how is (>>) implemented?
06:56:30 <Taneb> Varies Monad to Monad
06:56:36 <yesthisisuser> IO
06:56:38 <isomorphic> mauke:  That's kind of awesome
06:57:00 <Taneb> Default is "m >> k = m >>= \_ -> k"
06:57:17 <isomorphic> @src Maybe (>>)
06:57:38 <mauke> isomorphic: the code it generates looks awesome
06:57:58 <isomorphic> mauke:  It's really screaming for libvirt integration
06:58:11 <isomorphic> … you know, so finally we could target the BVM
06:58:13 <mauke> oh, what's that?
06:58:17 <isomorphic> …. maybe LLVM bindings
06:58:39 <isomorphic> library for virtualisation - http://libvirt.org
06:58:45 <quchen> Let's move this to #haskell-blah?
07:02:05 <ignacio> #nothaskell
07:04:05 <mr-> Oh.. lambdabot is gone :-/
07:10:50 <merijn> Is there any reason not to create a new top level module name?
07:11:01 <merijn> i.e. "Foo" vs "System.Foo" or "Control.Foo"
07:11:13 <tulcod> i love haskell. using template haskell and a few libraries, i just wrote code that finds a C header file, reads the #defines in there, and converts it to the haskell equivalents i need. at compile time
07:12:44 <tulcod> it's 12 lines total. omg
07:14:13 <enthropy> merijn: people might think your code predates hierarchical modules
07:14:52 <merijn> enthropy: It feels so overkill to write a module that's like "System.Foo.InternalHierarchy.Blah"
07:16:50 <sopvop> GHC source is undocumented mess!
07:17:10 <Lethalman> sopvop, what? \o/
07:17:11 <Sculptor> yo
07:17:22 <Igloo> Please send patches to fix it  :-)
07:17:23 <Lethalman> ghc is one of the most documented source I've ever seen
07:17:46 <Nimatek> But.. I thought Haskell documents itself!
07:17:48 <enthropy> probably you are looking at different parts
07:17:49 <Lethalman> don't look at haddocks on hackage, for some reason they don't report the literate docs
07:17:52 <quchen> Hm. Well I'm not particularly impressed with the docs, but maybe I'm looking in the wrong places.
07:17:53 <sopvop> I would, If I understood what is going on.
07:19:12 <sopvop> igloo: First I would replace all the \begin{code} and friends with haddock. I don't think it would ever be accepted :)
07:20:54 <benmachine> haddock isn't source documentation, it's API documentation
07:22:20 <sopvop> but at least it does not break sources html in haddock and github.
07:22:50 <htau> I am still not sure about what is going on in the example expression parser in Edk's parsers library. From looking at it and other parts of the library, I would assume that reservedOp is intended to interact with the strings supplied in the table, but It is not clear to me how reservedOp is intended to be constructed from the functions supplied in the rest of the library. "reserve somestyle...
07:22:51 <htau> ...name" seems promising, but doesn't seem to be right. Can anyone enlighten me?
07:24:10 <sopvop> reserved = reserve myStyle -- in my code
07:25:20 <htau> hmm, maybe I did not declare the style correctly.
07:27:12 <wewe98> ciao
07:27:21 <wewe98> !list
07:27:21 <monochrom> wewe98: http://lpaste.net
07:27:34 <mauke> hello, italia
07:32:21 <heilkn> hi! I edited the prefix directory in ~/.cabal/config for install-dirs user and install-dirs global but cabal still put's the libs in .cabal directory :(
07:36:41 <hpaste> rul pasted “Rfc2822 fields” at http://lpaste.net/91149
07:38:06 <rul> Hello. I'd like to know if there is a shorter way of getting rfc2822 fields compared to the way I'm doing it, as shown in http://lpaste.net/91149
07:38:40 <rul> getSubject, getFrom, getTo... is there a way to generate them?
07:45:15 <heilkn> rul, this looks like you're traversing lists
07:45:36 <heilkn> :t traverse
07:46:20 <enthropy> heilkn: traverse with which Applicative?
07:47:57 <rul> I think the problem here is that I have to return a different constructor for each function (Subject str, From str, To str, etc.), so I can't easily pattern-match
07:48:03 <enthropy>   getSubject (Message fs _) = fromMaybe "No subject" $ listToMaybe $ mapMaybe (\x -> case x of Subject y -> Just y; _ -> Nothing) fs -- this is not really better
07:48:04 <blueonyx> hi, how can i grep for haskell -- comments?
07:49:49 <twoolie> blueonyx: `grep -r "-- " *.hs ` ?
07:50:37 <heilkn> enthropy, rul: maybe there is a way to define an applicative instance for message?
07:50:54 <bscarlet> That won't find comments w/o the space.
07:50:54 <bscarlet> grep -- --
07:50:56 <bscarlet> (the first -- indicates the end of option processing, so the second -- is processed as a pattern)
07:51:09 <enthropy> > let a --- b = a + b in 1 --- 2
07:51:26 <blueonyx> bscarlet: yea that works, thanks you two
07:51:51 * hackagebot reenact 0.9 - A reimplementation of the Reactive library.  http://hackage.haskell.org/package/reenact-0.9 (HansHoglund)
07:51:53 <twoolie> `grep -r "\b--\b" *.hs`
07:52:13 <enthropy> --- doesn't seem to be a function, but things like --+ are
07:52:32 <twoolie> \b matches on word boundaries
07:52:50 <mauke> comments aren't word boundaries
07:52:52 <blueonyx> twoolie: doesnt find anything, -- -- does
07:53:00 <mauke> also, \b is perl syntax, not grep
07:54:40 <bscarlet> the \b works for me w/ gnu grep 2.13
07:54:43 <bscarlet> sorry 2.14
07:58:09 <htau> I just can't seem to that expression parser work, any chance that anyone has a working example I could look at? I was excited to try that feature out, but I am at the point where it doesn't make sense to play with it anymore and I should just hand roll the thing.
07:58:59 <jcowan> Is there a way (not in Haskell itself, but abstractly) to construct functors, applicative functors, and monads such that there is a neat stack of primitive methods (functors need one, applicatives need two, monads need three)?
07:59:24 <jcowan> or for two/three read three/four if necessary?
07:59:54 <shachaf> I'm not quite sure what you're asking.
08:00:37 <merijn> @unmtl StateT s STM a
08:01:14 <quchen> s -> STM (a, s)
08:01:33 <shachaf> s -> STM (s, a)
08:02:10 <merijn> hmm, pretty sure I need a different approach for this :\
08:02:18 <quchen> It's (a, s) I think.
08:02:23 <shachaf> Yes.
08:02:27 <shachaf> But it should be (s, a).
08:02:38 <jcowan> shachaf: So to define a functor you need only a mapping function, and you can define a monad with mapping, unit, and join functions.  But if you have only mapping and unit, you get a premonad rather than an applicative.  I'm wondering if there is some way to design applicatives so they fit in neatly between functors and monads, given that every monad is an applicative and every applicative is a functor.
08:03:12 <htau> what was the reasoning behind that tuple ordering for state?
08:03:37 <quchen> Truth or dare in the GHC HQ
08:04:00 <htau> They chose dare I suppose...
08:04:12 <alexander__b> what's the simplest GUI thing that haskell has bindings for? I just want a trayicon app
08:05:21 <quchen> alexander__b: I don't think "simple" lives in the same category as "tray icon".
08:05:37 <quchen> Apfelmus posted a new library a couple of days ago that sounds really simple: alexander__b: There was a recent
08:05:42 <quchen> Eh, thanks X
08:05:49 <quchen> http://apfelmus.nfshost.com/blog/2013/07/21-threepenny-gui-0-1.html
08:05:49 <quchen> That's the link
08:05:50 <alexander__b> quchen: simplest
08:06:03 <alexander__b> I'd prefer something "common"
08:06:15 <alexander__b> gtk/qt/tk/whatever. though I'm not familiar with either
08:06:39 <quchen> GTK+ is common, but it'll feel like you're coding C (because you're basically coding C).
08:06:59 <quchen> Anyway, that's as far as my GUI experience goes.
08:07:01 <alexander__b> quchen: I like C and would be interested in learning how haskell interacts with C, so that's not an entirely bad thing
08:07:33 <quchen> alexander__b: Haskell's GTK library is pretty much a wrapper the actual GTK C lib.
08:07:52 <quchen> Everything's in IO and you're procedurally generating the forms.
08:08:03 <quchen> It feels like coding C, but it's actually Haskell.
08:08:10 <quchen> No pointers though, so that's a small plus. :-P
08:08:18 <klrr> this distrurbs me https://gist.github.com/klrr/6049842
08:08:31 <alexander__b> quchen: I like pointers :-P
08:08:34 * alexander__b hides
08:14:44 <ParahSailin> im kinda confused how (>>= \(Just x) -> return x) works-- why dont you have to match the pattern Nothing?
08:15:00 <shachaf> You do.
08:15:06 <ParahSailin> it is implicit?
08:15:11 <shachaf> Oh, well, you don't "have" to.
08:15:17 <shachaf> You'll just get an error if that's not a Just.
08:15:21 <shachaf> So you shouldn't do that.
08:15:26 <ParahSailin> @src catMaybes
08:15:36 <ParahSailin> oh, curse lambdabot for not being here now
08:15:45 <ParahSailin> catMaybes ls = [x | Just x <- ls]
08:15:49 <shachaf> Is cursing really necessary?
08:15:59 <shachaf> OK, what about it?
08:16:16 <ParahSailin> is that equivalent to what i attempted to de-sugar?
08:16:36 <shachaf> No.
08:17:01 <ParahSailin> so the list comprehension syntax has some extra magic in it
08:17:28 <bscarlet> If I understand right, it's not the list comprehension, it's the list monad instance.
08:17:31 <shachaf> catMaybes ls = do { Just x <- ls; return x } would behave the same way.
08:17:47 <shachaf> bscarlet: No, it's the list comprehension (at least in Haskell 2010).
08:17:54 <ParahSailin> @undo do { Just x <- ls; return x }
08:17:56 <kappabot> ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
08:18:03 <shachaf> @undo catMaybes ls = [x | Just x <- ls]
08:18:03 <kappabot> catMaybes ls = concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
08:18:24 <ParahSailin> i see, so the do syntax adds that magic pattern matching
08:18:31 <quchen> ParahSailin: do notation has this built-in "fail" function we don't like to talk about. It's invoked if you encounter a pattern mismatch on the left side of "<-".
08:18:35 <bscarlet> shachaf: how does that fit with your statement that do syntax works the same way?
08:18:40 <ParahSailin> quchen: thanks
08:18:42 <shachaf> I searched for "list comprehension" in the Haskell report and found http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
08:19:04 <shachaf> bscarlet: How does it not?
08:20:25 <quchen> ParahSailin: For (most) practical purposes, you can view list comprehensions as sugar for do notation. Pattern mismatch => [] for lists.
08:21:33 <bscarlet> shachaf: are we talking past each other because of my use of "it's"? I meant that the magic which makes the failure of the pattern match for "Just x" isn't part of the list comprehension syntax, but rather a combination of two things: the translation of monadic bind pattern failure to a call to "fail", and the monad instance for list for which fail is [].
08:22:12 <shachaf> bscarlet: List comprehension syntax has nothing to do with the Monad instance for [].
08:22:26 <shachaf> Did you see my link? It's specified separately.
08:22:53 <benmachine> shachaf: they're specified separately, but there's a simple syntactic correspondence between them
08:23:19 <benmachine> the report could be rewritten to specify them together with zero change to the actual language
08:23:22 <benmachine> aiui
08:23:24 <shachaf> Yes. But "it's not the list comprehension, it's the list monad instance" is wrong.
08:23:31 <ParahSailin> there's MonadComprehensions
08:23:50 <shachaf> Hence "(at least in Haskell 2010)".
08:23:56 <bscarlet> shachaf: Ah. Thanks for explaining.
08:24:09 <quchen> bscarlet: GHC doesn't convert list comprehensions to monadic code, it uses folds etc. because those can be optimized better as far as I know.
08:24:28 <quchen> Using the List monad would be a valid implementation too, however.
08:25:07 <bscarlet> quchen: I would have hoped that ghc could optimize monadic code for the same thing just as well. If not, can you explain the obstacle at all?
08:28:03 <quchen> bscarlet: I just repeated what I was told multiple times here to keep my entropy footprint small.
08:28:19 <quchen> The monad instance for [] uses folds too after all.
08:29:54 <FreeFull> quchen: Folds?
08:30:00 <FreeFull> It's just concatMap
08:30:08 <quchen> m >>= k = foldr ((++) . k) [] m
08:30:19 <quchen> Which is concatMap written as a fold
08:30:36 <FreeFull> Well, all list operations can be written as a fold
08:30:45 <FreeFull> But concatMap is weaker than a fold
08:30:55 <merijn> Chan/TChan aren't functors? Sad :(
08:31:32 <merijn> Oh, I guess it makes sense for bidirectionalness
08:31:42 <shachaf> merijn: Just like IORef etc. isn't.
08:31:53 <FreeFull> merijn: I don't think the type would be right for functors
08:31:56 <shachaf> You can use CoYoneda Chan if you like, though!
08:32:17 <merijn> FreeFull: It's not right because the type functions as a bidirectional entry point
08:32:31 <merijn> If you had read only endpoints those could be functors
08:32:52 <merijn> Similarly write only endpoints could be contravariant functors, if I understood those correctly
08:33:11 <shachaf> merijn: CoYoneda Chan a = exists x. (Chan x, x -> a)
08:33:30 <merijn> shachaf: Yeah, but I don't think that will be very nice
08:33:38 <shachaf> That's more or less a read-only Chan. It produces values of some type -- you don't know what -- and it also has a function to convert it to your type.
08:34:17 <FreeFull> To modify the contents of an IORef you need something like    (a -> b) -> IORef a -> IO (IORef b)
08:34:27 <FreeFull> Actually
08:34:35 <FreeFull> You wouldn't need to return the IORef
08:34:42 <FreeFull> And
08:34:48 <FreeFull> I don't think you'd be able to change the type
08:34:50 <FreeFull> But you get me
08:34:57 <FreeFull> It doesn't match up with fmap
08:39:27 <ParahSailin> what is CoYoneda?
08:41:05 <hpaste> rul revised “Rfc2822 fields”: “Rfc2822 fields” at http://lpaste.net/91149
08:43:06 <rul> Hi. I could narrow my code as shown in http://lpaste.net/91149. There is obviously a pattern, but I can't realize how to exploit it. To, From and Subject are all constructors. Does anyone know how to make this code smaller? It does not scale to do this for all fields of rfc2822
08:43:38 <alexander__b> (\x y -> fromInteger ((^) (floor y) (floor x)))) -- I get "Defaulting the following constraint(s) to type `Integer'. how do I remove this warning? i.e. how do I specify Integer?
08:44:18 <shachaf> That's the full error you get? GHC doesn't tell you where it's happening or anything?
08:44:34 <kolmodin> I know there is a wiki page with a matrix of ghc versions vs library versions. I can't find it any more.
08:45:03 <kolmodin> Does somebody know where it (or something equivalent) is?
08:46:38 <enthropy> is it an oversight that [d| foo = foo |] :: Q [Dec], while instanceD takes  [Q Dec]?
08:46:43 <alexander__b> shachaf: it's on the end paren of (^)
08:46:52 * hackagebot git-annex 4.20130723 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130723 (JoeyHess)
08:48:01 <shachaf> alexander__b: When you ask a question like that, please go to hpaste and paste in the full code and full error that you actually get.
08:48:19 <enthropy> at some point [d| |] was [Q Dec] I think
08:49:14 <alexander__b> shachaf: that site is not very functional here.
08:49:38 <shachaf> See topic for the domain name of the day.
08:49:39 <valdyn> rul: you can pattern match against those constructors if they are creating the same type
08:49:44 <sopvop> So, after the great Functor=>Applicative=>Monad fix the (Functor m, Monad m) => Applicative (StateT s m) will replace Monad m constraints with Applicative? Or will it violate some laws?
08:49:46 <alexander__b> shachaf: is lpaste acceptable?
08:49:53 <alexander__b> shachaf: oh right
08:49:54 <shachaf> Any website is acceptable.
08:50:02 <shachaf> (Other than pastebin.com.)
08:50:16 <alexander__b> shachaf: http://lpaste.net/91152
08:50:23 * enthropy is mistaken, it's been Q [Dec] for a very long time http://www.haskell.org/ghc/docs/6.4-latest/html/users_guide/template-haskell.html
08:50:35 <alexander__b> shachaf: l51 c46, warning: Defaulting the following constraint(s) to type `Integer'
08:50:37 <b2coutts> why do people dislike pastebin?
08:50:39 <shachaf> alexander__b: That doesn't have your error. :-(
08:51:03 <alexander__b> shachaf: I just pasted it here
08:51:03 <alexander__b> shachaf: I can repaste if you really really want
08:51:10 <shachaf> alexander__b: Are you not seeing something like «(Integral b0) arising from a use of `^'»?
08:51:23 <alexander__b> shachaf: no the entire thing was just pasted
08:52:05 <alexander__b> shachaf: it's just that warning. on (^).
08:52:05 <m0g> b2coutts: people dislike pastebin because it's full of ads and mangles the input
08:52:07 <rul> valdyn: do yo mean that I can pass the constructor as parameter?
08:52:33 <valdyn> rul: yes, but im seeing that you are already doing that
08:52:45 <alexander__b> m0g: I haven't actually seen it mangling the input ever, but I know people complain about it. as for ads... lol. I don't get those. :-)
08:53:02 <shachaf> alexander__b: GHC literally only gives you a one-line warning?
08:53:12 <merijn> b2coutts: ugly, slow, ads, lots of JS
08:53:19 <rul> valdyn: My target is not to have one function per constructor
08:53:23 <alexander__b> shachaf: not ghc, sorry, ghc doesn't say anything. it's the syntax highlighting.
08:53:30 <m0g> alexander__b: I've experienced it several times already, in #bash in particular where people often have encoding problems. Sometimes the problems were not present in the raw file served by pastebin
08:53:43 <shachaf> Syntax highlighting?
08:54:00 <alexander__b> shachaf: ghc-mod.
08:54:01 <valdyn> rul: right now youre functions are all identical, so you could just aswell have getSubject (From f:fs) = ...
08:54:49 <shachaf> OK. ghc-mod is giving you partial errors, apparently. Or you don't know how to look at the full errors (in my case I press \l for it).
08:54:49 <ParahSailin> rul: do {From f <- xs; f}
08:54:49 <alexander__b> shachaf: which uses hlint.
08:54:50 <ParahSailin> ditto for Subject, etc
08:54:53 <shachaf> This isn't an hlint error, it's a GHC error.
08:55:15 <shachaf> alexander__b: So you should use ghc -Wall or ghci -Wall to get the full error. Otherwise you might be in the dark.
08:55:27 <shachaf> alexander__b: Anyway:
08:55:28 <shachaf> :t (^)
08:55:33 <kappabot> forall a b. (Integral b, Num a) => a -> b -> a
08:55:34 <shachaf> :t floor
08:55:41 <alexander__b> shachaf: -Wall was... verbose.
08:55:41 <kappabot> forall a b. (Integral b, RealFrac a) => a -> b
08:56:25 <shachaf> floor gives you some Integral instance. (^) *takes* some Integral instance. GHC doesn't know which instance to pick, so it defaults.
08:56:37 <alexander__b> shachaf: I'm not sure what that means
08:56:57 <rul> valdyn, ParahSailin: I think that I didn't explain myself very well. I want to do something like this: "getField From fields", to get the From field. Or "getField To fields", to get the To field, where "fields" is a list with rfc2822 fields
08:57:10 <shachaf> Do you know what type classes are?
08:57:12 <alexander__b> ^ takes integrals, floor gives integrals. I pass an integral to a function that takes an integral. what's the problem with that?
08:57:21 <merijn> alexander__b: *which* integral?
08:57:28 <shachaf> "Integral" isn't a type.
08:57:33 <merijn> alexander__b: Int, Matrix?
08:57:36 <rul> valdyn, ParahSailin: but I can't find a way to pass the constructor as a parameter
08:57:40 <merijn> alexander__b: "Peano"?
08:57:56 <bscarlet> alexander__b: it means the type of the intermediate value(s) returned by floor and consumed by ^ isn't fully nailed down. It's some type which is an instance of Integral, but your code doesn't give GHC enough information to know which.
08:58:04 <merijn> String? (see acme-php)
08:58:12 <shachaf> merijn: I think two was enough.
08:58:12 <alexander__b> ah
08:58:12 <alexander__b> integral is a type class
08:58:12 <alexander__b> merijn: wat
08:58:13 <valdyn> rul: you are using getFrom but you should just use getField (From f:fs)
08:58:26 <alexander__b> bscarlet: yes, I see now.
08:58:37 <merijn> shachaf: Yeah, I should've went for String immediately
08:58:41 <alexander__b> how do I specify that I want Integer then?
08:58:53 <merijn> alexander__b: type annotation
08:58:59 <alexander__b> merijn: yes but where?
08:59:01 <alexander__b> in the floors?
08:59:03 <merijn> "foo ^ (x :: Integer)"
08:59:08 <merijn> eh
08:59:12 <merijn> "foo ^ (floor x :: Integer)"
08:59:21 <alexander__b> I get the same thing
08:59:43 <alexander__b> ah because ^ doesn't specify Integer for its result
09:01:07 <rul> valdyn: If I do it that way then how can I distinguish which field I want?
09:01:13 <alexander__b>       ,("^"   , binOp  (\x y -> fromInteger ((^) (floor y :: Integer) (floor x :: Integer) :: Integer)))
09:01:13 <alexander__b> lol
09:01:23 <ParahSailin> rul: ah, so you want getfield cst fs = do {cst f <- fs; f}, where cst is a constructor
09:01:40 <alexander__b> actually I don't need to do it on the y. only on x and the result of the ^.
09:01:43 <ParahSailin> does haskell allow passing around constructors in pattern matches like that?
09:01:46 <shachaf> alexander__b: No, it has nothing to do with (^)'s result.
09:02:12 <valdyn> rul: 3 lines: getField (Subject f:fs) ; getField (From f:fs) ; getField (To f:fs)
09:02:13 <alexander__b> shachaf: yes because ^ produces an Integral and I use fromInteger on the result
09:02:31 <merijn> alexander__b: That should be inferrable
09:02:34 <merijn> :t fromInteger
09:02:34 <shachaf> alexander__b: You're using fromInteger, so you don't need to specify that the result is an Integer.
09:02:42 <alexander__b> oh. guess not.
09:02:42 <alexander__b> why not though?
09:02:46 <kappabot> forall a. Num a => Integer -> a
09:02:51 <shachaf> alexander__b: And the first argument is the same type as the result, because that's how the type of (^) goes.
09:02:51 <alexander__b> shachaf: I see. nice.
09:02:53 <merijn> alexander__b: type inference
09:03:03 <alexander__b> merijn: yes, I see.
09:03:05 <shachaf> Did you look at the type of (^)? kappabot told us what it was before.
09:03:14 <shachaf> :t (^)
09:03:19 <kappabot> forall a b. (Integral b, Num a) => a -> b -> a
09:03:21 <alexander__b> yes, second arg is Integral
09:03:27 <rul> ParahSailin: why should I use do notation? AFAIK what want to do is pure functional
09:03:31 <alexander__b> which is the one I am doing :: Integer on
09:03:39 <alexander__b> because floor returns an Integral
09:03:44 <Kinnison> rul: do notation is not impure
09:03:51 <Kinnison> rul: Only IO things are impure
09:03:52 <merijn> :t \x y -> fromInteger (floor y) ^ (floor x :: Integer)
09:03:54 <kappabot> forall a a1 a2. (Num a, RealFrac a1, RealFrac a2) => a2 -> a1 -> a
09:04:01 <merijn> Kinnison: IO is pure too
09:04:06 <Kinnison> merijn: Well, sorta :-)
09:04:13 <merijn> No, not sorta
09:04:17 <alexander__b> Kinnison: that's what I'm doing
09:04:22 <alexander__b> eh merijn ^
09:04:30 <merijn> IO is pure and referentially transparent, period.
09:04:31 <rul> Kinnison, ParahSailin: okay, I'll try that way
09:04:46 <Kinnison> merijn: I'm confused now :-(
09:05:19 <alexander__b> hm. ghc --Wall catches things my syntastic with ghc-mod doesn't. I wonder why.
09:05:19 <b2coutts> Kinnison: putStrLn "asdf"   will always give you the same result
09:05:28 <merijn> Kinnison: The *implementation* of IO isn't pure, but that isn't relevant, you can't do impure things with it inside haskell
09:05:33 <geekosaur> Kinnison, it's something of a trick. IO *actions* are purely functional
09:05:40 <b2coutts> readFile "file.txt"    will also always give you the same result
09:05:44 <Kinnison> b2coutts: Not true
09:05:53 <merijn> Kinnison: It is
09:06:03 <b2coutts> Kinnison: it will give you a thing that will read the contents of "file.txt"
09:06:07 <Kinnison> Well, it always gives you the same kind of IO action, okay
09:06:07 <b2coutts> (roughly)
09:06:07 <ParahSailin> rul: the do notation simply allows you to abbreviate 3 lines of pattern matching
09:06:09 <geekosaur> their results are not pure, but the whole pont of IO is you do not manipulate those directly, you use callbacks
09:06:10 <merijn> Kinnison: "putStrLn "asdf"" returns an action that when executed prints "asdf"
09:06:11 <Kinnison> *doing* IO is not pure
09:06:12 <shachaf> merijn: Not for any reasonable sense of the word "give you"
09:06:25 <shachaf> merijn: It *is* the same value, of course.
09:06:28 <shachaf> But whatever.
09:06:54 <Kinnison> and for the most part, when people say "IO is not pure" they are explicitly referring to the fact that doing it relies on the external impure world
09:06:58 <Kinnison> At least I do
09:07:02 <merijn> shachaf: Yeah, that's unlucky formulation
09:07:07 * Kinnison agrees that constructing the IO actions is pure
09:07:27 <geekosaur> but that is not actually happening *in Haskell*. think of it as, you are purely functionally creating a program to be run by the runtime. creation of that program is entirely pure, running it is not but it's not actually running *in Haskell*
09:07:30 <merijn> Kinnison: The problem I have with that use is that it perpetuates the myth that haskell requires ugly hacks to work with IO
09:07:45 <merijn> And that the existence of IO somehow makes haskell less pure
09:07:47 <b2coutts> Kinnison: it's a fairly important distinction to make that things of type "IO String" are in fact pure values
09:08:11 <Kinnison> merijn: I shall try and be more specific in future, so as not to offend you :-)
09:08:15 <b2coutts> it's helpful in understanding how IO works in haskell, and what it means for something to have type IO String
09:08:25 <b2coutts> @quote /bin/ls
09:08:26 <kappabot> No quotes match.
09:08:43 <Gracenotes> the monadic formulation of IO is more or less ordering via nested lambdas using strict nesting functions
09:08:53 <Gracenotes> whatever else semantics it has, well, go wild
09:08:57 <shachaf> Hmm, I'll just say it.
09:09:06 <shachaf> getLine :: IO String contains a String in the same way that /bin/ls contains a list of files.
09:09:37 <rul> ParahSailin: So I can use it like "getField fs = do { From f <- fs; f }", but not like "getField cst fs = do {cst f <- fs; f}" and then "getField From fs"
09:09:57 <ParahSailin> to the more knowledgeable people, is there a language extension that lets you do something like "derp constr fs = do {constr f <- fs; f}" where constr is a constructor?
09:10:17 <Gracenotes> rul: if you don't use constructors literally in a pattern machine context, they'll be packaged up as a function (or constant)
09:10:27 <Gracenotes> *matching
09:10:39 <Gracenotes> and you can't go back from function to pattern-matching-constructor
09:12:03 <rul> Gracenotes, ParahSailin: Okay then, I'll use the do notation for making one-line functions
09:12:34 <Gracenotes> if you have a constructor C a b of datatype D, you could define a function Monad m => D -> m (a, b) using fail. But perhaps you've heard that fail is fail, so beware.
09:13:04 <Gracenotes> this would do the same thing as the second version of getField you have there
09:13:28 <Gracenotes> and it would be a manual definition... with weird behavior for some monads...
09:14:58 <rul> Gracenotes: Ok, thanks :-)
09:15:44 <merijn> Foldable doesn't require Functor?
09:16:09 <Taneb> Nope
09:16:18 <merijn> hmm
09:16:21 <savask> Hello! While trying to install contravariant package (it's required by diagrams) I got this error: http://lpaste.net/91153 How can I overcome it?
09:16:22 <S11001001> merijn: Set
09:16:30 <Taneb> Set is foldable, for instance
09:16:41 <merijn> oh, right
09:16:53 * hackagebot io-streams 1.1.0.3 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.0.3 (GregoryCollins)
09:17:08 <rul> ParahSailin:  "do { From f <- fs; f }". In this case, do the "<-" returns the first element that pattern-matchs in the list?
09:17:30 <shachaf> savask: tagged 0.4.5? That's pretty old.
09:18:30 <shachaf> savask: By "pretty" I mean "a few months".
09:18:54 <shachaf> But the SafeHaskell issue was fixed in the latest version.
09:19:14 <savask> shachaf: And probably it requires new GHC, right?
09:19:48 <shachaf> savask: I hope not.
09:21:03 <savask> shachaf: Thanks a lot, that have worked! I always forget that cabal doesn't update packages automatically.
09:21:13 <Gracenotes> rul: if that's in the [] monad, that means the same thing as [ f | From f <- fs ], notation which you may be familiar with
09:21:28 <ParahSailin> rul: well actually it will concatMap all the From items of the fs list
09:22:22 <merijn> Man, the 'in' keyword keeps getting in my way :(
09:22:49 <ParahSailin> Gracenotes: no, thats technically different
09:23:16 <rul> Gracenotes: yeah, that's a clearer way for me :-)
09:23:19 <ParahSailin> Gracenotes: [ f | From f <- fs ] == do {From f <- fs; return f}
09:23:49 <Gracenotes> oh... it's a list of lists?
09:24:05 <alexander__b> http://lpaste.net/91154 -- I know that line is long and fugly and can be improved (I intend to), however -- how can I "exit early"?
09:24:21 <alexander__b> that is once I get an unrecognised operator, present it and be done
09:24:27 <Gracenotes> or, well, a list of datatypes which has a list constructor. I see... that's a less common pattern.
09:24:29 <ParahSailin> f :: [a] from what i can tell
09:25:04 <alexander__b> I can use foldr and flip f, but then that will not work with the rest of the program because infinite lists and blah.
09:25:11 <Gracenotes> so it would be like concat [ ... ]
09:26:18 <Gracenotes> do the list comprehension with a cat
09:26:58 * hackagebot fishfood 0.0.1.0 - Calculates file-size frequency-distribution.  http://hackage.haskell.org/package/fishfood-0.0.1.0 (AlistairWard)
09:27:14 <Gracenotes> I really never use list comprehensions, but they can help list processing intuition.
09:27:30 <monochrom> alexander__b: foldl cannot exit early. foldr can exit early if you use it right.
09:27:56 <alexander__b> monochrom: yes, I imagine I need to restructure things... or maybe collect all unrecognised operators in a list, and present that at the end
09:28:05 <enthropy> do others also think that -fdefer-type-errors should be in a default ~/.ghci?
09:28:13 <monochrom> > foldr (\x ys_unused -> x) 0 (repeat 1)
09:28:16 <kappabot>   1
09:28:27 <monochrom> exits early
09:29:57 <monochrom> I do not, enthropy
09:30:00 <alexander__b> what's considered an idiomatic-ish way of doing "if no args then print help else do stuff"?
09:32:20 <supki> I'd outsource that problem to optparse-applicative
09:32:42 <alexander__b> supki: compiling that now thanks for the suggestion
09:33:43 <monochrom> I do not know what is idiomatic. but I do this. if toy program, "args <- getArgs; case args of ...". if real program, go all out and use optparse-applicative to process args properly
09:36:05 <enthropy> optparse-applicative seems to require you to write more code than the equivalent program using cmdargs
09:37:11 <kartoffelbrei> enthropy: but it's pure and not as scary as cmdargs
09:37:14 <alexander__b> supki: monochrom: I don't understand the optparse-applicative docs. do *I* write the parser?
09:37:28 <alexander__b> there's an example of a parser and an example of how to use the parser, so I assume those two together would be an actual program
09:37:58 <alexander__b> except it doesn't tell me what imports the examples is using so nothing is in scope eh
09:38:11 <alexander__b> is there any *real* example that will compile and run?
09:39:21 <enthropy> kartoffelbrei: in what sense is cmdargs scary?
09:39:23 <bitonic``> alexander__b: <https://github.com/pcapriotti/optparse-applicative/tree/master/tests/Examples>?
09:39:36 <alexander__b> bitonic``: thanks
09:39:46 <bitonic``> alexander__b: first hit on google for “optparse-applicative” was the GitHub repo btw.
09:39:49 <enthropy> both have things going on in the background which can be ignored in normal usage
09:39:54 <alexander__b> bitonic``: I am in the github repo
09:40:13 <bitonic> alexander__b: and you didn’t find those examples?
09:40:28 <bitonic> they’re quite hard to miss
09:40:58 <alexander__b> I did not expect examples to be in "tests". that's traditionally in languages I use where tests go.
09:40:58 <alexander__b> not if you do not go into tests
09:41:11 <logicalguy> Hi, I have a question about the "read" typeclass
09:41:47 <logicalguy> can we have nested read statements?
09:41:54 <bitonic> alexander__b: something testing a program will be an example of usage for that program
09:42:00 <bitonic> so yeah in the future I’d look there :P
09:43:04 <alexander__b> bitonic: tests in tdd are usually not examples for users, but complicated and ugly perl or lisp things that make sure edge cases are respected. duly noted however.
09:43:04 <geekosaur> that question is wrong. (read statement?!)
09:43:13 <kartoffelbrei> enthropy: well, at least when you use the implicit interface is impure and it does some things which require ghc not to share some variables. thus you have write a {-# OPTIONS_GHC -fno-cse #-}, which is sacry enough for me.
09:44:00 <logicalguy> for example, > read "['T', 'r', 'u', 'e']" :: [Char] evaluates to "True"
09:45:00 <logicalguy> but > read [ read "['T', 'r', 'u', 'e']" :: [Char] ] :: Bool throws up an error
09:45:12 <kartoffelbrei> oh god, just what am i typing?
09:45:49 <joehillen> So I recently discovered a trick where you can generate a list of datatypes by deriving bounded and enum https://github.com/aristidb/http-types/blob/master/Network/HTTP/Types/Method.hs#L42, but when I try to do it for my own data type it fails because I think it's a GADT, https://gist.github.com/6063959. Yes I tried adding GenericNewTypeDeriving.
09:46:38 <geekosaur> logicalguy, the fact that you're calling it a statement instead of a function already indicates you don't have a good understanding of what's going on. your attempt at nesting them is even more confused
09:47:02 <logicalguy> oh, stope being so pedantic about my choice of words, geekosaur
09:47:52 <enthropy> kartoffelbrei: in practice? I might be I have not run into issues since I've only used the help annotation.
09:48:47 <valdyn> logicalguy: in which context could it make sense to apply read to the return value of the inner read?
09:49:28 <geekosaur> logicalguy, it's not pointless pedanticism
09:49:45 <logicalguy> valdyn, it says that all functions are expressions because they evaluate to some kind of value, so just for the sake of experimenting, it should work.
09:50:09 <logicalguy> yes, geekosaur, thank you for pointing out my wrong choice of words
09:50:11 <geekosaur> unless the pointless part supposed to be that there's no point to understanding
09:50:11 <kartoffelbrei> enthropy: well, i never really used it myself (except for trivial hello world type experiments), because reading stuff like that in the documentation makes me switch to another package.
09:50:44 <geekosaur> > (read . read) "['T','r','u','e']" :: Bool
09:51:04 <benmachine> lambdabot is missing
09:51:05 <kappabot>   True
09:51:22 <geekosaur> kappabot was supposed to be here though.. there it is
09:52:42 <sweetbomber> like challenges? take a look at this: http://www.youtube.com/watch?v=WWi3ZTEk0S0
09:52:45 <logicalguy> so what does (read . read) mean?
09:52:46 <benmachine> logicalguy: fundamentally the problem with your nested read was that you were doing read [x] for some x :: [Char], and that's a type error
09:53:29 <geekosaur> apply the output of the first read as the input of the second
09:53:38 <benmachine> logicalguy: you were putting read "['T', 'r', 'u', 'e']" as the single element of a list, and then trying to read *that*
09:53:45 <geekosaur> (f . g) x = f (g x)
09:53:47 <benmachine> but you can only read [Char] not [[Char]]
09:54:30 <logicalguy> wait a minute, I realized what I did wrong, I used the wrong brackets, the outer square brackets should actually have been ordinary brackets
09:54:48 * josephle is trying to think of a practical way to use (read . read)
09:54:50 <logicalguy> > read ( read "['T', 'r', 'u', 'e']" :: [Char] ) :: Bool
09:54:53 <kappabot>   True
09:55:20 <geekosaur> right
09:55:43 <josephle> actually, won't the first read in (read . read) end up being no different from id?
09:55:52 <logicalguy> thanks, guys, really silly of me, but I'm glad I actually tried it, I found a new error that I'm capable of doing
09:55:57 <josephle> (first being first applied)
09:56:40 <aristid> > show . show . show $ True
09:56:44 <kappabot>   "\"\\\"True\\\"\""
09:56:44 <logicalguy> so does this dot notation work for any set of functions?
09:56:57 <ParahSailin> :ty (.)
09:57:07 <aristid> logicalguy: the parameter of one has to fit the return type of the other.
09:57:11 <ParahSailin> @ty (.)
09:57:13 <kappabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:57:24 <logicalguy> yes, assuming I get that right, aristid
09:57:43 <benmachine> hmm
09:58:22 <benmachine> josephle: read :: String -> String is not the identity
09:58:44 <benmachine> josephle: it will expect its argument to begin and end with "s and interpret escape sequences and stuff
09:58:51 <josephle> ooh
09:58:54 <josephle> that is right
10:00:14 <logicalguy> thanks again, I am out of here.
10:00:15 <josephle> and if you embedd \" in the string, then (read . read) !== read
10:00:19 <josephle> okay, got it
10:09:10 <carter> wheres lambda bot? :(
10:09:40 <benmachine> carter: kappabot is serving as a temporary backup
10:09:41 <aristid> kappabot is here to replace him temporarily:)
10:09:50 <carter> k
10:10:00 <carter> Gracenotes
10:10:08 <carter> @hackage llvm-general
10:10:08 <kappabot> http://hackage.haskell.org/package/llvm-general
10:13:24 <joeyh> anyone know of a module that provides access to sync(2)?
10:13:31 <joeyh> I suppose it's just about trivial to FFI it by hand
10:15:27 <jophish> yo yo yo
10:16:17 <geekosaur> sync(2) is still useful?
10:16:34 <joeyh> arguable
10:21:17 <kartlos> is a Functor in Python the same thing as in Haskell? I keep coming across various strange explanations of Functors in python, that don't even mention fmap...
10:21:50 <FreeFull> I have no idea what functors are in Python
10:21:53 <shachaf> Probably not. People use that word to mean way too many things.
10:22:02 <shachaf> I also don't think it's a standard word in Python.
10:22:04 <Gracenotes> usually functors used in more imperative languages refer to function objects
10:22:22 <Gracenotes> it is a somewhat official term in C++, so I assume you might be dealing with C++ people
10:22:24 <shachaf> "more imperative languages" meaning C++?
10:22:27 <kartlos> http://my.safaribooksonline.com/book/programming/python/9780321637727/functors/ch09
10:22:34 <FreeFull> Yeah, seems to be function objects, rather than mathematical functors
10:22:54 <kartlos> why are they named functors, if they're not?
10:23:00 <shachaf> That's how it is.
10:23:14 <Gracenotes> well... it either returns a function or an object with __call__ implemented
10:23:20 <joehillen> "In computer science a functor is an object that can be called as though it were a function, so in Python terms a functor is just another kind of function object. Any class that has a __call__() special method is a functor."
10:23:21 <Gracenotes> so it is literally a callable object
10:23:29 <shachaf> Don't ask #haskell why other people call things names.
10:23:36 <joehillen> yeah, means something else in Python
10:23:49 <kartlos> shachaf: sorry about that
10:24:03 <shachaf> I'm not saying you should apologize, just that it won't do you any good.
10:25:15 <joehillen> did anyone else watch the monads talk by the javascript guy? It was like a "you rage, you lose" video
10:25:20 <Gracenotes> not in the new world order where every channel is #haskell
10:28:04 <kartlos> so is it fair to say that the definition of Funtor is the same as in science i.e. category theory? and that all other definitions are simply made up by programming language designers?
10:28:23 <kartlos> I mean the Haskell definition of Functor
10:28:28 <shachaf> Category theory is not science.
10:28:36 <kartlos> art?
10:28:40 <shachaf> Anyway, it's not as if that definition *isn't* made up. They're all made up.
10:28:41 <benmachine> no, mathematics
10:28:56 <joehillen> machematics != science?
10:29:09 <Gracenotes> category theory is mathematics is science
10:29:14 <benmachine> joehillen: I would say experiments form a key part of science, they don't form a key part of CT
10:29:16 <shachaf> OK, ignore everything I said about science.
10:29:31 <shachaf> Haskell's Functor is more or less an particular kind of categorical functor.
10:29:45 <Gracenotes> Though mathematics is science only because natural scientists feel bad for mathematicians. *duck*
10:30:33 <finity> Functor is for endofunctors on Hask, the category of Haskell types (correct me if I'm wrong here)
10:30:47 <benmachine> finity: not even all the endofunctors on Hask
10:31:13 <benmachine> it's true that all Haskell Functors are (more-or-less) category-theory functors, but there are lots of category-theory functors that Haskell probably can't express very well
10:32:42 <kartlos> is there a short explanation as to why they are "more-or-less" :)
10:34:21 <alexander__b> monochrom: is it frowned upon to not use optparse-applicative? my use scenario is just... if no args: do this. else: do this instead. it seems very overkill.
10:37:27 <alexander__b> does haskell have anything equivalent of python's """? for those not familiar with it, it lets you put in a bunch of text and break lines to keep within 78 columns without having to do "blah blah " \ + [newline] "blah blah"
10:37:43 <alexander__b> I want to print a help message to a user, and it will be multiline.
10:39:01 <FreeFull> alexander__b: No, but you could do something like     unlines ["This is","a help","message."]  with appropriate linebreaks
10:39:15 <alexander__b> FreeFull: ugh. thanks.
10:39:23 <bscarlet> alexander__b, FreeFull: yes. Hang on.
10:39:29 <geekosaur> alexander__b, there's string gaps
10:39:35 <enthropy> you can write the string with continuations like \    "firstline\<enter>   \second line\<enter>   \third line"
10:39:58 <geekosaur> there's also something on hackage which lets you do something similar to shell heredocs via quasiquotes, IIRC
10:40:01 <enthropy> where <enter> is actually putting it on a second line
10:40:03 <FreeFull> Ah, yeah, if you write something like   "abc\      \def" it becoes "abcdef"
10:40:11 <FreeFull> And you can have any whitespace in the gap
10:40:30 <alexander__b> yes it works
10:40:34 <FreeFull> It's not quite """ though
10:40:36 <alexander__b> but vim is going crazy
10:40:46 <alexander__b> it thinks the continuation lines are lambdas
10:41:35 <alexander__b> and it thinks the first and last lines are strings that're opened and not closed
10:42:05 * hackagebot unm-hip 0.1.1.4 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.1.1.4 (JosephCollard)
10:42:12 <geekosaur> newsflash, editor syntax hacks still are dumb as rocks
10:43:40 <bscarlet> geekosaur: some editors are smarter than others, but it seems like a hard problem to me. An editor would have to handle code mid-edit, when it's invalid. You'd need very good error recovery.
10:44:20 <geekosaur> exactly
10:44:52 <alexander__b> my current solution (IDK if it's very idiomatic) is to have a function that returns a [String], then in the function that prints the help I do putStrLn (unlines help).
10:45:57 <alexander__b> help being the function that returns a [String]
10:46:36 <c_wraith> alexander__b: that's actually quite idiomatic - you're separating generating the help message from printing it.
10:46:57 * alexander__b is proud of himself
10:47:38 <alexander__b> now I only need a neater way to print all my supported operators...
10:47:41 <bscarlet> alexander__b: personally I'd put the unlines inside "help" - no need to let your editor-driven choice of idiom bleed into your function types.
10:48:32 <alexander__b> bscarlet: maybe. depends on if I want to use only parts of help in the future or not.
10:49:25 <alexander__b> BTW if anyone have ideas on how to print supported ops, let me know. the ops are stored like this: http://lpaste.net/91152
10:49:26 <bscarlet> alexander__b: sure
10:50:27 <alexander__b> operators should probably be stored outside of the ops function... with annotations for the help... but I'm not sure.
10:52:05 * hackagebot unm-hip 0.1.1.5 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.1.1.5 (JosephCollard)
10:55:42 <nabilhassein> is base version 4.6.* compatible with ghc 7.4?
10:56:00 <nabilhassein> i need to use a function that isn't in 4.5, which is what i have, along with ghc 7.4
10:56:08 <nabilhassein> from Control.Concurrent
10:56:19 <c_wraith> what function?
10:56:24 <nabilhassein> forkFinally
10:56:51 <geekosaur> nabilhassein, base can't be upgraded, it's tied to the runtime and the compiler
10:57:06 <c_wraith> realistically, your only options are only work in higher versions of GHC, or implement it yourself
10:57:23 <nabilhassein> okay. i am on ubuntu. what is the fastest way to get from 7.4 to 7.6?
10:57:33 <c_wraith> install it from the generic linux binaries
10:57:53 <nabilhassein> is there a PPA?
10:58:07 <monochrom> consider my http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
10:58:17 <c_wraith> Why would you want that? the debian packaging of GHC is terrible.
10:58:54 <nabilhassein> c_wraith: haha, i've been starting to think the same thing. apt-get install is usually the least hassle but not for haskell it seems
11:01:06 <`Jake`> When I write a == a, a will be fully evaluated, right?
11:01:34 <geekosaur> depends on the definition of (==) for the type in question
11:01:42 <monochrom> depends on who wrote the Eq instance. but most instances are
11:01:44 <geekosaur> *usually* that would be true
11:01:49 <`Jake`> deriving for some custom types
11:01:56 <monochrom> however, exceptions include for example CReal
11:02:13 <c_wraith> deriving just dispatches to Eq instances for contained values
11:02:26 <c_wraith> So if all of them fully evaluate, so does the derived instance
11:02:27 <monochrom> yeah, it only postpones the question
11:02:44 <`Jake`> It's an Array
11:03:01 <c_wraith> So it matters what types it uses as indices and values
11:03:05 <startling> you could theoretically write Just _ == Just _ = True.
11:03:17 <lispy> There is always DeepSeq (and friends) if you need to evaluate it
11:03:43 <`Jake`> (Int,Int) as Indices, elements are eventually something along the lines of A = B | C
11:03:50 <monochrom> I'm sorry if the correct answer is more complex and surprising than your wanted answer.
11:03:57 <`Jake`> that's ok
11:04:17 <`Jake`> s/A = B | C/data A = B | C/
11:05:39 <monochrom> you should write an NFData instance for full evaluation. that's what NFData is for.
11:05:44 <`Jake`> ok
11:05:56 <`Jake`> after that just deepseq, right?
11:06:12 <monochrom> I forgot the exact names of the functions.
11:06:29 <johnw> i think rnf is the name of the instance function
11:06:34 <alexander__b> if I have [("foo","the foo"), ("bar", "the bar")] -- how do I turn it into the string: "foo\t the foo\n bar\t the bar"?
11:06:51 <`Jake`> (By the way, it's just for debugging. I don't actually need it to be strict when it's finished)
11:07:00 <`Jake`> ok, thanks
11:10:39 <b2coutts> alexander__b: do you know how to turn ("foo","the foo") into "foo\t the foo\n"?
11:10:41 <geekosaur> > let { hlepy = unlines . map hlepy'; hlepy' (k,v) = k ++ '\t':v } in hlepy [("foo","the foo"), ("bar", "the bar")]
11:11:09 <kappabot>   mueval-core: Time limit exceeded
11:11:14 <geekosaur> bah
11:11:36 <alexander__b> b2coutts: I would use the function whose name I don't remember with fst and snd
11:12:24 <b2coutts> alexander__b: you could then map that function over the list of pairs
11:12:29 <b2coutts> :t concat
11:12:36 <alexander__b> then I can map that to the list
11:12:40 <b2coutts> right
11:12:54 <kappabot> forall a. [[a]] -> [a]
11:13:02 <b2coutts> lambdabot seems to not be answering me, but you can use concat :: [[a]] -> [a] to combine them after
11:13:43 <alexander__b> the thing I was doing, lol, was just fst tuple ++ "\t" ++ snd tuple ++ "\n"
11:14:14 <startling> that's not bad.
11:14:52 <alexander__b> so I did map (\x -> fst x ++ "\t" ++ snd x ++ "\n") a
11:14:57 <alexander__b> there a was a tuple
11:15:01 <b2coutts> alexander__b: that's how I'd do it anyway
11:15:21 <b2coutts> though, depending on the situation, it may be that you can pattern match for the tuple
11:15:45 <b2coutts> i.e., if you're doing something like f tuple = fst tuple ++ ..., instead to f (a,b) = a ++ ...
11:15:59 <b2coutts> s/to/do
11:16:01 <`Jake`> I'd use pattern mathcing in the lambda, but I suppose that's up to preference
11:16:26 <alexander__b> that's probably nicer
11:16:38 <k0ral_> Hello, is there a type constructor T such that T a b = (a,b) ?
11:16:39 <alexander__b> http://lpaste.net/91157 what I did
11:16:51 <startling> k0ral_, (,)
11:17:03 <alexander__b> supportedOps is a function that returns a tuple with ("an operator", "the description of the operator")
11:17:23 <k0ral_> startling: as far as I tried, (,) is interpreted as a -> b -> (a,b) (with TupleSection extension)
11:17:35 <k0ral_> I'm looking for the type constructor, of kind * -> * -> *
11:17:43 <pooya72> hi guys! quick noob question how can your foldr [IO Int]? I'm assuming I need to apply something like liftIO to IO int
11:17:56 <`Jake`> alexander__b: you have "\t" twice in the lpaste. I suppose the second one should be "\n"?
11:18:06 <alexander__b> `Jake`: oh. yes.
11:18:19 <monochrom> foldr [IO Int] for what purpose? "the solution depends on the problem"
11:18:20 <startling> k0ral_, that's presumably why TupleSections is a language extension and not part of the language.
11:18:21 <alexander__b> I did it right in ghci but not in the src. :-P
11:18:23 <Clint> pooya72: how did you get [IO Int]?
11:18:47 <alexander__b> actually, I use putStrLn, so I don't need the \n at all
11:18:54 <startling> k0ral_: (without it, :k (,) = (,) :: * -> * -> *)
11:18:56 <alexander__b> just fst x ++ "\t" ++ snd x
11:19:21 <k0ral_> startling: oh, right
11:19:35 <pooya72> Clint: read a file then (read output :: Int)
11:19:39 <alexander__b> rewrote it to use pattern matching though because it's nicer IMO
11:20:25 <pooya72> Clint: Here I applied that to multiple files to get [IO Int]
11:21:27 <monochrom> consider "sequence"
11:21:30 <Clint> :t mapM_
11:21:35 <kappabot> on the commandline: Warning:
11:21:36 <kappabot>     -fglasgow-exts is deprecated: Use individual extensions instead
11:21:36 <kappabot> State/L.hs:95:18:
11:21:44 <Clint> uh-huh
11:22:16 <`Jake`> :t forM_
11:22:20 <kappabot> on the commandline: Warning:
11:22:20 <kappabot>     -fglasgow-exts is deprecated: Use individual extensions instead
11:22:20 <kappabot> State/L.hs:95:18:
11:22:30 * geekosaur *eyeroll* at kappabot
11:22:52 <monochrom> consider @type
11:23:17 <tulcod> can you compile template haskell to regular haskell?
11:23:28 <pooya72> Clint: Basically I'm trying to add two IO Int together
11:23:43 <Gracenotes> perhaps it is the only thing you can compile it to
11:24:16 <geekosaur> @hackage zeroth
11:24:17 <kappabot> http://hackage.haskell.org/package/zeroth
11:24:24 <quchen> tulcod: That's the whole idea behind TH. It's basically a DSL that can be used to generate Haskell using Haskell.
11:24:36 <geekosaur> ...but it only goes so far
11:25:08 <tulcod> quchen: yeah, but in a typical workflow you don't get to see the intermediate regular haskell. you only see the end product (ie. binary)
11:25:47 <Clint> pooya72: so you want the equivalent of do a <- readFile "blah"; b <- readFile "guh"; return $ (read a :: Int) + (read b :: Int) ?
11:25:48 <quchen> tulcod: You can have a look at the generated code by passing -ddump-splices
11:25:56 <tulcod> quchen: thanks :)
11:27:15 <pooya72> Clint: yes, but I want to apply: foldr (+)  0 [IO Int] to be exact
11:27:20 <`Jake`> :t mapM_ putStrLn $ return "a"
11:27:21 <kappabot> IO ()
11:28:14 <quchen> pooya72: You can add two IOs' contents together using `liftA2 (+)`.
11:28:19 <c_wraith> `Jake`: do you know what that particular return is doing?
11:28:34 <`Jake`> "a" => ["a"] i suppose
11:28:37 <c_wraith> yep
11:28:42 <`Jake`> writing return is faster than writing []
11:28:48 <`Jake`> maybe
11:28:51 <c_wraith> depending on keyboard layout, it could be
11:29:01 <`Jake`> I use american, actually, so it's probably not
11:30:31 <monochrom> if you use a speech recognizer, "return x" is faster to speak than "left bracket x right bracket"
11:31:12 <alexander__b> @source lookup
11:31:12 <kappabot> lookup not available
11:31:30 <alexander__b> uhm ok where can I find the source for lookup?
11:31:46 <quchen> hoogle "lookup", click the link, click on source
11:32:06 * hackagebot module-management 0.15 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.15 (DavidFox)
11:32:28 <geekosaur> actually...
11:32:33 <geekosaur> @src lookup
11:32:33 <kappabot> lookup _key []          =  Nothing
11:32:33 <kappabot> lookup  key ((x,y):xys) | key == x  = Just y
11:32:33 <kappabot>                         | otherwise = lookup key xys
11:32:46 <alexander__b> ah
11:32:50 <quchen> Or if you're lucky it's in Lambdabot's database. :-)
11:33:04 <alexander__b> ty
11:33:21 <geekosaur> "@source" I don't know how kappabot parsed it, there's no way to check its edit correction
11:34:49 <pooya72> quchen: trying to use liftA2, don't think i'm doing it right. Should it be like: liftA2 (+) [IO int] +
11:34:52 <pooya72> ?
11:36:44 <joehillen> @ty lift
11:36:45 <kappabot>     Not in scope: `lift'
11:36:46 <kappabot>     Perhaps you meant one of these:
11:36:46 <kappabot>       `liftM' (imported from Control.Monad),
11:36:56 <k00mi> pooya72: did you look at the type of liftA2?
11:37:00 <quchen> pooya72: Ah, a list of IO Int, not just two IO Int?
11:37:07 <quchen> Then foldM is what you need.
11:37:07 <mr-> > liftA2 (+) (Just 3) (Just 4)
11:37:10 <kappabot>   Just 7
11:37:14 <alexander__b> so I just implemented a lookup3 based on lookup. it looks up key in (x,y,z) and returns z. is there already a way to do this? my function works, but I kind of assume there's a better way
11:37:24 <cdk> :t fmap sum . sequence -- pooya72
11:37:25 <kappabot> forall (f :: * -> *) b. (Monad f, Functor f, Num b) => [f b] -> f b
11:37:34 <tac> alexander__b: what does the third thing do in the tuple?
11:37:37 <pooya72> quchen: cdk: thanks let me try it
11:37:40 <tac> err
11:37:44 <tac> alexander__b: the second thing rather
11:37:52 <quchen> pooya72: Nevermind, the sequence version is far better. Ignore what I said.
11:37:58 <quchen> Silly me. :s
11:38:24 <pooya72> quchen: ok let's see what happens :)
11:38:43 <alexander__b> tac: well the thing is, I'll probably want a function like this: I have [(x,y,z)]. I want to lookup based on key=x. then I want to return (y,z).
11:39:05 <alexander__b> tac: and then do fst theresult or snd theresult, as I want them in different contexts
11:39:08 <tac> @type lookup
11:39:09 <kappabot> forall a b. Eq a => a -> [(a, b)] -> Maybe b
11:39:17 <alexander__b> lookup takes [(a,b)]
11:39:21 <alexander__b> I have [(a,b,c,)]
11:39:24 <tac> You might want to write a function to "wrap up" the (x, y, z) into (x, (y, z))
11:39:31 <alexander__b> that's an idea
11:39:37 <cdk> alexander__b: why not use Data.Map
11:39:46 <tac> @type lookup . (\(x, y, z) -> (x, (y, z)))
11:39:48 <kappabot> forall b t t1 t2. (Eq t, Eq t1, Eq t2) => (t, t1, t2) -> [((t, (t1, t2)), b)] -> Maybe b
11:39:48 <alexander__b> cdk: does that support (x,y,z) the way I want to?
11:39:57 <alexander__b> tac: I like that
11:39:59 <tac> oops
11:40:03 <tac> not quite but close
11:40:06 <cdk> it supports Map x (y,z)
11:40:14 <tac> @type flip lookup . (\(x, y, z) -> (x, (y, z)))
11:40:15 <kappabot>     Couldn't match expected type `[(a0, b0)]'
11:40:16 <kappabot>                 with actual type `(t0, (t1, t2))'
11:40:16 <kappabot>     In the expression: (x, (y, z))
11:40:25 <tac> whatever, you can do it if you play with it :P
11:40:26 <cdk> where x is the lookup key, and (y,z) is the stored value
11:40:50 <tswett> @type lookup . \(x, (y, z)) -> (x, y, z)
11:40:59 <alexander__b> tac: hehe
11:40:59 <alexander__b> cdk: that sounds like what I want really
11:41:03 <kappabot> forall b t t1 t2. (Eq t, Eq t1, Eq t2) => (t, (t1, t2)) -> [((t, t1, t2), b)] -> Maybe b
11:41:12 <tswett> kappabot: ¿por qué no me amas?
11:41:21 <tswett> Oh, there we go.
11:41:24 <cdk> plus, your lookups will be O(log n) instead of O(n)
11:41:40 <alexander__b> cdk: do you have any links/tips on how this works? IDR LYAH using (x (y,z)) in map
11:42:00 <alexander__b> though I guess it's like just the same as using (x,y)
11:42:03 <cdk> @where Data.Map
11:42:03 <kappabot> I know nothing about data.map.
11:42:07 <cdk> dang
11:42:25 <cdk> @type Data.Map.fromList
11:42:26 <kappabot> forall k a. Ord k => [(k, a)] -> containers-0.5.0.0:Data.Map.Base.Map k a
11:42:55 <cdk> alexander__b: just look at Data.Map on hackage, in the containers package
11:44:22 <alexander__b> is there a point though if I just convert my function that returns (x,y,z)s to a function that returns (x,(y,z))s?
11:44:46 <tswett> alexander__b: yeah, if you did htat, you could use lookup.
11:45:11 <tswett> alexander__b: I'm pretty sure cdk is suggesting that you use Data.Map *instead* of using a list of ordered pairs.
11:45:28 <cdk> Data.Map will have better performance, and provides lots of other usefull functions. If you dont care about performance, and you only need this lookup then a assoc. list might be fine
11:45:58 <cdk> useful, even
11:46:01 <alexander__b> tswett: yes but is there a point when I can just have (x,(y,z))?
11:46:23 <alexander__b> OK thanks
11:46:43 <alexander__b> oh wait lookup returns a Maybe... guess I have to change some more things in here, heh
11:47:24 <alexander__b> I have this delicious thing (which I *will* be changing: fromMaybe (error (unwords $ concat (["Unrecognised operator: "] : [op] : []))) (lookup op ops <|> numberP op)
11:47:45 <alexander__b> but now I need the fst of the lookup
11:48:31 <alexander__b> I guess maybe I need a complete rewrite.
11:49:10 <cdk> alexander__b: you arent using Maybe very idiomatically.
11:49:38 <cdk> the point is to avoid using "error", the Nothing case should be handled gracefully
11:50:14 <cdk> s/error/any runtime exception/
11:50:25 <alexander__b> cdk: baby steps :-P
11:50:25 <johnw> even better is to see if you can use types to avoid the possibility of an unrecognized operator
11:50:52 <johnw> move as much error checking to compile-time as you can
11:50:54 <Hafydd> baby-step semantics
11:51:09 <alexander__b> johnw: uhm it's input
11:51:16 <johnw> ah, I see
11:51:27 <cdk> alexander__b: yes, but you can see how unweidly that line of code became. i guarantee if you use Maybe correctly it will be simpler and more easily verified to be correct
11:51:34 <alexander__b> johnw: it's if people use the calculator with "2 2 lulz"
11:51:56 <johnw> then output an image of ceiling cat sternly rebuking them
11:52:07 <alexander__b> cdk: yes. I'm implementing it in this bain dramaged way first. then I will rewrite it. I think I'll learn more that way
11:53:55 <merijn> hmm, is it possible to add finalizers to haskell values?
11:54:11 <johnw> merijn: sure
11:54:23 <johnw> merijn: that's what ResourceT is all about, but you mean globally?
11:55:45 <merijn> johnw: ResourceT is more a bracket type of thing, right?
11:55:46 <johnw> it's like bracket, but solves the sequencing problem, plus you can remove finalizers at a later time
11:56:19 <merijn> Yeah, that;s exactly what I can't have as the value I want to finalize is being passed around between threads
11:56:27 <johnw> ah
11:56:28 <merijn> Else I would just implement my own bracket type thing
11:56:43 <johnw> well, in that case a ForeignPtr around a StablePtr could be used
11:57:07 <johnw> the StablePtr is to remove its from the purview of the GC
11:57:11 <johnw> and the ForeignPtr is to attach the finalizer
11:57:49 <johnw> then when the ForeignPtr is GC'd, you can manual "destruct" the StablePtr yourself
11:58:18 <merijn> hmm
11:58:39 <merijn> I guess, seems odd that they didn't extend the ForeignPtr finalizer machinery to other haskell values...
11:58:56 <johnw> didn't they?  by providing StablePtr? :)
11:59:19 <merijn> StablePtr is rather costly
11:59:25 <merijn> To make, that is
11:59:27 <johnw> maybe there's an even lower-level way to do what you want, but I haven't learn it yet
11:59:40 <merijn> I'll check how ForeignPtr is implemented
11:59:52 <johnw> I think it's just a Ptr+ a function
12:00:00 <johnw> though the function may be a FunPtr
12:01:46 <merijn> hmm, are the Foreign.ForeignPtr docs on hackage broken for anyone else?
12:01:55 <johnw> go to Foreign.ForeignPtr.Safe
12:02:16 <johnw> the links are broken for me too
12:05:17 <merijn> Blah, GHC.ForeignPtr doesn't have any docs >.>
12:09:03 <monochrom> you're meant to use Foreign.ForeignPtr
12:09:44 <merijn> monochrom: I'm trying to figure out how that is implemented
12:10:07 <merijn> (or more specifically, how finalizers for foreign pointers are implemented)
12:10:33 <merijn> Don't touch my rabbithole! :<
12:10:52 <monochrom> ok, then read more source code :)
12:11:09 <merijn> hmm, looks like they make use of the weak ref stuff, which I guessed but wasn't sure
12:14:07 <merijn> hmm, according to System.Mem.Weak it's not very safe to add finalizer to non primitive types, I guess I could just add an IORef to my data type and add a finalizer to the IORef to clean up
12:30:15 <tulcod> can i just thank all of you guys and girls for writing such a useful programming language that doesn't require the sacrifice of a virgin on each compilation
12:30:34 <bscarlet> wait. you're not paying?
12:30:55 <b2coutts> did you even read the man page??
12:31:17 <bscarlet> now you're going to need some mistletoe and a stone circle.
12:33:33 <banister`sleep> bscarlet: what's the intuition to 'get' the usefulness of monads (more than just reading understanding the theoretical stuff)
12:33:36 <banister`sleep> ?
12:34:20 <tac> banister`sleep: Probably using them, like anything else you want to build an intuition for.
12:34:32 <c_wraith> banister`sleep: the useful thing is that they work.
12:34:48 <bflyblue> hi all, i'm relatively new to haskell and having trouble using inner/outer monads - has anyone got a bit of time to help a noob?
12:35:05 <tulcod> bflyblue: do you understand monads?
12:35:05 <tac> sure, what's your question bflyblue
12:35:28 <banister`sleep> c_wraith: so when you use monads in the 'do' syntax, it looks as if you're dealing with just simple values, but there's really a bunch of other crap going on behind the scenes?
12:35:31 <bflyblue> i think i understand the basics - but not sure how lifting works really
12:35:48 <tulcod> banister`sleep: honestly, it only really clicks when you try to write code and discover it's rather a waste to express certain constructs without them
12:35:55 <bflyblue> i'm trying to use zeromq and leveldb, both have monadic interfaces
12:35:57 <banister`sleep> c_wraith: how important is the do syntax, do you think people would use them if the do syntax didnt exist?
12:35:58 <aristid> banister`sleep: actually there's not much going on there.
12:36:10 <bflyblue> but when one is nested in the other, i get horribly confused
12:36:17 <joehillen> banister`sleep: the moment that monads made sense to me was when I wrote a list comprihension the reqular way, then using `do` and `guard`, then using `=>>` (bind) notation
12:36:20 <htau> bflybule: do you have some code you want us to look at?
12:36:21 <joehillen> List is a monad
12:36:46 <johnw> I think you mean >>=
12:36:47 <bflyblue> i do - can i PM you?
12:36:53 <joehillen> yeah
12:36:55 <htau> just paste it
12:37:03 <htau> http://lpaste.net/new/haskell
12:37:03 <shachaf> Don't paste code in the channel.
12:37:05 <shachaf> See the topic.
12:37:17 <banister`sleep> joehillen: im still confused by the 'reader' monad, the idea of functions being functors, applicatives and finally monads (in the form of 'reader') does my head in
12:37:23 <bflyblue> aah right - lemme do gist then.. one sec
12:37:36 <pooya72> member:quchen: cdk: finally got it. fmap sum sequence[IO int]
12:37:45 <pooya72> oh sorry no
12:37:50 <tulcod> banister`sleep: forget about applicatives, functors and all that. just try to work your head around monads.
12:37:51 <shachaf> pooya72: You keep writing that and that notation doesn't make any sense.
12:38:10 <joehillen> banister`sleep: I still don't understand Reader, so I can't help you there, but it will probably help to understand monad in general first
12:38:11 <pooya72> fmap sum (sequence [IO Int])
12:38:15 <shachaf> [IO int] is a type. (You probably meant [IO Int], with a capital i, but whatever.)
12:38:25 <banister`sleep> joehillen: i think i do undersatnd monads aside from that, just not intuitively ;)
12:38:28 <tulcod> banister`sleep: hint: try to write some code, eg. IO or list operations, without monads
12:38:31 <quchen> 20:37 <cdk> :t fmap sum . sequence -- pooya72
12:38:33 <johnw> banister`sleep: the function functor lets you "map" over the results of a function.  it's only hard to think about if you consider functors to be containers
12:38:33 <banister`sleep> so..for 'some' definition of undersatnd ;)
12:38:38 <pooya72> shachaf: yeah IO Int]
12:38:48 <nabilhassein> what is the most straightforward way to get an int into a bytestring?
12:38:49 <shachaf> pooya72: It's just confusing to say (sequence [IO Int]). :-)
12:38:54 <nabilhassein> converting to Word8 first is fine
12:39:01 <shachaf> One is a type and the other is a value.
12:39:03 <joehillen> banister`sleep: try the list comprehension thing, it will help I promise
12:39:08 <banister`sleep> johnw: well it's more than functions are part of the definition of functors, so it hints at an infinite descent for me, but it's clearly not
12:39:14 <banister`sleep> more that*
12:39:28 <tulcod> nabilhassein: what do you mean "get an int into a bytestring"? get the physical representation of a Word32 in memory?
12:39:44 <nabilhassein> tulcod: i think yes
12:39:46 <banister`sleep> johnw: so the fact that functions are necessary for functors, and functions themselves are functors..
12:39:53 <nabilhassein> if the int is I need a \NUL character
12:39:57 <nabilhassein> if the int is 0
12:39:58 <nabilhassein> sorry
12:40:14 <bflyblue> https://gist.github.com/bflyblue/6a3c4f73bc51b3db9f9b
12:40:19 <nabilhassein> if it's 33 it should be Chunk "!" because ASCII 33 is !, etc
12:40:22 <pooya72> quchen: I couldn't get that to work
12:40:26 <shachaf> banister`sleep: "Functor" is a description. If I say "Foo is a(n instance of) Functor" that doesn't change anything about what Foo is.
12:40:29 <bflyblue> i know i need to do something to make tyhe last line work, just not sure what
12:40:36 <shachaf> It's not part of the definition. It's just a property Foo happens to have.
12:41:24 <tulcod> nabilhassein: wait, so you want to convert Ints to Chars?
12:41:26 <banister`sleep> shachaf: what was your first project in haskell that gave you an opportunity to properly grok it
12:41:45 <tulcod> nabilhassein: a Bytestring is just an abstract list of bytes - without any meaning
12:41:48 <joehillen> banister`sleep: A functor is a mapping between categories
12:41:52 <nabilhassein> tulcod: that's what I need
12:41:58 <shachaf> I don't know?
12:41:59 <nabilhassein> it's for sending over the wire as part of a network protocol
12:42:07 * hackagebot dsp 0.2.2 - Haskell Digital Signal Processing  http://hackage.haskell.org/package/dsp-0.2.2 (HenningThielemann)
12:42:10 <tulcod> nabilhassein: seems like Data.Char.chr is what you're looking for
12:42:49 <tulcod> nabilhassein: (if you want to convert to actual Chars, that is)
12:42:50 <nabilhassein> tulcod: and then how do I append a char to a bytestring?
12:42:58 <nabilhassein> nothing in Data.ByteString takes a Char as an argument
12:43:02 <tulcod> well no, you don't, that would be very wrong
12:43:12 <banister`sleep> johnw: ok, take the example of the Maybe functor, how is that a mapping between categories? what category to what other category?
12:43:23 <shachaf> nabilhassein: A ByteString is a sequence of bytes, not of characters.
12:43:32 <shachaf> nabilhassein: Maybe you want Data.Text instead?
12:43:34 <tulcod> nabilhassein: if you want to get the actual 4 bytes of an Int in little-endian or whatever, i don't know how you should do that
12:43:41 <nabilhassein> shachaf: right. I really just think I need a function Int -> Word8
12:43:47 <johnw> banister`sleep: the category of Haskell types to the sub-category of Haskell types where every type is a Maybe type
12:43:52 <nabilhassein> then I can just use Data.ByteString's API
12:43:52 <shachaf> nabilhassein: Which does what?
12:44:22 <shachaf> johnw: More relevantly, it's a functor from the category of Haskell types to the category of Haskell types. :-)
12:44:31 <tulcod> banister`sleep: seriously, forget about all the other terms, just try to see how a Monad helps you organize your code
12:44:39 <johnw> shachaf++
12:44:39 <startling> how is Const X a mapping between categories? (I guess it's the empty mapping?)
12:44:40 <shachaf> I mean, you can talk about that subcategory, but it's also just a plain old functor from Hask to Hask.
12:44:43 <tulcod> forget about categories, functors, comonads, whatever
12:45:05 <shachaf> startling: It maps every object to X and every arrow to id.
12:45:30 <nabilhassein> the protocol deals only with bytes, but clients interpret some of those bytes as strings with an explicit length-encoding. so i need to get the length of a bytestring and then cons it onto the beginning
12:45:31 <tac> startling: that would be a constant functor. (And not really "empty")
12:45:40 <joehillen> banister`sleep: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
12:45:42 <tac> An empty functor would go from an empty category to... nothing.
12:45:57 <joehillen> banister`sleep: read that about 3 or 4 times
12:45:58 <tac> rather, from an empty category to any other category, mapping the 0 things to nothing.
12:46:02 <htau> banister: I discovered the utility of the state monad when I tried to handle complex state explicitly with pure functions, the monad made my life simpler.
12:46:22 <startling> shachaf: ah
12:46:32 <nabilhassein> i'm just trying to avoid the temptation of toEnum
12:47:04 <nabilhassein> i'd rather not use a partial function but this simple conversion seems quite convoluted without it
12:47:30 <tulcod> nabilhassein: you could do a foreign ccall to hton, i think that's what you're looking for
12:47:54 <tulcod> nabilhassein: but that's not exactly a solution
12:48:25 <htau> bflyblue: was there an error message associated with that code?
12:48:30 <shachaf> I doubt a foreign ccall to hton is going to be the answer to whatever question you have.
12:49:40 <bflyblue> No instance for (MonadResource (ZMQ z)) arising from a use of `put'
12:50:00 <johnw> banister`sleep: before thinking about applicatives and monads too much, it's well worth your time to invest in a much deeper understanding of functors: since applicatives and monads are just functors with extra behavior
12:50:08 <bflyblue> at that point inside teh ZMQ monad, and need to be in the outer ResourseT monad for put to work
12:50:21 <nabilhassein> ugh not even toEnum works
12:50:33 <nabilhassein> because the ByteString's length returns an Int64, not a regular Int
12:51:12 <shachaf> nabilhassein: What is your actual goal, again?
12:51:32 <nabilhassein> I am writing a bittorrent client
12:51:41 <nabilhassein> the specification mandates that encoded strings must have a length prefix
12:51:57 <dcoutts> nabilhassein: fromIntegral is ok to convert the Int64 to an Int if you know it's less than 2^31
12:51:59 <nabilhassein> so i need to compute the length of a given string and then cons those bytes onto the beginning of the bytestring before i can send it over the wire
12:52:02 <banister`sleep> johnw: but functors seem so simple, they're just a thing that supports fmap, right? what's the deeper insight there?
12:52:29 <dcoutts> nabilhassein: only reason lazy Bytestring uses Int64 is that it's possible on 32bit machines to have lazy bytestrings that are larger than fits in memory
12:53:35 <shachaf> nabilhassein: You asked for a function :: Int -> Word8 earlier.
12:53:46 <nabilhassein> dcoutts: ah, that makes sense. but still, i've been persuaded (in a previous context) that Partial Functions are Bad so even though I could use that fact to get this working with toEnum, i'd still prefer a nicer way to get those bytes
12:53:46 <shachaf> It sounds like there's something fishy going on.
12:54:41 * monochrom shakes head
12:54:41 <dcoutts> nabilhassein: fromIntegral is the standard numeric conversion, I'm not sure why you'd want to use toEnum
12:54:41 <nabilhassein> shachaf: yes, i think that will work, because the ByteString API would let me cons it onto the ByteString
12:54:48 <nabilhassein> dcoutts: ah! I forgot fromIntegral! I haven't done much number-type-converting previously but I think that will work perfectly
12:54:50 <monochrom> how long is the length prefix itself?
12:55:04 <nabilhassein> i suppose it could be an arbitrary length but it's usually quite short
12:55:10 <nabilhassein> short enough to fit in one byte
12:55:22 <nabilhassein> hm actually it might always be one byte or less, i need to check the specification
12:55:27 <monochrom> huh? how does the receiver know how long is the length prefix?
12:55:50 <johnw> banister`sleep: the confusion you felt thinking about functions as functors is an example; that should be second nature to you if you really fathom functors.  Functors conceptually form the trunk of a very broad and deep tree.  Your understanding of the deeper branches will depend on how well you grasp the simple mapping of category to category (which in Haskell is always Hask -> Hask).  And Functor isn't just about fmap.  That's one
12:55:50 <johnw> half of what a functor does.  And then there are the functor laws, what they mean, and how to recognize functors which break them
12:55:51 <jfischoff> dcoutts: I have an interesting bug, when I use sandboxing in cabal. If the installation of add-sourced files is interrupted, I get into a state I can't get out of. Sound familiar?
12:55:57 <nabilhassein> monochrom: yes, that's exactly what just occurred to me. but there is always a colon between the prefix and the actual string so perhaps that is how?
12:56:34 <dcoutts> jfischoff: not familiar, I'd file a ticket with as much detail as you can
12:56:43 <dcoutts> jfischoff: I'd guess at some timestamp thing
12:57:08 * hackagebot hinotify 0.3.6 - Haskell binding to inotify  http://hackage.haskell.org/package/hinotify-0.3.6 (LennartKolmodin)
12:57:10 <htau> bflyblue: have you tried liftM?
12:57:12 <monochrom> well, I don't know the bittorrent protocol. but you're writing bittorrent software, so supposedly you already know?
12:57:15 <dcoutts> jfischoff: so you may be able to reveal more details by looking at or fiddling with file timestamps
12:57:25 <nabilhassein> monochrom: haha, not well. but fromIntegral worked perfectly
12:57:36 <jfischoff> dcoutts: okay. I'll try to get a minimum test case.
12:57:58 <nabilhassein> dcoutts: thanks for reminding me. slightly embarrassing to have forgotten
12:58:07 <monochrom> ok, FSVO of "worked". just remind me to not use your software
12:58:15 <johnw> banister`sleep: there are many great free resources that go into depth about various dimensions of the humble functor, some more closely related to what you'll experience and others less so.  The best thing I can recommend is reading combined with coding, to explore and test your understanding.  That's what I do.  I'm still grappling with a true mastery of functors
12:58:56 <nabilhassein> monochrom: haha, yes, i am far from a working version. but it is a very fun project
12:59:58 <bflyblue> yeah i've tried various lift functions including liftM, but i'm not understanding the errors i get back
13:02:56 <nabilhassein> hm so i am getting another error, in a previously working project, after upgrading from ghc 7.4.1 to 7.6.3:
13:03:08 <nabilhassein> Couldn't match expected type `BL.ByteString'
13:03:08 <nabilhassein>                 with actual type `bytestring-0.10.0.2:Data.ByteString.Lazy.Internal.ByteString'
13:03:08 <nabilhassein>  
13:03:27 <shachaf> It sounds like you have multiple versions of bytestring installed.
13:03:27 <nabilhassein> has anyone encountered similar errors?
13:03:35 <shachaf> I recommend not having that.
13:03:35 <monochrom> too many versions of bytestring. and unrelated to switching GHC version.
13:03:41 <nabilhassein> ah, okay
13:03:44 <htau> bflyblue: shouldn't the ZMQ.. be part of your monad transformer stack?
13:04:07 <nabilhassein> for this i want to use ghc-pkg unregister?
13:05:02 <pentace> nabilhassein: or hide
13:05:08 <bflyblue> is there something special i need to do to use monad transformer?
13:05:40 <bflyblue> the outer is a ResourceT so assume it's a transformer
13:05:51 <applicative> bflyblue: import Control.Monad.Trans.State ?
13:06:04 <applicative> oh ResourceT
13:06:45 <jfischoff> bflyblue: did you paste the code already?
13:06:56 <bflyblue> trying to use both a ResourceT (for leveldb) and ZMQ, don't mind which order but i can't get them to place nicely
13:07:08 <bflyblue> https://gist.github.com/bflyblue/6a3c4f73bc51b3db9f9b
13:07:23 <applicative> bflyblue: if its ResourceT IO ..., then you just write e.g. lift $ putStrLn "hello world"
13:08:00 <bflyblue> i got IO working fine using lift, but not ZMQ
13:08:32 <applicative> hm, dont  know this ZMQ thing, let me look
13:09:14 <applicative> runZMQ :: MonadIO m => (forall z. ZMQ z a) -> m a
13:09:38 <bflyblue> newtype ZMQ z a = ZMQ { _unzmq :: ReaderT ZMQEnv IO a }
13:10:33 <jfischoff> what is the type of "open"
13:11:10 <b2coutts> :t open
13:11:13 <kappabot> Not in scope: `open'
13:11:25 <bflyblue> open :: MonadIO m => FilePath -> Options -> m DB
13:11:51 <bflyblue> it's line 24 that's the issue
13:12:18 <bflyblue> need put to be in the outer 'resourcet' and not the zmq monad
13:12:26 <jfischoff> I was confused why had to be a ResourceT action … which it doesn't
13:12:32 <applicative> runZMQ blah if it typechecks will be in any monad that comes under monadIO.  and so with open ...
13:14:58 <applicative> i see nothing in this is commiting use to ResourceT ?
13:15:17 <jfischoff> likewise
13:15:31 <bflyblue> leveldb uses it to cleanup if there's an exception
13:15:54 <nabilhassein> i am trying to delete bytestring-0.10.0.2 since it seems that having both it and bytestring-0.10.2.0 is problematic
13:16:13 <nabilhassein> ghc-pkg unregister warns me that doing so will break many many packages
13:16:36 <applicative> ah put and maybe bind are ResourceT things
13:16:47 <applicative> ghc-pkg unregister what? nabilhassein
13:16:48 <shachaf> Unregister 0.10.2.0 instead.
13:17:21 <applicative> oh i see
13:17:33 <applicative> you want the one that came with your ghc and no other
13:17:46 <monochrom> the criterion is not "get rid of the older" or "get rid of the newer". misses the point. the criterion is "get rid of the one that didn't come with GHC"
13:17:53 <johnw> yes, in fact it's a good idea to "pin" bytestring in your ~/.cabal/config
13:18:16 <johnw> with a line like: constraint: bytestring installed
13:18:31 <jfischoff> johnw: no way!
13:18:32 <johnw> then you'll never get any upgrades for that package
13:18:41 <monochrom> "upgrades"
13:18:52 <johnw> see http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
13:18:59 <jfischoff> oh that's awesome
13:19:04 <johnw> under "Rectify Wrong Settings"
13:19:08 <johnw> that's what I use, and it's a life-saver
13:19:19 <monochrom> with cabal, there is no "upgrade". "upgrade" means replacements. there is no replacement. there is only adding more and more, piling higher and deeper
13:19:24 <jfischoff> unix should go there too, template haskell etc.
13:19:28 <johnw> yep
13:19:44 <johnw> they're all there
13:20:01 * jfischoff jonathan looks
13:20:01 <monochrom> thank you for choosing monochrom!
13:20:07 <johnw> thank you monochrom!
13:20:09 <jfischoff> monochrom++
13:20:19 <applicative> nabilhassein: did you do 'cabal install bytestring' at some point, or was it installed with something else?
13:20:24 <johnw> i actually switched to using the HP because of that page; makes it easier for me to verify that my packages will work for HP users
13:20:28 <shachaf> monochrom: Why would I ever choose anyone else?
13:20:43 <nabilhassein> applicative: i believe i did, yes
13:20:47 <monochrom> I don't know. but I thank you anyway! :)
13:21:09 <nabilhassein> but the advice that you all gave me was extremely helpful and everything now appears to be in order
13:21:23 <nabilhassein> thanks very much! and johnw, thanks for that link, i'll be reading through it soon
13:21:26 <roboguy_> bflyblue: can't you change the indentation?
13:21:28 <applicative> nabilhassein: oh awesome.
13:21:44 <bflyblue> change the indentation?
13:21:49 <applicative> nabilhassein: the system is fairly simple, but takes a little bumping around in ...
13:22:11 <roboguy_> bflyblue: so that the call to put is in the first do?
13:22:12 <dmwit> ?botsnack
13:22:12 <kappabot> :)
13:22:32 <nabilhassein> applicative: yeah, dependency management is quite an interesting problem. it's nice to be working on a hobby project like this, i move quite slowly but i have the time to learn about each thing i am doing
13:23:43 <bflyblue> i could to make it work for now, but next step is to export the leveldb via zeromq, so will definitely need both monads for that
13:34:33 <roboguy_> bflyblue: how about liftResourceT? that looks like it might be what you need
13:35:30 <roboguy_> except I guess ZMQ would need a MonadResource instance
13:36:15 <bflyblue> that's what i thought should work, but gives: No instance for (MonadResource (ZMQ z))
13:37:08 * hackagebot a50 0.5 - Compare genome assemblies  http://hackage.haskell.org/package/a50-0.5 (KetilMalde)
13:38:06 <hpaste> applicative pasted “zmq attempt” at http://lpaste.net/91158
13:38:25 <applicative> bflyblue: did you figure it out? this makes sense ^^^
13:39:11 <applicative> the thing I think is to keep the zmq stuff together then exit with runZMQ taking whatever you returned (here nothing)
13:39:56 <applicative> or that's one way, the zmq package doesn't know about resourcet it seems
13:40:14 <bflyblue> next step is to allow requests via zeromq to put/get stuff from leveldb, doesn't seem right to destroy zmq context every time i want to use the database
13:41:01 <banister`sleep> applicative: do you think you'll get this book? http://www.amazon.com/Parallel-Concurrent-Programming-Haskell-ebook/dp/B00DWJ1BIG/
13:41:14 <johnw> i just got it
13:41:34 <joehillen> get the o'reilly version, no drm
13:41:41 <luite> is there also a free download?
13:42:09 <thoughtpolice> luite: yes, you can get PDF or deadtree from O'Reilly, but they're separate
13:42:09 <applicative> banister`sleep: yes!
13:42:11 <thoughtpolice> you can get ebook, deadtree, or ebook+deadtree combo
13:42:36 <applicative> oh wait, maybe I have the wrong zmq library bflyblue, are you using this zmq-conduit?
13:42:42 <thoughtpolice> for $30 it's absolutely worth it, it's a fantastic book from what i've read so far.
13:43:08 <bflyblue> oh no,
13:43:10 <luite> thoughtpolice: oh but the free online version doesn'tseem to have a download option
13:43:14 <bflyblue> "leveldb-haskell"
13:43:20 <applicative> luite, the webpage is free but incomplete.
13:43:27 <luite> aw :(
13:43:38 <thoughtpolice> yea it's just an O'Reilly tease of the first few chapters
13:43:40 <thoughtpolice> they do that
13:43:56 <applicative> bflyblue: thats what I was using , but now I see this conduit one,
13:44:15 <luite> i might get it after icfp
13:44:17 <bflyblue> let me take a look at that, might play with resourset nicer
13:45:27 <applicative> oh wait they're consistent or rather, zeromq3-haskell and zeromq-conduit.
13:46:00 <applicative> in any case you get the clearly all important resourcet instance in there
13:46:13 <applicative> http://hackage.haskell.org/package/zeromq3-conduit
13:50:30 <haasn> http://bpaste.net/show/116748/ <- this is a valid applicative, right?
13:51:10 <applicative> this is a little bizarre,  you want System.ZMQ3.Monad not System.ZMQ3.Monadic
13:52:09 * hackagebot phybin 0.2.2 - Utility for clustering phylogenetic trees in Newick format based on Robinson-Foulds distance.  http://hackage.haskell.org/package/phybin-0.2.2 (RyanNewton)
13:52:40 <bflyblue> oh?
13:55:07 <applicative> bflyblue: i'm not quite getting it,but the zmq conduit thing depends on zmq3 haskell, but it doesnt use the 'Monadic' module; rather it rewrites it as ....Monad to have a nonorphan resourcet instance
13:55:53 <bflyblue> ok, let me try the normal zmq3 haskell interface and see how far i can get with that :)
13:56:56 <applicative> yes, it looks like you should scrap conduitland/resourcet and use that, or else use the other 'ZMQ' monad. this decision makes sense but is very confusing, the zmq conduit one
13:57:29 <applicative> System.ZMQ from the regular zmq3-haskell is the common element.
13:57:31 <merijn> eh, fyi, ZMQ sockets aren't threadsafe and afaict the haskell-zeromq3 library has no code to make them so
13:57:57 <applicative> merijn: at the moment its more a matter of typechecking
13:58:03 <merijn> As a result, my own ZMQ code has a horrible threading hack to deal with that
13:58:28 <merijn> Also the System.ZMQ3.Monadic interface is, afaik, rather experimental
13:58:37 <merijn> System.ZMQ3 seems to be the production ready one
13:59:40 <applicative> merijn: I wonder if the fancy footwork in zeromq-conduit is an attempt to address this? I'm out of my depth with the material of course
14:00:31 <merijn> I'm trying to address this, but I only started coding like yesterday evening, so tough luck, unless you plan to wait a few months ;)
14:00:45 <applicative> it doesn't have to do with conduit, but https://github.com/NicolasT/zeromq3-conduit/blob/master/src/System/ZMQ3/Monad.hs
14:01:31 <merijn> I found the notion of a ZMQ conduit rather odd
14:01:51 <applicative> that the thing, conduit isn't a dependency
14:02:05 <merijn> I know
14:02:26 <merijn> That was just me musing
14:02:56 <merijn> conduits and pipes seem aimed at stream-like processing, whereas ZMQ is aimed at concurrent networking, the combination strikes me as less than ideal
14:02:58 <applicative> oh, for the whole package it is, sorry.  but it rewrites the Monadic module -- I suspect you will think no better
14:04:31 <joergfritsch> If I get a "not in scope type variable word8", what must I import?
14:04:42 <joelteon> Data.Word
14:04:48 <joergfritsch> ah
14:04:59 <k00mi> haasn: it is
14:05:37 <joergfritsch> joelteon: thanks
14:05:41 <joelteon> np
14:05:43 <joelteon> @hoogle Word8
14:05:44 <kappabot> Data.Word data Word8
14:05:44 <kappabot> Data.ByteString.Builder.Prim word8 :: FixedPrim Word8
14:05:44 <kappabot> Data.ByteString.Builder word8 :: Word8 -> Builder
14:05:46 <joelteon> you can also do that
14:06:02 <roboguy_> joergfritsch: if it says "type variable", you probably need to capitalize the "w"
14:07:00 <joergfritsch> roboguy: thanks, it is in scope now :D
14:07:47 <applicative> merijn: maybe it wont do for real network uses, but whats wrong with http://hackage.haskell.org/packages/archive/pipes-concurrency/1.2.1/doc/html/Control-Proxy-Concurrent.html
14:08:00 <applicative> except that you keep writing "performGC"
14:08:30 <merijn> applicative: My point is not that it's not good for real network uses
14:08:45 <chrisdotcode_> guys, does [] satisfy [a]?
14:08:50 <applicative> yes
14:08:53 <chrisdotcode_> figured
14:08:54 <applicative> @type []
14:08:56 <kappabot> forall a. [a]
14:08:57 <chrisdotcode_> applicative: thanks :)
14:09:17 <merijn> applicative: My point is that the type of networking you'd use ZMQ for is completely different from the type of networking you'd use pipes/conduits for
14:09:52 <merijn> applicative: i.e. pipes and conduits seem aimed at straighforward "connect to client/server, receive a stream of data, do something with it"
14:10:08 <applicative> yes, that sounds right, but i wouldn't have anticipated the stuff in pipes-concurrent with makes sense even if the examples are toylike
14:10:09 <merijn> applicative: ZMQ is more a "create your own packet switched network"
14:10:30 <dabd> what is a better introductory book for haskell? learn me a haskell or real world haskell?  thanks
14:10:44 <chrisdotcode_> dabd: LYAH, IMO
14:10:48 <applicative> merijn: i'm inclined to believe you, not having any experience with the like of zmq
14:11:06 <dabd> i am familiar with impure functional programming languages: clojure, ocaml, lisp
14:11:12 <dcoutts> dabd: LYAH for introductory, and I also often recommend "Programming in Haskell"
14:11:16 <applicative> dabd: there's a website for LYAH and it's better for the very beginning certainly
14:11:22 <merijn> dabd: In that case, skip LYAH and go to RWH
14:11:31 <applicative> ha
14:11:34 <merijn> dabd: Provided you feel reasonably comfortable in ocaml
14:11:43 <dabd> but i don't know anything about monads and other topics
14:11:53 <applicative> if you know ocaml you know a lot then
14:12:03 <dcoutts> dabd: I'm not sure I agree with merijn, I think LAYH would help with the Haskell specifics
14:12:04 <dabd> well i know basics of ocaml
14:12:05 <merijn> dabd: Monads are simple, read up on typeclasses. If you know ocaml the rest should be trivial
14:12:20 <dabd> not an expert by any means
14:12:33 <dcoutts> dabd: knowing other FP langs will certainly help
14:12:36 <haasn> Is there some :: String -> Rational that will parse something like "0.123", preferably without going through Double?
14:12:55 <merijn> dabd: Sure, but LYAH invests a lot of time explaining things like function composition, lack of parens for function application and parametric polymorphism, ec.
14:13:01 <applicative> its still making me seem lyah is the right path. Programming in Haskell is good, but there could be a very similar Programming in OCaml
14:13:16 <applicative> so maybe i'm taking this back .
14:13:43 <dabd> programming in haskell is a bit old isn't it?
14:13:43 <merijn> dabd: RWH has a crash course haskell in the first two chapters, if you read those and think "pffft, this is easy", keep going in RWH, else you can always switch to LYAH
14:13:46 <dcoutts> dabd: but there are enough differences (e.g. we don't obsess about tail recursion like they do in strict FP langs, so that leads to quite different idioms)
14:14:36 <merijn> dabd: LYAH is nice, but it takes like 2 or 3 chapters to reach the "map :: (a -> b) -> [a] -> [b]" point or so
14:14:48 <dabd> i decided to give it a try to learn haskell after looking at the computer shootout site comparing clojure to haskell. It seems haskell can be quite fast
14:15:25 <dcoutts> dabd: aye, we used to be always chasing C speed, but then Java came along... :-)
14:15:31 <dcoutts> much easier to beat
14:15:34 <tac> dabd: Type systems are nice for that.
14:16:05 <applicative> type systems are nice for beating clojure in shootouts?
14:16:11 <dabd> ok i'll start with learn you a haskell
14:16:21 * sm thought java was pretty fast
14:16:53 <dabd> is leksah the standard ide for haskell?»
14:16:59 * tulcod doesn't care about a 10x multiplication factor as long as the code works
14:17:09 * hackagebot lio 0.11.2.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.2.0 (DeianStefan)
14:17:10 <applicative> oh no dabd war will now break out
14:17:14 <merijn> dabd: Not really, most people here seem to use vim/emacs
14:17:16 <dabd> oops
14:17:34 <dabd> i use emacs for clojure but maybe there is something better for haskell
14:17:52 <applicative> oh awesome if you use emacs theres a giant infrastructure
14:17:56 <merijn> dabd: I suspect not, unless Peaker finally finishes lamdu ;)
14:18:43 <merijn> dabd: (For reference take a look at the horribly experimental: https://github.com/Peaker/lamdu)
14:18:56 <applicative> no dont look
14:19:04 <merijn> Not at the code, no :p
14:19:14 <jfischoff> what
14:19:16 <applicative> oh wait, maybe you were using emacs unwillingly for clojure
14:19:19 <jfischoff> s wrong with the code?
14:19:34 * jfischoff likes Peaker's code 
14:19:46 <dabd> no i like emacs
14:19:46 <tulcod> hlint says:  Warning: Use ***. sure, i will, as soon as i understand what it does.
14:19:50 <merijn> jfischoff: Yeah, but not for someone just starting haskell...
14:19:50 <applicative> oh wasn't objecting, just declaring it a distraction
14:19:58 <merijn> :t (***)
14:19:59 <kappabot>     Not in scope: `***'
14:19:59 <kappabot>     Perhaps you meant `**' (imported from Prelude)
14:20:00 <dabd> but i think it is better for lisp like languages
14:20:01 <jfischoff> merijn: oh fuck no
14:20:03 <merijn> !!
14:20:06 <dabd> haskell has complicated syntax
14:20:15 <merijn> No Control.Arrow in kappabot :(
14:20:28 <joelteon> :t (Control.Arrow.***)
14:20:29 <Peaker> jfischoff, :-)
14:20:36 <monochrom> tulcod: use your own judgement to decide which hlint advice to ignore
14:20:38 <Peaker> jfischoff, also yairchu's
14:20:39 <quchen> tulcod: (f *** g) (a, b) = (f a, g b)  -- This is pretty much the only relevant case. *ducks*
14:20:40 <kappabot> forall (a :: * -> * -> *) b c b' c'. Control.Arrow.Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:20:41 <kappabot> merijn: well, maybe you should take that up with the person who's supposed to be running lambdabot
14:20:43 <applicative> why not just import everything and let ghci sort it out
14:20:46 <tulcod> monochrom: thanks, will do :)
14:20:49 <merijn> tulcod: You can read it as "(***) :: (a -> b) -> (c -> d) -> (a, b) -> (c, d)
14:21:09 <tulcod> merijn, quchen: okay sure. but then i would import arrows just for this one place where i use them
14:21:15 <tulcod> is that acceptable?
14:21:17 <joelteon> they should be in the prelude :c
14:21:21 <joelteon> tulcod: import whatever you like
14:21:21 <merijn> tulcod: Also check out first, second and &&&
14:21:33 <joelteon> I personally import Control.Arrow a lot because I love the combinators
14:21:39 <monochrom> it is not so much "hlint is mechanical" as "hlint is clearly written by a person with his/her bias"
14:21:41 <merijn> tulcod: I import Control.Arrow almost by default :)
14:21:42 <applicative> dabd the syntax is pretty simple, really, a few sugary bon bons, precedence rules for operators etc
14:21:46 <shachaf> When people say "combinator" do they just mean "function"?
14:21:49 <shachaf> Or maybe even "value".
14:21:51 <jfischoff> Peaker: I don't think lenses or point free code is good beginner material
14:21:56 <jfischoff> but I use constantly
14:21:59 <quchen> Should I start a petition to move Control.Arrow to Data.Tuple? ;-D
14:22:04 <applicative> isn't [] a combinator
14:22:12 * startling combinates.
14:22:18 <monochrom> Control.Tuple
14:22:19 <dmwit> "combinator" has a specific technical meaning, but I think people may use it in slightly more relaxed ways than the technical definition would suggest.
14:22:22 <joelteon> shachaf: they mean "operator with a non-obvious purpose"
14:22:27 <joelteon> or at least, that's what I mean
14:22:27 <dabd> applicative: i really like s-expressions i wish haskell had s-expression syntax :-)
14:22:45 <applicative> ah, well dabd its not like that.
14:22:58 <joergfritsch> Is there any way I could make this work:
14:23:05 <joergfritsch> import qualified Data.ByteString as B (snoc)
14:23:05 <joergfritsch> import qualified Data.ByteString.Char8 as B
14:23:05 <applicative> dabd: there is a secret curly-bracket and ; syntax inside the sugar
14:23:06 <tulcod> merijn: but i understood arrows were this grand new concept to program in new ways. *** just looks like a regular function that was made an infix operator for no apparent reason :P
14:23:07 <jfischoff> dmwit: I think it has come to mean "function" :p
14:23:16 <monochrom> yes joergfritsch that will work
14:23:32 <shachaf> jfischoff: Sometimes even non-function values are called combinators.
14:23:33 <applicative> dabd: which i agree is infinitely more loathesome than the s expression
14:23:33 <monochrom> oh wait, there may be two snoc's
14:23:53 <joergfritsch> monochrom: can I not hide one snoc
14:23:54 <joergfritsch> ?
14:24:02 <jfischoff> shachaf: yeah I guess it just means "thing you combine with other things like it" now
14:24:03 <merijn> tulcod: arrows are "a grand new concept to program in new ways" in much the same way monads are
14:24:15 <FreeFull> dabd: Is the Y-combinator a combinator?
14:24:54 <applicative> @type fix
14:24:56 <kappabot> forall a. (a -> a) -> a
14:24:56 <merijn> tulcod: It just happens that functions are a very convenient arrow
14:25:03 <Eduard_Munteanu> FreeFull: FSVO combinator
14:25:09 <FreeFull> λf.(λx.f (x x)) (λx.f (x x))
14:25:11 <applicative> fix very much has the type of a 'combinator'
14:25:20 <dabd> freefull: i am not versed in lambda calculus
14:25:42 <dmwit> I've been annoyed by this before, too. "qualified", "as", and "hiding" should just be orthogonal instead of having them mixed up as they are now.
14:25:44 <tac> @type \f -> (\x -> f (x x)) (\x -> f (x x)) :: (r -> r) -> r
14:25:45 <FreeFull> But Haskell is based on System F
14:25:48 <applicative> jfischoff: edwardk for example uses the word combinator, and he doesn't use it that way
14:25:55 <kappabot>     Couldn't match expected type `t0'
14:25:55 <kappabot>                 with actual type `((r -> r) -> r) -> (r -> r) -> r'
14:25:55 <kappabot>       because type variable `r' would escape its scope
14:26:02 <applicative> it contains the notion of polymorphism
14:26:08 <dmwit> joergfritsch: You might consider defining "snoc = Data.ByteString.snoc" at the top of your file.
14:26:13 <monochrom> joergfritsch: I don't understand your purpose. which snoc do you want?
14:26:31 <Eduard_Munteanu> dmwit: mm, not sure they are orthogonal, they mixed them up rather well. Agda's stuff is somewhat similar.
14:26:43 <FreeFull> tac: Haskell's typing doesn't allow the y combinator to work
14:26:47 <shachaf> dmwit: What do you mean, mixed up?
14:26:59 <joergfritsch> the snoc that is not from the .Char8 I need.
14:27:02 <FreeFull> tac: Its functionality has to be implemented in a named way
14:27:04 <shachaf> You can make Y work in haskell using Curry's paradox.
14:27:10 <Eduard_Munteanu> I take it uncommon stuff like 'import Foo as F'.
14:27:15 <joergfritsch> dmwit: that works
14:27:31 <monochrom> ok, import qualified Data.ByteString as B(snoc); import qualified Data.ByteString.Char8 as B hiding(snoc)
14:27:45 <Eduard_Munteanu> It would help if Haskell had a better module system, though.
14:27:45 <haasn> you can implement the version of ‘y’ FreeFull gave in Haskell by using a newtype wrapper to get the recursive type
14:28:19 <dmwit> shachaf: Huh, I just checked the spec again. It seems they *are* orthogonal.
14:28:21 <FreeFull> haasn: Sure, but then the type is named
14:28:31 <FreeFull> You can't escape the naming
14:28:36 <dmwit> I guess in the past I just put the "hiding" and "as" clauses in the wrong order, and made a wrong conclusion about what was and was not allowed.
14:28:37 <shachaf> dmwit: OK then. I wasn't sure whaat you meant.
14:28:49 <dmwit> joergfritsch: So perhaps you will like to look at the spec, too.
14:29:03 <Eduard_Munteanu> dmwit: do you mean unqualified import as should be illegal, for example?
14:29:06 <dmwit> joergfritsch: You can import qualified Long.Name as ShortName hiding (anything, you, like)
14:29:23 <dmwit> Eduard_Munteanu: I do not mean unqualified import as should be illegal.
14:29:32 <FreeFull> Ironically your ShortName is just as long as LongName
14:29:35 <FreeFull> Ironically your ShortName is just as long as Long.Name
14:29:39 <Eduard_Munteanu> Hah.
14:29:53 <joergfritsch> dmwit: thanks man!
14:29:57 <dmwit> Eduard_Munteanu: I mean all the settings of the "has a qualified", "has an as-clause", and "has a hiding-clause" should be legal (and they are).
14:30:13 <Eduard_Munteanu> Ah.
14:30:41 <dmwit> (So there's eight settings all together.)
14:30:52 <dmwit> s/l //
14:31:06 <Eduard_Munteanu> The eightfold way for Haskell.
14:31:37 <Peaker> jfischoff, lamdu is probably *very* beginner-unfriendly :)
14:31:49 <monochrom> did you know: import qualified Data.ByteString as Data.ByteString(snoc); import qualified Data.ByteString.Char8 as Data.ByteString hiding(snoc)
14:32:00 <Peaker> jfischoff, I think it would have 40-50% more LOC if it were written in a more beginner-friendly style similar to other Haskell projects
14:32:20 <dmwit> TIL module import specifications have an optional trailing comma.
14:32:24 <dmwit> hooray!
14:32:35 <Eduard_Munteanu> Agda does that nicer, but they have a better modules system.
14:33:19 <Eduard_Munteanu> dmwit: err inside the ( ) parens, or how?
14:33:26 <dmwit> yep
14:33:35 <dmwit> import Foo (bar, baz,)
14:33:44 <shachaf> Export lists, also (I think?).
14:33:47 <dmwit> yes
14:33:47 <Eduard_Munteanu> I sort of wish records had that too.
14:34:01 <dmwit> Yes, there should be optional trailing commas everywhere there are commas. =)
14:34:06 <dmwit> (And screw you, TupleSections!)
14:34:39 <joergfritsch> Can someone help me w a piece of code where I need to make a small change but not quite sure how to bring it in best?
14:34:51 <jcowan> I figured out a hopefully clearer version of my previous question.  Here it is again.
14:34:59 <Eduard_Munteanu> joergfritsch: not if we don't see it :)
14:35:02 <dmwit> joergfritsch: Don't ask to ask; just ask. This goes for the future, too.
14:35:03 <jfischoff> don't worry TupleSections dmwit doesn't mean it
14:35:22 <joergfritsch> Here: https://gist.github.com/viloocity/e9b2606ac677b962cf7d I need to discriminate two cases
14:35:26 <dmwit> TupleSections can stay as soon as we get TDNR. =P
14:35:34 <joergfritsch> when b = 11 then use sendq
14:35:40 <joergfritsch> when b = 72 use sendqr
14:35:44 <jcowan> Given that the methods of Applicative are fmap, pure, and <*>, what additional method would turn Applicative into Monad', a class with the same powers as Monad, *without* allowing <*> to be defined in terms of the original method?
14:36:05 <sclv_> jcowan i think that is impossible
14:36:15 <dmwit> joergfritsch: And what should you do for other values of b?
14:36:18 <jfischoff> dmwit: TDNR?
14:36:19 <Eduard_Munteanu> Right, TDNR would be nice.
14:36:20 <merijn> jcowan: You can trivially define <*> given the monad functions
14:36:20 <jcowan> That's a large claim if true.
14:36:27 <dmwit> jfischoff: type-directed name resolution
14:36:36 <dmwit> jfischoff: i.e. what other languages call polymorphism
14:36:40 <joergfritsch> all other values would go to sendq
14:36:51 <joergfritsch> only val 72 goes to sendqr
14:36:51 <jcowan> Yes, given *the* Monad functions.  But I want a different set of Monad methods.
14:36:54 <sclv_> jcowan: anything you add to turn applicative to monad is equivalent to join
14:37:02 <dmwit> joergfritsch: So, use a case or an if-then-else. e.g. if b == 72 then sendqr else sendq
14:37:05 <merijn> jcowan: "f <*> x = f >>= \g -> join (liftM g x)"
14:37:08 <sclv_> you can write <*> using join, fmap, and pure
14:37:22 <sclv_> or just join and fmap in fact :-(
14:37:31 <sclv_> :-) rather
14:37:31 <jcowan> Ouch, yes, I see.
14:37:36 <jcowan> :-( from my POV
14:37:46 <sclv_> why would you want such a thing?
14:37:47 <joergfritsch> dmwit: that is not so easy since it needs to be part of the action (is that the right word)
14:37:49 <jfischoff> dmwit: still can't see what you want :(
14:37:50 <sclv_> its a sort of amazing relationship
14:37:51 <merijn> jcowan: Why?
14:38:11 <shachaf> Is there a Foo such that class Functor f => Applicative f where applicative :: Foo f a -> f a?
14:38:12 <jcowan> I had hoped to provide an ascending tower: add a new method, get a new useful typeclass.
14:38:13 <monochrom> jcowan: you may like http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms
14:38:18 <joergfritsch> dmwit: can I trigger two different actions depending on b?
14:38:29 <merijn> jcowan: You do, you add bind to Applicative to get monad
14:38:42 <dmwit> joergfritsch: Sure, why not?
14:38:43 <jcowan> Yes, but then <*> becomes redundant, as you say.  Not really neat.
14:38:51 <sclv_> right, some types of arrows are inbetween applicative and monad.
14:38:54 <shachaf> For example, there's CoYoneda, which gives you class Functor f where fmap :: CoYoneda f a -> f a
14:38:59 <sclv_> but they're not very useful
14:39:00 <joergfritsch> dmwit: was unsure
14:39:01 <applicative> joergfritsch: are you talking about the final case statement in there?
14:39:04 <joergfritsch> dmwit: will try
14:39:08 <shachaf> And there's Freem, which gives you class Functor m => Monad m where monad :: Freem m a -> m a
14:39:09 <sclv_> (depending on who you ask)
14:39:14 <jcowan> Was Premonad dropped because not useful?
14:39:14 <merijn> jcowan: You're looking at it wrong, <*> and join make bind redundant
14:39:16 <dmwit> joergfritsch: I mean you can literally replace sendq with (if b == 72 then sendqr else sendq) in your code.
14:39:24 <dmwit> Though aesthetically I don't like that solution.
14:39:25 <barshirtcliff> hey, do you guys have a favorite answer to the question, "what is a monad?" from non-computer-scientists?
14:39:26 <jcowan> merijn: join alone makes bind redundant already.
14:39:32 <merijn> jcowan: oh, true
14:39:40 <dmwit> barshirtcliff: There are many, many monad tutorials online.
14:39:43 <dmwit> Perhaps you should read one!
14:39:45 <joergfritsch> applicative: I talk about the whole return thing. But if there is a way to change the behaviour of teh case statement, even better
14:39:45 <barshirtcliff> I know.
14:39:48 <merijn> jcowan: Well, there you go, add join to applicative and done
14:39:52 <jcowan> I was going to use the fmap/unit/join basis, but fmap/unit is Premonad, which is not Applicative.
14:40:16 <Peaker> jfischoff, btw, which part of lamdu did you read?
14:40:18 <dmwit> ...or point your non-computer-scientist friend at one. =)
14:40:22 <shachaf> They're calling that "Premonad" now?
14:40:23 <sclv_> fmap/unit is really "inhabited functor"
14:40:24 <barshirtcliff> that never works.
14:40:29 <sclv_> jcowan: is this for r7?
14:40:36 <Eduard_Munteanu> Pointed
14:40:46 <monochrom> I assume "non-computer-scientist" = "mathematician".
14:40:47 <sclv_> pointed is just unit and it is terrible
14:40:54 <barshirtcliff> non-mathematician.
14:40:57 <jfischoff> Peaker: I have read bits of the code from time to time. I remember liking the style
14:40:59 <barshirtcliff> easy to explain to a mathematician.
14:41:00 <Eduard_Munteanu> sclv_: doesn't Pointed require Functor?
14:41:03 <shachaf> sclv_: But, like, affine traversals, man!
14:41:06 <sclv_> hahaah
14:41:16 <jcowan> sclv_: Maybe.  At least, I'm exploring it.
14:41:17 <Peaker> jfischoff, cool, I hope you run it too :-)
14:41:19 <sclv_> yeah you can do pointed functor and its slightly less terrible
14:41:33 <dmwit> barshirtcliff: I mean, are you looking for a recommendation of which tutorial would be appropriate, or what?
14:41:42 <applicative> joergfritsch: you dont want the return $ business since what happens in the branches is already IO, i take it
14:41:43 <sclv_> if we actually had the Functor => Applicative => Monad tower, the experience of the Haskell community is that's what you really want
14:41:43 <barshirtcliff> no, dmwit.  I know what a monad is.
14:41:48 <barshirtcliff> thank you, though.
14:41:48 <monochrom> well, I can't even define/explain/describe/what-you-call-it "set" to a non-computer-scientist non-mathematician.
14:41:48 <jfischoff> Peaker: I have but not recently :(. I pulled but haven't built in a bit
14:41:49 <dmwit> It's not going to be better to type one into IRC than it would be to just read an already-typed one on somebody's blog.
14:41:50 <sclv_> and there's no reason to try to decorate it out more
14:41:52 <Peaker> jfischoff, hopefully soon we'll be done with a new&improved inference engine that should speed things up (and infer some new things that weren't inferred before)
14:42:05 <tswett> Is it safe to unsafeCoerce something to Void and then back to its original type?
14:42:12 <applicative> !!!
14:42:20 <barshirtcliff> dmwit, well, pasting links is a good skill.  perhaps links don't work in this channel?
14:42:24 <barshirtcliff> :P
14:42:29 <sclv_> jcowan: there's debate about it but there's not much point to your "PreMonad" because the only law it takes is the free theorem you get from functorality
14:42:33 <monochrom> in fact, why would I?
14:42:46 <sclv_> so its really any functor with a function "gimmeOne :: f ()"
14:42:52 <dmwit> barshirtcliff: I'm really lost about what you want out of us. I'm happy to help, but don't know how.
14:42:54 <Eduard_Munteanu> tswett: dunno the answer, but I wonder what the GC does to stuff referenced from your original thing
14:43:01 <jfischoff> Peaker: nice
14:43:02 <sclv_> and you only don't have that in degenerate cases
14:43:06 <joergfritsch> applicative: what do I want then?
14:43:06 <barshirtcliff> thanks, dmwit.
14:43:17 <jcowan> sclv_: I concluded that, but wanted to make sure I didn't miss anything.
14:43:25 <shachaf> barshirtcliff: There is no need to be rude.
14:43:40 <barshirtcliff> I'm sorry, forgive me.
14:43:43 <jcowan> Well, class Comparator is already a bit redundant: it covers Eq, Ord, and something I'll call Hash.
14:43:53 <applicative> joergfritsch: a line in a do-block can just begin case lookup x y of Nothing -> do {..ten pages..} ; Just y -> do {... ten other pages...}
14:45:19 <jcowan> Now, is there a real practical advantage to the unit/bind basis as opposed to the fmap/unit/join basis?
14:45:23 <sclv_> jcowan: if you're doing that hierarchy you should also consider traversable, which is very handy along with applicative.
14:45:34 <jcowan> It's on my list, yes, along with foldable.
14:45:44 <applicative> main = do c <- getChar; case c of 'a' -> do getChar ...; 'b' -> return (); ...
14:45:55 <Eduard_Munteanu> jcowan: arguably they should provide both join and bind in the typeclass
14:46:03 <applicative> joergfritsch: or the like ^^^
14:46:05 <Gracenotes> join is not always as 'efficient'
14:46:12 * jcowan nods.
14:46:22 <Eduard_Munteanu> Gracenotes: yeah, I guess the same could hold for bind
14:46:44 <monochrom> unit-bind lets me think what applicative just said. fmap-unit-join lets me think []
14:46:53 <sclv_> but in do notation desugaring we get lots of binds and no joins
14:47:00 <Eduard_Munteanu> join (Trivial t) = t
14:47:06 <dmwit> I can't help feeling we failed barshirtcliff there. I'm really not sure what success would have looked like, though.
14:47:10 * hackagebot g-npm 0.0.2 - Generate Gentoo ebuilds from NodeJS/npm packages.  http://hackage.haskell.org/package/g-npm-0.0.2 (JesusRivero)
14:47:22 <monochrom> but wait, sometimes I use unit-bind for [] too
14:48:17 <joergfritsch> applicative: yes, but there is a reasin why it is an action
14:48:59 <monochrom> dmwit: success would look like a popular science article on K-theory for non-physicists non-mathematicians
14:49:10 <applicative> joergfritsch: i was just trying to talk you out of the return $
14:49:20 <monochrom> i.e., why would you write it and why would I read it?
14:49:32 <applicative> joergfritsch: because you end up with something that only typechecks if return $ return () does
14:49:47 <joergfritsch> applicative: but isn't this what is called an "action"?
14:49:56 <jophish> I'm writing a little lexer and I spy some really useful functions in Text.Regex.DFA.Engine. I'd really like to specify a bunch of NFAs (either with some combinators or as regular expressions) and have a function which returns the longest match from any of them on a string
14:49:59 <applicative> return () is an action
14:50:03 <applicative> not much of one...
14:50:10 <applicative> and so I guess is setq
14:50:19 <jcowan> http://lambda-the-ultimate.org/node/4708 <-- my best take on monads
14:50:48 <jophish> Are there any packages which provide this functionality, The haskell dynamic lexer engine (http://www.nondot.org/sabre/Projects/HaskellLexer/) looks like something along the right lines
14:51:09 <applicative> return $ return () is an action too , as is return $ setq x y z, but why would you want to return setq x y z, rather than returning whatever it is seq x y z returns
14:51:43 <dmwit> jophish: Most NFA libraries offer an "or" operation on NFAs; so I would expect you could change your "I'd really like ..." to "I'd really like to specify a single NFA and have a function which returns the longest match from it", which is certainly possible...
14:52:04 <jophish> dmwit: exactly
14:52:06 <joergfritsch> applicative: to achieve that both branches of the case statement "return" the same type IO()
14:53:00 <dmwit> jophish: Hm. Does this mean you consider your question answered? Or is there more to the question?
14:53:06 <applicative> joergfritsch: the type of the branches in your case statement are each I think IO (),
14:53:21 <applicative> joergfritsch: but the whole line has the type IO (IO ()) which is rarely desirable
14:54:08 <jophish> dmwit: can you suggest a nice nfa library?
14:54:21 <sclv_> there's an old monad reader that sketches one
14:54:26 <sclv_> and i have a toy one
14:54:33 <sclv_> that targets llvm ultimately
14:54:40 <sclv_> but i don't know if i'd call either 'nice and usable'
14:54:47 <dmwit> Well, the one you pointed at (regex-dfa) offers everything you asked for. There's half a dozen other regex libraries on Hackage that would all work.
14:55:05 <dmwit> There's also that one with a play-cum-paper associated with it.
14:55:07 <sclv_> right -- if you just want the regex side as opposed to a general purpose nfa lib
14:55:15 <sclv_> there are lots of great regexish libs
14:55:28 <dmwit> I can't say much about which is best, though; I haven't needed to use one for very much in-depth stuff.
14:55:54 <dmwit> I remember thinking the API of regex-applicative looked pretty nice.
14:55:55 <sclv_> its easy enough to take your regex engine and then wrap it in the helper function to 'pick the longest match'
14:56:14 <sclv_> the tdfa one is or used to be super performance tuned
14:56:55 <sclv_> compared to the others which are quite nice but not necessarily tackled with that eye for etc.
14:56:56 <Eduard_Munteanu> They say regex-posix is horribly slow, though.
14:56:58 * applicative swears by the regexes in frisby, but only because of the element of madness in it
14:57:26 <sclv_> that's a good criterion for picking code
14:57:34 <sclv_> i want code that when i look deeply into it, it looks back at me
14:58:01 <applicative> my kind of haskeller, that sclv_
14:58:16 <dmwit> http://sebfisch.github.com/haskell-regexp/regexp-play.pdf
14:59:06 <dmwit> jophish: I guess my final recommendation is to spend maybe 15-20 more minutes thinking about which one to pick, and then just pick one and get coding. =P
14:59:20 <jophish> dmwit: Sounds like a super plan, Thanks
15:01:42 <applicative> dmwit: but wait no, cant we spend 20 minutes arguing against regexen and favor of parser combinators, as is I think customary for this channel?
15:02:01 <applicative> or maybe that happened and i missed it
15:02:04 <dmwit> Why not both? That's why I suggested regex-applicative. =)
15:02:16 <jfischoff> :o
15:02:30 <applicative> regex-applicative is rational, as it seemed to me, yes
15:02:56 <monochrom> ok, 20 minutes reallocated for arguing applicative vs arrow :)
15:03:01 <pmade> I'm not sure if I've never noticed this or I recently changed something but using cabal-dev install now produces a lot of output in the form "Loading package ...".  How do I quiet that down?
15:03:06 <applicative> applicative ftw
15:03:12 <monochrom> haha
15:03:33 <c_wraith> pmade: that usually means something is running template haskell in the compile process
15:03:35 <c_wraith> pmade: as far as I know, there's no way to suppress that output
15:03:35 <pmade> c_wraith: Yep, that would be the difference.
15:03:45 <pmade> I guess I'll resort to grep -v
15:04:14 <applicative> so just omit {-#LANGUAGE TemplateHaskell #-} for a better world
15:04:57 <pmade> applicative: Snap app with lenses, so not using TH is too painful.
15:05:35 <jfischoff> pmade: it can't be helped if you are using TH.
15:06:11 <pmade> jfischoff: my makefile now reads: cabal-dev install | grep -v '^Loading package'
15:06:25 <jfischoff> oh that
15:06:33 <dmwit> That doesn't look like a Makefile at all!
15:06:36 <dmwit> not enough colons and hard tabs
15:06:38 <jfischoff> sure
15:07:43 <pmade> dmwit: I must be doing something wrong then ;)
15:09:53 <dmwit> This gives me a great idea for a stunt to pull in some joke project in the future.
15:09:53 <dmwit> echo Run ./Makefile > README
15:10:10 <applicative> pmade: I think you should make a regex so that "Loading package ..." turns into "Template Haskell hard at work ..."
15:10:29 <jophish> regex-applicative looks ideal
15:10:47 <jfischoff> or "This is why we can't have a nice cross-compiler"
15:10:47 <merijn> Is there a Set for things that aren't Ord but do have a mapping to an Ord value?
15:11:35 <shachaf> merijn: Use a newtype?
15:11:52 <dmwit> merijn: Nope. Make a newtype around either your type or Set.
15:11:55 <merijn> shachaf: Well, I can just as well implement Ord for my type, it'd just be nonsensical
15:12:13 <sclv_> wait why is it nonsensical
15:12:17 <dmwit> It would be nice if we had two Ord classes, one of which didn't promise to be sensical.
15:12:28 <shachaf> sclv_: Things like complex numbers, I guess?
15:12:44 <monochrom> use unordered-containers's Data.HashSet. it uses hashing, which is a mapping to Int, which is an Ord value
15:12:48 <merijn> sclv_: Because my data isn't orderable in itself, I'm just assigning unique id's for the sole goal of making them orderable
15:13:21 <merijn> sclv_: i.e. maintain a global counter and read from there whenever I create a new thing
15:14:01 <merijn> I'd hardly consider that a sensible ordering
15:14:26 <sclv_> oh so its totally legit
15:14:33 <sclv_> just not about the "meaning" of the things
15:14:38 <sclv_> yeah, Ord is/should be for that
15:14:52 <merijn> sclv_: It's a consistent Ord, just semantically silly
15:14:52 <sclv_> i agree with dmwit that we should have two ord classes to distinguish better
15:14:57 <sclv_> right
15:15:25 <sclv_> since we use ord for things like maps and stuff i think its by default the "semantics be dashed" class
15:15:32 <sclv_> and unfortunately we don't have the other :-P
15:15:35 <merijn> Actually
15:15:44 <merijn> Would IntMap have better performance than Set?
15:16:13 <sclv_> yeah the patricia variants always are way better when you can use them. good point!
15:16:27 <monochrom> instance Hashable YourType where hash x = x's unique ID
15:16:33 <merijn> I should probably use IntMap than
15:16:35 <c_wraith> always?
15:16:38 <sclv_> monochrom: cuet
15:17:16 <c_wraith> I thought the patricia variants were worse when the keys were dense enough to cause a lot of lookup depth, but the overall size is small
15:17:51 <dmwit> There's a max depth of like... eight, anyway, isn't there?
15:18:05 <merijn> c_wraith: Docs imply that complexity is limited by the number of bits in Int
15:18:22 <dmwit> If you have enough density to hit a depth of eight in an IntMap, you probably have enough density to hit a depth of at least eight in a Set.
15:18:30 <merijn> i.e. "O(min(n,W))" where n is the number of elements and W is the bits in Int
15:18:56 <c_wraith> I'd need to review exactly how the patricia tree branches
15:19:10 <c_wraith> But I'm pretty sure such cases exist
15:19:26 <dmwit> Okay. It wouldn't surprise me too much to find out I was wrong about performance. =D
15:21:15 <merijn> Oh well, we'll benchmark that later
15:21:46 <c_wraith> merijn: that upper bound on the number of bits doesn't mean a whole lot. "the maximum lookup time is logarithmic in the number of elements in the set of keys."
15:22:07 <c_wraith> merijn: all that *really* means is "it never gets unbalanced"
15:25:03 <c_wraith> Yeah, I just checked the definition.  It's a binary tree with common subpath compression.  Hmm.  Dense keys isn't the worst-case for that, then.
15:25:17 <c_wraith> because dense keys will share subpaths
15:26:47 <c_wraith> So you can get the tree depth to W with, um...  W + 1 keys.
15:27:15 <c_wraith> So yeah.  Highly artificial cases where you can get better performance out of Map than IntMap
15:27:56 <shachaf> Less artificial: You take the size of the map a lot.
15:28:01 <merijn> c_wraith: But not if, say, keys are [1..x]
15:28:37 <c_wraith> merijn: yeah.  Dense keys should be good for IntMap, with that representation
15:29:02 <merijn> \o/
15:29:48 <shachaf> Perhaps IntMap was written by Abram Denski.
15:30:26 <jfischoff> dcoutts: the issue appears to be with Custom build type packages. I didn't have Cabal-1.17.0 available in the sandbox, but for Custom type packages it compiles the second time I try to build, and I have to blow away my sandbox
15:30:52 <dcoutts> jfischoff: interesting
15:32:37 <jfischoff> dcoutts: hmm add Cabal-1.17.0 doesn't fix the problem. Still get cabal: The package 'lifted-base' requires Cabal library version >=1.17.0 &&
15:32:37 <jfischoff> >=1.8 but no suitable version is installed.
15:33:49 <dcoutts> jfischoff: I have to disappear, make sure you record all the details in a ticket on github
15:34:01 <dcoutts> and thanks for looking into it
15:34:19 <jfischoff> dcoutts: no problem, we need this pretty badly at work so … yeah I have to do it :)
15:36:18 <joehillen> http://chimera.labs.oreilly.com/books/1230000000929/index.html
15:38:07 <dcoutts> jfischoff: btw, if things like this become important at work, my company can do it. Obviously it's cheaper to leave it to volunteers.
15:38:57 <jfischoff> dcoutts: good to know. I'll mention it.
15:47:11 * hackagebot music-pitch 1.3 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.3 (HansHoglund)
15:47:13 * hackagebot music-pitch-literal 1.3 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.3 (HansHoglund)
15:47:15 * hackagebot music-dynamics 1.3 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.3 (HansHoglund)
15:52:11 * hackagebot music-dynamics-literal 1.3 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.3 (HansHoglund)
15:52:13 * hackagebot music-parts 1.3 - To be written.  http://hackage.haskell.org/package/music-parts-1.3 (HansHoglund)
15:52:15 * hackagebot music-articulation 1.3 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.3 (HansHoglund)
15:52:17 * hackagebot music-score 1.3 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.3 (HansHoglund)
15:52:19 * hackagebot music-preludes 1.3 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.3 (HansHoglund)
15:57:21 * hackagebot music-sibelius 1.3 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.3 (HansHoglund)
15:57:23 * hackagebot lilypond 1.0 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.0 (HansHoglund)
15:57:51 <geekosaur> "To be written."
16:02:11 * hackagebot git-gpush 2.0.1.0 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-2.0.1.0 (JohnWiegley)
16:02:25 <johnw> wow, hackagebot was almost instantaneous that time
16:02:31 <johnw> i uploaded maybe 1 second before
16:02:54 <luite> what does it do?
16:03:22 <johnw> git-gpush is a wrapper that sniffs your commit logs for special markers that let you perform additional actions on GitHub other than just closing a bug
16:03:30 <johnw> it's more of an example project really
16:04:00 <luite> ah hmm
16:04:21 <luite> what kind of things?
16:04:48 <johnw> right now it sniffs "confirm #1982:luite", which sets a "needs confirmation" label on #1982, reassigns it to luite, and adds a comment asking that the bug be confirmed as fixed
16:04:53 <johnw> but it's easy enough to add other behaviors
16:05:25 <johnw> it's intended to showcase how easy gitlib make it to write such a utility :)
16:05:32 <luite> that doesn't really sound like the thing you'd want in the commit log though
16:05:52 <johnw> well, we were already putting "fixes #1982"  in the commit log, so yeah, we do add these markers in them too
16:06:38 <sm> go hackagebot
16:06:44 <luite> yeah but a fix is really a change in the repository. "needs confirmation", uh well, perhaps sometimes
16:07:11 * hackagebot gitlib-libgit2 2.0.2.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-2.0.2.1 (JohnWiegley)
16:07:13 * hackagebot gitlib-s3 2.0.2.1 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-2.0.2.1 (JohnWiegley)
16:07:15 * hackagebot hlibgit2 0.18.0.9 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.9 (JohnWiegley)
16:07:40 <johnw> spent several hours today tracking down an uninitialized memory bug in libgit2's C code.  thank goodness such things just aren't even possible in Haskell
16:08:58 <luite> did you use valgrind, insure++ or similar?
16:09:14 <johnw> valgrind did find the bug, but I didn't know until I had finally tracked it down that it had anything to do with uninit mem
16:09:21 <johnw> I thought I was just using the library incorrectly
16:22:38 <merijn> Quick confirmation: Don't you almost always want to run code masked when using async exceptions?
16:22:50 <merijn> At least, non-pure code
16:23:17 <c_wraith> well, no.  You want to run code that handles the exceptions masked
16:23:49 <c_wraith> You don't care about code that may generate the exception but doesn't care about it
16:24:03 <hpaste> Tester pasted “Test” at http://lpaste.net/91162
16:24:04 <c_wraith> or may receive the exception, in the async case
16:24:24 <merijn> c_wraith: uh, you do if you're allocating things like sockets
16:24:24 <c_wraith> If all it's going to do is receive the exception and terminate, it doesn't need to be masked
16:24:30 <c_wraith> merijn: then you use bracket, which is exception-aware
16:24:59 <merijn> Except bracket won't work because I don't have a fixed cleanup
16:25:54 <merijn> I'm installing the cleanup for the socket as part of the thread dying
16:26:33 <c_wraith> then it's still exception-aware code
16:27:35 <merijn> c_wraith: Yes, but there is a window in between allocating the socket and the handler being registered in which you shouldn't be interrupted or you'll leak the socket
16:27:53 <c_wraith> merijn: you're describing the bracket idiom
16:28:28 <merijn> i.e. I have "forever $ do { (hnd, _, _) <- accept sock; installExceptionHandler hnd }"
16:28:54 <merijn> eh, assume the last one also hands the handle of to some chan/mvar
16:29:17 <merijn> I'm not sure how I'd rewrite that using bracket?
16:30:01 <c_wraith> accept and install the exception handler is the initialization.  Whatever hands it off is the main action.  Cleanup is whatever you want.
16:30:32 <merijn> c_wraith: btw, you don't need to mask exception handling code, all the handlers in Control.Exception have an implied mask
16:30:50 <c_wraith> yes, they already did it.
16:31:03 <c_wraith> You only need to mask if you're adding new exception-handling primitives
16:32:32 <DiegoNolan> with the haskell -> js compilers can you write js like you write html is blaze?
16:32:43 <DiegoNolan> in blaze*
16:34:29 <merijn> c_wraith: hmm, that way I end up writing "bracket foo (return ()) (return ())"
16:34:41 <merijn> eh, "bracket_"
16:34:49 <luite> DiegoNolan: Lethalman has made a blaze renderer for ghcjs, but there is still a problem with encoding strange characters (blaze encodes entities, but the dom functions don't expect them)
16:35:45 <DiegoNolan> hmm
16:36:07 <merijn> hmm, actually even bracket and mask leave room for a leak, I guess
16:36:20 <luite> DiegoNolan: he mentioned that he found the problem earlier today, maybe he already has a fix
16:36:38 <merijn> If you block on a retrying transaction while registering the handler I can still get interrupted
16:36:47 <DiegoNolan> what about haste and fay
16:37:01 <c_wraith> You need to plan for failure.  Don't worry that there are cases where exceptions can get in.  Just make sure that when things fail, they fail cleanly
16:37:02 <luite> fay has no type classes, so i'm not sure if it works
16:37:25 <luite> dunno about haste, i think it could work with the right bindings
16:37:42 <merijn> c_wraith: Failing cleanly means setting this stuff up without exceptions getting in, as that means leaking file descriptors
16:38:25 <merijn> Time to dig out by horrific double mask code
16:43:11 <hpaste> merijn pasted “Safe resource allocation” at http://lpaste.net/91163
16:43:27 <merijn> I think that's basically the only real safe way to avoid resource leaks
16:43:30 <Ghoul_> Does base have a Resource type?
16:44:01 <Ghoul_> A monad that allows you to clean up things if exceptions and such are thrown, automatically
16:44:16 <Ghoul_> (I'm aware of ResourceT in conduit..)
16:44:27 <merijn> Ghoul_: No, only things like bracket
16:44:31 <pxqr> Ghoul_: base have no such monad
16:44:51 <Ghoul_> ok. then resourcet it is.
16:57:05 <Cheery> hi
16:57:19 <roconnor> hi
16:57:46 <Cheery> I ended up writing a lambda calculus evaluator after playing with hindley-milner.
16:58:03 <Cheery> it was slightly terrible.
16:58:33 <roconnor> an evaluator is somewhat easier than type inference.
16:58:50 <roconnor> in a certain sense
16:59:16 <Cheery> I'll get back to writing a compiler to my language.. but I started to be curious about how haskell compiles again.
16:59:37 <Cheery> thought I could fullfill that curiousity first.
17:00:46 <Cheery> scanned papers about spineless taless machine and eval/apply, but didn't manage to understand it all yet.
17:01:31 <joehillen> Cheery: have you seen this? https://en.wikibooks.org/wiki/Haskell/Graph_reduction
17:02:11 <Cheery> I might have, but I don't  remember the contents. I get to reading it
17:02:12 * hackagebot dns 0.3.7 - DNS library in Haskell  http://hackage.haskell.org/package/dns-0.3.7 (KazuYamamoto)
17:17:39 <Cheery> joehillen: I read it through
17:33:02 <Cheery> it seems simple, but I don't understand any of it
17:34:34 <Cheery> well graph reduction is simple - functional program always reduces to same result - therefore we can memoize the reduction result.
17:38:33 <dibblego> how do I refer to (<*>) in haddock comments? It renders as a href to * by surrounding with <>
17:38:35 <Cheery> also the program gets uncurried, which seems to make sense too.
17:39:32 <startling> dibblego, even in ''?
17:39:53 <dibblego> you mean ``? even then
17:40:01 <startling> er yeah. ugh.
17:40:16 <startling> to be honest, I forget haddock syntax every time.
17:40:28 <dibblego> I got it
17:40:29 <dibblego> @\<*\>@
17:40:29 <kappabot> Unknown command, try @list
17:40:41 <enthropy> if you actually type '<*>', you might get a hyperlink to Control.Applicative.<*> though
17:40:56 <dibblego> I don't, I get a <a href="*"
17:41:14 <dibblego> also, I am not using Control.Applicative here
17:42:03 <enthropy> well the hyperlink should point to the version that is in scope there
17:42:16 <dibblego> how would you do that?
17:42:17 <startling> so long as <*> does not get misparsed.
17:42:38 <startling> try '\<*\>'
17:42:48 <dibblego> er `<*>` seems to work, wasn't before, I promise!
17:43:09 <ogew2> Hi, can anyone explain to me how Foldable can provide foldr for free if we implement foldMap please
17:43:48 <dibblego> ogew2: I have the equivalence using scala here https://gist.github.com/tonymorris/4366536
17:44:17 <dibblego> ogew2: one way to demonstrate it to yourself is by creating the data type using foldMap, then implementing all the [] functions to see that they are derivable
17:44:21 <enthropy> dibblego: ` and ' are different keys http://lpaste.net/91164
17:44:26 <ogew2> Thanks, I am reading it right now
17:44:37 <dibblego> enthropy: yeah I was using ` the whole time; I don't know what I missed
17:44:52 <dibblego> ogew2: I can convert it to haskell if that scala is too noisy (I wouldn't blame you)
17:44:55 <enthropy> well I'm suggesting to use ' instead of `
17:45:08 <dibblego> enthropy: oh right
17:46:47 <ogew2> let me try first, despite I have 0 experience in scala
17:46:50 <ogew2> =)
17:47:19 <dibblego> ogew2: scala is terrible for demonstrating this point — I just had that code lying around.
17:48:31 <ogew2> yea... i will appreciate it converted if it isnt too much trouble
17:49:41 <dibblego> ok, give me a bit
17:50:04 <dibblego> trying to organise this functional programming course, squeezing people into a room that won't fit — it's going to be cuddly
17:50:42 <ogew2> saw the course, checking it out. ;)
17:51:25 <CaptainK> Is there a spanish GHC? where reserved words are in spanish for example "Verdad" for "True"?
17:51:50 * CaptainK guys are sleeping over at #haskell.es
17:52:20 <CaptainK> or is all programming done in english? Just curious.
17:54:11 <joelteon> i honestly doubt there's a version of base with data constructors translated into spanish
17:54:58 <mapreduce> CaptainK: Programming is done in English.  You could always define stuff though.
17:55:07 <Cheery> I love localization gone too far
17:55:37 <Cheery> it's that lovely smell of your brain burning.
17:55:43 <johnw> I think it would Verdadero, anyway
17:56:04 <CaptainK> ya that would be too much to support in all the languages.  Curious though, english rules the roost there.
17:56:45 <johnw> not just english, but left-to-right, decimal, gregorian, solar, rules the roost :)
17:56:51 <CaptainK> Verdadero....too long...glad its in english
17:56:55 <mapreduce> CaptainK: Even when I was working with a Spanish client while working in Argentina, and the client wanted all docs in Spanish, the code had to be in English.
17:57:33 <adnap> Is there something simpler than (\x -> if x then trace "hello" x else x)
17:57:56 <johnw> so, x is a Bool?
17:58:00 <adnap> Yeah
17:58:14 <CaptainK> mapreduce: ok, thats interesting...thinking of going to Argentina, so good to know...need to improve my spanish, but only for documentation and of course basic communication
17:58:28 <johnw> i can't really think of anything simpler
17:58:35 <mapreduce> go somewhere else. :)
17:59:02 <johnw> adnap: that's the beauty of being able to define functions, though :)
17:59:06 <CaptainK> mapreduce: not so great a place for programmers?
17:59:13 <adnap> johnw: What?
17:59:29 <johnw> traceTrue = ...
17:59:34 <adnap> Er...
17:59:36 <adnap> okay
17:59:58 <adnap> It's not beautiful IMO
18:01:32 <johnw> well, if you wanted to represent truth as Just (), then you could say: x *> trace "hello" x
18:01:48 <johnw> but the savings is offset by an equal cost I'd say
18:04:17 <SLi> Is there an easier way to iterate a function f :: x -> Maybe x until it returns Nothing and collect the results into a list than what I came up with: unfoldr (fmap (join (,)) . f)? Feels like I'm probably missing some really simple function here :)
18:04:27 <haasn> :t let if' t f b = if b then t else f in join $ if' (trace "hello") id
18:04:29 <kappabot> Not in scope: `trace'
18:04:38 <haasn> :t let if' t f b = if b then t else f in join $ if' (id) id
18:04:39 <kappabot> Bool -> Bool
18:04:41 <johnw> :t Control.Monad.Loop.whileJust
18:04:42 <kappabot> Couldn't find qualified module.
18:04:46 <johnw> :t Control.Monad.Loops.whileJust
18:04:47 <kappabot> Couldn't find qualified module.
18:05:05 <haasn> kappabot is shachaf's?
18:05:32 <SLi> Hmm, whileJust.
18:05:41 * CaptainK loves that there is a spanish haskell channel.
18:06:34 <SLi> whileJust :: Monad m => m (Maybe a) -> (a -> m b) -> m [b]
18:06:54 <SLi> I'm not sure how to use that...
18:07:26 <SLi> Substituting either [] or Maybe for m makes it look a bit weird :)
18:07:32 <johnw> one sec
18:07:59 <enthropy> SLi: substitute Identity then?
18:08:03 <shachaf> SLi: Yes, it's not going to be useful with those monads.
18:08:20 <shachaf> enthropy: It's going to be even less useful with Identity!
18:08:32 <Ghoul_> am I supposed to be able to use environmental variables in my cabal config?
18:08:34 <johnw> iterateWhile isJust xs
18:08:41 <johnw> I think that's what you want
18:08:59 <SLi> Ah, right. Makes a lot of sense :) Thanks!
18:09:21 <johnw> > catMaybes [Just 10, Just 20, Nothing, Just 30]
18:09:25 <kappabot>   mueval-core: Time limit exceeded
18:09:29 <johnw> or maybe catMaybes
18:09:29 <haasn> that won't stop at Nothing
18:09:33 <johnw> oh, true
18:10:19 <johnw> and iterateWhile is not doing what I expect with the list monad
18:10:51 <dibblego> ogew2: https://gist.github.com/tonymorris/6067410
18:11:19 <johnw> > takeWhile isJust [Just 10, Just 20, Nothing, Just 30]
18:11:20 <haasn> basing this off unfoldr is really the most idiomatic way that comes to my mind
18:11:23 <kappabot>   mueval-core: Time limit exceeded
18:11:24 <shachaf> unfoldr seems reasonable to me.
18:11:30 <johnw> composing that with catMaybes would do it too
18:11:37 <shachaf> Anything that uses Bool seems unreasonable to me. Maybe is a better Bool than Bool here.
18:11:48 <enthropy> shachaf: I see now. For some reason I didn't recognize that 'a' and 'b' in whileJust are different
18:12:00 <shachaf> Also, over-@pling seems unreasonable to me. Do you really find (fmap (join (,)) . f) readable?
18:13:00 <SLi> I find it slightly unreadable, but I'm not sure how to make it better without using explicit recursion :p
18:13:06 <enthropy> @ty \f -> map fromJust . takeWhile isJust . iterate (f =<<) . Just
18:13:07 <ogew2> dibblego: thanks, that helps. lemme comprehend
18:13:07 <kappabot> forall b. (b -> Maybe b) -> b -> [b]
18:13:11 <chrisdotcode> hey guys :)
18:13:29 <shachaf> :t \f -> unfoldr (\x -> (x,) <$> f x)
18:13:31 <kappabot>     Not in scope: `unfoldr'
18:13:31 <kappabot>     Perhaps you meant `foldr' (imported from Prelude)
18:13:31 <kappabot> Illegal tuple section: use -XTupleSections
18:13:40 <SLi> Maybe with \x -> (x,x)
18:13:43 <shachaf> :t \f -> Data.List.unfoldr (\x -> (,) x <$> f x)
18:13:44 <kappabot> forall a. (a -> Maybe a) -> a -> [a]
18:14:36 <FreeFull> :t join (,)
18:14:37 <kappabot> forall a. a -> (a, a)
18:15:18 <johnw> :t id &&& id
18:15:20 <kappabot>     Not in scope: `&&&'
18:15:20 <kappabot>     Perhaps you meant `&&' (imported from Prelude)
18:15:40 <FreeFull> @let import Control.Arrow
18:15:40 <kappabot>  Invalid declaration
18:15:50 <shachaf> OK, too much kappabot abuse.
18:15:55 <shachaf> kappabot: @part #haskell
18:16:02 <haasn> join (&&&) -- modulo newtypes
18:16:04 <shachaf> Nothing is working anyway.
18:16:09 <haasn> with the Kleisli Maybe arrow
18:17:01 <haasn> unfoldr . runKleisli . join (&&&) . Kleisli :: (b -> Maybe b) -> b -> [b]
18:17:25 <shachaf> Not recommended.
18:21:49 <ogew2> I am still at LYAH level, so I gone through same real world codes, is it true you can store a function in a newtype/record? A value constructor can take in a function as parameter?
18:22:45 <Gracenotes> indeed
18:23:28 <shachaf> Functions are pretty much like any other value.
18:23:36 <Gracenotes> for newtypes, at least, you might have an object Foo, a constructor Foo, and an accessor runFoo. (as matter of convention)
18:23:52 <shachaf> "object" meaning "type".
18:23:56 <ogew2> thanks, i understood <dibblego> ogew2: https://gist.github.com/tonymorris/6067410 now
18:24:03 <Gracenotes> er, yeah, type name
18:24:30 <ogew2> for concrete type will get getSomething eh?
18:24:45 <shachaf> Eh. "get", "run".
18:24:53 <ogew2> i saw appEndo
18:25:01 <shachaf> There's surprisingly little distinction.
18:26:16 <ogew2> appreciated
18:26:41 <Gracenotes> there is a GSOC to make record naming better
18:27:05 <Gracenotes> although it looks a bit ugly tbh
18:27:08 <dibblego> ogew2: no problem
18:28:04 <Gracenotes> (just kidding. the notation is standard enough for structural subtyping)
18:31:50 * tabemann is really wishing there were some way to share names between records in the same module
18:51:31 <Moggle_> hi there, i'm installing accelerate on windows with msys and I'm getting the error "Loading package hashtables-1.1.0.2 ... ghc.exe: Unknown PEi386 section name `.eh_frame'", I don't suppose anyone knows of a simple fix for this?
18:52:01 <Moggle_> so far as google has been telling me, it has something to do with a GHC bug and/or msys doing something weird with a linker script
18:52:29 <danharaj> does anyone know if the structures in unordered-containers are spine strict or lazy?
18:54:12 <shachaf> danharaj: I would bet on spine-strict, knowing tibbe.
18:54:14 <shachaf> preflex: seen tibbe
18:54:15 <preflex>  tibbe was last seen on #haskell 40 days, 4 hours, 46 minutes and 59 seconds ago, saying: elliott: he might not see it, we're both pretty busy
18:54:24 <danharaj> yes that's what I suspect
18:56:32 <Ghoul_> thoughtpolice: the unknown section name thing is a little ridiculous
18:56:48 <Ghoul_> Why does it insist on pointing out unknown sections rather than just checking for required known sections?
19:42:16 * hackagebot splot 0.3.9 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.9 (EugeneKirpichov)
19:48:39 <johnw> splot is very handy
19:52:10 <FSean> Hello everyone.
19:55:29 <FSean> I have a question. I've been learning Haskell for a few days now coming from FSharp, and I very much enjoy the language. Some of its features really tickle my fancy. But, it seems like I have to fight it constantly to get anything to work. I'm not talking about the program not compiling, thought
19:56:56 <FSean> But my problems are more with trying to find a development environment I don't have to fight with to start a new program with, or with trying to figure out how to compile to an executable.
19:57:27 <FSean> I'm a Windows user. Does that have anything to do with it? I've read things about Haskell not liking windows very much.. hehe
19:57:28 <Crockeo> Were you working with F# in an IDE?
19:57:30 <shachaf> I'm going to guess that you're using Windows and part of the trouble is coming from that.
19:57:44 <FSean> Yes. FSharp in visual studio
19:57:58 <Crockeo> Okay, well, that in addition to using Windows is probably creating the feeling.
19:58:19 <shachaf> A lot of people just use a text editor and a command line to work with GHC. Have you been trying to avoid that?
19:58:44 <mapreduce> I've found that 'raw' Haskell works fine on Windows, it's only if you're trying to use dependencies when things get harder (also on OS X)
19:58:53 <shachaf> If you're particularly looking for an IDE etc. I can understanding that you'd run into trouble. :-)
19:58:53 <Crockeo> Agreed with mapreduce, actually
19:58:56 <shachaf> (Though some things exist.)
19:59:16 <Crockeo> (Like Leksah! But I don't know how that's actually doing these days.)
19:59:21 <FSean> I've resulted in using Notepad++ with ghc. But I'm not sure how compiling works. I've only figured out how to run a script in ghc like an interpreter
19:59:38 <FSean> I've tried leksah, and it's very nice. But making a new
19:59:42 <shachaf> I assume it's just "ghc foo.hs"
19:59:43 <Crockeo> Have you ever used gcc before? (GNU Compiler Collection)
19:59:43 <FSean> project isn't easy.
19:59:59 <shachaf> If that doesn't work, what have you tried?
20:00:12 <FSean> Yeah C++ is where I'm from before F# ^_^
20:00:14 <Crockeo> 'Cause some of the flags (namely just the -o flag) are somewhat reminiscent of gcc
20:00:45 <FSean> Things like "packages" I don't understand.
20:00:48 <shachaf> Not that you need to use -o in general.
20:00:52 <Crockeo> ^ True
20:00:58 <Crockeo> Just when you want really cool names
20:01:05 <shachaf> FSean: People will be much better able to help you if you ask for help with a concrete problem.
20:01:05 <Crockeo> (that aren't what it's already named)
20:01:46 <Crockeo> I have found that installing dependencies is a bitch on Windows.
20:02:01 <Crockeo> Albeit I haven't tried that hard to learn.
20:02:21 <FSean> Okay. When I open GHCi, it doesn't take any commands - just interprets haskell code
20:03:41 <shachaf> You're not asking a question that people can help with, exactly. :-)
20:03:43 <Crockeo> Either open a file with ghci ("ghci <filename>") or while in ghci load a file (":l <filename")
20:04:01 <FSean> I want to know how to compile a script into a program. Sorry, lol.
20:04:08 <Crockeo> "ghc <filename>"
20:04:21 <Crockeo> and, if there are no errors, it should work
20:04:22 <shachaf> Do you know how to use a command line?
20:04:37 <FSean> It's trying to interpret that as Haskell code
20:04:40 <FSean> haha
20:04:57 <Crockeo> Type that in while just using the command prompt rather than ghci
20:05:18 <FSean> Oh. Okay
20:05:47 <Crockeo> generally commands in ghci (there aren't any exceptions as far as i know) are prefaced with a ':'
20:06:13 <Crockeo> (Also, welcome to the wonderful land of Haskell. I promise you'll never leave after you get over the first few humps.)
20:07:04 <Crockeo> Also, quick question. Is there any way to quickly remove cabal packages (on windows), or do I just have to find where they're installed and uninstall them
20:07:09 <shachaf> Crockeo: Why would you promise that?
20:07:36 <FSean> Thank you. Like I said the language is very pleasing to me -- it's just I have to fight with it to accomplish anything. Whereas in F# (another very attractive language) I use Visual Studio, which is an amazing piece of software in my opinion.
20:07:54 <Crockeo> VS, no matter how much hate it gets, is fantastic.
20:07:58 <Crockeo> (at least imo)
20:08:42 <Crockeo> shachaf: Well, maybe he'll leave? I'unno in the end. Haskell seems to trap people into its elegance once they learn it.
20:08:44 <monochrom> Crockeo: use "ghc-pkg unregister". read my http://www.vex.net/~trebla/haskell/sicp.xhtml , even though it only tells linux directory names
20:09:01 <Crockeo> (thank you monochrom!)
20:10:15 <FSean> Have any of you messed with F#? It's based on ML languages but has syntax similarities with Haskell, too.
20:10:30 <monochrom> I am not interested in syntax similarities
20:10:44 <Crockeo> Touched it once before i understood functional programming, decided it was too hard and walked away
20:10:58 * Clint can't tell who's trolling whom
20:11:01 <monochrom> it's like saying "Mongolia uses the Russian alphabet"
20:11:31 <FSean> Some of the features in F# are pretty awesome
20:11:42 <dmwit> That's true!
20:11:45 <dmwit> However, this is a Haskell channel.
20:11:56 <Crockeo> Haha
20:12:25 <Crockeo> but i mean, come on, we can talk about comparing haskell and f# for just a bit
20:12:36 <Crockeo> *Prepares to get thrown out*
20:13:08 <haasn> as far as I'm aware, syntax similarities is pretty much where it ends
20:13:28 <Crockeo> alright, discussion is over then! fantastic
20:13:35 <shachaf> Crockeo: It would be better if you didn't say things that you felt obligated to follow with "*Prepares to get thrown out*" in the first place.
20:15:06 <monochrom> I prefer haskell because it satisfies: for every expression E of the right type, (\x -> x+x) E = E+E. very few languages satisfies this property.
20:15:32 <Hafydd> FSearp
20:15:53 <haasn> monochrom: yeah, like unsafeDupablePerformIO
20:15:53 <monochrom> (\x -> x+x) E != E+E is why programming makes you pull your hair
20:16:42 <FSean> lambda in fsharp is just
20:16:45 <FSean> fun x -> x+x
20:16:50 <FSean> (it's more fun)
20:17:07 <monochrom> does it satisfy (fun x -> x+x) E = E+E?
20:17:19 <haasn> monochrom: fairly sure it doesn't
20:17:38 <Crockeo> because if not then i have a feeling monochrom's gonna tear F# a new...
20:17:48 <haasn> more likely “not use it”
20:17:51 <shachaf> Crockeo: Come on.
20:18:00 <monochrom> that's my beef. and it's a semantics question, not a syntax question. I couldn't care less about syntax.
20:18:20 <dmwit> Don't blame this conversation on Crockeo.
20:18:37 <Crockeo> i'm just commenting immature things from the sidelines
20:18:52 <dolio> I care about syntax.
20:18:57 <FSean> Things like printf ( [1..100] |>List.Filter(fun x -> x % 2 = 0) ) tickle my fancy for some reason
20:18:58 <dmwit> Okay. You can blame immature sideline taunts on Crockeo. Then I agree "come on" is the right response.
20:19:32 <dmwit> > [x | x <- [1..100], x `mod` 2 == 0]
20:19:35 <Hafydd> That's pretty ugly.
20:19:45 <dmwit> Oh, do we not have a bot?
20:19:49 <Crockeo> (But in all reality FSean, while I don't mean to go and scold you, this is a Haskell channel)
20:19:56 <dmwit> > [x | x <- [1..100], x `mod` 2 == 0]
20:19:59 <shachaf> Let's see if this works any better now.
20:20:00 <kappabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
20:20:00 <Hafydd> > filter ((==0) . (%2)) [1..100]
20:20:04 <kappabot>   []
20:20:05 <haasn> > filter even [1..100]
20:20:08 <kappabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
20:20:12 <FSean> @Crockeo yes i understand. Sorry
20:20:12 <kappabot> Unknown command, try @list
20:20:13 <haasn> > [2,4..100]
20:20:16 <kappabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
20:20:18 <haasn> there
20:20:29 <Hafydd> > filter ((==0) . (`mod`2)) [1..100]
20:20:32 <kappabot>   mueval-core: Time limit exceeded
20:20:39 <Hafydd> Well, you get the idea.
20:20:58 <shachaf> We got the idea back at the very first demonstration, I think.
20:21:02 <adnap> haasn's is the prettiest
20:21:08 * haasn blushes
20:22:12 <Hafydd> The very first demonstration contained redundancy.
20:22:59 <dmwit> The very first translation was supposed to be a transliteration to compare syntax, because I was curious how Haskell's syntax for that kind of thing would look.
20:23:38 <adnap> Why does a type have to satisfy for the [x,y..z] pattern to work? Does it only work on numbers?
20:23:41 <dmwit> I subjectively prefer % over `mod`, but Haskell's syntax for basically every other part.
20:23:41 <adnap> *What
20:23:45 <dmwit> adnap: Enum
20:23:45 <haasn> dmwit: printf ( [1..100] |>List.filter(\ x -> x % 2 == 0) ) -- naturally
20:24:12 <dmwit> :t \a b c -> [a,b..c] -- how to ask mechanically
20:24:13 <kappabot> forall t. Enum t => t -> t -> t -> [t]
20:24:38 <FSean> What I showed in my example kind of reminds me of Haskell's where clause. you define what you're modifying or "talking about" first, then each expression you use for it starts with a |>
20:24:52 <haasn> dmwit: (breaks down on expressions that rely on a, b or c being polymorphic, of course)
20:25:14 <haasn> FSean: that's nothing like Haskell's ‘where’
20:25:18 <dmwit> haasn: ah
20:25:23 <haasn> where introduces additional definitions. It does not modify expressions in any way
20:25:32 <dmwit> :t let (a, b, c) = undefined in [a,b..c]
20:25:38 <kappabot> forall t. Enum t => [t]
20:25:46 <haasn> what you describe is standard function application. Haskell has that, even the other way around if you fancy
20:25:50 <FSean> My terminology isn't very accurate.
20:25:53 <FSean> : )
20:25:54 <enthropy> @ty enumFromThenTo
20:25:56 <kappabot> forall a. Enum a => a -> a -> a -> [a]
20:26:08 <adnap> I'm looking at http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/GHC-Enum.html#t%3AEnum I can't find where it says what the minimal complete definition of an instance is
20:26:10 <haasn> > let (|>) = flip ($) in [1..10] |> filter even |> take 10
20:26:14 <kappabot>   [2,4,6,8,10]
20:26:28 <dmwit> adnap: The minimal complete definition (in the absence of a declaration otherwise) is everything.
20:26:41 <haasn> oops, meant [1..100] but you get the idea
20:26:59 <FSean> But anyways -- So my experience with Haskell would be smoother if I used a GNU+Linux distro?
20:27:03 <dmwit> (Though it seems this particular class doesn't require everything.)
20:27:32 <haasn> FSean: GHC works fairly well on Windows, but some libraries might not
20:27:37 <adnap> dmwit: "this particular" seems to imply there is more than one Enum class
20:27:38 <haasn> I think everything that requires OpenGL basically breaks down
20:27:38 <enthropy> adnap: look at the source http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/src/GHC-Enum.html#Enum ?
20:27:55 <dmwit> adnap: Not at all. It implies there is more than one class.
20:28:23 <enthropy> which suggests all you need is toEnum and fromEnum
20:28:29 <adnap> Yeah
20:28:51 <haasn> (`plusInt` oneInt) O.o
20:28:55 <adnap> dmwit: I don't understand your point
20:29:23 <dmwit> As a general rule, the minimal complete definition is everything unless stated otherwise. Enum is an exception to this rule.
20:29:28 <dmwit> Is that more clear?
20:29:30 <adnap> YEs
20:30:30 <dmwit> FSean: I think Windows is sort of a second-class citizen in the Haskell world.
20:30:34 <dmwit> But it's definitely workable.
20:30:49 <haasn> FSean: of course, if you ask me, your experience with Haskell would be smoother on a Linux distro but that has little to do with Haskell ;)
20:30:49 <monochrom> adnap: http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 , then scroll down or look for "-- Enumeration and Bounded classes"
20:33:02 <FSean> Thanks for the information, folks. I have to go now -- cya : )
20:33:22 <Crockeo> Cya!
20:33:38 <Crockeo> Hope you do well in your learning-Haskell journey
20:34:06 <dmwit> Whoa, cool question. http://stackoverflow.com/q/17822539/791604
20:36:54 <Crockeo> quick question, in the definition of a (potentially naive) fibonacci function (fib 0 = 0, fib 1 = 1, fib n = fib (n - 1) + fib (n - 2), or something like that) have to go through every iteration upon calculation, or would it just 'remember' that fib x is always constant?
20:37:34 <Crockeo> would it have to go through*
20:37:35 <shachaf> I can't parse your question
20:37:38 <shachaf> Ah.
20:37:50 <haasn> dmwit: how long until somebody writes a type-level benchmarking suite
20:37:50 <shachaf> What's "it"?
20:37:50 <jmcarthur> Crockeo: it will not automatically memoize the function
20:38:14 <monochrom> it will not remember
20:38:14 <jmcarthur> Crockeo: ghc, that is. other implementations are of course allowed
20:38:20 <jmcarthur> Crockeo: the language does not specify that this optimization should happen, though, and ghc will not perform it
20:38:20 <haasn> Crockeo: the compiler doesn't ‘remember’ that fib x = y for some ‘x’ across different applications of the function
20:38:31 <monochrom> however, it will remember that fib is always constant :)
20:38:48 <silasm> can anyone recommend a good reference on when things /are/ automatically memoized in ghc?
20:39:03 <silasm> cause that's always bothered me.
20:39:09 <Crockeo> okay, so in terms of generating fibonacci numbers, something like "let list = 0 : 1 : [list !! (n - 1) + list !! (n - 2) | n <- [2 ..]]" would be faster, right?
20:39:37 <haasn> you're going to have a lot of overhead on (!!)
20:39:42 <silasm> I don't know about the !!'s. I know the ziplist method works.
20:39:44 <Crockeo> because it would be working off the last two, already generated, numbers rather than going through it every single time for every single new term
20:39:51 <shachaf> haasn: It would still be better.
20:39:54 <haasn> you're better off passing around the last two numbers via recursion
20:39:54 <dmwit> haasn: I'd be thrilled if that was the upshot. =)
20:40:11 <monochrom> your second method is quadratic. it's faster than the first method, exponential.
20:40:35 <dmwit> silasm: Things are not automatically memoized in GHC. NEXT!
20:41:16 <shachaf> It is quadratic or perhaps worse with the monomorphism restriction?
20:41:20 <shachaf> Er, without.
20:41:27 <haasn> the realization of how non-magical GHC is can sometimes be crushing when learning Haskell for the first time :)
20:41:37 <silasm> dmwit: really?! Well that makes things a lot simpler. To the explicit memoization page!
20:42:24 <hpaste> Crockeo pasted “quick fib” at http://lpaste.net/91165
20:42:42 <silasm> haasn: automatic memoization has some really really serious potential performance issues that would be really confusing. IMO lazy evaluation comes with enough gotchas as it is; I'm kind of glad to hear it doesn't have automatic memoization.
20:42:46 <dmwit> haasn: Yup. And then you get really deep into Haskell, and learn how magical GHC is, and you get uncrushed again.
20:42:49 <Crockeo> so ultimately (even though it would quickly wrap around 'cause of Int's bounds) that would be the fastest, yeah?
20:43:39 <haasn> I take it explicit memoization serves peoples needs fine either way?
20:43:50 <dmwit> Crockeo: That's a pretty good way to do it. Have you seen the "no arguments" version of that?
20:44:04 <dmwit> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:44:05 <haasn> dmwit: do you mean the pointless version?
20:44:08 <kappabot>   mueval-core: Time limit exceeded
20:44:09 <mgsloan> dmwit: Well, you could consider CAFs / sharing to be kinda like memoization.  The difference being that there's no lookup based on an input
20:44:13 <dmwit> haasn: I don't mean the pointless version.
20:44:15 <dmwit> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:44:19 <kappabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:44:38 <stevejb> hello, I am having trouble getting the tests to run for hmatrix ( http://hackage.haskell.org/package/hmatrix )
20:44:57 <stevejb> specifically on Ubuntu 13.04
20:44:59 <dmwit> stevejb: Are you on x86_64 and using runhaskell or ghci?
20:45:00 <haasn> > let fibs = scanl (+) 0 (1 : fibs) in fibs
20:45:02 <dmj> isnt using scanl and (!!) a form of memoization?
20:45:04 <kappabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:45:05 <stevejb> ghci
20:45:20 <stevejb> dmwit: trying to run Numeric.LinearAlgebra.Tests.runTests 20
20:45:35 <stevejb> and yes, 64 bit
20:45:37 <monochrom> "fibs = scanl (+) 0 (1 : fibs)" is explained in my http://www.vex.net/~trebla/haskell/scanl.xhtml
20:45:37 <mgsloan> silasm: Here's using the sharing of CAFs to implement memoization: http://www.haskell.org/haskellwiki/Memoization#Memoising_CAFS
20:45:54 <haasn> I wonder if there's a name for scanl mappend mempty
20:45:56 <dmwit> stevejb: It's possible that compiling your code will turn a segfaulting or bus-erroring program into a correctly running program.
20:46:06 <monochrom> however, scanl tricks don't generalize
20:46:25 <stevejb> dmwit: I tried to compile and I got an error about cblas
20:46:26 <dmwit> dmj: Yes, it is a form of memoization.
20:46:50 <haasn> (though you'd probably be better off with something other than [] and (!!) for looking things up)
20:47:02 <dmwit> stevejb: Okay; I should probably wait for you to say what your problem is instead of guessing, then. =)
20:47:09 <monochrom> no, I would attribute the memoization to "fib = ... fib ..." rather than scanl
20:47:37 <hpaste> stevejb pasted “compile with hmatrix error” at http://lpaste.net/91166
20:47:44 <stevejb> dmwit: I pasted it as shown above
20:47:50 <dmj> haasn: how else would you do a lookup on an infinte sequence generated by scanl?
20:48:07 <dmj> just curious
20:48:11 <dmwit> stevejb: Have you installed cblas...?
20:48:37 <dmj> instead of (!!)
20:48:40 <stevejb> dmwit: yes, but it is the version that came with Intel's MKL
20:48:47 <stevejb> dmwit: I believe. I can double check
20:49:32 <dmwit> stevejb: I recall when I was trying to install hmatrix, I had a hell of a time working out just which packages I needed.
20:49:33 <dmwit> stevejb: For some distributions, hmatrix has some documentation about which packages to install.
20:49:34 <dmwit> stevejb: So you might check there.
20:50:03 <haasn> dmj: I'm not sure what the best solution would be. Perhaps there's some sort of tree-like structure that could be used to memoize fibs while still enjoying the benefits of infinite generation, perhaps via unsafePerformIO tricks
20:50:05 <stevejb> dmwit: thank you. I am on Ubuntu. I will check there
20:50:29 <haasn> (and giving you log n lookup of specific entries)
20:51:08 <dmwit> haasn: oooo, I like that idea a lot
20:51:20 <jmcarthur> i think there are limited forms of automatic memoization that could make sense. certain kinds of dynamic specialization.
20:51:21 <dmwit> Turn the usual repeated-squaring-of-a-matrix trick into an infinite tree of all squarings.
20:51:49 <dmwit> Your index is a lazy bitstring, least-significant-bit-first.
20:51:56 <dmwit> That seems do-able!
20:51:59 <jmcarthur> haasn: what you are describing reminds me of memotrie or memocombinators
20:52:06 <haasn> dmwit: in two lines you first made me feel proud and then dumbfounded
20:53:03 <dmwit> Oh, do you know the way to compute Fibonacci numbers as matrix exponentiation?
20:53:28 <haasn> no
20:53:49 <dmj> haasn: my imperative mind was thinking binary search, until I realized it would be hard to know the length on an infinte sequence :) Adding to a tree would be nice. Constant time generation of value, log(n) insertion into tree, log(n) lookup. So the scanl would have to generate a tree as it accumulates... kind of interesting idea
20:53:51 <haasn> jmcarthur: yes that looks related; giving you two functions one for a -> b and the other for [(a, b)]
20:53:51 <dmwit> ?let data Matrix a = Matrix a a a a {- top left, top right, bottom left, bottom right -}
20:53:51 <stevejb> dmwit: I think that the problem is related to this: http://askubuntu.com/questions/69316/problems-with-linking-gsl-cblas
20:53:51 <kappabot>  Invalid declaration
20:54:05 <dmwit> Oops, kappabot is old lambdabot.
20:54:16 <dmwit> > (1, 1) + (2, 1)
20:54:20 <kappabot>   mueval-core: Time limit exceeded
20:54:24 <jmcarthur> haasn: i mean the way they work
20:54:32 <haasn> lambdabot just hasn't been the same since the brain surgery
20:55:44 <jmcarthur> haasn: they are basically just lazily generated tries. there is no unsafePerformIO. it just uses lazy evaluation of the trie to drive the memoization itself
20:55:44 <stevejb> it seems that this is solvable when compiling C/C++ programs. is there a way to chaning the linking order with ghc?
20:55:45 <haasn> jmcarthur: ah, okay
20:55:45 <jmcarthur> > (1, 1) + (2, 1)
20:55:45 <kappabot>   No instance for (GHC.Num.Num (t0, t1))
20:55:45 <kappabot>    arising from a use of `e_11121'
20:55:45 <kappabot>  ...
20:55:45 <jmcarthur> @let import Data.NumInstances
20:55:45 <kappabot>  Invalid declaration
20:55:45 <jmcarthur> :\
20:55:45 <jmcarthur> @undef
20:55:45 <jmcarthur> @let import Data.NumInstances
20:55:45 <kappabot>  Invalid declaration
20:55:45 <jmcarthur> oh well
20:55:53 <haasn> kappabot is not lambdabot
20:55:54 <jmcarthur> stevejb: to what end?
20:55:54 <haasn> unfortunately
20:56:09 <stevejb> jmcarthur: http://askubuntu.com/questions/69316/problems-with-linking-gsl-cblas
20:56:22 <stevejb> I am compiling a program with hmatrix that ultimately depends on (and is facing the same issue) as what is mentioned above
20:56:31 <ne> @def import Data.NumInstances
20:56:31 <kappabot> Maybe you meant: bf do let
20:56:40 <stevejb> jmcarthur: http://lpaste.net/91166
20:56:53 <ne> aw
20:57:48 <dmwit> > let xs *> ys = [[sum (zipWith (*) x y) | x <- xs] | y <- transpose ys] in [[1, 2], [3, 4]] *> [[2, 2], [3, 5]]
20:57:50 <jmcarthur> stevejb: i'm not sure if there is some particular way to control linking order. i know there are ways to link to specific libraries, so maybe it just works if you do it in the appropriate order.
20:57:52 <kappabot>   [[8,18],[12,26]]
20:58:19 <stevejb> jmcarthur: the compile string I am using is `ghc -O2 -threaded -rtsopts -eventlog Sjb_runner_1.hs -o Sjb_runner_1`
20:58:27 <dmwit> Got it transposed by accident.
20:58:28 <stevejb> how do I change the link order on the ghc command line?
20:58:36 <dmwit> haasn: Anyway, that's matrix multiplication.
20:58:41 <dmwit> haasn: Now, watch this...
20:58:45 <dmwit> (hold my beer)
20:58:53 <jmcarthur> stevejb: off the top of my head i don't know. have you checked the documentation?
20:59:09 <shachaf> dmwit: You *could* just link to the Wikipedia page...
20:59:16 <haasn> shachaf: I'm reading https://en.wikipedia.org/wiki/Fibonacci_numbers#Matrix_form right now
20:59:19 <dmwit> > let xs *> ys = transpose [[sum (zipWith (*) x y) | x <- xs] | y <- transpose ys] in iterate (*> [[1, 1], [0, 1]]) [[1, 1], [0, 1]]
20:59:22 <kappabot>   [[[1,1],[0,1]],[[1,2],[0,1]],[[1,3],[0,1]],[[1,4],[0,1]],[[1,5],[0,1]],[[1,...
20:59:27 <stevejb> jmcarthur: searching it now
20:59:43 <gnuvince> Is there going to be an update to RWH?
20:59:48 <dmwit> Oh, Wikipedia's no fun. Screwing up a lot is much more exciting!
20:59:57 <shachaf> gnuvince: So went the rumour, once upon a time.
21:00:01 <shachaf> There was a survey and anything.
21:00:09 <shachaf> I don't know what's happening now.
21:00:30 <gnuvince> shachaf: thank you.
21:02:20 <haasn> dmwit: makes sense, actually
21:02:41 <dmwit> Yeah, I was just grousing up there. Wikipedia is great.
21:03:29 <haasn> it's just like passing along Fn and Fn-1 as variables and using matrix multiplication to add them together and arrange it so that the other field holds the old Fn :)
21:03:51 <dmwit> right =)
21:04:00 <shachaf> haasn: But this lets you do repeated squaring!
21:04:20 <haasn> shachaf: yeah, I saw the implications on the wikipedia page
21:06:41 <ninegrid> well it seems that #regex and #vim are asleep so I was wondering if someone who is smart with regex might could help me accomplish something
21:06:52 <ninegrid> perhaps in a pm
21:12:18 * hackagebot bindings-GLFW 0.1.0 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-0.1.0 (BrianLewis)
21:12:19 * hackagebot GLFW-b 1.2.1 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.2.1 (BrianLewis)
21:15:07 <Crockeo> haasn: I'un even know if you're in the chatroom, but if you are, based off of your scanl example for generating fibonacci terms, I did the same for generating factorials: scanl (*) 1 [1 ..]
21:15:45 <haasn> another example of scanl mappend mempty :)
21:16:55 <haasn> (of course, that one isn't recursive)
21:17:18 * hackagebot GLFW-b-demo 1.0.3 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.3 (BrianLewis)
21:17:20 * hackagebot bindings-sqlite3 1.0.3 - Low level bindings to sqlite3.  http://hackage.haskell.org/package/bindings-sqlite3-1.0.3 (MauricioAntunes)
21:18:33 <haasn> I wonder what kind of interesting sequences can be generated from \x y -> let foo = scanl (*) x (y : foo) in foo
21:19:41 <Crockeo> to the [take 50 $ scanl (*) x (y :-- fuck, no, i can't reference the list inside of itself without doing a let, can i?
21:19:45 <Crockeo> :(
21:20:06 <haasn> stackoverflow doesn't want to accept my reply to that question dmwit linked :(
21:20:18 <Crockeo> :(
21:21:00 <haasn> it doesn't seem to like the form data my browser sends it, or something, because it thinks I entered “,my@email.adr,my@email.adr” (using my actual address)
21:21:28 <Crockeo> well that's super unfortunate
21:21:34 <Crockeo> just leaves me more time to be baffled by the question
21:21:40 <Crockeo> (i haven't actually read it, to be honest)
21:22:31 <sclv> you can register for so using a different openid provider
21:22:40 <sclv> and hook it up to that instead
21:22:49 <sclv> its a corker of a question i gotta say
21:23:07 <sclv> i've done it in the past, but then they fixed those issues so now there are new issues
21:23:14 <jmcarthur> Crockeo: you could also use some other function that uses recursion internally or which uses some recursive type internally
21:23:21 <jmcarthur> :t fix   -- for example
21:23:21 <sclv> and without the code in question and intuition its hard to say which constraints would blow up why
21:23:23 <kappabot> forall a. (a -> a) -> a
21:23:28 <jmcarthur> @src fix
21:23:28 <kappabot> fix f = let x = f x in x
21:23:54 <haasn> Crockeo: ah, works after enabling javascript
21:24:11 <Crockeo> oh the magic of javascript, making things work
21:24:27 <Crockeo> (and also giving you 610398612 viruses, but who cares about that)
21:26:07 <Crockeo> jmcarthur: i'll keep that in mind for tomorrow, but as for right now i think it's time for me to leave and get some zzz's
21:26:09 <monochrom> haasn: have you read my http://www.vex.net/~trebla/haskell/scanl.xhtml ?
21:26:14 <Crockeo> i have a big day of being made to go to the beach tomorrow
21:26:29 <jmcarthur> jealous
21:26:37 <haasn> monochrom: I looked at the fibonacci segment
21:27:29 <monochrom> then continue with "more 2nd-order recurrences"
21:30:22 <haasn> you mean the pell numbers?
21:31:13 <monochrom> I mean in general o2s = a : scanl op b o2s
21:31:27 <monochrom> op=(*) is your special case
21:31:37 <haasn> right
21:32:45 <monochrom> well, I guess yours is a bit different
21:33:13 <haasn> foo = a : scanl (*) b foo should be equivalent to foo = scanl (*) a (b : foo) -- right?
21:34:00 <monochrom> no, there is a fence-post difference
21:36:33 <haasn> oh, (a*b) then
21:36:44 <haasn> where I placed ‘b’
21:36:52 <haasn> in the former case
21:37:30 <haasn> no wonder it works out for fibonacci in particular, because ‘a’ is the identity of ‘f’
21:56:19 <augur_> does anyone know about any texts on the relationship between propositionally-constrained structures vs. algebraically generated structures?
21:58:01 <augur_> i know of only one paper that discusses a relationship, the johann and ghani one, but i was wondering if anyone know of any other stuff, maybe in the context of abstract or universal algebra
22:05:46 <lispy> anyone know of compiler text books that use Haskell as the compiler implementation language?
22:06:06 <lispy> Haskell seems like such a great language for building a compiler, but I can't think of any texts explaining how to build a compiler using haskell.
22:06:18 <lispy> We do a lot of embedded DSLs instead, I think
22:07:55 <Gracenotes> there is the interpreter book
22:08:16 <mstksg> anyone know what's going on with the "::" symbols in this screenshot? https://github.com/dag/vim2hs/raw/master/screenshots/bindings.png
22:08:29 <haasn> lispy: there's always the scheme book, heh
22:09:14 <augur_> lispy: answer my above question, since you're so knowledge about things :D
22:09:22 <Gracenotes> people who work on Haskell and compilers implemented in Haskell etc. might take for granted how much compilers background is needed, sometimes
22:09:34 <sclv> there's appel's tiger book in ML
22:09:39 <haasn> mstksg: maybe that's :: being displayed incorrectly
22:09:45 <sclv> that translates very neatly
22:09:46 <haasn> err, not that
22:09:48 <haasn> the unicode symbol for it
22:10:00 <mstksg> haasn: yeah, it only takes up one column
22:10:12 <haasn> > text "\x2237"
22:10:14 <kappabot>   ∷
22:10:16 <mstksg> does ghc interpret it as the same as ::?
22:10:16 <augur_> mstksg: it could also be idris maybe
22:10:48 <haasn> augur_: does idris even have putStrLn? :P
22:10:48 <Gracenotes> lispy: plus, would you make an imperative compilers textbook, or a functional compilers one?
22:10:54 <augur_> haasn: who knows!
22:11:01 <mstksg> does anyone know if ghc actually interprets it like ::?
22:11:22 <haasn> mstksg: I'm guessing that's your editor only displaying it that way. To answer your question, only if you enable UnicodeSyntax
22:11:35 <haasn> unless, of course, they're actually in the file like that
22:11:37 <Gracenotes> both might be a bit unfocused, mainly because there are highly divergent paths to take on compiling functional languages
22:11:43 <mstksg> haasn: it's not my editor, i saw a screenshot of someone's workstation that had it
22:11:45 <haasn> oh
22:11:57 <haasn> then it might be their editor displaying it that way. yi does something similar, for example
22:12:17 <sclv> tapl in ml arguably gets you through 90% of a compiler too
22:12:29 <sclv> what we don't have covered is codegen, basically
22:12:46 <Gracenotes> and the sometimes-forgotten tapl-in-haskell
22:12:54 <Gracenotes> ...really just a port of ML
22:12:56 <haasn> codegen down to the reduceron or other graph reducing machines
22:12:59 <lispy> Gracenotes: I'm wondering about classic topics in compiler theory. So I guess that assumes imperative language.
22:13:04 <haasn> using EDLSs
22:13:46 <Gracenotes> lispy: is it meant to teach Haskell at the same time?
22:14:19 <Gracenotes> would you do something like ExprF a = Int | Plus a a, with Fix ExprF
22:15:11 <lispy> Gracenotes: either one is fine. I'm just wondering if there is such a book and I just overlooked it.
22:15:40 <Gracenotes> ah. not that I know of. I would help contribute in a non-state-of-the-art manner if an effort were started
22:16:46 <haasn> if the design were like RWH I would go through and add ‘needs more lenses’ in the comments section of every code example
22:18:12 <Gracenotes> let's wait until haskell 2020, when lens is added to the Haskell standard
22:18:50 <haasn> or when Haskell is reimplemented in Lens
22:25:18 <ninegrid> this is absolutely the most helpful channel on freenode
22:29:16 <kvda> ninegrid, it's one of the more populous ones too.
22:30:12 <aaronweiss74> is there a way that I can allow a compiled haskell program on Windows to literally take as much memory as it needs?
22:34:30 <lispy> aaronweiss74: are you running into a 3-4GB boundary?
22:34:34 <lispy> aaronweiss74: what version of ghc?
22:34:47 <lispy> aaronweiss74: it really should take as much as windows allows it to take...
22:35:03 <lispy> unless, you have a 32 bit executable and more than 3-4 GB of ram
22:35:07 <aaronweiss74> lispy: 7.6.3, I tried using rtsopts to set higher but ran into an issue with 32-bit.
22:35:28 <lispy> aaronweiss74: there is a 64bit ghc for windows, but it has severe issues linking
22:35:55 <aaronweiss74> hmm, well, I'll have to try it, thanks
22:54:28 <lispy> Gracenotes: this book appears to cover functional programming and compiler construction (uses ML): http://www.amazon.com/Modern-Compiler-Implementation-Andrew-Appel/dp/0521607647/ref=pd_bxgy_b_text_y
22:58:15 <ddinh> Is there any way to do type restrictions in instance declarations?
22:58:51 <ddinh> e.g. if I have a type "tree a" and I want ta make it an instance of show iff a is an instance of show, is there a way to do it?
22:59:07 <shachaf> instance Show a => Show (Tree a) where ...
22:59:19 <startling> that's not iff.
22:59:44 <shachaf> True. I don't recommend the other direction.
22:59:50 <startling> me neither.
23:00:11 <ddinh> Makes sense.
23:00:15 <ddinh> Thanks, shachaf
23:07:21 <biscarch> is anyone aware of a lib called "selectable"?
23:08:56 <zRecursive> hard to connect irc.freenode.net recently ?!
23:10:38 <zRecursive> @ty flip id
23:10:40 <kappabot> forall b c. b -> (b -> c) -> c
23:11:07 <zRecursive> @ty if
23:11:08 <kappabot>     parse error (possibly incorrect indentation or mismatched brackets)
23:11:12 <zRecursive> @ty id
23:11:13 <kappabot> forall a. a -> a
23:11:42 <zRecursive> @ty flip
23:11:43 <kappabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:12:26 <biscarch> ah, it's Control.Concurrent.Selectable
23:12:58 <biscarch> but I still can't seem to find it...
23:25:27 <haasn> What libraries are there for pretty-printing (binary) trees?
23:25:34 <haasn> I'm looking for something nice and top-down
23:27:34 <lispy> graphviz? ;)
23:27:53 <haasn> oh, looks like Data.Tree.Pretty.drawVerticalTree does it
23:28:21 <lispy> Data.Tree is a rose tree
23:28:28 <lispy> just FYI
23:28:45 <lispy> I don't know how serious you are about the binary part
23:28:55 <haasn> about as serious as “it should look nice for binary trees”
23:29:08 <haasn> come to think of it, I don't just want binary trees either
23:29:13 <haasn> in the future
23:48:52 <hape01> @ty (.)
23:48:54 <kappabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:49:35 <sopvop> I'm tired on making my own Either a b with various instances accumulating 'a', is there any package with it?
23:51:02 <sopvop> like instance Monoid a => Applicative (MyEither a) where  (MyLeft e) <*> (MyLeft e') = MyLeft (e `mappend` e')
23:52:58 <shachaf> What's the rest of that instance?
23:53:09 <sopvop> Same as either
23:56:37 <johnw> does any have a Setup.hs for their cabal project which uses Shake to do some custom build magic?  looking for some examples to peer over
23:57:24 <Ralith> johnw: llvm-general is packaged with, but does not integrate with cabal, a shake build for llvm
23:57:41 <Ralith> though there's been talk of integrating it optionally
