00:02:48 * hackagebot hopfield 0.1.0.0 - Hopfield Networks, Boltzmann Machines and Clusters  http://hackage.haskell.org/package/hopfield-0.1.0.0 (NiklasHambuechen)
00:22:47 <covi> I am using Network.WebSockets.
00:23:06 <covi> Sometimes a websocket connection automatically disconnects after some time
00:23:10 <covi> how can i resolve that?
00:24:46 <Lethalman> @pl \mf a -> do f <- mf; a >>= f
00:24:46 <lambdabot> (line 1, column 20):
00:24:46 <lambdabot> unexpected ';'
00:24:46 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
00:25:21 <Cale> @undo \mf a -> do f <- mf; a >>= f
00:25:21 <lambdabot> \ mf a -> mf >>= \ f -> a >>= f
00:25:28 <Cale> @pl \ mf a -> mf >>= \ f -> a >>= f
00:25:29 <lambdabot> (. (>>=)) . (>>=)
00:25:29 <Lethalman> :t ap
00:25:32 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:25:49 <Lethalman> mh except I have -> m b
00:26:11 <Lethalman> Cale, thanks
00:26:25 <Lethalman> @hoogle m (a -> m b) -> m a -> m b
00:26:26 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:26:26 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:26:26 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
00:27:17 <Lethalman> maybe there's something we can do with =<<?
00:27:45 <Lethalman> :t liftM (=<<)
00:27:46 <lambdabot> (Monad m, Monad m1) => m (a -> m1 b) -> m (m1 a -> m1 b)
00:27:49 <Cale> :t liftM2 (=<<)
00:27:50 <lambdabot> (Monad m, Monad m1) => m (a -> m1 b) -> m (m1 a) -> m (m1 b)
00:27:59 <Cale> :t (join .) . liftM2 (=<<)
00:28:00 <lambdabot> Monad m => m (a1 -> m a) -> m (m a1) -> m a
00:28:09 <Cale> errrr
00:28:12 <Lethalman> :S
00:28:21 <Lethalman> :t (join . ) . liftM (=<<)
00:28:22 <lambdabot>     Occurs check: cannot construct the infinite type: m0 = (->) (m0 a0)
00:28:22 <lambdabot>     Expected type: (a0 -> a0 -> m0 b0) -> a0 -> m0 a0 -> m0 a0 -> b0
00:28:22 <lambdabot>       Actual type: (a0 -> a0 -> m0 b0) -> a0 -> m0 a0 -> m0 b0
00:28:25 <Lethalman> eheh :P
00:28:54 <Lethalman> ok, nothing easier than (. (>>=)) . (>>=)
00:29:45 <Lethalman> :t ap $ liftM2 (=<<)
00:29:46 <lambdabot> (Monad m, Monad m1) => (m (a -> m1 b) -> m (m1 a)) -> m (a -> m1 b) -> m (m1 b)
00:29:49 <Lethalman> eeeek :P
00:33:31 <ski> @type join .: ap
00:33:32 <lambdabot> Monad m => m (a1 -> m a) -> m a1 -> m a
00:36:23 <Lethalman> :t (.:)
00:36:24 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:36:26 <Lethalman> \o/
00:59:55 <ricree> Quick question. Is reactive banana worth the hassle overall? I've been trying to get into it this week, and while I can see where it might be useful, it seems like a huge hassle when you're interacting with the underlying gui library.
01:00:02 <ricree> but maybe I'm just not used to it yet
01:18:42 <rfw> hi, how do i "pause" a computation with ContT?
01:19:00 <rfw> currently i'm using callCC to grab the continuation while waiting for something else to trigger the continuation again
01:19:20 <rfw> but callCC just plows on and keeps running the rest of the code and gets called again when i trigger the continuation
01:19:50 <quchen> rfw: I'm not very proficient with Cont, but I remember a SO thread about a Pause Monad: http://stackoverflow.com/questions/10236953/the-pause-monad
01:19:53 <shachaf> Can you give a simple concrete example of the sort of thing you're trying to do, maybe?
01:20:10 <quchen> And then there's also the "functional goto" using Cont, which also feels like you can suspend a computation and jump back to it later.
01:20:43 <rfw> shachaf: i'm reading from a socket that i send requests to and get results back from "later"
01:21:12 <rfw> so i use ContT to "pause" the computation at where i'm requesting things from the socket and when i get the results back i resume the computation
01:21:44 <quchen> rfw: And an MVar won't do the trick?
01:21:52 <quchen> (Or something similar)
01:22:13 <shachaf> Yes, it's certainly possible that there's a simpler way of doing what you're trying to do, such as a simpler monad or threads or something.
01:22:24 <rfw> quchen: it would probably be a smarter approach, but i'm just wondering if i can do it this way
01:22:39 <shachaf> Yes, you can probably do it with ContT.
01:22:54 * hackagebot cabal-rpm 0.8.3 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.3 (JensPetersen)
01:23:09 <rfw> i can think of a particularly gross way where i return Maybe a and check in the callee if the result is Just a or Nothing
01:23:38 <shachaf> Can you give a concrete example using getLine or something like that instead of sockets?
01:23:52 <rfw> sure, give me a sec
01:24:03 <circle> is there an "infinity" number in haskell?
01:26:00 <ricree> > 1/0
01:26:02 <lambdabot>   Infinity
01:27:02 <circle> if you're wanting to compare other numbers to it
01:27:10 <circle> say you want any number to always be smaller than it
01:28:16 <shachaf> The answers at that stackoverflow post are good, mostly.
01:29:35 <shachaf> (Better than the question, on average.)
01:31:30 <circle> I'm getting an error and I have no idea why
01:31:31 <circle> http://lpaste.net/2300386244674191360
01:31:33 <circle> that's the error
01:32:20 <circle> http://lpaste.net/4023780093108158464 that's the piece of code it has a problem with
01:32:31 <shachaf> Good.
01:32:43 <circle> any ideas?
01:32:43 <shachaf> The error is that fbp-abprune is not a valid identifier.
01:32:51 <shachaf> You can tell because GHC inserts spaces.
01:33:18 <circle> ahhh
01:33:22 <shachaf> Next time, you should paste the complete error (and ideally the complete code).
01:33:37 <circle> shachaf: That is the complete error.
01:33:41 <circle> shachaf: There's nothing else.
01:34:15 <quchen> circle: You can't use "-" in identifiers. The only non-alphanumeric characters allowed are "'" and "_".
01:34:20 <shachaf> Really? You ran GHC and that's all it said?
01:34:24 <circle> shachaf: Yes.
01:34:26 <shachaf> Not even a line number?
01:34:41 <circle> Well, it gave a line number, and I gave you that line.
01:35:06 <shachaf> OK, so paste the complete error, and the lines before and after the error, to be on the safe side.
01:35:28 <shachaf> And also the lines before and after the line with the error, because you never know where the problem *really* is. :-)
01:35:55 <rfw> shachaf: never mind, i think i've realized that using concurrency would be the much smarter and less painful thing to do
01:36:04 <circle> kk
01:36:24 <quchen> Ideally you're doing something like "ghc ... > MyError  -->  lpaste". :-)
01:37:16 <quchen> rfw: As a pleasant side-effect, it would also make your program scale better. (Concurrency as a bonus, yipee)
01:37:27 <shachaf> rfw: Well, you would be using concurrency anyway.
01:37:38 <shachaf> It's just that you were trying to implement concurrency using ContT. :-)
01:37:51 <rfw> heh, indeed
01:37:56 <shachaf> (Which is almost always too powerful a tool for what you're really trying to do.)
01:38:05 <rfw> what i did learn though is that ContT is awesome :D
01:38:27 <shachaf> Perhaps "free monads are awesome" would be a better lesson!
01:38:42 <shachaf> As long as you're into "that kind of monad", "Codensity is awesome" would be a great lesson too.
01:39:34 <rfw> i think my brain has been hurt enough from messing around with ContT for today :P
01:39:39 <shachaf> newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
01:44:32 <johnw> ContT is very close Codensity, the difference being that it lets you fix the r: newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
01:44:59 <johnw> hmm... does that make Condensity a Rank-2 ContT?
01:46:43 <shachaf> I'm not sure that phrase really means anything.
01:46:52 <johnw> perhaps not
01:47:49 <johnw> perhaps better said as: ContT and Codensity differ in the rank of the functions they represent?
01:47:53 * shachaf mumbles something about (>>=) :: Monad m => m a -> Codensity m a
01:48:02 <johnw> ooh, that's nice!
01:48:08 <johnw> i hadn't thought of it that way before
01:48:16 <shachaf> I'm not sure what that means either.
01:50:01 <shachaf> Similarly (=>>) :: Comonad w => Density w a -> w a
01:50:51 <shachaf> This sort of thing comes up everywhere! It's great.
01:51:32 <johnw> sort of in the same way that f :: a -> b is similarly f :: a -> Yoneda a
01:51:55 <johnw> (for the function functor)
01:52:49 <johnw> so maybe what m a -> Codensity m a is saying is that any Monad can be CPS-transformed and be isomorphic?
01:53:24 <shachaf> I'm not sure what "Yoneda a" means.
01:53:38 <shachaf> And I'm also not sure what "isomorphic" (or "CPS-transformed") means.
01:53:40 <johnw> sorry, Yoneda (->) a
01:53:51 <shachaf> Codensity m isn't isomorphic to m.
01:54:06 <shachaf> I would say that it's similar to fmap :: Functor f => f a -> Yoneda f a
01:54:15 <shachaf> Or fmap :: Functor f => CoYoneda f a -> f a
01:54:15 <johnw> ah, yes
01:54:27 <johnw> which you've said before, actually, now that I remember
01:54:28 <Hafydd> Coneda
01:58:10 <cidevant> Hi there.
01:58:20 <cidevant>  Is somebody uses Yesod?
01:58:54 <shachaf> @where yesod
01:58:54 <lambdabot> #yesod - http://yesodweb.com/
01:59:02 <cidevant> thank you
01:59:40 <Hafydd> Yesod's logo is so cute.
02:01:13 <cidevant> Hafydd: just vertical tronsoformed haskell's logo
02:01:26 <Hafydd> Not quite.
02:01:52 <Hafydd> It has one more horizontal line, and the horizontal lines are differently placed.
02:02:24 <quicksilver> it's actually much nicer than the haskell logo
02:02:27 <quicksilver> I'm not sure why I think that.
02:05:09 <shachaf> Hmm, I don't much like the idea of libraries having logos that similar to the Haskell logo.
02:05:43 <swish1> Please someone explain me, why this "(sequence $ repeat $ randomIO ) >>= return . head :: IO Int" is not lazy?
02:06:21 <shachaf> sequence (repeat x) isn't lazy in general because it needs to execute infinitely many actions before it can yield anything.
02:06:43 <chrisdone> quicksilver: i like the snap logo: http://snapframework.com/
02:07:03 <shachaf> Do you expect "fst <$> do { x <- getLine; y <- getLine; return (x,y) }" to read one line or two?
02:07:49 <swish1> what then is the best way to perform indefinite number of IO actions?
02:08:07 <shachaf> There is no way without using unsafe functions.
02:08:24 <shachaf> In this case you should know about:
02:08:26 <shachaf> :t randoms
02:08:27 <lambdabot> (RandomGen g, Random a) => g -> [a]
02:08:55 <shachaf> The unsafe function you would use would be unsafeInterleaveIO. It may be that this would be a reasonable place to use it, but you should know exactly what you're getting into before you do.
02:12:01 <bennofs> Is it possible to splice names in a let in a TH expression quote?
02:12:06 <swish1> With unsafeInterleaveIO my example still not lazy
02:12:11 <bennofs> [| let $(name) = x in ... |] doesn't work
02:12:20 <bennofs> (Gives a parse error in pattern)
02:13:19 <chrisdone> bennofs: the type of name should be Q something, you know right?
02:13:29 <chrisdone> but also, that may be one of the limits of splicing. not sure
02:13:37 <bennofs> Ah, names are automatically generated in expression quotes
02:14:05 <bennofs> in [| let x = 3 in x |], the real name for x is generated by newName in the resulting ExpQ
02:14:33 <chrisdone> maybe there's a Pat type? would have to check
02:14:42 <bennofs> Well, it's no problem
02:14:55 <chrisdone> yeah, there's [p| … |]
02:15:39 <bennofs> [| let x = 4 in $([| let x = 3 in x |]) + x |] just works fine and the x's don't overlap (one is called x_1, the other x_2)
02:15:47 <bennofs> no need to use newName to generate names for the x's
02:17:06 <chrisdone> hm, yeah, it seems like a syntactical limit of the expression quoter
02:18:14 <bennofs> Also, there is stringE, but not integerE ...
02:18:39 <chrisdone> you can use Language.Haskell.Lift and just write lift <some instance of lift, like integer>
02:19:25 <chrisdone> λ> import Language.Haskell.TH.Lift
02:19:26 <chrisdone> λ> runQ [| let x = $(lift 123) in x |]
02:19:26 <chrisdone> LetE [ValD (VarP x_0) (NormalB (LitE (IntegerL 123))) []] (VarE x_0)
02:20:02 <bennofs> ah nice :)
02:27:44 <mgsloan> Better yet (though kinda messed up), autolifting:
02:27:44 <mgsloan> > let y = 123 in runQ [e| let x = y in x |]
02:27:45 <mgsloan> LetE [ValD (VarP x_1) (NormalB (LitE (IntegerL 123))) []] (VarE x_1)
02:27:46 <lambdabot>   <hint>:1:41: parse error on input `]'
02:30:21 <mgsloan> bennofs: I've got some somewhat-finished quasiquoters that let you splice names and other things here: https://github.com/mgsloan/quasi-extras/blob/master/src/Language/Quasi/Ast/TH.hs
02:30:28 <Ghoul_> are let's the same as where's apart from locality?
02:30:38 <Ghoul_> is there some performance win from using let instead of where, or vice verca
02:30:56 <mgsloan> bennofs: they also let you use these ast quotes as pattern matches
02:31:17 <mgsloan> bennofs: Only missing feature is being able to splice listlike bits of syntax, but otherwise they can do anything
02:31:28 <bennofs> mgsloan: I solved my problem already, but that looks interresting :)
02:32:36 <mgsloan> bennofs: It's in the midst of some other messings around with TH.  I'll try and separate it into a proper package sometime
02:33:23 <mgsloan> Ghoul_: lets and wheres are the same, just one is declaration / case syntax (where) and the other is expression syntax
02:33:41 <Ghoul_> ok
02:34:49 <merijn> Also, where clauses can scope over multiple guards, let's can't
02:35:00 <merijn> But no, there's no performance difference
02:36:05 <m3ga> @hoogle maybe
02:36:05 <lambdabot> Prelude data Maybe a
02:36:05 <lambdabot> Data.Maybe data Maybe a
02:36:06 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:37:49 <Rogach> Hello! What am I doing wrong in this code?
02:37:57 <Rogach> http://lpaste.net/90836
02:38:53 <Rogach> I tried to hide implementations of several algorithms behind common class, but ghc complains.
02:39:09 <shachaf> Rogach: When you write getMethod :: Method m => String -> m, that's promising that for any instance M of Method that I pick, you can give me a function :: String -> M
02:39:18 <mauke> caller chooses
02:39:19 <shachaf> You don't get to choose what m is. I do.
02:40:38 <Rogach> shachaf: Aha. Seems I got it.
02:40:59 <Rogach> shachaf: Yes, that was stupid :)
02:41:14 <circle> in this case, I know it won't be nothing
02:42:29 <Rogach> shachaf: Is there no way to achieve what I want? (i.e., selecting a class based on string)
02:42:50 <Rembane> Rogach: Why do you want to do it?
02:43:07 <merijn> Rogach: Why select based on String? Why not just on the type?
02:43:25 <shachaf> Rogach: It is possible that the right answer is to want something else.
02:43:40 <Rogach> merijn: I don't know the algorithm at compile time - I select that using cli parameter.
02:43:46 <shachaf> @where antipattern isn't directly relevant but maybe the way of thinking will be relevant.
02:43:46 <Rogach> shachaf: Sure, that seems to be the case :)
02:43:47 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:43:55 <shachaf> @where faq says something about that, I think.
02:43:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:44:28 <shachaf> "5.4 I'm making an RPG. Should I define a type for each kind of monster, and a type class for them?
02:44:31 <shachaf> Probably not. Some languages require a new type for each new behavior. In Haskell, behaviors are functions or IO actions, which are first-class values."
02:44:45 <Rogach> It's just that I looked at xmonad's LayoutClass and friends, and I thought that my situation is somehow similar.
02:45:19 <mauke> xmonad is a bit crazy
02:45:21 <shachaf> xmonad does some odd things.
02:45:24 <merijn> Rogach: Why not just have "(Floating f, Ord f, V.Unbox f) => Map String (Method f a)"? Where "type Method f a = (a -> V.Vector f -> f, a -> f -> V.Vector f -> V.Vector f)"
02:45:42 <mauke> IIRC its layouts are only separate types so it can read/show them
02:45:46 <shachaf> Part of the reason it does them is serialization.
02:45:48 <mauke> they used to be plain functions
02:45:56 * shachaf is always one step behind mauke. Why bother?
02:46:49 <merijn> Rogach: Or even get rid of the map and make it "String -> Method f a"
02:47:11 <shachaf> The main idea is that you can have a value represent a Method, rather than a type.
02:47:25 <Rogach> mauke: But what about ModifiedLayout? It conveniently implements LayoutClass, and that allows me to compose stuff cleanly: MirroredLayout $ SomeOtherLayout
02:47:57 <shachaf> Given data Layout = ..., you could probably write mirror :: Layout -> Layout, or something like that.
02:48:12 <shachaf> Maybe the xmonad types are parameterized too.
02:51:16 <jamy23> hello all!
02:51:24 <Eduard_Munteanu> jamy23: hi
02:51:47 <ricree> with gtk2hs, how do you add a tab page from a glade layout?
02:52:21 <jamy23> what is type "maybe"?
02:52:39 <Eduard_Munteanu> Any chance we could get https support on haskell.org and its subdomains? I can send bitcoins if getting a cert is the issue. :)
02:52:50 <Eduard_Munteanu> @src Maybe
02:52:50 <lambdabot> data Maybe a = Nothing | Just a
02:53:03 <Eduard_Munteanu> jamy23: have you seen the definition above?
02:53:19 <merijn> Rogach: This seems a simpler approach: http://lpaste.net/90836
02:53:22 <Gracenotes> it is not a type, but an augmentation of another type
02:53:22 <ricree> just in case:
02:53:26 <ricree> @src maybe
02:53:27 <lambdabot> maybe n _ Nothing  = n
02:53:27 <lambdabot> maybe _ f (Just x) = f x
02:53:45 <Gracenotes> depending on capitalization
02:54:04 <Rogach> merijn: Yes, that's nice.
02:54:11 <Gracenotes> yeah probably the latter... ... ... ... ... ... ...
02:54:43 <jamy23> how to unpack "a" from "just a"?
02:54:59 <merijn> Rogach: And then you can just use the record syntax to get the functions you need "apply :: Method f a -> a -> V.Vector f -> f"
02:54:59 <Eduard_Munteanu> jamy23: pattern match on it
02:55:02 <Rogach> merijn: I also tried to go with putting `apply` and `threshold` into top-level, and then matching on data (apply (MaxThreshold) values = ...)
02:55:42 <Eduard_Munteanu> jamy23: that way you also handle the Nothing case
02:55:44 <quchen> jamy23: There are the "maybe" and "fromMaybe" functions from Data.Maybe.
02:55:49 <merijn> Rogach: Functions only accept one type as argument, so that wouldn't typecheck :)
02:55:50 <ricree> jamy23: there's a could different ways, depending on what you want (and ps, I think you mean "Just a")
02:56:11 <quchen> (Which are implemented using pattern matching, like Eduard_Munteanu suggested.)
02:56:39 <Rogach> merijn: I'm still interested how guys at xmonad achieve what they do.
02:56:39 <Rogach> merijn: Their approach seems to be much cleaner than mine.
02:56:58 <Eduard_Munteanu> Actually, who's in charge of haskell.org?
02:57:19 <typoclass> Eduard_Munteanu: i suppose the haskell-infrastructure mailing list
02:57:33 <jamy23> what real difference from native maybe and custom "maybe' = nothing' | just' a"?
02:57:58 <Eduard_Munteanu> jamy23: none, really... but mind the capitalization
02:58:09 <ClaudiusMaximus> ricree: i do { widgetShowAll content ; page <- notebookAppendPage nb content tabname ; notebookSetCurrentPage nb page } -- though i've never used glade, not sure how it's different
02:58:23 <Eduard_Munteanu> The usual Maybe also comes with useful instances and functions.
02:58:34 <Rogach> merijn: It typechecks fine: http://lpaste.net/90836
02:58:40 <Rogach> merijn: It's just ugly as hell.
02:59:44 <merijn> Rogach: Ah, yeah, but that requires you to change all functions when you add a new Method, mine works without having to change anything :p
03:00:01 <typoclass> jamy23: try "data Maybe' a = Nothing' | Just' a" :-) but Maybe' is really pretty much the same as Maybe. a practical difference is that there's a number of functions in the standard library that work with Maybe, and you'd have to rewrite or change those to work with Maybe'
03:00:03 <jamy23> I thought that "maybe" is the some instance of Monads
03:00:37 <Eduard_Munteanu> jamy23: it is, along with other typeclasses, e.g. Functor
03:01:00 <Eduard_Munteanu> jamy23: you can define them yourself if you want
03:01:11 <Hafydd> Maybe (the type) is an instance of Monad (the class).
03:01:17 <shachaf> Rogach: xmonad is a bit weird, as I mentioned.
03:01:32 <shachaf> Rogach: If you insist on doing it with type classes you would probably need to use some sort of existential type to do it.
03:01:33 <ricree> ClaudiusMaximus: thanks. The issue I'm running into with glade, though, is that there's some weirdness since objects imported from a glade definition already have a parent hierarchy. I've seen examples of how to do it in c++, but it doesn't work in gtkhs. Or at least, the most obvious way to emulate it with gtk2hs doesn't work
03:01:43 <shachaf> But you don't really win much by doing it that way.
03:02:18 <Rogach> shachaf: But for the sake of education? :)
03:02:20 <jamy23> why it is? What it has from Monads? It is not IO, nor ST
03:02:31 <merijn> Rogach: See also, 3.2 of the Tao of Programming :) http://www.mit.edu/~xela/tao.html
03:02:41 <shachaf> Rogach: What?
03:03:26 <ricree> jamy23: Monad is just a particular typeclass (think interface, if you're coming from an imperative background). It just means it's a type that implements a certain set of functions
03:03:28 <Hafydd> Monad represents more than just IO and ST. Maybe can represent a computation that gives 0 or 1 results.
03:03:30 <mauke> jamy23: >>= and return
03:03:45 <Rogach> shachaf: I mean, I'm not sure that I would gain better code structure from type classes, but it may  improve my knowledge.
03:04:51 <shachaf> A certain set of functions and also a certain set of laws.
03:05:50 <jamy23> so Maybe is like a variable?
03:06:01 <typoclass> jamy23: how do you mean?
03:06:03 <mauke> no, Maybe is like a type
03:07:15 <ricree> jamy23: Do you know Java at all? Maybe is like a class (kinda, sorta, ish), while Monad is like an interface (again, kinda sorta)
03:07:25 <ricree> of in c++ terms, a class and an abstract class
03:07:30 <mauke> :-(
03:07:36 <bennofs> Is there a flag to GHC to not only print "prettified" code on -ddump-splices, but also the AST?
03:07:39 <mauke> more like a struct template and a concept
03:07:44 <jamy23> variable in imperative world can be defined but not set (like nothing), or can be set (like just)
03:07:55 <mauke> jamy23: what
03:08:12 <mauke> your "imperative world" is a fairly specific programming language you're thinking of
03:08:37 <mauke> possibly python? but not really
03:08:53 <jamy23> sorry. I am JS
03:08:55 <ricree> mauke: sorry, was going more for the more "intuitive" analogy  (to my mind, anyways, rather than the closest one)
03:08:57 <typoclass> jamy23: oh, you mean like null pointers? yes, Maybe is a lot like that. it's haskell's new improved way of doing null pointers and avoiding the equivalent of null pointer exceptions
03:09:27 <mauke> jamy23: a big difference is that Maybe is explicit and stackable
03:09:34 <mauke> you can't express 'Just Nothing' in JS
03:10:04 <shachaf> Just Nothing is the best.
03:11:27 <kingugo> #backtrack-linux
03:13:15 <Hafydd> You can express Just Nothing in C, however: void *x = NULL; void **y = &x;
03:17:01 <jamy023> i am back
03:17:28 <jamy023> i am was dropped from the server
03:18:39 <chrisdone> welcome back you who are is here
03:19:07 <bennofs> Can anyone help me with this TH issue? https://gist.github.com/bennofs/5983373
03:19:22 <bennofs> I want to generate data declarations, so I need an unique name
03:19:34 <bennofs> sadly, newName doesn't seem to be "unique" enough
03:20:05 <mgsloan> bennofs: Yeah, those names are not unique when it comes to export
03:20:11 <mgsloan> they're only locally unique
03:20:32 <mgsloan> at export those can just be accessed as "EmptyData"
03:21:01 <mgsloan> So unfortunately if you really need to do that you'll need to use "reify" to check if someone's already using the name earlier
03:21:15 <bennofs> Can I mark a datatype as "non-exportable"?
03:21:25 <mgsloan> Nope
03:21:38 <jamy023> What real use cases of Functor? Why simple map on list dont enought?
03:21:57 <bennofs> jamy023: What if you have a Data.Map? Or a Data.Sequence?
03:22:14 <mauke> jamy023: because not all types are []
03:22:21 <bennofs> jamy023: And you want to write algorithms that work on "Anything that can be mapped over"?
03:22:32 <merijn> mauke: Something, something lisp?
03:23:28 <jamy023> how we can mapped something that not [] ?
03:23:47 <jamy023> i dont get it
03:24:22 <bennofs> > fmap (+3) $ Data.Sequence.fromList [1,2,3]
03:24:23 <lambdabot>   Not in scope: `Data.Sequence.fromList'
03:24:32 <bennofs> @let import qualified Data.Sequence as Seq
03:24:33 <lambdabot>  Defined.
03:24:38 <bennofs> > fmap (+3) $ Seq.fromList [1,2,3]
03:24:39 <lambdabot>   fromList [4,5,6]
03:24:52 <mauke> > fmap show Nothing
03:24:53 <lambdabot>   Nothing
03:24:55 <raichoo> jamy023: You want to reuse a function with type a -> b for some structure f :: * -> *. f could be List, Maybe, Tree. fmap turn that function into something of type f a -> f b
03:25:01 <mauke> > fmap show (Just 42)
03:25:02 <lambdabot>   Just "42"
03:25:48 <raichoo> > fmap (+1) (Just 41)
03:25:49 <lambdabot>   Just 42
03:25:50 <bennofs> jamy023: You can define a function that adds 3 to each "element" in a structure using Functor
03:25:54 <bennofs> for example
03:26:00 <bennofs> @let add3 = fmap (\x -> x + 3)
03:26:01 <lambdabot>  .L.hs:148:8:
03:26:01 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'
03:26:01 <lambdabot> ...
03:26:18 <bennofs> @let add3 :: (Functor f) => f Int -> f Int; add3 = fmap (\x -> x + 3)
03:26:19 <lambdabot>  Defined.
03:26:26 <bennofs> Now you can use that function for any functor
03:26:35 <bennofs> > add3 $ Seq.fromList [1,2,3]
03:26:38 <lambdabot>   mueval-core: Time limit exceeded
03:26:39 <bennofs> > add3 $ [1,2,3]
03:26:42 <lambdabot>   [4,5,6]
03:26:47 <bennofs> > add3 $ Just 3
03:26:50 <lambdabot>   Just 6
03:26:53 <dEPy> what do  you guys think of LYAH vs Real world haskell?
03:27:02 <mstksg> jamy023: with some creativity you can find a lot of things that can be mapped over that aren't lists
03:27:09 <nerrz> LYAH being learn you a haskell for great good?
03:27:14 <dEPy> yes
03:27:25 <bennofs> I really enjoyed LYAH, only glanced over some chapters of RWH
03:27:30 <nerrz> I thought that was the best comp sci book I have ever purchased
03:27:38 <nerrz> and yes I purchased it because it was so good
03:28:04 <mstksg> dEPy: enjoyed both; lyah was a bit of an easier read while getting through most important concepts
03:28:25 <dEPy> nerrz you purchsed LYAH?
03:28:38 <nerrz> yes. I like having paper books
03:28:54 <nsno> i own lyah too
03:29:13 <nsno> well worth it imo
03:29:43 <merijn> dEPy: I think RWH skips over some fundamentals which are better explain in LYAH, but it comes with more real world/advanced examples
03:29:53 <merijn> dEPy: It's a good follow up book to LYAH, imo
03:30:05 <mstksg> merijn: that's actually how i see it too
03:30:28 <dEPy> I'm almost trough with LYAH, so RWH is a good next step I guess then?
03:30:35 <nerrz> I thought LYAH was really good for me because I haven't gone to university yet and am self taught and I was able to follow everything in the book
03:30:35 <dEPy> Ah ok. :)
03:30:42 <merijn> dEPy: Yeah, or just start coding :p
03:30:50 <jamy023> why this dont enought: add3 = (+)3 ; map add3 [4,5,6]
03:31:01 <zomg> I wonder if I should get back to writing my "haskell for web developers" thingy
03:31:15 <mstksg> zomg: i was just looking for resources on that actually
03:31:17 <zomg> I kinda got distracted and haven't touched it in like half a year :P
03:31:19 <dEPy> merijn: I did some basic stuff, It's really hard to do something usefull when all I did were those small examples from LYAH :D
03:31:31 <ion> > let add3 = (+)3 in map add3 [4,5,6]
03:31:32 <lambdabot>   [7,8,9]
03:31:35 <ion> Seems to work for me.
03:31:39 <mstksg> dEPy: i've heard good reviews about Haskell School of Experience
03:31:42 <zomg> mstksg: if you're interested, http://jjh.fi:8080/~jani/haskell-for-web/_site/
03:31:43 <nerrz> do you know project euler?
03:31:47 <osfameron> *Expression
03:31:49 <mstksg> er
03:31:51 <zomg> mstksg: it's very much work in progress but there's some stuff in there already
03:31:51 <mstksg> Expression
03:31:52 <mstksg> thanks
03:31:53 <dEPy> Yes I know euler
03:31:58 <osfameron> I think HSoE is a bit out of date now though
03:32:08 <bennofs> jamy023: But do you want a new map function for each data type that you want to map over?
03:32:08 <nerrz> have you dont them in haskell?
03:32:17 <osfameron> e.g. some of the libraries it refers to don't exist, or have changed API
03:32:31 <nerrz> done*
03:32:33 <FreeFull> bennofs: Talking about functors?
03:32:37 <typoclass> jamy023: yes, "map add3 [1,2]" works, but what doesn't work is "map add3 (Just 123)". so, fmap is a more general thing that will work in both cases (and a number of others as well)
03:32:39 <mstksg> osfameron: thanks; i was just considering buying it.  it was a second hand recommendation
03:32:40 <bennofs> FreeFull: yes
03:32:46 <dEPy> So, LYAH and RWH are best intro book. What then?
03:32:58 <bennofs> Typeclassopedia is a nice reference
03:33:01 * hackagebot putlenses 0.1.0 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.1.0 (HugoPacheco)
03:33:10 <mstksg> dEPy: just dig through your old programming projects and re-implement them in haskell
03:33:23 <bennofs> Also, it covers Traversable and Foldable, two very important classes imo that are not covered in LYAH
03:33:30 <dEPy> mstksg: that would be a good next step I guess yea.. :)
03:33:31 <mstksg> you'll learn more that way then just doing contrived projects
03:33:40 <ricree> dEPy: Write yourself a scheme ( http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours ) is a pretty good "first larger project"
03:33:57 <nerrz> speaking of that, what's a good gui library for haskell?
03:34:05 <jamy023> and why this not work: map add3 (7,5,6)
03:34:08 <mstksg> PEuler is more of a sunday afternoon math teaser than a language learning tool
03:34:14 <dEPy> ricree: I know that one. Will bookmark it. :)
03:34:15 <osfameron> mstksg: oh, I think it's worth reading still.  Admittedly I only got around 1/4 of the way through
03:34:20 <mstksg> jamy023: because i don't think (,,) is a functor instance
03:34:20 <chrisdone> nerrz: the gtk support isn't bad for linux
03:34:27 <nerrz> really, ill look into that
03:34:29 <typoclass> jamy023: that's a tuple, not a list. map works only for lists
03:34:32 <typoclass> @type map
03:34:32 <lambdabot> (a -> b) -> [a] -> [b]
03:34:42 <mstksg> er, thought you said fmap
03:34:49 <nerrz> idk, I used PE to teach myself the basics of haskell and java
03:34:52 <nerrz> I thought it was nice
03:35:05 <FreeFull> Project Euler is only good if you like maths
03:35:05 <jamy023> and Functor can mapped tuples?
03:35:07 <ricree> chrisbuchholz: is gtk2hs going to cause porting issues on windows?
03:35:09 <nerrz> also the problems are a good conversation piece with my friends
03:35:16 <Lethalman> FreeFull, *prime numbers
03:35:16 <ricree> chrisbuchholz: I've only used it on linux so far
03:35:20 <FreeFull> There is a Functor instance for (a,)
03:35:29 <bennofs> > fmap (+3) (1,3(
03:35:31 <bennofs> > fmap (+3) (1,3)
03:35:31 <lambdabot>   <hint>:1:16:
03:35:31 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
03:35:33 <lambdabot>   (1,6)
03:35:39 <chrisbuchholz> ricree: think you've got the wrong person :)
03:35:40 <ricree> oops, meant chrisdone. autocomplete fail
03:35:48 <FreeFull> Lethalman: There are many project euler problems that don't involve primes
03:35:54 <typoclass> bennofs: lambdabot is also available privately, for trying out things
03:36:22 <ricree> yep, sorry chrisbuchholz
03:36:47 <nerrz> idk, I assumed most people that liked haskell would also like maths, since it seems like the best language for that stuff
03:36:49 <mstksg> nerrz: good to hear it worked for you; maybe i'm an outlier
03:37:31 <nerrz> well, to be fair, past the first couple 99% of the time is actually solving the math and then 1% is writing the program
03:37:54 <mstksg> if you want practice implementing an arbitrary algorithm then it would help
03:38:06 <mstksg> the math is the fun part but it keeps it to just being pet projects imo
03:38:10 <mstksg> toy
03:38:48 <mstksg> but you do get a basic grasp of syntax
03:39:01 <FreeFull> Yeah, solutions to project euler problems don't get that big
03:39:15 <FreeFull> So it doesn't help if you want to learn how to do bigger projects
03:39:20 <nerrz> well, not in haskell they dont
03:39:34 <ricree> I don't know. Maybe it was just me, but I thought working through euler problems encouraged some bad structure, at least back when I was really new to Haskell
03:39:42 <nerrz> what do you mean?
03:39:54 <FreeFull> You tend to write quick and dirty hacks
03:40:03 <FreeFull> Rather than something more beautiful
03:40:06 <ricree> mostly a lot of really weird, awkward things with recursion
03:40:13 <mstksg> or little modules that don't really integrate well into big pictures
03:40:14 <jamy023> And last. How i can write generators in haskell?
03:40:47 <nerrz> well, I just have all of my problems in one program where each problem is just one function
03:41:01 <nerrz> I mean, if the math is there, they will be smallish problems
03:41:08 <mr-> jamy023: haskell lists may be infinite, is that enugh for you?
03:41:11 <nerrz> and then I can recycle a lot of helper functions
03:41:47 <FreeFull> jamy023: You don't need generators, everything behaves as if it was a generator
03:42:00 <FreeFull> That's what the whole laziness thing is about
03:42:17 <mstksg> jamy023: can you give a specific example of what you would want to accomplish?
03:42:33 <jamy023> if i need more difficult range than [1,2..] ?
03:42:45 <FreeFull> jamy023: For example?
03:43:26 <jamy023> fibonacci numbers
03:43:33 <mr-> jamy023: [ f x | x <- [1,2..] ] ? ;-)
03:44:01 <FreeFull> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
03:44:02 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)'
03:44:05 <FreeFull> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs
03:44:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:44:13 <FreeFull> jamy023: Is this satisfactory?
03:44:37 <mr-> jamy023: the point is, that every list is evaluated/computed only so far as it is needed
03:44:50 <mr-> (I guess that's what generators are)
03:45:29 <mstksg> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in take 10 fibs
03:45:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
03:45:50 <mstksg> laziness
03:46:57 <jamy023> if any next number depend on any of the other figures in this sequence under difficult conditions
03:48:03 <mstksg> can you give a specific example?
03:48:18 <FreeFull> jamy023: you can always write a recursive thing
03:50:36 <jamy023> so in haskell function uses as generators?
03:51:14 <Lethalman> jamy023, I wouldn't try to find analogies with other languages like python :-)
03:52:08 <jamy023> functions which returns infinity list that generators in haskell
03:52:12 <typoclass> jamy023: in some ways yes. for something where you'd use a generator in python, you can use a regular function in haskell. (e.g. the fibs example from 5 minutes ago)
03:53:44 <FreeFull> typoclass: That wasn't even a function though
03:53:47 <FreeFull> It was just a list
03:53:51 <FreeFull> That happened to refer to itself
03:53:56 <typoclass> FreeFull: yep
03:54:00 <jamy023> ok. How i can build infinity graph in haskell?
03:54:08 <FreeFull> Same how    map (*2) [1..]  is a list
03:54:55 <FreeFull> jamy023: Probably recursively
03:55:47 <jamy023> so i cant make custom data type for this like i can make data type for tree?
03:56:18 <bennofs> mgsloan: How would I check whether a datatype exists with reify?
03:56:43 <MasseR> jamy023: Sorry if I missed something, but you can make a custom recursive datatype, but it's an 'advanced concept'. Search for tying the knot if you are interested
03:56:53 <MasseR> Err, actually thats cyclic
03:56:57 <MasseR> Mixed my terms, sorry
03:57:06 <hashcat> >:k Integer
03:57:27 <bennofs> :k Integer = *
03:57:28 <lambdabot> parse error on input `='
03:57:52 <jamy023> MasseR: sorry, i dont get you. Can you give me a link?
03:58:08 <hashcat> :k Integer
03:58:09 <lambdabot> *
03:59:13 <mgsloan> bennofs: The API isn't very pretty for that case, but http://byorgey.wordpress.com/2011/08/16/idempotent-template-haskell/
04:00:42 <mr-> jamy023: maybe that's of interest: http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Graph.html
04:04:02 <jamy023> mr-: interesting. Thanks:)
04:05:36 <bennofs> mgsloan: thanks
04:05:43 <mgsloan> bennofs: welcome!
04:05:54 <jamy023> Thanks for all!
04:14:55 <jamy023> what is <- mean
04:15:03 <jamy023> ?
04:15:34 <ski> in a list comprehension, or in `do'-syntax ?
04:15:44 <raichoo> jamy023: https://en.wikibooks.org/wiki/Haskell/do_Notation
04:17:11 <jamy023> in list
04:17:12 <quchen> jamy023 - Cyclic tree: http://lpaste.net/90839
04:17:48 <ski> jamy023 : "draw elements from list"
04:18:13 <ski> > [x * 2 | x <- [0,1,2,3]]
04:18:14 <lambdabot>   [0,2,4,6]
04:18:23 <quchen> Well, "cyclic graph" might be a better name here.
04:19:00 <ski> `x' in turn becomes each one of `0',`1',`2',`3'; for each such choice, `x * 2' is computed, and the results are collected into the result list
04:19:20 <jamy023> quchen: Wrong definition of Tree
04:20:02 <raichoo> > do { x <- [0,1,2,3]; return (x * 2); }
04:20:03 <lambdabot>   [0,2,4,6]
04:20:24 <quchen> jamy023: It's a correct definition of an arbitrary non-empty tree.
04:20:36 <raichoo> > [0,1,2,3] >>= \x -> return (x * 2)
04:20:37 <lambdabot>   [0,2,4,6]
04:20:40 <Hafydd> What an awful example.
04:20:45 <Hafydd> > [0,2..6]
04:20:46 <lambdabot>   [0,2,4,6]
04:21:07 <jamy023> quchen: Tree with one node?
04:21:32 <quchen> jamy023: That's part of "non-empty", yes.
04:21:57 <raichoo> Hafydd: That was about how list comprehensions translate to do notation, translate to unsugared code.
04:22:17 <ski> @undo [x * 2 | x <- [0,1,2,3]]
04:22:17 <lambdabot> concatMap (\ x -> [x * 2]) [0, 1, 2, 3]
04:23:44 <Hafydd> @undo [f x y | x <- a, y <- b]
04:23:44 <lambdabot> concatMap (\ x -> concatMap (\ y -> [f x y]) b) a
04:26:07 <quchen> ... or `liftA2 f a b`
04:26:22 <Hafydd> @undo [f x | x<-a, p x]
04:26:23 <lambdabot> concatMap (\ x -> if p x then [f x] else []) a
04:26:47 <Hafydd> Is that how GHC actually does it?
04:27:39 <jamy023> quchen: Ok. My question was be: how to build infinity structure where each element lazy compute depending on other elements of this structure. How i can modify your code to define function which determines the value of a node?
04:27:41 <quchen> Hafydd: I remember hearing that GHC doesn't use Monad functions to desugar list comprehensions unless you have MonadComprehensions enabled. I'm not sure about that though.
04:28:15 <danr> quchen: Hafydd: http://www.reddit.com/r/haskell/comments/oolyt/why_are_guards_in_the_list_comprehension_faster/
04:28:50 <quchen> danr: Good link, thanks
04:29:09 <danr> so do notation goes into concatMap etc, and list comprehension into foldr/build fusion
04:31:32 <quchen> jamy023: Like this? http://lpaste.net/90840
04:33:02 <nerrz> can someone explain what the Kleisli composition function does (>=>)
04:34:02 <opqdonut> nerrz: think of it as composing side-effectful functions
04:34:23 <nerrz> so it is just like (.) but for monad?
04:34:26 <opqdonut> yep
04:34:39 <opqdonut> or, well, flip (.)
04:34:50 <nerrz> what do you mean?
04:35:00 <opqdonut> it works like this: (f >=> g) x = do y <- f x; z <- g y; return z
04:35:23 <opqdonut> In f.g it's g that gets executed "first", in f>=>g it's f
04:35:29 <quchen> nerrz: for example `lookup i >=> lookup j` performs a lookup for the i-j-th element in a `Map i (Map j a)`, resulting in Nothing if there is no such entry.
04:35:38 <ski> <http://www.haskell.org/onlinereport/exps.html#list-comprehensions>
04:36:04 <quchen> jamy023: Here's an example of a tree element depending on one deeper down the tree: http://lpaste.net/90840 -- The first tree element is defined by the one at level 3
04:36:44 <nerrz> so it is like folding a (.) over [f,g]
04:36:49 <nerrz> but for monad?
04:37:04 <nerrz> that actually sounds useful
04:38:37 <Hafydd> > ((+1) >=> (+1)) 0
04:38:38 <lambdabot>   No instance for (GHC.Show.Show (m0 c0))
04:38:38 <lambdabot>    arising from a use of `M18568099...
04:38:53 <quchen> nerrz: (.) combines two ordinary functions (a -> b) and (b -> c), while (<=<) combines two monad-valued functions (a -> m b) and (b -> m c).
04:38:57 <Hafydd> Oh...
04:39:00 <opqdonut> > ((+1) >=> (+1)) (Just 0)
04:39:01 <lambdabot>   No instance for (GHC.Show.Show c0)
04:39:01 <lambdabot>    arising from a use of `M1367992842.sh...
04:39:08 <opqdonut> oh, right, bah
04:39:32 <nerrz> quchen: in that example, how is that different from f x >>= g since that passes the result of f x to g
04:39:35 <opqdonut> > let inc = Just . (+1) in (inc >=> inc) (Just 0)
04:39:36 <lambdabot>   No instance for (GHC.Show.Show a0)
04:39:36 <lambdabot>    arising from a use of `M1009258318.sh...
04:39:43 <opqdonut> (suddenly it's not such a good example any more)
04:39:46 <opqdonut> > let inc = Just . (+1) in (inc >=> inc) 0
04:39:47 <lambdabot>   Just 2
04:39:49 <opqdonut> I'll get my coat
04:39:55 <quchen> nerrz: There's no difference. `f >=> g = \x -> f x >>= g` :-)
04:40:25 <bennofs> How do you call A,B,C (which are also kinds) in the kind A -> B -> C -> * ?
04:40:38 <bennofs> Parameter kinds?
04:41:36 <nerrz> quechen: okay, well at least I understand, thank you for the explanation since the docs for Control.Monad only have "Left-to-right Kleisli composition of monads." which was hard to look up
04:41:37 <quchen> nerrz: Here's the actual source: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#%3E%3D%3E
04:41:50 <alexander__b> how would I... do something ten times?
04:42:01 <nerrz> quchen: so that is literally how it is defined
04:42:03 <alexander__b> like 'print "hello, world!"' ten times
04:42:11 <bennofs> alexander__b: use replicateM
04:42:14 <bennofs> @ty replicateM
04:42:15 <lambdabot> Monad m => Int -> m a -> m [a]
04:42:18 <bennofs> @ty replicateM_
04:42:18 <lambdabot> Monad m => Int -> m a -> m ()
04:42:19 <quchen> > forM_ [1..10] $ \x -> print x
04:42:21 <lambdabot>   <IO ()>
04:42:26 <quchen> ^ nerrz
04:42:27 <banister> quchen: here's my attempt at left-to-right composition (inspired by haskell) http://showterm.io/47f46234281cf2c25f44a#fast
04:42:32 <Hafydd> > ((+) >=> (+)) 1 1
04:42:32 <quchen> Eh, wrong nick
04:42:33 <lambdabot>   3
04:42:40 <bennofs> > replicateM_ 10 $ print "Hello world"
04:42:41 <lambdabot>   <IO ()>
04:42:42 <Hafydd> No side-effects there.
04:43:09 <ski> > (lookup 'c' <=< lookup 1) [(0,[('A',"bc"),('B',"29")]),(1,[('a',""),('b',"eigenvariable"),('c',"lajakeka")]),(2,[])]
04:43:10 <lambdabot>   Just "lajakeka"
04:43:27 <bitonic> I remember a nice diagram of the kind subtyping present in GHC.  can’t find it now.  does anybody have a link?
04:43:39 <quchen> banister: That's a Javascript-requiring page that types some stuff in some non-Haskell language. Sure the link was right?
04:43:47 <alexander__b> bennofs: hm. that is quite nice.
04:43:48 <nerrz> quchen: is there ever a reason to use the composition instead of bind then?
04:44:22 <quchen> nerrz: is there ever a reason to use composition instead of direct function application?
04:44:28 <ski> bennofs : perhaps "argument kinds" or "(formal) parameter kinds", yes
04:44:30 <banister> quchen: hehe, it's just a ruby library that contains some ideas i got from haskell, ruby people dont really understand/care about it, so i thought i'd try it here..probably a poor move though, sorry :)
04:44:52 <quchen> nerrz: Same thing with using  f . g  vs  \x -> f (g x)
04:45:06 <quchen> banister: Well I don't know Ruby :-\
04:45:29 <ksf> hmmm apparently one doesn't need any data types when converting from one finally tagless representation to the other. newtypes suffice.
04:46:10 <nerrz> well I always felt (f . g) x looked cleaner since in math class I write (f.g)(x) over f(g(x))
04:46:20 <ksf> ...which means that one can write compilers without any data types representing the code, at all.
04:46:38 <quchen> nerrz: Consider the example I gave before, `looupTuple (i,j) = lookup i >=> lookup j`. Writing this with bind wouldn't be as clean. What the function is supposed to do is compose two monadic functions, and that's what >=> does. >>= is more along the lines of piping an explicit parameter along.
04:46:48 <ksf> start by emitting finally tagless directly in the parser, end with serialising finally tagless to strings.
04:47:28 * ksf wonders whether that's going to introduce a lot of dictionary passing overhead or not.
04:47:35 <nerrz> so I guess that the monad composition would fit my style better, and is the same efficiency wise since it is kind of just sugar
04:48:01 <nerrz> but why is it called Kleisli composition?
04:48:28 <quchen> nerrz: The Kleisli category is where the (a -> m b) functions live. And that's as much as I know.
04:48:45 <Hafydd> so I guess the do notation would fit my style better than list comprehensions, and is the same efficiency wise since it just kind of sugar
04:48:58 <nerrz> what?
04:49:27 <DrSyzygy> nerrz: There was this mathematician whose name was Kleisli
04:49:28 <typoclass> nerrz: as far as i know the Control.Monad module was written by people who love maths and math jargon
04:49:35 <bennofs> Is it "datatype" or "data type"?
04:49:55 <DrSyzygy> Kleisli managed to figure out how one could construct a category from a monad, such that the monadic composition turned into the ordinary composition in that category
04:50:10 <DrSyzygy> hence Kleisli composition, because it is the composition construction that Kleisli created.
04:50:20 <nerrz> typoclass: yeah, the documentation is sort of daunting
04:51:14 <ksf> :t (>=>)
04:51:15 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:51:21 <ksf> that's kleisli composition.
04:51:22 <quchen> Control.Monad was written by people who didn't feel like inventing funny words for things that already have names.
04:51:38 <DrSyzygy> quchen++
04:51:39 <mm_freak> typoclass: what would be a better name than "kleisli composition"?
04:51:50 <typoclass> nerrz: yeah. but the good news is that the description is daunting, but the principle behind it is usually quite nice and straightforward
04:51:52 <ksf> :t (.)
04:51:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:52:08 <Hafydd> Oohh, looks like something is about to go down.
04:52:17 <ksf> as you see, that's the same just in (-> m) instead of (->)
04:52:27 <ksf> (the syntax in the previous sentence is dodgy)
04:52:38 <mm_freak> ksf: minor nitpick, kleisli composition is (<=<)
04:52:52 <DrSyzygy> :t (<=<)
04:52:53 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:53:05 <DrSyzygy> :t (>=>)
04:53:06 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:53:06 <quchen> nerrz: I started learning Haskell without any prior knowledge of category theory, and to this day that hasn't changed significantly. Most of the words are just vocabulary to me, much like I don't question why you call a house "maison" in French.
04:53:06 <DrSyzygy> :t (.)
04:53:07 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:53:41 <DrSyzygy> Me on the other hand started with Haskell BECAUSE it and its community use category theory to explain and understand things
04:53:50 <Hafydd> (The idea of a Monad in functional programming existed before Haskell was invented, I believe)
04:53:57 <nerrz> quchen: haha, I guess that makes sense.
04:54:15 <mm_freak> people often say that type classes and concepts need better names, but then i ask, what would be those better names?
04:54:23 <mm_freak> what would be a better name than "monoid"?
04:54:29 <jamy023> quchen: i dont se where node depend on others in your solution. I see only mapping tree
04:54:43 <ski> bitonic : i think it resided on <http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Kinds>
04:54:54 <quchen> jamy023: The topmost node has the value "value of the third node of this graph".
04:55:04 <nerrz> speaking of that, I understand sort of how monads work in haskell to force sequential operation, but how does that work outside of the world of programming, like in pure math
04:55:11 <DrSyzygy> mm_freak: Burrito? ;-)
04:55:14 <quchen> DrSyzygy: Did you learn Haskell because you wanted to see category theory applied in a sense then?
04:55:32 <mm_freak> nerrz: do you understand fmap, return and join?
04:55:37 <DrSyzygy> quchen: I already knew category theory well when I got started, and I was intrigued to see programming developed from those abstractions.
04:55:51 <ski> Hafydd : not sure
04:55:56 <nerrz> yes
04:55:59 <typoclass> mm_freak: i don't know. but as a counter-example >>= has the name bind, not the name "inside-out Noodlinger conduction" or whatever
04:56:05 <h4199> AbstractSingletonProxyFactoryBean == monoid  /solved
04:56:09 <Eduard_Munteanu> Can you ask cabal not to install dependencies?
04:56:17 <typoclass> Eduard_Munteanu: how about --dry-run?
04:56:20 <mm_freak> nerrz: in math you use those
04:56:28 <jamy023> You dont get me
04:56:32 <Eduard_Munteanu> typoclass: hm, that should do, thanks
04:56:42 <mm_freak> typoclass: that's because there was no math equivalent to (>>=)
04:56:43 <jamy023> quchen:
04:56:44 <dcoutts> Eduard_Munteanu: you can do a local, configure; build; copy; register
04:56:45 <quchen> typoclass: >>= has a custom name because nobody uses it in category theory. :-)
04:56:54 <Eduard_Munteanu> Ah, thanks.
04:57:06 <mm_freak> typoclass: or rather math people didn't name it
04:57:13 <ocharles> well, >>= is sometimes referred to as being part of the "Kleisli tripple" (McBride, Kleisli Arrows of Outrageous Fortunes)
04:57:16 <ski> however, there was a symbol for `=<<'
04:57:23 <ocharles> but maybe that's a mcbrideism
04:57:30 <nerrz> mm_freak: I guess I don't see when numbers would ever be "wrapped" in a monad in math
04:57:42 <ski> `f =<< m' being written as `f^* m' or `f * m'
04:57:43 <mm_freak> typoclass: the problem is, once you invent a custom name, you need to explain the concept, but then algebraic people will go ahead and say, "come on, why didn't you just say 'monoid'?"
04:57:43 <elliott> mm_freak: you can use (>>=) just fine.
04:57:48 <DrSyzygy> and mathematicians keep using personal names for things because we name so DAMN many different things
04:57:50 <elliott> "Kleisli extension" or whatever.
04:57:51 <typoclass> ocharles: right, but that's not prominently mentioned on the Control.Monad haddock page
04:57:55 <elliott> yeah, what ski said
04:57:56 <mm_freak> elliott: i corrected myself above, sorry
04:57:59 <elliott> relative monads are defined with that
04:58:07 <mm_freak> nerrz: not numbers
04:58:09 <mm_freak> but sets
04:58:17 <mm_freak> or groups or …
04:58:37 <nerrz> mm_freak: like, giving context to values?
04:58:51 <mm_freak> nerrz: category theory doesn't capture values
04:59:03 <mm_freak> unless the values themselves are morphisms or objects
04:59:06 <mm_freak> like in a monoid category
04:59:08 <typoclass> quchen: you know, i think yours is a pretty good approach, treating it as vocabulary. ("much like i don't question why you call a house 'maison' in french")
04:59:42 <nerrz> mm_freak: so then, what does a set represent in catagory theory
04:59:50 <mm_freak> nerrz: depends on which category
05:00:05 <mm_freak> nerrz: in the category Set of sets the objects are all sets, the morphisms are all functions
05:00:25 <bennofs> Where would you put a module for deriving Typeable instances using Template Haskell? Under Data.Typeable.TH?
05:00:36 <mm_freak> nerrz: in that category there is an endofunctor that maps every object X to 1 + X, which is the same set X, but with one additional distinct value, let's call it Nothing
05:01:19 <mm_freak> nerrz: that functor maps all morhpisms A -> B to 1 + A -> 1 + B, mapping Nothing to Nothing and everything else like the original function
05:01:27 <jamy023> quchen: absent of compute node depend on other. compute nor get
05:01:29 <mm_freak> nerrz: this functor turns out to be a monad
05:01:36 <mm_freak> nerrz: in haskell you know it as Maybe =)
05:02:08 <mr-> mm_freak: except for a different category? ;-)
05:02:10 <quchen> jamy023: I don't understand what you're saying :-/
05:02:13 <mm_freak> mr-: yeah
05:02:16 <mm_freak> Hask instead of Set
05:02:17 <nerrz> mm_freak: may I ask, what level of math / what classes did you take
05:02:23 <mm_freak> nerrz: none
05:02:27 <nerrz> really
05:02:29 <mm_freak> except school
05:02:39 <mm_freak> solving basic equations with single variables =)
05:02:49 <mm_freak> i'm the living proof that everybody can learn category theory =)
05:03:02 <quchen> mm_freak: I'm the living proof you're wrong :>
05:03:21 <mm_freak> quchen: you just didn't try hard enough…  CT isn't complicated, it's just very abstract
05:03:39 <nerrz> mm_freak: haha. hopefully I can too, did you find any specific textbooks or online resources particularly usefull
05:03:44 <quchen> mm_freak: Yeah, it's mostly a motivational issue. I agree that books and curiosity can get you a long way.
05:03:49 <mm_freak> nerrz: wikibooks =)
05:04:13 <mm_freak> nerrz: when you learn category theory, free your mind from the real world =)
05:04:21 <nerrz> mm_freak: hmm, I may need to look for a paper book, I have a hard time reading textbook style material online
05:04:29 <ocharles> mindblown.gif feels appropriate here
05:05:40 <nerrz> I like the idea of abstraction from the real world, I guess that is why I like programming
05:05:41 <jamy023> I say build node when need. You solution lacking of generate nodes. It has only get nodes from previously generated infinity list nodes
05:05:48 <adnap> mm_freak: Why should I learn CT?
05:05:58 <jamy023> quchen
05:06:08 <mm_freak> adnap: it gives you a powerful common language to talk about math
05:06:11 <nerrz> adnap: isn't the joy of learning and furthering your education enought?
05:06:19 <quchen> nerrz: Have a look at Awodey. I find it fairly accessible for a CT book. (It comes with examples even.)
05:06:32 <adnap> nerrz: I like learning, but I have to prioritize what I learn
05:06:36 <quchen> (Not a book but lecture notes you can print yourself though)
05:06:44 * Eduard_Munteanu likes nerrz's typo... e - nought
05:06:58 <mm_freak> hehe
05:07:08 <ocharles> adnap: you shouldn't now, ct is old. hott is all the rage
05:07:13 <adnap> mm_freak: A common language... for math?
05:07:27 <quchen> nerrz: Oh, it seems like it *is* a book. Let me see whether I can find you something more usable here.
05:07:35 <nerrz> quchen: thanks for the advice
05:07:43 <adnap> mm_freak: Like, I can talk about any kind of math using CT?
05:07:51 <nerrz> http://www.amazon.com/Steve-Awodey/e/B001IXMHHC ?
05:08:03 * hackagebot th-orphans 0.6.1 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.6.1 (MichaelSloan)
05:08:13 <mm_freak> adnap: pretty much
05:08:19 * ski str Cale had a pdf lying around ..
05:08:40 <adnap> I'm not convinced it's cool
05:09:10 <mm_freak> also i always say that category theory is the best web framework =)
05:09:14 <quchen> nerrz: Well, just look for "awodey category theory" I guess. The PDF I have is some preprint version, and they made a book out of it it seems.
05:09:38 <typoclass> adnap: i was told that CT will help you reason about your (haskell) code, even at the beginner level ("just learned how to apply a function to an argument"). i don't have an opinion on this myself; i was kinda baffled by the claim
05:09:41 <nerrz> quchen: is that amazon link the book?
05:09:49 <quchen> nerrz: It's been on my harddrive for quite some time in the folder of unloved-todo-books ;-)
05:09:59 <quchen> nerrz:  http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182
05:10:12 <mm_freak> for programmers CT provides formal notions of informal things
05:10:14 <adnap> I have seen some people talking using CT, and it seems like Haskell types are categories, and arrows are just functions
05:10:33 <nerrz> isn't there an arrow type in haskell?
05:10:35 <nerrz> or is that different
05:10:36 <adnap> I don't see why they don't just talk using Haskell
05:10:37 <mm_freak> it may sound ridiculous, but CT establishes a notion of when a software design is "sensible"
05:11:02 <nerrz> mm_freak: what do you mean by that?
05:11:18 <typoclass> mm_freak: interesting, is there a blog post or something that elaborates this?
05:11:30 <mm_freak> typoclass: not yet
05:11:35 <mm_freak> nerrz: associativity for example establishes a notion of "naturality"
05:11:36 <adnap> Also, Homotopy Type Theory...
05:11:43 <adnap> What does this have to do with CT?
05:12:34 <mm_freak> the composition operator in a monoid is in a very strong sense "natural" for the things it combines…  if it has special cases, it will unlikely be associative
05:12:36 <Cale> adnap: Homotopy type theory has a lot to do with category theory, but I've been up for too many hours to attempt to explain it right now.
05:13:03 * hackagebot th-orphans 0.7 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.7 (MichaelSloan)
05:14:44 <adnap> mm_freak: Can you say anything specific about CT that would make sense to me and relate to my knowledge of Haskell?
05:15:04 <quchen> jamy023: You can also generate nodes as needed, that's what infinite data structures are good for. This creates the entire Collatz tree: http://lpaste.net/90843
05:15:12 <adnap> I would only be interested in learning CT if it helped my programming skill. I don't care about learning CT for its own sake
05:15:17 <mm_freak> adnap: well, you use monoids all the time
05:15:38 <ocharles> monoids aren't really a CT specific thing, that's just abstract algebra
05:15:54 <mm_freak> a monoid is a single-object category
05:15:55 <ocharles> adnap: so you might want to start with just abstract algebra and go from there
05:16:01 <adnap> I have
05:16:03 <ocharles> mm_freak: sure, it has a CT definition
05:16:14 <adnap> I have Artin's book
05:16:25 <mm_freak> i think the CT definition is the most sensible one, and it really gives meaning to the "mono" in "monoid"
05:16:41 <ocharles> I'm studying http://www.goodreads.com/book/show/8295305-a-book-of-abstract-algebra and not even moving on to CT before I finish that
05:16:43 <nerrz> is monoid pronounce MO-NOID or MONO-ID
05:16:54 <dzelzs> mm_freak: algebra gives meaning for them too
05:17:03 <mm_freak> i pronounce it mo-noid
05:17:15 <nerrz> mm_freak: okay, that is how I pronounce that too
05:17:20 <quchen> gonoids! :D
05:17:22 <mauke> mon OID (wich a french accent)
05:17:23 <CaptainK> hemroids
05:17:25 <mm_freak> but you could pronounce it mono-it, too
05:17:40 <mm_freak> but it's a little awkward
05:17:54 <mm_freak> dzelzs: what?
05:17:57 <adnap> But, I don't understand why it's better to learn things like monoids in mathematical notation vs. just learning monoids in Haskell
05:18:00 <mauke> did you mean: haemorrhoids
05:18:13 <mm_freak> adnap: when you learn monoids in haskell, you learn monoids in math notation
05:18:13 <quchen> ewww mauke!
05:18:22 <ocharles> I asked my uncle in aus (professor in maths of some sort) for advice on CT, and his response was "I don't know much about it, but all the material I could provide you assumes solid knowledge of abstract algebra first, if only for exercises translating them into CT specific terminology"
05:18:32 <adnap> mm_freak: Pretty much
05:18:39 <nerrz> good, can't let all my nerd friends laugh at me for my mispronunciations
05:18:39 <mauke> quchen: ... but you're fine with CaptainK?
05:18:45 <adnap> So why should I pick up a math book?
05:19:00 <mm_freak> adnap: because it helps you reason about your monoids
05:19:00 <ocharles> adnap: I like thinking about problems outside an implementation
05:19:11 <nerrz> adnap: math is fun
05:19:16 <ocharles> mathematics gives me a sufficient abstraction that is rigorous enough to turn back into a program later
05:19:16 <adnap> ocharles: That's what an API is
05:19:20 <mm_freak> adnap: nothing in the type class documentation for Monoid explains that the identity element (aka mempty) is actually unique, for example
05:19:30 <ocharles> adnap: no, that's still too concrete
05:19:32 <mm_freak> adnap: it gives you what we like to call "theorems for free"
05:19:40 <ocharles> adnap: but along the right lines
05:20:11 <ocharles> adnap: not to say I sit down with gridded paper before I program, but I spot little abstractions and remember solving this problem generally before
05:20:14 <mm_freak> adnap: then there are many concepts that are not captured by haskell type classes
05:20:23 <mm_freak> adnap: for example monoid morphisms
05:20:26 <quchen> mm_freak: In what sense is mempty unique? All possible monoid instances of a type have the same mempty? Or did you just mean that there is mo mempty' /= mempty for a single instance
05:20:38 <mauke> quchen: the latter
05:20:46 <ocharles> quchen: there is a unique identity for any monoid
05:20:49 <mm_freak> if you've ever used foldMap from one monoid to another, you've likely actually used a monoid morphism
05:20:50 <quchen> mauke: Well, that one's kind of obvious then.
05:20:58 <mauke> quchen: how so?
05:21:19 <mm_freak> quchen: given a type X with a proper monoid instance, then let x and y both be identity elements
05:21:24 <mm_freak> quchen: by the monoid laws x = y
05:21:24 <quchen> mauke: Well, suppose you have two mempties, then "e = e' <> e = e'".
05:21:31 <mauke> quchen: you win the proof
05:21:55 <quchen> … am I missing something or were you serious
05:22:11 <quchen> (Is there more to it than that?)
05:22:17 <mm_freak> no
05:22:20 <quchen> Oh. Well.
05:22:22 <companion_cube> e * e' = e  and e * e' = e'
05:22:26 <dzelzs> mm_freak: not just x = y. x IS y
05:22:33 <mm_freak> dzelzs: no, x = y
05:23:03 * hackagebot acid-state 0.11.4 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.11.4 (DavidHimmelstrup)
05:23:26 <dzelzs> mm_freak: you wanna say that monoid can contain two identity elements?
05:23:28 <mauke> ∀intents and purposes
05:24:00 <elliott> dzelzs: wat
05:24:02 <nomadmonad> merijn: I hope I'm thanking the right guy from the yesterday Scheme interpreter tutorial pointer. At least the guy was something like your alias! :] Thanks!
05:24:24 <adnap> Is CT a large body of knowledge?
05:24:26 <elliott> dzelzs: suppose we have a monoid with identity element x. suppose we have another y that is an identity element for this monoid. then x = y
05:24:44 <alpounet> dzelzs, they just are the same. e = e * e' = e'
05:24:47 <adnap> ...compared to other areas of mathematics
05:24:55 <alpounet> both equalities hold because both are neutral
05:25:02 <alpounet> so e = e'
05:25:14 <mm_freak> dzelzs: read "=" as "is equivalent to"
05:25:24 <mm_freak> a monoid assumes an equivalence relation
05:26:08 <quchen> mm_freak: If you have an equivalence relation, two equivalent elements are still distinct, aren't they?
05:26:18 <quchen> If you factor the equivalence out, then they become identical
05:26:34 <Eduard_Munteanu> quchen: unless the relation is equality itself
05:26:49 <mm_freak> quchen: an equivalence relation is reflexive, i.e. x = x
05:26:54 <mm_freak> so they can be equal
05:27:01 <quchen> Eduard_Munteanu: Ah, right.
05:27:19 <mauke> @check join (==)
05:27:22 <lambdabot>   +++ OK, passed 100 tests.
05:27:30 <typoclass> i can't pretend i understand this discussion, sorry, but how would this hypothetical instance of Monoideven look? for example, wouldn't it be a compiler error to write "instance Monoid Weird where mempty = Something ; mempty = OtherThing"
05:27:57 <mm_freak> typoclass: the point is, you could choose either Something or OtherThing, if they are equivalent
05:28:02 <mgsloan> bennofs: Such a module exists: http://hackage.haskell.org/packages/archive/derive/2.5.11/doc/html/Data-Derive-Typeable.html
05:28:12 <mgsloan> albeit it's amongst a ton of other TH derivers
05:28:14 <bennofs> mgsloan: It doesn't work for my type
05:28:19 <mm_freak> the distinction between equality and equivalence is important, because in some Monads you don't get equality
05:28:22 <quchen> typoclass: The assertion was that you cannot have a monoid instance with "mempty" and "mempty2" that both act neutrally with respect to mappend and are unequal
05:28:26 <mgsloan> bennofs: Oh, no way
05:28:28 <mm_freak> or Monoids or …
05:29:01 <quchen> typoclass: In other words, there can't be another natural number except 0 that satisfies "x + 0 = x"
05:29:03 <mauke> typoclass: this discussion is mostly math, not haskell. but in haskell terms you'd look at mempty2, which would be global, not a part of Monoid
05:29:25 <bennofs> mgsloan: Well, my type is of kind ((* -> * -> *) -> * -> * -> *) -> * -> * -> *, and it gave some error, which I can't rememeber right now
05:29:31 <circle> this is offtopic slightly...but if I'm doing a report about a program, should I be using past tense ("the function performed this") or present ("the function computes ...")?
05:29:53 <mauke> or even "the function will compute ..."?
05:29:57 <Hafydd> If it's a pure function, it happily doesn't matter!
05:30:00 <bennofs> Btw, how do I use "not" in CPP in haskell?
05:30:01 <Eduard_Munteanu> I'd say present.
05:30:09 <mauke> bennofs: huh?
05:30:24 <bennofs> mauke: I want #if not(..), does that work?
05:30:24 <quicksilver> circle: present tense normally for describing the purpose of a function
05:30:31 <typoclass> circle: either one, i guess. slight preference for "performed" to show that you tried and observed it
05:30:32 <mauke> bennofs: only in C++
05:30:34 <mauke> bennofs: !
05:30:42 <quicksilver> circle: past tense if you are describing some particular occasion when you used it
05:31:07 <mgsloan> bennofs: Yeah, I'm really not sure how that library works, so who knows!  Anyway, Data.Typeable.TH sounds good to me!
05:31:23 <mm_freak> let me try it this way:  the C programs "x++; x++;" and "x += 2;" are not equal, they may even do different things when compiled
05:31:25 <circle> quicksilver: Interesting. So, say I'm describing the program ("the tree consists of...") or ("the tree consisted of...") you reckon present?
05:31:26 <mm_freak> but they are equivalent
05:31:28 <mauke> "in 2003, the function computed the biggest prime number known the man."
05:31:36 <mauke> "the function computes fibonacci numbers."
05:31:47 <quchen> bennofs: Maybe do something like   #if … #define foo #endif     #ifndef foo …
05:31:51 <mauke> "the function has computed over 9000 decimal places so far"
05:32:22 <Hafydd> It's a machine that computed those things. A function doesn't act.
05:32:33 <quchen> mauke: Must be a very mighty function if it manages to work with such large numbers.
05:32:34 <dzelzs> mm_freak: all depends on meaning of "equal" and "equivalent" words
05:33:20 <mm_freak> dzelzs: there is a certain equivalence relation by which the two programs are equivalent
05:33:34 <mm_freak> "equal" usually means "indistinguishable"
05:33:40 <mauke> "the function was sleeping when suddenly an operator tripped over the power cord"
05:34:07 <dzelzs> mm_freak: they produce the same result
05:34:29 <dzelzs> mm_freak: if it is what you call "equivalent" then yes, they equivalent
05:34:30 <mm_freak> dzelzs: that's hard to say in a side-effecting program…  in fact it's undecidable
05:34:32 <Hafydd> The function exacted its revenge, later, by stabbing the same operator 27 times in the chest with a carving knife.
05:35:05 <banister> anyone here know about promises?
05:35:18 <banister> the async programming pattern
05:35:39 <typoclass> @package async
05:35:39 <lambdabot> http://hackage.haskell.org/package/async
05:35:44 <mstksg> banister: a bit, but not in the context of haskell
05:35:46 <typoclass> banister: is this any good? ^^
05:35:57 <banister> typoclass: hehe, it's more i wanted to talk about the theory behind them
05:35:59 <mauke> "the function will be tried for assault with a battery"
05:36:11 <dzelzs> exit
05:36:14 <mm_freak> banister: as in what monad-par implements with its IVars?
05:36:14 <Hafydd> Hahah.
05:36:17 <banister> typoclass: i've seen people saying that promises are monads, and this makes me curious, do u know about this?
05:36:55 <typoclass> banister: i haven't heard about it. on first glance it sounds weird :-)
05:37:01 <mauke> is that just IO?
05:37:09 <mstksg> it makes sense to me
05:37:16 <Hafydd> Promises do very much resemble IO values, yes.
05:37:24 <banister> typoclass: http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/
05:37:25 <mstksg> the specs specify a bind
05:37:42 <mstksg> bind is striaghtforward and so is return
05:37:42 <dmwit_> bennofs: Ignore quchen; just use #else
05:37:54 <mm_freak> promises are value-level things, aren't they?
05:37:55 <banister> typoclass: actually what im really curious about is whether THIS: http://taskjs.org/   is kind of equivalent to 'do' notation for promises
05:37:56 <bennofs> dmwit_: Yeah, I found out ! works too :)
05:37:56 <quchen> dmwit_: Good advice. The second part too.
05:37:57 <typoclass> oh right! there's clearly a similarity between a promise and an action
05:37:58 <mauke> bennofs: ignore dmwit_; just use !
05:38:02 <bennofs> :)
05:38:07 <banister> typoclass: the yield there is like x <-
05:38:16 <banister> typoclass: the similarity is a bit striking to me
05:38:21 <dmwit_> bennofs: ignore dmwit_; mauke is smarter
05:38:22 <mm_freak> banister: that's just coroutines
05:38:47 <mauke> bennofs: ignore this
05:38:53 <banister> mm_freak: i know it's co-routines, but that could just be seen as an implementation detail of do-notation for javascript, no?
05:38:53 <mauke> (WHERE IS YOUR GOD NOW?)
05:39:16 <banister> mm_freak: i've seen do-notation libraries for python that work by co-routines
05:39:25 <banister> that look almost exaclty the same as that code, hold on
05:39:35 <bennofs> Does CPP also replace macros in haskell code?
05:39:39 <mm_freak> banister: not really…  coroutines are something very specific, and they are captured by certain monads
05:39:39 <banister> mm_freak: http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html
05:39:46 <bennofs> i.e. will this hack work: http://lpaste.net/90844
05:39:53 <mm_freak> like Free(T), Coroutine, Operational, etc.
05:40:25 <banister> mm_freak: see this: http://cl.ly/image/121p161j0M1E
05:40:49 <banister> mm_freak: looks totally analogous to taskjs.org's nice syntax for promises
05:41:05 <quicksilver> circle: "the tree consists of " works nicely for an abstract undetermined tree. "The tree consisted of" sounds like a specific, actual, run of the program you're discussing.
05:41:16 <mauke> bennofs: cpp is too stupid to recognize Haskell code, so yes
05:41:27 <circle> quicksilver: fair enough
05:41:31 <mm_freak> banister: seems like they use generators to get monadic do-notation
05:41:37 <bennofs> mauke: That's actually good news for me :D
05:41:46 <mm_freak> so it's an application of generators, but not for generators' sake
05:41:47 <banister> mm_freak: yes exactly, and that looks exactly like the taskjs.org pretty notation for promises
05:41:58 <banister> mm_freak: http://taskjs.org/
05:42:10 <banister> mm_freak: so couldn't taskjs be seen as a do-notation for the promise monad?
05:42:49 <bennofs> What, transformers doesn't provide the MonadTrans class?
05:43:04 <bennofs> @index lift
05:43:05 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
05:43:05 <lambdabot> ParserCombinators.ReadPrec, Text.Read
05:43:24 <mm_freak> banister: what is the promise monad?
05:43:46 <banister> mm_freak: well as i asked before "are promises monads?" :P this article says they are: http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/
05:44:37 <banister> mm_freak: if u dont know what promises are, the wiki page is pretty good http://en.wikipedia.org/wiki/Futures_and_promises
05:44:46 <banister> they're used all the time in async programming esp js
05:45:09 <merijn> promises are like threading for people who are sad enough not to have threads :)
05:45:58 <banister> merijn: ah, you'll know the answer: are promises monads? :D
05:46:23 <supki> I don't see any monad law proved in that article
05:46:38 <banister> supki: here https://gist.github.com/briancavalier/3296186
05:46:49 <banister> especially the comments
05:47:25 <NeatBasis> can someone explain me this? create_account :: (Monad m) => String -> m ()
05:47:36 <banister> supki: do you buy it?
05:47:41 <NeatBasis> what is it that is supposed to be returnad?
05:47:53 <NeatBasis> returned
05:47:55 <mauke> NeatBasis: a value of type m ()
05:47:57 <MasseR> NeatBasis: Simplified: it doesn't return anything
05:48:02 <Lethalman> NeatBasis, are you confident with String -> IO () ?
05:48:03 <mauke> MasseR: :-/
05:48:04 <MasseR> It corresponds to for example javas void type
05:48:08 <mauke> MasseR: no, that's ()
05:48:09 <MasseR> mauke: Simplified!
05:48:25 <mauke> no
05:48:28 <MasseR> No?
05:48:29 <Lethalman> MasseR, just avoid analogies
05:48:30 <NeatBasis> and what is a value of type m()=
05:48:33 <NeatBasis> ?
05:48:36 <mauke> you're talking on a different level
05:48:42 <mauke> NeatBasis: well, depends on what m is, exactly
05:48:49 <mauke> it's left unspecified here
05:48:53 <Lethalman> NeatBasis, if you are you confident with String -> IO () , then Monad m => String -> m () is much similar, except it works for every monad, not only IO
05:49:05 <mauke> I can give you a few examples
05:49:13 <mauke> :t [(), (), ()]
05:49:13 <lambdabot> [()]
05:49:17 <mauke> ^ that's for m = []
05:49:24 <mauke> :t Just ()
05:49:24 <lambdabot> Maybe ()
05:49:25 <NeatBasis> how would i specify it if I wanted to specify the type Account
05:49:27 <mauke> ^ that's m = Maybe
05:49:33 <mm_freak> banister: ah
05:49:40 <mm_freak> so promises are indeed IVars
05:49:45 <mm_freak> as implemented by monad-par
05:50:03 <MasseR> mauke: Mind if I ask some questions in private? Not to disturb proper questions here
05:50:14 <mauke> MasseR: I think you have a proper question
05:50:16 <banister> mm_freak: cool
05:50:25 <mauke> MasseR: what is Account, though?
05:50:31 <banister> mm_freak: what's a monad-par ?
05:50:37 <mauke> MasseR: and where did you find this create_account?
05:50:45 <MasseR> mauke: Wrong person here
05:50:55 <mauke> argh
05:51:13 <mauke> sorry
05:51:45 <NeatBasis> I have a specified type Account that I would like to return
05:52:05 <banister> mm_freak: the thing i find a bit confusing is, the promises 'then' can be seen as bind, as it unwraps the monad value and sends it to a function that messes with it and then returns returns a new promise (monadic value)
05:52:07 <mauke> NeatBasis: need more context
05:52:18 <mm_freak> banister: it's a library implementing the Par monad for parallel computing…  the difference is that Par doesn't allow side effects, but you can write IVar for IO as well
05:52:24 <banister> mm_freak: but 'then' in most implementations actually takes 2 functions, not just 1 like the normal 'bind'
05:52:27 <mm_freak> @hackage monad-par
05:52:27 <lambdabot> http://hackage.haskell.org/package/monad-par
05:52:53 <banister> mm_freak: i.e it also takes a failure callback, does this compromise its monad-ness at all? or can 'bind' legitimately take 2 function parameters?
05:53:04 <NeatBasis> I'm trying to get a job, and the module specification says "create_account :: (Monad m) => String -> m ()" and I'm supposed to specify the monad accurately or something
05:53:25 <mauke> NeatBasis: can you post the complete question somewhere?
05:53:37 <NeatBasis> No one of the applicants know haskell so they decided to see how fast they could learn
05:53:44 <NeatBasis> yesh
05:54:05 <JuanDaugherty> that's crazy
05:54:15 <JuanDaugherty> sounds like slavers from hell
05:55:10 <zomg> JuanDaugherty: sounds pretty reasonable tbh, if they can't find someone who knows haskell, better pick the one who is the best learner =)
05:55:13 <mm_freak> banister: monads themselves can carry a failure continuation along (that's basically what a CPS-transformed Either would do)
05:55:23 <mm_freak> banister: but the bind function itself cannot take multiple functions
05:55:45 <JuanDaugherty> zomg, well it depends on what the stipulations where, like timing ans so forth
05:56:21 <JuanDaugherty> but for the general situation of the programmer that doesn't know haskell at all, it's ball breakers united against the humble worker
05:56:29 <zomg> :P
05:56:42 <banister> mm_freak: ah ok
05:56:44 <zomg> well yeah, it's gonna be hard to pick up haskell quickly if you haven't used similar languages before
05:57:08 <jmcarthur_mobile> JuanDaugherty: I think it sounds fine even if you aren't applying for a Haskell job, myself
05:57:27 <banister> mm_freak: so, going back to my original question.. if the pythonic do-notation using co-routines is a valid do-notation, can taskjs be seen as a do-notation for promises?
05:57:29 <JuanDaugherty> and if it's supposed to be done without recourse to web and such it's flat out insane
05:57:29 <zomg> I picked up Ruby in a week
05:57:37 <jmcarthur_mobile> You don't have to master it. Just be among the best of the applicants who started on the same page as you
05:57:41 <zomg> Well, really more like two days, but in a week I was pretty decent with it
05:57:45 <zomg> Can't really say same about haskell
05:57:46 <zomg> =)
05:57:49 <elliott> lol, a job offer seeing who can ask #haskell the fastest
05:58:01 <JuanDaugherty> Ruby or other algol like lang totally different case
05:58:06 <jmcarthur_mobile> Okay yeah that's silly :p
05:58:13 <banister> zomg: Yeah it's easy to become competent with ruby, but it does actually have some quite subtle elements that take a while to master imo
05:58:30 <zomg> Yeah
05:58:41 <banister> ruby eigenclasses had me confused for a good while ;)
05:59:03 <zomg> NeatBasis: btw if they are looking to hire people who know Haskell, I'm available :P
05:59:06 <zomg> Only remote though
05:59:13 <zomg> Not interested in moving to the other side of the globe or anything like that
05:59:14 <zomg> =)
05:59:23 <typoclass> NeatBasis: alright ... so what's your question exactly? the signature of your create_account function says that it'll return (), which stands for an empty value
05:59:33 <mauke> no, it says it returns m ()
05:59:33 <JuanDaugherty> even knowing langs with unconventional models of computation like lisp or prolog doesn't prepare you for something like that with Haskell, unless as I say several days at least were given to the Haskell naive applicants
05:59:41 <NeatBasis> http://pastebin.com/XQ9h2gqN
05:59:42 <mauke> The paste XQ9h2gqN has been copied to http://lpaste.net/90845
06:00:10 <mauke> is that finnish?
06:00:18 <mm_freak> banister: i don't know…  you would have to prove the monad axioms first
06:00:47 <NeatBasis> Partially bad google translate, I was lazy
06:00:51 <NeatBasis> English
06:01:10 <MasseR> NeatBasis: May I ask what firm?
06:01:14 <zomg> Finnish? Where? :p
06:01:18 <banister> mm_freak: thanks for your help, interesting stuff (to me)
06:01:22 <MasseR> zomg: Exactly :D
06:01:37 <zomg> Oh in that paste, didn't look at it enough
06:01:38 <zomg> =)
06:01:44 <zomg> Probably Reaktor if it's a finnish company
06:01:46 <mauke> NeatBasis: I don't see Account there
06:02:00 <MasseR> zomg: Do they do haskell? I thought their functional language was scala
06:02:10 <zomg> I think they do, they tried to recruit me
06:02:17 <zomg> Wasn't interested in moving to Helsinki so that was that
06:02:31 <banister> zomg: oh is that the finnish company behind bacon.js ?
06:02:33 <kingugo> zomg good day
06:02:33 <MasseR> Heh. I originally wanted to appl ythere
06:02:33 <JuanDaugherty> is it Hell sinki?
06:02:41 <MasseR> banister: No, it was some other smaller firm
06:02:45 <banister> oh ok
06:02:51 <zomg> kingugo: hi?
06:02:57 <zomg> banister: uh, not sure :)
06:03:01 <kingugo> am good and u?
06:03:15 <zomg> kingugo: sorry I'm confused
06:03:30 <kingugo> ok, tryna get some help
06:03:32 <NeatBasis> There isn't. It's a type I've created in my own code that I'm just trying to return in the create_account function
06:03:42 <mauke> NeatBasis: ... why?
06:03:51 <mauke> NeatBasis: create_account can't return Account
06:04:11 <NeatBasis> Can it be modified slightly so that it can?
06:04:36 <MasseR> No sorry, I was mistaken, bacon.js apparently _is_ from reaktor
06:04:56 <MasseR> NeatBasis: Only if you change the signature
06:04:57 <mauke> ... yes, you could have create_account :: String -> Account
06:05:08 <mauke> but that's no longer what the exercise wants
06:05:13 <JuanDaugherty> so are a lot of gui hs pkgs backed up from neither of the main hs guis supporting 7.6?
06:05:22 <NeatBasis> So what could I get with m()?
06:05:34 <NeatBasis> anything usable?
06:05:42 <zomg> NeatBasis: if they want the result to be m (), then it's not supposed to return anything
06:05:46 <MasseR> NeatBasis: If we forget about the 'm' part, it is like javas void-type. As in it doesn't return antyhing
06:05:58 <NeatBasis> ok.
06:06:05 <kingugo> anyone who can help on installing haskell on kali?
06:06:11 <MasseR> NeatBasis: What they want is for you to do some side-effect with that function. Like write to database or file or something
06:06:17 <typoclass> NeatBasis: i'm guessing that by "String -> m ()", the folks meant you should write e.g. "String -> NeatBasisMonad ()". in other words, write your own type, which is an instance of typeclass monad, and put it everywhere you see "m"
06:06:31 <quchen> Is there any value other than "return ()" that has type "m ()"?
06:06:42 <mauke> quchen: yes
06:06:49 <quchen> mauke: In a total world?
06:06:53 <mauke> oh, like that
06:07:05 <NeatBasis> typoclass: I had the feeling they had that idea
06:07:20 <dmwit> quchen: I believe you are meant to read the entire block as having a big "exists m." around it.
06:07:22 <mauke> quchen: fail "hello"?
06:07:25 <elliott> this question is stupid, you should look at a different job :p
06:07:42 <quchen> mauke: Let's not use the f-word in this channel ;-)
06:07:44 <MasseR> I'll take your place ;)
06:08:21 <dmwit> JuanDaugherty: ENOPARSE
06:08:34 <ion> return (foo `seq` ())
06:08:37 <NeatBasis> The tsak was also to change the generic types to some specified type and to create those types mylsef. I've been using persistent to create a database from which I can get objects and create them.
06:08:56 <elliott> that seems like overkill.
06:09:05 <dmwit> Not to me.
06:09:17 <dmwit> That's basically exactly what the problem itself says to do.
06:09:37 <JuanDaugherty> dmwit, do you mean you don't understand my query?
06:09:42 <MasseR> Meh. File io is database enough IMO
06:09:44 <dmwit> JuanDaugherty: I do mean that.
06:10:10 <NeatBasis> I've studied/coded haskell now 26 hours total and although I'm not "scared of monads", I'm confused the hell out.
06:10:42 <Entroacceptor> confusion is good
06:10:49 <MasseR> NeatBasis: As you might have already noticed, this is a friendly place to ask questions (altough apparently not safe place to _answer_ questions :P)
06:11:08 <mauke> MasseR: you've barely lost any limbs yet!
06:11:14 <zomg> NeatBasis: monads aren't really much more than a data type with a specific set of things that can be done to them :)
06:11:29 <nerrz> yeah, don't be afraid to ask questions, I ask dumb questions all the time ^^
06:11:38 <nerrz> and your's are actually important
06:11:51 <JuanDaugherty> I've recently observed a lot of pkgs are at the 7.6.3 level. However wxHaskell and gtk2hs are both still 7.4 and SFAIK and think the case they won't build in 7.6.3. So packages such as leksah are blocked for that reason from moving to 7.6 unless I'm mistaken, could be whence the query.
06:11:57 <NeatBasis> I don't expect to be working much with haskell even after I'm hired, if that happens
06:12:12 <zomg> It's annoying that most cool jobs here are in the helsinki area :/
06:12:20 <dmwit> hum
06:12:23 <NeatBasis> Yeah
06:12:24 <MasseR> zomg: And tampere
06:12:28 <zomg> Oulu is supposed to be the "technology city" of Finland
06:12:34 <zomg> and we get pretty much nothing interesting :D
06:12:36 <NeatBasis> zomg: Turku seems quite dead
06:12:38 <MasseR> Found a firm that does haskell in there
06:12:41 <JuanDaugherty> zomg, here=finland?
06:12:44 <zomg> JuanDaugherty: ye
06:12:47 <hiptobecubic> Why would you live outside of helsinki? ;)
06:12:50 <MasseR> NeatBasis: ... you are in turku, and you have haskell exercises?
06:12:56 <dmwit> JuanDaugherty: According to my darcs logs, gtk2hs-0.12.4 should be 7.6-compatible.
06:12:58 <MasseR> I reiterate my question, which firm
06:13:05 <typoclass> NeatBasis: here is a cat for you http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526421&k=tSKXkj9&lb=1&s=L
06:13:16 <zomg> hiptobecubic: eh, I like being able to drive my car everywhere and I keep hearing it's not great in helsinki :D
06:13:31 <zomg> that, and I was born in Oulu and never had any reason to move elsewhere
06:13:32 <zomg> =)
06:13:33 <NeatBasis> typoclass: thanx, purr
06:13:40 <dmwit> JuanDaugherty: Also, according to http://www.haskell.org/haskellwiki/Gtk2Hs/Installation#Supported_Versions I tested that it built on 7.6 before releasing it.
06:13:44 <hiptobecubic> You haven't even checked?
06:14:38 <NeatBasis> What does this mean? `Account' is applied to too many type arguments
06:14:46 <nerrz> typoclass: that is a great link
06:14:47 <JuanDaugherty> dmwit, so you've observed gtk apps built in 7.6 working fine?
06:14:58 <NeatBasis> I have the definition as follows: create_account :: String -> Account ()
06:15:24 <mauke> NeatBasis: your Account type takes no parameters
06:15:37 <nerrz> the xmonad one got me
06:15:48 <dmwit> JuanDaugherty: I'm not sure, because the code that's on Hackage exists as an installation on my boxes for only a very short time, and I don't remember whether I actually built a program and ran it during that time.
06:15:52 <typoclass> NeatBasis: that means the Account type that you defined doesn't (yet) have a type parameter. you'd get the same error if (e.g.) you had written String () -> m ()
06:15:59 <kingugo> p/query Afc
06:16:04 <dmwit> JuanDaugherty: However, I have built and run programs with *some* version of gtk2hs in 7.6.
06:16:04 <kingugo> p/query AfC
06:16:09 <ski> Cale : hm, you mentioned a while ago a homotopy type theory definition of "suspension". how did this definition go exactly ?
06:16:15 <typoclass> NeatBasis: so, try "data Account a = ..." instead of "data Account = ..."
06:16:25 <MasseR> NeatBasis: On some level types are like functions. They can have parameters. `data Foo a = Foo a` is a one argument func.. type
06:16:41 <dmwit> JuanDaugherty: I don't want to guarantee that it was a released version, but I haven't seen any complaints or patches since the release that were specifically for 7.6-compatibility.
06:16:49 <JuanDaugherty> dmwit, meaning I take it that the gtk support might have been 7.4
06:17:12 <NeatBasis> How do I go about it of I already have a type Account that I get from persistent?
06:17:34 <dmwit> JuanDaugherty: No, gtk2hs officially supports 7.6. If you are having trouble, it is a bug, and I want details.
06:17:44 <NeatBasis> can I define data Account a somehow using that existing type?
06:17:44 <zomg> I think what the task asks might be doable in a few days assuming you had a tutorial that goes straight into the point of doing exactly that... but most of the haskell guides are rather inpractical when approaching web dev :P
06:19:12 <JuanDaugherty> dmwit, I see that it does now say that it does, coulda sworn it said 7.4 a few days ago
06:19:17 <MasseR> NeatBasis: There will probably be violence directed at me after this but; You can think of monads as containers. Some computation happen inside those containers, defined by the rules of the specific monad. What you need to do is to create or rather _find_ a monad that can handle side effects of your choosing (database writing / reading) and then implement the functions that work within that monad
06:19:40 <elliott> no violence, only sighing
06:19:52 <MasseR> elliott: But at least there weren't tacos
06:19:54 <nerrz> what's wrong with that description?
06:19:54 <MasseR> Or spacesuits
06:20:44 <Cale> ski: Susp A has a north pole and a south pole, (point) constructors n : Susp A, and s : Susp A, and then for each point in A, we put in a path between n and s, so  p : A -> (n = s)
06:21:29 <ski> Cale : hm, so we don't get a "point at the equator" for each point in `A' ?
06:21:35 <zomg> Why aren't monads just described as a data type with a bunch of functions? :P I mean that's essentially what it is in terms of what you do when using them =)
06:21:50 <merijn> nerrz: Well, look at the "(->) r" monad, would you call that a container?
06:21:57 <merijn> nerrz: Or the State monad?
06:21:59 <Cale> ski: No, but we can actually put them in, up to homotopy equivalence :)
06:22:24 <nerrz> merijn: I understand
06:22:25 <MasseR> merijn: I could say state monad a container :)
06:22:35 <merijn> MasseR: oh? A container of what?
06:22:42 <ski> Cale : also i was pondering how elimination of `Susp A' would work
06:23:25 <MasseR> merijn: A container of functions that can do stateful computations
06:23:53 <merijn> Oh, I forgot two very obvious ones
06:23:55 <merijn> STM and IO
06:24:21 <JuanDaugherty> sighing, derision, pity, but also maybe direction to the better tutorials
06:24:25 <elliott> ski: you get to case on "n" and "s" but have to respect the equalities, basically
06:24:53 <quchen> merijn: The container analogy always worked well for me. I understand the criticism, but thinking of "<- >>= pull something out" still helps me thinking.
06:25:00 <Cale> ski: When you write a function f : Susp A -> X, you specify points f n and f s in X, along with a function A -> (f n = f s)
06:25:01 <ski> (i suppose we might "put them in" by adding `e : A -> Susp A' and perhaps replacing `p : A -> (n = s)' by `np : (a : A) -> (n = p a)' and `sp : (a : A) -> (s = p a)')
06:25:01 <MasseR> quchen: Exactly
06:25:15 <quchen> merijn: But you're right, there's nothing "contained" in the "box that has x in it" sense.
06:25:22 <ski> elliott : yeah, i understand that, but how could it look, syntactically ?
06:25:30 <merijn> quchen: I've found that the analogy breaks down incredibly hard when you have to implement a monad
06:25:38 <elliott> ski: syntactically as in, how would you sugar the eliminator?
06:25:47 <MasseR> merijn: You shouldn't always throw people to the deep end
06:25:49 <dmwit> merijn: Well, (->) r is a very good container. It's a container with one slot per inhabitant of r.
06:25:57 <elliott> ski: usually people envision the sugar as being that your equivalent of the "case" expression gets additional cases corresponding to the path elements
06:26:04 <elliott> where you have to return the relevant path
06:26:04 <MasseR> At least not when they have had only 26 hours of studying behind them
06:26:16 <quchen> merijn: I've found the exact opposite. To implement Reader the first time myself, I used the container analogy: pull value out of the old value, make new monadic value.
06:26:27 <merijn> MasseR: In that case they should go back to functors, types and typeclasses and ignore the existence of monads
06:26:44 <quchen> merijn: A `(->) r` "contains" what the function yields when applied to the environment, for example.
06:26:48 <zomg> MasseR: yeah but you could just say it's a data type with a set of functions even if you've only used haskell for 26 hours that should make sense assuming you've used other prog langs before =)
06:27:03 <zomg> hell, it would make more sense than saying it's a container but not really
06:27:03 <zomg> :P
06:27:06 <MasseR> zomg: Sure. But I find that that doesn't contain any information n it
06:27:08 <MasseR> *in it
06:27:21 <MasseR> It wouldn't give me the idea of what and why
06:27:24 <typoclass> NeatBasis: the "m" that you're implementing is not meant to represent an account, it's meant to allow you to talk to the database. think of it as a connection, or an interface to the database. someone will call one those 5 functions you mentioned, then your code does work, and talks to the database (i.e. persistent) to make things happen. then it may or may not return something to the caller. in the case of create_account, it is specifi
06:27:35 <quchen> merijn: What I meant to illustrate with that is that having odd mental models is not necessarily such a bad thing.
06:27:36 <Cale> ski: Well, the map which would send A -> Susp A by sending every point to a point on the equator is homotopic to the map which sends everything in A to the north pole.
06:27:52 <Cale> ski: (i.e. to the corresponding point on the equator)
06:28:07 <ski> elliott,Cale : mhm .. i was wondering because i had an idea myself of a possibly nice way to do it
06:28:18 <zomg> MasseR: well since most monads are used for different purposes, the information would be specific to each monad
06:28:31 <MasseR> quchen: after all, we're not all mathematicians and shouldn't be. I understand the monad rules, but I don't need to understand them to use monads (including finding suitable monads)
06:28:43 <nerrz> In first year physics they say that current is kind of like water pipes but not really. Isn't that kind of the same as saying Monads are kind of like containers but not realy, it makes it easier to mentally visualize the concept
06:28:45 <NeatBasis> typoclass: so it's a db connection that needs to be passed on so that i can be reused?
06:28:47 <MasseR> zomg: A function is a thing made of letters
06:28:56 <MasseR> That has about as much information portrayed
06:29:06 <elliott> ski: but currently the way it is done is, you get a type-theory style eliminator with an extra argument for preserving equalities
06:29:25 <ski> ok, like `foldr' or `cata'
06:29:27 <zomg> MasseR: usually the first monad people see is IO. And immediately it looks completely different from a container =)
06:29:39 <quchen> MasseR: Even in mathematics I do these things. To give an example, I find the picture of the path integral summing up a lot of wobbly lines works quite well. It is of course also helpful to know the mathematical side.
06:29:42 <Cale> ski: So you could just write that function instead. But if you want to express it, I don't know, more intensionally, I suppose, you would construct a new type similar to Susp A, but which had an explicit copy of A serving as the equator, and paths from that copy up to the north pole and down to the south
06:29:50 <Itkovian> zomg it's just a very big container, no?
06:29:56 <Cale> ski: and then you'd show that type is homotopy equivalent to Susp A
06:29:57 <elliott> ski: well, more dependent than that
06:30:05 <MasseR> zomg: True. But when you are first shown the container analog, you can see the analog working with IO too
06:30:07 <Cale> ski: Univalence would then make them equal as types
06:30:19 <zomg> MasseR: I suppose you could consider IO as "containing" side effects :P
06:30:21 <elliott> ski: like this: http://homotopytypetheory.org/2011/04/04/an-interval-type-implies-function-extensionality/ http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/
06:30:27 <nerrz> zomg: IO is kind of like a container
06:30:27 <ski> elliott : yeah, but basically a combinator
06:30:28 <typoclass> NeatBasis: yes it is. however the "passing on" in haskell is done automatically, at least with the approach used in your question. any function of the form "... -> ... -> m ..." automatically has access to the stuff in m
06:30:33 <MasseR> [filename] <- getArgs -- I take a value from a world container
06:30:37 <elliott> ski: the latter has an Agda type for the eliminator for the interval type
06:31:03 <ski> Cale : hm, interesting
06:31:11 <NeatBasis> what would the usage of these fuctions look like?
06:32:23 <NeatBasis> As fars as i know I have not seen this in any of the tutorials I've been reading. At least not like this
06:32:46 <Cale> ski: It's important to notice that paths are equations when thinking about how you're defining functions
06:32:47 <zomg> NeatBasis: you haven't seen do-notation?
06:32:50 <ski> elliott : `I-rec' i take it
06:32:53 <MasseR> NeatBasis: An example of an IO monad. do { foo <- get; put (foo + 1) }
06:32:54 <elliott> ski: yes
06:32:56 <MasseR> .. State
06:32:57 <MasseR> Not IO
06:33:15 <elliott> ski: along with the computational axioms after it
06:33:44 <NeatBasis> I have seen do notation, but I don't understand how exactly it connects to this problem
06:33:48 <ski> Cale : m, trying to reconcile the "paths are equalities" with "(usually) lots of points lie on paths" :)
06:34:03 <zomg> NeatBasis: do-notation is syntactic sugar for working with monads
06:34:04 <NeatBasis> I feel I'm missing something fundamental here
06:34:19 <zomg> haha well with 26 hours in to haskell you probably are :P
06:34:22 <Cale> ski: Well, we're only defining functions up to homotopy equivalence
06:34:25 <zomg> but that's absolutely normal
06:34:28 <NeatBasis> zomg: that sentence means very little to me
06:34:32 <zomg> I thought it might
06:34:32 <zomg> :P
06:34:38 <Cale> ski: (and spaces)
06:34:42 <MasseR> NeatBasis: Hmm... "I see he used get and then put, but what does that have to do with anything"?
06:35:03 <zomg> NeatBasis: what exactly is the problem? I've been sorta following but not closely enough I think..
06:36:05 <elliott> ski: it's important to note that the exotic equalities you define aren't the same as "refl"
06:36:25 <elliott> there are equalities in HoTT that are observationally different to those you get from reflexivity
06:36:51 <ski> "observationally different" in which sense ?
06:37:06 <NeatBasis> First of all I have no idea how the functions in the module are supposed to be used or how vaguely were the functions in my assignment defined
06:37:11 <Cale> ski: Ordinary sets are captured by spaces where there's at most one path between any two points (and often none, if the set is to have more than one element)
06:37:30 <ski> (i get that they are different, in that they identify things that wouldn't otherwise be identified, like the relations in a presentation of a group with generators)
06:37:51 <zomg> NeatBasis: well can't help with the vagueness, I'd suggest asking for more details.. but as far as I can tell the functions..
06:37:56 <bitonic> ski: observationally equal = you can replace them for one another in the code without other changes, while preserving semantics
06:38:08 <dmwit> NeatBasis: I expect the only vagueness is that you can instantiate the type variable "m" however you like, provided you also give a "Monad" instance for your instantiation.
06:38:08 <zomg> NeatBasis: create_account is supposed to take a string arg and create an account (probably just INSERT into DB)
06:38:14 <MasseR> NeatBasis: How much time have you got for this assignment?
06:38:20 <zomg> NeatBasis: transfer same really, with more args
06:38:30 <ski> bitonic : yes, i was wondering whether it was this sense that elliott meant
06:38:30 <zomg> NeatBasis: balance and history seem to be similar, but they also return values
06:38:41 <NeatBasis> I've had a week and this is the last day
06:38:51 <MasseR> NeatBasis: And most of the time you don't implement your own monad from the scratch
06:39:14 <bitonic> ski: I’d guess so
06:39:25 <zomg> NeatBasis: so this is supposed to be done using Yesod?
06:39:30 <Cale> ski: We can define h-level 0 to consist of just the contractible space, which is essentially a single point. Then h-level (n+1) consists of spaces where the space of paths between any pair of points is of h-level n.
06:39:36 <elliott> ski: well, for instance, a striking example is that univalence gives you two equalities of (bool = bool).
06:39:44 <typoclass> NeatBasis: here is a minimal example of how to use the monad you're implementing http://lpaste.net/90846
06:39:46 <Cale> ski: Then h-level 1 will consist of the empty space and the contractible space (truth values)
06:40:05 <elliott> ski: one is the obvious boring reflexive one, where substituting by it does nothing. the other arises from the isomorphism not : bool -> bool, and e.g. substituting a bool value by it *negates* that value!
06:40:17 <bitonic> ski, elliott: although obviously the equalities arising by reflexivity are not the only ones that relate observationally equal things
06:40:27 <Cale> ski: and h-level 2 will consist of spaces where for any two points, either there's a contractible space of paths between them, or an empty one, which are like sets
06:40:29 <NeatBasis> zomg: it's recommended
06:40:42 <ski> Cale : "contractible" corresponding to "at most one element" ?
06:40:46 <Cale> yeah
06:40:52 <elliott> contractible means exactly one element, no?
06:41:05 <elliott> it's exists x:A. forall y:A. x = y
06:41:11 <zomg> NeatBasis: okay, if keeping it simple, you could put it into the Handler monad, eg m () would become Handler ().. This way you could call them straight in your web page handlers
06:41:25 <elliott> so h-level 0 is the true propositions, h-level 1 is the propositions, etc.
06:41:42 <Cale> uh, yes
06:42:01 <elliott> (and "h-level n" is equivalent to "(n-2)-truncated")
06:42:20 <zomg> NeatBasis: if you don't understand that then I think you might sadly be out of time at this point, though I doubt any other applicants would fare much better unless they spent literally the whole week on it :)
06:42:27 <Cale> there's really just one contractible space up to isomorphism, and the space with just a single point does the trick
06:42:32 <ParaSa1lin> @hoogle pow
06:42:33 <lambdabot> package powermate
06:42:33 <lambdabot> package powerpc
06:42:33 <lambdabot> package traypoweroff
06:42:58 <ski> elliott : hm. but also substituting by `not' in the context would also not make any observable difference
06:43:03 <Cale> It's important to note when looking at the definition of contractibility given there that everything is assumed to be continuous
06:43:28 <ParaSa1lin> what package contains exponentiation :: Fractional a => a -> a -> a
06:43:39 <Cale> So that's a continuous assignment of paths from x to y
06:43:54 <ParaSa1lin> @hoogle Fractional a => a -> a -> a
06:43:55 <circle> how do I "add an instance declaration for (Eq NodeType)"
06:43:55 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
06:43:55 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:43:55 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
06:44:06 <elliott> ski: sure it would
06:44:19 <elliott> ski: let's say you have coerce : (A = B) -> A -> B
06:44:32 <Cale> Well -- the formalism doesn't admit you to write "discontinuous" ones. It's just if you interpret that logical expression classically, it doesn't work.
06:44:34 <elliott> ski: then coerce (univalence not_equiv) false = true, which is pretty observationally different :P
06:44:54 <elliott> ski: but it's true that, e.g. substituting any proposition over bools by it gives you an equivalent proposition back, or such.
06:45:36 <Cale> For example, in a classical setting, I can say "there exists a point x on the circle such that for every point y on the circle, there is a path from x to y" -- in fact, any point will do.
06:46:02 <Cale> But that choice of path won't be continuous in the choice of y
06:46:07 <ski> circle : addinging `deriving Eq' to the definition of the data type `NodeType' might work
06:46:09 <ParaSa1lin> @ty (**)
06:46:11 <lambdabot> Floating a => a -> a -> a
06:46:13 <ParaSa1lin> ah
06:46:18 <ski> s/addinging/adding/
06:46:22 <typoclass> NeatBasis: (my personal opinion is that they asked you a bizarre complicated question. rewriting the map function, or fibonacci numbers is reasonable. your thing is throwing people in at the deep end, and i'm not really sure what the use is. but should you manage it, then all the more kudos)
06:46:31 <circle> ski: I did that, then it gave me the message you saw
06:46:45 <NeatBasis> what I'm currently doing is just using the persistent sqlite http://pastebin.com/0H5sNW8d
06:46:47 <mauke> The paste 0H5sNW8d has been copied to http://lpaste.net/90847
06:47:26 <Cale> ski: anyway, I don't know if that clarifies things at all?
06:47:32 <circle> ski: ah, wait, sorry
06:47:36 <circle> ski: i missed something
06:47:51 <NeatBasis> there's some other imports as well there, but not included
06:48:10 <Cale> Also, everyone interested in HoTT should note that there is now a ##hott
06:48:13 <NeatBasis> I should have said trying to do
06:48:55 <ski> Cale : hm, perhaps this is a bit related to squaring on complex unit circle being surjective, but not having a continuous inverse
06:49:09 <ski> s/related/similar/
06:49:40 <NeatBasis> Sorry, wrong code
06:49:52 <ski> Cale : maybe
06:50:08 <typoclass> NeatBasis: line 7 needs some changing. you need only "create_account name". the part "= insert $ ..." belongs in the implementation, which you presumably have in Accounting.hs :-)
06:50:10 <NeatBasis> the last line should have said create_account "xcvxcv"
06:50:11 <ski> elliott : i'm not sure of the type of `equivalence' here
06:50:22 <Cale> ski: That's also related to the fact that given the construction of the circle with constructors base : circle and loop : base = base, the space base = base is equivalent to the integers :)
06:50:22 <typoclass> NeatBasis: alright then
06:50:39 <merijn> NeatBasis: Who gave you this assignment? Is it course work? If so, it seem like they rather over shot the skill required
06:50:47 <elliott> ski: you can introduce it with an isomorphism (and at least as far as bool goes, treat it as the same as one informally for all practical purposes)
06:50:52 <NeatBasis> It's just that I didn't get the create_account to compile since I don't know what to return
06:51:05 <typoclass> merijn: question at a job interview
06:51:06 <Cale> ski: you have ..., loop^-1 . loop^-1, loop^-1, refl, loop, loop . loop, ...
06:51:19 <Cale> and those are all inequivalent
06:51:22 <NeatBasis> It's a test if you can manage to learn and code haskell in a week
06:51:29 <typoclass> NeatBasis: try "return ()" as the last line in the do block of create_account
06:51:35 <merijn> typoclass: Ah, in that case I guess it depends on the minimal necessary haskell skill or not
06:51:35 <elliott> (and you can compute the isomorphism between them and the integers)
06:52:16 <merijn> NeatBasis: tbh, I think this task is completely unreasonable to learn in one week if you don't have prior haskell knowledge/experience
06:52:23 <typoclass> merijn: well ... i don't know why they didn't let them, like, reimplement 'map' or something
06:52:34 <typoclass> merijn: yeah exactly :)
06:52:46 <merijn> typoclass: Well, if you want experienced haskell hacker then clearly you don't want someone to implement map or so
06:53:01 <ski> Cale : yeah, that's another thing that i was wondering : how values in (non-trivial) equality types (like those inductively defined above) look like and behave, computationally
06:53:01 <Cale> ski: It's actually possible to formulate the group of integers in any way that you'd like, and construct an equivalence between base = base and that type, and that's been done in at least a couple ways :)
06:53:44 <NeatBasis> I think this is a bad coding test in that sense that even a partial completion requires quite a lot
06:53:45 <Cale> ski: Your paths always form a groupoid, so you can compose them when they line up end to end and invert them
06:53:51 <elliott> ski: a full computational story isn't quite known yet
06:54:13 <Cale> ski: and the paths between those paths do as well, and so on.
06:54:14 <typoclass> merijn: sure, but as i understood, the situation was that none of the applicants knew haskell
06:54:31 <merijn> NeatBasis: Well, it's actually not that much work if you know haskell, afaict. It's just a completely unreasonable amount of learning for people who don't already know
06:54:56 <ski> elliott : `univalence' (or `univalence not_equiv' ?) being an isomorphism ?
06:55:07 <elliott> ski: not_equiv is an equivalence
06:55:53 <elliott> ski: say equiv A B := (f : A -> B) * ((g : B -> A) * (g . f = id)) * ((h : B -> A) * (f . h = id))
06:55:57 <ski> Cale : yeah, so `loop' has a left and a right inverse, and those are equal(?)
06:56:09 <elliott> ski: (the different "g" and "h" is intentional)
06:56:20 <elliott> er.
06:56:21 <Cale> ski: it has a proper inverse, yes
06:56:23 <NeatBasis> HAH! got the first fuction to compile
06:56:28 <elliott> ok my definition isn't quite right.
06:56:37 <NeatBasis> create_account :: (PersistStore m) => String -> m ()
06:56:40 <elliott> I should just tell you to Ctrl+F equivalence in the HoTT book pdf or something :p
06:56:44 <ski> (i wonder whether one could encode left- and right- inverses, which are not equal)
06:56:53 <Cale> Of paths?
06:56:56 <typoclass> NeatBasis: alright then :)
06:57:09 <Cale> The paths are meant to form a groupoid, rather than an arbitrary category
06:57:40 <Cale> (well, actually it's more than just a groupoid because the paths between paths do too, and so on forever)
06:58:05 * hackagebot typeable-th 0.1 - Automatic deriving of TypeableN instances with Template Haskell  http://hackage.haskell.org/package/typeable-th-0.1 (BennoFuenfstueck)
06:58:12 <Cale> But ignoring all the higher structure, it's like a category in which every arrow has an inverse
06:59:03 <ski> ok
06:59:04 <cidevant> Hello ! do anybody has yesod tutorial app, where u do something like this
06:59:04 <cidevant> getEntryR entryId = do
06:59:05 <cidevant>     (entry, comments) <- runDB $ do
06:59:05 <cidevant>         entry <- get404 entryId
06:59:05 <cidevant>         comments <- selectList [CommentEntry ==. entryId] [Asc CommentPosted]
06:59:05 <cidevant>         return (entry, map entityVal comments)
06:59:08 <cidevant> ??
06:59:13 <cidevant> Yesod 1.2
06:59:38 <typoclass> cidevant: hello, please use http://lpaste.net/ for code that is longer than one line
06:59:47 <cidevant> typoclass: ok, thx
07:01:36 <Cale> ski: but that is a good question in general -- if you try to generalise to non-invertible arrows and maintain the higher dimensional structure (paths between paths and so on), then you'll likely end up with various sorts of (infinity,n)-categories and things like that :)
07:02:59 <ski> Cale : hm, i think i had some vague idea of symmetric vs. braided in mind, but i'm not sure it's coherent
07:04:01 <Cale> well, those relationships fall out of higher categories pretty quickly too, yeah :)
07:05:13 <ski> i was pondering `data Nat : Set where 0 : Nat; 1 : Nat; _+_ : Nat -> Nat -> Nat; LUnit : (n : Nat) -> (0 + n = n); RUnit : (m : Nat) -> (m = m + 0); Assoc : (m : Nat) -> (n : Nat) -> (o : Nat) -> ((m + n) + o = m + (n + o))', and how to define `_*_ : Nat -> Nat -> Nat' based on this
07:05:55 <elliott> you'd define it recursively on the tree
07:06:01 <elliott> and have some extra cases showing you respect the equalities
07:06:07 <elliott> like a quotient type
07:07:08 <Cale> Yeah, you'll be forced to prove that however you define multiplication, it respects the associativity and units of addition... I suppose in each argument.
07:07:45 <elliott> I think you'd maybe only have to eliminate on the first argument?
07:07:49 <elliott> not sure
07:08:25 <Cale> Well, you'll have for each first argument, a function Nat -> Nat which you'll have to show respects the equations
07:08:41 <ski> `0 * p = 0; 1 * p = p; (m + n) * p = (m * p) + (n * p)' is obvious, but i think i want something like `congr (\x -> x * p) (LUnit n) = LUnit (n * p); congr (\x -> x * p) (RUnit m) = RUnit (m * p); congr (\x -> x * p) (Assoc m n o) = Assoc (m * p) (n * p) (o * p)'
07:08:42 <Cale> and then you'll have to show that that choice of function does
07:09:28 <elliott> ski: right, that's what you could write those cases as
07:09:31 <elliott> (presuming appropriate sugar)
07:09:40 <Cale> It'd probably be easier to look at double : Nat -> Nat first
07:10:14 <ski> (with `congr : {A B : Set} -> {a0 a1 : A} -> (f : A -> B) -> (a0 = a1) -> (f a0 = f a1)')
07:11:00 <ski>   double 0 = 0
07:11:05 <ski>   double 1 = 1 + 1
07:11:15 <ski>   double (m + n) = double m + double n
07:12:08 <Cale>   double (LUnit n) : (double 0 + double n = double n)
07:12:47 <Cale> er
07:12:56 <Cale> no, it's just double (0 + n) = double n
07:13:21 <elliott> ski: (here Cale is using an equivalent but different imaginary sugar to the one you used)
07:13:22 <ski>   congr double (LUnit n) = LUnit (double n)  -- in my notation
07:14:38 <Cale> Yeah, you take the endpoints of each constructor path and apply the function to them, and you'll be required to provide a path of that type
07:14:43 <ski>   double (0 + n)  ={FOLD double.+}=  double 0 + double n  ={FOLD double.0}=  0 + double n  ={LUnit n}=  double n
07:15:04 <ski> (is the implicit chain followed by the type system)
07:15:30 <ski> (er, s/={LUnit n}=/={LUnit (double n)}=/, i.e.)
07:15:31 <elliott> ski: the language isn't going to rewrite by the additional equalities definitionally, afaik
07:15:36 <elliott> they're too powerful :)
07:15:49 <elliott> i.e., you'd have to invoke LUnit explicitly in your proof, I think
07:15:55 <Cale> Yeah, and there might be more than one inequivalent proof you could give
07:15:59 <elliott> (or use a tactic or such)
07:15:59 <ski> elliott : yes, which is why there's `LUnit (double n)' in the definiens, rather than just a `Refl' :)
07:16:03 <Cale> (I'm not sure in this case!)
07:16:07 <elliott> ah, right
07:16:44 * elliott thinks congr wants a nice infix operator for ski's sugar :P
07:17:11 <Cale> anyway, I'd *really* better sleep
07:17:26 <Cale> been up like 20 hours
07:17:30 <ski> well, i have another notation, which doesn't mention an identifier like `congr' -- but i'll have to ponder it more
07:18:06 <Cale> http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html -- these lectures are awesome btw
07:18:10 <ski> Cale : heh, ditto (though a bit more)
07:18:13 <NeatBasis> Do i need to create a function in order to get information from my own datatype? such as Account.name
07:18:35 <Cale> NeatBasis: If you're using record syntax, you can write  name myAccount
07:18:44 <typoclass> NeatBasis: no, you get the 'name' function for free. (i'm assuming you used record syntax?)
07:18:57 <bgamari> Why is it so difficult to derive a Show instance for a type "data Hello s a = Hello (s (s a))"
07:19:00 <bgamari> I get,
07:19:01 <bgamari>     No instance for (Show (s (s a)))
07:19:01 <bgamari>       arising from the 'deriving' clause of a data type declaration
07:19:18 <Cale> bgamari: Is there an instance Show a => Show (s a) ?
07:19:23 <Cale> er
07:19:33 <NeatBasis> okay
07:19:33 <bgamari> And when I try a standalone deriving instance it mumbles something about undecidable instances
07:19:34 <typoclass> NeatBasis: record syntax looks like data Account = A { name :: String }
07:19:37 <Cale> Well, s is a parameter
07:20:39 <bgamari> Right
07:20:39 <Cale> bgamari: Try writing a standalone deriving declaration like   deriving instance (Show (s (s a))) => Show (Hello s a)
07:20:45 <bgamari> yep
07:20:50 <Cale> oh
07:20:52 <mauke> @let data Hello s a = Hello (s (s a)) deriving (Eq, Ord, Show)
07:20:52 <lambdabot>  .L.hs:153:26:
07:20:52 <lambdabot>      No instance for (Eq (s (s a)))
07:20:52 <lambdabot>        arising from the 'd...
07:20:54 <bgamari> then I get complaints about the     Variable `s' occurs more often than in the instance head
07:20:55 <bgamari>       in the constraint: Show (s (s a))
07:20:56 <Cale> Still, eh?
07:20:57 <mauke> thought so
07:21:21 <mauke> FlexibleContexts? or does that require UndecideableInstances?
07:21:25 <Cale> oh, right, maybe just throw in UndecidableInstances?
07:21:36 <bgamari> GHC seems to think it requires UndecidableInstances
07:21:40 <Cale> I'm pretty sure that one's more than FlexibleContexts
07:21:41 <bgamari> but I really don't understand why
07:22:11 <Cale> bgamari: It's because the (rather simple) rule that GHC uses to try to prove that instance resolution terminates doesn't apply to instances like that one
07:23:07 <bgamari> alright, so I guess this is one of the cases where UndecidableInstances really is necessary  but not problematic?
07:23:23 <danharaj> UndecidableInstances is hardly ever problematic.
07:23:28 <elliott> bgamari: consider Fix Hello or whatever
07:23:33 <elliott> well
07:23:34 <elliott> never mind
07:24:18 <Cale> It's Overlapping and Incoherent instances where things start to get bad
07:24:45 <Cale> The worst thing that UndecidableInstances will do is allow a program to try to compile and end up getting the compiler into an infinite loop.
07:25:11 <Cale> So if the compiler terminates, you're okay :)
07:25:21 <danharaj> I think GHC cuts off instance resolution at a certain depth anyway.
07:25:28 <danharaj> So not even an infinite loop :P
07:25:32 <Cale> heh
07:26:45 <bgamari> Cale, Alright, excellent
07:26:46 <bgamari> thanks
07:30:31 <merijn> It's that time of the day where all my type signatures appear to be 140+ characters long >.>
07:30:59 <mauke> how many type variables, though?
07:31:24 <merijn> unique or total?
07:31:49 <mauke> unique
07:31:54 <circle> how do I use multiple "where" clauses?
07:32:03 <merijn> (3 vs 15)
07:34:03 <ski> circle : you can place multiple definitions in a single `where' clause
07:34:16 <circle> ski: go on
07:34:26 <ski> you can also nest a `where' clause inside another, by attaching it to a defining equation inside the other one
07:34:44 <ski>   f x = ...
07:34:46 <ski>     where
07:34:50 <ski>     a = ...
07:34:54 <ski>     g y = ...
07:35:25 <merijn> circle: See https://github.com/merijn/haskellFoldIndent#automatic-block-indent for a bunch of examples
07:35:31 <ski> is placing both a definition of `a' and a definition of `g' inside the `where' clause attaching to this definining equation of `f'
07:35:48 <circle> ski, merijn thank you
07:36:09 <ski> both the definition of `a' and of `g' use `x' (as well as use `a' and `g' (and `f') recursively) (`g' may also use `y')
07:36:27 <ski> and the direct body of `f' may use `x',`a' and `g' (but not `y')
07:37:43 <circle> I'm getting "parse error in input 'where'" when I try to indent
07:40:24 <merijn> circle: Are you using tabs?
07:40:30 <circle> spaces
07:40:35 <circle> ill pastebin it
07:40:35 <circle> sec
07:41:25 <circle> http://lpaste.net/new
07:41:58 <bennofs> circle: That url can't be right
07:42:05 <circle> ooops
07:47:36 <circle> nevermind
07:47:39 <circle> you can't indent where clauses
07:48:06 * hackagebot persistent-redis 0.0.2 - Backend for the persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.0.2 (PavelRyzhov)
07:50:56 <ski> circle : .. depends on what you mean
07:51:20 <ski> (if you paste some code, perhaps we'd have an easier time guessing)
07:52:24 <bgamari> Ghoul_, Why  do you want a spinlock?
07:52:31 * bgamari is quite curious
07:57:09 <merijn> whooo, up to 192 char type sig :)
07:57:22 <ski> Happy Happy Joy Joy.
07:57:44 <augur> ren and stimpy haskell!
07:57:55 <ion> Ren Curry
07:58:35 <augur> haskell stimpy
07:58:43 <bennofs> merijn: pipes or lens? :P
07:58:47 <JuanDaugherty> why is that ski? (My Chinese name is Ren Ren Juan)
07:59:29 <JuanDaugherty> ( 仁 人 卷 )
07:59:33 <merijn> bennofs: My own code
07:59:36 <bennofs> :O
07:59:51 <merijn> (Well, using reactive-banana)
08:00:32 <augur> JuanDaugherty: juan with a j?
08:00:36 <augur> is your name the spanish juan?
08:00:48 <JuanDaugherty> y
08:01:18 <JuanDaugherty> the aspirated J which is difficult for some English monoglots
08:01:21 <ski> JuanDaugherty : why is what ?
08:01:38 <JuanDaugherty>  Happy Happy Joy Joy.
08:01:55 <ski> oh. because we like types here
08:02:01 <JuanDaugherty> ah
08:02:39 <augur> JuanDaugherty: aspirated j in your name, or in the chinese?
08:02:55 <augur> JuanDaugherty: let me clarify
08:03:02 <augur> your username is "juan daughterty"
08:03:09 <augur> and you said your chinese name is ren ren juan
08:03:21 <JuanDaugherty> no the chinese is Ju an which is the way it's pronounced in some English speaking places, the UK especially
08:03:25 <augur> so either a) your first name is the spanish name "juan"
08:03:37 <augur> and you have a "chinese name" because you've learned some chinese or whatever
08:04:07 <augur> or b) your first name is an english variant of the spanish "juan" or something of that sort, pronounced joo-uhn or whatever
08:04:14 <augur> or c) you're chinese and your name is just juan
08:04:35 <JuanDaugherty> hey mang it ain't haskell, it's super simple shit
08:04:43 <augur> JuanDaugherty: yes but which is it!
08:05:08 <JuanDaugherty> on my birth certificate, my first name is given as "Juan"
08:05:41 <augur> JuanDaugherty: yes, i get that much
08:05:46 <augur> but im asking WHICH juan!
08:05:58 <dgpratt> augur, intentional pun?
08:06:26 <augur> dgpratt: no :P
08:06:30 <dgpratt> :)
08:06:45 <augur> JuanDaugherty: because if its the spanish juan, then "juan" is a very strange chinese name to have
08:06:48 <JuanDaugherty> if you're asking about my ethnicity, I'm the same as the current POTUS, except my father was an American. I have no known Hispanic ancestry.
08:07:08 <augur> given that spanish juan can be captured perfectly well in mandarin as huan
08:07:20 <augur> because mandarin h is spanish j
08:07:32 <augur> more or less
08:07:41 <ion> So you were born in Kenya?
08:08:01 <mauke> #haskell-blah?
08:08:09 <JuanDaugherty> well chicago, same diff I guess. i grew up in Hyde Park too
08:08:26 <augur> JuanDaugherty: do you pronounce your name, in english, as hwahn or joouhn :|
08:08:42 <mauke> "joan"
08:08:42 <dgpratt> I must've accidentally stumbled into #whyisjuannamedjuan
08:08:57 <augur> dgpratt: w.. we're not in that channel?
08:08:58 <augur> D:
08:09:04 <dgpratt> :)
08:09:50 <JuanDaugherty> I aspirate the J but often negligbly so that "wan" is effectively heard. Got "gwan" the other day, hate that.
08:10:23 <augur> JuanDaugherty: forget describing it like that
08:10:27 <augur> just whichof the two
08:10:31 <augur> hwahn or joouhn
08:10:52 <JuanDaugherty> http://ai-integration.biz/eg/index.php/Catalog_of_Internet_Identities
08:11:21 <augur> (technically, if its the chinese name, it's unaspirated and simply voiceless, as its q which is the aspirated counterpart of j, but thats a whole separate issue)
08:11:42 <elliott> mauke++ (re -blah)
08:12:12 <JuanDaugherty> as you like it, I don't insist on a pronunciation, except for dislike "gwan" or "qwan" or the like
08:12:48 <augur> JuanDaugherty: you're obnoxiously stubborn :)
08:12:58 <Hafydd> I'm not sure you know what "gender disphoric" means.
08:13:22 <augur> Hafydd: thats out of left field
08:13:32 <JuanDaugherty> yes I'm aware most chinese speakers take "juan" as a feminine name
08:13:52 <JuanDaugherty> there are also strict rules for name formation which I completely ignore
08:21:30 <quicksilver> juan name is as good as another to me
08:23:52 * JuanDaugherty :)
08:48:42 <JuanDaugherty> btw git master of leksah does according to the developer build in 7.6
08:49:08 <JuanDaugherty> but not with standard stuffs yet
08:52:55 <osfameron> "the git master of leksah!" sounds like a really bad 70s pulp sci fi novel...
08:53:01 <ab9rf> ha
08:55:33 <JuanDaugherty> s/git/github/
09:04:21 <ryant5000> is there any way to make GHC report specific warnings as errors?
09:05:03 <ryant5000> specifically, warn-missing-fields
09:05:37 <quchen> ryant5000: Well, there's -Werror, which makes all warnings errors, but you can't specify which ones
09:06:15 <kingugo> hey quench; you know who CADD is?
09:06:30 <mauke> kingugo: why are you in this channel?
09:06:30 <ryant5000> quchen: yeah :-/
09:06:48 <quchen> But if you're aiming for warning-free code, there isn't much of a difference between warnings and errors, is there? Compile, fix, recurse
09:06:50 <kingugo> am a haskellian mauke
09:06:58 <conal> ryant5000: sounds like a worthwhile feature request.
09:07:01 <mauke> kingugo: you never say anything haskell related
09:07:15 <conal> ryant5000: of course, it'd take some clarifying to get a concrete proposal.
09:07:29 <mauke> if gcc supports it, copy the interface
09:07:32 <byorgey> #haskell-blah is the place for Haskellians to say non-Haskell-related things.  #haskell is the channel for Haskellians to talk about Haskell.
09:07:53 <ryant5000> conal: yeah; i'll see if i can get some time to put that together
09:08:01 <Ke> gcc has -Werror=
09:08:19 <Ke> after which you can specify which warnings are errorr
09:12:09 <Peaker> quchen, you can easily ignore warnings by accident if you had a long build with a bunch of modules with warnings or such
09:12:14 <Peaker> I use -Werror
09:12:55 <mauke> workaround: write a ghc wrapper that parses/translates warnings
09:13:22 <ryant5000> mauke: yeah, my current plan involves a lot of grepping
09:14:32 <Peaker> ryant5000, why not -Werror?
09:14:41 <ryant5000> Peaker: too many existing errors in this particular build
09:14:52 <ryant5000> *existing warnings
09:15:40 <Peaker> ryant5000, fix them :)
09:15:59 <prophile> @ty lift
09:16:00 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
09:16:03 <Peaker> if you configure your favorite editor to jump to warnings/errors directly, it streamlines it and can't take too long
09:16:36 <ryant5000> Peaker: lol
09:17:02 <prophile> @ty t (m a) -> m a
09:17:03 <lambdabot> parse error on input `->'
09:17:07 <prophile> @hoogle t (m a) -> m a
09:17:07 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
09:17:08 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
09:17:08 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
09:17:26 <luite> Peaker: i have that for emacs, but ghc-mod doesn't work with everything :(
09:17:38 <Peaker> luite, why do you need ghc-mod to fix warnings?
09:18:01 <luite> Peaker: it reports the warnings to emacs in my config
09:18:40 <Peaker> I just use emacs compilation mode to build and it parses the line numbers
09:18:53 <luite> it runs cabal?
09:19:20 <luite> does it work with vado?
09:20:04 <Peaker> You tell emacs the command to run, and it runs it and parses the line numbers
09:20:20 <Peaker> you can run "cabal build", "make", "grep ..", ..
09:20:37 <luite> hmm, i guess that might work then
09:20:37 <Peaker> I don't know what vado is
09:21:21 <luite> Peaker: oh it runs commands remotely over ssh
09:21:29 <Peaker> in tramp mode, it does
09:21:32 <luite> i use it for dev on virtual machines
09:21:45 <Peaker> going back to manually jumping to line numbers is impossible after you have that.. also, it jumps to exact column -- so I can easily record a macro that fixes some type error in a standard way all over the project
09:21:55 <Peaker> oh, you meant vado runs commands over ssh
09:22:00 <luite> yeah
09:22:10 <Peaker> luite, emacs has "tramp" which can work over ssh (edit files, run commands as though they were local)
09:22:11 <luite> tramp can perhaps do everything as well
09:22:25 <Peaker> it isn't perfect, though, some emacs modules assume locality and break with tramp
09:22:42 <luite> hmm
09:23:27 <luite> vado works outside emacs as well, something like vado cabal install builds/installs on the remote machine (or local vm)
09:23:45 <luite> but perhaps tramp is better for most tasks
09:24:20 <quchen> Peaker: True, but I meant that in the context of -Wall
09:24:34 <Peaker> luite, you rsync it too, right?
09:24:54 <luite> Peaker: hm, i don't use rsync, just sshfs
09:25:04 <quchen> Peaker: It sounded like he wanted to promote specific warnings to errors, which I found odd
09:25:30 <Peaker> luite, isn't it horribly slow?  I think you might find tramp to be much more responsive than sshfs, or just rsync
09:25:40 <quchen> In retrospect I think there may be some instances where that's a workaround though.
09:25:53 <luite> Peaker: it was horribly slow until i found the nodelay flag for the mounts
09:26:19 <luite> still slower than other options probably
09:34:49 <kingugo> Pls anyone know who was CADD yesterday in this channel? he was helping me out on haskell
09:35:21 <monochrom> wait for him/her to re-appear. I don't think anyone here is interested in stalking.
09:53:11 <resnik_> @hoogle m a -> a
09:53:12 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
09:53:12 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
09:53:12 <lambdabot> Data.Monoid getDual :: Dual a -> a
10:01:15 <prophile> @undo do {rec {source <- f (fmap (const (flip const)) source)}; source}
10:01:15 <lambdabot> <unknown>.hs: 1: 17:NamedFieldPuns is not enabled
10:01:25 <prophile> :<
10:02:06 <prophile> what's the desugaring on do rec?
10:02:59 <monochrom> mfix (see Control.Monad.Fix)
10:16:08 <prophile> is there a Yoneda-like type for forall b. f (a -> b) -> f b rather than forall b. (a -> b) -> f b?
10:16:26 <prophile> I guess it'd be the Applicative equivalent of Yoneda for Functors or Codensity for Monads
10:35:24 <evancz> I am curious how GHC resolves dependencies within a let-expression
10:35:53 <evancz> does it do a topological sort that is aware that the dependencies may be cyclic?
10:36:09 <evancz> does this question even make sense?
10:36:44 <merijn> evancz: I don't think it makes sense, no
10:36:53 <merijn> evancz: Why would the ordering be problematic?
10:37:18 <evancz> one second, i'll try to create an example
10:37:46 <merijn> > let a = 0:b; b = 1:a in a -- this?
10:37:47 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
10:37:59 <Saizan> it has to compute the strongly connected components for type checking
10:38:31 <geekosaur> :t let a = a in a -- oops!
10:38:31 <lambdabot> t
10:38:33 <evancz> so GHC does do a traversal? Does it come out with something more like OCaml syntax?
10:38:49 <evancz> where it is explicit in saying "let rec" and "and" to express mutual recursion
10:39:02 <geekosaur> (that being the easiest way to write `undefined` *in* haskell)
10:39:09 <merijn> evancz: GHC let bindings are (implicitly) recursive
10:39:19 <feep> hi, I'm making a C-like programming language and I have a question regarding debruijn indexes, not sure if this is appropriate or if #lisp is a better place to ask (assuming there isn't a #lambdacalculus)
10:39:33 <evancz> I am know how it works at the source level
10:39:34 <merijn> evancz: The explicit let rec is more of a programmer help tool than a compiler help tool
10:39:47 <Saizan> evancz: no, it might just split it into more than one let, but i'm not sure
10:40:39 <feep> #lisp is probably better, I'll go poke them
10:40:44 <feep> scuse the interruption
10:40:49 <evancz> hold on, I will rephrase with code :)
10:41:09 <evancz> hmm, is hpaste down?
10:41:23 <kryft> evancz: See topic
10:41:36 <kryft> http://lpaste.net/new/haskell
10:42:42 <evancz> kryft: thanks :)
10:46:15 <evancz> http://lpaste.net/90852
10:46:48 <evancz> it appears that GHC must do a more complicated desugaring than to a "let rec", "and", "and" block
10:47:02 <evancz> I am curious about the details of this desugaring
10:47:31 <evancz> does this clarify my question?
10:48:09 <Saizan> evancz: yeah, GHC sees that f doesn't depend on p, so it generalizes f's type before typechecking the body of p
10:48:51 <evancz> okay, so it desugars to "let f x = x in let p = (f 1, f 'a') in ..."
10:49:03 <evancz> and therefore needs to do a clever topological sort
10:49:09 <evancz> that detects mutual recursion
10:49:15 <evancz> and puts them in a "let rec" block
10:49:33 <evancz> Does this make sense?
10:49:43 <Saizan> yeah, computing "strongly connected components" as i said above, there are a few simple algorithms to do that
10:49:57 <evancz> cool, thank you!
10:50:01 <evancz> I'll look into this more
10:50:11 <Saizan> evancz: that's a good way to think about it, the details of how GHC does it might differ
10:50:56 <shachaf> Haskell also supports polymorphic recursion, unlike ocaml, I think?
10:51:15 <Saizan> yep, but you need a type signature for that
10:51:26 <shachaf> Although that's not happening here. But it's maybe somewhat related.
10:51:28 <shachaf> Right.
10:51:52 <evancz> yeah, strongly connected components was exactly what I was looking for!
10:52:01 <evancz> glad I did not reinvent this :)
10:52:21 <evancz> with polymorphic recursion, ocaml cannot do it even with a type signature?
10:52:36 <roboguy_> evancz: isn't f just id?
10:52:40 <evancz> yes
10:52:54 <Saizan> evancz: no idea about ocaml there :)
10:53:10 <evancz> haha, okay
10:53:55 <evancz> hmm, I am trying to think of a function that uses polymorphic recursion..
10:54:00 <evancz> do you know of any off hand?
10:54:02 <shachaf> evancz: Hmm, it looks like it's now supported as a language extension.
10:54:28 <shachaf> evancz: The classic example is a something that deals with a data type like data Tree a = Leaf a | Branch (Tree (a,a))
10:54:39 <evancz> ahhh
10:54:53 <evancz> okay, from the purely functional data structures book :)
10:55:11 <Saizan> you could also just try that let rec code with a signature for f :)
10:55:27 <evancz> i'll try, be right back :)
10:58:08 <evancz> nope, ocaml does not like that either
10:58:49 <evancz> For context, I am in the middle of rewriting the type inferencer for Elm
10:59:42 <evancz> on polymorphic recursion, do we expect that the type gets generalized from the type annotation
10:59:51 <evancz> and then checked against the definition?
11:00:12 <evancz> hmm, that was phrased poorly
11:01:34 <evancz> in any case, i'll cross the polymorphic recursion bridge when it comes :)
11:01:39 <evancz> thanks for your help guys!
11:02:11 <Saizan> for polymorphic recursion you use the annotated type when checking applications of the function in the body, but you also have to check that it matches with the type of the function at the end
11:02:26 <Philonous> Is there an efficient way to implement a takeWhile Get action in cereal?
11:03:02 <Saizan> there are better ways to propagate type information from annotations downward, but that's what you'd do starting from HM
11:03:43 <feep> okay #lisp have declared that only common lisp questions are welcome :D
11:04:39 <feep> reasking here then. I'm making a scripting language ,and I translate my source tree (lisplike) into a form where all tokens are resolved, so I don't have to do oodles of lookup for every evaluation
11:05:03 <Saizan> Philonous: maybe with getBytes at the end?
11:05:16 <feep> so for every lambda I end up with a form where parameters have been replaced with "slot" expressions indicating "how many stackframes up, which index in the stackframe"
11:05:49 <Philonous> Saizan:  You mean checking how many bytes satisfy the condition with lookahead and then pulling them out with getBytes?
11:05:51 <feep> for instance, λ x λ y ( x + y) would become λ 1 λ 1 ([0:0] + [1:0])
11:06:03 <feep> (1 == "1 parameter")
11:06:04 <Saizan> Philonous: yeah
11:06:28 <feep> now, I thought that my slot expressions are _basically_ debruijn indexes, for the special case where each lambda has exactly one parameter
11:06:40 <feep> but my friend insists that this is a total misuse of terminology
11:06:52 <feep> and that I should stop mangling formal terms
11:06:58 <monochrom> yes, I think so too. either that, or reversed de Bruijn.
11:07:04 <feep> well they're inside out
11:07:10 <monochrom> I mean I think what you think
11:07:29 <josephle> but your indices are backwards from de Bruijn, as monochrom mentioned
11:07:37 <Saizan> indexes go from λ x λ y ( x + y) to λ λ (1 + 0)
11:07:41 <feep> ... oops
11:07:46 <feep> yeah I wrote it the wrong way around
11:07:52 <Saizan> levels go from λ x λ y ( x + y) to λ λ (0 + 1)
11:07:54 <feep> for instance, λ x λ y (y + x) would become λ 1 λ 1 ([0:0] + [1:0])
11:07:56 <monochrom> "basically" saves the day
11:08:40 <Philonous> Saizan:  Thanks, I had that same thought but dismissed it for some reason.
11:08:46 <Cale> feep: don't lambdas always have exactly one parameter? ;)
11:08:49 <feep> thanks, I'll poke him about it :D
11:09:20 <feep> Cale: well, you can always reduce it to multiple lambdas, I implemented them with multiple parameters though
11:09:22 <monochrom> computing is all about mangling formal terms
11:09:27 <feep> just think of it as one parameter that can be a tuple :D
11:20:42 <Hugh_> hello -
11:20:47 <burz> hello
11:20:53 <Hugh_> map :: (a -> b) -> [a] -> [b]
11:21:26 <Hugh_> in a type sig like this does the (a -> b) signify that it is a function?
11:21:36 <elliott> (a -> b) is a function from a to b, yes
11:21:48 <elliott> (right associative)
11:22:05 <Philonous> Saizan:  That worked, but now I'm feeling dirty ;)
11:22:29 <Cale> So map takes two parameters, (a function which takes parameters of type a and produces results of type b) and (a list of values of type a), and it produces a list of values of type b
11:22:29 <Hugh_> so I should read that as "map is a function which converts a list of a to a list of b
11:22:45 <elliott> Hugh_: given a function to turn an a into a b.
11:23:05 <Hugh_> ah... I guess I am just confused about how to read these signatures
11:23:07 <byorgey> Hugh_: you should read it as "map is a function which takes a function from a to b, and a list of a, and converts it to a list of b
11:23:15 <Philonous> Hugh_:  The ( a -> b) means it takes a function from a to b as an argument
11:23:16 <Cale> Or: map is a function which takes one parameter which is (a function which takes parameters of type a and produces results of type b) and produces (a function which takes a list of values of type a and produces a list of values of type b)
11:23:26 <Gracenotes> :t liftM3
11:23:27 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
11:23:29 <FreeFull> You could also read it as   map :: (a -> b) -> ([a] -> [b])
11:23:34 <Hugh_> great, thanks a lot!
11:23:36 <FreeFull> Which is equivalent to the first type signature
11:23:40 <Gracenotes> Hugh_: This function is confusing, but it takes 4 arguments
11:23:44 <Cale> -> associates to the right, so the type signature is the sams as what FreeFull wrote
11:23:45 <Gracenotes> liftM3, that is
11:24:08 <shachaf> Why did the liftMn signatures get alpha-renamed like that?
11:24:14 <FreeFull> So map is a function that takes a function from a to b, and lifts it to lists
11:24:15 <Cale> But any function which produces another function as its result is the same thing as a function with an additional parameter
11:24:19 <shachaf> a1 a2 a3 is terrible. It should be a b c.
11:24:29 <Gracenotes> shachaf: yes, it makes rather confusing auto-renames
11:24:34 <shachaf> :t liftM5 -- awful
11:24:35 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
11:25:05 <Cale> Wait until you get to liftM27
11:25:06 <Cale> ;)
11:25:24 <Hugh_> thanks - I think I am starting to understand monads too.
11:25:40 <Gracenotes> shachaf: oh, this is even worse!
11:25:42 <Gracenotes> :t liftM
11:25:43 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:25:45 <burz> :t lift M27
11:25:47 <lambdabot> Not in scope: data constructor `M27'
11:25:56 <burz> :t liftM27
11:25:58 <lambdabot>     Not in scope: `liftM27'
11:25:58 <lambdabot>     Perhaps you meant one of these:
11:25:58 <lambdabot>       `liftM2' (imported from Control.Monad.Writer),
11:26:00 <Gracenotes> :t liftA3
11:26:01 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
11:26:11 <Gracenotes> ahm. in any case.
11:28:17 <merijn> btw, am I the only one that wishes there was a monadic version of <*> that lets you lift things like "Monad m => (a -> b -> c -> d -> m e) -> m a -> m b -> m c -> m d -> m e"?
11:28:41 <Hugh_> Can functions only ever return one output?
11:29:07 <merijn> Hugh_: Yes, no and maybe, depending on what you mean by functions, return, one and output
11:29:09 <byorgey> Hugh_: Fundamentally, yes.  However, note that one output could be a tuple
11:29:30 <byorgey> or a data structure containing multiple pieces of information
11:29:33 <merijn> :t unzip -- for example
11:29:34 <lambdabot> [(a, b)] -> ([a], [b])
11:29:47 <Hugh_> sure, so you could mash up two 'return values' as a tuple but it is still only one variable returned of Type Tuple
11:29:54 <byorgey> Hugh_: right.
11:30:14 <byorgey> Hugh_: but the distinction is not that important, especially since you can bind the results of a function using pattern matching.
11:30:26 <byorgey> for example you can say  let (xs, ys) = unzip foo
11:30:45 <byorgey> unzip only "returns one output" but you can immediately take it apart.
11:31:40 <finishingmove> Is there some function that can take [1,2,3,4,5,6,7,8] and give [[1,2],[3,4],[5,6],[7,8]] ?
11:32:01 <Hugh_> so really all you are doing in a monad is to bind the next function in the chain to use a specific output value of the first and provide an identity function to strip it out again
11:32:05 <byorgey> yes, Data.List.Split.chunksOf from the 'split' package
11:32:11 <finishingmove> thanks
11:32:15 <byorgey> > chunksOf 2 [1,2,3,4,5,6,7,8]
11:32:17 <lambdabot>   [[1,2],[3,4],[5,6],[7,8]]
11:32:53 <byorgey> Hugh_: "provide an identity function to strip it out again" -- I'm not sure I understand what you mean by that, but it doesn't sound right
11:33:28 <augur> hmm
11:33:49 <augur> chunksOf n xs = take n xs ++ chunksOf n (drop n xs)
11:34:29 <byorgey> you need : instead of ++
11:34:39 <augur> byorgey: derp.
11:34:42 <FreeFull> :t unzip
11:34:42 <augur> that too
11:34:43 <lambdabot> [(a, b)] -> ([a], [b])
11:34:43 <NeatBasis> What does this mean and what do I have to do?  add (PersistUnique m) to the context of the type signature for  balance :: PersistStore m => String -> m Integer
11:34:46 <ski> @type splitAt
11:34:46 <lambdabot> Int -> [a] -> ([a], [a])
11:35:18 <byorgey> NeatBasis: that is suggesting to use the type signature  balance :: (PersistStore m, PersistUnique m) => String -> m Integer
11:35:28 <byorgey> I have no idea whether that is the right thing to do.
11:35:51 <Hugh_> ok, so as I understand it I have two 'boxes' representing my functions. The first takes an Int and does something to it to produce another Int. It returns this as a tuple (x, log) with a message. Then the second function only takes an Int as input but also needs to append a message. So we communicate the 'x' as the input value by binding to it... then I get stuck
11:35:54 <ski> merijn : istr i've called it `extendM4'
11:36:12 <NeatBasis> ok, I'll try
11:36:19 <byorgey> Hugh_: are you trying to figure out how the Writer monad works?
11:36:25 <Hugh_> yup
11:37:00 <Hugh_> well, actually I am trying to write my own
11:37:08 <byorgey> ah, good idea =)
11:37:17 <shachaf> Well, if you mean Writer, say Writer. :-) Most monads are not very much like Writer.
11:37:23 <byorgey> so you are trying to implement (>>=) ?
11:37:57 <Hugh_> why do we even need a special operator? just pattern match it?
11:38:19 * hackagebot hastache-aeson 0.1.0.0 - render hastache templates using aeson values  http://hackage.haskell.org/package/hastache-aeson-0.1.0.0 (VladimirKirillov)
11:40:29 <zvrba> "Applicative functors [..] allow you to operate on several functors with a single function" [from LYAH] <-- I strongly dislike this casual abuse of terminology
11:40:44 <roboguy_> Hugh_: you're asking why we need the "operator" (>>=)?
11:40:51 <zvrba> functor [the type class] != functor [a value belonging to the typeclass]
11:41:17 <zvrba> no wonder Haskell has a reputation of being hard to learn.
11:41:33 <Hugh_> yes... if all a monad is is making sure the correct output value is inserted into the second function then why not just pattern match?
11:42:05 <elliott> zvrba: well, no values belong to the typeclass Functor; typeclasses classify type [constructors], not values. but "functor" for "a value of type (f a) for some a, where f is a Functor" is a bad misnomer
11:42:12 <elliott> if you see someone using it you should correct them :p
11:42:17 <roboguy_> Hugh_: I'm not sure I understand the question... you can have pattern matching definitions for >>=
11:42:23 <elliott> oh, just saw your LYAH quote
11:42:47 <edwardk> > (1,2)^._2
11:42:48 <lambdabot>   Not in scope: `_2'
11:42:51 <Hugh_> so the whole point of monads is to link functions together?
11:42:55 * edwardk looks at elliott 
11:43:21 <elliott> edwardk: I'll put the Control.Lens.* that can be imported with the versions it has in Pristine.hs for now
11:43:26 <elliott> that can be done without rebuilding anything
11:43:31 <roboguy_> Hugh_: pretty much the whole point of Haskell overall is linking functions together
11:43:32 <elliott> some things like each are inaccessible though iirc :(
11:43:42 <byorgey> Hugh_: no, the point of monads is that they abstract certain patterns which show up repeatedly.
11:43:51 <roboguy_> Hugh_: also I'm not sure how that relates to the question about >>= being an "operator"...
11:43:52 <edwardk> elliott: what is broken? i want to fix it
11:43:54 <Hugh_> then if there is only one value output then no need for a monad. If there are two in the form of a tuple then just use pattern matching
11:44:00 <zvrba> elliott: well, it's in LYAH
11:44:12 <tac> zvrba: Functors are like a kind of container, right?
11:44:12 <edwardk> is it just i need to go spam more trustworthy annots? i'm happy to do so
11:44:14 <tac> :P
11:44:19 <byorgey> Hugh_: monads have not much to do with the number of outputs.
11:44:19 <zvrba> elliott: the sentence I just quoted.
11:44:20 <Hugh_> well why invent a new operator when regular pattern matching will suffice
11:44:24 <zvrba> tac: right :P
11:44:25 <edwardk> just tell me where or better yet send me patches =P
11:44:28 <roboguy_> Hugh_: what about something like the list monad?
11:44:53 <elliott> edwardk: nothing is broken with the latest lens, afaik -- I haven't tried it
11:45:06 <roboguy_> Hugh_: it's not really a "new operator". In Haskell operators are just regular functions and you can define new ones yourself
11:45:10 <elliott> edwardk: the problem is more, to upgrade it I need to do a multi-hour rebuild of everything to get the fixed dependencies etc
11:45:30 <elliott> edwardk: and this is kind of a pain and I was hoping I could consolidate it into one rebuild that would also fix the issue where mueval times out all the time
11:45:32 <edwardk> elliott: i'll happily… cheer you on ;)
11:46:03 <FreeFull> @let import Control.Lens.Tuple
11:46:05 <lambdabot>  Defined.
11:46:06 <Hugh_> So what is the point of a bloomin monad then !! I have trawled the 'net for a good explanation to no avail. They can't be magical!
11:46:13 <FreeFull> > (1,2) ^. _"
11:46:14 <lambdabot>   <hint>:1:12:
11:46:14 <lambdabot>      lexical error in string/character literal at end of input
11:46:15 <FreeFull> > (1,2) ^. _2
11:46:16 <lambdabot>   2
11:46:26 <elliott> Hugh_: it'll be a lot easier to understand monads if you have a more solid understanding of the rest of Haskell first.
11:46:40 <elliott> edwardk: hm, maybe just upgrading lens would be enough to import lens now that you sprinkled gross trustworthys everywhere
11:46:45 <FreeFull> Hugh_: It also helps to looks at what some monads do, to see what they're capable of
11:46:47 <elliott> edwardk: and I can chase the dependencies to get void etc. another time
11:46:50 <elliott> will try
11:47:08 <edwardk> if you want to make the trustworthy's more gentle and accurate feel free
11:47:14 <Hugh_> yeah, people tell me that. I have a good understanding of the basics already. I get functional programming. I really do.
11:47:34 <FreeFull> Hugh_: Do you undestand Haskell's type system well? Including typeclasses?
11:47:34 <roboguy_> Hugh_: the list monad would probably be good to look at
11:47:42 <zvrba> is there a (more) decent introductory book on Haskell that's more precise than LYAH?
11:47:51 <Hugh_> I just don't get how no one appears capable of explain the purpose of monads - not what they are, or how they work but the **purpose**
11:48:06 <Hugh_> yup
11:48:14 <roboguy_> Hugh_: when you use them right, they make code easier to write and easier to read
11:48:17 <elliott> edwardk: oh the trustworthys aren't on hackage
11:48:17 <zvrba> Hugh_: what is the purpose of any abstraction?
11:48:18 <Hugh_> typeclasses are no problem
11:48:26 <elliott> edwardk: is 3.10 blocked on more stuff?
11:48:34 <Philonous> Hugh_:  The whole point of "Monads" is that they have two functions, (>>=) and return and those two functions behave in a certain, predictable way (according to three "laws"). What you do with that is up to you. It is used to construct certain kinds of abstract computations, but that's not the only use.
11:48:47 <FreeFull> > do { a <- [1,2,3]; b <- ['a'..'z']; return (a,b) }
11:48:48 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(1,'e'),(1,'f'),(1,'g'),(1,'h'),(1,'i'),(1...
11:48:55 <FreeFull> > do { a <- [1,2,3]; b <- ['a'..'c']; return (a,b) }
11:48:56 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
11:48:56 <edwardk> Hugh_: monads are an abstraction we stole from category theory. they aren't like anything you've used before so its very hard to reason by analogy to other things. the benefit of them is that they are ubiquitous. a ton of stuff happens to _be_ a monad. that means that anything you can write once and for all that works across all monads will work with lots and lots of things
11:48:58 <elliott> Hugh_: if you're deeply concerned about finding a deep underlying purpose that has no relation to what they are or how they work or how you can use them, then you will never find it
11:49:02 <monochrom> purpose is personal and subjective. if you see no purpose, that's normal, and independent to that I see some purpose.
11:49:10 <elliott> or at least, reading about monads won't help you any more than meditation.
11:49:18 <FreeFull> I think edwardk just said it in the best way
11:49:27 <Hugh_> I don't buy that.
11:49:31 <edwardk> moggi turned around and figured out how we could use monads to reason about side-effects in semantics way back in the day and we borrowed them for that, and then we found all sorts of uses for them
11:49:35 <Philonous> Hugh_:  If you understand the type class and the monad laws than that's all there is to it.
11:49:41 <elliott> the focus on "purpose" above the abstract definition or the practicalities of how you use them necessarily means they're always going to look like scary magic you can't understand.
11:50:00 <josephle> Hugh_: but perhaps you don't get typeclasses
11:50:05 <elliott> and you could take that attitude towards anything, it just so happens that the word "monad" has a lot of pre-existing mystique unfortunately propagated so it's especially prone to this kind of thing.
11:50:08 <Hugh_> They might be 'abstract' in mathematics but they are clearly NOT abstract if they are put to use in a programming language to solve a problem
11:50:26 <Hugh_> I do get typeclasses
11:50:27 <monochrom> some people don't even see any purpose to life. how could you bring them to see any purpose in monad. or computing.
11:50:35 <elliott> if you don't think abstract things can solve problems then I agree, you won't see point in the things Haskell does
11:50:53 * tac has been peeved a lot lately by people using "abstract" to mean "I don't know how it works".
11:50:56 <edwardk> so monads are "about" controlling side-effects. they are about "zooming in on part of a container and making a new container out of it and getting a new container" they are "about" being spacesuits, burritos, list, aliens, elephants or whatever the analogy of the day is but they are able to be all of those things because they are just a set of two functions and 3 laws that happens to subsume those things.
11:51:14 <Hugh_> that's not true. A function is an 'abstract' concept but is something which could be explained to anyone
11:51:18 <monochrom> anyway, I didn't hear you ask for purposes of typeclasses, of types, of haskell... why?
11:51:28 <FreeFull> You can write something like sequence_ once and use it with anything that happens to be a monad
11:51:38 <elliott> Hugh_: yes, just like monads. as long as they're not pre-convinced that however you explain it to them, they won't see the point
11:51:43 <zvrba> Hugh_: i would disagree. I taught a course on programming in C to absolute beginners.
11:52:05 <zvrba> Hugh_: some of them could write everything in main(), but explaining the purpose of functions was.. next to impossible.
11:52:25 <edwardk> one of the best ways i know to learn about how to work with monads is to start with the laws and the methods and then see how a bunch of seemingly disparate examples fit that mold.
11:52:43 <edwardk> then take a look at what other people have written that works with every one of those examples and what those combinators mean in those contexts
11:52:48 <monochrom> "could be explained to" is subjective to the listener. I cannot explain functions to a 1-year old. I really can't.
11:53:03 <monochrom> and some 80-year-olds too
11:53:08 <edwardk> by the time you're done, you'll have a pretty good idea of what a monad is "about", but its not going to be a short discussion.
11:53:11 <jroesch_> yeah things like the Typeclassopedia are good for that, they go over a bunch of examples of how different data types fulfill common type classes
11:53:14 <Hugh_> ok, so can you at least tell me this: are monads 'built in' to Haskell or are they just a way to organise your code
11:53:14 <zvrba> anyway, back to my question. is there a more formal/precise introductory text on Haskell than LYAH?
11:53:19 * hackagebot typeable-th 0.1.1 - Automatic deriving of TypeableN instances with Template Haskell  http://hackage.haskell.org/package/typeable-th-0.1.1 (BennoFuenfstueck)
11:53:29 <elliott> the latter, if anything.
11:53:34 <zvrba> i'm tired of mentally rewriting its overloading of terms.
11:53:53 <edwardk> People write so many damn monad tutorials because it isn't until their third or fourth explanation that they finally "get it" because they've finally seen enough points of view to have some idea of the space being delineated. Then they rush out and try to write a tutorial to tell everyone what they just learned.
11:53:59 <josephle> Hugh_: ideally they're the latter, but they're somewhat elevated due to do-notation
11:54:00 <elliott> the Report has one (or two? is ST part of the report? I forget) type specified as "this abstract type exist and has these primitive operations, including a Monad instance"
11:54:04 <elliott> but that's as "primitive" as it gets.
11:54:10 <monochrom> a bit of both. it gets do-notation syntax support. it's also normal library code.
11:54:19 <jroesch_> there is some syntactic support, but elliot has it right, they are mostly just a "design pattern" of sorts
11:54:21 <elliott> there is syntactic sugar but beyond that they are just an ordianry typeclass taht you could define yourself.
11:54:34 <FreeFull> State, Reader, Writer, List, STM, IO, Maybe, Either a   are all useful monads
11:54:43 <elliott> and the sugar is simple to describe:
11:54:44 <elliott> @where do
11:54:44 <lambdabot> The rules of do notation: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14 (Note that "do { v <- m; ... }" is the same as "m >>= \v -> do { ... }" when v is a variable,
11:54:44 <lambdabot> rather than a more complex pattern.)
11:54:54 <FreeFull> And all code written for a nonspecific monad will work with them
11:54:59 <edwardk> Hugh_: Monad is a typeclass like any other. We use Applicative, Functor and other weaker structures almost as often for much the same purpose. Now, Monad has the privilege of having a little bit of syntactic sugar built into the language for it. 'do' sugar is magic built-in stuff, but the monads themselves are just code.
11:55:29 <Hugh_> ok, that makes sense to how I see them. So really I need to concentrate more on the bind and return functions rather than get confused thinking about a specific language construct called monad
11:55:29 <edwardk> you can read the code and write new monads, make up new classes of effects or containers, or syntax trees or what have you once you understand how a monad works
11:55:40 <FreeFull> Most of the magic resides in a monad's definition of   >>=   and the rest is in   return
11:55:40 * tac isn't convinced monads are the right abstraction for doing most run-of-the-mill programming.
11:56:17 <merijn> Hugh_: Personally I think even that might be a step to far, I recommend focussing on types and typeclasses, then work your way up to Functor and from that point on Applicative and Monad should be obvious
11:56:38 <Shou> In GHCi, is there a way to make it not display all my loaded modules when I set +m for multi-line?
11:56:40 <kryft> edwardk: And even 'do' is pretty straightforward to desugar, right? So not terribly 'magic' either
11:56:42 <edwardk> most people start using monads because they need to interact with the world. then they gradually get more comfortable dipping into the purely functional parts of the language for longer and longer periods of time, get a more nuanced understanding of how you can work with monads, make their own, use the mtl, etc.
11:56:49 <edwardk> kryft: exactly
11:56:52 <roboguy_> Hugh_: it's not really a specific language construct, Haskell just happens to have some extra shorthand for working with them (which you don't even, technically, need but it can make things look a little better sometimes)
11:57:04 <edwardk> @undo do x <- blah; y <- quux; return (f x y)
11:57:04 <lambdabot> blah >>= \ x -> quux >>= \ y -> return (f x y)
11:57:40 <edwardk> the compiler just does that translation for you so you don't have to clutter your code with (>>=)'s and can read it in a sort of imperative fashion
11:57:58 <jroesch_> Hugh_: there is the Typelcassopedia as a good resource for learning about type classes when you get there: http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
11:59:01 <FreeFull> jroesch_: Wait, why are you linking to a pdf?
11:59:54 <Hugh_> ok, thanks fellas. my two pennies worth of advice for anyone trying to explain these concepts is to make it painfully clear from the beginning that they are not a language feature because otherwise the person trying to learn gets tied in knots trying to find a solid definition outside of mathematics
11:59:59 <edwardk> Personally I spend a lot of time playing with abstractions in Haskell, because Haskell is a very fun place to reason about abstractions
12:00:26 <jroesch_> I was pointing him to it?
12:00:39 <Hugh_> thanks jroesch
12:00:48 <FreeFull> Hugh_: Also, keep in note that all Monads are Applicatives and Functors too
12:01:30 <edwardk> i would like to second the recommendation to scan through the Typeclassopaedia. It does a pretty good job of dispelling the illusion that Monad is somehow a privileged thing.
12:01:48 <FreeFull> Well, do notation is a priviledge
12:01:49 <Hugh_> out of interest, how many competent Haskell programmers (not the creators, the bods using it to programme) have advanced maths degrees?
12:01:51 <FreeFull> And it's in Prelude
12:01:56 <FreeFull> But that's about it
12:02:10 <monochrom> that statistic is not know
12:02:14 <monochrom> s/know/known/
12:02:20 <FreeFull> I don't have an advanced maths degree
12:02:24 <elliott> I doubt many people on the committee have "advanced maths degrees", depending on your definition.
12:02:26 <FreeFull> And find Haskell perfectly understandable
12:02:36 <elliott> (the haskell committee)
12:02:39 <FreeFull> And it's my primary programming language
12:02:41 <merijn> Hugh_: many of the more theoretical abstract haskell hackers seem to not have any degree related to math at all :)
12:03:04 <Hugh_> well then there's hope!
12:03:07 <edwardk> Hugh_: there are a lot of mathy people in the haskell community, but the main guy who implements Haskell and who has been involved since the language was initially designed never even did his PhD.
12:03:42 <jroesch_> I have a feeling that there are more PLT academics hanging around the language them Mathematicians
12:03:51 <jroesch_> then  Mathematicians*
12:03:56 <elliott> someone needs to get spj an honorary phd.
12:04:14 <jfischoff> Hugh_: I where I we use Haskell, no one there has advance degrees of any kind.
12:04:17 <jroesch_> he has written enough publications to deserve a few
12:04:21 <feep> than mathematicians
12:04:31 <Hugh_> ok, final question and then I'll leave you all in peace: would it be possible, other than the IO monad, to write big programmes without ever using a monad
12:04:52 <edwardk> Hugh_: yes.
12:05:02 <edwardk> i write lots of libraries in which i never even use a monad.
12:05:04 <elliott> if you wanted to.
12:05:08 <tac> Hugh_: Yeah. Technically, it doesn't even matter that IO is a monad
12:05:17 <FreeFull> I'm not an academic
12:05:23 <FreeFull> I haven't been to university yet
12:05:53 <hxn1248> Does anyone here use the haskellmode plugin with MacVim?
12:05:54 <haasn> monad is just an abstraction. You can implement and use the same functions without ever touching the abstraction
12:06:08 <ab9rf> you don't n
12:06:08 <Philonous> Hugh_:  That's an ambiguous question. If you mean "without using the Monad type class" then yes.
12:06:11 <tac> Hugh_: IO really just says "run this command, and here's the function to call when we get a result back"
12:06:37 <merijn> Hugh_: You could, but I certainly wouldn't want to
12:06:38 <Hugh_> ok, thanks again for all your advice.. I shall keep on striving... I genuinely do get the beauty of the language so it should be worthwhile once I emerge into the broad uplands of enlightenment.. cheerio
12:06:50 <ab9rf> you don't really need to understand what Monads are in order to use them.  in fact, i think you gain little by spending a lot of time trying to bend your brain around the abstraction.
12:07:10 <ab9rf> instead, use them, and let the abstraction grow on you naturally.
12:07:12 <merijn> hxn1248: Probably, although I personally thought it had too much gunk and took too much effort to get working
12:07:18 <roboguy_> Hugh_: here's one last bit of advice: I would highly recommend learning about functors and applicatives before monads, if you haven't already
12:07:30 <Hugh_> ok, will do..
12:07:54 <ab9rf> agree with that.  functors and applicatives are more "obvious" abstractions, i think
12:08:07 <elliott> @undefine
12:08:07 <lambdabot> Undefined.
12:08:10 <elliott> > (1,2) ^. _1
12:08:10 <Saizan> Hugh_: don't be scared by Monad though, the basics facts are simpler than they seem at first
12:08:11 <lambdabot>   L.hs:42:1:
12:08:11 <lambdabot>      Control.Lens: Can't be safely imported!
12:08:11 <lambdabot>      The module its...
12:08:19 <elliott> hm
12:08:21 <elliott> @flush
12:08:23 <elliott> @quit
12:10:10 <hxn1248> Yeah, I see what you're saying. I want to use it gives me some ugly menus. Does anyone here know how to get rid of them. They're too much of a distraction.
12:10:58 <Fuuzetsu> :t fmap (undefined, undefined)
12:11:06 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `(t0, t1)'
12:11:12 <lambdabot>     In the first argument of `fmap', namely `(undefined, undefined)'
12:11:14 <Fuuzetsu> :t fmap undefined (undefined, undefined)
12:11:20 <lambdabot> (t, b)
12:11:51 <haasn> :t fmap `asTypeIn` \fmap -> fmap undefined (undefined, undefined)
12:11:56 <lambdabot>     Not in scope: `asTypeIn'
12:11:59 <haasn> huh
12:12:02 <lambdabot>     Perhaps you meant `asTypeOf' (imported from Prelude)
12:12:24 <ion> @let asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn`
12:12:29 <haasn> :t fmap `asTypeIn` \fmap -> fmap undefined (undefined, undefined)
12:12:32 <lambdabot>  .L.hs:109:10:
12:12:38 <lambdabot>     Not in scope: `asTypeIn'
12:12:44 <lambdabot> Plugin `eval' failed with: <<timeout>>
12:12:48 <Fuuzetsu> :t second
12:12:49 <haasn> ion: the “where” is unnecessary, mind
12:12:54 <lambdabot> Not in scope: `second'
12:13:37 <ion> haasn: There’s some redundancy in there, yes.
12:13:50 <ion> haasn: You could also say the type signature is unnecessary. :-P
12:13:58 <haasn> :t let asTypeIn :: a -> (a -> b) -> b; asTypeIn = const in fmap `asTypeIn` \fmap -> fmap undefined (undefined, undefined)
12:13:59 <lambdabot>     Couldn't match type `a' with `b1'
12:13:59 <lambdabot>       `a' is a rigid type variable bound by
12:13:59 <lambdabot>           the type signature for asTypeIn :: a -> (a -> b1) -> b1
12:14:03 <roboguy_> Fuuzetsu: if you're trying to see how the tuple instance fmaps, you could try something like: :t fmap (undefined :: Int -> Int) (undefined, undefined)
12:14:15 <haasn> err
12:14:18 <haasn> :t let asTypeIn :: a -> (a -> b) -> a; asTypeIn = const in fmap `asTypeIn` \fmap -> fmap undefined (undefined, undefined)
12:14:19 <lambdabot> (a -> b) -> (t, a) -> (t, b)
12:14:20 <haasn> there we go =D
12:14:24 <Fuuzetsu> roboguy_: Nah, I thought about it and there's really only 1 way to define one
12:14:32 <roboguy_> Fuuzetsu: there is?
12:14:46 <roboguy_> :t fmap (undefined :: Int -> Int) (undefined, undefined)
12:14:47 <lambdabot> (t, Int)
12:15:06 <haasn> Fuuzetsu: there's only 1 way to define any Functor instance
12:15:06 <Fuuzetsu> roboguy_: Try defining one
12:15:08 <NeatBasis> How do I return Maybe Double here? balance :: (PersistUnique m) => String -> m Double
12:15:08 <haasn> they're unique
12:15:13 <roboguy_> Fuuzetsu: what about mapping only over the other argument using a newtype?
12:15:15 <tac> roboguy_: Parametricity says there's one total function of that type
12:15:21 <roboguy_> I guess you have to use newtype though
12:15:37 <roboguy_> never mind
12:15:40 <FreeFull> NeatBasis: Is there a PersistUnique instance for Maybe?
12:16:11 <NeatBasis> I don't know
12:16:12 <elliott> there are non-unique Functor instances.
12:16:15 <elliott> you still have to check your instance.
12:16:23 <haasn> elliott: that satisfy the laws?
12:16:33 <elliott> no
12:16:38 <elliott> that's why I said checking :p
12:17:00 <haasn> yeah, saw that afterwards :)
12:17:23 <NeatBasis> FreeFull I don't think so
12:17:55 <haasn> I should have say ‘any legal Functor instance’
12:17:58 <haasn> said*
12:18:14 <roboguy_> but, if you could flip the type constructor, wouldn't there be two ways in this case? I can see how that might be considered a different type, but wouldn't it still apply to tuples? (if that makes sense)
12:18:26 <Fuuzetsu> roboguy_: But you can't
12:20:22 <roboguy_> Fuuzetsu: I thought I remembered an extension that let you do stuff like instance Functor (-> b)   [as opposed to instance Functor ((->) a)]
12:20:24 <roboguy_> maybe not
12:20:59 <haasn> roboguy_: nope, a newtype is necessary
12:21:07 <roboguy_> hmm, okay
12:37:05 <roconnor> really ... no show instance for Data.Functor.Constant?
12:37:44 <shachaf> roconnor: Const and Identity don't have them either. :-(
12:38:23 <elliott> Data.Functor.Constant shouldn't exist
12:38:33 <elliott> it's Control.Applicative.Const but with a longer name and fewer instances.
12:40:09 <roconnor> > Identity 5
12:40:13 <lambdabot>   mueval-core: Time limit exceeded
12:41:02 <roconnor> shachaf: hmm
12:41:19 <edwardk> elliott: sadly ross really likes the longer name that nobody but he ever uses
12:41:51 <shachaf> Oh, wait, I remember that.
12:42:07 <shachaf> He added Foldable and Traversable instances for (e,) and (Either e), but not (Const r).
12:42:25 <roconnor> elliott: Data.Functor.Constant has more instances
12:42:31 * edwardk sighs.
12:42:41 <elliott> roconnor: ugh, really?
12:42:42 <elliott> it shouldn't :p
12:43:04 <shachaf> roconnor: Yes, because Ross refuses to add instances for Const.
12:43:09 <elliott> really
12:43:13 <roconnor> shachaf: wow
12:43:23 <roconnor> elliott: so there you go.  politics
12:43:34 <elliott> surely Identity and Constant are out of scope for transformers anyway
12:43:37 <roconnor> shachaf: it isn't a module dependency issue is it?
12:43:39 <elliott> they aren't even functor transformers
12:43:50 <shachaf> roconnor: I don't think so.
12:44:03 <shachaf> I mean, it's defined in Applicative. Traversable definitely needs Applicative.
12:44:11 <shachaf> http://www.haskell.org/pipermail/libraries/2013-June/020205.html
12:45:36 <roconnor> though neither have a Show instance
12:45:44 <Fuuzetsu> :t Identity
12:45:45 <lambdabot> a -> Identity a
12:46:07 <roconnor> :t runIdentity
12:46:08 <lambdabot> Identity a -> a
12:46:19 <shachaf> If you really have nothing to hide, how come you don't have a Show instance?
12:47:33 * roconnor loads up shachaf's link
12:47:47 <tac> :t concat
12:47:48 <lambdabot> [[a]] -> [a]
12:47:51 <roconnor> please don't say that nobody want to traverse a Const functor ...
12:48:09 <joelteon> PrivateData { bankPasswords = [...], bombSchematics = BombSchematics PipeBomb, ... }
12:49:18 <bennofs> I want Ixed and Contains instances for Const! :P
12:49:32 <jfischoff> I'm getting error: ../dist/build/autogen/cabal_macros.h: No such file or directory when trying to build using cabal sandboxes to build HsOpenSSL as a "add-source"-ed package. Builds fine normally
12:49:36 <jfischoff> any ideas?
12:50:39 <roconnor> woo-hoo
12:50:57 * haasn .oO( newtype Fix f = Fix { break :: f (Fix f) } )
12:51:27 <joelteon> haha, fixing doesn't help in haskell, it just causes the problem infinite times
12:51:34 <haasn> > fix error
12:51:35 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:51:42 <jfischoff> dcoutts: ping. Cabal sandbox question ^
12:52:08 <roconnor> haasn: *lol*
12:52:42 <roconnor> haasn: Identity a = Identity { identity :: a}
12:53:04 <haasn> that's correct! up to isomorphism
12:53:21 * hackagebot pipes-concurrency 1.2.1 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-1.2.1 (GabrielGonzalez)
12:53:22 <bennofs> @let my = const
12:53:23 <lambdabot>  Defined.
12:53:23 * hackagebot comonad 3.1 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-3.1 (EdwardKmett)
12:53:25 * hackagebot comonads-fd 3.0.3 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-3.0.3 (EdwardKmett)
12:53:27 * hackagebot monad-par-extras 0.3.3 - Combinators and extra features for Par monads  http://hackage.haskell.org/package/monad-par-extras-0.3.3 (RyanNewton)
12:53:35 <haasn> > fix my error -- wooh
12:53:35 <bennofs> > fix $ my Identity -- lol
12:53:36 <lambdabot>   Occurs check: cannot construct the infinite type:
12:53:36 <lambdabot>    t0 = ([GHC.Types.Char]...
12:53:36 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1
12:53:36 <lambdabot>                     Data....
12:53:45 <bennofs> huh
12:54:05 <haasn> oh
12:54:07 <bennofs> Where is that Typeable constraint coming from lol?
12:54:08 <haasn> > fix (my error) -- not as pretty =(
12:54:09 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:54:09 <lambdabot>    arising from a use ...
12:54:15 <bennofs> > fix $ my Identity -- lol
12:54:15 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1
12:54:16 <lambdabot>                     Data....
12:54:16 <Fuuzetsu> GHC
12:54:17 <joelteon> :t my
12:54:18 <haasn> elliott breaking somethign presumably
12:54:18 <lambdabot> a -> b -> a
12:54:21 <joelteon> :t my error
12:54:22 <lambdabot> b -> [Char] -> a
12:54:27 <Fuuzetsu> :t my
12:54:27 <lambdabot> a -> b -> a
12:54:29 <joelteon> > fix $ my error
12:54:31 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:54:31 <lambdabot>    arising from a use ...
12:54:34 <Fuuzetsu> my 1 2
12:54:36 <bennofs> > fix `my` error -- lol
12:54:37 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:54:37 <lambdabot>    arising from a use ...
12:54:37 <Fuuzetsu> > my 1 2
12:54:40 <lambdabot>   1
12:54:43 <bennofs> > fix `my` error :: () -- lol
12:54:43 <monochrom> what are you all doing?
12:54:44 <Fuuzetsu> :t const
12:54:44 <lambdabot>   Couldn't match expected type `()'
12:54:44 <lambdabot>              with actual type `(a0 -> a0)...
12:54:44 <lambdabot> a -> b -> a
12:54:46 <roconnor> okay okay, enough already
12:54:53 <roconnor> take it to PM until you get it right :)
12:56:30 <FreeFull> > fix `my` error "please"
12:56:31 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:56:31 <lambdabot>    arising from a use ...
12:56:35 <FreeFull> > fix `my` error "please" :: Int
12:56:36 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:56:36 <lambdabot>              with actual type ...
12:56:41 <shachaf> Enough bot spam.
12:56:41 <FreeFull> Actual type what
12:56:44 <FreeFull> Actual type WHAT
12:56:50 <elliott> if you /msg lambdabot it will tell you.
12:57:00 <Mortomes> [yijalldp;
12:57:03 <elliott> or you could use :t. or any number of things
12:57:06 <shachaf> Enough human spam, too.
12:57:26 <Mortomes> Oops, sorry about that
12:59:17 <FreeFull> Oh, I get it now
12:59:57 <jfischoff> dcoutts: nevermind
13:01:44 <bennofs> We have a show instance for Data a in lambdabot? ;O
13:01:58 <elliott> there is an instance (Typeable a, Typeable b) => Show (a -> b)
13:02:00 <haasn> > succ :: Int -> Int
13:02:01 <lambdabot>   <Int -> Int>
13:02:10 <haasn> so that's where the Typeable constraint came from
13:02:23 <haasn> oh, as elliott just said
13:02:23 <Fuuzetsu> Is this new?
13:02:37 <elliott> not really
13:02:38 <elliott> it's old
13:02:46 <elliott> it has a lame instance that just gave an error for a while but it used to have a good one
13:02:47 <shafire> hi
13:02:50 <elliott> so I put the good one back
13:03:14 <shafire> how are you?
13:05:28 <burz> splendid, thanks
13:06:49 --- mode: card.freenode.net set +o ChanServ
13:12:26 <Xunie> Since functions in Haskell are pure. It seems fairly trivial for the compiler/interpreter to execute large sub-sections of code in multiple threads.
13:12:43 <Xunie> Does ghc/ghci do this?
13:12:53 <ski> <shachaf> Newtype matches being irrefutable has to do with why newtype existentials aren't allowed, I think.
13:12:57 <ski> shachaf : elaborate ?
13:13:08 <mauke> Xunie: not automatically
13:13:23 <mauke> you have to give it some hints
13:13:47 <bb010g> I'm having an error I don't understand on a number module I'm making. Any help? http://lpaste.net/90853
13:13:52 <Xunie> mauke, like... what kind of hints?
13:14:02 <mauke> Control.Parallel.Strategies
13:14:05 <shachaf> ski: dolio said something about it once... I don't remember anymore.
13:15:03 <mauke> http://hackage.haskell.org/packages/archive/parallel/3.2.0.3/doc/html/Control-Parallel-Strategies.html
13:15:19 <Ralith> Xunie: yes, that would be trivial; however it would also not reliably make anything faster, since parallelization isn't free
13:15:32 <bb010g> It builds fine if I comment out the makeHP35s lines.
13:15:58 <Xunie> Ralith, parallelization is a harsh mistress. :3
13:16:00 <bb010g> s/makeHP35s/makePN35s
13:18:14 <monochrom> OPTIONS? LANGUAGE?
13:18:37 <monochrom> ok, you put it all those -X's, it's likely neither
13:18:45 <ski> shachaf : ok
13:19:43 <monochrom> it should be {-# LANGUAGE LiberalTypeSynonyms, RankNTypes, etc #-}
13:19:55 <bb010g> Oh.
13:20:48 <orzo_> I have an app that started used lazy bytestrings when i started, but as i adapted it to newer libraries it was using Data.Text interface and now has a lot of conversions to and from Bytestring to Text
13:21:41 <orzo_> I suspect it would be a good idea to go ahead and overhaul the thing and purge use of Bytestring altogether except in rare instances where im not using it as text
13:21:46 <monochrom> c::Integer, this pins down c's type, it is not polymorphic a1. similarly for e.
13:22:22 <bb010g> monochrom: The type doesn't pin it down?
13:22:23 <orzo_> Is that sensible?  Or does text incur a significant cost over bytestring and i might as well keep the hyprid system
13:22:45 <elliott> you should not use ByteString as a representation of text unless you have a special reason to
13:23:01 <luite> orzo_: yep, ByteString is also a bit less flexible, since it uses foreign pointers. if you don't need to pass it to foreign code Text is better since it will cause less fragmentation
13:23:01 <monochrom> the type does pin it down, it's Integer now, therefore it is not polymorphic a1
13:23:22 <shachaf> ski: Oh: <dolio> If you write a type Vec a n of length indexed vectors... <dolio> And then you write 'newtype List a = forall n. L (Vec a n)'. <dolio> Then you can write infinite lists using that type, as long as you can irrefutably match. <dolio> But, such values of List a contain a value that is not well typed by Vec a n for any finite n.
13:23:49 <orzo_> thanks
13:24:21 <monochrom> how about I use a simpler example?  pie :: forall t. t; pie = ().  do you agree that this is an error?
13:24:54 <elliott> shachaf: oh, that's a good reason.
13:24:59 <bb010g> No, looking at it.
13:25:00 <ski> shachaf : hm, i think recall the "unfounded existential type variable" from some other example
13:25:05 <luite> orzo_: i think a ByteString has a bit more overhead as well, but it wouldn't be that much, a few words
13:25:17 <bb010g> monochrom: Is it?
13:25:32 <monochrom> it is. try it.
13:25:40 <luite> orzo_: neither is terribly efficient for really short strings though
13:26:05 <elliott> well, ByteString is also half the size in many cases, for UTF-8 text.
13:26:11 <elliott> so talking of size overhead is a bit silly
13:26:25 <orzo_> well i'm parsing xml streams, i used to use a bytestring-based library for that but i've switched to a text-based library
13:27:02 <orzo_> oh, is text stored as utf-16 or something?
13:27:07 <luite> yes
13:27:08 <joehillen> does anyone know how to convert a Bytestring to a Network.Socket.HostAddress (alias to Word32)?
13:27:23 <alexander__b> https://secure.plaimi.net/~alexander/tmp/clac.hs -- someone rightly pointed out that pi doesn't work in this, how do I... make it work? I don't understand why what I'm doing there is wrong.
13:27:26 <orzo_> that's curious
13:27:27 <bb010g> monochrom: Why? Isn't the empty tuple a valid type?
13:27:41 <ion> @hackage cereal -- joehillen: Perhaps you’re looking for this.
13:27:42 <lambdabot> http://hackage.haskell.org/package/cereal -- joehillen: Perhaps you’re looking for this.
13:27:44 <orzo_> i'm pretty sure the stuff is UTF-8 on the wire and i dont see much point in converting
13:28:19 <mauke> alexander__b: "doesn't work" how?
13:28:24 <alexander__b> mauke: ERROR
13:28:37 <alexander__b> $ ./clac "5 pi +"
13:28:39 <alexander__b> ERROR
13:28:50 <monochrom> the empty tuple is a valid type. this doesn't make a difference.
13:29:01 <alexander__b> however, $ ./clac "5 pi"
13:29:03 <alexander__b> 3.141592653589793
13:29:14 <alexander__b> running it with just pi will also ERROR.
13:29:23 <shachaf> alexander__b: Well, look at the definition: f (_:xs)   "pi"   = return (pi:xs)
13:29:24 <mauke> alexander__b: pi pops an element
13:29:37 <mauke> your "pi" is effectively \_ -> pi
13:29:42 <alexander__b> yes, I thought I popped the "pi" el... oh wait
13:29:56 <mauke> 5 0 pi + should work
13:30:13 <shachaf> This is the only place in "f" that uses an _.
13:30:15 <monochrom> you must have been influenced by inferior tutorials that say "forall means any". they are missing the point. the point has never been "any". the point has always been "but who gets to choose?"
13:30:29 <luite> orzo_: there was an experiment replacing it with (or adding, i'm not sure) UTF-8, but it didn't really have enough of an advantage
13:30:33 <alexander__b> mauke: no but changing to pi:x:xs works
13:30:43 <mauke> alexander__b: why have x?
13:30:47 <monochrom> "pie :: forall t. t" means: the user of pie gets to choose a type for t. not the author.
13:30:51 <alexander__b> mauke: I won't. I ust did it to test, heh.
13:30:58 <mauke> alexander__b: also, that should fail for just "pi"
13:31:04 <alexander__b> mauke: yep
13:31:08 <monochrom> and yet, "pie = ()" means the author chooses a type for t, not the user. contradiction.
13:31:19 <mauke> preflex: calc 5 pi +
13:31:19 <preflex>  8.141592653589793
13:31:27 <shachaf> alexander__b: Take inspiration from the last line of f.
13:31:29 <geekosaur> alexander__b, think about what you're doing. there is a simple and correct fix, if I'm reading your code correctly; that wasn't it
13:31:36 <alexander__b> f (xs) "pi" return (pi:xs) works nice.
13:31:38 <geekosaur> ^^
13:31:54 <alexander__b> geekosaur: no, that was a quick "fix" to just verify that I was being stupid.
13:31:55 <mauke> don't need parens around xs
13:32:09 <shachaf> In fact you could extend readMaybe to handle "pi" along with the other constants.
13:32:11 <monochrom> in "makePN35s :: Integer -> Int -> PNum P12", it promises that the user gets to choose types for a1 and a2.
13:32:13 <alexander__b> mauke: I know. I left them to see if ghc-mod would whine. curiously, it did not.
13:32:37 <alexander__b> it usually whines about unnecessary parens/brackets/etc
13:33:00 <monochrom> and yet "(c, e, ...)" the author is usurping the user in choosing a1 and a2, he's saying a1=Integer, a2=Int. not letting user choose.
13:33:24 <mauke> preflex: calc pi ~
13:33:24 <preflex>  -3.141592653589793
13:33:28 <mauke> preflex: calc pi ~ 1 ~ +
13:33:28 <preflex>  4.141592653589793
13:33:56 <bb010g> monochrom: Oh! So, what should I be using?
13:34:07 <monochrom> the point has never been "a1 can be any type". the point has always been a class struggle between author and user, who gets to choose, who must obey.
13:34:17 <ski> bb010g : saying `polymorphicThing :: forall t. ..t..' means that you promise that `polymorphicThing' will have type `..t..' for *any* choice of `t' that the *user/caller* of `polymorphicThing' wants -- you, as implementer of `polymorphicThing' has no say in what `t' should be. in particular, you can't insist that the caller must choose `t' to be `Integer'
13:34:32 <monochrom> I don't know. it depends on what you want to accomplish.
13:35:55 <bb010g> ski: So I can give typeclass restrictions, but not type restrictions?
13:36:56 <ski> i'm not sure what you're asking, but i suspect the answer is no
13:37:33 <shachaf> This has nothing to do with type classes. This is a much more fundamental thing.
13:38:33 <ski> judging from the code of `pHP35s' and `makePN35s', it appears you want the callee (i.e. the implementing code of those) to choose `a1',`a2', and to have the responsibility for ensuring that for those choices, `Integral a1' and `Integral a2' holds
13:38:48 <ski> if so, you may want to use existentials
13:39:09 <shachaf> It's also possible that what you *really* want isn't existentials.
13:39:46 <ski> but beware that newbies (at least ones used to OO) often appear to reach for existentials, even when in many cases there's simpler ior better ways to achieve the goal
13:39:57 <ski> @where existential-antipattern
13:39:57 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
13:40:04 <bb010g> I haven't used OO before.
13:40:09 <ski> (that being said, there are legitimate uses of existentials)
13:41:05 <ski> conceptually, if you want existentials, instead of `forall a1 a2 . (Integral a1, Integral a2) => (a1, a2, Precision n)', you want `exists a1 a2 . (Integral a1, Integral a2) *> (a1, a2, Precision n)'
13:41:11 <ski> so that instead of getting
13:41:29 <ski>   pHP35s :: forall a1 a2 . (Integral a1, Integral a2) => (a1, a2, Precision P12)
13:41:33 <ski> you get
13:41:40 <ski>   pHP35s :: exists a1 a2 . (Integral a1, Integral a2) *> (a1, a2, Precision P12)
13:41:43 <alexander__b> dmwit: would you care to expand on how the binOp thing would function? I'm not sure I'm following
13:41:51 <ski> (and similarly, for the expansion of `Precision P12')
13:42:03 <dmwit> err
13:42:06 <dmwit> binOp thing?
13:42:19 <alexander__b> dmwit: you mentioned it uh yesterday? two days ago? lol
13:42:34 <dmwit> You might have to refresh my memory. Sorry. =P
13:42:40 <ski> the `exists' in the "return/result type" here means that the *implementer/author* of `pHP35s', iow the callee, gets to decide which types `a1' and `a2'
13:42:46 <alexander__b> dmwit: NP, https://secure.plaimi.net/~alexander/tmp/clac.hs
13:43:02 <alexander__b> dmwit: you said you would "binOp (+) (x:y:rest) = return"
13:43:30 <ski> (and the `*>' instead of `=>' means that it's the callee's responsibility of showing that the instances `Integral a1',`Integral a2' hold, rather than the caller's)
13:43:50 <dmwit> ah, yeah
13:43:56 <dmwit> Well, you cut off a bit. =)
13:44:04 <dmwit> binOp (+) (x:y:rest) = return ((x+y):rest)
13:44:27 <alexander__b> my copypaste from the chat might have been incomplete, yes
13:44:34 <ski> bb010g : now, there is actually no `exists' keyword in Haskell (not even in extensions in GHC) -- what you have to do it to create a new data type (using `data'), to encode the existential
13:44:39 <dmwit> ...and I suppose binOp _ _ = Nothing or something like that.
13:45:16 <S_J> so a monoid was easy to implement in python but a Monad less so.Is there some law that determines how a ADT must look when defining a Monad for it?
13:45:19 <bb010g> ski: I would use record syntax, but I want my operations to have the same precision at compile time.
13:45:22 <alexander__b> dmwit: I'm still a bit... confused as to where thi sgoes and uh what it does lol. sorry.
13:45:28 <ski> bb010g : since you already had invented names for `PNum' (as well as `Precision'), we can simply change them to using `data', making an "existential data type"
13:45:38 <byorgey> S_J: no
13:45:39 <solrize_> S_J you should read the typeclassopedia if you haven't yet
13:45:45 <ski> there's two syntices for this :
13:46:03 <dmwit> alexander__b: Well. You notice how the first, uh... 6? 7? of your equations look similar?
13:46:05 <ski>   data PNum n = forall a1 a2. (Integral a1, Integral a2) => MkPNum (a1, a2, Precision n)
13:46:14 <alexander__b> dmwit: yes
13:46:15 <dmwit> alexander__b: The idea is to factor out that similarity as much as possible into its own function.
13:46:22 <alexander__b> dmwit: I get that
13:46:27 <ski> alt., if you don't want the tuple
13:46:32 <ski>   data PNum n = forall a1 a2. (Integral a1, Integral a2) => MkPNum a1 a2 (Precision n)
13:46:32 <dmwit> okay, so what then?
13:46:40 <ski> the other syntax is
13:46:51 <ski>   data PNum n
13:46:52 <alexander__b> dmwit: so you would do some matching in f, and then call binop with the operator and list?
13:46:53 <ski>   where
13:46:58 <S_J> does it make sens e o implement monads and monoids etc in other langs when you dont have all the haskell machinery?
13:47:02 <dmwit> binOp is the factored code. Then you call binOp in your first 6 cases.
13:47:04 <dmwit> exactly
13:47:13 <Fuuzetsu> …any idea why Haddock completely disregards License/Licence/Copyright (and Module but this one doesn't really matter) fields in the module header?
13:47:16 <dmwit> e.g. f xs "*" = binOp (*) xs
13:47:16 <alexander__b> dmwit: so what would the entry in f look like?
13:47:17 <S_J> also, after i have defined a monoid, what do iget for free besides mconcat?
13:47:19 <ski>     MkPNum :: (Integral a1, Integral a2) => (a1, a2, Precision n) -> PNum n  -- `forall's are optional
13:47:28 <dmwit> nailed it
13:47:35 <dmwit> I'm prescient. ;-)
13:47:48 <ski> bb010g : it is possible to combine these with record syntax, btw
13:47:49 <jfischoff> S_J: without do notation I find them annoying in other languages, but some times better than the alternative
13:48:00 <alexander__b> dmwit: but that would give me a bunch of f xs someop = binOp someop xs
13:48:11 <dmwit> yep
13:48:16 <alexander__b> dmwit: but how is that... better?
13:48:34 <ski> bb010g : is this helping ?
13:48:38 <bb010g> Wouldn't the record syntax break the compile time precision check?
13:48:42 <bb010g> ski: Yes.
13:48:51 <ski> why would it ?
13:48:53 <dmwit> Well, you don't repeat the pattern; you don't repeat the three function calls; and with a bit more refactoring you needn't even repeat the stack itself.
13:49:35 <ski> bb010g : btw, you can't extract record fields involving the "existentially quantified type variables" using the field selectors
13:49:46 <ski> you have to pattern-match to access those fields
13:49:51 <dmwit> Optionally, later, you could have a real parse tree and then have a literal like [("*", (*)), ("+", (+))] that matched strings up with operations and then you could operate generically over all binary operations, making extending the language very easy.
13:50:37 <ski> (this is again because such selector functions would need to be typed using `exists', which (currently, at least) isn't a valid keyword in Haskell)
13:51:11 <alexander__b> dmwit: ah.
13:51:18 <alexander__b> dmwit: well... this step first lol.
13:51:28 <alexander__b> dmwit: thanks a lot for the feedback/handholding. I appreciate it.
13:51:29 <ski> bb010g : anyway, because you have to encode existentials with a concrete datatype, you have to explicitly wrap and unwrap using the constructor (possibly together with record syntax)
13:51:32 <bb010g> ski: Ick... I think I'll just drop the compile time check with the whole Peano number thing and just go with something simpler.
13:51:41 <bb010g> ski: Like record syntax. :)
13:52:18 <ski> bb010g : existentials aren't that hard when you get the hang of them, though it's sometimes a bit annoying and clunky that you can't directly use an `exists'
13:52:25 <alexander__b> dmwit: uhm, I have binOp (+) (x:y:rest) = return (x+y:rest)
13:52:27 <alexander__b> binOp (*) (x:y:rest) = return (x*y:rest)
13:52:39 <alexander__b> and ghc-mod whines about This binding for `+' shadows the existing binding
13:52:47 <alexander__b> (and for * as well)
13:52:49 <bb010g>  ski: As this is my first Haskell project, I think I'll play with them later.
13:53:00 <ski> sure
13:53:10 <mauke> > let (+) = (*) in 2 + 3
13:53:10 <alexander__b> bb010g: I didn't follow your posts -- what is your first haskell project? I'm doing mine as well.
13:53:11 <lambdabot>   6
13:53:14 <FreeFull> alexander__b: You can't pattern match on functions
13:53:33 <ski> bb010g : btw, have you used C ?
13:54:17 <FreeFull> alexander__b: I think what you want is     binOp f (x:y:rest) = return (x `f` y:rest)
13:54:23 <bb010g> alexander__b: A HP35s simulator. I'm going to go for an exact copy first, then start making it more general purpose.
13:54:45 <dmwit> alexander__b: I did something subtle.
13:54:45 <alexander__b> bb010g: sounds more ambitious than my project :-P
13:54:53 <FreeFull> Or something else
13:54:53 <ski>   binOp (+) (x:y:rest) = return (x + y : rest)
13:55:00 <alexander__b> dmwit: what was that? don't be subtle with an idiot. ;-)
13:55:03 <dmwit> alexander__b: You should not create one line of binOp per operator you need.
13:55:03 <bb010g> ski: No, it's on my list of languages to try, after prolog.
13:55:10 <dmwit> alexander__b: I really posted the entire code of binOp.
13:55:13 <ski> bb010g : ok
13:55:21 <alexander__b> dmwit: oh. that was why I was confused/thought your code was odd. :-P
13:55:26 <dmwit> alexander__b: Alpha-varying may make it more obvious, as FreeFull pointed out.
13:55:36 <ski> bb010g : if you don't mind me asking, which languages have you used ?
13:56:15 <ski> (bb010g : i asked about C, because there's a common idiom there that corresponds to the idea of existentials -- it could perhaps help you understand what existentials are)
13:56:24 <alexander__b> ski: but I still get the whole This binding for `+' shadows the existing binding
13:56:48 <bb010g> ski: I've played with calculator programming--RPN and TI-Basic.
13:56:51 <ski> you could use `<+>' or something, i suppose
13:57:02 <ski> bb010g : ok, fine
13:57:07 <josephle> ski: isn't the interface/implementation idea the big analogy for existentials?
13:57:13 <ski> no worry about existentials, it will come
13:57:20 <alexander__b> ski: or just somefunctionname like FreeFull did. that worked nicely, and made it a bit more obvious to me, heh.
13:57:31 <bb010g> ski: I'm actually doing this because the programs on the 35s are SLOW and hard to navigate. (Two line screen.)
13:58:23 <ski> josephle : i was thinking about simulating closures (sometimes objects) by a `void *' environment pointer, and a pointer to a function that accepts that environment in addition to auxilary arguments
13:59:08 <alexander__b> dmwit: OK this is really neat. now that I get WTF's going on. :-P thanks. and thanks to FreeFull for making it more obvious WTF's going on.
13:59:44 <josephle> ski: ah, I see what you mean.
13:59:50 <alexander__b> ghc-mod's _T is so great. wow.
13:59:52 <ski> josephle : another example would be a pointer to a sequence of (unknown number of) objects, and a pointer to a function that accepts a pointer to a sequence of equally many such objects
14:00:07 <josephle> I was taught existentials from the PLT side, so I always see them in terms of interface-implementation
14:01:47 <dmwit> alexander__b: Your code assumes that tabs align to eight-space tabstops. This is fine, because GHC assumes this too, but you should be aware that you are making this assumption, and change your editor's configuration if that wasn't an assumption you wanted to make.
14:02:09 <alexander__b> dmwit: wat? I don't use hard tabs
14:02:19 <alexander__b> dmwit: oh
14:02:30 <alexander__b> dmwit: so apparently the haskell format options I have enabled do that
14:02:30 <dmwit> There is a hard tab in the code you pasted. =)
14:02:37 <ski> (`a -> b' can be encoded as `exists s. (# s , (# s , a #) #-> b #)', where `(# ... , ... #)' is unboxed pair, and `#->' (<http://en.wikipedia.org/wiki/Strict_implication>) is the type of functions not depending on any nonlocal environment except that accessible everywhere (iow the "static" environment), which corresponds to C function pointers)
14:03:58 <dmwit> alexander__b: http://lpaste.net/90855
14:04:12 <alexander__b> dmwit: right the formatoptions set by my haskell ftplugin use vim defaults for sw and ts. I prefer soft spaces and a width of 2,is this acceptable in haskell-land?
14:04:27 <dmwit> That's pretty orthodox.
14:04:29 <tulcod> what FFI tool should I learn? i'm willing to dive deep as long as i end up with the best toolset. is Green Card the right choice?
14:04:39 <dmwit> or
14:04:42 <dmwit> What does soft spaces mean?
14:04:55 <alexander__b> dmwit: tabs are actual spaces not \t
14:05:04 <dmwit> That's pretty orthodox, yeah.
14:05:09 <alexander__b> dmwit: will return ((x+y):rest) actually work? I changed it to y+x here because of / and -
14:05:45 <alexander__b> dmwit: other than that I have what you have only I didn't get to unop :-P
14:05:45 <alexander__b> dmwit: thanks though
14:05:47 <ski> alexander__b : btw, did you fix `pi' ?
14:05:47 <geekosaur> tulcod, I think greencard is pretty much obsolete these days? (in fact I haven't seen it build in any ghc version from 6.6 on) mostly people use hsc2hs, or c2hs for well behaved C structs
14:05:57 <alexander__b> ski: ya. thanks for pointing it out. :-)
14:06:13 <dmwit> well, assuming you bound the function to (+), yes
14:06:14 <josephle> ski: ah yes, closure conversion
14:06:23 <dmwit> Hm, I wonder...
14:06:34 <alexander__b> dmwit: OK please explain that subtlety now :-P
14:06:57 <tulcod> geekosaur: so the most advanced operative tool would be c2hs?
14:06:58 <alexander__b> dmwit: I bound it to (op) (x:y:rest) = return (y `op` x : rest)
14:07:04 <dmwit> Yes, that's fine.
14:07:06 <alexander__b> dmwit: which works, but I guess yours is smarter?
14:07:10 <dmwit> Nope.
14:07:13 <dmwit> Just prettier. =)
14:07:14 <bb010g> One last question: I remember reading on LYAH that newtypes are more lazy than data & record syntax. Is that ever really a problem?
14:07:18 <geekosaur> fsvo advanced
14:07:21 <alexander__b> dmwit: but WTF why does it work? with / and -
14:07:32 <dmwit> (+) is just a variable name
14:07:44 <geekosaur> c2hs does the most work for you, but assumes nobody's playing any weird games anywhere. unfortunately, in C you can almost guarantee weird games somewhere
14:07:44 <ski> (`a #-> b' can be thought of as `[] (a -> b)', where `[]' denotes a "neccessary"-type modality of "known"/"persistent"/"non-cotingent")
14:07:44 <alexander__b> so why does x (+) y work?
14:08:10 <alexander__b> if (+) is -, 5 7 - would give you 7 - 5 instead of 5 - 7,no?
14:08:15 <geekosaur> (there's a special fork of c2hs that knows about the specific games that the gtk source plays... usually)
14:08:30 <dmwit> > let (+) = (-) in 5 + 7
14:08:31 <lambdabot>   -2
14:08:31 <alexander__b> unrelated again but is textwidth=78 acceptable in haskell?
14:08:37 <dmwit> > let (+) = (-) in 7 + 5
14:08:37 <ski> bb010g : if any difference, usually the opposite, i think
14:08:37 <tulcod> geekosaur: hm, that could be relevant, thanks
14:08:38 <lambdabot>   2
14:09:15 <tulcod> geekosaur: if there are weird games, does c2hs allow "overrides", if i can oversimplify the matter?
14:09:30 <tulcod> or does it crash and burn?
14:09:42 <dmwit> alexander__b: Anyway, if you find that binOp (-) is going the "wrong way", just use binOp (flip (-)) instead. ;-)
14:09:51 <alexander__b> heh
14:09:58 <alexander__b> true enough :-P
14:09:59 <S_J> > fmap (+) [1..10]
14:10:00 <lambdabot>   [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer ->...
14:10:06 <S_J> > fmap (+1) [1..10]
14:10:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:10:18 <S_J> @src map
14:10:18 <lambdabot> map _ []     = []
14:10:18 <lambdabot> map f (x:xs) = f x : map f xs
14:10:34 <S_J> @src fmap
14:10:34 <lambdabot> Source not found. Do you think like you type?
14:10:39 <S_J> ofc
14:10:40 <alexander__b> dmwit: thanks a lot for a *very* thorough feedback session
14:10:43 <alexander__b> dmwit: if only customer service was this good
14:10:46 <ski> @src [] fmap
14:10:46 <lambdabot> fmap = map
14:11:10 <ski> @src Maybe fmap
14:11:10 <lambdabot> fmap _ Nothing       = Nothing
14:11:10 <lambdabot> fmap f (Just a)      = Just (f a)
14:11:18 <jfischoff> @src Tree fmap
14:11:18 <lambdabot> Source not found. My pet ferret can type better than you!
14:11:46 <ski>   fmap f (Node a ats) = Node (f a) (map (fmap f) ats)
14:12:45 <Fuuzetsu> AFAIK, there's no way to defined ‘foo r f v = r { f = v }’, is there?
14:12:49 <Fuuzetsu> to define*
14:12:57 <geekosaur> tulcod, don't know really, haven't used it for complex things. I generally stick to hsc2hs, but I'm reasonably familiar with working wth things at that lower level
14:13:25 <johnw> Fuuzetsu: right, because f is syntactic there
14:13:34 <tulcod> geekosaur: thank you very much :)
14:13:35 <ski> Fuuzetsu : no, you can't pass field names as arguments
14:13:37 <johnw> Fuuzetsu: lens can make something like that
14:13:53 <Fuuzetsu> Heh, I was just thinking ‘damn, I need lens’
14:15:45 <astor> Is there an example of an ecommerce site using yesod/happstack/snap?
14:17:40 <johnw> astor: by ecommerce, what do you mean exactly?
14:18:18 <S_J> http://lpaste.net/90856 <- i cant define my fucntor for matrix
14:18:18 <astor> johnw: some site that sells something and accepts payments.
14:18:30 <astor> johnw: or just any site that accepts payments is good enough for me.
14:18:36 <johnw> ah, I'm actually going to start writing just such a thing today, based on Yesod and persitent
14:19:11 <astor> johnw: What type of payment system will you use?
14:19:17 <S_J> wait
14:19:19 <johnw> I think CyberSource
14:19:29 <johnw> since they can also do tax calculation for international sales
14:19:31 <osa1> stylish haskell doesn't support MultiWayIf syntax ;-(
14:19:32 <aristid> preflex: seen Tekmo
14:19:32 <preflex>  Tekmo was last seen on #haskell-lens 7 days, 16 hours, 37 minutes and 20 seconds ago, saying: That's pretty much exactly how I felt when I saw the lens docs saying "preview = view . pre"
14:19:38 <ion> s_j: Types of kind * -> * can be Functor instances. Matrix :: *, i.e. it doesn’t take a type parameter.
14:19:39 <S_J> http://lpaste.net/90857 <- same problem but updated.
14:19:57 <ion> s_j: Try data Matrix a = Matrix [[a]]
14:20:04 <aristid> anybody know what's the best way to ask Tekmo a short question when he's not on irc?:)
14:20:12 <alexander__b> dmwit: what does "const pi" do?
14:20:19 <ion> s_j: Btw, those Monoid instances are evil. :-P
14:20:25 <S_J> ion: why?
14:20:37 <astor> johnw: interesting.
14:21:38 <alexander__b> dmwit: also what is the significance of the names bin, un and nary?
14:21:52 <ion> s_j: Why is the Integer monoid (0,+) and the Int monoid (1,*)? Why, say, not the other way around? Why aren’t both the same monoid?
14:21:57 <S_J> but then i get monoid problems instead
14:22:13 <S_J> ion: didnt work?
14:23:48 <roboguy_> S_J: you should probably use the Sum and Product monoids
14:25:54 <roboguy_> S_J: the difference between Int and Integer is that Int is the word length integer (like C's int) and Integer is a arbitrary size integer. So, it doesn't really make sense to divide up them up with those instances
14:26:30 <johnw> S_J: what are "monoid problems"?
14:26:46 <johnw> is that when any two problems can make a new problem?
14:26:48 <ion> johnw: They aren’t easy/loveable enough.
14:27:08 <johnw> they are just an inverse away from a big group hug
14:27:11 <ion> Monoid money, monoid problems.
14:27:16 <josephle> johnw: but note that now you turned 2 problems into 1!
14:27:30 <acowley> Is anyone here brian (bsl on github)?
14:27:42 <josephle> details about problem difficulty are not included
14:28:18 * ion solves mempty
14:28:48 <roboguy_> S_J: I see the problem with the Functor instance, but you should definitely change those Monoid instances. And, if you want matrix monoids, you should make separate MatrixSum and MatrixProduct types
14:29:05 <byorgey> acowley: not to my knowledge.  Though of course that proves nothing.
14:29:22 <acowley> I'll just wander the internet asking people if they are bsl
14:29:53 <shachaf> acowley: bsl is Brian Lewis, if that helps.
14:30:00 <shachaf> I don't think he is in here.
14:33:23 <FreeFull> I can't see how you'd do MatrixSum and MatrixProduct monoids without indexing by Nat
14:34:26 <roboguy_> FreeFull: you mean because of how matrix sizes relate to the operations?
14:39:53 <FreeFull> roboguy_: Yeah
14:40:06 <FreeFull> You can't add two arbitrary matrices, they have to be of the same size
14:40:20 <roboguy_> FreeFull: that's a good point, but it looks like he's just working with 3x3 matrices right now
14:42:05 <S_J> i cant implement a Functor for a Monoid?
14:42:22 <danharaj> The kinds don't match.
14:42:24 <joelteon> S_J: they're differently kinded
14:42:48 <FreeFull> I don't even see how functors and monoids would be related
14:43:20 <FreeFull> Other than monads in category theory
14:43:21 <roboguy_> S_J: it wouldn't be a Functor for a Monoid. Functors and Monoids aren't really related. it would be a data type that would have both a monoid and a functor on it
14:44:30 <klrr_> mm_freak: you where the author of netwire?
14:44:34 <klrr_> is*
14:44:47 <klrr_> are you *
14:46:29 <roboguy_> S_J: the reason that your functor instance doesn't work is because the Matrix type doesn't have a type argument. An example of a type that does take a type argument would be your Perhaps type
14:47:07 <roboguy_> S_J: data Perhaps x = ...    -- <- the x here is the type argument
14:47:56 <roboguy_> S_J: Functor requires that a type has one argument
14:50:05 <S_J> and i can make a monoid of nthat same type?
14:50:22 <S_J> instance Monoid (Matrix a) where?
14:51:08 <roboguy_> S_J: yeah, that is possible.
14:51:09 <S_J> data Matrix Int = Matrix [[Int]] deriving (Eq, Ord, Show)
14:51:28 <mauke> S_J: denied
14:51:34 <mauke> Int is not a variable
14:51:37 <roboguy_> S_J: you can't call it Int there, but if you called it "x" or "a" or something like that (with a lowercase letter) then it would work
14:53:05 <S_J> then mempty = Matrix [[1,0],[0,1]] becomes a problem, no isntance for Num
14:53:35 <mauke> put a constraint on a
14:54:17 <S_J> data Matrix a = Matrix [[Int]] deriving (Eq, Ord, Show) works
14:54:26 <S_J> howd i put a constraint on a?
14:54:30 <mauke> haha what
14:54:37 <roboguy_> S_J: that's not what you want either, you should replace "Int" with "a"
14:55:09 <roboguy_> S_J: to put a constraint, you put a "Monoid a => ..." in the instance to tell it that "a" has to be a Monoid instance
14:55:41 <mauke> or Num a
14:56:22 <S_J> can you show: instance Monoid a => ... (Matrix a) where
14:57:11 <jfischoff> is there anyway from within the cabal.sandbox.config to say "never use the repo remotes"?
14:57:30 <mauke> instance (Num a) => Monoid (Matrix a) where mempty = Matrix [[1,0],[0,1]]
14:58:35 <roboguy_> err, yeah mauke is right. it needs Num
15:12:39 <orzo_> hello, i'm working on a completely p2p implementation of (mostly, found some mods convenient) xmpp.  It is very integrated into linux, meaning it detects active tty and treats it as an xmpp client of last resort and it detects logins and treats those as xmpp users
15:12:51 <orzo_> it is intended to work on a lan or vpn
15:13:15 <orzo_> i'm seeking collaborators
15:13:24 <orzo_> it already does the basics of presence and so on
15:14:04 <orzo_> it's the only fully p2p implementation of xmpp that i'm aware of
15:14:35 <FreeFull> It sounds very invasive
15:14:49 <orzo_> i guess, if you dont know its installed
15:15:03 <orzo_> no more invasive than the traditional unix talk though
15:15:33 <orzo_> basically just mapping traditional unix messaging stuff to a modern protocol
15:16:07 <orzo_> your subscribers are stored in a config file in your home
15:16:23 <orzo_> and i plan on supporting a lot of configurations regarding user preference
15:16:36 <orzo_> such as invisibility, or disabling, or whatever
15:17:57 <orzo_> its intended use is to complement another project which i'm involved with, which is a linux distro providing instant p2p social networking and vpn
15:18:00 <dmwit> alexander__b: The traditional words for arity are "unary", "binary", "trinary", etc.
15:18:18 <dmwit> alexander__b: When you get high enough, you just say things like 93-ary, etc.
15:18:32 <dmwit> alexander__b: And when you don't care how many arguments you get, you might say you are "n"-ary. ;-)
15:18:35 <monochrom> @quote monochrom 17-ary
15:18:35 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
15:18:44 <monochrom> hehe :)
15:18:50 <dmwit> =D
15:19:44 <orzo_> along with easy hard drive encryption
15:39:01 <bel3atar> how do you guys read this: filter ((<10) . length) list
15:39:08 <bel3atar> ?
15:41:09 <FreeFull> bel3atar: As in, how it would be said out loud?
15:41:40 <tgeeky> filter list by ((< 10) . length)
15:42:03 <orzo_> bel3atar: gives you elements whose length is less than 10, all otehrs are discarded
15:42:05 <bel3atar> tgeeky: you didn't read the cool part
15:42:19 <bel3atar> orzo_: is this how you read it?
15:42:53 <orzo_> i guess "filter less-than-10 composed with length list", but i doubt somebody would know what i meant by my words
15:43:36 <johnw> bel3atar: find subitems less than 10 items long
15:43:45 <tgeeky> yeap
15:43:53 <tgeeky> i was about to make a mistake
15:44:35 <tgeeky> @unpl (\x -> filter ((< 10) . length) x)
15:44:35 <lambdabot> (filter (\ d -> (length d) < 10))
15:45:12 <Hermit> bel3atar: filter (\x -> length x < 10) list
15:46:24 <bel3atar> Hermit: that's more readable =D
15:47:15 <Hermit> bel3atar: only for those that are not used to pointfree
15:47:30 <Hermit> I prefer the pointfree version
15:47:41 <Hermit> but that's a matter of taste
15:47:41 <banister> tgeeky: clever!
15:59:03 <pchiusano> is haste dead?
15:59:09 <NeatBasis> [Beer] -> [Energy drink] -> Haskell code ?
15:59:13 <pchiusano> i was trying to find an old paste...
15:59:21 <pchiusano> hpaste, i mean
15:59:57 <NeatBasis> convert :: [Beer] -> [Energy drink] -> Haskell code
16:00:34 <monochrom> hpaste is moved to lpaste.net
16:02:07 <FreeFull> pchiusano: All the old pastes are over at lpaste
16:02:19 <monochrom> don't :: (Drink d, Code c) => [d] -> c
16:02:38 <monochrom> or maybe just d instead of [d]
16:03:06 <pchiusano> FreeFull: hmm looks like no way to search
16:03:15 <FreeFull> > let don't = 3 in don't
16:03:16 <lambdabot>   3
16:03:30 <FreeFull> Ok, ' is only special at the beginning of an identifier
16:04:00 <wole> @ty generate
16:04:01 <lambdabot> Not in scope: `generate'
16:04:07 <pchiusano> actually, copumpkin do you have that sliding window paste that ed sent you?
16:04:11 <FreeFull> pchiusano: Yeah, I don't think there is a search
16:12:03 <tswett> @pf do func <- exprFunc; parm <- exprParm; return (EApply func parm)
16:12:03 <lambdabot> Maybe you meant: pl bf
16:12:07 <tswett> @pl do func <- exprFunc; parm <- exprParm; return (EApply func parm)
16:12:07 <lambdabot> (line 1, column 20):
16:12:07 <lambdabot> unexpected ';'
16:12:07 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
16:12:38 <tswett> @hoogle (a -> b -> c) -> m a -> m b -> m c
16:12:38 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:12:38 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:12:38 <lambdabot> Data.IntMap.Strict intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
16:14:50 <slack1256> Why isn't anybody fliping over "List done Right"
16:14:58 <slack1256> or the effects of this aren't far reaching?
16:21:45 <ski> `List' or `ListT' ?
16:22:06 <slack1256> I guess is ListT
16:22:25 <slack1256> Yep, ListT
16:23:05 <ski> @wiki ListT done right
16:23:05 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
16:23:25 * hackagebot netclock 0.6 - Netclock protocol  http://hackage.haskell.org/package/netclock-0.6 (AlexMcLean)
16:24:04 <acowley> Isn't that ListT work somewhat old?
16:24:29 <aristid> just use pipes!
16:25:09 <acowley> While the flip-outs it caused may have been intense, they are now slightly faded memories.
16:27:20 <jmcarthur> aristid: if all i need is Request/Respond, ListT is a bit more straightforward
16:29:40 <danharaj> just use `pipe a b c d l m n o p`!
16:30:12 <aristid> danharaj: nah.
16:30:18 <aristid> it's all about the proxies now
16:32:51 <elliott> Proxy needs to have a name that isn't Proxy.
16:32:53 <elliott> desperately.
16:33:00 <elliott> that's like the #1 worst thing about pipes.
16:33:19 <shachaf> The name "Proxy" is taken.
16:33:38 <shachaf> Since pipes is being entirely rewritten for version 4.0 anyway, why not take the time to rename it?
16:33:39 <aristid> it's hard for me to get used to the kleisli style, but so far i quite like pipes actually.
16:33:53 <aristid> shachaf: how much will the API change?
16:33:55 <shachaf> The old Proxy is going into base in GHC 7.8.
16:34:06 <shachaf> aristid: Quite a bit, I think.
16:34:15 <aristid> it's going into base? oO
16:34:19 <aristid> but the old stuff?
16:34:25 <acowley> I think some of my resistance to pipes is due simply to the name Proxy
16:34:26 <shachaf> Proxy as in data Proxy a = Proxy
16:34:31 <aristid> oh that one.
16:34:35 <shachaf> The good one.
16:34:46 <shachaf> aristid: See https://github.com/Gabriel439/Haskell-Pipes-Library
16:35:07 <shachaf> (You can tell me if it's different or not. That way I don't have to read it.)
16:35:10 <aristid> acowley: it's at least not as messy as conduits and unlike io-streams you don't get stupid IO everywhere :)
16:35:20 <S_J> (ZipList gs) <*> (ZipList xs) = ZipList (zipWith ($) gs xs) // makes no sense to me if the type is (<*>) :: f (a -> b) -> f a -> f b since the 2 args are of different types...
16:35:26 <acowley> I played with pipes-4 a bit, and it did seem pretty nice
16:35:31 <elliott> shachaf: you should report a bug.
16:35:37 <acowley> except it was also somewhat verbose for my use-case
16:35:37 <shachaf> :t zipWith ($)
16:35:38 <lambdabot> [b -> c] -> [b] -> [c]
16:36:03 <acowley> aristid: But the name Proxy is ridiculously bad.
16:36:14 <aristid> shachaf: looks like it's just drastically simplified.
16:36:40 <shachaf> aristid: OK, that works too.
16:36:48 <shachaf> Can it simplify away the name "Proxy"?
16:36:48 <acowley> I hope they can shift to v4 soon so that the ecosystem can gain functionality rather than have to adapt to a moving foundation
16:36:48 <aristid> or actually not.
16:36:57 <aristid> it looks pretty much the same to my noob eyes.
16:37:08 <shachaf> aristid: OK, maybe it's not simpler or rewritten.
16:37:23 <danharaj> so what category do proxies inhabit
16:37:31 <aristid> danharaj: four of them.
16:37:34 <copumpkin> pchiusano: it's on his twitter somewhere, but no
16:37:44 <elliott> I would be okay with pipes if it didn't have () ->
16:37:51 <elliott> and didn't use the name Proxy.
16:37:55 <elliott> those are my top two objections.
16:37:56 <acowley> elliott++
16:38:18 <aristid> the way pipes automagically terminate is cool :D
16:39:53 <djahandarie> What is there in terms of ASM DSLs or other sort of things in that domain?
16:40:04 <djahandarie> (Something lower than C DSLs.)
16:40:06 <danharaj> There's a Coq x86 DSL fwiw
16:40:15 <djahandarie> That's interesting, thanks.
16:41:20 <acowley> djahandarie: How about the LLVM things?
16:41:37 <djahandarie> Oh yeah, that does fit the bill doesn't it.
16:41:43 <elliott> there's uh
16:41:44 <elliott> harpy?
16:41:48 <elliott> @hackage harpy
16:41:48 <lambdabot> http://hackage.haskell.org/package/harpy
16:42:02 <elliott> woo I got the name right
16:42:22 <djahandarie> Ah neat.
16:44:42 <aristid> now that's a lot of typeclasses
16:48:26 <NeatBasis> is there an equivalent of :t or :type that I can use within a program?
16:49:06 <monochrom> no
16:49:48 <NeatBasis> nice
16:50:03 <flebron> not sure what that would give... a string?
16:50:27 <geekosaur> people are spoiled and expect expensive introspection and string eval in every language
16:50:41 <elliott> :t typeOf
16:50:42 <lambdabot> Typeable a => a -> TypeRep
16:50:45 <elliott> but it's not teh same, of course.
16:53:41 <shachaf> There should be a version of typeOf that's so evil that it can handle polymorphism.
16:53:57 <geekosaur> I thought that was coming soonish
16:53:58 <geekosaur> ?
16:53:59 <monochrom> customers who have looked at introspection and eval have also looked at: self-modifying code
16:55:06 <shachaf> I don't mean polykinds. I mean typeOf id telling you about the forall.
16:57:06 <elliott> shachaf: I think Oleg had something like that.
16:57:08 <elliott> polytypeable or something
17:10:22 <dmwit> NeatBasis: It is not necessary; types are known at compile time.
17:10:45 <dmwit> NeatBasis: Hence for any particular value, the function you desire can be implemented as (const "something here").
17:12:17 <elliott> dmwit: that's not quite true. at least with something as simple as rank-2
17:13:16 <dmwit> GHC typechecks all code. Ergo, the type is known at compile time. (No?)
17:13:49 <elliott> no, because polymorphism exists
17:14:09 <elliott> I can write some code to read a natural number from stdin and then run some code with a specific assignment of a type variable to a corresponding type-level natural (without DataKinds or anything, that's just a nicety)
17:14:22 <elliott> and this can involve different instances being used etc. (so observable difference)
17:14:35 <elliott> but it means at one point you have a type asignment you do not know at compile time.
17:14:35 <dmwit> Polymorphic types are types, too.
17:14:45 <Saizan> the type is known, it might not be a canonical type
17:15:04 <Saizan> (e.g. a local type variable)
17:15:05 <elliott> dmwit: ok, but I have (x :: NatSing a) for some a that I can tell you is in {Z, S Z, S (S Z), ...} but you don't know which.
17:15:09 <elliott> Saizan: right.
17:15:15 <elliott> but then Typeable's typeOf gives you something const "foo" does not.
17:15:59 <dmwit> elliott: Right. You can write (const "forall a :: Nat. NatSing a"), for example.
17:16:02 <dmwit> No?
17:16:16 <prophile> @hoogle (a -> a -> Ord) -> [a] -> [a]
17:16:16 <lambdabot> Warning: Unknown type Ord
17:16:16 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
17:16:16 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
17:16:22 <prophile> uh, not Ord
17:16:34 <prophile> @hoogle (a -> a -> Ordering) -> [a] -> [a]
17:16:35 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
17:16:35 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
17:16:35 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
17:17:05 <elliott> dmwit: it most certainly does not have the type (forall a. NatSing a)
17:17:19 <elliott> (exists a. NatSing a) would be closer.
17:17:30 <elliott> but it's not actually existential and of course that is not a type in Haskell
17:17:43 <dmwit> I'm lost. Can you give a concrete snippet of code whose type is not known at compile time?
17:17:53 <prophile> dmwit: 0
17:17:56 <dmwit> ...yet which compiles, please.
17:18:00 <prophile> ah
17:18:00 <dmwit> prophile: forall a. Num a => a
17:18:02 <dmwit> NEXT
17:18:27 <elliott> dmwit: OK.
17:18:44 <danharaj> Read an Int from the console and turn it into a Nat singleton.
17:19:07 <copumpkin> readInt :: (forall n. Nat n -> r) -> IO r
17:20:14 <elliott> yeah, that's what I'm doing.
17:20:57 <copumpkin> I wish my name were Thoralf
17:21:09 <dmwit> It doesn't cost very much to make that wish come true.
17:21:19 <copumpkin> it costs a lot in convenience
17:22:48 <elliott> dmwit: http://lpaste.net/90859
17:24:49 <dmwit> looking
17:29:37 <dmwit> hm =)
17:30:04 <elliott> this surprised me too, first time I saw it.
17:30:15 <elliott> btw, this is exactly the idea behind the "reflection" package, or at least the original/slow implementation.
17:31:16 <dmwit> Well, is "exists n. Nat n" really such a bad type for tn?
17:31:37 <dmwit> Presuming for the moment that this existed in Haskell, of course.
17:31:54 <dmwit> Or... yeah, okay.
17:32:00 <dmwit> That's not really right, either.
17:32:20 <elliott> dmwit: it's not right because you could have other things in scope referencing the same n
17:32:28 <elliott> like if I did let tn' = tn, for the simplest example.
17:32:40 <elliott> it's really "Nat n", where n is a local type variable bound by the lambda
17:32:48 <elliott> er
17:32:50 <elliott> *it's really "n",
17:32:53 <elliott> i.e. $ \(tn :: n) -> ...
17:33:11 <elliott> but, again it shows that typeOf does the "more :t" thing than a const :)
17:34:33 <dmwit> Well, I guess the real oddity here is that tn is an open term.
17:34:54 <dmwit> You can't really see this problem with closed terms. (Right?)
17:35:51 <shachaf> Doesn't e.g. polymorphic recursion give you the same problem?
17:36:45 <dmwit> Sort of, but again only on open terms (e.g. subterms of RHS's of equations).
17:37:05 <roboguy_> of course the important question (or at least, a important question) is why do you need runtime access to type information, NeatBasis? This is pretty much the first I've heard of this in Haskell, so I'm kind of curious actually
17:37:07 <dmwit> Not sure I 100% believe this.
17:37:08 <ski> dmwit : more like `exists n. Nat n *> n'
17:37:39 <shachaf> *>++
17:37:51 <ski> though just `n' for a free (statically unknown) `n' about which it is statically known that `Nat n' is also right
17:39:00 <ski> (you need to "unpack" `exists n. Nat n *> n' to such a free `n', even if only implicitl, to be able to say `value n')
17:44:45 <NeatBasis> roboguy_: Debugging newbie code
17:44:46 <NeatBasis> btw: what's this about? "Type of kind * used as a constraint" -- I'm trying something like this: create_account :: (PersistStore m, PersistMonadBackend backend0) => String -> m (Maybe (AccountGeneric backend0))
17:44:46 <shachaf> A constraint is generally something on the left side of =>
17:44:47 <NeatBasis> Pain in the ass trying to google a sentence with an asterisk in it
17:44:47 <shachaf> Try Hoogle instead!
17:44:47 <shachaf> A type of kind * is generally a thing on the right side of =>
17:45:16 <NeatBasis> I think I just broke Hoogle
17:46:13 <NeatBasis> Hoogle says Parse error
17:46:34 <shachaf> Hmm, sounds like Hoogle is behaving correctly.
17:46:52 <ski> (shachaf : .. or on the right side of the `::' in a type signature or type ascription)
17:47:00 <shachaf> Try typing *, if you want to figure out what * means.
17:47:21 <shachaf> ski: I'll say that "a :: b" means "a has type () => b". :-)
17:47:29 <ski> (:
17:48:50 <ski> @kind Eq a => [a]
17:48:50 <lambdabot> *
17:48:55 <Gracenotes> is an empty assumption list syntactically valid?
17:49:03 <ski> @kind () => ()
17:49:03 <lambdabot> *
17:49:11 <cidevant> @kind 0 => 0
17:49:12 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 0
17:49:17 <shachaf> @kind (Functor f) => f
17:49:17 <lambdabot> *
17:49:20 <danharaj> seems legit
17:49:20 <shachaf> ?
17:49:23 <monochrom> > let { f :: () => Int; f = 5 } in f
17:49:24 <lambdabot>   5
17:49:30 <monochrom> seems accepted :)
17:49:44 <Gracenotes> shachaf: ...that is weird...
17:49:48 <ski> cidevant : yesterday you started to ask a question about a `getEntryR' function, but you didn't finish
17:49:53 <danharaj> That might be a ghc only thing.
17:49:59 <shachaf> I think it is a bug, fixed in HEAD.
17:50:01 <shachaf> :t let foo :: (Functor f => f) -> Int; foo _ = 5
17:50:01 <lambdabot> <no location info>:
17:50:01 <lambdabot>     not an expression: `let foo :: (Functor f => f) -> Int; foo _ = 5'
17:50:05 <shachaf> :t let foo :: (Functor f => f) -> Int; foo _ = 5 in foo
17:50:06 <lambdabot>     Expecting one more argument to `f'
17:50:06 <lambdabot>     In the type signature for `foo': foo :: (Functor f => f) -> Int
17:50:06 <lambdabot>     In the expression:
17:50:26 <shachaf> :t let foo :: (Functor f => f) a; foo = undefined in foo
17:50:26 <lambdabot>     Illegal polymorphic or qualified type: Functor f => f
17:50:26 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
17:50:26 <lambdabot>     In the type signature for `foo': foo :: (Functor f => f) a
17:52:23 <et09> survey - in professional environments, do you guys do pair programming
17:52:23 <shachaf> There's a way to get a panic, anyway.
17:52:23 <cidevant> plz help me guys
17:52:23 <cidevant> http://lpaste.net/90861
17:52:25 <et09> i guess maybe it matters less in haskel
17:53:03 <danharaj> Some Haskell shops do pair programming
17:53:06 <Gracenotes> pair programming, if it happens, should be done only in the case of two people at similar skill levels and on the same page figuring out how to code something.
17:53:31 <Gracenotes> Not as a means of tutoring or apprenticeship (if so, call it that)
17:53:34 <cidevant> We practice haskell pair programming in our company ))
17:54:12 <monochrom> I use product type programming :)
17:54:26 <Gracenotes> I've seen it happen organically for complicated systems, without pair programming being prescribed by any management-type-things.
17:55:07 <cidevant> And you are right.. We practice it, if something fucked up )
17:55:25 <Gracenotes> everyone knows you can simulate product programming using recursive pair programming
17:55:41 <shachaf> Gracenotes: Only for finite products, I think.
17:56:03 <NeatBasis> I'm totally lost with this. I've been banding my head for 3 hours now. How can I get this function to work: http://pastebin.com/96gQKYwR
17:56:07 <danharaj> cidevant: (>>=) or fmap is how you extend a monadic value
17:56:11 <mauke> The paste 96gQKYwR has been copied to http://lpaste.net/90862
17:56:44 <shachaf> NeatBasis: That looks like Yesod.
17:56:56 <shachaf> @where yesod might know more than we do.
17:56:56 <lambdabot> #yesod - http://yesodweb.com/
17:56:58 <NeatBasis> Clearly I'm doing something I'm not supposed to do, but I have no idea what.
17:57:12 <NeatBasis> I'm using the Persist library from yesod
17:57:12 <ski> cidevant : by using `myVal <- get404 myKey', assuming `t (HandlerT site IO)' is a monad; by using `entities <- selectList filters selectopts', assuming `m' is a monad
17:57:39 <cidevant> shachaf: Yes..  But nobody answers there..
17:57:49 <cidevant> ski: solution ?
17:58:20 <cidevant> ski: I think, I should do something like this
17:58:20 <shachaf> Oh, this is pretty weird.
17:58:21 <cidevant> http://stackoverflow.com/a/9389550/2199202
17:58:25 <shachaf> GHC is mixing up constraints and values.
17:59:01 <Gracenotes> shachaf: HEAD?
17:59:06 <shachaf> No, 7.6
17:59:10 <Gracenotes> is this to do with :k Functor ?
17:59:10 <shachaf> I suspect this is fixed in HEAD.
17:59:15 <Gracenotes> and its ilk
17:59:16 <shachaf> :t let foo :: (Char ~ Char => Applicative f, Applicative f) => f Char; foo = undefined in foo
17:59:17 <lambdabot>     Illegal polymorphic or qualified type: Char ~ Char => Applicative f
17:59:17 <lambdabot>     Perhaps you intended to use -XRankNTypes or -XRank2Types
17:59:17 <lambdabot>     In the type signature for `foo':
17:59:24 <shachaf> elliott: Can you turn the good extensions on?
17:59:40 <shachaf> GHC gives foo the type: Applicative f => (Char ~ Char => Applicative f) -> f Char
17:59:47 <shachaf> Good type, right?
18:00:01 <elliott> shachaf: I'll do it if you add Trustworthy pragmas to lens :p
18:00:05 <ski> cidevant : i don't know about Yesod
18:00:13 <danharaj>  What does that type mean.
18:00:31 <joelteon> but Char always ~ Char
18:00:59 <shachaf> When is a Char not a Char?
18:01:17 <ski> shachaf : hm, stuff like `(forall a. Show a => Show (f a)) => ..f..' could potentially be useful
18:01:19 <monochrom> when a C char meets a Haskell Char
18:01:20 <Gracenotes> ..as the old koan goes
18:01:33 <Gracenotes> It has to be on a winding mountain road
18:01:37 <ski> in which case the consequent in `=>' wouldn't need to have kind `*'
18:01:50 <copumpkin> shachaf: the invalid entries in it!
18:02:09 <ski> (though arguably this is an (ad-hoc) overloading of `=>' (like it is overloaded in `instance' declarations))
18:02:13 <shachaf> λ> :t let foo :: (Char ~ Char => Applicative f) => Applicative f; foo = undefined in id `asTypeOf` foo
18:02:24 <shachaf> Er.
18:02:28 <shachaf> λ> :t let foo :: (Char ~ Char => Applicative f) => a; foo = undefined in id `asTypeOf` foo
18:02:32 <shachaf>      (Char ~ Char => Applicative f) -> Char ~ Char => Applicative f
18:02:55 <Gracenotes> :o?
18:03:12 <shachaf> I want to figure out how to create an Applicative f value.
18:03:32 <shachaf> elliott: I bet you could use a bug like this to create a super-fast version of reflection! With inlining and everything!
18:04:36 <elliott> wait, what bug
18:04:49 <elliott> huh, that's some bug.
18:05:15 <shachaf> I can't see a way to create a value :: Applicative f, though.
18:05:45 <ski> a non-bottom value ?
18:05:50 <shachaf> Yes.
18:05:55 <shachaf> I want the real Applicative dictionary.
18:07:02 <dmwit> I'm not sure I would conclude that such a value was actually an Applicative dictionary. =P
18:08:36 <danharaj> I thought reflection was already optimal via unsafeCoerce.
18:08:39 <shachaf> dmwit: It looks like it is.
18:08:56 <shachaf> (Based on the Core. But I don't really know.)
18:09:15 <shachaf> danharaj: No, it has to rely on a lot of NOINLINE so all the dispatching etc. happens at runtime.
18:09:21 <shachaf> Imagine it could inline dictionaries!
18:09:28 <danharaj> That'd be pretty great.
18:09:48 <danharaj> It would kind of call into question the semantics of system FC though since it would be accidental :P
18:12:00 <cidevant> ski: cidevant : by using `myVal <- get404 myKey', assuming `t (HandlerT site IO)' is a monad; by using `entities <- selectList filters selectopts', assuming `m' is a monad
18:12:12 <cidevant> should I use monad transformer?
18:12:59 <elliott> shachaf: do we actually need NOINLINE?
18:13:24 <shachaf> elliott: ...Not sure.
18:13:36 <shachaf> I would guess so, but who knows.
18:13:48 <shachaf> GHC would certainly have a license to go crazy without it.
18:14:00 <elliott> I already have that license.
18:15:13 <shachaf> HEAD requires the thing on the right side of => to be a type.
18:15:27 <ski> cidevant : `t' looks like it might reasonably be a monad transformer there, yes
18:16:22 <shachaf> elliott: I'd imagine that GHC might be able to eliminate dictionaries and so on in some cases without the NOINLINE, but I don't really know.
18:16:32 <cidevant> thank you! I hope you put on right path =) Going to dig info =)
18:16:46 <bennofs>  /url
18:17:23 <elliott> shachaf: sure.
18:19:23 <shachaf> Expected a constraint, but ‛Char ~ Char => Applicative Identity’ has kind ‛*’
18:19:23 <shachaf> Expected a type, but ‛Applicative Identity’ has kind ‛Constraint’
18:20:30 <hpc> what would (constraint => constraint) even mean?
18:21:07 <shachaf> Who cares?
18:21:20 <hpc> haha
18:21:32 <dolio> :k Int => Int
18:21:32 <lambdabot> *
18:22:03 <pentace> What is the Char ~ Char good for?
18:22:16 <shachaf> Absolutely nothing.
18:22:25 <pentace> ;)
18:22:34 <shachaf> Hmm, clearly GHC should just properly unify => and ->
18:22:38 <monochrom> char is good for barbeque
18:22:50 <shachaf> With arguments being implicit if their kind is Constraint.
18:23:14 <shachaf> > let foo :: Int => Int; foo x = 5*x in foo 5
18:23:14 <lambdabot>   25
18:24:10 <dolio> That sounds like a recipe for fun code.
18:24:15 <Gracenotes> that seems wrong somehow
18:24:22 <roboguy_> wow that's weird
18:24:37 <dolio> It's fixed in HEAD.
18:24:42 <dolio> I think.
18:24:52 <chrisdone> speaking of getting hold of dictionaries, existentials spring to mind? data Dict = forall a. Show a => Dict (Proxy a), let intDict = Dict (Proxy :: Proxy Int) … intDict now contains the Show dictionary for Int, i guess. /me missing context, so probably misfiring
18:24:53 <danharaj> Instead it'd be cool if you could use => for implicit parameters that aren't constraintly kinded.
18:24:53 <shachaf> dolio: "broken" in HEAD, you mean?
18:25:09 <dolio> No, I don't think that's what I mean.
18:25:14 <shachaf> chrisdone: Yes, and with ConstraintKinds you can do even better.
18:25:16 <roboguy_> kind of makes me want to look at the ghc source. I've heard it's actually (relatively) easy to read
18:25:24 <shachaf> dolio: Clearly the current behavior is correct.
18:25:26 <chrisdone> shachaf: ah, really? /me reads more scrollback
18:25:39 <shachaf> GHC should optimize for fun, not semantics.
18:25:53 <danharaj> funantics
18:26:01 <dolio> Optimize for people doing type inference in their head.
18:27:09 <shachaf> chrisdone: As in data Dict k = k => Dict
18:28:10 <ski> hpc : consider `instance Show a => Show (T a)' or `instance (forall a. Show a => Show (f a)) => Show (U f)'
18:29:03 <elliott> shachaf: you could make "instance" just give values for => arguments!
18:29:20 <elliott> instance Int = 123
18:29:46 <dolio> Obviously the correct choice.
18:30:00 <danharaj> Seems pretty solid.
18:30:15 <elliott> foo :: Applicative Blah; foo where { pure = ...; ... }
18:30:20 <danharaj> What is a categorical model for classes and instances anyway?
18:30:27 <elliott> so elegant.
18:31:43 <bennofs> Hmm that reminds me of a compile error I had, where I replaced -> by => and it still worked on GHC 7.6, but failed on 7.4
18:32:07 <acowley> what the heck is going on here?
18:32:19 <acowley> > let foo :: Int => Int; foo x = 5*x in foo 5
18:32:19 <lambdabot>   25
18:32:26 <dolio> Int => Int is a 7.6.3 only bug.
18:32:31 <acowley> oh goodness, I'm glad it's Friday
18:32:32 <dolio> No idea what it's doing.
18:32:43 <roboguy_> acowley: I guess ghc 7.6.3 is confusing constraints and types somehow
18:33:06 <dolio> Not really. It's very specific.
18:33:09 <dolio> :k a => a
18:33:10 <lambdabot>     Illegal constraint: a (Use -XConstraintKinds to permit this)
18:33:10 <lambdabot>     In a type in a GHCi command: a => a
18:33:17 <acowley> Yeah, but then can you compute with a dictionary, too?
18:33:21 <bennofs> Yes, that was the bug I had too  I think
18:33:26 <dolio> Well, that doesn't work, even if you turn on ConstraintKinds.
18:33:40 <dolio> Because it says Constraint and * are different.
18:33:51 <roboguy_> dolio: what is it specific to?
18:34:10 <slack1256> On pipes 4.0.0, in the internal module there is declaration
18:34:14 <slack1256> data X = X X
18:34:28 <slack1256> and this is accepted by ghci, does that even make sense?
18:34:30 <dolio> So, if you have a variable that must have both kind * and kind Constraint, it's not happy. But if you use a concrete type of kind * as a constraint, it accepts it.
18:34:37 <acowley> > let foo :: Category c => c; foo c = c <> c in foo undefined
18:34:37 <lambdabot>   Expecting two more arguments to `c'
18:34:39 <dolio> You can't use a constraint in a kind * position, either, I think.
18:34:40 <acowley> I ran out of steam
18:35:15 <dolio> Oh, actually, it is okay with that....
18:35:16 <acowley> So this is definitely fixed?
18:35:19 <dolio> :k Int => Show Int
18:35:20 <lambdabot> *
18:35:25 <dolio> Yeah, I'm pretty sure.
18:35:30 <acowley> Or should we spend time finding "awesome" new ways to write things?
18:35:37 <bennofs> But :D
18:35:46 <shachaf> dolio: Yes, that's the bug I was just fiddling with earlier.
18:36:02 <dolio> Ah.
18:36:31 <shachaf> Though I didn't realize you could have something of kind * on the left of the =>
18:36:37 <monochrom> slack1256: consider instead "data My = Ctor My". do you see what it says?
18:37:05 <shachaf> :t let foo :: (Int => Show Int) => a; foo = undefined in id `asTypeOf` foo
18:37:06 <lambdabot> (Int -> Show Int) -> Int -> Show Int
18:37:35 <dolio> roboguy_: So, it seems more like it's generating too-general kinds for concrete types, or simply doesn't care about their kinds.
18:37:53 <dolio> :k Int
18:37:53 <lambdabot> *
18:37:58 <dolio> Even though that still works.
18:38:01 <roboguy_> :t let foo :: Int => Char; foo x = 'a' in foo
18:38:02 <lambdabot> Int -> Char
18:38:04 <roboguy_> huh
18:38:18 <slack1256> I would expand the definition? so the only valid type (at least to me) is "Ctor (Ctor (Ctor ....)))
18:38:31 <ski> dolio : shachaf said you had some idea of `newtype' existentials not being allowed due to `newtype' matching being irrefutable ..
18:38:52 <ski> <shachaf> <dolio> If you write a type Vec a n of length indexed vectors... <dolio> And then you write 'newtype List a = forall n. L (Vec a n)'. <dolio> Then you can write infinite lists using that type, as long as you can irrefutably match. <dolio> But, such values of List a contain a value that is not well typed by Vec a n for any finite n.
18:39:09 <dolio> Yes.
18:39:09 <ski> dolio : just wondered whether you had any further comment or elaboration on that
18:39:54 <dolio> I think it's unfortunate that that is the case. :)
18:40:06 <monochrom> no, "Ctor (Ctor (...))" is a value, not a type.
18:40:35 <slack1256> Oh, Ok
18:41:03 <monochrom> but you accept that "data My = Ctor My" is allowed?
18:41:12 <slack1256> it has type My
18:41:13 <slack1256> yes
18:41:22 <monochrom> now just rename Ctor to My
18:41:31 <slack1256> I accept that
18:41:42 <monochrom> that's your data X = X X
18:41:45 <slack1256> Mmm OK. I see it now
18:41:55 <shachaf> data OhMy = My OhMy
18:42:08 <slack1256> yes. one X is a constructor and the another is a Type
18:42:18 <slack1256> type-constructor
18:42:23 <slack1256> My My
18:42:30 <slack1256> I feel like an old lady...
18:43:27 <ski> `foo :: exists s. Show s *> (Equal s (Maybe s),s); foo = let y@<s,(_,x)> = <Maybe s,(Refl,Just x)> in y' might be a sketch of a similar "unfounded existential type variable" which doesn't really exist
18:43:36 <slack1256> thanks monochrom.
18:43:52 <monochrom> you're welcome
18:44:00 <dolio> ski: Well, that's a differrent story.
18:44:08 <elliott> ski: do you need the Show s there?
18:44:18 <ski>   My :: OmHy -> OhMy
18:44:53 <ski> elliott : mostly just to show that one could `show' the last component (`x')
18:44:57 <dolio> That one has to be data, because constraints on the existentially quantified variables turn into dictionaries that have to be packed into the data representation.
18:45:16 <dolio> And the reason to not allow irrefutable matching on it is that dictionary evaluation is strict.
18:45:22 <ski> (you could remove either the `Show s' part or the `Equal s (Maybe s)' part, if you wish)
18:45:34 <geekosaur> data Oh = My Stars Garters -- :p
18:46:07 <dolio> ski: But, at one point, I thought you could have irrefutable matches as long as there were no constraints on the existentially quantified variables.
18:46:24 <ski> dolio : hm, in your case `n' was an infinite type, while in my case `s' was a cyclic type (`s = Maybe s'), no ?
18:46:27 <dolio> And so you could have newtypes with existentials as long as there were no constraints.
18:46:39 <ski> hm
18:46:56 <byorgey> reminds me of  data So :: Bool -> * where Oh :: So True
18:47:16 <dolio> But, there is a reason to disallow irrefutable matches even without constraints. Because it is enforcing that you don't construct a value that would have an infinite type.
18:47:26 <dolio> And there's otherwise no way to catch it, I think.
18:47:35 <ski> dolio : oh, right. i didn't think of no constraint on the `newtype' being relevant, just skip the `Show s *>' part in my example then
18:49:38 <dolio> ski: Basically, 'newtype List a = forall n. List (Vec a n)' has elements that aren't typeable by any particular Vec a n.
18:50:16 <dolio> Unless you rule out 'ones = case ones of List wons -> List (cons 1 wons)' somehow.
18:50:47 <dolio> Forcing it to be data makes that definition just bottom.
18:51:01 <dolio> data without irrefutable matching.
18:51:09 <dolio> Which is in every Vec a n.
18:52:33 <ski> hm
18:53:49 * hackagebot helm 0.2.0 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.2.0 (ZackCorr)
18:57:08 <dolio> ski: I don't know what you would do with your s ~ Maybe s example, but it does look like it'd work.
18:59:20 <dolio> I guess it means that 'exists s. (Equal s (Maybe s), Maybe s)' is observably the extended natural numbers.
19:02:14 <elliott> hmm, univalence gives you Nat = Maybe Nat.
19:02:54 <dolio> Propositionally.
19:03:09 <elliott> yes.
19:04:51 <dolio> I guess this is, too.
19:06:26 <dolio> Anyhow, the point wasn't that you could defeat the type system some way if you allowed irrefutable matches on existential types.
19:07:00 <dolio> It was that not having the irrefutable match enforced that the semantics were correct in a sense that can't (I think) be caught otherwise.
19:08:01 <Gracenotes> That's a shame; means that common Java practices aren't easily transferrable to Haskell.
19:08:28 <dolio> It does?
19:08:44 <CaptainK> good
19:09:11 <ski> dolio : hm, i'm not sure
19:09:34 <ski> i suppose it doesn't really say much about `newtype' existential
19:10:40 <Gracenotes> with Foo extends Bar, Bar y: Foo x = (Foo) y.
19:11:56 <dolio> ski: I don't know how you're going to enforce this for newtypes, other than using seq.
19:14:08 <ski> dolio : ok
19:14:58 <ski> hm
19:15:40 <ski> i suppose one could think of "has elements that aren't typeable by any particular Vec a n" as a kind of "failure of an existence property" (as in existence and disjunction property for intuitionistic logic)
19:15:50 <dolio> Right.
19:17:16 <dolio> There is no type s such that 'inf = Just inf' is well typed with type 'Maybe s'.
19:18:15 <dolio> So it seems like we shouldn't say that the type 'there _exists_ an s such that ...' admits that definition.
19:19:34 <dolio> Unless you add a first-class μ or something.
19:27:55 <heatsink> Wouldn't that be an uninhabited type?
19:28:37 <heatsink> Ah, I missed the n't
20:51:34 <prophile> are there any good theorem provers for first-order intuitionistic logic?
20:53:12 <heatsink> Like djinn?
20:53:24 <heatsink> I think one of Coq's tactics does that too
20:53:50 <prophile> djinn is great, but it's only effectively propositional intuitionistic logic
20:54:40 <prophile> I find myself in need of existential quantification :<
20:54:43 <tac> @djinn a -> a -> a -> a
20:54:44 <lambdabot> f _ _ a = a
20:55:45 <heatsink> Formulas with existentials are undecidable iirc
20:56:56 <heatsink> Here's Coq's FOL tactic http://coq.inria.fr/distrib/current/refman/Reference-Manual010.html#hevea_tactic150
21:00:54 <ezrios> out of curiosity, what is the usual academic progression to category theory?
21:01:20 <tij> map (-1) [1, 2, 3]
21:01:29 <tij> > map (-1) [1, 2, 3]
21:01:29 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
21:01:30 <lambdabot>    arising f...
21:01:31 <ezrios> as a sequence of subjects/fields to study
21:01:33 <shachaf> tij: (-1) is a number.
21:01:44 <shachaf> Try (subtract 1).
21:01:46 <heatsink> Learn Haskell.  Try to understand what "fmap" means.
21:01:59 * heatsink still barely understands any category theory
21:02:13 <tij> :shachaf: ah thanks
21:02:18 <ezrios> I have some understanding with fmap, at least with regards to lists
21:02:23 <tac> > fmap (+1) (Just 41)
21:02:24 <lambdabot>   Just 42
21:02:26 <ezrios> I used those extensively when I studied Racket/Lisp
21:02:30 <tac> > fmap (+1) [1,2,3]
21:02:31 <lambdabot>   [2,3,4]
21:02:48 <tac> > fmap (+1) (2, 3)
21:02:49 <lambdabot>   (2,4)
21:04:01 <shachaf> heatsink: Hmm, then why would you tell other people the best way to learn it? :-)
21:04:37 <caryatid> hello all, question about qualified imports with operators in the modules: `import qualified Applicative as A hiding ((<*>))` b/c I've my own <*>. but I still get "Ambiguous occurance ... either Main.<*> or ... Control.Applicative.<*>"
21:04:55 <tac> ezrios: Usually category theory is something you learn by osmossis if you're doing topology or algebra in mathematics.
21:05:00 <shachaf> caryatid: I say you have an unqualified import that imports it.
21:05:01 <tac> There's rarely ever a "category theory" class
21:05:22 <ezrios> tac: I see. Abstract algebra?
21:05:32 <tac> Thus, every book on either subject either has a short chapter of category theory at the beginning or an appendix at the end
21:05:39 <shachaf> caryatid: A qualified import doesn't generally need "hiding".
21:05:41 <tac> yes. That is the only kind of algebra you study after high school
21:05:53 <ezrios> tac: would that be approachable for someone with Calc I/II and Linalg?
21:05:55 <tac> (so we call it by the shorter name)
21:06:00 <caryatid> shachaf: doh!  I did have a full import of control.applicative at the top of the file... just didn't see it
21:06:04 <ezrios> I have a copy of dummit & foote lying about
21:06:09 <tac> Which one? category theory? or algebra?
21:06:13 <ezrios> algebra.
21:06:40 <tac> Ah. Algebra is a broad broad area. Learning the basics about groups and rings is definitely doable, even without calculus.
21:07:03 <heatsink> Generally speaking, learning about a category is only useful after you've learned several concrete examples of the category.
21:07:17 <ezrios> heatsink: I have noticed that, especially with monads
21:07:30 <tac> esp if you've done linear algebra (which is the study of vectorspaces, which are what happens when you take a ring and jam an abelian group into its torso)
21:07:31 <ezrios> they can be exceedingly abstract I wonder what they hell they can even be used for
21:07:54 <tac> There's lots of concrete examples of monads everyone knows though
21:07:57 <ezrios> tac: maybe I will take a look at Dummit & Foote, I have been meaning to this summer.
21:08:05 <ezrios> for sure - IO and []
21:08:20 <tac> IO is weird because it's abstract. But for sure, lists, and Maybe, too
21:08:20 <ezrios> I was shocked to learn that XMonad is... a monad
21:08:27 <monochrom> hehe
21:08:42 <caryatid> shachaf: if I may follow a silly question with perhaps another [ sorry new to haskell ]... I cannot seem to do `:t A.<*>` in ghci, but can do `A.Const` etc after :l my file.
21:08:46 <tac> ezrios: there's always ##math and ##categorytheory if you need any algebra help
21:08:51 <ezrios> actually I'm not sure if that statement is correct.
21:08:58 <ezrios> tac: I used to frequent ##math
21:08:59 <shachaf> caryatid: Maybe that's because you wrote "hiding ((<*>))".
21:09:04 <shachaf> caryatid: See 21:05 <shachaf> caryatid: A qualified import doesn't generally need "hiding".
21:09:10 <ezrios> then I forgot to pay bills for my VPS
21:09:17 <ezrios> and my IRC bouncer got cut off ;_;
21:09:20 <caryatid> shachaf: got rid of the hiding bit
21:09:29 <caryatid> .. maybe I should restart ghci ...
21:09:35 <shachaf> caryatid: Oh, then it's because you wrote ":t A.<*>"
21:09:54 <shachaf> caryatid: You should give the error when you do things like that. :-)
21:10:01 <shachaf> And read the error. This is a parse error.
21:10:13 <shachaf> The problem with ":t A.<*>" is the same as the problem with ":t <*>".
21:10:44 <caryatid> it is a parse error ...  ghci isn't cool with operators after a dot on ghci commands ?
21:11:00 <tac> ezrios: But yeah. Once you are familiar with groups and rings, basic category theory gets a lot easier.
21:11:07 <shachaf> caryatid: :t gets an expression. A.<*> isn't an expression.
21:11:09 <caryatid> couldn't do :t  A.(<*>) like i could :t (<*>)
21:11:19 <caryatid> shachaf: cool, thanks!
21:11:19 <monochrom> (A.<*>)
21:11:20 <shachaf> caryatid: Aha. The syntax is ":t (A.<*>)".
21:11:30 <caryatid> yep, just noticed that
21:11:48 <ezrios> tac: that's good to hear
21:11:54 <shachaf> By the way, shadowing <*> may not be a good idea.
21:12:02 <shachaf> It's a pretty important operator.
21:12:03 <ezrios> I'm looking for a fuller understanding of Haskell, it sounds insanely powerful
21:12:16 <ezrios> but it looks like I am not (yet?) smart enough to harness it all
21:12:34 <tac> It's only powerful because it makes the programmer wear a tighter straightjacket.
21:12:42 <tac> It's fun though :)
21:13:12 <caryatid> shachaf: yeah, learning typeclassopedia so made a `class MyApplicative` so I could create my own instances of MyApplicative and check that they behaved like the real ones
21:13:59 <caryatid> shachaf: but then that may not be the best way about it :)
21:14:16 <shachaf> The full power of the Haskell: http://www.youtube.com/watch?v=Ek3LMYJOYRc#t=67s
21:14:22 <shachaf> caryatid: Aha.
21:16:03 <monochrom> afterwards, be sure to destroy your github repo
21:40:00 <joelteon> god I wish hackage would index the yesod packages
21:44:46 <mikeplus64> joelteon: you can build the documentation locally if you put documentation: True in your cabal config
21:46:05 <joelteon> yeah, but I need searching
22:27:33 <stevejb> greetings - quick (newbie) question on importing repa. According to the tutorial I should import repa as `import qualified Data.Array.Repa as R`
22:27:53 <stevejb> however, how do I access repa's :. operator when I import it this way
22:28:00 <shachaf> R.:.
22:28:26 <shachaf> According to me you should learn a bit about Haskell's import system before following the tutorial. :-)
22:28:44 <stevejb> shachaf: that is probably a good idea. :-)
22:28:54 <shachaf> It'll surely make it much easier. But I don't know what level the tutorial is aimed at.
22:29:34 <stevejb> shachaf: I think that what ends up happening is if I do not import repa as qualified, I clobber some stuff in prelude
22:29:44 <stevejb> (like zipWith)
22:30:00 <shachaf> Yes.
22:30:07 <stevejb> so, I guess there is a tradeoff that I need to make between clobbering that stuff or having slightly more cumbersome syntax, right?
22:30:23 <shachaf> You can import both qualified and unqualified, e.g. import qualified Blah as B; import Blah ((:.), ...)
22:30:43 <shachaf> You can also hide things from Prelude if you want.
22:30:50 <shachaf> http://www.haskell.org/haskellwiki/Import covers it all, I think.
22:31:07 <stevejb> shachaf:  thank you for the reference. I really appreciate it.
22:31:18 <shachaf> Other than the qualified operator syntax, I suppose! Blah.+ infix, (Blah.+) prefix.
22:32:15 <shachaf> Someone should perhaps add that, or a link to a page that describes it.
22:33:20 <stevejb> I think that my approach for now will be to do all repa-related stuff as R. and just be extra verbose for now, and once I gain some experience I can figure out the right combination of qualified and unqualified imports
22:33:46 <shachaf> Sounds reasonable.
22:33:56 <shachaf> (I have never used repa.)
22:36:42 <zvrba> I tried this :t (+3) <*> (*100) and got an error about cannot being able to construct an infinite type ...
22:36:49 <stevejb> it seems quite useful so far. I am about 1 week into my first Haskell project.
22:37:01 <stevejb> anyway, thank you for the help
22:37:27 <zvrba> (I was trying to make sense of the applicative definition of <*> for functions)
22:38:51 <zenware> I've discovered the solution to P versus NP...
22:38:54 <zenware> No.
22:39:05 <zvrba> it says f <*> g = \x -> f x (g x) so I tried to figure out what types f and g should have...
22:39:49 <zvrba> so, why doesn't (+3) <*> (*100) "work"; by the given definition it should be a one-argument function?
22:40:09 <johnw> zvrba: expand the definition of <*>
22:41:19 <zvrba> yeah so I get \x -> (*3) x (*100)
22:41:33 <zvrba> hmm, but (*3) isn't a 2-argument function
22:41:54 <tac> @type (<*>)
22:41:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:42:52 <tac> zvrba: (+3) <*> is poorly typed, isn't it?
22:43:00 <tac> @type ((+3) <*>)
22:43:01 <lambdabot> Num (a -> b) => ((a -> b) -> a) -> (a -> b) -> b
22:43:06 <tac> or not, whatever
22:43:14 <tac> stupid weird functor instances....
22:43:19 <zvrba> :)
22:43:53 <tac> > fmap (+1) (+1) $ 0
22:43:54 <lambdabot>   2
22:44:00 <zvrba> @type (+3)
22:44:00 <lambdabot> Num a => a -> a
22:44:15 <tac> @type flip fmap (+1)
22:44:16 <lambdabot> Num a => (a -> b) -> a -> b
22:44:42 * hackagebot monoid-subclasses 0.3 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3 (MarioBlazevic)
22:45:24 <zvrba> the documentation for applicative says that it's less powerful than monad, but still that "instances can perform analysis of computations before they are executed, and thus produce shared optimizations"
22:45:33 <zvrba> any examples of this analysis?
22:45:51 <zvrba> LYAH gives only toy examples of Applicatives, I still can't quite grasp the point
22:46:12 <zvrba> except it being a weird way of doing fmap
22:46:38 <tac> I don't quite get why they are so useful either, but theoretically, they compose nicer than monads while getting you a few applications
22:47:21 <tac> they are more than fmap though. Fmap is just what you need to be a functor
22:47:57 <tac> http://blog.ezyang.com/2012/08/applicative-functors/
22:48:08 <tac> That page gives a set of nicer rules than the normal ones
22:48:14 <zvrba> ok
22:49:08 <zvrba> i guess i have to read the original paper
22:49:09 <zvrba> :p
22:49:17 <tac> That blogpost also links to the original paper
22:49:21 <zvrba> right
22:49:56 <zvrba> any suggestions on how to start practicing programming in haskell?
22:50:10 <tac> I'd start by writing programs :)
22:50:16 <zvrba> yeah, but like what?
22:50:24 <tac> What brought you to haskell to begin with?
22:50:56 <zvrba> i'd like to have a strongly-typed language suitable for fast prototyping of algorithms
22:51:22 <zvrba> concretely, I've been reading about topologies and discrete topologies and wanted to make some code to play with that
22:51:42 <tac> mathematical topologies? or the networking kind?
22:51:59 <zvrba> on the job I develop in C++, but that's unsuitable for fast prototyping, not the least because it lacks a REPL
22:52:03 <zvrba> mathematical topologies
22:52:05 <tac> oh neat
22:52:28 <tac> Break out Data.Vector and try coding up some algorithms you already know
22:53:02 <zvrba> mutable or immutable?
22:53:15 <tac> depends what you want to do with them
22:53:36 <tac> mutable if you're doing classic algorithms, though
22:53:40 <zvrba> mm
22:53:55 <zvrba> which means getting hands dirty with monads
22:54:17 <tac> If you're just doing IO, monads aren't bad at all
22:54:21 <zvrba> ok, I guess I'll approach the problem as I did when first learning C :P
22:54:39 <tac> You can cheat for a long time thinking of x <- doStuff as "running the command doStuff and storing the result in x"
22:54:53 <zvrba> I didn't understand pointers and I accepted & in scanf("%d", &x) as necessary part of the syntax to make it work.
22:55:01 <tac> ah yes
22:55:12 <zvrba> understanding came later when I dug under the hood and inspected assembly :P
22:55:18 <tac> the problem is you shouldn't learn C until you understand assembly >___>
22:55:22 <zvrba> :)
22:55:34 <zvrba> well, I did first understand assebly (6502 though)
22:55:41 <zvrba> nono
22:55:48 <zvrba> I don't want to cheat this tim
22:55:49 <zvrba> time
22:55:59 <zvrba> getLine is an (IO String)
22:56:03 <tac> yeah
22:56:08 <zvrba> it's a VALUE, not "action" as many like to say
22:56:14 <tac> right
22:56:20 <zvrba> action implies immediate execution, but that's kinda wrong
22:56:36 <copumpkin> not sure it does
22:56:43 <zvrba> well
22:56:47 <tac> you might think of getLine as an instruction, too
22:56:50 <zvrba> I already had a discussion about this
22:56:57 <tac> Instructions are things that will happen eventually, not necessarily right now
22:56:57 <zvrba> with edwardk , I think (on pvt)
22:57:01 <zvrba> tac: indeed.
22:57:16 <tac> You also have things like putStrLn :: String -> IO ()
22:57:30 <zvrba> esp IO "actions" are spoken about as something "active", but it's an ordinary passive value just like Int
22:57:53 <zvrba> it's the "evaluator" / "interpreter" that causes something to happen given the list of IO values
22:58:10 <zvrba> in this case, the runtime system, I guess
22:58:12 <shachaf> What is an active value?
22:58:13 <tac> yep. You have a division between evaluation and execution in Haskell which doesn't appear in too many other languages.
22:58:41 <tac> shachaf: He means that nothing changes when you evaluate it.
22:59:06 <tac> zvrba: It sounds like you understand enough. Don't let monads slow you down.
22:59:21 <zvrba> shachaf: getLine is often referred to as an "IO action" (not only getline, but everything inside IO)
22:59:23 <mauke> you don't need monads to understand IO
22:59:42 <tac> mauke: That is the point I think everyone in the room agrees on in this conversation :P
22:59:49 <zvrba> :)
23:00:20 <tac> Then >>= lets you pass a "continuation" of what to do after the action gets run
23:00:32 <tac> (same with >>, but it throws away the return value)
23:00:55 <shachaf> Here is an explanation I wrote on ways you might do IO: http://stackoverflow.com/a/13538351/712548
23:01:02 <tac> Even though >>= has a monad in its type signature, you can just think of it as IO-specific if that helps you Get Stuff Done ;)
23:01:14 <tac> @type (>>=)
23:01:14 <zvrba> shachaf: which is confusing, at least to me, because it evokes an association, to, say "printf" from C, which is decidedly NOT a value.
23:01:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:01:24 <tac> @type (>>=) :: IO a -> (a -> IO b) -> IO b
23:01:24 <lambdabot> IO a -> (a -> IO b) -> IO b
23:01:36 <zvrba> shachaf: i.e., I cannot "package" a list of printf statements into a data object to be executed eventually
23:01:44 <zvrba> (akin to JIT)
23:01:47 <mauke> C has no printf statements
23:02:01 <shachaf> You can do something equivalent, though.
23:02:09 <zvrba> mauke: right. it's a library function.
23:02:12 <mauke> and printf totally evaluates to something
23:02:12 <shachaf> You just need an interpreter.
23:02:18 <zvrba> yes.
23:02:20 <shachaf> C can express "IO actions" too.
23:02:38 * shachaf needs to go; back later.
23:02:43 <zvrba> a list of pointers to structures holding arguments to printf
23:02:49 <zvrba> very cumbersome, but possible, yes.
23:02:50 <mauke> a string
23:02:50 <zvrba> anyway.
23:03:03 <mauke> just append stuff, and system() it at the end
23:07:20 <tac> I kind of wish Haskell's stdlib had a stand-alone name for >>= and >> when they were specified to the IO type.
23:12:07 <johnw> why would it need to be in the stdlib?
23:12:13 <johnw> you can always use your own
23:13:06 <tac> johnw: So you can teach beginners how to use IO without having them see the word monad...
23:13:16 <tac> and without do notation, at first
23:13:27 <johnw> so make a beginners library?
23:14:16 <tac> That would only help the maybe half a person I teach Haskell to every year.
23:14:52 <tac> Then again, Haskell is kind of janky as an educational language overall.
23:25:01 <bitonic> tac: Haskell is not a janky educational language
23:27:02 <ChongLi> educational language?
23:27:09 <ChongLi> don't you mean academic language?
23:27:14 <ChongLi> which is still arguable
23:28:15 <tac> Haskell is not a good educational language, IMHO. (Academic, yes, it aces that role)
23:28:33 <haasn> tac: thoughts on Helium>
23:28:35 <haasn> ?*
23:28:35 <lambdabot> Maybe you meant: v @ ? .
23:28:38 <ChongLi> when I think "educational language" I think of stuff like Logo
23:28:52 <tac> haasn: never played with it.
23:29:33 <Nisstyre> ChongLi: or Scheme ;)
23:34:59 <shachaf> I think perhaps -dcore-lint should check the "constraint used with kind *" thing. Core distinguishes that, right?
23:38:34 <johnw> maybe #ghc would know?
23:41:30 <shachaf> #ghc is for GHC development. :-) Anyway, I didn't really expect an answer to the question.
23:41:56 <shachaf> I said that more because I'm too lazy to actually figure out sorts of conditions that this would catch and make a bug about it.
23:42:22 <johnw> ah.  I can't help at all with that one, sorry
23:43:13 <shachaf> Well, there are over a thousand people in this channel. Maybe one of them will care more than I do.
23:43:16 <shachaf> (Unlikely.)
