00:01:55 <tnks> well shit, I got lambdabot to eval, but I needed to be in the root directory of a source checkout.
00:02:01 <tnks> hardcoded paths, I guess.
00:22:51 <Ghoul_> hmm
00:23:33 <Ghoul_> I finished my file reader but once the data is in the trie the 80mb uses 1.7gb
00:23:58 <Ghoul_> I thought tries were supposed to prevent redundancy
00:24:29 <tnks> not having a cabal uninstall seems pretty sloppy.
00:26:50 <supki> I don't think I ever wanted cabal uninstall
00:27:05 <supki> but anyway I hear they accept patches :)
00:27:48 <tnks> I'm sure.
00:28:16 <arkeet> it doesn't sound that hard.
00:29:12 <tnks> I guess I have a reason.  I put ~/.cabal/bin on my PATH.
00:29:38 <tnks> so without an uninstall, I need to delete binaries out of there manually, if they conflict with others in other places.
00:33:21 <arkeet> I don't think anything keeps track of where binaries go.
00:33:58 <supki> cabal surely doesn't
00:34:05 <supki> (because ghc-pkg doesn't)
00:34:13 <arkeet> that's what I'm saying.
00:45:37 <kostja> hello!
00:45:53 <gry> hi
00:47:00 <kostja> is there a way to have two (or more) fingers on a list?
00:47:37 <mstksg> does anyone know where i can find the implementations of the base libraries
00:48:00 <kostja> mstksg: ghc
00:48:11 <Cale> kostja: What do you mean by fingers?
00:48:20 <kostja> Cale: zippers
00:48:22 <mauke> cursors
00:48:36 --- mode: ChanServ set +o edwardk
00:48:57 <Cale> Well, yes...
00:49:04 <ion> shachaf: I have a bit of hard time figuring out the conversion between Fix, Mu and Nu. Any hints to help me figure it out?
00:49:31 <kostja> Cale: so you have a clue?
00:50:09 <mauke> heh. Cale has lots of clues!
00:50:12 <kostja> Cale: in a procedural language I would work with references, I think
00:50:32 <kostja> so give me a hint, please
00:50:54 <Cale> kostja: The question is more one of exactly what sort of interface you'd like to have. At some point it might be simpler just to use a type of sequences which supports efficient concatenation/splitting.
00:52:00 <mauke> http://okmij.org/ftp/continuations/zipper.html#zipper2
00:52:16 <mauke> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8611
00:52:23 <mauke> I hear you can derive twice
00:52:26 <Cale> But just as you differentiate List a = 1 + a * List a to get  List' a = List a + a * List' a
00:52:34 <kostja> Cale: I'd like to have different views on the same text with independent cursors
00:52:40 <Cale> You can differentiate List' to get a type of lists with two holes.
00:53:48 <kostja> and if the number of "views" is not known at compile time?
00:54:48 <Cale> Well, I don't know a way to make this *terribly* practical if you don't know how many cursors you want. I'd rather just use a Data.Sequence at that point, and represent cursors by natural numbers.
00:55:23 <Cale> Data.Sequence is a structure which has log time concatenation and splitting, and constant time access to both ends.
00:56:34 <kostja> okay, so it would be the same approach, like in a procedural language, the you would use vector to have constant time indexed access
00:56:35 <Cale> I'm assuming that you're not really looking at the case of an infinite list with arbitrarily many cursors... I'm sure there's something you could do to work with that in a somewhat efficient way.
00:57:14 <Cale> Probably chopping the thing up into n finite initial segments, and then having the potentially infinite tail
00:57:40 <mauke> kostja: well, you could just use an array
00:58:01 <Cale> (you'd use Data.Sequences for the initial bits, because moving the cursors would require you to manipulate both ends of them)
00:58:14 <mr-> kostja: can't you just use a list of cursors?
00:58:14 <Cale> Yeah, you can also use an Array, obviously.
00:58:43 <kostja> the problem with the array, is, if one wants to insert text at the cursor positions
00:58:46 <Cale> mr-: That doesn't let you manipulate the sequence with one cursor, and have the changes reflected by the others
00:59:27 <mr-> Cale: true, your cursor-manipulations would need to work on the list. Is that bad?
00:59:52 <Cale> mr-: Well, the key is to do it without requiring any kind of mutation
01:00:36 <kostja> mr-: I'd also don't want to hold the data once for every cursor in memory
01:00:38 <mr-> I must have missed that requirement. Was that hidden in "I would use a pointer"? ;-)
01:00:44 <shachaf> ion: Hmm. Which functions are you trying to write?
01:00:53 <shachaf> ion: Some are easier than others.
01:01:02 <mr-> kostja: Ok
01:01:08 <mr-> that's fair
01:01:30 <shachaf> ion: mu2fix and fix2nu are easy.
01:02:29 --- mode: ChanServ set +o edwardk
01:02:59 <shachaf> edwardk: Somehow you accidentally got set to +O instead of +o.
01:03:03 <kostja> would be best to implement the cursor as an index and working on a sequence, like Cale suggested
01:03:08 <shachaf> edwardk: Which means ChanServ auto-ops you whenever you join.
01:03:20 <edwardk> interesting
01:03:59 --- mode: edwardk set -o edwardk
01:04:05 <ion> shachaf: Ok, i’ll look at those two first.
01:04:52 <shachaf> edwardk: You have to fix it with chanserv, I think.
01:05:00 <shachaf> ion: It might also help to understand what Mu and Nu "are", to some degree or another. :-)
01:05:20 <shachaf> Have you done anything with any of these types before?
01:06:01 <ion> shachaf: I was looking at mu2nu and nu2mu and the closest i got so far was something stupid like (r -> g r) -> (f r -> r) -> Mu f -> Nu g and even stupider like (forall r x . g x -> f r) -> Nu g -> Mu f.
01:06:05 <ion> shachaf: Nope, i haven’t.
01:06:34 <shachaf> Did you see kmc's article on Fix?
01:06:41 <shachaf> @google type-level fix and generic folds
01:06:42 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
01:06:42 <lambdabot> Title: main is usually a function: Type-level Fix and generic folds
01:07:04 <ion> shachaf: Hadn’t seen that one. Thanks, i’ll take a look.
01:08:06 -ChanServ(ChanServ@services.)- edwardk set flags -O on edwardk.
01:08:13 <shachaf> ion: But actually that article maybe isn't strictly necessary to figure them out.
01:08:32 <shachaf> ion: If I tell you that Mu Maybe is isomorphic to Nat, can you figure out how that works?
01:08:47 <shachaf> In particular write zero, succ, toInt for Mu Maybe (and then maybe for Nu Maybe).
01:08:58 <kostja> Cale: having a list of fingers, where every finger only holds the data to the right until the next finger. and the "actual" cursor would be a finger on this list
01:09:31 <ion> shachaf: Let me see…
01:09:41 <Cale> kostja: yes, that's possible
01:10:08 <Cale> kostja: Of course, it's not *quite* the same as just having a map from fingers to indices
01:10:14 <kostja> moving the cursor through the next would require to uncons a char from one finger and append it to the next
01:10:23 <Cale> yeah
01:11:42 <kostja> this should be cheaper than using indices to random access elements in a sequence
01:12:45 <shachaf> ion: (If you want I can clarify things more, maybe in #-overflow.)
01:13:03 <Cale> kostja: Maybe a little bit. I think the focus should probably be on the ease of constructing the interface you want though, until it's decided that you really need to do better performance-wise.
01:13:41 <ion> shachaf: Thanks. I’ll think about Mu/Nu Nats first.
01:13:59 <kostja> Cale: I really want to provide different views on the same text to a user
01:14:30 <kostja> that means different "windows" (or clipping regions)
01:15:17 <kostja> and every view should have its own cursor
01:21:05 <kostja> thank you, Cale, mauke and mr-
01:34:27 <Gracenotes> shachaf: linked from that blog post... I almost forgot about http://www.willamette.edu/~fruehr/haskell/evolution.html
01:39:12 <ion> shachaf: Ok, managed to write zero, succ, toInt for Mu Maybe. Let me see about Nu Maybe then.
01:41:09 <Gracenotes> congratulations, you are a PhD Haskell programmer
01:41:35 <Gracenotes> although maybe the bar has moved :p
01:42:12 <tnks> okay, so a .cabal has "ghc-options:         -O2 -Wall -Werror -optl-Wl"
01:42:50 <tnks> and when I try to build, I get "gcc: error: unrecognized command line option ‘-Wl’"
01:42:57 <Saizan> heh
01:43:05 <tnks> not sure what the best way to address this is.
01:44:13 <tnks> switches on the linker is kind of a tedious error.
01:44:20 <Saizan> the only way is to "cabal unpack $packagename" the package, edit that out, bump the version, and then "cabal install" (with no package argument) to install it from there
01:44:54 <shachaf> Gracenotes: What post?
01:45:24 <tnks> Saizan: that's really annoying.
01:48:17 <Gracenotes> shachaf: type-level fix
01:48:23 <shachaf> Oh.
01:49:34 <shachaf> Hmm, once in a while I used to look at that page and understand more than I did last time.
01:49:40 <tnks> Saizan: even sillier, -optl-Wl doesn't seem to be doing anything.  it just passes -Wl to gcc, which is expecting -Wl,someoption.
01:49:56 <shachaf> But I guess I understand all of it now?
01:49:57 <shachaf> Sad.
01:50:06 <tnks> but just -Wl isn't any option at all; it's just a no-op.
01:51:25 <Gracenotes> you should get a PhD in Haskell Studies
01:52:03 <Saizan> tnks: you should mail the maintainer about that, in a less abrasive way though
01:56:52 <tnks> Saizan: yeah, I was just thinking a simple patch is possible.
01:57:05 <danr> ion: what's your definition of Nu?
01:57:26 <tnks> but after all this. . . I got lambdabot working fine, with no complaints from any plugins.
01:57:30 <shachaf> danr: data Nu f = forall x. Nu x (x -> f x)
01:58:21 <tnks> also, I tried compiling the version in Darcs, but GCC was complaining about needing FlexibleInstances for a ton of plugins.
01:58:38 <tnks> the version in Cabal didn't have any such complaints.
01:59:28 <tnks> sorry, version in Hackage.
01:59:40 <tnks> ultimately, the Hackage release worked more swimmingly.
02:00:46 <tnks> oh yeah, not GCC complaining, GHC.
02:01:15 <Saizan> yeah, some packages remove some warnings related stuff when releasing, too
02:01:31 <Saizan> since it just makes the package brittle at that point
02:02:54 <tnks> Saizan: actually, it was more than a warning -- it stopped the build.
02:03:05 <supki> I don't think Darcs repo is relevant since all development seems to happen on github
02:03:18 <Saizan> tnks: still warnings-related
02:03:20 <tnks> oh, that's good to know.
02:03:27 <tnks> Saizan: yeah.
02:03:47 <Saizan> e.g. the one i've seen is removing -Werror
02:04:11 <tnks> even though I haven't been compiling my own Haskell, this has been kind of enlightening about what Haskell build headaches feel like.
02:04:44 <tnks> Saizan: where is -Werror typically specified?
02:05:04 <Saizan> in ghc-options, like in your case
02:05:23 <Ghoul_> haskell hash maps are so much faster than bytestring-tries
02:05:45 <Ghoul_> from 2.6us to 350ns
02:14:37 <tnks> okay, I think I found the Git repository for lambdabot.  It's split up into multiple sub-projects.
02:14:51 <tnks> is there a convenient way to build everything in one go?  https://github.com/mokus0/lambdabot
02:15:06 <tnks> or do I have to build everything one-at-a-time in order?
02:18:11 <Saizan> you might be able to just list the directories as arguments to cabal install
02:18:18 <Saizan> unless that only works for tarballs
02:18:49 <mstksg> can anyone help me implement the PrimMonad typeclass for the ST transformer STT?
02:19:00 <tnks> Saizan: I've been doing "runhaskell Setup" per some on-line docs.
02:19:12 <tnks> is there a way to use cabal instead to build from source?
02:19:18 <Saizan> sure
02:19:39 <Saizan> run "cabal install" in the directory where the .cabal file is
02:19:43 <tnks> by the way, thanks for answering these clearly-n00b questions.
02:20:35 <Saizan> cabal install --help has the basic examples at the end
02:21:28 <tnks> Saizan: I see this now. . . doesn't seem like it supports building multiple packages at once.
02:22:20 <tnks> well, I guess it does, but I can only have one current directory.
02:23:11 <Saizan> let me see if it handles multiple directories as arguments too
02:24:57 <tnks> well, I just cheated.  made a for-loop in shell.
02:26:19 <Saizan> should work here, but it's best to tell cabal more at once so the dependency solver makes the right choices
02:26:51 <tnks> Saizan: "should work here"?
02:26:52 <Saizan> afaict, "cabal install lambdabot*" from the repo directory should have worked
02:27:10 <tnks> Saizan: hmm, that didn't work for me.
02:27:19 <Saizan> tnks: the for-loop solution should be fine for your case, i meant
02:27:31 <tnks> yeah, that's a no brainer.
02:27:48 <tnks> although, I neglected error checking.
02:28:02 <tnks> so if one fails, it's just going to pass through.
02:28:09 <Saizan> tnks: cabal --version?
02:28:23 <tnks> 1.16.0.2
02:28:48 <tnks> It's just what Debian has.
02:29:19 <tnks> how far behind is it from what you guys use?
02:30:08 <Saizan> that's the latest release
02:30:34 <Saizan> it seems like it wants the / at the end of directory names, otherwise they are just interpreted as package names
02:30:50 <Saizan> (and lambdabot* doesn't expand to that)
02:30:51 <tnks> ah, that's sane.
02:30:59 <tnks> okay, good to know for next time.
02:31:15 <tnks> but Shell didn't fail me, and I now have the latested lambdabot working!
02:32:08 <Saizan> ("cabal install ./lambdabot*" works too)
02:32:22 <tnks> also good to know.
02:32:44 <tnks> I never really checked.
02:32:53 <tnks> does Haskell statically link?
02:33:50 <tnks> I think someone on my team mentioned that in passing, but it's hearsay to me.
02:34:12 <supki> GHC does
02:34:16 <supki> by default, that is
02:34:25 <tnks> supki: okay, but it supports dynamic linking too?
02:34:31 <supki> tnks: yes
02:34:38 <tnks> I kind of prefer static linking anyway.
02:34:46 <tnks> less of a pain in the ass for deployment.
02:34:50 <supki> sure
02:35:17 <tnks> has anyone ever suggested the idea of a binary repository for Hackage?
02:36:25 <tnks> maybe it's a horrible idea -- fraught with complexity and lost productivity.
02:37:34 <arcatan> the static linking would make that pretty hard, i guess
02:37:53 <Saizan> hackage links to distro's packages, some are binary
02:38:01 <tnks> Saizan: just found this:  lambdabot/scripts/ghci.sh
02:38:19 <tnks> echo "You must run this script from the root directory of lambdabot package.
02:40:59 <startling> can I give a fixity declaration to an operator defined in "let"?
02:41:45 <mauke> yes
02:42:04 <startling> how?
02:42:16 <shachaf> The same way you do it anywhere else.
02:42:49 <startling> humor me.
02:43:00 <mauke> what
02:43:10 <supki> > let infixl 0 ?; (?) :: a -> a; (?) = id in (0$0?)
02:43:11 <lambdabot>   The operator `?' [infixl 0] of a section
02:43:11 <lambdabot>      must have lower precedence th...
02:43:29 <startling> supki, thanks
03:02:49 <Taneb> tryhaskell has a paste service?
03:03:49 <arcatan> that's where hpaste lives nowadays
03:03:59 <Taneb> Oh, cool
03:09:57 <mauke>  No instance for (Num a0) arising from the literal `1'
03:09:59 <mauke> :-)
03:10:31 <shachaf> Hmm, I've seen that before.
03:10:43 <shachaf> I don't remember where.
03:11:37 <b_jonas> > 1 ++ ""
03:11:38 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:11:38 <lambdabot>    arising from the literal ...
03:11:44 <supki> > let a :: a; a = 1 in a
03:11:45 <lambdabot>   No instance for (GHC.Num.Num a1) arising from the literal `1'
03:11:45 <lambdabot>  Possible fix...
04:21:00 <alexander__b> hey, can someone make bindings to box2d for me? kthnx.
04:22:28 <dyn> I'm looking for some help
04:22:30 <dyn> (again..)
04:22:35 <dyn> http://blog.tmorris.net/posts/haskell-exercises-for-beginners/ <- I'd met this one
04:23:00 <dyn> and I've finished LYAH already but I feel my knowledge lacks a lot to even approach this one..
04:23:15 <dyn> anyone can suggest a learning path to bridge that gap and approach the beginner level? :)
04:27:14 <startling> dyn, what didn't you understand in that http://blog.tmorris.net/posts/haskell-exercises-for-beginners/ page?
04:28:36 <dyn> startling: I dont know what's :|
04:29:06 <startling> dyn, it's defined right there. Constructors can be infix.
04:29:28 <startling> data List t = Nil | (:|) l (List t)
04:29:55 <dyn> err.. where is it defined?
04:30:13 <startling> data List t = Nil | t :| List t deriving Eq
04:30:31 <dyn> that defines ":|" ?
04:30:52 <dyn> it says a List algebraic data type is a Nil or .. which can be compared via equal
04:30:56 <dyn> to my best understanding
04:31:01 <dyn> but I'm missing the middle :)
04:31:09 <elliott> it's equivalent to Cons t (List t)
04:31:12 <elliott> but with an infix constructor
04:31:19 <elliott> instead of (Cons 123 Nil) you say (123 :| Nil)
04:31:29 <startling> dyn, does it make more sense if you say "data List t = Nil | Cons t (List t) deriving Eq ?
04:31:44 <osa1> it's weird, I'm profiling my program with built-in profiling options, and it looks like removing INLINE directives makes my program run in fewer ticks ... what's could be the reason behind this?
04:31:59 <dyn> Cons is :, right?
04:32:08 <elliott> dyn: it's defining its own list type.
04:32:27 <elliott> just like data MyList a = Empty | More a (MyList a).
04:32:46 <startling> osa1, perhaps inlining isn't the magical optimization everyone thinks it is
04:33:01 <dyn> elliott: I understand a recursive type definition
04:33:16 <dyn> I only stumbled on the :|
04:33:28 <elliott> right. so it's just like that, but instead of More you use infix :|
04:33:37 <startling> dyn, well, do you understand it now?
04:33:42 <dyn> and it's infix because it starts with a colon, right?
04:33:45 <elliott> yes
04:33:49 <dyn> startling: getting there :)
04:34:11 <dyn> ok, I got that line
04:34:14 <osa1> startling: probably .. but I'm having trouble understanding how can inlining makes program run slower ..
04:34:20 <dyn> how about infixr 5 :| ?
04:34:28 <elliott> that says it's right-associative at precedence 5
04:34:38 <elliott> so e.g. (a :| b :| c) is (a :| (b :| c))
04:34:40 <startling> does inlining prevent sharing?
04:34:54 <dyn> elliott: I assumed infixr is a function definition :(
04:35:20 <dyn> but now that you say it's precedence, it's ok then
04:35:21 <startling> dyn, it's more like an instruction to GHC as to how to parse
04:35:44 <dyn> startling: yup, now I slightly remember even LYAH showed that in some chapter
04:35:46 <osa1> startling: do you mean GHC automatically memoizes shared function calls?
04:36:00 <startling> osa1, "sometimes"
04:36:46 <zRecursive> elliott: how many precedence are there ?
04:37:38 <elliott> 0-9
04:37:41 <elliott> or maybe 1-9
04:38:01 <dyn> instance (Show t) => Show (List t) where show = show . foldRight (:) []       -- I only saw examples where the word after where is actually used before the where expression
04:38:02 <zRecursive> 9 has lowest precedence ?
04:38:48 <zRecursive> s/has/is
04:38:50 <startling> dyn, you forgot how instances work
04:39:09 <zRecursive> elliott: i see now, thx
04:39:23 <dyn> ok, let me look up how to make a type class instance again
04:39:51 <zRecursive> i.e. ($) has lowest precedence
04:40:21 <Cale> zRecursive: that's correct
04:40:36 <Cale> It's 0-9
04:40:49 <zRecursive> Cale: thx
04:40:57 <Cale> and ($) has precedence 0
04:41:08 <Cale> (.) has precedence 9
04:41:37 <zRecursive> ok
04:41:49 <Cale> The rest probably aren't worth memorising :)
04:42:33 <Cale> More important than the precedence of any actual infix operator is probably the fact that function application binds more tightly than any infix symbol.
04:42:55 <zRecursive> ($) ... (.)   means dollars disappear, easy to keep it in mind :)
04:43:08 <dyn> heh
04:48:07 <dyn> thanks for your help!
05:01:22 <Eduard_Munteanu> Is there a name for   maybe (return ()) foo   where foo :: a -> m a?
05:02:16 <shachaf> traverse_?
05:02:17 <Eduard_Munteanu> I just want to do something if a Maybe-wrapped parameter isn't Nothing.
05:02:24 <elliott> Data.Foldable.forM_
05:02:32 <notdan> or mapM_?
05:02:38 <shachaf> Yes, one of those.
05:02:39 <elliott> or traverse_!
05:02:48 <elliott> or for_, if that exists.
05:02:51 <Eduard_Munteanu> Hm, so basically sequence-y stuff.
05:02:52 <shachaf> It does.
05:02:57 <startling> or (() <$) . traverse !
05:03:09 <Eduard_Munteanu> :t traverse_
05:03:09 <shachaf> Right. A Maybe is a list with at most one element.
05:03:10 <lambdabot>     Not in scope: `traverse_'
05:03:10 <lambdabot>     Perhaps you meant one of these:
05:03:10 <lambdabot>       `F.traverse_' (imported from Data.Foldable),
05:03:18 <Eduard_Munteanu> :t F.traverse_
05:03:18 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
05:03:26 <elliott> you probably want forM_.
05:03:29 <elliott> out of all of those.
05:03:54 <AryanKing> Is it just me, or has the lack of exercises in LYAH made it that much more difficult to internalize the information contained therein?
05:04:19 <startling> mapM_ is useful for >>=-style code
05:04:52 <startling> AryanKing: what a shitty username
05:05:24 <Eduard_Munteanu> AryanKing: depends on how one studies.
05:06:03 <AryanKing> It makes for a great conversation starter. And how so, Ed? I really struggled through it.
05:06:28 <Eduard_Munteanu> AryanKing: worked examples are fine IMO, but they make people just skim over them.
05:07:32 <AryanKing> That's the problem I had. The worked examples didn't really help me.
05:08:40 <bor0> can someone please explain how the bind operator works in this specific case: [3,4] >>= show
05:08:53 <AryanKing> It would be much better if the book has some exercises. I'm curious if anyone has any suggestion on where to find some exercises to do. I found Euler too advanced, having just starting out Haskell.
05:09:00 <Eduard_Munteanu> bor0: hint: show spews lists too
05:09:01 <startling> bor0, it doesn't.
05:09:05 <startling> oh
05:09:11 <startling> never mind, Eduard_Munteanu has it
05:09:18 <bor0> what do you mean by spew, technically? :)
05:09:34 <acube> Is there a package providing template haskell for deriving TypeableN instances?
05:09:36 <Eduard_Munteanu> bor0: has lists as the return type :)
05:10:00 <startling> acube, I think you just want {-# Language DeriveTypeable #-}
05:10:05 <acube> which would, for example, derive Typeable2 if I gave it a type of kind (* -> * -> *) -> * -> * -> *?
05:10:06 <Eduard_Munteanu> AryanKing: I wouldn't bother with Euler Project stuff
05:10:09 <notdan> :t show
05:10:10 <lambdabot> Show a => a -> String
05:10:13 <bor0> Eduard_Munteanu: why is show [3,4] different?
05:10:23 <acube> startling: Doesn't work with the kind I gave :|
05:10:29 <AryanKing> What would you recommend, Ed?
05:10:29 <notdan> :t show [3,4]
05:10:30 <lambdabot> String
05:10:38 <startling> acube, what'd you give it?
05:10:46 <bor0> > show [3,4]
05:10:48 <lambdabot>   "[3,4]"
05:10:53 <bor0> > [3,4] >>= show
05:10:54 <notdan> oh, yeah, String = [Char]
05:10:54 <lambdabot>   "34"
05:10:58 <notdan> it's the same list monad
05:11:18 <bor0> I'm basically trying to understand >>= better here
05:11:30 <acube> I have a type of kind ((* -> * -> *) -> * -> * -> *) -> * -> * -> *
05:11:39 <acube> And I want to derive Typeable2 for that
05:12:01 <saep> > [3,4] `concatMap` show
05:12:02 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[t0]'Couldn't m...
05:12:10 <notdan> bor0: so basically the definition of (>>= :: [a] -> (a -> [b]) -> [b]) is concat . map
05:12:10 <benmachine> that looks like it takes three parameters
05:12:16 <saep> > show `concatMap` [3,4]
05:12:17 <lambdabot>   "34"
05:12:33 <bor0> so every bind operator differs from the actual type we're applying it on?
05:12:43 <acube> benmachine: But Typeable2, because you can't have non-*-parameters for Typeable3
05:13:02 <benmachine> acube: ah, you're looking for Typeable2 (Blah t)?
05:13:09 <notdan> bor0: the bind operator is different for every monad, yes
05:13:12 <acube> benmachine: yes, because Typeable3 would be invalid
05:13:18 <notdan> bor0: do you know about typeclasses?
05:13:26 <bor0> ok, one more question. why does it make sense to make >>= concatMap in my specific case?
05:13:31 <bor0> yes, a bit I guess
05:14:04 <notdan> Well the thing about typeclasses is that they provide a way to define operators differently for every type.
05:14:33 <Maxdamantus> @undo [(a, b) | a <- [1..10], b <- [1..10]]
05:14:33 <lambdabot> concatMap (\ a -> concatMap (\ b -> [(a, b)]) [1 .. 10]) [1 .. 10]
05:14:37 <notdan> this definition makes sense because 1) it abides monad laws and 2) it represents non-deterministic computations
05:14:55 <bor0> that answered it, thanks notdan :)
05:15:08 <notdan> bor0: you could rewrite your snippet like this: do { x <- [1,2]; show x }
05:15:19 <acube> My current TH magic only handles kinds like (* -> *) -> * -> *, but not like ((* -> *) -> *) -> * -> *
05:15:25 <notdan> x represents a non-deterministic computation that can result in either 1 or 2
05:15:57 <bor0> for me to understand that I'll have to understand do {} first
05:15:59 <Eduard_Munteanu> AryanKing: not really sure, there were some exercises on the Haskell wiki
05:16:33 <AryanKing> Well, thanks for your help Ed.
05:16:57 <notdan> bor0: I can recommend reading about what typeclasses are and then reading Typeclassopedia about Functor and Monad: http://www.haskell.org/haskellwiki/Typeclassopedia
05:17:41 <notdan> bor0: I myself "got" various Haskell typeclasses after reading Typeclassopedia
05:17:46 * Eduard_Munteanu ended up with    forM_ x $ \x -> foo x    (it's a bit different actually)
05:17:53 <bor0> thanks, I'll check that
05:18:04 <kryft> Hmm, I haven't read typeclassopedia yet
05:19:32 <acube> Eduard_Munteanu: Isn't that jujst forM_ foo?
05:19:48 <acube> forM_ x foo*
05:20:12 <Eduard_Munteanu> acube: yes, but in my actual case I have arguments in different positions
05:20:40 <Eduard_Munteanu> sequence_ (foo <$> x <*> pure y)   might also do
05:21:34 <Eduard_Munteanu> :t sequence_ (?foo <$> ?x <*> pure ?y)
05:21:35 <lambdabot> parse error on input `?'
05:21:41 <acube> :t \y x -> traverse_ (`foo` y) x
05:21:41 <lambdabot>     Not in scope: `traverse_'
05:21:41 <lambdabot>     Perhaps you meant one of these:
05:21:41 <lambdabot>       `F.traverse_' (imported from Data.Foldable),
05:21:44 <Eduard_Munteanu> Huh.
05:21:45 <acube> :t \y x -> F.traverse_ (`foo` y) x
05:21:46 <lambdabot>     Not in scope: `foo'
05:21:46 <lambdabot>     Perhaps you meant `T.for' (imported from Data.Traversable)
05:21:51 <acube> :t \foo y x -> F.traverse_ (`foo` y) x
05:21:52 <lambdabot> (Applicative f, Foldable t) => (a -> t1 -> f b) -> t1 -> t a -> f ()
05:22:16 <acube> :t \foo y x -> F.sequence_ (foo <$> x <*> pure y)
05:22:17 <lambdabot> (Monad m, Applicative t, Foldable t) => (a2 -> a1 -> m a) -> a1 -> t a2 -> m ()
05:29:27 <namoamitabuddha> I feel that `(+) <$> (+3) <*> (*100) $ 5` is quite cryptic.
05:30:03 <elliott> I find it easy to parse but not as easy as (5+3) + (5*100).
05:30:09 <elliott> what's your point? I don't think anybody would write it that way in practice :P
05:30:25 <benmachine> it's not so bad when you get used to it
05:30:45 <benmachine> I'd prefer liftA2 (+) (+3) (*100) though
05:31:13 <namoamitabuddha> What do we benefit from these expressions?
05:31:43 <elliott> namoamitabuddha: where did you see the expression you quoted?
05:31:52 <namoamitabuddha> elliott: lyah
05:31:52 <elliott> (IOW, why presume there is benefit to it?)
05:31:56 <elliott> ok.
05:32:06 <elliott> I suspect it is merely trying to demonstrate how the Applicative instance for functions works.
05:32:20 <elliott> not advocating for writing that expression that way in practice
05:33:16 <kryft> namoamitabuddha: Most of the examples in LYAH are toy examples; Real World Haskell has some (somewhat) more realistic ones
05:33:44 <kryft> (Well, at least I seem to recall that LYAH had lots of examples like that.)
05:34:10 <namoamitabuddha> Well, is there any method to visualize such an expression, say, diagram chasing?
05:34:54 <namoamitabuddha> It's meaningless to write such a expression for 5+3+5*100; however, I wonder whether there's a good abstraction for that.\
05:35:07 <elliott> for the Applicative instance for (r ->), to evaluate (f <$> g <*> h <*> i) you just plug the overall parameter into all of g, h i and then pass the results to f. pretty simple
05:37:34 <elliott> namoamitabuddha: for an example where the (r ->) monad does simplify things, try writing an interpreter for the lambda calculus with it
05:37:46 <elliott> as eval :: Term -> Var -> Value, with only one explicit parameter
05:37:59 <elliott> plumbing the environment is cleaner that way
05:38:52 <namoamitabuddha> My understanding of abstract stuff is quite poor.
05:55:46 <namoamitabuddha> elliott: Thanks. I see.
05:57:56 <elliott> :)
06:49:39 <acube> @where hpaste
06:49:40 <lambdabot> http://paste.tryhaskell.org/new/haskell
06:54:22 <hpaste> acube pasted “Is this Typeable instance valid?” at http://paste.tryhaskell.org/90743
06:55:13 <Cale> acube: Can't you just write deriving Typeable?
06:55:20 <Cale> oh
06:55:22 <Cale> the kind...
06:56:24 <acube> I just want to know if I can use typeOf1 (undefined :: f ()) instead of typeOf1 (undefined :: f (Fix f)) there ...
06:56:56 <Cale> You probably can
06:57:03 <Cale> But there's not much reason to?
06:58:05 <byorgey> you can.
06:58:21 <byorgey> typeOf1 only returns a representation of the  * -> * part
06:58:34 <Cale> yeah
06:58:48 <byorgey> e.g.  typeOf1 (undefined :: [Int]) == typeOf1 (undefined :: [()])  ==> True
06:59:12 <byorgey> Cale: what do you mean by "there's not much reason to"?
06:59:42 <acube> byorgey: I think he means that in this example, I could just use f (Fix f) because I have scoped variables anyway
06:59:54 <byorgey> well, that's true
07:01:34 <Cale> You could even use the value itself that you get from pattern matching the Fix
07:02:02 <Cale>   typeOf (Fix x) = mkTyCon3 "my-package" "this-module" "Fix" `mkTyConApp` [typeOf1 x]
07:02:11 <Cale> ^^ that won't require ScopedTypeVariables
07:02:12 <acube> Yeah, but I'm writing some template haskell to generate typeable instances, so using () is much easier
07:03:24 <elliott> acube: why are you hand writing them??
07:03:33 <elliott> in 7.8 you can't even if you want to
07:03:52 <acube> elliott: I don't want to use 7.8 yet
07:04:01 <acube> elliott: And I've got a type of kind ((* -> * -> *) -> * -> * -> *) -> * -> * -> *
07:04:08 <acube> deriving fails
07:04:26 <elliott> ah
07:04:29 <elliott> ok :)
07:05:22 <Cale> Ah, I suppose in 7.8, the higher kinded Typeable instances are easier to derive as well
07:05:44 <byorgey> in 7.8 you just turn on -XPonies
07:05:56 <elliott> pretty hard to derive them
07:05:58 <elliott> since they're derived automatically
07:06:26 <Cale> I mean that what is being done automatically is perhaps easier
07:06:47 <elliott> right
07:07:32 <Fuuzetsu> @pl f x y = h (g x) (g y)
07:07:35 <lambdabot> f = id (fix (const (flip ((.) . h . g) g)))
07:07:35 <lambdabot> optimization suspended, use @pl-resume to continue.
07:08:40 <elliott> benmachine: is the pointless package fixed yet? :) (am I misremembering that it was you who maintains it?)
07:08:48 <benmachine> elliott: it is me who does it
07:08:56 <benmachine> I made a lot of progress
07:09:16 * elliott cries whenever someone does a @pl and it breaks.
07:09:59 <acube> I start to think that a Typeable2 instance for a data ComplexType f a b = ComplexType (f (ComplexType f) a b) is impossible to write :|
07:12:55 <acube> Or at least, it gets very messy ...
07:15:04 <Saizan> derive Typeable doesn't produce one?
07:15:33 <acube> derive Typeable says: Complex must only have arguments of kind *
07:16:12 <typoclass> acube: Complex is the same as ComplexType?
07:17:00 <acube> typoclass: Yes
07:20:47 <Saizan> yeah, i guess there's no class that's going to give you a TypeRep for 'f'
07:24:16 <hpaste> acube pasted “Are these instances valid?” at http://paste.tryhaskell.org/90744
07:24:44 <acube> Are the instances I pasted valid? I'm really unsure about the Typeable2 instance for Complex, as it doesn't feel right to use typeRepTyCon there
07:30:49 <Saizan> seems like they wouldn't cause cast to get unsound
08:04:18 <erisco> foo :: Maybe a -> Maybe b     foo n@Nothing = n      is a type error. other than reconstructing Nothing, is there a way to convert between Maybe types?
08:04:56 <elliott> I don't quite understand your question.
08:04:59 <elliott> what do you do in the Just case?
08:05:07 <elliott> but, Nothing is never reconstructed
08:05:11 <erisco> that isn't relevant
08:05:12 <elliott> there is only one of it, even operationally
08:05:20 <elliott> I think it is relevant :P
08:05:37 <erisco> I'm just saying,  foo n@Nothing = n   is a type error, and it seems you must use   foo Nothing = Nothing
08:05:45 <elliott> yes, that is correct
08:06:00 <elliott> were you able to write the former (bypassing the type system), it would behave the same as latter
08:06:05 <elliott> there is only one Nothing pointer (in GHC)
08:06:08 <erisco> right, is that the only way to do it? it is bothersome when you have    data MyType a b c = MyType 1 a b c | MyType2 b c
08:06:23 <elliott> you can use unsafeCoerce when you know it is ok
08:07:32 <erisco> hm okay
08:07:58 <erisco> thanks
08:09:28 <KingofFerrets> How do you check if a file already exists?
08:09:29 <elliott> :)
08:09:39 <elliott> KingofFerrets: doesFileExist, but you shouldn't, it's race condition land
08:10:19 <erisco> better to use exceptions. hmm, don't know what Haskell's exception idea is
08:10:40 <KingofFerrets> ...Race condition land?
08:10:48 <elliott> KingofFerrets: you check a file exists, and then do something that depends on that choice
08:10:52 <elliott> but whether it exists or not can change in-between the two
08:10:59 <elliott> there is very little reason to check explicitly
08:11:07 <KingofFerrets> Ah.
08:11:17 <erisco> so the solution is to put the test after you've done what you want aka exceptions ;)
08:12:00 <kryft> Hmm, that's a good point; I wonder how many times I've checked for existence explicitly (in other languages). :P
08:12:50 <KingofFerrets> Exceptions aren't an option here.
08:12:59 <elliott> why not?
08:13:01 <elliott> what are you trying to do?
08:13:15 <KingofFerrets> I don't want it to crash if the file exists, I just want it to output to the file name plus _2 or something. XD
08:13:28 <elliott> it's not about crashing
08:14:01 <erisco> indeed. exceptions are about not crashing :)
08:15:01 <bscarlet> KingOfFerrets: you check, don't see a file. I create the file for which you just checked. You don't append a _2 'cause you didn't see the file. You overwrite my file.
08:15:01 <erisco> KingofFerrets, if you are just grabbing a file name then it doesn't matter. the only issue is if you make the assumption that the file exists after you test for its existence
08:15:11 <KingofFerrets> Eh. I suppose that's technically true, it's just what I'm used to happening.
08:15:25 <erisco> I suppose assuming the converse is also dangerous
08:15:40 <KingofFerrets> bscarlet: Then what /do/ you recommend?
08:16:32 <erisco> oh, "output to the file" I just read "output the file name"
08:16:41 <erisco> yeah that is an exceptional case
08:17:38 <erisco> is there an open mode that fails if the file exists?
08:19:22 <bscarlet> erisco: it exists in the underlying open(...) call (O_EXCL). I dunno about Haskell.
08:20:37 <erisco> I'd presume you'd have to recurse, making up arbitrary file suffixes, and trying to open them until one suceeded
08:21:21 <erisco> preferably using some suffix generation that won't conflict with another instance of your program
08:21:53 <erisco> though that'd be some crazy scheduling happenstance to be locked like that
08:22:08 --- mode: ChanServ set +o monochrom
08:22:09 --- mode: monochrom set -bb *!*@*.anchorfree.com *!*@*204.93.60.*
08:22:09 --- mode: monochrom set -o monochrom
08:22:44 <erisco> actually one instance would have to succeed, so I suppose you'll converge. not an issue then
08:22:50 <KingofFerrets> Was going to go with _2, _3, _4, _5. When one of them succeeds, I open the handle and get back to work, so I don't think another instance of the program would cause the problem? If- yeah
08:23:22 <bscarlet> KingOfFerrets: What to do depends on the expected behaviour of whatever you might be racing against. If you're worried about other instances of your own program, that's one thing. If you're worried about other code you can't control, that's another.
08:24:32 <KingofFerrets> I don't expect any other code to be involved in the short-term, at leas.
08:24:35 <KingofFerrets> *least
08:25:14 <merijn> bscarlet: Presumably System.Posix should expose that interface
08:25:39 <merijn> ah
08:25:42 <merijn> Here we go: http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-IO.html#t:OpenFileFlags
08:25:57 <bscarlet> KingofFerrets: What merijn said.
08:26:00 <mauke> @hoogle openTempFile
08:26:00 <lambdabot> System.IO openTempFile :: FilePath -> String -> IO (FilePath, Handle)
08:26:00 <lambdabot> System.IO openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
08:26:16 <merijn> You want to use openFd and then use fdToHandle to obtain a handle
08:26:21 <mauke> openTempFile dir "foo.ext"
08:26:34 <mauke> (actualName, handle) <- openTempFile dir "foo.ext"
08:26:43 <merijn> Obviously, posix only
08:26:52 <mauke> this is in System.IO
08:29:27 <KingofFerrets> mauke: Sadly, don't want random gibberish after the filename, would prefer having a system for it.
08:29:44 <merijn> hmm, is there something fold-like matching the type "(a -> b -> a) -> a -> [b] -> [a]"?
08:30:09 <merijn> i.e. I want to end up with the list of as I produce while folding bs
08:30:16 <KingofFerrets> But System.Posix.File seems to have something workable...
08:30:41 <mauke> then you'll have to do it manually
08:31:06 <mauke> :t scanl
08:31:07 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
08:31:16 <mauke> @hoogle (a -> b -> a) -> a -> [b] -> [a]
08:31:17 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:31:17 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:31:17 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
08:33:11 --- mode: ChanServ set +o monochrom
08:33:11 --- mode: monochrom set -r
08:33:11 --- mode: monochrom set -o monochrom
08:34:42 <merijn> awww, there's no scanM :(
08:35:00 <merijn> Maybe monad-loops has something
08:35:11 <bscarlet> merijn: What type do you want?
08:36:27 <merijn> Monad m => (a -> b -> m a) -> a -> [b] -> m [a]
08:37:32 <merijn> I think I'll just have to implement it myself
08:39:05 <ocharles> :t \f x ys -> traverse (uncurry f) (zip (repeat x) ys)
08:39:05 <lambdabot>     Not in scope: `traverse'
08:39:06 <lambdabot>     Perhaps you meant one of these:
08:39:06 <lambdabot>       `T.traverse' (imported from Data.Traversable),
08:39:12 <ocharles> :t \f x ys -> T.traverse (uncurry f) (zip (repeat x) ys)
08:39:13 <lambdabot> Applicative f => (a -> b1 -> f b) -> a -> [b1] -> f [b]
08:39:19 <ocharles> that?
08:39:31 <typoclass> KingofFerrets: to summarize, use 'open' with the two relevant flags. open will either create the file and open it and give you the handle, or it will fail and you can try again with the next possible file name. see O_EXCL on http://linux.die.net/man/3/open
08:39:41 <ocharles> hmm, you want m [a] back
08:40:14 <ocharles> oh, mine should do that if your f is restricted as such
08:40:39 <ocharles> merijn: the above should do it, dunno anything else in the prelude though
08:40:41 <mauke> that doesn't look like it can work
08:41:00 <mauke> it doesn't assume a ~ b, so it does something else
08:41:02 <merijn> ocharles: Basically, right now I have a fold that represents an increasingly accurate approximation, I want to end up with a list of every approximation so I can do some stats on worst prediction/best prediction, standard deviation, etc.
08:41:26 <ocharles> mauke: oh, merijn wants to feed the output back in as feedback, I guess?
08:41:33 <merijn> No
08:42:12 <merijn> "(Approximation -> Measurement -> IO Approximation) -> Approximation -> [Measurement] -> IO [Approximation]"
08:42:19 <mauke> ocharles: yes
08:42:35 <merijn> oh, eh, yes
08:42:48 <merijn> I misunderstood what you were referring to as output
08:42:50 <typoclass> KingofFerrets: oh and you should check if open-excl-creat failed because of EEXIST, or for some other reason. because if you don't check, and open fails (e.g.) because you don't have permission to create stuff, you'll go into an infinite loop trying to create infinitely many files, and none of it will ever work
08:42:58 <ocharles> ok, ignore me then :)
08:43:00 <typoclass> KingofFerrets: ... make any sense? :-)
08:43:13 * ocharles goes back to rotting his brain with Perl
08:43:27 <merijn> I'll just write my own scan!
08:43:34 <merijn> With blackjack! And hookers!
08:43:38 <merijn> In fact, forget the scan!
08:43:50 <ocharles> party at merijn's!
08:45:18 <mauke> :t let scanlM f q ls = (q :) <$> case ls of [] -> pure []; x : xs -> f q x >>= \y -> scanlM f y xs in scanlM
08:45:18 <lambdabot> (Monad f, Applicative f) => (a -> t -> f a) -> a -> [t] -> f [a]
08:45:50 <ocharles> yay redundant context
08:45:56 <mauke> :t let scanlM f q ls = (q :) `liftM` case ls of [] -> return []; x : xs -> f q x >>= \y -> scanlM f y xs in scanlM
08:45:57 <lambdabot> Monad m => (a -> t -> m a) -> a -> [t] -> m [a]
08:46:00 <ocharles> :(
08:46:03 <KingofFerrets> Yup. Fun.
08:49:46 <merijn> mauke: Nice, thanks!
08:50:34 <mauke> it looks very unlazy
08:51:52 <ocharles> Hmm, is there a `maybe` like function for lists? I guess it would be "list :: (a -> b) -> (a -> [a] -> b) -> [a] -> b"
08:52:05 <leroux> Hello. I'm having a problem with finding the most efficient way of implementing `take` and `takeLast` of type `f :: Integer -> Integer` without the use of `show`.
08:52:31 <mauke> ocharles: foldr
08:52:39 <ocharles> then mauke's code is: scanlM f q ls = (q :) <$> list (pure []) (\x xs -> f q x >>= \y -> scanlM f y xs)
08:53:02 <mauke> but your 'list' type makes no sense to me
08:53:03 <ocharles> mauke: right, I thought I was describing a catamorphism or something. I can see how it fits foldr
08:53:18 <ocharles> mauke: ok, which bit did I make no sense at?
08:53:23 <merijn> mauke: meh, right now I'm using lazy IO to read in a 18k element list, then randomise the entire thing and analyse it, performance is the least of my worries xD
08:53:34 <leroux> I also tried to do `takeFromInteger k x = x `div` (10 ^ (l - toInteger k)).
08:53:35 <mauke> ocharles: how are you going to get a 'b' out of []?
08:53:35 <merijn> As long as it runs without crashing in a semi-reasonable time I'm good
08:53:50 <leroux> But I run into a problem with my length of integer function.
08:54:22 <yitz> leroux: ok. how do you propose to implement that?
08:54:43 <merijn> leroux: What's it do? return the last digit of the number?
08:54:46 <bscarlet> :t ((sequence .) .) . (. return) . scanl . flip ((.) . (>>=)) . flip
08:54:47 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m [a]
08:55:05 <leroux> https://gist.github.com/leroux/5950057
08:55:08 <leroux> merijn: &
08:55:18 <quicksilver> ocharles: you're on the right lines
08:55:27 <bscarlet> :t \f i bs -> sequence $ scanl (\ma b -> ma >>= \a -> f a b) (return i) bs
08:55:28 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m [a]
08:55:34 <quicksilver> ocharles: foldr is the recursive once but there is a non-recursive one
08:55:54 <quicksilver> ocharles: you wanted list :: ([] -> b) -> (a -> [a] -> b) -> [a] -> b
08:55:55 <KingofFerrets> ...should writing to files work in GHCI? Trying to test some stuff and it's creating files, but not actually outputting anything. O.o
08:56:07 <yitz> leroux: the problem is that Integer can be very big. going via a floating point number doesn't sound like a very good idea.
08:56:19 <leroux> Ahh.
08:56:21 <leroux> Okay, yeah.
08:56:25 <KingofFerrets> Just getting a handle and doing hPutStr handle "test" and I get empty files.
08:56:26 <quicksilver> KingofFerrets: it's probably just being buffered, try closing the file and/or calling hFlush
08:56:27 <merijn> KingofFerrets: It should, but might be buffered unless you flush/close the Handle
08:56:30 <elliott> quicksilver: erm... :)
08:56:32 <leroux> I ran into a problem when the length became greater than 310.
08:56:35 <KingofFerrets> ah
08:56:39 <elliott> did you mean () -> b or something?
08:56:43 <yitz> yes
08:56:47 <mauke> quicksilver: did you mean: list :: b -> ...
08:56:49 <quicksilver> yes :)
08:56:53 <yitz> leroux: any other ideas?
08:56:59 <KingofFerrets> Okay, that works, then.
08:56:59 <quicksilver> quite so
08:57:02 <leroux> I also did it via a show.
08:57:05 <KingofFerrets> Swoot, thanks.
08:57:12 <quicksilver> I meant () but certainly just b would be more sensible.
08:57:15 <leroux> But that didn't prove to be efficient enough.
08:57:19 <yitz> ah. ok. right that can be avoided.
08:57:22 <leroux> It took 88% of the cpu time.
08:57:26 <typoclass> KingofFerrets: maybe write yourself a helper function that does "hPut ... ; hFlush"
08:57:59 <yitz> really? hmm, i thought show was pretty efficient for Integer.
08:58:18 <KingofFerrets> typoclass: I don't need that; I just was trying to test one thing really quick in ghci. hClose does it too, and I'll only need that in my actual code, so I'm good.
08:58:36 <yitz> leroux: how big are the numbers you will use? i've used show on Integer with a few thousand digits with no measurable delay.
08:58:39 <leroux> I'll write it up again and create a gist of the code and cost centres.
08:58:39 <merijn> typoclass: Or just use hSetBuffering to toggle the buffering :p
08:58:53 <leroux> Umm.
08:58:59 <typoclass> merijn: right :-) good point
08:59:28 <mauke> merijn: that's usually a bad idea
08:59:28 <yitz> leroux: but personally using show feels like kind of a kludge to me anyway, so i'm with you in your quest to find a direct way to do it.
08:59:38 <leroux> Yeah.
08:59:47 <leroux> I was basically having to do a read . show.
09:00:06 <leroux> Well, a read . (some tranformation) . show.
09:02:06 <merijn> mauke: Sure
09:02:19 <leroux> yitz: Should I maybe mathematically reverse the number?
09:02:32 <leroux> And then have a take . (lazy show)?
09:02:41 <leroux> Is `show` lazy/
09:02:42 <leroux> ?
09:02:46 <mauke> fun exercise: write a haskell program that disables buffering and outputs a few strings. then run it under strace and see what happens
09:03:28 <merijn> Does hPutStr call putChar recursively for each char?
09:03:44 <mauke> @src hPutStr
09:03:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:03:51 <mauke> yes
09:04:04 <mauke> it has no choice because each Char could be the last
09:05:31 <yitz> leroux: ok. sounds a little too complicated though. i think what you're doing already is fine, just think of a better way to count the digits
09:05:31 <yitz> leroux: yes show is lazy
09:05:31 <yitz> > let x = show x in x
09:05:35 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:05:50 <leroux> Thanks.
09:06:10 <ocharles> mauke, quicksilver: oh yes, I forgot the constructors of list :) I guess I meant list :: b -> (a -> [a] -> b) -> [a] -> b
09:06:27 <leroux> That may be a possible solution
09:07:10 <yitz> leroux: you can repeated div by 10 and count how long it takes until you reach zero. this function might be of use:
09:07:15 <yitz> @type iterate
09:07:16 <lambdabot> (a -> a) -> a -> [a]
09:07:32 <yitz> > iterate (*2) 1
09:07:33 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:07:44 <leroux> Ahh. Hmm.
09:07:57 <yitz> @src iterate
09:07:58 <lambdabot> iterate f x =  x : iterate f (f x)
09:08:39 <leroux> Thanks yitz.
09:08:47 <leroux> I'll try to do something with that now.
09:16:09 <typoclass> > let until f predicate x = if predicate out then [] else out : (f `until` predicate) xnext where (xnext, out) = f x in ((`divMod` 10) `until` (== 0)) 123 -- leroux: spoiler ;-)
09:16:10 <lambdabot>   [3,2,1]
09:16:19 <leroux> Ooh. Thanks.
09:19:07 <yitz> typoclass: usually better style to use existing higher-level combinators than manual recursion in my opinion. leroux does seem to want speed, but with -O i'm not sure that would be faster anyway.
09:19:26 <typoclass> yitz: hm yeah ...
09:20:05 <leroux> How can I write a lazy takeFromInteger?
09:20:15 <xilo> how do i get documentation lookup in vim?
09:20:16 <leroux> Without first knowing the length of the entire integer/
09:21:03 <yitz> leroux: i think it will be tough without knowing (or implicitly knowing) the length
09:21:19 <typoclass> yitz: not sure about the speed issue, but i've kinda wondered why we don't have a function like iterate, but expecting a tuple. it would be useful for stuff like splitAt, break, divMod. it would collect the one half in the list, and pass the other half into the next iteration
09:21:42 <typoclass> ('we don't have' in the sense of 'we don't have in base')
09:26:13 <yitz> @type \f predicate -> map snd . takeWhile (not . predicate . snd) . iterate (f . fst) . f
09:26:14 <lambdabot> (a -> (a, b)) -> (b -> Bool) -> a -> [b]
09:27:09 <benmachine> yitz: looks like an unfoldr
09:27:37 <yitz> benmachine: it's supposed to be typoclass until
09:28:33 <yitz> benmachine: and yeah, it kind of an unfold.
09:30:28 <typoclass> yes it's nearly unfoldr, except that the producer function doesn't use a Maybe to signal the end of the list, instead producing an infinte list
09:30:33 <benmachine> elliott: just uploaded a new pointfree, btw
09:30:45 <benmachine> (no hackagebot?)
09:31:01 <elliott> benmachine: cool
09:31:19 <elliott> benmachine: did you look into how easy it would be to expose an API like lambdabot wants?
09:31:26 <benmachine> elliott: no, not yet
09:31:37 <elliott> alright
09:32:10 <elliott> benmachine: heh, the modules are still Plugin.Pl.*?
09:32:15 <benmachine> yep
09:32:18 <elliott> lambdabot doesn't even use that naming scheme now :)
09:32:18 <alexander__b> what is the name of the function that multiplies matrices again?
09:32:56 <alexander__b> like multiplying [x, y, z] with [1, -1, 1] for instance
09:33:13 <typoclass> what's the preferred way to url-decode again? package web-encodings is deprecated, and what was the replacement?
09:34:02 <acube> alexander__b: zipWith (*) ?
09:34:12 <acube> > zipWith (*) [1,2,3] [3,2,1]
09:34:13 <lambdabot>   [3,4,3]
09:34:14 <alexander__b> acube: ah yes of course. that was what I did. thanks.
09:37:12 <lpsmith> when writing bindings to C libraries, is there a standard way of dealing with multiple versions of the C library, especially in context of the PVP?
09:37:21 <yitz> typoclass: there's at least http-types, and uri-conduit
09:38:44 <typoclass> yitz: thanks, will look
09:39:27 <yitz> typoclass: i see a uri library. not familiar with it, not sure how robust it is. the other two are highly battle-tested in lots of real-world yesod apps. there are a lot of dark corners to uri parsing.
09:43:08 <benmachine> the network package has a uri module
09:45:01 <typoclass> heh, so many packages to look at :-)
09:49:25 <josephle> is the set of untyped lambda-calculus terms closed over beta-reduction a semigroup?
09:49:54 <josephle> I was just thinking about the untyped lambda-calc, and I realized that beta-reduction was associative
09:51:37 <mserrano> josephle: if the set is closed under the operation and the operation is associative, then it is a semigroup
09:52:49 <tromp_> what operation are u tralking about?
09:53:29 <josephle> tromp_: beta-reduction of lambda terms
09:53:59 <tromp_> that's a relation, not a binary operation?!
09:54:44 <josephle> tromp_ but when you apply beta-reduction?
09:56:20 <josephle> through the dynamic semantics of lambda-calc, that is
09:56:38 <tromp_> how is that a (semi-)group operation?
09:57:26 <josephle> (ab) |-> c, for some terms a, b, and c, right?
09:57:59 <tromp_> application is a binary operation, but it's not associative
09:58:27 <josephle> tromp_: you're right, I forgot that single-step semantics will be different
09:58:43 <josephle> erm single-step application
09:58:56 <josephle> and full evaluation is not necessarily terminating
09:59:12 * elliott is confused
09:59:25 <josephle> elliott: sorry, I got confused myself
09:59:31 <tromp_> termination has little to do with it
10:00:13 <josephle> I was thinking in terms of evaluation order
10:00:35 <josephle> so if (ab)c evaluates to some value v, then a(bc) should also evaluate to v, right?
10:00:59 <josephle> so I got confused and thought (ab)c == a(bc)
10:01:00 <tromp_> no
10:01:28 <josephle> tromp_: hmm, I can see why I might be wrong
10:01:50 <Ankhers> does anyone have experience creating Haskell applications with a GUI? I am starting to look into it and am unsure which package should be used.
10:02:04 <tromp_> KII != K(II)
10:03:01 <typoclass> Ankhers: i think either gtk, or wx. that's all i know :-)
10:03:47 <Ankhers> typoclass: I'm assuming you have no experience with either?
10:03:59 <typoclass> Ankhers: yep
10:04:09 <Ankhers> typoclass: Alright, thanks.
10:05:44 <josephle> tromp_: yep, you're right. I am now considerably less confused.
10:07:20 <sm> Ankhers: a web gui is another option
10:08:19 <saml> web gui is good
10:08:33 <saml> you open tcp connection and tell it to do something like draw a button
10:10:16 <typoclass> saml: obviously sm was referring to html/javascript
10:11:11 <sm> I was.. but yes, yet another option is to talk to a separate gui process written in something with mature gui libs
10:11:12 <saml> ah didn't know haskell compiles to html/javascript
10:11:33 <saml> i was thinking you create haskell server and have it serve html pages
10:11:51 <saml> then users use web browser to get the html pages and control the server
10:11:58 <sm> saml: a built-in web server is what I meant, yes
10:12:31 <typoclass> saml: right. (haskell doesn't "compile to gtk" either, or wx, or anything similar)
10:12:45 <Ankhers> Unfortunately, a web interface is not very practical for this application.
10:13:02 <saml> one thing about web is that now you need to authenticate every request... etc
10:13:15 <Ankhers> I have been meaning to take a look at one of the JS compilers though. Does anyone know of a decent one.
10:13:25 <saml> Ankhers, what app is this?
10:13:41 <Ankhers> I am creating a real time log parser.
10:13:50 <Ankhers> rather... attempting to.
10:13:57 <saml> like logstalgia?
10:14:01 <Ankhers> I am using it be become more familiar with Haskell.
10:14:22 <saml> ah i see. not sure if you need gui for that
10:14:39 <sm> Ankhers: maybe console ui is a cheaper solution!
10:14:49 <saml> let it just output to stdout so that you can pipe other tools
10:14:52 <sm> if it's a learning haskell project..
10:15:31 <Ankhers> You are probably right.
10:16:23 <Ankhers> In either case, could someone point me in the direction of a good cross platform compile tutorial?
10:16:27 <saml> write a bunch of haskell commandline tools that does parsing and stuff
10:16:31 <saml> or write a shell
10:16:55 <saml> what do you mean? you want to create windows binary on linux machine?
10:17:02 <Ankhers> Yes.
10:17:22 <saml> i haven't heard of such
10:17:31 <sm> you can do that with wine, or I guess vmware etc.
10:18:13 <Ankhers> Damn, I will just install git/haskell on my windows machine too than. Thanks for the help!
10:18:33 <sm> sure, if you have a windows machine that's easiest. np
10:18:58 <saml> why not use java? you compile once and run it everywhere
10:19:18 <saml> or just distribute source. people can do  runhaskell yourprogram.hs
10:20:49 <typoclass> Ankhers: from what i understand, it's possible to have gtk or wx application that (if all the stuff is installed) will compile on windows, and also compile on linux. i have more doubts about compiling a binary on linux that will then run on windows, or vice-versa
10:21:38 <sm> in most cases you won't want end-users compiling your app from source
10:22:09 <sm> dealing with the haskell and c dependencies will be too much hassle for them
10:22:46 <saml> cabal install your-log-analyzer
10:22:53 <sm> unless it's quite a simple app
10:23:10 <typoclass> sm: sure. the developer should do the compiling. (same reason why i don't think runhaskell is a practical solution)
10:28:20 <Luke> is network-house still the best way to parse ethernet frames?
10:28:55 <erisco> > (+2) <$> (Just 3) <*> (Just 7)
10:28:56 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
10:28:56 <lambdabot>    arising f...
10:29:31 <erisco> > (Just (+2)) <$> (Just 3) <*> (Just 7)
10:29:32 <lambdabot>   Couldn't match expected type `a1 -> a0 -> b0'
10:29:32 <lambdabot>              with actual type...
10:29:36 <erisco> well I don't get it
10:30:13 <prophile> erisco: (+ 2) is a function that takes one argument
10:30:25 <prophile> you're trying to "map" it with two arguments
10:30:27 <prophile> if you follow
10:30:45 <erisco> > (+) <$> (Just 3) <*> (Just 7)
10:30:47 <lambdabot>   Just 10
10:30:48 <prophile> > (+) <$> (Just 3) <*> (Just 7)
10:30:49 <lambdabot>   Just 10
10:30:59 <prophile> (+ 2) <$> (Just 3)
10:31:07 <prophile> > (+ 2) <$> (Just 3)
10:31:08 <lambdabot>   Just 5
10:31:31 <erisco> > (Just 3) <*> (Just 7)
10:31:32 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
10:31:32 <lambdabot>    arising f...
10:31:44 <erisco> :t (Just 3) <*> (Just 7)
10:31:45 <lambdabot> (Num (a -> b), Num a) => Maybe b
10:31:46 <josiah14_> question about haskell for the many-body problem that computational physicists/chemists are trying to solve
10:32:14 <erisco> what does Num (a -> b) mean
10:32:14 <josiah14_> is the laziness of haskell, or any feature of the language, really, going to be an advantage for this particular problem?
10:32:30 <sellout> :t <*>
10:32:31 <lambdabot> parse error on input `<*>'
10:32:41 <sellout> :t (<*>)
10:32:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:32:47 <josiah14_> looking into doing some work in computational chemistry and trying to pick a language
10:33:08 <prophile> erisco: Num (a -> b) would mean that for all functions, you can sensibly add them, subtract them, and multiply them, among other things
10:33:12 <prophile> which makes no sense, hence the failure
10:33:22 <erisco> what failure?
10:33:37 <prophile> Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
10:36:42 <tunixman_> I was speaking with carter and I'm having some troubles with http://trac.haskell.org/ghc
10:36:52 <carter> tunixman_ go to #ghc :)
10:36:57 <carter> and offer igloo hep there
10:36:59 <tunixman_> Alright.
10:42:55 <Hugh> Hello folks - not sure of the protocol here, is this a place for Newbies to ask questions or is this a place for experts only?
10:43:07 <elliott> former
10:43:09 <elliott> :)
10:43:14 <Hugh> ta!
10:43:27 <typoclass> Hugh: hello, welcome. ask away :-)
10:43:34 <external-reality> Hugh: This is magical place where all may ask questions regardless of skill level.
10:44:04 <external-reality> Hugh: all may answer them as well (*cough*)
10:44:13 <Luke> is there anything to go from a ByteString to a UArray?
10:44:25 <erisco> :t ((+) <$> (Just 6))
10:44:26 <lambdabot> Num a => Maybe (a -> a)
10:45:04 <erisco> so ... this applicative thing is kinda like a foldl
10:45:54 <Hugh> Ok, so I have been on a 'spiritual' journey of enlightenment over the last few months. Am a Java geek by trade but always new that purity of functions and rock-hard types were cool. Probably from Uni days doing ML...
10:47:15 <external-reality> Luke: You could always unpack the Bytestring and go from the list to a UArray.
10:47:43 <Luke> external-reality: The docs say the underpinning of ByteString is a UArray so I was hoping I could get access to that
10:48:21 <erisco> I don't get how this chains together exactly...
10:48:34 <Hugh> ... so my question regards Monads. I am beginning to think of them as wrapping 'something' in a pure function, am I going down the wrong path here?
10:48:45 <erisco> <*> takes the unary function on the left, and then the arg on the right, and returns the right arg applied to the func
10:48:59 <erisco> okay... but then how do subsequent <*> work?
10:49:01 <klrr_> is there a function that creates exec another program? well there is but what is its name? :P
10:49:22 <Hugh> ... and that Monads are not only useful for connecting the 'pure' haskell world to the dirty, ugly 'outside' world, they also have uses inside the pure world
10:49:28 <erisco> (+) <$> (Just 3) <*> (Just 2) <*>  (Just 1)
10:49:32 <erisco> > (+) <$> (Just 3) <*> (Just 2) <*>  (Just 1)
10:49:33 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
10:49:33 <lambdabot>    arising f...
10:49:39 <erisco> oh, it doesn't
10:49:43 <external-reality> Luke: Don't know. Maybe you could check Data.ByteString.Internal
10:50:04 <Luke> external-reality: I did. it was a foreign pointer
10:50:08 <Luke> seemed dangerous =)
10:50:16 <klrr_> is there a function that creates exec another program? well there is but what is its name? :P
10:50:59 <benmachine> Hugh: absolutely monads are not only useful for dirt
10:51:19 <benmachine> Hugh: I'm not sure what you mean by wrapping something in a pure function
10:51:36 <joehillen> IO should be renamed to the Dirt monad
10:51:49 <sellout> erisco: Subsequent <*> work if the function returns a function (IE, if the function isn’t unary)
10:52:08 <erisco> right ... just means I had the wrong idea
10:52:54 <Hugh> benmachine: let me come at this another angle... Is the concept of a Monad defined into the syntax of the Haskell language or is it more of a design pattern?
10:53:21 <elliott> Hugh: sort of neither
10:53:23 <elliott> but more the latter
10:53:35 <elliott> it's an abstraction codified within the language, but not part of the core language itself
10:53:36 <benmachine> Hugh: monads are not "baked in", except there is do-notation to make them a bit more convenient
10:53:41 <elliott> if the Monad typeclass didn't exist you could define it
10:53:47 <Hugh> ... not to torture the anology as they are clearly different things, but is a Monad more like a Factory Pattern rather than a Java Abstract class
10:53:53 <elliott> the only thing "special" is that an abstract, primitive type like IO happens to have an instance
10:54:05 <elliott> but, "design pattern" isn't all that far off
10:54:08 <benmachine> IO is magic but Monad is not
10:54:11 <elliott> it's just that Haskell has enough expressive power to encode that abstraction
10:54:23 <joehillen> Hugh: forget everything you learned about Java, it will help you learn Haskell
10:54:31 <c_wraith> Monad is clearly a design pattern..  But it's a very minimal pattern.
10:54:42 <Hugh> joe: yeah, ur correct there!
10:54:55 <joehillen> in fact, I argue the less you know about imperative programming, the easier it is to learn haskell
10:54:56 <external-reality> Hugh: A monad is an interface.
10:55:01 <c_wraith> It's more abstract than any pattern you'll read about in "programming patterns" books
10:55:41 <Hugh> One of the big pulls pulling me to a functional way of thinking is that I am sick of all the 'design pattern' bloat around Java
10:55:42 <joehillen> Hugh: https://www.youtube.com/watch?v=3q8xYFDYLeI
10:55:46 <external-reality> Hugh: From a programmers perspective a monad is an interface.
10:56:25 <Hugh> ahh, an interface. Ok. make sense. But in a world of strong-types, why do we need an interface?
10:56:37 <elliott> they are interfaces for types.
10:56:44 <elliott> typeclasses, that is.
10:56:46 <elliott> note: not the same as Java interface.
10:56:46 <c_wraith> Because an interface describes what you can do with a type
10:56:50 <elliott> but vaguely comparable.
10:57:06 <c_wraith> It's all nice that you have a type.  Wouldn't you also like to know what you can do with it?
10:57:34 <josephle> Hugh: interfaces are invaluable in the world of strong-types
10:57:52 <Hugh> I get the feeling they are seriously powerful things, but elusive to the point that there no formal **English** (rather than math) definition
10:58:14 <c_wraith> Hugh: Monads are very simple to describe in english.  The problem is not describing them.
10:58:29 <elliott> Hugh: it sounds like you might be simply making the attempt too early.
10:58:32 <c_wraith> Hugh: the problem is that the description is so abstract as to sound meaningless, until you've actually used them for a while.
10:58:38 <elliott> the more Haskell knowledge you have, the less mysterious abstractions like monads seem.
10:59:35 <carter> the way i described monads in HS "algebraic cooties"
10:59:38 <Hugh> Ok, I guess you are right. At some deep level I think I do get them. A bit like a baby knows that it wants to stop crawling and stand up. I just need something to help me up!
10:59:42 <erisco> I forget who I was speaking with... name started with a 'b' ...
10:59:46 <josephle> the typeclass-intuition problem, eh?
10:59:48 <carter> when i was in haskell
10:59:51 <external-reality> Hugh: Pure functions can be applied to things but have no notion of sequence. Monads provide a notion of sequence. But thats not all ...
10:59:52 <carter> I mean high school
10:59:53 <c_wraith> ..  I really do wonder if Kleisli categories might be easier for people to grasp initially.
11:00:03 <erisco> but I have no idea how the parser combinators I have fit into Applicative... so if you are listening, some hints would be helpful
11:00:49 <Hugh> external: thanks, I like that explaination
11:01:26 <c_wraith> The thing is, monads really have only as much to do with sequencing as function composition does.
11:01:28 <dolio> erisco: Something like (\>) can be generalized into (<*>), and (\\) into (<|>).
11:01:54 <c_wraith> Which is why I really think the Kleisli category construction might be a better instructional tool
11:01:59 <dolio> Your design is somewhat different though.
11:02:06 <erisco> dolio, hey :D I just don't see how
11:02:14 <erisco> dolio, the signatures seem entirely different
11:02:18 <c_wraith> It shows that monads are really just an extension of function composition
11:02:27 <Hugh> so kinda like (but not) Apache Camel routes, so do Monads?
11:02:27 <Nisstyre> I <3 the Async module so much
11:02:35 <Nisstyre> especially mapConcurrently
11:03:27 <typoclass> Hugh: here's how i would phrase it. Monad is the name of a typeclass which contains 3-4 functions. (a typeclass in haskell is a group of function signatures with usually no function implementations; vaguely similar to an interface in java). there's a few popular instances of the typeclass (the Maybe monad, IO, the list monad) and a bunch of others. a number of functions in the standard library consume or produce anything of the Monad ty
11:03:30 <dolio> erisco: f <*> x is 'parse f, yielding a function, then parse x, and apply the function to what it yields.' And you can make 'functions' for the first part with fmap.
11:03:55 <dolio> So, like, '(,) <$> px <*> py' is 'parse px and then py and tuple their results.'
11:04:09 <Nisstyre> I think Monoid should be explained before Monad, personally
11:04:23 <Nisstyre> or some other type class
11:04:42 <c_wraith> What's interesting is that no one has trouble with any class that applies to concrete types, rather than type constructors
11:04:57 <c_wraith> And people pick up the basic constructor classes, like Functor, relatively quickly.
11:05:14 <Nisstyre> c_wraith: but as soon as you introduce a type parameter that is polymorphic they can't grok it?
11:05:16 <Hugh> thanks, I think that any explanation needs to stay a country mile away from maths and give real-world practical uses
11:05:26 <erisco> dolio, ah, so I remove the assumption of how to combine the results and instead accept f :: a -> b -> c
11:05:58 <typoclass> Hugh: and there's a small amount of syntax (called do blocks) that the compiler translates into calls to the 3-4 functions i mentioned. that's about it :-) it'll become clear as you'll use those functions a few times (and maybe even implement a new instance of the typeclass), and get familiar with more standard library functions that use monads, and write some do blocks yourself
11:06:04 <dolio> erisco: Something like that, yes.
11:06:11 <Hugh> so every monad must be placed in a do block?
11:06:17 <erisco> dolio, I don't know why I should care to do that
11:06:21 <Nisstyre> no
11:06:21 <dolio> @@ Also: @type liftA2
11:06:21 <lambdabot>  Also: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:06:21 <typoclass> Hugh: yes that's what i'm saying. i recommend you just write some code, and read lyah or another book along the way. the understanding will come
11:06:37 <external-reality> Hugh: If you ever come across a situation where "something must happen first" you are in monad land.
11:06:39 <elliott> typoclass: you're saying that "every monad must be placed in a do block"...?
11:06:44 <Hugh> thanks, it is coming slowly.
11:07:22 <dolio> erisco: They're good building blocks.
11:07:27 <dolio> @type liftA2 (,)
11:07:28 <lambdabot> Applicative f => f a -> f b -> f (a, b)
11:07:33 <Hugh> Ok, so if I am writing a Haskell program to model getting dressed in the morning I will need to use a Monad to make sure my underpants go on first then the trousers?!
11:07:33 <erisco> good why? :P
11:07:47 <typoclass> Hugh: no, do blocks are optional. you can directly call the functions from the Monad typeclass, or you can write do blocks, which means the compiler will translate those into calls to the same functions. the translation is mechanical and fairly simple
11:07:50 <dolio> That tuples things. But if you use it with any constructor, you've built a parser that builds some other data type.
11:07:50 <Nisstyre> Hugh: possibly, yeah
11:08:00 <elliott> you never "need" to use Monad.
11:08:17 <Nisstyre> I mean, there's nothing wrong with using a Monad for that
11:08:30 <Nisstyre> assuming putting on an article of cloting is a side-effect
11:08:34 <erisco> dolio, so if I just want tuples, it is more cumbersome, but if I potentially want other types ... I guess it is just  a -> b -> c versus (a, b) -> c
11:08:34 <external-reality> elliott: please don't confuse the dude.
11:08:40 <Nisstyre> *clothing
11:08:42 <elliott> external-reality: ?
11:08:50 <Eduard_Munteanu> Are there some guidelines for writing the build-depends part of .cabal?
11:08:52 <elliott> I think "If you ever come across a situation where "something must happen first" you are in monad land." is more confusing than what I said.
11:08:59 <Nisstyre> elliott: I agree
11:09:10 <dolio> erisco: Having f a -> f b -> f (a, b), plus fmap is equivalent in power.
11:09:11 <Nisstyre> it's not the only place where things happen deterministically
11:09:20 <Eduard_Munteanu> I'm updating the build-depends for an Yesod project and it seems rather daunting.
11:09:24 <Nisstyre> actually, that's not even true of all monads...
11:09:25 <elliott> in fact, I think basically every attempt at an actual explanation will confuse Hugh at this point.
11:09:25 <external-reality> Um how?
11:09:50 <Hugh> ok, so would you ever need to wrap a function in a monad if it was only going to be called in isolation?
11:09:58 <elliott> external-reality: here are some monads that may disrupt your understanding of them as being about sequencing: (->) r, Cont r, []
11:10:10 <dolio> erisco: If you're asking about the types of the Applicative functions specifically, it's so that you can write 'f <$> x <*> y' which looks similar to 'f x y'. Instead of 'uncurry f <$> tuple x y'.
11:10:14 <elliott> also, the slightly dubious reverse state monad: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
11:10:26 <elliott> Hugh: I don't know what you mean by "wrap a function in a monad"
11:10:32 <Hugh> The most confusing thing is that it is so darn hard to explain what is a central part of the language!
11:10:51 <Hugh> well, that is how every book appears to describe it.
11:10:57 <dolio> And it extends to larger functions 'f <$> x <*> y <*> z' versus 'uncurry3 f <$> tuple3 x y z'.
11:10:58 <external-reality> Sure and you could give me examples of things that disrupt a physicist understanding of physics but I thought we were trying to explain the general concept of how they are used.
11:11:00 <elliott> Hugh: it's not even really a central part :P
11:11:00 <Nisstyre> Hugh: it's not really hard to explain, but it is hard to see how it could be useful
11:11:12 <elliott> like I said, I suggest you expand your Haskell knowledge. then Monad will be easy. in fact, worrying about Monad will make it harder.
11:11:21 <dolio> Haskell functions tend to be curried.
11:11:26 <Hugh> ok. good advice
11:11:28 <elliott> external-reality: I don't know what you mean by that.
11:11:30 <erisco> dolio, hrm perhaps I should convert it over and try it out then
11:11:42 <Nisstyre> elliott: another one that disrupts that view: the parsec monad
11:11:55 <erisco> I was originally thinking about not assuming tuples but didn't know that is what Applicative would be about
11:11:57 <elliott> Nisstyre: true.
11:12:01 <typoclass> Hugh: it's a fairly thin abstraction. elliott's advice is very good. worrying about it will make it harder :-) just write some code, the understanding will come
11:12:32 <erisco> and just opted not to because of the extra code ... however, yeah, a \> b \> c \> d is convenient to write but (a, (b, (c, d))) is not convenient to work with
11:12:40 <Hugh> ok, but humour me, if Haskell was not intending to be pure functional would there be any use of monads?
11:12:47 <elliott> yes
11:12:58 <elliott> in fact, Haskell IO was not always done via a monadic interface.
11:13:06 <elliott> it just happens to be convenient.
11:13:14 <external-reality> elliot: A general understanding is not hard to grasp but if you keep interrupting every attempt at explanation with edge-cases and mathematical nuances you will probably scare people away from Haskell all together. I'm just saying.
11:13:16 <Nisstyre> Hugh: also, don't confuse the type with the monad, e.g. IO is its own type, it doesn't have anything to do with Monad *necessarily*
11:13:30 <dolio> erisco: Right.
11:13:38 <Hugh> so the concept of a monad could be used in an inperative lingo
11:13:45 <Nisstyre> same with lists, Maybe, State, and anything else
11:13:47 <elliott> external-reality: you're objecting to things I didn't say. I didn't say anything mathematical, for instance. in fact, I replied to Hugh originally, not you, so I don't know what your problem is.
11:14:24 <external-reality> elliott: Ok, I apologize. Your right. I should come at you like that.
11:14:41 <elliott> ok. no harm done.
11:14:50 <erisco> dolio, thanks for the help. I finally figured out Functor today and hopefully this will knock down Applicative
11:15:07 <Nisstyre> Hugh: (some people may disagree with this, but I think it's true), something isn't really a monad until someone looks at it and says "hey, this is a monad" and makes it an instance of Monad
11:15:22 <Nisstyre> and even then there isn't anything different about the original type
11:15:41 <erisco> dolio, by the way, the parser works well. S -> aSa | aa on "aaaaaa" parses correctly :D
11:15:48 <Hugh> Thanks all - appreciate the help, got to go now.
11:16:01 <dolio> erisco: Nice. You fixed the overflow?
11:16:22 <typoclass> Nisstyre: heh, good observation
11:16:58 <erisco> dolio, yes. I had to cut a couple ideas I had to make it work, but they were just tentative things that I didn't know if would be useful anyhow
11:17:20 <erisco> dolio, and I had to fix a problem with the definition of // to actually make it do what I meant. but otherwise, yeah
11:17:27 <dolio> Okay.
11:18:11 <erisco> dolio, the problem was that \> forced evaluation of 'b' even if 'a' failed, and with the recursive rule  (token 'a' \> q) this meant token 'a' would keep failing forever
11:18:48 <erisco> which is why other examples without recursiveness didn't fail
11:18:51 <dolio> Okay. That's what I expected. I just couldn't figure out the argument that that was the case.
11:20:34 <erisco> dolio, my reason for trying that was for possible error recovery, but I suspect I'll have other ways to implement that
11:20:44 <josephle> where is this \> operator defined?
11:21:08 <erisco> josephle, I defined it for the parser combinator library I am working on
11:21:14 <josephle> ah
11:21:20 <erisco> >> seemed to be taken, and obviously > was
11:21:29 <erisco> so I picked something arrow-ish that was available
11:21:57 <erisco> kinda like   a `then` b   would be another possible name
11:22:21 <josephle> ah
11:22:42 <erisco> I'm open to other ideas :)
11:23:37 <erisco> actually I am changing it to use Applicative as dolio suggested so if that works, the operator will not exist, I think
11:23:56 <erisco> dolio, I have to instance Applicative for some type... what type will that be?
11:24:10 <dolio> erisco: Another thing is, Applicative comes with a ton of other operators baked in.
11:24:53 <dolio> x <$ p is "parse p and yield x instead". p <* q is 'parse p, then parse q, but return ps result' p *> q is the same but returning q's result, etc.
11:27:04 <dolio> I think you can even do stuff like: p <**> f <$> q, which parses p yielding x, then parses q yielding y, and yields f y x as a whole.
11:27:26 <dolio> Unsure if that one actually works.
11:27:32 <erisco> well before I get there, like I said, I have to make an instance, and currently I don't have any type to do that with
11:27:45 <erisco> hrm, I suppose I introduce a Parser type? I have no idea really :s
11:28:01 <dolio> Yeah, an alias isn't going to cut it anymore.
11:28:35 <erisco> okay will do that and see where I get
11:29:00 <erisco> half distracted by Day9's The Last Of Us play through oO
11:31:24 <josephle> erisco: are you writing a parser combinator library for your own enlightenment?
11:31:49 <erisco> josephle, I didn't find any available for Haskell so.... yes of course for enlightenment :P
11:32:07 <josephle> :P
11:32:13 <erisco> josephle, but also I had an idea on how to solve a backtracking problem with recursive descent parsers, which appears to have worked
11:32:32 <josephle> ooh, that's pretty cool
11:33:04 <josephle> I know I've been burned by the backtracking problem.
11:34:30 <erisco> josephle, rdp has the backtracking problem where some branches are never tried ... because they are "hidden" in a level of the parser
11:35:38 <erisco> josephle, I thought of a couple ways to try and solve this. the first one I didn't know how to even make type signatures for -- my Haskell is too weak I guess -- but the second was to return a list of possible parse matches instead of just the first one
11:35:57 <erisco> josephle, this way, when backtracking, I can easily try every available option
11:36:51 <erisco> things like +? and *?   (lazy repetition) are easy that way too
11:36:58 <RichyB> erisco: …you were joking when you said you didn't find any available parser combinator libraries for Haskell, right?
11:37:10 <erisco> RichyB, yes lol
11:37:44 <erisco> RichyB, in fact it seems to be a pet project for many ... kinda like web frameworks for PHP
11:37:49 <dmwit> Hm, I missed 9 hours of conversation because I wasn't identified with services. =/
11:37:53 <dmwit> Had some spam recently or something?
11:38:16 <dolio> dmwit: Yes.
11:38:18 <RichyB> erisco: at least it isn't actively dangerous like publishing web frameworks or monad tutorials. ;)
11:38:24 <dmwit> bummer
11:38:31 <elliott> +r is off now
11:39:43 <conal> is iavor's type-nats extension in ghc 7.6.3?
11:39:55 <elliott> conal: yes (AFAIK)
11:40:13 <dolio> Yep, seems to be.
11:40:21 <dolio> 2 :: GHC.TypeLits.Nat
11:40:35 <conal> cool. :)
11:43:37 <dmwit> Couldn't match type `2 + 2' with `4' -- what did I do wrong?
11:44:13 <dmwit> :m + PrincipiaMathematica
11:45:05 <elliott> dmwit: you, nothing. the GHC developers, something.
11:45:14 <dolio> Yeah, I did a :kind! 2 + 2 and it says '= 2 + 2'.
11:45:57 <typoclass> what does the "=" mean in there? "lifted from value level" ...?
11:45:57 <kosmikus> I don't think any computation on Nat kinds is in 7.6.*
11:46:12 <dmwit> kosmikus: oh, okay
11:46:39 <dmwit> Wait, does that mean + is a type variable?
11:46:40 <dolio> typoclass: :kind! is supposed to reduce the thing you pass to it.
11:46:45 <conal> kosmikus: no constraint solving?
11:47:11 <typoclass> dolio: ok :) ghc bug then
11:47:17 <kosmikus> conal: afaik this is planned (and perhaps in HEAD, or in the type-nats branch), but not released
11:47:41 <kosmikus> conal: but I might be wrong, I haven't been actively following this
11:47:43 <conal> kosmikus: ah. thx. i think i heard the same. hopefully soon.
11:49:08 <dmwit> Oh, it's not a variable.
11:49:25 <dmwit> Okay, I get it.
11:49:59 <dmwit> Strange to see IsEven in GHC.TypeLits.
11:50:07 <dmwit> Is that really such a fundamental predicate? =)
11:50:34 <banister> which concept is more important to grok, monoids or monads?
11:50:56 <dmwit> mu
11:51:02 <elliott> dmwit++
11:51:18 <dmwit> Grasp types and the operations on those types.
11:51:24 <dmwit> Name those operations after monoids and monads later.
11:51:26 <tac> banister: monoids are more fundamental. If you want to do any Haskell, though, you need to know about monads.
11:51:43 <tac> monoids you can learn about over lunch.
11:52:03 <banister> thx:)
11:52:43 <josephle> I wonder if the intuition of seeing monoids everywhere will make it easier for you to spot the monads.
11:52:48 <dmwit> You should learn about IO pretty early. You should learn about lists pretty early. You should learn about adding and multiplying pretty early.
11:53:01 <dmwit> Later, you can notice that IO and lists have some things in common, and that adding and lists have some things in common.
11:53:18 <dmwit> But those should come after IO and lists and numbers are all facile.
11:57:13 <erisco> dolio, I need a bit more nudging I guess. http://pastebin.com/xhDrzAex so \> isn't exactly replaced, because I have to put the meat of how the parsing happens somewhere...
11:57:17 <mauke> The paste xhDrzAex has been copied to http://paste.tryhaskell.org/90746
11:57:29 <erisco> dolio, I presume it goes into the 'f' in f <$> a <*> b?
11:58:08 <dmwit> erisco: If that data type is really your Parser data type, then you've written the right instances.
11:58:19 <dmwit> But I don't believe your real Parser a is just an a.
11:58:38 <erisco> well no it isn't, but I didn't think I could write the instances otherwise
11:58:46 <dmwit> uh?
11:58:55 <erisco> *shrug* guess I'll try again
11:59:12 <dmwit> Are you using the same type as the other day when I was helping you?
11:59:20 <erisco> approximately
11:59:44 <dmwit> Then perhaps it will help to observe that nas is fmap and (\>) has most of the code you need to implement (<*>).
11:59:55 <erisco> I was working with type alias  Parser t n = ListView t -> ParseResult t n
12:00:13 <erisco> yeah I realized it is fmap :) I figured out the Functor thing and am using that now
12:00:53 <erisco> so do I have   data Parser t a = Parser (ListView t -> a) instead of just Parser a?
12:01:21 <erisco> I ran into compile issues definining Applicative because it couldn't infer any 'ol 'a' was a ListView t-> a
12:01:28 <erisco> so perhaps I need a constraint or something?
12:01:33 <dmwit> Why not Parser (ListView t -> ParseResult t a) ?
12:01:45 <erisco> I feel like a finless fish trying to swim upstream right now
12:02:00 <erisco> right that
12:04:24 <erisco> dmwit, but I am confused then on how I write an instance for Functor, for example, because I get type errors "couldn't match b with ListView t -> ParseResult t a" and such
12:05:35 <erisco> the types I am working with are constrained, and Functor doesn't share those constraints, or I don't know how to specify them
12:10:27 <Luke> when I try the example of "sepBy" from atto parsec, it fails
12:10:35 <Luke> " commaSep p  = p `sepBy` (symbol ",")"
12:10:43 <Luke> "Result: incomplete input"
12:10:54 <Luke> I'm assuming that's meant to parse a comma separated value line
12:11:25 <Luke> http://hackage.haskell.org/packages/archive/attoparsec/0.10.4.0/doc/html/Data-Attoparsec-Combinator.html
12:11:36 <erisco> dolio, yeah I dunno I'm entirely lost again on this
12:12:18 <erisco> dolio, I don't exactly see how I can make   a <*> b  mean parse a then parse b
12:15:24 <erisco> hang on burst of idea here
12:16:02 <jfischoff> erisco: have you seen this http://www.cs.tufts.edu/~nr/cs257/archive/doaitse-swierstra/combinator-parsing-tutorial.pdf
12:16:20 <erisco> no but thanks
12:16:39 <c_wraith> That's a great paper
12:17:01 <dmwit> erisco: There's no good way to write a Functor instance if your fmap requires a constraint on either the input our output type of the functions you can fmap.
12:17:10 <dmwit> You can write an instance for a modified class.
12:17:21 <jfischoff> c_wraith: one of my favorites :)
12:17:22 <dmwit> Or you can just call your function fmap' or something. ;-)
12:18:00 <dmwit> erisco: Also, for making (a <*> b) mean "parse a then parse b", isn't that what (\>) does? ;-)
12:18:20 <dmwit> ?let data Parser a
12:18:20 <lambdabot>  Defined.
12:18:42 <erisco> dmwit, yes but dolio was explaining how it is quite similar to Applicative, and I can now half see why
12:18:44 <Luke> sepBy (take 3) (char ',') "123,123,123" -- fails with "Result: incomplete input. Am i misunderstanding what sepBy is for in atto parsec?
12:18:54 <erisco> but I'm missing the "this goes here" and "that goes there" understanding
12:18:59 <erisco> working on it
12:19:26 <dmwit> :t let nas :: (a -> b) -> (Parser a -> Parser b); nas = undefined; (\>) :: Parser a -> Parser b -> Parser (a, b); (\>) = undefined in \a b -> nas (\(f, x) -> f x) (a \> b)
12:19:27 <lambdabot> Parser (t -> b) -> Parser t -> Parser b
12:19:32 <dmwit> :t (<*>)
12:19:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:19:44 <dmwit> erisco: Does this help?
12:20:19 <joshc> # /window 14
12:20:21 <joshc> err...
12:20:26 <jfischoff> ha
12:20:51 <erisco> in so much that the signatures look similar, which I get, but otherwise, no :P
12:21:04 <erisco> I'm trying a couple things so we'll see
12:21:37 <Luke> anyone?
12:22:54 <sasel> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUC
12:22:56 <sasel> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUC
12:22:58 <sasel> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUC
12:23:35 <spammerdeluxe>  A modern-day "digital" computer, as opposed to an older "analog" computer, operates on the principle of two possible states of something – "on" and "off". This directly corresponds to there either being an electrical current present, or said electrical current being absent. The "on" state is assigned the value "1", while the "off" state is assigned the value "0".
12:23:57 <dmwit> idoru++
12:24:18 <Jeanne-Kamikaze> he has been doing lots of brainfuck apparently
12:24:30 --- mode: ChanServ set +o monochrom
12:24:49 <jfischoff> @slap Jeanne-Kamikaze
12:24:49 <lambdabot> stop telling me what to do
12:24:50 <fizbin> To be fair, I just thought sasel was expressing typical discomfort with getting complicated code to compile.
12:24:52 <Jeanne-Kamikaze> the second spam message is at least informative
12:25:04 --- mode: monochrom set +b *!327550*@*
12:25:24 <bscarlet> and wrong
12:25:36 <dmwit> Luke: Could not reproduce.
12:25:37 <jfischoff> That's more how I feel about not using Haskell for so long
12:25:46 <dmwit> Luke: parseOnly (sepBy (Data.Attoparsec.take 3) (char ',')) "123,123,123"
12:25:47 <dmwit> Right ["123","123","123"]
12:25:52 <Luke> wtf
12:26:05 <xilo> anyone how do to get documentation lookup in vim?
12:27:11 <Luke> dmwit: I was using eitherResult . parse, could that be causing the problem? parseOnly works for me too
12:27:15 <fosha> F.U.C.K. Y.O.U. 1F.U.C.K. Y.O.U2 61F.U.C.K. Y.O.U63 85F.U.C.K. Y.O.U. 12F.U.C.K. Y.O.U25 641F.U.C.K. Y.O.U663
12:27:22 <fosha> F.U.C.K. Y.O.U. 1F.U.C.K. Y.O.U2 61F.U.C.K. Y.O.U63 85F.U.C.K. Y.O.U. 12F.U.C.K. Y.O.U25 641F.U.C.K. Y.O.U663
12:27:23 --- mode: ChanServ set +o geekosaur
12:27:25 <fosha> F.U.C.K. Y.O.U. 1F.U.C.K. Y.O.U2 61F.U.C.K. Y.O.U63 85F.U.C.K. Y.O.U. 12F.U.C.K. Y.O.U25 641F.U.C.K. Y.O.U663
12:27:31 --- mode: geekosaur set -o geekosaur
12:27:42 <c_wraith> idoru is really quite on-the-spot
12:27:52 <xilo> me
12:28:04 <osfameron> xilo: :help
12:28:11 <fizbin> See, the spammers that leave a URL I at least understand what they're doing. What's with this crud though?
12:28:14 <xilo> osfameron: huh
12:28:24 --- mode: monochrom set +b *!~NIGGER@*
12:28:26 <osfameron> xilo: documentation lookup in vim?
12:28:33 <dmwit> Luke: I suppose it must. In the docs, eitherResult doesn't handle Partial results at all.
12:28:33 <xilo> asante: haskell documentation...
12:28:38 <xilo> er osfameron
12:28:44 <geekosaur> they've been hitting a couple other channels I'm in too. guess the kiddies are bored or something
12:28:48 <osfameron> we all look the same on irc ;-)
12:28:50 <xilo> this is haskell why would i ask about regular vim documentation in here lol
12:28:53 <asante> ;)
12:28:58 <edkk> hahaha
12:29:08 <Luke> dmwit: I thought it shouldn't need to given the complete input given
12:30:01 <dmwit> Your parser returns a Partial result because it can accept more input.
12:30:02 <geekosaur> I think the type still has to allow for it? so if you're not working with partials you need to use a parse entry point with a different type, e.g. parseOnly
12:30:16 <xilo> osfameron: looking for something like clojure has where you can hit a key on a type and it will bring up doc search results or something
12:30:18 <dmwit> Partial means "can accept more", not "can't stop here".
12:30:40 <geekosaur> ah
12:31:13 <Luke> dmwit: ah I see... it's not that it expects more input, a partial means "wants more input"
12:31:28 <dmwit> more like "willing to take more input"
12:32:19 <Luke> dmwit: but can I also get the results back so far?
12:32:33 <dmwit> Obviously, since parseOnly does. =)
12:33:20 <dmwit> Have you read the documentation?
12:33:40 <dmwit> I strongly recommend it, since I'm staring at the answer. ;-)
12:33:50 <Luke> i've read the docs
12:33:53 <Luke> they don't explain this at all
12:34:00 <bb010g> Is there any way to create a function like 'funfun acc x = if x == 0 then acc else funfun $ acc + x' with Haskell's type system?
12:34:02 <Luke> "Run a parser that cannot be resupplied via a Partial result."
12:34:12 <Luke> parse docs are "Run a parser."
12:35:01 <dmwit> http://hackage.haskell.org/packages/archive/attoparsec/latest/doc/html/Data-Attoparsec-Types.html#t:IResult
12:35:08 <Luke> yup that's what I'm looking at
12:35:29 <Luke> i think you're reading it with the answer already in mind ;-)
12:35:30 <erisco> bleh I don't understaaaaaaaand
12:35:48 <erisco> so is it like    parse <$> token 'a' <*> token 'b'   ?
12:36:04 <erisco> I don't know what needs to go on the left
12:36:29 <jfischoff> erisco:  You should do the first bit of that tutorial
12:36:29 <erisco> I'm thinking okay... some sort of function that does the parsing... so
12:36:29 <erisco> parse :: (a -> b -> c) -> Parser t a -> Parser t b -> Parser t c
12:36:29 <dmwit> Luke: Really? "To indicate that no more input is available, use an empty string." <- sounds pretty clear to me
12:37:05 <Luke> dmwit: it doesn't say that feeding it a complete input wont also return a Done
12:37:20 <jfischoff> bb010g: your function is takes 2 or 1 args, not really sensible.
12:37:27 <dmwit> Luke: What does "also" mean here?
12:37:33 <dmwit> You can only return one thing.
12:37:49 <jfischoff> bb010g: you probably want to use fold anyway
12:37:59 <Luke> dmwit: nothign in the docs indicates that feeding it a complete input wont return done
12:38:13 <Luke> dmwit: those docs make it sound like you can force a done on incomplete input with an empty string
12:38:24 <Eduard_Munteanu> Can I ask cabal/ghc to keep going in spite of errors? I want to see all hidden packages so I can add them to build-depends.
12:38:51 <bb010g> I'm just trying to see if it can be done. I know it doesn't make much sense.
12:38:52 <dmwit> re: "nothing in the docs indicates that feeding it a complete input wont return done" <- incorrect
12:39:02 <dmwit> The introduction text says: " If your parser reaches the end of a fragment of input and could consume more input, it will suspend parsing and return a Partial continuation."
12:39:14 <Luke> dmwit: exactly
12:39:51 <dmwit> re: "those docs make it sound like you can force a done on incomplete input with an empty string" <- don't agree; both Done and Fail seem like reasonable results of handing Partial's contents an empty string to me
12:39:54 <Luke> again that makes it sound like if the parser reaches the end and it wasn't a fragment (it was a complete parse) it would return Done
12:40:05 <dmwit> It doesn't sound like that to me.
12:40:08 <dmwit> It's very precise.
12:40:14 <Luke> really it's not =)
12:40:22 <dmwit> If it could consume more input, it will return Partial.
12:40:25 <dmwit> Just as you observed.
12:40:26 <jfischoff> bb010g: how would the second invocation of funfun work?
12:40:47 <Luke> dmwit: right, that doesn't mean the docs only describe that and nothing more though
12:41:00 <dmwit> That is the exact sentence it has!
12:41:09 <dmwit> I've just cut unnecessary words out!
12:41:10 <Luke> cool off a bit. just telling you how i read it
12:41:19 <Luke> no need to get excited
12:41:30 <geekosaur> sounds like you're applying a lay interpretation to a formal description
12:41:39 <Luke> geekosaur: totally could be happening
12:42:34 <Luke> " If your parser reaches the end of a fragment of input and could consume more input, it will suspend parsing and return a Partial continuation." + "Supply this continuation with more input so that the parser can resume. To indicate that no more input is available, use an empty string."
12:42:36 <Luke> this doesn't preclude a Done being returned if complete input is given
12:43:11 <Luke> the docs for Done: "The parse succeeded. The t parameter is the input that had not yet been consumed (if any) when the parse succeeded."
12:44:18 <asdfasd_> http://www.youtube.com/watch?v=c7HhYE_ddtQ
12:44:19 <Luke> nothing here says a Done can't be returned on a complete parse. Only that if you receive a partial (which was described as occurring on a fragment parse) that you can get a Done by feeding it an empty string.
12:44:28 <erisco> I can write stuff like (,,) <$> token 'a' <*> token 'b' <*> token 'c' but that isn't remotely what I want
12:44:53 <erisco> but that is all I see this Applicative thing doing
12:44:59 <Luke> dmwit: I know you think it's reasonable but "don't agree; both Done and Fail seem like reasonable results of handing Partial's contents an empty string to me" doesn't show how it's a complete doc specification
12:45:19 <bb010g> jfischoff: If x is not zero, then add x to the accumulator and return a partially applied funfun. If x is zero, then return the accumulator. Example: 'funfun 5 6 7 8 9 2 0 = 37'
12:45:54 <benmachine> Luke: it sounds like you could have a Done returned iff the parser knows it couldn't take any more input
12:46:02 <Luke> right
12:46:06 <Luke> that's what I thought too
12:46:20 <dmwit> That is the correct interpretation.
12:47:24 <Luke> dmwit: I think we have a miscommunication here. I fed it a complete parse and it returned a Partial
12:47:26 <geekosaur> Luke, but that means you need to "parse" an EOF marker or something; your parser fragment is incomplete
12:47:27 <erisco> and the number of arguments to the function on the left must be the number of things on the right
12:47:30 <bb010g> jfischoff: Basically, I'm trying to make a function of variable arity.
12:47:33 <erisco> so I don't even know what is being gained :s
12:47:40 <josephle> bb010g: can you write the type signature for funfun? That might tell you if it's possible to write funfun.
12:47:59 <dmwit> Luke: You fed it a complete parse, yes. But you didn't feed it something that would cause it to know it couldn't take any more input.
12:48:00 <geekosaur> you need to return an explicit "this parser is finished", not just fall off the end
12:48:04 <dmwit> Are you seeing the distinction here?
12:48:13 <Luke> dmwit: yes but you never said that before ;-)
12:48:19 <jfischoff> bb010g: You can make things that work like function of variable arity by using induction with type classes. Your definition would be different though.
12:48:19 <dmwit> I did too.
12:48:25 <Luke> geekosaur was the first to mention that
12:48:27 <geekosaur> becuase combining parser fragments is useful (and so is being able to test them, hence parseOnly)
12:48:30 <benmachine> Luke: regardless of who said what when, are we clear now?
12:48:32 <dmwit> 15:29 < dmwit> Partial means "can accept more", not "can't stop here".
12:48:34 <Luke> yea that makes sense now
12:48:38 <Luke> thanks
12:48:47 <geekosaur> Luke, maybe we're more familiar with parsers; it's something of a given
12:48:51 <osfameron> xilo: that sounds like a good idea.  I haven't done much haskell-specific config for vim tbh
12:49:09 <bb010g> jfischoff: How would that work?
12:49:09 <Luke> geekosaur: that's what I meant by "if you read it with the answer in mind it makes sense"
12:49:17 <Luke> I didn't have the answer in mind obviously =)
12:50:40 <geekosaur> (so, if you do not have some kind of explicit "we're done" indication then you do not (for example) handle garbage after the expected input. if you expect that to be automatic then you can't compose parser fragments properly
12:50:44 <Luke> the part I didn't understand was that if "sepBy" ended with a complete parse, it's still considered a fragment because it can always take more
12:50:45 <geekosaur> )
12:50:56 <Luke> I was thinking the fragment would be considered only for the "take 3"
12:51:12 <Luke> geekosaur: yeah it makes sense now
12:55:14 <erisco> the entire idea of Applicative seems to be to operate on data wrapped in another type in a convenient way ... okay, vague, and perhaps useful, but it doesn't remotely seem to apply here ... maybe I'm blind or I am doing things in a different way
12:55:55 <byorgey> erisco: "the entire idea of Applicative seems to be to operate on data wrapped in another type in a convenient way" -- no, that's Functor.
12:56:14 <erisco> but "parse A then parse B" as  a \> b  seems to be, at best,  \> <$> a <*> b  or something, which is pointless
12:56:19 <byorgey> the entire idea of Applicative is to *combine* structured things (e.g. parsers) in a convenient way.
12:56:33 <erisco> I don't see what is being combined
12:56:45 <byorgey> a and b are being combined into one parser.
12:57:11 <erisco> I look at an example like   (+) <$> (Just 5) <*> (Just 2)  and all I can really see is (5 + 2) while ignoring the fact it is wrapped in Maybe
12:57:15 <monochrom> don't rush to "describe in your own words to show that you understand" (because you don't understand). and you don't need to describe. just focus on use. get it to work.
12:57:58 <erisco> monochrom, what? I am just saying what I understand about it -- I am not asserting that I am correct
12:58:05 <byorgey> erisco: sure, in that case it's just doing 5 + 2.  But that also allows (+) <$> Nothing <*> Just 2 = Nothing.
12:58:23 <byorgey> erisco: we have enhanced arithmetic with the possibility of failure, which is automatically propagated through any computation.
12:58:35 <monochrom> no, my point is not correct vs incorrect. my point is wise use of time.
12:59:54 <monochrom> if you know (+) <$> (Just 5) <*> (Just 2) = Just (5+2), (+) <$> (Just 5) <*> Nothing = Nothing, you already understand.
13:00:46 <byorgey> "but "parse A then parse B" as  a \> b  seems to be, at best,  \> <$> a <*> b  or something, which is pointless" -- I don't understand this.
13:00:55 <erisco> byorgey, I dunno, I see the benefit of the Nothing case, but I don't have anything like that
13:01:01 <monochrom> if you also know that it carries over to (\x y z -> x+y+z) <$> (Just 1) <*> (Just 10) <*> (Just 100), you're golden.
13:01:17 <byorgey> the point is not to apply \> to a and b using different notation.  The point is to encapsulate the pattern of \> in the Applicative instance.
13:01:23 <erisco> byorgey, if I have  data MyType a = MyType a   what is the real point of Applicative? because that is what I have
13:01:52 <byorgey> then there is none.  but I thought you were building parsers.
13:01:55 <elliott> if you have data MyType a = MyType a, what is the point of MyType?
13:01:55 <erisco> I can define an operation  MyType a -> MyType b -> MyType (a, b)  and I don't see what Applicative is doing for me
13:02:08 <erisco> elliott, I don't know!
13:02:31 <erisco> I don't have a "parser" type ... I introduced one just for the sake of trying to figure out how Applicative would work
13:02:38 <monochrom> MyType can be made an Applicative but it is uninteresting.
13:02:54 <erisco> well that is what I am seeing right now: uninteresting :s clearly I am putting it on the wrong thing
13:02:58 <dmwit> erisco: What Applicative is doing for you is providing a familiar interface, nothing more.
13:03:06 <elliott> dmwit: not true
13:03:14 <elliott> it is also providing everything anyone has ever written to be generic over Applicatives
13:03:17 <byorgey> erisco: so what was the type of (\>) before ?
13:03:19 <elliott> for instance, you get to use Traversable.
13:03:22 <elliott> that's valuable.
13:03:42 <erisco> byorgey, it is  Parser t a -> Parser t b -> Parser t (ParseResult t a, ParseResult t b)  and Parser is a type alias
13:03:47 <elliott> define empty and (<|>) for your parser type, suddenly you get a "many" parser combinator for free
13:03:51 <dmwit> Right, but you don't get to e.g. magically write less code when implementing something that has the types of the Applicative methods or anything like that.
13:03:51 <byorgey> erisco: what is PArser a type alias for?
13:03:53 <erisco> byorgey, because a "parser" is a function
13:03:54 <elliott> and then you can use "asum".
13:03:56 <dmwit> So I should have said that instead.
13:04:00 <byorgey> erisco: sure
13:04:13 <erisco> byorgey, and I had no need for a concrete type.. and introducing one seems to be leading to nothing interesting
13:04:25 <byorgey> erisco: so instead of  type Parser t a = ...,  make   newtype Parser t a = Parser ...
13:04:35 <byorgey> erisco: now you can make   instance Applicative (Parser t) where ...
13:04:37 <erisco> I did that... but I don't see what I gain :s
13:04:41 <erisco> yes I know, I did that
13:04:50 <byorgey> erisco: but you just said you have  MyType a = MyType a.
13:05:06 <erisco> which is analogous to  data Parser a = Parser a
13:05:06 <byorgey> but now you are telling me you have  Parser a = Parser (some function stuff).
13:05:41 <byorgey> erisco: what was the definition of the Parser type alias before?
13:05:42 <erisco> what? no I never said that
13:05:53 <erisco> type Parser t n = ListView t -> ParseResult t n
13:06:01 <byorgey> (16:03) <    erisco> byorgey, because a "parser" is a function
13:06:07 <elliott> data Parser t n = Parser (ListView t -> ParseResult t n)
13:06:15 <elliott> is what you should give an Applicative instance for
13:06:16 <erisco> byorgey, yes, the concept of a parser in my code is a function, not a data type
13:06:21 <elliott> (actually you should use newtype not data. but it does not matter)
13:06:28 <byorgey> erisco: right.
13:06:44 <byorgey> so  newtype Parser t n = Parser (ListView t -> ParseResult t n)
13:06:52 <byorgey> that is not analogous to  data Parser a = Parser a.
13:07:03 <erisco> elliott, well I ran into the problem where my instance would not work because it couldn't infer ListView t -> ... from the plain ol' type 'b'
13:07:16 <erisco> and then I was told "you can't make any meaningful instance with that restriction" so I gave up
13:07:20 <monochrom> that is a separate problem.
13:07:21 <erisco> and did   data Parser a = Parser a
13:07:27 <elliott> erisco: I don't understand.
13:07:32 <erisco> neither do I
13:07:46 <erisco> finless fish swimming upstream I tell you :P
13:08:00 <byorgey> ok. Well, everyone can at least agree that  Parser a = Parser a  is uninteresting and will not shed any light on Applicative.
13:08:04 <erisco> writhing and going backwards mainly
13:08:34 <dmwit> erisco: Wait, I thought there was a typeclass constraint.
13:08:36 <erisco> byorgey, awesome :)
13:08:45 <dmwit> erisco: That was what I meant when I said there was no meaningful instance.
13:08:57 <erisco> dmwit, I dunno, I probably misunderstood you and then went spiraling down the wrong path
13:09:03 <S_J> So quickCheck perhaps gives you a higher percentage code coverage, but does that mean it tests better than unittesting? or that it tests more less important code maybe...?
13:09:48 <monochrom> use both quickcheck and unit-testing. end of "debate".
13:09:50 <byorgey> S_J: are table saws better than hammers?
13:10:22 <monochrom> any more false-dichotomies?
13:10:31 * elliott swears S_J has already asked that exact question...
13:10:46 <elliott> but, monochrom++
13:11:10 <monochrom> was it answered last time? I'm fine with re-asking if unanswered last time.
13:11:28 <aristid> table saws are _so much_ better than hammers
13:11:31 <monochrom> otoh if it was answered last time, then this time is a ban.
13:12:05 <erisco> so presuming data Parser t n = Parser (ListView t -> [ParseResult t n])  how do I write    instance Functor (Parser t) where     so that I don't get the type error? I need to add a constraint somehow?
13:12:08 <byorgey> (19:35) <       S_J> so, unittesting, property based testing, code coverage. what more is there to test your code?
13:12:15 <byorgey> different question, and it was unanswered.
13:12:18 <erisco> (I'm not looking for the implementation, just how to deal with the types properly)
13:12:31 * earthy_ uses fscheck as on of his unit test frameworks
13:12:41 <earthy> (ofcourse, C#, but the same principles apply)
13:12:45 <monochrom> ok good, then he/she has won a few more hours of stay time from me
13:12:59 <byorgey> erisco: you don't need any constraints.
13:13:05 <earthy> test as much as you can.
13:13:14 <earthy> in as many different ways as you can.
13:13:19 <byorgey> erisco: did you already try it and run into some sort of error?
13:13:20 <earthy> it can only serve to make your code better.
13:13:27 <erisco> byorgey, okay... but if I write    fmap f (Parser p) = Parser (f p)    I get a type error
13:13:34 <S_J> For a simple module with 20 if statements, each having 2 possible alternatives, there are 2**20 ~ 1 million different paths of execution. wouodnt that be 2**16 or am i thinking wrong?
13:14:00 <earthy> wouldn't what be 2^16?
13:14:01 <byorgey> erisco: what is the type of 'f' there? and what is the type of 'p'?
13:14:45 <koala_man> are the if statements independent?
13:14:51 <earthy> S_J: quickcheck makes for a *different* kind of test, not necessarily a better one.
13:15:17 <erisco> hang on
13:15:27 <S_J> i meant 2^20 obv. but how do you calc the number of paths of 20 if-else
13:15:58 <erisco> the cogs in this brain are slowly turning ... the 0.3W light bulb is beginning to be detectably dim
13:16:08 <byorgey> =)
13:16:22 <earthy> S_J: plus, it is easy to write reasonably good quickcheck properties.... thereby making it a small investment with a high payoff
13:16:56 <benmachine> some people write quickcheck properties in their docs
13:16:59 <benmachine> then they serve a dual purpose
13:17:38 <earthy> in the production code I've seen the unit tests and fscheck properties *are* the docs. :)
13:17:40 <byorgey> S_J: if you have 20 binary choices, then the total number of choices is 2^20.
13:17:56 <byorgey> 20 *independent* binary choices, that is.
13:20:17 <erisco> I... figured it out
13:20:27 <byorgey> =D
13:20:34 <erisco> well for Functor anyways... and it is so herpy derpy that... ugh well
13:20:51 <byorgey> what do you mean by herpy derpy?
13:21:26 <erisco> what I needed to do I should have already known ... but instead my brain shut off
13:21:35 <byorgey> hehe
13:22:22 <erisco> byorgey, are you unfamiliar with the herp and derp? :)
13:23:16 <byorgey> yes.
13:24:21 <erisco> ah, well, when one recognizes a failure of common sense, they might exclaim "herp derp" ... usually in an exaggerated voice
13:24:54 <erisco> like ... "I was looking all around the house for my keys and here they were in my pocket! herp derp."
13:28:06 <erisco_> okay so 'pure' seems impossible to define though...
13:28:23 <erisco_> if it requires that any type 'a' be made into Parser t a  then it isn't doable
13:29:12 <elliott> why not?
13:29:14 <erisco_> I can't do that unless 'a' is actually  (ListView t-> [ParseResult t n])
13:29:21 <elliott> wat
13:29:24 <elliott> are you still using Parser a = Parser a?
13:29:31 <elliott> we told you that definition sucks. :p
13:29:31 <erisco_> because data Parser t n = Parser (ListView t -> [ParseResult t n])
13:29:35 <elliott> right.
13:29:37 <elliott> so you need to write
13:29:38 <erisco_> right
13:29:40 <erisco_> so what am I missing
13:29:40 <elliott> a -> Parser t a
13:29:47 <erisco_> what?
13:29:48 <elliott> if you use the constructor, that's equivalent to writing
13:29:54 <elliott> a -> ListView t -> [ParseResult t a]
13:30:00 <elliott> because pure :: a -> f a, and f = Parser t a
13:30:05 <elliott> er
13:30:06 <elliott> because pure :: a -> f a, and f = Parser t
13:30:08 <elliott> beacuse you're giving an instance for Parser t.
13:30:49 <erisco_> okay, but ... it just doesn't make sense as an operation
13:31:13 <dolio> What are the 'labels' in your parse result?
13:31:16 <elliott> erisco_: why not?
13:31:38 <elliott> erisco_: the semantics of (pure x) is meant to be "a parser that consumes no input and yields the parse result x", if that spoiler helps.
13:31:46 <erisco_> elliott, well what do I do? make up an arbitrary function to stick in Parser?
13:32:01 <erisco_> uhh what
13:32:11 <elliott> I don't understand.
13:32:13 <erisco_> it is supposed to parse whatever 'a' is?
13:32:24 <elliott> no, why would it? or: what do you mean?
13:32:31 <erisco_> well you just said that yes?
13:32:38 <elliott> I don't think so
13:32:52 <elliott> at least, if that's what you get out of what you said, then either I don't know what you mean by "parse whatever 'a' is", or you misinterpreted :)
13:33:23 <erisco_> okay by the sounds of it I am making some dummy definition to stick the 'a' into?
13:33:32 <erisco_> I don't get the point of that ... I can't possibly make it make sense :S
13:33:55 <elliott> okay, well, a normal parser consumes some input and then maybe gives some parse results, right?
13:34:10 <elliott> so imagine the most trivial kind of parser possible. one that doesn't even bother looking at its input, and has one constant parse result for all inputs.
13:34:10 <erisco_> yeah ... the best I can think of is  Parser (\v -> [])   I suppose
13:34:20 <elliott> how is ParseResult defined?
13:34:37 <erisco_> a parser returns a list of ParseResult, so an empty list seems suitable I guess
13:34:47 <elliott> that's not what you want for pure
13:34:52 <elliott> because then you're throwing away the value pure gets passed
13:34:59 <dmwit> erisco_: That doesn't look reasonable to me. And I bet the Applicative laws will agree. =)
13:35:11 <byorgey> presumably it should be a singleton list.
13:35:33 <erisco_> it isn't. that isn't how I designed my parser
13:37:13 <dmwit> If your "it isn't" message was a response to byorgey, I think you should think about it again.
13:37:38 <dmwit> I've seen more of your code than byorgey has, but agree with him anyway.
13:37:51 <dmwit> (...at least, I think I've seen more. not 100% confident)
13:37:57 <erisco_> well in general it isn't a singleton... for this pure thing, maybe it can be, but I dunno... I'll have to look at these laws I guess and see what they mean
13:39:13 <elliott> of course, pure isn't general
13:39:21 <elliott> pure is creating a very specific subset of parsers.
13:41:29 <carter> woohooo, just emailed llvm devs the patch for 256bit simd ghc calling convention :)
13:41:58 <erisco_> um, side note, wouldn't type classes be ideal for type conversions? ie toList fromList?
13:42:05 <jfischoff> carter: which means ? (I'm sure it is good though ;)
13:42:14 <carter> jfischoff it means that if it lands soon
13:42:24 <carter> and also gets into the next llvm 3.3 point release
13:42:41 <carter> that I or someone else could exposed 256bit simd
13:42:41 <carter> to ghc
13:42:48 <Gracenotes> @hoogle toList
13:42:49 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
13:42:49 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
13:42:49 <lambdabot> Data.Text.Array toList :: Array -> Int -> Int -> [Word16]
13:43:09 <carter> jfischoff the simd work in ghc so far is only for XMM (128bit) x86 registers
13:43:40 * jfischoff nods
13:44:05 <carter> and the callign convention needs to have YMM (256bit) register support
13:44:15 <carter> for AVX / AVX2 primops to be first class
13:44:21 <Gracenotes> erisco_: Foldable/Traversable handle lots of list-y conversions, but with some algebraic structure...
13:45:14 <erisco_> so they all have their own definitions, right ... seems like the sort of thing a type class would be ideal for
13:45:32 <Ankhers> cabal install is failing. How can I find out more information about why it is failing?
13:45:36 <erisco_> for any of your types having a type class for to and from conversions ... seems like an idea
13:45:54 <dmwit> erisco_: The second hit (Data.Foldable.toList) *is* the type class-polymorphic version.
13:45:57 <erisco_> helps because you don't have longer names or name conflicts
13:45:57 <Gracenotes> the ability to write toList/fromList is a property you can often generalize to also do a lot cooler stuff... for free.
13:46:10 --- mode: ChanServ set +o monochrom
13:46:10 --- mode: monochrom set -b *!327550*@*
13:46:10 --- mode: monochrom set -o monochrom
13:46:11 <solrize_> there's now some 512 bit simd stuff in high end x86's
13:46:33 <solrize_> iirv
13:46:33 <solrize_> iirc
13:47:14 <erisco_> dmwit, Gracenotes I see
13:47:41 <Gracenotes> but you can also just do that, often
13:48:47 <chrisdotcode> hola everyone
13:48:49 <erisco_> shouldn't  (MyType f) <*> b = fmap f b  ?
13:48:53 <erisco_> seems like it should be
13:49:01 <dmwit> The types don't match.
13:49:03 <dmwit> :t fmap
13:49:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:49:05 <dmwit> :t (<*>)
13:49:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:49:15 <dmwit> The (<*>) one has some extra context.
13:49:36 <erisco_> I just pattern matched off the extra f though
13:49:45 <dmwit> Oh. You did?
13:49:50 <erisco_> didn't I? :o
13:49:54 <dmwit> I guess it depends on MyType, then.
13:50:10 <dmwit> It depends on how the type is defined, I mean.
13:50:37 <dmwit> For data MyType a = MyType a, yes, that's a fine implementation; for anything else, no, it doesn't really work right.
13:50:41 <erisco_> alrighty. I just have another type problem again
13:51:51 <erisco_> dmwit, I don't really understand why it wouldn't
13:52:30 <erisco_> dmwit, fmap f (Parser p) = Parser (map (fmap f) . p)   so it should be able of taking the function a -> b and applying it to a Parser
13:52:46 <dmwit> Right, but the contained thing isn't an (a -> b).
13:52:46 <erisco_> dmwit, which is the same case I have in <*> after I strip Parser off the first arg
13:52:56 <erisco_> it isn't?
13:52:59 <erisco_> :t <*>
13:52:59 <lambdabot> parse error on input `<*>'
13:53:02 <erisco_> :t (<*>)
13:53:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:53:10 <dmwit> I'm saying that usually "foo (MyType f) = f" does not have type "MyType a -> a".
13:53:30 <dmwit> That is, the thing contained in a "MyType (a -> b)" isn't just an "a -> b".
13:53:35 <dmwit> It's a more exciting beast.
13:53:46 <erisco_> okay I am failing here
13:54:45 <dmwit> Suppose for a moment that we have "data MyType a = MyType (a -> a)".
13:54:50 <dmwit> (I know this is not the type you have.)
13:54:52 <erisco_> so I reduce  f (a -> b) to just (a -> b) by pattern matching. fmap does (a -> b) -> f a -> f b   ... no idea what <*> would want different
13:55:00 <erisco_> okay assuming
13:55:14 <dmwit> And suppose you have "x :: MyType (a -> b)".
13:55:31 <dmwit> And now we pass "x" in as the argument to a function whose definition looks like "MyType f <*> b = ...".
13:55:42 <dmwit> Then what I'm saying is that in the "..." part, "f" does not have type "a -> b".
13:55:43 <erisco_> I don't get you on x... isn't that an invalid MyType?
13:55:48 <dmwit> It has type "(a -> b) -> (a -> b)" instead.
13:55:56 <dmwit> erisco_: Nope, it's perfectly valid.
13:56:11 <erisco_> oh, right, ((a -> b) -> (a ->b))
13:56:46 <erisco_> okay but I don't understand 'f does not have type a -> b'
13:56:52 <dmwit> So, in your verbal explanation, "so I reduce f (a -> b) to just (a -> b) by pattern matching", I'm saying that you do *not* reduce "f (a -> b)" to just "a -> b" by pattern matching.
13:56:59 <dmwit> erisco_: Okay, let's deal with that, then.
13:57:03 <erisco_> how is this not mandated by MyType? what else could it be? (a -> b) -> (a -> b) is a subset of a -> a
13:57:15 <dmwit> Yes, that's true so far.
13:57:34 <erisco_> so... MyType f  then f is of type a -> b
13:57:39 <erisco_> I mean a -> a
13:57:55 <dmwit> Well, no, it's of type "(a -> b) -> (a -> b)" (assuming this came from x above).
13:58:08 <erisco_> okay sure
13:58:24 <dmwit> Okay. And are we in agreement that "(a -> b) -> (a -> b)" is not equal to "(a -> b)"?
13:58:42 <erisco_> yes
13:58:47 <dmwit> okay
13:58:54 <dmwit> So, you're convinced now, or not?
13:59:07 <erisco_> I thought there was more... no
13:59:17 <dmwit> hm
13:59:22 <dmwit> Okay, let's do it more monomorphically.
13:59:37 <dmwit> Suppose we want to write "foo :: MyType (Int -> Bool) -> MyType Int -> MyType Bool".
13:59:39 <dmwit> Okay?
13:59:59 <erisco_> okay
14:00:01 <dmwit> And we'll assume we get to use "fmap :: (Int -> Bool) -> MyType Int -> MyType Bool" while we're implementing it.
14:00:11 <erisco_> gotcha
14:00:15 <dmwit> cool
14:00:35 <dmwit> Now, we write "foo (MyType f) b = ..." to begin with because we're savvy programmers.
14:00:45 <dmwit> We can both agree that "f" has type "(Int -> Bool) -> (Int -> Bool)".
14:00:59 <dmwit> So what type does "fmap f" have?
14:01:15 <erisco_> I thought f would have type Int -> Bool?
14:01:54 <dmwit> Okay. Why did you think that?
14:02:17 <erisco_> foo :: MyType (Int -> Bool) ....  foo (MyType f) ...  therefore f :: Int -> Bool
14:02:34 <dmwit> But we have written "data MyType a = MyType (a -> a)".
14:02:49 <dmwit> So perhaps we are also getting confused by the fact that this defines two different values, both named MyType.
14:02:55 <erisco_> we did? I thought we were doing MyType (Int -> Bool)
14:03:04 <dmwit> Let's write "data MyType a = MkMyType (a -> a)".
14:03:31 <erisco_> no I just thought MyType was a type not a type constructor
14:03:32 <dmwit> Now we will have to write "foo :: MyType (Int -> Bool) -> MyType Int -> MyType Bool" as before but "foo (MkMyType f) b = ..." instead.
14:04:01 <erisco_> I thought data MyType = MyType (Int -> Bool) ... so let me rethink going a -> b
14:04:04 <erisco_> a -> a
14:04:36 <dmwit> Well, if we had defined "data MyType = MyType (Int -> Bool)", then the type signature "foo :: MyType (Int -> Bool) -> MyType Int -> MyType Bool" wouldn't even be valid.
14:04:47 <dmwit> Since in that declaration "MyType" doesn't take any type parameters.
14:05:29 <Gracenotes> you can do something like data MyType a = MyType (Int -> a)
14:05:42 <erisco_> why must we be mapping functions... :s doesn't help me follow along. is that necessary?
14:05:51 <Gracenotes> or... a -> a... or anything with a... anywho.
14:05:52 <dmwit> erisco_: Nope. Propose a simpler type.
14:06:02 <dmwit> Gracenotes: Yes, we were using (a -> a).
14:06:22 <dmwit> erisco_: More complicated than "data MyType a = MyType a", though. =)
14:06:40 <dmwit> erisco_: How about "data MyType a = MyType a a"?
14:06:41 <erisco_> fmap f :: MyType (Int -> Bool) -> MyType (Int -> Bool)   I would presume
14:07:15 <dmwit> Yes!
14:07:17 <dmwit> That's exactly right. =)
14:07:29 * erisco_ gives himself a biscuit
14:07:51 <dmwit> So now it should be clear why "fmap f b" isn't right: we have "b :: MyType Bool", but "fmap f" is expecting an "MyType (Int -> Bool)".
14:07:52 <erisco_> okay so what's wrong then
14:08:41 <dmwit> (Recalling that the proposed implementation was "foo (MyType f) b = fmap f b".)
14:08:42 <erisco_> wait... er... how did that happen? :s
14:08:58 <dmwit> Work through it in your head again. Let me know where you get stuck. =)
14:10:48 <erisco_> okay something is drastically flawed about my understanding here...
14:11:00 <dmwit> Excellent!
14:11:12 <erisco_> no that isn't excellent! lol
14:11:24 <dmwit> It means you get to learn something. =)
14:11:35 <erisco_> MyType (Int -> Bool) -> MyType (Int) -> MyType (Bool)  to me this is saying we're going to give the Int  to Int -> Bool and then arrive at a Bool
14:11:48 <erisco_> this evidently isn't what is actually supposed to happen?
14:11:54 <dmwit> That's what we'd hope to do, yes.
14:12:08 <dmwit> But the pesky "MyType" in the way means we have to deal with whatever extra structure "MyType" has.
14:12:19 <dmwit> We can't just "fmap" it away -- we have to actually write some code, gosh darn it.
14:12:31 <erisco_> so why does fmap get (Int -> Bool) -> (Int -> Bool) and not just (Int -> Bool)
14:12:55 <dmwit> Because that's the information that's stored in a MyType (Int -> Bool).
14:13:31 <dmwit> If the only thing stored in a MyType (Int -> Bool) were an actual (Int -> Bool), it would kind of be a pointless type to have around.
14:13:43 <erisco> ... what? :(
14:14:14 <erisco> fmap :: (a -> b) -> MyType a -> MyType b  right? sorry, this is what I was saying originally, I know, but I don't get why its wrong
14:14:37 <dmwit> That is the type of fmap, assuming we can write a Functor instance for MyType at all.
14:14:41 <erisco> if I've peeled an a -> b out of MyType, which I did, it is an Int -> Bool, then what is wrong?
14:14:57 <erisco> where does (Int -> Bool) -> (Int -> Bool) ever get involved?
14:15:18 <dmwit> Let's eliminate a's and b's for now. Please try to ask the question in our more monomorphic setting.
14:15:32 <dmwit> Also, "MyType" needs an argument.
14:15:34 <dmwit> So try the question again.
14:17:00 <Gracenotes> it also makes sense in kind of a types-as-game-theory way
14:17:42 <dmwit> I feel that explaining the "types-as-game-theory" idea may not be a pedagogically sound road to walk down at the moment.
14:17:43 <erisco> dmwit, where was MyType msising an argument?
14:17:53 <dmwit> "...out of Mytype, ..."
14:18:00 <elliott> dmwit: (wait, were you pretending there was a Functor instance for Endo above?)
14:18:09 <dmwit> elliott: Yeah, sure, why not.
14:18:15 <elliott> heh
14:18:16 <erisco> dmwit, yeah, (MyType f) :: (MyType (a -> b))
14:18:41 <Gracenotes> heh. fair enough. "to get a blah, you need a blah, ..." adversaries notwithstanding.
14:18:48 <dmwit> erisco: That's a tricky thing to say, because type variables are funny. Try giving a concrete type with Ints and Bools and stuff.
14:19:01 <dmwit> Just trust me on this one for now.
14:19:07 <dmwit> We can get to exactly why a bit later.
14:19:17 <erisco> (MyType f) :: (MyType (Int -> Bool))
14:19:32 <erisco> we can agree that is the first argument to <*> right?
14:19:40 <dmwit> Right.
14:20:01 <erisco> okay, and the second argument is MyType Int, right?
14:20:21 <dmwit> The second argument has type "MyType Int", yes.
14:20:25 <erisco> right
14:21:02 <erisco> okay, so I have a mapping function f :: Int -> Bool and a var of type MyType Int
14:21:24 <erisco> so, fmap :: (Int -> Bool) -> MyType Int -> MyType Bool right?
14:21:40 <erisco> well, I have both arguments, so I use em
14:21:44 <erisco> and I should get a MyType Bool
14:21:46 <dmwit> whoa whoa whoa
14:21:47 <dmwit> stop
14:21:52 <erisco> shoot me
14:22:02 <chrisdotcode> are there exercise answers for the typeclassopedia article somewhere?
14:22:05 <dmwit> You do not have a mapping function f :: Int -> Bool.
14:22:14 <erisco> why not? :(
14:22:16 <dmwit> You have a function "f :: (Int -> Bool) -> (Int -> Bool".
14:22:19 <dmwit> You have a function "f :: (Int -> Bool) -> (Int -> Bool)".
14:22:21 <erisco> asd":fkasdiopfjsdio;afas
14:22:25 <erisco> how?
14:22:42 * elliott wonders if e.g. [a] wouldn't be simpler than (a -> a).
14:22:48 <dmwit> I really don't know how else to say this.
14:22:57 <erisco> oh fuck
14:23:06 <dmwit> MyType a contains an (a -> a); therefore MyType (Int -> Bool) contains an ((Int -> Bool) -> (Int -> Bool)).
14:23:22 <dmwit> elliott: You're welcome to take over. =)
14:23:28 <erisco> f :: (Int -> Bool) -> (Int -> Bool)
14:23:32 <dmwit> yes
14:23:43 <erisco> well what in the world do I do with that then :s
14:23:48 <dmwit> exactly =P
14:23:48 <elliott> dmwit: sorry, I'll stop backseat tutoring :p
14:24:07 <dmwit> erisco: Okay. So, we've established that "MyType f <*> b = fmap f b" is no good. Right?
14:24:18 <erisco> yes
14:24:21 <dmwit> Fine, so you have to write some actual code for your parser instance, too. =)
14:24:38 <dmwit> (I've written the code here, in-channel, already, by the way, using (\>) and fmap.)
14:24:48 <dmwit> (If you want spoilers, find it; if not, don't. ;-)
14:24:59 <erisco> I have it copied and read it and all
14:24:59 <ParahSai1in> @ty (\>)
14:25:00 <lambdabot>     Not in scope: `\>'
14:25:00 <lambdabot>     Perhaps you meant one of these:
14:25:00 <lambdabot>       `>>' (imported from Control.Monad.Writer),
14:25:05 <erisco> but it was opaque to me
14:25:12 <dmwit> Okay, no problem.
14:25:20 <dmwit> That means you get to enjoy inventing it yourself. =)
14:25:34 <erisco> I feel like I am learning how to add 2 + 2 and I have a lobotomy
14:26:48 <Gracenotes> If you like the polymorphic interpretation, and if it's confusing ignore it, then taking <*> :: f (a -> b) -> f a -> f b, you're given f (a -> b) and f a and your challenge is to come up with an f b. Well, that's impossible for any f at all.
14:27:12 <erisco> dmwit, okay so lets use my types for a sec here...
14:27:20 <Gracenotes> If you're also given a nice function (a -> b) -> f a -> f b, well, you already have an (f a), but you need an (a -> b) to use it.
14:27:27 <erisco> dmwit, data Parser t n = Parser (ListView t -> [ParseResult t n])
14:27:44 <erisco> dmwit, so (Parser f) means that f :: ListView t -> [ParserResult t n]   right?
14:27:58 <dmwit> Well. Basically, yes.
14:28:00 <Gracenotes> So you need something like f (a -> b) -> (a -> b). er... also impossible. in any case. that's mostly it. not great for intuition likely, but yes.
14:28:06 <dmwit> Again, with some caveats about how polymorphic t and n can be.
14:28:34 <elliott> if (Parser f :: Parser t n), then f :: ListView t -> [ParserResult t n]
14:28:39 <erisco> dmwit, oh shoot okay just a sec
14:28:46 <elliott> I have carefully crafted this statement to be true whether you scope your type variables or not.
14:30:21 <erisco> dmwit, so my mapping function is burried in my list of parseresults! stupid me
14:30:56 <erisco> my brain was linking back to the trivial Applicative examples and ignoring what 'f' actually was
14:30:57 <dmwit> exactly right
14:31:27 <erisco> which is the *exact* same problem I had when defining Functor... same mistake twice now
14:32:03 <erisco> so that means...
14:32:13 <erisco> I have to put my \> stuff where I have my <*> stuff...
14:32:26 <erisco> right?
14:32:44 <t2ahc> \LEAVE
14:32:56 <erisco> lemme do that
14:32:57 <dmwit> erisco: Right!
14:33:45 <erisco> boo yeah. goddam Eintein right here! the cosmos will never be the same now.
14:34:36 <covi> Hi all. How do I go from  WS.WebSockets p0 String  to  IO String?
14:34:45 <covi> (where WS is the WebSockets monad)
14:34:54 <erisco> dmwit, thank-you so much :D
14:35:25 <dmwit> high five!
14:35:44 <erisco> air five! no! irc five!
14:36:34 <erisco> is this over-generalizing a problem as you age? I seem to keep making associations that don't exist
14:37:14 <erisco> I'm just generally surprised at my failure here. I can usually do better =\
14:37:59 <taylorgb_> No harm done
14:38:10 <Gracenotes> covi: is there a MonadIO instance?
14:38:31 <Gracenotes> er, no, opposite... hm.
14:38:56 <Gracenotes> lemme see
14:39:04 <dmwit> erisco: So, what did you end up with?
14:39:18 <dmwit> Did you call (\>) or copy its code instead?
14:39:33 <Gracenotes> covi: usually getting IO is in the realm of 'run' functions
14:40:12 <Gracenotes> there seem to be functions like runWebSockets that give you an Iteratee, and then you just run the Iteratee.
14:44:26 <erisco> dmwit, I haven't wrote anything yet. going to chill for a bit and make some food
14:44:40 <covi> Gracenotes: it think it is a MonadIO
14:45:43 <Gracenotes> covi: okay, that is good for doing any arbitary IO thing with it, but to actually run it (i.e. get main to look at it), 'running' it tends to bring out the value into a normal IO context.
14:45:45 <erisco> dmwit, head is all fogged up from thinking too much. it is just a bit funny to me because it is like I am learning programming all over again
14:46:18 <erisco> dmwit, and I've spent hundreds of hours helping others, so I know the exact kind of things I am falling into, and what it is like to hear it lol
14:46:28 <Gracenotes> running it often means that it may lose whatever context it itself had, e.g. a persistent connection, so sometimes you want to run it and sometimes you want to lift arbitrary things into it.
14:46:43 <Gracenotes> depends on the monad, I guess.
14:46:48 <erisco> dmwit, and precisely how Haskell makes everything seem upsidedown and backwards is beyond me, but behold
14:47:09 <erisco> or rightsideup and frontwards, depending on your background ;)
15:07:28 <mischov> I defined a type in a module and imported that module into another file.  I can use functions from the imported module, but when I try to use the type I get this message in ghci:
15:07:32 <mischov> Not in scope: data constructor `Selector'
15:07:39 <mischov> Any idea why?
15:08:05 <geekosaur> you probably improted the type without its constructors
15:08:21 <geekosaur> try importing the type as:  MyType(..)
15:09:04 <geekosaur> (alternately you *exported* it without them, same story)
15:09:10 <mischov> Aaaand that works.  I've not had to do that with other modules, is there a reason I need to do that with mine?
15:10:22 <geekosaur> I would expect that to be necessary any time you use an explicit import list
15:10:28 <geekosaur> (resp. export list)
15:10:49 <nabilhassein> does anyone know of any reason that a file would have a type error in ghci under emacs, but load just fine under ghci on the command line?
15:10:56 <nabilhassein> as well as compiling just fine
15:11:02 <mischov> Okay.  Thank you geekosaur.
15:11:19 <hvr> nabilhassein: different GHCi options active in emacs-ghci?
15:11:39 <c_wraith> nabilhassein: is emacs loading it in a way that ignores LANGUAGE pragmas?
15:12:36 <resnik_> are Arrows anything special or are they just like any other typeclass? they seem to be implemented with normal function application and tuples but from what I've read it almost seems like there is some extra Voodoo going on that fundamentally seperates them from normal functions
15:13:23 <shachaf> I'm not sure what you mean by "them".
15:13:23 <nabilhassein> hvr, c_wraith: i don't see anything like that but maybe i'm missing something
15:13:25 <c_wraith> resnik_: there is some optional syntactic sugar for them..  But most people are leaning away from using Arrow much
15:13:26 <shachaf> Most instances of Arrow aren't (->).
15:13:51 <shachaf> So if you write instance Arrow Foo then clearly there's something separating (Foo a b) from (a -> b).
15:14:28 <shachaf> On the other hand in practice the only instance people use is (->). :-)
15:15:10 <nabilhassein> it's just so strange that it would be a type error rather than something else. perhaps it's for some reason not reloading the module it depends on?
15:15:11 <resnik_> i guess my questions is mostly just this: if Control.Arrow didn't exist you could easily implement it with normal functions and tuples, right?
15:15:26 <shachaf> Implement what?
15:15:28 <blume> @help
15:15:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:15:43 <nabilhassein> i have two source files, one of which imports the other. i changed that former file and that required making changes in the latter file as well
15:16:06 <nabilhassein> er, my former and latter are mixed up there but i think what i mean is clear anyway
15:37:16 <Peaker> bah, used lazy I/O somewhat innocently, code just exploded in my face. Boy, how I hate lazy IO
15:37:31 <slack1256> @type unsafeCoerce
15:37:32 <lambdabot> Not in scope: `unsafeCoerce'
15:37:44 <slack1256> Is hpaste down or is just me?
15:37:56 <geekosaur> @where hpaste
15:37:56 <lambdabot> http://paste.tryhaskell.org/new/haskell
15:38:02 <geekosaur> the domain name is horked
15:38:11 <slack1256> Oh ok.
15:38:16 <slack1256> is better that being down
15:41:57 <covi> I am encountering this for a simple script:  ParseError (ParseError {errorContexts = [], errorMessage = "Failed reading: takeWith"}). Any idea which library does the error originate from? What's takeWith?
15:42:39 <Peaker> covi, have you written a parser combinator?
15:43:10 <yyyyy> @ty takeWith
15:43:10 <lambdabot> Not in scope: `takeWith'
15:43:23 <yyyyy> @hoogle takeWith
15:43:24 <lambdabot> No results found
15:43:24 <blume_> @list
15:43:24 <lambdabot> What module?  Try @listmodules for some ideas.
15:43:38 <blume_> @listmodules
15:43:38 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
15:43:38 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
15:44:19 <blume_> @help search
15:44:19 <lambdabot> search provides: google gsite gwiki
15:44:43 <hpaste> slack1256 pasted “unsafeCoerce and ghci” at http://paste.tryhaskell.org/90748
15:45:21 <slack1256> could somebody look at that paste? the third line doesn't seem right
15:45:29 <slack1256> third entry sorry
15:46:42 <chee1> is there a version of `mask` that works on MonadIO rather than IO? mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
15:47:31 <chee1> mask :: (MonadIO m) ((forall a. m a -> m a) -> m b) -> m b) instead of ----^ ?
15:47:53 <shachaf> Not on MonadIO, but on various subclasses of MonadIO.
15:48:14 <shachaf> There are packages like http://hackage.haskell.org/package/MonadCatchIO-transformers
15:48:22 <Peaker> instance NFData Foo where rnf (Foo !_ !_ !_) = ()   sounds sane?
15:48:38 <Peaker> not missing some subtlety?
15:48:54 <shachaf> Peaker: Well, it depends on what Foo is.
15:49:11 <shachaf> You also want to reduce those _s to normal form, in general.
15:49:42 <Peaker> yeah, that's an important detail to omit :-) They're GLDoubles
15:50:09 <Peaker> oh, I see they are declared as strict fields anyway
15:50:28 <shachaf> chee1: I hear MonadCatchIO uses an API that'll be gone in the next version of GHC, actually.
15:50:37 <shachaf> So you might want to go with another package. There are a few others like it.
15:51:02 <elliott> like edwardk's exceptions.
15:51:41 <shachaf> Oh, edwardk wrote something for it?
15:52:30 <elliott> yes
15:52:47 <c_wraith> where's "search by author" on hackage?
15:53:06 <Peaker> I have: E.evaluate . DeepSeq.force . Aeson.eitherDecode' =<< LBS.readFile configPath     running in a single thread, but I see multiple file descriptors open on this file simultaneously, weird!
15:53:31 <shachaf> c_wraith: http://new-hackage.haskell.org/user/EdwardKmett
15:53:33 <covi> Peaker: yes
15:53:43 <Peaker> doesn't seem to be a leak, it's eventually freeing those fd's, but why not closing them right there are the deep force?
15:54:05 <covi> Peaker: weird that my code doesn't use 'takeWith'
15:54:11 <Peaker> covi, then that message is about some internal combinator used to the library used by your parser. You can probably add <?> annotations to the parts of your parser to get a more specific error
15:54:24 <Peaker> covi, you use it indirectly via some other combinator that uses it
15:55:16 <Peaker> how does the unsafeInterleaveIO of lazy bytestring readFile work? If you read the final bit of the string does it immediately close the file? Or does it queue it for GC later, or such?
15:57:45 <c_wraith> Peaker: the documentation suggests that the file is closed as soon as it reaches EOF
15:58:28 <Peaker> yeah, http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/src/Data-ByteString-Lazy.html (in hGetContentsN) seems to close it as soon as it is read
15:58:37 <Peaker> rather than dependent on GC
15:59:08 <Peaker> however, somehow I am getting multiple fds in my /proc/<pid>/fd pointing to this file, which I read from only one thread (I believe), I'll add some debug prints to make sure
15:59:45 <c_wraith> Well, is it possible laziness is making your code not process the file fully?
15:59:59 <c_wraith> If so, it's going to be waiting on GC
16:02:10 <iammisc> how efficient are iorefs?
16:02:24 <elliott> about as efficient as it gets
16:03:11 <iammisc> so if i'm creating a mutable data structure with lots of iorefs, and it's running really slowly, it's probably nothing to do with my iorefs?
16:03:12 <c_wraith> They're pretty low-overhead, but reading something like an Int out of one still requires multiple indirections
16:03:25 <iammisc> that's what i'm interested in.
16:03:36 <iammisc> I'm writing a skip list, and each node is basically data + an Array
16:03:46 <iammisc> an Array of IORefs
16:04:02 <c_wraith> adding another indirection...
16:04:08 <RichyB> Can't you use an IOArray directly and save one indirection?
16:04:15 <iammisc> Currently, inserting 2000 elements takes 3 seconds, which needs to improve
16:04:40 <luite_> iammisc: how much time is spent in gc?
16:04:53 <c_wraith> both arrays and IORefs are bad for GC, too..
16:05:00 <iammisc> luite_: at first it was 30%, but a few strictness annotations got it down to 8%
16:05:04 <RichyB> You have an immutable Array of mutable (IORef a)s; a mutable (IOArray a) will have the same shape but generate much less garbage.
16:05:06 <iammisc> would an ioarray be much better than an array
16:05:11 <iammisc> i see
16:05:16 <iammisc> lemme try and see
16:05:38 <iammisc> i'd show the code, but it's gone through so much hacking that i'm a bit embarassed at this point
16:06:07 <RichyB> Because an IOArray has about the same semantics as an unboxed array of IORefs (if you could get such a thing) would.
16:06:27 <iammisc> right
16:06:29 <luite_> iammisc: ah that dosn't seem so bad. but using an IOArray instead seems like the logical step
16:06:59 <luite_> still 3 seconds is rather long...
16:06:59 <Peaker> c_wraith, I have: E.evaluate . DeepSeq.force . Aeson.eitherDecode' =<< LBS.readFile configPath      so it should be fully evaluating this to the end of the Lazy ByteString
16:07:18 <iammisc> luite_: the thing about the gc is that even getting it lower didn't really help the speed *that* much
16:07:26 <iammisc> which makes me think it's somewhere else.
16:07:42 <iammisc> A little bit of profiling found that the program spends most of its time reading the iorefs
16:09:47 <c_wraith> Peaker: well, there are a couple places that could go wrong.  the NFData for whatever type you're decoding to, and Aeson may not consume the entire file.  (The latter is pretty unlikely, but could happen)
16:09:58 <Peaker> c_wraith, apparently, the eitherDecode' isn't forcing the whole string, even when its result is fully forced
16:11:08 <bb010g> Trying to use Control.Monad.State. I'm confused by the difference between State and StateT. Explanation please?
16:11:26 <tabemann> StateT is a monad transformer
16:11:29 <tabemann> State is a monad
16:11:51 <Gracenotes> Say, what are you using State for?
16:12:08 <shachaf> Well, if you want to be precise, StateT s is a monad transformer, and State s is a monad.
16:12:35 <c_wraith> iammisc: honestly, I doubt a skiplist implementation in haskell will ever be good. Mutable structures just don't play nicely with GHC's gc
16:12:38 <Gracenotes> If you're only interested in abstracting over computation with implicit 'state' of some kind, where ordering matters, State by itself is pretty good.
16:13:07 <tabemann> you'd only want StateT if you simultaneously need to use some other monad, such as IO
16:13:32 <iammisc> c_wraith: hmmm… that's interesting. Eventually, I want the skip list implementation to be moved on disk
16:13:52 <bb010g> I'm trying to build a HP 35s simulator, and need to implement a stack.
16:14:00 <chee1> shachaf: thanks
16:14:14 <iammisc> the eventual goal here is to have a database, but i wanted to look at the performance characteristics with an in-memory structure first
16:14:21 <Peaker> I can't figure out how it is possible for aeson not to read entire file to do the decoding, but somehow it does
16:14:43 <bb010g> I tried what was on Learn You a Haskell, but it failed.
16:14:55 <iammisc> i figured that the performance wouldn't be *that* good, but i would expect it to be decent; 3 seconds for 2000 elements is pretty bad, even badly coded python does a lot better...
16:15:10 <tabemann> what failed? (there have been changes since LYAH was written, mind you)
16:15:16 <c_wraith> Peaker: how big is the file?
16:15:30 <c_wraith> Peaker: and is it only one top-level js object?
16:15:37 <Peaker> c_wraith, 17KB, yeah
16:16:39 <bb010g> tabemann: Don't know, copied and pasted and it worked fine. Must have been a typing error. (herp derp) Sorry for the inconvience.
16:18:01 <tabemann> bb0l0g: I was just wondering, since the constructor State has now been turned into the function state, and that could break things, and I don't remember if LYAH was written before or after that change
16:18:11 <tabemann> s/constructor/data constructor
16:18:14 <Gracenotes> bb010g: if you run into any more issues, you can pastebin your b0rken code
16:18:51 <bb010g> Gracenotes: Sure.
16:19:31 <Gracenotes> the typesigs don't lie! but they don't tell the whole true either
16:20:57 <merijn> tabemann: After
16:21:10 <Gracenotes> hm... what was the motivation for combining State and StateT?
16:21:18 <hpaste> bb010g pasted “Failing State” at http://paste.tryhaskell.org/90749
16:21:25 <bb010g> tabemann: Turns out it's still failing, I accidentally loaded nothing. (herp derp) http://paste.tryhaskell.org/90749
16:21:31 <merijn> Gracenotes: reducing code duplication
16:22:03 <merijn> bb010g: The State constructor no longer exists (this has changed since LYAH was written), use that "state" function
16:22:09 <tabemann> State Stack () doesn't look right
16:22:45 <Gracenotes> oh. I guess all of the major wrapper monads are defined w/ Identity
16:22:51 <bb010g> tabemann: Stack is a type synonym for [Int], and there is no output.
16:23:03 <merijn> bb010g: The short story, which you can gladly ignore, is that State was replaced with a more general monad transformer and "State" is now a synonym for using that transformer, which means the types and functions are all the same, with one exception
16:23:13 <Peaker> c_wraith, I tried ruling out the single new-line that's after the top-level JSON object, by manually removing it. But apparently emacs adds it back when I save :-(
16:23:15 <tabemann> bb0l0g: ignore my comment
16:23:21 <Gracenotes> the easy solution, instead of 'State', write 'state'
16:23:30 <Gracenotes> the better solution, use modify :)
16:23:30 <merijn> bb010g: That being that the State constructor no longer exists and the "state" function is provided as a compatibility replacement
16:23:33 <Peaker> c_wraith, I am using the lower-level parsing interface that exposes the remaining bytestring, so I can see that the \n is remaining
16:23:49 <Gracenotes> at least for using State in "the real world"
16:23:52 <Peaker> c_wraith, though I guess if EOF is reached exactly without any further read, that would also avoid closing the file
16:24:03 <c_wraith> Peaker: really, that newline should only cause issues if it happens to be *exactly* the remaining contents of the file after the previous chunk has been read
16:24:07 <merijn> bb010g: Also, as Gracenotes points out, you probably want to use modify
16:24:09 <merijn> :t modify
16:24:10 <lambdabot> MonadState s m => (s -> s) -> m ()
16:24:25 <c_wraith> I don't like modify much. >_>
16:24:37 <merijn> bb010g: i.e. "push x = modify (x:)"
16:24:47 <Gracenotes> c_wraith: because you think it should be in the typeclass?
16:24:54 <bb010g> merijn: Ooh, nice.
16:25:00 <c_wraith> Gracenotes: no, because it's usually a source of space leaks
16:25:09 <bb010g> merijn: Do I have to import anything special?
16:25:13 <Gracenotes> oh. yeah, it is a bit lazy.
16:25:22 <Gracenotes> and it should also be in the typeclass.
16:25:23 <merijn> bb010g: No, Control.Monad.State should've imported that
16:25:57 <Gracenotes> I ran into the latter issue with a concurrent MonadState
16:26:06 <bb010g> merijn: So, should push not have a type of State Stack (), or is that fine?
16:26:14 <merijn> bb010g: That's fine
16:26:30 <merijn> bb010g: I use "State Foo ()" all the time
16:26:42 <merijn> (Well, usually I use StateT, but that's basically the same thing)
16:26:56 <bb010g> :pl \n -> modify (n:)
16:27:13 <Gracenotes> :t modify . (:)
16:27:14 <lambdabot> MonadState [a] m => a -> m ()
16:27:21 <tabemann> hmm.. it still doesn't compile when you use state rather than State
16:27:32 <bb010g> ?pl \n -> modify (n:)
16:27:33 <lambdabot> modify . (:)
16:27:52 <frelux> anyone on OS X 10.9 and able to build GHC?
16:28:25 <merijn> bb010g: oh!
16:28:32 <merijn> bb010g: You have a silly mistake
16:28:51 <bb010g> merijn: ???
16:28:58 <tabemann> got it
16:29:01 <merijn> bb010g: "push :: (Num a) => a -> State Stack ()" says that you can push *any* numeric value on the stack, whereas your stack is [Int]
16:29:07 <tabemann> yeah
16:29:13 <merijn> bb010g: So that's a type error :)
16:29:31 * bb010g facepalms
16:29:31 <merijn> You probably want "push :: Int -> State Stack ()"
16:29:42 <tabemann> you need to change your type to Int -> State Stack () or add a numeric conversion
16:30:09 <merijn> bb010g: It happens to the best of us ;)
16:30:38 <Peaker> c_wraith, I see now. The chunk size is larger than my file. When bytestring does lazy I/O and reads the last chunk, it waits for an extra chunk to be requested to get a 0-byte chunk to close the file
16:30:38 <bb010g> Is there any way to make a type synonym for a restraint?
16:31:03 <Peaker> c_wraith, whereas it'd probably be better to test for EOF if getting less-than-full-chunk, and close it already
16:31:15 <c_wraith> Peaker: ah, yes.  That would explain it.
16:31:16 <Gracenotes> what kind of restraint?
16:31:18 <tabemann> bb0l0g: you can, but you really don't want to
16:31:38 <tabemann> type class constraints on types (and you'd have to newtype it too I think) are bad
16:31:40 <Peaker> (currently any use of Lazy I/O with bytestring that has its own detection of end of content, even if that detection is actually at the EOF, will leak FD's)
16:31:41 <bb010g> type Stack = (Num a) => [a]
16:31:52 <tabemann> you don't want that
16:31:56 <bb010g> tabemann: Why?
16:32:09 <tabemann> because *every* function that uses that type has to take on that constraint as well
16:32:26 <Gracenotes> oh. yeah, also, you'll still want to parameterize Stack with a, yes
16:32:42 <c_wraith> Peaker: hmm.  And because it's in terms of hGetContents, which might be applied to things like network handles...  You can't really just make that policy for hGetContents in total
16:32:50 <merijn> bb010g: Basically, adding the constaint doesn't let you get away with not adding it to functions
16:32:51 <tabemann> you want a type Stack a = [a]
16:32:59 <Gracenotes> without the constraint, you might get the type "push :: a -> State (Stack a) ()", and "pop :: State (Stack a) (Maybe a)"
16:33:00 <tabemann> and then put your constraint on your *functions* that use that type, as needed
16:33:02 <merijn> bb010g: i.e. you don't really gain anything
16:33:08 <Gracenotes> which is quite reasonable, because you don't Num for that anyway
16:33:53 <bb010g> Gracenotes: Good point
16:33:54 <Gracenotes> though also, if you don't anticipate using anything other than Int, I would recommend that, just because of code generation being nicer :)
16:33:55 <merijn> Peaker: Clearly closing when you get a partial chunk is not an option for BS
16:34:08 <Peaker> c_wraith, perhaps with better hinting from the I/O manager below... if it can rely on it being async I/O, it can just try to do a non-blocking read of the remaining part of the chunk until it either got a whole chunk or EOF
16:34:08 <merijn> Peaker: Doing that would fail horribly when the Fd you're reading from happens to be a socket
16:34:23 <Peaker> merijn, ^^
16:34:51 <bb010g> Gracenotes: So, just for a base, using a generic stack is fine, with constraints when needed?
16:35:17 <tabemann> you might want an Int stack just because it'll compile nicer, as said
16:35:19 <c_wraith> Peaker: ghc doesn't use non-blocking IO for disk access, though
16:35:19 <merijn> bb010g: Yeah
16:35:37 <merijn> bb010g: Once you use functions that typechecker enforces a single stack type anyway
16:35:52 <bb010g> I'll be putting different types in there at different times.
16:35:55 <merijn> bb010g: For example, check the definition of Data.Set and it's Ord constraint
16:36:19 <Peaker> c_wraith, for disks it's safe to assume you can just try to read rest of chunk though
16:36:19 <bb010g> Would it be good to put it in at the end, once I build my hpNum type?
16:36:33 <bb010g> And stick with [a] for now?
16:36:35 <merijn> bb010g: That'll only work if you have a new Stack, i.e. "Num a => Stack a ()" works for *any* numeric a, but not for *all* numeric a
16:37:29 <merijn> bb010g: If you want a stack that support different numeric types, you'll have to wrap them somehow, the best approach depends a  little on what you want to do
16:38:08 <bb010g> merijn: Ok. Thanks!
16:38:35 <merijn> bb010g: "Num a => [a]" is not like OO subclassing where you can stuff different instances of Num into one list, it reads more like "for any type a, if a is a numeric type, this is a list of as"
16:39:16 <merijn> i.e. it could be [Int], it could be [Double], but it can't be [Int/Double] (or some other silly made up syntax)
16:39:31 <tabemann> you can do that with existential quantification... but you probably don't want that unless you have a very good reason...
16:40:10 <merijn> tabemann: He won't gain anything from EQ anyway
16:41:39 <tabemann> if you want to keep, say Ints and Doubles separate, most likely you just want to put them in an algebraic data type like type Foo = IntValue Int | DoubleValue Double, and put that in the Stack
16:41:49 <tabemann> s/type/data
16:42:09 <tabemann> (stupid habit from OCaml...)
16:42:51 <bb010g> Would I use modify to implement pop, or something different?
16:43:18 <tabemann> no
16:43:35 <tabemann> because the problem is that the value gotten out of the stack couldn't ever escape modify
16:43:40 <merijn> bb010g: You can't, modify doesn't return the changed value
16:43:50 <bb010g> merijn: What would I use?
16:43:57 <merijn> bb010g: The easiest way is to use get and put
16:44:14 <chrisdotcode> :i lift
16:44:30 <chrisdotcode> > 2 + 2
16:44:31 <lambdabot>   4
16:44:36 <chrisdotcode> :t lift
16:44:37 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:44:41 <bb010g> :t get
16:44:41 <lambdabot> MonadState s m => m s
16:44:42 <chrisdotcode> :i fmap
16:44:48 <bb010g> :t put
16:44:49 <lambdabot> MonadState s m => s -> m ()
16:44:51 <merijn> "stack <- get; case stack of [] -> return Nothing; (x:xs) -> put xs >> return (Just x)"
16:44:54 <Gracenotes> it can be done using the state 'constructor', but do notation works too
16:44:55 <chrisdotcode> guys, did I break lambdabot, or is :i not working anymore?
16:45:03 <Ghoul_> is there a way to make criterion do less iterations using defaultMain
16:45:09 <merijn> chrisdotcode: :i never worked in lambdabot
16:45:10 <Gracenotes> she doesn't really do :i
16:45:16 <Ghoul_> because the default number of iterations takes like 5 minutes to benchmark the thing I'm testing
16:45:23 <chrisdotcode> merijn: oh. I thought I recall it working once... oh well. thanks :)
16:45:42 <merijn> bb010g: i.e. get returns the current state and put just overwrites the old state with a new one
16:46:11 <merijn> bb010g: You probably want "pop :: State Stack (Maybe Int)" (i.e., return Nothing if the stack is empty)
16:46:48 <tabemann> ~partial functions are bad~
16:48:29 <tabemann> Ghoul_: you can change the value cfgSamples in the Config you use
16:48:41 <Ghoul_> yeah, found it thanks :)
16:49:08 <Peaker> c_wraith, merijn: Anyway, this ordeal exposed a real bug in my code (any any code that uses Aeson.decodeEither) of ignoring any data the trails the JSON itself.  I avoid it and use lower-level functions now that verify that the JSON isn't trailed by anything
16:49:28 <Peaker> (so now I should immediately consume the entire byte string)
16:49:30 <tabemann> Ghoul_: waaait I'm not sure if you can create a List Int value for that
16:49:44 <tabemann> oh you can
16:50:55 <tabemann> Peaker: you could just force the entire string and *then* feed it into Aeson.decodeEither, even though that probably might not be the most efficient in all cases (due to negating any advantages of lazy IO)
16:51:12 <Peaker> tabemann, might as well read strict bytestring and convert to lazy BS in that case
16:51:15 <Ghoul_> where does ljust come from?
16:51:31 <Peaker> tabemann, I just decided I wanted to fully understand why I was leaking fd's, rather than just throw a solution at it and avoid understanding
16:52:03 <Ghoul_> nevermind, it's in Criterion.Config :)
16:52:07 <Peaker> tabemann, and in the process, I learned about problematic behavior in the lazy IO of bytestrings (closing slightly later than ASAP) and of the Aeson library (necessarily ignoring any garbage after decoded JSON strings)
16:52:30 <Peaker> I wonder if both of these are worthy of bug reports (But not at 3 am anyway)
16:53:07 <tabemann> the first... is probably a basic design issue than a bug... the second... yeah
16:53:38 <Peaker> tabemann, the first is solvable too if we can assume non-blocking/local-file (which we probably can given the way the I/O manager works?)
16:53:46 <tabemann> that behavior might be designed with the idea that you could parse multiple different chunks of JSON in a row, but it is clearly non-optimal in many use cases
16:54:06 <chrisdotcode> : t lift
16:54:16 <Peaker> tabemann, but the decode* interfaces of Aeson don't give you the remaining bytestring so you can't do anything with the data after the JSON anyway
16:54:49 <tabemann> yeah... only partially reading the bytestring only makes sense if they give you the rest of the bytestring back
16:55:38 <merijn> Peaker: I don't think the IO manager can know whether something is a local file or not
16:55:47 <merijn> Peaker: So many edge cases
16:55:59 <Peaker> merijn, either local file or non-blocking is good
16:56:03 <merijn> Peaker: Unix sockets, NFS
16:56:05 <Peaker> merijn, AFAIK, everything is one of those, no?
16:56:22 <merijn> Peaker: Pretty sure NFS is neither? :p
16:56:32 <Peaker> NFS doesn't allow O_NONBLOCK?
16:56:36 <merijn> Well, it might be
16:56:37 <merijn> I dunno
16:57:00 <merijn> Anyhoo
16:57:04 <merijn> Bed time for me
16:57:32 <chrisdotcode> do predicate functions that operate over a single element always look like (a -> Bool)?
16:57:39 * tabemann has found this informative himself, as he didn't really know this about the behavior of hGetContents
16:58:27 <chrisdotcode> @src any
16:58:27 <lambdabot> any p =  or . map p
16:58:35 <chrisdotcode> :t any
16:58:36 <lambdabot> (a -> Bool) -> [a] -> Bool
17:00:48 <chrisdotcode> @src all
17:00:48 <lambdabot> all p =  and . map p
17:00:57 <chrisdotcode> @src and
17:00:57 <lambdabot> and   =  foldr (&&) True
17:01:28 <tabemann> looks like @src outputs the report prelude versions of the code
17:01:57 <chrisdotcode> tabemann: are there different versions besides that?
17:02:52 <tabemann> if you look in GHC.List and Data.List's source code, you'll notice that are a good few functions that have multiple versions, a "nice" version #ifdef'ed for the report prelude, and a fast, not very "nice" version actually used
17:02:52 <chrisdotcode> @src foldr
17:02:52 <lambdabot> foldr f z []     = z
17:02:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:04:18 * tabemann has spent too much time staring at GHC.List and Data.List in his (probably horribly misguided) effort to create a strict list library
17:06:17 <bb010g> merjin: @src get
17:06:35 <bb010g> @src get
17:06:35 <lambdabot> Source not found. There are some things that I just don't know.
17:06:45 <bb010g> @src foldrr
17:06:45 <lambdabot> Source not found. Are you typing with your feet?
17:06:49 <bb010g> @src foldr1
17:06:49 <lambdabot> foldr1 _ [x]    = x
17:06:49 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:06:49 <lambdabot> foldr1 _ []     = undefined
17:07:00 <bb010g> :t undefined
17:07:00 <lambdabot> a
17:08:04 <tabemann> this is what foldr actually looks like:
17:08:07 <tabemann> foldr k z = go
17:08:08 <tabemann>           where
17:08:08 <tabemann>             go []     = z
17:08:08 <tabemann>             go (y:ys) = y `k` go ys
17:08:28 <tabemann> a lot of the functions in there are much more elaborate than that
17:09:48 <tabemann> bb010g: undefined is "bottom"
17:09:50 <chrisdotcode> tabemann: I looked at the source of permutations on haddock, and I couldn't grok it...
17:10:16 <tabemann> it is a value that has no value, throws an exception when evaluated, and can fit any type
17:11:10 <tabemann> an equivalent outside the world of haskell is the "value" of dividing by zero
17:11:16 <Cale> throws an exception or gets stuck forever in an infinite loop
17:11:27 <Cale> It's a value which represents nontermination
17:12:15 <chrisdotcode> :t undefined
17:12:16 <lambdabot> a
17:12:41 <Cale> For instance, if you write   loop = loop   then we'd say that loop has value bottom as well -- sometimes the compiler/runtime system will even be smart enough to turn this infinite loop into an exception for you
17:14:30 <Cale> and the semantics of evaluation allows that because according to the semantics, the infinite loop and exception have the same value.
17:14:50 <Cale> (Even though they behave a little differently in reality)
17:15:44 * tabemann wishes the compiler would catch all infinite loops for him, as exceptions are much easier to catch and debug than actual infinite loops
17:16:20 <Peaker> for me shadowing warnings catch most of my infinite loops
17:16:25 <shachaf> It is easy to catch all infinite loops. But you must catch many non-infinite-loops as well.
17:17:24 <Peaker> tried to send a patch to a darcs project (hircules) -- email was out of service.  Tried to send a patch to a github project (aeson), github pull request just works, yay!
17:18:00 <Cale> WOW, hircules is still being worked on?
17:18:23 <Peaker> don't think so, I just tried it out, had to fix some stuff to get it to build
17:18:24 <Cale> That's the first I've heard of it in several years :)
17:18:32 <Peaker> so wanted to contribute these fixes
17:18:51 <Peaker> then when I ran it, it wasn't very good, didn't seem worth it, so I went back to xchat :-(
17:19:12 <carter_away> lukexi yo,
17:19:30 <lukexi> carter_away: yo!
17:19:35 <carter> so
17:19:55 <carter> the step i said isn't quite all of it
17:19:57 <ag90> Can I get a cabal project to depend on another project which is in directory relative to the cabal file?
17:20:08 <carter> ag90 only with cabal/cabal-install head
17:20:10 <carter> which are nice
17:20:19 <carter> tools
17:20:54 <ag90> Ah, so the HEAD version of cabal-install has this functionality?
17:21:09 <carter> yes
17:21:22 <ag90> Great! Thanks.
17:21:26 <carter> relatedly: lukexi  for the gcc48 to work properly as a stop gap
17:21:32 <carter> we have to do some deep ghc magic
17:21:36 <carter> before we boot strap the better way
17:21:43 <carter> lukexi is this haskell platform ghc?
17:22:28 <Ghoul_> is there a performance loss in pulling stuff out into let's
17:22:35 <Ghoul_> when they are only used once?
17:22:35 <lukexi> no i'm on a standalone 7.6.2
17:22:47 <Ghoul_> (does it force laziness or something?)
17:22:48 <carter> Ghoul_ ghc *should* do that
17:22:52 <carter> Ghoul_ show you code
17:23:00 <carter> so the question becomes less vague
17:23:13 <lukexi> i could switch to the latest HP if needed
17:23:14 <Ghoul_> well, I've been let floating a lot here: https://gist.github.com/kvanberendonck/5947287
17:23:19 <carter> lukexi no, not needed
17:23:45 <Ghoul_> the startup routine takes forever compared to the Java and C# versions, and the hash table lookup I can't beat java by almost 2x in benching :\
17:23:56 <carter> Ghoul_ hpaste your code or no one will help you
17:24:18 <lukexi> i'm working through a barf in brew install gcc48... (uninitialized constant Hardware::CPU)
17:24:18 <Ghoul_> I think its down..
17:24:30 <carter> Ghoul_ http://paste.tryhaskell.org/new/haskell
17:24:31 <Ghoul_> I tried that first.
17:24:40 <carter> or a gist
17:24:42 <carter> or pastebin
17:24:46 <carter> or one of a billion tools
17:25:02 <Ghoul_> carter: I put a gist up a few lines
17:25:10 <carter> Ghoul_ share the link again
17:25:14 <carter> oh
17:25:16 <carter> i seee
17:25:18 <Ghoul_> :P
17:25:33 <carter> your code is weird
17:25:57 <carter> hrmm
17:26:06 <Ghoul_> the format is designed to be memory mapped into C++ so it was hard to load with haskell
17:26:08 <carter> Ghoul_ add lots of bang patterns and inline bragmas
17:26:09 <Ghoul_> and I couldn't use binary to do it
17:26:10 <carter> *pragmas
17:26:19 <Ghoul_> lol
17:26:19 <carter> and measure again
17:26:29 <carter> Ghoul_ as you using -O2?
17:26:36 <carter> try using -O2 and -fllvm first
17:26:50 <Ghoul_> -O2 -funbox-strict-fields and I can't get llvm working because windows
17:26:58 <carter> Ghoul_ you're hosed
17:27:03 <iammisc> so yeah, using the IOArrays for my skip list did the trick
17:27:13 <iammisc> a few thousand entries, no problem
17:27:17 <carter> lukexi what does your ghc -v say?
17:27:34 <iammisc> turns out using array for mutable skip lists is a bad idea… :) Thanks for the help everyone!
17:27:41 <lukexi> carter: Glasgow Haskell Compiler, Version 7.6.2, stage 2 booted by GHC version 7.4.2
17:27:48 <carter> lukexi it should say more
17:30:26 <lukexi> carter: i messaged you, if you didn't see
17:30:31 <carter> saw it
17:30:35 <carter> i'm just trying to find something
17:32:17 <bgamari> Ghoul_, You've profiled?
17:32:33 <Ghoul_> nope
17:32:47 <carter> bgamari i'll let you take over this one
17:32:53 <carter> ghc has nice profiling tools
17:33:06 <Ghoul_> will ThreadScope do?
17:33:16 * tabemann should learn to use GHC's profiler, now that he's learned to use QuickCheck and Criterion...
17:33:18 <bgamari> Ghoul_, ahh, then that's the next step
17:33:27 <bgamari> Ghoul_, Not in this case
17:33:46 <bgamari> Ghoul_, ThreadScope is for examining parallel and concurrent performance
17:33:56 <bgamari> Ghoul_, Just the standard GHC profiler should do here
17:33:57 <Ghoul_> ah
17:34:18 <bgamari> compile with  -prof -auto-all -caf-all
17:34:26 <Ghoul_> (and for some reason when I compile with -threaded my program segfaults or the runtime worker threads fizzle)
17:34:28 <Ghoul_> ok
17:35:11 <bgamari> Ghoul_, uh oh; the segfaults might suggest pointer magic gone wrong
17:35:19 <Ghoul_> "Could not find module : Criterion.Main, perhaps you haven't installed the profiling libraries"?
17:35:36 <dmwit> oh boy
17:35:38 <bgamari> but perhaps let's ignore that for now
17:35:59 <dmwit> That right there is a sign that you're about to enter the world of pain that we used to have before cabal-install installed dependencies recursively.
17:36:00 <bgamari> Ghoul_, sadly you'll likely need to rebuild a number of libraries
17:36:07 <Peaker> whew, took a lot longer to make that aeson pull request than I thought
17:36:23 <Ghoul_> is this going to work on windows :S
17:36:48 <bgamari> Ghoul_, The easiest thing to do at this point is to blow away ~/.ghc, configure cabal to enable library profiling, and recompile your dependencies
17:37:09 <bgamari> Ghoul_, Yes, it should work but sadly cabal built all of your dependencies without profiling support
17:37:14 <Ghoul_> okay, I can do that.
17:37:27 * tabemann should remember this
17:37:34 <carter> does anyone remember where the ghc settings file is?
17:37:36 <Ghoul_> do I need to kill .cabal too?
17:37:41 <dmwit> nah
17:37:43 <bgamari> Ghoul_, nope
17:37:53 <Ghoul_> okay .ghc killed
17:38:13 <bgamari> Ghoul_, cabal configuration is in ~/.cabal/config
17:38:41 <Ghoul_> yep, found it
17:38:41 <bgamari> Ghoul_, uncomment the line setting `library-profiling` to true
17:39:20 * tabemann checks his ~/.cabal/config
17:39:20 <Ghoul_> yep
17:39:23 <tabemann> interesting
17:39:43 <tabemann> I have library-profiling and executable-profiling commented out in mine, but the commented-out values are False
17:39:58 <Ghoul_> yeah I had the same so I just made library profiling True
17:40:04 <Ghoul_> I didn't touch executable profiling because he didn't say to.
17:40:07 <bgamari> Ghoul_, I usually do this on any new machine before building anything unless I'm certain I won't be debugging or writing code
17:40:54 <bgamari> Ghoul_, The builds will take a bit longer and kill more disk space but it's nice to be able to fall into the profiler when necessary
17:41:07 <Ghoul_> okay, so now I just build everything?
17:42:41 <tabemann> okay, what do you do with cabal to rebuild *everything* you have?
17:43:56 <c_wraith> cabal install world
17:44:09 <carter> lukexi do you have a /usr/local/lib/ghc-7.6.3/ ?
17:44:11 <bgamari> Ghoul_, ^
17:44:20 <tabemann> thanks
17:44:22 <Ghoul_> oh okay, cool
17:44:31 * tabemann figures he might as well do this now, as he'll probably want to use the profiler at some point
17:44:47 <Ghoul_> found a bug in mmap too, writing this program
17:44:58 <lukexi> carter /usr/local/lib/ghc-7.6.2, yeah
17:44:59 <carter> Ghoul_ who's mmap? yours?
17:45:02 <bgamari> tabemann, there's nothing worse than having your debugging momentum killed by 2 hours of rebuilding
17:45:06 <Ghoul_> it uses unsafePerformIO but doesn't prevent inlining and the mmap goes to shit by optimizations
17:45:06 <tabemann> bug in mmap? you mean like the OS call, or do you mean something in-Haskell
17:45:09 <Ghoul_> no, mmap package
17:45:09 <carter> lukexi there should be a "settings" file
17:45:13 <Ghoul_> for haskell
17:45:22 <carter> bug in what sense?
17:45:26 <bgamari> Ghoul_, Oh my
17:45:34 <lukexi> carter yep
17:45:40 <Ghoul_> http://stackoverflow.com/questions/17292048/haskell-segfault-reading-lazy-bytestring-past-218-bytes
17:45:42 <tabemann> bgamari: thankfully I don't have *too* much to rebuild; everything I installed as debian packages before I discovered cabal I installed with profiling anyways
17:45:58 <carter> Ghoul_ its not meant for lazy bytestring...s
17:46:14 <carter> lukexi change the gcc from the absolute path to  just gcc
17:46:17 <Ghoul_> what isn't?
17:46:26 <Ghoul_> the mmap package has functions for mapping them lazily so you'd assume they work
17:46:29 <lukexi> carter aha, this is what tacticalgrace meant. ok.
17:46:34 <carter> lukexi yeah
17:46:42 <carter> Ghoul_ those are different sorts of lazy
17:46:59 <carter> OS lazy loading is different for lazy evaluatio
17:47:14 <carter> lukexi ironically, i can't figure out where my settings file is right now
17:47:22 <carter> *different from lazy evaluation
17:47:37 <Ghoul_> oh, I got tricked then I guess.
17:47:37 <bgamari> carter, Sounds like mmap doesn't NOINLINE something, causing an mmap syscall to be executed multiple times?
17:47:44 <lukexi> carter : )
17:48:13 <carter> bgamari or that… but mmap and lazy bytestrings sounds like an iffy combo unless i know more
17:48:18 <carter> and i don't have the time to know more right now :)
17:48:21 <bgamari> carter, oh definitely
17:48:48 <bgamari> Ghoul_, Yeah, I think you should certainly use a strict bytestring here
17:49:08 <carter> lukexi ok, now for now, this should "work"
17:49:11 <Ghoul_> I'll keep it in mind for the future
17:49:11 <carter> lukexi next
17:49:25 <Ghoul_> I ended up swapping to pointer hackery since binary wasn't suitable for reading this file anyway
17:49:26 <carter> lukexi i want you to go to the cabal repo on gitub
17:49:38 <carter> and install current head of cabal and cabal-install
17:49:59 <bgamari> Ghoul_, A strict bytestring is the closest thing to a plain old void*
17:50:13 <carter> which then lets you in your  ~/.cabal/config
17:50:17 <carter> do a nice overloading thing
17:50:22 <Ghoul_> yes, except I couldn't find out how to go backwards and stuff
17:50:22 <carter> that should get you nice build sanity
17:50:31 <carter> Ghoul_ backwards where?
17:50:35 <Ghoul_> since the file format has pointers all over the place - forwards, backwards, whichway, thatway
17:50:42 <lukexi> carter: underway
17:50:46 <carter> Ghoul_ those are offisets in the byte array
17:50:46 <Ghoul_> binary is from what I gather designed to serialize forwards
17:51:03 <carter> view pointers as explicit sharing
17:51:10 <bgamari> Ghoul_, well, you can at least deserialize the pointers
17:51:18 <bgamari> to offsets
17:51:22 <carter> yeah
17:51:31 <carter> which is also good engineering for format sanity
17:51:44 <Ghoul_> /s/pointers/offsets/
17:52:30 <foscon> ni.gggers
17:52:35 <foscon> fuck off
17:52:50 <foscon> haskell fags
17:52:55 --- mode: ChanServ set +o jmcarthur
17:53:06 <foscon> bITCH
17:53:11 <foscon> NIGGER
17:53:14 --- mode: jmcarthur set +b *!*@gateway/web/freenode/ip.198.144.116.182
17:53:18 --- kick: foscon was kicked by jmcarthur (foscon)
17:53:22 <bgamari> jmcarthur, thanks for that
17:53:26 <carter> thanks
17:53:26 --- mode: jmcarthur set -o jmcarthur
17:53:27 <carter> yeah
17:53:36 <carter> lukexi then add https://gist.github.com/cartazio/5953772  to the end of your cabal config
17:53:41 <Ghoul_> could probably configure lambdabot to autoban
17:53:44 <Ghoul_> they always use the same terms :P
17:53:51 <carter> Ghoul_ auto bans are iffy
17:54:02 <carter> auto anything ever is iffy
17:54:21 <Ghoul_> or at least make them look like an idiot by kicking them
17:54:30 <carter> Ghoul_ doesn't matter
17:55:01 <carter> lukexi theres only one interesting line the linked gist
17:55:02 <bgamari> anywho, back to pure, functional programming
17:55:09 <carter> bgamari i do very mutable thigns
17:55:15 <lukexi> carter cool i see it
17:55:36 <carter> bgamari have you noticed how much i'm struggling to resist using llvm-general and prioritize the past week?
17:55:39 <carter> hehe, prioritize
17:55:57 <carter> lukexi basically, we want to use apple clang for all the building
17:56:08 <jmcarthur> carter: is there any online documentation for llvm-general?
17:56:10 <carter> because then linking to weird / crazy things like C++ code ense sanely
17:56:15 <zRecursive> what's usage of llvm-general ?
17:56:16 <carter> jmcarthur yes, just install it :)
17:56:25 <carter> zRecursive any general use of llvm
17:56:31 <bgamari> carter, I've been trying to restrain myself from writing an IR engine recently
17:56:39 <zRecursive> carter: -fllvm ?
17:56:50 <carter> zRecursive no, for writing your own compilers and things that use llvm
17:57:00 <carter> @hackage llvm-general
17:57:00 <lambdabot> http://hackage.haskell.org/package/llvm-general
17:57:25 <zRecursive> carter: then haskell apps. donot need it ?
17:57:27 <carter> it doesn't have working docs on hackage because llvm isn't there
17:57:30 <carter> zRecursive depends
17:57:38 <zRecursive> carter: thx
17:57:50 <carter> zRecursive you'll know when you need it
17:58:03 <carter> in the mean time don't worry, because you probably dont
17:58:10 <zRecursive> ok
17:58:50 <carter> bgamari honestly i shouldn't be spending time right now adding simd AVX to x86_64 and simd to x86_32 llvm ghc conventions
17:58:54 <carter> but its easy to do
17:58:57 <carter> and someone should do it
17:59:00 <bgamari> carter, definitely!
17:59:05 <bgamari> carter, do it! You can't resist
17:59:10 <carter> bgamari which?
17:59:10 <Ghoul_> "Genering and compiling a zillion numerical type aliases this might take a while..."
17:59:20 <carter> Ghoul_ eh?
17:59:32 <Ghoul_> seen a few of those pop up on cabal recently :P
17:59:39 <carter> Ghoul_ which package?
17:59:43 <Ghoul_> a zillion is a large number
17:59:44 <Ghoul_> uhh
17:59:53 <carter> bgamari do which?
18:00:02 <carter> i've alreayd got the patch under review by llvm folks
18:00:05 <carter> though i may amend it
18:00:20 <bgamari> carter, add "simd AVX to x86_64 and simd to x86_32 llvm ghc conventions"
18:00:21 <Ghoul_> not sure actually, not enough scrollback.
18:00:47 <carter> bgamari i already ddi that
18:00:52 <carter> now just need to get it merged
18:01:20 <bgamari> carter, ahh, then you needn't worry about spending the time; it's already a sunk cost in that caes
18:01:33 <carter> bgamari sunk cost fallacies are bad
18:01:35 <carter> don't do them
18:02:46 <bgamari> carter, it's not a fallacy if it's true ;)
18:03:01 <carter> jmcarthur the docs are very good, just not on hackage
18:36:12 <np_> is there a cleaner way todo this?
18:36:32 <np_> where cdf = S.studentTUnstandardized (df + 1) (mu) (gamma * s * sqrt $ (df+1) / (df + s^2))
19:08:28 <bb010g> How would I use get from Control.Monad.State?
19:10:03 <applikativ> do { currentstate <- get ; put (currentstate+1)}
19:11:41 <bb010g> @undo do { currentstate <- get ; put (f currentstate) }
19:11:41 <lambdabot> get >>= \ currentstate -> put (f currentstate)
19:12:08 <shachaf> bb010g: That can also be written as "modify f". :-)
19:12:15 <applikativ> that's the same as modify f
19:12:46 <applikativ> mine is the same as modify (+1)
19:13:47 <bb010g> shachaf: Thanks!
19:14:10 <applikativ> bb010g: are you using a 'monad' with a MonadState instance?
19:14:18 <Hafydd> @pl get >>= \ currentstate -> put (f currentstate)
19:14:21 <lambdabot> get >>= put . f
19:14:21 <lambdabot> optimization suspended, use @pl-resume to continue.
19:15:18 <applikativ> bb010g: there is also the get and put in Control.Monad.Trans.State.Strict which relate to a particular type rather than a class
19:18:39 <relrod> /1/44
19:18:41 <relrod> oops :(
19:20:21 <np_> :q
19:23:10 <solrize_> http://ghc.haskell.org/trac/ghc/blog failing
19:24:27 <carter> http://ghc.haskell.org/trac/ghc/ works though
19:26:22 <DiegoNolan> What are the advantages and disadvantages of type classes and unions?
19:28:49 <carter> DiegoNolan depends on your goals
19:28:51 <carter> and how you use them
19:29:51 <DiegoNolan> Well lets say a 2D game engine
19:30:06 <DiegoNolan> Should all game objects be in certain type classes
19:30:08 <DiegoNolan> like
19:30:28 <DiegoNolan> class moveableobject where
19:30:49 <DiegoNolan> move :: MoveableObject a => a -> direction -> a
19:31:11 <DiegoNolan> can you even make a data structure
19:31:15 <DiegoNolan> of heterogeneous
19:31:22 <DiegoNolan> types without a union?
19:33:50 <Gracenotes> crazylike
19:34:21 <enthropy> [Dynamic] is one such thing
19:36:59 <carter> sounds like #haskell-game would know :)
19:37:38 <DiegoNolan> how many haskell sub irc's are there
19:37:48 <shachaf> One more than you can handle.
19:38:02 <solrize_> DiegoNolan, http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
19:38:21 <DiegoNolan> yeah
19:38:25 <DiegoNolan> i was just looking at that
19:38:46 <DiegoNolan> that's why i was wondering
19:40:02 <dmwit> Yes, I was going to suggest the "record of functions" solution.
19:40:05 <solrize_> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html    <--- overkill
19:40:08 <dmwit> No need for type classes, really.
19:42:55 <dmwit> solrize_: Hm, yes, and then you will find you want instance Default (MonadI []) and instance Default (MonadI Maybe) so that you can just use "def" instead of naming the right instance as a parameter every time.
19:43:15 <dmwit> And then you start to wonder if maybe, since you're writing "def" as the first argument *every* time, whether the compiler could do that for you...
19:43:23 <dmwit> and suddenly you've invented type classes. ;-)
19:43:35 <solrize_> i knew i could have invented type classes!  :)
19:43:53 <dmwit> hehehe
19:47:04 <isomorphic> This is a silly question - but can somebody desugar something like - in the Maybe monad - do mzero ; return () - I read it as mzero >> return () - but I'm surprised that the mzero affects the computation.
19:48:30 <dmwit> Yes, that desugaring looks fine to me.
19:48:55 <dmwit> ?src (>>) Maybe
19:48:55 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
19:49:01 <dmwit> ?src Maybe (>>)
19:49:01 <lambdabot> (Just _) >>  k      = k
19:49:01 <lambdabot> Nothing  >>  _      = Nothing
19:49:07 <monochrom> do { mzero; dnm } = mzero >> dnm = case Nothing of { Nothing -> Nothing; Just _ -> dnm } = Nothing.
19:49:18 <monochrom> "dnm" stands for "does not matter"
19:49:29 <dmwit> (But what it stands for does not matter.)
19:49:38 <monochrom> haha yeah
19:50:06 <shachaf> preflex: seen dnm
19:50:07 <preflex>  dnm was last seen on #haskell-blah 91 days, 19 hours, 32 minutes and 41 seconds ago, saying: Not stopping by CA on this trip, sadly.
19:50:20 <monochrom> interesting!
19:50:24 <dmwit> Does anybody have a mnemonic for which way ?src's arguments go when you're asking for a class method?
19:50:57 <dmwit> Perhaps "in the same order you'd put it in your source" is what I'll use.
19:50:58 <shachaf> dmwit: It's all a mess anyway.
19:51:01 <shachaf> Just look at this!
19:51:09 <shachaf> @src (->) (>>=)
19:51:09 <lambdabot> f >>= k = \ r -> k (f r) r
19:51:12 <shachaf> (->) isn't even a monad.
19:51:23 <c_wraith> close enough
19:51:29 <c_wraith> just fix the kind, and it's good
19:51:36 <dmwit> It is an idiosyncratic database, I'll certainly give you that.
19:51:59 <dmwit> Imagine how much fun it would be to implement a real database with alpha-variable keys.
19:52:03 <dmwit> Yikes!
19:52:07 <isomorphic> dmwit, monochrom :  Hrm..  Okay, I've made a simple mistake somewhere then!   If (>>) is defined in that way, how does guard work in Maybe?
19:52:18 <dmwit> ?src guard
19:52:19 <lambdabot> guard True  =  return ()
19:52:19 <lambdabot> guard False =  mzero
19:52:26 <shachaf> Hmm, there's an e^ix function.
19:53:26 <shachaf> dmwit: Riddle me this one:
19:53:26 <monochrom> yeah, it's called cis in Data.Complex
19:53:27 <shachaf> @src STRef ==
19:53:27 <lambdabot> STRef v1# == STRef v2# = sameMutVar# v1# v2#
19:53:34 <shachaf> Why not (==)? Because.
19:53:47 <shachaf> @src [] (==)
19:53:47 <lambdabot> []     == []     = True
19:53:47 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
19:53:47 <lambdabot> _      == _        = False
19:53:47 <dmwit> ?src STRef (==)
19:53:47 <lambdabot> Source not found. Whoa.
19:54:02 <dmwit> shachaf: That could and should be fixed.
19:54:04 <dmwit> I nominate you.
19:54:13 <monochrom> guard False = mzero = Nothing
19:54:56 <dmwit> isomorphic: Is your latter question answered? If not, please say.
19:55:32 <shachaf> dmwit: I reject the nomination. Sorry.
19:55:35 <isomorphic> dmwit:  I'm still misunderstanding - I'm running things through ghci to figure out why, but I'd appreciate if you could step through
19:55:59 <dmwit> What would you like me to step through?
19:56:27 <bb010g> @undo do { push 7 }
19:56:27 <lambdabot> push 7
19:56:49 <isomorphic> dmwit:  I think this - guard False >> (return True :: Maybe Bool)
19:57:03 <isomorphic> eg:  mzero >> (return True :: Maybe Bool)
19:57:09 <isomorphic> > mzero >> (return True :: Maybe Bool)
19:57:10 <lambdabot>   Nothing
19:57:14 <dmwit> guard False >> return True = mzero >> return True = Nothing >> return True = Nothing
19:57:24 <elliott> dmwit: do you know how @src works?
19:57:27 <elliott> it's pretty great.
19:57:37 <dmwit> equation 1 by definition of guard; 2 by definition of mzero; 3 by definition of (>>)
19:57:57 <dmwit> elliott: Sort of. It looks up a line in a fortune file-like database, right?
19:58:02 <elliott> right.
19:58:09 <elliott> it's nothing haskell-specific at all, really.
19:58:14 <elliott> all it does is collapse whitespace and stuff.
19:58:17 <bb010g> @quote
19:58:17 <lambdabot> Gulli says: everything seems much easier in Haskell
19:58:27 <dmwit> That's why it ought to be easy to fix STRef == to STRef (==), though.
19:58:49 <elliott> right. a good job for shachaf
19:58:58 <shachaf> No.
19:59:05 <isomorphic> dmwit:  Thanks! Yes, that makes sense now.    If return True were a more complex function - would it be guaranteed not to be evaluated ?
19:59:55 <isomorphic> (In the Nothing >> dnm case that is)
20:00:10 <dmwit> Yes.
20:00:53 <isomorphic> dmwit:  Thanks :)  I realise these probably seem like silly questions - I'm just making trying to get any magic out of my understanding :)
20:01:50 <CaptainK> can you give an example of @src? I'd like to look up a word "fabek" in a list and return the match ["fabek - a first name"]
20:02:01 <isomorphic> @src Maybe (>>)
20:02:01 <lambdabot> (Just _) >>  k      = k
20:02:01 <lambdabot> Nothing  >>  _      = Nothing
20:03:16 <enthropy> @src foldr
20:03:16 <lambdabot> foldr f z []     = z
20:03:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:03:40 <CaptainK> haven't been to the part in lyah describing the >>,  seen it now a lot and it looks like a nice shortcut to relating something
20:04:05 <dmwit> https://github.com/mokus0/lambdabot/pull/68
20:04:10 <dmwit> shachaf: =)
20:05:16 <dmwit> > filter ("fabek" `isInfixOf`) ["daniel - a first name", "fabek - a last name"] -- CaptainK
20:05:17 <lambdabot>   ["fabek - a last name"]
20:05:34 <elliott> daniel "dmwit" fabek
20:05:35 <CaptainK> wow kick ass
20:06:40 <dmwit> isomorphic: I didn't find your questions silly.
20:06:50 <bb010g> @src Control.Monad.Trans.RWS.Lazy.get
20:06:51 <lambdabot> Source not found. My brain just exploded
20:07:16 <dmwit> Pfft, what do I care if your brain exploded? You're not even Facebook friends with me any more.
20:07:23 <bb010g> :)
20:07:32 <dmwit> ?src State get
20:07:33 <lambdabot> Source not found. My brain just exploded
20:07:53 <dmwit> get = state (\s -> (s, s)) -- approximately
20:07:55 <tabemann> lambdabot's brain sure explodes often
20:07:55 <bb010g> dmwit: lambdabot's on Facebook?
20:07:56 <dmwit> for StateT
20:08:09 <dmwit> bb010g: Nah. It's a callback to a bit earlier when I got the ?src syntax wrong.
20:10:16 <bb010g> Stupid question: How do I chain pushes in something like "runState (push 7) [4,2]"?
20:10:30 <bb010g> Or any modify, really.
20:10:38 <shachaf> (push 7 >> push 8)?
20:11:06 <bb010g> shachaf: Why does that work?
20:11:31 <CaptainK> dmwit: can't remember how to query lambdabot about what 'isInfixOf' belongs to for import?
20:11:32 <shachaf> What do you mean?
20:11:50 <dmwit> ?index isInfixOf
20:11:51 <lambdabot> bzzt
20:11:56 <bb010g> shachaf: I thought >> replaced things...
20:11:58 <dmwit> ?hoogle isInfixOf
20:11:58 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
20:11:58 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
20:11:58 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
20:12:23 <bb010g> shachaf: At least with Maybe.
20:12:38 <tabemann> >> sequences actions
20:12:47 <Gracenotes> @src (>>) State
20:12:47 <lambdabot> Source not found. Whoa.
20:12:50 <Gracenotes> @src (>>=) State
20:12:50 <lambdabot> Source not found. Are you typing with your feet?
20:12:51 <tabemann> it just happens that that does not preserve values for Maybe, but that's just Maybe
20:12:52 <shachaf> foo :: State s a really means foo :: s -> (s, a)
20:12:56 <Gracenotes> how sad
20:12:59 <dmwit> ?src State (>>)
20:12:59 <lambdabot> Source not found. You speak an infinite deal of nothing.
20:13:03 <dmwit> ?src State (>>=)
20:13:03 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:13:07 <bb010g> ?src Writer (>>)
20:13:07 <lambdabot> Source not found. Abort, Retry, Panic?
20:13:12 <shachaf> So (>>) :: (s -> (s, a)) -> (s -> (s, b)) -> s -> (s, b)
20:13:14 <dmwit> ?src StateT (>>=)
20:13:15 <lambdabot> Source not found. Abort, Retry, Panic?
20:13:17 <bb010g> @src Writer (>>)
20:13:17 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:13:18 <dmwit> oh, bugger
20:13:27 <shachaf> (>>) f g s = let (s', _) = f s in g s'
20:13:40 <Gracenotes> oh shachaf, you're so smart
20:13:50 <Gracenotes> can you be lambdabot
20:14:03 <bb010g> So it just throws out the "normal" output and sticks the monadic part in?
20:14:03 * Gracenotes makes dinner
20:14:38 <enthropy> @djinn f :: (s -> (s, a)) -> (s -> (s, b)) -> s -> (s, b)
20:14:39 <lambdabot> Cannot parse command
20:14:54 <tabemann> lambdabot isn't helping much today
20:16:17 <tabemann> bb010g: yes, >> takes one action, discards any associated value (you know what I mean), and sequences it with another following action, giving an action with the associated value from the second action (I am not going to get into the exact semantics of "associated value" here)
20:16:52 <shachaf> @djinn (s -> (s, a)) -> (s -> (s, b)) -> s -> (s, b)
20:16:52 <lambdabot> f a b c =
20:16:52 <lambdabot>     case b c of
20:16:52 <lambdabot>     (_, d) -> case a c of
20:16:52 <lambdabot>               (e, _) -> (e, d)
20:17:05 <shachaf> But really you want indexed state here.
20:17:08 <dmwit> djinn really knows how to pick names
20:17:16 <shachaf> @djinn (s -> (s', a)) -> (s' -> (s'', b)) -> s -> (s'', b)
20:17:16 <lambdabot> f a b c =
20:17:16 <lambdabot>     case a c of
20:17:16 <lambdabot>     (d, _) -> b d
20:18:18 <dmwit> Funny. The first ?djinn ran the states in the "wrong" order.
20:18:42 <dmwit> Which accounts for the longer source.
20:18:43 <elliott> not even.
20:18:49 <elliott> it ran them both with the same state.
20:18:57 <elliott> and then took the output state of the first.
20:18:58 <dmwit> err?
20:19:02 <dmwit> oh, wow
20:19:07 <elliott> not terribly clever.
20:19:16 <dmwit> Just goes to show how hard you will look for state-passing if it's what you're expecting. -_-
20:19:23 <dmwit> s/you/I/
20:19:24 <elliott> I wonder if you could "refine" djinn's output by making it pretend it has a substructural type system as much as possible.
20:19:27 <elliott> or something.
20:19:44 <elliott> so it would try to be "forced" by the types more, by pretending they're stricter about what it can pass around.
20:20:34 <copumpkin> I thought djinn did try to use all arguments as much as it could
20:20:53 <elliott> right. but it's also about order and such.
20:21:00 <copumpkin> oh
20:21:23 <enthropy> maybe there's a non-deterministic djinn out there
20:21:28 <elliott> the question is whether with a sufficiently strict pretend-type-system it could auto-derive the right (>>) for State.
20:21:31 <enthropy> pick the version that generates the longest code
20:21:44 <shachaf> But here the shorter code is correct.
20:21:56 <shachaf> Well, you could write the same thing with more code. But there'd be no point.
20:22:08 <enthropy> the shortest code would be const
20:22:26 <enthropy> or maybe undefined... if djinn was allowed that
20:22:39 <shachaf> If djinn allowed undefined there would be no point.
20:22:42 <enthropy> oops flip const
20:23:08 <shachaf> > (compare `on` length) "flip const" "const id"
20:23:09 <lambdabot>   GT
20:23:18 <shachaf> f _ x=x -- even shorter!
20:23:52 <dmwit> f _=id
20:23:54 <tabemann> obviously length, whether short or long, is not a good metric for correctness
20:25:51 <shachaf> Every program djinn generates is correct.
20:25:59 <shachaf> Therefore length is a reasonable thing to optimize.
20:26:32 <tabemann> okay, correct is not the right word to describe this then
20:26:34 * tabemann feels dumb
20:27:09 <shachaf> I was only making a joke, I think.
20:28:25 <tabemann> but you make a point there
20:28:58 <tabemann> so what do we call the quality of what is most desirable in a program outputted by djinn, as correctness isn't it?
20:29:38 <shachaf> "desirable", I suppose, by definition.
20:29:55 <shachaf> @quote SaulGorn
20:29:55 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
20:30:57 <enthropy> but is there a reason it picks to run the first action in  @djinn (s -> (s, a)) -> (s -> (s, b)) -> s -> (s, b)?
20:32:42 <shachaf> It tries to use all arguments.
20:34:59 <tabemann> there is certainly only so much DWIM one can program into djinn
20:37:58 <shachaf> djinn is not intended to DWYM
20:38:23 <Hafydd> Deduce What I/You Mean?
20:38:42 <tabemann> Do What I/You Mean
20:38:58 <Hafydd> Looks like I failed to accurate DWYM.
20:42:48 <tabemann> it's not intended to DWYM, obviously, but we here have certainly been speak of it as if it should, or else its choosing an expression that is type-correct but not the "right" one wouldn't be a topic of discussion
20:43:24 <bb010g> @pl Just [4,2] >>= (\x -> Just (1:x))
20:43:27 <lambdabot> Just [4, 2] >>= Just . (1 :)
20:43:27 <lambdabot> optimization suspended, use @pl-resume to continue.
20:43:51 <Gracenotes> djinn is a mechanical turk
20:45:25 <bb010g> Is there anyway to automatically make a monadic function out of a normal one? (Example: Turn "(1:)" into "(\x -> Just (1:x))")
20:45:40 <byorgey> bb010g: yes,  return . f
20:46:09 <tabemann> or liftM f, if that was meant slightly differently
20:46:35 <bb010g> byorgey: return . f works. Thanks!
20:46:53 <byorgey> tabemann: I used the given example as a template
20:48:06 <tabemann> again, I should've noticed the Maybe monad in use...
20:48:30 <tabemann> (forget what I said)
20:50:38 <tabemann> okay, something I'm wondering about - is there anything complete (but readable) on the particular runtime model used by GHC
20:51:06 <tabemann> I ask because I've read quite a bit here and there, but apparently I'm missing points about the exact semantics of code compiled by GHC
20:54:08 <anon123> hpaste.org seems to be down at the moment.  Is there a preferred alternative?
20:54:14 <byorgey> @where hpaste
20:54:14 <lambdabot> http://paste.tryhaskell.org/new/haskell
20:54:33 <Gracenotes> the best overview of the idea behind GHC's operational semantics I think is Implementing Lazy Functional Languages on Stock Hardware
20:54:38 <monochrom> it is due to DNS problems with the name "hpaste.org"
20:54:55 <shachaf> @where stg , yes.
20:54:55 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
20:54:58 <byorgey> soon it will migrate to its new permanent home, paste.haskell.org
20:55:06 <anon123> sounds good
20:55:23 <byorgey> but for now we are stuck in limbo
20:55:49 <shachaf> What are we waiting on for hpaste.org?
20:55:58 <shachaf> It's shorter, so I much prefer it to paste.haskell.org
20:56:18 <byorgey> ultimately the hope is that hpaste.org will redirect to paste.haskell.org
20:56:23 <monochrom> perhaps ask chrisdone or @tell him
20:56:37 <tabemann> back
20:56:53 <tabemann> Gracenotes: on the web or on dead tree only?
20:56:54 <shachaf> byorgey: Why?
20:57:00 <monochrom> my understanding is that some greedy and/or incompetent DNS company refuses to let go.
20:57:10 <byorgey> shachaf: why will it redirect? or why switch at all?
20:57:56 <dmwit> Why will it redirect?
20:57:58 <shachaf> Well, either.
20:58:08 <shachaf> I don't object to paste.haskell.org being a working URL, but hpaste.org is shorter and works just as well.
20:58:31 <Gracenotes> tabemann: on web. google title if you like.
20:58:43 <byorgey> if you took 'redirect' to mean some particular technical HTTP thingy, I don't know what I'm talking about.
20:58:48 <tabemann> Gracenotes: found it
20:58:53 <byorgey> maybe hpaste.org will still work instead of redirecting.
20:59:10 <byorgey> I just meant that the official place it will be hosted is on haskell.org.
20:59:22 <bb010g> @src maybe
20:59:22 <lambdabot> maybe n _ Nothing  = n
20:59:22 <lambdabot> maybe _ f (Just x) = f x
20:59:23 <shachaf> There might be vague security concerns with paste.haskell.org being a subdomain of haskell.org
20:59:36 <dmwit> byorgey: I'm not sure that sentence makes sense.
20:59:37 <shachaf> But as it is haskell.org probably has much bigger concerns, like sending everything in plaintext. :-(
20:59:53 <byorgey> dmwit: it probably doesn't.
21:00:07 <dmwit> I think I see what you're driving at, though?
21:00:19 <dmwit> The idea is that hpaste.org will be hosted on the same hardware as all the other haskell.org services.
21:00:22 <dmwit> yes?
21:00:25 <byorgey> right.
21:00:56 <byorgey> I think I see your point now -- it could still be hosted on the same hardware but still at the URL hpaste.org.
21:01:14 <dmwit> Well, many domains could point to that hardware, yes. =)
21:01:23 <byorgey> right, OK.
21:01:56 <byorgey> in any case I don't think any firm decisions have been made about the domain.  Just the hosting.
21:02:07 <dmwit> ok
21:04:29 <hpaste> anon123 pasted “BSPTree” at http://paste.tryhaskell.org/90751
21:04:36 <mstksg> where should i store extensions to libraries in source code?
21:04:46 <anon123> anyone know why my insert is eating my elements?
21:05:20 <anon123> style suggestions are also welcome, but fyi this is very very preliminary code
21:06:32 <Gracenotes> do you have a really simple example?
21:06:39 <anon123> example is in the paste
21:06:42 <anon123> with output
21:07:23 <anon123> I should have 27 elements
21:07:44 <dmwit> Do simpler examples still exhibit the problem?
21:07:54 <dmwit> (How simple can you make it?)
21:08:35 <dmwit> This is a good debugging technique, by the way: I have found bugs just by having things click while trying to make a minimal failed test case.
21:09:17 <anon123> let me try something
21:12:13 <anon123> welp, using [1..2] and limiting nelems to 3 I get 8 elements (which is correct), so... hmmm
21:16:54 * sm thinks click as in audio ? hmm I really need a clickTrace
21:20:46 <anon123> I think I just sidetracked all of #haskell lol
21:23:06 <byorgey> mstksg: I don't understand your question.
21:23:09 <monochrom> don't worry, I held my tongue on a gripe I have always made on the topic
21:23:48 <byorgey> mstksg: can you give an example perhaps?
21:30:58 <c_wraith> > replicateM 3 [1, 2]
21:30:59 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
21:33:48 <mstksg> monochrom: i want to implement a typeclass over a type in a library
21:35:59 <mstksg> but i think i'm just going to make a type synonym and implement the typeclass on that
21:42:01 <byorgey> mstksg: you will need a newtype, not a type synonym.
21:42:26 * tabemann from reading over this paper on STG didn't know that a branch was being done upon getting the value of a boxed value each time that was done, even if it had already been evaluated
21:43:41 <Gracenotes> some of the things in the paper are no longer true
21:44:11 <Gracenotes> but, well, it is true that a lot of times it won't have already been evaluated.
21:44:18 <tabemann> not surprising, since it was written in 1992
21:44:30 <Gracenotes> if GHC is certain, it can throw away the boxes entirely.
21:44:44 <shachaf> tabemann: The paper describes a high-level operational model.
21:44:54 <shachaf> It's also about 20 years old.
21:45:26 <Pseudonym> For a paper on a supposed "machine", the STG paper is light on operational semantics.
21:45:32 <shachaf> For more details on the kind of code GHC actually generates you'll want to read some other and/or code that GHC actually generates.
21:45:38 <shachaf> @where ptr-tag
21:45:39 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
21:45:42 <shachaf> @where eval-apply
21:45:42 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
21:45:43 <shachaf> @where cpr
21:45:44 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
21:45:48 <shachaf> For example those three.
21:46:00 <Gracenotes> also, the GHC source code
21:46:09 <Gracenotes> is pretty massive, though.
21:46:31 <Pseudonym> It has mass?
21:46:43 <Gracenotes> yeah, it's all of the 1s
21:46:59 <Hafydd> It has entropy, so it has energy, so it has mass.
21:47:32 <tabemann> shachaf: will probably get to those after I am done reading the STG paper
21:47:40 <frankbro> Anyone is aware of the ast design for haskell is available somewhere?
21:47:45 <shachaf> They are much shorter.
21:47:55 <shachaf> What are other good papers to read to learn about how GHC compiles code?
21:47:59 <shachaf> I should make a list somewhere.
21:48:36 <Gracenotes> anything on core optimization?
21:48:43 <Pseudonym> The commentary.
21:48:51 <shachaf> Yes, the commentary is good.
21:49:02 <Gracenotes> I mean, STG is not that different from Core really.
21:49:09 <shachaf> Gracenotes: Hmm, maybe the inliner paper?
21:49:12 <shachaf> @where inlining
21:49:12 <lambdabot> I know nothing about inlining.
21:49:20 <shachaf> @where+ inlining http://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/
21:49:20 <lambdabot> Done.
21:49:51 <Pseudonym> Ministg is also a good one to look at.
21:50:19 <shachaf> Note that I haven't even read half these papers! I shouldn't be talkin'.
21:51:10 * tabemann saves these papers away to look at them later
21:51:18 <shachaf> @where ministg
21:51:18 <lambdabot> I know nothing about ministg.
21:51:30 <Pseudonym> https://github.com/bjpop/ministg
21:51:31 <shachaf> @where+ ministg http://www.haskell.org/haskellwiki/Ministg
21:51:31 <lambdabot> It is forever etched in my memory.
21:51:34 <shachaf> Oh, or that.
21:51:46 <shachaf> I think the wiki page is more informative.
21:52:17 <Pseudonym> Yeah.
21:52:28 <Pseudonym> Even more informative, I often commute on the same train as Bernie Pope.
21:53:34 <shachaf> preflex: seen bjpop
21:53:36 <preflex>  Sorry, I haven't seen bjpop
21:55:32 <dmwit> frankbro: haskell-src-exts has an AST type that covers most of GHCskell. Is that the kind of thing you're looking for?
21:57:02 <Pseudonym> @google a systematic derivation of the stg machine
21:57:03 <lambdabot> http://www.cs.ox.ac.uk/files/3858/pirog-biernacki-hs10.pdf
21:57:04 <lambdabot> Title: A Systematic Derivation of the STG Machine Verified in Coq
21:57:08 <frankbro> dmwit, aw, I think its perfect yes, thank you
21:57:24 <Gracenotes> I think I.. tried to make it through some of that paper once
21:57:38 <Pseudonym> @google the brisk machine
21:57:39 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.8708
21:57:40 <lambdabot> Title: CiteSeerX — The Brisk Machine: A Simplified STG Machine
21:57:47 <Pseudonym> Haven't read that one
21:58:30 <Gracenotes> 'yay, stg is grounded in operational semantics a bit'
21:58:40 <tabemann> okay, will be going to bed soon, but thanks for all the reading
21:59:56 <b6> could somebody try to build https://github.com/bsl/bindings-GLFW using only the haskell platform on windows? we know it builds with msys, but hope it only needs the HP.
22:01:46 <bb010g> @src Maybe return
22:01:46 <lambdabot> return              = Just
22:02:06 <bb010g> @src Either return
22:02:06 <lambdabot> return        = Right
22:02:27 <bb010g> @src Writer return
22:02:28 <lambdabot> Source not found. My brain just exploded
22:02:43 <bb010g> @src State return
22:02:43 <lambdabot> Source not found. stty: unknown mode: doofus
22:03:05 <bb010g> @src [] return
22:03:05 <lambdabot> return x    = [x]
22:03:26 <bb010g> @src Either >>
22:03:27 <lambdabot> Source not found. Abort, Retry, Panic?
22:03:33 <bb010g> @src Maybe >>
22:03:33 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:03:37 <bb010g> ?src Maybe >>
22:03:38 <lambdabot> Source not found. I am sorry.
22:03:40 <bb010g> ?src Maybe (>>)
22:03:41 <lambdabot> (Just _) >>  k      = k
22:03:41 <lambdabot> Nothing  >>  _      = Nothing
22:03:49 <bb010g> ?src Either (>>)
22:03:49 <lambdabot> Source not found. Are you typing with your feet?
22:04:00 <bb010g> ?src Either (>=)
22:04:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:04:04 <bb010g> ?src Either (>>=)
22:04:04 <lambdabot> Left  l >>= _ = Left l
22:04:04 <lambdabot> Right r >>= k = k r
22:04:23 <bb010g> ?src [] (>>=)
22:04:23 <lambdabot> xs >>= f     = concatMap f xs
22:04:28 <lambdabot> You can /msg me directly, by the way.
22:04:50 <DigitalKiwi> took lambdabot long enough
22:05:10 <lambdabot> I usually go the passive-aggressive route first.
22:06:08 <DigitalKiwi> oh someone has anonymous say on the bot ;p
22:15:33 <mstksg> i've been stuck for days on trying to combine ST and Rand so that the ST can be unwrapped first.  can anyone help me?
22:15:55 <mstksg> i need to implement PrimMonad for STT so I can use it with mutable vectors
22:16:43 <mstksg> but the types of the PrimMonad functions are too complex for me to understand
22:27:55 <copumpkin> mstksg: there's a reason STT doesn't exist
22:28:08 <copumpkin> and that is that it doesn't really work
22:28:42 <copumpkin> mstksg: same reason you don't find an IOT, really
22:29:01 <shachaf> I think elliott had some sort of idea about STT?
22:29:14 <shachaf> Or at least a transformer that gives you one aspect of ST.
22:31:28 <roboguy_> mstksg: why do you need to combine ST and Rand?
22:33:11 <arkeet> use a transformer over ST instead.
22:33:33 <copumpkin> well, that would have different semantics :)
22:33:40 <copumpkin> you can't just go flippin ur monadz
22:33:42 <arkeet> I don't know what semantics we are looking for.
22:34:03 <copumpkin> I don't either! just pointing out that they'd do different thigns
22:34:18 <shachaf> One of them does a very useful thing, namely existing.
22:34:25 <copumpkin> pfft
22:34:27 <copumpkin> overrated
22:34:36 <shachaf> Wow, what kind of constructivist are you?
22:34:51 <copumpkin> I'm an ultrainfinitist
22:35:01 <copumpkin> the finite is illusory
22:36:15 <mstksg> roboguy_  i have a computation that runs multiple ST computations, and they all are under one big Rand monad
22:43:27 <evincar> That feeling when you mentally remove the "co" from words that have nothing to do with category theory.
22:44:41 <kamatsu> envincar like "mputation"?
22:44:45 <arkeet> or "ffee"
22:45:11 <evincar> Yes. :|
22:45:33 <evincar> Also "nstructivist".
22:46:06 <arkeet> de
22:57:08 <rien> I think I'm just going to leave a question here
22:58:02 <rien> am I understanding denotational semantics correctly to think that if I write the d.s. for a function I wrote and run it through a theorem prover, I can check the correctness of that function I wrote?
23:01:16 <rien> oh! wait, is that why parser generators are always correct according to their specification? - because when writing a parser/compiler one defines the syntax and the semantics?
23:12:44 <ChongLi> cabal-dev install-deps is failing due to a conflicting version of base :(
23:13:13 <ChongLi> any way around this?
23:14:09 <ChongLi> the project depends on base-4.5.* and I have base-4.6.*
23:14:43 <evincar> Any difference with cabal-dev install --only-dependencies?
23:14:54 <evincar> I haven't used install-deps
23:15:09 <ChongLi> where will that install?
23:15:26 <ChongLi> I just want to download dependencies into this project so I can work on it
23:15:29 <evincar> ./cabal-dev or --builddir=SOMEWHERE
23:15:37 <ChongLi> oh ok
23:15:52 <ChongLi> yeah, could not resolve dependencies
23:16:17 <b6> ChongLi: please ask the authors to loosen up that base requirement. technically A.B.* is safest, but i think everyone loosens base to, e.g., < 5.
23:16:37 <ChongLi> ok :)
23:16:41 <ChongLi> the author is my friend, actually
23:16:49 <ChongLi> we're both learning together
23:32:28 <ChongLi> any advice about avoiding conflicts between stuff I use (such as xmonad, xmobar) and stuff I'm developing with cabal-dev?
23:34:14 <MercurialAlchemi> Hi folks
23:34:18 <ChongLi> hi
23:34:30 <MercurialAlchemi> I have the following data structures: http://paste.tryhaskell.org/90752
23:34:47 <MercurialAlchemi> I'd like to get all the names of the latest projects using lenses
23:35:15 <MercurialAlchemi> (as in Control.Lens)
23:35:33 <ChongLi> yeah
23:36:51 <ChongLi> just a sec
23:46:05 <ChongLi> hi
23:46:07 <ChongLi> still here?
23:46:32 <ChongLi> MercurialAlchemi?
23:48:32 <MercurialAlchemi> ChongLi: yep
23:49:04 <shachaf> ChongLi: toListOf (envProjects.traverse.projName) ?
23:49:07 <shachaf> Er, MercurialAlchemi:
23:50:22 <ChongLi> does that work for you?
23:50:28 <supki> > (length "traverse", length "folded")
23:50:30 <lambdabot>   (8,6)
23:50:42 <shachaf> > length "each"
23:50:43 <lambdabot>   4
23:50:52 <shachaf> So, like, whatever, man.
23:51:17 <MercurialAlchemi> shachaf: you mean env^.envLastProjects.traverse.projName?
23:51:32 <supki> ^..
23:51:37 <MercurialAlchemi> shachaf: (assuming env is an Env)
23:51:41 <shachaf> MercurialAlchemi: No, I mean what I said. You could also write it as env ^.. .envLastProjects.traverse.projName
23:52:02 <b6> i don't blame him for asking. it looks pretty weird.
23:52:03 <shachaf> Er, without that .
23:52:19 <shachaf> env ^.. envLastProjects.traverse.projName
23:52:26 <shachaf> env ^.. envLastProjects.each.projName
23:52:28 <shachaf> Whatever.
23:54:05 <MercurialAlchemi> this seems indeed to appease the typechecker without the need to sacrifice further goats
23:54:42 <b6> are lenses reasonably fast? it'd be ok to use them in a game, etc?
23:55:32 <MercurialAlchemi> I think I need to find a good guide to lenses
23:55:43 <Ghoul_> does attoparsec work with unicode
23:55:54 <MercurialAlchemi> all this stuff with Getting, etc is a bit above my head right now
23:55:58 <shachaf> I should finish writing my lens guide!
23:56:09 <b6> Ghoul_: i think not.
23:56:37 <shachaf> b6: In the average case you can expect simple lensy code to compile to the same thing you would have gotten without lenses.
23:56:51 <shachaf> b6: Sure it does, doesn't it? Data.Attoparsec.Text?
23:56:59 <canta> Is the @src for sort / sortBy / insertBy that lambdabot returns really what ghc is using when you use Data.List (sort)?
23:57:06 <shachaf> canta: No.
23:57:13 <MercurialAlchemi> shachaf: shachaf^.lens.guide? :)
23:57:24 <shachaf> :t lens
23:57:25 <lambdabot> Not in scope: `lens'
23:57:27 <b6> shachaf, Ghoul_: woah, sorry. looks like i was wrong. i think attoparsec didn't have Text stuff initially.
23:57:29 <shachaf> That's a type error, anyway.
23:57:32 <b6> but it seems to now.
23:57:45 <Ghoul_> oh okay
23:57:54 <Ghoul_> so as long as I dont use the Char8 stuff I guess
23:58:19 <Ghoul_> (at least, dont make assumptions)
23:58:39 <shachaf> MercurialAlchemi: Hmm, look at what I wrote here: http://stackoverflow.com/a/13436546/712548
23:59:48 <MercurialAlchemi> shachaf: ok, that helps
23:59:55 <MercurialAlchemi> thanks folks
