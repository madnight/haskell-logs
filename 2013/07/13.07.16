00:01:17 <CaptainK> Cale: what is the "." in your statement a place holder?
00:08:04 <mr-> CaptainK: that's function composition
00:08:07 <mr-> :t (.)
00:08:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:08:37 <mr-> it literally does what the type says ;-)
00:08:41 <mr-> (like in math)
00:08:53 <CaptainK> so I need it to differentiate between different elements passed to a function?
00:10:19 <mr-> CaptainK: hmm? ( f . g ) x = f ( g x )
00:11:10 <hrex> f (x : y) = y : x
00:11:17 <hrex> why does this not work?
00:11:18 <CaptainK> ah ok
00:11:46 <CaptainK> > f (x : y) = y : x
00:11:48 <lambdabot>   <hint>:1:11: parse error on input `='
00:11:56 <johnw> hrex: think about what the types of x and y must be
00:12:05 <mr-> hrex: suppose f :: [a] -> [a], what are the types of x and y?
00:12:14 <hrex> numbers
00:12:26 <mr-> no, y is a list of ...
00:13:20 <hrex> f (x : y) = x : y works
00:13:53 <hrex> what is happening behind the scene here?
00:13:56 <mr-> hrex: f is of type [a] -> [a], x has type a and y has type [a]
00:13:56 <MasseR> hrex: What is the type of x? What is the type of y? Then why does x : y work, but y : x doesn't
00:14:07 <mr-> and also:
00:14:10 <mr-> :t (:)
00:14:11 <lambdabot> a -> [a] -> [a]
00:14:39 <MasseR> hrex: x is a number. y is a list of numbers. Therefore you can't append a list of numbers to a number
00:14:45 <MasseR> But you can append a number to a list of numbers
00:15:09 <MasseR> 1 : [1,2,3] -- ok
00:15:14 <MasseR> [1,2,3] : 1 -- not ok
00:15:24 <MasseR> See what mr- said about the type of :
00:16:20 <hrex> how do I check the type of (:) in ghci?
00:16:22 <CaptainK> < [1,2,3] ++ 1
00:16:28 <MasseR> hrex: :t (:)
00:16:29 <c_wraith> hrex: :t (:)
00:16:29 <mr-> hrex: via :t (:)
00:16:32 <CaptainK> > [1,2,3] ++ 1
00:16:34 <lambdabot>   No instance for (GHC.Show.Show a0)
00:16:34 <lambdabot>    arising from a use of `M1779385920.sh...
00:16:36 <c_wraith> too many answers!
00:16:44 <c_wraith> @quote stereo
00:16:44 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
00:16:50 <c_wraith> haha
00:16:50 <CaptainK> > [1,2,3] ++ [1]
00:16:50 <hrex> thanks
00:16:51 <lambdabot>   [1,2,3,1]
00:16:53 <MasseR> You need to set turn infix : function into a prefix (:) function
00:16:54 <mr-> CaptainK: ++ expects a list on both sides :)
00:17:00 <Gracenotes> @quote glorious
00:17:00 <lambdabot> piroko says: Powerbook + external monitor + xmonad = glorious
00:17:52 <CaptainK> ok, got it, but I also read that its not a good idea to add long lists on the end because haskell has to read the whole line first and that can take some time depending on code
00:17:55 <c_wraith> @quote monochrom glorious
00:17:55 <lambdabot> No quotes match. My pet ferret can type better than you!
00:17:59 <c_wraith> drat.
00:18:06 <c_wraith> I'm misattributing quotes in my memory!
00:18:24 <MasseR> CaptainK: You're right. xs ++ ys is slow
00:18:25 <hrex> f (x : y) = y ++ [x]
00:18:32 <hrex> now it works
00:19:12 <mr-> hrex: great, but do you understand how there is no magic involved in your earlier version?
00:19:44 <hrex> mr-: I just get confused by the hidden implications
00:19:54 <CaptainK> its crazy I can "code" in haskell and not understand what the fuck I'm doing :P
00:19:56 <MasseR> hrex: Hidden implications?
00:20:11 <MasseR> CaptainK: The understanding and intuition comes with time
00:20:37 <mr-> hrex: just pay attention to the types, then you won't find magic for a long time
00:20:57 <CaptainK> MasseR: ya, so frustrating though...arggg...it really helps to have an underlying knowledge, not just memorize constructs
00:21:42 <MasseR> CaptainK: True. Altough I don't think I've ever 'memorized'. I got the intuition pretty quickly, but I'm still waiting for the proper understanding :P
00:21:52 <MasseR> Intuition helps keeping interest up
00:24:25 <killy9999> I have two function: a -> Maybe b and b -> c
00:24:36 <killy9999> how can I compose them to get a -> m (Maybe c)
00:24:42 <killy9999> where m is a monad
00:24:44 <killy9999> ?
00:24:57 <mr-> a combination of return and fmap?
00:25:12 <killy9999> yeah, but I'm thinking which combination will that be :D
00:26:17 <shachaf> You're allowed to use lambdas.
00:27:02 <killy9999> well,I'm trying to avoid lambdas
00:27:35 <killy9999> although if I turn b -> c into b -> Maybe c the task becomes trivial
00:27:48 <mr-> \x -> return $ (fmap g) $ (f x) ?
00:27:48 <hsyl20> killy9999: return . fmap g . f (where f and g are your two functions)
00:28:26 <shachaf> If you have to ask for help, you shouldn't be avoiding lambdas.
00:28:31 <CaptainK> ok, to summarize, main must have IO action so put shit outside main or use print $ map,  print is putStrLn . show, GHCi automagically prints, (f . y)x is f (x y) and watch use of ":"!
00:28:46 <shachaf> Write out the version with the lambdas first. Then you can get rid of them.
00:29:23 <killy9999> hsyl20: that seems to work.thanks!
00:29:37 <shachaf> Also you're probably wanting the wrong thing.
00:29:47 <shachaf> That "m" is completely arbitrary.
00:30:06 <killy9999> so?
00:30:33 <killy9999> I mean in my program m is a particular monad, but I don't think that affects the solution
00:33:50 <CaptainK> thanks so much guys, now time to dream a little haskell, sometimes that helps :)
00:34:27 <johnw> CaptainK: surprisingly, that helps quite a bit in fact :)
00:35:48 <CaptainK> I really have been dreaming...was going around with a function and putting everything inside it...weird.
00:36:37 <CaptainK> night
00:36:45 <johnw> I've found that the road to learning Haskell is peppered with sudden moments of "shocking clarity", when your subconscious finally works out a knot you've been puzzling over for weeks or months.  The other day it happened for me with conduit
00:37:51 * Kinnison still needs to grasp Conduit.  I read through it yesterday and intend to read through the fpcomplete tutorial tonight
00:40:54 <notdan> Kinnison: I highly recommend watching this talk: http://skillsmatter.com/podcast/home/lazy-io-and-alternatives-in-haskell/jd-7959
00:41:22 <notdan> It explains the design of pipes/conduits in a conscious way
00:41:27 * Kinnison bookmarks
00:41:34 <johnw> notdan: is there any way to watch that which isn't either in a super tiny window or full screen?
00:41:48 <notdan> that's how I got the basic graps of pipes :)
00:41:56 <notdan> johnw: none that I konw of :(
00:42:14 <johnw> skillsmatter.com feels like 1995 all over again
00:42:23 <notdan> Apparently they made the video watchable/embeddable on their site only, so you can't watch it on Vimeo
00:42:26 * hackagebot direct-sqlite 2.3.6 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.6 (IreneKnapp)
00:43:08 <Kinnison> johnw: Try: wget -O /tmp/conduit.mp4 "http://pdl.vimeocdn.com/38091/019/176319370.mp4?aksessionid=bc21441f20c4e2e534e2f566c5d8cbe5&token=1373967718_1c73700731ea72c4488685470f9c6f52"
00:43:24 <shachaf> johnw: Open http://player.vimeo.com/video/70060895?title=1&byline=0&portrait=0&color=ffffff in any size window you like
00:43:40 <johnw> shachaf: I get "Sorry"
00:43:42 <shachaf> Or that.
00:43:55 <johnw> sweet, thank you Kinnison!
00:43:56 <shachaf> Hmm, works for me.
00:44:06 <notdan> yeah I can't open it either, I tried that before
00:44:10 <johnw> shachaf: interesting, I've never been able to view any of the vimeo links before
00:44:16 <notdan> The creator of this video has not given you permission to embed it on this domain. This is a Vimeo Plus feature.
00:50:58 <adinapoli> johnw: Once I had one of those epiphanies while brushing my teeth :D
01:01:12 <dmj> yo
01:06:58 <Ghoul_> I was hoping someone could give me some criticism on my first monad: the Chrono monad -- http://lpaste.net/90949
01:07:48 <Kinnison> My main criticism is a lack of commentary makes it very hard to decide if it's right :-)
01:08:04 <Ghoul_> It's a state which can move forwards and backwards in time. It uses a programmer-supplied Keystone type which works like an event system and the programmer should define such that undo . redo = id
01:08:08 <Ghoul_> sorry, I should add documentation.
01:08:59 <lpaste> dmj pasted “War!” at http://lpaste.net/90950
01:09:03 <dmj> I wrote the game of War in 100-some lines of Haskell. I too would appreciate criticism.
01:10:00 <dmj> reader is for the cpu player names, writer for the stats the accumulate based on which player wins each hand, state for keeping track of the decks and reshuffling after each win/loss
01:11:36 <notdan> Ghoul_: so the first [e] in ChronoS is a list of previous actions/states?
01:11:50 <Ghoul_> notdan: it's a list of keystones
01:11:56 <Ghoul_> I found storing the states used too much memory
01:12:15 <Ghoul_> storing only keystones lets you store some 2 million past events in a little under 200mb ram
01:12:33 <Ghoul_> (doesn't matter when the state is an Int, but it does when the state is like a world or something)
01:12:33 <notdan> ok, sorry, I don't know what does keystone mean in this context
01:12:43 <Ghoul_> Uh, Keystone is a fancy word for Event
01:12:49 <notdan> Ah, alright :)
01:13:00 <Ghoul_> two example events are Inc (Increment) and Dec (Decrement) :)
01:16:28 <dmj> anybody? I don't account for cases where players can tie.
01:16:49 <dmj> first use of Monad transformers
01:17:27 * hackagebot units 1.0.0 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-1.0.0 (RichardEisenberg)
01:19:42 <notdan> dmj: looks alright
01:19:45 <notdan> nice use of split
01:20:00 <notdan> I dunno what to say I've never played War :)
01:20:48 <dmj> notdan: thanks! split fit like a glove
01:21:09 <dmj> notdan: Yea war isn't the best game :)
01:22:47 <notdan> Ghoul_: why do you need both 'put' and 'paradox'
01:23:05 <notdan> in one case you keep the history, in other you remove it, but I don't really understand why
01:24:28 <notdan> Ghoul_: so 'rewind' goes back in time and 'unwide' goes into the future, right?
01:25:02 <notdan> looks cool
01:32:00 <int_index> Hi. I'm trying to use Data.Map and I need to add `adjust' a value, but the function I want to use returns a monadic value. The type of `adjust' is
01:32:02 <int_index> adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
01:32:17 <int_index> whereas I need something like
01:32:32 <int_index> adjust :: Ord k => Monad t => (a -> t a) -> k -> Map k a -> t (Map k a)
01:32:46 <int_index> Any ideas?
01:34:27 <Ghoul_> notdan: yeah
01:34:31 <shachaf> int_index: There's a proposal on libraries@ for this function.
01:34:58 <shachaf> (My proposal, actually...)
01:35:15 <Ghoul_> uh, paradox is special. put erases the past since it becomes corrupted if the state changes directly
01:35:26 <int_index> Huh. Okay. I hope it gets implemented
01:35:36 <Ghoul_> paradox is basically a forceful put that destroys the integrity of the state ie: if you wind it forwards and backwards you may not get what you started with anymore
01:35:36 <shachaf> int_index: It'll probably be in the next version of containers, but until then, you'll have to build it out of what's exported by Data.Map.
01:35:44 <shachaf> int_index: Which you can. It just might be less efficient.
01:36:01 <shachaf> int_index: Control.Lens has this functions, for what that's worth.
01:36:11 <shachaf> You can borrow that implementation if you like.
01:36:21 <volitek_> What's wrong with hoogle? It's trying to get me to download a binary file, and nothing else loads... is it just me?
01:36:29 <MasseR> volitek_: See topic
01:36:37 <volitek_> oh, thanks
01:37:40 <int_index> shachaf, I considered using Lens but did not figured out how
01:37:59 <int_index> have not*
01:38:27 <shachaf> int_index: Well, lens has at :: (Functor f, Ord k) => k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)
01:39:40 <int_index> Wow. What is semantics of those `Maybe's?
01:40:02 <shachaf> Oh, right, you had adjust, not alter.
01:40:15 <shachaf> at k . traverse would give you your function.
01:40:24 <int_index> Thanks a lot!
01:40:27 <shachaf> And I guess you need Applicative, not Functor, for your function.
01:40:41 <shachaf> int_index: The Maybes are for nonexistent values.
01:41:00 <shachaf> I.e. you get a Nothing if the value doesn't exist, and you return a Nothing if you want to delete the value.
01:41:04 <DarkFox> I'm confused with Data.Binary, anyone here understand how a failure is meant to be declared? http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html
01:41:23 <shachaf> int_index: See also #haskell-lens :-)
01:41:50 <DarkFox> Or caused
01:43:44 <int_index> Why is haskell.org written in PHP when there are three nice Haskell-written web frameworks?
01:44:04 <merijn> int_index: Because haskell.org predates all of those frameworks by years and years?
01:44:21 <merijn> int_index: And no one feels like replacing something that works
01:44:45 <shachaf> There is no reason for haskell.org to be written in Haskell.
01:44:47 <merijn> int_index: However, if you feel like porting all infrastructure to haskell I'm sure that'd be appreciated ;)
01:45:30 <shachaf> merijn: Not really. If you write a wikimedia replacement and so on and make it better than the current system, then it can be replaced, but the language it's written in should hardly be a consideration.
01:45:51 <int_index> There's gitit
01:45:51 <DarkFox> O_o
01:45:54 <merijn> shachaf: Sure
01:46:06 <johnw> int_index: are you volunteering?
01:46:15 <shachaf> gitit is not a replacement for wikimedia.
01:46:29 <shachaf> mediawiki. Whatever.
01:46:55 <int_index> johnw, I am not qualified in web-development and I think it's a project too big for one person
01:47:19 <merijn> johnw: Since you're apparently set up already, I send my infra credentials to Ian, but apparently he was the wrong guy? Any clue who I should send them to?
01:47:21 <int_index> shachaf, gitit is a wiki engine, is it not?
01:47:29 <johnw> merijn: to me
01:51:54 <DarkFox> No one?
01:56:19 <zvrba> what is the recommended library for manipulating graphs? Data.Graph or fgl (Data.Graph.Inductive)
02:12:10 <prophile> @hoogle a -> b -> a
02:12:11 <lambdabot> Prelude const :: a -> b -> a
02:12:11 <lambdabot> Data.Function const :: a -> b -> a
02:12:11 <lambdabot> Prelude seq :: a -> b -> b
02:19:40 * hackagebot yesod-vend 0.3.0.0 - Simple CRUD classes for easy view creation for Yesod  http://hackage.haskell.org/package/yesod-vend-0.3.0.0 (KrzysztofSkrzetnicki)
02:19:48 --- topic: 'haskell.org in the middle of migration; expect turbulence | http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
02:19:48 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Mon Jul 15 11:29:39 2013]
02:19:48 --- names: list (clog yacks xpika multinormal bitonic petermw steshaw simukis_ denver nexx tsinnema NNNNN nominolo ThatOtherPerson cablehead dschoepe dcoutts_ srhb ClaudiusMaximus FreeFull no7hing phischu lunarjar dEPy waterlaz jbracker BoR0 copumpkin refold ulfdoz jibi merijn adinapoli DrTeggy rishabhjain erkin jchild marr Natch Sonderblade gdeest MindlessDrone tippenein inf-groupoid elediaz deavid t7 basvandijk ptek HugoDaniel Itkovian asQuirreL quchen djahandarie raichoo)
02:19:48 --- names: list (amosr zero7 ahf MrFenix_ allsystemsarego Kiryx YoungFrog hexagoxel chreekat ulrik Taneb sm scottschecter arthurvard TheFuzzball lichtsprung pamiz apples` kuribas AfC threesome Beetny Lethalman JaRoel Khisanth petapetapeta thalassarche strager path[l] Boney redneb D9 ramkrsna hrex mike4_ burp Mon_Ouie TheZimmer args[0] hsyl20 aess ceii cognominal fayden _emm_ Wizek LK4D4 dvyal kallisti kfish idntfy cads2 cads hkBst fosky gentleben diabel232 wollw tjohnson mbuf)
02:19:48 --- names: list (td123 kushal anon123 gereedy arkeet vobi MnO2 obcode pnielsen_ nilg ThomasLocke noam_ ecube pikhq sclv Michael_ ahihi ndonaldson danvet leroux csakatok_ wolfnn amathew fridim_ JohnBat26 u_ BigEndian Krakarn Kuraitou mecool otto_s_ N4sh_ coalton23 scrollback jesyspa adnap shanse Sixmsj joneshf-laptop c_wraith mgaare_ pseudolio satshabad mononofu natte demolithion rgrinberg callen parcs v4hn RichyB Urchin Urchin[emacs] Sgeo apaku zxq9 SoupE Nisstyre talzeus juhp)
02:19:48 --- names: list (mandarg` brainwash bobthenameless thorsten1 JKL1234- Rarrikins jaimef stepkut bitraten dolio jobstijl bel3atar hackagebot Guest31376 Cale predator117 Xunie DT` joe9 hattusili_III cdidd paddymahoney akraut dsantiago Beppe Peaker Guest84573 Vendethiel tufflax arkx Nik05 ctult M-ou-se_ troydm mavam pettter kcj insejn hallettj eacameron srcerer noddy jhance OlegYch aford EvilTownCat yogurt_truck robbert isomorphic geoffh so Luke Mortomes hiroakip Jonno_FTW)
02:19:48 --- names: list (joneshf-work owst jdoliner tavelram Fuuzetsu albel727 jssanders eyck fogus|gone Excureo vnz morolin kosmikus sclv_ leifw fridim__ upgrayeddd joar aninhumer ormaaj dreixel dan_johnsin Mowah pygospa hiratara PaiSho gbeshers killy9999 shergill dcoutts Kinnison n00dle jroesch [[zzzz]] ksf mornfall Maior vivekrai ISF DrCode sipa irene-knapp snoyberg kaictl Sebastien-L tudalex Deewiant mikecaruso tomprince sevvie Amadiro thorsten` Soft edkk acidi Irtopiste kazimir42)
02:19:48 --- names: list (Watabou DarkFox EarlGray^ isenmann gemelen conal augur_ MrWoohoo preflex mauke biscarch canissimia teiresias scshunt maoe shachaf Zamarok rfw ninegrid luzie Tril Tamae Pengoo Tesseraction destiny Twey misv stiell torkjak orzo rhodesd julmac Edoxile fijimunkii Morgawr popx kakos floatingman phetus doomlord_ ajhager flowsnake drbean machisuji Svedrin solancile ttuegel jdoles theorbtwo buetow drdo tamiko milli mceier jdhutah dextrey zeiris sg bcoppens setmeaway)
02:19:48 --- names: list (Kabaka mmaruseacph2 kludge` ParahSail1n macron tomejaguar stevejb Darkflux eL_Bart0 schoppenhauer zvrba lpsmith epta tomboy64 simon BMeph Spion_ helgikrs Guest21806 guymann xilo brianloveswords wchun jbauman bgamari jlaire OrangeDu1k knz Yaniel sanbonpe obiwanko Baughn ivan\ Vorpal kav RichiH Axman6 sirspazzolot capisce nomadmonad lahwran weie MasseR Ralith __main__ ezrios Bio ssbr sleepybug Draconx ktosiek Squid_Tamer zorzar ft sbahra[] hc copton kaol _br_)
02:19:48 --- names: list (vmeson wavewave Tarential qwandor @ChanServ PHO_ araujo ccasin lambdabot dogmaT dumbhat brandonw cdk supersym gpampara_off h_chiro_ LeaChim lattenwald ciaranm vvv ericmj ernst dustinswan ysuzuki linduxed blz37 brendan bezik mollerstrand neurocyte bscarlet noplamodo_ hive-mind earthy_ taylorgb jlouis fabjan Walther Ycros mlinksva levi vehk _flow_ msuszczy akiress AntiSpamMeta milessabin NeatBasis mviljamaa Shin-LaC mserrano mjrosenb epsylon jzelinskie)
02:19:48 --- names: list (Mayazcherquoi_ caligula_ chrra WhereIsMySpoon_ alexs_ Raynes mikeplus64 dilinger lokydor junsuijin aristid MK_FG xplat mrd crs_ mattp__ stass dsirenko_ anders^^ Blkt mgsloan saep bakingbread netj_ Brando753 Nimatek Licenser Moataz-E lulf Proteumus s00pcan ninzine jmcarthur pdxleif_away s_quark dmwit bobry Counter-Strike purefn tgeeky otterdam Xorlev wilfredh Raynos Dodek dabradley alexander__b redjohn FrHunter jang relrod neektza1 zw01 brixen Athas robinbb)
02:19:48 --- names: list (Will|- valdyn [edwtjo] statusfailed xnyhps Rembane def-lkb pyykkis machisuj- pfoetchen andrewsw dpwright dropdrive zq Astro-_ hpc FUZxxl KitB_ notdan ski benmachine tswett barrucadu mortberg trevize idoru mak` Valodim hape01 mephx sjl mendez cynick charley Shapeshifter Dashkal Zesler kxra prophile Starfire centrinia alshain sunfun gbarboza joelteon bogner_ ziman Spockz javawizard sunnavy_ aforemny_ finnrobi ehamberg Megant honza Enigmagic pi8029)
02:19:48 --- names: list (charlesofarrell xrq` petekaz` dsp_ jayne doshitan zoktar ParahSailin zz_nh2 stelleg Shou munro FireFly mietek shepheb kaw yam Watcher7|off bduc away_sondr3 clampz numberten TML Bigcheese ghorn nxorg8 BrianHV peddie Nickeeh lpaste sohum mixi bartavelle `0660 sajith Blazeix ve farn hpd Tribal genisage kloeri wereHamster gridapho1e nwf tessier_ carter Kuba_ jlamothe mrshoe klugez Adeon mstksg arbn stepcut Guest16699 mmathis FBI Nahra ion zacts dario^CIP)
02:19:48 --- names: list (Internet13 UziMonkey___ frontendloader adlan Boreeas joogi mirsal melter ortmage dqd shutdown_-h_now seneca Cerise nitrodex tylergillies ofan jxport gds ps-auxw cschneid lightquake ByronJohnson bbloom kshannon ChongLi ljhms_ hvr canvon hiyakashi solirc mkrull jrib Khady canar adimit wallmani jrslepak Rutger`_ hanDerPeder lispy cross vhz_ cods danr alcz jackhill Saizan Tene hyko Dtgr pyrtsa jliikka saiam mnbernstein elliott hamishmack chrisbuchholz mxf tomh-)
02:19:48 --- names: list (ccxCZ lopex ggherdov IbnFirnas warpy tensorpudding mami k0ral_ mechairoi thorkilnaur_ mrpantoufle birkenfeld solarus Liskni_si blakesmith confound Ke matzo_ Guest33530 csg__ fryguybob taruti Razz|at_1ork bholst nicoo Dybber mm_freak Ulrar divarvel fikusz averell_ dju ipuustin Jello_Raptor monochrom Derander threedaymonk volitek_ McManiaC jkpl liszt liori flori supki maksbotan_ newsham fergusnoble heath gspr idnar profmakx petanqk Riussi inr Belgarion0 opqdonut)
02:19:48 --- names: list (stomp DigitalKiwi fall_ Guest41554 SuperNoeMan ixian8 bxc electrogeek davean_ quicksilver SaBer_ rs0 tridactyla Kneiva_ dlundy Flint_ pellsson Vq Tinned_Tuna Chousuke_ Ezku_ TheSpectre KaneTW Jaak_ koninkje_away tromp__ ab9rf Sagi zebr Reisen b52 jml bben mlh Laney thetallguy _seantallen johnw \q janinge inarru sp3ctum tdammers Hafydd zerokarmaleft koala_man ethercro1 naz__ iteratee yan_ Clint Eridius qasi gdsx_ Guest98347 mike2 isomorphismes osfameron SHODAN)
02:19:48 --- names: list (wagle sdx23 smarter pharaun kryft latro`a_ vili ryanakca Bwild thoughtpolice pqmodn brett iulian Draggor ibid luite aszlig CosmicRay pr qz felipe_ vermeille magicman The_third_man bqp tvaalen_ bigs puzza007 cruxeternus prh` ninwa2 ggreg mokus xorox90_ Ornedan mapreduce ousado Th0mas zrot cronject transfinite Cryovat chrisdone justinls Ghoul_ mr- BlastHardcheese lpvb _janne integral sordina1 DrSyzygy horlicks_ Adios_ gbluma_ meretrix` othiym23 davorak_)
02:19:48 --- names: list (CindyLinz aleator_ mantovani tahu suiside b2coutts chirpsalot knyppeldynan udoprog drmegahertz agundry brainproxy yumike liyang zomg Plex- ent drewr `^_^v zenzike_ arnsholt Tehnix MetaCosm dixie_ saurik byorgey dyreshark schlumpi_ Elision_ HalfWayM1n pcapriotti bstrie wting johanbev elgot xymox phryk kqr lenstr Fuco peltchu wtw_ s4msung thetallguy1 cmsd2 cow-orker slobo zaphar_ps uu1101 tero- Gothmog_ int-e joshc kranius froztbyte wto_ Hardolaf myme1 deggis)
02:19:48 --- names: list (theDon canta jix_ Fubar^ ChewieBeardy rmunroe_ asante Maxdamantus tg b_jonas mikee petantik mimi_vx thirsteh em XMunkki yano hiredman tych0 davorb-cellphone asjo Eliel banjiewen marienz ido jyyou kryptiskt tomaw jaspervdj Gracenotes mux_ yiannis_t wunki plhk Yawgmoth Entroacceptor niko kaliyuga c_14 etrepum si14 Martty ivan` oldmanst1n bd__ tmiw betawaffle flux fry_ a11235_ mgregson geal SegFaultAX joeyh tunixman kini geekosaur alpounet swistak35 acfoltzer)
02:19:48 --- names: list (Ptival anachron majoh companion_cube vpm ocharles nlogax jlewis orospakr Jonte_ guerrilla cajla_ JPohlman1 duairc_ Sunhay ec_ ejls haasn raid luminous SirChurchill DustyDin1o akahn ehd jamwt gseitz dmp1ce nikola arcatan yeltzooo necroyeti Phlogistique strmpnk neena malorie_ cjay zaiste_ colah willb1 palmje)
02:29:12 <joergfritsch> What would be the most efficient way to create large number of eg session IDs?
02:30:10 <alpounet> joergfritsch, uh? could you elaborate a bit?
02:31:11 <joergfritsch> alpounet, if eg I have a multiplayer game and want to identify others via a session ID rather than an IP address only
02:31:50 <merijn> Make them login, use username as session id?
02:33:45 <quchen> Make them login, generate a number each time they do? You don't even need usernames
02:35:42 <petapetapeta> Hello. I am writing an interpreter in Haskell for a boolean search syntax. The special thing about this syntax is that an expression spans over several lines, and there is references to previous lines. So an example of a search is  'plane\nwing\n1 AND 2'. Which combines the boolean expressions on line 1 and 2.
02:35:48 <joergfritsch> Yes, but somewhere I read that numbers (Integers) and text-based IDs represent a terrible overhead in byets when they need to be sent to the far end.
02:36:03 <joergfritsch> Thus I was looking for something small and unique.
02:36:17 <alpounet> joergfritsch, how many "clients" should you be able to handle?
02:36:35 <petapetapeta> The final boolean expression is contained on the last line. Is it correct that to do this I need to use a state monad in the interpreter?
02:36:48 <mauke> petapetapeta: no
02:36:59 <joergfritsch> Well, I plan to implement a finite state machine that can handle at least "some". Lets say ... between 8 - 254 ?
02:37:24 <Kinnison> joergfritsch: Have a counter, issue session zero first, then session one, etc.
02:39:16 <joergfritsch> How does eg a web server generate session IDs?
02:39:35 <merijn> joergfritsch: They don't, HTTP is stateless, so there are no session IDs
02:39:41 <petapetapeta> mauke: What should I use then?
02:39:56 <mauke> petapetapeta: ?
02:39:59 <mauke> whatever you want
02:40:26 <mauke> I'm not even sure what you mean by "a state monad"
02:40:36 <mauke> but it's never technically necessary to use State
02:40:59 <ChongLi> yeah, it's just sugar for plumbing parameters around
02:40:59 <merijn> petapetapeta: You *could* use the State monad in the interpreter, but it's certainly not necessary and whether it's beneficial for your simple use case, maybe?
02:41:15 <Tinned_Tuna> joergfritsch: web *applications* (typically a framework or library used by the application) will generate the Session ID, the web server should be (mostly) oblivious to the contents of the request.
02:41:29 <petapetapeta> mauke: By a state monad, I mean a monad which contains the state of the environment.
02:41:34 <mauke> petapetapeta: what state?
02:41:37 <joergfritsch> understand.
02:42:36 <petapetapeta> mauke: The previously interpreted lines. So what I'm doing is that I'm interpreting one line at a time and when I encounter a backreference-token I need to get the interpreted line it refers to
02:42:54 <joergfritsch> mauke: How would you evaluate a scrip / DSL that is read line by line and not functional (ie imperative) without keeping some form of state from one line to the other?
02:43:03 <mauke> petapetapeta: but does that state change?
02:43:29 <merijn> joergfritsch: Why would you not write it imperatively if that's easy?
02:43:38 <mauke> joergfritsch: does writing to temp files count?
02:44:37 <joergfritsch> mauke: bec in Haskell I have great types and the state problem does IMHO not change if the DSL would be embedded in an omperative language, does it?
02:45:17 <joergfritsch> is there anyyhing slower than temp files?
02:45:28 <mauke> joergfritsch: are you confusing/mistabbing me with merijn?
02:45:36 <joergfritsch> mauke: yes
02:45:37 <mauke> joergfritsch: yeah, network access
02:45:42 <Tinned_Tuna> joergfritsch: you want state-free sessions?
02:45:58 <Tinned_Tuna> well, state-free session cookies?
02:46:04 <joergfritsch> Tinned_Tuna: for the session IDs: yes
02:46:34 <joergfritsch> Tinned_Tuna: yes, thought about doing something similar to SYN coockies.
02:46:40 <merijn> joergfritsch: Oh, I wasn't saying you shouldn't use haskell, I was just saying, that many people seem to think they should (without thinking about it) never use imperative style in haskell
02:46:41 <joergfritsch> may look into this again.
02:47:16 <merijn> joergfritsch: tbh, for the session id's I'd just stuff a counter in an IORef/TVar and use that to generate id's
02:47:19 <simukis_> merijn: can you even use imperative style?
02:47:25 <merijn> simukis_: Yes, easily
02:47:36 <petapetapeta> mauke: That is actually a good point
02:48:01 <merijn> simukis_: Lots of State and/or IO and just use do-notation, it's actually rather pleasant :)
02:48:16 <Tinned_Tuna> You may be able to do something as is outlined here: http://www.lightbluetouchpaper.org/2008/05/16/hardened-stateless-session-cookies/
02:48:22 <joergfritsch> merijn: I have the given that I started a DSL in Haskell and it works somewhat. To make it turing complete there may be some state required. Also eg to express a sequential computation.
02:48:24 <Tinned_Tuna> But I haven't read the paper in depth.
02:48:34 <simukis_> merijn: well… the `do` is not really imperative but I don't really want to fight over it.
02:48:39 <petapetapeta> mauke: I guess that since it contains the previously interpreted lines it would change each time a line has been interpreted
02:48:53 <merijn> simukis_: How is do for IO not imperative? What does imperative mean to you?
02:48:54 <Tinned_Tuna> simukis_: it's not *technically* imperative, but the style of writing is quite imperative.
02:49:16 <Tinned_Tuna> there's a distinction between the style of the code, and what's actually going on.
02:49:29 <petapetapeta> merijn: I just thought that I should use the state monad, as I need to keep track of the previously interpreted lines in the boolean expression.
02:49:31 <joergfritsch> Tinned_Tuna: good idea this cookie thing
02:49:49 <merijn> petapetapeta: You could just recursively call a function and pass the state like that
02:50:42 <merijn> petapetapeta: "parseLine :: Bool -> IO Bool; parseLine state = do { val <- getLine; let newState = doSomething val state; parseLine newState }"
02:51:04 <merijn> petapetapeta: Obviously that needs some short-circuiting to end the infinite recursion as some point
02:51:07 <Tinned_Tuna> joergfritsch: However, you are *much* better off by just generating a random session id from a PRNG, and using that.
02:51:58 <merijn> Tinned_Tuna: I actually disagree with the remark that IO code is not "technically imperative", it's is kinda the definition of technically imperative...
02:52:25 <Tinned_Tuna> yes, you'll need somewhere to store it, and some way of reading that cookie back.
02:52:39 <prophile> do notation is purely functional, as are IO objects
02:52:53 <prophile> the only imperative bit is how they're interpreted from the declaration of main, surely?
02:53:05 <joergfritsch> Tinned_Tuna: random session IDs; they are either very big in bytes or they are prone to conflict. If I first need to check for conflicts before it is issued then ... also not so nice.
02:53:19 <merijn> prophile: Like I said, it depends what you mean by imperative
02:53:22 <petapetapeta> merijn: Awesome. Thanks :) I will try looking in that direction
02:53:33 <Tinned_Tuna> the scheme is much simpler, and if your PRNG is chosen and setup correctly, and you've chosen session cookies of a sufficient length, you're very unlikely to suffer an attack through simply guessing cookies.
02:53:58 <merijn> petapetapeta: Coincidentally, that's really just a minimalist reimplementation of State, or State is a more elaborate implementation of that, depending how you look at it
02:53:59 <prophile> merijn: it strikes me as a bit of a common misconception that IO and/or do are a sneaky get-out-of-jail-free for making haskell imperative
02:54:08 <Tinned_Tuna> joergfritsch: if you have cookies of length (for example) 128-bits, your chance of a collision is something on the order of 2^(-64), which is a vanishingly small number
02:54:18 <merijn> prophile: IO is a DSL for describing imperative computations
02:54:39 <petapetapeta> merijn: That's what I thought when I first looked at it. Is there a way to achieve this without maintaining a state?
02:54:43 <joergfritsch> Tinned_Tuna: good point
02:55:04 <merijn> prophile: They're not a sneaky get out of jail cards, haskell provides a superset of the functionality of other languages
02:55:08 <prophile> merijn: but it's written declaritively, as with the rest of haskell
02:55:12 <Tinned_Tuna> merijn: I was more getting at the general imperative-in-haskell thing, in that I see it as functional code, but the expression in do-notation is much more imperative -- it's all about how you define imperative.
02:55:15 <prophile> *declaratively
02:55:19 <merijn> prophile: So?
02:55:33 <prophile> so I would view declarative and imperative as mutually exclusive
02:55:39 <merijn> I don't
02:55:58 <merijn> Or rather, I'm viewing them at separate levels here
02:56:09 <merijn> You're using declarative style to describe an imperative program
02:56:34 <Tinned_Tuna> joergfritsch: you could, technically, stick everything in a cookie, use an encrypt-then-mac construction and run with that.
02:56:39 <merijn> i.e. you're writing meta-code, declarative code that creates an imperative program
02:56:48 <merijn> That doesn't make the resulting program any less imperative
02:57:08 <prophile> does it make the code (or meta-code) imperative though, regardless of the program produced from it?
02:57:13 <merijn> That'd be like saying C is not imperative if your C compiler is written in haskell, because the compiler is declarative
02:57:31 <Tinned_Tuna> i.e. have cookie data d = "property=value;property2=value2;...;", and send E_k1(d)||MAC_k2(d) to the client.
02:57:42 <Eduard_Munteanu> Anyone happen to know if rotated text (Pango layouts) in Cairo are properly hinted/antialiased subpixel-wise?
02:57:51 <merijn> prophile: My definition of "imperative" is "describing a sequence of state mutations", which is exactly what IO describes
02:57:53 <Tinned_Tuna> then you check the mac, if it passes, decrypt the rest of it and de-serialise the internal datastructure.
02:57:56 <petapetapeta> go
02:57:57 <joergfritsch> Tinned_Tuna: Thanks, I will explore the coockie thing a bit.
02:58:08 <petapetapeta> typo - sorry
02:58:14 <Eduard_Munteanu> Rotation is applied by Cairo.
02:58:16 <merijn> petapetapeta: No, you can't achieve state without maintaining state :)
02:58:26 * prophile thinks about this some more
02:58:58 <petapetapeta> merijn: When you say it like that it seems obvious. But it is neccessary to maintain a state in some way in this use case right?
02:59:28 <merijn> petapetapeta: Yes, but that doesn't necessarily require you do it using State (as mauke was pointing out) just plain recursion with argument passing works too
03:00:30 <petapetapeta> merijn: But what would be the benefit of not using State. Is it because it's an easier implementation?
03:01:04 <merijn> prophile: An imperative program is understood in terms of fundamental operations that occur in some order (concurrently if you're thinking multithreaded), where the ordering/interleaving matters. IO is a DSL for describing exactly these kinds of programs, including the concurrency/interleaving if you include forkIO
03:01:48 <merijn> petapetapeta: Well, the simpler assures you that the State isn't secretly being used elsewhere (i.e. this is the only thing that's happening), other than that, there's not a lot of difference
03:01:58 <merijn> petapetapeta: I recommend going with whatever feels right/easiest/etc
03:02:28 <Banistertab> Hi, im having trouble unpacking this let expression can someone help me? What is itsaying exactly? applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)
03:03:10 <zvrba> which graph library to use?
03:03:21 <petapetapeta> merijn: Okay. Thanks a lot for helping. I was asking because I didn't want to make an incorrect choice. But it seem like I'm on the right track if I just keep some sort of state
03:03:55 <merijn> Banistertab: which part of it confuses you?
03:05:07 <prophile> merijn: okay, i concede the point
03:06:09 <merijn> > let (x, y) = (1, 2) in x + y -- Banistertab does this make sense to you?
03:06:11 <lambdabot>   3
03:07:41 <Banistertab> Merjin ah thanks
03:14:42 <prophile> is there a type composition operator?
03:15:12 <merijn> Data.Functor.Compose
03:15:34 <merijn> Which is not quite the same, sadly, as it require newtype wrapping/unwrapping
03:16:10 <prophile> it's better than a slap in the face with a wet fish
03:18:01 <prophile> it seems to me a non-leafy binary tree is Cofree (Pair . Maybe) (Pair a = (a,a))
03:22:41 <robde> how can I hide things from Main?
03:22:51 <mauke> for example?
03:22:56 <robde> like Main.head
03:23:04 <mauke> import Prelude hiding (head)
03:23:10 <mauke> or what do you mean?
03:23:14 <robde> oh, right
03:23:22 <robde> thanks, I confused that
03:25:07 <robde> mauke: but it still doesn’t seem to work: It could refer to either `Main.head', defined at
03:25:20 <mauke> what's the complete error message?
03:25:44 <robde> Ambiguous occurrence `head' ... or `Data.List.head', imported from `Data.List' (and originally defined in `GHC.List')
03:25:55 <mauke> what's the complete error message?
03:26:49 <robde> Ambiguous occurrence `head': It could refer to either `Main.head', defined at .Test.hs:14:1 or `Data.List.head', imported from `Data.List' (and originally defined in `GHC.List')
03:27:04 <mauke> does Test.hs contain 'import Data.List'?
03:27:36 <robde> no, maybe it’s still in ghci?
03:27:47 <mauke> weird
03:27:53 <mauke> post your code?
03:27:56 <mauke> @where hpaste
03:27:56 <lambdabot> http://lpaste.net/new/haskell
03:28:15 <hrex> Couldn't match expected type `[Action t0]'                 with actual type `IO [Action a0]'
03:28:25 <hrex> https://gist.github.com/anonymous/07c95d989e1d0a5ca984
03:28:53 <lpaste> m pasted “no title” at http://lpaste.net/5068797184422445056
03:29:02 <robde> mauke: http://lpaste.net/5068797184422445056
03:29:37 <mauke> hrex: run (action : instructions) = do x <- exec action; run (x ++ instructions)
03:30:21 <merijn> heath: Why do you have "data Action a" if you don't use the a type anywhere?
03:30:21 <hrex> mauke: thanks
03:30:26 <merijn> s/heath/hrex
03:30:27 <mauke> robde: works here
03:30:34 <robde> odd
03:31:07 <hrex> heath: ops
03:37:42 <ocharles> merijn: phantom type?
03:43:54 <merijn> ocharles: Seems unlikely for a "hello world" program and someone not really understanding IO yet :)
03:47:02 <Daat418> Hi all. I'm a programmer-aspirant and I'm trying to find an appopriate first language. I was considering Haskell but I'm unsure whether or not im barking up the wrong tree. I -love- programming but, realistically, I cannot make this time investment (at this stage in my life) to slowly pursue a fun and rewarding hobby.
03:47:18 <Daat418> I'm trying to graduate from support engineer to software engineer
03:47:59 <ocharles> merijn: I didn't read the scroll back, but you're probably right :)
03:48:07 <Daat418> the most development-related stuff i know is building procs in TSQL, emacs customization (somewhat) in emacs-lisp and bash scripting
03:48:20 <Daat418> That's pretty much the extent of it
03:48:38 <Daat418> I am fully aware of the differences between functional and imperative languages
03:48:44 <isomorphic> Daat418:  Found LYAH?
03:48:47 <isomorphic> @lyah
03:48:47 <lambdabot> Unknown command, try @list
03:48:59 <Daat418> isomorphi: Yes.
03:49:05 <merijn> Daat418: Realistically, I expect it'll take longer to become employable as haskell programmer rather than a mainstream language like Java/C#, on the other hand, I think your salary, skill and opportunity caps will be rather higher from learning haskell
03:50:17 <zvrba> merijn: any opinion on Data.Graph vs Data.Graph.Inductive [ease of use, documentation]
03:50:29 <merijn> zvrba: Absolutely zero
03:50:33 <isomorphic> Daat418:  I won't advocate a particular language.   But i'll confess I'm constantly impressed both by this language, and this community.
03:50:39 <zvrba> ok
03:51:40 <Daat418> merijn: First of all, I have no interest in either Java or C# (or any .net framework language). Second, regarding your last point, are you referring to the fact that knowing Haskell is "impressive" or that Haskell will inform your experience with imperative languages and knowledgeable employers are aware of this?
03:52:41 <merijn> Daat418: Both of those, plus the fact that haskell lets you do more complicated things more easily and the community is also where lots of interesting programming language research happens, meaning there's more learning and growth potential than other languages and communities
03:54:07 <Daat418> isomorphi: I am too. I've had enough exposure to all of the above to have garnered a genuine - if superficial - interest in Haskell. I'm familiar with Xmonad and Pandoc and I've read analyses of their source code. I was in complete awe...
03:54:47 <merijn> Daat418: In that case I think you're already doomed to learn haskell :)
03:55:03 <Daat418> merijn: ha!
03:55:24 <isomorphic> Daat418:  Type inference was the first thing that hit me.   Very quickly, you realise that if ghc is happy, that's a lot more assurance than most code.
03:56:15 <isomorphic> Daat418:  The next thing - each time you learn an abstraction - it initially feels alien.  Then something clicks which makes it feel natural.  Sort of like the "weird" keymappings in Vim.
03:56:33 <Daat418> isomorphi: I've had some exposure to this ^ I've been led to believe that if ghc isn't unhappy with the input it receives, your changelog will never include bugs
03:56:39 <MasseR> Daat418: Analysis of pandoc source? Where?
03:56:52 <isomorphic> Daat418:  No, you'll still get bugs.  But different ones.
03:56:57 <benmachine> Daat418: that's a bit of an overstatement, I write buggy haskell code all the time
03:57:04 <tdammers> Daat418: you can still write code that typechecks and compiles but has bugs
03:57:10 <benmachine> what you get a lot less of is boring bugs :) typos and stuff
03:57:24 <jzelinskie> Daat418: I don't suggest condeming other langauges like Java/C#. They are valuable tools with trade-offs just like Haskell. Being able to identify the best language to solve a problem is a part of being a good programmer.
03:57:26 <tdammers> oh, and let's not forget the ultimate refactorability
03:57:30 <mr-> Daat418: refactoring haskell code is a pure pleasure
03:57:42 <tdammers> changing a method name? just change it and let the compiler spit out a to-do list
03:57:44 <isomorphic> Daat418:  Python is a good language I think - it's worth a look
03:57:46 <Entroacceptor> and if you just want a job, PHP is enough
03:57:48 <benmachine> Daat418: I suggest condemning other languages where appropriate
03:58:09 <Daat418> isomorphic: that's a good comparison... when i realized that vi/vim commands can - essentially - form a language, i felt absolutely in tune with it and never baulked again.
03:58:13 <benmachine> especially if you're a hobbyist, condemn all you like, can't hurt
03:58:14 <tdammers> Entroacceptor: if you just want a job, *prostitution* will do
03:58:28 <Eduard_Munteanu> Why do I get no effect from contextSetMatrix when rendering text with Pango (and Cairo)?
03:58:37 <Entroacceptor> tdammers: probably not for me
03:58:46 <tdammers> Entroacceptor: fair enough :x
03:59:00 <Eduard_Munteanu> I do layoutContextChange.
03:59:10 <isomorphic> Daat418:  That's essentially the tradeoff you make with the mathy abstractions here - Monads, etc - like learning new words.
03:59:32 <merijn> benmachine: I'm a professional, I condemn languages with extreme prejudice :p
03:59:38 <Daat418> jzelinskie: thanks. my intention is purely to get started -right- and I think haskell presents an edge to those that aren't afraid/bewildered by it. I understand that different languages can be more effective/efficient/faster at different things
03:59:42 <benmachine> merijn: :)
04:00:08 <Daat418> benmachine: ha! on that note - screw java -_-
04:00:12 <benmachine> :D
04:00:20 <xplat> you get less typos and trivial misuses and no uncaught stack overflows, double frees, etc if your code typechecks at all.  if you use good types, you'll also get fewer semantic security bugs along the lines of code injection etc.  if you use good abstractions you won't get simple logic bugs like off-by-one etc
04:00:21 <benmachine> that's the spirit
04:00:47 <Daat418> MasseR: one moment
04:01:03 <Daat418> on my pinboard somewhere
04:01:16 <isomorphic> Daat418:  Recommendation I'd give is to try to write trivial examples rather than read tutorials
04:01:17 <hrex> QUIT
04:01:37 <xplat> the power of haskell, iow, is not just what it makes you do--it's also what it lets you do, and what it *lets you make yourself do*
04:02:08 <isomorphic> Daat418:  On that note, I like Python and haskell because you can have a REPL
04:02:18 <Daat418> MasseR: Part 1 of 2: http://www.youtube.com/watch?v=FEFETKhhq8w
04:02:24 <mr-> xplat: can you recommend a way to learn making "good types"?
04:02:45 <tdammers> isomorphic: most languages these days have a repl... well, C, C++, Java and C# don't...
04:03:00 <Daat418> isomorphic: python was my other choice. careful consideration and research have helped me concentrate my decisons down to a boolean :D
04:03:09 <isomorphic> tdammers:  Can't tel if you're being ironic
04:03:20 <tdammers> isomorphic: partially
04:03:37 <tdammers> isomorphic: having a repl seems to be standard procedure for new programming languages though
04:03:40 <MasseR> Daat418: Thanks. I know what I'll be doing this evening
04:03:48 <xplat> tdammers: C has a repl, it's just not standard.  java has a repl for the environment, but not the language
04:03:50 <tdammers> Daat418: why not both?
04:04:04 <tdammers> xplat: a C repl? nice.
04:04:08 <tdammers> where?
04:04:24 <xplat> mr-: i don't know any good comprehensive tutorials for that, although a lot of the basic language tutorials start to touch on it
04:04:30 <jzelinskie> I believe there's even a C++ REPL popular at SERN
04:04:32 <merijn> tdammers: I remember seeing one, afaik Intel is working on one for gdb too
04:04:37 <Daat418> tdammers: learn both at once, each representing a -completely- different way of managing objects and states?
04:04:40 <jzelinskie> CERN*
04:04:58 <Daat418> tdammers: are you a cruel person?
04:05:05 <MasseR> Daat418: Yeah, in my opinion, focus on one first and then see the other
04:05:07 <tdammers> Daat418: maybe not at once... but then, why not. They are sufficiently different I'd say
04:05:19 <tdammers> but yeah, one at a time is probably better
04:05:38 <jzelinskie> tdammers: http://root.cern.ch/drupal/content/cling
04:05:39 <tdammers> but then, the first language you pick up isn't particularly likely to be the most important one
04:05:43 <xplat> tdammers: http://stackoverflow.com/questions/10766900/is-there-a-repl-for-c-programming
04:06:09 <tdammers> jzelinskie: awesome
04:06:34 <jzelinskie> I haven't used it myself
04:06:45 <tdammers> I reckon it's not without caveats
04:06:54 <Daat418> tdammers: How about... Lisp?
04:07:03 <Daat418> tdammers: just throwing it out there
04:07:07 <jzelinskie> tdammers: check out the resources sections for those
04:07:27 <xplat> tdammers: few things in C, and nothing in C++, are without caveats, of course
04:07:36 <PatrickRobotham> Hi everyone, I'm going through Real World Haskell Chapter 5, I get an error message
04:07:38 <PatrickRobotham> "Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
04:07:38 <Daat418> MasseR: pretty neat video series, huh?
04:07:39 <PatrickRobotham> ./configure script then use 'build-type: Simple'." when I try to compile the package
04:07:50 <tdammers> xplat: true, very true (or should I say, 1, very 1)
04:08:01 <MasseR> Daat418: Hopefully
04:08:43 <benmachine> PatrickRobotham: sounds like just a warning, why should you care :P
04:08:44 <tdammers> Daat418: sure, why not. Haskell is closer to the functional programming spirit though, being all-pure and all that
04:09:00 <tdammers> Daat418: also, scheme probably makes for a nicer learning experience than Common Lisp
04:10:05 <benmachine> PatrickRobotham: I'm not sure why it doesn't already include that line, it should
04:10:39 <Daat418> isomorphic: regarding tutorials - I'm lucky in that I don't need to be battered over the head to realize they are not very helpful as an A-Z learning tool. I'm ADHD and learned the -right- way to learn by simple natural circumstance :P (i.e., I try to make something do something once I have a foundation firm enough to support basic comprehension, then I 'ask questions' and answer them with research)
04:10:49 <xplat> tdammers: these days i'd say racket rather than scheme
04:11:18 <MasseR> xplat: My preference is chicken
04:11:27 <tdammers> racket is kind of a superset of scheme anyway, isn't it?
04:11:44 <xplat> tdammers: it combines a lot of the historical advantages of scheme with a lot of those of common lisp.  the big one it's missing over common lisp is standardization
04:12:01 <tdammers> (disclaimer: I haven't done any serious scheme / lisp yet, just played around with a few lisps)
04:12:14 <MasseR> tdammers: racket is an implementation of scheme. There is no 'language' called scheme
04:12:26 <xplat> but it has a comprehensive set of libraries, active community, etc
04:12:32 <Daat418> tdammers: probably but learning common lisp would have the added benefit of allowing me to become even more intimate with emacs than I already am.
04:12:39 <tdammers> MasseR: then what's the language called?
04:12:53 <tdammers> just Lisp?
04:12:58 <MasseR> tdammers: My terminology is a bit off here, but you won't find an interpreter called scheme, nor a compile called scheme etc
04:13:14 <MasseR> Daat418: Common lisp =! elisp unfortunately
04:13:19 <tdammers> MasseR: of course. I don't think you'll find a compiler called "C++" either
04:13:38 <MasseR> tdammers: No, but these implementations all have their own gotchas
04:13:39 <Daat418> MasseR: I didn't think it was =, I thought it was ~
04:13:47 <MasseR> As in there is a lot more freedom in the implementation
04:13:52 <xplat> scheme is a standard and you have to pick an implementation.  but the standard doesn't cover very much so it matters a lot which implementation you pick
04:13:53 <tdammers> MasseR: of course they do. So do C++ implementations.
04:14:45 <tdammers> but yes, of course the standardized "language" part is much smaller than with other languages because so much can be (and is) offloaded to libraries
04:14:52 <xplat> more so than C, more so than C++, more so than even python
04:14:55 <MasseR> tdammers: Sorry, I'm a broken telephone in this. I asked #scheme once and they lectured me for quite a long time how scheme is not an implementation and how much further the distance between ie. racket and scheme is than c and gcc
04:15:22 <tdammers> well, I do agree that Scheme is not an implementation
04:15:59 <MasseR> Probably something like haskell and ghc, but where 'haskell' is almost synonymous to ghc, 'scheme' doesn't have anything like that
04:16:02 <tdammers> Racket, I would say, would be both the implementation and the language(s) it implements
04:16:32 <Daat418> now, regarding python... -the- learning resource for haskell beginners appears to be unanimously agreed upon - LYAH. Python has a much wider selection of texts, books, guides and so on. I am trying out Zed Shaw's "Learn Python the Hard Way" - any testimonials?
04:16:44 <tdammers> MasseR: so you mean there is no reference implementation, is that what you're saying?
04:16:50 <Daat418> So far, I like his approach
04:16:59 <MasseR> tdammers: Something like that yeah probably
04:17:10 <tdammers> Daat418: for Python, I just took the "official" intro guide and the reference and got cracking
04:17:46 <tdammers> Daat418: Python is *really* easy. With a bit of experience in other object-oriented and structured languages, you'll be up and running in two weeks or so
04:17:56 <mm_freak> python is really difficult to learn when you come from haskell…
04:18:00 <benmachine> tdammers: I think we're talking about a first language here
04:18:09 <tdammers> benmachine: hmm, yes, true
04:18:22 <tdammers> might want to learn a bunch of programming concepts as well while you're at it
04:18:29 <Maior> the first language I was ever properly "taught" was Standard ML
04:18:44 * tdammers does not have any formal education in programming
04:19:17 <mm_freak> the best way to learn python as a first language is not to do it
04:19:34 <Daat418> tdammers: so an education in functional programming WILL inform your experience with imperative languages and make learning them effortless?
04:20:10 <tdammers> Daat418: I don't know what an education in any kind of programming does. I've never had one.
04:20:35 <tdammers> Daat418: In the end, you'll want to become comfortable in several paradigms
04:20:36 <Daat418> tdammers: not a formal education - that's not what i meant.
04:21:03 <tdammers> ah... you mean will learning functional programming make it easier to pick up imperative?
04:21:04 <jzelinskie> which is why i said you shouldn't condem languages :)
04:21:15 <benmachine> Daat418: any education in any programming will make all other programming easier
04:21:15 <Tinned_Tuna> Daat418: not quite like that, but it'll illuminate the way you see them -- in much the same way that going and learning lots of things will illuminate your views :-)
04:21:17 <tdammers> I don't know, I started out with Pascal and C
04:21:27 <Tinned_Tuna> tl;dr, learn ALL the things.
04:21:35 <Daat418> tdammers: Essentially, I'm looking for a skeleton-key language.
04:21:37 <benmachine> Daat418: but I have no idea what the optimal path is, as it were
04:21:44 <benmachine> Daat418: that's a hard question! I suspect there is none
04:22:03 <benmachine> Daat418: I suspect there's sort of a list of things you have to learn and by and large it doesn't matter too much when you learn them
04:22:07 <Tinned_Tuna> I always recommend SICP (using Scheme) as a first course.
04:22:19 <Tinned_Tuna> because it's the one book that made a lot of things "click" for me.
04:22:29 <tdammers> Daat418: I don't think there is such a thing
04:22:56 <jzelinskie> if there was it would probably be c++
04:22:59 <Daat418> Tinned_Tuna: thanks! I've learned that some folks believe functional languages can inform and improve your ability with imperative languages. confusingly, others say that learning a functional language first makes imperative languages
04:23:02 <jzelinskie> just because it's so massive
04:23:04 <Daat418> "painful to deal with"
04:23:20 <mm_freak> Daat418: yes, that's right
04:23:27 <Tinned_Tuna> Daat418: it's not painful, you're just more aware of how things might be expressed in other languages.
04:23:33 <xplat> jzelinskie: oz/mozart is a better multiparadigm than C++, except of course the part where nobody uses it
04:23:56 <jzelinskie> i don't doubt that
04:24:06 <tdammers> Daat418: you'll want to learn a selection of languages that cover most of the programming paradigm landscape: statically-typed vs. dynamically-typed, functional, object-oriented (both the class-based and dynamic styles), structured...
04:24:24 <xplat> Daat418: those aren't contradictory.  you can be better at using imperative languages and still hate them more
04:24:41 <tdammers> xplat: you mean like I am pretty good at PHP?
04:25:14 <Daat418> interesting
04:25:18 <xplat> tdammers: :)
04:26:00 <tdammers> oh, and might want to include at least one language that doesn't do automatic memory management
04:26:10 <tdammers> (i.e., C or C++)
04:26:31 <Daat418> okay - a completely unrelated question! I was going through some of my older docs today - just for fun - and I happened upon this very interesting sentiment regarding Lisp: "LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot."
04:26:58 <notdan> Sounds like a quote from Larry Wall or some other UNIX nerd
04:27:03 <notdan> 're: LISP
04:27:05 <Tinned_Tuna> ooo, if you really want to bake your noodle, learn Prolog. took me a couple of goes to "get" prolog properly.
04:27:05 <Entroacceptor> I think ESR?
04:27:18 <notdan> yeah ESR
04:27:18 <Daat418> Entroacceptor: bingo!
04:27:37 <Entroacceptor> Daat418: and he was here a few years ago and wrote the same about haskell, IIRC
04:27:40 <Entroacceptor> let me find that again
04:27:44 <xplat> Daat418: the LISP 'experience' can happen with haskell too IMO
04:27:48 <Daat418> Entroacceptor: errr
04:27:58 <Daat418> Entroacceptor: Fascinating :D
04:28:03 <Entroacceptor> http://esr.ibiblio.org/?p=1796
04:28:15 <Daat418> xplat: what is this elusive 'experience', though?
04:28:24 <tdammers> indeed. Haskell made me really grok higher-order functions
04:28:59 <tdammers> Daat418: Lisp (and Haskell too) challenges you to think in certain ways, and those ways turn out to be very powerful mental models for code
04:29:32 <tdammers> Daat418: more powerful than the typical imperative mindset where you are basically manipulating buckets of bytes by applying commands to them in sequence
04:30:37 <jzelinskie> I think the homoiconography aspect of lisp is also important
04:30:55 <xplat> it's basically the difference between 'programming as writing recipes' and 'programming as deriving formulas'
04:31:37 <Daat418> xplat: tdammers: thank you. these are -excellent- explanations. i -get- it far more than i did 5 minutes ago.
04:31:41 <Daat418> thank you :)
04:31:46 <xplat> jzelinskie: a little, but not as much as HOFs.  also haskell has some similar things that lisp doesn't have thanks to laziness, like 'list as suspended loop'
04:31:52 <Daat418> I -need- to read this ESR article :p brb!
04:31:58 <kryft> tdammers: It also seems to translate into better code in languages that don't really support the more powerful models
04:32:27 <tdammers> kryft: they do support most of those models, they're just not as obvious
04:32:58 <tdammers> e.g., in PHP, purity is implicit, but you can still apply the concept to make for more maintainable code
04:33:01 <kryft> tdammers: Sure, I guess I meant 'explicitly support'
04:33:05 <tdammers> mkay
04:33:11 <xplat> i'd say they allow them, but don't support them.  much like assembly language and procedures.
04:34:02 <xplat> (well, assembly languages sometimes 'support' procedures to some extent, but there are other similar examples that aged better)
04:35:33 <kryft> tdammers: Although in some cases explicit support is pretty important; for example, in matlab defining new functions is painful enough that some things that are in principle possible are not a good idea
04:35:52 <xplat> basically they make you do all the work yourself, and let you mess it up more easily, which is why you write better imperative code but you hate it
04:36:01 <kryft> xplat: Hehe, yes
04:37:17 <kryft> xplat: I'm still very much a haskell newbie (haven't written anything real yet, but have more or less grasped LYAH and most of RWH), but I noticed that the benefit of having types is starting to become quite obvious when writing something like matlab :P
04:37:35 <kryft> And it changes the way I write code there even if I can't actually have a type system
04:38:18 <kryft> s/having types/having a good type system
04:38:24 <kryft> And type inference
04:42:55 <Daat418> "There are reasons to make the effort.  Haskellers (Haskellites? Haskellians? Haskellators? Haskelletons?) maintain that imperative programming relies heavily on side effects that push proving the correctness of programs to somewhere between impractically difficult and impossible.  They also like to point out that side effects make programs difficult to automatically parallelize across multiple processors, an increasingly important
04:42:55 <Daat418> consideration as multicores become the rule rather than the exception.
04:43:08 <Daat418> interesting!
04:43:20 <Daat418> I had no idea -that- level of abstraction was going on.
04:44:58 <MasseR> Daat418: There is a bit of a caveat with automatic parallelism
04:45:09 <MasseR> It turns out that laziness is bad for parallelization
04:46:14 <Daat418> Oh, by the way! I -don't- really understand why Xmonad is considered to be top-tier. I do -appreciate- how tightly and cleanly and concisely it is written but beyond that, what makes it so special?
04:46:56 <Daat418> MasseR: Ha!
04:47:04 <mauke> Daat418: it has users
04:47:30 <Daat418> mauke: ...please tell me there's more to it than that...
04:47:31 <kryft> That reminds me, I should probably try to read XMonad's source
04:47:56 <kryft> Is it hard to grasp if you don't know a lot about X?
04:48:05 <Daat418> mauke: I was thoroughly irritated that StumpWM turned out to be all but completely abandoned...
04:48:21 <MasseR> Daat418: What's your definition of top-tier? I can see why I like it, but it is a bit more difficult to explain why it deserves some special status
04:48:22 <simukis_> Daat418: It never crashes. It is light. It is configurable as much as you would ask for.
04:48:43 <Daat418> kryft: I can read it. If you can read .confs you can make sense of what you need to make sense of.
04:48:59 <simukis_> Daat418: that's how I think it is awesome.
04:49:08 <Daat418> simukis_: But you can't live-hack it in SLIME D:
04:49:10 <kryft> I dipped into Parsec's code yesterday and was pleasantly surprised by how approachable it looked
04:50:21 <Daat418> simukis_: that's totally fair but I cannot conceive of why it's considered better than an env like StumpWM or ratpoison.
04:51:00 <ion> http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.3.2/doc/html/Database-PostgreSQL-Simple.html#t:Query
04:51:02 <Daat418> simukis_: better than awesomewm? certainly - that thing looks like a giant mess an who wants to touch lua?
04:51:04 <ion> “This type is intended to make it difficult to construct a SQL query by concatenating string fragments, as that is an extremely common way to accidentally introduce SQL injection vulnerabilities into an application.”
04:51:07 <ion> instance Monoid Query
04:51:39 <jzelinskie> Not to be a downer, but most people would prefer lua to haskell
04:51:39 <Entroacceptor> I don't think it's viewed as objectively better than ratpoison, as it even has a different focus
04:51:50 <MasseR> Daat418: Indeed, live configuration change would be great. No doubt about that
04:51:57 <Daat418> simukis_: http://www.youtube.com/watch?v=tKt_rVO960Q
04:52:20 <Entroacceptor> I like it better than awesomewm or wmii (what I've tried before) because of the config
04:52:30 <MasseR> Daat418: But the code cleanliness (which doesn't mean a thing to end-users), stability and light-weightness are great points
04:52:35 <MasseR> And when you add xmonad-contrib
04:53:07 <Entroacceptor> and be careful, #haskell has some ...bias against certain languages
04:54:47 <Daat418> MasseR: Agreed, yes. I am somewhat biased toward StumpWM/Ratpoison due to a certain degree of familiarity and passionate love for Emacs and Lisp (that is, to the degree I understand them). The Xmonad config is beautiful but, ultimately, the config is genuinely just the beginning of the wm experience...
04:55:42 <bitonic> personally, I think XMonad is too much of a hassle.  I like i3
04:56:39 <Daat418> bitonic: it feels like a hassle. It's my current wm because i'm trying it out. I spent a good deal of time on -just- xmobar and it doesn't -feel- like it was time well-spent
04:56:57 <bitonic> i3 is the most sensible thing I could find
04:57:05 <bitonic> the XMonad defaults are just unusable
04:57:35 * hackagebot terminfo 0.1.0.0 - A pure-Haskell (no FFI) module for accessing terminfo databases  http://hackage.haskell.org/package/terminfo-0.1.0.0 (BryanRichter)
04:57:44 <Daat418> bitonic: yes, which is a terrible, terrible thing. it ensures your first impression is bad (and mine was).
04:57:59 <Daat418> MasseR: wb
04:58:07 <bitonic> Daat418: agreed.
04:58:09 <jzelinskie> last time I checked xmonad defaults were basically how I had customized my old DWM config from years ago
04:58:29 <jzelinskie> without ever using xmonad
04:58:32 <bitonic> they care a lot about keeping the core super small but there should be a way of getting xmonad + xmonad-contrib directly with some widely accepted defaults
04:58:45 <notdan> xmonad defaults are not worse than awesome defaults, I think
04:58:49 <notdan> (both are prett bad)
04:59:03 <notdan> so I just assumed it's the standard for tiling window managers
04:59:20 <Daat418> notdan: I haven't touched awesomewm because - truthfully - i am not in the least bit interested
04:59:26 <bitonic> never tried awesome.  the thing is, I don’t think you need the level of customization you need for—say—an editor in a WM.
04:59:28 <MasseR> Lua :/
04:59:44 <Daat418> MasseR: screw Lua. talk about a waste of time.
04:59:48 <bitonic> and i3 just gets most things right for me out of the box.  and the code is very hackable
04:59:56 <Daat418> MasseR: Might as well learn Cello >_<
05:00:02 <MasseR> Before xmonad I used wmii. I liked that
05:00:32 * Kinnison pouts at people being mean about Lua
05:00:36 <Kinnison> Lua is lovely
05:00:48 <bitonic> yeah, Lua is really not that terrible
05:00:49 <Daat418> Kinnison: It... is?
05:00:54 <MasseR> Kinnison: It'll do when in a pinch
05:01:02 <Kinnison> Daat418: I love it
05:01:05 <MasseR> But! This is just my personal _opinion_
05:01:07 <Kinnison> Daat418: I also love Haskell
05:01:11 <Kinnison> Daat418: and dill pickles
05:01:18 <Kinnison> Daat418: so people may find my opinions to be suspect
05:01:20 <Daat418> Kinnison: I hate Haskell.
05:01:27 <tero-> Lua is very good if you can write only correct code
05:01:29 <Kinnison> Daat418: fool
05:01:36 <bitonic> Daat418: you what?
05:01:40 <Daat418> Kinnison: haha. I love dill pickles and olives :)
05:01:49 <notdan> Yeah I am OK with Lua, it's... cute
05:01:51 <notdan> like Tcl
05:01:55 <Daat418> bitonic: I'm chatting in #haskell ... I'm probably being facetious :p
05:02:05 * Kinnison pondered rewriting his git server in Haskell.  Ended up deciding it wasn't worth it.  Lua is nice and easy for it
05:02:29 <Daat418> notdan: HA!!! cute
05:02:49 <Daat418> notdan: that's a terribly cruel adjective.
05:03:03 <Kinnison> notdan: that simile is most unfortunate
05:03:13 <Kinnison> (language bias -- shocking!)
05:04:08 <Daat418> Kinnison: My favourite language of all time is C#. Second only to ASP (not asp.net - that stuff is for kids)
05:04:19 <notdan> Kinnison: I am saying it in a positive way, btw
05:04:43 <Kinnison> notdan: I'm not sure I can countenance positivity where tcl is involved :-)
05:04:55 <Kinnison> Daat418: C# is okay, but I'm not a big OO fan
05:05:59 <Pip> Kinnison, Do you like C++?
05:06:31 <Kinnison> Pip: Nope.  Used to do a lot with it (I have games programming in my varied work history) but I really don't like it.
05:06:45 <Pip> I see :D
05:07:34 <Daat418> Kinnison: I found it repelling. At first I thought it was my lack of experience making the learning process painful (a friend offered me an entry-level dev position at a large advertising firm and even offered to give me intro lessons)
05:07:40 <Kinnison> These days I actively use Python, C, Lua, Haskell and Shell, and I keep my Perl, Awk and ARM assembly "live".
05:08:13 <Kinnison> Most of the rest of my programming knowledge has bit-rotted
05:08:25 <Daat418> Kinnison: Later, I learned that I am just really not at all keen on wasting energy on Java or Microsoft technologies. I don't like their structure, their standards, the companies that are responsible for them.
05:08:37 <Daat418> Kinnison: it's all very unnappealing to me.
05:08:49 <Kinnison> Daat418: fair enough.  If you know you dislike it, don't go near it :-)
05:09:37 <Daat418> Kinnison: I do feel somewhat awkward saying so because I lack fundamental knowledge. But, hopefully, you see where I'm coming from somewhat.
05:10:00 * Kinnison nods.  Different people's minds work in different ways
05:10:23 <Kinnison> We have a chap at work here who finds it actively hard to think in an idiomatically pythonic way.  His python code often resembles Haskell because he's a mathematician
05:10:41 <Daat418> Kinnison: indeed. I cannot deal with mess and endless abstraction. it'
05:10:51 <Daat418> Kinnison: it's painful to me (really)
05:10:57 <Daat418> Kinnison: ADHD
05:11:03 <Kinnison> :-)
05:11:30 <t7> Daat418: i have the same mentality when it comes to tracking mutable state all the time
05:11:31 <Daat418> Kinnison: which is why I am invoking my instapaper webjump whenever i want to read something online
05:11:45 <t7> my adhd mind cant be bothered to trace through all the possible paths
05:11:51 <Daat418> t7: :)
05:11:57 <t7> i just wanna know what variables are in scope and what is being returned
05:12:09 <Daat418> t7: I understand (adhd-brofist)
05:12:32 * t7 probably doesn't have adhd
05:12:41 <Daat418> t7: if I said "I'm addicted to Emacs" you could probably at least make sense of it, maybe?
05:13:33 <Daat418> t7: my coworkers all think I'm insane. I go on about emacs and I have to catch myself - they just think of it as a bloated and inferior vim.
05:13:53 <t7> im a vim guy...
05:13:59 * Kinnison uses both vim and emacs
05:14:01 * Kinnison is "special"
05:14:09 <MasseR> Kinnison: Me too
05:14:15 <Daat418> t7: I'm adding you to my /ignore. Go to hell.
05:14:23 <MasseR> Or rather, I'm a many years vim-user and I love it. But I wanted to see how emacs fares
05:14:23 <Daat418> t7: ^_^
05:14:38 <MasseR> So for the next couple of years I'm probably going to use emacs exclusively
05:14:43 <Kinnison> MasseR: Oh, I actively use both, often at the same time, sometimes next to one another on the same desktop
05:14:50 <MasseR> Kinnison: Oh good god
05:14:51 * Kinnison said he was "special"
05:14:58 <Daat418> Kinnison: I too use both.
05:15:13 <MasseR> My muscle memory can't handle both
05:15:19 <Daat418> MasseR: I can help you learn (and subsequently, learn to love emacs)
05:15:21 <MasseR> Even the most basic commands get mixed soon
05:15:27 <Entroacceptor> Kinnison: I'm special, too!
05:15:31 <sellout> Daat418: It can’t be inferior – you can implement Vim in Emacs, so it’s obvious that Vim ⊆ Emacs ;)
05:15:35 <Daat418> MasseR: hold on :)
05:15:54 <t7> sellout: yeah, bloat
05:16:10 <Daat418> t7: that's going too far :/ please don't say bloat
05:16:31 <MasseR> Daat418: Don't worry, I do like emacs. To a level
05:16:43 <Yaniel> by that logic vim ⊆ C
05:16:47 <Daat418> t7: your emacs configuration is entirely up to you - you don't have to run vim in ansi-term in buffer #205 if you don't want to.
05:17:29 <Daat418> MasseR: Behold! http://www.emacswiki.org/emacs/Evil
05:17:46 <MasseR> Daat418: I'm aware of that. I'm trying to avoid it
05:17:54 <MasseR> I want to learn _emacs_, not bring my vim to emacs
05:17:55 <Entroacceptor> this is getting a bit old and OT, can we go to -blah?
05:18:03 <Daat418> MasseR: good on you :)
05:18:15 <sellout> Yaniel: How about “Emacs encodes Vim” – that eliminates the Vim ⊆ C interpretation :)
05:18:17 <CADD> MasseR: evil-mode
05:18:30 <CADD> MasseR: oh nvm
05:18:40 <MasseR> :)
05:18:57 <CADD> MasseR: I dont know, i use emacs and i still use evil. they are mutually compatable i think
05:19:16 <Daat418> MasseR: As with anything, you'll probably need motivation to learn emacs. For me, that came from exposure to one mode in particular... http://orgmode.org/
05:19:25 <MasseR> Daat418: Me too
05:20:14 <MasseR> I heard good things about orgmode, but couldn't find equivalent for vim. And after .. 5 years of vimming (I consider myself quite proficient in it) I thought it's ok to learn something different too. I was never in the flamewar camp
05:20:25 <Daat418> http://orgmode.org/worg/org-contrib/babel/intro.html
05:20:51 <Daat418> MasseR: org-mode is absolutely phenomenal.
05:21:12 <Daat418> I could talk your ear off for HOURS upon HOURS about what it's capable of
05:21:16 <MasseR> Daat418: Indeed. It suits quite well to my workflow
05:21:27 <CADD> I agree with Daat418, you need a motivation. For me it was the Proof General. Pretty much nothing at all like that in vim.
05:21:28 <MasseR> Daat418: Sure go ahead, but probably not in here :D
05:21:47 <MasseR> Oh! And haskell-mode is .. magnificent. I love it
05:21:49 <CADD> That and amazing laxtex support.
05:22:01 <CADD> YES! haskell-mode
05:22:40 <CADD> It's really not an either-or thing. I still have my vimrc.
05:23:01 <Daat418> everything from todolists to entire blogs with structure and formatting and beautiful latex documents and desktop integration and scheduling and documentation generation through markup conversion and note management (ALL my notes are stored in a SINGLE plaintext file)
05:24:05 <CADD> indeed, org-mode is amazing.
05:24:12 <Daat418> MasseR: It is -the- most amazing tool - outside of pure code and Emacs itself - I have ever been exposed to in the realm of computers. in my life. ever.
05:24:14 <Daat418> end of story.
05:24:22 <CADD> pretty much
05:24:48 <CADD> emacs in itself is amazing
05:25:27 <CADD> i heard about it for such a long time, but after realizing that every single vim plugin was inventing emacs all over again, i had to switch
05:25:39 <Daat418> I truly love it. I make excuses to use it. I was copying some documentation off the web to a coworker and realized I could make it look and feel amazing by parsing it through org-mode with TeX integration (following a pandoc conversion)
05:25:43 <Daat418> and i fucking did it ^_^
05:25:59 <CADD> lol!
05:26:24 <MasseR> CADD: Agreed. Vim plugins < emacs plugins, but that is also because vimscript < elisp
05:26:29 <MasseR> Then again vim is more coherent
05:26:38 <MasseR> And the modality is extremely powerful
05:26:50 <MasseR> That alone rivals emacs' plugins
05:26:53 <CADD> MasseR: I agree with you on the first part. but no emacs is many times more coherent
05:27:00 <Daat418> CADD: haha, yup! I love it when people bring up vim plugins with me. this one dude was going on about how he no longer needs to use ssh to edit remote files because of git commits in st2 (god help us all). He had just got done telling me what antiquated trash emacs was.
05:27:08 <CADD> MasseR: the point isnt the power of the programming languge
05:27:09 <kryft> I just can't stand chords
05:27:15 <CADD> MasseR: its the power of the editor itself
05:27:23 <Daat418> I asked him, "Hey so-and-so, git commits are nice and all but have you heard of TRAMP?"
05:27:27 <kryft> (Having to press ctrl and anything else counts as a chord here)
05:27:31 <Daat418> So-and-so: "Huh?!"
05:27:43 <CADD> MasseR: Ok, more like every vim plugin is reinventing slime.
05:27:46 <CADD> Daat418: ^
05:27:47 <MasseR> CADD: I have to disagree. Every plugin have their own keybindings for functionalities that are similar to other plugins
05:28:21 <MasseR> My pet peeves are C-l, C-z and C-d.
05:28:22 <CADD> MasseR: a lot of the emacs chords fit well in other contexts
05:29:01 <Daat418> CADD: I'm using ERC as we speak *squeal* :>
05:29:01 <MasseR> CADD: Reinventing slime? I agree that there are plugins trying to do that but the majority isn't
05:29:35 <kryft> Hmm, apparently someone has tried to add evil mode bindings for org mode
05:29:36 <MasseR> Daat418: And the copying happens to other direction too
05:29:42 <kryft> That could work for me
05:29:44 <CADD> Daat418: I should be using erc, why am i not using it?
05:29:47 <MasseR> Take for example GUndo -> undo-tree
05:29:53 <CADD> Daat418: shame on me. im an irssi user.
05:30:06 <Daat418> CADD: Ha! Well, irssi is very nice
05:30:26 <merijn> I would like to propose #haskell-blah for the continuation of this conversation
05:30:32 <CADD> MasseR: true, but its amazing the stuff you get for free simply using emacs.
05:30:38 <CADD> Daat418: true true
05:34:01 <Daat418> A basic visual of ERC using My current config: http://i.imgur.com/C4Ycwn4.png?1
05:36:41 <Daat418> Well, thanks for the stimulating Q&A guys! (and putting up with my Emacs gushing)
05:36:48 <Daat418> I need to get ready for work
05:36:52 <Daat418> bye!
05:42:36 * hackagebot terminfo-hs 0.1.0.0 - A pure-Haskell (no FFI) module for accessing terminfo databases  http://hackage.haskell.org/package/terminfo-hs-0.1.0.0 (BryanRichter)
05:57:48 <Banistertab> Did anyone else find it hard to grok that `->` is a functor?
05:58:02 <Banistertab> And an applicative, and a monad...
05:59:31 <supki> well, (->) is not a Functor
05:59:44 <supki> ((->) e) is
05:59:49 <Banistertab> Yeah ;)
05:59:51 <byorgey> Banistertab: most people find it hard to grok at first.
06:00:05 <byorgey> I did.
06:00:33 <Banistertab> I find it confusing since functions are part of the definition of functors, yet thet are themselves also functors
06:01:57 <byorgey> Banistertab: right.  Ultimately I'm guessing it has nothing to do with Functor in particular, and everything to do with the fact that functions are first-class values in Haskell.
06:02:27 <byorgey> that is one of those key features of Haskell (and other functional languages) which is surprising, beautiful, and hard-to-grok-at-first
06:02:36 * hackagebot terminfo-hs 0.1.0.1 - A pure-Haskell (no FFI) module for accessing terminfo databases  http://hackage.haskell.org/package/terminfo-hs-0.1.0.1 (BryanRichter)
06:03:41 <Yaniel> so as a beginner... basically do is evil?
06:03:43 <killy9999> Banistertab: I'm not sure if I did manag to fully grok that, but I wrote down the types and proved to myself that the types make sense :)
06:03:48 <byorgey> it means you can not only *use* functions but also *talk about* them, manipulate them, pass them as arguments, store them in data structures...
06:03:50 <killy9999> Yaniel: no
06:04:48 <merijn> Yaniel: Why would do be evil?
06:04:50 <byorgey> Yaniel: do is only evil to the extent that you use it as a crutch, without understanding how it translates into calls to (>>=) and (>>)
06:04:51 <t7> IO monad is evil
06:04:55 <t7> IO is impure
06:05:06 <dmwit_> IO is not evil =(
06:05:16 <merijn> t7: ಠ_ಠ
06:05:20 <byorgey> it is not impure either.
06:05:24 <arcatan> IO is why we are here
06:05:28 <merijn> IO isn't impure and it's great!
06:05:33 <byorgey> *executing* IO is impure, that's why we leave it to the runtime.
06:05:39 <killy9999> merijn: http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
06:05:43 <killy9999> probably that's why
06:05:58 <killy9999> I think this page might be confusing many beginners (it did confuse me)
06:06:35 <merijn> killy9999: I partially agree with things there, especially the didactics point
06:07:01 <merijn> I always recommend newbies use >> and >>= explicitly until things click and only *then* use do-notation
06:07:19 <killy9999> yeah, but after reading this page some time ago I wasn't sure whether I should use do or not
06:07:39 <Yaniel> is this explained in learnyouahaskell somewhere near the end? :D
06:07:47 <killy9999> and I just went with using >>= and >> because it made the code look more cool and idiomatic (i.e. harder to understand)
06:07:53 <Entroacceptor> try using do for the list monad, that's confusing
06:08:14 <merijn> Yaniel: It should be explained in LYAH, yes
06:08:25 <Yaniel> okay, nvm then
06:08:44 <Yaniel> I suppose it'll become clear when I get that far
06:08:48 <merijn> Yaniel: Basically, do-notation is just syntactic sugar for perfectly normal haskell
06:08:54 <Yaniel> yeah
06:09:07 <Yaniel> someone told me that a couple of days ago
06:09:27 <merijn> Yaniel: The only reason it's used, is because it's nicer to read. Like I just mentioned, I recommend against using it for newcomers (to reduce confusion), but there's nothing wrong with it
06:09:27 <t7> 'normal haskell'
06:10:19 <t7> thats one of those sentences
06:10:27 <t7> i cant remember the name
06:10:31 <t7> oxymoron ?
06:11:41 <Breadmonster> What's the relationship between Haskell functors and category theory functors?
06:12:04 <Breadmonster> I remember that functors are maps from one category to another that preserve categorial structure.
06:12:20 <roconnor> Haskell functors are imagined to be endofunctors on a Category call Hask of types and functions.
06:12:37 * hackagebot hlint 1.8.48 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.48 (NeilMitchell)
06:12:53 <Breadmonster> That went way over my head.
06:12:54 <Breadmonster> But okay.
06:13:01 <Breadmonster> Where do I learn category theory?
06:13:38 <dmwit> "endofunctor" means "functor from some category to itself"
06:14:11 <Breadmonster> Oh, right, yeah.
06:14:12 <Kinnison> wikipedia has a few reasonably easy to understand pages on category theory
06:14:23 <dmwit> Hask is the category whose objects are Haskell types and whose arrows are functions of the appropriate type.
06:14:24 <Kinnison> but frankly I didn't find it that helpful in *learning* haskell
06:14:29 <Kinnison> just in making some 'aha' moments happen
06:15:07 <Breadmonster> Kinnison: I like the langauge because of those moments.
06:15:10 <quchen> The objects of Hask are types, the morphisms of Hask are functions between those types. A functor maps objects to objects and morphisms to morphisms (obeying the functor laws). Haskell Functors now map types to other types (for example a to Maybe a), and functions to functions between the new types (i.e. it maps (a->b) to (Maybe a -> Maybe b)).
06:15:30 <Breadmonster> Also, how many of you around here have PhDs in Math?
06:15:43 <Breadmonster> I'm beginning to feel like a kind of outcast.
06:16:00 <MasseR> Breadmonster: :D. Don't worry
06:16:04 <Kinnison> If it helps, I don't even have a bsc
06:16:10 <Breadmonster> Hmm.
06:16:17 * Kinnison is an uneducated oaf
06:16:18 <bscarlet> Breadmonster: big difference between outcast & outsider. :-)
06:16:27 <Breadmonster> Has anyone here read the HoTT book?
06:16:52 <Breadmonster> I was scrolling through it, and apart from a short section on Dedekind cuts, everything just flew over my hear.
06:16:53 <quchen> Breadmonster: ask mm_freak about his math education. He's the go-to guy when it comes to having no formal math training, yet a pretty good understanding of category theory.
06:16:58 <Breadmonster> Kinnison: Neither do I.
06:17:09 <Breadmonster> mm_freak: Anybody home?
06:17:16 * Kinnison is choosing his next course for open-university soon
06:17:19 <mm_freak> Breadmonster: yes
06:17:24 <t7> i have a gcse C in math; aka very qualified
06:17:25 * Kinnison is pondering a course on the mathematics behind graph and network theory
06:17:34 <Breadmonster> mm_freak: How'd you learn category theory?
06:17:50 <mm_freak> Breadmonster: gradually, piece by piece
06:18:11 <Breadmonster> Can you write papers in the subject?
06:18:32 <mm_freak> Breadmonster: on applied CT probably yes
06:18:42 <Breadmonster> Okay, that's good.
06:18:49 <mm_freak> at least applied to haskell/programming
06:19:06 <Breadmonster>  That's really good.
06:21:17 <mm_freak> Breadmonster: btw, i read your "how'd" as "how did", not as "how would"
06:21:43 <Breadmonster> Okay, so are there any textbooks on category theory?
06:22:15 <Breadmonster> Categories for the Working Mathematician flies over my head.
06:22:55 <byorgey> Breadmonster: yes, lots.  and don't worry, CftWM flies over everyone's head.  It is really more of a reference work than something to learn from.
06:23:00 <tikhonjelvis> Basic Category Theory for Computer Scientists is good
06:23:08 <tikhonjelvis> by Pierce
06:23:13 <Breadmonster> tikhonjelvis: are you on Quora?
06:23:20 <tikhonjelvis> very approachable
06:23:21 <byorgey> Awodey's book is also often highly recommended (though I haven't read it myself)
06:23:23 <tikhonjelvis> a bit
06:23:42 <Breadmonster> Is Awodey oriented towards computer science?
06:24:03 <byorgey> Not particularly, I think?  I am not sure.
06:24:18 <quchen> Awodey gives examples. That's what sets it apart from other books the most if you ask me.
06:24:25 <quchen> There's even a section on lambda calculus.
06:24:31 <Breadmonster> Hmm.
06:24:34 <quchen> Also it's not crazy formal.
06:24:41 <quchen> (Still formal, though.)
06:24:47 <Breadmonster> Alright.
06:24:53 <Breadmonster> Is category theory hard to learn?
06:25:13 <quchen> Not really. Like most introductory math books, it's mostly about how interested and determined you are.
06:25:36 <quchen> If you're only half-motivated, you're going to have a rough time (I know what I'm talking about here).
06:25:52 <osa1> @where paste
06:25:52 <lambdabot> http://paste.tryhaskell.org/new/haskell
06:26:13 <lpaste> osa1 pasted “what value to return instead of undefined?” at http://lpaste.net/90953
06:26:14 <quchen> Imagine learning Haskell without proper motivation. You'd still be complaining about how it has no side-effects which makes writing real applications hard.
06:26:22 <quchen> Same thing for category theory.
06:26:27 <tikhonjelvis> basic category theory is realtively simple, just very abstract
06:26:33 <osa1> hi all. in this piece of code: http://lpaste.net/90953 is there a better value to return instead of undefined?
06:26:41 <quchen> osa1: Yes.
06:26:48 <tikhonjelvis> it takes a particular mindset to deal with that much abstraction, different from most other things you can learn
06:26:48 <quchen> There is always a better value than undefined.
06:26:55 <mm_freak> Breadmonster: my own problem with CT was that i tried to find stuff that just wasn't there
06:27:15 <mm_freak> Breadmonster: "ok, i understand the axioms, but now what is a functor?!"
06:27:29 <osa1> quchen: that value will never be used, never evaluated etc. what can I use instead of undefined?
06:27:36 <Breadmonster> osa1: ()
06:27:56 <tikhonjelvis> osa1: you could use error with a useful error message
06:27:59 <mm_freak> osa1: you can't "return undefined", btw
06:28:01 <osa1> Breadmonster: that doesn't work, have you looked at the code?
06:28:09 <mm_freak> to return undefined is the same as to not return
06:28:21 <Breadmonster> mm_freak: What do you mean?
06:28:27 <kryft> quchen: You can also have the proper motivation but the wrong approach, though; for instance, it took me a long time to realize that when you encounter a new abstract concept, it's not necessarily useful to try to understand it in its full generality before actually working with concrete special cases
06:28:41 <mm_freak> Breadmonster: with what?
06:28:56 <Breadmonster> mm_freak: "ok, i understand the axioms, but now what is a functor?!
06:29:08 <quchen> kryft: Yes. Another plus for Awodey's examples. (It's a shame I can't find the PDF onlin anymore. I downloaded it legally somewhere, maybe it was on the Arxiv at some point.)
06:29:24 <osa1> Breadmonster: hmm actually you were right
06:29:25 <kryft> quchen: I used to try to study math linearly, refusing to move forward until I had understood a theorem or proof 'completely', which led to much frustration :)
06:29:36 <osa1> Breadmonster: catchError a (\err -> void (liftIO $ print err)) >> b this works
06:29:38 <mm_freak> Breadmonster: it's just very abstract and i had difficulty with the fact that there wasn't anything more than axioms
06:29:51 <kryft> quchen: I would also be interested in that
06:30:05 <quchen> kryft: Yeah, that's a common mistake. It's pretty important to learn to jump over the gaps you have.
06:30:39 <bscarlet> osa1: since you're not really using the value returned by a, you might need to replace a by (a >> return ()) if you want to have the error handler return ().
06:30:45 <kryft> quchen: Yes, I still make that mistake quite a lot; it's some kind of fundamental psychological flaw for me ;)
06:30:55 <osa1> even removing that void works, since print's return type is IO (). looks like I don't have to add anything there
06:31:17 <bscarlet> osa1: sorry. "need" wasn't the right word.
06:31:50 <kryft> quchen: How is Awodey compared with the Pierce book?
06:31:54 <Breadmonster> @src void\
06:31:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:31:56 <Breadmonster> @src void
06:31:56 <lambdabot> Source not found. :(
06:32:03 <Breadmonster> osa1: What does void do?
06:32:17 <quchen> kryft: I don't know Pierce I think.
06:32:28 <sopvop> :t Data.Functor.void
06:32:29 <lambdabot>     Not in scope: `Data.Functor.void'
06:32:29 <lambdabot>     Perhaps you meant `Data.Function.id' (imported from Data.Function)
06:32:36 <sopvop> :t Data.Monad.void
06:32:37 <lambdabot> Couldn't find qualified module.
06:32:52 <quchen> Control.Monad.void
06:33:00 <sopvop> oh, right
06:33:01 <quchen> It moved to Data.Functor in 7.6 I think
06:33:05 <quchen> But it's reexported from Monad
06:33:05 <sopvop> :t Control.Monad.void
06:33:06 <lambdabot> Functor f => f a -> f ()
06:33:13 <osa1> Breadmonster: void a = a >> return () -- I think this is the definition
06:33:24 <quchen> osa1: void = fmap (const ())
06:33:47 <quchen> Semantically that's equivalent to (>> return ()), but requires only Functor and not Monad
06:33:52 <kryft> quchen: I meant Basic Category for Computer Scientists that was mentioned above and that I've heard about before
06:34:04 <Breadmonster> @src Control.Monad.void
06:34:04 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:34:05 <osa1> hm, nice
06:34:15 <Breadmonster> What on earth is a rutabaga?
06:34:23 <Thra11> Breadmonster: a sort of tunrip
06:34:27 <Thra11> turnip*
06:34:28 <tikhonjelvis> it's a vegetable of some sort, I believe
06:34:39 <Breadmonster> Who made lambdabot?
06:34:41 <Breadmonster> :h
06:34:49 <Breadmonster> > 2 + 2
06:34:50 <lambdabot>   4
06:34:55 <Breadmonster> Oh, right, it does work.
06:37:07 <quchen> I think Lambdabot is a pretty basic IRC bot that gets its functionality from many little plugins
06:37:22 <quchen> So there's no single person responsible for her
06:37:23 <Breadmonster> Hmm.
06:37:30 <Breadmonster> Why won't it show me the source for void?
06:37:51 <quchen>  @src searches a static database (and not some original source files).
06:37:59 <Breadmonster> Oh, okay.
06:41:56 <prophile> @hoogle (a -> a -> a) -> Endo a
06:41:56 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
06:41:57 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
06:41:57 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
06:41:58 <quchen> How complicated is the notion of a "collection" in category theory? It's often used as a "we can't use sets here" word in basic texts. How complicated is a precise definition?
06:42:21 <Breadmonster> :t (***)
06:42:21 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:42:28 <Breadmonster> What on earth is that?
06:42:37 * hackagebot numtype 1.0.1 - Type-level (low cardinality) integers.  http://hackage.haskell.org/package/numtype-1.0.1 (BjornBuckwalter)
06:42:39 * hackagebot dimensional 0.12.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.12.1 (BjornBuckwalter)
06:42:41 * hackagebot numtype-tf 0.1.1 - Type-level (low cardinality) integers, implemented  using type families.  http://hackage.haskell.org/package/numtype-tf-0.1.1 (BjornBuckwalter)
06:42:45 <quchen> :t (***) `asAppliedTo` (undefined :: a -> b)
06:42:47 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
06:42:49 <quchen> Better? :-)
06:43:04 <prophile> quchen: it's a class, I think
06:43:23 <quchen> > ((+2) *** (++ "world")) (0, "hello ")
06:43:25 <lambdabot>   (2,"hello world")
06:44:05 <Breadmonster> Why on earth would you need that?
06:44:12 <notdan> Is there a sane way to convert between Text.Lazy <-> Text and ByteString.Lazy <-> ByteString?
06:44:12 <Breadmonster> Wait.
06:44:16 <Breadmonster> Wha's an arrow?
06:44:40 <prophile> danger will robinson
06:44:43 <notdan> I am trying to use scotty and heist and scotty relies on lazy Text, ByteStrings while heist relies on stric versions
06:44:49 <dmwit> quchen: It's as complicated as you want it to be.
06:44:53 <quchen> Breadmonster: It's sort of a generalized version of a function.
06:44:58 <dmwit> If you want it to be simple, you take "collection" to mean "set".
06:45:03 <prophile> Breadmonster: http://www.haskell.org/arrows/
06:45:05 <dmwit> But you could take any other theory you like.
06:45:07 <quchen> dmwit: That's my current approach :-)
06:46:10 <tikhonjelvis> Arrows are a little confusing because there is the idea of an arrow from category theory (e.g. a morphism) and an Arrow from Control.Arrow, which is different
06:46:39 <quchen> Breadmonster: There are probably around 1.5 arrows you'll ever actively use, the 1 being ordinary functions, and the .5 functions of the type "a -> m b".
06:46:40 <dmwit> There are terms like "locally small" and "small" for when each hom-set is a set and for when both the collection of objects and the collection of arrows are a set, respectively.
06:46:56 <quchen> dmwit: That's where the question came from, actually :-)
06:47:16 <dmwit> okay
06:47:20 <mm_freak> Breadmonster: basically arrows are categories enriched with side paths
06:47:31 <mm_freak> see 'arr' and 'first'
06:47:38 <mm_freak> those are the elementary functions of arrows
06:47:49 <quchen> dmwit: I was just wondering what kind of thing categories are using to beat Russell's paradox ;-)
06:48:11 <quchen> (i.e. what's the collection of objects of Set)
06:48:20 <tikhonjelvis> maybe I'm just biased, but I don't think Control.Arrow arrows are worth learning about until you really have to
06:49:17 <dmwit> I actually don't know the answer to that.
06:49:38 <dmwit> Probably "class" as prophile suggested.
06:49:51 <dmwit> But I've never been formally told what a "class" actually is, so I'm not sure.
06:49:58 <mm_freak> Breadmonster: nowadays you should learn Control.Category…  then it's really just a small step to Control.Arrow
06:50:57 <tikhonjelvis> I think part of the trick is that a "class" is not really defined in normal set theory
06:51:04 <tikhonjelvis> in order to avoid paradoxes and stuff
06:51:32 <tikhonjelvis> it's just a bunch of things defined by some property they all share
06:52:38 * hackagebot dimensional-tf 0.2 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.2 (BjornBuckwalter)
06:52:49 <lpaste> lasticot pasted “McCarthy” at http://lpaste.net/90954
06:52:53 <lasticot> hi, I've received this error message when executing my program: Prelude.read: no parse. How can I read an Int from the argument list?
06:53:18 <merijn> lasticot: By making sure you provide an Int? :)
06:53:24 <merijn> > read "abh" :: Int
06:53:26 <lambdabot>   *Exception: Prelude.read: no parse
06:54:34 <quchen> tikhonjelvis: Wikipedia says "class" is from set theory though. http://en.wikipedia.org/wiki/Class_%28set_theory%29
06:54:37 <lasticot> merijn: I must have done something wrong since "./mccarthy 89" trigers the same error message.
06:54:41 <quchen> There's some awkward thing going on here for sure.
06:54:53 <quchen> I'll just stick with locally small categories and I'll be fine I guess :-)
06:55:42 <quchen> The article sounds like an interesting read, it addresses the issue a little bit.
06:56:12 <tikhonjelvis> locally small seems to cover all the fun ones, at least for basic CS stuff
06:57:10 <dmwit> lasticot: You are trying to read your argument as both an Int and a String.
06:57:47 <dmwit> lasticot: Perhaps you just meant {cString = "M(" ++ head args ++ ")\n", on line 13.
06:58:08 <lasticot> dmwit: that's it thank you !
07:08:42 <Breadmonster> What do I need to import to get the Applicative typeclass?
07:08:46 <Breadmonster> It isn't in GHC.
07:09:55 <tikhonjelvis> umm, did you spell it correctly?
07:11:20 <tikhonjelvis> oh, I guess it's in Control.Applicative
07:11:24 <Banistertab>  import Contol.Applicative
07:11:43 <tikhonjelvis> I didn't realize it wasn't imported by default because I always use it
07:17:30 <tswett> GHC doesn't allow implicit parameters in types, does it?
07:18:33 <merijn> tswett: No :( Although it might be part of the type holes stuff that's being worked on?
07:19:07 <tswett> Types like this get old after a while: (((b :-> c) r :-> ((a :-> b) r :-> (a :-> c) r) r) r)
07:20:31 <bscarlet> what's an implicit type, and what's :-> ?
07:21:10 <tomboy64> i'm getting these errors: http://bpaste.net/show/114742/ with this code http://bpaste.net/show/114741/  --- but i have no idea what this error message is supposed to tell me: Occurs check: cannot construct the infinite type: t0 = Ratio t0
07:22:01 <tswett> bscarlet: I have the declaration type (a :-> b) r = a -> Cont r b.
07:22:28 <tikhonjelvis> the code is happier with more smilie faces in it
07:22:37 <tswett> bscarlet: I'd like it if it the r were an implicit parameter, so I could just say stuff like "(b :-> c) :-> (a :-> b) :-> (a :-> c) where ?r = r".
07:22:38 * hackagebot fishfood 0.0.0.1 - Finds the file-size frequency-distribution for the referenced files.  http://hackage.haskell.org/package/fishfood-0.0.0.1 (AlistairWard)
07:22:40 * hackagebot tagged-transformer 0.4 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.4 (MatveyAksenov)
07:22:41 <tswett> tomboy64: lemme take a look.
07:24:35 <tswett> tomboy64: in short, that error usually means "you made a mistake". In this case, I see that you're doing λ * x1. But are λ and x1 both of the same type?
07:25:01 <tswett> tomboy64: it looks to me like they aren't, so you're going to need to change something.
07:25:37 <tswett> tomboy64: is x1 a Ratio? If it is, then you should use / instead of % in the definition of λ, because % is only for making Ratios out of non-Ratios.
07:25:55 <tswett> And if x1 is not a Ratio, then you need to turn it into a Ratio before multiplying it by λ, because you can't multiply a Ratio by a non-Ratio.
07:26:10 <tomboy64> tswett: the latter is the case
07:26:32 <tomboy64> thanks for explaining that; i presumed haskell would convert it automatically.
07:26:41 <tomboy64> lack of experience with ratios ...
07:27:15 <tomboy64> tswett: do i need to turn n1 and n2 into ratios as well?
07:27:15 <Sculptor> yo
07:27:22 <tulcod> i want to write a function accepting certain option flags (such as whether to include certain search paths). what is the typical way to do this in haskell?
07:27:34 <tswett> *nod* Haskell pretty much never converts anything automatically. I'm not sure if that's a strength or a weakness.
07:27:39 <tswett> tomboy64: yeah, it looks like you do.
07:27:40 <A3F> bitmask ? ;d
07:28:14 <tswett> tulcod: if I remember correctly, the usual way is to define a new type that's a record of Bools.
07:28:29 <merijn> tulcod: What tswett said, or use Maybe arguments
07:28:29 <tswett> data Options = Options {includeCertainSearchPaths :: Bool; ...}
07:28:37 <tikhonjelvis> tulcod: have you looked at optparse-applicative?
07:28:43 <tulcod> tikhonjelvis: no
07:28:58 <merijn> like "foo :: Maybe FilePath -> ..." if it's Just, search the filepath, if Nothing, then don't
07:28:58 <tikhonjelvis> it's a nice library for dealing with commandline arguments
07:29:09 <tulcod> tikhonjelvis: this is not about command line arguments specifically
07:29:27 <tikhonjelvis> ah
07:29:39 <tulcod> merijn: uh, i think Nothing would be "just default" here?
07:29:48 <tikhonjelvis> I would probably organize it so that the function just takes a list of paths to search
07:29:56 <tikhonjelvis> and assemble the list based on the inputs
07:29:56 <merijn> tulcod: Whatever's convenient
07:30:13 <tulcod> merijn: i think something like that would be rather applicable in my instance, thanks
07:30:36 <merijn> tulcod: Usually I'd write a general function using that style and then provide a partially applied function for the common case
07:30:41 <CaptainK> what is the channel paste bin?
07:30:50 <tulcod> tikhonjelvis: well this is actually for an FFI so i cannot really do that
07:30:53 <tikhonjelvis> oh
07:30:57 <tikhonjelvis> well then
07:31:06 <Yaniel> @where paste
07:31:06 <lambdabot> http://paste.tryhaskell.org/new/haskell
07:31:12 <tikhonjelvis> can't really give you any advice on using the FFI :/
07:31:22 <A3F> does anyone have experience with using haskell as scripting language ?
07:31:25 <merijn> i.e., if the common case doesn't provide a search path then, "fooGeneric :: Maybe FilePath -> ...; foo :: ...; foo = fooGeneric Nothing"
07:32:28 <tulcod> tswett, merijn: thanks, i think i'll use a Maybe Bool for the user-specified flags, and merge those with an internal "default state" :)
07:32:38 * hackagebot MonadRandom 0.1.10 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.10 (BrentYorgey)
07:34:25 <lpaste> CaptainK pasted “EatMyWords” at http://lpaste.net/90955
07:35:21 <A3F> anyone? I would like to implement a scripting system for a game written in haskell and i would like for it to be in hs too, are there any projects I could check ?
07:35:22 <CaptainK> Any suggestions, additions or instruction to the above paste is newbie welecomed
07:36:21 <tikhonjelvis> A3F: What exactly do you mean by "scripting"?
07:36:40 <tikhonjelvis> I've used Haskell for some system scripts (i.e. replacing bash), but that's probably very different from using it for a game
07:36:51 <A3F> the same way lua is commonly used
07:37:02 <tikhonjelvis> ah
07:37:12 <tikhonjelvis> yeah, I haven't used it like that, I'm afraid
07:38:49 <A3F> I will probably link GHCi or Hugs but I wonder if there are more convenient ways for this
07:39:38 <tikhonjelvis> there's a package called plugins (hackage.haskell.org/package/plugins) which might be relevant
07:39:41 <tikhonjelvis> but I haven't used it myself
07:42:36 <A3F_> found this: http://hackage.haskell.org/package/hint , looks promising
07:54:26 <adas> i have installed mtl 2.1.2 using cabal. The installation was a success but i can't find the mtl documentation. Can someone please point me in the right direction?
07:55:07 <byorgey> adas: do you have cabal configured to build documentation?  For some silly reason it is off by default
07:55:48 <adas> byorgey: i don't think so. i just installed haskell, cabal and did 'cabal install mtl'
07:56:13 <byorgey> adas: ok. what OS are you on?
07:56:16 <CaptainK> New to git, is git a good place to blog haskell and share scripts?
07:56:44 <adas> byorgey: im on a linux box. arch linux
07:56:52 <Lethalman> adas, ~/.cabal/config then tweak the documentation property
07:57:18 <Lethalman> it's something like that iirc
07:57:23 <byorgey> CaptainK: github can be a good way to share scripts.  github is not a good way to write a blog.
07:57:39 * hackagebot database-migrate 0.2.0 - Database versioning and migration (experimental)  http://hackage.haskell.org/package/database-migrate-0.2.0 (MarkHibberd)
07:57:45 <Maior> byorgey: gh-pages...
07:57:50 <shoret> github pages is a fine way to have a blog
07:58:10 <byorgey> ah, didn't know about gh-pages
07:59:27 <byorgey> adas: once you put 'documentation: True' in your ~/.cabal/config, then  cabal install --reinstall mtl, then the documentation should be in  ~/.cabal/share/doc/
07:59:59 <adas> byorgey: thank you so much. I will do that now.
08:00:14 <Philippa> ...just realised something worrying
08:00:25 <Philippa> the way I use Haskell these days makes me the PLT equivalent of a Ruby hipster
08:00:40 <veryrandomname> can somebody explain to me why this Elerea(FRP) function takes 4 arguments? I think it should take only 2 https://gist.github.com/veryrandomname/aa609867ed4bc00f0bac#file-elereadelay
08:00:40 <Philippa> (metatheory, what's that? :p)
08:00:56 <tikhonjelvis> eh, in PLT Haskell is pretty mainstream
08:01:09 <Philippa> tikhonjelvis: just like Ruby in startup culture
08:02:32 <Philippa> (and both are common metalanguages for DSLery)
08:02:53 <Philippa> ah well. Good think I'm getting Taught Agda next month
08:02:56 <Philippa> *thing
08:03:05 <Philippa> eh, think too. Was a good idea :-)
08:03:18 <adas> byorgey: i think the --reinstall option is unrecognized
08:03:42 <Philippa> AFK (or at least Keyboard In Bag) shortly, anyway. Looks like I'm not amusing anyone
08:04:14 <byorgey> adas: what makes you think that?
08:04:34 <adas> byorgey: sory..i must have typed it in wrong. it seems to work now..
08:04:56 <byorgey> great =)
08:04:56 <CaptainK> byorgey: shoret: thanks for the input, will head over to #github for more
08:05:28 <adas> byorgey: it said reinstall are always dangerous and went ahead with the installation anyways
08:05:43 <byorgey> adas: ah, it is just trying to scare you
08:05:55 <byorgey> adas: it is dangerous to reinstall packages which other packages depend on.
08:06:09 <byorgey> adas: but since you just installed mtl on a fresh install, nothing else depends on it yet
08:06:11 <latermuse> is there a way to get the type that GHCI is using for a function? I need to compare it to the type that I think im using.
08:06:25 <tikhonjelvis> :t
08:06:26 <latermuse> while under type error scenario
08:06:35 <adas> ah okay. thanks for the clarification
08:06:46 <tikhonjelvis> try using -fdefer-type-errors?
08:06:53 <tikhonjelvis> it's a flag on 7.6+
08:07:00 <latermuse> ooh thats exactly what i meant :)
08:07:01 <latermuse> thanks!
08:07:09 <tikhonjelvis> :set -fdefer-type-errors
08:07:39 * hackagebot g-npm 0.0.1 - Generate Gentoo ebuilds from NodeJS/npm packages.  http://hackage.haskell.org/package/g-npm-0.0.1 (JesusRivero)
08:08:07 <adas> byorgey: i only have a LICENSE file in the .cabal/share/doc. is that normal?
08:08:19 <latermuse> bam! that instantly found the correct type error that ive been looking for!
08:08:43 <tikhonjelvis> awesome
08:08:49 <tikhonjelvis> I really love deferred type errors
08:08:50 <adas> is there a place only where i can get mtl docs
08:09:27 <adas> i searched hackage but there are many mtl's in there
08:09:41 <byorgey> what? there is only one mtl.
08:09:57 <byorgey> adas: when you did  cabal install --reinstall, did it output some messages about building the documentation?
08:10:20 <adas> byorgey: nope
08:10:40 <jhance> adas: http://hackage.haskell.org/package/mtl-2.1.2
08:10:55 <byorgey> adas: and you edited your ~/.cabal/config file and changed  Documentation: False to Documentation: True?
08:11:05 <adas> but the config file says Documentation: True
08:11:13 <byorgey> adas: did you remove the -- comment from in front of  Documentation: True?
08:11:13 <tikhonjelvis> is it commented out, perhaps?
08:11:29 <adas> byorgey: bad news.. i didn't remove the --
08:11:33 <adas> sorry
08:11:35 <byorgey> hehe, np
08:11:52 <tikhonjelvis> it's a common mistake--I've certainly done it before
08:12:13 <tikhonjelvis> it's worse because Emacs doesn't highlight the file correctly
08:12:28 <byorgey> adas: however, I am curious what you meant by "I searched hackage but there are many mtl's in there" -- how did you search Hackage?
08:12:59 <adas> byorgey: ctrl f using firefox
08:13:26 <byorgey> oh, there are many packages with names that involve 'mtl'
08:13:32 <byorgey> but there is only one 'mtl' package
08:14:07 <Clint> i pretend that 'transformers' is 'mtl'
08:14:09 <byorgey> you can always just go to  hackage.haskell.org/package/FOO  to see package FOO
08:14:21 <adas> ah okay. wow..didn't think simply getting the docs could be this involving
08:15:11 <byorgey> simply doing anything is involved when you are just learning how.
08:15:20 <Taneb> Unfortunately, very much of Haskell's ecosystem is "good enough"
08:15:35 <tikhonjelvis> getting better though, happily
08:16:31 <byorgey> Taneb: so, have you done anything to improve it recently? =)
08:17:31 <Taneb> byorgey, I submitted a pull request that adds an Applicative instance for a Monad
08:17:40 <byorgey> excellent!
08:17:40 <chunkstuntman> why can't I pass a list of lists to foldr?
08:17:48 <Taneb> :t foldr
08:17:49 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:17:53 <merijn> chunkstuntman: You can
08:18:01 <tikhonjelvis> you can, but your function type has to match up
08:18:02 <chunkstuntman> foldr (\x acc -> augPass x acc) pass
08:18:08 <Taneb> :t foldr :: ([a] -> b -> b) -> b -> [[a]] -> b
08:18:08 <lambdabot> ([a] -> b -> b) -> b -> [[a]] -> b
08:18:14 <tikhonjelvis> e.g. ([[a]] -> b -> b) -> b -> [[a]] -> b
08:18:17 <chunkstuntman> pass is the list of lists
08:18:26 <chunkstuntman> and augPass takes a list as input
08:18:28 <tikhonjelvis> er
08:18:33 <tikhonjelvis> e.g. ([a] -> b -> b) -> b -> [[a]] -> b
08:18:45 <merijn> chunkstuntman: You're missing an initial value
08:18:49 <byorgey> chunkstuntman: foldr needs another argument for the base case.
08:18:54 <Twey> tswett: http://webcache.googleusercontent.com/search?q=cache:v_Eet8wbRg0J:www.haskell.org/pipermail/haskell-cafe/2007-September/032360.html+&cd=1&hl=en&ct=clnk&gl=uk
08:19:29 <adas> quick question .. i keep seeing something like this often 'class Monad m => MonadState s m | m -> s where'. I don't understand the thing that comes after the pipe symbol
08:19:35 <chunkstuntman> I always mix up how you order foldr values
08:19:37 <chunkstuntman> thanks!
08:20:45 <augur_> chunkstuntman: its a reasonable thing to mix up, since the logical order doesnt fit the actual order in Haskell :p
08:20:48 <Twey> adas: It's a functional dependency.  It says that there can only be one s for each particular m.  For example, you could make an instance MonadState Int IO, but then you couldn't make a MonadState String IO.
08:20:55 <augur_> everyone knows that folds should order base case first!
08:22:21 <augur_> ofcourse, everyone REALLY knows folds should only have one argument for the algebra, but alas, we're not generic enough yet :p
08:22:40 <adas> Twey: but doesn't that limit what the class can be used for?
08:23:11 <adas> i read the 'm -> s' as the type of m solely depends on s. not sure if thats correct
08:23:28 <chunkstuntman> augur_: it's like that in scheme as well, I've never totally understood why
08:24:27 <Twey> adas: That's the idea.  The idea is that the argument s is ‘completely determined by’ the argument m — there's exactly one value of s that makes sense for any value of m.
08:24:31 <augur_> chunkstuntman: i think it might have to do with some kind of mental analogy to iteration -- do this do this do this and finally end with this
08:24:44 <Twey> adas: See http://www.haskell.org/haskellwiki/Functional_dependencies for a better example.  :þ
08:25:57 <volitek_>  When should you use state monads and when should you use Mvars?
08:26:20 <jhance> volitek_, Well, State is pure and MVar is not
08:26:52 <merijn> "When should you use a car and when should you use a tractor?"
08:27:06 <roconnor> you should use state monads unless you have some reason to use MVars.
08:27:14 <merijn> Sure, they're both motorised vehicles, but they're designed for completely different things
08:27:16 <mauke> whoa
08:27:26 <volitek_> Just when googling around for state, it seems half of people recommend one, and half the other
08:27:26 <mauke> State and MVar are like completely different things
08:27:31 <merijn> As such, a comparison is not very sensical
08:27:35 <mauke> MVars aren't even IORefs
08:27:36 <quicksilver> typical use for MVars is when you have multiple threads which need to communicate.
08:27:36 <shoret> only use MVars if you need two processes to communicate
08:27:39 <bscarlet> adas: I'd read m -> s as "the type of m determines the type of s", i.e. for each m such that there is an instance of MonadState s m, there is only one such s.
08:27:44 <Twey> volitek_: State is just a way of prettifying threading an argument between a bunch of function calls.  MVars are for communicating between threads.
08:28:12 <volitek_> Okay, I think State is what I need then
08:28:14 <volitek_> thanks
08:28:18 <jhance> volitek_: MVars are for concurrency, State is essentially a wrapper around "s -> (s, a)"
08:28:38 <Twey> volitek_: *IORefs* are for mutable state, i.e. communication between arbitrarily separated parts of a program that have access to the same IORef.
08:29:21 <roconnor> ah I was confusing MVars with STRefs
08:29:39 <applicative> volitek_: I think things went off track because you mentioned MVars rather than IORefs
08:29:47 <roconnor> you should use state monads unless you have some reason to use STRefs.
08:30:25 <applicative> your question, I take it, was something like: when should i use a state monad, and when should I use some obnoxious mutable thingy ...
08:31:13 <applicative> or maybe ...
08:31:26 <prophile> is there an ArrowApply analogue that makes the arrow equivalent to a comonad?
08:31:47 <applicative> yipe
08:34:24 <applicative>  app :: a (a b c, b) c
08:37:29 <CaptainK> How do you query lambdabot for all of its where entries?
08:38:27 <WilliamDhalgren> hi!
08:38:38 <CaptainK> high!
08:39:06 <scshunt> is there a way to export a qualified module?
08:40:39 <applicative> so that the importer of your module, qualified, would have to qualify twice, scshunt ?
08:40:59 <WilliamDhalgren> I was looking at the closed type families, soon in ghc, Not sure why they chose the more verbose syntax - type family .. where. Is there something ambigous about just type ... where?
08:41:26 <WilliamDhalgren> (and wouldn't it be more symmetric w GADTs)
08:41:37 <applicative> type family ... goes with type instance ...
08:41:44 <applicative> no?
08:41:48 <WilliamDhalgren> not with closed type families
08:41:56 <WilliamDhalgren> afaik
08:41:58 <applicative> I am suddenly seeing your point, yes
08:42:55 <merijn> WilliamDhalgren: It's a variation of the old syntax "type instance .. where"
08:43:22 <applicative> where do they talk about this, I have just heard about it obscurely, WilliamDhalgren
08:43:31 <applicative> the closed type families
08:43:59 <WilliamDhalgren> found a reddit link to the commit :D but there's a wiki page - http://ghc.haskell.org/trac/ghc/wiki/NewAxioms
08:44:08 <applicative> oh thanks
08:44:43 <WilliamDhalgren> merijn, i get where its comming from. but still seems unnecessary
08:44:56 <WilliamDhalgren> unless I'm overlooking something
08:46:01 <merijn> WilliamDhalgren: It is unnecessary from a compiler point of view, I think it's helpful from a "user confusion"/"googlability" point of view
08:46:26 <WilliamDhalgren> hm could be, merijn
08:46:30 <numberten> anyone know for how much longer Hoogle will be down?
08:48:37 <WilliamDhalgren> I though data ... where .., data .. = .. , type ... where, type .. = .. symmetry would aid a bit in ease of use though
08:50:54 <applicative> the thought of messing with ghc is too horrible to imagine, his patch required Showing 58 changed files with 1,428 additions and 1,165 deletions.
08:51:56 <applicative> maybe I should start studying some austere version of lisp, so i can figure out the implementation...
08:52:09 <WilliamDhalgren> ha, there's even a stale trac page with just such a syntax http://ghc.haskell.org/trac/ghc/wiki/TypeFunctions/TotalFamilies
08:54:36 <applicative> It seems that as soon as people try to use this they end up needing to prove theorems. Gah.
08:57:56 <roconnor> applicative: what do you think you have been doing in Haskell this whole time.  Bwahhhaaa.
08:58:30 <Twey> Haha
08:58:45 <Twey> That does seem like a pretty evil extension, though
09:01:21 <applicative> Bwahh indeed, roconnor
09:02:25 <applicative> I was worrying about this 'backpack' system, but it too is a little opaque. edwardk seems violently opposed
09:02:54 <roconnor> having not looked at it all, it sounds reasonable.
09:03:29 <applicative> it sounded great til edward started freaking out on reddit, but maybe I misunderstood that too
09:07:48 <robde> can I somehow add multiple cases for different patterns for a function in a let expression in ghci?
09:08:14 <numberten> is there a safe way of running a m () every x seconds? I've been playing around with  repeatedTimer :: IO () -> Delay -> IO TimerIO, but the action I'm looking to run isn't an IO action
09:08:30 <scshunt> what is it if not an IO action?
09:08:54 <robde> ah, found it out; the good old semicolon :)
09:08:57 <applicative> > let f [] = 4; f (x:xs) = 5 in f [1]
09:08:58 <lambdabot>   5
09:09:31 <roconnor> robde: you can also use approprite whitespace
09:09:44 <roconnor> oh wait you said in ghci
09:09:46 <applicative> roconnor: in ghci?
09:10:01 <applicative> well you can do that too with the multiline syntax
09:10:19 <numberten> robde: it's a newtype Monad wrapping ()
09:10:39 <robde> numberten: ?
09:10:42 <applicative> why would it wrap (), there's not much there...
09:11:19 <applicative> newtype F a = F {getF :: ()}
09:11:49 <numberten> it's a stateT record IO
09:11:52 <numberten> robde
09:11:56 <dropdrive> Is hoogle still a 28MB download for everyone? :(
09:12:09 <edwardk> applicative: i'm not violently opposed to backpack. i'm violently opposed to giving up the confluence of instance resolution to get it.
09:12:28 <edwardk> applicative: you can derive a variant of backpack that preserves instance resolution, but it comes at the cost of orphan instances.
09:12:29 <applicative> edwardk: oh is that not necessary then
09:12:45 <edwardk> applicative: which means that you need to incorporate yet another mechanism to make it so you can recover their power
09:13:10 <ocharles> what does 'confluence of instance resolution' mean?L
09:13:11 <edwardk> applicative: that makes backpack fairly complicated to implement correctly, and i worry that the approach in practice will be to just piss all over instance resolution, because it is easy
09:13:20 <applicative> at the cost of losing the possibility of orphan instance, you mean?
09:13:21 <edwardk> and we'll get a situation that is worse than the status quo
09:13:27 <edwardk> yes
09:13:35 <applicative> hm.
09:13:38 <Twey> What is this ‘backpack’?
09:13:48 <ocharles> Twey: http://www.reddit.com/r/haskell/comments/1id0p7/backpack_retrofitting_haskell_with_interfaces/
09:13:51 <applicative> http://www.mpi-sws.org/~skilpat/backpack/
09:13:53 <edwardk> backpack is a project by scott kilpatrick to layer a module signature system on haskell
09:14:03 <applicative> ... which sounds great ...
09:14:09 <gertc> hpaste maintenace?
09:14:22 <applicative> lpaste.net gertc
09:14:31 <gertc> thx
09:14:33 <edwardk> it has some serious issues though. confluence of instance resolution is one, another is that the module signatures have to be _exact_ matches. so if you write foo = 12 in a module with foo :: Int as the signature in the signature file, it will _fail_
09:14:39 <roconnor> wouldn't we replace Map, Set, etc. with ML-style functors?
09:14:42 <chal> How can I write (\x -> n `mod` x == 0) in pointfree style?
09:14:45 <edwardk> because the inferred type is more generic
09:15:05 <edwardk> roconnor: and give up the mtl, yoneda, codensity, and 70% of my code. sounds awesome
09:15:12 <applicative> @pl f x = eq (mod n )x o
09:15:15 <lambdabot> f = id (fix (const (flip (eq (mod n)) o)))
09:15:16 <lambdabot> optimization suspended, use @pl-resume to continue.
09:15:16 <edwardk> roconnor: i'll be off writing another language if that happens
09:15:18 <ocharles> chal: I wouldn't
09:15:18 <applicative> @pl f x = eq (mod n x) o
09:15:21 <roconnor> edwardk: do they also turn into ML style functors?
09:15:21 <lambdabot> f = id (fix (const (flip (eq . mod n) o)))
09:15:21 <lambdabot> optimization suspended, use @pl-resume to continue.
09:15:29 <quicksilver> chal: (==0).(n`mod`)
09:15:37 <ocharles> chal: leave that pointful, it's much more readable
09:15:44 <applicative> haha, quicksilver is a much better optimizer
09:15:49 <quicksilver> that's just about on the borderline of readable, for me.
09:15:50 <WilliamDhalgren> roconnor, from the paper, seems they think their mixins are quite different from functors
09:15:58 <Twey> ocharles, applicative: Thanks
09:16:10 <chal> ocharles: quicksilver ah, ok, was just wondering if it could be made clearer that way
09:16:20 <quicksilver> I would normally use the explicit lambda but I might possibly consider the pointfree if it worked well with other code
09:16:37 <quicksilver> [e.g. if I had other code using the (n`mod`) section, so there is a common pattern.
09:16:40 <quicksilver> ]
09:16:49 <applicative> well edwardk  at your rate of module construction, i'm somehow not too worried ;) ... its that the result will be unsound
09:17:01 <edwardk> roconnor: right now it is very easy in haskell to write code that works very generically in a lot of different contexts. we don't usually bake the classes for the dependencies on arguments of a data type into the data type in haskell. it is inimical to the tools we have for working generically, Set, Map, etc. move the instances to the call site. backpack is a great solution for an ml-like language, but naively applied to haskell
09:17:02 <edwardk>  it is a terrible idea.
09:17:13 <savask> Hello. How do I read documentation which I have installed with haskell-platform-doc package?
09:17:44 <jhance> savask: Most distros would install to /usr/share/doc
09:19:28 <Twey> Hmph.  How is it that people consider things like (== 0) . (n `mod`) to be ‘borderline readable’?  That's as obvious as code gets, to me
09:20:23 <lingxiao> hi all: what in your mind is a good incremental parser library/tutorial to study for someone just approaching the subject?
09:20:59 <tikhonjelvis> Twey: it depends on how much Haskell you've done, I suppose
09:21:04 <tikhonjelvis> but I also think that code's pretty readable
09:21:09 <Twey> tikhonjelvis: quicksilver has done more Haskell than I have
09:21:09 <joehillen> lingxiao: https://www.fpcomplete.com/school/attoparsec
09:21:15 <Twey> Hence my confusion
09:21:32 <joehillen> lingxiao: I just did that tutorial, and now I have a working parser
09:21:51 <lingxiao> joehillen : thanks a lot! I'll take a look
09:22:02 <applicative> Oh i see, this is the problem with Set & co, I get to give my Ord instrance
09:22:03 <edwardk> i often use these constructions in one module instantiated at wildly different types. the ml functor "solution" isn't a solution. i can't polymorphically recurse through an ml functor
09:22:03 <edwardk> it is a strictly weaker construct than the status quo
09:22:04 <roconnor> well, this has given me a new perspective on type class instances.   Here I thought they were simply a type inference mechanism.
09:22:04 <roconnor> well, value inference mechanism
09:22:04 <edwardk> ocharles: confluence of instance resolution: If I get two Ord Int dictionaries from two different parts of my code, they are the same.
09:22:04 <applicative> savask I always do "locate Control-Monad" ... ;)
09:22:04 <savask> jhance: Yeah, I see some libghc-* things there.
09:22:05 <edwardk> roconnor: confluence is at least as important as the simple automatic dictionary plumbing mechanism.
09:22:05 <edwardk> scala just pretends they are about plumbing values
09:22:06 <applicative> "locate Control-Monad.html" ... ;)
09:22:06 <edwardk> all of scalaz pretends to have confluence, so almost everything in it is trivially subverted by violating that expectation
09:22:06 <savask> applicative: Nothing, haha
09:22:06 <jhance> savask: Your distro probably has something to list files installed by a package
09:22:06 <edwardk> the scala containers have to use less efficient algorithms and inherently rely on object equality and hashing to compensate for it in other places
09:22:07 <savask> jhance: It must, but I thought there is a tool to read docs in haskell-platform :-P
09:22:08 <applicative> edwardk: can you say why scala must do this, I'm still trying to imprint the difficulty
09:22:08 <jhance> savask: Theres stuff like hoogle but thats more for searching through functions and stuff... To read docs you just read the html files
09:22:09 <jhance> savask: Do you not have a folder like /usr/share/doc/ghc-7.6.3?
09:22:21 <applicative> savask: the docs are html files. they will be in something ../share/doc/ghc/html/libraries..
09:22:34 <lingxiao> edwardk : can I ask you a question about machines when you have a moment?
09:22:35 <ocharles> edwardk: ah, ok
09:22:44 <Twey> But for me the only way that could possible become more obvious is if the pipeline went left-to-right
09:22:47 <Twey> possibly**
09:23:00 <lingxiao> rconner: sorry to butt into your conversation w/ ed
09:23:02 <quicksilver> Twey: sure. You're right. But not everyone agreeds.
09:23:05 <WilliamDhalgren> edwardk, there were a number of texts previously that strived to get first class modules with signatures, using some extension of existing haskell faculties. think oleg offered a typeclass encoding for functors, and there was an older ghc hq suggestion on getting modules and unifying records and classes with them. This seems to go the other way, adding a totally separate system on top of modules and classes etc.
09:23:10 <tikhonjelvis> eh, I think the right to left order is better because it's consistent with the normal function style
09:23:23 <savask> jhance: There is a folder ghc-doc as well.
09:23:30 <quicksilver> Twey: I find that very clear but I, personally, always have to think if I see a section of (.)
09:23:39 <edwardk> applicative: build two sets in scala, there is no guarantee they share an ordering, so the only way to union them is to take each value from one and insert it into the other, this is asymptotically slower than a hedge union
09:23:42 <quicksilver> Twey: h . (flip (f.)) . g
09:23:45 <savask> applicative: I see, just the main part was in finding those html files.
09:23:45 <tikhonjelvis> e.g. I would much rather go from f (g x) to f . g than g >>> f or whatever
09:23:54 <quicksilver> Twey: that's what I meant by close to the border
09:24:08 <jhance> savask: What distro are you on?
09:24:21 <savask> Debian
09:24:21 <applicative> edwardk: yes, I see.  I wasn't seeing that it's crucial that its Set, which requires some-order-or-other
09:24:31 <edwardk> WilliamDhalgren: i don't have an objection to backpack in general. i have an objection to losing confluence of instance resolution
09:25:05 <savask> jhance, applicative: Thanks, I have found docs for the needed package in ghc-doc folder :-)
09:25:06 <edwardk> applicative: the problem is that the instance is moved entirely to the use site, not carried around in the set constructor. This means that any of the accessors for working with set need to get the correct Ord instance.
09:25:20 <edwardk> if you lose confluence you can go _looking_ in the set using the wrong Ord instance.
09:25:28 <edwardk> it leads to more brittle code and less canonical constructions
09:25:38 <edwardk> and in many places it leads to the inability to write the code correctly at all
09:25:42 <edwardk> monad transformers for instance
09:25:58 <edwardk> a monad transformer relies on the fact that i can lift a dictionary up for working with a smaller part of the monad over the larger thing
09:26:02 <applicative> savask ah good
09:26:35 <applicative> savask: cabal install -ing things will produce documentation under .cabal/share/.. or the like, if you have it set to document things
09:26:37 <edwardk> but now i can pass bad instances around all over the place, and i start needing a vocabulary for talking about which dictionary that has the same type i want to plumb in, when the choice is ambiguous.
09:26:39 <thoughtpolice> yeah. Ur/Web does something like this where you can specifically control instances and where they're used, if you want (or let them be inferred.) the problem is that then instances become a question of scope
09:26:43 <thoughtpolice> not just if my program compiles
09:26:52 <edwardk> this already happens in ghc with implicit params in some limited situations, but they are obscure
09:27:04 <thoughtpolice> which is awful. like i don't know how the auto instance selection works if i import to instances of 'Ord Int' or whatever
09:27:09 <edwardk> thoughtpolice: exactly. i've written a lot of code with these in scala. it is terrible.
09:27:10 <thoughtpolice> *two
09:27:12 <Twey> quicksilver: I agree on the (.)-sections.  Sometimes I prefer fmap instead.
09:27:15 <thoughtpolice> it's highly scary
09:27:29 <thoughtpolice> in practice i almost always elaborate the dictionary argument and pass it explicitly to avoid that
09:27:40 <thoughtpolice> but then you're just *undoing* a transformation the compiler was doing for you!
09:28:10 <applicative> it does seem awful.  idris has this, maybe he knows better?
09:28:11 <thoughtpolice> it's a useful feature but it's very unnerving to wield, like bad things are waiting around the corner
09:28:16 <savask> applicative: No, I think I didn't. I need offline docs only because something had happened to hoogle, but I hope that won't last long.
09:28:23 <applicative> savask: https://www.fpcomplete.com/hoogle
09:28:25 <Twey> quicksilver: For me, so long as you can read from right to left building up a single value as you go, it's fine; dot-sections tend to require me to start thinking more than one argument ahead, which removes the nice linearity
09:28:29 <applicative> someone should put that in the header for the channel, so i can stop pasting it
09:28:29 <edwardk> applicative: personally i like having yoneda, the mtl, decent performance for containers, the ability to lean on confluence to preserve API invariants for something like a heap so I can make it foldable, etc.
09:29:25 <edwardk> i'm not willing to give them up to get a weak form of ml functor, not when we don't have to
09:29:36 <savask> applicative: Thanks, now I'm saved :-P
09:29:36 <WilliamDhalgren> edwardk, then, is this really essential to the backpack proposal? I mean they left the classes as future work entirely, and only mentioned requiring explicit controll over instance import/export offhand
09:29:36 <edwardk> and not when it is a hell of a lot of work to switch to that system and its worse than the status quo
09:29:47 <thoughtpolice> i'd also rather not give up instance confluence IME, i think.
09:29:52 <applicative> edwardk: yes, i think i'm with you.  it is the orphans that are the nightmare in all this
09:29:52 <Twey> thoughtpolice: Aren't instances already a matter of scope?  The only difference is that you can only have them at module scope.
09:30:01 <WilliamDhalgren> abs
09:30:15 <tikhonjelvis> Twey: You can't control how instances get exported and imported
09:30:17 <edwardk> WilliamDhalgren: Scott Kilpatrick came out and gave a talk at Harvard. I went through the problems with the approaches he proposed for dealing with classes and instance resolution and it was clear that had given very little thought to the consequences of the loss of instance resolution confluence.
09:30:22 <tikhonjelvis> so you can't limit them to a single module
09:30:23 <quicksilver> Twey: FWIW it's also harder to read if the sections contain badly overloaded terms
09:30:34 <quicksilver> Twey: because then it's harder to do type inferences as you go along
09:30:44 <Twey> quicksilver: Yeah, this is true
09:31:23 <thoughtpolice> Twey: because you can't control imports/exports, in practice lots of instances just come with the class/data type you're using. it's whole-sale if you're manually passing around instances, you will get into significantly weirder scope situations
09:32:46 <applicative> it took me a while to get accustomed to this feature of instances
09:32:46 <edwardk> WilliamDhalgren: i went home and worked out a system that i think preserves confluent but it makes it even _more_ complicated, and so i fear backpack, because the "easy thing" to make work is very very much the wrong thing.
09:32:59 <edwardk> WilliamDhalgren: without classes it is an interesting system for a trivial language.
09:33:33 <edwardk> with classes the naive solution proposed is terrible
09:33:35 <Twey> quicksilver: But I wrote the following function for someone the other day, which I thought was fairly straightforward (especially given that it had a name), and they found it unreadable: extractPrefix p = uncurry ((>>) . guard) . (on (==) (map toUpper) p *** return) . splitAt (length p)
09:33:43 <Twey> quicksilver: So I've been questioning my assumptions a bit
09:34:05 <companion_cube> edwardk: do you think ML functors make containers slower?
09:34:11 <applicative> classes and instances are a really strange language feature, the more one thinks about them.
09:34:12 <edwardk> lingxiao: sure. i'm a bit buried at the moment, so if i don't get back to you ping me later ;)
09:34:12 <edwardk> applicative: weird and wonderful
09:34:12 <applicative> yes
09:34:12 <edwardk> they are pretty much why i write haskell today.
09:34:12 <Philippa> edwardk: taken a look at the Backpack paper etc yet?
09:34:12 <Philippa> (I haven't, but it's up on one of my other boxen)
09:34:12 <edwardk> Philippa: i read the paper, attended the talk and spoke at length with the author
09:34:13 <Philippa> :-) Should've seen that coming. Some people get to have all the fun :p
09:34:13 <applicative> Philippa: and he's ready to rail
09:34:13 <edwardk> and then spend 2 days working on trying to patch holes in it
09:34:13 <Philippa> *nod*
09:34:13 <edwardk> applicative: hah
09:34:14 <Philippa> LMK if you'd have a way to use my own responses when I have them?
09:34:14 <edwardk> applicative: i'm trying not to mindlessly rail, but instead to let people know that it isn't a done deal and it has real issues.
09:34:14 <Philippa> I figure you're aware this is Shit I Care About
09:34:14 <edwardk> applicative: they can be fixed, but the first step to getting better is acknowledging you have a problem
09:34:41 <edwardk> companion_cube: i worry that it makes it less useful. i refuse to import Data.Map 50 times for 50 different uses in a module.
09:34:54 <companion_cube> ah, sure
09:34:55 <edwardk> It also would destroy polymorphically recursive use of Data.Map in another class
09:35:05 <edwardk> you cannot polymorphically recurse through ml functors.
09:35:27 <companion_cube> maybe with first class modules, but that's clumsy
09:35:29 <Philippa> edwardk: having not thought too hard in a while, is that a generative vs applicative thing, or something else?
09:35:51 <Philippa> oh, right, you'd need a runtime instance/structure rep anyway
09:36:30 <Philippa> (which, yes, Haskell pretty much needs to accept will be necessary or everyone'll go "you just broke all the interesting typing!"
09:36:30 <Philippa> )
09:37:04 <lingxiao> edwardk : yup thanks for responding, I see there's lots going on haha. Question: is it possible to create a circular topology in machines, where process 1 awaits input of type a from one end of a y, yield a to process 2, process 2 sends a to b. then yield b back to process 1. Process 1 then awaits b from the other end of a Y
09:37:12 <edwardk> companioncube: the moral equivalent of: data Maps k a = Maps (Maps (k, k) a) (Map k a) -- cannot be written with the 'ml functor' version.
09:37:15 <lingxiao> It's a bit convoluted..
09:37:21 <edwardk> Philippa: backpack has applicative semantics. thats fine and works pretty well.
09:37:38 <Philippa> *nod*. Just the polyrec => first-classness, then?
09:37:41 <edwardk> lingxiao: it can be done but it needs a bunch of stuff that pchiusano hasn't put in get for working with sources/sinks.
09:37:42 <WilliamDhalgren> edwardk, does the original mixml have analogous problems? just searching through the extended paper on it mentions it using "linear reference types in order to ensure that all term components of a module are defined once and only once.", not sure if that relates...
09:39:09 <Philippa> (disclaimer: I should AFK shortly, I am having an Interesting Week)
09:39:17 <edwardk> mixml doesn't have classes/instances. the issue never rears its ugly head.
09:39:26 <edwardk> Philippa: remind me to talk to you about propagators later
09:39:38 <edwardk> some time when i'm not stuck typing replies as fast as i can ;)
09:39:42 * applicative tries to think of some completely new line of discussion to distract edwardk 
09:39:59 <edwardk> applicative: =P
09:40:10 <applicative> it surprises me that spj and simonm would be going with this scheme if it basically rests on not thinking through the peculiarities of classes
09:40:52 <lingxiao> edwardk: Ah ok thanks!
09:41:46 <josephle> what is this about mixml?
09:41:47 <byorgey> applicative: despite what some may think, the simons are not omniscient.
09:42:07 <applicative> byorgey: perish the thought!
09:42:09 <Philippa> applicative: if something appears to rest on /not having to/, that can be attractive
09:42:33 <Philippa> also, having them involved is an open invitation to yell if it's not Right Enough - that helps
09:44:48 <WilliamDhalgren> maybe kilpatrick doesn't know much about what's the right thing to do with classes because the plan is to offload that nugget on simons :D
09:45:30 <bb010g> Is it possible to make a type with a fixed number of slots an instance of Applicative?
09:45:41 <WilliamDhalgren> josephle its about backpak, a mixml-inspired package system that might enter haskell
09:45:44 <applicative> by slots what do you mean bb010g
09:45:54 <josephle> WilliamDhalgren: ah, thanks for the context
09:46:06 <WilliamDhalgren> *backpack
09:46:17 <bb010g> I've got "data Stack a = !a !a !a !a"
09:46:18 <applicative> instance Applicative (Either a) where ... ; Either has "two slots"
09:46:35 <applicative> you need a constructor on the rh
09:46:36 <applicative> hs
09:46:44 <bb010g> But one is reserved for error, and the other for computation.
09:46:50 <applicative> data Stack a = Stack !a !a ..
09:47:25 <applicative> the Functor instance is obvious; pure a = Stack a a a a is that wrong?
09:47:51 <bb010g> applicative: Didn't think of that. Thanks.
09:48:24 <applicative> you would get <*> by laying the one with functions on top of the one with arguments, so to say
09:51:08 <xplat> roconnor: if you turn Set and Map and such into explicit functors and drop the typeclass versions, you get a programming style that is pretty similar to ML or Agda.  i don't really have all that much experience in ML, but i don't want to replicate my Agda experience with that style in Haskell.
09:51:28 <Philippa> thought: Whether your functors are applicative or generative, you effectively just parameterised all the types in the result on how they were built. Sometimes some of that info's redundant
09:51:44 <Philippa> xplat: it's worse in ML
09:52:14 <Philippa> typeclasses are /lovely/. Functors are too, unfortunately - it's filling in all the blanks on obvious stuff that isn't
09:52:24 <Philippa> you want "module inference"/"instance inference"
09:52:31 <Philippa> typeclasses give us it under the latter name
09:53:04 <xplat> also, yeah, mixins are not the same thing as functors, although there's an awkward simulation.  i think it's slightly less awkward than the simulation using newtypes is, but it's still a little awkward
09:53:40 <applicative> josephle: http://www.mpi-sws.org/~skilpat/backpack/ http://www.reddit.com/r/haskell/comments/1id0p7/backpack_retrofitting_haskell_with_interfaces/
09:55:15 <applicative> newtyping is a pain, but in the end I came around to it, since my own giving of names to constructors is just a fancy version, given that the compiler has its own view of the type
09:55:55 <applicative> all association of types with classes is mediated by users marking in this way, whether newtyping or explicitly 'defining' a type that of course the compiler already has a name for
09:57:03 <applicative> the she prepocessor had this pattern device for naming the pseudoconstructors of a newtyped thing, so you could pattern match without  a wrapper.
09:57:52 <edwardk> xplat: the issue is i immediately lose functionality from the haskell code when it comes to polymorphic recursion
09:59:11 <edwardk> I do think that confluence of instance resolution in backpack is salvageable. It just requires more thought than hiding instances or making everyone explicitly enumerate the instances in the module signature as well.
09:59:50 <edwardk> An example of a resolution, would be to allow .hsig files to name instances that they provide by putting the instance body (btw- the sig also needs to provide default signatures, not just signatures for the DefaultSignatures extension)
10:00:04 <edwardk> and then to start, disallow orphan instances entirely
10:00:10 <edwardk> then instances don't need to be infectious
10:00:20 <edwardk> you imported the data type or the class, so you get the instances
10:00:33 <edwardk> now, we can go back and address why we need orphans
10:00:50 <applicative> why do we need orphans?
10:00:57 <Philippa> edwardk: I keep wanting to just have a notion of "class that doesn't expect resolution" and crank stuff from there, but clearly that's another project entirely
10:01:14 <Philippa> but I really ought to get the hell AFK for a while
10:01:16 <edwardk> orphans come about for two reasons. one is you wanted to take and extend an existing data type you don't own with an instance for a class you don't own. instance Num a => Num (Maybe a)  -- those i can't fix this way
10:01:31 <applicative> yes
10:01:49 <edwardk> but we can make a notion of a 'mixin package' such that if you import both packages, say parsers and parsec, you get the parsec-parsers instances brought into scope
10:02:00 <edwardk> that is the subset of orphans that makes sense coherently across the entire ecosystem
10:02:18 <edwardk> this would have the _VERY_ desirable property that it fixes a huge wart for library authors today.
10:02:29 <bb010g> Are lambdabot's insults the same as sudo's?
10:02:29 <applicative> the parsec parsers instances are orphans?
10:02:55 <thoughtpolice> bb010g: they were taken from OpenBSD, i think. not sure if it was sudo specifically
10:03:00 <edwardk> that is that if i write a library i have a fundamental tension between being complete in the instances i supply, by supplying all instances for every data type and class that already exists on hackage when i wrote my package
10:03:05 <thoughtpolice> (don was a big OpenBSD user back then)
10:03:05 <applicative> wait I think i'm getting it.
10:03:42 <edwardk> or supplying a minimal set of dependencies
10:04:05 <applicative> edwardk: yes, the tension is familiar
10:04:08 <Philippa> applicative: yeah, they're orphaned from parsec
10:04:41 <edwardk> by punting the instances that are for types i dont depend upon into a 'mixin package' i can supply them all, but my users don't incur the extra dependency until they need both
10:05:20 <edwardk> this minimizes the sets of dependencies for _everyone_ and removes the tension for library authors
10:06:25 <edwardk> but it does take an already complex proposal (backpack) which has non-trivial interactions with cabal and the existing ecosystem, and makes it even more complicated
10:06:25 <applicative> this is a suggestion for present haskell apart from the backpack type nonsense?
10:06:31 <edwardk> and requires more interaction with ghc internals
10:06:32 <xplat> edwardk: the tension you're describing seems like a slightly higher-level variant of the expression problem
10:06:34 <edwardk> i have had this sort of mixin module notion in my head for ~5 years now
10:06:36 <dcoutts> edwardk: I had a half-day visit + discussion with the backpack people about the interaction with Cabal about a year ago at MSR, all quite interesting
10:06:37 <edwardk> xplat: the difference is it is resolvable tension in this case. you just need to acknowledge its existence and options become available toyou
10:06:40 <edwardk> dcoutts: i spoke with scott kilpatrick for an hour or so after he came out to harvard to present backpack and i admit i was a bit of an ogre during his presentation throwing up all sorts of issues he hadn't considered
10:06:40 <applicative> it would be nice if a class definer could somehow make a generic definition, so that I could then 'derive' it, rather than writing an instance; then ghc could recognize instances it had derived itself
10:06:41 <applicative> as it is it doesn't recognize its own instances
10:06:41 <applicative> I mean, if I derive functor in two modules, it declares an overlap if I import them both
10:06:54 <edwardk> applicative: sure there is a whole other set of haskell language tensions when it comes to making finer grained class hierarchies requiring polynomially more work for end-users, etc.
10:07:17 <applicative> yes, there is an inbuilt polynomial unpleasantness...
10:07:19 <Saizan> would the mixin package need to be defined as a sub-library of the package with the class (or type)?
10:07:21 <xplat> indeed.  i'm not sure how well the mixin proposal scales (O(nm) modules and each one with at least two people with 'first claim')
10:07:22 <edwardk> but the mixin module issue could at least make ditching orphans to preserve instance resolution tenable.
10:07:31 <xplat> but it's at least something.
10:08:00 <bgamari> joeyh, have you considered moving git-annex's source into src/
10:08:00 <xplat> *O(nm) packages
10:08:08 <bgamari> excellent timing for a netsplit
10:08:11 <edwardk> Saizan: the way i'd see it, it'd probably have to be some other notion that the package dependency tracker in cabal/hackage would need to understand, so that if it picks up a set of packages, it also incurs the mixin dependencies, and then ghc would have to know how to bring them into scope
10:08:26 <edwardk> xplat: we already have them. they just fail to come into scope most of the time
10:08:53 <dcoutts> edwardk: actually we had a chat about how this would translate into Cabal stuff, and what would be automatic and what manual
10:09:07 <edwardk> xplat: there is a whole cottage industry of folks who have little foo-bar packages for instances the original package authors didn't think were important enough to incur a dependency on
10:09:12 <xplat> edwardk: right, which is why 'at least it's something'.  it may still be a mess, but at least it would be a mess with some organization on top
10:09:15 <dcoutts> edwardk: I've not read their submitted version so I don't know if they cover that part
10:09:43 <edwardk> dcoutts: as far as i'm concerned if it relies on 'instance hiding', the loss of confluence of instance resolution would be damning.
10:10:32 * dmwit . o O ( data-default{,-class,-base,-instances-containers,-instances-dlist,-instances-old-locale} )
10:10:32 <edwardk> hence why i'm explaining that its not that simple. you popped in about 3/4ths of the way through the explanation of 'why that destroys the utility of haskell as it is written' ;)
10:10:53 <edwardk> there is a lot of chatter on reddit on the topic right now as well
10:10:53 <dcoutts> edwardk: I'm not really in a position to comment about the class/instance stuff, we didn't talk about that, just about how this would affect Cabal
10:10:54 <applicative> dcoutts: my impression was that edwardk 's thought was that a nice module system would be awesome for something like Cabal; only a 'nice module system' makes no sense in the presence of type classes
10:10:54 <bgamari> joeyh, have you considered moving git-annex's source into src/ ?
10:11:07 <dcoutts> edwardk: e.g. just because some package can provide interface foo, doesn't mean Cabal should just decide to pick up package Foo-alt as the provider of that interface
10:11:10 <edwardk> dmwit: the alternative is what we have now, you have a handful of packages it depends on, users bitching about adding or removing from the list, etc.
10:11:10 <dcoutts> things like that
10:11:23 <bgamari> joeyh, It would do quite a bit for making the repository easier to browse
10:11:25 <dmwit> I am not complaining.
10:12:00 <dmwit> Package maintainers have a hard enough job without my uninformed whinging. =P
10:12:15 <edwardk> dmwit: i get on average 2 complaints a week from users complaining that i depend on too many or too few things for comonad or semigroups, or some other package. nobody can agree on which way i should go, but they all want to complain =P
10:12:37 <applicative> edwardk: yes, this is what clearly needs a solution.
10:12:56 <Saizan> seems like if we get GHC to do mixin modules we could also get it to specialize datatypes ala C++ templates
10:13:11 <edwardk> dmwit: in the end i've just taken to trying to let each package i maintain develop a clear 'perspective' on what its manifest goals are. so lens has a different policy than say, tables, and i just try to be true to each package
10:13:52 <edwardk> dcoutts: sure, but once backpack tries to tackle instances, the current approach it is taking blows up. that was the subject of my objection to scott kilpatrick
10:14:29 <edwardk> dcoutts: and the only correctness-preserving extension to it that i can come up with that doesn't blow up, blows up into a lot more integration work =P
10:15:03 <dcoutts> edwardk: I'll have to read and get my head around that problem
10:15:07 <edwardk> that hiding of local instances leads to problems has been known for years, chung-chieh shan wrote about it 5-6 years ago
10:15:27 <edwardk> thats why we can't write instances in let bindings, can't hide them on import, etc.
10:15:31 <xplat> the main problem with instances is that open-world assumption, which requires a completely different approach to compartmentalization than closed-up things that know what they depend on
10:15:33 <danharaj1> edwardk: basically in the presence of instances, programs aren't composable because of the open world, correct?
10:16:20 <Philippa> danharaj: not the interesting way, anyway - you have to handle the interface between programs
10:16:31 <Philippa> which is, uh, kinda the point of the entire exercise
10:16:38 <edwardk> danharaj: the issue is you can't hide them or you lose confluence of instance resolution, so every API that uses them for correctness starts to silently fall apart and we start needing vocabulary for things we don't have to talk about now. e.g. we don't care which dictionary for Eq Int you get when you ask for one .. right up until we get local instances and instance hiding.
10:16:52 <danharaj> mm
10:16:52 <edwardk> then you start needing a vocabulary for how to plumb _this_ instance around
10:16:59 <xplat> the idea of hiding or explicitly importing instances is not a solution, it's an open subproblem waiting to mint a PhD
10:17:02 <edwardk> this already happens in some corner cases with implicit params
10:17:10 <thoughtpolice> local instances are where things will become really problematic
10:17:10 <Philippa> *nod*. You're always allowed to say "your Eq is not my Eq", but if you want them to coexist then you better be able to show coherence
10:17:36 <WilliamDhalgren> UHC has local instances, right?
10:17:36 <Philippa> local instances will... well, fuck any attempt to do that sideways because instances have no existance separate from the type tuple they're bound to
10:17:39 <danharaj> edwardk: Is there a good categorical semantics for non-local instances anyway?
10:17:52 <thoughtpolice> Philippa: yes :)
10:18:00 <Philippa> (so, does my choice of language at least insulate me from QotW?)
10:18:34 <edwardk> in fact, you can force it by making a dictionary type. data Dict p where Dict :: p => Dict p; and putting implicit params in it. Dict (?x :: Int)  -- now open two of them in a local scope which ?x does it evaluate to? it is implementation dependent. If we have non-confluent instance resolution then _every_ instance picks up this problem, not just some corner case involving overlapping instances and/or implicit params.
10:18:36 <WilliamDhalgren> yup, here they are, in a haskell, http://www.cs.uu.nl/wiki/bin/view/Ehc/UhcUserDocumentation#3_8_Local_instances
10:18:44 <Philippa> now, one solution to that is to have a notion of instances that are tied to more than that tuple? But then you lose a lot of the neat inference properties or at least have to set boundaries for them and have all the paperwork visible
10:19:01 <edwardk> WilliamDhalgren: and they are a dumb idea there too
10:19:13 <Philippa> ...I was supposed to be going for a shower, amongst other things. I am too familiar with this crap...
10:19:30 <danharaj> Clearly we need World polymorphism. :P
10:20:41 <edwardk> Philippa: i don't really want to give up the very properties that make haskell not suck to get ml-like modules in a slightly "easier" way. =P
10:20:59 <xplat> the UHC approach does not sound like it works
10:21:15 <edwardk> xplat: it doesn't, but its an obscure feature in an obscure compiler that hasn't been used in anger.
10:21:18 <thoughtpolice> edwardk: oh yeah, i hadn't considered using Dict with an implicit param, that's tricky. i'm not even sure how name shadowing etc comes in there
10:21:30 <applicative> "The implementation still has some quirks when abstracted dictionaries are involved. Sticking to ground instances like in the examples avoid this."
10:21:33 <edwardk> thoughtpolice: you can make up a whole record system with that btw.
10:21:39 <thoughtpolice> also, yeah, can we just not do anything to instance resolution? i enjoy reasoning about my code locally
10:21:49 <thoughtpolice> or at least not break it :(
10:21:49 <WilliamDhalgren> edwardk, so your solution boils down to having orphaned instances in scope iff both the datatype  and the class are in scope only?
10:22:17 <xplat> applicative: i don't think the way quantified constraints are handled is sufficient either
10:22:50 <xplat> applicative: it seems to be mostly suited to cheap tricks like in the example ...
10:22:50 <Philippa> edwardk: I do have plans to recover it :-) But yes. Anyway, I *really* have to go now
10:23:05 <Philippa> like "my girlfriend's about to start driving my way and I still need a shower" gtg
10:23:12 <edwardk> WilliamDhalgren: the solution is that if we really want backpack, a sound and confluence-preserving extension to the language is to ule out unstructured orphans complete, and then reintroduce a limited form of orphan that is brought when both packages are depended upon. this means that the lub of incurring a dependency on two packages isn't necessarily the two packages, but now can include a mixin.
10:23:30 <edwardk> er is to rule of unstructured orphans completely
10:23:30 <Philippa> edwardk: WFM
10:23:45 <edwardk> Philippa: kk. go run =)
10:23:51 <Philippa> instance (Package1, Package2) => ...
10:24:06 <danharaj> edwardk: I was thinking that Lawvere theories might have something to do with classes and instances.
10:24:22 <edwardk> danharaj: knock yourself out. i'm purely thinking operationally here
10:24:29 <danharaj> ahh
10:24:31 <xplat> yeah, orphans as they are already don't work well
10:24:43 <edwardk> just in terms of the nuts and bolts of the engineering and the social issue of how to balance these tensions
10:24:57 <xplat> danharaj: World polymorphism is also what i think is required here
10:25:48 <danharaj> edwardk: My hope is that clarifying the theoretical underpinning of classes would make some improvements 'obvious'.
10:26:12 <danharaj> edwardk: also the idea that Haskell has a denotational semantics that no one has written down seems more remote every time GHC gets extended :P
10:26:24 <xplat> danharaj: not sure where Lawvere theories would come in
10:27:20 <xplat> danharaj: 'i have found a wonderful denotational semantics for GHC Haskell which this margin is too small to contain'
10:27:27 <danharaj> xplat: A class definition sort of looks like a lawvere theory.
10:27:30 <danharaj> I think.
10:27:34 <danharaj> I haven't thought too hard about it.
10:28:19 <stelleg> xplat: :)
10:28:55 <applicative> edwardk: when you speak of " a limited form of orphan that is brought when both packages are depended upon" who writes this additional material
10:30:34 * applicative does his best thinking during net-splits
10:30:42 <mvj4> [pipes-concurrency] is there some nice way to model addressable consumers using pipes-concurrency?
10:31:28 <mvj4> (i.e. a consumer should only read if it is being adressed)
10:31:54 <mvj4> I'm currently using a set of Input's tagged with addresses.
10:32:42 <applicative> hm, mj4 you might write to the list https://groups.google.com/forum/#!forum/haskell-pipes I'm not sure I'm following
10:33:27 <applicative> new levels of pipe interface chaos were just announced today!
10:33:43 <mvj4> oh? is it 4.0?
10:34:00 <mvj4> applicative: thanks.
10:34:06 <applicative> the chaos is about 4.0, which will presumably take a little longer than we were thinking ...
10:34:48 <applicative> mvj4: Tekmo will surely grasp and answer your question immediately, which must be independent of this business...
10:37:21 <applicative> after every net split there is a copumpkin
10:37:33 <prophile> @hoogle (Alternative f) => Cofree f a -> f a
10:37:33 <lambdabot> Warning: Unknown type Cofree
10:37:33 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
10:37:33 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
10:37:44 <prophile> :|
10:37:50 <cdk> applicative: where is this announcement?
10:38:11 <mvj4> pipes - https://groups.google.com/forum/#!topic/haskell-pipes/t2A0U3sF1CM
10:40:23 <applicative> cdk which announcement
10:40:45 <applicative> oh the one mvj4 mentioned , its just internal fretting, not an announcement
10:42:05 <applicative> its a scheme to keep us from forever writing 'forever $'
10:43:05 <thoughtpolice> "* Remove the `()` argument from all the `Producer`s"
10:43:08 <thoughtpolice> sounds good to me!
10:43:27 <applicative> yes, but I started wanting it back in no time ...
10:43:28 <applicative> ha
10:43:58 <applicative> it amazing how much trouble it all, but maybe i'm lacking in something, eg. IQ
10:44:31 <applicative> the main problem he seems to be thinking of is performance, or communicating with the optimizer
10:44:37 <applicative> something like
10:44:58 <applicative> produce-three-things >-> forever munge >-> forever glop >-> printer
10:45:01 <applicative> is not so great
10:45:45 <applicative> we want produce-three-things <//<\\<<\\ munge <//<\\<<\\ glop >-> printer
10:46:09 <applicative> where the part that comes before printer is nowhere recursive
10:46:49 <applicative> or anyway, that is part of it, as I understand it
10:47:51 <roconnor> xplat: My experice with canonical structures in Coq has been relatively pleasant.  However, I did have George Gonthier encorcing something like confluence.
10:48:28 <xplat> applicative: where was the new chaos announced?
10:48:40 <applicative> https://groups.google.com/forum/#!topic/haskell-pipes/t2A0U3sF1CM
10:49:21 <applicative> it isn't about the types or anything, just what the preferred combinators should be, what sorts of things we should be writing for libraries..
10:50:36 <edwardk> applicative: the additional material would be a package on hackage, right now 'who is privileged to write a package' is an open question. i don't propose a solution to the social problem, merely the technical one
10:50:59 <applicative> edwardk: yes, that's what I figured.  there is a bit of a social problem...
10:51:27 <edwardk> applicative: my original motivation for exploring the consequences of backpack was to use it in the negative, to say hey this would be a nice system, but it leads to all of these other concerns, and the only resolution to those concerns i can come up with that doesn't suck is X. what are the consequences of X.
10:51:49 <edwardk> its 2-3 moves ahead. things get pretty murky that far out ;)
10:52:12 <applicative> maybe the point is that there is a distinctive kind of module, I cant make an orphan alone, I have to import it
10:52:41 <applicative> from another package which just does orphans so to speak
10:52:42 <edwardk> personally i worry that it is not worth the cost it would take to resolve all of these issues to get back to a state roughly equivalent but 5 steps to the left of where we are now.
10:53:14 <edwardk> but i have to articulate this point in the design space to showcase why the naive solution is very very naive
10:53:37 <edwardk> lest i be seen as not trying to constructively contribute and written off as 'just a hater' or something ;)
10:53:52 <applicative> youre just a hater edwardk
10:54:28 <applicative> it seems crazy, but a ban on orphans plus a special orphans-handling kind of package seems not so insane
10:54:43 <edwardk> I really want haskell to be the best language it can be, and if I just rolled over because a bunch of people put forward a proposal and there was no counter-argument, I'd be doing the community a disservice
10:54:58 <applicative> there wouldn't be too much conflict between orphan-handling packages, as there is when we are all secretly writing binary instances for Vector
10:55:21 <applicative> you're not really a hater edwardk !
10:55:25 <edwardk> applicative: personally i always just figured i could use it for a post-haskell language, where it can have been part of the ecosystem since birth.
10:55:49 <djahandarie> Nice job with Ermine btw
10:56:02 <edwardk> but the 'hackage onion' problem has been weighing on my mind more than most for a long time
10:56:05 <applicative> haskell seems not too bad at making itself an ok post haskell language
10:56:09 <djahandarie> I'm somewhat surprised you got green-lit to open-source that
10:56:17 <edwardk> djahandarie: now we just have to finish up the haskell-based compiler
10:56:33 <edwardk> djahandarie: they said yes, so we rushed around yesterday and just made it happen =)
10:57:59 <lpaste> bb010g pasted “fourStack Monad” at http://lpaste.net/90957
10:58:07 <bb010g> I'm trying to make a four-register stack an instance of monad as an exercise, but I can't figure out how to bind with the register limit. Is it possible?
10:58:14 <applicative> edwardk: you have a special genius for triggering madness in Chrome.
10:58:24 <applicative> it infers that the ermine haddocks are in Estonian
10:59:22 <applicative> the monad instance is going to be trouble bb010g
10:59:40 <RichyB> bb010g: it's just a 4-tuple version of the Identity monad, isn't it?
10:59:50 <bb010g> RichyB: Yes.
11:00:00 <applicative> Stack x y z w >>= f = let Stack x' x'' x''' x''' = f x ; ...
11:00:21 <RichyB> Ah, but you're going to end up with four different Stack constructors if you pass all four of x y z w into f.
11:00:22 <applicative> in Stack x' y'' z''' w''''
11:00:29 <edwardk> applicative: hah
11:00:47 <RichyB> I think applicative has it.
11:01:46 <RichyB> That satisfies left, right identity laws.
11:01:57 <applicative> bb010g: it might be easier to figure out what you're doing semantically and whether you want to do it if you do the join first
11:02:08 <c_wraith> Agh.  I can never remember this.  What's the name for set of types likes points and vectors, such that the difference between points is a vector, vectors can be added or subtracted, but you can only add a vector to a point?  I know this has a formal description somewhere
11:02:19 <dmwit> torsor
11:02:25 <c_wraith> thanks
11:02:26 <applicative> Stack (Stack a1 a2 a3 a4) (Stack b1 b2 b3 b4) ... = Stack a1 ...
11:02:42 <RichyB> I think it satisfies the associativity law too.
11:02:50 <c_wraith> I kept thinking "tensor - no, that's not right".  I was close!
11:03:34 <applicative> the simple case of this problem is the monad instance for data Double a = Double a a
11:03:44 <applicative> of course ...
11:04:33 <bb010g> I can't keep the other registers?
11:04:38 <applicative> no
11:04:56 <applicative> its the heartbreak of the monadic bind!
11:05:01 <dmwit> The complicated case of this problem are the many monad instances for data Stream a = a :> Stream a
11:05:02 <xplat> man
11:05:21 <neil___> How long is the haskell.org migration likely to last? And are the people migrating it aware that Hoogle is down?
11:05:21 <ParahSailin> is there a reason the instance of Read for Floating types requires a leading zero for numbers between 0 and 1
11:05:33 <xplat> the pipes operators *were* pretty nice, when they were introduced in the order you would encounter them in the old library
11:05:37 <applicative> bb010g: I think I'm right, but occasionally I  mix one point with another ...
11:05:59 <thoughtpolice> neil___: things are in flux, sorry. :( there are new admins now too, but none of us have access to the new server quite yet
11:06:12 <xplat> but now they'll all have to be renamed because you can't get the idea if you start with mostly >>~ and //>
11:06:26 <dmwit> I'm wrong, ignore me.
11:06:27 <applicative> hoogle is always up at https://www.fpcomplete.com/hoogle  neil___
11:06:50 <neil___> applicative: thanks, i knew that one - I'm the hoogle author so more asking on behalf of my users, I can just use it locally
11:07:00 <applicative> xplat: yes the pedagogy may get worse.  but now that I figuredout what he's saying, i'm not sure
11:07:10 <applicative> oh neil___ hi@
11:07:12 <applicative> hi!
11:07:38 <applicative> neil___: #haskell has been devoted to making these redirections
11:07:53 <applicative> the freaky thing is that the hoogle binary is what yuo seem to get if you go to that address
11:07:54 <neil___> thoughtpolice: any ETA? Anything I can do to help? I suspect the apache entry saying "this is a cgi binary" got lost
11:08:05 <applicative> ah
11:08:06 <dmwit> ParahSailin: Because Haskell itself does, probably.
11:08:09 <neil___> yeah, it serves up the binary, instead of running it
11:08:32 <edwardk> ParahSailin: bcause haskell does
11:08:34 <edwardk> > .1
11:08:35 <lambdabot>   <hint>:1:1: parse error on input `.'
11:08:41 <thoughtpolice> neil___: unsure. :( Peter Simons has access to the new servers, but i only have access to the old ones. the domain migration already happened however
11:08:48 <edwardk> :t (.1)
11:08:48 <lambdabot> Num (a -> b) => (b -> c) -> a -> c
11:08:57 <thoughtpolice> hopefully Peter will give us access today (or I can ask Ian)
11:09:07 <neil___> would be appreciated
11:09:12 * applicative prepares a Num (a->b) for his orphan mixin package
11:09:23 <ParahSailin> haskell is hardly homoiconic, why start with instances of Read
11:09:24 <neil___> i'll shove up a redirect temporarily to the FP complete one
11:09:45 <thoughtpolice> there are 5 new admins now, so hopefully we can fix this and have future problems sorted out in a timely manner
11:10:15 <dmwit> Why make the rules different for Read instances?
11:10:23 <edwardk> ParahSailin: Read and Show are intended to show valid source code representations of text
11:10:41 <edwardk> you can write all sorts of other parsers, but Read and Show were intended for that limited scope
11:10:41 <neil___> thoughtpolice: in fact i can't log in, any chance of a quick HTML upload in the hoogle directory? who can do that? (and separately, why can I no longer do that)
11:10:51 <edwardk> every time i see a 'special case' Show, i cry. =P
11:11:12 <applicative> Read and Show are really for debugging.  Haskell has the best debugging resources imaginable.
11:11:14 <edwardk> because then when i put them in a list, printing the container looks terrible
11:11:38 <Philippa> edwardk: yeah, I figure they're only permissible if they're denotationally equivalent
11:11:40 <edwardk> e.g. the error type in parsec
11:12:08 <edwardk> when i work with something containing one, i can't Show it cleanly.
11:12:11 <Philippa> yeah. Sorry, backwards compatibility and all that :-(
11:13:40 <dmwit> Anyway, talking about Show instances is orthogonal.
11:13:53 <dmwit> There's nothing stopping Read from accepting more things than Show can produce (and most instances do).
11:14:03 <icarot> Is the general good practice for writing a parser, "use applicative"?
11:14:26 <dmwit> no?
11:14:33 <edwardk> dmwit: the concern is when you go to literally parse an expression like (.1)  -- if you use the parser and its too liberal then when you build a composite read off it, it'll start admitting odd interpretations
11:14:52 <dmwit> Yes. That is a real argument; much better than the one about Show.
11:14:57 <xplat> applicative: unfortunately it seems a bit awkward to have a division between 'stateless' (meaning 'state is in the underlying monad or a proxy transformer) and 'stateful' (also have the proxy as a coroutine) building blocks and have to compose them using different operators
11:14:57 <icarot> I kinda got the "parsec considered undesirable" vibe from the typeclassopedia
11:15:07 <dmwit> And the one I was sort of half-heartedly trying to make when I said "why make the rules different for Read"?
11:15:16 <Philippa> icarot: it depends on your concerns. Applicative style can offer some libraries more opportunities to optimise. It makes matching things up against the grammar trickier sometimes though
11:15:28 <Philippa> icarot: Parsec is Haskell's answer to perl
11:15:46 <josephle> Philippa: how so?
11:15:50 <Philippa> with all the good and all the "holy hell, I put *what* in my foot?!" that implies
11:15:52 <edwardk> i tend to use Applicative combinators when i can because it gives the particular target more flexibility to optimize
11:15:56 <icarot> And the Haskell 98 tutorial (Haskell.org/tutorial) seems to like Read and Show. Meh.
11:16:02 <nabilhassein> is there a stack data structure in some library? google and hackage mostly turn up stuff about the call stack
11:16:19 <dmwit> nabilhassein: [] ?
11:16:35 <nabilhassein> dmwit: haha, that will probably work, yes
11:16:40 <Philippa> josephle: OK, so strictly speaking you want to pair it with a pretty-printing lib? But otherwise yeah, it pretty much covers perl's original problem domain for you and with room to do some incredibly filthy things if you're so inclined
11:16:43 <c_wraith> [] is sneaky that way.  It claims to just be a list, but it has all kinds of other uses!
11:17:01 <nabilhassein> but there's not some ADT only exposing push and pop? or something like that
11:17:10 <nabilhassein> really more out of curiosity, a list will certainly work
11:17:14 <dmwit> push = (:); pop = head
11:17:25 <dmwit> pop = splitAt 1
11:18:14 <byorgey> nabilhassein: not that I know of.  It's such a trivial wrapper on top of lists that no one has ever bothered.
11:18:54 <dwcook> Why is Hoogle asking me to download a bin file?
11:19:01 <dwcook> Oh, I should read the topic
11:19:28 <applicative> nabilhassein: http://apfelmus.nfshost.com/articles/operational-monad.html
11:20:16 <xplat> Philippa: honestly i always found perl regexps more composable than parsec, until you need recursion.  and lately even that's doable.
11:20:18 <dwcook> Wasn't there some standard function :: (a -> b) -> (a -> c) -> a -> (b, c) ?
11:20:59 <Lethalman> @hoogle f (Maybe a) -> f a
11:21:01 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:21:01 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:21:01 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
11:21:08 <djahandarie> @type (&&&)
11:21:09 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:21:15 <Lethalman> mh isn't there a catMaybes for foldables?
11:21:38 <djahandarie> @type (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
11:21:39 <dwcook> Where is that (&&&)?
11:21:39 <lambdabot> (a -> b) -> (a -> c) -> a -> (b, c)
11:21:44 <djahandarie> Control.Arrow
11:21:48 <dwcook> Cool, thanks.
11:21:58 <xplat> but parsec allows more abstraction, which makes its less concise syntax more bearable, and it's also better at getting data out of deeply nested matches without parsing multiple times ...
11:22:09 <djahandarie> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
11:22:09 <lambdabot> No results found
11:22:25 <notdan> Is there a way not to import instances from a module?
11:22:35 <djahandarie> @hoogle a b c -> a b c' -> a b (c, c')
11:22:36 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
11:22:40 <geekosaur> notdan, nope
11:22:48 <djahandarie> Too bad hoogle can't sub in instances like that
11:22:50 <notdan> I have two modules from different libraries and they both implement the same orphan instances
11:24:55 <applicative> nabilhassein: on the same theme, try something like this http://debasishg.blogspot.com/2013/01/a-language-and-its-interpretation.html
11:24:59 <Philippa> xplat: parsec does have the "*sigh*, do I just slap try around everything?" problem, yeah
11:25:26 <Philippa> it's definitely the old-school swiss army tacnuke of parsing though
11:25:27 <applicative> notdan: omg
11:25:38 <applicative> notdan: get rid of one them.
11:27:17 <applicative> Philippa_: I know you've been waiting for this ;) : I have revived the idiom brackets machinery from the terminally broken 'she'
11:28:17 <applicative> https://github.com/michaelt/her mankind has for so long been awaiting them
11:28:18 <thoughtpolice> neil___: sorry, was away for a few
11:29:35 <Philippa> got alet?
11:29:45 <applicative> how does that work
11:29:55 <Philippa> it's the better-named applicative do
11:30:00 <applicative> ah
11:30:07 <applicative> yeah, that would be a different plan
11:30:27 <Philippa> I think parsing's one of the better applications for it: sometimes the components were supposed to have names
11:30:28 <thoughtpolice> neil___: i think the policy ATM is to only migrate new accounts on demand, to clear out old accounts
11:31:14 <applicative> parallel monad comprehensions are sort of like 'applicative do' but the tend to want a different instance
11:31:19 <applicative> they tend
11:31:23 <thoughtpolice> neil___: i'll send an email to the new admin list to note it. when i get access, presumably i can reactivate your account quickly
11:31:39 <thoughtpolice> neil___: it's all a bit of a mess right now :P
11:32:19 <applicative> Philippa_: oh i see now, the point of calling it alet
11:33:21 <carter> xplat I am experimenting with a sort of world polymorphism in the api for a haskell lib i'm rolling out soon
11:33:44 <Philippa> applicative: right :-) Getting the 'in' clause is important
11:33:50 <carter> so that i can use different implementations
11:34:02 <Philippa> bonus points if I can have an equivalent for <$ as well (calling /that/ ado makes great sense)
11:34:27 <Philippa> I use that one in anger regularly: it's kinda turnstiley
11:35:29 <applicative> did you see the later she idiom brackets version of <$ with (| res (-blah-) |)
11:35:51 <applicative> the material unneed in the result is put in a 'comment' (-blah-)
11:36:28 <Philippa> huh, I didn't. Still not quite as nice if you've got an obvious string of what 'should' be *
11:36:35 <Philippa> (as in "I don't use /any/ of these sodding results")
11:36:59 <thoughtpolice> ugh, my grammar is terrible today
11:36:59 <Philippa> (anyone wondering why that might happen: logic programming)
11:37:00 <applicative> Plus (-char '('-) pExp (-char '+'-) pExp (-char ')'-)
11:37:16 <thoughtpolice> damn, neil just left
11:37:17 <applicative> not too readable an illustration
11:37:24 <Philippa> yeah. That's an alet case, I think
11:37:51 <applicative> Philippa: but ^^^ Plus pExp pExp is the main business, the (- blah -) material just needs to be there
11:38:21 <Philippa> *nod* sure. Give alet non-binding lines ala do
11:38:21 <erisco> I worked out the infinite cartesian product ... mostly. still a few questions I have about it ... but ...
11:39:02 <applicative> Philippa: yes, I was just interpreting the goofy symbolism for you
11:39:14 <Philippa> *nod*. Is okay, I get it :-)
11:39:25 <Philippa> similarly, = or <- are "this value matters"
11:39:32 <erisco> having that is a corner stone to the other problem I have for my parser design ... and an awesome consequence is that I can list all valid strings in a language (described by a non-left-recursive, context-free grammar)
11:39:32 <applicative> the main difficulty, that I don't then to get the operands in the order given by the operator, is not soluble this way
11:40:07 <Philippa> applicative: yeah, sooner or later you end up with a lambda on the LHS of <$>
11:41:04 <erisco> so, I can test acceptance by lookup :P
11:41:31 <erisco> in a computationally impractical way ... but what I like is that it is fundamentally simple
11:41:38 <osa1> sorry for off-topic question but, I was wondering if /r/haskell or Haskell-cafe are good places for look for Haskell internships .. I have one internship left before my graduation and I'm looking for Haskell jobs. any ideas who should I ask or where should I write for that?
11:43:33 <lispy> osa1: We're always looking for interns: http://corp.galois.com/careers/
11:44:00 <thoughtpolice> lispy: probably USA only though, right?
11:44:42 <osa1> lispy: thanks, sending you a privmsg
11:53:22 <tuque> Hi
11:53:42 <tuque> how do I iterate over a FreeT value
11:54:50 <tuque> or, how am i meant to? Say a FreeT a Identity b for some a and b?
11:56:16 <echo-boom> args <- getArgs will put all of the args in args ?
11:56:32 * roconnor sees no Traversable instance for FreeT
11:56:52 <klrr_> is it worth or suggested to learn agda?
11:57:32 <supki_> I think there is Traversable instance for FreeT
11:57:45 <supki_> (Monad m, Traversable m, Traversable f) => Traversable (FreeT f m)
11:57:47 <supki_> this
11:58:36 <tuque> i am using Ed K's package
11:58:37 <josephle> klrr_: well, what do you want to get out of agda?
11:58:45 <josephle> an appreciation for type-level programming?
11:59:16 <roconnor> ah I was looking in the wrong place
11:59:43 <klrr_> josephle: i dont really know what it is, but since i have a hard time understand FRP i would like learn something else, and i found agda while googling
11:59:48 <byorgey> echo-boom: yes
11:59:52 <roconnor> tuque: which package?
12:00:00 <echo-boom>  byorgey :/
12:00:03 <roconnor> apparently there are lots of implementations of FreeT
12:00:11 <byorgey> echo-boom: ?
12:00:19 <tuque> http://hackage.haskell.org/packages/archive/free/3.4.2/doc/html/Control-Monad-Trans-Free.html
12:00:31 <tuque> yes there are, i wonder whether i should consider a different one
12:00:39 <echo-boom> byorgey: never mind i found my problems thanks :)
12:00:43 <byorgey> ok =)
12:01:19 <roconnor> tuque: okay, you can use traverse (and friends) to iterate over FreeT.
12:01:28 <roconnor> tuque: in general traverse lets you iterate over things
12:01:46 <josephle> klrr_: agda is all about dependent-types, but perhaps byorgey can convince you of haskell's type-level programming fun
12:01:50 <roconnor> tuque: Though I'm not entirely sure what you mean by "iterate over".
12:02:11 <byorgey> doing type-level programming in Haskell is not fun.
12:02:19 <josephle> :(
12:02:24 <klrr_> what is type-level programming?
12:02:42 <tuque> roconnor: well as a start I'd like to pretty print each layer
12:03:04 <byorgey> klrr_: programming with types instead of values.
12:03:16 <tuque> with just regular untransformed Free it is easy
12:03:26 <byorgey> klrr_: when you have more and more expressive types for things, pretty soon you end up wanting to *compute* your types
12:03:32 <byorgey> that's type-level programming.
12:03:35 <robde> what is the advantage of using monoids like Sum, Product and Max instead of just sum, product and max?
12:03:59 <elliott> robde: you can use them on arbitrary tree structures with Data.Traversable, for one
12:04:08 <quchen> robde: You can pass "Sum" to a Writer monad computation for example (e.g. to count how many times a certain function is invoked)
12:04:16 <josephle> klrr_: on second thought, go ahead and learn haskell
12:04:16 <byorgey> robde: any time you want to use an operation or construction which works for all monoids.
12:04:29 <byorgey> like the examples elliott and quchen just mentioned.
12:04:49 <josephle> klrr_: better that you don't mess with the Limbo between "base" Haskell and Agda
12:05:00 <klrr_> i dont have anything to do with haskell, it starts to get boring, i dont know what to write and ive already written all programs that pepople say you should write when you ask what programs to write
12:05:10 <byorgey> klrr_: so learn Agda!
12:05:15 <byorgey> it will expand your mind.
12:05:15 <klrr_> josephle: that just makes me more interesting
12:05:27 <klrr_> i hope so, or it will tare it appart like FRP did xD
12:05:41 <quchen> klrr_: Well, that's a general programming issue, and not one with Haskell.
12:06:03 <quchen> klrr_: When you're a painter that doesn't know what to paint, the brand of the brush isn't at fault.
12:06:17 <roconnor> tuque: so you want to iterate over the structure of the free monad, not the values?
12:06:44 <byorgey> quchen: ...but learning a new painting technique might spark your creativity.
12:06:54 <klrr_> quchen: no, but instead of writing programs i try learn more about haskell, my next natural step was FRP but it was too messy for my head
12:06:54 <roconnor> tuque: what would you use for the regular untransformed Free?
12:07:10 <byorgey> Haskell vs Agda is a bigger difference than "what brand of brush are you using".
12:07:26 <josephle> yeah, it's more like realism vs cubism
12:07:49 <tuque> roconnor I'll paste a bit in a few moments
12:08:01 <roconnor> tuque: does iterT not do it for you?
12:08:20 <roconnor> tuque: I guess I should point out that I've never used FreeT, so I may not be the most helpful person.
12:08:52 <quchen> klrr_: Arrows, using Lens, type-level programming, concurrency (Marlow's upcoming book will probably help), ST monad, using GADTs, …
12:08:53 <notdan> http://lpaste.net/90958 why can't I derive monad instances for this?
12:09:01 <quchen> There are lots of things to do once you've got some working knowledge :-)
12:10:14 <josephle> quchen: you're gonna have to expand on using Lens. Are we talking about casual usage or a serious understanding of the implementation?
12:10:18 <byorgey> notdan: because it isn't one.
12:10:25 <klrr_> quchen: well, im talking about agda with tac and it seems really interesting, i guess i will try learn it, also, arrows... i think ive understood them (although not really "learned" them yet, i cant use them)
12:10:34 <quchen> josephle: Usage, only usage.
12:11:00 <josephle> quchen: fair enough
12:11:09 <byorgey> notdan: try to implement 'join' for those types.
12:11:16 <Lethalman> is there any catMaybes for foldable?
12:11:17 <byorgey> if you want to see why.
12:11:19 <Lethalman> @hoogle foldMaybe
12:11:20 <lambdabot> No results found
12:11:41 <notdan> byorgey: but it's just 'StateT Int IO a' wrapped in another Monad
12:11:43 <Lethalman> don't know, something like f (Maybe a) -> f a
12:11:46 <shachaf> josephle: The important part of lens's implementation is not complicated.
12:11:51 <quchen> josephle: Implementing it might be a bit of a stretch. Although I can also recommend writing a simple lens lib yourself. It will be nowhere as general as edwardk's Lens, but it teaches you the general idea behind lenses.
12:11:53 <byorgey> notdan: ...which isn't a monad.
12:12:03 <Lethalman> it's not possible maybe
12:12:12 <byorgey> notdan: if  m and n are monads,  m (n a)  is not necessarily a monad.
12:12:17 <josephle> yeah, I found the stanford slides about lens
12:12:21 <notdan> oh :(
12:12:26 <josephle> might spend a week figuring it out
12:12:36 <josephle> since i'm comfortable using lenses
12:12:42 <shachaf> stanford slides about lens?
12:12:48 <numberten> m (n a) isn't a m monad?
12:12:50 <quchen> klrr_: Get used to Foldable/Traversable
12:13:01 <tac> klrr_: arrows are kind of weird. I'm looking through them this week, too.
12:13:07 <quchen> klrr_: I'll keep them coming as I come up with them ;-)
12:13:09 <byorgey> numberten: well, technically I should say  the composition of m and n
12:13:12 <josephle> shachaf: http://www.scs.stanford.edu/11au-cs240h/notes/zipper-slides.html#(1)
12:13:14 <josephle> it's really basic
12:13:18 <Twey> klrr_: I think learning Agda is a great way to learn about Haskell :þ
12:13:24 <supki_> Lethalman: Foldable can't recreate the structure
12:13:25 <josephle> and only a small part of the set of slides
12:13:33 <numberten> ah
12:13:35 <Lethalman> :t (>>= maybe mzero return)
12:13:36 <lambdabot> MonadPlus m => m (Maybe b) -> m b
12:13:40 <klrr_> Twey: nice to hear :)
12:13:50 <Lethalman> found this somewhere here: http://conal.net/blog/posts/a-handy-generalized-filter
12:13:51 <byorgey> numberten: a value of type  m (n a)  is a monadic action in the m monad, sure.
12:13:53 <shachaf> Hmm, those aren't "lens" lenses, but sure.
12:14:27 <josephle> shachaf: ah, I was somewhat referencing quchen's advise to write a simple lens lib
12:14:29 <byorgey> numberten: I mean not being able to write a Monad instance for  Compose m n  where   Compose m n a = Compose (m (n a))
12:14:39 <numberten> I see
12:14:55 <shachaf> Oh, I must have missed that advice.
12:15:18 <Lethalman> I'm probably going to use that
12:15:28 <shachaf> Sure, writing an implementation of lenses doesn't hurt. It's very straightforward.
12:15:36 <Lethalman> it's not possible to do the same with Monoid right?
12:15:41 <shachaf> I've written over a dozen of them!
12:16:38 <supki_> shachaf: do you have a link for ruby one still?
12:17:08 <shachaf> Some of them were, as elliott can attest, very strange.
12:17:14 <shachaf> supki_: Oh, I wouldn't even count that.
12:17:41 * elliott attests.
12:18:23 <shachaf> Assuming you mean http://slbkbs.org/lens.rb . But I'd hardly go so far as to call that an implementation of lenses...
12:18:29 <shachaf> Well, I suppose I did. But you can't trust filenames.
12:19:16 <supki_> thanks :)
12:21:54 <numberten> @hoogle StateT s m a -> s -> m a
12:21:55 <lambdabot> Control.Monad.Trans.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
12:21:55 <lambdabot> Control.Monad.Trans.State.Strict evalStateT :: Monad m => StateT s m a -> s -> m a
12:21:55 <lambdabot> Control.Monad.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
12:25:32 <robde> byorgey: "any time you want to use an operation or construction which works for all monoids." what do you mean by that?
12:26:25 <shachaf> robde: Take fold :: Monoid m => [m] -> m
12:26:56 <shachaf> Or maybe foldMap. foldMap :: (Foldable t, Monoid m) => t m -> m
12:27:07 <elliott> shachaf: uh.
12:27:19 <shachaf> Er.
12:27:28 <tac> > fold $ map Sum [1,2,3,4,5]
12:27:29 <lambdabot>   Sum {getSum = 15}
12:27:57 <shachaf> foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:31:20 <Lethalman> :t let joinMaybes = (>>= maybe mzero return); liftMaybe f = joinMaybes . liftM f in liftMaybe
12:31:22 <lambdabot> MonadPlus m => (a1 -> Maybe b) -> m a1 -> m b
12:31:25 <Lethalman> lovely
12:32:27 <tgeeky> @type sum
12:32:28 <lambdabot> Num a => [a] -> a
12:32:29 <tgeeky> @type product
12:32:30 <lambdabot> Num a => [a] -> a
12:32:51 <Lethalman> :t let joinMaybes = (>>= maybe mzero return); liftMaybe f = joinMaybes . liftM f in liftMaybe (\x -> x < 2 then Just x else Nothing) [1,2,3]
12:32:53 <lambdabot> parse error on input `then'
12:33:02 <Lethalman> :t let joinMaybes = (>>= maybe mzero return); liftMaybe f = joinMaybes . liftM f in liftMaybe (\x -> if x < 2 then Just x else Nothing) [1,2,3]
12:33:04 <lambdabot> (Num b, Ord b) => [b]
12:33:35 <Lethalman> sorry, but well the result is [1]
12:33:42 <Lethalman> very cool
12:33:46 <tgeeky> robde: I'll answer in lieu of byorgey, but I don't guarantee he would say the same: sum, product, and max work on Num types, but you may not have a Num. If you want to work on something more general, you use can use the Monoid classes.
12:33:51 <Lethalman> anybody ever wrote this kind of function?
12:34:09 <tgeeky> @hoogle (Num b, Ord b) => [b]
12:34:10 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
12:34:10 <lambdabot> Data.Graph.Inductive.Internal.Heap heapsort :: Ord a => [a] -> [a]
12:34:10 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
12:34:35 <tgeeky> Lethalman: yeah, someone has written that before.
12:34:38 <shachaf> Sum and Product are specifically for cases where you *do* have a Num instance.
12:34:54 <Lethalman> tgeeky, eheh I believe so, couldn't find anything on hackage though
12:34:59 <Lethalman> or better, using hoogle
12:35:04 <Lethalman> I should try hayoo
12:35:07 <tgeeky> Lethalman: yes
12:35:19 <tgeeky> Lethalman: people do all kinds of ill-advised things with Maybes
12:35:26 <Fuuzetsu> Lethalman: catMaybes exists
12:35:29 <tgeeky> shachaf: see, I knew I would be wrong.
12:35:36 <Fuuzetsu> > catMaybes [Nothing, Just 1, Nothing, Just 2]
12:35:36 <Lethalman> Fuuzetsu, catMaybes is only for lists
12:35:38 <lambdabot>   [1,2]
12:36:03 <Fuuzetsu> oh okay
12:36:09 <Lethalman> aaaaaaaah yeah
12:36:10 <Lethalman> mmapMaybe :D
12:36:14 <Lethalman> what a name :(
12:36:31 <Lethalman> :t mmapMaybe
12:36:32 <lambdabot>     Not in scope: `mmapMaybe'
12:36:32 <lambdabot>     Perhaps you meant one of these:
12:36:32 <lambdabot>       `IM.mapMaybe' (imported from Data.IntMap),
12:36:43 <Lethalman> :t Control.Monad.Plus.mmapMaybe
12:36:45 <lambdabot> Couldn't find qualified module.
12:36:48 <tgeeky> Lethalman: generally, functions in hackgae packages don't be available.
12:37:01 <mentat> hey, how do I make cabal install the required dependencies from my package?
12:37:09 <tgeeky> mentat: it will do so automatically
12:37:15 <Fuuzetsu> mentat: cabal install --only-dependencies
12:37:22 <hammond> hi is Haskell faster than C++?
12:37:23 <Fuuzetsu> but it should be automatic (unless you configure by hand)
12:37:34 <tgeeky> hammond: no
12:37:37 <Fuuzetsu> @faq Can Haskell be faster than C++?
12:37:38 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:44 <Lethalman> and there's also mcatMaybe, awesome
12:37:45 <Lethalman> :-)
12:37:51 <mentat> ah ty
12:37:52 <hammond> I don't get it it seems like a hoox language.
12:37:56 <mentat> now I got a more meaningful message
12:38:00 <mentat> I needed to do a cabal update =D
12:38:06 <hammond> hoax*
12:38:16 <Fuuzetsu> hammond: …I think that's the first time I hear that one!
12:38:19 <tgeeky> hammond: but absolute fastness is not a good metric for anything. (speed of code) / (lines of code), might be better than C++.
12:38:33 <tgeeky> hammond: like bigfoot?
12:38:34 <erisco> damn, hammond has caught onto our ruse
12:38:42 <supki_> @ty foldMapOf (folded . _Just) pure
12:38:42 <lambdabot> (Applicative f1, Foldable f, Monoid (f1 a)) => f (Maybe a) -> f1 a
12:38:53 <hape01> how Do i transform [IO()] to IO[] ?
12:39:02 <Fuuzetsu> :t sequence
12:39:02 <lambdabot> Monad m => [m a] -> m [a]
12:39:05 <jzelinskie> most problems aren't even cpu bound and get an advantage from being written in C/C++
12:39:19 <hammond> So if you are a mathematician it's better for you, I thought the object was to make applications that work. Like it doesn't matter what methods you use as long as it works, and aslong as it's fast.
12:39:24 <Fuuzetsu> :t sequence (undefined :: [IO ()])
12:39:25 <lambdabot> IO [()]
12:39:42 <hammond> Instead haskell's focus seems to be on how it's programmed not the end product.
12:39:56 <xplat> carter: cool, how are you making it work in haskell?
12:40:00 <hape01> Fuuzetsu: which module is this in?
12:40:10 <erisco> hammond, Haskell is convenient because its programs are more easily proved to have certain properties
12:40:12 <Fuuzetsu> hape01: Uh… Control.Monad maybe?
12:40:20 <Lethalman> oooh Control.Monad.Plus is not safe :-( :-(
12:40:22 <hape01> Fuuzetsu: thank You
12:40:27 <hammond> which is rather weird. It's not like anyone user is going to look at your wcode and say hmmm how nice is this code implemented I will buy this application for all my computers.
12:40:43 <tgeeky> hammond: please stop trolling
12:40:44 <jhance> hammond: Go ahead and make an application that works, but you'll never be able to improve it because it won't be maintainable if you don't pay attention to *how* you are programming
12:40:47 <gspr> hammond: Surely those who have to maintain the software cares about how it's written?
12:40:50 <erisco> hammond, mathematically that is. as far as practicality, Haskell offers an excellent type system and encourages practices that scale well to large programs
12:40:57 <gspr> *care
12:40:59 <Fuuzetsu> all these replies~
12:41:05 * tgeeky attaches a flag to the troll and warns others
12:41:22 <WilliamDhalgren> hm, maybe that was a bit too trigger happy?
12:41:36 <jhance> thats what happens when you go to #x and talk about how you disagree with x's design philosophy
12:41:49 <tgeeky> i wonder if there are 900 people in #bigfoot
12:42:08 <erisco> if that was a troll it was weaksauce
12:42:49 <shoret`> eh, I agree it would have probably turned to real trolling, but I agree it was a little quick for a boot
12:43:08 <tgeeky> he was booted? he left according to my client
12:43:13 <jhance> It says he left.
12:43:46 <WilliamDhalgren> ah, true. still, left after being called a troll
12:44:01 <WilliamDhalgren> anyhow, not particularly important
12:44:06 <carter> xplat i have a world parameter in all my type classes :)
12:44:09 <carter> still working out some details
12:44:12 <arcatan> no true troll would leave after being called a troll etc.
12:44:13 <shoret`> oh. misread your message
12:44:17 <shoret`> yeah, bye troll
12:44:19 <erisco> there are plenty of people who only program as a means to an end, and I can understand curiosity when you hear that people take the "means" part as its own entity
12:44:30 <carter> but basically you lift / map values into a world
12:44:42 <carter> and then you "run" an expression in a world
12:44:52 <carter> which then lets all the type class instances get resolved
12:45:39 <dEPy> what do empty parens  ()  stand for?
12:45:48 <dEPy> for example:    push a xs = ((),a:xs)
12:45:50 <erisco> those who just cook what tastes decently and fills them up might be confused about the idea of molecular gastromony for the same reasons
12:45:50 <tgeeky> dEPy: the unit type
12:46:03 <tgeeky> @type ()
12:46:04 <lambdabot> ()
12:46:16 <Ue> Hi.  I wondered whether any notable projects use haskell?
12:46:34 <tgeeky> Ue: nearly 100% of projects on hackage.haskell.org, use haskell.
12:46:42 <tgeeky> At least a dozen or two dozen of them are notable.
12:46:57 <josephle> erisco: that might be an excellent analogy for the relationship between programming and programming language theory, but I sure hope it isn't one for programming and haskell ;)
12:47:22 <WilliamDhalgren> ue I don't know that many or that extremely notable, xmonad, pandoc, obviously the haskell compiler itself, darcs
12:47:25 <hammond> Sorry I disconnected.
12:47:47 <taylorgb_> I could well believe that the majority of motivating examples for Haskell are not well publicized. Seems that parts of investment banking and such seem very interested in haskell programmers
12:47:48 <jhance> Ue: Xmonad, GHC (if it counts), a few web frameworks, and probably some others I'm forgetting
12:47:51 <hammond> Yes I mean who cares what methods you are using aslong as the app works fine in the end.
12:48:12 <taylorgb_> hammond: but the majority of apps don't work fine
12:48:28 <jhance> hammond: Name anything besides tex that has no bugs.
12:48:32 <jhance> (and even tex has bugs)
12:48:40 <hammond> taylorgb_: that's the point of debugging, after debugging it it works fine.
12:48:49 <WilliamDhalgren> ah, good. hammond, well I agree. but mere speed is rarely the top criteria. ppl would be writing assembler in that case. anyhow, haskell was created as a research program in computer science - about efficient compilation of lazy functional languages. and is still a testbed for academia
12:48:54 <hammond> What's so odd about that.
12:48:56 <benmachine> debugging is hard
12:49:02 <benmachine> it's important to find ways to make it easier
12:49:07 <hammond> and it's not as fast as C++
12:49:08 <tgeeky> hammond: what about the huge swath of bugs that are difficult to catch in a debugger, or should have never been introduced in the first place?
12:49:08 <erisco> debugging is stupid hard and time consuming
12:49:13 <benmachine> Haskell does a lot of things to prevent bugs, and make bugs easier to find when they happen
12:49:14 <jhance> Debugging can only fix bugs you know exist
12:49:25 <hammond> What will you do without OO that's nonsense.
12:49:26 <taylorgb_> Fixing bugs without introducing other bugs is also difficult to do, and definitely difficult to prove
12:49:39 <jhance> hammond: Use functional programming instead?
12:49:47 <erisco> out before trolled
12:49:54 <hammond> You can't scale your apps without OO that's why Haskell is so obscure. I dunno
12:50:07 <benmachine> hammond: you can, people do
12:50:10 <Ue> hammond: LOL, Haskell has OOo.
12:50:15 <Ue> P
12:50:16 <jhance> I didn't realize that programming languages like C don't scale.
12:50:21 <WilliamDhalgren> Ue, not really
12:50:34 <benmachine> people have applied Haskell to OO but usually it's not necessary
12:50:34 <jhance> Guess Linux/GNU in general are slow and Windows is fast, since Windows is written in C++ and supposed OO
12:50:43 <Ue> WilliamDhalgren: Yar, it does, so does Matlab and everything else.
12:50:46 <benmachine> there are lots of ways to achieve modularity
12:50:47 <hammond> I always thought that the focus was how the end product works not the method used.
12:50:52 <josephle> Ue, what? haskell has equi-recursive types?
12:51:02 <jhance> hammond: And the method used affects how you get to the end product
12:51:03 <jzelinskie> jhance: +100!
12:51:07 <taylorgb_> Only parts of Windows are C++, mostly only in the shell layer
12:51:07 <jzelinskie> and the nsa has made it even faster!
12:51:11 <benmachine> oh he's left again
12:51:16 <taylorgb_> No c++ in the kernel for example, because of the limitations
12:51:21 <benmachine> *they've
12:51:22 <WilliamDhalgren> good, that's enough
12:51:35 <tuque> roconnor: nevermind my earlier paste-to-be, I am ok for now.
12:51:59 <tgeeky> tuque: happy to ignore it, sir!
12:52:23 <Ue> josephle: Well, you're a functional programmer… sssh.
12:52:36 <WilliamDhalgren> Ue, you could emulate some oo idioms, but there's no subtyping and, if you're using typeclasses to emulate OO classes, a deep inheritance hierarchy will quickly become a pain. well, exceptions system does just that ..
12:52:54 <Ue> josephle: I program using Matlab, C, C++ and Java… so you know… they are better.
12:53:18 <tgeeky> Ue: eww, ok, ok, eww
12:53:32 <Ue> tgeeky: He is being mean...
12:53:39 <benmachine> http://lambda-the-ultimate.org/node/319
12:53:40 <byorgey> robde: I mean any time you want to call a function with a Monoid constraint.
12:54:20 <benmachine> those interested in applying object orientation to Haskell should read http://lambda-the-ultimate.org/node/319
12:54:25 <benmachine> but I'm not one of those people :P
12:54:30 <byorgey> robde: e.g. if you want to use the Writer monad and have it adding numbers, you cannot just call the 'sum' function, because you are not the one doing the adding, you want the Monad instance for Writer to do the adding
12:54:42 <roconnor> tuque: iterT worked for you?
12:54:53 <byorgey> robde: so you need to use Sum so that it knows which monoid operations to do
12:55:10 <josephle> how am I being mean? Java has equirecursive types, but I'm pretty sure haskell doesn't!
12:55:30 <Fuuzetsu> Java confirmed for better type system than Haskell!
12:55:33 <josephle> lol
12:56:23 <robde> I see
12:56:41 <WilliamDhalgren> benmachine: though maybe they take an overly restricted view of what it takes to be OO. wonder how a prototype system ala javascript would look in haskell. there was that blogpost with a minimal library doing something like that. should try a better record system for it
12:57:04 <Ralith> is hoogle weirdly broken for anyone else?
12:57:11 <Yaniel> see topic
12:57:24 <benmachine> I was really expecting it to have been fixed by now :/
12:57:29 <benmachine> (hoogle, that is)
12:57:58 <Ralith> oh
12:58:01 <applicative> ndm was going to redirect to fpcomplete I thought he said, maybe thats not so easy
12:58:22 <josephle> WilliamDhalgren: i'm not sure there's a real consensus about what OO entails
12:58:23 <applicative> Ralith: maybe youre lucky and you can run the hoogle binary you just downloaded
12:59:02 <josephle> I may jest about equirecursive types, but we could also frame this as procedural-abstraction vs data-abstraction
12:59:07 <josephle> a la Cook's paper
12:59:31 <nbouscal_> Is there a standard way to turn a list (actually a bytestring in this case) into a list of equal length lists? Like split but based on length not delimiters.
12:59:53 <applicative> nbouscal_: import Data.List.Split
12:59:58 <applicative> cabal install split
13:00:06 <tgeeky> nbouscal_: http://hackage.haskell.org/packages/archive/split/0.2.1.1/doc/html/Data-List-Split.html
13:00:10 <tgeeky> nbouscal_: chunksOf
13:00:12 <Ue> josephle: I reckon people who use functional languages invent words to try to look smart.  C family languages are better because we do not use made up words.
13:00:13 <applicative> then use one of the combinators, chunksOf n xs ...
13:00:18 <tgeeky> applicative: :)
13:00:22 <tgeeky> byorgey++
13:00:33 <Ue> applicative: What is a combinator???
13:00:36 <applicative> nbouscal_: I think its in the current haskell platform so you may have it
13:00:37 <nbouscal_> Thanks all, will check it out.
13:00:47 <Ue> applicative: It sounds like a made up word.
13:00:53 <tgeeky> Ue: a function designed to be used in the context of a larger set of functions
13:00:57 <elliott> Ue: I don't see what you're trying to achieve here.
13:01:00 <applicative> Ue: I was just using it in the sense of a highly generic function
13:01:02 <elliott> convince everyone in #haskell to stop using Haskell?
13:01:15 <WilliamDhalgren> Ue you mean, jargon, terminology.
13:01:15 <applicative> S I etc are the ultimate combinators
13:01:30 <hammond> The thing is I'm interested in learning Haskell.
13:01:39 <shoret`> Ue: http://www.haskell.org/haskellwiki/Combinator_pattern
13:01:39 <jzelinskie> here we go
13:01:43 <hammond> Because I heard a lot of people talking about it.
13:01:47 <applicative> Ue: It is a made up word, but Curry made it up, so it's ok
13:01:50 <byorgey> hammond: you have come to the right place!
13:01:53 <tgeeky> hammond: that's a terrible reason to use a programming language.
13:02:05 <byorgey> it's a great reason to learn one though.
13:02:08 <WilliamDhalgren> rofl, this is getting amusing
13:02:12 <nbouscal_> Yep, chunksOf is what I need... Is there an implementation of it for ByteStrings?
13:02:12 <hape01> sequence $ map putStr ["a","b"]
13:02:12 <hammond> But I mean why does the focus has to be on what methods are used to create an application.
13:02:20 <tgeeky> hammond: but we would welcome you anyway. You need to drop misconceptions about what Haskell is or isn't, until you have played with it for some time.
13:02:21 <applicative> nbouscal_: haha, ask byorgey
13:02:25 <hape01> ab[(),()]
13:02:29 <hammond> I mean because of this the language doesn't have a 3d API
13:02:29 <mentat> yeah hammond, the good reason to learn haskell is to feel superior to everyone else
13:02:30 <hammond> .
13:02:30 <hape01> why   not ab  ?
13:02:38 <Ue> WilliamDhalgren: Well, other languages have less jargon.  Class, function, etc all have meaning in ordinary language.
13:02:59 <hammond> So even if Haskell is equally fast as C++ or maybe faster, lol, it can't be used to make games.
13:03:07 <byorgey> hape01: perhaps you want sequence_
13:03:15 <elliott> Ue: I mean, do you have any interest in learning Haskell? it doesn't seem like it... but if not, I'm not sure what you're trying to achieve by telling people who use it that it's bad.
13:03:31 <tgeeky> hammond: incorrect. It can, and has, been used to make games. It can also compile and manage C++ code for you.
13:03:31 <jzelinskie> What? I thought Half Life was written in Haskell? Haven't you seen the logo?
13:03:36 <hammond> This is because it focuses on innane things, I thought the focus was to solve problems not to create more problems really.
13:03:38 <supki_> hape01: ghci prints the result of computation if it isn't ()
13:03:38 <hape01> byorgey: didn't know that there is sequence_  :-) thx
13:03:53 <dEPy> hammond: you CAN make games with haskell
13:03:59 <hape01> wow
13:04:07 <josephle> hammond: I think the CEO of Epic Games might want to have a word with you...
13:04:08 <WilliamDhalgren> Ue I think you're right. terminology strives to feel similar in say oo languages, methods, objects etc. Terminology in hs mostly comes from math, so its comparatively obtruse. functors, monoids, monads,
13:04:08 <byorgey> hammond: are you really interested in learning Haskell, or are you just interested in trolling?
13:04:09 <dEPy> hammond: but rarely anyone does it
13:04:12 <hammond> dEPy: really?
13:04:29 <jzelinskie> has John Carmack been in this channel since he started porting Doom 3 to Haskell?
13:04:42 <tgeeky> jzelinskie: as far as I know, he's never been in #haskell.
13:04:43 <merijn> hammond: Fun fact, John Carmack (you know, id Software, Doom and Quake) has been learning haskell :)
13:04:47 <dEPy> hammond: yes, there are libraries (wrappers) for ogre, bullet physics, ...
13:04:47 <Hafydd> < hammond> but yeah in vacation it's always good to go in ##php and #python and #haskell and tell these people that their softwares languages suck
13:04:51 <WilliamDhalgren> hammond here's an old one - http://www.haskell.org/haskellwiki/Frag
13:04:54 <merijn> jzelinskie: He wasn't porting Doom3, he was porting an older doom
13:05:04 <Hafydd> < hammond> hehe, one person even jumped off the boat and left. hehe
13:05:05 <tgeeky> Hafydd: troll status confirmed.
13:05:05 <jzelinskie> ah
13:05:08 <mentat> one of the reasons I'm loving haskell is that my old code can be reused much more easily
13:05:11 <hammond> byorgey: yes I'm interested I know C++ already and at the time I learned it they told me it was the hardest thing, but now they are telling me Haskell is the hardest thing to learn.
13:05:24 <josephle> bah, C++ is still harder to learn
13:05:28 <mentat> I can change it without the fear of breaking everything
13:05:31 <hammond> Hafydd: you have betrayed me!
13:05:35 <Fuuzetsu> merijn: unfun fact: he doesn't like it
13:05:40 <Fuuzetsu> (or _get_ it or whatever)
13:05:47 <dEPy> anything imperative is easier to learn imo
13:05:56 <WilliamDhalgren> rofl, like nonobvious otherwise
13:05:58 <tgeeky> dEPy: haskell is the finest imperative...
13:06:02 <mentat> haskell is easy...
13:06:08 <WilliamDhalgren> hmm
13:06:16 <mentat> it is just very different from other programming languages
13:06:30 <josephle> if C++ is easy, there are clearly not enough templates in your code :P
13:06:30 <mentat> so you can't reuse your knowledge the same way you did it when you learned C++
13:06:40 <merijn> Fuuzetsu: Eh, based on what? All his comments I've seen were rather positive
13:07:00 <mentat> C++ is much, much harder than haskell
13:07:39 <tulcod> may i suggest we switch this channel's official language to lojban?
13:07:42 <Ue> Hafydd: It is funny, I said Haskell supports OO and then someone started arguing with me.  It is fully clearcut what any of these things are of course.
13:07:57 <Ue> Hafydd: Do you use this language for work or just as a hobby?
13:07:58 <taylorgb_> I think the difference with most imperative languages is that you only really need to understand the effects you want to produce to make some program that half kinda works, which really isn't true at all with haskell
13:08:02 --- mode: ChanServ set +o elliott
13:08:10 --- mode: elliott set +b $a:Portrait
13:08:25 --- mode: elliott set +b hammond!*@*
13:08:27 --- mode: elliott set -o elliott
13:08:54 <tgeeky> I would literally kill myself rather than write something critical (control for a radiotherapy device) in C++. In Haskell, if my code compiled, I might volunteer some unimportant body part as a test subject.
13:09:45 <tulcod> taylorgb_: as a current haskell student, the difficulty lies in knowing all the stuff you want a certain function to "do", and how you can do that in haskell
13:09:55 <lpaste> applicative pasted “chunky” at http://lpaste.net/90959
13:09:58 <Ue> tgeeky: It just depends on the job.  Like Java is good for Android apps because of memory safety etc etc.  Different languages apply for different jobs.
13:10:11 <tulcod> in C++, you can just start some function blergh, and change its return type and throws() declaration as you code
13:10:12 <applicative> nbouscal_: here is the general form of chunksOf as an unfold ^^^ http://lpaste.net/90959
13:10:16 <tulcod> that's not really possible in haskell
13:10:34 <zacts> yo
13:10:45 <applicative> yo
13:10:47 <saml> welcome zacts
13:10:50 <zacts> I can tell already that haskell is going to be my favorite language to program in.
13:10:57 <zomg> tulcod: I find it helps if you stop thinking of the big parts and rather focus on the small parts and build those. Then it's easy to put them together to form the big one
13:11:09 <taylorgb_> I agree. However, I think the real difference is just that the order in which you develop software changes somewhat. I.e., in Haskell you really need to understand things before you can write the program, whereas in C++ you really need to understand things before it will work
13:11:22 <tulcod> zomg: that includes knowing what the small parts ought to be
13:11:35 <taylorgb_> And you can end up wasting a lot of time with writing code that's not necessary or is wrong
13:11:41 <tulcod> taylorgb_: agreed
13:11:49 <Ue> djahandarie: あなたと日本語で話したくないですよ。
13:12:26 <zomg> tulcod: yeah I guess so, that was never a huge issue for me since I can do that in my head thanks to having done it in my head bazillion times in other languages =)
13:12:26 <tgeeky> taylorgb_: which you will do in Haskell, too. But when you refactor and you don't break type safety, GHC will guide you to your refactoring destination, keeping things in order on the way.
13:12:28 <taylorgb_> One of the nice things about Haskell seems to be that most of the effort is in the thinking, so changing designs or moving things about isn't time consuming at all
13:12:29 <johnw> taylorgb_: you mean, in Haskell coding and design are intermixed due to the nature of types?
13:13:05 <byorgey> zacts: =)
13:13:33 <applicative> zacts: :)
13:13:38 <taylorgb_> johnw: Not exactly.. I rather think that in Haskell you do the design by decomposing the problems into the relevant data structures and then composing them as is simplest to do. I don't think it's as easy to do that in other languages because the distinction isn't so clear
13:14:02 * hackagebot bitset 1.4.6 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.6 (SergeiLebedev)
13:14:04 <taylorgb_> I.e., there's a lot more boiler plate, and junk that you need to do because the language isn't stronger
13:14:14 <johnw> I agree that the emphasis on compositionality is a wonderful strong point
13:14:28 <johnw> when I find myself "fusing" algorithms, it feels wrong now
13:14:41 <byorgey> Ue: if you don't want to talk to djahandarie in Japanese, then there's no reason to clutter up #haskell telling him so in Japanese.
13:15:22 <Ue> byorgey: He was harassing me in another channel.
13:15:26 * applicative wasn't mind the 'oriental' decor
13:15:30 <applicative> minding
13:15:33 <Ue> byorgey: …about this channel.
13:15:40 <byorgey> Ue: then respond to him in another channel.  #haskell is not the place for that.
13:16:04 <tgeeky> byorgey: you used a translate service, right? You don't know Japanese... do you? :o
13:16:17 <applicative> you wouldn't believe what byorgey knows
13:16:27 <zomg> ですですですです
13:16:33 <johnw> I need a translate service that speaks byorgey
13:16:34 <tgeeky> I have seen his library, so I would.
13:16:38 <WilliamDhalgren> Ue, yes, well maybe not perfectly, but it is sufficiently clear - and its just as clear haskell isn't among them; don't think you'll find anyone arguing otherwise seriously. its family history is just completely separate
13:17:56 <applicative> WilliamDhalgren: this is about haskell vs. 'oo'
13:17:59 <applicative> ?
13:18:03 <WilliamDhalgren> right
13:18:11 <Ue> WilliamDhalgren and byorgey: I agree with you both.  He spread it between them though and I do not want to discuss this in the other channel.  If you are happy with it, may we be done with this subject?
13:18:24 <WilliamDhalgren> kk
13:18:30 * elliott isn't sure what the subject even is.
13:18:43 <WilliamDhalgren> japanese drama
13:18:53 <tgeeky> @quote subject
13:18:54 <lambdabot> grauenwolf says: (On predicates and the relational model) The definition of predicate is "the part of the sentence that makes the assertion about the subject." So predicates cannot be 'on' the
13:18:54 <lambdabot> attributes so much as 'about' the attributes.
13:19:47 <josephle> tgeeky: there must be some context to that quote
13:21:36 * applicative declares unfoldr to be the Best Combinator of July 2013
13:29:39 <nbouscal_> applicative: thank you!
13:33:07 <adnap> Is there a better way to write \x -> x /= x0 && x /= x1
13:33:26 <Clint> adnap: define "better"
13:33:27 <benmachine> adnap: there's x `notElem` [x0, x1]
13:33:35 <dwcook> @pl \x -> x /= x0 && x /= x1
13:33:36 <benmachine> adnap: but whether that's better is debateable
13:33:39 <lambdabot> ap ((&&) . (x0 /=)) (/= x1)
13:33:39 <lambdabot> optimization suspended, use @pl-resume to continue.
13:33:46 <dwcook> I wouldn't call that better :P
13:33:53 <adnap> I'm obviously asking for *opinions*
13:34:00 <benmachine> :t liftM2 (&&) (x0 /=) (x1 /=)
13:34:01 <lambdabot>     Not in scope: `x0'
13:34:01 <lambdabot>     Perhaps you meant `x' (imported from Debug.SimpleReflect)
13:34:01 <lambdabot>     Not in scope: `x1'
13:34:03 <tuque> roconnor: my base functor is data Config =  CVal Param next | Done.. what return value would make the most sense for the Done case?
13:34:04 <benmachine> hmph
13:34:07 * hackagebot semigroupoids 3.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.1 (EdwardKmett)
13:34:15 <benmachine> :t liftM2 (&&) ('y' /=) ('x' /=)
13:34:16 <lambdabot> Char -> Bool
13:34:42 <gnuvince> Is there a problem with Hoogle?  When I go to www.haskell.org/hoogle, I get a download prompt
13:34:46 <benmachine> gnuvince: yes
13:34:49 <shachaf> gnuvince: Yep. See topic.
13:34:56 <shachaf> Though, really, this is getting unreasonable.
13:34:56 <cdk> :t \x0 x1 -> (&&) `on` (/=x0) (/=x1)
13:34:57 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `Bool'
13:34:58 <lambdabot>     In the return type of a call of `/= x0'
13:34:58 <lambdabot>     Probable cause: `/= x0' is applied to too many arguments
13:34:58 <tuque> sorry roconnor i meant data Config next =  CVal Param next | Done
13:35:09 <arcatan> \x -> x `notElem` [x0,x1]
13:35:10 <gnuvince> shachaf: thank you
13:35:21 <arcatan> oh, right, somebody was faster than me already
13:35:30 <adnap> That seems like the most extendable way
13:35:44 <arcatan> rather easy to read, too
13:35:52 <adnap> And it can be written without the argumnet
13:36:01 <adnap> Or parameter, rather
13:36:29 <adnap> `notElem` [x0, x1]
13:36:43 <adnap> I think...
13:36:49 <tuque> roconnor sorry, to be more clear I'm trying to write an f m a -> m a for my base functor Config next = CVal Param next | Done so i can use it with iterT
13:36:58 <adnap> > `notElem` [5, 3] $ 2
13:37:00 <lambdabot>   <hint>:1:1: parse error on input ``'
13:37:51 <adnap> > (`notElem` [5, 3]) 2
13:37:52 <lambdabot>   True
13:39:06 <CADD> adnap: you can also write it like this
13:39:14 <CADD> > notElem 2 [1,3]
13:39:16 <lambdabot>   True
13:40:19 <CADD> adnap: surrounding a keyword with ` is only necessary to make it infix
13:40:27 <CADD> adnap: so like
13:40:38 <CADD> > 2 `notElem` [1,3]
13:40:40 <lambdabot>   True
13:42:39 <applicative> > on (liftM2 (&&)) (/=) 0 2 2
13:42:40 <lambdabot>   False
13:42:46 <applicative> > on (liftM2 (&&)) (/=) 2 2 3
13:42:46 <lambdabot>   True
13:47:21 <CADD> hey does anyone know how to compose lambdabot's > command with @@?
13:47:24 <CADD> say something like:
13:47:34 <CADD> @@ CADD > notElem 2 [1,3]
13:47:35 <lambdabot>  CADD > notElem 2 [1,3]
13:47:39 <CADD> @@ CADD @> notElem 2 [1,3]
13:47:40 <lambdabot> Plugin `compose' failed with: Unknown command: ">"
13:47:44 <CADD> hmm
13:48:26 <int-e> @run fix (1:)
13:48:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:48:35 <CADD> as in the second expression after my name would be executed as normal
13:48:38 <CADD> ah
13:48:43 <CADD> @@ CADD @run notElem 2 [1,3]
13:48:45 <lambdabot>  CADD   True
13:48:54 <CADD> int-e: brilliant!
13:48:56 <CADD> int-e++
13:49:08 <`^_^v> i'm writing a simple emulator. what would be the best solution for a static table of (numeric) opcode -> function?
13:50:26 <notNicolas_w> I have a Maybe [String] and I want to extract that [String] to use it in a do block for []
13:51:05 <adnap> > Just 3 >>= do $ return
13:51:07 <lambdabot>   Empty 'do' block
13:51:23 <adnap> > Just 3 >>= \x -> do $ return x
13:51:25 <lambdabot>   Empty 'do' block
13:51:35 <johnw> isn't that just Just 3 >>= return?
13:51:35 <adnap> > Just 3 >>= \x -> do { return x }
13:51:37 <lambdabot>   Just 3
13:51:40 <CADD> > Just 3 >>= return
13:51:42 <lambdabot>   Just 3
13:51:44 <CADD> adnap: ^
13:51:45 <adnap> johnw: Yeah, just showing notNicolas_w
13:51:48 <johnw> ah, ok
13:51:51 <johnw> monad law #1 :)
13:51:58 <enthropy> `^_^v: you can probably use functions with type    Int -> (function)
13:52:37 <notNicolas_w> errr
13:52:56 <notNicolas_w> names <- maybes >>= return doesn't work
13:52:58 <CADD> `^_^v: I would probably have a adt similar to something like this: [(Int,(a -> b))]
13:53:12 <shachaf> notNicolas_w: What do you want to do if it's Nothing?
13:53:17 <notNicolas_w> empty list
13:53:17 <shachaf> Then there's no [String] to extract.
13:53:20 <shachaf> OK.
13:53:21 <shachaf> :t fromMaybe
13:53:22 <lambdabot> a -> Maybe a -> a
13:53:24 <CADD> `^_^v: Now that is very limited in what you can do, it only allows funcs with only one argument
13:53:26 <notNicolas_w> ahh
13:53:39 <shachaf> Or you can do it yourself, of course, with pattern matching.
13:54:02 <shachaf> Or...
13:54:03 <shachaf> > fold (Just "abc")
13:54:05 <lambdabot>   "abc"
13:54:09 <shachaf> > fold Nothing :: [String]
13:54:10 <lambdabot>   []
13:54:19 <shachaf> Hmm, that was [Char], not [String]. Whatever.
13:54:32 <`^_^v> enthropy, i read in this chan that case statements involving integer literals call fromInteger implicitly, i would like to avoid that if possible
13:55:42 <notNicolas_w> ahh
13:55:49 <roconnor> notNicolas_w: I would turn your maybe String into a [String]
13:55:50 <benmachine> `^_^v: why do you want to avoid that?
13:55:56 <notNicolas_w> I'm not sure if I'm getting closer
13:55:58 * enthropy can't refute that, but it's better to have something that works and is too slow than to agonize over the fastest way to accomplish it
13:56:12 <notNicolas_w> it is a Maybe [String]
13:56:30 <roconnor> okay turn it into a http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String
13:56:33 <roconnor> gah
13:56:38 <roconnor> okay turn it into a [ [String] ]
13:56:48 <benmachine> `^_^v: it depends what the opcodes can be, are they contiguous?
13:56:50 <roconnor> stupid IRC client
13:57:07 <notNicolas_w> wtfspleen
13:57:09 <benmachine> roconnor: haha, that's interesting :P
13:57:58 <notNicolas_w> ok this do notation makes no sense. canning it.
13:58:06 <roconnor> do { listOStrings <- F.toList (Just ["a","b","c"]); ... }
13:58:25 <`^_^v> benmachine, yes
13:59:03 <roconnor> > [x | x <- F.toList (Just ["a","b","c"])]
13:59:04 <lambdabot>   [["a","b","c"]]
13:59:17 <roconnor> > [x | x <- F.toList Nothing]
13:59:18 <lambdabot>   []
13:59:26 <roconnor> > [x | x <- F.toList (Just [])]
13:59:27 <lambdabot>   [[]]
14:00:02 <benmachine> `^_^v: in that case maybe Data.Array will be your friend
14:00:43 <`^_^v> i was looking at the hashtables package, since i am going to be working in the ST monad anyway
14:01:06 <`^_^v> i'm not sure which is more performant
14:03:01 <benmachine> `^_^v: do you need your opcode table to be mutable?
14:03:12 <`^_^v> no
14:03:51 <benmachine> `^_^v: I'd stick to immutable arrays then, should make things simpler
14:04:10 <chrisdotcode> hi all :)
14:04:22 <CADD> o/
14:04:25 <`^_^v> i'll try it out, thanks
14:04:46 <Fuuzetsu> Is the Parallel and Concurrent Programming in Haskell coming out before the end of the month or was the date moved?
14:06:10 <Lethalman> is there a kind of unfold with monadic values?
14:06:31 <Lethalman> something like (a -> b) -> m (Maybe a) -> [b]
14:06:32 <Fuuzetsu> What type would that be?
14:06:33 <johnw> do you mean unfoldM?  I'm not sure what you mean by "monadic values"
14:06:36 <chunkstuntman> when I try to run this foldl function
14:06:37 <chunkstuntman> Prelude.foldl (\acc tri -> if inTriangle (Point 0.0 0.0) tri then (acc + 1) else acc) 0 (textToTri file)
14:06:39 <Fuuzetsu> :t unfoldM
14:06:40 <lambdabot>     Not in scope: `unfoldM'
14:06:40 <lambdabot>     Perhaps you meant one of these:
14:06:40 <lambdabot>       `BS.unfoldr' (imported from Data.ByteString),
14:06:44 <Lethalman> or better (a -> b) -> m (Maybe a) -> m [b]
14:06:52 <Lethalman> can't find anything like this
14:06:54 <chunkstuntman> I'm told that there is no instance for 0
14:07:07 <johnw> Lethalman: that's just whileJust xs f
14:07:22 <Lethalman> argh
14:07:29 <Fuuzetsu> @src whileJust
14:07:29 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
14:07:32 <Fuuzetsu> zzz
14:07:35 <Lethalman> johnw, hayoo failed to find that with different order of arguments :-)
14:07:36 <Lethalman> thanks
14:07:41 <johnw> sorry, flip whileJust
14:07:44 <Lethalman> yeah
14:07:49 <johnw> :t flip Control.Monad.Loop.whileJust
14:07:50 <lambdabot> Couldn't find qualified module.
14:07:54 <johnw> :t flip Control.Monad.Loops.whileJust
14:07:56 <lambdabot> Monad m => (a -> m b) -> m (Maybe a) -> m [b]
14:08:05 <Lethalman> hayoo real file though :-( unexpected
14:08:13 <johnw> compose in a "return" and you'll get (a -> b) for the first arg
14:08:35 <Lethalman> indeed
14:08:37 <johnw> :t \x y -> Control.Monad.Loops.whileJust y (return . x)
14:08:39 <lambdabot> Monad m => (a -> b) -> m (Maybe a) -> m [b]
14:09:05 <Lethalman> cthanks
14:10:57 <julian-goldsmith> hullo all
14:11:10 <julian-goldsmith> does anyone know where i might find information about processing tables functionally?
14:11:50 <notNicolas_w> relational algebra?
14:12:02 <troydm> databases?
14:12:28 <julian-goldsmith> kinda
14:12:42 <julian-goldsmith> i'm manipulating tab-separated value files in c# using linq
14:12:51 <johnw> julian-goldsmith: check out the "tables" package on Hackage, btw
14:12:53 <julian-goldsmith> and i need to change some of the fields at specific indices
14:12:59 <johnw> you just have to get the data into them first
14:13:17 <banister`sleep> johnw: do you think anyone actually intuitively understands foldr, or they just pretend to?
14:13:33 <hpc> the intuition is quite easy
14:13:35 <johnw> banister`sleep: heh, why are you asking me?  I intuitively understand foldr
14:13:53 <hpc> foldr (*) z list = replace (:) with (*) and [] with z
14:13:58 <Peaker> banister`sleep, foldr isn't hard to understand intuitively
14:14:00 <johnw> take a list, which is x:y:z:[], and now replaces every : with your binary function, and [] with your terminal value
14:14:02 <banister`sleep> johnw: can you give me an intuitive explanation
14:14:07 <johnw> done
14:14:26 <johnw> and right associate them
14:14:27 <CADD> banister`sleep: foldr is not hard at all
14:14:36 <johnw> so, x `f` (y `f` (z `f` term))
14:14:41 <banister`sleep> CADD: how can it work on infinite lists?
14:14:45 <Peaker> banister`sleep, a:(b:(c:(d:[]))) --> a*(b*(c*(d*z))))   and if * is lazy on its right arg, it works out nicely
14:14:51 <hpc> foldr (+) 0 [1,2,3] = foldr (+) 0 (1:(2:(3:[])))) = 1 + 2 + 3 + 0
14:14:53 <johnw> it can work on infinite lists *if* your f is not strict in the second argument
14:14:57 <troydm> banister`sleep: u traverse data while applying a function and keeping result while applying that result to next value
14:15:18 <troydm> that's wat fold[lr] does
14:15:42 <shachaf> foldl and foldr are different functions. foldr is much more fundamental.
14:15:55 <julian-goldsmith> huh, that tables library is kinda neat
14:16:19 <julian-goldsmith> is there any kind of general pattern for working with arrays in functional languages, though?  i'm working in c# right now
14:16:38 <johnw> what kind of patterns do you mean?
14:16:50 <julian-goldsmith> hold on, i'll post some code
14:16:53 <aristid> julian-goldsmith: have a look at the vector package.
14:17:10 <johnw> lens can also give you a convenient interface to arrays
14:17:14 <julian-goldsmith> aristid: i'm working in c#, so i can't use it right now
14:18:05 <Fuuzetsu> I just think of the folds on lists as if I was replacing (:) with whatever function I pass in and parenthesising it based on whether it's a left or right fold
14:18:12 <banister`sleep> shachaf: why is foldr more fundamental than foldl
14:18:22 <johnw> banister`sleep: foldl can be implemented using foldr, but not vice-versa
14:18:23 <CADD> banister`sleep: yeah, if you define "working" as never stopping.
14:18:43 <julian-goldsmith> http://pastebin.com/pwtrrt2z
14:18:52 <mauke> The paste pwtrrt2z has been copied to http://lpaste.net/90962
14:19:04 <julian-goldsmith> the first one is some of the functional code i've written to manipulate the files
14:19:11 <julian-goldsmith> and the second is the code i'm working on right now
14:19:13 <shachaf> I didn't say "more useful".
14:19:18 <dmwit> um
14:19:21 <shachaf> Though that's probably true for roughly the reason johnw said.
14:19:26 <dmwit> Isn't this channel for Haskell?
14:19:29 <julian-goldsmith> i'm looking for a way to pick fields out of the array functionally
14:19:35 <shachaf> Yes.
14:19:39 <julian-goldsmith> this is a general functional programming question
14:19:53 <shachaf> This channel is for Haskell, not general functional programming.
14:20:00 <CADD> dmwit: yes
14:20:12 <CADD> shachaf: oh there is a general fp one?
14:20:23 <dmwit> We do take generalized questions from time-to-time. But this sounds like a C# question to me.
14:20:29 <shachaf> Haskell has very different solutions to things that you'd use arrays for from C#'s.
14:20:31 <troydm> julian-goldsmith: depends on who you store array
14:20:35 <dmwit> CADD: irrelevant
14:21:00 <julian-goldsmith> troydm: i'm working with one flat array at a time
14:21:03 <shachaf> What dmwit said.
14:21:25 <troydm> julian-goldsmith: you want to process it functionally in C# ?
14:21:36 <julian-goldsmith> yeah, using linq
14:21:43 <shachaf> julian-goldsmith: We answer off-topic questions sometimes, but this is past the line.
14:21:47 <CADD> dmwit: oh, kk
14:21:51 <chunkstuntman> Prelude.foldl (\acc tri -> if inTriangle (Point 0.0 0.0) tri then (acc + 1) else acc) 0 (textToTri file)
14:21:59 <chunkstuntman> I'm told I need to declare 0 as a Num
14:22:03 <chunkstuntman> I'm not totally sure why
14:22:12 <shachaf> chunkstuntman: I doubt that's what GHC is saying.
14:22:22 <solrize_> linq is sort of like sql i thought
14:22:27 <chunkstuntman>  No instance for (Num (IO t0))
14:22:27 <chunkstuntman>       arising from the literal `0'
14:22:29 <chunkstuntman>     Possible fix: add an instance declaration for (Num (IO t0))
14:22:32 <julian-goldsmith> kind of, i guess
14:22:49 <johnw> chunkstuntman: texToTri returns an IO action
14:22:50 <julian-goldsmith> it basically adds map- and filter-like functions to arrays and lists
14:23:01 <roboguy_> julian-goldsmith: probably could use a fold. I'm not sure about linq, but I would guess there's an equivalent
14:23:08 <dmwit> chunkstuntman: At a guess: this is part of a larger chunk of code; perhaps a line in a do-block. That larger chunk of code expects the result of this fold to do some IO, but it doesn't do any.
14:23:15 <johnw> chunkstuntman: you need to put <$> textToTri file at the end of your line, instead of calling it directly
14:23:20 <dmwit> But I like johnw's guess better.
14:23:45 <shachaf> My guess: You need to go to lpaste.net and paste your full code and full error messages, other people will have to guess what the real problem is.
14:23:54 <dmwit> chunkstuntman: As a side note, in the future it's best to use lpaste.net or a similar place to give us the full code and the full error.
14:24:07 <julian-goldsmith> roboguy_: the problem is, i don't want to combine the fields, just manipulate them
14:24:07 <chunkstuntman> ok just a sec
14:24:09 * hackagebot module-management 0.13 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.13 (DavidFox)
14:25:02 <chunkstuntman> http://lpaste.net/90964
14:25:06 <roboguy_> julian-goldsmith: it looks like your combining fields to me. you're putting all the numbers together, all the names together, etc, right?
14:25:28 <johnw> chunkstuntman: try changing the $ to <$> in the second line of your main function
14:25:30 <shachaf> julian-goldsmith, roboguy_, troydm: Please take this discussion to another channel.
14:25:38 <dmwit> chunkstuntman: This is not the full code.
14:25:41 <johnw> shachaf++
14:25:42 <shachaf> chunkstuntman: That's not the full code.
14:26:02 <johnw> but they are right, this cannot be the full code
14:26:03 <dmwit> johnw: I now think you're barking up the wrong tree, and my guess was right.
14:26:07 <johnw> ok
14:26:14 <shachaf> chunkstuntman: In particular we don't know what splitFile, texxtToTri, inTriangle, Point are.
14:26:19 <dmwit> though it's impossible to tell yet
14:26:27 <johnw> yes, that's the real problem :)
14:26:36 <chunkstuntman> http://lpaste.net/90964
14:26:44 <johnw> aha!
14:26:50 <chunkstuntman> oh I'll post everything
14:26:50 <johnw> i was indeed wrong
14:26:53 <shachaf> Well, johnw's proposed fix certainly wouldn't work, unless there was a Num instance for IO something.
14:27:01 <johnw> ah, easy
14:27:09 <johnw> print $ Prelude.foldl
14:27:22 <johnw> he's evaluating a naked integer where an IO a is expected
14:27:38 <banister`sleep> CADD: 'never stopping' ?
14:27:55 <aristid> now that Eq and Ord are out of Num, there should be no reason why Num a => IO a can't be a Num instance :D
14:27:57 <banister`sleep> CADD: foldr (i think) is often used for infinite data structured whereas foldr is not
14:28:03 <banister`sleep> strucutres*
14:28:14 <johnw> banister`sleep: you meant to say foldl for that second scenario, right?
14:28:18 <Zer000> so I'm learning haskell and I thought I'd make a website to get better. I'm running the hello world Snap framework program and I'm editing the code in vim. There are a few things used in the program that look like they are defined in other, imported libs. My question is: can I open these modules (like Snap.Core) and see how the fn's are defined? And if so where do I find them?
14:28:29 <banister`sleep> johnw: yes, hehe
14:28:31 <julian-goldsmith> well, thanks for the help roboguy_ and troydm
14:28:33 <stairmast0r> why do i want to learn haskell?
14:28:34 <johnw> Zer000: on Hackage you'll find "Source" links
14:28:39 <stairmast0r> besides getting to read http://learnyouahaskell.com/ that
14:28:40 <julian-goldsmith> i'll probably beat on this some more then leave work
14:28:46 <johnw> i mean, in the haddocks you get linked to from Hackage
14:28:47 <julian-goldsmith> see you
14:28:51 <shachaf> Zer000: Try searching on Hayoo.
14:28:53 <dmwit> Zer000: You can use "cabal unpack" to get the source to any package that you installed from Hackage.
14:28:53 <shachaf> @where hayoo
14:28:54 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
14:29:01 <chunkstuntman> boom I got it
14:29:03 <shachaf> Or that, if you know what the package name is.
14:29:04 <chunkstuntman> thanks everyone
14:29:22 <chunkstuntman> it was ommitting the print call
14:29:23 <banister`sleep> shachaf: do you still do ruby?
14:29:25 <Fuuzetsu> I really wish we had a great jump-to-definition system that Agda does
14:29:37 <dmwit> stairmast0r: You might Google "why functional programming matters" as one essay on the topic.
14:29:47 <dmwit> stairmast0r: Though I don't think that's Haskell-specific.
14:29:55 <Fuuzetsu> at the moment we have to make due with tags and hoogle
14:29:57 <dmwit> ?where faq
14:29:57 <johnw> banister`sleep: I have yet to find a use for foldl.  I use foldl' when I know that the function I'm using is strict in its arguments, and foldr otherwise.  Maybe others have more to say on that, though
14:29:58 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:29:59 <shachaf> banister`sleep: I do everything and nothing.
14:30:03 <banister`sleep> shachaf: as an ex-rubyist and a brilliant haskeller, can you give me your honest opinion of this? https://github.com/banister/funkify
14:30:07 <chunkstuntman> stairmast0r: because it makes solving problems fun
14:30:14 <stairmast0r> chunkstuntman: how?
14:30:20 <johnw> shachaf is an ex-rubyist?
14:30:24 <Zer000> so is hayoo like readthedocs for python stuff?
14:30:32 <shachaf> johnw: No.
14:30:35 <banister`sleep> johnw: many language (like ruby) *only* have foldl, so i intuitively know when/how to use that, foldr on the other hand is a head fuck
14:30:59 <shachaf> I still use Ruby.
14:31:12 <chunkstuntman> stairmast0r: functional programming allows you to solve a problem without a lot of headaches imperative programming can bring
14:31:14 <johnw> banister`sleep: well, those other languages probably weren't lazy, so I'm guess they didn't have a motivating use case for foldr
14:31:15 <roboguy_> banister`sleep: it's the opposite for me, I mostly use foldr so I find foldl a little weird whenever I use it
14:31:30 <Nisstyre> banister`sleep: if the operation is associative it shouldn't matter apart from the order of parameters, and the implementation details
14:31:38 <dmwit> stairmast0r: Haskell is lazy; functional; is committed to purity; and has a top-notch type system. I think each of these is a serious advantage and am happy to talk about each.
14:31:45 <banister`sleep> shachaf: cool, can you look at that lib and give me your opinion, just peering at the readme is fine, but if you're not in the mood that's fine too :)
14:32:03 <johnw> banister`sleep: if the function you're folding with is strict in both argument, then in an imperative language foldl will likely use less stack (though it all depends on how that language is optimized)
14:32:20 <johnw> shachaf: What do you use ruby for, if I may ask?  Feel free to answer in -blah
14:32:21 <jfischoff> dmwit: can you explain why lazy is better than strict?
14:32:28 <dmwit> http://stackoverflow.com/questions/7868507/non-trivial-lazy-evaluation
14:32:31 <Nisstyre> who said it is?
14:32:57 <hpc> jfischoff: he can also explain why strict is better than lazy!
14:32:58 <shachaf> banister`sleep: I don't have much of one.
14:33:05 <Nisstyre> why is lazy better than non-strict?
14:33:10 <jfischoff> hpc: :)
14:33:18 <dmwit> Nisstyre: Because it has better memory usage.
14:33:26 <dmwit> and potentially does less work
14:33:35 <Nisstyre> good answer
14:33:41 <roconnor> Nisstyre: because (\x -> f) t is equivalent to f[x -> t]
14:33:44 <shachaf> @google augustss lazy
14:33:45 <lambdabot> http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
14:33:46 <lambdabot> Title: Things that amuse me
14:33:46 <tromp__> because it lets you compute the list of *all* prime numbers, for instance
14:33:58 <tromp__> and then take only what you need
14:34:25 <dmwit> roconnor, tromp__: These factors don't seem to differentiate lazy and non-strict to me.
14:34:54 <tromp__> no, that differntiates from strictness
14:34:56 <roconnor> dmwit: well I'd be happy with opportunistic evaluation.
14:35:10 <jfischoff> shachaf: although Mu Haskell is strict
14:36:14 <roconnor> I always presume questions about laziness are really about call-by-need semantics.
14:36:26 <dmwit> jfischoff: (In case it wasn't clear: the SO answer I posted was in response to your question.)
14:36:57 <shachaf> The augstss link I posted was, too.
14:37:00 <shachaf> augustss
14:37:18 <dmwit> right
14:38:08 <jfischoff> dmwit: thanks. I agree with Harper on augustss blog that function reuse is probably the biggest win (with non-strict, I guess you adressed lazy more)
14:38:24 <dmwit> I agree.
14:38:52 <roconnor> Is the name for the semantics of lazy evalation really "non-strict".  That is such a terrible name.
14:39:07 <c_wraith> no
14:39:09 * hackagebot penny-lib 0.16.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.16.0.0 (OmariNorman)
14:39:19 <shachaf> I think that's agreeing with augustss, not Harper.
14:39:25 <dmwit> I think "non-strict" just means "any evaluation order that wins whenever it's possible to win".
14:39:41 <c_wraith> lazy evaluation is call-by-need, specifically
14:39:49 <shachaf> Should be called "optimal semantics", clearly.
14:39:53 <shachaf> Or "best semantics".
14:40:08 <c_wraith> non-strict is just "not call-by-value"
14:40:10 <jfischoff> c_wraith: thanks for the clearity
14:40:15 <shachaf> c_wraith: Yes, but the name for the *semantics* of lazy evaluation is "non-strict".
14:40:26 <jfischoff> dmwit: I knew what you meant :)
14:40:41 <c_wraith> shachaf: well, no there are many options for non-strict semantics
14:40:51 <roconnor> or "semantics-where-functions-are-actually-abstractions-instead-of-an-evaluation-hinting-mechanism"
14:40:55 <c_wraith> shachaf: non-strict does not imply lazy
14:40:58 <shachaf> c_wraith: The semantics that laziness implements.
14:41:18 <dmwit> Perhaps c_wraith is talking operational semantics and shachaf is talking denotational semantics.
14:42:28 <shachaf> At any rate I understood roconnor. :-)
14:43:11 <hpc> dmwit: where "wins" = "terminates"
14:43:15 <roconnor> I have this problem in CS all the time.  Is a (simple) traveral an element of type Applicative f => (b -> f b) -> (a -> f a), or is a traversal any value of a type isomorphic to that such as (a -> KleeneStore b a)?
14:43:35 <roconnor> is a traversal an concept or a concrete realization?
14:43:54 <banister`sleep> lol https://github.com/mame/quine-relay
14:44:06 <banister`sleep> "An uroboros program with 50 programming languages"
14:44:09 * hackagebot penny-bin 0.16.0.2 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.16.0.2 (OmariNorman)
14:44:11 <johnw> isn't lazy evaluation just one implementation choice for encoding non-strict semantics?
14:44:38 <solrize_> yes
14:44:40 <johnw> it's nice of Omari to mention ledger in the first sentence of penny-bin's documentation
14:45:15 <roconnor> there are other evaluation strategies, such as ever time you reduce a lambda, you check another value of the Collatz Conjecture.
14:45:16 <shachaf> I'm not exactly sure what you mean by "encoding".
14:45:22 <dmwit> hpc: Well. I think it's more than just termination, or else my crappy semantics that never takes any steps wins an awful lot. =)
14:45:29 <johnw> I was trying to avoid saying implementing again
14:46:45 <stevejb> hello, does anyone have a second to try to reproduce the example at the following: http://hackage.haskell.org/packages/archive/hmatrix/0.15.0.0/doc/html/Numeric-GSL-Root.html#t:RootMethod
14:46:49 <stevejb> it is giving me a segfault
14:46:56 <roconnor> did we manage to answer the original question?
14:47:00 <shachaf> Beta-reduce, alpha-reuse, eta-recycle.
14:47:29 <dmwit> stevejb: I don't see an example there?
14:47:56 <stevejb> dmwit: where it says "
14:48:01 <stevejb> "the example in the GSL manual"
14:48:22 <dmwit> Oh. Why did you link to an anchor at the bottom of the page, then?
14:48:27 <stevejb> oh, oops
14:48:31 <stevejb> I must have scrolled up
14:48:33 <dmwit> It segfaults here, too.
14:48:56 <stevejb> dmwit: alright, thank you for letting me know. I will ping the author. I wanted to make sure it wasn't just me. Thanks
14:49:32 <dmwit> roconnor: Well, the person asking the original question hasn't spoken in a while, so... success? -_-
14:51:56 <roconnor> \o/
15:01:42 <notdan> http://lpaste.net/90966 why can GHC derive all of those except for MonadTrans? :S
15:02:44 <notdan> Even for a simpler type: StateT String (StateT Int m) a
15:02:46 <Peaker> notdan, because GeneralizedNewtypeDeriving uses the underlying instance of the type inside (in your case, ErrorT's)
15:03:30 <notdan> Right, ErrorT is monad and we can lift (m a) to ErrorT m a, right?
15:03:34 <dmwit> notdan: ...and to connect the dots, ErrorT's MonadTrans instance has the wrong type; it goes from m to ErrorT m instead of from m to ErrorT ReaderT StateT m.
15:04:08 <dmwit> (Excuse my informality.)
15:04:16 <hpc> dmwit: ??
15:04:17 <Peaker> notdan, the MonadTrans you need is a composition of two lifts, but that's new code. GeneralizedNewtypeDeriving only makes some code available from one type to the newtype
15:04:42 <dmwit> Okay, more formally, since the informal version seems to be confusing to at least one expert.
15:05:15 <shachaf> I undertoodmwit.
15:05:17 <dmwit> ErrorT's instance gives you a function for free named lift which goes from an "m a" to an "ErrorT ActionError (m a)". But that's not what you need to implement MonadTrans for ActionT.
15:05:18 <shachaf> s
15:05:35 <dmwit> You need to go from an "m a" to an "ErrorT ActionError (ReaderT ActionEnv (StateT Response m)) a".
15:05:55 <Lethalman> what do you guys think about http://paste.debian.net/16447/
15:05:55 <hpc> oh, i see
15:06:22 <Lethalman> mfoldMaybe
15:06:28 <shachaf> GeneralizedNewtypeDeriving will only give you "trivial" instances, more or less.
15:06:54 <Peaker> and broken trivial instances too :)
15:06:54 <shachaf> I.e. instances whose code is already written.
15:06:58 <shachaf> Right.
15:07:08 <notdan> Ok, so the lift I need is basically a composition of several lifts?
15:07:14 <dmwit> yes
15:07:28 <dmwit> plus some newtype nonsense =)
15:07:36 <Peaker> Lethalman, I hate using x `seq` f x   that's what (f $! x) is for
15:07:56 <Lethalman> Peaker, but that has two arguments :P
15:08:11 <Peaker> Lethalman, (f $! x $! v)
15:08:14 <notdan> thanks, dmwit, newtype nonsense is exactly what I forgot and it was giving me cryptic messages
15:08:16 <Lethalman> ah
15:08:19 <Peaker> or parens to make it left-associative
15:08:24 <Lethalman> right :-) thanks
15:08:48 <hpc> fun bit of subtlety: (f $! x $! v) evaluates v first
15:08:50 <Peaker> Lethalman, this looks more like an unfold than a fold
15:08:55 <Peaker> @type unfoldr
15:08:55 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:09:08 <Lethalman> :t foldr
15:09:12 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:09:17 <Lethalman> I wouldn't think so, you're folding the m (Maybe a)
15:09:36 <Peaker> Lethalman, maybe "whileJust" would be a better name
15:09:47 <Lethalman> Peaker, whileJust doesn't let me fold
15:09:54 <dmwit> Lethalman: You might like unfoldM from monad-loops?
15:10:04 <shachaf> hpc: You mean with the parentheses?
15:10:08 <Lethalman> dmwit, has no Maybe
15:10:15 <dmwit> um?
15:10:18 <shachaf> ((f $! x) $! v)?
15:10:24 <dmwit> unfoldM :: m (Maybe a) -> m [a] -- does too have a Maybe
15:10:45 <Lethalman> dmwit, ehm sorry confused, it returns a [a] not another thing
15:10:45 <quchen> hpc: I don't think that v is evaluated first. seq doesn't have a prescribed evaluation order.
15:10:56 <Peaker> Lethalman, also, why do the forcing inside the function, when 'f' could have done it?
15:10:56 <dmwit> Lethalman: So lift a fold.
15:11:02 <dmwit> e.g. foldl'
15:11:04 <quchen> hpc: I should rephrase, "v is not necessarily evaluated first".
15:11:13 <Lethalman> dmwit, how?
15:11:33 <dmwit> :t \f z -> liftM (foldl' f z)
15:11:33 <Lethalman> Peaker, because foldl' does it, no?
15:11:47 <dmwit> Does lambdabot hate me?
15:11:50 <lambdabot> Monad m => (r -> b -> r) -> r -> m [b] -> m r
15:11:53 <Peaker> @src foldl'
15:11:53 <lambdabot> foldl' f a []     = a
15:11:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:12:00 <FreeFull> @src lambdabot
15:12:01 <lambdabot> Source not found. Do you think like you type?
15:12:06 <dmwit> Lethalman: Like that.
15:12:15 <Lethalman> dmwit, foldl needs a list, I don't think you can't get to my mfoldMaybe
15:12:25 <dmwit> whaaaat
15:12:34 <Peaker> Lethalman, note that foldl' forces the result of f, not the args of f
15:12:34 <Lethalman> :S
15:12:54 <Lethalman> Peaker, yeah, was lazy :P
15:12:58 <Peaker> Lethalman, the args of f can be forced by f itself, or a wrapper to f
15:13:05 <dmwit> :t let unfoldM :: Monad m => m (Maybe a) -> m [a] in \f z m -> liftM (foldl' f z) (unfoldM m)
15:13:06 <Lethalman> Peaker, right
15:13:07 <lambdabot>     The type signature for `unfoldM' lacks an accompanying binding
15:13:08 <lambdabot>     Not in scope: `unfoldM'
15:13:08 <lambdabot>     Perhaps you meant one of these:
15:13:16 <dmwit> :t let unfoldM :: Monad m => m (Maybe a) -> m [a]; unfoldM = undefined in \f z m -> liftM (foldl' f z) (unfoldM m)
15:13:19 <lambdabot> Monad m => (r -> b -> r) -> r -> m (Maybe b) -> m r
15:13:21 <dmwit> Lethalman: ?
15:13:27 <Lethalman> awesome
15:13:28 <Lethalman> \o/
15:14:10 <Lethalman> dmwit, but it still returns an [a]
15:14:13 <Lethalman> :-)
15:14:22 <Lethalman> or not
15:14:26 <dmwit> I don't see any brackets anywhere in that type.
15:14:28 <Lethalman> eek how did it gone?
15:14:45 <Lethalman> :S
15:14:59 <Lethalman> :t liftM (foldl' f g)
15:15:02 <lambdabot> (Monad m, Show r, Show b, FromExpr r) => m [b] -> m r
15:15:09 <Lethalman> :t \f z -> liftM (foldl' f z)
15:15:11 <lambdabot> Monad m => (r -> b -> r) -> r -> m [b] -> m r
15:15:39 <Lethalman> ouch got it
15:15:45 <Lethalman> awesome thanks dmwit
15:15:57 <Lethalman> impressive :S
15:17:12 <cdk> has there been any talk as to including a Free monad implementation in the haskell platform? It's one of those things I find myself using more and more now that I'm familiar with it.
15:18:29 <acowley> Why does it have to be in the HP?
15:19:09 <jfischoff> I can't see many HP users asking for that
15:19:41 <cdk> for ease of access mostly, so I dont have to drag the free package and all its dependencies every time I want to use an AST of some kind.
15:19:54 <dmwit> BOOOO
15:19:56 <acowley> I just feel like cabal-install is good enough that the de factor platform defined by the packages I use is so easily installable as to not matter
15:20:12 <dmwit> I really dislike the "lots of dependencies" argument for not using code.
15:20:19 <acowley> agreed!
15:20:39 <acowley> I actually *love* that when I install some of my work on a fresh machine it downloads over 100 packages
15:20:47 <hpc> heh, i actually had to defend pandoc to someone the other day on that argument
15:20:53 <dmwit> Thank goodness! 100 packages worth of code I don't have to write myself!
15:20:59 <acowley> It gives such wonderful granularity to swapping out pieces of dependencies
15:21:21 <acowley> dmwit: exactly! And if one piece rots, I don't have to perform surgery on some big monster package.
15:24:48 <zRecursive> :t liftA2
15:24:49 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:47:43 --- mode: banks.freenode.net set +o ChanServ
15:48:01 <roboguy_> wow that was a big net split
15:48:02 <mapreduce> Tell him we need his Hoogle for the mainstream languages.
15:48:04 <acowley> Yeah, riding it made me slightly seasick
15:48:17 <gusto> yes
15:48:30 <gusto> that was a big one
15:48:32 <mapreduce> I ignore joins and parts, I feel like a just missed a Dr. Who episode.
15:48:33 <mapreduce> s/a /I /
16:03:41 <djahandarie> Cabal honestly just pisses me off now.
16:03:48 <djahandarie> I don't think I've ever had it "just work".
16:04:24 <djahandarie> Within like a few weeks of a completely clean slate, just simple installs are bound to start trying to reinstall things and break packages.
16:05:17 <RichyB> Installing separate programs into separate hsenvs works for me.
16:08:51 <acowley> I'm just really careful in general
16:09:10 <acowley> I hadn't had a cabal problem until recently when I tried something using yesod
16:09:34 <acowley> otherwise, I've found that being merciless with ghc-pkg unregister keeps me feeling fresh and clean.
16:19:15 <Ghoul_> if I get a stack overflow, what could be the cause?
16:19:21 <Ghoul_> (under -O2)
16:20:26 <orzo> a memory leak
16:20:35 <acowley> Usually a foldl whose accumulator isn't forced
16:20:39 <c_wraith> Ghoul_: the usual cause is building up a giant thunk that requires too much stack space to evaluate
16:22:00 <Ghoul_> so increasing laziness, then, isn't the way to fix it
16:22:15 <acowley> No
16:22:20 <acowley> Unless you don't need the result
16:22:32 <acowley> But the stack overflow suggests you do need it
16:27:50 <Ghoul_> Could it not be my fault? ie: could I get it from doing mapM_ f [1..2000000] regardless of what f is?
16:28:43 <c_wraith> mapM_ should never result in the stack overflowing.
16:28:52 <Ghoul_> oh, darn.
16:29:02 <c_wraith> unless the monad's (>>) uses up stack space, for some reason.
16:29:05 <acowley> I guess the monad itself could
16:29:17 <acowley> sigh, c_wraith and I are like 2s out of sync
16:29:24 <acowley> we need to work on that
16:31:17 <applicative> I think the monad could do it ;)
16:31:56 <acowley> applicative: you need to run ntpdate-haskell
16:32:43 <Ghoul_> well, my monad could wind back time which is /one way/ of fixing that :)
16:34:19 <Ghoul_> I tried adding bang patterns everywhere possible in `put` and `step` and it doesn't seem to fix the stack overflows. I'm thinking I have a space leak - maybe one of you could identify it on sight; https://gist.github.com/kvanberendonck/5997267
16:34:57 <Ghoul_> changing [1..2000000] to have one less zero, that is 200,000 causes the overflow to not happen
16:36:39 <acowley> Ghoul_: You could try making ChronoS strict in its s parameter
16:36:42 <Saizan> Ghoul_: foldl is almost never what you want, foldl' should be better
16:37:05 <Ghoul_> thanks, I'll do both those things :)
16:37:39 <Ghoul_> :t foldl'
16:37:40 <lambdabot> (a -> b -> a) -> a -> [b] -> a
16:39:00 <Ghoul_> Making it strict in it's s parameter (did I do it right? ChronoS :: Keystone s e => [e] -> !s -> [e] -> ChronoS s e ) doesn't fix the overflow
16:39:11 * hackagebot active 0.1.0.5 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.5 (BrentYorgey)
16:39:19 <c_wraith> No, you have to do it in the value level, not the type
16:39:59 <elliott> I doubt it would have even compiled if you said "-> !s ->"
16:40:10 <elliott> if it did, perhaps a GHC bug.
16:40:53 <shachaf> Works for GADTs.
16:41:00 <Saizan> well, record syntax works there, why not bangs
16:41:13 <josephle> just define type constructor ! :: * -> *
16:41:18 <Ghoul_> it compiled fine :)
16:41:58 <Ghoul_> okay, I threw a bang onto every single thing in step and put that didn't give a syntax error (including the entire ChronoS and each of its members), and changed all the $'s into $!'s and still no luck :(
16:42:11 <elliott> are you sure it's actually compiling?
16:42:26 <elliott> if you see no change and also claim "!s" worked as a type, then I suspect it actually isn't getting compiled, or you're running the old version somehow, or such.
16:42:41 <shachaf> elliott: This is a GADT.
16:42:45 <shachaf> "ChronoS :: ..."
16:42:49 <elliott> oh
16:42:52 <Ghoul_> yes, here's what I tried: http://lpaste.net/90968
16:43:03 <elliott> and people say GADT constructor syntax is more uniform
16:43:05 <Ghoul_> and im using -fforce-recomp and it appears to be compiling
16:46:32 <acowley> Could the lazy StateT be doing this?
16:46:37 <Saizan> Ghoul_: just "import Control.Monad.State.Strict"
16:46:49 <Saizan> Ghoul_: and the bang on the 's' field of ChronoS
16:47:15 <Ghoul_> yes, that worked :)
16:47:21 <Ghoul_> thanks
16:47:36 <acowley> No stack overflow is safe from #haskell.
16:47:49 <Ghoul_> lol
16:48:25 <applicative> oh lazy StateT bad
16:48:34 * applicative is still on 4 minute delay
16:49:24 * applicative doesn't have any business knowledge so he can't win FPComplete's prize :( 
16:49:44 <thoughtpolice> oh look, it's acowley
17:00:17 <raisdead> Is hpaste.org down?
17:00:36 <geekosaur> @where hpaste
17:00:36 <lambdabot> http://lpaste.net/new/haskell
17:00:39 <djahandarie> It has moved to lpaste.net
17:00:42 <geekosaur> new domain name
17:00:46 <geekosaur> same site
17:00:51 <raisdead> thanks
17:04:12 * hackagebot active 0.1.0.6 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.6 (BrentYorgey)
17:25:46 <johnw> if the top consumer in my heap profile is "ghc-prim:GHC.Types.:", does anyone know what that would indicate?
17:26:00 <elliott> that looks like (:)
17:26:05 <elliott> i.e. a cons cell
17:26:14 <johnw> does that indicate a great deal of thunking?
17:26:24 <johnw> or just tons o' conses
17:26:35 <johnw> ok, that makes sense, thanks elliott
17:29:52 <erisco> if you are building up a list during a calculation, but no longer need older results, is it beneficial to use init?
17:30:14 <erisco> does this allow gc to collect discarded parts?
17:30:32 <c_wraith> well, yes..  But I'd really look at generating the list in the other order
17:30:40 <c_wraith> init is a slow operation
17:31:07 <erisco> the entire list is being traversed anyways, and if I store it in the other direction it has to be reversed anyways
17:31:41 <c_wraith> If you're not adding new things to the list, there's little real benefit
17:31:46 <erisco> I am
17:32:11 <erisco> only a finite number of items become relevant on the list ... additional values don't hurt, but aren't necessary
17:32:49 <erisco> what is the strictness of init? shouldn't it only be doing a lookahead and returning [] one element from the back?
17:33:30 <shachaf> Things'll only be GCed when you traverse the entire list that init returns (and have no references to the original list), yes.
17:34:40 <erisco> hmm... I don't know if I'll actually hit the end... I'm zipping two lists together. even if both are of equal length, if the left list ends perhaps the right list is never looked at
17:34:52 <erisco> so in that case I am just building up even more junk
17:35:11 <shachaf> init is in general a suspicious kind of function.
17:36:36 <erisco> I'll just leave a note in my code then, since it is only a question of memory consumption
17:36:58 <shachaf> It is possible that you don't want lists in the first place.
17:37:06 <erisco> I do
17:38:49 <bgamari> joeyh, ping
17:39:43 <dmwit> This entire line of questioning makes me very uncomfortable.
17:40:04 * erisco cackles with evil laughter
17:40:04 <acowley> dmwit: Wrong IRC window?
17:40:11 <dmwit> nope
17:40:24 <shachaf> I agree with dmwit.
17:40:34 <int80_h> Can someone provide a live link to "how to build a nomadic
17:40:38 <int80_h> Err
17:40:46 <int80_h> Trying again
17:41:20 <silasm> erisco: are you implementing something like a fixed-size sliding window? Because that's what it sounds like.
17:41:38 <erisco> silasm, indeed it would be like that
17:41:45 <int80_h> Can someone provide a live link to " how to build a monadic interpreter in one day"?
17:41:57 <silasm> look up circular queues. Not sure how they're implemented in Haskell, though.
17:41:58 <shachaf> Then why do you say that you want lists?
17:42:09 <echo-boom> what is wrong with this http://bpaste.net/show/114883/ ?
17:42:11 <echo-boom> :/
17:42:16 <silasm> You could probably implement them the same way as in imperative languages with vectors or ST Arrays.
17:42:28 <hpc> echo-boom: single-quotes
17:42:35 <hpc> :t 'a'
17:42:35 <lambdabot> Char
17:42:37 <hpc> :t "a"
17:42:37 <lambdabot> [Char]
17:42:44 <echo-boom> hpc: Thanks
17:42:50 <erisco> because the problem uses lists. this is one special case of that problem ... and furthermore, extra values are no problem, so like I said, it was only a curiosity of memory consumption
17:42:52 <shachaf> echo-boom: What hpc said, and also: foo x:y is parsed as (foo x) : (y)
17:43:15 <hpc> and thirdly, your function needs more patterns
17:43:17 <echo-boom> is this right rmSpace (' ':x) == rmSpace x ?
17:43:20 <shachaf> echo-boom: And also: A do block can't end with a let.
17:43:28 <hpc> oh, and a single equals instead of one
17:43:32 <shachaf> And also what hpc said. Which turns out not to be last after all.
17:43:37 <hpc> haha
17:43:45 <erisco> silasm, I only agreed because as an analogy, that is what it could be interpreted as ... not because I am looking for a ring buffer
17:44:03 <silasm> erisco: is it fixed size?
17:44:22 <erisco> it doesn't matter :P I'll just shut up now.
17:44:43 <echo-boom> hpc: rmSpace (' ':x) = rmSpace x i removed the do after main =  is this right now ?
17:45:04 <shachaf> echo-boom: I think you should step back a little bit and figure out what's going on.
17:45:22 <shachaf> What are you trying to accomplish?
17:45:33 <echo-boom> shachaf: removing the spaces
17:45:33 <silasm> erisco: fair enough. I'm kind of interested though, as LZ77 compression uses circular queues and I'm thinking about implementing it after I finish LZ78 compression.
17:45:38 <shachaf> Are you reading an introduction to Haskell or something like that?
17:45:51 <echo-boom> shachaf: yeah...
17:46:08 <shachaf> OK.
17:46:21 <shachaf> Well, there's no reason to use "let" to define that function. It can be top-level.
17:46:38 <erisco> silasm, well, like I said, the data structure I need to operate on is a list. it just happens to be, in one special case during calculation, that I can end up with a finite list ... in general they may be infinite.
17:46:44 <roboguy_> int80_h: it looks like archive.org archived it: http://web.archive.org/web/20130514222324/http://www.haskell.org/wikiupload/c/c6/ICMI45-paper-en.pdf
17:47:18 <erisco> silasm, so to use a circular queue from the outset isn't sensical. I suppose my problem isn't of interest to you then
17:47:38 <silasm> erisco: ah, makes sense. Thanks anyways.
17:49:49 <erisco> okay this next question will get flak: can I catch an irrefutable pattern exception?
17:50:23 <c_wraith> yes, you can.
17:50:52 <c_wraith> that's even one of the classes of exception caught in spoon, I think
17:51:43 <int80_h> Roboguy_: thanks :)
17:51:54 <hpc> erisco: oh dear god
17:51:58 <johnw> how weird, I just this second found a bug in one of my uses of spoon
17:52:03 <johnw> and there you are mentioning it
17:52:38 <johnw> my bug was that I didn't realize that spoon is essentially an exception-catching deepseq
17:52:59 <shachaf> teaspoon is better.
17:53:20 <hpc> did you try and spoon an infinite structure?
17:53:21 <johnw> thanks, I think that fits my use case better
17:53:28 <shachaf> spoon should be renamed to tablespoon.
17:53:33 <c_wraith> I agree
17:53:40 <shachaf> Or maybe evilspoon.
17:53:42 <erisco> hpc, I don't know what spoon is, but I am working on an infinite data structure, yes
17:53:45 <johnw> no, I'm spooning search results from Hoogle, to catch rendering errors, but Hoogle uses a LOT of memory if you deepseq its results
17:53:46 <shachaf> deepspoon?
17:53:50 <c_wraith> hpc: based on his previous remark, I think spoon was forcing a list and wasting memory
17:54:09 <johnw> ladel
17:54:25 <shachaf> You can easily implement spoon with teaspoon.
17:54:37 <shachaf> You can do it the other way around too but you have to be mildly evil.
17:54:44 <shachaf> And use a newtype.
17:54:56 <johnw> ladle?
17:54:56 <shachaf> Therefore: teaspoon is the future.
17:55:07 <erisco> c_wraith, my two questions are unrelated, if you were referring to me
17:55:09 <johnw> yeah, teaspoon should be the new spoon
17:55:19 <johnw> now I have to re-evaluate every use I've ever made of spoon
17:55:34 <c_wraith> erisco: no, I was referring to johnw and his mentions of huge amounts of (:) in his heap profiles
17:55:51 <hpc> i wish hoogle was back up; it's my entry point to hackage 95% of the time...
17:56:10 <johnw> hpc: http://fpcomplete.com/hoogle
17:56:15 <erisco> oh, so spoon was entirely unrelated ... silly me :)
17:57:07 <c_wraith> erisco: no, spoon is somewhat related to your question.  It's an example of something that does catch that exception.
17:57:27 <erisco> ah, so I am not necessarily doing something wrong
17:59:00 <johnw> yep, that fixed my bug
17:59:01 <johnw> just s/spoon/teaspoon
17:59:12 <erisco> dunno what spoon is using it for, but I need to return results that might turn out to be invalid later down the line, but that line is infinite so I can't lookahead to cull returning the result altogether
17:59:26 <johnw> 3 hours of debugging to find that
17:59:40 <erisco> so, basically, the job of backtracking needs to be given to the caller ... and based on what I've seen, I'll have to catch that exception to do so
18:00:59 <erisco> kinda like.... [Just 1, Just 2, Just 3 ... on we go, then something bad happens, and we give the caller ... Nothing], which indicates the entire result is bunk
18:01:19 <shachaf> :t sequence
18:01:19 <lambdabot> Monad m => [m a] -> m [a]
18:01:32 <thoughtpolice> shachaf: i think spoon should definitely be evilspoon
18:02:01 <shachaf> thoughtpolice: Remember when I wrote EvilBazaar?
18:02:51 <shachaf> https://github.com/ekmett/lens/commit/7ec5e55c130093ad3f3428da12f866453d9f8412
18:04:37 <shachaf> Then I discovered that it was possible to replace unsafeCoerce with undefined and it still worked.
18:04:44 <shachaf> Completely gratuitous unsafeCoerce.
18:06:09 <erisco> magical: http://lpaste.net/90974
18:06:13 <c_wraith> unnecessarilyUnsafeCoerce
18:07:36 <jkoppel> Anyone else having issues with Hoogle?
18:07:50 <optimusbrine> yep, everyone
18:07:58 <shachaf> jkoppel: Yes. See topic.
18:08:12 <erisco> does it download in 28MB distributable now? :)
18:09:18 <jkoppel> schachaf: Thanks
18:27:47 <NemesisD> hi guys, i'm working through an idea and wanted to get some feedback
18:28:46 <Moggle_> I'm reading Computational Category Theory and oh god ML seems to be Haskell but with worse syntax in every way possible it's horrible (but really not that bad)
18:29:00 <NemesisD> it seems to me that a state machine with effectful transitions could almost be modeled as a monoid on the state and a ReaderT for the effects that should happen on transitions
18:29:24 <NemesisD> erm WriterT
18:31:45 <ezyang> What is the most painless way to convert a bytestring into a string? (assume it contains only ASCII)
18:32:04 <applicative> B.unpack
18:32:17 <ezyang> gives [Word8]
18:32:26 <applicative> no, Char8
18:32:28 <Clint> BC8.unpack
18:32:29 <applicative> should have said that
18:32:36 <applicative> like Clint says
18:32:44 <NemesisD> would i write a monad transformer that uses tell for changing the state but allows the instance to define a functions such that: class Monoid s => StateMachine s where onTransition :: s -> m a, i know im missing some type variables but does that make sense
18:32:57 <ezyang> oh Char8 uses the same base datatype
18:32:58 <ezyang> Handy
18:33:15 <shachaf> :-(
18:33:17 <applicative> yes,it's a pleasing hack
18:33:22 <shachaf> The "most painless way" *ought* to be decodeUtf8.
18:33:44 <shachaf> You should feel bad when you use .Char8. It's an experts-only sort of module.
18:33:44 <Clint> it ought to
18:33:46 <applicative> I was going to say, decodeUtf8 is in fact painless
18:34:04 <applicative> only it's not the *most* painless
18:34:09 <shachaf> Which decodeUtf8?
18:34:34 <shachaf> Data.ByteString.UTF8.toString is pretty painless.
18:34:36 <applicative> Data.Text.Encoding T.unpack . decodeUtf8
18:34:46 <shachaf> Data.Text.Encoding.decodeUtf8 requires you to go through Text.
18:34:53 <erisco> :t try
18:34:54 <lambdabot> Exception e => IO a -> IO (Either e a)
18:35:00 <erisco> :t catch
18:35:01 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
18:35:20 <jj515> pl \x y -> x . subtract y
18:35:25 <applicative> yes, shachaf but Text has the advantage that it has been maintained in the last 5 yrs
18:35:38 <applicative> well okay 3 years
18:35:51 <shachaf> I'm not saying not to use Text. I'm saying that it's painful.
18:36:12 <applicative> hey i wrote lenses once .^ utf8
18:36:22 <shachaf> And when you have a dozen of these in your program "(T.unpack . decodeUtf8)" gets annoying.
18:36:37 <echo-boom> does haskell works on haiku ?
18:36:42 <applicative> yeah thats why i wrote the lenses, they seem not to have been a win though
18:37:07 <shachaf> Anyway, now ezyang is going to use Data.ByteString.Char8, and write a program which is guaranteed not to be compatible with most languages in the world.
18:37:07 * applicative was first feeling that echo-boom was on some kind of drugs. 
18:37:09 <jj515> @pl \x y -> x . subtract y
18:37:10 <lambdabot> (. subtract) . (.)
18:37:13 <shachaf> Just because it's the most painless way.
18:37:32 <bscarlet> Text is UTF16. going through Text means two transcodes.
18:37:41 <applicative> shachaf: is BC8 that bad? i suppose itis
18:37:43 <shachaf> Indeed.
18:37:59 <applicative> bscarlet: are you worried about efficiency or Painlessness
18:38:24 <bscarlet> efficiency
18:38:35 <ezyang> shachaf: Am I absolved because the bytestring is from an ELF symbol table?
18:38:42 <ezyang> :)
18:38:57 <applicative> oh here's my isos for ezyang https://github.com/ekmett/lens/blob/master/experimental/Data/Text/Encoding/Lens.hs
18:39:05 <shachaf> ezyang: Nope.
18:39:22 <ezyang> aw come on, surely we're still far away from UTF-8 symbol tables...
18:39:24 <shachaf> ezyang: http://stackoverflow.com/questions/15295028/can-elf-symbols-be-represented-in-utf8
18:39:36 <ezyang> :<
18:39:43 <shachaf> Random person on the Internet says it could happen!
18:39:48 <applicative> oh wait they're not so simple, youd still need to compose with T.unpack
18:39:49 <shachaf> Anyway why make your program broken by design?
18:40:30 <ezyang> Hang on
18:40:40 <applicative> shachaf is at war against BC8
18:40:44 <ezyang> Arbitrarily picking UTF-8 is not obviously correct either; they could have used ISO 8859-1
18:41:13 <shachaf> Arbitrarily picking UTF-8 *is* correct because UTF-8 is the standard.
18:41:33 <shachaf> If you don't want to pick an encoding then you can use a sequence of bytes and that's fine too.
18:42:16 <shachaf> If you want to pick an encoding, and this is UNIX, then pick UTF-8. ISO-8859-1 is broken, and UTF-8 is a de facto standard, and a good encoding.
18:42:52 <bscarlet> shachaf: broken?
18:43:13 <Clint> even more broken than ISO-8859-15
18:43:38 <applicative> Data.Text has encode/decodeLatin1 bos seems to think its worth supporting
18:43:42 <shachaf> bscarlet: Yes, it doesn't work for the majority of the world's population.
18:44:04 <bscarlet> shachaf: not universal is not the same as broken.
18:44:20 <applicative> isn't utf8 supposed to map things to 'unicode' characters?
18:44:33 <elliott> it seems like elf string tables are binary data
18:44:35 <applicative> that's already a decisive objection
18:44:38 <elliott> if it's just "anything terminated by \0"
18:44:43 <elliott> er *symbol tables
18:44:46 <shachaf> I agree with elliott, of course.
18:44:53 <elliott> so you should keep it as ByteString and not convert to String if possible, I think
18:45:19 <shachaf> As I said, it should be sequences of bytes. But *if* you need to "decode" it for some use, you should use UTF-8.
18:45:24 <applicative> well , but are Haskell word8s standard word8s?
18:45:49 <bscarlet> applicative: ?
18:45:54 <applicative> ezyang posed the question of encode/decode
18:45:59 <shachaf> bscarlet: In this case it pretty much is.
18:45:59 <applicative> just kidding bscarlet
18:46:24 <thoughtpolice> part of an ELF symbol table *is* a string (namely the name of the symbol itself,) but i'd agree, just pick UTF-8
18:46:51 <bscarlet> applicative: I never know around here. Sometimes people don't understand something major, sometimes people understand so much more than I do that the difference in understanding is similar to the first case.
18:47:16 <shachaf> Or sometimes people are just trolling. :-(
18:47:38 * applicative is trolling shachaf. Why not, it's only fair.
18:47:50 <shachaf> thoughtpolice: It can hardly be a string without an encoding. :-)
18:47:54 <Ralith> thoughtpolice: I think the point was the name of the symbol is a byte sequence terminated by \0
18:48:37 <shachaf> applicative: I would appreciate it if you don't troll me, or this channel.
18:48:52 <applicative> uh, same here
18:49:40 <applicative> hm, the binary hoogle I have begins with ELF but I don't think the rest of it is going to be decodable by standard means...
18:51:33 <gentleben> support for 8859-1 while annoying is necessary
18:52:28 <shachaf> It is necessary in some cases, but it should not be the default.
18:53:02 <b2coutts> is there a way to apply a list of arguments to a function? i.e., apply (+) [1,2] -> 3
18:53:05 <shachaf> It's an experts-only sort of thing.
18:53:31 <shachaf> b2coutts: What should apply (+) [1,2,3] be?
18:53:40 <shachaf> What about apply id [succ,5]?
18:53:55 <applicative> b2coutts: foldr1 ?
18:53:58 <b2coutts> shachaf: both would be invalid
18:54:03 <applicative> oh
18:54:04 <bscarlet> It certainly seems an unwise default. I suppose there's actually a decent argument for using the encoding from $LANG.
18:54:11 <geekosaur> how do you plan to achieve that?
18:54:14 <applicative> then why not call it a pair, b2coutts
18:54:22 <elliott> $LANG affecting how programs treat the files I have is sort of annoying.
18:54:28 <shachaf> "invalid" meaning what?
18:54:33 <b2coutts> applicative: it's not necessarily a pair
18:54:35 <elliott> files are objective. my preferences should not make them mean different things
18:54:40 <NemesisD> b2coutts: why not use (1,2)
18:54:53 <b2coutts> it would be a function that can be applied N times, and a list of N things
18:55:05 <bscarlet> elliott: An understandable perspective, especially on #haskell.
18:55:08 <applicative> wait, would you rather a function that returned a Maybe Int , giving nothing where there's not just two?
18:55:10 <b2coutts> and would apply the elements of the list to the function in order
18:55:14 <applicative> that sounds ikay
18:55:24 <geekosaur> b2coutts, that's actually pretty slippery in haskell
18:55:24 <applicative> okay rather
18:55:27 <NemesisD> this sounds an awful lot like foldr1 (+)
18:55:35 <NemesisD> unless i misunderstand
18:55:46 <b2coutts> geekosaur: yeah, I'm sort of realizing that it's hard to make sense of it in terms of a type
18:55:50 <applicative> NemesisD: that's what I thought, but its supposed to fail for three args
18:55:55 <b2coutts> which probably means haskell would get mad at me for trying to do it
18:55:58 <geekosaur> (where's that example of a fold that appears to take more parameters than it actually does, because it produces a function and applies it?)
18:55:59 <applicative> or rather three member lists
18:56:28 <NemesisD> b2coutts: why would you not have it be a pair if it only accepts 2 elements
18:56:32 <elliott> presumably the intention is that the list would take exactly the "arity" of the function.
18:56:50 <NemesisD> you're preferring a partial function here and i don't understand why
18:56:58 <elliott> b2coutts: anyway you should consider foo :: String -> Int -> ...; what should the type of apply foo be
18:57:02 <applicative> > let onGood f [x,y] = Just (f x y) ; onGood f _ = Nothing
18:57:02 <lambdabot>   not an expression: `let onGood f [x,y] = Just (f x y) ; onGood f _ = Nothing'
18:57:03 <elliott> well, s/.../()/
18:57:07 <b2coutts> NemesisD: because it could be any number of elements; the restriction is that the function can be applied at least as many times as the length of the list
18:57:27 <b2coutts> elliott: well, a consequence is that the function would have to take the same type for all arguments
18:57:43 <applicative> > let onGood f [x,y] = Just (f x y) ; onGood f _ = Nothing in map (onGood (+)) [[2,3],[]]
18:57:44 <lambdabot>   [Just 5,Nothing]
18:58:01 <NemesisD> b2coutts: so apply (+) [1,2,3] = 6?
18:58:21 <b2coutts> NemesisD: no; that would give an error, because (+) can't take 3 arguments
18:58:37 <NemesisD> b2coutts: is + a parameter, could i specify any function there?
18:58:43 <b2coutts> yeah
18:58:43 <zRecursive> > sum [1..3]
18:58:45 <lambdabot>   6
18:58:58 <applicative> any function that takes arguments of uniform type evidently
18:59:05 <b2coutts> ^
18:59:16 <b2coutts> provided that it can take at least as many arguments as there are things in the list
18:59:18 <Fuuzetsu> Does anyone actually use Haddock's LaTeX backend? I hear that some people would like to see it go
18:59:40 <NemesisD> b2coutts: variadic functions don't really work in haskell, at least as far as i know
18:59:53 <b2coutts> well, the function wouldn't necessarily be variadic
19:00:02 <roboguy_> b2coutts: is there a specific problem you're working on or are you just wondering how that would work in general?
19:00:18 <NemesisD> woudln't this require some form of dependent types to work?
19:00:28 <applicative> well, the apply combinatory takes function arguments of diverse adicities.
19:00:33 <ParahSail1n> @ty printF
19:00:36 <lambdabot>     Not in scope: `printF'
19:00:36 <lambdabot>     Perhaps you meant one of these:
19:00:36 <lambdabot>       `print' (imported from Prelude),
19:00:39 <thoughtpolice> > (printf "%s" hello :: String)
19:00:39 <ParahSail1n> @ty printf
19:00:41 <geekosaur> b2coutts, if it depends on the arity of the function you pass it, it is variadic
19:00:42 <lambdabot> PrintfType r => String -> r
19:00:42 <lambdabot>   Not in scope: `hello'
19:00:43 <thoughtpolice> > (printf "%s" "hello" :: String)
19:00:47 <lambdabot>   mueval-core: Time limit exceeded
19:00:50 <Fuuzetsu> Didn't Oleg show how to have a function that takes various amount of arguments? (*hides from the 1 ARGUMENT ONLY camp*)
19:00:51 <thoughtpolice> > (printf "%s %s" "hello" "world" :: String)
19:00:52 <lambdabot>   "hello world"
19:01:03 <thoughtpolice> what's with all the time limit stuff
19:01:09 <applicative> yes, b2coutts is very much in olegland
19:01:22 <NemesisD> olegland sounds scary
19:01:30 <Fuuzetsu> the fun kind of scary?
19:01:30 <applicative> no it's good
19:01:38 <b2coutts> geekosaur: the apply function itself? it would just take 2 arguments
19:01:49 <NemesisD> b2coutts: try writing the type of the apply function
19:01:50 <geekosaur> thoughtpolice, we don't know but suspect this lambdabot doesn't have the fix that was found (someone assumed threadDelay was milliseconds)
19:01:57 <geekosaur> b2coutts, no, the arity of its first parameter
19:02:06 <NemesisD> or anyone really, im curious
19:02:07 <zRecursive> :t fix
19:02:08 <lambdabot> (a -> a) -> a
19:02:20 <zRecursive> why do we need fix ?
19:02:21 <applicative> heres a path into olegland http://okmij.org/ftp/Haskell/vararg-fn.lhs
19:02:38 <applicative> in order to sacrifice before the god of turing completeness
19:02:43 <NemesisD> not tonight, i'm attempting to venture into write-your-own-monad-transformer land tonight
19:02:49 <geekosaur> think about how you would have to deal with that. (it *can* be done, with some difficulty and many limitations, but it's not trivial.)
19:03:53 <zRecursive> > fix $ \_ -> 100
19:03:54 <lambdabot>   100
19:04:07 <roboguy_> zRecursive: fix can make recursive lambdas
19:04:23 <roboguy_> zRecursive: or just in general find the least defined fix point, I guess
19:04:46 <roboguy_> that's the word on the street, anyway
19:04:48 <applicative> ah there, oleg's function is build 1 = [1] , build 1 2 = [1,2] etc
19:04:55 <zRecursive> roboguy_: you mean  fix $ \loop -> ... loop
19:05:22 <b2coutts> yeah, as I try to implement it this idea makes even less sense than I originally thought
19:05:41 <Fuuzetsu> I wish to be a quarter of the wizard Oleg is one day…
19:07:28 <roboguy_> zRecursive: yeah, that would be an example
19:07:29 <Fuuzetsu> @src fix
19:07:30 <lambdabot> fix f = let x = f x in x
19:07:52 <roboguy_> b2coutts: I feel like a fold might be what you're looking for
19:08:03 <roboguy_> even though it's different than what you described
19:08:16 <Fuuzetsu> roboguy_: isn't that just the generic answer to 99% of the problems?
19:08:18 <zRecursive> Fuuzetsu: thx
19:08:33 <roboguy_> Fuuzetsu: haha yeah, true
19:08:37 <b2coutts> nah, the actual issue is that I'm defining functions of type [Value] -> Value, when any particular function takes only a fixed number of Values
19:08:55 <NemesisD> so i was wondering if i could express an idea i had about a monad transformer clumsily and then you guys could help me figure out what instances i need to write if its possible
19:08:59 <b2coutts> and thought it would be nicer for me to work with if I defined functions of type Value -> Value -> ... -> Value
19:09:18 <Fuuzetsu> NemesisD: Doesn't us just telling you defeat the point of the exercise?
19:09:54 <NemesisD> Fuuzetsu: well it isn't really an exercise, its a real thing i want to make, and you don't have to tell me outright, i just detect that i have some misconceptions of transformer stacks
19:10:14 <Fuuzetsu> *shrug* just ask I guess
19:11:03 <geekosaur> roboguy_, it *is* a fold... but not one which has a type expressible in Haskell (at least not without some Olegy type hackery)
19:11:19 <NemesisD> so I thought you can model a state machine in a Monoid, has an initial state mempty and then a possible transition, mappend
19:13:24 <NemesisD> so if that makes sense, i'd like to write a transformer that, if your monad supports a Writer interface, the state there can store the state of your state machine, but you'd write an instance for a particular combination of StateMachineT m s and a function for that monad like transitionHook :: s -> s -> m a
19:14:17 <NemesisD> haven't thought about the type of transitionHook, it would mostly make sense for IO, i don't know what it would do in a pure context
19:15:03 <NemesisD> have i butchered the terminology/concepts enough?
19:15:15 <Fuuzetsu> Where are you even getting IO from?
19:15:59 <NemesisD> Fuuzetsu: the transition hook will take a before state, and after state and then potentially perform an effectful action
19:18:13 <lpaste> applicative pasted “variadic depravity” at http://lpaste.net/90975
19:18:28 <applicative> heres my attempt b2coutts
19:19:06 <NemesisD> transitionHook :: (Monad m, MonadWriter m, Monoid s, StateMachineT m s) :: s -> s -> m a; runStateMachine :: m s
19:19:39 <NemesisD> can't really think of a meaningful thing to do with the a there, but it makes sense that it be usable within the monad, just not in the final result
19:21:16 <Fuuzetsu> While I don't have anything meaningful to say about the problem itself, I think that you're trying too hard to make it into a transformer. Have you considered a naive solution and then changing it to use a transformer once you actually deem it necessary?
19:21:20 <NemesisD> Fuuzetsu: make sense?
19:22:50 <Fuuzetsu> I mean, usually you'd sit down and go ‘I have this problem, how can I solve it? Oh, I can use a monad transformer, cool’ rather than ‘How can I solve this problem using monad transformers?’
19:23:31 <NemesisD> Fuuzetsu: i think my tendency to the transformer was because i don't want to specify what monad the transitionHook runs in
19:24:09 <NemesisD> and changing the state seems a natural fit for the writer monad and a monoid instance
19:24:43 <Fuuzetsu> Personally I think that changing state is a better fit for State ;)
19:25:01 <Fuuzetsu> (which conveniently comes with StateT)
19:25:18 <lpaste> applicative annotated “variadic depravity” with “variadic depravity with 'nice' errors” at http://lpaste.net/90975#a90976
19:25:36 <applicative> b2coutts: this corrects a mistake ^^^
19:25:39 <NemesisD> Fuuzetsu: its more defined transitions though, which is why i thought monoid, you can't necessarily just set whatever state you want
19:26:13 <NemesisD> in fact this might have some interesting monadic semantics though, because if you do an invalid transition, say from Final to NonFinal it should probably terminate the monad
19:26:43 <NemesisD> if it isn't clear by now, calling this idea half-baked would be generous at this point
19:26:46 <Fuuzetsu> Last time I checked, going from final to non-final is fine
19:27:25 <NemesisD> Fuuzetsu: that's up to the user of the state machine
19:27:33 <Fuuzetsu> (consider any state machine that accepts the ‘(ab)*’ regex)
19:27:54 <NemesisD> the whole point of a state machine is that there are a number of valid transitions and some that are not
19:28:32 <NemesisD> at least the state machine that i'm trying to model
19:28:34 <NemesisD> some transitions between two states are not valid
19:30:45 <NemesisD> i have to run out for a bit bbl
19:41:58 <Luke> how can I get a list of a Type's value constructors?
19:44:56 <dmwit> Luke: You might want to look into generics and typeable. But really you might want even more to take a step back and think about the choices you've made to get into this position.
19:45:26 <dmwit> applicative, b2coutts: You might like http://stackoverflow.com/q/6168880/791604 which has half a dozen implementations of variadic functions.
19:45:46 <Luke> dmwit: this is for digestive functors. I think it's appropriate
19:46:28 <dmwit> okay, I feel pretty confident in believing you
19:47:22 <Luke> what do you mean?
19:49:01 <shachaf> Luke: Data.Data can do it.
19:49:16 <shachaf> Er, what's a Type? Is that TH?
19:49:22 <shachaf> I guess it is.
19:50:06 <dmwit> Oh, are we already in TH-land?
19:50:09 <Luke> I'm not using TH or anything
19:50:11 <Luke> no not yet
19:50:12 <shachaf> What is Type?
19:50:20 <Luke> just some type I have
19:50:27 <Luke> data X = A | B
19:50:36 <shachaf> Oh, not "Type". "type". Just a type.
19:50:43 <Luke> right
19:50:49 <Luke> the caps was a typo
19:51:09 <shachaf> Do all the constructors take no arguments?
19:51:42 <shachaf> I mean, you're asking for a strange thing. What type are you hoping this function would have?
19:51:50 <Fuuzetsu> Heh, just stumbled upon this http://i.imgur.com/0OxzpDN.png
19:52:05 <Luke> shachaf: the kind is *
19:52:12 <shachaf> OK, and the type?
19:52:18 <Luke> the type of what?
19:52:37 <shachaf> You want a thing, right? Maybe it's not a function, but it's something.
19:52:39 <Luke> oh the function to print the name of the types?
19:53:22 <shachaf> I don't know about printing. Whatever it is you're after.
19:53:24 <Luke> yeah just something to take a type of kind * and return it's data constructors if that exists
19:53:57 <shachaf> Can you give a first approximation of a type?
19:54:15 <applicative> dataTypeConstrs $ dataTypeOf (Just (3::Int))
19:54:17 <Luke> yeah it's literally just something like "data X = A | B | C"
19:54:24 <applicative> [Nothing,Just]
19:54:28 <Luke> perfect
19:54:30 <Luke> thanks
19:54:39 <dmwit> If all you want is all the inhabitants, then perhaps [minBound .. maxBound] will suit you.
19:54:41 <applicative> Luke import Data.Data I'm not sure what comes next, though ...
19:54:53 <shachaf> So yourThing :: Data a => Proxy a -> [Constr]?
19:55:02 <shachaf> Are you sure you want Constr?
19:55:08 <Luke> yeah
19:55:08 <dmwit> Or make it an instance of Universe. ;-)
19:55:14 <shachaf> I'm not asking these questions just to be annoying, I'm trying to figure out what you want.
19:55:23 <shachaf> What about a type like data X = A Int | B Void | C?
19:55:53 <Luke> shachaf: in that case just return A B C
19:56:02 <shachaf> What's A B C?
19:56:28 <Luke> the names of the constructors
19:56:36 <shachaf> So you're looking for strings here?
19:56:47 <shachaf> OK then. It sounded more like you were looking for the constructors themselves.
19:57:08 <Luke> constructors themselves. the names was just the answer to the question you asked
19:57:20 <monochrom> perhaps consider this question: assume you get the value constructors, what will you use them for?
19:57:20 <shachaf> I'm confused again.
19:57:22 <applicative> dataTypeConstrs $ dataTypeOf C
19:57:23 <applicative> [A,B,C]
19:57:35 <Luke> shachaf: yeah applicative already has it
19:57:51 <elliott> I don't know your problem, but I'm less sure than you are that what applicative gave is what you want
19:57:57 <johnw> hey Luke!
19:58:05 <johnw> how's der Schweiz treating you? :)
19:58:07 <applicative> I agree with monochrom this may not be of much use, but why shouldn't Luke investigate
19:58:14 <Luke> johnw: hey =)
19:58:25 <shachaf> Yes. And even if what applicative said is what you want, you should have answers to my questions somehow.
19:58:58 <Luke> shachaf: I'm trying to answer your questions
19:59:35 <Luke> to give some context, this is for use with the choice function of digestive functors
19:59:35 <shachaf> Luke: [A,B,C] is a type error, for instance. So clearly that's not what you meant.
19:59:50 <shachaf> monochrom's question is good. What do you do with the constructors?
20:00:06 <Luke> shachaf: again, for use with choice of digestive functors
20:00:40 <Luke> I want to ensure I have every constructor covered
20:01:07 <monochrom> completely useless tautological truism, or words of eternal wisdom, you decide :) : the solution depends on the problem
20:01:36 <johnw> monochrom: the good thing about tautological truisms, is that they are tautological truisms
20:01:40 <dmwit> Do you want a list of all a type's inhabitants?
20:01:44 <choptimusprawn> XD
20:01:48 <Clint> you want a stringtype<->constructor mapping
20:01:54 <dmwit> "covering every constructor" seems like a very strange thing to me.
20:01:58 <shachaf> I don't know anything about those. I bet there's a way of phrasing the question without involving web pages, though.
20:02:05 <shachaf> Er, the answer.
20:02:05 <Luke> dmwit: if that's the name of what I'm trying to describe I suppose
20:02:36 <dmwit> hm
20:02:45 <dmwit> Well, it's hard to tell if that's the name of what you're trying to describe. =)
20:02:55 <shachaf> OK, let me try to clarify.
20:03:13 <shachaf> Clearly you don't want the value [A,B,C], because that's a type error.
20:03:27 <shachaf> And clearly you don't want ["A","B","C"], because you said you want more than just the names.
20:03:58 <shachaf> So you want something else. You can get [Constr], but does that really do what you're after?
20:05:20 <Luke> I think it does but since I have no experience with Data.Data I have to mess around with it
20:05:35 <dmwit> Think about "Either Bool Ordering". Would you want the list [Left False, Left True, Right LT, Right EQ, Right GT] or something similar but in a different order? If so, you want all the inhabitants, and we can give good advice.
20:05:45 <Clint> i think he wants fromList [(A,"A"),(B,"B"),(C,"C")]
20:06:02 <shachaf> Clint: That's a type error.
20:06:16 <Clint> shachaf: [(X,String)] ?
20:06:20 <elliott> I think it would have helped to not have overloaded the names A, B and C here
20:06:31 <shachaf> A :: Int -> X
20:06:47 <dmwit> Or would you want ["Left", "Right"]? Or (Left, Right)? Or what?
20:07:18 <Clint> i thought they were all kind *
20:07:28 <Luke> they are all of kind *
20:07:41 <dmwit> kinds don't enter into it
20:07:54 <monochrom> > [Left, Right]
20:07:55 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
20:07:55 <lambdabot>    arising from a use ...
20:08:19 <shachaf> :t [Nothing, Just]
20:08:20 <lambdabot>     Couldn't match expected type `Maybe a0'
20:08:20 <lambdabot>                 with actual type `a1 -> Maybe a1'
20:08:20 <lambdabot>     In the expression: Just
20:08:30 <Clint> Luke: you basically want to take an enum and render it as an html form select list, right?
20:08:38 <Luke> Clint: yeah
20:09:01 <shachaf> When you say "an enum", does that mean that data X = A Int | B Void | C is disallowed?
20:09:05 <Luke> So I don't know the names of what I'm trying to describe but basically just type like "X = A | B | C" nothing else
20:09:28 <elliott> OK, then you should probably use Enum/Bounded and maybe Show
20:09:34 <elliott> dmwit will now advocate for universe instead
20:09:42 <dmwit> elliott: You're like 10 minutes late.
20:09:49 <elliott> (but if this is really the case then you surely don't want Data)
20:09:54 <monochrom> I advocate for multiverse :)
20:10:06 <monochrom> afterall, ...
20:10:06 <shachaf> I asked about that type exactly to figure out what was going on.
20:10:11 <monochrom> @quote monochrom Kripke
20:10:11 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
20:10:12 <shachaf> If the answer is "it's not allowed", that's fine.
20:11:05 <Luke> shachaf: even if it's allowed I just want the A B C portion, whatever that's called. again I have no names to describe these things
20:11:10 <dmwit> Enum/Bounded is easier in the "GHC will write almost all the code for you" sense. But universe can handle more types.
20:12:03 <Clint> if it's allowed, you're kinda screwed
20:12:22 * monochrom thinks up another useless tautological truism or words of eternal wisdom! the output depends on the input :)
20:12:23 <shachaf> Understanding whether it's allowed is important to answering your question.
20:12:52 <Luke> I'm not sure what you mean by "allowed". I don't have any types like that
20:13:13 <monochrom> "allowed" means "will you allow it? you."
20:13:17 <dmwit> Do you understand the proposal that's been made?
20:13:30 <Luke> dmwit: which proposal?
20:13:39 <dmwit> Use Enum and Bounded.
20:13:57 <dmwit> [minBound .. maxBound] :: (Enum a, Bounded a) => [a]
20:14:05 <Luke> I'm not familiar with those types. I'm looking things up here but you're asking questions faster than I can google
20:14:37 <dmwit> For types whose constructors have no arguments, GHC can write Enum and Bounded instances for you. Just use deriving.
20:14:44 <shachaf> > data Hello = A | B | C | D | E deriving (Show, Eq, Ord, Bounded, Enum)
20:14:45 <lambdabot>   <hint>:1:1: parse error on input `data'
20:14:48 <shachaf> @let data Hello = A | B | C | D | E deriving (Show, Eq, Ord, Bounded, Enum)
20:14:50 <lambdabot>  Defined.
20:14:52 * elliott is happy to explain things if you ask, personally; I don't include an explanation of how to use Enum/Bounded here only because you might decide it doesn't fit your problem
20:15:10 <shachaf> > [minBound..maxBound] :: [Hello] -- this is one possibility
20:15:14 <lambdabot>   mueval-core: Time limit exceeded
20:15:20 * dmwit sighs a gigantic sigh
20:15:21 <shachaf> > [minBound..maxBound] :: [Hello] -- this is one possibility
20:15:25 <lambdabot>   mueval-core: Time limit exceeded
20:15:26 <shachaf> I give up.
20:15:37 <elliott> > [minBound..maxBound] :: [Hello] -- this is one possibility
20:15:40 <lambdabot>   mueval-core: Time limit exceeded
20:15:47 <monochrom> that's strange
20:15:48 <elliott> I was hoping that would work so I could say it only works for me.
20:16:05 <dmwit> elliott: fix it ====((((
20:16:23 <Luke> I don't know the critical differences between Data.Data and Bounded Enum. Again I'm googling in the background here but I have some reading to do before I can tell you if either is a good fit
20:16:47 <elliott> dmwit: ok, ok, I'll stare at the mueval code for a few minutes before giving up
20:16:54 <shachaf> I agree. That's why I didn't propose any of these solutions. I still don't know the question.
20:16:57 <dmwit> good enough for me
20:17:08 <shachaf> But maybe someone else knows.
20:17:21 <Clint> > zip ([minBound..maxBound] :: [Hello]) (map show ([minBound..maxBound] :: [Hello]))
20:17:25 <lambdabot>   [(A,"A"),(B,"B"),(C,"C"),(D,"D"),(E,"E")]
20:17:30 <Luke> shachaf: the question is as explicit as I can be with my current understanding of these libraries I know nothing about ;-) I'm trying my best to answer here
20:17:37 <Clint> ^ is that what you want
20:17:38 <Luke> Clint: yeah that looks good
20:17:43 <Luke> thanks
20:17:59 <shachaf> Luke: The question is still this: What are you going to do with the constructors?
20:18:25 <Luke> shachaf: you've already looked at the digestive functors function I mentioned?
20:18:26 <shachaf> I would hope for an answer that doesn't involve web pages or digestion.
20:18:31 <b2coutts> how do you guys debug haskell code for runtime errors? My usual non-haskell approach is to insert print statements, but that doesn't really seem like a haskell-y way to do it
20:18:46 <Luke> shachaf: are you familiar with digestive functors?
20:18:54 <shachaf> No.
20:18:54 <ParahSail1n> print statements are the best way to do it in haskell
20:19:16 <haasn> Clint: map (id &&& show)
20:19:19 <dmwit> b2coutts: spamming commands in ghci is my number 1
20:19:25 <dmwit> b2coutts: Debug.Trace is my number 2
20:19:30 <shachaf> OK, good luck.
20:19:31 <Luke> shachaf: I'm not sure I can briefly and adequately explain here then
20:19:35 <haasn> what dmwit said
20:20:00 <Twey> b2coutts: I stare at it really hard until it submits and gives up its secrets
20:20:07 <Clint> haasn: right
20:20:19 <Luke> haasn: that's what I'm using as well
20:20:24 <b2coutts> Twey: haha, this had been my strategy up until now
20:20:30 <Twey> It's easier to do that in Haskell than in the general case
20:20:33 <b2coutts> but I hadn't written anything more than a few lines in length
20:20:39 <Twey> Especially if your types are right
20:20:56 <haasn> I break things up into smaller functions then make sure those work correctly
20:20:59 <haasn> via GHCi testing
20:21:18 <dmwit> I feel like I should lean on ghci's debugger more, but I really don't understand that thing.
20:21:23 <haasn> ^
20:21:35 <b2coutts> I'm not sure the functions I'm testing could logically be broken up any further
20:21:43 <b2coutts> it's just tricky because they're deeply recursive
20:22:04 <b2coutts> mutually- and self- recursive
20:22:10 <Luke> dmwit: I use the ghci debugger pretty extensively - what's the part you don't like about it?
20:22:50 <xunie-laptop> Please mind you guys: I'm a total Haskell newbie. Is it possible to dynamically create/store/destroy computations in a database?
20:23:10 <dmwit> I think placing the blame on the debugger rather than on me is unfair.
20:23:22 <Luke> dmwit: btw I do recognize you mentioned min/maxBound earlier I just didn't realize what that was
20:23:25 <monochrom> how or where is that database stored?
20:23:34 <haasn> b2coutts: the procedure again falls down to making sure the base case is correct, and making sure the recursive cases are correct; via quickcheck or by inserting values manually and figuring out what happens
20:23:37 <dmwit> 'scool
20:23:41 <b2coutts> dmwit: wow, debug.trace is entrely straightforward
20:23:51 <xunie-laptop> monochrom, on a disk?
20:23:52 <b2coutts> I was expecting to have to make some horrible frankenstein of impure codee
20:24:01 <monochrom> ok, then I don't know how to do it
20:24:19 <haasn> b2coutts: it's not as straightforward as you might want though, when laziness gets added to the mix
20:24:25 <Luke> dmwit: the key win with the debugger is really just finding exceptions/async exception sources. everything else I usually use debug.trace
20:24:26 <b2coutts> oh, probably
20:24:42 <dmwit> I was mostly joking that elliott missed my universe advocacy than blaming you for missing [minBound..maxBound]. ;-)
20:25:06 <haasn> adding trace to some expression will still only print anything when that particular section of the result is forced
20:25:15 <geekosaur> xunie-laptop, I'm not even certain what you are asking. (even from a database angle: what are the "computations" in question?)
20:25:16 <Luke> i saw that mentioned in tutorials as well and though it was some psudo code like "imagine i have a range here"
20:25:17 <dmwit> Luke: I see. I don't do a lot of stuff that's exception-heavy.
20:25:40 <xunie-laptop> geekosaur, sorry, I've been up for too long!
20:25:49 <Luke> dmwit: I try not too but some IO libraries have no choice but to throw async exceptions at you =/
20:26:01 <xunie-laptop> What I meant to say was: I want to store valid Haskell functions in a database and call them later on!
20:26:04 <monochrom> I know how to do it if in memory and can die when the program dies. just store the expression in a map or set or list or...
20:27:18 <dmwit> xunie-laptop: Serializing Haskell functions is tricky. You could use String for storage; there are several libraries that help deserialize Haskell code from String into something usable. But not much for serializing.
20:27:33 <xunie-laptop> Daww.
20:27:47 <geekosaur> xunie-laptop, valid Haskell functions are typically machine code and difficult to store in databases. (there *is* a bytecode interpreter, but no access to the bytecode. there is the possibility of storing source code and using hint to evaluate it)
20:27:52 <xunie-laptop> Well, it doesn't matter! I'm gonna be entering the functions as a string anyways. So I'll save the string, evaluate the code, see if it's valid.
20:27:55 <dmwit> xunie-laptop: universe offers Read and Show instances for functions, but they're pretty tongue-in-cheek; they work by running the function on all possible inputs =P
20:28:08 <geekosaur> erlang can do this kind of thing, but erlang specifies a virtual machine architecture which makes it possible to do such things
20:28:30 <xunie-laptop> dmwit, how horrifying!
20:29:35 <choptimusprawn> I call this serialization of functions compiling, and these databases libraries ;P
20:29:54 <Luke> man Enum and Bounded are awesome! I had a feeling I was missing something here
20:30:34 <geekosaur> choptimusprawn, yes, but the indexing available is really crappy :)
20:30:49 <xunie-laptop> Not to mention the performance! :C
20:31:03 <geekosaur> enh, plugins isn't too terrible
20:31:04 <zRecursive> :t Bounded
20:31:05 <ClaudiusMaximus>  metasyntactic variable
20:31:05 <lambdabot> Not in scope: data constructor `Bounded'
20:31:10 <ClaudiusMaximus> oops wrong windo
20:31:23 <geekosaur> but storing a shared object in a database is not my idea of fun
20:31:49 <dmwit> ?src Bounded
20:31:49 <lambdabot> class  Bounded a  where
20:31:50 <lambdabot>     minBound, maxBound :: a
20:32:02 <Twey> geekosaur: What good is making it shared if you don't export it over a RESTful Web interface?!
20:32:18 <dmwit> It should be BoundedAbove and BoundedBelow. =P
20:32:26 <applicative> hm, you cant 'DeriveDataTypable' for empty data declarations, without StandaloneDeriving
20:32:30 <monochrom> upload it to dropbox :)
20:33:08 <applicative> dataTypeConstrs $ dataTypeOf (undefined :: Empty)
20:33:10 <applicative> []
20:34:07 <asdfjisfd> hi there, does hoogle not work for anybody else?
20:34:27 <applicative> asdfjisfd: its down see the note at the top of the channel
20:34:41 <asdfjisfd> bah, im a bit silly
20:34:41 <asdfjisfd> thank you
20:34:44 <applicative> https://www.fpcomplete.com/hoogle
20:34:53 <elliott> ./Mueval/Parallel.hs:                                           $ throwTo tid $ ErrorCall "Time limit exceeded.") Nothing
20:34:56 <elliott> ./Mueval/Parallel.hs:                                   throwTo tid (ErrorCall "Time limit exceeded")
20:34:59 <elliott> great, you can tell the two apart by the .
20:35:02 <elliott> that makes it easier
20:35:07 <b2coutts> fpcomplete should probably be in the topic for now
20:35:24 <Twey> Speaking of deriving, here's something I miss that I feel should exist somewhere: I often end up wanting to derive instances for types that *could* have the instance derived except that one constructor amongst many can't be derived, so I end up writing a bunch of cases that duplicate what the derived instance would do.  Is there some way to only specify the interesting case and derive the rest?
20:35:26 <elliott> anyway, I am pretty confident that the problem was not watchdog.hs.
20:35:32 <elliott> since it would not give the timeout error, afaik
20:35:33 <applicative> b2coutts: yes i've pasted it 20  or 30 times
20:35:40 --- mode: ChanServ set +o elliott
20:35:41 <asdfjisfd> out of curiosity, is there anywhere online that I can see how Data.Array.IArray is implemented?
20:36:10 --- topic: set to 'haskell.org in the middle of migration; expect turbulence -- for Hoogle, try https://www.fpcomplete.com/hoogle | http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by elliott
20:36:15 --- mode: elliott set -o elliott
20:36:22 <asdfjisfd> thanks elliott :)
20:36:31 <Twey> asdfjisfd: Well, it's a class, so the implementation depends on the instance
20:37:05 <applicative> oh awesome elliott
20:37:18 <asdfjisfd> sorry, that was a bad choice of wording, i'd like to see the class's code
20:37:20 <dmwit> asdfjisfd: If you're talking about the module, you can click the "Source" link at the top of the Hackage documentation.
20:37:27 <elliott> so it's (timeLimit opts * 700000)
20:37:36 <elliott> I hope dmwit is paying me for this running commentary
20:37:40 <asdfjisfd> ah, there it is, hidden at the top right! thank you :)
20:37:49 <dmwit> elliott: Well, I'm paying attention. Does that count?
20:37:55 <Luke> is there something like Bounded and Enum but for a type like "X = A Int | B Int | C Int" where all the data constructors have the same type?
20:38:08 <elliott> dmwit: dunno, what's the conversation rate of dmwit's attention <-> GBP?
20:38:13 <Twey> asdfjisfd: It's not a very interesting source, though :þ
20:38:32 <dmwit> Well, I could tell you my salary. Is that gauche?
20:38:52 <dmwit> Luke: data Tag = A | B | C; type X = (Tag, Int) -- ;-)
20:38:53 <asdfjisfd> i'm still learning Haskell, and I couldn't write IArray myself, so its still helpful to look at the source... even if its not interesting ;)
20:39:07 <Luke> dmwit: fair =)
20:40:05 <elliott> dmwit: everything about this is gauche. I'm looking at a file called /home/lambdabot/home/lambdabot/src/mueval-0.9/Mueval/ArgsParse.hs, do you have any idea how ridiculous that name is?
20:40:30 <Twey> asdfjisfd: It's not interesting in the sense that it's not contained there.  The code is all in http://hackage.haskell.org/packages/archive/array/0.3.0.1/doc/html/src/Data-Array-Base.html
20:40:33 <dmwit> /home/lambdabot/home/lamdbabot?
20:40:38 <elliott> now I'm going to look at /home/lambdabot/home/lambdabot/src/lambdabot/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Eval.hs. that's a practically illegal amount of "lambdabot"s.
20:40:50 <Twey> asdfjisfd: But it's highly implementation-specific and probably not a good learning resource
20:40:55 <elliott> dmwit: /home/lambdabot is a chroot
20:41:11 <dmwit> Oooof course it is.
20:41:12 <asdfjisfd> thanks Twey :)
20:41:40 <elliott> dmwit: look, have you read lambdabot's source code? would you trust it to run outside of a chroot?
20:42:06 <dmwit> Some of it, and, well... empirically yes.
20:42:18 <stevejb> hello, I was curious as to how to use Data.List.mapAccumL to get the index of the max of a list which gets constructed using a map
20:42:25 <dmwit> But I am a pretty trusting guy.
20:42:25 <stevejb> :t Data.List.mapAccumL
20:42:25 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:43:10 <dmwit> stevejb: I guess "acc" here will be specialized to a type that holds the max seen so far and its index.
20:43:37 <dmwit> Doesn't seem like you need a hammer as big as mapAccumL for this, though.
20:43:47 <stevejb> dmwit: so, how do I read the "(acc -> x -> (acc, y))" part
20:44:02 <elliott> dmwit: have you looked at the source for :t?
20:44:16 <stevejb> well, I figured that since I am constructing the list using a map, it would be easy enough to get the index with the map at the same time
20:44:42 <dmwit> elliott: nope
20:44:42 <JoeyA> Who runs Hoogle?  Visiting h t t p : / / w w w . h a s k e l l . o r g / h o o g l e / downloads the 20MB x86-64 binary :(
20:44:49 <johnw> JoeyA: see topic
20:44:50 <dmwit> JoeyA: /topic
20:44:53 <JoeyA> thanks
20:45:06 <elliott> dmwit: https://raw.github.com/mokus0/lambdabot/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Type.hs
20:45:16 <elliott> dmwit: I invite you to speculate on ways you could get it to pass two lines to GHCi rather than only one :)
20:45:19 <Twey> stevejb: Function from acc to x to pair of (acc, y)
20:45:31 <elliott> for instance, it lets through \r, I think.
20:45:51 <elliott> and maybe GHCi will accept \r as a newline and maybe you can get an \r fed to :t by using @@. are you sure you can't?
20:46:11 <dmwit> Not at all sure.
20:46:17 <Twey> stevejb: acc being your accumulator, x being the next element of the list, y being the corresponding element in the output list
20:46:36 <stevejb> Twey: I think that that helps
20:46:44 <stevejb> the idea that x is the next element
20:46:52 <elliott> OK, so it looks like it *should* be using a timeout of 3.5 seconds
20:47:47 <elliott> > [minBound..maxBound] :: [Test]
20:47:47 <stevejb> so for every element in list that I am mapping over, I need to keep track of (the_max, index_of_the_max)
20:47:48 <lambdabot>   Not in scope: type constructor or class `Test'
20:48:04 <elliott> > [minBound..maxBound] :: [Hello]
20:48:07 <lambdabot>   [A,B,C,D,E]
20:48:12 <elliott> no.
20:48:13 <elliott> stop working.
20:48:26 <johnw> > let xs = [1,5,8,3,5,6] in elemIndex (maximum xs) xs
20:48:28 <lambdabot>   Just 2
20:48:47 <elliott> ok, well, I guess I should look at my logs and see if it ever times out *before* 3.5 seconds.
20:50:50 <dmwit> > text "foo\rbar"
20:50:52 <lambdabot>   foobar
20:51:01 <dmwit> see? perfectly safe...
20:51:20 <dmwit> ?let data Foo = Foo
20:51:22 <lambdabot>  Defined.
20:51:29 <elliott> dmwit: hah, there's more ways to show arbitrary text than that
20:51:33 <dmwit> ?let instance Show Foo where show Foo = "foo\rbar"
20:51:35 <lambdabot>  Defined.
20:51:36 <elliott> and you don't know the \r isn't just being stripped for IRC output
20:51:38 <dmwit> > Foo
20:51:39 <Twey> stevejb: Do you know how to use folds?
20:51:42 <lambdabot>   foobar
20:51:42 <elliott> as opposed to as part of an intermediate @@
20:52:22 <stevejb> Twey: no
20:52:27 <dmwit> ?undefine
20:52:28 <lambdabot> Undefined.
20:52:32 <dmwit> ?let data Foo = Foo
20:52:33 <lambdabot>  Defined.
20:53:05 <Twey> stevejb: You should probably start there; mapAccumR is a combination of a fold and a map (it's a fold with an extra output that gets output as a list)
20:53:13 <Twey> :t foldr
20:53:14 <stevejb> Twey: thank you. I will work on that
20:53:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:53:29 <dmwit> ?let instance Show Foo where show Foo = "3\rPrelude.writeFile \"elliott_is_paranoid\" \"elliott_is_paranoid\""
20:53:30 <lambdabot>  Defined.
20:53:41 <dmwit> @@ @type (@run Foo)
20:53:42 <Twey> stevejb: http://www.haskell.org/haskellwiki/Fold
20:53:46 <lambdabot>  Num ((FilePath -> String -> IO ()) -> [Char] -> [Char] -> t) => t
20:53:51 <elliott> hah
20:53:55 <dmwit> hehehe
20:54:20 <elliott> anyway, my point is not that this exploit works (in fact, if it was as simple as that I would take lambdabot down until I could fix it)
20:54:36 <dmwit> Yes, I know. I got the point.
20:54:37 <stevejb> Twey: thanks! going through that now
20:54:42 <elliott> it's just that the :t code is so slapdash, for one of the most risky parts of the code, that I find it worth the paranoia of hiding it under another layer.
20:54:44 <dmwit> But your doomsday scenario made me curious.
20:54:51 <elliott> :)
20:55:08 <elliott> anyone who successfully exploits it gets, uh... I don't know. lambdabot admin privileges?
20:55:21 <xunie-laptop> elliott, security through obscurity is not security.
20:55:21 <dmwit> commit bit =)
20:55:23 <johnw> a lambda cookie
20:55:34 <xunie-laptop> I just dropped in, I don't know what you're talking about.
20:55:46 <elliott> xunie-laptop: a non-root chroot is a bit more than obscurity
20:55:51 <elliott> perhaps not enough to be security though
20:56:28 <johnw> I think that knowing whether your system is secure is just another form of the halting problem
20:56:55 <Twey> Only if you rely on unproven code!
20:56:56 <dmwit> There are conservative solutions to the halting problem.
20:56:59 <tabemann> question I should know - can you pattern-match against lists using [x, y, z] instead of using (x : y : z : [])?
20:57:06 <dmwit> As Twey is pointing out now. =)
20:57:13 <Twey> tabemann: Try it and see
20:57:44 <tabemann> yes
20:57:52 <Twey> > let [a, b, c] = "123" in b
20:57:53 <lambdabot>   '2'
20:58:15 <dmwit> > let [a, b, c] = "=(" in b
20:58:17 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern [a...
20:58:18 <johnw> true, it would be nice if I could use Agda for the sensitive parts of my code
20:58:30 <Twey> johnw: Well, you can.
20:58:42 <johnw> can I import an Agda module from Haskell?
20:58:46 <Twey> Agda<=>Haskell interaction is pretty good.
20:58:54 <dmwit> Yes, Agda has an FFI to Haskell.
20:58:57 <Twey> You can compile Agda to Haskell
20:59:19 <johnw> huh, I thought I'd asked #agda about that way back when I started to look at it, and they said no
20:59:33 <elliott> ok, so it looks like the time limit actually is being exceeded
20:59:36 <johnw> do you have an example of compiling some Agda to Haskell and using it in a Haskell program?  I'd be very interested
20:59:40 <elliott> and it's just too low
20:59:41 <elliott> but uh
20:59:44 * tabemann wonders how restrictive Agda's total functionality really is
20:59:49 <elliott> why is it taking 3.5 seconds to run code as simple as [minBound..maxBound]?
21:00:08 <Twey> johnw: The default compiler, MAlonzo, compiles to Haskell and then compiles with GHC
21:00:26 <Twey> You can import the generated Haskell like any other Haskell module
21:00:46 <johnw> is there a HOWTO for doing so anywhere that you know of?
21:01:21 <Twey> tabemann: It requires that at least one argument to a recursive call be structurally smaller than the original call that generated it
21:01:33 <Twey> johnw: Uhhm, http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.MAlonzo
21:01:59 <johnw> thanks!  gonna try it now
21:02:49 <elliott> hmm, maybe running the imports is taking too long
21:02:55 <tabemann> Twey: that's what I had read; it just seems very... restrictive, in that there are many algorithms which certainly terminate which don't fit that
21:03:23 <dmwit> tabemann: It's somewhat common to invent an argument which does decrease specifically to get around that problem.
21:03:28 <Twey> tabemann: It's not a complete solution to the halting problem, no :þ  But it's the closest we've got, as far as my understanding goes
21:03:48 <tabemann> dmwit: that's what I was thinking of
21:03:50 <Twey> Yeah, you can always wrangle an extra argument in for the proof
21:04:01 <Demos> can't you solve the halting proble for a fairly large class of programs given ass tons of memory?
21:04:43 <Twey> Demos: I don't think so
21:06:01 <Demos> OK this is a foggy memory of some paper I saw the title to years ago :D
21:06:12 <Twey> I could be wrong, but I'm reasonably sure that if you can't prove it in one step then you can't prove it (bear in mind that you don't know what the input values are; all you can tell is whether or not they'll get smaller)
21:06:33 <Twey> Either every branch decreases the input or it doesn't
21:06:34 <tabemann> of course that makes me think of the opposite... are there ways to *break* the attempt by agda to be total functional, e.g. having alternating arguments that decrease one at a time
21:07:16 <tabemann> or is its being total functional air-tight?
21:08:19 <dmwit> uh?
21:08:36 <dmwit> The answer to that question has to actually get a bit nuanced, I think.
21:09:02 <Demos> well if you could "break" agda then it sorta defeats the point
21:09:25 <Twey> Hrm
21:09:25 <dmwit> e.g. for Coq (which has a very similar set of restrictions) there are proofs that the core calculus terminates.
21:09:35 <dmwit> Then you just have to believe that the implementation and the proof match up.
21:10:10 <dmwit> I don't know if such proofs have been done for Agda, but it's all based on the same stuff, really.
21:10:22 <lpaste> Twey pasted “Agda isn't broken” at http://lpaste.net/90977
21:10:29 <Demos> step 1) write program. step 2) observe result. Step 3) have faith :D
21:10:37 <Twey> tabemann: Agda correctly detects that this program terminates, but I don't know why.  :þ
21:10:48 <Twey> Er, s/terminates/doesn't terminate/
21:11:35 <tabemann> yeah, that's the sort of thing I was thinking of
21:14:02 <monochrom> more words of wisdom: non-termination reasons are as hard as termination reasons :)
21:14:04 <Twey> Oh, never mind, I know why
21:15:19 <Twey> tabemann: The mutual recursion means that the checker will expand the definition until it gets to the original function call, so for example term₁ n m = term₂ (suc n) (pred m) = term₁ (pred (suc n)) (suc (pred m))
21:15:35 <Twey> = term₁ n m, so no decrease in argument size
21:15:41 <raisdead> I am tring to use Data.Fixed so I :m +Data.Fixed in ghci and then
21:15:45 <raisdead> try E0
21:16:22 <raisdead> (sorry for line break) and I get not in scope. What am I doing wrong?
21:16:39 <dmwit> E0 is a type, not a value.
21:16:43 <Twey> raisdead: The constructor E0 is not exported from Data.Fixed
21:16:49 <Twey> Only the type E0
21:16:58 <dmwit> Maybe you'd like 0 :: Fixed E0 or similar.
21:17:47 * Twey was kind of expecting to find µ in Data.Fixed
21:17:53 * tabemann likes the idea of dependent types, but he isn't sure if he's willing to give up being able to write arbitrary functions for being total functional
21:17:57 <raisdead> Thanks. I guess I need to look at undersanding the module statement more.
21:18:19 <Twey> tabemann: You don't need to give up partiality for dependent types
21:19:21 <Twey> tabemann: Only if you want your program to be a proof of something; non-totality results in incoherence.  For normal programs you can write as you will; there are flags to turn off the totality checker on (IIRC) a per-function, per-module, or per-program basis.
21:19:45 <Twey> tabemann: If you don't mind some overhead, Agda also has a partiality monad.
21:20:55 <tabemann> it's less that I want to be able to write partial functions - generally they are a bad idea in most cases anyways - but I don't like the idea of being restricted to a subset of possible programs to fit those programs that the compiler can *prove* to be total
21:21:44 <Demos> then dont write in agda, honestly why in the world would you turn off the totality checker
21:21:49 <Twey> tabemann: Well, it's the same thing, shy of solving the halting problem
21:21:58 <Twey> Demos: Because then you get Haskell with dependent types :þ
21:22:16 <tabemann> Demos: the dependent types are the part that I like about Agda
21:22:37 <Demos> well you loose whatever features haskell has that makes dependent types hard to implement
21:22:48 <tabemann> Idris seems cool too, but I wonder why they decided to make it strict rather than lazy
21:23:09 <Cale> tabemann: Probably just because it's easier to implement
21:23:32 <tabemann> if I wanted strict evaluation I would code in OCaml...
21:23:42 <Twey> I thought it was a conscious decision to ease ‘systems-level’ programming
21:23:46 <Demos> does OCaml have dependent types?
21:23:50 <Twey> Demos: No
21:23:53 <tabemann> Demos: of course not
21:24:06 <Demos> but nobody uses idris/haskell/ocaml for "systems programming"
21:24:08 <Cale> Twey: well, when Edwin says "systems programming" he just means "not just theorem proving"
21:24:16 <Twey> There's a variant of ML with a static type language of integers
21:24:16 <Demos> also nobody knows what "systems programming" is
21:24:22 <Twey> Cale: Sadly
21:24:43 <tabemann> they did make a Dependent ML, but it's not really maintained anymore, being folded into ATS
21:24:56 <Twey> tabemann: It's not really dependent anyway
21:25:02 <tabemann> Twey: so I heard
21:25:19 <Cale> Idris does apparently have some support for other evaluation orders, but I think lazy by default is important for compositionality.
21:25:59 <Demos> it is also important because it makes it quite hard to screw up the language with IO and state
21:26:31 <Twey> Cale: I could see strict-by-default being justified if it were intended for kernel programming or something
21:26:49 <tabemann> but you're not going to write a kernel in a garbage collected language anyways
21:26:58 <tabemann> or even hard realtime code, for that matter
21:27:09 <Twey> tabemann: Yeah, that's my issue with Idris :þ
21:27:31 <Demos> well I think you can do some realtime stuff in Go, and someone has done a kernel in haskell right?
21:28:01 <Twey> Edwin kind of implied that he'd like to explore options for non-GC'd code at some point
21:28:39 <Twey> Demos: Sure, but it's not really going to approach the performance people expect from kernels today
21:29:29 <Demos> true, actually a heavely verified kernel would be interesting as well, like the verified C compiler that is out ther
21:29:33 <tabemann> the only way I can see having GC in a kernel is with incremental GC designed for minimal impact and heavy use of critical sections where GC is turned off, and even then I'm skeptical
21:30:14 <tabemann> maybe reference counts could make it possible, simply due to their deterministic behavior without pauses
21:30:35 <Gracenotes> so, Rust is a pretty cool language
21:30:55 <tabemann> heard of it, never looked at it or used it
21:31:08 <Demos> I do not trust mozilla to design a clean language
21:31:25 <Gracenotes> I haven't used it myself. but, looking at it, plenty of constructs in the syntax *and* type system for provable runtime safety.
21:31:50 <Twey> It's not just Mozilla working on it
21:32:03 <Twey> It's attracted a fair bit of interest from the PL community
21:32:11 <Gracenotes> unfortunately, it seems like some programs written in it 'escape' to unsafe constructs too readily
21:32:25 <Gracenotes> some existing programs, that is
21:32:40 <Demos> I know, but my point is that it is not battle tested and does not have as much "cred" behind it as something like Go
21:32:51 <Twey> Demos: L4 has been verified
21:33:07 <Twey> Oh, Rust isn't production-ready yet; nobody's said it is
21:33:24 <Demos> can you tell me what L4 is? that is not really googleable
21:33:31 <tabemann> L4 is a microkernel
21:33:40 <tabemann> designed to be *really* fast, basically
21:33:51 <Gracenotes> well, Go isn't really a systems language much more than Python is.
21:34:09 <elliott> Rust might be less clean than Go but it would have to try very hard to be more pathetic
21:34:21 <elliott> but, language wars don't really belong here.
21:34:27 <Gracenotes> true enough.
21:34:31 <Twey> Demos: http://www.ertos.nicta.com.au/research/l4/
21:34:35 <thoughtpolice> Demos: look up L4.verified and seL4, they're verification efforts for an L4-style microkernel
21:34:49 <Demos> neat, will check out
21:35:12 <thoughtpolice> Microsoft Research has also has a verified OS project, 'Verve', although it's a bit of a different approach
21:37:19 <pharaun> i thought that was singularity
21:37:31 <pharaun> tho isn't that their managed runtime research os?
21:43:25 <tabemann> question - I have a String, and I want to get turn it into a Data.ByteString.ByteString containing UTF8; I see Data.ByteString.UTF8, but I only get as far as *its* ByteString, not the ByteString I want to finally end up with
21:43:25 <tabemann> so just how do I do this?
21:43:26 <shachaf> tabemann: Those are the same ByteString.
21:43:44 <tabemann> okay
21:44:05 <elliott> is there a particular reason you have a String rather than a Text?
21:45:08 <tabemann> elliott: I am just composing a bit of text that I'm feeding into a hashing algorithm
21:45:18 <tabemann> going through a Text would just make things more convoluted
21:45:27 <pharaun> speaking of string vs text/bytestring is the only 2 big choice for html parsing - HXT (strings only iirc) or tagsoup (which has tagsoup-fast for bytestring) my only real choice?
21:46:02 <pharaun> been poking around for a while through hackage and over the web and i have not ran into much other alternatives so was wondering if i was missing something
21:46:30 <pharaun> tabemann: pre-existing text or loaded from an external io source?
21:47:56 <pharaun> tabemann: but roughly you want 'fromString' iirc from bytestring-utf8
21:48:44 <NemesisD> ahh i've gotten myself really mixed up between what stuff i need to make into a type and which into a typeclass, could use some help
21:49:12 <monochrom> pharaun: I personally like HXT, but you may also like to consider: HaXml, hexpat, xml, xml-basic
21:49:21 <elliott> NemesisD: when in doubt, a type.
21:49:26 <NemesisD> or possibly typefamilies?
21:49:26 <elliott> in fact, even when not in doubt.
21:50:03 <pharaun> monochrom: i don't mind hxt, its just the string part is making me wary of performance issues.  Also isn't main issues of haxml/hexpat/etc that they expect well-formed xml/html which... most of the web isn't :)
21:50:58 <NemesisD> i'm trying write an abstract state machine like StateMachine s m a to support the following operations: validTransition :: s -> s -> Bool, and onTransition :: (Monoid s, Monad m) s -> s -> m a
21:51:19 <Demos> well most people who care enough to write well formed XML are using JSON or sexps by now :D
21:51:40 <pharaun> Demos: heh i'm unfortunately scrapping some sites *shrugs* so i'm a tad stuck with html parsing
21:51:59 <Demos> hehe fair enough
21:52:04 <monochrom> HaXml's HTML part may be pretty lenient on wrong HTML too
21:52:17 <NemesisD> oh and MonadPlus, the main task would terminate early on an invalid state change (with guard and validTransition) and run an onTransition in the monad on sucessful transition
21:52:20 <tabemann> back
21:52:21 <pharaun> Demos: i have had pretty good experience with aeson tho :) its decently fast for what i needed it for :D
21:52:34 <pharaun> monochrom: hmm i'll dig into that then thanks
21:52:35 <tabemann> pharaun: I'm constructing text and feeding it in at runtime
21:52:37 <monochrom> then again, it's also inputting String
21:52:41 <pharaun> ah
21:53:13 <NemesisD> but what do I do to get there? seems like i need a typeclass for the user-definable transition callback and validation
21:53:17 <byorgey> NemesisD: just make a record type with two fields, validTransition and onTransition
21:53:30 <pharaun> dang it, yes its inputting on string
21:54:22 <pharaun> i guess if i have to i can always bump up memory/spread the parsing task over several threads, was just hoping for a bytestring parser :)
21:54:41 <pharaun> looks like i'll be trying out tagsoup-fast
21:54:51 <NemesisD> byorgey: hmm interesting, i'll see if i can get those types to work out
22:02:43 <NemesisD> byorgey: this doesn't work out quite right for me. i would like a monadic interface similar to writer so I could do something like: do { transitionResult <- tell NextState; ... }
22:03:47 <NemesisD> the tell would abort if the state transition is invalid, and if it is valid, return the monadic result of onTransition
22:04:34 <NemesisD> the points where i'd extend this things aren't clear
22:04:41 <shachaf> That doesn't sound like something I'd call "tell".
22:04:41 <lpaste> raisdead pasted “relation design problem” at http://lpaste.net/90978
22:04:42 <lpaste> raisdead pasted “relation design problem” at http://lpaste.net/90979
22:06:43 <NemesisD> internally it would use tell, but yeah, i'd probably call it transition
22:07:06 <NemesisD> working on an example because i think i'm starting to come across as a crazy person
22:09:12 <raisdead> If someone has an opportunity, I have a question at http://lpaste.net/90979 that I cannot seam to find a good way to solve.
22:09:48 <tabemann> okay this is strange... every time I do an internal cycle in my program it acts as if I reset the random number generator back to the same initial value... except I'm calling getStdGen once and passing my random number generator around in a State monad, with a getRandomRange function that changes the state each time...
22:10:06 <johnw> tabemann: paste?
22:12:05 <tommd> tabemann: To clarify, you are calling `getStdGen` once per run of the program and not once per cycle, right?
22:12:08 <lpaste> tabemann pasted “Why is the random number generator acting weird?” at http://lpaste.net/90980
22:12:20 <tabemann> tommd: yes
22:12:21 <tommd> tabemann: In other words, the problem doesn't go away if you use `newStdGen`?
22:12:23 <tommd> ok
22:13:32 <tommd> tabemann: I'm still glancing at it, but you can use the Rand monad instead of State + RNG
22:13:45 <johnw> tabemann: the outer mapM_ in main is going to pass the same initial generator in for each invocation of evalState
22:13:50 <johnw> is that what you mean?
22:14:07 <tabemann> that sounds like the problem I have
22:14:25 <johnw> move the evalState one level out then
22:14:45 <tabemann> can't do that
22:14:49 <johnw> why not?
22:15:07 <tabemann> printStats needs to be in the IO monad, and on the other hand doesn't need to know anything about random numbers
22:15:27 <tommd> tabemann: Is there a reason not to use `newStdGen`?
22:15:34 <johnw> x <- printStats ; evalState $ mapM_ (uncurry x) ...
22:16:13 <tabemann> printStats returns (), but takes a list of collision counts
22:16:28 <johnw> ah
22:16:34 <tabemann> no IO ()
22:16:39 <johnw> well, you're going to have to create a data structure to hold the results, or use StateT
22:17:10 <tabemann> all the looping between the different tests occurs within the evalState; printStats is just for displaying the output
22:17:44 <NemesisD> what happened to hpaste?
22:17:53 <raisdead> lpaste.net
22:18:01 <tabemann> domain name problems
22:18:09 <NemesisD> ah ok
22:19:12 <lpaste> NemesisD pasted “incomplete state machine” at http://lpaste.net/90982
22:19:26 <monochrom> evalStateT (mapM_ (liftIO (uncurry printStats)) (mapM (\count -> ...))) gen
22:19:27 <NemesisD> byorgey: ^ i got most of the way there then got stuck
22:19:57 <zRecursive> :t evalStateT
22:19:58 <lambdabot> Monad m => StateT s m a -> s -> m a
22:20:01 <NemesisD> got stuck on runStateMachine and transition that is
22:20:22 <monochrom> type RandomState m a = StateT StdGen m a
22:20:24 <zRecursive> @unmtl StateT s m a
22:20:24 <lambdabot> s -> m (a, s)
22:20:26 <lpaste> tabemann revised “Why is the random number generator acting weird?”: “Why is the random number generator acting weird?” at http://lpaste.net/90980
22:20:32 <monochrom> etc etc
22:21:08 <monochrom> heh, ok, yours is less big-hammer :)
22:24:18 <tabemann> back
22:24:30 * tabemann is trying to get monochrom's code to work
22:25:11 <raisdead> I have some code at http://lpaste.net/90979 . I am trying to implement something equilvant to relation in database theory.
22:27:24 <NemesisD> or anyone else? should i be writing a monad instance for StateMachine perhaps
22:31:59 <NemesisD> i think i may need to put the StateMachine in State and make the whole thing RWS :/
22:32:42 <NemesisD> even though i don't want or need to set the state back
22:33:14 <tabemann> interesting - that didn't solve the problem
22:34:37 <tabemann> but I need to go to bed
22:39:32 <lispy> is there a way to use happy's glr mode with cabal?
22:45:34 <dmj> What's the closest I can come to bar pattern-matching style in do syntax? I want to check three cases, ==, <, and > (aka otherwise). If-else and case need two-level nesting.
22:46:35 <elliott> you should just nest.
22:47:11 <NemesisD> elliott: what do you mean?
22:47:24 <NemesisD> nest reader monads?
22:48:36 <Cale> dmj: Use   case compare x y of ...
22:49:15 <shachaf> Another possibility might be: do { ...; let { x | ... = ... | ... = ... }; ... }
22:49:26 <elliott> NemesisD: I mean -- yes, what Cale says
22:50:07 <NemesisD> elliott: was he talking to me?
22:50:13 <Cale> dmj: compare x y will produce one of LT, EQ, or GT in the case that x is less than, equal to, or greater than y respectively.
22:50:16 <NemesisD> or maybe i missed a message
22:50:16 <lispy> I guess I have to manually generate the .hs file and then check that into my package?
22:50:17 <elliott> NemesisD: ?
22:50:23 <elliott> I was answering dmj
22:51:47 <NemesisD> you addressed me though, but yeah that makes more sense
22:52:19 <elliott> huh?
22:52:21 <elliott> no I didn't.
22:54:19 <dmj> Cale: Exactly what I was looking for, thanks
22:54:20 <dmwit> NemesisD: ...you definitely did
22:54:55 <dmwit> wow
22:54:57 <dmwit> NemesisD: sorry
22:55:03 <dmwit> elliott: ...you definitely did
22:55:11 <joeace> hi
22:55:32 <elliott> dmwit: where?
22:55:36 <dmj> shachaf: what is let { x | .. = } ?
22:55:38 <elliott> <dmj> What's the closest I can come to bar pattern-matching style in do syntax? I want to check three cases, ==, <, and > (aka otherwise). If-else  and case need two-level nesting.
22:55:42 <elliott> <elliott> you should just nest.
22:55:46 <elliott> <NemesisD> elliott: what do you mean?
22:55:46 <dmwit> 01:49 < elliott> NemesisD: I mean -- yes, what Cale says
22:55:50 <elliott> yes.
22:55:54 <elliott> because NemesisD asked what I meant
22:56:36 <shachaf> dmj: A guard.
22:57:37 <dmj> > let { x | 3 == 3 = 4}
22:57:38 <lambdabot>   not an expression: `let { x | 3 == 3 = 4}'
22:58:09 <dmj> works in ghci, never knew about that, thanks
22:58:25 <dmwit> > let { x | 3 == 3 = 4 } in x -- works here, too
22:58:26 <lambdabot>   4
22:58:41 <johnw> huh
22:58:49 <johnw> still learning new Haskell syntax all the time
22:58:57 <shachaf> Which part is new?
22:59:09 <johnw> the part of not knowing I use guards in a let
22:59:12 <johnw> could use
22:59:24 <johnw> i love the consistency
22:59:31 <shachaf> Oh. Learning new ways that existing Haskell syntax you already know can be used.
22:59:39 <johnw> yeah, that :)
22:59:52 <dmj> dmwit: Is lambdabot just calling into ghci?
23:00:02 <shachaf> No.
23:00:09 <shachaf> lambdabot is doing its thing.
23:00:21 <shachaf> "its thing" will be changing in the near future, so I hear.
23:00:34 <dmj> shachaf: so the reason why my let didn't work is because its not in the IO monad?
23:00:41 <dmwit> dmj: lambdabot uses mueval, I think.
23:00:53 <shachaf> dmj: It's not "in any monad".
23:00:56 <dmwit> and yes, essentially
23:00:58 <shachaf> lambdabot evaluates expressions.
23:01:35 <dmj> > do { let { x | 3 == 3 = 4}; return x }
23:01:37 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
23:01:37 <lambdabot>    arising from a use of `M13193124...
23:01:51 <NemesisD> probably a dumb question, is there something like an RW monad
23:02:11 <NemesisD> where the read type differs from the write type
23:02:49 <dmwit> :t gets -- NemesisD
23:02:51 <lambdabot> MonadState s m => (s -> a) -> m a
23:03:33 <dmwit> Rumor has it lens also has some fun toys for munging the type of stateful computations.
23:03:41 <NemesisD> dmwit: but what if you want to guarantee that one part of the state (the reader) is read only, while the other is write only
23:03:59 <dmwit> Use ReaderT WriterT?
23:04:47 <dmwit> ?unmtl ReaderT r (WriterT w m) a
23:04:47 <lambdabot> r -> (WriterT w m) a
23:04:53 <dmwit> unmtl sucks these days
23:05:07 <dmwit> r -> m (w, a)
23:05:23 <shachaf> undmwitl
23:10:06 <lpaste> NemesisD annotated “incomplete state machine” with “incomplete state machine (stuck)” at http://lpaste.net/90982#a90985
23:10:12 <NemesisD> hmm, trying that but i'm having some problems ^
23:12:05 <NemesisD> man i've got some weird grouping/parentheses going on
23:13:17 <NemesisD> looks like i needed to lift the tell and ask. down to just 1 error
23:15:16 <dmwit> What is this Monoid instance all about?
23:16:09 <NemesisD> ah ok i think i understand a problem but not how to fix it. i'm using runReaderT to set the initial state, but i actually want to use runWriterT on the outermost level so i get the result
23:16:29 <NemesisD> dmwit: its for the writer part of the transformer stack, i write the next state when it changes using tell
23:17:14 <dmwit> Are you sure that's what you want to be telling?
23:17:32 <dmwit> You lose all information about "how you got to that state", so to speak.
23:18:01 <dmwit> You should consider tell [state] instead.
23:18:51 <NemesisD> that is possible, but not a requirement right now
23:19:32 <NemesisD> plus it gives a decent way of specifying the initial state
23:21:14 <dmwit> I would have expected that to go in myStateMachine.
23:21:46 <NemesisD> ahh ok i think its actually behaving correctly now, i realize i should be expecting finalResult to be ()
23:22:12 <NemesisD> dmwit: that's a good point, that might be a more natural way to express it
23:23:16 <NemesisD> dmwit: ooh, i think i'd actually need to use the dual of monoid that i just learned about, as i'd want to optimize for the head of the state list being the current state
23:23:54 <elliott> the dual of monoid?
23:23:56 <dmwit> I feel confused.
23:24:18 <NemesisD> isn't there some context for monoid where it flips the arguments
23:24:29 <NemesisD> for mappend
23:24:35 <johnw> Dual
23:24:47 <NemesisD> yeah
23:26:47 <NemesisD> btw is hoogle broken for anyone else
23:26:55 <dmwit> /topic
23:27:16 <NemesisD> right. is it related to the outage of hpaste
23:27:34 <NemesisD> are we under attack by imperialist imperative programmers
23:27:46 <zRecursive> :)
23:30:35 <NemesisD> i think i'm at that horrible state in my program where it looks like i've got 1 error left but really it is just the last error before GHC does another pass or something
23:31:41 <tommd> NemesisD: The community's digital footprint is in transition.
23:31:54 <tommd> hpaste is unrelated.
23:32:02 <NemesisD> tommd: what does that mean
23:32:35 <tommd> It means much of the Haskell.org infrastructure is moving off of Galois servers and onto others (can't recall the specifics)
23:33:58 <NemesisD> interesting, does galois not want to do it anymore?
23:34:23 <tommd> It isn't that, it's more a matter of unifying the physical host with the logical maintainer.
23:34:30 <evincar> I have a monad for doing unification and want to express "branch on several possibilities and resume with the result of the unique branch that unifies; otherwise fail with an inconsistency/ambiguity error"
23:34:45 <thoughtpolice> the servers were out of date and needed upgrading anyway. it also came with some nice upgrades to the hardware too
23:35:06 <evincar> Is LogicT a good thing for adding backtracking/nondeterminism like that?
23:35:09 <tommd> What would you know about it, thoughtpolice.  ;-)
23:35:16 <thoughtpolice> anyway, Hoogle is probably a 2 second fix once one of us gets our keys added :(
23:35:24 <thoughtpolice> tommd: :)
23:44:53 <dmj> irc logs down too?
23:45:09 <dmj> nvm
