00:00:53 <yesthisisuser> i am reading the wikibooks article about existentials: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
00:01:07 <yesthisisuser> under the section "Explaining the term existential", it says
00:01:23 <yesthisisuser> forall a. a is the intersection over all types, which must be {_|_}
00:01:56 <yesthisisuser> well.. doesn't that suggest that the type forall. a which is the same as a, is just the bottom value?
00:02:39 <c_wraith> oh
00:02:46 <c_wraith> They're really talking about entirely different things.
00:02:53 <c_wraith> There's just some overloading of the syntax.
00:03:09 <c_wraith> If you have a value with the type forall a. a, it's a bottom value necessarily
00:03:16 <diabel232> i am searching for some haskell decompiler
00:03:22 <diabel232> do you guys know any?
00:03:25 <c_wraith> nope
00:03:31 <c_wraith> I'm not sure anyone's put any work into it.
00:04:06 <yesthisisuser> c_wraith: "bottom value necessarily".. so you mean that any type that "contains" the bottom value sort of qualifies
00:04:18 <c_wraith> all types contain the bottom value
00:04:19 <SrPx> "A language with dependent types may include references to programs inside of types. For instance, the type of an array might include a program expression giving the size of the array, making it possible to verify absence of out-of-bounds accesses statically."
00:04:25 <c_wraith> (in haskell)
00:04:28 <SrPx> ... oh.
00:04:30 <SrPx> wow
00:05:23 <c_wraith> yesthisisuser: in fact, it's the *only* value shared by all types.  Which is why any value with that type must be a bottom value
00:05:59 <c_wraith> yesthisisuser: but GHC existentials just happen to abuse the forall notation and justify it with the universal/existential duality.
00:06:29 <c_wraith> yesthisisuser: the important part in the existential encoding is the data constructor.  data Foo = forall a. Foo a
00:07:20 <c_wraith> yesthisisuser: That says something very different.  It says that the type of the Foo constructor is forall a. a -> Foo
00:07:54 <c_wraith> yesthisisuser: which clearly means that it discards the type information.  There was some type, but once the constructor has been applied, knowledge of that type is lost.
00:08:16 <c_wraith> yesthisisuser: and that's the same thing existential imply
00:08:21 <c_wraith> *existentials
00:10:34 <yesthisisuser> c_wraith: ok, thanks. i still don't understand what they mean in the text by " the intersection over all types, which must be {‚ä•}"
00:12:18 <c_wraith> It means that the type unifies with every type, so that the value of the type must be a value of every type
00:13:05 <c_wraith> That's what it means by "intersection over all types" - that it has to be a value of all types.
00:13:16 <c_wraith> :t undefined
00:13:16 <yesthisisuser> ok. yeah i think i see how it works
00:13:17 <lambdabot> a
00:13:23 <c_wraith> :t undefined `asTypeOf` True
00:13:23 <lambdabot> Bool
00:13:30 <c_wraith> :t undefined `asTypeOf` Just True
00:13:30 <lambdabot> Maybe Bool
00:13:40 <c_wraith> so undefined has to be a value of every type
00:13:53 <c_wraith> :t undefined `asTypeOf` ()
00:13:53 <lambdabot> ()
00:13:57 <c_wraith> and so on, and so forth
00:14:24 <c_wraith> So..  intersect the set of values of each of those types, and you're left with one value, denotationally.
00:14:40 <haasn> (undefined :: forall a. a) is trivially ‚ä• because (undefined :: Void) can only have that value
00:14:41 <c_wraith> There are a few different operational expressions of it, of course.
00:14:51 <c_wraith> > undefined
00:14:52 <lambdabot>   *Exception: Prelude.undefined
00:14:58 <c_wraith> > let x = x in x
00:15:02 <lambdabot>   mueval-core: Time limit exceeded
00:15:06 <c_wraith> :t let x = x in x
00:15:07 <lambdabot> t
00:15:25 <c_wraith> so undefined and "let x = x in x" are different operationally, but both denote bottom
00:17:48 <yesthisisuser> so by saying forall a. Show a => a.. the bottom value is still the "qualifier".. but we have sort of limited the scope .. kind of .. or?
00:18:43 <c_wraith> That looks like it's an existential example again, right?
00:19:06 <yesthisisuser> yes it is from the same article
00:19:14 <c_wraith> It really is *entirely* different
00:19:20 <c_wraith> The data constructor changes things
00:19:32 <c_wraith> You can't just leave it out and expect things to make sense
00:21:07 <c_wraith> it means that the type of the constructor is forall a. Show a => a -> ShowBox
00:21:44 <yesthisisuser> c_wraith: can you recommend a good introduction text on this topic..? except the wikibooks article
00:22:33 <haasn> a third but even different example would be forall a. Monoid a => a
00:22:54 <c_wraith> I'm not sure I can. I think I learned almost everything on the topic just by hanging out in here. This is a great place to learn by osmosis. :)
00:23:35 * haasn envisions a university where all teaching happens by osmosis
00:24:36 <yesthisisuser> yeah i have learnt a lot of stuff at #haskell
00:24:44 <c_wraith> haasn: it can work, but you need motivated students.  Have to make themselves knowledge-porous. :)
00:24:59 <mauke> just stab holes in them
00:29:44 <haasn> think about it, it would be great. You'd have all the profs and students meet in a room to drink beer and chat about Haskell
00:32:30 <Ralith> haasn: you'd have a very hard time keeping the prof:student ratio high enough.
00:32:43 <Ralith> also, selecting sufficiently interested students.
00:35:07 <c_wraith> Ack.  I'm about to use OverlappingInstances.  This is ok, right?  Oleg gets away with it...
00:36:38 <johnw> why must you?
00:37:11 <c_wraith> I'm building a type class to flatten right-nested pairs into larger tuples
00:37:19 <c_wraith> The base case overlaps the recursive case
00:39:14 <c_wraith> nope! doesn't work...  As usual when I try to do stuff like this, my first idea missed something important.
00:39:52 <mstksg> are there any haskell lorem ipsum/dummy text libraries
00:42:25 <haasn> c_wraith: seems like you'd need an infinite number of cases no matter how you implement it
00:42:35 <haasn> because there's no way to get from ‚Äúx-sized tuple‚Äù to ‚Äúx+1-sized tuple‚Äù for the recursive case
00:42:38 <c_wraith> well, yes
00:42:48 <c_wraith> But it's ok to just limit it to 10 or so
00:43:01 <c_wraith> I mean, GHC limits tuples to like 63
00:43:15 <c_wraith> So it's a finite set
00:44:39 <haasn> seems to me like you'd need 10 overlapping instances then, of the shape (a,b); (a,(b,c)); (a,(b,(c,d)); etc. then
00:45:22 <applicative> mstksg: hah, he seems to have removed this module http://hackage.haskell.org/packages/archive/xhtml-combinators/0.2.2/doc/html/src/Text-XHtmlCombinators-Extras-Lorem.html
00:46:52 <mstksg> applicative: heh thanks
00:48:22 <mstksg> that's one way of implementing it lol
00:50:06 <applicative> he left out a lot of cases for para _
00:50:59 <applicative> I wonder if there's a technical difficulty writing this sort of thing so that the compiler treats it correctly
00:59:50 <c_wraith> Hmm.  I've concluded that nested tuples just don't have enough information to do this cleanly - but I actually have more information than nested tuples, so maybe I should use it directly, instead of going through an intermediate representation
01:03:04 <applicative> mstksg: http://www.serpentine.com/blog/2012/09/12/the-case-of-the-mysterious-explosion-in-space/ may explain why he removed the lorem module, and how to write it properly
01:03:17 <applicative> or maybe its good now
01:22:36 * hackagebot minioperational 0.4.1 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.1 (FumiakiKinoshita)
01:22:38 * hackagebot minioperational 0.4.2 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.2 (FumiakiKinoshita)
01:24:40 <c_wraith> This is amazingly clumsy.  If only kind-promoted tuples could handle nats as elements
01:24:54 <haasn> wasn't there some library that provides prisms for JSON data?
01:24:59 <haasn> or at least traversals
01:25:17 <supki> lens-aeson
01:29:47 <haasn> supki: thanks
02:09:05 <zomg> Oh great, install acid-state, it screws up Warp in some way... apparently a conflict with the version of Data.Text >_>
02:17:04 <tdammers> woot... <3 Maybe monad
02:17:44 <quchen> tdammers: ?
02:19:35 <tdammers> nm
02:20:03 <tdammers> just simplified a piece of code significantly by using the maybe monad
02:20:42 <quchen> Oh. I thought you had found out something surprising about it, and then I was surprised that there are surprises in Maybe. :-)
02:20:53 <tdammers> there are no surprises, really
02:21:12 <Yaniel> Maybe not?
02:21:35 <tdammers> I just had a horrible mess of nested ifs and Just and all that, and refactored it into a straightforward do {} block
02:21:41 <quchen> I'm just always surprised how the Monad laws guarantee that nothing weird happens.
02:21:46 <quchen> They seem so small and innocent.
02:22:00 <tdammers> it's pure zen ;)
02:22:24 <quchen> Yet in *every* crazy situation they ensure that the code does what I think it should do (modulo honest bugs)
02:22:31 <Work_jack> Hey, I sent an email to Ross Paterson about creating a user account on Hackage (http://hackage.haskell.org/packages/accounts.html) but I haven't gotten a response yet (that was ~4 days ago), should I continue waiting?
02:40:32 <bennofs> @hoogle (Traversable t) => t a -> t b -> t (a,b)
02:40:33 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
02:40:33 <lambdabot> Graphics.Rendering.OpenGL.GL.Exception finallyRet :: IO a -> IO b -> IO (a, b)
02:40:33 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
02:42:19 <merijn> Work_jack: There can be some latency in asking, yeah. I would give him at least a week to get around to it
02:42:29 <merijn> Work_jack: Especially since 4 days ago was over the weekend
02:46:22 <Work_jack> merijn: I'll just wait then
03:31:11 <Vertue> hi
03:32:36 <Vertue> I'm trying to parse a double quote in haskell as a character.  I thought doing '\"' would work but it doesn't
03:32:39 <Vertue> Any ideas?
03:32:52 <Lethalman> > '"'
03:32:53 <lambdabot>   '"'
03:32:59 <radish> morning everyone
03:33:04 <Vertue> tried that as well
03:33:29 <Lethalman> Vertue, lambdabot says it works
03:33:53 <Vertue> sorry
03:33:59 <Vertue> silly mistake on my side
03:34:14 <Vertue> lambdabot is right, as always...
03:34:15 <Vertue> Thanks
03:45:18 <mstksg> anyone here ever use blaze?
03:45:31 <mstksg> how do i get it to stop escaping my ampersands so i can type html entities like &copy; ?
03:45:57 <Zenol> Hi. Lazyness question. With data T = T !Int, when I do T something, where something is a thunk, what will happen? something will be "evaluated" until we have something that is a Int and not a thunk to an int? Or only the outermost constructor?
03:48:24 <haasn> Zenol: as far as I'm aware, ‚Äòsomething‚Äô will only be evaluated when you force the constructor
03:48:37 <haasn> oh
03:48:43 <haasn> I think I didn't read your question correctly
03:49:38 <haasn> Int is a strict data type, you either have the entire number evaluated or nothing
03:50:09 <HugoDaniel> yo
03:50:43 <haasn> (Int is primitive, the constructor can't even reference a thunk)
03:50:51 <haasn> (that would be a kind error or something)
03:51:02 <supki> Zenol: with data T = T !int  T something  means  something `seq` T something
03:51:32 <supki> Zenol: when you "do" T something nothing happens, if you evaluate T something, then something will be evaluated
03:51:53 <supki> (up to outermost constructor)
03:52:56 <Zenol> haasn, supki> oh, and something `seq` evaluate to the whole thing until we have a hint?
03:53:38 <Zenol> An so, if I have T (a, b), and something is a function that return a (a, b), then only the function will be evaluated (when the T something will be needed)
03:53:53 <haasn> Zenol: however, in the case of  ‚Äúdata X a = X a; data T = T !(X Int)‚Äù  <- forcing ‚ÄòT something‚Äô will still only force the constructor of ‚ÄòX‚Äô
03:53:59 <haasn> so you can have T (X undefined)
03:54:18 <Zenol> haasn> Ok :)
03:55:25 <haasn> in general, (seq) only forces the outer constructor (and whatever strict fields it may have)
03:55:48 <haasn> so in the case of T !(a, b) -- only the (,) constructor will be forced; not the ‚Äòa‚Äô or ‚Äòb‚Äô parameters, when forcing T
04:05:02 <Zenol> haasn> Hum, and in the case I have f -> (a, b), g -> f, h -> g, when I do let x = g in x `seq` x, then it will "evaluate" g, h, and f (to take the (,) constructor) ?
04:05:24 <Zenol> haasn> (Just to check if I understand)
04:06:45 <haasn> x `seq` x -- is a no-op
04:07:15 <Ghoul_> has anyone implemented automatic lifting like how `liftIO` works with the recursive lifting, but for transformers?
04:07:21 <haasn> and if you mean f = (a,b); g = f; h = g -- then yes, forcing ‚Äòlet x = g in x‚Äô will evaluate until you get to (,)
04:07:57 <supki> Zenol: x `seq` x  means "evaluate x when you evaluate x"
04:08:19 <klrr> :t if
04:08:20 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
04:08:28 <haasn> :t if'
04:08:29 <lambdabot>     Not in scope: if'
04:08:29 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
04:08:30 <Zenol> hu, ok, so it's usefull in case x `seq` somethingOn x
04:08:31 <haasn> :(
04:09:16 <Zenol> hum, are they an acessible paper on how how ghc evaluates / call things/functions/thunks ?
04:09:31 <typoclass> klrr: it's not a real function, it's syntax. (you couldn't have a function "if ... then ... else ..." anyway. at most something like "if ... `then` ... `else` ...")
04:10:35 <haasn> > let if' b _ t _ f = if b then t else f; then' = (); else' = () in if' True then' "Sure you can" else' "Why not?"
04:10:36 <lambdabot>   "Sure you can"
04:11:15 <typoclass> haasn: erm :-) yes, that's very fantastic
04:11:45 <Zenol> (And, question completely different and out of topic : You can't do template haskell and cross compile with ghc, right? [Since it's need a stage 2 compiler from the doc, but a cross compiler is a stage 1 compiler])
04:11:51 * typoclass . o O ( if' True else' "yo" then' "meow" )
04:11:58 <haasn> to be fair, you can't do ‚Äúif x then f y else z‚Äù
04:12:38 <haasn> typoclass: okay smartypants; data Case = Then | Else -- and distinguish between them in if'
04:13:14 <haasn> could even overload it using a MPTC to make sure you don't use ‚ÄòThen‚Äô or ‚ÄòElse‚Äô twice
04:14:30 <quchen> What's the extension again that lets you redefine if-then-else?
04:14:40 <typoclass> quchen: RebindableSyntax or some such
04:14:47 <quchen> That sounds about right
04:14:47 <haasn> yeah that
04:14:53 <typoclass> > let x = True ; f = succ ; y = 42 ; z = 17 in if x then f y else z -- haasn: not sure what you mean?
04:14:54 <lambdabot>   43
04:14:55 <haasn> will desugar to ifThenElse a b c
04:15:19 <haasn> typoclass: I mean, using the if' then' else' hack
04:15:26 <haasn> because you'd need parentheses around the arguments
04:15:56 <typoclass> haasn: oh i see
04:17:07 <typoclass> Ghoul_: you mean this ...? http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-IO-Class.html#liftIO
04:17:19 <Ghoul_> yes typoclass
04:17:36 <Ghoul_> Wait, no. That can't be the same I read before.
04:18:41 <quchen> Ghoul_: All the general API transformer functions are auto-lifting. Have a look at the class definitions of MonadReader, MonadState, MonadWriter for example.
04:18:54 <quchen> MonadIO is just another one in that list.
04:19:06 <Ghoul_> will those auto-lift with transformers?
04:19:12 <quchen> Yes.
04:19:13 <typoclass> Ghoul_: i'm not sure if that's the liftIO you're looking for (i just googled and package 'transformers' came up)
04:19:27 <haasn> typoclass: I wasn't aware any others exist
04:19:30 <quchen> "get" will call the next State-y monad in your stack.
04:20:55 * tdammers wonder what happens when I stack two MonadStates on top of each other
04:21:26 <haasn> tdammers: the MonadState instance for the outer StateT doesn't care about the underlying ‚Äòm‚Äô
04:21:44 <tdammers> right
04:21:49 <typoclass> haasn: i'm not sure *shrug* hayoo finds about 10 liftIO functions. they all seem basically the same
04:21:49 <tdammers> of course
04:21:58 <haasn> tdammers: and you can use ‚Äòlift‚Äô to get to the underlying one manually
04:22:05 <quchen> tdammers: For multiple States you should lift manually.
04:22:08 <haasn> typoclass: sure those are not re-exports?
04:22:08 <Ghoul_> haasn: can you show how that would look?
04:22:34 <haasn> :t lift get :: StateT s (State t) t
04:22:35 <typoclass> haasn: could be. also could be old identical stuff before it was all standardized to 'transformers'
04:22:35 <lambdabot> StateT s (State t) t
04:22:56 <haasn> :t get :: StateT s (State t) s
04:22:57 <lambdabot> StateT s (State t) s
04:23:24 <mm_freak> mtl and transformers share MonadIO and thus liftIO
04:23:36 <mm_freak> mtl just reexports MonadIO
04:23:47 <mm_freak> at least mtl 2
04:23:56 <haasn> typoclass: looks like those are all re-exports
04:24:47 <haasn> though http://hackage.haskell.org/packages/archive/test-framework/latest/doc/html/Test-Framework-Providers-API.html#v:liftIO seems new =)
04:25:33 <typoclass> ... which would be a cool hayoo feature. display which ones are just reexports
04:25:43 <haasn> (or just hide them)
04:27:00 <mm_freak> GHC with -W recognizes reexports and tells you about redundant imports caused by them‚Ä¶  it's an indirection, but better than nothing =)
04:27:39 <yesthisisuser> i accidentally went to #haskell on efnet. a very surreal experience until i realized i was on the wrong network
04:27:41 <eduardo_> What's up, guys? I am interested in playing with haskell DSLs. I tried to install "The BASIC package"  (http://hackage.haskell.org/package/BASIC) but it fails compiling. The error message I get is "No instance for (type-level-0.2.4:Data.TypeLevel.Num.Sets.NatI n2)". Has anybody tried to install this package?
04:28:20 <sipa> basic has typelevel nats :o
04:28:21 <haasn> seems like it hasn't been updated for GHC 7.x
04:28:44 <haasn> keep in mind this is from 2009
04:28:54 <eduardo_> haasn
04:29:17 <eduardo_> haasn: thanks‚Ä¶ What version of ghci do you think it is compatible with?
04:29:46 <haasn> eduardo_: the page shows ‚ÄúBuilt in ghc-6.10, ghc-6.12‚Äù
04:29:50 <haasn> built on*
04:30:10 <hpaste> quchen pasted ‚ÄúLifting gets‚Äù at http://lpaste.net/91327
04:30:17 <haasn> sipa: seems like that's coming from the ‚Äòllvm‚Äô package
04:30:22 <typoclass> eduardo_: yeah. it says "build failure: ghc 7.0". (but yeah, that text is easily missed. it should be in red, or bigger, or something)
04:30:32 <eduardo_> haasn: Thanks! Sorry for the dumb question
04:30:49 <haasn> typoclass: good idea
04:31:43 <eduardo_> haasn: I was not aware that ghc 7.x broke things...
04:31:57 <haasn> it's a major version update, there's bound to be some incompatibilities
04:32:15 <haasn> to be fair, maybe it's an upstream change or something
04:32:26 <haasn> and the package version dependencies aren't accurate enough
04:32:55 <typoclass> eduardo_: often, compiler updates mean that packages need to be updated as well. but luckily, half the time it's only minor updates that you can do quickly
04:33:00 <eduardo_> Is there a way of having multiple versions of ghc on my system? I use OS X and Windows
04:33:43 <haasn> ‚ÄúDependency llvm >=0.6.3: using llvm-0.9.0.1‚Äù <- from the failed build log
04:34:10 <haasn> it's possible it may build if you downgrade to llvm 0.8
04:34:12 <quchen> You can do multiple local installations, but I'm not sure how well Cabal works with libraries created by different compilers.
04:34:29 <typoclass> eduardo_: i guess other examples of dsls in haskell would be applicative (f <$> x <*> y <*> z) and parsec
04:34:42 <eduardo_> Then I guess it is easier if I use a VM...
04:34:44 <quchen> I'd probably create a new user for every GHC installation just to be on the safe side. (Or use a VM.)
04:34:44 <dcoutts> quchen: so long as they're different ghc versions then it all works fine
04:35:13 <quchen> dcoutts: Aren't there conflicts if the same library is installed in .cabal/lib?
04:35:28 <eduardo_> I'll try using a VM, then‚Ä¶ Thanks, guys
04:35:32 <dcoutts> quchen: it's versioned with the lib version and ghc version
04:35:32 <quchen> Each GHC has its own package DB, but Cabal doesn't seem to put everything in separate folders
04:35:44 <dcoutts> quchen: it does, so long as they're different ghc versions
04:35:45 <mm_freak> quchen, eduardo_: cabal works fine with multiple compiler installations‚Ä¶  you just have to tell it every time which compiler to use
04:35:51 <typoclass> eduardo_: oh, and i guess this is a dsl as well :-) https://github.com/pcapriotti/optparse-applicative#getting-started
04:36:02 <quchen> dcoutts, mm_freak: Ah, I looked one directory level too shallow.
04:36:06 <eduardo_> typoclass: I was just going to ask you that!
04:36:07 <quchen> There are compiler-specific subdirs.
04:36:13 <quchen> Sorry for the confusion.
04:36:30 <mm_freak> what it doesn't really support is multiple installations of the same compiler version
04:36:35 <dcoutts> quchen: if you need multiple installations of the same ghc version, then it'd be better to do "global" installations (ie into the global package db)
04:36:38 <eduardo_> typoclass: I want to learn parsec someday. I like making toy compilers and stuff
04:36:48 <mm_freak> so you should add version suffixes if you intend to do this‚Ä¶  i don't know how to do that though
04:36:52 <dcoutts> mm_freak: not with --user, but it would with --global
04:37:15 <dcoutts> mm_freak: but it'd only be sensible to do that with a ghc installation in your own user dir
04:37:31 <mm_freak> i see
04:37:33 <quchen> eduardo_: You can learn Parsec some *day*. It's not really that complicated, assuming you have a basic grasp of Monads.
04:37:55 <eduardo_> quchen: As I matter of fact, I do :)
04:38:28 <tdammers> quchen: a very basic grasp is enough to write a simple Parsec parser I'd say
04:38:48 <quchen> tdammers: I think "<- pulls out a value" is quite enough for Parsec :-)
04:38:54 <tdammers> indeed
04:39:22 <tdammers> unless you want to use Parsec on top of some monad stack with IO and whatnot underneath
04:39:53 <quchen> I've never used ParsecT.
04:40:01 <haasn> the line between what is and isn't an EDSL gets very blurry in Haskell
04:40:07 <quchen> Speaking of which, why does Parsec keep track of a user state when you can just stack it with State?
04:40:13 <tdammers> idk
04:40:20 <tdammers> convenience?
04:40:32 <tdammers> not that it is that much more convenient, if at all
04:40:38 <eduardo_> tdammers: Graham Hutton's book - Programming in Haskell - has a good chapter on writing parsers using monads.
04:40:39 <haasn> technically every library gives rise to an EDSL
04:40:41 <quchen> Efficiency would be my first guess.
04:41:11 <quchen> Or craziness :P
04:41:12 <mm_freak> quchen: the efficiency is the same‚Ä¶  it's convenience
04:41:17 <mm_freak> maybe not even that
04:41:52 <mm_freak> however, check whether there is a difference in how (<|>) behaves for state
04:43:10 <merijn> eduardo_: tbh, I think can "learn parsec" in like half an hour
04:43:18 <quchen> How does <|> behave for State?
04:43:38 <merijn> quchen: It doesn't, I suspect State is only Alternative if the value it produces is?
04:43:48 <quchen> Ah, the underlying Monad has to MonadPlus
04:44:24 <quchen> instance (Functor m, MonadPlus m) => Alternative (StateT s m) where    empty = mzero    (<|>) = mplus
04:45:28 <typoclass> eduardo_: parsec is basically "a few parse functions and a few combinators". it offers a function that will consume a char from the input, a function that will consume a digit, and so on. then it offers a second group of functions that will use them, such as "many digit" to parse any number of digits, or "sepBy string (char ':')". you use those to assemble larger parsers from smaller ones
04:46:17 <haasn> also  m `mplus` n = StateT $ \s -> runStateT m s `mplus` runStateT n s
04:46:19 <eduardo_> typoclass: Then it is very similar to what Graham Hutton does on his book!
04:46:20 <typoclass> merijn: i guess you could learn parsec in half an hour *if* you have the right material. e.g. if you try to learn it from the haddocks, it won't go well
04:46:35 <eduardo_> typoclass: What kind of grammars is it able to parse? How powerful is it?
04:46:49 <haasn> so the underlying monad chooses how to combine states, neat
04:47:07 <mm_freak> interestingly i think a parser combinator library is fully defined by Monad, Alternative and satisfy, and for most languages Applicative + Alternative + satisfy are enough
04:47:17 <quchen> eduardo_: I'm not very familiar with formal grammar, but Parsec has arbitrary lookahead.
04:47:38 <eduardo_> guchen: I guess that makes it very powerfull
04:47:51 <mm_freak> eduardo_: too powerful
04:47:54 <typoclass> eduardo_: i'm not sure, but here is a chapter that uses parsec to define a parser for csv files http://book.realworldhaskell.org/read/using-parsec.html
04:47:58 <quchen> eduardo_: At the cost of efficiency, yes.
04:48:32 <eduardo_> speaking of efficiency, do you guys know where I can learn something about haskell parallelism?
04:48:33 * haasn prefers applicative parsers for style
04:48:42 <typoclass> eduardo_: (on that page, it may be best if you start by looking at section "Extended Example: Full CSV Parser")
04:48:48 <Work_jack> eduardo_: http://chimera.labs.oreilly.com/books/1230000000929 ;)
04:48:48 <quchen> eduardo_: There's a book coming out really soon about that very subject.
04:49:13 <eduardo_> You guys rock! So sharp!
04:49:19 <quchen> Written by the guy who created much of GHC's parallel stuff.
04:49:25 <ocharles> lovely chap, too
04:49:46 <merijn> typoclass: Really? Why not, that's what I did?
04:49:51 <eduardo_> cool‚Ä¶ the book is readable online
04:49:56 <quchen> ocharles: You can't not be lovely when working around SPJ's enthusiasm haha
04:50:10 <ocharles> eduardo_: please buy copy if you can afford it though - it's a fantastic book :)
04:50:11 <eduardo_> Haskell people seam so selfless
04:50:20 <eduardo_> I will sure do
04:50:30 <ocharles> quchen: :) I haven't met SPJ, but I am looking forward to that day
04:50:41 <eduardo_> When the book is readable online that makes me more eager to buy it
04:50:42 <quchen> ocharles: Neither have I, so do I
04:50:50 <haasn> ocharles: is it okay if I buy it and then let it collect dust on a shelf while reading it online? so much more convenient!
04:51:07 <eduardo_> ocharles: you mean Simon Peyton Jones
04:51:08 <eduardo_> ?
04:51:13 <quchen> eduardo_: Simon Marlow said he's not sure how long that version will be online though. He said an official permanent HTML version is in the making, but not a priority.
04:51:19 <quchen> Let me see whether I can find some quotes for that.
04:52:01 <quchen> Here you go: http://www.reddit.com/r/haskell/comments/1iwr7x/parallel_and_concurrent_programming_in_haskell/cb8t9mu
04:52:13 <eduardo_> haasn: been there, done that!
04:52:27 <ocharles> haasn: of course, you could also buy the kindle edition if that's how you like to read
04:52:38 <ocharles> eduardo_: yea, I should be seeing him talk next month
04:52:42 <typoclass> merijn: i dunno, i found it quite difficult to figure out. i looked at the haddocks when i was beginnerish-intermediateish. it was hard to figure out how to put the stuff together ("sepBy string ..."). i was much happier with the rwh chapter, rather than the haddocks
04:53:20 <eduardo_> ocharles: He seems to be a gentleman
04:53:26 <quchen> RWH only goes so far though. All those "optional" and "multiple" combinators kind of require you to read the Haddocks (or to reinvent them).
04:53:41 <quchen> And the standard lexers, uuuuh
04:53:53 <eduardo_> ocharles: the problem is that kindle versions of technical books generally suck
04:54:09 <ocharles> eduardo_: i agree, that's why I opted for a dead tree instead
04:54:33 <Taneb> I have my books on living tree. I carve them into trees.
04:54:46 <typoclass> quchen: well yeah. i'm arguing for looking at the rwh chapter, then the haddock
04:55:05 <ocharles> Taneb: I'm visualising that like the Shrike's tree in the Hyperion books :)
04:55:12 <ocharles> (which if you haven't read and like sci-fi - read!)
04:55:16 <quchen> eduardo_: The digital version of the book comes in multiple formats when you buy them from O'Reilly.
04:55:24 <quchen> All of them are DRM free.
04:55:41 <eduardo_> guchen: cool
04:55:53 <eduardo_> quchen: just like no starch press!
04:55:55 <Taneb> ocharles, I've already got a long reading list and I'm running out of trees
04:56:17 <eduardo_> quchen: I loved "Learn you a Haskell for the greater good"
04:56:17 <quchen> eduardo_: PDF, ePub, Kindle-compatible .mobi, and DAISY
04:56:30 <quchen> eduardo_: Same here, it's the book that made me learn Haskell :-)
04:56:57 <eduardo_> quchen: The author has such a nutty sense of humor!!!
04:57:01 <Walther> the problem though, at least for me, is that you won't actually learn by just reading
04:57:10 <Walther> you have to actually start writing code and testing things out
04:57:11 <ocharles> Yea, that book sealed the deal for me too. It's lambdas all the way down
04:57:21 <eduardo_> Walther: That's right
04:57:35 <quchen> Taneb: Statistically the trunk of a tree is pretty much dead already, so why not shred it and make a book :P
04:57:38 <eduardo_> I try to learn buy coding
04:57:43 <typoclass> Walther: yes that is true. any textbook is only a guideline for writing your own code and playing around
04:57:53 <eduardo_> But have yet not done anything really useful in haskell
04:58:05 <Walther> Are there any neat haskell-to-java compilers btw?
04:58:12 <quchen> Walther: WAT.
04:58:20 <Walther> I will be forced to do java stuff for a course, thinking if I could avoid it a bit
04:58:27 <Walther> well, for a couple courses even
04:58:45 <haasn> Walther: there's Frege which is a language similar to Haskell that compiles to JVM
04:59:00 <Walther> hm, will look into that perhaps
04:59:07 <haasn> I tried it but it was insufficiently Haskell-like to be very enjoyable to use
04:59:08 <quchen> There was some project for Haskell-to-JVM, but I've heard it pronounced dead multiple times here.
04:59:14 <Walther> ok
04:59:15 <Taneb> Walther, I think that if you are doing it for a course it may be for the best to use Java
04:59:23 <Walther> Taneb: probably
04:59:37 <Taneb> It'd mean you learn Java, which is presumably the point of the course
04:59:51 <Taneb> If it isn't you could ask the instructor if you could use Haskell instead
04:59:57 <eduardo_> Java is not that bad‚Ä¶ The problem is that, after using haskell, you feel like your hands are tied.
04:59:58 <Walther> no, the point of the courses is to serve as an introduction to programming
05:00:22 <typoclass> Walther: well you could convince the prof to allow haskell, dropping the jvm bytecode requirement :-) if yes, i guess that will mean he'll either love you or hate you
05:00:38 <Work_jack> Walther: You can probably ask your instructor, but learning other languages is a good thing: I'd recommend just using Java
05:00:39 <Walther> and i've already had basics of java before, and a intro course in python, but those won't be counting as having completed the intros in the uni i actually start at now
05:00:44 <quchen> Walther: Someone has to be able to compile and correct your code, which is going to be the main issue.
05:00:49 <Walther> ^
05:01:21 <eduardo_> quchen: agreed
05:01:24 <Walther> which is why I'll most probably just bite my lip and write java for a couple courses, for the rest of the stuff it'll be projects and whatnot so i think i'll be able to use any language later on
05:01:37 <mr-> another issue is code samples you will have to complete
05:01:46 <quchen> mapM_ (print . reverse . map toUpper . show) "hello world" -- Instructor: Woot
05:01:51 <eduardo_> Walther: It you serve you as good experience
05:01:54 <Walther> yeah, but those will only be like the two first intro courses
05:02:16 <eduardo_> LOL
05:03:57 <quchen> Wait, why are there "'" in the output of the above code
05:04:14 <haasn> > show 'h' -- quchen
05:04:15 <lambdabot>   "'h'"
05:05:14 <quchen> Oh, I never thought about Char's Show instance.
05:05:15 <typoclass> quchen: ¬´print 'u'¬ª vs ¬´putChar 'u'¬ª?
05:05:17 <quchen> Makes sense though.
05:05:46 <typoclass> quchen: same as how print will add "" and \, but putStrLn will not
05:06:01 <haasn> typoclass: that would be a type error
05:06:38 <quchen> Hm?
05:06:39 <haasn> he's mapping ‚Äòshow‚Äô onto every character, then mapping toUpper over the result of that string (why not toUpper first? :), then reversing it (redundantly) and finally printing it again (which wraps it in " ")
05:06:39 <typoclass> haasn: could you elaborate?
05:06:53 <haasn> typoclass: replacing print by putChar in that snippet
05:07:04 <quchen> Ah.
05:07:19 <quchen> Also, I just wanted to write some mapM_ thing and chain multiple functions together.
05:07:25 <quchen> The program wasn't meant to make much sense.
05:07:37 <haasn> That makes more sense :)
05:07:54 <simon``> is there a neat way to sort something based on several comparisons so if the first returns EQ, the next is tried.
05:07:55 <quchen> I just wanted something I could append "-- Instructor: Woot" to :-)
05:08:00 <typoclass> haasn: oh yes you're right
05:08:08 <quchen> simon``: Yes, mappend :-)
05:08:19 <typoclass> simon``: yes, there's that Monoid instance ...
05:08:33 <simon``> quchen, typoclass: thanks!
05:08:56 <typoclass> simon``: see http://stackoverflow.com/questions/11486436/composing-two-comparison-functions
05:08:58 <haasn> it seems I am the only one who didn't understand simon``'s question
05:09:07 <haasn> oh, I think I do now
05:09:14 <haasn> ie. (Ord a, Ord b) => Ord (a, b) -- ?
05:09:27 <simon``> yup. :)
05:09:51 <haasn> oh, no, now I get it
05:10:03 <haasn> composing two ‚Äòcompare‚Äô-like functions
05:10:43 <hpaste> quchen pasted ‚Äúsimon``: Ordering monoid‚Äù at http://lpaste.net/91328
05:10:45 <typoclass> > sortBy (comparing length <> comparing sort) $ words "lol cat meow" -- simon`` here's an example. <> is mappend, i.e. it uses the Monoid Ordering instance
05:10:46 <lambdabot>   ["cat","lol","meow"]
05:10:52 <typoclass> :t comparing length
05:10:52 <lambdabot> [a] -> [a] -> Ordering
05:11:03 <ocharles> yay instance Monoid Ordering
05:11:06 <typoclass> uh wait i has a dumb
05:11:10 <typoclass> i can't haskell today
05:11:45 <typoclass> i used the Monoid (->) instance, not Monoid Ordering
05:11:47 <ocharles> yea
05:11:47 <haasn> ‚Äòcomparing sort‚Äô just blew my mind
05:11:52 <ocharles> I was about to say it's not just that Monoid
05:11:53 <haasn> typoclass: both
05:11:57 <quchen> You used both.
05:12:48 * hackagebot modular-arithmetic 1.0.1.1 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.0.1.1 (TikhonJelvis)
05:12:58 <quchen> haasn: It's my go-to example of how cool monoids are :-D
05:13:21 <haasn> i love monoids
05:13:32 <typoclass> (also the *only* example about something cool done with a monoid)
05:13:36 <typoclass> ;-) j/k
05:13:59 <quchen> Except Writer and STM and Maybe and and and
05:14:00 <haasn> I like Monoid (Maybe String) for fizzbuzz
05:14:16 <haasn> quchen: and lens!
05:14:24 <haasn> :t view traverse
05:14:25 <lambdabot> (Traversable t, Monoid a, MonadReader (t a) m) => m a
05:14:26 <quchen> haasn: I don't understand Lens.
05:14:40 <quchen> haasn: Foldable is a pretty cool guy though.
05:14:42 <haasn> quchen: you can ‚Äòread out‚Äô a multi-target traversal if the type of the target is a Monoid
05:15:25 <Taneb> > ["hi ", "quchen"] ^. traverse
05:15:29 <lambdabot>   "hi quchen"
05:16:03 <Yaniel> :t traverse
05:16:05 <quchen> > Data.Foldable.fold ["hi ", "Taneb"]
05:16:06 <lambdabot>   "hi Taneb"
05:16:31 <Taneb> > ["hi ", "quchen"] ^. folded . to length . to Sum
05:16:32 <lambdabot>   Sum {getSum = 9}
05:16:37 <Yaniel> oh right, it's not ghc
05:16:46 <tdammers> lens is great
05:16:46 <Taneb> Yaniel, it's in Data.Traverse
05:16:58 <Yaniel> :t Data.Traverse.traverse
05:16:59 <lambdabot> Couldn't find qualified module.
05:17:04 <haasn> :t traverse
05:17:08 <haasn> huh..
05:17:09 <Taneb> Traversable, sorry
05:17:13 <Yaniel> :t Data.Traversable.traverse
05:17:14 <quchen> I find Lens too complex in most cases. It's great how generic it is, but sometimes it's too much for me.
05:17:14 <simon``> haasn: how does your Monoid (Maybe String) for fizzbuzz look like?
05:17:15 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:17:16 <tdammers> the type signatures are crazy at times hough, to the point that they are almost useless as documentation
05:17:19 <Yaniel> there it is
05:17:19 <tdammers> *though
05:17:29 <haasn> simon``: fizzBuzz x = fromMaybe (show x) $ ["fizz" | x `rem` 3 == 0] <> ["buzz" | x `rem` 5 == 0]
05:17:43 <Taneb> tdammers, lens has some of the best documentation around, aside from type signatures
05:17:48 <haasn> tdammers: yeah the MonadReader overloading for what should be a simple function is a bit unnecessary at times
05:18:15 <Taneb> haasn, in earlier versions there were two combinators
05:18:21 <tdammers> Taneb: yes, it does
05:18:29 <Taneb> And I misuse the word combinator quite egregiously
05:18:32 <Taneb> There were two functions
05:18:39 <tdammers> typing "lens" in my address bar gives the lens operator cheat sheet as the first result
05:18:40 <Taneb> "view" and not view
05:18:51 <haasn> :t (^.) -- this one is still not overloaded is it?
05:18:51 <lambdabot> s -> Getting a s a -> a
05:18:52 <Taneb> One was specialized to functions, the other was for MonadReaders
05:18:56 <haasn> yeah
05:19:13 <haasn> Taneb: it was ‚Äòget‚Äô or something wasn't it?
05:19:37 <simon``> haasn: peculiar.
05:19:47 <haasn> wait, ‚Äòget‚Äô is standard MonadState stuff
05:19:50 <Taneb> haasn, peruse
05:19:53 <typoclass> simon``: anyhoo. if you (like me) need some extra explanation, then (comparing length <> comparing sort) first uses instance Monoid (a -> b), which duplicates the input because that instance's mappend is defined as mappend f g x = f x `mappend` g x. this makes a second call to mappend, here the Monoid Ordering instance. see also http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-Monoid.html
05:20:16 <Yuu-chan> Where is <> defined?
05:20:16 <simon``> typoclass: that's quite fine, thank you!
05:20:18 <quchen> (f <> g) x = f x <> g x   --   Monoid instance for functions
05:20:22 <Taneb> Yuu-chan, Data.Monoid
05:20:27 <haasn> Yuu-chan: Data.Semigroup -- for me
05:20:28 <quchen> Yuu-chan: <> is an infiy synonym for mappend, nothing more
05:20:52 <haasn> ah, I import Data.Monoid hiding ((<>))
05:21:09 <typoclass> Yuu-chan: it's somewhat new. i guess you won't have it if your compiler is 2 years old or so
05:22:31 <Yuu-chan> typoclass: yes, there is only GHC 7.0.4 installed. But I wonder why Hoogle couldn't find that operator
05:22:48 <haasn> simon``: the example I used relies on MonadComprehensions for ["fizz" | x `rem` 3 == 0]  <- which desugars to something like guard (x `rem` 3 == 0) >> return "fizz"; and ‚Äòguard‚Äô for Maybe returns Nothing if it fails; or Just () otherwise -- the (<>) then combines those two Maybe Strings such that Nothing is an identity and the inner two strings are themselves (<>)'d
05:23:00 <haasn> so Just "fizz" <> Just "buzz"  -> Just "fizzbuzz"
05:23:08 <haasn> it's quite neat, though I can't take credit for it myself
05:23:21 <typoclass> Yuu-chan: ugh, well, because hoogle is somewhat unreliable. hayoo can give you a second opinion
05:23:24 <typoclass> @where hoogle
05:23:24 <lambdabot> http://haskell.org/hoogle ‚Äì See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:23:34 <merijn> ugh
05:23:45 <merijn> I want my recursive imports :(
05:24:00 <Yuu-chan> Nice, thanks :)
05:24:22 <simon``> haasn: ah, so the []s are just comprehensions and not actually lists.
05:24:46 <Yuu-chan> Could you please explain the magic of comparing length <> comparing sort?
05:25:17 <typoclass> haasn: so the full example would be something like ["fizz" | ...] <> ["buzz" | ...] ?
05:25:36 <simon``> Yuu-chan: it uses the Monoid b => Monoid (a -> b) instance
05:25:53 <typoclass> Yuu-chan: sure. start by looking at the message i wrote to simon`` about 5 minutes ago
05:26:01 <typoclass> Yuu-chan: which part is unclear?
05:26:01 * Yuu-chan tries to understand typoclass' explanation above
05:26:47 <quchen> Yuu-chan:  (comparing length <> comparing sort) x y    -> Use the Monoid b => Monoid (a -> b) instance
05:27:00 <quchen> ==> (comparing length x <> comparing sort x) y
05:27:03 <quchen> (use it again)
05:27:14 <quchen> comparing length x y <> comparing sort x y
05:27:29 <quchen> Now both sides evaluate to Orderings, hence the <> is the Ordering-<>
05:27:55 <quchen> Which means the thing first compares the lengths of x and y, and then the sorted versions of them.
05:28:13 <haasn> EQ is the identity for Ordering
05:28:29 <haasn> otherwise it's just left-biased
05:28:57 <Yuu-chan> > [x `mappend` y | x <- [LT, EQ, GT], y <- [LT, EQ, GT]]
05:28:58 <lambdabot>   [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
05:29:01 <haasn> EQ <> y = y; x <> _ = x
05:29:22 <typoclass> :t comparing length -- Yuu-chan: this may help. this selects the Monoid (x -> y) instance, because x = [a] and y = [a] -> Ordering. it then selects the same instance a second time with x = [a] and y = Ordering. it then selects another Monoid instance, which is the Monoid Ordering instance
05:29:22 <lambdabot> [a] -> [a] -> Ordering
05:29:56 <Tinned_Tuna> >  [(x,y,x `mappend` y) | x <- [LT, EQ, GT], y <- [LT, EQ, GT]]
05:29:57 <lambdabot>   [(LT,LT,LT),(LT,EQ,LT),(LT,GT,LT),(EQ,LT,LT),(EQ,EQ,EQ),(EQ,GT,GT),(GT,LT,G...
05:30:49 <Yuu-chan> I still don't get the result :( So how words are arranged there?
05:31:34 <quchen> Yuu-chan: How do you compare whether one word is lexicographically smaller than another word (by hand)?
05:31:49 <quchen> You look at the first letter of both words, and compare them.
05:32:06 <quchen> If one is larger than the other, the whole corresponding word is larger (or smaller) than the other.
05:32:08 <Yuu-chan> So, words are compared by length, than (in case of equality) lexicographically by set of letters, right?
05:32:13 <quchen> That's what "x <> _ = x" encodes.
05:32:17 <typoclass> Yuu-chan: the output is sorted first by length (first all the 3-letter words, then the 4-letter word), and in case of a tie, it's sorted alphabetically (the two 3-letter words are sorted alphabetically)
05:32:43 <typoclass> Yuu-chan: yes exactly
05:33:19 <Yuu-chan> > sortBy (comparing length `mappend` comparing sort) $ words "a quick brown fox jumps over the lazy dog"
05:33:20 <lambdabot>   ["a","dog","the","fox","lazy","over","brown","quick","jumps"]
05:34:10 <Yuu-chan> Aha. Thank you guys!
05:34:40 <maltem> So I really failÖ I managed to implement Gaussian elimination in a way that leaks space (and time)
05:35:09 <maltem> If I already put deepseqs everywhere in the "loop", what remains to try?
05:35:21 <quchen> Posting the code would be a good start
05:35:54 <maltem> yep, I'll try to distill it from what I have (there are more types involved than necessary)
05:36:08 <quchen> Good. :-)
05:38:06 <typoclass> maltem: note that hpaste's url changed recently
05:38:07 <typoclass> @paste
05:38:07 <lambdabot> Haskell pastebin: http://hpaste.org/
05:38:13 <typoclass> urgh! that's the old one
05:38:17 <typoclass> @where hpaste
05:38:17 <lambdabot> http://lpaste.net/new/haskell
05:38:21 <typoclass> this ^^
05:40:01 <maltem> thanks, I hope you're patient enough until I have something to post :)
05:47:56 --- mode: ChanServ set +o mauke
05:47:57 --- mode: mauke set -b *!*@*.dsl.dyn.telnor.net$#haskell-ops
05:48:20 --- mode: mauke set -b $r:*.dsl.dyn.telnor.net/*$#haskell-ops
05:49:43 <hpaste> maltem pasted ‚ÄúGaussian space leak‚Äù at http://lpaste.net/91329
05:50:05 * simon`` trolls job interviewer's question "Please rewrite the following code so it works better" by rewriting C# code in Haskell. ;-)
05:50:11 <maltem> (sorry, it's still quite large, but at least it's self-contained now)
05:50:20 --- mode: mauke set -o mauke
05:50:53 <maltem> the entry point would be "gauss"
05:50:56 <typoclass> simon``: excellent :-)
05:51:39 <simon``> I suppose making an algebraic type Employee a typeclass of something is sort of like "rewriting the Employee class"
05:52:58 <typoclass> > sortBy (comparing length <> comparing sort) $ words "jumps quick a b" -- apparently q comes before j in the alphabet. or the code has a bug. not sure yet.
05:52:59 <lambdabot>   ["a","b","quick","jumps"]
05:53:55 <Yaniel> interesting
05:54:10 <basvandijk> Hello, does anybody know how this log analysis tool is called that is written in Haskell?
05:54:52 <typoclass> (spoiler: here is a bugfix) > sortBy (comparing length <> compare) $ words "a quick brown cat jumps over the lazy cat"
05:54:57 <quchen> > (sort "jumps", sort "quick") -- typoclass
05:54:58 <lambdabot>   ("jmpsu","cikqu")
05:55:04 <quchen> c < j.
05:55:10 <gavri> is there a way to get the list of user processes in haskell or any of its standard libraries? or do I have to run an external command like ps? This module doesn't seem to have a "list processes" function http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html
05:55:32 <typoclass> quchen: dude that's like, so old. i was 4 seconds faster :-D
05:55:38 <yitz> > sortBy (comparing sort) $ words "jumps quick a b"
05:55:40 <lambdabot>   ["a","b","quick","jumps"]
05:56:32 <quchen> gavri: If you're looking for a function "getOpenThreads :: IO [ThreadID]", we recently discussed that here, and didn't come up with a solution. I think there's an old ticket asking for such a function on Trac.
05:56:40 <typoclass> gavri: i don't know if there's a package, but you could always list the contents of directory /proc. or indeed run ps
05:57:00 <gavri> thanks, quchen and typoclass
05:57:13 <gavri> wondering which approach is more portable
05:57:15 <gavri> ps options
05:57:17 <gavri> or /proc
05:57:38 <gavri> proc is linux specifix, right?
05:57:42 <yitz> ps is more portable, but there are variations on the options
05:57:54 <gavri> yeah, ps is more portable than /proc
05:58:05 <typoclass> gavri: /proc is linux-only, as far as i know. ps is somewhat standardized. should be fine as long as you only use the posix switches
05:58:09 <merijn> quchen: The problem with getOpenThreads is that it breaks encapsulation of things like async and any library using threads
05:58:12 <gavri> but I'll need to use the "-o" option
05:58:14 <yitz> gavri: not only linux specific, but it can change from one version of the linux kernal to another
05:58:19 <gavri> and prevent headers from being displayed
05:58:37 <merijn> quchen: Suddenly every library using threads has to be designed to deal with exceptions from arbitrary code, not just library code
05:58:48 <gavri> k, thanks all. I love haskellers on irc
05:59:10 <quchen> merijn: Good point. Maybe we should call it 'unsafeGetOpenThreads'.
05:59:10 * typoclass purrs
05:59:11 <merijn> quchen: I'm already having a hard time desiging my library to play with exceptions from my own code, having to make it safe in the presence of exceptions from outside would make me cry
05:59:33 <maltem> quchen, typoclass: may it be that Data.Map always retains the old data when I update some Map?
05:59:51 <quchen> maltem: Elaborate?
06:00:11 <quchen> Maps are immutable like any other Haskell value. If you update a map, you'll get a new one.
06:00:28 <yitz> merijn: i see your point. although being in IO, of course many unexpected things could still happen that are unrelated to your library code, even without getOpenThreads.
06:00:53 <maltem> quchen, I'm wondering if the old map will be gc'ed
06:01:10 <quchen> maltem: Not all of it.
06:01:14 <yitz> maltem: generally a lot of the map is re-used. the parts that aren't are gc'ed/
06:01:36 <maltem> ok, that shouldn't be a problem in itself then
06:01:37 <quchen> maltem: When you change a single element in a Map, most of the two Maps you get (the old and new one) can be shared in memory.
06:01:49 <merijn> yitz: Only two things can happen: I do an operation that throws an exception or my own code throws an exception
06:01:58 <quchen> If you decide not to use the old Map anymore, the parts not needed by the new map can be GC'd.
06:01:59 <merijn> yitz: Which means that preventing resource leaks is easy
06:02:04 <yitz> merijn: out of memory?
06:02:17 <yitz> merijn: power failure?
06:02:37 <merijn> yitz: power failure is irrelevant for resource safety, if the program dies you can't leak anything
06:03:00 <yitz> merijn: no, your UPS sends a power failure signal and you get a signal
06:03:21 <merijn> yitz: That's hardly a library design issue
06:03:31 <merijn> yitz: That's something a program has to deal with
06:04:04 <maltem> quchen, yitz: Any bets then where the pasted code could be leaking?
06:04:07 <merijn> yitz: My networking library has to make sure it doesn't like sockets/file descriptors. Which I do by being really careful with async exceptions
06:04:07 <yitz> merijn: right so if someone throws some other kind of unplanned exception at you, why is that any different?
06:04:31 <quchen> maltem: Oh, I missed that paste
06:04:35 <merijn> yitz: User code can't throw async exceptions to my library threads, because they don't have thread ids, so I don't have to worry about that
06:04:36 <typoclass> merijn: well, what if your code runs on a quantum computer and *all the things* happen? at the same time?
06:04:37 <typoclass> ;-)
06:05:08 <maltem> quchen, ah, http://lpaste.net/91329
06:05:27 <merijn> yitz: Other exceptions have two options: 1) Occurs in code of library user, in which case, not my problem or 2) during some operation I'm doing, which is no different from any other IO exception I already deal with
06:06:02 <quchen> maltem: btw, r `deepseq` r == force r
06:06:06 <yitz> merijn: the OS can though. and there can be plenty of other things less fatal than out of memory which can do that.
06:06:08 <merijn> yitz: The entire point is that no one can throw unplanned exceptions at my code, because they can't throw anything at my code
06:06:14 <merijn> yitz: No, it can't
06:06:26 <merijn> yitz: The OS can only signal processes/OS threads, not haskell threads
06:06:37 <merijn> yitz: Which means the runtime or application have to handle those
06:06:38 <maltem> quchen, actually that lines goes r `deepseq` (r - Ö)   :)
06:07:02 <quchen> \r -> r `deepseq` r - (r `coeff` j) .* pivot_row
06:07:06 <quchen> That parses as
06:07:10 <quchen> \r -> (r `deepseq` r) - (r `coeff` j) .* pivot_row
06:07:33 <maltem> oh, that's a good remark
06:07:43 <yitz> maltem: use force
06:07:51 <quchen> <quchen> maltem: btw, r `deepseq` r == force r
06:07:52 <quchen> :-)
06:08:12 <merijn> yitz: getOpenThreads would break tht assumption, as now unplanned exceptions *can* be thrown at my code
06:08:43 <maltem> well, maybe I should force or seq something different
06:08:55 <yitz> merijn: perhaps. it seems weird to me to rely on such an assumption though.
06:09:23 <merijn> yitz: Why?
06:09:32 <quchen> maltem: Does the program always run out of memory, or just for larger systems?
06:09:37 <edkk> @pl f = f x y
06:09:37 <lambdabot> f = fix (flip ($ x) y)
06:10:04 <quchen> maltem: You could try running it with profiling and see which function takes the most memory. It's really hard to go through the thing visually as it stands
06:10:22 <yitz> merijn: just like in top-level IO you need to handle any kind of exception, including kinds you can't predict or know about in advance, it seems natural that the same should be true in a thread. that's just part of what IO is.
06:11:10 <merijn> yitz: You need to handle any *synchronous exception*
06:11:11 <yitz> merijn: if there were such an additional guarantee in threads, there should be a more restricted monad for that. kind of like ST.
06:11:40 <yitz> or STM
06:11:40 <maltem> quchen, only for larger systems. My "real-world" matrix where it fails is 105◊210
06:11:43 <merijn> yitz: Those can be dealt with by bracket and friends
06:12:48 <merijn> yitz: Top level IO doesn't have to deal with asynchronous exceptions because there is no notion of asynchronous exceptions without threads...
06:13:11 <quchen> maltem: (<>) = union for maps  -- I'll just keep linting around until I come up with something helpful
06:16:22 <quchen> maltem: Try compiling it with -prof -auto-all and 100*100, then run with +RTS -P. Open the generated .prof file and see whether some function uses excessive memory.
06:16:55 <quchen> Or try with 20*20 first, because profiling may eat up some performance.
06:21:02 <yitz> merijn: i'm not sure what the distinction is. when you throw an exception at a thread, you can't handle that with bracket, catch, etc.?
06:22:27 <merijn> yitz: The problem is that secretly bracket resource allocation is not fully atomic
06:22:43 <merijn> yitz: If resource acquisition in bracket blocks it can still be interrupted by an exception
06:23:06 <maltem> quchen, I'll try that
06:23:15 <merijn> So if you have non-trivial resource allocation you need to protect, then you don't want to be interrupted while doing that
06:23:24 * typoclass is somewhat terrified what on earth merijn is doing
06:23:33 * yitz agrees
06:23:57 <yitz> merijn: this doesn't actually involve missiles, does it? (gulp)
06:23:58 <merijn> typoclass: I recommend not writing C, then :)
06:24:48 <merijn> typoclass: Actually I just need to spawn of handlers for a socket, the problem is that I need one to read from and one to write to the socket, and obviously both the threads and sockets need to be cleaned up properly to not leak resources
06:25:03 <yitz> merijn: anyway, the story about blocking exceptions changed significantly not that long ago. are you talking about the current situation?
06:25:20 <merijn> typoclass: This means being careful with installing cleanup handlers that make sure both threads and sockets are getting cleaned up
06:25:34 <typoclass> merijn: not if i can help it. if anyone asks me to write c, i'll poop on their bed. and scratch their furniture. also distribute the contents of the litter box throughout the room
06:25:55 <merijn> yitz: I read Simon's book to see if there was anything about haskell concurrency I missed, his explanation in the book matches what I knew already, so I'm asuming yes
06:26:09 <yitz> merijn: right, embedded software on missiles tends to be written in C, and they have been known to blow up because of that :)
06:26:35 <Rembane> Aren't missiles made for blowing up?
06:26:51 <merijn> typoclass: Developing a concurrent runtime in C has been a job for over a year until January :p
06:27:07 <typoclass> Rembane: yes, but bonus points if they blow up near the enemy and not, say, while being carried on our own airplane
06:27:07 <yitz> Rembane: yes but usually you want to have some control over exactly when. otherwise, the results can be rather embarassing.
06:27:11 <merijn> typoclass: Even worse, it was a distributed, concurrent runtime written in C :)
06:27:25 <Rembane> typoclass, yitz: ^______^
06:28:03 <merijn> typoclass: Haskell concurrency doesn't scare me, I'm just properly paranoid about haskell implementation details to make sure my code is safe. Because if the code is safe I can have neat high level wrappers and not have to worry about it anymore :p
06:29:04 <yitz> merijn: i would look at the current library source code rather than (or in addition to) simon's book. especially in the GHC.* modules. there are good comments about this stuff there.
06:29:49 <merijn> yitz: I know :)
06:30:16 <merijn> yitz: I was just pointing out that these types of considerations are a good argument *against* the ability to query which threads exist
06:30:24 <quchen> Using a makefile, it's quite easy to write a "make with profiling, then run with the following flags". Is there something similar to that in Cabal?
06:30:47 <quchen> "cabal build --prof" or something like that, with a specific --prof instruction set in the .cabal file?
06:30:48 <typoclass> merijn: i would ask about having two threads on the haskell side (instead of c), one for reading one for writing. but i assume you have already thought of that and rejected it
06:32:24 <typoclass> quchen: i think they're recommending to just build everything with profiling enabled. i.e. turn on that switch in your global cabal config ... http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
06:33:17 <merijn> typoclass: I have that
06:33:29 <yitz> merijn: i hear what you are saying. but it still seems that the kinds of guarantees you want, as nice as they are, don't seem to me to be expected as part of the usual philosophy of the IO monad, nor does the type signature of forkIO imply any such guarantees.
06:33:32 <merijn> typoclass: But that means cleanup becomes more complicated
06:34:40 <merijn> yitz: forkIO doesn't imply it, but you might expect stronger guarantees from libraries than from forkIO
06:35:03 <simon``> do database transactions usually happen through the IO monad?
06:35:17 <eduardo_> Guys, is it possible to install hackage packages that depend on llvm on windows?
06:35:32 <merijn> yitz: i.e. "my program's networking doesn't magically break due to unexpected exceptions being thrown at it by some other library that is messing with threads it shouldn't"
06:36:30 <yitz> merijn: forkPrivatIO :: IO () -> (ThreadId -> IO a) -> IO a
06:36:34 <quchen> simon``: Yes, always. Doing DB stuff is a real world sie effect.
06:36:51 <quchen> (Unless the DB is entirely contained in your program, of course.)
06:37:12 <merijn> yitz: I think you misunderstood what I was saying because you didn't read the context
06:37:14 <simon``> quchen: thanks!
06:37:18 <yitz> merijn: could be
06:37:29 <merijn> yitz: The original question was "why is there no "getRunningThreads :: IO [ThreadId]"
06:37:56 <merijn> yitz: I already hide my libraries threadid's, the problem is that "getRunningThreads" would expose them
06:38:07 <merijn> I was explaining why that reexposure is undesirable
06:38:27 <merijn> Stopping your own library from leaking thread id's is easy (as you just showed)
06:38:41 <merijn> But it relies on the current inability to query that info
06:39:38 <yitz> merijn: yes. i still don't see why a thread spawned directy or indirectly using forkIO, given its type signature, and given the usual "all bets are off" semantics of the IO monad, should be bothered by what someone could do it by using getRunningThreads.
06:40:22 <merijn> Why should IO have "all bets are off" semantics?
06:40:38 <yitz> merijn: i am not talking about implementing that on top of forkIO. I am talking about it as a built-in, so that its thread IDs would then *not* be visible in getRunningThread.
06:40:40 <merijn> According to that logic implementing "readLn = undefined" would be fine too :)
06:41:08 <yitz> merijn: that does seem to happen sometimes actually :)
06:41:18 <typoclass> merijn: why would people use a dangerous hypothetical mechanism to get your private ThreadIds, then throw weird unexpected exceptions at your threads? it sounds like if someone is doing something that funky, they deserve it
06:42:08 <merijn> typoclass: True, unfortunately that mechanism means that any library you use could potentially do that funky thing, making it hard to track down who is crashing your program
06:42:41 <typoclass> i mean, isn't it a bit like saying, i need to guard against an adversary going into my memory and changing a few bytes?
06:42:47 <typoclass> merijn: hm yeah ...
06:43:32 <merijn> typoclass: I would advocate against libraries having the ability to randomly fiddle with memory too :p
06:43:34 <yitz> yeah i guess typoclass is right. the purpose of getRunningThreads would presumably be for some kind of monitoring. if you use it to throw exceptions, good luck. (though i still think somehow the type system should protect against that)
06:44:05 <typoclass> merijn: oh, absolutely :-)
06:45:19 <typoclass> yitz: yes. i guess what would be acceptable is "getRunningThreads :: IO [ThreadId']", with ThreadId' being a new thing that you can only use for getting some statistics or other read-only stuff, not for throwing exceptions
06:47:23 <yitz> typoclass: continuing merijn's memory analogy, how about a way to allocate (in IO) a pure data object together with a handle which could be queried for things like whether the object is still alive or GC'ed, and if alive, how much memory it is using?
06:48:59 <typoclass> yitz: sure, why not. that could occasionally be useful. but i don't know much about this sort of internal ghc thing
06:49:11 <cidevant> hi !) How can I convert Int -> [Int]
06:49:21 <cidevant> for ex: 1234 -> [1, 2, 3, 4] ?
06:49:58 <typoclass> cidevant: hello. you could use divMod, calling it multiple times
06:49:59 <Yaniel> > 1:[]
06:50:00 <lambdabot>   [1]
06:50:13 <typoclass> > 1234 `divMod` 10 -- this would be the first step
06:50:14 <lambdabot>   (123,4)
06:50:26 <nschoe> cidevant, I think you would need to use maths here : use logarithm to know how many digits you have
06:50:26 <yitz> > let toRadix b = reverse . map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in toRadix 10 1234
06:50:27 <lambdabot>   [1,2,3,4]
06:50:43 <nschoe> yitz, elegant... :)
06:50:48 <roconnor> > unfoldr (\x -> if 0 == x then Nothing else Just (x `divMod` 10)) 1234
06:50:49 <lambdabot>   [123,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:50:55 <Taneb> Is there a way to write an anamorphism for Maybe? (is this the question I want?)
06:51:02 <typoclass> reverse map mod what? :-)
06:51:03 <roconnor> > unfoldr (\x -> if 0 == x then Nothing else Just (swap (x `divMod` 10))) 1234
06:51:05 <lambdabot>   [4,3,2,1]
06:51:15 <roconnor> ... needs unfoldl
06:51:26 <tikhon> :t swap
06:51:27 <lambdabot> (a, b) -> (b, a)
06:51:31 <yitz> roconnor: or iterate
06:51:37 <typoclass> roconnor: i think someone had a "guard" variant with that, instead of "if 0 =="
06:51:47 <roconnor> typoclass: ooh
06:51:50 <cidevant> Thanx
06:52:03 <typoclass> roconnor: iirc we talked about it just a few weeks ago
06:52:07 <cidevant> SOLVED: let toRadix b = reverse . map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in toRadix 10 1234
06:52:12 <yitz> nschoe: thanks
06:52:32 <roconnor> > unfoldr (\x -> [swap (x `divMod` 10) | x != 0]) 1234
06:52:33 <lambdabot>   Not in scope: `!='
06:52:33 <lambdabot>  Perhaps you meant one of these:
06:52:33 <lambdabot>    `!' (imported from D...
06:52:36 <roconnor> > unfoldr (\x -> [swap (x `divMod` 10) | x /= 0]) 1234
06:52:38 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a0, b0)'
06:52:38 <lambdabot>              with ...
06:53:30 * roconnor isn't sure how monad comprehensions work
06:53:41 <tikhon> just like do notation
06:54:58 <typoclass> ... as i always say, i still think 'base' should contain some kind of iterate2 :: (a -> (b, a)) -> a -> [b] thing. you could use it with break, span, flip divMod, and so on
06:55:13 <shergill> :t iterate
06:55:13 <lambdabot> (a -> a) -> a -> [a]
06:55:54 <yitz> typoclass: unfoldr is supposed to be that. there are many possible variations on it though.
06:56:03 <roconnor> :type unfoldr . (Just .)
06:56:10 <roconnor> :t unfoldr . (Just .)
06:56:10 <lambdabot> (b -> (a, b)) -> b -> [a]
06:56:48 <roconnor> :t fmap unfoldr (fmap return)
06:56:49 <lambdabot> (b -> (a, b)) -> b -> [a]
06:56:55 <typoclass> yitz: right, the difference is that iterate2 would keep doing its thing infinitely, like iterate. you'd use takeWhile or some such to cut off the list
06:57:18 <yitz> typoclass: roconnor's variant does that
06:57:23 <roconnor> typoclass: iterate2 should return a Stream not a List.
06:57:50 * hackagebot bindings-libzip 0.11 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.11 (SergeyAstanin)
06:57:52 * hackagebot LibZip 0.11 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.11 (SergeyAstanin)
06:58:20 <Cale> roconnor: Well, so "should" iterate, but infinite lists are a reasonable substitute for streams unless you're actually trying to reason about termination through the type system.
07:00:31 <Cale> I actually agree on needing something like iterate2 defined perhaps just as roconnor wrote it. (I'm not sure iterate2 is the best name for it, but we can bikeshed that separately :)
07:00:37 <typoclass> > let until f predicate x = if predicate out then [] else out : (f `until` predicate) xnext where (xnext, out) = f x in ((`divMod` 10) `until` (== 0)) 123 -- cidevant: here is another possibility. i dug out the solution that was discussed in #haskell on 8 july 2013 :-)
07:00:39 <lambdabot>   [3,2,1]
07:00:45 <Cale> The thing is, unfoldr is usually a bit annoying to actually apply in the various special cases where you need it.
07:01:18 <Cale> Frequently, some combination of map, iterate, and takeWhile ends up doing better.
07:01:19 <Yaniel> what is unfoldr anyways?
07:01:23 <Yaniel> or where
07:01:23 <Cale> :t unfoldr
07:01:24 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
07:01:42 <typoclass> Yaniel: basically it produces a list until you say "stop"
07:01:54 <roconnor> Cale: it would be easier if List was defined as Mu (Compose Maybe (a,))  :P
07:02:00 <Yaniel> i.e. until it gets a Nothing?
07:02:07 <typoclass> ("you" = the function that you pass into unfoldr as the first argument. "say stop" = return Nothing)
07:02:16 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "This string contains the numbers 25, 42, and 362." :: [Int] -- my favorite use of unfoldr
07:02:17 <lambdabot>   [25,42,362]
07:02:20 <Cale> @src unfoldr
07:02:20 <lambdabot> unfoldr f b  = case f b of
07:02:20 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
07:02:20 <lambdabot>    Nothing        -> []
07:02:23 <Yaniel> kthx
07:02:29 <Cale> yep
07:03:22 <nschoe> yitz, OMG I've struggled for so long to get that result... and again it was by far less elegant :P
07:04:03 <Cale> You give it a function to iterate, and an initial value of type b, and it applies the function, either obtaining a value of type a and a new value of type b (in which case it produces the value of type a in its output list and recursively uses the new b value for the rest of the list), or it gets Nothing and stops, producing an empty list.
07:04:04 * typoclass still thinks listToMaybe should be called head
07:04:05 <typoclass> ;-)
07:04:22 <Cale> typoclass: Well, there are some idiomatic safe uses of head
07:04:30 <yitz> typoclass: yeah. too late.
07:04:39 <typoclass> cale: yeah ...
07:04:41 <shergill> so what's the consensus on arrows? i'd heard about them a year or two ago, and yesterday i figured i'd dig into it. are their specific use cases where they've been found to be the better abstraction to use (than, say monads and splicatives)?
07:04:45 <Cale> map head . group . sort, for instance
07:04:52 <yitz> Cale: there are some idiomatic safe uses of unsafePerformIO, too.
07:04:56 <donri> there are safe uses of weak dynamic type systems
07:04:58 <shergill> *there
07:05:40 <tikhon> I personally don't like arrows, but I don't know if that represents a consensus
07:05:41 <Cale> yitz: Maybe! Can you think of one?
07:06:13 <yitz> Cale: no, use Data.List.NonEmpty.head for that
07:06:25 <donri> Cale: ffi? doesn't ST use it too
07:06:27 <roconnor> shergill: I've never made any serious use of Arrows in my 10 year Haskell life.
07:06:42 <Cale> donri: Well "ffi" doesn't count as an idiom.
07:06:45 <yitz> Cale: don't text and bytestring use it internally?
07:06:47 <donri> ok :)
07:06:58 <Cale> (and I don't mean in the applicative sense, but in the sense of something we do regularly)
07:07:01 <yitz> Cale: anyway, ResourceT does
07:07:13 <tikhon> Among other things, arrows just feel more arbitrary than functors/applicatives/monads
07:07:33 <elliott> Arrows are quite a well-defined and sound abstraction. unfortunately it's a bad one.
07:07:47 <tikhon> I think they would make more sense without arr
07:07:50 <elliott> and severely flawed for what you might want to use them for.
07:07:57 <Cale> I've used Arrow perhaps more than 99% of people out there, and I think in its present form, it's not terribly usable, but if tweaked a bit, there's certainly a place for it!
07:08:05 <roconnor> As I recally the arrows laws are strange in that parrellel arrows feel like they should commute, but they don't.
07:08:13 <Cale> roconnor: That's correct.
07:08:14 <yitz> tikhon: i don't think they're arbitrary. it just turns out that applicative is more convenient to use and results in clearer code. i think that was a non-trivial discovery.
07:08:30 <shergill> yeah, i recall skimming over them last year and looking at the various laws. but they seemed more like an exercise in academic dalliance. i probably need to read the arrows paper again, to really grasp the problem they try and solve
07:08:40 <tikhon> applicative feels like a very natural generalization of functors
07:08:46 <maltem> quchen, so I digged around somewhat, profiling. Alas, all it told me that time and space are primarily spent for the numerical operations in row_transformation, so no surprise here. I still cannot tell why things are not gc'ed. Let's just hope that I'll be wiser on another day
07:08:48 <elliott> it sucks how badly Arrow interacts with GADTs, also.
07:08:50 <Cale> The paper introducing Arrow decided to forego the law that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k), but that was, imo, a mistake
07:09:07 <yitz> tikhon: it seems so now, but it took a few years before people thought of it
07:09:16 <tikhon> sure
07:09:21 <donri> shergill: i think Category+Applicative gives you most of the use cases for Arrow, but without the problems like the performance hit of the tuples
07:09:29 <Cale> It's because if you want that law, you give up on having a Kleisli arrow for most monads (only commutative monads give arrows then)
07:09:46 <Cale> The order of effects of g and h get swapped.
07:10:21 <quchen> maltem: That's unfortunate. The next thing you could do is the heap profiling RWH has a chapter about.
07:10:30 <yitz> tikhon: the fact that <*> looks just like curry's S combinator was a clue that we were really onto something good.
07:10:33 <Cale> So, presumably because monads were especially popular at the time, Hughes wanted Arrows to generalise them.
07:11:23 <roconnor> I was visiting Conor last week and I got the low-down on the invention of Applicaitives.
07:11:30 <Cale> The real problem with Arrow is the extent to which you're forced to use "arr" to do anything useful, and the fact that arr gets in the way of the primary reason why you'd want Arrow over Monad.
07:11:47 <roconnor> Apparently Conor wanted to write Haskell code like in an ML style.
07:11:50 <elliott> yitz: and pure is K of course.
07:12:09 <shergill> Cale: could you elaborate?
07:12:10 <yitz> elliott: ok. somehow that seems less enlightening though.
07:12:13 <donri> Cale: weren't you sketching out a "new Arrow"?
07:12:30 <tikhon> at least for me, some of the things I wanted to do with arrows when I first read about them wouldn't work with arr
07:12:33 <elliott> yitz: I think it completes the picture. Applicative gives us S and K, and as we know, S and K give us everything :)
07:12:42 <yitz> elliott: ok
07:12:44 <tikhon> for example, I wanted to encode reversible computations
07:12:49 <Cale> donri: yeah, iPwn has an internal new Arrow library which we'll have to release at some point, perhaps along with our preprocessor
07:13:06 <donri> Cale: sounds promising!
07:13:08 <shergill> heh@iPwn
07:13:48 <Cale> shergill: When you write x >>= f, the f is necessarily of function type, and functions in Haskell are totally opaque. There's nothing you can do with this to simplify the computation you'll have to do because all you could do with f is apply it to a value which you won't have until you actually execute x.
07:14:12 <yitz> Cale: may i guess that it only has klieli arrow for commutative monads :)
07:14:21 <Cale> shergill: By contrast, when you're writing Arrow computations like f >>> g, the f and g are both of a type that you have some control over.
07:14:38 <Cale> yitz: That's right
07:15:03 <Cale> shergill: and so perhaps there's room to do analysis to simplify things before executing the composite computation
07:15:18 <shergill> Cale: right, makes sense
07:15:26 <maltem> quchen, I think heap profiling would only tell me what I already know, not give me a hint at the reason
07:15:27 <shergill> also getting a sense of deja vu from that paper
07:15:29 <Cale> (maybe f and g are inverses for instance, and perhaps you can determine this)
07:15:43 <Cale> However, arr spoils almost any analysis
07:16:23 <quchen> maltem: Probably, but I'm out of ideas (and experience) here :-\
07:16:28 <Cale> any time you have something like  f >>> arr h >>> g, there's no real hope of doing any kind of optimisation across that
07:16:35 <shergill> well it's just a dummy conversion from function to arrow right?
07:16:46 <Cale> because just like before, you have no idea what h is because it's a function.
07:16:56 <shergill> right, gotcha
07:17:38 <donri> data MyArrow a b = Arr (a -> b) | F a b | G a b  -- as soon as we have an 'Arr'; we're back to square one: functions are opaque
07:17:53 <Cale> However, the proc/do notation has a tendency to stick 'arr' in between *every* pair of lines in the do block, with functions that rearrange nested pairs of pairs in various ways, and pull out bits which are to be acted on
07:17:53 <maltem> quchen, I'm happy enough to know that it is, indeed, not easy :)
07:18:03 <satc> How to write this in pointfree => foo f = do m <- newMem ; f m ; free m
07:18:24 <dmwit> ?@ @pl @undo foo f = do { m <- newMem; f m; free m }
07:18:24 <lambdabot>  (line 1, column 40):
07:18:24 <lambdabot> unexpected ';'
07:18:24 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
07:18:44 <shergill> Cale: so can this be avoided? i.e., what would be the less opaque 'function' style which could be adopted which would obviate this issue?
07:18:44 <dmwit> ?pl foo f = newMem >>= \m -> f m >> free m
07:18:44 <lambdabot> foo = (newMem >>=) . (`ap` free) . ((>>) .)
07:18:52 <Cale> So, the key is to put some additional machinery into the Arrow typeclass so that these operations which rewire things can be made explicit, and libraries which use the Arrow abstraction can implement them in some way which is transparent and analysable.
07:18:54 <quchen> maltem: I'm not a very good metric for that though.
07:19:06 <dmwit> ?undo foo f = do { m <- newMem; f m; free m }
07:19:06 <lambdabot> foo f = newMem >>= \ m -> f m >> free m;
07:19:09 <satc> I only meant to write things in do as pointfree without actually creating a variable named m.\
07:19:14 <dmwit> dat semicolon
07:19:17 <satc> I am happy with choosing f
07:19:18 <donri> @. pl undo do { m <- newMem; f m; free m }
07:19:21 <lambdabot> newMem >>= ap ((>>) . f) free
07:19:22 <lambdabot> optimization suspended, use @pl-resume to continue.
07:19:43 <dmwit> @. pl undo \f -> do { m <- newMem; f m; free m }
07:19:43 <lambdabot> (newMem >>=) . (`ap` free) . ((>>) .)
07:19:44 <shergill> Cale: hmm do you have an explicit example of such machinery? i understand the abstract
07:19:49 <Cale> For example, you'll want some stuff like  assocL :: (a,(b,c)) ~> ((a,b),c), and its inverse assocR :: ((a,b),c) ~> (a,(b,c)), as well as swap :: (a,b) ~> (b,a)
07:20:00 <satc> @hoogle ap
07:20:00 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
07:20:00 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
07:20:00 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
07:20:04 <shergill> ah
07:20:06 <dmwit> Oh, wait, what's the difference between ?. and ?@?
07:20:07 <merijn> dmwit: It's "(>>) <$> f <*> free" :)
07:20:08 <maltem> quchen, remembering those happy days when shouting "why is this slow?" would have dons come by and do something about it!
07:20:21 <dmwit> ?help .
07:20:21 <lambdabot> . <cmd1> <cmd2> [args].
07:20:21 <lambdabot> . [or compose] is the composition of two plugins
07:20:21 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
07:20:28 <dmwit> ?help @
07:20:28 <lambdabot>  @@ [args].
07:20:28 <lambdabot>  @@ executes plugin invocations in its arguments, parentheses can be used.
07:20:28 <lambdabot>  The commands are right associative.
07:20:28 <lambdabot>  For example:    @@ @pl @undo code
07:20:28 <lambdabot>  is the same as: @@ (@pl (@undo code))
07:20:32 <yitz> Cale: so the post which shows that applicative and arrows are effectively equivalent somehow hardwires the use of functions inside somewhere, and it's not really true if you avoid that?
07:20:45 <merijn> "newMem >>= ((>>) <$> f <*> free)"
07:21:01 <shergill> yitz: where is that post?
07:21:17 <dmwit> merijn: f is the point here, so you haven't point-free-ified it at all yet in my opinion.
07:21:30 <merijn> I thought m was the point?
07:21:40 <merijn> whoops
07:21:40 <dmwit> I guess they're both points.
07:21:58 <donri> what's the point!
07:22:06 <shergill> Cale: but aren't assocL etc just functions? and wasn't the problem with functions that they were opaque? i guess the answer is that they're to be considered as the atomic building blocks?
07:22:13 <danr> @. pl undo \ f -> do { m <- newMem; f m: free m }
07:22:13 <lambdabot> (newMem >>=) . (`ap` free) . ((:) .)
07:22:21 <quchen> It's really hard holding back on all the "point" puns ready to be made here.
07:22:50 <danr> huh, where did the cons come from?
07:23:01 <yitz> shergill: i was thinking of this: http://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/
07:23:01 <quchen> You wrote : instead of :
07:23:02 <danr> @type newMem
07:23:03 <lambdabot> Not in scope: `newMem'
07:23:08 <danr> quchen: haha, right!
07:23:21 <quchen> ": instead of :" <- totally intended typo!
07:23:40 <cidevant> Hi!) Need help again. Can someone fix it ? https://gist.github.com/cidevant/6113346
07:23:42 <danr> quchen: brilliant! I didn't even spot it
07:23:55 <quchen> danr: I think you just gave a brilliant candidate for an underhanded Haskell contest.
07:24:12 <byorgey> cidevant: what does (xs * 2)  mean?
07:24:40 <cidevant> it should Double number
07:24:45 <cidevant> Integer * 2
07:24:47 <byorgey> cidevant: what type is xs?
07:25:01 <cidevant> doubleEverySecondNumber :: [Integer] -> [Integer]
07:25:04 <cidevant> definition
07:25:30 <dmwit> cidevant: Read byorgey's question carefully; he's being sneaky but very helpful. =)
07:25:31 <byorgey> cidevant: I know what type doubleEverySecondNumber is.  I'm asking what type you think xs has, in the line  "doubleEverySecondNumber (x:xs) = x : (xs * 2)"
07:25:53 <byorgey> I'm not being sneaky, I'm being Socratic!
07:25:58 <dmwit> =D
07:26:04 <quchen> Sneakratic!
07:26:57 <cidevant> byorgey: maybe I made pattern match mistake.. I think it should be something like this doubleEverySecondNumber (x:xs:[]) = x : (xs * 2)
07:27:21 <yitz> Cale: ok, yes. Here is a quote from cdsmith's second post: "It turns out that arr plays a unique role in the structure we get from combining Category and Applicative..."
07:27:23 <danr> @. pl undo \ f -> do { m <- newMem; f m; free m }
07:27:23 <lambdabot> (newMem >>=) . (`ap` free) . ((>>) .)
07:27:50 <danr> quchen: hmm. do you mean some kind of spot-the-typo-contest?
07:27:57 <mellum1> if I have type T = IntMap.int, for example, can I then somehow have (show t) where t is a T call my own function?
07:28:08 <mellum1> T=IntMap Int I mean
07:28:32 <merijn> danr: The underhanded C contest is a contest where you have to submit code that *looks* innocent, but is actually malicious
07:28:48 <danr> merijn: oh. I haven't seen that one
07:28:52 <quchen> danr: OT, so let's leave it at "google 'underhanded C contest'".
07:29:00 <yitz> hi byorgey
07:29:15 <merijn> danr: It's the opposite of the obfuscated C contest in that you're supposed to not look obfuscated but still be malicious
07:29:23 <quchen> mellum1: No, you cannot define instances for "type".
07:29:39 <quchen> mellum1: If you want your own "show" function, you'll have to use a newtype.
07:29:51 <mellum1> quchen: okay, thanks.
07:29:56 <yitz> byorgey: enjoyed your post about euterpea
07:30:13 <quchen> The reason for this is that instances are tied to actual types, while "type" only introduces a type synonym (and not a real new type). And yes the names are confusing.
07:30:53 <yitz> byorgey: i've been hesitant about building anything on it, though, because the authors *still* have not uploaded even a single version of it to hackage
07:32:53 <yitz> merijn: i enjoy reading the results of that contest.
07:33:05 <danharaj> edwardk: do you have a recommended library for parsing command args and flags?
07:33:29 <quchen> @hackage optparse-applicative
07:33:29 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
07:33:43 <quchen> ^ danharaj
07:33:46 * yitz seconds optparse-applicative
07:33:57 <yitz> there are plenty of other good ones though
07:34:04 <Ivo> would haskell be able to handle the recursion depth to play around with this way better than python? https://gist.github.com/Ivoz/6113373
07:34:14 <danharaj> yitz: that's the problem, isn't it? There's too many good ones to choose :P
07:34:48 <yitz> danharaj: yes. i'd rather have that problem than the opposite one though.
07:35:26 <quchen> danharaj: MonadRandom is an excellent library designed to make choosing between equal alternatives better.
07:35:42 <quchen> There are other random number libraries equally suited at the task though.
07:36:03 <xraycat> :-)
07:36:09 <mr-> Ivo: probably not, the number just become very big very quickly
07:36:17 <quchen> @quote kmc incompatible
07:36:17 <lambdabot> kmc says: Haskell is a language where the community observes that there are 50 incompatible error handling monads, and the response is 50 incompatible packages for generically handling all error
07:36:17 <lambdabot> handling monads
07:36:18 <quchen> :-)
07:36:21 <yitz> Ivo: it's not just an issue of recursion depth
07:36:53 <Ivo> yitz: i wanted to see how big numbers were getting on my screen
07:37:05 <yitz> quchen: there's an xkcd about that
07:37:07 <Ivo> but python was hitting recursion depth before i could see really big ones
07:37:18 <mr-> Ivo: well, try it :-)
07:37:30 <mellum1> So, how do I work with the newtype? for example newtype T = T (IntMap.IntMap Int); empty :: T; empty = IntMap.empty gives a type error
07:37:54 <mellum1> ah, I need to add a T
07:38:00 <tikhon> newtypes are just like normal algebraic data types--you have to wrap your value with a constructor
07:38:22 <Ivo> the best I could get is up(n, 3, 2)
07:38:40 <yitz> Ivo: does it fill up your screen?
07:39:55 <Ivo> up(3,3,3) hits recursion depth immediately for instance :)
07:40:20 <Ivo> i wonder if memoization would help..
07:41:02 <mr-> Ivo: I added the simplest haskell version as a comment
07:41:33 <haasn> mr-: you probably want more strictness
07:42:51 <haasn> otherwise that's just going to make you run out of memory fast
07:43:19 <theWinner> what is the relationship (if any) between functional zippers and lenses?
07:43:39 <haasn> lens provides a generalized notion of zippers
07:43:45 <haasn> that works for any traversal
07:43:49 <roconnor> I recall that lens has a hetrogenious zipper library using HLIst
07:44:01 <haasn> I doubt it uses HList
07:44:08 <roconnor> hmm
07:44:09 <haasn> but I could be wrong
07:44:20 <haasn> http://ekmett.github.io/lens/Control-Lens-Zipper.html
07:44:28 <yitz> haasn: i think you're right
07:44:29 <elliott> haasn: it won't soon.
07:44:30 <theWinner> so I can just forget about zippers and use lenses instead?
07:44:42 <elliott> it's being split into a zippers package that builds on top of lens.
07:44:45 <roconnor> I see, it is only vaugely related to HLists
07:44:46 <haasn> you can just forget about _ and use lenses instead
07:44:51 <haasn> elliott: okay
07:45:14 <tikhon> in particular, you can forget about Haskell and just uses lenses instead :)
07:45:22 <haasn> > zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'J' & rightmost & focus .~ 'y' & rezip
07:45:24 <lambdabot>   Not in scope: `zipper'Not in scope: `downward'Not in scope: `fromWithin'Not...
07:45:26 <haasn> aaw
07:45:37 <sludo> can anyone comment on what haskell ide projects are currently active/popular?
07:45:43 <donri> elliott: why?
07:45:51 <theWinner> so i can navigate parent-child relationships using lenses....
07:45:53 <danharaj> sludo: fpcomplete's ide
07:45:55 <theWinner> interesting
07:45:56 <danharaj> it is closed source
07:46:06 <mr-> haasn: you are right, of course!
07:46:15 <elliott> donri: good question. I dislike the change.
07:46:27 <mr-> I keep forgetting about the downsides of laziness..
07:46:35 <donri> elliott: the zipper stuff doesn't seem that intrusive in lens
07:46:40 <haasn> elliott: to be fair, lens doesn't need to provide everything under the sun, and nothing in lens depends on Zipper does it?
07:46:44 <elliott> donri: I agree.
07:46:57 <theWinner> tikhon, could you explain your comment? I'm curious
07:47:05 <elliott> haasn: the module is quite small and it fits in well with the rest of the API and lets you do some really neat stuff out of the box. that's my position.
07:47:14 <elliott> it has gotten more complex because of indexing though.
07:47:18 <tikhon> I was just being facetious
07:47:34 <tikhon> and making fun of lenses for being so gigantic and all-encompassing
07:47:49 <theWinner> then I wonder was haasn meant
07:47:51 <haasn> ‚ÄòjerkTo‚Äô <- my juvenile mind is thinking up some puns to use here
07:48:04 <theWinner> (i totally don't get the original statement)
07:48:10 <theWinner> <- noober
07:48:18 <donri> there are jerks in lens
07:48:20 <donri> :t jerks
07:48:20 <lambdabot> Not in scope: `jerks'
07:48:24 <donri> :(
07:48:33 <quchen> mr-: The "!" is unnecessary, a is already strict because of the first pattern. (Where's the n==1 pattern?)
07:49:01 <theWinner> "you can just forget about _ and use lenses instead" - is that a statement on their generality?
07:49:01 <quchen> Also, I don't think memoization helps much when calculating uparrows, those things explode no matter what trickery you throw at them.
07:49:07 <haasn> yeah the !a is unnecessary
07:49:19 <quchen> So is the !b
07:49:25 <Ivo> mr-: I hadn't seen the ! syntax before, whats that mean?
07:49:30 <haasn> thunks only build up in the second and third arguments
07:49:46 <mr-> haasn, quchen, but it doesn't hurt either!
07:50:04 <mr-> quchen: why the !b?
07:50:05 <quchen> mr-: neither does adding "id" to the beginning of each line
07:50:11 <haasn> come to think of it
07:50:13 <Ivo> quchen: well i was hoping it might help recursion a *tiny* little bit... probably not.
07:50:22 <haasn> will that function every return anything other than ‚Äòa‚Äô
07:50:31 <haasn> ever*
07:50:33 <quchen> mr-: The second pattern checks whether "b == 1", so b has to be evaluated
07:50:45 <haasn> yeah the n=1 pattern is missing, no wonder
07:50:47 <mr-> ah, right, tanks
07:50:56 <mr-> oops ;-)
07:51:02 <Ivo> haasn: https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation very interesting function :)
07:51:07 <theWinner> are there downsides to lenses, such as performance or understandability?
07:51:15 <donri> elliott: ISTR part of the problem is edwardk wants Control.Lens to export every non-internal submodule, but then with stuff like zipper that ends up being a lot.
07:51:17 <yitz> Ivo: up 2 3 3 ran fine, but up 2 4 3 ate up all my memory and then segfaulted.
07:51:18 <haasn> Ivo: I'm familiar with it, from Graham's number :P
07:51:25 <haasn> Ivo: ‚Äòup 3 3 3‚Äô still stack overflows here
07:51:37 <Ivo> yitz: awesome, that's exactly what I wanted
07:51:45 <Ivo> yitz: so we just need... more memory now
07:51:54 <donri> elliott: personally i'd like it to just be Lens.Zipper etc and then I don't care much what the "Lens" module exports
07:52:02 <quchen> I added a comment with a memoizing version.
07:52:08 <haasn> yitz: isn't that just because you're building up huge thunks?
07:52:11 <yitz> Ivo: increase your memory to Graham's number gigabytes
07:52:22 <yitz> haasn: probably yeah
07:52:22 <haasn> or are you running the strict version?
07:52:34 <yitz> haasn: just typed it naively in ghci
07:52:43 <Ivo> really gives you something to think about when a computer can't handle just 3 ‚Üë‚Üë‚Üë 3
07:53:09 <mr-> Ivo: you think so? It's just a large number..
07:53:25 <tdammers> what's ‚Üë‚Üë‚Üë?
07:53:25 <Ivo> it looks so simple...
07:53:31 <tikhon> tdammers: up-arrow notation
07:53:34 <roconnor> theWinner: I think that lenes can greatly enhance readiblity if it is used properly (and the reader is familier with the lens library).
07:53:42 <tdammers> oh right, that.
07:53:43 <tikhon> there was a wikipedia link to it earlier
07:53:50 <haasn> https://en.wikipedia.org/wiki/Hyper_operator
07:53:50 <tdammers> yeah, saw it
07:53:58 <tikhon> the core problem is that there are a lot of numbers out there
07:54:16 <roconnor> theWinner: It is also my understanding that the lens library is quite efficent; for example, I'm told that the Uniplate reimplementation is even faster that Neil's original implementation.
07:54:17 <yitz> theWinner: no i think lens is performant and straightforward. it's just that there are a lot of types, operators, and functions to learn.
07:54:20 <merijn> Ivo: There's many numbers computers can't handle :)
07:54:29 <haasn> lens has a lot of internal optimizations
07:54:29 <edwardk> donri: 3.10 is removing zipper from the lens library
07:54:32 <haasn> and hacks
07:54:34 <quchen> merijn: Actually, a computer can handle almost no numbers!
07:54:42 <donri> edwardk: but whyyy
07:54:50 <merijn> Ivo: Out of curiosity, was the interest sparked by day9's video? :p
07:54:51 <edwardk> and yeah the uniplate code in lens is about 30% faster than uniplate itself
07:54:59 <theWinner> i  guess one downside of lenses is that when I'm using F#and have to code them all manually
07:55:03 <haasn> theWinner: the downside is dependence and corresponding withdrawal symptoms
07:55:07 <Ivo> merijn: you got me
07:55:15 <edwardk> donri: because then the 'zippers' package will be able to use more controversial/traditional names for the navigation operations
07:55:20 <haasn> merijn: like Œ©
07:55:23 <donri> edwardk: if zipper is out why not uniplate etc
07:55:32 <edwardk> lens-style lenses in F# don't work. more traditional lenses do
07:55:44 <roconnor> theWinner: The big "problem" with lens is that the actually types of the operations are not actually helpful in guiding the user.  But that is the price paid to get transparent subtyping.
07:55:48 <edwardk> donri: mostly because almost everything that was in Uniplate has just become a general purpose traversal combinator
07:55:58 <donri> edwardk: hm ok. so again the problem is the insistence of exporting everything from Control.Lens and discouraging qualified/explicit imports? :P
07:56:03 <Ivo> quchen: thanks! I wonder how much help simple memoization can really provide...
07:56:08 <theWinner> I have an imperative programmer that may dislik lenses because he'll be like "why don't you just mutate it?"
07:56:14 <yitz> donri: because edwardk loves to maintain lots and lots of interdependent hackage packages
07:56:20 <donri> hah
07:56:20 <edwardk> donri: i will agree to disagree on whether or not that is a feature
07:56:23 <haasn> theWinner: then you'll love lenses + StateT
07:56:27 <quchen> Ivo: For a suitable problem, memoization can do a lot.
07:56:28 <donri> edwardk: ;)
07:56:42 <Ivo> quchen: well the question is how suitable is this
07:56:46 <quchen> Ivo: See the fibo example in memocombinator's docs.
07:56:52 <donri> qualified and explicit imports suck. open imports suck more :p
07:56:53 <quchen> Here I think it's very unsuitable. :-P
07:56:56 <Ivo> (in this case)
07:56:57 <haasn> theWinner: https://github.com/ekmett/lens/blob/master/examples/Pong.hs#L108
07:57:31 <theWinner> nice
07:57:38 <edwardk> > execState ?? ("hello",2) $ do _1 .= "goodbye"; _2 += 3
07:57:40 <lambdabot>   ("goodbye",5)
07:57:49 <edwardk> theWinner: that looks somewhat imperative to me ;)
07:57:52 <Ivo> would some custom C library for large discrete math do much better than haskell?
07:58:00 <roconnor> theWinner: edwardk can probably tell you stories about how mutation in Scala messed everything up at his company and switching to lenses (which "mutate" by copy) saved the day.
07:58:15 <theWinner> do tell!
07:58:16 <edwardk> > execState ?? ("hello",2) $ do _1 .= "goodbye"; _2 += 3; _1.traverse %= Data.Char.toUpper
07:58:18 <lambdabot>   ("GOODBYE",5)
07:58:32 <quchen> Ivo: Here's a version that prints out intermediate recursive calls. http://lpaste.net/91332
07:58:33 <Ivo> tikhon: i like your summary of the problem :)
07:58:46 <edwardk> i could but roconnor just did ;)
07:58:48 <quchen> Run it with 3 3 3 as arguments and get ready to hit C-c.
07:58:57 <mellum1> so, if I have newtype T = T Int, how do I extract the Int in a t of type T? Is there something better than case t of T i -> i?
07:59:12 <quchen> Ivo: Keep in mind that this is the optimized memoized version :-)
08:00:03 <edwardk> i originally started working with lenses because i needed them for that purpose. wrote the scalaz lens implementation, then came back to haskell
08:00:16 <quchen> mellum1: Record syntax? `newtype T a = T { unwrap :: a }
08:00:19 <quchen> `
08:00:33 <quchen> That'll give you unwrap :: T a -> a
08:00:49 <roconnor> theWinner: I presume the issue is the same issue that everyone has.  One has a pipeline which is mutating some global structure and intermediate parts of the pipeline have hacks that lie about the data and then break assumtions that other people are using and the whole thing becomes a big mess.  With lenes when your hacks lie, they only lie to themselves, because copies are made.  Copies are largely efficent becuase of the
08:00:50 <roconnor> sharing of the unchanged bits.
08:00:59 <theWinner> how did mutation mess things up at your company?
08:01:03 <byorgey> yitz: eh? which post about euterpea is that?
08:01:28 <byorgey> yitz: perhaps you have me confused with someone else?
08:01:32 <theWinner> cool
08:01:53 <byorgey> yitz: though I am in touch with some of the authors, I will try to convince them to upload it to Hackage
08:02:09 <theWinner> edwardk,why were you doing scalaz?
08:02:21 <theWinner> as opposed to haskell
08:03:07 <jdoles> I tried Warp with siege with 10000 concurrent connections and it basically falls over.
08:03:08 <donri> because scala is java is enterprise? :p
08:03:35 <yitz> byorgey: ohh it was mzero. yeah. :) i guess because of your work on FARM.
08:03:42 <jdoles> Wasn't this C10K thing "a thing" a few _years_ ago?
08:03:45 * danr is back after reading all entries in the Unhandled C competition :)
08:04:02 <edwardk> theWinner: we had a toolchain for combinators that flatten out data structures into various tables in a star-schema. it would generate a lazy stream of records, but streams in scala aren't memoizing. so without the purity of lenses what would happen is some combinators would run the stream, then we'd rerun it and get the same effects, because some code needed to analyze the future of the stream a couple of times
08:04:23 <edwardk> with lenses we're not actually mutating any objects, so the streams have well-defined semantics
08:04:39 <edwardk> and can be 'run' multiple times without consequence
08:04:48 <theWinner> nice
08:04:50 <yitz> byorgey: if you have anything interesting to say about your language learning project, tell me on blah or pm
08:04:50 <edwardk> and we were going scalaz because the data we needed to work with was on the jvm
08:04:59 <theWinner> ah, the jvm
08:05:20 <edwardk> we since gave up and just wrote a language to run there instead
08:05:32 <edwardk> solving our scala problm
08:05:44 <theWinner> I wonder if Haskell will ever get a presence on the JVM
08:05:44 <theWinner> or .net, for that matter
08:05:45 <sclv_> @remember littlecalculist combinatorics. n. math's way of punishing you for failing to use abstraction.
08:05:46 <lambdabot> It is stored.
08:05:48 <tikhon> heh, that's a surprisingly common reaction to being forced onto the JVM :)
08:05:54 <edwardk> sclv_: hahahaha
08:06:09 <sclv_> that's for byorgey :-P
08:06:12 <tikhon> I don't think the JVM is very well suited to Haskell
08:06:15 <byorgey> =D
08:06:20 <tikhon> but there is a project called Frege trying to do something like htat
08:06:29 <theWinner> hmm
08:06:31 <tikhon> it's not entirely compatible with Haskell proper though
08:06:53 <theWinner> due to the JVM's semantics?
08:07:28 <shergill> if there was a llvm bytecode to jvm bytecode translator, that would do the trick
08:07:38 <tikhon> my understanding is that it is heavily optimized for a Java-like workload which is very different from a functional programming workload, especially considering laziness
08:08:19 <theWinner> shergill, is the haskell llvm backend being maintained?
08:08:26 <sclv_> there was a v. funny story about some functional code in clojure or something deployed on the jvm.
08:08:52 <sclv_> where it ran in like 4MB resident so the dev says "set the heap size to 8"
08:09:01 <sclv_> and it goes to 8 and gcs and then goes back down.
08:09:11 <sclv_> and they say "hmm" and bump it to 16, and the same thing happens
08:09:18 <sclv_> and then to 32, and the same thing happens again
08:09:20 <zomg> haha.. only on #haskell
08:09:21 <sclv_> and then 64
08:09:22 <shergill> theWinner: i believe so since it's one of the backends currently available during compilation
08:09:26 <zomg> > we since gave up and just wrote a language to run there instead
08:09:27 <lambdabot>   Not in scope: `we'
08:09:27 <lambdabot>  Perhaps you meant one of these:
08:09:27 <lambdabot>    `w' (imported from D...
08:09:34 <zomg> nowhere else will you find someone solving a problem by writing a new language...
08:09:37 <zomg> lol
08:09:40 <sclv_> and eventually this happened all the way up to the max size they could allocate
08:09:45 <yitz> here it is: http://xkcd.com/927/
08:09:48 <sclv_> and they go back to the dev and say "wtf is with your code!"
08:09:59 <sclv_> and he says "knock it back down to 8 and stop asking so many questions"
08:10:00 <tikhon> the first company I worked at--a pretty staid enterprise software company primarily using Java--did the same thing
08:10:36 <sclv_> the intepretive overhead of lots of object creation is significant on the JVM, but you'll still beat ruby or python :-)
08:10:37 <tikhon> then they had a lot of fun writing tooling for it--they even wrote their own IDE, and the only problem was that it sucked
08:10:40 <sclv_> just gotta set your sights low
08:10:43 <sclv_> (er)
08:11:30 <edwardk> at least the jvm knows that people tend to spam lots of short lifespan objects and has the nursery, etc.
08:11:50 <tikhon> are there runtimes that don't do that these days?
08:12:06 <edwardk> i have a long memory ;)
08:12:18 <tikhon> in that case, it was probably before my time :P
08:12:18 <edwardk> just saying it could be worse
08:12:23 <sclv_> the problem iirc is just that an object costs a fair amount of space compared to e.g. a thunk a la ghc
08:12:25 <tikhon> I have a skewed perspective on these things
08:13:03 <sclv_> or a plain 'ol closure a la scheme
08:14:06 <Format> Hi all, i have a noob question; how to define a list whit operators, such as [(>),(<),(and),(or)...]. Thanks for your time.
08:14:19 <tikhon> that would work if the types matched
08:14:25 <applicative> Format, they just need to be the same type
08:14:26 <dmwit> Format: Just like that. [(<), (>)] is a perfectly good list.
08:14:32 <tikhon> > [(>), (<), (>=), (=<)]
08:14:33 <lambdabot>   Not in scope: `=<'
08:14:33 <lambdabot>  Perhaps you meant one of these:
08:14:33 <lambdabot>    `=<<' (imported from...
08:14:52 <tikhon> > [(>), (<), (>=), (<=)]
08:14:53 <dmwit> > let x = [(>), (<), (>=), (>=)] in 3
08:14:53 <lambdabot>   [<() -> () -> Bool>,<() -> () -> Bool>,<() -> () -> Bool>,<() -> () -> Bool>]
08:14:54 <lambdabot>   3
08:15:02 <applicative> Format, or rather, the typechecker needs to be able to specialize their types together and still be left with something ...
08:15:14 <dmwit> Oh, there's a Show instance in lambdabot. =)
08:15:33 <S11001001> @ty [(>), (<)]
08:15:34 <lambdabot> Ord a => [a -> a -> Bool]
08:15:44 <augur> uhh...
08:16:02 <Format> tikhon : thanks, and what about to mix operators like [(>), (<), (*), (*), (somefunction)]
08:16:03 <augur> oh i see.
08:16:18 <tikhon> Format: the type system doesn't really allow that
08:16:28 <tikhon> basically, you shouldn't need to do that
08:16:41 <applicative> that wont work since (*) is number -> number -> number, but > is number -> number -> bool
08:16:44 <sclv_> Format: what are you trying to do?
08:16:51 <tikhon> it's the same idea as not being able to make a list of [True, "foo"]
08:16:53 <applicative> well is there a Num instance for Bool?
08:17:04 <sclv_> there could be!
08:17:08 <tikhon> > [True, "foo"]
08:17:08 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
08:17:09 <lambdabot>              with actual type...
08:17:15 <sclv_> applicative: i await your libraries proposal
08:17:25 <applicative> hah
08:17:31 <Format> sclv_ that im trying to do is define a list of funcions, then aply it to a list of datas
08:17:33 <applicative> Format should propose it
08:17:58 <YurasShumovich> hello
08:18:03 <applicative> Format: excellent plan, but the result cant be a heterogeneous list of bools, numbers, etc
08:18:14 <applicative> hello YurasShumovich
08:18:29 <sclv_> Format: but a function takes two arguments as well. So you would need to apply < to pairs of numbers, or two two lists...
08:18:38 <sclv_> I find it helps to write the type signature of what I want to produce first
08:18:44 <applicative> YurasShumovich: what are *your* actual and expected types?
08:18:46 <sclv_> to check if I'm asking for something that makes sense
08:18:50 <Format> applicative thanks a lot, so, the list of function must have the same amount of parameters ?
08:18:53 <YurasShumovich> I'm looking for Data.Map replacement, based on STM
08:18:59 <__jay> n
08:19:11 <YurasShumovich> MVar (Data.Map) seems too slow
08:19:16 <applicative> Format, yes but they need to be the same type and the result the same
08:19:48 <dmwit> sclv_: (+) = (||), (*) = (&&)
08:19:49 <applicative> YurasShumovich: the HashMap from unordered-containers?
08:20:12 <dmwit> signum is trickier
08:20:22 <applicative> YurasShumovich: http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.1/doc/html/Data-HashMap-Strict.html
08:20:23 <tikhon> what about signum = id?
08:20:28 <Format> applicative, great so i can do a list [(>), (<),  (somefunction)] only if somefunction take 2 parameters and return a boll ? corrent ?
08:20:38 <applicative> Format: exactly
08:20:45 <dmwit> signum = id is not bad
08:20:54 <tikhon> > signum 0
08:20:55 <dmwit> and abs = id, too, I guess
08:20:56 <lambdabot>   0
08:20:56 <tikhon> > signum 1
08:20:58 <lambdabot>   1
08:21:01 <Format> applicative, great, thanks a lot :)
08:21:14 <dmwit> type Word1 = Bool
08:21:27 <YurasShumovich> applicative: do you mean MVar (HashMap)?
08:21:38 <sclv_> dmwit: yep. Z/2
08:21:50 <YurasShumovich> will not be as slow, as MVar (Map)?
08:21:55 <Format> > [True]
08:21:56 <lambdabot>   [True]
08:22:09 <Format> > [1..]
08:22:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:22:15 <Format> xD
08:22:16 <applicative> YurasShumovich: no I wasnt touching on the mutability, just suggesting this is better, at least often, than Data.Map
08:23:02 * hackagebot monadiccp-gecode 0.1.1 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-gecode-0.1.1 (JanTikovsky)
08:23:17 <YurasShumovich> applicative: I need a lot of concurrent updates, both the Map and HashMap stored in MVar will be slow
08:24:07 <YurasShumovich> applicative: because every update will block all other threads, even when they update different keys
08:24:44 <YurasShumovich> applicative: I need more granular locking
08:24:55 <Format> > [(>)]
08:24:56 <lambdabot>   [<() -> () -> Bool>]
08:27:32 <Format> > [(>) ,(<), (and), (or) ]
08:27:33 <lambdabot>   Couldn't match type `GHC.Types.Bool'
08:27:33 <lambdabot>                with `[GHC.Types.Bool] ...
08:27:51 <tikhon> remember that (and) and (&&) are different
08:27:51 <mr-> Format: the types have to match
08:27:55 <tikhon> :t and
08:27:56 <lambdabot> [Bool] -> Bool
08:27:59 <tikhon> :t (&&)
08:27:59 <lambdabot> Bool -> Bool -> Bool
08:28:12 <Format> sorry, testing like a noob xD
08:28:22 <tikhon> don't worry about it--it's the best way to learn
08:28:33 <dmwit> > negate (maxBound :: Word8)
08:28:34 <lambdabot>   1
08:28:40 <dmwit> hm, okay
08:28:43 <applicative> @type [and,or]
08:28:44 <lambdabot> [[Bool] -> Bool]
08:28:45 <mr-> Format: nothing to worry about, but if you don't want suggestions, you can talk to lambdabot in private ;-)
08:29:07 <dmwit> ?let instance Num Bool where (+) = (||); (*) = (&&); negate = id; abs = id; signum = id; fromInteger n = (n .&. 1) == 1
08:29:08 <lambdabot>  .L.hs:145:28:
08:29:08 <lambdabot>      Ambiguous occurrence `.&.'
08:29:08 <lambdabot>      It could refer to either ...
08:29:09 <applicative> @type [(<),(>)]
08:29:10 <lambdabot> Ord a => [a -> a -> Bool]
08:29:14 <YurasShumovich> "TArray" is implemented as "Array i (TVar e)": http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TArray.html. Will "Map k (MVar v)" be fast enough for frequent concurrent updates?
08:29:18 <dmwit> ?let instance Num Bool where (+) = (||); (*) = (&&); negate = id; abs = id; signum = id; fromInteger n = (n `mod` 2) == 1
08:29:19 <Format> mr- oh! nice, i did not think that work in private...sorry about spam...
08:29:19 <lambdabot>  Defined.
08:29:29 <dmwit> > [(>), (<), (&&), (||)]
08:29:29 <mauke> dmwit: odd
08:29:30 <lambdabot>   [<Bool -> Bool -> Bool>,<Bool -> Bool -> Bool>,<Bool -> Bool -> Bool>,<Bool...
08:29:36 <tikhon> :t (.&.)
08:29:37 <lambdabot>     Ambiguous occurrence `.&.'
08:29:37 <lambdabot>     It could refer to either `Data.Bits..&.',
08:29:37 <lambdabot>                              imported from `Data.Bits' at /home/lambdabot/.lambdabot/State/L.hs:54:1-16
08:29:39 <dmwit> mauke: type Word1 = Bool, then everything makes sense
08:29:40 <mr-> Format: it's no spam
08:29:51 <mauke> dmwit: fromInteger = odd
08:29:59 <dmwit> mauke: Oh! Much better, thanks.
08:30:08 <mauke> :-)
08:30:11 <applicative> oh I hadn't taken in this response of lambdabot, if it cant show, it shows the types
08:30:33 <mauke> Test.QuickCheck.Property..&.
08:30:35 <mauke> goddammit
08:30:38 <applicative> ah indeed brilliant fromInteger
08:30:45 <yitz> dmwit: don't you want (+) = xor?
08:30:50 <dmwit> hm
08:30:54 <dmwit> Yeah, I probably do.
08:31:06 <dmwit> Will anybody be upset if I ?undefine?
08:31:26 <dmwit> > (maxBound :: Word8) + 1
08:31:27 <lambdabot>   0
08:31:39 <dmwit> ?undefine
08:31:40 <lambdabot> Undefined.
08:31:52 <applicative> > (maxBound :: Word) + 1
08:31:53 <lambdabot>   0
08:31:57 <dmwit> ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
08:31:58 <lambdabot>  Defined.
08:32:13 <mauke> > (.&.)
08:32:14 <lambdabot>   Ambiguous occurrence `.&.'
08:32:14 <lambdabot>  It could refer to either `Data.Bits..&.',
08:32:14 <lambdabot>      ...
08:32:23 <tikhon> > abs (True + True * False + False * True + True)
08:32:28 <lambdabot>   mueval-core: Time limit exceeded
08:32:31 <tikhon> ...
08:32:42 <dmwit> > abs (True + True * False + False * True + True)
08:32:45 <lambdabot>   False
08:32:52 <dmwit> It likes me better. :3
08:32:57 <tikhon> !
08:33:14 <CaptainK> lambdabot is the next skynet
08:33:23 <mr-> hmm.. you don't want Bool to be Z/2Z ?
08:33:32 <mauke> preflex: seen elliott
08:33:33 <preflex>  elliott was last seen on #haskell 46 minutes and 18 seconds ago, saying: it has gotten more complex because of indexing though.
08:33:43 <dmwit> mr-: What have I done wrong this time?
08:33:51 <applicative> hah
08:33:53 <mr-> dmwit: I would have expected 0 + 0 = 0
08:33:55 <elliott> it'll probably time out more often because it imports lens now
08:34:00 <elliott> you have only yourselves to blame!!!
08:34:02 <dmwit> > 0+0 :: Bool
08:34:06 <lambdabot>   False
08:34:08 <dmwit> > 0 :: Bool
08:34:11 <lambdabot>   False
08:34:12 <tikhon> > False + False
08:34:15 <lambdabot>   False
08:34:21 <dmwit> mr-: That equation seems to hold.
08:34:23 <tikhon> > True + True
08:34:26 <lambdabot>   False
08:34:30 <tikhon> > True + False
08:34:33 <lambdabot>   True
08:34:44 <mr-> dmwit: oh, maybe I don't understand (+) = (/=) then ;-)
08:34:49 <sclv_> > True ^ 3
08:34:52 <lambdabot>   True
08:34:56 <mr-> never mind me
08:35:01 <sclv_> (/=) is how we write xor
08:35:02 <dmwit> mr-: Yeah, (/=) being xor is subtle.
08:35:05 <elliott> mr-: False /= False is False
08:35:15 <tikhon> > False /= False == True
08:35:16 <lambdabot>   Precedence parsing error
08:35:16 <lambdabot>      cannot mix `GHC.Classes./=' [infix 4] and `GH...
08:35:24 <tikhon> > (False /= False) == True
08:35:26 <lambdabot>   False
08:35:26 <Format> <CaptainK> lambdabot is the next skynet // epic
08:35:34 <mauke> Format: no, it's rather short, actually
08:35:37 <mr-> k, that's misleading :-)
08:35:53 <dmwit> > [(x + y) * z == x * z + y * z | [x, y, z] <- replicateM 3 [False, True]]
08:35:56 <lambdabot>   [True,True,True,True,True,True,True,True]
08:36:30 <sclv_> @remember dmwit ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
08:36:30 <lambdabot> Good to know.
08:36:59 <dmwit> > [(x * y) + z == (x + z) * (y + z) | [x, y, z] <- replicateM 3 [False, True]]
08:37:02 <lambdabot>   [True,True,True,False,True,False,True,True]
08:38:25 <yitz> @check \x y z -> (x::Bool) + (y + z) == (x + y) + z
08:38:29 <lambdabot>   mueval-core: Time limit exceeded
08:38:33 <yitz> @check \x y z -> (x::Bool) + (y + z) == (x + y) + z
08:38:36 <lambdabot>   +++ OK, passed 100 tests.
08:38:40 <tac> > True + False
08:38:44 <lambdabot>   mueval-core: Time limit exceeded
08:38:48 <tac> wtf lambdabot
08:38:49 <byorgey> xor is a monoid on Bool
08:38:56 <dmwit>  > [(x+y)+z == x+(y+z) | (x,y,z) <- universe] -- =(
08:39:14 <dmwit> > [(x+y)+z == x+(y+z) | [x,y,z] <- replicateM 3 [False, True]]
08:39:18 <lambdabot>   [True,True,True,True,True,True,True,True]
08:39:41 <augur> byorgey: lots of things are monoids on bool!
08:40:16 <byorgey> augur: if by "lots" you mean "a small finite number", ok
08:40:35 <dmwit> Conjecture: all functions of appropriate type are the mappend of some Bool monoid instance.
08:40:39 <yitz> @type xor
08:40:40 <lambdabot> Bits a => a -> a -> a
08:40:48 <yitz> we write xor as xor
08:40:53 <dmwit> Now let me try to disprove this.
08:40:57 <augur> dmwit: thats trivially true if we have depending types :)
08:41:04 <augur> dependent*
08:41:13 <dmwit> Why do dependent types change the conjecture?
08:41:18 <byorgey> dmwit: false.
08:41:18 <ocharles> mm_freak: are you at all free to briefly indulge me with a silly netwire question?
08:41:19 <tikhon> there's a finite number of possible Bool -> Bool -> Bool functions
08:41:24 <tikhon> so just count all of them
08:41:25 <augur> dmwit: because we can embed the condition into the type
08:41:28 <byorgey> dmwit: consider  \_ _ -> True
08:41:29 <sclv_> yitz: but Bool isn't an instance of Bits!
08:41:44 <yitz> sclv_: tell me it ain't so
08:41:57 <dmwit> byorgey: right
08:42:04 <dmwit> no identity
08:42:09 <sclv_> yitz: yeah, i dunno. weird
08:42:09 <yitz> sclv_: that had something to do with Bool not having a Num instance, didn't it?
08:42:13 <byorgey> right.
08:42:22 <sclv_> Bits only requires an Eq!
08:42:24 <dmwit> augur: I haven't understood this point yet. Care to elaborate?
08:42:32 <sclv_> maybe that really should be a libraries patch
08:42:48 <yitz> sclv_: i think that changed at some point, partly for that reason
08:42:54 <tikhon> dmwit: I think he means that "appropriate type" would be the type of "monoids over bool" if you had dependent types
08:43:08 <dmwit> ah
08:43:20 <dmwit> Okay, yes, then it's trivial. =)
08:43:22 <augur> dmwit: of the "appropriate type" includes a condition of being monoidal, then all functions of that type are indeed monoids, by necessity!
08:43:25 <sclv_> could well be. we should add the instance hten
08:43:35 <sclv_> (or maybe we shoulda added the num instance for bool!)
08:43:49 <yitz> sclv_: well dmwit just did here in lambdabot
08:43:52 <augur> i wonder what the monoids on Bool are hm
08:44:01 <tikhon> the num instance for bools makes sense mathematically, but I think it's too likely to be a mistake in real code
08:44:07 <byorgey> dmwit: it's also not hard to construct non-associative functions of type  Bool -> Bool -> Bool
08:44:16 <augur> there's only 16 binary functions on bool
08:44:16 <Ivo> so i managed to get this program running by quchen, in ghci: http://lpaste.net/91332 he said watch out for memory overrun, but it came up as stack overflow instead. in console it seemed io limited as well. Should it hit a stack overflow?
08:44:18 <tikhon> (well, it makese sense mathematically as far as Num makes sense mathematically :P)
08:44:23 <augur> so we should be able to find the monoids!
08:44:35 <dmwit> tikhon: Yes, I expect that is the resistance you would find from libraries@, too.
08:45:02 <byorgey> > let False + True = True; _ + _ = False in [(x+y)+z == x+(y+z) | [x,y,z] <- replicateM 3 [False, True]]
08:45:03 <lambdabot>   [True,True,True,True,True,False,True,False]
08:45:08 <yitz> Ivo: compile with -rtsopts then run with +RTS -K2g
08:45:16 <sclv_> But as a programmer familiar with non-toy languages like C and Pascal, I fully expect to be able to write "if 0 then..."
08:45:17 <mr-> augur: there has to be an identity, chose that and the rest is fixed
08:45:19 <tikhon> I would also like to have a Bool typeclass rather than a single Bool type
08:45:23 <mr-> choose
08:45:29 <augur> mr-: not quite
08:45:30 <sclv_> :-P
08:45:44 <dmwit> sclv_: heh
08:45:57 <mr-> augur: why not?
08:46:11 <augur> there's more than two monoids on bool :)
08:46:41 <mm_freak> ocharles: go ahead
08:46:44 <augur> if byorgey is right about xor being a monoid, then there are at least three
08:46:45 <ocharles> tikhon: see the bool library on hackage
08:46:48 <mr-> augur: I guess it's true
08:46:59 <mr-> augur: the non-identity times non-identity can be either
08:47:07 <augur> what
08:47:14 <edwardk> mr-: ok, I choose "False". Tell me, did I mean (||) or `xor`?
08:47:16 <ocharles> mm_freak: I was trying to build upon your 'bouncing ball' answers on haskell-cafe. I have multiple "bouncing balls", which are just '#'s that move from left to right on a line
08:47:19 <ocharles> This works fine
08:47:37 <ocharles> I wanted to add collision information, to show some information when a ball "bounces" - that is changes direction at the left hand side
08:47:40 <ocharles> here's what I have:
08:47:50 <dmwit> augur: Prelude Data.Universe Data.Universe.Instances> [f | f <- universe, associative f, hasIdentity f] :: [Bool -> Bool -> Bool]
08:47:53 <dmwit> [[(False,[(False,False),(True,False)]),(True,[(False,False),(True,True)])],[(False,[(False,False),(True,True)]),(True,[(False,False),(True,True)])],[(False,[(False,False),(True,True)]),(True,[(False,True),(True,False)])],[(False,[(False,True),(True,False)]),(True,[(False,False),(True,True)])],[(False,[(False,False),(True,True)]),(True,[(False,True),(True,True)])]]
08:47:58 <hpaste> ocharles pasted ‚Äúmulti bounce (for mm_freak)‚Äù at http://lpaste.net/91333
08:47:59 <mr-> edwardk: Yes, I was just seeing that. So we need to fix the identity and what non-identity times non-identity is
08:48:01 <augur> dmwit: horrible
08:48:05 <dmwit> Thank you.
08:48:13 <augur> dmwit: make that look nicer!
08:48:15 <sclv_> ok here's a genuine question: how far off is our Num typeclass from being a legit boolean algebra typeclass?
08:48:26 <augur> dmwit: also now i have to learn about Universe!
08:48:37 <Ivo> yitz: i don't know complete steps for compiling things and running them yet :/
08:48:46 <dmwit> augur: patches welcome
08:48:54 <augur> dmwit: tell me about Data.Universe
08:49:04 <ocharles> universe is cool, I was using it to prove some basic answers to the exercises about A Book of Abstract Algebra
08:49:07 <ocharles> :)
08:49:09 <tikhon> I think Num has too *many* functions to represent a boolean algebra
08:49:23 <dmwit> augur:
08:49:25 <dmwit> ?hackage universe
08:49:25 <lambdabot> http://hackage.haskell.org/package/universe
08:49:27 <mm_freak> ocharles: go on =)
08:49:31 <ocharles> mm_freak: I was curious if I was just along the right lines. It felt weird to bring that Either in
08:49:46 <edwardk> now, if you go a step further and say that say two binary operations you have like that have the same unit, and that (a*b).(c*d) = (a.c)*(b.d) -- that is that the two 'abide' each other to borrow a term from Bird then you can use the Eckmann-Hilton argument to show that the two operations are commutative and must be the same operation.
08:50:00 <ocharles> mm_freak: basically, I'm struggled to understand how to emit "events" from other wires, or more how to connect things together
08:50:19 <edwardk> which is a particularly oblique way of saying that that relationship doesn't hold between or and xor ;)
08:50:19 <augur> eckmann-hilton is cool
08:50:22 <augur> tick tock tick tock
08:50:42 <ocharles> mm_freak: in this code I attempted to it by jamming it all down the same wire, but that feels like a bit of an antipattern
08:50:54 <mm_freak> ocharles: yes, that Either is indeed weird
08:50:58 <ocharles> so a ball wire is either its position, or a collision event
08:51:31 <n-dolio> sclv_: Boolean algebra? It's further from that than from ring, isn't it?
08:51:49 <tikhon> it depends on what laws you expect Num instances to follow
08:51:59 <tikhon> but yeah, I'd expect Num to be more like a ring or something, with Bits being a boolean algebra
08:52:19 <mm_freak> think of it this way:  a ball wire is /always/ its position, which in netwire's semantics is a continuous event‚Ä¶  what you really want is to augment the position with direction change information
08:52:37 <ocharles> mm_freak: yes! that matches the "what I want" part :)
08:52:57 <ocharles> mm_freak: I knew something was going wrong when I noticed that I'd briefly stopped the ball moving for that instant a collision occurs
08:54:12 <mm_freak> ocharles: the stopping of the ball is related to the collision detection‚Ä¶  the tricky part about collision detection is the bounce-off‚Ä¶  the naive way is to move the ball back into bounds, but that makes it behave weird at edges
08:54:14 <dmwit> augur: Turns out I had a bug.
08:54:23 <dmwit> augur: I was only checking for one-sided identities.
08:54:28 <augur> mmm
08:54:40 <dmwit> augur: With the correction, the monoids are [(&&), (==), (/=), (||)]
08:54:47 <mm_freak> ocharles: to get the extra information you actually have to write your own mover, because the integral* wires are not expressive enough for that
08:55:25 <augur> dmwit: fun!
08:55:27 <ocharles> mm_freak: Hm, even if I don't care about accurate collisionns for now?
08:55:40 <mm_freak> ocharles: yes, this isn't about collisions
08:55:44 <ocharles> mm_freak: I mean I don't really care if the collision semantics aren't right, the challenge for this exercise was to learn how to get two pieces of information to interact
08:55:48 <ocharles> ah, ok
08:55:48 <Taneb> dmwit, hmm, they're all commutative
08:56:03 <mr-> Taneb: they have to be!
08:56:17 <mm_freak> ocharles: my personal recommendation is to look into the source code of integral_‚Ä¶  it's really easy to reproduce and allows you to add any extra information you want
08:56:23 <Taneb> mr-, can you explain why?
08:56:27 <mr-> Tene: because whenever you are multiplying two elements that are not the same, one of them is the identity
08:56:41 <Taneb> I'm Taneb
08:56:44 <mm_freak> integral* wires themselves only give you position from velocity in an abstract sense‚Ä¶  any extra information is lost
08:56:45 <mr-> sorry
08:56:54 <mr-> Taneb: because whenever you are multiplying two elements that are not the same, one of them is the identity ;-)
08:56:54 <ocharles> mm_freak: ok, I'll do that. but do I end up with something like Wire e m () (Int, Maybe Collision) then?
08:56:57 <Taneb> :)
08:57:01 <Taneb> That makes sense, mr-
08:57:04 <ocharles> mm_freak: just trying to determine what my goal is
08:57:50 <augur> dmwit: where is associative and hasIdentity?
08:58:33 <dmwit> augur: I defined them myself in ghci.
08:58:39 <augur> dmwit: ah ok.
08:58:40 <mm_freak> ocharles: that's certainly one way, but it gets you back to first class events, which is not idiomatic in netwire
08:58:40 <dmwit> let associative f = and [f (f x y) z == f x (f y z) | (x, y, z) <- universe]
08:58:49 <n-dolio> edwardk: You don't need to assume that they have the same unit. Just that they have units.
08:58:49 <dmwit> And similarly for identity, I can share it if you want.
08:59:00 <edwardk> er of course
08:59:11 <edwardk> een a while since i used it
08:59:16 <mm_freak> ocharles: here is one idiomatic way to do it:  Wire e m a (Int, Time)
08:59:32 <mm_freak> ocharles: as a side note, if your wire doesn't use its input, its input type should be polymorphic
08:59:38 <ocharles> right
08:59:41 <mm_freak> otherwise you run into trouble with applicative combinators
08:59:44 <n-dolio> Well, it's often presented the way you did, but it turns out to not be necessary.
08:59:59 <anarchat> hello!
09:00:08 <RichyB> ocharles, oh hey there. I've been enjoying your blog articles. Thank you for writing them.
09:00:18 <augur> @let leftID e (*) = and [e * x == x | x <- universe]
09:00:18 <ocharles> RichyB: thank you! glad you like them, I welcome feedback :)
09:00:19 <lambdabot>  .L.hs:149:39:
09:00:19 <lambdabot>      Couldn't match expected type `[a1]' with actual type `a0 ...
09:00:26 <augur> o
09:00:36 <augur> @let leftID e m = and [e `m` x == x | x <- universe]
09:00:41 <lambdabot>  .L.hs:149:39:
09:00:41 <lambdabot>      Couldn't match expected type `[a1]' with actual type `a0 ...
09:00:41 <augur> :|
09:00:41 <dmwit> :t universe
09:00:42 <lambdabot> Plated a => a -> [a]
09:00:44 <dmwit> =|
09:00:47 <ocharles> mm_freak: so how do I know about collisions from that wire?
09:00:51 <RichyB> ocharles, I was surprised to learn that you've gone from Perl to Haskell, actually.
09:01:02 <dmwit> augur: \bot doesn't do universe at the moment
09:01:04 <edwardk> n-dolio: oh yeah. i remember now, you can prove from the fact that they abide that the units are the same
09:01:04 <hpaste> Format pasted ‚Äúqueens‚Äù at http://lpaste.net/91335
09:01:11 <augur> dmwit: :(
09:01:16 <n-dolio> Yes.
09:01:16 <ocharles> RichyB: We haven't quite done that yet, I'm just gradually rewriting the entire world with the hope to one day deploy it. So far, no haskell is deployed :(
09:01:29 <RichyB> Most Perl programmers I've known wouldn't trade it for anything.
09:01:48 <RichyB> Some sampling bias there because it only includes programmers who are still clinging to Perl, of course. ;)
09:01:59 <mm_freak> ocharles: output extra information about the last collision and when it occurred
09:02:00 <mauke> I wouldn't trade Perl for Haskell
09:02:01 <augur> i wonder if there are some nice theorems about decomposing monoids on things
09:02:09 <mauke> I wouldn't trade Haskell for Perl either, though
09:02:16 <ocharles> RichyB: I never got the "I <3 Perl" stuff. it's a shit language. I had my brief fling with it, but CPAN doesn't make up for the huge number of warts
09:02:27 <anarchat> i am having trouble installing c2hs, a requirement to install git-annex, as documented here: http://git-annex.branchable.com/install/cabal/ - the error I am getting is related to "happy", and is detailed here: http://paste.debian.net/20221/
09:02:35 <dmwit> anarchat: cabal install alex happy
09:02:36 <anarchat> i am not "happy" ;)
09:02:37 <Maior> ocharles: I love it for the things I find it good at
09:02:47 <mm_freak> ocharles: the idea is that you can always construct events from concrete information:  Wire e m (Time, CollisionInfo) (Time, CollisionInfo)
09:02:47 <Maior> ocharles: (but then, that applies to most things)
09:02:53 <ocharles> mm_freak: ah! so Time is constant up to collisions
09:03:00 <mm_freak> yeah
09:03:05 <dmwit> anarchat: (or install them from your distro's repositories)
09:03:10 <anarchat> dmwit: ack
09:03:28 <dmwit> anarchat: It is unfortunate that cabal itself cannot do this particular kind of dependency chasing.
09:03:36 <mm_freak> ocharles: this is a general rule for netwire:  always start with concrete, continuous information and extract events from it later
09:03:41 <dmwit> anarchat: But it is a trickier job than it looks like on the surface.
09:03:52 <mm_freak> ocharles: ideally events are identity-like wires that can inhibit
09:03:59 <ocharles> yea, I got that bit
09:04:07 <mm_freak> hence the type synonym:  Event e m a = Wire e m a a
09:04:13 <ocharles> and usually do inhibit, until the event occurs, right?
09:04:20 <mm_freak> depends on the event
09:04:31 <mm_freak> netwire actually has to types of events:  discrete and continuous events
09:04:41 <mr-> augur: definitely not in full generality (think non-finitely generated groups)
09:04:42 <mm_freak> but they are both (unfortunately) represented by the same type
09:04:52 <ocharles> i see
09:05:14 <yitz> @let instance Bits Bool where (.&.) = (&&); (.|.) == (||); xor = (/=); complement = not; shift x n = flip $ (&&) . (== 0); rotate = const; bitSize = const 1; isSigned = const False; testBit = shift; bit = (== 0); popCount False = 0; popCount True = 1
09:05:14 <lambdabot>  Parse failed: Parse error: ;
09:05:52 <ocharles> mm_freak: alright, I think this should let me make a little more progress. I'll understand how integral and accum wires work, and see if I can build something that has type Wire e m a (Position, CollisionTime)
09:05:58 <ocharles> (that's just (Double, Double))
09:06:09 <augur> mr-: hm. well, for limited domains, even. the idea of generating various algebraic structures is quite interesting to me.
09:06:10 <yitz> @let instance Bits Bool where (.&.) = (&&); (.|.) == (||); xor = (/=); complement = not; shift = flip $ (&&) . (== 0); rotate = const; bitSize = const 1; isSigned = const False; testBit = shift; bit = (== 0); popCount False = 0; popCount True = 1
09:06:11 <lambdabot>  Parse failed: Parse error: ;
09:06:32 <yitz> dmwit: alright. how did you do that?
09:06:40 <anarchat> dmwit: thanks, i'll see if it works (and if i can fix git-annex's doc)
09:06:41 <dmwit> Bool is such a small type that it makes definitions like these look crazy. I mean, I'm sure that definition of shift is right, but DANG
09:06:48 <dmwit> yitz: I dunno what's wrong. I can't spot anything.
09:06:55 <anarchat> (btw, i am really happy to see a great piece of software that is bound of becoming more popular written in haskell)
09:06:58 <dmwit> yitz: Maybe it's getting cut off, or maybe the two popCount lines are a problem.
09:07:08 <anarchat> (it makes for a great excuse for me to play with haskell again :)
09:07:11 <dmwit> try popCount = fromEnum?
09:07:12 <mr-> augur: there seems to be a relationship between finite monoids and regular languages (http://www.sciencedirect.com/science/article/pii/0304397581900578)
09:07:13 <mm_freak> ocharles: good luck =)
09:07:14 <ocharles> RichyB: there you go, you can expect a blog post on netwire now at some point ;)
09:07:52 <yitz> @let instance Bits Bool where (.&.) = (&&); (.|.) == (||); xor = (/=); complement = not; shift = flip $ (&&) . (== 0); rotate = const; bitSize = const 1; isSigned = const False; testBit = shift; bit = (== 0); popCount = length . filter id . return
09:07:52 <lambdabot>  Parse failed: Parse error: ;
09:08:06 <RichyB> ocharles, sweet, thanks. :)
09:08:13 <byorgey> (.|.) == (||)
09:08:16 <byorgey> is the syntax error
09:08:25 <yitz> ahh thanks
09:08:27 <dmwit> good spot
09:08:36 <sclv_> well, boolean algebras and boolean rings are iso
09:08:40 <yitz> @let instance Bits Bool where (.&.) = (&&); (.|.) = (||); xor = (/=); complement = not; shift = flip $ (&&) . (== 0); rotate = const; bitSize = const 1; isSigned = const False; testBit = shift; bit = (== 0); popCount False = 0; popCount True = 1
09:08:40 <lambdabot>  Defined.
09:08:56 <dmwit> :t popCount
09:08:57 <lambdabot> Bits a => a -> Int
09:09:04 <dmwit> :t fromEnum
09:09:04 <lambdabot> Enum a => a -> Int
09:09:18 <dmwit> ;-)
09:09:21 <yitz> haha
09:09:32 <yitz> so, instance Enum Bool where ...
09:09:43 <dmwit> Bool is already an Enum.
09:09:56 <yitz> fromEnum True
09:10:00 <dmwit> > map fromEnum [minBound .. maxBound]
09:10:01 <lambdabot>   No instance for (GHC.Enum.Enum a0)
09:10:01 <lambdabot>    arising from a use of `GHC.Enum.fromE...
09:10:05 <yitz> > fromEnum True
09:10:06 <lambdabot>   1
09:10:12 <dmwit> > map fromEnum [False, True]
09:10:13 <lambdabot>   [0,1]
09:10:14 <yitz> dmwit: ok sorry missed that
09:10:41 <dmwit> :t shift
09:10:42 <lambdabot> Bits a => a -> Int -> a
09:11:13 <dmwit> That is a wonderful definition of shift, by the way.
09:11:37 <dmwit> > shift False 1
09:11:41 <lambdabot>   False
09:11:48 <dmwit> ...okay, yes
09:11:52 <dmwit> > shift 0 1 :: Word8
09:11:53 <lambdabot>   0
09:12:02 <yitz> dmwit: thanks
09:12:24 <yitz> dmwit: i like testBit = shift too
09:12:36 <dmwit> yes!
09:14:56 <dmwit> ?remember yitz @let instance Bits Bool where (.&.) = (&&); (.|.) = (||); xor = (/=); complement = not; shift = flip $ (&&) . (== 0); rotate = const; bitSize = const 1; isSigned = const False; testBit = shift; bit = (== 0); popCount = fromEnum
09:14:57 <lambdabot> It is stored.
09:15:25 <yitz> dmwit: hah we could even say shift = flip $ (&&) . bit
09:15:41 <dmwit> cute
09:26:46 <c_wraith> does GHC 7.8 improve inference of datakinds/typelits?
09:27:35 <c_wraith> I'm having to provide manual SingI constraints on types whose kinds already constrain them to having SingI constraints
09:28:13 * hackagebot hdbi 1.0.0 - Haskell Database Independent interface  http://hackage.haskell.org/package/hdbi-1.0.0 (AlekseyUymanov)
09:28:15 * hackagebot hdbi-postgresql 1.0.0 - PostgreSQL driver for hdbi  http://hackage.haskell.org/package/hdbi-postgresql-1.0.0 (AlekseyUymanov)
09:35:42 <radish> hello!
09:37:14 <radish> quick performance question.  I have a recursive function with a value myValue -1.  It's not going to calculate that every time I recurse if myValue is scoped in the function that calls the recursive function, right?
09:38:05 <radish> like, it's /not/ an argument of the recursive function.  it's in the /same scope/ as the recursive function.
09:38:13 * hackagebot unix-process-conduit 0.2.1.2 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.1.2 (MichaelSnoyman)
09:38:25 <c_wraith> It won't recalculate it if you name the expression
09:38:41 <c_wraith> If you name the expression in a non-recursive scope, that is
09:39:12 <c_wraith> If you don't, it will depend on the optimizer deciding that there's actually a benefit to CSE and the floating the binding.
09:39:16 <seeg> hello
09:39:25 <c_wraith> *and then
09:40:19 <applicative> hello seeg
09:40:51 <radish> c_wraith: so I should define it in the scope above and reference the definition from the recursive function?
09:41:02 <c_wraith> radish: that will guarantee it's only calculated once, yes
09:41:05 <seeg> i'm trying to fetch a row from DB using Persistent, but I get errors, here's the gist: https://gist.github.com/CGenie/7e83acb77a86f2d8049d
09:41:06 <applicative> radish: then it will be clear
09:41:12 <seeg> as you can see, the SQL is correct
09:41:22 <c_wraith> radish: well, technically, calculated at most once.  (laziness and the chance it might not be used at all, etc)
09:41:31 <yitz> c_wraith: well, define "non-recursive scope". if a function is recursive but has a where binding "myValue = -1" do you call that non-recursive scope?
09:41:32 <seeg> and I checked: there is a row with 'email' = 'test@test.com'
09:41:34 <radish> c_wraith: that's what I was doing initially but I wanted to trim some of the fat.
09:41:57 <seeg> sorry, I don't get errors, I do get Nothing ;)
09:41:58 <c_wraith> radish: extra name bindings really aren't fat, most of the time.
09:42:20 <radish> c_wraith: so I can't do it in a where definition either I take it.
09:42:25 <blochchain> http://lpaste.net/91336   why isn't this being executed more lazily? it's causing a stack overflow when reading a file of 9.5 million lines. (my machine has 22 GB of RAM)
09:42:52 <radish> c_wraith: that's very frustrating because I'll undoubtly not catch things like that in the future.
09:43:07 <c_wraith> radish: you can do it in a where clause, if the where clause is bound to the higher scope
09:43:45 <c_wraith> yitz: I would consider that to be a recursive scope.  in that case, it's up to the optimizer deciding to float the expression.  Which it often does, but it's still very mysterious.
09:44:14 <yitz> seeg: we don't see all of your code in that gist. but the debugging output looks pretty clear. run that exact same query in db repl. do you get anything?
09:44:18 <applicative> google thinks the persistent package is in Norwegian
09:44:23 <applicative> http://hackage.haskell.org/packages/archive/persistent/1.2.2.0/doc/html/doc-index-R.html
09:44:24 <yitz> seeg: are you sure you got a good db connection?
09:44:35 <applicative> where is runDB from, seeg
09:45:03 <zvrba> i tried to install hdirect and got an error about ambiguous module name Prelude: it was found in multiple packages: base haskell98-2.0.0.1
09:45:12 <seeg> I use Yesod
09:45:16 <Gracenotes> it thinks the same thing about S
09:45:29 <seeg> the connection should be OK, at least auth/login inserts a user properly
09:45:36 <zvrba> any suggestions on how to fix it?
09:46:00 <c_wraith> zvrba: then the package hasn't been updated for recent versions of GHC. The fix is removing Haskell98 from the dependencies and repairing the code that breaks because of it.
09:46:01 <applicative> zvrba: the cabal file should declare the language I think is it just hdirect not a dependency
09:46:22 <applicative> right, what c_wraith the point is Haskell98 was declared to avoid work
09:46:26 <Franciman> hey people, why aren't certain symbols allowed after -- ??
09:46:26 <zvrba> has anybody here used hdirect to use COM components?
09:46:51 <geekosaur> Franciman, because -- can quite sensibly be part of a symbol name
09:47:02 <geekosaur> for example xmonad uses an infix operator (-->)
09:47:13 <c_wraith> Franciman: technically, -- doesn't imply a comment by itself. The syntax is a bit more specific.
09:47:16 <Gracenotes> > let a --* b = (a-1) * b in 5 --* 5
09:47:17 <lambdabot>   20
09:47:18 <geekosaur> -- is only a comment when it's not part of a larger symbol
09:47:24 <applicative> wow hdirect looks like a lot of trouble, zvrba
09:47:45 <Franciman> oh thanks
09:47:46 <Gracenotes> > let a -- b = a * b in 5 -- 5
09:47:47 <lambdabot>   <hint>:1:29:
09:47:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
09:48:07 <c_wraith> > 5 ----------------------  but this is a comment
09:48:08 <lambdabot>   5
09:48:31 <byorgey> zvrba: the last upload was in early 2010, and it hasn't been updated as c_wraith mentioned, which means it clearly hasn't been used in about two years
09:48:48 <Gracenotes> applicative: perhaps, I suppose, it must think it's norwegian from all of the 'raw'
09:49:23 <yitz> applicative: when i allow google to translate it, the only change is A B C D E F G H I K => A B C D E F G H In K
09:49:50 <zvrba> what should I put instead of haskell98 to the cabal file?
09:49:59 <byorgey> zvrba: just delete it
09:50:02 <zvrba> and it says base >= 2 && base < 5
09:50:15 <byorgey> that's fine
09:50:29 <zvrba> how do I build with cabal?
09:50:36 <geekosaur> cabal install
09:50:43 <geekosaur> (without package name, so it uses the cabal file in .)
09:50:48 <zvrba> ok
09:51:15 <zvrba> could not find List, as it's in haskell98, which I've just deleted.
09:51:16 <seeg> sheesh, seems that the row was not there after all, sqlitebrowser saves changes only when I say so :)
09:51:24 <byorgey> zvrba: the biggest problem you are going to run into is that all the imports look to be of the form e.g.  import List, using the old non-hierarchical module names, instead of the new e.g.  import Data.List
09:51:28 <zvrba> blargh. this is going to be tedious
09:51:37 <byorgey> zvrba: it is easy to fix but very tedious.
09:51:41 <c_wraith> zvrba: yep.  You're going to have to fix lots of imports
09:51:41 <zvrba> yup
09:52:00 <byorgey> there may be other less tedious things to fix too, who knows
09:52:08 <byorgey> only one way to find out.
09:52:29 <zvrba> aaargh, and it's in literate haskell!
09:52:42 <c_wraith> byorgey: by the way, did you know we're more than halfway through 2013 now? :P
09:52:56 <byorgey> c_wraith: haha, oh yeah
09:53:14 <byorgey> zvrba: what's wrong with literate Haskell?
09:53:29 <c_wraith> If you're not used to it, it's more cognitive overhead to work with.
09:53:40 <c_wraith> I assume that's the complaint.
09:53:41 <byorgey> but that's true of everything.
09:53:45 <c_wraith> well, yes
09:54:14 <zvrba> byorgey: latex layer around the code to parse :P
09:54:26 <yitz> zvrba: if you can do the work to update hdirect and make it usable in a modern environment, please upload the result to hackage. when needed, that could be a very very useful library.
09:55:00 <zvrba> yitz: working on it.
09:55:21 <zvrba> it's like 50 files to edit imports in
09:55:30 <byorgey> the maintainer is listed as Don Stewart, who is clearly not maintaing it anymore and furthermore has more or less disappeared from the community
09:55:31 <yitz> zvrba: wow.
09:55:42 <byorgey> so you could even take over as the maintainer, stick it on github somewhere, etc.
09:55:49 <yitz> yeah dons is busy working for a bank now
09:55:56 <zvrba> I want to play with PDB parsing.
09:56:22 <zvrba> DIA interface
09:56:30 <c_wraith> byorgey: Were you involved with the type literals stuff, or only the related DataKinds stuff?
09:56:54 <zvrba> I already have a C++ program that dumps the interesting stuff to a flat file, but I want to try to do it from haskell
09:56:58 <byorgey> c_wraith: only DataKinds
09:57:01 <zvrba> + other processing on top of it
09:57:18 <c_wraith> byorgey: darn.  I'll have to find some other way to try to extract answers about this stuff. :)
09:57:32 <yitz> zvrba: yes hdirect could be useful for many things
09:57:54 <zvrba> yitz: (databases, etc... right.)
09:58:18 <byorgey> c_wraith: you should contact Iavor Diatchki
09:58:22 <byorgey> I don't think he's on IRC
09:58:28 <zvrba> is there a program that can intelligently repair indentation of literate haskell code?
09:58:50 <zvrba> e.g. all imports with names are nicely indented, adding qualified names destroys the nice indentation
09:59:10 <yitz> zvrba: emacs haskell mode might help a little, but it will still require some keystrokes for each line
09:59:23 <byorgey> zvrba: http://hackage.haskell.org/package/stylish%2Dhaskell , not sure if it works on literate Haskell though
09:59:41 <zvrba> ok, I'll just drop the nice indentation in the first run
09:59:46 <zvrba> (+ the file uses tabs :/)
09:59:55 <byorgey> stylish-haskell can help with the tabs too
10:00:05 <zvrba> oh, hdirect also names som jni stuff...
10:00:12 <yitz> so can emacs :)
10:00:31 <byorgey> of course =)
10:00:42 <zvrba> hm
10:00:46 <zvrba> how do you compile lhs to a book?
10:01:02 <yitz> zvrba: all the top-level module names are not in style nowadays either. they would be better as HDirect.Foo or something.
10:01:35 <zvrba> yitz: oh, I get it..
10:01:49 <byorgey> zvrba: it might be valid LaTeX, in which case you just do whatever you would normally do for a LaTeX document
10:02:07 <zvrba> right :)
10:02:11 <zvrba> but I doubt it.
10:02:14 <byorgey> not sure when the first version of lhs2tex came out, it's unlikely that hdirect would be using that
10:02:27 <zvrba> literate source usually has to be weaved or tangled before compilation with latex or compiler
10:02:47 <yitz> zvrba: might work. it's latex style literate, not bird tracks.
10:03:33 <byorgey> the point of latex style literate code is that GHC will ignore anything outside  \begin{code} ... \end{code}, and then you just have to define a code environment to tell LaTeX how to typeset it
10:05:12 <satc> @pl (\b c a -> f a b c)
10:05:12 <lambdabot> flip . flip f
10:06:28 <zvrba> but there's both Monad and Control.Monad
10:06:46 <zvrba> the code imports just Monad
10:06:50 <zvrba> which should I use?
10:07:09 <dmwit> blochchain: Did you ever get an answer?
10:07:24 <zvrba> ah, I'll just rewrite it to COntrol.Monad
10:07:25 <blochchain> dmwit, i don't think so
10:07:25 <dmwit> blochchain: If I had to guess without testing, I would blame maximum. Have you compiled with -O2?
10:07:28 <zvrba> it uses qualified imports
10:07:47 <dmwit> blochchain: (And by the way, stack overflow usually indicates "too lazy", not "not lazy enough".
10:07:50 <dmwit> )
10:08:43 <blochchain> dmwit, i hadnt used -O2. what does it do
10:08:49 <blochchain> having trouble finding info on it
10:09:00 <dmwit> It turns on optimizations.
10:09:16 <dmwit> In particular, I expect it will notice that maximum is being used strictly and substitute it with a stricter version of maximum.
10:09:19 <dmwit> s/expect/hope/
10:09:33 <dmwit> If not, you could try defining the stricter maximum yourself.
10:09:35 <dmwit> ?src maximum
10:09:35 <lambdabot> maximum [] = undefined
10:09:35 <lambdabot> maximum xs = foldl1 max xs
10:09:48 <dmwit> The stricter maximum is \xs -> foldl1' max xs
10:09:54 <dmwit> (note the prime)
10:09:57 <zvrba> who wrote hdirect originally? it's huge..
10:10:08 <yitz> i think nowadays just -O is recommended. it doesn't everything you probably want and nothing you probably don't want.
10:10:18 <yitz> it *does*
10:10:57 <dmwit> zvrba: According to Hackage, Sigbjorn Finne is the author.
10:11:13 <zvrba> mm
10:11:32 <dmwit> You could look in the darcs repository metadata for more detailed information.
10:12:16 <blochchain> it worked. that's a nifty trick, dmwit
10:12:23 <blochchain> i never knew about -O2
10:13:01 <kosmikus> byorgey: I started maintaining lhs2tex in 2004. by then it must have existed for several years already. I'd guess something like 2001, perhaps. or even earlier.
10:13:28 <yitz> sigbjorn used to be at galois. now he is a core developer of the opera browser.
10:13:55 <zvrba> from Haskell to C++. :S
10:15:06 <luite> yitz: hmm, that must be less interesting now that they just use chrome's engine...
10:16:08 <Taneb> Whenever I see someone write "BOS", I don't expand it to Brian O'Sullivan, I just imagine them shouting "boss"
10:16:13 <Taneb> It gets confusing
10:16:24 <arnsholt> If he worked on Presto he's either doing something completely different, or working somewhere else
10:16:26 <dmwit> Funny, I voice the 's' in "bos".
10:16:55 <yitz> luite: probably. but i'm sure sigbjorn has plenty to do.
10:17:10 <arnsholt> (The whole department named "Core" was axed when they moved over to Chrome, sadly)
10:17:16 <luite> yitz: probably :)
10:17:18 <yitz> dmwit: me too, as the first sound in "sullivan"
10:17:52 <dmwit> The first 's' in "Sullivan" is voiced?
10:17:56 <dmwit> Surely not...
10:18:04 <yitz> wow. hdirect has a module called OmgParser. it's full of stuff like this:
10:18:07 <dmwit> Or am I using technical terms incorrectly again?
10:18:37 <zvrba> OMG as in OMG Corba :)
10:18:42 <yitz> happyIn4 :: ([Defn]) -> (HappyAbsSyn ); happyIn4 x = Happy_GHC_Exts.unsafeCoerce# x; {-# INLINE happyIn4 #-}
10:19:05 <arnsholt> dmwit: A voiced s is the sound normally written z, for reference
10:19:13 <dmwit> Okay, I'm using it right.
10:19:17 <yitz> dmwit: oh voiced as opposed to unvoice, in the phonetic sense
10:19:23 <luite> yitz: happy generated parser? they have lots of unsafeCoerce
10:19:25 <dmwit> yeah =)
10:19:41 <elliott> yitz: omg. it's so happy.
10:20:08 <yitz> zvrba: if you can make this work that would be an amazing contribution
10:20:36 <zvrba> yitz: working on it; so far it's just simple renaming of modules to modern names
10:21:20 <zvrba> fortunately, MS tends to keep COM binary interface very very very stable ;)
10:22:35 <yitz> dmwit: maybe you're thinking of tom bosley
10:22:49 <dmwit> =)
10:23:15 <zvrba> hm
10:23:35 <zvrba> now I'm stuck: it wants module System, but it's in haskell98 package which I've just removed
10:23:47 <zvrba> it uses getProgName, exitWith, ExitCode
10:23:49 <applicative> zvrba: oh, i think i just finished
10:23:52 <yitz> zvrba: probably System.IO
10:23:57 <dmwit> ?hoogle getProgName
10:23:57 <applicative> zvrba: yeah thats two
10:23:57 <lambdabot> System.Environment getProgName :: IO String
10:24:03 <yitz> oh that's System.Environment
10:24:04 <dmwit> ?hoogle exitWith
10:24:04 <applicative> System,Exit and Environment
10:24:04 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
10:24:16 <zvrba> System.Environment
10:24:17 <yitz> zvrba: you may need both of those
10:24:21 <zvrba> applicative: finished what_
10:24:24 <dmwit> zvrba: Now you know how to ask the question in an automated way! =)
10:24:40 <zvrba> yeah, I just remembered to use Eclipse :)
10:26:27 <applicative> oh i updated it, just trying to figure it out
10:28:14 * hackagebot haskell-src-meta 0.6.0.3 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.3 (BenMillwood)
10:29:28 <applicative> zvrba: https://github.com/michaelt/hdirect
10:30:00 <zvrba> oh
10:30:08 <zvrba> meaning, somebody has already updated it? :)
10:30:13 <applicative> zvrba I punted with the version number and package name fields.
10:31:03 <applicative> zvrba: you should figure out how to get it to know its own version name, at the moment version_number = "version_number see Main.hs line 324"
10:31:12 <applicative> hahahaha
10:32:27 <yitz> @. hoogle run text $ "exit" ++ "With"
10:32:28 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
10:32:41 <theWinner> anyone here use F#?
10:33:14 * hackagebot first-class-patterns 0.3.2 - First class patterns and pattern matching, using type families  http://hackage.haskell.org/package/first-class-patterns-0.3.2 (BrentYorgey)
10:35:20 <byorgey> kosmikus: wow, I didn't know it had been around that long.
10:35:27 <yitz> applicative: use the Paths_packagename module
10:35:35 <byorgey> kosmikus: who were its initial author(s) then?
10:36:04 <applicative> yitz: yes, I'm thinking zvrba should figure out how to do it. I was just bringing it up to data in homage to S. Finne and D. Leijen
10:36:28 <applicative> of blessed memory
10:36:49 <yitz> applicative: ok great. meaning you already did some of the tedium that zvrba thought needs to be done?
10:37:21 <applicative> yeah I made it Haskell 20XX but there seems to have been a different sort of getMyVersionNumber
10:38:14 <dcoutts> byorgey: Ralf Hinze is another author, perhaps original
10:38:15 <applicative> so currently the version number is eternall fixed as "version number" so to say
10:38:38 <yitz> zvrba: cabal automatically creates a module called Paths_foo when you build foo.cabal. Look up in the cabal docs what's in there. if you have trouble, let me know.
10:39:17 <byorgey> ah, https://github.com/kosmikus/lhs2tex/blob/master/AUTHORS
10:39:17 <applicative> zvrba since you seem to have domain knowledge if you figure it out and it works you should take over maintainership from uh, whats his name, dons
10:39:19 <zvrba> wuhu, the library now compiled, with warnings though
10:39:20 <kosmikus> byorgey: Ralf Hinze wrote it.
10:39:24 <zvrba> like overlapping patterns...
10:39:28 <yitz> yay!
10:39:38 <byorgey> cool
10:39:59 <zvrba> applicative: i have some domain knowledge, but not enough haskell knowledge :S
10:40:09 <applicative> yeah I noticed a lot of overlapping patterns
10:40:11 <zvrba> ok, I'll figure it out underway
10:40:18 <dcoutts> byorgey: Ralf has dropped all his practical stuff as far as I can see. Frown needs a maintainer.
10:40:37 <kosmikus> frown never had one
10:40:40 * dcoutts tried to persuade one of Ralf's students to pick it up
10:40:52 <yitz> zvrba: looks like the overlapping patterns were always in there and it worked. nice to fix but definitely not your highest priority.
10:40:57 <byorgey> huh, I'd never heard of frown
10:41:01 <dcoutts> kosmikus: not a maintainer, had an author!
10:41:07 <zvrba> wtf, I've got an exe! :-)
10:41:10 <dcoutts> byorgey: like happy, get it?
10:41:11 <zvrba> hdirect.exe
10:41:14 <kosmikus> ralf wrote it but never maintained it
10:41:14 <zvrba> \o/
10:41:18 <byorgey> dcoutts: haha =)
10:41:37 <yitz> zvrba++
10:41:37 <dcoutts> byorgey: supposed to be a happy-like parser generator but with some extra features and possibly a bit faster
10:41:45 <applicative> zvrba: oh awesome
10:41:51 <byorgey> zvrba: that was fast!
10:41:55 <zvrba> i've found the Paths_ file
10:42:04 <byorgey> dcoutts: I see
10:42:06 <dcoutts> byorgey: particularly, better parse error reporting, reports which production it was in and what terminals were expected
10:42:39 <zvrba> the version is hard-coded to 0.21
10:42:43 <zvrba> in the Paths_ file
10:42:46 <kosmikus> frown was nice. i used it for Generic Haskell.
10:43:01 <dcoutts> byorgey: ever noticed how ghc parse errors are terrible? direct consequence of happy's minimalist approach to error reporting, it tells you almost noting, just the lexer state
10:43:04 <yitz> zvrba: yes. the Paths_ file gets generated from the cabal file automatically every time you build.
10:43:09 <applicative> zvrba yeah I saw two places src/Opts.lhs:356:11: Not in scope: `pkg_name'
10:43:25 <applicative> and src/Main.lhs:381:42: Not in scope: `pkg_name'
10:43:27 <byorgey> dcoutts: ahh, I see.  I had forgotten that GHC uses happy.
10:43:35 <byorgey> GHC's parse errors are indeed terrible.
10:43:38 <kosmikus> heh
10:43:49 <kosmikus> how can you forget
10:43:49 <applicative> zvrba: and likewise with pkg_version
10:44:04 <dcoutts> "Parser error at (..), erm perhaps you did something wrong? Layout maybe?"
10:44:18 <dcoutts> yah, great, ta
10:44:26 <zvrba> src/Version.hs
10:45:04 <applicative> zvrba: oh i'll be darned.
10:45:16 <zvrba> grep ;)
10:45:33 <applicative> zvrba: i 'updated' "import Version" to "import Data.Version" in a couple places...
10:45:41 <zvrba> :/
10:45:43 <applicative> zvrba: that needs correction...
10:45:53 <yitz> Probable cause: `foo' is applied to too few arguments
10:46:24 <zvrba> what does ihc.exe refer to in pkg_name ?
10:48:02 <zvrba> why has the homepage haskell.org/hdirect disappeared?
10:48:46 <zvrba> ok, got an exe.
10:48:47 <yitz> zvrba: oh yeah. haskell.org moved to a new server about 2 yrs ago. the people who owned pages like that complained but i guess that one was neglected.
10:49:18 <yitz> zvrba: write to the haskell-infrastructure mailing list and ask if anyone knows about that.
10:49:20 <applicative> zvrba: I pushed the version with the correct Version
10:49:30 <sclv_> we actually just moved again last week
10:49:34 <sclv_> or three weeks ago
10:49:36 <zvrba> i've also found an old paper ('199x) which talks about com programming with haskell.
10:49:37 <chrisdotcode_> hey guys  :)
10:49:41 <sclv_> so maybe it was a more recent problem.
10:49:41 <yitz> sclv_: oh you already moved? great!
10:49:50 <zvrba> applicative: ok!
10:50:01 <sclv_> community.haskell.org hasn't moved yet
10:50:08 <sclv_> and there are some other pieces that are... in process
10:50:15 <sclv_> but the main webserver moved
10:50:16 <yitz> sclv_: i had been doing a lot of the lun support work but was buried at work for a month or two. am i off that now?
10:50:39 <chrisdotcode_> how do I compare the values inside of two tuples? I thought it was "(<) <$> (10, 12) <*> (97, 113)", but that was completely wrong.
10:50:45 <yitz> sclv_: read: almost all of the lun support work, except for a little help from malcolmw.
10:51:01 <sclv_> yitz: lun is community? well we'd love to have you keep chipping in!
10:51:11 <sclv_> but there's a bunch of new enthusiastic admins too
10:51:24 <enthropy> > (<) <$> (10, 12) <*> (97, 113)
10:51:25 <yitz> sclv_: great!
10:51:25 <lambdabot>   No instance for (Data.Monoid.Monoid t0)
10:51:25 <lambdabot>    arising from a use of `e_1101297...
10:51:26 <sclv_> it'll be good to keep you in the loop just so we can get yr advice and knowledge
10:51:29 <zvrba> RHW is a huge book :S
10:51:51 <yitz> sclv_: any changes so far i should know about?
10:51:51 <arnsholt> dcoutts: Well, happy seems to generate a LALR parser, and error reporting with LALR is known to be wonky
10:51:55 <sclv_> we mainly chat on the #haskell-infrastructure channel -- i see yr idling there
10:51:58 <chrisdotcode_> enthropy: yeah, it's a weird I couldn't get it working...
10:52:11 <dcoutts> arnsholt: true, it's tricky, but happy does nothing
10:52:16 <yitz> sclv_: ah ok that's active again? nice.
10:52:32 <dcoutts> arnsholt: one does at least know what production one was in when it failed, and which terminals were expected in that state
10:52:45 <arnsholt> True, true
10:53:02 <dcoutts> parsec doesn't do a whole lot more than that
10:53:03 <yitz> is happy short for happy-go-lucky?
10:53:12 <arnsholt> Apparently perl (which uses yacc internally) goes to heroic lengths to provide useful error messages
10:53:17 <dcoutts> and that's enough for parsec to produce pretty good error messages
10:53:34 <enthropy> > (<) <$> (First $ Just 10, 12) <*> (First $ Just 97, 113)
10:53:35 <lambdabot>   (First {getFirst = Just 10},True)
10:53:52 <dcoutts> arnsholt: not-even-slightly-heroic would be a major improvement for us :-)
10:54:08 <arnsholt> True that, true that =)
10:55:24 <yitz> sclv_: so is there anyone around now who can dig up the hdirect page from the old haskell.org for zvrba and applicative?
10:55:49 <zvrba> re HDirect: http://dl.acm.org/citation.cfm?id=289437
10:55:56 <Philippa> Parsec's errors get messy if you use negation
10:56:09 <c_wraith> oh!  There are no actual instances of SingI, as far as I can tell.
10:56:14 <c_wraith> No wonder this is baffling.
10:56:20 <Philippa> or if you do a lot of generating the 'real' parser on the fly, say
10:56:55 <Philippa> the applicative fragment should be well-behaved though, especially if you annotate w/ <!>
10:57:30 <c_wraith> err.  "There are built-in instances [of SingI] for the singleton types corresponding to type literals."
10:58:00 <c_wraith> I'm not sure what that means, but I strongly suspect it's why I need to put what I think are redundant constraints on functions.
10:58:18 <sclv_> hrm, the hdirect page disappeared ~2 years ago, acording to archive.org
10:58:20 <sclv_> not in the last move
10:58:24 <sclv_> dunno where we'd find it
10:58:55 <c_wraith> I guess it means that there are more or less unlimited numbers of instances, so they only exist when mentioned - they can't be inferred.
10:58:59 <popx> anyone know of a datastructure or database where you can make location based queries: ie all points near this location (x, y) point or similar?
10:59:28 <Adeon> locality sensitive hashing?
10:59:42 <popx> that sounds interesting
10:59:58 <enthropy> @type uncurry (***) . ((>) *** (>))
10:59:59 <lambdabot> (Ord b, Ord b') => (b, b') -> (b, b') -> (Bool, Bool)
11:00:13 <zvrba> anyway.. enough for today.
11:00:22 <enthropy> popx: kd tree
11:02:48 <sclv_> zvrba, applicative in the meantime there's always archive.org: http://web.archive.org/web/20100701121341/http://www.haskell.org/hdirect/
11:02:50 <kingugo> Just starting off with haskell; have a little question, you guys shouldn't mind my newbieness. Please what does  <- mean in this lineghci > [ x * y | x <- [2 ,5 ,10] , y <- [8 ,10 ,11] , x * y > 50]
11:03:13 <kingugo> Just starting off with haskell; have a little question, you guys shouldn't mind my newbieness. Please what does  <- mean in this line* ghci > [ x * y | x <- [2 ,5 ,10] , y <- [8 ,10 ,11] , x * y > 50]
11:03:28 <tikhon> that's part of the syntax for list comprehensions
11:03:34 <mapreduce> echo
11:03:40 <tikhon> it means that x will take all the values from [2, 5, 10]
11:03:42 <arnsholt> kingugo: Means that x will be one of the elements in the list on the right
11:03:44 <tikhon> simplest example:
11:03:48 <mapreduce> it means 'takes each value of'
11:03:50 <tikhon> [x | x <- [2, 5, 10]]
11:03:52 <tikhon> > [x | x <- [2, 5, 10]]
11:03:53 <lambdabot>   [2,5,10]
11:03:58 <tikhon> > [x + 1 | x <- [2, 5, 10]]
11:03:59 <lambdabot>   [3,6,11]
11:04:00 <arnsholt> (It's the little epsilon thing which is set membership in mathematical notation)
11:04:08 <tikhon> ‚àà
11:04:52 <popx> enthropy: thanks, that was what I was looking for :)
11:05:47 <kingugo> thanks all. got it. Proceeding with "Learn You a haskell for great good" hope am in the right path
11:05:55 <enthropy> popx: there are lots of alternatives. I'm doing a binding to http://people.cs.ubc.ca/~mariusm/index.php/FLANN/FLANN right now for example
11:12:09 <kingugo> another confusion. in this code; r e moveNonUppercasest = [ c | c <- st , c ë elem ë [ íA í.. í Z í]] is `elem` a keyword? thanks.
11:12:30 <kingugo> another confusion. in this code; removeNonUppercasest = [ c | c <- st , c ë elem ë [ íA í.. í Z í]] is `elem` a keyword? thanks.
11:12:37 <byorgey> kingugo: elem is not a keyword, it is a function defined in the standard Data.List module.
11:12:41 <byorgey> @type elem
11:12:41 <lambdabot> Eq a => a -> [a] -> Bool
11:12:58 <tikhon> @src elem
11:12:58 <lambdabot> elem x    =  any (== x)
11:13:00 <byorgey> putting it in backticks like `elem`  makes it infix.
11:13:12 <tikhon> @src any
11:13:12 <lambdabot> any p =  or . map p
11:13:50 <satc> @hoogle basicUnsafeFreeze
11:13:51 <lambdabot> No results found
11:14:22 <kingugo> @hoogle basic unsafe freeze
11:14:22 <lambdabot> No results found
11:14:30 <kingugo> auwch
11:16:53 <kingugo> thanks all. still moving.
11:18:15 * hackagebot HLearn-approximation 1.1.0 -   http://hackage.haskell.org/package/HLearn-approximation-1.1.0 (MikeIzbicki)
11:19:12 <kingugo> byorgey: how about st?
11:20:54 <byorgey> kingugo: I think st is supposed to be a parameter to that function.
11:21:02 <bscarlet> kingugo: you pasted "removeNonUppercasest", but it'd make more sense if you meant "removeNonUppercase st"
11:21:10 <chunkstuntman> how can I get a square root precise to 100 digits?
11:21:10 <byorgey> kingugo: i.e. you are missing a space, it should say  removeNonUppercase st = ...
11:21:39 <dmwit> > sqrt 2 :: CReal
11:21:40 <lambdabot>   1.4142135623730950488016887242096980785697
11:21:40 <byorgey> chunkstuntman: use CReal, perhaps
11:21:46 <dmwit> :t showCReal
11:21:47 <lambdabot> Int -> CReal -> String
11:21:55 <dmwit> > showCReal 100 (sqrt 2)
11:21:56 <lambdabot>   "1.414213562373095048801688724209698078569671875376948073176679737990732478...
11:22:04 <kingugo> ow, ok. now i get it
11:22:13 <kingugo> thanks. the space confused me.
11:22:56 <dmwit> Or use cyclotomic numbers!
11:23:12 <yitz> sclv_: i've got to run. maybe someone at galois would know where the hdirect page is? or someone at yale?
11:23:38 <yitz> sclv_: otherwise, i guess we could just copy text from the archive.org page and start over :(
11:25:27 * dmwit . o O ( sqrt :: Floating a => a -> [a] )
11:25:29 <yitz> dmwit: sqrt 2 works out nicely in, say Z/7Z.
11:25:34 <applicative> i was going to say, I've transferred allegiance to cyclotomic, but I think they wont help with digits of sqrt 2
11:25:54 <applicative> sqrt 2 = e(8) - e(8)^3
11:26:05 <dmwit> I suspect asking for the digits was actually just a plea for a high-accuracy representation.
11:26:23 <applicative> oh then by all means cyclotomic if it fits the rest...
11:26:30 <satc> what does freeze do to a mutable vector ?
11:26:39 <applicative> satc: nothing
11:26:44 <dmwit> Although I can't know for sure. =)
11:27:12 <applicative> satc oh wait, freeze, unlike unsafeFreeze, should copy it
11:28:46 <dmwit> > [n^2 `mod` 7 | n <- [0..6]]
11:28:47 <applicative> satc in any case unsafeFreeze . mutatelikecrazy . unsafeThaw in theory uses the same array through out, so you don't want to retain references to the unmutated vector
11:28:48 <lambdabot>   [0,1,4,2,2,4,1]
11:29:26 <applicative> satc: by contrast freeze . mutatelikecrazy . thaw is safe that way
11:29:43 <applicative> satc: my types aren't quite fitting together but I hope im making sense
11:30:13 <dmwit> yitz: seems you chose your sizing carefully
11:30:20 <satc> applicative: I am trying to understand what does this mean for unsafeToForeignPtr "Yield the underlying ForeignPtr together with the offset to the data and its length. Modifying the data through the ForeignPtr is unsafe if the vector could have frozen before the modification."
11:30:43 <applicative> oh Storable vectors satc ?
11:30:44 <satc> applicative: from http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Storable-Mutable.html
11:30:52 <satc> applicative: yes
11:31:21 <yitz> dmwit: yes. the gauss symbol will help to find a lot more lucky choices.
11:31:45 <satc> applicative: I want to use pointer associated with my vector as array in external c functions using ffi?
11:33:11 <satc> applicative: on haskell side I can get the MVector from ForeignPtr and while using c ffi I can translate that to a ForeignPtr. Is that a right way to do it?
11:33:16 * hackagebot mongodb-queue 0.2.5 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.5 (GregWeber)
11:33:19 <applicative> satc: yes I see, this is more particular than the case I was envisaging.
11:33:23 <applicative> satc: O
11:34:08 * applicative doesnt depends on ninjas to do his ffi
11:35:16 <applicative> or niebelungen and rhine maidens
11:35:53 <c_wraith> Can you pack an existential into a newtype if it doesn't carry dictionaries?
11:36:00 <monochrom> ‚ô• rhine maidens
11:37:05 <monochrom> no, I think newtype existential is syntactically ruled out
11:37:27 <applicative> yes, the error says, use data instead
11:38:04 <applicative> or maybe one immediately understands ones crime
11:38:18 <monochrom> GHC user's guide explains: "but single-field existentially quantified constructors aren't much use. So the simple restriction (no existential stuff on newtype) stands, unless there are convincing reasons to change it. "
11:38:45 <byorgey> I think single-field existentially quantified constructors are perfectly useful, especially when a GADT is involved.
11:39:05 <elliott> existential newtypes being unsound seems like a better reason.
11:39:29 <elliott> (FSVO unsound, of course)
11:39:39 <monochrom> yikes, how to see that it is unsound?
11:40:35 <applicative> forall s . Stream (s,s -> Maybe (a,s))
11:40:49 <elliott> monochrom: newtype Oops a = forall n. Oops (Vec n a)
11:41:01 <elliott> monochrom: there exists a value (Oops v) for which v does not have the type Vec n a for any n :: Nat
11:41:26 <elliott> exercise: write this or ask dolio for it, I chose the latter :P
11:43:17 <monochrom> but does "data Opa a = forall n. Opa (Vec n a)" suffer the same problem?
11:43:38 <elliott> monochrom: no.
11:43:46 <elliott> it relies on newtype constructor matches being irrefutable
11:43:59 <ReinH> hai
11:44:04 <elliott> oops = Oops (Cons () yikes) where Oops yikes = oops
11:44:06 <elliott> ^ should do it.
11:44:15 <elliott> or oops = fix (\(Oops yikes) -> Oops (Cons () yikes))
11:44:19 <applicative> ReinH: hi!
11:44:24 <elliott> monochrom: if you do that with the data version, you just get _|_
11:44:25 <elliott> which is OK.
11:44:25 <ReinH> applicative: :)
11:45:02 <Gracenotes> elliott: what do you get from those?
11:45:16 <Gracenotes> how does unsoundness manifest itself
11:45:18 <elliott> you get an infinite Vec.
11:45:30 <Gracenotes> so heap asplosion?
11:45:39 <elliott> it should work out at runtime.
11:45:43 <elliott> the problem is the type system doesn't make any sense.
11:45:55 <dmwit> can you not fix (\~(Oops yikes) -> Oops (Cons () yikes)) for the data one?
11:46:03 <Gracenotes> oh, I see what you mean about 'for any n :: Nat', if Nat is data (rather than codata)
11:46:12 <elliott> Nat is a kind.
11:46:15 <Gracenotes> I suppose it's type-level anyway
11:46:15 <elliott> here, you don't even need data kinds though
11:46:18 <elliott> just use data Z; data S n
11:46:23 <elliott> there are no infinite types, yet it should have type n = S n
11:46:50 <elliott> dmwit: I don't believe so, but I don't immediately see why not.
11:47:09 <elliott> dmwit: perhaps irrefutable matches on existentials are restricted
11:47:11 <elliott> like they are on GADTs
11:48:34 <monochrom> I see how it's a FSVO :)
11:48:55 <dmwit> fix (\v -> Oops (case v of Oops yikes -> Cons () yikes)) -- seems not to require an irrefutable match
11:49:26 <dmwit> Oh, perhaps that's a type error, though.
11:49:36 <dmwit> Because the existential escapes the case.
11:49:58 <elliott> monochrom: if you're not disturbed by being able to do (case foo of Oops v -> ...) and get v :: Vec n a that corresponds to no actual type n (and indeed an attempt to construct this type is rejected by the compiler), then I don't know what scares you.
11:50:20 <elliott> certainly I don't know how you interpret existentials if you're allowed to do such nonsense
11:51:12 <monochrom> I am only scared by provable contradictions.
11:52:57 <monochrom> this is not so much "no actual type" as "is actual type but inexpressible in the given type language, and is hidden away anyway"
11:53:16 <c_wraith> My implementation of the function I'm writing is unsafeCoerce anyway.
11:53:34 <c_wraith> I just wanted to avoid the overhead of the data constructor.
11:54:08 <c_wraith> Man, once you start doing type-level programming in haskell, you go to the dark side fast.
11:54:17 * dmwit thinks of that email about infinite types. Nothing wrong with them except that a lot of errors go undetected if you allow them.
11:54:26 <monochrom> to derive a contradiction from that, you need to add the artifical meta-rule "every type is expressible in the given type language"
11:54:45 <tikhon> OCaml actually supports infinite types (although with a flag, I believe)
11:54:46 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
11:55:53 <tikhon> I think people largely don't use them for the same reasons outlined in that email
11:56:57 <tikhon> in fact, in their documentation, they have a very similar example for why rectypes are dangerous :)
11:57:52 <c_wraith> Recursive newtypes let you approximate infinite types.
11:58:03 <dmwit> Yes.
11:58:12 <tikhon> it's a bit awkward, but worth the added safety
11:58:55 <monochrom> my favourite infinite type: newtype US_economy money = Ctor (money -> US_economy) :)
11:58:57 <Gracenotes> does kind-level Fix give you general recursion? ...I'm not sure if that makes sense.
11:59:29 <Gracenotes> both value-level and type-level do.
12:00:29 <Gracenotes> no, that doesn't make any sense to me.
12:00:56 <monochrom> http://okmij.org/ftp/Computation/fixed-point-combinators.html
12:05:19 <c_wraith> Holy crap, I just realized what I'm doing.  This should even work - and that terrifies me.  If I do get this working, it deserves to be shared.
12:05:45 <diabel232> is haskell good for someone who wants to learn programming
12:05:50 <diabel232> i mean good for first language
12:05:53 <diabel232> as*
12:05:56 <tikhon> yeah, I think so
12:06:02 <S11001001> diabel232: sure
12:06:06 <diabel232> many people tell me its bad difficult and leave it!
12:06:17 <alexander__b> diabel232: depends on background and intentions, I think, but generally: yes.
12:06:17 <tikhon> calumny
12:06:21 <monochrom> many people have prejudices
12:06:28 <Spion_> I've been told its especially good for people with a math background
12:06:43 <alexander__b> diabel232: haskell is a general-purpose language, so you should be able to get along with it regardless of your intentions though.
12:06:45 <tikhon> if anything, Haskell is *easier* to learn if you don't have any programming experience
12:06:53 <tikhon> you don't have to unlearn anything
12:07:04 <diabel232> ill stick with haskell then
12:07:09 <diabel232> i find that yesod is amazing
12:07:11 <tikhon> that's the spirit!
12:07:18 <monochrom> many people also say that you must memorize the multiplication table
12:07:45 <monochrom> many people say what to learn based on what they themselves were forced to learn.
12:08:04 <tikhon> heh, I'm the opposite
12:08:09 <roconnor> I recommend learning Coq before Haskell.  That is what I did.
12:08:11 <tikhon> I started out with JavaScript and Perl
12:08:17 <tikhon> don't start with JavaScript or Perl!
12:09:14 <diabel232> i wanted to learn ruby
12:09:21 <diabel232> but after i saw gems doing magic
12:09:30 <diabel232> with huge amonts of code that i dont understand
12:09:46 <diabel232> its better to learn something less complicated
12:09:54 <tikhon> yes
12:09:58 <diabel232> than building "lego applications"
12:10:35 <tikhon> and Haskell has a *very* simple core‚Äîa vestige of its mathematical roots
12:10:58 <tikhon> mathematicians‚Äîwith good reason‚Äîare obsesses with simplicity and elegance
12:11:41 <karatekid> tikhon: any thoughts on OCaml vs. Haskell?
12:11:46 <karatekid> oh, and hello :)
12:11:54 <tikhon> I still like Haskell more
12:12:07 <tikhon> but OCaml is alright‚Äîbetter than most of the alternatives
12:12:18 <tikhon> polymorphic variants are awesome
12:12:23 <tikhon> the object system... isn't
12:12:30 <tikhon> (although it's very good for an object system)
12:12:55 <tikhon> the module system is great but doesn't quite make up for the lack of typeclasses
12:13:05 <tikhon> the value restriction is evil
12:13:07 <tikhon> hmm
12:13:30 <tikhon> the syntax is a fair bit uglier
12:13:38 <tikhon> I think that covers most of my impressions on it
12:13:38 <diabel232> do i have feeling that more people are getting interested in haskell ?
12:13:46 <yesthisisuser> ocaml claims to be "object-oriented".. i don't really get that.. have never used it
12:13:51 <diabel232> on hackage number of packages is groowing very fast
12:14:04 <tikhon> it claims to be "object-oriented" because it has an object system with classes and stuff
12:14:07 <tikhon> just most people never use it
12:14:26 <S11001001> diabel232: you are the only one who can answer that :)
12:14:44 <tikhon> OCaml has structural typing
12:14:49 <tikhon> and, unlike Go, it doesn't suck
12:14:51 <tikhon> so there's that
12:14:51 <primitive> is the reason for the absence of the === operator in Haskell its strong typing system?
12:14:58 <tikhon> ===?
12:15:06 <primitive> strict equals, like in PHP or JS
12:15:08 <tikhon> as compared to JavaScript?
12:15:10 <primitive> yeah
12:15:12 <tikhon> yeah, the type system
12:15:19 <yesthisisuser> i wouldn't say "absence"
12:15:24 <kingugo> ghci > head [5 ,4 ,3 ,2 ,1]
12:15:24 <kingugo> 5
12:15:27 <tikhon> or, more accurately, the fact that we don't automatically coerce values between different types
12:15:31 <primitive> so basically, the == in Haskell is equivalent to === in weakly typed languages?
12:15:38 <tikhon> you could say that, yes
12:15:39 <mauke> primitive: not really
12:15:39 <kingugo> is hail the name and head the command?
12:15:52 <tikhon> except a program like True == "foo" won't even type
12:15:58 <roconnor> isn't there some unsafeComparePointerEquality in GHC?
12:16:03 <tikhon> where in most dynamically typed languages it would just evaluate to False
12:16:16 <yesthisisuser> you don't come across things like  if (a != true && a != false) { !!! }
12:16:19 <yesthisisuser> in haskell
12:16:30 <primitive> tikhon: ahh, I see
12:16:34 <tikhon> reallyUnsafePtrEq#
12:16:47 <tikhon> I think the name is very evocative
12:16:57 <S11001001> primitive: supposing both == and === could only be applied to values of same type in such other languages, would they still be different?
12:17:12 <primitive> S11001001: I think not, so that answers my question perfectly
12:17:14 <primitive> makes a lot more sense now
12:17:20 <karatekid> diabel232: i am trying to learn now :)
12:17:34 <diabel232> haskell or yesod?:)
12:17:44 <karatekid> diabel232: oh sorry, haskell
12:17:50 <monochrom> I am not convinced that === is about types.
12:18:06 <diabel232> with you luck! i will also keep learning haskell :)
12:18:13 <diabel232> monads lambdas etc :)
12:18:17 * hackagebot hfann 0.4.2 - Haskell binding to the FANN library  http://hackage.haskell.org/package/hfann-0.4.2 (DavidHimmelstrup)
12:18:26 <yesthisisuser> === feels like something that was added to the language because people were complaining about relaxed type safety
12:18:57 <mauke> === is something that was added to the language because people didn't understand perl
12:19:17 <S11001001> yesthisisuser: or maybe wanted an equality that's actually symmetric and transitive
12:20:30 <tikhon> well, symmetric *most* of the time
12:20:50 <mauke> > 0/0 == 0/0
12:20:52 <lambdabot>   False
12:20:58 <tikhon> yeah
12:21:17 <tikhon> I always get the words "symmetric" and "reflexive" confused
12:21:17 <S11001001> no accounting for taste
12:22:01 <tromp_> > 1/0 != 1/0
12:22:02 <lambdabot>   Not in scope: `!='
12:22:02 <lambdabot>  Perhaps you meant one of these:
12:22:02 <lambdabot>    `!' (imported from D...
12:22:05 <yesthisisuser> i also confuse symmetric and reflexive sometimes
12:22:07 <tromp_> > 1/0 \= 1/0
12:22:08 <lambdabot>   Not in scope: `\='
12:22:08 <lambdabot>  Perhaps you meant one of these:
12:22:08 <lambdabot>    `/=' (imported from ...
12:22:11 <tromp_> > 1/0 /= 1/0
12:22:12 <lambdabot>   False
12:22:17 <tac> tikhon: reflexive from reflection... when you look back on yourself and how much you've embarrassed yourself.
12:22:26 <tromp_> > 1/0 == 1/0
12:22:27 <lambdabot>   True
12:22:53 <tac> tikhon: symmetric means it looks the same in a mirror:    x R y      | <-mirror  y R x
12:23:16 <tikhon> I think using "mirror" in both mnemonics is doomed
12:24:12 <yesthisisuser> hmm... mirror . reflection. i think that is how the confusion started for me
12:24:47 <tac> maybe think of the Duran Duran song, The Reflex
12:25:10 <tac> Since Duran appears twice in the name, you can remember Duran R Duran... ah, reflexivity is when a relation holds for itself :)
12:25:16 <yesthisisuser> aah.. duran duran.. like aRa ..
12:25:29 <tac> http://www.youtube.com/watch?v=oDnNF5cHCdo
12:26:53 <yesthisisuser> duran~duran forall duran in X
12:35:11 <enthropy> what's a recommended way to add a finalizer to a Ptr (), when the free_ function I have refers to another pointer (which I'm holding onto as a ForeignPtr too)?
12:36:30 <Cale> enthropy: That's the difference between a Ptr and a ForeignPtr, the latter can have a finalizer.
12:36:49 <tac> it's also worth noting that in dependently-typed languages, the constructor for equality types is almost always called "refl" (short for reflexivity)
12:37:14 <tac> and that the other properties (symmetry and transitivity) are theorems you can prove about paths by pattern-matching on refl.
12:37:30 <enthropy> Cale: I'm not sure if I need to copy the contents of that "environment" which is needed to decide how to free the pointer
12:37:51 <enthropy> since that "environment" could get freed earlier I suppose
12:38:18 * hackagebot buildwrapper 0.7.4 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.4 (JeanPhilippeMoresmau)
12:39:10 <kingugo> fst ( " Wow " , False ) works, does it mean that he head functin doesnt work in list of strings like head ["he", "she"]
12:39:29 <mr-> hmm?
12:39:36 <mr-> > head ["he", "she"]
12:39:37 <lambdabot>   "he"
12:39:46 <mr-> it works! ;-)
12:39:58 <kingugo> ow, it didnt work on my ghc
12:40:05 <kingugo> let me try that again. thanks
12:41:55 <kingugo> mr-: i get it
12:42:04 <c_wraith> holy crap, this works.  I'm kind of in a state of shock.
12:42:11 <mr-> nice :-)
12:42:23 <kingugo> > fst ( " Wow " , False )
12:42:24 <lambdabot>   " Wow "
12:42:31 <kingugo> works but not
12:42:45 <kingugo> > head ( " Wow " , False )
12:42:46 <lambdabot>   Couldn't match expected type `[a0]'
12:42:46 <lambdabot>              with actual type `([GHC.Ty...
12:42:56 <kingugo> instead, its
12:43:02 <kingugo> > head ( " Wow " , "False ")
12:43:03 <lambdabot>   Couldn't match expected type `[a0]'
12:43:03 <lambdabot>              with actual type `([GHC.Ty...
12:43:08 <kingugo> > head ( " Wow " , "False")
12:43:09 <lambdabot>   Couldn't match expected type `[a0]'
12:43:09 <lambdabot>              with actual type `([GHC.Ty...
12:43:22 <kingugo> > head [ " Wow " , "False"]
12:43:23 <lambdabot>   " Wow "
12:43:47 <kingugo> > head [ " Wow " , False ]
12:43:48 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:43:48 <lambdabot>              with actual ty...
12:43:50 <mr-> Yes, head works on lists and fst on tuples
12:43:52 <mr-> :t head
12:43:54 <lambdabot> [a] -> a
12:43:55 <mr-> :t fst
12:43:55 <lambdabot> (a, b) -> a
12:44:02 <mr-> (two-tuples, specifically)
12:44:17 <kingugo> cool. thanks man
12:44:33 <mr-> sure
12:47:10 <FreeFull> What's the easiest way to output sound from a haskell program?
12:48:19 <shoret> FreeFull: portaudio has some simple examples
12:49:50 <FreeFull> shoret: Thanks
12:51:39 <eduardo__> hello, there
12:51:53 <FreeFull> shoret: It doesn't seem to have hackage documentation
12:51:54 <eduardo__> has anybody tried to install llvm bindings on ubuntu?
12:52:07 <bscarlet> which llvm bindings?
12:52:41 <eduardo__> actually i am trying to install a hackage package called "BASIC"
12:52:57 <eduardo__> and it depends on llvm-3.2.0.2
12:53:04 <bscarlet> sounds like lennart augustsson's stuff
12:53:09 <eduardo__> which depens on llvm-base-3.2.02.
12:53:29 <eduardo__> http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
12:54:09 <FreeFull> Ah
12:54:10 <sclv_> eduardo__: you can install whatever version of the llvm package matches your llvm
12:54:43 <FreeFull> This is weird
12:54:44 <eduardo__> I used apt-get to install llvm3.2
12:55:02 <eduardo__> the error I get is: llvm-base-3.2.0.2 failed during the configure step. The exception was:
12:55:03 <eduardo__> ExitFailure 1
12:55:15 <FreeFull> When I install it with cabal, I do get haddock documentation, but hackage doesn't have haddock documentation for it
12:55:37 <roboguy_> eduardo__: there was probably more error information before that
12:55:56 <geekosaur> but you may need to rerun with -v3 to get full information
12:56:43 <eduardo__> let me try
12:58:01 <eduardo__> http://lpaste.net/91343
12:58:41 <shoret> FreeFull: if i remember right, there's a really somple example in the examples dir that plays a Dr. Evil sample
12:58:50 <shoret> i'd start with that one
12:59:19 <bscarlet> eduardo__: does ubuntu have a separate dev package for llvm?
12:59:35 <geekosaur> Eduard_Munteanu, did you install the -dev package?
12:59:41 <geekosaur> er
12:59:56 <geekosaur> eduardo__, you need to install a separate -dev package
13:00:23 <geekosaur> you have the runtime installed, but debianoids and RHoids both split off devel headers and libraries into separate packages
13:00:58 <eduardo__> hmmmm
13:01:11 <eduardo__> Should I look for something like llvm-dev ?
13:02:03 <kingugo> snd (8 ,11)
13:02:11 <roconnor> 11
13:02:17 <kingugo> snd doest accept more than two values?
13:02:22 <tikhon> no
13:02:24 <geekosaur> nope
13:02:26 <tikhon> look at the type
13:02:27 <tikhon> :t snd
13:02:28 <lambdabot> (a, b) -> b
13:02:34 <sclv_> snd only takes one value!
13:02:41 <geekosaur> tuples in haskell are not variable length; every length tuple is a different type
13:02:43 <sclv_> it is just a value that happens to be a pair
13:02:51 <kingugo> sclv_: one or two?
13:03:02 <sclv_> (a,b) is the type of a single value
13:03:09 <geekosaur> kingugo, it is a single value which is a 2-tuple
13:03:13 <sclv_> that value happens to be a pair with two components
13:03:24 <eduardo__> geekosaur: I installed a package called "libghc-llvm-dev"
13:03:25 <kingugo> ok. got it
13:03:29 <FreeFull> > let x = (3,4) in  snd x
13:03:31 <lambdabot>   4
13:03:37 <eduardo__> geekosaur: it still won't work :(
13:04:03 <bscarlet> eduardo__: I'd be surprised if that were the right package.
13:04:57 <eduardo__> trying this one right now: "llvm-3.1-dev"
13:05:03 <FreeFull> If you would implement 2-tuples as a function, the function would be if'
13:05:04 <geekosaur> if you are using ubuntu's ghc package then that might get you a working haskell llvm package. if not, you have just confused your system pretty badly (in fact, even if you are, you may have just confgused thinsg badly)
13:08:03 <eduardo__> geekosaur: I have actually installed llvm-3.2.-dev
13:09:14 <eduardo__> geekosaur: i installed an older version of ghc
13:09:26 <geekosaur> that would have been sucked in by the libghc package as a dependency
13:09:48 <eduardo__> geekosaur: Languae.BASIC fails to build on ghc >6
13:14:17 <Entroacceptor> I'm using aeson and some data from Network.MPD. Now I want to combine two results of that. Is there a way to amend a json object with another field without writing the whole tojson instance myself (lots of fields)
13:15:13 <k00mi> Entroacceptor: maybe aeson-smart is what you want
13:15:30 <shoret> you could write a json object with 2 fields: the new field and the entire original object
13:16:49 <Entroacceptor> shoret: yeah, but that makes the json look ugly
13:18:05 <c_wraith> What does StorableArray's Storable instance do?
13:19:11 <c_wraith> Does it hold on to the Ptr it was given in peek, such that writeArray changes the memory it is pointing to?
13:19:16 <luite> Entroacceptor: ToJSON produces a Value, you can just pattern match a bit on that to add fields etc
13:20:31 <augur> Philippa: i think you broke conor
13:20:46 <Entroacceptor> luite: ah, I'll try
13:21:48 <luite> Entroacceptor: an object is a HashMap with Text keys, so that's not hard to work with
13:21:56 <Entroacceptor> thanks
13:23:31 <c_wraith> Oh.  It appears to not *have* a Storable instance.  That explains a bunch..
13:24:10 <RichyB> c_wraith, it just has a Storable constraint on its value type, right?
13:24:34 <c_wraith> RichyB: yeah.  As I look at the class more, it obviously can't work with things that are variable-size
13:26:35 <RichyB> Yeah. Also, (Storable a) has (sizeOf :: a -> Int), but I think it's supposed to be assumed that sizeOf (undefined :: a) is assumed to always work.
13:27:01 <vod1k> any good examples on how to properly handle partial parsing with attoparsec? Say continuously read data out of a socket and parse out messages?
13:27:35 <c_wraith> RichyB: yeah, that's how it's documented.  So you have to know the size from the type alone.
13:27:36 <vod1k> i know how to work the parser, but not sure how to deal with Partial
13:31:25 <c_wraith> Ok..  Is there a memcopy somewhere in the FFI?
13:33:08 <edwardk> RichyB: yeah, i kind of wish that function had been sizeOf :: p a -> Int -- but that convention wasn't known then
13:33:47 <RichyB> edwardk, what do you mean by "p a"?
13:33:54 <c_wraith> p is polymorphic
13:34:07 <edwardk> since you know nothing about p you can't use the argument for anything.
13:34:10 <edwardk> you can force it, thats it
13:34:34 <twomashi2> Anyone know how to write a function that puts something in a list if its not already a list? Using typeclasses?
13:34:38 <Gracenotes> or a Proxy, I've heard
13:34:42 <RichyB> c_wraith, er, I think so. Foreign.Marshal.Array perhaps.
13:34:58 <edwardk> when you are accepting a proxy argument, by taking a polymorphic wrapper rather than an explicit Proxy type you allow the user to pass you any one he has in any wrapper.
13:35:08 <zzing> I am having an error that I am unable to figure out in https://gist.github.com/iaefai/d62f86ed9f88cda67346   It says (line 29) 'Opinion' is applied to too many type arguments. I am sure it is a simple problem, but no real idea on how to solve.
13:35:15 <dmwit> twomashi2: Can you give a few examples of input/output pairs?
13:35:18 <edwardk> Gracenotes: i prefer to return Proxy's in positive position and always accept them as polymorphic arguments in negative position
13:35:25 <edwardk> it makes the api nicer to use
13:35:31 <c_wraith> RichyB: ah, perfect.  Thanks
13:35:37 <twomashi2> dmwit: 1 -> [1], but also, [1] -> [1]
13:35:44 <edwardk> because you often find unexpected opportunities to just use some value you have in scope directly
13:36:05 <dmwit> zzing: The Opinion type constructor doesn't take any type arguments.
13:36:13 <dmwit> zzing: So just use Maybe Opinion as the return type.
13:36:40 <zzing> dmwit, ok, what is the difference between a data Opinion a =  ‚Ä¶  and data Opinion = ...
13:36:49 <dmwit> twomashi2: That is hard to do correctly. However, I suspect this is an XY problem.
13:37:17 <RichyB> c_wraith, oh I was off a bit, it's http://www.haskell.org/ghc/docs/7.6.3/html/libraries/base-4.6.0.1/Foreign-Marshal-Utils.html#g:6
13:37:31 <edwardk> newtype M a s = M { runM :: a }; data Monoid_ a = Monoid_ { mempty_ :: a, mappend_ :: a -> a -> a }; instance Reifies s (Monoid_ a) => Monoid (M a s) where mappend a b = M (mappend_ (reflect a) (runM a) (runM b)); ...
13:37:40 <edwardk> that works because M a s can be used as p s directly
13:37:52 <Gracenotes> edwardk: makes sense
13:37:54 <joelteon> has anybody here ever stumbled across a library that allows you to manipulate Lunix IP routing tables
13:38:04 <joelteon> I found iproute but that's for simulating a routing table, not modifying the system one
13:38:13 <edwardk> Which lets you call    reflect :: Reifies s a => p s -> a
13:38:17 <dmwit> zzing: In "data Opinion a = ...", the Opinion data-type is parameterized on another type, and the "..." may use "a".
13:38:45 <zzing> dmwit, can Opinion be defined with multiple additional types?
13:39:03 <RichyB> OH
13:39:04 <c_wraith> RichyB: the copyArray stuff is actually a better fit for what I'm doing anyway.
13:39:14 <dmwit> twomashi2: (In other words, to get good advice about how to proceed, you should describe the slightly higher-level problem that you are trying to solve. Perhaps the solution you are thinking of that requires the given function has a more idiomatic alternative.)
13:39:22 <dmwit> zzing: Yes.
13:40:19 <zzing> dmwit, am I seeing the difference between a type constructor and a data constructor here?
13:40:46 <RichyB> edwardk, so you'd have something like, data MCHammer a = CannotTouchThis; somewhere, and sizeOf :: p a -> Int, then call it like sizeOf (CannotTouchThis :: MCHammer Int) -- ?
13:41:28 <NemesisD> ghc's garbage collector is stop-the-world right?
13:41:31 <dmwit> hard to say what you're seeing =)
13:41:57 <n-dolio> Parts of it are.
13:42:03 <dmwit> RichyB: You might even have data MCHammer a where CannotTouchThis :: MCHammer Int so that you don't need the type annotation when calling sizeOf. =)
13:42:26 <RichyB> dmwit, ooh, another nice use for GADTs. ;)
13:42:50 * geekosaur points out that Can'tTouchThis is a perfectly valid identifier :p
13:43:00 <twomashi2> dmwit: Ok :) under normal circumstances I wouldnt want a function like this.. im just making a command line wrapper that takes a haskell expression, and compiles it behind: interact . (userFunc) . lines. For convenience sake I'd like to support returning both a list or a single value.
13:43:03 <RichyB> It is? Huh.
13:43:37 <c_wraith> ' being final is a convention, not a language restriction
13:43:39 <twomashi2> (ie it's like awk but compiles a haskel expression then runs it)
13:43:58 <dmwit> twomashi2: I think you should treat those two cases separately, and not try to mash them together.
13:44:03 <tikhon> how would you want it to handle strings?
13:46:06 <dmwit> data MCSpammer a where CannedTouchThis :: MCSpammer Ham
13:46:43 <Entroacceptor> dmwit--
13:46:54 <dmwit> :3
13:47:21 <n-dolio> DISPLAY 3 cannot be reached.
13:47:39 <twomashi2> dmwit: probably I should heh
13:48:01 * dmwit feeds n-dolio a magic cookie
13:58:28 <c_wraith> There.  size-typed multidimensional arrays with Storable instances.
13:58:42 <c_wraith> Only minor use of unsafeCoerce.  No problem!
13:59:46 <c_wraith> (only works on GHC 7.6 or higher)
14:00:13 <nabilhassein> do any of you have experience with hsenv? is it a more modern version of virthualenv?
14:01:02 <shoret> hsenv rocks
14:01:08 <geekosaur> hsenv is the successor to (and effectively 2nd major version of) virthualenv
14:01:28 <nabilhassein> i've been having trouble with the emacs mode for hsenv
14:01:34 <geekosaur> I think they got tired of it being confused with the python virtualenv or something
14:01:40 <nabilhassein> i tried looking at hsenv.el myself but i'm not much of an elisp hacker
14:02:21 <nabilhassein> i get the problem "directory foo does not does not contain any hsenv."
14:02:31 <nabilhassein> when it does, and everything loads up at the command line with no problem
14:03:49 <nabilhassein> it's here if anyone wants to take a look: https://github.com/Paczesiowa/hsenv/blob/master/hsenv.el
14:04:25 <levi> I've had bad luck lately with emacs packages that deal with alternative paths and such.
14:08:34 <enthropy> c_wraith: I think copumpkin is neglecting a library that does that (wrapping Vector... which has Storable versions too)
14:09:32 <enthropy> https://github.com/copumpkin/vector-static
14:18:08 <JoeyA> How do you make a cabal test-suite that can access internal modules of the package being tested?
14:18:42 <Clint> can you?
14:18:43 <dcoutts> JoeyA: list them as extra-modules for the test-suite, rather than depending on the library in the build-depends
14:18:43 <JoeyA> The warp package does it.  I'm pretty sure I'm doing the exact same thing in my package, but I still get a "member of the hidden package" error.
14:19:18 <dcoutts> Clint: you can do it either way, import the modules direct, or depend on the lib (so only via its external interface)
14:19:39 <JoeyA> dcoutts: makes sense, but warp somehow gets by without doing that.
14:19:46 * dcoutts doubts it
14:20:06 <JoeyA> http://hackage.haskell.org/packages/archive/warp/1.3.9/warp.cabal
14:20:26 <JoeyA> I'm trying the "Hs-Source-Dirs:  test, ." trick
14:21:01 <dcoutts> JoeyA: it's doing exactly what I suggested you do
14:21:14 <JoeyA> I don't mind using extra-modules, but I don't get how warp is doing it.
14:21:28 <JoeyA> warp.cabal doesn't have an extra-modules list
14:21:35 <dcoutts> warp isn't specify the extra-modules, though strictly speaking that's wrong
14:21:51 <JoeyA> Maybe it's because I'm using hsc2hs
14:21:57 <dcoutts> that'd do it
14:22:12 <JoeyA> Thanks
14:22:26 <twomashi2> how do you check if the return type of a function is a list in templatehaskell
14:22:27 <dcoutts> JoeyA: all components are supposed to list all their modules
14:22:42 <dcoutts> JoeyA: it's not checked however, and the consequences of not doing so vary
14:23:12 <dcoutts> JoeyA: it'll always fail for libs (when linking dependent things), fail for exes during sdist, fail if there are pre-processors involved
14:23:37 <dcoutts> JoeyA: warp gets away with it because all the modules are already listed in the lib, so the sdist does not fail
14:23:49 <dcoutts> one day we'll actually check this properly and enforce it
14:24:18 <JoeyA> By the way, I'm working on an I/O manager for Windows using completion ports.  Anyone want to test it?  I have a modified network package that uses IOCP for connect, accept, send, and recv.  Only Vista and later are supported right now.
14:24:25 <dcoutts> awesome
14:24:55 <JoeyA> It can be tested with GHC 7.6.  It's a standalone library: https://github.com/joeyadams/hs-windows-iocp
14:25:12 <JoeyA> The core of the functionality is here: https://github.com/joeyadams/hs-windows-iocp/blob/master/IOCP/Manager.hsc
14:25:29 <JoeyA> Please review while the code is easy to read.  Windows XP will need an awkward workaround.
14:25:48 <JoeyA> Namely, send the I/O request to a worker thread, start it from there, and (if needed) cancel it from there.
14:25:50 <maltem> quchen: Good news, I sort-of fixed the leak. Amazingly, one of the central issues was that I was using a custom Ratio type; switching to Data.Ratio really did something. Perhaps some funny issues with inlining.
14:26:06 <dcoutts> JoeyA: what's the XP issue?
14:26:25 <JoeyA> dcoutts: XP doesn't have CancelIoEx, just CancelIo
14:26:31 <dcoutts> ah
14:26:38 <JoeyA> CancelIo cancels all pending I/O on a given handle by the current thread.
14:26:44 <dcoutts> could you just not support cancelling for XP?
14:27:36 <JoeyA> dcoutts: I have an application that currently runs on XP, and needs to support cancellation (so I can keep trying to connect to the server without leaking OS threads).
14:27:42 <JoeyA> CancelIoEx cancels a specific I/O action, and can be called from any thread.
14:27:46 <dcoutts> hmm
14:28:05 <dcoutts> JoeyA: it's quite a high price to pay for the feature
14:28:08 <JoeyA> Cancellation aside, XP has another quirk: all I/O issued by a thread is cancelled on thread exit.
14:28:16 <dcoutts> gah
14:28:35 <JoeyA> On Vista and later, it still does that, but not for IOCP.
14:28:50 <dcoutts> JoeyA: how is the performance / scaling, compared to standard IO manager?
14:28:56 <JoeyA> So basically, Windows Vista rocks, and people just don't know it ;-)
14:29:00 <dcoutts> :-)
14:29:16 <JoeyA> I haven't tested scaling.  I was hoping someone with acme-pong experience would do that bit for me :-)
14:29:21 <dcoutts> :-)
14:29:27 * dcoutts suggests a blog post
14:29:33 <dcoutts> JoeyA: nobody is surprised that XP sucks :-)
14:29:56 <dcoutts> 10 years is a long time in kernel development
14:30:09 <JoeyA> As far as performance on XP (I've implemented the XP workaround before, but have since rewritten the code), each I/O request takes about 30 microseconds.
14:30:18 <JoeyA> But when lots of threads are involved, that might be amortized.
14:30:41 <dcoutts> JoeyA: ie the worker threads are shared
14:30:44 <JoeyA> Since it could dequeue a bunch of completions at once (unless the RTS immediately schedules the receiving thread after a putMVar)
14:31:01 <JoeyA> Does it?
14:31:28 <dcoutts> JoeyA: oh, I was asking, since you said you have to issue all the IOs on a separate thread, due to the cancel malarky
14:31:40 <JoeyA> Also, threadDelay is similarly expensive.  Maybe not with the parallel I/O manager, but with 7.6, it's about as bad as what I'm proposing.
14:32:14 <JoeyA> But the XP workaround doesn't necessarily require two context switches.
14:32:22 <JoeyA> The worker thread can be the same as the completion handler thread.
14:32:30 <dcoutts> mm
14:32:52 <JoeyA> Err, more than two.  App -> IO manager -> App
14:33:25 <JoeyA> But right now, I'm just focusing on Vista and later.  I want XP support to be the awkward afterthought.
14:33:57 <JoeyA> Also, I don't plan to support non-threaded RTS.
14:34:09 <JoeyA> I suppose I could, by using a small timeout in GetQueuedCompletionStatus.
14:34:37 <dcoutts> right
14:34:38 <JoeyA> But the XP workaround wouldn't be possible unless all of the bindings are in C, which would make it hard to write bindings.
14:34:43 <dcoutts> no, I wouldn't bother either
14:34:52 <dcoutts> anyone interested in servers will be using the threaded rts
14:35:04 <JoeyA> I'm interested in clients.
14:35:10 <kingugo> whats the difference between zip and ++ or :?
14:35:20 <dcoutts> JoeyA: well, that too
14:35:32 <dcoutts> it already switches IO manager depending on the RTS
14:35:37 <dcoutts> it's fine to do that
14:35:51 <JoeyA> With the current I/O manager, I can't interrupt recv, making it very difficult to implement programs that need to run for long periods of time.
14:36:02 <JoeyA> My app currently uses socket timeouts (see my network-socket-options package).
14:36:12 <dcoutts> JoeyA: I'd definitely recommend a blog post and ask people to try the various benchmarks
14:36:41 <kingugo> 5: [2,3]
14:36:47 <kingugo> > 5: [2,3]
14:36:49 <lambdabot>   [5,2,3]
14:36:50 <xico> hi
14:36:51 <JoeyA> Perhaps.  I'm just not sure how I want to release it.  I'm currently thinking a windows-iocp package (just the I/O manager) and a modified version of the network package.
14:37:10 <JoeyA> Putting the network ops in a separate package would make it harder to use.
14:37:10 <kingugo> > 5 ++ [2,3]
14:37:11 <lambdabot>   No instance for (GHC.Show.Show a0)
14:37:12 <lambdabot>    arising from a use of `M1686240954.sh...
14:37:14 <xico> can anyone suggest a nicer version of: foldM (const . f) i [1..i]
14:37:18 <c_wraith> enthropy: I took a *far* simpler approach than that. My only real concern is being a useful tool for making FFI bindings for multidimensional arrays. :)
14:37:30 <xico> (ouch i mean different is)
14:37:32 <kingugo> zip 5 [2,3]
14:37:36 <RichyB> kingugo, the differences are mentioned in the types.
14:37:37 <xico> foldM (const . f) i [1..n]
14:37:43 <dcoutts> JoeyA: can do it differently for an initial test vs a later release. Ideally later we just integrate it into base, like the other IO managers
14:37:49 <kingugo> > zip 5 [2,3]
14:37:50 <lambdabot>   No instance for (GHC.Show.Show a0)
14:37:50 <lambdabot>    arising from a use of `M1759044725.sh...
14:37:55 <RichyB> kingugo, (:) :: a -> [a] -> [a], so
14:37:58 <JoeyA> dcoutts: also, I need to fix a potential bug in my current design, and learn a bit about IOCP's concurrency value.
14:38:01 <RichyB> > 1 : [2, 3]
14:38:01 <lambdabot>   [1,2,3]
14:38:13 <RichyB> kingugo, (++) :: [a] -> [a] -> [a], so:
14:38:18 <dcoutts> JoeyA: good luck, gotta dash
14:38:25 <RichyB> > [1, 2] ++ [3, 4]
14:38:26 <lambdabot>   [1,2,3,4]
14:38:27 <JoeyA> Thanks for the help!
14:38:35 <enthropy> c_wraith: I think hmatrix has some stuff like that. How does your approach compare?
14:38:41 <quchen> maltem: Sounds legit. Ratio is strict in the numerator/denominator.
14:38:42 <tac> > [1, 2] <> [3, 4]
14:38:42 <RichyB> kingugo, and zip :: [a] -> [b] -> [(a, b)], so
14:38:43 <lambdabot>   [1,2,3,4]
14:38:49 <quchen> maltem: data  Ratio a = !a :% !a
14:38:53 <RichyB> > zip [1, 2] [3, 4]
14:38:54 <lambdabot>   [(1,3),(2,4)]
14:39:08 <arkeet> > zip [1,2] ['a','b']
14:39:09 <lambdabot>   [(1,'a'),(2,'b')]
14:39:18 <arkeet> > zip [1,2] ['a','b','c']
14:39:19 <lambdabot>   [(1,'a'),(2,'b')]
14:39:37 <bscarlet> kingugo: ++ appends one list to another of the same type, (:) tacks a new element onto the beginning of a list, and zip take two lists of different types and builds from them a new list of pairs of corresponding elements from the two lists.
14:39:38 <RichyB> kingugo, (:) puts one element on the front of a list. (++) appends one list to another list. zip creates a list of pairs from a pair of lists.
14:39:50 <kingugo> ok RichyB.  thanks
14:40:05 <kingugo> arkeet: why is c ommited?
14:40:05 <arkeet> liftA2 (,) also creates a list of pairs from a pair of lists. =(
14:40:17 <arkeet> kingugo: there's no corresponding element in the first list
14:40:19 <bscarlet> kingugo: nothing to pair it with
14:40:25 <maltem> quchen, when I strictified my datatype in the same way, there wasn't any effect. I'm too lazy to investigate that now
14:40:39 <c_wraith> enthropy: I've only got about a page of code, if you neglect the instances for each dimensionality. Pretty much as simple as can be. Everything except the stuff that *really* needs the size to be part of the type is only supported via a toStorableArray call
14:40:39 <arkeet> @src zip
14:40:39 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
14:40:40 <lambdabot> zip _      _      = []
14:40:49 <quchen> maltem: So how large are the systems you can handle now?
14:41:19 <kingugo> wow. got it. they are quite different from each other. thanks guys
14:42:29 <maltem> quchen, the one that was problematic before was 1260◊1260
14:42:47 <quchen> maltem: Oh, I thought it was around 100*100 already
14:43:02 <maltem> yeah, initially :)
14:43:54 <maltem> the 1260 one was the "next step" of problematic systems
14:57:56 <zRecursive> `cabal configure` reports "cabal: At least the following dependencies are missing: aeson -any, happstack-server -any, libmpd -any", can cabal install those dependencies automatically ?
14:58:21 * hackagebot angel 0.4.4 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.4.4 (MichaelXavier)
14:58:44 <Clint> zRecursive: what do you mean by "automatically"
14:59:37 <geekosaur> I think if you use `cabal configure` you're telling it not to operate in automatic mode
14:59:37 <zRecursive> Clint: i hope `cabal build` can do it automatically
14:59:48 <geekosaur> `cabal install` would install them if possible
15:00:01 <ocharles> mm_freak: I have a bouncing ball with a collision counter!
15:00:07 <hpaste> ocharles pasted ‚ÄúBouncing collisions‚Äù at http://lpaste.net/91346
15:00:15 <geekosaur> but if you're running individual targets then you are asserting to it that you're handling stuff yourself
15:00:21 <ocharles> I dunno if that ^ is any more idiomatic, but it feels less mad :)
15:00:51 <zRecursive> geekosaur: Can `cabal install` work for local app?
15:01:03 <zRecursive> not in hackage
15:01:03 <geekosaur> I have no idea what you just asked
15:01:17 <ocharles> zRecursive: cabal install can take file paths and archives to install
15:01:22 <geekosaur> `cabal install` with no package named and a *.cabal file in the current directory will follow dependencies, yes
15:01:23 <ocharles> and maybe even urls
15:01:35 <zRecursive> yhx
15:01:37 <zRecursive> thx
15:04:16 <Luser> Hey guys.
15:06:02 <Luser> I was wondering- I am 22 yo at the moment and I am currently learning RoR so i can apply for a new job. The thing is - I've found haskell and yesod in the internet and I started considering if choosing haskell wouldn't be a better thing. What do you guys think? Should I start with it or is it too late?
15:07:00 <Neqoxec> too late? as in you can't learn new things anymore? are you the guy from memento?
15:07:35 <NemesisD> anyone know of a simple library for doing inline, typesafe templating? I need to generate a multiline email with some string interpolation
15:07:45 <NemesisD> it looks like interpolatedstring-qq doesn't build anymore
15:08:04 <geekosaur> Luser, I started learning Haskell at age 43
15:08:20 <Luser> Well I didn't say what I exactly mean correctly, sorry.
15:08:42 <Luser> The thing is I am working as an IT helpdesk atm, and I want to start working as a programmer asap.
15:09:15 <Luser> And I'm just wondering which option is better and will allow me to start coding usefull things faster.
15:09:21 <NemesisD> hmm looks like "here" might be good
15:09:32 <JoeyA> Luser: can you program in any other language yet?
15:09:53 <elliott> if your goal is solely to get a job then ruby on rails is probably much better.
15:09:55 <Luser> I know basics of python and ruby.
15:10:35 <Luser> Well it's obviously not only about the job, but I need money to live.
15:10:40 <quchen> What elliott said.
15:10:55 <NemesisD> i can attest to that. at work i'm a ruby on rails developer and people are feverishly trying to source rails devs of varying skillsets
15:11:13 <Luser> K, that's the answer I was looking for.
15:11:16 <JoeyA> Ruby will probably be more comfortable, then, and it'll be easier to find a job.
15:11:42 <Nisstyre> JoeyA: only if you use Rails prolly
15:11:45 <NemesisD> a caution: spend enough time coding in haskell and you'll get the reputation at work as the aloof haskell programmer
15:11:48 <Nisstyre> there aren't too many non-rails ruby jobs
15:12:06 <NemesisD> also you will begin getting frustrated at all the problems you run into that you know haskell would prevent
15:12:18 <Nisstyre> NemesisD: I wrote one 1000 line program at work and I have that rep, though there is another guy who's been there longer who did the payment system in Haskell
15:13:09 <JoeyA> I'm a Haskell programmer that might be getting a .NET job soon, so I might get to experience that frustration.
15:13:23 <Luser> I won't stop on learning one language, that can not happen, but as I said, got to find better paid job and I want to work as a programmer.
15:13:29 <Nisstyre> JoeyA: F# perhaps
15:13:31 <Luser> Ha :).
15:13:31 <RichyB> They have this thing called F#. ;)
15:13:32 <NemesisD> Nisstyre: unfortunately it is just irresponsible for me to write critical systems in haskell here. reduces the bus number to 1 and means i'm the only one who can work on it
15:13:53 <Nisstyre> NemesisD: yeah, I'm going to rewrite that 1000 line program in Python or nodejs -_-
15:13:57 <Nisstyre> since I'm leaving in a month
15:14:00 <JoeyA> Right.  That's one thing I'm noticing.
15:14:08 <NemesisD> yeah pursue languages rigorously, trust me. theres a surprising number of crossover as far as useful skills you learn
15:14:14 <JoeyA> In the .NET world, Haskell is sitting politely in the back of the room.
15:14:21 <NemesisD> Nisstyre: oh man that's cold
15:14:29 <Nisstyre> NemesisD: no, I start school :P
15:14:33 <Nisstyre> it's of my own volition
15:14:49 <Nisstyre> well I will be working part-time, but remotely
15:14:51 <Nisstyre> and not often
15:15:01 <Nisstyre> so fuck maintaining it myself if they're hiring someone new
15:15:06 <NemesisD> you are part of the haskell master race, what are you doing writing stuff in javascript by choice
15:15:25 <Nisstyre> NemesisD: well, it'll prolly be Python, and it's so any noob can make changes
15:15:43 <Nisstyre> it will probably 1500 lines in Python, though
15:15:45 <Nisstyre> or more
15:15:52 <JoeyA> I did a little C# last week for the job I'm applying for.  I think the main thing I missed is Maybe.
15:16:02 <JoeyA> (it was a test)
15:16:07 <Nisstyre> JoeyA: catMaybes is so useful
15:16:21 <JoeyA> I missed being able to return Nothing to signal failure.
15:16:37 <Nisstyre> because you can just process a list of stuff that might fail, and then get only the stuff that didn't fail...
15:16:40 <Nisstyre> or an empty list
15:17:25 <NemesisD> returning Nothing to signal failure is only suitable if there's only 1 type of failure you can have and the calling function must handle it immediately
15:17:32 <JoeyA> Since C# doesn't have discriminated unions (a.k.a. sum types), you have to either throw an exception, return a bool and set an out parameter in the true case, or define your own Maybe class.
15:17:44 <Nisstyre> NemesisD: yeah, it's fairly common in the type of programs I write, though
15:17:54 <bennofs> I once wrote a curry function for python. curry(f)(1)(2)(3) would be the same as f(1,2,3). But it got unreadable very fast
15:17:54 <Nisstyre> NemesisD: there are special exception types if you want more
15:17:55 <JoeyA> Sure, you can emulate Maybe pretty nicely in C#, but it's not idiomatic.
15:18:23 <bennofs> javascript i mean
15:18:45 <Nisstyre> bennofs: python has partial application via functools.partial, so there's not much reason to curry functions other than if you are doing something odd
15:19:26 <startling> functools.partial sucks.
15:19:32 <Nisstyre> yeah but it's in the stdlib
15:19:45 <Nisstyre> Racket's (curry f a b) is much nicer
15:21:30 <Nisstyre> NemesisD: one thing I've noticed is that studying PLs in general makes you a lot more efficient at learning things, and not even just new PLs
15:21:46 <Nisstyre> it also prepares you to come up with solutions to difficult problems
15:22:41 <bennofs> What does PL mean?
15:22:58 <Nisstyre> programming language
15:24:24 <tortrot> so I am trying to learn a bit more about haskell by porting a small lib to it, I think there is probably an elegant syntactical solution for what I'm doing, the code works fine though- anyone wanna take a look? I'll throw it on lpaste
15:24:49 <hpaste> tortrot pasted ‚Äúregexerer‚Äù at http://lpaste.net/91347
15:24:56 <maltem> Nisstyre, it teaches you good acquaintance with frustration indeed
15:25:01 <JoeyA> Haskell has helped me understand C#'s IEnumerable.  When Intellisense gives me a giant signature when I type ".SelectMany(", I can whittle it down to the essentials and see that it's just concatMap.
15:25:10 <DanBurton> so is lpaste the new hpaste? What happened to hpaste?
15:25:28 <Clint> negligence
15:25:46 <maltem> Weren't it problems with the domain provider?
15:26:00 <maltem> It's the same software as before
15:26:05 <JoeyA> tortrot: function composition
15:26:10 <tortrot> basically how my c++ version works is you can do something like verEx.searchOneLine().startOfLine().find("http") etc etc, I want to do something that is a bit like that but don't really know how.
15:26:45 <NemesisD> tortrot: you have an opportunity to do a lot of function composition there
15:27:05 <hpaste> quchen annotated ‚Äúregexerer‚Äù with ‚Äúregexerer (use function composition!))‚Äù at http://lpaste.net/91347#a91348
15:27:33 <zzing> tortrot, something that has helped me in the past is consider how the data is being processed in each step
15:27:38 <NemesisD> let a = foo x; let b = bar a is the same as bar . foo $ x
15:28:02 <tortrot> so basically just doing it in reverse? wow. I was trying to do it the opposite order with no luck
15:28:06 <tortrot> initially.
15:28:39 <NemesisD> tortrot: well if you think about it: bar . foo $ x is bar (foo x)
15:29:14 <NemesisD> you get used to reading pipelines of composed functions from right to left
15:29:17 <roboguy_> tortrot: it would probably be easier if you flipped the arguments on those functions
15:29:53 <quchen> You'll get used to reading bidirectional pipelines too :-)   m >>= return . f
15:29:55 <tortrot> NemesisD: sure, I guess using nix has got my mind a bit stuck on left to right (:
15:30:19 <tortrot> roboguy_: why is that? would that let me remove the flip?
15:31:09 <Nisstyre> > (+1) . (*2) . (+5) $ 6
15:31:10 <lambdabot>   23
15:31:24 <Nisstyre> that would look ugly if compose went the other way I think
15:31:44 <roboguy_> tortrot: yeah, right now I count 5 flips that you would need
15:31:44 <Nisstyre> well, it doesn't matter for that
15:32:02 <roboguy_> tortrot: or, you could write it as an infix section
15:32:06 <Nisstyre> meh actually I guess it doesn't matter at all
15:33:22 <roboguy_> tortrot: for example (`possibly` "s") is the same as flip possibly "s"
15:33:57 <tortrot> roboguy_: yeah wow, that explains it. was racking my brain I suppose the argument order was my hangup. That is great! I was doing infix earlier as well, however, I was stuck on the no arg ones with trying to make it clean
15:34:23 <NemesisD> doesn't compose kind of go the other way with lens
15:34:41 <Nisstyre> > let (.) f g x = g (f x) in head . (*2) $ [1..10]
15:34:42 <lambdabot>   2
15:35:16 <Nisstyre> idk, does that seem easier to read?
15:35:29 <FreeFull> Nisstyre: If compose went the other way, you could do      6 & (+5) ¬∑ (*2) ¬∑ (+1)
15:35:42 <Nisstyre> FreeFull: yeah I guess
15:36:09 <Nisstyre> FreeFull: in my mind I place an invisible parameter to the right of the composed functions
15:36:16 <DanBurton> The reason it is "." is to look kinda sorta like the function composition operator from math, so it should also take args in the order that math does
15:36:18 <Nisstyre> thus the head . (*2) example looks weird
15:36:25 <Nisstyre> since it seems like I'm multipling a list by a number
15:36:45 <Nisstyre> DanBurton: I agree with that
15:37:25 <FreeFull> DanBurton: Some argue that function composition in math is the wrong way around
15:37:33 <FreeFull> And that function application should go like   (x)f
15:37:37 <Nisstyre> FreeFull: it isn't if you imagine a parameter on the right
15:37:43 <Nisstyre> then it's intuitive
15:37:51 <RichyB> import Control.Arrow (>>>) if you really hate it.
15:37:55 <Nisstyre> oh, postfix?
15:38:01 <Nisstyre> use Forth then :P
15:38:12 <DanBurton> But lenses sort of turn it backwards, to simulate OO-style programming
15:38:23 <DanBurton> > [1,2,3]^.to head.to (*2)
15:38:24 <RichyB> > ($ 5) $ (+1) >>> (*2) >>> (-1)
15:38:25 <lambdabot>   2
15:38:25 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> c))
15:38:25 <lambdabot>    arising f...
15:38:46 <Nisstyre> FreeFull: x(f) is just x f in postfix notation
15:39:06 <Nisstyre> which you can go insane with if you use Forth or Factor, or Joy even
15:39:13 <Nisstyre> the last one even has types
15:40:14 <RichyB> Oh, I forgot subtraction doesn't work in sections.
15:40:30 <RichyB> > ($ 5) $ (+1) >>> (*2) >>> (`subtract` 1)
15:40:32 <lambdabot>   -11
15:40:42 <quchen> > ($ 5) $ (+1) >>> (*2) >>> (subtract 1)
15:40:45 <lambdabot>   11
15:40:49 <FreeFull> RichyB: (`subtract` 1) is the same as (1-)
15:40:51 <quchen> subtract a b = b - a
15:40:53 <c_wraith> err.  `subtract` is never what you want. :)
15:41:02 <RichyB> Hahahaha *headdesk*
15:41:06 <c_wraith> > (1 -) 5
15:41:07 <lambdabot>   -4
15:41:19 <quchen> subtract is the least infixable function in Haskell by a huge margin. :-)
15:41:34 <quchen> (Another good entry to the hypothetical underhanded Haskell contest.)
15:41:44 <RichyB> Ooh
15:41:50 <c_wraith> > 5 `subtract` 1
15:41:51 <lambdabot>   -4
15:41:55 <c_wraith> totally what you expect!
15:42:33 <FreeFull> Someone should actually hold an underhanded Haskell contest
15:42:35 <RichyB> Guess you're supposed to read (subtract a b) as, "subtract a from b" rather than "a minus b".
15:42:56 <Nisstyre> > let ($) x f = f x in 4 ($ 2 (*))
15:42:57 <lambdabot>   Could not deduce (GHC.Num.Num a0)
15:42:57 <lambdabot>    arising from the ambiguity check for `...
15:43:06 <c_wraith> I feel bad about this unsafeCoerce
15:43:11 <Nisstyre> > let ($) x f = f x in 4 $ (2 $ (*))
15:43:12 <lambdabot>   8
15:43:26 <Nisstyre> sorry, my postfix is rusty
15:43:43 <c_wraith> But then I think a bit, and realize I'm doing more-or-less unchecked memory copying via the FFI, and realize that unsafeCoerce is not the unsafest part of the code.
15:44:11 <tortrot> woo I got it, whole lib is fixed to work with composition. Thank you thank you, it actually works. Pretty pumped because it is my first application in haskell that does anything which is somewhat useful!
15:45:31 <RichyB> c_wraith, wait, what?
15:46:13 <RichyB> unsafePerformIO I can understand the use of. When is unsafeCoerce ever useful in user-code?
15:46:26 <hpaste> c_wraith pasted ‚ÄúCurrent status‚Äù at http://lpaste.net/91349
15:46:47 <c_wraith> RichyB: I'm recovering the real type from an existential.
15:47:00 <djahandarie> RichyB, when you know the underlying representation for two things is the same and you want to avoid run-time overhead of doing work which essentially amounts to an id function.
15:47:08 <RichyB> I thought the sole purpose of unsafeCoerce was for compilers from higher-level languages like Cayenne into Haskell to be able to ask the Haskell compiler to take their word for it that the soundness of the following has already been checked out.
15:47:16 <c_wraith> RichyB: line 90 in that paste
15:47:51 <c_wraith> If you look at the list of extensions in use, it's clear that what I'm doing is barely haskell anymore.
15:48:30 <zzing> Do we have a simple library to render vectors graphics?
15:48:46 <c_wraith> zzing: is that what cairo does? (I actually don't know)
15:49:01 <levi> Yes, cairo does vector graphics.
15:49:03 <RichyB> c_wraith, it seems deeply ironic to have imported that many high-firepower type-system extensions and still end up with an unsafeCoerce in there anyway. :)
15:49:10 <zzing> c_wraith, to some level, not sure if it is simple
15:49:15 <zzing> I think we had a compositional one
15:49:58 <levi> There's Diagrams
15:50:04 <c_wraith> RichyB: The thing is, those extensions still don't add up to real dependent types. :)
15:50:16 <levi> Cairo is one of the many back-ends to Diagrams.
15:50:56 <RichyB> c_wraith, I don't understand how a MultiArray in that code could possibly have the same shape as a StorableArray. data MultiArray (dimensions :: k) e = forall i. MultiArray (StorableArray i e) -- shouldn't a MultiArray be represented in memory with a pointer-sized tag followed by a pointer to whatever struct a StorableArray is backed by?
15:51:24 <c_wraith> RichyB: I've tested everything except the Storable instance so far.  It all works.
15:52:07 <RichyB> How? There isn't a strictness or packing annotation to tell GHC that it can inline the SA's fields into the MA. o_O
15:52:38 <RichyB> Also, why is it not a newtype?
15:52:48 <c_wraith> It's not a newtype because it's existentially quantified
15:53:02 <c_wraith> and GHC doesn't support existentially quantified newtypes.  (If it did, it would be a newtype)
15:53:56 <c_wraith> RichyB: oh, and it works because I'm unsafeCoercing the whole MA, just the SA with an unknown index type to an SA with a known index type
15:54:07 <c_wraith> err, I'm *not* unsafeCoercing the whole MA
15:54:17 <Nisstyre> Is there a way to get rid of the parens here? http://ideone.com/ACZL3w
15:54:20 <RichyB> OH
15:54:24 * Nisstyre is experimenting with Haskell postfix
15:54:29 <RichyB> c_wraith, yes of course, that's really obvious now. Thank you.
15:54:50 <RichyB> I have no idea how I managed to miss the fact that you were unwrapping the MA constructor.
15:55:10 <c_wraith> Sometimes things like that..  you just skim over without noticing.  I know, I do it too. :)
15:55:51 <FreeFull> Nisstyre: I don't think you could
15:55:58 <Nisstyre> FreeFull: ah ok
15:56:16 <Nisstyre> FreeFull: yeah I see now
15:56:32 <Nisstyre> it would be the same with the normal $
15:56:38 <Nisstyre> except flipped around obviously
15:57:14 <c_wraith> Hmm.  I think I see how to get rid of that unsafeCoerce, but I'd need a GADT, and it would introduce some extra overhead.
15:57:23 <c_wraith> Still, it's worth trying.  More extensions!
15:57:29 <RichyB> Meh.
15:57:53 <RichyB> I think I can convince myself that it's safe from the (d -> i), (i -> d) fundep bijection.
15:58:33 <c_wraith> well, it's safe as long as the constructor is hidden.
15:58:40 <c_wraith> and the instances are all correct.
15:59:47 <c_wraith> Actually, even the GADT approach needs the MA instances to all be correct. But that's reasonable, I guess.
15:59:55 <Nisstyre> FreeFull: we need a -XPostfixFunctions extensions clearly
16:00:07 <Nisstyre> *extension
16:00:45 <RichyB> Please no.
16:01:15 <RichyB> We have enough syntax already. Just write expressions starting ($ value) instead. ;P
16:01:18 <Nisstyre> RichyB: that *was* a joke :P
16:01:31 <RichyB> Thank goodness.
16:01:50 <Nisstyre> although it wouldn't be any more crazy than ImplicitParams
16:03:00 <RichyB> ImplicitParams has one -really- useful use case. You can use it to write expressions in the REPL with holes in them to work out what types should be in the holes.
16:03:30 <quchen> RichyB: 7.8 comes with turbo holes!
16:03:47 <RichyB> :t (+ 5) . ?f . (`div` 2)
16:03:48 <lambdabot> parse error on input `?'
16:04:20 <quchen> RichyB: http://www.reddit.com/r/haskell/comments/10u7xr/ghc_head_now_features_agdalike_holes/
16:04:30 <RichyB> Dammit \bot. Oh well.
16:04:32 <RichyB> (+5) . ?f . (`div` 2) :: (?f::b -> c, Integral b, Num c) => b -> c
16:04:41 <Nisstyre> fair enough
16:05:07 <c_wraith> Hmm.  The GADT approach doesn't quite work the way I'd hoped.  Maybe for someone with significantly better type-fu than me.
16:05:17 <erisco> version of tail where tail [] = [] ?
16:05:34 <quchen> erisco: Type mismatch
16:05:38 <Nisstyre> erisco: there is a Safe library on hackage
16:05:40 <RichyB> quchen, oh fuck yes, that is *way* better.
16:05:40 <quchen> tail :: [a] -> a
16:05:51 <monochrom> @type tail
16:05:51 <lambdabot> [a] -> [a]
16:05:52 <RichyB> Er, sorry for the language.
16:05:55 <quchen> Oh.
16:05:57 <quchen> Woops.
16:06:02 <Tene> quchen: You're thinking of head.
16:06:11 <quchen> Tene: No, I wasn't thinking.
16:06:13 <quchen> Anyway, there's listToMaybe.
16:06:14 <monochrom> "you're thinking ahead" :)
16:06:24 <erisco> :t drop
16:06:25 <lambdabot> Int -> [a] -> [a]
16:06:25 <Nisstyre> > tailMay []
16:06:26 <lambdabot>   Not in scope: `tailMay'
16:06:29 <MrRacoon> monochrom: thats what i read
16:06:31 <erisco> drop 1 []
16:06:32 <Franciman> hey can I call a module ":+:" ?
16:06:32 <Nisstyre> hmm
16:06:44 <erisco> > drop 1 []
16:06:45 <lambdabot>   []
16:06:48 <Franciman> the haskell 2010 report says that it is a valid modid
16:07:19 <geekosaur> Franciman, depends, ghc derives filenames from module names and that filename would never fly on Windows
16:07:40 <Franciman> geekosaur but for example if I do
16:07:41 <Hafydd> ;
16:07:48 <Franciman> import Data.List as :+:
16:07:54 <Franciman> ghc says it's an error too
16:08:01 <Tene> > import Data.list as :+:
16:08:02 <lambdabot>   <hint>:1:1: parse error on input `import'
16:08:07 <quchen> Even if it's not an error, it's a very bad idea.
16:08:14 <erisco> > last []
16:08:15 <c_wraith> is there a subreddit for haskell code review?
16:08:15 <lambdabot>   *Exception: Prelude.last: empty list
16:08:20 <FreeFull> geekosaur: :+: would be a perfectly good filename on Linux
16:08:21 <pdxleif> If I wanted to be all "modern", I'd use traverse_ here instead of mapM_ ? - https://github.com/LeifW/yaml2owl/blob/master/src/Main.hs#L26
16:08:31 <erisco> quchen, you might have been thinking of last
16:08:35 <geekosaur> FreeFull, yes, and of course Linux is the only OS anyone uses?
16:08:47 <FreeFull> Linux only forbids  / and NUL
16:08:51 <quchen> erisco: No, I wasn't thinking.
16:08:52 <roboguy_> Franciman: why would you want to do that, though? is this just purely hypothetical?
16:09:02 <monochrom> no, modid -> { conid . } conid; conid -> large { small | large | digit | ' }. :+: is under consym not conid.
16:09:10 <RichyB> geekosaur, don't be silly. Lots of people are on BSD, or its baby cousin OS X. ;)
16:09:27 <Franciman> roboguy_ writing a Lexer for Haskell. I am writing an IDE for it. Will you try it when it's done :P ?
16:09:55 <MrRacoon> what would happen if we told lambda bot to generate an infinite list?
16:10:00 <pdxleif> I don't know if "cousin" is as accurate as "mutant hybrid".
16:10:05 <Franciman> damn monochrom thanks :P
16:10:10 <Franciman> I didn't notice it
16:10:11 <dmj> MrRacoon: it would explode
16:10:19 <dmj> > [2..]
16:10:22 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
16:10:22 <Tene> > repeat "loop"
16:10:22 <lambdabot>   ["loop","loop","loop","loop","loop","loop","loop","loop","loop","loop","loo...
16:10:26 <roboguy_> Franciman: sure. I still don't see why you'd want a module called ":+:", but I'll try it
16:10:33 <geekosaur> MrRacoon, it has both timeouts and output size limits
16:11:02 <MrRacoon> i c
16:11:17 <Franciman> roboguy_, well it's not valid, but I want my lexer to analyse anything correctly
16:11:23 <dmj> MrRacoon: if interested: http://www.haskell.org/haskellwiki/Lambdabot
16:11:23 <erisco> @pl \s -> (s, a)
16:11:23 <lambdabot> flip (,) a
16:11:25 <roboguy_> ahh, ok I see
16:11:30 <geekosaur> and other limits, just for people who want to try to break into the machine it's running on
16:11:51 <FreeFull> :t (`ap` id)
16:11:51 <lambdabot> (a -> a -> b) -> a -> b
16:12:24 <FreeFull> Hmm, I was hoping it'd be not only for functions, but for all monads
16:12:53 <RichyB> pdxleif, well, it's a mostly-BSD userland with a non-micro kernel derived from Mach for reasons that I couldn't even begin to speculate about. :)
16:14:15 <roboguy_> how often does ghc optimize copying into destructive updates?
16:19:45 <MrRacoon> >  concat $ repeat ' '
16:19:45 <lambdabot>   Couldn't match expected type `[a0]'
16:19:46 <lambdabot>              with actual type `GHC.Type...
16:20:26 <RichyB> repeat ' ' is already [Char].
16:20:30 <erisco> @pl \s -> fmap (fmap f) s
16:20:31 <lambdabot> fmap (fmap f)
16:20:31 <RichyB> > concat $ repeat " "
16:20:32 <lambdabot>   "                                                                          ...
16:20:39 <RichyB> ^ is probably what you meant.
16:20:46 <RichyB> repeat " " is [[Char]].
16:20:47 <MrRacoon> RichyB: yerp
16:21:58 <MrRacoon> :t repeat
16:21:59 <lambdabot> a -> [a]
16:29:01 <enthropy> @src cycle
16:29:01 <lambdabot> cycle [] = undefined
16:29:01 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:30:15 <dmj> enthropy: wonder why it's not cycle xs = xs ++ cycle xs
16:30:42 <Tene> > cycle xs = xs ++ cycle xs
16:30:42 <lambdabot>   <hint>:1:10: parse error on input `='
16:30:56 <Nisstyre> dmj: I think there was an answer to that or something similar on SO
16:31:23 <enthropy> dmj: the xs' version makes an infinite list that doesn't take up so much space
16:31:59 <dmj> ah http://stackoverflow.com/questions/14969010/how-would-i-write-cycle-as-a-lambda-function
16:32:12 <dmj> myCycle = \xs -> let ys = xs ++ ys in ys -- is inlined
16:32:23 <MrRacoon> > cycle /win 30
16:32:24 <lambdabot>   Not in scope: `win'
16:32:25 <lambdabot>  Perhaps you meant one of these:
16:32:25 <lambdabot>    `sin' (imported fro...
16:32:29 <MrRacoon> hehe
16:37:52 <edwardk> dmj: sharing
16:38:11 <dmj> edwardk: sharing?
16:38:29 <edwardk> dmj: by using undefined for [] it can give you back a bottom consistently when you use it on an empty list. otherwise when interpreting in ghci sometimes it wouldn't spot the <loop>.
16:38:52 <edwardk> by using cycle xs = xs' where xs' = xs ++ xs'    the xs' references itself, rather than a fresh invocation of cycle
16:39:21 <edwardk> this will wind up being a list that points back to its own head after it runs through xs
16:40:07 <edwardk> using cycle xs = xs ++ cycle xs   you get a chain that will just keep taking up more and more memory if you hold onto the root of it and unrolling it
16:40:19 <Nisstyre> that makes sense
16:41:12 <edwardk> so both of those inobvious bits of reasoning are captured in the current implementation of that function
16:41:21 <Nisstyre> edwardk: this is "tying the knot" right?
16:41:28 <edwardk> yeah
16:42:02 <edwardk> fix f = a where a = f a  -- is more efficient than fix f = f (fix f)   for the same reason
16:43:14 <edwardk> this is more or less the key to understanding why 'let shouldn't be recursive' is silly. ;)
16:44:03 <tabemann> let being recursive is annoying if your habits were formed by ML, and you're used to rebinding the same name repeatedly when you do things to it
16:44:18 <dmj> edwardk: so both do produce thunk buildup, but moreso cycle since its a fresh invocation each time.
16:44:47 * tabemann has made bugs in Haskell code before by doing just that
16:45:08 <edwardk> tabemann: then use (&) or case    -- and turn in -Wall to catch the error
16:45:15 <c_wraith> I found a reason to use do rec today, because do notation isn't recursive enough for me. :)
16:45:16 <edwardk> er turn on
16:45:51 <edwardk> case foo s of (f, s) -> case bar s of (a, s) -> (f a, s)   -- works fine
16:46:21 <edwardk> as does    foo s & \(f, s) -> bar s & \(a,s) -> (f a, s)
16:46:28 <edwardk> which can be broken across multiple lines
16:46:58 <edwardk> personally i live in a world where i like things to compile with -Wall, and shaowing complains, so i just don't do it
16:47:02 <edwardk> but your mileage may vary
16:47:36 <tabemann> yeah, I'm used to, in OCaml, saying let (f, s) = foo s in let (a, s)  bar s in (f a, s) for that
16:47:57 <dolio> -Wall warns about some unfortunate stuff.
16:48:05 <tabemann> s/(a, s)  bar/(a, s) = bar/
16:48:06 <dolio> But most of it doesn't come up very often.
16:48:47 <tabemann> what I do now in Haskell is something like let (f, s') = foo s in let (a, s'') = bar s' in (f a, s'')
16:49:12 <tabemann> or if I feel like I'll add too many primes, with each rebinding I alternate between having and not having a prime
16:49:36 <c_wraith> If I have too many primes, I break it up into multiple functions.
16:50:20 <dmj> ah :) http://www.haskell.org/haskellwiki/Tying_the_Knot
16:50:50 <c_wraith> (where "too many" is "more than one" most of the time)
16:51:56 <tabemann> two primes is generally my limit
16:52:28 <dmj> > let { x = 0 : y; y = 1 : x } in take 5 x
16:52:29 <lambdabot>   [0,1,0,1,0]
16:53:35 <dmj> > @src cycle
16:53:36 <lambdabot>   <hint>:1:1: parse error on input `@'
16:53:40 <tabemann> is there any specific reason why they decided to make let always recursive in Haskell, rather than using an explicit let rec like in ML or Scheme?
16:54:03 <dmj> @src cycle
16:54:03 <lambdabot> cycle [] = undefined
16:54:03 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:54:08 <c_wraith> it's way more useful for it to be recursive in a lazy language
16:58:09 <Nisstyre> tabemann: isn't let* recursive in Scheme?
16:58:17 <tabemann> Nisstyre: no
16:58:33 <tabemann> let* allows previously defined things to be accessed by later things, in order
17:01:16 <Nisstyre> tabemann: oh I see, for some reason I thought let* did that too. I almost never need to use letrec in Scheme or Racket for some reason.
17:03:43 <tabemann> the main reason to use letrec in Scheme is if you are writing functions that are explicitly recursive, rather than calling higher-order functions that are recursive internally
17:04:26 <Nisstyre> tabemann: yes I have used it before, but it was a while ago
17:04:38 <Nisstyre> tabemann: and I usually use define for recursive functions for some reason
17:05:14 <Nisstyre> I can see the use cases though
17:05:44 <ocharles> woohoo, I can move a rectangle from left to right in an SDL context
17:05:50 <ocharles> SDL+netwire ftw
17:07:12 <tabemann> I'm more used to using let rec in OCaml, because top-level definitions in OCaml are defined identically to other definitions, unlike in Scheme
17:13:26 * hackagebot robots-txt 0.3.0.1 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.3.0.1 (MarkWotton)
17:13:32 <rtmt> I'm having trouble getting prelude to recognize something like 'a' as Word8
17:13:40 <rtmt> eg: split 'a' "aXaXaXa" == ["","X","X","X",""]
17:13:54 <rtmt> split 'a' "aXaXaXa" == ["","X","X","X",""]
17:15:14 <roconnor> what does word8 have to do with split?
17:15:16 <geekosaur> what does that have to do with Word8?
17:15:17 <geekosaur> heh
17:15:35 <geekosaur> also 'a' is a Char, Char is *wider* than Word8
17:15:40 <rtmt> Yeah thats from the bytesting library not the defualt.
17:15:41 * tabemann was reading an interview with Simon PJ today, and it seems like he at least seems to care more that Haskell is pure than it is lazy... even though it seems much of the semantic differences between Haskell and just about any other language (other than Miranda or Clean) is in that it is lazy (e.g. I can easily perceive a pure ML, but I would program it little differently than any other strict environment)
17:15:51 <rtmt> ByteString*
17:16:13 <roconnor> is there anything in Data.ByteString.Char8?
17:16:28 <tabemann> Data.ByteString.Char8 considered harmful
17:16:51 <FreeFull> rtmt: I'm guessing what you actually want is the split library
17:17:07 <tabemann> if you really want to get arbitrary text in and out of ByteStrings, you should be using Data.ByteString.UTF8
17:17:08 <FreeFull> rtmt: http://hackage.haskell.org/package/split-0.2.2
17:17:37 <rtmt> I really am just trying to figure out how to use the funcitons included in the bytestring library.
17:17:57 <rtmt> And prelude doesn't want to play nice.
17:18:29 <FreeFull> rtmt: It's not really to do with prelude
17:18:42 <roconnor> tabemann: I think most of the time we program in a strongly normalizing fragment of haskell.
17:18:51 <FreeFull> rtmt: A Word8 would be something like 5
17:19:15 <c_wraith> 5 is a boring Word8.  65 is better.
17:19:39 <rtmt> okay so I actually have to use the ascii doe then
17:19:45 <geekosaur> rtmt: usually you want to import ByteString qualified and qualify the functions at use, rather than trying to deal with the Prelude versions
17:19:53 <rtmt> I was
17:20:12 <rtmt> The code I posted was from the haskell documentation
17:20:54 <dmj> rtmt
17:20:59 <rtmt> http://lpaste.net/91350
17:21:00 <rtmt> yes
17:21:06 <dmj> rtmt: import qualified Data.ByteString.Internal as BS (c2w, w2c)
17:21:11 <dmj> g = split (BS.c2w '\n') "a\nb\nd\ne" == ["a","b","d","e"]
17:21:54 <dmj> rtmt: someone on SO had the same issue, http://stackoverflow.com/questions/10623424/haskell-how-to-convert-char-to-word8
17:22:08 <rtmt> thanks
17:22:14 <roconnor> > fromEnum . toEnum $ 'a' :: Word8
17:22:15 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:22:15 <lambdabot>              with actual type ...
17:22:25 <roconnor> > toEnum . fromEnum $ 'a' :: Word8
17:22:26 <lambdabot>   97
17:22:47 <dmj> rtmt: http://pastebin.com/raw.php?i=ypkEBgSi
17:22:52 <mauke> The paste ypkEBgSi has been copied to http://lpaste.net/91351
17:23:22 <dmj> mauke: Oh :) I was like why isn't lpaste.com working.. doh!
17:24:06 <elliott> that copier is automated, btw
17:24:10 <zRecursive> :t (<*)
17:24:11 <lambdabot> Applicative f => f a -> f b -> f a
17:24:20 <dmj> elliott: oh that's even better
17:24:31 <dmj> talking to a bot
17:24:47 <elliott> well, mauke isn't quite a bot.
17:25:41 <dmj> elliot: if he can autocopy he can't be human :)
17:27:36 <FreeFull> <* is the << of Applicative
17:28:11 <FreeFull> :t (<<)
17:28:11 <lambdabot>     Not in scope: `<<'
17:28:11 <lambdabot>     Perhaps you meant one of these:
17:28:11 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
17:28:16 <dmj> :t (>>)
17:28:16 <lambdabot> Monad m => m a -> m b -> m b
17:28:26 <FreeFull> :t flip (>>)
17:28:26 <lambdabot> Monad m => m b -> m a -> m b
17:31:27 <dmj> rtmt: Data.ByteString.Char8 has a split function which is Char -> ByteString -> [ByteString], that would be better than using the Internal reference I gave before.
17:36:11 <erisco> got a cool function for today
17:36:23 <johnw> what?
17:36:31 <erisco> http://lpaste.net/91352     can you think of uses? :)
17:36:35 <johnw> -
17:37:14 <johnw> um, how is that different from map?
17:37:57 <elliott> that's foldr
17:37:59 <elliott> almost.
17:38:02 <elliott> :t foldr ?? []
17:38:02 <lambdabot> (a -> [a1] -> [a1]) -> [a] -> [a1]
17:38:11 <elliott> > foldr f z [a,b,c,d]
17:38:11 <erisco> it is almost like a map, almost like a fold
17:38:12 <lambdabot>   f a (f b (f c (f d z)))
17:38:14 <hpc> :t ??
17:38:14 <lambdabot> parse error on input `??'
17:38:18 <hpc> :t (??)
17:38:19 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:38:22 <johnw> ah, I see
17:38:28 <hpc> oh, (??) = caleflip
17:38:37 <jmcarthur> :t (`foldr` [])
17:38:38 <lambdabot> (a -> [a1] -> [a1]) -> [a] -> [a1]
17:38:40 <elliott> from lens.
17:38:50 <bscarlet> um: hlint itself says what it is, right in the lpaste
17:39:04 <edwardk> yeah, technically i think it was skiflip ;)
17:39:19 <johnw> (??) = sik
17:39:33 <erisco> jmcarthur, neato
17:39:36 <edwardk> johnw: in that ski_ proposed it originally =P
17:39:40 <zRecursive> @hoogle split
17:39:40 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
17:39:40 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
17:39:40 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
17:40:16 <hpc> edwardk: it's my favorite caleskell-ism, just for how surprising it is :D
17:40:18 <liyang> erisco: don't be discouraged. You'll find and reinvent lots of cool stuff, only to discover later that edwardk's already done it. (And better too.)
17:40:42 <erisco> liyang, I was actually looking for something equivalent
17:40:50 <erisco> I recognized it was something like a map or fold
17:40:58 <hpc> erisco: little-known secret - the way to get ahead in haskell is to write libraries that do complex IO, and document everything
17:41:14 <hpc> erisco: because edwardk has the other end of the library market covered
17:41:35 <edwardk> hah
17:41:55 <edwardk> i started working on trying to take market share away from the 'documented' crowd but it ate into my productivity margin
17:42:05 <erisco> I... um... am confused
17:42:10 <erisco> anyways, thanks
17:42:43 <hpc> edwardk: better than don "five year vacation" stewart ;)
17:42:46 <edwardk> erisco: he's teasing me because I have written a lot of libraries that provide obvious things that were missing or just not in a canonical location
17:43:14 <edwardk> erisco: but i tend to avoid complex IO-based systems and have historically not been great at documenting
17:43:22 <edwardk> i'm working on the latter though
17:43:41 <johnw> edwardk's autobiography would at least be a quick read ;)
17:43:51 <edwardk> hah
17:43:57 <edwardk> born, wrote stuff, died.
17:44:09 <johnw> main = wroteStuff
17:44:11 <hpc> erisco: i was serious about writing IO-heavy libs though; you can never have too many ways to interact with the world
17:44:54 <hpc> main = lens' <> (ask >>= (<* wroteStuff))
17:45:14 <edwardk> johnw: not sure i could use that for my biography. i mean wroteStuff is an IO action. i'd be more willing to give you back a lazy pretty printable document, but damnit you better print it yourself ;)
17:45:16 <roconnor> hpc:  needs more <>~
17:47:06 <edwardk> snoyman's would be main = [auto|biography|]
17:47:14 <gennaro123> ciao atutti
17:47:28 <gennaro123> list!
17:47:43 <erisco> > (`foldr` []) intersperse [1..10]
17:47:44 <lambdabot>   []
17:47:48 <edwardk> probably with more hamlet
17:47:49 <johnw> haha
17:47:52 <erisco> I just find that wonderfully useless :)
17:48:09 <BMeph> edwardk: You should save a step, and use links to video talks for your documentation refs.... ;)
17:48:20 <edwardk> BMeph: heh
17:49:25 <edwardk> Speaking of random video links, Runar Bjarnason recorded me, dolio and joshcough talking about the recent open sourcing of our compiler for "Ermine."
17:49:27 <edwardk> http://www.youtube.com/watch?v=QCvXlOCBe5A
17:49:30 <erisco> > (`foldr` []) concatMap (take 10 $ repeat (const "abc"))
17:49:30 <lambdabot>   ""
17:49:33 <erisco> ^.^
17:49:46 <BMeph> edwardk: Oh, and snoyman's auto-b would be that quote, but with whatever those words are in Hebrew. ;)
17:51:59 <hpc> edwardk: better idea - upload your presentation notes to hackage, then at conferences read straight from the internet
17:52:50 <BMeph> edwardk: Even better: record your talk in advance, and just hang around for the questions! 8D
17:52:52 <edwardk> hpc: liyang did more or less that at a talk he gave on profunctors. posted it to the school of Haskell and then pulled up the page for the talk =)
17:53:07 <johnw> i like that edwardk's champions the theoretical, abstract and mathematical, while snoyberg champions the concrete and practical.  Often if what I want is very high-level, I run into an edwardk library that's already implemented; and if I want to do some low-level like send an e-mail, it's typically a snoyberg library that's already covered it.  I see the two like Hackage bookends  :)
17:53:54 <edwardk> Yes, but when the two armies meet in the middle, death and chaos shall ensue
17:54:10 <johnw> considering you are both on the same libraries committee, I figure you can play nicely
17:54:27 <liyang> BMeph: great idea!
17:54:46 <edwardk> There is already a small holding action out on one side where me, snoyman and Tekmo are circling one another on the machines/conduit/pipes front ;)
17:55:02 <johnw> i haven't tried machines yet
17:55:04 <geekosaur> BMeph: which is just "autobiografiyah" in Hebrew letters, of course
17:55:06 <mstksg> i must be blanking out here but is there an operator that i can use instead of (.) to "reverse" the notation of a long chain of compositions?  sometimes it's tricky reading backwards
17:55:21 <geekosaur> not standard. lens has & for the purpose
17:55:32 <edwardk> Tekmo as a better propaganda machine, but snoyman has outmaneuvered him to take the web, while I'm just trying to refine some core technology.
17:55:42 <jmcarthur> mstksg: you could just read (f . g . h) left-to-right :)
17:56:29 <edwardk> If in the end, machines doesn't pan out, I'll probably just embrace whichever one of theirs is still standing ;)
17:56:36 <liyang> mstksg: what is backwards anyway? It's just the dual of forwards.
17:56:43 <edwardk> But don't tell anyone
17:56:55 <geekosaur> "1053 total"
17:56:56 <johnw> mums the word
17:57:02 <geekosaur> :p
17:57:23 <johnw> i thought pipes was looking beautiful, but it sure how complexified lately.  Conduit may only solve a subset of the problem, but it does it in a very straightforward way at least
17:57:43 <mstksg> jmcarthur: if i have map (f . g . h . i . j) xs ... to see what's going on, i apply the list of compositions backwards in my head (j to x, i to j, etc.)...but reading backwards can drain a soul vv
17:57:51 <elliott> pipes seems to be getting simpler lately. whether that sas much is up to you
17:57:51 <edwardk> I want something cleaner than both of them that can do more. Is that too much to ask for? =)
17:57:52 <jmcarthur> mstksg: it even makes sense from an operational point of view since that is the order of evaluation.   (f . g . h) x ==> f ((g . h) x)  -- now it's f's turn
17:58:01 <elliott> edwardk: is machines cleaner yet? :p
17:58:08 <edwardk> elliott: not yet
17:58:08 <jmcarthur> mstksg: note that h will be evaluated *last*, not first
17:58:15 <edwardk> there is a reason its still in stasis
17:58:24 <enthropy> can runghc load a .o file in the same way that ghci or ghc can?
17:58:40 <edwardk> though if pchiusano gets around to using his infinite freetime as a freelance consultant these days to work on it, then it may start to flesh out
17:58:57 <hpc> enthropy: afaict, runghc is basically the same as running "ghci file", then running main
17:58:57 <liyang> mstksg: it gets less painful the more often you do it.
17:59:04 <edwardk> he's been focusing on improving the streaming library for scalaz which borrows a lot from the scala implementation of machines
17:59:12 <hpc> enthropy: and if you have a .o, you also want the .hi file too
17:59:18 <hpc> s/want/need/ :P
17:59:25 <enthropy> hpc: this .o is from a .c
17:59:25 <edwardk> So, machines has more or less gone on to influence other languages. We'll see how it round trips back to Haskell.
17:59:29 <jmcarthur> mstksg: but i'm really just playing tricks with this argument. the big point is that (f . g . h) is just some value composed from simpler ones, and the sooner you learn to think of it that way instead of some sequence of operations, the better
17:59:42 <mstksg> liyang: thanks, i guess that's encouraging to hear. maybe it's just my fixation on imperative thinking
17:59:46 <hpc> enthropy: well, that doesn't sound like it has a main ;)
18:00:00 <liyang> mstksg: (said the bishop to the actress.)
18:00:02 <mstksg> jmcarthur: yeah, it seems that that shift in thinking is a necessary one
18:00:08 <monochrom> I want infinite free time too!
18:00:20 <hpc> monochrom: just do what dons does
18:00:22 <jmcarthur> mstksg: or, rather, think of composed functions as sequencing is only *one* way to think of it, and it's not usually the most useful way
18:00:30 <jmcarthur> *thinking of
18:00:35 <hpc> monochrom: stop programming and blog about liquor
18:00:37 <enthropy> hpc: right, it has some symbols that are needed in my main
18:00:43 <monochrom> haha, now it's liquor?
18:00:52 <applicative> no !?
18:00:56 <hpc> https://dl.dropboxusercontent.com/u/37707/dons.png
18:01:23 <applicative> aw
18:01:37 <monochrom> dons was the chosen one!
18:01:52 <mstksg> for some reason my journal into haskell has made me freefall out of imperative thinking and then climb back slowly there with all of these monad libraries
18:01:52 <monochrom> now he's a drunk one :)
18:02:15 <hpc> little known fact: dons had a son named edwardk, then died in an epic volcano fight
18:02:15 <geekosaur> drunken master?
18:02:17 <mstksg> and combinators
18:02:38 <hpc> edwardk: bring balance to the force!
18:03:02 <monochrom> "om or nom. there is no try"
18:03:33 * hackagebot inspection-proxy 0.1.0.1 - A simple proxy for debugging plaintext protocols communication  http://hackage.haskell.org/package/inspection-proxy-0.1.0.1 (MariusGhita)
18:04:09 <hpc> do, or http://hackage.haskell.org/package/acme-dont
18:04:11 <hpc> there is no try
18:04:22 <geekosaur> m or w
18:05:25 <hpc> mstksg: for extra fun, go back to java :P
18:05:46 <FreeFull> > don't [3]
18:05:47 <lambdabot>   Not in scope: `don't'
18:05:56 <FreeFull> @let import Acme.Dont
18:05:57 <lambdabot>  .L.hs:33:1:
18:05:57 <lambdabot>      Failed to load interface for `Acme.Dont'
18:05:57 <lambdabot>      Use -v to see...
18:06:05 <zRecursive> just leaving clojure for haskell :)
18:06:15 <CADD> zRecursive: good!
18:06:41 <hpc> FreeFull: tragically, you have to write "don't $ do ..." to fully mimic the original perl
18:06:47 <CADD> zRecursive: although i think clojure is good if you NEED to use the jvm, i personally stay as far away from it as possible
18:07:21 <zRecursive> CADD: yeah
18:07:25 <mstksg> it's just a little odd that i spent all of those times working out exercises for figuring out problems functionally, then i learned about monads and combainators and i don't do anything more functional than fmap and fold.
18:07:33 <FreeFull> hpc: Is it a part of perl?
18:07:46 <geekosaur> no
18:08:04 <hpc> http://search.cpan.org/~dconway/Acme-Don-t-1.01/t.pm
18:08:05 <FreeFull> Oh, it's a part of a library
18:08:14 <geekosaur> none of the Acme:: modules are included with Perl
18:08:20 <hpc> sub don't (&) {}
18:13:08 <erisco> ah ha...
18:13:47 <erisco> I didn't suspect Haskell would be strict on a pattern match for  (Foo a)  if Foo is the only value constructor
18:14:10 <hpc> erisco: that's the semantics of pattern matching
18:14:20 <hpc> (modulo ghc getting clever with optimizations)
18:14:27 <geekosaur> pattern matching is the primary way to introduce strictness
18:14:32 <erisco> mm, well, I had to use  ~(Foo a)
18:14:43 <erisco> which is no biggie, but took me a while to figure out what was wrong
18:15:04 <erisco> "had" as in, it was syntatically convenient to use pattern matching
18:15:06 <BMeph> erisco: You mean, that you were doin' it rong? ;√æ
18:15:34 <erisco> well, sure, just throwing it out there that it was a bit of a gotcha
18:16:00 <erisco> I was aware of the strictness because for two value constructors it would only be known at runtime which one was actually present
18:16:04 <johnw> if I have an x, and I pattern match (Foo a) on x, I always assume x will be evaluated to WHNF, no matter how it is defined
18:16:12 <erisco> but with only a single constructor, I made an incorrect assumption
18:16:33 <johnw> otherwise, how could it know that it's a Foo?
18:16:48 <johnw> I see, you're suggesting that from the type it knows
18:17:08 <erisco> yeah, I assumed it would and then forget I made that assumption
18:17:09 <johnw> and since there is only one option, it could infer without evaluating
18:17:28 <erisco> irrefutable pattern fixes it up though
18:17:30 <johnw> well, ~(Foo a) makes your intention properly explicit
18:17:37 <hpc> perhaps you should consider making Foo a newtype, too
18:17:41 <dolio> What did you use to learn? And did it never talk about data vs. newtype?
18:17:47 <johnw> "I know this is a Foo, but don't need you to evaluate just yet"
18:17:54 <erisco> I thought newtype was just a syntatical variant on data?
18:18:39 <erisco> well, a specific case of data. does it actually mean something different?
18:19:07 <johnw> newtype flags a type so that it doesn't unify with its underlying type, but there is no additional data representation
18:19:30 <johnw> it's more like a syntactic variant on type, although data can be used anywhere that newtype can be
18:20:06 <johnw> i.e., newtype is a compile-time distinction, data is also a runtime distinction
18:20:11 <erisco> interesting...
18:20:20 <erisco> if I use newtype instead of data, I don't have to use the irrefutable pattern
18:20:40 <lispy> newtype has different strictness than data
18:20:47 <erisco> evidently so
18:20:51 <lispy> because the "constructor" for the newtype doesn't exist at run-time
18:21:05 <johnw> ah, so ~(Foo a) isn't needed?  good to know
18:21:39 <erisco> is there any reason to use data if you only have one value constructor?
18:21:52 <lispy> erisco: if you wanted it to be lazy :)
18:21:56 <erisco> in light of the additional strictness?
18:23:31 <startling> how evil is non-injective "show"?
18:23:55 <ezrios> it's the devil's spawn
18:24:12 <ojw> well are you using read?
18:24:24 <startling> nope.
18:24:35 <ojw> then I'm not an expert, but... what's the harm?
18:24:43 <lispy> erisco: http://stackoverflow.com/a/13567709/5113
18:24:58 <zRecursive> why "the constructor for the newtype doesn't exist at run-time" ?
18:25:29 <startling> zRecursive: because it doesn't need to.
18:25:33 <ojw> does anyone have a preferred indexed set library?
18:25:49 <startling> zRecursive: if you want it to, don't use "newtype", use "data"
18:26:02 <erisco> lispy, thanks :)
18:26:08 <lispy> zRecursive: It's the design. The reason they chose to make it that way, is so that at run-time there is no penalty for making a newtype.
18:26:15 <ojw> I've used ixset, hoping there's something new and better :)
18:26:20 <zRecursive> startling: how to use newtype at run time ?
18:26:34 <startling> zRecursive, that makes no sense.
18:26:34 <lispy> In practice, there is an unintended penalty. If someone used clever RULES (rewrite rules) for the orginal type, the newtype won't automatically inherit them.
18:27:51 <zRecursive> lispy: thx
18:28:03 <geekosaur> zRecursive, what would you expect newtype to do at runtime?
18:28:04 <geekosaur> its whole reason for existence is to make the compiler "forget" things about a type
18:28:23 <zRecursive> geekosaur: same as data
18:28:33 <mm_freak> ocharles: great =)
18:28:53 <geekosaur> then why not use data?
18:29:24 * zRecursive i always thing newtype is same as data with only one constructor :)
18:30:39 * monochrom makes a bad pun: the purpose of newtype is unclear to newtypes :)
18:30:51 <geekosaur> there'd be no point to a newtype that was just a restricted form of data
18:31:03 <monochrom> (the second "newtypes" refers to beginners :) )
18:31:08 <c_wraith> As of today, I still wish there were existential newtypes. :)
18:31:25 <c_wraith> I've somehow found a use case for one!
18:33:12 <dolio> Of course there are uses. They just also let you do things that don't make sense.
18:38:57 <tabemann> hmm... but why couldn't the whole "forgetting" things about a type just be done automatically?
18:39:53 <c_wraith> Well, that's *usually* a bug.  It's best to make sure people really mean it.
18:41:27 <edwardk> I always viewed a newtype as showing off how cool we are with type erasure. Look Ma, no tags!
18:41:35 <tabemann> I mean, why would one ever want, say, data Foo = Foo Bar when they can have newtype Foo = Foo Bar
18:42:04 <c_wraith> edwardk: but because I'm existentially quantifying a type variable, I don't get to be cool.
18:42:22 <edwardk> ‚Ä¶ while some Java guy is cowering in the corner trembling in fear at the thought of not having instanceof.
18:42:44 <edwardk> tabemann: data Foo = Foo Bar creates a wrapper. an extra distinguished _|_ you can have
18:42:54 <edwardk> there is a difference between _|_ and Foo _|_
18:43:32 <edwardk> so when you pattern patch on Foo you can do so strictly or lazily depending on if you want to force that outer layer or not
18:43:53 <edwardk> it offers a finer grain of control over when you bottom out.
18:44:27 <edwardk> also with polykinds it is unfortunate but some things that look like they should be able to be newtypes can merely be data types, etc.
18:44:39 <tabemann> polykinds?
18:44:54 <jmcarthur> tabemann: kind polymorphism
18:45:27 <c_wraith> I've been using that today, too.
18:45:29 <edwardk> newtype Magic a r = Magic (forall s. Reifies s a => Proxy s -> r) -- works without PolyKinds, but has to be data with it turned on.
18:46:05 <jmcarthur> tabemann: the idea is that type parameters don't necessarily have to be just some particular kind (*, *->*, (*->*)->*, etc.) but can be instantiated to different kinds
18:47:14 <c_wraith> edwardk: do you know why ¬´ fromNat :: forall (proxy :: Nat -> *) (n :: Nat). SingI n => proxy n -> Int ¬ª needs the SingI constraint in it? Is that just due to how early the type-level nats implementation is?
18:47:18 <tabemann> now I'm going to have to wrap my brain around that
18:48:00 <tabemann> type-level nats... is that like basically poor-man's dependent typing?
18:48:28 <c_wraith> It's part of poor-man's dependent typing.  Not nearly all of what's available.
18:48:32 <edwardk> yes. without the constraint after it erases there is nothing being passed around
18:48:33 <jmcarthur> tabemann: for example, with PolyKinds, this can be an instance of Category (at least if Control.Category is build with that extension):    newtype T f g = T (forall a. f a -> g a)
18:48:51 <edwardk> the dictionary for SingI n   is the only thing carrying around the Int you want
18:49:07 <edwardk> otherwise you convinced the compiler one exists, but didn't keep it ;)
18:49:27 <ion> The generalization of value-level bugs results in type-level gnats.
18:49:27 <edwardk> so you can't project it down to the value level
18:49:31 <c_wraith> edwardk: sure, but I would have thought the dictionary would be implicit in the (n :: Nat) declaration, rather than need to be mentioned explicitly.
18:49:41 <tabemann> okay, this is interesting, but I need to get offline for a moment
18:49:53 <edwardk> (n :: Nat) just says that you have some type inhabiting that kind. types get erased
18:50:07 <edwardk> even if they are from super-fancy special kinds
18:50:29 <c_wraith> Oh, I see.  It's an implementation detail in some sense - without the constraint, there's nowhere for the dictionary to be passed.
18:51:07 <edwardk> its a type that has no term inhabitants, so when its erased. you've got nothing at runtime. we erase types because they can be damn expensive to pass around and update and substitute into, you don't _want_ to pay for them all at runtime
18:51:24 <edwardk> the dictionary is witnessing the fact that you need the particular Int that that Nat represents as a value.
18:51:35 <edwardk> not just as an existential claim that one existed that you can pass around
18:52:22 <edwardk> the latter after erasure is "free", the former becomes real code to move the witness
18:54:03 <edwardk> that means that when i go to implement something like: https://github.com/ekmett/bound/blob/master/examples/Overkill.hs     most of those type-checking shenanigans come without cost at runtime, making them at least not a misfeature
18:54:40 <c_wraith> I just didn't realize how much the type erasure directly shapes the code being compiled.  It's not enough to say "all Nat-kinded types have an instance of SingI, so one will always exist".  You also have to say "and pass it here."
18:55:57 <c_wraith> You have to say it explicitly, that is.  The compiler won't notice that it's needed and include it for you.
18:56:06 <edwardk> yeah, i've long conjectured that you can probably make a perfectly cromulent notion of typeclasses by talking about sub-kinds of * that satisfy a constraint, and then you could track the witnesses that you occupy that proper sub-kind, etc. its just not how haskell was written.
18:56:14 <edwardk> well, at least GHC
18:56:24 <edwardk> if you look at JHC on the other hand they implement closer to what you're thinking
18:56:59 <c_wraith> Though JHC doesn't have all these features I'm abusing in the first place. :)
18:57:02 <edwardk> because they erase down to a core that loses the unbounded polymorphism and replaces it with a form of bounded subtyping and they play some locally dependent typing tricks in the interpretation of that core
18:57:04 <edwardk> sure
18:57:26 <c_wraith> Thanks for the explanation. It really did clear up why I needed that constraint explicitly.
18:57:36 <edwardk> but meacham at least thinks the right way that the features you want would have the interpretation you expect
18:57:56 <edwardk> np
19:01:55 <dolio> The sub-kinds interpretation doesn't work for multi-parameter type classes.
19:02:56 <dolio> Unless you start having sub-kinds of products of kinds or something.
19:06:47 <edwardk> yeah, it gets messy there
19:08:21 <dolio> Otherwise I think people were explaining it that way before you were on the scene. :)
19:10:52 <thoughtpolice> jmcarthur: FWIW, Category will be polykinded in 7.8
19:17:29 <hpaste> joefiorini pasted ‚Äúwebsockets example‚Äù at http://lpaste.net/91353
19:17:58 <joefiorini> ^^ is there a reason that keeps failing with "out of scope sink" at line 15?
19:18:57 <joefiorini> compiler reports both sink and msg are not in scope, but seems like it should work? still learning, google wasn't very helpful :/
19:21:10 <RichyB> move line 15 up into a let statement after line 10?
19:22:38 <RichyB> joefiorini, I think that all that's up is that the "where" clause at the bottom doesn't have any of the intermediate bindings in the 'do' block available to it.
19:22:41 <RichyB> http://lpaste.net/91353
19:23:39 <joefiorini> RichyB: yeah, that makes a little sense... wonder why the example I'm following shows it? https://raw.github.com/jaspervdj/websockets/master/example/server.lhs
19:24:07 <monochrom> I can't find line 15
19:24:33 <RichyB> monochrom, look in http://lpaste.net/91353 - not the one I posted.
19:25:21 <RichyB> joefiorini, I think that the indentation works out differently there and that the "where" is indented to one of the patterns in the "case" statement, not to the "do" block.
19:25:51 <monochrom> "where" does not see the inside of the do-block
19:25:57 <joefiorini> RichyB: okay, that makes a little more sense... so scope is very dependent on indentation level?
19:26:01 <geekosaur> yes
19:26:04 <RichyB> Yes.
19:26:33 <joefiorini> thanks :)
19:26:34 <geekosaur> haskell uses indentation in a way similar (but not identical) to python
19:26:44 <monochrom> oh, I suppose you have a "case" and it can have its "where". that one will see sink and msg
19:26:53 <RichyB> Haskell's lexer picks up newlines, indent-increases and indent-decreases and turns them into equivalent ; { and }s for you, so indentation really is semantically important.
19:27:17 <RichyB> I'm phrasing that badly but hopefully you get what I mean there.
19:28:46 <joefiorini> RichyB:  yes, makes some sense. so I can imagine { }s around indentations?
19:29:29 <joefiorini> that sounds like a useful trick :)
19:30:14 <RichyB> I think so.
19:30:28 <erisco> @src foldl
19:30:28 <lambdabot> foldl f z []     = z
19:30:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:30:49 <RichyB> @src foldl'
19:30:49 <lambdabot> foldl' f a []     = a
19:30:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:31:49 <erisco> was just checking why foldl didn't like infinite lists :)
19:33:54 <Modius> Is there some wrapper for System.Process that people habitually use, especially when doing Win32 work or cross-platform that includes windows?
19:37:11 <joefiorini> RichyB: moving the where up under the first case branch fixed the issue http://lpaste.net/91353
19:37:36 <RichyB> Cheers.
19:37:50 <joefiorini> thanks for the help
19:38:08 <joefiorini> I do think the let reads more nicely though, probably going to stick with that
20:12:11 <ion> @remember edwardk clearly it should be \x -> x <$ do f . g $ x. do is a magical () killing machine
20:12:11 <lambdabot> It is stored.
20:12:36 <edwardk> > 5 * do 3 + 4
20:12:37 <lambdabot>   35
20:12:54 <hpaste> stevejb pasted ‚Äúhaving a compile error with this‚Äù at http://lpaste.net/2863634809991725056
20:13:54 <geekosaur> :t (^)
20:13:54 <lambdabot> (Integral b, Num a) => a -> b -> a
20:14:17 <geekosaur> hm, not that
20:14:47 <edwardk> > 5 ^ do 3 + 4
20:14:48 <lambdabot>   78125
20:18:41 <ion> > 5 ^ do succ $ 3 + 4
20:18:42 <lambdabot>   390625
20:19:16 <erisco> > 5^8
20:19:17 <lambdabot>   390625
20:20:07 <c_wraith> Hey, this is enough unlike anything I've done before that I'm throwing it out for comment.  It all *works* in my testing, but that doesn't mean I'm not doing something stupidly unsafe somewhere.  Can folks check this out and tell me if I've done anything horribly dumb?  http://lpaste.net/91356
20:20:54 <edwardk> if you don't need the show you can always use the Proxy from Data.Proxy to hold your Nat.
20:21:19 <c_wraith> I actually wanted something with a *really* short constructor name for my use case.
20:21:35 <elliott> toStorableArray looks dangerous.
20:21:36 <c_wraith> I guess I should have looked at Data.Proxy
20:21:37 <elliott> since user gets to pick the i
20:21:39 <edwardk> overall the N is shorter though, so I can see it, yeah.
20:22:03 <c_wraith> elliott: They sort of get to pick i.  They can't create MA instances, though
20:22:04 <ion> > 5 ^ do 3 + 4 :: Integer :: Double
20:22:05 <lambdabot>   78125.0
20:22:17 <edwardk> you at least don't seem to require N in negative positions, so kudos for that ;)
20:22:19 <c_wraith> elliott: and that limits it to only the correct i
20:22:34 <c_wraith> edwardk: that's actually a pattern I picked up from you and shachaf. :)
20:22:35 <edwardk> ion: sneaky
20:23:06 <crdueck> It's strange that Data.Set provides lookup{LT,GT,LE,GE}, and member, but no regular lookup function. There has got to be a better way than lookupIndex and elemAt.
20:23:11 <elliott> c_wraith: ah.
20:23:19 <elliott> c_wraith: why not:
20:23:19 <elliott> data MultiArray (dimensions :: k) e = forall i. MultiArray (StorableArray i e)
20:23:20 <elliott> ->
20:23:29 <elliott> data MultiArray (dimensions :: k) e = forall i. MA k i => MultiArray (StorableArray i e)
20:23:33 <elliott> or such.
20:23:36 <enthropy> crdueck: member is not good enough?
20:23:42 <elliott> c_wraith: in fact, if you used a type family you could avoid the existential entirely
20:23:49 <elliott> (and a constructor overhead)
20:23:52 <crdueck> enthropy: no, I need access to the actual element.
20:23:53 <edwardk> crdueck: you want the actual element that compares as equal because i presume you are smuggling extra info in it?
20:24:03 <elliott> newtype MultiArray (dimensions :: k) e = MultiArray (StorableArray (Thingy k) e)
20:24:17 <c_wraith> oh, hmm.  That's an excellent point
20:24:21 <edwardk> or are you using the Set as a sort of hash-cons bin?
20:24:35 <c_wraith> elliott: that's definitely a change worth making.  Thanks.
20:24:41 <elliott> :)
20:24:44 <enthropy> (Map k k) might be the way to do it instead of (Set k)
20:24:45 <crdueck> edwardk: the former. I have a data type data Foo = Foo1 Int | Foo2 Char etc
20:24:46 <elliott> I sort of wish fundeps exposed a type family
20:24:59 <elliott> so "class Foo a b | a -> b" would expose something to get the b from an a
20:25:13 <c_wraith> Yeah, that would be handy
20:25:36 <edwardk> crdueck: and the (==) is on just if it is a Foo1 or Foo2 or something?
20:25:43 <edwardk> crdueck: why not just use a Map in the first place?
20:26:01 <crdueck> yes, the Ord instance doesn't depend on the values in Foo. so Foo1 4 == Foo1 6
20:27:08 <c_wraith> elliott: and I suppose I should declare Thingy (or whatever I name it) with data, to preserve injectivity the way the fundeps currently do
20:27:32 <edwardk> newtype Key = Key Foo; instance Eq Key where Key Foo1{} == Key Foo1{} = True; Key Foo2{} == Key Foo2{} = True; _ == _ = False         ; then work with Map Key Foo where by convention the key is just the newtyped wrapped version of the value.
20:27:40 <elliott> c_wraith: um, I think type family gives you the same properties here
20:27:46 <elliott> you can have duplicate "b"s already
20:27:56 <edwardk> an extra pointer at each node shouldn't hurt you too bad and you at least get a good guarantee of correctness
20:28:05 <edwardk> also you can make the Key actually contain less info if you want
20:28:15 <edwardk> data Key = Key1 | Key2
20:28:28 <edwardk> bit duplicaty, but hey
20:28:44 <crdueck> edwardk: I had thought to use Map at first, but I want some type guarantees on the keys and vals of the Map.
20:29:25 <edwardk> crdueck: i usually wind up making some kind of Map that takes strongly typed keys to get strongly typed values
20:29:37 <edwardk> i really should package that idea up for release some day
20:31:46 <edwardk> lookup :: HOrd f => f a -> HMap f g -> Maybe (g a)
20:31:53 <crdueck> if I had data Key = IntKey | CharKey; data Val = ValInt Int | ValChar Char; then I would only want IntKey to be a key for a ValInt value in my Map. Then I thought this was a lot of work to just get the same type safety I would get by having just a set of Val.
20:32:15 <crdueck> how can I strongly type my keys like you suggest?
20:32:52 <edwardk> data Key a where IntKey :: Key Int; CharKey :: Key Char
20:33:07 <edwardk> then work with an    HMap Key Identity
20:33:29 <edwardk> ou can have up to two entries in your map one Int and one Char
20:34:19 <edwardk> HMap :: (x -> *) -> (x -> *) -> *
20:34:30 <edwardk> so this even works with args of other kinds, etc.
20:34:40 <edwardk> meaning that HMap need be defined only once
20:35:36 <edwardk> the trick is in HOrdering, equality needs to give back a type equality witness
20:36:19 <NemesisD> i've got a bit of a dilemma. i'm using http://hackage.haskell.org/packages/archive/here/1.2.1/doc/html/Data-String-Here-Interpolated.html to do interpolated strings
20:36:36 <NemesisD> it seems to require a Show and Typeable instance for values you interpolate
20:36:44 <edwardk> data HOrdering f g where HLT :: HOrdering f g; HEQ :: HOrdering f f; HGT :: HOrdering f g
20:36:53 <NemesisD> but that means if you try to interpolate a string value it puts quotes around it
20:37:25 <NemesisD> so [i|quoted value ${"quoted string"}|] retruns "quoted value \"quoted string\"
20:37:46 <NemesisD> any clever ideas for avoiding those explicit quotes
20:38:26 <edwardk> class HEq f where heq :: f a -> f b -> Maybe (a == b);                  class HEq f => HOrd f where hcompare :: f a -> f b -> HOrdering a b
20:38:52 <edwardk> then you can order the map on HOrd, and when you find a key you can know that the type arguments match.
20:39:14 <edwardk> all the HMap, HEq, HOrd, HOrdering crap gets written once.
20:39:20 <Saizan> NemesisD: Show seems like the wrong class, but i guess a newtype would work
20:39:47 <edwardk> crdueck: i'm mentioning it as 'the right solution', not necessarily the one you should implement ;)
20:40:26 <NemesisD> Saizan: ah according to the example, if you interpolate an actual string it doesn't add the quotes
20:40:39 <format> hi all, one quieck question, i have a function that transponce a matrix, how i resolve this exception:  http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/l
20:40:43 <format> 00:37 [ cheezey         ] [ Guest94385    ] [ melter        ] [ s4msung        ] [ Will|         ]
20:40:46 <format> 00:37 [ chickenflu      ] [ guymann       ] [ mendez_       ] [ s_quark        ] [ wollw         ]
20:40:47 <NemesisD> which is probably a bad sign performance wise but i guess it doesn't matter for this program
20:40:49 <format> 00:37 [ chirpsalot      ] [ h_chiro_      ] [ mephx         ] [ SaBer          ] [ wormphlegm    ]
20:40:52 <format> 00:37 [ ChongLi         ] [ haasn         ] [ mero          ] [ Saeppel        ] [ wting         ]
20:40:55 <format> 00:37 [ Chousuke        ] [ hackagebot    ] [ message144    ] [ Sagi           ] [ wto           ]
20:40:57 --- mode: ChanServ set +o geekosaur
20:40:58 <format> 00:37 [ chrisbuchholz_  ] [ Hafydd        ] [ MetaCosm      ] [ saiam          ] [ wtw           ]
20:41:01 <format> 00:37 [ chrisdotcode_   ] [ hamishmack    ] [ mgaare        ] [ saiam^         ] [ wunki         ]
20:41:04 <format> 00:37 [ chrra           ] [ hape01        ] [ mgregson      ] [ saiko-chriskun ] [ xaimus        ]
20:41:07 <format> 00:37 [ ciaranm         ] [ Hardolaf      ] [ mgsloan       ] [ Saizan         ] [ xenophon      ]
20:41:10 <format> 00:37 [ CindyLinz       ] [ heath         ] [ miclorb       ] [ sajith         ] [ xilo          ]
20:41:11 --- kick: format was kicked by geekosaur (don't paste in the channel)
20:41:33 --- mode: geekosaur set -o geekosaur
20:41:44 <xilo> what the hell
20:42:16 <geekosaur> I'm guessing they slipped and pasted the contents of their irc window
20:42:24 <monochrom> yeah
20:42:55 <format> sorry about paste.
20:43:00 <format> missclick
20:44:45 <enthropy> NemesisD: use another quasiquoter. For example this one http://hackage.haskell.org/package/interpolatedstring-perl6-0.9.0
20:44:50 <format> I have this erros to transponce a matrix ,Program error: pattern match failure: head [].. im doing this whit this code...  trans x = (map head x)) ++ trans (map tail x). The cut condition is an empty list
20:45:33 <format> it is working but i need to cut before the error
20:45:37 <Saizan> ?src transpose
20:45:37 <lambdabot> transpose []             = []
20:45:37 <lambdabot> transpose ([]   : xss)   = transpose xss
20:45:37 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:46:29 <Saizan> that checks for the empty list
20:48:14 <enthropy> NemesisD: but if you insist on here, you can also change the String to a type that doesn't show with quotes. For example using  [i| ${Text.PrettyPrint.text "hi"} |]
20:50:49 <NemesisD> enthropy: i've got no loyalty to here. just found it today
20:51:08 <c_wraith> man, this is typo-prone.  I'm really glad that the compiler checks that the associated type family definition matches the instance head.
20:51:13 <NemesisD> sight unseen i'd still probably picked it over the other one because its the one without perl in the name
20:52:56 <guymann> h
21:00:15 <edwardk> i suppose all that HEq/HOrd crap can be simplified, by CPSing the equality witness code, etc.
21:00:41 <edwardk> class HEq f where heq :: f a -> f b -> ((a ~ b) => r) -> r -> r;   default heq :: HOrd f => f a -> f b -> ((a ~ b) => r) -> r -> r; heq fa fb e ne = hcompare fa fb ne e ne       class HEq f => HOrd f where hcompare :: f a -> f b -> r -> ((a ~ b) => r) -> r -> r
21:00:52 <c_wraith> The only thing that makes me sad about going to type families is that I really wish that :t in ghci would resolve type families that can be resolved.
21:01:47 <format> another think, if i have a map, but i what that the function i will map, its in the middle or at the last, like, map c [a,b] should result in a b c ( e.g, map (f 2) [a,b,c] should result in [f a 2, f b 2, f c 2]
21:02:41 <joelteon> what the heq?
21:04:42 <enthropy> > map (flip f 2 :: Expr -> Expr) [a,b,c]
21:04:43 <lambdabot>   [f a 2,f b 2,f c 2]
21:12:59 <ab9rf> hee
21:14:03 <Saizan> format: in general you'd use a lambda expression
21:14:34 <Saizan> format: e.g. map (\x -> f x 2)
21:14:50 <ab9rf> @pl \x -> f x 2
21:14:50 <lambdabot> flip f 2
21:17:14 <ion> map (`f` 2)
21:21:08 <c_wraith> ok.  Converted to a type family, the only remaining unsafe stuff is *everything about the FFI*, and renamed to a slightly better name..  http://lpaste.net/91358
21:24:57 <c_wraith> ...  Wow, Storable is actually pretty dangerous, now that I think about it.  It has all kinds of ways to write all over the wrong memory.
21:33:20 <tabemann> okay, question I should know the answer to
21:33:53 <tabemann> I want a thread to halt without exiting, so I am applying forever to some monad, but I need an IO monad that does absolutely nothing
21:34:11 <c_wraith> Err.
21:34:25 <johnw> tabemann: why not threadDelay for a really long time?
21:34:25 <c_wraith> I think you want something like forever $ threadDelay 10000000
21:34:32 <tabemann> that'd do it
21:35:13 <c_wraith> johnw: the problem with a single threadDelay is that it's limited to like 34 minutes on 32-bit systems. :)
21:35:22 <johnw> ah
21:35:33 <johnw> i forgot that people still use 32-bit systems :)
21:35:38 <c_wraith> Turns out, microseconds go *really* fast!
21:36:20 <c_wraith> also threadDelay has some RTS issues on 64-bit OS X with very large numbers.  I'm not sure anyone's figured out why.
21:37:41 <nerrz> does anyone use haskell-mode with emacs here?
21:38:36 <roboguy_> nerrz: I do. I'm definitely not an expert though
21:38:53 <nerrz> I am having an issue getting the indentation right
21:39:36 <johnw> c_wraith: interesting, I think I've run into that acutally
21:41:09 <nerrz> roboguy_: like, when you do C-x h and then tab, does it auto indent the file?
21:41:14 <tabemann> -Nx is the option to set the number of OS threads to occupy by default, x being the number, right?
21:41:15 <tabemann> (with +RTS I mean)
21:41:25 <johnw> yes
21:41:32 <johnw> if you omit x, it uses all cores on the system
21:41:56 <roboguy_> nerrz: you shouldn't autoindent blocks of haskell code
21:42:17 <roboguy_> there are too many different possible indentation levels, each with different meanings
21:42:21 * tabemann has found autoident doesn't work with Haskell
21:42:27 <tabemann> *autoindent
21:42:33 <johnw> i'm surprised people don't whinge about Haskell allowing whitespace indentation
21:42:45 <johnw> maybe because it's optional -- and yet no one I know takes advantage of that option
21:42:55 <johnw> i mean, semantic indentation
21:43:00 <edwardk> crdueck: https://github.com/ekmett/indexed/blob/master/src/Indexed/Map.hs
21:43:01 <edwardk> got bored
21:43:14 <edwardk> crdueck: didn't bother finishing it but i got it to start working at least
21:43:14 <tabemann> people don't like the idea of it, but it turns out that it really works out very well in practice, so no one doesn't actually use it
21:43:16 <nerrz> what is the standard for indentation then? I thought 4 spaces for each level
21:43:22 <tabemann> no no
21:43:37 * hackagebot type-digits 0.3 - Arbitrary-base type-level digits  http://hackage.haskell.org/package/type-digits-0.3 (NicolasFrisby)
21:43:39 * hackagebot type-ord 0.3 - Type-level comparison operator  http://hackage.haskell.org/package/type-ord-0.3 (NicolasFrisby)
21:43:40 <tabemann> haskell-mode under EMACS at least does *two* spaces for each level by default
21:43:41 * hackagebot type-cereal 0.3 - Type-level serialization of type constructors  http://hackage.haskell.org/package/type-cereal-0.3 (NicolasFrisby)
21:44:19 <roboguy_> nerrz: the problem is that for many (maybe even most) lines of haskell code, there are multiple valid indent levels and they all have different meanings
21:44:20 <c_wraith> Heh.  Just realized I never actually did anything that required PolyKinds.  Slightly simpler code, yay!
21:48:29 <dmj> nerrz: there's indent, identation, and simple-indent. I use indent. Unsure what is idiomatic tho. http://www.haskell.org/haskellwiki/Emacs/Indentation
21:49:54 <dmj> nerrz: this too: http://stackoverflow.com/questions/11365815/what-are-the-similarities-and-differences-among-haskell-indentation-modes-for-em
21:50:13 <johnw> i use indentation
21:50:16 <nerrz> dmj: what are your settings for the mode, or are the default?
21:50:32 <johnw> with the various offsets set to 4
21:50:38 <tabemann> I just use whatever the default is for haskell-mode
21:53:09 <dmj> nerrz: (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
21:53:36 <nerrz> johnw: ahh, I only set the first one to 4 and not all the keyword settings to 4
21:56:31 <nerrz> thanks for the help
21:56:46 <dmj> pluralsight.com acquired peepcode.com.. intellesting
21:57:58 <Ralith> Is there a way to say "Does not have tag x" using Distribution.Version?
22:03:19 <dmj> Ralith: can you say \y -> `notElem` y (versionTags x)
22:03:31 <dmj> except not infix
22:03:39 <Ralith> that works!
22:03:41 <Ralith> thanks
22:03:51 <dmj> cool! :)
22:04:08 <Ralith> for some reason whenever I'm given a set of operators I lose the ability to work outside of it
22:05:56 <dmj> ha same, do you use Distributed.Version on your larger projects?
22:06:23 <dmj> it kind of scares me to be honest
22:06:55 <dmj> Also, does anyone know if hackage2 builds on OSX? I couldn't get it to work.
22:08:07 <nonconvergent> Is this a good place to ask about darcs and cabal in addition to haskell itself?
22:08:21 <zRecursive> sure
22:10:33 <stevejb> hello, can someone running ubuntu 12.04 (64 bit) or upwards try to compile the following test code:
22:10:36 <stevejb> http://lpaste.net/2863634809991725056
22:12:53 <nonconvergent> Alright then. I grabbed some packages through darcs and installed them, and now I'd like to update them, mainly to try it with different build flags.  Is there anything to do to replace or uninstall them?
22:13:56 <zRecursive> `ghc-pkg unregister` && `rm -fr`
22:14:08 <nonconvergent> zRecursive: rm what?
22:14:24 <nonconvergent> The darcs-gotten sources?
22:14:28 <zRecursive> ~/.ghc and ~/.cabal
22:14:49 <zRecursive> find them in "~/.ghc and ~/.cabal"
22:14:53 <nonconvergent> What if I installed --global?
22:15:26 <zRecursive> `ghc-pkg list` to find them
22:19:50 <dmj> stevejb: will try on my kubuntu vm
22:20:09 <stevejb> dmj: thanks you.
22:26:32 <dmj> stevejb: fighting with gsl
22:29:45 <Saizan> nonconvergent: no real reason to rm anything, actually, usually you just issue a new cabal install which will overwrite the old stuff if the version number is the same
22:31:01 <stevejb> dmj: that is what I was curious about
22:31:12 <stevejb> are you getting a bunch of junk about cblas?
22:32:04 <hpaste> stevejb pasted ‚Äúcblas link error‚Äù at http://lpaste.net/91360
22:32:22 <dmj> yea
22:32:28 <dmj> sudo apt-get install libgsl0-dev
22:32:36 <dmj> to get around "cannot link gsl"
22:32:54 <dmj> oh hmm, yours is different
22:33:38 <stevejb> you may need sudo apt-get install liblapack-dev
22:34:55 <dmj> stevejb: ok, I'm getting the libgsl.so undefined ref
22:35:34 <dmj> stevejb: ill try in osx
22:35:39 <stevejb> dmj: thank you!
22:36:00 <stevejb> the strange thing is, I got it to work in a Debian VM but not in Ubuntu. They must be handling those libraries differently somehow
22:36:13 <stevejb> debian is the only platform where I have gotten it to build
22:37:20 <dmj> that is strange, was the gsl library on deb the same version as ubuntu?
22:37:52 <stevejb> I would think so. I thought that Ubuntu was a fork of debian. I am not sure how to check the version number directly
22:38:49 <dmj> I used 1.15 on kubuntu, and homebrew is installing 1.15 as well
22:39:04 <johnw> stevejb: cat /etc/debian_version?
22:39:29 <stevejb> jessie/sid
22:41:04 <dmj> works on OSX, (0.33333333333333337,3.700743415417189e-15)
22:41:13 <stevejb> dmj: excellent, thanks!
22:42:00 <stevejb> dmj: I am curious as to why it does not work in Ubuntu but works in Debian. I suppose for now I can move this particular project to the VM. Weird though. I emailed the author of hmatrix but for him it compiles on Ubuntu (although he uses 32 bit)
22:43:58 <dmj> stevejb: np, unless the version of gsl I installed was incorrect on ubuntu, I'm not sure either
22:47:28 <dmj> stevejb: One interesting thing to note. runhaskell Main.hs works on ubuntu, no errors
22:47:52 <dmj> stevejb: same with ghci
22:48:06 <dmj> stevejb: Do you need it compiled or can you run it as a script
22:48:31 <stevejb> dmj: I am incorporating that code into something that is going to be using some parallelism, so I think I need compiled right?
22:48:51 <stevejb> e.g. so I can run with -N20
22:50:54 <dmj> stevejb: yea probably. think I found the issue
22:51:19 <stevejb> dmj: oh yeah?
22:52:41 <dmj> stevejb: seems like its an issue with the linking order
22:52:47 <dmj> stevejb: http://askubuntu.com/questions/69316/problems-with-linking-gsl-cblas
22:53:31 <stevejb> dmj: is there a way to change the linking order on the command line?
22:54:15 <dmj> stevejb: trying to figure that out
23:00:45 <stevejb> dmj: awesome. Thank you so much for looking at this!
23:01:32 <dmj> stevejb: no prob
23:09:06 <sgk284> hey all, quick question about haskell and data composition / inheritance. I have a DirectedGraph data type, and want to implement a DirectedAcyclicGraph on top of that. I want this new data type to have the same functions as the DirectedGraph, except I need to change the behavior of inserting a new edge to check for cycles.
23:09:13 <sgk284> I've done it like this: https://gist.github.com/stevekrenzel/65d7c883831eddbc6718
23:09:26 <sgk284> which is the OOP equivalent of composition
23:09:52 <sgk284> but since everything else just proxies through to the directed graph, is there a Haskell equivalent of inheritance?
23:10:06 <sgk284> so that I'd only have to implement insertEdge on the DAG data type
23:10:26 <johnw> sgk284: there's two ways you can do that
23:10:45 <johnw> have your DirectedGraph type contain a collection of functions for working on values of that type
23:10:57 <johnw> and then, you override those functions when constructing a DAG value
23:11:11 <johnw> this is pretty much isomorphic to creating a Graph type class
23:11:21 <johnw> to represent operations common to all graph types
23:11:33 <johnw> (or at least, directed graphs)
23:12:17 <sgk284> johnw: thanks for the response, not quite sure I follow
23:12:25 <sgk284> so I'd create a class that is common to both? with default implementations
23:12:36 <sgk284> and override the implementation for the DAG instance?
23:12:46 <johnw> class DirectedGraph g where graphOperation :: g -> foo
23:13:02 <johnw> instance DirectedGraph DirectedAcyclicGraph where graphOperation g = ...
23:13:25 <johnw> but you don't _need_ to use type classes for this type of abstraction
23:13:27 <sgk284> interesting! thanks I'll give it a shot (still relatively new to Haskell)
23:13:28 <johnw> the alternative is:
23:13:51 <johnw> data DirectedGraph = DirectedGraph { graphOperation :: foo }
23:14:35 <johnw> makeAcylicDirectedGraph = DirectedGraph acyclicGraphOperation
23:14:43 <zvrba> isn't using a record with operations which gets passed around just an explicit way of doing what classes do behind your back?
23:14:57 <johnw> yeah, that's why I said the two approaches are isomorphic in this case
23:15:15 <johnw> the choice of which depends on how they will be _used_ more than anything else
23:15:25 <johnw> the type class approach can lead to annoying type signatures and type errors
23:15:37 <zvrba> ok
23:15:38 <johnw> the ADT approach feels more "manual", but for users it's way less confusing
23:16:05 <johnw> just fyi, I've used both approaches pretty extensively
23:16:10 <johnw> I now favor ADTs for this
23:16:16 <sgk284> thanks johnw, so in that second example, graphOperation would be a function that operates on the graph?
23:16:25 <johnw> a touch more work for me, but much easier to work with
23:16:27 <sgk284> never thought about putting functions in a data type definition... heh
23:16:32 <johnw> yes
23:16:40 <johnw> you'd have many graphOperation functions
23:16:55 <sgk284> makes total sense
23:17:03 <zvrba> hah, almost like doing OO in C. a struct of function pointers :-)
23:17:08 <johnw> it can get a little complicated if you need to employ recursion, in which case you'll need to tie the knot
23:17:16 <johnw> zvrba: exactly :)
23:17:18 <sgk284> ok
23:17:33 <dmj> sgk284: a function within a function
23:17:41 <dmj> http://shuklan.com/haskell/L06_files/inception.png
23:17:45 <zvrba> johnw: mm. i can see why it can be easier on the users :)
23:17:49 <sgk284> lol dmj
23:18:19 <sgk284> is the approach, with the explicit composition, bad form in Haskell? or simply not optimal?
23:18:26 <zvrba> johnw: i tried to make sense of Data.Vector.Unboxed, its mutable variant, etc. and the combination of type families and classes made it a hellish experience :S
23:18:36 <johnw> I see type classes as the right choice to express a common interface among disparate implementations; and ADTs as the right choice to abstract commonalities among similar implementations
23:19:25 <sgk284> thanks everyone, going to go explore these alternate routes now
23:19:28 <johnw> like, any two given monads may have absolutely nothing in common but the Monad interface
23:19:34 <johnw> while these two graph types will have a lot in common
23:20:07 <zvrba> johnw: why is recursion problematic when goind the ADT route?
23:20:12 <dmj> johnw: do you know if you can specify linking order in ghc when compiling haskell code that depends on C code?
23:20:49 <johnw> zvrba: let g = DirectedGraph { graphOperation = \x -> graphOperation2 g; ... } in g
23:21:26 <johnw> dmj: order of which elements?  C objects, Haskell objects, or libraries?
23:21:54 <johnw> generally the link line is going to be: <Haskell> <C> <Libs>, where each is in the same order as given in the .cabal file
23:26:48 <dmj> johnw: hmatrix depends on the gnu science libs and -lgslcblas is being linked as -lgsl, can I do something like ghc --make Main.hs -lgsl lgslcblas ?
23:27:05 <dmj> oops, meant to say they are being linked in reverse order
23:28:14 <johnw> oh
23:28:17 <johnw> that I know nothing abuot
23:31:34 <carter> johnw you got things working? :)
23:31:40 <johnw> in the end, yeah
23:31:47 <johnw> i had to split off the executable into another cabal project entireyl
23:31:54 <johnw> to avoid its compile flags from being clobbered
23:32:10 <carter> did someone say the word matrix?
23:32:22 <carter> sorry, connection dropped
23:32:22 <carter> you were syaing?
23:34:17 <dmj> carter: yes, hmatrix not compiling in ubuntu :(
23:34:29 <carter> dmj thats ok
23:34:41 <dmj> carter: speaking of which, hackage2, prob won't compile on OSX right
23:34:43 <carter> if you wait a few weeks you can use my stuff in tead ;)
23:34:50 <carter> eh?
23:34:54 <carter> dmj why's that?
23:35:00 <carter> oh yeah, you were the one i pointed to hackage2
23:35:10 <carter> right?
23:35:22 <dmj> carter: yea did a darcs get
23:35:33 <carter> whats the problem on macs?
23:35:35 <dmj> carter: hsenv cabal install *boom*
23:35:38 <carter> oh
23:35:41 <carter> don't use hsenv :)
23:35:45 <carter> use cabal install head
23:35:49 <carter> it has nice sandboxing :)
23:36:06 <dmj> oh? :) what is this head package
23:36:12 <johnw> he means cabal-install HEAD
23:36:16 <dmj> ahhh :)
23:36:32 <carter> and cabal HEAD
23:36:33 <carter> both
23:36:38 <carter> they're int eh same github repo
23:36:44 <carter> johnw thanks :)
23:36:57 <carter> also glad I got you half a hack into solving your lib stuff
23:37:06 <carter> splitting it into 2 packages + the hack got you through?
23:37:11 <johnw> yeah, thanks for your time
23:37:23 <johnw> yes, now I'm happily using C++11 in my soap client code
23:37:28 <carter> yay
23:37:32 <johnw> i really wanted unique_ptr and lambdas
23:37:35 <carter> helping the world be a less crusty place
23:37:41 <johnw> enough to sink another 2 hours into this mania today
23:37:58 <stevejb> dmj: just coming back online. Any progress on the linking?
23:38:14 <johnw> exception safety is an unappreciated art
23:38:45 <carter> johnw eh?
23:38:49 <carter> what'd happene next?
23:38:57 <carter> dmj what were you error messages
23:39:03 <dmj> stevejb: no :( these c++ guys had the same error, they fixed it by rearranging the linking order, but unsure how to do that from ghc
23:39:03 <johnw> i mean, I wanted unique_ptr in order to write exception safe code
23:39:06 <dmj> stevejb: http://askubuntu.com/questions/69316/problems-with-linking-gsl-cblas
23:39:21 <stevejb> dmj: thank you.
23:39:38 <dmj> stevejb: no prob hope it works out
23:40:07 <stevejb> dmj: I think I will just work in the Debian VM for now. Perhaps I will email the mailing list and see if someone recognizes it. I really appreciate the help.
23:40:11 <carter> stevejb dmj  hopeful you can be free of such pains in a few weeks ;)
23:40:18 <carter> mwhahaha
23:40:20 <stevejb> carter: hopefully! :)
23:40:23 <carter> johnw what sort of exceptions
23:40:35 <johnw> carter: any and all
23:40:37 <carter> stevejb, bscarlet  is preventing me from too much yak shaving
23:40:43 <carter> johnw: how so?
23:40:47 <johnw> how do you mean?
23:40:53 <stevejb> carter: although this particular stuff was not matrix related. just using hmatrix for its access to GSL's numerical integration
23:41:05 <carter> ah
23:41:21 <carter> stevejb : use the ad  package!
23:41:28 <carter> and build your own numerical integrators
23:41:56 <carter> johnw: what sort of exceptions does unique_ptr handle? (i need to look up what it is )
23:42:04 <dmj> carter: after 'cabal install HEAD' "no pkg named head" *doing it wrong*
23:42:06 <johnw> carter: unique_ptr is the new auto_ptr
23:42:20 <carter> dmj: go to github
23:42:24 <johnw> it's the partner to shared_ptr and weak_ptr
23:42:28 <carter> github.com/haskell/cabal/
23:42:50 <carter> cd cabal ; cabal install; cd ../cabal-install ; cabal install
23:42:52 <carter> and know joy
23:42:57 <carter> ah
23:43:01 <carter> johnw: thanks
23:43:01 <johnw> when you have a unique_ptr value, it's supposed to mean "This is the *only* pointer to the allocated block; ownership can be transferred, but references can be duplicated"
23:43:13 <johnw> s/cannot be duplicated
23:43:19 <carter> ah
23:43:40 <carter> staticly
23:43:46 <johnw> it's an optimization over shared_ptr's for which there is only ever 1 or 0 refcounts
23:43:46 <carter> or dynamicly?
23:43:59 <johnw> anyway, this isn't really Haskell :)
23:44:04 <carter> true
23:44:18 <carter> i'm Rusty on such things
23:44:24 <carter> pun inteneded
23:44:25 <dmj> johnw: is that a new c++11 feature?
23:44:29 <yitz> carter: i heard cabal head sandboxing is good, we're planning on switching to it soon when we have the time. but hsenv and cabal-dev are fine. we use cabal-dev. if a package doesn't build in cabal-dev, the package is broken and should be fixed. same for hsenv i assume.
23:44:41 <johnw> dmj: yes, unique_ptr replaces the now deprecated auto_ptr
23:44:44 <carter> yitz they work differently
23:44:52 <carter> so a blanket assumption is wrong
23:45:11 <yitz> carter: yes but they make no assumptions outside of what a proper cabal package is required to provide.
23:45:37 <carter> true, but it does dmj  no harm to be using the cabal provided functionality
23:45:43 <yitz> indeed
23:45:47 <carter> because that one actually has engineering support
23:45:59 <carter> the others are no longer actively deved
23:46:05 <carter> to my understanding
23:46:26 <yitz> carter: they are no more than a thin wrapper for cabal-install. if that has engineering support, then so do they.
23:46:45 <carter> yitz it is 240am and I don't feel like having a pointless debate
23:47:00 <carter> cabal sandbox provides INTER sandbox support
23:47:07 <carter> and there are some subtletie sthere
23:47:24 <carter> and cabal gets right (once i helped them id the bugs)
23:47:29 <yitz> not pointless. we are a commercial shop. it is extremely important to us that basic infrastructure like the build system works. and not just bleeding edge, either; we need to use stable stuff.
23:47:36 <carter> yes
23:47:40 <carter> i'm not talking to you though
23:47:42 <carter> i'm talking to dmj
23:47:44 <yitz> heh
23:47:55 <carter> yitz theres a reason i'm writing simd code in C
23:47:56 <yitz> ok :)
23:48:03 <carter> so that peple like you can be conservative and have nice things
23:48:07 <carter> rather than writing my code in ghc head
23:48:22 <carter> as long as you're using at least ghc 7.6 :)
23:48:25 <carter> hehe
23:48:39 <carter> i agreed tradeoffs exist
23:48:39 <haasn> Has anybody written a workable C compiler in Haskell?
23:48:39 * hackagebot fixed-storable-array 0.1.0.0 - Fixed-size wrapper for StorableArrays, with its own  Storable instance  http://hackage.haskell.org/package/fixed-storable-array-0.1.0.0 (CarlHowells)
23:48:46 <carter> haasn theres no reason to
23:48:47 <carter> :)
23:48:50 <carter> clang is pretty nice
23:48:57 <carter> and it'd take a lot of work
23:49:02 <carter> to do something nicer than clang
23:49:13 <carter> haasn: johnw may have opinions on how good/ bad idea that is
23:49:15 <yitz> umm... switching to it today. :) actually, we will probably still need to use older ghc to provide bug fix releases for our older versions. for quite a while.
23:49:24 <carter> ah
23:49:27 <carter> whats your biz again yitz ?
23:49:39 <yitz> http://suite-sol.com/
23:49:41 <haasn> carter: heh, just mild curiosity here; speaking to colleague and he says no C compiler on the market is sane :)
23:50:04 <carter> haasn clang is the only one that is written so you can use it as a library too
23:50:11 <carter> and it gives decent error messages
23:50:13 <dmj> carter: which is the official repo? the darcs or github one
23:50:20 <carter> github
23:50:24 <carter> the one i linked you to
23:51:00 <carter> yitz thats terrifyingly enterprise focused :)
23:51:14 <dmj> haasn: http://hackage.haskell.org/package/hcc
23:51:22 <yitz> carter: indeed. this tool is entirely haskell: http://www.suite-sol.com/pages/solutions/suitehelp.html
23:51:38 <yitz> carter: other stuff too. most of our newer stuff. a lot of other stuff not haskell though.
23:51:52 <carter> yitz do you have any math going on inside?
23:51:53 <carter> :)
23:51:59 <carter> probably not
23:52:03 <ninegrid> what is DITA
23:52:03 <yitz> carter: only in my head
23:52:15 <ninegrid> I want to produce it
23:52:15 <carter> some acronym?
23:52:20 <yitz> ninegrid: kind of docbook for enterprise
23:52:26 <ninegrid> ah, ok
23:52:31 <yitz> invented by IBM
23:52:42 <carter> the king of enterprise
23:52:45 <carter> ish
23:53:02 <ninegrid> IBM is awesome, still
23:53:10 <carter> they sold their thinkpad arm
23:53:21 <dmj> yitz: that's awesome, haskell for the real world
23:53:33 <carter> dmj theres a lot of haskell at a lot of places
23:53:39 <carter> just a small fraction of the world though
23:53:43 <carter> even though its a large set
23:54:02 <yitz> ninegrid: it's a very different style of writing than docbook though. it abandons the book metaphor entirely. you write small semantically contained components, then weave them in various ways into different publication formats.
23:54:18 <ninegrid> carter: yes but they transcended into beings of light... or something. no longer manufacturing corporeal forms
23:54:19 <yitz> carter: growing quickly
23:54:36 <carter> yitz ihope to be one such statistic soon
23:54:53 <yitz> carter: great! good luck
23:55:18 <dmj> carter: where? I get SF and NY, but def. not chicago :-/ just a bunch of java
23:55:46 <carter> dmj you have to create/be the change you want to see in the world
23:55:47 <carter> :)
23:56:04 <carter> there are 1-2 haskellers in chicago area who are trying to do their own wee bizzes
23:56:05 <yitz> ninegrid: walsh claimed (in a famous post) that dita could have been done within docbook, and that ibm re-invented his wheel. but anyway, that's what enterprise tech doc departments are using now.
23:56:54 <yitz> carter: ah you're a chicagoan? i lived there for a few years.
23:57:01 <dmj> carter: that's the dang truth. yea I met jeremy awhile back and luke at a meetup. I was in an unenlightened state tho
23:57:25 <dmj> yitz: what neighborhood?
23:57:47 <yitz> was at u of c but commuted from the north side
23:57:52 <carter> yitz i'm in nyc :)
23:58:08 <carter> i meant I know some folks who are in chicago who came to hackphi the past 2 years
23:58:10 <yitz> ah ok. guess dmj is the chicagoan?
23:58:19 <carter> dmj Luke  is the dude i was thinking of
23:58:38 <carter> if thats the right handle
23:58:47 <dmj> yitz: ha no way, I'm at u of c. hyde park can be shady :)
23:59:01 <dmj> carter: yes! Luke was talking about going to hacPhi and I was like whats that
23:59:14 <carter> dmj awesomeness, thats what hacphi is
23:59:33 <carter> i may have been a bit mean during the fplcomplete presentaion
23:59:48 <carter> and a presentation where the lib was gpl so i can't look at it
23:59:52 <yitz> dmj: when i came to the campus the first time to interview, they told me the boundaries where i could walk. e.g., only walk on the south side of 47th st, not the north side. etc.
