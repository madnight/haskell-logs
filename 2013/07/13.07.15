00:03:09 <Gracenotes> they both have weird names.
00:04:29 <Gracenotes> hm, haskellwiki down for a while now?
00:04:49 <johnw> migrations are in process
00:05:23 <Gracenotes> to the fanciest new hardware?
00:05:36 <johnw> new VMs, if that counts :)
00:06:36 <Gracenotes> how fancy
00:07:00 <Gracenotes> that is what internet archive is for. among other things.
00:45:25 <Lethalman> finger trees only have O(1) prepend and append of element? not insertion?
00:48:08 <ijp> Lethalman: arbitrary insertion is logarithmic
00:48:15 <Lethalman> ijp, ok
00:48:17 <ijp> more or less
00:48:26 <Lethalman> I don't see any api in hackage though
00:48:40 <opqdonut> insertion at index i is O(log(min(i,n-i)) IIRC
00:48:50 <alpounet> Lethalman, Data.Sequence uses it
00:48:56 <ijp> opqdonut: note the "more or less"
00:49:03 <opqdonut> Lethalman: inserting at i is done by split, append concat
00:49:09 <opqdonut> ijp: I wasn't refuting you :)
00:49:11 <Lethalman> opqdonut, ok
00:49:24 <Lethalman> and how do I lookup the index given an element?
00:49:39 <opqdonut> in general, linear search
00:49:52 <Lethalman> right, with a view I guess
00:50:04 <Lethalman> ok thanks
00:50:08 <Lethalman> I was reading about finger search trees
00:50:22 <Lethalman> which should be a little the opposite in terms of complexity, O(1) lookup
00:50:27 <Lethalman> but I couldn't find an implementation in hackage
00:50:35 <johnw> Lethalman: findIndex?
00:50:46 <gunio> Reckity knick knack the rep tep hegger.  Isn't it awful how it's jeckally jewish?
00:50:48 <gunio> Partinks spee spaga speel scrap.  Ruda Trooda.  Ejection request.  Heffy the jello wup.  Juffo-wup!  rab locid rebbasmoth.  The Proteus Animal Plannable.  Poo da Boo!  need 10-15 people straight  Groaning my grurch nords.  Ruh ninna knaw knife
00:50:50 <gunio> agrillio mellish.  Blakes my bog.  kedda mah go go mageezik  Renna manuck to the ruthafied sneffal  The Rump Shaking Rider Crew - Fuck You!  Wren a men a menna menna moo, filling my jolts and filling my shoe, plenk a  peek a pokie zal nawl knife
00:50:52 <gunio> Shaar nag lililly linomp nip.  Many mini minotaur taurs, hate tar tar sauce.  I am a robibbob meme.  Have you ever thought about where the bird goes?  Squirnish Mernish.  Jelly jolaggalan joo!  Chuh lap lap rillip.  Oh I grew three years.  I'm old now.
00:50:52 --- mode: ChanServ set +o johnw
00:50:54 <gunio> Does anyone heck teck the rooga beega bagga?  Hebber master hoon a ferr fee.  Hilly a mackhole.  The shiny dot in the middle of a liddle light, of the middle of a lep lep lains!  Gotta get that schit ass shcrap  biteoad.  Ruproudj a malef loo
00:50:55 <gunio> Moistie bather.  riberian schmecklef  Mulla Malee loo lup the new flood wars.  Chuddy dip, chuddy dip, chuddy microchip.  Bucka lucka loo, bucky lucky blay.  Bucka lucky blay lee.
00:50:57 <Lethalman> :t findIndex
00:50:57 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
00:50:58 --- kick: gunio was kicked by johnw (Kicked by johnw)
00:50:59 <gunio> Burpaline: The wonder world.  Salmy magoo goal greggats  Rump duh duh duh dump, duh duh duh demp doop dump, runna nuh nah  Riggity ass gaggags  i nick  Roddan raldwell  Roady carewell reggal mahole  Rup tup shmelly smelly shmebb ub.  Roady farewell rose bose mahaggal.  A pocahontas watch
00:51:01 <gunio> Blubbity ash hoosh her mellopath.  a Maticake for my buddy andy  Oh we-heh-heh-hell I'm thinking about the greg nargs, I'm thinkin about you!  End midal too walkin' with a dolphin.  I went up that street, you went up another street, we all up the presidio.  I'm goin out with arsenio!
00:51:01 --- mode: ChanServ set +o mauke
00:51:01 --- mode: mauke set +b *!*@114.108.49.105
00:51:05 <Lethalman> johnw, that's not Data.Sequence
00:51:28 --- mode: johnw set -o johnw
00:51:30 <opqdonut> Lethalman: you can use finger trees for all sorts of things depending on what you "measure" the elements with
00:51:51 <opqdonut> Lethalman: with a constant measurement measure(x)=1 you get Data.Sequence
00:52:25 <opqdonut> Lethalman: with a priority measurement you get a priority queue
00:52:31 <opqdonut> etc
00:52:35 <Lethalman> I see, that's nice
00:52:56 <opqdonut> finger trees are a very general idea
00:53:10 --- mode: mauke set -o mauke
00:53:34 <Lethalman> I was reading about finger search tree
00:53:42 <opqdonut> here's another example: if you store bits in your fingertree, and measure(0)=(1,0) and measure(1)=(1,1)
00:53:45 <Lethalman> but didn't see an implementation in hackage
00:53:54 <Lethalman> they should be a binary search tree but with the finger idea
00:54:05 <opqdonut> then you get a sequence that you can index with both the index, and "give me the i'th 1"
00:54:07 <Lethalman> can't believe it's not in hackage :P you guys implement all sort of theoretical stuff
00:54:27 --- mode: ChanServ set +o johnw
00:54:28 <opqdonut> "binary search tree without the finger idea" sounds like a binary search tree :)
00:54:30 --- mode: ChanServ set +o johnw
00:54:32 <opqdonut> (with data in the leaves)
00:54:55 <Lethalman> oh
00:54:57 --- mode: johnw set -o johnw
00:55:03 <Lethalman> right
00:55:11 <Lethalman> opqdonut, I still haven't got the head around measure
00:55:17 <Ghoul_> Lethalman: not this? http://hackage.haskell.org/packages/archive/fingertree/0.1.0.0/doc/html/Data-FingerTree.html
00:55:37 <Lethalman> Ghoul_, that's finger tree, not finger search tree
00:55:50 <Ghoul_> Oh, sorry.
00:56:48 <Ghoul_> Does anyone know why I get a few ambiguous type errors here? http://lpaste.net/90920 -- Cause of the error /might/ be MonadState should be implied by MonadChrono but I'm unsure how without wrecking the other constraints
00:57:05 <opqdonut> Lethalman: I don't have experience with "finger search trees", but wikipedia says " It should not be confused with a finger tree"
00:57:09 <sopvop> if you measure with "max" you will get search tree, or not?
00:57:45 <opqdonut> sopvop: yes
00:58:16 <opqdonut> (you obviously also need to keep ordering when inserting)
00:58:18 <Lethalman> huh?
00:59:06 <sopvop> sure
00:59:17 * Lethalman must understand that paper :S
01:03:21 <sopvop> fingertree paper has chapter 4.7 Application: ordered sequences
01:28:25 * Lethalman a little confused
01:28:35 <Lethalman> why Data.Sequence adds instance Functor FingerTree
01:28:47 <Lethalman> and Data.FingerTree has instance Functor (FingerTree v)
01:29:14 <xunie-laptop> Is there a function in prelude that's (tail $ init)?
01:29:24 <Taneb> Lethalman, they are different FingerTrees
01:29:35 <Hafydd> :t tail $ init
01:29:36 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'
01:29:36 <lambdabot>     In the second argument of `($)', namely `init'
01:29:36 <lambdabot>     In the expression: tail $ init
01:29:47 <Hafydd> :t tail . init
01:29:47 <lambdabot> [a] -> [a]
01:29:50 <Hafydd> Do you mean that?
01:29:50 <kosmikus> shachaf: saw you asking about the LambaPi paper. http://www.kosmikus.org/LambdaPi/ should have links to all the different versions of the paper.
01:30:28 <Hafydd> Anyway, no, there isn't.
01:31:09 <Lethalman> Taneb, ah Data.Sequence doesn't use Data.FingerTree
01:31:22 <shachaf> kosmikus: I was asking about it?
01:31:40 <xunie-laptop> Hafydd, yes, I meant that.
01:31:42 <shachaf> Anyway, yes, I remember seeing that page at one point.
01:31:48 <Lethalman> why is that? I expected a dependency on fingertree by containers
01:38:33 <kosmikus> shachaf: it was in my log; you mentioned it during the weekend, also wondering about different versions. but perhaps you weren't wondering for yourself, but pointing it out to someone else. if so, then sorry. I didn't read up all the context of the log.
01:38:48 <ijp> has anyone tried writing a haskell OS for the rPi?
01:39:20 <Ghoul_> ijp: there exists a "Haskell OS"
01:39:36 <Ghoul_> I personally think a more interesting project would be a haskell environment (shell + tools) running above UNIX
01:39:49 <Ghoul_> /s/UNIX/Linux
01:47:55 <alpounet> Lethalman, I guess containers' implementation is tuned for performance (well, for GHC at least)
01:48:20 <Lethalman> alpounet, I see, the difference is that it uses unpacked Int directly instead of the Measure v
01:48:25 <Lethalman> that might be the difference
01:48:41 <shachaf> kosmikus: Oh, right.
01:48:50 <mstksg> is there a monadic while loop?
01:48:52 <shachaf> kosmikus: Yes, someone asked about it, I think.
01:49:09 <mstksg> like monad's forever, except it halts when the return matches a criteria
01:49:11 <mstksg> or doesn't match
01:49:12 <shachaf> mstksg: http://hackage.haskell.org/package/monad-loops
01:49:18 <alpounet> Lethalman, yeah, I guess it happens to be enough for Data.Sequence
01:49:19 <mstksg> shachaf: thanks :)
01:50:17 <Lethalman> alpounet, that lets me think about the actual usage of fingertree package though, that's only a theoretical example?
01:50:41 <Lethalman> I'd like to read about the choice made by Seq to not use Data.FingerTree
01:51:14 <ijp> "less overhead" probably
01:52:10 <ijp> ah, nvm, already mentioned
01:53:46 <Lethalman> eeeek haskell wiki seems down
02:08:07 <gspr> Is hoogle in pain? It keeps serving me with weird mime types
02:08:18 <shachaf> Yep.
02:08:23 <gspr> poor hoogle
02:10:39 <FreeFull> gspr: Give it a hug
02:11:28 <gspr> I don't wanna catch whatever it has ;)
02:12:22 <FreeFull> gspr: Not a disease =P
02:19:20 <gspr> Oh, now I see the channel topic. That answers my question, I guess :)
02:23:13 <irene-knapp> Hoogle is down.  I'm sure there will be complaints about it throughout the day; I'm just staking my claim to have mentioned it first. :(
02:23:32 <shachaf> You are late by many hours.
02:23:35 <shachaf> See topic.
02:23:35 <irene-knapp> drat!
02:23:39 <irene-knapp> oh, lol
02:23:41 <irene-knapp> hackage too eh
02:23:48 <shachaf> No.
02:24:03 * irene-knapp applies Reading Comprehension L5
02:24:06 <irene-knapp> ah, noted
02:24:29 <irene-knapp> (previously I had been using the Reading Incomprehension L1 skill, which implements the same interface...)
02:24:54 <irene-knapp> I'm glad they're finally migrating.
02:24:57 <irene-knapp> Where are they migrating to?
02:25:06 <eroen> Greenland.
02:25:14 <benmachine> where it's cooler
02:25:21 <irene-knapp> mm
02:25:25 <benmachine> they'll come back in the winter
02:25:32 * irene-knapp would like to see it all cloud-ified rather than this constant switching between data centers
02:25:34 <benmachine> or perhaps this is just what I wish I was doing
02:25:35 <irene-knapp> but oh well
02:28:55 <adnap> lol
02:28:57 <adnap> What the hell
02:29:09 <adnap> Visiting Hoogle downloads a BIN file
02:31:19 <irene-knapp> yes, I know
02:31:36 <mauke> seems to be the hoogle executable
02:31:48 <irene-knapp> oh, that would make sense
02:31:55 <irene-knapp> now the real question is, will it accept a POST request :)
02:32:31 <shachaf> It was the Hoogle executable when I recklessly downloaded and ran it earlier.
02:32:50 <shachaf> (Well, I did run it in gdb. But still somewhat recklessly.)
02:33:08 <irene-knapp> lol
02:33:58 <mauke> ^@^@^@^@^@^@^@[]^@^@^@^@^@^@( w_s16ys{v} [lid] :: <nt>main:Hoogle.DataBase.Instances.Instances{tc rSgQ} ) <nt>main:Hoogle.DataBase.Instances.Instances{tc rSgQ}^@^@^@^@^@Pattern match failure in do expression at src/Hoogle/DataBase/TypeSearch/Graphs.hs:106:13-28
02:34:24 <quchen> Also it's 28 megs
02:34:29 <quchen> Hoogle is quite a beast it seems
02:34:41 <irene-knapp> hm
02:35:09 <irene-knapp> anyway, www.haskell.org/hoogle doesn't work either, topic notwithstanding
02:37:03 <shachaf> See the bit after the first semicolon and before the second semicolon.
02:38:03 <shachaf> Is there a better way to phrase the topic?
02:38:05 <irene-knapp> "expect turbulence"?  yeah, no, I know
02:38:15 <irene-knapp> the phrasing is probably fine, it's just too early in the morning for me
02:38:33 <irene-knapp> and I was hoping that doing something magic would make everything work for me again without my having to think
02:38:49 <MasseR> irene-knapp: You can always use hayoo
02:39:05 <irene-knapp> ugh, yeah, lol
02:39:13 <irene-knapp> I really just wanted hackage's doc repo
02:39:20 <irene-knapp> which could be a static site, but apparently is not
02:39:34 <irene-knapp> hoogle was just a convenient way to find what I wanted in it
02:39:50 <merijn> Breaking news: Hoogle breaks, productivity of haskellers worldwide drops by 80%
02:40:51 <irene-knapp> har
02:42:00 <adnap> Is there something like maybe, but with type "Monoid a => b -> (a -> b) -> a -> b", and definition "f y g x = if memty x then y else g x"?
02:42:10 <adnap> Er
02:42:25 <adnap> "f y g x = if x == mempty then y else g x"
02:51:16 <quchen> adnap: mempty isn't a function, and in general you cannot check whether something is equal to mempty (as that requires Eq).
02:52:15 <quchen> adnap: The point of the "maybe" function is being the deconstructor of the Maybe type, very similar to what foldr is for List.
02:52:35 <quchen> "maybe" replaces all "Just" with a custom function "f", and "Nothing" with some constant.
02:53:01 <quchen> You can't transfer that generality to (just) an arbitrary monoid, but you can of course define the function you mentioned yourself.
02:57:46 <supki> you can also have IsEmpty typeclass with isEmpty :: IsEmpty a => a -> Bool and redo as many Monoid instances as you want yourself (sort of what Control.Lens.Empty does, but less abstract)
03:09:48 <ChongLi> haskell.org/hoogle is now a 28MB bin file?
03:10:02 <mauke> haskell.org/hoogle is now hoogle
03:10:44 <ChongLi> haskell.org is a default page for the web server
03:11:18 * hackagebot yesod-dsl 0.1.1.3 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.3 (TeroLaitinen)
03:11:34 <merijn> ChongLi: See topic
03:21:26 <danr> no hoogle today? :(
03:23:55 <gspr> This thing with /hoogle serving up the hoogle binary… there's no password or other sensitive info sitting inside the binary, I hope?
03:23:57 <alpounet> danr, I think there is a blog post with instructions on how to set up a local one
03:25:19 <Hugh_> hello, why can I do (+3) 5 and get 8 but (-3) 5 gives an error not the expected 2 ? thanks
03:25:33 <Kinnison> because (-3) is negative 3
03:25:40 <gspr> Hugh_: - means two different things
03:25:50 <Kinnison> :t (-3)
03:25:50 <lambdabot> Num a => a
03:25:54 <Kinnison> :t (- 3)
03:25:54 <lambdabot> Num a => a
03:26:01 <Kinnison> :t (-) 3
03:26:01 <lambdabot> Num a => a -> a
03:26:04 <Kinnison> :_)
03:26:06 <Hugh_> ok, makes sense
03:26:47 <Hugh_> so if I want a partial function which will take a single param and subtract 3 I need (- 3)
03:27:33 <Kinnison> More like ((-) 3)
03:27:49 <gspr> Kinnison: But that will have 3 as the left hand argument
03:27:49 <Kinnison> although that's not quite right
03:27:50 <Kinnison> erm.
03:27:56 <Kinnison> ((flip (-)) 3)
03:27:57 <Hugh_> yeah, sorry that what I meant! Thanks for your help
03:28:34 <zvrba> hello
03:29:30 <zvrba> consider the following problem: given a polygon with all sides parallel to coordinate axes, cover it with the minimal number of rectangles.
03:29:48 <zvrba> any suggestions on how to 1) represent the polygon, 2) search for the solution
03:29:59 <merijn> hughfdjackson: You might want to use subtract
03:30:01 <merijn> eh
03:30:07 <merijn> oh, he left
03:30:12 <zvrba> i' trying to solve this one: http://www.reddit.com/r/dailyprogrammer/comments/1hkpwz/070313_challenge_125_hard_robo_room_service/
03:30:25 <zvrba> i think I can solve the rest, except the polygon covering
03:59:54 <Ghoul_> > (-3) 5
03:59:55 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
03:59:55 <lambdabot>    arising f...
04:01:24 <Tinned_Tuna> > ((-)3) 5
04:01:26 <lambdabot>   -2
04:01:35 <Tinned_Tuna> (-3) is not a section.
04:01:42 <Tinned_Tuna> :t (-3)
04:01:43 <lambdabot> Num a => a
04:01:51 <Tinned_Tuna> :t ((-)3)
04:01:52 <lambdabot> Num a => a -> a
04:02:04 <merijn> You want
04:02:09 <merijn> > subtract 3 5
04:02:10 <lambdabot>   2
04:02:16 <Ghoul_> Does anyone know why I get a few ambiguous type errors here? http://lpaste.net/90920 -- Cause of the error /might/ be MonadState should be implied by MonadChrono but I'm unsure how without wrecking the other constraints
04:03:53 <Hugh_> haskell.org and hoogle are down! In fact Haskell.org has been deleted
04:04:11 <`Jake`> haskell.org works for me
04:04:13 <Ghoul_> Hugh_: read the topic
04:04:30 <Hugh_> ?
04:04:41 <Hugh_> ahh!
04:04:44 <Ghoul_> "haskell.org in the middle of migration; expect turbulence;" :)
04:04:45 <merijn> Hugh_: haskell.org is being migrated, the redirect is broken
04:04:57 <merijn> Hugh_: www.haskell.org works, but hoogle and some other things are down
04:05:15 <Hugh_> ta
04:06:53 <silasm> holy shit ST is awesome. Just by switching to STArrays I turned what was like a 3-minute decompression into a 7 second one
04:07:08 <silasm> why have I never used this before
04:07:32 <FreeFull> I don't know
04:07:48 <FreeFull> silasm: Maybe you want to look at vectors or repa
04:08:57 <silasm> will do. I'll have to see about making an ST Trie so I can speed up the compression too. Gonna turn this project into an fp complete tutorial, so hopefully I can make it decently fast. I've learned a lot myself so hopefully the tutorial helps people :)
04:09:23 <Saizan> Ghoul_: if you want the full ChronoS s e you need "CronoT get", otherwise you only get 's'
04:09:42 <Saizan> Ghoul_: same for put
04:10:00 <Ghoul_> Sorry I don't follow
04:10:39 <Saizan> Ghoul_: the MonadState instance for (CronoT s e m) is declared with a state type of 's'
04:11:01 <Saizan> so using get and put for CronoT you're only going to get and put 's'
04:11:25 <Ghoul_> Oh okay
04:11:35 <Saizan> if you wrap them in the ChronoT constructor you are using the put and get from the wrapped StateT monad
04:11:50 <Saizan> so you access the full ChronoS s e type
04:13:46 <Ghoul_> OH it's so obvious now Saizan, thanks a lot!
04:14:04 <Ghoul_> Took me a while to understand what you mean but I feel really stupid now ;)
04:16:08 <Saizan> cheers :)
04:16:21 <Ghoul_> thanks :)
04:36:20 * hackagebot GLFW-b 1.1.0 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.1.0 (BrianLewis)
04:38:33 <banister`sleep> can someone give an exmaple of a haskell data type that is just a functor and not an applicative functor?
04:43:45 <srhb> banister`sleep: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
04:45:02 <elliott> ugh, that top answer refers to "cofunctors" :(
04:45:32 <elliott> haha, and says Void is a Monoid
04:49:14 <banister`sleep> srhb: thanks
04:49:27 <banister`sleep> srhb: is one example of a funcotr but not an applicative functor a binary tree?
04:49:43 <banister`sleep> it's easy to write fmap for a binary tree but i couldn't think of a reasonable implementation for <*>
04:49:59 <Breadmonster> haskell.org is down for some reason.
04:50:05 <Breadmonster> Or at least, it appears to be down.
04:50:07 <ijp> see topic
04:50:13 <Breadmonster> Oh, right, sorry.
04:50:38 <Breadmonster> Okay, is there a function that counts the number of times a particular element appears in a list?
04:50:58 <elliott> you can construct one easily
04:50:59 <elliott> using length and filter
04:51:10 <Breadmonster> I can, but I was thinking of a fold, actually.
04:51:14 <Breadmonster> In any case, is there one?
04:51:19 <Breadmonster> Or do I have to define it?
04:51:30 <srhb> I think it's too simple to be defined in the Prelude for sure.
04:51:56 <srhb> > length . filter (==2) $ [1,1,2,2,3,3,4,2]
04:51:57 <lambdabot>   3
04:52:31 <srhb> @hoogle [a] -> a -> Int
04:52:32 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
04:52:32 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
04:52:32 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:52:52 <Breadmonster> count test = foldl' (\e x -> if test x then e + 1 else e)
04:53:05 <elliott> count p = length . filter p
04:53:11 <Breadmonster> Okay, fine, yeah.
04:53:18 <Breadmonster> But isn't it better to use the foldl?
04:53:20 <FreeFull> banister`sleep: I'm thinking a <*> for binary trees would work somewhat like <*> does for lists by default
04:53:24 <srhb> Breadmonster: Why?
04:53:58 <FreeFull> banister`sleep: Although a ziptree implementation is possible too assuming there aren't constraints
04:54:02 <Breadmonster> srhb: because filter constructs a new list, so memory allocation/deallocation while the length means that there's going to be an additional pass through the list?
04:54:29 <ijp> length .: filter for the golfers
04:54:46 <FreeFull> Well, that's what you intuition says, but have you actually tested both?
04:54:47 <ijp> but then you'd need to import it/define it
04:54:47 <Breadmonster> srhb: Or that isn't how it works?
04:54:51 <FreeFull> I demand data
04:54:59 <srhb> Breadmonster: The "new list" will be consumed immediately by length.
04:55:06 <srhb> Breadmonster: The algorithm should be O(1) in space
04:55:35 <alpounet> length will ask for the elements to filter, directly
04:55:44 <Breadmonster> Yeah, but I was talking about allocation.
04:55:58 <Breadmonster> Instead, won't the strict fold just result in one value?
04:55:59 <benmachine> Breadmonster: sometimes optimisations will eliminate intermediate data structures
04:56:09 <merijn> Fusion, yay!
04:56:17 <ijp> compiler writers are smart. Who knew?
04:56:20 * hackagebot GLFW-b-demo 1.0.1 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.1 (BrianLewis)
04:56:24 <benmachine> Breadmonster: there's been a lot of work on ensuring that if something creates a list and then something else immediately eats it, then you can rewrite the code so no list is ever created
04:56:32 <benmachine> er
04:56:40 <benmachine> for "you" read "the compiler"
04:56:41 <elliott> Breadmonster: I suggest you look at the Core.
04:56:44 <benmachine> I don't
04:56:44 <elliott> it will give a direct answer
04:56:45 <srhb> Breadmonster: Look up "stream fusion" - if you're interested.
04:56:46 <benmachine> I suggest you profile
04:56:53 <benmachine> if you even care that much
04:57:06 <elliott> facts are better than approximations, for something this simple
04:57:20 <elliott> if you want to know whether it involves intermediate cons cells core willgive you the answer immediately
04:57:28 <Breadmonster> I actually don't care because it won't make too much of a difference.
04:57:35 <Breadmonster> But I like how smart Haskell is.
04:57:38 <Breadmonster> What's Core?
04:57:40 <benmachine> elliott: yeah but if what you want to know is whether or not it is fast, the best way is to go check how fast it is :P
04:57:54 <elliott> Core is GHC's intermediate language.
04:57:57 <srhb> Breadmonster: It's one of the lower-levels that the compiler translates your Haskell to.
04:57:57 <elliott> @hackage ghc-core
04:57:57 <lambdabot> http://hackage.haskell.org/package/ghc-core
04:57:59 <elliott> is a pretty good tool
04:58:06 <elliott> (though you want to pass -dsuppress-all usually...)
04:58:08 <benmachine> Haskell gets compiled to Core then from there to machine code or whatever
04:58:11 <Breadmonster> elliott: And it's a whole langauge in itself?
04:58:22 <elliott> it basically looks like really simple haskell.
04:58:25 <benmachine> it's not a language that you'd ever write code in
04:58:27 <elliott> though the semantics aren't quite the same.
04:58:29 <benmachine> but it is a whole language
04:58:37 <elliott> benmachine: I've wanted to write Core before.
04:58:53 <elliott> for free access to dictionary passing
04:58:59 <srhb> Breadmonster: The idea, I think, is to translate Haskell through gradually simpler languages where optimizations can more readily be introduced.
04:59:25 <benmachine> srhb: it isn't always a case of "simpler = more optimisable", mind
04:59:43 <Breadmonster> Alright.
04:59:49 <benmachine> you apply optimisations before, after and during simplification :P
04:59:49 <Breadmonster> Okay, and I have to look up stream fusion?
04:59:53 <srhb> benmachine: Aye.
04:59:55 <banister`sleep> FreeFull: just out of curiosity when i <*> on a list i apply each function from the LHS list to the RHS list and then concat the results, i can imagine the first part with binary trees, but how would i then 'concat' the results togther with threes?
05:00:07 <benmachine> Breadmonster: you don't *have* to, but it's cool and interesting and will help you understand why you shouldn't stress about list functions too much
05:00:09 <banister`sleep> trees*
05:00:12 <srhb> Breadmonster: It's nice to know about at least, so you know that length . filter is completely viable
05:00:40 <FreeFull> banister`sleep: I haven't thought it out fully
05:01:11 <FreeFull> banister`sleep: A zippy applicative instance for binary trees would be easy enough because you'd just discard any branches that aren't in both trees
05:01:12 <elliott> stream fusion isn't what's used for lists byd efault
05:01:13 <elliott> afaik
05:01:19 <srhb> benmachine: Aye, I guess I should have worded it as "... where some optimizations are easier" :P
05:01:23 <elliott> it's foldr/build fusion
05:04:01 <DarkFox> What was the lambdabot command to serialize binary data?
05:05:18 <notdan> Does anyone where familiar with proxies/pipes? I want to plug in producer to the server, but I am not sure how to do that
05:06:12 <quchen> notdan: Did you read the tutorial? http://hackage.haskell.org/packages/archive/pipes/3.3.0/doc/html/Control-Proxy-Tutorial.html
05:07:18 <notdan> quchen: yes, I did
05:08:43 <notdan> I still don't undestand how to do that
05:17:40 <quchen> notdan: I don't think you can use Server and Producer together. http://lpaste.net/90922
05:18:08 <quchen> You'll always have to match the uninhabited type C with something else
05:22:58 <notdan> quchen: well I want produced value to go into the server, so I want b from the Producer match b' from the Server
05:24:26 <quchen> notdan: Maybe CoProducer is what you're looking for? It's the inverted version of a producer, it sends values upstream
05:24:30 <DarkFox> notdan: hey dan
05:25:26 <notdan> quchen: hm, yeah that might be it
05:25:35 <irene-knapp> I think it's generally the case that when people tell you what their names are (or aren't), and you want to address those people, you should use them (or not, as appropriate).
05:25:37 <notdan> quchen: I guess I should just stick to uni-directional pipes for a while
05:25:40 <notdan> DarkFox: hello there
05:25:57 <ocharles> notdan: hi, I use pipes quite a lot
05:26:02 <ocharles> notdan: did you solve your problem?
05:26:12 <DarkFox> :)
05:26:32 * DarkFox continues thinking for events for his event server
05:26:36 <DarkFox> and protocol
05:27:16 <notdan> ocharles: not really. Maybe Server is not what I need at all
05:27:32 <ocharles> notdan: paste some code and I'll see if I can help
05:27:53 <benmachine> notdan: is that Maybe as in the type or as in you think Server might not be what you need at all? :P
05:27:54 <notdan> ocharles: I am writing an IRC bot, so I thought it would be nice to have a Server interface to a channel
05:28:08 <notdan> well I've already deleted that code and decided to take a different approach
05:28:22 <notdan> benmachine: the latter :)
05:28:25 <ocharles> notdan: Ok, what is the request type for that Server though?
05:28:40 <ocharles> (or was)
05:30:16 <notdan> well, in the nutshell I wanted to connect those two: http://lpaste.net/90924
05:31:19 <ocharles> notdan: with what type of expected behaviour? Those are two pipes that produce things, so you would want to use monadic composition
05:31:59 <ocharles> (which would give you one Proxy that produces things)
05:32:39 <ocharles> Producer == Server (), so your final proxy would be Server String, and you have to decide what requests cause you to use the prompter, and what requests go to proxy1
05:32:52 <notdan> I want to create a closed pipe. I want to connect the prompter to prox1 in the way that the output of prompter goes to the proxy1
05:33:15 <notdan> And then I want to send the output of proxy1 somewhere else
05:34:35 <ocharles> notdan: it sounds like proxy1 should not be a server then, but is instead a general Proxy
05:35:05 <ocharles> notdan: but I don't quite understand what the intention of proxy1 is
05:36:03 <ocharles> As it stands now, it's something that passes downstream requests upstream, printing them, and produces an infinite monotonic sequence downstream
05:37:23 <ocharles> If you want to send prompter into proxy1, you have to flip prompter round with 'turn'
05:37:42 <notdan> Yes. It a very oversimplified model of a server. It gets requests from upstream, sends them to a handle, produced infinite amount of data downstream from another handle
05:39:48 <ocharles> notdan: ok, turn (or literally replacing respond with request in prompter) should let you connect them with pull composition
05:39:54 <notdan> I don't really understand 'turn'. My proxies has types like :: (Proxy p) => b' -> p a' a b' b, but turn requires something of a type (p a' a b' b)
05:40:59 <ocharles> notdan: that means the first request has to go in. If b' == (), then 'turn (p ())'
05:42:22 <notdan> Oh, I see
05:43:34 <ocharles> turn on a Producer String will give you a Client String ()
05:44:00 <ocharles> (so something that never requests turns into something that only requests)
05:51:11 <notdan> Ok, it compiles now, but the integers are not being printed: http://lpaste.net/90925
05:51:55 <luite> notdan: oh cool, switching to pipes to get streaming results?
05:52:36 <ocharles> notdan: that's because nothing downstream ever requests
05:53:11 <ocharles> oh wait, turn prompter is requesting, hm
05:53:26 <ocharles> I think it's because the integer from proxy1 is consumed by 'turn prompter'
05:53:29 <ocharles> nothing causes that to flow downstream
05:53:43 <quchen> ocharles: So "turn" takes a proxy and converts every request to a response, and vice versa?
05:53:48 <ocharles> yes
05:54:06 <bitonic`> not really Haskell, but: is there a package to display type derivations in Html?
05:54:16 <quchen> ocharles: Is that just to avoid code duplication, or can I use it do do something new?
05:55:30 <ocharles> quchen: just lets you reuse components in the opposite direction
05:57:57 <notdan> ocharles: but how can the integers be consumed by the turned prompter if it consumes only ()?
05:58:28 <Zenol> Hi. Is it me or hoogle is down since yesterday?
05:58:43 <ocharles> notdan: oh, you have printers in between. hrm
05:58:47 <elliott> Zenol: see topic
05:59:49 <Zenol> elliott> Ohw, thanks ^^'
05:59:54 <ocharles> notdan: so at the moment this program doesn't terminate, but nothing gets printed to stdout?
06:01:06 <elliott> Zenol: :)
06:01:28 <notdan> ocharles: nope :(
06:02:08 <notdan> Also, this might be related: http://lpaste.net/90926 runit asks for user input 4 times (as expected) and runit2 does not terminate
06:04:19 <ocharles> notdan: debugD s = execD (putStrLn s), btw
06:04:41 <mikeplus64> i'm using MVars to implement a loop that runs every n seconds (where i have one thread puting to it every n seconds, and the other trying to take from it constantly). is this ideal, or is there some other abstraction i'm maybe missing?
06:06:25 <ocharles> notdan: I think the problem is with unitD, which never requests
06:06:28 <DarkFox> Ymm
06:06:31 <DarkFox> Hoogle down?
06:06:40 <ocharles> notdan: unitD just forever responds with ()
06:06:58 <DarkFox> haskell.org in the middle of migration well.. Strange that a query is spamming me with binary data.........
06:07:09 <ocharles> notdan: so I don't think you want to be composing with those
06:07:35 <DarkFox> No I do not wish to download a 28.0MB file from hoogle... I want my search results -___-
06:07:38 <DarkFox> lol
06:07:53 <Maior> ah yes, it looks like it's serving the hoogle binary
06:08:22 <ocharles> notdan: I think you might want to map upstream or downstream to ()
06:08:36 <ocharles> notdan: so fromListS [1..] >-> unitU  becomes
06:08:37 <ocharles> argh
06:08:48 <ocharles> fromListS [1..] >-> unitU  ->  fromListS [1..] >-> mapU (const ())
06:09:17 <DarkFox> Maior: Indeed :P
06:09:42 <DarkFox> Maior: I have a feeling that is what we call a bug :P
06:10:11 <notdan> ocharles: ah, I see
06:10:30 <notdan> ocharles: yeah, this work flawlessly, thanks :)
06:11:48 <ocharles> notdan: Also worth noting is that pipes API will change fairly drastically in version 4.0.0, which is only around the corner
06:12:12 <ocharles> changing for the better imo - no more pipes transformers, no more Proxy type class, and much more emphasis on simpler types
06:12:13 <quchen> ocharles: What? Oh.
06:12:27 <quchen> ocharles: Are you the maintainer?
06:12:38 <ocharles> most things in the prelude are now Producers, Consumers or Pipes -- and you 'generalise' them as you see fit
06:12:57 <ocharles> notdan: not a maintainer, but quite active in this area (I have a few pipes-* libraries that I will be releasing with 4.0.0)
06:13:32 <quchen> Is the concurrent one among those by any chance? :-)
06:14:49 <quchen> Oh, the Github readme says "concurrency" is part of the main "pipes" package.
06:15:47 <notdan> ocharles: oh :( well I guess I picked the wrong time to start playing with pipes
06:16:06 <luite> quchen: is that what used to be pipes-concurrency?
06:16:40 <ocharles> notdan: I don't think you did, a lot of these concepts will carry forward to 4.0.0
06:16:45 <ocharles> I encourage carrying on :)
06:16:46 <quchen> luite: It still is, I just abbreviated it.
06:16:54 <notdan> ok, thanks :)
06:17:07 <ocharles> quchen: pretty sure pipes-concurrency still exists
06:17:09 <luite> quchen: oh but it's a separate package in pipes 3.x now
06:17:23 <quchen> luite:  "The core pipes ecosystem consists of the following four libraries:  [...] pipes-concurrency: Message passing and reactive programming [...]"
06:17:30 <luite> ah i see
06:17:48 <CADD> ocharles: that sounds cool!
06:18:00 <CADD> ocharles: about pipes 4.0.0 and all
06:18:34 <CADD> ocharles: any articles or notes about it?
06:18:35 <ocharles> i'm stoked on the API in 4.0.0
06:19:13 <ocharles> https://groups.google.com/forum/#!topic/haskell-pipes/7Wlk9C6tlMo
06:19:37 <Kinnison> Are pipes like conduits?
06:19:50 <ocharles> Kinnison: yep
06:19:54 <quchen> Eh wait, pipes 4.0.0 has only 4 source files?
06:20:09 <quchen> Feels like a lot was removed then
06:20:15 <tomboy64> hm
06:20:16 <ocharles> quchen: 5 with Pipes.hs
06:20:19 <CADD> ocharles: Thanks!
06:20:20 <tomboy64> "It works!"
06:20:30 <tomboy64> can i have haskell.org back now, please?
06:20:38 <ocharles> quchen: all the pipes transformers have gone (in favour of base monad transformers), the Proxy type class has gone (in favour of just ProxyFast)
06:20:43 <ocharles> and some deprecated stuff has gone
06:20:44 <quchen> ocharles: 4 without tutorial.hs :P
06:20:52 <ocharles> quchen: :)
06:20:58 <srhb> tomboy64: www.haskell.org
06:21:16 <notdan> ocharles: wait, there will be no pipe transformers? Ah, I liked those :(
06:21:52 <ocharles> notdan: all the functionality is in monad transformers
06:21:58 <tomboy64> srhb: The requested URL /hoogle/ was not found on this server.
06:22:01 <tomboy64> :(
06:22:05 * tomboy64 sad
06:22:36 <CADD> @@ tomboy64 @hoogle a -> (a -> b) -> b
06:22:36 <lambdabot>  tomboy64
06:22:36 <lambdabot>  Prelude ($) :: (a -> b) -> a -> b
06:22:36 <lambdabot>  Data.Function ($) :: (a -> b) -> a -> b
06:22:36 <lambdabot>  Prelude ($!) :: (a -> b) -> a -> b
06:22:51 <quchen> ocharles: Pipes transformers?
06:22:54 <ocharles> notdan: So (Monad m, Proxy p, StateP Int) => p a' a b' b m r  becomes  Monad m => Proxy a' a b' b (StateT Int m) r
06:23:01 <quchen> I haven't used most of the advanced stuff yet
06:23:07 <ocharles> Which is much simpler, imo
06:23:10 <quchen> Pipes are still polymorphic over some base monad, right?
06:23:17 <ocharles> yep
06:23:20 <tomboy64> thanks CADD
06:23:22 <quchen> Good.
06:23:31 <ocharles> though you might have to 'hoist lift' a little more often
06:23:32 <tomboy64> this is one thing i prefer to do with my browser, though
06:23:35 <ocharles> if you are mixing monads all the time
06:23:38 <CADD> tomboy64: np
06:23:40 <notdan> ocharles: but then it would be messier to compose them
06:23:47 <notdan> yeah
06:23:55 <CADD> tomboy64: idk, i like cerminals, or ghci! :)
06:24:06 <ocharles> occasionally yes, but a lot work for just any 'Monad m'
06:24:10 <ocharles> so in those cases it just works out
06:24:22 <ocharles> it only gets a bit messy when you have stuff that's based on IO, and something else wants to add state
06:24:34 <CADD> tomboy64: http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
06:24:37 <ocharles> but even then, you could generalise to MonadIO m
06:25:27 <quchen> Wow, the diagrams got a level up http://lpaste.net/90927
06:25:34 <CADD> tomboy64: s/cerminals/terminals/
06:26:03 <ocharles> quchen: Yea, I want to replace those with real pictures though (hopefully produced by 'diagrams')
06:26:09 <CADD> quchen: what is that?
06:26:10 <ocharles> ascii art only goes so far
06:26:23 <quchen> CADD: Random picture from the Pipes 4.0.0 docs
06:26:33 <CADD> quchen: cool
06:26:47 <ocharles> (that picture is respond composition, iirc)
06:26:50 <quchen> CADD: It comes with additional text
06:26:51 <CADD> quchen: ah, right \>\
06:27:50 <notdan> @hoogle hoist
06:27:50 <lambdabot> No results found
06:28:09 <ocharles> notdan: check the mmorph package for hoist
06:29:11 <ocharles> hoist is fmap for monads
06:30:47 <notdan> thanks
06:31:09 <ocharles> so 'StateT Identity' could be 'mapped' into 'StateT IO'
06:32:03 <notdan> right, so it's like fmap for monad transformers
06:32:12 <ocharles> yea
06:33:56 <ocharles> Ok, time for lunch
06:43:58 <byorgey> ocharles: should be fun to make a little DSL for describing your wiring diagrams which can then generate images via 'diagrams'
06:44:45 <byorgey> ocharles: we don't currently have good support for drawing arrows, but I have just finished adding a lot of generic features to support nice arrows and they are slated for the 0.7.1 release.
06:59:04 <quchen> ocharles: In the 4.0.0 API, how do I map over values flowing upstream? There's only "map" which is a Pipe, is there some way to get a CoPipe out of that?
06:59:23 <quchen> There doesn't seem to be a "turn" function
07:00:12 <quchen> Or is the desired behaviour captured by one of the five different pipe categories
07:00:31 <ocharles> quchen: turn is now reflect, I believe
07:00:52 <ocharles> quchen: but you can also use request composition
07:01:20 <quchen> You're right, "Reflect switches the upstream and downstream ends"
07:01:36 <ocharles> quchen: foor
07:01:38 <ocharles> erm
07:01:40 * ocharles tries that again
07:02:27 <ocharles> quchen: mapU f foo = (f . request) \>\ foo
07:02:28 <ocharles> iirc
07:02:53 <quchen> I was hoping I wouldn't need \>\ :P
07:03:01 <ocharles> wait, make that (fmap f . request)
07:03:03 <quchen> That operator is a little mysterious
07:03:19 <ocharles> that says 'whenever foo requests, instead run fmap f request'
07:04:56 <quchen> So "pull" starts requesting a value from the most downstream pipe, right?
07:05:18 <ocharles> quchen: yea
07:05:20 <quchen> Push is the same thing, but on the other end: the initial request is pushed into the pipe from the most upstream pipe
07:05:29 <ocharles> right
07:05:39 <quchen> Request and respond confuse me.
07:05:42 <ocharles> pull composition is the most intuitive to the haskell programmer, because it nicely models lazy evaluation
07:06:51 <quchen> Push/pull feel like the old semantics, while the new request/respond have crazy diagrams.
07:07:06 <ocharles> quchen: request and respond composition are a little scary, yea
07:07:36 <ocharles> But one way to think of them is that 'request' makes a hole, that can be filled in with any monadic action returning a value
07:09:11 <quchen> ocharles: The plumbing analogy seems to fail with request/respond
07:09:36 <quchen> It makes me think of a braid (and that's not just because the pictures look like one)
07:09:45 <applicative> let drain = request ();
07:09:47 <ocharles> quchen: analogy's suck :)
07:10:14 <applicative> let openSpigot = request () ?
07:10:17 <ocharles> they always fail somewhere, the whole point of them is to omit information to build the similarity
07:11:02 <applicative> let read_ = request (); write = respond -- <-- my preference
07:14:34 <applicative> well i seem to have recovered the idiom brackets implementation from the she-preprocessor https://github.com/michaelt/her
07:14:42 <applicative> what mankind has so long been sighing for!
07:16:28 <killy9999> @hoogle [Maybe a] -> Bool
07:16:29 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
07:16:29 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
07:16:29 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:16:36 <elliott> hm, I should write -XIdiomBrackets for GHC
07:16:40 <elliott> it would be nice to have a proper implementation
07:16:41 <dropdrive> Is there a nicer way of writing: something >>= (return . Just) ?  Hoogle is down so it's ahrd to play around
07:16:49 <applicative> elliott: yes.
07:17:02 <quicksilver> dropdrive: yes
07:17:10 <applicative> they seem not to be as awesome as one hopes, but they're awesome
07:17:10 <elliott> it sounds easy enough
07:17:11 <killy9999> dropdrive: lift Just
07:17:19 <elliott> of course that is because I have never tried to modify GHC
07:17:23 <applicative> maybe if it was rock solid it would be genuinely awesome
07:17:23 <elliott> so I'm sure it's practically impossible
07:17:30 <quicksilver> :t \f -> f >>= (return . Just)
07:17:31 <lambdabot> Monad m => m a -> m (Maybe a)
07:17:39 <elliott> I wonder how fast recompiling GHC is for development purposes though
07:17:41 <Twey> dropdrive: fmap Just something
07:17:43 <elliott> if you're only changing some things
07:17:43 <quicksilver> :t liftM Just
07:17:44 <lambdabot> Monad m => m a1 -> m (Maybe a1)
07:17:47 <elliott> since this machine is slow
07:17:50 <Twey> :t fmap Just
07:17:51 <lambdabot> Functor f => f a -> f (Maybe a)
07:17:54 <dropdrive> Thanks.
07:18:01 <haasn> dropdrive: x >>= return . f  =  fmap f -- it's a law
07:18:05 <Twey> (assuming your monad is also a Functor, of course, as it should be)
07:18:23 <Twey> dropdrive: You can also write it infix with <$> from Control.Applicative if that's your thing.
07:19:58 <dmwit> dropdrive: It's possible you want to use MaybeT; then what you just wrote is more like "lift something" than "fmap Just something".
07:20:20 <dropdrive> Twey: That is kind of my thing, thanks.
07:20:38 <dropdrive> dmwit: Sadly I don't understand that (yet).
07:20:39 <Gracenotes> haasn: hm. funny how similar pure f <*> x = fmap f is
07:21:13 <applicative> (|f x|) Gracenotes, please!
07:21:23 <ocharles> applicative: ghc plugin or gtfo
07:21:29 <Gracenotes> is my lack of idioms brackets / causing a racket?
07:21:32 <dmwit> dropdrive: No time like the present!
07:21:43 <applicative> Gracenotes: https://github.com/michaelt/her
07:22:57 <parcs> > (115-111)/115
07:22:58 <lambdabot>   3.4782608695652174e-2
07:22:58 <Gracenotes> yes, >>= and <*> conveniently come with ways of bringing functions into their purview, applicatives by lifting the function and monads by composing a function
07:23:28 <Gracenotes> if you're into fmap, I guess.
07:24:31 <HugoDaniel> :)
07:29:30 <Hugh_> I was under the impression that textToString was in Prelude?
07:29:35 <dropdrive> In attoparsec, isn't parseFoo <|> parseBar supposed to be the same as parseBar <|> parseFoo?
07:29:41 <Hugh_> I get a not in scope
07:29:58 <Hugh_> have a Text, want a String...
07:30:01 <dropdrive> (Assuming parseFoo and parseBar can't *both* succeed)
07:30:03 <Hugh_> Text -> String
07:30:14 <Twey> Hugh_: Text isn't in base, so how could textToString be in Prelude?
07:30:35 <Twey> Hugh_: The function you want is called ‘unpack’ and it's in the Text module you're using
07:30:58 <Hugh_> ok, then the FPComplete docs are wrong..
07:30:58 <Hugh_> I assume it is in Data.Text?
07:31:17 <elliott> hm, what fpcomplete thing says that?
07:31:42 <dmwit> dropdrive: No, I don't think so.
07:31:56 <dmwit> That's not a promise.
07:31:58 <nomeata> Hi. For a lightning talk on „Real World Haskell“ applications, I am collecting a list of these. Only programs for non-programmers quality. So far I have xmonad, Nikki and the robots, Chrodify, git-annex, hleder and (shamless plug) arbtt. I might or might not add darcs. Anything else to add?
07:32:11 <Twey> Hugh_: If you're using Data.Text, then yes
07:32:11 <Twey> There's also Data.Text.Lazy.unpack if you're using Data.Text.Lazy
07:32:28 <Hugh_> so when in hoogle I search for 'textToString' I get a link to BasicPrelude
07:32:34 <quchen> nomeata: Hoodle, a note-taking program: http://ianwookim.org/hoodle/
07:32:43 <Twey> nomeata: Raincat!
07:32:48 <quchen> And of course GHC.
07:32:50 <Hugh_> thanks Twey
07:32:52 <shoret> yes, definitely hoodle
07:33:04 <nomeata> quchen: GHC does not qualify, as it is a programmer’s tool.
07:33:06 <Twey> GHC is mostly for programmers, surely
07:33:21 <quchen> Oh, I overlooked that.
07:33:35 <Twey> Likewise xmonad, to some extent.  I'm not sure what benefit you'd get from xmonad if you couldn't program Haskell.
07:33:44 <Twey> Maybe Bluetile.
07:33:48 <elliott> people come to haskell from xmonad sometimes
07:33:52 <elliott> it's just another config language to some degree.
07:34:05 <nomeata> Twey: xmonad is a corner case, but I believe that there userswho don’t „program haskell“ but managed to configure it.
07:34:20 <Twey> They're not really its target audience, though, I think
07:34:45 <shoret> @nomeata: yi
07:34:45 <lambdabot> Unknown command, try @list
07:35:06 <benmachine> am I the only person who thinks lambdabot should use a different command character
07:35:24 <quchen> ?pl \x -> x
07:35:24 <lambdabot> id
07:35:26 <quchen> Tadaa.
07:35:28 <elliott> am I the only person who thinks people should use a different addressing character
07:35:30 <b2coutts> I used xmonad for a long time before learning haskell
07:35:36 <shoret> eh, I should remember my IRC
07:35:39 <b2coutts> it's nice as a simple minimalistic tiling window manager
07:35:45 <b2coutts> and basic configuration can be done without knowing haskell
07:35:46 <ijp> Twey: and most normal users don't care about wms as much as programmers
07:35:54 <Yaniel> am I the only one who thinks a nick should be enough for addressing people
07:36:00 <quchen> elliott: Well, "at" is a little more of an addressing character than it is a IRC bot command character.
07:36:02 <Twey> elliott: Or no addressing character
07:36:05 <merijn> elliott: Naah, it gets twitter uses rid of this awful @ notation for adressing people
07:36:10 <nomeata> shoret: I also have certain requirements as to popularity and visiblity, and I am not sure how popular yi is outside the set of people who use it mainly because it is written in Haskell.
07:36:15 <nomeata> But my perception of yi might be wrong.
07:36:18 <Twey> We should use ℕ instead.
07:36:21 <elliott> I don't think anyone uses yi.
07:36:32 <haasn> we don't need addressing characters. “Name: Foo” works fine on IRC
07:36:40 <shoret> elliott: they should!
07:36:42 <haasn> and I see no reason to change it
07:36:46 <shergill> not even dons?
07:37:02 <quchen> nomeata: Detexify's backend is written in Haskell, and if your audience is somewhat scientific (uses Latex) many have used it already.
07:37:26 <nomeata> quchen: it is? I thought I hacked on that a long time ago, and don’t remember Haskell.
07:37:26 <mapreduce> Presumably we should also change the # to something else because of twitter's hashtags.
07:37:37 <nomeata> but maybe I was just hacking on the frontend
07:37:39 <shergill> oh. did not know.
07:37:45 <mapreduce> which are #justthegermanwayofcomposingwords in disguise.
07:37:47 <quchen> nomeata: Here's the repo: https://github.com/kirel/detexify-hs-backend
07:38:19 <elliott> there's yitz's thingy that I forget what it is.
07:38:25 <elliott> but I remember it's written in Haskell!
07:38:49 <quchen> nomeata: The new version isn't in Haskell anymore though, it's JS and Ruby. Luckily, it's not released yet and seems to be vapory.
07:38:57 <nomeata> quchen: ok :-)
07:40:29 <quchen> nomeata: The new version recommends \beta when I draw \otimes. Haskell gooo ;-)
07:40:46 <ijp> mapreduce: atLeastItIsn'tCamelCase
07:40:57 <ijp> oh wait, this is #haskell
07:41:07 <ijp> you guys like that sort of thing
07:41:17 <shergill> lol
07:41:22 <FreeFull> BetterCamelThanPascal
07:41:34 * hackagebot hakyll-agda 0.1.6 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.6 (FrancescoMazzoli)
07:41:41 <quchen> Let's not have a camel case vs underscore war.
07:41:53 <ijp> quchen: actually, I'm on the side of hyphenation
07:41:57 <shergill> i do miss lisp's flexibility in being able to use / - _ etc in variable names
07:41:59 <ijp> but I agree
07:42:01 <luite> or use both, like GHC does
07:42:41 <FreeFull> > let a_b = 'a' in a_b
07:42:42 <lambdabot>   'a'
07:42:56 <FreeFull> shergill: See, you can  use underscores
07:43:02 <FreeFull> > let a-b = 'a' in a-b
07:43:03 <lambdabot>   'a'
07:43:11 <FreeFull> And -
07:43:12 <benmachine> FreeFull: cheater :P
07:43:14 <applicative> hah
07:43:16 <FreeFull> > let a/b = 'a' in a/b
07:43:16 <lambdabot>   'a'
07:43:19 <FreeFull> And / =P
07:43:25 <shergill> lol
07:43:30 <benmachine> > let a-b-c = 'a' in "oh no this doesn't work"
07:43:31 <lambdabot>   <hint>:1:5: Parse error in pattern: a - b
07:43:36 <quchen> > let d'_'b = 2 in d'_'b
07:43:36 <quchen> :-)
07:43:37 <lambdabot>   2
07:43:43 <FreeFull> =P
07:44:18 <shergill> one hyphen ought to be enough for anybody
07:45:15 <FreeFull> > let a_b_c = 'a' in "x"
07:45:16 <lambdabot>   "x"
07:45:20 <quchen> > let a-b = "yes it does" in a-b -- benmachine
07:45:21 <FreeFull> _ still works =P
07:45:21 <lambdabot>   "yes it does"
07:45:42 <benmachine> quchen: that's a different thing
07:45:47 <FreeFull> Of course, the same thing wouldn't work in ghci
07:45:53 <FreeFull> I'll let you figure out why
07:45:56 <quchen> benmachine: Pssst
07:46:10 <benmachine> FreeFull: which same thing?
07:46:52 <cartocor> hoogle is down?
07:46:59 <Maior> /topic
07:47:03 <benmachine> FreeFull: oh, I see what you mean
07:47:18 <applicative> cartocor: https://www.fpcomplete.com/hoogle
07:47:33 <cartocor> thanks
07:47:38 <Adeon> I went to hoogle and it downloaded some mysterious executable
07:47:43 <byorgey> hoogle works, you might have to be sure to use www.haskell.org/hoogle instead of haskell.org/hoogle
07:47:56 <byorgey> it works for me at the moment, at least
07:48:14 <applicative> the fpcomplete version has some nice features
07:49:10 <kartlos> http://www.haskell.org/hoogle/ sends me some crazy .dms file
07:50:03 <applicative> Oh I thought it was the hoogle executable i was getting
07:50:13 <FreeFull> Hoogle is sick
07:50:36 <applicative> >it beginsELF
07:51:08 <kartlos> applicative: it's possible that it's (part of) the executable
07:51:12 <applicative> ELF> rather
07:53:53 <FreeFull> @hoogle test
07:53:53 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
07:53:53 <lambdabot> Test.HUnit.Base data Test
07:53:53 <lambdabot> Test.QuickCheck.Test test :: State -> (StdGen -> Int -> Prop) -> IO Result
07:54:03 <FreeFull> That's local to lambdabot I think
07:54:19 <quchen> I wish FPComplete could tell us who they're consulting.
07:54:22 <quchen> Same for Galois.
07:54:45 <quchen> They seem like they're not doing so bad, so there's got to be someone paying for their staff.
07:55:04 <Maior> you mean who's consulting them? ;P
07:56:13 <Y-Less> Hi, is anyone else having problems with Hoogle?  I tried to connect in two different browsers and both claim it is a application/octet-stream download of 28Mb that downloads almost instantly, and not a web page
07:56:25 <quchen> Y-Less: see topic
07:56:46 <benmachine> but as people have observed, www.haskell.org/hoogle doesn't work either
07:56:55 <quchen> Y-Less: You can use FPComplete's Hoogle in the meantime, https://www.fpcomplete.com/hoogle
07:57:39 <Y-Less> Yes, I should have read the topic first!  Sorry, that's a complete nweb mistake!
07:59:54 <lpaste> nabilhassein pasted “code golfing with case and bind” at http://lpaste.net/90928
08:00:20 <nabilhassein> i feel like i remember what i'm going for in this super-short paste being possible, but i can't find it
08:00:31 <nabilhassein> does anyone know how to do it?
08:03:11 <Urchin[emacs]> how do I see the present working directory in ghci?
08:03:53 <quchen> Urchin[emacs]: :!pwd
08:04:22 <quchen>  :! executes a system command, pwd prints the working directory.
08:04:24 <byorgey> nabilhassein: you can do it with the LambdaCase extension
08:04:30 <byorgey> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#lambda-case
08:04:36 <Urchin[emacs]> quchen: thanks
08:04:48 <byorgey> getArgs >>= \case [] -> ...
08:05:18 <applicative> :! ls
08:05:38 <applicative> :! pwd
08:05:58 <byorgey> /irc/freenode/#haskell
08:06:42 <applicative> or of course System.Directory.getCurrentDirectory
08:07:18 <nabilhassein> byorgey: is that new in ghc 7.6?
08:07:25 <applicative> oh i see, irssi was hiccuping again.
08:07:27 <byorgey> nabilhassein: yes.
08:07:28 <Urchin[emacs]> applicative: that last one is windows?
08:07:54 <saep> getArgs >>= \x -> case x of [] -> ...
08:07:58 <nabilhassein> byorgey: i guess it's time to upgrade. thanks for the pointer, that's exactly what i had been looking for!
08:08:04 <applicative> Urchin[emacs]: sorry, I didn't add anything, irssi was sleeping when I answered you question, so i didn't see the responses
08:08:10 <byorgey> nabilhassein: you can also just do what saep wrote above.
08:08:19 <byorgey> nabilhassein: I doubt it is worth upgrading just for LambdaCase.
08:08:33 <byorgey> though if you already wanted to upgrade for other reasons, I guess there's no time like the present.
08:08:36 <Urchin[emacs]> applicative: it's ok
08:09:05 <byorgey> Urchin[emacs]: on windows, you might want something like  :! dir
08:10:13 <applicative> how long has lambdacase been around?
08:10:25 <quchen> 7.6?
08:10:59 <applicative> oh is that all.  hm, I think nabilhassein might do well to upgrade if it's not a nightmare anyway
08:11:01 <quchen> 7.6. http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/release-7-6-1.html
08:11:18 <applicative> lambdacase is strangely good, it inlines well, for example
08:11:48 <quchen> applicative: Is it somehow better than \x -> case x of ..?
08:11:56 <quchen> Other than brevity of course
08:12:02 <applicative> quchen: that is my magical belief yes
08:12:30 <applicative> but my evidence is not too strong...
08:12:33 <quchen> I'll take that as a no then.
08:13:19 <applicative> no, I have observed it, but I don't know what the contexts are
08:13:38 <applicative> \x -> case x of ..., does in fact involve a layer of indirection
08:14:27 <quchen> Probably similar to how (== x) isn't always equal to (\y -> y == x)
08:15:04 <elliott> it is
08:15:08 <elliott> it's (x ==) that might not be
08:15:34 <nabilhassein> in my real context, it's really not a big deal at all
08:15:57 <nabilhassein> i'm just idly code golfing, haha
08:16:51 <quchen> elliott: Oh. Wait, what's going on here
08:17:04 <nabilhassein> how often does ubuntu update the haskell platform? it appears to have been on 7.4 for some while
08:17:40 <b2coutts> nabilhassein: I think ubuntu has testing repos you can use if you want more recent software
08:17:42 <klrr_> nabilhassein: in latest ubuntu there is none, ghc, and the standard libs are in seperated packages
08:18:28 <elliott> quchen: eta expansion
08:19:07 <quchen> (x ==)  =  \y -> (x ==) y
08:19:08 <quchen> ?
08:19:23 <quchen> = \y -> (==) x y
08:19:43 <quchen> And now I'm stuck.
08:20:14 <roconnor> > seq undefined "x"
08:20:15 <lambdabot>   "*Exception: Prelude.undefined
08:20:23 <roconnor> > seq (\x -> undefined x) "x"
08:20:25 <lambdabot>   "x"
08:20:29 <elliott> quchen: you can translate (x ==) as either (\y -> x == y) or as ((==) x).
08:21:11 <roconnor> when I write a haskell report, I'm bringing back the Seq typeclass.
08:21:22 <elliott> wasn't it called Eval
08:21:23 <quchen> elliott: I see, the first one is always non-bottom (as long as seq can distinguish bottom from (const bottom))
08:21:27 <roconnor> elliott: I think
08:22:27 <benmachine> quchen: one advantage of lambda-case over normal-case is that it avoids creating a new variable
08:22:33 <benmachine> quchen: you get less name clutter
08:22:49 <quchen> benmachine: I think that can easily be optimized away by the compiler, no?
08:23:19 <benmachine> quchen: sure, but I'm not talking in terms of performance, I'm talking about things for the programmer to remember
08:23:23 <luite> quchen: but it keeps the source cleaner
08:23:37 <benmachine> quchen: it's clearer that this value won't be reused
08:25:15 <quchen> In that case I agree.
08:25:41 <klrr_> morning haskellers
08:26:21 <Rembane> Morning!
08:26:27 <applicative> morning klrr_
08:26:37 <applicative> what was the seq typeclass?
08:26:41 <klrr_> writing anything cool?
08:28:39 <elliott> applicative: class Eval a where seq :: a -> b -> b
08:39:53 <Breadmonster> Can someone explain why Haskell's type system is so strong while Scala's is pathetic?
08:40:01 <roconnor> applicative: the Eval class lets you disallow function types so you don't have to bother with the *weak* head normal form.
08:40:09 <tac> Breadmonster: Haskell's is pathetic in different ways.
08:40:17 <roconnor> applicative: that said, I'm not sure that the Haskell report disallowed functions ...
08:40:28 <Breadmonster> tac: But I've never seen Haskell's fail.
08:40:33 <tac> Breadmonster: also, that's not an appropriate or on-topic thing
08:40:48 <tac> please consider rephrasing it so it's not flamebait :<
08:40:54 <roconnor> tac: is it on topic for #haskell-blah?
08:40:55 <Breadmonster> Oh, yeah, fine.
08:41:14 <Breadmonster> tac: What makes Haskell's type inference so much stronger than Scala's?
08:41:29 <applicative> the power of God is on Haskell's side of course
08:41:56 <RichyB> Breadmonster: IIRC Scala's has features (I think covariance and defaulting) which make it difficult/unsolvable to infer sometimes.
08:41:56 * roconnor hasn't used Scala.
08:42:02 <applicative> roconnor: I see
08:42:13 <RichyB> Er, covariance? I meant something else.
08:42:13 <roconnor> does scala have subtyping?
08:42:24 <RichyB> roconnor: ah thank you, that's it.
08:42:24 <tac> yeah
08:42:25 <applicative> Breadmonster: there are some very scala-knowledgeable people around frequently
08:42:28 <Breadmonster> RichyB: But it can't even infer types of recursive functions.
08:42:33 <tac> Subtyping is a big problem with inference, IIRC
08:42:36 <applicative> but maybe not now.
08:42:47 <RichyB> Breadmonster: yeah, pity. Oh well.
08:43:00 <Breadmonster> def fact(n: Int) = if (n == 0) then n*fact(n-1) else 1
08:43:07 <Breadmonster> That's going to fail miserably, because of a type error.
08:43:16 <roconnor> It seams to be that, although subtyping appears to be a good idea, it is actually a mistake.
08:43:40 <RichyB> Scala's type system isn't "pathetic" in that it's also strong, you can embed some useful invariants in it and it doesn't have too many ways to write forall a b. (a -> b).
08:43:56 <tac> Breadmonster: Perhaps you also overvalue type inference. It's just one of many features of a language, and not a critical one, either.
08:43:58 <applicative> I wonder if I could somehow use  {-# OPTIONS_GHC -F -pgmF 'runhaskell her.hs' #-} as a preprocessor
08:44:03 <RichyB> Some of the features, particularly subtyping, are known to make type inference globally way harder though.
08:44:18 <RichyB> It's not a deal breaker for the people using it on a day to day basis. :)
08:46:38 <applicative> so here is the idiom brackets part of the she preprocessor, in one highly portable file http://lpaste.net/90930
08:46:41 * hackagebot unm-hip 0.0.0.2 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.0.0.2 (JosephCollard)
08:47:20 <Breadmonster> Can someone please explain to me what forall does?
08:47:22 <Breadmonster> I've seen it before.
08:47:25 <stelleg> anyone else getting a 28M binary from hoogle?
08:47:26 <Breadmonster> @src forall
08:47:26 <lambdabot> Source not found. Sorry.
08:47:27 <mapreduce> Scala's type inference is actually enough of a problem where it *does* happen that I always specify the return types of methods even where they can be inferred.
08:47:30 <Breadmonster> @src [] forall
08:47:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:47:46 <benmachine> stelleg: it's implicated in the haskell.org mess alluded to in the topic
08:47:50 <mapreduce> e.g., def foo = new Object has a different type to: def foo = new Object { }
08:47:50 <benmachine> stelleg: best to ignore it, probaby
08:47:51 <applicative> stelleg: yes, try fpcomplete?
08:47:52 <Breadmonster> @src Data.List.foldl'
08:47:52 <lambdabot> Source not found. stty: unknown mode: doofus
08:48:00 <Breadmonster> @src foldl'
08:48:00 <lambdabot> foldl' f a []     = a
08:48:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:48:05 <stelleg> benmachine: ah sorry didn't look up, thanks
08:48:16 <Breadmonster> @src seq
08:48:16 <lambdabot> Source not found. :(
08:48:22 <FreeFull> Breadmonster: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
08:48:28 <Breadmonster> Can someone explain how seq is magic?
08:48:29 <benmachine> stelleg: the topic's advice to use www.haskell.org doesn't work for hoogle, sadly
08:48:40 <Kinnison> stelleg: looks like hoogle is giving you its CGI instead of running it
08:48:49 <Breadmonster> Yeah, it is.
08:48:55 <benmachine> Breadmonster: seq is the only thing that can return a different result for undefined :: a -> b and const undefined :: a -> b
08:49:13 <Breadmonster> benmachine: Where do I find the source?
08:49:28 <benmachine> Breadmonster: for seq? it doesn't have a Haskell implementation
08:49:29 <Breadmonster> Is it hardcoded into the compiler?
08:49:31 <benmachine> yes
08:49:33 <stelleg> Kinnison: yeah looks like it
08:49:46 <benmachine> because of what I just said, it can do things no normal function can
08:53:21 <Cale> Breadmonster: seq (const undefined) 0 will evaluate to 0, but seq undefined 0 will be undefined
08:53:29 <Cale> oh, yeah, that was already said
08:54:12 <Breadmonster> Shouldn't ti be the other way around?
08:55:26 <benmachine> Breadmonster: why?
08:55:33 <FreeFull> I wonder...
08:56:02 <applicative> I see it can make sure 'const undefined' is in whnf without exploding
08:56:40 <FreeFull> > head $ seq <$> [const undefined, undefined] <*> [2,3]
08:56:41 <lambdabot>   2
08:56:46 <FreeFull> > tail $ seq <$> [const undefined, undefined] <*> [2,3]
08:56:46 <lambdabot>   [3,*Exception: Prelude.undefined
08:57:16 <benmachine> I suppose the idea is that whnf for functions is \x -> [stuff]
08:57:18 <Breadmonster> Hmm.
08:57:22 <benmachine> and const undefined is \_ -> undefined
08:57:26 <benmachine> but undefined has no whnf
08:57:39 <benmachine> and explodes when you try to fin it
08:57:41 <benmachine> *find
08:58:10 <Breadmonster> What's whnf?
08:58:50 <applicative> it's mean calculating a functional expression till the outmost constructor is revealed
08:58:54 <FreeFull> Weak head normal form
08:59:07 <applicative> pardon illiteracy...
08:59:07 <roconnor> Breadmonster: whnf means "weak head normal form"  It means the term either begins with a constructor or begins with a lambda.
08:59:12 <FreeFull> > deepseq (const undefined) 0
08:59:12 <lambdabot>   Not in scope: `deepseq'
08:59:23 <roconnor> \_ -> undefined   begins with a lambda
08:59:25 <mm_freak> are Algebra and Coalgebra defined somewhere for F-(co-)algebras?
08:59:33 <roconnor> undefined   does not begin with a lambda or a constructor
08:59:42 <Breadmonster> Hmm, thanks roconnor :)
08:59:50 <Breadmonster> @src deepseq
08:59:50 <lambdabot> Source not found. I am sorry.
08:59:59 <applicative> so fff (gggg x) :: Maybe Int is in whnf if you you've found out if it is a Just or a Nothing, but inside the Just there might be a complicated functional expression
09:01:06 <mm_freak> @hoogle Algebra f a
09:01:07 <lambdabot> Did you mean: :: Algebra f a
09:01:07 <lambdabot> package function-instances-algebra
09:04:33 <applicative> i guess if we think of Undefined as the evil other constructor for each type, including a -> b it's not so strange
09:06:06 <FreeFull> Undefined is the only constructor for Void
09:06:07 <HugoDaniel> i always make sure to include a Steroids constructor
09:06:15 <HugoDaniel> Undefined with Steroids
09:06:43 <benmachine> I think that's an odd sort of way of thinking about it
09:06:55 <benmachine> Void isn't supposed to have any constructors, that's sort of the point
09:07:06 <benmachine> it has values, but only sort-of-fake values
09:09:08 <quicksilver> I would say Void doesn't have any values
09:09:12 <quicksilver> undefined isn't a value
09:09:22 <Chri_____> @help
09:09:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:09:23 <quicksilver> and thinkinf of Undefined as a constructor is badthink
09:09:42 <roconnor> undefined is a partial value :D
09:10:08 <applicative> it came up in a narrow connection, I dont think anyone was proposing it as a true theory of Undefined
09:10:33 <Chri_____> @hoogle [Int] → [Int]
09:10:33 <lambdabot> Parse error:
09:10:33 <lambdabot>   [Int] → [Int]
09:10:33 <lambdabot>          ^
09:10:52 <Chri_____> @hoogle [Int] -> [Int]
09:10:52 <lambdabot> Data.Graph.Inductive.Query.BFS bfsn :: Graph gr => [Node] -> gr a b -> [Node]
09:10:52 <lambdabot> Data.Graph.Inductive.Query.DFS dfs :: Graph gr => [Node] -> gr a b -> [Node]
09:10:52 <lambdabot> Data.Graph.Inductive.Query.DFS rdfs :: Graph gr => [Node] -> gr a b -> [Node]
09:11:13 <FreeFull> Chri_____: What do you want the function to do?
09:11:20 <applicative> In many respects Haskell types X Y Z are like Maybe X Maybe Y Maybe Z considered in another system
09:11:58 <applicative> there's a lot of functions [Int] -> [Int]; [a] -> [a] not so many
09:12:43 <FreeFull> I think the simpleset [a] -> [a] function is id
09:12:50 <Chri_____> Hey, I was just testing the Hoogle integration here. The web version seems to be having problems (visiting the Hoogle page just downloads a ~30MB file).
09:13:05 <quicksilver> yes, the haskell.org web site is a bit broken
09:13:05 <FreeFull> Chri_____: Yeah, everyone is hitting that problem
09:13:24 <applicative> yes its apparently mentioned in the remarks you get with this channel
09:13:27 <monochrom> yikes, it is continuing into today?
09:13:39 <FreeFull> monochrom: Yep
09:13:58 <applicative> the mysterious binary download is extremely creepy
09:14:18 <monochrom> um, ironically, the topic still contains http://haskell.org :)
09:14:23 <quicksilver> it is, presumably, the hoogle binary itself
09:14:23 --- mode: ChanServ set +o monochrom
09:14:26 <applicative> of course, as a devil may care idiot, i tried to run it but my system wont let me ....
09:14:32 --- topic: set to 'haskell.org in the middle of migration; expect turbulence; use www.haskell.org | http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by monochrom
09:14:38 <quicksilver> being downloaded as a binary file instead of executed as a cgi script
09:14:42 --- mode: monochrom set -o monochrom
09:14:58 <applicative> https://www.fpcomplete.com/hoogle is fine
09:14:59 <monochrom> (in the past, I have always sworn by www.haskell.org anyway :) )
09:15:17 <quchen> What's an unboxed tuple? Are the contained values (or pointers) stored in consecutive memory cells?
09:15:37 <quicksilver> quchen: as far as I know, it's a syntactic thing only
09:15:43 <quicksilver> quchen: they don't actually 'exist'
09:15:52 <quicksilver> it's a way of represent register calling, rougly
09:16:14 <quchen> quicksilver: So it's more of a "this is lowlevel-ish" annotation?
09:16:48 <FreeFull> Usually a tuple will be three pointers
09:17:00 <benmachine> quchen: unboxed tuples are aiui a way of returning multiple results with minimal overhead
09:17:00 <FreeFull> I think an unboxed tuple would only be one
09:17:07 <quicksilver> quchen: I believe it implies that those value aren't actually stored at all.
09:17:35 <quicksilver> that is, there is no heap representation for unboxed tuples - they're never stored on the heap
09:17:36 <c_wraith> unboxed tuples are generally just stored in registers, yeah
09:17:38 <quicksilver> I could be wrong.
09:17:44 <applicative> quicksilver: do you mean, the tuple value isn't stored or anything
09:17:49 <quchen> benmachine: But a tuple is only 3 ints, isn't it? One for the constructor, one for each cell
09:17:57 <applicative> the unboxed items it contains must be there
09:18:05 <quicksilver> applicative: not in the heap
09:18:12 <quchen> (An unboxed tuple can contain boxed values, right?)
09:18:14 <applicative> quicksilver: yes, I see that
09:18:26 <benmachine> iirc unboxed tuples have to immediately be unpacked
09:18:32 <benmachine> can't be passed around or otherwise fiddled with
09:18:37 <quicksilver> i.e. they're not a real thing
09:18:40 <applicative> the point is, we dont use anything for (# 2#,3# #) we dont use for 2# and 3#
09:18:53 <quicksilver> they're just a way of coercing multiple return values into the syntax of Core
09:18:59 <quicksilver> whilst still making Core look a bit like haskell
09:19:13 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#unboxed-tuples
09:19:44 <astor``> Problems with hoogle?
09:19:52 <applicative> yes, use https://www.fpcomplete.com/hoogle
09:20:04 <applicative> its discussed in the topic astor``
09:20:05 <quicksilver> quchen: I think full 3-tuple is 8 words, plus whatever it costs to store the underlying 3 objects.
09:20:28 <quchen> quicksilver: How does that 8 come about?
09:20:36 <quicksilver> quchen: indirection pointer -> data pointer -> 3 * [ indirection pointer -> data pointer ]
09:20:58 <astor``> applicative: ah, sorry for the spam
09:21:11 <quicksilver> the topic doesn't actually say to use fpcomplete's hoogle
09:21:15 <applicative> astor``: no its happening to everyone
09:21:29 <quicksilver> and the topic somehow implies that www.haskell.org will be better - but that doesn't help for hoogle
09:22:03 <geekosaur> there are multiple unrelated problems (except insofar as the weekend maintenance seems to have caused them)
09:22:41 <benmachine> quicksilver: you have permission to change it, don't you?
09:23:08 <quicksilver> benmachine: yes, but monochrom just did and I wondered if he had a plan
09:23:10 <quchen> quicksilver: Why an indirection pointer and a data pointer in the beginning? I would've guessed that a (boxed) n-Tuple is a pointer to the tuple (1), which then contains the pointer to the data constructor (1+1=2) and n pointers to the contained data (= 2 + n)
09:23:25 <quchen> eeh
09:23:29 <quchen> Wait, that doesn't make sense.
09:23:32 <quicksilver> quchen: the indirection pointer is how thunks work
09:23:48 <benmachine> quicksilver: don't think so, that was just to remove the reference to haskell.org in favour of www.haskell.org (which seems to work for non-hoogle things)
09:23:55 <quchen> Hm, I should have a look at the post with the memory pictures again.
09:24:03 <quicksilver> quchen: I can't explain to you why it is done that way rather than a single level of pointing to data structure which has flags in
09:24:09 <quicksilver> quchen: but I imagine there is a reason :)
09:24:33 <benmachine> perhaps to reduce the number of indirections?
09:24:45 <benmachine> so you can reach the data without dereffing the pointer, for e..g
09:24:57 <benmachine> or perhaps because the data tells you how to use the pointer, sometimes
09:26:42 * hackagebot hsx2hs 0.13.0 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.13.0 (JeremyShaw)
09:32:22 <applicative> well, it's not hard to get an idiom brackets preprocessor to be called as a local script http://lpaste.net/90931
09:32:25 <astor> If we assume that the inner loops and the most used data structures are "optimized" in large haskell systems, then not using tagged pointers can be a benefit given the 80/20 rule.
09:34:30 <elliott> applicative: (<*^) doesn't need an Applicative constraint
09:34:52 <elliott> (it's lens's (??), btw)
09:34:54 <applicative> ha, yes. this is almost all mcbride's text
09:36:02 <elliott> it looks like doing it in GHC would be way simpler
09:36:05 <elliott> since you already have a parser.
09:36:48 <applicative> elliott: yes, or anyway haskell-src-exts
09:37:20 <elliott> I find the (%...%) ~ @ extensions to idiom brackets quite hideous frankly
09:37:50 <applicative> elliott: yes, but he seems also to have included (- blah -) for (% blah %)
09:38:06 <applicative> which is nice as akin to {-blah-}
09:38:14 <elliott> oh, that seems workable
09:38:30 <applicative> @ I don't know about, yes
09:38:39 <elliott> ~ just seems extraneous though, (pure x) seems more legible and adequate
09:38:54 <elliott> I find the example "(|cond notADrill ~ launchMissiles ~ (|()|)) @ |)" rather telling as far as their utility goes
09:39:10 <applicative> hah, yes pretty deadly
09:39:23 <mmachenry> Hello, I'm trying to run a process with System.Process.runProcess. My hope is that if my parent process receives sigINT that the child process does as well. This is not the case. Do I need to explicitely catch sigINT and pass it to my child process with killProcess or is there a simpler way to run a process that inherits the signals handlers?
09:39:40 <applicative> the little 'wee parser' is not too bad as done her ehttp://lpaste.net/90932
09:39:49 <geekosaur> mmachenry, that's ... oversimplistic and platform dependent
09:40:46 <geekosaur> (a) POSIX: if SIGINT is sent via the terminal, it is sent to the entire process group. Other signal sources target a single process (although see `man 2 kill` and possibly `man killpg`)
09:41:12 <geekosaur> (b) signal handlers (other than default and ignore) can not be inherited across exec(), since their address space vanishes.
09:41:32 <mmachenry> geekosaur: Well I'm on a Linux system.
09:41:36 <mmachenry> For starters.
09:41:54 <elliott> hm I wonder how you write (<$)
09:42:18 <elliott> x <$ y = (| x (-y-) |) I suppose
09:43:11 <geekosaur> mmachenry, then I have described what is happening
09:44:16 <applicative> elliott: yes, thats how i did it here http://lpaste.net/90935
09:45:12 <elliott> perhaps there should be some fancy notation for traverse :)
09:45:36 <applicative> he says that in the comments on the webpage. i was wondering ...
09:46:29 <applicative> the (| x , y |) is really pleasing, but doenst work for (| x, y , z |)
09:46:42 * hackagebot hsp 0.9.0 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.9.0 (JeremyShaw)
09:46:43 <applicative> which would have to be included in your ghc patch, elliott ;)
09:46:47 <mmachenry> geekosaur: So I am not getting sigINT from the console. Does this mean that I need to catch sigINT explicitely and send it to the child?
09:47:02 <elliott> heh (| xs, ys |) is almost cute enough to justify ZipList as the [] Applicative instance
09:47:47 <geekosaur> you shouldn't, but it depends on how you're spawning your subprocess. show code?
09:47:50 <notdan> How can I lift a proxy that operates in the IO monad to a proxy that operates on some other instance of MonadIO?
09:47:51 <geekosaur> ?where hpaste
09:47:51 <lambdabot> http://lpaste.net/new/haskell
09:49:08 <augur_> elliott: (| xs , ys |) is reasonable for the product one too tho
09:49:30 <ocharles> elliott: are you still using SHE, or did you start that plugin that you promised the world?
09:49:58 <augur_> who needs SHE when you've got agda!
09:50:21 <elliott> ocharles: well I'm tempted to poke around a GHC patch
09:50:24 <notdan> oh, it's hoist_P liftiO
09:50:24 <elliott> how hard can it be, right?
09:50:53 <ocharles> elliott: i heard if you can't do that, you can't call yourself a Real Programmer
09:50:56 <ocharles> and you wouldn't want that
09:51:04 <killy9999> @pl f a b (_,c) = (\r -> g r b) <$> h a c
09:51:04 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . flip ((.) . (<$>) . flip g) . h
09:51:18 <ocharles> I need to do some GHC hacking too - it was suggested I upgrade alex to alex 3 for simpler Unicode
09:51:25 <ocharles> which is also apparently "fairly trivial"
09:51:26 <killy9999> anyone has an idea how to eta-reduce this definition?
09:51:27 <killy9999> f a b (_,c) = (\r -> g r b) <$> h a c
09:51:38 <killy9999> I'd like to get rid of (_,c)
09:51:42 * hackagebot happstack-hsp 7.2.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.2.0 (JeremyShaw)
09:52:01 <killy9999> without introducing explicit lambda
09:52:20 <applicative> @pl f a b (x,c) = fmap (\r -> g r b) ( h a c)
09:52:20 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . flip ((.) . fmap . flip g) . h
09:52:29 <ocharles> hah
09:52:30 <applicative> sorry killy9999 ...
09:52:43 <applicative> @pl f  (x,c) = fmap (\r -> g r b) ( h a c)
09:52:44 <ocharles> fmap (\r -> g r b) . h a . snd
09:52:46 <lambdabot> f = fix (const (ap (const (fmap (flip g b) . h a) . fst) snd))
09:52:46 <lambdabot> optimization suspended, use @pl-resume to continue.
09:52:50 <ocharles> it's that, right?
09:53:16 * killy9999 is checking
09:53:19 <applicative> I think i'll use @ocharles-resume to continue
09:53:27 <ocharles> :)
09:55:03 <killy9999> ocharles: yeah, I think it is, though I don't see yet why I can't use fmap as an infix operator...
09:55:09 <astor> mmachenry: there are two levels of groups, the session and the process group.  Within a session, the process group that is foreground will get SIGINT.  Typically what happens is that something calls setsid creating a new session, disassociating all terminal control from whatever spawned it.
09:55:36 <ocharles> killy9999: my rule of thumb is: use fmap for partial application, use <$> when you have all parameters
09:55:45 <ocharles> I think it leads to much cleaner code
09:56:27 <applicative> no, use (|f ... |) when you have all the parameters, then elliot will implement them....
09:56:40 <killy9999> it certainly leads to compiling code
09:56:42 * hackagebot hsx-jmacro 7.3.0 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.0 (JeremyShaw)
09:56:44 * hackagebot happstack-server 7.3.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.0 (JeremyShaw)
09:56:46 * hackagebot happstack-server-tls 7.0.3 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.0.3 (JeremyShaw)
09:56:51 <ocharles> right, i'm outta here
10:01:42 * hackagebot happstack-lite 7.3.1 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.3.1 (JeremyShaw)
10:06:42 * hackagebot happstack-heist 7.1.1 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.1.1 (JeremyShaw)
10:06:44 * hackagebot happstack-heist 7.1.2 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.1.2 (JeremyShaw)
10:07:47 <joehillen> anyone know what's up with hoogle?
10:08:13 <joehillen> nvm, just saw the today's topic
10:08:39 <klrr_> hoogle is down?
10:08:50 <mauke> hoogle is now hoogle
10:09:20 <joehillen> firefox want's to download a binary file whenever I try to visit
10:09:29 <mauke> that binary is hoogle
10:09:34 <shachaf> You wan't to download that file.
10:09:34 <tomboy64> > repeat []
10:09:35 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
10:09:39 <tomboy64> hm
10:09:52 <structuralist> I'm trying to build some intuition for cofree comonads… how do you guys think about it?
10:10:08 <edwardk> a * f (a * f (a * f (....
10:10:19 <edwardk> its an a and an f wrapped around an a and an f wrapped around an ...
10:10:42 <edwardk> its a syntax tree made out of 'f's with 'a' annotations at every level
10:11:23 <shachaf> As a tree with f-shaped branches, just like free monads! :-)
10:11:42 * hackagebot happstack-hstringtemplate 7.0.3 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-7.0.3 (JeremyShaw)
10:11:44 * hackagebot happstack-jmacro 7.0.5 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.5 (JeremyShaw)
10:11:47 * hackagebot happstack-hamlet 7.0.3 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-7.0.3 (JeremyShaw)
10:16:15 <structuralist> interesting… I usually think of syntax trees as initial algebras, but it sounds like cofree monads are most naturally coalgebraic
10:16:29 <structuralist> thought of coalgebraically*
10:16:43 * hackagebot happstack-clientsession 7.2.5 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.5 (JeremyShaw)
10:17:55 <structuralist> which has more to do with behavior than syntax
10:18:17 <astor> What is the following called? a -> ((a->b), (a -> c), (a -> d)) -> (b, c, d)
10:18:52 <structuralist> astor: a variation on fanout?
10:20:17 <structuralist> there's also http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
10:20:32 <astor> structuralist: I thought it was related to arrows, but I'm not fluent in arrows.
10:21:17 <Philippa_> structuralist: so initial algebras and final algebras are the same thing in languages like Haskell
10:21:24 <structuralist> astor: I'm not sure why (&&&) is in Control.Arrow and not Prelude, it seems like such an obvious thing for functions
10:21:26 <Philippa_> sorry, final *co*algebras
10:21:38 <structuralist> astor: it's actually related to the universal property for cartesian products
10:21:43 * hackagebot reform 0.2.0 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.0 (JeremyShaw)
10:21:45 * hackagebot reform-blaze 0.2.0 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.2.0 (JeremyShaw)
10:21:47 * hackagebot reform-happstack 0.2.0 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.2.0 (JeremyShaw)
10:22:50 <structuralist> morphisms Z → (X,Y) are given by a morphism Z → X and a morphism Z → Y
10:23:15 <structuralist> > :t (&&&)
10:23:16 <lambdabot>   <hint>:1:1: parse error on input `:'
10:23:18 <structuralist> er
10:23:21 <structuralist> how do I use this again
10:23:42 <structuralist> @t (&&&)
10:23:42 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:23:48 <ericmoritz> hi.  I've been beating my head against a wall all weekend trying to solve this and I feel like I'm probably trying so solve a problem the wrong way. I have a list of [IO (Maybe Int)] and I want to take the first Just Int out of that list but I want to lazily execute the IO monad.
10:23:55 <ericmoritz> https://gist.github.com/ericmoritz/f4f8c5d770de12b9af74
10:24:31 <structuralist> anyway, (&&&) basically does that
10:24:32 <ericmoritz> I feel like there there has to be a way to do this without the custom firstIOJust function
10:25:04 <applicative> sequence gives you  IO [Maybe Int]
10:25:11 <shachaf> applicative: Doesn't help here.
10:25:19 <ericmoritz> applicative: it seems to execute the actions first though
10:25:22 <applicative> withouit executing
10:25:23 <applicative> i see
10:25:30 <shachaf> ericmoritz: Unfortunately this kind of compositionality and IO (or most monads, really) don't mix very well. :-(
10:25:38 <applicative> you want to do as many actions as it takes to get a Just x
10:25:39 <applicative> nice
10:26:43 * hackagebot reform-hsp 0.2.0 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.0 (JeremyShaw)
10:27:01 <ericmoritz> shachaf: so there isn't some magically Control.Monad, Data.Maybe incantation that'll do that?
10:27:14 <merijn> ericmoritz, shachaf: This sounds like a job for...monad-loops!
10:27:22 <merijn> @hackage monad-loops
10:27:22 <lambdabot> http://hackage.haskell.org/package/monad-loops
10:27:26 <shachaf> merijn: I looked at monad-loops.
10:27:29 <applicative> yes something like whileM untilM
10:27:41 <merijn> Oh, there's nothing like that in monad-loops?
10:27:42 <shachaf> merijn: Do you have any particular recommendation of how to do that?
10:28:15 <johnw> I don't think firstM is lazy in that way
10:28:29 <johnw> but maybe it is
10:28:38 <applicative> the result will be IO Int ?
10:28:45 <astor> if I do map (f &&& g &&& h) list then I get :: [(a, (b, c))].  Are there good ways to unflatten recursive tuples?
10:28:45 <shachaf> Oh, firstM is.
10:28:59 <shachaf> But then you pretty much have to use fromJust and it's terrible.
10:29:47 <astor> ^unflatten^flatten
10:29:53 <optimusbrine> ive hoogled it, but in-case I am missing something, is there a function somewhere, like bits :: Word8 -> [Bool]? (or something maybe more generic)
10:30:00 <shachaf> It should be firstM :: Monad m => (a -> m (Maybe b)) -> [a] -> m (Maybe b) or something.
10:30:16 <elliott> optimusbrine: perhaps look at Data.Bits, I think it has something along those lines
10:30:26 <merijn> shachaf: Why not just join rather than using fromJust?
10:30:26 <ericmoritz> shachaf: I'll try that; thanks
10:30:43 <shachaf> ericmoritz: No, I just said a thing that didn't exist.
10:30:45 <merijn> firstM returns "IO (Maybe (Maybe Int)"
10:31:01 <merijn> Then you just "fmap join"
10:31:02 <shachaf> merijn: Hmm, true enough.
10:31:19 <elliott> a join that's always a fromJust sort of isn't better.
10:31:21 <astor> optimusbrine: Maybe it's Data.Bits, but there is a typeclass for Bits that seems to be designed for large bit strings that can map over them I think.
10:31:30 <elliott> like how (drop 1) is not really better than tail for the zip `ap` tail thing.
10:31:33 <merijn> :t fmap join . firstM isJust
10:31:33 <lambdabot>     Not in scope: `firstM'
10:31:33 <lambdabot>     Perhaps you meant `first' (imported from Control.Arrow)
10:31:34 <elliott> it's just obscuring your intent.
10:31:43 * hackagebot web-routes-happstack 0.23.5 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.5 (JeremyShaw)
10:31:45 * hackagebot web-routes-hsp 0.24.0 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.24.0 (JeremyShaw)
10:32:15 <shachaf> elliott: It's not always fromJust.
10:32:30 <merijn> shachaf: It's not always fromJust, if the list has no entries then fromJust would be a crash
10:32:42 <merijn> join doesn't crash if the list has no matching entries
10:33:24 <elliott> hmm.
10:33:35 <astor> optimusbrine: the bitwise package.
10:33:50 <optimusbrine> Ah! thanks.
10:34:29 <astor> optimusbrine: there is no typeclass other than Bits, but it includes mapping etc.
10:36:10 <tomboy64> is there a built-in function that concatenates 2 lists in a 2-tuple?
10:36:21 <shachaf> uncurry (++)
10:36:32 <tomboy64> e.g. ([a],[b]) -> [a] ++ [b]?
10:36:43 <Clint> :t uncurry (++)
10:36:43 <lambdabot> ([a], [a]) -> [a]
10:36:44 * hackagebot watcher 0.1 - Watch a file/directory and run a command it is modified  http://hackage.haskell.org/package/watcher-0.1 (ErlendHamberg)
10:36:51 <tomboy64> thanky
10:38:27 <astor> maybe watcher should be used as a backend for Shake
10:39:11 <luite> astor: it's an executable, probably better to use the underlying fsnotify library
10:39:19 <Hafydd> [a] ++ [b] doesn't make much sense.
10:39:29 <astor> luite: yes. I see it's now hinotify
10:39:53 <ericmoritz> is there something up with hoogle? http://www.haskell.org/hoogle/ seems to be an elf binary
10:40:05 <luite> astor: that's one of the fsnotify backends, it uses other backends on windows and os x
10:40:22 <ericmoritz> I might be mistaken but I thought it went to a search page
10:40:32 <abc22134> @Hafydd why?
10:40:32 <lambdabot> Unknown command, try @list
10:40:49 <astor> luite: ok.
10:40:51 <abc22134> Hafydd: why?
10:41:02 <astor> ericmoritz: https://www.fpcomplete.com/hoogle
10:41:08 <Hafydd> abc22134: well... I suppose it does if a,b are values and not types.
10:41:34 <tomboy64> Hafydd: they are values.
10:41:43 * hackagebot happstack-authenticate 0.10.5 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.5 (JeremyShaw)
10:41:46 * hackagebot happstack-hsp 7.2.1 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.2.1 (JeremyShaw)
10:41:56 <abc22134> @let a=1;b=2 in [a]++[b]
10:41:56 <lambdabot>  Parse failed: Parse error: in
10:42:25 <abc22134> @let {a=1;b=2} in [a]++[b]
10:42:26 <lambdabot>  Parse failed: Parse error: in
10:43:53 <S11001001> abc22134: s,@,> ,
10:44:19 <abc22134> > let a=1;b=2 in [a]++[b]
10:44:20 <lambdabot>   [1,2]
10:44:32 <abc22134> Hafydd: see?
10:44:46 <structuralist> I have a kind of strange question
10:44:54 <structuralist> monads are algebraic theories, right?
10:45:05 <structuralist> is there such a thing as a coalgebraic theory, and is that what a comonad is?
10:45:08 <abc22134> S11001001: thanks!
10:45:12 <Hafydd> Or, shorter:
10:45:15 <Hafydd> > [a] ++ [b]
10:45:16 <S11001001> abc22134: I assumed you meant types when you used a, b in your question.
10:45:16 <lambdabot>   [a,b]
10:45:21 <CaptainK> e
10:45:59 <abc22134> Hafydd: right, I tried it at GHCi first.
10:46:23 <Hafydd> (That's because lambdabot has SimpleReflect loaded)
10:46:27 <benmachine> structuralist: interesting; I'm not sure, but I know there is a structure called a comonoid, and it has a comultiplication
10:47:52 <johnw> no
10:47:56 <johnw> (wrong window)
10:48:10 <c_wraith> That did feel a little out of context
10:48:22 <polson136> I have a module that I would like to upload to xmonad-contrib, and I had a couple questions (first time uploading to any open-source project)
10:48:51 <structuralist> benmachine: hmm. are there cofree comonoids?
10:49:07 <benmachine> structuralist: pass. I don't really even know what a comonoid is
10:49:18 <shachaf> structuralist: Comonoids are boring in Hask, so I'm told.
10:49:22 <johnw> what would the cofree comonoid do: list bifurcation?
10:49:37 <shachaf> A comonad is a comonoid in the category of endofunctors, though!
10:50:17 <shachaf> Anyway, a comonoid has (a -> (), a -> (a,a))
10:50:45 <shachaf> Compare to extract :: w ~> Id duplicate :: w ~> (w  . w)
10:50:45 <benmachine> shachaf: is it only really interesting with other monoidal structures?
10:51:44 * hackagebot watcher 0.1.1 - Watch a file/directory and run a command it is modified  http://hackage.haskell.org/package/watcher-0.1.1 (ErlendHamberg)
10:51:44 <shachaf> benmachine: I don't know.
10:52:08 <shachaf> I think I heard that it's boring in any CCC.
10:53:05 <benmachine> shachaf: right, because in any CCC the unit of the monoidal structure is the terminal object, so morphisms to it are boring
10:53:07 <c_wraith> comonoids have some issues with things like determinism, too.  Like, there are n+1 possible things a list comonoid could do to split an n-element list
10:53:16 <benmachine> shachaf: I... think
10:53:32 * johnw feels like there is a relationship between comonoids and quotient sets
10:54:03 <elliott> c_wraith: isn't it that the laws require the a -> (a,a) to be \x -> (x,x)?
10:54:06 <elliott> in Hask-*
10:54:07 <johnw> like, representing Integers as Rational Integers is sort of an a -> (a,a) operation
10:54:28 <structuralist> what's Hask-*?
10:54:52 <shachaf> The category people usually call "Hask".
10:55:16 <benmachine> elliott: yeah, that sounds right
10:56:30 <benmachine> johnw: a -> (a,a) isn't really the whole story of a comonoid, the identity/associativity stuff is what makes a comonoid a comonoid
10:56:38 <c_wraith> What are the comonoid laws, then?
10:56:42 <benmachine> possibly coidentity/coassociativity :P
10:56:44 * hackagebot unbound 0.4.2 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.2 (BrentYorgey)
10:56:57 <benmachine> c_wraith: take the monoid laws and turn around all the arrows? :P
10:57:01 <FreeFull> I thought about comonoids before
10:57:23 <FreeFull> Wouldn't the output have to be something like a   Stream (a,a)
10:57:32 <benmachine> FreeFull: output of what
11:00:11 <dmwit> The problem is that the "comempty is identity" law says that
11:00:26 <dmwit> first comempty (comappend a) = (\a -> ((), a))
11:00:39 <dmwit> and likewise second comempty (comppend a) = (\a -> (a, ()).
11:00:54 <dmwit> This means you have to choose comempty _ = () and comappend a = (a, a)
11:01:15 <FreeFull> benmachine: Comappend
11:02:06 <klrr_> could IO be presented through FRP while remaining Haskell completely pure?
11:02:14 <FreeFull> comempty (Sum 7) would output something like    [(7,0),(8,-1),(6,1),(9,-2)...]
11:02:29 <benmachine> dmwit: not sure I understand the role of a in your LHSs
11:02:32 <kanishka> for postgres, very simple sending of sql queries and stable, is this a good ranking:
11:02:34 <kanishka> 1) postgresql-libpq, 2) libpq, 3) postgresql-simple, 4) HDBC-postgresql
11:02:47 <dmwit> benmachine: there's an outer-most "forall a."
11:03:13 <benmachine> dmwit: but a is not free in the RHS, is that intentional?
11:03:25 <dmwit> err
11:03:44 <dmwit> Yes, my law is incorrect.
11:03:59 <dmwit> first comempty (comappend a) = ((), a) -- corrected law
11:04:03 <benmachine> aha
11:04:11 <benmachine> with you
11:04:20 <FreeFull> I wonder, would it make sense to make a Num instance for Sum and Product? =P
11:04:30 <benmachine> comempty pretty much has to be comempty _ = () anyway, doesn't it?
11:04:35 <dmwit> yep
11:04:42 <benmachine> just because () is terminal
11:04:45 <dmwit> The real kicker is that comappend is so constrained.
11:04:46 <benmachine> (ignoring bottoms)
11:04:54 <dmwit> FreeFull: I'm annoyed often that there is no such instance.
11:05:06 <dmwit> I don't really think there's a good reason not to have one.
11:05:25 <FreeFull> Why can't comempty be equal to mempty?
11:05:42 <dmwit> It's not typed properly. =)
11:06:00 <dmwit> mempty :: Monoid m => () -> m, so comempty :: Comonoid w => w -> ()
11:06:08 <FreeFull> I'm thinking comempty would be a and comappend a -> Stream (a,a)
11:06:18 <FreeFull> :t mempty
11:06:18 <dmwit> and mappend :: Monoid m => (m, m) -> m, so comappend :: Comonoid w => w -> (w, w)
11:06:19 <lambdabot> Monoid a => a
11:06:20 <elliott> dmwit: obviously Product x + Product y should be Product (x * y)
11:06:23 <elliott> fromInteger 0 = Product 1
11:06:35 * benmachine stabs elliott 
11:06:36 <FreeFull> elliott: No
11:06:38 <FreeFull> That's evil
11:06:54 * structuralist lols
11:06:56 <elliott> then you can use Sum (Product Int).
11:07:08 <dmwit> elliott: The whole point of Product and Sum is that neither (+) nor (*) is the canonical name for mappend.
11:07:58 <elliott> I'm kidding!
11:08:03 <FreeFull> dmwit: Since when is mempty () -> m though
11:08:13 <elliott> since forever.
11:08:14 <dmwit> FreeFull: Well. =)
11:08:16 <elliott> that's how it is categorically.
11:08:22 <elliott> and (() -> a) is isomorphic to a anyway.
11:08:40 <FreeFull> elliott: Not the same when flipping arrows though
11:08:41 <shachaf> How can you turn the arrows around if you don't have any arrows in the first place?
11:08:45 <shachaf> Checkmate.
11:09:02 <structuralist> FreeFull: categorical philosophy goes something like only arrows exist to begin with
11:09:18 <dmwit> FreeFull: You've got things all worked around. Monoids and comonoids are categorical things; then separately we ask what would a natural model of them be in Haskell.
11:09:20 <shachaf> Speaking of arrows, it turns out that a monad in a group is an inner automorphism.
11:09:31 <dmwit> It turns out that the natural model in Haskell drops the (() ->) part because it's not useful.
11:10:21 <shachaf> People discovered monoids way before they invented categories.
11:10:33 <dmwit> I never claimed the contrary.
11:10:53 <elliott> they didn't discover comonoids, though.
11:11:08 * elliott wonders what a cogroup is.
11:11:10 <Taneb> Are comonoids even a thing?
11:11:18 <dmwit> (In fact, I would even go so far as to say I carefully avoided claiming the contrary.)
11:11:38 <shachaf> You claimed that they're categorical things.
11:11:43 <shachaf> But I wasn't being serious anyway.
11:11:47 <dmwit> Do you find that to be untrue?
11:12:08 <dmwit> Taneb: Sure, why not? =)
11:12:49 <Taneb> (has this just been discussed? should I logread?)
11:13:00 <elliott> Taneb: yes
11:13:16 <Taneb> Righto
11:15:54 <Taneb> Right, so comonoids are uselessy trivial in Hask?
11:15:59 <dmwit> right
11:16:18 <polson136> I want to upload a module to xmonad-contrib that is based off of Xmonad.Hooks.ServerMode, but instead of passing the index through the X server, it passes a string. I am wondering if it makes sense to make a new module or modify the existing one. Obviously I can't rewrite the already-existing functions.
11:16:26 <FreeFull> Now, is there a cocategory cotheory?
11:16:43 <Taneb> instance Comonoid a where wempty _ = (); wappend a = (a, a)
11:17:11 <dmwit> polson136: I think it makes sense to offer variants from the same module, but with a different name.
11:17:31 <dmwit> Taneb: Yep, it's hopeless.
11:17:39 <polson136> ok, now I just have to figure out what to name the thing.
11:17:40 <shachaf> Taneb: Best stick with comonads.
11:18:23 <structuralist> so is there a comonad whose coalgebras are comonoids?
11:18:29 <structuralist> as trivial as they are
11:18:51 <dmwit> Thanks to seq and people's acceptance of laws that are satisfied up to totality, there may be other implementations of Comonoid. But not in a terribly interesting way.
11:21:22 <dropdrive> Do I have any hope of using Criterion with GHC 7.0.4?
11:21:58 <dmwit> Do you have a reason to think there's no hope?
11:22:57 <dmwit> That is to say: it sounds like there's a question behind this question, and you should ask that one instead.
11:23:01 <dmwit> It's probably a better question anyway.
11:23:30 <shachaf> Well, if you just want hope, there is always hope.
11:24:01 <Taneb> You just need to believe with all your heart
11:24:13 <dropdrive> dmwit: Well, you're right -- when cabal tries to install Statistics/Distribution/Beta.hs, I get "Unsupported extension: DeriveGeneric"
11:24:28 <dropdrive> ...from the statistics-0.10.4.1 package.
11:25:09 <dcoutts> dropdrive: try an older version of the statistics package
11:25:09 <dmwit> You could try installing an older version of criterion/statistics.
11:25:51 <dmwit> e.g. cabal install criterion --constraint "statistics < 0.10" or whatever.
11:26:13 <dropdrive> dcoutts, dmwit: I didn't know that was possible.  Thanks much.
11:26:40 <dmwit> According to the Hackage documentation, "< 0.10.4" should be strict enough.
11:29:32 --- mode: ChanServ set +o shachaf
11:30:01 --- topic: set to 'haskell.org in the middle of migration; expect turbulence | http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by shachaf
11:30:06 --- mode: shachaf set -o shachaf
11:31:44 <nabilhassein> i think i asked this before but I don't remember when so I can't easily search the logs:
11:32:03 <nabilhassein> is there something like getByte :: IO Word8 and putByte :: Word8 -> IO ()?
11:33:57 <dmwit> I can think of half a dozen ways of doing that, all kludgy in one way or another.
11:34:16 <dmwit> Is there a high level goal you're trying to achieve with that? It's possible that there's an XY problem here.
11:34:16 <geekosaur> not /per se/, there's getBuf / putBuf but for this you probably want to use something like binary or cereal
11:34:39 <geekosaur> (which is really ==dmwit)
11:35:11 <shachaf> geekosaur: getBuf? I keep seeing advertisements for that. It must be good.
11:35:21 <geekosaur> I think that's the name?
11:35:42 <geekosaur> oh, right, h-
11:35:46 <geekosaur> hGetBuf hPutBuf
11:35:49 <nabilhassein> dmwit: no, i just kind of dislike using fromEnum and toEnum to convert from Char because they're partial
11:36:17 <dmwit> Yes, fromEnum and toEnum are not a good idea.
11:36:37 <geekosaur> nabilhassein, I think you missed the point. you are probably not *really* just doing arbitrary byte I/O, but something higher level; it would make more sense to solve the higher level problem with a higher level library
11:36:38 <dmwit> But that doesn't really tell me anything about what you're trying to achieve, because the obvious way of getting and putting characters doesn't use them.
11:36:58 <nabilhassein> i am writing an interpreter for brainfuck
11:37:01 <geekosaur> rather than using stuff which will probably work but be inefficient and ugly and painful
11:37:10 <nabilhassein> so i can only get a single byte of input, or perform a single byte of output
11:37:11 <shachaf> nabilhassein: Don't use getChar to get a byte because that's plain wrong.
11:37:14 <geekosaur> ... oh, that might well change things
11:37:40 <dmwit> Right, so brainfuck is screwed up enough that you may actually have to do something screwed up in Haskell.
11:37:43 <dmwit> So that sucks.
11:38:01 <nabilhassein> shachaf: yeah, i didn't like it one bit
11:38:06 <nabilhassein> but i haven't found anything better
11:38:45 <dmwit> Have you considered not making yet another brainfuck interpreter? ;-)
11:39:11 <dmwit> I'm really only joking, though.
11:39:20 <optimusbrine> maybe bytestring IO?
11:39:22 <dmwit> You could consider setting the encoding of stdin/stdout to latin-1.
11:39:22 <nabilhassein> dmwit: it's so fun! no wonder so many people do it
11:39:26 <dmwit> This covers all and only the bytes.
11:39:41 <nabilhassein> dmwit: that sounds perfect. how do i do that?
11:39:44 <shachaf> I think people do it because it's a monoid, actually.
11:39:55 <dmwit> As optimusbrine suggests, you could also consider using ByteString's IO API. I'm not sure if they have byte-at-a-time commands, but it seems fairly likely.
11:40:13 <ocharles> you can specify the amount of bytes to get
11:40:14 <dmwit> ?hoogle hSetEncoding
11:40:14 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
11:40:14 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
11:40:18 <ocharles> so i imagine you can just set that to one
11:40:50 <ocharles> If you want arbitrary bytes, then use ByteString
11:40:58 <geekosaur> not directly, from the looks of it
11:42:28 <nabilhassein> ocharles: that seems like it will work. geekosaur: not sure i understand what you said -- were you saying that ocharles's suggestion won't work?
11:42:54 <geekosaur> [15 14:39] <dmwit> As optimusbrine suggests, you could also consider using ByteString's IO API. I'm not sure if they have byte-at-a-time commands, but it seems fairly likely.
11:43:27 <geekosaur> there's no convenient byte at a time option in ByteString (which makes sense because a ByteString really wants to be a collection of bytes for optimal performance)
11:43:50 <dmwit> Perhaps there is a lazy hGetContents-alike.
11:44:00 <dmwit> s/lazy/unsafeInterleave'd/
11:44:31 <ocharles> I suppose
11:44:38 <ocharles> you'd end up with [Word8], ultimately
11:45:40 <ParahSailin> @src hPutChar
11:45:40 <lambdabot> Source not found. Sorry.
11:49:16 <nabilhassein> i've used the bytestring api for output and i like the code much better already
11:49:27 <nabilhassein> but i don't see how to specify a number of bytes to read
11:50:10 <dmwit> As I was saying: just read them all and process them as if it was a lazy list. =)
11:50:35 <optimusbrine> BS.hGet takes a length
11:50:39 <dmwit> bf :: AST -> [Word8] -> [Word8]
11:51:24 <nabilhassein> dmwit: ah, now i understand
11:51:33 <nabilhassein> optimusbrine: right, not sure how i missed that. thanks!
11:51:37 <optimusbrine> :P
11:51:46 <dmwit> main = ByteString.interact (bf myWonderfulBrainfuckProgram)
11:52:21 <tij> how do you load multiple modules to ghci? everytime I try to load two, only one is available (despite compiling both)
11:52:42 <Apocalisp> edwardk: I see that Ermine source is public now
11:52:42 <dmwit> :l Foo.hs Bar.hs
11:52:44 <dmwit> :m + Foo Bar
11:52:46 <tij> :load a b only results in a's functions
11:52:46 <brendan> +Module ?
11:53:05 <geekosaur> :m + (or import in recentish ghci)
11:53:39 <tij> im trying to test my own stuff
11:54:02 <tij> if I do something like:   :load Conversion BF
11:54:11 <geekosaur> it's still a module
11:54:15 <tij> Prelude becomes: *Conversion>
11:54:59 <tij> geekosaur: ok that worked... any idea why :load wasn't working?
11:55:12 <dmwit> It worked. You just don't understand what :load is supposed to do.
11:55:57 <tij> dmwit: what is it supposed to do?
11:56:15 <dmwit> It just processes the files you ask for. If you want to put things in scope, you still have to do that with :m.
11:56:36 <Redz> hallo, i'm searching for update-functions on tuples like (b -> c) -> (a,b) -> (a,c) . does someone know, where i can find these? or how to do this with lenses?
11:56:39 <Zenol> hum, without hoogle it's a bit hard. Which is the method for reading an integer from a string (Remember I saw something like String->(Int, String) )
11:56:47 <dmwit> :t reads
11:56:48 <lambdabot> Read a => ReadS a
11:56:59 <dmwit> ?hoogle (b -> c) -> (a, b) -> (a, c)
11:56:59 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
11:56:59 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:56:59 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
11:57:04 <dmwit> bleck
11:57:06 <dmwit> :t second
11:57:07 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
11:57:18 <dmwit> :t Control.Lens.on Control.Lens._2
11:57:19 <lambdabot> Not in scope: `Control.Lens.on'
11:57:19 <Redz> thank you, dmwit
11:57:52 <byorgey> :t over _2
11:57:52 <lambdabot> Not in scope: `_2'
11:58:06 <byorgey> :t Control.Lens.over Control.Lens._2
11:58:06 <lambdabot> (Control.Lens.Internal.Indexed.Indexable Int p, Control.Lens.Tuple.Field2 s t a b) => p a b -> s -> t
11:58:09 <byorgey> eek
11:58:16 <shachaf> @let import Control.Lens.Tuple
11:58:17 <lambdabot>  Defined.
11:58:18 <shachaf> @let import Control.Lens.Setter
11:58:19 <lambdabot>  Defined.
11:58:21 <Zenol> read throw if the string isn't a number. I need something secure that only read the numeric value from the string and skip what remains.
11:58:31 <dmwit> :t reads
11:58:31 <lambdabot> Read a => ReadS a
11:58:37 <Redz> well, these functions arent common. ;)
11:58:47 <byorgey> :t over _2 :: (b -> c) -> (a,b) -> (a,c)
11:58:48 <lambdabot> (b -> c) -> (a, b) -> (a, c)
11:59:29 <Redz> byorgey: thats nice, thank you.
11:59:42 <dmwit> :t over
12:00:03 <dmwit> lambdabot: *poke*
12:00:29 <Taneb> @type over
12:00:35 <Taneb> @ping
12:00:35 <lambdabot> pong
12:00:45 <Taneb> > "hi"
12:00:48 <shachaf> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:00:49 <lambdabot>   "hi"
12:00:52 <Taneb> THERE WE Go
12:01:12 <dmwit> botsnack for shachaf =)
12:02:13 <byorgey> #HCi, the #haskell Haskell Compiler interactive mode
12:02:43 <c_wraith> > [reads "123", reads "foo" ]:: [[(Int, String)]] -- Zenol
12:02:44 <lambdabot>   [[(123,"")],[]]
12:04:07 <dmwit> > reads "(( (-123e5)) )" :: ReadS Double -- also fun
12:04:07 <lambdabot>   Couldn't match type `[(a0, GHC.Base.String)]'
12:04:07 <lambdabot>                with `GHC.Base...
12:04:28 <dmwit> > (reads :: ReadS Double) "(( (-123e5)) )"
12:04:29 <lambdabot>   [(-1.23e7,"")]
12:05:18 <dmwit> (This is also why writing your own parser is so popular. WAY faster.)
12:05:42 <Zenol> ohw :o
12:06:33 <klrr_> GOD, why... no type signatures....
12:07:03 <Zenol> dwit> Why does your irst read failed?
12:07:11 <tac> klrr_: Just use Hindley-Milner! :P
12:07:27 <klrr_> tac: what's that?
12:07:51 <dmwit> Zenol: Because ReadS Double is String -> [(Double, String)].
12:07:53 <klrr_> is it a type system, but then comes the queston, what's a type system
12:08:19 <tac> Hindley-Milner is the algorithm that Haskell uses to figure out all your types for you if you leave them out.
12:08:44 <optimusbrine> well, most of them anyhow :)
12:08:59 <klrr_> tac: aah, okey, well i was pointing at the offical elm examples, they dont have type signatures which makes them pain in ass to reason about
12:09:23 <tac> klrr_: ah. I believe Elm also has HM type inference... I think
12:10:02 <tac> klrr_: You might want to contact the author of Elm and give him that feedback.
12:10:34 <klrr_> i might yes, i only got one problem with Elm, it's for the web, why not a normal language? :(
12:10:52 <Zenol> dwit> Ohw sorry, I'm a bit tired. Thanks :)
12:11:17 <dmwit> If you complain, you might want to use slightly different words than "reason about", since that has a pretty specific meaning in the community of folks who muck about with type systems and functional languages.
12:11:25 <robde> hello. why does (uncurry id) ((+1),2) equal 3?
12:11:41 <tac> klrr_: The whole FPR-for-UI concept relies on having a viable UI toolkit. Javascript's DOM is the most accessible platform in the modern era.
12:12:02 <tac> @type uncurry id
12:12:02 <lambdabot> (b -> c, b) -> c
12:12:04 <klrr_> tac: but isnt streaming IO basically a signal?
12:12:06 <Fuuzetsu> (uncurry id) ((+1), 2) = id (+1) 2 = (+1) 2 = 3
12:12:11 <klrr_> tac: everything is FRP
12:12:23 <klrr_> or well, im wrong, but it would be cool :P
12:12:38 <ofan> @type uncurry
12:12:39 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:12:45 <robde> Fuuzetsu: oh, now I see it, thanks.
12:12:51 <klrr_> dmwit: reason about in the sense that it's easier to read the code if you can quickly see what types being used
12:13:22 <tac> klrr_: also keep in mind, perhaps, Elm is actually Evan's master's thesis project
12:13:34 <dmwit> That's fine. You don't have to tell me. I'm just trying to alert you to a possible source of miscommunication.
12:13:58 <tac> klrr_: It's one guy who just recently finished school working on it. (Although I guess he got hired to work on Elm fulltime recently)
12:14:25 <klrr_> it's much easier to understand than yampa and opengl
12:14:39 <klrr_> i wanna make a copy of it for openGL
12:14:43 <tac> (and yeah, dmwit is right. "Hard to reason about" has some specific connotations with Functional Programming. Perhaps just say "it's hard to figure out the types and understand the program" :)
12:14:45 <klrr_> so i can make a game
12:14:58 <tac> klrr_: I'm sure it's a patches-welcome kind of thing :)
12:16:07 <klrr_> it would actually be a good project i can contribute too, but first i have to learn it, and it doesnt have any docs, bit ill try
12:16:38 <klrr_> but im not good enough so no idea anyway -.-
12:17:00 <merijn> Does anyone see why this reactive-banana code results in <<loop>>? http://lpaste.net/90910
12:19:06 <Zenol> > (reads :: ReadS Double) "asdad"
12:19:07 <lambdabot>   []
12:19:18 <Zenol> hrumf ...
12:19:42 <benmachine> > (reads :: ReadS Double) "9asdad"
12:19:43 <lambdabot>   [(9.0,"asdad")]
12:20:25 <Zenol> oh, i wrote read instead of reads -_-
12:20:40 <Fuuzetsu> :t reads
12:20:41 <lambdabot> Read a => ReadS a
12:20:42 <Fuuzetsu> :t read
12:20:43 <lambdabot> Read a => String -> a
12:21:02 <dmwit> merijn: At a guess: evaluating "mfix ui" means evaluating behavior, which means evaluating delay, which means evaluating mfix ui.
12:23:00 <dmwit> I wonder whether (mfix (return . f) = return (fix f)) is a MonadFix law.
12:23:25 <shachaf> dmwit: It is.
12:23:43 <merijn> dmwit: No, the second argument of stepper shouldn't be evaluated until the next event
12:23:54 <tulcod> i want to write haskell bindings for libxkbcommon, which is a C library which processes keyboard events. it works by feeding it physical keyboard events to a "state", and it returns processed events. in theory, it is a pure library, but in all practical uses, we would send it events originating from IO. should I use some kind of State monad to represent the library's state (one can have several parallel states which are constructed by a library call)?
12:23:57 <merijn> Unless my entire understanding of reactive-banana is wrong
12:24:42 <merijn> dmwit: Since it only needs to evaluate the behavior in delay when eInput happens
12:24:58 <dmwit> merijn: Do you expect the implementation of "stepper" to pattern match on its second argument?
12:25:59 <merijn> dmwit: I dunno how it's implemented, but afaik it should be lazy in its second argument, because 1) that's what Apfelmus said on stackoverflow 2) else the monadfix instance of moment would be useless
12:26:04 <dmwit> Never mind. Your expectations don't matter. The source says it does.
12:26:17 <merijn> That sounds like a bug
12:26:51 <dmwit> Is it possible you misunderstood what Heinrich said?
12:27:05 <dmwit> I mean, I have not yet ruled out the possibility that I am very wrong.
12:27:19 <dmwit> That still would not surprise me; my guess is still only like... 25% confidence level.
12:27:53 <dmwit> But the MonadFix instance doesn't matter here, is what I was getting at with the law above.
12:28:02 <merijn> dmwit: I think you missed that I'm <@ the behavior over the event
12:28:05 <dmwit> Since you return immediately, you can just use fix and move the return outside.
12:28:12 <merijn> the pattern match in stepper should happen on the result of <@
12:28:25 <dmwit> Yes, that's true.
12:28:29 <shachaf> <ꙮ
12:28:44 <merijn> And that should just wait until an event actually happens on eInput
12:28:47 <dmwit> Do you not expect <@ to pattern match its first argument?
12:28:57 <merijn> dmwit: No, that'd make no sense
12:29:06 <dmwit> Again, I feel (because of your talk about events and stuff) that I'm not making my point as clearly as I can.
12:29:11 <merijn> dmwit: <@ returns the first value at the time that the argument right happens
12:30:02 <dmwit> I'm not sure how to clarify what I mean.
12:30:04 <robde> is it possible to ommit the argument in a lambda expression too? like in f a = (+) a?
12:30:20 <klrr_> could FRP be applied to stuff like IO? for example, could Handle be replaced with a Signal?
12:30:22 <merijn> robde: Sure
12:30:24 <shachaf> robde: What?
12:30:29 <structuralist> dmwit: what are the connotations of "reason about"?
12:30:41 <dmwit> For example, when talking about (>>=) :: [Int] -> (Int -> [Bool]) -> [Bool], I don't expect (>>=) to pattern-match on Ints, but I do expect it to pattern match on [Int]s and [Bool]s.
12:31:04 <tac> is banana reactive still the nicest intro to FPR?
12:31:10 <benmachine> I would agree with dmwit as far as the use of mfix is redundant here and could be replaced with fix
12:31:13 <robde> oh never mind :) that’s the same as just ommiting the whole lambda expression, right?
12:31:15 <tac> I have been putting off learning more about FPR for forever :<
12:31:27 <dmwit> Likewise, when using (<@), I don't expect (<@) to pattern match on the contained values that are getting munged by events, but I do expect it to pattern match on the Event blah.
12:31:28 <merijn> dmwit: Yes, but the value it's getting is (partially) just the stepper itself
12:31:37 <robde> (\ x -> (+) x) = (+)
12:31:44 <klrr_> tac: im trying to learn FRP, it's really annoying since there's mostly research papers which makes no sense
12:31:47 <benmachine> robde: yep
12:32:03 <structuralist> tac: check out http://conal.net/blog/tag/frp
12:32:24 <dmwit> structuralist: When talking about reasoning, FP folks usually mean "equational reasoning"; that is, replacing subexpressions in a program by the thing they evaluate to without changing the meaning of the program.
12:32:31 <Ralith> klrr_: why does that make no sense?
12:32:38 <merijn> Really I just need some input/details from Apfelmus, I think, but he's not on IRC and the latency of stackoverflow is awful :(
12:32:39 <structuralist> I see
12:32:41 <robde> here, I present you my swap implementation: swap = uncurry $ flip $ curry id
12:34:15 <klrr_> Ralith: i donno, the examples is using math syntax instead of haskell syntax and such things that makes it harder to understand, forcing me to learn math stuff while i wanna learn about FRP, also, i am also very stupid making it also harder
12:34:27 <dmwit> merijn: Can I recommend just evaluating "fix ui'" in ghci and seeing if it <<loop>>s? Here ui' is just like ui but without the return.
12:34:30 <tac> equational reasoning means equal things can be replaced by equal things. Variables may always be replaced by their definitions, and the program still evaluates to the same value.
12:34:35 <robde> where can I find the definition of "if"? or is it hard-coded?
12:34:43 <benmachine> robde: cute
12:34:49 <dmwit> robde: It's hard-coded.
12:35:18 <benmachine> robde: "if" is a piece of syntax instead of an ordinary function, but you can write an ordinary function that does more or less the same thing
12:35:22 <dmwit> robde: You may change what it means by enabling the RebindableSyntax extension. See the GHC manual for more details if that sounds like the kind of thing you want to do.
12:36:01 <dmwit> robde: curry id = (,), right? so swap = uncurry $ flip (,) -- ?
12:36:07 <dmwit> :t uncurry $ flip (,)
12:36:08 <lambdabot> (a, b) -> (b, a)
12:36:12 <benmachine> :t curry id
12:36:13 <lambdabot> a -> b -> (a, b)
12:36:29 <benmachine> dmwit: makes sense
12:36:40 <benmachine> @free a -> b -> (a,b)
12:36:40 <lambdabot> Extra stuff at end of line
12:36:43 <benmachine> oh :(
12:36:45 <dmwit> merijn: Sorry, scratch the "ghci" suggestion. You'll have to compile it. ghci doesn't do <<loop>>s.
12:36:57 <benmachine> dmwit: well, it stops doing anything :P
12:37:01 <dmwit> ?free a -> b -> Pair a b
12:37:01 <lambdabot> Extra stuff at end of line
12:37:03 <dmwit> aww
12:37:16 <dmwit> ?djinn-add data Pair a b = Pair a b
12:37:23 <dmwit> oh, free
12:37:27 <dmwit> I'm dum
12:37:41 <dmwit>  ?free-add -- ;-)
12:37:45 <merijn> dmwit: Also, it's not possible to pull UI out of the moment monad...
12:37:47 <benmachine> I seriously can't get anything useful out of @free
12:37:57 <benmachine> anything other than an error, that is
12:38:01 <shachaf> @free dmwit :: a -> b -> (a,b)
12:38:01 <lambdabot> $map_Pair f g . dmwit x = dmwit (f x) . g
12:38:01 <dmwit> merijn: disagree
12:38:02 <merijn> dmwit: So I can't run it with just fix
12:38:03 <Zenol> hum, if I recall well I can use guard to skip the whole remaining code of a do bloc (IO in my case)?
12:38:13 <merijn> dmwit: Where would I get eInput from?
12:38:16 <dmwit> merijn: Recall my law above: mfix (return . f) = return (fix f).
12:38:31 <benmachine> Zenol: whether or not you can use guard depends on what monad you are using
12:38:35 <merijn> dmwit: I'm using values produced in the Moment monad inside the definition
12:38:58 <dmwit> All the things you're using are let-bound; there's no bind anywhere.
12:39:10 <merijn> dmwit: There's one right above the defintion...
12:39:21 <merijn> line 27
12:39:27 <benmachine> merijn: right, there isn't one inside the definition
12:39:41 <merijn> Yes, I can remove the moment from ui, but I can't *run* it
12:40:01 <merijn> I can't get the ui definition outside of Moment, even if ui isn't a Moment return value
12:40:01 <dmwit> merijn: Okay, point taken. What happens if you let eInput = undefined? =)
12:40:13 <dmwit> Just for fun.
12:40:16 <dmwit> For Science.
12:40:19 <merijn> dmwit: Then I expect it to crash regardless of what my code does
12:40:25 <lpaste> benmachine annotated “reactive-banana <<loop>>” with “reactive-banana <<loop>> (annotation)” at http://lpaste.net/90910#a90937
12:40:26 <dmwit> Let's test that hypothesis.
12:40:37 <benmachine> merijn: how about doing that ^?
12:41:05 <benmachine> oh wait
12:41:10 * benmachine edit
12:41:30 <lpaste> benmachine revised “reactive-banana <<loop>> (annotation)”: “reactive-banana <<loop>>, using fix” at http://lpaste.net/90937
12:42:16 <benmachine> merijn: according to MonadFix laws, what I jsut pasted should be the same
12:42:27 <benmachine> merijn: I didn't typecheck it though; does it make sense?
12:42:46 <merijn> "fix xyzzy" returns
12:42:52 <merijn> eh
12:42:56 <merijn> "fix ui"
12:43:14 <merijn> Which is where I pull out eInput and replace it with undefined
12:43:20 <Zenol> benmachine> It's an IO monad. Not sure it's going to work...
12:43:46 <benmachine> Zenol: basically the monad has to have a MonadPlus instance, I think it's possible to define one for IO but it's kind of icky
12:44:00 <dmwit> :t when
12:44:01 <lambdabot> Monad m => Bool -> m () -> m ()
12:44:04 <merijn> benmachine: That <<loop>>'s too
12:44:10 <NemesisD> is there an established pattern for writing point free functions that take > 1 argument
12:44:48 <dmwit> There are a certain brand of people who will tell you that all functions take exactly 1 argument.
12:45:18 <NemesisD> yeah i know, and i know people get mad when i talk about > 1 argument, but i'm addressing people who know what i mean
12:45:33 <NemesisD> :P
12:45:53 <shachaf> This certain brand of people might suggest that you don't know what you mean either!
12:46:41 <Zenol> dmwit > when boolean $ \_ -> ?
12:47:07 <NemesisD> bah
12:47:19 <dmwit> Zenol: None of "when"'s arguments are functions.
12:48:20 <Zenol> dwit> It's truw T.T
12:48:21 <n-dolio> The second one can be.
12:48:29 <shachaf> n-dolio: Not usefully.
12:48:54 <Zenol> $ do is better so :p
12:49:30 <dmwit> I find it sort of amusing that Zenol has not yet spelled my nick correctly.
12:49:48 <n-dolio> It's pretty hard to spell, dwight.
12:50:26 <dmwit> =D
12:50:41 <dmwit> Also, as usual, I'm wrong.
12:51:02 <dmwit> merijn: So, have you tried my proposed experiment yet?
12:51:02 --- mode: ChanServ set +o mauke
12:51:02 --- mode: mauke set -b *!*@114.108.49.105
12:51:24 <shachaf> dmwit: The correct spelling is "dmwit: " anyway.
12:51:29 <merijn> dmwit: Yes, I just said
12:51:43 <merijn> Replacing eInput with undefined and doing "fix ui" returns
12:51:55 <dmwit> Ah, cool. Sorry I missed that.
12:52:01 <merijn> Not although replacing mfix ui with "fix ui" still crashes too
12:52:11 <dmwit> Provided it returns without throwing an exception, that puts my hypothesis to rest quite soundly.
12:52:30 <merijn> It returns without throwing, yeah
12:52:48 <dmwit> aaa, that's what "fix xyzzy" returns meant
12:53:02 --- mode: mauke set -o mauke
12:54:05 <merijn> dmwit: hence the "eh..."fix ui"" below that :p
12:55:17 <tac> Oh, speaking of FPR... arrows. I heard there was some recent find that arrows can be given a more solid mathematical foundation using profunctors.
12:55:29 <tac> Is there any material on that?
13:00:41 <dmwit> merijn: Anyway, given that this is the only place I can see that has any recursion whatsoever, I would advise focusing on it. =P
13:00:56 <Eduard_Munteanu> @hoogle void
13:00:56 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:00:56 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
13:00:56 <lambdabot> package void
13:01:08 <Eduard_Munteanu> There's something wrong with the online hoogle
13:01:14 <benmachine> Eduard_Munteanu: we know
13:01:21 <benmachine> fpcomplete apparently have their own hoogle
13:01:24 <benmachine> I forget where it is
13:02:27 <merijn> dmwit: Yeah, I actually had it directly recursive, which is wrong (which Apfelmus pointed out on SO too), but now that I removed that direct issue, I think it should work. But I don't understand the reactive-banana internals enough to say for sure and, as I said, the latency to wait for a clarification on SO is so long :(
13:02:41 <merijn> I'm just waiting around and not doing anything until that happens :\
13:02:49 <dmwit> Well.
13:02:59 <dmwit> There's no real difference between direct recursion and using fix.
13:03:02 <dmwit> ?src fix
13:03:02 <lambdabot> fix f = let x = f x in x
13:03:14 <merijn> dmwit: No, I meant something more operational
13:03:22 <dmwit> okay
13:03:24 <merijn> dmwit: See my question here: http://stackoverflow.com/questions/17634884/how-to-implement-reactive-banana-behaviors-that-recursively-depend-on-themself
13:03:49 <merijn> dmwit: The problem is that that one uses its own behavior without a well-defined value, which is why I introduced the "delay" behavior
13:03:54 <benmachine> merijn: points for "themself"
13:04:04 <benmachine> it is an undervalued word
13:04:24 <merijn> The stepper makes sure that the initial value of the behavior is well-defined
13:04:33 <merijn> (i.e. True)
13:06:55 <edwardk> anything new on tekmo's 'fork lens' front?
13:07:32 <johnw> wuh?
13:07:43 <merijn> edwardk: Your site appears to be dead?
13:08:16 <edwardk> noise on the pipes mailing list. apparently my 'there is no viable lens-core' response/faq entry has finally caused tekmo to speak of mutiny or something
13:08:21 <edwardk> see the haskell pipes mailing list
13:09:19 <johnw> nice, it's on Gmane, adding it to my news reader...
13:31:04 <FreeFull> > [undefined..undefined]
13:31:04 <lambdabot>   *Exception: Prelude.undefined
13:31:19 <FreeFull> > map (const 3) [undefined..undefined]
13:31:20 <lambdabot>   Could not deduce (GHC.Enum.Enum a0)
13:31:20 <lambdabot>    arising from the arithmetic sequence...
13:31:39 <FreeFull> > map (const 3) [undefined :: Int..undefined]
13:31:40 <lambdabot>   <hint>:1:29: parse error on input `Int..'
13:31:46 <FreeFull> > map (const 3) [*undefined :: Int)..undefined]
13:31:47 <lambdabot>   <hint>:1:27: parse error on input `::'
13:31:50 <FreeFull> > map (const 3) [(undefined :: Int)..undefined]
13:31:51 <lambdabot>   *Exception: Prelude.undefined
13:32:01 <FreeFull> Ok, makes sense
13:34:12 <optimusbrine> http://pastebin.com/UA5Wm141 maybe I am getting a little rusty, but ghci complains that this is non-exhaustive, and i don't see how
13:34:13 <mauke> The paste UA5Wm141 has been copied to http://lpaste.net/90940
13:35:39 <shachaf> optimusbrine: Please post the error along with your code.
13:35:57 <shachaf> (I mean, always. Not just now. It's just a good thing to do.)
13:35:58 <optimusbrine> *** Exception: Obfusc.hs:45:1-37: Non-exhaustive patterns in function unPair
13:36:02 <mm_freak> i took some time today to write a new tutorial on writing a fast, parallel primality test for mersenne numbers in haskell
13:36:07 <geekosaur> that looks wrong; the pattern [(a,a)] does not match a pair of the same thing
13:36:09 <mm_freak> http://ertes.de/Math/Lucas-Lehmer%20in%20Haskell
13:36:21 <optimusbrine> and that span is over the last clause of unPair
13:36:47 * hackagebot happstack-foundation 0.4.0 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.4.0 (JeremyShaw)
13:36:58 <shachaf> geekosaur: ?
13:37:02 <pantsman> optimusbrine, unPair / unpair
13:37:04 <pantsman> are you sure?
13:37:17 <geekosaur> line 2
13:37:34 <shachaf> Line 2 is a type signature.
13:37:41 <geekosaur> oh, duh
13:37:47 <geekosaur> sorry
13:37:48 <shachaf> Oh, yes, it's what pantsman said.
13:38:02 <shachaf> optimusbrine: You should turn on the warning for missing type signatures.
13:38:06 <shachaf> Then GHC would have caught it.
13:38:34 <optimusbrine> what is missing a type signature?
13:38:43 <shachaf> optimusbrine: See what pantsman said.
13:39:03 <acowley> Or use ghc-mod
13:39:05 <geekosaur> optimusbrine, type signature was a false alarm. the problem is what pantsman said
13:39:18 <shachaf> geekosaur: No, -Wall would have caught this, since unpair has no type.
13:39:25 <optimusbrine> oh, i see now. typo
13:39:27 <optimusbrine> thanks
13:39:28 <geekosaur> but turning on the warning would have told you about the bug on line 3
13:39:38 <shachaf> optimusbrine: Also, a good way to figure out this sort of thing is to load the module in ghci and experiment with different inputs.
13:39:48 * geekosaur might be too tired to think straight about this...
13:39:59 <shachaf> E.g. you could've given it a non-empty list, then an empty list, and seen that it fails even on an empty list.
13:41:00 <TakumoKatekari> Hi all, I'm a bit of a haskell noob, can someone tell me what the difference between => and -> is in a type signature/
13:41:39 <shachaf> TakumoKatekari: Hoogle would normally tell you, but it's down.
13:41:45 <srhb> TakumoKatekari: Things before the => are class constraints, ie  "Ord x => " means in the following type, x must be a member of the Ord type class
13:41:47 * hackagebot happstack-server-tls 7.0.4 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.0.4 (JeremyShaw)
13:43:01 <TakumoKatekari> srhb: So all the items before the => are for type classes e.g. Ord Eq Show etc
13:43:14 <shachaf> The things before => are constraints, yes.
13:43:15 <TakumoKatekari> and then the -> is just for between parameters and the output?
13:43:19 * geekosaur has never quite understood how => could be confused with ->. the thing before => does not look like a parameter...
13:43:41 <TakumoKatekari> Well learnyouahaskell didn't explain it very clearly
13:43:42 <shachaf> > let foo :: Int => Int; foo x = 5*x in foo 5 -- geekosaur: checkmate
13:43:43 <lambdabot>   25
13:43:52 <shachaf> TakumoKatekari: Sorry, ignore what I just said.
13:44:02 <shachaf> TakumoKatekari: It's a bug in GHC. I shouldn't have brought it up here.
13:44:23 <TakumoKatekari> is GHC the official haskell implementation or just the de facto?
13:44:31 <Taneb> De facto
13:44:34 <Taneb> Very facto
13:44:35 <geekosaur> de facto. there are others, just not widely used
13:44:44 <geekosaur> (jhc/ajhc, uhc, etc.)
13:45:14 <shachaf> GHC is the Haskell implementation de facto and du jour, but not de jure.
13:45:24 <Sonderblade> hugs?
13:45:31 <geekosaur> hugs is dead
13:45:49 <geekosaur> (I mean, it's still there, but its code hasn't been touched in years)
13:46:27 <lispy> Hugs should be almost ideal for emscripten though
13:46:29 <byorgey> TakumoKatekari: it is official to the extent that it is included with the Haskell Platform.
13:46:40 <lispy> Get some haskell into the browser that way
13:47:39 <TakumoKatekari> I just see haskell and always want to learn it
13:47:44 <TakumoKatekari> gotta just get my head into it
13:50:09 <b2coutts> TakumoKatekari: I'm not sure how I feel about LYAH
13:50:31 <b2coutts> honestly I don't like it very much, but I don't know what else I'd recommend to beginners
13:51:11 <Banistertab> B2coutts why dont you like it
13:51:59 <b2coutts> Banistertab: a few things; the general aesthetic, the fact that they spent a long chapter just listing a bunch of functions in various libraries
13:52:35 <Banistertab> Yeah i just skipped that part
13:52:46 <b2coutts> and in general, I feel like they waste a lot of time explaining things that aren't difficult, and skipping things that need to be taught
13:52:58 <Banistertab> I thought it covers functors/applicatives/monads pretty well
13:53:35 <acowley> Yeah, I think it covers the core pieces at a pretty good pace.
13:56:48 * hackagebot unm-hip 0.0.0.3 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.0.0.3 (JosephCollard)
14:03:30 <orzo> haskell.org is offering me a 28meg BIN file
14:03:45 <johnw> i think that's the hoogle binary
14:03:49 <troydm> orzo: be grateful for this offer
14:03:52 <johnw> must mean CGI isn't enabled
14:04:12 <orzo> http://haskell.org/hoogle
14:04:36 <monochrom> yikes
14:04:39 <troydm> orzo: it's probably some problem after migration or something
14:06:10 <hpc> 28 megs? clearly a haskell binary
14:06:11 * hpc ducks
14:07:19 <monochrom> hehe
14:09:27 <orzo> i downloaded it but it wont run cause it's not finding libgmp
14:09:52 <benmachine> orzo: you know, some would say it's a bad idea to just try running random binaries you downloaded and don't know what they are :)
14:10:09 <orzo> heh
14:10:11 <benmachine> monochrom: maybe it would be a good idea to put a note specifically about hoogle in the topic, since it keeps coming up
14:10:42 <benmachine> (but then, maybe that's just because some overlook the topic)
14:10:56 <orzo> i figure it's a binary that will implement hoogle
14:11:06 <orzo> so i just put it into cgi-bin on localhost...
14:11:08 <orzo> heh
14:11:20 <benmachine> orzo: well, good luck with that
14:11:28 <benmachine> orzo: you can already just get hoogle from hackage
14:11:34 <benmachine> orzo: I don't know how the database works though
14:11:46 <orzo> actually i tried to get hoogle from hackage not long ago
14:11:50 <orzo> and it failed to install
14:12:02 * optimusbrine got it this morning just fine
14:12:43 <hpc> the way i usually install haskell binaries is to cabal-dev install, then copy the binary to /usr/bin
14:12:45 <orzo> did you do that because the site is down?
14:12:56 <optimusbrine> i did :)
14:13:35 <dropdrive> Is hoogle working for anyone?  I go and get a 28MB download
14:13:42 <orzo> heh
14:13:49 <orzo> me2
14:13:53 <ctult> Is there such a language that is both purely OO and purely functional?
14:14:02 <notdan> You can download the databases from hackage too.
14:14:15 <notdan> For example, to get the database for diagrams-core, you download the file http://hackage.haskell.org/packages/archive/diagrams-core/latest/doc/html/diagrams-core.txt
14:14:17 <ctult> (e.g. Everything is an object and stems from one base class, but the methods have no side-effects)
14:14:24 <notdan> Alternatively you can do: hoogle --data-all
14:15:04 <tdammers> ctult: how is that functional? It's just OOP without mutable state.
14:15:11 <hpc> ctult: everything is an object in a category!
14:15:23 <orzo> well, my hoogle install failed again
14:15:38 <optimusbrine> where is it failing?
14:15:46 <hpc> optimusbrine: on his computer, duh :P
14:15:50 <optimusbrine> XD
14:16:04 <orzo> haskell-src-exts-1.13.5 failed during the configure step. The exception was:
14:16:04 <orzo> ExitFailure 1
14:16:04 <orzo> hoogle-4.2.16 depends on haskell-src-exts-1.13.5 which failed to install.
14:16:24 <hpc> oh right, hoogle is down
14:16:35 <hpc> hackage is up!
14:16:38 <hpc> and it has graphs now
14:16:48 <dmwit> orzo: This means you should scroll up to find the real error in the build log for haskell-src-exts.
14:16:55 <optimusbrine> haskell-src-exts is probably failing on some external dependency
14:16:59 <optimusbrine> yeah that
14:17:10 <ctult> tdammers: It would be based more on mathematical functions than "methods",
14:18:07 <c_wraith> hmm.
14:18:09 <hpc> it has dependencies of array (>=0.1), base (==4.*), cpphs (>=1.3), pretty (>=1.0)
14:18:11 <tdammers> ctult: I'd still think "functional programming" is about higher-order functions about as much as it is about purity
14:18:15 <orzo> Configuring haskell-src-exts-1.13.5...
14:18:15 <orzo> setup: The program happy version >=1.17 is required but it could not be found.
14:18:24 <orzo> that was a whole lot of scroll
14:18:24 <dmwit> orzo: solution: cabal install happy
14:18:41 <tdammers> if not more, in practice (although this opinion is probably more popular among Schemers or Common Lispers or Clojurians than here)
14:18:47 <dmwit> In case you don't have alex, you'll probably want to install that, too.
14:18:49 <ctult> tdammers: Who said there would be no higher-order functions, or tail calls, or even currying?
14:19:03 <optimusbrine> and make sure .cabal/bin is in your path
14:19:09 <c_wraith> What would people think about having a native binding that included source for the native library, but also had a cabal flag to link against the system version instead?
14:19:25 <optimusbrine> ~/.cabal/bin *
14:19:27 <c_wraith> Is that a terrible idea, or a reasonable idea?
14:19:38 <hpc> c_wraith: it would have my thumbs up, so long as it linked against the system by default
14:20:01 <c_wraith> hpc: would need to go the other way around, for docs to build on hackage...
14:20:18 <hpc> or linked against (system, or included if system not present)
14:20:18 <napping> ctult: so where do objects come in?
14:20:25 <napping> row-variable polymorphism? open recursion?
14:20:32 <napping> I'm looking for some open recursion myself
14:20:37 <c_wraith> hpc: hmm.  that would be a good default, but that sounds ugly to implement
14:20:43 <hpc> yeah
14:21:03 <tdammers> ctult: if you want to go full OOP, you can't have free functions, only methods
14:21:26 <napping> is there any better way than making a new record type for the mutual recursion group, opening the implementation to a function transforming those records, and perhaps binding the fixpoint to nice names?
14:21:27 <ctult> tdammers: It depends on your definition.  I am thinking of Alan Kay's,
14:21:27 <c_wraith> hpc: I just had a worrying thought.  It's only a few steps past that to get to autoconf
14:21:54 <tdammers> ctult: well, you said yourself you want everything to be an object...
14:21:55 <dmwit> Huh. I wonder whether anybody ever proposed having a universal Hackage flag that Hackage sets to True on every build.
14:21:58 <dmwit> That would be nice.
14:21:58 <monochrom> haskell-src-exts takes a long time to build
14:22:32 <ctult> tdammers: Everything is an object, even functions that take functions and return them.
14:22:43 <dropdrive> Are there "Do's and Don't's" guidelines for writing fast attoparsec code?
14:23:00 <dmwit> Then we could have "defaults that work good for most people" and "defaults that work good for Hackage" without very much conflict.
14:23:09 <tdammers> ctult: ah, right. So, basically, you're thinking of a pure version of JavaScript, maybe?
14:23:14 <tdammers> with static types?
14:23:25 <orzo> installing happy didn't work dmwit
14:23:26 <hpc> dmwit: it's not too late to put it in hackage2!
14:23:37 * dmwit nominates c_wraith
14:23:37 <hpc> orzo: is happy on your $PATH?
14:23:41 <orzo> cabal info shows installed happy version is "Unknown"
14:23:42 <ctult> tdammers: Yes, it would probably have to be prototype-based.
14:23:47 <orzo> even though the install just completed without issue
14:24:12 <dmwit> More to the point, is happy on cabal's PATH?
14:24:46 <tdammers> ctult: I'm in. Is it done yet? :D
14:24:55 <hpc> orzo: same for me; binaries don't install quite like libraries so you don't get all the info
14:25:02 <napping> ctult: have
14:25:07 <napping> have you tried O'Caml's object system?
14:25:18 <orzo> well i guess it was the PATH thing
14:25:30 <orzo> seems to have gotten farther than before now
14:25:36 <ctult> tdammers: I wish.  I would use it.
14:25:43 <ctult> ;)
14:25:46 <hpc> when you do "cabal install happy", it installs it by default to ~/.cabal/bin
14:25:59 <dmwit> Oh, "cabal info happy".
14:26:01 <hpc> most people will recommend adding that to your path
14:26:03 <dmwit> Yeah, you should expect that to lie.
14:26:06 <ctult> napping: It's not really like that.  OCaml's is impure by design.
14:26:10 <monochrom> "cabal info" will not find happy, even if installed. it's just an executable. cabal doesn't track executables
14:26:47 <napping> how so? It has some extra support for mutable stuff, but you can define immutable objects if you like
14:27:25 <orzo> isn't hoogle gonna be up by the time my build completes
14:27:29 <ctult> napping: Yes, but the object system *itself* is mutable.
14:27:37 <napping> huh?
14:28:28 <napping> no more than any of the rest of the type system
14:28:37 <lispy> monochrom: I think they're trying to change that? recent cabal does stuff with a wold file
14:28:40 <lispy> world*
14:28:50 <ctult> napping: This language is going to be fully pure.
14:28:55 <ctult> No side-effects allowed
14:28:59 <dmwit> The world file doesn't have to do with tracking executables.
14:29:01 <lispy> I think the point of the world file is to track cabal installed binaries (but I'm not sure)
14:29:04 <lispy> ah
14:29:07 <lispy> what is it?
14:29:11 <monochrom> the world file is only history of installs, not current state
14:29:15 <dmwit> It keeps a list of all installed packages.
14:29:21 <dmwit> There's no mapping between executables and packages.
14:29:57 <monochrom> for example if you unregister a package, or move to another GHC altogether and so you have no packages, it wouldn't know
14:30:27 <napping> ctult: why does that stop you from looking at pure contstructs in languages that are not totally pure?
14:30:28 <orzo> hoogle is installed
14:30:29 <lispy> What's the point of the world file?
14:30:35 <orzo> but i've no idea what i wanted to search
14:30:37 <monochrom> I don't know
14:30:57 <ctult> napping: I will think about it, but I'm not sure how it would work.
14:31:12 <dmwit> The world file is a strange beast. I think it was originally introduced in the hopes of giving some way of dealing with GHC upgrades, but it doesn't really do that very well.
14:31:53 <monochrom> perhaps its author thinks that you will never throw away packages (how unthinkable!), therefore install history suffices?
14:33:17 <dmwit> Perhaps it is just another log file. =)
14:34:33 <napping> ctult: objects have a bunch of pure functions, maybe returning other objects
14:35:09 <napping> recursive types and row-variable polymorphism let you give types to a bunch of things
14:35:54 <ctult>  hm
14:41:49 * hackagebot mongodb-queue 0.2.3.0 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.3.0 (GregWeber)
14:44:24 <gspr> Suppose I have a C function  int foo(state *s);  that is pure in the sense that it is fully determined by the opaque state type. If all I can hold on the Haskell side is a pointer to the opaque state, is there a recommended way to create a monad for foo (using unsafePerformIO, of course)?
14:44:53 <acowley> What's a good package to get functor composition from?
14:45:03 <gspr> So far I've thought of having a simple counter that mimics the state
14:45:38 <elliott> acowley: transformers
14:45:54 <acowley> gspr: I'm not entirely sure what you mean by "create a monad for foo", but if you just want to stash the Ptr somewhere you could use Reader
14:46:28 <acowley> elliott: thanks!
14:46:35 <acowley> elliott: I wouldn't have thought to look there
14:46:48 <gspr> acowley: Yes, I've been thinking long the lines of reader, but won't I run the risk of GHC optimizing everything I do out since the Ptr never changes?
14:46:54 <gspr> s/long/along/
14:47:24 <acowley> gspr: If those optimizations aren't valid, and you need to sequence things in IO, then ReaderT over IO
14:47:55 <gspr> acowley: Exactly. I'm essentially looking to build a very restricted IO where only certain operations are allowed (essentially just calls to foo)
14:49:04 <acowley> gspr: You can secure things by newtype'ing where needed, and don't export the constructor
14:50:01 <gspr> acowley: Yeah, I've done it that way before. There's no way to build a "mini-IO" myself though (with unsafePerformIO and similar diabolical tools, of course)?
14:50:33 <acowley> I don't see why you'd want to do that, though
14:50:40 <FreeFull> For science
14:50:50 <gspr> acowley: Fun and absolutely no profit
14:50:52 <acowley> if your newtyped ReaderT (Ptr CFoo) IO doesn't export constructors, nobody can run IO actions in it
14:51:09 <gspr> acowley: Yeah, I guess it's really what I should do. Thanks :)
14:51:22 <acowley> well you can unsafePerformIO all your IO operations and just put ReaderT over Identity, but that seems perverse
14:55:18 <seliopou> Does the NOINLINE pragma affect any other optimizations besides inlining?
14:55:35 <seliopou> like common subexpression elimination, for example?
14:58:32 <acowley> seliopou: I don't think so
15:02:09 <seliopou> acowley: the reason I ask is because the documentation for INLINE alludes to the idea of "too much work", so I thought perhaps INLINE meant "assume this does no work" and NOINLINE meant "assume this does so much work"
15:02:17 <seliopou> and whatever that metric was was reused by the compiler
15:03:18 <acowley> seliopou: That is referring to the heuristic used by the inliner to decide what to inline. So the NOINLINE should just make the inliner refuse to inline the expression, but shouldn't affect other steps.
15:04:47 <seliopou> ok gotcha
15:04:48 <seliopou> thanks
15:05:13 <seliopou>  back to the drawing board
15:06:21 <acowley> seliopou: Do you have some code that's not behaving that way?
15:16:25 <shafire> Is there any easy way to call ada functions from haskell?
15:18:12 <c_wraith> shafire: I highly doubt it
15:19:05 <shafire> any idea, how I could get it done?
15:19:29 <Peaker> shafire, usually to FFI to some random language, you use the "lingua franca" as an intermediate bridge: C
15:20:01 <Peaker> shafire, Haskell has C FFI (which is considered good, at least until non-trivial C types are involved), Ada likely has C FFI too, you can go via C
15:20:02 <c_wraith> yep.  Export a way for C to call the function, use the FFI to call the C version
15:20:10 <napping> is there a null/isEmpty for Builder?
15:21:11 <shafire> okay thank you!
15:21:49 <Peaker> napping, sounds like you need to translate to ByteString and check that
15:22:07 <Peaker> napping, it might defeat the point, though if it's a lazy byte string (and you can select a chunk size = 1) it might not be too bad
15:24:42 <napping> seems plausible, looking at the internals it doesn't seem like you can get away too much cheaper anyway
15:25:20 <napping> have to actually allocate a buffer and run IO stuff to get any information out anyway
15:26:16 <napping> with any luck inlining and specialization and stuff might even avoid setting up a thunk that knows how to populate the tail
15:26:35 <Peaker> napping, you mainly compose the builder as a monoid, right?
15:27:26 <napping> yeah
15:27:50 <Peaker> napping, you could perhaps wrap the Builder with pairs: (Monoid.All, Builder)  where the All denotes whether it is empty, such that you compose the pairs rather than the builders, and that might be better or much worse :)
15:28:06 <napping> I'm trying to see how to expose some pretty-printing stuff in haxr, which uses a tiny little pretty-printing library based on Builder
15:28:17 <napping> wrapping it instead with a Maybe for empty or not
15:28:43 <Peaker> napping, cool, the Monoid for Maybe is the right one. That's nicer than mine :)
15:29:13 <Peaker> napping, though a tuple might be better for laziness -- i.e: GHC might see that only one part of the tuple is used in some computations and not compute it
15:29:39 <napping> I don't see how
15:30:04 <napping> I think that would always go in the direction of not using the builder if it's empty
15:30:18 <napping> and an always-nonempty one should pick up SpecConstr
15:30:20 <Peaker> snd $ someInlinedBuilderPair ...
15:30:48 <napping> I'm looking at a use in haxr, it wants to do stuff like defining <+> so it puts a space between non-empty strings but has a unit
15:31:34 <Peaker> napping, with enough inlining, if <+> is not used anywhere in a program, the tuple can be compiled away, I think
15:31:46 <Peaker> though a Maybe probably can't, but I'm not sure about that
15:31:54 <napping> it should
15:32:08 <napping> case/constr etc
15:32:15 <napping> <+> is certainly used
15:32:37 <napping> but if you inline an always-nonempty argument you'll reduce the case and stuff
15:32:53 <Peaker> Nothing must get special treatment, so the Maybe can be compiled away into code that dispatches on whether builder is empty, in addition to the empty-support (and checks) that's already in builder
15:33:16 <Peaker> so that might be very slightly wasteful
15:33:31 <napping> it's just ordinary pattern matching
15:34:20 <Peaker> napping, eventual use of the Maybe will pattern match on the Maybe and only when it is statically known it's a Just (non-empty) it can be compiled away.  Whereas with a pair, if emptiness isn't checked, it can be compiled away
15:34:37 <napping> I suppose you can save the heap allocation either way
15:34:41 <c_wraith> does GHC ever statically remove a pattern match?
15:34:46 <napping> at least as long as it's statically known to be a pair
15:34:46 <Peaker> but I think this is probably not going to have a significant effect anyway
15:35:12 <Peaker> c_wraith, sure:  case foo of Nothing -> case foo of Nothing -> 1   is going to be compiled into a single case, I'm pretty sure
15:35:35 <napping> probably, but either way gives you a change to actually statically optimize stuff, unlike an isEmpty test based on actually running builders
15:36:11 <Peaker> running a 1-byte chunk builder might be cheap though
15:36:13 <c_wraith> Peaker: hmm.  Ok, that's a case (no pun intended) I hadn't considered.  But does it optimize something like case Nothing of Nothing -> 1 ; Just _ -> 2 ?
15:36:23 <Peaker> c_wraith, pretty sure it does
15:36:41 <c_wraith> I guess I could use ghc-core to test these things, instead of asking
15:36:51 <napping> I think the most recent paper covering that stuff was the one on constructor specialization
15:36:59 <Peaker> sounds like a pretty simple optimization to implement
15:39:24 <c_wraith> I suppose it's heavily reliant on inlining, though
15:39:38 <c_wraith> Like most of GHC's optimizations.
15:39:44 <napping> of course
15:39:49 <napping> can't optimize anything without inling
15:40:14 <napping> kinda unfortunate if you actually want to be able to replace shared libraries
15:41:22 <Peaker> if something kept track about what was inlined where, and also kept naive non-inlined versions of functions, you could do that, and JIT a new inlining later maybe too
15:41:30 <Peaker> I guess what I'm describing is a standard JIT VM
15:41:52 <napping> yeah, or at least track how far things got inlined when you were compiling
15:42:21 <napping> so you know what downstream actually needs to rebuild
15:54:19 <augur_> is there a good intro to ML? ive heard interesting things about how it differs from haskell, so im curious to learn a bit more than just the sketchy handful of "facts" i know about it
16:00:37 <levi> augur_: Robert Harper has a free book on Standard ML, and there are several free books on Objective Caml available.
16:01:02 <josephle> yay, ML!
16:01:13 <augur_> levi: ill give harper's book a look.
16:01:17 <josephle> always a fun time with the module system (oh how I wish ML had typeclasses)
16:01:46 <levi> Yeah, the Standard ML module system is pretty sophisticated.
16:01:49 <sellout> josephle: Indeed. I miss ML’s functors.
16:02:27 <josephle> whenever SML gets a successor (hah.), somebody needs to gut the equality types system and put in a real typeclass system
16:03:13 <levi> Nothing much seems to be happening in SML-land lately, though it may still be used for teaching and research.
16:04:39 <levi> Although there seems to be recent github activity at MultiMLton's repository.
16:06:44 <levi> It's got an interesting multi-core concurrency story.
16:17:10 <zebr> [chalk:~]% wget -qO- www.haskell.org/hoogle/ | file -
16:17:10 <zebr> /dev/stdin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.8, not stripped
16:17:19 <zebr> is it just me or is there something very wrong with hoogle?
16:17:39 <johnw> zebr: see the topic
16:17:52 <zebr> ah, ok
16:21:52 * hackagebot dbmigrations 0.7 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.7 (JonathanDaugherty)
16:46:32 <chrisdotcode> hi everyone :)
16:46:56 <DiegoNolan> what's up with hoogle?
16:47:05 <geekosaur> see /topic
16:47:29 <hpc> hoogle 2.0 is a revolutionary design based on the feedback of its users :P
16:47:43 <chrisdotcode> geekosaur: would you, by any chance, know how to get lambdabot working inside of ghci?
16:48:17 <Moggle_> @hoogle [(a, b)] -> ([a], [b])
16:48:18 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
16:48:18 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
16:48:44 <geekosaur> nope, sorry
16:48:51 <chrisdotcode> heh. well thanks anyway.
16:49:07 <shachaf> My advice: Don't try to get lambdabot working inside of ghci.
16:49:07 <chrisdotcode> I'm assuming it's possible, because the wiki page says it can be, but I see no documentation for that
16:49:11 <geekosaur> some point I may try it again (the one time I did try it was one of the long periods when LB didn't really build for anyone, IIRC)
16:49:28 <elbee> hi
16:49:32 <chrisdotcode> shachaf: I just really want the @src annotations, @undo, and other cool stuff during a repl session
16:49:47 <geekosaur> I am also not sure anyone has actually tested goa in the past 5 years :/
16:50:00 <c_wraith> yeah, ghci has changed a lot since goa was written
16:50:30 <chrisdotcode> what's goa?
16:50:37 <chrisdotcode> the plugin system that lambdabot used, I'm guessing?
16:50:42 <geekosaur> @hackage goa
16:50:42 <lambdabot> http://hackage.haskell.org/package/goa
16:51:00 <geekosaur> "ghci on acid", the glue to hook LB into ghci
16:51:34 <chrisdotcode> well it says chrisdone uploaded it recently... so either it was down, or there's an actual update...
16:52:06 <Thra11> chrisdotcode: FWIW, I have lambdabot working in my ghci. I just built it with cabal and then defined a command in ghci.conf
16:52:07 * hackagebot mongodb-queue 0.2.3.1 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.3.1 (GregWeber)
16:52:21 <geekosaur> hm, interesting. try it?
16:52:35 <chrisdotcode> Thra11: well I have lambdabot installed already, but what's the command in your conf file?
16:52:41 <chrisdotcode> also, how well does it work?
16:53:13 <tswett> Ahoy. So I'm trying to use Haskell to implement a toy programming language. I think I pronounced the incantation wrong and now I've summoned an angry demon who's giving me "ambiguous type variable" errors.
16:53:27 <tswett> That's what I get for dabbling in black magic such as UndecidableInstances, I guess.
16:53:30 <tswett> In any case, let me paste my code.
16:53:32 <Thra11> chrisdotcode: seems to work ok. haven't tested everything. line in ghci.conf is :def lb \str -> return $ ":! ~/.cabal/bin/lambdabot -l CRITICAL -e \"" ++ str ++ "\""
16:53:54 <dmwit> Couldn't focus, read "baste my code".
16:53:59 <dmwit> Didn't think it would help much.
16:54:17 <lpaste> tswett pasted “Linear demons” at http://lpaste.net/90943
16:54:23 <Thra11> chrisdotcode: (I have it suppress errors less than critical because otherwise it complains about a broken plugin every time I use it)
16:55:35 <chrisdotcode> Thra11: I downloaded lambdabot from the repos, and not built with cabal, can I use /usr/bin/lambdabot in place of the cabal bin?
16:55:56 <Thra11> chrisdotcode: yes
16:56:07 <chrisdotcode> sweet, thanks :D trying now
16:56:08 <dmwit> tswett: uh
16:56:13 <dmwit> This is a very unusual way to do this.
16:56:29 <geekosaur> tswett, those types all look rather suspect to ,e
16:56:30 <dmwit> Isn't it much more normal to just make compile :: Expr e -> e, and then, like
16:56:32 <tswett> dmwit: I should probably do it the usual way, then. :D What would that be?
16:56:42 <dmwit> Apply :: Expr (a -> b) -> Expr a -> Expr b
16:56:46 <geekosaur> (amd I expect the compiler error is the compiler agreeing with me)
16:57:07 * hackagebot clckwrks 0.18.0 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.18.0 (JeremyShaw)
16:57:16 <tswett> dmwit: hmmm. Yeah, that actually sounds like it would make a lot of sense.
16:57:43 <tswett> Yeah, lemme do that. Thanks.
16:58:07 <dmwit> I mean, independently we can try to understand why this error occurs.
16:58:27 <dmwit> I think it's because the type of "x" in "compile x" on line 50 isn't specific enough.
16:59:01 <tswett> Can't we infer x :: Expr One?
16:59:16 <dmwit> no?
16:59:37 <dmwit> We know x :: Expr c for some c, but nothing more.
16:59:39 <tswett> Er.
16:59:41 <tswett> Right, exactly that.
17:00:11 <dmwit> ...and we would need to know Compile c d for some d to be able to call compile there.
17:00:16 <dmwit> Which we don't know.
17:00:45 <tswett> So, essentially, we don't know that x is of a type that compile can be applied to.
17:00:46 <shachaf> You can trust dmwit on this. He's an Exprt.
17:00:53 <dmwit> exactly
17:01:02 <tswett> Yeah, that actually makes perfect sense.
17:01:03 <geekosaur> as long as he's not an ex-pert
17:01:19 <tswett> All right, thanks. :)
17:01:44 <dmwit> shachaf: ...oh, I get it. =D
17:02:01 <geekosaur> ExprT
17:02:07 * hackagebot clckwrks 0.18.1 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.18.1 (JeremyShaw)
17:02:09 * hackagebot clckwrks-plugin-page 0.2.0 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.0 (JeremyShaw)
17:02:11 * hackagebot clckwrks-plugin-media 0.5.0 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.5.0 (JeremyShaw)
17:03:40 <dmwit> Huh, did GHC grow the ability to derive class instances for GADTs?
17:03:41 <dmwit> neat!
17:04:50 <hpc> GHC actually budded a smaller ghc off of it
17:04:57 <tswett> Woohoo, my regex replacement almost did what I wanted it to: :s/Lolly \(.\|(.*)\) \(.\|(.*)\)/\1 :-> \2/g
17:04:58 <hpc> then ghc ate GHC and absorbed its powers
17:05:11 <chrisdotcode> Thra11: okay, it doesn't seem to be working for me...
17:06:02 <tswett> -> is infixr 5, right?
17:06:41 <dmwit> -> isn't an operator...
17:06:41 <geekosaur> -> is syntax, don't think precedence applies as such
17:07:04 <tswett> Uh, right. I meant the type constructor, but those don't have fixities either.
17:07:07 * hackagebot clckwrks-plugin-bugs 0.6.0 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.0 (JeremyShaw)
17:07:09 <tswett> At least not in vanilla Haskell.
17:07:09 * hackagebot clckwrks-plugin-ircbot 0.6.0 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.0 (JeremyShaw)
17:07:39 <acowley> Uhm, what the heck is this: "warning: trigraph ignored [-Wtrigraphs]"
17:08:12 <geekosaur> you have -XCPP and a sequence ??x for some x
17:08:40 <acowley> ah!
17:08:57 <acowley> Huh, I don't have CPP in that particular module
17:08:59 <shachaf> Hmm, the Report says that «case x of { (a,_) | let b = not a in b :: Bool -> a }» is valid?
17:08:59 <geekosaur> ...this may be a good time to switch to cpphs
17:09:35 <geekosaur> pretty sure ghc doesn't do trigraphs, they're an ANSI C abomination
17:09:53 <Thra11> chrisdotcode: does lambdabot work if you run it from outside ghci?
17:09:59 <acowley> I use cpphs when I mean to use CPP, but I'm not using CPP here.
17:10:07 <scshunt> trigraphs are indeed an abomination
17:10:16 <acowley> geekosaur: In any case, thanks for explaining that. I did indeed have a string that has ??! in it
17:10:34 <scshunt> shachaf: why wouldn't it be?
17:11:22 <shachaf> scshunt: Well, GHC rejects it.
17:11:31 <shachaf> The Report specifies that parsers might reject it.
17:11:43 <scshunt> where?
17:12:08 * hackagebot clckwrks-theme-bootstrap 0.2.11 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.11 (JeremyShaw)
17:12:48 <shachaf> Section 3.
17:13:16 <scshunt> where?
17:13:29 * tabemann is thinking of just where to go with it now that he's doing a "Lunch and Learn" at his workplace on Haskell
17:13:43 <chrisdotcode> Thra11: yeah, she does; I'm trying to run her with a command now.
17:13:47 <c_wraith> ...  Welp.  I can, in fact, construct a custom Setup.hs that will vary how a package builds depending on the presence of a particular native library in the search path GHC uses.
17:14:04 <c_wraith> I'm terrified by this
17:14:06 <shachaf> scshunt: I already closed the page. They give the exact expression I just copied here.
17:14:40 <dmwit> shachaf: That's a subtle edge case.
17:14:42 <chrisdotcode> Thra11: "/usr/bin/lambdabot  -e "@src any" works, but it doesn't work with -l
17:14:45 <dmwit> I wonder how they found it.
17:15:00 * tabemann is thinking of focusing on purity and laziness as there are so many different things he could spend an hour talking about Haskell on, and those are the things that really differentiate it from, say, OCaml or SML (aside from type classes)
17:15:02 <scshunt> dmwit: probably someone tried to do it
17:15:04 <dmwit> "stick it in bison and see where it complains"
17:15:06 <dmwit> right
17:15:06 <scshunt> shachaf: you should clearly file a ghc bug
17:15:13 <chrisdotcode> Thra11: my version is 4.2.3.2
17:16:09 <geekosaur> some of those are tests from when they realized that the old brace insertion rule of the haskell98 report was impossible
17:16:24 <Thra11> chrisdotcode: 4.3 here. Try removing the "-l CRITICAL" bit for now
17:16:38 <chrisdotcode> Thra11: okay, I'll try that now.
17:16:51 <geekosaur> (IIRC someone found a specific case where different compilers could, completely legally, interpret a particular expression in two different ways)
17:17:13 <elliott> shachaf: where is the ambiguity?
17:17:16 <elliott> in that experssion
17:17:20 <shachaf> elliott: There's no ambiguity.
17:17:25 <elliott> right
17:18:24 <dmwit> There's no ambiguity. You just have to look ahead -- perhaps a lot, it's not obvious to me -- to disambiguate.
17:18:46 <elliott> well, I mean, what else could it be?
17:18:50 <elliott> as in what could it change half-way to become
17:19:03 <dmwit> ...in b :: Bool -> a -> 3
17:19:14 <elliott> ohh.
17:19:19 * tabemann is curious as to how a non-ambiguity could be legally interpreted differently by different Haskell compilers
17:19:21 <elliott> great.
17:19:42 <dmwit> tabemann: This is not the example of something that can be interpreted differently by different compilers.
17:19:59 <chrisdotcode> Thra11: okay, so ":lb @src any" works, but I still get "Exception: all servers detached"; I;m guessing that's because "-l CRITICAL" isn't working.
17:20:02 <geekosaur> tabemann, this isn't the example I was talking about
17:20:27 <geekosaur> I don't recall the example now and was unable to find the list message last time I looked
17:21:20 <geekosaur> possibly lambdabot should suppress that exception when the only "server" is the command line or other local session
17:24:00 <Thra11> On the subject of lambdabot, is there a quick fix for: "Plugin `source' failed with: state not initialized"? or is it just broken?
17:24:26 <chirpsalot> Ummmm. Is hoogle broken? http://www.haskell.org/hoogle/ just starts a 28mb download for me now, which has me confused.
17:24:45 <dmwit> Thra11: Put the source state in the right place.
17:25:04 <dmwit> I don't remember where it comes from or where it goes, except that it starts somewhere in ~/.cabal and ends somewhere in ~/.lambdabot.
17:25:04 <tabemann> chirpsalot: same here
17:25:07 <dmwit> Good luck.
17:25:15 <hpc> chirpsalot: we have improved hoogle based on feedback from our users
17:25:15 <geekosaur> chirpsalot, see /topic
17:25:18 <hpc> chirpsalot: (see topic)
17:25:24 <Thra11> dmwit: ok, thanks
17:26:35 <chirpsalot> hpc: geekosaur oh butts, sorry. Was looking at the topic for 'hoogle' so I missed it. Thanks.
17:27:53 <Vendethiel> where can you report "learn you a haskell" typos?
17:28:48 <tswett> Vendethiel: email the author, I guess. bonus@learnyouahaskell.com
17:28:58 <Vendethiel> oke ty
17:28:58 <tabemann> the title isn't a typo, though
17:29:18 <Vendethiel> i know that haha
17:30:37 <tswett> Now I just need to come up with a function of type ((a -> Bottom) -> Bottom) -> a, where Bottom is a void type. Uhh... guess I'll need to switch to CPS.
17:30:39 <Thra11> dmwit: cp ~/.cabal/share/lambdabot-4.3/State/* ~/.lambdabot/State/ seems to have done the trick. thanks
17:32:08 * hackagebot persistent-mongoDB 1.2.1.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.2.1.2 (GregWeber)
17:38:55 <chrisdotcode> does cabal have transactions?
17:39:20 <chrisdotcode> * transactional installs?
17:47:54 <lpvb> looking at the state of haskell platform, I assume everyone here uses macs?
17:47:58 <lpvb> or windows
17:48:05 <scshunt> can we topic that?
17:48:06 <dibblego> No.
17:48:13 <shachaf> Cale, dolio: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=83
17:50:06 <amyers> lpvb: Why?
17:50:28 <lpvb> amyers: all the linux pages on haskell platform's website is out of date
17:50:36 <lpvb> you have to basically compile it yourself
17:51:05 <amyers> lpvb: Ah, I think it's more that all the Linux folks use their distro packages or straight cabal
17:51:05 <elliott> that's more to do with distros than the platform.
17:51:05 <Cale> shachaf: aha, I thought it might be parametricity that was missing
17:51:45 <amyers> lpvb: Platform always causes me deep suffering so I use cabal, for instance :p
17:51:45 <Cale> I should look at the details of this once I'm more awake
17:52:10 <lpvb> amyers: so what do you do? install ghc and cabal only?
17:52:27 <amyers> lpvb: I install ghc and cabal vis my package manage
17:52:33 <amyers> *manager.
17:52:44 <amyers> lpvb: The immediately cabal update && cabal install cabal-install
17:53:24 <monochrom> I build Haskell Platform (except GHC itself) from source. what's outdated about it?
17:53:31 <amyers> I don't know if that's the best worflow but it works for me
17:53:54 <hpc> i download the latest ghc binary, compile cabal, compile cabal-dev, then go to town
17:54:10 <monochrom> linux distros do not always catch up with Haskell Platform releases.
18:02:14 <tswett> Okay, I came up with a function of type ((a -> Void) -> Void) -> a. It's pretty horrible, though:
18:02:19 <tswett> \f -> unsafePerformIO $ do var <- newEmptyMVar; (try :: IO a -> IO (Either BlockedIndefinitelyOnMVar a)) (evaluate (f (\x -> seq (unsafePerformIO (putMVar var x)) (throw BlockedIndefinitelyOnMVar)))); takeMVar var
18:02:26 <acowley> amyers: I do the mac version of that.
18:03:08 <hpc> :t fix const
18:03:09 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = b0 -> a0
18:03:09 <lambdabot>     Expected type: a0 -> a0
18:03:09 <lambdabot>       Actual type: a0 -> b0 -> a0
18:04:24 <c_wraith> :t fix . const
18:04:25 <lambdabot> c -> c
18:05:09 <c_wraith> hey, parametricity works!  It's the same function as all other total functions with that type!
18:07:07 <shachaf> :t fix id `asTypeOf` id
18:07:08 <lambdabot> a -> a
18:07:13 <shachaf> Hooray for parametricity!
18:10:55 <c_wraith> fix id is a little less total
18:12:19 <tswett> Hm. (a -> a) -> a -> a is satisfied by infinitely many total functions. (a -> a -> a) -> a -> a is also satisfied by infinitely many total functions.
18:12:33 <tswett> But the latter type seems to have a different quality than the former type.
18:12:45 <tswett> Like they ought to have different polynomials, or different topological spaces, or something.
18:16:29 <zRecursive> :t fix
18:16:30 <lambdabot> (a -> a) -> a
18:27:14 * hackagebot persistent-mongoDB 1.2.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.2.2 (GregWeber)
18:27:33 <roconnor> Twey: (a -> a) -> a -> a is the church encoding of natural numbers
18:27:34 <roconnor> er
18:27:39 <roconnor> tswett: : (a -> a) -> a -> a is the church encoding of natural numbers
18:27:46 <tswett> Yeah, I know that.
18:27:51 <roconnor> tswett: (a -> a -> a) -> a -> a is the church encoding of a list of bits.
18:27:53 <tswett> And then (a -> a -> a) -> a -> a encodes a tree, right?
18:28:08 <roconnor> er
18:28:10 <roconnor> right a tree
18:30:59 <b6> is there an attoparsec combinator for 0 or 1 occurrences? optional. i can do string "," <|> string "", but is there nothing better?
18:46:30 <roboguy_> b6: I'm not sure, but it looks like you could make one: optional = option ""
18:48:24 <b6> roboguy_: oh, i think you're right. i must be tired. thanks for spotting that.
18:50:12 <scshunt> is there a way to tell cabal to build only one module?
18:50:15 <lpaste> tswett pasted “Isn't this what Cont is for?” at http://lpaste.net/90944
18:50:21 <tswett> Hi scshunt.
18:50:42 <scshunt> hi
18:51:11 <tswett> All right, so I'm trying to define "compile Cancel". Now, Cancel has the type Expr (((a -> Bottom) -> Bottom) -> a) (where "Bottom" has nothing to do with the concept of _|_ in Haskell).
18:51:53 <tswett> What I want to do, of course, is return something of type ((a -> Bottom) -> Bottom) -> a. But this type doesn't really make sense in Haskell.
18:52:10 <elliott> such a function is non-constructive, of course
18:52:16 <scshunt> tswett: why not?
18:52:55 <tswett> scshunt: well, the function I want to define can only be defined in Haskell using unsafePerformIO and exception handling.
18:53:09 <tswett> So I feel like the next best thing is to return something of type M (((a -> Bottom) -> Bottom) -> a), where M is some appropriate monad.
18:53:33 <scshunt> like, say, Maybe?
18:54:08 <tswett> Or perhaps not a monad but some other family of type constructor.
18:54:56 <tswett> scshunt: mmm no. I ought to be able to turn an "M a" into an "a", as long as "a" doesn't contain Bottom, and have the result behave correctly.
18:55:44 <tswett> My first instinct was to use a continuation monad, and return something of type Cont bot (((a -> bot) -> bot) -> a).
18:55:59 <elliott> yes, Cont lets you encode classical type stuff
18:56:05 <elliott> pierce's law corresponds to call/cc
18:56:07 <shachaf> tswett: http://okmij.org/ftp/Computation/lem.html
18:56:09 <tswett> But ((((a -> bot) -> bot) -> a) -> bot) -> bot (what a mouthful) isn't populated.
18:56:21 <shachaf> Oleg points out that you can define "forall a. (forall m. Monad m => ((a -> m F) -> m F)) -> a"
18:56:43 <shachaf> @djinn ((((a -> Void) -> Void) -> a) -> Void) -> Void
18:56:43 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
18:56:49 <shachaf> thanks djinn
18:57:31 <tswett> Hmm. That's pretty close to what I'm after.
18:59:10 <shachaf> And you don't need a fancy monad for that, either. Just exceptions.
18:59:34 <elliott> but you might want continuations if doing linear logic stuff anyway.
19:00:33 <tswett> Yeah. I feel like a "Cont bot (((a -> bot) -> bot) -> a)" *ought* to exist.
19:01:07 <shachaf> @djinn-add type Contt r a = (a -> r) -> r
19:01:27 <shachaf> @djinn Contt Void (((a -> Void) -> Void) -> a)
19:01:28 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
19:01:34 <shachaf> This is exactly the same type as before, of course.
19:02:15 * hackagebot xml-lens 0.1.3 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.3 (FumiakiKinoshita)
19:02:18 <tswett> Right. Of course, a Cont Void (anything) is kind of a useless thing to have, isn't it?
19:02:40 <shachaf> Useless for whom?
19:02:54 <shachaf> All proofs are useless because you cannot eat them.
19:02:57 <tswett> For someone living inside the Haskell program.
19:03:06 <Rarrikins> As a raptor, I agree.
19:03:28 <tswett> The only thing the Haskell program denizen can do with it is pass something of type (<whatever> -> Void) in it, and he's not going to be able to come up with such a thing.
19:03:43 <elliott> it might be able to, if it gets passed one.
19:04:11 <elliott> of course you cannot prove anything false in the *global* context, modulo _|_, but you can use disproofs to discharge the obligation to write code when given impossible information
19:04:43 <tswett> I guess the capability this function needs is the ability to eat the entire continuation. The semantics, really, are that f (cancel g) = g f, whenever "f (cancel g)" is the entire computation.
19:04:57 <tswett> elliott: yeah, but I'd be just as happy writing 'error "unreachable"'.
19:07:14 <roboguy_> hmm, "The lambda expression ... has two arguments but it's type ... has only two"
19:07:15 * hackagebot llvm-general 3.2.4.4 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.4.4 (BenjaminScarlet)
19:07:17 * hackagebot llvm-general 3.3.4.4 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.4.4 (BenjaminScarlet)
19:07:41 <tswett> I think this might actually be what I'm after: cancel g = callCC (error "unreachable" . g)
19:08:14 <tswett> This will work fine because g is guaranteed to actually use the continuation, and thus won't return... I feel like I'm making a mistake.
19:08:51 <elliott> roboguy_: iirc fixed bug
19:09:03 <roboguy_> elliott: in which version?
19:09:10 <roboguy_> (is it fixed in)
19:09:18 <elliott> probably 7.8 (not released)
19:09:22 <elliott> failing that, one newer than the one you have
19:10:04 <roboguy_> elliott: ah ok, that's good. it's not really causing a problem, I just thought that was an interesting error message
19:10:23 <roboguy_> thought I'd bring it up just in case I managed to find a new bug
19:10:55 <shachaf> The apostrophe there looks like a bug too, unless that came from typing and not copying.
19:11:04 <roboguy_> shachaf: yeah I didn't copy it
19:17:15 * hackagebot dual-tree 0.1.0.3 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.1.0.3 (BrentYorgey)
19:19:06 <shachaf> byorgey: That's a lot of newtypes.
19:19:08 <elliott> hi cmccann
19:19:19 <cmccann> hi elliott
19:19:21 <shachaf> Hmm, odd tree.
19:19:27 <byorgey> shachaf: newtypes?
19:19:30 <chirpsalot> :| I feel like I have to use fromIntegral so much when I need to use lists to calculate arbitrary position integers (for example, multiplying the first n integers in a list). I am doing something wrong, aren't I?
19:20:13 <shachaf> byorgey: In the tree definition.
19:21:23 <byorgey> shachaf: ah, indeed
19:41:35 <bb010g> Anyone know why the Haskell wiki's pictures are broken?
19:42:12 * geekosaur points to /topic
19:42:18 <carter> bb010g because they're in the middle of a several day migration
19:42:20 <geekosaur> there's considerable disruption at the moment
19:49:55 <ab9rf> what are they migrating from and to?
19:50:11 <shachaf> A server; a server.
19:52:15 * hackagebot mongodb-queue 0.2.4 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.4 (GregWeber)
19:55:17 <bb010g> @src Functor (,)
19:55:17 <lambdabot> Source not found. Where did you learn to type?
19:55:31 <bb010g> Is there any way to get lambdabot to import more things?
19:55:46 <shachaf> It won't help with @src.
19:55:55 <shachaf> Because @src is just a handwritten ad-hoc text file.
19:56:02 <shachaf> @src (,) fmap -- the secret
19:56:03 <lambdabot> Source not found. Take a stress pill and think things over.
19:56:05 <shachaf> @src (,) fmap
19:56:05 <lambdabot> fmap f (x,y) = (x, f y)
19:56:43 <tswett> @src readLine
19:56:44 <lambdabot> Source not found. Maybe you made a typo?
19:56:53 <tswett> @src Maybe
19:56:53 <lambdabot> data Maybe a = Nothing | Just a
19:56:59 <tswett> @src Just
19:56:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:57:02 <shachaf> Also, you can /msg lambdabot.
19:57:05 <bb010g> It makes sense to me to pull from the GHC source.
19:57:08 <tswett> ^_^
19:57:16 * hackagebot xmonad-contrib 0.11.2 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.11.2 (AdamVogt)
19:57:18 <augur_> better to use hoogle, bb010g
19:57:27 <travisb> except hoogle's down last time we checked
19:57:30 <shachaf> Then do it!
19:57:32 <augur_> wat
19:57:48 <augur_> thats a tragedy
19:57:50 <augur_> a disaster
19:57:52 <travisb> augur_: it spits out a 28 MB file at you
19:57:53 <augur_> a catastrophe
19:58:00 <lemongrabber> Why has Hoogle been down for like, a day?
19:58:01 <travisb> it's because of the haskell.org move
19:58:41 <c_wraith> Many people move services without downtime. >_>
19:58:56 <bb010g> Looks like the wiki just went down.
19:59:46 <tabemann> (stupid IRC client can't remember different nicks for different nets across reconnects...)
20:00:27 <geekosaur> many people have professional hosting
20:03:59 <tabemann> at least there's http://holumbus.fh-wedel.de/hayoo/hayoo.html , and Hackage, which that points at, still seems to work
20:08:01 <joelteon> is there any version of hlint that supports lambda case?
20:11:23 <zRecursive> @where hlint
20:11:23 <lambdabot> http://community.haskell.org/~ndm/hlint/
20:12:37 <bb010g> You might want to put up a note about archive.gov for access to the wiki and other things.
20:13:11 <carter> bb010g people are pretty good at explaining it to anyone who asks :)
20:17:24 <bb010g> Wiki's back up.
20:18:53 <tlevine> I want to use QuickCheck through cabal. Is there a good boilerplate or something for this? (For context, it's for this: https://github.com/tlevine/battleship)
20:36:35 <bb010g> Is there a way to view the code generated by deriving?
20:37:53 <shachaf> Yes, there's a GHC option.
20:38:07 <enthropy> bb010g: the flag is something like -ddump-deriv
20:38:52 <bb010g> No way from GHCi?
20:39:28 --- mode: ChanServ set -o shachaf
20:39:30 <enthropy> ghci will accept that flag too
20:41:32 <lpaste> enthropy pasted “see bb010g?” at http://lpaste.net/90947
20:42:34 <bb010g> Cool! Thanks.
20:46:26 <whaletechno> 0
20:49:48 <NemesisD> so is it not possible to define update queries on acid state that take arbitrary update operations?
20:52:04 <haasn> well, you have to be able to serialize the update
20:55:03 <c_wraith> Though that makes me wonder if you could use observable sharing and a free monad approach to create an update language that allows serialization of arbitrary logic.
20:55:36 <c_wraith> I guess not.  You still can apply arbitrary pure functions which can't be serialized.
21:13:46 <NemesisD> are mtl and transformers mutually exclusive
21:14:42 <tabemann> NemesisD: umm... isn't mtl a library of monad transformers?
21:14:57 * tabemann takes that back for a sec
21:14:58 <ParahSail1n> two different libraries
21:15:02 <shachaf> NemesisD: No.
21:15:10 <shachaf> @hackage mtl -- see dependencies list
21:15:10 <lambdabot> http://hackage.haskell.org/package/mtl -- see dependencies list
21:15:46 <yan_> are there types that let me lazily compose function-like values (i'm doing this in scala but figure #haskell can help me with the fundamentals).. i.e. i have a type "Maybe b => Pass a b", (a pass maps from a to Maybe b), and i'd like to be able to compose two types, such that i get Pass a b <cmp> Pass b c will produce a 'Pass a c'. This feels very monadic, but all examples of bind i've seen are parameterized on one parameter, not two. I'd like to be able to define
21:16:00 <yan_> is there a metaphor that i'm not aware of?
21:16:27 <shachaf> yan_: Category?
21:16:35 <shachaf> @src Category
21:16:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:16:47 <shachaf> class Category k where id :: k a a; (.) :: k b c -> k a b -> k a c
21:17:16 <shachaf> (Or, if you don't have id, Semigroupoid is the same thing without id. But that's not in base.)
21:17:54 <yan_> shachaf: (firstly, hello again), secondly this seems what i'm looking for.. and scalaz has a typeclass for it
21:18:04 <shachaf> Hi!
21:18:12 <shachaf> Oh, right, Scala.
21:19:05 <shachaf> Yes, scalaz has Category, which is probably exactly what you want if you have identity.
21:19:47 <shachaf> (As long as your thing obeys the usual laws: (a . b) . c = a . (b . c), a . id = id . a = a .)
21:20:00 <yan_> shachaf: yeah, i'm trying to transform various subclasses of what i term Target, so essentially a pass is Pass[-A <: Target, +B <: Target]
21:20:06 <yan_> shachaf: (not sure if you're familiar with scala)
21:20:33 <shachaf> Nope, not familiar.
21:20:43 <shachaf> I guess - and + are contravariance/covariance notation?
21:20:45 <tabemann> Phttp://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html > "You might think that this is some exotic idea without practical relevance, brought into the Scala community by some vocal Haskell fanatics. This is clearly not the case." << since when should one think that type classes are merely something for "vocal Haskell fanatics", as if Haskell users must be "fanatics" to have good i
21:20:46 <tabemann> deas
21:20:48 <yan_> shachaf: exactly
21:21:28 <yan_> shachaf: '-A <: Target' = contravariant type A that is some subclass of Target
21:23:54 * shachaf should get a proper understanding of subtyping one of these days.
21:27:16 * tabemann for some reason doesn't like the idea of generalized subtyping, vis-a-vis, algebraic data types
21:27:46 <tabemann> drop that second comma
21:28:28 <tabemann> of course, then, I don't really like inheritance in the first place
21:28:43 <c_wraith> how about purely structural subtyping?
21:28:53 <c_wraith> I can appreciate the value of that.
21:30:03 <tabemann> that I'm okay with
21:31:04 <tabemann> it's really inheritance from implementation classes that bothers me
21:31:30 <scshunt> drop both commas
21:31:43 <c_wraith> in my experience, the liskov substitution principle really doesn't work in practice.
21:32:55 <c_wraith> (and in contrast, Liskov thinks using monads as an abstraction is overkill)
21:34:01 <tabemann> to me inheriting from classes that can be instantiated breaks modularity easily, and can generally be replaced by wrapping objects or passing in outside objects to be called by an object)
21:36:04 <c_wraith> that matches what most people currently recommend as best practices in OO languages - prefer delegating to subclassing
21:36:24 <c_wraith> (which makes it unfortunate those languages make subclassing easy and delegating hard)
21:36:57 * tabemann works in Java, and wishes it would *only* allow inheriting from interfaces
21:37:37 <strager> I am debugging a BlockedIndefinitelyOnSTM exception.  I have a breakpoint on the exception in GHCi.  :hist shows a stack trace, but for what I think is the main thread.  How can I show a stack trace for all threads?
21:47:16 <inf-groupoid> tabemann: So, basically, a straightjacketed version of type classes that forces you to declare all instances for the same type in the same place? (And denies you higher kinds, and lots of other problems.)
21:51:42 <tabemann> what're you specifically referring to there?
21:53:23 <inf-groupoid> tabemann: If I make some new type class Quux, I can make an instance for an already existing type, say, Int, without changing the type's definition. If I want an already existing class to implement a new interface, I have to modify the class, recompile it, and recompile any code that uses that class.
21:54:40 <inf-groupoid> tabemann: Although I would agree that it is easier to use interface inheritance in a principled way. Class inheritance makes it too tempting to violate the Liskov substitution principle.
21:54:50 <tabemann> if you're thinking in a Java model, e.g., the proper way to do it is for Int to have already implemented an interface specifying everything one can do to an integer, and to implement that interface
21:55:36 <zRecursive> interface -> type class ?
21:55:57 <Xunie> Would you people recommend using greek letters in your function names?
21:56:05 <tabemann> zRecursive: their terminology was confusing me
21:56:10 <inf-groupoid> zRecursive: Mmm... What you can do with interfaces is a strict subset of what you can do with type classes. :-)
21:56:35 <Xunie> And if so: what is the easiest way to write them? Any editors with a 'virtual keyboard' out there so I can easily punch in 'phi' when I need it?
21:57:00 * tabemann considers using Unicode in code to be a bad idea, despite what the developers of Agda think
21:57:12 <inf-groupoid> Xunie: No. Greek letters are fine in type variables, especially in type class definitions.
21:57:41 <inf-groupoid> Xunie: But not in value-level entities, that would be too painful to code.
21:57:42 <lemongrabber> I use vim digraphs for greek -> they're great
21:57:50 <tabemann> the problem with Unicode in code is when you have to type it, and that you have to resort to all kinds of different, awkward input methods to deal with them
21:58:17 * tabemann doesn't know how people type in Agda, and yes, he knows there's special support in Emacs to help with it
21:58:28 <inf-groupoid> tabemann: Write all your code in Emacs' Agda-mode, then copy it back to a buffer containing a Haskell program! :-P
21:58:38 <tabemann> lol
21:59:47 * Xunie is now considering writing his own key-map.
22:00:22 * tabemann used to have his caps lock key mapped to /compose/, but he lost that configuration with the machine it was on
22:01:29 <tabemann> (of course, compose seems more designed to help typing in foreign languages than in Agda or Unicodified Haskell)
22:04:32 <tabemann> what would probably be better than using Unicode in your own code is having a converter that Unicodifies code for printing
22:05:25 <tabemann> so then you can type without worrying about having to enter Unicode characters and yet you can prettify your code if you really want to have lambdas instead of \ and Unicode arrows instead of -> and like
22:17:18 * hackagebot random-source 0.3.0.5 - Generic basis for random number generators  http://hackage.haskell.org/package/random-source-0.3.0.5 (JamesCook)
22:32:19 * hackagebot random-source 0.3.0.6 - Generic basis for random number generators  http://hackage.haskell.org/package/random-source-0.3.0.6 (JamesCook)
22:35:45 <pharaun> it feels really good to make the type system finally submit
22:38:07 <shachaf> That sounds backwards.
22:38:18 <shachaf> You should be the one who submits. That's what the type system is for.
22:48:54 <LLckfan> Does any1 know anything about GE dishwashers
22:49:50 --- mode: ChanServ set +o shachaf
22:50:14 --- mode: shachaf set +b *!*LLckfan@67.213.25.*
22:50:14 --- kick: LLckfan was kicked by shachaf (LLckfan)
22:50:50 --- mode: shachaf set -q+b $a:LLckfan $a:LLckfan
22:51:29 --- mode: shachaf set -b+b *!*LLckfan@67.213.25.* *!*LLckfan@*
22:51:31 --- mode: shachaf set -o shachaf
22:54:23 <pharaun> shachaf: haha yes its backward, i mainly wanted X to happen but Y wasn't allowing it so i bent the type system to allow it :p
23:11:13 <dmj> > do print "ok"; putStrLn "ok";
23:11:14 <lambdabot>   <IO ()>
23:12:07 <mr-> haskell.org seems to be back!
23:12:19 <dmj> yes :) a very good thing
23:12:39 <mr-> hoogle not so much
23:13:40 <dmj> going to hoogle prompted me to download a file
23:13:59 <lemongrabber> Yeah - been like that since yesterday
23:14:08 <dmj> maybe they're migrating?
23:14:18 <lemongrabber> I guess so
23:14:37 <lemongrabber> Anybody tried running the binary that hoogle gets you to download?
23:14:46 <shachaf> It's Hoogle.
23:14:54 <lemongrabber> I thought it might be
23:15:04 <lemongrabber> So, anybody hosting hoogle?
23:15:41 <irene-knapp> lol
23:15:47 <irene-knapp> it needs an external database
23:17:41 <applicative> lemongrabber: https://www.fpcomplete.com/hoogle
23:18:25 <lemongrabber> Oh, cool thanks!
23:23:01 <dmj> > do x <- [1..2]; y <- [1..2]; return (x,y)
23:23:02 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
23:27:56 <CaptainK> Can't figure why this works in GHCi but not compile: http://ideone.com/8BQadX
23:29:46 <Cale> CaptainK: because ghci automatically applies print to the expressions you type in order to put something on the screen
23:30:15 <Cale> (at least, when they're not IO actions -- in that case it also prints the result of the action after executing it)
23:30:16 <inf-groupoid> CaptainK: GHC expects main to be of type IO t, for whatever t.
23:30:53 <Cale> tuple2list ("me","you")  is a list, not an IO action. You could apply print to it to get an IO action to print the result to the terminal
23:30:53 <CaptainK> ok so I need to add a print in there to make it compile?
23:31:05 <Cale> yeah
23:31:38 <Cale> You can also, if you want, move the definition of tuple2list out of main
23:33:55 <Cale> CaptainK: http://ideone.com/U7JDGy
23:34:49 <CaptainK> ok, that helps, next I will try with map
23:39:02 <CaptainK> what am I missing here? http://ideone.com/NAzgVK
23:40:53 <mr-> CaptainK: you missed print or putStrLn
23:41:55 <dmj> > map ((++"..") . fst) $ zip ["one", "two", "three"] ["1", "2", "3"]
23:41:56 <lambdabot>   ["one..","two..","three.."]
23:42:01 <mr-> CaptainK: look at the error message, it is telling you that main i supposed to be (IO t0) but as of now, it is [[[Char]]]
23:42:44 <CaptainK> what is t0?
23:42:51 <mr-> CaptainK: some other type
23:43:08 <CaptainK> can be any type
23:43:27 <CaptainK> int char string
23:43:41 <CaptainK> just a general holder?
23:43:45 <mr-> :t print
23:43:47 <lambdabot> Show a => a -> IO ()
23:43:50 <mr-> :t putStrLn
23:43:51 <lambdabot> String -> IO ()
23:44:38 <CaptainK> so how does that error message translate, just not obvious to me
23:45:12 <Cale> CaptainK: Whatever main is, it has to be an IO action
23:45:19 <CaptainK> I can see it wants something else and right now it has [[[Char]]]
23:45:25 <CaptainK> ok, so it wants an IO
23:45:35 <mr-> That's what it is saying, yes
23:46:20 <mr-> CaptainK: note that there is a print in the code Cale pasted
23:46:53 <CaptainK> yes because GHCi automagically puts those in, so we need them in compile time?
23:47:25 * hackagebot git-monitor 2.0.1.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-2.0.1.0 (JohnWiegley)
23:47:26 <Cale> yeah, you're actually required to define main as a proper IO action
23:47:27 * hackagebot gitlib 2.0.1.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-2.0.1.0 (JohnWiegley)
23:47:29 * hackagebot gitlib-cmdline 2.0.1.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-2.0.1.0 (JohnWiegley)
23:47:31 * hackagebot gitlib-libgit2 2.0.1.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-2.0.1.0 (JohnWiegley)
23:47:33 * hackagebot gitlib-s3 2.0.1.0 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-2.0.1.0 (JohnWiegley)
23:48:34 <codesoup> CaptainK, http://ideone.com/WXUQgS
23:48:54 <codesoup> show turns the output into a string, putStrLn prints it
23:51:21 <mr-> @src print
23:51:21 <lambdabot> print x = putStrLn (show x)
23:51:23 <mr-> :-)
23:52:25 * hackagebot gitlib-sample 2.0.1.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-2.0.1.0 (JohnWiegley)
23:52:27 * hackagebot fswatcher 0.1 - Watch a file/directory and run a command it is modified  http://hackage.haskell.org/package/fswatcher-0.1 (ErlendHamberg)
23:54:17 <CaptainK> ok, so print is same a putStrLn show
23:54:44 <Cale> CaptainK: Or more precisely, it's the same as putStrLn . show
23:55:39 <CaptainK> dmj: thats a nice shorter version :)
23:58:09 <MrFenix> is it just me, or is something wrong with hoogle?
23:58:46 <MrFenix> when accessing it firefox asks me to download a 28.1MB binary file
23:58:58 <mr-> MrFenix: something is wrong
23:59:13 <mr-> MrFenix: the topic says there is some migration going on
23:59:22 <MrFenix> ah ok thanks
23:59:47 <MrFenix> got hidden behind the long list of nicks :)
