04:06:29 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
04:06:29 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
04:06:29 --- names: list (clog foxnorth hexagoxel synonymous [[zzz]] q66 hashcat JuanDaugherty jonsterling federkasten rishabhjain k00mi sxn jonkri shergill paullik1 Moataz-E Ebony dcoutts_ nexx machisuji chidy kamatsu1 Lethalman jibi LK4D4 eldariof ozataman gehmehgeh Bryan792 xexonixxexillion jozefg dialelo Sgeo gusto joergfritsch snikkers kcj typoclass coeus wolfnn HugoDaniel mithsv petapetapeta megabeest BitPuffin jophish_ fuzzy_id cognominal Zenol kludge` asQuirreL Mon_Ouie flebron)
04:06:29 --- names: list (Franciman JaRoel simukis_ yopikh desc|zenbook alanz fujimura threesome Alice3 tg hiratara goldkatze ioanel kevinqcs doomlord Swizec xcvvbr azm amosr kuribas totos pantsman cdk boris`` donri james-ubc path[l] dysinger jmcarthur_mobile merijn Icewing Taneb ts33kr ivan\ mdhopkins chuzz d_arcy BrianHV Mortomes_ marr MindlessDrone ntus1017 tomboy65 bitonic tmiw Quadrescence wole fran Kiryx aeolist harovali Neqoxec thunderrd ninegrid adnap burp Masky gentleben)
04:06:29 --- names: list (maxter gautamc Endy OlegYch Rarrikins akurei_ nanothief bmuk vmussa setmeaway2 julmac bscarlet Argue otto_s preflex sm mauke dakrone Tribal Ralith shanse ajhager xinming leroux Modius shrekster ezrios frx SoupEvil apaku RichyB fijimunkii m3ga bgilbert Bynbo7 supersym pantech ngk kerrick Beetny sjl ktosiek satshabad gienah xcthulhu predator217 imalsogreg destiny_ `0660 Nisstyre brainwash Pengoo smlgs sleepybug sellout- nabilhassein SLi dsfox EarlGray^^ aford)
04:06:29 --- names: list (flux dsfox1 tulcod Excureo Th0mas monochrom epta frontendloader brett kaw ReinH flowsnake chrisbuchholz melter zacts Puffton IanKelling waterlaz joar bogner_ parcs perlite bogner ahihi Jayrays tych0 tertl3 kubrat nominolo scottj zzing Sonderblade copumpkin xymox eacameron Raynes shesek GasaiYuno sclv Deewiant Sculptor dav stepcut jrib kallisti_ tippenein Mayzie noam_ dustinswan philipdexter biscarch phienone c_wraith zxq9 Kuba s00pcan noddy DexterLB plhk dmwit)
04:06:29 --- names: list (floatingman2 saiam isomorphic Shin-LaC troydm Phlogistique petermw _d3f yano novascorpio amathew MyrAchle solancile yacks Amadiro kav knyppeldynan jlaire Nimatek Vorpal zugz jmcarthur Krakarn timbod Darkflux MrRacoon nuttycom1 vw21 nik_89 lusory joshc bcoca vnz ido nkpart Kuraitou akraut RageOfThou cads felipe_ stuntaneous scottschecter cmsd2 optimusbrine ninzine phryk Xorlev Khisanth gemelen Hardolaf peltchu myme1 mgsloan akiress_ MasseR_ wting_ Guest10475)
04:06:29 --- names: list (ssbr` gbluma_ Jimi` int-e Laney mixi thetallguy2 Elision mapreduce tero- schlumpi theDon janinge zaphar_p1 kqr1 Gothmog_ kranius_ cow-orke1 b2coutts HalfWayMan k0ral pcapriotti johanbev_ deggisv2 lenstr Fuco_ wto javawizard slobo_ SHODAN s4msung morolin bstrie theorbtwo idntfy ehd cyphase eb4890 goodmanio ps-auxw dreixel_ Internet13 ciaranm lattenwald thirsteh mimi_vx vehk PHO_ qwandor M-ou-se hackagebot thorkilnaur__ sordina1 canar mlinksva noplamodo helgikrs)
04:06:29 --- names: list (akahn Twey mmathis upgrayeddd mee ivan` hiyakashi banjiewen Tesseraction kaictl Ghoul_ vivekrai cronject levi chirpsalot averell linduxed mikee hape01 araujo JustAPerson dan_johnsin @Cale mstksg Jonte mux Heffalump a11235 zerokarmaleft kloeri xplat ahf Eridius Sunhay bd_ BlastHardcheese geoffh shachaf xnyhps sirspazzolot jlewis duairc JPohlmann integral jaimef ParahSail1n Kabaka purefn dmarker jophish sclv_ Brando753 mikecaruso tvaalen Cryovat canta ousado)
04:06:29 --- names: list (tomprince idoru uu1101 studybot_ DrCode tdammers brendan pingveno DT`` Adios_ gpampara rce bbee koala_man nu11ptr folone bduc torkjak n-dolio brandonw brainproxy othiym23 davorak_ aleator_ mantovani suiside udoprog drmegahertz agundry zomg Plex- ent drewr zenzike_ arnsholt Tehnix dixie_ saurik luite Saizan lispy hvr kshannon ofan mviljamaa sbahra[] eL_Bart0 Maior thorsten1 rgrinberg demolithion @Igloo jlouis tahu fayden MetaCosm shiona wchun ernst mollerstrand)
04:06:29 --- names: list (statusfa1led Boreeas ehamberg mami_ dropdrive tswett bholst_ colah_ mechairo` sevvie Yawgmoth_ ChongLi compnaion_cbue [edwtjo] jssanders Gracenotes Boney bind tensorpudding doshitan nelk pygospa jbauman Guest88661 maksbotan cscherrer stevejb augur brianloveswords rfw Sourceless gspr shepheb lokydor ethercrow mirsal idnar flori skypers WhereIsMySpoon smarter germanmushroom Arnoldz ghorn_ de-Vri-es vobi Zariel c_14 Odd_Bloke Kyzza zz_nh2 arossouw maoe bio- supki)
04:06:29 --- names: list (QinGW tomaw guymann wollw tpsinnem liyang bogdanp Maxdamantus wormphlegm Tinned_Tuna osfameron edkk tavelram_ Ke joachifm ggreg volitek bbloom vmeson mrpantoufle aess briden dwierenga dcoutts bytbox brisbin hiptobecubic joelteon osnr ski_ hiredman canissimia jroesch cods Dtgr `fogus xilo Ornedan schoppenhauer Raynos _br_ kakos lambdabot sajith mornfall CosmicRay djahandarie neektza1 hive-mind Soft kaol jackhill threedaymonk quicksilver Enigmagic liori eyck_)
04:06:29 --- names: list (pettter_ ttm pqmodn_ malorie_ mgregson DigitalKiwi Saeppel dilinger_ td123_ Gilly_ Tekerson_ arkx gnuvince iteratee_ thoughtpolice Natch leifw BMeph clampz YoungFrog Tarential Nahra_ ryanakca dsirenko mr- weie joneshf-laptop Razz ziman MoALTz farn Valodim shennyg thetallguy cheezey Licenser Nik05 froztbyte bezik tomh- aninhumer pr dju pjstadig xenophon zorzar `^_^v Ark1 raid drdo Edoxile sohum s_quark chickenflu ClaudiusMaximus ocharles peddie hpaste thorsten`)
04:06:29 --- names: list (KaneTW nikolah niko ghorn zw01 chrisdone charlesofarrell_ greymalkin fall_ buetow Nickeeh yan_ stass bartavelle Blkt Entroacceptor aformeny Hafydd fxrh latro`a sgso anon1231 bgamari Paks args[0] knz ogew zero7 centrinia yam dsp_ swook` Watcher7 cdidd Fuuzetsu lunarjar kryptiskt jyyou ejls tudalex wunki puzza007 qz kryft sdx23 mike2 \q jml Sagi koninkje_away TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut Belgarion0 petanqk profmakx liszt jkpl McManiaC)
04:06:29 --- names: list (Jello_Raptor nicoo taruti blakesmith solarus jliikka pyrtsa danr cross Rutger`_ Khady solirc ljhms_ Cerise seneca shutdown_-h_now dqd ortmage joogi adlan dario^CIP ion arbn Adeon klugez mrshoe gridaphobe wereHamster genisage hpd ve TML away_sondr3 mietek FireFly xrq pi8029 finnrobi sunnavy_ sunfun prophile kxra ski FUZxxl bz dpwright andrewsw pfoetchen machisuj- Rembane valdyn robinbb Athas brixen relrod Counter-Strike Proteumus lulf mattp__ aristid chrra)
04:06:29 --- names: list (_flow_ fabjan vvv LeaChim h_chiro_ dumbhat @ChanServ wavewave Squid_Tamer Baughn OrangeDuck tomejaguar mmaruseacph2 dextrey milli tamiko rhodesd n00dle Kinnison pnielsen NeatBasis_ sg elgot bcoppens sipa wagle geekosaur isomorphismes anders^^_ magicman mokus mgaare Dybber mendez_ Clint sp3ctum_ cruxeternus birkenfeld seantallen Vq pharaun ericmj fikusz bqp Will| matzo Draconx XMunkki_ janne- divarvel poucet franksh gereedy anildigital_away jodaro bergmark)
04:06:29 --- names: list (elliott deavid AntiSpamMeta dlundy gbarboza meretrix dogmaT MK_FG asante Philippa petercoulton __main__ xrl iulian b52 Svedrin bentrevor Vendethiel jlamothe zoktar vvein petantik caligula__ edunham ixian fryguybob tessier davd cynick petekaz`` Ulrar mrd_ Morgawr Starfire_ mjrosenb newsham nlogax jang1 bobry davean Chousuke wilfredh mortberg fihi09``` tylergillies_ Dashkal gseitz_ ByronJohnson neurocyte kini cschneid Bigcheese Ycros lightquake nxorg8 arkeet)
04:06:29 --- names: list (willb1 necroyeti yeltzooo dmp1ce jamwt cjay tromp_ Spockz arcatan def-lkb_ zaiste pdxleif aszlig CindyLinz lopex lpvb Jaak milessabin Bwild ibid drbean davorb-cellphone bitraten Reisen go|dfish rpenguin jayne nullcone_ inr ISF junsuijin ccasin heath electrogeek Walther ipuustin taylorgb cajla geal ninwa BigEndian ab9rf inarru orospakr acfoltzer tunixman joeyh mxf Ptival gds alpounet betawaffle fergusnoble majoh robbert guerrilla SegFaultAX haasn ggherdov)
04:06:29 --- names: list (ELLIOTTCABLE marienz barrucadu warpy zrot kooga bigs DarkFox mceier em fry talzeus_ mikeplus64 dyreshark vili DustyDingo neena lpsmith Draggor horlicks ParahSailin FreeFull zeiris_ notdan natte Liskni_si pyykkis capisce_ zvrba yiannis_1 mononofu epsylon Fubar^ adimit_away lahwran Riussi_ popx jix copton rmunroe endojelly DrSyzygy alexs kosmikus jrslepak KitB johnw b_jonas oldmanstan Ezku misv pikhq honza SirChurchill anachron earthy palmje Martty munro ft)
04:06:29 --- names: list (dsantiago Tene so Eliel hpc scshunt xorox90_ mkrull si14 etrepum asjo Zesler confound_ nwf carter jaspervd1 luminous macron otterdam xaimus mak` MrWoohoo killy9999 Yaniel `bps vpm tridactyla)
04:09:35 <merijn> Right...
04:10:08 <merijn> This type seems a candidate for CPS style (and Cont?) but I'm not sure how: "Handle -> (Handle -> (Handle -> IO ()) -> IO ()) -> (Handle -> IO ()) -> IO ()"
04:10:17 <merijn> Any Suggestions?
04:19:10 <merijn> ruh-roh
04:19:12 <typoclass> merijn: hm ... that could be all kinds of things?
04:19:24 <merijn> This is not a good exit message for ghci "attempting to use module `Prelude' (./Prelude.hs) which is not loaded"
04:19:44 <typoclass> merijn: maybe approach it from a different way ... how about something Readerish that gives all those guys the Handle?
04:19:52 <merijn> typoclass: I'm doing CPS, so I keep passing in the next continuation.
04:20:08 <merijn> typoclass: That's one single type signature
04:20:54 <merijn> Basically it's doing "Do something with Handle, *maybe* hand of to next guy which again goes something with handle, which *maybe* hands it off to the next"
04:30:22 * hackagebot oi 0.3.1 - Library for purely functional lazy interactions with the outer world.  http://hackage.haskell.org/package/oi-0.3.1 (NobuoYamashita)
04:32:41 <typoclass> merijn: i dunno, but i think you could do Handle -> (Handle -> Action -> IO ()) -> Action -> IO (), assuming "type Action = Handle -> IO ()". if you then flip the argument order inside the parens, you have Handle -> (Action -> Action) -> Action -> IO (). you could then move the remaining Handle to be the last argument, and get (Action -> Action) -> Action -> Action -> Action. no idea if that's any clearer ...
04:32:46 <typoclass> anyway, i have no idea
04:32:48 * typoclass purrs
04:40:06 <merijn> bleh, attoparsec doesn't seem to have an "atMost :: Int -> Parser a -> Parser a" that consumes no more than Int bytes :\
05:11:42 <merijn> How can I trigger a "parse failure" in attoparsec?
05:12:21 <dalaing1> merijn: empty
05:12:45 <hpc> i think fail will work too
05:12:58 <hpc> fail "here's the error message you get back if the whole parser fails"
05:13:05 <merijn> oh! good
05:13:11 <merijn> hpc: Fail throws an exception :(
05:13:14 <hpc> D:
05:13:27 <merijn> from the docs "Monad, where fail throws an exception (i.e. fails) with an error message."
05:13:56 <merijn> But yeah, empty/mzero appear to be failing parsers \o/
05:14:21 <hpc> with an appropriately designed fail, you would be able to do stuff like
05:14:29 <hpc> do ' ' <- anyChar
05:14:33 <hpc>    ...
05:16:47 <merijn> I'm not too happy with attoparsec anyhoo
05:17:05 <merijn> Parsing a fixed length substring isn't possible
05:17:16 <merijn> So I have to manually call parse again to do so
05:19:29 <merijn> Like
05:19:30 <merijn> "limit i p = take i >>= either (const empty) return . parseOnly p"
05:20:07 <merijn> Which limits p to consume no more than i bytes
05:20:23 <merijn> Which seems like the type of thing you want in a binary parser library...
05:23:14 <aristid> merijn: how well would the typeclass Binary work for you?
05:24:37 <merijn> aristid: What is that from?
05:24:55 <aristid> merijn: nevermind i meant the package binary
05:25:41 <zvrba> how can easily test whether a value matches a particular pattern_
05:25:42 <zvrba> ?
05:25:56 <typoclass> zvrba: how about case-of?
05:26:09 <typoclass> > case Just 42 of Just x -> x + 3
05:26:10 <lambdabot>   45
05:26:11 <zvrba> shorter way of writing: isX (TC _) = True ; isX (TC' _) = False
05:26:26 <zvrba> I just want to test a value for particular contructor
05:26:37 <zvrba> ok
05:26:48 <donri> you can make the second pattern simply _
05:27:00 <typoclass> zvrba: i wouldn't use an isX function, i think i'd just use "case ... of (TC _) -> ..."
05:27:30 <donri> if you need to do this a lot for many constructors you could look into generics or templates
05:27:50 <zvrba> no, it's only two constructors. I want to partition a list based on the value's constructor.
05:27:52 <merijn> aristid: That doesn't provide things like alternative, though
05:28:23 <merijn> aristid: So it's fine for parsing fixed binary data, but not for parsing complexer things where you wanna say "try this, else try this, else try this"
05:28:32 <zvrba> ended up like this: (hc, vc) = partition (\x -> case x of { (HC _) -> True; _ -> False }) chords
05:29:22 <donri> > show (toConstr (Just 1)) == "Just"
05:29:23 <lambdabot>   True
05:29:48 <donri> beware that this provides less static safety, though
05:30:25 <donri> > toConstr (Just 1) == toConstr (Just undefined)  -- bit safer
05:30:27 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
05:30:27 <lambdabot>    arising from a use ...
05:30:35 <donri> heh
05:30:54 <merijn> Easiest way to convert ascii to Char? BS.Char8?
05:31:57 <typoclass> zvrba: if you wish, you can use the lambda case extension to simplify that a little http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/syntax-extns.html#lambda-case
05:32:03 <hpc> @src Char
05:32:03 <lambdabot> data Char = C# Char#
05:32:29 <hpc> merijn: you can probably exploit the fact that ASCII and unicode have the same low codepoints
05:32:34 <hpc> and use chr . ord
05:32:39 <hpc> or some variant thereof
05:34:14 <zvrba> typoclass: mm.
05:34:27 <merijn> I guess just chr would work
05:34:28 <merijn> :t chr
05:34:29 <lambdabot> Int -> Char
05:34:31 <merijn> hmm
05:34:46 <merijn> :t chr . fromIntegral :: Word8 -> Char
05:34:47 <lambdabot> Word8 -> Char
05:34:54 <int-e> :t toEnum . fromEnum
05:34:55 <lambdabot> (Enum c, Enum a) => a -> c
05:35:49 <FreeFull> > (toEnum . fromEnum) 'f'
05:35:50 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
05:36:01 <FreeFull> > (toEnum . fromEnum) 'f' :: Char
05:36:02 <lambdabot>   'f'
05:36:11 <FreeFull> I see, it defaults to ()
06:04:24 <dlackili> > let { (a0, a1, a2, m) = (1013904223, 1197560701, 2297181429, 4180963733) ; seed = (1374119413, 2650529429) ; next (x0, x1) = (a0 * x0 + a1 * x1 + a2) `mod` m ; test = seed : zip (snd <$> test) (next <$> test) } in fst <$> take 32 test
06:04:25 <lambdabot>   [1374119413,2650529429,3181485606,593042182,3001506207,228538280,3039904337...
06:05:17 <dlackili> > let { (a0, a1, a2, m) = (1013904223, 1997560701, 2297181429, 4180963733) ; seed = (1374119413, 2650529429) ; next (x0, x1) = (a0 * x0 + a1 * x1 + a2) `mod` m ; test = seed : zip (snd <$> test) (next <$> test) } in fst <$> take 32 test
06:05:18 <lambdabot>   [1374119413,2650529429,775067416,2933382968,2853573641,897029376,3985031409...
06:07:00 <Quadrescence> dlackili, wow, you're in every single channel with this
06:08:45 <startling> is it just me or is Data.Graph really bad
06:31:24 <merijn> Why is there a <$ but no $> :((
06:33:09 <startling> it bugs me too. :(
06:40:41 <merijn> Hmm, I need a name for "newtype Foo a b = Foo (a -> b, b -> Maybe a)"
06:41:16 <bennofs> Isn't that just something like a list?
06:41:35 <merijn> No?
06:41:46 <bennofs> What do you need it for then?
06:41:56 <merijn> It's just two types that are convertible (modulo error) into eachother
06:42:24 <merijn> i.e. "serialise a to b" and "deserialise b to a"
06:42:42 <bennofs> lens calls those "prisms"
06:43:58 <FreeFull> merijn: Something that would imply "maybe bijective"
06:44:05 <FreeFull> Or not
06:44:45 <FreeFull> I don't really know
06:44:48 <merijn> Oh, actually turning this into prisms might be useful
06:53:50 <merijn> Hmm, no actually prisms aren't powerful enough for what I was hoping to accomplish
06:54:05 <roconnor> merijn, what were you hoping for?
06:56:07 <merijn> roconnor: I have a protocol that I need to bother output and parse, which gives rise to a lot of values "(a -> ByteString, ByteString -> Maybe a)" but as far as I can tell those don't really compose further, and I don't think lens can help there?
06:56:15 <merijn> s/bother/both
06:57:38 <merijn> Basicaly, the parser "ByteString -> Maybe a" would compose nicely as applicative, but I don't see how I could possibly do the same for the serialisation
06:58:20 <merijn> "Foo <$> tuple1 <*> tuple2 :: (Foo -> ByteString, ByteString -> Maybe Foo)"
06:58:41 <merijn> But that requires the applicative to know how to decompose Foo, which isn't possible I think?
06:59:04 <roconnor> merijn, I've never considered prisms for seralization, but it seems appropriate.
06:59:16 <roconnor> I'm not certain it is helpful, but it is approporiate
06:59:21 <merijn> Sure
06:59:43 <merijn> But the actual problem I wanted to solve is to be able to compose serialisation and deserialisation at the same time
07:00:24 <roconnor> merijn, I see.  Yea, probably nothing in lens will help much there.
07:00:31 <roconnor> I'll think about it.
07:01:09 <merijn> That seems like it'd be such a nicely elegant thing
07:02:42 <dmwit> merijn: Have you seen the partial isomorphisms paper (and associated Hackage package)?
07:02:43 <merijn> Oh well, any suggestions how to name pairs of serialiser/deserialisers?
07:02:48 <merijn> dmwit: No
07:03:04 <dmwit> ?hackage partial-isomorphisms
07:03:04 <lambdabot> http://hackage.haskell.org/package/partial-isomorphisms
07:04:06 <merijn> dmwit: That doesn't look like the code has the type of performance/robustness I'm after :)
07:05:02 <dmwit> I'm not sure I understand what that objection means.
07:05:19 <luite> it's clearly not enterprise level webscale
07:05:46 <dmwit> Also, the code is not the point, in my opinion.
07:06:00 <Philonous> What does the cereal/binary Put monad give me over the ByteString Builder monoid?
07:06:05 <dmwit> The idea about how to structure composable combined parsers and pretty printers is the point.
07:06:42 <merijn> dmwit: The objection means I want/need fast parsing/serialisation and a 2 year old unmaintained library from a paper doesn't inspire too much confidence in that department
07:06:48 <merijn> dmwit: But I'll take a quick look
07:07:02 <luite> merijn: it's really small, doesn't seem to require much maintenance
07:07:18 <dmwit> right
07:07:50 <merijn> luite: Sure, but the first glance also didn't seem to be the sort of data structure you want when speed is relevant
07:08:17 <luite> merijn: what, an ADT with 2 functions?
07:08:42 <aristid> it's not CPS'd, see
07:08:49 <merijn> luite: I didn't actually look at any code, just the API stuff
07:13:36 <Xire> hello everybody ! I wanted to ask if someone could explain to me how I can write function with taken iterate and an anonymous function to get this  result: 0 2 6 12 20 30 42 56 72 90 110 132
07:13:50 <Xire> myIterate y = take y (iterate (anonymous function) (k))
07:15:28 <ParahSail1n> @ty iterate
07:15:29 <lambdabot> (a -> a) -> a -> [a]
07:15:42 <Xire> I think I have to write somthing like this f(fx)=fx+(fx-x)+2 but I do not now how
07:16:49 <ParahSail1n> > take 10 $ map (\x -> x*(x+1)) [0..]
07:16:50 <lambdabot>   [0,2,6,12,20,30,42,56,72,90]
07:17:03 <Philonous> > scanl (+) 0 [2,4..]
07:17:04 <lambdabot>   [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462...
07:18:24 <Philonous> Xire:  Do you have to do it with iterate?
07:18:53 <Xire> yes
07:19:34 <merijn> dmwit: For now I'm mostly lost with that paper
07:19:51 <Philonous> merijn:  What paper?
07:20:10 <merijn> Philonous: "Invertible Syntax Descriptions:"
07:20:11 <merijn> Unifying Parsing and Pretty Printing
07:21:12 <merijn> luite: Also, the implementation of the library might not be very complicated, but the TH generated code doesn't look very efficient. Anyway, I don't plan to add Yet Another Layer of Yak Shaving, so I'm skipping this for now
07:22:04 <merijn> Although that means I now have to think of a naming scheme for these things
07:22:32 <luite> merijn: fair enough. complaining about lib is more fun than using them anyway ;)
07:22:39 <luite> libs
07:24:04 <ParahSail1n> > iterate (\q -> q + ((round $ sqrt $ fromIntegral q) + 1) * 2) 0
07:24:05 <lambdabot>   [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462...
07:25:41 <Xire> thank you ParahSail1n
07:50:39 <startling> is there something like Functor/Contravariant f that requires an (a -> b) and a (b -> a) to map f a to f b?
07:54:40 <roconnor> startling, yes
07:54:51 <roconnor> startling, but I forget where.  XFunctor?
07:54:57 <dmwit> These are called invariant functors, I think.
07:55:28 <roconnor> I'm feeling compelled to write a small Time tutorial on the Haskell Wiki
07:55:42 <dmwit> ?hackage invariant
07:55:42 <lambdabot> http://hackage.haskell.org/package/invariant
07:56:29 <donri> roconnor: +1, or in the haddocks?
07:57:26 <kqr1> roconnor, do it!
07:57:34 <roconnor> okay, let me find my wiki password
08:00:26 * dmwit chuckles at the hebrew-time package
08:00:48 <dmwit> roconnor: Write it for FP complete, maybe they'll pay you $1000 for it!
08:01:01 <roconnor> heh
08:01:24 <dmwit> I'm serious. I want lots of people to compete so that in a month when I have time to compete it will still be around... =P
08:02:45 <startling> dmwit: cool! thanks.
08:03:00 <roconnor> dmwit, I don't think what I have in mind is appropriate for the contest
08:03:55 <dmwit> too bad =)
08:19:00 <merijn> Is there an opposite of "try" that is "Either e a -> IO a", throwing e? :)
08:19:38 <elliott> either throwIO return is pretty short
08:19:56 <merijn> elliott: Yeah, that's what I figured, but that require that e is an exception, no?
08:20:31 <ion> You want to throw an arbitrary e?
08:20:37 <bennofs> merijn: try also requires that e is an exception
08:21:53 <merijn> ion: No, I don't necessarily want to throw e
08:22:08 <elliott> wat.
08:22:28 <merijn> I think I'll go with
08:22:29 <merijn> untry :: Show e => String -> Either e a -> IO a
08:22:29 <merijn> untry s (Left e) = throwIO $ s ++ ": " ++ e
08:22:40 <merijn> eh
08:22:44 <merijn> I guess that needs "show e"
08:23:31 <merijn> ion: attoparsec returns String upon error and String is not an Exception instance :\
08:23:51 <ion> So you don’t want Either e a -> IO a, you want Either String a -> IO a?
08:24:01 <ion> @type throwIO . userError
08:24:01 <lambdabot> String -> IO a
08:57:25 <danharaj> does anyone know if threadscope can indicate threads are being blocked on STM retry if the program doesn't use STM?
09:01:56 <int-e> danharaj: GHC.Event.Unique (used for timed events, for example) uses STM. There may be other places in the Haskell part of the RTS.
09:02:21 <danharaj> int-e: ah ok.
09:05:25 <merijn> show on an ASCII bytestring just produces a "normal" string, right?
09:11:19 <ion> show produces a string, yes.
09:12:41 <merijn> ion: I wanted to know whether the produced string would be normally human readable if it only contained ASCII characters
09:13:06 <ion> Well, did you try?
09:13:40 <kqr1> i just now realised the Show class contains a lot more functions than show
09:14:08 <mel-> hi
09:14:22 <kqr1> or maybe it doesn't
09:14:27 <kqr1> i might be looking at the wrong Show class
09:14:36 <merijn> kqr1: There is only one
09:14:44 <startling> kqr1, it does but they're hidden by :info
09:15:05 <ion> They are? Not here.
09:15:17 <mel-> in maths, i can write something like 'f \times g' and when I apply it to pairs (x,y) i obtain a pair (f(x),g(y)).
09:15:23 <mel-> how can I write this in haskell?
09:15:33 <ion> > f *** g $ (x,y)
09:15:34 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr c'0)
09:15:34 <lambdabot>    arising from a u...
09:15:56 <ion> > f *** g $ (x,y) :: (Expr, Expr)
09:15:57 <lambdabot>   (f x,g y)
09:17:13 <mel-> damn, this operator is not in my scope, and i don't how to google for something like '***' :)
09:17:21 <startling> Control.Arrow, I think.
09:17:30 <startling> @where (***)
09:17:30 <lambdabot> I know nothing about (***).
09:17:33 <mr-> @hoogle (***)
09:17:33 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:23:21 <bscarlet> @where Expr
09:23:22 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:27:04 <merijn> ugh
09:27:28 <merijn> attoparsec and Data.Binary.Get are both limited to Int for the number of bytes to read...
09:28:24 <merijn> Well, Data.Binary.Get supports Int64 too, but even that's not sufficient to handle the max of the protocol I'm dealing with
09:29:02 <merijn> Does anyone have any other suggestions for parser libraries for dealing with binary data?
09:29:05 <aristid> merijn: does the partial parsing work well enough for that?
09:29:53 <merijn> aristid: attoparsec doesn't have a "limit" combinator that lets you specify an upperbound for the length of something, it's rather annoying
09:30:38 <merijn> I have a hack that runs a parser within a parser to fake that, but that requires using "take"
09:30:55 <merijn> Which is 1) terrible for long values and 2) doesn't allow for values bigger than Int
09:31:36 <merijn> Data.Binary.Get is wholly unsuitable for parsing as it only does serialisation/deserialisation and doesn't support backtracking/failure unless you hand code it using lookAhead
09:31:36 <aristid> merijn: couldn't you try writing the parser with the low-level constructor?
09:31:55 <merijn> aristid: I could, but I would prefer not to have to
09:32:20 <aristid> merijn: you could write that parser and pull request it to bos!
09:32:39 <merijn> aristid: I already submitted a issue with my naive version
09:33:29 <merijn> I don't really understand some of the stuff his code is doing, so I don't feel that comfortable implementing my own version
09:35:09 <aristid> merijn: am i blind or does binary not have support for non-lazy IO? i mean like attoparsec's "feed"
09:35:47 <merijn> aristid: You're blind :)
09:35:50 <merijn> aristid: "runGetIncremental :: Get a -> Decoder a"
09:36:00 <merijn> pushChunk :: Decoder a -> ByteString -> Decoder a
09:36:25 <aristid> merijn: ah it's just not re-exported from the top-level
09:37:35 <merijn> Right, so now I have to choose to somehow expand attoparsec to do what I want or implement combinators on top of binary :\
09:37:48 <merijn> This makes me a sad panda
09:38:04 <aristid> no there are many more options!
09:38:20 <aristid> like extending pipes to be able to do what you need ;)
09:38:23 <merijn> aristid: What? Say screw this and stop the project?
09:38:40 <merijn> aristid: No, because afaict pipes is pretty much the antithesis of what I'm working on
09:38:54 <merijn> pipes is all about sequential stream processing
09:38:56 <aristid> merijn: what are you actually working on?:)
09:39:34 <merijn> aristid: An alternative ZeroMQ implementation, because I'm not happy with lack of some features in the C implementation, plus I am unhappy with the haskell bindings to it
09:39:52 <luite> merijn tends to be unhappy with a lot of things ;)
09:39:57 <merijn> Yes
09:40:16 <merijn> People should have higher standards >.>
09:40:20 <aristid> merijn: why would you use zeromq?:)
09:40:28 <merijn> aristid: Name a better alternative?
09:40:39 <aristid> merijn: for which problem precisely?
09:40:52 <merijn> aristid: For the problem of writing complex distributed systems
09:41:08 <merijn> aristid: Or really, for any sort of network programming
09:41:12 <bscarlet> Is there some way I can write a pattern guard in the middle of a pattern?
09:41:16 <aristid> merijn: you mean stuff like storm?
09:41:25 <merijn> aristid: I have no clue what storm is?
09:41:49 <aristid> http://storm-project.net/
09:42:19 <aristid> i guess that doesn't include the queuing part though
09:42:39 <merijn> ZMQ == sockets without the suck
09:42:52 <aristid> aha, what does ZMQ improve over sockets?
09:43:59 <merijn> aristid: multi-part messages, automatic reconnection, bidirectionality (i.e. all sockets can bind and connect), support for publish-subscribe and round-robin message distribution, application level routing
09:44:04 <kuribas> I am writing bezier math code (outline, intersection,...).  Is there a good vector math library to use, for example for matrix transforms, calculating distances, unit vector, etc...
09:44:46 <merijn> aristid: In the new protocol version (not yet fully implemented in the main implementation) it will have authentication and encryption integrated
09:45:11 <aristid> merijn: criticism like these no longer apply? http://lucumr.pocoo.org/2012/6/26/disconnects-are-good-for-you/
09:46:00 <merijn> aristid: i.e. all the stuff you need for complex networking but don't want to implement
09:46:28 <merijn> aristid: The appropriate behaviour for req/rep sockets is still a matter of discussion
09:47:59 <aristid> i'm not sure if that means it's still a problem or not.
09:48:28 <merijn> I dunno, I only skimmed the article
09:48:34 <merijn> tl;dr and all that :)
09:51:08 <aristid> merijn: i didn't recall the details either, but something like that being a problem with zeromq was in the back of my mind... some more comments: https://news.ycombinator.com/item?id=4161073
09:52:36 <merijn> gah
09:52:45 <merijn> ok, I'm sick of this BS for now
09:53:49 <merijn> I guess the new extra layer of yak shaving is "fix binary parsing to not suck"
09:54:58 <aristid> merijn: i think you should limit the scope of your problem to something less broad than 'anything networking' :P
09:56:52 <merijn> aristid: I don't have any scope
09:57:01 <merijn> I'm just trying to parse the ZMQ binary protocol
09:57:10 <pokerexchangenet> Join the hottest new social poker on the web, play, win, exchange chips for awesome prizes! http://www.pokerexchangenetwork.com/ sign up, buy chips and play on http://www.pokerexchangenetwork.com:8181/
09:57:15 <merijn> @where ops
09:57:16 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
09:57:16 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:57:25 --- mode: ChanServ set +o geekosaur
09:57:35 <geekosaur> oh, already idoru-d
09:57:37 --- mode: geekosaur set -o geekosaur
09:57:38 <dmwit> already k-lined, no need for ops
09:58:27 <merijn> aristid: The problem is that attoparsec doesn't support a notion of a field of fixed size and binary doesn't have any real notion of parsing
09:58:32 <elliott> there should be a rule that if someone responds to a @where ops they have to ban at least one person before deopping. to make things more exciting.
09:58:36 <merijn> i.e. no matching patterns and no backstracking
09:58:37 <aristid> hum if the reaction by freenode is instant, why does freenode still propagate the spam message?
09:58:48 <aristid> merijn: yeah fair enough, those are real problems
09:59:27 <merijn> aristid: The thing that's causing me trouble is that I have things like "null padded string in field of 20 bytes" and attoparsec has no notion of parsing those
09:59:42 <jmcarthur> aristid: it's not really instant. it's still just flood detection, as i understand it.
09:59:46 <dmwit> I think there's probably a threshold. It sends the first few messages, then notices spam is happening and kills.
10:00:03 <merijn> Likewise there's no way describe any field that has  a size bigger than Int in attoparsec
10:00:04 <geekosaur> idoru's not built into freenode's input layer, it's just another client. (hence why it has to be in a channel to see spam, and it sees nothing in channels it's not in)
10:00:17 <geekosaur> so it's already propagated when idoru sees it
10:00:29 <aristid> oh
10:00:34 <merijn> These two things are the main cause of my current headache
10:00:37 <aristid> it just reacts quickly then :D
10:00:44 <geekosaur> yep
10:00:52 <aristid> merijn: is "Bigger than Int" a real problem?
10:01:08 <aristid> merijn: i would suspect that GHC wouldn't deal very well with zeromq messages >4GB
10:01:34 <aristid> well or actually more
10:01:37 <merijn> aristid: Realistically? Probably not, but it means it doesn't follow the protocol, thus not being very future proof
10:01:39 <geekosaur> I would suspect zeromq wouldn't deal very well with messages >4GB :p
10:01:39 <aristid> on 64-bit machines
10:01:54 <aristid> merijn: how many bits does the protocol mandate? 128?
10:01:55 <geekosaur> at least I doubt it's been well tested :)
10:02:19 <merijn> aristid: The protocol dictates maximum message size of (2^64 -1)
10:02:29 <merijn> i.e. 64bit unsigned
10:02:42 <aristid> merijn: so you need Word64 hum
10:02:55 <merijn> geekosaur: Of course, but it's a matter of future-proofing the protocol
10:03:11 <aristid> the protocol isn't going to be that future-proof itself :P
10:04:05 <merijn> Anyhoo, I'm going to the movies, I'll deal with this nonsense some other time
10:04:22 <merijn> Or, alternatively, I get frustrated enough to say "fuck it"
10:04:28 <merijn> later!
10:04:57 <aristid> cu
10:15:45 <wole> @ty buildExpressionParser
10:15:46 <lambdabot> Not in scope: `buildExpressionParser'
10:37:00 <mel-> my haskell programm stops with the error message "<<loop>>"
10:37:21 <shachaf> @where rts-xc might help.
10:37:22 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
10:38:39 <mel-> it is unclear to me what causes this problem. i have tracked this down to the following. when i define "f = f'" everything works fine. when i write "f = let res = f' in res" the program aborts.
10:39:17 <jmcarthur> mel-:  http://lpaste.net/new/haskell
10:40:11 <elliott> that sounds bizarre
10:40:19 <mel-> it is. :-/
10:44:58 <Nisstyre> > let f = f let res = f' in res
10:44:59 <lambdabot>   <hint>:1:11: parse error on input `let'
10:45:09 <Nisstyre> > let f = let res = f' in res
10:45:10 <lambdabot>   not an expression: `let f = let res = f' in res'
10:46:01 <dmwit> mel-: Show us enough code that we can reproduce the problem.
10:46:26 <mel-> i'm assembling a minimal test case
10:58:46 <mel-> okay, so, i have tried to stip the program while still exhibiting the same behaviour: http://lpaste.net/91259
10:59:18 <mel-> there's a 'FIXME' in the code and the comment there say which version of the code works and which version makes the program immediately fail with "<<loop>>".
10:59:32 <mel-> you need to start the program with a numerical parameter, e.g. "./test 10"
10:59:46 <mel-> this is pretty strange for me.
11:00:02 <hpc> there's your problem
11:00:13 <hpc> let (n, state) = computeF1' state recursionLevel pair nOdd -- both states on this line are the same
11:00:22 <hpc> you should let (n, state')
11:00:30 <hpc> ... in (n, state')
11:01:38 <hpc> let-in works that way to allow such fun constructs as
11:01:51 <hpc> > let squares = 1 : map (* 2) squares in squares
11:01:51 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
11:02:02 <mel-> oh my.... i was looking somewhere else for the problem.
11:02:12 <mel-> thank you very much
11:02:28 <hpc> er, that's not named squares
11:02:31 <hpc> but you get the point :)
11:03:28 <jmcarthur> aw man, a data point for that thread on nonrecursive let, and not in favor of my side
11:04:08 <aristid> jmcarthur: what's your side?
11:04:17 <int-e> > scanl (+) 0 (scanl (+) 1 (repeat 2))
11:04:18 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
11:04:18 <hpc> his side is no non-recursive let
11:04:21 <hpc> as is mine
11:04:25 <aristid> hum
11:04:51 <aristid> i guess nonrecursive let lets us locally pretend haskell is less partial than it is ;E
11:05:13 <hpc> all it's going to do is encourage newbies to write towers of let
11:05:29 <hpc> instead of thinking with composition
11:05:56 <aristid> oh a non-recursive let that doesn't allow backreferences at all?
11:06:07 <aristid> i was imagining something more like recursion detection :D
11:06:29 <hpc> yeah, like ML's let vs letrec
11:06:55 <hpc> (and letfun; ML is kinda tedious to define things in)
11:07:04 <chrisdone> so is lisp
11:07:10 <hpc> @quote defun
11:07:10 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
11:07:21 <chrisdone> CL: let, let*, flet, labels, Haskell: let
11:07:22 <hpc> @quote .funbox.
11:07:30 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
11:07:30 <hpc> there we go
11:07:44 <hpc> chrisdone: don't forget defun, define, defmacro
11:07:59 <aristid> well scheme is less bad
11:08:13 <aristid> slightly
11:08:16 <hpc> scheme's poison is global continuations
11:08:57 <chrisdone> in STG recursive, non-recursive and tail-recursive definitions are distinguished in the AST, iirc
11:09:29 <hpc> chrisdone: STG is almost assembly, though
11:09:51 <hpc> (was about to say "almost machine language, but it is a G-machine language"
11:09:57 <hpc> )
11:10:28 * jmcarthur wishes repa had a mutable API to go along with the immutable one, the way vector does
11:10:43 <hpc> that would be... interesting
11:10:44 <chrisdone> hpc: almost assembly? it's system f with bells
11:11:23 <hpc> chrisdone: i mean, it's below what you would expect a programmer to type in
11:11:35 <jmcarthur> well, Core is still fairly high level. STG gets into VM territory.
11:11:58 <chrisdone> the stg ast isn't that different to core
11:12:04 <aristid> i hope you don't expect a programmer to type in core
11:12:06 <jmcarthur> Cmm is more what i would call "almost assembly" though
11:12:12 <chrisdone> still has lambdas, cases, lets, literals, ops, cons
11:12:16 <jmcarthur> i think a programmer could reasonably write core by hand, yes
11:12:23 <chrisdone> yeah, maybe you're thinking of cmm, not stg
11:12:33 <aristid> jmcarthur: could, ok. but should?
11:12:37 <hpc> anyhoo, let's not take design decisions for core as inspiration for haskell
11:12:40 <jmcarthur> i don't think it's crazy
11:13:15 <jmcarthur> then again, i write a lot of ocaml
11:13:18 <chrisdone> core/stg remind me of the fundamental lisp implementation
11:13:35 <chrisdone> hpc: fwiw this is the stg ast: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/StgSyn.html
11:13:58 <chrisdone> ghcjs and haste compile to js from stg
11:15:20 <monochrom> I don't write in core, but that's just because I don't want to write out all the types
11:15:24 <aristid> stupid question: is the Y combinator possible in core?
11:15:28 <chrisdone> they could use core, but stg resolves some things like the recursive/non-recursive and letnoescape which is also useful for making faster output
11:15:31 <hpc> yes
11:15:46 * hackagebot fay-hsx 0.2.0 - Clientside HTML generation for fay.  http://hackage.haskell.org/package/fay-hsx-0.2.0 (JeremyShaw)
11:15:48 * hackagebot mustache2hs 0.2.2 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.2.2 (StephenWeber)
11:15:53 <hpc> it has to be, because fix is defined in ordinary haskell
11:15:55 <chrisdone> aristid: core is just system f with a couple extra things, it has lambdas and cases and such
11:16:10 <aristid> chrisdone: yeah but Y combinator is not possible in haskell
11:16:22 <aristid> hpc: isn't fix just defined recursively?
11:16:34 <jmcarthur> you mean the untyped LC implementation?
11:16:46 <aristid> yes
11:16:58 <monochrom> let's just be specific: (\x -> x x)
11:17:14 <hpc> the Y combinator doesn't imply that it has to be the untyped lambda-calculus implementation
11:17:15 <aristid> monochrom: ok. is that possible in core?
11:17:26 <jmcarthur> do you rule out unsafeCoerce?
11:17:29 <monochrom> I say no.
11:17:37 <aristid> hum
11:17:41 <jmcarthur> it depends one what you say is valid core
11:17:45 <jmcarthur> *on what
11:18:00 <aristid> jmcarthur: and on which things does it depend?:)
11:18:54 <monochrom> at the haskell level, I have to use a newtype to help. this translates to unsafecoerce at the core level
11:20:04 <shachaf> The non-(value-)recursive Y in Haskell causes problems with the inliner.
11:20:06 <chrisdone> the more direct question is whether Y can be defined in system F, which i'm not sure about
11:20:22 <jmcarthur> i dont think so
11:20:23 <chrisdone> apparently a type of ∀a.(a→a)→a fixed point is possible
11:20:31 <jmcarthur> really?
11:20:43 <chrisdone> i'm quoting wikipedia, but they provide no source
11:20:51 * chrisdone looks for the system f paper
11:20:54 <Saizan> the coercions introduced by newtypes are not the same as the unsafecoerce one
11:20:55 <elliott> hpc: I don't think calling just any fixpoint combinator Y is right.
11:21:01 <elliott> there are lots of fixpoint combinators with different names.
11:21:13 <elliott> Y refers to only one specific definition, IMO
11:21:30 <Saizan> yeah
11:22:15 <shachaf> chrisdone: "In polymorphic lambda calculus (System F) a polymorphic fixed-point combinator has type ∀a.(a→a)→a, where a is a type variable."
11:22:37 <shachaf> That's saying what its type would be, if it existed. But you can't define it without taking something unsound as a primitive.
11:22:45 <shachaf> Or, at least, I'd certainly hope so.
11:22:59 <chrisdone> right
11:24:30 <chrisdone> http://stackoverflow.com/a/2860908/89574 clarifies
11:25:05 <m-r-r> Hello,
11:25:26 <m-r-r> Is it possible to have references in Haskell ?
11:25:43 <monochrom> sorry, what does that mean?
11:26:10 <jmcarthur> m-r-r: mutable? call-by-reference?
11:26:52 <m-r-r> jmcarthur: references to a value (pointers)
11:26:56 <chrisdone> the docs for core are uncharacteristically decent http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/CoreSyn.html
11:27:08 <monochrom> what do you need "references" for?
11:27:20 <jmcarthur> m-r-r: this sounds less useful to me than i imagine it does to you
11:27:33 <monochrom> to a large extent you don't need it
11:27:51 <ClaudiusMaximus> theoretically "take k . sort" could use ~(k) space for a lazily generated list - does this hold in practice with GHC's sort?  if not, is there already a library that has ~(k) space implementation for this?
11:28:02 <m-r-r> In fact, i need to store some data in structures
11:28:11 <jmcarthur> chrisdone: i am always surprised by how simple core really is
11:28:17 <jmcarthur> m-r-r: we have data structures
11:28:24 <jmcarthur> but you don't need pointers to write them
11:28:26 <m-r-r> each "node" has related nodes
11:28:57 <m-r-r> each node contains lists of others nodes (like in a DOM tree, for instance)
11:29:12 <tulcod> m-r-r: you just put that list in the type
11:29:33 <tulcod> m-r-r: no need to make that a pointer explicitly - it's optimized automatically
11:29:38 <jmcarthur> m-r-r: data Tree a = Node [Tree a] | Leaf a   -- something like this
11:29:44 <chrisdone> jmcarthur: yeah i did a prototype re-implementation of fay compiling from core and the whole compiler was a couple pages of code, so simple. (the ghcjs/haste guys have the right of it by choosing STG because it strips things down a bit more)
11:29:46 <monochrom> like this? "data Tree = End | More Int Tree Tree"? (a binary tree)
11:30:03 <m-r-r> ok, but if i have the same node in two lists, it will take twice the space
11:30:08 <tulcod> m-r-r: no
11:30:09 <jmcarthur> m-r-r: i disagree
11:30:22 <tulcod> m-r-r: compilers these days are pretty good
11:30:36 <jmcarthur> m-r-r: let x = (1, 2) in [x,x,x,x,x]   -- only has one copy of (1,2)
11:30:46 <ClaudiusMaximus> m-r-r: if it's a tree, then just use a tree, otherwise for cycles i've used something like  (Map NodeID (Map Relation NodeID), Map NodeID Content)
11:31:02 <chrisdone> ClaudiusMaximus: is that possible? how can you sort a list without looking at the last item?
11:31:03 <monochrom> "x = More 5 x x" is a self-referencing tree and uses O(1) space
11:31:22 <m-r-r> so, if i have 1000 times the same node in different places in the tree, il won't take 1000 times the size of one node ?
11:31:27 <sshack> Are there any haskell plotting libraries like mat libplot for python? My usage case is plotting graphs for a webapp.
11:31:30 <ClaudiusMaximus> chrisdone: you can discard any that are not in the result
11:31:38 <tulcod> m-r-r: why do you find that so hard to believe?
11:31:45 <jmcarthur> ClaudiusMaximus: then all versions of that expression satisfy your criteria
11:31:46 <ClaudiusMaximus> chrisdone: like minimum is constant space, though it needs to look at the end
11:32:05 <m-r-r> tulcod: I just wanted too be sure
11:32:13 <jmcarthur> m-r-r: this is called "sharing"
11:32:21 <chrisdone> ClaudiusMaximus: oh, wait, i was thinking that every element will be checked, but--right, not at once and possibly in sequence therefore using limited space. gotcha
11:32:38 <m-r-r> jmcarthur: ok. and that works only for tree or everywhere ?
11:32:39 <jmcarthur> m-r-r: if you create the same node twice, it will exist in memory twice. however, if you create it and then use it in multiple places, then it will just be in memory once
11:32:44 <tulcod> m-r-r: in haskell, you generally do it the "easy way" until you discover your program isn't sufficiently fast. then you use a profiler to discover what is causing that. but generally, just do it hte easy way
11:32:56 <jmcarthur> m-r-r: it's a fundamental property of ghc
11:33:00 <jmcarthur> m-r-r: not just trees
11:33:05 <m-r-r> tulcod: ok
11:33:15 <tulcod> jmcarthur: i disagree with that, there is no explicit method to create some object twice, is there?
11:33:16 <m-r-r> jmcarthur: and others implementations ?
11:33:25 <monochrom> m-r-r: instead of explicit "pointers" or "references", you just use names. down there at the machine level, it's pointers yes, but that's too low-level
11:33:43 <m-r-r> monochrom: ok, thanks :-)
11:33:46 <ClaudiusMaximus> what about (map (+1) (let x = 1 in [x,x,x,x,x])) - doesn't that lose the sharing?
11:33:48 <jmcarthur> tulcod: let x = replicate 5 True; y = replicate 5 True in (x, y)   -- x and y are different heap objects
11:33:52 <hpc> ClaudiusMaximus: yes
11:33:55 <chrisdone> ClaudiusMaximus: so even take 1 . bubbleSort would be constant space right?
11:34:15 <hpc> unless some kind of optimizations happen that might reduce the expression
11:34:19 <chrisdone> ah, wait
11:34:24 * chrisdone puts his lazy hat on
11:34:28 <jmcarthur> tulcod: (actually, that's not entirely true in this particular case because ghc will apply common subexpression elimination to it, but in general it won't/can't do that)
11:34:30 <tulcod> jmcarthur: are you sure about that?
11:34:44 <chrisdone> nah, that would be O(n) space at least, n/m
11:34:57 <jmcarthur> tulcod: consider that the number 5 there is dynamically determined and just so happens to be 5 in both of those cases this time
11:34:59 <ClaudiusMaximus> chrisdone: guess i'll try it with GHC's sort and see how explosive it is...
11:35:06 <tulcod> jmcarthur: i mean, the "replicate 5 True" call can be optimized away the second time, can't it?
11:35:06 <jmcarthur> tulcod: yes, i am 100% certain
11:35:12 <chrisdone> ghc's is a merge sort right?
11:35:16 <tulcod> (not just in this specific instance)
11:35:23 <jmcarthur> tulcod: as i just said, it *is* optimized away in this case, but it fundamentally can't be in general
11:35:36 <tulcod> hm, okay
11:36:13 <chrisdone> ClaudiusMaximus: for the map example, i really would not speculate, check out the core or the stg. it may manipulate the sharing or be fused in surprising ways
11:36:38 <jmcarthur> ClaudiusMaximus: that loses sharing unless you implement map using my stable-memo package :)
11:36:47 <jmcarthur> @hackage stable-memo
11:36:47 <lambdabot> http://hackage.haskell.org/package/stable-memo
11:36:52 <jmcarthur> ^^ map is actually the example i use
11:37:00 <chrisdone> jmcarthur: definitely loses sharing?
11:37:02 <jmcarthur> *an example
11:37:14 <jmcarthur> chrisdone: for the base implementation of map, at least
11:37:23 <jmcarthur> chrisdone: and with ghc as it exists today
11:37:56 <chrisdone> i should add core output to hpaste so we can dissect the output in discussion
11:38:04 <jmcarthur> that would be cool
11:39:25 <jmcarthur> ClaudiusMaximus: but note that in order to actually preserve sharing there is some runtime overhead. in the general case, something like memoization is *required*
11:39:32 <donri> chrisdone: someone was working on a pastebin for core analysis
11:39:53 <donri> alpounet: was it you?
11:40:00 <elliott> chrisdone: ghc errors and warnings too, then?
11:40:06 <lispy> chrisdone: if you did that, I think you'd also want to output statistics for when optimizations fire
11:40:16 <lispy> chrisdone: so that we can also talk about RULES
11:40:54 <jmcarthur> ghc-core output, then?
11:41:48 <chrisdone> elliott: i suppose while at it it would make sense to output errors/warnings too
11:42:36 <chrisdone> lispy: i'm not familiar with developing RULES. is there a page i can read that explains what you're talking about?
11:43:35 <donri> -ddump-rule-firings
11:43:44 <jmcarthur> chrisdone: lispy just means rewrite rules. e.g.   {-# RULES "map-fusion" forall f g xs. map f (map g xs) = map (f . g) xs #-}
11:43:56 <jmcarthur> or do you just mean how to see which ones fired?
11:44:10 <chrisdone> ah, is that all? yeah, could do
11:44:29 <donri> or maybe -ddump-simpl-stats
11:45:29 * chrisdone plays around with the ghc api
11:45:43 <donri> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/options-debugging.html
11:46:23 <chrisdone> HACKER TERRITORY. HACKER TERRITORY. (You were warned.)
11:46:30 <chrisdone> haha
11:48:59 <donri> chrisdone: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/rewrite-rules.html#controlling-rules
11:49:31 <chrisdone> donri: yeah, these are good. i'll cook something up
11:49:49 <donri> \o/
11:50:27 <donri> beware that compilation is completely unsafe :p
11:54:25 <chrisdone> hmm, what are the unsafe parts of ghc compilation?
11:54:30 <chrisdone> i can only think of template haskell
11:54:43 <donri> chrisdone: OPTIONS_GHC for one
11:54:55 <donri> chrisdone: http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell/SafeCompilation
11:54:58 <chrisdone> sure, options pragmas
11:55:00 <hpc> you can make compilation non-terminating
11:55:23 <chrisdone> sure, a timeout on compilation would be appropriate anyway to not waste resources
11:55:41 <joelteon> what
11:55:45 <joelteon> how long would an appropriate timeout be
11:55:49 <joelteon> what if it's just complex
11:55:56 <donri> it's a pastebin
11:56:08 <hpc> joelteon: for type class resolution, it's expressed as a recursion depth
11:56:31 <hpc> not sure what other cases there are
11:59:22 <donri> chrisdone: what OS is hpaste running on? sandboxing with selinux is dead easy on fedora
11:59:38 <chrisdone> ubuntu
11:59:48 <magneticduck> question: is it fairly easy to render a gradient / some arbitrary color field using openGL?
11:59:50 <donri> ah, no clue with apparmor
12:00:01 <magneticduck> because I'm doing some tests in gloss using a collection of rectangles..
12:00:17 <koala_man> magneticduck: a gradient, certainly
12:00:22 <magneticduck> even with -threaded, blocks of like less than 30 pixels take so long
12:00:24 <magneticduck> to RENDER
12:00:27 <hpc> gradients are basically "baby's first opengl"
12:00:32 <chrisdone> disabling or whitefiltering OPTIONS and LANGUAGE should be enough, i think
12:00:38 <magneticduck> gaah; what kind of things does openGL do to make that faster
12:00:48 <luite> donri: selinux is rather broken on ubuntu
12:00:54 <luite> donri: with debian wheezy it works well
12:01:02 <donri> luite: i can imagine :)
12:01:18 <magneticduck> mmm, alright. Now, if there was only an easy to use openGL graphics package
12:01:24 <luite> donri: http://paste.hskll.org/get/309
12:01:27 <donri> chrisdone: might suffice, but then it's more limited ;)
12:01:28 <magneticduck> so I don't have to deal with all that obfurscated quasi-C code
12:01:44 <hpc> magneticduck: i have heard good things about the combination of sdl, gloss, graphics-drawingcombinators
12:01:45 <magneticduck> xl oh well I'll have to deal with it eventually
12:01:54 <magneticduck> huh, I wonder how that works
12:01:55 <chrisdone> donri: yup
12:02:10 <chrisdone> donri: (like my time)
12:02:15 <donri> chrisdone: :)
12:02:23 <magneticduck> because I honestly love Gloss; aside from a few problems with handling events (you can't override the escape-key for instance)... I wish I could make my game in gloss
12:02:43 <magneticduck> what's graphics-drawing combinators?
12:02:54 <donri> it's just soooo easy on fedora. literally "sandbox ghc"
12:03:00 <hpc> magneticduck: go to #haskell-game
12:03:08 <hpc> for more info on graphics libs
12:03:09 <donri> luite: neat, how is selinux used?
12:03:18 <magneticduck> ahah, that is actually what I need, hpc; looked it up on hoogle
12:03:32 <donri> luite: custom policy or just some well placed labels?
12:03:37 <luite> donri: custom policy
12:03:46 <magneticduck> hpc: sadly, I rarely get much help there because evidently only a handful of people write games in haskell :<
12:04:55 <luite> donri: and it uses the selinux api to switch from one security context to another
12:05:04 <ClaudiusMaximus> > let minimumsBy k cmp = foldl' (((strictly . take k) .) . flip (insertBy cmp)) [] ; strictly [] = [] ; strictly (x:xs) = let ys = strictly xs in x `seq` ys `seq` (x : ys) in minimumsBy 10 compare [100000,99999..0]
12:05:05 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
12:05:24 <donri> luite: cool :)
12:05:42 <Guest83068>   x <- maybe (return Nothing) stuffM maybeThing -- is there a better way to do this?
12:05:45 <luite> donri: notdan has blogged about it
12:05:47 <chrisdone> > [100000,99999..0]
12:05:48 <lambdabot>   [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,9...
12:05:56 <donri> luite: but the code itself is run client side right?
12:06:01 <luite> donri: no not yet
12:06:12 <donri> ah, thought ghcjs was used
12:06:29 <luite> donri: oh this is just the first part of the project, getting sandboxing and the site to work
12:07:03 <chrisdone> Guest83068: not that i know of
12:07:12 <donri> luite: epic project :)
12:07:13 <chrisdone> :t traverse
12:07:13 <lambdabot>     Not in scope: `traverse'
12:07:14 <lambdabot>     Perhaps you meant one of these:
12:07:14 <lambdabot>       `T.traverse' (imported from Data.Traversable),
12:07:20 <chrisdone> -_-
12:07:21 <chrisdone> :t T.traverse
12:07:21 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
12:07:35 <chrisdone> Guest83068: hm, possibly this
12:07:39 <Guest83068> ty
12:07:46 <luite> donri: http://parenz.wordpress.com/2013/07/15/interactive-diagrams-gsoc-progress-report/
12:07:59 <donri> luite: yeah i skimmed that i think
12:09:44 <donri> luite: " Even if you configure a subdirectory in your home dir to have a specific security context, restorecon won’t correctly install the context specified in the policy. You actually have to set he context yourself, using chcon." semanage fcontext should do?
12:09:58 <dmwit> :t maybe (return Nothing)
12:09:58 <lambdabot> Monad m => (a -> m (Maybe a1)) -> Maybe a -> m (Maybe a1)
12:10:57 <luite> donri: that adds a file context to the policy, doesn't it?
12:11:48 <luite> donri: notdan had already added that in a policy for the pastebin, but restorecon wouldn't pick it up because the homedir policy would override it
12:12:57 <donri> luite: ordering issue? duno. also selinux has some path aliasing thing where it'll treat /lib64 the same as /lib which ISTR caused some weirdness with fcontext for me
12:13:10 <donri> uh, that's just an example
12:13:56 <luite> donri: oh dunno, i know that there were other people with the same proble, but just using /var/lib, /usr/bin etc fixed it
12:14:04 <luite> instead of running from the home dir
12:14:28 <donri> luite: subdir in home dir should be fine though?
12:14:40 <luite> i think it already was a subdir
12:15:27 <donri> odd, you certainly should be able to set contexts for directories in home
12:15:45 <donri> let's blame debian! why aren't you all using fedora already
12:16:51 <luite> unfortunately the whole policy didn't work on ubuntu, they have some version confligts or something
12:17:17 <Clint> ubuntu doesn't like selinux
12:17:18 <donri> i imagine ubuntu's selinux support is crap as they're focused on apparmor
12:17:30 <luite> yep, i guess it's hardly used there
12:17:54 <luite> apparmore is a whole lot easier to use
12:18:07 <donri> fedora ships and enables it by default so it sort of has to work good
12:18:34 <luite> it's still rather annoying to work with
12:20:04 <donri> selinux is much more powerful but also has many quirks yeah
12:20:44 <luite> hmm, what can selinux do that apparmor can't, other than the obvious label vs path differences?
12:21:48 <donri> i don't really know the details but selinux is much more fine grained
12:22:12 <bscarlet> cabal upload seems to have hung for me. My package seems to be up. Any idea what it's waiting for?
12:22:53 <chrisdone> bscarlet: don't worry about it, it's just weird like that. experienced the same thing for years
12:23:10 <bscarlet> hmm.
12:23:24 <aristid> bscarlet: at some point it will be done
12:23:42 <luite> donri: bah, i chose selinux for wolfgang over apparmor for some reason, but i forgot... i was hoping you'd tell me ;)
12:24:03 <chrisdone> luite: because fedora has a cool hat logo?
12:24:27 <luite> chrisdone: no because i used ubuntu
12:24:37 <luite> when selinux still worked on it
12:24:42 <bscarlet> Well, I waited and it gave me a 500.
12:25:01 <luite> bscarlet: best i can do is 403
12:26:11 <chrisdone> bscarlet: yeah, matches my experience. sometimes it goes through ok, sometimes it hangs. either way the package appears to upload
12:26:57 <bscarlet> Well, thanks.
12:30:53 * hackagebot llvm-general 3.2.5.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.5.0 (BenjaminScarlet)
12:30:55 * hackagebot llvm-general 3.3.5.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.5.0 (BenjaminScarlet)
12:31:04 <chrisdone> bscarlet: \o/
12:31:21 <bscarlet> \0/
12:45:21 <ClaudiusMaximus> is there something i could use that is better than   concat . transpose . parMap strategy function . transpose . chunksOf numCapabilities   ?  (not complaining, just curious - this gives me almost perfect parallelism so far, 191.7% productivity with 2 cores)
12:48:57 <aristid> ClaudiusMaximus: how well does it behave for more than 2 cores?
12:50:26 <ClaudiusMaximus> aristid: i imagine it will scale nicely, but i'll try it on my desktop shortly..
12:53:07 <aristid> @hoogle chunksOf
12:53:07 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
12:53:07 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
12:53:31 <aristid> @hoogle transpose . chunksOf 4
12:53:31 <lambdabot> Parse error:
12:53:31 <lambdabot>   transpose . chunksOf 4
12:53:31 <lambdabot>              ^
12:53:38 <aristid> :t transpose . chunksOf 4
12:53:38 <lambdabot> [a] -> [[a]]
12:54:07 <aristid> ClaudiusMaximus: how do you measure productivity?
12:54:17 <ClaudiusMaximus> aristid: actually, it's more like   mconcat . parMap strategy (mconcat . map function) . transpose . chunksOf numCapabilities  which is probably a fairly standard way to do a parallel/sequential reduction of a commutative monoid
12:54:21 <ClaudiusMaximus> aristid: +RTS -s
12:54:46 <ClaudiusMaximus> > chunksOf 3 [1..10]
12:54:48 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
12:55:04 <ClaudiusMaximus> from Data.List.Split
12:55:28 <luite> ClaudiusMaximus: isn't that the same as the parListChunk strategy?
12:55:34 <aristid> ClaudiusMaximus: i just suspect it might waste time transposing?
12:55:44 <mr-> > transpose  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:55:45 <lambdabot>   [[1,4,7,10],[2,5,8],[3,6,9]]
12:56:16 <aristid> ClaudiusMaximus: do you know how big your input list is?
12:56:27 <ClaudiusMaximus> luite: iirc, that doesn't have the transpose - so you need to know a good size...
12:56:31 <ClaudiusMaximus> aristid: no
12:57:47 <ClaudiusMaximus> aristid: i can calculate an upper bound, though it might be out by a few orders of magnitude...
12:57:55 <aristid> ClaudiusMaximus: couldn't you maybe split up your input list into pretty big chunks, let's say size 1000 or so, and then use chunksOf 333?
12:58:09 <luite> ClaudiusMaximus: hmm, but isn't your list rather long? if there is a lot of calculation time per element then parList would just work
12:58:27 <newsham> ?hoogle chunksOf
12:58:27 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
12:58:27 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
12:58:41 <aristid> newsham: Data.List.Split
12:58:44 <donri> ClaudiusMaximus: also if you can it might be better to parallelize the relevant function itself, since chunking will not really be "fair"
12:58:52 <newsham> nifty.  i always invented my own.. glad its in the libs now
12:59:45 <donri> ClaudiusMaximus: or even go nuts with data parallelism
13:00:49 <luite> donri: chunking is used to reduce the number of sparks, parallellizing the function would only increas it
13:00:59 <ClaudiusMaximus> donri: i tried parallizing the function, but my fu was weak and i got no speedup and a bucketload of sparks
13:01:21 <luite> donri: otherwise parList would do the trick already
13:01:21 <donri> yeah. it really depends on the problem at hand
13:03:11 <ClaudiusMaximus> yep with this transpose/chunking i get 1 spark per core - the list is almost certainly long enough that any unfairness at the end will be a small percentage of runtime
13:03:26 <mel-> I need to link a haskell program statically. I have read that I shall use 'ghc -optl-static ...' for that. When I do this it fails with "/usr/bin/ld: cannot find -lffi". can I easily fix this? My operating system (fedora 18) does not seem to provide a file libffi.a.
13:05:37 <donri> mel-: static should be the default...
13:05:59 <donri> duno about C libs though
13:06:48 <donri> mel-: i see a bunch of packages for "yum search libffi" on fedora 18
13:07:17 <donri> mel-: yum install ghc-libffi-devel should get you what you need i expect
13:07:50 <mel-> donri: ghc generated dynamic executables on my system by default.
13:08:15 <mel-> that is what 'file' and 'ldd' tell me.
13:08:38 <donri> mel-: well haskell libraries should be statically linked
13:08:56 <mel-> donri: ghc-libffi-devel is installed and doesn't do the trick.
13:09:29 <mel-> it seems that ghc/gcc are looking for libffi.a. at least i had the same problem with -lgmp not being found. but in this case i did find a package providing libgmp.a.
13:15:09 <donri> mel-: yeah, may have to compile the library for static use yourself then. mingw{32,64}-libffi-static has this file but no idea if it can be used outside mingw
13:15:52 <mel-> donri: i'm just wondering about this.... not even 'trivial' programs can be compiled statically.
13:16:12 <mel-> donri: so, if i see things correctly, static compilation of haskell programs on fedora (18) seems to be broken.
13:16:18 <mel-> (in general)
13:16:47 <donri> mel-: yum list \*-static
13:17:04 <mel-> donri: biiig list :)
13:17:28 <donri> mel-: quite. point is these are not installed by default i don't think, and not available for every packaged library
13:18:16 <mel-> donri: sorry, i had problems parsing that :)
13:18:41 <donri> mel-: or rather the point is, static libraries are packaged separately. it's not "broken", it's just you don't have the libraries
13:19:30 <mel-> donri: yeah, welll, my point is that there are no static librarires for libffi. and least not following the same naming scheme of the other libraries with a '-static' suffix
13:19:41 <donri> mel-: quite
13:20:29 <mel-> donri: hah! https://bugzilla.redhat.com/show_bug.cgi?id=844842
13:20:36 <donri> mel-: so the problem is missing packages. nothing is "broken" as such
13:20:47 <donri> (not to belittle your frustration)
13:21:10 <mel-> oh, it's not (yet) frustration, just annoyance.
13:29:00 <LambdaDusk> so on the target machine, only libgmp.so.3 is installed, while on my machine, GHC compiles against libgmp.so.10. I can't compile on target machine due to restrictions... what chances do I have?
13:34:39 <mel-> damn, now i got the thing statically linked and on the other system (for which i am doing this), the excecutable fails to start with the error message 'FATAL: kernel too old'... m-)
13:43:08 <aristid> mel-: heh
13:54:03 <veryrandomname> does someone know how to do event switching in elerea?
13:54:04 <monochrom> LambdaDusk: consider my http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
13:55:03 <LambdaDusk> monochrom: What do I have to configure when I build my GHC for gmp 3?
13:55:26 <monochrom> oh wait, you want gmp3? I misread
13:55:58 <monochrom> then GHC's official website's binary tarball already works. it uses gmp 3
13:58:44 <LambdaDusk> monochrom: the server I want to run the app on only has gmp3 installed, but my ghc always compiles against ghc10
13:58:52 <LambdaDusk> monochrom: *gmp10
13:59:16 <elliott> link statically?
13:59:22 <monochrom> no, it is not so much GHC's choice as OS's choice
13:59:42 <monochrom> GHC just asks for "-lgmp". whether that leads to 3 or 10 is up to your OS
14:00:05 <monochrom> get an OS that turns "-lgmp" into 3.
14:00:05 <Clint> it's generally advisable to build for your target platform
14:00:38 <monochrom> I am sorry it is really not GHC's call.
14:01:36 <LambdaDusk> elliott: How would I do that? which options? I think that's the best solution
14:02:38 <elliott> -optl-static -optl-pthread or something.
14:06:10 <LambdaDusk> elliott: I get a load of warnings from libHSnetwork.a
14:13:30 <LambdaDusk> elliott: Butt it works! thanks
14:14:36 <elliott> :)
14:22:41 <tulcod> i have a C lib which can return 0, which i want to return as Nothing, and positive values n, which i want to return as Just n. now, i have to write if statements for this in all functions dealing with it, but can i somehow use types to make sure i didn't forget it anywhere?
14:22:53 <tulcod> that is, is there a sort of Nonzero integral type?
14:25:14 <kier> tulcod: I'm not an expert but would it not be easiest to make a wrapper function over the C functions which converts the integer into a Maybe, and only use/export this wrapper function?
14:26:40 <tulcod> kier: hm... i might be able to do something like that, but i'm afraid that'll take too much code for what i'm trying to accomplish
14:26:54 <tulcod> kier: but i'll keep it in mind as a backup plan, thanks for the hint :)
14:26:57 <evancz> I have been using the Data.Binary library recently (it's really nice!). I currently take a bunch of data structures (Info) and serialize them to separate files. I'd like to have a totally separate program (no knowledge of Info) read all those files and serialize [Info] to a single file
14:27:02 <evancz> Does this seem possible?
14:28:03 <evancz> I guess the question is: can you work with something when the only thing you know is that it is an instance of binary?
14:28:08 <kier> evancz: A polymorphic "Read files containing a, write one file containing [a]"-esque program?
14:28:13 <evancz> yes
14:28:20 <evancz> so much more concise
14:29:10 <evancz> I need to do this in the Setup.hs of my .cabal so sharing the data structure is not feasable (afaik)
14:32:06 <kier> evancz: Data.Binary puts lists by putting the length of the list (as an Int) followed by putting each element of the list concatenated together, so it might be possible to replicate that behaviour by hand
14:32:31 <kier> evancz: e.g. put the number of files, then directly append each input file to the output
14:32:51 <evancz> That sounds quite doable
14:33:07 <evancz> I'd imagine that'd be fairly independent of versions of Data.Binary
14:33:33 <evancz> thank you :)
14:34:00 <kier> evancz: np ;)
14:36:01 <evancz> Should have looked at source of Data.Binary earlier :) I'll try this approach and see how it goes :)
14:36:24 <evancz> see you later!
14:37:52 <pxqr> how many heap objects will take this data Foo = Foo { _a :: {-# UNPACK #-}!(IORef Int) } ?
14:37:54 <pxqr> 2?
15:10:26 <tulcod> which package should i use to marshall C utf8 strings?
15:23:22 <Ebony> "C UTF8 strings"?
15:23:30 <Ebony> I don't recall there being such a thing!
15:23:38 <leroux> Hey, I'm having trouble compiling this script: https://gist.github.com/6096519
15:23:47 <tulcod> well, just char* strings, but with utf8 encoding
15:26:05 <Ebony> tulcod: You still seem confused.
15:26:23 <Ebony> "char * strings" isn't healthy.
15:26:49 <Ebony> I would go on further about that, but I'm... not really interested...
15:27:02 <tulcod> Ebony: i have a C library returning a string of type char *, containing some utf-8 encoded character. i want to marshal that character into haskell.
15:27:19 <Ebony> No. The string isn't of type char *. Strings don't have types in C.
15:27:28 <Ebony> Strings are sequences of characters.
15:27:39 <tulcod> ..
15:27:41 <tulcod> ie char *
15:27:46 <tulcod> char * is a sequence of chars
15:27:52 <Ebony> No. char * is not a sequence of chars.
15:27:53 <tulcod> although in this case one char is not one character
15:27:57 <Ebony> It's a pointer to a char.
15:28:00 <tulcod> yeah
15:28:10 <tulcod> so?
15:28:48 <Ebony> char *foo; strcpy((char *) &foo, "hello"); Is this what you mean, when you say a pointer is a string?
15:28:48 <tulcod> Ebony: i fail to see what your complaint is
15:29:47 <Ebony> ... or do you mean to say that a string is a sequence of characters? In that case, you don't need to mention that a pointer to a string is a pointer to the first character of that string... You don't need to mention char *.
15:29:49 <tulcod> Ebony: look, i don't know what you want from me. i just have a C string in utf-8 encoding which i want to read out
15:31:04 <Ebony> ... and you want to UTF8-decode it?
15:31:17 <carter> dysinger have you looked at http://scrz.io/ yet?
15:31:29 <tulcod> Ebony: i don't know what hte internal representation of haskell Chars is, but if that's necessary, sure
15:32:32 <dysinger> carter: briefly
15:33:01 <carter> you are the relative master of Ops, so any opnining would be good
15:33:11 <carter> docker wins for now I assume? or are there tradeoff?S
15:35:19 <Ebony> tulcod: Yes. I think you want to UTF8-decode the C string.
15:35:46 <tulcod> Ebony: okay, so do you know the most up to date and stable package for that?
15:36:39 <enthropy> tulcod: if withCString doesn't decode, you can always just use the appropriate http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Codec-Binary-UTF8-String.html
15:36:43 <Ebony> There's an intersection of both?
15:37:10 <tulcod> enthropy: the *CString functions are locale-dependent
15:37:32 <Ebony> Can you intersect "fastest", too? I'd like to see that.
15:37:36 <tulcod> Ebony: fuck you.
15:37:53 <Ebony> tulcod: Uhh, isn't UTF8 locale-dependent?
15:38:08 <tulcod> no, i thought it was pretty independent from the env?
15:38:09 <elliott> tulcod: ?
15:38:13 * elliott wonders what's going on
15:38:24 <kier> Could you not just convert the C string directly to a Haskell ByteString, and then use the standard functions to decode that to a Text? Or is that too slow/unreliable/etc. ?
15:38:56 <tulcod> kier: well yeah sure, but then what's the standard function to decode a ByteString as utf-8 to String?
15:40:11 <Ebony> I wonder which character set C uses... hmmm...
15:40:56 * hackagebot tsparse 0.2.0.0 - Parses U.S. federal Thrift Savings Plan PDF quarterly statements  http://hackage.haskell.org/package/tsparse-0.2.0.0 (OmariNorman)
15:40:59 * hackagebot ConstraintKinds 1.1.0.0 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-1.1.0.0 (MikeIzbicki)
15:41:09 <kier> Data.Text.Encoding.decodeUtf8 gives you a Text; you can obtain the first (and in this case only) character with Data.Text.head
15:41:37 <tulcod> kier: sounds good
15:41:39 <tulcod> thanks
15:42:46 <kier> tulcod: once again I'm not sure about the speed/efficiency of this method
15:43:02 <tulcod> it's usually just one character, so i'm not too concerned about that
15:43:32 <tulcod> converting back and forth between Text and String is safe, right? i mean, the only difference is in the way it's stored?
15:44:32 <kier> tulcod: I think so, as long as you use Data.Text and not its Data.Text.Word8 counterpart (which is more like a ByteString)
15:45:57 * hackagebot HLearn-algebra 1.1.0.0 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-1.1.0.0 (MikeIzbicki)
15:45:59 * hackagebot HLearn-datastructures 1.1.0 -   http://hackage.haskell.org/package/HLearn-datastructures-1.1.0 (MikeIzbicki)
15:50:00 <Ebony> If a byte in C were 20 bits, then there would be no need for UTF8.
15:52:44 <shachaf> Unicode codepoints need 21 bits.
15:53:12 <shachaf> Anyway, UTF-8 is an encoding into octets.
15:54:51 <Ebony> What's the largest UTF8-supported unicode codepoint, shachaf?
15:55:23 <shachaf> UTF-8 can encode all of Unicode.
15:55:57 <shachaf> > maxBound :: Char -- up to here
15:55:57 * hackagebot HLearn-distributions 1.1.0 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-1.1.0 (MikeIzbicki)
15:55:58 <lambdabot>   '\1114111'
15:56:14 <Ebony> Oh, so it can.
15:56:37 <Ebony> ... and you're right. 21 bit bytes is what C needs. :)
15:57:23 <Ebony> I was hoping to hint more towards the fact that it's... locale-specific
15:59:01 <tulcod> how is utf-8 encoding locale specific?
15:59:13 <tulcod> isn't the entire point of utf-8 that it is one standard encoding for all characters?
16:00:13 <Ebony> Are 21-bit bytes still octets?
16:00:15 <monochrom> utf8 is not locale-specific. "do you use utf8?" may be locale-specific
16:00:46 <Clint> only 8-bit bytes are octets
16:01:11 <Ebony> Okay. If C doesn't have 8-bit bytes, can it still have UTF8 encoding?
16:01:39 <monochrom> "byte" already refers to 8 bits
16:01:42 <tulcod> Ebony: wth are you on about?
16:02:19 <Ebony> monochrom: No. That's "octet".
16:02:36 <Ebony> tulcod: CHAR_BIT is not necessarily 8.
16:02:48 <Ebony> If it isn't, can UTF8 exist?
16:02:58 <monochrom> both byte and octet refer to 8 bits
16:04:46 <mauke> what is going on here
16:05:41 <monochrom> utf8 exists independent of C
16:06:18 <mauke> yes, but a C byte is not the same as an octet
16:06:51 <mauke> and of course you can have utf-8 even in units bigger than 8 bits
16:07:15 <hpc> i thought byte was specified to be 8 bits
16:07:52 <kier> "The C standard requires that the char integral data type is capable of holding at least 256 different values, and is represented by at least 8 bits"
16:07:56 <mauke> it's very much context dependent
16:08:15 <enthropy> preflex seen lowasser
16:08:16 <preflex>  lowasser was last seen on #haskell 166 days, 46 minutes and 19 seconds ago, saying: Does anybody remember seeing a paper on generating code refactorings/rewritings based on figuring out rules from before/after examples?
16:10:11 <enthropy> do other people have experience with glpk-hs? Specifically I'm wondering why the solvers are in IO
16:10:46 <Lethalman> enthropy, cause you want to call glpk functions I guess
16:10:59 <Lethalman> otherwise, you wouldn't be using glpk but a native haskell solver
16:11:08 <Nisstyre> hpc: a C char is one byte but theoretically a byte can be something other than 8 bits, although all modern systems have it as 8 bits...
16:12:00 <enthropy> Lethalman: you can import functions without the IO in the signature (or call unsafePerformIO after the fact) however
16:13:09 <tulcod> kier: managed to read it out. i have no idea if this is portable (esp with regarsd to signed/unsigned chars), but i guess time will tell.
16:13:16 <tulcod> kier: either way, it works, thanks
16:13:24 <enthropy> maybe it's because glpk is rather noisy by default printing things like  28: obj =   0.000000000e+00  infeas =  1.959e-15 (59)
16:13:43 <kier> tulcod: glad I could help ;)
16:14:01 <Lethalman> enthropy, that's exactly.... unsafe
16:14:29 <Lethalman> enthropy, you're assuming the solver is returning the same solution for each input
16:14:50 <Lethalman> I'm not sure that's true
16:15:29 <Lethalman> enthropy, if you are that confident, try using unsafePerformIO yourself
16:15:59 <hpc> glpk is a linear solver
16:16:10 <hpc> i would certainly hope it operates like a pure function
16:16:26 <Lethalman> hpc, yes, unless it starts changing global stuff internally or such
16:16:40 <Lethalman> or putting extra information in the input, or whatelse
16:16:47 <Lethalman> unless you perfectly know, that's unsafe
16:17:54 <rightfold> @pl \xs = zip xs (drop 1 xs)
16:17:54 <lambdabot> (line 1, column 5):
16:17:54 <lambdabot> unexpected "="
16:17:54 <lambdabot> expecting operator, pattern or "->"
16:18:01 <rightfold> @pl \xs -> zip xs (drop 1 xs)
16:18:02 <lambdabot> ap zip (drop 1)
16:18:40 <Lethalman> :O
16:18:44 <Lethalman> :t ap zip
16:18:45 <lambdabot> ([a] -> [b]) -> [a] -> [(a, b)]
16:25:38 <hpc> the acid-state homepage is 500-ing
16:25:47 <ion> The server is on acid.
16:28:36 <Masky> I'm using HDBC for the first time. I'm going to be making queries in a bunch of functions that work recursively. Is the best way to do that to pass the database handle around from function to function?
16:29:29 <hpc> Masky: you can do ReaderT (i forget what the dbh type is) SomethingElse
16:31:14 <hpc> :( acid-state doesn't export makeEvent
16:31:16 <haasn> so do we have an equivalent of the ‘base’ lens for all fractional types?
16:31:40 <haasn> I guess that's nontrivial due to repeating decimals
16:31:53 <ion> Did you send a pull request yet?
16:38:29 <hpc> hmm, doesn't actually seem like an easy thing to change
16:40:00 <hpc> mainly i just want to write my queries in a separate module from the types they act on
16:40:50 <hpc> but that's not actually possible the way IsAcidic is defined :(
16:44:38 <hpc> oh well, doesn't seem to be possible
16:52:13 <edwardk> haasn: write one =P
16:53:12 <haasn> hmm I'll have to check up on the prism laws again
16:55:53 <piesquared> Hey guys. I'm using haskellmode-vim and getting errors along the lines of "count not satisfy package <blah>", even though when I 'cabal install' everything works fine. Any ideas? (FYI this is with snap-server, but I don't think it's Snap's fault.)
16:56:24 <piesquared> my 'build-depends' in the *.cabal does require that package, but I have it in the correct version - cabal install is perfectly happy.
16:56:34 <haasn> edwardk: preview l . review l = id -- would be violated
16:56:58 <edwardk> then don't write one =P
16:57:02 <haasn> since for a fraction that has an infinite decimal expansion in that base it would be ⊥
16:57:04 <haasn> =(
16:57:24 <haasn> wait
16:57:26 <hpc> or write one and squint until the bugs go away ;)
16:57:26 <edwardk> otoh, one can argue that you might render it to a fixed precision as a hack =P
16:57:44 <haasn> what if we standardize 0.123(45) for repeating decimals? ie 0.123454545
16:58:03 <edwardk> the problem is they likely won't all be easily determined like that
16:58:40 <haasn> what do you mean?
16:58:42 * elliott notes: CReal
16:58:45 <edwardk> e.g. feed it pi. =)
16:58:49 <haasn> Fractional
16:58:58 <elliott> oh, ok then
16:59:11 <edwardk> you have Fractional Double, Fractional Float
16:59:20 <edwardk> so i can feed it pi =P
16:59:20 <edwardk> yum
16:59:21 <haasn> pi :: Double -- isn't pi
16:59:27 <edwardk> sure
16:59:30 <haasn> it's a fraction :)
16:59:32 <haasn> technically
16:59:33 <hpc> if you limit yourself to just the obviously repeating decimals, you get something like Either Rational CReal
16:59:39 <monochrom> I think "0.123(45)" is already pretty popular notation on IRC for repeating decimals
16:59:45 <edwardk> anyways it sounds like a mess
16:59:58 <haasn> yeah, probably more trouble than it's worth; we have Show for base 10
16:59:59 <elliott> it sounds kind of convenient.
17:00:04 <BMeph> Flag: pi is not a repeating decimal. ;p
17:00:12 <haasn> and who needs base 2 fractional expansions?
17:00:15 <hpc> monochrom: U+0305 (cc 85): COMBINING OVERLINE [ ̅]
17:00:25 <monochrom> pi = 3.(142857) :)
17:00:28 <edwardk> as for the laws you could argue it forms an improper prism of the first (or second) kind once you work out which way that goes so long as you get a one-sided inverse
17:00:31 <hpc> 0.1234 ̅5 ̅ -- test
17:00:42 <haasn> hpc: doesn't render correctly here
17:00:54 <hpc> or here
17:01:13 <monochrom> yikes, unicode combining thingies are tricky
17:01:22 <Clint> 1̅2̅3
17:01:53 <hpc> oh, it's being combined with a space
17:01:59 <monochrom> haha
17:02:50 <hpc> 0.1234̅5̅ there we go
17:02:55 <hpc> kind of
17:03:07 <haasn> ouch
17:03:27 <haasn> it combines correctly, but the result is a horrible mess in these fonts :)
17:03:42 <hpc> on mine the overline is not full-width
17:03:57 <haasn> same
17:04:03 <hpc> and doesn't align perfectly
17:04:10 <hpc> (droid sans mono)
17:04:22 <Clint> file a bug
17:04:54 <hpc> too lazy
17:09:09 <FreeFull> :t pi
17:09:09 <lambdabot> Floating a => a
17:09:29 <FreeFull> > atan 1 * 8 == pi
17:09:30 <lambdabot>   False
17:09:33 <FreeFull> > atan 1 * 8
17:09:34 <lambdabot>   6.283185307179586
17:09:36 <FreeFull> > atan 1 * 4
17:09:37 <lambdabot>   3.141592653589793
17:09:39 <FreeFull> > atan 1 * 4 == pi
17:09:40 <lambdabot>   True
17:17:14 <m-r-r> good morning :-)
17:17:27 <m-r-r> I have another question:
17:18:13 <m-r-r> I have a function that can return Nothing or Just a constant bad value, or another value
17:18:43 <m-r-r> The type of this function is "Maybe a"
17:20:01 <monochrom> what is "bad value"? why is it not Nothing?
17:20:05 <m-r-r> How can i get the value returned by this function, with a fallback on a default constant if the function returns "Nothing" or "Just myBadValue" ?
17:20:44 <m-r-r> monochrom: a bad value is a constant that i want to replace by my default value if the function returns it
17:21:13 <monochrom> why not use Nothing?
17:21:42 <monochrom> why is it not always either Nothing or Just (good value)?
17:22:25 <m-r-r> monochrom: i have not written this function. Its System.IO.getEncoding. I want to use the UTF-8 codec if getEncoding returns "char8", and getEncoding use a Maybe monad
17:22:55 <gdoteof> is:   \() an idiom in haskell?
17:23:18 <haasn> I wouldn't see why it is
17:23:18 <hpc> no
17:23:22 <gdoteof> i am trying to grok http://www.yesodweb.com/blog/2012/10/yesod-fay-js
17:23:24 <hpaste> m-r-r pasted “openTextFile” at http://lpaste.net/2597835682227421184
17:23:34 <gdoteof> cmdGetPeople <- addCommand $ \() -> do
17:23:38 <gdoteof> is the first line
17:23:54 <hpc> oh, it's an idiom in CPS-transformed code
17:24:07 <hpc> where you have to be a function from something to something
17:24:07 <haasn> a wild stab in the dark would be that addCommand is polymorphic over some typeclass and he specifically wants the () instance so he's pattern matching to help along the type inferencing
17:25:05 <enthropy> hpc: wouldn't cps more commonly be: \k -> k (what the function actually calculates)
17:25:07 <m-r-r> i pasted my function, but it doesn't work because the of the pattern matching line #9
17:25:17 <gdoteof> ohh i see
17:25:42 <gdoteof> what is `()` called.. does it have a name
17:25:42 <jj515> hi all. could someone give me a hand with the following little function?
17:25:44 <gdoteof> i think of it as void
17:25:45 <jj515> let x = fmap listToMaybe . reads $ words "123 1234" :: [Maybe (Int, String)]
17:25:47 <hpc> enthropy: er yes, not CPS
17:25:52 <hpc> but similar
17:26:07 <geekosaur> isn't it commonly referred to as "unit"?
17:26:10 <jj515> I think I have something wrong with the type at the end but I can't figure out what
17:26:12 <Clint> m-r-r: you could use if/then/else or a pattern guard
17:26:26 <gdoteof> geekosaur: unit seems leigt
17:26:39 <enthropy> m-r-r: you can't pattern match on lowercase things like char8
17:26:39 <geekosaur> and \() feels to me like "forcing something to be lazy"
17:27:08 <enthropy> you have to do something like     case encoding of Just x | x == System.IO.char8 -> hSetEncoding ...
17:27:24 <pentace> :t reads $ words "123 1234"
17:27:25 <lambdabot>     Couldn't match type `[Char]' with `Char'
17:27:25 <lambdabot>     Expected type: String
17:27:25 <lambdabot>       Actual type: [String]
17:27:37 <pentace> :t reads
17:27:37 <lambdabot> Read a => ReadS a
17:27:41 <m-r-r> enthropy: and there is no escape sequence or something like this to deactivate pattern matching ?
17:28:12 <m-r-r> Clint: ok, i will try the if/then/else
17:28:17 <enthropy> no
17:28:27 <m-r-r> enthropy: ok
17:28:54 <enthropy> data TextEncoding doesn't look like it has an Eq instance, but you can compare the String you get from show
17:29:24 <enthropy> which would be something like    case encoding of Just x | show x == show System.IO.char8 -> hSetEncoding
17:29:28 <monochrom> I agree with enthropy, if you trust its Show instance
17:30:05 <m-r-r> enthropy: so you can use guards in "case" ?!
17:30:11 <monochrom> yes
17:30:53 <monochrom> > case 45 of x | x>10 -> "good"
17:30:54 <lambdabot>   "good"
17:31:22 <m-r-r> ok, i will try that
17:31:23 <pentace> jj515: Ah right
17:31:32 <m-r-r> thanks :-)
17:32:54 <jj515> this works fine:
17:32:55 <jj515> let x = fmap  reads $ words "123 1234" :: [[ (Int, String)]]
17:33:15 <jj515> but when I try to add listToMaybe, I can't get it to work
17:33:23 <pentace> jj515: Maybe you want concatMap instead of fmap?
17:33:55 <pentace> :t listToMaybe . concatMap reads $ words "123 1234"
17:33:56 <lambdabot> Read a => Maybe (a, String)
17:37:28 <jj515> pentace: i was actually looking for a list of maybes
17:38:08 <pentace> jj515: Okay, I was confused ... "fmap listToMaybe . reads $ y" is the same as "(fmap listToMaybe) . reads $ y"
17:38:22 <pentace> That's where the error comes from
17:38:39 <pentace> so wou probably wand fmap (listToMaybe . reads) ...
17:38:47 <pentace> *you
17:39:06 <jj515> ahh...
17:39:22 <jj515> pentace: you're exactly right
17:39:23 <pentace> *want ... meh, it's too hot here :S
17:39:32 <jj515> thanks
18:00:53 <joelteon> function composition binds more tightly than operators
18:02:27 <mauke> function composition is an operator
18:05:27 <nullcone_> The actual statement of Godel's incompleteness theorem is that every consistent system cannot prove the existence of Gauss ,and it directly implies the version we know nowadays.
18:14:48 <zacts> Godel Escher Bach - MU -> MIU
18:15:32 <zacts> I wonder what it would be like to implement a program that tries to solve that using haskell?
18:28:44 <pentace> zacts: jeltsch wrote a blog post about an implementation: http://jeltsch.wordpress.com/2013/04/18/miu-in-haskell/
18:35:36 <carter> is anyone who undrestands how to use darcs around?
18:37:35 <Clint> you perform your vcs tasks and then you curse a lot at the ui
18:37:58 <harovali1> hi again, I'm a newbie, and also forget things sometimes. I'd like to play around with f.i. Typeable classs in ghci, to write f.i. typeOf Maybe Int  .  Do I have to "import" Typeable somehow ? Or I'm trying something impossiblein the ghci ?
18:38:56 <carter> Clint no, i need someone to actually help me
18:39:15 <carter> because i need to figure out somethign so i can finish helping make a project bsd rather than gpl
18:40:19 <geekosaur> harovali1, depending on ghc/ghci version 'import Data.Typeable' or ':m +Darta.Typeable'
18:40:20 <carter> oh, nevermind
18:40:22 <carter> figured it out
18:40:59 <harovali1> geekosaur: thanks !
18:58:14 <joelteon> is it possible to implement an indexed IO monad (GHC's IO implementation) without basically unsafePerformIO'ing in every bind?
18:59:02 <carter> does anyone know how to get darcs to print the diff assocaited with a patch?
19:00:04 <bb010g> With "deriving instance", is it possible to do more than one derived type per line?
19:00:42 <enthropy>  deriving instance Foo A; deriving instance Foo B; -- this fits on one line :p
19:01:38 <radish> hello everyone! :D
19:01:47 <radish> i have a superb question for y'all
19:02:09 <radish> I'm building one very lovely RNG but i've come upon a stumble
19:02:22 <jmcarthur> joelteon: what would the index mean in an indexed IO monad?
19:02:26 <carter> nevermind, figured i tout
19:02:28 <radish> I can either pass a tuple of lists into a function or call the function as IO
19:02:43 <joelteon> jmcarthur: same thing it means in any other indexed monad, I guess
19:02:54 <jmcarthur> joelteon: it means different things in different indexed monads
19:02:59 <joelteon> yeah
19:03:19 <joelteon> ok, maybe one that enforces that withSocketsDo has been called
19:03:55 <jmcarthur> you could implement such a thing with newtype
19:03:57 <jmcarthur> around IO
19:04:03 <radish> which do y'all think would be the superior choice here?
19:04:03 <radish> I'm worried about speed
19:04:06 <jmcarthur> no unsafePerformIO should be necessary
19:04:21 <joelteon> you could?
19:04:43 <jmcarthur> radish: i don't think you have provided enough information for anybody to answer this question
19:04:59 <radish> oops my connection dropped out
19:05:05 <radish> what was the last thing I said?
19:05:38 <radish> the darn thing won't let me know if messages aren't getting through lol
19:06:10 <jmcarthur> joelteon: sure, it's just going to be something like   newtype IOWithPerhapsSocketsEnabled i j a = IOWPSE (IO a)   and appropriate wrappers for bind and return. you'd have to hide the implementation for it to be safe, and provide some primitives for running withSocketsDo and other sockets stuff that requires certain types
19:06:21 <jmcarthur> radish: "I'm worried about speed"
19:07:08 <joelteon> i guess
19:07:09 <radish> jmcarthur: okay everything got through so far
19:07:11 <joelteon> ok, fair enough
19:07:21 <jmcarthur> joelteon: but it sounds like your goal is to just have an indexed monad without much real purpose. it is not a direction i would recommend
19:07:27 <radish> jmcarthur: what more information should i provide?
19:07:51 <jmcarthur> radish: i don't know what to make of tuple of lists vs. IO. it depends on what you are actually doing in either case
19:09:59 <radish> jmcarthur: everything should be pretty much the same, except in one case I'll be taking state and toying with it, in the other I'll be passing a tuple containing a list containing in total exactly 16 tuples of word 8s like ([(w8,w8,w8,w8)],[(w8,w8,w8,w8)]).  I'm thinking that creating a list over and over might be offset by using just one copy and mutating it.
19:10:22 <radish> jmcarthur: is IO particularly slow?
19:10:56 <radish> jmcarthur: i've never worked with haskell IO before
19:11:29 <radish> jmcarthur: then again I only end up computing what I use, right? so passing big lists shouldn't be a problem?
19:12:08 <jmcarthur> radish: IO has no inherent overhead of its own, really. i would be more concerned with the algorithm i'm using than with the presence of IO itself. that said, i'd prefer an implementation that doesn't require IO because that's just better software engineering
19:12:19 <jmcarthur> radish: but not for any performance reasons
19:13:07 <jmcarthur> there are circumstances where ghc might be able to perform some nice optimizations due to purity where IO might get in the way, but IO is not fundamentally slow
19:13:25 <jmcarthur> big lists are only slow if you use them inappropriately
19:14:00 <jmcarthur> it just depends on millions of factors. without knowing exactly what you are doing, i have no hope of really telling you which option is faster
19:14:13 <jmcarthur> even then i could get it wrong, of course :)
19:14:31 <ParahSail1n> try it and see, then profile if slow
19:14:55 <jmcarthur> radish: i have a question though, which might be enlightening for you... what exactly would you be mutating?
19:15:31 <radish> jmcarthur: state of course!
19:15:37 <radish> jmcarthur: ;)
19:16:53 <jmcarthur> radish: that is rather vague ;)
19:17:16 <jmcarthur> radish: would the state, bychance, be a tuple of lists?
19:17:38 <radish> jmcarthur: yes the input must be output so that it can be a new input
19:18:08 <jmcarthur> radish: so your idea is to eliminate some allocations by using mutation instead, right? so which parts of that state do you make mutable?
19:19:10 <jmcarthur> radish: e.g., if you just put the whole thing in an IORef then you are doing the same work as you would be with a purely functional version.
19:19:23 <jmcarthur> radish: since you still have to create new tuples of lists to replace the old ones
19:20:12 <ParahSail1n> you can use an MVector as your IO/STRef
19:20:32 <pentace> I'm having a weird problem here. When I import Graphics.Rendering.Cairo and Control.Monad.IO.Class I get an ambiguity error for each occurence of liftIO. However, I can't hide either of these liftIOs because otherwise certain instances are missing. How is that possible?
19:21:01 <Nisstyre> pentace: can't you import only the instances?
19:21:11 <pentace> How?
19:21:18 <Nisstyre> import Foo.Bar()
19:21:19 <jmcarthur> import Graphics.Rendering.Cairo ()
19:21:21 <Nisstyre> that imports only instances
19:21:37 <pentace> But I need the function, too
19:21:42 <Saizan> different liftIO sound fishy
19:21:42 <Nisstyre> you can import them too
19:22:04 <Saizan> pentace: you can import qualified, or just disambiguate with the module name
19:22:17 <Nisstyre> yeah or just do a qualified import
19:22:36 <pentace> Let me try ..
19:22:42 <Saizan> import Foo.Bar as F;  import Quux as Q; .... F.liftIO .. Q.liftIO
19:24:13 <Ghoul_> :t runStateT
19:24:14 <lambdabot> StateT s m a -> s -> m (a, s)
19:24:37 <Ghoul_> It's so annoying that the s is the 2nd argument
19:24:44 <pentace> Hmm, that works but I still don't get how this is possible
19:24:46 <Ghoul_> more often than not the initial state is the concrete thing
19:25:16 <dmwit> pentace: What's the exact error?
19:25:26 <dmwit> Because I can't reproduce that problem here.
19:25:33 <dmwit> I can import those two modules and use liftIO just fine.
19:25:59 <dmwit> (Perhaps your cairo package was built against a different version of mtl than the one you're using now or something crazy like that!)
19:26:17 <Saizan> yeah, pentace's problem is that he's using two versions of transformers at the same time
19:26:35 <Nisstyre> ugh
19:26:45 <Nisstyre> can't you hide one?
19:26:53 <dmwit> Saizan: How do you know this?
19:27:12 <geekosaur> you'd have to rebuild everything else built against the other one, from the sound of it
19:27:28 <geekosaur> but yes, multiple transformers versions is what that sounds like to me as well
19:28:00 <dmwit> Okay. All three of us *think* that's what it is. But let's see the error.
19:28:37 <hpaste> pentace pasted “liftIO errors” at http://lpaste.net/91261
19:29:01 <pentace> dmwit: ^^ errors there
19:29:18 <Saizan> pentace: and hiding none?
19:29:34 <geekosaur> pentace is hiding imports, not packages
19:29:42 <Saizan> i know
19:29:58 <geekosaur> so hiding none gets you an ambiguous liftIO
19:30:02 <dmwit> no
19:30:09 <geekosaur> because it's exported by both
19:30:15 <dmwit> Not unless there are two package versions.
19:30:20 <Saizan> i want to see that error :)
19:30:23 <dmwit> And moreover, the error will say the two package version numbers.
19:30:27 <dmwit> If that's the problem.
19:30:36 <dmwit> Which is why we want to see the error. It's a diagnostic.
19:30:37 <pentace> Saizan: that yields an ambiguity error
19:30:44 <geekosaur> yes
19:30:45 <dmwit> pentace: Please paste the exact error.
19:30:46 <Nisstyre> yeah, I've had that problem and it does state which packages are in conflict
19:30:46 <geekosaur> show that error
19:32:27 <pentace> dmwit: http://lpaste.net/91262
19:33:11 <dmwit> Okay, that's very strange.
19:33:15 <geekosaur> right, it's not showing where those import from.
19:33:41 <dmwit> ah, good point
19:34:06 <geekosaur> dmwit, we actually saw this in #xmonad once, same issue where xmonad was built against one and xmonad-contrib was built against the other. and diagnosing it was painful :/
19:34:27 <Saizan> pentace: anyhow, in "ghc-pkg list", check for multiple versions of transformers or mtl
19:35:10 <dmwit> pentace: Can you check what "ghc-pkg describe cairo" says about dependencies? Also, check what "ghc-pkg list transformers" and "ghc-pkg list mtl" say.
19:35:25 <pentace> Saizan: there's only a single entry for each
19:35:55 <geekosaur> (the key symptom there turned out to be that a layout claimed to not be an instance of LayoutClass... which really meant it wasn't an instance of the core's LayoutClass, it was an instance of the one xmonad-contrib had originally been built against. but no version number was printed because it was indirect)
19:37:27 <pentace> ghc-pkg list mtl ==> mtl-1.1.0.2
19:37:35 <pentace> ghc-pkg describe cairo | grep mtl ==> mtl-1.1.0.2-23ca4de7c573fd4df309067199a40634
19:37:45 <pentace> that last one looks weird
19:38:44 <pentace> but all dependencies look like this
19:38:50 <dmwit> Yes, it's normal.
19:39:04 <dmwit> ghc-pkg describe mtl | grep id if you want to double-check that the hashes match
19:39:10 <dmwit> But they should, or you'd have problems earlier.
19:39:18 <dmwit> So this is strange, because it sounds like cairo and mtl agree with each other.
19:39:35 <dmwit> Are you perhaps in some kind of sandbox that is using a different package database?
19:39:49 <dmwit> So that ghc-pkg and ghci don't agree on what packages are available or something like that?
19:40:59 <pentace> not that I know of
19:41:12 <CaptainK> what is n-reduction's "n" part stand for?
19:41:46 <dmwit> CaptainK: If that's eta reduction, it means turning \x -> f x into f.
19:42:00 <dmwit> I'm not sure the letters in the various reduction types actually stand for anything.
19:42:01 <CaptainK> yep thats what I was looking for
19:42:26 <CaptainK> when you want to read on it, you need to know how its called :P
19:42:42 <dmwit> yes
19:43:09 <CaptainK> that is one very cool haskell property
19:43:21 <dmwit> pentace: Well, I'm scratching my head. Don't really know how that could happen.
19:43:28 <dmwit> CaptainK: eta reduction is not correct for Haskell
19:43:40 <CaptainK> how do you mean?
19:43:46 <dmwit> > (\x -> undefined x) `seq` 3
19:43:47 <lambdabot>   3
19:43:50 <dmwit> > undefined `seq` 3
19:43:51 <lambdabot>   *Exception: Prelude.undefined
19:44:05 <dmwit> A thing and its eta reduct are not the same in Haskell.
19:44:14 <dmwit> s/not the same/not always the same/
19:44:35 <pentace> dmwit: Looking at http://hackage.haskell.org/packages/archive/cairo/0.12.4/doc/html/Graphics-Rendering-Cairo.html#g:14 cairo seems to explicitly export this function
19:44:56 <dmwit> pentace: It's just re-exporting mtl's one, though.
19:45:40 <dmwit> You can see it in the import list at the top of the source file.
19:46:39 <dmwit> pentace: http://hackage.haskell.org/packages/archive/cairo/0.12.4/doc/html/src/Graphics-Rendering-Cairo.html#line-284
19:47:06 <pentace> okay
19:49:29 <dmwit> pentace: And just to double-check: ghc-pkg check doesn't report any problems?
19:49:58 <pentace> it outputs nothing
19:52:31 <dmwit> I lose. I've got no ideas left.
19:52:41 <dmwit> Nuke it from orbit and reinstall. =P
19:55:05 <CaptainK> > > let x = 5 in (^2)
19:55:06 <lambdabot>   <hint>:1:1: parse error on input `>'
19:55:13 <CaptainK> > let x = 5 in (^2)
19:55:14 <lambdabot>   <Integer -> Integer>
19:56:07 <zRecursive> > 2 ^^ 64
19:56:08 <lambdabot>   1.8446744073709552e19
19:56:19 <zRecursive> > 2 ** 64
19:56:20 <lambdabot>   1.8446744073709552e19
19:56:49 <CaptainK> > let x = (^2)
19:56:50 <lambdabot>   not an expression: `let x = (^2)'
19:57:09 <zRecursive> > 2 ^ 64
19:57:10 <lambdabot>   18446744073709551616
19:57:41 <zRecursive> :t (^)
19:57:42 <lambdabot> (Integral b, Num a) => a -> b -> a
19:57:48 <zRecursive> :t (^^)
19:57:48 <lambdabot> (Fractional a, Integral b) => a -> b -> a
19:58:40 <zRecursive> :t (**)
19:58:41 <lambdabot> Floating a => a -> a -> a
19:58:47 <CaptainK> Can do this in GHCi, let x = (^2), but not with lambdabot
19:58:57 <pentace> dmwit: The Cairo instances are derived with GeneralizedNewtypeDeriving, might it be a compiler bug in the old GHC 6.12?
19:59:16 <geekosaur> CaptainK, yes, lambdabot is not pretending to be the inside of a `do`
19:59:24 <geekosaur> it wants full expressions
20:00:07 <nooodl_> @let x = (^2)
20:00:07 <lambdabot>  .L.hs:131:1:
20:00:07 <lambdabot>      Multiple declarations of `x'
20:00:07 <lambdabot>      Declared at: .L.hs:130:1...
20:00:22 <nooodl_> @let xxxxx = (^2)
20:00:23 <lambdabot>  Defined.
20:00:27 <nooodl_> > xxxxx 3
20:00:30 <CaptainK> geekosaur: ok, makes sense
20:00:31 <lambdabot>   mueval-core: Time limit exceeded
20:01:42 <CaptainK> 3*3 exceedes a time limit?
20:01:56 <geekosaur> > xxxxx 3
20:02:00 <lambdabot>   mueval-core: Time limit exceeded
20:02:05 <geekosaur> something is weird with the bot
20:02:36 <geekosaur> possibly the preamble (the thing @let writes into, which shows up as .L.hs in error messages) has gotten too complex again
20:02:50 <Modius> Was experimenting with building GHC from tip - is there a way to use make  to uninstall what it put in /usr/local/bin etc.?
20:04:03 <CaptainK> > xxxxxx 4
20:04:07 <lambdabot>   16
20:04:20 <CaptainK> > xxxxx 4
20:04:23 <lambdabot>   16
20:05:29 <CaptainK> now its working, no timeout, something to do with resource sharing
20:07:54 <dmj> iteratees are awesome
20:08:06 <dmj> http://www.mew.org/~kazu/proj/enumerator/
20:08:40 <dmj> so are pipes, conduit, and enumerator, all sort of tackling the same problem? The lazy I/o issue?
20:09:26 <dmwit> pentace: Well, GHC 6-series isn't officially supported by gtk2hs any more. But it really should work -- as far as I know we haven't done anything terribly GHC-7 specific.
20:09:40 <dmwit> (I just don't test it on GHC 6 before a release any more.)
20:10:01 <dmwit> Side question: why are you using GHC 6.12? That's several years old now.
20:11:10 <pentace> Because I don't want to re-build gtk2hs :D
20:12:05 <pentace> Also, I just saw that transformers doesn't use mtl, so it actually *can't* be the same class, no?
20:12:12 <dmj> pentace: are you running osx? I'm able to get gtk2hs working on ghc 7.6.3
20:12:13 <jmcarthur> dmj: they are tackling the problem that it is difficult to write composable code with strict IO
20:12:20 <dmwit> mtl uses transformers.
20:12:25 <pentace> dmj: Nope, Windows
20:12:36 <pentace> Ah
20:12:48 <dmwit> Although perhaps it didn't in the time of mtl-1.
20:12:52 <dmwit> I don't remember.
20:13:02 <dmwit> Anyway, I'm going to bed. I wish you the best of luck. Upgrade GHC, that's my advice.
20:13:21 <pentace> Okay, thanks for the help
20:14:52 <pentace> You're right, mtl-1 doesn't use it :S
20:15:10 <dmj> jmcarthur: ah I see. Finally get the "producer/consumer" part.
20:15:11 <dmj> run_ $ fileFeeder $$ listFeeder $$ (consumer2 >> consumer)
20:15:47 <geekosaur> mtl1 was standalone
20:15:59 <geekosaur> transformers was kinda the testbed for mtl2
20:16:08 <dmj> pentace: curious what your experience with haskell on windows is like. Have you used the .NET interop at all? http://hackage.haskell.org/package/hs-dotnet
20:16:55 <geekosaur> (well, transformers and monads-fd; the latter used different modules so mtl-2 is more or less monads-fd with the mtl1 module names)
20:16:59 <pentace> dmj: No, I haven't used it
20:18:16 <dmj> pentace: any webdev? (w/ haskell on windows)
20:19:09 <pentace> I have built some small Happstack servers once
20:19:58 <pentace> In my experience using Haskell on Windows is just fine as long as you don't need to install external c-packages
20:20:30 <pentace> e.g building gtk2hs and finding a proper set of external libraries was a pain :S
20:20:53 <stepcut> happstack is supposed to work on windows.. I even test it sometimes
20:21:19 <pentace> yep, it worked very well
21:08:30 <pentace> "GHC internal error: `Main.$dmmodifyGUI' is not in scope during type checking, but it passed the renamer" heh
21:21:14 * hackagebot HLearn-distributions 1.1.0.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-1.1.0.1 (MikeIzbicki)
21:34:22 <Gracenotes> Everyone who is interested in primary/secondary computer science education should watch this: http://www.youtube.com/watch?v=Pim4aYfiZiY (Teaching Programming: Too much doing, not enough understanding) </ad>
21:36:56 <zomg> Gracenotes: looks interesting. I get a similar experiences from seeing fellow students with no programming backgrounds trying to learn programming in school
21:37:23 <zomg> at least in the beginning courses there seems to be a lot of OK JUST DO THIS NOW AND THEN THAT HAPPENS!
21:37:51 <zomg> and then it's the next topic where you do something else and people hadn't even learned the fundamental concepts from the previous lesson (say loops or whatever)
21:38:27 <zomg> Though with students going further (say university level CS degrees) then it actually seems to be the opposite, from the POV of getting a job at least
21:38:37 <Gracenotes> yeah. the presentation starts out slow, but it has a lot of really interesting phenomena described, with constructive methods that can be used.
21:38:43 <zomg> lot of theorycrafting but not enough building practical applications
21:38:59 <zomg> Yeah
21:39:09 <zomg> If I ever get bored of being well paid I might consider teaching programming
21:39:13 <zomg> lol
21:41:44 <bb010g> Is there an instance of Traversable for lists?
21:41:52 <johnw> yes, there should be
21:42:07 <johnw> yes
21:42:14 <johnw> just use ":i []" in ghci
21:42:22 <johnw> (after importing Data.Traversable)
21:47:54 <pentace> Is there a function :: (MonadIO m, MonadIO n) => m a -> n a?
21:47:57 <bb010g> "traverse (+) [1,2,3,4,5]" fails, complaining about 'print' and ambigious type variables, even if I have [1,2,3,4,5]::[Integer].
21:48:35 <bb010g> !hoogle (MonadIO m, MonadIO n) => m a -> n a
21:48:47 <pentace> bb010g: There's not even a print in that expression
21:48:54 <pentace> I already checked hoogle
21:49:10 <bb010g> pentace: Trying in ghci.
21:50:11 <pentace> :t traverse
21:50:11 <lambdabot>     Not in scope: `traverse'
21:50:12 <lambdabot>     Perhaps you meant one of these:
21:50:12 <lambdabot>       `T.traverse' (imported from Data.Traversable),
21:50:19 <pentace> :t T.traverse
21:50:20 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
21:50:38 <bb010g> :t T.traverse (+) [1,2,3,4,5]
21:50:38 <lambdabot> Num a => a -> [a]
21:50:48 * bb010g facepalms
21:52:14 <bb010g> > T.traverse (+) [1,2,3,4,5] 1
21:52:15 <lambdabot>   [2,3,4,5,6]
21:57:06 <bb010g> How exactly does Traversable work? "sequence" doesn't make sense to me on lists.
21:57:21 <bb010g> > T.sequence [[1,2],[3,4]]
21:57:22 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
21:57:36 <johnw> sequence takes an [m a] to m [a]
21:57:43 <johnw> it distributes m over []
21:57:51 <johnw> sequenceA generalizes this to
21:57:56 <johnw> n (m a) -> m (n a)
21:58:14 <bb010g> :t sequence
21:58:14 <lambdabot> Monad m => [m a] -> m [a]
21:58:15 <bb010g> :t sequenceA
21:58:16 <lambdabot>     Not in scope: `sequenceA'
21:58:16 <lambdabot>     Perhaps you meant one of these:
21:58:16 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
21:58:23 <bb010g> :t T.sequence
21:58:24 <lambdabot> (Monad m, T.Traversable t) => t (m a) -> m (t a)
21:58:24 <johnw> :t T.sequenceA
21:58:25 <lambdabot> (Applicative f, T.Traversable t) => t (f a) -> f (t a)
21:59:25 <bb010g> What would you use it for?
22:00:35 <johnw> say you have a Maybe (IO a), and what you want is an IO (Maybe a)
22:00:39 <johnw> sequenceA to the rescue
22:00:46 <johnw> I use it for that quite often, actually
22:00:47 <enthropy> bb010g: do you use mapM?
22:01:37 <johnw> bb010g: oh, were you asking about sequenceA, or Traversable in general?
22:02:42 <bb010g> johnw: Traversable in general
22:02:59 <johnw> example: given a Maybe a, and you want to do stuff to the a
22:03:08 <johnw> forM maybeValue $ \value -> do ...
22:03:21 <johnw> as opposed to case matching and ignoring the Nothing case
22:03:50 <johnw> plus, within that forM block you can "return 10", and the result will be m (Maybe 10) for whichever monad you're in
22:04:09 <johnw> i use that idiom _often-
22:04:26 <stevejb> hello, I am working on using the Math.Root.Finder package, and I
22:04:26 <stevejb>     am having a bit of trouble understanding the types
22:04:47 <stevejb>  (Num a, Ord a, RootFinder r a b) =>  (a -> b) -> a -> a -> a -> Either (r a b) (r a b)
22:05:08 <carter> stevejb what alg are you using
22:05:15 <carter> and what problem are you rooting? :)
22:05:38 <stevejb> carter: hi!
22:05:50 <carter> stevejb you need a good guess
22:05:52 <stevejb> carter: well, I have this function that I generate, but just as a test I am trying the following:
22:05:55 <carter> yes
22:05:58 <carter> what i'm saying
22:06:03 <stevejb> let myfn x = x**3.0 - 4.0 * x**2 + 6*x - 24.0 :: Double
22:06:04 <carter> is thats clearly a numerical root finding
22:06:08 <carter> procedure
22:06:11 <carter> do you know what the roots are?
22:06:20 <carter> when you're testing a polynomial root finder
22:06:22 <stevejb> yeah, I have a guess
22:06:28 <carter> form it by a product of roots
22:07:00 <stevejb> I think my question is more simple. I am just trying to figure out how to use the findRoot package
22:07:03 <carter> yes
22:07:06 <carter> i'm saying 2 things
22:07:18 <carter> @hackage findRoot
22:07:18 <lambdabot> http://hackage.haskell.org/package/findRoot
22:07:19 <stevejb> eg, I am trying : findRoot myfn 0.001 10.0 and getting a type error
22:07:25 <carter> hackage link?
22:07:38 <stevejb> http://hackage.haskell.org/packages/archive/roots/0.1.1.0/doc/html/Math-Root-Finder.html
22:07:46 <enthropy> you need 3 initial values apparently
22:08:05 <carter> stevejb lets read the types more
22:08:17 <carter> stevejb also share the type errors when you're stumped!
22:08:17 <stevejb> carter: alright
22:08:18 <enthropy> oh the last one is a tolerance
22:08:19 <carter> enthropy good call
22:09:10 <enthropy> stevejb: if you're just doing polynomials there are better methods that will reliably get you all the roots
22:09:29 <hpaste> stevejb pasted “rootFinder error” at http://lpaste.net/91264
22:10:01 <stevejb> enthropy: the polynomial is just my test. I cannot well characterize the function that Iw ant to find the root of, other than :: Double -> Double
22:10:39 <stevejb> I am trying to figure out the error I pasted
22:11:00 <carter> stevejb sorry, connection dropped
22:11:06 <enthropy> you can specify the method by adding a type signature
22:11:35 <stevejb> enthropy: is that what the "add an instance declaration" is saying?
22:12:05 <stevejb> carter: no worries
22:12:07 <enthropy> that's a bit misleading because you don't need to write another instance
22:12:16 <carter> i didn't see the error message paste
22:12:24 <enthropy> you just need to help ghc to pick an existing instance
22:12:31 <stevejb>  http://lpaste.net/91264
22:12:45 <stevejb> what do you mean?
22:13:00 <enthropy> stevejb: findRoot myfn 0.01 10.0 0.0001 :: Either (Bisect Double Double) (Bisect Double Double)
22:13:54 <carter> stevejb notice the type class constraint!
22:14:42 <carter> findRoot :: (RootFinder r a b, Num a, Ord a) => (a -> b) -> a -> a -> a -> Either (r a b) (r a b)
22:15:03 <carter> as enthropy  has noted
22:15:10 <enthropy> stevejb: it might be easier just to use functions which implement the specific method (ex http://hackage.haskell.org/packages/archive/roots/0.1.1.0/doc/html/Math-Root-Finder-Dekker.html#t:Dekker )
22:15:13 <stevejb> enthropy: it seems to not see the constructor for Bisect
22:15:19 <enthropy> you have to import it
22:16:42 <stevejb> enthropy: thanks, that worked
22:17:11 <stevejb> what method do you think would be the best, if I want the first positive root > 0
22:17:28 <carter> stevejb depends on the polynomials you care about
22:17:30 <carter> math is hard :)
22:17:53 <stevejb> carter: I will have to think about it then :)
22:18:03 <carter> because even if you know what you want
22:18:12 <carter> you may care more about fast approximate root finding
22:18:19 <carter> or you might care about numericall stable answers
22:18:28 <carter> eg: what if the first postive roots are really close together
22:18:31 <carter> or well seperated
22:18:39 <carter> or what if you really just want the eigen values of the system?
22:18:40 <carter> :)
22:18:59 <stevejb> yeah I see. good points
22:20:24 <ben_> really quickly, is there a way to do a lambda with no arguments?
22:20:30 <ben_> or do i need to write this differently
22:20:31 <ben_> map ( \x -> [0..10] ) [0..10]
22:20:37 <ben_> to get a 2d array of 0..10's
22:20:46 <enthropy> map (const [0 .. 10]) [0 .. 10]
22:20:52 <ben_> thanks!
22:20:52 <enthropy> the lambda is shorter
22:21:07 <ben_> does const make more sense though
22:21:52 <enthropy>  \ _ -> [0 .. 10] -- makes more sense than naming x
22:22:05 <enthropy> > replicate 11 [0 .. 10]
22:22:06 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10],[0,1,2,3,4,5,6,7,8,9,10],[0,1,2,3,4,5,6,7,8,9,10]...
22:22:37 <ben_> oh heh, that makes sense too
22:22:41 <ben_> > "thanks
22:22:42 <lambdabot>   <hint>:1:8:
22:22:42 <lambdabot>      lexical error in string/character literal at end of input
22:22:45 <ben_> > "thanks"
22:22:46 <lambdabot>   "thanks"
22:23:07 <Hafydd> The phrase "2D array" when referring to a linked list of linked lists is displeasing.
22:23:20 <ben_> good point
22:23:45 <ben_> i take it i should be using data.array ?
22:23:59 <Hafydd> That depends what you're actually doing.
22:24:03 <ben_> game board
22:24:04 <zRecursive> Data.Array
22:24:08 <ben_> so yes i assume
22:25:15 <Hafydd> Yes, I would think so.
22:25:24 <ben_> cool i'll work with that
22:25:26 <ben_> thanks
22:35:30 <bicgena> http://mathoverflow.net/questions/20882/most-unintuitive-application-of-the-axiom-of-choice/70338#70338  I was under the impression that it was more than just choice that makes that impossible
22:40:53 <ben_> should i totally avoid doing anything mutable in haskell until i've mastered the basics
22:41:14 <ben_> and by mastered i mean, am able to write reasonably idiomatic real programs
22:46:57 <Hafydd> ben_: by "doing anything mutable" do you mean using ST monads?
22:47:34 <zomg> if you literally meant anything that involves mutable state in any form, then I'm not sure if that's a good idea =)
22:47:50 <zomg> since a lot of programs would need some kind of state and tbh I don't see any reason to totally avoid it
22:48:51 <Gracenotes> it's hard to accidentally mutate things in Haskell
22:49:09 <Gracenotes> it's way too frickin easy to mutate things in most other languages.
22:53:55 <johnw> even better: variables that are in an uninitialized state until you DO mutate them:)
22:54:18 <johnw> i'd love a way to ask C++ to not allow variables to be defined without an initializer
22:58:17 <dmj> johnw: reminds me of C#, half the code was just null checks
22:58:31 <johnw> yeah, and java :(
22:58:46 <johnw> it may be one of my most favorite features in Haskell that uninitialized values just don't even make sense
22:58:59 <johnw> it's like a contradiction in terms
22:59:01 <zomg> I worked with a Java codebase at one point, there's actually some libraries which add annotations which do the nullchecks for you :P
22:59:06 <johnw> a value in either an inhabitant or a type, or it's just not a value
22:59:10 <mauke> instance Ord MyType;
22:59:11 <zomg> so you can have like @NotNull whatevervariable
22:59:20 <johnw> oh, that's nice
22:59:33 <johnw> cooler if it could be the default and I use @Null to reverse it
22:59:39 <johnw> like C# with it's ? suffix annotation
23:02:34 <dmj> yea, think C# got the (??) operator, var c = obj ?? new Class();
23:03:00 <johnw> I meant just: int? x;
23:03:18 <johnw> oh, ?? is basically fromMaybe?
23:03:33 <dmj> I just remember calling if (people.Where(x => x.Name == "blah").FirstOfDefault() != null) { /* filth */ }
23:04:25 <dmj> ha yea it's fromMaybe
23:04:51 <dmj> ah the "null coalescing operator"
23:04:57 <dmj> fromMaybe sounds better
23:05:23 <Aorion> Does anyone have a working snippet wherein the 'read' function is applied to a list of strings, and a discussion of why map does not work with read as it does with most sane functions
23:05:24 <Aorion> ?
23:05:35 <Aorion> i'm talking, something like read "5" :: Integer works
23:05:47 <Aorion> but the syntax for map read ["5", "3"] :: Integer is less clear
23:06:15 <Kinnison> It'd need to be :: [Integer]
23:06:21 <Kinnison> since you're typing the result of the map
23:06:46 <johnw> > map read ["5", "3"] :: [Integer]
23:06:47 <lambdabot>   [5,3]
23:07:00 * Kinnison waves to johnw
23:07:05 <johnw> hi Kinnison !
23:07:08 * Kinnison shall be in NY this week, and then Austin
23:07:12 <Kinnison> Crazy days
23:07:27 <Aorion> okay, that worked in ghci. Now, why does that work the way it does? when I type read "5" :: Integer, I am thinking that the read function returns an integer. So if I map read to a list of strings, for each string, it should return an integer.
23:07:45 <Aorion> when you say :: [Integer] i am thinking, map read to a list of strings and return a list of integers
23:07:51 <Kinnison> Aorion: When you say read "5" :: Integer
23:07:59 <Kinnison> Aorion: you're saying that the result of read "5" is an Integer
23:08:12 <Kinnison> Aorion: that allows ghc to work out which read implementation to use
23:08:25 <Kinnison> Aorion: when you say map read ["5", "3"] :: [Integer]
23:08:26 <Aorion> Ahh, that's the deep magic
23:08:36 <Kinnison> Aorion: you're saying that the result of map read [...] is [Integer]
23:08:45 <Aorion> I can see that
23:08:50 <Kinnison> Aorion: so by type inference, ghc can work out that the type of read must be String -> Integer
23:08:57 <Kinnison> Aorion: and from there, to select the right read implementation
23:08:57 <Aorion> so why doesn't just read ["5", "3"] :: [Integer] work?
23:09:08 <Kinnison> Aorion: because read is always String -> a
23:09:19 <Aorion> yep
23:09:30 <Kinnison> > read "[5, 3]" :: [Integer]
23:09:31 <lambdabot>   [5,3]
23:09:47 <Aorion> it's just, I would think it should work one way or the other, but the way it works feels like something halfway between
23:10:03 <Kinnison> Once you learn to decompose what you're typing, it will all make sense
23:10:16 <Kinnison> > map (read :: String -> Integer) ["5", "3"]
23:10:17 <lambdabot>   [5,3]
23:10:37 <Aorion> @Kinnison that completely lines up with what I was thinking
23:10:37 <lambdabot> Unknown command, try @list
23:10:52 <johnw> @ is for twitter, not IRC :)
23:10:57 <Kinnison> :-)
23:11:12 <Kinnison> Aorion: word of warning, it's 07:10 and I've not slept tonight
23:11:19 <Kinnison> Aorion: so I might be making no sense at all :-)
23:11:19 <Aorion> I am old school, I IRC'd using @ to denote targets way before twitter
23:11:37 <Aorion> so i'll keep using @ tyvm :)
23:11:48 <Kinnison> Aorion: lambdabot will notice and whinge :-)
23:12:00 <Aorion> okay. point taken.
23:12:55 <Aorion> so Kinnison: The way I should think about what you posted, is that the String -> Integer bit specifies which implementation of read to use, which makes the result of the map non-ambiguous. is that correct?
23:12:58 <haasn> Aorion: what do you mean “should work one way or the other”?
23:13:17 <haasn> Aorion: yes, basically
23:13:30 <Kinnison> Aorion: Indeed, since once the read implementation is locked down, the type system can sort everything else out
23:14:06 <Kinnison> Aorion: of course, if the way you use read ends up telling the type system what you meant anyway, then it is all automatic
23:14:07 <johnw> we call that "fixing the type"
23:14:27 <haasn> > sum (map read ["3", "5"])
23:14:28 <lambdabot>   8
23:14:50 <johnw> in that case, the signature of sum fixes the type for read
23:15:31 <haasn> (at least, it adds enough constraints to make GHC default a different type)
23:15:36 <Aorion> haasn: Map maps a function onto a list of functions (technically on the backend it does something funky that I'm still working out in my head). What I was saying as to "one way or the other" is that either I specify that read, when given a list, returns a list of integers or I specify that read returns an integer, and then I can map read onto a list. But the first response I got said, specify that read works on each element and that
23:15:38 <Aorion> list of integers
23:15:57 <haasn> Aorion: ‘map’ maps a function onto a list of values
23:16:09 <Aorion> which is deep magic, how can I know that ghc is 'finding' the right types for methods I haven't specified
23:16:10 <haasn> there's nothing funky going on
23:16:18 <haasn> > map f [x, y, z]
23:16:19 <lambdabot>   Ambiguous occurrence `x'
23:16:19 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
23:16:21 <haasn> ugh
23:16:32 <haasn> > map f [a, b, c] -- do we even still have this?
23:16:34 <Aorion> i'm sure it works in the context of the type system that ghc has set up, but I am not terribly familiar with it yet, so I get uneasy when things just "happen"
23:16:34 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
23:16:34 <lambdabot>    arising from a us...
23:16:57 <johnw> Aorion: if you're interested, type of topic of "type unification" may be of interest to you
23:17:13 <johnw> that's how GHC infers the types for the expressions used
23:17:46 <Aorion> Okay. I will look that up.
23:17:56 <haasn> Aorion: well, to sort some things out; read, when given a list, is a type error; read must always be given a string. In the case of the ‘map read ...’ example, it's ‘map’ that's actually going through the list and applying ‘read’ to every element
23:18:06 <haasn> map read ["5", "3"]  =  [read "5", read "3"]
23:18:26 <Aorion> yep
23:18:35 <Aorion> so wait a second, and you'll see
23:18:38 <roboguy_> I don't suppose there's a tool to automatically upgrade all the files in a haskell source tree to use hierarchical modules instead of haskell98 modules?
23:18:40 <johnw> http://smallshire.org.uk/sufficientlysmall/2010/04/11/a-hindley-milner-type-inference-implementation-in-python/
23:18:50 <johnw> that shows a Hindley-Milner style type unification algorithm in Python
23:18:54 <johnw> (HM is what Haskell uses)
23:18:59 <Aorion> now if I wanted to specify that read returned an integer, without knowing the type system, would you think :: Integer or :: [Integer]?
23:19:06 <haasn> johnw: (almost)?
23:19:09 <Aorion> if you wanted to tell haskell to make read return an integer
23:19:23 <johnw> haasn: almost what?
23:19:34 <haasn> almost HM? I thought Haskell is based on System F which is distinct
23:20:03 <johnw> Aorion: also: http://cs.brown.edu/courses/cs173/2002/Lectures/2002-11-13.pdf
23:20:06 <haasn> Aorion: depends on where the signature is
23:20:26 <johnw> haasn: ah, I thought System FC referred to more than just the type unifier
23:20:34 <haasn> Aorion: in the case of:   map read ["5", "3"] :: [Integer]  <- the signature covers the entire expression, map included. Keeping in mind map :: (a -> b) -> [a] -> [b]
23:20:49 <haasn> johnw: it's possible you're right, I don't know if the actual type unification algorithm differs
23:21:00 <Aorion> haasn: so yes, my initial inclination was to make read return integers, because if it did, then I would end up with a list of integers after I mapped through everything
23:21:23 <haasn> Aorion: so in your case read :: Read a => String -> a -- is specialized to read :: String -> Integer;  and that gets passed to map, which gets specialized to map :: (String -> Integer) -> [String] -> [Integer]
23:21:24 <Aorion> if you specify [Integer] then the system is actually going back down and specifying ::Integer for each read operation, implicitly
23:21:30 <haasn> so you see the result of the entire expression has type [Integer]
23:21:36 <Aorion> and that implicitness was what confused me
23:21:39 <haasn> ah
23:21:44 <haasn> well yeah, that's just type unification at work
23:21:51 <johnw> Aorion: and lastly: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=16&cad=rja&ved=0CFcQFjAFOAo&url=http%3A%2F%2Fforum.vhugot.com%2Fdownload%2Ffile.php%3Fid%3D357&ei=Ibj0UfKmKcvcqQHkjYGABg&usg=AFQjCNHqFegKGZlF7J6x5cA44VjJnpkz_w&sig2=OS-fCQWZA1agTA4MYwcgvw
23:21:54 <johnw> gross
23:22:06 <Aorion> johnw: those have been bookmarked, thanks for the reading material :)
23:22:08 <johnw> http://forum.vhugot.com/download/file.php?id=357‎
23:22:21 <johnw> sure thing.  it's a lot less magical than you might imagine too
23:22:22 <haasn> GHC knows that map :: (a -> b) -> [a] -> [b]; and that the result of that expression (the [b]) is [Integer] because you told it; so it knows that [b] ~ [Integer] ergo b ~ Integer
23:22:37 <Kinnison> Aorion: A trick I used when I was learning to trust the type inference engine was to always write things out explicitly, then slowly remove bits of the type data and see when ghc could no longer work out what I meant
23:23:06 <Kinnison> > let readIntegers = read :: String -> Integer in map readIntegers ["5", "3"]
23:23:07 <lambdabot>   [5,3]
23:23:12 <Kinnison> for example
23:23:15 <Aorion> yes, it makes sense now, but it's not intuitive until you've run into this problem
23:23:17 <haasn> and it also unifies read :: Read b => String -> b  -- with (a -> Integer) and that gives you (a ~ String) and again (b ~ Integer)
23:23:53 <johnw> where Haskell type inference *really* gets magical is when it works "backward"
23:24:09 <haasn> unification works both ways :)
23:24:11 <johnw> like, you say alloca $ \ptr -> ... and then much later you use "ptr", and the type inferred at that point governs the type of alloca
23:24:23 <haasn> it's a bit like prolog in that sense
23:24:29 <johnw> it's just weird that when I use malloc, I never have to specify the saze :)
23:24:39 <doesthiswork> is it alright to bother you folk with lambda calculus questions?
23:24:48 <johnw> we have lambda calculus questions!
23:24:51 <johnw> love!
23:24:53 <johnw> man, I really can't type
23:25:08 <haasn> doesthiswork: depends on who you ask, I guess
23:25:26 <doesthiswork> So the y combinator gives you the fixed point of any function in untyped lambda calc
23:25:58 <doesthiswork> but no matter whether it diverges or converges it doesn't terminate
23:26:16 * hackagebot henet 1.3.8.1 - Bindings and high level interface for to ENet v1.3.8  http://hackage.haskell.org/package/henet-1.3.8.1 (JohnEricson)
23:26:17 <doesthiswork> What is it used for?
23:26:25 <johnw> you can use it for a few things
23:26:33 <johnw> one popular use is to make recursive lambdas in Haskell
23:26:43 <haasn> Aorion: to provide another example; if you wanted to specify that ‘read returns an integer’ you could do:  map (\x -> read x :: Integer) ["5", "3"]
23:27:00 <johnw> fix $ \f x -> if x > 0 then f (x - 1) else x
23:27:12 <haasn> what do you mean, it doesn't terminate?
23:27:33 <johnw> termination is governed by what 'g' does with its argument in the y combinator
23:27:40 <johnw> Y g = g (Y g)
23:27:52 <johnw> > fix (const 10)
23:27:53 <lambdabot>   10
23:27:53 <haasn> > fix (const 0) 1
23:27:54 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
23:27:54 <lambdabot>    arising f...
23:27:55 <haasn> oh
23:27:58 <johnw> where fix f = f (fix f)
23:28:00 <haasn> right
23:28:05 <BMeph> johnw: It depends on what the menaing of the word "it" is.... ;þ
23:28:15 <BMeph> Er, *meaning
23:28:46 <johnw> doesthiswork: so, the least fixed point for a given function may not be non-termination, it depends on the definition of that function
23:29:06 <Aorion> is there an easy way to dump the result of an operation to terminal, like what ghci does?
23:29:07 <johnw> in Haskell this works because we have lazy evaluation
23:29:27 <doesthiswork> do you have to mix applicative and normal order in to get it to terminate?
23:29:27 <johnw> g (g (g (Y g))) may never evaluate the g (g (Y g)) part
23:29:33 <haasn> Aorion: you mean in a compiled program?
23:29:38 <Aorion> yes
23:29:49 <haasn> Aorion: ‘print’ is essentially what GHCi is doing
23:29:50 <mauke> print?
23:30:07 <haasn> eg. main = print $ map (read :: String -> Integer) ["3", "5"]
23:30:13 <Aorion> that worked
23:31:24 <doesthiswork> johnw: Y comb of (\x. x true false) doesn't seem to terminatet
23:31:49 <doesthiswork> althought it has two fixed points (true and false)
23:31:50 <johnw> that's because x in that case is a function
23:32:09 <haasn> doesthiswork: that's basically like writing let x = x true false
23:32:10 <johnw> > fix $ \f -> f True False
23:32:11 <lambdabot>   Occurs check: cannot construct the infinite type:
23:32:11 <lambdabot>    t0 = GHC.Types.Bool ->...
23:32:24 <haasn> not only does it not type check, but even if it did, it would diverge
23:32:33 <haasn> like let x = x
23:32:33 <johnw> doesthiswork: try this: (\x. if x then true else false)
23:32:38 <johnw> that has two fixed points
23:33:33 <johnw> > fix $ \f x -> if x then True else False
23:33:34 <lambdabot>   <Bool -> Bool>
23:33:44 <johnw> actually, it would have to be (\x y. if y then true else false)
23:33:55 <johnw> x represents the recursion
23:34:13 <haasn> depends on what the actual goal here is
23:34:17 <johnw> true
23:35:20 <lightquake> what's the best way to get some JSON from a URL?
23:35:29 <johnw> lightquake: using aeson and http-conduit
23:35:35 <doesthiswork> I'm trying to understand how the Y combindator  λf.(λx.f (x x)) (λx.f (x x)) is supposed to terminate
23:36:04 <johnw> doesthiswork: if f is strict in its argument, I think it never will
23:36:16 <johnw> if it is not strict in its argument, then it's easy
23:36:16 * hackagebot helm 0.4 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.4 (ZackCorr)
23:36:41 <haasn> johnw: seems right
23:36:48 <doesthiswork> ok so this is something that depends on evaluation strategy?
23:36:58 <haasn> > fix $ \x -> x `seq` ()
23:37:02 <lambdabot>   mueval-core: Time limit exceeded
23:37:19 <haasn> (of course, the nice thing here is that we don't know if it actually diverges or if lambdabot is just broken as usual)
23:38:26 <johnw> "Even though we often refer to Y as "the" Y combinator, in actual fact there are an infinite number of Y combinators. We will only be concerned with two of these, one lazy and one strict. We need two Y combinators because the Y combinator we define for lazy languages will not work for strict languages. The lazy Y combinator is often referred to as the normal-order Y combinator and the strict one is referred to as the applicative-order Y
23:38:27 <johnw> combinator. Basically, normal-order is another way of saying "lazy" and applicative-order is another way of saying "strict"."
23:38:29 <johnw> that's from http://mvanier.livejournal.com/2897.html
23:39:26 <doesthiswork> thanks, i was unaware that more than one was needed
23:39:45 <johnw> see also http://mvanier.livejournal.com/2700.html
23:40:50 <johnw> also interesting: http://blog.ezyang.com/2012/09/y-combinator-and-strict-positivity/
23:41:01 <johnw> that shows an attempt to implement the traditional Y combinator in Haskell
23:41:14 <Saizan> i think most of the uses of "Y combinator" should rather be "fixpoint combinator" in that quote
23:41:48 <BMeph> Yeah, Ed's a good read. He also has the name I'm most envious of, out of all the Haskell regulars. :)
23:45:09 <Gracenotes> let L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)) in L L L L L L L L L L L L L L L L L L L L L L L L L L
23:46:31 <zRecursive> why does `runCommand $ "tail foo.txt"` need pressing "Enter" to quit ?
23:51:17 * hackagebot henet 1.3.8.1.1 - Bindings and high level interface for to ENet v1.3.8  http://hackage.haskell.org/package/henet-1.3.8.1.1 (JohnEricson)
