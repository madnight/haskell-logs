00:00:29 <Gracenotes> it is a bit.. pie-in-the-sky, so to speak
00:00:34 <arkeet> the point is, don't use an if/then/else to test if something matches a pattern that you want to extract some data first, and then extract it later.
00:00:36 <Gracenotes> is that even a phrase
00:00:39 <arkeet> just do it all in one go with a pattern match.
00:00:47 <arkeet> it is, but I don't think it's applicable here.
00:01:02 <Gracenotes> okay, let's say castle-in-the-sky.
00:01:07 <Gracenotes> it's in the sky.
00:01:53 <CaptainK> ya that makes sense
00:01:56 <Gracenotes> I need to learn more interesting idioms.
00:02:06 <arkeet> and I think it misses an important reason for avoiding this usage of bools, too.
00:02:38 <arkeet> which is that pattern matching is more local.
00:02:46 <arkeet> which means
00:02:50 <arkeet> uh
00:03:10 <Gracenotes> somewhat related: http://www.haskell.org/haskellwiki/Avoiding_partial_functions
00:03:15 <arkeet> you can't accidentally forget to change part of it and end up with a crashing program.
00:03:18 <arkeet> quite related.
00:03:24 <Gracenotes> the constraints are in the compiler's head, not yours.
00:03:31 <arkeet> yes
00:03:52 <augur_> Gracenotes: i avoid partial functions by using -Wall to complain about them :)
00:04:03 <augur_> or better yet, by using Agda!
00:04:08 <arkeet> -Wall complains about head?
00:04:45 <arkeet> it'll complain about ones you wrote, but there are unfortunately a bunch already in the Prelude and elsewhere.
00:04:54 <Pseudonym> Use a logic language. Boolean and partial function problems solved!
00:05:08 <arkeet> many other problems introduced!
00:05:09 <augur_> arkeet: right, i mean for my things
00:05:32 * arkeet still hasn't ever used a logic language
00:08:06 <arkeet> I guess the point the article makes is that bools contain less information than what you're trying to get by using them anyway.
00:09:09 <amosr> { a = b } + { a <> b }, not () + () !
00:09:20 <arkeet> > () + ()
00:09:21 <lambdabot>   No instance for (GHC.Num.Num ()) arising from a use of `GHC.Num.+'
00:09:21 <lambdabot>  Possibl...
00:09:31 <arkeet> oh well.
00:09:43 <Gracenotes>    ()
00:09:47 <amosr> is there a coq bot? :-)
00:10:25 <arkeet> thanks Gracenotes.
00:10:48 <Gracenotes> np
00:21:45 <yitz> amosr: how about an idris bot?
00:22:00 <amosr> I haven't had much of a look at idris yet
00:46:53 <mikeplus64> anyone know if repa works on windows? i don't have a place to test it atm
00:47:15 <mikeplus64> i don't see why it wouldn't
00:47:20 <amosr> hmm, I've never tried it on windows
00:47:38 <amosr> it doesn't do anything particularly crazy
00:48:47 <amosr> does threading stuff work on windows? if so, repa probably does
00:50:29 <mikeplus64> i thinnk it works, but might be kinda slow
00:51:19 <mikeplus64> but of course there are sequential and parallel functions provided by repa
00:53:04 <Lethalman> uh, what about TSX intel hardware option and haskell stm?
00:53:09 <Lethalman> can't find anything
00:53:36 * hackagebot MFlow 0.3.0.2 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.3.0.2 (AlbertoCorona)
00:53:59 <amosr> the gang stuff is kinda slow in osx too (and presumably linux?) but if you have large enough work it's worth it
00:54:41 <Gracenotes> STM in the general case is a lot lot harder than STM for Haskell
00:55:26 <Gracenotes> cuz of arbitrary mutation and stuff
00:55:55 <Gracenotes> s/STM/TM/
00:57:26 <Gracenotes> er, but it could help... would be interesting, if it existed (?)
01:08:22 <yitz> threading works fine on windows. haven't tried repa.
01:18:02 <kamatsu> I don't see why repa would be borked on windows.
01:19:55 <mikeplus64> it's weird that repa has no mapM[_]/forM[_]
01:20:06 <mikeplus64> easy to implement, but still weird
01:24:42 <Nazeer> could you please anyone tell me why it doesnt work? [zip a b | a<-[1], b<-["first"]]
01:24:59 <simukis_> > [zip a b | a<-[1], b<-["first"]]
01:25:00 <lambdabot>   No instance for (GHC.Show.Show a0)
01:25:00 <lambdabot>    arising from a use of `M1322893870.sh...
01:25:26 <Nazeer> yes. but when i do zip [1] ["first"] it works as expected
01:25:48 <thorsten`> but a <- [1] causes a to be 1 and not [1]
01:26:13 <Bor0> > [zip a b | a <- [[1]], b<-[["first"]]]
01:26:14 <lambdabot>   [[(1,"first")]]
01:26:14 <thorsten`> > [zip a b | a <- [[1]] , b <- ["first"]]
01:26:15 <lambdabot>   [[(1,'f')]]
01:29:46 <Nazeer> thanks Bor0, thorsten, but bit confused. i will read it and come back
01:30:17 <thorsten`> Nazeer: it really depends on, what you want your code to do
01:31:16 <bscarlet> Nazeer: zip zips lists. Inside the list comprehension, a and b are not lists. They are elements from the lists.
01:33:05 <thorsten`> well in the given example b<-["first"], b both is an element and a list itself.
01:33:17 <Nazeer> Thanks bscarlet. now i got it
01:34:28 <augur_> thorsten`: altenkirch?
01:35:07 <thorsten`> augur_: i don't get your question :), is altenkirch a last name or a location?
01:35:31 <augur_> thats a no then!
01:35:49 <augur_> there's a famous thorsten (well famous in the FP/TT communities)
01:35:57 <augur_> thorsten altenkirch
01:36:21 <augur_> every once in a while it turns out im right when i ask these questions. lol
01:37:13 <thorsten`> ah ok :D. TT = Type Theory? and FP=functional programming?
01:38:06 <augur_> yep
01:40:02 <quicksilver> chrisdone++ # hpaste history safe back to 2008
01:42:17 <Ghoul_> is there a string type in a package somewhere that works like c# and java strings
01:42:34 <Ghoul_> that is, internally is stored as a hash rather than the physical string for fast hashmaps and comparison
01:46:50 <quicksilver> Ghoul_: ?
01:47:01 <ocharles> dmwit: y u make universe package constraints so restrictive?!
01:47:08 <quicksilver> Ghoul_: I'm pretty sure that C# and java strings are *also* stored as physical strings
01:47:14 <quicksilver> but probably you mean string interning?
01:47:33 <Ghoul_> well, java gets 4ns hash times so the hashes are carried along with the strings
01:48:03 <quicksilver> it's only compile-time constants that are interned in java
01:48:06 <quicksilver> I don't know much about C#
01:48:12 <Ghoul_> ah okay
01:48:44 <quicksilver> anyhow - http://hackage.haskell.org/package/intern
01:48:53 <quicksilver> I've never used that package myself
01:49:14 <quicksilver> string interning is a microoptimization, I wouldn't worry about it unless you know it will help your program.
01:52:10 <Ghoul_> thanks
01:52:30 <Breadmonster> @src reverse
01:52:30 <lambdabot> reverse = foldl (flip (:)) []
01:52:43 <Breadmonster> Why doesn't it use foldl' instead of foldl?
01:53:21 <anon123> http://lpaste.net/90779 Does anyone know why this doesn't work and/or how I can shove a list in there?
01:53:36 <Gracenotes> plus, if you have lots and lots of a few strings, just convert the string to a nullary ADT constructor; no space at all :)
01:53:50 <quicksilver> anon123: there is an extension called FlexibleInstances
01:53:50 <Gracenotes> Breadmonster: because (:) is a constructor; (+) is not
01:54:10 <quicksilver> anon123: the error message you got should have suggested that extension
01:54:17 <Breadmonster> Gracenotes: isn't (:) a regular function?
01:54:19 <Gracenotes> seq evaluates the thing on the left enough to figure out what its constructor is, so it's not necessary.
01:54:27 <quicksilver> although even when it's working, the two instances you have there still overlap.
01:54:41 <anon123> quicksilver: it suggested it, but is there a reason it is disabled?
01:55:12 <Breadmonster> Gracenotes: So no performance penalty for using foldl in this case?
01:55:16 <anon123> quicksilver: what do you mean by 'they overlap'
01:55:19 <quicksilver> anon123: well, it's disabled because it's non-standard.
01:55:28 <quicksilver> as to why it's non-standard - mostly historical reasons.
01:55:31 <Gracenotes> You can provide arguments to a function, and you can provide arguments to a constructor, but these behave pretty differently when Haskell is actually getting evaluated.
01:55:46 <Gracenotes> Breadmonster: there is a performance penalty for using foldl' here, because it's a totally unnecessary seq
01:55:58 <quicksilver> people initially had a narrow view of what would be the natural way to write instances
01:56:38 <quicksilver> anon123: and, they overlap because given the type "SomeData [Int]", say, that matches both "SomeData a" and "SomeData [a]"
01:56:43 <anon123> quicksilver: so this falls under the category of "things that simply have not yet made it into standard haskell"
01:56:48 <quicksilver> yes,
01:56:55 <Breadmonster> Gracenotes: mind if I PM? I had a question that's not exactly related to Haskell.
01:57:08 <anon123> quicksilver: Oooooooh
01:57:18 <Gracenotes> I would recommend asking any question in its appropriate channel
01:57:25 <Gracenotes> tbh
01:57:33 <amosr> performance penalty for unnecessary seq? hmm
01:57:44 <quicksilver> anon123: here is the page where the proposal for adding it to a future haskell standard is: http://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
01:58:04 <Gracenotes> amosr: who knows, it might be optimized out, if it's inlined aggressively enough.
01:58:19 <amosr> I'd like to try that and see what core it produces. but I'm too lazy
01:58:26 <quicksilver> Gracenotes: or just if the strictness analyzer can see it's not needed
01:58:43 <quicksilver> but in principle one should avoid un-needed seqs, they certainly might be slowing things down.
01:59:54 <Gracenotes> or ask a question here, it's not that busy..
02:00:46 <alpounet> amosr, it can force more work to be done than necessary
02:01:32 <amosr> alpounet: I meant in the foldl (flip (:)) [] case
02:03:24 <dmj> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
02:03:24 <dmj>  
02:03:24 <dmj>  
02:03:30 <dmj> Any idea where that article went?
02:04:33 <dmj> Grabmuller and Piponi's blog post were very good, was wondering if there is more documentation on monad transformers that is recommended
02:14:38 <quicksilver> @ask Cale is there a new location for http://cale.yi.org/index.php/How_To_Use_Monad_Transformers ?
02:14:38 <lambdabot> Consider it noted.
02:14:52 <quicksilver> dmj: I don't know but Cale is still active in this channel. Let's ask him.
02:15:46 <quicksilver> amosr: well arguably it's still forcing the flip? but if the flip gets totally inlined anyway then seq ought to be able to detect that it's working in a constructor, yes
02:16:20 <Nazeer> how it evaluates the lazyiness in [(a,b) | b<-[1..10],a<-[1..b]]
02:16:32 <Nazeer> how it evaluates the lazyiness in [(a,b) | b<-[1..10],a<-[1..a]]
02:16:43 <quicksilver> I'm not really sure how to answer that question, Nazeer
02:16:53 <Nazeer> how it evaluates the lazyiness in [(a,b) | b<-[1..10],a<-[1..b]] this is correct
02:17:01 <quicksilver> the list elements are generated lazily on demand
02:17:09 <quicksilver> a complete picture would be quite time-consuming to draw
02:17:15 <quicksilver> (Although it would be quite pretty)
02:18:46 <Gracenotes> if you say print out the resulting list, then for every element assigned to b, a list will be constructed and each element assigned to a. repeat 10 times.
02:18:48 <Nazeer> quicksilver: thanks. i just wanted to visualize it
02:19:21 <dmj> quicksilver: thanks for notifying him
02:19:38 <dmj> help
02:19:41 <Gracenotes> but the amount of work done in calculating the final list is no more than the portion of the final list that's examined.
02:19:45 <quicksilver> Nazeer: well the list [1..10] is only constructed once
02:19:54 <quicksilver> but equally it's only constructed gradually
02:20:06 <quicksilver> once you've got as far as (3,2), say
02:20:16 <quicksilver> the list [1..10] looks like 1:2:3:<thunk>
02:20:36 <dmj> > take 2 [1,2,3,undefined,undefined]
02:20:38 <lambdabot>   [1,2]
02:20:45 <quicksilver> the lists [1..1] and [1..2] which were constructed for earlier elements are no longer referenced and have probably been GCed
02:20:45 <dmj> see lazy
02:20:52 <Gracenotes> Things that go <thunk> in the night
02:20:57 <dmj> :)
02:21:02 <dmj> Gracenotes: lol
02:21:10 <quicksilver> it would be clearer with a drawing but I think it would take me 15 minutes to draw and I don't have time :)
02:21:39 <Nazeer> quicksilve: thanks. Let me read your msgs one more time
02:23:00 <Nazeer> Wow.. quicksilver: Got it now!!
02:23:10 <dmj> Nazeer: one thing that might help you, at least it did for me
02:23:25 <Nazeer> pls go ahead dmj
02:23:27 <dmj> in your ghci session, do let f = map (*1) [1..10]
02:23:44 <dmj> then do :sprint f
02:23:49 <dmj> you should see f = _
02:23:55 <dmj> this is an unevaluated expression
02:24:01 <dmj> then call "length f"
02:24:11 <Nazeer> yes dmj, i see it
02:24:14 <dmj> and :sprint f
02:24:16 <dmj> again
02:24:25 <dmj> should now see "f = [_,_,_,_,_,_,_,_,_,_]"
02:24:34 <dmj> notice how length does not require unboxing
02:25:00 <dmj> then finally "sum f"
02:25:07 <dmj> f = [1,2,3,4,5,6,7,8,9,10]
02:25:12 <dmj> should evaluate everything
02:25:19 <dmj> straight from simon marlow's new book :)
02:25:45 <quicksilver> dmj: unboxing is not the word you wanted there. However your example is great.
02:26:24 <Nazeer> thats the way i want to visualize it. your help is useful dmj
02:26:53 <quicksilver> I haven't played with :sprint, I'm still on ghc 6.12 :-(
02:27:20 <dmj> quicksilver: what should I have used instead of "unbox"? Maybe I'm misunderstanding the concept
02:28:03 <quicksilver> dmj: I would say "notice how length does not force the individual values"
02:28:18 <quicksilver> although 'evaluate' would be another good word as well as force
02:28:34 <quicksilver> even when evaluated they are still boxed, you see
02:29:08 <dmj> quicksilver: Ah I see, so when does unboxing occur (if it does) in the above?
02:29:59 <dmj> quicksilver: and more importantly, why are you still on GHC 6.12
02:29:59 <dmj>  
02:30:07 <dmj> ;)
02:30:24 <Nazeer> in this context, unboxing means, openings up the list? or may be it is too early to understand the boxing or unboxing for me?
02:30:46 <quicksilver> Nazeer: well as I said, unboxing is the wrong word
02:31:32 <Nazeer> oh..ya
02:31:34 <quicksilver> dmj: nothing in that code would cause unboxing. unboxing happens when values are passed to functions which expect unboxed parameters, or when stored in special unboxed data structures.
02:31:36 <alpounet> unboxing is used for something else, here "evaluate" and "force" fit and are the common words to describe this
02:32:12 <quicksilver> dmj: normal haskell values in GHC are always boxed even when fully evaluated
02:34:15 <dmj> quicksilver, 2 questions to follow-up then, are data declarations with bang patterns unboxed? And does newtype avoid an "extra" layer of boxing?
02:34:37 <quicksilver> newtype avoids an extra layer, but doesn't reduce the layers already there.
02:34:51 <plhk> unboxing means using values native to hardware, right?
02:35:02 <quicksilver> data declarations with bang patterns are not unboxed by default
02:35:06 <quicksilver> merely strict
02:35:15 <quicksilver> although there is a compiler flag -funbox-strict-fields
02:35:25 <quicksilver> and there is a pragma {-# UNPACK #-}
02:36:07 <dmj> quicksiler: how does unboxing relate to thunks? sry for all the ?'s
02:36:21 <HugoDaniel> hello
02:36:39 * shachaf notes that {-# UNPACK #-} isn't respected with optimizations off, even if explicitly specified.
02:36:54 <alpounet> dmj, expect an article soon about these matters (laziness, strictness, unpacking, etc)
02:37:09 <quicksilver> dmj: if a function takes unboxed parameters then it cannot be passed a thunk
02:37:13 <HugoDaniel> ive been reading the parallel programming book, and now i feel that i should use lazy eval everytime everywhere :/
02:37:20 <quicksilver> dmj: so the calling code must reduce the thunk before passing it in.
02:37:24 <alpounet> shachaf, uh, does GHC warn about the pragma not being used?
02:37:28 <dmj> alpounet: I am definitely looking forward to that
02:37:43 <shachaf> alpounet: No, it'll just compile the file and ignore it.
02:37:44 <quicksilver> dmj: dually, a data structure with unboxed fields cannot store a thunk, so the thunk must be reduced before being stored
02:37:48 <quicksilver> dmj: make sense?
02:38:00 <shachaf> alpounet: And if you compile a library without optimizations, then anything that uses that library has to be binary-compatible, of course.
02:38:02 <Xunie> Now hang on. What does the 'n:' mean in the following code snippet? http://lpaste.net/1925226537905291264
02:38:09 <anon123> quicksilver: any danger of also using MultiParamTypeClasses ?
02:38:11 <chreekat> I'm refactoring some template haskell, and i'd like to check that two methods (old and new) of type ([String] -> Q [Dec]) return the same value given the same input. This seems like a nice candidate for quickcheck, but I'm having trouble understanding if/how to unwrap something in the Q monad
02:38:31 <quicksilver> In some ways I think functions with unboxed parameters are the more fundamental notion. Unboxed data structures are just a tweak.
02:38:44 <shachaf> alpounet: I discovered this when rwbarton tried an evil trick with declaring an ADT identical to Data.Map and unsafeCoercing back and forth.
02:38:46 <quicksilver> anon123: nope, MPTC is a widely used and well-regarded extension.
02:38:56 <anon123> quicksilver: excellent!
02:39:05 <HugoDaniel> thunks to rule the world and what not... because they "help separate the algorithm from parallelism"
02:39:17 <alpounet> shachaf, uh. I think a warning would be nice in that case
02:39:59 <bscarlet> Xunie: it means stick an n on the head of the list
02:40:08 <bscarlet> > 1:[2,3]
02:40:09 <lambdabot>   [1,2,3]
02:40:11 <Xunie> Oh yeah. Fail.
02:40:12 <shachaf> alpounet: You should double-check I'm not making things up before opening a ticket about it or anything like that.
02:40:16 <Xunie> Sorry 'bout that.
02:41:12 <kamatsu> hm, seems like TransformComps doesn't interact properly with RebindableSyntax
02:41:24 <kamatsu> i was hoping to use it to generate an AST I could compile, but alas
02:41:47 <alpounet> shachaf, yeah, let me do just that. When was it? I mean, was it with the latest GHC?
02:42:15 <shachaf> I don't remember.
02:42:18 <shachaf> Sometime last year?
02:43:12 <dmj> quicksilver: Yes, a fully reduced thunk is an unboxed type. And fully reduced meaning: normal form?
02:43:25 <quicksilver> no, still wrong
02:43:27 <quicksilver> sorry :)
02:43:34 <quicksilver> a fully reduced thunk is still boxed
02:43:47 <quicksilver> it' just that if you're going to put it into an unboxed parameter or field, you better reduce it first.
02:43:55 <quicksilver> yes, fully reduced = NF
02:44:17 <quicksilver> although the only types which can be unboxed are simple types anyway (Int/Char/etc)
02:44:18 <shachaf> You don't have to fully reduce it, really, just to WHNF.
02:44:33 <shachaf> Hmm, is that necessarily true?
02:44:36 <quicksilver> no.
02:44:40 * shachaf might be mixing up two different things here.
02:44:48 <quicksilver> you can imagine unboxing Complex
02:44:58 <quicksilver> and if you do imagine that, you'd need it in NF not just WHNF
02:45:02 <dmj> quicksilver: "dmj: dually, a data structure with unboxed fields cannot store a
02:45:03 <dmj>               thunk, so the thunk must be reduced before being stored"
02:45:03 <dmj>  
02:45:17 <dmj> quicksilver: leads me to believe that "fully reduced" == unboxed
02:45:21 <quicksilver> no idea if any of our curent code does unbox Complex mind you.
02:45:33 <quicksilver> dmj: understandable.
02:46:15 <quicksilver> dmj: I'm not quite sure how to make it more precise, mind you :)
02:46:28 <quicksilver> The Int '1', in haskell (1 :: Int) is still a boxed value
02:46:42 <dmj> quicksilver: yes
02:46:50 <quicksilver> it consists of a pointer, which points to the actual machine word containing the 1.
02:47:04 <dmj> yes
02:47:08 <quicksilver> the GHC notation for that unboxed word is 1#
02:47:16 <quicksilver> so you reduce your thunk to 1
02:47:24 <quicksilver> but then you pass the actual underlying 1#
02:47:33 <quicksilver> ... if you're passing to a function taking unboxed parameters.
02:47:50 <quicksilver> s/in haskell/in GHC/
02:48:15 <dmj> what do functions that take unboxed parameters look like?
02:48:42 <quicksilver> foo :: Int# -> Int# -> Int#
02:49:00 <quicksilver> you don't normally use them directly
02:49:12 <quicksilver> unless you are working on GHC or a very low level GHC-specific library
02:49:29 <quicksilver> but all the basic arithmetic functions have unboxed versions
02:49:34 <quicksilver> and the compiler uses them when it can
02:49:46 <quicksilver> so the optimiser tries to unbox simple arithmetic
02:49:58 <circle> is there a prelude function to tell me which index a certain object is within a list?
02:50:10 <quicksilver> @type find
02:50:11 <lambdabot> (a -> Bool) -> [a] -> Maybe a
02:50:15 <quicksilver> @type findIndex
02:50:16 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
02:50:24 <quicksilver> circle: that one
02:50:28 <gour> morning
02:50:35 <dmj> quicksilver: so if I wanted to sum the first 3 billion integers, would GHC unbox them?
02:50:48 <quicksilver> > findIndex (=='l') "hello"
02:50:49 <lambdabot>   Just 2
02:50:50 <gour> is Qt bindings generator for haskell gsoc project supposed to cover qt5?
02:50:56 <alpounet> shachaf, it seems the problem is still there
02:50:59 <quicksilver> dmj: yes. I imagine so.
02:51:05 <circle> can 'Just 2' be used as an int though?
02:51:14 <quicksilver> circle: no, but you can unpack it.
02:51:18 <circle> how would I do that?
02:51:23 <quicksilver> circle: the reason for that is so that Nothing can denote it's not that
02:51:49 <quicksilver> > case findIndex (=='l') "hello" of Just i -> "I found it at index"++(show i); Nothing -> "I did not find it"
02:51:50 <lambdabot>   "I found it at index2"
02:53:08 <shachaf> I wonder how much better a monomorphized unpacked Complex would perform...
02:53:52 <quicksilver> shachaf: Vector has an Unbox instance for Complex
02:54:02 <quicksilver> shachaf: of course, vector's unboxing is not exactly the same thing as GHC's unboxing
02:54:13 <quicksilver> but well, it is the same thing, just a different framework
02:54:27 <shachaf> It's quite different, in fact.
02:54:32 * quicksilver nods
02:54:33 <merijn> circle: If you have a Maybe, you usually want to use pattern matching/case-of to get something out, other options are things like
02:54:36 <merijn> :t maybe
02:54:36 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:54:41 <merijn> :t fromMaybe
02:54:42 <lambdabot> a -> Maybe a -> a
02:54:50 <merijn> Or just fmap
02:55:08 <alpounet> shachaf, http://lpaste.net/90783 -- 7.6.3 here
02:55:30 <shachaf> alpounet: Sounds right.
02:55:45 <quicksilver> shachaf: you could presumably write GHC code to unbox Complex numbers into vector types on recent processors with the new GHC support for those vector instructions.
02:56:03 <alpounet> worth filing a ticket I guess
02:56:25 <shachaf> alpounet: This behavior almost seems like it happens on purpose.
02:56:33 <quicksilver> shachaf: it's a pretty obscure use case except for those people who regularly write programs using Complex. They think it's the most important use case :)
02:58:54 <alpounet> shachaf, i meant about the lack of a warning
02:59:24 <alpounet> (unless not displaying a warning is what you mean by "it")
02:59:35 <shachaf> alpounet: I mean, it sounds like there would be code to handle it, so maybe it's a case that was considered.
02:59:39 <shachaf> Maybe not. I don't know.
03:18:49 <mikeplus64> http://quasimal.com/out.ogv
03:19:11 <mikeplus64> video of me playing my unpolished 3d snake game (ofc, it's in haskell :))
03:21:56 <amosr> mikeplus64: I am very confused
03:22:47 <BoR0> me too
03:23:28 <acube> haskell removes "categories of bugs" ... nice pun!
03:24:02 <simukis_> I like the idea of that confusing snake
03:24:08 <HugoDaniel> :)
03:24:47 <mikeplus64> i think the level is too big, it's too hard to see where you are/where other stuff is
03:24:52 <HugoDaniel> anyone here uses other compiler besides the ghc ?
03:26:01 <HugoDaniel> i wonder how many of the haskell platform libs could compile in anything other than ghcc
03:26:04 <HugoDaniel> ghc
03:27:56 <yitz> in a cabal file, how do i specify a flag for a package in build-depends?
03:28:58 <circle> regarding findIndex, I actually need the index in Int form rather than 'Just Int'
03:28:59 <circle> I'
03:29:03 <circle> I'm using the Int in an expression
03:29:05 <circle> what should I do
03:29:19 <alpounet> yitz, depending on a package if some flag is set?
03:29:21 <HugoDaniel> i would love to have a haskell compiler that could bootstrap itself from thin air (and a raw basic)
03:29:30 <quicksilver> circle: I did make some effort to answer that question
03:29:37 <quicksilver> circle: I showed you how to use 'case'
03:29:38 <yitz> circle: use maybe or fromMaybe, and specify what to do if the value is Nothing
03:29:46 <circle> I know all about case and stuff
03:29:47 <quicksilver> somebody else suggested maybe or fromMaybe
03:29:50 <circle> I'm using this in an expression
03:29:53 <circle> deep in an expression
03:29:56 <quicksilver> you can use case in an expression
03:29:56 <circle> there can be no pattern matching
03:29:58 <circle> or cases
03:29:59 <quicksilver> as deep as you like
03:30:03 <quicksilver> you can pattern match ANYWHERE
03:30:42 <merijn> Also, there's fromMaybe/maybe if you don't want to pattern match
03:30:43 <alpounet> yitz, if that's it, just do:  if flag(foo)\n   build-depends:   some-optional-dep
03:30:43 <yitz> circle: it doesn't matter where in an expression. the whole point of the Maybe type is that it might be Nothing, and the type makes sure that you won't forget to handle that case too.
03:30:52 <quicksilver> he's gone, yitz, merijn
03:31:27 <yitz> alpounet: no. i depend on the package unconditionally. when i build that package, i need to set one of its flags to a specific value.
03:32:06 <alpounet> well you can't do that in your cabal file afaik
03:32:13 <yitz> hi again circle :)
03:32:19 <yitz> circle: it doesn't matter where in an expression. the whole point of the Maybe type is that it might be Nothing, and the type makes sure that you won't forget to handle that case too.
03:32:36 <circle> in this case, I know it won't be nothing
03:32:41 <yitz> circle: you can do either what quicksilver suggested or what i suggested anywhere in an expression
03:32:41 <benmachine> circle: maybe you could show us some code, and we can show you how to pattern match in it?
03:32:44 <circle> I'm just finding the index of the maximum element of a list
03:32:57 <HugoDaniel> circle: try something like this: (\a b -> (\(Just i) -> i) $ findIndex a b)
03:32:58 <HugoDaniel> :/
03:32:59 <benmachine> circle: interesting
03:33:10 <HugoDaniel> circle use sets
03:33:12 <benmachine> HugoDaniel: no, that's rubbish
03:33:15 <HugoDaniel> :D
03:33:20 <acube> circle: What is when the list is empty?
03:33:40 <merijn> circle: You can just use fromMaybe
03:33:46 <HugoDaniel> yeah
03:33:52 <quicksilver> if you know it wont' be nothing you can use fromJust
03:34:05 <benmachine> fromMaybe (error "descriptive error message that is way better than the fromJust one")
03:34:09 <HugoDaniel> circle: whenever you have a "Maybe Int" you can think of it as "I need a default value for the case that this breaks"
03:34:17 <quicksilver> or what benmachine said
03:34:33 <acube> Still the question, what happens when the list is empty?
03:34:34 <HugoDaniel> circle: so, say if the index doesn't exist you want to return 0, you can use "fromMaybe 0 $ findIndex ...."
03:34:36 <benmachine> circle: alternatively, how about this
03:34:48 <yitz> alpounet: that would be very bad news. how do i build this app then? if i don't set that flag, cabal gets very lost and the dep versions go all wrong.
03:34:54 <acube> If you know it can't be empty, pattern match on the list like (xs~
03:35:04 <benmachine> > maximumBy snd . zip [0 ..] $ "syzygy"
03:35:05 <lambdabot>   Couldn't match type `GHC.Types.Char'
03:35:05 <lambdabot>                with `(a0, GHC.Types.Ch...
03:35:24 <acube> like l@(x:xs), and then use fromMaybe x (maximum (x:xs)) ?
03:35:25 <benmachine> huh
03:35:26 * benmachine fiddles
03:35:34 <acube> @ty maximum
03:35:35 <lambdabot> Ord a => [a] -> a
03:35:40 <acube> > maximum []
03:35:41 <lambdabot>   *Exception: Prelude.maximum: empty list
03:35:43 <benmachine> oh, silly
03:35:48 <HugoDaniel> circle, but really if you are doing something serious and this is a frequent operation then try another datatype, list is not the best
03:35:49 <benmachine> > maximumBy (comparing snd) . zip [0 ..] $ "syzygy"
03:35:50 <lambdabot>   (2,'z')
03:36:03 <acube> Maximum doesn't even retrun a Maybe @ circle
03:36:11 <acube> return*
03:36:13 <benmachine> acube: it really ought to though :P
03:36:14 <yitz> alpounet: theoretically i could pre-install that package. but it itself has tons of deps. the cabal file controls that. if i have to install it manually, i'll need to manually discover a whole build plan for it.
03:36:16 <HugoDaniel> :/
03:36:20 <merijn> yitz: The cabal manual explicitly states that uses flags to control which behaviour is exposed is fundamentally broken
03:36:37 <merijn> yitz: Because how does cabal know which options where set when a package was installed
03:37:12 <benmachine> basically, flags aren't meant to be part of your API
03:37:13 <yitz> merijn: it's not doing that. just controlling whether to use older or newer versions of certain dependencies, and adjusting the code to match their apis.
03:37:22 <benmachine> they're meant to be different ways of building the same thing
03:37:36 <alpounet> yitz, can't you use macros?
03:37:39 <yitz> benmachine: it's not part of the apis. it's doing exactly what you said.
03:37:42 <alpounet> MIN_VERSION_foo
03:37:43 <alpounet> etc
03:37:52 <yitz> alpounet: in the cabal file?
03:37:53 <alpounet> in the haskell code itself
03:37:59 <benmachine> yitz: so, why do you need to set the flags?
03:38:36 <benmachine> yitz: oh right, caught up
03:38:45 <yitz> benmachine: dep A needs me to set the flag so that it will be able to use an older version of dep B, which i need for other reasons
03:39:11 <benmachine> yitz: if you say "I need an older version of dep B", shouldn't cabal set that flag on dep A automatically?
03:39:35 <yitz> benmachine: and both dep A and dep B have a whole boatload of other direct and indirect dependencies that would take me hours to work out manually without cabal
03:40:08 <circle> if I have already made a module called Data, how do I import haskell modules like Haskell's Data?
03:40:16 <yitz> benmachine: no, unfortunately. the cabal docs describe the exact algorithm cabal uses for setting the flags automatically. that algorithm does the wrong thing in this case.
03:40:22 <benmachine> circle: you mean Data.Data?
03:40:31 <circle> indeed
03:40:33 <mauke> circle: I don't think there's a standard Data module
03:40:33 <yitz> benmachine: so i want to set the flag manually. but it looks like i can't do that either. :(
03:40:37 <benmachine> circle: don't have a module called that :P
03:40:51 <benmachine> yitz: cabal install A -fflag?
03:40:54 <circle> I mean Data.ZX
03:41:12 <quicksilver> it doesn't matter
03:41:17 <DarkFox> Has anyone made Int128? or should one just use Integer for Ipv6 ?
03:41:28 <alpounet> benmachine, A is a dep of his project and he would like to avoid having to preinstall dep A just  to build it with that flag
03:41:33 <quicksilver> I mean, if you have a module called Data.Foo that won't affect Data.List, circle
03:41:38 <yitz> benmachine: right, but then it doesn't look into my cabal file for the deps of A, pulls in all the wrong versions, and makes it impossible for me to install my own package afterwards.
03:41:44 <quicksilver> it would only matter if you used exactly the same name - Data.List.
03:41:47 <benmachine> circle: common components of module names don't have any relevance beyond your understanding of them
03:42:47 <yitz> benmachine: so i would first have to do cabal install C-some-version. but that induces the same problem again. so first cabal install D-some-version. and on and on.
03:42:56 <benmachine> yitz: ho hum. so, what's the wrong thing that the algorithm does?
03:43:19 <yitz> benmachine: just figuring out the whole plan is NP-hard.
03:43:27 <quicksilver> DarkFox: there is http://hackage.haskell.org/package/largeword-1.0.0 and http://hackage.haskell.org/package/data-dword-0.2.2
03:43:34 <quicksilver> DarkFox: not sure if one is preferred over the other
03:44:13 <yitz> benmachine: it sets the flag to default, sees if can get all the direct deps, if not tries the oposite. but if the failure happens later, not on the direct deps, then the whole thing just fails.
03:44:28 <shachaf> One should use an IPv6 type for IPv6.
03:44:37 <quicksilver> DarkFox: but Network.Socket usess 'HostAddress6'
03:44:45 <quicksilver> DarkFox: type HostAddress6 = (Word32, Word32, Word32, Word32)
03:45:09 <HugoDaniel> :D
03:46:04 <benmachine> yitz: huh. and I suppose that's sensible because arbitrary backtracking would mean you tried a *lot* of things before giving up
03:46:54 <benmachine> yitz: I don't suppose there's any chance that cabal install -ffoo sets foo for dependencies as well?
03:47:03 <DarkFox> quicksilver: :P
03:47:28 <DarkFox> (Word32, Word32, Word32, Word32) now that's a joke :P
03:47:41 <HugoDaniel> why ?
03:47:52 <HugoDaniel> its not, it maps very well to IPv6
03:48:23 <DarkFox> Wel sure it works but It's a little funny :)
03:48:33 <DarkFox> Funny not bad (joke)
03:48:49 <Hail_Spacecake> I want to write a program that will open a file look at the first 6 bytes and tell me if it is a png or not
03:49:01 <Hail_Spacecake> and I'm not sure how to hardcode the magic png bits into the program
03:49:27 <DarkFox> maxBound :: HostAddress6
03:49:27 <DarkFox> (4294967295,4294967295,4294967295,4294967295)
03:49:30 <Hail_Spacecake> I know from wikipedia that the first six bytes of a valid png file are hex 89 50 4E 47 0D 0A 1A 0A
03:49:34 <Hail_Spacecake> but how do I write that in haskell?
03:49:35 <HugoDaniel> Hail_Spacecake: you can use one of the png libs (they probably do that), or try the ByteString package
03:49:41 * DarkFox never tried such on maxBound that's awesome :)
03:49:50 <Hail_Spacecake> I'm intentionally trying to write this from scratch to understand haskell IO better
03:49:53 <HugoDaniel> if you want to do proper low level parsing i suggest cereal or binary packages
03:50:22 <Hail_Spacecake> well I'm not really parsing anything, I just want to compare six bytes
03:50:27 <HugoDaniel> Hail_Spacecake: ok, then go with ByteString :)
03:50:38 <quicksilver> Hail_Spacecake: open the file; use ByteString's "hGet h 6" to get the first six bytes.
03:50:45 <Hail_Spacecake> sure, that makes sense
03:51:10 <benmachine> Hail_Spacecake: you can use hexadecimal notation for integer and character literals
03:51:11 <quicksilver> Hail_Spacecake: and then check == pack[0x89,0x50,0x4E,0x47,0x0D,0x0A]
03:51:17 <benmachine> > '\xa0'
03:51:18 <lambdabot>   '\160'
03:51:40 <yitz> benmachine: doubt it (what a namespace mess that would be), but i'll try
03:51:59 <Hail_Spacecake> okay so when I write a literal 0x4e or whatever in haskell, that's a Word8?
03:51:59 <quicksilver> benmachine: whilst that a useful thing to know, I'd hope character literals will not be involved in reading and comparing 6 bytes
03:52:09 <Hail_Spacecake> and pack converts a list of word8 into a bytestring
03:52:12 <benmachine> quicksilver: true
03:52:14 <Hail_Spacecake> which I guess is underlyingly a list?
03:52:15 <fenris_kcf> hy. if multiple patterns match, is there a way to combine the results?
03:52:20 <quicksilver> Hail_Spacecake: it can be a Word8 it wants to be
03:52:25 <typoclass> > map chr [0x89,0x50,0x4E,0x47,0x0D,0x0A]
03:52:26 <lambdabot>   "\137PNG\r\n"
03:52:27 <benmachine> > "\x48\x45\x4c\x4c\x4f"
03:52:28 <lambdabot>   "HELLO"
03:52:30 <HugoDaniel> :D
03:52:39 <quicksilver> Hail_Spacecake: (numeric literals are polymorphic)
03:52:51 <quicksilver> > [0x89,0x50,0x4E,0x47,0x0D,0x0A] :: [Word8]
03:52:52 <lambdabot>   [137,80,78,71,13,10]
03:52:55 <benmachine> fenris_kcf: combine them in what way?
03:52:55 <Hail_Spacecake> ah, okay
03:52:56 <quicksilver> > [0x89,0x50,0x4E,0x47,0x0D,0x0A] :: [Int]
03:52:56 <lambdabot>   [137,80,78,71,13,10]
03:52:57 <Hail_Spacecake> '''''
03:53:06 <Hail_Spacecake> er, sorry about that, my key is stuck
03:53:13 <quicksilver> Hail_Spacecake: but, yes, if you pass them as parameter to bytestring's pack
03:53:21 <quicksilver> then they're going to be interpreted as a list of Word8s
03:53:29 <fenris_kcf> benmachine: for example if they are of type [t], then concat should be used
03:53:30 <typoclass> Hail_Spacecake: in my opinion, it's clearer to write "\137PNG\r\n" in your source code, rather than [0x89,0x50,0x4E,0x47,0x0D,0x0A]
03:53:54 <quicksilver> clearer one way
03:54:11 <quicksilver> but it does open up a can of worms about Chars not being bytes and encodings and doing the right thing
03:54:27 <Hail_Spacecake> yeah it's less clear to me
03:54:36 <quicksilver> I think I'd write [0x89,0x50,0x4E,0x47,0x0D,0x0A] -- bytestring magic number is "\137PNG\r\n" in ASCII
03:54:36 <Hail_Spacecake> I just know a PNG is a magic six bytes
03:54:49 <quicksilver> that is, put the asciis in a comment
03:54:50 <Hail_Spacecake> I guess they were chosen intentionally to be PNG in ascii, but that's immaterial for me
03:55:00 <benmachine> fenris_kcf: hmm. not really
03:55:29 <typoclass> Hail_Spacecake: fair enough, but i suggest you add a comment like quicksilver said
03:55:35 <simukis_> doesn't bytestring have IsString instance
03:55:37 <benmachine> fenris_kcf: you might be able to do something clever with a list comprehension, want to show us some example code?
03:55:57 <simukis_> why not XOverloadedStrings and "\137PNG\r\n" :: ByteString?
03:55:57 <fenris_kcf> would have to squeeze it first
03:56:00 <HugoDaniel> i forgot how #haskell is awesome
03:56:14 <benmachine> typoclass: does it really matter what the ascii representation is?
03:56:30 <Hail_Spacecake> hang on a sec
03:56:31 <benmachine> typoclass: imo just "this is the PNG magic number" is fine
03:56:36 <Hail_Spacecake> if pack is type [Word8] -> ByteString
03:56:45 <Hail_Spacecake> then shouldn't something like pack [22,400] fail?
03:57:01 <benmachine> Hail_Spacecake: that depends on how large numeric literals are interpreted as Word8s
03:57:02 <quicksilver> Hail_Spacecake: unfortunately that's a shortcoming with polymorphic literals
03:57:13 <quicksilver> Hail_Spacecake: they're not range checked
03:57:18 <benmachine> Hail_Spacecake: probably it just cuts off the top bits rather than erroring
03:57:19 <quicksilver> > [22,400] :: [Word8]
03:57:20 <lambdabot>   [22,144]
03:57:25 <HugoDaniel> or use this: http://hackage.haskell.org/package/magic :D
03:57:31 <benmachine> I imagine this is partially for efficiency reasons
03:57:33 <quicksilver> Hail_Spacecake: this is consistent with arithmetic
03:57:37 <quicksilver> but it's annoying
03:57:41 <quicksilver> > 200 + 200 :: Word8
03:57:42 <lambdabot>   144
03:57:45 <benmachine> HugoDaniel: there is no way that package can live up to its name
03:58:06 <chrisdone> is there a single func out there on hackage somewhere to run a computation in a separate thread but with a timeout of the likes threadDelay would take?
03:58:06 <HugoDaniel> benmachine: i haven't actually tried it, except through the "file" *nix command
03:58:16 <quicksilver> simukis_: that works too. I don't like overloaded strings, I don't like using strings for bytes. But I'm sure it's fine.
03:58:17 <benmachine> HugoDaniel: mm
03:58:36 <chrisdone> either with a default value or an Either return type
03:59:00 <typoclass> chrisdone: this? http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html
03:59:07 <chrisdone> that's a module
03:59:19 <chrisdone> i looked in there just now. i don't see a function in there as i described
03:59:32 <benmachine> chrisdone: maybe in combination with System.Timeout?
03:59:51 <quicksilver> chrisdone: System.Timeout?
03:59:58 <chrisdone> ahh, perfect! thanks =)
04:00:06 <benmachine> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-Timeout.html
04:00:09 <benmachine> in case you didn't have it to hand
04:00:16 <chrisdone> I :browse'd it, but thanks =)
04:00:46 <quicksilver>  (timeout 30 ask#Haskell) `mplus` (searchGoogleYourSelf)
04:00:58 <HugoDaniel> :D
04:01:00 <chrisdone> yeah =p
04:01:14 <quicksilver> sadly that's not the right mplus instance
04:01:18 <quicksilver> need to wrap it in MaybeT
04:01:25 <HugoDaniel> i like the precedence :D
04:02:06 <quicksilver> actually what I often find is that I can't find things on google, so I ask in IRC, and then if I search google again using the words in my IRC question it works
04:02:24 <yitz> to me the fact that PNG is in the "magic number" is interesting, and it seems cleaner actually to build the magic number from that rather than just putting it in a comment
04:02:26 <quicksilver> so the exercise of formulating the question for IRC also formulates the right search query which was evading me before.
04:02:35 <merijn> benmachine: I guess the other reason for just dropping any bits that don't fit (in literals) is that it's similar to C (and other languages) behavior
04:03:03 <quicksilver> merijn: (and early haskell implementations were written in C or compiled into C)
04:03:07 <Hail_Spacecake> another question, if I have a do block that returns an IO String
04:03:10 <typoclass> quicksilver: also known as rubberducking :)
04:03:13 <yitz> i am opposed to writing bytestrings as ASCII strings almost always. this might be one of the exceptional cases where it makes sense though.
04:03:17 <Hail_Spacecake> and I want to print that value in another do block
04:03:47 <Hail_Spacecake> right now I'm doing: do {a <- innerDoBlock args; putStrLn a}
04:03:50 <Hail_Spacecake> which seems inefficient
04:04:08 <Hail_Spacecake> is there a better way to do this?
04:04:11 <quicksilver> Hail_Spacecake: putStrLn =<< innerDoBlock args
04:04:20 <quicksilver> or innerDoBlock args >>= putStrLn
04:04:29 <benmachine> merijn: yes, because C is our model of good behaviour :P
04:04:29 <yitz> overloaded strings is a separate flame war. i'll just sumarize that (as usual) i agree with quicksilver.
04:04:32 <quicksilver> depending which  you think reads better.
04:04:42 <merijn> benmachine: No, but consistency is a good thing
04:04:52 <Hail_Spacecake> oh so =<< is exactly the same as >>= just with switched args?
04:04:55 <quicksilver> merijn: are you sure? I thought it was the hobgoblin of small minds?
04:04:58 <quicksilver> Hail_Spacecake: yes.
04:04:58 <merijn> benmachine: Breaking consistency should only be done if the alternative is significantly better
04:05:29 <merijn> benmachine: And I'm currently unsure of a better way to deal with it, runtime crash?
04:05:50 <merijn> :t (>>=)
04:05:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:05:51 <benmachine> merijn: I'm not sure if runtime crash is better but I'm not sure if it's worse either
04:05:52 <chrisdone> scripts in haskell, winrar http://lpaste.net/5177195772357115904
04:05:55 <merijn> :t (=<<)
04:05:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:06:13 <typoclass> merijn: i don't agree. "400 :: Word8" could easily be a compiler error, couldn't it?
04:06:14 <benmachine> merijn: it would be really nice if we could get a compile-time crash on bad literals, but that would require language rather than library changes
04:06:18 <yitz> merijn: in haskell, when bits don't fit, they go into another component of the constructor
04:06:23 <quicksilver> chrisdone: are lpaste's new paste numbers supposed to be unguessable?
04:06:27 <merijn> typoclass: Sure, but what about "fromIntegral 400 :: Word8"?
04:06:38 <merijn> typoclass: Which is effectively what "400 :: Word8" is
04:06:42 <quicksilver> chrisdone: or is that a 'private' one?
04:06:49 <chrisdone> quicksilver: yeah, the private ones
04:06:51 <typoclass> quicksilver: there's two buttons, for private and public pastes
04:06:58 <quicksilver> I saw the two buttons :)
04:07:12 <quicksilver> "random URL strings is enough privacy for anyone, just ask Zuck?"
04:07:15 <yitz> merijn: true, and but it shouldn't be. we should compute literals at compile time, not run time.
04:07:19 <yitz> like C :)
04:07:28 <quicksilver> yitz: we do compute them at compile time
04:07:28 <merijn> yitz: We should do impressive constant folding!
04:07:34 <quicksilver> but that's not really the point
04:07:42 <quicksilver> because you can pass polymorphic numbers about
04:07:51 <quicksilver> so you still have to decide what to do at runtime at some point.
04:08:01 <yitz> quicksilver: no. we convert them to an expression like fromInteger or fromString and then run that at run time.
04:08:08 <chrisdone> my wifi driver for this retina isn't so great, it cuts out but doesn't reconnect. so this script checks to see if it's died and quickly re-connects to the access point
04:08:09 <quicksilver> you can pass (400 :: Num a => a) across a module boundary.
04:08:15 <quicksilver> yitz: that's the specification, not the implementation.
04:08:22 <quicksilver> yitz: the implementation is at compile time.
04:08:33 <merijn> benmachine: Anyway, my point was that, until we settle on a definite superior approach, consistency with other languages is preferable to being different
04:09:02 <yitz> quicksilver: polymorphism of literals should be limited to types that can be determined concretely at compile time, and the coersion function should be run at compile time.
04:09:05 <benmachine> merijn: I'll agree with that, but I don't have to like it :P
04:09:47 <typoclass> i don't think we should use c's mistakes as excuses for repeating them
04:10:02 <merijn> typoclass: See my previous line
04:10:08 <chrisdone> quicksilver: yeah the private is like "it's not the end of the world if this gets out (after all i'm sending it to a server owned by a maniac, but i'd rather not have it public)" rather than any form of security
04:10:10 <yitz> quicksilver: no. if you write a Num or IsString instance with a partial function, your malformed literal will cause an error at run time.
04:10:34 <quicksilver> yitz: yes, that indeed is true.
04:10:50 <chrisdone> anyway, people pasting private things should consult the service agreement
04:10:50 <quicksilver> yitz: but the standard instances for GHC builtin types will get dealt with at compile time
04:10:51 <merijn> If only Haskell was a total language
04:10:58 <merijn> :p
04:11:00 <HugoDaniel> :)
04:11:09 <quicksilver> chrisdone: I was being a little flippant :)
04:11:20 <HugoDaniel> flip . flip . flip
04:11:21 <chrisdone> quicksilver: me too, there is no service agreement =p
04:12:14 <typoclass> yitz: in my opinion you're right. a compiler error would be best, a runtime error is the best we could do, silently ignoring errors is not great. (i don't care about consistency with c)
04:12:37 <merijn> typoclass: Ok, so what should "fromIntegral 400 :: Word8" do? Crash
04:12:41 <merijn> ?
04:12:53 <typoclass> merijn: i dunno, yeah? why not?
04:13:14 <merijn> Because I use the assumption that it truncates?
04:13:22 <merijn> Also, partiality is awful
04:15:01 <quicksilver> positive integers module 256 are not a particularly poorly behaved concept
04:15:06 <quicksilver> and they're well supported by the hardware
04:15:14 <quicksilver> it's not ridiculous just to specify that's what it does
04:15:26 <Adeon> > fromIntegral 123 :: Word8
04:15:28 <lambdabot>   123
04:15:28 <quicksilver> (but in point of fact I don't think it *is* specified)
04:15:29 <Adeon> > fromIntegral 300 :: Word8
04:15:31 <lambdabot>   44
04:16:18 <yitz> typoclass: we could do compiler errors. it would mean a change to the status quo (non-breaking almost always), and some implementation effort.
04:16:26 <typoclass> merijn: i don't mean to provoke, but i haven't understood your position yet. as a thought experiment, would you be in favor of removing Maybe and changing the language so that (e.g.) String and all kinds of types can be a special 'null pointer' value, or an actual String
04:16:31 <typoclass> yitz: right, right
04:16:55 <chrisdone> @quote breakfast
04:16:56 <lambdabot> byorgey says: I got this great pair of toy glasses in my breakfast CReal that make you CDouble.
04:17:10 <HugoDaniel> :D
04:17:10 <chrisdone> hahaha
04:17:11 <HugoDaniel> ahaha
04:17:14 <merijn> typoclass: No, but I mostly use Word8 when dealing with binary stuff and C code, where the behaviour is convenient
04:17:34 <benmachine> so it seems one of the major questions is whether or not fromInteger 400 :: Word8 actually *is* an error
04:17:41 <yitz> quicksilver: yes i think all the standard instances are total. even Text literals replace all surrogates with REPLACEMENT CHARACTER. messy, but total.
04:17:43 <benmachine> and that depends on what the programmer expects
04:17:47 <merijn> typoclass: Removing the fromIntegral for Word8 basically means everyone always has to do "fromIntegral (x `mod` 256)"
04:18:02 <quicksilver> yitz: yeah, there was a long debate about whether partial instances were reasonable
04:18:04 <benmachine> and if the programmer is using Word8 specifically, they probably have an expectation about size limitations and their violation
04:18:05 <HugoDaniel> why not build your own type ? like Number255 :P
04:18:17 <benmachine> HugoDaniel: why not call it Word8?
04:18:17 <quicksilver> yitz: some people cited it as a reason to dislike overloadedstrings at all
04:18:19 <HugoDaniel> :D
04:18:25 <merijn> typoclass: When I work with binary stuff or C code the truncation behaviour is very common and useful, for example to mask out bits and check whether flags are set
04:18:33 * yitz raises his hand
04:18:43 <chrisdone> yitz: put it down!
04:18:49 <HugoDaniel> but, with Number255 you could also have a flag that tells you if there was an overflow :D
04:18:49 <benmachine> quicksilver: hmm. /me speculates about instance IsString a where fromString = unsafePerformGHC
04:18:49 <typoclass> merijn: ah ok. so you'd be happy if (hypothetically) Word8 threw errors and you could instead do "import Foreign.CWord8" or some such to get the current behavior?
04:18:52 <yitz> me, me!
04:19:09 <merijn> Read Word32, check whether a flag is set by "fromIntegral myReadWord .&. myFlag"
04:19:34 <merijn> typoclass: Yes, but then I have an additional argument, that if you introduce Foreign.CWord8 Word8 will have 0 applicability
04:19:53 <HugoDaniel> anyone is up to the challenge of creating the "useless Haskell Platform" ? it should be similar to the Haskell Platform but it must consist only of useless packages :D
04:20:01 <yitz> benmachine: you could write an IsString instance involving unsafePerformIO launchMissiles.
04:20:03 <merijn> typoclass: iow, the only real reason to have Word8 in the first place, is to have Foreign.CWord8
04:20:14 <benmachine> yitz: I am being silly :P
04:20:23 <chrisdone> HugoDaniel: The Haskell Wonky Floorboards?
04:20:32 <HugoDaniel> ahah :D
04:20:45 <merijn> typoclass: Because I can't think of a sane use case for Word8 that doesn't involve binary data manipulation or C FFI
04:20:54 <benmachine> merijn: I think ByteStrings are Word8s without being anything to do with C
04:21:12 <chrisdone> The Haskell Park Bench That Feels A Bit Wet Aw Damn
04:21:13 <merijn> benmachine: Yes, I said binary data *or* C, not *and*
04:21:28 <typoclass> merijn: ok :) but the discussion started with the person who wanted [400] :: Word8 and convert it to ByteString or something like that
04:22:25 <merijn> typoclass: Sure, that'd be a bit undesirable, but I think breaking the other usecases for the sole reason of fixing that (fairly obvious) error isn't worth it
04:22:41 <merijn> Or rather, not fixing the error, but reporting it at compile time
04:22:45 <yitz> HugoDaniel: i nominate the packages in the Acme section on the hackage packages page.
04:22:50 <HugoDaniel> ahaha
04:22:55 <merijn> I'd accept a compile time warning for literals that are to big, though
04:22:57 <benmachine> merijn: the one case where that error isn't fairly obvious is where type inference fixes the type without you noticing
04:23:21 <yitz> HugoDaniel: which always appear near the top, thus making the first impression of hackage on newcomers
04:23:22 <benmachine> (this is part of the reason why Int is evil)
04:23:32 <HugoDaniel> ahaha its always a very nice welcoming card :D
04:23:33 <typoclass> benmachine: true, and then any behavior of "the number changes mysteriously" is even sneakier
04:23:37 <merijn> benmachine: Right, but I'm against not writing down type signatures too, so my philosophy is internally sound!
04:24:38 <yitz> HugoDaniel: we should ask Ross to add a macro to hackage which automatially changes the Acme keyword to ZZZZAcme
04:25:04 <HugoDaniel> but what if newcomers really want to know the current year ? :D
04:25:23 <HugoDaniel> acmd-year is up there for the job :)
04:25:28 <HugoDaniel> *acme
04:26:22 <yitz> i also nominate hnop
04:26:55 <yitz> although hnop is historically important - it was the first package on hackage, and taught people how to use the system.
04:27:07 <typoclass> merijn: ok :) but remember that particularly beginners have not yet developed their own philosophy, particularly not an internally sound one. they rely a great deal on the language
04:28:11 <merijn> typoclass: Another argument in favour of being consistent with other languages! :)
04:28:12 <yitz> HugoDaniel: hey, that's a cool package. it actually reads the year number from the version number of the package.
04:28:13 <typoclass> yitz: pfff, ancient history. that was like six years ago or something. the world was black and white back then ;-)
04:28:46 <yitz> typoclass: why dost thou thinkest that it be ancient?
04:29:24 <shachaf> That'd be "why dost thou think" or "why thinkest thou" or something.
04:29:34 <chrisdone> typoclass: i remember when the internet was black and white and you had to upload web pages back onto the internet when you were done with them
04:29:38 <HugoDaniel> yitz: yes true, no IO required
04:29:57 <typoclass> @remember chrisdone i remember when the internet was black and white and you had to upload web pages back onto the internet when you were done with them
04:29:58 <lambdabot> Nice!
04:29:59 <yitz> shachaf: ok ok. see, i'm not authentically ancient.
04:30:15 <typoclass> yitz: yes, you're ancientest
04:30:38 <HugoDaniel> :D
04:31:06 <yitz> chrisdone: ms sharepoint actually still works that way, sort of.
04:42:41 <quicksilver> I have haskell-cafe posts from yitz going back to october 2006, I think that makes him ancient
04:44:49 <HugoDaniel> :D
04:51:26 <Entroacceptor> on that, any progress of the hackage2 test?
04:52:19 <alpounet> i think it's running smoothly
04:53:46 <alpounet> latest commit was 5 days ago
05:01:03 <chrisdone> @quote hackage2
05:01:03 <lambdabot> No quotes match. Where did you learn to type?
05:09:31 <noam> :t (undefined :: a -> a) . (undefined :: a)
05:09:32 <lambdabot> a -> c
05:09:41 <noam> what is going on here?
05:10:40 <shachaf> Two functions are being composed.
05:10:49 <shachaf> What's the problem?
05:11:04 <noam> i don't see where c is coming from
05:11:20 <fenris_kcf> just a name
05:11:23 <fenris_kcf> placeholder
05:11:52 <fenris_kcf> probably arisen from the inference-algorithm
05:12:19 <noam> :t (undefined :: (a -> b) -> (a -> b)) . (undefined :: (a -> b))
05:12:20 <lambdabot> a -> a1 -> b
05:12:48 <noam> hmm
05:12:55 <shachaf> :t (.)
05:12:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:13:09 <shachaf> There's your c. (.) f g :: a -> c
05:13:26 <tero-> uh, compiling a lot of Yesod's persistent definitions and handlers seems to be heavy for ghc. compiling just one module takes close to 10 mins and more than 6 GB of memory
05:13:50 <shachaf> @where yesod might know more than #haskell
05:13:50 <lambdabot> #yesod - http://yesodweb.com/
05:14:23 <tero-> shachaf: thanks. I'll head there
05:15:36 <noam> shachaf: it's a bit confusing to me still but i think i get it...
05:17:59 <shachaf> noam: Note that the 'a's in (undefined :: a -> a) and (udnefined :: a) are unrelated.
05:18:20 <shachaf> :t (undefined :: x -> x) . (undefined :: y)
05:18:21 <lambdabot> a -> c
05:18:49 <noam> hmm yes i see
05:18:57 <noam> what is the syntax if i want to make them related?
05:19:02 <noam> (the same)
05:21:44 <erisco> dolio, heya
05:22:38 <shachaf> noam: Look into ScopedTypeVariables.
05:22:59 <shachaf> But in general that doesn't quite make sense -- someone has to decide what a is or where it comes from or something.
05:23:04 * shachaf disappears.
05:23:12 <noam> :t let (x, y) = undefined :: (a -> a, a) in (x . y)
05:23:12 <lambdabot> a -> c
05:23:33 <noam> shachaf: that seems to do the trick
05:23:44 <noam> still the same result :P
05:25:27 <t7> wut
05:26:02 <t7> :t let (x, y) = (id, id) in (x . y)
05:26:03 <lambdabot> c -> c
05:26:49 <sipa> is that unexpected, t7?
05:27:09 <t7> nope
05:27:30 <t7> just needed to read it properly :)
05:27:33 <typoclass> noam: i think that realistically, id is the only implementation you could have for a -> a. unless you add constraints like (Eq a) => a -> a or whatever
05:28:10 <sipa> excluding bottom, it is the only implementation
05:28:29 <sipa> well, and unsafePerformIO and friends
05:28:39 <typoclass> sipa: yes yes
05:28:51 <noam> typoclass: well there can not be a function of type (a -> b) then, right?
05:29:17 <noam> which means that that composition i did does not make so much sense
05:29:21 <typoclass> noam: that's correct! in haskell there couldn't be one
05:29:52 <sipa> :t const raise
05:29:52 <lambdabot> Not in scope: `raise'
05:31:41 <sipa> :t const undefined
05:31:42 <lambdabot> b -> a
05:32:01 <jmcarthur_mobile> Well, there can be on, but it doesn't do anything especially useful.
05:32:03 <acube> Is it allowed for a haskell compiler to just go and evaluate some random code that doesn't depend on any other values, or only on values that have already been evaluated?
05:32:04 <typoclass> sipa: error is a candicate
05:32:05 <jmcarthur_mobile> *one
05:32:09 <typoclass> @type error
05:32:10 <lambdabot> [Char] -> a
05:35:11 <jmcarthur_mobile> acube: the compiler I'd allowed to evaluate anything as long as it doesn't make an otherwise terminating program fail to terminate
05:35:12 <jmcarthur_mobile> *is
05:40:47 <merijn> jmcarthur_mobile: I guess by that you mean it's not allowed to turn a program into bottom unless it was already bottom?
05:41:07 <jmcarthur_mobile> merijn: right
05:41:28 <quicksilver> but it's a bit more involved than that
05:42:03 <quicksilver> non-terminating haskell programs can have useful observational semantics
05:42:09 <quicksilver> for example, a web server
05:42:25 <quicksilver> so it actually mustn't change any part into bottom which wasn't already bottom
05:42:54 <fruitFly> is there anyway to run haskell programs without having haskell installed on a machine like python's py2exe? http://www.py2exe.org/
05:45:18 <mauke> fruitFly: yes
05:45:35 <mauke> ghc compiles to native code
05:45:59 <fruitFly> mauke: oh shizzle dizzle
05:46:26 <fruitFly> mauke: thanks :)
05:47:31 <fruitFly> mauke: so there is a windows, linux and os x version of the haskell platform that is developed to compile to their respective native codes?
05:47:33 <typoclass> fruitFly: ghc statically links the binaries by default (afaik?). there is one or two libraries you may still need (libgmp?), but overall it shouldn't be too hard. i guess you can get there by distributing 2-3 files
05:49:27 <mauke> fruitFly: yes
05:49:27 <merijn> quicksilver: Hence, asking for my clarification whether he meant bottom when he said non-terminating
05:49:44 <fenris_kcf> what is the recommended way to use the quasi-pattern "n+1" in GHC?
05:49:51 <merijn> fenris_kcf: Not
05:49:53 <fenris_kcf> just using n and taking n-1 ?
05:49:59 <fruitFly> typoclass: "distributing 2-3 files"? meaning 2-3 things might need to be installed on the clients inorder to get the app to work in some cases?
05:50:02 <merijn> fenris_kcf: Yes
05:50:25 <fenris_kcf> hmm, ok
05:50:45 <merijn> fruitFly: Yes, unless you package the libraries too, it's basically the same as distributing C/C++ programs
05:53:26 <fruitFly> merijn: i'm not fully following, what might the client be missing? and why would i need to package any libraries if the library functions in my source code are compiling to native code?
05:53:43 <merijn> fruitFly: Well, what if the client doesn't have OpenGL installed?
05:54:16 <merijn> fruitFly: You might want to google and read up on "shared libraries" or "dynamic libraries"
05:54:27 <merijn> fruitFly: Just because it's native code, doesn't mean it's just one file
05:55:53 <fruitFly> meretrix`: ok, so haskell compiles to native code dependent on some software packages sometimes like openGl, libgmp, etc.? so if I wanted to put a haskell.exe on a system it would need to download those packages?
05:58:16 <merijn> fruitFly: No, haskell compiles to native code, this code might use other shared libraries, which means you have to ensure the client actually has those shared libraries installed
05:59:29 <merijn> fruitFly: There's two ways of making sure they're installed: 1) ship a copy of the library with your executable (this is the approach many windows developers/game devs take) 2) tell the user to make sure they're installed, otherwise your program will crash
05:59:33 <fruitFly> merijn: ok, so the libraries the client will require will depend on the source code, right?
05:59:51 <merijn> Many open source/linux package take approach number 2 and rely on package managers to install the relevant libraries
05:59:55 <merijn> fruitFly: Yes
05:59:59 <fruitFly> merijn: ok got it :)
06:00:55 <fruitFly> merijn: so haskell compiler is engineered to be compiled to windows, linux, os x etc. respectively?
06:01:52 <mauke> is this your first compiler?
06:03:27 <typoclass> fruitFly: well, the windows version of ghc compiles your source to native windows binaries, the osx version to native osx binaries, etc.
06:04:33 <erisco> instance Functor MyType where  ... MyType :: * -> *   is there a way to constrin so  MyType :: (SomeClass **) => * -> ** ?
06:04:54 <erisco> or can this constraint only be stated by Functor?
06:05:09 <fruitFly> mauke: typoclass got it lol, i'm not the most experienced with the OS layer, but now thinking about it that's seems to be the only way to do it
06:05:34 <erisco> I don't necessarily see a problem with saying "this instance only works for types which satisfy x y and z"
06:37:39 <merijn> Is there a groupBy that doesn't only look at adjacent matches? Or should I just sortBy, *then* groupBy
06:38:38 <RichyB> merijn: nub eliminates duplicates without reordering but it's quadratic.
06:39:51 <merijn> I don't want to eliminate duplicates
06:40:02 <merijn> I want to group them
06:40:04 <merijn> :t groupBy
06:40:16 <merijn> oh, goodie, lambdabot is gone :(
06:40:35 <merijn> groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
06:40:43 <merijn> Except I want any match, not just adjacent
06:41:18 <RichyB> So from the list [1,1,3,2,1,3], what output do you want? [ [1,1,1], [3,3], [2] ] ?
06:41:38 <lasticot> groupBy . sort ?
06:42:45 <merijn> lasticot: Yes, I was just asking whether there was another way
06:42:56 <merijn> "Or should I just sortBy, *then* groupBy"
06:43:17 <dmwit> merijn: Map.fromListWith
06:43:24 <dmwit> ...sort of
06:43:27 <lasticot> oops... sorry about that ^^'
06:43:38 <dmwit> It doesn't really do the "by" part without some annoying newtype gymnastics.
06:46:36 <namoamitabuddha> Monad is not easy understanding.
06:48:35 <dmwit> namoamitabuddha: Have you tried sigfpe's article? That was my favorite.
06:48:52 <dmwit> ?google you could have invented monads and maybe you already have
06:48:59 <dmwit> derp
06:49:00 <HugoDaniel> namoamitabuddha: start by using monads a lot, and the understanding will come :)
06:49:14 <dmwit> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
07:00:16 <sopvop> it's so hard to come up with an operator which does not clash with lens :(
07:00:42 <mauke> it's trivial
07:00:49 <mauke> use a diagonalization procedure
07:01:15 <FreeFull> sopvop: Just stick a bunch of **** at the end
07:01:25 <FreeFull> %^&%^&%&^&*****
07:01:30 <quicksil1er> as far as I recall, lens uses no operator more than 5 symbols long
07:01:30 <FreeFull> Almost certainly won't clash with lens
07:01:42 <quicksil1er> yeah, FreeFull's choice is a good one.
07:02:01 <quicksil1er> ideally your haskell programs will also read like 1970s batman comics
07:02:20 <FreeFull> > let a %^&%^&%&^&***** b = [a,b] in 3 %^&%^&%&^&***** 4
07:02:38 <FreeFull> Lambdabot, where are you D:
07:02:54 <mauke> on the other side
07:02:58 <sopvop> Lambdabot is disgusted with your operator
07:04:11 * FreeFull runs it in his local lambdabot
07:04:36 <FreeFull>   [3,4]
07:15:02 --- mode: calvino.freenode.net set +o ChanServ
07:29:21 <quchen> Is there a good and short example of a valid program that Haskell's type system doesn't allow? I'm thinking of the explicit definition of the Y combinator, is there something better?
07:29:52 <mauke> print (if True then "yes" else 42)
07:30:25 <quchen> That's a pretty good one.
07:30:37 <mauke> @remember raganwald Immuteability: The property of functional programmers that prevents them from shutting up about pure functional programming.
07:30:55 <quchen> mauke: Good thing Lambdabot isn't here.
07:31:04 <mauke> yep
07:31:56 <tuscan> .NIGGER NIGGER NIGGERNIGGER_NIGGER_NIGGER_NIGGER_NIGGER_NIGGER_NIGGER_NIGGERNIGGER_NIGGER_NIGGER_NIGGERNIGGER_NIGGER_NIGGER_NIGGERNIGGER_NIGGER_NIGGER_NIGGERLK52
07:31:58 <dgpratt> huh...I just noticed this channel has no ops
07:32:11 <dgpratt> and I'm about to get my question answered
07:32:14 <mauke> dgpratt: welcome to freenode :-)
07:32:29 <mauke> well, welcome to freenode in DoS netsplit mode
07:32:41 <dgpratt> :)
07:33:07 <mauke> but it's normal for channels to have no opped nicks
07:33:12 <mauke> what's less normal is the lack of services
07:33:30 <quchen> I find tuscan's typography offensive.
07:33:43 <acube> What's DoS netsplit mode?
07:33:44 <mauke> please don't comment on spam
07:34:00 <mauke> acube: http://en.wikipedia.org/wiki/Netsplit
07:34:42 <mauke> http://en.wikipedia.org/wiki/DoS
07:35:59 <acube> Oh. So the services got split from us in a netsplit?
07:36:24 <mauke> presumably, but I'm not sure what the exact problem is
07:37:59 <merijn> dgpratt: It's recommended freenode policy not to have users with ops unless they're actively doing op tasks (like banning spammers)
07:38:29 <S11001001> mauke: the services are getting dosed according to wallops earlier
07:38:51 <merijn> DOS'ing freenode seems to be every script kiddie's favorite hobby
07:45:11 <BoR0> in category theory, when we have A and id_A, can we state that id_A is an element of A? if not, how are these two related? I understand that id_A : A -> A, maybe it's an arrow of A?
07:45:49 <dmwit> id_A : A -> A is the most you can say.
07:45:57 <dmwit> "element" doesn't make sense for all categories.
07:46:00 <yitz__> BoR0: it's an element of Hom(A,A)
07:46:13 <dmwit> "an arrow of A" doesn't give enough data; is A the domain? codomain? both?
07:46:17 <Saizan> BoR0: you say that id_A is an arrow from A to A, i.e. an element of Hom(A,A)
07:46:24 <BoR0> what is Hom?
07:46:37 <guerrilla> is Hom(A, A) always a set though?
07:46:45 <yitz__> guerrilla: yes by definition
07:46:48 <Saizan> for a given category we denote with Hom(X,Y) the collection of arrows from X to Y
07:46:55 <BoR0> oh, okay
07:47:12 <Saizan> guerrilla: well, it can be large
07:47:14 <yitz__> Saizan: guerrilla is right, it's a set, not a collection
07:47:56 <yitz__> the objects of the category are a collection. if they are a set, it is a "small category".
07:48:26 <guerrilla> yes, thanks. that's what i was looking for
07:48:48 <Saizan> yitz__: if Hom(X,Y) is a set for every X and Y then it's a locally small category
07:49:15 <BoR0> what confuses me here I guess, is, if we have f : A->B, how does g : B->A make that g o f = id_A, and why not g o f = A simply
07:49:41 <yitz__> Saizan: dunno. according to (what used to be) the standard definition, Hom is a set.
07:49:47 <bakibour> Hi
07:49:49 <Saizan> yitz__: http://ncatlab.org/nlab/show/locally+small+category
07:49:49 <nomeata> Hi. When it comes to difficult types, is there a good simple example for a data type that does all the stuff that causes naive thinking to break down? I mean something with nested recursion etc., but not new stuff like GADTs.
07:49:52 <yitz__> Saizan: see Mac Lane.
07:50:00 <dmwit> BoR0: In general, it is not true that any well-typed arrow of type A -> A is actually id_A.
07:50:18 <dmwit> BoR0: So it may be that we have f : A -> B and g : B -> A for which g . f /= id_A.
07:50:22 <bakibour> Some time back i wrote this stuff here, http://www.haskell.org/haskellwiki/Graph_processing_and_representation_(Graep) but the links are not working anymore, is there any way to get a backup of this?
07:50:45 <dmwit> BoR0: As for "why not g . f = A", well, that is just ill-typed. On the left is an arrow, and on the right an object. =)
07:51:02 <BoR0> dmwit, ok I was watching a video by awodey and he was talking about some specific case. I am more interested in why not g o f = A
07:51:31 <dmwit> Because the equation doesn't make sense. =)
07:51:40 <BoR0> g o f is obviously A -> B -> A, but I'm having a trouble with always imagining A and B as sets and id_A as element of A
07:51:55 <dmwit> Well, the type of g . f is A -> A. No mention of B needed.
07:52:20 <BoR0> so what are the possible inputs of g o f ?
07:52:57 <dmwit> bakibour: mmm; I think the deadline for requesting migrations from the old wiki was over years ago
07:53:04 <dmwit> BoR0: mu
07:53:10 <Saizan> BoR0: in general arrows don't have inputs or outputs, are you talking about a specific category?
07:53:18 <bakibour> dmwit: Dang :(
07:53:25 <Saizan> BoR0: also, in general objects are not sets themselves
07:53:42 <BoR0> Saizan, nope, I am interested in general. I can't imagine A nor B nor A->B nor ->
07:53:55 <dmwit> bakibour: I suppose it's possible that something like archive.org has copies.
07:54:18 <Saizan> BoR0: think of objects as just labels that tell you which arrow compositions are legal
07:54:36 <BoR0> but what use of the compositions when they do not have any input nor output
07:54:55 <Saizan> it's still pretty useful, and more general
07:55:04 <dmwit> That question is category-specific.
07:55:25 <dmwit> ...if I'm reading it right.
07:55:38 <Saizan> for example a category where "application" wouldn't make sense is the one where objects are the natural numbers and there's an arrow "n -> m" only when n <= m
07:55:45 <bakibour> Is there any further going abstraction of arrows yet? Adding graphs of arrows and such.
07:56:12 <Saizan> BoR0: there you can still have composition due to the transitivity of <=
07:56:15 <BoR0> Saizan, I see. so we have _applicationless_ categories
07:56:16 <dmwit> Another good example of a no-application category is the category you get by taking any graph, making the nodes objects and the paths in the graph arrows.
07:56:22 <BoR0> that clears some of it, thanks
07:56:50 <dmwit> A path p has type p : A -> B when it starts at node A and ends at node B.
07:56:58 <dmwit> Arrow composition is path concatenation.
07:56:58 <bakibour> Hm archive.org doesnt come up with anything also ...
07:57:08 <Saizan> bakibour: there are "quivers" which require even less than a category
07:58:10 <bakibour> Saizan: I am particularly interested in the graphs + arrows, thats what that Graep idea was about and now that i have a look at that HoTT book i think i had some ideas back then which converge with the ideas of HoTT.
07:59:00 <allsystemsarego> Hi all, http://lpaste.net/90785 how do I make it stop at 37 instead of skipping over it?
07:59:07 <Saizan> bakibour: you mean Control.Arrow.Arrow ?
07:59:25 <bakibour> Saizan: Yes
07:59:47 <bakibour> The idea was that you can put Arrow.Arrow in graphs.
07:59:47 <dmwit> allsystemsarego: Simple, don't unconditionally call putIntList.
08:00:02 <bakibour> And then you can talk about paths in these graphs.
08:00:02 <Saizan> bakibour: ah, that's another thing, it doesn't really match with the CT concept of "arrow" as morphism, it's more like a monad for profunctors
08:00:07 <yitz__> Saizan: ha, in the book Mac Lan actually only talks about small categories, and calls "really big" small categories "large categories".
08:00:19 <bakibour> Why doesnt it?
08:00:20 <dmwit> allsystemsarego: (Alternately, modify the list beforehand so that it stops at 37, e.g. with takeWhile.)
08:00:23 <allsystemsarego> dmwit, thanks, I'll try that
08:00:47 <bakibour> Suppose you have polynomials as functions
08:01:18 <Saizan> bakibour: CT's concept of "arrow" (or hom-set) is more like just Control.Category
08:01:36 <bakibour> P(x) then if i had a DAG of  these they would be categories
08:01:45 <bakibour> Cartesian closed even i would think
08:01:49 <Saizan> though what you call an arrow in CT is an element of that type
08:02:07 <yitz__> Saizan: but in real life, mathematicians always have (or used to have) in mind what i said, knowing that they could always retreat to small categories with some added complexity if forced to their underlying set theory assumption better grounded.
08:02:08 <bakibour> The arrow has the type of the function
08:02:16 <dmwit> :t mapM_ print . takeWhile (/=37)
08:02:33 <dmwit> oops, still no bot
08:02:34 <bakibour> The value of that edge/arrow it the actual function
08:02:52 <Saizan> bakibour: i'm not saying you can't make a category out of those, just that it's quite a more demanding concept
08:02:55 <bakibour> getting the actual value in the type of that graph is some kind of binding
08:03:04 <bakibour> Totally
08:03:22 <bakibour> It gets really mind boggling if you try to get programs with loops :)
08:03:25 <yitz__> Saizan: your link talks about "Grothendiek universes". i guarantee you that Grothendiek himself never paid any attention to those when he was doing his work in algebraic geometry.
08:03:57 <Saizan> yitz__: well, definitions evolve
08:03:57 <yitz__> Saizan: having known Mac Lane personally, i can say that he didn't either.
08:03:58 --- mode: calvino.freenode.net set +o ChanServ
08:04:24 <yitz__> Saizan: ok could be.
08:05:09 <Saizan> bakibour: i think it's better to not call an instance of Control.Arrow.Arrow and "arrow" in a CT context
08:05:13 <bakibour> What is going on here :)?
08:05:32 <Saizan> the servers are messed  up
08:05:51 <bakibour> Maybe the NSA has a buffer overflow or so
08:06:01 --- mode: ChanServ set +o mauke
08:06:10 <Saizan> s/and/an/
08:06:17 <yitz> someone is really hammering freenode today.
08:06:23 <bakibour> Saizan: What is missing to make Arrows Morphims?
08:06:25 <yitz> probably a broken botnet.
08:06:39 <Saizan> bakibour: first of all the type is not its elements
08:07:03 <acube> bakibour: Maybe the NSA should use Haskell to avoid these? :P
08:07:05 <bakibour> Saizan: ?
08:07:16 <bakibour> acube: certainly :)
08:07:32 <Saizan> bakibour: (->) is not an arrow, it's an Arrow, but id :: Int -> Int could be an arrow
08:07:44 <Saizan> but id :: Int -> Int is not an Arrow
08:08:34 <bakibour> I always thought Arrows would wrap types of id :: Int -> Int
08:09:01 <Saizan> what do you mean by that?
08:09:27 <chrisdotcode_> morning, #haskell
08:09:39 <bakibour> That eg Arrow TypeA TypeB wraps function of type TypeA -> TypeB
08:09:40 <ofan> morning
08:09:47 <CaptainK> chrisdotcode_: morning :)
08:09:53 <Saizan> bakibour: what do you mean by wraps?
08:10:03 <CaptainK> mornin all
08:10:06 <chrisdotcode_> hey, CaptainK, ofan
08:10:08 <ab9rf> like a burrito?
08:10:09 * ab9rf runs
08:10:21 <bakibour> Well that the value of an Arrow is an actual function
08:10:25 * CaptainK wonders who had <4 hours sleep
08:10:33 <ofan> is arrow different from Arrow?
08:10:37 <ab9rf> ofan: yes
08:10:46 <ofan> ab9rf: how?
08:10:53 <ab9rf> one is a concept, the other is a type constructor
08:10:58 <Saizan> bakibour: (->) is an instance of the Arrow class, but there can be many other
08:11:08 <ofan> oh hah, got it
08:11:10 <bakibour> Saizan: Ah ok
08:11:12 <ab9rf> or a class, i forget which, too early in the morning
08:11:14 <Saizan> ab9rf, ofan: actually, one is a typeclass
08:11:23 --- mode: mauke set -qqqq *!*@gateway/web/freenode/ip.80.212.74.204 *!*@gateway/web/freenode/ip.69.26.207.104 *!*@gateway/web/freenode/ip.173.180.71.38 *!*@gateway/web/freenode/ip.190.244.124.219
08:11:26 --- mode: mauke set -qqqq *!*@gateway/web/freenode/ip.80.212.75.* testnickk12!*@* Ergon!*@* res!*@*
08:11:29 --- mode: mauke set -qq Quex!*@* Mangina!*@*
08:11:31 --- mode: mauke set -z
08:11:34 <ab9rf> gak
08:11:56 <CaptainK> > filter (elem "bares" . words) ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"] ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"]
08:11:57 <bakibour> Well then i am just talking about the (->) instance here
08:12:11 <ab9rf> (->) is not an instance, it's an operator
08:12:27 <Saizan> ab9rf: (->) is an instance of Arrow
08:12:27 <bakibour> Instance of the Arrow of ->
08:12:38 <Saizan> gah
08:12:39 <ab9rf> so it is
08:12:44 <ab9rf> i need more coffee, or something
08:12:48 <Saizan> we're swamping in terminology
08:12:56 <ab9rf> Saizan: that happens a lot
08:13:01 <Saizan> bakibour: do you have an OOP background?
08:13:07 <bakibour> Saizan: Guess :)
08:13:08 * chrisdotcode_ is trying to follow, but is slowly drowning
08:13:16 <bakibour> Saizan: yes
08:13:20 <Saizan> i guess that might be half of the problem
08:13:54 <guerrilla> :)
08:14:00 <Saizan> bakibour: anyhow i'd phrase it like this, arrow is method of Category, while Arrow is a subclass of Category
08:14:15 <CaptainK> > > take 5 [1..] ==> [1,2,3,4,5]
08:14:18 <Saizan> (in a weird world where methods can be types)
08:14:25 <bakibour> The instance of the Arrow (->) just deals with the kind of concaternation, the operators of the Arrow
08:14:32 <CaptainK> > take 5 [1..] ==> [1,2,3,4,5]
08:14:46 <bakibour> Saizan: Hm
08:14:46 <CaptainK> hello lamdbabot?
08:15:01 <ab9rf> CaptainK: not here atm
08:15:16 <CaptainK> I new he was a loafer!
08:15:33 <Saizan> in fact Arrow is a terrible name for the class
08:15:35 <CaptainK> I want my money back!
08:15:40 <bakibour> :)
08:21:28 <mm_freak> hpaste alternative?
08:21:56 <mm_freak> oh, seen the topic
08:22:09 <mm_freak> what happened to hpaste?
08:22:24 <Clint> apparently bos is refusing to talk to anyone
08:22:44 <sordina1> Hey guys, is there a version of fold that yields a list of its progress?
08:23:05 <acube> @ty scanr
08:23:16 <acube> Aw, lambdabot :(
08:23:18 <sordina1> acube: thanks!
08:23:23 <Saizan> scanl too
08:23:42 <sordina1> I'd forgotten what it was called and was starting to doubt my sanity
08:23:48 <CaptainK> your fired lambdabot!
08:23:56 * hackagebot hledger-web 0.21.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.21.3 (SimonMichael)
08:24:46 <mauke> *you're
08:25:37 <CaptainK> :P god I need a bot to correct my grammer
08:25:45 <mauke> *grammar
08:25:47 <mauke> *spelling
08:25:49 <CaptainK> lol
08:25:55 <CaptainK> i give up
08:26:02 * CaptainK throws hands in air
08:26:04 <mauke> *I
08:26:09 * mauke stops
08:26:22 <mm_freak> are all my old pastes lost now?
08:26:23 * CaptainK /throughs hands in air
08:27:21 <CaptainK> mauke: maybe cause your good at correcting me :P
08:27:41 <CaptainK> http://ideone.com/z69Dx0
08:28:00 --- mode: mauke set +oooo byorgey Cale copumpkin dcoutts
08:28:00 --- mode: mauke set +oo dolio jmcarthur
08:28:00 --- mode: mauke set +o monochrom
08:28:21 <CaptainK> need to get just the beginning entry of a list, but getting multiple elements
08:28:49 <acube> CaptainK: Use isPrefixOf
08:28:52 <CaptainK> was working on this yesterday, but found instances where if the word is by itself, it matches
08:29:12 <CaptainK> acube: import Data.List, lol back to that again
08:29:26 <CaptainK> is there a way to do it in Prelude
08:32:36 <acube> CaptainK: What do you want to do exactly?
08:33:05 <CaptainK> same as isPrefixOf, but in Prelude using pattern matching
08:33:34 <mauke> why?
08:33:50 <CaptainK> because I'm a horrible person
08:34:21 <CaptainK> jk, more of a purist, trying to do it without any imports
08:34:59 <pentace> > let p ('f' : 'o' : 'o' : _) = True; p _ = False in p "foobar"
08:35:27 <acube> ugly: and . zipWith (==) "yourword"
08:35:30 <CaptainK> lambdabot is on vacation
08:36:32 <acube> But and . zipWith (==) "xxx" is in Prelude :D
08:38:02 <klrr> do i need to know how to use arrows to use yampa? if so, is there any good arrow tutorial someone could recommend?
08:38:31 <merijn> mm_freak: Might be, depends on whether bos gets back to us at some point
08:39:16 <mm_freak> klrr: yes, for yampa you need to understand arrows  i can offer my still unfinished arrow tutorial  it should give you enough information to start
08:39:53 <mm_freak> klrr: http://ertes.de/new/tutorials/arrows.html
08:40:10 <klrr> mm_freak: thanks, is arrows harder or easier than monads to learn?
08:40:25 <mm_freak> klrr: neither
08:40:33 <mm_freak> but my tutorial assumes familiarity with monads
08:40:43 <klrr> is it super mega harder, well i know about monads so that's good :D
08:41:08 <mm_freak> klrr: arrows are "not quite monads"
08:41:18 <yitz> CaptainK: use (== [x]) . take 1 instead of elem x
08:41:36 <mm_freak> klrr: some design patterns can't be encoded as monads, and yampa's SF is one of them
08:41:50 <klrr> mm_freak: well i dont really know what monads IS, just how they work and different kinds of monads that's useful
08:42:00 <klrr> ok
08:42:15 <mm_freak> klrr: monads are monads, a bunch of axioms, nothing more
08:42:24 <mm_freak> if you have something that fits those axioms, that something is a monad
08:42:25 <klrr> what's axioms? xD
08:43:01 <mm_freak> just like natural numbers are a bunch of axioms:  roughly speaking there is a zero, and every natural number has a distinct non-zero successor natural number
08:43:25 <mm_freak> so [], [()], [(), ()],  is a set of natural numbers, because it fits the axioms
08:43:31 <mm_freak> so is data Nat = Zero | Succ Nat
08:43:56 <b2coutts> klrr: in this context, axioms are just a set of criteria something can satisfy
08:44:02 <klrr> mm_freak: okey, i think about monads as something that works with >>= and <- and also i think it as a computation, not simply a function, is that correct way to think about it?
08:44:13 <Gracenotes> CaptainK: yeah, importing Data.List should not be a problem, especially if you are manipulating lists
08:44:16 <mm_freak> klrr: for some monads
08:44:17 <Gracenotes> I do it all the time
08:44:35 <ab9rf> not all monads represent a computation, only certain monads
08:44:36 <dmwit> yitz: or ([x] `isPrefixOf`) ;-)
08:44:38 <mm_freak> klrr: haskell monads are characterized by the two functions (>>=) and `return`
08:44:41 <klrr> i wouldnt be able to implement the IO monad myself for example, but i can use it and other monads
08:44:49 <mm_freak> klrr: and the corresponding axioms
08:44:53 <CaptainK> Gracenotes: true that, just looking for a way, to mostly help expand my already tiny understanding of haskell
08:44:55 <yitz> dmwit: CaptainK does not want to import anything not in the Prelude
08:45:03 <Gracenotes> maybe False (==x) . safeHead
08:45:18 <Gracenotes> (at least one of those not in the Prelude)
08:45:26 <yitz> Gracenotes: unfortunately, safeHead is not in the prelude. take 1 is the closest we have.
08:45:42 <dmwit> I see. Well, that's silly.
08:45:46 <yitz> Gracenotes: maybe is there though :)
08:46:04 <mm_freak> klrr: an "XYZ axiom" pretty much means a "formal requirement to be an XYZ"
08:46:07 <Gracenotes> Haskell has a modicum of battery included
08:46:21 <sm> damn.. I uploaded a bad tarball to hackage. How could I get it removed ?
08:46:24 <CaptainK> yitz: filter ((== "bares") . take 1) -- produces []
08:46:45 <dmwit> CaptainK: See if you can figure out why.
08:46:46 <yitz> CaptainK: leave in the words. just replace elem x with what i wrote.
08:47:03 <CaptainK> ok, trying
08:47:15 <yitz> dmwit: you're right, should have said that :)
08:47:32 <dmwit> sm: I don't know of a way. Upload a new version with a bigger number instead.
08:47:37 <yitz> sm: email ross
08:47:40 <klrr> mm_freak: okey, well then it's exactly the level i am at i think :D
08:47:48 <yitz> sm: it works. i've done it. ;)
08:48:14 <dmwit> Ah, yes, the old "contact the guy with root" trick. I always forget that one.
08:48:15 <sm> yitz: thanks, is that the city.ac.uk address ?
08:48:24 <yitz> yes i think so
08:48:30 <yitz> ross paterson
08:48:53 <CaptainK> yitz: put in "" what I'm to write
08:49:09 <yitz> CaptainK: ?
08:49:12 <CaptainK> as a newbie its hard to see whats function and declaration
08:49:28 <mm_freak> klrr: feedback always welcome =)
08:49:36 <CaptainK> filter ((== "bares") . take 1 .words) dictwords
08:50:00 <hamid> CaptainK, you have to practice :P
08:50:55 <yitz> CaptainK: that ought to work with the data in your paste. you say you're getting [] ?
08:51:06 * CaptainK wonders why there is follow the white rabbit output knock knock..., brb
08:51:25 <yitz> grrr need lambdabot where are you ???
08:51:39 <Gracenotes> someone volunteer
08:51:46 <ab9rf> i think lambdabot took the red pill
08:53:59 <dmwit> > "test"
08:54:02 <goodfellow>   mueval-core: GhcException "cannot satisfy -package lambdabot: \n    lambdab...
08:54:11 <dmwit> ...that looks good
08:54:15 <dmwit> ship it
08:54:17 <CaptainK> yitz: http://ideone.com/PWte2B
08:54:18 <goodfellow> Title: Ideone.com | Online Haskell Compiler & Debugging Tool
08:54:23 <dolio> Yeah. Those two strings are semantically identical.
08:54:30 <dmwit> ?quit
08:54:58 <yitz> thanks for the try, goodfellow
08:55:31 <dncr> If I want to write a long list of short strict bytestrings to a file (overwriting if the file already exists), (BS.writeFile f . BSC.unlines) is bad for pre-assembling in memory. Is it better to instead use: 1) BSL.fromChunks, or 2) BS.writeFile and repeated BS.appendFile?
08:56:14 <yitz> CaptainK: good, that's what you wanted, isn't it?
08:56:33 <CaptainK> yes, thanks!
08:56:47 <dmwit> dncr: I would expect writeFile/appendFile to be constantly opening and closing the file. Probably not what you want.
08:57:35 <dncr> dmwit: ok, then replace that with 2b) opening a handle and doing my own appends
08:58:00 <dmwit> In that case, I expect 1 and 2b to be basically identical.
08:58:17 <dmwit> Lazy bytestrings are basically a newtype wrapper around lists of strict bytestrings.
08:58:36 <dmwit> You might want to look at that thing... don't remember what it's called...
08:58:39 <dmwit> blaze-builder or something?
08:58:48 <dncr> I'm not sure how to interpret that BSL.fromChunks is "O(c)", I guess it will be O(1) for a lazy list?
08:59:09 <fijimunkii> 0
08:59:33 <yitz> dncr: linear in the number of chunks
09:00:06 <yitz> dncr: in normal usage, that will be linear in the number of characters with a very small coefficient.
09:00:10 <dmwit> I guess these O notation things are for fully-forced values.
09:00:17 <dncr> ok
09:01:46 <dncr> I guess I don't have to feel bad about using BSL.fromChunks, and it's going the other way (lazy -> strict) which is usually bad.
09:02:19 --- mode: calvino.freenode.net set +o ChanServ
09:03:03 <dmwit> > "test"
09:03:03 <goodfellow>   "test"
09:03:09 <dmwit> neat
09:03:13 <yitz> dncr: only bad if you expect the lsb to be really huge
09:03:17 <yitz> *lbs
09:03:19 <dmwit> ?tell elliott You're a goodfellow admin. Enjoy!
09:03:20 <goodfellow> Consider it noted.
09:03:26 <yitz> @botsnack
09:03:26 <goodfellow> :)
09:04:09 <yitz> dmwit: thanks!
09:04:16 <dmwit> :)
09:04:47 <monochrom> dncr: lazy bytestring is not lazy byte by byte. it is lazy chunk by chunk, each chunk is 64KB IIRC. it gets one whole chunk done or nothing at a time.
09:04:47 <pentace> > last [1..]
09:04:51 <goodfellow>   mueval-core: Time limit exceeded
09:05:47 <dmwit> > last [1..1000000]
09:05:48 <goodfellow>   1000000
09:05:55 <yitz> > length . takeWhile (>0) $ iterate (`div` 2) (maxBound :: Int)
09:05:55 <goodfellow>   63
09:06:28 <dmwit> > 2^1024
09:06:29 <goodfellow>   179769313486231590772930519078902473361797697894230657273430081157732675805...
09:06:40 <dmwit> > 2^(2^20)
09:06:40 <goodfellow>   674114012549907340226906510470424543762018594853268828469449156767422707007...
09:06:44 <dmwit> > 2^(2^30)
09:06:49 <goodfellow>   mueval: ExitFailure 1
09:06:49 <goodfellow>  mueval: Prelude.undefined
09:06:58 <yitz> @vixen how old of a bot are you?
09:06:58 <goodfellow> 19, you?
09:07:02 <yitz> yay!
09:07:39 <yitz> just hope the comment are from an era when they weren't *too* offensive
09:07:42 <yitz> comments
09:07:48 * dmwit shrugs
09:07:54 <dmwit> This is just "cabal install lambdabot".
09:08:04 <klrr> mm_freak: are you the author of netwire?
09:08:17 <dmwit> And then changing its nick/admin list.
09:08:32 <yitz> dmwit: amazing that still works
09:08:48 <dmwit> Didn't you hear? lambdabot actually has a maintainer now.
09:08:54 <dmwit> There was a release less than a month ago.
09:09:24 <bb010g> What happened to lambdabot?
09:10:12 <yitz> > System.Info.compilerVersion
09:10:13 <goodfellow>   Not in scope: `System.Info.compilerVersion'
09:10:23 <yitz> bb010g: went belly up
09:10:43 <dmwit> Glorious yadda yadda, 7.6.3
09:10:53 <bb010g> And goodfellow's stepping in?
09:11:04 <yitz> dmwit: wow and that old \bot still compiles. fantastic.
09:11:15 <yitz> bb010g: yes, thanks to dmwit
09:11:22 <dmwit> yitz: no... this is new \bot
09:11:31 <dmwit> old \bot required 7.0 or older
09:11:35 <yitz> dmwit: oh the one elliot is working on?
09:12:02 <yitz> and vixen is still in there? well what do you know.
09:12:06 <dmwit> This is the one m0kus is working on. Presumably elliott's changes are being sent to him, though I'm not confident of that.
09:12:15 <yitz> ah ok.
09:12:22 <dmwit> The code for vixen was never removed. Just the configuration file was changed.
09:12:27 <yitz> got it
09:23:57 * hackagebot hsbencher 1.3.1 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.3.1 (RyanNewton)
09:23:58 <goodfellow> Title: HackageDB: hsbencher-1.3.1
09:25:43 <mm_freak> klrr: yes
09:25:59 <AsgardBSD> EvilTownCat: Hey, arent you on archlinux also?
09:27:22 <klrr> mm_freak: cool =o
09:31:29 <klrr> mm_freak: what does opaque mean?
09:32:07 <mm_freak> klrr: all you can do with a function is to apply it or pass it to other functions
09:32:16 <klrr> okey
09:32:38 <mm_freak> in most other languages you can get stuff like function addresses or even source code  none of that is available in haskell
09:33:25 <Y_Less> Does anyone know of any bugs in GHC related to Vectors and -O2?  My code works slowly without that flag, but fails with.  I'm trying to narrow down the cause further but thought I would ask.
09:34:57 <klrr> mm_freak: also, i dont get what runState is, it's seems to be a function in its type declaration, but it's not defined anywhere what the funciton does
09:36:50 <Y_Less> runState evaluates a series of computations that are ordered and pass psudo-global state between them
09:37:26 <Y_Less> I didn't explain that well
09:37:42 <klrr> but the function runState isnt defined anywhere
09:37:50 <klrr> it's just a type singature
09:37:53 <Y_Less> http://www.haskell.org/hoogle/?hoogle=runState
09:37:54 <goodfellow> Title: runState - Hoogle
09:38:14 <klrr> oh
09:38:14 --- mode: calvino.freenode.net set +o ChanServ
09:38:19 <Y_Less> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-State-Lazy.html#runState
09:38:20 <goodfellow> Title: Control/Monad/Trans/State/Lazy.hs, http://tinyurl.com/k3plalc
09:38:25 <klrr> but why is State a record, it all gets messy in my head..
09:38:40 <int-e> klrr: if you have  data State s a = State { runState :: s -> (a, s) }  then that defines a function runState that accesses the record field with that name
09:38:53 <int-e> so  runState :: State s a -> (s -> (a, s))
09:39:07 <monochrom> so-called "record" in haskell just adds syntax sugar
09:39:09 <klrr> yes but why put it in a record?
09:39:26 <int-e> so it can have interesting class instances without making a mess
09:39:29 <dolio> To auto-generate the function.
09:39:54 <dolio> Saves one line.
09:40:00 <monochrom> using "record" syntax does not make the type different
09:40:11 <klrr> so ghc figures out how the funciton works, so i can write data Game = Game a b c { makeAnAwesomeGameForMe :: Blbblabl -> IO () }
09:40:30 <monochrom> that is a syntax error
09:41:19 <Y_Less> Anyway, in the link I gave runState is just a function not a record
09:41:45 <klrr> i cant understand how yuou even can have a function inside a record, i the records stuff only took a record as argument and returned a certain value
09:42:04 <dolio> Functions are values.
09:42:12 <monochrom> do you mind reading the Haskell Report? this section: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-690004.2.1
09:42:12 <c_wraith> klrr: functions are values.  you can put a value inside a record
09:42:14 <goodfellow> Title: 4 Declarations and Bindings, http://tinyurl.com/ccfjmh2
09:42:15 <klrr> so
09:42:31 <Gracenotes> hm.. was that necessary.
09:42:36 <klrr> also i dont get how State even work or how to use the crap, does it work like IORef?
09:42:48 <Gracenotes> and does that tinyurl perhaps point to some malware-ridden site? who knows.
09:42:48 <c_wraith> State is just a function
09:43:00 <klrr> it's a datatype
09:43:04 <klrr> funcitnos are lowercase
09:43:08 <monochrom> use tinyurls at your own risk :)
09:43:11 <dolio> That's some ancient lambdabot stuff.
09:43:13 <c_wraith> It extracts the pattern s -> (s, a)  into a data type
09:43:28 <c_wraith> So that you don't need to handle the argument chaining manually
09:43:28 <Gracenotes> oh, we have a substitute
09:43:44 <klrr> but where is the s -> (s, a) comes in, i dont get it, in mm_freak it's not defined anywhere
09:43:48 <dolio> dmwit: Can you turn off the URL shortening plugin in goodfellow?
09:44:04 <klrr> arrows is SHIT FRP crap anal
09:44:11 <Gracenotes> wat
09:44:31 <whald> the wiki for cabal says that resources to be used by the program should go to the "dist/resources" subdirectory. but it gives no hint how to access those resources at runtime :-/ can someone tell me how to deal with static resource files?
09:44:31 <monochrom> not all confused minds are meant to be deconfused
09:44:40 <c_wraith> guess so
09:45:02 <monochrom> I think he's learning too many things at once, and also lacking some very basic things to start with
09:45:09 <dcoutts> whald: http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
09:45:10 <goodfellow> Title: Cabal User Guide, http://tinyurl.com/chq232g
09:45:24 <ab9rf> monochrom: no, he's been like that for a long time now
09:45:25 <c_wraith> State *is* confusing at first.  It's not a great place to start.
09:45:36 <monochrom> then he may be trolling
09:45:50 <whald> dcoutts, cool, thanks!
09:48:10 <Cale> Hey what, why are we all +o'ed?
09:48:13 <chrisdone> mm_freak: no, your pastes aren't lost. the only thing changed is the domain
09:48:23 <mm_freak> chrisdone: great, thanks
09:48:34 --- mode: Cale set -ooo byorgey Cale copumpkin
09:48:39 <int-e> Cale: no services
09:48:42 <chrisdone> Cale: i'm not +o'd. +o me and i'll confirm the +o'ness
09:48:49 <Cale> oh, heh
09:49:14 <dolio> Really?
09:49:26 <monochrom> chanserv will be intermittent.
09:49:28 <Gracenotes> in a future where only humans rule the desolate wasteland known as freenode...
09:49:35 <dolio> Ah.
09:49:48 --- mode: monochrom set +ooo Cale byorgey copumpkin
09:49:50 <Cale> I was going to -o us all, but my client decided to make me one of the first annoyingly -- but that's probably a good thing if services are down :P
09:50:16 <int-e> saved by the alphabet
09:50:47 <chrisdone> there should be a super hero whose power is alphabetization and alphabetism
09:50:48 <djahandarie> Fail by Cale there lol
09:52:27 <Cale> djahandarie: apparently XChat :P
09:53:17 <Cale> You'd think if it's smart enough to split mode changes into multiple parts, it would be smart enough to realise that deopping yourself as part of the first chunk wouldn't be wise :P
09:53:53 <Cale> Anyway, why the heck are services down?
09:54:07 <geekosaur> DoS attack
09:54:18 <geekosaur> which by now you should be used to on freenode...
09:55:29 <monochrom> I have a theory. it all started with me banning someone.
09:56:12 <josephle> so they take it out on all of freenode? That's quite the overreaction
09:56:12 <Gracenotes> oh, those efnet hoodlums
09:56:44 <Gracenotes> or maybe quakenet? all not to be trusted.
09:57:26 <monochrom> <defrinh> A = 10, B = 8, and C = 5 <defrinh> (B + A) / C * C  A * C ^ (A  B) % B  B % C * (C  3)  C % B
09:57:32 <monochrom> [some time later]
09:58:28 <monochrom> <monochrom> wrong channel <shachaf> defrinh: As monochrom said, wrong channel. <defrinh> It is programming math   *** monochrom sets mode: +b $a:perdent *** defrinh was kicked by monochrom (defrinh)
09:59:03 <monochrom> an hour later, a lot of "niggers" "fuck" spam began
10:01:47 <monochrom> and since we were very successful at blocking that too, they must have ramped up their effort :)
10:03:25 <b2coutts> and then if freenode manages to block them as well, the next logical step will be to attack the internet
10:03:31 <CaptainK> kids can't play nice in the sandbox
10:03:47 <CaptainK> > karma ytiz
10:03:48 <goodfellow>   Not in scope: `karma'Not in scope: `ytiz'
10:08:49 <CaptainK> yitz++
10:08:58 <CaptainK> @karma yitz
10:08:58 <goodfellow> yitz has a karma of 1
10:09:10 <CaptainK> yitz++
10:09:12 <CaptainK> @karma yitz
10:09:13 <goodfellow> yitz has a karma of 2
10:09:18 <CaptainK> cool
10:09:58 <CaptainK> @karma CaptainK
10:09:59 <goodfellow> You have a karma of 0
10:10:02 <CaptainK> :(
10:10:10 <int-e> @karma
10:10:11 <goodfellow> You have a karma of 0
10:10:32 <CaptainK> always a more efficient way :P
10:10:55 <Gracenotes> @kar
10:10:56 <goodfellow> Maybe you meant: karma karma+ karma- karma-all yarr part keal faq arr
10:11:07 <Gracenotes> @yarrrr
10:11:07 <goodfellow> Aye
10:11:11 <CaptainK> lol
10:11:16 <CaptainK> @k
10:11:17 <goodfellow> Maybe you meant: karma karma+ karma- karma-all keal kind v @ ? .
10:11:45 <int-e> haha.
10:11:47 <int-e> @karma <
10:11:47 <goodfellow> < has a karma of -1
10:12:41 <int-e> <-- cannot imagine how that happened. ;-)
10:12:51 <lingxiao> hi all
10:13:16 <lingxiao> has anyone tried to use machines to describe a plan that might yield a list of results
10:13:26 <lingxiao> at which point the compuation would branch into each item in the list?
10:13:59 <tunixman> carter_away Ghoul_ Maybe, I haven't tried haskell on windows yet, but I do seem to have a windows workstation at work now.
10:14:06 <tunixman> I'm happy to see what I can do of course.
10:14:31 <CaptainK> can goodfellow turn ugly urls into tiny ones?
10:18:28 <klrr_> sry for my outrage
10:20:54 <CaptainK> klrr_: are you the one with tourettes?
10:21:15 <llks992> hello. I want to merge a list of pairs by key like this: [(1,2),(1,3)] -> [(1,[2,3])]. what would be the best way to do it? my first approach was to use Data.List groupBy to create lists with pairs of the same key and then map a function that accumulates the snd. entries as a list in the snd. entry of a tuple. would that be straightforward?
10:21:27 <klrr_> CaptainK: no diea what that is
10:22:14 <Gracenotes> sortBy fst, if necessary.
10:22:32 <Gracenotes> otherwise, groupBy would work well.
10:22:46 <Gracenotes> Data.Map might also do a good job if you're into that.
10:23:18 <circle> what does it mean in an error when it says "with actual type `[a0] -> [b0]"
10:23:48 <ab9rf> circle: because that was the inferred type that didn't match the declared type.
10:23:56 <klrr_> circle: that it has wrong type
10:23:57 <ab9rf> where a0 and b0 are free type variables
10:23:59 <circle> yeah but what is "a0
10:24:38 <klrr_> a variable
10:24:40 <Gracenotes> GHC says "Based on context, I want a function from a list to another list here, and I've figured out enough to know you don't have that."
10:24:43 <geekosaur> the whole point is that it has no idea
10:24:47 <klrr_> not sure why it's not simply a
10:24:50 <geekosaur> it knows it's a distinct type but has no idea what
10:24:51 <klrr_> "a"*
10:25:09 <ab9rf> a, a0, no real difference
10:25:25 <geekosaur> and the variable name depends on idiosyncracies of how ghc's type inference works and is of no real significance
10:25:35 <ab9rf> it probably allocated 'a' to some other type that was successfully unified
10:25:46 <ab9rf> it's possible that a is unified with [a0] in that situation
10:26:09 <geekosaur> if *you* use a type variable, it will make some slight attempt to retain that name... but that can fail
10:26:12 <ab9rf> but it really does not matter
10:28:58 * hackagebot fb 0.14.9 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.9 (FelipeLessa)
10:28:59 <goodfellow> Title: HackageDB: fb-0.14.9
10:29:15 <mm_freak> klrr_: runState is defined in the tutorial
10:29:30 <mm_freak> pay more attention to the definitions =)
10:29:44 <mm_freak> see the beginning of section 3.1
10:30:09 <carter> tunixman yay :)
10:31:18 <klrr_> mm_freak: i cant find it, i only find a type signature
10:31:35 <tunixman> carter I'm installing the Haskell Platform now.
10:31:42 <carter> tunixman woo
10:31:59 <carter> tunixman I think the real issue is ghoul couldn't get ghc to find llvm stuff in path
10:32:01 <bb010g> @karma++ dmwit
10:32:02 <goodfellow> dmwit's karma raised to 1.
10:32:05 <carter> suspect it was a config issue
10:32:33 <klrr_> @karma++ dwit
10:32:33 <goodfellow> dwit's karma raised to 1.
10:32:34 <klrr_> @karma++ dwit
10:32:35 <goodfellow> dwit's karma raised to 2.
10:32:35 <klrr_> @karma++ dwit
10:32:35 <goodfellow> dwit's karma raised to 3.
10:32:35 <klrr_> @karma++ dwit
10:32:35 <goodfellow> dwit's karma raised to 4.
10:32:38 <klrr_> @karma++ dwit
10:32:38 <goodfellow> dwit's karma raised to 5.
10:32:40 <klrr_> @karma++ dwit
10:32:40 <goodfellow> dwit's karma raised to 6.
10:32:45 <ab9rf> klrr_: cut it out
10:33:09 <klrr_> he needs it
10:34:15 <erisco> klrr_, I gave him some karma for you
10:34:20 <carter> dmwit #ghc doesn't have lambdabot, can you help fix that? :)
10:34:31 <carter> *have a lambdabot
10:34:44 <carter> goodfellow is apparently yours? yitz would like it on #ghc
10:35:05 <erisco> no but I have connections
10:35:10 <erisco> also known as /msg ;)
10:35:53 <klrr_> arrows and frp is not good, it's too unnatural, it cant even be explained easily
10:35:57 <Cale> goodfellow is a temporary bot because lambdabot seems to be down until elliott gets back
10:36:13 <klrr_> @help
10:36:13 <goodfellow> help <command>. Ask for help for <command>. Try 'list' for all commands
10:36:16 <klrr_> @list
10:36:17 <goodfellow> What module?  Try @listmodules for some ideas.
10:36:23 <klrr_> @listmodules
10:36:23 <goodfellow> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlinerc pl pointful poll pretty quote search seen slap
10:36:23 <goodfellow> source spell system tell ticker todo topic type undo unlambda unmtl url version vixen where
10:36:30 <Cale> klrr_: Arrows aren't great as they currently stand, but something close to arrowised FRP works *quite* well.
10:36:40 <chrisdone> lambdanaught - space bot version of lbot
10:37:26 <klrr_> Cale: i dont get why they're useful and i dont get how they work or is used
10:37:30 <klrr_> they
10:37:32 <klrr_> are crap
10:37:49 <tunixman> llvm on windows?
10:37:50 <tunixman> wow.
10:37:52 <tunixman> alright.
10:38:00 <Cale> If you don't understand how they work, why are you making a judgment like that?
10:38:01 <carter> yeah
10:38:18 <geekosaur> "I don't understand them, clearly they will never be any good ever"
10:38:20 <carter> tunixman you have visual studio or are you using mingw?
10:38:22 <klrr_> Cale: since i cant use them if i dont understand them, they're useless for me
10:38:36 * erisco nom nom nom troll
10:38:45 <klrr_> geekosaur: how am i supposed to see how they are usefull if i cant understand them?
10:38:48 <klrr_> i cant
10:38:52 <ab9rf> klrr_: then move on.
10:38:52 <klrr_> and i cant learn them since they're too difficult
10:38:56 <geekosaur> and this makes them permanently broken
10:39:05 <geekosaur> because you yourself are the sole arbiter of such things
10:39:09 <Cale> klrr_: Anyway, I've used arrowised FRP for an action RPG (which is currently unfinished and the company is on extended hiatus while the founder puts together more money), and our Arrowy FRP system worked quite well.
10:39:10 <klrr_> move on to another language , start over, haskell is only for smart people...
10:39:15 <ab9rf> geekosaur: solipism is all the rage these days
10:39:43 <erisco> Cale, isn't that every start up game studio ever? (once you throw out the erroneous outliers aka successful studios) :P
10:39:56 <klrr_> in a normal language you can simply get input without any shitty abstraction, and you can still have pure functions
10:40:11 <Gracenotes> 2/10 tbh
10:40:20 <Cale> klrr_: FRP is ultimately about making sure that you don't lose updates.
10:40:31 <tunixman> I have visual studio right now, but could probably add mingw.
10:40:41 <carter> tunixman may be easier with VS
10:40:45 <carter> dude was using mingw
10:40:46 <carter> idk
10:40:47 <Cale> klrr_: A game is generally a giant clusterfuck of things which change over time in various ways, and which cause each other to update
10:41:00 <carter> wow, the ops are out openly today
10:41:00 <tunixman> I've never used mingw actually. Only cygwin and VS.
10:41:02 <carter> what happened?
10:41:04 <tunixman> But I can try it.
10:41:09 <Cale> carter: services are down
10:41:11 <erisco> Cale, I'd say it is ultimately about conciseness, but correctness is indeed a problem with convoluted code
10:41:16 <ab9rf> carter: services are down because freenode is being abused
10:41:18 <klrr_> Cale: but that doesnt matter, you can still make games that way, FRP is impossible since you need to know about stupid sillyt arrow crap
10:41:29 <carter> what services?
10:41:35 <Cale> klrr_: *Most* bugs in a game generally come out of things being updated in the wrong order, and updates being lost as a result.
10:41:42 <ab9rf> carter: irc services.  nickserv/chanserv/burpserv
10:41:51 <carter> ahhh
10:41:52 <Cheery> wow 1000 nicks
10:42:06 <Cheery> hi everyone
10:42:28 <carter> @Cale have you had a look at llvm-general?
10:42:28 <goodfellow> Unknown command, try @list
10:42:29 <Cale> klrr_: FRP is about producing declarative descriptions of how the changes in various things affect one another, and leaving it up to a library to determine the correct way to update them all efficiently and correctly.
10:42:29 <Cheery> I'm trying to implement type inference.
10:42:31 <josephle> arrows are really elegant and nice to use, but woe is me when I forget (&&&) duplicates monadic actions and not just results
10:42:33 <Cheery> anyone know nice algorithm?
10:42:53 <carter> Cheery depends on the type system you're trying to infere!
10:42:59 <Cale> klrr_: The arrow stuff is really not the hard part at all
10:43:17 <erisco> Cale, you say determine... wouldn't this determination be runtime? and the perf factors are largely based on push vs pull no?
10:43:39 <Cale> klrr_: I also don't understand why you seem to be so upset about it -- there are really not that many libraries which use the Arrow abstraction, so it's quite optional to learn it.
10:43:44 <klrr_> Cale: okey, so if i dont get arrows i will not get FRP, so basically im gfucking fucked, i should quit programming and become a street cleaner or legist
10:43:58 * hackagebot monitor 0.1.1 - Do things when files change.  http://hackage.haskell.org/package/monitor-0.1.1 (MartinStensgard)
10:43:59 <klrr_> FRP IS THE FUCKING FUTURE
10:43:59 <goodfellow> Title: HackageDB: monitor-0.1.1
10:44:06 <Cheery> carter: I'm bit ignorant about the type of type system. can you help me out?
10:44:11 <ab9rf> why do we continue to let this troll troll?
10:44:22 --- mode: calvino.freenode.net set +o ChanServ
10:44:24 <klrr_> elm, frag, and some game studios is using it for REAL GAMES
10:44:25 <Cale> erisco: It's a combination of runtime and static
10:44:31 <ab9rf> wee, chanserv is back!
10:44:34 <klrr_> ab9rf: i dont troll, i am angry
10:44:36 <carter> ab9rf who's trolling?
10:44:37 <Gracenotes> as an aside, there's reactive programming without functional, and also functional reactive programming without arrows.
10:44:42 <Gracenotes> ab9rf: for now, at least
10:44:55 <Cale> klrr_: I completely fail to comprehend why someone would be angry about this.
10:45:12 <erisco> Cale, these are Haskell libraries yeah? how is any static analysis done? compiler extensions?
10:45:19 <albertov> Hi, I'm trying to write a binding to the GDAL library and wondering if there is a way to call an external program to retrieve some values for the .cabal file, something like: extra-lib-dirs: $(gdal-config --libs)
10:45:22 <klrr_> since i cant learn it , and others can, which means i dont have enough brain capasity to learn the fucking crap
10:45:52 <klrr_> i wish i was from india and believed in hinduism, since then i could easily get a better brain
10:46:00 <carter> klrr_ it takes and sleep to learn new things
10:46:13 <carter> erisco so you can also  optimize things at run time
10:46:21 <carter> depending on how you're exectuign it
10:46:34 <klrr_> also, in the fucking process i realized i havent understood fucking monad shit and fucking applicative functors
10:46:37 <Cale> erisco: Possibly! You can also arrange a lot of stuff which might be done by the compiler is instead done very early on at runtime -- taking the arrow computation which encodes (most of) your game and turning it into a graph and translating that into a more efficient form.
10:46:56 <Cheery> carter: would it help if I described the types I allow?
10:47:01 <carter> Cheery yes
10:47:13 <carter> and which type systems you're taking ideas from
10:47:29 <Cale> Arrow is almost exactly what you need in order to extract a graph of your whole computation -- but unnecessary uses of arr tend to get in the way of doing that kind of analysis
10:47:31 <carter> and then that combo will fall in one of "solved" or "interesting research question"
10:48:14 <Cale> klrr_: If you calm down and take your time, I'm sure you'll get it in time. How long have you spent learning Haskell so far?
10:48:25 <Gracenotes> knowing what you don't know is the first step to knowing things. so that is good.
10:48:28 <Cale> klrr_: I've been programming in Haskell for over a decade.
10:48:47 <carter> @Cale are you using heterogenuous arrows or normal ones?
10:48:47 <goodfellow> Unknown command, try @list
10:49:10 <carter> klrr_ i've been using haskell for > 8 years too, i've only gotten *good* in the past 2
10:49:23 <erisco> Cale, and do you know roughly what these optimizations might be? you can't rearrange the graph ... the perf differences that I can indentify are push versus pull, where you want frequent updates to be pulled and rare updates to be pushed
10:49:24 <klrr_> Cale: i dont rememeber, ive tried learn it before so when i started i already had a foundation, so i knew all pure funciton crap and such, some months, maybe over 4 or more
10:49:36 <Cale> Our Arrow class is more like a direct formalisation of the data which goes into monoidal categories
10:49:38 <carter> 4 months?
10:49:40 <Cheery> carter: I need inference for something that has types like C has, but in addition I have generic functions and something similar to C++ templates.
10:49:44 <josephle> carter: what is your definition of good? Just for reference :P
10:49:44 <erisco> Cale, but you can't understand those implications from static analysis alone ... so I don't know what the static part would get you
10:50:01 <carter> josephle my definition of good may be a bit over the top
10:50:12 <klrr_> people can do stuff in other languages, i cant do a shit since i need to learn new abstraction to even make something work
10:50:17 <carter> josephle i am possibly getting some patches into GHC and LLVM soon (very simple ones mind you)
10:50:29 <erisco> Cale, other than some finagling of the code generation if you extended the compiler, but that might be minor improvements
10:50:32 <carter> klrr_ sounds like you're stressed out and short on sleep
10:50:41 <Cale> erisco: There are lots of things you can do to the (typed, heterogeneous) graph once you have it in an explicit form.
10:50:52 <carter> Cheery C++ templates are lambda calculus at the type level....
10:50:58 <klrr_> carter: no time for that, im working on the day so i have to learn on the night
10:51:02 <burkaman> klrr_: dude Yampa and arrows are not easy for anybody
10:51:08 <burkaman> nobody learns this stuff in a few days
10:51:11 <carter> yes
10:51:14 <Cale> erisco: It's quite complicated actually doing them all...
10:51:32 <carter> @Cale have you seen conal's hacking recently?
10:51:32 <goodfellow> Unknown command, try @list
10:51:37 <Cale> Not recently
10:51:50 <carter> he's got a monoidal category thing on githbu
10:51:56 <klrr_> they fucking do, there's fuckjing programmers that are under 15 and can code useful stuff
10:51:57 <carter> https://github.com/conal/lambda-ccc
10:52:11 <CaptainK> @quote kirr_
10:52:11 <goodfellow> No quotes match. Maybe you made a typo?
10:52:17 <burkaman> klrr_: any topic where the best learning resources are academic papers is going to be tough
10:52:21 <carter> klrr_ you don't need to use arrows for ANY task in ahskell
10:52:32 <erisco> Cale, the abstract idea is simple, but yes, implementation is another thing. I am just curious about what general knowledge you might have, since I will be working on such a thing sooner or later
10:52:32 <carter> so don't gate your learning that way
10:53:24 <klrr_> but i want to make a game development framework like love2d so i can make games, and the best way is to use FRP since then you can get stuff like in Elm like Mouse.position and such essential stuff
10:53:30 <Cale> erisco: Well, the first thing we did was to replace Arrow with something that had everything that the proc/do notation needed to wire results around made explicit
10:53:59 <carter> klrr_ yes, but you don't need to use arrows
10:54:05 <Cheery> http://bpaste.net/show/HL7pIpdmDuy5IQwieZBt/
10:54:06 <Cale> erisco: So that the only uses of arr in the translation of proc/do were complex expressions to the right of -< and complex patterns to the left of <-
10:54:06 <carter> and FRP has some subtle performance things
10:54:10 <erisco> there is no pinnacle or single ladder to climb, klrr_. comparing age with talent isn't meaningful
10:54:17 <klrr_> i have cause that other event and behavior stuff isnt like those in Elm
10:54:26 <mm_freak> klrr_: what's unnatural about AFRP?
10:54:28 <Cheery> carter: so I've thought about using this kind of type system.
10:54:42 <carter> Cheery you should take a step back
10:54:50 <carter> and see if you can embed the types you want in a current langauge
10:54:55 <Cale> erisco: This included things like  swap :: (Arrow (~>)) => (a,b) ~> (b,a)
10:54:56 <carter> Idris might be a sane choice
10:55:01 <klrr_> mm_freak: everything, proc, arr, and everything
10:55:11 --- mode: calvino.freenode.net set +o ChanServ
10:55:13 <burkaman> klrr_: how long have you spent trying to understand arrows?
10:55:21 <mm_freak> klrr_: that's a problem of yampa, isn't it?
10:55:22 <klrr_> this week
10:55:26 <carter> klrr_ i've never used arrows ever, but i can still write haskell code with C bits thats faster than fortran
10:55:28 <dmwit> ?join #ghc
10:55:39 <carter> @quote bscarlet
10:55:39 <goodfellow> No quotes match. :(
10:55:43 <carter> darn
10:55:43 <erisco> klrr_, also, such reputations are over-sensationalized, focused on a few things done well and blind to the larger picture
10:55:48 <mcstar> i think it is entirely possible that someone doesnt have the brain capcity to learn haskell if they decide on it a priori
10:55:59 <carter> mcstar nope
10:56:00 <erisco> klrr_, do you know the difference between efficiency and effectiveness?
10:56:02 <klrr_> carter: ive written programs, but i can only wirte simple SHIT crap like irc bots and lisp interpreters, i wanna write useful stuff that either me or other can use
10:56:05 <Cale> erisco: and explicit left and right isomorphisms between ((),a) and a and associators: assocl :: (a,(b,c)) ~> ((a,b),c), and its inverse assocr
10:56:09 <Cheery> carter: are you going to propose that whatever I'm doing is worthless?
10:56:15 <carter> Cheery nope
10:56:16 <carter> i'm saying
10:56:19 <carter> that is HARD
10:56:39 <klrr_> erisco: im trying to do that by learning arrows first then frp
10:56:40 <carter> and Idris has a lot of the machinery you need
10:56:43 <mcstar> carter: nope what?
10:56:48 <klrr_> now i will eat ice cream bbl
10:56:51 <Cale> erisco: and then we had a preprocessor which interpreted the proc/do syntax in terms of that, and which also relied on the law that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
10:56:54 <Gracenotes> enjoy ice cream
10:56:55 <carter> mcstar people can learn if they take the time
10:57:08 <carter> klrr_ arrows are not essential to FRP
10:57:13 <carter> ignore the press to the contrary
10:57:14 <mm_freak> klrr_: "i'm hiding the number right now" . buttonPressed <|> integral_ 0 . time  -- how is this unnatural?  it's not pseudo-code, it's actual netwire code, and netwire is AFRP
10:57:15 <Cale> erisco: This law was explicitly rejected by the original Arrow paper, and isn't true for most Kleisli arrows
10:57:29 <mcstar> no they cant, if they decide it is too abstract/convoluted/hard whatever for them
10:57:36 <Cale> erisco: However, I strongly believe it's true of every library for which the Arrow abstraction is actually appropriate.
10:57:50 <mm_freak> klrr_: you're just making the mistake to assume that you can master AFRP in an hour ;)
10:57:56 <carter> mcstar whatever, i politely disagree but dont' feel like debating
10:57:59 <burkaman> mcstar: it's not about brain capacity though
10:57:59 <Cheery> carter: I just look for some simple type inference here, for quite simple types.
10:58:01 <mcstar> or they dont have some fun in the meantime and they are not real geniuses
10:58:07 <conal> Arrow isn't essential to any functionality. just a structuring device. same for Monad, Applicative, Functor, etc.
10:58:10 <Cale> erisco: and it's *very* important for making the semantics of arrow computations easy to understand
10:58:13 <erisco> klrr_, trying to do what?
10:58:42 <byorgey> wait, the original arrow paper rejected (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k) , really??
10:58:45 <byorgey> wow
10:58:46 <Cale> yes
10:59:00 <Cale> Because it's untrue for Arrow instances arising from noncommutative monads.
10:59:07 <Cale> the order of g and h is swapped
10:59:12 <byorgey> ahh, right, I see
10:59:27 <erisco> Cale, I am not familiar with any of Haskell's approaches to FRP, but I do understand the idea abstractly, so I am still not sure what these laws allow you to do
10:59:30 <Cale> But allowing that to happen breaks the idea that Arrows form nice circuit diagrams.
10:59:37 <byorgey> Cale: right, exactly
11:00:09 <carter> @Cale how so?
11:00:10 <goodfellow> Unknown command, try @list
11:00:11 <Cale> So it's rather like trying to design electrical circuits where most of your components are allowed to communicate via radio signals with one another, and interfere.
11:00:11 <erisco> Cale, are you trying to exploit equivalences in order to cull certain updates? that doesn't seem sensical to me, but I don't know otherwise what you might be up to
11:00:30 <Cale> You have no lumped circuit abstraction anymore :)
11:00:35 <klrr_> also , i hate when there is much choice, it's good of experienced, since they can easily see which is best, but beginners CANT choose
11:00:57 <Cale> erisco: There's a lot of wiring noise to eliminate.
11:00:59 <conal> Having a denotational model of a data type (like AFRP signal functions), together with the type class morphism discipline, helps a lot. The laws for the data type then follow from the laws on the semantics, which are often already established.
11:01:08 <erisco> klrr_, oh come now. are you expecting to be made good by a particular product that only the pros know?
11:01:09 <bb010g> @src negate
11:01:09 <goodfellow> negate x = 0 - x
11:01:15 <bb010g> @src (-)
11:01:15 <goodfellow> x - y = x + negate y
11:01:23 <erisco> klrr_, I am not aware of any conspiracies or "trade secrets" of the sort
11:01:34 <Cale> erisco: you want to figure out where the results are going and eliminate all the crap that's between them, and possibly fuse updates together
11:01:35 <carter> conal @Cale  explain more?
11:01:41 <conal> carter: http://conal.net/papers/type-class-morphisms/
11:01:47 <goodfellow> Title: Denotational design with type class morphisms
11:01:47 <klrr_> i will try netwire instead
11:01:48 <bb010g> @src Float (-)
11:01:49 <goodfellow> Source not found. Abort, Retry, Panic?
11:01:51 <carter> PRINTIN NOW :)
11:01:53 <bb010g> @src Float negate
11:01:54 <goodfellow> Source not found. Just try something else.
11:02:00 <mm_freak> erisco: liftA2 (,) (h . fst) (k . snd) . liftA2 (,) (f . fst) (g . snd) = liftA2 (,) (h . f . fst) (k . g . snd)
11:02:04 <mm_freak> erisco: do you understand this law?
11:02:10 <Cale> It's hard to explain everything in detail here, especially without the context of the actual details of our library...
11:02:15 <carter> conal have you had a look see at llvm-general :)
11:02:18 <carter> ?
11:02:19 <conal> carter: and more laws can follow besides the class laws, like that >>>/*** interchange.
11:02:22 <carter> cool
11:02:37 <erisco> mm_freak, the law of longer expressions are more difficult to udnerstand?
11:02:41 <mm_freak> erisco: note that (.) is from Control.Category
11:02:46 <conal> carter: i don't think so. did we talk about llvm-general before?
11:02:53 <carter> nope
11:02:56 <carter> didn't exist then
11:03:09 <carter> bscarlet unveiled it ot the world this past 2-3 weeks
11:03:19 <klrr_> mm_freak: "arrow interface (or optionally an applicative interface)," means that you can work with signals(or wires they maybe is called in your library) with the arrow class methods, or the applicative class methods?
11:03:26 <erisco> Cale, yeah the stuff you are talking about sounds rooted in the technicals of implementation, and those inefficiences can be introduced for any number of reasons, including choice of design
11:03:26 <llks992> suppose I only want to change the second value of a certain pair in a list. when a recursive function goes through all pairs and finds one with a matching key, how do I only change the value of that pair without writing the key?
11:03:33 <mm_freak> klrr_: yes
11:03:38 <klrr_> ok
11:03:50 <Cale> erisco: Well, we were very much focused on our implementation.
11:03:53 <erisco> Cale, so I don't think that insight will be particularly helpful unless I do things similarly, but I'll know who to contact :)
11:03:56 <carter> its a very very nice llvm lib
11:04:01 <mm_freak> erisco: do you understand this one:  f . g <*> x = f . (g <*> x)
11:04:18 <Cale> erisco: For the obvious reason that if we weren't, it's quite easy to spend forever not actually getting anything done :)
11:04:38 <carter> klrr_ applicative is much eaasier to work with, and gives you much of the same power as arrows
11:04:46 <Cale> erisco: But yeah, I have some opinions about what Arrow ought to become
11:04:48 <valdyn> llks992: since you need to "write" the whole list, what does a single key matter?
11:04:50 <CaptainK> is there a more comprehensive example of bots usage?  This page needs updating: http://www.haskell.org/haskellwiki/Lambdabot
11:04:51 <goodfellow> Title: Lambdabot - HaskellWiki
11:05:02 <Cale> I don't think that Arrow in its present state in the libraries is particularly useful.
11:05:09 <klrr_> <*> == `fmap` ?
11:05:13 <Cale> But it's *very close* to something which is.
11:05:17 <mm_freak> klrr_: no, <*> is <*>
11:05:17 <Cale> <*> = `ap`
11:05:30 <llks992> valdyn: oh, you are right. so there is no way in haskell to prevent from rewriting that whole list? or is there some compiler magic involved?
11:05:33 <carter> :t (<*>)
11:05:34 <goodfellow> Applicative f => f (a -> b) -> f a -> f b
11:05:36 <klrr_> @eval (+2) <$> [1,2,3]
11:05:36 <mm_freak> @botsnack are you back, buddy?
11:05:37 <goodfellow> :)
11:05:39 <mm_freak> ah
11:05:43 <klrr_> @eval (+2) <*> [1,2,3]
11:05:51 <conal> @Cale: ditto. i make a great number of Arrow almost-instances.
11:05:51 <goodfellow> Unknown command, try @list
11:05:54 <Cale> > (+2) <$> [1,2,3]
11:05:56 <goodfellow>   [3,4,5]
11:06:07 <Cale> > [(+2),(*5)] <*> [1,2,3]
11:06:07 <valdyn> llks992: the list is backed by a structure that does this efficiently
11:06:08 <goodfellow>   [3,4,5,5,10,15]
11:06:12 <erisco> mm_freak, no I don't. I must be reading it wrong, because in my head the types aren't the same
11:06:12 <mm_freak> > [succ, pred] <*> [10, 20, 30]
11:06:14 <goodfellow>   [11,21,31,9,19,29]
11:06:16 <klrr_> > (+2 <*> [1,2,3])
11:06:16 <goodfellow>   The operator `GHC.Num.+' [infixl 6] of a section
11:06:16 <goodfellow>      must have lower prece...
11:06:22 <klrr_> > (+2) <*> [1,2,3]
11:06:23 <goodfellow>   Couldn't match expected type `[a0 -> b0]'
11:06:23 <goodfellow>              with actual type `a1...
11:06:26 <valdyn> llks992: you dont need to worry about writing the whole list in your case
11:06:30 <Cale> klrr_: see my example
11:06:40 <klrr_> Cale: ok
11:06:46 <klrr_> > [(+2),(*5)] <*> [1,2,3]
11:06:47 <goodfellow>   [3,4,5,5,10,15]
11:06:51 <klrr_> it's double <$> ?
11:06:59 <klrr_> it's dig into it two times?
11:07:00 <Cale> Not just double...
11:07:07 <llks992> valdyn: and rewriting the tuple is efficient too?
11:07:11 <erisco> Cale, well best of luck then. I just got burned by Applicative and Alternative so my loyalty to Haskell abstractions took a bashing
11:07:14 <mm_freak> erisco: oh sorry, i messed up
11:07:14 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [1,2,3]
11:07:15 <goodfellow>   [1,2,3,3,4,5,2,4,6,1,4,9,2,4,8]
11:07:23 <carter> Ghoul_ wooo, i see your issue is now on ghc trac
11:07:24 <carter> great
11:07:27 <carter> makes it much easier
11:07:27 <valdyn> llks992: yes
11:07:33 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [5,6,7]
11:07:34 <goodfellow>   [5,6,7,7,8,9,10,12,14,25,36,49,32,64,128]
11:07:42 <erisco> mm_freak, oh okay. I really am weak with Haskell so I wasn't sure
11:07:57 <llks992> valdyn: and efficient means no rewrites at all?
11:08:04 <Cale> klrr_: For lists,  fs <*> xs = [f x | f <- fs, x <- xs]
11:08:09 <valdyn> llks992: you cannot do some things efficiently, for instance the ++ operator on list is not efficient
11:08:20 <valdyn> llks992: but you dont have to worry about "copying" the list
11:08:28 <klrr_> applicative is mind-hard
11:08:28 <erisco> klrr_, it uses cartesian product, if you are familiar with that term
11:08:43 <Cale> valdyn: (++) is as efficient as it can be for lists
11:08:55 <klrr_> i dont know any difficult terms
11:09:17 <dmwit> where "difficult" means "terms klrr_ doesn't know" ;-)
11:09:22 <Cale> klrr_: Well, what Applicative library are you trying to use?
11:09:39 <klrr_> is there several ? o.o
11:09:41 <Cale> klrr_: Don't try to understand the abstraction first -- get to know some library which uses it
11:09:49 <yrrebaer> > (uncurry((.flip replicate 'a').(++).flip replicate 'A')=<<)$map([(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(4,2)]!!)$map(read.(:[]))"074433366333561263"
11:09:50 <valdyn> Cale: im sure it is
11:09:50 <goodfellow>   "AaaAAAAaaAAaaaAAaaaAAaaAAaaAAaaAAAaaAAAaaAAaaAAaaAAaaAAAaAAAaaAaaaAAaAAAaa...
11:09:56 <klrr_> WOT
11:10:04 <erisco> klrr_, are you familiar with expanding (x + y + z)*(a + b) ? same thing
11:10:04 <normalra> yrrebaer: Beautiful.
11:10:06 <klrr_> but tutorials ALWAYS starts with abstraction
11:10:31 <Cale> klrr_: I don't know which tutorials you're using, but I'm not sure that's true.
11:10:58 <mm_freak> erisco: anyway, it's a statemant about side effects
11:11:00 <Cale> klrr_: But in any case, I would recommend learning to use a number of monads before you try to understand what a monad is generally, for instance.
11:11:05 <Cale> and the same goes for Applicative
11:11:09 <Cale> (and Arrow)
11:11:17 <mcstar> what is wrong with not using haskell btw?
11:11:29 <Cale> mcstar: nothing?
11:11:38 <erisco> klrr_, I agree with Cale -- I am new to Haskell too and I don't find that any of the abstractions make sense out of context of their uses
11:11:52 <mcstar> i mean, if it is too hard for someone, then just simply ignore it
11:11:57 <mm_freak> erisco: (f *** g) . (h *** i) = (f . h) *** (g . i)
11:12:03 <roboguy_> klrr_: I'm not a haskell expert, but I usually think of applicative as applying a function in a context (given by the functor)
11:12:08 <mm_freak> erisco: imagine that the function category would not satisfy this law
11:12:27 <klrr_> but there's no programs to write, i cant figure out any program to write, that's why i was starting to learn FRP in the first place, since i had to do something with haskell
11:12:27 <roboguy_> for example:
11:12:29 <mcstar> i dont see myself gettin upset because i dont understand differential geometry
11:12:38 <Cale> For example, if you just want to know how to stick some IO actions together, try my http://www.haskell.org/haskellwiki/Introduction_to_IO before you read http://www.haskell.org/haskellwiki/Monads_as_Computation
11:12:39 <roboguy_> > (+) <$> [1,2,3] <*> [4,5,6]
11:12:41 <goodfellow> Title: Introduction to IO - HaskellWiki
11:12:41 <goodfellow>   [5,6,7,6,7,8,7,8,9]
11:12:43 <erisco> mcstar, you simpleton! :P
11:12:46 <mm_freak> klrr_: you picked a difficult path
11:12:49 <mcstar> true..
11:12:58 <mm_freak> klrr_: FRP is not easy to learn, so don't be frustrated
11:13:00 <Cale> > (+) <$> [10,20,30] <*> [4,5,6]
11:13:00 <klrr_> mm_freak: what's the easy path
11:13:01 <goodfellow>   [14,15,16,24,25,26,34,35,36]
11:13:12 <mm_freak> klrr_: the easy path is to start with an application, not with a concept
11:13:24 <chrisdotcode_> @src head
11:13:24 <goodfellow> head (x:_) = x
11:13:24 <goodfellow> head []    = undefined
11:13:26 <mm_freak> write a command line app, a web app or something like that
11:13:31 <klrr_> WHY DIDNT I KNOW THAT fuck myself
11:13:41 <roboguy_> klrr_: note how it looks very similar to regular function application (if you take out the <$> and <*>)
11:13:46 <chrisdotcode_> Cale: what happened to lambdabot? :o
11:13:49 <klrr_> now i learned Everything WRONG -.-
11:13:56 <Cale> chrisdotcode_: It was gone when I got here
11:13:59 <erisco> backtrack and retry
11:14:03 <chrisdotcode_> goodfellow's here, but she's not...
11:14:15 <Cale> I'm not running lambdabot at the moment, elliott is, so this is on him ;)
11:14:16 <dmwit> Cale isn't in charge of lambdabot any more.
11:14:24 <erisco> mm_freak, sorry I haven't been introduced to category theory, so I might not be up for this discussion
11:14:26 <mcstar> did he mean it?
11:14:35 <chrisdotcode_> heh, forgot about that.
11:14:58 <mm_freak> erisco: in the function category (.) is just function composition
11:15:13 <mcstar> (i made a similar mistake during my uni years, tried to learn too much theory wo enough practice...)
11:15:16 <Cale> In fact FRP is so difficult to learn, that even the people who have used it and have spent a long time thinking about it don't really try to claim that they understand what the right way to do it is.
11:15:20 <erisco> mm_freak, either way, it seems that the optimizations Cale is speaking of is rooted in the implementation strategy chosen -- now, perhaps the issues are more general than that, but I won't understand from Haskell terms ... wasn't super important anyways
11:15:24 <erisco> mm_freak, I was just casually curious
11:15:25 <chrisdotcode_> dmwit: so did "caleskell" -> "haskelliot" now?
11:15:32 <Cale> It's still very much a research topic.
11:15:34 <mcstar> i do think it was a valuable advice
11:15:39 <dmwit> chrisdotcode_: heh
11:15:39 <Cale> chrisdotcode_: haha
11:15:50 <mm_freak> yeah
11:16:00 <chrisdotcode_> :)
11:16:03 <conal> @Cale: it might be quite easy to learn once we figure out how to package it well.
11:16:03 <goodfellow> Unknown command, try @list
11:16:07 <mm_freak> right now, if there are 10 different FRP implementations, they implement it in 10 different ways =)
11:16:14 <Cale> conal: Well, right.
11:16:25 <mm_freak> and 5 of them don't even have actual defined semantics
11:16:26 <erisco> Cale, research on implementations or what? to me the basic idea seems rather simple, but perhaps it is more general than I imagined?
11:16:28 <dmwit> Cale: (I think all these people are putting @ in front of your name because your op bit is showing.)
11:16:29 <Cale> conal: But at the moment, we don't really fully know what FRP *is*.
11:16:38 <Gracenotes> do we know what RP is :x
11:16:44 <conal> mm_freak: not just different implementations. wildly different semantics. most are not what i think of as FRP.
11:16:54 <Cale> We just know that there's this design space of libraries which seem attractive, and some of them work better than others.
11:16:56 <Gracenotes> hopefully we know what DP is
11:17:01 <valdyn> llks992: efficient means that it scales up and you dont have to worry about it
11:17:29 <mm_freak> conal: well, what is your notion of FRP?
11:17:46 <mm_freak> mine is something along the lines of (Time ->)
11:17:47 <conal> mm_freak: two fundamental properties: denotative and continuous time.
11:17:59 <erisco> valdyn, llks992 and typically that means near linear yeah?
11:18:20 <conal> mm_freak: see http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/
11:18:20 <goodfellow> Title: terminology - What is (functional) reactive programming? - Stack Overflow, http://tinyurl.com/y9e6p2u
11:18:26 <Cale> I don't think time actually has to be continuous, just indistinguishable in some contexts from continuous. :)
11:18:27 <valdyn> erisco: certainly not when copying a list - that wouldnt scale well
11:18:43 <conal> mm_freak: and stackoverflow.com/questions/5385377/the-difference-between-reactive-and-functional-reactive-programming
11:19:01 <conal> mm_freak: and stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language
11:19:11 <dmwit> Cale: What's the difference between "foo" and "indistinguishable from foo"?
11:19:16 <mm_freak> conal: i've actually read all of those
11:19:19 <Cale> i.e. behaviours are things for which you're not allowed to distinguish the times when they change.
11:19:35 <valdyn> erisco: or maybe you mean linear with the number of elements changed, then you'd be right
11:19:53 <erisco> valdyn, linear with the size of the list, or the input in general
11:19:54 <Cale> They might be implemented in terms of discrete changes.
11:20:03 <Cale> But as a library user, you shouldn't be able to tell.
11:20:13 <valdyn> erisco: a naive copy scales with the size of the list, but thats not efficient
11:20:20 <merijn> dmwit: I think Cale means "operational semantics/meaning indistinguishable from foo", whereas implementation might be distinguishable
11:20:27 <mm_freak> conal: my conclusion is that time should be exposed as continuous, but must be implemented as discrete to be useful and efficient
11:20:33 <merijn> dmwit: i.e. indistinguishable in all the dimensions we care about
11:20:34 <chrisdone> conal: you know you could just rename FRP in your blog to something involving time and people would adopt it
11:20:39 <erisco> valdyn, okay well I guess we're working off different ideas of efficient in this context. never mind
11:20:46 <mm_freak> conal: i should note that i'm the author of netwire (and note entirely happy with it)
11:21:00 <conal> mm_freak: "must be" is quite a strong conclusion. i imagine it'd be hard to support.
11:21:03 <mm_freak> s/note/not/
11:21:09 <Cale> "continuous time" might imply more about what kinds of operations and transformations you're allowed to apply in some cases
11:21:19 <Cale> Like, are you allowed to slow down a behaviour by 50%?
11:21:25 <mm_freak> conal: that's quite true
11:21:36 <valdyn> erisco: we were talking about a function which changes a single element of a list
11:22:00 <merijn> mm_freak: Well, netwire lacks a notion of events, at least events that behave according to conal's semantics, meaning netwire can't really be seen as having "first-class time"
11:22:13 <conal> mm_freak: if you maintain the continuous-time denotation, implement it however you want.
11:22:25 <Gracenotes> any FRP implementations vaguely use measure theory/topology/etc?
11:22:54 <Cale> Or, it seems to imply that between any two points in time you could determine the value of the behaviour, there would be another point at which it could be sampled.
11:23:12 <Cale> However, I think in terms of practical implementations, that property is bad.
11:23:21 <mm_freak> Cale: that's too strong
11:23:25 <erisco> valdyn, I thought you were speaking in context of "efficiency for a general purpose algorithm means that it scales well", and so I was asking if O(n) was that assumption, but rather you are talking about "for this specific problem, there exists a more efficient implementation that is sub-linear, so a linear solution is not efficient"
11:23:36 <Cale> There are a lot of things that "continuous time" could mean.
11:23:41 <mm_freak> Cale: unlike most other FRP implementations netwire doesn't allow you to go back in time
11:23:43 <erisco> valdyn, which is a very verbose way for me to point out we were talking of different things
11:23:52 <S_J> I cant register with NickServ,
11:23:58 <Cale> mm_freak: Yeah, ours didn't either. :)
11:24:09 <S_J> isnt the syntax /msg NickServ identify _nickname_ _pw_ ?
11:24:09 <merijn> Cale: Lame ;p
11:24:12 <Cale> I think it's quite important not to have arbitrary delays.
11:24:29 <merijn> S_J: Nickserv is down, it's DDoS freenode-day again
11:24:41 <mm_freak> well, individual wires ("behaviors") allow it, but Wire in general does not
11:24:48 <Cale> You obviously need *some* way to shift values along the occurrences of an event.
11:24:54 <mm_freak> you can pass negative dts, but it doesn't necessarily mean going back in time
11:25:21 <mm_freak> it's hard to combine inverse timeflow with dynamic switching
11:26:09 <valdyn> erisco: yea, you nailed it.
11:26:12 <conal> oh, nice. my "what is FRP" SO answer now has 301 points.
11:26:14 <Cale> But being able to create new occurrences of an event from thin air -- say by specifying them as happening after a certain amount of time -- is both not really required by applications very much, and can result in some serious performance problems.
11:26:38 <mm_freak> merijn: what is "first-class time", btw?
11:26:53 <erisco> conal, just a rookie here, and I recognize the issue with continuous functions of time in terms of updating dependants, why do you prefer "denotative continuous-time programming"? does denotative indicate some sampling method?
11:27:22 <Cale> This is because each genuinely new occurrence of an event potentially requires computation of arbitrarily many behaviours
11:27:29 <erisco> conal, and generally speaking, what are the big mysteries? are they rooted in technical implementation problems or slightly more abstract?
11:27:47 <conal> erisco: "denotative" is explained in one or more of those StackOverflow replies.
11:27:55 <carter> Isn't one challenge that the computation graph changes dynamically?
11:28:03 <Cale> In order to have a system which works efficiently, you really want to have a clock which isn't unlimited in resolution, so that you have enough time to compute all the behaviours.
11:28:07 <carter> so you can't actually schedule things as awesomely as one might like?
11:28:13 <merijn> mm_freak: Time is a first-class notion in your semantics, which requires you to have some form of events happening separately from your behaviours that can influence your behaviours
11:28:34 <Cale> carter: Well, that is a challenge, yes.
11:28:41 <mm_freak> merijn: could you give an example?  because that sounds pretty much trivial to do with netwire
11:29:09 <carter> Cale and i guess for ios, you can't do runtime compilation when the graph changes :(
11:29:16 <merijn> mm_freak: ok, a behaviour that is true until a button is pressed, which I can reuse inside another behaviour that doesn't know about buttons at all
11:29:42 <Cale> carter: well, you can, and really have to, but you really don't want to be dynamically changing the computation you're doing *that* often.
11:30:01 <conal> erisco: i like your "big mysteries" question. i don't hear it often. probably better for discussing another time. i have papers to finish reviewing.
11:30:03 <merijn> mm_freak: afaict netwire requires you to somehow pass this event through/around the outer behaviour to get it to the inside to actually see an event happen
11:30:13 <Cale> carter: Of course, it's going to happen: you're going to load new monsters into the world and their AIs will have to run, for example.
11:30:17 <mm_freak> merijn: f untilButtonPressed = ?
11:30:17 <conal> (i'd rather not start a discussion that i don't have time to finish.)
11:30:22 <mm_freak> where untilButtonPressed is a wire
11:30:26 <carter> yeah
11:30:38 <carter> because that dynamicity seems like it'd be the biggest challenge
11:30:53 <merijn> mm_freak: mm_freak and f is a Wire too, but one that doesn't know about buttons
11:30:56 <Cale> carter: But a lot of the simplification there can hopefully be shared.
11:30:58 <mm_freak> merijn: i guess you mean that events themselves are not first class
11:31:07 <carter> jah
11:31:41 <mm_freak> merijn: to turn an event wire into [(Time, a)] there is one piece missing
11:31:52 <mm_freak> because netwire doesn't have a notion of discrete events, and it really needs one
11:31:54 <merijn> mm_freak: Yeah
11:32:18 <erisco> conal, ah I see, sorry. clicked on the least useful link then. so the work then is designing a minimal set of axioms that span all conceivable ... systems? (not sure of the word to stick there, but hey)
11:32:23 <mm_freak> i've considered this for a long time, but i'm not quite sure how to model it yet
11:32:34 <merijn> mm_freak: basically, to write code that treats time as a first-class value, you need to have first class events
11:32:54 <mm_freak> merijn: you don't need first class events, but you need discrete events
11:33:38 <merijn> mm_freak: why don't you need first-class events? (also, I need to run an errand, so I'll be back in about 5-10 mins)
11:33:52 <conal> erisco: axioms? did one of my SO answers talk about axioms?
11:34:21 <mm_freak> merijn: once you have discrete events you get a function to convert discrete events into [(Time, a)] for free
11:34:31 <erisco> conal, no you said "building block" but I don't have any distinction between the two
11:34:45 <chrisdotcode_> is there any way to add parameter restraints in haskell? like:
11:34:45 <chrisdotcode_> foo :: Int<23 -> [a] -> a
11:34:58 <mm_freak> chrisdotcode_: not directly
11:34:59 <Cale> chrisdotcode_: no
11:35:01 <chrisdotcode_> that's called "dependent types", right?
11:35:07 <conal> erisco: ah. by "building block" i mean an element of the vocabulary/API.
11:35:13 <yitz> conal: i still think that "function of time" is two complicated as the fundamental model for a behavior. i'll bet implementation would be simpler if you used a simpler concept.
11:35:16 <mm_freak> chrisdotcode_: yes, dependent types would allow this, but you don't need them
11:35:17 <conal> erisco: on "denotative", see http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-35882
11:35:17 <yitz> *too
11:35:17 <Cale> chrisdotcode_: Well, dependently typed systems have a way to encode that
11:35:18 <goodfellow> Title: Conal Elliott  Is Haskell a purely functional language?, http://tinyurl.com/6cv3g9q
11:35:25 <erisco> conal, I understand, but I still don't see the difference conceptually
11:35:45 <chrisdotcode_> Cale, mm_freak: so would you use guards for something like that?
11:35:46 <Cale> chrisdotcode_: You'd work with a pair consisting of an integer and a proof that it's less than 23
11:35:56 <erisco> conal, it is still the minimal set of tools you're given to construct everything from
11:35:59 <Cale> (in a dependently typed setting)
11:36:11 <mm_freak> chrisdotcode_: i'm crazy enough to encode the real thing =)
11:36:21 <conal> yitz: i'm intrigued. and i assume you want a *precise* simple model, not one whose simplicity is due to vagueness.
11:36:23 <chrisdotcode_> Cale: so, foo :: Pair Int (Int -> Bool) -> [a] -> a
11:36:30 <fenris_kcf> how to make GHC find standard modules like "Maybe"?
11:36:33 <chrisdotcode_> mm_freak: what do you mean by "encode"?
11:36:51 <mm_freak> chrisdotcode_: if your function is a 'take', then Nat is just fine as the type of the first argument
11:36:52 <erisco> conal, I don't mean to assert, I am just offering what it looks like to me
11:36:54 <Cale> foo :: (exists x :: Int, x < 23) -> [a] -> a
11:37:11 <mm_freak> chrisdotcode_: but then you can enrich the Nat type with a maximum value
11:37:13 <yitz> conal: of course
11:37:16 <mm_freak> this is possible using GADTs
11:37:19 <conal> erisco: don't start with the API. start with a mathematical model. make it precise, adequate, and simple. then design the API around that model.
11:37:29 <conal> yitz: great.
11:38:11 <chrisdotcode_> Cale: is that a legal type signature?
11:38:15 <Cale> chrisdotcode_: No.
11:38:23 <chrisdotcode_> mm_freak: how would you do that? the only way I see is guards.
11:38:31 <Cale> chrisdotcode_: It's in an imaginary dependently-typed Haskelly language
11:38:36 <erisco> conal, and I am curious because the work I've been doing over the past couple years has lead me to start designing these building blocks to, ideally, abate some complications with game development ... I should read your work :)
11:38:59 <Cale> chrisdotcode_: You generally don't put constraints like this in the type system in Haskell.
11:39:07 <yitz> conal: the simplest is just a partial ordering on events - where the ordering specifies ordering in time. a behavior is something that happens between two events - without having to say exactly how it varies over time.
11:39:12 <Cale> chrisdotcode_: It's theoretically possible with GADTs, but awkward.
11:39:31 <mm_freak> chrisdotcode_: as said, i'm crazy enough to do this  practically you probably should just write an Int wrapper that doesn't allow constructing arbitrarily large values
11:39:33 <Cale> and the awkwardness might outweigh the benefits
11:39:33 <chrisdotcode_> Cale: I was reading the "next mainstream language" pdf, and it would be really nice if you could encode that in the type system
11:39:36 <conal> yitz: do you mean incompletely specifying the meaning of behaviors?
11:39:45 <yitz> conal: or over several events in sequence
11:39:54 <mm_freak> chrisdotcode_: if the maximum number is fixed, it's quite easy  if not, you can use the 'reflection' library and a concept called "implicit configurations"
11:40:02 <Cale> chrisdotcode_: Well, have a look at coq
11:40:09 <Cale> chrisdotcode_: or agda
11:40:18 <Cale> Or even Idris :)
11:40:27 <raichoo> Even? :P
11:40:39 <fenris_kcf> nvm ...
11:41:40 <yitz> conal: i mean that your notion of behavior by definition requires every aspect of how it evolves at every instant all to be part of the semantics.
11:41:48 <mm_freak> raichoo: "even", because idris by itself doesn't enforce totality, just like haskell
11:41:53 <mm_freak> so you can always get around the constraint
11:41:58 <mm_freak> by passing a bottom "proof"
11:42:25 <conal> yitz: for me, events were always a means to an end, i.e., they were there to support time-varying values (behaviors). if you don't address behaviors, it's not a (simpler) model of FRP.
11:42:33 <raichoo> mm_freak:  %default total. But that's another story ^^. In the and you are right
11:42:33 <yitz> conal: to me what happens exactly at this moment and also a picosecond later isn't part of what i mean when i talk about a behavior.
11:42:49 <merijn> mm_freak: I suspect your definition of "discrete event" is mine of a "first-class event" :p
11:43:03 <Cale> But then again, Idris also has some practical aspects to it already, while Coq and Agda are not something that you'd usually write desktop applications in.
11:43:11 <merijn> mm_freak: i.e. "Event a" is something that can happen at point X in time and produce an arbitrary value of type a
11:43:11 <raichoo> Indeed.
11:43:14 <mm_freak> merijn: possibly, but my notion is definitely not first-class
11:43:31 <mm_freak> unless you view a wire itself as a first class event
11:43:40 <chrisdotcode_> Cale: but haskell is my one true love...
11:43:50 <merijn> mm_freak: If it is possible to have "Event a" and use it to construct behaviours and pass around, then I'd consider it first class
11:44:01 <S_J> http://www.gotw.ca/gotw/084.htm <- Pretty good. That means classes are not more than structs really. better to have a lot of functions that can operate on different classes/structs/records/datatypes than to put all functionality in a class.
11:44:02 <goodfellow> Title: GotW #84: Monoliths "Unstrung"
11:44:04 <mm_freak> chrisdotcode_: haskell ruins you for most other languages, but then agda has the potential to ruin you for haskell =)
11:44:09 <yitz> conal: why not describe things that evolve over time, with the parts of that which are meaningful to people being the semantics? behaviors for people, not a simulation of the physical universe.
11:44:11 <merijn> mm_freak: Note that I'm talking about FRP events, not the netwire events
11:44:34 <Cale> But I still see Idris as somewhat in a beta stage of development.
11:44:41 <mm_freak> merijn: "FRP events" is a loose notion and manifests in different ways in different implementations
11:44:47 <chrisdotcode_> mm_freak: oh? does it? should I go check out agda?
11:44:53 <merijn> mm_freak: Sure, but they have clear semantics
11:44:55 <mm_freak> chrisdotcode_: probably not
11:45:01 <conal> mm_freak: much of that variation is semantic. it's not just implementation.
11:45:05 <Cale> Agda will ruin your hands first
11:45:13 <conal> yitz: i'm a person, and the variation over time matters to me essentially.
11:45:14 <merijn> mm_freak: How they're implemented I don't care about
11:45:20 <Cale> With its fancy unicode characters which are impossible to type
11:45:20 <chrisdotcode_> agda is a haskell dilect?
11:45:26 <chrisdotcode_> *dialect
11:45:30 <Cale> chrisdotcode_: If you know Haskell, it's not hard to pick up.
11:45:34 <mm_freak> conal: especially if you compare netwire to the others
11:45:48 <mm_freak> Cale: oh, it's not that bad actually, once you get used to it
11:46:00 <mm_freak> it's about like memorizing all the haskell operators =)
11:46:05 <chrisdotcode_> oh, wait, agda is writtein haskell...
11:46:11 <conal> yitz: it's exactly what i was trying to get at in creating FRP.
11:46:12 <Cale> mm_freak: I played around with Agda for a few hours, and at the end of it, my hands physically ached.
11:46:14 <chrisdotcode_> s/writtein/written in
11:46:16 <chrisdotcode_> haha
11:46:20 <chrisdotcode_> Cale: did you have a compose key?
11:46:32 <Cale> I do, but the emacs mode doesn't require that
11:46:42 <merijn> mm_freak: When I say first class events I really just meant "I can pass the around and create new ones based on behaviours and/or existing events"
11:46:44 <Cale> (I have caps lock set to compose)
11:46:44 <yitz> conal: :) ok but i'll still claim that usually all the details really don't matter to you. in fact, if they do, quantum mechanics says that you will necessarily be disappointed.
11:46:52 <mm_freak> Cale: oh yeah, i understand that
11:46:59 <mm_freak> it's a lot of backslash typing
11:47:26 <conal> mm_freak: if you go back to the early definitions of FRP, they weren't "loose" about events. i guess they got loose later, perhaps when people were more interested in coding than in specification (more in how than in what).
11:47:49 <merijn> yitz: FRP is not about obtaining *all* values, it's about being able to compute the value at an arbitrary point in time
11:48:13 <mm_freak> conal: that was definitely my path, yes  my original idea was to write a "sane" yampa
11:48:16 <conal> merijn: you could say the same about other infinite data types.
11:48:28 <mm_freak> conal: signal inhibition did not exist at that point
11:48:30 <merijn> conal: oh, sure
11:48:40 <conal> merijn: but i prefer to think in terms of the entire well-defined infinite value.
11:48:49 <Cale> merijn: and maybe not even an arbitrary point in time, but at an arbitrary occurrence of some event :)
11:49:00 * hackagebot hsbencher 1.3.4 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.3.4 (RyanNewton)
11:49:01 <goodfellow> Title: HackageDB: hsbencher-1.3.4
11:49:05 <yitz> merijn: so i'm saying you really don't want to be able to compute the value at an arbitrary point in time. only at the moment of an event.
11:49:26 <conal> merijn: which has a precise semantics. you can extract partial information later, and non-strict language semantics makes it work happily.
11:49:31 <merijn> yitz: oh? What about animation? I wanna start the next frame as soon as I finish the current one
11:50:14 <yitz> merijn: frames of an animation are an implementation detail. (albeit an important one)
11:50:15 <conal> sigh. people want to focus on events. oh well.
11:50:18 <Guest17879> hmm, lambdabot froze?
11:50:23 <merijn> yitz: If you only want it at the occurence of some event, that is trivially specified in conal's semantics
11:50:31 <yitz> merijn: people are not supposed to notice frame boundaries.
11:50:33 <merijn> yitz: Whereas doing the reverse is hard, if not impossible
11:50:47 <conal> the FRP mindset is that discreteness is the exception, not the rule.
11:51:02 <yitz> yes i've seen that. it perplexes me.
11:51:18 <conal> semantic power, simplicity, and composability are all enhanced by the continuous nature.
11:51:26 <yitz> it necessarily will lead to a huge amount of complexity and difficulty. for what gain?
11:51:39 <functorf1n> Hi
11:51:41 <merijn> yitz: Why does it lead to huge amounts of complexity?
11:51:52 <chrisdotcode_> mm_freak: are dependent types even that useful? they seem incredibly useful to me, but if a few simple guards can cover it, then is it really needed?
11:52:01 <conal> ditto for continuous & infinite space for image synthesis & manipulation.
11:52:09 <Cale> conal: The reason I want to focus on events in that way is that if you're allowed to compute the values of behaviours at arbitrary offsets, or create occurrences of events from thin air, then very poorly-behaved things can happen. You still don't want to be able to tell the moments at which a behaviour is changing, and it's going to have a value at every occurrence of every event, so it appears continuous in every sens
11:52:10 <Cale> e that you can observe it.
11:53:17 <bb010g> @src Double minBound
11:53:17 <goodfellow> Source not found. Maybe if you used more than just two fingers...
11:53:32 <Cale> But perhaps it's just that I have no idea of how to implement a system efficiently which allows you to arbitrarily cut time into smaller pieces.
11:53:36 <conal> @Cale: there are occurrences of events at every moment in continuous time.
11:53:36 <goodfellow> Unknown command, try @list
11:54:00 * hackagebot hsbencher 1.3.6 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.3.6 (RyanNewton)
11:54:00 <goodfellow> Title: HackageDB: hsbencher-1.3.6
11:54:02 <elliott> okay, looks like lambdabot just lost its network connection
11:54:05 <elliott> it's awful at handling that
11:54:11 <functorf1n> I am looking to wrap this https://gist.github.com/victoredwardocallaghan/cf2b2b95613d6b71092b up in a Monad to ensure locking primatives are done correctly, how do I go about doing that?
11:54:33 <yitz> just because the behavior will ultimately be continuous when it is rendered doesn't mean that continuity needs to be part of the semantic model.
11:54:40 <conal> @Cale: is your event focus driven by implementation worries? or semantic simplicity? or ??
11:54:41 <goodfellow> Unknown command, try @list
11:54:46 <Cale> conal: Because you might be required to compute any behaviour at every point at which there is an occurrence of an event, if you allow events to occur at too many points in time, you might not have enough time to compute all the behaviours you need to compute, and then the system falls over.
11:54:48 <lambdabot> Unknown command, try @list
11:54:53 <mm_freak> chrisdotcode_: dependent types are useful to lift certain things to the type level
11:55:05 <mm_freak> this makes writing certain applications easier and proofs possible
11:55:37 <functorf1n> classic example of a dependent type is a vector that depends on n
11:55:41 <conal> yitz: just the opposite. although the semantic model is simply infinite/continuous, the implementations can be finite/discrete.
11:55:50 <alexander__b> how did you do [5..10] only negative 5 and 10?
11:55:59 <chrisdotcode_> mm_freak: yeah, it seemed to add checks at compile time, instead of runtime.
11:56:05 <alexander__b> i.e. [-10..-5]
11:56:06 <mm_freak> chrisdotcode_: for example in haskell you need some lifting boilerplate to write a modular arithmetic type that includes the modulus in the type
11:56:10 <chrisdotcode_> (and make certain runtime checks even easier)
11:56:14 <merijn> alexander__b: add a step
11:56:18 <byorgey> alexander__b: [-5, -6 .. -10]
11:56:21 <merijn> > [-10,-9..-5]
11:56:22 <mm_freak> chrisdotcode_: you can then write "5 + 7" to mean "5 + 7 modulo n"
11:56:25 <goodfellow>   Not in scope: `..-'
11:56:28 <lambdabot>   Not in scope: `..-'
11:56:32 <merijn> > [-10,-9..(-5)]
11:56:33 <byorgey> > [-10 .. -5]
11:56:34 <goodfellow>   can't find file: L.hs
11:56:36 <goodfellow>   [-10,-9,-8,-7,-6,-5]
11:56:38 <lambdabot>   [-10,-9,-8,-7,-6,-5]
11:56:40 <lambdabot>   can't find file: L.hs
11:56:45 <mm_freak> chrisdotcode_: this isn't really about compile-time checking
11:56:45 <alexander__b> ah!
11:56:49 <alexander__b> my issue wasn't what you'd think though
11:56:49 <geekosaur> silly haskell prefix unary parsing
11:56:50 <haasn> elliott!!
11:56:53 <chrisdotcode_> mm_freak: could you do that with template haskell?
11:56:57 <mm_freak> chrisdotcode_: in this case it's actually dependent types for convenience
11:56:59 <alexander__b> I forgot to use to put spaces
11:56:59 <chrisdotcode_> well, it's about safety
11:57:06 <chrisdotcode_> convenience? isn't it safety?
11:57:10 <mm_freak> chrisdotcode_: you can do that with regular haskell and a few type system extensions
11:57:15 <alexander__b> you can do [5..10] but not [-10,-9..-5]. you need spaces in the latter.
11:57:16 <conal> i choose continuous semantic models for their simplicity & naturalness (fit to the domain). never for implementation reasons.
11:57:18 <Cale> conal: I'm interested in the semantics, but that interest is very much rooted in a concern for everything being efficiently implementable.
11:57:22 <yitz> conal: just as the best way to model colors is in spaces that reflect the way people percieve colors and think about them rather than the way we render them, i think the same should be true about the semantics of behaviors.
11:57:35 <mm_freak> chrisdotcode_: no, it's convenience  you're not proving anything, you're just passing the modulus implicitly
11:57:42 <Cale> It's not useful to me to have a beautiful semantics which I can't implement.
11:58:00 <functorf1n> I mean, should I be using a IO monad or a state monad?
11:58:04 <yitz> conal: you can model them using newtonian physics, but then you are focusing on the implementation. aristotilian physics is better for semantics.
11:58:17 <elliott> uh um this is a problem yes
11:58:22 <elliott> goodfellow: @part #haskell
11:58:29 <elliott> dmwit: you can bring it back if you want :)
11:58:30 --- mode: monochrom set +o elliott
11:58:39 <elliott> why are we all +o'd?
11:58:41 <elliott> oh, no services?
11:58:45 <geekosaur> yeh
11:58:49 <chrisdotcode_> mm_freak: how so?
11:58:53 <monochrom> and you too :)
11:58:56 --- mode: monochrom set +o geekosaur
11:59:01 <conal> yitz: as i've said, as long as the implementation is faithful to the semantics (i.e. correct), do whatever you want.
11:59:07 <mm_freak> chrisdotcode_: type classes
11:59:11 <chrisdotcode_> elliott: so I was saying that now that you're in charge of lambdabot, "caleskell" should be renamed "haskelliot"
11:59:20 <mkramer> Hi guys. Cabal question: How do I go from the name of a module (e.g. http://hackage.haskell.org/packages/archive/random-extras/0.17/doc/html/Data-Random-Extras.html) to the thing that `cabal install` knows how to find?
11:59:21 <monochrom> hehehe
11:59:22 <mm_freak> chrisdotcode_: instance (Modulus n) => Num (Mod n) where 
11:59:27 <erisco> Cale, conal, TBAG (interesting name), ActiveVRML, Fran, and the paper Functional Implementations of Continuous Modeled Animation ... claimed as efficient
11:59:40 <mm_freak> chrisdotcode_: the modulus follows from the type n:  modulus :: (Modulus n) => n -> Integer
11:59:51 <erisco> Cale, conal so I am a little confused with the conversation being had
12:00:00 <dcoutts> mkramer: you mean, assuming you had not already found the docs on hackage
12:00:07 <Cale> conal: Then again, with a different hat on, producing a beautiful semantics for FRP, just from a purely mathematical perspective, which may never be used directly for real world systems also is a very interesting space to consider :)
12:00:14 <chrisdotcode_> mm_freak: right.
12:00:16 <mm_freak> chrisdotcode_: note that you can pass bottom to this function, because it cares only about the type
12:00:38 * haasn prefers :: (Modulus n) => proxy n -> Integer -- for this kind of thing
12:00:49 <yitz> gotta run nice to see you conal :)
12:00:51 <conal> erisco: i made phenomenally efficient, correct implementations of Fran in 1997 or so. got hundreds or thousands of frames per second.
12:00:55 <dcoutts> mkramer: if you know the package is installed, you can use ghc-pkg find-module
12:00:57 <mm_freak> haasn: yes, definitely  i'm leaving out the proxy part for the sake of simplicity
12:01:00 <conal> yitz: take care. be well. :)
12:01:03 <aristid> mm_freak: netwire is discrete, right?
12:01:04 <Cale> (maybe something which can be used to understand other systems by allowing them to embed into it)
12:01:16 <mm_freak> aristid: internally, yes
12:01:26 <dcoutts> mkramer: if all you know is the module name, and it's not installed, then that is a bit harder, would have to google. The new hackage server search feature will cover this.
12:01:33 <mm_freak> aristid: netwire exposes its discreteness, but you don't have to use it
12:01:42 <mkramer> dcoutts: Alright, thanks
12:02:50 <aristid> what's the currently favored I/O library btw? :D
12:03:05 <aristid> pipes?
12:03:13 <Cale> aristid: System.IO ;)
12:03:21 <quchen> I love pipes. Not sure how "favored" it is though.
12:03:21 <erisco> Cale, conal, so I'm missing what the debate is about =\
12:03:41 <monochrom> is there even a debate?
12:03:51 <Cale> There's not really a debate going on here.
12:04:06 <erisco> there are conflicting claims
12:04:07 <mstksg> has anyone here built a medium-scale web app/project in haskell?
12:04:08 <conal> erisco: me, too. i don't see clean precise semantics as in conflict with efficiency.
12:04:10 <quchen> aristid: Even if pipes wasn't good I'd use it just to support its awesome level of documentation. :-)
12:04:10 <Cale> I was just explaining what my perspective is on the construction of FRP systems in general.
12:04:12 <aristid> quchen: one thing that confuses me about pipes is that Proxy superficially seems overpowered
12:04:50 <Cale> conal: Did you ever get Reactive to work efficiently?
12:04:51 <haasn> aristid: type balance needs immediate hotfixing!
12:04:56 <quchen> aristid: Agreed, also finding the right specialized pipe among all those type synonyms isn't easy
12:05:01 <erisco> Cale, but does conal's work not show that implementations that use continuous semantics (and I haven't looked at this -- though I will -- and I can't imagine what that ends up as in program code)
12:05:08 <mm_freak> mstksg: at least the following projects are medium-scale:  clckwrks and gitit
12:05:17 <erisco> Cale, are efficient? that is the debate I am talking about
12:05:25 <aristid> quchen: is there some kind of justification for the generalization from Pipe to Proxy other than "we can"?
12:05:29 <mm_freak> mstksg: i use gitit myself
12:05:43 <Cale> erisco: *Maybe* -- I'm not entirely convinced myself that they work on the same kind of scale that I'm talking about.
12:05:54 <mm_freak> (it's a mediawiki alternative  not quite as powerful, but sufficient for most applications)
12:05:59 <Cale> erisco: I'm talking about implementing an entire action RPG inside the FRP system.
12:06:00 <quchen> aristid: I started using it after that generalization, so I'm not sure about that one
12:06:17 <mstksg> mm_freak: thanks :) honored.  i'm trying to decide the platform for my next web project and i was wondering how the haskell ecosystem/web experience is like
12:06:22 <aristid> quchen: hum
12:06:23 <Cale> with many monster AIs, combat, collision detection, all that sort of thing
12:06:38 <Cale> I'm not sure that was ever attempted with Fran :)
12:06:45 <aristid> quchen: i seem to recall there was also a third I/O library that used IO for everything
12:06:48 <erisco> Cale, and? if the concept was worth its salt it wouldn't matter what you were implementing
12:06:50 <aristid> by greg collins iirc
12:07:03 <erisco> Cale, then again I don't know conal's intentions with his idea, so.
12:07:10 <Cale> erisco: The concepts that we have are not *so* different
12:07:23 <aristid> ah, yes, io-streams
12:07:25 <conal> @Cale: i got bogged down trying to debug Reactive hanging. there were a few GHC RTS bugs at the time, possibly some other issues, and I never got back to the effort.
12:07:25 <lambdabot> Unknown command, try @list
12:07:26 <Cale> These are really subtle details -- the overall ideas are mostly similar.
12:07:29 <mm_freak> mstksg: well, both projects are written using happstack (although gitit seems to be moving to yesod)  for an example of a medium-profile yesod website see haskellers.com
12:07:52 <mm_freak> i'm not aware of any medium-scale snap projects
12:08:10 <conal> @Cale: i'd hoped to work with someone on a correct, robust, and efficient implementation of unamb/lub for GHC.
12:08:11 <lambdabot> Unknown command, try @list
12:08:11 <mstksg> how was your experience in developing them?  can you compare it to other platforms you've used in the past?
12:08:11 <erisco> Cale, hm. I suspect then that there is more meaning buried in the terminology being used
12:08:52 <conal> @Cale: yes some subtle issues. both semantic and implementation.
12:08:52 <lambdabot> Unknown command, try @list
12:09:31 <mm_freak> mstksg: pretty much all haskell frameworks feel much less complicated and fragile as pretty much all frameworks in other languages i've used, including but not limited to zend framework and typo3
12:09:50 <conal> now i'm focused on compiling the pure/denotative/functional part of Haskell to hardware for massively parallel execution.
12:10:01 <Cale> I fully admit that there might just be options that I totally don't even know about for FRP implementations, and for that reason I see certain things as impractical just because I don't know of certain solutions to those problems.
12:10:15 <conal> i hope it falls out that lub will be efficiently and correctly implemented.
12:11:19 <conal> @Cale: thanks. i'm glad to hear. i'm often discouraged when i hear people claim that something can't be done, just because they haven't thought of how. mostly i worry that they'll believe what they say and that other will believe it.
12:11:19 <lambdabot> Unknown command, try @list
12:11:28 <mstksg> mm_freak: thanks, that's interesting to hear. have you ever used ruby?
12:11:40 <erisco> conal, did you give a presentation on unamb?
12:11:48 <mm_freak> mstksg: no, i found ruby scary
12:12:02 <Cale> But until I *do* know the solutions to those issues, those things *are* impractical for me to implement!
12:12:03 <Cale> :)
12:12:20 <conal> erisco: i probably mentioned it in my push-pull talk. it was in the paper as a small but crucial piece of the puzzle.
12:13:02 <conal> erisco: however, i do think lub (of which unamb is a special case) will turn out to be as valuable a modularity tool as non-strictness.
12:13:08 <ion> @Cale: I think you should change your nick to list. hth
12:13:08 <lambdabot> Unknown command, try @list
12:13:14 <conal> erisco: which is to say terrifically valuable.
12:13:17 <Cale> ion: ?
12:13:35 <sellout> ion: Maybe stop prefixing with @ ;)
12:14:02 <haasn> But that's what it says in my client, @Cale =P
12:14:03 <sellout> Oh you must have some client that shows ops as @<nick>
12:14:04 <mstksg> mm_freak: ah i see well thanks for pointiung me to those projects :)
12:14:15 <Cale> ion: My nick is not @Cale, it's just Cale. Your IRC client is displaying an @ next to my name because I have a user mode +o (channel operator)
12:14:21 <erisco> oh god I just read "bottom" in the description of lub ... I'll have to /quit on that for a while then :P
12:14:57 <merijn> haasn: @ just means someone is a channel op
12:15:06 <shachaf> Cale: ion was making a lambdabot joke about other people addressing you as @Cale causing a bit of noise.
12:15:06 * monochrom facepalms
12:15:19 <CaptainK> @version
12:15:19 <lambdabot> lambdabot 5.0
12:15:19 <lambdabot> git clone git://github.com/mokus0/lambdabot.git
12:15:40 <mstksg> still, using @ is a gesture of respect, right
12:15:46 <Clint> @no
12:15:46 <lambdabot> Error: expected a Haskell expression or declaration
12:15:47 <mstksg> :)
12:15:50 <haasn> shachaf: oh, now I get it. *facepalm*
12:15:57 <Cale> shachaf: I see
12:16:16 <functorf1n> hello?
12:16:19 <Cale> hello
12:16:23 <mstksg> hello
12:16:47 <functorf1n> oh good, thought there may have been a problem with my client for a moment.
12:17:23 <functorf1n> yea so, how do I go about wrapping up locking primatives into a (io?) monad?
12:17:36 <Cale> functorf1n: I don't quite understand what you mean.
12:18:00 <Cale> functorf1n: What program are you trying to write?
12:18:15 <functorf1n> I posted it above?
12:18:40 <Cale> functorf1n: How far above?
12:19:05 <monochrom> that was half an hour ago
12:19:06 <Cale> https://gist.github.com/victoredwardocallaghan/cf2b2b95613d6b71092b
12:19:07 <Cale> ?
12:19:46 <functorf1n> https://gist.github.com/victoredwardocallaghan/cf2b2b95613d6b71092b
12:19:53 <functorf1n> yep that's it Cale
12:19:55 <functorf1n> thanks
12:19:56 <Cale> functorf1n: okay, so this program you wrote works, and you're looking to clean it up, or make it work better in some way?
12:20:18 <Cale> Also, there's no "an IO monad"
12:20:22 <Cale> it's "the IO monad"
12:20:23 <mm_freak> (the program he wrote doesn't work)
12:20:49 <monochrom> why does it not work? or how is it known?
12:21:04 <functorf1n> Cale: yes, so I want to make sure a lock does not get called on a lock and so on..
12:21:24 <functorf1n> mm_freak: you need android patches for that wakelock device to exist.
12:21:42 <mm_freak> monochrom: do h <- openFile; ; hClose h
12:21:53 <arkeet> =(
12:21:56 <mm_freak> that's how it doesn't work
12:22:02 <functorf1n> dont worry about that for now, I am just interested in the abstraction.
12:22:03 <mm_freak> functorf1n: use withFile
12:22:04 <arkeet> lens and operational both contain a function called `view`
12:22:05 <arkeet> =(
12:22:09 <wole> @hoogle getClockTime
12:22:09 <lambdabot> System.Time getClockTime :: IO ClockTime
12:22:12 <Cale> What do you mean by "a lock does not get called on a lock"?
12:22:16 <mstksg> Cale: what would i call one instance of a monad?
12:22:17 <elliott> arkeet: that's ok. free > operational.
12:22:36 <haasn> arkeet: the only valid solution is to import whatever conflicts with lens qualified
12:22:39 <Cale> mstksg: An instance of the Monad class is called a Monad. It is a type constructor.
12:22:39 <arkeet> I haven't seen enough of both to form an opinion.
12:22:43 <mm_freak> elliott: performance free < performance operational
12:22:49 <monochrom> guess what, I would just readFile and writeFile and screw the handle altogether
12:22:54 <Cale> For example, IO is a monad.
12:22:59 <Cale> IO String is not a monad
12:23:04 <Cale> and getLine is not either
12:23:29 <Cale> getLine can be called an IO action
12:23:38 <mstksg> Cale: not a haskell instance, I mean...if my function gave me a result of type Maybe String, should i just call it a "maybe type value"?
12:23:38 <elliott> mm_freak: I don't believe you :P
12:23:49 <mm_freak> elliott: then benchmark it
12:23:54 <elliott> mm_freak: Free (CoYoneda f) is the same as Operational f
12:23:54 <Cale> Yeah, a Maybe value is fine.
12:24:01 <elliott> well, I guess you get one extra constructor.
12:24:15 <Cale> The fact that Maybe happens to be a monad is generally not important to what its values are.
12:24:19 <mm_freak> elliott: operational is more lightweight, because it really encodes a sequence of instructions, unlike free, which encodes an expression tree
12:24:30 <elliott> mm_freak: expand out the definition of Free (CoYoneda f)
12:24:31 <functorf1n> yep I understand the mathematics well.. its just the implementation of this idea. I believe a monad should encapsulate the idea of locking primatives so you can't call unlock on a lock that does not exist and all that sort of thing..
12:24:39 <elliott> you will see it is literally identical to the definition of Operational
12:24:39 <functorf1n> It would be good to check this at the type level
12:24:46 <mm_freak> elliott: i know, but then you could just as well use operational =)
12:24:52 <haasn> or free =)
12:25:14 <Cale> functorf1n: I still don't really know what you're talking about...
12:25:14 <elliott> well, you can also just put the (result -> a) functions in the ADT.
12:25:20 <merijn> functorf1n: You might be interested in Conor McBride's paper "Kleisli Arrows of Outrageous Fortune"
12:25:25 <elliott> also, there is Control.Monad.Free.Church
12:25:36 <Cale> functorf1n: You want to prevent programs like  do lock x; lock x  at the type level?
12:25:44 <mm_freak> i think 'free' and 'operational' are both for prototyping and experimentation
12:25:45 <merijn> functorf1n: it covers exactly those type of things, like functions not working on a file handle after it was closed
12:25:57 <mm_freak> for the actual application you would probably want to write a more direct type
12:26:32 <Cale> functorf1n: You might find that Haskell's type system is not powerful enough to make encoding that kind of property an easy or convenient thing to do. It is *possible* to encode things like that though.
12:26:34 <functorf1n> Cale: yes
12:26:55 <functorf1n> merijn: thanks mm_freak thanks
12:27:10 <mm_freak> functorf1n: the easiest way to encode this is by encoding withLock, instead of lock and unlock
12:27:12 <Cale> functorf1n: But also, the type of lock and unlock won't be IO () anymore
12:27:16 <merijn> functorf1n: I agree with Cale that it might not be easy, though. McBride uses a haskell preprocessor to create some syntactic niceties for doing these things
12:27:19 <astor> I guess if there's only one lock instance it shouldn't be too hard.
12:27:26 <mm_freak> functorf1n: withLock :: Locked a -> IO a
12:27:37 <arkeet> anyway, how about http://hackage.haskell.org/package/free-operational
12:27:42 <mm_freak> functorf1n: this doesn't prevent anything statically, but it prevents silly mistakes
12:27:47 <arkeet> =)
12:27:51 <Cale> yes, using a with* style function is the usual answer
12:28:08 <mm_freak> functorf1n: you /can/ prevent it statically by doing something along the lines of runST
12:28:17 <Cale> It still doesn't guarantee that you don't write  withLock x (withLock x ...) though
12:28:25 <mm_freak> functorf1n: locked :: (forall s. Locked s a) -> IO a
12:28:35 <aristid> scary when pigworker has functional programming discussions on twitter as opposed to the expected train talk.
12:28:42 <functorf1n> I think this idea of withLock is good.. the API I dislike from google in the kernel. but basically its meant to be so you can call it and stops the phone from sleeping..
12:28:43 <Cale> i.e. locking the same resource twice, in this case)
12:28:55 <mm_freak> Cale: well, actually it does guarantee that =)
12:29:15 <merijn> aristid: isn't it pigworker talking about FP always scary?
12:29:16 <aristid> Cale: is this new policy that the ops here keep their +o active?
12:29:22 <mm_freak> functorf1n: are you actually writing an android app in haskell?
12:29:27 <Cale> mm_freak: Well, you'll need another type "Locked" for each String
12:29:30 <aristid> merijn: depends how easily you're scared
12:29:30 <merijn> aristid: I think it has to do with services being dead due to DoS
12:29:32 <mserrano> aristid: services are dead, so it makes sense
12:29:48 <aristid> merijn: oh i didn't notice that services are down :D
12:30:02 <Cale> I don't like keeping +o active
12:30:04 <tgeeky> gotta keep that @ torch alive!
12:30:08 <Cale> But it makes sense for now
12:30:33 <functorf1n> mm_freak: i'm actually writing a tool to talk to the baseband firmware in haskell.
12:30:44 <elliott> services are just an excuse. actually we're trying to strike fear into the hearts of the populace so we can oppress them as effectively as possible.
12:30:53 <elliott> be very afraid!
12:30:56 <tgeeky> elliott: that's just good timing!
12:31:05 <josephle> @pl (\n -> (n, f n))
12:31:05 <lambdabot> ap (,) f
12:31:09 <wole> :t runWriterT
12:31:10 <lambdabot> WriterT w m a -> m (a, w)
12:31:19 <ion> I hear theres a mechanism that secretly records all the communication on the channel.
12:31:20 <josephle> :t ap
12:31:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:31:37 <functorf1n> "There is also a user-space interface. Writing a name to /sys/power/wake_lock establishes a lock with that name, which can then be written to /sys/power/wake_unlock to release the lock. The current patch set only allows suspend locks to be taken from user space. "
12:31:42 <arkeet> elliott: so I guess free-operational describes exactly what you're saying.
12:31:43 <BoR0> @src ap
12:31:43 <lambdabot> ap = liftM2 id
12:31:43 <tgeeky> ion: for this channel, of course, there's one that non-secretly does that.
12:31:45 <arkeet> except it's yoneda and not coyoneda.
12:31:46 <elliott> ion: we use clog. it's an early beta-test version of PRISM.
12:31:53 <Cale> functorf1n: If you had a type-level representation of all the valid strings which could be passed to lock/unlock, then something along the lines of mm_freak's approach would work very well.
12:32:06 <elliott> haven't gotten around to upgrading yet, so the user in the channel isn't hidden.
12:32:17 <elliott> arkeet: right.
12:32:45 <functorf1n> Cale: I think the string is just any name.. although I could just makeup some kind of contraint I guess
12:32:51 --- mode: calvino.freenode.net set +o ChanServ
12:33:31 <elliott> thanks services. thervices.
12:33:36 <arkeet> wait.
12:33:37 <arkeet> it is coyoneda.
12:33:46 <astor> functorf1n: You have to make some abstraction above the OS-interface in order to make it safe, whether it is functions like withLock or a finite set of locks.
12:33:51 <arkeet> it's just Data.Functor.Yoneda.Contravariant.Yoneda
12:33:53 <arkeet> =(
12:34:13 <Cale> functorf1n: For example, you could have a class Device t where deviceName :: Proxy t -> String  (and data Proxy t = Proxy), and then use instances of that typeclass as type-level representations of the things you're going to be locking and unlocking.
12:35:48 <arkeet> http://hackage.haskell.org/package/minioperational cute.
12:35:49 <josephle> I'm sorry lambdabot, but (ap (,) f) is *not* more descriptive than (\n -> (n, f n)) :(
12:36:16 <arkeet> it isn't?
12:36:16 <ion> Has lambdabot claimed it is?
12:36:22 <Cale> and then have some type Locked t a as a representation of the computations you're allowed to do with the device t being locked (with result of type a)
12:36:39 <Cale> josephle: What are you complaining about?
12:36:54 <tgeeky> @unpl (ap (,) f)
12:36:54 <lambdabot> (((,)) >>= \ b -> f >>= \ a -> return (b a))
12:36:59 <arkeet> haha
12:37:06 <monochrom> (\n -> (n, f n)) = id *** f
12:37:07 <Cale> josephle: You asked lambdabot to make the expression points-free, and that's what it did
12:37:10 <arkeet> @unpl ap (,) f x
12:37:10 <lambdabot> (((,)) >>= \ b -> f >>= \ a -> return (b a)) x
12:37:12 <arkeet> great.
12:37:21 <arkeet> > ap (,) f x
12:37:22 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:37:22 <lambdabot>    arising from a us...
12:37:24 <arkeet> ba
12:37:30 <Cale> josephle: Making an expression points-free is not always a good idea
12:37:47 <josephle> Cale: oh I know, I also know the warnings about points-free giving out...esoteric answers
12:37:48 <arkeet> it often isn't.
12:37:50 <haasn> monochrom: id &&& f
12:38:02 <monochrom> however, (\n -> (n, f n)) itself is just as good
12:38:08 <arkeet> id &&& f is good
12:38:24 <elliott> ap (,) f is pretty readable.
12:38:26 <elliott> if you know what the S combinator is.
12:38:38 <arkeet> ap f g x = (f x) (g x)
12:39:10 <monochrom> I never remember the S combinator. and you see, I even misremember &&& and ***
12:39:20 <functorf1n>  Cale mm_freak sorry its still all sinking in..
12:39:47 <haasn> the mnemonic for (&&&) is that f &&& g applies f *and* g to the same argument, whereas (***) only applies one of each to one of each element of the tuple
12:39:53 <haasn> the one I use, that is
12:40:10 <arkeet> :t uncurry (***)
12:40:11 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
12:40:32 <arkeet> :t join (***)
12:40:34 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
12:40:47 <arkeet> hmm.
12:40:55 <arkeet> :t join (***) . arr (join (,))
12:40:56 <lambdabot>     No instance for (Arrow (,)) arising from a use of `***'
12:40:56 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
12:40:56 <lambdabot>     In the first argument of `join', namely `(***)'
12:41:04 <arkeet> uh
12:41:11 <arkeet> oh.
12:41:12 <josephle> haasn: your mnemonic forgets to mention that the argument gets duplicated. This is kinda important when dealing with nondeterministic monadic effects
12:41:24 <arkeet> :t (join (***) .) <<< arr (join (,))
12:41:25 <lambdabot>     Couldn't match type `a1 -> a2 b0 c0' with `(a0, a0)'
12:41:25 <lambdabot>     Expected type: a0 -> a0 -> a1 -> a2 b0 c0
12:41:25 <lambdabot>       Actual type: a0 -> a0 -> (a0, a0)
12:41:28 <arkeet> whatever.
12:41:42 <elliott> josephle: ??
12:41:52 <arkeet> ??
12:41:55 <josephle> elliott: I was playing around with arrows
12:41:59 <elliott> haasn's mnemonic seems to be completely correct with no exceptions for the (->) instance to me, but maybe I'm missing something
12:42:06 <elliott> oh, other instances. ok.
12:42:29 <josephle> and rollDie >>> (f &&& g) gave me unexpected results
12:42:31 <functorf1n> Cale: wait so what do you mean by the Proxy GADT here?
12:43:26 <haasn> arkeet: (&&&) = arr (join (,)) >>> f *** g
12:43:39 <haasn> f &&& g = *
12:43:41 <arkeet> I don't understand why you have f and g on the right but not the left.
12:43:54 <arkeet> ok.
12:44:34 <elliott> I don't think rollDie >>> (f &&& g) should give unexpected results
12:44:44 <elliott> like, it seems like that working properly is sort of the whole point.
12:44:52 <josephle> well it was unexpected because I misunderstood arrows
12:44:53 <haasn> what arrow is rollDie using?
12:45:15 <josephle> haasn, the IO monad
12:45:49 <haasn> and what's the result? the die only gets rolled once, with the same result being passed to f and g?
12:45:49 <josephle> elliot: the unexpected part is all my fault. Arrows were working correctly.
12:46:07 <Cale> functorf1n: It's just something which lets you determine for which t you want the String.
12:46:07 <benzrf> hi!
12:46:07 <josephle> haasn: the die gets rolled twice. f gets one roll, g gets the other.
12:46:15 <benzrf> I wrote this program to convert stuff to pig latin: http://paste.pound-python.org/show/34824/
12:46:19 <benzrf> can you give me tips on how to improve it?
12:46:23 <benzrf> it feels a bit kuldgy
12:46:28 <josephle> haasn: which is correct behavior. But I didn't realize it then.
12:46:28 <benzrf> *kludgy
12:46:31 <Cale> functorf1n: You could also make it  deviceName :: t -> String  -- but that will require t to have at least one value.
12:47:31 <Cale> benzrf: Use break or span instead of takeWhile and dropWhile?
12:47:39 <benzrf> ughhh!
12:47:39 <haasn> josephle: I don't see how that works keeping in mind rollDie >>> f &&& g = rollDie >>> arr (\r -> (r, r)) >>> f *** g
12:47:44 <benzrf> I knew there was a functoin that did what I was looking for
12:47:48 <benzrf> but I couldn't remember what it was
12:47:49 <benzrf> :\
12:48:07 <functorf1n> Cale: sorry, I am getting a little confused. there is only ever two devices wake_lock and wake_unlock
12:48:17 <elliott> I think the question is what type rollDie has.
12:48:19 <elliott> and what type f and g have
12:48:24 <Cale> benzrf: also, define isVowel separately, so you can use it instead of elem :)
12:48:31 <josephle> rollDie would have IO Int
12:48:51 <haasn> well, that doesn't even type check does
12:48:55 <elliott> ok. so the effect isn't in the arrow at all there, what you're writing is just equivalent to \x -> (f (rollDie x), g (rollDie x))
12:48:56 <haasn> s/ does//
12:48:58 <Cale> functorf1n: what are the string parameters then?
12:49:03 <elliott> and presumably f :: IO ... -> ..., g :: IO ... -> ...
12:49:07 <josephle> elliott: yeah, that's what I'm getting at
12:49:09 <elliott> but haasn's explanation is still correct there
12:49:17 <elliott> there's only one (rollDie x), all (rollDie x)s are equal
12:49:22 <functorf1n> Cale: I assume the kernel has some kind of linked list and whenever you write a name (string) into wake_lock it just appends it to the list and when you write the same name in wake_unlock it removes it. When wake_unlock is empty the phone can sleep. this is how I understand it
12:49:24 <elliott> so the same parameter is passed to both f and g
12:49:31 <elliott> in fact with GHC, it will be the exact same memory pointer that is passed
12:49:31 <josephle> okay
12:49:49 <josephle> so the action is duplicated
12:49:52 <haasn> josephle: you made it seem like rollDie :: a -> Kleisli IO Int
12:50:00 <haasn> err
12:50:00 <wole> @hoogle fromJust
12:50:01 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
12:50:05 <haasn> rollDie :: Kleisli IO a Int
12:50:05 <functorf1n> Cale: I guess all it would need to ensure is that the same name is not written twice to wake_lock
12:50:07 <Cale> functorf1n: What happens if you lock the same string multiple times
12:50:08 <Cale> ?
12:50:23 <benzrf> Cale: better? http://paste.pound-python.org/show/34825
12:50:28 <functorf1n> Cale: I think this is what I wish to protect agiest..
12:50:38 <benzrf> oops
12:50:42 --- mode: calvino.freenode.net set +o ChanServ
12:50:42 <benzrf> I mean concat, not unwords -.-
12:50:48 <benzrf> yay services is back!
12:50:52 <functorf1n> STwriter, I was thinking about that..
12:50:59 <benzrf> orrr not
12:51:05 --- mode: Cale set -oooo byorgey copumpkin dcoutts elliott
12:51:06 --- mode: Cale set -ooo geekosaur jmcarthur monochrom
12:51:10 --- mode: Cale set -o Cale
12:51:19 <seeg> hello
12:51:21 <haasn> aah, we don't know if ChanServ is properly working yet
12:51:21 <geekosaur> optimist?
12:51:33 <Cale> UNBRIDLED OPTIMISM
12:51:49 <geekosaur> (it's not, from the loops of it)
12:51:52 <geekosaur> *looks
12:52:13 <merijn> chanserv was back 10mins or so as well, so it'll probably die again
12:52:41 <benzrf> how do I join two lists in a tuple -.-
12:52:46 <monochrom> I oppose this choice. but I am fine with you making this choice, so that its full consequence is inflicted upon you.
12:52:54 <haasn> toListOf both -- wooh
12:52:59 <benzrf> yay!
12:53:02 <haasn> not even
12:53:08 <haasn> toListOf (each.each) -- wooh-er
12:53:09 <merijn> or just "uncurry zip"
12:53:09 <functorf1n> Cale: I think maybe runST is the go, what do you think?
12:53:14 <merijn> :t uncurry zip
12:53:14 <lambdabot> ([a], [b]) -> [(a, b)]
12:53:19 <Cale> functorf1n: probably not
12:53:22 <monochrom> let chanserv die in, say, hour an hour, and then incidentally a spammer/troll comes
12:53:28 <benzrf> what exactly is uncurry
12:53:33 <benzrf> :t uncurry
12:53:33 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:53:34 <merijn> :t uncurry
12:53:34 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:53:35 <geekosaur> depends on what you mean by join two lists in a tuple
12:53:35 <haasn> (that's assuming you want join as in (++))
12:53:39 <benzrf> o:
12:53:40 <geekosaur> :t uncurry
12:53:40 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:53:49 <Cale> wat
12:54:03 <monochrom> idealists never learn reality unless and until their ideals are implemented and then reality checks.
12:54:47 <seeg> I'm trying to create 2 cabal packages A and B, A depends on B. Suppose I compiled B and used cabal install to install it into $HOME/.cabal/lib... How can I tell project's A to use B as a dependency? It seems that simply adding B to A's build-depends doesn't work...
12:55:23 <Cale> seeg: uh, it should?
12:55:31 <monochrom> it works for me
12:55:46 <seeg> hmmm
12:55:51 <seeg> ok, will keep trying
12:55:52 <seeg> :)
12:55:53 <functorf1n> Cale: really?
12:55:57 <monochrom> show your complete files and commands.
12:56:21 <Cale> functorf1n: ST is for performing computations which are actually pure, but which locally involve arbitrary amounts of mutable state.
12:56:44 <Cale> functorf1n: You can't read or write files inside of an ST action, for example.
12:57:10 <functorf1n> Ahh, yea your right dang
12:59:22 <functorf1n> noted!
13:00:03 <functorf1n> Cale: could you point me to somewhere on the wiki that explains more about withLocked idea..
13:00:34 --- mode: ChanServ set +o geekosaur
13:00:35 --- mode: ChanServ set +o Cale
13:00:42 <Cale> wtf
13:00:47 <Cale> uhhhh
13:01:11 <Cale> seems services are back
13:01:12 <Fuuzetsu`> Freenode is so broken today
13:01:12 --- mode: ChanServ set +o Cale
13:01:14 <geekosaur> this would be why you don't mass-deop on a hair trigger. services showing back up /= services working
13:01:21 <monochrom> probably nickserv wakes up suddenly
13:01:28 <Cale> yeah
13:01:39 <Cale> geekosaur: It worked out okay :)
13:01:44 --- mode: Cale set -o Cale
13:01:47 <b2coutts> that or a bunch of people conspired to change their nicks at the same time to fuck with us
13:01:49 <geekosaur> it services a couple requests and then freezes again
13:02:07 --- mode: ChanServ set +o geekosaur
13:03:05 <Cale> functorf1n: anyway...
13:03:28 <seeg> ok, this works with dependencies
13:03:38 <Cale> okay, so let's look at a way to do this which doesn't really guarantee anything much, but it's a little safer than the separate lock and unlock
13:03:46 <seeg> but doesn't work when I do cabal-dev configure in project A
13:03:57 --- mode: ChanServ set +o Cale
13:04:11 <functorf1n> Cale: cool
13:04:21 <Cale> functorf1n: you could have  withLock name action = do lock name; v <- action; unlock name; return v
13:04:50 <Cale> functorf1n: That'll let you write  withLock "foo" $ do ... a bunch of stuff ...
13:05:12 <Cale> That'll take the lock before, and release it after doing whatever bunch of stuff you wanted to do.
13:06:05 <functorf1n> perfect
13:06:31 <arkeet> locks suck =(
13:06:35 <Cale> Well, it doesn't stop you from writing: withLock "foo" (withLock "foo" (...))
13:06:55 <haasn> Cale: presumably lock would do something
13:07:12 <Cale> haasn: see functorf1n's paste here: https://gist.github.com/victoredwardocallaghan/cf2b2b95613d6b71092b
13:07:31 <haasn> so it doesn't =P
13:07:56 <Cale> functorf1n: Is there a way of knowing whether any given "lock" is taken already?
13:08:33 <Cale> functorf1n: We could make withLock determine a string which is not among those already taken
13:09:16 <Cale> (Instead of relying on a parameter)
13:09:36 <functorf1n> Cale: I'm not sure, maybe its possible to read the file but I would have to read the kernel code..
13:10:04 <Cale> ah, cat /proc/wakelocks
13:10:48 <Guest77084> semi-offtopic, this is really neat: http://exploringdata.github.io/vis/programming-languages-influence-network/
13:12:04 <Cale> chanserv seems to be working okay now...
13:12:08 --- mode: Cale set -o Cale
13:13:19 <dmwit> lambdabot: ?botsnack
13:13:19 <lambdabot> :)
13:13:24 <dmwit> okey-dokey
13:15:10 <functorf1n> Cale: Do I have to set -XRankNTypes ?
13:15:35 <Cale> functorf1n: for what?
13:15:46 <Cale> functorf1n: You'll need RankNTypes for ST
13:16:37 <functorf1n> but isn't withLock :: (forall b. String -> IO b -> IO a)
13:16:54 <functorf1n> withLock name action = do ..
13:17:09 <mm_freak> functorf1n: that's just String -> IO b -> IO a
13:17:21 <mm_freak> and the type doesn't really make sense, unless the action doesn't return
13:17:34 <mitsai_> WTF
13:17:34 <mitsai_> already in use XD
13:17:39 <mm_freak> String -> IO a -> IO () is a more sensible type
13:17:54 <functorf1n> thanks, ghc-mod misinforming me again
13:18:17 <haasn> the code Cale posted should actually type as :: String -> IO a -> IO a -- no?
13:18:23 <Cale> functorf1n: You only need RankNTypes to have parameters to functions which are required to be polymorphic (and so on)
13:18:35 <arkeet> you need it to be able to *write* forall
13:18:40 <Cale> haasn: That's correct
13:18:44 <haasn> or -XExplicitForall
13:18:45 <arkeet> but you don't need to write forall in that case.
13:18:50 <arkeet> yes, or ScopedTypeVariables.
13:19:17 <bb010g> @src (!!)
13:19:18 <lambdabot> xs     !! n | n < 0 = undefined
13:19:18 <lambdabot> []     !! _         = undefined
13:19:18 <lambdabot> (x:_)  !! 0         = x
13:19:18 <lambdabot> (_:xs) !! n         = xs !! (n-1)
13:19:45 <bb010g> lambdabot's back!
13:19:51 <ab9rf> wee
13:19:52 <elliott> lambdaback
13:20:02 <dmwit> It's a Christmas miracle.
13:20:03 <arkeet> thanks, lambdabot.
13:20:06 <arkeet> thamdabot.
13:20:14 <haasn> lambdabat
13:20:16 <functorf1n> Many thanks guys!
13:20:16 <conal> I realized what was dissatisfying to me about the earlier FRP discussion today. Not knowing how to implement FRP semantics (including continuous time) efficiently can lead to researching efficient implementation or to choosing using something other than FRP. But I hear (perhaps mistakenly) the difficulty used to justify changing what "FRP" means. I'd much rather people say "FRP-inspired" if they want to change the semantic
13:20:17 <conal>  model, particulary for the two fundamental properties that shaped it (denotative and temporally continuous).
13:20:32 <b2coutts> limbdabot
13:21:08 <elliott> conal++
13:21:22 <ezyang_> Hey guys, straw poll, do you like the name tryAtomicReadMVar or peekMVar better?
13:21:24 <conal> elliott: thx :)
13:21:44 <functorf1n> ok ~ its getting to that 6:30 am mark..
13:21:48 <haasn> without knowing what the function is doing - peekMVar
13:21:49 <functorf1n> you know the story..
13:21:53 <aristid> ezyang_: if it's atomic, i like the former.
13:21:55 <djahandarie> ezyang_, former.
13:21:59 <Cale> conal: Well, "temporally continuous" can mean a large variety of things
13:22:14 <elliott> ezyang_: what does it do? :p
13:22:21 <arkeet> there's nothing continuous about Double =(
13:22:24 <conal> Cale: i said it more precisely in the first papers.
13:22:29 <augur> conal: what is the denotational semantics of FRP?
13:22:32 <conal> arkeet: the semantics is not in terms of doubles.
13:22:33 <ezyang_> Locks the MVar, checks if there's a value in it and returns it if there is
13:22:41 <arkeet> =)
13:22:43 <aristid> ezyang_: it's logically the same as a get-put cycle, except atomic, right?
13:22:51 <conal> augur: see my papers, including Fran & Push-Pull.
13:22:59 <augur> conal: fran?
13:23:23 <Cale> conal: Our system had behaviours which the user couldn't really tell were not continuous, but it also didn't give them operations which enabled them to express the observation of behaviours at just any point in time. (They had to observe behaviours at the occurrences of events)
13:23:23 <ezyang_> aristid: Well, the atomicity is the important bit
13:23:25 <conal> augur: http://conal.net/papers
13:23:33 <conal> augur: "functional reactive animation"
13:23:43 <haasn> atomicPeekMVar --?
13:23:47 <AsgardBSD> carter: NUMERICAL LINEAR ALGEBRA, Hacker's Delight and Algorithm Design are not freely available
13:23:55 <augur> conal: oh ok
13:24:02 <carter> arkeet analytic combinatorics is
13:24:04 <AsgardBSD> [20:54:00] <carter> As they are all free pdfs
13:24:11 <carter> other neat books are A=B
13:24:19 <carter> and generating functionology
13:24:21 <aristid> atomicallyPeekMVar
13:24:22 <carter> those are all freely avaialbe
13:24:24 <carter> and good
13:24:35 <aristid> ezyang_: clearly we need an abbreviation for atomic!
13:24:35 <carter> YES
13:24:46 <Guest8492> atomicallyUnsafePerformInterleaveSTIO
13:24:47 <carter> AsgardBSD doesn't mater
13:24:47 <ezyang_> you can't hug with nuclear arms
13:24:48 <AsgardBSD> i just wanted to respond to what you said earlier, when you said it was free
13:24:50 <aristid> carter agrees with me.
13:24:55 <conal> Cale: in what sense were your behaviors "not continuous"?
13:25:00 <erisco> conal, no one gets to own a term. bastardization is inevitable. I'd recommend not fighting such a war
13:25:03 <carter> AsgardBSD point being
13:25:09 <carter> all of them are good
13:25:17 <carter> and enough of them are free to keep you busy for free for a year
13:25:23 <haasn> > generalCategory ''
13:25:24 <lambdabot>   OtherSymbol
13:25:28 <carter> aristid thats out of context :P
13:25:30 <conal> erisco: my concerns are not about ownership. i don't want to own terms.
13:25:40 * elliott cannot imagine thinking of conal as fighting any war
13:26:02 <conal> elliott: thx.
13:26:51 <jfischoff> conal: is possible to only have behaviors? Is it reasonable to think of events as sampled behaviors?
13:26:59 <Cale> conal: The implementation would only ever have to compute them at the occurrences of events, and there was no way to construct occurrences of events from thin air (except at the external interface to the FRP library)
13:27:04 <aristid> carter: you could qualify your "YES" statements if they don't apply universally to the context! ;)
13:27:11 <carter> darn it
13:27:48 <Cale> conal: So it would be possible to have a semantics for behaviours in which they were only defined on the union of the times at which events occur globally.
13:28:08 <functorf1n> night night
13:28:12 <Cale> conal: in addition to the continuously varying interpretation
13:28:36 <Cale> and as a user of our system, there's no way to distinguish between those interpretations of what's happening
13:28:46 <Cale> (but the discrete one is operationally true)
13:28:57 <conal> jfischoff: if "sampled behavior" /= behavior, then you have two things, right?
13:29:53 <jfischoff> conal: fair enough. I supposed you can recover either one from each other respectively (behaviors being the limit of events perhaps)
13:30:50 --- mode: calvino.freenode.net set +o ChanServ
13:30:53 <jfischoff> conal: have you looked at any of the FRP paper for ICFP 2013?
13:30:56 <Cale> conal: I guess the difference is really more of a difference in terms of the operations available on events, moreso than a difference about behaviours.
13:31:09 <conal> jfischoff: behaviors contain/denote strictly more info than events, so you couldn't recover behaviors from events (other than in a limit, as you note)
13:31:28 <Cale> conal: In our system, there was no way to say "delay the occurrences of this event by 0.001 seconds"
13:31:47 <Cale> or "delay the occurrences of this event by the values of this behaviour"
13:31:58 <Cale> (at the time they would have occurred)
13:32:06 <conal> jfischoff: i think i looked. did it abandon continuous time semantics?
13:32:26 <Cale> Those sorts of things seem (at least to me) to get one into a lot of potential trouble regarding computational complexity.
13:32:41 <jfischoff> conal: I skimmed one to discover that but wasn't able to tell :(.
13:32:46 <Cale> If you have too much work to do at any point in time, then your program fails spectacularly
13:33:27 <Cale> and being able to delay by arbitrarily fine amounts makes it easy to construct performance bugs of that sort unintentionally
13:35:00 <Cale> Having different parts of the system required to be at least somewhat in lockstep regarding events makes it easier to ensure that you'll have enough time in which to compute things before they're already out of date.
13:35:27 <Cale> (because as much as we'd like all pure computations to be instantaneous, they're really not)
13:36:17 <Cale> conal: Does that make sense?
13:37:49 --- mode: geekosaur set -o geekosaur
13:37:56 <geekosaur> I'll risk it, we do seem to be stable-ish now
13:40:39 <Cale> conal: For example, in a completely idealised setting, you could do collision detection where collisions produce events at the exact times when collisions will occur, but because collisions can occur at almost arbitrarily close but unequal times, the pure computations of behaviours which are required following each event can take more time to accomplish than there is available before the next occurrence, and that ends
13:40:39 <Cale> up resulting in disaster.
13:42:19 <Cale> Especially if you get farther and farther behind in your computation of behaviours which have already been invalidated.
13:44:12 <benzrf> hello, anybody know why idoru banned me?
13:44:26 <Cale> benzrf: "spam"
13:44:27 <elliott> ask #freenode
13:44:27 <erisco> Cale, this seems to be an issue about trying to keep your simulation time synced with reality, but of course it doesn't have to be that way
13:44:32 <elliott> we don't know
13:44:36 <benzrf> Cale: I saw that o_o
13:44:43 <elliott> probably a mistake
13:44:46 <Cale> erisco: It has to be that way if you want your game to be playable.
13:44:48 <erisco> Cale, for a game it certainly does, though :)
13:44:54 <benzrf> why would it think I'm a spammer, I wonder...? anyway, I tweaked the pig latin thing, is http://paste.pound-python.org/show/34829 good?
13:45:19 <Cale> benzrf: yeah, that works :)
13:45:46 <erisco> Cale, if the universe runs in this manor it has the unfair advantage that it can take as long as it wants computing the next step and no one will be the wiser
13:46:26 <erisco> Cale, so the answer, clearly, is to download the user's conscious into the machine. in that way, they experience the game correctly regardless of execution times :)
13:48:17 <benzrf> Cale: yessss I am starting to get haskell
13:48:25 <dmwit> benzrf: You might think about pigLatinWord word = case break isVowel word of ("", _) -> word ++ "yay"; (consonants, remainder) -> remainder ++ consonants ++ "ay"
13:48:40 <benzrf> oh, that's a good point
13:48:40 <dmwit> But that's mostly an aesthetic difference.
13:48:42 <benzrf> now I feel less smart
13:48:54 <benzrf> thanks o:
13:49:05 <dmwit> I would say the difference between your code and my suggestion is very small.
13:49:18 <erisco> Cale, just pointing out that the issue you describe seems to be a different beast of a problem that might require different ideas
13:51:01 <Cale> erisco: yes
13:51:38 <Cale> erisco: There's a very big difference in terms of what's acceptable for FRP that's just running a non-realtime simulation of something, and FRP that *needs* to have soft realtime guarantees to be correct
13:53:59 <erisco> Cale, I had a lookup of categories of realtime and if wikipedia is any authority, then I think games fall under "firm" rather than "soft"
13:54:40 <geekosaur> siiiigh
13:54:40 <erisco> Cale, at least there are many aspects which are firm. Graphics being an easy example
13:55:01 --- mode: calvino.freenode.net set +o ChanServ
13:55:42 <Cale> erisco: Well, yeah...
13:55:54 <erisco> Cale, sorry, was just learning something :)
13:56:32 <Cale> erisco: It *can* be useful to have frames display after their deadline, if you want things to admit screen lag in place of missed frames.
13:56:55 <Cale> (like, for instance many old SNES games had)
13:57:07 <S_J> hmm, how bug is the haskell runtime and how much RAM and processor would you need to run it?
13:57:58 <erisco> S_J, at least one of each :D
13:58:40 <ab9rf> you need enough of each :)
13:59:06 <Cale> S_J: It's probably not worth trying to get Haskell programs to run directly on machines with less than a few hundred megabytes of RAM these days, but you probably could get by with tens?
13:59:46 <ab9rf> haskell apps work well enough on the Pi, although the build system struggles.
13:59:47 <Cale> As for CPU speed, it really depends a lot on your application
14:00:22 <erisco> Cale, I suppose it depends on how you define your value function. I guess the categories are black and white in theory and more gray in practice
14:00:24 <Cale> Yeah, as the amount of memory goes down, you'll eventually be forced to work out how to cross-compile :)
14:00:47 <Cale> GHC itself is quite expensive to run
14:00:51 <Cale> as well as the linker
15:03:47 --- topic: 'http://haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
15:03:47 --- topic: set by monochrom on [Tue Jul 09 09:38:58 2013]
15:03:47 --- names: list (clog vk_ michael1 zemmy UziMonkey___ jmbto Finnfinn frontendloader james-ubc HugoDaniel ehaliewicz BobFunk timemage adlan lukexi donri Kuraitou twanvl DrCode unK_ rachit7 MK_FG mizu_no_oto ag90 PeterNor Boreeas sellout joogi Y_Less mirsal melter ortmage dqd shutdown_-h_now seneca Cerise Guest39520 tylergillies ofan machisuji quchen arkeet PHO_ plucas jxport zz_nh2 desc|zenbook drdo gds redgirl ClaudiusMaximus kobain vehk hexagoxel ps-auxw wole Philippa cschneid)
15:03:47 --- names: list (lunarjar MasseR jfischoff lightquake_ neurocyte benprew lcfrs nan` ByronJohnson Reite bbloom sShintah Walther_ kshannon_ Bigcheese_ ChongLi_ obcode tufflax taylorgb_ ljhms_ hvr wlangstroth jzl_ gentleben macph favonia yitz AleXoundOS_ canvon Myk267 Spaceghost purefn armlesshobo doomlord_ hiyakashi solrize_ f8ld thorsten` jorick solirc mkrull jrib Khady canar adimit liftMeMaybe srh_ mikeplus64 homie_ brendan akiress icarot parcs EvilTownCat drbean wallmani)
15:03:47 --- names: list (mikecaruso @ChanServ hive-min1 jrslepak earthy_ Rutger`_ hanDerPe1er lispy_ cross_ mlinksva_ vhz_ corkexaminer cods_ danr_ Nahra BigEndia1 chrra_ Nik05 alcz jackhill_ pikhq_ Saizan_ roconnor_ mornfall rzh_ Tene robbert hyko ATuin folone knz_ Kiryx DT__ Xunie__ BeardedC` andares_ Ycros knightshade Der_Dackel copumpkin lokydor LAMMJohnson joelb Guest71082 chidy jlouis mollerstrand Mowah Dtgr julmac sepp2k pyrtsa pkrnj jliikka saiam tathougies ulfdoz mnbernstein)
15:03:47 --- names: list (mike4_ _justjust Minos` conehead osa1 flebron elliott setmeaway mauke CADD idntfy dwcook stelleg message144 agumonkey sprsquish_ apples bananagram catwiesel cablehead hamishmack hughfdjackson xunatai OlegYch9 gabor mawuli walter ajhager Guest84704 chrisbuchholz mstksg floatingman lambdabot predator117 mxf tomh- milli kylcarte mattrepl S_J Mortomes dgvncsz0f Sculptor_ roboguy_ chatsiri_ mcstar resnik_ erisco nabilhassein Khisanth Velpoman trism [swift] Amadiro)
15:03:47 --- names: list (Jonno_FTW tommd bb010g hiroakip c_wraith hwiersma Suchorski schoppenhauer joehillen dubsg ccxCZ chee1 kcj AsgardBSD tac tornate dncr threesome sipa aford kakos tomprince WhereIsMySpoon randomlogin pmade msuszczy albel727 EvilPenguin cfricke lopex pentace bicgena ggherdov IbnFirnas warpy centrinia mimico__ NeufDeuxRit jonkri Xorlev nooodl Internet13 tensorpudding mami k0ral_ mechairoi quaestor1 thorkilnaur_ amiller_ saep bscarlet mrpantoufle mak` birkenfeld)
15:03:47 --- names: list (hattusili_III_ solarus nsno_ genisage_ Liskni_si blakesmith Ke confound aforemny matzo_ crdueck_ dav_ mserrano csg__ fryguybob Zesler shachaf taruti epta_ Razz|at_1ork ericmj bholst_ nicoo ceverett caligula_ nexx Dybber mm_freak Ulrar ernst_ trevize amathew divarvel xunie_ fikusz dexter2 averell_ dju ipuustin tippenein bakingbread Jello_Raptor zoktar sunfun_ Bio _main_ lpsmith monochrom natte q66 wavewave_ Derander threedaymonk volitek_ McManiaC jkpl finnrobi)
15:03:47 --- names: list (aess_ SoupE liszt liori refold flori supki_ dsirenko_ maksbotan_ nik_89_ newsham fergusnoble heath gspr idnar qwandor|quassel permanente tbn` petanqk Riussi inr Vendethiel Guest40665 mavam opqdonut stomp Watcher7 pettter Eduard_Munteanu DarkFox mjrosenb Mayazcherquoi DigitalKiwi Valodim mononofu aristid noctux tiffany fall_ shintah Guest41554 SuperNoeMan LeaChim ixian8 sondr34 cynick bxc electrogeek alessand1o teiresias davean_ quicksilver SaBer_ rs0 tridacty1a)
15:03:47 --- names: list (vvv_ Kneiva_ zeiris honza dlundy Flint_ pellsson Chousuke_ Vq Tinned_Tuna Ezku_ TheSpectre jlaire KaneTW Jaak_ PrO_OkI_________ koninkje1away tromp__ ab9rf arlinius lemao kevinqcs scottschecter k00mi augur danbru insejn skchrko bytbox lattenwald palhaco Sagi zebr Reisen Fuuzetsu Guest35753 tomejaguar b52 Proteumus jml [[zzz]] wollw bben Vorpal ion Thra11 mlh circle Laney thetallguy h_chiro _seantallen alexander__b dcoutts johnw_ robinbb-freenode \rs epsylon`)
15:03:47 --- names: list (misv whaletechno ft janinge inarru sp3ctum_ tdammers_ Megant_ Hafydd_ koala_man zerokarm1left ethercro1 andrewsw_ mrshoe wereHams1er edkk_ naz__ joar_ charley iteratee_ yan_ Clint Eridius_ qasi sirspazz1lot gdsx_ Guest98347 mike2 isomorph1smes osfameron jang1 klugez tswett SHODAN wagle sdx23 levi dsp__ Excureo sbahra mephx lusory agjacome juhp niklasb kludge` smarter DolphR Alice3 Benzi-Junior ecube dEPy Kabaka jesyspa kuribas biscarch flowsnake torkjak)
15:03:47 --- names: list (Licenser isomorphic burp weie mceier ninzine Blkt marr erkin doomlord _br_ pharaun ssedov MrFahrenheit vobi MrWoohoo bitonic kryft zammy MrFenix_ Krakarn Lethalman pantech latro`a_ noam maoe1 kerrick_ thunderrd Glavata vili ryanakca Bwild FireFly thoughtpolice pqmodn kaw brett terra-and-luna tgeeky yacks doshitan iulian mmaruseacph2 preflex crs_ shanse Draggor inf-groupoid otto_s brianloveswords alshain ibid xnyhps ssbr cognominal brad- brainwash pygospa luite)
15:03:47 --- names: list (machisuji_ aszlig CosmicRay copton kaol lulf pr qz Swizec ezrios sleepybug IanKelling helgikrs Cale felipe_ vermeille Squid_Tamer magicman The_third_man hackagebot dumbhat ktosiek ceii ahihi bqp tvaalen_ perlite bigs_ tkr Dashkal puzza007 jbauman_ cruxeternus prh` jdoliner arbn1 ninwa2 ggreg sevvie_ mokus sjl- xorox90_ prophile Bynbo7 Ornedan JKL1234- mapreduce ousado Starfire Maerten Th0mas tanakh zrot CaptainLex cronject supersym transfinite kloeri Cryovat)
15:03:47 --- names: list (xilo chrisdone dan_johnsin Raynes voxpopuli justinls Ghoul_ ve mr- Nimatek BlastHardcheese Pengoo lpvb mrd _janne alang__ integral satshaba1 sordina1 DrSyzygy_ horlicks_ Adios_ gbluma_ meretrix` hc clampz unlink WzC othiym23 davorak_ CindyLinz aleator_ mantovani tahu suiside b2coutts chirpsalot knyppeldynan udoprog drmegahertz agundry brainproxy linduxed yumike dogmaT leifw liyang zomg Plex- ent drewr callen tudalex `^_^v zenzike_ arnsholt Tehnix MetaCosm)
15:03:47 --- names: list (dixie_ saurik byorgey dyreshark kaictl schlumpi_ Elision_ HalfWayM1n pcapriotti bstrie wting talzeus johanbev elgot arkx xymox pdxleif bziobnic phryk kqr lenstr Fuco peltchu wtw_ s4msung thetallguy1 Urchin args[0] cmsd2 cow-orker slobo zaphar_ps uu1101 tero- Gothmog_ int-e joshc Morgawr kranius froztbyte wto_ Hardolaf gemelen myme1 deggis theDon def- `0660 noplamodo Edoxile bartavelle mixi sohum lpaste alang Nickeeh peddie BrianHV nxorg8 ghorn Counter-Strike)
15:03:47 --- names: list (canta jix_ CODEtakun Fubar^ ChewieBeardy jroesch_ domingo acidi rmunroe_ asante macron Maxdamantus dabradley pfoetche1 dpwright_ Rembane edwtjo def-lkb notdan sm tg `bps Iskarlar Guest26345 Athas zq zw01 statusfailed brixen barrucadu dropdrive neektza1 kosmikus b_jonas Astro- anders^^ mikee relrod valdyn FUZxxl pyykkis Will| jmcarthur Kinnison KitB hpc thorsten1 mortberg petantik mimi_vx thirsteh pnielsen sclv_ jaimef em otterdam XMunkki shepheb yano kav)
15:03:47 --- names: list (hiredman deavidsedice farn gridaphobe Twey Tribal tych0 sajith davorb-cellphone obiwanko td123 TML Kuba zvrba yam Guest7812 asjo Eliel ISF hpd djahandarie banjiewen marienz ido Ralith tessier Natch jyyou rfw kryptiskt tomaw eyck zorzar sg jaspervdj geoffh_ Gracenotes Adeon AntiSpamMeta mux_ nwf yiannis_t ivan\ carter_away ciaranm Blazeix wunki genivf plhk Soft Deewiant Tesseraction Yawgmoth araujo Entroacceptor Draconx PapaJacky benmachine netj niko fayden)
15:03:47 --- names: list (brandonw kaliyuga vmeson guymann bobry akraut blackbit c_14 etrepum jodaro_ si14 upgrayeddd Martty fireglow Baughn covi alang_ jlamothe ahf gdeest troydm hanky-panky16 fijimunkii Francisco goldkatze rien capisce gpampara_off ninegrid Irtopiste ParahSailin chrisdotcode srcerer mgaare_ EarlGray^ bcoppens_ ivan` oldmanst1n tamiko bd__ tmiw betawaffle jssanders flux lahwran junsuiji1 fry_ a11235_ mgregson nullFxn fxrh ccasin geal SegFaultAX joeyh tunixman kini)
15:03:47 --- names: list (geekosaur alpounet swistak35 anon123 acfoltzer Ptival anachron philipde` majoh companion_cube vpm bgamari rgrinberg Zariel vnz ocharles nlogax quux demolithion jlewis orospakr Jonte_ guerrilla cajla_ eL_Bart0 JPohlman1 duairc_ frio1 Sunhay mietek ec_ Xaseron ejls haasn raid luminous SirChurchill jayne adnap cdidd BobuSumisu dreixel munro DustyDin1o dmwit morolin joneshf-work wilfredh akahn hungryblank charlesofarrell xrq Raynos ehd vivekrai hiratara Enigmagic)
15:03:47 --- names: list (nuttycom1 wchun kxra pi8028 waterlaz bogner Dodek joelteon s00pcan_ ziman ehamberg jcp petekaz s_quark palmje sunnavy gbarboza destiny_ numberten idoru willb1 mendez Tarential Shapeshifter colah zaiste_ cjay Shou malorie_ neena fabjan strmpnk jzelinskie Phlogistique Gilly necroyeti yeltzooo M-ou-se arcatan nikola dilinger dmp1ce gseitz jamwt)
15:04:27 <mcstar> nabilhassein: http://sprunge.us/OgQd?haskell this code uses stm to manage multiple processes from a haskeline cli interface
15:05:04 <mcstar> also, it is probably not good practice, what you see there
15:05:14 <mcstar> and i think i forgot how it works, i wrote it months ago
15:05:29 <nabilhassein> haha alright
15:05:31 <nabilhassein> i'll take a look
15:06:40 <monochrom> wait, you can spell NOINLINE as NoInline?
15:08:13 <mcstar> i think it worked, so yeah
15:08:34 <monochrom> I have 2 points.
15:09:57 <monochrom> 1. you don't get a warning or error message for misspelling. try {-# Sjkldjsd gThreads #-}. 2. without the necessary pragma, you may still luck out and get working code
15:10:30 <elliott> a flag to warn for unknown pragmas would be nice for things like this.
15:10:46 <Xaseron> how can i print an IO String?
15:11:15 <tac> Xaseron: you can't
15:11:26 <tac> You can only print Strings
15:11:39 <mcstar> > print "IO String"
15:11:40 <lambdabot>   <IO ()>
15:11:41 <monochrom> what exactly do you want printed?
15:11:42 <tac> So you need to do something like myIOStirng >>= print
15:11:52 <elliott> monochrom++
15:11:53 <nabilhassein> elliott: do you think that would be difficult?
15:12:05 <elliott> nabilhassein: it sounds easy to implement
15:12:08 <nabilhassein> brent yorgey was helping me with some cabal problems some time ago
15:12:23 <nabilhassein> and cabal init automatically detected the dependencies in the source i had already written
15:12:38 <nabilhassein> but apparently there's nothing analogous to update an already existing cabal file
15:12:52 <jdhutah> Xaseron: print =<< s
15:12:56 <nabilhassein> that was a bit surprising to me. so is the lack of warning for nonexistent language pragmas
15:13:17 <nabilhassein> each of these things sounds fairly easy, but i know next to nothing about compilers or build tools
15:13:21 <mcstar> monochrom: Pragmas all take the form {-# word ... #-} where word indicates the type of pragma, and is followed optionally by information specific to that type of pragma. Case is ignored in word.
15:13:25 <Xaseron> i computed a string based on a input (getLine ) and i want to print the result
15:13:53 <monochrom> darn, thanks
15:14:34 <dwcook> @type getLine >>= putStrLn
15:14:35 <lambdabot> IO ()
15:15:06 <monochrom> NoInline looks nicer than NOINLINE, you have taste
15:15:50 <nabilhassein> so does this mean I could have been writing {-# Language NoOverloadedStrings #-} this entire time?
15:15:51 <monochrom> getLine >>= putStrLn as said, or use do notation: do { s <- getLine; putStrLn s }
15:15:51 <nabilhassein> haha
15:16:32 <monochrom> yes, now note that the part "NoOverloadedStrings" is still case-sensitive. only the leading word ("language") is case-insensitive
15:17:03 <nabilhassein> monochrom: thanks. is this documented somewhere?
15:17:04 <monochrom> there is NoOverloadedStrings? that's so cool, I want to add it everywhere!
15:17:21 <nabilhassein> ah i just found it
15:17:22 <nabilhassein> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html
15:17:23 <monochrom> I think it's in the Haskell 2010 Report and mcstar was quoting it
15:17:52 <nabilhassein> trivial to find if you think to look. but i always saw {-# LANGUAGE foo #-} so i always did the same thing
15:17:55 <mcstar> i was quoting the ghc user guide
15:18:36 <monochrom> oops
15:18:58 <mcstar> 7.6.3
15:19:24 <Eduard_Munteanu> Hrmpf... persistent doesn't seem to be able to store arbitrary serializable stuff.
15:19:47 <nabilhassein> yeah, i found that when reading haskell docs i frequently have to go to the url bar and change *.*.* to latest
15:19:52 <Eduard_Munteanu> Besides, PersistValue is a data.
15:20:10 <nabilhassein> because google often turns up old versions as the top result
15:20:15 <nabilhassein> does anyone know a good workaround for that?
15:20:24 <Eduard_Munteanu> I would have expected an open definition, a-la typeclasses.
15:20:37 <mcstar> you might have it on your system
15:20:41 <mcstar> bookmark that
15:20:45 <mcstar> or use grep
15:20:56 <Eduard_Munteanu> nabilhassein: if no version is specified, it will pick the latest
15:22:30 <Eduard_Munteanu> nabilhassein: make a smart bookmark if you're using firefox, then it's a matter of doing opening an URL like   hackage foo
15:22:43 <Eduard_Munteanu> s/doing//
15:23:03 <Eduard_Munteanu> ("hackage" is probably too long, you can abbreviate it)
15:23:46 <nabilhassein> Eduard_Munteanu: thanks!
15:23:58 <mcstar> Eduard_Munteanu: can firefox search sites from the address bar as chromium can?
15:24:04 <mcstar> i miss that feature
15:24:10 <Eduard_Munteanu> mcstar: yes
15:24:34 <mcstar> but would that require manual intervention?
15:24:39 <mauke> no
15:24:39 <Eduard_Munteanu> It should be touted more often; instead they keep adding addons that do the same thing
15:24:40 <mcstar> chromium just picks up seach fields
15:24:53 <mauke> wait, what
15:24:56 <mcstar> ok, then how do i do that?
15:24:58 <mauke> this is #haskell
15:25:03 <mcstar> oh
15:25:15 <Eduard_Munteanu> mcstar: just right click on a search field on e.g. wikipedia and bookmark it
15:25:26 <Eduard_Munteanu> Hm, fair.
15:26:00 <mstksg> is it just me or are haskell binaries unusually large compared to C/Fortran ports?
15:26:07 <mstksg> or is this like comparing apples to oranges
15:26:43 <mauke> everything linked statically
15:26:45 <Eduard_Munteanu> mstksg: that's because they're statically linked by default
15:27:25 <Eduard_Munteanu> By default, Haskell libs are statically linked, only non-Haskell libraries are dynamically linked.
15:27:30 <mstksg> ah i see
15:27:37 <ezyang_> What are functions f :: Int -> Word and g :: Word -> Int such that they are inverses?
15:27:39 <mstksg> that makes sense
15:27:41 <Eduard_Munteanu> Erm, linked into your code, if it wasn't clear.
15:27:45 <ezyang_> clearly fromIntegral is not right, because it truncates
15:28:33 <mauke> subtract minBound
15:29:01 <ezyang_> are you suggesting cast to Integer, subtract and cast back?
15:29:13 <mauke> whatever it takes!
15:29:16 <ezyang_> This really ought to be a no-op...
15:29:18 <monochrom> wait, fromIntegral truncates this one? do you have an example?
15:29:25 <Guest84704> Is there a way to use lens to get overlapped record field names?
15:29:34 <mauke> > fromIntegral (minBound :: Int) :: Word
15:29:35 <lambdabot>   2147483648
15:29:38 <Eduard_Munteanu> ezyang_: you can probably do it with primops I guess
15:29:47 <ezyang_> oh, maybe fromIntegral does do the right thing
15:29:53 <ezyang_> > fromIntegral (maxBound :: Word) :: Int
15:29:53 <lambdabot>   -1
15:29:58 <ezyang_> yay
15:30:03 <monochrom> well, it wraps, but I don't like to call it truncate
15:30:36 <ezyang_> no, it doesn't truncate
15:30:42 <monochrom> to me, "truncate" implies "not invertible"
15:30:49 <ezyang_> Truncate would have maxBound :: Word = maxBound :: Int
15:30:59 <monochrom> yeah
15:31:04 <ezyang_> I was mistaken about how fromIntegral worked
15:31:51 <supki_> Guest84704: I think you can use makeClassy + makeFields for that
15:32:06 <supki_> I don't think it is in any way documented though
15:37:20 <Eduard_Munteanu> I have some threads that do background jobs and report progress (an estimated % completion). Polling is fine, I don't need to be notified on updates (not right now at least). Anything better than IORefs for moving that data around?
15:38:58 <monochrom> if the writer uses atomicModifyIORef, that is fine. you can also use STM's TVar. at this point, either way is fine.
15:39:09 * hackagebot hledger-web 0.21.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.21.3 (SimonMichael)
15:39:39 <Guest84704> how about a shared MVar and blocking on a report?
15:39:41 <c_wraith> atomicModifyIORef is not guaranteed to be serial with readIORef accesses, is it?
15:39:47 <sm> woah.. that hackage upload ended with 500 Internal Server Error
15:40:23 <monochrom> well, I guess the writer could also be just simply writeIORef if it just writes a known number and not "increase by 1"
15:40:56 <Eduard_Munteanu> monochrom: err, I thought IORefs were atomic even with {read,write}IORef
15:41:28 <Eduard_Munteanu> Oh, yeah, I don't need to read-modify-write.
15:41:31 <monochrom> I just mean: don't { n <- readIORef; writeIORef (n+1) }. perhaps you already stay away from that, then cool
15:41:58 <Eduard_Munteanu> monochrom: that'd be fine too, I guess, there's only one writer per IORef.
15:42:42 <Guest84704> Eduard_Munteanu: What's the point of reporting? What does the consumer do?
15:43:48 <monochrom> the consumer pays you money, therefore you would like to fulfill his/her requirements such as "show me percentages every 2 seconds" :)
15:44:07 <Guest84704> If the consumer only prints the progress, then I think it makes sense to have it blocking on an MVar all the time, and then share that MVar among all background threads.
15:44:09 <Eduard_Munteanu> Guest84704: to show it to the user.. it's a web app and right now I'm okay with JS-less pages where you can refresh to check progress.
15:44:42 <Eduard_Munteanu> Guest84704: nah, the consumer has to complete timely
15:44:50 <Eduard_Munteanu> It's an Yesod webapp, actually.
15:45:19 <monochrom> MVar is hard to use or wrong if number of readers and/or number of writers is unknown and possibly 0
15:45:59 <monochrom> if no one is takeMVaring, then the putMVarer is the one being blocked. are you sure you want this?
15:46:00 <Guest84704> if number of readers == 1, then how can it go wrong with n writers?
15:46:21 <Eduard_Munteanu> Guest84704: there's always 1 reader and 1 writer
15:46:35 <Eduard_Munteanu> I track progress among multiple jobs.
15:47:32 <Guest84704> you can always write Job JobId ProgressPercent to the MVar, and aggregate in the reader, so that's not a problem, but if you can't block of course that's not going to work.
15:48:50 <monochrom> I am wrong to talk about number of readers and writers. it should be number of reads and writes.
15:49:17 <monochrom> if you choose MVar, you need number of reads = number of writes. this is a severe constraint.
15:49:19 <_justjust> what does the Scalar b ~ Time mean in a signature like i :: (VectorSpace b, Scalar b ~ Time)
15:49:27 <Eduard_Munteanu> I'd rather not block the writer either.
15:49:27 <leo_31>  i was fired recently. why do my old colleagues still have me on skype? and the boss too
15:49:47 <monochrom> in most polling schemes, you deliberately want /=
15:50:11 <Eduard_Munteanu> _justjust: it's a type equality constraint
15:50:37 <leo_31>  i was fired recently. why do my old colleagues still have me on skype? and the boss too
15:50:47 <mcstar> because it is OT
15:50:49 <Eduard_Munteanu> leo_31: that doesn't sound like a Haskell question
15:50:52 <_justjust> Eduard_Munteanu: thank you!
15:51:10 <leo_31> what is haskell? i was fired from a different job
15:51:28 <Eduard_Munteanu> leo_31: why come here then? It's offtopic.
15:51:38 <monochrom> yeah, wrong channel.
15:51:40 <leo_31> which is the right chsnnel please?
15:51:47 <mcstar> for what?
15:51:55 <leo_31> for my qyestion
15:51:56 <Guest84704> Well the advantage of MVar is that the write is always acknowledged, so you can leave it to the reader to act as the "Monoid".  For IORefs the writer needs to do that.  If the reader of a MVar is "always" blocked on the MVar and never on anything else, then in principle the writer should never block.
15:51:58 <monochrom> I don't know. there may be none.
15:52:19 <mcstar> leo_31: #free-psychoterapy
15:53:34 --- mode: ChanServ set +o elliott
15:53:42 --- mode: elliott set +b *!*jswksl@31.205.67.*
15:53:42 --- kick: leo_31 was kicked by elliott (leo_31)
15:53:43 * Eduard_Munteanu sort of wonders if there's locking library
15:53:50 <elliott> (previously banned with same IP for same stuff)
15:54:02 <Eduard_Munteanu> Ah.
15:54:17 <monochrom> interesting. then you should generalize the jswksl part
15:54:22 <Guest84704> what sort of locks?
15:54:23 <elliott> yes, going to
15:54:35 --- mode: elliott set +b *!*@31.205.67.235
15:54:36 <Eduard_Munteanu> Guest84704: mutexes
15:54:46 --- mode: elliott set -b *!*jswksl@31.205.67.*
15:54:58 --- mode: elliott set -b *!*ssjsj@31.205.67.*
15:55:03 --- mode: elliott set -o elliott
15:55:05 * Eduard_Munteanu wonders if it's "mutex, mutii" :P
15:55:16 <Eduard_Munteanu> Or mutices? :)
15:55:26 <tgeeky> mutexen
15:55:41 <c_wraith> I like mutices
15:56:14 <tunixman> mutexx
15:56:37 <Eduard_Munteanu> tunixman: is that MuTeX? :D
15:57:06 <tunixman> TeX
15:57:14 <tunixman> I'm not sure if that worked.
15:57:20 <monochrom> https://www.dropbox.com/s/4sferqlnqmfhg7g/nu.txt
15:57:22 <arkeet> it worked for me.
15:57:23 <Guest84704> lock =  takeMVar; unlock = putMVar; mkMutex = newMVar 1
15:57:32 <arkeet> why not newMVar ()
15:58:05 <Eduard_Munteanu> Guest84704: hm, yeah... maybe a bit expensive though.
15:58:08 <monochrom> 1 = (), categorically :)
15:59:30 <Guest84704> I think it's pretty close to the bare minimum.  MVar implements a wait-queue for GHC light-weight threads.  The C-library mutex based on linux futexes have real thread waitqueues.  Some bridge is needed and most of it is in MVar.
16:00:12 <Guest84704> But yes, some fat could be trimmed.
16:01:45 <Eduard_Munteanu> I thought that mvar stuff would require a bunch of atomic writes to lock.
16:03:24 <Guest84704> I don't remember, I think it might be one or two.
16:04:16 <Guest84704> I implemented MVar groups a while back, that's why I have even a slight idea.
16:05:33 <monochrom> cool
16:05:57 * elliott wonders who Guest84704 is :P
16:06:57 <ezrios> \whois Guest84704
16:06:59 <ezrios> :>
16:18:48 <acowley> My internet died does anyone have any beautification tips for
16:18:53 <acowley> :t \f -> F.find f . Identity
16:18:54 <nodesjs_is_sucid> Hey Guys
16:18:54 <lambdabot> (a -> Bool) -> a -> Maybe a
16:20:51 * tabemann can't help but feel that just because the browser forces you to code in javascript doesn't mean that the you should on the server as well
16:22:53 * tabemann is glad that there is work on compiling Haskell into JavaScript
16:23:31 <tabemann> (sorry - had to comment on nodesjs_is_sucid's nick)
16:25:00 <nodesjs_is_sucid> ?? tabemann
16:25:00 <lambdabot>  tabemann
16:27:27 <tabemann> nodesjs_is_sucid: I was just commending on the typical motivation for Node.js, and noting that you don't have to code in JavaScript on the client side in the first place, thanks to compilers that target JavaScript already existing, much the less code in JavaScript on the server side too
16:28:11 <acowley> tabemann: I think part of it is that there are a lot of programmers who learned programming through doing front-end JS stuff, and node.js gives them an easy way to do server-side work.
16:29:18 <tabemann> that I've heard, but a good programmer should be able to work in more than one language, and be able to pick up whatever languages they need as they go
16:29:40 <jonkri> Why can I do "\e -> putStrLn $ show (e :: HttpException)", but not "\(e :: HttpException) -> putStrLn $ show e"?
16:29:40 <benmachine> tabemann: regrettably there are many more programmers than there are good programmers
16:29:49 <benmachine> we have to make the best of what we've got
16:30:19 <benmachine> jonkri: well, in one case you're putting the typesig on an expression, in the other it's on a pattern
16:30:28 <benmachine> jonkri: the latter is a reasonable thing to want but they're not the same
16:30:38 <benmachine> jonkri: I believe there's a GHC extension which allows it
16:30:39 <nodesjs_is_sucid> tabemann I'm working on Node.js ...Seriously it's pain in the A***
16:30:42 <benmachine> ScopedTypeVariabes perhaps
16:30:45 <acowley> right or wrong, it's not surprising that people are biased towards what they already know
16:30:47 <tabemann> benmachine: yeah
16:31:28 <jonkri> benmachine: i just want ghc to know the type of e :>
16:31:48 <jonkri> what does it mean to put a type signature on a pattern?
16:32:10 <acowley> This is why type theory folks (e.g. Edwin Brady) are trying to coopt children's toys to teach type theory. Get 'em while they're young, and you won't have to convert 'em later!
16:32:29 <benmachine> jonkri: do you mean "what is the difference between patterns and expressions" or what
16:32:31 * tabemann wonders what one really gets out of coding in JavaScript on the server versus the client, as while it may be the same language, the runtime model is completely different
16:32:47 <benmachine> tabemann: superficial syntactic sameness
16:32:48 <tabemann> *but the*
16:33:03 <benmachine> similarity!
16:33:09 <jonkri> benmachine: i thought i knew the difference, but now i realize that i probably didn't :P
16:33:16 <tabemann> to me the runtime model is the hard part to learn about an environment, not the syntax
16:33:16 <nodesjs_is_sucid> I preferred Class based Language much better then that ... tabemann
16:33:16 <benmachine> that's an aliterative word that is much better
16:33:40 <benmachine> tabemann: yes, the reasons I cite are silly ones, but some people are interested in them nonetheless
16:34:15 <benmachine> jonkri: I'm kind of too tired to think of a really nice expression, but basically patterns are things in function definitions that get matched against arguments
16:34:20 <tabemann> people are often interested in silly things indeed
16:34:29 <benmachine> like, things between \ -> in a lambda or things on the LHS of = in a function def
16:34:44 <benmachine> they're also in case statements
16:35:05 <benmachine> an expression is a value
16:35:06 <tabemann> people seem to irrationally like syntactic sameness, e.g. the proliferation of brace languages after C, even when these languages have completely different underlying models
16:35:10 <jonkri> benmachine: ok (i know :))
16:35:12 <jonkri> thanks
16:35:13 <benmachine> a pattern is something to match a value against
16:35:45 <benmachine> I suppose putting a typesig on a pattern is just saying "I want this bit to be this type"
16:35:48 <mstksg> tabemann: not necesarily irrational; there is much less cognitive friction involved
16:35:57 <benmachine> it doesn't really affect pattern matching at all, just type checking/inference
16:36:15 <tabemann> (for imperative, object-oriented languages, Smalltalk, Modula-3, and EIffel are perfectly good languages, yet they didn't take off in the way that Java or C# did...)
16:36:15 <benmachine> mstksg: depends. false analogies are arguably worse than none at all
16:38:54 <tabemann> false analogies tend to be misleading
16:39:19 <mstksg> people don't want to spend time learning syntax, they want to spend time learning the language and all its intricacies, features, thought processes, paradigms, etc.
16:39:53 <tabemann> but that is just saving time on the easy part
16:39:54 <mstksg> and while syntax can be a path towards the latter, if there is an alternative where syntax-learning is "skippable", people would chose it
16:40:14 <benmachine> syntax compatibility is fine where there's no drawback
16:40:24 <benmachine> but when you're syntax-compatible with C that's not the case
16:41:00 <benmachine> I think the fact that python didn't go for C syntax is what allowed it to make more sensible choices in several cases
16:41:17 <benmachine> e.g. assignments being statements not expressions
16:41:28 <tabemann> syntax compatibility is superficial compatibility; e.g. C++ and Java - they are superficially similar, but underlyingly very different despite both being imperative and object-oriented
16:41:57 <tabemann> python is a good example of that syntax compatibility is not necessary
16:42:14 <benmachine> also C syntax is just not very good if you ask me :P
16:42:20 <benmachine> mercifully, no-one does
16:42:22 <tabemann> yes, a few people complain here and there about whitespace in python, but no one really cares
16:42:37 <FreeFull> Python is still paradigm-compatible though
16:42:44 <benmachine> tabemann: it boggles my mind that people will say to me "python has significant whitespace this is the most terrible thing"
16:42:47 <mstksg> we can make an analogy with human languages; languages written in roman script may look similar but have completely different structures, and so would languages in other scripts/writing systems
16:42:52 <benmachine> as if that ever mattered to anyone
16:43:20 <tabemann> python is paradigm-compatible with dynamic, garbage-collected object-oriented languages, not static, manually memory-managed object-oriented languages
16:43:29 <FreeFull> Do you know what actually is a horrible thing? Javascript's automatic semicolon insertion thing
16:43:54 <mstksg> wish there was a javascript strict mode
16:44:34 <tabemann> there's worse things about javascript
16:44:47 <FreeFull> Javascript is the only language I know where commenting out a piece of whitespace and nothing else can change the meaning of the code
16:45:19 <CaptainK> Glad to have script block :)
16:45:20 <inf-groupoid> FreeFull: Whoa, really?
16:45:52 <tabemann> CaptainK: too bad so much stuff uses JavaScript today that the web is basically useless with scripts off
16:46:32 <CaptainK> not too bad, been able to traverse a ways without it, but ya eventually you need to start pushing buttons
16:46:38 <tabemann> (all the JavaScript tends to wreck things like page caching and screen readers as well)
16:47:00 <FreeFull> tabemann: That really sucks when you want to use a browser that doesn't do javascript
16:47:12 <mstksg> y'all are crazy, javascript can be a beautiful language.  people just use it for the wrong things.
16:47:16 <CaptainK> I have my system inversed colors, that throws off the browsers with some weird shit
16:47:22 <tabemann> FreeFull: you basically have to use one of Firefox, Chrome, Safari, or IE these days
16:47:48 <FreeFull> tabemann: I actually know of other browsers that work pretty well
16:47:49 <benmachine> mstksg: you can do beautiful things with horrible tools, if you're determined enough :)
16:47:50 <CaptainK> does anyone actually program in haskell with a white background and black text?
16:47:52 <diabel232> which haskell web framework should i choose
16:47:55 <tabemann> well, Opera too
16:47:56 <diabel232> which is most popular?
16:47:58 <mstksg> how easy would it have been for the primary scripting language of the web to not have functions as first-class objects
16:48:11 <mstksg> and be extremely functional in its design
16:48:20 <FreeFull> tabemann: Odyssey
16:48:28 <mstksg> javascript is just lisp without parentheses
16:48:29 <tabemann> (if I'm doing any web programming, I'm doing my client-side work in Haskell and compiling that to JavaScript)
16:48:43 <tabemann> JavaScript is a poor parenthesis-less version of Scheme
16:48:48 <FreeFull> "AROS's usability has made a huge leap with the porting of the modern and standards-compliant Odyssey web browser. Based on the WebKit engine, Odyssey includes a JIT Javascript compiler, and supports tabbed browsing, HTML5, CSS, SVG and SSL. It is also highly configurable, with a GUI allowing management of bookmarks, cookies, content blocking, history, passwords and more."
16:49:11 <ocharles> CaptainK: i do, sometimes. but not just black text
16:49:13 <FreeFull> Javascript has an advanced object system
16:49:14 <CaptainK> well its nice how haskell deals with the brackets thats a relief
16:49:25 <FreeFull> Haskell deals with whitespace well
16:49:32 <tabemann> CaptainK: green text on black background here
16:49:40 <FreeFull> Don't want whitespace? Completely optional!
16:49:43 <CaptainK> my eyes burn after 4hours of white background...blood shot red
16:49:50 <FreeFull> You can write any program as one long line of code if you want
16:50:02 <CaptainK> ya green, reminds me of the old terminal days
16:50:06 * tabemann has to agree that Haskell has really nice handling of whitespace
16:50:36 <mstksg> javascript has the best parts of objects without the worst parts (classes)
16:50:36 <CaptainK> yes that what I reall like about it
16:50:47 <FreeFull> Meanwhile, making one-liners in C involves avoiding the preprocessor
16:50:59 <FreeFull> And Perl is just cheating =P
16:51:26 <tabemann> mstksg: I tend to use objects and classes the other way around, using classes as a (poor) replacement for proper modules/namespaces and objects as a (poor) replacement for proper abstract data types
16:52:06 <monochrom> use objects as first-class modules and namespaces! :)
16:52:29 <FreeFull> Hmm, if Haskell had slightly better support for modules
16:52:31 <FreeFull> It'd be perfect
16:52:33 <tabemann> e.g. when coding in OCaml, which has perfectly good modules and abstract data types, I don't use its object system at all, as I have no need to use it
16:52:39 <CADD> mstksg: i would actually disagree with you i think that classes > prototypes
16:53:06 <CADD> it seems that everyone and his grandma that as soon as they get into a prototype based system instantly want to implement classes
16:53:10 <jonkri> how can i scope a variable in a pattern with ghc?
16:53:11 <banister`gym> mstksg: ruby is far more lispy than js IMO
16:53:22 * tabemann doesn't like inheritance except when using the Java-style "interface" model of inheritance, where no implementations are actually inherited
16:53:29 <CADD> banister`gym: you are totally right on that one
16:53:37 <FreeFull> Ruby doesn't feel very lispy to me
16:53:39 <CADD> js was almost scheme!!
16:53:41 <CADD> fff...
16:53:52 <CADD> well, there are no parens
16:53:55 <jonkri> lol, i misspelled scopedtypevariables
16:54:01 <mstksg> banister`gym of course, but i'm just trying to say that the web's scripting language isn't that bad really when you think about what it could have been
16:54:02 <CADD> but it is definatly more lispy than js in certain aspects
16:54:12 <tabemann> our web browsers probably would be using scheme today of JWZ was given a little more time to work on it at Netscape
16:54:20 <tabemann> *if JWZ*
16:54:36 <CADD> tabemann: you are totally right
16:54:45 <CADD> the man wrote the first version of js in ten days!
16:54:47 <CADD> damn
16:54:57 <jonkri> what should you do if you find yourself wanting to make an instance of a list of a type? create a data Type2 = Type2 [Type1] type?
16:55:13 <mserrano> CADD: the first version of js wasn't particularly high-quality
16:55:20 <CADD> jonkri: looks about right
16:55:34 <CADD> mserrano: well yeah, it was written in 10 days
16:55:42 <FreeFull> jonkri: I'd use newtype rather than data there, because it'd be slightly faster
16:55:42 <tabemann> it should be remembered that JWZ himself was a former Lisper
16:55:52 <CADD> FreeFull: definatly
16:55:57 <FreeFull> But that's purely a performance concern
16:56:03 <CADD> tabemann: yup
16:56:39 <CADD> jonkri: that and newtype only allows for one slot in the type, so if you are looking for record types you have to use data
16:58:11 <tabemann> well, at least JavaScript has first-class lexical closures - that is something that many would not have included in it
16:59:05 <tabemann> that probably at least outweighs crap like automatic type conversion between strings and integers...
17:00:04 <banister`gym> FreeFull: the author of ruby was a hardcore elisp programmer, ruby takes things like 'everything is an expression', predicate functions (ending in ?), the same object inspect output, non-local returns, it even takes a bunch of methods from Enumerable directly from standard lisp. AFAIK first-class continuations and the way closures work was taken directly from lisp too
17:00:10 <CADD> tabemann: yeah and its the first mainstream language with them
17:00:10 <jonkri> CADD, FreeFull: Thanks!
17:00:18 <CADD> jonkri: np!
17:00:52 <CADD> banister`gym: you are absolutely right
17:01:19 <tabemann> banister`gym: when you say taken from lisp, I assume you mean common lisp or scheme, as elisp itself has dynamic closures...
17:01:30 <tathougies> in profiling output with -fprof-auto, what does it mean when ghc puts a './' after the cost centre namE?
17:01:54 <tathougies> sorry, a '.\'
17:02:13 <banister`gym> tabemann: yeah elisp has weird scope (fixed in recent versions though)
17:02:59 <tabemann> they did kinda hack on lexical scope into elisp in later times, but it's still hacky because you have to explicitly specify it when you either do a let or for a given source file
17:03:10 <banister`gym> yeah
17:03:51 <CADD> thankfully its lisp, and not some arbitrary language
17:04:11 <CADD> which is why ive been so saddened by the rise of python
17:04:21 <CADD> but atleast its looking to each javas lunch
17:04:24 <CADD> which im fine with
17:04:25 * tabemann would like to see emacs rewritten to use scheme, but that's never going to happen, since there's far too much code already written for it
17:04:34 <CADD> id rather use python over java any day
17:04:38 <banister`gym> speaking of ruby, i just hacked some haskell-style currying/composition magic into a ruby lib :D https://github.com/banister/funkify
17:04:53 * tabemann had a period where he coded in python, shortly after he tried to learn perl and found it revolting
17:05:07 <mstksg> i think ruby is the natural interpreted/weakly typed counterpart to haskell
17:05:10 <liftMeMaybe> what does Cons stand for?
17:05:13 <CADD> ^)*&%)$&*^)$@*&^ = vaild perl
17:05:16 <tabemann> python at the time seemed so much nicer than perl, or C++, or C
17:05:25 <CADD> liftMeMaybe: long history
17:05:42 <CADD> the only think that matters is that it appends to the head of a list
17:05:50 <tabemann> you could say "construct"
17:06:02 <mstksg> you could say it's because it's snoc backwards
17:06:08 <CADD> dont even ask about car and cdr
17:06:10 <CADD> :)
17:06:16 <tabemann> thankfully haskell doesn't use those
17:06:18 <Guest56226> exit
17:06:20 <CADD> ikr?
17:06:24 <CADD> i would mind
17:06:28 <CADD> but im sure others would
17:06:32 <CADD> wouldnt*
17:06:36 <liftMeMaybe> and : is called cons-operator?
17:06:43 <CADD> yes
17:06:49 <CADD> ++ is also used
17:07:00 <liftMeMaybe> and doing : is called 'consing'?
17:07:02 <tabemann> yes
17:07:04 <CADD> iirc : is to append to the head, ++ is for the end of the list
17:07:23 <tabemann> no
17:07:24 <CADD> usually you should use :, since its constant time
17:07:32 <CADD> while ++ is O(n)
17:07:40 <tabemann> ++ is append
17:07:50 <tabemann> i.e. (++) :: [a] -> [a] -> [a]
17:07:58 <CADD> oops, i should have written cons, not append. my bad
17:08:20 <liftMeMaybe> ty
17:08:32 <CADD> tabemen: right you are
17:09:05 <mstksg> banister`gym that's a cute library you got there
17:09:16 <CADD> indeed
17:09:22 <CADD> i was taking a look at it, very nice
17:09:26 * tabemann at times almost wishes that (++) weren't included in Haskell as an operator, as it just invited inefficient code
17:09:26 <banister`gym> mstksg: thanks after doing haskell for a while i wanted some of that stuff in ruby
17:09:43 <tabemann> *invites*
17:09:58 <CADD> tabemann: totally agree with you
17:10:20 <tabemann> (any place multiple (++)s are used should really be implemented with different lists or with types that basically hide difference lists like builders)
17:10:30 <CADD> tabemann: but if you actually care about learning anything, then you will learn that its bad
17:10:49 <tabemann> s/different/difference
17:11:26 <CADD> another thing i would like to see is bitstrings being the default string implementation
17:11:34 <monochrom>  haskell
17:11:36 <CADD> or Text
17:11:59 <tabemann> Text, not bitstrings, as bitstrings don't support unicode
17:12:01 <elliott> ByteString repalcing String would be an unmitigated disaster
17:12:11 <tabemann> and of course in this day and age there is no excuse for not supporting unicode
17:12:32 <CADD> yeah, Text would be better
17:12:44 <CADD> elliott: you are right, but there are options
17:12:58 <tabemann> s/bitstring/ByteString
17:13:05 <CADD> ty
17:13:09 <CADD> i made that mistake too
17:13:57 <tabemann> of course, this is one of those things that in retrospect should have been done differently, but are so entrenched now that they really can't be changed
17:14:38 <tabemann> question - are lazy Texts chunking like lazy ByteStrings?
17:14:45 <CADD> exactly
17:15:04 <tabemann> if so, they should use lazy Texts instead of [Char] for the default string implementation
17:15:28 <CADD> i was responding to your first statement, not the question
17:15:37 <tabemann> yeah
17:15:40 <CADD> i dont know the answer to the question
17:16:11 <tabemann> we need strings to be lazy... but we don't need character-resolution laziness
17:17:58 <bscarlet> Unfortunately Text is internally UTF-16, which means transcoding for conversion to String _and_ for conversion to UTF-8.
17:18:52 <tunixman> tabemann: http://www.emacswiki.org/emacs/GuileEmacs
17:18:55 <tabemann> okay, lazy Text is chunking... but UTF-16 is bad, as just about everything in the outside world except for Win32 calls uses UTF-8
17:19:07 <frankbro> awwwwwww yea .. FP complete beta ide, thats whats up
17:19:15 <CaptainK> is anyone running haskell on Minix?
17:19:39 <tabemann> people run Minix today?
17:19:50 <bscarlet> Is there a instance of IsString that's a newtype around ByteString promising the bytes are UTF-8?
17:20:50 <tabemann> (w h y did they make text use UTF-16?)
17:21:05 <xilo> are there any good haskell books/sites that actually teach by example and exercise?
17:21:06 <CaptainK> tabemann: lol, its a nice os, I like the userland kicked out of the kernel
17:22:17 <tabemann> as microkernel architectures go, I like L4... but L4 is *much* smaller than Minix
17:22:23 <CaptainK> xilo: search for the haskell school
17:22:44 <CADD> frankenbro: use a real editor like vim or emacs :P
17:22:49 <xilo> CaptainK: i get actual schools in google lol
17:23:05 <CADD> s/frankenbro/frankbro/g
17:23:24 <CADD> CaptinK: I wish minix won
17:23:32 <frankbro> CADD, yea thats what I used but .. it has vim mode!
17:23:38 <CaptainK> I was going to say google it, but thats like saying you skidoo instead of snowmobile
17:23:40 <xilo> oh i found it
17:23:41 <CADD> CaptainK: so much better than monolithic
17:23:50 <CADD> frankbro: oh i did not know that
17:24:00 <tabemann> (the problem with vi(m) is I can never remember which mode I'm in...)
17:24:03 <xilo> frankbro: sup foo
17:24:05 <CADD> frankbro: knowing that i may have to give it a second look
17:24:07 <xilo> tabemann: get powerline
17:24:09 <frankbro> xilo, OH SHI-
17:24:16 <CaptainK> in my not so experienced opinion, it looks atractive the micro kernel stuff
17:24:22 <tabemann> (and vim seems to sacrifice any advantages of vi to turn it into emacs, where they you might as well use emacs anyways)
17:24:24 <CADD> frankbro: but vim "mode" is not the same as vim
17:24:34 <monochrom> tabemann: when I am not using English, UTF-16 is a sweet spot
17:24:34 <CADD> frankbro: i have so many damn plugins that i rely on
17:24:34 <CaptainK> there is a video of it starting up in less than 150ms
17:24:46 <frankbro> CADD, well it seems to support what I use the most. Doesnt have visual block so far.
17:25:04 <CADD> frankbro: ouch no visual blocks?
17:25:15 <CADD> frankbro: thats kind of a deal breaker for me
17:25:24 <tabemann> monochrom: I wonder what point you have to reach to actually get denser text with UTF-16 versus UTF-8
17:25:41 <frankbro> yea, emulators rarely support it afaik
17:25:43 <frankbro> viemu doesnt
17:26:04 <monochrom> join #haskell.tw. that's the point at which UTF-16 wins
17:26:04 <CaptainK> anyway, I'm setting up haskell on Minix tonight.  See how it goes.
17:26:12 <frankbro> CADD, really? Just how much do you use visual block.
17:26:13 <xilo> tabemann: http://i.imgur.com/LB3Uncd.png
17:26:17 <CADD> CaptinK: good luck
17:26:47 <CADD> frankenbro: I use visual mode a lot, another thing that most emulators that i have seen dont have the "c" command either
17:26:58 <tathougies> what does it mean in profiling results if the >>= operator is using 73% of time?
17:27:28 <tabemann> xilo: that really looks like trying to emacsify vi
17:27:32 <CADD> frankenbro: the best vim emulator that i have found so far is evil-mode in emacs
17:27:45 <CADD> tabemann: that is exactly why i switched to emacs
17:28:01 <CADD> tabemann: i realized that my vim setup was turning into a horrible imitation of emacs
17:28:13 <CADD> tabemann: i havent looked back, i really enjoy emacs
17:28:22 <CaptainK> CADD: need good packaging, not luck :P
17:28:33 <frankbro> CADD, theres no even a frankenbro in this room .. I dont even know how you manage to do that. Don't you use tab to autocomplete?
17:28:59 <xilo> tabemann: i don't think so
17:29:23 <tabemann> CADD: that is exactly the impression I get of vim these days
17:29:36 <mstksg> tabemann: i set my vim to hilight the current line when i'm in edit mode
17:29:47 <mstksg> it saves the real estate from powerbar which is imo kind of ugly
17:30:09 <mstksg> and also from a UI perspective it's a lot more intuitive
17:30:28 * tabemann doesn't get the view that emacs is too "big"... when compared with the likes of eclipse it is definitively tiny
17:30:44 <CADD> frankbro: no i dont, i havent used irc in a couple of years
17:30:50 <CADD> frankbro: thanks for the reminder
17:31:03 <CADD> tabemann: exactly, that is why i switched
17:31:24 <jdhutah> hi everyone. i'm just starting with haskell and was surprised by the type of (!!).  I wrote my own maybeIndex :: [a] -> Int -> Maybe a. Wondering if this already exists, I've had a hard time finding info about safe indexing, surprisingly.
17:31:42 <CADD> tabemann: a lot of my vim friends just looked at me weird and made all the typical emacs jokes like c-c-x-c-x-ohGodMakeItStop
17:31:50 <elliott> jdhutah: maybeToList . drop i works
17:32:26 <liftMeMaybe> why isnt this lazy? http://lpaste.net/317624256152207360
17:32:32 <monochrom> "emacs is big" was a very old view, long before IDEs existed
17:32:53 <tabemann> CADD: C-x M-x whatever is better than ESCAPE ESCAPE ESCAPE
17:33:00 <CADD> tabemann: true that
17:33:20 <mstksg> tabemann: ctrl+[
17:33:23 <CADD> tabemann: plus evil-mode just sold me, brilliant stuff
17:33:27 <tabemann> monochrom: yeah, the whole "eight megabytes and constantly swapping"
17:33:29 <monochrom> and I should be saying that in #haskell-blah. and you should, too.
17:33:36 <jdhutah> elliott: sorry, should've been more clear. I'm trying to index into a list that might be too short, and just want a Maybe a out
17:33:37 <CADD> tabemann: sadly there are some hitches with using vim macros
17:34:08 <CADD> monochrom: wait, there is a haskell-blah?
17:34:17 <elliott> jdhutah: right, yes
17:34:27 <elliott> I meant listToMaybe, sorry
17:34:31 <elliott> maybeIndex xs i = listToMaybe (drop i xs)
17:34:35 <elliott> but you can just write it inline
17:34:38 <CADD> monochrom: neat
17:34:46 <jdhutah> ah ha
17:34:49 <tabemann> CADD: not surprising
17:35:19 <liftMeMaybe> anyone?
17:35:24 <jdhutah> elliott: thanks.
17:37:28 <dmj> liftMeMaybe: what is your question
17:37:49 <monochrom> liftMeMaybe: I don't know what laziness you expect. but insertion into a key-value list cannot be too lazy, you have to walk the whole list before knowing where to insert, in the worst case.
17:42:40 <liftMeMaybe> monochrom: but take 5 $ foldr (:) [] [1..] works just fine, opposed to take 5 $ histogram $ map (\ x -> (x,x)) [1..]
17:42:57 <liftMeMaybe> isnt it almost the same?
17:44:37 <monochrom> you are saying, (:) and appendAtKey are almost the same. that is a stretch.
17:44:53 <bscarlet> liftMeMaybe: No. The beginning of the histogram isn't the histogram of the beginning.
17:44:57 <jzelinskie> how do you pronounce <*>?
17:45:09 <CADD> <*>
17:45:11 <CADD> :P
17:45:29 <CADD> angle brackets star can work too
17:45:44 <CADD> some may call it the double sparrow i think
17:45:53 <jzelinskie> lol
17:46:00 <CADD> since *> is called right sparrow and <* is called left sparrow
17:46:01 <monochrom> (:) x xs does not examine xs. appendAtKey x xs examines xs, all of it.
17:46:10 <jzelinskie> thanks
17:46:14 <CADD> np
17:47:13 <pentace> What is the proper way of making a Cabal package that states "default-language: Haskell2010" also compatible to Haskell 98?
17:47:28 <liftMeMaybe> monochrom: is it possible to make it lazy?
17:47:30 <monochrom> well, ok, I misread some of your code. now I don't know what appendAtKey does
17:49:20 <liftMeMaybe> monochrom: it appends the value of the current pair (from the fold) to the list of the matching entry in that histogram list [(a,[b])]
17:50:06 <yitz> <*> "apply to" ?
17:50:52 <jzelinskie> i thought it might be something like that since it is part of APPLIcatives
17:51:16 <yitz> it a applies a function inside the applicative
17:52:19 <liftMeMaybe> bscarlet: can you think of a way of reversing that list?
17:52:43 <bscarlet> liftMeMaybe: reversing which list?
17:53:09 <dmj> liftMeMaybe: Can you give a concrete example
17:53:53 <liftMeMaybe> histogram $ map (\ x -> (x,x)) [1,2,3,4,5] is [(5,[5]),(4,[4]),(3,[3]),(2,[2]),(1,[1])], I suspect that the lazyness does not work because of this?
17:55:25 <dmj> liftMeMaybe: Why would that "stop" laziness? is histogram strict? Did you write this function?
17:55:46 <monochrom> it's at http://lpaste.net/317624256152207360
17:55:53 <dmj> ah thanks
17:57:19 <sleepybug> why does (putStrLn . show) 1 work but map (putStrLn . show) [1] not work
17:57:25 <sleepybug> this is in ghci
17:57:44 <sleepybug> :t map (putStrLn . show)
17:57:44 <lambdabot> Show a => [a] -> [IO ()]
17:57:57 <sleepybug> I don't really get it
17:57:59 <cdk> sleepybug: (putStrLn . show) :: Show a => a -> IO ()
17:58:07 <cdk> you want mapM_
17:58:16 <sleepybug> ohh okay
17:58:19 <cdk> also, putStrLn . show == print
17:58:28 <cdk> > mapM_ print [1..5]
17:58:30 <lambdabot>   <IO ()>
17:58:33 <sleepybug> oh I didn't know that
17:58:39 <cdk> eh, well it works
17:58:43 <sleepybug> cool thanks :3
17:58:52 <cdk> np
17:59:35 <bscarlet> liftMeMaybe: You might manage to make (map fst . histogram) lazy, if you rewrote histogram without the reversal. But I don't think you can make it lazy if you look at the output lists. The first output list could include an element from arbitrarily far out in the input, so you're never going to get the the second pair.
17:59:47 <dmj> sleepybug: (putStrLn . show) == print
18:00:05 <jonkri> how can i go from a "yyyy-MM-ddTHH:mm:ssZ" string to a haskell date representation of an appropriate type?
18:00:44 <dmj> :t putStrLn . show
18:00:46 <dmj> :t print
18:00:48 <lambdabot> Show a => a -> IO ()
18:00:50 <lambdabot> Show a => a -> IO ()
18:01:42 <sleepybug> thanks dmj :3
18:02:05 <dmj> np ;)
18:03:05 <pentace> jonkri: Have you looked at the time package?
18:03:15 <tabemann> one thing I've been wondering about offhand - are there any advantages to using existential quantification over simply hiding your values in closures, and when type class instances are needed, wrapping newtypes around those closures and providing instances for those?
18:04:06 <jonkri> pentace: yes, but i couldn't see how to go about the time zones (it might not be "Z")
18:05:13 <pentace> http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Format.html#g:2
18:05:26 <pentace> parseTime accepts a format string
18:06:44 <jonkri> pentace: So "Z", "CET", etc, can be interpreted by %Z?
18:07:15 <pentace> That's how I understand the docs, yes
18:08:07 <geekosaur> to the extent that it can be interpreted at all
18:08:42 <CADD> tabemann: im pretty sure its to do with the forall syntax that you get with existential quantification, which you dont get with closures
18:08:44 <geekosaur> (there are a lot of time zone abbreviations that are not unique)
18:08:50 <CADD> although i could be wrong
18:09:58 <tabemann> CADD: but typically with existential quantification you are still essentially hiding your values behind closures, as the only way you can do anything with them is by giving them one or more type classes and applying functions for those type classes to them
18:10:45 <jonkri> thanks
18:11:27 <pentace> Isn't the default-language field documented somewhere?
18:12:32 <CADD> tabemann: hmm, well im not sure then. It may just be syntactical sugar, since im not that well brushed up on EQ.
18:13:43 <tabemann> EQ does seem more *succinct*, once you've defined your types, than relying on hiding behind closures
18:15:02 <CADD> tabemann: and isnt that what haskell is all about?
18:15:08 <CADD> not really but partly
18:15:44 <CADD> either way i thought tht EQ gave you more machinary that closures
18:15:54 <CADD> s/tht/that/g
18:16:01 <tabemann> well
18:16:24 <tabemann> hmm
18:16:26 <tabemann> I onno
18:16:33 <CADD> me neither :)
18:16:37 <tathougies> i'm experiencing a pretty steep slowdown with a monad transformer over IO
18:16:53 <CADD> haskell is never slow!
18:16:54 <CADD> jkjk
18:16:55 <tathougies> ghc profiling reports that i spend almost 70% of execution time in the bind function for my custom monad
18:17:13 <cdk> tathougies: post some code samples please
18:17:19 <CADD> yes please
18:17:22 <tathougies> okay
18:17:33 <tathougies> cdk: What specifically, the definition of my monad? or something more?
18:17:48 <CADD> tathougies: that would be a good start
18:17:56 <cdk> the monad instance would be helpful, since you said bind is taking the most time
18:18:10 <cdk> also the newtype/data declaration for the custom monad would be goo
18:18:12 <cdk> good
18:18:24 <tathougies> i'll give you the monad definition; but the code i'm trying to optimize is pretty involved, so i'll have to condense it down if you want to see it
18:18:41 <tathougies> is there a preferred haskell pastebin?
18:18:44 <CADD> tathougies: nice use of semicolon
18:18:45 <cdk> lets start with the monad instance and data type first.
18:18:49 <cdk> @where hpaste
18:18:49 <lambdabot> http://lpaste.net/new/haskell
18:19:13 * hackagebot shelly 1.3.0.7 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.0.7 (GregWeber)
18:19:13 <cdk> tathougies: ^
18:19:13 <CADD> huh, new address
18:19:31 <cdk> ugh, ninja'd by hackage
18:19:55 <CADD> @where hpaste tathougies
18:19:55 <lambdabot> http://lpaste.net/new/haskell
18:20:47 <tathougies> http://lpaste.net/90790
18:20:58 <tathougies> it's a simple reader-type monad
18:21:28 <tathougies> monad transformer*
18:21:46 <CADD> tathougies: yeah that looks straight out of any book on haskell
18:22:00 <tathougies> yeah...
18:22:24 <CADD> what else did the profiling say tathougies?
18:22:25 <tathougies> let me work on getting a benchmark, using my monad and then using IO
18:22:32 <cdk> tathougies: what does AstroConfig look like?
18:22:34 <CADD> excellent
18:22:53 <CADD> tathougies: what cdk said
18:23:08 <tathougies> AstroConfig is a data record type, one constructor
18:23:20 <CADD> tathougies: did you try newtype?
18:23:25 <tathougies> for what?
18:23:31 <tathougies> AstroConfig has more than one field...
18:23:32 <CADD> nvm, its a record type
18:23:56 <tathougies> also, i don't see why it should make a difference. AFAICT, it should just be like a pointer being passed around
18:24:23 <CADD> in general newtype is quite a bit faster than data
18:24:31 <cdk> and AstroConfig is parameterized by (AstroT m)?
18:24:36 <tathougies> yes it is
18:24:44 <cdk> could I see that definition?
18:24:46 <tathougies> but it's only ever instantiated once
18:24:48 <tathougies> sure...
18:25:01 <mm_freak> CADD: "quite a bit" is quite a bit exaggerated
18:25:12 <CADD> mm_freak: true enough
18:25:14 <mm_freak> in most cases it's only marginally faster, but it has different semantics
18:25:24 <CADD> mm_freak: indeed
18:25:48 <CADD> mm_freak: its amazing the optimizations that goes on under the hood
18:25:48 <tathougies> http://lpaste.net/90791
18:26:01 <CADD> mm_freak: i mean the STGM is a beast in and of itself
18:32:16 <cdk> tathougies: i dont think whatever is causing your slowdown is coming from the monad instance. but here's some stylistic changes that probably wont change performance, but look nicer/more idiomatic
18:32:20 <cdk> http://lpaste.net/90790
18:32:54 <tathougies> cdk, thanks, i'm working on putting a small example together to showcase the problem i'm hacing
18:33:11 <cdk> alright, i'll take a look when you're ready
18:45:56 <Ghoul_> line 17 AstorT -> AstroT btw
18:46:43 <ricree>  I have a reactive banana question. I was poking around one of the first examples, and trying to figure out how to add a button that changes one of the text boxes while still updating the result. So far, what I've got will change the text box, but won't update until another event happens
18:46:49 <ricree> http://lpaste.net/90795
18:48:11 <covi> If I have data X = Y and, say, data Y = Z, is Y and X the same type?
18:49:39 <tabemann> umm that won't work ifyou're using data
18:49:48 <tabemann> that is true if you use "type" not "data"
18:49:54 <tabemann> if you use "data" that won't compile
18:50:16 <covi> yeah
18:50:29 <tabemann> with "data" you have to provide a data constructor, and no, they won't be the same type then
18:50:31 <covi> but i'd like to be able to say Y 'is' X
18:50:39 <tabemann> you need "type" for that
18:50:48 <covi> or 'is a' X
18:50:55 <geekosaur> ummmm
18:50:59 <geekosaur> OOP detected
18:51:02 <covi> cause I really want data X = Y | SthElse, where Y and SthElse is data
18:51:18 <geekosaur> that's not how it works
18:51:18 <amosr> (it will compile because data constructor and type are in different namespaces but it is a bad idea)
18:51:19 <covi> geekosaur: yeah...kinda
18:51:32 <covi> geekosaur: so what's the idiomatic way to do this
18:51:36 <geekosaur> Y is a data constructor unique to the type X
18:52:02 <geekosaur> data X = SomeY Y | SomeOtherThing Z
18:52:29 <tabemann> and no, that doesn't make Y an X
18:52:59 <tabemann> (if Haskell even had notions of subtyping in the first place)
18:53:36 <monochrom> in "data X = Blah Stuff Etc", "Blah" is not a type name.
18:53:39 <geekosaur> Haskell is not OOP based, and trying to treat it that way will lead you into various ugly predicaments. (there *are* ways to simulate OOP, but they're not very friendly)
18:55:43 <monochrom> also, I don't know what you want to do
18:56:18 <monochrom> or perhaps I know? data X = Case1 Y | Case2 SthElse
18:56:52 <ricree> Anyone have a moment to help with a reactive banana question? I'm trying to get the button in http://lpaste.net/90795 to update both the text input and the result text
18:57:05 <monochrom> Blah, Case1, Case2 are value constructors. if you don't know what that means, 1st-order approximation is "tags".
19:03:01 <LuxuryMode> im using GHCI, how can do i load interfaces or modules, e.g. the Char interface?
19:03:15 <applicative> LuxuryMode: import Data.Char
19:03:22 <LuxuryMode> thanks applicative
19:03:23 <applicative> or :m +Data.Char
19:03:24 <amosr> :m + Data.Char
19:04:24 <applicative> LuxuryMode: old tutorials use Char, Monad, IO etc.; use Data.Char , Control.Monad, System.IO instead. you can find the documentation somewhere on your system probably
19:04:47 <LuxuryMode> noethanks
19:04:54 <LuxuryMode> got it, thanks
19:05:03 <LuxuryMode> couldnt import it using any of your suggestions
19:06:03 <LuxuryMode> oh nm
19:06:09 <applicative> LuxuryMode: are you inside ghci with the Prelude> prompt?
19:06:10 <LuxuryMode> didnt realize i had to use fully qualified name when using it
19:06:19 <LuxuryMode> like map Data.Char.toUpper "hello"
19:06:31 <elliott> you don't
19:06:32 <elliott> if you import it
19:06:33 <applicative> oh, you don't if you type import Data.Char
19:06:35 <LuxuryMode> was doing map Char.toUpper "hello"
19:06:53 <applicative> you can do: import qualified Data.Char as Char
19:07:13 <LuxuryMode> https://gist.github.com/levinotik/5971938
19:07:24 <applicative> then qualify the names, but Data.Char doesn't have  overlaps with Prelude
19:08:10 <LuxuryMode> import qualified works
19:08:12 <LuxuryMode> thanks guys
19:08:13 <applicative> you should be able to type 'map toUpper "hello" '
19:08:21 <applicative> > map toUpper "hello"
19:08:22 <lambdabot>   "HELLO"
19:08:25 <applicative> like so
19:08:36 <LuxuryMode> even nicer, thanks
19:08:41 <applicative> lambdabot has done import Data.Char
19:09:04 <applicative> you need to import qualified for things that overlap Prelude or whatever else
19:09:18 <LuxuryMode> working through this: http://www.umiacs.umd.edu/~hal/docs/daume02yaht.pdf as I wait for this: http://amzn.com/0201882957 to ship to me :)
19:09:18 <applicative> such as ByteString, Vector, Map etc.
19:09:29 <LuxuryMode> im afraid the former might be outdated in some respects...
19:10:02 <applicative> you might try the recent 'learn you  a haskell'
19:10:15 <LuxuryMode> oh i see, so the Data.Char actually ruins itimport Data.Char then map toUpper "hello" works
19:10:17 <applicative> it has a more up to date perspective than either of the above
19:10:25 <LuxuryMode> been through learn you a haskell
19:10:27 <LuxuryMode> or most of it
19:10:27 <applicative> ah
19:10:31 <LuxuryMode> others recommended that book
19:10:36 <LuxuryMode> figured id give it a whirl
19:10:49 <applicative> if you just do 'import qualified Data.Char' then you have to do Data.Char.toUpper
19:10:49 <LuxuryMode> any background i have in FP is from Scala
19:11:01 <LuxuryMode> but im trying to take a lesscircuitous route
19:11:03 <LuxuryMode> :)
19:13:03 <applicative> wow Peaker seems to have made a pile of emendations to wxHaskell https://github.com/Peaker/wxHaskell
19:13:21 * applicative will see if it actually builds ...
19:21:55 * applicative wonders, what makes a man or woman use require MissingH as a dependency
19:39:00 <prophile> are there formulations of the IO monad that don't resort to RealWorld hackery?
19:39:50 <roconnor> prophile: http://r6.ca/blog/20110520T220201Z.html
19:41:52 <prophile> roconnor: interesting
19:42:13 <prophile> how practical would a free IO monad be?
19:42:30 <prophile> it strikes me you'd have to augment the data type to add an action
19:43:20 <roconnor> prophile: it might not be too bad if you use open recursion
19:43:38 <prophile> open recursion?
19:44:18 <roconnor> instead of using a recursive data type, you write a functor that has a parameter where the recursive type would go.
19:44:28 <roconnor> then you use Mu F where F is your functor.
19:44:40 <roconnor> when you want to augment your type, you use Mu (F :+: G)
19:45:19 <prophile> ah, now we're getting into territory that's beyond me
19:45:25 <prophile> Mu is similar to Fix?
19:45:29 <roconnor> yes
19:45:32 <roconnor> @src Mu
19:45:32 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
19:46:04 <roconnor> prophile: you may want to check out "Data Types a la carte" which as I recall talks about this sort of thing
19:46:11 <roconnor> @src fix
19:46:11 <lambdabot> fix f = let x = f x in x
19:46:40 <prophile> will do
19:46:41 <roconnor> well, you can write fix less efficently as   fix f = f (fix x)
19:46:47 <roconnor> er
19:46:54 <roconnor> fix f = f (fix f)
19:47:55 <prophile> this looks interesting
19:49:31 <roconnor> edwardk had some augmentation to the free monad for IO that I never understood.
19:49:47 <applicative> hm, whats wrong with RealWorld hackery
19:50:36 <applicative> hugs uses newtype IO a = IO ((a -> IOResult) -> IOResult)
19:50:54 <dmwit> ocharles: pong
19:52:40 <prophile> applicative: interesting
19:52:49 <roconnor> applicative: http://programmers.stackexchange.com/questions/161568/critique-of-the-io-monad-being-viewed-as-a-state-monad-operating-on-the-world
19:52:49 <prophile> that looks a lot like Cont IOResult
19:53:03 <applicative> http://cpansearch.perl.org/src/AUTRIJUS/Language-Haskell-0.01/hugs98-Nov2003/libraries/Hugs/Prelude.hs it was being discussed somewhere not long ago
19:53:08 <prophile> would the monad instance be the same?
19:54:04 <applicative> yes surely, but I don't see it in the hugs code
19:55:41 <applicative> no , there it is; it is (>>=) = primBindIO which is primitive...
19:55:54 <applicative> a little opaque this
19:55:55 <prophile> that may just be for efficiency
19:58:34 <applicative> hm, roconnor this objetion is in the 'awkward squad' paper
19:58:37 <applicative> no?
19:58:50 <slack1256> How do other funcional languages with the problem of multiple logical futures in data stuctures?
19:59:23 <prophile> the nondeterministic lambda calculus, clearly
20:00:24 <prophile> huh
20:00:30 <prophile> so apparently there is a nondeterministic lambda calculus
20:00:32 <applicative> roconnor: in any case, as ground for introducing an 'operational semantics' he gives some argument that on a denotational semantics everything IO ends up being _|_
20:00:35 <slack1256> exactly
20:01:23 <prophile> https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CC8QFjAA&url=http%3A%2F%2Fwww.ki.informatik.uni-frankfurt.de%2Fpapers%2Fnd986.ps&ei=nR_eUbebGOXu0gWPuIHACw&usg=AFQjCNF_NTgimuXp5tirOZZZyXI83YDCoA&bvm=bv.48705608,d.d2k
20:01:27 <prophile> ah
20:01:29 <roconnor> applicative: I don't recall seeing this objection in the akward squad
20:01:30 <prophile> damn it google
20:01:56 <applicative> roconnor, page 15
20:01:56 <prophile> http://www.ki.informatik.uni-frankfurt.de/papers/nd986.ps
20:02:19 <applicative> Regarded as a function on Worlds, this program loop :: IO () ; loop = loop
20:02:37 <applicative> has denotation _|_
20:03:09 <applicative> but alas this program, loopX :: IO () ; loopX = putChar 'x' >> loopX
20:03:24 <applicative> also has denotation _|_
20:03:46 <applicative> Yet these programs would be regarded as highly distinguishable by a user
20:03:53 <applicative> I think thats the same
20:04:08 <prophile> here's something sort of related that bothers me, going on a tangent
20:04:19 <prophile> by the curry-howard isomorphism, fix is clearly impossible to implement
20:04:22 <prophile> and yet lo and behold
20:04:52 <Cale> prophile: General recursion results in an inconsistent logic, yes.
20:05:02 <applicative> a system with fix cant be viewd as a logi
20:05:03 <applicative> c
20:05:13 <prophile> ah, so recursion is what breaks it?
20:05:15 <prophile> gotcha
20:05:18 <Cale> It can, it's just an inconsistent logic where there's a proof of anything.
20:05:25 <roconnor> applicative: I see
20:05:33 <prophile> Cale: because bottom is in every type?
20:05:37 <Cale> yeah
20:05:41 <applicative> Cale, I think thats an alternative description of the same
20:05:51 * prophile learns things
20:05:52 <Cale> fix id
20:05:53 <roconnor> applicative: but he gives are argument this the State model yeilds trivial dentational semantics, not that IO yields trivial denotational sematnics.
20:05:56 <Cale> is a proof of anything
20:06:34 <roconnor> also, why isn't PDF portable?
20:06:36 <applicative> roconnor: yes, I see that; I was trying to figure it out
20:06:42 <Cale> But the proofs in this logic have different meanings, so we aren't too concerned with the fact that everything is provable, because we care about the differences between proofs.
20:06:45 <prophile> roconnor: does the free monad IO suffer the same problems?
20:06:51 <thoughtpolice> prophile: sure, that IO implementation in hugs is definitely Cont-ish. Haskell 1.2 had stream-like IO that had a continuation layer
20:07:02 <thoughtpolice> it's an interesting read
20:07:14 <roconnor> loopX = putChar 'x' >> loopX is non bottom in a free monad model of IO.
20:07:48 <Cale> It's not clear what sort of thing is meant to be the denotation of World
20:07:50 <zRecursive> what does free mean in free monad ?
20:07:56 <Cale> What do they choose?
20:08:01 <roconnor> However, I have no reasonable model of concurency using free monads.
20:08:09 <monochrom> a free monad model of IO will actually tell you, correctly, that you get an infinite sequence of 'x'
20:08:15 <applicative> free means, built up like expressions, with no laws to identify terms, very crudely
20:08:20 <roconnor> OTOH, I'm not sure anyone else has a reasonable model of concurency either.
20:08:24 <Cale> roconnor: Sure you do. Stick in a bunch of concurrency primitives by fiat :)
20:08:37 <prophile> roconnor: I suppose if you could inject some notion of interleaving
20:08:38 <roconnor> Cale: reasonable. :)
20:08:45 <zRecursive> applicative: thx
20:08:50 <prophile> although that still doesn't model interactions outside of the program
20:08:55 <roconnor> prophile: ya, it seem one could hack on a scheduler
20:09:09 <Cale> It's a free monad after all, so you can put in basically whatever operations you want without having to specify how they work, and then worry about that in the interpreter.
20:09:35 <Cale> (and in whatever denotational semantics you manage to come up with)
20:09:36 <roconnor> prophile: I find it plausable there are laws you want to impose on the free monad (making it non-free)>
20:10:02 <dmwit> ?tell ocharles ?tell me what you want, or send an email to me at dmwit.com, or file a bug if this is about one of the packages I maintain, or something -- it seems we don't really get on IRC at the same time
20:10:03 <lambdabot> Consider it noted.
20:10:05 * prophile tries not to think about the ramifications of unsafePerformIO
20:10:07 <roconnor> but I'm not for sure certain there are any.
20:10:41 <roconnor> if you want to model unsafePerformIO, you will probably have to give up on the standard denotation of the lambda calculus.
20:11:14 <prophile> I'm imagining most of the discussions about how IO is modelled just put aside unsafePerformIO
20:11:30 <roconnor> is unsafePeformIO part of the FFI?
20:11:48 <prophile> it's certainly used in the FFI, I don't know if it's "part of it"
20:12:04 <roconnor> I'd be happy to get all of Haskell 98
20:12:53 <prophile> looks like unsafePerformIO is not in the haskell 98 report
20:13:07 <Cale> Yeah, it's in the FFI addendum to the H98 report
20:13:16 <Cale> and in H2010 as a result
20:13:25 <prophile> curse addenda
20:13:36 <roconnor> the free monad model of IO isn't so bad because basically anything could happen when doing IO.
20:13:45 <tabemann> http://lpaste.net/90796 < asking for opinions about this idiom
20:14:01 <roconnor> I recall a reddit question asking how to recursively list directory contents.
20:14:06 <prophile> although it might be less modular, data types a la carte notwithstanding
20:14:29 <Cale> It's part of the language, but you don't have to consider it as an ordinary part so much as a low-level hook which you can rely on being present that lets you extend the semantics of expression evaluation with new things.
20:14:31 <roconnor> and I realized that all the implementations were naively assuming that the directory contents were not changing as you traversed it.
20:14:36 <prophile> tabemann: looks a lot like a comonad
20:14:49 <Cale> In the same way that we might eventually standardise Template Haskell
20:15:13 <roconnor> I doubt it is even possible to get a consistent directory traversal.
20:16:17 <Cale> tabemann: Yeah, that kind of idiom is a good way to encode object oriented programming.
20:16:25 <Cale> tabemann: Even without the typeclass.
20:16:48 <monochrom> I can't find unsafePerformIO in Haskell 2010 or the 98 FFI addendum
20:17:05 <Cale> It's kind of silly in this *particular* case -- you could make a doubly infinite list of Strings and that's pretty much the same thing.
20:17:18 <roconnor> tabemann: http://www.haskell.org/haskellwiki/Tying_the_knot has some tips on making that more efficent
20:17:24 <roconnor> though it is kinda hard to understand
20:18:06 <tabemann> Cale: I knew this case was kind of silly, but I figured the concept could be used in many other cases where one wants to have implementation and data hidden behind a uniform interface without type variables
20:18:14 <Cale> But if there were other operations than just showing, the fact that you can capture the function parameters and not have to evaluate the structure all at once is really useful for encoding fancier things.
20:18:41 <JuanDaugherty> has cabal hell been squelched? I just setup a 7.6.3 environment and I'm amazed at how smooth it's gone all the way thru yesod-bin and some others.
20:18:58 <roboguy_> it seems to me that there are a fixed set of things that can (and can't) happen when you do IO, depending on what specifically you're doing. seems like that could help with some sort of formal description
20:19:05 <monochrom> no, instead, fresh starts are always smooth
20:19:21 <Cale> For example,  data GameObject = GO { display :: IO (), timeStep :: DeltaTime -> [GameObject], react :: UserInput -> [GameObject] }
20:19:57 <roconnor> you get your entire Game, all in one value.
20:20:05 <Cale> and then you can define various values of this type by recursion which express how these things are displayed on the screen and react to user input and the passage of time by replacing themselves with lists of game objects
20:20:13 <JuanDaugherty> well leksah would be the acid test, and yeah I have made sure sofar to only do cabal installable 7.6 stuff
20:20:17 <prophile> but they can't interact with other game objects
20:20:24 <Cale> Yeah, that's an issue :)
20:20:32 <Cale> You need a little more than this
20:20:45 <prophile> actually I'd think of comonads
20:20:54 <prophile> each game object's next state is a function of it and all other objects in the game world
20:21:28 <Cale> Like, perhaps some way for each GameObject to express its geometry (for collision and such), and an extra parameter to timeStep consisting of the GameObjects currently present.
20:21:32 <tabemann> hmm
20:21:36 * tabemann looks at comonads
20:22:07 <tabemann> comonads don't seem to be able to express the concept of basically eliminating type variables, allowing multiple implementations and data representations to be mixed together
20:22:23 <Cale> But yeah, the point is more to contrast this sort of thing with the perspective of having a type which has lots and lots of constructors for everything that can occur in your game world
20:22:40 <applicative> tabemann: maybe it should be data InfTree a = InfTree a (InfTree a) (InfTree a)
20:22:52 <Cale> You instead put the operations on those objects into records, and define the objects by mutual recursion.
20:23:32 <tabemann> applicative: the data structure in the example could be represented that way for any given value representation, but I wanted to be able to put multiple values with different implementations and representations in the same list
20:23:57 <roboguy_> Cale: what about something like this: http://prog21.dadgum.com/24.html
20:24:32 <roboguy_> where functions give state changes, basically
20:25:51 <Cale> Yeah, the idea is that your overall game loop would then be implemented by putting together all these transitions in your GameObject values in some fashion (or by composing GameObjects together in such a way that there is just one which needs to run and will run all the others)
20:26:21 <joelteon> what do you guys suggest for parsing dates in arbitrary formatS?
20:26:29 <tabemann> applicative: okay, I can see how that would work here, and yes, that could be extended much further
20:26:54 <tabemann> that is actually basically the same thing as what I implemented, except I used a record so I could use function call syntax
20:26:56 <Cale> joelteon: http://www.haskell.org/ghc/docs/latest/html/libraries/time-1.4.0.1/Data-Time-Format.html
20:27:26 <joelteon> but that requires a format string
20:27:45 <Cale> Oh, you mean like trying to guess the format string?
20:27:50 <joelteon> yeah
20:27:55 <Cale> (that's obviously impossible in general...)
20:28:03 <Cale> I wonder what the unix date program does.
20:28:31 <joelteon> yeah, I know
20:28:44 <joelteon> I know of a rubygem that does something similar, though
20:29:56 <Cale> Well, I haven't heard of anyone implementing that in Haskell yet...
20:30:24 <Cale> You might try to just write a function which consumes a string and emits a guess at a format string for it.
20:30:48 <joelteon> yeah
20:31:27 <Cale> by various heuristics -- you'll want to determine late which number is the day of month and which is the month of year, in case someone puts in something like 04/21
20:31:49 <tabemann> I seee being able to guess day versus month order as particularly problematic
20:32:11 <tabemann> as there are many days that will be valid months, and there is no rule globally on what order days versus months tend to take
20:32:20 <tabemann> you might guess from the current locale
20:32:26 <Cale> Of course, if you allow those to get swapped, then you'll have an issue where it behaves inconsistently
20:32:35 <tabemann> (e.g. month before day in US, day before month elsewhere)
20:32:36 <Cale> like if the same person enters 04/02
20:32:55 <Cale> You might also make a locale-based ruling on that
20:33:00 <Clint> joelteon: you might want to look at what http://hackage.haskell.org/packages/archive/dates/0.2.2.0/doc/html/Data-Dates.html does and expand it a bit
20:34:02 <Cale> oh, yeah, that looks like it tries a variety of things
20:34:15 * hackagebot llvm-general 3.2.4.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.4.3 (BenjaminScarlet)
20:35:07 <tabemann> note that there is also year position as well, as there are two general places the year can be place
20:35:10 <tabemann> *placed
20:35:15 <tabemann> there is no problem with 4-digit years
20:35:20 <tabemann> but 2-digit years are problematic
20:35:43 <tabemann> well
20:35:57 <tabemann> one might assume that two digit years can only come *after* the day and month
20:36:18 <tabemann> and only handle years before them if they are four digit
20:37:03 <Michae___> has anyone used haskell in programming competitions like topcoder? Would you recommend using it?
20:37:32 <CADD> Michae___: Absolutely
20:38:07 <Michae___> CADD: Was it harder to optimize the problems in a low level sense compared to an imperativ elanguage? Did that matter?
20:38:09 <CADD> Michae___: i havent used it in topcoder, but ive used it in some informal competitions with friends and killed hardcore
20:38:44 <CADD> Michae___: Uhh, haskell is pretty good at finding optimal solutions you usually just have to remember a few rules of thumb
20:38:59 <CADD> Michae___: like never use the default Char implementation
20:39:07 <CADD> Michae___: Always remember to TCO
20:39:11 <tabemann> TCO?
20:39:15 * hackagebot llvm-general 3.3.4.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.4.3 (BenjaminScarlet)
20:39:17 <CADD> tail call optimization
20:39:28 <tabemann> well
20:39:33 <carter> confounwoot
20:39:43 <tabemann> there are areas in which TCO isn't necessary, e.g. if you are constructing lists
20:40:09 <CADD> true true, but if you are writing a recursive function you should write it in tail call form
20:40:25 <CADD> but then again you should really never write an explicit recursive func
20:40:34 <CADD> you should always use higher order functions
20:41:07 <tabemann> if you are constructing a list like: foo x = x : foo (bar x) you don't need TCO
20:41:08 <CADD> Michae___: Haskell is pretty damn fast on its own, plus adding in laziness really helps
20:41:41 <CADD> Michae___: I use it because after a while i pretty much just think in haskell
20:41:44 <CADD> tabemann: sure sure
20:41:56 <Michae___> yeah, that's why I'm considering it
20:42:03 <JamesJones> About to buy a vpn... What do you think of Mullvad? Anyone else use better vpn services?
20:42:12 <CADD> tabemann: actually that pretty much is in tail call form
20:42:55 <applicative> no, the outermost function symbol is (:)
20:43:15 <roboguy_> I think I heard there are cases where non-TC recursive functions are better, performance-wise, than TC recursive functions but that never made much sense to me. is it like that in that list case?
20:43:49 <CADD> applicative: oh you are right i forgot that is an infix form
20:44:14 <tabemann> when constructing lists the way I mentioned, you aren't actually recursively calling yourself - you're creating a thunk and passing it to (:), which will only be evaluated when the tail of the cons cell is evlauated
20:44:56 <edkk> applicative: does ghc do tail-call-modulo-cons tc's, tho ?
20:45:10 <edkk> (I have no idea :p)
20:46:27 <tabemann> roboguy: tail recursive list construction means you build the entire list in memory and then return it, whereas non-tail recursive list construction (in Haskell) means you only construct the list as needed by the consumer
20:46:49 <roboguy_> ok, that makes sense
20:48:51 <tabemann> for a while to me the tail recursive strategy seemed more natural to me, but that's because I was used to working in OCaml, and OCaml is strict, and what is the obvious way to do things in Haskell will easily explode the stack in OCaml
20:49:43 <edkk> so, when should you "do" TCO in haskell ? (if at all)
20:50:37 <tabemann> edkk: when using functions that are strict on their arguments
20:51:11 <edkk> tabemann: ofc. makes sense!
20:51:53 <tabemann> e.g. foldr (+) 0 xs will blow up the stack easily because (+) evaluates its arguments
20:54:13 <tabemann> one note that when using TCO in Haskell, any "accumulator" arguments should be made strict with bang patterns, lest they create a towering tower of thunks that will eat potentially unbounded amounts of heap space, and then explode the stack when they are finally evaluated
20:54:47 <applicative> edkk: tabemann 's function was basically 'iterate bar' but see how ghc optimizes iterate http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-List.html#iterate
20:55:04 <edkk> tabemann: sound advice. thanks!
20:56:17 <ezrios> @hoogle =<<
20:56:17 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:56:17 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:56:34 <JoeyA> Just wondering, could an atomic readMVar be implemented by using takeMVar and tryPutMVar?
20:57:04 <JoeyA> If another thread calls putMVar right after we takeMVar, we simply won't restore the original value.
20:57:06 <ezrios> so =<< is just (flip >>=)?
20:57:15 <JoeyA> @src =<<
20:57:15 <lambdabot> f =<< x = x >>= f
20:57:20 <JoeyA> Yes
20:57:25 <prophile> technically no
20:57:28 <prophile> it's flip (>>=)
20:57:38 <CADD> prophile: lol
20:57:43 <JoeyA> @quote intuition
20:57:43 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
20:57:44 <prophile> (flip >>=) would be weird
20:57:44 <CADD> ezrios: yes
20:57:46 <JoeyA> nvm
20:57:50 <prophile> :t (flip >>=)
20:57:51 <lambdabot> ((b1 -> a -> c) -> (a -> b1 -> c) -> b) -> (a -> b1 -> c) -> b
20:57:53 <CADD> prophile: what would be lisp for you
20:58:03 <ezrios> ah right, damn sections ._.
20:58:08 <prophile> (flip >>=) is valid haskell is the thing
20:58:18 <prophile> due to the reader monad
20:58:20 <CADD> prophile: indeed
20:58:27 <edkk> applicative: cool. can't say I know enough about how the compilation/execution steps actually will look lower down, yet, but I'll have a look
20:58:33 <prophile> and it looks mighty weird too
20:58:43 <ezrios> prophile: apologies, still learning Haskell
20:58:54 <prophile> ezrios: no need to apologise
20:59:01 <CADD> ok, now i know this is the haskell irc, but i was wondering what are your guy's opinion on fexprs?
20:59:21 <CADD> since you guys are haskellers, i think that you guys would be more ok with it than ocaml or lisp people
20:59:22 <sipa> i have no guys
20:59:28 <CADD> sice it is lazy
20:59:58 <CADD> sipa: yeah oops
20:59:59 <tabemann> JoeyA: about your question earlier, that *looks* like it might do what it want it to, but don't trust my answer on this one
21:00:08 <JoeyA> I'm not a lisper, but from reading the description, all functions in Haskell are fexprs.
21:00:13 <tabemann> *what you want it to*
21:00:34 <CADD> JoeyA: kinda, they don't evaluate their arguments
21:00:52 <sipa> what is a fexpr?
21:01:06 <JoeyA> Of course, the function might force some arguments to produce a result
21:01:15 <CADD> it is a function (usually in a lisplike lang) that doesnt eval its args
21:01:20 <JoeyA> e.g. \a -> a+1
21:01:24 <CADD> sipa: ^
21:02:13 <JoeyA> If you force (\a -> a+1) 3, + will force a so it can produce a number.
21:02:26 <CADD> so you could have something like: (deffexpr something (a b) (+ a b)) (something (+ 2 2) (+ 2 2))
21:02:31 <CADD> and that would return
21:02:40 <tabemann> it seems the main criticism of fexprs is that there is no static way to determine whether a function is one in a lisp, and hence no way to properly compile evaluation of arguments for a function before calling it
21:02:48 <CADD> (+ (+ 2 2) (+ 2 2)) unevaluated
21:03:01 <tabemann> macros don't have this problem because they are expanded during compilation rather than at runtime
21:03:12 <CADD> so obviously (eval (something (+ 2 2) (+ 2 2)) ==> 8
21:03:24 <CADD> tabemann: exactly
21:03:55 <CADD> tabemann: the argument in the other direction is saying that lisp shouldnt be compiled, it should always be interpreted
21:04:10 <edkk> so, call, me stupid, but what is the difference between a fexpr and a function?
21:04:12 <CADD> tabemann: since lisp already blurs the distinctions between compile time and untime
21:04:19 <CADD> s/untime/runtime/
21:04:37 <CADD> 20:59 < CADD> it is a function (usually in a lisplike lang) that doesnt eval its args
21:04:42 <tabemann> but that is a major disadvantage, because it has been clearly shown that  you *can* compile lisps with substantial performance gains over their being interpreted
21:04:42 <CADD> 21:01 < CADD> so you could have something like: (deffexpr something (a b) (+ a b)) (something (+ 2 2) (+ 2 2))
21:04:51 <CADD> 21:01 < CADD> (+ (+ 2 2) (+ 2 2)) unevaluated
21:04:53 <CADD> 21:01 < CADD> so obviously (eval (something (+ 2 2) (+ 2 2)) ==> 8
21:05:17 <CADD> tabemann: of course, that is the beauty of things like SBCL
21:05:34 <edkk> or, the less fortunately named, stalin
21:05:53 <CADD> tabemann: there are some lisps like newlisp that are completely interpreted and pretty performant
21:05:59 <dolio> fexprs are not like lazy evaluation.
21:06:04 <CADD> edkk: lol stalin is interesting
21:06:09 <CADD> dolio: you are right its not
21:06:22 <dolio> Because 'eval' is not meant the same way as 'evaluate' in Haskell.
21:06:23 <tabemann> there's other scheme compilers that produce fast code, e.g. bigloo
21:06:45 <edkk> yeah. bigloo is extreme
21:06:47 <CADD> indeed bigaloo is cool
21:07:04 <CADD> im actually a pretty big fan of racket, which is pretty performant
21:08:35 <CADD> tabemann: either way, i think that you should have the option to use fexprs if you want to, and any code that doesnt use them can still be compiled
21:08:52 <CADD> tabemann: just like with everything, the right tool for the job
21:08:58 <tabemann> what do you get from fexprs that you can't get from macros, though?
21:09:18 <CADD> tabemann: they are available at runtime as first class citizens
21:09:22 <CADD> unlike macros
21:10:02 <CADD> that and if you go full fexpr, the entire enviroment is available first class
21:10:10 <CADD> which is mindbending to say the least
21:10:20 <tabemann> the only thing is that the only place I see a good reason to not compile code is at the read-eval-print loop
21:10:29 <edkk> agreed
21:10:38 <edkk> and even there, why not just compile it..
21:10:40 <CADD> tabemann: yes that would be a wonderful place to use them
21:10:55 <CADD> edkk: well, fundamentally you really cant compile fexprs
21:11:04 <tabemann> edkk: yeah - if your compiler is fast enough, you might as well actually compile your code in the read-eval-print loop
21:11:18 <tabemann> you might actually embed your compiler into the runtime, and compile code passed to eval
21:11:46 <CADD> http://lambda-the-ultimate.org/node/3861
21:11:54 <CADD> intersting ltu article on first class envs
21:12:17 <edkk> tabemann: yep. doesn't Scala's REPL do that ?
21:12:18 <JoeyA> Ah, I figured out why using tryPutMVar in readMVar wouldn't work: it would allow a putMVar call to push an existing value out of the way.
21:12:33 <CADD> edkk: ugh the scala repl
21:12:45 <CADD> edkk: yeah it does compile every line added through the repl
21:12:47 <edkk> tabemann: and yeah! after writing a nice scheme compiler, "eval" should be a one-liner :p
21:13:12 <edkk> CADD: well, as soon as the jit is warm, it runs quite nicely
21:13:29 <edkk> but, those three seconds are painful
21:13:34 <CADD> edkk: yeah you are right, but i like clojure quite a bit more than scala
21:13:45 <CADD> edkk: and i think clojure is an abomination
21:13:54 <dolio> This is pretty off topic.
21:14:01 <CADD> edkk: so you can imagine how i feel about scala
21:14:10 <CADD> dolio: you are right, to haskell-blah!
21:14:32 <edkk> dolio: yeah. quite silent though. but, should probably move to #blah. sorry
21:21:39 <Michae___> is there a way in the haskell list monad of expressing that a value can be any number of elements from the list?
21:22:39 <JoeyA> Michae___: what do you mean?
21:22:45 <JoeyA> a <- [1,2,3,4,5]
21:22:47 <JoeyA> Now what?
21:23:17 <JoeyA> a, of course, will be either 1, 2, 3, 4, or 5 (each will be used in order).
21:23:23 <Cale> Michae___: perhaps  x <- subsequences xs  ?
21:23:34 <Cale> > subsequences [1..5]
21:23:35 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
21:24:39 <applicative> > [a |  a <- subsequences [1..5], sum a = 5]
21:24:40 <lambdabot>   <hint>:1:39: parse error on input `='
21:24:46 <applicative> > [a |  a <- subsequences [1..5], sum a == 5]
21:24:47 <lambdabot>   [[2,3],[1,4],[5]]
21:29:51 <prophile> at what number of language pragmas at the top of a file does one have to step back and contemplate one's sins
21:33:35 <JoeyA> Seven.
21:34:25 <JoeyA> But I'd count {-# BangPatterns #-} and {-# RecordWildcards #-} as freebies.
21:54:17 * hackagebot bindings-GLFW 0.0.0 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-0.0.0 (BrianLewis)
21:54:19 * hackagebot GLFW-b 1.0.0 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.0.0 (BrianLewis)
21:54:21 * hackagebot GLFW-b-demo 1.0.0 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.0 (BrianLewis)
21:55:16 * tabemann wonders why they didn't make BangPatterns part of Haskell 2010
21:56:07 <blackdog> anyone know if there's a way to get Network.Socket.getAddrInfo not to perform ipv6 lookups?
21:59:28 <sipa> in getaddrinfo(), specify AF_INET as af_family
21:59:38 <sipa> for the haskell wrapper, bo idea
21:59:40 <sipa> no
22:05:00 <Ghoul_> tabemann: and likewise, bang patterns :)
22:05:19 <quastra> @pl
22:05:19 <lambdabot> (line 1, column 1):
22:05:19 <lambdabot> unexpected end of input
22:05:19 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
22:05:33 <Ghoul_> uh, sorry, magichash
22:05:42 <Ghoul_> my brains a mash today
22:09:56 <blackdog> sipa: worked it out, i was just being dumb. now i just need to find a way to tell http-conduit not to ask for ipv6 as well...
22:27:46 <nabilhassein> is there something like getByte, analogous to getChar, but returning a Word8?
22:27:57 <nabilhassein> i can do getChar and then convert it
22:28:12 <nabilhassein> but i think getByte would be slightly cleaner if it's in some library
22:28:17 <tgeeky> @hoogle IO Word8
22:28:18 <lambdabot> Did you mean: :: IO Word8
22:28:18 <lambdabot> No results found
22:28:34 <Ghoul_> uh, you can do
22:28:47 <Ghoul_> getByte :: Get Word8; getByte = get
22:28:49 <Ghoul_> probably
22:29:02 <Ghoul_> but let me check, theres probably something else
22:30:24 <Ghoul_> :t getWord8
22:30:26 <lambdabot> Not in scope: `getWord8'
22:30:27 <nabilhassein> @info Get
22:30:28 <lambdabot> Get
22:30:36 <Ghoul_> nabilhassein: there is actually a getWord8
22:30:36 <nabilhassein> where does `Get` live?
22:30:44 <Ghoul_> http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html
22:31:18 <tgeeky> @hoogle :: IO Word8
22:31:18 <lambdabot> System.Random randomIO :: Random a => IO a
22:31:18 <lambdabot> System.Exit exitFailure :: IO a
22:31:18 <lambdabot> System.Exit exitSuccess :: IO a
22:31:26 <tgeeky> hehe, at least that's correct, if not helpful
22:31:44 <nabilhassein> Ghoul_: its type seems a bit strange. why is it in Get instead of IO?
22:31:49 <Ghoul_> @hoogle :: Get Word8
22:31:49 <lambdabot> Did you mean: :: RequestMethod
22:31:49 <lambdabot> Data.ByteString.Lazy head :: ByteString -> Word8
22:31:49 <lambdabot> Data.ByteString head :: ByteString -> Word8
22:31:58 <Ghoul_> its a parser monad kinda
22:32:15 <Ghoul_> Wait, maybe I misunderstood
22:32:19 <Ghoul_> are you in Get already?
22:32:45 <nabilhassein> i think i need to be in IO
22:32:49 <nabilhassein> to get a byte from the user
22:32:50 <nabilhassein> right?
22:32:50 <Ghoul_> Oh im sorry, I misunderstood. You're talking about the :: IO ones
22:33:53 <Ghoul_> Yes, the get library is something different to what you want, that's my fault sorry. There doesn't seem to be a :: IO Word8 so you're out of luck
22:35:39 <tgeeky> nabilhassein: try hGetByte from Prelude.Generalize
22:36:00 <tgeeky> http://hackage.haskell.org/packages/archive/prelude-generalize/0.4/doc/html/Prelude-Generalize.html
22:36:52 <Ghoul_> (which is hGetChar with some internal machinery)
22:37:11 <tgeeky> Ghoul_: I don't even claim to understand what it is, but it least it has a type Handle -> IO Word8
22:40:42 <arkeet> I like prelude-generalize
22:40:43 <nabilhassein> tgeeky, Ghoul_: thanks! i appreciate it
22:40:44 <arkeet> it has bool
22:43:03 <arkeet> otoh it looks like a jumble of things
22:44:01 <tgeeky> arkeet: yeah, he who makes a generalized prelude rather well split up into sections with a common coherent reason, will be praised
22:51:11 <kvda> when you have 2 maybes, is there a better way to test if they're both Just, and extract the value then using >> if (isJust a) && (isJust b) then fn (fromJust a) (fromJust b) ...
22:51:20 <kvda> ?
22:51:34 <roboguy_> fn <$> a <*> b
22:51:49 <elliott> kvda: case (a, b) of (Just x, Just y) -> fn x y; _ -> ...
22:52:00 <elliott> always use case, (almost) never isJust/fromJust
22:52:35 <roboguy_> oh, you aren't wrapping it in Just
22:52:44 <Cale> You should only use isJust/fromJust if you're only using one of the two :)
22:53:11 <inf-groupoid> And you have a proof that the one you are using is really the case!
22:53:18 <inf-groupoid> (Even if you cannot tell the compiler.)
22:53:29 <prophile> even then
22:53:31 <kvda> great, thanks elliott, i had a feeling i wanted to do that, but didn't think of passing them both in as a tuple
22:53:38 <prophile> enforce this stuff through the type system
22:54:08 <prophile> if it can't be Nothing, it (probably) shouldn't be in a Maybe in the first place
22:54:21 <inf-groupoid> prophile: Some stuff cannot be enforced by the type system, because the type system is not expressive enough to even express it.
22:55:06 <prophile> naturally
22:55:22 <prophile> but "this isn't nullable" can be :)
22:58:45 <elliott> there are values I do not know how to write without fromJust or rank-2 types.
23:01:04 <inf-groupoid> prophile: Of course, "this isn't nullable" is expressible - by not using Maybe. But sometimes what you cannot say is the fact you have a proof that, for some "f :: a -> Maybe b" and "x :: a", "f x :: Maybe b" is guaranteed to be of the form "Just y :: Maybe b".
23:01:06 <fragamus> edwardk are you here
23:02:08 <fragamus> pairs
23:29:19 * hackagebot nehe-tuts 0.2.4 - Port of the NeHe OpenGL tutorials to Haskell.  http://hackage.haskell.org/package/nehe-tuts-0.2.4 (JasonDagit)
23:53:09 <flebron> so i was just blown away by some beautiful haskell and would like to share
23:53:20 <flebron> this is how kosaraju's algorithm for strongly connected components is implemented in Data.Graph:
23:53:28 <flebron> scc  :: Graph -> Forest Vertex
23:53:29 <flebron> scc g = dfs g (reverse (postOrd (transposeG g)))
23:54:02 <flebron> that is something i might write on a whiteboard to explain the idea of the algorithm to a newcomer. that it also compiles and runs is just wonderful to me.
23:56:20 <circle>  is there a function which is basically filter, except if it doesn't pass the predicate a default value is inserted?
