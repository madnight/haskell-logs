00:10:26 <heilkn> hi! I'm trying to install haskell-platform 2013.2.0.0 in a prefix but the build process complains, that happy is required to build happy
00:16:36 <heilkn> :( prefix installation of haskell-platform-2013.2.0.0 is completely broken
00:20:04 <monochrom> worksforme. check PATH. do not run "Setup clean" in happy's source directory.
00:24:16 <heilkn> monochrom, I'm doing a fresh install without any haskell enviornment pre installed
00:24:49 <heilkn> I did install ghc-7.6.3 and tried to install haskell-platform afterwards
00:25:34 <heilkn> I needed to remove a line in scripts/build.sh, because GHC_PACKAGE_PATH is not supported
00:26:53 <sobhan> in haskell any function can only run one command ?
00:27:22 <heilkn> sobhan, what do you mean by this?
00:27:47 <sobhan> heilkn: can my functions run many command ?
00:27:55 <heilkn> what is a command?
00:28:11 <sobhan> heilkn: err...another function
00:28:51 <heilkn> sobhan, you can compose more than one function
00:28:58 <sobhan> thanks
00:31:07 <heilkn> for example f x = x^2 + 2 * x
00:31:47 <heilkn> http://codepad.org/m5Qc64KE
00:33:01 <heilkn> sobhan, or http://codepad.org/hBA0Z78u
00:33:36 <Kinnison> sobhan: or http://codepad.org/S03AdLS4 if you're looking to "run more than one thing" from main as it were.
00:34:04 <sobhan> heilkn: i was thinking of some thing like f = command 1
00:34:08 <sobhan> command 2
00:34:22 <heilkn> then look at Kinnisons link
00:35:07 <heilkn> sobhan, you need to understand, that function can have only one return value
00:35:13 <sobhan> ok thanks
00:35:43 <Kinnison> sobhan: although that one return value can be a compound/complex value, you're not limited to a single int or similar.
00:35:52 <heilkn> so if you run the second command in a do block, the result from the first command will be lost
00:38:15 <heilkn> http://codepad.org/NhlcuEnG
00:38:19 <heilkn> sobhan, ^^
00:41:18 <zRecursive> printf "%.2f\n" (9.575 :: Float) => 9.58 in haskell, it is what i need. However, in OCaml ,C and CL  all return 9.57.   what special way does haskell use ?
00:42:30 <heilkn> zRecursive, if you round it mathematically correct, you will get 9.58
00:42:50 <Lethalman> > printf "%.2f\n" (9.579 :: FloaT)
00:42:51 <lambdabot>   Not in scope: type constructor or class `FloaT'
00:42:51 <lambdabot>  Perhaps you meant `Float' ...
00:42:53 <Lethalman> > printf "%.2f\n" (9.579 :: Float)
00:42:53 <lambdabot>   No instance for (Text.Printf.PrintfType a0)
00:42:54 <lambdabot>    arising from a use of `e_129...
00:43:44 <zRecursive> heilkn: 9.58 is what i need. it seems haskell doesnot use IEEE float representation ?
00:43:54 <zRecursive> as in C
00:47:11 <supki> > showFFloat (Just 2) 9.575 ""
00:47:12 <lambdabot>   "9.58"
00:53:30 <zRecursive> It is not IEEE 754 ?
00:54:38 <supki> well, that a function I believe printf uses to format floats
00:54:51 <supki> I'm not an expert on IEEE754 :)
00:55:58 <zRecursive> anyway haskell give me what i want , neat :-D
01:10:50 <YoungFrog> perhaps it depends on the underlying implementation ?
01:11:24 <YoungFrog> (I know no haskell, but I know such things happen sometimes)
01:33:58 <gogoat100> k
01:34:08 <gogoat100> 0/ *
01:38:27 <adas> can someone please tell me what kind of code i can write to understnad the state monad?
01:39:40 <tikhonjelvis> you could try implementing the state monad yourself from first principles
01:40:00 <tikhonjelvis> this approach works really well for some people and really poorly for others
01:41:48 <merijn> I agree, implementing the State monad is not very hard and is very enlightening
01:43:36 <shachaf> join = fmap extract!
01:43:36 <orzo> as an anarchist, i say we dismantle the State monad
01:45:03 <merijn> The Socialist comonad
01:45:07 <adas> maybe first i can write some code that uses the state monad b4 i write another implementation of the state momnad
01:45:07 <merijn> Everyone can get things out
01:46:30 <Krakarn> why isn't there a function which type is: Monad m => m a -> (a -> b) -> m b
01:46:48 <mauke> :t flip liftM
01:46:48 <lambdabot> Monad m => m a1 -> (a1 -> r) -> m r
01:47:08 <Krakarn> hmm I was trying to search for it but couldn't find it for some reason
01:47:15 <merijn> Krakarn: That just liftM and/or fmap
01:47:20 <alpounet> with the args flipped
01:47:25 <mauke> @hoogle Monad m => m a -> (a -> b) -> m b
01:47:25 <merijn> :t flip fmap
01:47:25 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
01:47:25 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
01:47:25 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
01:47:26 <lambdabot> Functor f => f a -> (a -> b) -> f b
01:47:36 <Krakarn> maybe theres something wrong with my hoogle
01:48:19 <merijn> Anyhoo, as you can see, that function does in fact exist ;)
01:48:26 <supki> @ty (Control.Lens.<&>)
01:48:27 <lambdabot> Functor f => f a -> (a -> b) -> f b
01:48:41 <Krakarn> oh wait, i was searching for Monad m => m a -> (a -> b) -> m (a -> b)
01:48:53 <Krakarn> thanks
01:49:10 <merijn> :t let fmap f x m = join $ m >>= return . f in fmap
01:49:11 <lambdabot> Monad m => (a1 -> m a) -> t -> m a1 -> m a
01:49:29 <merijn> oh
01:49:31 <merijn> lol
01:49:36 <merijn> Extra argument >.>
01:49:42 <mauke> :t const return
01:49:43 <lambdabot> Monad m => b -> a -> m a
01:51:30 <gh_> hi, can someone who is using Mac OSX tell me the value of System.Info.os (by using ghci for instance)?
01:51:55 <merijn> gh_: "darwin"
01:53:31 <gh_> merijn, thanks
02:49:16 <Cedric__> Hi there, I'm looking for a hacker
02:52:40 <orzo> for what
02:52:48 <orzo> do you pay?
02:53:26 <Cedric__> Yes I do
02:53:39 <Ghoul_> Oh?
02:54:32 <elliott> this is off-topic.
02:56:58 <astor> Next on hackage: rootkit in haskell.
02:57:04 <orzo> heh
02:58:07 <Ghoul_> There /was/ that zero day rootkit sdk leak a while back
02:58:14 <Lethalman> hacker may refer to a term for software hacker, not necessarily security :-)
02:58:22 <Ghoul_> wtb> ffi bindings :P
02:58:33 <merijn> Ghoul_: How much you paying? :p
02:58:37 <Ghoul_> haha
03:00:52 <juliend> hi, i would like install gitit on raspberry
03:01:03 <juliend> i use raspbian distrib
03:02:40 <juliend> i not found deb, so i would like cabal install gigit, but, compilation problem, and very slow
03:02:53 <hashcat> hi, what's fix in Data.Function used for?
03:03:10 <elliott> anonymous recursion
03:03:30 <elliott> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
03:03:30 <lambdabot>   3628800
03:03:40 <elliott> fix (\x -> ...) is the same as let x = ... in x
03:03:42 <elliott> where ... can mention x
03:04:13 <hashcat> why is it named fix??
03:04:38 <Ghoul_> I wonder that too.
03:05:40 <merijn> > fix error
03:05:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:05:54 <elliott> hashcat: it finds a fixed point
03:05:58 <elliott> fix f = f (fix f)
03:05:58 <elliott> so
03:06:00 <hashcat> what happend?
03:06:02 <elliott> f (fix f) = fix f
03:06:10 <elliott> so (fix f) is a fixed point of f
03:06:14 <elliott> (gives same value when you plug it back in)
03:06:24 <Ghoul_> @src fix
03:06:25 <lambdabot> fix f = let x = f x in x
03:06:55 <merijn> hashcat: As elliot points out "fix f = f (fix f)", i.e. it calls f on the result of "fix f", fix having the type "(a -> a) -> a"
03:07:15 <merijn> hashcat: Now, you might wonder "how can fix ever produce an 'a' if it needs an 'a' to produce one?"
03:07:45 <hashcat> merijn: true
03:07:48 <merijn> hashcat: Which is where laziness comes into play, if 'f' does can begin producing a result without it's argument, then it will work
03:08:10 <banister> what is an arrow?
03:08:23 <banister> i just read "proc is like lambda for arrows"
03:08:28 <banister> what's an arrow ?
03:08:33 <merijn> hashcat: Imagine the function '\x -> "hello" ++ x', clearly it can return "hello" before needing to evaluate x, right?
03:08:49 <merijn> > fix (\x -> "hello" ++ x)
03:08:50 <lambdabot>   "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohell...
03:09:07 <Ghoul_> > take 15 $ fix (\x -> "hello" ++ x)
03:09:09 <lambdabot>   "hellohellohello"
03:09:23 <merijn> hashcat: "f (fix f)" basically becomes ""hello" ++ fix f"
03:09:29 <Ghoul_> I always get impressed by laziness.
03:09:40 <merijn> hashcat: And 'fix f' again becomes ""hello" ++ fix f", ad infinitum
03:10:06 <merijn> It's rather similar to things like
03:10:12 <merijn> > let ones = 1:ones in ones
03:10:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:10:33 <merijn> > fix (1:) -- One might even call it the same :)
03:10:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:10:52 <hashcat> I'm still trying to figure out
03:11:13 <merijn> hashcat: Try manually expanding my example with the lambda and the definition of fix
03:11:28 <merijn> Start on a piece of paper, substitute definitions until it makes sense or you get bored :p
03:12:00 <Ghoul_> @pl (\x -> fix (x:))
03:12:00 <lambdabot> fix . (:)
03:12:30 <Ghoul_> > let repeat = fix . (:) in repeat "hello"
03:12:32 <lambdabot>   ["hello","hello","hello","hello","hello","hello","hello","hello","hello","h...
03:12:54 <Ghoul_> @src repeat
03:12:55 <lambdabot> repeat x = xs where xs = x : xs
03:13:18 <tulcod> lambdabot is awesome
03:13:22 <Ghoul_> Indeed!
03:13:31 <tulcod> can you even do that stuff in ghci?
03:13:36 <merijn> tulcod: Sure
03:13:45 <Ghoul_> You can do @pl in ghci?
03:13:55 <Ghoul_> (or @src?)
03:14:04 <merijn> Ghoul_: oh, @pl not directly, but there's a commandline install for pl
03:14:15 <merijn> Ghoul_: @src is actually kinda sucky, it's just a lookup table
03:14:25 <merijn> You're better of using Hoogle and clicking the source link
03:16:15 <Ghoul_> Looking at the source for base can be confusing because of lengths gone to expanding/optimizing certain things
03:16:27 <Ghoul_> for example, folds are very confusing to look at because of the way they are expanded
03:16:29 <Ghoul_> @src foldl
03:16:30 <lambdabot> foldl f z []     = z
03:16:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:16:40 <Ghoul_> Whereas, it's expressed much simpler in lambdabots lookup
03:16:53 <alpounet> Ghoul_, yes, but you'll eventually only care about the actual source
03:17:16 <hashcat> "fix f = f $ f $ f ..." ?
03:17:42 <elliott> hashcat: yes
03:17:45 <merijn> hashcat: pretty much
03:17:49 <hashcat> > (1:) $ (1:) $ (1:) (1:[])
03:17:51 <lambdabot>   [1,1,1,1]
03:18:26 <merijn> hashcat: Except you never pass in a "final" actual 'a' (or [] in your example), so it just keeps going infinitely :)
03:18:54 <merijn> Unless your function stops at some point, of course
03:19:06 <merijn> > fix (take 15 . ("hello "++))
03:19:07 <lambdabot>   "hello hello hel"
03:19:27 <hashcat> thanks for help!
03:19:44 <merijn> hashcat: This is the starting point of even weirder things
03:20:15 <merijn> hashcat: Like, passing the result of a function as argument to that same function. Unfortunately with hpaste dead my example is gone :\
03:21:27 <Ghoul_> Can fix be used for like strange tree recusion
03:21:31 <alpounet> there are some pretty sweet examples of using 'fix' for fun stuffs
03:21:31 <BoR0> try this: let fix f = f (fix f). now let "fix f" = H, so we get H = f H. that is, when expanded: H = f ( f ( f ( f ( ... H ... ) ) ) )
03:21:40 <alpounet> in the hackage2 source
03:22:05 <Ghoul_> :t fixM
03:22:06 <lambdabot>     Not in scope: `fixM'
03:22:06 <lambdabot>     Perhaps you meant `fix' (imported from Data.Function)
03:30:44 <merijn> Ghoul_: You're probably looking for mfix?
03:30:45 <merijn> :t mfix
03:30:46 <lambdabot> MonadFix m => (a -> m a) -> m a
03:31:30 <Ghoul_> Ah, that's the one
03:58:07 <heilkn> I have a problem with installing haskell-platform. I followed the instructions on the website: installing ghc-7.6.3 and then configure und make the platform. the problem is, that happy isn't building, because happy could not be found: http://pastebin.com/ZQGnyZde
03:58:12 <mauke> The paste ZQGnyZde has been copied to http://lpaste.net/91051
04:10:36 <simon> in Alex, why can't I write "$id = [a-zA-Z_] [a-zA-Z0-9_]*" initially? apparently, it's the " [a-zA-Z0-9_]*" that causes a parse error. how else is regex concatenation defined in these aliases?
04:11:04 <Ghoul_> Does anyone know if theres a haskell parser written using attoparsec, or troubles that might be found by attempting to do so?
04:11:19 <elliott> your parse errors will suck.
04:15:17 <FreeFull> simon: Tried removing the space?
04:15:23 <merijn> heilkn: Is there a reason you're not just installing the platform binaries?
04:15:49 <simon> FreeFull, yes. no luck.
04:15:58 <heilkn> merijn,where would I get them?
04:16:57 <merijn> heilkn: Depends on your OS
04:16:59 <heilkn> merijn, I can not any distribution packages, because I have no su rights at work
04:17:00 <simon> FreeFull, I can just skip using concatenated aliases since my grammar isn't very big anyway.
04:17:48 <Ghoul_> No su rights at work?!
04:17:54 <Ghoul_> Start an uprising!
04:18:22 <Ghoul_> That sounds like the biggest way to kill productivity.
04:18:39 <heilkn> it is, but there's no way to change it
04:18:49 <Ghoul_> Do you run unix at home?
04:18:52 <simon> for some reason, I get "line-map.c: file "<command-line>" left but not entered" when compiling my generated lexer. any way to avoid that?
04:18:58 <hpc> once you have shell access, there's a whole host of priveledge escalations you can try
04:19:01 <hpc> ;)
04:19:03 <heilkn> Ghoul_, yes, I do
04:19:08 <Ghoul_> Or, the same distribution for that matter
04:19:21 <heilkn> Ghoul_, no, I don't :(
04:19:22 <Ghoul_> I don't know much, but you could try just copying the binaries
04:19:45 <tulcod> heilkn: it's pretty easy: explain to management that you spend at least an hour a day circumventing your lack of su rights. it's costing them thousands of dollars/euros a year.
04:19:58 <Ghoul_> Once you have basic ghc, cabal, haddock and such you can instal everything else without su
04:20:06 <Ghoul_> even the newer cabal and such!
04:20:27 <hpc> you definitely don't need su to install cabal
04:20:42 <heilkn> yeah, in principal you're right, but the installation routine should really just work
04:20:54 <hpc> (compile from source and stick it in some kind of ~/.bin)
04:21:13 <heilkn> hpc, it doesn't work. please see this: http://lpaste.net/91051
04:21:25 <heilkn> hpc, happy complains, that happy is not available
04:21:38 <Ghoul_> cabal install happy
04:21:41 <Ghoul_> ?
04:21:51 <heilkn> haha!
04:22:02 <heilkn> I'm building the platform right now!
04:22:04 <hpc> haha
04:22:05 <Ghoul_> (I'm serious, just make sure your cabal bin is in your path)
04:22:09 <supki> heilkn: I've just downloaded .tar.gz with sources and it "Just Worked" for me, did you have any other errors before happy?
04:22:09 <Ghoul_> Oh, derp
04:22:45 <tulcod> bah, i'd rather work in a VM than withotu su rights
04:22:56 <supki> heilkn: or, alternatively, can we see the whole log of commands you typed in?
04:23:10 <heilkn> supki, yeah, I had to remove line 69 from scripts/build.sh, because GHC_PACKAGE_PATH is not supported
04:23:34 <Ghoul_> Out of interest, what distribution is it?
04:23:57 <tulcod> i'm guessing suse
04:24:25 <hashcat> hi , how to hide instance?
04:24:45 <merijn> hashcat: You can't, why do you want to do that?
04:25:07 <tulcod> hashcat: i think you're looking for "newtype"
04:25:17 <supki> heilkn: I believe you can have more luck with reunpacking the platform and applying your script changes to it
04:25:20 <merijn> tulcod: So do I, but I wanna know what he wants before saying that :)
04:25:22 <heilkn> supki, I can summarize it for you. download and extract ghc-7.6.3. configure --prefix=$LOCAL/haskell-platform ; make install; then the same for the platform 2013.2.0.0
04:25:29 <supki> (before getting errors I mean)
04:25:34 <hashcat> I import Control.Arrow and wanna hide Kleisli
04:25:38 <tulcod> merijn: :)
04:25:44 <tulcod> hashcat: that's not a reason
04:25:46 <merijn> hashcat: Why?
04:25:57 <heilkn> Ghoul_, it's debian
04:26:04 <hashcat> that It can inference my type without a lot of signature
04:26:17 <tulcod> huh...
04:26:29 <FreeFull> hashcat: Can you show an example of that?
04:26:30 <merijn> hashcat: What code are you trying to compile? lpaste it?
04:26:32 <supki> hashcat: hiding instance is not going to help with it
04:27:03 <simukis_> I have `list = [[a]]` and I want to achieve `[[a, b, c...] | a <- list !! 0, b <- list !! 1, c <- list !! 2…]`. Any suggestions?
04:27:05 <supki> even if it was possible
04:27:29 <hashcat> I make Arrow's funtion into Data.Dynamic, but it complains ambiguous
04:27:46 <FreeFull> simukis_: Can you give a more specific examlpe with what output you expect for what input?
04:27:49 <Ghoul_> heilkn: can you get your hands on a haskell platform prebuild deb?
04:27:54 <supki> yes, that's not because you have Arrow instance for Kleisli
04:28:00 <Ghoul_> Then you could do something from here: http://askubuntu.com/questions/339/how-can-i-install-a-package-without-root-access
04:28:16 <supki> hashcat: but because the type is ambiguous
04:28:20 <tulcod> simukis_: so [[0,1,2],[3,4,5],[6,7,8]] -> [0,4,8], right?
04:28:20 <Ghoul_> The "installing it to your home directory" solution looks pleasing :)
04:29:23 <simukis_> tulcod: Nope, I'll get an example ready in a moment.
04:30:51 <FreeFull> > sequence [[1,2],[3,4],[5,6]]
04:30:52 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
04:31:12 <Ghoul_> /s/deb/dep debs/
04:31:19 <FreeFull> simukis_: Maybe this?
04:31:49 <m3ga> is hpaste.org down?
04:31:54 <hashcat> well, I see. creating Dynamics for Arrows for several type seems impossible in this moment
04:31:55 <simukis_> FreeFull: Exactly!
04:31:57 <simukis_> awesome
04:32:23 <simukis_> thanks! :)
04:32:36 <merijn> m3ga: Yes, lpaste is the new place to be
04:32:50 <tulcod> hashcat: it sounds more like your code is incomplete
04:32:52 <merijn> m3ga: Rather, the domain owner isn't reachable to migrate to a new machine
04:33:03 <tulcod> hashcat: either way you can resolve ambiguous types by explicitly declaring them
04:34:51 <lpaste> m3ga pasted “utf-8 not working on linux?” at http://lpaste.net/91054
04:35:23 <m3ga> does that code work for anyone else?
04:35:24 <sobhan> i can only use where when my functions are like fun x | x == 1 -> 1 ?
04:35:47 <hashcat> tulcod: I can't explicit declaring them because infinite cases
04:35:49 <merijn> m3ga: What's your terminal locale?
04:36:09 <tulcod> hashcat: again, sounds like your code is broken rather than a limitation of haskell
04:36:31 <sobhan> ah never mind
04:36:37 <hpc> hashcat: you wouldn't be able to use an infinite type in haskell anyway
04:37:07 <hashcat> tulcod: I just try to make arrows coposable at runtime
04:37:29 <Ghoul_> sobhan: the where has to have at least 1 space in front if you break it onto a new line
04:37:43 <Ghoul_> not sure if that's what you're looking for though. It's hard (or impossible?) to show with lambdabot I think
04:37:49 <sobhan> Ghoul_: is it wrong to use it like this ?http://ideone.com/ZwX73w
04:38:00 <m3ga> merijn: LANG=en_AU.UTF-8 and LANGUAGE=en_AU:en
04:38:10 <m3ga> LC_ALL=C
04:38:30 <Ghoul_> that looks correct to me
04:38:32 <merijn> m3ga: Bingo
04:38:39 <merijn> LC_ALL=C <- wut
04:38:54 <m3ga> yep, thats it. thanks
04:39:01 <Ghoul_> but I would use guards there
04:39:01 <merijn> Try setting that to en_AU.UTF-8 too
04:39:19 <m3ga> yep, that fixed it
04:39:25 <m3ga> thanks
04:39:47 <Ghoul_> sobhan: except your if is incorrect
04:39:52 <Ghoul_> you're missing an else
04:40:09 <sobhan> Ghoul_: else if obligatory ?
04:40:21 <alpounet> sobhan, otherwise it's not an expression
04:40:28 <Ghoul_> if x then y else z maps to ifThenElse which is a function taking a few arguments
04:40:30 <sobhan> ah ok thanks
04:40:31 <Ghoul_> so yes, its compulsary
04:40:43 <Ghoul_> :t ifThenElse
04:40:44 <lambdabot> Not in scope: `ifThenElse'
04:40:48 <Ghoul_> Was worth a shot.
04:40:58 <alpounet> sobhan, imagine: x = if foo == 5 then -1
04:41:05 <alpounet> what if foo /= 5?
04:41:11 <sobhan> ok
04:41:40 <alpounet> :t if'
04:41:41 <lambdabot>     Not in scope: if'
04:41:41 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
04:41:44 <alexander__b> does anyone know of a vim syntax highlight plugin/file that doesn't... suck? the one I'm currently using doesn't have highlighting for e.g. parameters or builtin functions.
04:41:49 <BoR0> @src if
04:41:50 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:41:53 <alpounet> @src if'
04:41:53 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:42:04 <alpounet> meh, there used to be an if' I think
04:42:21 <hashcat> is there any Polymorphic version Data.Dynamic?
04:42:22 <Ghoul_> Theres one called bool in that prelude utils package
04:42:28 <alpounet> if' b e1 e2 = if b then e1 else e2
04:43:49 <twanvl> I would expect bool to have the arguments the other way around
04:45:35 <lpaste> Bor0 pasted “if'” at http://lpaste.net/91056
04:45:42 <BoR0> it can look like this too: http://lpaste.net/91056
04:55:25 <Ghoul_> well
04:55:28 <Ghoul_> I like it better like this
04:56:05 <Ghoul_> bool :: a -> a -> Bool -> a
04:56:15 <mr-> BoR0: heh, cool
04:56:26 <Ghoul_> let thing = bool 3 5 in thing $ x > 3
04:56:36 <FreeFull> bool True x _ = x; bool False _ y = y;
04:56:49 <FreeFull> Oh, that order
04:56:56 <Ghoul_> You'd have the condition as the last argument
04:57:04 <Ghoul_> so that its more haskell-ey
04:57:05 <Ghoul_> :t maybe
04:57:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:57:38 <FreeFull> @pl \f x y z -> f y z x
04:57:38 <lambdabot> flip . (flip .)
04:59:34 <slehuito> Hi there,
04:59:45 <slehuito> Willing to understand (and play with) a big project (http://hackage.haskell.org/package/gf), I'd like to run it in debug mode.
04:59:59 <slehuito> I tried "ghci", then ":l GF.hs" (main module), which miserably failed: "Could not find module `Paths_gf'".
05:00:12 <slehuito> How should I proceed to ensure everything is live and well under ghci's REPL?
05:00:22 <slehuito> Any mean to use the project's cabal file?
05:00:32 <slehuito> Any other suggestions on how to get familiarity with the code of large existing projects?
05:00:38 <alpounet> Ghoul_, well, sometimes, you also want something along the lines of: initSucceeded <- Foo.init  and from there, if it failed, you just want to exit the program, but if it succeeds, I like to be able to open a do block at the end, which will define the "success" case. I admit this goes outside bool's scope, but having such a function at hand can be handy
05:00:42 <merijn> slehuito: was the Paths_gf.hs file in the same folder?
05:00:57 <slehuito> @merijn: no
05:00:57 <lambdabot> Unknown command, try @list
05:01:33 <slehuito> merijn: no. And there are lots of folders...
05:01:45 <slehuito> hence the question about cabal
05:01:54 <merijn> slehuito: Ah, and where you opening GF.hs from the folder it was in?
05:02:00 <merijn> s/where/were
05:02:11 <slehuito> merijn: yes
05:02:52 <merijn> slehuito: Try opening it from the top level, ghci uses directory names for hierarchic lookups, so suppose "Foo/Bar/GF.hs" imports "Foo.Bar.Paths_gf" then ghci can't find it
05:02:53 <supki> Paths_gs.hs is generated by cabal when you install the package
05:03:08 <Ghoul_> alpounet: thats a noble case for flip . (bool x) cond $ ....
05:03:10 <merijn> Oh, it's auto generated?
05:03:22 <supki> yep
05:03:25 <Ghoul_> although, that's better territory for just if .. then .. else, honestly xD
05:03:26 <merijn> In that case you might wanna run "cabal build" to build but not install the project
05:04:04 <supki> one way to work aroung that is to have Paths_gf.hs stub somewhere, it's not very interesting file
05:04:11 <supki> s/aroung/around/
05:04:12 <slehuito> Isn't "cabal install" equivalent to "cabal build" + other things?
05:04:22 <supki> yes it is
05:04:37 <alpounet> Ghoul_, right, that's a gorgeons line of code :p
05:04:45 <slehuito> so "cabal build" is not going to solve the problem, is it?
05:04:50 <Ghoul_> :P
05:05:00 <alpounet> err, gorgeous
05:05:18 <simon> I'm combining an alex "posn" lexer and a happy parser, and I'm unsure how to specify tokens so the AlexPosn is propagated into my syntax tree. I've got Lexer.x/Parser.y (minimal): https://gist.github.com/sshine/7d86233e733764fe8bde -- I'm basically emulating an example from the Happy documentation and try to decipher the output.
05:05:28 <merijn> slehuito: If Paths_gf is generated by the build, as supki says then it might not exist until you build the project
05:06:41 <slehuito> Ah yes: I did a "cabal install" to get the exe ready AND I retreived the sources independantly and dezipped them in the hope of using ghci.
05:06:57 <simon> so it seems I get a position-annotated list of tokens, but the parser doesn't take those positions and puts them into the syntax tree. the underscores in my list of tokens in the parser can apparently not be "pos" or some other variable, since then the generated code will have patterns with recurring variable names...
05:07:11 <sobhan> any one could take a look at the then "PONG " ++( unwords . tail command) line in   https://github.com/SobhanMP/Echoboom/blob/master/Nextboom.hs ?
05:07:17 <merijn> slehuito: oh, then it would work if you had just done "import GF"
05:07:42 <merijn> slehuito: Because that would've loaded the installed module
05:08:01 <merijn> slehuito: It's just the loading of a file with a missing (generated?) module that's going wrong here
05:09:05 <supki> you can make i.e.  module Paths_gf where getDataFileName :: FilePath -> IO FilePath; getDataFileName = return  if you want to mess with unpacked sources
05:09:18 <alpounet> yeah the Paths_foo module are generated by cabal
05:09:22 <alpounet> for the data files
05:09:29 <supki> because you really don't care where data files are
05:09:38 <alpounet> http://neilmitchell.blogspot.fr/2008/02/adding-data-files-using-cabal.html sums it up
05:10:40 <sobhan> unwords $tail t is like unwords . tail t ?
05:11:44 <FreeFull> sobhan: More like    unwords . tail $ t
05:11:51 <sobhan> ah ok
05:11:55 <sobhan> FreeFull: Thhanks
05:12:11 <merijn> sobhan: Function application has the highest precedence, so "unwords . tail t" parses as "unwords . (tail t)"
05:12:26 <sobhan> ah ok
05:12:43 <merijn> "unwords . tail $ t" parses as "(unwords . tail) t" which is the same as "unwords $ tail t", yes
05:13:38 <sobhan> haskell don't transform [Char] to String ?
05:13:40 <Ghoul_> :t (\t -> unwords . tail $ t)
05:13:41 <lambdabot> [String] -> String
05:13:55 <Ghoul_> String is an alias for [Char] so they are equivalent
05:14:04 <merijn> sobhan: [Char] is exactly the same as String
05:14:11 <merijn> :t "hello?" :: String
05:14:12 <lambdabot> String
05:14:15 <merijn> :t "hello?" :: [Char]
05:14:15 <sobhan>     Couldn't match expected type `[Char]'
05:14:16 <lambdabot> [Char]
05:14:18 <sobhan>                 with actual type `a0 -> String'
05:14:20 <sobhan>     In the second argument of `(++)', namely
05:14:22 <sobhan>       `(unwords . tail (command))'
05:14:35 <Ghoul_> use lpaste for errors
05:14:39 <merijn> sobhan: It's saying you're giving it a function that creates a String, when it wants a String
05:14:50 <merijn> > ("hello"++) :: String
05:14:51 <lambdabot>   Couldn't match type `[GHC.Types.Char] -> [GHC.Types.Char]'
05:14:51 <lambdabot>                w...
05:15:34 <Ghoul_> Is there a clang-like error plugin for ghc anywhere?
05:15:36 <Ghoul_> I love clang errors
05:15:52 <Ghoul_> and ghc errors are cryptic for beginners. colorful errors would be really helpful :)
05:15:57 <sobhan> merijn: so how do i do  "PONG " ++( unwords . tail (command)) ?
05:16:42 <sobhan> Ghoul_: www.cs.uu.nl/helium ?
05:16:58 <shiona> Not trying to derail you or anything, but any pointers in how to start with solving a min cut problem for graphs?
05:17:32 * hackagebot monadiccp 0.7.6 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.6 (MaikRiechert)
05:17:49 <dmwit> shiona: Grab a book like "Combinatorial Optimization"?
05:18:09 <Ghoul_> :t ( unwords . tail (command))
05:18:09 <lambdabot>     Not in scope: `command'
05:18:10 <lambdabot>     Perhaps you meant `comma' (imported from Text.PrettyPrint.HughesPJ)
05:18:34 <Ghoul_> :t (\_ -> let command = "" in ( unwords . tail (command)))
05:18:35 <lambdabot>     Couldn't match expected type `a0 -> [String]'
05:18:36 <lambdabot>                 with actual type `[Char]'
05:18:36 <lambdabot>     In the return type of a call of `tail'
05:18:39 <shiona> I managed to do it with an extremely inefficient [(Word8, Word8)] assoc. list, but I was thinking of something like ST Word8 [Word8]
05:18:43 <dmwit> :t unwords . tail
05:18:44 <lambdabot> [String] -> String
05:18:46 <sobhan> :t (unwords . tail(["testing" , "this"])
05:18:47 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:18:50 <sobhan> :t (unwords . tail(["testing" , "this"]))
05:18:51 <lambdabot>     Couldn't match expected type `a0 -> [String]'
05:18:51 <lambdabot>                 with actual type `[[Char]]'
05:18:51 <lambdabot>     In the return type of a call of `tail'
05:18:52 <dmwit> :t \command -> (unwords . tail) command
05:18:53 <lambdabot> [String] -> String
05:19:12 <shiona> but couldn't really get it to work the way I wanted, should I expect something like that to work
05:19:40 <dmwit> Your question is much too vague to really answer.
05:20:50 <shiona> sorry.. how would you represent (and build that representation) of a sparse, mutable graph in haskell (from assosiative array)
05:20:55 <alpounet> > unwords . tail $ ["will get ignored", "hi", "there"]
05:20:56 <lambdabot>   "hi there"
05:20:56 <shiona> is that better?
05:20:57 <supki> I wouldn't expect ST Word8 [Word8] to work
05:21:39 <dmwit> shiona: I would use fgl, which already has a type for mutable graphs.
05:22:31 <shiona> dmwit: I looked at it, but could not find out how I would merge nodes
05:22:56 <shiona> also I'm trying to learn something about mutables on the way
05:23:16 <merijn> sobhan: You probably meant to type: "(unwords . tail) command" or "unwords . tail $ command"
05:24:03 <slehuito> supki: adding a Paths_gf worked fine... only to hit a similar problem, namely an unfound module named "DarcsVersion_gf". Googling didn't produce any relevant thing...
05:24:36 <dmwit> shiona: I don't know what "merging nodes" means.
05:25:08 <dmwit> If you want to learn about mutables, though, that's a laudable goal, and then I would advise you to look into ST after all, especially STRefs and STArrays.
05:26:20 <shiona> yeah. I wanted to have something real to do so I took up this challenge
05:26:38 <shiona> and merging (also called collapsing) nodes: http://i.stack.imgur.com/3SlGc.jpg
05:26:50 <supki> slehuito: looks like Setup.hs creates this file
05:26:55 <sobhan> merijn: beh i moved it to where \
05:27:12 <shiona> three nodes are merged into one, so that all edges into any one of the old nodes will be going into the new single node
05:27:47 <dmwit> Presumably you just remove all the edges from each of the nodes you're collapsing and add them going to the new node, then remove all the collapsed nodes.
05:28:25 <supki> slehuito: you do  cabal build  , see what file was generated and make a stub similar to that (or copy verbatim)
05:28:35 <dmwit> This is a horribly operational description of what to do, but if you're working with mutable graphs that's about the best you can hope for.
05:29:09 <dmwit> gotta run, g'luck
05:29:21 <supki> slehuito: auto-generated files are in dist/build/autogen
05:30:13 <shiona> thanks
05:32:32 * hackagebot http-conduit-downloader 1.0.7 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.7 (VladimirShabanov)
05:37:07 <sobhan> :D i'm getthing used to haskell :D
05:38:32 <mstksg> i want to quit my engineering career and go into programming.
05:38:35 <mstksg> is this a good idea?
05:38:59 <mstksg> er sorry wrong room
05:39:14 <mstksg> anyone here making a living off of haskell?
05:39:58 <alexander__b> mstksg: I wouldn't say I am living off of haskell (I am a complete newbie), but where I work we've always chosen the tech on a team-basis.
05:40:03 <sobhan> mstksg: a professor who teaches haskell
05:40:10 <sobhan> ?
05:40:41 <alexander__b> mstksg: i.e. if we want to use haskell, we would. we almost did for our latest project, but ended up with python because one of the guys weren't comfortable with learning haskell since it's such a short project.
05:40:53 <alexander__b> s/would/will
05:41:36 <slehuito> supki: Thanks for the tips.
05:41:59 <slehuito> No more errors with unknown haskell module
05:42:30 <slehuito> However, there also is a ".h" file in the "autogen" folder...
05:42:55 <Yaniel> I'd say programming is a subset of engineering
05:43:42 <alexander__b> Yaniel: people call it art, engineering and science. I think it may be all three, but more commonly it's a *craft*.
05:43:50 <mstksg> Yaniel: you could say that, but in EE the day-to-day things are a whole different set of things to wrestle with and deal with
05:43:56 <slehuito> supki: putting the ".h" file in the right folder worked
05:44:22 <supki> :)
05:45:05 <slehuito> supki: now I have an unfound module "PGF.Macros", and ghci tells me it's a hidden module...
05:45:11 <tikhonjelvis> Haskell jobs aren't terribly common, but you could probably find one if you were willing to relocate
05:48:10 <slehuito> the file which I load in ghci (GF.hs) is in gf/src/compiler
05:49:36 <slehuito> the file corresponding to "PGF.Macros" is in gf/runtime/haskell/PGF
05:49:38 <sobhan> can i do nothing in else?
05:49:39 <ignacio> "Haskell consultant needed in Northern Siberia"
05:50:24 <sobhan> mstksg: you should take it
05:50:41 <mstksg> tikhonjelvis: i've seen some resources/networking resources for haskell job seekers but things always seem particularly esoteric
05:50:46 <mstksg> but i've always wanted to learn russian
05:51:17 <tikhonjelvis> what do you mean by "esoteric"?
05:51:57 <merijn> mstksg: haskellers.com?
05:52:06 <merijn> mstksg: I've been contacted through there a couple of times
05:52:16 <supki> slehuito: you can add gf/runtime/haskell directory to ghci search path with -i: ghci -igf/runtime/haskell gf/compiler/GF.hs
05:53:14 <mstksg> tikhonjelvis: niche applications with high specializations. but i guess that's not so bad.  but people rarely chose haskell for their project unless there's no other choice it seems
05:53:34 <tikhonjelvis> hmm, it probably depends
05:53:37 <mstksg> maybe i am not looking broadly enough
05:53:46 <tikhonjelvis> I know some companies are using it for web development stuff, for example
05:53:49 <tikhonjelvis> not very niche
05:53:56 <mstksg> tikhonjelvis: that's the kind of applications i couldn't find haha
05:54:19 <tikhonjelvis> I wouldn't know how to go about finding that sort of company online though
05:54:32 <mstksg> haskell is useful for normal stuff too
05:54:41 <merijn> mstksg: These companies don't advertise much on the hype forums like HN, because they're to busy becoming filthy rich :p
05:54:41 <tikhonjelvis> e.g. I know IMVU has started using Haskell, but only because somebody I'm acquainted with started working there
05:54:58 <merijn> mstksg: Ask around here and suddenly people are using haskell everywhere for everything :p
05:55:28 <tikhonjelvis> that said, I should probably point out that I've never used Haskell professionally :P
05:55:56 <mstksg> haha understood...but it's good to hear that people are competing in mainstream markets doing 'normal' applications with haskell
05:56:21 <mstksg> don't mind me, just your average 5am-in-the-morning job dissatisfaction rant
05:56:36 <tikhonjelvis> you could try OCaml instead
05:57:33 * hackagebot monadiccp-gecode 0.1 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-gecode-0.1 (JanTikovsky)
05:57:34 <mstksg> i'll put that on a list thanks
05:57:38 <tikhonjelvis> it's a nice functional language and not *that* much worse than Haskell
05:57:46 <mstksg> for now i think i'm going to try to sleep
05:57:51 <mstksg> thanks for advice
05:57:53 <tikhonjelvis> pfft, sleep is for the weak
05:57:55 <merijn> mstksg: Jane Street (investment company) is hiring all manner of FP programmers, fyi
05:58:07 <merijn> mstksg: They work in ocaml, but they're happy to hire Scala/Haskell people
05:58:30 <tikhonjelvis> it's a nice company
05:58:31 <merijn> I believe Standard Chartered uses Scala and Haskell?
05:58:55 <merijn> Until edwardk is done reimplementing everything in lens, at which point they'll just be using lens, I think :p
05:59:08 <tikhonjelvis> he isn't at Standard Chartered though
06:00:12 <merijn> Maybe my memory is faulty
06:00:18 <merijn> I'm probably thinking of dons?
06:00:21 <tikhonjelvis> yeah
06:01:12 <tikhonjelvis> and some other fairly well-known Haskellers like Lennart Augustsson
06:03:18 <merijn> Facebook ;)
06:03:33 <tikhonjelvis> yeah, Facebook has been expanding its Haskellers
06:03:46 <tikhonjelvis> but I think it also does a bunch of OCaml--maybe even more OCaml than Haskell
06:04:21 <alexander__b> OTOH Facebook are evil so
06:04:21 <quchen> I remember dons saying something along the lines of "we're using Haskell for something really awesome here at Facebook, but I can't tell you what yet"
06:04:26 <quchen> Still waiting for that
06:04:43 <tikhonjelvis> bos, not dons
06:04:54 <quchen> One of those 3-4 letter names
06:05:01 <tikhonjelvis> alexander__b: most big companies are evil, so
06:05:05 <quchen> SPJ SM BOS EDK DONS
06:05:09 <alexander__b> tikhonjelvis: yeh so avoid them ;-)
06:05:17 <dmwit> Dang. One letter off from fame.
06:05:32 <quchen> dmwit: You're not a name abbreviation are you
06:05:55 <dmwit> Tricky question. Sort of, yes.
06:06:07 <dmwit> (My initials are DMW.)
06:06:21 <dmwit> (but "i" and "t" don't otherwise appear after the "w" in my name)
06:06:36 <quchen> What a clever spoof.
06:06:47 <arcatan> but you're in the IT industruy. how nice.
06:06:51 * dmwit preens
06:07:00 <tikhonjelvis> I've been considering switching over to my initials
06:07:27 <tikhonjelvis> in a perfect world, I'd just use my first name, but that is not to be :(
06:07:33 <quchen> Mike?
06:07:35 <quchen> Jack? :-)
06:07:48 <dmwit> obviously his first name is TJ
06:07:58 <slehuito> supki: still making progress while adding search directories in ghci ;-)
06:08:32 <tikhon> oh
06:08:37 <tikhon> maybe it does work now :P
06:08:46 <tikhon> or is this already registered?
06:08:50 <slehuito> supki: Now, I'm hitting a compilation error ("expecting on more argument to 'Exception'")
06:08:56 <tikhon> I haven't been prompted for a password, so I assume it isn't
06:09:22 <heilkn> ok, if anyone is interested. I managed to install happy, by downloading happy-1.17 and edit the version number in packages/platform.packages. the same had to be done for alex-3.0.5 by substituting it through alex-3.0.4. then creating build.stamp running make install, removing build.stamp re-edit the platform.packages file and running the build process from the beginning
06:09:23 <dmwit> How nice, tikhonjelvis and tikhon hash to the same color.
06:09:40 <slehuito> supki: I imagine the version of Control.Exception used in ghci is different from the one used by "cabal build"
06:10:19 <dmwit> That seems pretty unlikely.
06:11:11 <slehuito> supki: cabal file specifies "base >= 4.2 && <5"
06:11:46 * sobhan is lucky his name isn't common in IRC
06:11:48 <dmwit> You will only ever have one version of base installed in any particular (global) GHC package database.
06:14:31 <elliott> dmwit: xchat or such?
06:14:35 <elliott> you should see how it does nick colours.
06:14:42 <elliott> it's basically just summing the letters mod 16.
06:14:54 <supki> slehuito: can you paste full error message somewhere?
06:15:00 <supki> preferably not in channel
06:16:11 <slehuito> supki: any suggestion? (I'm not familiar with pasting sites)
06:16:17 <dmwit> elliott: irssi, and I think it's even stupider.
06:16:18 <tikhon> lpaste
06:16:37 <dmwit> elliott: It just counts up from 0. It's not nick-dependent at all!
06:16:39 <tikhon> lpaste.net
06:19:13 <ignacio> mstksg: it's funny that you mention EE as an example of engineering
06:19:32 <ignacio> I've always felt EE is closer to programming than to the other engineering disciplines
06:19:48 <tulcod> ignacio: then you don't know EE
06:19:49 <slehuito> supki: http://lpaste.net/91060
06:19:50 <ignacio> since it's the only one you can do at home, by yourself
06:20:14 <ignacio> without huge teams, $$ and regulations
06:20:31 <tulcod> ignacio: again, then you don't know EE... sure, there are branches of EE that you can do at home, but there are tons you can't
06:20:49 <tulcod> which is exactly the same as for mechanical engineering, or recently bioengineering
06:20:54 <ignacio> just like programming
06:21:07 <tikhon> EE is similar to programming in other ways though
06:21:14 <tikhon> well, parts of EE are, anyhow
06:21:18 <tulcod> no?
06:21:29 <tikhon> well, I guess it depends
06:21:31 <hape02> why does this not compile?:      f :: Maybe a -> b                f Nothing = 7
06:21:32 <ignacio> why mechanical engineering?
06:21:36 <slehuito> supki: I remember reading in a blog comment that published code didn't work, and that happened to be because of an API change in 'Control.Exception'. That's why I think it's a similar problem here
06:21:44 <dmwit> hape02: Because 7 isn't polymorphic enough.
06:21:46 <tikhon> where you say computer architecture falls, for example?
06:21:54 <tulcod> ignacio: you can build a bike at home
06:21:56 <dmwit> hape02: You promise that no matter what type I pick, you can hand me a value of that type as your output.
06:21:59 <tulcod> that's mechanical engineering
06:22:04 <ignacio> ....ok
06:22:07 <dmwit> hape02: But I can pick a type that 7 isn't a value of.
06:22:30 <tulcod> tikhon: computer engineering is both EE and CS, yes, but that's only one in maybe a hundred areas of EE
06:23:00 <supki> slehuito: that looks like a super old module you shouldn't import really
06:23:00 <hape02> dmwit: Your words let me understand know. Thx
06:23:02 <tikhon> circuit stuff in general is pretty similar
06:23:12 <tulcod> saying EE is like programming is like saying cooking an egg is like building a kitchen
06:23:22 <tulcod> (or vice versa, for that matter)
06:23:29 <tulcod> tikhon: just... no
06:23:36 <tikhon> we certainly use a bunch of similar techniques like synthesis
06:24:09 <tulcod> tikhon: yeah. and we use calculus. does that mean EE is basically just physics?
06:24:12 <tikhon> some of the stuff I've been doing in the recent past is basically the same as trying to minimize a circuit, except for prorgams
06:24:15 <tikhon> programs**
06:24:21 <tikhon> very similar techniques
06:25:00 <ignacio> you're  turning it into a very broad assertion. I'm just saying that you can do EE at much smaller scales than you can do oil engineering
06:25:33 <tulcod> ignacio: you can do reactions with oil on your desk
06:25:43 <tulcod> no, you cannot drill 1km into the ground in your house, unless you have a 1km house
06:26:30 <slehuito> supki: you're probably right, but I don't know this project (yet), so I thought I'd just browse it through ghci. I've no special cue as to what I should import or not
06:26:38 <tikhon> in fact, for certain things, we solve problems about computer programs by treating them as circuits
06:26:49 <supki> slehuito: I think it should work if you either s/Exception/SomeException/ or define USE_INTERRUPT
06:27:08 <slehuito> supki: yes, it's an old module (2005), but many others are as old and still useful for me
06:27:31 <supki> I just think nobody ever tried to use that lib from ghci
06:27:43 <supki> and .cabal file sets flag to not use that module by default
06:27:48 <slehuito> I think you're right? ;-)
06:28:04 <tulcod> tikhon: by that logic, programming in haskell is basically just business administration since they also use flow charts
06:28:28 <tikhon> if we used the same flow charts, I'd be willing to say that
06:28:29 <heilkn> how to tell cabal where to store downloaded source code?
06:28:41 <tikhon> just like I"m willing to say that programming in Haskell is basically dealing with formal logic :)
06:29:01 <dcoutts> heilkn: they're cached under ~/.cabal/packages, but you can unpack one easily using cabal unpack ${pkgname}
06:29:03 <dmwit> heilkn: The remote-repo-cache option in ~/.cabal/config
06:29:06 <tulcod> tikhon: do you fancy a career in computational linguistics, then?
06:29:56 <tikhon> for what it's worth, I actually do find it pretty fascinating
06:30:13 <tikhon> there's certainly some overlap between PL and linguistics
06:31:34 <Hafydd> Programming in Haskell uses flow charts?
06:31:44 <tikhon> I imagine some people do
06:31:48 <tikhon> maybe the ones using arrows
06:32:06 <Hafydd> Are you sure those aren't commutative diagrams?
06:32:33 <dmwit> Everything is never as it seems.
06:33:10 <Hafydd> All is not as it seems: concealed traps and pitfalls await the unwary Haskeller.
06:38:09 <merijn> tikhon: Should look into the Institute for Language, Logic & Computation in Amsterdam, then :p
06:38:28 <banister> merijn: op=op
06:42:20 <tikhon> merijn: that looks really cool
06:43:34 <tikhon> actually, oddly enough, the most interesting topic (at least for me) that they look at seems to be music
06:44:28 <merijn> I think there was a guy in Utrecht doing a PhD in encoding music theory in Haskell's type system
06:47:46 <ion> That sounds like an interesting project. I’d like to study music theory some century.
06:58:36 <ignacio> ion: learning music theory is like 10th or 11th in my list of things to do
06:58:45 <ignacio> it keeps getting pushed down
07:00:36 <tdammers> merijn: he will probably have to limit himself to a relatively conservative subset of music genres
07:01:42 <merijn> tdammers: How are genres relevant in the context of music theory?
07:02:19 <tikhon> some genres allow very different constructs
07:02:51 <tikhon> like different scales
07:03:07 <merijn> scales and harmonies are mostly orthogonal to genre
07:04:15 <tikhon> I think scale might have been the wrong word here
07:04:22 <tikhon> I really don't know much about music theory :/
07:07:39 <tdammers> merijn: every genre has its own theory, or rather, every genre requires a slightly different theory to explain it
07:08:13 <tdammers> and the newer, less established genres are still evolving, so by the time you have formalized the theory, stuff has already moved elsewhere
07:08:30 <tdammers> of course the basics are the same for many
07:45:27 <ricree> Any suggestions on the best way to include configuration in a program's structure? Just throw it into an IORef until you need it? Or is there a more elegant way? Most of the articles I found while searching talked primarily about reading and writing config data, which isn't something I'm too worried about.
07:45:43 <merijn> ricree: Reader?
07:46:32 <supki> or reflection
07:48:18 <dmwit> If you already have a transformer stack, throw a ReaderT in and you're done.
07:48:36 <dmwit> If not, just putting the configuration record as an argument to all your functions is pretty darn simple and quite convenient.
07:49:20 <ignacio> "the configuration record" = Map ?
07:49:30 <dmwit> Usually not.
07:49:42 <dmwit> Unless all the options you have happen to have the same type. That's very unusual.
07:49:49 <ignacio> ah right
07:49:56 <dmwit> A custom data type is much more common.
07:50:14 <Lethalman> simple data type + read is the simplest I guess
07:50:26 <ignacio> is it not common practice to define some sort of Variant type?
07:50:34 <dmwit> Lethalman: The question specified that he's not worried about the reading and writing part. =)
07:50:56 <dmwit> I don't know what "some sort of Variant type" is.
07:51:03 <Lethalman> dmwit, yes my phrase was meant less related
07:51:08 <Lethalman> *meant to be
07:51:21 <ignacio> data ConfVar = ConfString String | ConfInt Int | ConfNull
07:51:31 <dmwit> That is not very common practice.
07:52:06 <dmwit> It happens (e.g. in the JSON library), but usually you eliminate those as quickly as possible in favor of a type that tells you a bit more.
07:52:10 <Lethalman> ignacio, well if you really have a field that is either a string or int, why not
07:52:19 <tulcod> tdammers: i agree, the only formal model of any music is that it is a series of audio samples... and even that is not quite the entire picture
07:52:20 <ignacio> strings + read sounds more extensible
07:52:38 <Lethalman> like, for example: data Connection = TCP ... | Socket ...
07:52:56 <Lethalman> but then it only applies to the connection field of your configuration
07:54:30 <ignacio> how would you express "a map with showable values" other than putting strings inside?
07:54:59 <dmwit> You could use existentials. But what's wrong with putting strings inside?
07:55:32 <supki> If the only thing you can do with a value is show it, you might as well just use String instead
07:56:29 <ignacio> yeah I didn't think this through
07:57:22 <nerrz> how much memory does an empty linked list use, since it is just a pointer to null, right?
07:57:42 <danr> nerrz: lists in ghc share the same nil constructor
07:57:56 <ignacio> I'm thinking of behavior like read, where you specify that it should return some Readable type
07:58:10 <dmwit> nerrz: We should clear this up now, though: it is not just a pointer to null. It's is a pointer to [].
07:58:46 <ignacio> so you'd have findPlease myMap "key" :: Int
07:58:47 <nerrz> okay, but all lists point to the same []?
07:58:54 <ignacio> but it's really just wrapping a map lookup with read
07:58:57 <danr> and what dmwit said is relevant and totally correct :)
07:58:57 <dmwit> nerrz: right
07:59:03 <dmwit> nerrz: At least in GHC. =)
07:59:17 <ignacio> what's null?
07:59:21 <nerrz> so the memory wasted has diminishing returns as you use more lists?
07:59:24 <dmwit> no such thing
07:59:30 <ignacio> :t null
07:59:31 <lambdabot> [a] -> Bool
07:59:34 <merijn> ignacio: In haskell there's no such thing as null
07:59:37 <ignacio> oh, null list predicate
07:59:41 <merijn> Well, there's the function :p
07:59:48 <merijn> But that's not what people were talking about
07:59:49 <dmwit> nerrz: Yes.
07:59:51 <ignacio> yep
08:00:46 <nerrz> So, I ask this because I was wondering if I had a data threeStrings that was just 3 strings, and for some cases I was passng 2 empty strings, how bad is that for memory usage?
08:01:18 <ignacio> well the pointer has to point somewhere
08:01:20 <dmwit> Even if things weren't shared I doubt that would matter much in the scheme of things.
08:01:28 <ignacio> [] is as good as some string
08:01:45 <dmwit> We're talking about maybe a word or five. GHC allocates gigabytes per minute.
08:01:55 <ignacio> is that... a good thing?
08:02:21 <dmwit> I'm just saying you're almost certainly optimizing the wrong thing, and should profile before thinking about such stuff.
08:02:23 <luite> it has a reasonably efficient allocator :)
08:02:38 <nerrz> dmwit: okay, so it really isn't going to affect performance?
08:02:51 <dmwit> As we've said at least three times now, that's correct.
08:02:56 <nerrz> okay
08:02:58 <nerrz> thank you
08:03:42 <luite> empty strings are statically allocated by the way
08:04:05 <luite> so you only pay the price for the extra pointer fields in your data type
08:21:22 <tdammers> tulcod: well, the thing is, music is an art form, not exact science, and as such, bending the rules, questioning them, commenting on them, and turning them upside down is part of the game
08:21:33 <tdammers> in a completely informal, intuition-based way
08:21:49 <tdammers> formal music theory can never be much more than an analysis after the fact, really
08:22:06 <merijn> dmwit: Pythogaros disagrees with you
08:22:08 <merijn> eh
08:22:12 <merijn> s/dmwit/tdammers
08:22:20 <tulcod> tdammers: agreed
08:23:06 <tdammers> merijn: no offense, but in this particular regard, he had it wrong
08:23:33 <tdammers> I mean, he did explain the physics, and some of the actual art, but it's not like his theory suddenly explains *all* of music
08:23:56 <merijn> It doesn't try to explain music, it describes harmonies
08:24:22 <tdammers> describe, explain, same difference
08:24:36 <tdammers> and the description kind of fails when the harmonies become more complex
08:25:34 <tdammers> oh, and the math is actually a lot less elegant than theorists would like it to be
08:26:25 <tdammers> deriving a chromatic scale using pure fifths and octaves only get ugly rather quickly
08:28:36 <tdammers> and as soon as you leave the realm of simple major triads, physics isn't helping much anymore, and it becomes a matter more of cultural psychology or some such
08:33:34 <Maior> oh, you're not *actually* talking about GEB
08:35:47 <tulcod> merijn: it wasn't perfect
08:35:58 <tulcod> merijn: pianos aren't tuned to pythagoras' works
08:36:41 <tulcod> merijn: although i must admit it's close, and he had some great initial ideas
08:39:56 <merijn> tulcod: Piano's aren't tuned purely to avoid constant retuning
08:40:10 <merijn> You'd have to retune for every song that's in a different key
08:40:36 <tulcod> merijn: that's not the entire story since we invented chord progressions...
08:40:38 <merijn> Somewhere a few centuries ago they decided on an average tuning that minimises the amount of wolf-tones (i.e. bad harmonies) so you can play every key in the same tuning
08:42:11 <dmwit> > 440 * 2^(1/13)
08:42:13 <lambdabot>   Could not deduce (GHC.Num.Num b0) arising from the literal `1'
08:42:13 <lambdabot>  from the co...
08:42:16 <dmwit> > 440 * 2**(1/13)
08:42:17 <lambdabot>   464.0970736519245
08:43:00 <dsabanin> hey guys
08:43:08 <Eduard_Munteanu> dsabanin: hi
08:44:05 <drostie> hi dsabanin.
08:44:45 <dsabanin> what is the best guide available online on Haskell, for someone who've been doing FP for last couple years in CLISP and Clojure? Something not for complete newbies :)
08:44:56 <dmwit> > floor <$> iterate (*(2**(1/13))) 440
08:44:57 <lambdabot>   [440,464,489,516,544,574,605,639,674,710,749,790,834,880,928,979,1032,1089,...
08:45:13 <dmwit> dsabanin: The Gentle Introduction is nice.
08:45:17 <dmwit> dsabanin: Also,
08:45:20 <dmwit> ?where tutorials
08:45:21 <lambdabot> http://haskell.org/haskellwiki/Tutorials
08:45:59 <tikhon> the gentle introduction just felt like a slightly cuter retelling of the haskell report
08:46:20 <drostie> Okay, I finally understand Sleator and Tarjan's link/cut trees. Now I have to figure out how Demaine et al. are making them *functional* ;_;
08:46:26 <dsabanin> Gentle introduction says Revised June, 2000 by Reuben Thomas. Nothing important changed since then?
08:46:38 <tikhon> eh, a bit
08:46:48 <tikhon> but most of the changes were *additions*
08:46:54 <drostie> dsabanin: actually Learn You a Haskell for Great Good will probably help?
08:46:55 <tikhon> so it's still a reasonable place to start
08:47:06 <Zenol> Learn You Haskell is realy for newbees.
08:47:16 <tikhon> yeah, LYAH is probably a bit slow
08:47:22 <drostie> dsabanin: because it spends a lot of time on the type system and type classes which is what you're missing if you're coming from Lisp/Clojure.
08:47:27 <tikhon> honestly, I'd just try to write something in Haskell
08:47:31 <applicative> It is, but it covers some difficult material with considerable art
08:47:41 <dsabanin> I want something like "learn c the hard way"
08:47:44 <tikhon> I personally really liked "Write Yourself a Scheme in 48 hours"
08:47:46 * applicative is with drostie in fact
08:48:24 <Zenol> RWH is probably cool if you jump over the first chapters.
08:48:24 <dsabanin> tikhon that one sounds interesting :)
08:48:32 <applicative> dsabanin: have you done a bit of haskell already, I take it?
08:48:33 <Zenol> but it isnt really detailed.
08:48:56 <drostie> dsabanin: also just to warn you, the : operator isn't cons, it's more like Scheme "promises", so it's all lazy-evaluated. :D
08:49:05 <dsabanin> applicative not really, only in tryhaskell.org
08:49:25 <dsabanin> drostie thanks, will keep in mind :)
08:49:34 <applicative> ah. I was going to recommend the new book on concurrent and parallel haskell, which doesn't presuppose too much
08:50:17 <applicative> a manuscript version here http://ofps.oreilly.com/titles/9781449335946/
08:50:48 <dsabanin> thanks for great links everyone
08:51:02 <dsabanin> time to do some reading :)
08:51:26 <ignacio> I'm going through the JSON pretty printer chapter in RWH
08:51:30 <ignacio> not terribly fun
08:51:34 <applicative> Real World Haskell is unfortunately already kind of out of date, thanks partly to the work of the authors writing better libraries...
08:51:39 <ignacio> but so far I loved RWH
08:51:42 <applicative> ignacio: ah
08:52:04 <applicative> dsabanin: maybe thats the answer RWH or some assemblage
08:52:42 * hackagebot atomic-primops 0.4 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.4 (RyanNewton)
08:53:04 * ignacio puts on his fluffy crocodile slippers
08:56:07 <dsabanin> started with RWH
08:56:17 <dsabanin> will try the build your own scheme after that
08:56:51 <applicative> in both cases a few language changes and changes in basic libraries like parsec may cause hiccups
08:57:06 <applicative> these will be well understood here, so just ask if code doesn't compile
08:57:48 <applicative> write yourself a scheme may be being updated in some version
08:58:20 <drostie> ignacio: if you want help with the JSON pretty printer let us know, but it looks pretty straightforward.
08:58:23 <tikhon> it's a wikibook now, so it's possible for the community to keep it up to date
08:58:34 <tikhon> but whether anybody actually does... well, that's another question
08:58:50 <tikhon> that I can't answer one way or another
08:59:44 <applicative> yeah, thats what I was thinking, its quite a while ago parsec changed but after RWH and I think the Scheme writing tutorial
09:02:37 <applicative> hm the published version of 'concurrent and parallel haskell' has a chapter on repa
09:27:34 <joergfritsch> what is wrong here:
09:27:39 <joergfritsch> getLocalSer :: [a] -> ([a], [a])
09:27:39 <joergfritsch> getLocalSer cyclist = do let ([newser], [remlst]) = splitAt 1 cyclist
09:27:39 <joergfritsch>                          return ([newser], [remlst])
09:28:21 <geekosaur> why are you using do?
09:28:36 <geekosaur> why are you trying to use a monad when there's no monad in the return value?
09:28:49 <tomboy64> did i understand that correctly that sets are basically the same as lists, just automatically ordered?
09:29:13 <joergfritsch> geekosaur: this is just one try to get my tuple back
09:29:25 <geekosaur> and?
09:29:33 <monochrom> @type splitAt
09:29:33 <lambdabot> Int -> [a] -> ([a], [a])
09:29:36 <joergfritsch> geekosaur: I always get something like
09:29:44 <geekosaur> you haven't even touched the questions I asked. does that mean you simply do not know what you are doing?
09:30:18 <monochrom> ok, getLocalSer cyclist = splitAt 1 cyclist. KISS
09:30:30 <geekosaur> ^^ is the best I can pull from the mess you made
09:30:45 <Maior> tomboy64: http://en.wikipedia.org/wiki/Set_(abstract_data_type)
09:30:51 <Maior> tomboy64: (tl;dr "no")
09:31:04 <applicative> tomboy64: there's a totally different way of implementing them, not with lists
09:31:28 <tomboy64> okay
09:31:33 <geekosaur> joergfritsch, there's no point to most of what you did there. there's no monad, there's no point to using a let, there's nothing going on but the splitAt which you can just use as is
09:31:36 <tomboy64> so let's do some reading :-}
09:32:47 <geekosaur> again I ask: what were you trying to accomplish with all the extra noise? or did you just throw it in "because"?
09:33:58 <monochrom> I think I know. common programmer psychology. to fix a program, add more code, never consider deleting code
09:34:04 <joergfritsch> geekosaur: Sorry for being so straight, but the fact that you have done n a couple of years longer than I does not make others inferior beings.
09:34:30 <marko> What his channel  is talking about?
09:34:40 <Maior> marko: http://www.haskell.org/
09:34:51 <geekosaur> joergfritsch, there is a tendency for neewcomers to Haskell to just use random syntax for no obvious reason, I'm trying to understand why
09:35:05 <geekosaur> I mean, it's complex enough without adding stuff in
09:35:17 <geekosaur> I'm not trying to be insulting, I'm tryong to understand
09:35:30 <joergfritsch> geekosaur: because the return command looks very similar to other languages but in fact is not.
09:35:42 <Maior> learnyouahaskell.com
09:35:48 <joergfritsch> I was not present when they named the thing
09:35:51 <geekosaur> and yes "just throwing it in 'because'" pretty much is the answer we get a lot!
09:35:56 <marko> I want to  go to somebody computer i know their ip but i want to download some files  can  i do that? is it possible?
09:36:08 <applicative> ha
09:36:10 <monochrom> that's off-topic, marko
09:36:15 <Maior> marko: wrong channel, very wrong channel
09:36:38 <marko> hah lol
09:38:25 <tromp> go to #nsa or something, marko
09:39:13 <applicative> is it just me or is http://www.haskellers.com/jobs/46 practically unreadable?
09:39:45 <plhk> it is
09:39:57 <monochrom> it is me too. black on black.
09:40:15 <sirspazzolot> applicative: if it were consistently dark I'd be fine with it, but having to switch from the white to the dark gray is annoying
09:40:18 <hape01> joergfritsch: this compiles, at least:   getLocalSer ∷ [a] → ([a], [a])     getLocalSer cyclist = splitAt 1 cyclist
09:40:30 <applicative> it's probably that Template Haskell he's using!
09:40:39 <applicative> cassius or whatever
09:41:48 <applicative> hah, one of the more recent patches on github is 'improved jobs CSS'
09:42:10 <monochrom> "improved"
09:45:23 <ignacio> hey, what's with the fancy ∷ and →
09:46:08 <monochrom> like you said, it's fancy :)
09:46:41 <bb010g> Does the channel automatically do that? :: -> =>
09:46:44 <bb010g> :(
09:46:59 <ignacio> I don't think that's possible on freenode
09:47:01 <monochrom> no, don't worry
09:47:08 <ignacio> is it?
09:47:28 <bb010g> It might be possible clientside.
09:47:34 <monochrom> but! you can set your irc software to do it, using its auto-correction facility
09:47:42 <FreeFull> I can't even type a ∷
09:47:53 <ignacio> you just gotta type : and then : really fast
09:47:59 <ignacio> before the carriage finishes moving
09:48:04 <monochrom> haha
09:48:06 <FreeFull> ignacio: That doesn't do anything =P
09:48:13 <ignacio> you're probably too slow
09:48:18 <FreeFull> =P
09:48:26 <josephle> says you, I installed irssi on a typewriter
09:48:32 <monochrom> ∷)
09:48:34 <FreeFull> Something like ǻ is much easier to write
09:48:45 <ignacio> holy fuck, we have control characters which reference typewriter mechanisms
09:49:03 <ignacio> 21st century and we're still using "carriage returns"
09:49:08 <monochrom> ascii was inspired by typewriter
09:49:20 <applicative> the typewriter is sort of Keyboard98, it's still the reference
09:49:39 <monochrom> electric typewriter has static typing
09:49:52 <Clint> *rimshot*
09:50:04 <MrRacoon> hehe
09:56:18 <hape01> ignacio, bb010g: When You copy+paste from Emcas/haskell with fontlock enabled, than You get these symbols in here: IO ∅  ←  →  ⇒  ≡
09:56:18 <Krakarn> is there something wrong with me because I can't quite gets to grips with functions as applicative functors?
09:56:38 <hape01> think it is plain unicode?
09:56:52 <bitonic> ∅ for () doesn’t make any sense
09:57:04 <hape01> butonic: is that no called unit?
09:57:19 <hape01> bitonic: is that no called unit?
09:57:27 <hape01> bitonic: is that not called unit? sorry
09:57:34 <bitonic> hape01: yes, while ∅ is the symbol for the empty set
09:58:05 <bitonic> the close thing to an empty set in type theory is often called Empty, or 0
09:58:07 <bitonic> or Void
09:58:24 <bitonic> and it’s the dual of Unit, which is also called 1 sometimes
09:58:40 <bitonic> but anyway they should fix that if Emacs really converts () to ∅
09:59:01 <hape01> ... for sure. I took it as implemeneted :-)
09:59:19 <ignacio> Krakarn: there was something wrong with you the moment you set out to learn Haskell
09:59:32 <ignacio> except for that, you're OK
09:59:38 <monochrom> haha
09:59:51 <stolaruk> (<*>) will always return an applicative functor, as opposed to a regular functor, correct?
10:00:12 <tac> @type (undefined <*>)
10:00:13 <lambdabot> Applicative f => f a -> f b
10:00:21 <tac> stolaruk: ^ yep
10:00:45 <applicative> Krakarn: you mean the applicative instance for (a ->) so to say
10:00:49 <stolaruk> Cool, thank you!
10:01:01 <Krakarn> applicative yes
10:01:22 <Krakarn> I mean I sorta get it, but at the same time it feels I didn't get the whole picture
10:01:26 <Krakarn> I guess it comes with time
10:01:37 <applicative> in a way its the best one, isn't <*> the 'S' combinator, pure is 'I' ... something like that
10:02:20 <supki> pure is K
10:02:36 <applicative> Krakarn: but suppose you have the secret key, the a, and I have a function a -> Char, and another a -> Char -> String,
10:02:39 <applicative> K of course
10:02:47 <stolaruk> Types become instances of typeclasses. Functions are functors and applicative functors... does that mean there is a "Function" type?
10:03:07 <applicative> if you give me the secret a I can get a char , and a Char-> String, and thus a String
10:03:37 <applicative> but even if you don't give me the secret a, I can already figure out, not the string, but a function a -> String
10:03:42 <applicative> I guess that's hopelss
10:04:04 <applicative> Krakarn: it's the same as the so-called reader monad -- it is also a monad of course (a ->)
10:04:10 <applicative> to write it that way.
10:04:27 <Krakarn> hmm
10:04:39 <applicative> the reader is so called because everthing in the program is dependent of some external thing that need to be read, e.g. a configuration file
10:04:46 <Krakarn> I come from an imperative background, maybe that's why
10:05:18 <FreeFull> :t join . id
10:05:18 <lambdabot> Monad m => m (m a) -> m a
10:05:32 <FreeFull> Ah, nevermind
10:05:34 <applicative> so inside the monad or applicative, it's as if I pretend to work with Ints and Chars and so on, but really, its all configuration dependent and I'm using Conf -> Char, Conf -> Int, etc etc.
10:05:39 <monochrom> stolaruk: the type "(->) e" is a type that is an instance of the Functor type class.
10:05:46 <applicative> but the applicative combinators let me 'emulate' ordinay application and so on
10:05:57 <Krakarn> right
10:06:57 <applicative> another way of looking at the applicative instance is to think of X -> Y values as 'variable' Y's
10:07:03 <applicative> depending on a choice of X
10:07:20 <applicative> 'a Y that varies over Xs', or whatever dubious language you like.
10:07:45 <applicative> but if I have a Char that varies over Confs and a (Char -> Int) that varies over Confs, ie
10:07:49 * hackagebot bytes 0.9 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.9 (EdwardKmett)
10:07:57 <applicative> a Conf -> Char, and a Conf -> Char -> Int,
10:07:59 <stolaruk> monochrom: Ok so we tare talking specifically about a curried function expecting one more argument
10:08:40 <applicative> then I have a variable Int too,  a Conf -> Int, applying the Conf-dependent function to the Conf-dependent value
10:08:54 <applicative> this application is by <*>
10:08:55 <Krakarn> right well
10:10:19 <applicative> @type (+) <*> (+1) <*> (+2)
10:10:20 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
10:10:20 <lambdabot>     Expected type: (a0 -> b0) -> a0
10:10:20 <lambdabot>       Actual type: (a0 -> b0) -> a0 -> b0
10:10:23 <applicative> ahhhhh
10:10:27 <applicative> @type (+) <$> (+1) <*> (+2)
10:10:28 <lambdabot> Num a => a -> a
10:10:39 <Krakarn> :)
10:11:06 <Krakarn> see? it all blends together to form a mess of functions which I can't understand :P
10:11:51 <Krakarn> if you just stare at it for long enough, maybe it will come through
10:11:59 <applicative> Krakarn: I agree the <$> symbolism is fairly deadly, though you get used to mentally deleting it ...
10:11:59 <tac> @type ((+)<$>)
10:12:00 <lambdabot> (Functor f, Num a) => f a -> f (a -> a)
10:12:37 <tac> What kind of sadist would use that instance of Applicative?
10:12:38 <applicative> @type (+) <$> [1,2,3] <*> [4]
10:12:42 <lambdabot> Num b => [b]
10:12:47 <applicative> type (+) <$> [1,2,3] <*> [4]
10:12:53 <applicative> > (+) <$> [1,2,3] <*> [4]
10:12:54 <lambdabot>   [5,6,7]
10:12:55 <Krakarn> hmm well you could say that if you always think about lifting the original function then you can use <*> as you wish
10:13:08 <tac> You can code for clarity, or you can code for clever. I'm not convinced Applicative for (->) gains you a ton of clarity.
10:13:30 <applicative> tac, I think the S K I combinators gave some clarity to something
10:14:49 <applicative> its true that the Functor and Applicative instances for (->) a make for a pile of pointless new error messages
10:16:10 <Krakarn> like having a function as an instance of Num?
10:16:11 <applicative> and are probably not worth the trouble, but it's the poor man's non-Transformers reader monad
10:16:26 <ReinH> Hi folks. What are people using these days for HTTP clients (especially RESTy, JSON or XML)?
10:16:33 <drostie> tac: wait, the code you provided doesn't use the Applicative Functor instance for (->), it just uses the Functor instance in general.
10:16:58 <applicative> ReinH: did you see the zippy one-liner for http-streams the other day.
10:17:03 <ReinH> Krakarn: something something Godel numbering?
10:17:06 <ReinH> applicative: hai! No?
10:17:12 <bitonic> @ty (<*>) -- drostie
10:17:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:17:46 <applicative> http://www.reddit.com/r/haskell/comments/1iihvg/neat_trick_downloading_a_file_over_http_using/ it's silly, just downloading a file, but nice
10:17:51 <bitonic> drostie: oh sorry, it’s lists there.
10:17:52 <ReinH> applicative: pipes seems like a fun way to do it
10:17:57 <drostie> bitonic: I know what <*> is; I'm confused as to what point tac is making.
10:18:19 <bitonic> drostie: yeah, you’re right, I misunderstood your comment
10:18:48 <applicative> ReinH: he is going to port http-streams to pipes, once pipes settles down ...
10:18:49 <bitonic> in tac’s code what you’re using is the Functor and Applicative instance for []
10:19:13 <ReinH> applicative: Right. Seems good. Typed, composable stream processing is so win.
10:19:39 <ReinH> applicative: And then someone can use it for a HTTP server / middleware stack
10:19:44 <applicative> ReinH: I was going to try it, partly to figure out some of these http things, but then emerged on the pipes list
10:19:58 <ReinH> applicative: HTTP is hard. And HTTP2 will be harder.
10:20:32 <applicative> conduit also has machinery for all this
10:21:26 <applicative> http-streams/io-streams doesn't abstract from IO at all, but it is charming anyway
10:21:33 <ReinH> applicative: hmm, I'm wondering how to handle short-lived TCP connections with pipes
10:22:09 <ReinH> have a proxy that queues and manages a connection?
10:22:40 <ReinH> so it queues the upstream payloads until a conn is avaialble?
10:22:51 <applicative> I take it you've seen https://github.com/k0001/pipes-network/tree/master/src/Control/Proxy
10:23:07 <applicative> i don't know much about such things, of course
10:23:36 <ReinH> applicative: afaik the TCP proxy expects a NS.Socket to be managed externally
10:23:54 <ReinH> applicative: I think what I want is https://github.com/k0001/pipes-network/blob/master/src/Control/Proxy/TCP/Safe.hs
10:24:28 <applicative> ah, yes, I was just pointing out someone had gone into TCP land in case you hadn't noticed
10:25:07 <ReinH> applicative: yeah :)
10:28:15 <applicative> ReinH: Renzo C also has a simplified Network.TCP which as it happened helped me get the idea, not that you sound like you need the Idea of TCP, https://github.com/k0001/network-simple/blob/master/src/Network/Simple/TCP.hs
10:28:24 <ReinH> Hmm... where are the pipe/proxy laws? I want to know what is required of my proxies.
10:28:42 <ReinH> applicative: that is cool though
10:29:13 <drostie> Let's see, the <*> for (->) is f(x -> y) -> f x -> f y which in this case is (a -> x -> y) -> (a -> x) -> (a -> y) ? So fg <*> fx = \a -> (fg a) (fx a) ? :D
10:29:28 <ReinH> yeah, I totally can do that. There's a 'take' proxy obv.
10:29:29 <applicative> drostie, exactly
10:29:53 <applicative> yes ReinH or maybe head_ in your case ...?
10:30:08 <ReinH> applicative: Well, in my case it's heuristic-based, I just want to make sure I'm not violating laws.
10:30:50 <ReinH> applicative: the use case is I will be making a small number of distinct calls to a heavily rate-limited API
10:30:55 <applicative> I was thinking the 'laws' Tekmo is thinking of are supposed to be encapsulated in the leading combinators >-> //> and so on
10:31:06 <applicative> with their alarming //>\\<</ names
10:31:08 <ReinH> so I can add a rate limiting proxy that manages a distinct queue
10:31:29 <ReinH> so the client just sends all the messages it wants, whenever it wants, and the rate limiter makes sure I don't exceed limits
10:31:43 <edwardk> @tell davean analytics should build with current versions of everything again
10:31:43 <lambdabot> Consider it noted.
10:31:50 <ReinH> edwardk: hi!
10:32:01 <edwardk> heya ReinH
10:32:01 <applicative> edwardk: you have an `everything` package
10:32:03 <applicative> ?
10:32:10 <ReinH> applicative: it is ALL the things :)
10:32:18 <edwardk> nah. i broke up everything. now its i just have 'all the packages' instead
10:32:42 <applicative> cabal install edwardk -j322
10:32:49 * hackagebot bits 0.3 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.3 (EdwardKmett)
10:32:56 <ReinH> pdxleif: I am also in pdx iff PDX = Portland, OR
10:33:14 <ReinH> applicative: I wish that worked but for my brain
10:33:54 <applicative> you need snoymans 'cabala receive edwardk -j322'
10:34:15 <applicative> and a correct spiritual attitude ...
10:34:27 <ReinH> where is that cyberpunk future when I need it?
10:35:08 <applicative> snoyman thought he was making a witty pun but 'cabal' is old english 'cabala'
10:35:17 <ReinH> :D
10:35:19 * edwardk installs a chip in the back of his brain and mutters "I finally know category theory."
10:35:35 <ReinH> edwardk: exactly
10:35:38 <applicative> there's a lot of people with that chip; they turn out not to useful
10:35:47 <applicative> not to be useful
10:35:58 <edwardk> applicative: how do you think i found mine? they were giving them out free at some conference
10:36:04 <applicative> haha
10:36:24 <applicative> everyone was hitting everything with yoneda and you just joined right in
10:36:59 * applicative took a class with steven awode y , who was forever saying 'then we hit it with yoneda...'
10:37:00 <edwardk> its just a right kan extension man, its no big deal. everyone is doing it. monads want to be free, dude!
10:37:36 <applicative> somehow the 2 second yoneda hit would always pass by a little too quickly for me...
10:37:42 <pdxleif> ReinH: Yeah?  Where do you work?  Having a sort of Idris meetup tomorrow if'n you're into dependent types...
10:37:49 * hackagebot bits 0.3.1 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.3.1 (EdwardKmett)
10:37:53 <applicative> hail Idris
10:37:59 <edwardk> alas i seem unable to retain category theory. there is a definitely a forgetful functor involved
10:38:17 <ReinH> pdxleif: I contract for ATT so I work from home and this week is full up (parents visiting) but I'd love to get together and talk about such things.
10:38:46 <pdxleif> You ever make it by the PDXFunc meetings we have at Janrain?
10:38:54 <ReinH> pdxleif: no but I should.
10:39:06 <pdxleif> Do you get to use FP at ATT?
10:39:35 <ReinH> pdxleif: I... write some javascript sometimes...
10:39:57 <ReinH> :(
10:40:03 <pdxleif> heh.  I guess there's functions in there.
10:40:11 <ReinH> they are even first order.
10:40:17 <ReinH> and you can hack in currying and PA
10:40:20 <ReinH> but it's not a great FP langauge
10:40:37 <pdxleif> Idris has a JavaScript backend, these days...
10:40:39 <ReinH> CoffeeScript is slightly better in that regard (" " is composition)
10:40:52 <pdxleif> Ah, cool.
10:40:57 <zq> is it possible to use the application operator to simplify "f (3*2) (f (-1) 1)"?
10:40:58 <applicative> do they use some Haskell at Janrain?
10:41:08 <Hafydd> What's the difference between currying and PA?
10:41:17 <root________> http://lpaste.net/91061
10:41:19 <dmwit> Application isn't an operator. And what do you mean by "simplify"?
10:41:28 <ReinH> so `memoized fibonacci 5` does what you'd expect
10:41:37 <root________> that provides an error.  What's the proper way to nest a second guard within the otherwise clause of an existing guard
10:41:38 <dmwit> You can probably reduce it to "f 6 (f (-1) 1)" if your Num instance is sane.
10:41:39 <zq> dmwit: application operator as in ($)
10:41:45 <dmwit> ah
10:41:53 <pdxleif> applicative: Yeah, totally.  Here's a blog post from back in the day - http://janrain.com/blog/haskell-janrain/
10:41:57 <applicative> @pl goo f = f (3*2) (f (-1) 1)
10:42:00 <lambdabot> goo = ap ($ 6) (flip ($ -1) 1)
10:42:01 <lambdabot> optimization suspended, use @pl-resume to continue.
10:42:09 <pdxleif> We also use Scala and some other stuff.
10:42:11 <ReinH> Hafydd: currying is converting an n-arity function into n 1-arity functions
10:42:13 <zq> simplify as in reduce the paren count
10:42:24 <dmwit> Yes, you can reduce the parenthesis count.
10:42:28 <dmwit> f (3*2) $ f (-1) 1
10:42:33 <ReinH> so f(x,y,z) becomes f(x)(y)(z)
10:42:38 <applicative> oh cool pdxleif the website make it seem the company is going places
10:42:47 <applicative> but then a website would ;)
10:42:50 <zq> dmwit: what about f $ 3*2 $ f (-1) 1?
10:42:51 * hackagebot ssh 0.2.12 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.12 (SimonMichael)
10:42:52 <dmwit> If ($) were left-associative like it ought to be you could reduce it further. =)
10:42:56 <dmwit> zq: sorry, no
10:42:58 <Hafydd> Oh, alright.
10:43:06 <ReinH> Hafydd: PA is essentially a partially curried function
10:43:11 <dmwit> zq: The fact that you can't do that is, in my opinion, a wart.
10:43:12 <pdxleif> applicative: Yeah, then the website is working!  Good places, I hope. :J
10:43:17 <Hafydd> I see, ReinH.
10:43:17 <zq> hm no nvm
10:43:19 <dmwit> One we are unfortunately stuck with because so many people abuse it.
10:43:25 <zq> that treats (3*2) as a function
10:43:26 <ReinH> f(x)(y) is a partially applied function that accepts an arg
10:44:43 <applicative> > foldr1 (+) [3*2,-1,1]
10:44:44 <lambdabot>   6
10:44:52 <ReinH> Hafydd: although PA can also be like Scheme's `cut`
10:44:59 <dmwit> applicative: cute suggestion =)
10:45:06 <dmwit> > foldr1 f [3*2,-1,1]
10:45:08 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
10:45:08 <lambdabot>    arising from a us...
10:45:14 <ReinH> Hafydd: which does not require currying
10:45:16 <dmwit> > foldr1 f [3*2,-1,1] :: Expr
10:45:17 <lambdabot>   f (3 * 2) (f (negate 1) 1)
10:45:26 <applicative> ah good
10:45:28 <Hafydd> Or Python's functools.partial.
10:45:30 <tac> @type f
10:45:31 <lambdabot> FromExpr a => a
10:45:32 <ReinH> or Elixir's &n notation
10:45:36 <pdxleif> I'd like for us to be more active in open source.  Right now you just see us on hackage like these two places that I know of - http://hackage.haskell.org/package/memcached, http://hackage.haskell.org/package/yesod-auth (rpxnow)
10:45:54 <applicative> zq or, more safely
10:45:57 <pdxleif> We have an openid library too, I think.  Oh, and coup.
10:46:05 <dmwit> applicative: (Provided f is being used at the same type in both places, of course. A pretty likely scenario, I think.)
10:46:23 <applicative> dmwit: yes, I wasn't contemplating that
10:47:01 <ReinH> pdxleif: so you're using yesod in production?
10:47:02 <ReinH> seems good
10:47:08 <ReinH> pdxleif: where do you work again?
10:47:37 <pdxleif> Janrain.  And we're not using Yesod, we use Snap (we have one of the Snap team here).
10:47:43 <dmwit> > let f x y = fromIntegral x + y in foldr1 f [3*2,-1,1]
10:47:45 <lambdabot>   6
10:47:50 <dmwit> uh
10:47:55 <dmwit> Oh, right. =P
10:48:02 <dmwit> > let f x y = fromIntegral x + y in foldr1 f [3*2,-1,1] :: Double
10:48:03 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
10:48:04 <lambdabot>    arising from a use ...
10:48:06 <pdxleif> That yesod auth module is unconnected w/ us - just someone wrote a client lib for our rpxnow.com thing.
10:48:13 <dmwit> > let f x y = fromIntegral x + y in f (3*2) (f (-1) 1) :: Double
10:48:15 <lambdabot>   6.0
10:48:31 <dmwit> (Just wanted to make sure I could cook up such an example.)
10:48:33 <ReinH> pdxleif: oh cool
10:48:51 <applicative> zq so any way foldr/foldr1 is a suitable abstraction where you contemplate f x (f y (f z ..
10:50:02 <applicative> why do 1  + 2 when you can do foldr (+) 1 [2]
10:50:43 <applicative> i guess foldr1 is sort of meant to be like a lisp (+ 1 2 3 4 5)
10:51:08 <pdxleif> Or J's +/ 1 2 3 4 ?
10:51:16 <applicative> ah
10:51:38 <zq> applicative: foldr1 only takes 2 args, though
10:51:47 <applicative> wait, we need FOLDR brackets (|(+) 1 2 3 4 5|)
10:51:51 <elliott> well, lisp often has (+) as 0, no?
10:52:04 <augur> elliott: indeed
10:52:05 <Krakarn> what about iterate
10:52:07 <zq> applicative: as in, the function you feed to foldr1 must only accept 2 args
10:52:16 <elliott> though (+ x) is unlikely to be x + 0. :(
10:52:18 <Krakarn> dont mind me lol
10:52:23 <applicative> oh, but that syntax (op 1 2 3 4) is typical no? for a lisp?
10:52:25 <augur> elliott: why?
10:52:26 <pdxleif> In scala they call foldl and foldl1 "foldLeft" and "reduceLeft", respectively.
10:52:32 * applicative hasn't looked at a lisp for a while
10:52:56 <elliott> because (+ -3) is probably going to be 3.
10:53:02 <elliott> pretty sure it's like this in common lisp and scheme
10:53:12 <augur> elliott: mit scheme has (+ -3) == -3
10:53:22 <applicative> > ala Sum foldMap [1,2,3]
10:53:23 <lambdabot>   Not in scope: `ala'
10:53:23 <lambdabot>  Perhaps you meant one of these:
10:53:23 <lambdabot>    `all' (imported fro...
10:53:28 <applicative> :(
10:53:52 <augur> elliott: at least as of MIT Scheme's 2008 version
10:53:56 <augur> 1 ]=> (+ -3)
10:53:56 <augur> ;Value: -3
10:54:29 <applicative> oh I see, thus (+) is 0
10:54:32 <applicative> taken by itself
10:54:39 <applicative> (*) is presumably 1?
10:54:50 <augur> yeah, scheme treats * as the obvious folds
10:54:52 <supki> @let import Control.Lens.Wrapped
10:54:52 <elliott> so it's not really a fold1.
10:54:53 <lambdabot>  Defined.
10:55:08 <augur> elliott: not in MIT scheme no, its just foldr
10:55:09 <elliott> IIRC scheme leaves (+) undefined or something
10:55:14 <applicative> no, it's more like ala _ foldMap
10:55:21 <augur> elliott: nope, (+) is 0
10:55:27 <dmwit> zq: Not necessarily. e.g. (.) takes three arguments but foldr1 (.) type-checks ok.
10:55:34 <dmwit> :t foldr1 (.)
10:55:35 <lambdabot> [c -> c] -> c -> c
10:55:41 <augur> elliott: (*) = 1, (append) = ()
10:56:08 <applicative> > foldr1 (.) [even,  odd . (+1)] $ 3
10:56:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
10:56:09 <lambdabot>    arising from a use of `GHC....
10:56:24 <applicative> oh wait that was moronic
10:56:41 <applicative> > foldr1 (.) [(*3). (+1)] $ 3
10:56:42 <lambdabot>   12
10:56:47 <elliott> augur: I mean R5RS.
10:56:50 <applicative> > foldr1 (.) [(*3), (+1)] $ 3
10:56:51 <lambdabot>   12
10:56:53 <elliott> I believe MIT Scheme has (+) as 0, yes
10:57:21 <applicative> @type foldMap
10:57:22 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:57:43 <augur> elliott: ill have to check what i have currently, but i think its r5rs
10:57:44 <dmwit> applicative: useless use of $ award
10:57:50 <applicative> @type foldMap Sum
10:57:51 <lambdabot> (Num a, Foldable t) => t a -> Sum a
10:57:56 <applicative> dmwit: yes, too much editing
10:58:03 * dmwit nods appreciatively
10:58:05 <applicative> > foldMap Sum []
10:58:06 <lambdabot>   Sum {getSum = 0}
10:58:18 <elliott> ok, I was wrong, r5rs defines (+) as 0
10:58:21 <applicative> > foldMap Product []
10:58:21 <elliott> just checked
10:58:22 <lambdabot>   Product {getProduct = 1}
10:58:34 <elliott> and (*) as 1
10:58:35 <applicative> > foldMap ZipList []
10:58:36 <lambdabot>   No instance for (Data.Monoid.Monoid
10:58:36 <lambdabot>                     (Control.Applicativ...
10:58:39 <applicative> bahj
10:58:46 <augur> elliott: drracket confirms these all for r5rs too :)
10:58:51 <applicative> > foldMap (++[]) []
10:58:52 <lambdabot>   []
10:59:38 <applicative> so we can emulate the lisp phenomena without special syntax, we just need tiresome newtype wrapping
10:59:53 <Shie0shi> hello, can typesystem save from pebkac?
11:00:06 <applicative> ?!!
11:00:06 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
11:00:23 <tac> Is there an easy way to have Aeson return Nothing if a key doesn't exist?
11:00:41 <tac> ah, nvm
11:00:42 <dmwit> Shie0shi: "Pray tell, if you put the wrong numbers in, do you still get the right answer out?"
11:00:45 <tac> .:? is the operator I want
11:00:50 <dsabanin> is it normal that after executing 313 ^ 313333 in ghci, I got segfault on mac?
11:01:08 * applicative tries it
11:01:17 <dsabanin> ver 7.6.3
11:01:27 <dmwit> dsabanin: segfault is almost always a GHC bug, except when dealing with the FFI.
11:01:39 <Shie0shi> dmwit: wrong number should not be allowed
11:01:41 <applicative> :Illegal instruction: 4"
11:01:44 <dsabanin> I didn't expect to hit one so fast :)
11:01:52 <applicative> dsabanin: doesn't look good.
11:01:54 <dmwit> Shie0shi: Then pebkac is not allowed, and your question is senseless.
11:02:13 <applicative> well, if we were C programmers, we'd say, what did you expect doing ^ 313333
11:02:16 <dmwit> dsabanin: That exact code works fine here, so if I were you (and I could reproduce it) I would complain on Trac.
11:02:40 <applicative> dsabanin: did you compile it? let me see
11:02:51 <dsabanin> applicative I just opened ghci and entered 313 ^ 313333
11:03:01 <dsabanin> btw, ruby returns the result :)
11:03:07 <dsabanin> after a long while
11:03:12 <byorgey> Shie0shi: the type system can be used to catch certain kinds of "pebkac" errors.  It can never save you from them completely.
11:03:13 <dmwit> GHC return it immediately here. =)
11:03:19 <elliott> shie0shi already quit
11:03:24 <byorgey> oh.
11:03:49 <dsabanin> heh, it actually worked after I restarted the ghci
11:04:09 * byorgey is not sure whether Shie0shi was serious or trolling.
11:04:09 <dsabanin> much faster than ruby indeed
11:04:38 <applicative> dsabanin: it works after its compiled, main = print $ (313 ^ 313333 :: Integer)
11:04:49 <dmwit> It's only 20 multiplications or so. I'm surprised Ruby had trouble with it, to be honest.
11:05:09 <dsabanin> ruby has trouble with lots of things :)
11:05:44 <applicative> I wonder where the trouble is coming from.
11:05:51 <applicative> let me try without optimization
11:06:20 <applicative> no that works fine
11:06:22 <dmwit> Maybe OSX has a buggy libgmp or something.
11:06:35 <dmwit> I mean, I feel there is not much for GHC to do in the realm of optimization here.
11:07:20 <applicative> dmwit: it seems to work however i compile, but fails inside ghci
11:07:31 <dmwit> hm
11:07:39 <applicative> maybe ghci has its own way to convert to string?
11:07:40 <dmwit> That does seem to lead the blame away from libgmp, then. =)
11:08:29 <applicative> it is obviously in  the show instance, I think
11:08:41 <applicative> because it prints the first 1000 + digits then fails
11:09:47 <monochrom> 313^313333 at ghci prompt works for me on linux both i386 and x86_64. (perhaps you already know)
11:09:49 <dmwit> Well, that could mean that libgmp uses a C analogue of lazy bytestrings and mucked up its... wait
11:09:51 <geekosaur> [19 14:00] <dsabanin> is it normal that after executing 313 ^ 313333 in ghci, I got segfault on mac?
11:09:59 <dmwit> That doesn't make sense.
11:10:00 <applicative> monochrom: yes, it was seeming an os x thing
11:10:03 <geekosaur> that's a known bug with many ghc versions on os x
11:10:28 <applicative> oh what is the general characterization?  dont do big numbers in ghci?
11:10:39 <osa1> uh. my program leaks memory if I don't use strict HashMap ...
11:10:46 <monochrom> may I suggest: use a virtual machine and run linux inside :)
11:10:55 * applicative recommends strict hashmap
11:11:02 <geekosaur> lemme try to find the ghc bug
11:11:04 <monochrom> then use strict hashmap
11:12:10 * applicative recommends strict hashmap to his friends who use hashmaps
11:12:25 * applicative also recommends strict stateT to his friends who use state
11:12:55 <Fuuzetsu> :t (undefined <|> undefined)
11:12:55 <lambdabot> Alternative f => f a
11:13:10 <osa1> applicative: do you mean always use strict versions of StateT, HashMap etc?
11:13:12 <Fuuzetsu> @pl f x = foo x <|> bar x
11:13:15 <lambdabot> f = liftM2 (<|>) foo bar
11:13:15 <lambdabot> optimization suspended, use @pl-resume to continue.
11:13:17 <applicative> osa1: yes
11:13:26 <johnw> osa1: until you decide you need the lazy version
11:13:39 <applicative> osa1: but I dont mean to be speaking with authority, only as the scribes do
11:15:12 <osa1> ahh. this again made my think that maybe strict-by-default with optional laziness would be a better choice for haskell ...
11:15:20 <johnw> noooooo
11:15:33 <johnw> having a strict-by-default data structure is a different beast from a strict-by-default language
11:16:02 <applicative> osa1: well maybe, but these cases are pretty clear. lazy state is a bit recherche
11:16:14 <johnw> because it's pretty typical that you want your data structures to accumulate data, rather than thunks; but I definitely want thunks used in place of expressions I'm never going to evaluate
11:16:28 <ignacio> IO feels like "Haskell doesn't kill people, it just calls a hitman and passes him a list of people he wants dead"
11:16:29 <applicative> exactly yes
11:16:51 <applicative> ignacio: try io-streams or something
11:17:11 <johnw> yeah, or conduit.  this week everything looks like a nail and conduit is my hammer
11:17:35 <johnw> there's nothing like overusing something to discover when it shouldn't be used :)
11:17:36 <applicative> osa1: like johnw says, in a state calculation, the state is like an accumulator. the situation is like a left fold, where we want 'really' to accumulate
11:18:14 <applicative> ignacio: I recommend it. I suppose conduit has better tutorials about.
11:18:32 <osa1> fair enough
11:18:40 <johnw> well, and io-streams is a much more basic model
11:18:40 * applicative secretly is madly in love with lazy io and will never let it go
11:18:57 <johnw> see edsko's recent talk on "alternatives to lazy I/O" for a good overview of io-streams vs. pipes/conduit
11:18:59 <applicative> yes its simpler and more primitive
11:19:03 <osa1> applicative: I didn't think of that in terms of accumulators, that makes sense. is it also why we generally prefer foldl' over foldl, right?
11:19:17 <applicative> osa1: yes, that was my analogy
11:19:40 <johnw> applicative: edsko's example of unsafeInterleaveIO leading to referential opacity (x + y not being the same as y + x) scared me a bit
11:19:52 <applicative> given the way people use a hashmap osa1 it's similar
11:20:07 <geekosaur> bleh I am not recognizing the OS X bug
11:20:12 <dmwit> x + y = y + x is not a promise of referential transparency
11:20:22 <geekosaur> (on the ghc trac)
11:20:24 <johnw> osa1: yeah, foldl must compute "all the way down" before it can yield an answer, so it's kind of silly to generate a whole list of thunks.  laziness is better when only one thunk gets created, as is often the case with foldr.  so generally the choice is between foldr and foldl'
11:20:31 <ignacio> I'll look into both
11:20:32 <applicative> its a promise of + though dmwit
11:20:35 <dmwit> > let (+) = (++) in "x" + "y" == "y" + "x" -- perfectly referentially transparent
11:20:37 <lambdabot>   False
11:20:43 <johnw> dmwit: no, but generally it's what we've come ot assume
11:20:45 <dmwit> applicative: not at all
11:20:50 <dmwit> > x + y == y + x
11:20:52 <lambdabot>   False
11:20:57 <applicative> haha
11:21:08 <applicative> okay I take it all back
11:21:12 <Fuuzetsu> > 2 + 1
11:21:13 <lambdabot>   3
11:21:32 <applicative> I guess @check is gone from lambdabot
11:21:39 <dmwit> Lazy IO definitely has problems. But that particular way of demonstrating it isn't convincing to me.
11:21:42 <osa1> uh, how did that work? > x + y == y + x
11:21:48 <dmwit> > x
11:21:49 <lambdabot>   x
11:21:53 <dmwit> ?where simple-reflect
11:21:54 <lambdabot> I know nothing about simple-reflect.
11:21:57 <ignacio> x*x
11:21:59 <applicative> osa1: it is using Expr so x is a real item
11:22:08 <applicative> @type x
11:22:09 <enthropy> > x^5
11:22:09 <lambdabot> Expr
11:22:10 <lambdabot>   x * x * (x * x) * x
11:22:18 <dmwit> osa1: basic idea is outlined well here: http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
11:22:21 <osa1> ooh
11:22:21 <johnw> @where simple-reflect
11:22:22 <lambdabot> I know nothing about simple-reflect.
11:22:32 <applicative> > foldr f x [y,z]
11:22:33 <lambdabot>   f y (f z x)
11:22:33 <osa1> thanks for the link
11:22:35 <dmwit> ?where+ simple-reflect http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
11:22:35 <lambdabot> Nice!
11:22:42 <johnw> I import simple-reflect into all my ghci sessions too
11:22:55 <johnw> > foldr (+) z [a,b,c,d]
11:22:57 <lambdabot>   a + (b + (c + (d + z)))
11:23:04 <dmwit> You know, I think the only serious use I've found for simple-reflect is to stare at foldr and foldl outputs. =P
11:23:04 <applicative> ah much better
11:23:20 <applicative> not a trivial employment when teaching
11:23:30 <dmwit> very true
11:23:35 <johnw> dmwit: I sometimes us it to convience myself of what join is going to mean in some situations
11:23:46 <arkeet> I like  Maybe ()
11:23:56 <johnw> isn't Maybe () ~ Bool?
11:24:02 <arkeet> yes
11:24:07 <dmwit> arkeet: You might like: All
11:24:22 <Taneb> Maybe () ~ Either Void (Either () ())
11:24:24 <arkeet> but I can use monadish things with Maybe ()
11:24:25 <johnw> haha
11:24:48 <johnw> type BoolM = Maybe ()
11:24:55 <dmwit> > mconcat [All True, All True, All False, let loop = loop in loop]
11:24:57 <lambdabot>   All {getAll = False}
11:25:10 <johnw> > ala All [True, True, False, undefined]
11:25:12 <lambdabot>   Couldn't match expected type `(GHC.Types.Bool -> Data.Monoid.All)
11:25:12 <lambdabot>          ...
11:25:15 <johnw> > ala All mconcat [True, True, False, undefined]
11:25:17 <lambdabot>   Couldn't match type `[[GHC.Types.Bool] -> Data.Monoid.All]'
11:25:17 <lambdabot>                ...
11:25:29 <johnw> > ala mconcat All [True, True, False, undefined]
11:25:31 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `[a0] -> a0'
11:25:32 <lambdabot>  Expected type: ([a0...
11:25:35 <dmwit> > foldMap All [True, True, False, undefined]
11:25:36 <lambdabot>   All {getAll = False}
11:25:38 <arkeet> > msum [Just (), Nothing]
11:25:39 <johnw> thanks
11:25:39 <lambdabot>   Just ()
11:25:41 <ignacio> > foldl (+) 0 [1,2,3,4,5]
11:25:42 <lambdabot>   15
11:25:49 <ignacio> > foldl (+) 0 [a,b,c,d,e]
11:25:49 <lambdabot>   0 + a + b + c + d + e
11:25:58 <arkeet> > foldr (>>) (return ()) [Just (), Nothing]
11:25:59 <djahandarie> > ala All foldMap [True, True, False, undefined]
11:26:00 <lambdabot>   Nothing
11:26:01 <lambdabot>   False
11:26:04 <johnw> too bad that foldl output is missing parens
11:26:15 <ignacio> > foldl (funky) 0 [a,b,c,d,e]
11:26:16 <lambdabot>   Not in scope: `funky'
11:26:22 <ignacio> > foldl (f) 0 [a,b,c,d,e]
11:26:23 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
11:26:23 <lambdabot>    arising from a us...
11:26:26 <dmwit> > foldr (+) 0 [a,b,c,d,e]
11:26:27 <lambdabot>   a + (b + (c + (d + (e + 0))))
11:26:29 <arkeet> > foldl f 0 [a,b,c,d,e] :: Expr
11:26:31 <lambdabot>   f (f (f (f (f 0 a) b) c) d) e
11:26:42 <dmwit> johnw: It only inserts parens that don't match the fixity. =)
11:26:44 <ignacio> ah, silly me
11:26:46 <johnw> ah, ok
11:27:04 <johnw> :t ala
11:27:17 <arkeet> we have lens now?
11:27:22 <saml> yes
11:27:29 <arkeet> > ("a","b")^.both
11:27:30 <lambdabot>   Not in scope: `both'Not in scope: `^.'
11:27:30 <lambdabot>  Perhaps you meant one of these:
11:27:30 <lambdabot>    ...
11:27:38 <applicative> > (0,2) .^ _1
11:27:38 <ignacio> sooo if f has a match like f _ x = x, will the foldl still make a million thunks?
11:27:38 <arkeet> what
11:27:39 <lambdabot>   Not in scope: `_1'Not in scope: `.^'
11:27:39 <lambdabot>  Perhaps you meant one of these:
11:27:39 <lambdabot>    `....
11:27:52 * hackagebot geek 1.0.0.4 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.4 (JinjingWang)
11:28:05 <applicative> i guess we dont at the moment
11:28:13 <dmwit> ?src foldl
11:28:14 <lambdabot> foldl f z []     = z
11:28:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:28:18 <arkeet> :(
11:28:54 <dmwit> ignacio: Looks like it. The outermost call is foldl, so the accumulator doesn't get forced until you've walked the whole list.
11:29:00 <applicative> > foldl const 0 [1..]
11:29:01 <dmwit> (I think. I'm so bad at this.)
11:29:09 <lambdabot>   mueval-core: Time limit exceeded
11:29:09 <dmwit> f _ x = x is flip const or const id.
11:29:22 <ignacio> dmwit: it's not easy thinking with portals
11:29:30 <applicative> somehow it thinks const 0 x might end up being something other than 0 out there in the infinites
11:29:31 <arkeet> you can't know how many times foldl applies the function until you see the end of the list.
11:30:02 <applicative> > foldr (flip const) 0 [1..]
11:30:05 <arkeet> or rather
11:30:06 <lambdabot>   mueval-core: Time limit exceeded
11:30:12 <dmwit> applicative: Well. It becomes const 1 0, then const 2 (const 1 0), etc. So it's right.
11:30:13 <arkeet> foldl doesn't produce anything until it hits the end of the list.
11:30:35 <applicative> oh I made a mistake, this is why i need simple reflect for my folds
11:30:40 <dmwit> yes =)
11:30:42 <dmwit> me2
11:30:49 <arkeet> > foldr (flip const) 0 [1..] :: Expr
11:30:53 <lambdabot>   mueval-core: Time limit exceeded
11:30:57 <arkeet> > foldr (const) 0 [1..] :: Expr
11:30:58 <lambdabot>   1
11:31:12 <arkeet> > foldr (flip (const id)) 0 [1..] :: Expr
11:31:13 <lambdabot>   1
11:31:22 <arkeet> > foldr (flip (flip (const id) id)) 0 [1..] :: Expr
11:31:23 <lambdabot>   1
11:31:27 <arkeet> > foldr (flip (flip (const id)) id) 0 [1..] :: Expr
11:31:28 <lambdabot>   No instance for (GHC.Num.Num
11:31:29 <lambdabot>                     (Debug.SimpleReflect.Expr....
11:31:31 <arkeet> hmm
11:31:48 <arkeet> :t flip (flip (const id) id)
11:31:49 <lambdabot> c -> a -> c
11:31:59 <arkeet> :t fix (\x -> flip (x id))
11:32:00 <lambdabot>     Occurs check: cannot construct the infinite type:
11:32:00 <lambdabot>       c0 = (a0 -> a0) -> c0
11:32:00 <lambdabot>     Expected type: a0 -> (a0 -> a0) -> c0
11:32:11 <arkeet> er
11:32:17 <dmwit> const id = flip const and flip (flip f) = f, so flip (const id) = flip (flip const) = const.
11:32:25 <arkeet> const = flip (const id)
11:32:36 <arkeet> yeah.
11:32:44 <arkeet> :t fix $ \x -> flip (x id)
11:32:45 <lambdabot>     Occurs check: cannot construct the infinite type:
11:32:45 <lambdabot>       c0 = (a0 -> a0) -> c0
11:32:45 <lambdabot>     Expected type: a0 -> (a0 -> a0) -> c0
11:32:57 <arkeet> uh
11:33:06 <arkeet> right.
11:33:10 <arkeet> fix doesn't do polymorphic recursion.
11:33:17 <ignacio> it's my second day here and it's the second time people go nuts with flip, const and id
11:33:35 <arkeet> :t let const = flip (const id) in const
11:33:36 <lambdabot>     Occurs check: cannot construct the infinite type:
11:33:36 <lambdabot>       c0 = (a0 -> a0) -> c0
11:33:36 <lambdabot>     Expected type: a0 -> (a0 -> a0) -> c0
11:33:44 <arkeet> :t let const :: a -> b -> a; const = flip (const id) in const
11:33:45 <lambdabot> a -> b -> a
11:34:00 <arkeet> > let const :: a -> b -> a; const = flip (const id) in const 1 2
11:34:02 <lambdabot>   *Exception: stack overflow
11:34:03 <arkeet> =)
11:34:05 <tulcod> can i choose not to expose a module? it's one for internal data types
11:34:14 <dmwit> tulcod: Yes, put it in extra-modules.
11:34:15 <arkeet> sure. just don't export it.
11:34:18 <arkeet> oh, cabal.
11:34:27 <arkeet> I read export, not expose.
11:34:36 <tulcod> dmwit: does that also mean no one can import it?
11:34:40 <arkeet> yes
11:34:40 <dmwit> Yes.
11:34:46 <arkeet> you should let people import it.
11:34:48 <tulcod> sweet, that's what i want
11:34:59 <dmwit> You'll regret it later, probably.
11:35:03 <osa1> omg this is awful :-D http://hackage.haskell.org/packages/archive/simple-reflect/0.3.1/doc/html/Debug-SimpleReflect-Vars.html
11:35:05 <tulcod> why's that?
11:35:11 <dmwit> Because abstractions *always* leak.
11:35:30 <tulcod> so is it a sign i'm doing something wrong? this is for an FFI by the way
11:35:37 <ignacio> so might as well stab it with a screwdriver before shipping?
11:35:40 <dmwit> No, not at all.
11:35:47 <dmwit> Having an internal module is very common.
11:36:15 <ignacio> the old "shank the module" principle
11:36:20 <dmwit> But there's also a very Python-like "we're all consenting adults" convention of exposing that module (with a suitably warningful name, e.g. including Internal somewhere).
11:36:47 <ignacio> FinalStaticDoNotTouch
11:36:48 <monochrom> Data.ByteString.Unsafe.Internal.DontOpen.NoUserServiceableParts.WarrantyVoidIfOpened
11:36:58 <tulcod> hehe, okay, i'll keep that in mind
11:36:59 <dmwit> right =)
11:37:09 <tulcod> i already have one situation where that might actually be appropriate
11:37:48 <ignacio> doesn't that go against safety?
11:37:56 <tulcod> it's an FFI
11:38:08 <tulcod> everything goes against safety
11:38:30 <ignacio> if the user wants to stick his hand inside he can recompile and make it super-explicit
11:38:49 <ignacio> instead of relying on Module.DoNotTouch
11:39:01 <ignacio> well DoNotTouch is kinda explicit
11:39:16 <ignacio> yeah, n/m
11:39:44 <dmwit> Yes, but code duplication is Bad. Bugs fixed upstream must have duplicated fixes downstream, the temptation to fork and modify the downstream project becomes much stronger, etc.
11:39:58 <dmwit> Well, bugfixes and feature additions both.
11:40:01 <tulcod> i'll put my internal types in InternalTypes, and some FFI functions users might be interested in in... i dunno, UnsafeFuns?
11:40:21 <merijn> tulcod: My.Module.Unsafe is a common choice
11:40:22 <dmwit> Sounds like a plan!
11:40:28 <tulcod> merijn: thanks :)
11:40:31 <dmwit> I think .Internal is a much more common choice.
11:40:48 <tulcod> dmwit: yeah, but i'd rather separate the internal types from the FFI calls in this instance
11:40:52 <merijn> dmwit: It depends on whether they're unsafe or just unstable
11:40:55 <arkeet> Unsafe modules are intended to be used, just carefully.
11:41:17 <ignacio> anyone here do Functional workouts like crossfit?
11:41:18 <dmwit> tulcod: That's fine, and laudable.
11:41:23 <arkeet> Internal is for implementation details that people should normally not care about.
11:41:44 <arkeet> and changes to Internal modules aren't subject to the PVP and so on.
11:41:47 <dmwit> Right. I agree with all the distinctions both merijn and arkeet are making.
11:42:00 <tulcod> thanks for the imput guys
11:42:03 <monochrom> Control.Reactive.Unstable
11:42:11 <arkeet> =)
11:42:12 <tulcod> this is my first haskell project so i'm a bit fuzzy on good practices
11:42:31 <shergill> applicative: so for hashmaps i guess where you'd want lazy structures are if you want to tie the knot of sorts?
11:43:08 <dmwit> Yes, or if you don't want to evaluate the values for any other reason -- e.g. you're going to put a lot more things in the HashMap than you're ever going to take out.
11:43:22 <dmwit> Say, for memoization.
11:43:52 <arkeet> dmwit: putting a lot of things into a lazy structure sounds like an invitation for space leaks.
11:44:18 <monochrom> warning: crosstalk on what "structure" refers too
11:44:23 <arkeet> maybe.
11:44:37 <monochrom> i.e., the hashmap itself? the values you store in the hashmap?
11:44:58 <monochrom> fact: the hashmap itself is already eager. you don't have a choice here.
11:45:19 <dmwit> arkeet: Maybe. Perhaps your thunk only needs to store something small (like, "5") but does a lot of work before it evaluates to something else small (like, "120").
11:45:46 <arkeet> sure.
11:46:06 <arkeet> maybe I didn't mean space leaks. in any case, things we don't like.
11:46:20 <dmwit> You're right, there's a danger of space leaks.
11:46:21 <arkeet> like accidentally putting a big thunk into a MVar.
11:46:26 <dmwit> But strict hashmaps have a danger of time leaks. =)
11:47:04 <dmwit> d-d-d-danger look behind you... there's a tradeoff out to FIND you!
11:48:41 <tulcod> dmwit: i think it's other-modules instead of extra-modules :)
11:49:00 <monochrom> sounds right
11:49:13 <dmwit> oops
11:49:29 <dmwit> Sorry!
11:49:32 <ignacio> it's amazing how concise a statement can be without using a single symbol
11:49:45 <ignacio> "The Map key value is an Data.IntMap.IntMap indexed by the hash value, containing either one (key, value) or a Data.Map.Map key value for all keys with the same hash value. "
11:50:28 <ignacio> I feel like my brain shifted down 3 gears while parsing that
11:51:52 <saml> key-value of Map is an hash(value)
11:51:55 <saml> what? i give up
11:52:23 <srhb> You need to beatbox it, it comes out right then.
11:52:32 <saml> why need map when you have function?
11:52:41 <dmwit> saml: The hashmap maps hashes to either a single (key, value) pair or to a balanced tree used for storing the (key -> value) mapping for colliding hashes.
11:52:53 <arkeet> Map (IntMap hash (Either (key,value) (Map key value))
11:52:53 <arkeet> ?
11:53:10 <arkeet> )
11:53:17 <monochrom> function is unsearchable. map is searchable.
11:53:25 <dmwit> I can't say I understand why they special-case single (key, value) pairs. I'm sure Data.Map already has a quite concise representation for that.
11:53:39 <saml> so it's representing currying?
11:53:46 <dmwit> ...no
11:53:48 <monochrom> no
11:54:26 <arkeet> why would you use a IntMap as a key anyway
11:54:27 <saml> i guess Map's domain and range are dynamic
11:54:31 <monochrom> NewMap k v = IntMap Int (Either (k,v) (Map k v))
11:54:52 <arkeet> maybe I misinterpret "Map key value"
11:54:56 <dmwit> arkeet: Yeah, I feel that part is just awkward wording. I think the outer Map in your proposal just isn't there.
11:54:56 <arkeet> lol
11:55:04 <arkeet> ok
11:55:13 <dmwit> Hard to say without seeing the context, though.
11:55:21 <srhb> arkeet: The value of the key in the Map is a (...) _
11:55:22 <srhb> ?
11:55:30 <srhb> well, the type really.
11:55:36 <arkeet> yeah, that's how I took it
11:55:42 <srhb> That's what I get as well.
11:55:57 <dmwit> ahhh, seeing the source makes the parse more clear
11:56:02 <arkeet> but in retrospect that doesn't quite make sense
11:56:06 <dmwit> The type "Map key value" is an ...
11:56:11 <arkeet> ok.
11:56:15 <dmwit> key and value are type variables.
11:56:20 <srhb> Hngh.
11:56:20 <arkeet> =)
11:56:24 <monochrom> <monochrom> NewMap k v = IntMap Int (Either (k,v) (Map k v))
11:56:28 <arkeet> that's what I was starting to think.
11:56:42 <monochrom> see how it's both shorter and clearer with symbols such as = ( )
11:56:46 <ignacio> so it's really English that's at falt
11:56:49 <ignacio> *fault
11:56:55 <srhb> As usual.
11:56:59 <arkeet> english is bad at being unambiguous.
11:57:03 <srhb> I wonder how it would parse in Esperanto.
11:57:09 <dmwit> monochrom: Yes. The question is not "is that the right interpretation" (clearly yes) but "why is this text correct English for that interpretation".
11:57:13 <srhb> Esperanto ALL the Haddocks!
11:57:33 <dmwit> I think it's not English, but the author that's at fault.
11:57:37 <arkeet> =)
11:57:41 <dmwit> English can be made unambiguous, with some effort.
11:57:52 * hackagebot geek 1.0.0.5 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.5 (JinjingWang)
11:58:04 <monochrom> the prose could be clearer by adding a few more words and some fonts. but this means longer.
11:58:11 <dmwit> yep
11:58:27 <ignacio> the original ( http://hackage.haskell.org/package/hashmap ) uses fonts to make it somewhat clearer
11:58:32 <monochrom> e.g., the <tt>Map k v</tt> type is ...
11:58:46 <arkeet> eww, html =)
11:58:49 <srhb> The word type also helps.
11:58:51 <ignacio> :t id
11:58:51 <lambdabot> a -> a
11:58:57 <ignacio> :info Some
11:59:03 <arkeet> using non-words for type variables helps too.
11:59:10 <srhb> arkeet: Very true.
12:00:15 <dmwit> Okay, after looking at the source it seems they're not even doing fancy stuff like unpacking. So my complaint about special-casing single keys stands.
12:00:51 <dmwit> ignacio: Scroll up a line or two: data Some k v = Only !k v | More !(M.Map k v) deriving (Eq, Ord)
12:01:09 <srhb> dmwit: You mean the Either is wrong?
12:01:17 <arkeet> dmwit: the worse thing is that there are two valid ways to represent a single k/v pair./
12:01:33 <arkeet> where's the source?
12:01:35 <dmwit> arkeet: That's exactly my complaint, no?
12:01:38 <arkeet> maybe.
12:01:50 <arkeet> oh, hashmap
12:01:53 <dmwit> srhb: Yeah, just skip the Either entirely. Map k v subsumes (k, v)
12:02:06 <srhb> Aye.
12:02:34 <srhb> At the cost of a slightly "bigger" packing, I assume.
12:02:35 <monochrom> but I use unordered-containers instead of hashmap anyway
12:02:45 <arkeet> the Either is wrapped up in some Some type.
12:03:07 <ignacio> slightly is an understatement
12:03:11 <arkeet> and if a single k/v pair is the common case, then it probably makes sense for performance.
12:03:28 <ignacio> collisions are suposed to be exceptional
12:03:38 <ignacio> at least in some use cases
12:03:50 <arkeet> only some?
12:03:59 <ignacio> I don't know
12:04:26 <ignacio> I  supose someone might be using hash maps with more keys than possible hashes
12:04:28 <dmwit> A singleton Map is not a significantly bigger package.
12:04:37 <dmwit> singleton k x = Bin 1 k x Tip Tip
12:04:48 <dmwit> Same number of dereferences to get the key or value, and Tip's don't take any space.
12:05:31 <ignacio> but you have the pointers to 1, tip, tip right?
12:05:56 <dmwit> I suppose.
12:06:00 <ignacio> it might not matter depending on the size of x and k
12:10:19 <zq> (putStrLn "asdf") >> (print 43) is equivalent to do { putStrLn "asdf"; print 43 }, right?
12:10:27 <arkeet> yes
12:10:44 <zq> in general, is bind equivalent to sequencing in a do block?
12:10:58 <Jeanne-Kamikaze> do is just sugar
12:10:58 <arkeet> yes, do blocks are just syntactic sugar.
12:11:05 <zq> thanks
12:11:12 <arkeet> @undo do {putStrLn "asdf"; x <- readLn; print x}
12:11:12 <lambdabot> putStrLn "asdf" >> readLn >>= \ x -> print x
12:11:45 <klrr_> morning
12:12:04 <arkeet> afternoon
12:12:12 <yesthisisuser> evening
12:12:19 <zq> i know kung fu
12:14:32 <ignacio> @undo do {x <- readLn; putStrLn "hi"; print x}
12:14:32 <lambdabot> readLn >>= \ x -> putStrLn "hi" >> print x
12:16:16 <ignacio> @undo do {x <- readLn; y <- readLn; print x; print y}
12:16:16 <lambdabot> readLn >>= \ x -> readLn >>= \ y -> print x >> print y
12:19:40 <ignacio> getting into Haskell was a worse mistake than going into Physics
12:20:12 <monochrom> worksforme
12:20:16 <applicative> physics is good
12:20:32 <dmwit> Conclusion: going into physics was not much of a mistake at all.
12:20:36 <applicative> haskell is a little more rigorous
12:20:50 <applicative> but not much ...
12:22:19 <mcstar> depends where you stand
12:22:22 <mcstar> it can be much more
12:22:41 <ignacio> physics? rigurous? I've seen things that would make a mathematician squeal
12:23:19 <ignacio> and I'm just an undergrad
12:24:03 <monochrom> math is rigorous. physics is vigorous. but not as vigorous as dumping sodium into water. :)
12:24:34 <Taneb> monochrom, that's chemistry
12:24:45 <monochrom> that is, unless, the physics guys bring out the big guns such as LHC...
12:25:09 <applicative> when it comes to symbolism a language like haskell or agda or whatever, requires much more precision than is customary among mathematicians
12:25:22 <tulcod> in writing an FFI, what is reasonable behaviour if the C lib returns a NULL ptr because it's out of memory?
12:25:42 <applicative> but the mathemeticians have a complicated tradition and system of conventions to make up for this
12:25:54 <Cale> tulcod: Throwing an exception?
12:26:01 <tulcod> (this is not a memory-intensive application so it is an unlikely condition which cannot reasonably can be dealt with by freeing stuff)
12:26:11 <tulcod> Cale: ok.
12:26:20 <tulcod> Cale: an IOError?
12:26:37 <applicative> is there an ffi related body of excpetions?
12:27:24 <johnw> applicative: in my experience: SIGABRT and SIGSEGV
12:27:35 <monochrom> I ignore out-of-memory, but you have the choice of exception or nullPtr (in Foreign.Ptr)
12:28:24 <Cale> tulcod: Usually I'd just call error, and let the program die, because there's probably not much that can be done about a condition like that...
12:28:38 <tulcod> ok
12:28:53 <tulcod> well i can also just not deal with it, and eventually have the C lib crash stuff
12:29:07 <arkeet> why not fail early?
12:29:51 <arkeet> monochrom: bah, sodium. that's nothing ;)
12:32:53 * hackagebot phybin 0.1.2.5 - Utility for binning phylogenetic trees in Newick format.  http://hackage.haskell.org/package/phybin-0.1.2.5 (RyanNewton)
12:35:02 <ignacio> is it just me or reddit/hackernews is getting a lot of haskell articles?
12:35:07 <ignacio> *are
12:35:15 <monochrom> I don't read either
12:35:50 <tac> ignacio: There's little periods where people spam haskell in those places.
12:45:47 <ignacio> it's interesting that getArgs has type IO [String] even though the return value is the same for every program run and it has no side effects
12:46:39 <supki> ignacio: not really, see withArgs
12:47:05 <dmwit> The return value is not the same for every program run.
12:47:10 <tac> ignacio: Generally speaking, things initialized at the program's startup end up having an IO-type
12:47:40 <ignacio> I see
12:47:45 <tac> You could cheat and erase it with unsafePerformIO (and some people do this sometimes), but I think it's practice is discouraged
12:48:02 <dmwit> Also, I'm not so confident about "it has no side effects".
12:48:13 <tac> But what you do with IO is between you and your diety.
12:49:09 <shachaf> System.Info.os is also a problem. Should be IO.
12:49:56 <tac> You never know when your process will get serialized, moved to a new computer with a new operating system, and resumed ;)
12:50:24 <Igloo> tac: In that case, the function is completely useless
12:50:29 <ignacio> it's an oversight I'm willing to forgive
12:53:29 <shachaf> Even if it never changes during the runtime of the program it should be IO.
12:54:45 <dmwit> (+) :: Int -> Int -> IO Int
12:55:46 <scshunt> ignacio: it's not pure though. You can't figure out its value until you actually run the program
12:56:31 <shachaf> dmwit: Int :: IO *
12:57:04 <dmwit> Yes, I saw this proposal yesterday. But I don't really know what it means.
12:57:13 <dmwit> I do know what (+) :: Int -> Int -> IO Int means, though.
12:58:01 <tac> (+) should be IO because you might run out of physical memory :P
12:58:30 <tac> or because your computer might crash. Suddenly, the "real world" has effective the outcome of your pure function ;)
12:58:56 <shachaf> dmwit: I don't know what anything that involves IO "means"!
12:59:06 <dmwit> (For example, since we don't have type-level lambda, this means we can't realistically have and use type-level bind. So how would we ever use something of kind IO *?)
12:59:42 <shachaf> It's less of a proposal and more of a joke.
13:00:11 <dmwit> =)
13:00:22 <shachaf> And it's in the context of a dependently types, anyway.
13:00:28 <taylorgb_> Sounds like a bit of a risk if people don't realise that it is a joke
13:00:29 <shachaf> s/ly//
13:00:42 <dmwit> Well, I understand it even less well in a dependently typed language. =P
13:01:10 <dmwit> taylorgb_: I know it's a joke. I was just pissily defending my own joke, which I now realize is a losing strategy. =)
13:01:28 <shachaf> Anyway, I would hope that (+) wouldn't be :: Int -> Int -> IO Int
13:02:43 <dmwit> Well, if you argue that os should have an IO type, then I argue that 2^33 should have IO type for the same reason. =)
13:03:23 <taylorgb_> I think you lose some utility and gain some futility if everything becomes IO
13:03:32 <shachaf> The trouble is with the whole of Int, though.
13:03:44 <dmwit> (That is: I evaluate something in ghci, and then replace a term like that in my program with what ghci spits out. I shouldn't have to check whether "os" gets called anywhere in between to know this is correct. Same argument for 2^33.)
13:07:32 <dmwit> shachaf: I'm pretty happy to agree that (+) isn't special here. You'd need similar modifications to (*), (-), etc.
13:07:52 <dmwit> (re: "whole of Int")
13:08:04 <shachaf> Maybe you need an IO Constraint somewhere in there too.
13:08:07 <shachaf> For good measure.
13:09:46 <stelleg> so I'm struggling with IOUArrays a bit, wondering if someone could clear things up for me
13:10:01 <dmwit> ?where justask ;-)
13:10:02 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:10:14 <stelleg> :)
13:10:41 <tac> ?where Vector
13:10:41 <lambdabot> I know nothing about vector.
13:10:43 <tac> :(
13:10:50 <dmwit> ?hackage vector
13:10:51 <lambdabot> http://hackage.haskell.org/package/vector
13:11:08 <tac> If you have the option, Data.Vector is a little nicer than Haskell's array libraries
13:11:19 <tac> (and by a little, I mean a lot)
13:11:20 <stelleg> The docs for IOUArray say that it takes two type arguemnts i, and e, which are the index type of the array (of class Ix) and the element type of the array
13:11:39 <stelleg> oh wait
13:11:56 <stelleg> instances are left associative?
13:12:04 <monochrom> yes
13:12:05 <dmwit> uh?
13:12:18 <stelleg> so MArray IOUArray Word IO
13:12:38 <monochrom> means MArray has 3 parameters
13:12:40 <stelleg> yes
13:12:44 <stelleg> nevermind then
13:12:45 <stelleg> thanks
13:15:38 <stelleg> still struggling to actually create one though
13:15:43 <stelleg> newArray (1, 10) 5.0 :: IOUArray Int Float
13:15:56 <stelleg> seems like that should work
13:16:14 <aristid> stelleg: is there a specific version you're using array rather than vector?
13:16:43 <monochrom> newArray (1,10) 5.0 :: IO (IOUArray Int Float). you're trapped in IO, remember? :)
13:16:45 <stelleg> aristid: just trying to do a ring buffer for audio in IO
13:17:10 <stelleg> monochrom: doh!
13:17:11 <stelleg> thanks!
13:17:29 <aristid> stelleg: sounds like a task for storable vectors :)
13:17:36 <stelleg> aristid: cool I'll check it out
13:17:45 <stelleg> I got it working with Sequence
13:18:04 <aristid> stelleg: sequence is cool but not exactly a data structure suitable for sound buffers :D
13:18:07 <stelleg> but I think its overwriting the whole vector on writeIORef
13:18:23 <stelleg> aristid: yeah I agree
13:18:35 <stelleg> whole *sequence
13:19:10 <ignacio> trapped in IO: comming this summer
13:19:33 <stelleg> starring ignorant haskell programmer #538
13:19:43 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526421&k=tSKXkj9
13:19:46 <stelleg> me
13:20:55 <bb010g> Anybody here used Monatron?
13:21:21 <dmwit> ?where justask
13:21:21 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:22:46 <elflord> anybody is using Arch and emacs ? my emacs mode is not loaded automatically. the version of my emacs is the default latest
13:23:15 <elflord> i tried M-X packages-install
13:23:24 <elflord> but it couldn't find my emacs mode
13:23:37 <elflord> i've already installed the mode through pacman
13:23:48 <kartoffelbrei> elford: yes, i use both
13:24:06 <edwardk> http://www.gizoogle.net/xfer.php?link=http://www.haskell.org
13:24:12 <kartoffelbrei> what mode exactly?
13:25:14 <dmwit> edwardk: funny =)
13:25:23 <dmwit> I wonder why "specification" becomes "justification".
13:25:29 <dmwit> Those two words are... pretty different.
13:26:16 <edwardk> http://www.gizoogle.net/xfer.php?link=http://www.haskell.org/haskellwiki/Language_and_library_specification If you find a gangbangin' fuck up in tha report, please bust it ta tha haskell-prime mailin list (you gotta regista first), or bust it directly ta one of tha current committee members.
13:28:09 <dmwit> "Da accompanyin text is up in Dutch yo, but tha syntax diagrams is legible up in any language."
13:29:15 <taylorgb_> That would definitely be one way to punch up the language in the report
13:30:36 <taylorgb_> I'm always surprised how short the haskell report is after being used to the C++ standard
13:31:05 <johnw> well, the C++ standard makes Scheme seem like a footnote
13:31:39 <johnw> you know a language standard is big when your publishing department has to break it into two volumes
13:31:50 <Taneb> johnw, isn't Scheme deliberately minimalist?
13:31:51 <taylorgb_> I think the latest draft is about 1400 pages
13:32:03 <taylorgb_> And the committee is looking to split it into two documents pretty soon I think
13:32:06 <johnw> Taneb: does that make C++ deliberately maximalist?
13:32:22 <Taneb> Yeah, why not
13:32:27 <johnw> fortunately, PDFs in my reader are effectively all the same size :)
13:33:08 <joergfritsch> How can a 16bit signed integer (data Int16) represent negative numbers? Wouldn't there be at least one additional bit required to represent the sign?
13:33:28 <dmwit> It represents numbers in the range -(2^15) to 2^15-1.
13:33:32 <ignacio> joergfritsch: yes, 15 bits and one additional bit
13:33:38 <joergfritsch> understand
13:33:43 <joergfritsch> Thanks!
13:33:54 <dmwit> > minBound :: Int16
13:33:55 <lambdabot>   -32768
13:33:56 <ignacio> although it's probably 2's complement so it's a bit more complicated
13:34:15 <dmwit> > 2^15
13:34:17 <lambdabot>   32768
13:34:17 <ignacio> but you really don't care how it's stored inside
13:34:32 <dmwit> You might care, if you use the Bits instance.
13:34:41 <ignacio> :t (.&.)
13:34:42 <lambdabot>     Ambiguous occurrence `.&.'
13:34:42 <lambdabot>     It could refer to either `Data.Bits..&.',
13:34:42 <lambdabot>                              imported from `Data.Bits' at /home/lambdabot/.lambdabot/State/L.hs:51:1-16
13:34:46 <joergfritsch> yes, I just wanted to make usre that it is not using more then 16 bit :D
13:34:51 <ignacio> :t Data.Bits..&.
13:34:52 <lambdabot> parse error on input `Data.Bits..&.'
13:34:55 <ignacio> :t Data.Bits.(.&.)
13:34:56 <lambdabot> Couldn't find qualified module.
13:34:59 <ignacio> :/
13:35:09 <ignacio> :t (Data.Bits..&.)
13:35:09 <lambdabot> Bits a => a -> a -> a
13:35:23 <dmwit> It might reasonably be considered a code smell to mix Bits functions and arithmetic, though. =)
13:35:24 <ignacio> do we have something like :info?
13:35:31 <dmwit> no
13:35:52 <shachaf> Yes, in ghci.
13:36:19 <ignacio>  Int and Integer are Bits, doesn't look like Int16 is an instance
13:36:48 <dmwit> Looks like it's an instance to me.
13:37:03 <dmwit> Prelude Data.Bits Data.Int> 0 .&. 0 :: Int16
13:37:03 <dmwit> 0
13:37:42 <ignacio> yep, hadn't loaded Data.Int
13:42:23 <ignacio__> I've done something terribly wrong
13:42:41 <ignacio> yep, I've completely fucked up
13:42:47 <ignacio__> brb
13:49:29 <jfischoff> has anyone tried this technique with HEAD: http://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
13:49:38 <jfischoff> I'm wondering if it works now….
13:52:58 <ignacio> again with the fancy symbols
13:53:11 <ignacio> what happened to good old iso8859-1
13:53:39 <johnw> what about just good old 7-bit
13:53:55 <ignacio> I like my ás just fine
13:53:57 <johnw> the Apple ][ never induced any confusion; even lowercase was too much
13:54:17 <ignacio> also ñ and ü
13:54:24 <dyn> anyone excited on the fpcomplete competition?
13:54:44 <jfischoff> I'm a little confused by it
13:54:57 <dyn> why?
13:55:12 <johnw> yes, why?
13:55:44 <jfischoff> johnw: Has it started? is there going to a specific problem to solve? Are we to come up with the problem and the solution?
13:55:55 <jfischoff> how is the winner determined?
13:56:13 <johnw> yes, no, yes, by some committee here on our side
13:56:23 <dyn> I believe these are all covered in the introduction here: https://www.fpcomplete.com/business/competition/competition-overview
13:56:34 <johnw> invent a problem that people commonly face, especially in current industry
13:56:41 <johnw> show a typical solution to that problem in Haskell
13:56:44 <johnw> win $$
13:57:25 <Gracenotes> not a solution at scale, but, good for prototyping, say...
13:57:28 <dyn> johnw: you are related to fpcomplete?
13:57:30 <johnw> exactly
13:57:32 <johnw> dyn: yes
13:57:32 <taylorgb_> Would have been quite underhanded to set the challenges to be things that the community needs at the moment
13:57:41 <dyn> cool!
13:58:11 <dyn> I'd like to believe that this competition would bring _lots_ of new tutorial like materials to the masses
13:58:25 <jfischoff> johnw: who owns the code?
13:58:48 <johnw> jfischoff: great question
13:59:01 <johnw> i would expect a BSD-style license would be acceptable, but you'd have to ask to be sure
13:59:12 <johnw> dyn: that's the exact hope we have
14:00:56 <dyn> I was trying to get to know a bit more about fpcomplete (the company) but did not found much
14:00:58 <taylorgb_> It's quite a lot to ask though, finding quite small and self-contained business problems isn't exactly easy. Usually it's the wider business constraints and requirements that makes programs complicated
14:01:08 <ignacio> does ghci have something like @undo ?
14:01:22 <johnw> taylorgb_: think of the devops community; there's LOTS of examples there
14:01:28 <chrisdone> it doesn't afaik, but the repl package on hackage does
14:01:30 <chrisdone> @undef or so
14:01:31 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:01:37 <dyn> johnw: oh, also, some 'lessons learned' like articles about the online IDE would be very interesting to read
14:01:40 <johnw> one area Haskell hasn't really focused on is deployment and live-debugging scenarios (example: the ekg package)
14:01:54 <dyn> johnw: (assuming there were lessons learned on the way..)
14:02:05 <taylorgb_> I don't think devops are the people you have to convince though, as they usually have a lot of free reign on what they use
14:02:08 <johnw> dyn: I think we may well write that once the release is out
14:02:25 <taylorgb_> and often solve very different problems to general enterprise
14:02:54 * hackagebot geek 1.0.0.6 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.6 (JinjingWang)
14:03:14 <yesthisisuser> what if I have two Maybe String and want to do (++) <$> Just "abc" <*> Just "def" .. but if only one of the values is Nothing, the result is the other value
14:03:22 <Clint> As a condition of entry, all Entries must be released by the Participant under the open BSD license, and Participant grants FP Complete a perpetual, irrevocable, worldwide, royalty-free, and non-exclusive license to use, reproduce, adapt, modify, publish, distribute, publicly perform, and publicly display and promote any Entry that Participant submits to this Competition unless the Entry is explicitly rejected by FP Complete.
14:03:29 <Clint> i wonder what "the open BSD license" is
14:03:49 <johnw> yesthisisuser: this question has been asked before, actually
14:04:30 <johnw> yesthisisuser: liftM2 f a b <|> a <|> b
14:05:34 <stelleg> anyone know how to do mutable operations on an array in stm?
14:05:47 <stelleg> or a vector for that matter
14:05:49 <jfischoff> johnw: if you guys picked a problem I would be more interested in competing
14:06:24 <johnw> jfischoff: that's very interesting to hear; but I think the idea was for the community to pick teh problem so that we'd have lots of different solutions to showcase, rather than many solutions to a single problem
14:06:35 <jfischoff> johnw: and people could see my solution and the winner less subjective way
14:06:49 <dmwit> stelleg: I guess you would need an STMArray. Dunno of such a thing. Why do you want it?
14:06:56 <yesthisisuser> johnw: thanks! exactly what i was looking for
14:06:58 <monochrom> stelleg: stm doesn't have any array. do it in ST or IO. you may use vector or IOArray, IOUArray, STArray, STUArray
14:07:12 <jfischoff> johnw: my guess is fp complete knows what problems to solve better than I do
14:07:23 <dyn> jfischoff: I think the way they are starting it is much more approachable for the masses
14:07:49 <monochrom> yikes, I'm wrong, stm has an array, it's in Control.Concurrent.STM.TArray
14:07:59 <dyn> jfischoff: as an absolute haskell noob myself, I wouldn't even think into the competition that way
14:08:25 <stelleg> dmwit: I have multiple threads reading and writing from a large array
14:08:27 <johnw> this isn't a contents for "best solution to problem X", it's a contest for "most helpful/applicable/denomstrative solution to (some) common problem"
14:08:32 <johnw> s/contents/contest
14:08:36 <monochrom> oh haha it is currently just Array i (TVar e) :)
14:08:48 <stelleg> monochrom: oh cool thanks
14:08:50 <dmwit> stelleg: Well, I gathered that much. =)
14:09:21 <monochrom> it may or may not be fast enough, but sure give it a try
14:09:22 <stelleg> monochrom: ah I guess that makes sense
14:09:23 <stelleg> yeah
14:09:27 <dmwit> monochrom: Oh, cute. Actually, I guess that's pretty much what I would want anyway, huh?
14:09:30 <jfischoff> johnw: sure but can't you pick the common problem?
14:09:44 <jfischoff> or put it to a vote
14:09:45 <monochrom> well, at least it has the desired semantics
14:09:46 <johnw> we'd have to pick many to get the result we want
14:09:57 <Gracenotes> I expect that things coming out of this contest won't be the basis of a useful library.
14:10:02 <jfischoff> I think it is just going to lead to a lot of unfocused work
14:10:02 <ignacio> submittion = 42
14:10:03 <Gracenotes> Libraries require more thought, less hacking.
14:10:22 <johnw> i bet you could just look for any Java library that people like which Haskell doesn't have an answer for, and show how the problem being solved by that library can be done in Haskell, and it would be a great candidate
14:10:24 <Gracenotes> However, it shows that you can use existing libraries with great code organization, efficiency, and safety.
14:10:29 <jfischoff> I would prefer if people were actually solving a useful problem and the community gets to pick the one they like the best
14:10:37 <Gracenotes> Or, hopefully it will.
14:11:05 <johnw> jfischoff: the community can have a contest like that any time they want
14:11:30 <dmwit> jfischoff: Perhaps pick something from haskell_proposals.reddit.com or similar.
14:11:31 <stelleg> monochrom: its a bit different from what I want actually
14:11:35 <Gracenotes> Lots of people don't know that Haskell is a general-purpose programming language. Let alone our conundrums with e.g. HTML parsing or whatever.
14:12:00 <stelleg> monochrom: I have one thread that can completely replace the array
14:12:06 <jfischoff> johnw: I would like to look at a problem, and be like "I know how to solve that with Haskell very quickly"
14:12:17 <dmwit> stelleg: TVar (TArray i e), then.
14:12:18 <stelleg> and then another that is very often modifying elements in the array
14:12:25 <johnw> jfischoff: then surf the web and find some problems that fit that description!
14:12:36 <johnw> we're paying you to do some of the legwork here :)
14:12:42 <johnw> (potentially paying you)
14:12:46 <monochrom> oh, dmwit's sounds good
14:12:56 <tuxit> jfischoff: or scratch an itch ;-)
14:13:35 <dmwit> hm
14:13:46 <stelleg> dmwit: do you think that will do mutable updates to the TArray though?
14:13:55 <stelleg> if it's inside a TVar?
14:14:09 <monochrom> it does. it has two levels of mutation by design.
14:14:15 <dmwit> johnw: I wonder, are people allowed to make multiple submissions in a single month? How many months will you be running this contest (if you know)?
14:14:17 <jfischoff> johnw: I guess that is the fundemental problem. The leg work is not that interesting and the money is not that good. If there was some way my code would be visible and promoted win or loss I would be more interested.
14:14:37 <dmwit> stelleg: Not sure I understand the question yet.
14:15:03 <johnw> dmwit: yes to multiple submissions, although I think you can only win once in a given month; as for how many months, I suppose it will depend on how useful an exercise it is.  If it keeps producing compelling tutorials/examples each month, I don't see why it wouldn't continue indefinitely
14:15:04 <stelleg> dmwit: so modifying a TVar requires reading said TVar then writing it
14:15:48 <stelleg> dmwit: so I would wonder if writing the TArray back would write the "mutation" or the whole array back into the TVar
14:15:51 <stelleg> does that make sense?
14:16:21 <dmwit> And what's the policy on already-released content? e.g. dmwit.com/volume is already a tutorial; dmwit.com/yeganesh already has the code but I could add a tutorial; dmwit.com/square is sitting on my hard drive half-finished
14:16:51 <johnw> jfischoff: then I'd have to say: spend your time when your interest lies.  If the terms of the contest are not attractive, either submit your ideas for how to make it more so to our business people, or seek out better problems to solve :)
14:17:17 <johnw> we'll never satisfy everyone, that's just a given
14:17:21 <dmwit> stelleg: not really
14:17:46 <dyn> johnw: did you already start receiving submissions?
14:18:05 <johnw> dyn: I haven't heard yet; that's not my area
14:18:21 <johnw> I think Mike Meyers is focused on reading/evaluating those submissions
14:18:37 <dyn> I wonder if many applicants would finish till the 1st of Aug
14:18:58 <dyn> but I hope things will get warm up pretty soon then
14:19:01 <johnw> I don't think length is necessarily a winning factor on these
14:19:15 <jfischoff> johnw: no doubt, but my suggestion A/B test with a more specific request and a shorter time limit. You might get more/better submissions.
14:19:16 <dmwit> Aha, the page actually answers that question.
14:19:18 <johnw> I have a feeling somebody is going to show off aeson-lens and win in very few linse, but that's just a guess
14:19:26 <johnw> (or lens-aeson)
14:19:32 <dmwit> "Entries may be based on new or pre-existing code, as long as they haven't been published before."
14:19:43 <dmwit> So square is in, but volume and yeganesh are out.
14:19:53 <tac> drostie: Perhaps this might be interesting to you: http://bentnib.org/conservation-laws.pdf
14:19:56 <dyn> jfischoff: there'd be quite a few almost-the-same solutions that way
14:20:05 <lpaste> monochrom pasted “Two Towers” at http://lpaste.net/91064
14:20:07 <dyn> jfischoff: and much less to learn at the end for the public.. (imho)
14:20:26 <drostie> tac, this is #haskell. :P
14:20:26 <monochrom> stelleg: see my paste above, i.e., http://lpaste.net/91064
14:20:50 <monochrom> oops, there is a typo
14:20:58 <tac> drostie: That's a paper on parametricity of type theory and its relation to conservations laws in physics
14:21:15 <lpaste> monochrom revised “Two Towers”: “Two Towers” at http://lpaste.net/91064
14:21:22 <drostie> okay, then I'll read it in #haskell. :P
14:21:29 <monochrom> typo fixed, same url :)
14:21:48 <stelleg> monochrom: cool thanks, so you think the small update is O(1)?
14:22:01 <monochrom> chrisdone++  in-place edit superpower :)
14:22:04 <monochrom> yes
14:22:35 <drostie> tac: I'd like to also do differential geometry in Haskell syntax but it does get a little onerous. :<
14:22:46 <supki> johnw: I would be surprised. lens-aeson is like half a year old and aeson-lens is even older
14:22:56 * hackagebot GLFW-b-demo 1.0.2 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.2 (BrianLewis)
14:23:00 <dmwit> err, hm
14:23:03 <monochrom> hmm, there is also an MVar story, and it may be even slightly faster
14:23:05 <tac> drostie: do you know about synthetic differential geometry?
14:23:10 <dmwit> The official rules are worded oddly.
14:23:15 <johnw> supki: it's just that dynamically parsing aeson to grab out the bits you need (like, using a biplate to snarf out all the strings) would just be sooo cool
14:23:47 <dmwit> "Content and code previously published and available in the public domain or commercial products are not eligible for prizes." <- does this mean code previously published under BSD *is* eligible?
14:23:49 <drostie> tac: the best candidate I've seen so far was presented by Roger Penrose in /Spinors and Space-Time/, where he covers his "abstract index notation" for making geometric expressions look like Einstein summations
14:23:52 <dmwit> johnw: ?
14:24:05 <drostie> but it's still a bit messy to write down as function applications in Haskell.
14:24:29 <drostie> tac: I probably don't know much about it. :D
14:24:37 <S_J> > let f x xs = x:xs in f 1 [1]
14:24:38 <lambdabot>   [1,1]
14:24:40 <Gracenotes> dmwit: I'd imagine the problem selection and judging of entries will make that issue effectively nil, though
14:24:57 <S_J> @type append
14:24:57 <lambdabot>     Not in scope: `append'
14:24:57 <lambdabot>     Perhaps you meant one of these:
14:24:57 <lambdabot>       `BSC.append' (imported from Data.ByteString.Char8),
14:25:16 <tac> http://www.math.ias.edu/~mshulman/papers/sdg/pizza-seminar.pdf <-- drostie. It's an approach to infinitesimal calculus that works very nicely.
14:25:29 <tac> Without appeals to notions of "approximately equal"
14:25:39 <stelleg> monochrom: cool thanks, just playing around with that now
14:26:09 <S_J> > let append a [] = [a]; append a (x:xs) = x : append a xs in append 5 [1,2,3]
14:26:10 <lambdabot>   [1,2,3,5]
14:26:48 <S_J> > let append a [] = [a]; append a (x:xs) = x : append a xs in [append 5 [1,2,3], append 1 [], append 3[1]]
14:26:49 <lambdabot>   [[1,2,3,5],[1],[1,3]]
14:26:55 <dmwit> Gracenotes: I dunno. I have a bunch of code on github that I'd love to be paid $1000 to complete and tutorialize.
14:27:08 <dmwit> (and similar places)
14:27:58 <danr> @type (++)
14:27:58 <lambdabot> [a] -> [a] -> [a]
14:28:04 <danr> S_J: ^ ?
14:28:27 <dmwit> ...and which would form the basis of a useful tutorial for the wider community.
14:30:02 <volitek> If I have a list like [True, False, False, True, False, False, True, False, False, False] How do I take all the Falses from the end up until the first True?
14:30:29 <monochrom> perhaps reverse the list first
14:30:48 <volitek> sure, but its the other bit I don't get how to do
14:30:52 <monochrom> even better, perhaps use another data structure altogether
14:30:55 <dmwit> "dropWhile not" will remove everything before the first True.
14:31:20 <volitek> dmwit: thanks, just what I'm looking for
14:31:21 <monochrom> reverse . dropWhile not . reverse
14:31:37 <dmwit> I think you want to dropWhile not before you reverse.
14:31:42 <dmwit> Then do something more after you reverse.
14:31:52 <monochrom> err, dropWhile? takeWhile?
14:31:59 <dmwit> reverse . filter not . reverse . dropWhile not -- perhaps
14:32:23 <dmwit> Or maybe I misinterpreted the question.
14:32:25 <volitek> Let's imagine the list was reversed already, it was just an example
14:32:36 <volitek> How would I do it inclusively?
14:32:44 <dmwit> For [True, False, True, False], would you like to get [False, False] out, or just [False]?
14:32:52 <dmwit> or [False, True, False]?
14:32:54 <volitek> So if its [False, False, True, False, True] I want to return [False, False, True]
14:33:04 <dmwit> you... what?
14:33:11 <volitek> if its already reversed
14:33:35 <dmwit> > break id [False, False, True, False, True]
14:33:37 <lambdabot>   ([False,False],[True,False,True])
14:34:02 <dmwit> What should it do on [False, False, False]?
14:34:11 <drostie> tac: I <3 you. :D
14:34:37 <Dodek> 4
14:34:57 <volitek> dmwit: return the whole list, but that shouldnt happen
14:35:11 <volitek> the actual case im thinking of is a series of betting in poker
14:35:18 <tac> drostie: don't mention it :P
14:35:32 <volitek> i want all the actions after the last raise or blind inclusive
14:35:40 <dmwit> You'll have to use break or something like it, then.
14:35:45 <volitek> okay, thanks
14:35:49 <volitek> i didnt know about break
14:36:41 <supki> if you know you always have True you can just \xs -> takeWhile not xs ++ [True]
14:37:03 <dmwit> Yes, such an idea is why I asked about what to do with [False, False, False].
14:37:33 <dmwit> If [False, False, False, True] is an okay output, then you can use supki's thing, which will be ever-so-slightly simpler than doing a break and pattern matching.
14:39:20 <volitek> ah, supkis thing wont work because this was just a simple example, imagine it's (True, 7) or (True, 3) and I need the number
14:39:28 <volitek> but yeah break does the job
14:39:30 <volitek> thanks
14:44:39 <S_J> @type catMaybe
14:44:40 <lambdabot>     Not in scope: `catMaybe'
14:44:40 <lambdabot>     Perhaps you meant one of these:
14:44:40 <lambdabot>       `catMaybes' (imported from Data.Maybe),
14:44:43 <S_J> @type catMaybes
14:44:43 <lambdabot> [Maybe a] -> [a]
14:45:01 <dmwit> johnw: In any case, thanks for talking about this competition. It looks like a lot of fun and I hope it goes for at least two more months. =)
14:46:15 <dyn> +1
14:46:25 <johnw> dmwit: thanks, me too :)
14:46:38 <dmwit> Hum, I wonder what other structures t have a reasonable t (Maybe a) -> t a function.
14:46:50 <S_J> > let sl (x:xs) = (x + (fst $ sl xs), 1 + (snd $ sl xs)); sl [] = (0,0); in sl [1,2,3]
14:46:50 <lambdabot>   (6,3)
14:47:19 <S_J> that is 2N right?
14:47:34 <dmwit> :t \xs -> xs >>= maybe mzero return
14:47:36 <lambdabot> MonadPlus m => m (Maybe b) -> m b
14:48:08 <S_J> > let sl (x:xs) = (x + (fst $ sl xs), 1 + (snd $ sl xs)); sl [] = (0,0); in curry (/) $ sl [1,2,3]
14:48:08 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b1)
14:48:09 <lambdabot>    arising from a use ...
14:48:17 <dmwit> S_J: 2N?
14:48:32 <S_J> > let sl (x:xs) = (x + (fst $ sl xs), 1 + (snd $ sl xs)); sl [] = (0,0); in $ sl [1,2,3]
14:48:32 <byorgey> dmwit: but since MonadPlus is basically a higher-kinded Monoid, and free monoids are lists...
14:48:33 <lambdabot>   <hint>:1:75: parse error on input `$'
14:48:40 <S_J> how do i apply f a b to a tuple?
14:48:44 <S_J> @type curry
14:48:45 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:48:48 <S_J> @type uncurry
14:48:48 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:49:03 <S_J> > let sl (x:xs) = (x + (fst $ sl xs), 1 + (snd $ sl xs)); sl [] = (0,0); in uncurry (/) $ sl [1,2,3]
14:49:03 <lambdabot>   2.0
14:49:26 <S_J> > let sl (x:xs) = (x + (fst $ sl xs), 1 + (snd $ sl xs)); sl [] = (0,0); in uncurry (/) $ sl [1,2,3,4]
14:49:27 <lambdabot>   2.5
14:49:43 <byorgey> conclusion: MonadPlus is not the right generalization, if you want to find some interesting structures which support that operation which are not essentially isomorphic to lists
14:49:43 <dmwit> byorgey: Therefore [] is better than any MonadPlus? Or?
14:49:44 <S_J> dmwit; O(2N)
14:50:03 <dmwit> If arithmetic is O(1), then yes.
14:50:29 <dmwit> byorgey: But surely MonadPlus instances can have more structure than the free instance.
14:50:47 <dmwit> "free" essentially means "least structure", doesn't it?
14:50:53 <S_J> so youd have to do it with another function to achieve 1N ? no wait you foldl *forepaint smack*
14:51:01 <dmwit> eh?
14:51:08 <dmwit> S_J: O(n) = O(2n)
14:51:23 <S_J> dmwit: yeah i know but you know what i mean
14:51:28 <S_J> do you write T(2N) ?
14:51:45 <dmwit> I don't see why foldl would be better.
14:51:51 <dmwit> And I'm very amused by "forepaint". =D
14:51:58 <dyn> generally, is it a better idea to install haskell libraries via my system package manager (on arch linux) or use cabal or..?
14:52:16 <dmwit> dyn: I manage all my own Haskell stuff independent of my package manager.
14:52:17 <S_J> > foldl (\(s,l) x -> (s+x,l+1)) (0,0) [1,2,3,4]
14:52:18 <lambdabot>   (10,4)
14:52:25 <S_J> isnt that just 1 traversal
14:52:36 <dmwit> Yes. So is sl.
14:52:44 <dyn> dmwit: with cabal?
14:52:48 <S_J> > let sumlen = foldl (\(s,l) x -> (s+x,l+1)) (0,0) in sumlen [1..4]
14:52:49 <lambdabot>   (10,4)
14:52:51 <dmwit> dyn: yes
14:52:58 <S_J> > let sumlen = foldl (\(s,l) x -> (s+x,l+1)) (0,0) in uncurry (/) $ sumlen [1..4]
14:52:59 <lambdabot>   2.5
14:53:14 <byorgey> dmwit: it depends on how you look at it.  I would say "free" means "most structure".  At least it is "most information-preserving".
14:53:35 <dmwit> yes
14:53:40 <byorgey> since there has to be a homomorphism *from* the free instance *to* any other instance.
14:53:46 <dmwit> right
14:54:10 <zacts> I want to reimplement standard UNIX commands in haskell
14:54:19 <stelleg> monochrom: awesome, convinced myself that you are right about the nested TVars
14:54:21 <stelleg> thanks a lot!
14:54:22 <zacts> how much would this slow down my programs if using ghc?
14:54:35 <monochrom> it is dmwit's idea. thank him too!
14:54:40 <byorgey> zacts: by precisely 3.7 zots
14:54:40 <dmwit> I'm not sure I can think of a more exciting type than [] that has a reasonable "remove any hole you like" operation, though.
14:54:44 <stelleg> thanks dmwit!
14:54:53 <chrisbuchholz> What library should i look into for watching for changes in a file/directory? I have looked at kqueue and hinotify, but theres not much info about them, so id like to hear some opinions about them and maybe other libraries
14:54:56 <dmwit> stelleg: cheers! =D
14:55:06 <byorgey> dmwit: I can't either.
14:55:28 <zacts> byorgey: I mean would it most likely be a noticable speed decrease?
14:55:57 <dmwit> zacts: The rule of thumb used to be 50-100% slowdown when moving from idiomatic C to idiomatic Haskell.
14:56:16 <zacts> ok, interesting
14:56:17 <dmwit> Of course, I think GHC has improved since then. Probably gcc has, too. And probably the standard Unix tools are not idiomatic C.
14:56:41 <zacts> well, I want to start a C->haskell unix project just for fun anyway
14:56:49 <dmwit> That sounds like a capital idea!
14:57:01 <johnw> chrisbuchholz: I know that Yesod and git-annex both use a more general library
14:57:06 <johnw> can't remember the name
14:57:27 <chrisbuchholz> johnw: will google around a bit for it, thanks
15:04:15 <dyn> I'm trying to follow the attoparsec tutorial at https://www.fpcomplete.com/school/attoparsec
15:04:35 <dyn> and get a compile error: Couldn't match expected type `Data.ByteString.Internal.ByteString' with actual type `[Char]'
15:04:44 <dyn> any idea what mistake I made?
15:05:35 <CADD> dyn: you are putting a string where you should be putting a bytestring
15:05:39 <Cale> dyn: You might've missed a conversion between String and ByteString, or used the wrong version of an IO primitive
15:06:09 <k00mi> dyn: you probably forgot the OverloadedStrings extension
15:06:29 <dyn> k00mi: that's the one :)
15:06:56 <dyn> CADD, Cale: I understood the message but failed to see where the whole `Data.ByteString.Internal.ByteString' might come from
15:07:22 <Cale> That's the fully qualified name of the type of strict ByteStrings
15:07:22 <CADD> dyn: kk, best of luck with your project!
15:08:41 <Cale> The Data.Attoparsec.Char8 module exports type synonyms and various functions for working with ByteStrings of that type
15:08:59 <Cale> for instance,  parseOnly :: Parser a -> ByteString -> Either String a
15:09:23 <dyn> > :t parseOnly
15:09:24 <S_J> C to haskell? whyyyy!?
15:09:25 <lambdabot>   <hint>:1:1: parse error on input `:'
15:09:30 <dyn> :t parseOnly
15:09:31 <lambdabot> Not in scope: `parseOnly'
15:09:36 <dyn> ah right
15:10:00 <dyn> ok, I see, it's Parser a -> ByteString -> Either String a
15:10:38 <dyn> Cale: and what does exactly OverloadedStrings give in that situation?
15:10:52 <Cale> dyn: So if that string literal you're passing as a parameter wasn't automatically converted by the OverloadedStrings extension, you'd have to apply Data.ByteString.Char8.pack to it
15:11:12 <Cale> Otherwise, it's just a String, which is a list of Char
15:11:21 <dyn> so it's a kind of automatic conversion between [Char] and ByteString?
15:11:26 <dyn> okay
15:11:53 <dyn> and technically it's a language extension? added by a module?
15:12:20 <Cale> Yeah, it automatically applies fromString :: (IsString a) => String -> a to string literals
15:12:25 <dyn> for now it reminds me a bit of scala's implicit conversions
15:12:48 <Cale> similarly to how there's an automatic application of  fromInteger :: (Num a) => Integer -> a  to integer literals
15:13:25 <dyn> ok, thanks!
15:13:29 <Cale> So, your string literals become polymorphic with that extension
15:14:08 <Cale> (i.e. they're secretly functions of that conversion, and the compiler supplies the right one at the point in the code where the concrete type is pinned down)
15:14:41 <dyn> Cale: it sounds identical to the implicit conversions I mentioned
15:14:44 <dyn> (in scala)
15:15:18 <Cale> It's not quite like that
15:15:28 <dyn> what's the difference?
15:15:54 <Cale> If OverloadedStrings is turned on, then you'll see things like  "foo" :: (IsString a) => a
15:16:09 <johnw> I do love OverloadedStrings
15:16:32 <Cale> Then suppose you have:
15:16:42 <Cale> f :: Text -> Int
15:16:49 <Cale> f x = Text.length x
15:17:04 <Cale> You couldn't write:
15:17:08 <Cale> f :: Text -> Int
15:17:22 <Cale> f x = Data.ByteString.length x
15:17:43 <Cale> There's no implicit conversion between different types of String
15:17:49 <Cale> it's just that literals are polymorphic
15:18:01 <shachaf> ByteString doesn't have a legitimate IsString instance anyway.
15:18:29 <Cale> So while you'd be able to write f "foo" regardless of whether f is meant to take a Text or ByteString or String
15:18:48 <Cale> You'll still have to explicitly convert between things of a specific type.
15:18:56 <shachaf> Now try f :: [a] -> Int; f = length, and then writing f "foo". :-(
15:19:00 <dyn> I have to think about that
15:20:05 <Cale> It's just that "foo" is desugared to (Data.String.fromString "foo"), where the "foo" in the second case is explicitly a String (i.e. a list of Char)
15:20:09 <monochrom> the next big thing is overloaded list
15:27:04 <mikeplus64> monochrom: any idea of its status? i read some mailing list thread about it a while ago, but haven't seen anything since
15:27:30 <monochrom> no idea. not following.
15:27:58 <monochrom> uninterested in all those new-fangled overloaded-everything
15:29:10 <mikeplus64> monochrom: well, it's kind of interesting in the aspect of maybe not having to go through a fromList function
15:29:27 <mikeplus64> i found fromList to be a big bottleneck in some hmatrix functions
15:30:09 <monochrom> did you know: overloaded list simply means inserting "fromList" behind your back
15:30:45 <monochrom> the presence of a fromList bottleneck is independent of who wrote it, human or computer
15:30:46 <mikeplus64> yeah, but there was talk about having a primitive array type
15:30:51 <shachaf> monochrom: But I want overloaded HList!
15:31:04 <johnw> or overloaded DList
15:31:10 <shachaf> ?
15:31:22 <johnw> wouldn't it mean I could interact with DLists using plain list syntax?
15:31:40 <johnw> i've not read the full proposal, so don't mind me
15:31:44 <monochrom> the next next big thing is overloaded lambda abstraction and overloaded function application
15:31:50 <shachaf> Not a big fan of that overloading, but sure. But you can get that with plain old fromList.
15:32:06 <shachaf> edwardk already overloads function application.
15:32:10 <johnw> OverloadedGrammar
15:32:42 <monochrom> "space, the final frontier", where "space" refers to function application :)
15:32:42 <mikeplus64> monochrom: if there is no "primitive array type", like there is a primitive string type already, then no it's not a big win at all
15:34:36 <monochrom> haskell 2137 will support overloaded ::
15:34:50 <johnw> will it let me swap the meaning of :: and :?
15:35:01 <monochrom> yes, but that's quanit
15:35:10 <monochrom> s/quanit/quaint/
15:36:55 <dmwit> Will it let me write "foo :<: Foo a b" to mean "there's some instantiation of a and b for which foo :: Foo a b"?
15:37:53 <monochrom> I don't know. I don't fully understand overloaded ::, it's more than a century beyond me :)
15:45:09 <Zenol> 2137?
15:45:42 <monochrom> is a prime number :)
15:46:00 <Zenol> >.<
15:46:15 <Zenol> I alwais count modulus 2.
15:46:22 <sipa> not in base 8
15:48:26 <shachaf> 2999 is a prime number.
15:50:33 <sipa> frequently
15:53:11 <sipa> at least in base 10 and base 17
15:54:03 <FreeFull> There is no base where 4 is a prime
16:06:13 <Redz> hello,
16:06:13 <Redz> i have a handle from a socket and now i want to read all available data, but i cant find a function that give me the data or tells me the size of available data. just want to read non-blocking. know someone how to do this?
16:06:39 <shachaf> Why do you want to "read non-blocking"? Or, what do you mean by that?
16:07:59 <thoughtpolice> preflex: seen nominolo
16:07:59 <preflex>  nominolo was last seen on #haskell-infrastructure 1 day, 5 hours, 38 minutes and 49 seconds ago, saying: At work we're using mostly a bunch of CNAME and A records
16:08:16 <Redz> non-blocking means, i dont need threads for multiple connections.
16:08:47 <shachaf> The answer is: Use threads.
16:09:18 <shachaf> I recommend reading the FAQ.
16:09:21 <shachaf> http://www.haskell.org/haskellwiki/FAQ#Concurrency_and_parallelism
16:10:04 <Redz> i cant. i need to catch data from handles and send this to one handle. i cant let them send the same time.
16:11:34 <shachaf> I suspect that threads and concurrency are the answer to your problem.
16:11:34 <johnw> Redz: you can use a channel to serialize input from multiple threads to a single actor thread
16:12:40 <johnw> and I think shachaf is right, you should listen to him
16:13:00 <Redz> Control.Concurrent.Chan ?
16:13:13 <johnw> that, or Control.Concurrent.STM.TChan
16:13:22 <johnw> i'd probably use the latter until I knew I needed the former
16:13:47 <shachaf> Chan is good and it might be the answer to your problem.
16:13:58 <shachaf> But without knowing what your problem is I couldn't say for sure. :-)
16:14:45 <shachaf> But I say that if you have a "threads are bad" sort of attitude, you should probably abandon it.
16:15:11 <shachaf> It won't help you write Haskell code. You should know how concurrency works in Haskell, even if you end up not using it.
16:17:43 <Redz> yes, i dont like threads, but i worked with them earlier for other network stuff. ;)
16:18:02 <johnw> threads in Haskell don't deserve the same stigma that they have in some other languages
16:18:09 <Cale> Redz: Why don't you like threads? They're much more natural than non-blocking IO
16:18:18 <johnw> in Haskell they are very lightweight, and with STM quite easy to work with
16:18:21 <shachaf> Redz: Did you read the FAQ section I linked to?
16:18:35 <Cale> You could also potentially use the async package, depending on what you want to do.
16:18:36 <johnw> and the 'async' library is wonderful to use
16:18:39 <Redz> shachaf: not now.
16:19:04 <shachaf> Hmm. Well, it says pretty much the same thing people are saying in this channel.
16:19:20 <shachaf> So you would do better to read it than to read this channel. :-)
16:21:05 <josephle> I wonder if you can be morally terrible and use async/control.concurrent.chan to implement a smalltalk object system
16:23:55 <Redz> i expected that i never need threads in haskell, before i started learning. but the automatic threaded support of the compiler works not as i expected. ;)
16:31:05 <johnw> automatic threaded support?
16:31:29 <Redz> i mean ghc -threaded
16:31:41 <johnw> do you mean that you thought GHC would make code automatically parallelized?
16:32:23 <Redz> i wish, it could.
16:32:49 <johnw> so do computer researchers everywhere, I imagine
16:33:37 <m3ga> haskell does make parallelization of some code easier, but its not automatic.
16:34:15 <johnw> Redz: having written concurrent algorithms in many language, I can tell you that Haskell has been the best experience so far, hands down
16:34:52 <Redz> the best is not enough. sometimes. :p
16:35:12 <johnw> if the best is what I have, it's what I use
16:37:02 <Redz> haskell is the best. but i can imagine things, which could be better.
16:40:04 * tabemann is thinking of implementing a Scheme (probably R5RS) in Haskell for the hell of it, but is wondering about just how to manage mutability without making just about everything an IORef or STRef...
16:40:33 <jmcarthur_mobile> I find threads and blocking calls much easier to use than nonblocking calls in one thread.
16:40:49 <ignacio> does writing block?
16:40:49 <jmcarthur_mobile> What's wrong with refs?
16:41:27 <tabemann> jmcarthur_mobile: it means that I can't use the Scheme from within pure Haskell
16:42:10 <jmcarthur_mobile> ignacio: the GHC io manager uses nonblocking under the hood for efficiency but they appear to block from your point of view
16:42:41 * tabemann is used to writing IO code using nonblocking calls and select() or poll() in other languages, but it seems like that is completely unnecessary in Haskell
16:42:43 <jmcarthur_mobile> IO and ST are pure too.
16:43:22 <shachaf> "pure" doesn't mean a whole lot.
16:43:31 <ignacio> in the sense that hiring a hitman doesn't make you a murderer
16:43:33 <tabemann> jmcarthur_mobile: I mean that Haskell code calling into Scheme would have to be within the IO or ST monad itself
16:43:41 <jmcarthur_mobile> It means a lot, just different things to different people.
16:44:13 <jmcarthur_mobile> tabemann: well, ST is designed not to require that, specifically
16:44:29 <jmcarthur_mobile> Unless you need to interleave
16:45:01 <jmcarthur_mobile> tabemann: you could always use a state monad thing, but it's still a monad. Not that I think that's such a bad thing
16:45:08 <tabemann> I'd want to be able to make arbitrary calls between Haskell and Scheme while preserving Scheme state across calls
16:45:32 <zacts> in haskell is all data represented by functions?
16:45:40 <tabemann> zacts: no
16:46:01 <tabemann> thunks are not functions because they behave differently when evaluated (aside from not taking arguments)
16:46:46 <zacts> interesting.. just asking newbie questions. I'm learning scheme first, and then haskell next after that.
16:46:54 <zacts> back to my reading..
16:47:10 <tabemann> jmcarthur_mobile: I might just use the IO monad anyways, just in case any code within any series of calls between Haskell and Scheme needs to talk to the outside world
16:47:23 <monochrom> there is no thunk in the haskell reports
16:48:01 <zacts> tabemann: what project are you working on exactly that utilizes both scheme and haskell?
16:48:05 <jmcarthur_mobile> The line is blurry in GHC, but it doesn't naively work that way
16:48:14 * tabemann tends to mean GHC Haskell when he said "Haskell", not Haskell 98 or Haskell 2010
16:48:36 <zacts> oh I see
16:48:41 * zacts greps backlog
16:48:53 <zacts> a scheme interpreter in haskell
16:48:59 <tabemann> zacts: I'm bored and need a project, and it'd be nice to have Scheme available as use as a scripting language from within Haskell, and effective use of it as a scripting language therefor means supporting arbitrary calls between Haskell and Scheme
16:49:03 <shachaf> jmcarthur_mobile: If you want to avoid all monads, you're going to have a hard time writing Haskell code.
16:49:03 <tabemann> yes
16:49:15 <shachaf> Functions are pretty important, for instance.
16:49:47 <zacts> cool!
16:50:49 <tabemann> I've seen tutorials that basically describe creating a mini-Scheme in Haskell, but for something to be a useful scripting language it ought to be at least full R5RS (R6RS and R7RS are controversial, of course)
16:51:13 <tabemann> and R5RS support doesn't seem like it should be too much, since R5RS is only 50 pages long
16:52:47 <tabemann> okay
16:53:23 <tabemann> of *course* you would need to have some monad crossing calls from Scheme to Haskell to Scheme, to be able to copy Scheme state from the outer Scheme to the inner Scheme, and that is even if there were no IO and no mutable state
16:56:42 <tabemann> dammit - the name "hascheme" is already taken for, obviously, a scheme interpreter written in haskell (I wonder how many people have done this project before)
16:57:11 <tabemann> as is "haScm"
16:57:48 <zacts> hakscm
16:58:04 <b2coutts> is recursion possible in a lambda?
16:58:04 <aristid> tabemannhaskellscheme
16:58:05 <tabemann> as is "haskeme"!
16:58:37 <zacts> schaskell
16:58:44 <aristid> tabemann: sorry man, it's way too popular a product for you to get one of the catchy names! ;)
16:58:50 <aristid> -product+project
16:59:06 <b2coutts> tabemann: if you write a racket interpreter instead, it could be called "Raskell"
16:59:27 <tabemann> racket is too massive of a project to just make into a little haskell-embeddable scripting language
16:59:48 <b2coutts> well, some subset of racket anyway
17:00:09 <b2coutts> implementing ALL of scheme would probably be kind of tedious as well
17:00:24 <b2coutts> (I don't actually know the spec for scheme well enough to know how tedious it would be)
17:00:27 <tabemann> okay "scmhs" is not taken
17:00:39 <tabemann> the R5RS standard, which I am going to be using, is *small*
17:00:41 <tabemann> it's 50 pages, total
17:00:43 <zacts> b2coutts: that's the name of my cat "Raskell"
17:00:57 <b2coutts> tabemann: woah
17:01:46 <b2coutts> "every program is brackets, and also the brackets can contain brackets"
17:02:59 <tabemann> the part that makes scheme a little more tedious to implement in Haskell is that it actually has lots of mutable state, even if it gently dissuades the user from not mutating it
17:03:27 <tabemann> (e.g. the convention of marking all mutating functions with a ! at the end)
17:04:13 <tabemann> at least the one Scheme-tutorial in Haskell I saw just glossed over this by, IIRC, just not including mutable state
17:05:15 <b2coutts> I've never actually written a full scheme interpreter
17:05:15 <tabemann> s/not mutating/mutating
17:05:23 <b2coutts> I've used it lots, and written several partial ones
17:05:33 <b2coutts> but I never actually stuck it through and finished one
17:07:06 <tabemann> it would certainly be easy to write a Scheme in Haskell if one didn't care about writing a full implementation of one of the RnRS standards
17:08:02 <erisco> is there an unpure function somewhere? f a -> a?
17:08:16 <tabemann> erisco: unsafePerformIO
17:08:19 <joelteon> unsafeCoerce
17:08:32 <erisco> why is that unsafe?
17:08:34 <Ghoul_> unsafePerformIO is the opposite to what he wanted
17:08:35 <Redz> the ffi stuff.
17:08:38 <Ghoul_> :t unsafePerformIO
17:08:38 <lambdabot> Not in scope: `unsafePerformIO'
17:08:42 <dmwit> erisco: No. http://dmwit.com/unimportant/grumpy.jpg
17:08:50 <tabemann> Ghoul_: okay, it has just IO and not f
17:08:53 <Ghoul_> Wait, nevermind, I'm silly.
17:09:07 <Ghoul_> Thinking in imperative mode thismorning :S
17:09:25 <erisco> I don't get what's wrong
17:09:42 <dmwit> erisco: Consider unsafePerformIO getLine :: String.
17:09:51 <dmwit> You could call it many times and have many different answers. Strange!
17:09:52 <tabemann> erisco: unsafePerformIO is unsafe because it can launch nuclear missiles in seemingly pure code; unsafeCoerce is unsafe because it can convert anything to anything without concern for binary format, and isn't nice to the GC
17:09:55 <erisco> well obviously you wouldn't have a definition for every type
17:10:04 <erisco> I mean a type class method
17:10:21 <Ghoul_> What monad might that be useful for, though?
17:10:30 <dmwit> Ah, nope. Many monads have run* functions, but it's hard to unify them; they all take extra information or return extra information.
17:10:57 <dmwit> e.g.
17:10:59 <dmwit> :t runState
17:11:00 <lambdabot> State s a -> s -> (a, s)
17:11:08 <dmwit> Has "sort of" the shape "f a -> a", but some extra gunk.
17:11:10 <dmwit> Likewise,
17:11:13 <dmwit> :t runWriter
17:11:14 <lambdabot> Writer w a -> (a, w)
17:11:16 <dmwit> :t runReader
17:11:18 <lambdabot> Reader r a -> r -> a
17:11:39 <dmwit> Again, "sort of" they have the shape "f a -> a", but some extra stuff. And each run* function has *different* extra stuff.
17:11:48 <dmwit> :t runST
17:11:49 <lambdabot> (forall s. ST s a) -> a
17:12:24 <dmwit> Let's see, what other fun ones are there?
17:12:27 <dmwit> :t runMaybeT
17:12:29 <lambdabot> Not in scope: `runMaybeT'
17:12:34 <tabemann> mind you that all these run* functions *are* pure, whereas you asked for an impure function
17:13:00 <jfischoff> dmwit: if you encode them as free monads the run function is the same no (a fold over the f-algebra)?
17:13:06 <dmwit> :t Control.Monad.Trans.Maybe.runMaybeT
17:13:07 <lambdabot> Control.Monad.Trans.Maybe.MaybeT m a -> m (Maybe a)
17:13:28 <dmwit> jfischoff: Sure, but then you're just hiding the differences in having to write an f-algebra.
17:13:39 * jfischoff nods
17:14:19 <dmwit> erisco: (Please nod along if you're following or object if you're lost. We want to explain anything that isn't clear.)
17:14:43 <erisco> sorry I was just looking for a yes or no
17:14:49 <dmwit> "no"
17:14:52 <Ghoul_> nop
17:14:54 <Ghoul_> 0x90
17:29:35 <tabemann> interesting - R5RS doesn't say anything about the binary format of strings, i.e. I could use IORef String to implement them if I felt like it... but the problem then is there would be no built-in means to read and write *binary* data to and from ports, as the built-in functions for reading and writing to and from ports just uses strings...
17:39:37 <spock> howdy, I'm having trouble with getting cabal not to pass the following parameter to "ld -hash-size=31".
17:40:11 <spock> it crashes ever installation of any package, I've grepped the .cabal directory
17:40:24 <spock> nothing there seems to have that option
17:40:33 <spock> I'm not sure why this is getting passed
17:40:44 <spock> anyone have any clues?
17:48:25 <gertc> fmap ab ma  =  ma >>= (return . ab)  i dont understand that . is the same as fmap?
17:49:30 <shachaf> (return . ab) = \x -> return (ab x)
17:49:41 <shachaf> It happens to be the implementation of fmap for one instance of Functor.
17:49:49 <shachaf> But it's probably not the one you're looking at here.
17:49:53 <erisco> any prebuilt show function for infinite lists?
17:50:00 <tabemann> erisco: no
17:50:03 <erisco> kk
17:50:03 <shachaf> Yes. show
17:50:13 <Gracenotes> :t fmap
17:50:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:50:18 <Gracenotes> :t (=<<)
17:50:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:50:48 <heatsink> My program crashes during hs_exit, in a call to malloc(), if I create a vector longer than 2^17 elements.  How can I debug this?
17:50:53 <tabemann> shachaf: I was thinking of special-cased handling of infinite list (which is impossible), not just the obvious case of producing an infinite string
17:51:34 <Gracenotes> The types look pretty similar, right (assuming f and m are the same type operator). To implement fmap in terms of (>>=), though, you end up needing return (assuming laws followed etc.).
17:51:47 <heatsink> tabemann, how would you distinguish infinite lists from very long finite lists?
17:51:55 <heatsink> Oh, right
17:51:57 <tabemann> heatsink: you can't
17:51:57 <heatsink> impossible
17:52:34 <Gracenotes> so it's not about (.), it's that in fact (>>=) is kind of an enhanced version of fmap, where you can simulate the latter using the former (assuming laws followed etc.)
17:52:56 <Gracenotes> somethinglikethat
17:53:09 <tabemann> and just traversing the whole list and seeing if it will fit in memory space doesn't work because you can construct *finite* lists of arbitrary size
17:53:50 <Gracenotes> about infinite lists: http://ro-che.info/ccc/09.html
17:54:41 <gertc> ok got it >>= is the fmap of monads
17:55:00 <tabemann> gertc: no, that's liftM
17:55:25 <tabemann> :t liftM
17:55:25 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
17:57:18 <Gracenotes> liftM is fmap implemented using >>= and return. My main comparison of the two functions, anyway, is that they do most of the 'heavy lifting' in their respective instances' computational interpretations
17:57:26 <Gracenotes> and there is a source
17:57:27 <Gracenotes> @src liftM
17:57:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:57:36 <Gracenotes> @. undo src liftM
17:57:36 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1);
17:58:24 <gertc> aha :)
17:58:39 <gertc> like it when things connect :)
17:59:05 <tabemann> note that one *could* implement x >>= f = join $ fmap f x and then have liftM = fmap
17:59:15 <tabemann> there is no reason why >>= must be fundamental
18:00:22 <dmp1ce> For anyone using vim-hdevtools, how can I tell if it is working?  I tried to install it using vundle.  I don't think it is loading.
18:00:47 <tabemann> (of course that is with Functor as a superclass of Monad)
18:01:16 <erisco> > (pure $ pure 1) :: [[Int]]
18:01:17 <lambdabot>   [[1]]
18:01:29 <joelteon> :t pure
18:01:31 <lambdabot> Applicative f => a -> f a
18:01:59 <tabemann> pure would be return, if Applicative were a superclass of Monad
18:02:24 <joelteon> what's the typeclass that's Applicative without (<*>)
18:03:05 <tabemann> umm... Applicative is pretty meaningless without <*>...
18:03:21 <joelteon> yeah
18:03:25 <joelteon> what's the typeclass that's just pure
18:04:13 <erisco> something a bit amusing when your function is   tok = pure . pure . pure
18:04:16 <byorgey> it is usually called "Pointed", and it's not very useful.
18:04:26 <byorgey> the typeclass which is Applicative without pure is much more useful.
18:04:37 <joelteon> :t point
18:04:38 <lambdabot>     Not in scope: `point'
18:04:39 <lambdabot>     Perhaps you meant `print' (imported from Prelude)
18:07:51 <osa1> does left and right folds applied to this parameters generate thunks with more or less same size? `(+) 0 [1..1000]` ?
18:07:59 <tabemann> Apply in semigroupoids seems to be that
18:08:15 <tabemann> osal: no
18:08:37 <tabemann> a left fold will create a big thunk; a right fold will allocate a lot on the stack
18:09:09 <osa1> tabemann: where can I learn more about that?
18:09:46 * tabemann knows people have written stuff on this, but doesn't recall where to find it offhand - some other people here may know
18:10:22 <tabemann> but basically, you only want to use foldr on functions whose second argument is lazy, and you only want to use foldl', not foldl, as it is strict on its accumulator and thus won't construct big thunks
18:10:46 <osa1> tabemann: I know all that. I'm trying to understand why foldl generates bigger thunks
18:10:58 <osa1> to me it looks like generating thunk with same size of what foldr generates
18:11:53 <tabemann> foldl builds up a tree of expressions on the heap as thunks and then returns the tower of thunks, unevaluated
18:12:26 <tabemann> foldr nests expressions and thus takes up space on the stack, not the heap
18:15:06 <erisco> > fmap (pure::a->[a]) "abcdef"
18:15:06 <lambdabot>   ["a","b","c","d","e","f"]
18:15:10 <tabemann> (note that foldl can still cause stack overflows, but that is when that tower of thunks is finally evaluated, which may occur at an arbitrary time later)
18:15:42 <Gracenotes> (:[])
18:18:41 <Ghoul_> How do I do a dotpoint in haddock?
18:19:23 <byorgey> Ghoul_: what is a dotpoint?
18:19:31 <Ghoul_> a bullet point, sorry
18:19:38 <Ghoul_> if that makes more sense.
18:19:48 <Ghoul_> I'd like to make a list of rules that instances should follow
18:19:54 <Ghoul_> and I thought bullet points would express them best
18:20:17 <byorgey> Ghoul_: you use *
18:20:40 <byorgey> be sure to add a blank line before and after the list
18:20:51 <Gracenotes> here are laws expressed in base: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html
18:21:29 <byorgey> Ghoul_: just find another package with bullet points in its Haddocks, and look at the source
18:21:34 <byorgey> such as what Gracenotes just linked
18:21:44 <Ghoul_> uh yeah I was using * but it isn't working. I'll just look at Control Monad thanks
18:22:10 <Ghoul_> blank line does the trick!
18:29:34 <spock> just in case this happens to other people: the cabal error ld: -hash-size=31  is related to a package in ubuntu which links ld to ld.gold and NOT ld.bfd which is the one ghc expects to use
18:29:59 <spock> surely you guys will probably see this again given the number of ubuntu users out there
18:32:07 <shachaf> tabemann: If someone asks a vague question, assuming that they're asking for something impossible seems like a strange thing to do.
18:33:33 <tabemann> okay, I've got a question - out of all the different sorts of data structures written out there for Haskell, are there any vector-like ones with O(1) prepending and O(1) indexing?
18:34:39 <shachaf> Why do you want O(1)?
18:35:01 <tabemann> I'm building a stack, but I need to be able to point at variables anywhere in the stack, not just access the top of the stack
18:36:01 <shachaf> OK. I don't know exactly what you want but maybe look at Data.Sequence.
18:37:56 <osa1> @where paste
18:37:56 <lambdabot> http://paste.tryhaskell.org/new/haskell
18:38:30 <monochrom> actually, it's lpaste.net now
18:38:34 <osa1> it's still not clear to me why non-strict left folds generate bigger thunks, can anyone explain to me on this example http://lpaste.net/91068
18:38:36 <tabemann> too bad IOArray isn't expandable, or else I would use that
18:38:50 <monochrom> @where+ paste http://lpaste.net/new/haskell
18:38:50 <lambdabot> Done.
18:38:56 <shachaf> OK, so you're OK with mutable data structures.
18:39:21 <tabemann> shachaf: I'm implementing a Scheme - local variable bindings in it are mutable in the first place
18:39:23 <shachaf> You can write the usual growing array thing code on top of one of the mutable arrays.
18:39:23 <monochrom> osa1: have you read my http://www.vex.net/~trebla/haskell/lazy.xhtml ?
18:39:34 <shachaf> I don't think there's any such thing in Haskell.
18:39:36 <osa1> monochrom: no, thanks for the link
18:39:57 <tabemann> monochrom's explanation is excellent - read it all
18:40:19 <byorgey> tabemann: and there are going to be so many variables that O(1) vs O(log n) really makes that big of a difference?
18:41:05 <tabemann> byorgey: probably not...
18:41:23 <byorgey> Just use Data.Sequence, and you can switch to an auto-expanding IOArray later if it turns out to really make a difference.
18:41:33 * tabemann wonders if the expense of dynamically expanding a mutable array would be greater than or less than the expense of traversing a Seq
18:41:34 <shachaf> O(log n) is O(1) anyway.
18:41:44 <byorgey> that's what I mean.
18:41:57 <shachaf> Hmm, except when n is infinite, I suppose.
18:42:11 <shachaf> E.g. you can have O(log n) access to a leaf of a tree, but that doesn't help you if it's infinite.
18:42:13 <byorgey> tabemann: that question is meaningless out of context.
18:42:20 <tabemann> the advantage of using an IOArray, though, is that I don't have to allocate IORefs for every single thing in the stack
18:42:47 <shachaf> Whereas with a different tree you can get the leftmost element or something in constant time. So O(log n) vs. O(1) matters more there.
18:44:19 <tabemann> IOArray means O(1) argument passing and O(1) binding lookups but it means more expensive stack expansion (or wasteful allocation); Seq means O(1) argument passing, O(log n) binding lookups, and allocating lots of IORefs, with their individual overhead
18:46:10 <c_wraith> IORefs are also not great for garbage collection.
18:46:26 * byorgey hands tabemann a self-help book for those struggling with premature optimization
18:46:50 <Nisstyre> byorgey: what about those of us struggling with postmature optimization?
18:47:29 <tabemann> c_wraith: unfortunately I simply can't avoid mutable state, thanks to Scheme being impure
18:47:38 <Nisstyre> tabemann: you can
18:47:50 <c_wraith> Well, then, you make do with what you have to.
18:47:53 <Nisstyre> you must be thinking of common lisp
18:47:53 <tabemann> my life would be easier if I decided to say fuck RnRS and just not implement mutation functions
18:48:06 <Nisstyre> I mean Scheme has set! and all
18:48:09 <Nisstyre> but you don't have to use it
18:48:27 <byorgey> Nisstyre: tabemann is *implementing* scheme.
18:48:29 <Nisstyre> ah ok
18:48:32 <Nisstyre> fair enough then
18:48:43 <Nisstyre> well you can just leave it out I guess
18:48:59 <Nisstyre> you may piss off people who try and use it though :P
18:49:08 <tabemann> haha
18:49:10 <byorgey> tabemann: anyway, just implement something! anything! the simplest thing you can possibly think of.  then when it is too slow you can improve it later.
18:49:23 <c_wraith> You don't have to implement set! with mutation..  It's just an optimization
18:49:30 <byorgey> Haskell is easy to refactor.  And the things which actually end up making it slow will be completely different than what you would have guessed.
18:49:32 <Nisstyre> yeah that's true
18:49:42 <Nisstyre> if the semantics are the same it doesn't really matter if it's functional or not
18:50:00 <shachaf> mutation is just what everyone starts with. eventually they end up with nutation.
18:50:10 <tabemann> c_wraith: I can't rebind variables dynamically with it, because of the semantics with things like, umm, continuations
18:51:23 <tabemann> i.e. if I bind a variable, apply call/cc and save the continuation somewhere, get the variable's value, then set! that variable, and then apply the continuation
18:52:01 <tabemann> the first getting the value must differ from the second getting, if the value is changed by set!
18:52:23 <Nisstyre> tabemann: is there no way to desugar set! into something pure?
18:52:37 <shachaf> Are you saying that it's impossible to implement Scheme without IOArrays, or what?
18:53:56 <tabemann> shachaf: there's other ways I can think of implementing it, but they aren't going to be as performant (e.g. dynamically looking up (and rebinding) variable bindings in a more elaborate data structure of some sort)
18:54:32 <tabemann> and the implementation I'm thinking of makes it easy to implement both continuations and closures with minimal copying
18:54:48 <tabemann> without getting rid of set!
18:57:24 <tabemann> (set! needs to be able to mutate a closure's free variables while having the changes be seen in the context those variables were bound, and using more elaborate functional data structures that will enable that while remaining performant is going to be difficult)
18:58:24 <Ebony> byorgey: Not only can you improve on it later, but you can also measure the improvements... Providing you have something to measure them against :)
18:59:01 <Ebony> The simplest thing seems to be a good thing to measure speed against.
18:59:36 <tabemann> I'm partially doing this not out of trying to (prematurely) optimize but how to implement use cases like the one I mentioned above simply, and I can't get rid of IO anyways because I need to be able to do IO from within Scheme in the first place)
19:00:20 <tabemann> if it weren't for lexical scope I could implement something similar to traditional implementations of dynamic scope in a functional fashion, but obviously Scheme is lexically scoped
19:01:35 <tabemann> hmm
19:01:53 <tabemann> maybe implementing the stack just as a linked list of IORefs would actually make implementing continuations easier...
19:02:28 <tabemann> at the cost of O(n) variable lookups
19:03:21 <Ebony> ... and other problems inherent of the stack...
19:06:16 <tabemann> okay
19:07:28 <tabemann> stack frames with IOArrays work if A) there are *two* IOArrays per stack frame, one for arguments and one for variable bindings and B) each sub-stack grows, not shrinks and C) the argument sub-stack is copied when a continuation is entered
19:07:31 <Ralith> tabemann: just because the language might do IO doesn't mean your evaluator should.
19:08:51 <tabemann> (the problem with putting both variables and arguments in the same stack is that we need to see the same variables across continuations, but we can't overwrite arguments in the event of multiple continuations pointing to the same stack frame
19:09:36 * tabemann wants to handle all the pathological cases correctly
19:11:03 <tabemann> Ralith: but for the evaluator to *not* do IO means basically logging any IO operations from within it, saving the current state, escaping from the evaluator and doing the IO outside it, and then restoring the state and returning to execution
19:11:47 <tabemann> and that's more complex when one considers Scheme -> Haskell -> Scheme calls, because one would have to escape from the Haskell too, copying the IO log across it, and then return to the Haskell and carry the restored state into Scheme through it
19:11:49 <tabemann> too complex
19:12:43 <Ebony> tabemann: Are you attempting to extend the lifetime of objects?
19:13:14 <tabemann> Ebony: continuations can indefinitely extend the lifetime of stack frames
19:16:05 <tabemann> (thank gawd I don't have to implement my own garbage collector even if I have to bother with giving call/cc all the right semantics...)
19:16:27 <Nisstyre> tabemann: what about delimited continuations?
19:16:48 <Ebony> tabemann: What does O(1) mean?
19:16:50 <Ghoul_> anyone know how to reconnect lambdabot after a netsplit
19:16:52 <Ghoul_> without restarting ?
19:17:03 <Ghoul_> but keeping the same server name so it doesn't mess up the admins and stuff
19:17:07 <tabemann> Ebony: it means that something takes constant time or space
19:17:16 <Ebony> tabemann: Good.
19:17:22 <Nisstyre> tabemann: have you read Friedman's papers on continuations?
19:17:30 <tabemann> Nisstyre: no I haven't
19:17:34 <Nisstyre> I'd recommend it
19:17:39 <Nisstyre> http://www.cs.indiana.edu/~dfried/
19:17:55 <Nisstyre> the one on trampolined style will be helpful maybe
19:18:51 <tabemann> I'm planning on implementing continuations as just a reference to a stack frame combined with an index into its argument stack, and letting the normal GC handle disposing of stack frames
19:18:55 <Nisstyre> oh and "Recycling Continuations"
19:19:23 <Ebony> tabemann: I suggest turning Data.Sequence prepends and indexes into O(1) operations by using sleep and padding.
19:19:28 <Nisstyre> that is specifically about implementing continuations
19:19:33 <tabemann> that's basically the least complex way of implementing continuations that I can think of
19:21:36 <Ebony> For example, you could wrap Data.Sequence operations and sleep for whatever time that took subtracted from one year. The result is that the operation took exactly one year; An O(1) operation. ;)
19:21:53 <Nisstyre> Ebony: have you seen "sleep sort"? :P
19:22:16 <Ebony> No, but I can see how that'd also be an O(1) operation.
19:22:38 <tabemann> Ebony: and that's what partially makes me partial to IOArray, in that I know the look-up time will have a small constant factor rather than, say, a large constant factor
19:23:00 <Nisstyre> Ebony: yeah, to sort an array of integers, assign a thread to each one, and have them wakeup in the number of seconds or whatever that the integer represents
19:23:07 <tabemann> the only major expense of IOArrays are when they are expanded, but if I can guess the maximum stack size ahead of time, I may be able to avoid that
19:23:38 <tabemann> (i.e. the deepest execution path through a given function)
19:24:06 <Nisstyre> tabemann: the paper I reference (Recycling Continuations) seems to give a good functional way to implement continuations and save on space
19:24:17 <Nisstyre> although it may or may not be complicated for your design
19:27:01 <erisco> I've got two different operations I want to do for <*> but I've only one type ... seems problematic
19:27:07 <tabemann> the thing is that I'm going to have to implement stack frames on the heap *anyways*, simply because I'm implementing this in Haskell, not C, so I might as well take advantage of that to simplify my continuation implementation
19:28:18 <Ebony> The heap? The stack? Aren't they both from the same place, anyway?
19:28:33 <tabemann> Ebony: they're the same in Haskell essentially; they're not the same in C
19:28:41 <shachaf> tabemann: Huh?
19:28:47 <tabemann> and there are Schemes that use the C stack, e.g. Chicken Scheme
19:28:49 <Ebony> tabemann: There aren't any stack OR heap in C.
19:29:04 <Cale> Well, *Haskell* has neither concept.
19:29:14 <Nisstyre> C definitely has a stack and a heap...
19:29:28 <Ebony> Find me the word "stack" or "heap" in the C standard...
19:29:39 <tabemann> shachaf: aren't stacks basically allocated in the heap, and dynamically resized with being reallocated, in Haskell?
19:29:43 <Cale> But the way GHC implements your programs involves both a heap and a stack, and uses them for different purposes
19:29:59 <Cale> The stack is essentially a stack of pattern matches which are waiting to happen.
19:30:10 <Nisstyre> Ebony: fair enough, but most implementations have a distinction
19:30:10 <Cale> (it's not a call stack!)
19:30:16 <tabemann> it's easy to say many things if one only cares about what Haskell 98 or Haskell 2010 standards say, and not about how anyone implements it
19:30:42 <tabemann> and it's easy to say many things about C if one only cares about what ANSI has to say
19:30:43 <shachaf> It's easy to say many things if one does not care about them being correct.
19:30:53 * Clint claps.
19:31:17 <Nisstyre> Ebony: for example it's probably not a good idea to make use of things like VLAs in C too much because most implementations will allocate the memory on a (limited) stack
19:31:25 <tabemann> shachaf: there's been many times I have read people making comments to the effect of "but that isn't Haskell! that's just GHC, and GHC isn't Haskell!"
19:31:57 <Ebony> Nisstyre: Don't confuse VLAs with automatic storage duration.
19:32:07 <tabemann> but typically in reality people do target GHC, and not, say, Haskell 2010
19:32:08 <Ebony> Nisstyre: VLAs can be allocated in dynamic storage duration, too.
19:32:25 <Nisstyre> Ebony: I'm not, but I'm just saying that you have to be aware of what particular implementations do with them
19:32:36 <shachaf> C minutiæ are mostly off-topic in here.
19:32:47 <tabemann> and of course the runtime properties of one's code depend upon how one's runtime is implemented, not just what the language standard says
19:32:50 <Nisstyre> if the exact operational semantics aren't specified, how do you know?
19:32:56 <Ebony> This isn't ##C, so I won't go on about that... All I'll say is, if I were implementing C in this day and age I'd use some form of graph rather than a stack, because of the recent additions in the C11 standard (threading).
19:33:07 <Nisstyre> Ebony: fair enough
19:33:30 <tabemann> de facto matters just as much as de jure
19:33:32 <Ebony> tabemann: That might give you some ideas...
19:34:16 <Ivoz> Disclaimer: "trying to understand monads". should a new / custom monad expect to bind only functions that return its type, or should it be able to bind any function that returns the type the monad might be wrapping?
19:34:52 <shachaf> Ivoz: I'm not sure what you wrote means anything as written. :-) Can you clarify "bind" "its type", etc.?
19:35:01 <byorgey> Ivoz: what is the type of (>>=) ?
19:35:16 <shachaf> s/" /", /
19:35:41 <Ivoz> ok, so its been a while since I've written haskell.. but I'm assuming you guys know the idea best here. Here's my current quandry in full -
19:35:41 <tabemann> :t (>>=)
19:35:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:36:03 <shachaf> wagle: comonad.com is edwardk's. It's been down for months or something.
19:36:12 <Ivoz> looking at https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Writer_monad you might be able to get what I mean by "bind"
19:36:14 <shachaf> There's a mirror somewhere but we should bug edwardk until he gets it back up.
19:36:41 <wagle> was up last week, but...
19:36:43 <Ivoz> I think the whole example seems to be written badly, but particularly I'm wondering about:
19:37:07 <shachaf> I think I'd recommend avoiding that example and in fact any JavaScript example.
19:37:08 <byorgey> Ivoz: you are trying to learn about monads in Haskell by reading javascript code on a wikipedia page ?!?!
19:37:29 <tabemann> "bind" in that example is (>>=), and yeah, why the f are they using JavaScript to demonstrate monads!
19:37:32 <Ivoz> For this new writer monad, you seem to need to write new functions en mass that return its type, and that seems stupid to me
19:38:03 <tabemann> umm all functions you pass to (>>=) have to return the same monad type constructor, but the type applied to it can differ
19:38:04 <wagle> if you can understand in in javascript, then you UNDERSTAND IT...  i think
19:38:09 <Ivoz> byorgey: well actually I'm in the middle of trying to understand them as best as possible, because intuitively that example seems horrid to me and so I want to rewrite it
19:38:13 <shachaf> Ivoz: Something is very mixed up in what you're saying, and I'm inclined to blame this example.
19:38:15 <Nisstyre> well, you could use javascript, or python, or scheme, or haskell
19:38:19 <Nisstyre> it's the same concept...
19:38:44 <shachaf> So use a different example.
19:38:46 <Nisstyre> although I wouldn't use JS because I'd want it to be clear
19:39:03 <byorgey> Ivoz: you are going about this fom the wrong direction, IMO.  Instead of starting by trying to "understand monads", just start by understanding the Monad type class and the types of its methods, and implement some example instances in Haskell.
19:39:11 <Ivoz> I think its perfectly possible to be very clear in javascript, people often aren't, though
19:39:14 <tabemann> the question is *why* did they choose JavaScript for this - there are plenty of examples for other things on Wikipedia in Haskell, so it is not like Wikipedia has some policy that code examples must be put in JavaScript
19:39:27 <Nisstyre> Ivoz: I'm just thinking in this particular case, I'd want to make use of "new" and "this"
19:39:42 <Nisstyre> which can be confusing for people not acquainted with the black magic contained in those
19:39:59 <Ivoz> tabemann: well from an outsiders point of view, haskell can be very hard to read for anyone who hasn't looked at it before, so I'd suspect they'd be drawn to this example as well
19:40:07 <byorgey> tabemann: probably some misguided notion of demonstrating that "monads show up in lots of programming languages"
19:40:10 <shachaf> Ivoz: No, I can't think of a way to explain this in JavaScript without muddling things up terribly.
19:40:47 <shachaf> The author certainly seems somewhat muddled to me.
19:40:51 <Nisstyre> Ivoz: are you familiar with Python? I can implement Maybe in Python which is an instance of Monad
19:41:02 <Nisstyre> and things may be a little bit clearer
19:41:11 <Ivoz> byorgey: I think they're probably "doable" in most languages, but make far less sense to actually use in some rather than others
19:41:12 * tabemann isn't aware of monads catching on anywhere other than in Haskell and closely related languages, even though people *have* implemented them in other languages, e.g. OCaml
19:41:33 <byorgey> Ivoz: sure.
19:42:02 <Redz> every imperative language is just a big monad, i think. ;)
19:42:16 <shachaf> Ivoz: The point of talking about "monads" is the *abstraction*, not every individual instance.
19:42:21 <tabemann> just with one instance of Monad, and being forced to use do notation everywhere
19:42:29 <Nisstyre> Redz: http://conal.net/blog/posts/the-c-language-is-purely-functional
19:42:30 <shachaf> And you're not going to be able to express that in JavaScript easily.
19:42:42 <tabemann> shachaf: yes, when I code for C I really code for CPP
19:42:46 <Ivoz> for instance here's a blog of a prominent php guy trying to implement them in php - http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html mediocre implementation, but I just can't see anyone wanting to make use of them given how obtuse they are in the language
19:42:52 <tabemann> s/shachaf/Nisstyre
19:43:13 <Nisstyre> Ivoz: ugh
19:43:25 <Nisstyre> how about fixing the thousand other problems first? >.>
19:43:44 <Ivoz> javascript allowing closures and first-class functions, I wouldn't think monads should have to be horrible in it, though, so I wanted to make this wikipedia example better.
19:44:01 <tabemann> if we really wanted to demonstrate the universality of monads we would be demonstrating them in ALGOL
19:44:02 <shachaf> Ivoz: You're linking to things written by people who don't really know what they're talking about.
19:44:05 <erisco> if I have two ways I want to define an applicative instance, have I necessarily messed up?
19:44:18 <BMeph> I'm with Nisstyre here: " here's a blog of a prominent php guy trying to implement them in php"...now, you have four problems. ;)
19:44:35 <shachaf> Ivoz: I suggest that you aren't going to be able to figure this out well enough to explain it very easily either.
19:44:54 <shachaf> People always *think* they've figured it out well enough to explain it, but usually they're missing the point.
19:44:56 <Ivoz> I never said what he came up with was super impressive, was just trying to give an example of my point that they make far less sense in some languages than others
19:45:07 <shachaf> Surely both of these people are.
19:45:24 <tabemann> usual explanations of monads seem to sort of work for IO, ST, STM, State, Writer, etc.... and totally break for list
19:46:07 <Ivoz> Nisstyre: yes I'm very familiar with python... is a writer monad possible to hack together in a minute?
19:46:13 <Nisstyre> Ivoz: first learn about type classes before you try to really understand what a monad is or isn't. Also don't get confused between the concept of a "monad" and a type. Things like [a] are still types, and they are independent of the monad instance in the sense that you don't need to add the Monad constraint at all when using them.
19:46:45 <Ivoz> I think of a monad as something that usually "wraps" a type
19:46:49 <shachaf> What does "a writer monad" mean?
19:46:54 <Nisstyre> Ivoz: er, maybe, not sure if it'd help
19:47:18 <Nisstyre> Ivoz: that's not really the right way to think about it imo
19:47:32 <shachaf> I think one's best bet if one wants to "explain monads" in JavaScript is to use Cont or something. But of course that'd be very confusing too.
19:47:47 <Ivoz> well tabemann also seems to have a concept of one, I hadn't come across it before
19:48:46 <m3ga> how does one contact the admins for http://code.haskell.org/ ?
19:48:56 <shachaf> m3ga: Try asking in #haskell-infrastructure.
19:49:26 <m3ga> thanks shachaf
19:49:36 <tabemann> by "a concept of one" I was specifically referring to http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Writer-Lazy.html#t:Writer, not to a nebulous sort of "writer monad"
19:51:00 <Ivoz> the monad demonstrated on the wikipedia page would seem to me to be better labeled as a 'logging' monad
19:51:33 <Nisstyre> Ivoz: http://www.haskell.org/haskellwiki/All_about_monads#The_Writer_monad
19:52:09 <tabemann> the "log" that Writer produces is called a /Monoid/
19:52:19 <shachaf> Yes, "logging" is perfectly fine.
19:53:11 <Ivoz> well the link you give tabemann even refs to a log in its explanation :D
19:53:20 <shachaf> Ugh, that Wikipedia page is really terrible.
19:53:48 <tabemann> except that Writer works with *any* monoid, and not all monoids behave like logs
19:53:49 <Ivoz> help thousands of future inquisitive programmers out and improve it!
19:54:19 <Ivoz> yes 'writing' is a more general concept, 'logging' is one practically any programmer should be able to immediately relate to though
19:54:20 <Nisstyre> tabemann: e.g. natural numbers
19:54:43 <tabemann> Nisstyre: you got to that just before I did
19:55:18 <tabemann> e.g. natural numbers have *two* monoids, sum (mempty = 0, mappend = (+)) and product (mempty = 1, mappend = (*))
19:55:39 <Nisstyre> I guess the reason Int isn't an instance in Data.Monoid is because there are multiple possible ones right?
19:55:40 <roboguy_> Ivoz: you can multiply to a number, for example, instead of appending to a string
19:55:44 <Ivoz> is a monoid a monad that 'naturally' applies to something?
19:55:46 <shachaf> There are more than two Monoid instances for Nat, of course.
19:55:56 <tabemann> Nisstyre: yes
19:55:58 <shachaf> Ugh, this channel is awful.
19:56:07 <shachaf> Everything is bad.
19:56:24 * shachaf sighs.
19:56:30 <Ivoz> well thankyou to everyone for not being immediately dismissive of me :)
19:56:32 <tabemann> Ivoz: not at all
19:56:51 <tabemann> monoids are just any combination of an identity and an associative function
19:57:01 <shachaf> Ivoz: Your question is generally reasonable.
19:57:07 <lpaste> MedDev pasted “Add Subsequent” at http://lpaste.net/91070
19:57:10 <Nisstyre> binary associative operator with an identity element
19:57:56 <shachaf> MedDev: By indexing into the old vector?
19:58:20 <shachaf> Hmm, Vector isn't Array.
19:58:38 <shachaf> MedDev: Why is your solution "very very slow"?
19:58:39 <Nisstyre> also shachaf is right, you could come up with tons of different monoid instances for the various number types, not to mention the types that are instances already
19:59:45 <Ivoz> shachaf: consider that maybe half programmers with a C-style / OO background, having come across the wiki page for monads, might immediately look at the javascript example to try and get an idea of what these 'mystical' things are, since thats their most relateable language
20:00:01 <Ivoz> make you feel warm and fuzzy inside? :)
20:00:19 <shachaf> Ivoz: No, that page would be much better if the example was deleted.
20:00:21 <MedDev> shachaf, it's a big vector of PCM values something like a few million elements?
20:00:29 * tabemann is all for deleting the example too
20:00:30 <shachaf> MedDev: So?
20:00:59 <MedDev> shachaf, it hangs when I run it.  Eventually I just ctrl+c to end it from evaluating
20:01:00 <tabemann> nothing is better than something misleading
20:01:04 <Ivoz> people might then complain that there is no example of monads in any language other than haskell
20:01:16 <shachaf> MedDev: Can you @paste a complete example?
20:01:26 <tabemann> that's probably because few people use monads except in Haskell and related languages
20:01:39 <MedDev> Yeah, just a second
20:01:46 <tabemann> there's not nearly the motivation to use them out in the world of impure languages
20:01:54 <shachaf> Ivoz: That's OK, I think.
20:02:06 <shachaf> "monads" have nothing to do with "purity".
20:02:17 <tabemann> shachaf: of course they don't
20:02:57 <tabemann> but they were popularized in haskell originally as a solution to doing IO in a pure language, and only then people came up with other uses for them that had nothing to do with purity versus impurity
20:03:23 <lpaste> MedDev revised “Add Subsequent”: “Add Subsequent with main” at http://lpaste.net/91070
20:03:51 <shachaf> MedDev: That's not a program I can run. :-(
20:04:20 <Ivoz> what if they're a cool idea that could apply to most languages, like isolation of state, just that they haven't achieved mindshare yet
20:05:32 <shachaf> I don't even know what "they" means.
20:05:36 <MedDev> shachaf, no worries. going to try indexing the vector directly and building another like you suggested
20:05:43 <tabemann> s/they/monads
20:05:50 <Ivoz> ^ basically
20:05:51 <shachaf> Yes, I know that much.
20:06:27 <shachaf> If Haskell didn't have the class Monad, there would still be plenty of things that would be instances of it, like [] and Maybe and (r ->).
20:06:29 <tabemann> well, for monads to really be likely to take off in a given language, it is likely they would probably need language syntactic support (like that which has been recently added as an extension to OCaml)
20:06:33 <Ivoz> it seems to me a useful general programming tool in any "first-class-functional" language
20:06:36 <shachaf> So it's not as if it "wouldn't have monads".
20:07:03 <shachaf> The point of saying "monad" is that you have an abstraction.
20:07:31 <tabemann> yes, you could have functions equivalent to (>>=) but for individual type constructors without a Monad type class, yes
20:07:41 <roboguy_> tabemann: doesn't C# have some syntactic support for stuff like that
20:07:43 <shachaf> This is easily expressible in Haskell, not so easily expressible in other languages. And even when it is expressible -- sometimes by being informal etc. rather than doing something within the language -- the concept gets terribly muddled.
20:08:01 <shachaf> You end up with people being awfully confused and writing bad articles.
20:08:10 <tabemann> roboguy_: dunno, not a C# person myself
20:08:17 <Ivoz> well I would like to help stop people writing bad articles :/
20:08:28 <shachaf> MedDev: I suspect you're missing something important.
20:08:42 <tabemann> the thing is type classes make the concept of monads much easier to clearly express
20:08:53 <shachaf> MedDev: But I don't know what. But I think you should figure it out. :-)
20:09:05 <shachaf> Anyway, there's nothing useful I can do here at this point.
20:09:22 <Ivoz> imho, in 'general programming trends', people are starting to warm up to stronger typing a hell of lot these days
20:09:47 <tabemann> unfortunately, many of those people are ending up as Scala programmers...
20:09:56 <Ivoz> as in even where python programmers are starting to wonder whether parse-time type hint checking would be awesome
20:10:09 <shachaf> MedDev: Oh, try using fromListN.
20:10:43 <Ivoz> tabemann: is that the worst thing that could happen?
20:11:05 <tabemann> Scala is basically Java pretending to be an FP and failing at it
20:11:08 <nimish> Ivoz: python 3 has optional type annotations
20:11:16 <nimish> not sure if anyone uses them
20:11:31 <Ivoz> nimish: its all for runtime, though
20:12:10 <tabemann> limited type annotations in an otherwise dynamic language are not the same thing as Hindley-Milner or supersets of it like whatever subset of System F GHC is really using now
20:13:14 <tabemann> we do see full typifications of previously dynamic languages in places, though, e.g. Typed Racket
20:14:13 <Ivoz> haskell being able to tell you to gtfo if any of your typing is wrong in the entire program ast is not an unenvied perk
20:14:32 <Ivoz> microsoft made typescript for javascript :)
20:15:12 <tabemann> the thing is the likes of Hindley-Milner gets around most of the limitations of older traditional static typing that motivated people to use dynamic typing in the first place
20:15:48 <Gracenotes> it is a bit difficult to use with mutability
20:17:13 <tabemann> Gracenotes: OCaml and SML manage to use HM even with mutability
20:17:43 <tabemann> (even though traditional imperative coders may bristle at being forced to use ref types...)
20:19:23 <Gracenotes> monomorphically, yes.
20:20:17 <tabemann> Gracenotes: yes, there's that
20:20:35 <erisco> data Foo a b c = Foo1 a | Foo2 b | Foo3 c  ;  I have three sources for a, b, c ... some interface like   (a -> d) -> (b -> d) -> (c -> d) -> f [a] -> f [b] -> f [c] -> f [d]
20:21:06 <erisco> but not so ugly... and expandable to more args like Applicative is
20:22:10 <erisco> a->d = Foo1, b -> d = Foo2, c -> d = Foo 3, d = Foo
20:22:35 * tabemann is confused
20:22:49 <erisco> me too :)
20:23:21 <Gracenotes> you want to write something like map either
20:23:23 <Gracenotes> @type either
20:23:24 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:23:36 <Gracenotes> except ternary
20:24:04 <Gracenotes> and... how you merge them is whatever that is
20:24:38 <Gracenotes> I'm not sure what f is, but at least for this usage, Functor should suffice it seems (Applicative not needed)
20:26:00 <Gracenotes> yeah, mostly I'm just confused about the relationship between Foo and that complicated signature
20:26:59 <tabemann> the question I have is, for all those functions being applied to the different list items, how are they being ordered together in their results in f [d]
20:27:23 <erisco> the signature was intended to be of some class method
20:27:31 <tabemann> class method?
20:27:33 * tabemann facepalms
20:27:34 <erisco> so the implementation is type dependent
20:28:09 <erisco> but the trick is a slick interface like you have with Applicative
20:28:21 <tabemann> okay, so you have a type class Bar and f is an instance of it
20:28:56 <erisco> yeah
20:29:06 <tabemann> I don't see where Foo comes in here
20:29:15 <erisco> it is an example
20:29:25 <tabemann> but the type signatures don't match at all
20:29:36 <erisco> I don't know what you mean
20:29:51 <tabemann> Foo can't be a Bar, as it is * -> * -> * -> * and a Bar must be * -> *
20:29:54 <b2coutts> I'm having difficulty figuring out how to, given a list of filenames, get a string containing all of their contents concatenated together. Any suggestions?
20:30:08 <erisco> tabemann, ah fair enough
20:30:17 <Ghoul_> is there a way to document instances of classes using haddock
20:30:21 <tabemann> b2coutts: concat $ map readFile filenames
20:30:25 <Ghoul_> I always just get the default documentation
20:30:37 <Ghoul_> when my version of the function has quirks I'd like the programmer to know about
20:30:49 <erisco> :t either
20:30:50 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:31:10 <Ghoul_> Consider get/put here: https://github.com/kvanberendonck/monad-chrono/blob/master/src/Control/Monad/Chrono.hs
20:31:20 <johnw> Ghoul_: if you have a type class, it should show all the instances Haddock knows about at the time the docs were generated
20:31:20 <erisco> that might be fine for two value constructors, but how might I extend to more?
20:31:22 <Ghoul_> get/put documentation is replaced by default State monad documentation for get/put
20:31:48 <Ghoul_> johnw: they show up, they just show the wrong documentation
20:32:54 <b2coutts> tabemann: this doesn't work since readFile produces an IO String instead of a String
20:33:06 <b2coutts> and some hacking I tried to do with applicatives was fruitless
20:33:13 <b2coutts> I suppose I should probably just learn Monads before doing this
20:33:19 <tabemann> whoops
20:33:33 <tabemann> :t concatM
20:33:34 <lambdabot>     Not in scope: `concatM'
20:33:34 <lambdabot>     Perhaps you meant one of these:
20:33:34 <lambdabot>       `concat' (imported from Data.List),
20:33:55 <johnw> concat <$> mapM readFile files
20:33:58 <tabemann> whoops, I thought I saw a concatM somewhere
20:34:09 <johnw> :t concatMapM
20:34:11 <lambdabot>     Not in scope: `concatMapM'
20:34:11 <lambdabot>     Perhaps you meant one of these:
20:34:11 <lambdabot>       `concatMap' (imported from Data.List),
20:34:45 <b2coutts> johnw: awesome, thanks. I'll definitely come back to this to make sure I understand what this does when I learn monads
20:34:58 <b2coutts> but for now it's nice to just have it working
20:35:05 <tabemann> (why did I forget that readFile returned IO String?)
20:35:20 <Ghoul_> is <$> fmap?
20:35:23 <johnw> yes
20:35:27 <Ghoul_> Oh cool
20:35:53 <Nisstyre> :t mconcat
20:35:54 <lambdabot> Monoid a => [a] -> a
20:36:25 <erisco> tabemann, data Foo = Foo0 Char | Foo1 Int | Foo2 Float    instead
20:36:31 <Nisstyre> :t foldr mappend mempty
20:36:32 <lambdabot> Monoid b => [b] -> b
20:36:32 <erisco> I don't need the type variables actually
20:36:33 <flebron> Suppose I wanted to implement the following functions in Haskell, is STUArray Int Int what I would want? http://ideone.com/e8Ajj3
20:36:50 <flebron> (I'm pretty new at ST stuff :))
20:37:00 <b2coutts> :9
20:37:03 <b2coutts> whoops
20:38:08 <erisco> so I have some [Char], and [Int], and [Float], and I need to get to [Foo]
20:38:38 <johnw> data Foo = FooChar Char | FooInt Int | FooFloat Float
20:38:39 <Nisstyre> erisco: (map toFoo chars) ++ (map toFoo ints) ++ (map toFoo floats)
20:39:08 <erisco> (a -> d) -> (b -> d) -> (c -> d) -> f a -> f b -> f c -> f d
20:39:43 <erisco> Nisstyre, ++ is not the method I want to use to get to [Foo]
20:39:53 <Nisstyre> erisco: well however you want to do it
20:40:01 <tabemann> is f supposed to be an instance of, say, Foldable here?
20:40:13 <tabemann> hmm
20:40:18 <Gracenotes> Are you sure that shouldn't be (a -> d) -> (b -> d) -> (c -> d) -> Either3 a b c -> d
20:40:56 <Nisstyre> erisco: what's wrong with johnw's method?
20:41:16 <erisco> Gracenotes, I might condense those three functions in that way, perhaps
20:41:36 <erisco> what is johnw's method?
20:41:54 <monochrom> flebron: STUArray is one way
20:42:30 <Nisstyre> erisco: using FooChar, FooInt, etc...
20:42:54 <flebron> monochrom: So I could have find_set :: Int -> UArray Int Int -> UArray Int Int that efficiently modified the array?
20:43:00 <erisco> I don't get how that is different than what I started with
20:43:08 <flebron> Or would all my computations have to be done within the ST monad?
20:43:44 <flebron> (Those functions are for a disjoint-sets implementation, for use in Kruskal's minimum spanning tree algorithm.)
20:43:46 <tabemann> flebron: if you want to do something like that, you should use Maps, whether Data.Map, or Data.Hashmap.{Lazy,Strict}
20:43:52 <erisco> Nisstyre, how would I define toFoo?
20:43:58 <flebron> I was looking for O(1) access :)
20:44:00 <tabemann> passing around UArrays like that is going to be *inefficient*, as every update will copy the entire array
20:44:05 <flebron> Right.
20:44:21 <tabemann> Data.Map has O(log N) and Data.HashMap.{Lazy,Strict} has O(1)
20:44:26 <flebron> Though I had heard ST can make those STUArrays be updated in place.
20:44:34 <tabemann> yes, it can
20:44:34 <flebron> Hashes will always have expected O(1) at best.
20:46:04 <monochrom> find_set :: STUArray s Int Int -> STUArray s Int Int -> Int -> ST s Int
20:46:11 <Nisstyre> erisco: http://ideone.com/m9Olf3
20:47:00 <Gracenotes> hashmaps can have higher constant costs than people think
20:47:48 <tabemann> considering we're hashing Ints here, that should essentially just be a modulus...
20:48:51 <flebron> monochrom: What are the two STUArrays?
20:48:53 <Gracenotes> IntMap is ridiculously fast, though, if we want immutability
20:49:01 <monochrom> rank and parent
20:49:10 <flebron> Oh, right.
20:49:43 <flebron> This is perhaps stupid but... do I just call that function in the monadic ST code? How do I actually "call" it?
20:49:52 <erisco> Nisstyre, that is an interesting idea, but isn't as simple as I want. I'll have to think about the problem more then
20:49:58 <monochrom> in monadic ST code
20:50:28 <monochrom> some outer level will have a runST
20:52:14 <flebron> So I would say... let x = runST $ find_set rank parent i?
20:52:23 * flebron doesn't think that's right, lets are just bindings.
20:52:37 <monochrom> runST has to wrap around the whole algorithm
20:52:56 <monochrom> and wrap around the creation of rank and parent
20:52:58 <flebron> That's fine, assume it is. kruskal = runST $ ...
20:53:07 <flebron> OK, sure. Say those are created.
20:54:05 <pentace> Is there a package for finding local minima/maxima in a list?
20:55:01 <flebron> zip3 x (tail x) (tail tail x) and look at the middle one? :p
20:55:08 <flebron> * tail $ tail x
20:55:51 <pentace> nope
20:56:29 <pentace> I need something for arbitrary intervals
20:57:06 <Gracenotes> well, if you're only looking at local ones, neighbors should be enough.
20:57:59 <Gracenotes> are you looking for an RMQ library?
20:58:14 <pentace> I don't know what that is
20:58:26 <Gracenotes> https://en.wikipedia.org/wiki/Range_Minimum_Query
20:59:45 <pentace> I think that's what I need but for all possible sub-arrays within the complete array
21:00:06 <pentace> of a given length, that is
21:01:05 <path[l]> all permutations? or all slices?
21:01:08 <pentace> so find the element c such that a[c] == minimum [a[c-n] ... a[c+n]]
21:02:28 <pentace> path[l]: slices, I think
21:02:37 <Gracenotes> If you have constant n, then you can get O(1) query with linear space.
21:02:54 <Gracenotes> which may be a bit boring
21:03:16 <pentace> n is not given at compile time
21:05:36 <pentace> traversing the complete array once and find all minima of each (n-1)-element block might be a first step because there cannot be two minima within such a block
21:05:57 <pentace> but I'm not sure what to do with the results
21:07:50 <path[l]> pentace: if I understand correctly, you have a list and you want to be able to answer arbitrarily many queries about the minimum element between 2 indices?
21:08:47 <Gracenotes> hm, I might have misread your notation... you're looking for a slice of a given size with the minimum maximal element over all slices.
21:09:22 <path[l]> oh heh nm, I too thought you were looking for RMQ
21:10:49 <Gracenotes> pentace: nonetheless, like in RMQ, this data structure will probably be useful: https://en.wikipedia.org/wiki/Cartesian_tree
21:10:53 <pentace> Sorry, I'm not sure I'm able to give an exact definition :S
21:11:04 <Gracenotes> it results in potentially linear searches, though
21:11:55 <Gracenotes> and it is adaptable for any n dynamically... but takes preprocessing...
21:13:09 <Gracenotes> what is varying in your problem? Are you processing many such lists? Is there likely to be duplicate solutions in a given list?
21:13:31 <pentace> The list is fixed but the n may vary
21:16:04 <Gracenotes> okay. there may be some clever way to do it for all n in linear time, but Cartesian trees is *a* way to do it for a single n in possibly linear time.
21:17:21 <Gracenotes> There are so many problems you can come up with of this flavor, they have a similar toolbox for solving them. There is probably a paper somewhere dedicated to this variant.
21:22:02 <pentace> Gracenotes: So I have to build a new tree for every new n?
21:25:12 <kallisti> this channel so fat.
21:28:55 <Gracenotes> pentace: no, same tree for every n.
21:32:26 <pentace> Okay, thanks. Trying to understand that tree ...
21:36:43 <Gracenotes> It's just one way to do it, though, there are probably others. For a general feel, https://community.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor
21:40:47 <flebron> Does something like this make sense in monadic ST code? if rx > ry then writeArray foo bar baz else writeArray foo baz bar
21:44:36 <stevejb> greetings, quick question on understanding fromIntegral
21:44:51 <stevejb> in ghci, > (fromIntegral 10) + 3.4 works as expected
21:45:03 <stevejb> however, if I do `let y = fromIntegral 10`
21:45:09 <stevejb> and then > y + 3.4
21:45:11 <stevejb> that does not work
21:45:41 <Nisstyre> :t fromIntegral 10
21:45:42 <lambdabot> Num b => b
21:46:02 <flebron> If you check :t y, y will be of type Integer
21:46:14 <Nisstyre> :t let t = fromIntegral 10 in t
21:46:15 <lambdabot> Num b => b
21:46:16 <Nisstyre> hmm
21:46:30 <stevejb> what does the `in t` do?
21:46:39 <Nisstyre> I kind of expected defaulting to happen there, whatever
21:46:43 <Nisstyre> anyway it's defaulting to Integer
21:47:04 <stevejb> Nisstyre: so, how do I say that I have a number that is "ready" to act as a double
21:47:12 <stevejb> that was at some point an integer
21:48:03 <Nisstyre> > let y = (fromIntegral 10) :: Double in y + 3.4
21:48:04 <lambdabot>   13.4
21:48:05 * hackagebot typesafe-endian 0.1.0.1 - Enforce endianness with types  http://hackage.haskell.org/package/typesafe-endian-0.1.0.1 (JohnEricson)
21:48:22 <shachaf> I'm not sure what "monadic" has to do with it, but I guess? It's possible I don't understand the question.
21:48:28 <shachaf> Hmm, scrolled up.
21:49:09 <stevejb> Nisstyre: I cannot keep it more general?
21:49:24 <flebron> shachaf: I'm writing that expression inside a "do". That will do the right thing, correct?
21:49:38 <Nisstyre> stevejb: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/interactive-evaluation.html
21:49:45 <stevejb> Nisstyre: thanks!
21:49:49 <Nisstyre> see section 2.4.5
21:49:52 <flebron> The expression being evaluated will be the correct one, and evaluating it will carry out the action in the ST monad.
21:50:00 <shachaf> flebron: That depends on what the right thing is.
21:50:42 <stevejb> Nisstyre: so, this will work in compiled code, but not ghci since when I interact it is forced to type it?
21:50:45 <flebron> shachaf: if a then b else c, even inside a do, will evaluate b or c depending on whether a is true or not. Evaluating that conditional, then, will evaluate either b or c, and evaluating either of those carries out their respective computation in the ST monad.
21:51:28 <shachaf> flebron: You want to know about execution, not evaluation.
21:51:43 <shachaf> Evaluating an ST action does approximately nothing.
21:51:57 <shachaf> The answer is yes. You can test that yourself easily enough.
21:52:10 <flebron> shachaf: So evaluating "writeArray foo bar baz" does nothing? Well, I guess when this is passed to runST.
21:52:15 <shachaf> do { if True then print 1 else print 2 } with IO or something.
21:52:27 <shachaf> flebron: No, but executing it (which is probably what you meant) will write to the array.
21:52:51 <flebron> By executing do you mean passing the result of that do to runST?
21:53:33 <shachaf> I mean "execute" in a more general sense, but sure, sort of.
21:53:51 <flebron> I translated this correctly, then? http://ideone.com/XAYriv
21:53:55 <shachaf> E.g. executing (a >> b) is executing a and then executing b.
21:54:03 <Nisstyre> stevejb: I should've linked this instead http://www.haskell.org/onlinereport/decls.html#sect4.3.4
21:54:07 <shachaf> I have no idea.
21:54:13 <shachaf> Did you test it?
21:54:15 <flebron> (The C code is below)
21:54:21 <flebron> Not yet, the code that tests it is a bit longer.
21:54:40 <dmj> stevejb: fromIntegral works the same regardless wether its context is monadic or not, also, let expressions in do syntax are syntactic sugar, reinterpreted by GHC at compile time.
21:56:09 <dmj> > do { let x = 5; print x }
21:56:11 <lambdabot>   <hint>:1:25: parse error on input `}'
21:58:18 <roboguy_> > do { let { x = 5 }; print x }
21:58:18 <lambdabot>   <IO ()>
21:59:04 <dmj> > let { x = 5 } in do { print x }
21:59:06 <lambdabot>   <IO ()>
21:59:20 <roboguy_> it's easy to forget those braces
21:59:27 <dmj> > let x = 5 in do print x
21:59:29 <lambdabot>   <IO ()>
22:00:06 <xunie-laptop> I'm stumped. I have an IO Integer, and an Integer. I want to divide the IO Integer by an Integer and get the result as a double and print that.
22:00:14 <xunie-laptop> I can't just divide it. What the hell, man. ._.
22:00:22 <flebron> an IO Integer is not an Integer
22:00:33 <flebron> it's an action that will do some IO, and return an Integer
22:00:35 <shachaf> xunie-laptop: You should read the FAQ on this! It has a good explanation.
22:00:38 <shachaf> @where faq
22:00:38 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:00:41 <shachaf> Section 5, I think.
22:00:52 <dmj> roboguy_: yea, I'm unsure why the above didn't work though
22:00:55 <xunie-laptop> Oh yeah, FAQ me! :3
22:01:04 <flebron> in something like C, you'd have int foo() { ... }. You can't divide foo / 5, but you can execute foo, and then divide the result by 5.
22:01:37 <shachaf> I think comparing to C in general makes for bad analogies.
22:02:02 <johnw> unless you want to talk about curved things that look like horseshoes
22:02:03 <shachaf> As we can tell by the way you were confusing evaluation and execution a little while ago. :-)
22:02:04 <roboguy_> dmj: I think it has something to do with a let statement potentially having multiple bindings defined in it. but I don't actually understand why they made the braces necessary, since you don't need them for a "let ... in ..."
22:02:26 <flebron> I remember that question is the same question I asked here when I was 18, quite a few years ago :) I wanted to make a test suite for my uni projects, and wanted to make a counter for how many tests had failed. I was weirded out I couldn't just... you know... print the counter :)
22:02:40 <Nisstyre> > return (3/undefined) :: IO Float
22:02:41 <lambdabot>   <IO Float>
22:05:28 <xunie-laptop> Alright, let me rephrase. I have a function that returns an IO Integer, without printing it directly, how can I use it to pass to a function or perform some computation 'on it'?
22:05:42 <dmj> roboguy_: I thought I read in the docs that any let expression in a do block (ex: let x = 5) gets interpreted as a do statement inside of the "in" portion of a "let in" statement
22:06:08 <johnw> > (return 3 :: IO Int) >>= return . (+1) >>= print
22:06:10 <lambdabot>   <IO ()>
22:06:22 <shachaf> xunie-laptop: Various ways. This is a local question but it might have a non-local answer.
22:06:23 <johnw> (also prints 4 in ghci)
22:06:32 <roboguy_> dmj: hmm. actually, now that I think about it "do let x = 1; y = 2; print x" would be a little weird
22:06:36 <shachaf> There's no way to "turn IO Integer into Integer", I can tell you that.
22:06:42 <shachaf> @quote /bin/ls
22:06:42 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:06:47 <shachaf> xunie-laptop: Did you read section 5 of the FAQ?
22:07:13 <xunie-laptop> I'm reading it as we speak, yes.
22:07:14 <xunie-laptop> Hang on.
22:07:22 <shachaf> Here's an example: foo :: IO Integer; main :: IO (); main = do { x <- foo; print (x * 5) }
22:07:54 <shachaf> OK, no point in retyping things that are already written in it!
22:09:51 <dmj> > do { let { x = 5; y = 5; }; print x }
22:09:52 <lambdabot>   <IO ()>
22:09:56 <dmj> > let { x = 5; y = 5; } in do { print x }
22:09:57 <lambdabot>   <IO ()>
22:10:29 <flebron> Inside the IO monad, " <- " is used to get the value that the computation produces, and bind it to some name. So "x <- foo" means binding x to the value that foo produces, when run.
22:10:49 <flebron> This doesn't run the computation per se, it gives you another computation, but now "x" has a name :)
22:11:44 <Nisstyre> > ((return 3) :: IO Int) >>= \a -> print a >>= \_ -> return "a"
22:11:45 <lambdabot>   <IO [Char]>
22:15:21 <Nisstyre> btw, I think this applies to the whole "zomg monads" thing rather well http://youtu.be/36GT2zI8lVA
22:15:45 * mikeplus64 wishes ghc was a bit better at turning fromInteger (fromSing n) :: Int into I# n
22:15:54 <flebron> heh
22:16:06 <mikeplus64> it's a tiny, tiny insignificant check but an unecessary one
22:16:26 <Nisstyre> just replace "magnets" with "monads"
22:17:20 <newsham> not burritos?
22:17:39 <Nisstyre> newsham: nope, the point of the video is that you can't understand some things as anything else
22:17:42 <mikeplus64> (and means that ghc doesn't evaluate expressions like "fromInteger (fromSing (sing :: Sing n)) * fromInteger (fromSing (sing :: Sing m)) :: Int" at compile time :()
22:18:30 <Nisstyre> newsham: none of those stupid analogies helped me understand the concept
22:18:45 <newsham> so you're trying to say monads are just like magnets because they cant be understood through analogy?
22:19:04 <newsham> the irony is rich with this one
22:19:08 <Nisstyre> newsham: sort of, not really, it's more the point about understanding something in a framework
22:19:10 <Nisstyre> vs. by analogy
22:20:00 <Nisstyre> newsham: also yes it is kind of ironic to understand why analogies are bad by an analogy
22:20:00 <roboguy_> mikeplus64: I thought Int was pretty much a type synonym for I#
22:20:39 <shachaf> roboguy_: Not at all. They even have different kinds.
22:21:26 <roboguy_> shachaf: aren't they pretty closely connected to each other though?
22:21:35 <mikeplus64> roboguy_: data Int = I# Int#
22:21:52 <shachaf> Er, by I# I assumed you meant Int#
22:21:56 <shachaf> I# isn't even a type.
22:22:07 <newsham> ps: burritos also cannot be understood by analogy
22:22:11 <shachaf> This was a bad assumption, of course.
22:22:39 <mikeplus64> shachaf: it could be a type in with a bit more magical DataKinds :)
22:22:45 <mikeplus64> s/in //
22:23:35 <flebron> What is a way to do the following: Walk a list L, and carry out some actions (updating some STRef), until said reference reaches some value, and then stop walking the list.
22:23:43 <roboguy_> does I# represent some kind of "implicit" data constructor?
22:24:04 <roboguy_> implicit might not be the right word
22:24:05 <flebron> I was thinking Control.Monad.Loops' whileM_, but I didn't know how to do the list-walking part.
22:24:45 <mikeplus64> roboguy_: it makes a regular haskell type out of the unboxed type Int#
22:24:54 <roboguy_> mikeplus64: ahh, okay
22:25:09 <roboguy_> mikeplus64: so Int *is* boxed then?
22:25:15 <mikeplus64> yeah
22:25:29 <roboguy_> I guess it would have to be
22:25:44 <volitek> How do I get the nth Word32 in a bytestring? I'm reading the Data.Binary and Data.Bytestring stuff and it makes no sense to me :(
22:25:52 <johnw> flebron: untilM (updateRef) (checkRef)?
22:26:06 <flebron> johnw: How would I do the list-walking part?
22:26:23 <johnw> ah, then foldM
22:26:45 <newsham> whats the nth word32 in a bytestring?
22:26:46 <mikeplus64> roboguy_: but, nicely, ghc optimisations can and do turn functions on Int into functions on Int#
22:26:52 <newsham> a bytestring is not a sequence of word32s
22:26:52 <johnw> foldM (\_ x -> unless checkRef $ updateRef x) () xs?
22:27:03 <newsham> do you mean you want to treat groups of 4-bytes as a word32, and then find the nth one?
22:27:14 <johnw> oh, it would have to be y <- checkRef ; unless y ...
22:27:32 <volitek> I assumed I have to do the skip 4*n in Data.Binary.Get and then getWord32le
22:27:39 <roboguy_> mikeplus64: that's cool
22:27:40 <flebron> johnw: If I evaluate that, do I need to evaluate the whole list? No, right?
22:27:41 <volitek> but I don't know how to write that
22:27:59 <volitek> newsham: yes, thats what i want to do
22:28:21 <johnw> flebron: hmm... maybe it wuold
22:28:23 <newsham> volitek: take your bytestring-word8 library and yoru bytestring object, use the libraries drop function to drop 4*n of the items, and then take 4 of the items
22:28:42 <newsham> now you have 4 bytes.  you can at that point "manually" convert them to a word32 if you want to
22:28:55 <newsham> or you can use the Data.Binary.Get package to do it, but that would prob be as much or more work
22:29:01 <xunie-laptop> Okay, so I read the FAQ, I read as much as I could, I like to think I have a basic understanding of things now. But why on EARTH isn't this working?:
22:29:01 <xunie-laptop> main = getCPUTime >>= (return . fromIntegral) >>= (return . (\x -> (x/cpuTimePrecision))) >>= print
22:29:13 <volitek> oh okay, ill try that way
22:29:37 <newsham> do you want them as little endian?  lets say you have 4 bytes [a,b,c,d] all word8s
22:30:04 <johnw> flebron: there are several ways to short-circuit such a computation
22:30:20 <flebron> johnw: Such as?
22:30:26 <newsham> you should first convert each to a word32, then do:   a | (b << 8) | (c << 24) | (d << 32)   (but using haskell's weird shiftR and .|. operators instead of my c ones)
22:30:34 <newsham> and you'll have a 32-bit value
22:30:40 <johnw> flip runContT return $ callCC $ \exit -> foldM (\_ x -> ... else exit ()) ...
22:31:04 <mikeplus64> xunie-laptop: the error says no instance for Fractional Integer, and cpuTimePrecision isn't an Integer, so you have to convert it into something with an instance for Fractional, like Double or Float
22:31:05 <newsham> make sense?
22:31:20 <mikeplus64> xunie-laptop: or use div or quot, which are integer divides
22:31:33 <xunie-laptop> I just realized that.
22:31:37 <xunie-laptop> Hang on.
22:31:44 <flebron> johnw: Does that work well within ST? (I've never used more than one monad that way :s)
22:31:58 <johnw> ContT should work with ST as the base monad
22:32:02 <xunie-laptop> Oh god.
22:32:02 <xunie-laptop> It works.
22:32:03 <xunie-laptop> IT WORKS
22:32:21 <newsham> hmm.. the Data.Binary.Get mightnot be too hard either.. if you pared it down to the 4-byte bytestring youw ant, in "bs" then its just:  runGet getWord32le bs
22:32:21 <johnw> I tend to write: where scoped = flip runContT return . callCC a lot too
22:32:28 <xunie-laptop> Hahah, oh god. It all makes sense now. You guys are awesome. I hope this will make you feel all warm and fuzzy inside.
22:32:38 <newsham> thats probably easier
22:33:57 <overdamped> electromagnetism is often explained by analogy to water flow
22:34:09 <bscarlet> :t foldM_
22:34:09 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m ()
22:34:14 <newsham> an analogy is like a metaphore.
22:34:27 <flebron> a metaphore is like a semaphore about semaphores
22:34:54 <overdamped> I'm deadlocked here
22:36:25 <applicative> so runGet getWord32le . take 4 . drop (4*n)  , newsham?
22:37:41 <newsham> volitek: http://www.thenewsh.com/~newsham/x/machine/get32.hs  works
22:39:20 <applicative> ah you just get the getWord32le from the remaining bs
22:40:25 <volitek> newsham: I've got to the bit where you have a list of four Word8s... struggling to figure how to convert it to a word32
22:41:10 <volitek> aaah so I just do runGet? cool
22:41:27 <applicative> concat them into a bystring for that thoug
22:41:34 <applicative> pardon typing
22:42:29 <applicative> pack [w8',w8'',w8''',w8] rather
22:44:25 <newsham> applicative: see url above
22:45:17 <applicative> yes i saw it wasnt necessary, he just mentioned his list
22:52:51 <volitek> I get Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString' with actual type `BS.ByteString' :(
22:54:52 <newsham> volitek: alternatively, make a stream of int32's and pick the nth one?  http://www.thenewsh.com/~newsham/x/machine/get32b.hs
22:55:24 <newsham> volitek: hmm.. where did you get your bytestring from?
22:55:46 <newsham> and where did you get that error?
22:56:07 <shachaf> volitek: There are two ByteString types: lazy ByteString and strict ByteString
22:56:28 <shachaf> Data.ByteString, Data.ByteString.Internal, etc. all use strict ByteString.
22:56:37 <shachaf> Data.ByteString.Lazy, Data.ByteString.Lazy.Internal, etc. all use lazy ByteString.
22:57:07 <newsham> bytestring is pretty cool, but its definitely a bit confusing when you start learning them. :(
22:57:08 <shachaf> Since you have an error where you can't match two ByteString types, that would probably imply that BS is Data.ByteString (but you should tell us instead of making us guess!)
22:57:19 <shachaf> By tell us I mean "paste your code, instead of just giving an error with no code".
22:57:21 <newsham> its too bad something so basic has such a learning curve
22:58:16 <lpaste> stevejb pasted “typing in lambdas” at http://lpaste.net/2158847341191233536
22:58:58 <stevejb> hello, I have a question about the above paste, trying to get the types to work out. dpi and dnpi should be doubles
22:59:28 <stevejb> but, ghci seems to think that dpi is an Int
23:00:23 <volitek> newsham: this is what i had http://pastebin.com/vH2E6Kjv
23:01:20 <lpaste> stevejb pasted “the error” at http://lpaste.net/91073
23:01:42 <newsham> you didnt paste enough.. but it appears yoru error is in your import.
23:01:50 <newsham> can you use the import from my example?
23:02:47 <shachaf> stevejb: What is the type of -?
23:02:50 <shachaf> (-), I mean.
23:03:12 <stevejb> just the standard one (-) :: Num a => a -> a -> a
23:03:17 <shachaf> Right.
23:03:23 <shachaf> What's its type in this case?
23:03:33 <shachaf> You have two (-)s there but they should have the same type.
23:03:52 <shachaf> (I'm asking what "a" is.)
23:04:04 <stevejb> so, when I am making a function with the lambda, I thought that it would infer that.
23:04:14 <shachaf> It is.
23:04:18 <volitek> newsham: Yeah, that changed the error, I forgot the .Lazy in the import
23:04:20 <shachaf> Now it's your turn to infer it. :-)
23:04:25 <stevejb> :)
23:04:29 <shachaf> So?
23:04:45 <volitek> Now it's complaining that n isn't a GHC.Int.Int64 when you times it by 4
23:04:56 <stevejb> well fromIntegral gives me a Num
23:05:03 <stevejb> so, I would assume that dpi is also a num
23:05:07 <shachaf> Num isn't a type.
23:05:18 <shachaf> What's "a" here? It's concrete.
23:05:35 <shachaf> There are two numeric types here, namely Double and Int.
23:05:40 <shachaf> Which one is "a'?
23:05:43 <shachaf> s/'/"/
23:06:35 <stevejb> well, I since I am not specifying what dpi is, then I would assume it infers the type from (fromIntegral si), which ends up being Int?
23:06:36 <joelteon> ahh, using times as a verb
23:07:16 <shachaf> OK, let me try to say what I mean differently.
23:07:32 <shachaf> stevejb: (-) takes two arguments of some type and returns a value of the same type.
23:07:49 <volitek> newsham: aha, fixed it, thanks so much!!
23:08:03 <shachaf> stevejb: So: What are the types of: dpi, (fromIntegral si), and (inner_t dpi dnpi (fts dnpi))?
23:08:09 <shachaf> They all have to match. Do you see why?
23:08:28 <stevejb> ah I see
23:09:15 <NemesisD> anyone know of any tools/techniques for analyzing an executable cabal project and creating export lists for modules
23:09:16 <stevejb> since  (inner_t dpi dnpi (fts dnpi)) is Int, then that forces (fromIntegral si) to be an Int as well
23:09:22 <stevejb> which forces dpi to be Int?
23:09:37 <shachaf> Well, they all have to be the same type, at any rate.
23:09:54 <shachaf> If dpi :: Double and (inner_t dpi dnpi (fts dnpi)) :: Int, it won't work.
23:10:09 <stevejb> so, I need to do fromIntegral on the result of inner_t?
23:10:30 <shachaf> Does that do what you want?
23:11:09 <stevejb> shachaf: I will have to see. Still new at this.
23:11:50 <stevejb>  let     thr_fs = (\dpi dnpi -> dpi - (fromIntegral si :: Double) - (fromIntegral ( inner_t dpi dnpi (fts dnpi)) :: Double) )
23:11:54 <stevejb> this seemed to do what I wanted
23:13:02 <shachaf> The answer is probably yes.
23:16:02 <arkeet> stevejb: fwiw, you only have to specify Double once.
23:16:19 <stevejb> arkeet: thanks
23:16:23 <stevejb> shachaf: thank you as well
23:16:29 <arkeet> and if you gave a type signature for thr_fs, you wouldn't have to write it in the definition at all.
23:16:52 <shachaf> arkeet's advice is good.
23:17:27 <stevejb> arkeet: so, rather than anonymous functions, make them regular functions with type signatures?
23:17:52 <arkeet> well, the lambda part is independent of that.
23:17:55 <shachaf> "anonymous" has nothing to do with it.
23:18:04 <shachaf> First of all, that thing isn't "anonymous". You're giving it a name.
23:18:14 <shachaf> Second, you can give anything a signature, function or not. "x :: Int; x = 5"
23:18:17 <arkeet> I assume he was talking about the lambda.
23:18:30 <stevejb> arkeet: yeah, I was
23:18:39 <shachaf> Right, but "f x = y" means "f = \x -> y"
23:18:50 <stevejb> okay, so I can give a type signature at any point, even within other typed functions?
23:19:05 <shachaf> Yes.
23:19:05 <arkeet> you can give a type signature together with any definition.
23:19:11 <stevejb> wow this stuff is cool! thanks!
23:19:17 <stevejb> this helps a lot
23:19:52 <stevejb> so, when I am debugging in ghci, can I supply a type signature to ghci as well?
23:20:10 <arkeet> yes, but you'll have to put it on the same line
23:20:15 <arkeet> let foo :: Int; foo = 10
23:20:36 <arkeet> either that or use multi-line input. but that's kind of annoying.
23:20:37 <stevejb> ok, awesome
23:21:36 <shachaf> stevejb: Note that "f = \x y -> ..." means the same thing as "f x y = ..."
23:22:23 <arkeet> well, there are subtle differences
23:22:36 <arkeet> writing f = \x y -> ... is a nice way to get bitten by the monomorphism restriction.
23:22:56 <shachaf> Yes. I was going to mention that and then decided not to.
23:23:09 <stevejb> arkeet: I will have to look into that
23:23:45 <arkeet> it's something everyone runs into sooner or later
23:25:21 <arkeet> e.g. try in ghc
23:25:26 <arkeet> let f = \x -> x + x
23:25:29 <arkeet> f 2.5
23:25:52 <arkeet> er, ghci
23:26:23 <arkeet> and then read
23:26:25 <arkeet> @where dmr
23:26:25 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:26:38 <stevejb> ah I see, instance declaration for (Fractional Integer)
23:26:52 <stevejb> arkeet: thank you for the reference.
23:26:56 <arkeet> yes, observe :t f
23:27:17 <arkeet> generally, if something has a more restrictive type than you intended, it's probably the dmr.
23:28:05 <stevejb> what does the d mean?
23:28:12 <arkeet> "dreaded", I'm told.
23:28:25 <arkeet> I prefer other adjectives.
23:28:30 <shachaf> "delicious"
23:28:42 <arkeet> so does shachaf.
23:29:14 <stevejb> :)
23:35:44 <flebron> Hi. I'm not understanding GHC's error message here: http://ideone.com/s5PhLs . What am I doing wrong? Both kruskal and solveChained seem to have the right types.
23:37:09 <shachaf> flebron: You can't take an STUArray out of the ST that you made it in.
23:37:15 <flebron> Oh.
23:37:24 <shachaf> That's the point, sort of.
23:37:33 <flebron> So I can't reuse that STUArray for a bunch of computations like that?
23:37:57 <shachaf> I don't know.
23:38:01 <johnw> flebron: why not have solveChained return ST s [Int]?
23:38:03 <shachaf> You can have one big runST.
23:38:13 <shachaf> What johnw said is what you would have to do.
23:38:41 <flebron> It could, I see no issue with that. That wouldn't be "taking the STUArray out"?
23:39:00 <shachaf> My explanation was too abbreviated to be useful.
23:39:11 <shachaf> You should understand how ST works, ideally.
23:39:54 <shachaf> You can pretend it's like IO, except with restricted operations (of course), and you create a whole new IO every time you runST.
23:40:08 <shachaf> And things from different ones can't mix.
23:40:17 <shachaf> I think my explanation is a bad one here.
23:40:17 <flebron> Ah, OK.
23:40:32 <flebron> That's the 's'.
23:40:41 <shachaf> Right.
23:40:48 <flebron> I can have ST s (ST s x) -> ST s x, but I can't have ST s (ST s' x) -> ST s x
23:40:53 <shachaf> Yep.
23:41:18 <flebron> Cool, OK, makes sense. That's the entire purpose of s? Not to mix contexts?
23:41:32 <flebron> (What _is_ it?)
23:41:34 <shachaf> More or less, yes.
23:41:41 <shachaf> It doesn't matter what it is.
23:41:49 <shachaf> It can be () for all you care.
23:42:13 <flebron> Oh, it really can have no particular value. As in, it really could be ().
23:42:39 <shachaf> You don't get to pick what s is.
23:42:41 <shachaf> runST gets to pick.
23:42:50 <shachaf> The point is that you don't know, so you can't take any chances.
23:43:01 <flebron> That's the "forall".
23:43:06 <shachaf> Yep.
23:43:16 <flebron> OK, cool. Thanks :)
23:43:23 <Gracenotes> it just so happens that all of your code in ST is written to take anything
23:43:45 <Gracenotes> almost as though the API has forced you :o
23:47:11 <johnw> flebron: the 's' is what we call a "phantom type".  it's used to distinguish types at compile time that would otherwise be identical
23:48:15 <shachaf> s isn't actually phantom, exactly.
23:48:25 <shachaf> Well, maybe indirectly.
23:48:30 <shachaf> Not that it matters here. You don't know.
23:48:45 <johnw> true, I shouldn't presume to state what the implementation of ST might use s for
23:49:57 <shachaf> In the actual implementation of runST, s becomes RealWorld.
23:50:02 <shachaf> Not that you should care.
23:50:09 <dmj> this is a cool video, bos's haskell story: http://vimeo.com/6703480
23:50:20 <johnw> the beauty is, I can't even if I wanted to :)
23:52:08 <mstksg> is there an expressive way to let three fields of a data constructor be the three values of a list?
23:52:23 <shachaf> That depends.
23:52:28 <Gracenotes> lists can have more than three values, right?
23:52:35 <shachaf> Do you have a concrete example?
23:52:36 <mstksg> er in this case, it's guarunteed to be 3
23:52:56 <arkeet> s stands for skolem.
23:53:01 <arkeet> who guarantees it to be 3?
23:53:02 <mstksg> um i have time = [8,19,3]
23:53:07 <mstksg> a case statement does
23:53:15 <mstksg> data Time = Time Int Int Int
23:53:20 <Gracenotes> shachaf: any fancy lens things to do that?
23:53:42 <mstksg> and the numbers represent h, m, s
23:53:55 <shachaf> arkeet: skolem? i've never met 'em!
23:54:04 <mstksg> if time is of length 0, i return Time 0 0 0; if it's of length 1, i return Time h 0 0
23:54:10 <shachaf> mstksg: If you make data Time a = Time a a a, then you can derive Foldable and use toList.
23:54:15 <mstksg> if it's of length 2, Time h m 0
23:54:18 <Gracenotes> so, the list is a base 60 number in reverse representation?
23:54:31 <shachaf> Otherwise, not really. You can use Data.Data or similar (e.g. Data.Lens.Plated) but that's awful.
23:54:31 <mstksg> yes
23:54:42 <shachaf> Oh, wait.
23:54:47 <shachaf> You wanted it the other way around.
23:54:57 <mstksg> i guess i cound restructure everything into just keeping the track of seconds
23:55:04 <shachaf> That phrasing was confusing!
23:55:39 <mstksg> okay i can look into Foldable
23:55:50 <shachaf> Foldable does the opposite of what you want.
23:55:55 <arkeet> mstksg: there isn't really anything better than the obvious thing. besides avoiding using a list.
23:55:55 <arkeet> wait.
23:55:55 <arkeet> do you want to convert [Int] to Time or Time to [Int]?
23:55:57 <arkeet> for [Int] to Time there's nothing nice.
23:56:01 <arkeet> Foldable turns things into lists.
23:56:06 <shachaf> arkeet: Well...
23:56:11 <mstksg> i'd like [Int] to Time
23:56:23 <shachaf> arkeet: There's partsOf. But that's awful.
23:56:25 <arkeet> for some definition of English.
23:56:28 <shachaf> In fact I shouldn't even mention it. Sorry.
23:56:40 <mstksg> i guess I might just represent everything in number of seconds
23:56:49 <arkeet> that's probably better.
23:56:51 <mstksg> otherwise right now i'm just doing it by hand
23:57:00 <arkeet> I don't like inappropriate use of lists
23:57:15 <shachaf> No one likes inappropriate uses of lists.
23:57:19 <shachaf> Except lispers.
23:57:36 <mstksg> well the list comes from the use of sepBy, which grabs instances of 'digit digit' separated by colons and returns a list
23:57:42 <mstksg> in parsec
23:57:47 <shachaf> @quote monochrom lisp
23:57:47 <lambdabot> monochrom says: in retrospect, it seems lisp designers were more interested in list processing than functional programming
23:57:56 <Lethalman> type families are complex :S
23:57:59 <Ghoul_> was there a regression or something :|
23:58:14 <Ghoul_> java is so far ahead in the x64 quadcore language benchmark game right now
23:58:21 <Ghoul_> I swear it was only last month they were equal
23:59:01 <arkeet> -blah
23:59:02 <mstksg> is there a better way to turn a string like 'hh:mm:ss' (which can be missing hh, mm, or ss) into Time Int Int Int, where the value is 0 if it's missing?
23:59:30 <johnw> Ghoul_: link?
