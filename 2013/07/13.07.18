00:04:13 <mstksg> can anyone explain to me what "def" means here?
00:04:25 <mstksg>  (readWith parseMarkdown) def{ stateOptions = opts }
00:04:34 <mstksg> is it a keyword?
00:04:39 <dmj> no
00:04:40 <MasseR> mstksg: No. It's a function
00:04:41 <mstksg> is it a type?
00:04:47 <MasseR> Or a variable
00:04:54 <dmj> that looks like record update syntax to me
00:05:10 <shachaf> MasseR: No, it's a value.
00:05:20 <mstksg> so it's returning a "def" with an updated stateOptions record?
00:05:27 <MasseR> mstksg: Yes
00:05:30 <shachaf> ghci can tell you more with :t
00:05:43 <mstksg> ah thanks
00:05:57 <mstksg> :)
00:08:15 <mstksg> was having trouble cause i can't really seem to find where it's defined.  it's not an argument in the function so i guess it must be a global?
00:08:44 <shachaf> Try :i
00:09:27 <mstksg> shachaf: thanks :)  i'll try; didn't know about :i
00:09:58 <dmj> mstksg: In pandoc there is Default class that defines def. Re-exported in Text.Pandoc.Options
00:10:03 <dmj> http://hackage.haskell.org/packages/archive/pandoc/1.11.1/doc/html/src/Text-Pandoc-Options.html
00:10:06 <shachaf> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=def
00:10:35 <dmj> that works better
00:10:45 <mstksg> thanks all
00:15:40 <mr-> heh, wedel
00:16:20 <dmj> is there no longer a Data.ByteString.Strict?
00:16:58 <shachaf> Was there ever?
00:17:16 <dmj> this stanford lecture has "import qualified Data.ByteString.Strict as S"
00:17:38 <dmj> http://www.scs.stanford.edu/11au-cs240h/notes/iteratee-slides.html#(1)
00:18:02 <mr-> maybe they had their own library?
00:18:09 <shachaf> That's probably pseudocode.
00:18:24 <shachaf> My guess is that they meant Data.ByteString.
00:18:33 <mr-> there is a data.bytestring.strict.lens
00:19:30 <shachaf> Yes. I wrote some of the code for that.
00:19:35 <shachaf> It's for Data.ByteString.
00:20:29 <dmj> shachaf: ah thanks
00:22:45 <mr-> Fitting.. http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=960526295&k=GRjswk9&lb=1&s=A
00:31:26 <dmj> mr-: lol, these are funny
00:44:40 <Ghoul_> some of the lambdacat ones I dont get ;(
00:45:33 <CADD> i love lambdacats XD
00:48:17 <dmj> ceiling cat is watching you unsafePerfromIO
00:55:23 * hackagebot papillon 0.0.47 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.47 (YoshikuniJujo)
00:58:12 <Gracenotes> I will ruin the joke of any lambdacat you don't get :)
01:01:01 <Gracenotes> some of em are a stretch though
01:04:27 <dmj> Gracenotes: tagged cat jumps more predictably?
01:06:15 <Gracenotes> @where ptr-tag
01:06:15 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
01:07:45 <Gracenotes> with these fancy branch predictors, it's less efficient (but more cool-sounding) to implement case expressions as blind jumps into alternative continuations
01:08:31 <Gracenotes> rather, just use a simple if statement/static jump-ahead table against an integer tag
01:10:44 <mstksg> is there any way to get access to a function not exported by a module?
01:10:58 <mstksg> a force export?
01:11:02 <supki> no
01:11:14 <mstksg> :(
01:12:03 <dmj> Gracenotes: over my head, will need to read spj's article
01:30:14 <jxm> So, yeah, I have no particular question or request for help, docs and src are pretty much all that I needed
01:30:33 <jxm> But as I just got started using i3, I thought I would come hang out here a bit, and say hello
01:30:40 <jxm> Maybe have a little chat with you guys
01:31:04 <jxm> I am an xmonad (and dwm a long time ago) switcher
01:31:17 * jxm is sorry - wrong chan
01:32:51 * jxm is glad that he did not paste here his #my_super_animal_porn_chan_for_pervs conversations ;-)
01:33:39 <leonhuang> hello, everyone. Would you plz tell me how to import self-defined module in Haskell 7.6?
01:34:42 <dmj`> leonhuang: what have you tried?
01:35:25 <leonhuang> I did it as Learn You a Haskell for Great Good! does, and I get "Could not find module `Geometry.Cube'"
01:36:14 <merijn> leonhuang: GHC will look for a file named Cube.hs (or Cube.lhs) in the directory Geometry
01:37:02 <leonhuang> OMG, I misspelled the word
01:37:05 <leonhuang> Thank you
01:37:14 <leonhuang> and sorry for my disturbing
01:37:50 <merijn> leonhuang: It happens :)
01:38:13 <supki> I wich ghc could also look for a file name Geometry-Cube.l?hs in the directory . :-(
01:39:11 <Taneb> I am finally working on Wordeger
01:39:17 <leonhuang> supki: I tried and failed
01:39:46 <supki> leonhuang: yeah, that's not how ghc works sadly
01:40:30 <leonhuang> supki: maybe it's ambiguous
01:43:38 <supki> sure it is, but ghc could error when you have both A-B.hs and A/B.hs
01:44:44 <quchen> That would also make it painful to find things in a large source tree.
01:44:44 <supki> I just don't like how directory trees make flat module structure look hierarchical
01:44:51 <quchen> Foo/Bar-Baz/Qux
01:50:18 <joergfritsch> I want to encode and decide bitfields into byte strings
01:50:34 <joergfritsch> can I use Data.Bitsyntax for this?
01:50:47 <joergfritsch> Is not quite clear to me if this meets what I want
01:54:17 <Taneb> Okay, I have implemented fromInteger and (+) for Wordegers
01:55:42 <quchen> Wordegers? Unbounded Word, that is?
01:56:51 <Taneb> Precisely
01:57:17 <Taneb> I've been meaning to write them for a while, unsatisfied with existing alternatives
01:58:24 <sexlove69> hi
01:58:42 <joergfritsch> Data/BitSyntax.hs:1:1:
01:58:42 <joergfritsch>     Ambiguous module name `Prelude':
01:58:42 <joergfritsch>       it was found in multiple packages: base haskell98-2.0.0.2
01:58:44 <joergfritsch> cabal: Error: some packages failed to install:
01:58:55 <joergfritsch> How would I fix this: HOw can I fix this?
01:59:21 <merijn> Why is it trying to use haskell98 are you installing something ancient?
02:01:54 <sexlove69> !!New sex tape hollywood (you must click ok Button before) >> http://apps.facebook.com/316328471834749/?referral_id=100000513678994
02:08:02 <Taneb> @where ops
02:08:03 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
02:08:03 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:08:23 <mauke> you rang?
02:08:52 <quchen> I think it's about that spambot 7 minutes ago.
02:08:52 <kranius> hello
02:08:52 <Taneb> Nevermind, sorry
02:08:57 <Taneb> Yeah
02:09:37 <quicksilver> idoru caught it faster than I probably could have even if I'd been right here
02:11:55 <Taneb> I didn't see the quit message, and I deeply apologize for the opspam
02:19:10 <Taneb> Okay, my (+) does not work
02:28:05 <Taneb> Okay, fixed the (+)
02:30:33 <quicksilver> Taneb: no need to apologise, better to be that way around than the other
02:30:44 <Taneb> :)
02:32:01 <benokit> hi, can I write "foo xs ys = sequence_ $ zipWith (\x y -> bar x y) xs ys" more compactly?
02:33:44 <quchen> (\x y -> bar x y)   ==>   bar
02:34:12 <quchen> sequence (zipWith ...) = zipWithM
02:34:26 <quchen> benokit: ^
02:34:31 <benokit> yes but compiler complaines about "foo = sequence_ $ zipWith bar"
02:34:53 <Taneb> foo xs ys = sequence_ $ zipWith bar xs ys
02:35:03 <quchen> foo = zipWithM_ bar
02:35:17 <quchen> Ah wait
02:35:21 <Taneb> @type zipWithM_ ?bar
02:35:22 <lambdabot> Not in scope: `?'
02:35:22 <lambdabot>     Not in scope: `bar'
02:35:22 <lambdabot>     Perhaps you meant one of these:
02:35:26 <quchen> foo xs ys = zipWithM_ bar xs ys
02:35:40 <benokit> ok thanks, I was searching for zipWithM_ actually
02:36:18 <quchen> zipWithM_ ... = zipWith … >> return ()
02:37:19 <benokit> thanks again
02:38:16 <BoR0> @src !!
02:38:16 <lambdabot> xs     !! n | n < 0 = undefined
02:38:16 <lambdabot> []     !! _         = undefined
02:38:16 <lambdabot> (x:_)  !! 0         = x
02:38:16 <lambdabot> (_:xs) !! n         = xs !! (n-1)
02:39:18 <BoR0> @src :
02:39:18 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:40:12 <Taneb> BoR0, (:) is a data constructor for []
02:40:27 <Taneb> [] is roughly defined as data [] a = [] | (:) a [a]
02:42:00 <Tinned_Tuna> @src (:)
02:42:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:42:04 <Tinned_Tuna> :-p
03:05:12 <joergfritsch> Can someone tell me what is wrong here:
03:05:13 <joergfritsch> https://gist.github.com/viloocity/f0dc943d2889936249d3
03:07:00 <adnap> This is weird...
03:07:11 <CADD> joergfritsch: error?
03:07:12 <adnap> > (flip (-) 1) 4
03:07:13 <lambdabot>   3
03:07:21 <adnap> > (+ (-1)) 4
03:07:23 <lambdabot>   3
03:07:31 <adnap> > (- 1) 4
03:07:33 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
03:07:33 <lambdabot>    arising f...
03:07:47 <adnap> > (`-` 1) 4
03:07:48 <lambdabot>   <hint>:1:3: parse error on input `-'
03:07:52 <adnap> lol
03:08:02 <mgore> hi, anyone here who could answer a question about the haskeline library?
03:08:05 <joergfritsch> CADD:   No instance for (BitField a0) arising from a use of `setbfBit'
03:08:28 <CADD> joergfritsch: line?
03:08:36 <CADD> joergfritsch: im guessing 26?
03:08:52 <CADD> mgore: dont ask to ask, just ask
03:09:02 <mgore> k :)
03:09:05 <joergfritsch> 23
03:09:21 <joergfritsch> CADD: 23
03:09:34 <mgore> is there something equivalent to the readline action getStringBuffer :: IO String  in haskeline
03:09:36 <mgore> ?
03:10:12 <mgore> background: i have a read-eval-print-loop that needs to catch interrupts and save the characters that have been entered so far
03:10:42 <mgore> meant: getLineBuffer :: IO String
03:11:18 <supki> joergfritsch: let on line 23 is recursive
03:11:32 <supki> joergfritsch: also ghc does not know what BitField instance to choose
03:12:15 <joergfritsch> how do I choose the instance? mybf :: BitField 32 does not work either
03:13:11 <supki> :: BitField Integer
03:13:38 <joergfritsch> spuki: but is that not part of the class definition that I have on top?
03:13:47 <supki> ?
03:14:11 <joergfritsch> spuki: instance BitField Integer where
03:14:56 <supki> the fact you have instance BitField Integer isn't related to the type of mybf
03:15:05 <supki> I'm not sure what you're asking
03:16:24 <supki> there isn't "that's the only instance in scope so I choose it" rule in ghc
03:17:18 <joergfritsch> spuki: understand
03:17:44 <joergfritsch> spuki: would be helpful though, if there is only one instance in scope, what other instance should it be then :D
03:21:08 <supki> no, it wouldn't; if someone adds instance BitField Int then suddenly your code becomes ambiguous
03:21:18 <Taneb> *Data.Wordeger> 17 - 10 :: Wordeger
03:21:19 <Taneb> 7
03:21:19 <Taneb> :D
03:21:29 <supki> and you probably want to know you're writing an ambiguous code as early as you can
03:21:51 <Taneb> Now to figure out how to do multiplication
03:21:55 <supki> Taneb: wow
03:22:07 <supki> Taneb: what about (-10) :: Wordeger ?
03:22:24 <Taneb> 0, apparently
03:23:04 <supki> why not _|_
03:23:05 <Taneb> Which suggests that (- x) = negate (fromInteger x) rather than fromInteger (negate x)
03:23:32 <Taneb> supki, because I'm still writing everything?
03:23:37 <Taneb> And actually thought it would be _|_
03:23:48 <Taneb> Because I thought it would become fromInteger (negate 10)
03:23:54 <Taneb> Rather than negate (fromInteger 10)
03:23:59 <Taneb> Colour me surprised
03:24:51 <Taneb> Although perhaps this behaviour is more useful?
03:25:07 <Taneb> I'll deal with it later
03:27:24 <Lethalman> I was thinking that 0-x is simpler than negate x :S
03:27:32 <Lethalman> probably less general
03:34:25 <hpc> :t negate ?x
03:34:26 <lambdabot> Not in scope: `?'
03:34:30 <hpc> :(
03:36:19 <Lethalman> :t negate x
03:36:20 <lambdabot> Expr
03:36:25 <Lethalman> :t 0-x
03:36:26 <lambdabot> Expr
03:36:39 <Lethalman> :t \x -> 0-x
03:36:39 <lambdabot> Num a => a -> a
03:36:47 <Lethalman> well seems general enough
03:37:16 <Lethalman> :t negate
03:37:17 <lambdabot> Num a => a -> a
03:37:20 <Lethalman> indeed it is
03:43:08 <Taneb> It suddenly occurs to me that I have no idea what multiplication algorithm to use
03:44:46 <Taneb> Hmm...
03:45:03 <Taneb> Wikipedia mentions a linear-time one made by Knuth
03:59:05 <Lethalman> channel quite today
03:59:08 <Lethalman> *quiet
04:00:06 <zRecursive> strange quiet ...
04:30:15 <quchen> Taneb: If there's an algorithm by Knuth, that's probably the one you should pick.
04:30:36 <quchen> (If there's no algorithm by Knuth, it's probably not computable.) ;-)
04:30:47 <Yaniel> what is 'Literate Haskell' O.o
04:30:52 <CADD> quchen: pretty much
04:31:18 <CADD> Yaniel: literate programming is a way of writing code that everthing is automatically a comment
04:31:33 <quchen> Yaniel: It's an alternative way of formatting your source code. In literate Haskell files, every normal text is a comment, and code starts with "> " on every line.
04:31:38 <CADD> Yaniel: all the code is "uncommented" by a > at the beggining of the line
04:31:51 <sipa> Yaniel: the idea is that you write your code to be read by a human, rather than a computer
04:32:02 <Yaniel> ah
04:32:12 <sipa> Yaniel: it contains piece of code embedded in the test
04:32:22 <quchen> Yaniel: Example: http://lpaste.net/91024
04:32:22 <sipa> rather than pieces of text embedded in the code :)
04:32:33 <Yaniel> I see
04:33:06 <quchen> It's nicer if you want to explain a lot with not so much actual code.
04:33:12 <Yaniel> yep
04:33:14 <CADD> Yaniel: the idea was invented by knuth
04:36:03 <Yaniel> I suppose this is where .lhs is used as the filename extension?
04:36:09 <quchen> Yes.
04:40:22 <merijn> Yaniel: It's commonly used to write things like "executable" papers/blogposts
04:40:58 <Yaniel> and looks disturbingly much like quoted email :D
04:41:35 <simukis_> haskellers are unending well of “right to the eye” quotes.
04:42:16 <Taneb> Hmm
04:42:30 <Taneb> This implementation isn't unbounded! (oh now)
04:42:32 <Taneb> *no
04:42:57 <Taneb> Of course, the maximum is 2^maximum int
04:43:10 <Taneb> > 2 ^ (toInteger (maxBound :: Int))
04:43:17 <merijn> Yaniel: An example (the stuff is a bit complicated, so don't worry if it goes over your head) would be: http://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
04:44:23 <merijn> Yaniel: THere's two allowed syntaxes for literate haskell, either the > quoted style or a latex like style that uses \begin{code} and \end{code}
04:45:10 <tulcod> merijn: wow, does that mean you can mix latex and haskell?
04:45:36 <tulcod> ie. have a latex document that compiles as haskell
04:45:57 <merijn> tulcod: Yes
04:46:00 <tulcod> sweet
04:46:08 <Yaniel> hahah I like this :D
04:46:17 <merijn> tulcod: There's even a program to prettify/latexify the haskell code in there
04:46:39 <tulcod> well i'd just use the latex lstlisting environment
04:46:44 <merijn> lhs2TeX
04:47:50 <merijn> The literate haskell probably won't be valid latex directly, but you can automatically convert it into valid LaTeX so you can make your papers runnable
04:50:03 <quchen> It should be fairly easy to include in a minimal file.
04:50:18 <quchen> \begin{document} \input{foo.lhs} \end{document}
04:56:02 <merijn> quchen: That's not the issue, I think it's more with accidentaly latex/tex code in the haskell being interpreted by LaTeX unless escaped
04:56:17 <merijn> It's been a while since I tried, so I don't remember exactly what happened
04:56:34 <quchen> Ah, it probably doesn't escape all the hyphens etc
04:57:11 <quchen> On the other hand, why would I want my paper to be runnable - but that's an entirely different discussion.
04:57:45 <Maior> quchen: because I've seen books and papers containing code with basic compilation and logic errors and it makes me sad
04:58:17 <tulcod> quchen: because it's awesome that you and your pc can read the same document
04:59:37 <quchen> tulcod: Nobody reads Latex source.
04:59:48 <quchen> (Except to write it.)
05:00:54 * hackagebot air-extra 2013.7.18 - air-extra  http://hackage.haskell.org/package/air-extra-2013.7.18 (JinjingWang)
05:04:56 <ent> hmm
05:07:06 <merijn> quchen: arXiv encourages people to publish their TeX
05:07:25 <merijn> Which means you could run the program without having to rewrite it
05:09:11 <quchen> I find that strange for multiple reasons. 1. when is the last time you made use of that? 2. Many times, trivial program parts are skipped as papers often have length limits, 3. programs so complex you can't copy them in a minute are rarely in papers
05:09:34 <quchen> 4. Latex makes Haddock sources on Hackage awkward to read :>
05:10:05 <quchen> But I guess it hurts nobody and reminds us of the academic origins of GHC, so why not.
05:11:32 <merijn> quchen: I think more papers should be runnable
05:11:48 <merijn> quchen: Too many CS papers make claims without providing the source to verify them
05:12:16 <merijn> Providing an easy to make papers runnable is a step in the right direction
05:12:40 <quchen> Hm, that's probably true.
05:13:07 <merijn> It's similar to the call for academics to publish source together with papers
05:13:26 <quchen> Right, a lot of work in theoretical physics is published without code.
05:13:34 <quchen> (Simulation-heavy physics.)
05:13:53 <csabahruska> hi, does the hoogle web service work for you? to me the http://www.haskell.org/hoogle url just downloads a file named: 'download'.
05:14:02 <quchen> Alright alright, literate Latex is good :-)
05:14:31 <quchen> csabahruska: Works for me. There were some migration issues yesterday like the one you described.
05:14:41 <lpaste> danilo2 pasted “Template Haskell instances” at http://lpaste.net/91026
05:14:59 <merijn> csabahruska: It was broken yesterday, but should be fixed
05:15:05 <quchen> csabahruska: If haskell.org's Hoogle doesn't work, use FP Complete's Hoogle: https://www.fpcomplete.com/hoogle
05:15:09 <merijn> csabahruska: Please let us know if you are still experiencing problems
05:15:21 <isomorphic> csabahruska:  Or hayoo
05:15:28 <danilo2> HI! Is it possible to automatically generate (using Template Haskell) instances of some type classes, like in this example: http://lpaste.net/91026 ?
05:15:30 <merijn> hayoo is terrible >.>
05:15:41 <quchen> Is it?
05:15:41 <Maior> merijn: <3 http://recomputation.org/blog/2013/04/12/the-recomputation-manifesto/
05:15:58 <csabahruska> https://www.fpcomplete.com/hoogle seems to be ok, but http://www.haskell.org/hoogle is still broken
05:16:15 <isomorphic> csabahruska:  Cache?
05:16:22 <merijn> danilo2: It is possible to generate classes automatically using template haskell, lens does this
05:16:27 <merijn> danilo2: I dunno the details, though
05:16:56 <merijn> csabahruska: Are you by any chance behind a proxy/cache?
05:18:10 <csabahruska> isomorphic: checking
05:19:11 <danilo2> merijn: The details are  as follows: The type class always includes one function and several instances implement it (like in the example) - So there is always a method which simply implements the type class. If you have any further questions I'll answer them and If you could tell how lens could help, I would be very thankful :)
05:19:16 <csabahruska> isomorphic, merijn: ok, it is workong
05:19:18 <csabahruska> working
05:19:29 <csabahruska> sorry, my bad
05:19:30 <csabahruska> :)
05:20:50 <csabahruska> there is other stuff, it seems that the some previously uploaded files (pictures) were removed from haskell wiki
05:21:26 <csabahruska> e.g. http://www.haskell.org/haskellwiki/LambdaCubeEngine
05:21:31 <merijn> danilo2: I didn't mean lens could solve, I meant that lens uses TH to generate classes too. You might wanna look at the way they do it to see if it'd work for you?
05:21:45 <csabahruska> the screenshots are missing
05:22:10 <merijn> csabahruska: gimme a sec, checking
05:22:23 <alpounet> lens probably isn't the simplest example
05:22:39 <alpounet> acid-state might generate simpler code with TH
05:23:12 <alpounet> with its `makeAcidic`
05:23:32 <alpounet> http://hackage.haskell.org/packages/archive/acid-state/0.11.4/doc/html/src/Data-Acid-TemplateHaskell.html#makeAcidic
05:24:21 <danilo2> meijn: Thank you :) I'll look into lens. I'm afraid for now, that template haskell is very powerfull but a little complex and If there is somebody, who could help implement such automatuic generation of instances (http://lpaste.net/91026), it would be super :)
05:25:31 <_emm_> danilo2: you'll find lens internals complex too
05:25:47 <merijn> csabahruska: Yeah, a bunch of stuff seems to be missing, lemme see if I can manage to find where they are
05:26:27 <danilo2> _emm_: I know - and I know that lens internals will be even more complex than what I'm trying to do :)
05:26:33 <csabahruska> merijn: thanks :)
05:31:01 <alpounet> danilo2, see what I said above
05:31:19 <alpounet> makeAcidic should be way simpler and does something along the lines of what you want, I think
05:31:44 <danilo2> alpounet: I did not see the above lines - I'm looking ito it right now :)
05:44:44 <ion> lpsmith: Oh, awesome, i see there’s support for Copy in postgresql-simple now.
05:46:30 <lpsmith> yeah, not quite releasted
05:46:35 <lpsmith> but on github
05:47:22 <lpsmith> postgresql-libpq had copy support for some time now,  and you could always have used it in conjunction with postgresql-simple via the Internal module
05:47:36 <lpsmith> ion ^
05:48:00 <ion> lpsmith: Yeah, i installed it from github.
05:48:32 <lpsmith> Ok, let me know if there are any problems, the code hasn't been properly tested yet
05:48:43 <ion> No problems so far.
05:49:01 <lpsmith> Previously the little bit of copy stuff I'd did was via the internal module and postgresql-libpq
05:49:38 <danilo2> Why when I'm executing ` let emptyShow name = [d|instance Show $(conT name) where show _ = ""|]` in ghci I'm getting error (about overlapping instances for Show)? This is a function - so where this error comes from?
05:51:03 <davd> [pipes] is there some nice way to express abort-this-pipeline when discovering Nothing, Left etc or extract the embedded value? something like fromListS [Just 2, Nothing, Just 3] >-> terminateD >-> printD should result in "2".
05:51:04 <ion> I used ByteString Builder to feed chunks of rows to putCopyData as follows. Dunno if that is the best way to do it. https://github.com/ion1/sqarkov/commit/a5d3d636b30c8d1867b4adfdaf9c280f8536e909
06:09:33 <danilo2> I can use ''A to get data type A name in Template Haskell, but how can I get all the parameters of A? (Lets say A was declared as data A a b c = ...)
06:09:59 <Kinnison> Presumably you get to start poking around in Q
06:12:19 <bscarlet> danilo2: you call reify, get an Info, and pattern match.
06:12:48 <danilo2> bscarlet: checking it right now :)
06:13:44 <bscarlet> danilo2: see, for example, https://github.com/bscarlet/llvm-general/blob/master/src/LLVM/General/Internal/InstructionDefs.hs#L28
06:19:01 <bscarlet> I've got some derived Show instances I'd like to tweak. Is there any way I can get access to the derived version in order to call it in a hand-written instance?
06:23:25 <gspr> bscarlet: Aren't the derive rules always "ConstructorName (show field1) (show field2) ..."?
06:23:40 <zvrba> can somebody explain the relation between Data.Vector methods and the various mutable and immutable implementations?
06:23:51 <BoR0> @src tail
06:23:51 <lambdabot> tail (_:xs) = xs
06:23:51 <lambdabot> tail []     = undefined
06:24:12 <dmwit> bscarlet: I don't know of a way.
06:24:16 <zvrba> documentation explains differences between Data.Vector.{Boxed,Unboxed,..} but not the relation with functions in Data.Vector
06:24:22 <dmwit> gspr: Derived instances define showsPrec.
06:24:29 <gspr> dmwit: Oh, my bad
06:25:44 <bscarlet> gspr: I think so. I've got many types each with somewhere between several and very many constructors. Because of potential name conflicts, I'd really like the show instances to use qualified names.
06:26:27 <danilo2>  Why when I'm executing ` let emptyShow name = [d|instance Show $(conT name) where show _ = ""|]` in ghci I'm getting error (about overlapping instances for Show)? This is a function - so where this error comes from?
06:30:17 <bscarlet> danilo2: Is there already an instance for whatever $(conT name) works out to?
06:32:05 <danilo2> bscarlet: How can there be an instance if "name" is a variable (for this function)?
06:32:09 <osa1> @where paste
06:32:09 <lambdabot> http://paste.tryhaskell.org/new/haskell
06:32:31 <bscarlet> danilo2: good question. dunno.
06:32:55 <danilo2> bscarlet: Just run "ghci -XTemplateHaskell -XFlexibleInstances" and paste the code into ghci: "let emptyShow name = [d|instance Show $(conT name) where show _ = ""|]" and you'll get an error
06:36:03 * hackagebot geek 1.0.0.1 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.1 (JinjingWang)
06:38:15 <quicksilver> danilo2: doesn't that give lots of instance like "instance Show a where ..." ?
06:38:23 <quicksilver> that is, the type is a variable name
06:38:29 <quicksilver> so it overlaps with everything else
06:38:56 <bscarlet> danilo2: yeah. again, dunno. But if you put the same code in a dinky little module & run it with runhaskell it works, so the problem in ghci specific.
06:39:26 <jzelinskie> just read a good comment on reddit, looked up and saw tdammers wrote it -- i recognized his name from dicussion the other day -- small world
06:39:27 <bscarlet> quicksilver: the point is it's weird to get the error without ever splicing in the result of the function.
06:39:27 <danilo2> quicksilver: but this is a FUNCTION :) as bscarlet told - when you put this code in a module it works :/
06:39:35 <quicksilver> oh, ok
06:40:10 <bscarlet> danilo2: I guess ghci is just somewhat prescient.
06:40:54 <quicksilver> but then isn't "let emptyShow name = [d| blah |]" a let expression in the Q monad?
06:41:05 <quicksilver> can ghci cope with that?
06:42:24 <bscarlet> I wouldn't call that a let expression in the Q monad. I'd call that a let expression defining a function the return type of which is a declaration in the Q monad.
06:42:59 <Eduard_Munteanu> Is there a dropWhile for Text conduits?
06:43:48 <bscarlet> quicksilver: a let expression in the Q monad would be [| let foo = 3 |]
06:44:32 <quicksilver> hmm yes, bscarlet
06:44:46 <quicksilver> just a bug then I guess
06:45:13 <bscarlet> (dunno how to navigate talking about something like TH without being somewhat pedantic)
06:45:41 <Philonous> bscarlet:  Re getting the code that ghc derives: -ddump-deriv
06:45:53 <danilo2> bscarlet: quicksilver: I've got an simmilar error when trying to put very simmilar code into a module - could you please see it? http://stackoverflow.com/questions/17725188/strange-error-when-defining-a-template-haskell-function
06:46:00 <Eduard_Munteanu> Err, I mean for lists, sorry.
06:46:33 <Eduard_Munteanu> I want to sink a bunch of lines to nowhere.
06:46:49 <bscarlet> Philonous: Thanks. I'm hoping to avoid the code being huge, so unfortunately that approach isn't quite what I'm looking for.
06:50:25 <Eduard_Munteanu> Actually, I don't need that. :/
06:51:11 <bscarlet> danilo2: note that TH does not represent the generated code as Strings. You can't use $( ) just anywhere.
06:52:45 <bscarlet> danilo2: TH uses the Haskell parser, which is augmented to allow $( ) constructs in a very few syntactic contexts. Where you're using it isn't one of them.
06:52:47 <danilo2> bscarlet: please see this working example (it works and it is very simmilar to what I've have written): https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md#example-generating-a-show-instance
06:53:41 <danilo2> bscarlet: as far as I know I can use splices inside quotations and vice versa.
06:55:09 <bscarlet> danilo2: Sure. But the quotation isn't just text, it's parsed haskell code. And I don't think you can use a splice where you're trying to in any parsed haskell code, quotes or no.
06:55:26 <bscarlet> danilo2: the parser can't do that.
06:56:38 <Eduard_Munteanu> Does 'map' consume all input in conduits?
06:57:08 <danilo2> bscarlet: So what is the difference between my exampel and this (working) one: https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md#example-generating-a-show-instance ?
06:58:35 <danilo2> bcarlet: could you please tell me how can I fix it? (or give any hint?)
06:58:47 <bscarlet> danilo2: trying to get there.
06:58:58 <bscarlet> danilo2: (really. bear with me)
06:59:29 <danilo2> bscarlet: Thank you! :)
07:02:26 <bscarlet> danilo2: the difference is that the parameter of Show happens to be one of the sorts of things for which the parser has a production to allow a splice. The analogous statement is not true of your failing example.
07:02:52 <bscarlet> danilo2: try doing it without the quasiquote/splice, just with straight TH.
07:04:03 <danilo2> bscarlet: So it is impossible to create contexts like I've tried ? (with splices?) This should be straightforward for the compiler :(
07:04:29 <bscarlet> danilo2: I'm not sure what you mean by "create contexts".
07:05:28 <danilo2> bscarlet: I've explained it further in the question in StackOverflow: "That splice is supposed to put appropriate context constraints for the instance"
07:05:50 <bscarlet> danilo2: Ah.
07:06:48 <bscarlet> bscarlet: No, you can't splice in a context, and Q String would be the wrong type even if you could.
07:07:25 <bscarlet> danilo2: splicing is _not_ pasting text.
07:23:09 <zugz> Can anyone help with a memory-efficient way of looking up indexes of a large sorted list of strings?
07:23:40 <merijn> zugz: Eh, not using a list would be the best way
07:23:59 <merijn> zugz: lists aren't meant for random access, accessing indexes in lists is O(n)
07:24:12 <merijn> zugz: You probably want to use either Map or an Array
07:24:15 <zugz> I have list::[String] with about 2.5 million entries, of total size 45MB; if I try to build "Data.Map.fromAscList $ zip key [0..]", it eats up > 1GB of RAM
07:24:35 <zugz> yeah, my problem seems to be that the overheads with a Map are too large
07:24:42 <mauke> or with String
07:24:52 <merijn> zugz: How long are your strings?
07:24:55 <zugz> you think using an Array and implementing a binary search by hand would work?
07:25:07 <zugz> around 20 bytes on average
07:25:14 <merijn> zugz: You mean 20 characters
07:25:23 <zugz> (it's all the wikipedia article titles)
07:25:23 <merijn> zugz: Strings are like 20 bytes per char
07:25:30 <zugz> happens to be the same in this case
07:25:32 <astor> zugz: do you have an upper bound on the length of strings?
07:25:33 <mauke> String doesn't store bytes
07:25:40 <merijn> zugz: No, they're not the same at all
07:26:03 <zugz> merijn: the characters are all alphanumeric or space
07:26:09 <merijn> zugz: Irrelevant
07:26:21 <zugz> merijn: really? I thought they were stored as unicode?
07:26:23 <merijn> zugz: Strings use about 20 bytes per character
07:26:30 <mauke> "stored as unicode" isn't a thing
07:26:33 <mauke> unicode isn't a storage format
07:26:48 <zugz> merijn: ah hmm... so I should use Data.Text?
07:27:14 <zugz> or since I know they're bytes, go straight to Char8?
07:27:30 <zugz> but still, the bulk of the 1GB of ram must be from Map overheads, right?
07:27:31 <merijn> zugz: Data.Text stores strings as compact bytes (and deals with proper encoding), rather than lists of characters
07:27:40 <mauke> zugz: why?
07:27:42 <zugz> hmm maybe not actually
07:27:54 <zugz> ok thanks, this may well be all it is, thanks
07:27:55 <zugz> will test
07:27:56 <merijn> zugz: So using Text rather than String should cut back on memory a lot
07:27:59 <adas> im trying to write code to find the average of a list of elements. I am using the state monad. So this is the state `State Double [Int]`. to get value of state i can do s <- get. but what do i do to get the intermediate value?
07:28:29 <merijn> zugz: I think it's more likely that the [String] doesn't load everything until you try to stuff it into the map :)
07:28:44 <zugz> merijn: yes indeed
07:29:28 <astor> zugz: If you want to spend a few hours on this, I suggest two arrays, one offset array (l) and one Word8 array with all the strings concatenated (s).  l is n+1 in length. string i starts at l[i] and ends at l[i+1], thus s[l[i]..l[i+1]-1]
07:29:33 <merijn> adas: uh, you just use get?
07:29:55 <typoclass> zugz: i think you should first of all use profiling to figure out what is eating up the memory. it's quite a simple process. here are the three steps http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/profiling.html#id597120
07:30:09 <adas> merijn: but `get` gets the state right?
07:30:10 <merijn> zugz: RWH has a chapter on profiling haskell code too, btw
07:30:23 <zugz> thanks all, #haskell is great!
07:30:33 <merijn> adas: Yes, which is exactly what you're asking?
07:31:00 <adas> i mean in if st = s -> (s, a) then x <- get will give me 's'. but how do i get the 'a'?
07:31:02 <zugz> I did try heap profiling, but found the resulting graphs less than transparent
07:31:07 <merijn> adas: oh
07:31:12 <merijn> adas: >>=
07:31:29 <merijn> adas: or just "result <- myStateAction"
07:32:21 <quchen> adas: "get" is a State action that has the "s" as "a". "x <- get" gets the "a" out of "get", which is the "s".
07:32:23 <ClaudiusMaximus> zugz: probably you want -hy http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/prof-heap.html#rts-options-heap-prof
07:32:55 <merijn> adas: "get :: State s s" "foo :: State s a", you get the a out of foo the same way you get s out of get
07:33:52 <merijn> "(>>=) :: m a -> (a -> m b) -> m b" specialise to State "(>>=) :: State s a -> (a -> State s b) -> State s b"
07:35:15 <merijn> :t let foo s = do { x <- get; put (x+1); return s } in foo "blah"
07:35:16 <lambdabot> (Num s, MonadState s m) => m [Char]
07:36:12 <merijn> :t let foo s = do { x <- get; put (x+1); return s } in do { x <- foo "blah"; return x ++ "yay!" }
07:36:12 <lambdabot>     Couldn't match type `Char' with `[Char]'
07:36:12 <lambdabot>     Expected type: [[Char]]
07:36:13 <lambdabot>       Actual type: [Char]
07:36:25 <merijn> hmm
07:36:30 <merijn> oh, duh
07:36:37 <merijn> :t let foo s = do { x <- get; put (x+1); return s } in do { x <- foo "blah"; return (x ++ "yay!") }
07:36:38 <lambdabot> (Num s, MonadState s m) => m [Char]
07:37:02 <merijn> > let foo s = do { x <- get; put (x+1); return s } in runState (do { x <- foo "blah"; return (x ++ "yay!") }) 0
07:37:03 <lambdabot>   ("blahyay!",1)
07:37:24 <merijn> or even
07:38:23 <merijn> > runState (do { x <- do { foo <- get; put (foo+1); return 'c' }; return (x:"hkh") }) 4
07:38:23 <lambdabot>   ("chkh",5)
07:45:11 <klrr_> i hope my friend comes bak
07:45:26 <klrr_> soon so i get my bouncer login so i can be here 24/7 :P
07:46:45 <YoungFrog> what prevents you from being here 24/7 ? sleep is for the weaks.
07:47:12 <klrr_> YoungFrog: work, got a summerjob, cleaning rooms at a hotel -.-
07:47:54 <zugz> thanks everyone, using Text.Text rather than String saved the day! The Data.Map Text Int seems to still take around half a gig, but that's fine for my application
07:48:00 <YoungFrog> klrr_: ah, non IT work is bad luck.
07:48:29 <Hafydd> "non IT work" encompasses a lot of interestin work.
07:48:41 <klrr_> YoungFrog: yeah, but for IT work i need to know java and c++ dont i? :(
07:49:07 <YoungFrog> I dunno, I'm not in the IT business myself :)
07:49:17 <klrr_> where are you in?
07:49:35 <YoungFrog> academic
07:50:15 <klrr_> YoungFrog: are you PHD student ? =op
07:50:18 <klrr_> =o*
07:50:47 <YoungFrog> yes, at least I was not too long ago.
07:51:36 <klrr_> YoungFrog: cool what do you research?
07:52:12 <YoungFrog> I'm into differential geometry
07:52:21 <YoungFrog> i.e. maths
07:52:23 <klrr_> okeey, no idea what that is :P
07:52:24 <klrr_> okey
07:52:27 <klrr_> cool!
07:52:44 <YoungFrog> yes it is
07:52:52 <YoungFrog> hereby confirming what Hafydd said
07:54:01 <danilo2> Hi! I've got question connected to Haskell's IO - according to: http://www.haskell.org/haskellwiki/IO_inside#IO_actions_as_values can we threat IO actions as functions changing a "World" object? If yes, could we explicite pass this "World" object between different actions? I want to do something like "(x, new_world) = get_Line(old_world)" etc.
07:54:32 <finity> http://hackage.haskell.org/package/acme-realworld
07:54:43 <quchen> danilo2: No, the "World" is not accessible. It really corresponds to our universe.
07:54:58 <klrr_> isnt acme a text editor by bell labs?
07:55:01 <quchen> Passing it around would be making a copy of the universe just so you could travel around in time in your program. :-)
07:55:05 <klrr_> the one in plan9 OS
07:55:28 <danharaj> Cale: Hi. Can you get on gtalk? :3
07:55:30 <finity> I was actually thinking about this last night: would getWorld be a kind of call/cc for the whole universe?
07:55:46 <finity> You could reinstate the state of the universe and therefore its future
07:55:50 <quchen> danilo2: For practical purposes, you can often think of `IO` as `State RealWorld`, with the exception that you can't use `get`.
07:56:02 <finity> quchen: I think this is philosophically very interesting
07:56:16 <Cale> danharaj: uh, sure!
07:56:16 * hackagebot grid 7.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.1 (AmyDeBuitleir)
07:56:22 <danilo2> quchen: I deeply understand what you're talking about, but still I want to simulate some behaviour. I want to create a "Console" object. User will be able to write to this console, read from it etc - Is it possible in Haskell to create such explicite console, which would be bound to "real world console" somehow?
07:56:24 <Lethalman> quchen, so it's a writer :P
07:56:44 <Hafydd> I think it's better to think of an IO value as something like a chess strategy for playing in the real world.
07:56:49 <quchen> Lethalman: Well you can still modify the world.
07:56:57 <quchen> Lethalman: It's an analogy that only goes so far :-)
07:57:10 <merijn> quchen: That analogy breaks down hard when you consider forkIO
07:57:15 <quchen> merijn: Yes.
07:57:33 <Hafydd> Plus, it's possible that your IO value really does represent a chess strategy, in some applications!
07:57:39 <geekosaur> danilo2, the "realworld" is just a simulated state sequencer, not something you can usefully query. (in GHC it gets optimized away completely during compilation)
07:58:08 <merijn> danilo2: It's easy to do that, I have a library that lets you write to/read from virtual terminals
07:58:24 <Sculptor> yo
07:58:26 <danilo2> merijn: where can I find it?
07:58:55 <merijn> danilo2: It's very minimal, I'm adding things to it as I need them in my other code. The source is here: https://github.com/merijn/posix-pty
07:59:06 <ignacio> are you talking about the RealWorld type referenced in IO?
07:59:13 <finity> ignacio: Yes
07:59:46 <ignacio> what does it do?
08:00:22 <merijn> ignacio: Nothing and it's probably better to forget it exists
08:00:38 <ignacio> too late, cat's out of the bag
08:00:40 <merijn> ignacio: It's an irrelevant implementation detail of GHC
08:00:51 <geekosaur> ignacio, I just described it
08:00:58 <geekosaur> [18 10:57] <geekosaur> danilo2, the "realworld" is just a simulated state sequencer, not something you can usefully query. (in GHC it gets optimized away completely during compilation)
08:01:06 <ignacio> succintly
08:01:07 <tulcod> so how's it defined? :P
08:01:14 <merijn> tulcod: You can't define it in haskell
08:01:16 * hackagebot tkyprof 0.2.1 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.2.1 (MitsutoshiAoe)
08:01:27 <merijn> tulcod: It's a primitive of ghc
08:02:23 <geekosaur> its sole reason for existence is to thread IO functions together by means of data dependence (that is, it's passed as a parameter and returned in an (unboxed) tuple). no actual value for it exists; any references that don't vanish come code generation time are an internal error.
08:02:30 <ignacio> run :: IO -> RealWorld -> RealWorld ?
08:02:41 <tulcod> ignacio: IO is not a type
08:02:45 <ignacio> er IO ()
08:02:51 <geekosaur> ignacio, hoping that it will become a real thing won't make it a real thing
08:03:27 <quchen> ^ that's especially relevant in case your program is bottom
08:03:42 <ignacio> just throwing stuff out there
08:04:05 <merijn> ignacio: Except that it's stuff that doesn't make sense, realworld does not and cannot exist in haskell
08:04:26 <quchen> Are you familiar with the `ST s` monad? The `s` there is very similar to RealWorld. It's there as a dummy.
08:04:34 <finity> Isn't IO = ST RealWorld?
08:04:37 <finity> Or am I mistaken?
08:04:43 <ignacio> it might conceivably make sense for someone not yet familiar with IO (ie me)
08:04:48 <merijn> finity: Yes, but the s in ST s doesn't exist either
08:04:50 <danilo2> merijn: Thank you for this library - do you have some "fancy" examples to use it?
08:04:50 <quchen> finity: Could be, but I'm not sure.
08:05:02 <geekosaur> finity, not exactly, although it's isomorphic
08:05:18 <merijn> danilo2: I'm working on a terminal multiplexer (i.e something like screen/tmux), but I got distracted
08:05:22 <geekosaur> such that there's an (unsafe) primitive that can translate between them
08:05:37 <merijn> danilo2: I figured someone else might want to have these functions to, so put them in a separate library
08:05:55 <geekosaur> (well, probably not a primitive)
08:06:37 <ignacio> is there any fun to be had with haskell and abstract algebra? As in groups and stuff (I don't know category theory)
08:07:01 <BoR0> @src succ
08:07:02 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
08:07:07 <quchen> Out of curiosity, where's IO defined in GHC's source?
08:07:30 <BoR0> how is succ defined in haskell?
08:07:38 <ignacio> ghci says "defined in GHC.Types"
08:07:41 <quchen> BoR0: It's part of the Enum typeclass.
08:08:06 <finity> @info succ
08:08:07 <lambdabot> succ
08:08:14 <finity> Hmm, I guess I'm bad a lambdabot
08:08:24 <ignacio> ghci says "defined in GHC.Types"
08:08:29 <ignacio> sorry
08:08:51 <tikhonjelvis> succ is just part of a typeclass
08:09:04 <BoR0> I see, so I have to look into Enum, thx
08:09:25 <tikhonjelvis> well, if you want to see its implementation, you'll have to look at the particular type your care about
08:09:26 <shachaf> Saizan: Hooray for CoYoneday wrappers around Data.Set!
08:10:21 <shachaf> The main issues are "functions taking two Sets" and maybe more generally "functions that do anything other than map over a Set".
08:10:32 <BoR0> where can I download Prelude.hs from?
08:10:44 <quchen> ignacio: Right, newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:10:51 <BoR0> (and other haskell library sources)
08:11:03 <shachaf> You can get a reference Prelude in the Haskell report.
08:11:13 <shachaf> The real Prelude is in base, which you can download and look at.
08:11:20 <geekosaur> BoR0, they're part of the ghc source. but ^^ plus you can get (some) source via links in the haddocks
08:11:21 <shachaf> But it won't be organized the way you think.
08:11:35 <BoR0> I see, okay, thanks
08:11:41 <geekosaur> (http://www.haskell.org/ghc/docs/latest/html/libraries/frames.html)
08:12:40 <shachaf> Weird, frames.
08:14:10 * geekosaur actually prefers the frame interface
08:14:35 <geekosaur> because I tend to jump around a lot so the frame with the master module index is useful
08:15:20 <`^_^v> am i missing something obvious? it is pretty early in the morning.. http://pastebin.com/t5FvB86q
08:15:26 <mauke> The paste t5FvB86q has been copied to http://lpaste.net/91030
08:15:33 <BoR0> how do fromEnum and toEnum work? I can't get it
08:16:08 <tulcod> BoR0: what do you mean "how do they work"?
08:16:28 <danilo2> merijn: Thank you! I'll definitelly look deeply into it :)
08:16:31 <tikhonjelvis> they're also part of the Enum typeclass
08:16:34 <BoR0> data X = A | B | C deriving (Enum). how does fromEnum A know to return 0 ?
08:16:38 <tikhonjelvis> oh
08:16:46 <tikhonjelvis> that just happens at compile time
08:16:47 <tulcod> BoR0: GHC implementation magic
08:16:58 <tikhonjelvis> the compiler can look at the type and see that the A constructor comes first
08:17:05 <tulcod> BoR0: there's something similar going on for deriving (Show)
08:17:10 <tikhonjelvis> for data X = C | B | A, fromEnum A would be 2
08:17:17 <BoR0> okay, so it's compiler magic
08:17:25 <merijn> Well, not really magic
08:17:25 <BoR0> I saw that succ's implementation is trivial, but it uses fromEnum and toEnum
08:17:39 <mux> well, it could be done without the compiler's help, using GHC.Generic
08:17:43 <merijn> deriving is just compile time code generation
08:18:01 <tulcod> mux: i would consider using any GHC.* module compiler help...
08:18:17 <BoR0> what is GHC.Generic, I am not familiar with that
08:18:31 <tikhonjelvis> umm, if you're just beginning, I wouldn't worry about GHC.Generic
08:18:37 <mux> my point was that it doesn't need to be magic, and you could have this same behavior using GHC's generic mechanism
08:18:46 <BoR0> okay, I understand. thanks
08:19:05 <geekosaur> `^_^v, there are limits to what you are allowed to do with unboxed values. see http://www.haskell.org/haskellwiki/Unboxed_type and links therein
08:19:10 <tikhonjelvis> you can think of Enum as generating a function that looks like
08:19:21 <tikhonjelvis> fromEnum A = 0; fromEnum B = 1; fromEnum C = 2
08:19:28 <Eduard_Munteanu> :t runContT id . callCC
08:19:29 <lambdabot>     Couldn't match expected type `ContT r0 m0 a0'
08:19:29 <lambdabot>                 with actual type `a1 -> a1'
08:19:29 <lambdabot>     In the first argument of `runContT', namely `id'
08:19:38 <BoR0> yeah tikhonjelvis that's a good example :) just what I thought of, thanks
08:20:03 <Eduard_Munteanu> :t flip runContT id . callCC
08:20:04 <lambdabot> ((m r -> ContT r m b) -> ContT r m (m r)) -> m r
08:20:46 <Eduard_Munteanu> I seem to be using that at times...
08:20:49 <tikhonjelvis> BoR0: You can also see how it would be trivial to write that function from the type definition if you could programmatically access the constructors in order, yes?
08:21:18 <Eduard_Munteanu> Maybe it should even be a standard function.
08:27:54 <BoR0> tikhonjelvis, nope
08:28:10 <mizu_no_oto> Is there a current best library for simple terminal UIs?  I'm making a very simple rogue-like, and was looking at hcurses and nurses, but wanted to see if there was a better way to do things.
08:28:29 <tikhonjelvis> BoR0: If you had a hypothetical function that, given a type, could give you the type's constructors
08:28:44 <tikhonjelvis> the logic for going from that to the fromEnum function would be pretty simple
08:29:08 <BoR0> you mean this hypothetical function would return all constructors in a list?
08:29:16 <tikhonjelvis> something like that, yes
08:29:20 <shachaf> Terminal UIs? I don't even know what a UI homomorphism is.
08:29:29 <BoR0> I see. so what does "hypothetical" mean, could one implement such a function?
08:29:30 <merijn> mizu_no_oto: No, ask me again in a few months
08:29:37 <tikhonjelvis> shachaf: hyperlink
08:29:45 <merijn> mizu_no_oto: I've been trying to build one for a couple of weeks, for the exact same reason :p
08:29:49 <kosmikus> mizu_no_oto: vty is reasonably simple (but iirc, not extremely efficient)
08:29:54 <tikhonjelvis> BoR0: Well, clearly, the compiler has enough information to do this
08:30:01 <merijn> mizu_no_oto: I'm currently stuck on a bug in reactive-banana >.>
08:30:05 <shachaf> I thought those were meant to be between documents.
08:30:09 <tikhonjelvis> after all, the compiler has to know what the type is made up of to compile the entire file!
08:30:10 <mizu_no_oto> ah
08:30:13 <merijn> mizu_no_oto: vty-ui is ok, but way to imperative for me
08:30:16 <kosmikus> mizu_no_oto: there's also vty-ui, but I haven't used it
08:30:27 <kosmikus> yes, none of them are great ;)
08:30:28 <tikhonjelvis> shachaf: At least on mobile, they go between apps too
08:31:03 <BoR0> tikhonjelvis, how would such a function look like, and is it possible to implement it without using fromEnum/toEnum?
08:31:23 <tikhonjelvis> BoR0: that's a slightly tricky question
08:31:31 <tikhonjelvis> a function like that would need some help from the compiler
08:31:32 <merijn> kosmikus: "not extremely efficient" <- I'm not sure what kind of efficiency you expect/require of your terminal ui, but I doubt it'll be a bottleneck...
08:31:41 <tikhonjelvis> and it would need to run at compile time
08:31:51 <tikhonjelvis> happily, GHC provide facilities for both of these
08:31:56 <tikhonjelvis> but they're a bit convoluted
08:32:21 <BoR0> oh, okay. I was just curious about how things are done. and you are mentioning it all the time (compile time), but I _think_ I get it now
08:33:02 <tikhonjelvis> the big idea is simple enough
08:33:15 <tikhonjelvis> it's just that the actual reality is a bit more complicated
08:33:22 <BoR0> yup
08:33:50 <BoR0> in C/C++ the enum keyword does exactly that. compile-time mapping
08:33:50 <tikhonjelvis> but if you can imagine "meta Haskell"--Haskell that operates on Haskell code at compile time--it should be easy to see roughly how we can automatically create a fromEnum function like this
08:34:45 <BoR0> I assume this meta haskell does the, let's say "pattern matching" magic as well?
08:35:11 <BoR0> or type check or whatever else
08:35:21 <tikhonjelvis> yeah, basically
08:35:21 <tac> pattern matching is not really magic
08:35:25 <tac> as brilliant as it is
08:35:35 <BoR0> I should've quoted magic as well, sorry :)
08:35:47 <tac> ah. Yes, it can totally be "magic" :)
08:36:01 <tikhonjelvis> one of the complications is that there is actually more than one set of tools which can do things like this in Haskell
08:36:41 <tikhonjelvis> and some things (including this particular deriving mechanism) are acutally built right into GHC
08:37:39 <Taneb> Alright, I've given up and used a niave implementation for (*)
08:37:41 <BoR0> okay, I'll have to go now. thank you guys for clearing this up, it really helped. cheers
08:37:50 <tikhonjelvis> no problem; see you later
08:37:57 <BoR0> thanks, cya
08:40:05 <Taneb> There is really significant slowdown computing (*)
08:40:54 <Taneb> Bah
08:44:09 <mm_freak> while Functor denotes endofunctors on Hask, what does RFunctor (constraint-restricted functor) denote?  it's an isofunctor from a subcategory C of Hask to another subcategory D of Hask and C and D may be completely separate, right?
08:45:35 <shachaf> What's an "isofunctor"?
08:46:41 <Taneb> Okay, I've written enough now that I'm happy to put it on github
08:47:23 <Lethalman> Taneb, (*) as in multiplication is slow?
08:47:26 <byorgey> mm_freak: yes, that's essentially right I think.  There's some question as to what C and D really look like though.
08:47:33 <Taneb> Lethalman, for my unbounded word type
08:47:43 <Taneb> With the definition I have just written
08:47:47 <byorgey> for example, is C just the full subcategory of Hask induced by the objects which happen to satisfy the given constraint?
08:48:05 <byorgey> or do you only want those morphisms which preserve the operations associated with that constraint?
08:48:34 <byorgey> e.g. if the constraint is Ord, should C be just all the Ord types and arbitrary functions between them, or only order-preserving functions?
08:49:01 <byorgey> probably the latter makes more sense, but sometimes people want the former.
08:49:08 <mm_freak> byorgey: i understand
08:49:13 <byorgey> e.g. when people talk about a Functor instance for Set they almost certainly want the former.
08:50:10 * byorgey also has no idea what "isofunctor" means
08:50:46 <mm_freak> i think a functor F : C -> D is an isofunctor, if there exists a G : D -> C such that G . F = id : C -> C
08:50:53 <mm_freak> an isomorphism in the corresponding functor category
08:51:40 <mm_freak> is this a broken concept?  because i've read the term "isofunctor" before
08:52:25 <joergfritsch> Can anyone tell me how shilfL in Data.Bits is supposed to work? When I apply it I get the result that I would expect from shoftR!
08:52:46 <mm_freak> joergfritsch: shiftR x numBits
08:52:53 <mm_freak> don't confuse argument order…  it happened to me
08:53:01 <tromp> > 5 `shiftL` 1
08:53:02 <lambdabot>   10
08:53:13 <mm_freak> sorry, same for shiftL
08:53:16 <joergfritsch> mm_freak: yes, but if I setBit 8
08:53:20 <finity> mm_freak: Some google searching tells me that "isomorphism of categories" is the way that's usually described
08:53:21 <joergfritsch> then shiftL 1
08:53:29 <joergfritsch> why is the setBit afterwards then 9
08:53:30 <joergfritsch> ?
08:53:32 <finity> mm_freak: But IANACT (I Am Not A Category Theorist)
08:53:37 <joergfritsch> I expevcted it to be 7
08:53:47 <tromp> bit 0 is rightmost bit
08:53:54 <mm_freak> joergfritsch: shift-left multiplies by powers of 2
08:54:07 <tromp> bit 8 = 100000000
08:54:08 <joergfritsch> tromp: oh
08:54:09 <mm_freak> joergfritsch: in binary notation you can visualize it as appending a zero
08:54:10 <joergfritsch> OK
08:54:23 <joergfritsch> Thanks!
08:55:38 <shachaf> IEAWIUT (I Expand Acronyms When I Use Them)
08:56:19 * hackagebot geek 1.0.0.3 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.3 (JinjingWang)
08:56:20 <benmachine> an iso of cats ought to have left and right inverses
08:56:21 * hackagebot geek-server 1.0.0.3 - Geek blog engine server  http://hackage.haskell.org/package/geek-server-1.0.0.3 (JinjingWang)
08:57:33 <Taneb> https://github.com/Taneb/Wordeger
08:57:42 <quicksilver> benmachine: if ever a comment begged for a lambdakitten...
08:58:05 <wbooze> lol
08:58:35 <Taneb> Help would be VERY welcome
08:58:54 <benmachine> quicksilver: :P I'm on a phone keyboard so lazy about full words
08:59:13 <tikhonjelvis> you should try one of the gesture-based keyboards like swype
08:59:19 <tikhonjelvis> it makes typing full words much easier
08:59:46 <benmachine> yeah I do have that, just not at the same time as ssh
08:59:46 <mux> SwiftKey is the shit
09:01:38 <quicksilver> benmachine: http://imgur.com/avsBGYP
09:02:41 <benmachine> quicksilver: can't see it on phone, will appreciate later
09:03:53 <tikhonjelvis> you're talking on IRC, through SSH, on your phone?
09:04:26 <kryft> tikhonjelvis: Quite normal!
09:04:48 <tulcod> Taneb: i've never heard of the term "wordeger", can't you name it something more explicative like SemiInteger?
09:05:06 <Taneb> tulcod, it's Int => Integer : Word -> Wordeger
09:05:07 <joelteon> but then your rockstar programmer cred goes right out the window
09:05:25 <Hafydd> That's awful.
09:05:32 <tikhonjelvis> umm
09:05:35 <Hafydd> Don't try to be funny in your code.
09:05:35 <joelteon> but an Integer is an arbitrary precision Int, right?
09:05:41 <tikhonjelvis> that sounds like a natural number to me
09:05:55 <joelteon> isn't non-arbitrary precision the whole point of Words?
09:06:11 <Taneb> I'll agree it's a silly name
09:06:19 * hackagebot scotty-session 0.0.1 - Adding session functionality to scotty  http://hackage.haskell.org/package/scotty-session-0.0.1 (AlexanderThiemann)
09:06:31 <tulcod> Taneb: uh. a word is just a byte.
09:06:39 <tulcod> Taneb: "word" says nothing about signedness
09:07:03 <benmachine> quicksilver: that's wodnerful
09:07:09 * benmachine upgraded to tethering laptop
09:07:40 <shachaf> In Haskell it does.
09:07:43 <tulcod> Taneb: also, maybe the best course of action is to provide use cases for this?
09:07:48 <Taneb> joelteon, the only difference between Data.Word and Data.Int is that one's signed and the other isn't
09:07:56 <tulcod> shachaf: okay, true
09:08:11 <Taneb> tulcod, more correct list/stream indexing
09:08:23 <tulcod> Taneb: not here to me, but in the README, in test/ cases
09:08:29 <shachaf> I would call it something like "Nat".
09:08:35 <tikhonjelvis> wait, so are you just making natural numbers?
09:08:37 <shachaf> Since it's a (strict) natural number and all.
09:09:00 <Taneb> tikhonjelvis, I'm trying to make space and time efficient natural numbers
09:09:07 <tikhonjelvis> ah
09:09:16 <tikhonjelvis> as opposed to a think wrapper over Integer?
09:09:20 <shachaf> You're implementing this yourself rather than using GMP?
09:09:21 <tikhonjelvis> thin wrapper**
09:09:40 <Taneb> shachaf, I wrote it in a couple of hours when I was bored
09:09:48 <Taneb> Maybe converting it to use GMP should be a goal
09:09:56 <tulcod> Taneb: yeah, but clearly you're expecting more of this, since you're asking for help here
09:10:02 <tikhonjelvis> ultimately, unary encoding isn't *that* bad :P
09:11:13 <shachaf> tikhonjelvis: It's that bad for nearly everything except laziness.
09:11:15 <Taneb> tulcod, I'm asking for help because I realised it's significantly beyond what I am currently capable of
09:11:46 <tikhonjelvis> eh, it's only exponentially worse--no big deal
09:11:49 <DigitalKiwi> I often write things I never plan on using simply as a learning excercise
09:12:11 <tikhonjelvis> besides, nobody's stopping you from using a unary encoding that is also strict :)
09:12:42 <shachaf> It would make Harper happy, I suppose.
09:12:53 <p\mage> ok guys, how do I study algorithms?
09:13:02 <tikhonjelvis> algorithms?
09:13:17 <tikhonjelvis> you could read a book
09:13:24 <tikhonjelvis> for example, there is a book called "Algorithms"
09:13:28 <tikhonjelvis> it's probably relevant
09:13:45 <shachaf> You could wait for the movie to come out.
09:13:49 <tikhonjelvis> www.cs.berkeley.edu/~vazirani/algorithms.html
09:13:50 <shachaf> Might be a while, though.
09:14:07 <kryft> tikhonjelvis: Nice
09:14:12 <p\mage> why don't computer scientists make movies to train future computer scientists?
09:14:19 <tikhonjelvis> oh, we do, we do
09:14:31 <Taneb> p\mage, because my socks are really boring
09:14:38 <Taneb> And I can't find any willing actors
09:14:48 <shachaf> p\mage: This channel is for Haskell.
09:16:21 <p\mage> shachaf: any place I can go to study algorithms?
09:16:25 <tikhonjelvis> yeah, we try to avoid algorithms in Haskell-land
09:16:35 <p\mage> oh?
09:16:39 <p\mage> what do you guys use?
09:16:42 <tikhonjelvis> quite a base field of study, that
09:17:08 <Taneb> p\mage, magic, mainly
09:17:10 <tac> tikhonjelvis: That.... is an absurd thing to say. You don't "avoid algorithms" in Haskell...
09:17:34 <p\mage> tikhonjelvis: I thought you guys must use recursive algorithms
09:17:44 <tikhonjelvis> I was being somewhat facetious
09:18:04 <p\mage> well then, hahah, what kinds of algorithms do you guys use?
09:18:20 <p\mage> if you saw a binary tree search algorithm, how would you make a haskell version?
09:18:33 <tikhonjelvis> pretty much the same way, I imagine
09:18:45 <tikhonjelvis> unless the tree search used mutation all over the place
09:18:49 <tikhonjelvis> in which case we would do it better
09:18:54 <quicksilver> benmachine: thanks :)
09:19:02 <mizu_no_oto> p\mage: You *can* express imperative algorithms in Haskell, even if people don't like to
09:19:20 <p\mage> mizu_no_oto: oh, well huh
09:19:34 <p\mage> do I start with an imperative language or do I start with haskell?
09:19:43 <tikhonjelvis> I'd go for Haskell
09:19:46 <mizu_no_oto> Have you done any programming?
09:19:47 <tikhonjelvis> but I might be a tad biased
09:19:49 <p\mage> I'd like to study algorithms
09:19:55 <p\mage> mizu_no_oto: lots, but never in haskell
09:21:10 <p\mage> well, I want to make sure I know algorithms
09:22:00 <mizu_no_oto> get Pearls of Functional Algorithm Design
09:22:12 <CADD> mizu_no_oto: love that book!
09:22:28 <WraithM> I just got that book!
09:22:38 <Cale> p\mage: If you learn Haskell, you'll also learn how to program imperatively as you go along.
09:22:43 <CADD> WraithM: its super duper!
09:22:54 <WraithM> CADD: Yeah, I'm psyched
09:23:03 <CADD> WraithM: enjoy!
09:23:09 <Cale> p\mage: Writing IO actions is not very different from imperative programming, most of the time.
09:23:33 <Tinned_Tuna> Okaski is a great read, once you've got a good handle on things
09:23:42 <Cale> (though there are cases where you can accomplish it by means that wouldn't be available in an imperative language)
09:23:48 <CADD> Tinned_Tuna: that too! great paper!
09:24:13 <mizu_no_oto> Although for general algorithms with a more imperative bent Introduction to Algorithms by Cormen, Lieserson, Rivest and Stein is good.
09:24:47 <p\mage> Tinned_Tuna: who's Okaski?
09:24:57 <Tinned_Tuna> CADD: he has a whole book out :-p
09:25:02 <danilo2> Hi! Could somebody look please at this question? I'm trying to check if function return type is in IO monad or not: http://stackoverflow.com/questions/17728828/cannot-pattern-match-against-io-with-template-haskell :)
09:25:04 <wbooze> on ds
09:25:13 <wbooze> implemented in ....
09:25:15 <wbooze> ml
09:25:16 <wbooze> tho
09:25:21 <wbooze> eheh
09:25:23 <elliott> wbooze: ?
09:25:23 <Tinned_Tuna> http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1374164696&sr=8-1&keywords=purely+functional+data+structures
09:25:27 <Tinned_Tuna> p\mage: ^
09:25:31 <tikhonjelvis> there is an appendix with Haskell code, I believe
09:25:40 <wbooze> well the code is ml (new_jersey)
09:25:48 <wbooze> ds == data structures....
09:25:55 <Cale> danilo2: You can't put arbitrary expressions inside pattern matches...
09:26:11 <wbooze> i didn't get thru it tho....
09:26:11 <Tinned_Tuna> ML is sufficiently similar to Haskell for the book to still be enlightening :-)
09:26:16 <wbooze> cause i lack many things....
09:26:19 * hackagebot risc386 0.0.20130718 - Reduced instruction set i386 simulator  http://hackage.haskell.org/package/risc386-0.0.20130718 (AndreasAbel)
09:26:22 <CADD> Tinned_Tuna: indeed, he does. its like a book length paper turned book length book!
09:26:25 <Tinned_Tuna> you just have to keep in mind the lazy semantics of haskell when you're reading it
09:26:32 <wbooze> well yes, and i don't know ml or enough ml
09:26:36 <wbooze> meh
09:26:41 <Tinned_Tuna> CADD: I think it's just an expansion of his PhD thesis really.
09:26:47 <Cale> danilo2: What you have there is not so different from trying to write  f (sin x) = x^2
09:26:50 <CADD> Tinned_Tuna: exactly
09:26:50 <Tinned_Tuna> wbooze: it's very similar
09:27:07 <Tinned_Tuna> wbooze: the primary difference is the lazy vs. strict semantics.
09:27:16 <jhance> danilo2: I do not comprehend what you intend "AppT (ConT $ mkName "GHC.Types.IO") _ -> return True" to actually do
09:28:01 <jhance> You need to get the name of the first arg and compare towards the mkName, not pattern match.
09:28:02 <mizu_no_oto> https://mitpress.mit.edu/books/introduction-algorithms
09:28:03 <Cale> p\mage: Okasaki is the correct spelling of his name
09:28:43 <Tinned_Tuna> Either way, read the smeggin' thing. Then make note of the fact that you can push masses of data around with the State monad
09:28:50 <Cale> p\mage: He's a guy who wrote one of the first and most popular books treating the implementation of a wide variety of data structures in functional programming languages.
09:28:53 <Tinned_Tuna> and really probably shouldn't
09:29:07 <p\mage> Cale: wow
09:29:58 <Eduard_Munteanu> Argh... what do you do with Foo (Maybe a) if you want to abort on failure? Wrapping stuff like that in MaybeT is ugly and annoying.
09:30:13 <Cale> Eduard_Munteanu: branch explicitly?
09:30:22 <mizu_no_oto> p\mage: He also has some very readable papers, like Red Black trees in a functional setting
09:30:28 <Eduard_Munteanu> Cale: hm, that kinda sucks too
09:30:49 <Cale> Eduard_Munteanu: branch explicitly and then abstract away the case expression through a function like maybe?
09:30:57 <Cale> :t maybe
09:30:58 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:31:12 <Cale> (honestly that's not better than a case expression most of the time)
09:31:27 <Eduard_Munteanu> Yeah, maybe (return ()) looks quite ugly.
09:32:16 <Cale> LambdaCase is niceish though
09:32:36 <p\mage> mizu_no_oto: where do I get these really readable paperss of Okasaki?
09:33:17 <Eduard_Munteanu> Maybe I should complain about functions giving e.g. IO (Maybe a) instead?
09:33:19 <Cale> myFooMaybe >>= \case
09:33:26 <Cale>   Nothing -> return ()
09:33:30 <Cale>   Just x -> do ...
09:33:44 <supki> that looks like traverse_
09:34:08 <shachaf> It is.
09:34:43 <elliott> well, it's for_
09:34:48 <elliott> or strictly, forM_
09:35:07 <ClaudiusMaximus> Eduard_Munteanu: what about  do{ Just thing <- foo ; ... }  (not sure whether the pattern match failure exception would be nice, though)
09:37:24 <Eduard_Munteanu> Oh.
09:37:42 <CADD> p\mage: google is your friend
09:37:42 <Eduard_Munteanu> ClaudiusMaximus: it shouldn't result in an exception, but 'fail'
09:38:49 <Eduard_Munteanu> > runMaybeT $ do { Just foo <- Nothing; return () }
09:38:50 <lambdabot>   Not in scope: `runMaybeT'
09:39:53 <Eduard_Munteanu> That's not right though.
09:40:04 <ClaudiusMaximus> Eduard_Munteanu: oh, i was specializing to IO
09:40:16 <danilo2> jhance: I'm trying to check if function returns something in IO monad
09:41:25 * hackagebot combinatorial-problems 0.0.5 - A number of data structures to represent and allow the manipulation of standard combinatorial problems, used as test problems in computer science.  http://hackage.haskell.org/package/combinatorial-problems-0.0.5 (RichardSenington)
09:41:27 * hackagebot local-search 0.0.7 - Generalised local search within Haskell, for applications in combinatorial optimisation.  http://hackage.haskell.org/package/local-search-0.0.7 (RichardSenington)
09:42:10 <Eduard_Munteanu> Anyway, I'm trying to write a while loop in IO.
09:42:46 <Eduard_Munteanu> (more like   while (f = foo()) { <use f> }   though :D)
09:42:52 <danilo2> Cale: coukld you explain more about the "arbitrary expressions inside pattern matches" - I don't think I'm doing anything wriong - this is purre Haskell code :(
09:43:58 <Cale> danilo2: ConT $ mkName "GHC.Types.IO" -- this is an expression, which consists of the application of a function ($)
09:44:02 <Cale> It is not a pattern
09:44:16 <Cale> and so doesn't belong on the left hand side of a -> inside of a case expression.
09:45:14 <Cale> You could match against the pattern  AppT (ConT x) _
09:46:35 <Cale> But if you're going to replace x with anything there, it has to be a pattern. If it's an application, it will be the application of a data constructor to some other patterns.
09:46:35 <p\mage> CADD: I need some help, I click on this link and get a 404: http://www.usma.edu/EECS/SitePages/sigcse05.pdf , also this page searching duplicates of publication 5073: http://www.usma.edu/SitePages/Search.aspx?k=duplicates%3A%225073%22&start1=61  ; lots of 404's there
09:46:45 <Cale> mkName is not a data constructor
09:46:48 <p\mage> all the links on the last page are 404s
09:47:36 <Cale> p\mage: What exactly are you actually looking for?
09:47:51 <ClaudiusMaximus> @hackage monad-loops Eduard_Munteanu maybe something similar here?
09:47:51 <lambdabot> http://hackage.haskell.org/package/monad-loops Eduard_Munteanu maybe something similar here?
09:48:01 <p\mage> Alternatives to Two Classic Data Structures by Chris Okasaki. Symposium on Computer Science Education (SIGCSE),
09:48:07 <Eduard_Munteanu> Yeah, I'm trying not to add more deps though.
09:48:46 <p\mage> I'm trying to download all of Chris Okasaki's paperws
09:48:48 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.108.6421&rep=rep1&type=pdf
09:48:53 <Cale> googling works
09:52:21 <Eduard_Munteanu> Dang, conduits should have a filter that created a new conduit to process.
09:53:19 <p\mage> I'd like the Handbook of Data Structures and Applications but I don't have the money
09:53:24 <Eduard_Munteanu> Like  filter :: Resource m => (a -> Bool) -> Conduit a m a -> Conduit a m a    or something like that
09:55:01 <Eduard_Munteanu> Such that you could do    foo <- filter pred $ do { foo <- head; return foo }  <continue where the inner conduit left>
09:55:18 <Cale> p\mage: One important thing to realise about implementing imperative algorithms in a language like Haskell is that you can translate pretty much any piece of imperative pseudocode as follows:
09:55:45 <p\mage> ooh, like function loop (n-1)?
09:55:52 <Cale> Each line (place where the instruction pointer will be), becomes a function, and all the local variables become function parameters.
09:55:53 <danilo2> Cale: Thank you!
09:56:12 <p\mage> Cale: oh wow
09:56:13 <Cale> Well, all the mutable variables in scope do.
09:56:27 <Cale> Then these functions call each other according to the control flow
09:56:40 <Cale> in a mutually-recursive way
09:57:07 <Cale> Once you make this translation, you can just start simplifying things by inlining definitions
09:57:24 <mizu_no_oto> merijn: https://github.com/lens/terminal http://doryen.eptalys.net/libtcod/features/
09:57:32 <Cale> and eventually you'll typically be left with just one or two recursive function definitions.
09:57:56 <SoleSoul> Hi. Is there an easy way to create GUI in Haskell? I don't mean something like Gtk in C. I mean something like the GUI in Rebol. In other words, is there a library which allows for describing GUI in a declarative dialect? (is it complete enough for day to day use?)
09:58:20 <Yaniel> QML is declarative
09:58:23 <Cale> SoleSoul: "Yes" and "probably not"
09:58:31 <Yaniel> and I'd guess Qt has haskell bindings
09:58:49 <SoleSoul> Cale: which one would you suggest?
09:59:00 <elliott> SoleSoul: sort of
09:59:06 <p\mage> Yaniel: lol they need to update that for Qt 5
09:59:07 <elliott> you can use e.g. wx with reactive-banana
09:59:07 <tikhonjelvis> I don't think the Qt bindings are well supported, but I could be wrong
09:59:11 <elliott> and that ends up pretty heavily declarative
10:02:22 <SoleSoul> I mean something like these examples: http://www.rebol.com/how-to/fields.html   It may not be the most versatile or beautiful GUI in the world but it's easy. Is there anything which is even remotely close? Can you help me find a code example?
10:03:28 <Cale> SoleSoul: Well, none of that stuff is very different from how using WxHaskell or even Gtk2Hs will look.
10:03:45 <kazagistar1> SoleSoul: That looks like it could be done with HTML
10:03:48 <dolio> Good ol' rebol.
10:04:12 <SoleSoul> kazagistar1: exactly. That's what I'm looking for, but in haskell and with a real GUI.
10:04:31 <Cale> SoleSoul: You might also like the option of using Gtk2Hs with Glade
10:04:49 <dolio> HTML is the real gui these days, apparently.
10:05:33 <Cale> https://glade.gnome.org/images/glade-main-page.png <-- Glade lets you compose your dialog boxes visually, and then import them at runtime from an XML file.
10:05:42 <SoleSoul> Cale: My little experience with gtkhs says differently, but I would love to be proved wrong. It's just not as simple. I'll look it up again, but I'm a little sceptic to honest.
10:06:02 <tikhonjelvis> the only GUI toolkit I've used was wxWidgets
10:06:09 <Cale> Well, there are aspects of Gtk2Hs which are definitely more complicated.
10:06:10 <kazagistar1> HTML has a number of advantages over the other "real GUI toolkits", most importantly that it makes installing and updating a non-issue and gives you perfect cross platform support
10:06:14 <tikhonjelvis> the Haskell bindings were actually rather nice, but the framework itself is a pain
10:06:18 <Cale> WxHaskell is a bit more simple.
10:07:56 <SoleSoul> Cale: I have used Glade with C++, but you are not exactly _writing_ glade. You build it with an application. It has so many unused options. Every little tool is a project instead of a quick hack.
10:09:17 <SoleSoul> The reason for asking is because Rebol has so many advantages, but I can't leave the beauty of computing things with Haskell...
10:09:32 <SoleSoul> :)
10:13:01 <Cale> SoleSoul: Well, you do something like  Just dialog <- xmlNew "myProject.glade" and then you do a bunch of things which look like  textView <- xmlGetWidget dialog castToTextView "mainTextView"  for each of the widgets you're going to need to set event handlers on.
10:14:47 <SoleSoul> Cale: Then it's no better than C++ in that regard. It may be too much to ask, but in Rebol you only have to write, in plain text, the name of the widget, some properties, and the name of the handlers, and all that is left to do is to write the functions.
10:14:50 <sm_> a clone of rebol's gui dsl might be a nice front end for haskell gui libs
10:15:34 <zomg> whoa first person I've ever seen mention rebol :p
10:15:36 <Cale> SoleSoul: well, that's for the convenience of laying out your widgets visually.
10:16:11 <Cale> SoleSoul: if you actually define them in-place, then there's not much more to specify.
10:16:56 <dolio> SoleSoul: We have a custom language here at work for laying out guis that's a lot like that.
10:16:57 <SoleSoul> zomg: It might be because Rebol 3 has gone open source.
10:17:03 <dolio> Written in what is essentially Haskell.
10:17:12 <dolio> Unfortunately it's proprietary.
10:17:12 <SoleSoul> dolio: Is it public?
10:17:20 <dolio> But, it can be done.
10:17:52 <SoleSoul> dolio: Is showing an example of a simple hello world gui a violation of the license?
10:18:03 <Cale> I mean, if you want to specify less than this, it's easy to just make a data type for describing the bits that you want to describe and write a function which executes appropriate code to create the widgets.
10:18:16 <Cale> (i.e. recursively over your data structure)
10:18:18 * fizbin kicks his connection.
10:18:35 <zomg> SoleSoul: oh, interesting. I fiddled with it a while back, seemed it had some interesting ideas
10:19:00 <SoleSoul> Cale: I'm really trying to imagine how this code would look like. What should I search for in order to see an example?
10:19:07 <dolio> A hello world gui would probably be something like 'atom "Hello world"'
10:19:28 <dolio> Maybe slightly more complex than that.
10:19:31 <SoleSoul> dolio: what would that do? show a window with a label?
10:19:41 <dolio> Yes, it would be a label.
10:19:49 <dolio> What it does depends on how you execute it.
10:20:08 <dolio> There's a lot of stuff for rendering the same gui descriptions in many formats. Java, HTML, Excel, ...
10:20:23 <SoleSoul> dolio: I see.
10:20:27 <dolio> So it might pop up in a window, or be embedded in something else.
10:21:38 <SoleSoul> dolio: So a Rebol-like gui in Haskell _is_ possible but doesn't exist in public.
10:22:07 <SoleSoul> If I could only connect my Haskell functions to the Rebol GUI :)
10:22:22 <dolio> It's a very slimmed down problem domain, though. Because we're technically only displaying "reports". So it's mainly static charts and tables and such, with occasionally combo boxes that select between stuff and whatnot.
10:22:39 <dolio> But it might be sufficient for a lot of really simple stuff.
10:24:17 <sm> SoleSoul: that must be possible too. A simple matter of programming!
10:25:49 <SoleSoul> The original idea was to program in the right paradigm for each part of the application. GUI in a declarative style, logic in functional frogramming, and global state in classes. I've never tried that, but I would LOVE to.
10:26:05 <SoleSoul> *programming
10:26:24 <Eduard_Munteanu> Hm, actually, I think I can't nest conduits. I'm not sure it makes sense unless one wants to do something like dropWhile.
10:26:54 <Eduard_Munteanu> Or at least it should sink a continuous part of the input.
10:27:53 <Eduard_Munteanu> Or maybe it does make sense if all intermediate values are dropped too.
10:28:12 <Eduard_Munteanu> I should probably ask #yesod, though?
10:36:54 <sm> SoleSoul: has any other programming language been connected to rebol ?
10:37:00 <simon> I'm debugging a Happy parser, and I get "Couldn't match type `Posn' with `[LeftExp]'" -- I'm trying to decipher which of these types is the one the parser generates and which the AST contains.
10:37:54 <SoleSoul> sm: Do you mean this? http://rebol.com/docs/library.html
10:37:59 <simon> (the actual types that come afterwards are extremely long due to the complexity of the generated parser)
10:38:54 <sclv_> you can get the gist of our compositional ui by looking at jmacro-rpc
10:38:56 <sclv_> and the panels library
10:39:06 <sclv_> its the whole notion but just in html/javascript
10:39:55 <sm> SoleSoul: yes but I was thinking more the reverse direction, controlling rebol code from a haskell main program
10:40:09 * simon tries to decipher the long type and makes some sense of it
10:40:42 <sm> so you could send it ui-drawing commands and receive high-level ui events
10:41:27 * hackagebot comonad-transformers 3.0.4 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.0.4 (EdwardKmett)
10:41:50 <SoleSoul> sm: I don't know. I know more Haskell than Rebol.
10:42:38 <sm> in general though, I guess it'll be more productive to build a rebol-like gui dsl in haskell than driving actual rebol
10:43:06 <SoleSoul> sm: This? http://www.rebol.com/r3/docs/concepts/extensions-callbacks.html
10:43:32 <sm> did you see http://praisecurseandrecurse.blogspot.com/2013/07/the-polar-game-in-haskell-day-7-towards.html ? the wxhaskell example at the end seems quite nice
10:44:06 <klrr_> sm: interesting do he use FRP ?
10:44:18 <sm> I don't think it does
10:44:28 <klrr_> okey
10:44:36 <sm> SoleSoul: callbacks, yes that could be used
10:44:44 <klrr_> is the author of pipes here on irc?
10:47:40 <mkscrg> that would be Tekmo
10:48:51 <SoleSoul> sm, Cale: Thanks for the help. Time to play with some code.
10:49:19 <sm> good luck!
10:49:40 <SoleSoul> Thanks
10:59:11 <eacameron> Is there a type that is the conceptual opposite of Maybe a? I.e. login :: Unless Failure
11:00:03 <wbooze> not!
11:00:07 <wbooze> not maybe a
11:00:17 <shachaf> eacameron: I don't follow.
11:00:42 <shachaf> Do you want some Foo such that Foo (Maybe a) = a?
11:00:53 <shachaf> Or are you looking for data Bar a = Bad a | Good?
11:00:56 <wbooze> if failure don't login
11:01:00 <shachaf> Or something else?
11:01:25 <eacameron> shachaf: data Bar a = Bad a | Good is what I want
11:01:56 <shachaf> OK.
11:02:10 <shachaf> So the same as Maybe, with a different meaning.
11:02:21 <byorgey> Maybe has no inherent meaning.
11:02:21 <eacameron> shachaf: yes, exactly
11:02:24 <shachaf> You might just use Maybe for that.
11:02:41 <shachaf> It's not as if you're going to get a Monad instance with the opposite short-circuiting behavior or something.
11:03:15 <eacameron> shachaf: well the truth is I'm doing this in C++ where there is an attatched meaning :(
11:03:17 <shachaf> You might be able to make a Monoid instance, though... Probably it would be First.
11:03:28 <byorgey> eacameron: how about  Either a () ?
11:03:46 <shachaf> That sounds good.
11:03:52 <wbooze> lol
11:03:57 <wbooze> or a
11:04:27 <shachaf> wbooze: What?
11:04:28 <wbooze> or maybe neither b,c,d,......z:0,1,2.....9
11:05:02 <lumb323> hello. does it make sense to have a type class withouth a variable, so class MyClass where ..?
11:05:21 <elliott> lumb323: no. but GHC supports it anyway, after shachaf wrote a patch
11:05:45 <shachaf> No released version of GHC supports it.
11:06:00 <lumb323> elliott: if it does not make sense, why was it added?
11:06:19 <shachaf> For consistency.
11:06:27 <shachaf> And because it's justifiable sometimes.
11:06:35 <elliott> wait, wait, I got a good one: it makes about as much sense as shachaf.
11:07:07 <shachaf> lumb323: (If you haven't noticed yet, elliott is just taking this question as an opportunity to make fun of me.)
11:07:15 <shachaf> (It's what he does.)
11:07:43 * dmwit hugs shachaf
11:11:27 * hackagebot highlight-versions 0.1.3.2 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.3.2 (BrentYorgey)
11:12:33 <Fuuzetsu> @src isInfixOf
11:12:33 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
11:13:45 <josephle> ...those are some creative variable names
11:14:13 <Fuuzetsu> What was wrong with ‘x’ and ‘y’…
11:14:16 <Fuuzetsu> or xs
11:14:21 <shachaf> needle haystack is good.
11:14:34 <dmwit> Nothing is wrong with xs. Nothing is wrong with needle.
11:14:45 <josephle> isInfixOf is like finding a needle in a haystack, eh?
11:15:03 <elliott> even PHP calls them needle and haystack.
11:15:20 <elliott> also, I forgot how beautiful isInfixOf's implementation is.
11:17:22 * ziman prefers the form "(needle `isPrefixOf`) `any` tails haystack" :)
11:17:41 <dmwit> yikes
11:17:52 <elliott> isInfixOf needle = any (isPrefixOf needle) . tails would be better. yours is, um, unique.
11:17:58 <elliott> well, (needle `isPrefixOf`) might be good.
11:18:05 <dmwit> "any" doesn't work very well as an infix operator.
11:18:16 <shachaf> (needle `isPrefixOf`) is way better, of course.
11:18:35 <shachaf> ziman: You forgot one, with -XPostfixOperators:
11:18:36 <byorgey> in that particular case it does read pretty well as English.   "the needle is a prefix of any tails of the haystack"?
11:18:42 <elliott> dmwit: well, "needle is prefix of any tails of haystack" reads "nicely"
11:18:46 <shachaf> (needle `isPrefixOf`) `any` (haystack `tails`)
11:18:49 <elliott> but as Haskell it reads bizarrely.
11:18:58 <elliott> byorgey: I'm going to sue.
11:19:13 <shachaf> ((needle `isPrefixOf`) `any`) (haystack `tails`) -- even better!
11:19:27 <byorgey> elliott: is Sue your mom's name?
11:21:53 <Hafydd> :t any
11:21:54 <lambdabot> (a -> Bool) -> [a] -> Bool
11:22:16 <klrr_> is the author of pipes here on irc?
11:22:30 <shachaf> klrr_: No.
11:22:31 <dmwit> Didn't you ask that half an hour ago (and get your answer)?
11:23:52 <shachaf> dmwit: Yes.
11:24:40 <dmwit> klrr_: You might consider just asking your question. There's a halfway decent chance that the author of pipes is not the only person that knows the answer.
11:25:13 <klrr_> dmwit: i justy wanted to know who he was if he was here, i got no question regarding pipes yet
11:29:10 <Eduard_Munteanu> Where are ghci :set options documented? I'm trying to look for 'prompt' and can't find it
11:29:43 <Eduard_Munteanu> Oh, sorry, nvm, it's under :set
11:30:00 <Eduard_Munteanu> (separate from :set <flag> I guess)
11:30:16 <Fuuzetsu> Why is Data.Map asking for an Ord distance for a lot of its functions?
11:30:34 <dmwit> Fuuzetsu: Because the keys are stored in a balanced tree.
11:30:36 <elliott> it's based on a tree.
11:30:42 <elliott> it needs to know the ordering of your keys to be efficient
11:30:44 <monochrom> because it uses Ord to build a search tree
11:30:59 <dmwit> Well. Because the keys are stored in a search tree. The fact that it's balanced is irrelevant.
11:31:23 <elliott> I really wish we had a separation of "arbitrary ordering" and "proper ordering".
11:31:27 <elliott> so you could use things with no reasonable ordering as Map keys.
11:31:32 <Eduard_Munteanu> "If prompt starts with " then it is parsed as a Haskell String; otherwise it is treated as a literal string."  -- does Haskell String mean it interprets it as Haskell code?
11:31:46 <merijn> Fuuzetsu: Without the Ord you could only implement Map as "Eq a => [(a,b)]" with O(n) lookup :)
11:32:07 <Fuuzetsu> I'm looking for precisely that but it seems like I'll have to do it by hand
11:32:17 <merijn> :t lookup
11:32:18 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:32:31 <merijn> It even already exists :)
11:32:36 <elliott> Eduard_Munteanu: probably means "read"
11:32:38 <elliott> but try it and see
11:33:00 <merijn> Fuuzetsu: If you can make your key an instance of Ix, you might be able to get away with using an Array as a map too
11:33:35 <Fuuzetsu> nah, it's someone elses code that I'm just trying to refactor a bit
11:33:37 <Eduard_Munteanu> elliott: mm, it doesn't seem to make a difference... at least I know it doesn't interpret it :/
11:34:02 <elliott> Fuuzetsu: is there a reason your key type cannot be Ord?
11:34:18 <Eduard_Munteanu> :set prompt """
11:34:18 <Eduard_Munteanu> Can't parse prompt string. Use Haskell syntax.
11:34:37 <Eduard_Munteanu> I guess it just uses quoting rules for Haskell string literals?
11:34:59 <Fuuzetsu> elliott: I don't know. I don't want to add one.
11:35:08 <elliott> it's a few characters if you can derive it :P
11:35:12 <elliott> and more efficient
11:35:33 <Fuuzetsu> elliott: It's not my code, I'm just doing some turning of ugly code to not-so-ugly code
11:37:08 <Eduard_Munteanu> Hm, I wish the prompt was smarter.
11:41:41 <davd> wouldn't it be great with a separate irc channel dedicated to pipes?
11:42:16 <klrr_> davd: suggest it on its mailing list, ive looked into it a bit and i seem to like the idea, it seems a lot like FRP
11:42:17 <davd> I have all of these minor questions popping up over time, which doesn't seem to be a good fit for the mailing list.
11:42:27 <davd> yeah, it's cool :)
11:42:45 <klrr_> make sense of io instead of magical funcions in the IO monad
11:43:08 <elliott> pipes questions are on-topic here
11:43:34 <monochrom> Eduard_Munteanu: concerning the difference between " and no " : consider :set prompt \x2200 vs :set prompt "\x2200"
11:43:42 <chrisbuchholz> do any of you use anything to have a "live" feeling abu
11:43:54 <chrisbuchholz> about if your code works?
11:44:42 <elliott> the type checker
11:44:51 <monochrom> I don't feel. I reason and test. to increase chance of success, I build bottom-up, not top-down
11:44:54 <chrisbuchholz> I have written a small program that watches for changes in a file and compiles it when a change is detected, but I would like to have something more seemingless - like intellisense
11:45:00 <chrisbuchholz> I'm using vim btw
11:45:47 <chrisbuchholz> elliott: but do you run that manually when you want to check?
11:45:50 <davd> there is some vim-plugin which does type checking on save (don't know where you can find it though)
11:46:13 * optimusbrine is always completely bewildered until the exact moment when his code compiles
11:46:27 <gwern> phooey. no edwardk
11:46:28 <chrisbuchholz> monochrom: don't think I'm quite there yet though :D
11:46:40 <chrisbuchholz> optimusbrine: feel the same way
11:46:53 <dmwit> Sometimes I am bewildered long after the code compiles.
11:46:55 <elliott> chrisbuchholz: :r
11:46:58 <elliott> in ghci
11:47:04 <dmwit> It is a feeling common to all programmers, I think.
11:47:07 <optimusbrine> dmwit, yes, ditto
11:47:11 <elliott> anyway look into hsdevtools or ghc-mod
11:47:12 <elliott> with syntastic
11:47:17 <monochrom> I believe you mean you don't know how to reason yet. but surely you know how to test and how to build bottom-up.
11:47:21 <elliott> *hdevtools
11:47:40 <gwern> so anyway, any Google Summer of Code mentors around?
11:47:42 <chrisbuchholz> monochrom: well sure
11:47:50 <chrisbuchholz> elliott: will do
11:49:37 <byorgey> gwern: I am not an official mentor but am closely following two particular projects and mentoring in an unofficial role.
11:50:18 <gwern> byorgey: well, maybe you know. I'm thinking of trying to statistically analyze my collection of past haskell summers of code (cook up some covariates and run a logistic regression) and I'm wondering if google has done this already
11:50:40 <byorgey> ah.  no, sorry, I don't know.
11:50:48 <gwern> byorgey: do you know who i might ask?
11:51:04 <ocharles> dmwit: i had that feeling a while ago
11:51:17 <ocharles> dmwit: battled with the compiler for a good four hours then pop "OK"
11:51:33 <byorgey> gwern: maybe ask Carol Smith, who runs the GSoC program?
11:51:34 <ocharles> there was a brief "uhhh... really?" moment
11:51:48 <byorgey> she frequently responds to emails on the GSoC mentors mailing list
11:52:00 * gwern is not on that ml
11:52:32 <byorgey> gwern: https://plus.google.com/106914622056861826817
11:54:09 <gwern> hm. I was only thinking of haskell, but I wonder what overall gsoc results look like
11:54:34 <gwern> it'd be incredibly difficult to code up 400 students per year, but if the data has already been collected in the applications...
11:54:47 <byorgey> ah. well, you said "you were wondering if google has done this already".
11:54:59 <byorgey> I don't know why google would do it for Haskell in particular.
11:55:23 <gwern> browsing her g+ page, I don't see any analyses posted
11:55:31 <gwern> unless they're buried in her talks
11:55:55 <byorgey> yeah, I don't know.  I've never heard of anything like that being done, but that doesn't mean it hasn't
11:57:53 <gwern> hm. i don't see any way to email her via g=
11:58:35 <shachaf> gwern: #haskell-gsoc
11:58:43 <gwern> shachaf: no one's there
11:58:51 <gwern> just jasper and dcoutts, iirc
11:58:54 <shachaf> (Might be a better place to find mentors. Not saying this is off-topic in here.)
11:59:18 <shachaf> 19 people there. 20 if you join!
11:59:55 <gwern> oh fine
12:01:18 <astor> gwern: I'm sure *some* sort of analysis has been done, at least internally in order to gauge the impact.
12:01:34 * hackagebot chaselev-deque 0.1.3 - Chase & Lev work-stealing lock-free double-ended queues (deques).  http://hackage.haskell.org/package/chaselev-deque-0.1.3 (RyanNewton)
12:02:13 <gwern> astor: I've learned to not assume that. people are always very busy
12:03:34 <hiredman> win 15
12:03:38 <ion> lose 16
12:04:15 * dmwit jots down the score: hiredman 15, ion -16
12:05:35 <astor> If RyanNewton is here, the web page lists as a known problem that Chase & Lev is indeterministic (i.e. buggy) - from 2012.02.  Update if this has been fixed?
12:13:52 <klrr_> pipes.... they're even more difficult than FRP to understand xD
12:14:26 <deggis> klrr_: their implementation or how to use? :)
12:15:19 <klrr_> deggis: well, it seems very complex
12:16:04 <klrr_> deggis: also lots of new jargon
12:16:39 <deggis> i've only done some little tests with pipes. only thing with confusing complex stuff is to take time and figure out the stuff piece by piece :) have you tried the tutorial?
12:18:25 <klrr_> deggis: im reading it atm, it doesnt explain what () mean
12:18:32 <klrr_> s when it's used as a varibale
12:18:46 <klrr_> ()== haskells null?
12:19:07 <mauke> @src ()
12:19:08 <lambdabot> data () = ()
12:19:09 <klrr_> it's like null in the context of return, but the use here, what does it mean?
12:19:30 <deggis> @type print
12:19:31 <lambdabot> Show a => a -> IO ()
12:19:51 <klrr_> null basically? okey, when would you like to have null as an variable?
12:19:55 <klrr_> mindfucking
12:20:09 <dmwit> No, not null. The type with only one value.
12:20:28 <deggis> you can think that as a void type as in C/java
12:20:28 <mauke> what variable?
12:20:31 <mauke> it's a constant
12:20:44 <klrr_> null==void, ive only programmed in haskell
12:20:48 <dmwit> When you have nothing interesting to say, you can use () as a type to indicate that, and () as the single value of that type.
12:20:50 <klrr_> i cant C jargon
12:20:54 <merijn> klrr_: () is the unit type, it's a type with only one constructor (i.e. "()")
12:21:05 <klrr_> so it's nothing basically
12:21:09 <klrr_> Nothing*
12:21:13 <merijn> klrr_: It's exactly to defining "data Unit = Unit"
12:21:22 <dmwit> no, Nothing is a value of the Maybe a type.
12:21:23 <klrr_> okey okey, it's like void
12:21:30 <monochrom> () is not null or void. that may be your problem.
12:21:37 <dmwit> It's very like C's void.
12:21:39 <klrr_> it is in the context of print
12:22:09 <klrr_> but in this context of pipes, as a input variable to a funciton, how should i "read" it?
12:22:12 <klrr_> think of it as?
12:22:16 <dmwit> However, Haskell also has a Void, which is very different from ().
12:22:38 <klrr_> idc sry, im wondering about using () as a variable, what does it mean?
12:22:44 <monochrom> to be frank, it doesn't matter what you call it, and what you call it may be completely unrelated to what you think.
12:22:49 <merijn> klrr_: What do you mean by variable?
12:22:52 <dmwit> () is not a variable.
12:22:52 <mauke> klrr_: I don't understand this "using () as a variable"
12:23:05 <klrr_> http://hackage.haskell.org/packages/archive/pipes/3.2.0/doc/html/Control-Proxy-Tutorial.html
12:23:07 <deggis> s/variable/value?
12:23:12 <klrr_> it uses () as a variable
12:23:14 <mauke> s/variable/type/?
12:23:15 <klrr_> in the link
12:23:16 <merijn> klrr_: Have you thought about using [] as a variable?
12:23:17 <mauke> klrr_: WHAT DOES THAT MEAN
12:23:26 <dmwit> You should read "() -> a" as "a function that takes an uninteresting value and produces an a".
12:23:26 <klrr_> LOOK AT THE LINK
12:23:31 <mauke> klrr_: ok, what now?
12:23:31 <merijn> klrr_: If that question makes no sense, then good, you don't make sense either
12:23:35 <monochrom> the bottomline though is if what you think doesn't help you understand actual code, what you think is wrong. I have no further comment.
12:23:42 <klrr_> then why have () in the first place?
12:23:53 <mauke> klrr_: that's a pretty long page. which part should I look at?
12:24:00 <klrr_> any code example
12:24:05 <mauke>  import Control.Monad
12:24:08 <mauke> ok, what now?
12:24:37 <monochrom> and I don't understand why I bother.
12:25:19 <klrr_> sry for being rude, but still, i dont know what to fucking call it, you know those fucking freaking shitty crap shit that you use, called VARIABLES, they are used in FUNCTIONSm, in PIPE TUTORIAL, () is used as variable, how should i intepret that, and why have it in the first place?
12:25:31 <mauke> klrr_: you keep repeating yourself
12:25:38 <klrr_> lines' h () = runIdentityP loop where loop = dolines' h () = runIdentityP loop where loop = do
12:25:41 <mauke> I still have no idea what you mean by "variable"
12:25:41 <klrr_> lines' h () = runIdentityP loop where loop = dolines' h () = runIdentityP loop where loop = do
12:25:44 <klrr_> lines' h () = runIdentityP loop where loop = dolines' h () = runIdentityP loop where loop = do
12:25:47 <merijn> klrr_: It's not it's used as a pattern match
12:25:48 <klrr_> look at it and you see
12:25:52 <monochrom> perhaps () isn't used as variable, and you're completely misreading.
12:25:55 <mauke> klrr_: ok, that contains ()
12:25:59 <mauke> klrr_: where's the variable?
12:26:05 <merijn> klrr_: It's exactly the same as "lines' h []" would be as a pattern match
12:26:06 <klrr_> why does the function need unit?
12:26:18 <merijn> klrr_: Well, it's a pipe, it needs to consume *something*
12:26:19 <klrr_> s/unit/()
12:26:34 <merijn> klrr_: Since we're not really caring *what* it consumes, it makes sense to use ()
12:26:34 * hackagebot atomic-primops 0.3 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.3 (RyanNewton)
12:26:40 <klrr_> i dont get it, in almost all example there's no input so why place the () there?
12:26:44 <merijn> klrr_: Because that shows that we don't really care about the value we deal
12:26:50 <klrr_> () == any type?
12:26:56 <mauke> no, () is only ()
12:26:57 <klrr_> why not use "a" or sth?
12:26:58 <dmwit> No. () is a specific type.
12:27:04 <klrr_> then what does it consume, nothing?
12:27:10 <dmwit> correct
12:27:11 <mauke> it consumes ()
12:27:13 <monochrom> have you learned Haskell?
12:27:16 <mauke> which is a specific value
12:27:19 <byorgey> klrr_: presumably it is becauase we want to be able to compose these functions with other functions somehow.
12:27:35 <byorgey> so they have to be functions even if they don't actually need any input.
12:27:42 <byorgey> to indicate that, we use () as the type of the input.
12:27:45 <klrr_> i dont fucking care about shitty haskell fuck, i gonna stop learning that stupiod carap fucktard shit have fun with fucking theory -.-
12:28:18 <mauke> welcome back
12:28:19 <levi> Someone's having a bad day.
12:28:32 <klrr_> i dont mean to offend anyone, sry if i did, i gonna quit learning programming thanks for trying to help at least
12:28:46 <joelteon> havent seen that before
12:29:42 <josephle> ...wasn't he asking about agda 3 days ago?
12:29:52 <josephle> this has been a very strange saga
12:30:13 <byorgey> it's probably not over =)
12:30:24 <monochrom> I am tired of that person.
12:30:52 <shachaf> Probably not. They came back last time, and the times before, and after being kicked.
12:31:32 <ignacio> question about ghc, does it recognize if I define a type isomorphic to a list?
12:31:38 <mauke> random quotes from my backlog: <klrr_> can FRP be applied to IO? <klrr_> i gonna learn about pipes <klrr_> and write an irc bot with it
12:31:41 <ignacio> for optimization or whatever
12:31:42 <monochrom> the type of "I want to know, but I won't pay the cost, you owe it to me to teach me"
12:31:53 <mauke> ignacio: no
12:31:53 <dmwit> ignacio: nope
12:31:58 <merijn> ignacio: I wish :(
12:32:12 <ignacio> does it have any optimizations for lists?
12:32:17 <dmwit> Yes, lots.
12:32:19 <merijn> ignacio: There's fusion
12:32:25 <mauke> ignacio: for operations on lists
12:32:26 <merijn> ignacio: You might be wanting newtypes
12:32:30 <mauke> not so much for lists themselves
12:32:33 <ignacio> makes sense
12:32:43 <monochrom> "inquring mind wants to know, therefore you owe it to me to explain" is why I hate inquiring minds. perhaps I just mean inquiring narcissist minds.
12:32:44 <ignacio> thanks
12:32:44 <elliott> this isn't even the first time they've said Haskell sucks before leaving.
12:33:04 <byorgey> ignacio: if by "a type isomorphic to list" you mean like  data List a = Nil | Cons a (List a), then no.  However I don't know why you would want to do that.
12:33:08 <shachaf> There's no optimization on lists that you couldn't get for your own type, as far as I know.
12:33:12 <merijn> ignacio: newtype lets you define a value that (at runtime) is represented identically, but is completely separate when it comes to type checking
12:33:14 <byorgey> ignacio: if you want a type isomorphic to lists which is a distinct type, use a newtype.
12:33:24 <merijn> ignacio: Which covers most uses cases for wanting isomorphic types
12:33:30 <byorgey> that *will* probably be optimized.  I hope.
12:33:35 <ignacio> byorgey: I might do that because I'm just starting off with haskell
12:33:43 <dmwit> "You owe it to me to explain" may not be such a great attitude, but "I'm going to keep trying even though I've been frustrated before" sure seems nice.
12:33:49 <ignacio> but yeah, newtype makes sense there.
12:34:13 <monochrom> list fusion on GHC is implemented as pragmas in library code. you could write similar pragmas for your own stuff
12:34:33 --- mode: ChanServ set +o mauke
12:34:34 --- mode: mauke set +b *!*@88.129.148.32
12:34:40 --- kick: safdkjl was kicked by mauke (safdkjl)
12:35:21 <joelteon> who's that
12:35:35 <elliott> klrr
12:36:40 --- mode: mauke set -o mauke
12:39:11 <totemizer> hi. i am reading this http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf , and the first piece of code there is `divides d n = rem n d == 0` which I typed into ghci but it says parse error. what am I doing wrong?
12:39:23 <joelteon> you need let
12:39:27 <dmwit> In ghci, you need to put "let" at the beginning.
12:39:45 <dmwit> However, if you put that code in a file, it should work just fine.
12:40:22 <dmwit> totemizer++ for good question-asking skills
12:40:45 <totemizer> dmwit: doing this for 10 years, asking stupid questions, thanks :)
12:40:53 <totemizer> first time with haskell though
12:41:18 <byorgey> that was not a stupid question at all.
12:41:25 <merijn> totemizer: I'm pretty sure dmwit was serious
12:41:45 <merijn> totemizer: In the sense that you 1) said what you did, 2) where it came from 3) what you expected to happen 4) what actually happened
12:41:58 <dmwit> yup
12:42:33 <shachaf> totemizer: For what it's worth, I suspect that it's expecting you to type that line into a file (but I can't open the PDF right now so I can't double-check).
12:42:41 <monochrom> we just went through days of ill-posed incomplete inconsistent questions
12:42:44 <shachaf> Things are a bit different in ghci -- "let" is the biggest difference, really.
12:42:51 <totemizer> sry, english is not my first language, stupid for me is kind of like.. silly, too easy, easy to answer for an expert but hard to find it alone... along this way. probably not the best word :-\
12:43:17 <dmj> > let divides d n = rem n d == 0
12:43:18 <lambdabot>   not an expression: `let divides d n = rem n d == 0'
12:43:20 <totemizer> shachaf: I think it expects me to use a different interpreter
12:43:32 * djahandarie . o O ( monochrom has them alliteration skills. )
12:43:43 <dmwit> And here we see that lambdabot is not ghci. =)
12:43:51 <shachaf> Hmm, questions like that (easy for an expert, hard by yourself) are half the point of a channel like this.
12:43:59 <dmwit> ?let divides d n = rem n d == 0
12:44:01 <lambdabot>  Defined.
12:44:09 <elliott> totemizer: "Put the definition of divides in a file prime.hs. Start the Haskell in- terpreter hugs (Section 1.1). Now give the command :load prime or :l prime, followed by pressing Enter."
12:44:11 <josephle> djahandarie: the members of #haskell are secret wordsmiths :)
12:44:13 <elliott> so it was meant to go in a file
12:44:22 <elliott> you can do that with ghci instead of hugs
12:44:27 <elliott> the same instructions will work
12:44:39 <totemizer> elliott: thanks
12:44:45 <shachaf> The other half is questions that are hard by yourself *and* hard for other people.
12:45:06 * monochrom loves alliteration :)
12:45:14 <elliott> shachaf: you forgot the questions that are hard for an expert, but easy by yourself.
12:45:21 <elliott> like "why am I getting this error?" without showing code!
12:45:26 <shachaf> elliott: No, those are the worst.
12:45:51 <chrisdotcode_> :t map
12:45:52 <lambdabot> (a -> b) -> [a] -> [b]
12:46:27 <totemizer> the worst kind of question in my opinion is "i downloaded this <3rd-party-unmaintained-lib-name>. it does not work!"
12:46:48 <merijn> totemizer: Technically that's not a question but a statement :)
12:46:57 <totemizer> merijn: EXACTLY
12:47:03 <josephle> one hopes they can find the former maintainer to lambast
12:47:35 <dmwit> :t double map
12:47:37 <lambdabot>     Ambiguous occurrence `double'
12:47:37 <lambdabot>     It could refer to either `L.double',
12:47:37 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:122:1
12:47:46 <dmwit> whoops
12:47:48 <dmwit> ?undefine
12:47:49 <lambdabot> Undefined.
12:48:25 <shachaf> :-(
12:48:31 <shachaf> @let import Control.Lens.Setter
12:48:32 <lambdabot>  Defined.
12:48:33 <shachaf> @let import Control.Lens.Getter
12:48:34 <lambdabot>  Defined.
12:48:36 <shachaf> @let import Control.Lens.Lens
12:48:37 <lambdabot>  Defined.
12:48:38 <shachaf> @let import Control.Lens.Traversal
12:48:39 <lambdabot>  Defined.
12:48:40 <shachaf> @let import Control.Lens.Prism
12:48:41 <lambdabot>  Defined.
12:48:43 <shachaf> @let import Control.Lens.Iso
12:48:45 <lambdabot>  Defined.
12:48:47 <shachaf> @let import Control.Lens.Fold
12:48:48 <lambdabot>  Defined.
12:48:56 <mauke> @let import Data.Default
12:48:57 <lambdabot>  .L.hs:66:1:
12:48:57 <lambdabot>      Failed to load interface for `Data.Default'
12:48:57 <lambdabot>      Perhaps yo...
12:49:02 <dmwit> uh. sorry?
12:49:08 <haasn> shachaf: clearly we need Control.Lens.EverythingUnderTheSun
12:49:14 <arkeet> that's Control.Lens
12:49:16 <monochrom> this doesn't scale
12:49:18 <shachaf> elliott: cabal install data-default?
12:49:29 <shachaf> haasn: We're waiting on elliott for that.
12:49:34 <elliott> hmm, I'm surprised it doesn't have data-default installed
12:49:51 <monochrom> then again, it is not meant to scale, it's just lambdabot.
12:49:58 <shachaf> elliott doesn't want to fix something unless it also fixes everything else.
12:50:09 <arkeet> we don't have the new @run yet do we
12:50:10 <elliott> dmwit: how did you say I should import universe?
12:50:34 <ignacio> how do you keep lambdabot from running stuff like: show [1..]
12:50:44 <haasn> > show [1..]
12:50:45 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:50:46 <dmwit> I don't remember. import Data.Universe qualified as U, probably
12:51:02 <ignacio> neat?
12:51:06 <dmwit> > last [1..]
12:51:10 <lambdabot>   mueval-core: Time limit exceeded
12:51:15 <ignacio> ahh there
12:52:10 <dmwit> elliott: I don't remember what all I had to do to make the instances play nice with the other packages.
12:52:34 <elliott> @undefine
12:52:34 <lambdabot> Undefined.
12:52:35 <elliott> > def
12:52:36 <lambdabot>   L.hs:100:1:
12:52:36 <lambdabot>      Data.Universe: Can't be safely imported!
12:52:36 <lambdabot>      The module i...
12:52:40 <elliott> lol.
12:52:46 <dmwit> oh
12:52:50 <elliott> @undefine
12:52:51 <lambdabot> Undefined.
12:53:08 <elliott> do you use, uh, Hashable or something?
12:53:15 <dmwit> Everything should be safe, how do I ask the compiler to confirm that for me?
12:53:19 <dmwit> A link to the documentation is fine.
12:53:31 <chrisdotcode_> are you guys currently trying to break lambabot?
12:53:38 <haasn> no, we're trying to unbreak it
12:53:40 <elliott> dmwit: it should Just Work.
12:53:45 <chrisdotcode_> :t performUnsafeIO
12:53:45 <lambdabot> Not in scope: `performUnsafeIO'
12:54:00 <dmwit> elliott: hm. Well, I depend on a lot of packages to provide Universe instances for them.
12:54:09 <dmwit> I could split that into a separate package; maybe that would make some things easier.
12:54:09 <haasn> chrisdotcode_: that isn't even a function, it's unsafePerformIO you're thinking of
12:54:15 <elliott> dmwit: ah, you import Data.Void
12:54:19 <elliott> dmwit: this is not a problem inherently
12:54:23 <elliott> but it is with the current packages lambdabot has
12:54:23 <chrisdotcode_> haasn: ah, yes. thank you :)
12:54:28 <chrisdotcode_> :t unsafePerformIO
12:54:29 <lambdabot> Not in scope: `unsafePerformIO'
12:54:36 <dmwit> oh
12:54:36 <elliott> it would need to reinstall everything, which I will do but is a big fuss
12:54:39 <shachaf> representable-functors isn't safe.
12:54:42 <chrisdotcode_> is't it IO a -> a?
12:54:46 <elliott> I guess I'll look into the timeouts problem while I'm at this
12:54:48 <haasn> chrisdotcode_: yes
12:54:56 <chrisdotcode_> haasn: thank you :)
12:55:25 <mauke> @hoogle unsafePerformIO
12:55:25 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:55:25 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:55:25 <lambdabot> Graphics.UI.GLUT.Raw.APIEntry unsafePerformIO :: IO a -> a
12:56:02 <ignacio> lambdabot: help
12:56:49 <mauke> > def
12:56:50 <lambdabot>   ()
12:56:56 <mauke> > length def
12:56:56 <lambdabot>   0
12:57:01 <dmwit> ignacio: try ?help
12:57:10 <haasn> :t asTypeIn
12:57:11 <lambdabot> a -> (a -> b) -> a
12:57:14 <haasn> oh good
12:57:32 <ignacio> ?help
12:57:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:57:33 <mauke> > length (def "")
12:57:34 <lambdabot>   0
12:57:37 <ignacio> list
12:57:41 <mauke> yes~
12:57:45 <ignacio> ?help list
12:57:46 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
12:57:55 <dmwit> ignacio: almost there...
12:58:08 <ignacio> ?list
12:58:08 <lambdabot> What module?  Try @listmodules for some ideas.
12:58:13 <ignacio> @listmodules
12:58:13 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
12:58:13 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
12:58:18 <elliott> you are in a maze of twisty passages.
12:58:23 <ignacio> ?list grue
12:58:24 <lambdabot> No module "grue" loaded
12:58:27 <dmwit> =)
12:58:33 <levi> go north
12:58:38 <elliott> they're not all alike because one of them contains help for lambdabot commands.
12:58:42 <josephle> you are eaten by a grue!
12:58:48 <ignacio> ?list djinn
12:58:48 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
12:59:00 <ignacio> ?help djinn
12:59:00 <lambdabot> djinn <type>.
12:59:00 <lambdabot> Generates Haskell code from a type.
12:59:01 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
12:59:22 <ignacio> I thought it was a GEB reference
12:59:22 <haasn> @djinn f :: (a -> b) -> b -> Maybe a -> b
12:59:23 <lambdabot> Cannot parse command
12:59:27 <haasn> @djinn (a -> b) -> b -> Maybe a -> b
12:59:27 <lambdabot> f a b c =
12:59:27 <lambdabot>     case c of
12:59:27 <lambdabot>     Nothing -> b
12:59:27 <lambdabot>     Just d -> a d
13:00:35 <ignacio> it spits out some function with that type?
13:00:40 <dmwit> yup
13:00:41 <ignacio> @djinn a -> a
13:00:41 <lambdabot> f a = a
13:00:43 <ignacio> neato
13:00:44 <haasn> pretty much
13:00:52 <haasn> it tries to pick the ‘prettiest’ function
13:00:59 <ignacio> @djinn [a] -> a
13:00:59 <lambdabot> Error: Undefined type []
13:01:02 <haasn> eg. an equally valid function would be f _ a _ = a
13:01:08 <shachaf> @djinn pretty :: a -> a -> a
13:01:08 <lambdabot> Cannot parse command
13:01:13 <shachaf> @djinn a -> a -> a
13:01:13 <lambdabot> f _ a = a
13:01:25 <shachaf> I guess that's prettier than const.
13:01:26 <FreeFull> :t const $ flip const
13:01:26 <lambdabot> b -> b1 -> c -> c
13:01:32 <FreeFull> :t const $  const
13:01:33 <lambdabot> b -> a -> b1 -> a
13:01:34 <mauke> @djinn (Monoid a) => a -> a -> a
13:01:34 <lambdabot> Error: Class not found: Monoid
13:01:45 <FreeFull> :t const . const
13:01:45 <lambdabot> a -> b -> b1 -> a
13:01:54 <haasn> it doesn't know about type classes or recursive types afaik
13:02:02 <ignacio> @djinn a -> b
13:02:02 <lambdabot> -- f cannot be realized.
13:02:03 <shachaf> Djinn knows about type classes but only badly.
13:02:03 <mauke> @djinn-add class Monoid a where mempty :: a; mappend :: a -> a -> a
13:02:10 <mauke> @djinn (Monoid a) => a -> a -> a
13:02:10 <lambdabot> f = mappend
13:02:11 <FreeFull> :t const . flip const
13:02:12 <lambdabot> a -> b -> c -> c
13:02:19 <FreeFull> :t flip const . const
13:02:20 <lambdabot> a -> c -> c
13:02:31 <FreeFull> Well, whatever
13:02:36 <FreeFull> What you want is  const $ const
13:02:37 <shachaf> You can also /msg lambdabot.
13:03:00 <shachaf> @djinn Monoid a => a -> a -> a -> a
13:03:00 <lambdabot> f a b _ = mappend a b
13:03:15 <shachaf> @djinn Monad m => a -> m a
13:03:15 <lambdabot> f = return
13:03:16 <shachaf> @djinn Monad m => b -> m b
13:03:16 <lambdabot> -- f cannot be realized.
13:03:20 <shachaf> Thanks, djinn.
13:03:23 <ignacio> @djinn a
13:03:23 <lambdabot> -- f cannot be realized.
13:03:24 <haasn> FreeFull: also known as  const const  ;)
13:03:26 <ignacio> @djinn a -> ()
13:03:26 <lambdabot> f _ = ()
13:03:32 <FreeFull> :t const const
13:03:33 <lambdabot> b -> a -> b1 -> a
13:03:39 <shachaf> const () should be in base.
13:03:39 <FreeFull> haasn: Oh =P
13:03:45 <ignacio> @djinn a -> [a]
13:03:45 <lambdabot> Error: Undefined type []
13:03:49 <shachaf> It should be called obvious
13:03:57 <shachaf> roconnor's name
13:04:00 <ignacio> no recursive types -> no lists?
13:04:02 <mauke> :t def :: a -> ()
13:04:03 <lambdabot> a -> ()
13:04:18 <shachaf> ignacio: Lists are boring as far as Djinn is concerned.
13:04:18 <FreeFull> :t def
13:04:19 <lambdabot> Default a => a
13:04:20 <shachaf> So is Maybe.
13:04:24 <shachaf> So is this channel.
13:04:40 <haasn> djinn doesn't find excitement in a lot of things does it
13:04:49 * FreeFull eats kartoffelbrei
13:04:50 <mauke> hitman monkey
13:04:56 <ignacio> @djinn
13:04:56 <lambdabot> Cannot parse command
13:05:13 <aristid> @dinn a -> b -> c -> (b -> a -> c)
13:05:13 <lambdabot> f _ _ a _ _ = a
13:05:38 <haasn> I think you meant (a -> b -> c) -> b -> a -> c
13:05:55 <joelteon> @djinn (a -> b -> c) -> b -> a -> c
13:05:55 <lambdabot> f a b c = a c b
13:05:57 <aristid> @dinn (a -> b -> c) -> (b -> a -> c)
13:05:57 <lambdabot> f a b c = a c b
13:06:16 <aristid> haasn: well, djinn liked both:)
13:06:20 <FreeFull> @dinn flip
13:06:20 <lambdabot> -- f cannot be realized.
13:06:32 <FreeFull> @dinn a -> b
13:06:33 <lambdabot> -- f cannot be realized.
13:06:37 <haasn> @@ @djinn @type flip
13:06:38 <lambdabot>  f a b c = a c b
13:06:44 <FreeFull> @dinn a -> b -> b
13:06:44 <lambdabot> f _ a = a
13:07:04 <FreeFull> @dinn a -> b -> c -> d -> (a,b,c,d)
13:07:05 <lambdabot> f a b c d = (a, b, c, d)
13:07:08 <ignacio> it'd be nice if it said whether the function is unique
13:07:21 <joelteon> haha
13:07:27 <joelteon> let implement = @@ @djin @type
13:07:42 <FreeFull> @implement map
13:07:43 <lambdabot> Unknown command, try @list
13:08:09 <FreeFull> @@ @djinn @type map
13:08:09 <lambdabot>  Error: Undefined type []
13:08:19 <ignacio> @djinn Int
13:08:19 <lambdabot> Error: Undefined type Int
13:08:20 <FreeFull> @@ @djinn @type flip const flip const flip
13:08:21 <lambdabot>  f _ a b c = a c b
13:08:24 <FreeFull> @@ @djinn @type flip const flip const flip id id id
13:08:25 <lambdabot>  f a = a (\ b -> b)
13:08:38 <monochrom> are you done playing with lambdabot?
13:08:53 <haasn> shachaf │ You can also /msg lambdabot.
13:09:04 <FreeFull> Does this mean that    flip const flip const flip id id id === ($ id)
13:10:08 <monochrom> I don't know. let's calculate.
13:10:18 <Eduard_Munteanu> Hrmpf... why do I think   (f . g) $ x `op` do [...]   looks better than    f . g $ x `op` do [...]    ? Anybody agree?
13:10:21 <Fuuzetsu> > (2 :: Int) >>= (3 :: Int)
13:10:22 <lambdabot>   Couldn't match expected type `m0 a0'
13:10:22 <lambdabot>              with actual type `GHC.Typ...
13:10:25 <joelteon> :t flip const flip const flip id id id
13:10:27 <lambdabot> ((a -> a) -> c) -> c
13:10:40 <haasn> flip const flip const flip id id id = const const flip flip id id id = const flip id id id = flip id id = flip ($) id = ($ id)
13:10:41 <Fuuzetsu> > ((2 :: Int) >>= 3) :: Bool
13:10:42 <monochrom> (flip const flip const) flip id id id = (const) flip id id id
13:10:43 <haasn> yes
13:10:43 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
13:10:43 <lambdabot>              with actual type...
13:10:43 <Eduard_Munteanu> f $ x   just seems ugly.
13:11:00 <monochrom> (const flip id) id id = (id) id id
13:11:18 <monochrom> (id id) id = (id) id = id
13:11:45 <dmwit> (const flip id) = (id) doesn't look right
13:11:55 <Fuuzetsu> oh damn it, I read ‘>=’ as ‘>>=’… Here I thought I was experiencing some dirty hack
13:12:07 <haasn> monochrom: no (const flip id) = (flip)
13:12:09 <monochrom> ($ id) = (\x -> x $ id) = (\x -> x id)
13:12:25 <ignacio> I see #haskell is really geared for conversation :P
13:12:39 <monochrom> oh, right
13:12:49 <Eduard_Munteanu> Or equivalently...    (foo . bar . baz) $ do [...]
13:12:54 <monochrom> (const flip id) id id = (flip) id id
13:13:22 <Eduard_Munteanu> s/equivalently/similarly/
13:13:24 <Fuuzetsu> @pl f x = f . g x
13:13:27 <lambdabot> f = id (fix (flip ((.) . (.)) g))
13:13:27 <lambdabot> optimization suspended, use @pl-resume to continue.
13:13:48 <monochrom> (flip id) id = (flip ($)) id = ($ id), yeah.
13:13:50 <Fuuzetsu> could it really be the time to use .: …
13:13:55 <dmwit> Why does ?pl suspend optimization so much more than it used to?
13:14:02 <Fuuzetsu> It's broken apparently
13:14:15 <haasn> Fuuzetsu: that doesn't type check
13:14:16 <shachaf> It's broken and elliott doesn't care enough to fix it.
13:14:19 <joelteon> f = id (...) seems weird.
13:14:35 <Fuuzetsu> haasn: I wasn't just going to use that, no worries
13:14:45 <dmwit> Unless elliott broke it in the first place, I don't blame him.
13:14:59 <monochrom> id sometimes takes on the type (a->b)->(a->b), which is ($)
13:15:19 <shachaf> dmwit: It was working and then elliott started running lambdabot instead of Cale.
13:15:28 <haasn> let's all blame elliott
13:15:28 <shachaf> At which point it wasn't working.
13:15:53 <dmwit> I know that bit of history, thanks.
13:16:51 <shachaf> OK, then why not blame him?
13:17:02 <shachaf> Alternatively: Who cares about blame? It should be fixed, and elliott is the only person in a position to fix it.
13:17:16 <dmwit> I don't believe that.
13:17:26 <haasn> isn't lambdabot's current code publicly available?
13:17:29 <dmwit> Yes.
13:17:33 <FreeFull> monochrom: id can take on any value for a
13:17:35 <shachaf> What, you want me to debug it remotely?
13:17:44 <dmwit> No.
13:17:53 <shachaf> I have a lambdabot instance working. I downloaded it from Hackage, compiled it, and @pl just worked.
13:18:11 <haasn> but does that include all of elliott's modification (I'm assuming there are some)?
13:18:14 <dmwit> Okay. Then I blame elliott.
13:18:30 <dmwit> Under the assumption that the one you downloaded is the most recent release.
13:19:07 <shachaf> It is not.
13:19:44 <shachaf> It's the responsibility of whoever is running lambdabot to have things like @pl working.
13:20:04 <dmwit> Hm. I'm not sure I subscribe to that. =P
13:20:22 <haasn> responsibility, perhaps, but that still doesn't mean only elliott is in the situation to investigate and resolve the issue
13:20:54 <kier> @pl \a -> a
13:20:55 <lambdabot> id
13:20:57 <haasn> the only way I would see that being the case is if elliott doesn't make his instance's code public
13:22:15 <elliott> shachaf: I've made efforts to fix @pl in a future-proof manner.
13:24:17 <shachaf> I see.
13:25:17 <elliott> feel free to bug benmachine if you'd like, last I asked he was planning to look into including a Haskell API for the pointfree package that lambdabot could hook into.
13:25:26 <elliott> no sense in having two copies of the codebase, one inside lambdabot
13:26:15 <FreeFull> @pl \x -> \y -> y x y
13:26:15 <lambdabot> join . flip id
13:27:04 <shachaf> Hmm, you could use the "API" as in "running the binary".
13:27:49 <elliott> no
13:27:51 <elliott> because of timeouts
13:28:22 <elliott> well, maybe it already has the timeout @pl does, I don't know, but I'd much prefer a haskell API since spawning processes is slower and more brittle
13:28:50 <NemesisD> hey guys, you aren't sick of me asking for help on this state machine project yet are you?
13:29:05 <NemesisD> because i'm about to do it again
13:29:15 <chrisdotcode_> @src foldr
13:29:15 <lambdabot> foldr f z []     = z
13:29:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:29:38 <chrisdotcode_> does the order matter? could it also be:
13:29:38 <chrisdotcode_> f (foldr f z xs) x?
13:30:06 <mauke> chrisdotcode_: well, that would change the type of foldr slightly
13:30:10 <mauke> no real difference, though
13:30:14 <chrisdotcode_> mauke: well, besides the type change
13:30:16 <chrisdotcode_> yeah, okay.
13:30:17 <elliott> shachaf: anyway if you'd like to try debugging the problem with the copy of @pl's code lambdabot has non-remotely, I suspect you can just git clone https://github.com/mokus0/lambdabot.git and run it from ghci
13:30:25 <chrisdotcode_> I was just asking if it was that way because of effeciency or something
13:30:27 <chrisdotcode_> thanks, mauke
13:30:45 <mauke> foldr (:) [] is a no-op
13:30:59 <lpaste> NemesisD pasted “more state machine fun” at http://lpaste.net/91033
13:31:09 <NemesisD> could someone help me figure out what i'm doing wrong here^
13:31:44 <n-dolio> mauke: Nah, it does plenty of ops that it doesn't need to.
13:32:45 <shachaf> elliott: I can't clone that due to aforementioned Internet connection corrupting packets.
13:34:11 <ClaudiusMaximus> NemesisD: maybe remove the problem type signature and see what ghci says its type is?
13:34:22 <elliott> I wonder if it's just a bug that mueval's time limit isn't in seconds.
13:34:35 <dmwit> shachaf: Hm. I didn't see your previous message, so I don't really know the nature of the problem you're having; would it be helpful for me to host the repository somewhere else?
13:34:52 <shachaf> dmwit: It was "aforementioned" in a different channel.
13:35:05 <shachaf> Anyway it's a problem on my end. I'll fix it eventually.
13:35:13 <dmwit> ok
13:36:39 <dmwit> NemesisD: I suspect you should annotate your myStateMachine as a StateMachine FSMState (StateT FSMState IO) String or similar instead of StateMachine FSMState IO String. But I haven't tried it.
13:36:40 <Eduard_Munteanu> I find myself wishing for this at times... is there something like Maybe/Either that handles errors, success *and* early exit (but still successful)?
13:36:55 <mauke> Cont?
13:37:02 <Eduard_Munteanu> Cont does, yeah.
13:37:14 <ion> Either (Either e a) a ;-)
13:37:39 <dmwit> beautiful
13:37:51 <Eduard_Munteanu> I mean some nice wrapper for that (more adhoc?).
13:38:07 <shachaf> That's not especially ad-hoc.
13:38:17 <simon> NemesisD, No instance for (MonadState FSMState IO) is connected to your attempt to runStateT (initialState sm)
13:38:18 <shachaf> Either isn't for "errors" exactly so much as for "early exit".
13:38:25 <shachaf> You can exit either with an error or with a success.
13:38:57 <shachaf> mauke: Did you see Oleg's (forall m. Monad m => (a -> m Void) -> m Void) -> a?
13:39:00 <simon> NemesisD, that is, FSMState must be an instance of Monadstate before you can do that.
13:39:02 <shachaf> Even that doesn't use Cont.
13:39:08 <simon> NemesisD, sorry, MonadState.
13:39:15 <Eduard_Munteanu> Well, you must be able to distinguish errors from early exit. And preferably *not* distinguish early and late exit.
13:39:24 <mauke> shachaf: no
13:39:43 <shachaf> You can implement a function with that type in Haskell! It's great.
13:39:52 <mauke> Eduard_Munteanu: I wrote something tangentially related in Perl but that doesn't help you
13:40:15 <dmwit> ?djinn Not (Not a) -> a
13:40:16 <lambdabot> -- f cannot be realized.
13:40:37 <mauke> shachaf: that doesn't even look hard
13:40:46 <mauke> I get to choose m
13:40:51 <shachaf> Right, it's not.
13:41:10 <joelteon> how does that return a value?
13:41:16 <mauke> side channely
13:42:06 <Eduard_Munteanu> mauke: related how? I guess monads aren't really at home in Perl.
13:42:09 <NemesisD> simon: i guess i may have an incorrect assumption some there, i was not anticipating on defining an instance of that monad
13:42:34 <NemesisD> simon: i was trying to force the monadstateness to the m parameter of the StateMachine s m a
13:42:35 <Eduard_Munteanu> (But yes, I have wished for monads in other languages before. :D)
13:43:17 <dmwit> I guess ((a -> Either a Void) -> Either a Void) -> a looks pretty easy.
13:43:25 <simon> NemesisD, do you know about the RWS monad?
13:43:33 * byorgey hasn't been following but noticed someone mention  (MonadState FSMState IO), for which I highly doubt there is a sensible instance
13:43:58 <simon> byorgey, it's because he is testing his monad directly in main
13:44:06 <byorgey> ah, ok
13:44:24 <simon> but yeah, NemesisD, you probably want to get that IO out of there.
13:44:28 <ClaudiusMaximus> :t runStateT
13:44:30 <lambdabot> StateT s m a -> s -> m (a, s)
13:44:39 <shachaf> dmwit: Right. But foo :: Monad m => (a -> m Void) -> m Void can't do anything m-specific.
13:45:11 <ClaudiusMaximus> so that use is  runStateT action initial, but NemesisD has runStateMachine sm action = runStateT (initialState sm) $ runReaderT action sm
13:45:27 <NemesisD> simon: i do but it didn't seem like the right choice, i don't need the writer
13:45:43 <mr-> dmwit: how is it easy?
13:45:48 <ClaudiusMaximus> adding a flip gives an infinite type error, though..
13:45:50 <dmwit> shachaf: I'm not sure I understand why you connected those two sentences with "but".
13:45:56 <dmwit> Does one contradict the other?
13:45:59 <zRecursive> @unmtl StateT s m a
13:45:59 <lambdabot> s -> m (a, s)
13:46:21 <dmwit> mr-: \f -> case f Left of Left a -> a
13:46:24 <NemesisD> simon: not sure what you mean by there in get that IO out of there
13:46:29 <elliott> shachaf: well, foo :: (a -> Either a Void) -> Either a Void can't do much specific either.
13:46:58 <shachaf> If X contradicts Y it's silly to say "X but Y".
13:48:03 <FreeFull> elliott: Is there any definition for that other than bottom?
13:48:05 <mr-> dmwit: is there a const missing?
13:48:05 <dmwit> Okay, I'll ask a better question.
13:48:17 <dmwit> mr-: I don't think so.
13:48:20 <elliott> FreeFull: for a specific a, yes.
13:48:23 <dmwit> :t \f -> case f Left of Left a -> a
13:48:24 <lambdabot> ((a -> Either a b) -> Either t t1) -> t
13:48:37 <NemesisD> ah i see you're right about the runStateT being backwards
13:48:39 <mr-> hrm ;-)
13:48:44 <elliott> dmwit: you want ; Right v -> absurd v.
13:48:48 <NemesisD> i think...
13:48:52 <dmwit> shachaf: Does the fact that ((a -> Either a Void) -> Either a Void) -> a is easy not imply that Oleg's type is easy?
13:48:56 <FreeFull> elliott: Ah, I was thinking for a general a
13:49:12 <dmwit> elliott: sure
13:49:27 <simon> NemesisD, let me see if I understand what you're doing.. a state-machine that goes from Init->Middle->Complete. what do you use the reader for?
13:49:31 <shachaf> dmwit: It does.
13:49:38 <dmwit> okay, great
13:49:58 <NemesisD> simon: it has defined transitions and can execute monadic actions on some or all of the transitions
13:50:04 <ClaudiusMaximus> NemesisD: the infinite type issue comes from your MonadReader containing the action that the runReaderT is running
13:50:11 <dmwit> Now to think about what kind of values have the shape forall m. Monad m => (a -> m Void) -> m Void.
13:50:34 <shachaf> http://okmij.org/ftp/Computation/lem.html
13:51:50 <lpaste> bb010g revised “One-line FizzBuzz”: “One-line FizzBuzz” at http://lpaste.net/91009
13:52:35 <Zenol> Hi!
13:52:39 <FreeFull> There is no haskell program that can't be made into a oneliner
13:52:47 <haasn> true
13:52:57 <ignacio> how about the empty program
13:53:05 <haasn> not a valid haskell program, missing main
13:53:20 <ignacio> also you can just add \n
13:53:28 <hpc> there's also no java program that can't be made into a one-liner; however, our one-liners are shorter ;)
13:53:54 <FreeFull> Anyway, that one-line fizzbuzz is way too long
13:54:00 <monochrom> I don't like counting lines. I prefer counting tokens.
13:54:03 <NemesisD> ClaudiusMaximus: what can i do about that
13:54:18 <haasn> fizzBuzz x = fromMaybe (show x) $ ["fizz" | x `rem` 3 == 0] <> ["buzz" | x `rem` 5 == 0]
13:54:32 <hpc> monochrom: getouttahere, you lously lisper
13:54:55 <monochrom> I do not use or like lisp. or even scheme.
13:54:59 <hpc> ah
13:55:11 <hpc> well, i had a professor that would love to brag about how his code used fewer S-expressions
13:55:20 <ClaudiusMaximus> NemesisD: a newtype perhaps, but then you have to wrap/unwrap
13:55:27 <shachaf> @quote monochrom lisp
13:55:27 <lambdabot> monochrom says: in retrospect, it seems lisp designers were more interested in list processing than functional programming
13:55:47 <johnw> ClaudiusMaximus: ala (from newtype, or lens) can be wrapping/unwrapping much easier
13:55:48 <monochrom> my haskell programs use fewer S-expressions than all non-empty lisp programs :)
13:55:54 <johnw> s/be/make
13:55:58 <NemesisD> *weeps*
13:56:54 <simon> NemesisD, I'd use a newtype as well.
13:57:13 <simon> NemesisD, I'm still unsure what you're reading.
13:57:41 <merijn> haasn: Neat use of monad comprehensions there :)
13:58:07 <dmwit> Oh, I see. The claim that (a -> b) is isomorphic to (forall m. Monad m => a -> m b) doesn't imply that we can do LEM because the translation needs to have access to the source code.
13:58:16 <NemesisD> simon: im sneaking the StateMachine into the user-supplied monad so the transform code can use it but they don't need to worry about it
13:58:19 <NemesisD> amd o
13:58:27 <NemesisD> and i'm not sure over what type i need a newtype
13:59:01 <simon> NemesisD, so you're letting transforming monad actions read the state but not change it?
13:59:16 <dmwit> or...
13:59:38 * Zenol wonder what dmwit is talking about.
13:59:44 <ClaudiusMaximus> if you get occurs check  m = .... m ...   then something like   newtype M = MkM (.... M ....)   might work
13:59:55 <NemesisD> simon: i suppose the user-supplied monadic action shouldn't need to read that statemachine from the reader, but yeah they shouldn't be able to change it
14:00:01 <hpc> dmwit: there's not really an isomorphism if you can't write a function to go back and forth, i think?
14:00:09 <hpc> *pair of functions
14:00:10 <NemesisD> simon: its a bit of magic that makes transition work, which is part of the "library"
14:00:21 <simon> NemesisD, maybe you want 'newtype FSM a = FSM (StateT FSMState (Reader ...sometype... a))
14:00:22 <dmwit> hpc: The pair of functions may not be implementable in the language, though. And that's fine.
14:00:31 <hpc> ah, fair
14:00:53 <dmwit> :t \f g -> return (f (runIdentity . g))
14:00:54 <lambdabot> Monad m => ((a1 -> c) -> a) -> (a1 -> Identity c) -> m a
14:01:15 <NemesisD> simon: yikes
14:01:23 <NemesisD> i may need to cut my losses on this thing
14:01:31 <dmwit> :t \f g -> return (f (runIdentity . g)) :: ((a -> b) -> b) -> (forall m. Monad m => (a -> m b) -> m b)
14:01:32 <lambdabot>     Illegal symbol '.' in type
14:01:32 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
14:01:32 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
14:01:38 <simon> NemesisD, do you have a task description?
14:02:02 <haasn> dmwit: (return .) and (runIdentity .) seems to be the isomorphism?
14:02:46 <dmwit> Taking care of polymorphism is the tricky bit.
14:03:33 <elliott> dmwit: the isomorphism isn't one you can witness in Haskell, afaik
14:03:36 <NemesisD> simon: not sure what you mean
14:03:46 <elliott> dmwit: you have to define it by induction on Haskell terms.
14:04:04 <dmwit> elliott: Yes, I believe you and I are saying the same thing.
14:04:25 <elliott> right.
14:04:27 <dmwit> Zenol: Oh, sorry, missed your question. http://okmij.org/ftp/Computation/lem.html
14:04:54 <NemesisD> simon: like what this is supposed to do?
14:06:14 <Zenol> dmwit> Thanks, although I'm not sure I can understand that :s
14:09:37 <byorgey> haasn: yes, that is an isomorphism between (a -> b)  and (forall m. Monad m => a -> m b).
14:10:00 <byorgey> the point seems to be that you can always replace the former by the latter in any type, and they will be isomorphic.
14:10:21 <haasn> oh
14:10:37 <byorgey> that is, e.g.  ((a -> b) -> (c -> d)) is isomorphic to  ((a :-> b) :-> (c :-> d))  where   x :-> y =  forall m. Monad m => x -> m y
14:10:54 <haasn> that's obviously not something you can do with a haskell function because it's impossible to write a function that's polymorphic over “every type signature that contains X somewhere”
14:11:01 <byorgey> haasn: right.
14:11:31 <dmwit> Well, even implementing the particular isomorphism ((a -> b) -> c) -> (forall m. (a -> m b) -> m c) seems to be something you can't do.
14:11:36 <dmwit> uh
14:11:40 <dmwit> forall m. Monad m =>, of course
14:11:49 <byorgey> really?  that is surprising to me.
14:12:11 <dmwit> If you believe that you can't implement ((a -> Void) -> Void) -> a, then this claim follows.
14:12:29 <dmwit> Because you can implement (forall m. Monad m => (a -> m Void) -> m Void) -> a. =)
14:12:53 <byorgey> fair enough.
14:13:04 <dmwit> It was surprising to me, too.
14:13:14 <dmwit> I'm still trying to read ghci's error message.
14:14:07 <hpc> dmwit: forgive me if i don't consider a thing possible just because oleg did it :P
14:14:16 <dmwit> hah!
14:14:25 <elliott> dmwit: well, because the monadic function passed in "has effects".
14:14:32 <elliott> and you don't get to "observe" when it's called in ((a -> b) -> c).
14:14:40 <byorgey> ahhh
14:14:41 <elliott> this explanation provided to you courtesy of scare quote industries, inc.
14:15:00 <elliott> the reason you can define it by induction on terms is because then you *do* get to see where the function is called.
14:15:40 <dmwit> Okay. At a high level, this seems reasonable.
14:15:51 <mauke> hpc: http://this-plt-life.tumblr.com/post/41439555366/when-oleg-shows-a-newbie-how-to-solve-a-problem
14:16:22 <monochrom> hehehe, I like that :)
14:16:41 <monochrom> (and others in the same collection :) )
14:16:58 <monochrom> there is one about adding IO to haskell :)
14:17:03 <elliott> dmwit: I think the isomorphism might not also be quite exact?
14:17:09 <ion> mauke: :-)
14:17:18 <elliott> dmwit: because you can certainly prove ((A -> Void) -> Void) for some As without having a value of A.
14:17:31 <elliott> dmwit: the catch is, you have to have a value of type A in the body of the lambda -- but it can *depend* on the (A -> Void) passed in.
14:17:42 <elliott> and jamming the "m" in there somehow stops you abusing this.
14:18:10 <joergfritsch> What is the best way to implement increasing sequence numbers in Haskell? Is it the state monad, IOREfs or ?
14:18:26 <dmwit> > [1..]
14:18:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:18:36 <dmwit> elliott: I definitely didn't follow that explanation.
14:18:38 <mauke> joergfritsch: lists
14:18:52 <elliott> dmwit: the intuition I'm using is from an old blog post of roconnor's. let me see if I can dig it up.
14:18:56 <joergfritsch> how would a list tell me the current state? By appending?
14:19:02 <mauke> joergfritsch: by its first element
14:19:41 <joergfritsch> mauke: first element? you mean last? sequence number 21 is after 20 etc..
14:19:49 <mauke> joergfritsch: no, first
14:19:54 <elliott> dmwit: http://r6.ca/blog/20040616T005300Z.html
14:20:00 <joergfritsch> mauke: no understand
14:20:08 <mauke> joergfritsch: what state?
14:20:16 <hpc> joergfritsch: conduit is the current state of the art in increasing numbers ;)
14:20:24 <hpc> but the field is rapidly evolving
14:20:31 <elliott> dmwit: presumably you cannot translate the double-negated proof there to the form involving the Monad.
14:20:39 <elliott> I suspect trying to do so would be educational.
14:20:50 <joergfritsch> state of the sequence: first I send out part 1, then part 2 etc. ... I need to track what has been sent and what still needs to be send
14:22:29 <acowley> joergfritsch: Maybe fleshing out your scenario would help
14:22:34 <simon> NemesisD, yes, what it's supposed to do.
14:23:05 <dmwit> elliott: thanks
14:23:07 <joergfritsch> acowley: sequence numbers from 0 to 254 that roll over when 254 has been reached.
14:23:20 <acowley> > cycle [0..4]
14:23:21 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
14:23:32 <joergfritsch> acowley: sequence numbers are to be used in a network protocol.
14:23:47 <dmwit> 254 is an idiosyncratic upper limit
14:23:55 <acowley> dmwit: Think different
14:24:18 <NemesisD> simon: i wanted a way for a user to describe a statemachine where the state is a Monoid, to define the transitions it supports and a monadic action to perform on certain transitions (or all transitions)
14:24:57 <NemesisD> simon: and to provide a monadic interface for performing those transitions within the monad the statemachine is parameterized for using "transition"
14:25:06 <joergfritsch> acowley: creating the sequence is not a problem, but there needs to be some pointer to it
14:25:17 <banister> NemesisD: sounds nerdy
14:25:25 <dmwit> The sequence *is* the pointer.
14:25:38 <NemesisD> banister: i don't disagree with you there
14:25:42 <acowley> joergfritsch: Yeah, I understand, but you're going to have to give some more context for anyone to help you do the plumbing
14:26:06 <rgrinberg> joergfritsch: if you really need to walk the sequence in both directions use a zipper
14:26:16 <Zenol> Who is oleg? x)
14:26:21 <simon> NemesisD, so every time you change state, whatever action made that change triggers some other actions?
14:26:57 <dmwit> I don't think joergfritsch suggested that he needs to walk the sequence in both directions. As a consequence, I think learning about zippers at this point would be a wild goose chase.
14:27:38 <NemesisD> simon: hmm not sure if i would phrase that, calling transition NextState will check if NextState can transition from the current state. the whole monad aborts if no. if yes, it calls your specified onTransition function to run the action associated with that transition
14:27:41 <joergfritsch> acowley: think about tcp sequence numbers. Very similar. The application should embed sequence numbers in packets (ByteStrings) and whenever a new packet is send it should know what is the next sequence number to be used. If 254 is used restart at 0.
14:28:25 <dmwit> It seems I'm mixing up my metaphors. I meant red herring, not wild goose chase.
14:29:01 <acowley> joergfritsch: If you're just generating packets, then you just mapM_ f (cycle [0..254])
14:29:08 <amyers> Is there a version of mod that works on Fractionals somewhere?
14:29:12 <monochrom> wild red herring chase :)
14:29:12 <simon> NemesisD, ahh!
14:29:14 <zRecursive> :t (*>)
14:29:15 <lambdabot> Applicative f => f a -> f b -> f b
14:29:20 <acowley> farmed red herring isn't that bad
14:29:23 <dmwit> :t fmod -- amyers
14:29:24 <simon> NemesisD, and there's only one action per state it transitions to?
14:29:24 <lambdabot>     Not in scope: `fmod'
14:29:25 <lambdabot>     Perhaps you meant `mod' (imported from Prelude)
14:29:29 <dmwit> :t mod'
14:29:30 <lambdabot> Real a => a -> a -> a
14:29:38 <dmwit> Who can remember this stuff.
14:30:04 <acowley> where does mod' come from?
14:30:09 <dmwit> ?index mod'
14:30:10 <lambdabot> bzzt
14:30:10 <NemesisD> simon: there may not be anything to do on some transitions, in which case your onTransition :: s -> s -> m a would be a noop
14:30:15 <dmwit> dunno!
14:30:17 <dmwit> ?hoogle mod'
14:30:17 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
14:30:18 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
14:30:21 <amyers> :t mod'
14:30:22 <lambdabot> Real a => a -> a -> a
14:30:22 <joergfritsch> acowley: I guess the problem is that this is not happening one after each other. Information may arrive, needs a sequence number, gets send. After two minutes again information arrives, new call to the sequence number function ... .
14:30:27 <simon> NemesisD, ok, cool.
14:30:32 <NemesisD> simon: im beginning to realize that it is probably foolish to model onTransition as a function
14:30:51 <simon> NemesisD, but what does these onTransition functions change? the state machine itself, or some other state?
14:30:54 <amyers> Where does mod' come from?  It's not in my ghci
14:30:58 <dmwit> That's sort of an odd place for it. But there it is.
14:31:02 <shachaf> @hoogle mod'
14:31:02 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
14:31:03 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
14:31:05 <dmwit> amyers: See the ?hoogle query above.
14:31:09 <Zenol> dmwit> If I understand what's written, ((A->F)->F)->A is something that should always be true (and equivalent to telling "if supposing A is false lead to a contradiction, then A was true" ?
14:31:12 <shachaf> Oh, dmwit said so above.
14:31:20 <taylorgb_> NemesisD: How are your problems progressing
14:31:20 <simon> NemesisD, it seems useful to have a map between states and actions that are triggered when entering that state.
14:31:24 <amyers> dmwit: Thanks :p
14:31:35 <dmwit> Zenol: ((A->F)->F) -> A is not implementable in Haskell.
14:31:36 <NemesisD> simon: i think it maybe makes more sense for something like transitions :: Map (s, s)  (Maybe (m a)) or something
14:31:37 <acowley> huh, I wouldn't have thought to look there if I needed it
14:31:57 <dmwit> Zenol: It is not "true" except in logics that take it or something equivalent to it as an axiom.
14:31:59 <NemesisD> taylorgb_: as the days go on i see more flaws with my reasoning, but am no closer to a working compile :P
14:32:23 <taylorgb_> Did you see the paste I made? A very poor approximation of a state machine :p
14:32:33 <NemesisD> simon: the maybe is gross there but it is a supported case for the transition to have no meaningful side effect
14:32:38 <dmwit> Zenol: However, I find your English translation of the logic to be accurate.
14:32:42 <byorgey> Zenol: in particular, it is problematic for logics used as a basis for talking about computation, because it is "non-constructive".
14:33:09 <simon> NemesisD, it's pretty much the same as transitions :: s -> s -> m a (where a comes from somewhere)
14:33:10 <NemesisD> this might force my hand to make the transition type m ()
14:33:13 <dmwit> acowley: yeah, me neither
14:33:18 <byorgey> Zenol: because if supposing that there are no values of type A leads to a contradiction, that does not help you actually find a value of type A.
14:33:46 <simon> NemesisD, well, it might as well return an (m a) that does nothing.
14:33:47 <NemesisD> simon: the hard part for me is that in the noop case, what do you return for a?
14:34:00 <Cale> A -> ((A -> F) -> F) is easy though, and it's the same thing as the double dual embedding in linear algebra.
14:34:07 <NemesisD> simon: doesn't it have to return a value if a is not ()
14:34:09 <simon> NemesisD, I don't know. it depends on what an action would generally return in this case.
14:34:18 <Zenol> byorgey & dmwit> Ok, thanks, it's clearer now :)
14:34:25 <Cale> There is also a map (((A -> F) -> F) -> F) -> (A -> F)
14:34:40 <simon> NemesisD, it's kind of hypothetical to me. I don't know what the return value of a transition function would be used for.
14:34:50 <NemesisD> its like putting do nothing and do something in the same type :/
14:34:52 <Cale> from which you can get ((((A -> F) -> F) -> F) -> F) -> ((A -> F) -> F)
14:35:10 <Cale> which is the join of a monad, to go with the return before :)
14:36:06 <byorgey> @type \g a -> g (\k -> k a)
14:36:07 <lambdabot> (((t2 -> t1) -> t1) -> t) -> t2 -> t
14:36:23 <Cale> (and that too can be carried out for appropriate multiple-dual spaces in linear algebra, and there is similarly a monad structure there)
14:36:32 <shachaf> @djinn Not (Not (Not (Not a))) -> Not (Not a)
14:36:33 <lambdabot> f a b = void (a (\ c -> void (c b)))
14:36:56 <Zenol> Cale> I lost you after your second map I think.
14:37:10 <Cale> @djinn Not (Not (Not a)) -> Not a
14:37:11 <lambdabot> f a b = void (a (\ c -> c b))
14:37:49 <shachaf> @djinn-add Nop r a = a -> r
14:37:49 <lambdabot> Cannot parse command
14:37:51 <shachaf> @djinn-add type Nop r a = a -> r
14:38:03 <shachaf> @djinn Nop r (Nop r (Nop r a)) -> Nop r a
14:38:03 <lambdabot> f a b = a (\ c -> c b)
14:38:11 <Zenol> djinn ? :o
14:38:32 <Cale> Zenol: As in, if something is already negated, then you can do double negation elimination on it, so even without excluded middle, we only end up with three different things: A, not A, and not (not A)
14:38:44 <Cale> not (not (not A)) being equivalent to not A
14:39:04 <shachaf> not (not A) being not equivalent to A
14:39:08 <shachaf> ...OK, that wasn't helpful.
14:40:37 <dmwit> ?djinn Nop r (Nop r' (Nop r'' a)) -> Nop r''' a
14:40:38 <lambdabot> -- f cannot be realized.
14:41:39 <Cale> Zenol: djinn is a proof search tool for a particular intuitionist logic which expresses its proofs as Haskell programs
14:42:11 <Cale> i.e. you give it a Haskell type which isn't too complicated, and it writes a program of that type for you
14:42:27 <Zenol> Cale> Ok. I'm still trying to undestand Not (Not (Not a)) -> Not a implementation ^^
14:42:49 <c_wraith> Not is a funny type
14:42:51 <zRecursive> a bit intelligent ?
14:42:56 <c_wraith> Don't worry too much about it, just yet. :)
14:43:01 <dmwit> bah
14:43:06 <dmwit> Worry about it now. It's fun.
14:43:26 <merijn> :k Not
14:43:27 <lambdabot> Not in scope: type constructor or class `Not'
14:43:28 <Cale> Okay, well, the type Not a is equal to a -> Void -- where Void is a type with no values.
14:43:52 <dmwit> merijn: Not :: * -> *
14:44:32 <Cale> and the function void :: Void -> a is okay, because there's no parameter you could possibly give it, so it will never have to cough up a value of type a for you
14:44:33 <Zenol> Ok, so it's the same thing of shachaf's nop, altough r should be specialised to a type without constructor.
14:45:32 <Cale> (however, there may be terms with type Void, even if there are no values, in a setting which involves negated premises)
14:45:41 <Cale> Right
14:45:43 <Zenol> hum.. but what's void implementation? void = error "impossible" ? x)
14:46:02 <merijn> "void = unsafeCoerce" :D
14:46:02 <Cale> void x = case x of {}
14:46:28 <Cale> That pattern match is complete because x's type has no constructors
14:46:49 <Zenol> merijin> The last time I saw unsafeCoerce is when I compiled GHC and sow a commont on how it's implemented is ... well, strange :p
14:47:17 <Zenol> Cale> Ohw, fun \ o /
14:47:31 <Cale> actually, that's not valid haskell :P
14:47:42 <bitonic> Cale: was going to say that :P
14:47:43 <c_wraith> Even with EmptyDataDecls?
14:47:47 <bitonic> yeah
14:47:50 <c_wraith> too bad.
14:47:55 <c_wraith> It'd be awesome if it was.
14:48:03 <merijn> Haskell2010 has EmptyDataDecls by default, no?
14:48:07 <Cale> It should be!
14:48:10 <bitonic> an explicit empty pattern would be cool too
14:48:19 <bitonic> e.g. body-less patterns
14:48:23 <Cale> Though, really, that's more likely a bug than a legitimate use
14:48:30 <merijn> I use empty data all the time and GHC never yells at me, so I just assumed it was in the standard
14:48:31 <Cale> Not many people use Haskell to prove theorems.
14:48:35 <bitonic> case x of ()
14:48:35 <elliott> Cale: it is with recent GHC
14:48:36 <elliott> and an -X
14:48:47 <elliott> but it's implemented as error "x" rather than forcing the argument first, I think.
14:48:50 <elliott> which is gross
14:49:17 <bitonic> elliott: what X is it?
14:49:30 <elliott> no idea.
14:49:38 <elliott> EmptyCase or something probably
14:49:40 <Zenol> Hum, but you can "prove" everything using error O.o
14:49:40 <Cale> Well, you shouldn't be able to tell the difference for a Void type anyway, and if it were a type that had a constructor, you could similarly avoid forcing by using an irrefutable pattern (like a single variable)
14:49:41 <bitonic> is it a released GHC?
14:50:09 <Cale> Zenol: yeah, this is why nobody takes Haskell seriously as a theorem prover
14:50:11 <elliott> Cale: you can tell the difference
14:50:18 <elliott> void (error "some descriptive error")
14:50:29 <elliott> if you have a _|_ Void value then it's nice to get the error from it.
14:50:31 <elliott> rather than some generic error.
14:50:42 <Cale> elliott: good point :P
14:51:33 <Cale> Zenol: Similarly, we could also define it recursively:  void x = void x
14:51:57 <bitonic> Cale: that doesn’t rely on the fact that “x :: Void” though.
14:52:16 <bitonic> which seems like a waste
14:52:23 <Cale> bitonic: Indeed, it doesn't, but the fact that it terminates for any value of x does ;)
14:52:52 <bitonic> Cale: does “value” mean “non-bottom”?
14:52:54 <Cale> yeah
14:52:59 <Cale> In this case
14:54:52 <bitonic> OK, but I guess we agree that both operationally and in terms of “niceness” of the function something forcing the argument is the best thing.  which one would guess would be the effect of an empty pattern
14:56:27 <Zenol> Cale> ((a->F)->F)->F) = a -> F -> F -> F ... I can't figure out the type of a and b in f a b :s
14:56:49 <Cale> Zenol: no, that's untrue
14:57:04 <Cale> a -> F -> F -> F would be a -> (F -> (F -> F))
14:57:50 <Zenol> arg, yes.
14:58:24 <Cale> Let me rewrite this with different names...
14:58:51 <Cale> f p a = void (p (\q -> q a))
14:59:59 <Cale> p :: Not (Not (Not a)) = Not (Not a) -> Void
15:00:21 <Cale> a :: a
15:01:12 <Cale> (\q -> q a) :: (a -> Void) -> Void = Not (Not a)
15:01:22 <Zenol> Ah! -> Not a! So f :: Not ( Not(Not a)) -> a -> Void
15:01:36 <Cale> right
15:02:01 <Cale> Which is the same as Not (Not (Not a)) -> Not a
15:02:21 <Cale> Maybe I should mention how lambdas are the same thing as proofs by natural deduction...
15:03:07 <Cale> In logic, when we want to prove that A -> B, we start by assuming that we had some proof of A, and try to construct from that a proof of B
15:03:48 <Cale> In lambda calculus, when we want to define a function A -> B, we start by assuming that we have some value x :: A, and try to construct from that a value y :: B
15:03:57 <Cale> and then the function is given by (\x -> y)
15:04:26 <Cale> In logic, if we have a proof that A -> B, and a proof that A, then we can stick those together (by modus ponens) to get a proof of B.
15:04:56 <Cale> In lambda calculus, if we have a function of type A -> B, and a value of type A, then we can stick those together (by function application) to get a value of type B.
15:06:10 <Cale> So functional programmers are just applied logicians who spend most of their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
15:07:03 <Zenol> hehe
15:07:19 <nicoo> Cale: You aren't saying anything new (though Void isn't false (which is an empty type))
15:07:22 <Cale> btw, the type (a,b) corresponds to "a and b" in logic, and the type Either a b corresponds to "a or b"
15:07:44 <Cale> nicoo: Well, only because Haskell is inconsistent.
15:08:03 <nicoo> Cale: No. It isn't false because it is inhabited
15:08:05 <Cale> Void *wouldn't* have a value, it's just that Haskell has general recursion, so every type has a value.
15:08:19 <nicoo> Void *has* a value, ()
15:08:23 <Cale> Or, to put it better, Void has no non-bottom values.
15:08:23 <dmwit> no
15:08:25 <jfischoff_> no
15:08:48 <dmwit> () does not have type Void.
15:08:50 <dmwit> It has type ().
15:09:19 <josephle> Unit, the empty tuple. Void, the empty sum (or at least it *should* be).
15:09:21 <nicoo> Sorry, got confused with OCaml :(
15:09:37 <monochrom> ocaml calls () unit
15:09:48 <nicoo> monochrom: Yup.
15:09:58 <shachaf> C calls () Void, kind of.
15:10:05 <shachaf> Except it's not first-class.
15:10:21 <Zenol> Cale> Why are you saying that haskell is inconsistent ? (If we forgive about error and unsafe functions like that)
15:10:36 <Cale> Zenol: we can write  fix f = f (fix f)
15:10:37 <shachaf> s/V/v/
15:10:40 <Cale> fix :: (a -> a) -> a
15:10:40 <shachaf> It would be useful if it was first-class, at least in C++ (which also calls () void).
15:10:46 <Cale> and then fix id :: a
15:10:50 <monochrom> actually, I disagree about C's void. C's void is so abstract that nobody knows what it is.
15:10:56 <Cale> So we have a "proof of anything"
15:11:49 <josephle> monochrom: are we talking about void or (void *)?
15:11:53 <Zenol> Cale> But it won't terminate :o
15:12:02 <monochrom> I am talking about void.
15:12:24 <monochrom> even (void *) is less abstract than void.
15:12:33 <josephle> ...that's scary.
15:12:35 <Cale> Zenol: That is correct. There are languages where you can't write fix (but can still do quite a lot of recursion, just not all recursion), and where all the programs terminate.
15:12:43 <Cale> Zenol: and their logics are consistent too :)
15:13:17 <monochrom> perhaps it's instructive to first say what I mean by more abstract.
15:13:18 <Zenol> Cale> ohw... and it's the case of coq I suppose.
15:13:25 <nicoo> Cale: Yes, if you restrict to well-funded recursion (like Coq)
15:13:25 <Cale> Zenol: right
15:13:29 <roconnor> Zenol: hopefully :D
15:13:43 <Zenol> Cale> which other ones?
15:13:47 <Cale> Agda
15:14:05 <roconnor> epigram
15:14:43 <monochrom> if I define a data type and tell you all about its implementation (concrete data type), you can operate on it in almost any way you want, i.e., you have many, many operations over it.
15:14:49 * roconnor is suspicious of the impredicativity of Prop in Coq.
15:15:29 <monochrom> if I don't tell you about its implementation, but I give you 5 operations on it, then it's more abstract, you only have 5 operations, not many, many operations.
15:15:45 <monochrom> so roughly, fewer operations = more abstract
15:16:38 * hackagebot risc386 0.0.20130719 - Reduced instruction set i386 simulator  http://hackage.haskell.org/package/risc386-0.0.20130719 (AndreasAbel)
15:16:50 <Zenol> monocrhom> hum, there isn't any "operation" on C/C++'s void type (except decltype or prototyping ...)...
15:17:01 <Zenol> (but thats not really an operation)
15:17:21 <monochrom> now consider Coq's unit type and void type. unit has 1 operation: T->() (type T is up to you; I guess that's still many, many operations). void has 1 operation: void->T (type T is up to you).
15:17:22 <Cale> monochrom: That sort of gets to a funny thought I had about how the geometric story for Homotopy Type Theory changes if you arbitrarily toss in a module system and newtypes :)
15:17:38 <monochrom> so yeah, C's void has 0 operations, that's even worse than Coq's unit and void.
15:17:53 <shachaf> monochrom: What about "return;"?!
15:18:33 <monochrom> what is the type of "return;"?
15:18:51 <shachaf> It has no type.
15:19:16 <shachaf> Calling "void" a type in the first place is rather suspect.
15:19:26 <monochrom> then perhaps it is not an operation of void. I expect an operation to have a type.
15:20:06 <shachaf> What is an operation?
15:20:48 <SLi> return; is a statement, statements have no type.
15:20:59 <SLi> Expressions have types.
15:21:08 <monochrom> an operation has a type. an operation is the "x" in a type signature "x :: t". :)
15:21:27 <shachaf> OK.
15:21:38 <shachaf> I think "x :: t" is a syntax error in C, so C has no operations.
15:21:56 <Zenol> xd
15:21:59 <monochrom> I suppose I should except "return :: void"
15:22:28 <monochrom> with that, C's void is roughly Coq's, ML's, haskell's unit
15:23:02 <FreeFull> But then you get the whole  void*  business
15:23:03 <shachaf> You can't say "void x;".
15:23:03 <hpc> except it's a compile error to attempt making a variable of type void
15:23:09 <monochrom> well, at least it cannot be Coq's void. Coq's void don't have an operation similar to C's return.
15:23:20 <hpc> void is outside the type heirarchy
15:23:21 <FreeFull> shachaf: I think you might be able to
15:23:26 <FreeFull> Lemme check
15:23:26 <shachaf> As a GNU extenion you can say: void f() {} void g() { return f(); }, but no in standard C.
15:23:39 <shachaf> t
15:23:41 <hpc> or rather, it's a type that does not even contain bottom
15:24:10 <monochrom> anyway, if you agree with my philosophy --- more operations = less abstract = you know more --- then I'm happy.
15:24:20 <SLi> I still don't think C statements have types. Ever.
15:24:21 <FreeFull> Ok, you can't do void x;
15:24:26 <tac> hpc: Did you find a bottom in Coq?
15:24:36 <FreeFull> SLi: They can have values
15:24:48 <FreeFull> For example   x = y; has the same value as y
15:25:20 <shachaf> x = y is an expression.
15:25:29 <shachaf> Not that any of this is on-topic.
15:25:36 <SLi> FreeFull: I'm not sure about that. The expression x=y has the same value, but x=y; is a statement and has no value.
15:25:37 <monochrom> yikes, typo. "I suppose I should except return::void" --> s/except/accept/
15:25:49 <FreeFull> What about   x=y=z; ?
15:26:11 <FreeFull> Just adding the ; makes it from an expression into a statement?
15:26:18 <SLi> Yes.
15:26:23 <Zenol> and, existancial types? how does they works? x)
15:28:38 <Cale> Existential types work by letting the constructors of a datatype be polymorphic in some type variable which doesn't occur in the type of their result.
15:29:03 <Cale> For example, in GADT syntax, you can write:
15:29:08 <Cale> data Foo where
15:29:31 <Cale>   MkFoo :: [a] -> (a -> IO ()) -> (a -> String) -> Foo
15:30:48 <Cale> If you get a value of type Foo, you can pattern match on the MkFoo constructor, but your code then doesn't know anything about what type a is, and so there aren't many operations you can perform on the values of type a in the list. Essentially, you can only apply the functions a -> IO () and a -> String that you were given along with the list.
15:31:20 <Cale> So, in this case, the type might as well be [(IO (), String)]
15:31:48 <monochrom> universal type (e.g., "f :: t->t"): author of f does not choose t, user of f chooses
15:32:19 <shachaf> data Noo f where MkNoo :: a -> (a -> f a) -> Noo f
15:32:31 <Cale> Right, and when you apply MkFoo to construct a value of type Foo, you get to choose which type a is.
15:32:33 <monochrom> existential type (e.g., "e :: exists t. (t, t->Int)"), author of e chooses t, user of e does not chooe t
15:32:57 <monochrom> now, that's really only half the story. the other half is provided by parametric polymorphism:
15:33:20 <Cale> i.e. there exists some type a which is the type of the values in the list, and the type which the functions accept, but your clients won't know which type that is.
15:33:23 <monochrom> parametric polymorphism: you never know what your adversary chooses
15:33:45 <monochrom> e.g., if the author chooses t, the user doesn't know what is t
15:34:21 <FreeFull> So it's a way of hiding the t from the user?
15:34:29 <monochrom> polymorphism is the dialectic class struggle between author and user
15:35:02 <monochrom> a logic or proof course is the dialectic class struggle between teacher and student :)
15:35:06 <tac> FreeFull: yep. Existential types embody the notion of "information hiding" or "abstracting away implementation details"
15:35:09 <haasn> monochrom: except in lens
15:35:24 <haasn> where it's the magic glue that holds everything together
15:35:30 <tac> FreeFull: in ML dialects, module systems are heavily based on existential types
15:35:31 <c_wraith> in lens, it's the dialectic class struggle between author and compiler
15:35:50 <monochrom> hehehe
15:36:01 <haasn> except the author cheats and uses unsafeCoerce
15:36:18 <FreeFull> So the only thing you can do that's useful with e is    (snd e) (fst e)
15:36:40 <c_wraith> FreeFull: conceptually, yes.
15:37:00 <shachaf> case e of (f,x) -> x f
15:37:08 <c_wraith> FreeFull: though there are some operational issues with not using a case statement
15:37:20 <c_wraith> which is why shachaf wrote it that way
15:37:37 <shachaf> c_wraith: There are also issues with Haskell not having "exists" in the first place.
15:37:49 <c_wraith> shachaf: which is why I didn't say it was flat-out wrong. :)
15:37:52 <FreeFull> shachaf: I wonder why you called the value f and the function x =P
15:37:57 <tac> FreeFull: A toy example would be ListOfStuff = forall a. ListOfStuff [a]. You can write a function ListOfStuff -> Int to ask its length, but you can never ask what's inside of it, because you don't know the type, and you don't know what you would do with whats inside if you ever got ahold of it.
15:38:19 <shachaf> Those are operational in the sense that "operational" means something like "how it works", and it doesn't.
15:41:00 <FreeFull> tac: Doesn't that make the list useless other than its structure?
15:41:19 <shachaf> It does.
15:41:28 <tac> FreeFull: In that case, yes :) But you might notice that SomeList is "essentially the same" as the type [()] (list of units)
15:41:32 <shachaf> (exists a. [a]) ~ [()]
15:41:40 <tac> Or more plainly, the natural numbers 0, 1, 2, 3, ...
15:41:42 <shachaf> By ~ I mean isomorphism, not equality.
15:42:04 <tac> FreeFull: In general, information hiding is not stressed nearly as much in FP :)
15:42:21 <FreeFull> Usually FP is about the information =P
15:42:24 <shachaf> "as much" as what?
15:42:33 <shachaf> It's stressed. It's what parametricity is all about, for instance.
15:42:44 <FreeFull> I guess
15:42:55 <FreeFull> It lets you know that there are only two possible things id could do
15:43:32 <tac> It's kind of neat that information hiding (existential types) are adjoint to polymorphism (universal types)
15:43:33 <FreeFull> Or rather return, I guess
15:43:34 <shachaf> Choose: id can only be one thing; id can only be three things.
15:43:38 <tac> and they are both two ways to look at the same thing
15:43:42 <monochrom> I think it is not stressed because we automatically do it
15:43:54 <FreeFull> shachaf: What would the third thing be?
15:44:03 <shachaf> That depends on what the first two are.
15:44:06 <shachaf> tac: Adjoint how?
15:44:20 <FreeFull> 1) Return its parameter unchanged   2) Return bottom
15:44:41 <shachaf> id = undefined and id _ = undefined are both valid.
15:44:55 <FreeFull> shachaf: I guess you could tell the two apart with seq
15:44:57 <ptc> Anyone know why hoogling for System.Event gives of 404? (link: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Event.html#t:Event)
15:45:00 <FreeFull> Well, "tell apart"
15:45:04 <FreeFull> So you're right
15:45:12 <tac> Oops, they are not directly adjoint to each other
15:45:21 <tac> but they are close :)
15:45:23 <tac> http://en.wikipedia.org/wiki/Universal_quantification#As_adjoint
15:45:52 <josephle> how many adjunctions does it take to reach the _|_ of a cartesian closed category?
15:47:10 <shachaf> tac: OK, thank you.
15:47:46 <shachaf> Why are they not directly adjoint?
15:47:52 <shachaf> I should read that article, I suppose.
15:48:10 <shachaf> It sounds like dependent sums/products would be related in a similar way to regular products/exponents.
15:49:29 <Zenol> to come back on what dmwit was reading, so there is an implementation of ((A -> m F)->m F)-> A ?!
15:50:22 <tac> shachaf: Do you know about how polymorphism and existentials generalize products and coproducts?
15:50:49 <shachaf> Yes. That's why I just mentioned dependent sums and products.
15:50:52 <tac> shachaf: One way to say it is that products and coproducts aren't directly adjoint either. They are on opposite sides of the diagonal functo.
15:50:59 <shachaf> (Unless you mean something else?)
15:51:00 <tac> functor*
15:51:08 <tac> nope. That's it.
15:51:28 <shachaf> Wait, products and coproducts?
15:51:36 <tac> (,) and Either
15:51:37 <shachaf> You mean repeated products/coproducts?
15:51:42 <tac> yeah
15:51:44 <shachaf> OK.
15:51:47 <tac> They generalize those things
15:52:02 <tac> So their generalizations act similarly to the boring versions
15:54:16 <shachaf> Which diagonal functor?
15:57:21 <Cale> shachaf: The functor C -> C x C which sends each object X to the object (X,X) and each arrow f: X -> Y to the pair of arrows (f,f): (X,X) -> (Y,Y)
15:58:03 <dmwit> Zenol: close, yes
15:58:05 <shachaf> OK.
15:58:18 <dmwit> Zenol: It's actually an implementation of ((forall m. Monad m => A -> m F) -> m F) -> A.
15:58:41 <dmwit> I wouldn't be surprised if there were some class "smaller" than Monad which would be enough.
15:58:49 <dmwit> Like, one with just return or something. =)
15:58:55 <Cale> shachaf: Steve Awodey gives a *really* good series of lectures here: http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html in which he provides quite a clear explanation of how that works.
15:59:05 <Zenol> dmwit> But, we can't get back the A -> mF -> m F -> A with the isomorphisme?
15:59:21 <dmwit> The parentheses matter so much.
15:59:36 <Zenol> sorry, with the right parenthesis.
15:59:40 <dmwit> Anyway, the reason the isomorphism doesn't help is because it's external to Haskell.
15:59:41 <shachaf> Cale: Thanks, will look.
15:59:43 <Zenol> Since it's for all monade, we can take a monade than does nothing except containing the value?
16:00:02 <dmwit> gotta run, but others should be able to help
16:00:20 <Zenol> ok, bye :)
16:01:57 <Cale> shachaf: Of course, we could just look at it directly. Suppose G is the diagonal functor as I gave above. If we want a left adjoint F to it, that means we need a (natural) bijection between maps (A,B) -> GX, and F(A,B) -> X
16:02:20 <Cale> (A,B) -> GX is the same thing as (A,B) -> (X,X) which is the same thing as a pair of arrows A -> X and B -> X
16:02:38 <Cale> So this is saying that whenever we have arrows A -> X and B -> X, we have an arrow F(A,B) -> X
16:02:47 <Cale> (and vice versa)
16:02:58 <kizzo2> Couldn't match expected type `Apples-0.0.1:Apples.Python.Types.StartFrom'
16:03:06 <kizzo2> with actual type `StartFrom'
16:03:09 <Zenol> pure_rev :: (a :-> b) -> (a -> b) makes me think that any forall m. a -> m b can be converted to a a -> b, so that you can compute a (((A->F)->F)->F) -> A from (((A->mF)->mF->mF)->A
16:03:14 <Cale> So, that's got to be the sum!
16:04:11 <kizzo2> ghc-pkg list Apples
16:04:14 <Cale> shachaf: Or, we could take the diagonal functor as our F and ask for a right adjoint G to it. That would mean there would be a natural bijection between FX -> (A,B) and X -> G(A,B)
16:04:17 <kizzo2> /usr/lib/ghc-7.6.3/package.conf.d
16:04:19 <kizzo2> /home/kizzo/.ghc/i386-linux-7.6.3/package.conf.d
16:05:28 <Cale> FX -> (A,B) is (X,X) -> (A,B) which is the same thing as a pair of arrows X -> A and X -> B, and we'd need a bijection between those pairs of arrows and arrows X -> G(A,B)
16:05:38 <Cale> and that's exactly the product
16:05:40 <kizzo2> I'm following this page, but I can't successfully follow the steps: http://stackoverflow.com/questions/12576817/couldnt-match-expected-type-with-actual-type-error-when-using-codec-bmp
16:07:14 <Cale> i.e. assuming that binary sums always exist, the functor C x C -> C which sends each pair of objects to its sum is left adjoint to the diagonal functor, and assuming that binary products always exist, then the functor which sends each pair of objects to its product is right adjoint to the diagonal functor.
16:07:52 <kizzo2> Nobody has a clue? (just saying)
16:08:12 <Cale> kizzo2: Maybe you have two ByteString packages installed.
16:08:21 <Cale> kizzo2: do  ghc-pkg list bytestring
16:08:54 <Cale> also try  ghc-pkg check  to see if there are any broken packages
16:09:18 <Cale> (regardless of that, you might have things built against inconsistent versions of ByteString)
16:09:22 <kizzo2> Cale: I am dealing with the Apples package, which I'm making myself, and the problem is that when I list the packages, it doesn't show them as being there.
16:09:26 <kizzo2> Ok I'll try that..
16:10:49 <Cale> You might want to paste the output on lpaste.net
16:10:56 <Cale> so that we can look too :)
16:12:02 <kizzo2> Alrighty..
16:16:04 <shachaf> Cale: Sorry, was away.
16:16:07 * shachaf looks.
16:19:49 <kizzo2> http://lpaste.net/91038
16:20:17 <Cale> kizzo2: I'm more interested in ghc-pkg list bytestring
16:20:34 <Cale> of course Apples won't be installed if its build failed :P
16:20:56 <kizzo2> /usr/lib/ghc-7.6.3/package.conf.d bytestring-0.10.0.2
16:21:00 <kizzo2> /home/kizzo/.ghc/i386-linux-7.6.3/package.conf.d
16:21:31 <Cale> apparently you have something built against bytestring-0.9.2.1?
16:21:40 <kizzo2> Yeah but my problem isn't with bytestring at all (that's not my stackoverflow article), but with this "inplace" library I'm trying to build called "Apples".
16:21:54 <Cale> oh, I see
16:22:02 <kizzo2> Right, cool beans.
16:22:58 <Cale> all right, so yeah, this says that there are two types named StartFrom defined in different packages and they are not the same type
16:24:02 <Cale> One of them is defined in Apples.Python.Types.StartFrom, and the other is defined somewhere else (perhaps the current module?)
16:24:14 <kizzo2> Hmm..
16:24:21 <skjermlaus> quick question, to transform Maybe a -> Maybe [a] what is the name of the technique/typeclass? applicative? i cant remember
16:24:38 <Cale> skjermlaus: fmap (:[]) would do it
16:24:38 <yesthisisuser> hi guys. i have started reading Barr Wells Category Theory book.. got stuck already when they talk about hom functions..
16:24:55 <skjermlaus> Thanks Cale, so a functor? :D
16:25:07 <Cale> skjermlaus: yeah, you'd be using the fact that Maybe is a functor there
16:25:17 <Cale> yesthisisuser: ask away
16:25:22 <monochrom> Cale: perhaps you would like to ask for the complete output of "ghc-pkg list -v" and also "ghc -v". after all, who knows, perhaps there are even two versions of Apples
16:25:22 <skjermlaus> I see, great.
16:26:02 <yesthisisuser> i just don't understand the intuition behind it
16:26:07 <Cale> monochrom: Well, it doesn't look like there are any installed versions of Apples installed...
16:26:10 <Cale> er
16:26:33 <Cale> yesthisisuser: Okay, so, a category C consists of the following:
16:27:02 <monochrom> hrm, ha, that's strange
16:27:06 <Cale> 1) A collection of objects (these can be anything we like, and just serve as labels to say which arrows we're allowed to compose)
16:27:20 <yesthisisuser> right
16:27:34 <shachaf> Cale: OK, I see how it works.
16:27:45 <shachaf> Thanks, that makes sense.
16:27:55 <Cale> 2) For each two objects X and Y, a collection C(X,Y) of arrows from X to Y (also written Hom_C(X,Y) or Hom(X,Y) when C is obvious)
16:28:55 <yesthisisuser> ok.. well, that is fine.. the only thing is how it is introduced here is confusing
16:28:57 <Cale> (These can also be anything we like, in particular they need not be functions, their presence or absence and the way that composition acts on them is what's important)
16:29:09 <burz> hey guys, I'm a little confused about the usage of the state monad... mind if I ask a question?
16:29:12 <Cale> When f is in C(X,Y) we write f: X -> Y
16:29:16 <Cale> burz: definitely
16:29:21 <shachaf> Cale: Now I just need to figure out the dependent version. :-)
16:29:25 <Cale> I mean, we don't mind! :)
16:29:46 <Cale> shachaf: Awodey also goes over that :)
16:30:11 <Cale> Well, kind of.
16:30:27 <yesthisisuser> Cale: in the book they go on saying that Hom(S, f)(g) = f . g
16:30:28 <dmwit> kizzo2: Perhaps cabal is using a different ghc than you think. I say this because the ghc-pkg output you showed for Apples does not list your package at all.
16:30:58 <dmwit> not really sure why Cale kept getting hung up on ByteString, since nothing you said appears to be about ByteString at all
16:31:03 <Cale> He explains how the existential and universal quantifiers are left and right adjoints to the functor which considers a formula with n free variables as a formula with n+1 free variables.
16:31:18 <Cale> dmwit: He linked to a post where the issue was with ByteString
16:31:34 <Cale> dmwit: which wasn't actually his problem, but a similar problem posted on StackOverflow
16:31:46 <dmwit> I see.
16:32:17 <Cale> yesthisisuser: Okay, so that usage is the Hom functor!
16:33:16 <Cale> yesthisisuser: It's a bit of an extension of the notation. If we have some category C, and we fix some object A in C, then for each object B in C, we have a set Hom(A,B)
16:33:59 <Cale> and for each arrow f: B -> B', we obtain a function from the set Hom(A,B) to the set Hom(A,B') by composition
16:34:39 <burz> ok cool, so suppose I hava an array which I want to use as a state. I've declared it as: type ArrayStateMonad a = State (Array a). I have a function that returns the spot at (x, y), getPosition' :: Array a -> Int -> Int -> a. I'm not sure how I would go about creating a getPosition function that could be used monadically. I've tried to define a function like getPosition x y = state (\g -> let p = getPosition' g x y in (p, g)), to no avail.
16:34:41 <Cale> So, we have a map on objects: send each object B in the category C to the object Hom(A,B) in the category Set
16:35:37 <Cale> and we have a map on arrows: send each arrow f: B -> B' in the category C to the arrow Hom(A,f): Hom(A,B) -> Hom(A,B') given by definition to be Hom(A,f)(g) = f . g
16:35:47 <Cale> in the category Set
16:36:11 <Cale> an arrow in the category Set is just a function, so we're defining the function by saying what it does to an element g of the set Hom(A,B)
16:36:20 <monochrom> @unmtl State
16:36:21 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
16:36:26 <yesthisisuser> Cale: I think I'll have to read that a couple of times .. but thanks. your explanation is better than the book
16:36:30 <monochrom> @unmtl State Int Bool
16:36:30 <lambdabot> Int -> (Bool, Int)
16:36:41 <Cale> yesthisisuser: Let me send you a book you might enjoy better :)
16:37:28 <zRecursive> it seems "Int -> (Bool, Int)" much clear than "State Int Bool" ? why do we need mtl ?
16:37:50 <monochrom> burz: that should work, if it doesn't, error is elsewhere, show unabridged actual code
16:38:07 <yesthisisuser> Cale: Thanks! great stuff
16:39:02 <kizzo2> http://pastebin.com/Zmuvd7XS
16:39:05 <c_wraith> zRecursive: it's clearer as a type, yes.  If you have a bunch of functions of related types (all passing an Int around, but the other returned argument changing), it's much easier to hook them together with the State interface
16:39:09 <mauke> The paste Zmuvd7XS has been copied to http://lpaste.net/91039
16:39:17 <Cale> zRecursive: Because the State monad gives us operations for chaining together functions like that.
16:40:01 <tabemann> I've been following Conal Elliott's blog, and on it I have seen the opinion (or what seems to be it) that Haskell really isn't pure because it doesn't have referential transparency in that all values not directly tied to outside IO cannot necessarily be determined at compile time (e.g. mathematical properties)?
16:40:06 <Cale> zRecursive: and by defining it as a Monad (which we couldn't formally do without the newtype), we automatically get all the operations in Control.Monad and elsewhere for free.
16:40:13 <tabemann> s/?/What do you think of this?
16:40:18 <Cale> i.e. things which have been written to work in any monad.
16:41:04 <zRecursive> Cale: thx, it is better to show some example
16:41:25 <c_wraith> tabemann: Conal has some good points, in that he's searching for a better abstraction.  There are definitely problems with the way IO works.  But IO as a type still has value, and is one of the best approaches we know of.
16:41:30 <Cale> tabemann: I'm pretty sure that Conal is *half* serious about those things. He wants people to think about new ways to structure programs.
16:42:30 <Cale> He's right in that our semantics for dealing with expression evaluation doesn't on its own suffice to explain the behaviour of IO actions in a way which lets us reason about them algebraically.
16:42:39 <Cale> (at least, beyond, say, the monad laws)
16:43:15 <tabemann> when I read him talking about how IO basically makes Haskell a language that can be programmed in as a imperative ones, I wonder what is there to replace it? both stream IO and continuation IO have been tried, and they had problems which is why monadic IO is now used
16:43:19 <monochrom> part of it is extremist because "maxBound :: Int isn't referentially transparent, it varies across platforms" is stretching it
16:43:20 <Cale> Of course, because the IO monad lets you do so much, almost no laws really hold, since you might just overwrite your program's memory halfway through.
16:43:47 <shachaf> conal doesn't mind the "monadic" part of "monadic IO".
16:43:47 <tabemann> monochrom: the insistence that referential transparency must be a compile-time property and not a run-time property comes off to me as a tad extremist myself
16:43:52 <dwcook> @type unsafePerformIO getLine
16:43:53 <lambdabot> Not in scope: `unsafePerformIO'
16:43:53 <shachaf> Monads are great. I'm sure conal is a fan.
16:43:57 <shachaf> It's the "IO" part.
16:44:30 <shachaf> And that can be done in dozens of ways and I assume he doesn't really like any of them.
16:44:33 <c_wraith> Yeah, he's looking for a better way to organize your program's interaction with the outside world.  That's his *big* goal.
16:44:44 <shachaf> Actually, conal mentioned that he preferred stream I/O to monadic I/O.
16:44:56 <shachaf> Because it was so awkward that people did their best to minimize their use of it.
16:45:20 <tabemann> I got the impression that he wished that one didn't have to deal with IO in the first place
16:45:37 <c_wraith> tabemann: he doesn't want to have to deal with unstructured access to the outside world.
16:45:49 <Cale> tabemann: Well, he wishes one didn't have to deal with IO, but that same wish doesn't hold of I/O.
16:45:52 <c_wraith> tabemann: he wants an interface with simple laws and strong reasoning
16:46:23 <b2coutts> is there a way to make haskell derive a Show instance for only some clauses of a datatype?
16:46:26 <Cale> tabemann: He wants some better declarative way of expressing how inputs correspond to outputs which has nice algebraic laws and semantics.
16:46:37 <monochrom> no
16:46:47 <tabemann> c_wraith: that appears to go down to things like that Int, Float, and Double are all impure in that their semantics are not formally specified or compile-time predictable
16:47:03 <b2coutts> i.e., my datatype has one "part" of its definition that contains a function, so Show can't be derived from it, and I want to define the Show instance for this one specific clause, and have the rest of them derived
16:47:17 <c_wraith> No, those are minor things.  The big thing is that "IO ()" doesn't tell you *anything* about what the action does.
16:47:43 <monochrom> then I'm afraid you have to write a lot of code by hand
16:48:05 <shachaf> conal would also prefer that Int had some standard meaning.
16:48:10 <shachaf> Which it doesn't, in the Report.
16:48:23 <c_wraith> b2coutts: you could put the function inside a newtype, and give that newtype a show instance.  It'd let you auto-derive it, at least.
16:48:24 <tabemann> c_wraith: is there any way to specify IO that truly does?
16:48:38 <c_wraith> tabemann: that's the open question he's looking for the answer to
16:48:44 <Cale> tabemann: There are ways to do a lot better
16:49:00 * b2coutts begrudgingly writes a bunch of code by hand
16:49:10 <Cale> Even without putting so much detail into the type system, there are building blocks which satisfy nicer laws.
16:50:02 * tabemann wonders if there is a way to separate concurrency from IO, so they are not lumped together, besides just the use of par?
16:50:26 <tabemann> same thing with exception handling
16:51:03 <Cale> tabemann: Consider something like a game -- most of what a game does consists of various bits of state causing various other bits of state to change in response over time and over user input. Most bugs in games have to do with failing to update that state in a consistent or correct way.
16:51:11 <yesthisisuser> it feels like something needs to change already at the hardware layer
16:51:49 <tabemann> the problem is that ultimately we still have to go through standard libraries at some level (which mediate access to kernel calls), and they force an abstraction on us
16:52:09 <hpc> tabemann: perhaps something like an out-of-order state monad?
16:52:17 <Cale> tabemann: Ideally, there would be some way to express the dependencies between the things which are changing over time declaratively, and in such a way that state updates are still efficiently performed, and you don't waste lots of time computing things which are out of date or unneeded for other reasons.
16:52:36 <Cale> tabemann: and that's what FRP systems give you
16:53:04 <tabemann> we can do that with internal state, e.g. the ST and STM monads, but everything beyond the standard library is just one big blob of state that we cannot subdivide
16:54:25 <tabemann> we ultimate seem to be forced into accessing the outside world with one big abstraction that lumps it together, be it monadic IO, stream IO, or continuation IO
16:54:26 <Cale> tabemann: There are two fundamental concepts which FRP libraries try to provide in various ways: behaviours, which are things that whenever you look at them, will always have some value. These are things like the current position of the mouse, or the current time, or the current thing being drawn on the screen, or the current hitpoints that a monster has
16:55:46 <Cale> And secondly, events, which are things that occur at discrete points in time, and have values at those times. Things like the sequence of keystrokes or mouse clicks, or the sequence of attacks made by a monster, or the sequence of sounds played, or sequences of incoming or outgoing network messages.
16:56:19 <tabemann> yes, you can decompose *input* into events and persistent but varying states
16:56:27 <Cale> FRP systems will give you some ways of manipulating and combining behaviours and events to form new behaviours and events.
16:57:13 <Cale> and you'll do this in some way that essentially defines how your input events and behaviours correspond to various output events and behaviours, and then the library will take care of keeping everything up to date all the time
16:57:20 <tabemann> the problem is how do we decompose *output*?
16:57:50 <tabemann> (output being anything that modifies the state of the "real world")
16:57:56 <Cale> Well, in restricted domains, it's usually not so hard to come up with a fixed set of behaviours and events which completely determine the scope of what you're doing.
16:58:07 <Cale> But this isn't the whole big messy real world.
16:58:33 <Cale> Maybe with changes at the OS level, a clearly defined interface would suffice.
16:58:56 <Cale> But yeah, it's a bit of an open problem.
16:59:08 <tabemann> the big problem is that things that modify the outside world don't have predictable side effects; changing one thing one place can change just about anything anywhere else
16:59:19 <Cale> In practice though, you can make use of FRP libraries instead of writing at least the majority of your program in IO
16:59:26 <tabemann> so one cannot separate output into separate states
16:59:27 <Cale> and that has benefits
16:59:39 <burz> with a parameterized declaration of the State monad i.e. type GridStateMonad a = State (Grid a), what am I doing wrongly trying to execure evalState (put (newGrid 4) >>= getPosition 1 1) (newGrid 4) if I've defined getPosition as: getPosition :: Int -> Int -> GridStateMonad a (Position a) \n getPosition x y = state (\g -> let p = getPosition' g x y in (p, g))?
16:59:48 <Cale> (just defining some initial behaviours and events in terms of IO actions, as well as what to do with the outputs)
17:00:23 <tabemann> the thing with FRP is how do we put it on a foundation other than monadic IO, stream IO, or continuation IO?
17:00:45 <tabemann> so far it is merely an abstraction over portions of monadic IO
17:01:02 <Cale> Well, maybe we just define a semantics for it, and then try to implement that semantics using IO, and if we fail, then it's a bug.
17:01:14 <tabemann> (I get the impression that Conal isn't looking for merely hiding monadic IO behind a nicer-looking API)
17:01:28 <shachaf> How do we put Haskell code on a foundation other than x86 machine code?
17:01:37 <shachaf> (Answer: ARM machine code.)
17:01:46 <tabemann> (or LLVM)
17:01:53 <monochrom> I could also be a foundation
17:01:54 <zRecursive> llvm
17:01:55 <hpc> (or MIPS machine code)
17:02:02 <hpc> (or reduceron)
17:02:05 <Cale> Well, you can ask him about what his ideals are there, but in practical terms, you can go a long way to eliminating giant swathes of IO code from your programs like that.
17:02:06 <hpc> (or turing tape)
17:02:12 <zRecursive> llvm's IR
17:02:51 <Cale> burz: What is GridStateMonad a?
17:03:04 <Cale> oh
17:03:04 <tabemann> from what he writes, it isn't clear if he has an idea of what could replace what is that would fit his ideals
17:03:08 <Cale> I missed that
17:03:57 <monochrom> Cale: I already asked burz to "show unabridged actual code" and I am ignored.
17:04:05 <Cale> burz: Your problem is that the right parameter to >>= is not a function, but an action of type  State (Grid a) (Position a)
17:04:17 <tabemann> he does seem to have the idea that Haskell or something like it could be reformulated to have formal semantics with regard to pure code
17:04:22 <tabemann> but that doesn't cover IO
17:04:24 <Cale> burz: Perhaps you meant to use >>
17:05:01 <Cale> tabemann: It did at one point have a formal semantics for expression evaluation
17:05:11 <monochrom> well, I guess that nails it
17:05:14 <Cale> But for some reason, that wasn't maintained alongside the Haskell Report.
17:05:42 <Cale> (in fact, both operational and denotational semantics)
17:05:54 <burz> momchrom: here you go: https://github.com/burz/cellaut/blob/master/Grid.hs
17:06:04 <Cale> tee hee momchrom
17:06:08 <hpc> Cale: i would be interested in reading an old copy, just to see how one would go about specifying such things
17:06:12 <tabemann> the hard part there is making mathematical operations have formal semantics also means either restrictive semantics or slow implementation
17:07:17 <tabemann> i.e. integer math would have to be restricted to a single size for Int independent of the word size, and floating-point math would have to be implemented entirely in software
17:07:56 <tabemann> and one would have to do software checks for overflow in integer math
17:08:17 <Cale> hpc: right at the bottom of http://www.haskell.org/haskellwiki/Language_and_library_specification there are some links to a static and dynamic semantics of Haskell
17:09:00 <tabemann> the integer part has been done, though, if one looks at various Lisps and at Python
17:09:31 <tabemann> with the floating-point part, the "fast" solution is to just assume the hardware follows the standard perfectly and blame the hardware when it doesn't
17:09:36 <hpc> i assume dynamic is going to be the one with the IO semantics
17:09:40 <iammisc> hi all; i'm looking for a Chan-like data structure that will let me "close" a channel, meaning that subsequent readChan's will return Nothing (or some other behavior)
17:09:43 <hpc> and that's precisely the link that isn't loading for me :P
17:09:57 <Cale> hpc: This was also before the time when the IO monad existed :P
17:10:15 * tabemann remembers reading discussions about whether Int and Integer should have been unified in Haskell before
17:10:28 <Cale> I think Int should just be moved out of the Prelude
17:10:31 <yesthisisuser> is there any hardware design that supports direct execution of say lambda calculus or combinatory logic?
17:10:36 <elliott> Int :: IO *
17:10:41 <elliott> @@ yesthisisuser: @where reduceron
17:10:41 <lambdabot>  yesthisisuser: http://www.cs.york.ac.uk/fp/reduceron/
17:10:43 <Cale> yesthisisuser: yes.
17:10:48 <burz> cale: yeah, >> works, thanks!
17:11:58 <yesthisisuser> interesting..
17:12:02 <dolio> I don't understand what "unifying Int and Integer" means.
17:12:06 <tabemann> Cale: but that assumes then that we "should" use Integer, but then, just using Integer would probably be even slower than having a unified Int and Integer where word format versus bignum format is determined at runtime
17:12:13 <Cale> dolio: Probably, getting rid of Int
17:12:19 <dolio> Well, that's all it can mean.
17:12:26 <Cale> tabemann: Integer already does that
17:12:33 <tabemann> dolio: representing small numbers as words, representing big numbers as bignums, and automatically converting with automatic oveflow detection
17:12:44 <dolio> That's called Integer.
17:12:47 <Cale> tabemann: Yes, GHC's Integer implementation does that exactly.
17:12:53 <hpc> Cale: that dynamic paper seems to be lost forever
17:12:59 <Cale> If you :info Integer you'll see that it has two constructors
17:13:17 <hpc> or at least until psu.edu's citeseer starts behaving again
17:13:23 <Cale> It has S# which just has an Int# (machine int) parameter
17:13:30 <zRecursive> :i Integer
17:13:51 <Cale> and J# which has an Int# parameter followed by a ByteArray# (which is the GMP integer representation)
17:13:54 <tabemann> okay, good - I had thought that Integer was just a bignum, not a Lisp or Python-style unified word-and-bignum type
17:14:03 <dmwit> elliott: Int :: IO *, cute
17:14:21 <Cale> Well, it doesn't *actually* matter, because you can't tell the difference -- the representation is subject to future changes :)
17:14:22 <shachaf> Cale: Hmm, these Awodey videos are many GBs.
17:14:41 <Cale> shachaf: yeah...
17:14:50 <tabemann> I do care about performance properties myself...
17:14:57 <shachaf> I'll have to download them some other time. And maybe free up some hard drive space!
17:15:10 <shachaf> Each 3-part thing is 80 minutes?
17:15:28 <elliott> dmwit: it's the Right Thing to do! consider heterogeneous distributed computing
17:15:30 <Cale> shachaf: something like that, I didn't keep track. I just streamed them off the page.
17:16:02 <shachaf> That works if you have a good Internet connection everywhere!
17:16:13 <p\mage_> ok, what book is an introduction to algorithms?
17:16:16 <tabemann> well, at least that makes me feel better about using Integer for arbitrary integers
17:17:06 <p\mage_> I have Pearls of Functional Algorithm Design
17:17:15 <Cale> shachaf: Or a good internet connection somewhere, and are willing to stay there!
17:17:22 <p\mage_> all of this: http://www.cs.berkeley.edu/~vazirani/algorithms.html
17:20:55 <Cale> I feel like a lot of presentations of algorithms obscure much of the scaffolding which make the construction of those algorithms obvious. Of course, by Curry Howard, I feel pretty much exactly the same way about many proofs of theorems in mathematics.
17:21:07 <Cale> (or I should say, particular presentations of those proofs :)
17:22:36 <tswett> It seems like about 90% of all theorems in category theory are obvious.
17:23:05 <Cale> The more surprising thing is that 90% of all the definitions are "obvious" too :D
17:23:41 <tswett> This is why I like algebra. In algebra, 70% of all theorems are obvious. In analysis, only 45% of all theorems are obvious.
17:23:41 <ion> Including the one that defines 90 % of all definitions as “obvious”.
17:24:01 <tswett> And 90% of the obvious theorems are algebraic ones.
17:24:29 <Cale> (mostly that, if you give the data, the laws which need to be satisfied come from those data in whatever way would be the first one you'd think of)
17:25:03 <tabemann> very stupid question that came to the top of my head - what happens in multithreaded code if more than one thread attempts to evaluate the same thunk at once?
17:25:16 <hpc> tabemann: that's actually a great question
17:25:38 <hpc> tabemann: as i understand it, the runtime begins evaluating a thunk by redirecting it to another bit of code
17:26:01 <hpc> when a second thread begins evaluating the thunk, it will be redirected and block until the first thread finishes
17:26:07 <tabemann> but how can that be atomic on a multicore system?
17:26:12 <hpc> this happens only in the threaded runtime
17:26:27 <hpc> in the nonthreaded runtime, a thunk gets redirected to error "<<loop>>"
17:26:45 <hpc> tabemann: how can anything be atomic?
17:26:48 <Cale> Yeah, ideally, the pointer gets rewritten to point at a grey hole, which is a piece of code which blocks until the value finishes evaluating, so one of the two threads will block until the other evaluates it. I believe there may be a small gap wherein both of the processors may both evaluate the thunk.
17:27:11 <Cale> At least, there was one at one point, and I've heard various things about it being plugged or unplugged.
17:27:17 <hpc> in theory, the gaps don't matter
17:27:23 <tabemann> hpc: I mean if you have two OS threads on different cores, what stops them from branching into the thunk exactly simultaneously?
17:27:26 <Cale> Statistically, it's very rare
17:27:31 <Cale> (but it does happen)
17:27:34 <hpc> they're a small performance regression unless you do bad things
17:28:19 <shachaf> tabemann: Why do you keep calling your questions stupid?
17:28:36 <tabemann> shachaf: because I feel they must be obvious and that I should know better
17:28:42 <shachaf> I think that question is fine, but if it's actually stupid, then you probably shouldn't ask it.
17:29:18 <shachaf> If you don't know how to answer it, and you don't know how to improve it, then maybe it's not stupid. Or maybe people will tell you how to improve your question, or how to figure out the answer by yourself.
17:29:54 <shachaf> But asking a question that you know in advance to be "stupid" just means I won't want to answer it.
17:30:19 <tabemann> hmm... I could see how simultaneous branching *should* work identically on different cores provided no exceptional conditions and no unsafePerformIO... but if one of the threads runs out of memory or evaluated unsafePerformIO, the same thunk could then literally be evaluated with two different values (or non-values if one is bottom)
17:30:40 <hpc> tabemann: in any event, #haskell is about the safest place ever to ask stupid questions
17:30:55 <hpc> you should see the stuff i sometimes have to ask in here
17:31:11 <shachaf> Please don't ask stupid questions in #haskell. Ask good questions, even if they're about simple things.
17:31:22 <shachaf> (I don't know what a "stupid question" is, really, but it doesn't sound good.)
17:31:32 <tabemann> the "stupid" part is mostly self-deprecation
17:31:51 <c_wraith> @protontorpedo
17:31:51 <lambdabot> how is haskell different than java?
17:31:53 <dolio> You should not use unsafePerformIO in a situation where evaluating the thing twice would produce different results.
17:32:18 <tabemann> yes, but plenty of people use it for horrifically unsafe things IRL
17:32:26 <dolio> No.
17:32:31 <c_wraith> If they do, they get what they deserve
17:32:36 <luzie> > :t 2+2
17:32:37 <lambdabot>   <hint>:1:1: parse error on input `:'
17:32:40 <shachaf> unsafePerformIO has special code to guard against being duplicated.
17:32:47 <shachaf> So FSVO "different".
17:33:19 <ion> shachaf: Should i insert this syringe i found on the street into my nostril?
17:33:30 * tabemann at least thinks that the unsafePerformIO hack is "horrifically unsafe"...
17:35:09 <shachaf> @google mainisusuallyafunction thunks
17:35:10 <lambdabot> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
17:35:11 <lambdabot> Title: main is usually a function: Thunks and lazy blackholes: an introduction to GH...
17:35:24 <Cale> @protontorpedo
17:35:24 <lambdabot> lazy makes macro not needed?
17:35:29 <Cale> @protontorpedo
17:35:29 <lambdabot> is there an oo db in haskell?
17:35:37 <Cale> @keal
17:35:37 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
17:35:42 * tabemann remembers reading about blackholes, but they didn't seem to insure atomicity
17:35:51 <dolio> No, I mean, "plenty" of people do not use it.
17:36:02 <mm_freak> is there any recursion in @djinn?
17:36:10 <dolio> It is used very rarely, usually in low level libraries written by experts.
17:36:12 <tabemann> okay, plenty may have been an exaggeration
17:36:20 <Cale> mm_freak: djinn will never write a recursive definition
17:36:25 <shachaf> mm_freak: You mean, will it generate recursion functions? No.
17:36:32 <shachaf> Well, s/function/definition/, sure.
17:36:51 <mm_freak> no, recursive types to express e.g. natural numbers
17:36:54 <mm_freak> Fix Maybe
17:37:06 <dolio> There is not that, either.
17:37:08 <c_wraith> tabemann: unsafePerformIO uses a function designed to ensure atomicity of evaluation, though..  it gives stronger guarantees then blackholes do
17:37:30 <mm_freak> is djinn even possible for inductive types?
17:37:43 <dolio> No.
17:37:48 <mm_freak> i see
17:37:50 <hpc> in general, no
17:37:57 <dolio> It only has types that correspond to propositional logic.
17:37:57 <hpc> you could probably extend djinn to work sometimes
17:38:26 <dolio> Because it is based on a decision procedure for propositional logic.
17:38:43 <mm_freak> how far can auto-proofing go?
17:38:49 <mm_freak> proofing?  proving…
17:39:09 <tabemann> c_wraith: that's good at least, even though I don't feel like I would rely on that even if I did ever have to use unsafePerformIO (probably when binding a C API)...
17:39:35 <c_wraith> sequent calculus is complete and computable, right?  And that's..  First-order logic?  Man, I should actually learn this stuff.
17:41:06 <tabemann> (somehow it seems that it probably is only a good idea if it *could* be executed twice unexpectedly without ill effect)
17:41:21 <mm_freak> if you introduce induction, will djinn's error message be "i cannot prove this" or "i disproved this"?
17:41:31 <dmwit> tabemann: The point is that even if your thing is pure it might not be reentrant.
17:41:37 <dmwit> like
17:41:39 <dmwit> externally pure
17:41:46 * hackagebot supervisor 0.1.0.0 - Control an internal monad execution for trace generation, backtrakcking, testing and other purposes  http://hackage.haskell.org/package/supervisor-0.1.0.0 (AlbertoCorona)
17:41:48 <c_wraith> Heh.  yes, like the crypt_r bindings I wrote.
17:41:54 <tabemann> dmwit: yeah
17:41:56 <c_wraith> They're externally pure, and certainly not re-entrant
17:42:37 <tabemann> C APIs are horrible for frequently being non-reentrant
17:43:21 <dolio> c_wraith: You can do many logics in sequent calculus style.
17:43:21 <c_wraith> Hmm, no, wait.  The only pure function I exported actually *is* re-entrant - and really slow because of it.
17:43:34 <c_wraith> Crazy c libs
17:43:48 <tabemann> (when I said "executed twice unexpectedly" I was including the case of the code being entered while already being inside of it)
17:44:54 <dolio> However, even if first-order logic is decidable (which I can't recall), the problem is that adding higher-rank types would be second-order.
17:44:57 <c_wraith> Which is actually pretty much the only way to evaluate a value twice unexpectedly, unless it's inlined at compile-time
17:45:03 <dolio> For instance.
17:45:29 <dmwit> tabemann: Then I disagree. I think it makes fine sense to unsafePerformIO something which is pure but not re-entrant.
17:46:48 <dolio> I feel like first-order probably isn't decidable either, though.
17:46:50 <tabemann> even when one takes into the case of not the same unsafePerformIO being evaluated twice but two different unsafePerformIOs in different places into the same general API being evaluated simultaneously on different cores?
17:47:10 <dolio> Unless you put some pretty harsh restrictions on it.
17:47:18 <tabemann> for that I would be highly tempted to surround the call into the C API with a lock
17:47:36 <dmwit> Okay, you convinced me.
17:48:05 <c_wraith> tabemann: Yes, you have to lock that case.  The case you don't need to lock is when you pass a context object into a function call
17:48:48 <c_wraith> tabemann: so long as you ensure serial access to the context object, you can't cause double-execution by double-evaluating the result
17:53:11 <tabemann> hmm... I would probably lock multiple calls with unsafePerformIO into *any* C API unless I was certain the whole thing was reentrant, or simply just avoid unsafePerformIO for those cases even if I know the code is pure
17:53:40 <tabemann> s/certain/absolutely certain
17:54:25 <tabemann> hmm
17:54:46 <tabemann> do "unsafe" C calls ensure atomicity in the whole "let's stop all the cores but one" thing?
17:54:55 <c_wraith> No
17:55:32 <c_wraith> But "unsafe" is the wrong thing to default to.
17:55:42 <c_wraith> use "safe" unless you know exactly why it's the wrong choice.
17:55:54 <tabemann> it seems a lot of code uses "unsafe", but from what I've read it's horrible if you're doing anything concurrent
17:56:06 <shachaf> "unsafe" loses a whole lot of different, somewhat-unrelated guarantees.
17:56:11 <shachaf> It gains some speed.
17:56:16 <shachaf> So what c_wraith said.
17:56:51 <c_wraith> unsafe breaks concurrency when people call long-running functions with it.
17:57:11 <hpc> the first rule of haskell is that "unsafe" means what it says on the tin
17:57:14 <tabemann> hmm... what is exact the trade-off in single-core speed with "unsafe" versus multi-core availability with "safe"...
17:57:16 <c_wraith> those functions don't use the RTS allocator, so they can't stop when the GC wants to do a stop-the-world collection
17:57:42 <c_wraith> So all the other cores stop and wait until the one in the unsafe foreign call finally returns and allocates something
17:57:44 <shachaf> unsafe breaks a bunch of things.
17:57:53 <c_wraith> Which - if that's several seconds, goodbye all concurrency
17:58:09 <shachaf> If I say "unsafe breaks X", you'll probably think "OK, I don't do X, so it's safe to use unsafe", and neglect Y and Z.
17:58:24 <c_wraith> Heh, yes.  That's just how unsafe breaks concurrency.
17:58:29 <c_wraith> It breaks many other things, too.
17:58:40 <tabemann> c_wraith: so if the code is calling malloc it should be "unsafe"?
17:58:48 <shachaf> So I think a partial answer might be worse than no answer.
17:59:00 <shachaf> tabemann: No, is "should" never be "unsafe".
17:59:25 <c_wraith> as far as I know, malloc always succeeds immediately on modern systems.
17:59:26 <dmwit> Just mark everything safe, and buy a new computer next year.
17:59:35 <dmwit> modern *linux* systems
17:59:38 <merijn> c_wraith: Not on BSD's
17:59:39 <dmwit> Not all OSs overcommit.
17:59:48 <merijn> dmwit: Well, almost all do
18:00:03 <merijn> dmwit: But BSD's only overcommit up to 20% by default
18:00:18 <tabemann> malloc on Linux starts killing processes to free up memory when you run out of virtual memory space, at least in the default setup....
18:00:32 <merijn> tabemann: And it always freaking starts with SSH >.<
18:00:33 <c_wraith> tabemann: yes, but the malloc call never fails!
18:00:38 <merijn> tabemann: f the OOM killer
18:01:11 <dmwit> Is it really malloc?
18:01:12 <tabemann> that fact makes me feel uncomfortable with having only 8 GB of RAM and 16 GB of swap
18:01:20 <tabemann> dmwit: obviously the kernel, not malloc
18:01:39 <dmwit> But I mean, is the kernel really doing that while malloc runs? I don't think that's right.
18:01:40 <hpc> ppsh, you weren't using those processes
18:01:45 <dmwit> It's later, when you actually start using the memory.
18:01:53 <hpc> if they were important, they would use root's extra 5% of memory
18:01:55 <tabemann> that sounds right
18:02:02 <dmwit> Which was sort of c_wraith's whole point.
18:02:14 <c_wraith> Anyway.  Just use "safe".
18:02:17 <dmwit> yes
18:02:22 <dmwit> ==c_wraith
18:02:35 <tabemann> c_wraith: which is what makes me wonder when I see code that uses "unsafe" in, say, Data.ByteString
18:02:47 <c_wraith> Well, ByteString is written by experts.
18:03:00 <c_wraith> It does far dirtier stuff than just use unsafe foreign calls.
18:03:20 <c_wraith> Its authors knew exactly what they were doing and why.
18:03:45 <hpc> ByteString is basically high-level microsoft people writing assembly with shadow puppets
18:03:50 <c_wraith> (There's stuff in it that I still really have no understanding of why it works, like inlinePerformIO)
18:04:05 <dmwit> Well. Enough of the blanket rules. If you want to know what's going on with safe and unsafe, there's no place like the paper on concurrent haskell.
18:04:28 <dmwit> http://community.haskell.org/~simonmar/bib/concffi04_abstract.html
18:04:41 <c_wraith> Some of that is out of date, iirc
18:04:51 <dolio> I thought bytestring was written by Australian university students.
18:04:54 <c_wraith> But it's still a good starting point
18:05:01 <c_wraith> dolio: well, one of its authors was
18:05:14 <c_wraith> dolio: but he was surprisingly competent for a university student.
18:05:15 <tabemann> okay, nother paper to read then
18:05:59 <djahandarie> Not only was he a university student, but an Australian university student? Damn. What were they thinking.
18:06:13 <hpc> djahandarie: avoid success at all costs? :P
18:06:29 <monochrom> that paper is probably only outdated in one point: "number of capabilities = 1"
18:07:05 <dmwit> erm
18:07:14 <dmwit> I thought that was the paper that introduced m-to-n threading.
18:07:25 <dmwit> I meant to link the paper that introduced that, so if I didn't I made a mistake.
18:08:45 <monochrom> it still counts as, say, 5-to-3 threading if 1 OS thread runs Haskell code (1 capability) and 2 OS threads run C code
18:10:17 <tabemann> when you say OS threads running C code, does "safe" break out C code into worker threads? (sorry, it might be in the paper, but I've only read part of the first page so far)
18:10:19 <dmwit> I mean, it talks about multiplexing Haskell threads. So that's good enough for me, whether that was implemented at publishing time or not.
18:10:31 <dmwit> tabemann: Yes, safe calls happen on their own OS thread.
18:10:56 <monochrom> you can read my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
18:11:02 <c_wraith> the runtime keeps a pool of OS threads for doing safe FFI calls around.
18:11:32 <c_wraith> That's why it runs more threads than the number of capabilities you've set it for, if you ever checked and were wondering about that.
18:13:42 <tabemann> so far maximum Haskell performance, assuming M cores and N Haskell threads without interdependencies, one should set the number of capabilities to M?
18:13:47 <tabemann> s/far/for
18:14:15 <geekosaur> that also assumes nothing else running on the machine, which is dubious
18:14:57 <tabemann> but will those processes be taking up full cores all the time?
18:15:06 <dmwit> I think there used to be some GC issues that meant M-1 threads was optimal. Dunno the status of that.
18:15:11 <c_wraith> Not if they don't have any green threads to run
18:15:18 <dmwit> err, M-1 capabilities, I mean
18:15:45 <c_wraith> I mean, if they don't have anything runnable, capabilities just block until they get something they can run.
18:15:51 <geekosaur> tabemann, you're *inviting* the possibility. I'd want to allow for the rest of the system to run, but that may be just me
18:17:34 <tabemann> geekosaur: hmm... yeah, it might make sense to set less than M capabilities if those OS threads will max out their CPU usage, i.e. if the OS tries to run any other (processes') threads on the same cores they will force preemption
18:18:58 <c_wraith> yeah, that's where the GC issue dmwit mentioned came in. If you were pre-empted on one core, it would kill all the other cores when a GC happened
18:19:10 <tabemann> okay, gotta go for now
18:19:31 <c_wraith> pitfalls of stop-the-world GC...
18:19:38 <tabemann|away> too bad GHC doesn't use incremental
18:19:51 <dmwit> c_wraith: That is the clearest explanation of the problem I've ever heard.
18:20:15 * tabemann|away will have to remember this
18:26:07 <optimusbrine> @djinn (Maybe a) -> (Maybe b) -> (Maybe a)
18:26:08 <lambdabot> f a b =
18:26:08 <lambdabot>     case a of
18:26:08 <lambdabot>     Nothing -> Nothing
18:26:08 <lambdabot>     Just c -> case b of
18:26:08 <lambdabot>               Nothing -> Nothing
18:26:10 <lambdabot>               Just _ -> Just c
18:26:19 <optimusbrine> why does it look at b at all?
18:26:33 <shachaf> Because it tries to use as many arguments as it can.
18:26:34 <harovali1> hi, supose there is a type declaration like this
18:26:35 <harovali1> ( a -> b) -> f a -> f b
18:26:35 <harovali1> Is 'f' there a sintactic element like '->' or is it a type reference like a or b ?
18:26:41 <optimusbrine> ah
18:26:51 <shachaf> If you want it to do the thing you want, make the type more polymorphic.
18:26:58 <shachaf> Hooray for information hiding!
18:27:04 <shachaf> From now on I'm calling parametricity that.
18:27:09 <shachaf> harovali1: f is a type constructor.
18:27:12 <shachaf> For example Maybe.
18:27:34 <shachaf> (->) is a type constructor too, for what that's worth, but you don't need to worry about that. :-)
18:28:42 <harovali1> shachaf: so , how is ( a -> b )  different than f a  ?
18:29:15 <shachaf> I'm not sure what you mean.
18:29:35 <dmwit> harovali1: f is a type variable; (->) is a specific (non-variable) type constructor.
18:29:54 <dmwit> :k (->)
18:29:57 <lambdabot> * -> * -> *
18:30:02 <dmwit> yay, lambdabot does :k
18:30:05 <shachaf> That is one way in which these things are different.
18:30:16 <shachaf> I,I *^op -> * -> *
18:30:32 <dmwit> :k forall m. Monad m => m
18:30:33 <lambdabot>     Illegal symbol '.' in type
18:30:33 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
18:30:33 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
18:30:35 <harovali1> dmwit: aha, I see
18:30:56 <dmwit> uh
18:30:59 <dmwit> That can't be right.
18:31:14 <harovali1> dmwit: what the bot said?
18:31:14 <dmwit> Oh, this is that bug we were noticing the other day, right?
18:31:20 <dmwit> No, what ghci told me. =)
18:31:22 <dmwit> Prelude> :k forall m. Monad m => m
18:31:24 <dmwit> forall m. Monad m => m :: *
18:31:27 <shachaf> It's the bug we've been noticing for months.
18:31:34 <harovali1> dmwit: ouch !  :-)
18:33:13 <dmwit> Well, I haven't been noticing it for months. =/
18:39:31 <harovali1> type variables are defined in classes ? Like the class Functor ?
18:39:41 <dmwit> no
18:41:00 <dmwit> Each type that mentions a type variable has either an explicit or implicit "forall" binding that type variable somewhere.
18:41:01 <troydm> harovali1: what are type variables? O_O
18:41:14 <dmwit> In Haskell 98/Haskell2010, all foralls are implicit and outermost.
18:41:27 <dmwit> troydm: e.g. the a and b in map :: (a -> b) -> [a] -> [b]
18:41:32 <troydm> harovali1: ohh you mean types
18:41:44 <dmwit> I don't think he meant types.
18:41:47 <troydm> yeah i can them just type parameters
18:41:53 <troydm> *call
18:42:18 <shachaf> troydm: There's such a thing as a type variable and that's the standard name.
18:42:23 <shachaf> And it doesn't mean the same thing as a type.
18:42:29 <applicative> dmwit dont listen to them http://math.andrej.com/2012/12/25/free-variables-are-not-implicitly-universally-quantified/
18:42:56 <harovali1> dmwit: so, in (a -> b) -> f a -> f b  , all three a, b and f are type variables ?
18:43:15 <applicative> they range over all types of kind *
18:43:29 <applicative> f ranges over things of kind * -> *
18:43:51 <dmwit> applicative: That doesn't appear to be talking about Haskell type declarations.
18:43:57 <dmwit> And therefore is irrelevant here.
18:44:07 <dmwit> harovali1: yes
18:44:28 <applicative> not at all, its a general attack on that specific form of nonsense, which prevails among highly educated people
18:44:37 <applicative> its a bit of a harangue of course
18:44:39 <dmwit> But which has not shown its head here (yet).
18:45:15 <applicative> there is no reason to speak of a quantifier in connection with (a->b) -> f a -> f b
18:46:03 <harovali1> applicative: is somtehing of form * -> *  also of form * ?
18:46:05 <dmwit> There is a good reason to talk about a quantifier in connection with the type declaration map :: (a -> b) -> [a] -> [b], and that is because there is one.
18:46:10 <dmwit> two, in fact
18:46:17 <dmwit> harovali1: no
18:46:26 <applicative> no, there are free variables.
18:46:32 <dmwit> whaaat
18:46:34 <elliott> oh god, not this again
18:46:35 <harovali1> aha
18:46:38 <harovali1> thanks
18:46:59 <dmwit> applicative: Are we talking about Haskell here, or logic?
18:47:04 <dmwit> Because in Haskell, those are not free variables.
18:47:05 <applicative> ghc needs an interpretation that can supply a quantifier because it has other fancy types.
18:47:08 * elliott waits for it to move onto Applicative => Monad being bad.
18:47:14 * harovali1 speaks only about haskell
18:47:25 <applicative> in Haskell 98 there is no concept of quantified type variables
18:47:29 <applicative> its pure ghc
18:48:05 <applicative> elliott: I never argued that; only that everyone's arguments were wrong, and thus spreading nonsense, which is wrong
18:48:17 <harovali1> ok, that's a discussion that supersedes my currents interests :-)
18:48:18 <applicative> I favor Applicative => Monad
18:48:30 <elliott> ok. I think spreading tedium is wrong too. :p
18:49:00 <applicative> elliott: sure
18:49:10 <dmwit> applicative: If I write "foo :: a -> b" and "bar :: b", I can nevertheless apply foo to bar, despite the fact that a and b are not equal.
18:49:22 <dmwit> If a and b were free, I would not expect that to succeed.
18:49:35 <applicative> indeed, there are endlessly many pages on this in logic primers
18:49:48 <applicative> if you quantify them, you have to instantiate them.
18:50:35 <applicative> it is impossible to reason just with quantifiers
18:50:57 <dmwit> You are claiming that they are not quantified. So I don't understand why your sentence beginning "if you quantify them" says anything relevant here.
18:51:21 <applicative> foo :: forall a b . a -> b ; bar :: forall x . x
18:51:28 <applicative> now apply one to the other
18:51:34 <dmwit> yes
18:51:36 <applicative> it doesn't work
18:52:00 <applicative> you instantiate -- need new letters like Frege and Gentzen
18:52:10 <dmwit> Okay, I'm happy introducing some explicit type application syntax to go along with the explicit quantification.
18:52:26 <dmwit> I don't see how that lets you conclude that type variables are therefore not implicitly quantified in Haskell.
18:52:27 <applicative> foo :: m -> n ; bar :: m ; foo bar :: n
18:53:00 <applicative> the typing derivation for foo bar, which shows that it occupies any type you please, presuppose the use of free variables
18:53:10 <dmwit> Also irrelevant.
18:54:01 <skjermlaus> is there a way to have a type signature such that you either return a value or shut down the program? I could use an Either with a quit signal I know, but i'd have to propagate this through multiple functions.
18:54:06 <applicative> there must be an unquantified type foo :: m -> n
18:54:12 <skjermlaus> right now i return undefined to force a crash after I free all my assets (very hacky I know)
18:54:30 <dmwit> :t exitWith
18:54:31 <lambdabot> Not in scope: `exitWith'
18:54:36 <dmwit> ?hoogle exitWith
18:54:37 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
18:55:47 <skjermlaus> :t ExitCode
18:55:48 <lambdabot> Not in scope: data constructor `ExitCode'
18:55:59 <applicative> http://haddocks.fpcomplete.com/fp/7.4.2/20130622-109/base/System-Exit.html#t:ExitCode
18:56:33 <skjermlaus> just what I needed, thank you!
18:56:44 <applicative> case blah of 13 -> exitWith (ExitSuccess); 14 -> exitWith (ExitFailure 2)
18:59:35 <dmwit> Well, anyway, I'm not really sure what point you're trying to make. But so far I'm 0% convinced that I did something wrong.
19:00:53 <applicative> hm, i hadn't realize people continued to rail at A Bauer and P Taylor about this; bless them...
19:01:31 * elliott so far agrees 100% with both the Bauer post and with dmwit.
19:02:24 <dmwit> Yes, I also agree with Bauer 100%.
19:02:48 <applicative> the connection with types, which is his real purpose, only becomes clear in the discussion
19:03:23 <applicative> he is opposing coq and agda cranks who insist on binding everything in sight
19:03:45 <applicative> as if this were somehow more precise
19:03:55 * elliott sigh
19:07:29 <augur_> ofcourse, a typing statement of one and a typing statement of the other ARE equivalent
19:09:02 <BMeph> dmwit: "<dmwit> Well, anyway, I'm not really sure what point you're trying to make. But so far I'm 0% convinced that I did something wrong." sounds like a quote my city's Mayor should say. :)
19:09:03 <zzing> I am attempting to build the boolean package using the latest platform on mac 10.8, but I get an error in the cabal configure: https://gist.github.com/iaefai/c8044a6fabe0ec7cf04d  about invalid C code generated. Any idea on how to solve this?
19:09:29 <dmwit> I like to think I'm quite up-front about it when I am convinced I am wrong.
19:09:38 <dmwit> I think I've announced it at least twice tonight already.
19:10:21 <dmwit> zzing: That doesn't look like an error to me.
19:10:31 <dmwit> Is that the whole output?
19:10:44 <zzing> for configure, let me get a build output
19:12:15 <zzing> https://gist.github.com/iaefai/c8044a6fabe0ec7cf04d   added the relevant source code on the comment
19:12:17 <elliott> I am also up-front about when dmwit is convinced he is wrong.
19:13:50 <zzing> Sorry, I jumped the gun a little on the error in C, the rest fails though
19:14:05 <zzing> Might be a 7.6 thing, but it said it could compile on 7.6
19:14:09 <zzing> (on hackage)
19:14:18 <dmwit> Looks like it's trying to treat the end of the first pragma as a CPP thing.
19:14:31 <dmwit> Try moving the end-of-pragma marker onto the previous line or something.
19:15:10 <zzing> That is it
19:16:23 <zzing> There seems to be a few of these
19:19:51 <harovali1> in haskell there is parsec, which is great AFAIK. Is there a similar library which instead of parsing, handles generative grammars in haskell ?
19:22:35 <dmwit> What's a generative grammar?
19:22:47 <dmwit> That is to say, what do you want out of the library if not parsing?
19:22:58 <harovali1> there is an old program (written in C++) which handles generative grammars; its name is kaptain.
19:23:49 * tabemann thinks of Chomsky when he hears "generative grammar"
19:23:52 <dmwit> Enumeration of valid sentences, perhaps?
19:24:03 <harovali1> you write a grammar (for instance in BNF) , and you guide the generative grammar instantiation by interacting with a GUI that kaptain builds based on special grammar operatores
19:24:04 <augur_> tabemann: lots of people do!
19:24:20 <harovali1> tabemann: sure, that's the idea
19:24:27 <harovali1> augur_: sure too
19:24:35 <dmwit> harovali1: I'm tempted to just say "data".
19:24:53 <harovali1> I'd like to 'redo' what kaptain does, but in haskell
19:25:19 <harovali1> that's why I'm explorting if there is already aomething that does that
19:25:31 <harovali1> or something partial, or similar to that
19:26:07 <dmwit> It's still not totally clear to me what you want the library to do.
19:26:30 <harovali1> dmwit: yes, it has to to with enumeration if you wish, or better, precise instantiation of the gremmar to write valid sentences in the grammar
19:27:06 <dmwit> Well, now I am just going to say "data".
19:27:17 <augur_> dmwit: data isnt quite a grammar
19:27:29 <augur_> you need to use GADTs to properly model grammars
19:27:44 <dmwit> Pray tell, what is the first token you write when declaring a GADT?
19:28:02 <shachaf> Y'all're missing out on the Mountain View Haskell meeting!
19:28:04 <augur_> or you could have a set of different ADTs for each terminal
19:28:06 <augur_> it depends
19:28:24 <harovali1> dmwit: both the grammar and the instances are data, only that you use the grammar to guide the process of writing data that complies (can be parsed back) in the gramamr
19:28:24 <shachaf> The last half hour of trying to get the projector working has been great.
19:28:26 <augur_> dmwit: there would be two ways, really. lemme hpaste
19:28:53 <augur_> hpaste isnt working :(
19:28:53 <xunie-laptop> shachaf, I can't tune in, can I?
19:29:04 <dilinger> shachaf: type errors between the projector/cable/computers?
19:29:21 <shachaf> xunie-laptop: I don't think so.
19:29:35 <shachaf> You might ask conal if he has slides or something later.
19:29:42 <dmwit> harovali1: My answer is even more literal than you're thinking.
19:29:50 <harovali1> dmwit: :-)
19:29:52 <dmwit> harovali1: I literally mean "the keyword data" is the library you're looking for.
19:29:58 <tabemann> augur_: I just tried going to *l*paste and it came up just fine
19:30:06 <augur_> lpaste works, yeah'
19:30:06 <harovali1> dmwit: ah !
19:30:10 <dmwit> ?where hpaste
19:30:11 <lambdabot> http://lpaste.net/new/haskell
19:31:01 <tabemann> augur_: and if you are trying to access old pastes that were at hpaste, they are at lpaste now - the IDs are the same
19:31:12 <dmwit> harovali1: as in data Expr = Plus Expr Expr | Literal Int, which provides you with two (Haskell) terms Plus and Literal which can be used to generate terms in the grammar.
19:31:36 <dmwit> the grammar here being S -> S + S | N; N -> [0-9]*
19:32:19 <dmwit> You can easily define an (infinite) tree of such terms, where each node's branches correspond to the valid grammar production rules.
19:33:46 <Gracenotes> where's that funnily named page on ncatlab I found the other day :/
19:34:00 <harovali1> is data a library in ghc  (like parsec is) , or is it a haskell language inner component?
19:34:17 <dmwit> It's a keyword. It's how you define new inductive types.
19:34:32 <harovali1> dmwit: interesting
19:34:35 <dmwit> So, no, it's not a library.
19:34:57 <elliott> you've used parsec not bot defined your own data types? :)
19:35:10 <augur_> dmwit: http://lpaste.net/91040
19:35:30 <applicative> harovali1: are you talking about the keyword in 'data X = X | Y
19:35:31 <applicative> ?
19:35:53 <skjermlaus> I have this habit of making "oneline" functions with huge where parts, is this normal practice?
19:36:27 <augur_> dmwit: it really depends on whether you want a type for each kind of expression, or you want a general type of expressions
19:36:42 <dmwit> Yes, I know.
19:37:16 <augur_> personally i think the indexing solution is superior
19:37:20 <applicative> skjermlaus: where is good.  I guess one could go too far, as with most good things...
19:37:31 <harovali1> applicative: yes
19:37:37 <dmwit> I find your GADT a bit silly.
19:37:42 <augur_> dmwit: why?
19:37:54 <applicative> harovali1: oh yeah, 'data' is about as built in as it gets
19:37:56 <harovali1> applicative: but now I've also found this, which sounds like something different, or not ?  http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html
19:38:12 <applicative> harovali1: I was wondering if you mean that, which is a different subject
19:38:13 <dmwit> Why is having three types named Expr S, Expr A, and Expr B better than having three types named S, A, and B?
19:38:17 <dmwit> That's essentially what you've done.
19:38:34 <augur_> dmwit: because then you can have Expr a and it means any expression
19:38:46 <harovali1> applicative: how are they different , would you please tell me a little bit ?
19:38:50 <dmwit> sort of
19:39:04 <augur_> dmwit: i mean, it means that in certain contexts
19:39:15 <applicative> harovali1: for one thing data X = X | Y String , etc has been around since before haskell
19:39:21 <augur_> so like, a semantics would want it to be like, eval :: Expr a -> Whatever
19:39:27 <applicative> Data.Data and Data.Typeable are comparatively recent libraries
19:39:30 <augur_> which you couldnt do with the independent types
19:39:41 <augur_> you could i guess sum them
19:39:50 <augur_> eval :: Either S (Either A B) -> Whatever
19:40:03 <augur_> but that just gets hairy when you've got lots of different categories
19:40:04 <dmwit> Again, I don't see that eval :: Expr a -> Foo a (say) is significantly better than evalS :: S -> Foo S, etc.
19:40:26 <augur_> dmwit: but i dont want a million different evals
19:40:27 <dmwit> or class Eval a where eval :: a -> Foo a, for example
19:40:29 <applicative> harovali1: they are for certain sorts of 'generic' programming. they have lots of uses but are fairly advanced
19:40:30 <augur_> i want _one_ eval
19:40:50 <augur_> type classes would be a possible alternative, sure
19:41:07 <augur_> the type class version is probably more extensible
19:41:10 <harovali1> applicative: and what is the data builtin used for ?
19:41:39 <applicative> harovali1: in Data.Data, Data (capital D) is a type class
19:41:40 <nabilhassein> is the "default" keyword usable from a .ghci file? http://www.haskell.org/haskellwiki/Keywords#default
19:41:42 <augur_> dmwit: it really all depends on your preferences. the indexed version is more interesting for richer grammars, obviously.
19:42:49 <dmwit> admitted
19:43:21 <applicative> harovali1: types that fall under Data are subject to certain highly generic manipulations, see e.g. gfoldl and so on
19:43:51 <applicative> harovali1: the data keyword is for defining your own types. Try it!
19:44:40 <harovali1> applicative: thank you all very much
19:45:06 <applicative> harovali1: you make a little grammar for it, data Harovali1 = H Int | A Char | R (Harovali1,Char)
19:45:41 <harovali1> applicative: hmm, interesting
19:45:56 <applicative> harovali1: this immediately gives you three functions, H :: Int -> Haravoli1; A :: Char -> Harovali1 etc
19:46:21 <applicative> then you can go on and define your own functions Harovali1 -> Harovali1 or Harovali1 -> Int or whatever
19:46:39 <applicative> i should have written
19:46:58 <applicative> data Harovali1 = H Int | A Char | R (Harovali1,Char) deriving (Eq, Ord, Show) -- maybe others
19:46:59 <harovali1> going back to my first question , I'm looking for the reverse of parsec (which parses whatever you tell it to), do you think something like that already written ?
19:47:24 <jmcarthur> if you were trapped on an island with only one or two recursion schemes, what would you prefer them to be?
19:47:32 <applicative> foldr
19:47:38 <applicative> no, unfold
19:47:56 <jmcarthur> neither are especially general, are they?
19:48:02 <shachaf> jmcarthur: cata and ana
19:48:08 <shachaf> You get general recursion that way!
19:48:23 <jmcarthur> really?
19:48:31 <jmcarthur> this is did not realize
19:48:33 <shachaf> Sure.
19:48:36 <applicative> I was thinking of anamorphisms, why would anyone call them that?
19:49:30 <shachaf> jmcarthur: hylo :: (Functor f, Functor g) => (f b -> b) -> (a -> f a) -> a -> b
19:49:48 <harovali1> or reformulating the question, is the (advanced) concept of generic programming broad enough to write not only haskell code but other grammars too?
19:49:50 <jmcarthur> i can't even think of a way that i could define a cyclic list using cata and/or ana, let alone fancier things
19:50:10 <shachaf> Er, no g.
19:50:11 <applicative> i guess its not likely to have a solution unless you permit fun and games like general recursion?
19:50:12 <jmcarthur> i realize i can generate an infinite list, which is maybe close enough
19:50:43 <shachaf> Same thing.
19:50:49 <jmcarthur> yeah i guess
19:51:27 <shachaf> Similary Functor f => Nu g -> Mu g gives you general recursion.
19:51:39 <applicative> Nu f -> Mu f
19:51:43 <shachaf> Sigh, I'll never get this f/g thing straight.
19:52:02 <elliott> they're not implicitly quantified, they're free. there's an f ~ g constraint in the context
19:52:03 <jmcarthur> do you know of any material that explains this?
19:52:05 * elliott hides
19:52:19 <applicative> you mean, we can emulate general recursion, or something like that. as one does in agda and so on?
19:52:34 <shachaf> Well, figuring it out makes a good exercise!
19:52:43 <shachaf> Explains which thing in particular?
19:52:44 <nabilhassein> at the end of the section labeled "a variadic command runner", right above "relative paths", the author of the linked post on Shelly indicates that the line `default (Int, Text)` is at the top of his scripts. is there an analogous way to invoke this automatically in a .ghci file? http://www.yesodweb.com/blog/2012/07/shelly-update
19:52:52 <elliott> applicative: no, it gives you it directly
19:52:58 <jmcarthur> how these things are powerful enough for general recursion
19:53:08 <elliott> applicative: because you can turn your productive "codata" into its "data" result
19:53:15 <applicative> elliott: you mean, if I concede there is such a function as hylo
19:53:19 <elliott> even if the codata is infinite and so the "data" doesn't terminate.
19:53:21 <elliott> roughly.
19:53:26 <elliott> applicative: right.
19:53:28 <jmcarthur> and by "general recursion" do you also include things like polymorphic recursion?
19:53:34 <applicative> yes I see the point now
19:54:02 <shachaf> I'm not sure.
19:54:05 <applicative> I was thinking of 'general recursion' as giving me hylo, instead but maybe this is a better way of speaking?
19:54:13 <shachaf> I mean general as opposed to e.g. primitive recursion.
19:54:59 <jmcarthur> i typically take general recursion to mean "whatever i can do with let", but i don't know whether to count fancier types too
19:55:00 <applicative> hylo does have a tendency to diverge, which would suggest it's in the same game
19:55:14 <shachaf> jmcarthur: Did you do the exercise where you write the isomorphisms between Mu/Nu/Fix?
19:55:26 <applicative> Nu is my master
19:55:28 <shachaf> Without using recursion, wherever possible.
19:55:34 <jmcarthur> i have done some of those, but not all
19:55:44 <jmcarthur> i will do it
19:55:58 <applicative> how is 'Fix' here different from 'Mu'?
19:56:18 <applicative> i'm forgetting jargon i guess
19:56:20 <shachaf> jmcarthur: Also take some specific types, like Mu Maybe/Nu Maybe, and compare what you can do with them (without using recursion yourself).
19:56:27 <shachaf> newtype Fix f = Fix { runFix :: f (Fix f) }
19:56:34 <applicative> right
19:56:36 <shachaf> newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
19:56:42 <shachaf> data Nu f = forall x. Nu x (x -> f x)
19:56:55 <applicative> oh indeed thats a different Mu than on sometimes sees
19:57:03 <jmcarthur> newtype Fix f = Fix (f (Fix f)); newtype Mu f = Mu (forall a. (f a -> a) -> a); data Nu f = forall a. Nu (a -> f a) a
19:57:04 <jmcarthur> bah
19:57:08 <applicative> Nu is always like that, existential
19:57:18 <shachaf> My Mu is the true Mu.
19:57:34 <Gracenotes> modulo alpha conversion
19:57:42 <shachaf> r is the true type variable.
19:59:23 <shachaf> In particular Nu Maybe has one inhabitant that Mu Maybe doesn't, which is the problem here.
20:00:20 <applicative> yes, an excellent inhabitant.
20:01:13 <applicative> But Mu Maybe and Fix Maybe go together
20:01:39 <shachaf> In Haskell they all go together.
20:02:01 <shachaf> But Fix doesn't go with Mu more or less than it does with Nu.
20:03:48 <jmcarthur> this is feeling a lot like my Yoneda and CoYoneda exercises
20:04:28 <shachaf> Which exercises?
20:04:52 <jmcarthur> more like experiments. just playing around with what i can convert to what
20:05:04 <shachaf> Ah. Yep.
20:06:10 <jmcarthur> muToFix and fixToNu are easy. the other direction not so much
20:06:26 <shachaf> Right.
20:06:38 <applicative> Im not at all seeing that this Mu is universal. the core use is for the initial F algebra, which might as well be construed as Fix :: f (Fix f) -> Fix f or am I in a muddle.
20:07:05 <shachaf> In a sense you need an "interpreter" for a Nu value, but a Mu value *is* an "interpreter" of sorts.
20:07:26 <shachaf> applicative: Well, Haskell doesn't really distinguish. But Mu is the standard initial F-algebra.
20:07:49 <shachaf> Well, Mu itself isn't the algebra, it's inMu :: Functor f => f (Mu f) -> Mu f
20:08:05 <applicative> yes, that's my thought, but Fix :: f (Fix f) -> Fix f is an f algebra, and is initial
20:08:21 <shachaf> inNu :: f (Nu f) -> Nu f is initial too, in Haskell.
20:08:24 <dolio> μF is just a name given to initial F algebras.
20:08:47 <dolio> Your Mu is just a way of encoding it in System Fω.
20:08:51 <applicative> shachaf: yes of course, I as thinking they're both candidates, but puzzled by your insistance on your Mu
20:08:58 <applicative> insistence
20:09:10 <dolio> I don't know why that would be "standard."
20:09:43 <shachaf> applicative: You could just as well say runFix is a terminal coalgebra (which it is).
20:11:29 <applicative> does this speak in favor of insisting that your Mu is the one true Mu?
20:11:47 <applicative> its certainly a better type from many points of view....
20:12:13 <skjermlaus> If I have a datatype Sheep, and a function f :: Sheep -> Sheep, is there some general way to reverse changes f made? Without making a new function that does the opposite of f.
20:12:46 <jmcarthur> skjermlaus: keep the original input around?
20:12:49 <applicative> not in general for sure.
20:13:21 <skjermlaus> figured I'd ask before i do it the hard way, thanks
20:13:31 <jmcarthur> skjermlaus: consider   f = const 0
20:13:42 <jmcarthur> skjermlaus: (replacing 0 with whatever Sheep you have sitting around)
20:14:05 <applicative> excellent example jmcarthur somehow I was reaching for something complicated...
20:14:15 <skjermlaus> what does const mean?
20:14:18 <skjermlaus> constant?
20:14:19 <jmcarthur> :t const
20:14:20 <lambdabot> a -> b -> a
20:14:23 <jmcarthur> > const 5 "foo"
20:14:24 <lambdabot>   5
20:14:29 <jmcarthur> > const "bar" True
20:14:29 <applicative> const 0 martha_the_sheep = 0
20:14:30 <lambdabot>   "bar"
20:15:33 <applicative> > let zero = const (0::Int) in map zero [0...
20:15:34 <lambdabot>   <hint>:1:44:
20:15:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
20:15:37 <applicative> > let zero = const (0::Int) in map zero [0...]
20:15:38 <lambdabot>   A section must be enclosed in parentheses thus: (0 ...)Not in scope: `...'
20:15:38 <lambdabot> ...
20:15:41 <applicative> bah
20:15:46 <applicative> > let zero = const (0::Int) in map zero [0..
20:15:47 <lambdabot>   <hint>:1:43:
20:15:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
20:15:49 <applicative> > let zero = const (0::Int) in map zero [0..]
20:15:50 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:15:55 <applicative> i am typing in the dark.
20:16:17 <applicative> see I dont thnk you can inspect those 0s to see what number they came from
20:16:19 <skjermlaus> Don't think I get it, but I am convinced nonetheless.
20:16:37 <applicative> consider abs
20:16:47 <jmcarthur> skjermlaus: inlining const:    f _ = SomeSheep
20:16:51 <applicative> map abs [-1,1]
20:16:54 <jmcarthur> skjermlaus: hard to find an inverse for f there
20:16:59 <applicative> > map abs [-1,1]
20:17:00 <optimusbrine> skjermlaus, it really doesn't make sense to talk about undoing what X -> Y does by getting back X: you never lost it in the first place :P
20:17:00 <lambdabot>   [1,1]
20:17:01 <skjermlaus> ah yeah
20:17:22 <applicative> I cant recover whether the 1 came from -1 or 1
20:17:31 <jmcarthur> skjermlaus: hence my suggestion to just keep the input around instead of forgetting it in the first place
20:17:56 <skjermlaus> I see, thanks
20:22:57 <jmcarthur> this LtU thread was enlightening for me http://lambda-the-ultimate.org/node/4290
20:24:00 <jmcarthur> good summary:   "That is, to construct fix f, first build an infinite stream of fs (an unfold), and then replace each cons with application (a fold)."
20:24:05 <novascorpio> Hi, I saw the following code for generating a lazy infinite sequence of fibonacci, and I'm having some trouble understanding it. I have a rudimentary understanding of smlnj and I understand ocaml pretty well: fibonacci2 = 0:1:zipwith (+) fibonacci2 (tail fibonacci2)
20:24:51 <jmcarthur> novascorpio: try doing a few steps of evaluation
20:25:16 <novascorpio> jmcarthur: hmm ok.
20:26:20 <novascorpio> ooh I see. that's clever.
20:26:25 <jmcarthur> :)
20:27:55 <shachaf> @let hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b; hylo f g = f . fmap (hylo f g) . g
20:27:56 * tabemann is using the fibonacci sequence as an example for his "lunch and learn" at work on haskell, but he isn't using that implementation as it's probably too clever for his coworkers
20:27:56 <lambdabot>  Defined.
20:27:56 <Ghoul_> modules containing monads should be in Control.Monad.* ?
20:28:11 <jmcarthur> Ghoul_: not necessarily
20:28:27 <jmcarthur> Ghoul_: don't worry too much about conventions. they don't make a whole lot of sense anyway
20:28:34 <Ghoul_> lol ok
20:28:49 <Ghoul_> It's just Im polishing up my monad and im going to go through the process of putting something on hackage
20:28:50 <jmcarthur> Ghoul_: e.g. one could argue that *everything* belongs under Data.*
20:29:08 <tabemann> then why have a Data top-level module then?
20:29:13 <jmcarthur> tabemann: why indeed
20:30:10 <dolio> I don't think you can argue that, really. And there's some stuff in Data that doesn't make a lot of sense.
20:30:50 <shachaf> To be fair, there is no Data top-level module. :-)
20:31:22 <dolio> Some stuff is unclear where to put.
20:31:33 <dolio> Like, Text is in Data.Text, but there's also a Text hierarchy.
20:31:35 <jmcarthur> i will back out on the claim slightly. one could argue that all functions and other values could make sense under Data. type classes and such might not
20:31:53 <elliott> yes. typeclasses are clearly "control".
20:31:59 <jmcarthur> heh
20:32:30 <jmcarthur> if Control.* were named Code.* instead, then it would be easier to see the error of our ways
20:33:36 <dolio> I'm actually not even sure that the Data type class belongs in the Data hierarchy like it is.
20:34:05 <dolio> Despite being all about data.
20:34:13 <jmcarthur> i love that we have Control.Monad and Data.Functor
20:34:24 <dolio> Yeah, I'm not sure how that happened.
20:34:39 <elliott> because functors are containers.
20:34:42 <elliott> but monads are computations!
20:34:51 * jmcarthur sighs
20:34:53 * elliott is trolling. sorry.
20:35:07 <optimusbrine> Text.Monad (i mean, the program I wrote is text)
20:35:28 <Gracenotes> I'll believe it when I see DeriveMonad
20:35:39 <jmcarthur> ha
20:36:01 <tabemann> one can do GeneralizedNewtypeDeriving with Monad instances...
20:36:11 <jmcarthur> not the same
20:36:32 <jmcarthur> you can *actually* derive Functor, Foldable, Traversable these days
20:36:51 <shachaf> jmcarthur: But it's O(n^2). :-(
20:36:59 <jmcarthur> shachaf: tis awful
20:37:34 <jmcarthur> wait, n^2? that's even worse than i thought it was
20:37:50 <shachaf> What did you think?
20:37:54 <Ralith> what's n?
20:37:55 <jmcarthur> n is the number of leaves?
20:37:59 <dolio> Not always n^2.
20:38:16 <shachaf> Yes, I mean for a list in particular.
20:38:23 <jmcarthur> oh
20:38:31 <dolio> Its badness varies by type.
20:38:33 <shachaf> It's the path to the leaf, and it depends on how much of the structure you evaluate and so on.
20:38:35 <jmcarthur> O(n*depth) is what i thought
20:38:36 <shachaf> http://ghc.haskell.org/trac/ghc/ticket/7436
20:38:40 <tabemann> how do you derive Monad for something if you could create multiple Monad instances for the same data structure (with different newtypes obviously)?
20:38:42 <shachaf> It's just eta expansion.
20:39:12 <jmcarthur> tabemann: you don't
20:39:32 <applicative> it's all Data. that's why Data. should be scrapped
20:39:53 <tabemann> they've renamed large sets of modules in Haskell before, they can do it again
20:40:07 <jmcarthur> tabemann: this time i span many/most packages
20:40:11 <jmcarthur> *it spans
20:40:32 <tabemann> tis true
20:40:42 <scshunt> data structures should move to Structure.
20:42:01 * hackagebot attoparsec-conduit 1.0.1.2 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-1.0.1.2 (MichaelSnoyman)
20:42:03 * hackagebot classy-prelude 0.5.9 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.9 (MichaelSnoyman)
20:42:05 * hackagebot conduit 1.0.7.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.7.2 (MichaelSnoyman)
20:42:07 * hackagebot markdown 0.1.6 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.6 (MichaelSnoyman)
20:42:09 * hackagebot mime-mail-ses 0.2.1.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.1.2 (MichaelSnoyman)
20:42:37 <applicative> yipe, missiles launched from the israel/lebanon border, film at 11
20:44:16 <jmcarthur> fix f = foldr1 (.) (repeat f) undefined
20:44:49 <applicative> @type let fix f = foldr1 (.) (repeat f) undefined in fix
20:44:49 <lambdabot> (c -> c) -> c
20:44:55 <applicative> hm
20:45:20 <jmcarthur> > let fix f = foldr1 (.) (repeat f) undefined in fix (1:)
20:45:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:45:38 <jmcarthur> > let fix f = foldr1 (.) (repeat f) undefined in fix $ const "foo"
20:45:38 <lambdabot>   "foo"
20:46:41 <jmcarthur> perhaps better:   fix = foldr ($) undefined . repeat
20:47:01 * hackagebot uri-conduit 1.1.1 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-1.1.1 (MichaelSnoyman)
20:47:03 * hackagebot xml-conduit 1.1.0.5 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.5 (MichaelSnoyman)
20:47:05 * hackagebot yaml 0.8.4 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.4 (MichaelSnoyman)
20:47:07 * hackagebot yesod-bin 1.2.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.2 (MichaelSnoyman)
20:47:09 * hackagebot yesod-fay 0.4.0.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.1 (MichaelSnoyman)
20:47:17 <jmcarthur> we are being snoymaned!
20:47:25 <pharaun> :D
20:47:40 <pharaun> oh i didn't know there was a uri-conduit
20:47:43 * pharaun wonders what's in there
20:48:22 <pharaun> ahh
20:48:23 <BMeph> phraun: Do you get tired of people trying to turn you upside-down? :)
20:48:58 <pharaun> heh
20:50:53 <applicative> > foldr1 (.) (repeat f) undefined $ ([0,1]++) . (zipWith(+) `ap` tail)
20:50:54 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr t)
20:50:54 <lambdabot>    arising from the ...
20:51:18 <applicative> > (\f -> foldr1 (.) (repeat f) undefined )$ ([0,1]++) . (zipWith(+) `ap` tail)
20:51:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:51:28 <pharaun> BMeph: i'm mostly tired today :p
20:52:22 <ClaudiusMaximus> :t foldr1 -- could be better as  (a -> b -> b) -> (a -> b) -> [a] -> b  ?  (or at least that's how i remember one discussion a decade ago..)
20:52:23 <lambdabot> (a -> a -> a) -> [a] -> a
20:52:41 <jmcarthur> > foldr ($) undefined . repeat $ ([0,1]++) . (zipWith(+) `ap` tail)
20:52:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:53:09 <applicative> yes I see, that's better definition
20:53:30 <jmcarthur> not a big fan of the appearance of undefined
20:53:58 <jmcarthur> since that is itself basically   fix id
20:54:11 <jmcarthur> not sure what else to do though
20:55:18 <jmcarthur> i guess the right thing is to use a stream instead of a list
20:55:20 <applicative> oh i see, you are secretly presupposing fix in this definition of fix, you are thinking , jmcarthur
20:55:33 <jmcarthur> it's not critical
20:55:46 <applicative> its good anyway
20:55:48 <jmcarthur> just gotta use data Stream a = Stream a (Stream a) instead of []
20:55:53 <zzing> Is there a reason why ghc 7.6.3 is barfing on #-} being on a separate line in every other package and his brother?  Example from text: https://gist.github.com/iaefai/2eb6137cef175192fb20
20:56:17 <applicative> wrong c-preprocessor?
20:56:24 <jmcarthur> the point is that cata+ana defined fix
20:56:26 <zzing> clang?
20:56:38 <applicative> right, I remember chaos from clang exactly
20:56:49 <applicative> it was tabs at bottom
20:57:07 <zzing> I can install gcc48 I believe, but would prefer clang
20:57:18 <ClaudiusMaximus> depth first backtracking search for all solutions to a finite problem is a list monad use case, right?  or is there something else i should use?
20:57:46 <jmcarthur> ClaudiusMaximus: sounds listy, but consider logict
20:58:13 <jmcarthur> Logic is basically [], just with different performance characteristics
20:58:15 <applicative> zzing: Im pretty sure thats whats going on, but am not competent to advise further ...
20:58:35 <jmcarthur> LogicT has better semantics than transformers' ListT though
20:58:40 <applicative> what is that site where you can search the #haskell logs readily
20:59:16 <applicative> I finally saw what people were complaining about with ListT, never having taken an interest
20:59:45 <jmcarthur> it's not even a monad transformer, really
20:59:48 <applicative> ot
20:59:50 <elliott> ircbrowse.net
20:59:53 <applicative> its pretty trashy
20:59:54 <jmcarthur> it only creates monads from commutative monads
20:59:56 <applicative> oh thanks elliott
21:00:31 <applicative> but it's easy to define the intended one, something like data ListT m a = Nil | Cons a (m (ListT a)) which is pretty simple
21:00:35 <applicative> maybe that's not quite it
21:00:49 <jmcarthur> it needs an m around the whole thing, too
21:01:09 <applicative> yes, I should newtype a recursivized base functor
21:01:28 <jmcarthur> data ListF m a = Nil | Cons a (ListT a); newtype ListT m a = ListT (m (ListF m a))
21:01:36 <applicative> yes
21:01:43 <applicative> it's so simple why not use it
21:02:16 <jmcarthur> it's kind of a pain to use without a ton of combinators, which nobody has taken the time to define
21:02:39 <applicative> its pretty cool. Tekmo is forever on about it.
21:02:58 <applicative> but yes, you couldnt make do with :, do and a few other things
21:03:49 <applicative> I meant, because Tekmo is forever on about it, I took the occasion to figure it out
21:04:14 <applicative> the 'correct' ListT does seem pretty powerful.
21:04:37 <jmcarthur> yeah it's a bit underused except for what people think of logict being for
21:05:04 <zzing> Is there a way for me to tell ghc to use gcc?
21:05:18 <carter> zzing it uses gcc normally
21:05:22 <jmcarthur> i never realized you had to
21:05:22 <carter> ohhh
21:05:27 <zzing> clang here
21:05:29 <zzing> mac
21:05:31 <carter> zzing mac
21:05:33 <carter> ok
21:05:39 <ClaudiusMaximus> jmcarthur: any benchmarks to compare Logic and [] ?  my problem has a finite number of choices at each level and a finite depth, so the extra fairness of Logic doesn't appeal that much unless it's faster and more memory efficient (streaming output would be ideal)
21:05:41 <carter> 10.9 or 10.8 with xcode 5?
21:05:47 <zzing> 10.8 w/xc5
21:05:57 <carter> zzing heres what you do first
21:06:08 <carter> if you reinstall the  xcode 4.6 cli tools
21:06:11 <carter> you'll have a good gcc again
21:06:17 <jmcarthur> ClaudiusMaximus: in a nutshell, LogicT inlines better, but loses sharing. it's a tradeoff and depends on how you will use it
21:06:42 <carter> zzing do that for now
21:06:46 <zzing> will do
21:07:06 <jmcarthur> ClaudiusMaximus: the extra fairness of LogicT only counts at all if you use its special combinators. the Monad instance is the same as []'s
21:07:12 <carter> zzing with a teeny bit of work, once some CLANG patches make their way back into XCODE 5, you'll be able to use CLANG as your CPP
21:07:23 <zzing> ok, good
21:07:36 <carter> zzing i MADE SURE apple devs knew about these issues
21:07:45 <zzing> awesome
21:07:54 <carter> thoughtpolice did the hardwork of writing the clang patches
21:08:06 <carter> i just pestered everyone
21:08:22 <carter> also seems like apple's considering my bug report on the matter the canonical one
21:08:36 <carter> because theyve closed other reports citing mine as already existing
21:08:52 <zzing> It looks  like i have to get the pkg again
21:08:56 <carter> yup
21:09:07 <zzing> maintenance down for wtf :P
21:09:13 <carter> eh?
21:09:21 <zzing> http://devimages.apple.com/maintenance/
21:09:27 <zzing> connect.apple.com redirects
21:09:54 <carter> developers.apple.com  too?
21:10:00 <carter> https://developer.apple.com/
21:10:09 <carter> ahhhh
21:10:09 <carter> damn
21:10:28 <carter> zzing OR you could install clang HEAD
21:10:34 <carter> and symlink gcc to clang :)
21:10:40 <zzing> I will wait
21:10:55 <carter> it would work
21:10:59 <carter> but fair enough
21:11:10 <applicative> zzing: https://github.com/mxcl/homebrew/issues/12225 is sort of relevant
21:11:19 <applicative> did you build this ghc yourself?
21:11:59 <zzing> I did uninstall the platform and reinstall from homebrew, but the issue is simply clang only
21:12:04 <zzing> So unrelated really
21:14:16 <ClaudiusMaximus> jmcarthur: hm, sharing loss might be bad, and i don't need a transformer; would i be correct in thinking that if i use MonadPlus i could write code that runs with both Logic and [] ?
21:14:49 <jmcarthur> ClaudiusMaximus: that seems reasonable, yes
21:15:24 <applicative> zzing: ah, there seemed to be a thought that if ghc was built with clang, it would adopt it as its c preprocessor... which is maybe a little anthropomorphic ...
21:15:56 <carter> that is true...
21:16:07 <carter> but clang 3.3 doesn't have the right CPP patches yet
21:16:13 <carter> should once the next point release is out
21:16:23 <jmcarthur> ClaudiusMaximus: a helpful function i haven't seen around:   fromList = msum . map return
21:16:24 <zzing> MAybe they are down for an update :P
21:16:40 <ClaudiusMaximus> aha, i was about to ask is there a handy combinator that does  [a] -> Logic a
21:17:00 <applicative> there was an extensive discussion of this error http://pastebin.com/z7nA1d1q
21:17:03 <Ghoul_> I can't get Chrono to export correctly here so that I can import it from other modules. Given Chrono.hs as http://lpaste.net/91044 from my other module I get "Not in scope: type constructor or class `Chrono'. Perhaps you meant `ChronoT' (imported from Control.Monad.Chrono)". Can somebody help me? :)
21:17:04 <mauke> The paste z7nA1d1q has been copied to http://lpaste.net/91045
21:17:34 <applicative> with juxovec here around 6:40 http://tunes.org/~nef/logs/haskell/13.06.05
21:17:45 <applicative> but it seems he didn't report back with good news
21:18:20 <applicative> zzing: ^^^ fwiw
21:19:02 <zzing> applicative, it is prebuilt in both cases
21:19:16 <carter> applicative zzing  the CPP stuff is well understood
21:20:02 <zzing> Is there any way to bind to c++ in a practical way?
21:20:02 <carter> clang head or  real gcc are needed
21:20:04 <carter> or the next point release of clang 3.3
21:20:56 <carter> zzing yes
21:20:59 <carter> extern C :)
21:21:06 <applicative> carter: i wasn't opposing your wisdom but imagining i was helping it along
21:21:06 <zzing> !!!
21:21:23 <carter> applicative i'm tired so i couldn't tell :)
21:21:30 <carter> so i set my pedantic to 11
21:21:53 <applicative> Ghoul_: *Control.Monad.Chrono> let x = Chrono undefined
21:21:58 <applicative> works for me
21:22:04 <carter> zzing i'm also mentoring a smart fellow, ofan, who's working on making the low level wrapper stuff happen automatically
21:22:06 <ClaudiusMaximus> Ghoul_: maybe your directory/file layout is wrong or ghc(i) is using a previously installed version instead of your local one, or you didn't restart ghci after recompiling/reinstalling, or something along those lines
21:22:11 <applicative> so the constructor Chrono is in scope Ghoul_
21:22:30 <carter> he's using the work by another smart dude, wavewave, whose project fficxx does the extern C wrapper stuff for you
21:22:54 <applicative> wavewave is clearly a Master
21:22:57 <zzing> carter, I would love to see nice c++ binding ability
21:23:08 <carter> no templates are possible in a nice general way
21:23:32 <carter> zzing if you want to see an AWESOME haskell lib that binds into some nontrivial C++
21:23:34 <carter> look at
21:23:35 <applicative> Ghoul_: oh wait, I see, are you calling from the right directory? or have you compile with cabal or someting?
21:23:39 <carter> @hackage llvm-general
21:23:40 <lambdabot> http://hackage.haskell.org/package/llvm-general
21:23:53 <carter> which is by bscarlet, and gives you pretty complete but haskelly access to LLVM
21:24:04 <carter> github.com/bscarlet/llvm-general
21:24:09 <Ghoul_> applicative: Im just using ghc
21:24:10 <zzing> interesting
21:24:20 <carter> https://github.com/bscarlet/llvm-general/tree/master/src/LLVM/General/Internal/FFI
21:24:26 <Ghoul_> I have Main.hs in a top directory, with the directories Control and Monad inside that and Chrono.hs inside that
21:24:48 <carter> basically lots of extern "C" { STUFF HERE } blocks
21:24:52 <applicative> Ghoul_: then you do ghci Control/Monad/Chronos.hs
21:24:56 <applicative> ?
21:24:59 <carter> because C++ has an ABI that makes no sense
21:25:09 <carter> so you need to make sure you expose things using the C abi
21:25:20 <applicative> if you open Main.hs maybe not everything is in scope, I cant remember how that works
21:25:33 <carter> zzing so basically, you write C style wrappers for the C++ code
21:25:39 <carter> then ffi around it like you'd do with normal C
21:25:54 <zzing> sounds evil
21:25:58 <applicative> Ghoul_: I usually just have a Test.hs at the top or somewhere that imports everything
21:26:06 <ClaudiusMaximus> applicative, that's to do with compiled code vs interpreted code i think
21:26:24 <applicative> Oh, had Ghoul_ compiled?
21:26:46 * applicative uses cabal sandbox now, and is somehow less prone to confusion ... in that context
21:27:40 <applicative> ClaudiusMaximus: can you see what Ghoul_ 's problem is?
21:27:40 <carter> cabal's new sandboxing is awesome
21:27:54 <applicative> it really is
21:27:56 <ClaudiusMaximus> if ghci sees a .o it loads that (with only its exported symbols visible) instead of the .hs (with all its symbols visible)  - that might be an issue
21:28:14 <applicative> though I can't compare it to the others, since I never used them except trivially
21:29:11 <carter> applicative well, its designed to work with cabal :)
21:29:13 <Ghoul_> Sorry, getting hammered with notifications from elsewhere, really sorry
21:29:18 <carter> so any way it acts funny, is a bug
21:29:21 <carter> unlike the external ones
21:29:30 <Ghoul_> I think I should try a cabal file
21:29:35 <carter> those are nice
21:29:36 <applicative> yes, thats what gave me the conviction needed to figure it out, carter
21:29:43 <carter> figure what out
21:29:45 <applicative> Ghoul_: yes, it helps.
21:30:01 <applicative> figure out cabal sandbox when I hadn't e.g. figured out cabal-dev
21:30:22 <carter> i was using it when it was still cabal sandbox-init
21:30:24 <carter> etc
21:30:29 <carter> instead of factored out auto commands
21:30:30 <carter> :)
21:30:38 <carter> had 1-2 gnarly bugs that got fixed fast :)
21:30:39 <applicative> well there then *early adopter*
21:30:45 <carter> yes
21:30:49 <carter> i take the bugs
21:30:52 <carter> so you don't have to
21:31:00 <carter> mwhaahahah
21:31:17 * carter sobs at having all the bugs, but laughs because you neer get them
21:31:44 <applicative> Ghoul_: if you make a cabal file, you can of course just install the library, and then test from there though you can just build and employ the correct incantations
21:31:52 <applicative> Ghoul_: you know about 'cabal init' ?
21:32:04 <applicative> which writes the file for you
21:32:27 <carter> cabal init + cabal sandbox init
21:32:30 <carter> are your friends :)
21:32:31 <carter> do them
21:32:50 <applicative> yes, this combination really altered things for me.
21:33:14 <Ghoul_> thanks :) cabal init is ncie
21:33:19 <applicative> has anyone attempted a tutorial about the sandboxing?
21:33:23 <monochrom> :load *Control.Monad.Chrono
21:33:34 <carter> applicative not that i've seen
21:33:38 <carter> you should :)_
21:33:41 <carter> :)
21:33:58 <applicative> well, I keep learning new things. I guess I could make a note of them as I do...
21:34:14 <applicative> i was talking to a power user on here a few days ago
21:34:23 <carter> oh?
21:34:24 <carter> whom?
21:34:33 <carter> what does power user mean anyways?
21:34:51 <applicative> it doesn't mean much, i think, i was speaking '''ironically'''
21:35:33 <Ghoul_> so if my monad is Control.Monad.Chrono do I shove Chrono.hs in the top directory
21:35:36 <Ghoul_> or in Control/Monad/...
21:36:00 <applicative> ah carter, it was hvr does that nick suggest anything?
21:36:13 <carter> no clue who that is
21:36:17 <carter> also they're on channel :)
21:37:36 <monochrom> Control/Monad/Chrono.hs
21:37:37 <zzing> cabal works with sandboxes now?
21:38:01 <ClaudiusMaximus> hm, cabal init seems to overwrite any pre-existing LICENSE file without warning..  someone with a hackage trac login wants to volunteer to file a bug report?  i'm personally not bothered enough to register just for that..
21:38:01 <monochrom> cabal comes with sandboxes. unreleased version. github only.
21:38:16 <zzing> sounds like something to get
21:38:59 <zzing> Thank all, might see you tomorrow :P
21:39:00 <Ghoul_> and so I should put Control.Monad.Chrono under exposed-modules ?
21:39:12 <monochrom> yes
21:39:13 <Ghoul_> (sorry last question, I promise :P)
21:39:16 <applicative> zzing: yes, you can build it with ghc-7.6 it was no trouble
21:39:52 <applicative> ClaudiusMaximus: I think they respond to bug reports onthe github cabal site too
21:40:06 <ClaudiusMaximus> applicative: don't have a github account either..
21:40:14 <applicative> hah, good work
21:40:47 <carter> ClaudiusMaximus GITHUB TICKET
21:40:49 <carter> not trac
21:41:05 <carter> they don't use the track anymore
21:41:36 <ClaudiusMaximus> carter: oh, ok :)
21:41:37 <carter> *trac
21:41:42 <carter> np
21:41:58 <Ghoul_> cabal build doesn't find my hs files, is there an obvious solution?
21:43:01 <carter> Ghoul_ look how other haskell projects are organized and do that :)
21:43:02 <carter> for now
21:43:20 <carter> src/MODULE/HIERARCHY/HERE.hs
21:44:23 <applicative> ClaudiusMaximus: yes I see it does 'writeLicense' without looking https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init.hs 535 fff
21:44:36 <monochrom> if you use src/Control/Monad/Chrono.hs, there is one more thing to set in your *.cabal file, and I'm too lazy to tell you what, because I don't even use it
21:44:36 <applicative> is it bad that it overwrites the old license?
21:44:53 <Ghoul_> lol, that's helpful
21:45:02 <Ghoul_> but at least I know what I'm looking for :)
21:45:06 <applicative> hs-src-dirs or something
21:46:38 <carter> i'm ok with it overwriting the old license
21:46:44 <ClaudiusMaximus> applicative: it could be bad, if your team of lawyers don't have a backup
21:46:45 <carter> thats easy to undo with git :)
21:47:15 <carter> ClaudiusMaximus if you're not versioning the code, it'd be a problem
21:47:50 <Ghoul_> (Doh -- exposed-modules -- it was commented out!)
21:47:52 * Ghoul_ feels stupid
21:48:08 <carter> Ghoul_ thats because its late at night
21:48:15 <carter> everyones daft then, especialy me
21:50:01 <ClaudiusMaximus> applicative, carter: sure, it's minor, but the lack of warning could potentially lead to code being accidentally released under a wrong license - i know i'm usually worn out by the time my code is 99% done late at night, and i might accidentally hit 5 instead of 6 or something
21:50:23 * ClaudiusMaximus worries too much :)
21:50:51 <carter> ClaudiusMaximus speaking as someone who'd writing enterprise haskell codes + making some bits open source and other enterprise / commmercial licensed only
21:51:05 <carter> "accidental" licenses aren't an issue
21:51:29 <carter> nothing anyone uses on hackage is anything but mit/bsd/apache
21:51:50 <carter> and anything else, the commercial license should have language that supercedes any license included with the source
21:51:58 <carter> huh, actually I should add that to my commercial license :)
22:00:55 * tabemann wishes he could write haskell for his job
22:01:19 <tabemann> (too bad I'm stuck working in Java, and in jobs for this, C, C++, Python, or, at best, Lua)
22:01:37 <tabemann> s/for this/before this
22:03:24 <applicative> lua is now integrated into pandoc. somehow i still dont want to learn it
22:04:07 <tabemann> Lua is barebones but at least it has first-class lexical closures; it's like JavaScript but less brain-dead
22:04:21 <tabemann> its C API is nice to work with, though
22:04:52 <dmj`> tabemann: do you like lua better than python?
22:05:03 <tabemann> dmj`: Python's C API put me off
22:05:38 <tabemann> god I still remember manually manipulating reference counts, and checking my code repeatedly to make sure I didn't miss any increments or decrements
22:05:57 <Ghoul_> does this look like normal cabal output? http://lpaste.net/91046
22:05:57 <dmj`> tabemann: at least it's not VB.net :)
22:06:06 <Ghoul_> is there supposed to be 2 "1 of 1"'s ?
22:06:34 <tabemann> Lua was better for what I was using it for than Python, because I wanted to control all of the ways it talked to the outside world (including commenting out stuff in the runtime I didn't like), whereas that would have been impossible with Python
22:07:06 <tabemann> Python would be better for general-purpose programming than Lua, obviously
22:08:02 <roboguy_> Ghoul_: that's how it generally is for me. I think it has to do with the difference between .o and .p_o
22:08:16 <Ghoul_> OK good :)
22:08:27 <Ghoul_> I thought I messed up and exported the same thing twice somehow lol
22:08:51 <geekosaur> Ghoul_, that just means you also enabled profiling builds
22:09:05 <Ghoul_> oh, okay
22:09:08 <tabemann> dmj`: something about both .NET languages and JVM languages put me off anyways, not just VB.NET
22:09:08 <geekosaur> .p_o is used when you enable profiling
22:09:09 <Ghoul_> thanks for the fact
22:09:29 <geekosaur> (that way you getthe fast one for normal code and the slower but profile enabled one when you need it)
22:10:25 * tabemann thinks both Scala and Clojure would be better languages were they not tied to the JVM
22:13:45 <dmj`> tabemann: yes, C#'s LINQ is nice though, SelectMany == bind. Erik Meijer invented it.
22:14:43 <tabemann> monads seem to have bee pasted onto a number of different languages as of late (e.g. syntax has been added for them to OCaml), but they seem to not have taken off in them as they have in Haskell
22:15:51 <tabemann> s/bee/been
22:15:59 <carter> applicative WHERE IS THIS LUA INTEGERATION?
22:16:05 <carter> this i s new to me
22:17:12 <dmj`> tabemann: is the phd route an option? good way to do haskell fulltime :)
22:17:35 <carter> dmj` thats a badddddd reason to do a phd
22:17:47 <carter> tabemann the trick is to create a biz that uses haskell
22:17:51 <carter> theres more and more every day :)
22:18:06 <dmj`> carter: hah is this from personal experience?
22:18:07 <tabemann> everything I've heard about phds doesn't make me feel enthusiastic about the idea of doing one
22:18:12 <carter> dmj` yes
22:18:20 <carter> i'm still doing stuff that researchy engineering
22:18:41 <carter> but on my own timeline and not contorting it for incremental results or pleasing someone elses interests
22:19:14 <carter> also honestly, the right industrial environment is way more supportive than any academic one i've seen
22:19:17 * tabemann doesn't like the idea of actually *running* a business, and in fact has no idea as to how to do so
22:19:26 <carter> tabemann its like good engineering
22:19:33 <tabemann> that is true; I'd much rather stay in the industry than go into academia myself
22:20:04 <Ghoul_> whats the best way to add something to hackage?
22:20:10 <carter> Ghoul_ get an email account
22:20:20 <johnw> Ghoul_: "cabal upload", after you get an account
22:20:20 <carter> Ghoul_ you mean upload a package
22:20:22 <slack1256> Maybe this is kind of dumb. With EmptyDataDecls, emptry data types cannot be passed to functions right?
22:20:31 <Ghoul_> ok thanks
22:20:32 <dmj`> carter: that sounds like a good deal, have you tried to sell people on haskell? I think I would say I'm a "solutions provider", avoid the explanation altogether. Try SaaS model
22:20:36 <slack1256> because what term could I pass to a funcion if it's empty.
22:20:41 <carter> dmj` nope
22:20:48 <carter> i'm actually doing somethign different
22:21:18 <carter> dmj` you'll know what i'm doing in a few weeks if you follow hackage or reddit or cafe
22:21:19 <dmj`> carter: yea? for industry?
22:21:35 <carter> you'll see
22:21:42 <dmj`> carter: cool beans
22:21:49 <carter> i'm also doing some community / ecosystem work
22:23:14 <dmj`> carter: what community projects do you think need the most love?
22:23:23 <carter> dmj` all of them
22:23:33 <dmj`> carter: I say because I want to get more involved.
22:23:48 <carter> dmj` whats your current strenghts / things you want to learn more about?
22:24:05 <carter> sclv posted to reddit how hackage2 needs help
22:24:25 <Ghoul_> okay, sent the required email :) time to play the waiting game
22:24:32 <Ghoul_> this is exciting.
22:24:34 <carter> Ghoul_ whats the package?
22:24:40 <carter> show me on github
22:24:47 <Ghoul_> a time traveling state! :)
22:24:52 <carter> tardis monad?
22:24:59 <carter> does that need to be on hackage though? :)
22:25:08 <carter> http://hackage.haskell.org/packages/archive/tardis/0.3.0.0/doc/html/Control-Monad-Tardis.html
22:25:12 <Ghoul_> Oh, I have yet to setup a repo. That's a good idea, then I can put it in the cabal file. Full code is here for the time being https://gist.github.com/kvanberendonck/5997267
22:25:23 <Ghoul_> Not quite, this is something different.
22:27:10 <Ghoul_> the gist is missing the documentation, sorry about that, but the idea is to approach time travel in a more cpu/memory efficient way than storing huge thunks or a list of states
22:27:19 <dmj`> carter: Cloud haskell looks really cool.
22:28:16 <carter> tabemann http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki
22:28:16 <carter> Ghoul_ oh, undo redo?
22:28:18 <carter> dmj`: do you know distributed systems / want to learn about them?
22:28:18 <carter> thats kinda important for that one
22:28:18 <carter> http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf is good lecture notes on distributed systems on the theory side :)
22:28:42 <carter> dmj` whats your current areas of expertise / awesome?
22:30:01 <carter> or failing that, what areas you wanna become an expert in / awesome at?
22:30:55 <Ghoul_> carter: undo . redo = id
22:30:59 <Ghoul_> in a human readable way
22:31:00 <carter> huh
22:31:04 <carter> whats the use case ?
22:31:08 <carter> neat though
22:31:14 <Ghoul_> uh, say I wanted to run a game server
22:31:18 <carter> i'm too tired to read code Ghoul_  :)
22:31:19 <Ghoul_> with the ability to roll back in time
22:31:19 <carter> ohh
22:31:26 <Ghoul_> but the state is huuuge
22:31:32 <Ghoul_> then I can store the events that happen instead using Chrono
22:31:43 <Ghoul_> and rollback and forwards quite easily
22:32:15 <dmj`> carter: most of my networking knowledge is from C. Did an IRC server, a router, and tcp/ip implementation. Trying to write a web server in haskell now. grokking snap-server, happstack-server, hyena, prying my eyes out reading the http 1.1 spec. I'd like to get good with distributed systems stuff. Learn more about fault-tolerant algorithms. Feel good about using parsec.
22:32:36 <carter> cool
22:32:49 <carter> dmj` worth digging into #haskell-distributed then :)
22:32:55 <carter> theres an irc for that
22:33:06 <carter> dmj` otoh, if you wanted to maximize scope of community impact
22:33:14 <carter> helping hackage2   happen is good too
22:33:31 <carter> http://www.reddit.com/r/haskell/comments/1iki8p/how_to_help_develop_hackage2/
22:33:57 <dmj`> carter: I'd rather help the community (if I can that is ;)
22:34:15 <carter> dmj` then do a darcs clone + read the stufff on that reddit post
22:34:58 <carter> sounds like you have the right backround to help
22:35:05 <carter> i would, but i have a bajillion things i'm doing
22:35:19 <carter> any  more and it'll overflow to zero or a negative number
22:37:22 <dmj`> carter: alright will do.
22:37:34 <carter> i may still try to help
22:37:39 <carter> but i really shouldnt :O
22:37:47 <carter> #hackage is the channel for that
22:37:52 <carter> sclv did a good summery on that reddit post
22:38:56 <dmj`> carter: alright will do. taking breaks is a good thing.
22:39:07 <carter> np
22:39:25 <carter> dmj` : also  dcoutts is someone to pester to help understand whats needed
22:39:33 <carter> theres also a cabal-devs mainling list
22:39:36 <carter> *mailing list
22:39:42 <carter> but i think thats also mentioned int he redddit psot
22:39:46 <carter> i can't spell
22:39:48 <carter> ttyl
22:39:53 <carter> i should go rest :)
22:41:46 <dmj`> carter: yes, sleep is good
22:42:11 <lpaste> skjermlaus pasted “'s' is a rigid type” at http://lpaste.net/91047
22:42:28 <skjermlaus> could someone tell me what that message means?
22:42:32 <skjermlaus> in the paste
22:43:49 <supki> skjermlaus: it means 'first' promises to return any 's' user may want and you return 'Skill' instead
22:44:07 <skjermlaus> oh
22:44:30 <skjermlaus> do I have to put Skill instead of s in the class? or is there some other way?
22:44:55 <skjermlaus> its not like I'm going to use that type class for any other type anyways, but it's a bit ugly imo :p
22:45:50 <supki> you can look at -XMultiParamTypeClasses + -XFunctionalDependencies and/or -XTypeFamilies
22:46:24 <skjermlaus> Okay, thank you
22:57:14 * hackagebot directory-layout 0.4.0.0 - Declare, construct and verify directory layout  http://hackage.haskell.org/package/directory-layout-0.4.0.0 (MatveyAksenov)
23:02:14 * hackagebot tagged-transformer 0.4.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.4.1 (MatveyAksenov)
23:13:43 <Ghoul_> the maintainer of tagged-transformer should be told there a haddock glitch in his package
23:14:07 <johnw> what glitch?
23:14:08 <Ghoul_> In the documentation near "because the newtype is free" the free turns into a broken hyperlink after being haddock'd
23:14:10 <supki> oh?
23:14:34 <johnw> ah
23:14:39 <Ghoul_> he quoted it like `"free"` and haddock interpreted it wrong
23:14:42 <supki> I see, thanks
23:24:39 <pharaun> what causes haddock to not generate links/doc for certain versions
23:24:43 <pharaun> i noticed that happens occasionally
23:25:02 <mauke> build failure
23:25:48 <johnw> it happens sometimes if hscolour fails
23:25:48 <pharaun> ahh k
23:26:35 <Ghoul_> Its a little bit annoying
23:26:56 <pharaun> anything i can do about it like if i notice one email the author or ?
23:38:35 <Ghoul_> how do you uninstall a cabal package
23:41:57 <ClaudiusMaximus> @where uninstall
23:41:58 <lambdabot> Uninstall, what's that ? -- Also see <http://www.vex.net/~trebla/haskell/sicp.xhtml#remove>
23:42:01 <johnw> the most complete way is using the "cabal-delete" tool
23:42:10 <johnw> just cabal install cabal-delete; cabal-delete package
23:42:28 <ClaudiusMaximus> oh, didn't know about that :)
23:42:33 <johnw> that's what I use
23:42:45 <johnw> I like that it can recursively remove packages that depend on the one you're removing too
23:43:16 <ClaudiusMaximus> @hackage cabal-delete seems 404
23:43:17 <lambdabot> http://hackage.haskell.org/package/cabal-delete seems 404
23:43:24 <johnw> oh, it's on github
23:43:26 <johnw> sorry, forgot that
23:47:19 <Ghoul_> cabal-uninstall works
23:47:29 <Ghoul_> sorry, didn't see the comment about cabal-delete :)
