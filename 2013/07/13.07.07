00:04:13 <fragamus> GAME! match nomenclature from two different comonad definitions:    (extract, duplicate, extend) vs (coreturn, cojoin)
00:05:55 <mauke> extract = coreturn, duplicate = cojoin?
00:06:17 <byorgey> that would be my guess too.
00:06:22 <byorgey> and extend is cobind.
00:07:12 <fragamus> you guys are right
00:07:31 <CaptainK> ok, thanks all for the help, deserved the harsh treament, not seeing the forest for the trees :P
00:08:02 <johnw> CaptainK: we're here to help; at the same time, a little extra reading could take you a lot further in shorter time than we can
00:08:34 <CaptainK> true true...been pushing my square peg in a round hole for too many hours today.
00:09:35 <byorgey> CaptainK: get some sleep =)
00:10:00 <CaptainK> can't wait to get a new full sized laptop...coding on these mini acer aspire ones...so the screen is like ipad size....ya I need sleep
00:10:24 <Ebony> Would anyone happen to know what software they used on this site (the realworldhaskell online book)? http://book.realworldhaskell.org/read/
00:10:41 * CaptainK smells something like burning rubber.
00:11:03 <byorgey> Ebony: I think it was something custom
00:20:12 <ofan> Ebony: do you mean the website?
00:21:07 <Cale> Ebony: According to the meta tags, DocBook
00:21:19 <mstksg> does anyone know why despite so many widely used ghc extensions and stuff we haven't had a new haskell standard in literally fifteen years?
00:21:43 <elliott> mstksg: ...we had a new Haskell standard three years ago.
00:21:44 <Cale> mstksg: Because standardisation is less important than you'd think
00:21:57 <Cale> Well, does Haskell 2010 really count?
00:21:58 <Cale> ;)
00:22:11 <mstksg> elliott: oh really? heh. i guess i always hear people talking about 98
00:22:21 <mauke> ... people are still talking about '98?
00:22:36 <Cale> Haskell 2010 is essentially the same language as Haskell 98
00:23:20 <mstksg> did it incorporate any of the popular ghc extensions?
00:23:24 <mauke> C99 is essentially the same language as C90 :-)
00:23:37 <Cale> Basically just pattern guards
00:23:44 <mauke> FFI?
00:23:55 <Cale> FFI was already specified in an addendum to H98
00:24:03 <Cale> as was Hierarchical Modules
00:24:58 <mstksg> it just feels like when i write or use codes with extensions i'm not really using "official haskell"
00:25:07 <mstksg> like "real haskell"
00:25:16 <mauke> real haskell is ghc at this point
00:25:49 <Cale> mstksg: The purpose of the standard is to document what's already implemented.
00:26:22 <mstksg> Cale: it's not that the standards dictate how implementations are to work?
00:26:40 <elliott> Haskell was meant to be a language that is extended and built upon as research work from the beginning.
00:26:43 <mauke> it's both
00:26:54 <elliott> it's a starting point. maybe it shouldn't be but that's how it is.
00:26:57 <mauke> implementations are supposed to mutate in random directions
00:27:12 * hackagebot attoparsec-conduit 1.0.1.1 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-1.0.1.1 (MichaelSnoyman)
00:27:13 <mauke> then some changes are merged into the main language
00:27:14 <Cale> The standard helps implementations be more similar, but if there's any good reason for them to behave differently, then I'm sure they'll do so.
00:27:24 <mstksg> i guess i can understand that
00:27:43 <nicoo> qalc
00:27:44 <mstksg> given the spirit of haskell's inception
00:27:47 <nicoo> Oops
00:28:00 <mstksg> i guess i come from a background where specifications come first, implementations after
00:28:05 <Cale> actually, GHC doesn't use the H98/H2010 prelude at this point
00:28:05 <mstksg> as a hard rule
00:28:17 <mauke> mstksg: where does that happen?
00:28:31 <Cale> Really, the 'base' package is more of a standard in that respect than the Report's Prelude.
00:29:07 <mauke> because that's not how it happened with Unix, C, C++, Perl, JavaScript, Java, C#, Python, ...
00:29:36 <shachaf> Perhaps Ada?
00:30:53 <mstksg> isn't posix a spec for unix systems from which linux etc. follow?  they add their own "extensions" but have no influence in determining the future of other posix systems
00:31:15 <Ebony> mstksg: It wasn't, originally.
00:31:23 <mauke> posix is an after-the-fact description of what various unix systems do
00:31:44 <Ebony> s/It wasn't/That wasn't how Unix was defined/
00:31:59 <mauke> but it's not like posix was written first, and then someone implemented unix
00:32:12 * hackagebot conduit 1.0.7.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.7.1 (MichaelSnoyman)
00:32:14 * hackagebot filesystem-conduit 1.0.0.1 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-1.0.0.1 (MichaelSnoyman)
00:32:16 * hackagebot network-conduit-tls 1.0.0.3 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.0.3 (MichaelSnoyman)
00:32:49 <mstksg> maybe i'm speaking more from test-driven development
00:33:08 <mstksg> where the specs are created in an implementation-less vacuum of sorts
00:33:12 <mauke> waterfail
00:33:37 <mstksg> and implementation is created to fill specs
00:34:14 <mstksg> and isn't ruby only defined by its specifications?
00:34:21 <mstksg> it has a C implementation that is a reference
00:34:46 <mstksg> but the java/.net implementations are technically on equal levels
00:35:12 <mauke> the implementation always comes first
00:35:41 <bitonic`> mauke: the first Haskell standard came before any implementation
00:36:27 <bitonic`> and then I think Augustsson implemented Haskell from the first time following the standard
00:37:12 * hackagebot yesod-auth 1.2.0.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.0.2 (MichaelSnoyman)
00:38:35 <elliott> well, Haskell was the POSIX of lazy functional languages.
00:38:40 <elliott> sort of.
00:38:57 <mstksg> in any case it might be more romantic to think of a programming language as a language, and not a language interpreter
00:39:25 <mstksg> a language should exist independent of implementations because it's just...an idea, a way of speaking
00:39:28 <mstksg> right?
00:39:35 <bitonic> elliott: type classes were new, weren’t they?
00:39:36 <mstksg> a syntax for communication
00:39:58 <elliott> bitonic: sure.
00:40:30 <byorgey> that was pretty much the only risky/not-well-trodden thing they stuck in the original Haskell standard
00:40:48 <mauke> bitonic: ah, the report 1.0
00:41:17 <bitonic> I also think the behaviour with what regards lazyness and data types was changed from miranda
00:41:38 <bitonic> yes
00:42:20 <bitonic> in Miranda (_|_, _|_) = _|_.  in Haskell that’s not the case
00:42:56 <dolio> It's not really true in Miranda, either.
00:43:22 <dolio> Haskell is just more consistent.
00:43:31 <bitonic> dolio: ‘Miranda’s design identified ⊥ with (⊥, ⊥), which influenced us considerably.’  From the ‘Being Lazy with Class’ paper
00:43:52 <dolio> Miranda has seq, which makes it untrue.
00:44:09 <dolio> Tuple patterns were irrefutable.
00:44:25 <dolio> But seq still distinguished (_|_, _|_) from _|_.
00:44:37 <Gracenotes> hm... that is a bit inconsistent
00:45:29 <bitonic> dolio: oh, right.
00:45:44 <Gracenotes> lots of Miranda users in this channel, eh.
00:46:12 <bitonic> I just recalled that section in that (very nice) paper :)
00:46:19 <bitonic> never used miranda in my life
00:46:22 <dolio> I've never used it. I just know some stuff about it.
00:46:36 <dolio> It had some cool features that got lost.
00:46:54 <dolio> Like, you could specify rewrite rules to apply to constructors of a data type.
00:47:06 <bitonic> I was born when Haskell was born, so I never had a need for Miranda ehe
00:47:08 <dolio> To make automatic smart constructors.
00:47:20 <dolio> That looked like any other constructor.
00:47:24 <Gracenotes> that sounds potentially confusing.
00:47:39 <bitonic> dolio: oh cool, did it also have pattern synonyms?
00:47:44 <dolio> I don't think so.
00:48:32 <Gracenotes> http://www.berniepope.id.au/docs/mira2hask.pdf - we just need to find the dual of this paper
00:49:31 <Gracenotes> oh, Miranda also allowed f a a = True; f _ _ = False as having the same behavior as (==)
00:49:46 <Gracenotes> Which can cause some issues with _|_...
00:50:10 <dolio> Yeah, I'm not sure I'm a huge fan of that.
00:51:43 <Gracenotes> Miranda had no anonymous functions, no explicit case statements
00:52:42 <Gracenotes> though that's just syntactic
00:55:51 <Gracenotes> liftM5 :: Monad * => (** -> *** -> **** -> ***** -> ****** -> *******) -> * ** -> * *** -> * **** -> * ***** -> * ****** -> * *******
00:56:13 <arkeet> thank goodness we have letters for type variables
00:56:29 <arkeet> :c
00:57:05 <mauke> "In addition, the syntax of Haskell offers a number of conveniences not found in Miranda (such as anonymous functions, let expressions, if-then-else expressions, case expressions, as patterns, user-defined operators, 'wild-card' parameters, etc.)"
00:57:16 <bitonic> that was another bold move in the Haskell standard!
00:57:45 <bitonic> “guys, we’re going to use alphanumeric strings for our type variables!”
00:58:17 <mauke> ** :: a -> a
00:58:32 <arkeet> the first 4 of those are pretty essential.
00:58:41 <mauke> id :: id -> id
00:58:42 <arkeet> well, maybe if/then/else a bit less so.
00:58:52 <arkeet> since you could just write a function for that.
01:00:25 <arkeet> which should be bool :: a -> a -> Bool -> a
01:00:28 <Gracenotes> hm. in the Miranda interpreter, ':t foo' is 'foo ::'
01:00:44 <arkeet> you mean you write 'foo ::' to query its type?
01:00:56 <Gracenotes> yes. also, if foo isn't defined, it will give you '*'
01:01:02 <arkeet> heh.
01:01:11 <shachaf> Well, foo *is* undefined.
01:01:15 <arkeet> lol
01:01:37 <Gracenotes> free variables are all top
01:20:21 <circle>  data Tree a = Node a [Tree a]
01:20:26 <circle> where's the base case in that Tree definition?
01:20:45 <elliott> e.g. Node x []
01:20:58 <circle> is [] a list of type [Tree a]?
01:21:06 <elliott> yes
01:21:10 <circle> hmm, ok
01:21:15 <elliott> the empty list is [a]
01:21:21 <elliott> for any a
01:21:28 <elliott> including Tree a
01:21:33 <circle> interesting
01:21:45 <mauke> types don't need a base case
01:22:03 <mauke> data Foo a = C a (Foo a)
01:22:24 <shachaf> Least fixed points do. :-)
01:22:34 <shachaf> (I.e. data does, not codata. But Haskell doesn't distinguish.)
01:23:47 <circle> if I wanted to make a function which took a Tree of Ints
01:23:53 <circle> how would the outline look?
01:24:00 <mauke> foo x = ...
01:24:05 <circle> f :: Tree Int -> Foo
01:24:06 <circle> ?
01:24:22 <elliott> f (Tree x ts) = ...
01:24:24 <elliott> erm.
01:24:27 <elliott> f (Node x ts) = ...
01:24:34 <circle> I mean the type outline
01:24:45 <mauke> yes
01:25:48 <circle> so it would be
01:25:49 <circle> f :: Tree Int -> Foo
01:27:06 <elliott> sure.
01:29:57 <mikeplus64> > f
01:29:58 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
01:29:58 <lambdabot>    arising from a us...
01:34:27 <startling> Cale, sorry, I appreciate you trying to follow up, but I had realized that I wasn't being productive and had stepped away from the computer.
01:35:14 <Cale> no worries -- I realised after the fact that pipes does have a type alias called "Client"
01:40:06 <Gracenotes> :t \x -> f x x
01:40:07 <lambdabot> FromExpr (t1 -> t1 -> t) => t1 -> t
01:46:59 <FreeFull> Gracenotes: You want join
01:47:24 <FreeFull> :t join (\x y -> f x y)
01:47:24 <lambdabot> (Monad ((->) t), FromExpr (t -> t -> a)) => t -> a
01:47:32 <FreeFull> > join (\x y -> f x y)
01:47:33 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
01:47:34 <lambdabot>    arising from a us...
01:47:47 <FreeFull> Oh, I found something Expr doesn't work for
01:48:00 <FreeFull> No, wait
01:48:02 <FreeFull> > join (\x y -> f x y) a
01:48:03 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
01:48:03 <lambdabot>    arising from a us...
01:48:08 <FreeFull> Nope, doesn't work
01:50:30 <FreeFull> > join (+) 3 -- Gracenotes
01:50:32 <lambdabot>   6
01:50:38 <supki> > join f x :: Expr
01:50:38 <FreeFull> > join (,) 3
01:50:39 <lambdabot>   f x x
01:50:40 <lambdabot>   can't find file: L.hs
01:50:47 <FreeFull> supki: Oh, I see
02:30:38 <b6> 2^10 people in channel. keep it just like this. steady.
02:31:09 <elliott> ChanServ and lambdabot aren't people
02:31:49 <neolax> @src group
02:31:49 <lambdabot> group = groupBy (==)
02:31:54 <neolax> @src groupBy
02:31:54 <lambdabot> groupBy _  []       =  []
02:31:54 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
02:31:54 <lambdabot>     where (ys,zs) = span (eq x) xs
02:32:04 <neolax> @src break
02:32:04 <lambdabot> break p =  span (not . p)
02:32:07 <neolax> @src span
02:32:07 <lambdabot> span _ xs@[]                     =  (xs, xs)
02:32:07 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
02:32:07 <lambdabot>                   | otherwise    =  ([],xs)
02:32:58 <mr-> weird
02:33:11 <mr-> xs@[] = (xs,xs) ?
02:33:49 <elliott> v@p matches against the pattern p and also binds the whole thing to q
02:33:54 <mr-> Why not just span _ [] = ([], []) ?
02:34:00 <elliott> oh.
02:34:03 <elliott> good question.
02:34:20 <elliott> *to v
02:34:40 <shachaf> You could argue that there's a bit more "type safety", since you can't change the type of xs, whereas [] can have any type.
02:34:54 <shachaf> But that wouldn't be a great argument. I would write it with ([], [])
02:55:19 <neolax> @src words
02:55:19 <lambdabot> words s = case dropWhile isSpace s of
02:55:19 <lambdabot>     "" -> []
02:55:19 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:05:21 <circle> I have a list
03:05:26 <circle> and I'm filling the list
03:05:33 <circle> like [f 1, f 2, f 3....]
03:05:40 <circle> how do I make it go over multiple lines?
03:06:32 <shachaf> Lines?
03:07:02 <circle> yes
03:07:05 <johnw> circle: I'm not quite sure what you're asking about; are you wanting to pretty-print a list structure?  Can you define "make it go"?
03:07:12 <circle> I'm making the list
03:07:15 <circle> in my editor
03:07:29 <shachaf> Make you can hpaste what you tried?
03:07:32 <circle> I want to extend it over multiple lines
03:07:37 <circle> because I don't want one line too long
03:07:37 <shachaf> Then someone can edit it with a working suggestion.
03:07:39 <circle> just a cosmetic thing
03:07:40 <codesoup> i think he means how he should break up lines of code in his editor
03:07:50 <shachaf> Yes. It should "just work" so clearly something is going on.
03:08:01 <shachaf> So showing existing code is the best way to get the problem solved. :-)
03:15:37 <aristid> shame that repa has no scans.
03:15:40 <circle> just a cosmetic thing
03:19:23 <quchen> http://paste.tryhaskell.org/3595033647050129408 -- circle
03:19:55 <circle> hmm
03:19:57 <circle> fair enough
03:20:02 <circle> you can't do it more elegantly?
03:20:19 <aristid> yes put the ++ on the end of the first line
03:21:29 <aristid> circle: if you're filling it like [f 1, f 2, f 3...] you might be able to use a function to generate the list ;)
03:21:33 <aristid> map f [1..]
03:21:45 <circle> can't you go
03:22:18 <shachaf> quchen: That's not necessary. You can just spread a list over two lines.
03:22:35 <shachaf> I would give circle an example if they showed their existing code.
03:23:14 <quchen> shachaf: Oh.
03:23:27 <quchen> Right. :s
03:23:44 <aristid> quchen: i thought you did that because you prefer the look of aligning []s :)
03:24:04 <codesoup> you can pretty much press enter and put a newline anywhere as long as it doesn't break your indent structure
03:24:05 <quchen> aristid: No, it was probably the result of having the morning dumb right now
03:24:39 <circle> shachaf: my existing code isn't too relevant, and I must admit I haven't really trioed anything at this point
03:24:41 <aristid> haskell's whitespace sensitivity is fairly subtle, i'm not sure whether that's a good or bad thing
03:24:52 <quchen> aristid: I probably thought of multiline strings when I wrote that
03:25:03 <aristid> quchen: heh.
03:27:15 <wole> @hoogle (</>)
03:27:15 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
03:27:16 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
03:28:37 <shachaf> circle: This is valid code:
03:28:41 <shachaf> [ f 1, f 2
03:28:43 <shachaf> , f 3, ...
03:28:44 <shachaf> ]
03:28:55 <circle> how about [1, 2, 3, 4
03:28:57 <circle>        ,
03:29:04 <circle>     4, 5, 6]
03:29:18 <shachaf> At this point I really think you should try it out. :-)
03:29:37 <shachaf> In itself, that looks valid. But maybe the un-indenting will affect something else. I don't know.
03:30:19 <shachaf> GHC is pretty good at saying whether code is valid or not.
03:30:27 <shachaf> Even better than most humans.
03:32:58 <hpaste> neolax pasted “I have no idea why it doesn't work :/ would you take a look?” at http://paste.tryhaskell.org/90718
03:33:13 <neolax> hpaste: thanks
03:33:48 <elliott> neolax: can you hpaste your error too?
03:33:49 <shachaf> neolax: Could you add the output you get (and ideally the output you expect) to the paste?
03:34:42 <shachaf> Hmm, does hpaste no longer hlint?
03:34:52 <shachaf> Oh, no, that's a putStr, not a putStrLn.
03:34:56 <elliott> (good riddance if so...)
03:35:13 <neolax> this is what i get :
03:35:13 <neolax> [["hello","guys,","i","want","to","separate","these","words","by","a"],[],[],[],[],[],[],[],[],[]]
03:35:29 <neolax> with an infinit [], [] ,[] at the end
03:35:52 <shachaf> > break (=="word") ["blah","blah","word","hello","there"]
03:35:53 <lambdabot>   (["blah","blah"],["word","hello","there"])
03:35:55 <shachaf> > break (=="word") ["word","hello","there"]
03:35:56 <lambdabot>   ([],["word","hello","there"])
03:36:02 <shachaf> break doesn't get rid of the "word" itself.
03:36:10 <neolax> ow!
03:36:27 <neolax> didn't think of that :/
03:37:05 <neolax> shachaf: thanks. i'll take care of it :P
03:39:26 <aristid> > second tail . break (=="word") $ ["foo","word","hello","there"]
03:39:27 <lambdabot>   (["foo"],["hello","there"])
03:39:46 <shachaf> > second tail . break (=="word") $ [] -- watch out!
03:39:48 <lambdabot>   ([],*Exception: Prelude.tail: empty list
03:40:13 <shachaf> > second (drop 1) . break (=="word") $ [] -- maybe this. But, really, neolax is already pattern-matching anyway. No need to use "second".
03:40:14 <lambdabot>   ([],[])
03:43:31 <hvr> any Emacs haskell-mode+haskell-interactive-mode users here who want to test tab-completion in the REPL?
03:43:53 <elliott> break should really give ([a],a,[a])
03:43:58 <elliott> or, or, ListZipper a!
03:44:32 <shachaf> zomg break : [a] -> ListZipper a
03:44:34 <shachaf> good type
03:44:43 <elliott> you forgot the predicate.
03:44:58 <shachaf> " :" stands for "p ::"
03:45:07 <elliott> type BreakList a = (a -> Bool) -> ([a],[a])
03:45:12 <shachaf> Except that doesn't handle the no-match case.
03:45:47 <shachaf> break don't handle that case so great, neither.
03:46:38 <aristid> case break of (xs,[]) -> noMatch ; (xs,b:ys) -> match isn't so bad tho
03:47:01 <shachaf> aristid: ?
03:47:20 <shachaf> Ah, hmm.
03:47:22 <aristid> shachaf: i mean dealing with the way break is right now. or did i make a mistake?
03:47:30 <shachaf> No, I did.
03:47:31 <mgsloan> It'd be kinda neat if "Maybe Int :: Type (Maybe Int)"
03:47:44 <elliott> wat
03:47:46 <mgsloan> Naaah nevermind awful idea
03:47:49 <shachaf> mgsloan: It'd be, like, totally neat!
03:47:51 <circle> bvad idea
03:47:53 <mgsloan> due to the separate namespaces
03:47:56 <shachaf> Then we wouldn't need to use Proxy.
03:48:12 <mgsloan> Yeah, and it'd give a nice syntax for TypeRep
03:48:16 <shachaf> Except types should just be first-class.
03:48:26 <shachaf> TypeRep is kind of a different deal...
03:48:28 <shachaf> Well, maybe.
03:48:40 <FreeFull> elliott: ([a], Maybe a, [a])
03:48:43 <mgsloan> Yeah, you could have a "Type a -> TypeRep" coercion
03:48:44 <aristid> ghc's more recent dependent typing features seem like they might be more pain than they're worth if you actually try to use them.
03:48:47 <FreeFull> Because the element might not be there
03:49:13 <mgsloan> Anyway, this wacky idea was inspired by the idea that "(:) :: a -> Type a -> a"
03:49:22 <mgsloan> :D
03:49:49 <Lethalman> given foo :: a -> IO () and bar :: Maybe a, how can I get a baz :: Maybe a -> IO () ?
03:50:02 <aristid> mgsloan: you should go play around with agda:)
03:50:18 <mgsloan> aristid: I did install it a few days ago!
03:50:24 <aristid> mgsloan: yay
03:50:26 <FreeFull> Lethalman: What should it do for Nothing?
03:50:40 <Lethalman> FreeFull, return ()
03:50:44 <aristid> mgsloan: if you have any ideas about using agda without emacs... don't. just use it with emacs</saving you a lot of pain>
03:50:49 <Lethalman> FreeFull, is it possible without a case of?
03:51:09 * hackagebot yesod-platform 1.2.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.2 (MichaelSnoyman)
03:51:15 <mgsloan> aristid: Yeah, I've heard the emacs integration is neat
03:51:32 <aristid> mgsloan: more than that, using agda without it is the worst thing ever.
03:51:40 <FreeFull> :t maybe (undefined :: a -> IO ()) (return ()) (Just 3)
03:51:42 <lambdabot>     Couldn't match type `()' with `a1 -> IO ()'
03:51:42 <lambdabot>     Expected type: a0 -> a1 -> IO ()
03:51:42 <lambdabot>       Actual type: a0 -> ()
03:51:45 <FreeFull> :t maybe
03:51:45 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:51:48 <mgsloan> aristid: Actually, that's where I got bogged down.  Supposedly an "agda-mode" executable was supposed to be installed
03:51:57 <aristid> mgsloan: yes...?
03:52:01 <FreeFull> :t maybe (return ()) (undefined :: a -> IO ()) (Just 3)
03:52:02 <lambdabot> IO ()
03:52:06 <aristid> mgsloan: is ~/.cabal/bin in your path?:P
03:52:16 <mgsloan> aristid: Well, it wasn't, at least from the ubuntu repo
03:52:17 <aristid> mgsloan: which of the agda packages did you install?
03:52:20 <FreeFull> Lethalman: Substitute your function for undefined
03:52:30 <Lethalman> :S
03:52:30 <FreeFull> And it should work. Doesn't need the type annotation
03:52:33 <Lethalman> right
03:52:34 <aristid> mgsloan: why don't you just use cabal to install agda?
03:52:35 <Lethalman> ops, gtg
03:52:38 <Lethalman> thanks !
03:52:45 <mgsloan> aristid: Ahh, not sure why I didn't think of that
03:52:59 <supki> Lethalman: Data.Foldable.for_
03:53:09 <mgsloan> aristid: Not so good for agda that its ubuntu package is so out of date
03:53:40 <shachaf> mgsloan: Types should just be first-class, though.
03:53:43 <FreeFull> Many ubuntu packages are out of date
03:54:07 <circle> bvad idea
03:54:13 <mgsloan>  shachaf: Nah, classes should be first-type
03:54:20 <aristid> mgsloan: i have given up on ubuntu, so *shrug* but that's a topic for #haskell-blah if anything
03:54:26 <shachaf> flip (::) :: (a :: *) -> a -> a
03:54:29 <mgsloan> Oh yeah, so have I
03:54:49 <mgsloan> This is probably the first ubuntu package version of a hackage package I've tried to install in years
03:55:38 <aristid> mgsloan: because you didn't think of it as a haskell thing?
03:56:02 <mgsloan> aristid: Well, I knew it was written in haskell.  The problem was "Prebuilt packages" is first on this page: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Download
03:56:13 <mgsloan> and there's no code block with "cabal install agda" in it
03:56:19 <mgsloan> if I'd seen that I'd have just done that
03:56:47 <aristid> mgsloan: ah. yeah i think it's cabal install Agda, not cabal install agda :D
03:58:28 <mgsloan> aristid: huh, that's odd, "cabal install agda" is working
03:58:48 <hpaste> aristid pasted “Loading Agda mode” at http://paste.tryhaskell.org/90719
03:59:26 <aristid> mgsloan: oh, is cabal case-insensitive? oO
04:00:00 <aristid> mgsloan: i pasted some code for your emacs init, hpaste helpfully announced it:)
04:00:24 <mgsloan> aristid: Thanks!
04:01:09 * hackagebot terrahs 0.9 - A Haskell GIS Programming Environment  http://hackage.haskell.org/package/terrahs-0.9 (SergioCosta)
04:01:10 <aristid> mgsloan: and download the agda standard library and uncompress it into ~/agda/lib (well or anywhere else, but change the emacs init code in that case)
04:03:32 <neolax> is there a standard function for trimming texts? I mean removing left and right spaces of the text?
04:04:00 <elliott> from the head is easy. dropWhile isSpace
04:04:08 <FreeFull> er
04:04:34 <aristid> from the end is easy too, but inefficient: reverse . dropWhile isSpace . reverse :D
04:07:49 <kartlos> does anyone know how to initialise a [Word8] with literals? I just want to create a constant list that holds 3 specific Word8's
04:10:14 <aristid> kartlos: [1,2,3]
04:10:37 <aristid> kartlos: if that's not what you mean, please ask your question more precisely
04:10:50 <mr-> kartlos: add :: [Word8] to that, if you like
04:11:12 <kartlos> aristid: actually I want to do something like ['a', 'b', 'c']
04:11:23 <aristid> map ord "abc"
04:11:34 <aristid> oh yeah not quite
04:11:36 <aristid> :t ord
04:11:37 <lambdabot> Char -> Int
04:11:57 <aristid> > map (fromIntegral . ord) "abc" :: [Word8]
04:11:58 <lambdabot>   [97,98,99]
04:12:04 <mgsloan> aristid: I updated the wiki page so that hopefully noone else will make the mistake I did!
04:12:24 <kartlos> aristid: thank you very much! :)
04:12:48 <aristid> mgsloan: yay:)
04:16:31 <Breadmonster> Guys?
04:16:35 <Breadmonster> I'm having a slight problem.
04:16:49 <Breadmonster> So you can only perform IO from main, right/
04:16:57 <Breadmonster> Or a function that's called from main?
04:17:30 <aristid> unless you use evil functions that you shouldn't use, yes.
04:18:06 <shachaf> Well, that's kind of an odd way of looking at it.
04:18:09 <FreeFull> Breadmonster: What are you trying to do?
04:18:14 <Breadmonster> Then how is it that Parsec has a function like Monad m => m a -> a?
04:18:14 <shachaf> It's like saying "A C program can only run code from main()".
04:18:19 <nicoo> a/wg #kerlann
04:18:33 <FreeFull> Breadmonster: What function is that?
04:18:37 <Breadmonster> FreeFull, I'm trying to make a basic interpreter.
04:18:40 <Breadmonster> parse
04:18:51 <FreeFull> @hoogle parse
04:18:51 <Breadmonster> Or at least, that's what I've been able to use it for.
04:18:51 <lambdabot> Data.Version parseVersion :: ReadP Version
04:18:51 <lambdabot> Language.Haskell.ParseMonad module Language.Haskell.ParseMonad
04:18:51 <lambdabot> Language.Haskell.Parser module Language.Haskell.Parser
04:19:36 <shachaf> I doubt it has a function like that.
04:19:42 <Breadmonster> FreeFull: The problem is that when running the program, you need to do IO before some other computation, and I cannot do that.
04:19:46 <FreeFull> Parse doesn't seem to be   m a -> a
04:20:04 <aristid> Breadmonster: no, parsec has no function with any type Monad m => m a -> a
04:20:09 <shachaf> It might have type M a -> a for some specific monad M, but that's quite different.
04:20:22 <Breadmonster> shachaf, Okay, yeah, that.
04:20:22 <aristid> Breadmonster: you also realize that not every Monad is IO?
04:20:33 <aristid> Breadmonster: for some monad types, M a -> a is legal
04:20:38 <aristid> like Identity
04:20:50 <Breadmonster> aristid, I presumed that since you could do that for one monad, you could do that for all of them...
04:20:54 <aristid> no.
04:21:00 <Breadmonster> Okay, I'll explain my problem like this.
04:21:23 <Breadmonster> my interpreter reads BASIC code line-by-line, and builds an AST, which it then walks down.
04:21:36 <Breadmonster> What should I do when I encounter IO?
04:21:49 <aristid> while parsing?
04:21:57 <Breadmonster> No, during evaluation.
04:22:01 <Breadmonster> Of the syntax tree.
04:22:06 <aristid> use IO for the evaluator.
04:22:19 <Peaker> Breadmonster, interpretBasic :: BasicAST -> IO BasicResult ?
04:22:19 <nicoo> Well, you interpreter should have type AST -> IO (your_result_type)
04:22:27 <Breadmonster> aristid: Wouldn't that be overkill?
04:22:33 <aristid> Breadmonster: no. it would be normal.
04:22:37 <elliott> nothing that is necessary is overkill
04:22:45 <Breadmonster> Hmm, okay.
04:22:56 <nicoo> Breadmonster: That's the normal solution if you *need* to do IO during evaluation
04:23:10 <aristid> your evaluator is supposed to be able to do arbitrary I/O, so it needs to be in type IO.
04:23:19 <Breadmonster> The way I've written my eval function like a recursive function that keeps track of state in a map.
04:23:24 <Breadmonster> Hmm, okay, I'll try this one out.
04:23:30 <Breadmonster> Haskell really bends your mind.
04:24:04 <elliott> you can use StateT! but maybe not yet.
04:24:37 <FreeFull> IO is the easy solution, another solution would be to use a monad that can be made into IO later
04:25:39 <nicoo> FreeFull: I was looking for a simple, explained example for this
04:25:48 <Peaker> Breadmonster, what kind of effects does your Basic interpreter have?
04:26:01 <Breadmonster> Just simple IO.
04:26:11 <Breadmonster> Well, that and assignment.
04:26:22 <Peaker> Breadmonster, IO is not an effect
04:26:29 <Breadmonster> What do you mean by effect?
04:26:47 <Peaker> Breadmonster, effects like throwing exceptions, destructive assignment, printing out to screen, etc
04:26:51 <Breadmonster> Oh, right.
04:27:05 <Breadmonster> Printing to the screen.
04:27:09 <Breadmonster> And taking user input.
04:27:20 <Breadmonster> Though I'm stumped about how the last one is supposed to be done.
04:27:23 <Peaker> Breadmonster, you could use a monad much more restrictive than IO that can only do these things
04:27:34 <Peaker> Breadmonster, but as a beginner, it's going to be easier to just use IO
04:27:35 <Breadmonster> What's IO used for then?
04:27:52 <FreeFull> IO is for all interaction with the outside world
04:28:08 <Peaker> Breadmonster, IO is how that monad would be implemented. IO is for working with input/output effects, mutable variables, exceptions, ...
04:28:31 <Breadmonster> IO is used for mutable variables?
04:28:47 <Peaker> Breadmonster, they're called IORefs in IO, yes
04:28:59 <Peaker> Breadmonster, you could say they're mutable cells and not "variables"
04:29:02 <Breadmonster> Where exactly is all this in Learn You a Haskell?
04:29:45 <Peaker> don't see it, maybe he decided to focus on better practices than using IO for these purposes :)
04:29:58 <Peaker> though it is useful to know about IORefs
04:30:43 <FreeFull> Learn You a Haskell is only a guide for beginners, for more advanced stuff you have to look elsewhere
04:31:28 <Breadmonster> FreeFull, so what should you use after LYAH?
04:31:35 <Breadmonster> Haskell is far deeper than I thought -.-
04:36:37 <FreeFull> Breadmonster: You could look at Real World Haskell, or Typeclassopedia, or just go looking through libraries
04:36:45 <Breadmonster> Hmm, okay.
04:36:46 <FreeFull> Maybe read some stuff on Haskell wiki
04:36:57 <Breadmonster> I've been waiting for Real World OCaml too.
04:37:04 <Breadmonster> But yeah, I think I'll start RWH.
04:37:23 <elliott> cmccann! hi!
04:37:40 <cmccann> y helo thar
04:37:51 <shachaf> hi cmccann
04:38:20 <cmccann> hi shachaf
04:38:35 <cmccann> you know its not like I haven't been idling in channel basically every day
04:38:58 <shachaf> You haven't been?
04:39:52 <elliott> you need to idle more loudly.
04:39:57 <elliott> what if we gave you voice?
04:39:57 <cmccann> it's certainly not the case that I haven't failed to be idling here
04:40:01 <shachaf> s/n't//
04:40:17 <shachaf> cmccann: We "seen"ed you the other day and the last you'd spoken was a month ago about not doing my work for me.
04:40:28 <cmccann> I suppose I could make fun of elliott at inopportune times now and then
04:40:29 <shachaf> So I imagine you haven't gotten a whole lot of it done over the past month.
04:40:52 <cmccann> no, I've been too busy doing my own work to not do yours.
04:41:11 <shachaf> Oh, so you did mine?
04:41:30 <cmccann> nah. I just didn't not do it. totes different.
04:41:42 <cmccann> intuitionism yo.
04:43:07 <kryft> I never did like the law of excluded middle
04:43:25 <kryft> You can get weird nilpotent infinitesimals without it!
04:43:47 <cmccann> we should use the law of the included middle instead.
04:46:09 <neolax> :t last
04:46:10 <lambdabot> [a] -> a
04:46:17 <neolax> > last [1,2,3]
04:46:18 <lambdabot>   3
04:46:21 <neolax> good :)
04:46:24 <cmccann> > last []
04:46:25 <lambdabot>   *Exception: Prelude.last: empty list
04:46:27 <cmccann> not good :(
04:47:18 <neolax> cmccann: :D
04:47:53 <elliott> cmccann: I removed NumInstances. as a present.
04:47:57 <elliott> I also removed lens as a punishment.
04:48:13 <shachaf> elliott giveth and elliott taketh away
04:48:16 <cmccann> I'm not sure that counts as a punishment.
04:48:18 <shachaf> But really elliott just taketh away
04:48:47 <kryft> shachaf: well elliott doth give advice on occasion, so there's that
04:49:03 <cmccann> I'm not sure elliott's advice counts as advice.
04:57:48 <aranea> Hi. I'm returning to Haskell after a longer break. Can't that be done more elegantly? arg <- listToMaybe <$> getArgs; cwd <- getCurrentDirectory; let dir = fromMaybe cwd arg;
04:59:38 <elliott> perhaps you will find fromMaybe <$> getCurrentDirectory <*> (listToMaybe <$> getArgs) more elegant
04:59:41 <cmccann> you could do something like "fromMaybe <$> getCurrentDirectory <*> (listToMaybe <$> getArgs)"
04:59:51 <elliott> cmccann: you are fired.
04:59:51 <cmccann> but that's not really more elegant to my eye
05:01:06 <cmccann> elliott: >:[
05:01:10 <aranea> thanks, I was just trying to remember all this haskell magic :)
05:01:24 <FreeFull> Is it bad that most of the time I use hlint, it has no suggestions?
05:01:54 <cmccann> it's bad if most of the time you use elliott and he has no suggestions.
05:02:18 <Peaker> aranea, I dislike listToMaybe on getArgs, your users may be confused
05:02:50 <shachaf> Peaker: Do you always type "ls ."?
05:03:09 <Peaker> I'm not complaining about 0 args, but about N>1 args
05:04:36 <aranea> Peaker: atm the program is only for myself, and I'll add a usage info later
05:04:55 <aranea> it wouldn't make much sense to use multiple dirs here
05:05:58 <cmccann> the main problem with listToMaybe is that it should be named "head".
05:06:06 <aranea> yeah, full ack
05:06:12 <FreeFull> headMaybe
05:06:32 <shachaf> aranea: Explicit case might be the simplest.
05:06:39 <shachaf> args <- getArgs
05:07:03 <shachaf> name <- case args of [] -> ...; [x] -> ...; _ -> ...
05:07:04 <cmccann> I probably would use the case expression personally.
05:07:05 <shachaf> Or something.
05:07:23 <cmccann> I think it's clearest for this scenario.
05:07:35 <aranea> yes, that's right
05:07:36 <cmccann> instead of listToMaybe and fromMaybe
05:12:46 <aranea> how to check if a list ends in a specific pattern?
05:12:57 <aranea> I want to get all tar files from my directory
05:13:41 <shachaf> :t isSuffixOf
05:13:42 <lambdabot> Eq a => [a] -> [a] -> Bool
05:14:37 <aranea> thanks
05:15:02 <neolax> no dropLast?
05:15:07 <neolax> :t dropLast
05:15:08 <lambdabot> Not in scope: `dropLast'
05:15:18 <neolax> i'll go with reverse then :/
05:15:29 <shachaf> > init "watch out with empty lists!"
05:15:32 <lambdabot>   "watch out with empty lists"
05:15:35 <shachaf> @where sneaky
05:15:36 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
05:15:57 <neolax> ow thanks :)
05:18:29 <benmachine> aranea: if you want to get all tar files in a directory, there are functions from (iirc) System.FilePath to help you with that
05:20:59 <aranea> benmachine: there's  the Glob package (System.FilePath.Glob), I just didn't want to install that
05:21:15 <FreeFull> Oh, that's actually a pretty clever definition
05:21:29 <FreeFull> I wonder if it only traverses the list once
05:21:36 <benmachine> aranea: I was thinking of takeExtension
05:22:21 <aranea> Ah, System.FilePath.Posix
05:22:29 <aranea> yeah, you're right
05:22:32 <benmachine> re-exported in System.FilePath
05:23:10 <benmachine> I think the idea is you use the functions in System.FilePath so that when a windows user uses your program it uses the other functions instead
05:23:17 <aranea> isSuffixOf ".tar" is still shorter
05:23:30 <benmachine> that's true
05:23:32 <aranea> and it's also portable
05:23:37 <benmachine> but imo takeExtension is clearer
05:23:59 <aranea> yeah, sure, but I'm lazy ;)
05:24:07 <benmachine> :P as you wish
05:24:16 <benmachine> System.FilePath is portable
05:26:30 <isomorphic> Is passing a value wrapped in Maybe into a function a bad sign - eg: does one avoid passing wrapped values in any particular situations?
05:27:16 <benmachine> isomorphic: it depends
05:27:17 <circle>  say I have a function that takes 2 arguments, a number and a list. say I want to map this function onto a list with a constant number as an argument, but in the function profile, the number comes last. what do I do?
05:27:37 <benmachine> isomorphic: if you have a function Maybe a -> Maybe b and Nothing always returns Nothing, then I'd say yeah, that's bad
05:27:45 <benmachine> just write a -> Maybe b and let people =<< it
05:28:46 <isomorphic> benmachine:  I think that might be my situation.    It's odd how the syntax being odd for something can tip you off ;)
05:29:24 <mauke> :t flip
05:29:25 <lambdabot> (a -> b -> c) -> b -> a -> c
05:29:26 <benmachine> isomorphic: there are perfectly legitimate reasons to take Maybe as a parameter, e.g. optional parameters
05:29:28 <mauke> circle: ^
05:29:47 <benmachine> but if the Nothing behaviour is somehow trivial it might be better to just exclude it
05:29:48 <circle> mauke: what?
05:30:00 <mauke> > flip f x y :: Expr
05:30:01 <lambdabot>   f y x
05:30:19 <mauke> map (flip f 42)
05:30:28 <circle> ah, thanks
05:30:34 <benmachine> alternatively you can just use an explicit lambda
05:30:39 <benmachine> \xs -> flip xs 42
05:30:51 <mauke> map (\x -> f x 42)
05:30:57 <benmachine> which is better depends on various mostly aesthetic concerns
05:31:02 <mauke> map (`f` 42)
05:31:04 <FreeFull> You can also do   map (`f` 42)
05:31:10 <FreeFull> Damn, mauke beat me to it
05:31:59 <shachaf> Using (??) = flip, you can say: map (f ?? 42)
05:32:02 <shachaf> Where the ?? is a "hole"
05:32:49 <circle> do you just apply flip to the function if applying map, or do you apply flip to the function and the constant argument you have with it
05:32:49 <neolax> :t writeFile
05:32:50 <lambdabot> FilePath -> String -> IO ()
05:33:00 <mauke> using scheme, you can say (map (cut f <> 42) xs)
05:33:01 <neolax> good :)
05:33:55 <mauke> using common lisp, you can say (mapcar #'(lambda (x) (funcall f x 42)) xs)
05:34:05 <mauke> circle: what do you mean?
05:34:09 <mauke> (example?)
05:34:12 <circle> nevermind, figured it out
05:34:20 <shachaf> My general recommendation is never to apply flip.
05:34:25 <circle> shachaf: why?
05:34:33 <shachaf> Because it makes for confusing code.
05:34:49 <shachaf> The code will be clearer if you use a lambda.
05:34:55 <circle> it's clear in my example
05:34:59 <circle> or my code
05:35:17 <Peaker> trying to run the guihaskell package, I get: guihaskell: user error (Pattern match failure in do expression at Graphics/UI/Gtk/MenuComboToolbar/ComboBox.chs:244:3-14). Bah.
05:35:17 <acube> shachaf: Even in cases like flip someFunction someHandler $ do ... ?
05:35:40 <luite_> hmm, yeah, flip evalState and similar is one of the few cases where i use it
05:35:41 <shachaf> circle: I suspect that that's not true, from the perspective of someone reading your code.
05:35:57 <Peaker> there's probably no warning about such either, because pattern matching in do blocks is so happy to "fail" over :(
05:35:57 <circle> how would I use a lambda to do it?
05:35:58 <shachaf> I much prefer (`runFoo` x) $ ...
05:36:05 * shachaf is pretty strongly biased against flip.
05:36:16 <mauke> <mauke> map (\x -> f x 42)
05:36:18 <shachaf> circle: As benmachine and mauke said above.
05:36:42 <circle> oh, okay
05:36:47 <luite_> shachaf: tbh that's not less confusing
05:36:49 * acube likes to avoid parentheses
05:37:34 <shachaf> luite_: It's somewhat less confusing to me but I agree this is an edge case with no great answer.
05:39:30 <mauke> flip `flip` 42 $ f
05:39:41 <acube> That's confusing
05:39:42 <luite_> hmm, i think we need an objective measure of confusingness
05:40:13 <acube> @let import Control.Lens.Combinators
05:40:15 <lambdabot>  Defined.
05:40:27 <acube> @ty \f -> flip ?? 32 $ f
05:40:28 <lambdabot> Num b => (a -> b -> c) -> a -> c
05:40:59 * acube likes how (??) looks like it's making a hole there, which will be filled later
05:41:12 <shachaf> It is an imperfect analogy but it does.
05:41:22 <acube> @ty (??)
05:41:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
05:42:05 <mauke> @ty \f -> f & flip ?? 42
05:42:06 <lambdabot> Num a => (a -> b -> c) -> b -> c
05:42:41 <acube> why is the type different from my type?
05:42:43 <acube> @ty \f -> flip ?? 32 $ f
05:42:43 <lambdabot> Num b => (a -> b -> c) -> a -> c
05:43:15 <elliott> precedence
05:43:48 <acube> @ty \f -> (f & flip) ?? 42
05:43:48 <lambdabot> Num a => (a -> b -> c) -> b -> c
05:44:42 <isomorphic> @hpaste
05:44:42 <lambdabot> Haskell pastebin: http://hpaste.org/
05:44:44 <acube> @ty \($ 42)
05:44:44 <lambdabot> Parse error in pattern: $ 42
05:44:48 <acube> @ty ($ 42)
05:44:48 <lambdabot> Num a => (a -> b) -> b
05:46:53 <mauke> :t map . ($ 42) . flip
05:46:54 <lambdabot> Num a1 => (a -> a1 -> b) -> [a] -> [b]
05:47:37 <mauke> :t (<$>) <$> (`ask` 42) <$> (??)
05:47:38 <lambdabot> (Functor f, Num a1) => (a -> a1 -> b) -> f a -> f b
05:47:54 <acube> @ty ask
05:47:55 <lambdabot> MonadReader r m => m r
05:48:45 <hpaste> “_justjust” pasted “netwire bouncing ball” at http://paste.tryhaskell.org/90720
05:48:50 <mauke> :t ask `asTypeOf` asks
05:48:50 <lambdabot> (r -> a) -> r -> a
05:49:19 <_justjust> how can i make the object bounce at pos == 0? in my nertwire paste above
05:49:22 <benmachine> :t asks `asTypeOf` ask
05:49:23 <lambdabot> (r -> a) -> r -> a
06:00:07 <circle> I'm having a problem discovering the source of an error
06:00:11 <circle> http://pastebin.com/frvwvYkh
06:00:14 <mauke> The paste frvwvYkh has been copied to http://paste.tryhaskell.org/90721
06:00:18 <circle> there's a code exercpt, and the rror that was thrown
06:01:06 <mauke> a b : c means (a b) : c
06:01:53 <circle> huh?
06:02:07 <mauke> Node (a, b) x : xs means (Node (a, b) x) : xs
06:02:40 <circle> ahh
06:02:42 <circle> how would I fix that
06:02:47 <mauke> (x : xs)
06:03:45 <circle> ah, thank you
06:08:15 <acube> Is :.: from GHC.Generics ever used by a representation generated with Rep?
06:25:33 <hpaste> circle pasted “t” at http://paste.tryhaskell.org/2154706533156388864
06:25:45 <circle> so what's the problem there?
06:25:47 <circle> the error is pasted
06:26:01 <circle> it's claiming I'm returnig the wrong type
06:26:04 <circle> I just can't see how
06:26:12 <shachaf> Is this homework, by the way?
06:27:10 <circle> not really relevant
06:27:43 <shachaf> OK.
06:27:51 <circle> any ideas shachaf ?
06:28:04 <fryguybob> circle: What is the type of  map ((flip f) (n - 1)) xs  ?
06:28:38 <circle> [[Tree (Bank, Bank)]
06:28:39 <shachaf> I was going to help if you'd said either yes or no. But I suppose I excluded the middle.
06:28:56 <shachaf> So I guess someone else will help.
06:29:01 <augur_> shachaf: serves you right for being classical!
06:29:10 <fryguybob> circle: Ok, what is the type of  [map ((flip f) (n - 1)) xs]  ?
06:29:39 <circle> ahhhh
06:29:56 <circle> it's [[Tree (Bank, Bank)]]
06:31:20 <circle> thanks fryguybob
06:42:12 <Ghoul_> Anyone know any good projects that use trifecta for language parsing
06:47:54 <Fuuzetsu> circle: Why not just Tree Bank Bank? Not much need for a tuple, is there?
06:58:16 <_justjust> why is input not in scope in: proc input -> do {y <- foo input -< 1}?
07:05:08 <haasn> _justjust: afaik the calculations (foo input) can't depend on locally bound arrow variables
07:05:21 <haasn> that would require a monad
07:05:38 <haasn> but you could instead do y <- foo -< (input, 1)
07:08:11 <_justjust> haasn: ok thanks
07:13:27 <Eduard_Munteanu> Is there any way to flush FDs from System.Posix.IO?
07:13:56 <Eduard_Munteanu> Maybe I could set O_SYNC on it, but there might be a better way.
07:16:06 <luite_> Eduard_Munteanu: hmm, i suspect not, since cautious-file imports it itself
07:16:43 <Eduard_Munteanu> Hm, I see. I guess O_SYNC does then.
07:17:34 <benmachine> you could try hFlush . fdToHandle
07:17:47 <benmachine> but that sounds unguaranteed to work
07:18:10 <lcamel> Which section of the "Haskell 2010 Language Report" describes the dynamic semantic of function application ?
07:20:19 <namoamitabuddha> What's the use of `(->) r' monad?
07:20:45 <Eduard_Munteanu> namoamitabuddha: it's Reader
07:21:00 <namoamitabuddha> Eduard_Munteanu: ?
07:21:32 <Eduard_Munteanu> @src Reader
07:21:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:21:58 <Chousuke> namoamitabuddha: you can use it to compose functions that all take the same first argument
07:22:06 <haasn> LYAH has a chapter on Reader that covers a few examples http://learnyouahaskell.com/for-a-few-monads-more#reader
07:22:18 <Chousuke> the usual example is global configuration
07:22:39 <isomorphic> Which paste should we use while hpaste is down?
07:22:51 <shanse> @where hpaste
07:22:52 <lambdabot> http://paste.tryhaskell.org/new/haskell
07:22:56 <namoamitabuddha> Is there any contrafunctor?
07:23:04 <isomorphic> shanse:  Thanks :)
07:24:01 <stopm> haskell is a piece of shit
07:24:30 <bitonic> @where ops
07:24:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
07:24:30 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:24:39 <stopm> @where ops
07:24:39 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
07:24:39 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:24:41 --- mode: ChanServ set +o copumpkin
07:24:41 <stopm> @where ops
07:24:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
07:24:41 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:24:44 --- mode: copumpkin set +b stopm!*@*
07:25:04 <Philippa> that's no way to tak about the Peyton-Jones' cat!
07:25:20 <mcstar> he means the cat shit somehting... give him a break
07:25:43 <Clint> did the 'm' stand for "monads"
07:26:29 <namoamitabuddha> Clint: usually
07:26:39 <Philippa> mcstar: the past tense is "shat", as in "the cat shat on the mat" :-)
07:26:56 --- mode: copumpkin set -o copumpkin
07:27:05 <Eduard_Munteanu> Maybe he meant "Haskell is *the* shit". :P
07:27:19 <bitonic> *the* piece of shit
07:27:38 <mcstar> i wonder what could have made him so angry to come and tell us
07:28:02 <circle> I just can't see how
07:28:22 <ion> FWIW, just ignoring the troll silently would likely have resulted in less distraction on the channel.
07:28:23 <Eduard_Munteanu> mcstar: not only, but seeing idoru earlier, I guess he said that to other channels too
07:29:03 <benmachine> namoamitabuddha: newtype Op a b = Op (b -> a) has (Op r) a contrafunctor
07:29:19 <mcstar> Philippa: i will use shtako in the future...
07:29:30 <benmachine> (probably a bad name, but I made one up on the spot)
07:29:47 <benmachine> more generally, many things that are notionally a function into something are contrafunctors
07:29:55 <mcstar> (im not sure you get the reference... it's from a scifi show)
07:30:00 <Philippa> ion: it seemed moderately quiet or I wouldn't have cracked the joke, yeah
07:30:28 <ion> philippa: I was referring to the “@where ops”.
07:30:32 <namoamitabuddha> benmachine: I mean, is there facilities of contrafunctor in haskell? Another example: the pullback.
07:30:52 <Philippa> ion: the first one was bitonic making sure someone was handy to k/b. The others were the troll
07:31:00 <benmachine> namoamitabuddha: ah, maybe you're interested in http://hackage.haskell.org/package/contravariant
07:31:13 <ion> philippa: I know. What i said still stands. :-)
07:31:21 <Philippa> we weren't to know an oper'd get involved, after all?
07:31:54 <namoamitabuddha> benmachine: Seems good. A random question only.
07:32:10 <benmachine> namoamitabuddha: I don't know about pullbacks, that sounds difficult
07:32:29 <copumpkin> pullbacks are more dependent typey
07:32:33 <benmachine> I asked a question on SO about whether or not haskell had equalisers
07:32:35 <copumpkin> you'd want a language like idris or agda for it
07:32:45 <benmachine> I'm yet to find convincing evidence it doesn't
07:32:55 <benmachine> so it kind of has pullbacks
07:32:58 <benmachine> but perhaps not generically
07:33:14 <copumpkin> benmachine: what would you consider an equalizer in haskell?
07:33:55 <namoamitabuddha> Pullback is a fundamental concept in mathematics. I don't think it pervasive in programming.
07:34:10 <hpaste> isomorphic pasted “IO + Maybe” at http://paste.tryhaskell.org/5707978284747194368
07:34:16 <copumpkin> namoamitabuddha: the closest common progrmaming concept that's basically a pullback is a relational join
07:34:31 <benmachine> copumpkin: just a function satisfying the relevant universal property
07:34:42 <copumpkin> oh well sure
07:34:55 <copumpkin> but most CT talk in haskell is about stuff the type system roughly gives you in some form or another
07:35:18 <isomorphic> ^-- so, I've been trying to figure out the best way to combine Maybe and IO in the paste - the purpose of the code is to get a heap of data out of some C structs and make a regular haskell data type
07:36:16 <benmachine> copumpkin: what do you mean?
07:36:32 <isomorphic> Can anybody suggest an elegant way to do it?
07:37:56 <copumpkin> benmachine: nothing particularly special about haskell having equalizers in that sense. python might too! take for example products in haskell, whose laws are all basically satisfied, too
07:38:06 <copumpkin> due to types
07:38:20 <copumpkin> or natural transformations
07:38:37 <namoamitabuddha> natural transformations?
07:38:53 <benmachine> copumpkin: in the question, I got lots of people trying to find two functions whose equaliser was not r.e. or some such
07:39:06 <benmachine> maybe I should have just tried to work that out directly
07:39:32 <benmachine> copumpkin: but also I'd had discussions in #agda about whether or not agda was cartesian
07:39:44 <benmachine> whether or not agda had finite limits
07:39:59 <ion> isomorphic: MaybeT?
07:40:02 <benmachine> (cartesian is a silly word. never define a word for a concept you can express in like three more words)
07:40:11 <copumpkin> :)
07:40:18 <copumpkin> I'd expect the answer is yes?
07:41:32 <isomorphic> ion:  Perfect, looking it up now, thanks :)
07:41:50 <benmachine> copumpkin: some people thought yes, some people thought no, iirc
07:42:05 <benmachine> copumpkin: I would expect yes too, but I don't really know how the category of agda types works
07:42:19 <benmachine> like, do morphisms have to be non-dependent functions?
07:42:43 <benmachine> or are they all "automatically dependent" and non-dependent functions are just morphisms from A to const B
07:43:49 <ion> isomorphic: Use “liftIO foo” for “foo :: IO a” where a is not a Maybe value and “MaybeT bar” for “bar :: IO (Maybe a)” where you want the entire computation to fail upon a Nothing.
07:46:48 <Saizan> benmachine: in categories the Agda one has non-de16:38  namoamita : natural transformations?pendent functions as morphisms
07:46:51 <Saizan> 16:38  namoamita : natural transformations?
07:47:09 <ion> Yes, i16:38  namoamita : natural transformations?ndeed.
07:47:18 <wallmani> > 12+34
07:47:19 <lambdabot>   46
07:47:46 <wallmani> > :t 1337
07:47:47 <lambdabot>   <hint>:1:1: parse error on input `:'
07:47:56 <wallmani> :(
07:47:58 <ion> :t 1337
07:47:59 <lambdabot> Num a => a
07:48:07 <wallmani> ah
07:48:16 <benmachine> Saizan: makes sense, I suppose
07:49:20 <benmachine> yeah, that sounds more plausible than the other idea
07:49:43 <benmachine> (the other idea would require "const B" being an object in its own right, and then one would have to wonder what a function from it would mean)
07:51:57 <Saizan> 16:39  copumpkin : :)
07:52:01 <Saizan> 16:39  copumpkin : :)
07:52:31 <copumpkin> o.O
07:53:32 <acube> Why doesn't repa's Elt class have an instance (Elt a) => Elt [a] ?
07:54:15 <copumpkin> acube: someone needs to come up with a good unpacked representation for it
07:54:25 <copumpkin> and [a] has odd properties
07:54:41 <acube> So I cannot use repa for 2D arrays of strings? :/
07:54:45 <isomorphic> ion:  Thanks :)
07:55:01 <Saizan> what have i done?
07:55:08 <copumpkin> acube: storing strings is tricky!
07:55:10 <Saizan> anyhow, sorry.
07:55:13 <jmcarthur> acube: if they are fixed length you can. if they are not, maybe you still can, but it sounds harder
07:55:14 <copumpkin> they're not going to be unboxed
07:55:42 <jmcarthur> ah right, or they will just be boxed, which maybe is good enough
07:55:48 <copumpkin> jmcarthur: omg that's a cute property of vector-static
07:56:00 <copumpkin> vectors of homogeneous vectors make sense!
07:56:04 <jmcarthur> copumpkin: :)
07:56:15 <copumpkin> if only someone had written that
07:56:22 <jmcarthur> yeah static length vectors are unboxable
07:56:26 <acube> copumpkin: But I can't use foldS then
07:56:50 <jmcarthur> not unboxable in a very nice way, though, for larger lengths
07:56:56 <copumpkin> yeah
07:57:07 <jmcarthur> since the Unbox style is struct of arrays rather than array of structs
07:57:09 <copumpkin> we need more control over locality anyway
08:02:43 <exFalso1> hi, are shared MVars safe to use in a forkProcess'd process?
08:03:30 <exFalso1> or in other words can mvars be used for ipc?
08:06:58 <benmachine> exFalso1: don't think so
08:07:09 <benmachine> pretty sure they're process-local
08:07:43 <exFalso1> benmachine: thanks
08:08:29 <nschoe> Hi everyone, since ltk (used by leksah) seems not to be installable via cabal for now, I cloned the github repo and tried to build from here. But when I run 'runhaskell Setup.lhs configure' I get error 'at least the following dependencies are missing : glib >=0.10.0 && ,0.13" (some others) but when I do 'cabal install glib' it tells me that glib 0.12.4 is already installed. Is it possible that my ~/cabal/lib is not in the Setup.lhs PATH ? and i
08:08:29 <nschoe> f so, could someone tell me how to add it, please ?
08:10:39 <hamishmack> nschoe: For now you could follow the steps described here… https://github.com/leksah/leksah/blob/master/.travis.yml
08:11:26 <nschoe> thanks hamishmack , I'll try this !
08:12:12 <hamishmack> nschoe: Here is what it looks like in action… https://travis-ci.org/leksah/leksah/builds/8816554
08:12:20 <benmachine> nschoe: runhaskell Setup.hs defaults to global installs, so won't have access to your user-installed stuff
08:12:27 <benmachine> you could try using --user
08:14:01 <nschoe> okay, I'll try with the --user flag
08:17:14 <nschoe> How it seems to improve, now it is "gtk >=0.12.4.1 && <0.13 || >=3.12.4.1 && <3.13" that is missing, bt 'cabal install gtk' gives me "All the requested packages are already installed: gtk-0.12.4". So ... how do I get gtk-0.12.4.1 ?
08:17:38 <hamishmack> DId you use cabal-meta to install it?
08:18:07 <hamishmack> If you clone the leksah repo and follwo the steps in the .travis.yml
08:18:26 <hamishmack> it should install gtk as part of the build
08:19:05 <nschoe> ho actually I did not try yet the instructions on travis.yml, I wanted to try adding the --user flag before, in case it worked "just like that"
08:20:59 <nschoe> what is this cabal-meta thing, if I may ask ?
08:21:29 <hamishmack> nschoe: https://github.com/yesodweb/cabal-meta
08:21:50 <nschoe> yeah sorry, actually reading that page ^^
08:22:34 <nschoe> I'll try the travis.yml file then.
08:29:11 <lcamel> where in the Haskell Report can i find the dynamic semantic of (\x -> x + 2) 3  =>  3 + 2  ?
08:29:24 <satc> I was wondering how to actually perform some computation in TH. suppose I want to perform some function `foo :: String -> String -> String ` at compile time. What I did was wrote a function like `fooTH :: ExpQ -> ExpQ -> ExpQ` `fooTH x y = [| $(x) `foo` $(y) |]. But what it does is generate code actually containing foo. I want actually to replace that with the result of running foo on parameters.
08:31:52 <acube> satc: have you tried fooTH :: String -> String -> ExpQ; fooTH x y = stringE $ foo x y?
08:32:19 <int-e> lcamel: it's somewhere between the lines :)
08:34:15 <lcamel> int-e: i feel painful when i can't find some definitions in the spec :)
08:35:52 <satc> acube: Thanks. I was missing this. I think if you have ExpQ then you can not do this.
08:36:55 <acube> satc: Why do you want to take an ExpQ anyway? Do you want to apply "foo" on the source generated by ExpQ?
08:42:20 <mikeplus64> @hoogle (a -> b -> m c) -> m a -> m b -> m c
08:42:20 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:42:20 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
08:42:20 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:43:07 <Fuuzetsu> :t liftM2
08:43:08 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:44:26 <mikeplus64> i'll just use normal monadic stuff, it's nicer than join (liftMx ...)
08:45:22 <ion> It would be nice to have bind2, bind3 in Control.Monad.
08:45:39 <Fuuzetsu> call it >>>= and >>>>=
08:45:58 <tikhonjelvis> infix operators are not happy with three or four argument functions, usually
08:46:13 <ion> Especially with = on the right. :-P
08:46:30 <ion> (a >>>= f) b
08:46:55 <acube> @hackage plumbers
08:46:55 <lambdabot> http://hackage.haskell.org/package/plumbers
08:47:10 <mikeplus64> D:
08:47:14 <acube> Lots of functions for you :P
08:47:41 <tikhonjelvis> hmm
08:48:01 <ion> This is worse than lens :-D
08:48:11 <ion> http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/Control-Plumbers.html
08:48:14 <tikhonjelvis> or better, as the case may be
08:54:21 <erisco> how can I debug a stack overflow error? I know it is because I am forcing evaluation of an infinite list, but I am not sure how I am doing so
08:56:07 <meretrix`> Hi. With hslogger, how can I get the default root LogHandler?  I can get the root Logger, but I see no function of type "Logger -> LogHandler".
08:56:10 <Fuuzetsu> http://www.haskell.org/haskellwiki/Debugging
08:56:29 <erisco> yeah I didn't really find what would help on that list
08:56:51 <Fuuzetsu> erisco: There's debugging help on GHC pages too which is a lot more comprehensive
08:57:12 <Fuuzetsu> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/ghci-debugger.html
08:57:16 <tikhonjelvis> erisco: Are you familiar with the GHCi debugger?
08:57:56 <tikhonjelvis> you can set a breakpoint in the function where you think you have a problem
08:58:03 <tikhonjelvis> and explore from there
08:58:19 <tikhonjelvis> I usually just use :help in GHCi, which gives a list of possible commands
09:03:48 <erisco> tikhonjelvis, yeah I dunno. I don't know where it is occurring so I don't know where to set a break
09:05:11 <tikhonjelvis> You can try setting a breakpoint in the main function and just stepping through the code
09:05:30 <tikhonjelvis> or just make a good guess about where it *can't* have happened yet,  and put the breakpoint there
09:05:48 <erisco> tikhonjelvis, I do that and it doesn't break
09:05:54 <erisco> just hangs
09:06:07 <tikhonjelvis> hmm
09:06:33 <tikhonjelvis> maybe try evaluating your expression using :trace?
09:06:42 <tikhonjelvis> I've never done that myself, but it sounds useful
09:06:54 <erisco> I tried that but still hangs
09:06:59 <erisco> not sure what is going on
09:07:45 <yitz> erisco: it usually happens because you are *not* forcing the evaluation of the elemenst of the list
09:08:09 <erisco> yitz, my stack couldn't possibly be that deep
09:08:34 <erisco> well, I certainly don't see how ... I know I have a potentially infinite list so I presume it is that
09:09:33 <yitz> > sum [1..1000000] -- without -O optimization, the partial sums are not evaluated
09:09:35 <lambdabot>   *Exception: stack overflow
09:10:00 <acube> > foldl' (+) 0 [1..100000000]
09:10:03 <lambdabot>   mueval-core: Time limit exceeded
09:10:05 <yitz> so you build up a huge list of unevaluated sum operations instead of adding up as you go
09:10:05 <acube> > foldl' (+) 0 [1..1000000]
09:10:06 <lambdabot>   500000500000
09:10:09 <erisco> yeah I get that but my input is of length 6
09:10:28 <yitz> erisco: how about pasting your code?
09:10:32 <yitz> @where hpaste
09:10:32 <lambdabot> http://paste.tryhaskell.org/new/haskell
09:10:43 <erisco> well I could but its 90 lines or so
09:11:11 <erisco> http://paste.tryhaskell.org/90723
09:11:41 <erisco> I don't know how to get eyeballs on what Haskell is actually doing =\
09:13:38 <erisco> maybe I broke gchi it is behaving oddly... will restart
09:14:05 <erisco> ah now it breaks at main =\
09:14:28 <Fuuzetsu> What's your input?
09:14:46 <yitz> erisco: how big can nChain be?
09:15:02 <erisco> yitz, it is infinite
09:15:06 <erisco> as far as I can tell
09:15:16 <FreeFull> yitz: If you are trying to find a sum within a certain range, I think there is a formula that will give you the result much quicker than actually summing all the numbers
09:15:29 <erisco> debugging with ghci using :step is quite opaque... no idea what is being evaluated currently
09:15:36 <yitz> erisco: it never makes sense to use foldr with (+) (well almost never)
09:15:37 <erisco> all you get is some type sig?
09:16:13 <erisco> yitz, ah .... foldr starts at the right doesn it
09:16:26 <yitz> erisco: also, \> looks suspicious. Maybe make the viewLength field of ListView strict, i.e. !Int instead of Int.
09:16:31 <yitz> yes
09:16:49 <yitz> erisco: you probably want foldl'
09:17:00 <yitz> i.e. start at the left and force the partial sums
09:17:21 <yitz> i.e. exactly what acube was showing you :)
09:19:18 <erisco> having a tough time finding what module foldl' is in
09:19:35 <erisco> ah might have it :)
09:19:43 <acube> @index foldl'
09:19:43 <lambdabot> Data.List
09:20:04 <acube> erisco: ^^
09:20:11 <erisco> is lambdabot a crucial component in the Haskell tool chain?
09:20:20 <tikhonjelvis> hah, not really
09:20:25 <tikhonjelvis> but you can install it locally if you want
09:20:45 <acube> @hoogle foldl'
09:20:45 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
09:20:45 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
09:20:45 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
09:20:49 <tikhonjelvis> or just have hoogle locally
09:20:59 <acube> Or use hayoo
09:21:00 <tikhonjelvis> I just get by using hoogle online
09:21:02 <acube> :D
09:21:03 <tikhonjelvis> eh
09:21:04 <tikhonjelvis> eh
09:21:06 <erisco> :t foldl
09:21:07 <lambdabot> (a -> b -> a) -> a -> [b] -> a
09:21:12 <erisco> oh have to swap my args now
09:22:01 <erisco> I think?
09:22:05 <erisco> :t foldr
09:22:05 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:23:03 <erisco> but... why is my accumulator different like that :s confused
09:24:11 <erisco> oh, nChain isn't infinite, sorry, just chain is
09:24:26 <FreeFull> > foldr f a [b,c,d,e,f]
09:24:26 <lambdabot>   f b (f c (f d (f e (f f a))))
09:24:47 <FreeFull> > foldl f a [b,c,d,e]
09:24:48 <lambdabot>   f (f (f (f a b) c) d) e
09:24:53 <FreeFull> > foldr f a [b,c,d,e]
09:24:54 <lambdabot>   f b (f c (f d (f e a)))
09:25:20 <erisco> >foldr sum [1..10]
09:25:27 <erisco> > foldr sum [1..10]
09:25:28 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
09:25:28 <lambdabot>    arising from a use ...
09:25:32 <FreeFull> > [a..f]
09:25:33 <lambdabot>   *Exception: not a number
09:25:46 <erisco> > foldl sum [1..10]
09:25:47 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = b0 -> [a0]
09:25:47 <lambdabot>  Expected...
09:25:51 <FreeFull> > [a..f] :: [Expr]
09:25:52 <lambdabot>   *Exception: not a number
09:25:56 <FreeFull> > [0..10] :: [Expr]
09:25:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
09:25:58 <erisco> oh sum is on a list
09:26:02 <erisco> hurr durr
09:26:38 <FreeFull> @src sum
09:26:38 <lambdabot> sum = foldl (+) 0
09:29:06 <erisco> so I can't change my foldr to a foldl? can't make sense of this
09:29:31 <erisco> I thought it was the same thing different associativity
09:30:32 <erisco> actually I don't even know how my foldr was even working in the first place... the accumulator takes two args and mine was only taking one??
09:30:39 <erisco> gah I hate these growing pains -.-
09:31:44 <FreeFull> It's possible to implement foldr in terms of foldl and vice versa
09:32:15 <erisco> well I still have a stack overflow but I rewrote using foldl'
09:32:22 <erisco> hmm
09:32:36 <erisco> guess I will try the :step thing though again, it doesn't show corresponding source, so really opaque
09:33:25 <tikhonjelvis> maybe try combining :set and :trace?
09:33:37 <erisco> whaaa.... ghci won't set a break on main again -.- says "module Main is not interpreted"
09:33:43 <latro`a> it's not the same thing with different associativity
09:33:55 <copumpkin> erisco: keep in mind that foldl' isn't just a magic bullet
09:33:57 <latro`a> especially for non-strict folding functions
09:33:59 <copumpkin> if you're accumulating a pair
09:34:04 <copumpkin> then foldl' will do nothing
09:34:18 <FreeFull> Well, you can use foldl' combined with making the pair strict
09:34:33 <copumpkin> FreeFull: in haskell you can write foldl in terms of foldr, but you can't get the full functionality of foldr from foldl
09:34:34 <erisco> copumpkin, was just a shot in the dark. what do you mean accumulating a pair?
09:34:50 <FreeFull> copumpkin: Yeah, because of infinite lists
09:34:54 <copumpkin> erisco: say you're folding and keeping track of the sum and length separately
09:35:03 <dolio> Is the code you pasted the code that's overflowing?
09:35:04 <copumpkin> you might be tempted to use a pair as your accumulator
09:35:09 <dolio> Parsing 6 'a's?
09:35:45 <erisco> yeah I'm trying to get ghci working again =\
09:35:54 <erisco> copumpkin, why does the type of the acc matter/
09:36:07 <stacky> foldl' will only evaluate its accumulating parameter to the outermost constructor
09:36:10 <copumpkin> I'm just saying be aware of what the foldl' is actually doing
09:36:33 <stacky> so if you're using a tuple, it'll evaluate to the tuple constructor, but none of its components
09:37:13 <dolio> I'm skeptical that you're working with anything big enough for your choice of fold to matter.
09:37:35 <erisco> weird... when I use foldl' I can't set a breakpoint on main
09:37:45 <erisco> maybe to do with the imported module Data.List? *shrug*
09:38:09 <FreeFull> erisco: To get rid of the not interpreted thing, you have to delete the executable
09:38:49 <FreeFull> Although GHCi might have some way to import it interpreted thing anyway
09:38:58 <dolio> erisco: Have you successfully run this on an even smaller example?
09:39:10 <erisco> I specified ".hs" and also it started working again after I reverted the foldl' changes... dunno seems odd
09:39:13 <erisco> exe is still there
09:39:47 <erisco> dolio, I have successfully run it when not using a self-referential parser
09:40:03 <dolio> Okay.
09:40:09 <erisco> I am expecting it to run out of input and stop, but something keeps going :)
09:40:13 <Saizan> specifying .hs doesn't help, changing the file helps because the compiled version will be obsolete
09:40:24 <erisco> mod times?
09:40:27 <Saizan> yeah
09:40:39 <Saizan> ":load *foo.hs" should work regardless
09:40:42 <erisco> I hate that kind of black magic stuff =\
09:41:30 <erisco> programming version of spooky action at a distance I reckon
09:41:39 <pentace> Saizan: What does the * indicate there?
09:41:47 <dolio> I think people have been giving you advice on parts of your program that are not causing the error.
09:42:11 <Saizan> pentace: just tells ghci to ignore compiled versions
09:42:27 <pentace> ah
09:42:28 <erisco> if these steps were not so hard to read =\
09:44:57 <erisco> I don't particularly know what I am supposed to make of things. there is this _result type that keeps changing and some other types pop up now and then
09:45:16 <erisco> and then some values pop up now and then such as   t :: Char = 'a'
09:45:31 <Saizan> erisco: can you paste the code and the call that overflows?
09:45:41 <tikhonjelvis> the values pop up when it knows how to print them
09:45:41 <erisco>  just call main
09:46:28 <erisco> and the formatting is piss poor ... one amorphous blob of text :o no better visualization tools?
09:47:57 <erisco> ghci seems to randomly fall apart and refuses to actually break at break points anymore
09:48:09 <erisco> and :delete * refuses to actually delete breakpoints ... either that or the breakpoint counter never resets
09:49:35 <erisco> so the first break is    _result :: [ParseMatch Char Q] -> IO () = _
09:50:01 <erisco> I don't get what that is really saying
09:50:57 <erisco> yes, main does the IO thing, and yes somewhere along the line there is a list of parse matches, but I don't what code it is actually talking about
09:52:09 <erisco> then I go again and it says   _result :: [ParseMatch Char Q] ->String = _
09:52:16 <erisco> so ... where has the IO gone and why :s
09:53:06 <erisco> it looks like it is starting at either end of the main function ...  [ParseMatch Char Q] is what q (ListView 6 "aaaaaa")  returns, and IO () is what putStrLn does
09:53:30 <erisco> putStrLn . show . pmAccept   and IO () changes to String changes to Bool
09:54:48 <erisco> hm... so it is progressing down a stack progressively saying "okay, to get this answer I need this next answer"
09:56:25 <erisco> but it becomes unwieldly to follow for long...
09:56:44 <erisco> by about step 8 or so it is straight off the deep end and I lose track of where we are
09:57:52 <meretrix`> Is there really no way to print a backtrace when an uncaught exception is hit in a production application?
09:57:59 <dolio> erisco: Okay, so here is your problem, I think....
09:58:10 <geekosaur> if you don't understand how haskell evalulation works, a debugger will only confuse you
09:58:19 <geekosaur> kinda likewise for backtraces
09:58:30 <dolio> Well, I'm not certain, but this seems weird to me, at least.
09:58:45 <erisco> geekosaur, even if I did, am I suppose to be able to keep track of such a deep stack of things?
09:58:53 <erisco> seems unreasonable
09:59:00 <dolio> p1 // p2, upon failure of the first parser, puts the failed parse result in the list of parse results.
09:59:20 <erisco> yes, it does, but why is that a problem?
09:59:47 <meretrix`> Oh.. my question had nothing to do with erisco..
10:00:42 <meretrix`> I just want a way to be able to figure out what happen when a large application throws a divide by zero exception and I have no clue what happened.
10:00:45 <monochrom> @where stacktrace
10:00:45 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
10:00:52 <dolio> But, I'm not convinced that q = p \> q will be well-behaved unless the list of parse results is eventually empty.
10:01:00 <dolio> Of p, that is.
10:01:13 <meretrix`> monochrom: Yeah, but I'm thinking of a performance critical producation application.
10:01:27 <meretrix`> Many times bugs are only hit in production and difficult to reproduce.
10:01:55 <erisco> dolio, \> also does the second part even if the first part fails
10:01:56 <meretrix`> I'm used to Java's backtraces being everywhere.
10:02:45 <dolio> Well, then, I don't find it very surprising that you're getting a stack overflow.
10:02:48 <erisco> dolio, I was intending on relying on lazy behaviour but evidently I screwed up with something
10:03:12 <erisco> dolio, well if I never ask for the second part, then I don't see the problem ... not sure where I am doing so exactly
10:03:43 <monochrom> I don't know whether "compile with -O -prof -fprof-auto -rtsopts" gets you both performance and information. I would try it and measure.
10:04:03 <erisco> all I am asking for is  pmAccept . head   which is the first parse match and whether it was successful or not
10:04:56 <dolio> But the first parse match is something that keeps looking ahead to itself, infinitely, even if it already knows that it can't succeed.
10:05:17 <dolio> That seems to be what you've described.
10:05:18 <erisco> how am I forcing that?
10:05:41 <erisco> yes, it "looks ahead" in the same way that [1..] "looks ahead", or at least that is my intent. obviously that isn't reality
10:06:15 <monochrom> the following statement may be provocative. IMO there is a clear conflict between "performant" and "has backtrace information". if you say "but my JVM can do it", then you probably don't know that the JVM has silently taken a performance hit for the necessary bookkeeping.
10:06:30 <dwcook> Where does the name Mu come from in newtype Mu f = Mu (f (Mu f))?
10:07:24 <erisco> dwcook, I believe it was an arbitrarily chosen name. If you refer to lambda calculus, there are a few common lambas that are named like that
10:07:57 <monochrom> in any case, I'm willing to bet: "-O -prof etc etc" is on par with a JVM with backtrace capability but otherwise optimized
10:08:17 <meretrix`> That's true. I'll give it a try.
10:08:28 <dwcook> erisco, so, it was chosen simply to have a short name that was available?
10:08:33 <dwcook> ("available")
10:09:28 <erisco> I suppose? It comes from math land and they like latin letters and such. They seem to prefer brevity
10:09:54 <erisco> or greek letters. pretty sure mu is greek
10:10:05 <dwcook> Yeah, it is.
10:10:37 <Hafydd> They also like latin letters.
10:10:39 <dwcook> Latin letters are a subset of English letters, I think. :)
10:10:52 <erisco> well no, I don't think they are
10:10:59 <dwcook> Example?
10:10:59 <erisco> but probably commonalities
10:11:05 <Hafydd> x
10:11:18 <dwcook> Hafydd, that's an English letter.
10:11:25 <Hafydd> http://en.wikipedia.org/wiki/X
10:11:32 <Hafydd> X (named ex /ˈɛks/, plural exes[1]) is the twenty-fourth letter in the ISO basic Latin alphabet. In Roman numerals, it represents 10.
10:12:09 <erisco> yeah I don't think they backported 'x' into latin from english ;) but I don't think dwcook was talking about causality
10:12:42 <Hafydd> I don'
10:12:46 <dwcook> Disproof of my statement would be showing a letter in the Latin alphabet that's not in the English alphabet.
10:12:57 <Hafydd> t think there's such a thing as an "English alphabet".
10:13:14 <erisco> dwcook, on Wikipedia they mention the "archaic latin alphabet" which isn't the same as the "classical latin alphabet"
10:13:20 <Gracenotes> English as in vs. American?
10:13:38 <dwcook> By "English alphabet" I mean "the alphabet used in English orthography".
10:13:48 <Gracenotes> English as in vs. American? :)
10:14:12 <dwcook> No, English as in the language as a whole, including its dialects (British, American, etc.)
10:14:34 <Gracenotes> Okay, good to make that distinction, but English the language has a lot of dialects...
10:15:12 <tikhonjelvis> I've always referred to it as the "Roman alphabet"
10:15:21 <tikhonjelvis> as opposed to, say, Cyrillic
10:16:13 <dolio> ericso: At best, only parts of your parse state are well-behaved in (\>).
10:16:15 <erisco> dwcook, ah maybe it is called "old latin". I don't know of these things
10:16:41 <dwcook> I think it could definitely be argued that the archaeic Latin alphabet is not a subset of the English one.
10:16:46 <dolio> Because you're defining the result parse state as a combination the first one, and the infinite lookahead one.
10:16:50 <dwcook> Especially if there are letters in it that don't serve the same purpose.
10:17:14 <dwcook> +as equivalent ones in English
10:17:21 <dolio> So, pmAccept x && pmAccept y looks okay at first blush, because if pmAccept x is false, it can short-circuit.
10:17:23 <monochrom> infinite lookahead :)
10:17:38 <Hafydd> Apparently: In the orthography of Modern English, thorn (þ), eth (ð), wynn (ƿ), yogh (ȝ), ash (æ), and ethel (œ) are obsolete.
10:17:41 <dolio> But when you add things in the second, there is no short-circuiting.
10:18:02 <dwcook> I have an aunt named Ethel. I think I will start writing her name that way.
10:18:07 <Gracenotes> where does long s fall here?
10:18:11 <dolio> And pmRest y also just takes directly from the one that is looking ahead forever.
10:18:13 <dwcook> She may or may not be amused.
10:18:16 <Gracenotes> It is just an s, not a separate letter...
10:18:35 <tikhonjelvis> I've seen people use æ before
10:18:36 <erisco> dolio, I rewrote that whole section at one point to not do anything with 'y' unless pmAccept x was true, but to no effect
10:18:45 <solrize> to write a datatype "Foo a"   as    "data Foo :: * -> *  where ..."   do I need -XKindSignatures?  i don't remember needing that before 7.4
10:19:26 <erisco> dolio, I have the same suspicions that you do but I haven't the foggiest of how to find the issue... I guess I'll just have to rewrite the entire thing
10:19:37 <erisco> will be about the only way I can rethink the problem
10:19:37 <dolio> erisco: So, even though the boolean combination may short circuit, it's difficult to tell if it isn't also contaminated by the non-well-founded stuff elsewhere.
10:20:05 <erisco> I agree
10:22:09 <erisco> of course I can also use substitution to evaluate everything by hand
10:23:03 <dolio> I also find other things suspicious.
10:23:23 <dolio> Like, if token fails, it sets the length to 0, but doesn't change the input.
10:23:48 <dolio> But then it looks like viewOfPm resets it.
10:23:51 <erisco> dolio, not sure what you mean by "doesn't change the input"
10:23:58 <dolio> It keeps the whole list.
10:24:14 <dolio> So the integer you have is no longer really the length of the list.
10:24:33 <erisco> that shouldn't matter
10:24:41 <dolio> And other parts of the code rely on the length of the list being equal to the integer for coverage.
10:24:52 <erisco> it does?
10:25:11 <dolio> token assumes that.
10:25:31 <erisco> I don't see how
10:25:52 <erisco> all it seems to care that if the length is zero, the list is treated as having no input left
10:26:04 <erisco> and other than that it doesn't look at length
10:26:31 <dolio> That match is not exhaustive.
10:26:40 <klrr_> what is the most mature FRP library?
10:26:40 <dolio> I guess it doesn't matter.
10:26:57 <erisco> I'd have a runtime exception if it missed
10:27:29 <dolio> It is important if the 0 that token puts in is supposed to short-circuit future parsers, though.
10:27:34 <erisco> maybe I have some inconsistencies with how I report the match... I see in one case I use  ListView 0 avs   and in the other  ListView 1 [v]
10:27:44 <erisco> which may as well be avs instead of [v]
10:27:56 <tikhonjelvis> klrr_: I don't know if it's the *most* mature, but Reactive Banana is certainly a good option
10:28:00 <dolio> Because it will then get reset to whatever the actual length of the list is later.
10:29:38 <erisco> dolio, that process is used by \> so that it can try 'b' if 'a' fails
10:29:52 <klrr_> tikhonjelvis: reactive banana and yampa seem to be the most mature ones reading the wiki , yampa seem to have most projects using it, i gonna look into both
10:30:02 <erisco> dolio, instead of resetting I could also just use the original ListView given to \> ... which would be clearer
10:31:19 <tikhonjelvis> klrr_: it's a little hard to compare because they use different models
10:31:58 <klrr_> tikhonjelvis: oh, is bananas' one better for certain stuff and yampa for others, or just plain different in general?
10:32:04 <tikhonjelvis> I personally prefer the more classical event/behavior model over the arrow-based libraries, so I like Reactive Banana more
10:32:11 <tikhonjelvis> eh
10:32:12 <erisco> dolio, a \> b  is "a followed by b" but for error recovery, I try b anyways if 'a' fails. If I am not interested in 'b' if 'a' fails, I'll just never ask for it
10:32:14 <tikhonjelvis> just plain different
10:32:17 <erisco> and so it won't be parsed
10:32:30 <user8> Can someone help me figure out why http://paste.tryhaskell.org/90725 uses all available memory and stack overflows?
10:32:31 <tikhonjelvis> I mean, I'm sure they have pros and cons, but those are just incidental
10:33:20 <klrr_> tikhonjelvis: okey, i will start out with banana then, also, that first documantation link that yampa had scared me a bit, all kind of wacky graphs xD
10:33:22 <erisco> dolio, I don't know if this is a practical design yet but I certainly can't test that with a stack overflow in the way ;) I think I'll evaluate it by hand ...
10:33:29 <erisco> hopefulyl the line length isn't too long
10:34:09 <erisco> first some lunches though :D
10:34:13 <tikhonjelvis> klrr_: yeah, that's what I would do too
10:34:27 <tikhonjelvis> my suggestion is to find a really simple project and just try to write it
10:34:38 <tikhonjelvis> that really helps in understanding the abstractions
10:34:58 <tikhonjelvis> for example, you could write a little app for John Conway's game of life--that's how I got started with FRP
10:36:46 <luite_> klrr_: sodium might be worth looking into, it has more or less the same model as banana. neither has continuous time though (unless heinrich added it recently)
10:37:18 <ncs> I need to pattern match on a Map like so: func (M.fromList ((a,b):as)) = ...   but i get back the error : Parse error in pattern: M.fromList... :( anybody has any idea why?
10:37:47 <Clint> because you can't do that
10:38:15 <ncs> and do you have any suggestions/alternatives?
10:38:29 <FreeFull> ncs: You can only pattern match on constructors
10:38:33 <Clint> what are you actually trying to do?
10:39:23 <ncs> I have to datatypes, A and B. I have a Map A A and a Map A B and I want the function to check for every element of Map A A to do something to the Map A B where the A's are the same in the 2 maps
10:39:31 <ncs> two^
10:40:15 <pentace> Can't you use map?
10:40:16 <tromp_> the 2 maps have the same keys?
10:40:37 <portnov> @pl prop_contains_all xs = sort xs == toList (fromList xs)
10:40:37 <lambdabot> prop_contains_all = liftM2 (==) sort (toList . fromList)
10:40:47 <tromp_> why not have Map A (A,B) ?
10:40:52 <ncs> yes, they use the same keys.. basically i want to replace all the keys of Map A B with the values of Map A A
10:42:03 <Clint> so both maps have the same type
10:42:41 <tromp_> so you want newmap[a] = abmap[aamap[a]] ?
10:43:30 <pentace> mapKeys might be what you're looking for
10:43:42 <ncs> for example if Map A B = [(a1,b)] and Map A A = [(a1,a2)], i want to end up with Map A B = [(a2,b)] and Map A A = [(a1,a2)]
10:44:17 <FreeFull> ncs: Have you checked if   M.intersection  already does what you want?
10:44:42 <benmachine> I think pentace is right, and you're looking for mapKeys
10:44:57 <ncs> definitely not intersection, i'll have a look at mapkeys
10:46:56 <FreeFull> ncs: Does the  Map A A not change?
10:47:17 <ncs> no, that one must be kept the same. only the keys of Map A B must be updated
10:47:38 <ncs> and I don't see how I can use mapKeys for that either.. :S
10:47:57 <FreeFull> ncs: Well, it's all immutable anyway, so all you can do is return a new Map
10:48:10 <wereHamster> where can I ask questions about http conduit?
10:48:44 <tikhonjelvis> you *can* ask them pretty much anywhere :P
10:48:50 <tikhonjelvis> but maybe try #yesod?
10:48:59 <tikhonjelvis> (I think that's the name of the channel)
10:48:59 <Clint> depends on the question
10:49:05 <monochrom> here and #yesod
10:49:06 <tikhonjelvis> or here
10:49:21 <wereHamster> some code works standalone but does not work as part of a larger aplication
10:49:24 <ncs> yes, but I still have to go through all the elements of Map A A and if a key of Map A B is the same as one of the keys of Map A A then it should be replaced with the value found in Map A A
10:49:29 <S_J> Do you sometimes find that programming in haskell makes your code to compact? i find it hard to dissect sometimes when I come back to it.
10:49:45 <benmachine> actually yeah, looks liek mapKeys doesn't do what I assumed it did
10:50:26 <hpaste> wereHamster pasted “wtf http conduit?” at http://paste.tryhaskell.org/90726
10:50:52 <FreeFull> ncs: The type should be something like      Ord a => Map a a -> Map a b -> Map a b   right?
10:50:52 <tikhonjelvis> S_J: As long as you're tasteful about it, you'll get used to it pretty quickly
10:51:04 <ncs> yes!
10:51:06 <byorgey> S_J: yes, sometimes you have to intentionally fight against making the code too concise.  Sometimes it is too tempting to be "clever" to make the code short instead of making it clear
10:51:11 <tikhonjelvis> in general, shorter is better, but not to the point of obfuscation
10:51:16 <wereHamster> If it makes any difference, the larger app uses threads
10:51:25 <wereHamster> compiled with -threaded
10:51:27 <byorgey> S_J: but as you gain experience it becomes less of a problem
10:52:00 <tikhonjelvis> Honestly, I think most languages go too far in the opposite direction
10:52:07 <tikhonjelvis> if you have too much code, it just becomes noise
10:52:17 <tikhonjelvis> Java is the obvious example
10:52:23 <tikhonjelvis> but even OCaml seems to be like that
10:52:27 <tikhonjelvis> a little bit
10:52:46 <benmachine> ncs: isn't that just mapKeys (\x -> findWithDefault x x aamap)
10:54:39 <ncs> benmachine: at first glance it seems to be exactly what i want.. i'll try it out!
10:55:34 <benmachine> (I tend to use fromMaybe x (lookup k map) instead of findWithDefault x k map, so I don't have to remember so many names)
10:55:38 <benmachine> (but that's just me)
10:58:14 <kostja> hi!
10:59:03 <klrr_> luite_: will do thanks
10:59:51 <FreeFull> benmachine: I tend to use   maybe x id instead of fromMaybe x because then you don't have to import Data.Maybe
11:00:07 <luite_> klrr_: i have a few simple examples for the web here: http://weblog.luite.com/wordpress/?p=127
11:00:22 <benmachine> FreeFull: yw
11:00:24 <benmachine> eer
11:00:27 * benmachine mistype
11:00:29 <kostja> I'm working on an application that should abstract the application logic from the user interface to support different uis (e.g. vty, wx). what would be the best way to handle user input?
11:00:43 <benmachine> FreeFull: imports aren't that upsetting, are they?
11:00:51 <ncs> benmachine: thanks! that was the solution :)
11:01:11 <FreeFull> benmachine: I'm lazy when I'm in ghci =P
11:01:31 <benmachine> FreeFull: get a .ghci that imports all the things
11:03:42 <joelteon> import *
11:03:45 <kostja> or should user input be handled completely in the ui, just calling functions in the application core logic?
11:03:46 <joelteon> shouldn't be a problem
11:05:11 <monochrom> kostja: I say yes to the last choice
11:07:07 <Lethalman> kostja, the yi editor does something similar already with vty and gtk
11:07:56 <kostja> Lethalman: yes, that's right. unfortunately yi is very very bad documented
11:24:00 <j00bus> help!  I'm trying to cross compile llvm for arm and I'm running into this build error.  /llvm/build/Debug+Asserts/lib/libLLVMSupport.a: could not read symbols: Archive has no index; run ranlib to add one
11:24:08 <j00bus> anyone else seen this?
11:26:39 <bgamari> j00bus, can't say I have
11:27:01 <j00bus> you wouldn't happen to have haskell and llvm running on arm would you?
11:27:11 <bgamari> j00bus, yep
11:27:21 <bgamari> j00bus, These are a bit dated but might be useful: http://bgamari.github.io/posts/2011-10-17-crosscompiling_llvm.html
11:27:26 <bgamari> http://bgamari.github.io/posts/2012-01-27-ghc-llvm-arm.html
11:27:26 <j00bus> did you cross compile to get it there?
11:27:33 <j00bus> yeah, i'm reading those now
11:27:43 <j00bus> you must be bgamari :)
11:27:57 <bgamari> j00bus, recently I've been building llvm on the target
11:28:15 <bgamari> as I have a pandaboard which is quite sufficient
11:28:29 <bgamari> when I was working on the beagleboard XM building LLVM was tricky at best
11:28:40 <bgamari> that being said, I haven't build llvm recently, just ghc
11:28:44 <bgamari> let me try upgrading
11:28:49 <bgamari> I've been meaning to try this anyways
11:30:07 <bgamari> j00bus, I haven't seen that error though, very strange
11:31:15 <j00bus> i followed your directions exactly in the ubuntu post.  at first i was on my debian machine, so i tried my ubuntu machine afterwards.  nothing so far.
11:31:16 <bgamari> j00bus, google turns up this, http://llvm.org/bugs/show_bug.cgi?id=15958
11:31:19 * hackagebot hPDB 0.99 - Parser, print and manipulate structures in PDB file format.  http://hackage.haskell.org/package/hPDB-0.99 (MichalGajda)
11:31:21 * hackagebot hPDB-examples 0.99 - Parser, print and manipulate structures in PDB file format.  http://hackage.haskell.org/package/hPDB-examples-0.99 (MichalGajda)
11:31:23 * hackagebot ghci-ng 7.4.2.1 - Extended GHCi fork  http://hackage.haskell.org/package/ghci-ng-7.4.2.1 (HerbertValerioRiedel)
11:31:41 <bgamari> j00bus, have you tried blowing away that .a and rebuilding it?
11:31:56 <j00bus> no
11:32:02 <hvr> chrisdone: ping
11:32:23 <j00bus> i'm targeting a raspberry pi running raspbian
11:32:27 <bgamari> j00bus, ahh
11:33:26 <j00bus> and the whole reason i'm doing this is becaues 'cabal install yesod-platform' failed.  I'm a haskell noob right now.
11:33:43 <j00bus> All i need is to get a copy of llvm running on the pi correct?
11:34:40 <bgamari> j00bus, Yep, but it needs to be new enough to have the GHC calling convention patches
11:34:50 <bgamari> which I think happened in 3.2
11:34:55 <j00bus> ok
11:48:39 <alexander__b> is there a way to send a float to a function that takes an integer, and turn the result into a float?
11:51:06 <pentace> fromInteger . f . round
11:51:19 * hackagebot stomp-queue 0.0.3 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.3 (TobiasSchoofs)
11:52:51 <S_J> from hpc: " 83% alternatives used (5/6)". what does thta mean? I have one branch in a fucntion thatr doesnt get executed, that is all. there are only 2 if-else clauses so if this is that it should be 3/4. Also: " 97% expressions used (167/171)" how can that be when there is only one branch in a fun that doesnt get called.
11:59:02 <alexander__b> pentace: that's what I'm currently doing. I was kind of hoping there was a shorter way.
11:59:32 <pharaun> is there a good way to stream a conduit into a bytestring?
11:59:39 <pharaun> i'm attempting to figure this out now :)
11:59:50 <pentace> alexander__b: I fear not
12:00:08 <alexander__b> pentace: or actually, I am using floor rather than round, but that's just because, heh.
12:00:27 <Clint> pharaun: Data.Conduit.List.consume ?
12:00:56 <pharaun> Clint: let me check
12:02:12 <pharaun> I think so since its a strict Bytestring so i can do that then concat it together
12:02:16 <pharaun> Clint: ok i'll try that thanks
12:04:24 <Gracenotes> hm. this is a cool use of fixpoint datatypes for fun and profit. http://brianmckenna.org/blog/type_annotation_cofree
12:04:57 <Gracenotes> skimmed through; should look at more closely later...
12:07:39 <yogert> Hey, does anyone have any recommendations for a haskell plotting library?
12:07:56 <typoclass> yogert: maybe "diagrams"?
12:08:43 <yogert> as in, something akin to matplotlib for python
12:08:47 <klrr_> exit
12:09:10 <pharaun> Clint: ok i got the types to all work out, so this should be good, thanks :)
12:09:21 <mike> hi guys
12:09:35 <mike> anyone of you used package linear?
12:09:40 <Clint> pharaun: np
12:09:46 <yogert> okay, I'll give that a look
12:10:16 <danharaj> mikecaruso: I haven't but since it is written and maintained by Edward Kmett I am confident when I say it is a good library.
12:10:19 <danharaj> er sorry
12:10:43 <danharaj> didn't mean to ping the wrong mike :3
12:10:45 <alexander__b> gah. mlt has changed.
12:11:00 <alexander__b> learnyouahaskell uses State, Writer and Error
12:11:05 <alexander__b> what are the equivalents in mlt2?
12:11:10 <Guest59930> no problem
12:11:21 <danharaj> alexander__b: do you mean mtl?
12:11:26 <alexander__b> danharaj: sorry, yes.
12:11:37 <typoclass> yogert: here are some examples for the 'diagrams' library http://projects.haskell.org/diagrams/gallery.html , and here are some for the 'chart' library https://github.com/timbod7/haskell-chart/wiki#standard-api
12:12:18 <mi-mike> I like it too, but I have problem understandint typeclasses R1, R2 and R3
12:12:22 <yogert> typoclass: I've seen this before and I was under the impression it was more akin to d3js. Perhaps I'll ask on their irc channel
12:12:35 <danharaj> alexander__b: those monads are still in mtl. What is the problem?
12:12:38 <mi-mike> and how they can be used to extract values of certain coordinates from a vector
12:12:49 <alexander__b> danharaj: not in mtl2 apparently
12:13:13 <Clint> alexander__b: check transformers
12:13:14 <alexander__b>     Not in scope: data constructor `State'
12:13:16 <alexander__b>     Perhaps you meant `StateT' (imported from Control.Monad.State)
12:13:18 <alexander__b> Clint: check what?
12:13:23 <Clint> the transformers package
12:13:27 <alexander__b> oh right. I have that too.
12:13:29 <danharaj> You mean this package, right? http://hackage.haskell.org/package/mtl-2.1.2
12:13:43 <alexander__b> keep in mind that I have no idea what I'm doing and only started learning haskell...
12:13:44 <typoclass> yogert: i'm not familiar with d3js (or matplotlib), i was just giving you some pointers
12:13:50 <alexander__b> danharaj: I have mtl 2.1.2-r1
12:14:08 <alexander__b> I guess doing import Control.Monad.State in ghci doesn't import from mtl then?
12:14:13 <haasn> alexander__b: (mtl is based on transformers, the StateT is the same)
12:14:31 <typoclass> alexander__b: yeah, i think C.M.State will be the one from package 'base', not 'mtl'
12:14:47 <alexander__b> typoclass: and this has changed since learn you a haskell?
12:14:58 <alexander__b> typoclass: because learn you a haskell just does import and then uses stuff.
12:15:03 <danharaj> Control.Monad.State isn't in base is it?
12:15:08 <alexander__b> danharaj: yes... but
12:15:09 <haasn> danharaj: I wouldn't think so
12:15:10 <alexander__b>     Not in scope: data constructor `State'
12:15:12 <alexander__b>     Perhaps you meant `StateT' (imported from Control.Monad.State)
12:15:15 <typoclass> alexander__b: wait, i got it wrong, sorry
12:15:29 <typoclass> danharaj: you're right
12:15:31 <haasn> alexander__b: try ‘state’ (lowercase)
12:15:36 <danharaj> no do not
12:15:41 <alexander__b> ...
12:15:42 <danharaj> it is definitely not lowercase.
12:15:48 <haasn> danharaj: what do you mean?
12:16:03 <alexander__b> state lowercase is not the same as State, I suspect, as the Learn You A Haskell examples did not work using that
12:16:04 <danharaj> alexander__b: that is weird. State s is a type alias for StateT s Identity and I see it right here in teh docs.
12:16:10 <haasn> mtl is based off the old State definition, the new one based on transformers moves the ‘old’ behavior to a function instead
12:16:14 <danharaj> haasn: Types cannot start with lowercase letters.
12:16:15 <haasn> err
12:16:21 <haasn> LYAH is based off the old State definition*
12:16:28 <alexander__b> so... what do I do?
12:16:29 <Clint> alexander__b: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#g:1
12:16:30 <haasn> :t state
12:16:30 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
12:16:35 <haasn> alexander__b: just use ‘state’ where LYAH suggests State
12:16:40 <alexander__b> haasn: thanks.
12:16:42 <haasn> if you want to construct a stateful function
12:16:44 <haasn> eg.
12:16:52 <danharaj> Oh I see State is a data constructor.
12:16:53 <haasn> :t state (\s -> ((), s+1))
12:16:53 <lambdabot> (Num s, MonadState s m) => m ()
12:16:54 <danharaj> My mistake.
12:17:20 <haasn> (of course, this is equal to “modify (+1)”)
12:17:24 <alexander__b>     No instance for (Monad (state StdGen))
12:17:31 <typoclass> alexander__b: could you paste the code that you were trying? i'm also suspicious about the error message mentioning "data constructor State"
12:17:40 <haasn> alexander__b: oh err, some miscommunication here
12:17:43 <alexander__b> typoclass: uhm just a bunch of different stuff
12:17:48 <danharaj> hpaste.org
12:17:49 <alexander__b> typoclass: from the learn you a haskell book
12:17:55 <haasn> alexander__b: ‘state’ to replace the State data constructor; the type is still called State
12:18:09 <alexander__b> I have a 500 lines file with random stuff I'm trying out from the book, lol
12:18:10 <haasn> @where hpaste
12:18:10 <lambdabot> http://paste.tryhaskell.org/new/haskell
12:18:31 <haasn> just post the few lines that are erroring
12:18:38 <alexander__b> hpaste doesn't really work here.
12:18:50 <alexander__b> haasn: it's *a lot* of lines. I'd need to pick one example, I guess
12:19:43 <yogert> typoclass: As for the Chart library, I wasn't able to get that one installed… During the installation it said it requires, among other things, cairo 0.12.4.
12:20:13 <yogert> typoclass: That doesn't seem right… given that the current version is 1.12
12:21:02 <haasn> alexander__b: well, basically, when I meant to change State to state, I only meant where you're using it as a data constructor :)
12:21:11 <haasn> the type is still called State (it's just an alias)
12:21:19 <danharaj> yogert: that is the version of the haskell binding to cairo.
12:21:20 <alexander__b> haasn: right, yes. I tried a minimal example, which worked
12:21:21 <typoclass> alexander__b: anyway, in general it's possible that you read in a book to import Blah.Foo, where actually you need to import Blah.Thingy.Foo these days. lyah isn't a particularly old book, but still, versions can change in a few years
12:21:24 <alexander__b> just randomSt = state random
12:21:31 <danharaj> yogert: in your error.
12:21:31 <haasn> :t state random
12:21:32 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
12:21:59 <joelteon> > state random
12:22:00 <lambdabot>   No instance for (System.Random.Random a0)
12:22:00 <lambdabot>    arising from a use of `e_1'
12:22:00 <lambdabot>  T...
12:22:02 <typoclass> alexander__b: this tells you where State is living these days http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/doc-index-S.html i suppose you want .Lazy
12:22:18 <haasn> I thought I remembered ‘state’ and ‘random’ having the tuple in the opposite order :P
12:23:33 <typoclass> alexander__b: (if you're unsure, use "ghc-pkg list" to find out what version you have. for me, it's mtl-2.1.1. note the version version number in the documentation url)
12:24:05 <byorgey> yogert: note that jbracker is working on a port of Chart to be able to use the diagrams library as a backend... which in turn means you will be able to use Chart with any diagrams backend, including native SVG and PS backends that are easy to install
12:24:08 <haasn> 2.1.2 here
12:24:33 <typoclass> alexander__b: i've only skimmed it, but this may be useful http://stackoverflow.com/questions/14157090/has-the-control-monad-state-api-changed-recently
12:24:34 <byorgey> cairo is a powerful library but it is often difficult to install
12:24:36 <haasn> alexander__b should be using the same environment as me
12:26:04 <alexander__b> after spending ~forever, my baby.hs from learn you a haskell all works
12:26:40 <haasn> alexander__b: you might not know this, but having all of your experiments in a file isn't necessary; I just use the excellent REPL when experimenting :)
12:26:45 <alexander__b> weee. thanks.
12:27:00 <alexander__b> haasn: it's so I can look up "how did I do foo"
12:27:10 <haasn> ah
12:27:47 <yogert> byorgey: You're the maintainer of Diagrams, correct? At the moment I'm reading a book and I want to be able to plot some things as I go. So preferably, I'd be spending most of my time in GHCI. Am I correct in guessing that Diagrams is not best suited for this?
12:28:31 <byorgey> yogert: "plot" meaning "plot some data"? or just "draw some things"?
12:29:20 <byorgey> diagrams has no specific facilities for plotting data, though custom data visualization with diagrams can be quite pleasant
12:29:32 <yogert> Both data and functions. Mostly time series and histograms. I took Diagrams as being more akin to d3js
12:29:46 <haasn> yogert: oh, I remember finding an excellent library for this
12:30:03 <byorgey> yogert: right, the best library for that is Chart.
12:30:13 <arnsholt> For random data slicing and dicing, R is also very good
12:30:20 <arnsholt> Of course, not Haskell =)
12:30:50 <yogert> yeah I know. And I've spent some time with the whole python environment ala pylab
12:31:12 <yogert> Ill have to put off learning R for now : P
12:31:19 <haasn> yogert: Graphics.Rendering.Plot.Figure.Simple (don't remember what package it's from); it has various APIs including stuff like: display $ plot (Line, [sin, cos] :: [Function])   or  display $ parametric (id, sin) (-10, 10) 500
12:31:36 <haasn> simplest way I found to just get a nice-looking graphical output of a Double -> Double on the fly
12:31:38 <wole> @hoogle toList
12:31:39 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
12:31:39 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
12:31:39 <lambdabot> Data.Text.Array toList :: Array -> Int -> Int -> [Word16]
12:32:01 <byorgey> haasn: that's from the plot package, which also requires cairo.
12:32:23 <byorgey> and hasn't been updated for 2 years
12:33:01 <yogert> byorgey: Also, I'm a bit confused by the previous comment you made about a Chart port. Were you suggesting that I consider using Diagrams in the future as a backend for Chart?
12:33:34 <byorgey> yogert: I mean that in the future, you will be able to use Chart without having to install cairo
12:33:49 <yogert> Oh, okay.
12:33:56 <byorgey> if you instead install diagrams and a non-cairo diagrams backend such as diagrams-svg
12:34:07 <byorgey> which is easy to install on all platforms
12:35:14 <arnsholt> yogert: As an anecodtical data point, I found sitting down and learning R to pay off within a day for my purposes
12:35:22 <arnsholt> Of course, YMMV
12:36:05 <byorgey> but then you know R.
12:36:12 <byorgey> you can never get that brain space back.
12:37:02 <arkeet> lol
12:37:04 <byorgey> argh, sorry, I should know better.  I do not actually condone language-bashing in #haskell.
12:37:12 <arnsholt> 'sok =)
12:37:17 <byorgey> amusing as it may be =)
12:37:28 <arkeet> haskell is a good thing to occupy brain space with.
12:37:49 <S_J> what is >>= called? join?
12:37:54 <byorgey> S_J: bind.
12:37:58 <arkeet> no, join is called join.
12:38:01 <arkeet> >>= is bind
12:38:06 <byorgey> join is called... what arkeet said =)
12:38:14 <arnsholt> R is a bit weird, but as a PhD student in a data analysis heavy area it's been quite useful
12:38:28 <byorgey> I bet.
12:38:32 <S_J> but there is no literal bind function, i mean i cant call bind instead of >>=
12:38:42 <byorgey> S_J: right
12:38:43 <arkeet> ?
12:38:58 <arkeet> >>= is pronounced bind (I think). and it's written >>=
12:39:43 <haasn> arkeet: yes
12:40:17 <haasn> (>>=) is the ‘literal bind function’ I guess :)
12:40:52 <luite_> =<< is pronounced pu!q
12:41:06 <arkeet> =)
12:42:05 <typoclass> luite_: in other words, 'bind' was so drunk that it has fallen over
12:42:37 <haasn> puıq
12:42:49 <haasn> is what my script suggests, at least
12:43:54 <yogert> is it just me or is package management on osx horribly horribly broken? No installs ever seem to go smoothly.
12:45:09 <yogert> Any reason why id be running into trouble installing the cairo bindings? I first had an error suggesting I should install gtk2hs-buildtools.
12:45:59 <banister> does haskell have decent curses bindings?
12:46:39 <yogert> Next the problem is that the package cairo-pdf is missing
12:46:58 <haasn> banister: there are a few curses packages iirc all with their own fair of ugliness
12:47:04 <haasn> banister: there's also ‘vty’, a pure-haskell alternative
12:47:21 <typoclass> yogert: yeah, cabal installs only haskell stuff, it doesn't install c libraries or external tools. but it does alert you that they're missing
12:48:14 <yogert> typoclass: I just found an entry in a mailing list suggesting that the package i want is actually called libcairo2-dev
12:48:25 <yogert> go figure
12:48:43 <banister> haasn: oh ok thanks, can you recommend a decent project for a haskell beginner? I tried messing with the websocket library but it seems pretty complicated, it's using quite advanced haskell features
12:48:54 <haasn> banister: no idea
12:48:58 <byorgey> yogert: there are some instructions for installing cairo on OSX here: ers.se] has quit [Quit: Lost terminal]
12:49:01 <byorgey> (13:58)                -!- roconnor [~roconnor@e120-pool-d89a7750.brdbnd.voicenetwork.ca] has quit [Quit: Konversation terminated!]
12:49:04 <byorgey> (14:05)                -!- mizu_no_oto [~textual@c-76-24-19-222.hsd1.ma.comcast.net] has joined #haskell-lens
12:49:05 <banister> haasn: what was your first project?
12:49:07 <byorgey> (14:11)                -!- joelb [~textual@c-76-102-13-163.hsd1.ca.comcast.net] has joined #haskell-lens
12:49:10 <byorgey> oops, sorry
12:49:31 <byorgey> yogert: http://www.haskell.org/haskellwiki/Diagrams/Install  -- not sure how up-to-date they are.  ask carter.
12:49:40 <haasn> banister: when I first started out I looked at some existing projects and started contributing small amounts of those; it helps you get feedback from more experienced haskell programmers when they review your patches/ideas
12:49:43 <typoclass> yogert: yep, that's a likely name for an external non-haskell package that cabal needs but doesn't itself install
12:49:45 <carter> byorgey huh?
12:49:53 <haasn> contributing small amounts to chose*
12:49:55 <haasn> to those, even
12:49:56 <yogert> The instructions I saw on the cairo site merely suggested using macports. Ill try your link
12:50:01 <byorgey> carter: are the OSX cairo installation instructions at http://www.haskell.org/haskellwiki/Diagrams/Install  still up-to-date?
12:50:07 <typoclass> carter: an accidental middle-click, i suppose
12:50:26 <typoclass> carter: er sorry, i misread your question
12:50:27 <byorgey> it was an intentional middle-click, with unintentional clipboard contents
12:50:36 <carter> byorgey yogert  last I checked, brew now installs the missing lib
12:50:48 <carter> so if you do a brew install of the cairo and friends
12:50:52 <carter> (gkt)
12:50:54 <carter> plus all the deps
12:51:10 <carter> the lib that wasn't brew built will now be brew built
12:51:41 <carter> basically the point of the uninstall steps
12:51:51 <carter> is to make sure they're all built consistently with the same version
12:51:51 <carter> s
12:52:09 <byorgey> so you're saying the uninstall stuff on that page can now be ignored?
12:52:10 <carter> but point being: using brew *should* work, though its been a while since I sued
12:52:19 <carter> byorgey probably
12:52:22 * typoclass . o O ( i wonder why any irc client even interprets the newlines inside of clipboard text ... seems pretty clear that it should only send messages when the user presses the enter key )
12:52:33 <byorgey> typoclass: I have wondered that myself.
12:52:59 <carter> *tested it
12:53:14 <carter> but tldr: use 64bit ghc
12:53:19 <haasn> typoclass: pasting is a complicated business, apparently. I got the weechat guys to make it somewhat sane
12:53:20 <carter> and brew should work
12:53:34 <carter> what sort of sane
12:53:44 <joelteon> it's because IRC messages can't have newlines, right?
12:53:54 <typoclass> haasn: hm interesting. how is it complicated?
12:54:21 <prophile> technically IRC messages are required to have newlines, that's how you delimit them
12:54:43 <yogert> carter: Would macports be okay to use? The cairo website instructs osx users to install it through macports, and I now have other things that depend on that particular installation.
12:55:20 <haasn> typoclass: I'm not too keen on the specifics, but apparently it's difficult to distinguish a paste from a user just regularly entering text. weechat listens for multiple keypresses in rapid succession, but some terminals also have special characters to communicate this kind of thing
12:55:21 <joelteon> prophile: you must be fun at parties
12:55:30 <carter> yogert find out experimentally
12:55:32 <carter> but if it breaks
12:55:35 <carter> on you :)
12:55:46 <carter> brew tries to use the apple build tools
12:55:57 <carter> macports builds its own copy of everything
12:56:03 <carter> which is good and bad
12:56:10 <typoclass> joelteon: i assume the client could display the multiple lines in the edit area, and only send them when the person presses enter
12:56:12 <carter> macports does do deps and version stuff better
12:56:18 <geekosaur> macports uses apple build tools for most things, actually
12:56:28 * typoclass scratches his head
12:56:39 <geekosaur> we only blacklist the apple build tols when they're known to produce broken code
12:56:47 <carter> ahhh
12:56:51 <carter> well
12:57:03 <carter> i had some weird experiences and then i switched back to brew
12:57:03 <geekosaur> (which happens quite a bit, actually; apple's compilers are rather buggy)
12:57:14 <carter> geekosaur apple clang or gcc?
12:57:18 <carter> apple gcc is weird and old
12:57:34 <carter> doensn't understand -march=native
12:57:34 <sm> doesn't brew use some more-than-usually insecure ruby packaging system ?
12:57:35 <carter> and friends
12:57:39 <geekosaur> gcc is very buggy; some versions of apple's clang are prereleases with bugs
12:57:40 <carter> no clue
12:58:01 <typoclass> haasn: oh, weechat is a terminal program!? i see. yeah that would be difficult then. vim handles it quite ok (if configured), but it runs inside of a special terminal called gvim
12:58:15 <geekosaur> but apple has been getting better at using good versions of clang
12:58:30 <carter> geekosaur i know :
12:58:57 <carter> geekosaur i was last week making sure some clang patches would be considreed for 3.3 POINT + xcode 5 so ghc can be happy in a clang only env
13:12:56 <S_J> http://stackoverflow.com/questions/8610277/haskell-parsing-command-line-arguments   whats that @ doing there?
13:15:09 <typoclass> S_J: "name@pattern" matches on the pattern, but also assigns the name to the entire thing. "w@(x:xs)" will assign the name x to the head of the list, xs to the tail, and w to the whole list
13:15:55 <S_J> :t getArgs
13:15:55 <lambdabot> Not in scope: `getArgs'
13:16:13 <S_J> where is getArgs?
13:16:27 <typoclass> @hoogle getArgs -- iirc it's System.Environment
13:16:27 <lambdabot> Parse error:
13:16:28 <lambdabot>   getArgs -- iirc it's System.Environment
13:16:28 <lambdabot>             ^
13:16:33 <typoclass> @hoogle getArgs
13:16:34 <lambdabot> System.Environment getArgs :: IO [String]
13:16:34 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
13:16:34 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
13:20:01 <S_J> how can i go from String->Int
13:20:20 <S_J> @hoogle String->Int
13:20:20 <lambdabot> Test.HUnit.Base Label :: String -> Node
13:20:20 <lambdabot> Prelude error :: [Char] -> a
13:20:20 <lambdabot> Prelude length :: [a] -> Int
13:20:36 <benmachine> S_J: length :)
13:20:49 <benmachine> S_J: mroe seriously, you should be careful, because what are you going to do about errors?
13:21:00 <benmachine> you can use "read" to ignore errors
13:21:06 <benmachine> or "reads" to get a list of possible results
13:21:13 <benmachine> which will be empty if there was an error
13:21:30 <typoclass> S_J: in general, 'reads' and similar functions. the SO page that you linked uses 'reads' in one place (answer 1)
13:22:27 <S_J> @hoogle reads
13:22:27 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
13:22:27 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
13:22:27 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
13:25:37 <S_J> i dont get how to use reads
13:27:21 <stacky> > reads "4hi" :: [(Int, String)]
13:27:22 <lambdabot>   [(4,"hi")]
13:27:22 <hpaste> typoclass pasted “command line arguments (untested)” at http://paste.tryhaskell.org/90728
13:27:53 <stacky> the first element of the tuple is what it could parse, the second is the rest of the string
13:28:07 <stacky> if it can't find what you want, it'll give you an empty list
13:28:14 <typoclass> S_J: check this ^^ i think that's how i'd write the stack overflow answer. also, you could use readMaybe from the Text.Read module (if you have it)
13:33:11 <erisco> > fst . (1, [1..)
13:33:12 <lambdabot>   <hint>:1:15: parse error on input `)'
13:33:14 <erisco> > fst . (1, [1..])
13:33:15 <lambdabot>   Couldn't match expected type `a0 -> (c0, b0)'
13:33:15 <lambdabot>              with actual type...
13:33:25 <erisco> fst (1, [1..])
13:33:32 <erisco> > fst (1, [1..])
13:33:33 <lambdabot>   1
13:34:01 <erisco> so this is evidence that the second value doesn't need to be evaluated right?
13:35:01 <Eduard_Munteanu> Hrm, can you import qualified something as X.Y? E.g. Data.Map.empty would be shortened to D.M.empty
13:35:06 <haasn> > [1..]
13:35:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:35:18 <haasn> here's a mildly better example:
13:35:20 <haasn> > fst (1, 1/0)
13:35:21 <lambdabot>   1
13:35:50 <erisco> > fst (1, undefined)
13:35:51 <lambdabot>   1
13:35:59 <erisco> > snd (1, undefined)
13:36:00 <lambdabot>   *Exception: Prelude.undefined
13:36:01 <haasn> Eduard_Munteanu: seems to work
13:36:04 <erisco> > (1, undefined)
13:36:05 <lambdabot>   (1,*Exception: Prelude.undefined
13:36:13 <Eduard_Munteanu> haasn: thanks
13:36:25 <typoclass> erisco: yes, that's laziness
13:37:39 <S_J> > reads "4" :: [(Int, String)]
13:37:40 <lambdabot>   [(4,"")]
13:39:24 <Taneb> Can someone show me an example of where reads returns a list of more than 1 element?
13:39:35 <Hafydd> @src reads
13:39:35 <lambdabot> reads = readsPrec minPrec
13:39:41 <Hafydd> @src readsPrec
13:39:41 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:39:51 <Eduard_Munteanu> Taneb: it doesn't
13:40:04 <Eduard_Munteanu> Taneb: it uses [] much like Maybe
13:40:11 <haasn> the heck
13:40:32 <Taneb> Eduard_Munteanu: that's annoying. I may write a sternly worded letter to the Haskell' committee
13:41:19 <typoclass> Taneb: how about readMaybe from Text.Read? it's part of base, these days
13:41:39 <Taneb> > reads "4blah"
13:41:40 <lambdabot>   []
13:41:42 <Taneb> :(
13:41:48 <haasn> > reads "()blah"
13:41:49 <lambdabot>   [((),"blah")]
13:42:01 <Taneb> > reads "4blah" :: [(Int, String)]
13:42:01 <lambdabot>   [(4,"blah")]
13:42:15 <Taneb> I am just slowly realising I do not really understand the Read class
13:42:58 <pentace> > reads "0x4blah" :: [(Int, String)]
13:42:59 <lambdabot>   [(75,"lah")]
13:44:03 <typoclass> Taneb: «reads "4blah"» will default to (), which it can't read from the String, giving an empty list
13:44:19 <Taneb> typoclass: yeah, I wasn't thinking.
13:44:36 <Taneb> > reads "\"hi\"not hi" :: [(String, String)]
13:44:37 <lambdabot>   [("hi","not hi")]
13:47:12 <deggis> pentace: oh, took a moment to figure where that 75 comes from. thanks for the teaser/scarer
13:47:26 <pentace> np :)
13:48:34 <typoclass> i think that you should usually match reads against [(x, "")] to exclude stuff like pentace's example
13:49:54 <deggis> i took that as an reminder to use a real parser in real applications with mystery inputs
13:50:51 <stacky> although, careful that [(x, "")] would reject trailing whitespace, if that isn't what you want :o
13:50:58 <S_J> I understood as running hpc twice would combine both results but it seems my snd run just overwrites the first...can I solve this`?
13:54:35 <typoclass> S_J: http://www.haskell.org/haskellwiki/Haskell_program_coverage seems to suggest there's a 'combine' command in hpc
13:55:45 <alexander__b> maybe not a haskell question, but I am writing a calculator that takes some args. what do I do about globbing?
13:55:53 <alexander__b> I want to be able to do foo 2 2 *
13:55:58 <alexander__b> but I need to do foo 2 2 \*
13:56:32 <haasn> alexander__b: require whitespace to terminate numbers, but don't for symbols?
13:56:36 <haasn> or am I misunderstanding
13:56:38 <alexander__b> I'm not really sure why this is happening, if it has to do with getArgs or what. I am modelling my calculator on pcalc (except RPN), and pcalc can do "pcalc 2 * 2"
13:56:44 <alexander__b> haasn: you are
13:56:45 <haasn> oh
13:56:47 <haasn> I am, yes
13:57:00 <alexander__b> haasn: "2 2 *" becomes 2 2 [all the files in pwd]
13:57:11 <alexander__b> according to putStrLn args
13:57:27 <geekosaur> alexander__b, that's the shell, your program can't do anything about it
13:57:33 <Gracenotes> oh... yeah... your shell takes care of that long before your program sees it
13:57:36 <alexander__b> geekosaur: why does it work well with e.g. pcalc?
13:57:47 <typoclass> alexander__b: oh, that's what you mean. yes, your shell will expand * . it's one of the special characters in the shell
13:57:51 <haasn> maybe pcalc looks for [all the files in pwd] and parses that as * ;)
13:58:03 <alexander__b> and why doesn't "2 2 *" work?
13:58:15 <haasn> try '2 2 *'
13:58:15 <alexander__b> pcalc 2 * 2 will whine about syntax error, but pcalc "2 * 2" works well.
13:58:18 <alexander__b> haasn: same
13:58:24 <haasn> oh, wait; that works here
13:58:37 <Gracenotes> double quotes shouldn't expand globs
13:58:39 <alexander__b> if you do echo "*", that should echo the * char in BASH.
13:58:41 <alexander__b> Gracenotes: exactly
13:58:49 <morricone> Hi, I'm working throught the typeclassopedia and I am stumbling over "((,) e)" what type ist that?
13:59:05 <haasn> alexander__b: are you looking at the arguments individually? "2 2 *" gets passed as one argument
13:59:10 <typoclass> alexander__b: yes. now try the command echo * , without the quotes. that's the difference
13:59:11 <haasn> where as 2 2 \* gets passed as three
13:59:14 <Taneb> morricone: firstly, it's not a type in of itself, it's a partially applied type function
13:59:22 <alexander__b> typoclass: I know
13:59:27 <Taneb> morricone: what is the type of (True, "hi")
13:59:38 <alexander__b> typoclass: I know BASH quite well. the problem is foo "2 2 *" fails as well.
13:59:57 <alexander__b> haasn: I am doing equation <- getArgs, and passing that as a [String].
14:00:09 <morricone> (Bool, String) (my haskell is a bit rusty)
14:00:31 <alexander__b> haasn: debugging a bit here. putStrLn $ unwords equation gives: 2 2 *, when using ""s.
14:00:34 <typoclass> alexander__b: well, that will run program 'foo' with one argument (a String with 5 characters)
14:00:41 <alexander__b> but the program does Prelude.read: no parse nonetheless
14:00:45 <Taneb> morricone: yep, and remember how you can turn infix functions into prefix functions, like "foo $ bar" -> "($) foo bar"?
14:00:49 <alexander__b> typoclass: oh yes, of course
14:00:53 <Taneb> Well, you can do the same with type constructors!
14:01:03 <haasn> alexander__b: yes, like I said; ["2 2 *"] vs ["2", "2", "*"]
14:01:05 <alexander__b> typoclass: that's the problem. :-)
14:01:13 <Taneb> (Bool, String) is the same as (,) Bool String, morricone
14:01:15 <Nisstyre> you can also pattern match on type constructors >.>
14:01:30 <morricone> ah, thanks Taneb
14:01:33 <alexander__b> so what would be a sane way of handling this?
14:01:45 <haasn> alexander__b: I guess treating the whole thing as a single string and using your own parsing function
14:01:54 <alexander__b> hm.
14:01:55 <Taneb> morricone: so (,) e takes another type and gives you the type of a tuple!
14:01:55 <geekosaur> concatenate all the parameters with spaces in between, use a real parser on the result
14:01:56 <alexander__b> thanks.
14:03:12 <alexander__b> geekosaur: I was thinking the opposite
14:03:25 <alexander__b> i.e. turning "2 2 +" into ["2", "2", "+"]
14:03:30 <typoclass> morricone: so ((,) e) is a 2-tuple that has 'e' as the type of the left half, and the type of the right still missing. (compare Either vs. Either String vs. Either String Int. ((,) e) is analogous to Either String)
14:03:42 <morricone> Taneb, so basically you i get (e, x) where e ist fixed and x is free?
14:04:01 <Taneb> morricone: pretty much!
14:04:06 <typoclass> morricone: yep
14:04:19 <morricone> thanks!
14:04:27 <Taneb> And because it's kind (kinda like a type for types) is "* -> *", you can make it an instance of Functor and whole bunch else of that shape
14:04:40 <alexander__b> does haskell have an appropriate function for that? i.e. to turn "2 2 +" into ["2", "2", "+"]
14:04:50 <typoclass> alexander__b: yes, 'words'
14:05:01 <alexander__b> err yes. I meant ["2 2 +"] for the former
14:05:14 <alexander__b> I could just check if one arg, and if so, words it.
14:05:25 <typoclass> alexander__b: yes that seems like an acceptable choice
14:05:44 <stacky> (>>= words) would do it
14:06:00 <alexander__b> stacky: I'm sadly not experienced enough to have a grip on those yet =/
14:06:11 <stacky> ah sorry
14:06:30 <stacky> concat (map words ["2 2 +"])
14:06:30 <alexander__b> but I guess ["2 2 +"] >>= words, right?
14:06:42 <alexander__b> err maybe not then
14:06:49 <stacky> no yeah, that's right
14:06:54 <alexander__b> yes, ghci agrees
14:07:09 <alexander__b> I just read about this yesterday
14:07:13 <tailcalled> >>= is defined as concatMap, which is concat . map
14:07:20 <typoclass> stacky: right :-) but i think it'll get confusing if someone mistakenly runs his program with more than one argument, and doesn't get a clear error message
14:07:20 <alexander__b> so it's nice to see a "real world example" this quickly. :-)
14:07:21 <tailcalled> for lists
14:07:29 <morricone> ah, so (,{,}) is just a type constructor like every other typ constructor and (a,b,c) is just syntactic sugar
14:07:37 <haasn> tailcalled: (<<=) is concatMap
14:07:39 <haasn> err
14:07:44 <haasn> (>>=)
14:07:53 <haasn> wait, no
14:08:03 <haasn> (=<<) that's the one
14:08:30 <tailcalled> whoops
14:09:00 <Taneb> morricone: barring tuple-weirdness, yeah
14:09:24 <haasn> Taneb: tuple-weirdness?
14:09:51 <Taneb> haasn: the fact that tuple constructors are in principle infinite scares me
14:09:58 <haasn> ah
14:10:25 <haasn> I think they're also distinct from ‘ordinary’ constructors in Template Haskell
14:10:31 <stacky> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Tuple.html
14:10:34 <stacky> isn't it beautiful
14:10:53 <haasn> haha
14:11:04 <typoclass> stacky: no, isn't :-)
14:11:11 <Gracenotes> morricone: yep
14:11:15 <stacky> ha
14:11:22 <Gracenotes> oh, I see that has been answered
14:11:41 <tailcalled> so, anyone else remember the discussion about comonads vs objects
14:11:45 <tailcalled> on /r/Haskell?
14:11:54 <Gracenotes> I read it
14:11:57 <benmachine> tailcalled: I remember that, yeah
14:12:05 <haasn> also beautiful
14:12:06 <typoclass> in everyone's defense, i guess 2-tuples account for 80% of all tuples, and 3-tuples for 80% of the rest, and so on
14:12:06 <haasn> https://raw.github.com/ekmett/lens/master/src/Control/Lens/Tuple.hs
14:12:17 <tailcalled> I've got an addition to my last part, but I'm not sure it's worth a new post
14:12:19 <tailcalled> http://www.reddit.com/r/haskell/comments/1gtb60/comonads_and_objects_revisited/
14:12:27 <Gracenotes> just use records bro.
14:12:40 <haasn> such a shame it has to be so complicated when 2-tuples ought to be enough for everyone
14:12:45 <typoclass> in other words, nobody ever uses an 9-tuple or a 17-tuple
14:12:48 <haasn> 3+ tuples might as well be syntax sugar for (1, (2,3))
14:12:49 <tailcalled> the comonad coalgebra interpretation is essentially the same as the greatest fixpoint interpretation
14:12:51 <haasn> and so forth
14:13:05 <Gracenotes> The main reason I see for using tuples is as multiple return values.
14:13:09 <haasn> main difference would be some boring things concerning ⊥
14:13:30 <typoclass> Gracenotes: right, absolutely
14:13:39 <Gracenotes> and perhaps easy interoperability between multiple arguments and multiple return values
14:13:55 <haasn> or pairs of values as in [(a, b)]
14:14:13 <alexander__b> w00t. works like a charm with my new "putStrLn $ solve $ parse equation". :-)
14:14:40 <Gracenotes> as an assoc list, yes, with Eq a (maybe Ord a), but... there are more space- and time-efficient structures :)
14:15:34 <Lethalman> or because data Foo a b = Foo a b is boring to write
14:18:45 <S_J> But I dont get what to do with HPC if I run the same program twice instead of combining two different programs.
14:19:13 <alexander__b> anyone know what's wrong when hdevtools: bind: resource busy (Address already in use)
14:19:41 <alexander__b> happens both inside and outside of vim
14:19:53 <osa1> stylish-haskell and hlint don't support MultiWayIf syntax ;-(
14:21:27 <morricone> So the funcator instance for ((->) e) is:    fmap f (->) e = (->) f e   right?
14:21:39 <osa1> is concat more efficient than `foldr (++) ""` ?
14:21:52 <haasn> “more efficient” by what metric?
14:21:59 <haasn> @src concat
14:21:59 <lambdabot> concat = foldr (++) []
14:22:06 <osa1> haasn: number of cons operations
14:22:15 <osa1> uh
14:22:15 <typoclass> osa1: in general, implement the simplest possible thing, then profile?
14:22:34 <haasn> “cons operations”?
14:22:57 <osa1> haasn: yes
14:24:39 <roboguy_> morricone: (->) is a type constructor, so it produces types not values. so I'm not sure what you mean
14:24:54 <roboguy_> by fmap f (->) e = (-> f e
14:25:28 <morricone> roboguy_: I'm still mixing these things up
14:25:35 <byorgey> morricone: you want to start by taking the type of fmap and substituting (,) e  for  f
14:26:04 <byorgey> I mean (->) e
14:26:22 * hackagebot haste-compiler 0.2 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2 (AntonEkblad)
14:27:10 <S_J> are the problem with darcs related to haskell or poor programming? i hear something about exponential merges
14:28:10 <haasn> S_J: neither
14:28:22 <haasn> S_J: they're related to the patch theory darcs operates on
14:30:54 <S_J> Math and computer science nerds only...
14:31:01 <caryatid> Hello!  Question from a new haskeller -- Going through the typeclassopedia, the exerercises ask for instance declarations. I was wanting to to declarations for already existing instances for the purpose of learning. Like `instance Functor Maybe where ...` Is there a way to do this w/o getting "Duplicate instnace declartaions"?
14:31:19 <shachaf> caryatid: Define the type yourself, with a different name.
14:31:51 <caryatid> shachaf: like `data MyMaybe a = MyJust | MyNothing` ?
14:31:57 <shachaf> Yep.
14:32:03 <caryatid> missed an "a" there ..
14:32:03 <shachaf> Except with an 'a' after MyJust.
14:32:13 <caryatid> jinx.  Thanks!
14:32:15 <rootnode> is there something like a parallel filter?
14:32:16 <typoclass> S_J: i think much of the criticism of darcs being slow refers to old versions. i've never noticed problems with darcs, speed or anything else (although i don't have repos with eleventy gigabytes of contents)
14:32:33 <S_J> so he starts off like that and then it turns out it doesnt...work...?
14:32:34 <shachaf> Also deriving (Show,Eq,Ord, etc.) might make your life simpler.
14:32:46 <shachaf> caryatid: Oh, an alternative is defining your own class.
14:32:52 <shachaf> instance MyFunctor Maybe where ...
14:33:13 <shachaf> Or you can do both. Not too much point in that.
14:33:18 <caryatid> oh, totally -- and that would be less work for complicated types?
14:33:25 <alexander__b> hm. rewrote my parse function. now it's broken. apparently I don't understand/I forgot the basics.
14:34:05 <alexander__b> http://bpaste.net/show/eAyeI78tiokmn5hc55Lt/ -- I assume something is really wrong here?
14:34:27 <alexander__b> I'm trying to catch emptylist, list that has more than one element, and uh the rest (should be an otherwise, I guess)
14:34:56 <shachaf> alexander__b: Well, the first two cases there seem to pretty much cover it all, don't they?
14:34:58 <alexander__b> oh. right. no. but. yes. trying to catch empty, length > 1, and one member.
14:35:02 <monochrom> lines 2-3 already cover all cases. line 4 is dead code.
14:35:15 <alexander__b> right
14:35:36 <typoclass> alexander__b: also, consider the 'error' function. i don't think you want the error message to show up inside of the list of Strings :-)
14:35:39 <typoclass> > error "omg"
14:35:40 <lambdabot>   *Exception: omg
14:35:47 <alexander__b> typoclass: I'm working my way there
14:36:10 <alexander__b> but right now I just need to check first if the list is empty, or has more than one member. and I'm failing, apparently.
14:36:32 <haasn> alexander__b: the third line is redundant
14:36:41 <haasn> every list either matches the first or second lines
14:36:51 <alexander__b> haasn: well, no. it is actually vital. it is just wrong. or the one before is.
14:36:54 <alexander__b> haasn: right.
14:37:02 <alexander__b> haasn: so that's not how I check if the list has length > 1
14:37:08 <alexander__b> which was what I did initially
14:37:15 <typoclass> haasn: magnificent stereo... no, three channels apparently :)
14:37:28 <haasn> oh
14:37:31 <haasn> I'm slow, too :(
14:37:35 <haasn> darn me for being alt tab so much
14:37:50 <alexander__b> originally I did if (length xs > 1) then xs else xs >>= words
14:37:56 <haasn> I go by “reply first, check other replies later”
14:37:58 <alexander__b> so this is what I want to try to do with pattern matching
14:38:21 <haasn> (_:xs) will match a list of length 1, mind
14:38:29 <morricone> byorgey: so the type would be: fmap (a -> b) -> ((->) a) -> ((->) b)
14:38:36 <haasn> also, why the extra case?
14:38:37 <alexander__b> haasn: yes, I see this now. should I be doing _:_:xs?
14:38:43 <haasn> > ["2", "2", "*"] >>= words
14:38:44 <lambdabot>   ["2","2","*"]
14:38:47 <haasn> no harm done
14:38:50 <alexander__b> wat?
14:39:12 <alexander__b> it's for
14:39:14 <alexander__b> ["2 2 +"] >>= words
14:39:20 <haasn> > ["2 2", "3", "*"] >>= words
14:39:21 <lambdabot>   ["2","2","3","*"]
14:39:31 <alexander__b> I'm not sure what your point is
14:40:01 <haasn> that I don't understand why you're special-casing lists of length > 1
14:40:34 <alexander__b> haasn: because the program might get ["2 2 +"] instead of ["2", "2", "+"], depending on how the argument is given on the command line.
14:40:42 <alexander__b> > ["2 2 +"] >>= words
14:40:43 <lambdabot>   ["2","2","+"]
14:40:55 <alexander__b> is for when the args doesn't already look like that
14:41:37 <haasn> that doesn't seem to answer my question
14:41:47 <alexander__b> haasn: consider these two ways of invoking the program:
14:41:50 <alexander__b> calc 2 2 +
14:41:53 <alexander__b> calc "2 2 +"
14:41:59 <haasn> yes
14:42:01 <monochrom> I don't know the precise specification of parse. but perhaps I can just randomly suggest to delete line 3. why not.
14:42:02 <alexander__b> I want both to give me ["2", "2", "+"]
14:42:17 <alexander__b> so in the latter case I do xs >>= words. in the former I just leave it alone.
14:42:18 <haasn> yes
14:42:35 <alexander__b> so,
14:42:37 <alexander__b> parse [] = ["err"]
14:42:39 <alexander__b> parse (_:_:xs) = xs
14:42:41 <alexander__b> parse xs = xs >>= words
14:43:03 <haasn> that will turn ["2", "2", "*"] into just "*", min
14:43:05 <haasn> mind*
14:43:08 <alexander__b> er
14:43:12 <alexander__b> oh
14:43:16 <alexander__b> lol
14:43:17 <haasn> but still
14:43:24 <roboguy_> morricone: not quite. remember, in this case f == (->) e
14:43:35 <alexander__b> haasn: so parse (x:y:xs) = x:y:xs
14:43:36 <haasn> my point stands; why are you trying to avoid using “>>= words” in the former scenario?
14:43:37 <alexander__b> :-P
14:43:46 <alexander__b> haasn: ohhhh. now I get your point. :-)
14:43:55 <haasn> the function is idempotent; and besides, what if somebody inputs something like:  calc "2 2" "*"
14:43:56 <alexander__b> I'm not the brightest nor the most experienced. :-P
14:44:00 <haasn> with your method that would error
14:44:19 <alexander__b> right. so.
14:44:21 <alexander__b> parse [] = ["err"]
14:44:23 <alexander__b> parse xs = xs >>= words
14:44:30 <haasn> for example, yes
14:44:39 <haasn> the concerns about ["err"] raised earlier still stand, obviously
14:44:40 <morricone> roboguy_: so fmap (b -> a) -> ((->) a) -> ((->) b) ?
14:44:44 <typoclass> alexander__b: friendly question, would you mind reducing the number of chat lines a little bit (e.g. "oh er lol" could easily be combined in 1 message)
14:44:46 <alexander__b> except that I need to use Error. but first I want to make it work, heh.
14:44:53 <morricone> That would make more sense anyway
14:45:09 <alexander__b> typoclass: yes, sorry.
14:45:25 <roboguy_> morricone: no, the (a -> b) is right. look at the other part. generally, fmap :: (a -> b) -> f a -> f b
14:45:29 <typoclass> alexander__b: thanks. don't worry :-)
14:45:33 <roboguy_> morricone: but you need to replace the two fs
14:45:35 <haasn> morricone: I think you swapped ‘a’ and ‘b’ somewhere there; that also doesn't kind-check
14:45:42 <stacky> morricone: since f is ((->) e), then f a is ((->) e a), which is the same as (e -> a)
14:46:15 <alexander__b> ghc-mod whines about main not having a type signature, but I read somewhere that it's not required/usually done. should I do main :: IO () or not? what is more common?
14:46:37 <shachaf> You should have top-level type signatures.
14:46:39 <haasn> I personally do main :: IO ()
14:46:53 <alexander__b> OK, thanks.
14:47:05 <haasn> it's definitely not required, but top-level type signatures are fairly standard practice so either you put up with the error message or you just include it
14:47:10 <typoclass> alexander__b: i agree it's a bit redundant, but i usually write down the main :: IO () just to silence that warning
14:47:38 <hpaste> morricone pasted “Typeclassopedia Excerise Functor 1.” at http://paste.tryhaskell.org/90730
14:48:01 <alexander__b> ignoring how LOL this code probably is to someone who knows what they are doing; ghc-mod whines about "Defaulting the following constraint(s) to type 'Double' for the f function: http://bpaste.net/show/AXO1F26JynBcDyAjhmAH/
14:48:11 <morricone> Could someone take a look at that?
14:48:11 <alexander__b> how do I silence this?
14:48:27 <roboguy_> morricone: you have (b -> a) instead of (a -> b) and the definition of fmap isn't quite right
14:48:39 <mstksg> this is a quick/dumb question but where is <$> defined?
14:48:42 <haasn> alexander__b: by including a type signature ;)
14:48:51 <monochrom> <$> is in Control.Applicative
14:48:56 <shachaf> mstksg: Hoogle is a good way to answer questions like that!
14:48:58 <alexander__b> haasn: how do you do it in that case, when using where f =?
14:49:00 <shachaf> @hoohle <$>
14:49:01 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
14:49:01 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
14:49:06 <shachaf> @where hoogle -- web interface
14:49:07 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:49:14 <haasn> alexander__b: just have ‘f :: whatever’ as an extra line, aligned with the other ‘f’ cases
14:49:23 <haasn> same way you'd do it on the top level, basically
14:49:43 <alexander__b> haasn: so where [type signature] \n f this = that -- is acceptable?
14:49:51 <mstksg> shachaf thanks haha.  google wasn't much help for me
14:50:07 <haasn> alexander__b: sure
14:50:34 <S_J> So could you give a reason why it is not necessarily a good idea to add tests just to get 100% code coverage?
14:50:36 <roboguy_> schlumpi_: wait, it worked even though there was a typo?
14:50:39 <haasn> alexander__b: also, I would personally start prettifying that by swapping the two parameters of ‘f’, then moving the pattern match to a helper function
14:50:40 <roboguy_> err, shachaf
14:51:01 <haasn> like f "*" = op2 (*); with op2 f (x:y:xs) = f x y : xs
14:51:04 <shachaf> roboguy_: Yes.
14:51:06 <alexander__b> haasn: swapping the parameters?
14:51:18 <alexander__b> haasn: as for the latter -- I was intending to.
14:53:37 <typoclass> alexander__b: a "defaulting" warning usually means that you didn't specify a type, and you can shut up the warning by writing down the type. alternatively, you can often shut it up by turning off the monomorphism restriction
14:53:41 <typoclass> @where dmr
14:53:41 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:53:57 <alexander__b> typoclass: I knew this, I just didn't know that you could put a type signature in a where like that.
14:54:36 <alexander__b> although, I'm not really sure WTH the type signature should be for f, heh.
14:54:45 <haasn> by the looks of it
14:54:54 <haasn> :: [Double] -> String -> [Double]
14:55:04 <haasn> (if you want doubles, that is)
14:55:17 <stacky> (you can also include type signatures in lets in the same manner, for future reference)
14:55:25 <alexander__b> stacky: thanks.
14:55:29 <typoclass> alexander__b: keep in mind that floats (doubles) can be pretty sneaky fellows
14:55:32 <alexander__b> haasn: yes. thanks.
14:55:56 <haasn> or more generally :: (RealFrac a, Floating a) => [a] -> String -> [a] -- is one of these constraints redundant?
14:56:12 <alexander__b> typoclass: yes; I'm just not worried about that ATM. I'm teaching myself really basic stuff here, heh. but I'll read up on that, and I'll find out how to use Error. I'd also like to be able to use Ratios in some sane manner.
14:57:11 <typoclass> alexander__b: good plan! Ratio is good to know
14:57:23 <parcs> > sqrt 10
14:57:24 <lambdabot>   3.1622776601683795
14:57:26 <haasn> be careful with Ratio, you don't get a Floating instance
14:57:28 <parcs> what a cool number
14:57:35 <alexander__b> I'll also have to figure out how Infinity works.
14:57:40 <haasn> eg. pi, cos, sin, tan etc.
14:57:41 <alexander__b> haasn: that's what I was referring to.
14:58:11 <haasn> if you want more precision than Double offers you, you could use something like CReal ;)
14:58:16 <hpaste> morricone revised “Typeclassopedia Excerise Functor 1.”: “Fixed definition of fmap” at http://paste.tryhaskell.org/90730
14:58:24 <alexander__b> haasn: I'll keep it in mind, thanks.
14:58:31 <haasn> there's also Fixed, which is for fixed-length floating points that don't suffer from the NaN/Infinity stuff iirc
14:58:39 <haasn> you can specify the precision for those as well
14:59:10 <haasn> morricone: your type signature in the Either case is wrong, mind
14:59:21 <haasn> ‘Either a’ isn't a valid type there; Either takes two parameters
14:59:39 <alexander__b> I'll keep on hacking on this tomorrow. thanks for today's help. I started this during the weekend, with no Internet available, so it's been nice to have some questions answered. :-)
15:00:08 <morricone> haasn: yeah I forgot to fix that
15:00:36 <haasn> morricone: your ‘fmap’ for (->) e doesn't type-check either, though it's correct in principle
15:00:39 <haasn> you need to swap the parameters
15:00:40 <hpaste> morricone revised “Typeclassopedia Excerise Functor 1.”: “Fixed type of fmap” at http://paste.tryhaskell.org/90730
15:00:59 <haasn> :t (.)
15:01:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:01:51 <haasn> the ‘outer’ function comes first
15:02:27 <morricone> I see
15:02:43 <morricone> so fmap f g = f . g ?
15:02:49 <haasn> correct
15:02:56 <roboguy_> morricone: also, your Either instance isn't quite right
15:03:04 <haasn> note that this is equal to: fmap f g = (.) f g
15:03:14 <haasn> I'm sure you can think of a way to reduce that ;)
15:04:31 <morricone> btw, I like learning haskell, I feel lost like when I started programming :)
15:04:57 <typoclass> morricone: ;-)
15:08:31 <yesthisisuser> Hi guys. I have a question: I know what lifting means in the context of FP. I have a somehow vague idea of what it means in type theory. Is there any correlation between these two concepts?
15:09:18 <haasn> ‘lift’ is a highly overloaded term, afaik
15:09:29 <yesthisisuser> so it seems
15:09:47 <S_J> :t liftM¨
15:09:48 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:09:49 <S_J> :t liftM
15:09:50 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:09:53 <haasn> :t lift
15:09:54 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:09:55 <S_J> :t >>=
15:09:56 <lambdabot> parse error on input `>>='
15:10:23 <S_J> how do i msg lambdabot again?
15:10:47 <ChongLi> :t (>>=)
15:10:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:11:21 <S_J> > liftM (+1) (Just 6)
15:11:22 <lambdabot>   Just 7
15:11:29 <S_J> @src liftM
15:11:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:12:12 <S_J> > mylift f v = v >>= \r -> return $ f r
15:12:12 <lambdabot>   <hint>:1:12: parse error on input `='
15:12:18 <Pip> Is Haskell deprecated old language?
15:12:19 <typoclass> S_J: try "/query lambdabot", or double-clicking the name lambdabot in your chat client
15:12:44 <k00mi> I can't believe there is no safe indexing function for lists on hackage (except in xmonad-contrib)
15:12:51 <S_J> > mylift f v = v >>= \r -> return $ f r in mylift (+1) (Just 6)
15:12:51 <lambdabot>   <hint>:1:12: parse error on input `='
15:13:04 <typoclass> Pip: it surely isn't! development is lively, both of libraries and the compiler
15:13:05 <S_J> > let mylift f v = v >>= \r -> return $ f r in mylift (+1) (Just 6)
15:13:06 <lambdabot>   Just 7
15:13:54 <Gracenotes> generally lifting is into a functor of some kind, but you can lift values or functions...
15:14:00 <S_J> k00mi: because you dont want to index a list?
15:14:07 <Gracenotes> these usually mean different things.
15:14:38 <Gracenotes> or maybe not, but it seems plausible.
15:14:59 <typoclass> k00mi: you mean, given a list and an element, find the first index?
15:15:08 <Pip> typoclass, But is it a state of the art language ever created?
15:15:16 <k00mi> S_J: well, I do
15:15:26 <k00mi> typoclass: no, given a list and an index, maybe give an element
15:15:58 <S_J> how can lift take 1 arg and no function and still change the monad? what does it do? what is a monad transformer?
15:16:03 <S_J> @src lift
15:16:04 <lambdabot> Source not found. My mind is going. I can feel it.
15:16:52 <yesthisisuser> what is the equivalent of @src in ghci?
15:16:55 <S_J> k00mi: well maybe you are using the wrong data structure if you need to idnex it.
15:17:17 <inf-groupoid> S_J: You cannot expect a type class function to have a single definition. :-|
15:17:28 <typoclass> Pip: i would call haskell state of the art in many ways (in particular the type system)
15:18:10 <geekosaur> ghci doesn't have a @src. for that matter, lambdabot only barely does (it's an out of date manually compiled database)
15:18:27 <Pip> typoclass, Do you use ghci?
15:18:30 <yesthisisuser> i guess :list is the closest thing
15:18:31 <typoclass> yesthisisuser: i don't think there is one. (@src in lambdabot is basically looking it up in a plaintext file that someone once made.) what you can do is click 'source' on pages like this http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html (right hand side)
15:18:34 <typoclass> Pip: sure
15:18:48 <Pip> typoclass, Do you use it colored output?
15:19:16 <typoclass> Pip: i don't think ghci has colored output. i wish it had
15:19:28 <Pip> It does
15:21:07 <typoclass> Pip: interesting, how do you turn it on?
15:21:32 <yesthisisuser> i am wondering that too...
15:21:43 <Pip> typoclass, how do you think it has colored output ---> http://learnyouahaskell.com/starting-out#ready-set-go
15:21:54 <Gracenotes> http://new-hackage.haskell.org/package/lambdabot/src/State/source
15:22:50 <Gracenotes> a lot of these definitions will be used if you ask GHC to not do any stdlib optimizations whatsoever
15:23:17 <hpaste> morricone revised “Typeclassopedia Excerise Functor 1.”: “Fixed old exercises and added new” at http://paste.tryhaskell.org/90730
15:23:37 <morricone> I hope everything works out now, I tried checking it with ghc beforehand
15:24:05 <shachaf> morricone: That'll surely be less confusing if you put "::" after fmap, even in the comments.
15:24:25 <Gracenotes> the definitions look pretty right
15:24:45 <Gracenotes> er, although, why the 'Right' in ((,) e)?
15:24:53 <Gracenotes> besides that, good
15:25:08 <morricone> typo
15:25:36 <k00mi> S_J: I have a static index of 2 and don't see any other method without much hassle
15:25:42 <morricone> cool, thanks everyone!
15:26:20 <shachaf> If your Functor instance typechecks and isn't "weird" then it's probably correct.
15:26:30 <roboguy_> k00mi: what about pattern matching?
15:26:33 <shachaf> (NB: "weird" means "incorrect", so this is a tautology.)
15:26:45 <S_J> can a fold by aborted prematurely?
15:27:26 <S_J> k00mi: you mean your list is always [a,b,c] ? so it is never longer and thus the O(n) issue is irrelevant?
15:27:34 <Gracenotes> isn't 'abort' a feature of imperative languages?
15:27:37 <typoclass> Pip: right, but i think the author of the 'learn you a haskell' took the un-colored text and put it through a program that added colors. ghci doesn't do that by itself, unfortunately
15:27:54 <roboguy_> k00mi: like case xs of (_:_:x:_) -> ...; _ -> ...
15:27:57 <S_J> k00mi: is it always length 3?
15:28:18 <k00mi> S_J: no, but I always want the second element
15:28:30 <k00mi> roboguy_: I'd rather write my own safe indexing function
15:28:56 <hpaste> S_J pasted “safe index, general” at http://paste.tryhaskell.org/90735
15:28:57 <k00mi> actually, pattern matching might be an option
15:29:20 <typoclass> k00mi: if your index is 2, then i suggest what roboguy said (it works for lists of any length). and yes, it won't be difficult to write the indexing function. i guess it's a good exercise
15:30:18 <typoclass> k00mi: in principle you're right. it's weird that we don't have a !!-like function :: [a] -> Int -> Maybe a. i guess that shows that indexing isn't much used anyway ...
15:30:39 <k00mi> typoclass: yet there is the unsafe version
15:31:54 <S_J> typoclass: yes that is what i was saying, one might use !! for testing but indexing isnt used in real code since it is linear
15:32:38 <k00mi> S_J: I know that, but it is no worse than pattern matching for constant indices
15:33:35 <S_J> use the one i posted...it is safe
15:33:37 <typoclass> S_J: i would say that !! is a somewhat uncommon function, but i don't think that 'real code' uses only sub-linear algorithms
15:35:08 <banister> where is sequenceA defined?
15:35:36 <typoclass> banister: check hoogle! it will mention the module and package
15:35:39 <S_J> a fold cant be exited right?
15:35:39 <typoclass> @where hoogle
15:35:39 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:35:41 <typoclass> :-)
15:36:26 <S_J> typoclass: no but i mean using !! you might use it in a context which would ame your whole algorithm quadratic. linear is good by itself obv
15:37:18 <banister> thx
15:37:31 <banister> typoclass: are there any ghci plugins that provide access to hoogle?
15:37:56 <S_J> aso would you implement index with explicit recursion like i did?
15:38:00 <typoclass> banister: there's a command-line tool ("hoogle") which you can install via cabal
15:38:20 <banister> typoclass: cool
15:38:28 <banister> typoclass: is there a way to run a shell command from ghci? :D
15:38:30 <typoclass> banister: oh also, the lambdabot plugin of course. lambdabot is available privately via "/query lambdabot"
15:38:38 <roboguy_> banister: you can access it with :!hoogle
15:39:08 <banister> man, cabal needs to be less noisy ;)
15:39:10 <k00mi> S_J: thanks, but I'll go with pattern matching
15:39:13 <typoclass> banister: yep, see :help in ghci. :! seems to be what you need
15:39:19 <banister> thx
15:40:07 <yesthisisuser> hence the :!hoogle command mentioned by roboguy_
15:40:12 <Hafydd> :!clear is great,
15:40:13 <hpaste> k00mi annotated “safe index, general” with “safe index, general (annotation)” at http://paste.tryhaskell.org/90735#a90736
15:40:25 <k00mi> S_J: why that second function and not like that?
15:40:54 <roboguy_> yesthisisuser, banister: yeah, you can even do stuff like :!hoogle lift | less
15:41:01 <banister> roboguy_: very cool
15:41:25 <yesthisisuser> Hafydd: i know! that's how i discovered :! in the first place
15:42:13 <S_J> :t listToMaybe
15:42:14 <lambdabot> [a] -> Maybe a
15:42:26 <yesthisisuser> makes sense
15:42:29 <yesthisisuser> :)
15:42:39 <typoclass> S_J: listToMaybe is essentially "safeHead"
15:43:47 <osa1> I have a newtype wrapping StateT, how can I make it instance of MonadBaseControl? http://hackage.haskell.org/packages/archive/monad-control/0.3.2.1/doc/html/Control-Monad-Trans-Control.html#t:MonadBaseControl
15:45:08 <S_J> k00mi: yours is better i guess
15:46:21 <k00mi> ok
15:48:55 <haasn> osa1: simplest way would be GeneralizedNewtypeDeriving, I guess
15:48:57 <haasn> but be careful with that
15:56:24 * hackagebot data-binary-ieee754 0.4.4 - Parser/Serialiser for IEEE-754 floating-point values  http://hackage.haskell.org/package/data-binary-ieee754-0.4.4 (JohnMillikin)
16:03:20 <NemesisD> do i need to know set theory to learn category theory?
16:04:03 <monochrom> no, but it may help. 2nd but: you may already know enough set theory without realizing it.
16:05:09 <NemesisD> i'm looking for some resources to learn/retain category theory. i've had some exposure to it at meetups and it falls out of my brain not long thereafter
16:05:14 <monochrom> like, 0 ∈ {2, {2, 3}} ∪ {4}, true or false? if you know, you're good
16:05:36 <Gracenotes> this recently published thing may be a good thing
16:05:45 <monochrom> practice is how to retain. if you don't use it, you don't retain it
16:05:56 <Gracenotes> recently revised, rather. http://arxiv.org/abs/1302.6946
16:06:29 <Gracenotes> there's also Pierce's book, which I haven't read much of
16:06:34 <Gracenotes> curiously, my university library had it
16:06:39 <monochrom> I retain Chinese because I will read and write on Chinese web forums. that is essentially the only cause why I still retain Chinese
16:06:45 <monochrom> s/will/still/
16:07:39 <monochrom> if you won't apply category theory, you won't retain. this is unchangeable.
16:08:36 <NemesisD> monochrom: i wonder if this is an argument that i don't need to learn it. i'm not really interested in practicing category theory for the sake of category theory. i'm more interested in being a better haskell programmer and understanding more code that currently makes no sense to me
16:08:43 <k00mi> NemesisD: current reddid thread on that topic: http://www.reddit.com/r/haskell/comments/1ht4mf/books_on_category_theory_for_beginners/
16:09:19 <NemesisD> k00mi: yep. that's what brought me here. once i started looking up expensive mathematics books on amazon i started questioning my motivations
16:09:26 <monochrom> I can't retain adjunction, I seldom use it. I retain Galois connection (an easy special case), I use it once in a while, and it's really easy.
16:09:37 <k00mi> NemesisD: I see
16:10:13 <Gracenotes> although, as I linked earlier, this is a very interesting application of category theory. http://www.reddit.com/r/haskell/comments/1ht33e/bottomup_type_annotation_with_the_cofree_comonad/
16:10:14 <haasn> aren't adjunctions the bread and butter of category theory?
16:10:26 <Gracenotes> you don't need category theory to come up with it, but it makes it incredibly easy.
16:10:30 <haasn> (until you get to some wider, more elegant generalization)
16:10:35 <monochrom> that depends on who you talk to
16:10:54 <johnw> adjunctions arise in lots of places in Haskell.  Even currying is an adjunction
16:11:24 <NemesisD> my main goal is to write understandable, concise code and understand others haskell code
16:11:25 <typoclass> johnw: interesting, what does that tell me about currying?
16:11:31 <monochrom> I am more interested in limits. I don't run into non-Galois-connection adjunctions.
16:11:45 <johnw> typoclass: there is a paper by Ralph Hinze where he investigates that particular adjunction in some detail, I'd recommend reading there
16:11:48 <Gracenotes> Abstracting in a given direction can do any mix of adding and/or subtracting accidental and/or essential complexity.
16:11:49 <NemesisD> i come from a perspective that excessive cleverness is a Bad Idea for software development
16:11:55 <Gracenotes> That's just software engineering more than anything else.
16:12:03 <johnw> "Generic Programming with Adjunctions"
16:12:26 <haasn> depends on whether or not it's maintainable cleverness ;)
16:12:29 <typoclass> johnw: ok so you mean, allows better reasoning about code if it involves curried functions?
16:12:52 <johnw> typoclass: it means you can model currying use the same abstract reasoning as you might apply to any adjunction
16:13:47 <johnw> the adjunction in this case being: Hom((a,b),-) -| Hom(a -> b,-)
16:14:08 <dolio> monochrom: What about 0 ∈ 4, true or false? :)
16:17:55 <johnw> typoclass: as for what it tells you about currying
16:19:25 <johnw> typoclass: because it's an adjunction, and not an isomorphism, it means that although the y represent an equivalence in one direction (that is, with both representations, given an 'a' I can give you its corresponding 'b'), in the other direction there is no mapping (given a 'b', "a -> b" will not give me an 'a')
16:20:20 <johnw> although, right there I was mentioned the adjunction between (a,b) -| (a -> b), sorry to confuse
16:20:36 <roboguy_> dolio: doesn't that depend on how we're defining numbers?
16:20:38 <typoclass> johnw: oh ... "i can curry, but not uncurry"?
16:20:42 <johnw> but currying is that same adjunction just between functors now
16:20:57 <johnw> typoclass: it means that if you curry, you lose some flexibility
16:21:34 <haasn> the canonical ST definition of 4 is {0,1,2,3}, right?
16:21:47 <johnw> with a function (a,b) -> c, you have both 'a' and 'b' from a single application.  with a function a -> b -> c, from a single application you only get 'a'
16:22:37 <johnw> the nature of adjunction in most cases that I've seen is that you lose something (flexibility, structure, etc.) going from left to right
16:22:57 <Gracenotes> 'you' in this case is the function, yes
16:23:04 <Gracenotes> not the... caller, you might say
16:23:29 <johnw> right
16:24:24 <typoclass> johnw: ok thanks a lot
16:24:36 <banister> just installed hoogle via cabal, but the executable is not available :/
16:24:52 <banister> are my paths all screwed up? where are cabal executables stored?
16:25:02 * banister just intsalled the haskell platform on osx
16:25:46 <roboguy_> banister: I think, for me at least, it's in /Users/david/Library/Haskell/bin/
16:26:27 <banister> roboguy_: did u have to manually add that to your PATH ?
16:26:40 <joelteon> yeah
16:27:03 <typoclass> banister: in your shell, try "echo $PATH"
16:27:38 <MitchellSalad> is there a monad transformer for (Either a) that isn't ErrorT?
16:28:32 <MitchellSalad> i'm trying to sequence a bunch of system calls together, and if any of them fail, i want to catch a (stdout, stderr, exit_code) triple as the Left, but it seems like ErrorT will only throw a String error
16:28:49 <MitchellSalad> well, an 'Error', which is basically just a String
16:32:20 <johnw> MitchellSalad: there is EitherT, in the either package
16:32:36 <typoclass> MitchellSalad: how about http://hackage.haskell.org/package/either ? there's a second package, but i forgot the name and afaik it's essentially the same
16:32:58 <dolio> roboguy_: Yes, it does. But many (including me) consider it a mark against a theory that you can even consider such a question.
16:33:04 <johnw> the "errors" package also nicely re-exports either
16:33:18 <johnw> plus having lots of other nice functionality
16:36:04 <S_J> so, unittesting, property based testing, code coverage. what more is there to test your code?
16:36:27 <johnw> typoclass: I came across a very neat summary of adjunctions the other day.  If an isomorphism between functors F and G means that F . G = Id, and G . F = Id, having an adjunction means that F . G . F = F, and G . F . G = G, because F . G = Id (but G . F /= Id!)
16:36:28 <MitchellSalad> johnw, typoclass thanks guys =)
16:36:58 <johnw> so in that sense, you can look at an adjunction as "half of an isomorphism"
16:37:11 <typoclass> johnw: hm ok
16:37:36 <roboguy_> dolio: but aren't, for instance, dedekind cuts a valid set-theoretic way to define numbers? wouldn't 0 ∈ 4 be false in that case?
16:37:54 <dolio> It would be false.
16:38:02 <johnw> composing the functors one way is a no-op, but the other way is not.  Btw, G . F, the non-composable directions, is the M in Monad (G . F = M)
16:38:37 <byorgey> johnw: if F and G are adjoint it is not necessarily the case that F . G = Id.
16:38:52 <roboguy_> dolio: and in the case of a peano-style definition, it would be true right?
16:38:52 <johnw> how would I express it correctly?
16:39:27 <dolio> There is more than one way to define the natural numbers in ZF, so it depends.
16:39:31 <johnw> I thought that F . G -> I was the counit transformation
16:39:51 <johnw> hmm.. maybe I used "=" where I did not mean equality
16:39:59 <byorgey> johnw: yes, there has to be a natural transformation  F . G -> I, but that is very different than saying  F . G  is the identity
16:40:12 <johnw> ok, thanks for clarifying that
16:42:24 <roboguy_> dolio: well, i know, that's what i'm saying. that's why the question seems valid to me. unless you mean considering 0 ∈ 4?
16:43:00 <dolio> Yes. I mean, why isn't '0 ∈ 4' just ruled out as a proposition?
16:43:33 <dolio> Basically ZF has no abstraction.
16:43:37 <roboguy_> ahh, I see. that makes sense, never mind
16:47:29 <Ghoul_> is it possible to add instances for lists
16:47:38 <Ghoul_> /s/lists/list types/
16:49:06 <inf-groupoid> dolio: Set theory feels a lot like an untyped assembly language for mathematics. Sets are not really the objects you want to deal with, they are how you encode the objects you want to deal with so you can keep the theory happy. :-|
16:49:24 <crdueck> Ghoul_: the usual trick is to use a newtype
16:49:48 <Ghoul_> even if it's just lists in general?
16:50:17 <crdueck> yes, you wont pay any runtime performance penalty
16:50:43 <crdueck> just define a newtype wrapping a list, and redefine whatever class instances you need
16:51:01 <Ghoul_> ok, thanks
16:51:18 <FreeFull> Instead of set theory you could use homotopy type theory
16:51:20 <FreeFull> Seems nicer
16:52:29 <dolio> inf-groupoid: Yes. But then you can't escape that you've built everything is made out of sets, so you can ask some seemingly nonsense questions. It's kind of like everything being a subclass of Object in Java. So even if you don't know anything about a type, you know you can ask for a string representation, or compare it to anything else for equality, and so on.
16:54:30 <inf-groupoid> dolio: Yeah, like "is 3 in 4"? Peano arithmetic says yes, other encodings of the natural numbers may say no, but the real correct answer is "the question makes no sense".
16:54:59 <dolio> Right.
16:55:06 <dolio> Untyped lambda calculus has the same problem, too.
16:55:12 <dolio> You can encode lots of things using functions.
16:55:23 <dolio> But then you can always apply your things to anything else.
16:55:31 <monochrom> truth or dare! Y = 0?
16:55:36 <dolio> Because everything is a function.
16:56:45 <dolio> forall x. 0 x = false x?
16:57:40 <berdario> I was reading about having Reference Counting in Haskell, and how (even ignoring cycles) it could be a little bit of a problem to implement (pure languages tends to do a lot more allocations)... so, assuming that one's not satisfied with C's undefined behaviours and somewhat weak typing... what would you use for a personal/toy VM project, with garbage collection and all? (thus ruling out languages that don't have a
16:57:40 <berdario> deterministic memory release model I guess)
16:58:52 <jmcarthur> berdario: GC is surprisingly easy to write. the tricky thing is making it fast
16:58:59 <berdario> I was thinking about Rust, but maybe you have some other suggestion
16:59:15 <jmcarthur> oh you are asking about language, i see
17:00:30 <berdario> jmcarthur: I know a bit about the theory, but wouldn't implementing a GC engine on a GC-collected language (implementation) be a little pointless?...
17:00:39 <typoclass> berdario: hi, how do you mean "having reference counting in haskell"? you want to write a toy language, and are considering haskell for implementing the compiler and runtime?
17:00:51 <berdario> yes I started wondering today why there wasn't any Haskell runtime+compiler written in Haskell :)
17:01:00 <berdario> typoclass: yes
17:01:35 <typoclass> berdario: i think almost all of ghc is written in haskell
17:01:44 <jmcarthur> berdario: well, ghc is written in haskell. it's just the runtime that is not, but that's just because a runtime written in haskell would, well, need a haskell runtime of its own
17:02:44 <berdario> jmcarthur: oh, ok... assuming that the ghc runtime would be rewritten from scratch in 2013, with no consideration of legacy compatibility, support for C FFI and such... what would you pick?
17:03:38 <monochrom> I would design a new language for writing GHC runtime
17:04:17 <jmcarthur> berdario: i think i'd still go with the way ghc does it. haskell for the compiler, some decent intermediate language like llvm for the low level stuff, probably just C for the runtime itself.
17:04:19 <dolio> You could conceivably write it in a Haskell-looking language with a very limited instruction set, but then you'd be writing two compilers.
17:05:04 <monochrom> I just want to beg the question "who writes the runtime for your new language" :)
17:05:15 <typoclass> berdario: well, the haskell runtime requiring a haskell runtime is admittedly a bit of a catch-22 :-) but the runtime of some other language requiring a haskell runtime seems like no issue to me?
17:09:23 <dolio> You might be able to write an EDSL in Haskell that would have the right properties for writing runtime systems, and then write a Haskell runtime system in that.
17:09:31 <dolio> That sounds like the best solution.
17:11:56 <berdario> uh, nice answers :) I forgot that only old versions of ghc had the C-backend... I guess that leveraging LLVM would be a good idea... typoclass: yes, but I was wondering about implementing a different GC on top... I'm just brainstorming
17:13:45 <dolio> I don't know the status of Rust, for instance.
17:14:08 <dolio> So I can't answer any questions about it. And I wouldn't be surprised if many other people here are in the same boat.
17:14:57 <dolio> There are several other similar languages that I also don't know much about.
17:15:31 <shachaf> Rust seems pretty nice, for the niche it's going for.
17:15:45 <berdario> uh, similar languages? even if you don't know much... what do you have in mind, if they would be fit for the job?
17:15:54 <dolio> Cyclone?
17:16:06 <berdario> Cyclone is quite dead afaik
17:16:13 <dolio> Okay, then.
17:16:23 <berdario> (last changes in 2006, if I remember correctly)
17:17:49 <dolio> I think bitc was targeting that niche, as well. But it's dead, too, last I heard.
17:18:26 <berdario> I thought about Ada, but Gnat is only x86
17:21:16 <berdario> uhm, BitC seems to have been declared dead in 2012, but interesting nonetheless: http://www.coyotos.org/pipermail/bitc-dev/2012-March/003300.html
17:24:30 <AsgardBSD> Since i started learning Haskell, i used Learn you a haskell
17:24:46 <AsgardBSD> But the data type chapter is not verry clear
17:26:06 * Slick` I have very fresh credit cards for sell, from my own sniffers and logs ;) many different bins and countries :) 10$ each, write me any interested in linotrecias@gmail.com
17:26:50 <hpaste> typoclass pasted “toy VM” at http://paste.tryhaskell.org/90737
17:26:59 <typoclass> berdario: ok just as a minimal thought experiment :-) what's wrong with this? ^^
17:27:50 <jfischoff> is there an example anywhere showing how to use the ghc api to collect all of the exported names of module starting with a import declaration?
17:28:44 <AsgardBSD> Nah forget what i said, i think i just made sense out of the data type part (chapter 8 i was talking about)
17:29:07 <typoclass> jfischoff: i'd assume that the source of ghci does that somewhere near where the :browse command is handled
17:29:22 <jfischoff> good idea
17:30:26 <typoclass> jfischoff: ... though on second thought, i don't even know if it uses the regular ghc api, or something more mystical
17:30:50 <jfischoff> typoclass: not sure if there is anything more mystical
17:31:01 <typoclass> AsgardBSD: if you have any particular questions, feel free to ask :)
17:31:08 <typoclass> jfischoff: very good :)
17:31:10 * jfischoff is looking at ghc source
17:32:24 <AsgardBSD> NExt summer, i will make a compagnie of indie developper with some friend... we will surely use Haskell (some of our goal will be to use uncommon language to make great thing)
17:32:49 <typoclass> AsgardBSD: sounds great
17:32:55 <AsgardBSD> But does haskell will make our work harder?
17:33:09 <AsgardBSD> Because almost every programming language can do everything
17:33:18 <AsgardBSD> but there are some better suited for some task
17:33:33 <AsgardBSD> so does using haskell will be counter productive?
17:34:15 <benmachine> AsgardBSD: it depends on what you are trying to do, a bit
17:34:24 <benmachine> there are some tasks haskell is not well-suited to
17:34:31 <AsgardBSD> a game loop
17:34:38 <benmachine> and some that it is in principle well-suited to but the libraries are undeveloped or similar
17:34:43 <AsgardBSD> (well, a recursive game loop.....)
17:34:50 <benmachine> what kind of game?
17:34:58 <AsgardBSD> we didnt really decided yet
17:35:35 <benmachine> are you aware of http://www.haskell.org/haskellwiki/Frag ?
17:35:46 <erisco> haha :D finally got it working
17:36:10 <berdario> typoclass: it would work fine, I guess :) but I wasn't thinking of putting all data in an immutable Map... I was thinking more of a mutable array... possibly while avoiding the haskell's GC to run between each of the ToyVM instructions, so to have some small VM feasible for usage in an embedded/realtime environment, for example
17:36:20 <erisco> had to scrap some ideas for now until I better know how to implement them... but I can parse S -> aSa | aa correctly with my parser combinators so awesome :)
17:36:40 <typoclass> AsgardBSD: i think haskell will make things easier. in python or another language like that, you would spend a long time on "if object is null", unit tests, and generally implementing half of a type system. in haskell, it's hard to get something to compile, but once it compiles, you're nearly done
17:36:46 <berdario> (not that I have any business doing embedded stuff: as I said, I was just brainstorming :) )
17:37:05 <benmachine> there are some things to avoid in haskell
17:37:41 <benmachine> because of the way the GHC garbage collector works, your program will occasionally pause for very short intervals
17:37:55 <AsgardBSD> I also intend to use haskell in my final year project of my tech in embeded (electronics with programming)
17:37:58 <benmachine> this doesn't matter in most applications but it can be a problem for high-performance games
17:38:06 <benmachine> or it might be a problem
17:38:08 <benmachine> I don't know
17:38:21 <AsgardBSD> Well, we want to make some 8/16 bit game
17:38:25 <AsgardBSD> old school game
17:38:29 <AsgardBSD> with chiptune
17:38:55 <AsgardBSD> so performance wont be a problem (at least, not from special effect)
17:39:13 <benmachine> ah, that's good
17:39:47 <benmachine> http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
17:39:53 <benmachine> ^ some other Haskell games
17:40:02 <berdario> AsgardBSD: do you know about Nikki and the robots? http://joyridelabs.de/
17:40:57 <typoclass> berdario: right, a Data.Map is immutable (like most stuff in haskell). the way it works is: a function like Map.delete takes one immutable Map, and gives back another immutable Map, which will be identical except with one thing removed. (if anyone is still using the old map, it will continue to exist unchanged.)
17:41:06 <berdario> seems similar to what you're planning to do... more than haskell, I think that the problem will be marketing your game... I think there's a lot of competition out there
17:41:48 <typoclass> berdario: so, in my example, the recursion called the function 'interpret', but with the new, mutated map
17:48:49 <AsgardBSD> nice thansk
17:50:11 * carter AsgardBSD have you dled or read any of the books i've pointed you to yet? :)
17:50:14 <carter> AsgardBSD have you dled or read any of the books i've pointed you to yet? :)
17:50:24 <AsgardBSD> not yet
17:50:29 <AsgardBSD> I will order them in 3 week
17:50:44 <AsgardBSD> because i cant make the delevery to my home when im not at home
17:50:57 <carter> AsgardBSD the pdfs are pretty good oto!
17:51:04 <AsgardBSD> i have summer school + work this month
17:51:11 <carter> like, analytic combinatorics is lovely in either form
17:51:12 <AsgardBSD> I prefer paper for book
17:51:15 <carter> fair
17:51:16 <AsgardBSD> except if free pdf
17:51:25 <AsgardBSD> analytic is free
17:51:29 <roboguy_> is there a good way to cycle through a finite list, as though it was circular, until a given condition is met?
17:51:59 <AsgardBSD> I think i will spend 1000$ on book this year :)
17:52:53 <typoclass> roboguy_: depends on the condition; is it IO or something? :-) i guess you're not looking for takeWhile (cond) (cycle theList)
17:52:54 <kfish> roboguy_, turn it into an infinite list first with Prelude.cycle
17:54:00 <roboguy_> well, basically, I want to add 1 to n elements of a list starting at a certain index, going back to the beginning if the end is reached. Also the (+1)s should stack
17:54:21 <carter> As they are all free pdfs
17:55:20 <roboguy_> it's for a board game called mancala
17:56:30 <typoclass> roboguy_: so, 'add1 5 [17,23]' should give [18,24,19,25,20] ?
17:57:53 <roboguy_> typoclass: it would be more like 'add1 5 [17,23] == [17+1+1+1,23+1+1] == [20,25]'
17:57:57 <Hafydd> I'm not sure if [] is the best model for a mancala board.
17:58:07 <byorgey> oh, mancala is one of those simple games that turns out to be very, very tricky to model in an elegant way
17:58:26 <roboguy_> Hafydd: yeah, neither am I. I tried coming up with a structure for it, but I'm having problems
17:58:38 <byorgey> I'm not saying it can't be done.  Just that it pays to think carefully about how you represent the board.
17:58:40 * typoclass has got to be the only guy who's never heard of this thing 'mancala'
17:58:46 <byorgey> @go mancala
17:58:46 <lambdabot> Maybe you meant: google googleit do
17:59:15 <typoclass> byorgey: sure :) doing it now
18:02:50 <ChongLi> wow
18:02:55 <ChongLi> I just heard of haste
18:03:15 <ChongLi> amazing how some people just come out of the woodwork with this stuff :)
18:03:17 <roboguy_> it's one of those things that really looks like it would be pretty easy with destructive updates. I'm not sure if there's a more functional way to look at it. hmm
18:13:20 <AsgardBSD> carter they are not all free pdf
18:16:27 <AsgardBSD> carter: NUMERICAL LINEAR ALGEBRA, Hacker's Delight and Algorithm Design are not freely available
18:26:38 <haasn> I read the wikipedia article on mancala and I'm no step closer to understanding it
18:26:54 <haasn> Why don't they include a helpful vector graphic like the articles for chess, checkers, etc.
18:27:07 <Gracenotes> computer mancala is solved, man
18:27:11 <Gracenotes> don't even worry about it
18:27:47 <Gracenotes> and the rules are defined in the various subarticles
18:27:54 <Gracenotes> e.g. https://en.wikipedia.org/wiki/Kalah
18:28:11 <Gracenotes> https://en.wikipedia.org/wiki/Oware https://en.wikipedia.org/wiki/Congkak
18:28:17 <roboguy_> Gracenotes: aren't a lot of things solved though? and people still do it anyway. besides, the fact that I'm having issues implementing this structure is making me curious about how you would work with this kind of circular list in Haskell
18:28:24 <roboguy_> things tend to generalize
18:28:57 <Gracenotes> yes, the other half of solved things is humans enjoying the limitations of humanity.
18:29:18 <frx> hello. is real world haskell worth reading after LYAH or do they overlap too much?
18:29:28 <c_wraith> they don't really overlap much
18:29:29 <roconnor> @hpaste
18:29:29 <lambdabot> Haskell pastebin: http://hpaste.org/
18:29:38 <Gracenotes> RWH has some great exercises as well
18:30:40 <roboguy_> Gracenotes: what about practicing and generalizing things?
18:30:59 <roboguy_> it seems to me the fact that I'm having trouble with this suggests I should keep at it not that I should quit
18:31:49 <Gracenotes> roboguy_: yeah, of course. explore it until you see no unexplored corners
18:31:55 <roboguy_> here is the circular list structure that I'm working on. it feels a little weird though
18:31:57 <roboguy_> http://paste.tryhaskell.org/90738
18:32:10 <Gracenotes> except the corners with strange growling sounds coming from them
18:32:27 <roboguy_> it's similar to the clist package, but I don't think clist has everything that I need for this
18:32:34 <roboguy_> Gracenotes: haha, yeah
18:32:34 <Gracenotes> unless you have a flamethrower
18:33:38 <Gracenotes> you could also do something like a pre-cons, or somethin
18:33:55 <typoclass> roboguy_: i think doing something that is "already solved" can be a perfectly fine exercise and perfectly satisfying. me playing the piano or going on a bike ride isn't redundant because someone has already done that in the past
18:35:33 <Gracenotes> roboguy_: yeah, seems cool, main issue is that rotate is O(n)
18:36:37 <Gracenotes> if you're just looking for a fixed-length circular list, Array certainly would work
18:36:53 <Gracenotes> but.. modifying it is more interesting
18:37:10 <Gracenotes> and more amenable to stream fusion etc.
18:38:10 <Gracenotes> have you looked at zippers? might not help here, but still interesting.
18:38:28 <AsgardBSD> Would be cool if there could be a haskell course on coursera / udacity / EDX
18:38:42 <roboguy_> Gracenotes: briefly, a while ago. they do look pretty cool
18:39:44 <roboguy_> Gracenotes: when you say "modify" do you mean make a new copy or modify the existing one with IO/ST?
18:40:23 <Gracenotes> well, new copy, completely pure stuff.
18:42:26 <Gracenotes> roboguy_: hm, if you are interested in seeing some other solutions to similar problems, e.g. deque, I would recommend reading Purely Functional Data Structures
18:42:34 <Gracenotes> available both as a book and free pdf online
18:43:10 <Gracenotes> some great ideas there, many of them in the Haskell standard library
18:44:30 <roboguy_> it might be kind of cool if there was a (sort of) more general Functor-like structure where you could give it a way to get to the next element, if that makes sense
18:44:42 <roboguy_> Gracenotes: that looks pretty cool, I'll have to look at it. thanks!
18:44:56 <stolaruk> I'm a Haskell newbie, half way thru LYAH, and I've experienced first hand how once you fix the type errors and get your code to compile, it runs correctly, ie, no (or less) run time errors. Given this trait of Haskell, I'm wondering how useful it is to write tests. Do Haskell programmers find TDD and the like to be very useful?
18:45:18 <c_wraith> yeah, tests are still good.
18:45:34 <c_wraith> You just get to skip a class of errors prevented by the type system
18:46:07 <stolaruk> So, what sort of errors do tests help you to avoid?
18:47:34 <benmachine> stolaruk: some things are more or less amenable to testing
18:47:54 <benmachine> stolaruk: some things are more or less amenable to type checking
18:48:17 <benmachine> if you have some code for string manipulation and it's just String -> String, that doesn't tell you a great deal about what it does
18:48:30 <stolaruk> benmachine: Ah, good point.
18:48:38 <benmachine> so the typechecker won't save you if you get it wrong
18:48:47 <MitchellSalad> is there a Monoid instance of Either a b? I'm trying to reduce [Either a b] to Either a b, keeping the first Left found, or else any Right
18:48:52 <stolaruk> But with Haskell, do you find yourself writing less tests?
18:49:03 <MitchellSalad> sort of like the Last monoid, except looking for errors, and for Either, not Maybe
18:49:27 <benmachine> stolaruk: I don't want to make too many grand claims because I don't write code except for fun, and then I don't writ emuch that isn't Haskell
18:49:56 <stolaruk> benmachine: What sort of things do you write for fun? Just curious.
18:50:12 <benmachine> stolaruk: but I think it's fair to say there are a bunch of tests I'd have to write for a python program that I don't for a haskell program
18:50:27 <benmachine> stolaruk: bits and pieces all over the place
18:50:49 <benmachine> a bit of cleanup work on cabal
18:51:00 <typoclass> stolaruk: as an example, for a function [a] -> Maybe a that gives you the first element (if any), you could test that the element extracted is indeed the first one, and if [] indeed gives Nothing as the result. other things are ensured by haskell's type system. (in java, you'd have to test things like if it's null; in dynamic languages you'd have to test if it's the right type altogether, etc.)
18:51:35 <crdueck> > sequence [Right 4, Left 2, Right 3]
18:51:36 <lambdabot>   Left 2
18:51:50 <MitchellSalad> crdueck, thanks!
18:51:50 <crdueck> ^ MitchellSalad
18:52:20 <stolaruk> typoclass: So you still have to test that your functions are doing what you intended them to do
18:52:58 <benmachine> stolaruk: to some degree
18:53:25 <benmachine> stolaruk: sometimes you don't have to, especially with highly polymorphic functions
18:53:29 <typoclass> stolaruk: yes, minus the things that the type system does. things like testing for null pointers are no issue in haskell because we have Maybe
18:53:47 <benmachine> stolaruk: cute fact: barring use of error and infinite loops, f :: [a] -> Maybe a must satisfy f [] = Nothing
18:54:50 <stolaruk> benmachine: Why is that? I do know that if you use pattern matching, you have to satisfy all possible patterns. At least the linter tells me so. ;)
18:54:56 <typoclass> benmachine: heh :-) neat. obvious when you think about it. for "Just x", it would have to pull an x out of its behind, which it can't
18:55:02 <benmachine> typoclass: right
18:55:16 <stolaruk> Oh I see. I think. ;)_
18:55:32 <typoclass> stolaruk: no, ben's line of code is just one of the cases, the other one still needs to be written
18:55:48 <benmachine> yeah, I can't tell you exactly what it does in the (x:xs) case
18:56:14 <benmachine> but actually it sort of has to return exactly one of the elements of the list or Nothing
18:56:30 <benmachine> (or crash, or infinite loop)
18:56:46 <benmachine> because there just isn't a way to synthesise values of completely polymorphic type
18:56:54 <benmachine> nor is there a way to combine them
18:57:12 <typoclass> stolaruk: if you have 'reverse' for example, the signature is [a] -> [a]. the type checker can't tell a lot about that function, and there's plenty of room for unit tests
18:57:31 <benmachine> typoclass: for that type signature, you *do* get a free theorem
18:57:36 <stolaruk> typoclass: Yeah, I can see that. Cool!
18:57:40 <stolaruk> I guess.
18:57:53 <benmachine> suppose you have g :: [a] -> [a]
18:57:53 <stolaruk> Hehe, I'm not so much intro writing tests.
18:58:03 <benmachine> then g can't possibly inspect the a in the list
18:58:05 <stolaruk> s/intro/into
18:58:22 <benmachine> in particular, if you map f :: a -> b over all of them, g can't tell that you did that
18:58:28 <benmachine> so must behave the same as it was going to anyway
18:58:29 <typoclass> stolaruk: (other languages have type systems that are more powerful, and could express things like "this list is the reverse of that list", but lose things like type inference along the way)
18:58:35 <benmachine> in short, g (map f xs) = map f (g xs)
18:58:45 <benmachine> err
18:58:49 <benmachine> no that is right
18:59:35 <benmachine> so yeah, a simple type can tell you a lot more than you might guess
19:00:09 <benmachine> a function with type a -> a either returns its argument or always crashes regardless of its argument
19:00:16 <typoclass> benmachine: seems good to me. map f can change each element individually but can't reorder the list; g can reorder the list but can't change any elements. if map is Prelude.map
19:00:32 <stolaruk> benmachine: When you say that in "g :: [a] -> [a]" then g can't inspect the "a" in the list, what do you mean by inspect?
19:00:32 <benmachine> typoclass: yeah
19:00:44 <hpaste> berdario pasted “for roboguy_” at http://paste.tryhaskell.org/90739
19:00:50 <shachaf> stolaruk: g can't, for example, add 1 if a is Int.
19:00:57 <roboguy_> stolaruk: it can't make any decisions based on the value of the elements of the list or change them
19:01:01 <shachaf> stolaruk: It can only treat values of type 'a' as opaque black boxes.
19:01:16 <shachaf> It can't create them out of nowhere. There's a pretty limited set of things it can do.
19:01:16 <stolaruk> Oh right because "a" is a type variable
19:01:20 <berdario> maybe you've already solved it... but... whatever
19:01:42 <shachaf> @free g :: [a] -> [a]
19:01:42 <lambdabot> $map f . g = g . $map f
19:01:47 <shachaf> @free g :: [a] -> Maybe a
19:01:48 <lambdabot> $map_Maybe f . g = g . $map f
19:01:49 <liyang> Because a is a forall (universally) quantified type variable.
19:02:00 <typoclass> benmachine: right, the only plausible implementation for a -> a is id. only other possibilities are weirdos like 'undefined'. for a -> b, there's no plausible implementation
19:02:04 <benmachine> stolaruk: yeah, it's important that it's not only a type variable, it doesn't have any constraints on it
19:02:20 <stolaruk> benmachine: Right,
19:02:23 <shachaf> Constraints are weird.
19:03:04 <roboguy_> berdario: no, I haven't quite gotten a good solution yet. I'll take a look at this, thanks!
19:03:19 <liyang> A 'constraint' is just a type! A Constraint however...
19:04:14 <berdario> roboguy_: ah, that is just for the "add1 5 [17,23] == [20,25]" problem... I haven't followed the clist discussion since
19:04:17 <shachaf> There should negative constraints in Haskell, and a negative constraint should be called a constrain't.
19:04:19 <typoclass> stolaruk: the point is that g couldn't find out "oh, i've now been called with a list of Ints", and do something hinky. the signature ensures it must treat any type the same as any other type. the only thing g knows about its argument is that it will be a list
19:04:28 <benmachine> shachaf: :P
19:04:38 <typoclass> shachaf: excellen't
19:04:51 <stolaruk> typoclass: Right, yeah I can see that.
19:05:19 <typoclass> shachaf: (what's a negative constraint? "function takes any type 'a' as long as we don't have an Eq instance for 'a' in scope?)
19:05:47 <shachaf> typoclass: Presumably. I don't really care what it is, just what it's called.
19:05:53 <liyang> Things are simpler in the DTP world. :<
19:05:56 <typoclass> shachaf: alright
19:05:59 <AsgardBSD> I was wondering: does compiled piece of code of haskell is hard to reverse engineer (due to its functional nature)
19:06:01 <shachaf> It doesn't really make sense, not properly.
19:06:38 <geekosaur> not because it's functional, but because it's based on graph reduction instead of strict evaluation
19:06:48 <typoclass> "i'm an upstanding hardworking function and i will not deal with any of those snobbish types that have Eq instances"
19:08:29 <roboguy_> berdario: it's pretty cool. that might actually work better than what I was thinking of using. I'll have to try it
19:08:42 <AsgardBSD> so yes its harder to RE haskell than a C executable?
19:09:00 <shachaf> So a T-algebra for some monad T is some type A and function k :: T A -> A, such that k . join = k . fmap k, and k . return = id
19:09:08 <haasn> one point of note is that people have lots of experience reverse engineering C code
19:09:10 <shachaf> And apparently this lets you encode laws like associativity.
19:09:16 <shachaf> What are some good examples?
19:09:18 <haasn> wouldn't say the same for haskell
19:09:22 <shachaf> Or even bad examples.
19:09:27 <haasn> AsgardBSD: note that haskell libraries in particular often even include code snippets for inlining
19:09:34 <geekosaur> also because decompilers generally go to C, and that's going to be harder to undersdtand than if it went to the source language. but that has nothing to do with FP; the same would happen with a non-C/C++ imperative language
19:10:07 <benmachine> shachaf: the free T-algebra has the type T A and the function join :: T (T A) -> T A
19:10:19 <berdario> roboguy_: good to hear :) ... I haven't touched haskell in 7 months, and I longed for something to get my hands dirty
19:10:22 <Fuuzetsu> Do you guys have any tips on proving Haskell programs with Agda? It seems that a lot of times Agda just tells me that my Haskell program is potentially non-terminating (think about a proof with Applicative's some/many which can't be proven to terminate in general). Would you change your Haskell program just to make it easier to prove?
19:10:24 <AsgardBSD> but a FP program == lot of funtion (everything is a function, we can pass function as argument, return function argument...)
19:10:24 <stolaruk> Wouldn't it be difficult to RE an executable compiled from Haskell due to the fact that Haskell is so abstract/high level?
19:10:34 <AsgardBSD> also, not the same calling conventiion
19:10:36 <benmachine> shachaf: possibly a boring example :)
19:10:55 <shachaf> benmachine: Sure, I know that one.
19:11:06 <benmachine> shachaf: are you interested specifically in Haskell, or CT generally?
19:11:06 <geekosaur> C can pass function arguments
19:11:10 <shachaf> benmachine: I want to figure out how algebraic structures (complete with laws) are encoded.
19:11:19 <shachaf> benmachine: Both are fine.
19:11:28 <benmachine> shachaf: an algebra for the list monad is basically an implementation of mconcat, i.e. a monoid structure
19:11:32 <haasn> AsgardBSD: compilers for FP languages to platforms like x86 tend to go through a series of abstractions into some form of primitive evaluation machine; you'd have to reverse those abstractions imo
19:12:06 <haasn> it's not necessarily a simple transformation; keep in mind also Haskell's laziness
19:12:12 <AsgardBSD> so haskell is a great language to make closed source application... like a indie game
19:12:13 <tabemann> curiosity question: why would unrolling loops in Haskell code that will be largely strict internally (because it's math code) make it *slower*?
19:12:19 <AsgardBSD> hard to reverse engineer
19:12:22 <haasn> AsgardBSD: I don't think that's relevant here
19:12:22 <benmachine> shachaf: the associativity of the monoid structure so defined comes from the first law
19:12:59 <haasn> AsgardBSD: ‘closed source’ is more or a legal distinction than a technical one imo
19:13:03 <haasn> of*
19:13:31 <shachaf> benmachine: What T are you talking about here? []?
19:13:31 <benmachine> shachaf: because yo uhave something like mconcat (map mconcat [[x,y],[z]]) = mconcat (concat [[x,y],z]]) = mconcat [x,y,z] = mconcat (concat [[x],[y,z]])
19:13:33 <haasn> if you don't want people using your software, use legal means to protect it I guess
19:13:33 <benmachine> yes
19:14:12 <benmachine> for T = [], T-algebras with carrier A correspond to monoid structures on A
19:14:25 <shachaf> benmachine: You can make data Foo a = Mult a a | Unit, such that Free (FAlg a) behaves a lot like a free monoid, except that it's more of a free pointed magma since there are no laws.
19:14:27 <benmachine> I... think I remember that correctly
19:14:40 <shachaf> I was hoping for something that looked like that, except also encoded the laws somehow.
19:14:53 <shachaf> Is it not that straightforward?
19:15:05 <shachaf> Er, Free (FAlg Foo)
19:15:32 <shachaf> (With Free f a = forall r. (a -> r) -> f r -> r, I think it was.)
19:17:53 <tabemann> does anyone know why loop unrolling in math code would slow it down, especially when from looking at the Core the non-unrolled code seems to convert values to and from boxed Int values with each iteration?
19:19:19 <dolio> What does the unrolled code do?
19:19:30 <tabemann> it calculates integer square roots
19:19:38 <dolio> No, I mean, does it also box?
19:20:41 <tabemann> last time I looked at it, the non-unrolled inner loop took boxed Int values
19:21:09 <tabemann> ** why won't ghc -ddump-simpl IntSqrt.hs do what I want it to again now...
19:21:28 <dolio> -fforce-recomp?
19:21:46 <tabemann> that did it
19:22:52 <tabemann> interesting
19:23:07 <tabemann> the unrolled code is still using boxed values internally
19:23:16 <dolio> Okay.
19:23:35 <dolio> I don't know why it's slower, but that explains why it isn't faster, at least.
19:24:03 <carter> tabemann you may want to try out making things stricter
19:24:04 <jmcarthur> tabemann: add some strictness annotations and see if that helps
19:24:13 <dolio> Are you compiling with -O2?
19:24:14 <carter> tabemann i have a strict identity monad you can use to help
19:24:44 <tabemann> dolio: I probably should do that
19:24:49 <dolio> Yes.
19:25:01 <carter> -O2 is your friend, except when you hit weird bugs
19:25:04 <dolio> Don't worry about strict identity monads yet. :)
19:25:06 <jmcarthur> tabemann: were you using optimizations at all?
19:25:52 <jmcarthur> that is not meant to read like incredulity
19:26:30 <tabemann> no I wasn't; maybe that'll increase the performance factor of my code over using floating point sqrt with conversion to and from an Int
19:26:57 <tabemann> okay, that made *everything* much faster
19:27:16 <jmcarthur> ghc relies heavily on optimizations to make even barely reasonable executables. it's very crippling to have them off
19:27:57 <tabemann> now my unrolled code is slightly faster than my non-unrolled code
19:28:23 <tabemann> and both are at worst about as fast as floating point sqrt, but often noticeably faster
19:29:15 <jmcarthur> if this is numeric code in a tight loop, the llvm backend might actually do alright unrolling for you, depending on what ghc gives it
19:29:27 <jmcarthur> (and other nice numeric optimizations)
19:29:41 <tabemann> I'm running criterion against it
19:29:48 <jmcarthur> i suggest trying -fllvm
19:29:54 <jmcarthur> if this is numeric code, at leat
19:29:55 <jmcarthur> *least
19:30:09 <tabemann> yeah, it's numeric code
19:32:14 * tabemann wonders why floating point sqrt would be significantly slower in haskell compared to in C, unless haskell implements its own floating point sqrt rather than using glibc's
19:32:55 <frx> tabemann is it really? do you have any examples?
19:33:55 <tabemann> sqrt 127 using floating point sqrt in haskell takes ~22 ns; ~11 ns in C
19:34:00 <Gracenotes> how defined FAlg?
19:34:07 <Gracenotes> hm, did not scroll down.
19:35:13 <johnw> tabemann: can I see your testing code?
19:37:39 <tabemann> johwn: as soon as hpaste responds
19:38:08 <tabemann> screw it, I'll use pastebin
19:38:46 <carter> yeah, doing -fllvm will make you happier
19:39:58 <geekosaur> tabemann, hpaste.org name is gone
19:40:03 <geekosaur> @where hpaste
19:40:03 <lambdabot> http://paste.tryhaskell.org/new/haskell
19:40:07 <geekosaur> ^^ new url
19:40:10 <geekosaur> also see /topic
19:40:24 <parcs> sqrt on Float/Double uses glibc sqrtf
19:40:42 <hpaste> tabemann pasted “Haskell sqrt test code” at http://paste.tryhaskell.org/90740
19:40:44 <parcs> er sqrtf/sqrt
19:41:18 <hpaste> tabemann pasted “C sqrt test code” at http://paste.tryhaskell.org/90741
19:41:53 <carter> tabemann you should look at hackers delight
19:42:56 <carter> http://www.hackersdelight.org/hdcodetxt/isqrt.c.txt integer square root
19:43:05 <tabemann> carter: that code is from that book
19:43:07 <tabemann> the C code it is
19:43:10 <carter> yes
19:43:16 <tabemann> the Haskell code is my attempt at rendering the C code in Haskell
19:43:30 <carter> tabemann then you shoudl REALLY look at my strict identity monad code :)
19:43:38 <carter> its used for writing code from that book :)
19:43:47 <johnw> tabemann: um, for the floatSqrt test, on the Haskell side you are using floor after every computations, but you're not doing that on the C side
19:43:47 <carter> and with -fllvm it gives me nice asm
19:44:17 <johnw> that extra floor could easily account for the added 11ns
19:44:39 <tabemann> I'll add a floor to my C code and see what happens
19:45:16 <carter> https://gist.github.com/cartazio/5842883
19:47:08 <tabemann> okay, now with the floor, sqrt(127) floating point takes 14 ns
19:47:29 <johnw> which C compiler are you using?
19:47:31 <carter> tabemann with the strict identity monad (or doing nested cases as a strict let) and -fllvm , i get very nice asm
19:47:41 <tabemann> johnw: gcc
19:47:52 <johnw> gcc -O2?
19:47:56 <tabemann> note that the C code was being run without -O2
19:48:01 <tabemann> I'll see what happens when I run it with that
19:48:04 <johnw> and ghc -O2?
19:48:18 <johnw> just trying to make sure we're comparing the same thing
19:48:30 <tabemann> oooh, gcc -O2 makes it much faster
19:48:39 <carter> tabemann also -fllvm
19:48:40 <carter> for ghc
19:49:03 <carter> makes a HUGE difference
19:49:05 <tabemann> I'll try running GHC with -fllvm now (I ran it before again with -O2)
19:49:13 <carter> tabemann no, BOTH :)
19:49:34 <johnw> tabemann: another thing I'd be interested in seeing: compile your C functions to a library, then link to them from GHC via the FFI, and make sure that there's no difference
19:49:48 <carter> johnw yeah, that should add < 3 ns overhead
19:49:49 <carter> ish
19:50:14 <Clint> i thought ghc -O2 was inadvisable
19:50:15 <tabemann> carter: both -O2 and -fllvm with GHC (I assumed that), or -fllvm and -O2 with gcc too (wut?)
19:50:43 <johnw> Clint: it's often slow without much perceivable benefit, so it's a poor choice for a Cabal default
19:50:49 <johnw> this is what I've read
19:50:54 <tabemann> dammit, I'll need to install llvm
19:51:02 <carter> tabemann mac or linux?
19:51:05 <carter> clang is >>> gcc
19:51:09 <carter> such nice error messages
19:51:25 <tabemann> carter: linux
19:52:04 * tabemann has to figure out what packages to install now to get LLVM to work with GHC...
19:52:13 <carter> tabemann just LLVM
19:52:19 <carter> nothing special needed
19:52:23 <carter> but you should install clang too :)
19:52:29 <tabemann> 3.0?
19:52:40 <carter> tabemann 3.2 or  3.3 if you can
19:52:43 <carter> but 3.0 works probably
19:52:45 <carter> idk
19:53:34 <tabemann> okay, now will have to wait for it all to install via my straw of an internet connection
19:53:57 <carter> ah
19:55:25 <tabemann> okay, all the packages should be downloaded in 3 min
19:55:31 <carter> woot
19:55:36 <carter> binary or source build?
19:55:48 <tabemann> so should I be using -fllvm with GHC in general?
19:55:50 <tabemann> binary
19:56:01 <tabemann> as usual, it's debian, so it's behind the times
19:56:09 <johnw> -fllvm helps with numerical code, I've heard
19:56:28 <carter> tabemann if you're doing numerical or bit fiddly things (as it seems), yes!
19:56:56 <carter> i have some really nice examples where  llvm reduces a permuation function and its inverse to identity
19:57:11 <carter> whereas the native backend has 40+ bit fiddlign operations
19:57:22 <wagle> hi..  anyone use gitit with haskell platform 2013.2.0.0?
19:57:36 <tabemann> carter: nice
19:57:38 <johnw> wagle: what's the problem?
19:57:49 <carter> share the error message and we can help
19:59:55 <wagle> looking, gave up, trying something else, thought i'd ask here
19:59:57 <tabemann> about the strict identity monad - what does one get out of it when one is writing code that would be naturally strict by its very construction (i.e. numerics code)
20:01:35 <carter> making sure its strict
20:01:47 <wagle> lemme finish my current attempt before asking again
20:01:59 <carter> wagle hpaste your error message
20:02:09 <carter> tabemann you're saying "naturally strict"
20:02:23 <gurrag> what's the recommended way for Ubuntu 13.04 users to get the Haskell Platform? compiling from source?
20:02:40 <carter> but by your own words, the strictness was deduced at O2 not O1
20:02:41 <wagle> cant find it, its scrolled way back, cant find Network.Gitit.Interface
20:02:55 <gurrag> is there a PPA for it that tricks apt into using the older version of haskell?
20:03:03 <carter> gurrag you dont' want that
20:03:16 <carter> haskell platform versions are tied to specific ghcs
20:03:17 <gurrag> don't want which
20:03:24 <tabemann> carter: I mean that no datastructures are produced that could hold thunks; once the initial thunk is evaluated, the entire thing would have to be evaluated
20:03:34 <carter> applications can be thunked
20:03:51 <wagle> i'm current trying 2012.4.0.0
20:04:08 <carter> wagle hpaste the error message
20:04:11 <carter> or we can't help you :)
20:04:50 <wagle> I said I dont have it, will have to get to the point where I can generate it again
20:04:56 <carter> ok
20:05:22 <carter> tabemann as has been indicated in prior irc chatter, you're still getting a handle on the evaluation model
20:05:33 <carter> and thats ok
20:05:47 <carter> right now you're writing code that you want ot always be strict
20:05:54 <carter> and by your own benchmarks
20:06:04 <carter> theres a measurable difference between 01 and 02
20:06:19 <carter> the solution then is to make your code strict by construction
20:06:38 <carter> tabemann a simpler first step
20:06:41 <carter> is to enable bang patterns
20:06:46 <carter> and put them on all your function args
20:06:48 <tabemann> measurable is an understatement; -O2 resulted in an order of magnitude speed-up
20:07:08 <carter> tabemann hence measurable
20:07:23 <carter> tabemann experiment 1
20:07:42 <carter> {-# LANGUAGE BangPatterns #-} at the top of your module
20:07:44 <tabemann> I'll try the bang-patterns and see what happens
20:08:03 <carter> tabemann you may find that you'll get O2 perf at O1 that wya
20:08:33 <carter> good engineering is about having performance be robust :)
20:08:40 <carter> well, sometimes
20:08:52 <carter> but yeah, bang pattern all your lets and function args
20:09:18 <carter> tibbe's high peformance haskell slides http://www.slideshare.net/tibbe/highperformance-haskell are helpful
20:09:23 <carter> when you're learnign the tricks
20:09:35 <tabemann> I was going to ask about bang-patterning the lets
20:10:25 <tabemann> I've seen that slideshow
20:15:46 <tabemann> wtf
20:16:19 <tabemann> oh, not BangBatterns
20:16:29 * hackagebot llvm-general 3.2.4.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.4.1 (BenjaminScarlet)
20:16:31 * hackagebot llvm-general 3.3.4.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.4.1 (BenjaminScarlet)
20:18:13 <tabemann> okay, the code still *needs* -O2; BangPatterns won't do it, as the code with the bangs was but no -O2 was still a good order of magnitude slower
20:19:19 <pentace> Does anyone know of a binary search implementation on Array that yields a pair of adjacent indices (i, j) such that the value being searched is in the range A[i] .. A[j]?
20:20:35 <gurrag> carter: what would you suggest I do then
20:20:42 <carter> gurrag for what?
20:20:59 <gurrag> for either getting a version of haskell-platform installed on Ubuntu 13 or learning to live without it
20:21:25 <carter> gurrag install the right ghc version and build the rest :)
20:22:01 <carter> gurrag either the binary build online
20:22:06 <carter> or build ghc from source
20:22:12 <carter> and then install the rest of the libs yourself
20:22:30 <carter> theres some pretty good docs on the dev wikii for building ghc from source
20:22:45 <gurrag> I think i'll just install ghc and install the libs I need through whatever the haskell package manager is called
20:23:00 <jekor> Is there a way to tell cabal to reinstall all packages (such as after changing .cabal/config to use library profiling)?
20:23:29 <johnw> jekor: by wiping .ghc and .cabal/lib
20:23:33 <shachaf> jekor: Maybe `cabal install world`?
20:23:34 <gurrag> cabal, that's the one
20:24:11 <jekor> johnw: Last resort :)
20:24:28 <jekor> shachaf: Thanks for the world keyword.
20:24:36 <shachaf> I've never tried it, so I don't really know how well it works.
20:25:11 <carter> wait, theres a world keyword?!
20:25:18 <gurrag> carter: does this look alright http://niket-kumar.blogspot.com/2013/05/ubuntu-1304-how-to-setup-haskell.html
20:25:26 <carter> no clue
20:25:39 <carter> gurrag go tothe dev wiki
20:25:46 <carter> or just try the binary build on ghc's site
20:26:02 <carter> look at the "official" stuff first
20:26:20 <carter> honestly just try the unknown linux build first
20:26:28 <arkeet> carter: yes, it just looks at the list in .cabal/worl
20:26:28 <arkeet> d
20:26:35 <carter> oh
20:26:43 <carter> thats a lot of stuff sometimes
20:26:44 <arkeet> which contains things you cabal install'd
20:27:02 <jekor> gurrag: What are you trying to do? Installing GHC from source is pretty straightforward but takes a long time to build.
20:27:24 <shachaf> There is no reason to compile GHC yourself in the common case.
20:27:33 <arkeet> well, you can cabal install --one-shot if you don't want it to go in world.
20:27:34 <monochrom> I don't like "world", it means history, it is bound to contain junks you no longer care.
20:27:45 <arkeet> monochrom: --one-shot stuff you don't care about, then
20:28:35 <monochrom> yes but I'm talking about people who just know about "world" and "--one-shot" now and "world" has already accumulated past 10 years of junk.
20:28:40 <gurrag> shachaf: I'm in the "uncommon case" of Canonical making the weird decision to ship a newer version of GHC than there's currently haskell-platform support for
20:28:42 <gurrag> in Ubuntu 13
20:28:52 <carter> gurrag what ghc version?
20:28:58 <carter> 7.6?
20:29:05 <monochrom> also today you have no idea what you won't care about 5 years into the future
20:29:05 <carter> that has a haskell platform version
20:29:28 <shachaf> gurrag: That's generally fine. You don't really need haskell-platform.
20:29:38 <carter> yeah
20:29:47 <carter> just cabal things as you need them
20:29:55 <gurrag> fair enough :)
20:30:07 <gurrag> will it still be (relatively) easy to deploy things
20:30:39 <gurrag> i.e. package up programs and send them to my audience without having to have them jump through hoops on account of me not using the standard "haskell-platform"
20:31:03 <monochrom> ubuntu 13.04 chose ghc 7.6.2. this is one point older than current haskell platform. what are you talking about?
20:31:04 <dolio> Deploy how? Binary?
20:31:08 <jekor> gurrag: I've never used haskell-platform and never had a problem with deployment. Just use cabal-dev and setup your cabal file. You'll be fine.
20:31:23 <carter> yes
20:32:28 <gurrag> alright, thanks
20:32:50 <gurrag> dolio: I thought it was a Bad Thing (tm) to talk about deploying binaries compiled from Haskell
20:32:53 <gurrag> for whatever reason
20:33:02 <carter> gurrag nope, its fine
20:33:05 <carter> its one of the thigns people like
20:33:10 <carter> that its easy to statically build things
20:33:17 <gurrag> alright, cool!
20:33:52 <dolio> Well, that may or may not be a good thing, depending on who you ask.
20:33:59 <gurrag> so I could write a game that used SDL and OpenGL libraries and distribute it as a binary and it'd run on another Linux machine without them having to install Haskell?
20:34:22 <dolio> Because static linking is easy because dynamic linking is not.
20:34:36 <dolio> Unless they've finally sorted some of that out without my hearing about it.
20:36:03 <dolio> Yes, they shouldn't have to have Haskell stuff installed. Just the dependencies that actually are dynamically linked.
20:36:49 <gurrag> :D
20:37:00 <gurrag> well this brightens my day
20:37:38 <applikativ> gurrag: there aren't that many public cases of this, but some of the familiar haskell executables are distributed as binaries, e.g. pandoc and darcs
20:39:58 <wagle> reverting to 2012.4.0.0 and rebuilding gitit worked..  I'll try 2013.2.0.0 again in a few weeks
20:42:45 <daniel-s> Hello, I'm reading about category theory and thought it might be worth asking here:
20:42:47 <daniel-s> Let A = {a, b, c, d}. If f : {1,2,3,4,5,6,7,8,9,10} -> A is given by {a, b, c, c, b, a, d, d, a, b}, what is f (4)?
20:42:53 <daniel-s> Can someone help with that
20:43:12 <shachaf> What are A and f here?
20:43:32 <Nisstyre> daniel-s: how come you didn't wait for an answer in #math?
20:45:31 <monochrom> the notation "{a, b, c, c, b, a, d, d, a, b}" usually does not specify a function. the question is ill-posed.
20:45:39 <applikativ> strange way of talking daniel-s , isn't it obviously f 4 = c
20:46:06 <Nisstyre> also A isn't a set is it?
20:46:27 <monochrom> {a, b, c, d} is common notation for a set.
20:46:31 <daniel-s> shachaf: A is a set, f is a function
20:46:40 <Nisstyre> monochrom: I meant the other one "A is given by ..."
20:46:56 <Nisstyre> not sure if that was supposed to be A
20:47:06 <shachaf> daniel-s: What is the motivation for this question?
20:47:07 <applikativ> but the second use of {} makes it all more than just a set, you mean, to {1,2,3,4,5,6,7,8,9,10}, respectively, f associates {a, b, c, c, b, a, d, d, a, b}
20:47:25 <shachaf> Is it homework? (If so, I suggest that you probably didn't understand it.)
20:47:37 <monochrom> parse tree is: (f : {1,2,3,4,5,6,7,8,9,10} -> A) is given by ...
20:47:39 <daniel-s> shachaf: I'm reading through Category Theory for Scientists by David Spivak
20:47:47 <daniel-s> I didn't understand the question
20:47:54 <shachaf> Ah.
20:48:07 <arkeet> {...} could denote the universal morphism in a product or so
20:48:07 <daniel-s> I'm familiar with set theory, I didn't think it was too difficult, I just didn't get exactly what it meant
20:48:25 <arkeet> or maybe it's some other brackets, I dunno
20:48:29 <daniel-s> I figured to ask here because I assumed there would be a lot of people here that are familiar with category theory
20:48:36 <shachaf> What is the question?
20:48:36 <Nisstyre> arkeet: the angled brackets?
20:48:39 <arkeet> maybe.
20:48:43 <shachaf> I have the PDF. What page?
20:48:54 <applikativ> I don't think this notation is particularly common
20:48:56 <daniel-s> arkeet: It's a question about sets, {} means a set.
20:49:03 <arkeet> well, it's poor notation in the question then.
20:49:12 <shachaf> {a, b, c, c, b, a, d, d, a, b} means the same set as {a, b, c, d}
20:49:13 <arkeet> maybe you should look in the book to see if they explain the notation
20:49:22 <daniel-s> Sorry, {a,b,c,c... should be in round brackets
20:49:31 <arkeet> that's better.
20:49:37 <arkeet> a bit.
20:49:39 <Nisstyre> shachaf: so it's meant to say that the elements in A map to more than one element in the other set?
20:49:45 <shachaf> OK then.
20:49:50 <shachaf> Nisstyre: No, the book uses (), not {}.
20:49:53 <applikativ> right, thats why {a, b, c, c, b, a, d, d, a, b}  isn't really introducing a set, but the second element of a bunch of pairs in an association
20:50:07 <Nisstyre> oh ok
20:50:13 <applikativ> that's not so bad then
20:50:25 <daniel-s> sorry, my mistake
20:50:29 <shachaf> The book says: Let A  = {a, b, c, d}. If f : 10 -> A is given by (a, b, c, c, b, a, d, d, a, b), what is f(4)?
20:50:32 <arkeet> I like to denote the universal morphism of a product by a column vector.
20:50:42 <arkeet> (and for a sum, a row vector)
20:50:57 <daniel-s> So it's mapping the set {1,2..10} to A, producing (a, b, ..b) as a result
20:51:03 <applikativ> it's still a little bizarre; i wonder if he had introduced this way of speaking before
20:51:12 <arkeet> (but {1,...,10} isn't ordered!)
20:51:22 <arkeet> (well, sets aren't ordered)
20:51:27 <applikativ> that doesn't matter
20:51:37 <monochrom> presumably, (a, b, c, c, b, a, d, d, a, b) is ordered
20:51:46 <daniel-s> arkeet: Is it wrong for me to write the set out like that? In that ... shorthand?
20:51:50 <applikativ> 10 isnt ordered either is closer to the problem
20:51:58 <arkeet> daniel-s: no, I'm not complaining about ...
20:52:01 <shachaf> Oh, he gives a definition right before that exercise.
20:52:02 <arkeet> I'm complaining about nothing important.
20:52:04 <monochrom> or else, "(a, b, c, c, b, a, d, d, a, b)" is notation for "\n -> if n==0 then a else if n==1 then b else ..."
20:52:05 <shachaf> Did you read the definition?
20:52:10 <shachaf> You should quote it here along with your question.
20:52:15 <arkeet> that's what I said
20:52:18 <arkeet> maybe he explains the notation
20:52:35 <shachaf> He does.
20:52:37 <arkeet> monochrom: it says "is given by", not "is"
20:52:57 <monochrom> um, mathematicians say "is given by" for "equals".
20:52:58 <daniel-s> Well, he uses underscore(n) to be {1,2,...,n}
20:53:15 <shachaf> daniel-s: Are we looking at the same PDF?
20:53:19 <daniel-s> So in his example he has written 10_ <-- underscore
20:53:30 <daniel-s> shachaf: top of page 19?
20:53:37 <shachaf> And bottom of page 18.
20:53:44 <shachaf> First, he says that n means {1, 2, 3, ..., n}.
20:54:12 <shachaf> Then, he says: Let A be any set. A function f : n -> A can be written as a sequence
20:54:12 <daniel-s> shachaf: Is the answer just c?
20:54:28 <shachaf> f = (f(1), f(2), ..., f(n))
20:54:40 <daniel-s> I completely missed that!
20:55:01 <shachaf> It's the only paragraph between the definition of n and your exercise.
20:55:09 <shachaf> It's important to read these things. :-)
20:56:13 <Nisstyre> yeah, usually if you have trouble understanding something in a math book it means you didn't read or didn't understand something previously said
20:56:32 <applikativ> he introduced the necessary jargon the page before. it was clear what he meant though
20:56:50 <shachaf> So the answer is yes. It's c.
20:57:54 <applikativ> > map (join (*)) [1..7]
20:57:54 <lambdabot>   [1,4,9,16,25,36,49]
20:58:14 <applikativ> theres the answer to the next problem
20:58:31 <Fuuzetsu> Can someone think of a Haddock documented project that builds with GHC HEAD?
20:58:43 <Fuuzetsu> I tried lens but its deps don't build ;(
20:58:53 <monochrom> base
20:59:40 <monochrom> base is hard. try containers, bytestring, ...
21:00:17 <shachaf> comonad?
21:00:20 <daniel-s> OK, thanks shachaf and everyone
21:00:27 <shachaf> semigroups?
21:00:41 <shachaf> semigroupoids?
21:01:00 <johnw> infinite groupoids are the new thing
21:01:10 <Fuuzetsu> Trying all these out. So far base and containers are out (hackage has too old versions I think)
21:01:11 <johnw> there are just so many of them
21:01:42 <applikativ> infinity groupoids
21:02:50 <Fuuzetsu> Got anything bigger? Comonad and semigroups are rather small.
21:03:05 <Fuuzetsu> I'm basically trying to see performance change between Haddock parsers.
21:03:11 <monochrom> I do not know whether hxt builds, but it is big
21:03:14 <Fuuzetsu> On a Real Project™
21:03:16 <shachaf> I don't have HEAD. So I don't know.
21:03:30 <johnw> shachaf: I have nightlies, if you are running Linux
21:03:46 <shachaf> I can build it myself.
21:03:54 <shachaf> But my current repository is messed up.
21:03:58 <Fuuzetsu> hxt no good
21:04:09 <johnw> shachaf: just might save you some CPU heat
21:04:21 <monochrom> hmm, why do they fail to build? what's new in GHC HEAD to cause this?
21:04:25 <Fuuzetsu> hm, might be good actually
21:05:01 <Fuuzetsu> monochrom: What do you mean by ‘they’?
21:05:12 <monochrom> all the packages you found to not build
21:05:15 <johnw> Fuuzetsu: what about something like transformers?
21:05:30 <johnw> when I tried to build anything with HEAD, I was equally defeated
21:06:05 <Fuuzetsu> monochrom: lens' deps don't build due to various reasons, hackage base is too old (I think), comonad and semigroups are just too small for my purpose. Trying HXT out at the moment.
21:06:24 <johnw> Fuuzetsu: maybe try pipes too
21:06:26 <Fuuzetsu> A lot of things depend on the old GHC Typeable1, 2… which was replaced fairly recently
21:06:38 <Fuuzetsu> I'll look into it if HXT fails, johnw
21:06:54 <Fuuzetsu> text seems pretty big
21:07:12 <johnw> and vector
21:07:34 <shachaf> monochrom: lens has a custom Typeable instance.
21:07:39 <shachaf> Which is disallowed in HEAD, I think.
21:08:28 <startling> what's the way to turn a traversal into a Getter for a list in lens?
21:08:46 <shachaf> startling: partsOf?
21:08:59 <johnw> I wonder why libraries@ is so worried about backwards incompatible changes, when recent GHC can't build basic packages, am I missing something in their process?
21:09:00 <shachaf> In fact that turns it into a lens.
21:09:12 <applikativ> has anyone mastered cabal sandbox ?
21:09:35 <shachaf> startling: Or you can just use toListOf.
21:09:41 <applikativ> I cant figure out how to work on several related packages at once; or is that a lost cause
21:09:42 <startling> shachaf: ah, cool, partsOf is it
21:09:50 <startling> shachaf: what's the difference between partsOf and toListOf?
21:09:54 <monochrom> libraries@ and GHC are not aligned
21:10:09 <applikativ> they are at war
21:10:20 <shachaf> startling: toListOf will simply give you a list. It's not a lens, just a function.
21:10:23 <johnw> ah, I suppose libraries@ is concerned with the language per se, and GHC is just an implementation of it
21:10:39 <shachaf> startling: partsOf will give you an actual read-write lens.
21:10:51 <shachaf> startling: The read part uses toListOf. The write part uses black magic.
21:11:04 <startling> shachaf, cool
21:11:06 <shachaf> (Actually it's not very black magic. It's just a traversal with State.)
21:11:15 <Fuuzetsu> To be fair, GHC is THE leading implementation…
21:11:20 <defrinh> A = 10, B = 8, and C = 5
21:11:25 <defrinh> (B + A) / C * C – A * C ^ (A – B) % B – B % C * (C – 3) – C % B
21:11:30 <johnw> until GHC++
21:11:30 <defrinh> I got = 14.28 but that can't be right.
21:11:37 <Ghoul_> I need O1 lookup between an ordering number with no holes in the set and a data. What's the best thing to use at the moment?
21:11:41 <monochrom> wrong channel
21:11:43 <arkeet> defrinh: who cares?
21:11:45 <applikativ> wow
21:12:04 <startling> shachaf: can I use partsOf itraverse somehow?
21:12:14 <arkeet> Ghoul_: an array?
21:12:18 <shachaf> startling: I think you want itraversed (or just traversed)
21:12:25 <shachaf> startling: Unless you want the indices too?
21:12:55 <startling> shachaf: I want the indices and the values of the TraversableWithIndex instance collected into a list
21:13:02 <Ghoul_> I was thinking that initially but wanted to be sure, thanks
21:13:25 <shachaf> startling: Perhaps you want itoListOf.
21:13:27 <shachaf> λ> itoListOf itraversed "hello"
21:13:28 <shachaf> [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
21:14:05 <startling> hmm
21:14:10 <startling> okay, I should take a step back.
21:14:17 <defrinh> Anyone?
21:14:25 <monochrom> wrong channel
21:14:28 <shachaf> defrinh: As monochrom said, wrong channel.
21:14:45 <defrinh> It is programming math
21:15:12 --- mode: ChanServ set +o monochrom
21:15:20 --- mode: monochrom set +b $a:perdent
21:15:30 --- kick: defrinh was kicked by monochrom (defrinh)
21:15:33 <startling> I have a (i -> a -> m x) function and a TraversableWithIndex i t. I want to have a "t a -> m [x]"
21:15:36 --- mode: monochrom set -o monochrom
21:16:30 <shachaf> Let's figure it out without the index first.
21:16:53 <shachaf> We have (a -> m b) and t a, and we want t [b]?
21:16:57 <startling> is it toListOf traverse?
21:17:00 <shachaf> Er.
21:17:03 <shachaf> We have (a -> m b) and t a, and we want m [b]?
21:17:07 <shachaf> Where m is Applicative.
21:17:11 <startling> yeah.
21:18:54 <Fuuzetsu> HXT worked fine, thanks guys
21:18:59 <monochrom> nice
21:19:13 <shachaf> startling: It sounds like you can toListOf first, and then use plain old traverse?
21:19:30 <startling> oh, good point
21:19:42 <augur> kamatsu: really, look at that paper i linked you to.
21:19:50 <shachaf> OK, so that's problem 1 solved.
21:20:08 <shachaf> Now let's say you have ((i,a) -> m b) and t a, and you want m [b]?
21:20:09 <augur> because you literally do just get the STLC out of it. it falls into your lap without having to do anything.
21:20:16 <shachaf> Where t is TraversableWithIndex i
21:20:40 <shachaf> itoList :: t a -> [(i,a)]
21:20:44 <shachaf> Then use regular traverse?
21:21:55 <augur> kamatsu: the whole reason i wrote the tutorial was to explain exactly this point -- that C-H isn't something we had to identify, if only we had been smart enough we would've seen that it was sitting in front of us the whole time, screaming out
21:22:18 <Ghoul_> Does someone know how to fix this error: http://pastie.org/8119911 ?
21:23:25 <startling> shachaf: aha
21:23:34 <startling> yeah, that seems like the nicest way. thanks.
21:24:02 <shachaf> startling: An alternative: itraverse first, then toList.
21:24:18 <shachaf> itraverse :: (i -> a -> m b) -> t a -> m (t b)
21:24:31 <kamatsu> augur: Like i said on reddit, STLC doesn't fall out automatically
21:24:31 <shachaf> fmap toList :: m (t b) -> m [b]
21:24:43 <augur> kamatsu: and like i said, it does
21:24:49 <kamatsu> augur: you have to give names to your assumptions, then STLC falls out as a structure for proof terms.
21:25:00 <augur> kamatsu: ND already names hypotheses!
21:25:09 <startling> shachaf: one step ahead of you!
21:25:21 <startling> (this way's nicer since I don't need to uncurry)
21:25:51 <kamatsu> augur: only local hypotheses
21:25:52 <augur> kamatsu: thats how ->I works -- you do ->I^i for some hypothesis i
21:26:00 <shachaf> startling: But you have to fmap.
21:26:16 <kamatsu> augur: and even then, the names of the hypotheses aren't part of your term structure.
21:26:25 <kamatsu> they're part of the metatheory
21:26:26 <augur> kamatsu: sure they are
21:27:03 <augur> they're part of ND proofs in every explicit ND presentation i've seen
21:27:12 -ChanServ(ChanServ@services.)- Foundership transferred from dons, shapr, johnw to edwardk.
21:27:13 <kamatsu> yes, because they're part of the metatheory
21:27:27 <monochrom> Ghoul_: which module is IArray from?
21:27:35 <kamatsu> you can hardly construct a proof in ND without using the metatheory of ND.
21:27:42 <shachaf> edwardk is dictator now?
21:27:45 <augur> kamatsu: no, they're part of the nature of ND
21:27:51 <monochrom> kind of
21:27:52 <Ghoul_> Well, it's in Data.Array but I thought it was too hard so I just swapped to Data.Vector
21:27:52 <edwardk> apparently
21:27:57 <augur> kamatsu: hypotheses are named. thats just how ND is
21:27:59 <Ghoul_> which seems more noob friendly.
21:28:18 <kamatsu> augur: yes, named in the metatheory. Your term is just a formula, though. The entire proof structure is in the metalogic.
21:28:19 * shachaf was OK with the inactive +Fs, "just in case".
21:28:30 <copumpkin> yeah
21:28:41 <kamatsu> augur: You only get STLC if you move the proof structure into your terms.
21:28:43 <augur> kamatsu: no, dude, they're named in the theory itself. ND hypotheses have names
21:28:50 <augur> kamatsu: no you're not listening
21:28:57 <augur> you dont "move proof structure into your terms"
21:29:05 <edwardk> johnw transfered the founder flag to me, but i'm not sure why it wiped out all 3 of the other founders listed.
21:29:08 <augur> ND proof trees _just are_ lambda terms
21:29:32 <copumpkin> edwardk: you can add more in
21:29:39 <augur> written in a tree notation instead of on one line, but otherwise identical but for name choice of the inference rules/constructors
21:29:41 <edwardk> i tried the comma separated list
21:29:43 <Gryllida_> FUCKING SHIT
21:29:49 --- mode: ChanServ set +o copumpkin
21:29:50 <augur> whoa easy there, Gryllida_
21:29:54 <Gryllida_> NIGGERS
21:29:57 <augur> or that
21:29:57 <kamatsu> augur: i agree
21:29:58 <copumpkin> lol
21:30:00 --- mode: copumpkin set -o copumpkin
21:30:35 * copumpkin waves at gry
21:30:40 --- mode: ChanServ set +o edwardk
21:30:43 <Byllida> fucking shit n1gger fucks
21:30:45 <kamatsu> augur: that there is a correspondence between proof trees and lambda terms.
21:30:47 --- mode: ChanServ set +o copumpkin
21:30:49 <Byllida> fuck off fags
21:30:50 --- mode: copumpkin set +b *!cc5d3c28@gateway/web/freenode/ip.204.93.60.40
21:30:51 --- kick: Byllida was kicked by copumpkin (No. Bad.)
21:30:56 <augur> kamatsu: no im not saying there's a correspondence
21:30:57 <augur> ffs
21:31:01 <augur> there's no correspondence
21:31:02 <kamatsu> augur: even a blindingly obvious one
21:31:02 <shachaf> augur, kamatsu: Maybe #haskell-overflow would be better for this discussion, by the way. Lots of noise in here.
21:31:06 <augur> lambda terms ARE proof trees
21:31:15 <augur> shachaf: or just blah
21:31:19 <kamatsu> what do you mean by "ARE"?
21:31:26 <kamatsu> want to move to blah?
21:31:29 <augur> kamatsu: yes
21:31:47 <shachaf> #-overflow sounds better to me -- it's better for longer discussions.
21:33:15 <augur> so whats up with the trolls
21:33:19 <kamatsu> argh, my client won't display messages from those channels, what on earth.
21:39:47 <Ghoul_> hmm, stack overflow
21:40:10 <Ghoul_> maybe Data.Vector is unsuitable for 2 million elements
21:40:20 <applikativ> what are the elements?
21:40:27 <copumpkin> stack overflow doing what?
21:40:29 <Ghoul_> data's.
21:40:31 --- mode: copumpkin set -o copumpkin
21:40:49 <Ghoul_> sec, I'll paste. I was using generateM to generate the immutable vector
21:40:50 <applikativ> are you using Data.Vector with some recursive type?
21:41:42 <Ghoul_> http://pastie.org/private/bjp7ks2qrjrqfqtr34y4ga
21:41:46 <Ghoul_> no its not recursive
21:41:54 <Ghoul_> if I change line 99
21:42:06 <Ghoul_> to like just 1000 or something, it works fine and happens instantly.
21:42:22 <copumpkin> hmm, that seems unfortunate
21:42:37 <augur> copumpkin: is there a troll invasion on irc currently?
21:42:49 <copumpkin> not sure, why?
21:47:41 <applikativ> Ghoul_: bah, this use of Ptr () is over my head :(
21:48:04 <Ghoul_> applikativ: lol, its a file format I hate so much
21:48:08 <startling> is there something like "maybe" for turning a getter for a Maybe a into a getter for an a?
21:48:11 <startling> (in lens)
21:48:11 <Ghoul_> designed for struct loading from C/C++
21:48:22 <applikativ> i see
21:48:23 <edwardk> :t non
21:48:24 <lambdabot>     Not in scope: `non'
21:48:25 <lambdabot>     Perhaps you meant one of these:
21:48:25 <lambdabot>       `not' (imported from Data.Bool),
21:48:31 <edwardk> startling: use 'non'
21:48:34 <edwardk> e.g. non 0
21:48:46 <Ghoul_> But the important line is really on 99. something in generateM recurses enough to blow the stack, maybe..
21:48:52 <shachaf> Sadly, non requires (and uses) Eq.
21:49:00 <edwardk> non x    witnesses the isomorphism between Maybe (a sans x)   and a
21:49:07 <shachaf> Which is unnecessary for the Getter half.
21:49:40 <startling> edwardk: excellent
21:49:47 <startling> (I have Eq anyway)
21:50:13 <monochrom> Ghoul_: did you compile with -O at least?
21:50:30 <Ghoul_> Uh, no, I'll try that.
21:50:38 <edwardk> startling: there is also 'anon' which can be used where Eq can't be solved in general but can for the target element
21:50:44 <edwardk> anon null Map.empty, etc.
21:50:52 <startling> cool
21:50:57 <Ghoul_> It works with -O
21:51:00 <pdxleif> hakyll site is down. :(
21:51:00 <startling> is non a prism?
21:51:03 <Ghoul_> is there some way I can force it on the file
21:51:07 <Ghoul_> from the source file
21:51:12 <monochrom> no
21:51:16 <Ghoul_> damn.
21:51:17 <edwardk> its an isomorphism so, trivially, yes.
21:51:26 <shachaf> edwardk: Will break when 3.10 comes out. :-(
21:51:32 <arkeet> he speaks!
21:51:45 <edwardk> anon will break, yeah. anon will take a prism in the new version
21:58:13 <Gracenotes> edwardk: you are op'd
21:58:23 <applikativ> pdxleif: I think most of the info is buried in the git repository anyway, e.g. https://github.com/jaspervdj/hakyll/blob/master/web/index.markdown
21:59:18 <JIMB> niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers niggers 
21:59:29 <applikativ> wow, pretty effective
21:59:40 <kamatsu> oh man, the trolls :/
21:59:47 <polack> fucking niggers
21:59:51 <polack> fuck off
22:00:04 --- mode: ChanServ set +o shachaf
22:00:08 <polack> fUCK OFF NIGGERS
22:00:11 <applikativ> hm, we need to get rid of polack evidently
22:00:11 --- mode: shachaf set +b *!*cc5d3c27@*.204.93.60.39
22:00:11 --- kick: polack was kicked by shachaf (polack)
22:00:12 <arkeet> +r ?
22:00:31 <edwardk> Gracenotes: ^- that is why
22:00:33 <arkeet> oh there's an IP range.
22:00:46 <applikativ> :(
22:00:59 <augur> applikativ: >_>
22:01:05 --- mode: shachaf set -bb *!*cc5d3c27@*.204.93.60.39 *!cc5d3c28@gateway/web/freenode/ip.204.93.60.40
22:01:15 --- mode: shachaf set +b *!*@*204.93.60.*
22:01:21 <Gracenotes> oh. active patrol.
22:01:26 <Gracenotes> go away, mean people
22:02:07 --- mode: shachaf set -o shachaf
22:04:29 <Guest27539> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK
22:04:29 <Guest27539> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK
22:04:29 <Guest27539> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK
22:04:29 <Guest27539> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK
22:04:29 <Guest27539> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK
22:04:30 --- mode: ChanServ set +o monochrom
22:05:35 --- mode: monochrom set +m
22:05:50 --- mode: monochrom set +b *!*@*.anchorfree.com
22:05:58 --- kick: Guest27539 was kicked by monochrom (Guest27539)
22:06:01 --- mode: monochrom set -m
22:06:42 * relrod seconds arkeet's suggestion of +r for a while.
22:06:54 <arkeet> maybe if it keeps up
22:07:14 <applikativ> hm, I guess the new cabal sandboxing works more or less live cabal-dev
22:07:20 <kamatsu> what's +r?
22:07:35 <arkeet> only registered users may join, iirc
22:07:38 <relrod> yeah.
22:07:42 <shachaf> +R, isn't it?
22:07:47 <arkeet> I forget.
22:07:48 <applikativ> so I can't really do cabal sandbox  for several projects simultaneously
22:07:49 <hvr> applikativ: I like cabal's native sandboxing more than cabal-dev
22:07:51 <Gracenotes> one is join, one is talk.
22:07:51 <shachaf> Anyway, we'll see if it goes on.
22:07:55 --- mode: ChanServ set +o edwardk_
22:07:56 <arkeet> there exists a network for which it is +r
22:08:01 <haasn> I think one of the two is only registered users can join, the other being only registered users can send messages
22:08:10 <sp3ctum_> wow sounds like a really bad monday for someone
22:08:22 <arkeet> or maybe it's a magical ban mask
22:08:57 <monochrom> R is deprecated. they suggest +q $~a instead (for silencing)
22:08:59 <applikativ> hvr: oh you have used it.  I never used cabal dev but have been using the native sandboxing lately
22:09:11 <applikativ> or rather, I only tried cabal-dev
22:09:29 <hvr> i see
22:09:31 <Gracenotes> ah. ... last time I did any serious moderating, freenode had a totally different ircd. anyway, though, Haskell :)
22:10:07 <applikativ> hvr: but I was looking at cabal dev tutorials to see how one could be working on two or three related projects at once
22:13:20 <applikativ> hvr: but basically if I have three related packages I'm working on I have to do cabal <sandbox> install x y from inside the sandbox for z, I guess.
22:13:51 <applikativ> whereas I can just do cabal build inside the sandboxed z, to build z as usual
22:13:52 <hvr> applikativ: iirc with cabal's native sandbox, the sandbox doesn't have to be associated with one project specifically
22:14:06 --- mode: ChanServ set +o edwardk_
22:14:36 <hvr> applikativ: you just need to have the .-file pointing to the same sandbox in place in all 3 projects
22:14:45 <applikativ> hvr: I see, that's what i was wondering. but e.g. cabal sandbox init doesn't take arguments, maybe it looks for subdirectories with .cabal files
22:15:57 <applikativ> oh wait, does cabal sandbox init not require a .cabal file?
22:16:10 --- mode: ChanServ set +o monochrom
22:16:10 --- mode: monochrom set -b $a:perdent
22:16:10 --- mode: monochrom set -o monochrom
22:16:20 <hvr> applikativ: it doesn't :-)
22:16:33 <applikativ> indeed not; it's getting clearer now.
22:16:57 <applikativ> It's been awesome but so far on reflection my use has been a little primitive...
22:18:11 <hvr> applikativ: maybe related: https://github.com/haskell/cabal/issues/1356
22:18:52 <hvr> applikativ: there are *many* other sandbox related issues over there, which are interesting to read
22:20:22 <applikativ> i see, yeah, it ought to have occured that that's where the documentation is so far, so to speak
22:25:34 <kamatsu> so, how mature is cabal sandboxing?
22:25:39 <kamatsu> is it ready for regular use?
22:26:13 <applikativ> I've been using it for a month or so, but in what's clearly a pretty elementary way.
22:27:13 <applikativ> kamatsu: have you used one of the other 'sandboxing' methods?
22:28:42 <arkeet> what does it do that say hsenv doesn't?
22:28:43 <applikativ> in any case, it is supposed to appear with the next Cabal/cabal
22:28:56 <arkeet> or cabal-dev
22:29:21 <applikativ> I think it is attempting to make something like cabal-dev a part of cabal
22:29:26 <arkeet> ok.
22:29:37 <arkeet> that's about all I know, too.
22:29:49 --- mode: ChanServ set +o edwardk
22:29:50 <applikativ> hsenv and cabal dev both had 'cabal-dev ghci' like commands
22:29:56 <startling> is there something like MonadError somewhere that lets me run multiple actions and collect all the errors from each of those actions?
22:30:17 <kamatsu> i used cabal-dev a bit
22:30:31 <kamatsu> but it ended up being too annoying. Now I just wipe ~/.ghc and ~/.cabal periodically
22:30:43 <applikativ> kamatsu: yes, that was my method...
22:30:43 <arkeet> maybe you should try hsenv instead
22:30:45 <joelteon> heh
22:30:52 <arkeet> and no need to wipe all of .cabal
22:30:59 <arkeet> in particular you might want to keep config, world, and bin
22:31:01 <joelteon> yeah, that'll kill your config and that's just annoying
22:31:11 <kamatsu> eh, i don't have anything special in my config
22:31:20 <joelteon> you think that NOW
22:31:21 <arkeet> maybe you should!
22:31:25 <arkeet> like profiling
22:31:27 <shachaf> arkeet: Note that bin/ often has references to things in lib/.
22:31:38 <arkeet> shachaf: share stuff?
22:31:39 <shachaf> @where cabal-cabal -- kamatsu:
22:31:39 <lambdabot> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
22:31:50 <shachaf> arkeet: Or maybe I'm thinking of share/.
22:31:51 <shachaf> I don't know.
22:31:59 <dope> fucking niggers
22:31:59 <arkeet> I don't know what you are thinking, either.
22:32:04 <dope> SUCK MY DICK
22:32:06 --- mode: ChanServ set +o shachaf
22:32:09 <applikativ> share should go, that's where the haddocks are.
22:32:09 --- mode: shachaf set +b *!*327550b7@*.50.117.80.183
22:32:09 --- kick: dope was kicked by shachaf (dope)
22:32:20 <startling>  
22:32:20 <startling> e.g. I want something vaguely like (MonadError e m1, MonadError [e] m2) => [m1 x] -> m2 [x]
22:32:26 <monochrom> I'm just going to put on +r
22:32:29 --- mode: ChanServ set +o monochrom
22:32:30 <applikativ> actually, I kill .cabal/lib etc most often because haddocking has become too slow
22:32:32 --- mode: monochrom set +r
22:32:37 --- mode: monochrom set -o monochrom
22:32:44 <shachaf> OK, sounds reasonable at this point.
22:32:45 --- mode: shachaf set -o shachaf
22:32:58 <monochrom> I'll set a clock to -r 10 hours later
22:33:15 <hpaste> irene-knapp pasted “Mac OS X 10.9 beta 2” at http://paste.tryhaskell.org/90742
22:33:57 <irene-knapp> if I had a working set of flags
22:34:03 <irene-knapp> I could persist them by recompiling ghc
22:34:09 <irene-knapp> with appropriate build.mk changes
22:34:10 * arkeet misread that as a working set of legs. =(
22:34:13 <irene-knapp> nope.
22:34:41 <irene-knapp> alas, I do not.  -optc=—sysroot=/blah and the same path to -optl=—sysroot=
22:34:47 <irene-knapp> gets me started, since those are the first hurdles
22:34:58 <irene-knapp> but it's trying to link against a dylib in an absolute path, and that dylib no longer exists in this version
22:35:14 <irene-knapp> I'm not clear on why it is trying to do that, since it's *supposed* to be linking against the libsystem wrapper
22:35:28 <irene-knapp> it's not following the platform ABI in that respect, in other words ><
22:36:36 * irene-knapp hmmmms and wonders if this could be an xcode version problem
22:36:44 <irene-knapp> whoa
22:36:57 <irene-knapp> okay, for future googlers: xcode-select the Xcode 5 and everything just works ><
22:37:01 <irene-knapp> I am a happy but confused Irene
22:38:35 <applikativ> are you actually using XCode rather than , e.g. the gcc that comes with it
22:38:49 <monochrom> she left
22:38:55 <applikativ> ah
22:41:31 <osa1> what is the state of art to 'catch' from within MonadIO? Google search returned lots of discussions and ways to do that, I was wondering if we have a easy/true way to do that ..
22:41:54 <mstksg> hey guys, i'm trying to launch two separate instances of a monad within a monad transformer (a RandT that contains two independent ST/State monads with different states that aren't connected)
22:42:06 <mstksg> has anyone ever tried this?
22:42:31 <mstksg> i'm having problems with the types of the sub-functions that are called within the ST monad
22:42:45 <applikativ> BlahT (StateT s (StateT s' m)) a
22:42:47 <mstksg> and how to pass the generator/bind them sequentually to the RandT
22:42:57 <Ghoul_> fmap BS.pack $ peekCStringLen (castPtr strptr, strlen) gives me "couldn't match type [Char] with [Word8]"
22:43:00 <Ghoul_> where BS is ByteString
22:43:02 <Ghoul_> any ideas?
22:43:17 <mstksg> applikativ: the states aren't within eachother, they are run sequentially/in series
22:43:31 <Ghoul_> peekCStringLen returns a String (or [Char]).
22:43:33 <applikativ> mstksg: isn't this always equivalent to BlahT (StateT (s,s') m) a
22:43:43 <applikativ> oh
22:44:11 <mstksg> the two states don't ever "interact" so I don't really want to put them both under the same monad
22:44:51 <monochrom> Ghoul_: how about BS.packCStringLen directly
22:45:19 <Ghoul_> Oh! That's what I was looking for
22:45:23 <Ghoul_> I swear I couldn't find it, thanks!
22:46:58 <mstksg> i think the solution might have to do with hoist
22:47:01 <applikativ> mstksg: I was just wondering how you wrote the type, though
22:47:24 <applikativ> yes I was wondering if hoist and zoom might be of assistance
22:48:07 <mstksg> i have some code up at http://stackoverflow.com/q/17516407/292731
22:48:38 <mstksg> note i've never actually used monad transformers in real projects so all of this is a little new to me
22:51:27 <mstksg> i'm not even sure if transformers is the way to go; but i don't really know how to begin rolling my own monad
22:51:33 <mstksg> for this case
23:01:00 <kamatsu> mstksg: In all my years of haskelling, i've had to roll my own monad about 3 times.
23:01:30 <kamatsu> every other time it's some combination of transformers.
23:02:02 --- mode: ChanServ set +o edwardk
23:05:58 <tnks> playing around with lambdabot. . . a little rough/new still on cabal, but I did a "cabal install lambdabot" which seemed to work.
23:06:36 <tnks> but I'm getting a "Could not find module `SimpleReflect'" when I try a simple evaluation.
23:06:47 <shachaf> kamatsu: Especially when Cont and Codensity are available!
23:06:51 <tnks> cabal seems to indicate that simple-refect is installed.
23:07:58 <monochrom> the module name seem to be Debug.SimpleReflect
23:08:17 <shachaf> Yes. Pristine.hs is outdated.
23:08:36 <shachaf> lambdabot is "high-maintenance". You have to know what you're doing, or how to figure out what to do.
23:08:51 <shachaf> Not quite intended for general consumption, though it's getting better.
23:09:08 <shachaf> (I'm only saying this as a sort of warning -- lots of fiddling lies ahead of you.)
23:09:30 <flebron> Say I have a type t which is a Read instance. Given a String, is there a way to obtain a Maybe t?
23:09:36 <tnks> shachaf: oh well, maybe I'll punt.
23:09:45 <tnks> feels like I'm really close, though.
23:15:24 <copumpkin> flebron: fmap snd . listToMaybe . reads
23:15:26 <copumpkin> or something like that
23:15:32 <copumpkin> :t fmap snd . listToMaybe . reads
23:15:35 <lambdabot>     No instance for (Read a0) arising from a use of `reads'
23:15:35 <lambdabot>     The type variable `a0' is ambiguous
23:15:35 <lambdabot>     Possible fix: add a type signature that fixes these type variable(s)
23:15:44 <copumpkin> :t reads
23:15:44 <lambdabot> Read a => ReadS a
23:15:44 <FreeFull> copumpkin: fst
23:16:15 <shachaf> Though it *should* be snd!
23:16:44 <copumpkin> hm, fair enough :)
