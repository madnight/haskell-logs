00:01:52 <augur> external-reality: there are no sets in computers nor could there be
00:01:58 <augur> there are only things masquerading as sets
00:05:04 <external-reality> augur: Is that a jest at my user name?
00:05:16 <augur> external-reality: no?
00:05:36 <augur> i dont know how it could be a jest at your username
00:06:19 <ethoma> Does anyone know how to get GHC to compile for 64 bit machines on Windows? I have a 64 bit machine but it seems integers still default to 32 bits.
00:08:29 <shachaf> "Integer" is unbounded.
00:08:55 <shachaf> "Int" is probably the machine word size. If it's 32 bits, you probably installed the 32-bit version of GHC.
00:09:33 <ethoma> Okay - I bet when I tried installing the 64 bit version it just did not overwrite the 32 bit version for some reason.
00:10:21 <shachaf> I don't know how it works on Windows.
00:10:26 <Kinnison> Is Windows ILP64 or LP64?  If the latter, then Int will still be 32bit, surely?
00:11:30 <zvrba> LLP64, actually.
00:11:34 <zvrba> with visual c
00:11:55 <shachaf> What do any of those have to do with Haskell?
00:12:02 * hackagebot git-monitor 1.3.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-1.3.0 (JohnWiegley)
00:12:04 * hackagebot gitlib 1.2.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-1.2.0 (JohnWiegley)
00:12:06 * hackagebot gitlib-cmdline 1.2.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-1.2.0 (JohnWiegley)
00:12:08 * hackagebot gitlib-libgit2 1.2.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-1.2.0 (JohnWiegley)
00:12:10 * hackagebot gitlib-sample 1.2.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-1.2.0 (JohnWiegley)
00:12:48 <shachaf> The size of CInt will surely be the same as the size of "int" in C.
00:12:57 <Kinnison> shachaf: I guess very little since ABI tends to formed around things like the Word* and C* stuff
00:13:52 <Kinnison> If you want 64bit Ints, why not use Int64 ?
00:15:44 <shachaf> Presumably ethoma wanted x86-64 executables, and was using the size of Int to check for that.
00:18:22 * hackagebot gitlib-test 1.2.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-1.2.0 (JohnWiegley)
00:18:27 * hackagebot gitlib-utils 1.2.0 - Generic utility functions for working with Git repositories  http://hackage.haskell.org/package/gitlib-utils-1.2.0 (JohnWiegley)
00:22:39 * Kinnison really should get gitlib out and start playing with it.  Perhaps in a few weeks
00:22:50 <johnw> if you have any questions, please let me know
00:23:16 <Kinnison> johnw: I guessed you'd pop up and say that as soon as I pressed enter :-)
00:23:22 <johnw> :)
00:23:52 <Kinnison> OOI, when you build gitlib-libgit2 are you relying on a system-provided libgit2 or do you build a libgit2.a for your binding directly?
00:25:03 <johnw> I have my own fork of libgit2 and gets build by cabal
00:25:12 <johnw> it has a few tweaks of my own to better suite its use under hlibgit2
00:25:25 <johnw> all of which have been submitted upstream, just waiting on acceptance
00:25:45 <Kinnison> nod.
00:26:17 * Kinnison hopes the libgit2 guys reach a 1.0 ABI soon, it's really annoying that every app I know which uses it, ends up submoduling in either a locally tweaked version or a very specific SHA so the ABI/API changes don't bite them unexpectedly
00:26:42 <johnw> yeah, keeping hlibgit2 up to date is a rather large piece of work too
00:31:01 * Kinnison has a Lua git library for the git service he wrote, and that has to submodule a particular version, so that luagit2 then works, so that Gall can use it
00:35:18 <johnw> yeah, I hear you
00:36:30 * Kinnison is glad to know he's not alone in lamenting this pain.
00:36:47 <DigitalKiwi> Kinnison: :D
00:41:42 <shachaf> data DataBox = forall a. Data a => DataBox (Proxy a)
00:41:46 <shachaf> Kind of silly.
00:52:18 <klrr> morning haskellers
00:52:27 <Taneb> Morning
01:11:51 <Taneb> Okay, this is the first time I have really used comonad transformers and I think it's getting out of hand
01:11:58 <Taneb> Well
01:12:08 <Taneb> It isn't getting out of hand, I've only got 2 levels
01:12:23 <Taneb> TracedT (Sum (V2 Word8)) (Store Word8) BlockType
01:12:25 <kryft> Taneb: The first step is admitting you have a problem
01:16:13 <shachaf> Oh! Haddock pages have a Synopsis link on the side.
01:16:32 <shachaf> *That's* how you get links to a specific part of the page without checking the HTML.
01:16:43 <johnw> shachaf: huh, thanks for pointing that out
01:16:45 <opqdonut> oh
01:16:47 <opqdonut> nice
01:18:10 <shachaf> Now I just need the ability to link to an arbitrary line of highlighted source.
01:18:41 <shachaf> There are anchors for line numbers but no links to them.
01:19:05 <shachaf> For that matter it would be nice if the highlighted source was full of links.
01:19:07 <shachaf> Oh well.
01:25:35 <Saizan> that'd need quite a change of hscolour
01:29:36 <sopvop> Is there a data Void a = Void  or similar functor in base, so I don't reinvent it?
01:29:42 <johnw> the void module
01:29:46 <johnw> er, package
01:29:52 <johnw> i don't think it's in base
01:29:58 <sopvop> Void in that package is not a functor
01:30:10 <johnw> ah
01:30:33 <johnw> you use Tagged a Void
01:30:35 <johnw> could
01:31:32 <sopvop> Tagged has Data.Proxy!
01:31:55 <shachaf> sopvop: Proxy is the name for it.
01:32:00 <johnw> i guess that's it
01:32:02 <shachaf> It's going to be in base in the next version, probably.
01:32:09 <shachaf> Void is the name for a rather different type.
01:32:33 <shachaf> johnw: You mean Tagged a () :-)
01:32:40 <johnw> yes, thank you
01:33:10 <quchen> Can you give a simple example for where Void is useful? All I can think of right now is in Pipes, but that's rather specialized.
01:35:26 <johnw> quchen: http://stackoverflow.com/questions/14131856/whats-the-absurd-function-in-data-void-useful-for
01:38:07 <quchen> johnw: Thanks, looks useful
01:39:27 <quchen> So in http://paste.tryhaskell.org/3652160474478280704 the code ensures that there can be no Left values?
01:40:37 <quchen> Well, wait. `Either Void a` already says there can't be Left.
01:41:17 <quchen> So `absurd` in this case is just to satisfy the pattern matcher and the type system?
01:41:30 <supki> Type ensures there are no Left values and code ensures there are no partial pattern matches
01:41:36 <johnw> right, the type is saying that there can be no Left values
01:42:09 <quchen> In other words, what would be bad about leaving the "Left" pattern away, because it can't be reached anyway? Silencing the "non-exhaustive" warning?
01:42:20 <johnw> right
01:42:29 <johnw> the Void type is just a regular type, it doesn't interface with the parser
01:42:52 <quchen> What's "the parser"?
01:43:01 <johnw> GHC
01:43:04 <shachaf> The parser doesn't really have anything to do with it.
01:43:25 <quchen> Why can't (or shouldn't) I just use `undefined` instead of `absurd x`?
01:43:45 <johnw> undefined is more general
01:43:47 <shachaf> I mean, GHC knows that Void is an EmptyDataDecl. If it was smarter about it it could probably detect that and not warn. Just like it does right now for impossible GADT branches.
01:43:55 <johnw> absurd x matches the Void -> a type requirement
01:44:06 <johnw> shachaf: maybe it even does
01:44:24 <aiguu> n a list comprehension, if you use a range does the range generate every iteration or does it generate once or lazily without regenerating at all?
01:44:33 <shachaf> quchen: Because "absurd x" is just using someone else's promise that the code is safe.
01:45:05 <shachaf> undefined is making your own promise. Making promises like that is bad because GHC can't check them.
01:45:34 <quchen> shachaf: In a technical or a human sense? Should I read the `absurd x` as "I as a programmer promise that this won't be reached", as opposed to undefined's "whatever man"?
01:45:58 <shachaf> You're making the promise, but you're basing it on someone else's promise.
01:46:10 <shachaf> As long as they keep their end, you keep your end. The code is total and safe.
01:46:44 <shachaf> When you write undefined, there are no guarantees about anything. Maybe you wrote a proof on paper, or in your head, that the undefined will never be reached. But GHC can't check that proof.
01:47:15 <shachaf> Similarly, you shouldn't use isJust and fromJust rather than pattern matching (or maybe).
01:47:35 <klrr> how should i know if i should use mvar or ioref?
01:47:36 <shachaf> Even if it's completely safe, you're the one guaranteeing that it's safe, not the compiler.
01:47:51 <johnw> klrr: if multiple threads will try to access it at the same time
01:48:05 <klrr> okey
01:48:07 <shachaf> And people are quite bad this kind of thing -- see every NullPointerException ever raised.
01:48:20 <klrr> also, can i use State monad for the same thing?
01:48:29 <klrr> or is it immutable?
01:48:33 <johnw> I really don't know what you mean by "the same thing"
01:48:44 <klrr> not same thing
01:49:44 <klrr> but can it become the same, i want to have possibility to modifiy the varibale during the program, i could make so it keeps passing the same value all over the place and that i each time gives a new copy, but i thought it might be better with variable approuch
01:49:45 <quchen> shachaf: I think I'm getting it partially at least. Suppose I have an `Either Void a` somewhere in my code, and I want to apply the `simple` function from the paste to it. I still don't understand how the difference between writing `absurd x` (which has type a) and `undefined` (also type a) is handled by the compiler.
01:50:18 <johnw> klrr: you can use State to pass around state, if that's what you're asking
01:50:48 <klrr> aka, i want a list of channels and a list of owners which can be modified while my irc bot is running, what should i use?
01:52:14 <hvr> external-reality, byorgey: 'M-x haskell-mode-view-news' would have mentioned it :)
01:52:16 <shachaf> quchen: Who cares about how it's handled by the compiler?
01:52:46 <shachaf> Let's pretend they both compile to the same thing (they actually don't -- absurd x is better, because it'll propagate an old exception rather than making up a new meaningless one).
01:53:05 <johnw> klrr: I would lean toward a TVar for that, but I don't understand much about your code
01:53:06 <klrr> i could use IORef and use Scheme in haskell in 48 hours tutoprial as reference, but im not sure if that's the proper way for my program
01:53:15 <shachaf> If the function's type was Either Int a -> a, the undefined version would continue to compile.
01:53:36 <shachaf> That's bad.
01:53:44 <klrr> johnw: i want a mutable state that follows allong the computation
01:53:57 <johnw> klrr: is your code multithreaded?
01:54:05 <jtanguy> klrr: you might want to take a look at hulk http://chrisdone.com/posts/hulk-haskell-irc-server
01:54:08 <klrr> nope, why would it be?
01:54:12 <johnw> then IORef
01:54:28 <quchen> shachaf: Ah, so it's purely about human error then?
01:54:38 <ziman> quchen, "undefined" is cheating; "absurd" is not
01:54:51 <ziman> absurd is a perfectly valid, pure function
01:55:20 <quchen> ziman: undefined is a perfectly valid CAF, isn't it
01:55:25 <ziman> "undefined" is an unsafe thing that's used as a replacement for code you haven't written yet
01:55:37 <shachaf> quchen: This piece of code will never be reached. It certainly doesn't matter what you write there, not when the program runs.
01:55:57 <shachaf> quchen: No, undefined is not valid, and you should feel bad when you use it.
01:56:08 <ziman> quchen, the difference is philosophical -- if "absurd" is sufficient, there's no reason to reach for "undefined"
01:56:19 <ziman> no reason to stain your code
01:56:27 <quchen> Well, luckily I never use undefined (other than as a prototyping placeholder). :-)
01:56:28 <ziman> also, documentation
01:56:30 <shachaf> The difference is more than philosophical. It's also about catching bugs.
01:56:42 <shachaf> See what I said about isJust.
01:57:10 <ziman> well, yes, "absurd" says more about the case-branch -- it says that it cannot be reached and this is statically checked
01:57:19 <shachaf> Using undefined is very bad, but another bad thing is that you have to remember that the Either was a Left yourself.
01:57:27 <klrr> i dont know enough to write programs
01:57:38 <ziman> while you don't get any of these guarantees with undefined
01:57:38 <johnw> and it also says that if the function's type is changed to be non-Void, you'll get an error in your used of absurd
01:58:46 <quchen> shachaf: I think I've got the right idea now, thanks for your help! Time to search this out in the wild where it will hopefully be useful :-)
01:59:00 <shachaf> Related:
01:59:00 <shachaf> @where boolean-blindness
01:59:00 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
01:59:13 <shachaf> @where crossroad , too, I guess.
01:59:13 <lambdabot> http://www.vex.net/~trebla/haskell/crossroad.xhtml
02:06:12 <tomejaguar> can I get "cabal info packagename" to display info about all versions of packagename, rather than just the latest version?
02:11:57 <parcs_>  bc
02:16:30 <quchen> One more question about absurd's implementation: http://paste.tryhaskell.org/2930553754832863232 First of all, due to the newtype, Void is already strict in its data field (of type Void). Why the "seq"? Second, the "spin" function basically traverses the infinite chain of nested Voids. Why use `spin` when `absurd = absurd` would also typecheck?
02:16:48 <quchen> ... for large values of "One"
02:18:18 <parcs_> quchen: https://github.com/ekmett/void/commit/19b6e1cb05904158ee41d3d5c993b84a605f7b45
02:21:02 <quchen> parcs: Now I'm confused. Shouldn't I be unable to reach the "absurd" section? Why can it <<loop>>?
02:21:44 <quchen> (The type system ensures I need a proper Void to get into the absurd section, and it also ensures I cannot get a Void in the first place.)
02:23:56 <merijn> quchen: Getting Void is easy
02:24:08 <merijn> "undefined :: Void", done
02:24:15 * hackagebot gitlib 1.2.1 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-1.2.1 (JohnWiegley)
02:24:28 <Kinnison> Another one?
02:24:40 <Kinnison> johnw -- you need to check your uploads more carefully :)
02:24:49 <quchen> let void :: Void; void = void in void -- void void void
02:24:50 <johnw> uh oh, what did I do?
02:25:28 <quchen> merijn: Is there a way of getting it that's unintentionally possible? ;-)
02:25:51 <Kinnison> johnw: 130m between gitlib uploads :-)
02:26:16 <johnw> well, this one happened because a pull request turned up some unfortunate code repetition, so I added a new API method
02:26:30 <Kinnison> :-)
02:26:41 <Kinnison> The closer gitlib gets to perfect, the happier I am
02:26:46 <Kinnison> so no complaints from me :-)
02:27:06 <johnw> also, today I added the ability for Repository instances to distinguish at the type-level as to whether they support MutableTree's (which can allow for certain optimizations, in the case of gitlib-libgit2), or only PersistentTree's.
02:27:45 <johnw> so, it's now a type error to use "unsafeMutateTree" on a CmdLineRepository :)
02:28:33 <shachaf> Hmm, that sounds like a name error.
02:29:01 <shachaf> If it's called unsafe it should be unsafe!
02:29:18 <shachaf> Try adding an unsafeCoerce.
02:29:34 <johnw> "mutateTree tree" returns a new tree after applying the mutation that can occur within a TreeT.  unsafeMutateTree tree can change the internal structure of "tree", so that you can't really hold onto a reliable reference to a past state
02:30:08 <johnw> this is done because of the way libgit's treebuilder structure works
02:30:26 <shachaf> That sounds to me (on a less joking note) like something that should either be safe or not exist at all.
02:31:08 <johnw> it's safe if you are writing to the abstract API provided by the Repository type class.  you won't be able to ever call unsafeMutateTree.  But it's allowed if you are talking to a LgRepository instance, since it indicates a promise that you really know what you're doing
02:31:14 <johnw> git-monitor uses this functionality, in particular
02:31:25 <johnw> otherwise it would lead to truly needless data copying
02:32:47 <johnw> now, if you're Repository is written all in Haskell, like the CmdLineRepository is, then the mutation isn't needed because of the efficiency of persistent data structures in Haskell.  It's really only the C-ness of libgit2 that makes allowing the distinction worthwhile
02:33:03 <johnw> (or I should say, called for)
02:33:31 <shachaf> That sounds like the sort of thing that oughtn't ever require actual mutation of "pure" values. If they can be mutated they shouldn't be values.
02:33:52 <johnw> libgit's treebuilders are not pure
02:34:46 <shachaf> But I don't really care enough to look at the specifics so I'll stop arguing about it.
02:35:08 <shachaf> C code that isn't pure doesn't mean that the Haskell API wrapping it should be impure...
02:36:02 <eikke> wow, that's deep
02:36:03 <johnw> yeah, we'd need a longer discussion for me to convince you, and it's very late
02:36:11 <johnw> there just one place where the pure version has to do a copy operation that the impure version doesn't, and I'd love to see if you knew of a way to avoid that copy
02:36:31 <prophile> this isn't strictly haskell, but any suggestions on constructing a logical expression for 'exactly n of these boolean variables are true' without blowing up to a ridiculous size?
02:36:33 <johnw> because it can be an expensive copy
02:37:03 * eikke wrote a read-only Python implementation of Git a couple of years ago, wondering whether something alike has been done in Haskell, shouldn't be too hard
02:37:13 <johnw> eikke: there's the hit package
02:37:20 <johnw> i do intend to write a gitlib-hit backend at some point
02:37:35 <johnw> so that you can write pure-Haskell Git utilities which don't use command-line Git either
02:38:17 <eikke> sounds interesting
02:38:54 <johnw> it would only take about a couple hours to do too, but it's been hard to make time for it!  maybe someone else will take up the challenge
02:39:00 <johnw> once written, I'd be happy to maintain it
02:41:45 <parcs> ghc generates strange core for 'absurd (Void a) = absurd a'
02:43:24 <parcs> it looks like { a = b realWorld#; b _ = a; absurd _ = a }
02:49:32 <ion> ಠ
02:50:05 <parcs> i suppose with 'absurd (error "foo")' one would except to see "error: foo" instead of "<<loop>>" which is what the seq does
02:53:19 <parcs> http://stackoverflow.com/questions/11070690/how-do-exceptions-in-haskell-work
03:10:27 <bitonic`> is there a ‘newtype Const a b = Const a’ defined somewhere?  I’d expect that to appear in some package by edwardk :P
03:10:37 <johnw> i believe that's in Data.Functor?
03:10:59 <bitonic> johnw: oh yes, you’re right!  thanks
03:11:00 <johnw> no, Control.Applicative
03:11:06 <johnw> or maybe re-exported there
03:11:23 <bitonic> yeah it’s in Control.Applicative.  somehow I never noticed.
03:11:29 <bitonic> but it lacks instances
03:11:56 <bitonic> I need ‘instance Num a => Num (Const a b)’
03:12:11 <shachaf> That sounds like a fishy instance.
03:12:19 <shachaf> On the other hand instances like Show would be nice.
03:12:41 <bitonic> shachaf: why is it fishy?
03:13:04 <shachaf> For the same reason Num a => Num (Identity a) would be fishy.
03:13:25 <Lethalman> what's the usefulness of Const?
03:13:25 <bitonic> shachaf: why is Num (Identity a) fishy :P?
03:13:53 <Lethalman> only introducing a phantom type?
03:14:13 <bitonic> Lethalman: in my case I have a data type that takes a ‘* -> *’, and sometimes I don’t need the parameter
03:14:28 <bitonic> so I just want to throw it away
03:14:36 <bitonic> Const lets you do that
03:15:12 <johnw> today I wished I'd had "flip" at the type level
03:15:14 <Lethalman> mh ok
03:16:46 <Mikicacarica> FREE BRAZZERS ACCOUNTS EVERYDAY HERE ---> http://gratisbrazzers.blogspot.com
03:17:06 <ocharles> Lethalman: Const is very useful when you want to fold a monoid over some arbitrary structure
03:17:54 --- mode: ChanServ set +o johnw
03:17:57 <ocharles> Lethalman: for example, if I have a 'Tree a', I can turn every leaf into '[a]', and then I can use the monoid instance of '[a]' to concatenate them all. So I get a 'Tree a -> [a]' function
03:18:08 --- mode: johnw set -o johnw
03:18:29 <ocharles> For every node, I just apply 'Const . (:[])', or 'Const . pure', depending on how you want to write it
03:19:04 <shachaf> ocharles: Note that you get O(n^2) behavior with a left-biased tree this way.
03:19:22 * hackagebot hatex-guide 1.0.1.4 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.0.1.4 (DanielDiaz)
03:19:26 <johnw> hmm.. I wonder why there isn't a ConstT
03:19:30 <shachaf> If you use Endo [a] as your monoid you can get O(n) instead. :-)
03:19:51 <shachaf> Why would there be a ConstT?
03:19:54 <ocharles> johnw: isn't that Compose?
03:20:03 <ocharles> johnw: Const is not a monad, if you're thinking that
03:20:11 <johnw> ConstT a m b says: i only care about the value a, but I want the side effects from m
03:20:15 <bitonic> shachaf: so what’s wrong about instances like that for Const/Identity?
03:20:17 <johnw> ah, ok
03:20:17 <Lethalman> ocharles, \o/
03:20:27 <Lethalman> ocharles, isn't that a simple fold that starts with [] ?
03:20:33 <Lethalman> why would you need Const?
03:20:48 <ocharles> Lethalman: sure, there are other ways to do it
03:20:59 <ocharles> But the nice feature is we already have this class called 'Traversable'
03:21:01 <ocharles> :t traverse
03:21:01 <lambdabot>     Not in scope: `traverse'
03:21:02 <lambdabot>     Perhaps you meant one of these:
03:21:02 <lambdabot>       `T.traverse' (imported from Data.Traversable),
03:21:02 <shachaf> bitonic: I don't know if they wrong. They seem fishy.
03:21:04 <ocharles> yay
03:21:08 <ocharles> :t Data.Traversable.traverse
03:21:09 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
03:21:21 <Lethalman> yes
03:21:30 <bitonic> shachaf: uhm, okay.
03:21:31 <ocharles> Lethalman: traverse walks over any traversable structure, applying some function with side effects in an applicative functor for each 'element'
03:21:44 <Lethalman> I see
03:21:45 <ocharles> Lethalman: so we can write this recursion once, and using Const we can derive a fold out of it
03:21:46 <Lethalman> :t foldr
03:21:46 <lambdabot> (a -> b -> b) -> b -> [a] -> b
03:22:00 <Lethalman> here is not effectful, so no need for Const
03:22:50 <ocharles> No, but for our 'Tree a', that foldr is no good
03:23:00 <Lethalman> well because it's on lists
03:23:04 <bor0> what is the name of this operator >>=
03:23:06 <ocharles> We do have Data.Foldable, but Data.Traversable is more powerful than that, and we can get a Foldable instance from Traversable
03:23:19 <Lethalman> mh ok
03:23:20 <bitonic> bor0: “bind”
03:23:22 <ocharles> So instead of writing two recursions on our 'Tree', we just do it once in 'Traversable'
03:23:29 <bor0> ok, so that's the binding operator
03:24:22 * hackagebot hatex-guide 1.0.1.5 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.0.1.5 (DanielDiaz)
03:24:41 <ocharles> Lethalman: fwiw, I asked exactly this question a year ago: http://stackoverflow.com/questions/11532050/what-is-the-const-applicative-functor-useful-for :)
03:26:31 <Lethalman> ocharles, awesome thanks
03:27:27 <merijn> johnw: I wish for type level flip and type level compose like every other day... :p
03:27:35 <ocharles> I still don't understand what http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Applicative-Lift.html is though
03:27:46 <merijn> (Yes, I'm aware of Data.Functor.Compose, newtypre wrapping is lame :( )
03:29:10 <shachaf> Type-level flip exists as a newtype too.
03:29:16 <shachaf> Useful for some things.
03:29:56 <bor0> why does this work "data Test = True | False | Abcdef" while this doesn't "data Test = True | False | Abcdef | 0" ?
03:30:11 <ocharles> bor0: 0 is not a valid data constructor name
03:30:35 <bor0> can I make a data type that will accept true, false or a single digit?
03:31:10 <ocharles> Not directly in the data type, i don't think
03:31:15 <ocharles> You would need a smart constructor
03:31:16 <sipa> you can implement Num for your type, and have a fromInteger fubction
03:32:12 <ocharles> data Test = True | False | Abcdef | Digit Int; digit x = if x < 10 && x > -10 then Just (Digit x) else Nothing
03:34:29 <bor0> I can't get "digit x = if x < 10 && x > -10 then Just (Digit x) else Nothing" to pass on ghci
03:35:47 <Rembane> bor0: What error message do you get?
03:36:07 <Rembane> bor0: Also, try to wrap -10 in parenthesisssss, like this: (-10)
03:38:53 <bor0> okay, I got it. thanks
03:39:22 * hackagebot hatex-guide 1.0.1.6 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.0.1.6 (DanielDiaz)
03:58:26 <merijn> ugh
03:58:35 <merijn> Why is naming things so hard? :(
03:58:59 <megajosh2> I can't name anything
03:59:00 <johnw> is there a function for rendering a ByteString as lowercase hexadecimal?
03:59:00 <Entroacceptor> because it doesn't matter much
03:59:04 <megajosh2> Just look at my stupid nickname
03:59:48 <merijn> Entroacceptor: It does for APIs
04:00:54 <supki> merijn: you can let someone else to make a usable wrapper around your api :p
04:01:20 <supki> unless you plan to use it yourself I guess
04:01:30 <merijn> supki: I plan to use it myself
04:02:03 <ocharles> johnw: bytestring-base16?
04:02:28 <ocharles> johnw: sorry, base16-bytestring
04:02:40 <johnw> thank you!
04:02:55 <ocharles> the source code is very wtf-terrifying for what it does :)
04:03:11 <shachaf> johnw: unpack >=> printf "%02x"
04:03:47 <ocharles> shachaf: nice use of the list monad. I should do that more
04:04:24 <johnw> shachaf: clever
04:04:28 <shachaf> base16-bytestring gives you a function of type ByteString -> ByteString. :-(
04:04:47 <shachaf> Which is probably OK for some specialized uses but it has the wrong type and shouldn't really be the default.
04:05:01 <johnw> I am actually wanting ByteString -> Text
04:05:12 <johnw> so either way still requires an additional conversion
04:05:41 <ocharles> shachaf: well, it's a bit unsafe but I think it's ok to assume that the result is ASCII
04:05:48 <shachaf> Text and String are good types.
04:05:55 <ocharles> and Char8.unpack would be "safe enough"
04:06:07 <ocharles> but i agree, the right type would be nice
04:06:13 <ocharles> is this library in the platform?
04:06:17 <shachaf> No.
04:06:28 <ocharles> so it should be quite easy to get it patched then, right?
04:06:47 <shachaf> It also uses unsafe (and hopefully fast?) code to use mutation to write directly into a ByteString.
04:07:01 <ocharles> oh, so that's a bit of a trickier change I guess
04:07:26 <ocharles> I gueess Text can do that though
04:07:50 <shachaf> I don't mind this function existing -- it has some specialized uses, like I said, and we don't have a type that represents these base16 values as efficiently as a ByteString does -- but it shouldn't be the default.
04:12:13 <Baughn> Who do I contact to delete a package from hackage?
04:12:34 <merijn> Baughn: I don't think there's a real process in place to do that, why?
04:12:46 <byorgey> Baughn: I think it's still Ross Paterson, until Hackage 2 goes live at least
04:13:16 <Baughn> merijn: Because it just occurred to me, years back I uploaded a (buggy, incomplete) networking package *containing a custom cryptography implementation*.
04:13:28 <Baughn> merijn: I don't think anyone is *using* it, thank Jade, but I'd like to take it down.
04:13:44 <merijn> Baughn: Oh, yeah, in that case just contact the Hackage maintainers
04:14:11 <shachaf> Baughn: You could overwrite it with a "this package is deprecated" placeholder.
04:14:30 <johnw> "Look ma, no package"
04:14:30 <Baughn> I don't have the password anymore. :X
04:14:43 <Peaker> Baughn, where have you been?
04:14:49 <Peaker> Baughn, you still Haskelling?
04:14:49 <johnw> Baughn: if you e-mail me a tarball, I'll upload it
04:15:04 <merijn> Baughn: Felt bad after reading the evisceration of cryptocat somewhere? ;)
04:15:11 <Baughn> johnw: Um.. will this do:?  ""
04:15:17 <johnw> no
04:15:20 <johnw> it needs a cabal file
04:15:34 <shachaf> Baughn: You should email Ross about that, too, then.
04:16:17 <Baughn> merijn: I read through my code again, and I can't find any obvious flaws. So yes.
04:16:31 <Baughn> merijn: Well, other than the blatant timing attacks.
04:16:54 <Baughn> Peaker: Well, doing non-programming things off work for the most part.
04:17:14 <Baughn> Peaker: Occasionally haskelling, but typically only in conditions where I don't have an internet connection. ^^;
04:17:42 <Peaker> Baughn, heh, remember the "enough" project? It's been making a lot of progress under the "lamdu" name
04:17:49 <merijn> Speaking of which, did thoughtpolice upload his NaCl bindings to hackage yet? >.>
04:19:23 * hackagebot gitlib-libgit2 1.2.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-1.2.1 (JohnWiegley)
04:19:25 * hackagebot gitlib-s3 1.1.1 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-1.1.1 (JohnWiegley)
04:20:44 <Baughn> Peaker: Vaguely.
04:21:02 <zvrba> after LYAH, what's the next recommended book? RWH?
04:21:10 <johnw> RWH isn't bad for a second book
04:21:33 <zvrba> ok
04:21:40 <zvrba> any possible others?
04:22:09 <johnw> after that, you will quickly be leaving the land of books, and entering the land of articles and blog posts, although there are a few other Haskell books out there (I haven't read any of them)
04:22:16 <johnw> for example, the Typeclassopedia
04:22:32 <zvrba> hmm
04:22:36 <zvrba> ok
04:22:43 <Baughn> Typeclassopedia++
04:23:11 <shachaf> _Programming in Haskell_ by Hutton is a good first Haskell book.
04:23:42 <Baughn> Peaker: Most recently, I've been working on an Infinity engine reimplementation (KID, not Bioware), to see if I can get Ever17 running in a browser. Using haskell through GCHJS.
04:23:50 <zvrba> shachaf: does it also cover "real world" stuff?
04:23:55 <merijn> thoughtpolice: btw, do you salt bindings take care not to store keys in swappable memory?
04:23:58 <Baughn> Peaker: Amusingly, it's still faster than the original.
04:24:01 <zvrba> like, IO, binary encoding/decoding, FFI, etc?
04:24:25 <Peaker> Baughn, hah, cool :)
04:24:29 <shachaf> zvrba: I don't think so.
04:25:13 <Baughn> Peaker: Copyright is an issue. I'd *like* to be able to sell the result, *along with the required data*, but the original developers are unreachable. :/
04:26:03 <merijn> Anyone here have (based on names alone) suggestions for a name for the following "supply . lift", I was thinking of "heave" or "hoist", but I'm not really sure of that
04:26:34 <merijn> The 3rd alternative would be some variation of "supply", like "supplyT", "supply'" or whatever, but I don't really like those either
04:26:52 <johnw> what does supply do?
04:26:55 <Peaker> Baughn, there ought to be laws about abandonware...
04:27:17 <Baughn> Peaker: I'm Norwegian, living in Ireland, redeveloping a Japanese game.
04:27:17 <johnw> or rather, what's it's type
04:28:22 <Baughn> Peaker: Serving the code on servers run by an American company but sited in countries all over the globe, to players from *any* country.
04:28:28 <Baughn> Peaker: ...more laws would not help.
04:28:43 <Baughn> A single world government might.
04:29:38 <merijn> johnw: I'm not 100% settled yet, I have two type signatures and I'm trying to name both. Clearly one should be supply, the other dunno yet. The types are: "(s -> f a) -> SupplyT s f a" and "Applicative f => (s -> a) -> SupplyT s f a" (the latter allowing me the special case of Identity to neatly result in "(s -> a) -> Supply s a" without needing to be given a function (s -> Identity a))
04:29:39 <Peaker> Baughn, heh.. less copyrights then
04:29:52 <Peaker> Baughn, you could hire some artists to draw alternate data
04:30:12 <Baughn> Peaker: It's not that kind of game. Yes, I could replace the art - no problem.
04:30:30 <Baughn> Peaker: But the Infinity series is a series of /visual novels/. The *story* is the main draw.
04:30:36 <merijn> (And if I'm gonna special case Identity, I might as well cover all Applicative's)
04:31:01 <johnw> Peaker, Baughn: I think your conversation may be better suited to -blah
04:31:19 <Baughn> Fair point.
04:32:19 <johnw> merijn: maybe just supplyL, for lifted
04:32:48 <merijn> johnw: Yeah, I thought that too, but that looks so ugly, and I'd need to figure out which one to call the lifted
04:33:29 <johnw> grant?
04:34:02 <merijn> It seems odd to call "(s -> a) -> Supply s a" lifted (even though it has an explicit lift) and calling "(s -> f a) -> SupplyT s f a" lifted is odd because it doesn't lift
04:34:22 <johnw> yes, called it "lifted" would be confusing
04:34:36 <merijn> johnw: Oh, plenty of synonyms, like "provide", "furnish", etc. I was just hoping to think of one that seemed to imply the "pure" bit
04:34:55 <johnw> supplicated (j/k)
04:35:28 <merijn> johnw: I'm already very proud of the name "demand :: Supply s s" :p
04:35:52 <johnw> what about environ?
04:36:06 <johnw> since you essentially wrapping a supply around a function in the base monad?
04:37:12 <johnw> or for that matter, scoped
04:38:01 <merijn> ok, time to get dinner, if I don't think of something better when I get back it will be "supply :: (s -> f a) -> SupplyT s f a" and "provide :: Applicative f => (s -> a) -> SupplyT s f a"
04:38:07 <merijn> s/dinner/lunch
04:38:11 <johnw> provide sounds good
04:38:12 <johnw> enjoy!
04:38:20 <merijn> Although, I guess, technically lunch could be dinner
04:53:24 <wlangstroth> zvrba: typeclassopedia gave me my Haskell "aha" moment, so I'll forever recommend it
04:53:46 <HugoDaniel> :)
04:54:24 * hackagebot special-keys 0.1.0.0 - Simple data types that help me here and there.  http://hackage.haskell.org/package/special-keys-0.1.0.0 (HugoGomes)
04:54:32 <simukis_> I got my “aha” when I saw definition for monad typeclass.
04:54:45 <simukis_> so code's still the best way to learn IMHO.
04:55:01 <wlangstroth> simukis_ has a point
04:55:26 <wlangstroth> if monads become frustrating, this is pretty good: https://www.youtube.com/watch?v=ZhuHCtR3xq8&list=WLsPCt39Y_nAQlhxAhoA7xBbpOawdHGLkG
04:56:02 <ocharles> wlangstroth: I love that talk
04:59:24 * hackagebot qhull-simple 0.1 - Simple bindings to Qhull, a library for computing convex hulls  http://hackage.haskell.org/package/qhull-simple-0.1 (GardSpreemann)
05:04:12 <zvrba> wlangstroth: except I hate the convention. sometimes 'f' is used as a type constructor, sometimes as an ordinary function. and everything is named with single-letters >:
05:04:18 <zvrba> anyway.
05:04:59 <zvrba> (like, in pure f <*> pure x = pure (f x) f is not the same f as in the type signature for pure.)
05:05:08 <zvrba> and has no relation to it either.
05:05:13 <supki> unfortunately we cannot name things with zero letters
05:05:30 <zvrba> maybe you should borrow some more delimiters from perl
05:05:32 <zvrba> instead
05:05:37 <zvrba> $_ ftw
05:05:56 <zvrba> perl excels at zero-character arguments, defaulting to $_
05:06:02 <zvrba> </rant>
05:08:46 <tomejaguar> Does anyone know why HaskellDB uses CalendarTime from old-time, rather than Day from Data.Time.Calendar
05:08:50 <merijn> zvrba: In general I don't find it such a big problem as the scope tends to be fairly small
05:09:56 <merijn> zvrba: Basically, identifier name length should increase inverse proportionally to use (i.e. the more often used, the shorter to type/read) and increase proportionally to scope (i.e. the bigger the scope, the longer the name)
05:10:33 <merijn> So "fmap f (Just x) = Just (f x)" are fine, imo, as the scope of f and x are just that one line
05:11:15 <tomejaguar> zvrba: In the type signature for pure you have Applicative f => a -> f a, so you know immediately that f is an arbitrary Applicative.  I don't think it could be any clearer than that.
05:12:58 <Lethalman> ghc from git tells me version 7.7, is that really 7.8 from an api perspective?
05:13:18 <Lethalman> that is, version not bumped yet
05:13:35 <quchen> Lethalman: uneven numbers are intermediate dev versions I think.
05:13:43 <quchen> 7.7 is what will eventually become 7.8
05:13:44 <simukis_> I suspect ghc uses versioning system where even numbers are stable
05:14:22 <simukis_> and uneven mean development versions. Other project that uses this versioning system is GNOME for example.
05:14:25 <Lethalman> quchen, I was looking at ghcjs and requiring 7.8 to be installed straight away, it's ghc from git right?
05:14:25 <mauke> yeah, it's like perl
05:14:28 <luite> Lethalman: things can still change, but it will probably be mostly the same
05:14:48 <Lethalman> (or nightly build that is, ghc 7.7)
05:14:52 <luite> yeah use 7.7
05:15:33 <luite> that 7.8 is just a joke, people have been complaining that ghcjs it too hard to install (rightfully so)
05:15:35 <merijn> Basically, there are only even number ghc releases
05:15:52 <luite> so the solution is to be from the future and install ghcjs the easy way
05:15:57 <luite> (and bring me a sports almanac)
05:16:01 <merijn> People tend to just call what happens in-between them odd numbered :p
05:16:02 <Lethalman> :)
05:16:16 <Lethalman> let's see how hard it is to install ghcjs from 7.6
05:16:22 <luite> Lethalman: impossible
05:16:24 <luite> really
05:16:27 <Lethalman> :S
05:16:33 <Lethalman> isn't it just vagrant up?
05:16:56 <t7> someone make a VM image with ghcjs installed :)
05:16:57 <luite> yeah but the vagrant virtual machine contains GHC HEAD
05:17:02 <luite> t7: already done
05:17:11 <t7> great minds...
05:17:15 <luite> i'm updating it to the latest HEAD in a few days
05:17:29 <luite> there's also a script that builds it from source with vagrant
05:17:34 <luite> which takes a while
05:17:50 <Lethalman> luite, you mean that vagrant up installs ghc 7.8 under the hood?
05:17:52 <luite> yeah
05:17:56 <Lethalman> oh
05:18:02 <Lethalman> then I'll just use my ghc git :-) thanks
05:18:11 <Lethalman> luite, can you say that in the README.md?
05:18:15 <luite> Lethalman: it needs the GHCJS patch to add the JavaScriptFFI extension
05:18:38 <luite> i think it will be merged soon, but we still need to decide on the final form of the patch
05:18:45 <Lethalman> luite, I can understand, so given it needs a patched ghc there's no way from 7.6
05:18:53 <banister> luite: do you have any examples using backbone.js with GHCJS ?
05:19:02 <Lethalman> luite, where can I look at the patch? I'm curious :-)
05:19:23 <luite> Lethalman: yeah it also depends on new cross-platform build features in 7.7/8
05:19:38 <Lethalman> awesome
05:19:44 <quchen> luite: What's GHCJS from a technical standpoint? I vaguely remember that you once called it its own project somehow based on GHC. Are there any plans for adding a JS code generator in GHC?
05:19:58 <Lethalman> luite, is it plugin-based or the javascript ffi is somewhat hardcoded?
05:20:05 <luite> Lethalman: https://github.com/ghcjs/ghcjs.github.com/blob/master/patches/ghc-ghcjs.patch
05:20:31 <luite> Lethalman: the FFI is done in GHCJS itself, so we can change the syntax without requiring changes to GHC itself
05:20:49 <Lethalman> luite, but the backend not a plugin as I can see
05:21:10 <luite> Lethalman: i'm going to make the marshalling changeable as wel in the coming days (after that i'll update the prebuilt vagrant image)
05:21:27 <luite> Lethalman: at the moment, when you return a Bool from ffi, you have to return it as 0 or 1
05:21:36 <luite> a relic from the ccall marshalling
05:21:44 <luite> but it's a bit silly in JS, where you ahve native bools
05:21:53 <Lethalman> luite, indeed
05:21:56 <luite> even more so since haskell Bool is compiled to javascript bool
05:22:06 <luite> so the 0/1 step is entirely unnecessary
05:22:13 <Lethalman> luite, let's say I want to add another backend, do I need to patch ghc or there's a way through plugins?
05:22:34 <luite> Lethalman: another backend to generate javascript? or another target?
05:22:40 <Lethalman> another target
05:23:59 <luite> Lethalman: a few bits still need to be finished. The only thing that GHCJS really needs the patch for is the new JavaScriptFFI extension and some of the FFI marshalling. The rest of the patch is just extending the GHC API to make it easier to write backends
05:24:04 <luite> as plugins
05:24:22 <luite> Lethalman: i'm going to try to make marshalling more plugin-able
05:24:36 <luite> and perhaps adding custom architectures should also be possible through plugins
05:24:48 <Lethalman> good :-)
05:24:56 * Lethalman reading some ghcjs code
05:25:26 <luite> Lethalman: do you have a specific target in mind by the way? SPJ commented earlier today on the patch, said that it would be ok to merge, but better if we can extend it in such a way that it makes it easier to write new backends in general
05:25:53 <luite> so i'll be happy to make some changes if it helps others :)
05:26:02 <Lethalman> luite, not really anything in mind
05:27:22 <luite> Lethalman: changing the parser/lexer for the foreign imports is porbably not something that should be done through a plugin
05:27:32 <luite> and the JSRef type is GHCJS-specifc
05:27:57 <fxr> this question is about test-framework. did you ever get "Unknown flag: -t" error when you invoke one of your tests?
05:27:58 <luite> Lethalman: btw the ghcjs code is rather ugly, i apologize in advance ;p
05:28:37 <Lethalman> luite, well I'm not very knowledged on haskell, so I can't even judge :P
05:28:42 <luite> Lethalman: i'll be cleaning it up before release (official release is planned when 7.8 is out)
05:29:07 <luite> right now i'm switching the intermediate format to binary files to make linking faster and the resulting code smaller
05:30:59 <luite> code size is still a bit of a problem, but we have good optimizations, that just need to be tweaked a bit more. after compiling a module (Actually after a top-level block) it optimizes the javascript functions using dataflow analysis, rewriting expressions, eliminating dead code, unused variables, unnecessary assignments
05:31:21 <luite> and when linking it does some link-time optimization now, renaming lots of things
05:34:58 <Lethalman> luite, so you aren't exploiting ghc optimizations somehow
05:35:05 <luite> Lethalman: more people have asked about backbone.js btw, do you think using backbone would be preferable to using a haskell frp lib?
05:35:50 <Lethalman> luite, depends on whether it's a new project, or you're going to integrate an existing one I guess
05:36:08 <Lethalman> luite, also I'm not very knowledged about frp in general, don't know its full expressiveness and limits
05:36:14 <luite> Lethalman: ghcjs uses STG as the source language. GHC normally compiles   Haskell -> Core -> STG -> Cmm (-> LLVM optionally) -> Native
05:36:28 <Lethalman> ok
05:36:38 <luite> Lethalman: most of the optimizations, rewrite rules, specialization etc, happen on Core, so we do get those
05:36:44 <Lethalman> I see
05:36:56 <luite> Lethalman: but the low-level optimizations, that GHC does on Cmm, are the ones that we have te reimplement for JavaScript
05:38:50 <luite> Lethalman: and the link-time things are JS-specific anyway
06:06:54 <thoughtpolice> merijn: not at the moment they don't. that's eventually something i want to do, but i'm not doing it now (realistically 0 haskell crypto libraries do this anyway)
06:07:32 <merijn> thoughtpolice: ooh, if I feel like procrastinating I might look into that!
06:07:39 <merijn> Seems like a cool challenge to tackle
06:07:51 <hseg> The implementation of some and many in Alternative here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html causes them both to evaluate to bottom.
06:07:58 <merijn> (Can you tell I'm procrastinating from writing documentation?)
06:09:11 <merijn> hseg: Yes, that's the same as the definitions for (==) and (/=) in the Eq class
06:09:32 <merijn> hseg: It's so that you only have to implement one of the functions
06:09:34 <hseg> Specifically, since many_v = some_v <|> pure [] and not pure [] <|> some_v, the left-hand side for that <|> is always infinite, and we therefore cannot use lazy techniques to make use of the functions.
06:10:10 <hseg> It is not the mutual recursion that's the problem. It's the fact that many_v doesn't have a minimally-defined state.
06:10:16 <merijn> hmm, wait
06:10:42 <merijn> hseg: No, you're wrong
06:10:58 <hseg> How's that?
06:11:01 <merijn> hseg: It is not always infinite
06:11:11 <merijn> hseg: some_v is empty if v is empty
06:12:25 <hseg> No, some_v = pure empty if v = empty. But I see your point. What happens in the case v /= empty?
06:13:26 <merijn> > some (Just 1)
06:13:29 <lambdabot>   mueval-core: Time limit exceeded
06:13:46 <merijn> You get "Just <infinite list of ones>" I think?
06:14:14 <merijn> I'm not sure I understand some/many though
06:14:21 <supki> you get bottom I think
06:14:30 <hseg> Let me pose the problem differently. What's the difference between let x = 1 : x in x and let x = x ++ [1] in x
06:14:45 <hseg> > fix (1:)
06:14:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:14:55 <hseg> > fix (++[1])
06:14:59 <lambdabot>   mueval-core: Time limit exceeded
06:15:54 <hseg> Thus, since in many_v, the non-infinite part is on the left-hand side, the infinite list has no minimally-defined value from which it can be evaluated.
06:17:38 <supki> > many Nothing
06:17:39 <lambdabot>   Just []
06:17:43 <supki> > some Nothing
06:17:44 <lambdabot>   Nothing
06:18:40 <hseg> Again, as said above, in the cases where v=empty, these equations do have a sensible value. It's when v/=empty that we run into problems
06:20:38 <ocharles> Can DataKinds be used for this type of dependent type stuff? 'edges :: (a :: Vertex) -> (b :: Vertex) -> [Edge a b]'
06:21:04 <ocharles> where 'data Vertex = A | B', such that edges A B :: [Edge A B]
06:22:12 <hseg> Proposal (which would solve the problem): replace definition of many_v in Applicative to many_v = pure [] <|> some_v
06:22:46 <merijn> ocharles: Not without encoding the type of Vertex as a phantom type
06:22:47 <t7> GHC is like GCC, maybe its time for a clang
06:22:54 <ocharles> merijn: In Vertex itself?
06:23:01 <ocharles> Or Tagged?
06:23:51 <supki> hseg: in e.g. parsec both many and some have non-bottom values for non-empty arguments
06:24:11 <supki> apparently I don't undestand the question
06:24:24 <hseg> Odd. Apparently I don't understand the problem.
06:24:24 <merijn> ocharles: You could use a GADT "data VertexType = AType | BType; data Vertex :: VertexType -> * where A :: Vertex AType; B :: Vertex BType; edges :: Vertex a -> Vertex b -> [Edge a b]"
06:24:49 <ocharles> right
06:24:52 <ocharles> this also seems to work:
06:25:09 <supki> I've never seen any meaningful usage of many/some in non-parsing context though
06:25:11 <ocharles> data Tagged (a :: Vertex) b = Tagged b
06:25:24 <ocharles> but then I guess you could instantiate weird vertexs
06:25:35 <ocharles> like Tagged A :: Tagged B Vertex
06:25:36 <merijn> ocharles: Yeah
06:25:41 * ocharles goes with a GADT
06:25:48 <merijn> <3 GADTs
06:26:09 <ocharles> I wonder how this looks in Agda
06:26:16 <ocharles> hopefully I don't need to do this GADT stuff at all there
06:26:45 <supki> hseg: well, in parsec  empty = mzero  and given the law  mzero >>= k = mzero  you can get non-bottom values from many/some
06:26:58 <supki> maybe many/some should be in MonadPlus
06:27:01 <supki> I don't know
06:27:24 <quchen> They should probably not be in Alternative.
06:27:51 <quchen> (The module seems fine, it's just that they're in the typeclass what is odd.)
06:28:16 <hseg> Why is it odd that they are in the typeclass?
06:28:35 <merijn> quchen: I think you're supposed to override them
06:29:26 * hackagebot Commando 0.1.0.0 - Watch some files; Rerun a command  http://hackage.haskell.org/package/Commando-0.1.0.0 (LyndonMaydwell)
06:29:27 <quchen> merijn: For performance reasons? Are the default definitions that bad?
06:29:28 * hackagebot Conscript 0.1.0.0 - Restart a command on STDIN activity  http://hackage.haskell.org/package/Conscript-0.1.0.0 (LyndonMaydwell)
06:29:42 <merijn> Hmm, where should I put package wide documentation that doesn't fit in any specific module? In the cabal package description? Pick a random module to dump them in?
06:30:12 <quchen> Random documentation is always a good idea.
06:30:44 <quchen> If you're writing something about the entire package, I think the package description should be fine.
06:30:51 <quchen> Otherwise maybe consider the main module of the package.
06:31:06 <merijn> Although I guess that doesn't let me hyperlink documentation :\
06:31:13 <merijn> quchen: I don't have a main module
06:31:40 <shergill> i'm trying to track down an error i'm having during lambdabot build. does anyone here have ghc 7.6.3 via nixpkgs?
06:31:57 <quchen> merijn: But your doc is so important you can't just leave it away?
06:32:35 <quchen> merijn: I mean when you can't decide where it goes it's probably redundant, unless it's relevant to everything, in which case it's for the package intro
06:32:42 <merijn> quchen: Well, I don't wanna copy-paste almost identical documentation in each module
06:33:10 <quchen> merijn: Make a dummy function with the docs in some module, and reexport it from all others? :D
06:33:39 <hseg> Still doesn't make sense. If, e.g. m ~ [], we get that mzero = [], mplus = (++). Thus, many_v's implementation creates an infinite sequence of terms to the left of (++), which prevents us from evaluating any part of that list.
06:35:08 <hseg> Oh, wait.
06:38:36 <jtanguy> merijn: you could use some CPP preprocessing to import the documentation chunk
06:39:23 <jtanguy> there are several open tickets on the haddock trac for reusing named chunks of haddock doc across modules
06:44:32 <hseg> BTW, even Parsec doesn't use Alternative's many and some. It has different semantics for them and therefore implements them on its own.
06:45:41 <Sculptor> yo
06:45:50 <quchen> hseg: Parsec also doesn't use Alternative's <|>. It instead redefines it with a different fixity. :C
06:47:36 <applicative> I think they predate the Alternative class
06:48:11 <hseg> Thus, we can safely discard this piece of evidence and return to the question at hand: Apart from when v=empty, assuming <|> is at least partially strict in its first argument, is it possible for many v to evaluate to something other than bottom?
06:48:39 <hseg> If not, isn't it worth it to change the definition of many_v to many_v = pure [] <|> some_v ?
06:49:50 <merijn> Is there a way to silence redundant import warnings?
06:49:51 <supki> hseg: huh?
06:50:10 <merijn> i.e., when I'm importing something to get the Haddock hyperlinking working
06:50:11 <supki> hseg: Control.Applicative.many works with parsec just fine
06:50:46 <hseg> supki: The many used with Parsec is Text.Parsec.Prim.many, not Control.Applicative.many
06:50:59 <supki> you can try it yourself in ghci
06:52:43 <lacop> hey guys
06:53:07 <lacop> I'm having trouble reading a very long line, stack space overflow no matter what I try
06:53:58 <lacop> https://gist.github.com/lacop/6961283e05c1f5ac1adf
06:54:11 <lacop> ignore the l1 input, the second line is the problem
06:54:46 <merijn> lacop: getContents doesn't finish until it reads end of file
06:54:52 <lacop> it is a space separated list of up to 1mil integers, all I really need is to go over it once with foldl, but even getting a max overflows
06:55:05 <lacop> merijn: it's a two line input file
06:55:13 <supki> lacop: are you sure problem is with reading?
06:55:14 <hpaste> hseg pasted “many test code” at http://paste.tryhaskell.org/3280032606598463488
06:55:19 <lacop> just two numbers on first line (not important), then many many numbers on second
06:55:23 <supki> I would guess maximum stack overflows
06:55:26 <hseg> Don't have ghci on hand. Are you claiming that the following code works?
06:55:26 <namoamitabuddha> With haskellmode installed, how can I enable auto indentation in vim?
06:55:42 <merijn> lacop: 1 million integers in String form is going to be horribly inefficient
06:56:03 <lacop> merijn: well that's the point, how can I read chunks from line/
06:56:12 <merijn> lacop: oh, that's easy
06:56:15 <lacop> All I can find is getLine and getContents
06:56:39 <lacop> I want somehow to read one space-separated chunk, then 'read' that into Int and feed that to foldl
06:57:06 <ocharles> dependent type haskell gurus! Can https://gist.github.com/ocharles/dc1e1bb17b31ae3b5b49 be made to work?
06:57:08 <lacop> that should go through only once, lazy eval and such, never actually holding 1mil integers in memory only the foldl result
06:57:30 <merijn> lacop: ah, there's no String based default for getting partial data
06:57:30 <ocharles> I've just added a comment to that diff with my type error
06:57:31 <lacop> merijn: how? :) I've been struggling with this for quite some time
06:57:41 <supki> hseg: yes (modulo type errors)
06:57:42 <merijn> lacop: You want something like hGetSome
06:57:43 <ocharles> It's those bloody existentials again, but I can't see how to do this without existentials...
06:57:49 <lacop> damn... well I though so, I've been searching for a long time
06:57:50 <namoamitabuddha> For example,
06:57:52 <merijn> lacop: Which reads a fixed number of bytes from a file
06:58:00 <namoamitabuddha> when I type "=" and a newline
06:58:06 <merijn> lacop: Then you just need to convert the ByteString to Text/String before working on it
06:58:08 <namoamitabuddha> it doesn't indent automatically
06:58:24 <hseg> Odd. Very, very odd. Then my reasoning regarding http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#line-147 is wrong and I have no idea how to fix it.
06:58:25 <lacop> hmm, I've tried that, someone suggested it like two days ago when I was here
06:58:40 <ocharles> I'm trying to model a graph with a finite amount of vertices and edges, and I want to be able to say 'if this edge changes - all of these edges must be followed'
06:58:40 <merijn> namoamitabuddha: You disable haskell-mode and install my vim indenter :)
06:58:53 <ocharles> all of these paths*
06:59:00 <ocharles> where these paths can be of varying length
06:59:02 <lacop> what I think I need is read it char by char, parsing the integers myself
06:59:15 <lacop> if there is no function to get int from input stream
06:59:21 <lacop> but that just seems silly
06:59:27 <merijn> lacop: No, don't do that, read in large ByteString/Text chunks, then read Int's from that
06:59:50 <ocharles> the problem is 'propagateOut', which I was hoping to repeatedly apply to 'propagatedEdges' with fix
07:00:06 <merijn> it Seems odd that there's no hGetString :: Handle -> Int -> IO String, though
07:00:10 <mr-> merijn: but but haskellmode has _t !
07:00:16 <merijn> mr-: Which does?
07:00:18 <lacop> Data.Text package is not available to me, I'll have a look at ByteString chunks
07:00:32 <mr-> merijn: shows you the type of what is under the cursor
07:00:32 <merijn> lacop: Why is it not available?
07:00:41 <merijn> mr-: Oh, I use hdevtools for that
07:00:47 <namoamitabuddha> merijn: Is haskell-mode very notorious?
07:00:50 <merijn> mr-: Which is, what haskell-mode uses too, I think
07:01:05 <merijn> namoamitabuddha: I thought it included too much junk I didn't use and was too hard to configure
07:01:15 <lacop> I'm learning haskell by solving some coding competition tasks, it's a test server where you upload your source
07:01:22 <mr-> merijn: does your indenter do coloring too?
07:01:31 <mr-> (and where is it? ;-)
07:01:32 <supki> lacop: if you just read integers and print them, does it stack overflows?
07:01:35 <lacop> No control over installed modules, and Data.Text is not there, it was suggested last time and didn't work
07:01:43 <merijn> namoamitabuddha: So in the end I ended up using syntastic + hdevtools for highlighting type errors/querying type information and then, when I got fed up with the sucky indentation I wrote my own indentation
07:01:55 <merijn> mr-: I just use the default syntax colouring that vim uses for haskell
07:02:03 <lacop> supki: let me try..
07:02:14 <merijn> mr-, namoamitabuddha: AS for location: https://github.com/merijn/haskellFoldIndent
07:02:30 <merijn> mr-: (As the name implies, I intend to implement folding at some point too)
07:03:14 <DanielDiaz> simple question: I have profiling and documentation enabled by default in the cabal config file, what are the flags to disable them in a particular use of cabal?
07:03:32 <mr-> merijn: thanks, I'll try that (another couple of days fiddling with my vimrc.. ;-)
07:03:49 <dcoutts> DanielDiaz: see cabal install --help, all those things have --enable-* and --disable- variants
07:04:00 <merijn> mr-: I happen to have a dotfiles repo with a decently commented vimrc which includes the config for hdevtools and syntastic too! ;)
07:04:23 <DanielDiaz> dcoutts: OK, thanks.
07:04:33 <mr-> Oh no! Make that a couple of weeks ;-P
07:06:47 <lacop> supki: no, it's pretty slow but that just might be IO output
07:06:50 <lacop> but doesn't crash
07:06:54 <lacop> (a:_) <- L.lines `fmap` L.getContents
07:06:57 <lacop> mapM_ putStrLn $ map (show . int) $ L.words a
07:07:12 <lacop> however, let mx = maximum . map int $ L.words a and then printing mx does crash
07:07:29 <lacop> I mean, shouldn't it just need space for single integer?
07:07:50 <opqdonut> maximum is lazy
07:07:52 <lacop> maximum should keep current max, iterating over the mapped list, which would always parse and construct in memory only a single integer
07:07:55 <supki> lacop: the problem is maximum is too lazy
07:08:04 <lacop> huh?
07:08:12 <mauke> @src maximum
07:08:13 <lambdabot> maximum [] = undefined
07:08:13 <lambdabot> maximum xs = foldl1 max xs
07:08:22 <mauke> foldl1'?
07:08:38 <supki> lacop: it builds a giant thunk which only get forced when you try to print it
07:08:59 <supki> yes, foldl1' would be ok
07:09:08 <lacop> hm, and so foldl is the same way then
07:09:14 <lacop> but foldl' would work?
07:09:26 <supki> also there is strictMaximum in Data.List but isn't exported for whatever reason
07:11:45 <hseg> Oh, now I get it. [16:47] <hseg> ... assuming <|> is at least partially strict in its first argument, ... The definition of <|> for ParsecT is non-strict in both arguments.
07:12:42 <lacop> well I got this working
07:12:49 <lacop> let ai = map int $ L.words a,        let mx = foldl' (\m e -> max e m) 0 ai,        print mx
07:13:04 <hseg> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/src/Text-Parsec-Prim.html#parserPlus
07:13:12 <banister> lacop: ai == artificial intelligence?
07:13:17 <hseg> Thanks guys!
07:13:56 <lacop> array integers? dunno, it's sloppy because I'm trying everything to get it work right now :) the lambda is useless in the foldl
07:14:40 <lacop> but this still overflows: let (sm, mx) = foldl' (\(s,m) e -> (s + (min (k-1) e), max e m)) (0, 0) ai
07:14:50 <daniel-s_> hi
07:14:57 <Hafydd> Starting with a max of 0 could give a wrong result if you have negative integers.
07:14:59 <lacop> I mean, instead of one integer I'm now folding with two, what's the big difference?
07:15:09 <lacop> Hafydd: I know, not a problem in this case
07:15:11 <daniel-s_> Is there a way using ghci to continue a line when you press enter?
07:15:26 <Botje> use :{ and :} for multiline stuff
07:15:31 <lacop> supki: any idea why foldl' doesn't help here? ^
07:15:58 <mauke> lacop: because your tuple is lazy in its elements again
07:16:21 <lacop> yeah I'm just looking at foldl' and it's using seq on the accumulated data
07:17:12 <lacop> mauke: is there some way to make seq work for a tuple?
07:17:14 <mcstar> there is :set +m also
07:17:30 <mcstar> why is handier than the brace style
07:18:03 <mcstar> which* sry
07:18:12 <acube> lacop: There is deepseq, which uses instances to force all parts of an expression
07:18:21 <acube> @hackage deepseq
07:18:21 <lambdabot> http://hackage.haskell.org/package/deepseq
07:19:34 <supki> lacop: no, you can use seq for its contents manually though: \(s, m) e -> s `seq` m `seq` (s + (min (k-1) e), max e m)
07:19:42 <supki> lacop: or use bangpatterns
07:19:49 <supki> (they are equivalent)
07:20:31 <supki> lacop: i.e. \(!s, !m) e -> (s + (min (k -1) e), max e m)
07:20:49 <supki> lacop: you'll need -XBangPatterns for those
07:20:50 <lacop> supki: tried that, says invalid bangpattern
07:20:58 <lacop> but the manual seq in lambda works, thanks!
07:21:13 <supki> lacop: yes, they're language extension
07:21:17 <lacop> you guys are great, i think this should do it
07:21:39 <lacop> and I need to go read up on theory behind this because the solution is pretty hacky :)
07:23:41 <hpaste> vlatkoB pasted “Can this be written without lambda  function?” at http://paste.tryhaskell.org/90667
07:23:53 <vlatkoB> Can this be written without lambda  function?
07:24:34 <osfameron> verything can be written without lambdas
07:24:47 <supki> @ty map (fst &&& words . snd)
07:24:47 <lambdabot> [(a, String)] -> [(a, [String])]
07:25:12 <supki> wwait
07:25:28 <supki> @ty map (second words)
07:25:29 <lambdabot> [(d, String)] -> [(d, [String])]
07:25:46 <supki> vlatkoB: ^
07:25:48 <ocharles> :t second
07:25:49 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
07:25:56 <ocharles> :t second words
07:25:56 <lambdabot> (d, String) -> (d, [String])
07:26:47 <vlatkoB> Those are arrows?
07:26:54 <ocharles> -> is an arrow
07:27:13 <ocharles> so you can think of second :: (a -> b) -> (d, b) -> (d, c)
07:27:27 <ocharles> and second words :: (d, String) -> (d, [String])
07:28:01 <vlatkoB> Thanks.
07:29:33 <lacop> supki: wohoo, tester says OK, and it's actually a bit faster than my previous cpp solution :) thanks again
07:30:25 <supki> :)
07:32:51 <mr-> merijn: have you seen this error from hdevtools before? phase `C pre-processor' failed (exitcode = 1) error: missing binary operator before token "("
07:33:32 <acube> mr-: I know that error
07:33:41 <acube> mr-: Do you use any cabal-defined macros?
07:33:45 <merijn> Oh poop
07:33:56 <acube> (Like MIN_VERSION_something)
07:34:03 <merijn> I can't have an empty (i.e. zero functions/datatypes) section in haddock?
07:34:27 <mr-> acube: yes
07:35:22 <quchen> merijn: I think you can, Pipes does it for example: http://hackage.haskell.org/packages/archive/pipes/3.3.0/doc/html/Control-Proxy-Tutorial.html
07:35:39 <ocharles> merijn: sure you can
07:35:40 <mr-> acube: I am working on cabal itself, so I would rather not just remove it
07:35:47 <merijn> oh
07:35:57 <merijn> Looks like I need to leave an empty line in the export list
07:36:16 <ocharles> yea, I think that got me
07:36:34 <merijn> The day has been saved!
07:36:41 <mr-> acube: do you know of a fix? ;-)
07:37:03 <dcoutts> mr-: you'll get that error if you use ghc/ghci directly without using -optP-include -optPdist/build/autogen/cabal_macros.h
07:37:05 <chrisdone> :t fix
07:37:06 <lambdabot> (a -> a) -> a
07:37:57 <fryguybob> ocharles: I don't know if you saw my "yes" answer to your question.  I'm working on using TSX with GHC's STM.
07:38:17 <ocharles> fryguybob: ah, I didn't. cool! what have you done so far?L
07:38:19 <acube> mr-: You need to get hdevtools to add -optP-include -optPdist/build/autogen/cabal_macros.h to the ghc options
07:38:29 <acube> mr-: you can do that with the -g parameter of hdevtools
07:38:50 <mr-> dcoutts, acube: great, thanks!
07:39:12 <fryguybob> ocharles: I have a plan for it all and I've worked with TSX, but at this point, I'm still waiting for hardware.
07:39:46 <fryguybob> Then I will need to get the right kernel running so I can profile hardware transactions.
07:40:20 <ocharles> fryguybob: cool. I'm hoping to get hardware with TSX in the future too, and STM seemed like an obvious place where it might be useful
07:40:38 <ocharles> i don't know how all this really low level stuff works though, but having it in a domain I'm remotely familiar with makes it more interesting
07:40:56 <banister> if i wanted to say write a simple plot of a mandlebrot fractal in haskell (just to learn the language) which graphics lib should i look at?
07:41:58 <dcoutts> fryguybob: oh interesting. I had a good chat with an Intel chap about that last year.
07:42:08 <dcoutts> fryguybob: what strategy are you thinking of taking?
07:42:28 <luite> banister: you you need a gui? perhaps juicypixels if you can just generate an image
07:42:43 <banister> luite: generating an image is fine
07:42:54 <banister> luite: thx
07:43:13 <luite> banister: not much of a drawing api, but if you can generate a pixel array somehow, juicypixels gives you an image file :)
07:43:51 <banister> luite: ah so it doesnt have things like getPixel or setPixel ?
07:44:56 <fryguybob> dcoutts: As a first pass, using the coarse grain lock with HLE.  After that using the coarse grain version (with HLE) as the fall back to running atomic regions in hardware transactions.
07:45:49 <dcoutts> fryguybob: you mean a lock in the validation/commit of the stm logs?
07:45:56 <fryguybob> dcoutts: There are several things to try with this, but left branches of an  orElse  need STM (inside the hardware transaction) and a read set has to be tracked.
07:46:19 <luite> banister: it has readPixel / writePixel for STVectors
07:46:28 <fryguybob> dcoutts: Yeah, the coarse grain lock protects validation and commit.
07:46:32 <dcoutts> fryguybob: are you just thinking of doing this in the rts C code, or also considering generating different code?
07:46:47 <applicative> banister:             readPixel :: PrimMonad m => MutableImage (PrimState m) a -> Int -> Int -> m a
07:46:51 <applicative>             writePixel :: PrimMonad m => MutableImage (PrimState m) a -> Int -> Int -> a -> m ()
07:46:52 <fryguybob> dcoutts: At this point just in the rts.
07:46:54 <applicative> that was a bit long
07:47:47 <dcoutts> fryguybob: ok, keeps things simpler. So not trying to translate small stm code sequences into hardware transactions directly. "Just" making the STM "interpreter" in the RTS use these features to go faster.
07:47:51 <luite> fryguybob: does the hardware help tracking retried transactions that can be restarted after some commit?
07:48:21 <thoughtpolice> fryguybob: well, HLE should be transparent, right? pthreads automatically does lock elision if it's supported
07:48:29 <dcoutts> fryguybob: so that's also the approach that this Intel chap advocated, to use it to speed up the stm log validate/commit
07:48:38 <fryguybob> dcoutts: Right, that should point to the cases that don't work out well.  I might do something to refactor trees of  orElse  so they only have one left branch.
07:48:46 <watermind> the opposite of primitive type is structured type, right?
07:48:47 <banister> applicative: luite thx
07:49:07 <fryguybob> thoughtpolice: The STM locks are spin locks not pthread locks.
07:50:10 <thoughtpolice> fryguybob: oh, i see. perhaps i should read your STM commentary (it seems like a good, detailed read btw) :)
07:50:16 <mr-> dcoutts: do you also know of a fix for "Could not find module `Paths_cabal_install'" ? (sorry for being daft..)
07:50:17 <fryguybob> :D
07:50:28 <dcoutts> mr-: -i dist/build/autogen
07:50:32 <dcoutts> erm, no space
07:50:37 <dcoutts> -idist/build/autogen
07:53:34 <mr-> Great, thanks. (forgot the *s in my find..)
07:55:30 <bss03> Any way I convince the latest haskell platform to give me C code I can put other our decrepet build system?
07:55:36 <geekosaur> ?
07:56:10 <mr-> merijn: hdevtools is much better than haskellmode! Thanks :-)
07:56:17 <bss03> I'm wanting to experiment with Haskell on OS4690.
07:56:23 <chrisdone> bss03: has anyone really been far even as decided to use even go want to do look more like?
07:56:49 <geekosaur> ghc hasn't compiled to C in some time, and I think the porting mode is currently broken'
07:56:50 <bss03> I have a process for producing OS4690 binaries, but it involves using a particular C/C++ compiler.
07:58:32 <bss03> Any other Haskell compiler that can give me C-ish code?
07:58:48 <mauke> how dead is jhc?
07:59:01 <geekosaur> the ajhc fork seems to be fairly active
07:59:01 <chrisdone> mauke: i got it to build, it works for me
07:59:08 <luite> ajhc is alive, and merged back into jhc upstream
07:59:14 <luite> from time to time
08:00:00 <wallmani> hi friends
08:00:22 <bss03> Yeah, looks  like jhc has some changes in it's repository in March of this year.
08:00:24 <geekosaur> but I don't know if you can take (a)jhc-generated C code from one architecture and build it on a different architecture
08:00:55 <thoughtpolice> as long as you have a C99 compiler, it Should Work
08:01:11 <thoughtpolice> (you may have to abandon the threading crap, but ajhc now lets you do this IIRC)
08:01:19 <bss03> I can find a 32-bit x86 machine to compile it on, and that's the (CPU) architecture it will run on.
08:01:38 <geekosaur> it doesn't bake word size or endian assumptions into the geneated code?
08:01:51 <bss03> Oh, no, this compiler had it's last update before C99 was released.
08:02:11 <thoughtpolice> nope, people have run JHC on all kinds of stuff. there was one guy running it on the Wii, some people doing small ARM boards (teensey i think)
08:05:23 <thoughtpolice> bss03: yeah, it uses features in the RTS and generated code like struct initializers, etc. if you can't support that, you may just be SOL :(
08:05:44 <bss03> Does it make a lot of use of C99?  'Cause this compiler is older than my career, so it doesn't have things like uint8_t, although I might be able to fake it.
08:05:44 <elliott> I bet there's some sort of horrific C99->C89 mangler somewhere.
08:05:57 <elliott> bss03: btw, my condolences.
08:05:58 <CaptainK> In  a do block,  if k == 0 then k=1 else k=2,  do I have to use let?
08:06:11 <mauke> CaptainK: you can't modify variables
08:06:13 <thoughtpolice> elliott: i think someone wrote one using Clang, but for Visual Studio's C compiler as the target, yeah
08:07:53 <bss03> Captaink: let k' = if k == 0 then 1 else 2 in do {- ... -}?
08:08:18 <mux> you can usually find types of the form u_intN_t on many OSes that long predate C99
08:08:23 <CaptainK> ah thats why,
08:09:08 <CaptainK> so the branch collapses and sets k' or whatever I want to call k'
08:09:09 <merijn> Can I make text bold in haddock?
08:09:14 <bss03> mux: Yeah, I can fake all the types required by C99, I think.  I can't fake struct initializers... I don't think.
08:09:17 <merijn> I only see a way to do emphasis (italic)
08:09:53 <mux> bss03: those sound like more involved indeed, though if you're lucky and using GCC there might just be a corresponding extension that you could use
08:10:28 <bss03> mux: No, the compiler is from IBM's old "Visual Age" line.
08:10:34 <thoughtpolice> bss03: i mean, you could maybe hack ajhc into shape to generate appropriate code, but i don't think you're going to find anything really easy at this rate. is a C cross compiler (like GCC) or something impossible?
08:11:08 <mux> bss03: ouch, good luck man.
08:11:26 <bss03> "In the future" (tm), we will be moving to a clang-based solution.  Right now, though it doesn't seem possible.
08:12:41 <mux> bss03: what would me most painful is if you have to deal with lots of VLA usage in your codebase I guess
08:12:57 <merijn> Anyone? Haddock bold text?
08:13:05 <mux> you should be able to rewrite those using alloca() but that will be a manual process
08:13:08 <ocharles> merijn: I don't think it can do that
08:13:09 <thoughtpolice> merijn: i don't believe there is, no
08:13:21 <elliott> the manual has a complete description of the markup IIRC
08:13:39 <karl> hello
08:13:41 <merijn> elliott: Yeah, I was just hoping I was wrong
08:13:45 <merijn> So sad :(
08:13:54 <merijn> How will I draw attention now :(
08:14:03 <applicative> bold text; is it really necessary?
08:14:27 <mauke> merijn: use the power of unicode
08:14:51 <mauke> merijn: http://mauke.hopto.org/stuff/javascript/unicode.html?q=bold
08:15:00 <merijn> applicative: Yeah, I wanted to have a bold "TL;DR: Don't use this module if <condition>" in my docs
08:15:11 <Guest39424> i there a portable (non-installation) ghc version? for windows there is the portable option, but for linux? and: is there a slim-version of ghc (only few mb)?
08:15:24 <Guest39424> i = is
08:15:46 <applicative> hm, why not System.Merijn.Unsafe
08:16:45 <merijn> applicative: It's not unsafe
08:17:02 <merijn> applicative: It just uneccessarily restricts the generality of your code in some cases
08:17:08 <thoughtpolice> Guest39424: you can use a binary distribution (not from your distro) and install it to some location (like portable media) and that'll be fine.
08:17:20 <thoughtpolice> Guest39424: also, no, there is no 'slim' ghc build
08:17:36 <sm> happy july 4th, citizens. Check out http://www.restorethefourth.net/ if you're in the US
08:18:07 <chrisdone> merijn: you could use haskell-src-exts for your vimdentation
08:18:44 <merijn> chrisdone: Yes, because what I need is more yak shaving and less haskell coding!
08:19:02 <jmcarthur> sm: regardless of my feelings on the matter, i must point out that politicial links probably don't belong here
08:19:36 <Guest39424> ok thanks thoughtpolice. is there another haskell-compiler, which is smaller in size?
08:20:07 <applicative> there is the hugs interpreter Guest39424
08:20:17 <applicative> it is not maintained, but I think you can build it
08:20:25 <chrisdone> merijn: regexes are a field of yaks that breed =)
08:20:33 <yitz> is jhc smaller than ghc?
08:20:45 <chrisdone> yitz: yeah it's small
08:21:16 <applicative> i was wondering about jhc, but it's kind of hard to use in any case
08:21:31 <merijn> chrisdone: Sure, but vim can only make line-by-line indent decisions, so I'd have to implement a way to figure out when to rescan the entire file with -haskell-src-exts, etc
08:21:39 <elliott> you can probably make GHC fairly small.
08:21:48 <Guest39424> applicative what do you mean with "hard to use"?
08:21:49 <elliott> if you build with dynamic libraries and no profiling and -Os and stuff.
08:22:10 <elliott> USB sticks are pretty big these days though so I'm not sure why you'd bother
08:22:12 <chrisdone> merijn: i just scan the current declaration
08:22:42 <applicative> Guest39424: it is an unfinished work, basically using it and proposing to develop it are the same
08:22:44 <mux> merijn: it must have a way to do contextual stuff as well, otherwise some of the indent functionality for comments wouldn't work
08:22:54 <applicative> hm, homebrew has hugs
08:23:17 <merijn> mux: I think it just uses a schlemiel the painter algorithm
08:23:22 <mauke> applicative++  # alliterative
08:23:57 <elliott> alliterative applicative
08:24:09 <yitz> mauke++ meta-alliterative
08:24:20 <elliott> bss03: hm, did you consider hugs?
08:24:45 <Guest39424> applicative, so you would suggest hugs, even if it isn't maintained anymore?
08:24:47 <elliott> yitz: thankfully no relevant words start with "y".
08:24:51 <yitz> :)
08:25:42 <yitz> elliott: if my nick began with f there might have been some way to work in fix there
08:26:07 <applicative> Guest39424: you could try it, you will only have the standard base libraries, and various curiosities will arise.  codepad.org uses it
08:26:30 <applicative> Guest39424: but what are you trying to do?
08:26:31 <mauke> y-combinator
08:26:36 <chrisdone> hugs has a nice simple codebase
08:26:44 <yitz> ah there you go
08:26:52 <chrisdone> for some values of simple and nice, after ghc
08:27:33 <Guest39424> applicative, i work as a teacher in an institution, where the accounts are not able to install anything
08:27:53 <Guest39424> but i want to show my students (they actually learn java) a bit of haskell, and the nice things one can do
08:28:01 <applicative> Guest39424: yes, I think hugs is still used by some universities even, for this reason
08:28:22 <applicative> that the students can install it
08:28:40 <applicative> installing ghc is easier than it used to be.
08:29:55 <elliott> I think universities still use hugs so we can go "omg, another poor soul" whenever their students paste an error here.
08:30:09 <Guest39424> applicative, yes, but they only have limited hd space
08:30:19 <Guest39424> therefore i asked for a smaller ghc-verion
08:30:22 <Guest39424> version
08:30:38 <chrisdone> there's also uhc, as an option
08:30:53 <mcstar> cant you install ghc centrally?
08:31:15 <Guest39424> mcstar, no, i am no admin there
08:31:22 <mcstar> talk to the admin then
08:31:31 <mcstar> thats the sensible solution, afaics
08:31:55 <mcstar> they are there for the good of the students, not to ignore requests
08:32:05 <Guest39424> mcstar, i asked... till now no answer
08:32:15 <Guest39424> lazy admins... :-/
08:32:26 <mcstar> too bad
08:32:33 <bss03> elliott: No, I tried the -C flag in GHC and when that failed miserably, I asked here.
08:32:59 <Guest39424> so i am going with hugs, thank you guys, especially applicative ;-)
08:33:20 <mcstar> stupid solution, but you could install it into /tmp maybe
08:33:42 <elliott> bss03: it might be worth considering if you don't have performance requirements and don't really need very modern libraries are such
08:33:49 <elliott> simple C interperter, should work on just about everything
08:34:06 <Guest39424> mcstar, but then i had to install it every time we reboot the system
08:34:25 <mcstar> yeah, but i'd imagine those servers have months of uptime
08:34:50 <applicative> Guest39424: just be sure to inform them there is a real compiler making it at least as efficient as java
08:35:18 <mcstar> applicative: by 'it' you mean?
08:35:36 <Guest39424> ha ha, in their opinion, java is the future, and haskell... "what is haskell"
08:36:24 <bss03> elliott: Well, performance is going to be an issue in the future, but for a PoC anything will work.
08:37:33 <applicative> mcstar: oh by 'it' I meant Haskell; one might get a wrong impression from Hugs
08:37:44 <applicative> http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&data=u64q
08:37:45 <mcstar> oh
08:37:45 <Guest39424> applicative ;-)
08:37:54 <applicative> Guest39424: ^^^
08:38:15 <Guest39424> okay then, thank you guys, have a nice day
08:38:34 <applicative> the java ones have been improving.  fannkuch-redux is dragging haskell down a bit
08:38:54 <mcstar> i wrote myself a fannkuch some time ago from scratch :)
08:41:09 <monochrom> I'm reading HWN. did kmc really joined? and just to say that johnw is wrong? :)
08:41:22 <applicative> i was wondering about that
08:41:43 <mcstar> the tendency is to use simd operations in c/c++ code in the shootout problems, how can ghc cope with that?
08:41:52 <applicative> > 1
08:41:52 <lambdabot>   1
08:41:54 <elliott> he was in here for about a week
08:41:57 <ocharles> chrisdone: how are you finding your Truly Ergonomic btw?
08:43:00 <jmcarthur> mcstar: eventually, with simd
08:43:09 <mcstar> hey jmcarthur
08:43:13 <monochrom> ha, found it, on June 27
08:43:31 <jmcarthur> mcstar: hey!
08:43:57 <applicative> hah, PHP is next after C for pidigits
08:44:59 <applicative> php has functions that use gmp explicitly       $u = gmp_mul($d, gmp_mul(-10, $u));
08:45:55 <applicative> i wonder what indirection makes ghc slower.  hm
08:46:11 <Rarrikins> mcstar: There has been work done on adding SIMD optimizations to GHC: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
08:46:41 <mcstar> ty
08:47:16 <mcstar> the differences are quite small on pidigits, and php is hardly next after C
08:47:38 <mcstar> im looking at 64bit single core
08:47:47 <luite> do they all use gmp or something?
08:47:56 <mcstar> probably
08:48:32 <applicative> mcstar: well okay fortran and something; in fact its twice as fast as ghc, barely slower than c, this php
08:48:56 <acube> Does GHC have an option called -package-conf? If yes, what does it do?
08:49:05 <Kinnison> johnw: am I meant to be able to use gitlib from ghci?
08:49:06 <applicative> luite: yes, the c program has comments suggesting close knowledge of gmp peculiarities
08:49:30 <applicative> acube: it tells ghc which package-conf to look at for libraries
08:49:34 <Kinnison> johnw: http://pastebin.com/rsGZnF3z :-(
08:49:36 <mauke> The paste rsGZnF3z has been copied to http://paste.tryhaskell.org/90670
08:49:49 <mcstar> applicative: look at lua, it is all over the place, that program has been optimized to reach that point, probably the haskell version could use some more optimization
08:49:51 <acube> applicative: is package-conf a synonym for package-db`
08:49:53 <acube> ?
08:50:16 <applicative> isnt that the file
08:50:17 <applicative> hm
08:50:39 <acube> There is a -package-db option
08:50:53 <supki> acube: I think the former is deprecated
08:51:00 <luite> acube: yeah it was renamed
08:51:19 <acube> Does -package-conf exist in GHC 7.4.2?
08:51:27 <acube> Ehm, I mean -package-db
08:52:07 <applicative> acube: here is what I put at the end of calls to ghc in my sandbox  -package-db .cabal-sandbox/x86_64-osx-ghc-7.6.2-packages.conf.d/
08:52:10 <geekosaur> Kinnison, that's a threading issue of some kind (_tls_init). possibly gitlib doesn't work with threaded runtime (ghci is always threaded, ghc only if you build with -threaded), possibly it doesn't like the sandbox (ghci -fno-ghci-sandbox)
08:52:44 <acube> applicative: I know that my it works with GHC 7.6, I just get a weird error when using the ghc library for GHC 7.4
08:53:07 <acube> (Like "cannot satisfy -package -db" when using -package-db in parseDynamicFlags)
08:53:28 <applicative> hm, there was another flag then>
08:53:29 <applicative> ?
08:53:31 <monochrom> the old name was -package-conf
08:53:50 <veryrandomname> question regarding attoparsec/parsec: is it possible to parse the intermediate result of a parser, without using the 'parse' function?
08:54:00 <Kinnison> geekosaur: Hmm, ta.  Makes exploring gitlib by hand a bit of a pain
08:54:34 <applicative> map (parse myparser) (inits mystring) ;)
08:55:10 <lasticot> merijn: hi, I'm working on the problem you gave me yesterday about the state monad I managed to implement return, but when it came to implementing (>>=) I got stucked.
08:55:53 <lasticot> I looked the solution and I really don't understand what the function runMyState is doing
08:56:17 <lasticot> merijn: I looked the solution and I really don't understand what the function runMyState is doing
08:57:21 <merijn> lasticot: it is simply unwrapping the constructor, an identical definition would be "runMyState (MyState x) = x"
08:58:11 <merijn> where x is a function of type "s -> (a,s)"
08:58:56 <lasticot> merijn: ok let think about that a little
08:59:11 <veryrandomname> applicative: did you answer me? I rather wanted to use two parsers, where the second parser parses the output of the first
09:00:47 <merijn> lasticot: Remember that because of currying "runMyState foo s" (let's say foo = MyState f) -> "runMyState (MyState f) s" -> "(runMyState (MyState f)) s" -> "f s"
09:02:04 <merijn> ok, time to go home
09:03:31 <Kinnison> geekosaur: Even building without threading doesn't seem to help :-(
09:04:24 <dwcook> veryrandomname, you mean like parserA >>= parserB ?
09:04:39 <magneticduck> question: in what kind of situation would one get an error like this:
09:04:42 <magneticduck>     Couldn't match expected type `ET.PathMovement a0'
09:04:42 <dwcook> Er woop
09:04:44 <magneticduck>                 with actual type `ET.PathLocation Double'
09:05:07 <dwcook> Something employing (>>=) is my point anyhow
09:05:11 <dwcook> or do notation
09:05:15 <dwcook> same deal
09:06:09 <geekosaur> magneticduck, you would get that f you specified a PathLocation Double but the thing you passed it to wanted a PathMovement a0 for some a0
09:06:39 <magneticduck> the function I passed it to has a type of (RealFloat a) => (PathMovement a) -> ...
09:06:56 <magneticduck> if I can't pass a PathMovement Double...
09:06:59 <magneticduck> wth!
09:07:25 <veryrandomname> dwcook: not really, as I understand it, in parserA >>= parserB, parserA will parse the input and parserB will continue to parse the same input as parserA(without what parserA already parsed)
09:08:06 <dwcook> veryrandomname, oh, I think I understand you now. Yeah, you're right.
09:08:23 <geekosaur> magneticduck, but it thinks you passed it a PathLocation, not a PathMovement
09:08:47 <magneticduck> rofl missed that. I can be so stupid...
09:08:48 <veryrandomname> dwcook: the only way I see to do it would be parserA >>= (\result -> parse parserB result)
09:08:57 <dwcook> veryrandomname, yeah, that's what I was going to suggest.
09:09:01 <magneticduck> I was getting some pretty tricky type problems though and I though this was another tricky one
09:09:47 <veryrandomname> dwcook: I just thought that there would be a better way or something, but it does make sense this way I guess.
09:12:06 <veryrandomname> dwcook: whats faster/better? making one parser or chaining them like parserA >>= (\result -> parse parserB result) ?
09:13:34 <dwcook> veryrandomname, I mean, that *is* one parser, it's just built up from others
09:14:03 <dwcook> I know hardly anything about the performance of things in Haskell
09:14:10 <veryrandomname> dwcook: right, but its not one process of parsing :/
09:14:17 <dwcook> But I can answer better: Whatever is clearest
09:14:30 <veryrandomname> dwcook: I think so too
09:15:12 <dwcook> If you want, you can try refactoring it to do only one pass
09:15:15 <dwcook> Depends on what you're parsing
09:16:04 <veryrandomname> dwcook: I really can't tell whats more sensible, I'm parsing a http header. I guess I'll try both and look at the results
09:16:34 <dwcook> As far as I'm aware, HTTP headers don't need more than one pass. But it's probably not a big deal if you do that
09:16:54 <dwcook> Go with the thing that's obvious to you, then maybe think about it again later
09:44:59 <portnov> hi all
09:47:46 <AleXoundOS> portnov, hi
09:48:58 <portnov> Q: how to export data family instance constructors from module?
09:49:38 <portnov> i.e. I have
09:49:38 <portnov> data instance Some X = A | B | C
09:49:38 <portnov> and want to export A, B, C
09:56:24 <bscarlet> portnov: Is the family defined in the same module as the instance?
09:56:40 <portnov> bscarlet: no, it's defined in another module
09:57:12 <portnov> but, the problem is still here even if data family is defined in same module
09:58:14 <portnov> http://paste.in.ua/8442/
09:58:32 <bscarlet> portnov: Have you tried putting Some(A,B,C) in the export list?
09:58:55 <lasticot> merijn: I think I've understood most of it now, what should I do next?
09:58:58 <portnov> huh
09:59:09 <portnov> bscarlet: it compiles at least, thanks
10:01:51 <bscarlet> portnov: without type families involved, that's how you write constructors in an export list. You can also do Some(..) to mean all the constructors of Some. I find it a little odd that when families are mixed into the situation, the syntax doesn't change, but so it seems to be.
10:03:54 <portnov> bscarlet: it's not so obvious with data families. Think what if I have say data instance Some Y = U | V | W, it's another data type. Then exporting (Some (A, B, C, U, V, W)) will export constructors of different data types in one construction
10:04:26 <bscarlet> portnov: exactly. Hence "I find it a little odd".
10:04:57 <portnov> ok :)
10:17:11 <Luke1> I'm having an issue w/ haskell-mode and flymake. It isn't able to find my imports. it seems like it can't find the last import in the import list. anyone have experience with this?
10:26:00 <DiegoNolan> if i have a function that returns State StdGen a
10:26:06 <DiegoNolan> how do i get to this value a
10:26:59 <elliott> you need to feed an StdGen in
10:27:02 <elliott> look at runState, evalState
10:27:34 <DiegoNolan> both these require a StdGen
10:27:41 <DiegoNolan> i don't want to carry around a StdGen
10:27:47 <DiegoNolan> i thought that was the point of the state monad
10:28:04 <elliott> oh, you're operating within the monad still
10:28:07 <elliott> then you can do
10:28:10 <elliott> do { a <- myAction; ... }
10:28:18 <elliott> which will have the type State StdGen blah for some blah
10:28:22 <elliott> and a will be of type a
10:28:22 <DiegoNolan> but then my entire function is the State Monad
10:28:25 <elliott> yes
10:28:28 <elliott> of course
10:28:41 <DiegoNolan> but that is annoying
10:28:52 <elliott> that is the only way it can be
10:28:54 <DiegoNolan> i feel like fust being in the IO monad would be less of a headache
10:29:11 <elliott> huh? it would be more of a headache -- you need to do hacks to get global variables in IO, and you'd still be equally "trapped"
10:29:30 <DiegoNolan> all i want is a random number
10:29:40 <jmcarthur> elliott: not quite. you can just use the randomIO bunch of functions
10:29:49 <DiegoNolan> yeah
10:29:57 <elliott> oh, well for that special case, sure
10:30:02 <elliott> perhaps look at MonadRandom or such
10:30:06 <DiegoNolan> hmm
10:30:06 <elliott> @hackage MonadRandom
10:30:06 <lambdabot> http://hackage.haskell.org/package/MonadRandom
10:30:17 <jmcarthur> DiegoNolan: there are advantages to using a state monad or passing it around explicitly, but that doesn't mean you always have to do that
10:30:18 <elliott> it's basically just State StdGen with some helper definitions.
10:30:56 <DiegoNolan> hmm
10:31:14 <jmcarthur> note that IO is also an instance of MonadRandom
10:32:03 <jmcarthur> it lets you write generic code over any monad that supports that interface, whether it be IO, State StdGen, or something else
10:32:12 <DiegoNolan> that would make it safer because then i only know it is randomIO and nothing else
10:32:29 <jmcarthur> well, the State StdGen thing would need a newtype wrapper to implement the interface, but the principle still applies
10:32:34 <DiegoNolan> but then i still have to write it in that monad
10:32:43 <DiegoNolan> which i have to hink of binds and returns and all that
10:32:45 <jmcarthur> you only need to write it in some abstract monad
10:32:54 <jmcarthur> binds and returns are not a problem once you are used to them
10:33:00 <jmcarthur> Control.Monad is pretty rich
10:33:27 <DiegoNolan> i'm only trying to do procedural generation, so i think it may just be easier to do what i have been doing
10:33:32 <DiegoNolan> just passing in a gen
10:33:36 <DiegoNolan> and leaving the code not monadic
10:33:38 <jmcarthur> also, if you don't mind adding an extra Applicative constraint (or waiting until we finally make Applicative a superclass of Monad), you can also use stuff in Control.Applicative and Data.Traversable
10:33:47 <DiegoNolan> and just passing the StdGen arround
10:34:14 <jmcarthur> it depends on how much code you are writing
10:34:25 <jmcarthur> whether a whole monad is worth it
10:34:38 <DiegoNolan> it only becomes a pain
10:34:40 <jmcarthur> there is an up front cost, but when your code scales up it is a bit nicer
10:34:46 <DiegoNolan> when the recursion branches an n amount of times
10:34:50 <DiegoNolan> then i have to generate n StdGens
10:34:54 <DiegoNolan> which is a pain
10:34:54 <jmcarthur> huh?
10:35:00 <DiegoNolan> but i guess i should just make a funcito for that
10:35:12 <DiegoNolan> i have a recursive function that makes trees procedurally
10:35:16 <DiegoNolan> so when the tree branches
10:35:26 <DiegoNolan> i have to make new std gens for each branch
10:35:31 <jmcarthur> you have to split the StdGen, sure
10:35:36 <DiegoNolan> yeah
10:35:40 <elliott> that's what the monad keeps track of for you.
10:35:42 <DiegoNolan> which is the only annoying part
10:35:46 <Palmik_> Hi guys. Does anyone here know since when is INLINEABLE supported and what is the name of the macro for querying ghc version? (Something like MIN_VERSION_<packagename>(x, y, z) for packages)
10:35:57 <jmcarthur> elliott: the state monad would destroy the laziness, unfortunately, if that is important
10:36:09 <jmcarthur> elliott: i think there is some lazier MonadRandom out there, though
10:36:13 <DiegoNolan> no i think that would be fine
10:36:32 <DiegoNolan> it probably should be strict anyway because it can go really deep
10:36:47 <DiegoNolan> but i tihnk one probably is that it is difficlut to make it tail recursive
10:37:09 <jmcarthur> DiegoNolan: splitting the StdGen is actually a feature that is lacking in most PRNGs
10:37:23 <jmcarthur> DiegoNolan: so, it's interesting to me that this is seen as annoying at all :)
10:37:42 <jmcarthur> DiegoNolan: of course, if you want it to be strict anyway, you don't actually have to split at all
10:37:54 <jmcarthur> DiegoNolan: you can just pass the final state of the StdGen from one branch into the next branch
10:38:00 <jmcarthur> DiegoNolan: and the monad does that all for you
10:38:26 <DiegoNolan> hm
10:38:49 <DiegoNolan> the way i was donig in was just making a random list of ints with the current StdGen
10:39:02 <DiegoNolan> then mapping mkStdGen over the list
10:39:09 <jmcarthur> woah
10:39:14 <DiegoNolan> then passing each vaule onto the branches
10:39:17 <jmcarthur> that sounds really unwise to me
10:39:21 <DiegoNolan> yeah that's why it was annoynig
10:39:35 <jmcarthur> not even from a software engineering standpoint, but also from a randomness standpoint
10:39:36 <DiegoNolan> but how else would you get 2 or more stdGens from one
10:39:43 <jmcarthur> StdGen has a split function
10:40:23 <DiegoNolan> ahh it does
10:40:25 <DiegoNolan> never new that
10:40:27 <DiegoNolan> knew*
10:40:55 <jmcarthur> and it's going to give much higher quality randomness than map mkStdGen
10:41:00 <CaptainK> what is wrong with this? http://ideone.com/TkTR8f
10:41:19 <elliott> CaptainK: variables do not change
10:41:22 <jmcarthur> CaptainK: "let a = a + 1" is a recursive definition
10:41:27 <elliott> you could remove the first definition of a and it would behave the same
10:41:41 <jmcarthur> CaptainK: the 'a' on the right side is the 'a' on the left side
10:42:10 <jmcarthur> CaptainK: so it expands thusly:   a + 1  =>  (a + 1) + 1  =>  ((a + 1) + 1) + 1)  =>  and so on forever
10:42:31 <jmcarthur> CaptainK: if you want to base the new a on the old a, give them different names
10:42:38 <CaptainK> ok, thats my imperative programming coming to haunt me]
10:42:52 <jmcarthur> CaptainK: so it would be  let a = 1; ...; let b = a + 1; ...
10:43:03 <Luke1> How can I make haskell flymake for emacs look for modules in src? My .ghci has -isrc and I need the equivalent in flymake
10:43:27 <jmcarthur> Luke1: i don't know how to do it in the raw. haskell-mode and ghc-mod handle this all for me
10:43:45 <jmcarthur> Luke1: or is this not even in a cabal project?
10:43:53 <jmcarthur> Luke1: i'm speaking about projects that have cabal files
10:44:19 <Luke1> it's in a cabal project
10:44:36 * hackagebot data-store 0.3.0.6 - Type safe, in-memory dictionary with multidimensional keys.  http://hackage.haskell.org/package/data-store-0.3.0.6 (PetrPilar)
10:45:12 <Luke1> do you have ghc-mod installed?
10:45:26 <Luke1> i had ghc-mod like features without even having it installed somehow
10:45:54 <Luke1> when I run "# ghc-mod check <file>" on the command line it finds the packages just fine
10:46:46 <jmcarthur> if you have a ghc-mod command then you surely have ghc-mod installed...
10:47:49 <Luke1> well I installed it to check
10:47:57 <jmcarthur> ah
10:48:01 <Luke1> so I'm not sure what flymake was using to compile and get get error info...
10:48:08 <jmcarthur> in theory you should be able to just set up ghc-mod in emacs and be done with it
10:48:19 <jmcarthur> instead of dealing with flymake directly
10:49:07 <jmcarthur> i should also point out that there is also some new thing like ghc-mod that supposedly has some advantages, but i haven't tried it and don't remember its name
10:49:09 <Luke1> does flymake compile separately from ghc-mod?
10:49:16 <jmcarthur> ghc-mod uses flymake
10:49:18 <Luke1> i've been unable to get ghc-mod working at all in emacs
10:49:21 <Luke1> oh
10:49:44 <Luke1> i don't have the ghc-init function
10:50:19 <jmcarthur> Luke1: once you have your load-path set up correctly, you should be able to just use (autoload 'ghc-init "ghc" nil t) (add-hook 'haskell-mode-hook (lambda () (ghc-init) (flymake-mode)))
10:50:28 <CaptainK> How do you loop..err..recurse this to count http://ideone.com/KXZZ0B ?
10:50:33 <Luke1> what do I set my loadpath to though?
10:50:58 <Luke1> where did you get the .el front-end files for ghc-mod?
10:51:29 <jmcarthur> Luke1: the cabal package should put them under .cabal/share/ghc-mod-<version>/
10:51:48 <Luke1> I tried those before and they had errors. I'll try again
10:51:50 <jmcarthur> Luke1: but i think recent versions of haskell-mode will automatically look for ghc-mod
10:51:57 <Luke1> it doesn't
10:51:59 <Luke1> i have the latest
10:52:12 <jmcarthur> i don't have the load-path set to look for ghc-mod and i'm using it
10:52:33 <geekosaur> CaptainK, you're still being imperative there
10:52:33 <Luke1> hmm wtf
10:52:57 <CaptainK> lol, I know its so hard to kill that mode of thinking
10:53:23 <CaptainK> call it as a function then?
10:53:53 <Luke1> jmcarthur: that worked! Thanks!
10:54:02 <jmcarthur> Luke1: what worked?
10:54:05 <Luke1> jmcarthur: wtf was compiling my haskell before I had ghc-mod?
10:54:15 <jmcarthur> no idea
10:54:23 <Luke1> I tried the auto-load ghc-mod again with the latest haskell-mode and it found it
10:54:27 <jmcarthur> ah
10:54:38 <Luke1> i must not have tried with the latest version before
10:54:48 <Luke1> i'm really confused as to what was compiling my haskell before
10:55:04 <monochrom> haha, tooth fairies perhaps :)
10:56:26 <geekosaur> CaptainK, http://ideone.com/Zgmajg
10:56:39 <Luke1> jmcarthur: do you know what flymake-haskell-multi is?
10:56:42 <Luke1> i think that's what I was using before
10:57:45 <jmcarthur> no idea
10:58:33 <Luke1> do you use scion too?
10:58:39 <jmcarthur> nope
10:59:17 <Luke1> https://github.com/purcell/flymake-easy this is what I was using to compile
10:59:33 <Luke1> it was working well but I didn't know how to configure the include searches
11:08:17 <Luke1> jmcarthur: thanks so much. all working fine now
11:09:50 <jmcarthur> great!
11:11:00 <chrisdone> yay emacs
11:19:40 <CaptainK> geekosaur: how do I assign a bunch of code to cycle for each element in a list?
11:20:38 <CaptainK> i.e. ["TEN","ONE"...] for each one do some code and recurse for the second and so on
11:21:43 <geekosaur> depends on what you are doing. as I suppose you're still trying to force haskell into a procedural mode, you probably want mapM_ or forM_
11:22:25 <ethoma>  /msg NickServ identify nyenhuis1
11:22:27 <geekosaur> but what you actually wqant depends on what you're trying to do with the list
11:22:50 <geekosaur> "oops"
11:23:07 <geekosaur> ethoma, suggest you change that password asap
11:23:17 <ethoma> yeah - idk why it did that?
11:23:26 <ethoma> I only use it here though
11:23:39 <geekosaur> you typed a space before it sent it
11:24:14 <ethoma> wow that sucks - I hope no one knows my reddit and stack overflow username
11:24:30 <CaptainK> what I'm doing right now is just assigning the list to a name and then manully typing name !! 0, name !! 1 and so on ...
11:25:02 <CaptainK> running the code for each instance by changing it in the program and rerunning the whole thing
11:25:24 <CaptainK> want to have that do it by recursion
11:26:11 <jmcarthur> CaptainK: if you could write the type signature of the code in the form  element -> output,  what would its type be?
11:26:30 <jmcarthur> CaptainK: the code that runs for each element, that is
11:26:34 <S_J> How do I mao over IO [Integer]?
11:27:16 <jmcarthur> S_J: same question i just asked CaptainK. :)  what kind of function are you trying to map over it?  Integer -> ??
11:27:44 <CaptainK> mine would be String
11:27:57 <jmcarthur> CaptainK: so you are just transforming the elements of the list into Strings?
11:27:59 <geekosaur> S_J, first you use >>= to get an action which can operate on the [Integer], then what kind of map you want depends on what you're trying to do (but since the result has to be in IO you probably want some variant of mapM)
11:28:17 <CaptainK> after manipulation yes
11:28:21 <simukis_> shouldn't `map func <$> io_list` work?
11:28:27 <jmcarthur> CaptainK: and you are wanting to get a list back?
11:28:49 <CaptainK> yes, a heavily processed one
11:28:49 <jmcarthur> CaptainK: a list of Strings, that is?
11:28:58 <jmcarthur> CaptainK: can you just use map, then?
11:29:01 <jmcarthur> :t map
11:29:02 <lambdabot> (a -> b) -> [a] -> [b]
11:29:19 <CaptainK> so you wrap your code in map()
11:29:25 <joelteon> :hist is telling me the history is empty
11:29:29 <joelteon> for this exception
11:29:38 <joelteon> is there anything I'm missing? do I need profiling turned on?
11:30:07 <jmcarthur> > map (\x -> x + 5) [1,2,3,4,5]
11:30:08 <lambdabot>   [6,7,8,9,10]
11:30:39 * jmcarthur has never used :hist
11:31:03 <joelteon> also, it might be because the source of the exception is from the FFI
11:31:23 <S_J> a <- expr; all (<=100) a; what pattern is that? thought it was >>=
11:31:34 <joelteon> I'm getting an undefined exception from imagemagick bindings (i.e. it doesn't know what the exception is)
11:33:09 <joelteon> anyone have any advice? I don't usually run into this stuff in haskell so I'm not so good at debugging
11:34:39 <CaptainK> ok, i have the code working but just need to recurse it.
11:35:22 <S_J> what function takes a value from a Monad and prints it? Just 5 >>= print
11:35:26 <CaptainK> so I need to give my code a function name and pass it my list
11:35:30 <S_J> > Just 5 >>= return . print
11:35:32 <lambdabot>   Just <IO ()>
11:37:40 <codesoup> btw CaptainK, it's easier for people to figure out what you want to do if you make a paste of it. i think there is a haskelly pastebin in the topic
11:37:44 <geekosaur> S_J, that question is a bit confused, I think. for starters, which monad do you believe that to be in? (since it needs to be IO if you want to print)
11:37:50 <tac> > getLine
11:37:51 <lambdabot>   <IO [Char]>
11:38:06 <tac> That is a hacky show instance, isn't it?
11:38:13 <CaptainK> codesoup: ya, I'll try to post a simple exmple
11:38:23 <tac> Meaning, you can't actually define a show instance that displays the type in Haskell, can you?
11:38:33 <tac> (since it breaks parametricity)
11:40:24 <S_J> What do you do when you do :: IO Double for example, well you create an IO Double instead of an IO Int for example but it is not a cast right?
11:40:27 <geekosaur> tac: not standard Haskell, it's using Data.Typeable which requires some compiler support
11:40:45 <tac> ah
11:41:13 <jmcarthur> S_J: functions don't generically "take values from monads". monads are values. their type parameters might not even represent values
11:41:51 <jmcarthur> S_J: there is also not a generic print function outside of IO. you need either IO or some monad that wraps IO in order to print things
11:41:56 <jmcarthur> S_J: so the Maybe monad can't print things
11:41:57 <geekosaur> S_J, it's not a cast, it specifies the type you want and the compiler will use that to infer other types and pick appropriate typeclass instances. (if it can)
11:42:39 <geekosaur> so if I specify a Double type, this will control (for example) the result type of the implicit fromIntegral call around a numeric literal
11:42:53 <ethoma> Is the default Haskell platform download for Windows 64 bit? It doesn't say.
11:44:35 <geekosaur> I think it's 32 bit with 64 bit still being in development (or possibly testing at this point)
11:44:43 <jmcarthur> S_J: the (<=) in "a <- expr; all (<=100)" is just "less than or equal", not some monadic combinator
11:45:32 <jmcarthur> S_J: also, i don't see how that expression would typecheck unless that all function is not the standard one
11:45:35 <jmcarthur> :t all
11:45:35 <lambdabot> (a -> Bool) -> [a] -> Bool
11:46:45 <S_J> > Just 5 >>= \r -> print r; return r
11:46:46 <lambdabot>   <hint>:1:25: parse error on input `;'
11:46:52 <S_J> > Just 5 >>= \r -> do print r; return r
11:46:53 <jmcarthur> S_J: however, there is a (=<<) operator, which is just (>>=) with the arguments swapped
11:46:53 <lambdabot>   Couldn't match type `GHC.Types.IO' with `Data.Maybe.Maybe'
11:46:53 <lambdabot>  Expected type: ...
11:47:17 <jmcarthur> S_J: as i said earlier, you can't print in the Maybe monad
11:53:36 <CaptainK> codesoup: In [x| x <- ... Want to work with x not "word" http://ideone.com/GpuqXi
11:54:35 <CaptainK> it just an example, so don't want just a new way to print the list, want to do a bunch more stuff then print out.
11:56:07 <CaptainK> so let word =[x| x <- words], want to do a whole bunch of calcs for each x
11:56:16 <jmcarthur> CaptainK: "let word =[x| x <- words]"  that is just a complicated way of saying that word should be the same as words. it draws each element from words and puts it into a new list called word
11:56:35 <codesoup> CaptainK, try "let newword = [reverse x | x <- words]"
11:56:41 <CaptainK> right, but it is nice way to filter
11:56:52 <jmcarthur> CaptainK: so it looks to me like what you *actually* are trying to do is not return a list of strings, but just print a bunch of strings, right?
11:56:58 <CaptainK> remember its only an example, I don't want to just reverse the words
11:57:09 <CaptainK> jmcarthur: yes
11:57:20 <jmcarthur> CaptainK: see mapM_
11:57:22 <jmcarthur> :t mapM_
11:57:23 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:57:39 <jmcarthur> CaptainK: so you can use that to apply a function to each element of the list
11:57:48 <jmcarthur> CaptainK: where the function can return IO actions
11:58:01 <jmcarthur> :t mapM_ (print . reverse)
11:58:02 <lambdabot> Show a => [[a]] -> IO ()
11:58:19 <jmcarthur> :t mapM_ (print . reverse) ["ANGER","ARRIS","CARES"]
11:58:19 <lambdabot> IO ()
11:58:41 <CaptainK> but I want to do more than reverse it
11:58:51 <startling> CaptainK: what else do you want to do?
11:58:58 <codesoup> CaptainK, you should write a function first and then map that function to the list at the end
11:58:59 <jmcarthur> (i can't use print in lambdabot, otherwise i would demonstrate it working)
11:59:04 <jmcarthur> CaptainK: then do more...
11:59:41 <codesoup> CaptainK, say you make functions doThis, doThat, doSomeMore, and then you do "map (doSomeMore . doThat . doThis) words"
11:59:51 <codesoup> and now you have a list where each element has been transformed by your functions
12:00:03 <CaptainK> codesoup: mapM_ (print . do my function here)
12:00:48 <jmcarthur> CaptainK: what is it you are *actually* wanting to do?
12:00:50 <codesoup> if you are just working with each word one by one, then just make functions that work on individual words. afterwards you can apply all those functions to all the words
12:01:20 <CaptainK> do a bunch of tests on each word and spit out a result
12:01:44 <bscarlet> CaptainK: http://ideone.com/u98bpU
12:01:45 <jmcarthur> CaptainK: by "tests" you mean "things that return Bool"?
12:02:04 <CaptainK> no, that return null or new string
12:02:20 <bscarlet> CaptainK: what do you mean by "null"?
12:02:26 <jmcarthur> CaptainK: i take it you mean Nothing or Just someNewString?
12:02:31 <CaptainK> return nothing
12:02:44 <jmcarthur> CaptainK: and so the idea is that you want the end result to contain the new strings and that's it?
12:02:49 <jmcarthur> :t catMaybes
12:02:50 <lambdabot> [Maybe a] -> [a]
12:02:51 <CaptainK> and return numbers
12:02:53 <jmcarthur> :t mapMaybes
12:02:53 <lambdabot>     Not in scope: `mapMaybes'
12:02:54 <lambdabot>     Perhaps you meant one of these:
12:02:54 <lambdabot>       `IM.mapMaybe' (imported from Data.IntMap),
12:02:54 <subbyyy> which one is better, cabal-dev or virthualenv?
12:02:55 <jmcarthur> :t mapMaybe
12:02:56 <lambdabot> (a -> Maybe b) -> [a] -> [b]
12:03:23 <codesoup> CaptainK, make a function for each individual test, then compose them, then map them to the list of words
12:03:23 <jmcarthur> subbyyy: i have only used the former. eventually, cabal-install itself will have a sandbox feature too, and i can't wait
12:04:05 <jmcarthur> CaptainK: so... what is the type of the result of this whole thing? you have said vague things about strings and nulls and numbers, which is not helping us help you much
12:04:13 <subbyyy> jmcarthur: thanks for the info. ill just go with cabal-dev for now
12:04:28 <codesoup> actually bscarlet's example is perfect
12:04:36 <ksf> what's up with hpaste?
12:05:01 <bscarlet> codesoup: :-)
12:05:53 <CaptainK> jmcarthur: realize its vague, but I think the paste and map will help...I'm just trying by example to see how I replace my imperative thinking with functions.
12:06:01 <bscarlet> CaptainK: dunno how perfect my example is, depending on what you want to do. If you want to filter out some of the inputs and/or return numbers instead of strings, you need to do other stuff too.
12:06:18 <ksf> argh pastebin's syntax highlighting is unusable.
12:07:02 <CaptainK> the important thing was to just get an example of how to call something to branch of code for each elements in a list
12:07:12 <ksf> anyhow, http://pastebin.com/wtvdkSPH
12:07:19 <mauke> The paste wtvdkSPH has been copied to http://paste.tryhaskell.org/90674
12:07:20 <ksf> alphaTy isn't doing what I think it ought to do.
12:07:22 <S_J> can you send a message to a thread created by forkIO?
12:07:33 <ksf> that is, replace all type variables in a type with fresh ones.
12:07:43 <bscarlet> CaptainK: Because you've used the word "null" as it might be used in Java or Javascript, and because you've been vague about your typing, it sounds to me like you need to learn not just about functional vs. imperative thinking, but static vs. dynamic typing too. They're separate things to learn.
12:08:03 <ksf> I figure it's a transformer issue, but then I have, strictly speaking, no idea what I'm doing when it comes to transformers.
12:08:08 <jmcarthur> CaptainK: there are many ways to do that. map is the one to use when it's just going to be plain pure functions and you expect the result to be another list of the same length where the function has been applied to each element of the original list
12:08:10 <ksf> (I just use them and usually they work)
12:08:11 <CaptainK> ok, thats important to know for sure
12:09:05 <jmcarthur> CaptainK: have you been following any sort of tutorial? maybe we should just refer to you Learn You a Haskell or something so you can learn things in an order we recommend
12:09:15 <jmcarthur> @where lyah
12:09:15 <lambdabot> http://www.learnyouahaskell.com/
12:09:49 <CaptainK> ya, the lyah is ok, but its gets boring, just want to start now
12:10:03 <CaptainK> need to work with code, its faster for me
12:10:09 <ksf> CaptainK, if lyah is boring, try real world haskell
12:10:17 <ksf> it's less gentle :)
12:10:25 <jmcarthur> @where rwh
12:10:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:10:36 <CaptainK> well its reading things on the screen too, don't like reading that way
12:10:44 <CaptainK> wish I had the book
12:10:48 <jmcarthur> CaptainK: both of those do come in dead tree form :)
12:11:07 <CaptainK> Its hard to get anything where I live
12:11:19 <jmcarthur> you can't order online?
12:11:27 <CaptainK> which is such a joke, because the whole world comes through my doorstep
12:12:09 <CaptainK> will be doing so , but will have to wait for someone travelling to my dimension before receipt
12:12:09 * ksf informs the channel that they aren't rubber ducks, I haven't recognised the solution, y'all can look at his paste :)
12:12:10 <monochrom> LYAH has code to work with
12:12:25 <ksf> s/I/he/
12:12:34 <CaptainK> ya, but that code is more number oriented
12:12:47 <CaptainK> I'm need more TEXT examples
12:13:03 <ksf> you'll like rwh better, then.
12:13:23 <CaptainK> ah, ok...looking for rwh
12:13:46 <jmcarthur> @where rwh
12:13:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:15:34 <CaptainK> ok thanks guys...I'll try to educate myself a bit better and create less vague questions.
12:16:35 * CaptainK is reading...reading...drink beer...reading...reading...smoke joint...reading...
12:16:49 <codesoup> if you really want to get your hands dirty immediately, there are things like "write yourself a scheme in 48 hours". i'm not so sure it's very suitable as a haskell tutorial though
12:16:51 <monochrom> I respect your preference, but text examples are hardly more instructive than number examples. if all you care will be number-crunching or text-crunching, haskell is a sledgehammer and not worth learning, go with perl or awk.
12:16:52 <ksf> argh don't drink and smoke
12:17:41 <ksf> actually, haskell is a 10-ton scapel when it comes to text processing.
12:18:11 <erisco> if you have a recursive function which creates an infinite type (due to collecting results in tuples), the way to fix this seems to be a recursive data type
12:18:53 <erisco> but it is somewhat silly to create a new type in every case of this ... the question is perhaps oddly worded
12:18:58 <ksf> http://pastebin.com/wtvdkSPH  (alphaTy (called from constraints) isn't doing what it should, replace all type variables in a looked up free binding with fresh ones)
12:18:58 <mauke> The paste wtvdkSPH has been copied to http://paste.tryhaskell.org/90674
12:19:09 <CaptainK> I can tell this is an excellent programming language, its my failing that I don't want to value it with
12:19:10 <ksf> erisco, blame type theory.
12:19:42 <ksf> and... don't succumb to tuple cancer.
12:19:43 <erisco> I'm seeking a common mechanism for doing this, rather than a new data type per recursive function
12:20:11 <ksf> haskell isn't scheme
12:20:41 <ksf> erisco, the generalised way to do it is this: http://blog.plover.com/prog/springschool95-2.html
12:21:52 <erisco> ksf, I'll take a look thanks. Really this is about readability and practicality more than anything
12:21:59 <S_J> So what do you think of the internet of things? Can we save a lot of energy by connecting everything and controlling it? Sounds like a big safety hazard as well...?
12:22:46 <ksf> meh, noone wants to debug my code :,|
12:23:03 <monochrom> I think the internet is full of people posting to wrong channels.
12:23:12 <johnw> S_J: That is not really on topic for this channel
12:24:44 <uniquenick> are (,) and (,,) and (,,,) etc just ordinary operators?
12:25:00 <ksf> uniquenick, modulo syntactic sugar, yes.
12:25:17 <uniquenick> where are they defined?  hoogle doesn't want to search for (,)
12:25:20 <monochrom> I don't know what is "ordinary", but these seem to work:
12:25:29 <ksf> they're inbuilt.
12:25:33 <monochrom> > (,,) 5 Bool 'x'
12:25:34 <lambdabot>   Not in scope: data constructor `Bool'
12:25:37 <monochrom> oops
12:25:41 <monochrom> > (,,) 5 True 'x'
12:25:41 <lambdabot>   (5,True,'x')
12:25:46 <ksf> because they're kind of special, being n-ary and everything.
12:26:03 <ksf> they behave normally, though.
12:26:07 <bscarlet> doesn't that stuff require CommaSections?
12:26:13 <ksf> even more normal when you enable -XTupleSections
12:26:19 <ksf> no, only sections, not the pure operators.
12:26:29 <bscarlet> Ah.
12:28:14 <uniquenick> what specialness makes it so you need to do (5,3) rather than just 5,3 but you don't need to do (5+3)?
12:28:29 <monochrom> parser
12:30:17 <monochrom> (,,) is also specially recognized by parser. see Haskell 2010 section 3.8, has a dedicated rule for them
12:31:29 <monochrom> TupleSections is when you write like (5,) IIRC
12:32:51 <S_J> johnw: I thought you guys were intellectuals :)
12:33:57 <monochrom> that isn't relevant
12:34:43 <Sonarpulse> is there any function :: a -> Ptr a
12:34:49 <Sonarpulse> I realize I can use alloca and poke
12:35:01 <Sonarpulse> but the C function takes a const parameter
12:35:13 <Sonarpulse> so what's the point?
12:36:32 <monochrom> do you mean the C function is like f(const *T)?
12:36:47 <johnw> SS_J: we talk about Haskell here, other stuff elsewhere
12:37:05 <ksf> http://pastebin.com/G0Ds42Sv  (made the whole thing less intimidating)
12:37:11 <mauke> The paste G0Ds42Sv has been copied to http://paste.tryhaskell.org/90679
12:37:14 <Sonarpulse> yes
12:37:31 <geekosaur> Sonarpulse, the point is that a Haskell value can get moved around by the garbage collector
12:37:33 <geekosaur> and there's no way to know if the C function will hold on to the pointer
12:37:46 <Sonarpulse> ok
12:37:47 <johnw> Kinnison: ping
12:37:50 <Sonarpulse> say you know it won't
12:38:04 <monochrom> the FFI doesn't care whether it's const T* or T*. do your normal alloca and poke on the Haskell side, say "const T*" on the C side. neither side will care.
12:38:04 <johnw> @tell Kinnison You must wrap code that uses Libgit2 in "withLibGitDo"
12:38:04 <lambdabot> Consider it noted.
12:38:31 <geekosaur> there are various unsafe pointers
12:38:37 <Sonarpulse> well in my case it's going to copy it anyway
12:38:57 <Sonarpulse> ah ok, so the other unsafe pointers can be used as an optomization when one actually needs it
12:38:59 <Sonarpulse> (not in my case)
12:39:12 <Sonarpulse> thanks all
12:39:49 <monochrom> if you further say, you know the haskell side is practically pure despite alloca and poke, add an unsafeDupableIO or unsafeLocalState (they're currently synonyms)
12:40:02 <Sonarpulse> ok cool
12:40:44 <ksf> *DOH*
12:41:31 <CaptainK> ok, starting to see the proper way of thinking...thanks for the help see you all a bit later
12:42:35 <chrisdone> johnw: !!!
12:43:44 <__S__J__> why does XMPP use XML since it is supposed to be near real-time?
12:44:03 <ksf> because XML is cancer
12:44:11 <ksf> cancer has the habit of spreading
12:44:26 <__S__J__> what does people hate about XML? that it is hard to read?
12:44:43 <ksf> *and* hard to parse.
12:44:48 <Taneb> It's excessively verbose
12:45:00 <pkkm> very space-inefficient when you have more structure than data.
12:45:19 <ksf> there's also no reason whatsoever to have attributes.
12:45:47 <ksf> I once had to debug an ant file, that wasn't fun.
12:45:53 <Taneb> It's a modification of HTML and it shows
12:45:58 <johnw> chrisdone: hi!
12:46:17 <ksf> (though make is also a hell to its own when it comes to syntax)
12:46:25 <arkeet> it's also awful that tags can contain a mix of tags and content.
12:47:04 <pkkm> in my opinion, XML is very overused, especially in things like build systems, where there is a lot of markup and not much data.
12:47:20 <pkkm> S-expressions or JSON would be much more efficient and easier to read and parse.
12:47:28 <acube> I like json/yaml much more than xml
12:47:39 <ksf> or piqi
12:47:52 <ksf> (for your ADT needs)
12:48:18 <pkkm> I think it's a pity that S-expressions aren't more widely used today. they would make a great alternative to XML in many places.
12:48:22 <arkeet> I have never heard of piqi.
12:48:26 <johnw> chrisdone: what's up?
12:48:30 * acube neither
12:48:39 <johnw> pkkm: articles have been written about that :)
12:48:54 <monochrom> __S__J__: I'm going to put you on +q for several hours for repetitively going off-topic despite being told to stop
12:49:00 --- mode: ChanServ set +o monochrom
12:49:04 <johnw> monochrom++
12:49:10 --- mode: monochrom set +q $a:S_J
12:49:15 --- mode: monochrom set -o monochrom
12:49:38 * hackagebot gitlib-libgit2 1.2.2 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-1.2.2 (JohnWiegley)
12:49:40 * hackagebot gitlib-s3 1.1.2 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-1.1.2 (JohnWiegley)
12:49:42 * hackagebot gitlib-cmdline 1.2.1 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-1.2.1 (JohnWiegley)
12:49:44 * hackagebot git-monitor 1.3.1 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-1.3.1 (JohnWiegley)
12:51:23 <Sonarpul`> is there any standard functino from converting a C error code to a boolean?
12:51:45 <ksf> never mind, both my test and my type inferer are sane, what wasn't sane was alpha-renaming types of bound, instead of free bindings
12:51:59 <johnw> Sonarpu`: wouldn't that just be "err >= 0"?
12:52:13 <astor> isn't there a way to derive Binary, Hashable, NFData etc. for data types now with all the fancy derive language extensions?
12:52:16 <ksf> that really depends on the C function.
12:52:24 <monochrom> "err /= 0" may be better :)
12:52:24 <ksf> and it'd be /= 0
12:52:25 <johnw> astor: using GeneralizedNewtypeDeriving
12:52:37 <mauke> Sonarpulse: what's a C error code?
12:52:39 <astor> johnw: but for data types?
12:52:41 <johnw> although, that only works for newtype wrappers around types that have those
12:52:56 <johnw> ah, I'm not sure whether these guys have Generics support or not
12:52:57 <Sonarpulse> johnw yes
12:53:03 <ksf> astor, yes, there is.
12:53:06 <Sonarpulse> or /=
12:53:11 <johnw> ok
12:53:34 <monochrom> or maybe it's err==0
12:53:38 <Sonarpulse> mauke: CInt return used to signify error
12:53:48 <mauke> Sonarpulse: used how?
12:53:52 <ksf> astor, if your class hasn't GHC.Generics support yet, try http://hackage.haskell.org/package/derive
12:54:01 <ksf> you can get hashable from binary, easily.
12:54:25 <monochrom> Bohold, I tell you a mystery:
12:54:29 <benmachine> there's no uniform way of interpreting an integer as an error in C
12:55:31 <monochrom> C side "int f()" can be mapped to Haskell side "foreign import ccall f :: IO Bool". it will do the "right" thing. C 0 becomes Haskell False, C non-zero becomes Haskell True
12:55:35 <arkeet> there is no "C error code". the only standard for exit codes is that 0 is success and anything else is failure.
12:55:42 <arkeet> and errno is something else.
12:56:09 <monochrom> essentially C side HsBool must be int
12:56:16 <arkeet> monochrom: really? neat.
12:57:01 <monochrom> and the trumpet shall sound...
12:57:31 <arkeet> well I suppose it's completely reasonable to expect that.
12:58:45 <Kinnison> johnw: sorry, was travelling
12:59:27 <Kinnison> johnw: Can you give me an example of what you mean by wrapping with withLibGitDo ?
13:00:28 <johnw> main = withLibGitDo $ lalala
13:00:34 <Kinnison> aah
13:00:43 <johnw> libgit2, since 0.18, has a global function that needs to be called to initialize threading support
13:00:48 <johnw> that's what withLibGitDo is doing
13:00:56 <Kinnison> do I need to do that every time?
13:01:01 <johnw> i have an issue open about the awkwardness of it
13:01:02 <johnw> yes
13:01:12 <arkeet> sounds no more evil than withSocketsDo
13:01:28 <Kinnison> johnw: Lovely -- that seems to behave \o/
13:01:29 <astor> ksf: thanks.  derive takes ages to compile, but looks promising.
13:02:07 <johnw> Kinnison: cool, I'm rather eager to hear about your experiences, I don't think anyone out there is seriously writing gitlib code except for myself and some co-workers
13:02:12 <luite> withRocketshipUnderpantsDo
13:02:13 <chrisdone> johnw:  i played around with using that trigram-based code grepping utility from google on hpaste. 'tis fast
13:02:27 <johnw> chrisdone: nice!
13:02:31 <Kinnison> johnw: Well, we're currently designing a system at work which will require me to master gitlib and also something like happstack
13:02:42 <johnw> Kinnison: also, based on shachaf's observation last night, I found a way to get rid of unsafeMutateTree, so except that change to be coming this weekend
13:02:49 <Kinnison> heh
13:02:55 <Kinnison> cool
13:02:59 <johnw> Kinnison: ok, that will motivate me to write some docs then
13:03:09 <ksf> astor, if it's available, really use GHC.Generics support
13:03:09 <johnw> Kinnison: just ask me questions and I'll write up the answers as Haddocks
13:03:09 <Kinnison> johnw: Docs would definitely help me a *LOT*
13:03:15 * Kinnison grins johnw 
13:03:16 <ksf> derive will blow up your binary size etc.
13:03:24 <johnw> Kinnison: for now, look at the same code like git-monitor and git-gpush
13:03:28 <johnw> s/same/sample
13:03:33 <johnw> and also the tests
13:03:42 <ksf> ghc is really, really bad at getting rid of code that's only used at compile time.
13:03:47 <Kinnison> johnw: Don't expect anything serious for a week or two -- we need to finish the design first.  We're expecting to do parallel development in Haskell, Python and possibly Lua
13:04:02 <Kinnison> johnw: So we want to get the design right first
13:04:05 <astor> ksf: I would guess that Generic should be enough for Binary, Hashable and NFData, but is it?  My compiler says no.
13:04:23 <ksf> well, someone has to write the code for it.
13:05:06 <ethoma> If I have installed two versions of GHC, is there a way I can select which one the command "ghc" should belong to? (Windows)
13:05:28 <Kinnison> johnw: But I'll have a good play in the meantime and punt you any questions I have
13:05:36 <Kinnison> johnw: Do you have a preferred email address if you're not around on IRC?
13:06:11 <johnw> johnw@fpcomplete.com
13:06:49 * Kinnison stuffs a mutt alias in
13:07:14 <Kinnison> ta
13:07:26 <Rarrikins> ethoma: Set the path appropriately.
13:09:51 <hpaste> monochrom pasted “self-gratifying self test” at http://paste.tryhaskell.org/90681
13:09:57 <monochrom> hehehe!
13:10:07 <monochrom> please read, it's funny! :)
13:15:41 <astor> I can derive Hashable using a standalone instance declaration. However for Binary I get warnings: No explicit method or default declaration for `put' (and the same for 'get').
13:16:45 <monochrom> ethoma: if you say explicitly "ghc-7.6.3", "ghci-7.6.3" etc, you can get at the exact version
13:17:49 <Peaker> astor, you mean:   instance Binary Foo ?  The Binary class probably doesn't use a default with a default signature
13:18:47 <Peaker> astor, and the Hashable class probably does
13:18:55 <Peaker> astor, you can use the "derive" package to derive the Binary instance
13:21:21 <astor> Peaker: right.  NFData and Hashable works, Binary requires "derive".
13:22:25 <Peaker> it could be made to work, I wonder why it wasn't
13:22:51 <DiegoNolan_> Peaker, how do you have images of faded colors in drawingcombinators?
13:22:51 <justinjay> hello?
13:23:00 <justinjay> there we go
13:23:06 <DiegoNolan_> do you have to use unsafeOpenGLImage?
13:23:15 <Peaker> DiegoNolan_, we don't have any images there at all
13:23:23 <Peaker> DiegoNolan_, only font rendering and ordinary rectangles, iirc
13:23:35 <DiegoNolan_> convexPolys
13:23:35 <Peaker> DiegoNolan_, we use graphics-drawingcombinators so we don't have to go through the GL catastrophy directly
13:23:45 <DiegoNolan_> yeah
13:23:53 <DiegoNolan_> but as it is now you can only make solid color shapes
13:23:56 <Peaker> DiegoNolan_, and it can tint, including tinting with transparency.. not sure what you mean by "faded" though
13:24:14 <DiegoNolan_> I mean like soft edges on a shape
13:24:20 <astor> Peaker: The derive package mentions Binary as something that cannot be derived using the "guess" method because a tag is only needed with more than one constructor.  Maybe related?
13:24:33 <Peaker> DiegoNolan_, we don't have any soft edges on any shape afaik :)
13:24:46 <DiegoNolan_> hmm
13:25:03 <Peaker> astor, unlikely.. Generic can probably be used to derive binary instances
13:25:08 <DiegoNolan_> is there an example of unsafeOpenGLImage anywhere?
13:25:14 <DiegoNolan_> what it can do?
13:26:29 <Peaker> not sure if you're addressing me, but I don't know that function..
13:27:06 <DiegoNolan_> Peaker, yeah its in the library
13:27:47 <DiegoNolan_> Peaker, so as far as you know it is not possible to have an single image with different colors besides combining a bunch of images
13:29:40 <Peaker> DiegoNolan_, I now see that function, it's basically giving you low-level access to the library so you can extend it
13:30:06 <Peaker> DiegoNolan_, you can do any GL drawing you want in it
13:30:11 <DiegoNolan_> ahh
13:33:50 <bobajett> how can I write this function foo, such that: foo 'a' ['b','c'] => [ ['a','b','c'],  ['b','a,'c'],  ['b','c','a'] ]
13:34:07 <bobajett> for the life of me I can't figure out how to write a recursive function to do that.
13:34:37 <bobajett> (its a part of a function used to compute permutations)
13:35:01 <arkeet> start with a base case. what should foo a [] be?
13:35:15 <bobajett> [['a']]
13:35:26 <arkeet> then, given  foo a bs  what should  foo a (b:bs)  be?
13:35:44 <ethoma> Try using the split function and splitting the list at different points, then add in the extra character in the middle of the split and join
13:35:59 <arkeet> ethoma: that's not very nice.
13:36:17 <bobajett> arkeet: cool, I'll try that out.
13:36:36 <ethoma> arkeet: It seems to be easier to me? Maybe not as fast though
13:36:57 <arkeet> ethoma: there's a nice way to do it.
13:37:17 <dmwit> That way seems pretty nice to be.
13:37:19 <arkeet> hmm, I might be thinking of the opposite thing.
13:37:19 <dmwit> *me
13:37:32 <arkeet> I was thinking of select.
13:37:41 <dmwit> There are several nice ways, each with its own flavor of nicety. =)
13:37:55 <astor> anyone using Shake here?
13:38:02 <arkeet> oh, never mind, it works.
13:38:23 <bscarlet> astor: yes
13:38:54 <arkeet> e.g. how would you build [[a,b,c], [b,a,c], [b,c,a]] out of [[a,c],[c,a]]?
13:38:59 <arkeet> (and a and [b,c])
13:39:18 <arkeet> (hint: look at the head and the tail of the result)
13:39:25 <ethoma> arkeet: I think you could do it with foo accu a (b:bs) = (b:a:bs:[]):(a:b:bs:[]):accu
13:39:50 <arkeet> I think you couldn't, because that's a type error.
13:39:54 <ethoma> arkeet: well not exactly that - but something like that idea of exchanging
13:40:05 <astor> I want to misuse it for configuration management.  So I have an oracle that can for example give me the sha512sum of a given part of a remote configuration.  I have the local configuration and can detect if there's a change.  I'm trying to figure out how to get this into the Shake system :-)
13:40:21 <arkeet> hmm
13:40:31 <arkeet> > {-  _] "spoiler"
13:40:33 <lambdabot>   <hint>:1:1: unterminated `{-'
13:40:43 <arkeet> > {-  -} "spoiler"
13:40:44 <lambdabot>   "spoiler"
13:40:46 <arkeet> ok
13:40:56 <bobajett> arkeet: this is where I get stuck: so foo x [] = [[x]] -- solves the case foo 'a' [] => [['a']]
13:41:02 <arkeet> oh wait, this channel is +c
13:41:47 <arkeet> bobajett: ok, look at my hint :-)
13:42:06 <bscarlet> astor: can you try stating in English a simple example of what you want to check, and what you want to do sometimes if the check so indicates?
13:42:27 <nooodl> <arkeet> e.g. how would you build [[a,b,c], [b,a,c], [b,c,a]] out of [[a,c],[c,a]]? <-- this looks very wrong to me
13:42:41 <bobajett> oh sorry didn't see your hint, let me try again
13:42:59 <arkeet> nooodl: it's correct.
13:43:03 <nooodl> b in the centre first, then left, then right... with a and c swapped?!
13:43:08 <dmwit> I'm with nooodl.
13:43:29 <arkeet> it's "how would you build foo a [b,c] out of foo a [c]?"
13:43:30 <dmwit> Well, I think both the input and the output are screwy. =)
13:43:55 <arkeet> look again
13:43:59 <astor> bscarlet: Example:  If "ssh remote 'cat /etc/passwd | sha512sum'" /= 2323flfnlkn then "scp pristine/remote/etc/passwd remote:/etc/passwd".
13:44:08 <bscarlet> dmwit, arkeet, noodl: perhaps the example underspecifies the problem?
13:44:16 <arkeet> > foo a [b,c]
13:44:20 <lambdabot>   mueval-core: Time limit exceeded
13:44:22 <arkeet> > foo a [b,c]
13:44:26 <lambdabot>   mueval-core: Time limit exceeded
13:44:28 <arkeet> uh
13:44:30 * dmwit sighs
13:44:39 <alpounet> @src foo
13:44:39 <lambdabot> Source not found. Abort, Retry, Panic?
13:44:40 <arkeet> > foo a [b,c]
13:44:44 <lambdabot>   [[a,b,c],[b,a,c],[b,c,a]]
13:44:45 <arkeet> > foo a [c]
13:44:48 <lambdabot>   [[a,c],[c,a]]
13:44:49 <arkeet> looks fine to me.
13:44:52 <astor> bscarlet: I consider the "what is sha512sum of /etc/password?" to be an oracle, but it could be represented as a file locally as well
13:45:19 <arkeet> > foo a [b,c,d,e,f]
13:45:19 <lambdabot>   Ambiguous occurrence `f'
13:45:20 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
13:45:21 <arkeet> > foo a [b,c,d,e]
13:45:26 <lambdabot>   mueval-core: Time limit exceeded
13:45:27 <arkeet> ugh.
13:45:28 <arkeet> > foo a [b,c,d,e]
13:45:33 <lambdabot>   mueval-core: Time limit exceeded
13:45:36 <arkeet> *ugh*
13:45:49 <arkeet> > foo a [b,c,d,e]
13:45:52 <lambdabot>   [[a,b,c,d,e],[b,a,c,d,e],[b,c,a,d,e],[b,c,d,a,e],[b,c,d,e,a]]
13:45:54 <nooodl> wow lambdabot is being weird
13:46:02 <arkeet> bobajett: ^ this is what you're looking for right?
13:46:09 <bobajett> yep!!
13:46:41 <starji> The _____ season that was on when I was in elementary school was the best season ever.
13:46:41 <starji>     permalink
13:46:53 <dav> arkeet: how did you define foo in lambdabot ?
13:46:59 <arkeet> I used @let in private.
13:47:06 <dav> ah, I see
13:47:07 <bobajett> I know thats what Im trying to figure out!! magic!
13:47:12 <bobajett> oh! cool!
13:47:15 <elliott> starji: ?
13:47:33 <arkeet> ??
13:47:53 <elliott> ???
13:48:14 <roconnor> > zip<$>inits<*>tails $ [b,c,d,e]
13:48:15 <lambdabot>   [([],[b,c,d,e]),([b],[c,d,e]),([b,c],[d,e]),([b,c,d],[e]),([b,c,d,e],[])]
13:48:19 <hpaste> arkeet pasted “solution for bobajett” at http://paste.tryhaskell.org/90683
13:48:24 <arkeet> don't click if you don't like spoilers, I guess.
13:49:00 <bobajett> arkeet: thanks so much! I've been struggling with this for longer than I care to mention, but I'll struggle some more based on your hints before clicking on the link. But I really appreciate it!!!
13:49:00 <joehillen> arkeet: impressive
13:49:33 <arkeet> bobajett: ok :)
13:53:26 <arkeet> > foldr (<=<) return (map foo [a,b,c]) []
13:53:30 <lambdabot>   [[a,b,c],[b,a,c],[b,c,a],[a,c,b],[c,a,b],[c,b,a]]
13:53:48 <bscarlet> astor: I'd start with writing a simple version eliminating the remoteness, just updating one set of files from another. Get that working with simple rules, then dig in to how Shake implements those rules, and make an analogous new type to represent a remote path and write appropriate instances to encapsulate the remoteness.
13:53:49 <joelteon> :t foo
13:53:50 <lambdabot> t -> [t] -> [[t]]
13:53:55 <joelteon> foo 1 [1]
13:53:58 <joelteon> > foo 1 [1]
13:54:01 <lambdabot>   [[1,1],[1,1]]
13:54:04 <arkeet> it's the same foo as above.
13:54:57 <arkeet> > foldr (<=<) return (map foo [a,b]) [c,d]
13:54:57 <dav> I had -- foo x a = foo' x a [] where { foo' x [] b = [ b ++ [x] ] ; foo' x (a:as) b = ( b ++ [x] ++ (a:as) ) : foo' x as (b ++ [a]) }
13:55:00 <lambdabot>   [[a,b,c,d],[b,a,c,d],[b,c,a,d],[b,c,d,a],[a,c,b,d],[c,a,b,d],[c,b,a,d],[c,b...
13:55:04 <dav> but yours is much more elegant
13:55:09 <arkeet> :)
13:55:26 <arkeet> is yours lazy enough?
13:55:26 <arkeet> > foo 0 [1..]
13:55:29 * apples used zippers :(
13:55:30 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
13:55:36 <arkeet> > map (take 3) foo 0 [1..]
13:55:38 <lambdabot>   Couldn't match expected type `a1 -> [t2] -> t0'
13:55:38 <lambdabot>              with actual ty...
13:55:43 <arkeet> > map (take 3) $ foo 0 [1..]
13:55:46 <lambdabot>   [[0,1,2],[1,0,2],[1,2,0],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
13:56:14 <bobajett> nice!!
13:56:31 <kxra> i'm trying to teach myself haskell by making a simple survey app
13:56:54 <arkeet> bobajett: bonus points if you understand the foldr thing I did.
13:56:58 <dav> Prelude> take 5 $ map (take 5) (foo 1 [2..])
13:56:58 <dav> [[1,2,3,4,5],[2,1,3,4,5],[2,3,1,4,5],[2,3,4,1,5],[2,3,4,5,1]]
13:57:07 <kxra> context here: http://www.happstack.com/ircBot/irc-log/happs-2013-07-04.txt
13:57:10 <arkeet> davd__: ok.
13:57:13 <dav> it's lazy enough..
13:57:18 <dav> but it's ugly..
13:57:19 <kxra> but i need help joining two list of boolans
13:57:29 <kxra> booleans*
13:57:41 <dav> kxra: zip ?
13:57:49 <arkeet> joining how?
13:57:51 <bobajett> arkeet: Im afraid I haven't even seen "<=<" in my readings of LYAH and CFP yet.
13:57:57 <dmwit> ?hoogle [Bool] -> [Bool] -> [Bool]
13:57:57 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
13:57:57 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
13:57:57 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:58:02 <arkeet> bobajett: it's a monad thing
13:58:16 <arkeet> :t (<=<)
13:58:16 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:58:30 <kxra> dav, arkeet: joinisg such that the first elements of each list are compared, and saved as the first element of the resulting list
13:59:01 <arkeet> elliott++ for making :t work in private
13:59:04 <Peaker> bobajett, if you think of   (a -> m b)  as a thing ("effectful function" perhaps), the (<=<) is like (.), but for "effectful functions" rather than ordinary functions
13:59:09 <kxra> so [True, True, False] and [True, False, False] would result in [True, False, False]
13:59:41 <kxra> pardon the unecessary spaces
13:59:43 <bobajett> Peaker: nice! that actually made sense!
13:59:43 <dmwit> :t zipWith -- kxra
13:59:44 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:59:46 <arkeet> spaces are good.
13:59:50 <arkeet> and zipWith is probably what you want.
14:00:09 <arkeet> you give it a function that tells what to do with two Bools.
14:00:18 <arkeet> and then you get something that works on two [Bool]s.
14:00:19 <dav> arkeet, bobajett: another one, inspired by roconnor: foo2 x l = zipWith f (inits l) (tails l) where f l1 l2 = l1 ++ [x] ++ l2
14:00:50 <dmwit> > zipWith (const error) [1, 2, 3] [] -- but beware: it truncates to the length of the shorter list
14:00:53 <lambdabot>   []
14:01:03 <arkeet> dav: yes
14:01:09 <arkeet> :)
14:01:19 <Peaker> bobajett, cool :)
14:01:21 <arkeet> although I don't like how it traverses the list twice.
14:01:24 <dav> arkeet: I think yours would perform the best though cause you avoid ++
14:01:29 <arkeet> in parallel, I suppose.
14:01:39 <arkeet> maybe.
14:01:46 <arkeet> that might be what I meant.
14:02:32 <dav> kxra: I don't understand what you mean
14:02:39 <arkeet> Peaker++
14:02:41 <Kinnison> johnw: Am I expected to use withRepository all the time?
14:02:45 <mapreduc1> > zipWith (&&) [True, True, False] [True, False, False]
14:02:46 <lambdabot>   [True,False,False]
14:03:15 <arkeet> I was thinking of "foo a" as a function that inserts  a  somewhere into a list
14:03:24 <mapreduce> kxra: Isn't that what you're after?
14:03:32 <arkeet> choosing the position nondeterminstically.
14:03:37 <johnw> Kinnison: either withRepository or runRepository.  A repository is a monad transformer, so you need to be "inside it" to invoke gitlib functions
14:03:39 <arkeet> or whatever.
14:03:50 <arkeet> list monad is fun
14:04:02 <kxra> dmwit: zipwith looks like it might work, but i got this error "Couldn't match expected type `a0 -> b0 -> c0'
14:04:20 <Kinnison> johnw: Hmm, so what would be the best way to open a repository and keep it around for use at various points but not all the time?
14:04:22 <kxra>  with actual type '[Bool]'
14:04:28 <arkeet> kxra: well, paste your code.
14:04:31 <arkeet> or something
14:04:31 <kxra> oh i see
14:04:34 <arkeet> or that.
14:04:36 <mapreduce> kxra: You probably got the arguments in the wrong order.
14:04:39 <dmwit> kxra: Perhaps you supplied your list as the first argument instead of a combining function.
14:04:40 <kxra> yeah i did
14:05:04 <dmwit> kxra: (That is pretty much just literally reading your error aloud, though. =)
14:05:07 <Kinnison> johnw: Not least I'll want to keep a repository around (not losing caches or whatever) but I'll be invoked via happstack from time to time, so I'll not be "inside" the repository AFAICT all the time
14:05:10 <johnw> Kinnison: you can use "repoGet" inside the monad transformer.  That is a plain object that you can pass to runRepository in future
14:05:42 <Kinnison> where does repoGet come from?
14:05:53 <johnw> sorry
14:05:56 <johnw> getRepository
14:06:23 <johnw> withRepository Lg.lgFactory "some path name" $ getRpository
14:06:36 <johnw> that should return you a value that you can later pass to runRepository to interact with the repo at that same path
14:07:33 <alpounet> johnw, i guess you use these bindings for the ice?
14:07:35 <alpounet> ide*
14:07:53 <johnw> alpounet: yes
14:08:11 <Kinnison> Hmm, I get:
14:08:12 <Kinnison>     Couldn't match expected type `LgRepository m0 a0'
14:08:12 <Kinnison>                 with actual type `RepositoryFactory t0 m1 c0 -> t0 m1 c0'
14:08:16 <Kinnison> when I do:
14:08:22 <Kinnison> Prelude Git.Libgit2 Git Git.Utils Data.String Filesystem.Path> :t withLibGitDo $ withRepository lgFactory (fromString "/tmp/blah.git") $ getRepository
14:08:34 * Kinnison is exploring in ghci
14:08:56 <johnw> hmm
14:08:59 <johnw> let me try
14:09:15 * Kinnison is just trying to get a feel for this :-)
14:12:03 <kxra> okay, so now how can i drop tuple pairs from a list if one of their elements is False?
14:12:31 <Kinnison> kxra: Start off by writing out the type of the function you're trying to achieve
14:12:53 <johnw> Kinnison: this loads in ghci: https://gist.github.com/5930267
14:13:33 <Kinnison> johnw: So the missing 'lgFactory' at the end was the trick :-)
14:13:39 <Kinnison> withLibGitDo $ withRepository lgFactory (fromString "/tmp/blah.git") $ getRepository lgFactory
14:13:42 <Kinnison>   :: IO Git.Libgit2.Repository
14:13:45 <Kinnison> that seems reasonable
14:13:49 <johnw> yes
14:14:04 <johnw> i could avoid that second lgFactory if I added another associated type to the Repository class
14:14:07 <johnw> but I'm not sure it's worth it
14:14:40 * Kinnison grins, that's fine
14:14:49 <Kinnison> and then runRepository lgFactory r $ do .......
14:14:52 <Kinnison> when I want to use it
14:14:59 <Kinnison> that seems pretty easy, this is really nice
14:15:06 <johnw> although, I do suppose it's going to be a common use pattern for people to hold onto a repository in order to interact with it later
14:15:19 <Kinnison> v. common in daemons
14:15:22 <johnw> btw, there is also lgRunRepository, if you're only ever going to use libgit2
14:15:50 <johnw> the factory stuff is intended to let you run entirely backend-agnostic code
14:15:57 <Kinnison> Nod.
14:16:06 <Kinnison> I think it'd do me good to try and write backend-agnostic code where possble
14:16:18 <Kinnison> In fact, I shouldn't be doing anything which prevents me from using Git.Cmdline
14:16:24 <johnw> right
14:16:28 <johnw> CmdLine is also easier to debug
14:16:42 <johnw> you just s/silently/verbosely in CmdLine.hs, and suddenly you can see everything that is happpening
14:16:46 <Kinnison> Is shelly a convenient library for running sub-processes?
14:16:50 <johnw> yes, very
14:16:57 * Kinnison should learn that too then
14:17:01 * Kinnison puts it on his list
14:17:23 <kxra> Kinnison: like this? [(Bool, [Char])] -> [(Bool, [Char])]
14:17:36 <Kinnison> FYI, since Filesystem.Path has an IsString instance, you can do 'fromString' instead of 'fromText . pack'
14:17:47 <johnw> ah, nice
14:17:50 <Kinnison> kxra: Okay, that's good
14:17:55 <johnw> I use OverloadedStrings normally
14:18:20 <Kinnison> johnw: Mmm, I should learn the more useful -X... I guess
14:18:56 <anon123> Does anyone know if there are any libraries for Binary Space Partitioning?  http://new-hackage.haskell.org/package/spacepart seems to be dead...
14:19:03 <johnw> Kinnison: also, if you come across "awkwardnesses" in using the API, I am extremely interested to hear about it
14:19:06 <Kinnison> kxra: Now, you want to filter based on the first element of the tuple
14:19:13 <Kinnison> johnw: Nod. I'll do my best
14:19:24 <johnw> as well as anything that forces you into inefficient patterns
14:19:41 <johnw> I already realize that I need a mutateTreeRef, to avoid everyone always having to make a needless call to resolveTreeRef first
14:19:43 <Kinnison> johnw: Honestly I don't know enough yet to spot inefficiencies, but I can spot awkward :-)
14:20:03 <Kinnison> kxra: So you want something which goes (Bool, [Char]) -> Bool
14:20:12 <Kinnison> kxra: there's fst
14:20:14 <Kinnison> :t fst
14:20:14 <lambdabot> (a, b) -> a
14:20:14 <johnw> by inefficient I mean, you constantly have to do the same thing over and over
14:20:23 <Kinnison> johnw: notde.
14:20:28 <Kinnison> johnw: noted even :-)
14:20:46 <Kinnison> kxra: So, let's consider playing with filter
14:20:48 <Kinnison> :t filter
14:20:48 <lambdabot> (a -> Bool) -> [a] -> [a]
14:20:55 <Kinnison> :t filter fst
14:20:56 <lambdabot> [(Bool, b)] -> [(Bool, b)]
14:21:03 <Kinnison> kxra: See how I got there?
14:22:11 <Kinnison> johnw: presumably it behoves me to just ensure my main is always 'withLibGitDo realMain' or something?
14:22:16 <kxra> lambdabot is awesome
14:23:56 * Kinnison should play with happstack next
14:24:01 * Kinnison wants to glue happstack and gitlib together and see what horrors ensue
14:24:08 <johnw> Kinnison: yes, if you are using the libgit2 backend
14:24:29 <johnw> Kinnison: more abstract is: withBackendDo lgFactory
14:25:25 * Kinnison nods
14:25:56 <luite> going to build a better github?
14:26:45 <Kinnison> luite: If I were, I wouldn't be starting with this little understanding :-)
14:26:57 <Kinnison> johnw: OOI, is there a convenience function to turn an oid into a string/text/whatever?
14:28:01 <johnw> renderOid
14:28:07 <luite> Kinnison: hey it's a good start :)
14:28:10 <johnw> or renderObjOid, if you have a tagged oid (which you almost always will)
14:28:14 <luite> perhaps haskell has fewer unicorns
14:28:33 <johnw> parseOid/parseObjOid are the opposite
14:28:56 <Kinnison> what's the difference between an oid and a tagged oid?
14:29:11 <johnw> a commit oid doesn't type check with a blob oid, for example
14:30:23 <Kinnison> aah, so a tagged oid is an oid whose object type you know?
14:30:27 <johnw> yes
14:30:30 <Kinnison> neat
14:30:47 <Kinnison> so lookupRef produces an oid, where createCommit produces a tagged-as-commit oid?
14:30:55 <johnw> yes
14:31:03 <Kinnison> awesome, this is starting to click
14:31:09 <Kinnison> MOAR haddock in Git.hs would be nice
14:31:25 <johnw> actually, lookupRef returns a commit reference
14:31:44 <johnw> a function which accepts a plain oid is existsObject
14:32:09 <johnw> nothing but parseOid returns a plain oid
14:32:27 <johnw> actually, join me in #gitlib
14:32:32 <Kinnison> sure
15:02:31 <inf-groupoid> Can the scope of a "where" block be a whole type class instance?
15:09:17 <tomejaguar> Here's an interesting testing idea: A module which generates lots of input data using Arbitrary, and runs your function on it, but doesn't test any properties.  Instead it writes down the input and output so it can run the same functions after refactoring and check they give the same results.
15:09:22 <tomejaguar> Opinions?
15:09:59 <jfischoff> I can see value in that.
15:10:02 <jfischoff> do it!
15:10:15 <jmcarthur> tomejaguar: i would just keep the old code around, if it indeed serves as a good model for what the new code should do
15:10:59 <jmcarthur> hmm, actually, i'm seeing some value now that i'm thinking about how little work it would be
15:11:03 <jmcarthur> to use, that is
15:11:17 <tomejaguar> jmcarthur: Perhaps it could run the same input data over two versions of your repository.
15:11:30 <jmcarthur> would be cool if you just give some tool a module as input and then run it on the same module again when you are done refactoring
15:11:35 <jmcarthur> ah that would be cool too
15:11:57 <tomejaguar> Hmm, why has no one invented this before.  It would be useful.
15:11:59 <jmcarthur> or, rather, you give it one revision from which to generate the data and another to compare it against
15:12:04 <tomejaguar> Now I've invented it I've got to implement it :)
15:12:13 <jmcarthur> one big downside is that changing specs are the norm
15:12:29 <tomejaguar> jmcarthur: true, but there are many cases where you want to preserve all functionality
15:12:31 <jmcarthur> so its usefulness really only lasts for the duration of a refactoring
15:12:38 <tomejaguar> That is true
15:12:57 <jmcarthur> that said, it could be a nice refactoring assistant
15:13:03 <monochrom> inf-groupoid: unfortunately no
15:22:37 <pozori> okay, I
15:23:21 <pozori> I'm halfway through "Learn you a Haskell for a great good!", but I still can't quite understand the practical benefits of functional programming to imperative
15:24:37 <pozori> I've been duplicating examples in Java quite easily. sure Haskell may save a few lines in many cases and I understand implications of no-side-effects-functions, but somehow I just don't get it
15:25:13 <watermind> pozori: depends on what you mean by "functional programming"
15:25:28 <watermind> pozori: haskell is giving you many new things at once
15:25:41 <pozori> watermind: exactly! that is the question, practically
15:26:05 <elliott> perhaps you would find it easier to see if you didn't duplicate examples in Java.
15:26:13 <watermind> so one the one hand haskell is functional in the sense that it implements (typed) lambda calculus
15:26:29 <elliott> you'll only learn about translating Java to Haskell that way, not what truly new things Haskell can give you.
15:26:47 <pozori> elliott: you missed my point completely
15:26:48 <monochrom> translating Java to Haskell is impractical
15:26:49 <watermind> so in short that means you can build higher order functions
15:27:03 <watermind> you pass functions as arguments and you can return them as result
15:27:18 <watermind> that alone is pretty good in the sense that you can make programs more modular
15:27:18 <elliott> pozori: I don't see how. why the hostility?
15:27:48 <watermind> so for instance take something like fold
15:27:54 <watermind> well foldr
15:28:21 <monochrom> Haskell opens up many valuable ways of abstraction, they are unavailable in Java. but your practical work may or may not value abstraction. I have no further comments.
15:28:32 <watermind> foldr can be used to implement many different functions (map, filter, etc)
15:29:30 <watermind> than map and filter can be used to construct other functions (to upper case, remove odd numbers)
15:29:48 <watermind> you only get this kind of modularity because you can pass functions as arguments and return them as results
15:30:01 <watermind> ^ that are some of the benefits of being higher order
15:30:13 <watermind> haskell is also pure
15:30:26 <watermind> that is related with what you talk about, being free of side effects
15:30:38 <pozori> yes, I've gathered that much. similar to piping in bash, no side effects etc.
15:30:50 <watermind> so you can be pretty sure if a function uses IO or not, same with state etc
15:30:58 <elliott> monochrom++
15:31:21 <watermind> the you also have lazy evaluation (well non strict)
15:31:29 <monochrom> well, watermind, here is the thing. obtaining and using map, filter, etc is still possible in Java, via the Command pattern. therefore, this benefit of Haskell can be shoved under "oh Haskell just saves a few lines of code here".
15:31:32 <pozori> I know lazy evaluation too
15:32:14 <monochrom> in fact, have you seen my http://www.vex.net/~trebla/humour/Nightmare.java ? :)
15:32:54 <watermind> monochrom: looks interesting :/
15:32:58 <pozori> and what monochrom said is pretty much the core of my question. I'm trying to wrap my head around if functional programming makes some things available which are not doable in imperatives
15:33:24 <elliott> well, Java and Haskell are in the same computational class. at the end of the day, you can do the same things. the question is how you can do them and how easily.
15:33:27 <elliott> and how maintainably.
15:34:15 <sipa> it allows you to do things while forgetting details
15:34:37 <sipa> limiting the requirement of your attention to the problem being solved instead of implementation details
15:35:01 <sipa> that's what abstraction is about - not what you can (somehow) do
15:35:18 <watermind> pozori: depends on what you mean by "can do"
15:35:35 <pozori> "computational class" is a new concept for me.. explain like I'm 5 briefly
15:35:48 <elliott> the things they can compute are the same.
15:35:54 <pozori> aha ok
15:36:08 <elliott> at the end of the day it's all numbers. Haskell is not going to do something fundamentally more than Java, but it can be fundamentally *different*.
15:36:12 <Nisstyre-laptop> What is the difference between a refinement type and a type with a smart constructor?
15:36:20 <watermind> pozori: for instance parametric polymorphism in haskell... it gives you certain assurances about the behaviour of functions just from looking at the type
15:36:21 <elliott> (and the ways in which it is different can be beneficial to your programming.)
15:36:39 <watermind> pozori: e.g.   f :: a->a    you can be sure that it is either identity or undefined
15:37:29 <watermind> pozori:  g :: [a] -> [a]    it can only shuffle stuff, remove and duplicate
15:37:42 <pozori> ahh... somehow I have a feeling I need to master some imperative language before even looking at Haskell.. :(
15:38:02 <Clint> why
15:38:05 <watermind> pozori: lazy evaluation which I was getting too, it allows you to be more modular to in ways you can't be in java, not easily anyway
15:38:17 <pozori> Clint: for contrast
15:38:44 <sipa> pozori: i'm not sure about that - knowing an imperative language may shape your thinking in a certain way, which is hard to change afterwards
15:40:20 <watermind> pozori: for instance suppose you want to   suppose you want:  1) the n first primes     2) all primes smaller than K    3) all primes until the difference between two consecutive ones is 50
15:41:04 <watermind> pozori: in haskell you can make a program that generates the infinite list of primes, and then use it to implement 1) 2) and 3)
15:41:06 <monochrom> I am a counterexample to that. I had been an expert in imperative programming before I started learning functional. expert means I could prove imperative programs correct with ease.
15:41:10 <pozori> watermind: all that stuff was covered in the book and I understand how simple it is to just take a set formula and turn it into working code in Haskell.
15:41:42 <monochrom> guess what? all methods of proving imperative programs correct begin by converting them to functions. that's my ramp to functional programming.
15:41:46 <watermind> pozori: this was not about converting a formula to haskell, it was about modularity
15:42:24 <pozori> watermind: you mean piping of functions? yes, that is handy unix-style stuff and I appreciate it.
15:42:28 <watermind> monochrom: hoare logic / Dijkstra's Weakest Precondition ?
15:42:49 <monochrom> Dijkstra's is one, though it's a pretty high-order function :)
15:43:14 <watermind> what HO function are you seeing there?
15:43:33 <watermind> not sure what you mean...
15:43:36 <monochrom> a program is a function from predicates (postcondition) to predicates (precondition). forward sequential composition is backward function composition.
15:43:49 <watermind> right
15:43:56 <monochrom> prog :: (State -> Bool) -> (State -> Bool)
15:44:06 <watermind> yeap got it
15:45:14 <watermind> got a question by the way (whole different topic)
15:45:15 <monochrom> another method is more elementary, prog :: State -> State, it maps pre-state to post-state; and then you say, sometimes you want to allow non-determinism, so you s/function/relation
15:45:43 <watermind> Y :: (σ->σ)->σ
15:46:20 <monochrom> denotational semantics ends up also saying "a program is such-and-such function...". and then there are variations on the domain and co-domain
15:46:26 <watermind> if you want to construct say, a recursive first order function and restrict the argument of Y to be first order at most, do you lose anything?
15:47:40 <watermind> I actually wonder if first order functions in Y are enough to build any recursive function of any order
15:47:53 <watermind> it's difficult to find a counter example
15:50:36 <watermind> I searched for an answer but all I found was Gentzen's system T
15:50:45 <watermind> system T has very limited recursion
15:50:48 <monochrom> ok, factorial :: Nat -> Nat. if I want to use Y to get me factorial, I need Y :: ((Nat->Nat) -> (Nat->Nat)) -> (Nat->Nat). I need σ=Nat->Nat. So, this instance of Y is not first-order. but perhaps you mean, σ is first-order, that's the restriction you want to impose.
15:50:51 <watermind> more than what I'm suggesting
15:51:19 <watermind> monochrom: I mean restricting *the argument* of Y to be first order
15:51:24 <watermind> monochrom: not Y itself
15:52:03 <monochrom> then σ->σ = (Nat->Nat) -> (Nat->Nat) is 2nd-order
15:52:55 <watermind> true... let me look back at what I'm trying to do, got confused here
15:55:26 <watermind> ok sorry got confused... so my restriction is on the "stepping function", the sigma
15:56:04 <watermind> so Yσ : (σ->σ)->σ
15:56:26 <watermind> and I was wondering if having  Yσ  for first order σ is enough
15:56:29 <monochrom> alright, you allow σ=Nat->Nat and so I can get factorial. but now I have problems with map.
15:57:19 <watermind> let me check
15:57:41 <watermind> I get that you do, but I wonder if you can't rewrite it so you don't
15:57:45 <watermind> let me see
16:01:20 <watermind> monochrom: can't you just do map f = let map' step xs = ... in (Y map')
16:02:23 <watermind> map' assumes a fixed f
16:02:41 <monochrom> interesting
16:02:42 <watermind> so that lowers the order
16:03:20 <elliott> but maybe map wants to modify the function it gets as it goes along.
16:03:41 <watermind> ?
16:03:47 <elliott> well, ok, map doesn't.
16:03:51 <elliott> but a higher order function might.
16:03:53 <watermind> hmmm
16:03:56 <watermind> right
16:04:04 <watermind> continuation like stuff
16:04:06 <elliott> foo _ [] = []; foo p (x:xs) | p x = x : foo (not . p) xs | otherwise = foo p xs
16:04:08 <elliott> or such.
16:04:20 <startling> > foldr (.) id [(+ 1), (+ 2)]
16:04:21 <lambdabot>   <Integer -> Integer>
16:04:32 <elliott> and there you can replace the modification of the function with modification of a boolean parameter
16:04:44 <elliott> but you're getting into distinctly non-trivial territory there. what if instead of (not . p) it was (f p) where f is a parameter? etc.
16:05:04 <watermind> yes I get what you're saying
16:05:15 <elliott> (then you could use a natural, to track how many times you want to apply f. but now you're paying a performance cost at the very least)
16:05:33 <elliott> so, I don't actually know if it's possible to do it all "first-order"
16:05:42 <elliott> but I reckon you don't want to because it sounds painful :)
16:06:00 <startling> > foldr (.) (\(vs, f) g -> (f 0 : vs, f . g)) ([], id) [(+ 1), (+ 2)]
16:06:01 <lambdabot>   Couldn't match expected type `[((a0 -> b0) -> ([c0], a0 -> c0))
16:06:01 <lambdabot>            ...
16:06:34 <watermind> elliott: true
16:07:23 <watermind> and that is actually just part of the real question I've been wondering about which is:
16:08:15 <watermind> can I write any 2nd higher order function, without ever building a term of order > 2
16:08:32 <watermind> note Y is not a function though
16:09:01 <watermind> 2nd higher order/ 2nd order
16:09:22 <monochrom> oh! I know. defunctionalization says that you can always translate to first-order, and it is a pretty easy translation. you just need algebraic data types or equivalent.
16:10:09 <watermind> oh
16:10:25 <watermind> I was just looking at that again a while ago and it didn't even occur me
16:11:21 <elliott> ok, yes. as ever, monochrom is wise.
16:11:22 <watermind> monochrom: why do you need algebraic data types? isn't it just adding arguments, moving to upper level
16:12:36 <watermind> I'm not exactly sure if that answers the question though
16:13:21 <monochrom> I don't know what is "add arguments, move to upper level" like. the defunctionalization tutorial I read uses algebraic data types, and it's convenient, and I can see how to replace them by eg numbers, and I have to go.
16:13:21 <watermind> because in the end, I'm actually trying to build a 2nd order function
16:13:42 <watermind> monochrom: right, thanks see you
16:15:31 <gwern> ' When I turn my profiling code to look at the garbage collection phases, it gives me >98% time spent directly in evacuate, for whatever that's worth. If only I had a per-line profile now... :-) '  When I turn my profiling code to look at the garbage collection phases, it gives me >98% time spent directly in evacuate, for whatever that's worth. If only I had a per-line profile now... :-)
16:15:39 <gwern> http://hackage.haskell.org/trac/ghc/ticket/5505
16:15:48 <gwern> heisenlogging
16:16:46 <watermind> defunctionalization assumes a complete program in which you define a finite number of functions
16:17:27 <watermind> I want to actually buld a function that is 2nd order
16:43:34 <stevejb> greetings, I have a bit of a newbie question. I have a function of 4 arguments, and I want to "bake in" some of 2 of the arguments, returning a function of the remaining two arguments. What is the best way to go about this?
16:43:48 <stevejb> e.g. for yak_maker :: Double -> Double -> Double -> InputSt -> (Double -> Double -> Double)
16:43:49 <elliott> just apply it to them.
16:43:55 <elliott> (yak_maker pi 123)
16:44:10 <stevejb> how to I control which argument in the list it applies to?
16:44:14 <elliott> a -> b -> c actually means a -> (b -> c). every function takes one argument, it can just return another function if it wants "more arguments".
16:44:25 <elliott> well, it's always going to be the first two there.
16:44:31 <elliott> if you want to control e.g. the second and third, then
16:44:36 <elliott> (\yak1 -> yak_maker yak1 pi 123)
16:44:42 <elliott> (do you know lambda syntax?)
16:44:54 <stevejb> yeah I think so
16:45:13 <monochrom> watermind: perhaps a high-order Y cannot be implemented in terms of a low-order Y
16:48:09 <stevejb> sig my_InputSt
16:48:11 <stevejb> oops
16:55:50 <erisco> :t In
16:55:50 <lambdabot> f (Mu f) -> Mu f
17:04:23 <merijn> stevejb: Hell, you could even just define "defaultYak x y = ya_maker x 3 y 6" or something
17:04:36 <nerrz> how would I apply a list of functions of type (String -> String) to a string in such a way that each functions result is passed to the next function as the parameter?
17:04:41 <stevejb> merijn: thank you
17:04:59 <merijn> stevejb: In fact, defining common functions in terms of partially applied more general functions is a very common pattern in haskell
17:05:26 <merijn> nerrz: I'll take "What is fold?" for 300 :)
17:05:56 <stevejb> merijn: this is my first haskell project. I really appreciate the design help
17:06:03 <merijn> :t foldl
17:06:03 <lambdabot> (a -> b -> a) -> a -> [b] -> a
17:06:16 <merijn> :t foldl ($)
17:06:17 <lambdabot>     Occurs check: cannot construct the infinite type: b1 = b0 -> b1
17:06:17 <lambdabot>     Expected type: (b0 -> b1) -> b0 -> b0 -> b1
17:06:17 <lambdabot>       Actual type: (b0 -> b1) -> b0 -> b1
17:06:21 <merijn> hmm
17:06:24 <nerrz> it is a list of functions
17:06:39 <merijn> nerrz: Sure, so just use ($) to apply them
17:06:39 <monochrom> foldl (.) id fs xs
17:06:41 <merijn> :t foldr
17:06:42 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:07:01 <merijn> Yeah, I guess (.) is simpler
17:07:05 <monochrom> it can also be foldr
17:07:06 <nerrz> ahh, thank you
17:07:12 <stevejb> :load
17:07:38 <merijn> nerrz: The beauty of parametric polymorphism is that it doesn't care whether your listen contains functions or something else :)
17:08:40 <nerrz> thank you for the help
17:12:28 <merijn> If I have portable code, except for one optional module (MPTC, FunDeps, Undecidable+Flexible Instances), should I just conditionally export that when compiled with GHC or should I check for a specific version of GHC that introduced extensions?
17:12:48 <merijn> (Or, third option, pretend like there's not other compilers and always export)
17:14:47 <watermind> monochrom: it probably can't... it just isn't obvious that it's impossible, but more importantly it isn't obvious how far we could go
17:15:17 <watermind> monochrom: e.g. would 1st order Y be enough for at least all recursive 2nd order functions
17:15:55 <watermind> not obvious to me anyway
17:19:02 <stevejb> I have a question on shown here https://gist.github.com/stephenjbarr/ae49dea79d66c4284ebb
17:20:20 <monochrom> merijn: even base itself has #ifdef's that disables certain functions for non-GHC. so I think it's reasonable to disable that module for non-GHC, and it's even better to disable for old GHCs if you have time to find out
17:21:00 <enthropy> stevejb: you should do something like    h y = fst $ quad (flip f y) (g1 y) (g2 y)
17:21:03 <merijn> monochrom: I don't know where to find out when it was introduced, though
17:21:31 <stevejb> enthropy: thank you, I will give that a try
17:21:35 <enthropy> stevejb: but maybe you're better of transforming the 2D integral into 1D since that'll make your error estimate more realistic
17:21:47 <merijn> Also, I'm not sure whether "assume no one but GHC implements things" is the right approach. I'd say that cabal should provide a tool to check for extension existence, but I'm to afraid of accidentally volunteering :p
17:21:54 <monochrom> perhaps enable for all GHCs, then upload a new version to refine the conditions when you receive a bug report "it fails on my vintage GHC 4.6!"
17:22:01 <stevejb> enthropy: I am doing integrals over fairly smooth functions so I am not terribly worried
17:22:14 * monochrom has, in fact, vintage 4.08!
17:22:18 <merijn> monochrom: Yeah, I was thinking that too, I'll probably go with that
17:22:20 <stevejb> enthropy: specifically, integrals over a normal probability density function
17:23:21 <monochrom> the good old days when GHC's source tree was called "fptools"
17:23:31 <merijn> ok, bed time, I'll procrastinate the package description until tomorrow
17:24:49 <monochrom> just say "Whee." in the package description. see for example http://hackage.haskell.org/package/critbit
17:25:02 <elliott> haha
17:26:03 <merijn> Right now I have "This package provides "
17:26:15 <elliott> This packages provides whee.
17:26:22 <monochrom> yes
17:27:42 <elliott> in two years the critbit description will be "Production-ready whee based on overloaded numeric whee methods. Benchmarks against five other whee are available." followed by a UML diagram where "Whee" connects to four other "Whee" of different colours, each with "Whee" inside them
17:29:30 <merijn> That is where I decided "fuck it, I hate writing descriptions, I'll put it off"
17:30:53 <monochrom> description: This package provides the modules listed below
17:31:28 <elliott> this package provides functionality
17:31:53 <monochrom> {- | This module fulfills the package description. -} module Foo where ...
17:31:56 <startling> this package.
17:33:21 <monochrom> description: The module descriptions are false.
17:33:23 <merijn> "Placeholder package description."
17:33:34 <monochrom> {- | The package description is false. -} module Foo where ...
17:34:03 <merijn> monochrom: Actually, I already wrote a bunch of module descriptions and documentations! It took a lot of willpower and stuff, but I managed!
17:35:09 <monochrom> ok, all you need to do now, is to muster a bit of logic power to write: description: The module documentation is false. :)
17:35:15 <elliott> Data.Align remains my finest documentation moment
17:36:38 <merijn> elliott: FWIW, I love the function name "malign"
17:37:08 <elliott> I think that one wasn't my invention :)
17:37:10 <monochrom> which package is that?
17:37:36 <elliott> these
17:38:30 <merijn> anyhoo, sleep
17:47:45 <dmwit> Now I kind of want to release a package named Acme::Whee with no code but pages and pages of documentation.
17:49:59 <startling> hmm, I kinda want to have data Expression r = Identifier r | Lambda (Expression (Maybe r))
17:50:44 <dmwit> You might like: GADTs
17:50:59 <startling> how would GADTs help there?
17:51:12 <dmwit> Your variables can be typed.
17:51:18 <dmwit> Turn your type-level numeral into a type-level list, baby!
17:51:25 <startling> not sure what you mean.
17:51:49 <dmwit> Right now, you have a type-level number, which ensures that your variables can't have an index bigger than the size of the environment, right?
17:52:16 <startling> I guess you could say that.
17:52:27 <elliott> the nice thing about the nested type version is that you can make it a Monad
17:52:36 <dmwit> Okay. Well, instead of a type-level Peano number, each succ in the peano number could have a type associated with it.
17:52:52 <dmwit> So that all values of that type "know" which type of variable is in the environment at that position.
17:52:56 <startling> dmwit: oh, I see.
17:53:09 <startling> I don't think that's that useful, though
17:53:33 <dmwit> Well, it lets you abuse GHC's type checker as a type-checker for your typed lambda calculus.
17:53:45 <dmwit> Some might say that not having to implement a type inference engine is useful. =)
17:54:01 <startling> dmwit, heh
17:54:27 <Philippa> dmwit: I'm not entirely in that crowd, but I'm *picky* :p
17:54:56 <Philippa> (also, y'know, been doing it for a decade so I'm allowed to be cranky and opinionated about it)
17:55:02 <dmwit> Sure.
17:55:12 <dmwit> But when I see somebody who doesn't know the trick, I figure I ought to point it out. =)
17:55:28 <elliott> hmm, I wonder if the (Nat -> *) term representation is one of those relative monad thingies.
17:55:36 <elliott> given that the (* -> *) version is a regular old monad.
17:55:37 <startling> let x = y in z is semantically the same as (\x -> z) y, right?
17:56:00 <dmwit> Depends on your semantics.
17:56:05 <elliott> you get Term m -> (Fin m -> Term n) -> Term n, I guess.
17:56:07 <dmwit> Some might ask that the former do more sharing than the latter.
17:56:07 <dolio> elliott: The problem is that the Nat -> * version isn't structured the same way.
17:56:08 * tabemann remembers people used lambdas like that in lisp before they introduced let
17:56:11 <startling> dmwit: I mean haskell
17:56:20 <elliott> I don't know if that's what relative monads get you because I never bothered reading what they actually are.
17:56:22 <dmwit> Well, there isn't really a semantics for Haskell. =)
17:56:29 <Nisstyre-laptop> tabemann: how long did it take to introduce let? O_o
17:56:44 <elliott> startling: the former is more permissive about typing
17:56:48 <dmwit> But for Haskell, the difference between those is in typing.
17:56:52 <dmwit> ...as elliott is pointing out.
17:56:55 <Nisstyre-laptop> tabemann: how old are you if you don't mind me asking?
17:56:59 <elliott> no no, dmwit is pointing it out.
17:57:03 <startling> dmwit, elliott, how so?
17:57:06 <elliott> I just thought "oh, good, I don't have to"! you can't take that away from me.
17:57:13 <tabemann> Nisstyre-laptop, I'm 28, but I've done a lot of reading
17:57:14 <dolio> Like, in Bound, your free variables go in the parameter.
17:57:18 <Nisstyre-laptop> tabemann: ah okay
17:57:23 <elliott> dolio: right.
17:57:25 <dmwit> > let x = 1 in (x / 2, x `div` 2)
17:57:26 <lambdabot>   (0.5,0)
17:57:35 <dmwit> > (\x -> (x / 2, x `div` 2)) 1
17:57:36 <Nisstyre-laptop> tabemann: because at least SICP mentions let as a lambda macro
17:57:36 <lambdabot>   No instance for (GHC.Show.Show t0)
17:57:36 <lambdabot>    arising from a use of `M982465322.sho...
17:57:38 <elliott> dolio: I'm thinking solely of the use of the (* -> *) form where you only ever pass in Maybe^n Void.
17:57:43 <startling> dmwit, oh, got it
17:57:52 <elliott> which is what you get if you just treat it as a strictly de bruijn term representation or whatever.
17:57:53 <Nisstyre-laptop> or I think it does
17:57:56 <dolio> But in the Nat-indexed version, you need a separate free variable parameter.
17:58:01 <dmwit> ...I'm very glad. That was sort of a tongue-in-cheek explanation. =P
17:58:11 <dolio> Or you use Fin n as your free variables, which sucks.
17:58:17 <tabemann> Nisstyre-laptop: but I remember reading that for a very good period in the days of Maclisp they basically did that for lack of a built-in let
17:58:24 <Nisstyre-laptop> tabemann: no macros?
17:58:27 * elliott is all about the things that suck.
17:58:45 <tabemann> Nisstyre-laptop: they had those
17:59:11 <dolio> It is a relative monad, though.
17:59:32 <Nisstyre-laptop> tabemann: I think in pretty much every lisp, let is desugared to a lambda
17:59:38 <Nisstyre-laptop> whether or not it is a user defined macro
17:59:40 <dolio> Normally I'm down on nested types. But I really think they're better for this.
18:00:17 <tabemann> I thought Scheme had a built-in let
18:00:17 --- mode: ChanServ set +o monochrom
18:00:21 <elliott> is it as simple as a relative monad is (M : C -> Hask) where you have (F : C -> Hask) and then return is (F A -> M A) and bind is (M A -> (F A -> M B) -> M B)?
18:00:25 --- mode: monochrom set -q $a:S_J
18:00:28 <elliott> I should read the paper.
18:00:35 <dolio> Yes, it is that simple.
18:00:36 <Nisstyre-laptop> tabemann: I doubt it, there's no need for it to be in the core language
18:00:38 --- mode: monochrom set -o monochrom
18:00:48 <Nisstyre-laptop> tabemann: to be clear, I don't mean the language not having it defined
18:00:54 <Nisstyre-laptop> I mean let being in the core language or not
18:00:54 <elliott> dolio: cool.
18:00:58 <Nisstyre-laptop> what everything desugars to
18:03:18 <tabemann> wouldn't having a core-implemented let allow you to optimize it better than implementing it as a macro in terms of lambda (which would mean having to recognize that such a lambda can be optimized away)?
18:18:37 <watermind> monochrom: actually it should be possible to write any n-order function using 1st order Y  (not considering infinite data structures anyway)
18:20:13 <watermind> monochrom: there's a way to encode any function as a 1st order function, if you use some sort of non local control operator (e.g. local exceptions)
18:20:49 <watermind> monochrom: we don't have that but, _decoding_ doesn't need any non-local control operator
18:21:06 <watermind> monochrom: so in theory we could just build the encoded function and decode it
18:21:36 <watermind> unless I'm missing something, but I don't think so
18:24:26 <bb010g> test
18:25:13 <bb010g> @pl \a b -> b a
18:25:13 <lambdabot> flip id
18:25:50 <Aetherspawn> @pl \x x y x -> x y x x
18:25:53 <lambdabot> const (const (join . flip ap id . flip id))
18:25:53 <lambdabot> optimization suspended, use @pl-resume to continue.
18:26:05 <erisco> @pl-resume
18:26:06 <erisco> do it! :D
18:26:11 <lambdabot> const (const (join . flip ap id . flip id))
18:26:11 <lambdabot> optimization suspended, use @pl-resume to continue.
18:26:12 <Aetherspawn> @pl-resume
18:26:24 <lambdabot> const (const (join . flip ap id . flip id))
18:26:24 <lambdabot> optimization suspended, use @pl-resume to continue.
18:26:44 <bb010g> @pl \a b c d e f g -> a (b c) ($e) (g f)
18:26:47 <lambdabot> ((const .) .) . flip flip (flip id) . (flip .) . ((flip .) .) . ((((.) .) .) .) . ((((.) .) .) .) . flip flip (flip id) . (flip .) . (((.) .) .) . (.)
18:26:47 <lambdabot> optimization suspended, use @pl-resume to continue.
18:27:06 <erisco> mmm that is some fine Haskell
18:27:32 <Aetherspawn> hslisp
18:27:35 <bb010g> @pl \f x -> f (f x)
18:27:35 <lambdabot> join (.)
18:27:44 <bb010g> @pl \f x -> f (f (f x))
18:27:44 <lambdabot> ap (.) (join (.))
18:27:52 <bb010g> @pl \f x -> f (f (f (f x)))
18:27:52 <lambdabot> ap (.) (ap (.) (join (.)))
18:28:24 <bb010g> Looks like the Church numerals can be represented as repeated ap (.) on join (.). Weird.
18:34:09 <startling> does trifecta/parsers have anything for infix operators?
18:34:17 <bb010g_> @help
18:34:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:35:01 <bb010g_> @help karma
18:35:01 <lambdabot> karma <polynick>. Return a person's karma value
18:35:51 <bb010g_> @pf \in `g` f -> f in
18:35:51 <lambdabot> Maybe you meant: pl bf
18:35:58 <bb010g_> @pl \in `g` f -> f in
18:35:58 <lambdabot> (line 1, column 4):
18:35:58 <lambdabot> unexpected reserved word "in"
18:35:58 <lambdabot> expecting pattern
18:36:09 <bb010g_> @pl \a `g` f -> f a
18:36:09 <lambdabot> (line 1, column 4):
18:36:09 <lambdabot> unexpected "`"
18:36:09 <lambdabot> expecting operator, pattern or "->"
18:36:26 <bb010g_> @pl \a f -> f a
18:36:27 <lambdabot> flip id
18:36:39 <dmwit_> ?pl a `g` f = f a
18:36:39 <lambdabot> (line 1, column 10):
18:36:39 <lambdabot> unexpected " "
18:36:51 <dmwit_> I don't think ?pl knows what to do with backticks. =)
18:37:54 <Aetherspawn> uh
18:38:01 <Aetherspawn> `cabal install ltk` has a haskell error in it
18:38:17 <Aetherspawn> src/Text/PrinterParser.hs:230:42: Not in scope: `catch'
18:39:00 <monochrom> that may be old code. Prelude had catch, but not anymore
18:39:33 <external-reality> Is there a name for a Set with an limit on the number of elements it may contain?
18:40:51 <Aetherspawn> monochrom: damn. How recent was it removed?
18:41:27 <bb010g_> @help djinn
18:41:27 <lambdabot> djinn <type>.
18:41:27 <lambdabot> Generates Haskell code from a type.
18:41:27 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:42:09 <bb010g_> @djinn a -> (a -> b) -> b
18:42:09 <lambdabot> f a b = b a
18:42:57 <bb010g_> @djinn a -> (b -> c) -> (c -> a) -> d -> (a,c)
18:42:57 <lambdabot> -- f cannot be realized.
18:43:04 <bb010g_> @djinn a -> (b -> c) -> (c -> a) -> d -> (a -> c)
18:43:04 <lambdabot> -- f cannot be realized.
18:43:05 <tac> @djinn Not (Not (Either (Not a) a))
18:43:05 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
18:43:37 <bb010g_> @djinn a -> (b -> c) -> (c -> a) -> d -> (a -> c) -> d
18:43:37 <lambdabot> f _ _ _ a _ = a
18:43:41 <tac> @djinn Not (Not (Not a)) -> Not a
18:43:41 <lambdabot> f a b = void (a (\ c -> c b))
18:44:32 <bb010g_> @djinn Left (Right (Just b) -> Left b
18:44:32 <lambdabot> Cannot parse command
18:44:38 <bb010g_> @djinn Left (Right (Just b)) -> Left b
18:44:38 <lambdabot> Error: Undefined type Left
18:44:41 <monochrom> Aetherspawn: it was deprecated since 7.2, August 2011
18:45:01 <mm_freak_> external-reality: "Set with a limit" alone is not well-defined
18:45:14 <bb010g_> @help more
18:45:14 <lambdabot>  @more. Return more output from the bot buffer.
18:45:36 <Aetherspawn> Ah, well, starred the issue in the leksah trac
18:45:41 <Aetherspawn> I hope it gets fixed soon..
18:46:37 <bb010g_> @unpl flip ($ (. >>=) id ((.)$(.))
18:46:38 <lambdabot> <unknown>.hs: 1: 12:Parse error: >>=
18:46:49 <bb010g_> @unpl flip ($ (. (>>=)) id ((.)$(.))
18:46:49 <lambdabot> <unknown>.hs: 1: 31:Parse error: EOF
18:47:02 <bb010g_> @unpl flip ($ (. (>>=))) id ((.)$(.))
18:47:03 <lambdabot> (\ k l -> (>>=) (k l))
18:47:30 <bb010g_> @unpl flip ($ (. (join $))) id ((.)$(.))
18:47:30 <lambdabot> (\ l m -> (l m) >>= \ n -> n)
18:47:54 <bb010g_> @unpl >>=
18:47:54 <lambdabot> <unknown>.hs: 1: 1:Parse error: >>=
18:47:58 <bb010g_> @unpl (>>=)
18:47:58 <lambdabot> (>>=)
18:48:09 <bb010g_> @unpl join
18:48:09 <lambdabot> (\ b -> b >>= \ a -> a)
18:49:22 <bb010g_> @help pointfull
18:49:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:49:30 <bb010g_> @help pointful
18:49:31 <lambdabot> pointful <expr>. Make code pointier.
18:50:56 <bb010g_> @pl \a d z e o f x e q n m -> (o x q) (m a) a (x f) (d z f m)
18:50:59 <lambdabot> ((const .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (.) . flip . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . ((.) .) . (ap .) . ((flip .) .) .
18:50:59 <lambdabot>  (((flip .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . (((.) .) .)) . flip id) id) (flip id)
18:50:59 <lambdabot> optimization suspended, use @pl-resume to continue.
18:51:09 <bb010g_> @pl-resume
18:51:15 <lambdabot> ((const .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (.) . flip . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . ((.) .) . (ap .) . ((flip .) .) .
18:51:15 <lambdabot>  (((flip .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . (((.) .) .)) . flip id) id) (flip id)
18:51:15 <lambdabot> optimization suspended, use @pl-resume to continue.
18:51:20 <bb010g_> @pl-resume
18:51:32 <lambdabot> ((const .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (.) . flip . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . ((.) .) . (ap .) . ((flip .) .) .
18:51:32 <lambdabot>  (((flip .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . (((.) .) .)) . flip id) id) (flip id)
18:51:32 <lambdabot> optimization suspended, use @pl-resume to continue.
18:51:51 <bb010g_> @help pl-resume
18:51:51 <lambdabot> pl-resume. Resume a suspended pointless transformation.
18:53:25 <Aetherspawn> "pointless transformation" lol
18:55:34 <Aetherspawn> where are the haskell sources for packages located?
18:55:40 <bb010g_> @unpl ((const .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (.) . flip . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . ((.) .) . (ap .) . ((flip .) .) . (((flip .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . (((.) .) .)) . flip id) id) (flip id)
18:55:40 <lambdabot> (\ db gk gn _ gw gz hc _ hu _ -> ((gk gn) >>= \ dr -> return ((\ ie y z ae -> (return ((\ jl az ba bf -> return ((\ fp bk bl bo bs bx -> bl bo bs (bx fp) bk) db ((\ cu -> cu) db)) db gw jl ba bf az)
18:55:40 <lambdabot> z ((\ cx -> cx ie) z)) z ae) >>= \ eh -> y >>= \ eg -> return (eh eg)) gz dr)) gz hc hu)
18:55:51 <monochrom> hackage has a lot of sources
18:56:00 <Aetherspawn> I mean after they are downloaded, locally
18:56:03 <Aetherspawn> leksah wants to know
18:56:25 <monochrom> explore $HOME/.cabal/packages
18:56:33 <Aetherspawn> ah, thanks
19:07:43 <bb010g_> Can you define a right-associtive operator?
19:07:51 <joelteon> are services down?
19:08:52 <monochrom> seems yes
19:09:19 <monochrom> use infixr to make an operator right-associative
19:13:09 <copumpkin> bb010g_: sure
19:26:32 <bb010g_> If you let (|.) be a left-associative operator defined as (flip id), why does ("potato" |. length |. (+2) |. sum . (:[2]) |. show) fail?
19:28:18 <bb010g_> Why do (|.) and (.) conflict?
19:28:59 <erisco_> same precedence?
19:29:14 --- mode: calvino.freenode.net set +o ChanServ
19:29:43 <bb010g_> Should I turn down (|.) to 8?
19:30:23 <enthropy> if anything it makes sense to have it closer to 0 just like $ is
19:31:41 <joelteon> so comma *or* newline is a separator in .cabal files? that's neat
19:32:53 <bb010g_> ghci is giving me "parse error on input `infixl'" when I put in infixl 0 |.
19:33:07 <joelteon> yeah, ghci doesn't do infix declarations
19:33:12 <bb010g_> Ah.
19:34:04 <joelteon> oh, never mind
19:36:23 <bb010g> Loading in from a temporary .hs file works.
19:51:22 <frankbro> Can you redefine show the a list of type?
19:52:15 <frankbro> -the+for
19:52:50 <elliott> you can actually overload how [A] is shown in the Show instance for A, yes.
19:52:53 <elliott> though it may be unwise.
19:52:57 <elliott> simply define showList.
19:53:46 <frankbro> elliott, oh wow wasn't aware of that, it's perfect, thanks
19:54:02 <elliott> just don't expect it for any other container :)
20:08:25 <jmcarthur> my understanding of the other-extensions field in cabal files is that, unlike the extensions field, it doesn't cause cabal to enable the listed extensions for all modules. is this correct?
20:08:45 <dcoutts_> jmcarthur: correct
20:09:06 <jmcarthur> because i have found that on my machine it appears to meet my expectations, but on somebody else's machine it seems to be adding at least one of the extensions to the build for at least one of the modules in the project
20:09:36 <dcoutts_> jmcarthur: the old 'extensions' field has been split into default-extensions and other-extensions
20:10:03 <dcoutts_> jmcarthur: default-extensions has the same behaviour as the old extensions field, and other-extensions is as you described.
20:10:26 <jmcarthur> dcoutts_: https://github.com/haskell-game/graphics/blob/master/graphics.cabal has extensions only listed in other-extensions at all, but on alpounet's machine you have to add {-# LANGUAGE NoCPP #-} to the top of Game.Graphics.Triangles, otherwise the build is broken
20:11:07 <jmcarthur> dcoutts_: (because apparently CPP is incompatible with multiline haskell strings)
20:11:43 <dcoutts_> jmcarthur: yes you would have to add language pragmas to enable the extensions in specific modules
20:12:07 <jmcarthur> that's my expectation, but not what i'm observing (on alpounet's machine, at least)
20:12:17 <jmcarthur> dcoutts_: note that I said NoCPP, not CPP
20:12:28 <jmcarthur> dcoutts_: other-extensions lists CPP
20:12:33 <dcoutts_> oh
20:13:16 <dcoutts_> well, you can see, run with -v and see how cabal calls ghc
20:13:18 <jmcarthur> the thing i find confusing is that it seems to work fine for me (and indeed breaks if i add CPP to that module)
20:13:41 <dcoutts_> jmcarthur: yes I expect it to work the way I described
20:13:54 <jmcarthur> dcoutts_: alpounet told me that it was apparently not adding -XCPP to the ghc line
20:14:05 <jmcarthur> which confused me more
20:14:08 <dcoutts_> right
20:14:21 <dcoutts_> it shouldn't add -XCPP, but then the NoCPP should not be needed
20:14:33 <dcoutts_> because nothing else should be turning on cpp
20:14:40 <jmcarthur> does it sound like it might be a ghc bug of some sort? cabal just invokes ghc once, right?
20:15:04 <dcoutts_> jmcarthur: more than once, but you can see just what it does with -v
20:15:07 <jmcarthur> ah shoot, i should have had alpounet try the build without CPP in the other-extensions field
20:15:13 <jmcarthur> ah
20:15:26 <jmcarthur> well, then i guess if it didn't show up at all then i really don't know what's going on
20:15:39 <dcoutts_> jmcarthur: aye, would need more details
20:16:03 <jmcarthur> alright, thanks
20:41:20 <tabemann> hmm... why would NickServ be down?
20:42:29 <tgeeky> tabemann: /whois NickServ
20:42:43 <tgeeky> tabemann: still up for me?
20:43:10 <tgeeky> tabemann: i was gonna say netsplit, but I didn't see one
20:43:23 <elliott> I have no NickServ.
20:43:28 <elliott> I think it depends on the server you are on.
20:43:35 <tgeeky> elliott: that should not be?
20:43:51 <elliott> whether it should or shouldn't be, it is
20:44:10 <joelteon> very wise, elliott
20:44:16 <tgeeky> elliott: hehe. Yes, There is a hidden netsplit.
20:45:12 <tabemann> as least NickServ won't immediately change my nick when it comes back on for me - the NickServ here doesn't seem quite as... aggressive as some elsewhere
20:50:23 --- mode: calvino.freenode.net set +o ChanServ
20:57:07 <hpaste> stolaruk pasted “Lazy I/O” at http://paste.tryhaskell.org/90684
20:57:46 <stolaruk> I have a couple newbie questions about lazy I/O. Could someone please take a look at my paste? My questions are in the paste.
20:58:42 <tabemann> hmm
20:58:56 <tabemann> I think it's that putStr is trying to evaluate its input
20:59:12 <tabemann> and it's only able to evaluate part of it at a time, which turns out to be a line at a time due to line buffering
20:59:23 <tabemann> so until you enter the line "Hello"
20:59:39 <tabemann> it can't get anything, and then it evaluates up until the end of the line
20:59:54 <tabemann> where then it's stuck until you enter "world"!
21:00:06 <tabemann> where then it is able to evaluate that list
21:00:29 <tabemann> with putStr outputting the parts of the list as it evaluates them, rather than requiring to reach end of list before it outputs anything as you might assume
21:01:31 <stolaruk> Ok, so it's a "line buffering" specification that defines this behavior
21:01:48 <tabemann> you can change the buffering if you want
21:02:00 <stolaruk> oh really?
21:02:35 <tabemann> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering
21:02:49 <u_> in leksah, does a gray arrow mean tab or something?
21:03:17 <stolaruk> tabemann: wow, cool!
21:03:25 <hamishmack> u_: Yes
21:03:50 <u_> > words "1\t2"
21:03:51 <lambdabot>   ["1","2"]
21:03:54 <u_> ah good
21:04:04 <stolaruk> tabemann: My statement in the first question is correct, right?
21:05:24 <tabemann> basically yes; due to lazy IO, the actual IO carried out by the value returned in IO String by getContents is not carried out until the list is evaluated, and then it is only carried out as far as the list is evaluated
21:06:21 <stolaruk> tabemann: Awesome! Thanks for your help!
21:06:51 <u_> ah but it throws a fit if it finds one in a literal anyway
21:09:13 <Aetherspawn-> does anyone use eclipseFP
21:09:25 <Aetherspawn-> is there an alternative to the huge black box with white text when you hover something in ctrl+space ?
21:10:03 <tabemann> sorry, emacs user here
21:10:17 <mgaogw> anyone remember how long it took to install haskell-platform with homebrew? i've been on "make install" for a couple minutes
21:10:31 <tabemann> (I use Eclipse at work, and it annoys me, but oh well)
21:10:46 <Aetherspawn-> Which reminds me, there isn't a haskell platform for ubuntu 13.04 yet
21:10:57 <tabemann> a couple minutes for a make install is nothing for anything nontrivial...
21:11:17 <Aetherspawn-> I had to install ghc, cabal-install, then cabal install cabal-install then manually patch the /usr/bin with the ~/.cabal/bin one otherwise the old cabal was causing buildtools problems..
21:11:48 <mgaogw> Aetherspawn -> where you installing over an old installation of haskell?
21:11:53 <Cale> Aetherspawn-: I don't trust Ubuntu to get anything Haskell-related right.
21:12:02 <Aetherspawn-> no, fresh ubuntu 13.04
21:12:09 <Aetherspawn-> but theres no haskell-platform on apt
21:12:12 <Aetherspawn-> for 13.04
21:12:59 <monochrom> instead of patching /usr/bin, you could have just apt-get remove cabal-install
21:13:03 <mgaogw> so i'm an osx user, should i try brew install ghc and brew install cabal-install, as opposed to brew install haskell-platform?
21:13:17 <Aetherspawn-> monochrom: but then other users cant use cabal
21:13:26 <Cale> Yeah, I'd just grab the GHC generic linux binary, and then the cabal-install tarball from hackage, and run the bootstrap.sh script from that, and that should result in a reasonable setup... editing ~/.cabal/config to produce profiling and documentation is a good idea too though.
21:13:29 <Aetherspawn-> and if I delete my .cabal one day, I'll lose my cabal to bring it back
21:13:52 <monochrom> cp it to /usr/local/bin
21:13:57 <ion> FWIW, this is how i always install GHC and Cabal. https://gist.github.com/ion1/2815423
21:14:16 <ion> (On systems including Ubuntu)
21:14:17 <Aetherspawn-> thats probably a better idea
21:14:37 <monochrom> in fact, earlier, you could have cabal install --global --root-cmd=sudo cabal-install. it would land in /usr/local/bin automatically
21:14:48 <mgaogw> ok - so to try and remove what's been partially downloaded from home-brew should I just manually remove stuff?
21:15:01 <Aetherspawn-> can I reinstall it in global
21:15:10 <Aetherspawn-> and will it remove from local automatically?
21:15:21 <monochrom> there is no automatic removal
21:15:49 <ion> If you delete .cabal, you can reinstall it trivially. I tend to do that whenever upgrading GHC anyway.
21:15:52 <monochrom> at this point, cp to /usr/local/bin is the least trouble
21:16:28 <Aetherspawn-> aw shit I didn't cp I mv'd.
21:16:39 <monochrom> oh, same difference
21:16:52 <Aetherspawn-> Looks like I have a second chance at getting this right :P
21:16:55 <Aetherspawn-> I'll try the global installation
21:17:21 <ion> I find it a good thing that you can purge the entire thing out of existence with a single rm -fr .ghc .cabal :-)
21:17:49 <dmj> can you use /Library/Haskell/bin/uninstall-hs ?
21:17:58 <dmj> I'm unsure if that's OSX only
21:18:05 <monochrom> I don't have it
21:18:12 <ion> /Library is an OSX thing.
21:18:21 <dmj> ah
21:19:47 <johnw> ion: and NeXTsep, let's not forget
21:20:03 <ion> :-)
21:22:53 <ion> It’s sad developers flocked to GNOME and ignored GNUstep.
21:23:20 --- mode: calvino.freenode.net set +o ChanServ
21:28:45 <Aetherspawn-> I know this isn't the linux help channel, but I've got cabal in /usr/local/bin and when I do /usr/local/bin/cabal --version it works but just typing "cabal --version" gives "bash: /usr/bin/cabal: No such file or directory" and my path looks like "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/kyle/.cabal/bin" -- I'm not really sure what's going on... it should search /usr/local/
21:28:47 <Aetherspawn-> bin, no?
21:29:49 <Aetherspawn-> Eh, nevermind. Restarting the session solved it. Some wierd caching issue with bash maybe.
21:30:33 <monochrom> hash -r
21:31:20 <Aetherspawn-> Oh, cool.
21:31:49 <Aetherspawn-> Pity hash is taken.
21:31:55 <Aetherspawn-> It'd be a cool name for bash written in hs.
21:32:06 <monochrom> haha
21:32:41 <tabemann> I'm not sure why one would *want* to rewrite bash itself... but I can definitely see the need for a shell written in Haskell
21:32:43 <tabemann> maybe hssh
21:33:57 <Aetherspawn-> maybe hush? Haskell User Shell?
21:34:17 <tabemann> oh hssh is also taken
21:34:56 <tabemann> hush is also taken
21:35:13 <tabemann> hsh is *also* taken
21:35:18 <Aetherspawn-> hsfi... a remake of fish in haskell ;__;
21:35:19 * Aetherspawn- cry
21:35:50 <Aetherspawn-> (fish being a lua-powered shell)
21:36:15 <tgeeky> I thought it was C or C++
21:36:30 <tabemann> well typically lua is embedded in C or C++
21:36:53 <Aetherspawn-> The shell itself probably is, but most the plugins are lua
21:37:22 <tgeeky> I just remember a lot of segfaulting last time I tried it. :o
21:37:23 <Aetherspawn-> (Which I think even includes the default tab completion and most of the default features)
21:37:27 <Aetherspawn-> lol
21:38:19 <ion> hssh would be a confusing name for a shell, it sounds more like something ssh-related. :-)
21:38:24 * monochrom recommends tchsh: type-checked hashell shell
21:38:31 <ion> monochrom: :-D
21:39:25 <Aetherspawn-> wtsh, pronounced "whatshell", or well-typed shell :)
21:39:27 <ion> Actually, hashell would be a great name.
21:39:56 <monochrom> a typo that happens to be a great name :)
21:46:24 <johnw> maybe call it "pure"
21:49:48 <Aetherspawn> pureshell, push, but it's probably already taken.
21:50:02 <johnw> or the opposite, "effects"
21:50:03 <johnw> anyway
22:02:00 <startling> is there a nice way to turn a Map into an arbitrary structure by specifying what keys you want? bonus points if a) it's just Applicative, and b) it'll error on Maps containing more keys than the ones specified.
22:09:01 <mm_freak_> startling: could you give an example?
22:09:44 <Aetherspawn> is there a pure hash structure that doesn't require IO for lookup
22:09:51 <Aetherspawn> but is still very performant for 1 lookup?
22:12:57 <mm_freak_> Aetherspawn: see the unordered-containers package
22:13:04 <mm_freak_> HashMap and HashSet
22:13:13 <startling> mm_freak_, I'd like to do something like runSomething myMap $ (,) <$> get "a" <*> get "b"
22:13:39 <startling> and get a Maybe (a, a) where myMap is a Map String a
22:14:38 <copumpkin> you can do that just using the function applicative
22:15:14 <startling> copumpkin, nuh-uh
22:15:20 <startling> the Maybes don't get lifted
22:15:26 <Aetherspawn> :t map_
22:15:27 <lambdabot>     Not in scope: `map_'
22:15:27 <lambdabot>     Perhaps you meant one of these:
22:15:27 <lambdabot>       `mapM' (imported from Control.Monad.Writer),
22:15:34 <copumpkin> oh
22:16:03 <copumpkin> :t liftM2 (,) <$> M.lookup "a" <*> M.lookup "b"
22:16:03 <lambdabot> M.Map [Char] a -> Maybe (a, a)
22:16:18 <startling> oh, interesting
22:16:58 <startling> the other thing I'd like is to be able to tell in advance all the keys this kind of action requires and error if it's applied to a map with extra keys.
22:17:47 <monochrom> if you get Nothing, you know that at least one key is not found
22:17:52 <startling> :r:r
22:17:58 <monochrom> err, nevermind, misread
22:22:35 <mm_freak_> startling: note that this is Maybe-applicative, not Map-applicative
22:23:00 <Moggle_> i hope this cross-compiling business works out well with webkitgtk, I think I've spent almost 4 hours on this. :(
22:23:18 <Moggle_> gtk2hs is a harsh mistress.
22:23:30 <startling> mm_freak_: sure.
22:23:57 * finishingmove gets whipped by gtk2hs
22:25:05 <mm_freak_> startling: if you need a semi-applicative interface to Map itself, have a look at the semigroupoids package
22:25:53 <mm_freak_> in particular Data.Functor.Apply
22:30:50 * tabemann wonders whether he should use this one integer sqrt he overlooked in Haskell's Delight as, in Haskell at least, it's *really* fast
22:31:22 <tabemann> (in C against floating-point square root on AMD64 it seems to be about as fast or a bit slower)
22:32:11 <tabemann> s/Haskell's/Hacker's
22:55:46 <startling> did I invent this? https://gist.github.com/startling/5932234
23:05:05 <ion> startling: What do you use it for?
23:05:16 <johnw> startling: that sort of looks isomorphic to "Product (Const (Set k)) ((->) v)", if you use a newtype to mappend over the Set in <*>
23:05:51 <johnw> it's just that here the applicative algebra is represented in an ADT
23:07:25 <Moggle_> Real World Haskell says "Furthermore, the garbage collector used by GHC as of version 6.8.3 is single threaded: it pauses all other threads while it runs, and executes on one core. This limits the performance ", is this still true as of GHC 7.6.3?
23:07:33 <startling> ion, checking ahead-of-time whether files or map keys exist
23:08:16 <startling> (you can see the ingredients of any recipe without running it)
23:08:16 <Cale> Moggle_: It stops the world still, but the garbage collector itself is parallel
23:08:27 <Moggle_> Cale: ah, that's pretty nice!
23:09:13 <Aetherspawn> What's the reason it has to stop the world ?
23:09:20 <Cale> Moggle_: They've also experimented with minor collections that don't stop the world, but iirc, those didn't improve performance. (I could be wrong about that)
23:09:53 <Aetherspawn> if it stops the world, then the world has stopped and it sounds impossible for there to be any performance equality between stopping and not stopping the world
23:09:55 <Aetherspawn> if that makes sense.
23:10:06 <Moggle_> Aetherspawn: How long the world is stopped will affect performance
23:10:25 <Cale> Aetherspawn: It never stops the world for a very long time, of course :)
23:10:25 <Moggle_> ie. how long the garbage collector runs
23:13:50 <mm_freak_> tabemann: the arithmoi package contains an extremely fast Integer square root
23:14:16 <Aetherspawn> is there like a HashMap but with a tree structure
23:14:25 <Aetherspawn> so that transactions of children are cheaper..
23:14:32 <mm_freak_> Aetherspawn: HashMap /is/ a tree structure
23:14:44 <mm_freak_> it's basically Map, but with hash comparison instead of Ord
23:15:55 <Aetherspawn> Say I have a structure with 2 million elements, and one of those looks like "foo/bar/hey" and I lookup hey so I use "foo/bar/hey" as the key(?)
23:16:25 <Aetherspawn> but what if I already have foo/bar and I don't want the expense of looking through the 2 million elements agian. Is what I'm thinking of impossible?
23:16:44 <mm_freak_> Aetherspawn: Map and HashMap are just dictionaries…  maybe a finger-tree/trie is more like what you're looking for
23:16:57 <Aetherspawn> ah thanks, I'll take a look at those :)
23:17:14 <mm_freak_> i don't know what the canonical packages for those are
23:21:49 <johnw> tries will let you narrow down to a subtree of all "foo/bar" keys
23:21:57 <johnw> (and any key under that key)
23:27:48 <Aetherspawn> are these the right ones? http://hackage.haskell.org/packages/archive/list-tries/0.5.1/doc/html/Data-ListTrie-Patricia-Set.html
23:30:53 <fragamus> hi
23:31:33 <joelteon> anybody happen to know if you can figure out whether a delete actually deleted anything in persistent
23:31:38 <fragamus> I need something     [a]->[[a]]      all possible substrings
23:35:05 <shirt> I'm using HDBC. how do i quote a value?
23:35:17 <ion> > inits <=< tails $ "foobar"
23:35:18 <lambdabot>   ["","f","fo","foo","foob","fooba","foobar","","o","oo","oob","ooba","oobar"...
23:36:37 <meanpath> gentoo
23:36:59 <ion> shirt: Doesn’t toSql take care of that?
23:38:15 <shirt> ion: yeah, but i'm building a complex query and can't use toSql
23:38:47 <ion> Why can’t you?
23:39:12 <shirt> i'm dynamically calculating the table name
23:39:31 <Kinnison> Anyone here experienced in happstack
23:39:33 <Kinnison> ?
23:51:27 <johnw> Kinnison: someone may be able to answer your question, but people rarely claim expertise in a general area
23:51:50 <Kinnison> True enough, I should remember that really
23:51:54 * elliott is an expert on all things.
23:52:10 * Kinnison is trying to work out how to pass some context (options, etc) to happstack handlers
23:52:38 <MasseR> Reader monad is one way
23:53:28 <Kinnison> I'd ideally like to be able to mutate that context
23:53:35 <Kinnison> i.e. State rather than Reader
23:53:41 <MasseR> Well there you have it :)
23:53:43 <elliott> State monad is one way :p
23:54:04 <Kinnison> Right, but Happstack is expecting something which doesn't look like I can shove State into
23:54:41 <MasseR> You can have your own transformers there
23:54:48 <elliott> you could just do the cheap thing and use a TVar or whatever.
23:54:56 <elliott> if you can smuggle one in.
23:54:57 <Kinnison> elliott: That was where I was going :-(
23:55:19 * Kinnison was hoping for something more elegant
23:55:28 <elliott> I think I answered an SO question about using custom transformers with Happstack once, but I have completely forgotten what the answer was :)
23:55:35 <Kinnison> heh
23:55:36 <elliott> (I just read the docs)
23:55:40 <MasseR> Kinnison: Seriously, you can use monad transformers
23:55:49 <elliott> Kinnison: well, presumably you can be serving multiple requests concurrently
23:55:54 <elliott> so StateT doesn't necessarily make sense
23:55:57 <Kinnison> elliott: Mmm, that's a good point
23:56:04 <Kinnison> So I should probably use a TMVar ?
23:56:20 <MasseR> I would put that TVar into a reader
23:57:07 <elliott> no reason for the M part if you don't need it
23:58:24 <Kinnison> Assuming I want to mutate the value, I assumed I'd want the M to ensure that different threads don't mutate it simultaneously
23:59:27 <elliott> well, TVar is STM. you already get atomicity.
23:59:33 <elliott> TMVar is just a TVar that can be empty.
23:59:38 <fragamus> i seem to recall that lambdabot can convert to point free     how is that done
