00:01:56 <johnw> i'm guessing its strict in the bind operation
00:02:56 <predator217> okay the thread says: Control.Monad.State.Strict is strict in the actions, but the state
00:02:59 <predator217> itself is still lazy
00:03:14 <johnw> i think many consider this a bug
00:03:20 <johnw> since it has surprised many peolpe
00:03:30 <johnw> i've answered this same question I think 5 times since we found out about it
00:04:13 <predator217> maybe it would be better to explicitly say so in the docs on hackage
00:04:18 <johnw> yes, at least that
00:09:37 <MedDev> Is it possible to have nested (unboxed) vectors, a vector of vectors?
00:10:28 <MedDev> It won't seem to let me write an instance declaration for such (V.singleton V.empty) V.++ (V.singleton V.empty) says that there's no instance
00:16:02 <MedDev> looks like maybe i want Data.Sequence
00:28:44 <startling> edwardk, do you ever think about separating out the error-reporting parts of trifecta?
00:32:02 <Ralith> startling: why separate them out?
00:33:18 <startling> I guess it's not as important for them to be separate package-wise as semantically.
00:33:31 <startling> It'd be cool if I could parse a string and get an error that I can inspect rather than a Doc.
00:34:56 <Ralith> oh, that's what you meant
00:35:10 <Ralith> it'd be neat, but I'm not sure it'd be useful
00:37:21 <startling> it'd be cool if e.g. a type-checker could use the same error types; then the whole thing could just be in an Either Error
00:44:27 <MedDev> weee sequence is what i wanted!
00:47:01 <startling> > isSymbol '-' -- why not?
00:47:03 <lambdabot>   False
00:47:15 <shachaf> > generalCategory '-'
00:47:16 <lambdabot>   DashPunctuation
00:47:57 <startling> oh
00:48:02 <startling> > isPunctuation '-'
00:48:02 <lambdabot>   True
00:48:29 <Yaniel> what is Symbol then?
00:48:38 <Yaniel> Character?
00:48:52 <shachaf> Probably as defined by Unicode.
00:49:02 <Yaniel> hmm
00:49:08 <startling> > isSymbol '$'
00:49:09 <lambdabot>   True
00:49:13 <startling> idgi either
00:49:50 <Yaniel> > generalCategory '%'
00:49:51 <lambdabot>   OtherPunctuation
00:52:25 <Yaniel> @hoogle generalCategory
00:52:25 <lambdabot> Data.Char data GeneralCategory
00:52:25 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
01:09:54 <ezrios> Does Network.Browser still work? The example given in the docs seems broken
01:10:30 <johnw> I don't know; but have you seen Network.HTTP.Conduit.Browser?
01:11:28 <ezrios> johnw: no; does it support HTTP Basic Auth?
01:11:45 <johnw> it sure ought to; http-conduit does, and it's based on that
01:11:45 <arossouw> http://lpaste.net/91201, on line 2 dont get why xs doesn't return the entire list, but only the items thats left in the list
01:12:05 <ezrios> johnw: I will check it out then, thanks
01:13:15 <ezrios> j/join ##linux
01:13:24 <ezrios> ._.
01:13:49 <ezrios> shutdown warnings really mess with weechat's curses interface
01:16:09 <arossouw> guess i need to learn basics first, i'll check out yet another haskell tutorial
01:16:09 <ezrios> arossouw: look up pattern matching
01:16:37 <arossouw> ok
01:16:48 <arossouw> haskell makes you think overtime :-), challenging
01:19:00 <ezrios> @hoogle get
01:19:01 <lambdabot> Prelude getChar :: IO Char
01:19:01 <lambdabot> System.IO getChar :: IO Char
01:19:01 <lambdabot> Prelude getContents :: IO String
01:22:40 <Kinnison> ezrios: Or perhaps Control.Monad.State's get :: MonadState s m => m s
01:22:47 <Kinnison> ezrios: depending on what you really wanted :-)
01:23:05 <ezrios> Kinnison: that probably makes more sense, thanks
01:24:19 <ezrios> oh god I have never worked with the State monad ;_;
01:25:01 <sopvop> which style you think is better, monadicFoo = do \n  code, or monadicFoo =\n  do code ?
01:27:11 <Lethalman> sopvop, the former, cause you avoid further indentation later
01:27:25 <Lethalman> you have less indentation if you put do on the monadicFoo = line
01:28:20 <sopvop> me too, but some people say that is "hiding do"
01:28:44 <Lethalman> sopvop, I want to hide do :P
01:28:45 * Kinnison prefers flarfle = do\n  code
01:28:58 <Lethalman> I don't care about "do"
01:29:54 <johnw> i like do\n also
01:30:04 <ezrios> ya, do\n
01:31:39 <sopvop> So, I'm doing it right :)
01:34:08 <bitonic> nooo, do\n is baaaaad
01:34:16 <bitonic> you can’t clearly see do blocks that way
01:35:37 <MasseR> bitonic: I find the other way to hide do better
01:35:38 <Lethalman> "do" keyword clutters the code
01:36:00 <bitonic> MasseR: well, “hiding” keywords is confusing
01:36:12 <MasseR> bitonic: Exactly. Thats why I do do\n
01:36:38 <bitonic> MasseR: wait, you think that the on-line do hides the do more?
01:36:39 <MasseR> But then again, this is same as foo {} vs foo\n{}. You get used to either one
01:36:43 <bitonic> I think it’s the opposite
01:36:44 * Kinnison has looked at his code and appears to use do\ncode at the "top level" and do code\n when adding blocks within functions
01:37:01 <Lethalman> foo $ do\n
01:37:31 <Lethalman> foo $ \x -> do
01:37:46 <Kinnison> Hah, having said that, I appear to be super inconsistent anyway -- yay for not having found a "style" yet
01:38:32 <Lethalman> also I'm satisfied to have discovered MultiWayIf
01:39:02 <Lethalman> that syntax rocks
01:40:40 <HugoDaniel> hi
01:40:50 <james-ubc> so I've heard haskell is getting pretty popular in the gnome processing crowd
01:41:56 <jzelinskie> how does one pronounce <$> ?
01:42:12 <jzelinskie> apply?
01:42:12 <Nimatek> fmap
01:42:15 <jzelinskie> fmap?
01:42:23 <opqdonut> :t (<$>)
01:42:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:42:25 <opqdonut> :t fmap
01:42:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:42:27 <jzelinskie> <*> is apply right
01:42:33 <opqdonut> @source (<$>)
01:42:34 <lambdabot> Unknown command, try @list
01:42:39 <opqdonut> @src (<$>)
01:42:40 <lambdabot> f <$> a = fmap f a
01:42:42 <opqdonut> there ya go
01:42:55 <sopvop> james-ubc: processed gnome... food?
01:43:32 <jzelinskie> so functors implement <$> as well?
01:43:35 <dobblego> money bum
01:43:44 <jzelinskie> not just applicatives?
01:44:01 <dobblego> all applicatives implement functor
01:44:05 <jzelinskie> i know that
01:44:16 <johnw> <$> is just an operator name for fmap
01:44:18 <sopvop> <$> is just infix fmap
01:44:20 <johnw> so it's really a Functor thing
01:44:24 <jzelinskie> ok cool
01:44:30 <jzelinskie> i've only seen it used with applicatives
01:44:40 <johnw> just happens to live in Control.Applicative for consistency of use with <*>
01:44:45 <jzelinskie> ah
01:44:48 <jzelinskie> makes sense, thanks
01:45:17 <quchen> I think it's moved to Data.Functor in the next release (but re-exported from Applicative).
01:45:59 <jzelinskie> i also recently discovered that Monads aren't required to be Functors. Historical baggage?
01:46:07 <HugoDaniel> james-ubc: why ?
01:46:11 <mauke> jzelinskie: yeah
01:46:38 <jzelinskie> I assume if they changed it, legacy stuff would break because they don't have the instance defined?
01:46:57 <quchen> jzelinskie: We'll see in a couple of months. :-)
01:47:11 <johnw> jzelinskie: they are changing it.  Actually, all Monads are Applicatives, which are all Functors
01:47:13 <jzelinskie> glad to see they plan on fixing it
01:47:28 <quchen> We're trying to make the change gradually, generating warnings first, and then doing the actual change in a couple of versions.
01:48:11 <jzelinskie> yeah, I'm 12 chapters into Learn You a Haskell, so I'm kinda confirming that knowledge johnw
01:49:09 <ogew2> newbie question: you can pattern match a newtype like it is a 2-tuple ?
01:49:28 <quchen> ogew2: You can't have a newtype of something with multiple fields.
01:49:38 <james-ubc> HugoDaniel, easier than perl and faster than other langs without much work
01:49:40 <dobblego> ogew2: if the newtype takes a pair in its constructor argument sure
01:49:53 <james-ubc> this is like grad stuff though O.o
01:50:34 <ogew2> noted with thanks
01:50:38 <quchen> ogew2: newtype Foo a = Foo a a -- Error
01:50:48 <quchen> ogew2: newtype Bar a = Bar (a, a) -- matchable as usual
01:51:05 <ogew2> ahh.
01:51:29 <quchen> ogew2: For what it's worth, newtype is pretty much the same as a restricted version of data, up to some details.
01:51:39 <ogew2> (Bar x) = x --  that means x = (a, a) ?
01:51:54 <ogew2> can i (Bar (x, y)) ?
01:52:01 <quchen> Something along those lines, yes.
01:52:02 <dobblego> yes
01:52:12 <ogew2> cool thanks all
01:52:40 <quchen> ogew2:  "that means x = (a, a)" - that "=" should be a "::".
01:52:51 <quchen> You mixed types and values there.
01:53:01 <ogew2> nice tips
01:53:21 <ogew2> thanks
02:10:03 <MedDev> Is there a lot of overhead associated with using writeFile and show?
02:10:27 <m3ga> MedDev: in comparison to what?
02:10:44 <MedDev> lol good question
02:11:50 <MedDev> m3ga, just trying to figure out the best way to force evaluation to see how long it takes to process the entirety for a huge sequence
02:13:30 <MedDev> I ended up producing a >80mb text file.  I think the coercion into a string is part of the time taken.
02:13:44 <mauke> :t evaluate . length . show
02:13:45 <lambdabot> Show a => a -> IO Int
02:14:40 <m3ga> not really a coercion, but yes, the conversion of show can be significant. mauke's suggestion is spot on.
02:15:24 <quchen> Use the `force`, Luke!
02:15:47 <quchen> http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html#v:force
02:16:04 <quchen> MedDev: ^
02:16:22 <mauke> @hoogle force
02:16:22 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
02:16:22 <lambdabot> package force-layout
02:16:22 <lambdabot> Graphics.UI.GLUT.Initialization ForceDirectContext :: DirectRendering
02:16:33 <mauke> that doesn't even do anything
02:16:56 <quchen> ..?
02:17:09 <mauke> you still have to force the outermost layer somehow
02:17:14 <quchen> That is correct.
02:17:58 <mauke> recordTime; evaluate (force x); recordTime; evaluate (length (show x)); recordTime
02:18:47 <MedDev> mauke, that seems to have worked!
02:20:59 <quchen> recordTime >> (evaluate $!! show x) >> recordTime
02:20:59 <hvr> johnw: ping?
02:21:43 <quchen> Ah, he just wants to profile the `show`, nevermind, in that case: what Mauke said.
02:22:08 <MedDev> no i want to take show out of the picture
02:23:00 <quchen> So you have a thunk and you want to see how long it takes to reduce it to normal form?
02:23:25 <quchen> In any case, you'll want to use some function from DeepSeq.
02:23:34 <MedDev> ok I'll look around
02:23:36 <MedDev> thanks :)
02:24:19 <quchen> Just remember that "force x" is a thunk like everything else. To force the x, you have to evaluate "force x" to at least WHNF.
02:24:31 <quchen> That's why we wrapped it in an additional `evaluate` above.
02:25:21 <MedDev> I'll try to remember, but can't promise I will ;)
02:26:38 <zRecursive> weird lazy :)
02:28:20 <quchen> zRecursive: Usually you're not really interested when exactly the force is evaluated. It's often used in a parallel scenario, and as long as it's in the parallel computation you're fine.
02:28:43 <quchen> Of course it would be bad if all the parallel computation did nothing but tell the main thread to please evaluate some `force` sequentially :-)
02:30:10 <quchen> zRecursive: Forcing evaluation at some specific point so you can put timers around it is kind of the inverse of making a C++ program a little lazy sometimes. It's awkward.
02:30:11 <zRecursive> seems hard to control
02:30:40 <quchen> Control.Concurrent makes it surprisingly easy.
02:31:01 <zRecursive> @hoogle Control.Concurrent
02:31:01 <lambdabot> Control.Concurrent module Control.Concurrent
02:31:01 <lambdabot> package concurrent-barrier
02:31:01 <lambdabot> package concurrent-extra
02:31:08 <quchen> Eh, Control.Parallel
02:31:09 <quchen> pardon
02:31:15 <DexterLB> is there an arbitrary root function?
02:31:20 <quchen> sqrt?
02:31:23 <mauke> **
02:31:33 <quchen> Oh, arbitrary non-square.
02:31:38 <DexterLB> ^
02:31:50 <mauke> definitely not ^
02:32:00 <DexterLB> lol
02:32:34 <mauke> > 27 ** (1/3)
02:32:35 <lambdabot>   3.0
02:33:02 <DexterLB> ah, that's awesome
02:33:04 <DexterLB> thanks
02:33:14 <Lethalman> :t 27**(1/3)
02:33:14 <zRecursive> > 27 ^^ (1/3)
02:33:15 <lambdabot> Floating a => a
02:33:15 <lambdabot>   Could not deduce (GHC.Num.Num b0) arising from the literal `1'
02:33:15 <lambdabot>  from the co...
02:33:42 <Lethalman> :t 1/3
02:33:42 <mauke> ^^ needs integral exponents
02:33:43 <lambdabot> Fractional a => a
02:33:52 <jophish_> Yo yo yo
02:39:55 <matttt_> I just install mueval using `cabal install mueval`, now when I run `mueval -e '1 + 1'`, I get this error: "Could not find module `ShowQ'"
02:40:14 <matttt_> any ideas what could be the problem?
02:44:54 <quchen> Suppose I have a list of IO actions that each query a server, and I'd like to evaluate this concurrently. In order not to launch a heavy DDoS attack, I'd like to limit the number of concurrently executed actions to N. Is there a standard function to do this, or do I have to write my own little bookkeeper?
02:45:22 <t7> so i would like to create a buffer of random primes in a background thread and regenerate them as they are used, using channels or something. What are my options?
02:45:26 <mauke> quchen: maybe there's something in async?
02:46:19 <t7> is there a lazy way todo an IO thing?
02:46:48 <quchen> t7: Fork off a prime-generating thread with a bounded channel to the workers?
02:47:22 <t7> oh nice
02:48:05 <quchen> TBQueue should be what you're looking for
02:48:14 <t7> oh i found boundedchan
02:49:00 <donri> stupid question: can it affect compile times if dependencies were previously built -O2? i guess larger object files take longer to link statically? anything else?
02:49:43 <Saizan> more stuff will be available for inlining, i think
02:49:58 <donri> t7: there's unsafeInterleaveIO and it's called unsafe for a reason :)
02:50:21 <Saizan> but icbw
02:50:47 <donri> Saizan: sounds plausible for sure
02:51:13 <Saizan> donri: you could compare the .hi files, ghc has a flag to decode them
02:51:17 <quchen> mauke: Can't find anything there. I'll just go with forking N workers and distributing the tasks from some other thread.
02:51:48 <donri> thing is i proposed for fedora that they build their haskell rpms with -O2 thinking it would only benefit users. maybe it will make for worse build times though even if you don't use -O2 yourself
02:52:17 <donri> juhp: ^
02:52:34 <quchen> donri: Isn't O2 pretty much the same as O1?
02:52:51 <donri> quchen: not IME or from what i've heard from others
02:52:57 <quchen> IME?
02:53:00 <donri> in my experience
02:53:23 <donri> i've seen cases where -O2 magically fixed memory explosions
02:53:29 <quchen> Oh.
02:53:51 <t7> quchen: how do i do an STM thing in the IO monad?
02:53:53 <zugz> 'keys' is a sorted list of Text strings, and I want a memory-efficient data structure which will allow me to look up the *index* of an element of keys. "Map.fromAscList $ zip keys [0..]"  does the job, but is too expensive in terms of memory. Any suggestions?
02:53:59 <t7> or should i be doing the reverse?
02:54:03 <quchen> t7: atomically :: STM a -> IO a
02:54:19 <quchen> t7: No, STM actions are always embedded in IO actions at some point.
02:54:21 <donri> you can't do the reverse
02:54:28 <donri> it's much of the point of stm :)
02:54:48 <donri> or i should say, the STM monad
02:54:53 <quchen> t7: Have you read the STM chapter of RWH?
02:55:04 <quchen> And while we're at it, Simon Marlow's book is online (for the time being)
02:55:18 <quchen> http://chimera.labs.oreilly.com/books/1230000000929/index.html
02:56:12 <merijn> Right, I've now patched my patch for the second time >.>
02:56:21 <donri> zugz: Data.Set and lookupIndex maybe?
02:56:28 <quchen> merijn: Merge problems or did your fix not work?
02:56:44 <donri> zugz: assuming you don't have collisions
02:57:00 <merijn> quchen: First my fix just moved the error, then I noticed unnecessary code >.>
02:57:30 <quchen> The second law at work! :-)
02:57:34 <zugz> donri: sounds perfect, but where is lookupIndex? Not in http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
02:58:04 <zugz> donri: aha! Data.Set.Strict
02:58:08 <donri> zugz: apparently new http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Set.html#g:8
02:58:29 * hackagebot language-java 0.2.5 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.5 (JamesKoppel)
02:58:37 <donri> not sure where you're seeing that module
02:58:41 <donri> it's not in containers
02:58:43 <zugz> donri: oh ignore that, getting confused
02:58:47 <merijn> @tell applicative Are you sure you're using the recompiled/patched GHC? Also, which platform (i.e. architecture, GHC version, GHC bitsize, etc.) are you on?
02:58:47 <lambdabot> Consider it noted.
02:59:33 <zugz> donri: and cool, I'll try the new library. Thanks!
02:59:59 <donri> zugz: it tends to get messy if you upgrade core libraries though
03:00:58 <t7> hpaste is down?
03:01:01 <quchen> ^ This. In my experience, reinstalling everything is much faster than surgery in Base.
03:01:06 <t7> am i doing it right? http://paste.ubuntu.com/5910635/
03:01:06 <quchen> t7: it's LPaste now.
03:01:08 <quchen> @paste
03:01:08 <lambdabot> Haskell pastebin: http://hpaste.org/
03:01:10 <quchen> …
03:01:12 <quchen> @where paste
03:01:13 <lambdabot> http://lpaste.net/new/haskell
03:01:14 <quchen> Ah.
03:01:32 <quchen> @tell Cale Lambdabot's @paste still mentions hpaste instead of lpaste
03:01:32 <lambdabot> Consider it noted.
03:03:28 <t7> @hoogle m a -> int -> [m a]
03:03:28 <lambdabot> Did you mean: m a -> Int -> [m a]
03:03:29 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
03:03:29 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
03:03:32 <t7> @hoogle m a -> int -> m [a]
03:03:32 <lambdabot> Did you mean: m a -> Int -> m [a]
03:03:32 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
03:03:32 <lambdabot> Text.ParserCombinators.ReadP endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
03:03:43 <t7> > sequence
03:03:44 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 m0)
03:03:44 <lambdabot>    arising from a use...
03:03:54 <t7> @hoogle sequence
03:03:54 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:03:54 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:03:54 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
03:04:09 <t7> wrong way
03:04:10 <supki> quchen: I think elliott runs lambdabot currently
03:05:07 <quchen> @tell elliott Lambdabot's `@paste` still mentions hpaste instead of lpaste. (`@where paste` works correctly.)
03:05:07 <lambdabot> Consider it noted.
03:10:02 <zugz> donri: "ghc -icontainers" will do me for now
03:19:53 <hpaste> jophish pasted “idiomatic haskell?” at http://lpaste.net/91202
03:20:35 <jophish_> I feel that this is quite complicated. I'm interested in writing like you pros, but don't really know how.
03:20:52 <jophish_> This is a lexer for kaleidoscope, http://llvm.org/docs/tutorial/OCamlLangImpl2.html
03:21:13 <dobblego> jophish: have you run hlint on it?
03:21:16 <jophish_> I'd really appreciate it if someone could take a quick look and suggest some points where this could be simplified
03:21:20 <dobblego> m++[s] is glaring
03:21:50 <jophish_> yeah, I could probably get away with just returning the length of the match there
03:22:00 <jophish_> and taking that many from the input string
03:22:29 <jophish_> I'll take a look at hlint, I don't suppose that flags up algorithm problems though :)
03:23:51 <jophish_> getLongestPrefix was mostly stolen from regex-applicative, which just returned the remaining string, not too useful for advancing a source position
03:24:11 <ClaudiusMaximus> jophish_: lpaste runs hlint, see the bottom of the page
03:24:24 <jophish_> oh, groovy
03:38:23 <shiona> The number of mathematical ideas and/or useful haskell libraries is daunting. Is there a tried-and-true path from basic understanding of haskell onward?
03:39:02 <donri> @where rwh
03:39:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:39:41 <shiona> ok, I guess I never finished that
03:39:49 <shiona> so back I go
03:40:54 <quchen> After RWH it's the usual find-and-learn-libraries phase.
03:40:55 <donri> it's not quite up to date with modern libraries, but still good
03:43:14 <shiona> My problem is that although many people have taught me applicatives and monads, I still cant get a graps of them
03:43:51 <alexander__b> shiona: same. I hope intuition will kick in sometime soon.
03:44:08 <shiona> Then I go on and try to do something with ST and it works when it's under 50 lines, but after that the code somehow melts and I'm unable to save any of it
03:44:21 <alexander__b> shiona: though TBF a lot of haskell guys when trying to explain such things will just show you a million lines of code and say that it's obvious. :-P
03:44:35 <donri> ST probably isn't the best monad to start with
03:45:45 <shiona> what would you suggest?
03:46:01 <quchen> Maybe, Writer, State.
03:46:03 <quchen> In that order.
03:46:26 <alexander__b> shiona: have you seen this: http://stackoverflow.com/questions/1012573/getting-started-with-haskell ? I keep getting referred to the top answer there, and it seems to be insightful. I am sort of following it. (though most people will tell you to skip the Euler phase.)
03:47:30 <shiona> alexander__b: yes, I think I started going though the intermediate stuff about a year ago
03:47:33 <dobblego> I teach functional programming. I go List, Maybe, Reader, State, Writer, ReaderWriterState, Parser, in that order
03:47:43 <alexander__b> shiona: you are a lot further ahead than me then, heh.
03:50:28 <shiona> ok, list and maybe are pretty much under my belt. Well, i know how to fmap over them, but using them in any more complex patterns will result in very imperative code
03:52:39 <quchen> shiona: Suppose you have `database :: Map Int (Map Int String)`, which encodes a 2-dimensional table. Write a function that looks up the i-j-th index.
03:53:48 <quchen> (You can use Map.lookup in the solution of course.)
03:53:50 <donri> before you try to understand any of the type classes in haskell it's important that you understand the type class concept itself
03:54:29 <donri> for example it's easy to get baffled at how a monad computation could possibly work the way it does, missing the fact that >>= is a different operator for every type
03:55:21 <t7> @hoogle (r -> a -> (b, r)) -> [a] -> r -> ([b], r)
03:55:21 <lambdabot> No results found
03:55:23 <donri> also, do notation is great and you should use it, but it's also important to understand how to work without it
03:55:26 <ogew2> quchen: lookup :: Int -> Int -> String ? Am I right or I need to constraint to database or something
03:55:30 <t7> @hoogle (r -> a -> (b, r)) -> [a] -> r
03:55:30 <lambdabot> No results found
03:55:30 <donri> (and when it is redundant)
03:55:54 <donri> @where do
03:55:54 <lambdabot> The rules of do notation: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14 (Note that "do { v <- m; ... }" is the same as "m >>= \v -> do { ... }" when v is a variable,
03:55:54 <lambdabot> rather than a more complex pattern.)
03:55:57 <quchen> lookup :: Ord k => k -> Map k a -> Maybe a
03:56:02 <donri> @where do-notation
03:56:02 <lambdabot> http://book.realworldhaskell.org/read/monads.html#monads.do
03:56:04 <donri> :(
03:56:06 <shiona> quchen: I started with "\i j -> lookup i . lookup j", but as the result is maybe, I think i need to fmap it.
03:56:16 <ogew2> sigh.
03:56:19 <donri> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
03:56:38 <quchen> shiona: The idea of composing two lookups is right, but as you mentioned the Maybe is in the way.
03:56:40 <shiona> that seems to return a Maybe Maybe Map though
03:57:13 <quchen> \i j -> [lookup i] then [lookup j]   -- And if one of them fails, the whole thing should be Nothing, right?
03:57:29 <donri> :t join
03:57:29 <lambdabot> Monad m => m (m a) -> m a
03:58:05 <shiona> yea, in this case I would have most likely gone with the imperative if-then-else or case solutions, if donri hadn't given it out
03:58:19 <donri> uh sorry, you're doing this for learning
03:58:24 <donri> reflex :p
03:58:31 <quchen> I wouldn't use donri's suggestion here anyway.
03:59:30 <quchen> What you want to do is take the result from `lookup i ...` and pipe it into a `lookup j ...`.
03:59:53 <quchen> Fmap is like throwing more stuff into a bucket. Piping is what >>= does. :-)
03:59:55 <shiona> well, with donris help my function of choice would be (\i j m -> join $ Data.Map.lookup i <$> Data.Map.lookup j m)
04:00:07 <shiona> agh
04:00:18 <shiona> yea, of course
04:00:28 <shiona> this is what I mean when I say I can't see these things
04:00:31 <quchen> Your solution works, but is not very readable. :-)
04:00:37 <donri> yes join might not be what you want anyway, didn't read the full problem
04:00:55 <quchen> We can refactor it to the real solution step-wise though, once you found that one :-)
04:01:18 <ogew2> :t Data.Map.lookup
04:01:19 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
04:01:46 <quchen> So how would you write a single lookup for i? It'll be something like \i j m = lookup i m.
04:02:05 <quchen> Now pass the result of that lookup to another one.
04:02:22 <shiona> do you mean (\i j m -> Data.Map.lookup i m >>= Data.Map.lookup j)
04:02:37 <quchen> Yep :-)
04:03:10 <ogew2> cool
04:03:11 <quchen> That can be written even nicer with >=>, defined as `a >=> b = \x -> a x >>= b`
04:03:23 <quchen>   \i j m -> Data.Map.lookup i m >>= Data.Map.lookup j
04:03:34 <quchen> = \i j -> \m -> Data.Map.lookup i m >>= Data.Map.lookup j
04:03:35 <donri> it's easier to grok if you use =<< as it's more like $ and <$>
04:03:44 <quchen> = \i j -> Data.Map.lookup i m >=> Data.Map.lookup j
04:03:53 <quchen> Eh, scratch the m
04:03:56 <shiona> yea
04:03:56 <quchen> = \i j -> Data.Map.lookup i >=> Data.Map.lookup j
04:04:01 <ogew2> (lookup i >=> lookup x )
04:04:18 <shiona> ok, well, that might go a little overboard for me for now :D
04:04:39 <quchen> shiona: It also helped me in the beginning to go the full imperative way, writing everything with do notation, and then learning to refactor that.
04:04:39 <donri> similarly i think it's <=< that's like (.) ?
04:04:47 <quchen> Yes.
04:05:12 <Lethalman> :t flip (.)
04:05:12 <lambdabot> (a -> b) -> (b -> c) -> a -> c
04:05:18 <Lethalman> :t flip (>=>)
04:05:19 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:05:20 <dobblego> (=<<) has the arguments around the correct way, which is especially important when teaching
04:05:24 <quchen> lookup2 i j m = do { iElement <- lookup i m; jElement <- lookup j iElement; return jElement }
04:05:30 <quchen> That's the full do-based version.
04:05:30 <Lethalman> is there a flip (.) somewhere? :-)
04:05:40 <quchen> Lethalman: Control.Category.(>>>)
04:05:41 <dobblego> Lethalman: (>>>)
04:05:47 <Lethalman> ah
04:05:58 <Lethalman> :t (>>>)
04:05:59 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
04:06:09 <Lethalman> awesome
04:06:15 <ogew2> then what is the flip for >=> ?
04:06:20 <quchen> <=<
04:06:27 <dobblego> @type (<=<)
04:06:27 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:06:29 <ogew2> intuitive :)
04:06:33 <quchen> :t (>>>) `asAppliedTo` (undefined :: a -> b)
04:06:34 <lambdabot> (a -> b) -> (b -> c) -> a -> c
04:06:36 <quchen> Much better. :-)
04:06:44 <dobblego> which is the same type as (.) with m wrapping every return position
04:06:53 <ogew2> does Category need to be Monad?
04:06:58 <Taneb> No
04:07:06 <ogew2> applicatives? functor?
04:07:07 <quchen> No, category is its own typeclass, independent of everything.
04:07:11 <ogew2> thanks all
04:07:24 <donri> Arrow needs Category, though
04:07:29 <Taneb> Is there a Monad instance for Monoid e => (,) e?
04:07:36 <Lethalman> ogew2, http://www.haskell.org/haskellwiki/Typeclassopedia
04:07:41 <Lethalman> ogew2, see the diagram
04:07:44 <dobblego> Taneb: yes, Control.Monad.Instances iirc
04:07:45 <ogew2> thankx
04:07:49 <quchen> Taneb: Yes, I think so.
04:07:56 <dobblego> Taneb: or Control.Monad.Writer for the wrapper
04:08:03 <donri> .Instances is deprecated in some recent ghc
04:08:04 <Taneb> dobblego, nothing in .Instances
04:08:12 <dobblego> ok
04:08:23 <Taneb> Or in Control.Monad
04:09:12 <Taneb> It's pretty easy to write an instance
04:09:45 <Taneb> Maybe I should write to libraries@?
04:09:47 <dobblego> there is one in semigroupoids — which I may have confused
04:10:15 <dobblego> Semigroup m => Bind ((,) m)
04:11:19 <ogew2> quchen, to complete ur tutorial, is the definition for `lookup2D :: Int -> Int -> Map a -> a`  ?
04:11:35 <quchen> ogew2: Careful, the result isn't just `a`.
04:11:42 <ogew2> Gotit
04:11:52 <dobblego> ogew2: what would happen if I passed two Int for which there is no value?
04:11:54 <quchen> And the Map needs a "Map a", the type of the keys must be in there.
04:11:59 <ogew2> lookup2D :: Int -> Int -> Map a -> Maybe a   ?
04:12:00 <Taneb> instance Monoid e => Monoid ((,) e where return = (,) mempty; (w, a) >>= f = let (w', b) = f a in (w `mappend` w', b); (w, _) >> (w', a) = (w `mappend` w', a)
04:12:22 <dobblego> Int -> Int -> Map Int a -> Maybe a
04:12:34 <ogew2> sigh.
04:12:36 <ogew2> thanks
04:12:41 <quchen> :t \i j -> Data.Map.lookup i >=> Data.Map.lookup j
04:12:41 <lambdabot> (Ord k, Ord k1) => k -> k1 -> M.Map k (M.Map k1 c) -> Maybe c
04:12:44 <dobblego> Taneb: yes, the Writer monad might help you
04:13:13 <Taneb> dobblego, I know about the Writer monad, I'm just wondering why the instance isn't in base
04:13:17 <dobblego> ok
04:13:35 <merijn> Taneb: You mean (,) e? I think it's in Data.Tuple?
04:13:38 <quchen> I could have sworn there is such an instance somewhere.
04:13:45 <quchen> merijn: I just checked, it's not
04:13:51 <merijn> Whoops, nope
04:13:59 <merijn> I remember a complaint about it on libraries@
04:14:07 <quchen> Wasn't that about Either?
04:14:10 <ogew2> can i hint :t   that i and j has to be int ?
04:14:13 <merijn> No, before then
04:14:14 <Taneb> It should probably be in .Instances for now
04:14:29 <quchen> :t \i j -> Data.Map.lookup (i :: Int) >=> Data.Map.lookup (j :: Int) -- ogew2
04:14:30 <lambdabot> Int -> Int -> M.Map Int (M.Map Int c) -> Maybe c
04:14:51 <ogew2> wow
04:15:18 <Lethalman> :t Data.Map.lookup `asAppliedTo` (1 :: Int)
04:15:19 <lambdabot> Int -> M.Map Int a -> Maybe a
04:15:28 <merijn> ogew2: You can add type annotations almost anywhere, as long as the annotations type check
04:15:45 <quchen> merijn: Except in Lambda parameters, for that you need an extension :-(
04:15:51 <quchen> :t \(x :: Int) -> x
04:15:52 <lambdabot>     Illegal type signature: `Int'
04:15:52 <lambdabot>       Perhaps you intended to use -XScopedTypeVariables
04:15:52 <lambdabot>     In a pattern type-signature
04:15:53 <ogew2> ;) noted
04:15:54 <quchen> :-(
04:15:56 <merijn> I know
04:16:05 <merijn> But STV is a good thing anyway!
04:16:31 <quchen> I want -fglasgow-exts back, adding the same boilerplate to every file is annoying.
04:16:43 <dobblego> aw
04:16:44 <quchen> MultiWayIf, BangPatterns, ScopedTypeVariables, LambdaCase …
04:16:56 <donri> quchen: default-extensions in .cabal?
04:17:15 <donri> or default-languages i think is the preferred name, hm
04:17:59 <quchen> donri: That requires writing a Cabal file for everything
04:18:11 <merijn> quchen: glasgow-exts wouldn't have MultiWayIf and LambdaCase anyway, it predates those
04:18:12 <donri> yes, do that ;)
04:18:45 <quchen> merijn: -fglasgow-extended-exts
04:18:45 <donri> there's .ghci if that's what you want it for
04:18:45 <merijn> I should enable all those extensions in my .ghci
04:18:45 <donri> :set -X...
04:18:45 <supki> quchen: what kind of code you write that requires STV for each file?
04:18:45 <merijn> Plus imports
04:18:56 <merijn> So I don't keep forgetting everything
04:19:16 <quchen> supki: It's one of the unobtrusive extensions I would mind being on by default.
04:19:20 <dobblego> while we are complaining, I want the Prelude hidden 4 eva
04:19:27 <supki> ah, sure
04:19:28 <quchen> s/would/wouldn't
04:20:08 <quchen> dobblego: The Prelude is pretty important
04:20:23 <dobblego> not in my scope without me saying so it isn't
04:20:31 <quchen> dobblego: But it's also full of unimportant stuff, and that part should probably be put into a KitchenSink module
04:20:57 <merijn> RankNTypes strictly supercedes Rank2Types, right?
04:21:09 <quchen> Aren't they synonyms?
04:21:12 <donri> yes, the latter is being deprecated even i think
04:21:24 <merijn> donri: I never get warnings for Rank2Types so I doubt it
04:21:40 <donri> merijn: at some point
04:21:40 <sopvop> will people hate me for using -XTupleSections ?
04:21:46 <donri> i read some vague plans
04:21:48 <hvr> sopvop: haters gonna hate
04:21:57 <dobblego> sopvop: if they did, let me know, so I can use them more
04:22:14 <sopvop> I don't think my package will compile on anything besides GHC anyway
04:22:28 <quchen> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
04:22:34 <quchen> Doesn't mention anything about deprecation
04:22:38 <quchen> (Or synonym-ness) :-(
04:22:49 <sopvop> quchen: I was in release notes
04:22:52 <sopvop> It
04:22:55 <donri> it was on the ghc mailing list or something
04:23:09 <quchen> sopvop: I like tuple secions.
04:23:11 <merijn> sopvop: TupleSections is great!
04:24:05 <quchen> supki: Add TupleSections to my list of always-on extensions.
04:24:08 <quchen> I should just write a macro for my editor to enable all that stuff automatically.
04:24:08 <Lethalman> TupleSections and MultiWayIf always on
04:24:08 <sopvop> I've got tired from typing `(,,,) foo bar <$> something <*> something` and thought about risky syntax extensions :)
04:24:23 <donri> http://ghc.haskell.org/trac/ghc/changeset/984676d51291ea900cec289599e647de38645405/
04:24:31 <hpaste> merijn pasted “new .ghci” at http://lpaste.net/91204
04:24:38 <merijn> Any important extensions I'm missing?
04:24:56 <sopvop> merijn: OverloadedStrings
04:25:26 <merijn> sopvop: ಠ_ಠ
04:25:26 <Lethalman> make sure you have ExtendedDefaultRules together with OverloadedStrings
04:25:26 <dobblego> NoImplicitPrelude
04:25:26 <merijn> imports too, btw
04:25:39 <donri> merijn: mine that i haven't touched in a while http://lpaste.net/91205
04:25:40 <merijn> dobblego: Why would I want NoImplicitPrelude in my .ghci?!
04:25:45 <sopvop> -XNoMonomorphismRestriction :)
04:26:00 <merijn> sopvop: oh, good point
04:26:00 <quchen> sopvop: Careful, when proposing that TupleSections are good, you probably shouldn't be using 4-tuples in your example ;-P
04:26:00 <dobblego> merijn: just noticed it is .ghci
04:26:24 <merijn> donri: Are the derive ones actually useful in ghci?
04:26:41 <donri> merijn: for me yes
04:27:02 <merijn> How come?
04:27:27 <donri> uh testing code that uses generics for example?
04:27:55 <donri> and foldable/traversable for lens
04:28:05 <merijn> Wouldn't that just works when you load them?
04:28:21 <sopvop> what was -XPolymorphicComponents doing?
04:28:22 <donri> merijn: you can write data declarations in ghci since i think 7.4
04:31:16 <merijn> <- mind blown
04:31:22 <donri> \o/
04:31:51 <quchen> data declarations?
04:32:02 <quchen> Oh, in GHCi
04:34:58 <chrisdone> does anyone know if it's possible to kill all running threads in ghci?
04:35:28 <Taneb> Write, I'm sending a message to the libraries mailing list regarding the tuple monad instance
04:36:20 <Taneb> *right
04:37:48 <bitonic> chrisdone: well the usual way to kill threads is to throw exceptions at them
04:38:03 <chrisdone> bitonic: suppose i didn't fork the thread so i don't have the threadid
04:38:07 <bitonic> which is what “killThread” does
04:38:11 <bitonic> right, then I’m not sure
04:38:30 <bitonic> chrisdone: so how do you plan to find “which” thread to kill?
04:38:47 <bitonic> or do you just want to kill them all :P
04:38:55 <quchen> And killing GHCi is not an option?
04:38:59 <chrisdone> bitonic: yes, i want to kill them all without mercy
04:39:01 <chrisdone> quchen: no
04:39:16 <bitonic> chrisdone: OK, let’s see, this sounds like a useful thing to know
04:39:45 <chrisdone> note: running :load does not kill running threads in ghci
04:41:54 <merijn> I don't think you can kill threads unless you keep track of their ThreadId
04:42:12 <merijn> Which is why is usually want to wrap forkIO with some form of thread manager
04:43:15 <bitonic> merijn: well the hope is to find some GHC facility to get the ThreadIds of children
04:43:36 <merijn> I don't think there is
04:43:39 <merijn> At least not exposed
04:43:48 <bitonic> mhm, that’s a shame
04:43:55 <bitonic> I’d like something like “ps” for GHC
04:44:06 <Rarrikins> chrisdone: It appears the milestone for adding that is _|_
04:44:10 <Rarrikins> chrisdone: http://ghc.haskell.org/trac/ghc/ticket/1399
04:44:49 <ClaudiusMaximus> threadscope might hook into the relevant parts of ghc rts?
04:47:04 <chrisdone> Rarrikins: hm, sucks
04:49:06 <quchen> What happens when I reduce NumCapabilities at runtime? Are the OS threads killed, or do they have time to finish up (and die out as no sparks are given to them)?
04:50:40 <merijn> quchen: I would say they get graciously shutdown and all threads/sparks distributed to the others
04:50:54 <merijn> But that claim isn't verified or backed up by facts :p
04:51:44 <quchen>  > Sending all process the SLEDGEHAMMER signal.
04:52:27 <chrisdone> i tried setNumCapabilities 2 in ghci and it didn't even stop me launching three threads
04:52:31 <merijn> The monad and applicative implementations of ContT are confusing as fuck >.>
04:52:50 <merijn> chrisdone: capabilities determines the number of OS threads, it has nothing to do with haskell threads
04:52:57 <chrisdone> yeah every time i read or implement ContT i have to re-learn it
04:53:12 <quchen> I don't even need the T for Cont to confuse me
04:53:21 <merijn> chrisdone: Actually, it capabilities doesn't even relate to OS threads
04:53:28 <quchen> Oh?
04:53:47 <quchen> Then what is a capability?
04:53:57 <merijn> Capabilities refer to the number of cores to use
04:54:00 <chrisdone> http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/GHC-Conc-Sync.html#v:setNumCapabilities
04:54:13 <merijn> Which means you shouldn't have more computational threads than cores to use, obviously
04:54:24 <chrisdone> cores or processors or whatever gives true paralellism
04:54:27 <merijn> But using extra OS threads for blocking sys/foregin calls make sense
04:54:54 <chrisdone> ClaudiusMaximus: checking out threadscope's source now, seems interesting
04:54:56 <quchen> So a capability is an OS thread as long as there are less than cores on the machine?
04:55:09 <merijn> quchen: No
04:55:13 <quchen> And each of those OS threads is sent to a different CPU
04:55:15 <merijn> quchen: Capabilities aren't a thing
04:55:47 <merijn> quchen: They are a suggestion to the runtime "be adviced, there is no more than X concurrent computation units, so more than X computtional threads is useless"
04:55:56 <merijn> I don't think the RTS bothers to pin threads
04:56:16 <quchen> Ah, so the -N flag merely suggests GHC that it could use multiple cores
04:56:17 <chrisdone> http://hackage.haskell.org/packages/archive/ghc-events/0.3.0.1/doc/html/GHC-RTS-Events.html
04:56:23 <merijn> quchen: Yes
04:56:24 <chrisdone> ClaudiusMaximus: veeeery interesting
04:56:59 <quchen> merijn: And then GHC opens a couple of OS threads to satisfy its needs, with the upper boundary given by numCapabilities?
04:57:15 <chrisdone> ah, it's just parsing
04:57:26 <merijn> quchen: Not even upperbound, as I set, the RTS might want X parallel threads for computation + Y more to do blocking foreign calls
04:57:46 <merijn> Because blocking syscalls don't take up computational resources
04:57:51 <chrisdone> ClaudiusMaximus: yeah, threadscope just parses a file that ghc outputs
04:58:24 <merijn> s/as I set/as I sad/ <- lolwut
04:58:28 <merijn> dammit
04:58:30 <merijn> *said
04:58:34 <merijn> Screw typing!
04:58:39 <chrisdone> get out of here!
04:58:49 <ClaudiusMaximus> chrisdone: ah, but could you fork a thread in ghci that parses its own eventlog ?
04:59:09 <chrisdone> ClaudiusMaximus: i've never ran threadscope, does it output logging live?
04:59:14 <quchen> No
04:59:27 <chrisdone> then it's not useful
04:59:30 <quchen> At least not last time I used it
04:59:40 <quchen> Yes it was. At least last time I used it.
05:00:03 <ClaudiusMaximus> the eventlog is output live afaik
05:00:22 <chrisdone> i'll try it in ghci
05:00:36 <ClaudiusMaximus> maybe ghci isn't linked with eventlog support, but who knows..
05:01:10 <chrisdone> nope: Prelude> :set -eventlog
05:01:10 <chrisdone> Some flags have not been recognized: -eventlog
05:01:54 <chrisdone> ah wait
05:02:00 <chrisdone> running ghci -eventlog didn't fail. let's see…
05:03:15 <ClaudiusMaximus> chrisdone: $ ghci +RTS -l
05:03:16 <ClaudiusMaximus> ghc: the flag -l requires the program to be built with -eventlog or -debug
05:03:45 <ClaudiusMaximus> gotta go...
05:04:43 <chrisdone> ClaudiusMaximus: right, i may have to rebuild ghci. pff…
05:09:34 <jonkri> In what order are functions evaluated? For example, in "1:2:3:[]", "Haskell" seems to know to apply 3:[] first, before for example 1:2. Why is this? I would have expected 1:2 to evaluate first, like left to right.
05:10:15 <chrisdone> Prelude Unsafe.Coerce Control.Concurrent Data.Word> unsafeCoerce (1 :: Word32) :: ThreadId
05:10:15 <chrisdone> ThreadId Segmentation fault (core dumped)
05:10:16 <chrisdone> darn =p
05:10:28 <dcoutts> jonkri: you're confusing two things: evaluation order and the parenthesis / operator precedence
05:10:45 <dcoutts> jonkri: in 1:2:3:[] there is nothing to evaluate, it's already in normal form
05:11:02 <dcoutts> jonkri: what you're really wondering about here is how the parens work here
05:11:15 <quchen> chrisdone: And they told me there were no core dumps in Haskell!
05:11:38 <quchen> chrisdone: ThreadID is very reluctant, I tried getting it as an Int once and got very mad.
05:11:40 <dcoutts> jonkri: ie should the : operator behave like ((1:2):3):[] or like 1:(2:(3:[]))
05:11:55 <dcoutts> jonkri: or similar question about 1 + 2 + 3
05:12:22 <chrisdone> quchen: last time i needed a thread id as a string i used show and parsed it
05:12:25 <dcoutts> jonkri: all these operators have an associativity (left, right or none) and a precedence
05:12:50 <dcoutts> jonkri: you can find out in ghci by asking: :info :
05:12:51 <quchen> chrisdone: That would be the hate-hack solution. (Did the same.)
05:12:57 <jonkri> dcoutts: Aha. I know about precedence.
05:13:08 <dcoutts> jonkri: right, so in this case it's infixr 5 :
05:13:24 <dcoutts> jonkri: infix"r" for right-associative
05:13:28 <jonkri> Ah, I never noticed the 'r' in infixr.
05:13:33 <dcoutts> and precedence level 5
05:13:38 <ski_> there's also `infixl' and `infix'
05:13:40 <dcoutts> infixl 6 +
05:13:57 <dcoutts> that says + is left associative and precedence 6
05:14:09 <jonkri> I see.
05:14:11 <dcoutts> jonkri: so that means that 1 + 2 + 3  is really (1+2) + 3
05:14:26 <dcoutts> while 1 : 2 : 3 : [] is  1:(2:(3:[]))
05:14:48 <quchen> chrisdone: Would "toInt :: ThreadID -> Int" be a worthy proposal?
05:14:59 <dcoutts> jonkri: and note again that this is just parsing, not evaluation
05:15:52 <jonkri> How would you define evaluation
05:15:59 <jonkri> Nevermind, I was about to erase that. :-P
05:16:13 <dcoutts> jonkri: there's several good tutorials with explanations
05:16:14 <chrisdone> quchen: it exists here http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/src/GHC-Conc-Sync.html#ThreadId
05:16:28 <chrisdone> quchen: foreign import ccall unsafe "rts_getThreadId" getThreadId :: ThreadId# -> CInt
05:16:28 <chrisdone> quchen: id2TSO :: ThreadId -> ThreadId#;  id2TSO (ThreadId t) = t
05:16:34 <chrisdone> quchen: it's intentionally not exposed, i expect
05:17:07 <quchen> I think ThreadID -> Int would be a useful function. On the other hand, it's a good idea to not have the reverse direction.
05:18:09 <merijn> quchen: WHy do you need ThreadID -> Int?
05:18:11 <chrisdone> yeah. you can basically make ThreadId -> Int with show, so i suppose it can't hurt for it to be exposed
05:18:25 <chrisdone> merijn: i've needed it in the past when i want to refer to a particular ongoing job
05:18:25 <mauke> safeCoerce = read . show
05:18:55 <merijn> mauke: oh, you should submit that to acme-php
05:19:03 <merijn> Maybe rename it "cast"
05:19:17 <chrisdone> merijn: i could generate a UID for it myself, but it's rather pointless when the thread id's sitting there
05:19:22 <quchen> Specialize it to a -> Int and call the function (int)
05:19:31 <merijn> chrisdone: Except that ThreadIds can be reused
05:19:39 <quchen> merijn: I don't *need* it, it was just somewhat useful in the past and I had to hack it in. I don't remember the use case though. Let me think …
05:19:56 <chrisdone> merijn: you mean once the thread has ended and a new thread has started?
05:19:56 <merijn> chrisdone: So you can have multiple jobs with the same id
05:20:03 <merijn> chrisdone: Yes
05:20:24 <chrisdone> merijn: yeah, so once the thread ends, the job ends and the id is free to be re-used. i don't see the problem
05:20:41 <chrisdone> (in fact, the re-usability is partly what's nice about it)
05:20:52 <merijn> chrisdone: Sure, it might be safein yur case, but if someone is logging job ids, for example
05:20:56 <chrisdone> you don't want some ever-increasing number
05:20:58 <merijn> Best to just not encourage it
05:21:30 <merijn> Because unlikely things can turn into bugs at the most unexpected of times!
05:21:31 <chrisdone> if they're logging job ids then they'll log "this job finished"
05:21:47 <quchen> merijn: Ah, here's an example. I wrote this decentralized P2P chat, and each message was broadcast to adjacent clients from individual threads. At some point I would have liked the receiver to know exactly which of the threads of the sender the thing came from.
05:21:48 <chrisdone> just like process ids in unix
05:22:23 <quchen> merijn: If your follow-up question now is why the receiver needs to know about that I would have to think again.
05:23:04 <merijn> :p
05:23:06 <chrisdone> well the use-case isn't anything new, you have the same thing with process IDs
05:23:40 <quchen> merijn: Another example: every thread generates its own seed for a RNG, and puts its own ThreadID in the pool.
05:23:47 <merijn> You could used string ids and used the show instance of ThreaId :p
05:24:05 <quchen> merijn: Hence mauke's safeCoerce proposal. :-)
05:24:25 <chrisdone> merijn: that's what we both did
05:24:27 <quchen> You have to add `drop (length "threadid: ")` though because the Show instance.
05:24:29 <merijn> You don't even need that, just "show" would be sufficient as Identifier
05:24:43 <merijn> hell, even using the ThreadId directly as identier would work...
05:24:55 <quchen> merijn: But maybe I want to square the ThreadID.
05:24:59 <merijn> I don't see the advantage of it being an int
05:25:13 <merijn> quchen: Even better that you can't, then!
05:25:24 <merijn> Subtle bugs are the worst kind of bugs!
05:25:41 <quchen> I'm not sure squaring a threaad ID counts as subtle :P
05:26:07 <merijn> No, but in general "ThreadId -> Int" would open up room for a lot of subtle ones
05:26:34 <quchen> I remember thinking that as well, but for some reason really wanting it as an Int.
05:26:36 <merijn> Type conversions are evil!
05:26:41 <chrisdone> i didn't do any manipulation of the id itself, just used it as a unique identifier. mostly i wanted an int for printing
05:26:52 <chrisdone> it's nicer to read "Job 3 ended" rather than "Job ThreadId 3 ended"
05:27:11 <Yuu-chan> I need to draw some lines in the window. Could someone recommend a simple graphic library?
05:27:20 <merijn> "dropWhile (/=' ') . show"
05:27:20 <chrisdone> SDL?
05:27:31 <quchen> merijn: Oh, chrisdone just gave us the killer reason: Show is for serialization, and not for prettyprinting.
05:27:36 <chrisdone> merijn: yeah thanks for that hard program, we didn't figure that out
05:27:39 <merijn> :p
05:27:42 <quchen> We need a prettyprinting ThreadID function.
05:27:53 <merijn> quchen: See, that I'd accept
05:27:57 <quchen> 'd
05:28:10 <applicative> Yuu-chan: I'm not sure what you mean by window, but gloss is pretty straightforward
05:28:13 <quchen> So - no, I don't accept that, but I would if you sent me cupcakes? :D
05:28:31 <Yuu-chan> chrisdone: I've thought of that and of OpenGL, and I'm curious if there are more high-level functional approaches, some combinator library, maybe
05:28:37 <merijn> hah, I just went back to check
05:28:40 <quchen> merijn: In retrospect, that may have been the reason I wanted it multiple times. But I can't say that anymore, confirmation bias etc.
05:28:49 <DanielDiaz> Yuu-chan: gloss is a nice one. http://hackage.haskell.org/package/gloss
05:28:54 <chrisdone> Yuu-chan: ah, there are, i'm not familiar with them, others here know
05:29:06 <yesthisisuser> what about gtk2hs? http://projects.haskell.org/gtk2hs
05:29:11 <merijn> The conversion bug from yesterday goes all the way back to the original implementation of the new io manager in 2010, in other words, it never worked correctly :O
05:29:15 <jonkri> dcoutts: Thanks a lot for your help. :-)
05:29:33 <dcoutts> jonkri: np
05:29:37 <quchen> merijn: OOOohh, so that's where your disregard for type conversions comes from.
05:29:43 <quchen> Now everything makes sense :D
05:29:51 <applicative> Yuu-chan: http://gloss.ouroborus.net/ has still image examples
05:30:06 <Yuu-chan> Gloss looks interesting, thank you all!
05:30:26 <yesthisisuser> Yuu-chan: here are some drawing examples for gtk2hs and Cairo: http://code.haskell.org/gtk2hs/cairo/demo/
05:31:13 <applicative> if you do 'cabal unpack gloss-examples' you can study a series of increasingly complicated uses
05:32:00 <Yuu-chan> yesthisisuser: does Cairo works well for Windows?
05:32:33 <yesthisisuser> Yuu-chan: I have never used it on windows but i think it should.
05:32:52 <DanielDiaz> Yuu-chan: Cairo worked perfectly for me in Windows, and I have used it lot of times. You may need some dll's though.
05:33:33 <Yuu-chan> Ok, thanks, I'll consider cairo too.
05:34:19 <DanielDiaz> Yuu-chan: the nice thing about cairo is that you can export nice images to files.
05:35:00 <yesthisisuser> i don't know how solid the Haskell bindings are but GTK+ is usually fine on any supported platform
05:35:21 <DanielDiaz> Yuu-chan: However, gloss is capable of doing animations in a very easy way.
05:35:41 <SLi> Not that I want to troll, but why is it that nearly always when I want to cabal install something bigger (in this case leksah), something fails to build? First gio and pango, which had to be fixed with a magical incantation of cabal install --reinstall gtk2hs-buildtools, and now ltk, which fails with "Not in scope: `catch'".
05:36:21 <quchen> Prelude.catch was removed in the last release of GHC (after being deprecated for some time). How old is the package you tried to install?
05:36:32 <applicative> ouch thats a version problem
05:36:38 <applicative> oh as quchen says
05:36:39 <quchen> (Assuming that's where the issue came from)
05:36:45 <merijn> quchen: Sounds right
05:37:18 <merijn> I feel I should be able to use ContT to solve my problem of mixing StateT and bracket, but I can't figure out how :(
05:37:20 <SLi> Um, I don't know. I just said cabal update && cabal install leksah. So I assume it would try to install the newest ltk? (0.8.0.6 is the version)
05:37:40 <SLi> Hm, definitely not the newest.
05:37:52 <SLi> I don't know why it's trying to install that.
05:37:58 <merijn> Last version from leksah seems to be from 2012
05:38:14 <SLi> 0.8.0.6 is from 2010.
05:38:19 <quchen> 2012 was 7.4-platrorm-territory, which still had Prelude.catch
05:38:35 <applicative> how old is your ghc SLi, this is an old hackage v newer hackage problem
05:38:38 <SLi> cabal install ltk tries to install 0.8.0.6.
05:38:47 <merijn> tbh, I'm not sure how well leksah is actually maintained
05:38:51 <quchen> SLi: ghc --version?
05:38:58 <SLi> My ghc is from Debian unstable, 7.6.3.
05:39:01 <quchen> Hm.
05:39:14 <quchen> Well, that's as current as it gets.
05:39:28 <quchen> I guess it's Leksah's fault then.
05:40:31 <applicative> hm, I though it was still maintained
05:40:32 <SLi> merijn: Ah. Any recommendations for a Haskell dev environment? :) I've been using emacs and I'm semi-happy with it (basically my only gripes are with somewhat broken indentation), but I'd be willing to give other environments a try.
05:40:34 <quchen> If it helps, I'm not a fan of Leksah myself and would like to recommend you another editor, and in the process turn this channel into a warzone.
05:40:34 <applicative> uh oh, editor war
05:40:34 <SLi> :)
05:40:39 <applicative> SLi, nano ftw!
05:40:46 <quchen> I use Notepad with Wine.
05:41:02 <applicative> quchen: awesome
05:41:50 <SLi> Mostly I was just curious about what such an IDE has to offer. For example, I guess something could help by displaying types on the fly and highlighting the smallest non-typechecking subexpression instead of the entire line like emacs does? :)
05:41:51 <applicative> i just wish I had something that would read my handwriting, then i would be really productive. whitespace is a problem ...
05:42:03 <bitonic> SLi: the latter is going to be hard because not even GHC does that
05:42:05 <bitonic> you just get a line
05:42:09 <SLi> bitonic: ok.
05:43:18 <SLi> While we're on the subject, I'd like to have a touchscreen & virtual keyboad usable Haskell editor. And a pony. Please.
05:43:19 <quchen> applicative: Right, writing Haskell by hand would solve all our problems.
05:43:20 <merijn> SLi: Most people here just use vim or emacs, I think
05:43:21 * quchen is special
05:43:33 <merijn> SLi: Wanna see something cool (but completely not practically usable yet)?
05:43:53 <MercurialAlchemi> SLi: vim + syntastic + ghc-mod
05:44:00 <applicative> i don't know if that's right, merijn, exactly, it's just that they're the ones people bother to talk about - for good reason of course
05:44:09 <SLi> Ok. Guess I'll stick to emacs then :) I'm somewhat unhappy with it's indenting though. Not how it indents, but that pressing tab sometimes messes the correct indentation and pressing it no matter how many times never fixes it.
05:44:12 <merijn> SLi: The future of statically, strongly typed functional IDEs: https://github.com/Peaker/lamdu
05:44:14 <SLi> merijn: maybe :)
05:44:42 <merijn> MercurialAlchemi: If you need a good auto-indent to go with that, I've got you covered! :p
05:44:50 <quchen> merijn: Is there a x86 version of that I could download and test?
05:45:09 <SLi> merijn: I guess I'll take a look :)
05:45:14 <merijn> quchen: It doesn't build from cabal? Last time I tried it *just compiled*
05:45:16 <applicative> lambdu is pretty wild
05:45:36 <merijn> SLi: type based auto-completion, on the fly typechecking, etc.
05:45:46 <quchen> merijn: Can I install the dependencies locally somehow? So everything stays in the Lamdu folder
05:45:54 <merijn> quchen: cabal-dev?
05:46:07 <quchen> cabal install cabal-dev?
05:46:11 <quchen> Never used it
05:46:11 <merijn> yeah
05:46:25 <merijn> quchen: cabal-dev just creates a project speficic package database
05:46:34 <MercurialAlchemi> merijn: I don't know, the auto-indent is OK?
05:46:46 <quchen> merijn: And apart from that it's just like cabal? Same flags etc?
05:46:52 <merijn> Just "cabal-dev install" instead of "cabal install" for a project
05:46:53 <MercurialAlchemi> merijn: I'd be more interested in a "manage imports and exports" feature
05:46:54 <merijn> quchen: I think so?
05:46:57 <quchen> Cool.
05:47:16 <applicative> quchen: try the development version of cabal, with the de-luxe cabal sandbox
05:47:27 <applicative> or maybe not ..
05:47:33 <SLi> "Code stored as code solves most merge conflicts. With textual tools a line where two variables were renamed causes a conflict. Just moving around code also generates a lot of spurious conflicts -- which will no longer be the case." That sounds a bit scary. Because a small number of trivial merge conflicts is often better than an automerge gone wrong (a changed variable name may indicate that the purpose of the variable changed too, so it may not be what the
05:47:33 <SLi> conflicting committer intended).
05:47:33 <quchen> applicative: Heard of that, but I'm a little afraid of it.
05:47:37 <SLi> But maybe it's worth a try :)
05:47:39 <merijn> MercurialAlchemi: My work-in-progress autoindenter is at https://github.com/merijn/haskellFoldIndent, the import/export thing I dunno if someone is doing that
05:48:12 <applicative> quchen: I made bold to install it, probably thinking similarly, and it's totally changed everything for me.
05:48:23 <merijn> SLi: The point is that they do version control at an AST level, rather than text level
05:48:31 <applicative> but I'm not actually arguing for early adoption
05:48:34 <quchen> applicative: How is it deluxe-r than cabal-dev?
05:48:39 <MercurialAlchemi> merijn: cool
05:48:44 <merijn> SLi: So moving a function and changing a function are trivially mergable, unlike textual diffs which can't see that
05:48:52 <applicative> quchen i think its similar
05:48:54 <SLi> Basically I treat a merge conflict as "hey, there's something messy here, please check". But I do realize that I'm much more used to merge conflicts and much less afraid of them than many other people :)
05:49:04 <quchen> applicative: But more integrated into Cabal etc. I see.
05:49:05 <SLi> merijn: yup. As long as it's not too zealous, that's probably good.
05:49:36 <merijn> SLi: But they're implementing their own language for this thing, so it's not really suitable for "real" programming, but it's an insanely cool prototype :)
05:49:44 <applicative> quchen: i think thats right; in some ways its weaker -- if I remember, theres a cabal-dev ghci that got things right
05:49:48 <SLi> merijn: ah, it wasn't Haskell :)
05:49:58 <quchen> How do I disable profiling again? When I'm using cabal-dev for a local install, I really don't need the .p_o
05:49:58 <merijn> SLi: No, it's very haskell inspired, though
05:50:04 <quchen> -disable-prof isn't working
05:50:24 <applicative> is there a local cabal.config sort of file it respects?
05:50:32 <merijn> SLi: Haskell is rather big and complicated to implement, though so that'd be a bit unwieldy to work with
05:50:54 <MercurialAlchemi> merijn: looks cool, I'll try it as soon as I'm back coding for fun instead of coding for profit
05:51:12 <SLi> But basically I tend to think that the closer two changes are to each other in the source, the bigger the probability that the trivial merge is not the right one, and I think current SCM merge conflicts are mostly a fairly good approximation of "it would be good that someone human looked at this before proceeding".
05:52:57 <SLi> Of course if type checking can be integrated in the merge process, it's possible to eliminate not currently conflicting merges that cause a build failure (or even new warnings), which would be good :)
05:53:07 <applicative> SLi: Peaker is on this channel pretty frequently, he will defend his position capably
05:53:16 <applicative> ...
05:53:27 <merijn> hmmm
05:53:29 <SLi> :)
05:53:37 <merijn> I just looked at the implementation of bracket
05:53:40 <MercurialAlchemi> you'll tear my code files from my cold, dead hands
05:53:59 <applicative> merijn: and burst into tears ?
05:54:00 <merijn> As far as I can see bracket isn't safe if your resource acquisition can black...
05:54:07 <merijn> s/black/block
05:54:26 <quchen> merijn: In what sense is it not safe?
05:54:35 <merijn> It uses mask, rather than interruptibleMask, so if you block in resource acquisition you can still be interrupted and leak partially acquired resources
05:54:42 <merijn> eh
05:54:54 <merijn> UNinterruptibleMask
05:55:03 <quchen> merijn: I think Marlow's book talks about that.
05:55:05 <merijn> quchen: Not safe in the sense that it's supposed to prevent resource leaks, but doesn't
05:55:52 <merijn> I should maybe read the concurrency part of it
05:55:53 <quchen> When discussing the `mask` in the section about async exceptions he brings up issues with mask and uninterruptibleMask
05:56:04 <quchen> Maybe that's relevant here.
05:56:05 <quchen> Maybe not.
05:58:30 <merijn> I looked at the "mask and forkIO" section, but it's not discussed there, I'll just start reading the start to see if I run into a discussion
05:59:10 <MercurialAlchemi> merijn: I'll try your plugin as soon as I'm back coding for fun instead of for profit
05:59:26 <merijn> MercurialAlchemi: Lemme run if you run into anything
05:59:32 <mauke> if your resource acquisition isn't atomic, you're screwed anyway, no?
05:59:34 <merijn> oh: "But before should perform only one blocking operation. An exception raised by a second blocking operation would not result in after being executed. If you need to perform two blocking operations, the right way is to nest calls to bracket"
05:59:46 <merijn> mauke: Why?
05:59:58 <mauke> because otherwise it can't be used safely
06:00:13 <merijn> I don't see why that's necessarily true?
06:01:10 <merijn> I'm doing cleanup of threads, i.e. there's a cleanup that should kill a thread and clean it resources, but if the thread dies it should also cleanup and deregister it's cleanup hook
06:01:40 <merijn> This means that my resource acquisition is two steps "acquire resource, register handler"
06:02:00 <applicative> @type \a f g -> bracket (bracket a f g)
06:02:01 <lambdabot> IO a1 -> (a1 -> IO b1) -> (a1 -> IO a) -> (a -> IO b) -> (a -> IO c) -> IO c
06:02:03 <merijn> The handler registration can block if there's contention on the cleanup
06:02:05 <applicative> nice
06:02:16 <merijn> So I want either *both* to happen, or neither
06:02:43 <merijn> But that means I should not ever get interrupted while registering the handler
06:02:54 <mauke> can you mask manually?
06:03:10 <merijn> with mask it's possible to block for a bit and get interrupted in there
06:03:37 <merijn> mauke: I can write my own code using uninterruptibleMask, it's just that everyone always yells "you shouldn't use mask yourself!"
06:04:29 <merijn> So I wondered if there was an existing safe approach
06:04:29 <merijn> But it looks like I should just assume I'm a aware of the dangers of uninterruptibleMask and do things myself :)
06:05:50 <quchen> Assuming is not a very good start with that function.
06:06:41 <merijn> quchen: I've worked on a concurrent runtime system in C using pthreads, I'm an adept at foot shooting :)
06:06:47 <quchen> unsafePerformIO getYear -- Assuming everyone celebrates on New Year's and doesn't run my program
06:07:09 <de-Vri-es> hey, I just compiled a simple helloword with and without optimization, but I didn't see any difference in an objdump from both versions
06:07:14 <de-Vri-es> any idea why that may be?
06:07:33 <merijn> quchen: I like to think I'm experienced enough at this to ignore all the "experts-only" warnings :)
06:07:43 <merijn> de-Vri-es: There's not much to optimise about hello world?
06:07:46 <applicative> maybe de-Vri-es there's not too much scope for optimization with hello world
06:07:53 <mauke> de-Vri-es: did it say "compiling" each time?
06:07:53 <quchen> Oh yes there is
06:08:02 <merijn> mauke: oh, good point
06:08:05 <merijn> mauke++
06:08:05 <de-Vri-es> ehh, let me see
06:08:19 <merijn> I've fallen into that trap so often
06:08:21 <applicative> good point mauke
06:08:24 <de-Vri-es> mauke: no it didn't
06:08:26 <quchen> Compare the output of "ghc -O helloworld.js -ddump-simpl -fforce-recomp" with the one without O
06:08:31 <quchen> There's one hell of a difference
06:08:33 <mauke> de-Vri-es: -fforce-recomp
06:08:55 <de-Vri-es> I see, didn't know it doesn't do that
06:08:57 <de-Vri-es> thanks
06:09:01 <applicative> quchen: its helloworld.hs, please
06:09:04 <merijn> quchen: helloworld.js ಠ_ಠ ಠ_ಠ
06:09:27 <quchen> You guys didn't get the memo? SPJ is now working on Node.js
06:09:29 <merijn> de-Vri-es: It tries to be smart about recompiling, since the code didn't change it was like "I don't need to recompile"
06:09:40 <quchen> I should be careful now. :>
06:09:51 <merijn> de-Vri-es: i.e. ghc behaves like make
06:09:55 <applicative> de-Vri-es: i made a stupid alias, hclean, that crushes the o and i files, which i somehow forget less than --fforce-recomp
06:09:55 <de-Vri-es> merijn: I just kinda assumed it would delegate that to a build tool
06:10:18 <quchen> applicative: A --clean flag (the inverse of --make) would be pretty cool.
06:10:28 <merijn> de-Vri-es: Nope, one of the advantages of a proper module system is no unnecessary recompiles :)
06:10:49 <de-Vri-es> good to know :)
06:11:05 <quchen> Meanwhile, Lamdu is still compiling.
06:11:31 <applicative> de-Vri-es: it's irritating when you're writing a short executable, this default, but with beyond that, the sensibleness of the default shows itself
06:12:09 <quchen> merijn: Oh, ghc-dev doesn't use the global package DB at all? It even installs the packages I already have locally again?
06:12:10 <de-Vri-es> applicative: yeah. it makes sense, as long as you know about it
06:12:15 <merijn> quchen: Yeah
06:12:22 <quchen> Even the Platform stuff then?
06:12:28 <quchen> That explains the compilation time
06:12:43 <applicative> de-Vri-es: yes, exactly
06:12:45 <merijn> quchen: Yeah, it's one of the main reasons I don't usually use cabal-dev
06:13:20 <quchen> merijn: Do you know anything about when parallel building is coming?
06:13:23 <applicative> when ghc is re-building, it emits claims like 'recompilation not needed'
06:13:26 <quchen> 7 cores are bored here
06:13:42 <merijn> quchen: I think cabal already supports parallel builds?
06:13:51 <applicative> of course it does
06:14:05 <applicative> -j37
06:14:41 <quchen> Wat.
06:14:49 <quchen> Did I just miss the existence of that parameter then
06:14:51 <applicative> its recent
06:14:59 <quchen> Is it in the Platform?
06:15:08 <applicative> but its in the going cabal-install Im pretty sure
06:15:22 <merijn> quchen: Fun fact, you can install newer cabal-install versions no problem
06:15:37 <merijn> gah
06:15:50 <merijn> Let me guess
06:15:50 <quchen> merijn: What's cabal-install good for anyway, how is it different from "cabal install"?
06:15:57 <merijn> ContT won't work with Rank2Types?
06:15:57 <applicative> I think its in the cabal-install the comes with the recent platform
06:15:57 <t7> how do i parrellel zipWith?
06:16:05 <merijn> quchen: cabal-install *is* the cabal binary
06:16:09 <quchen> merijn: I just found out I don't even have cabal-install
06:16:10 <quchen> Oh.
06:16:15 <quchen> And cabal is a link to it?
06:16:39 <mauke> http://hackage.haskell.org/package/cabal-install
06:16:41 <merijn> quchen: cabal (the package name) is the library, cabal-install (the package name) is the executable caal
06:16:56 <mauke> http://hackage.haskell.org/package/Cabal
06:17:11 <applicative> there's an irritating ambiguity.
06:17:32 <quchen> merijn: But the thing I enter in my command line is "cabal", not "cabal-install".
06:17:42 <quchen> Oh.
06:17:42 <applicative> t7 parallel zipWith?
06:17:43 <applicative> hm
06:17:48 <merijn> quchen: Yes, he cabal-install package installs a binary named cabal
06:17:48 <quchen> Bloody hell.
06:17:55 <quchen> Alright, I think I got it now.
06:18:06 <quchen> Sorry, I'm a bit slow. It's warm and I have this birth defect.
06:18:07 <applicative> quchen: 'cabal-install' is just a way of speaking, following the executable's package name, to disambuiguage
06:18:13 <applicative> disambiguate too
06:18:30 <mauke> coambiguate
06:18:42 <quchen> AAAAAAAH now Lamdu installs Lens locally
06:18:46 <quchen> I should have done this over night
06:18:50 <applicative> hahah
06:18:59 <quchen> ExitFailure 1
06:19:03 <quchen> Screw it :-C
06:21:05 <quchen> applicative: I see, "cabal install cabal-install" looks much more reasonable than "cabal install cabal".
06:21:11 * Yaasky is new to Haskell
06:21:22 * Yaasky loves infinite primes (:
06:21:34 <ski_> infinite primes ?
06:21:37 <mauke> inb4 nubBy
06:21:47 <Yaasky> yep.
06:21:58 <mauke> most primes are finite
06:22:25 <applicative> yes, mauke but they are infinite ;)
06:22:40 <Yaasky> I know but I have never been able to compute that from imperative programming. always thought they were just theories
06:22:49 <Yaasky> mathematical theories
06:23:08 <applicative> I see, that you can define primes :: [Integer], for example
06:23:28 <Yaasky> yes, without an upper bound
06:23:32 <applicative> It is very strange and wonderful Yaasky
06:23:41 <applicative> of course you pay for it in some ways!
06:23:43 <ghorn_> ll
06:24:20 <mauke> ls -lh
06:24:21 <Yaasky> I'm yet to know the costs. Right now, it's free. I'm still new
06:25:11 <applicative> Yaasky: no, Im not objecting to it, it is just closely bound up with other features of Haskell that have plusses and minuses.
06:25:22 <applicative> Of course it is overwhelmingly beautiful
06:26:44 <applicative> Yaasky: take a look at http://www.cs.bham.ac.uk/~mhe/papers/seemingly-impossible.html or in its original form, sort of, http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
06:27:32 <Yaasky> Thanks applicative! This is the reason I am here: to learn more
06:27:33 <quchen> > nubBy(((>1).).gcd) -- Did soneone say primes?
06:27:34 <lambdabot>   <[Integer] -> [Integer]>
06:27:35 <b2coutts> applicative: I'm curious; how do you pay for it?
06:27:48 <b2coutts> I thought that it was pretty much free
06:28:03 <applicative> b2coutts: I was just making the obvious point, it's bound up with laziness
06:28:26 <mauke> ... and there's the nubBy!
06:28:42 <b2coutts> applicative: oh, as in you pay for it by having some of the less desirable properties of laziness, not with a performance loss?
06:28:51 <applicative> I was just trying to avoid being excessively enthusiastic b2coutts though of course I am excessively enthusiastic
06:28:56 <b2coutts> haha
06:29:18 <applicative> b2coutts: right, I wasn't being clear really
06:29:35 <jevankovich> Don't forget being able to represent images as infinitely definite functions over the reals. That's nice too
06:30:20 <Yaasky> I have no idea what that is, jevankovich, but it does sound useful
06:32:02 <merijn> heh
06:32:06 <jevankovich> you can have a function "image :: Float -> Float -> Color" and sample it any where whenever you need it. You don't need to worry about storing all of those points in an array like would be standard in an imperative language
06:32:19 <merijn> I've been overcomplicating my code with MVar's to communicate a threads id to the thread
06:32:36 <merijn> Totally forgetting the fact that there's like a completely simple "myThreadId" available...
06:32:54 <Yaasky> ah true, jevankovich
06:33:33 <quchen> merijn: I'm looking forward to the point where you'd like to have it as an Int :>
06:33:38 * hackagebot unix-process-conduit 0.2.1 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.1 (MichaelSnoyman)
06:37:35 <b2coutts> jevankovich: is that a horrible way of doing it in terms of performance/space, or is this one of those cases where GHC is magic?
06:38:01 <b2coutts> also wouldn't those be ints?
06:41:29 <jevankovich> b2coutts: The way I used it I used floats from 0 to 1 and I did this in a raytracer. If it was done for loading an image from storage that wasn't going to be transformed, this would be fairly awful I'd imagine. For how I used it (I also did something similar to represent the volume I was raytracing) it made representing transformations really nice
06:41:37 <applicative> b2coutts: I think jevankovich is thinking of the image itself as Float -> Float -> Color, then you so to speak interpret it
06:41:42 <applicative> oh hes explaining
06:42:00 <jevankovich> It's nice for arbitrarily generating images
06:43:01 <merijn> hmm
06:43:08 <merijn> I've got a nice tricky question
06:43:27 <b2coutts> jevankovich: oh, cool, I was thinking of a bitmap
06:43:40 <b2coutts> er, a pixel map
06:43:47 <b2coutts> you know what I mean >_>
06:43:57 <bscarlet> merijn: I, for one, am waiting to be tricked.
06:44:42 <merijn> Do these have the same effect? "do { tid <- myThreadId; putMVar m (killThread tid) }" vs "do { putMVar m =<< (myThreadId >>= killThread) }"
06:45:03 <merijn> oh, I guess they do
06:45:33 <merijn> because of the =<< requires "myThreadId >>= killThread" to be evaluated before being able to get it out
06:45:36 <applicative> wait do the types fit
06:45:56 <mauke> @. pl undo do { tid <- myThreadId; putMVar m (killThread tid) }
06:45:56 <lambdabot> putMVar m . killThread =<< myThreadId
06:45:59 <applicative> oh isee
06:46:12 <merijn> actually, now I'm doubting again
06:46:16 <merijn> About the second
06:46:33 <mauke> @unpl putMVar m =<< (myThreadId >>= killThread)
06:46:33 <lambdabot> ((myThreadId >>= killThread) >>= (putMVar m))
06:46:37 <applicative> @undo do { tid <- myThreadId; putMVar m (killThread tid) }
06:46:37 <lambdabot> myThreadId >>= \ tid -> putMVar m (killThread tid)
06:46:40 <mauke> @. redo unpl putMVar m =<< (myThreadId >>= killThread)
06:46:40 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
06:46:54 <mauke> @. do unpl putMVar m =<< (myThreadId >>= killThread)
06:46:55 <lambdabot> (do { a <- (do { a <- myThreadId; killThread a}); (putMVar m) a})
06:47:17 <mauke> the second one puts the result of killing tid
06:47:50 <merijn> hmm I guess I wanted "do { putMVar m (myThreadId >>= killThread) }"
06:47:56 <merijn> That's what I get for simplifying on the fly
06:48:04 <mauke> that would kill the wrong thread, no?
06:48:06 <merijn> I suspect that one kills the thread reading
06:48:12 <merijn> mauke: Yes, hence my question :p
06:48:25 <merijn> mauke: I was checking that that would indeed kill the wrong one
06:51:23 <bscarlet> merijn: Well, I'm confused at least. Which one kills the wrong thread and why?
06:52:21 <fmardini> Hi, finding it a bit hard to wrap my head around the type signature of (.) . (.)
06:52:32 <fmardini> any ideas on how to tackle
06:52:56 <merijn> bscarlet: The second one
06:53:16 <merijn> bscarlet: i.e "putMVar m (myThreadId >>= killThread)"
06:53:30 <merijn> bscarlet: because the myThreadId will be evaluated in the reading thread, not the writing thread
06:55:08 <bscarlet> merijn: so (once you've made the correction), you're talking about an MVar (IO ())?
06:55:37 <jevankovich> fmardini: the type of (.) is (b -> c) -> (a -> b) -> a -> c . When you put the first argument as (.) b is bound to a different (b -> c) and c is bound to a different ((a -> b) -> a -> c)
06:56:22 <merijn> bscarlet: Yes
06:56:34 <merijn> bscarlet: The first one is MVar (IO ()) too
06:56:47 <merijn> bscarlet: The original second one had the wrong type
06:57:17 <applicative> @pl \f g x y  -> f (g x y)
06:57:18 <lambdabot> (.) . (.)
06:57:35 <Yaasky> fmardini: you can extrapolate what jevankovich said to the signature of (.) . (.) which is (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:58:17 <bscarlet> merijn: Thanks.
06:59:36 <applicative> fmardini: one if constantly combining signs like so even (x + y) , length (x ++ y) etc. this abstracts the pattern
06:59:43 <applicative> one is forever ...
07:00:15 <applicative> somehow, the abstraction is not quite as useful as say foldr or (.) itself ...
07:00:52 <fmardini> jevankovich: thanks. this seems to have "uncurried" the second function of the composition. this is what is confusing me
07:01:05 <applicative> @type let owl f op x y = f (op x y) in owl
07:01:06 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
07:01:14 <merijn> fmardini: My advice is, take a pen and paper, write out the types of all components and start substituting by hand
07:01:42 <mauke> get a type writer
07:02:22 <hpaste> merijn pasted “Managed threads without resource leaks!” at http://lpaste.net/91208
07:02:36 <merijn> Right, I think that's as safe as I can get it
07:02:57 <applicative> fmardini: yes, in order to make sense of (.).(.) the types end up being specialized, the second argument must take two arguments so to say
07:03:00 <fmardini> merijn: will give it a shot
07:03:34 <merijn> fmardini: Hell, I did that not 10 minutes ago to figure out how ContT works :)
07:04:09 <fmardini> merijn: :) gotta love them types
07:04:20 <applicative> fmardini, the case is similar to
07:04:23 <applicative> @type flip id
07:04:24 <lambdabot> b -> (b -> c) -> c
07:04:41 <jevankovich> fmardini: It might be a good idea to give each function new type variables. That way it'll be harder to mix everything up
07:04:53 <applicative> here, if it is to make sense, id has to be specialised to (b->c) -> (b->c)
07:05:40 <fmardini> applicative: flip id help actually :) thanks
07:07:24 <Yaasky> ah this :t flip id actually helped me understand—a bit—what's going on here
07:07:33 * Yaasky was totally lost
07:10:50 <adas> I am in the IO monad. Inside the IO monad I have a (Just val). Is it possible to get the 'val' alone to do more processing with it?
07:11:35 <tdammers> adas: sure
07:11:45 <tdammers> let Just v = yourMaybeValue
07:12:06 <jevankovich> But then in the case that it's Nothing...
07:12:17 <tdammers> well, of course, then it breaks
07:12:35 <tdammers> you can use fromMaybe or maybe, of course
07:12:46 <tdammers> the fact that you're in IO doesn't really change a lot
07:13:35 <adas> oh oh ofcourse..the control.maybe should have some helpers. thanks for reminding me. : )
07:14:02 <adas> there is no such thing
07:14:07 <adas> Data.maybe perhaps
07:15:04 <jevankovich> You could write a small function if it's okay to have a sane default come out with Nothing
07:15:07 * Yaasky is about to leave
07:15:18 <Yaasky> thanks for the links, applicative
07:16:09 <Yaasky> thanks for the chat bscarlet, merijn, jevankovich, applicative, lambdabot and the rest
07:18:17 <adas> im just trying to print a value inside a maybe
07:18:19 <hpaste> merijn pasted “ContT-ify?” at http://lpaste.net/91209
07:19:01 <merijn> It seems like that could be nicified/generalised using ContT, but I'm not to familiar with ContT? Any helpers?
07:19:07 <mauke> :t maybe (return ()) print
07:19:08 <lambdabot> Show a => Maybe a -> IO ()
07:19:48 <merijn> also known as forM_
07:20:20 <mauke> :t maybe def print
07:20:21 <lambdabot> Show a => Maybe a -> IO ()
07:20:23 <merijn> (or "whenJust :: Monad m => (a -> m ()) -> Maybe a -> m ()")
07:20:45 <mauke> :t maybe def def
07:20:45 <Sculptor> yo
07:20:46 <lambdabot> Default b => Maybe a -> b
07:24:02 <znaimon> `morning
07:25:42 <adas> mauke: the type of maybe says :b -> (a -> b) -> Maybe a -> b. In your example i see 'b' is a monad? Am i correct?
07:26:08 <mauke> huh?
07:26:24 <duikboot> Hi, can I call System.Cmd system with map? :  http://lpaste.net/91210 Sorry for this stupid question, but I am a beginner...
07:26:25 <mauke> which example? and why does that even matter?
07:27:05 <applicative> hi znaimon
07:27:12 <adas> mauke: maybe (return ()) print
07:27:31 <applicative> it would be mapM_ duikboot but maybe more is needed
07:27:42 <mauke> adas: b can't be a monad as it has kind *
07:27:46 <applicative> map just makes a list of actions in  case like this; you want an action
07:28:04 <jophish_> Yo yo yo, people
07:28:51 <adas> but isn't return () of type IO ()?
07:28:51 <dgpratt> feeling conflicted
07:29:04 <mauke> adas: yes
07:29:16 <applicative> duikboot: if l is defined as in your module, main = mapM_ system l
07:29:39 <Saizan> adas: by "monad" we refer to the parametrized types that are instances of the Monad class (in the context of Haskell)
07:29:52 <applicative> duikboot if l is the string that comes from readFile, you will need to associate it with a list of strings, e.g. with unlines
07:29:56 <jevankovich> adas: IO is a monad. A monad takes a type to become a concrete type. IO () is a concrete type because () was given to monad
07:30:02 <dgpratt> I have this program where I am working with some data of type [[String]] but a more precise type of the data would be [(String, String, String, String)]
07:30:22 <dgpratt> the problem is that at some point I need to "transpose" the data
07:30:28 <Saizan> adas: if you have (foo :: IO ()) then foo is sometimes called a monadic action, or just action, or "value of monadic type"
07:30:41 <adas> thanks for the clarification. i used some misplaced words.. hence the confusion.
07:30:42 <bscarlet> :t unzip4
07:30:44 <lambdabot> [(a, b, c, d)] -> ([a], [b], [c], [d])
07:31:05 <dgpratt> bscarlet, hmm, interesting
07:31:20 <duikboot> applicative: Thanks a lot mapM_ works!
07:31:36 <applicative> duikboot: ah good
07:32:04 <adas> when i say maybe .. i saw 'b' and thought it can only be a concrete type and nothing else. So i was thinking that 'b' could be any primitive concrete type. Didn't occur to me that a value of type IO () is also concrete
07:32:04 <dgpratt> anyways, I can't decide if I should use the more precise type or the more convenient type and convert as necessary
07:32:08 <adas> *saw
07:32:15 <dgpratt> opinions welcome
07:33:16 <Saizan> adas: the type (IO ()) is a concrete type
07:34:13 <adas> yup i got that now )
07:34:37 <bscarlet> dgpratt: I find tuples bigger than pairs get to be a pain if I use them too broadly - they're great in limited scopes. If I use them too broadly they're either confusing (for lack of an inherent explanation of what they mean - e.g. a declared type would be better) or I hit problems where they don't fit some standard api well - e.g. Map only works with pairs.
07:35:56 <elliott> dgpratt: here is what I would do
07:35:59 <jevankovich> adas: Note that (a->b) is also a concrete type ( (->) has kind * -> * -> *) and could also be the 'b' in maybe
07:36:03 <elliott> dgpratt: data Foo a = Foo a a a
07:36:07 <elliott> dgpratt: [Foo String]
07:36:19 <elliott> dgpratt: you can then use Data.Traversable.sequenceA or such to get Foo [String]
07:36:23 <elliott> perhaps this will work for you
07:36:44 <davesque> hey, could someone help me with these type errors: http://lpaste.net/91211
07:37:28 <davesque> i've been screwing around with {-# LANGUAGE ExistentialQuantification #-} and {-# LANGUAGE RankNTypes #-}, but to no avail
07:37:55 <mauke> davesque: remove the type signature
07:38:14 <davesque> mauke: right, when i do that, i get Parser a -> Parser a -> Parser a
07:38:19 <mauke> yep
07:38:22 <mauke> that's the correct type
07:38:39 * hackagebot magma 0.2.0.0 - magma is an algebraic structure consisting a set together with an binary operation.  http://hackage.haskell.org/package/magma-0.2.0.0 (KatsutoshiItoh)
07:38:58 <davesque> mauke: how could i work towards having a Parser that returns either a result with type a or b?
07:39:01 <jevankovich> davesque: maybe if or had type Parser a -> Parser b -> Parser (Either a b). You'll have to use the Left and Right constructors inside the case
07:39:13 <mauke> davesque: Parser a -> Parser b -> Parser (Either a b)
07:39:24 <jevankovich> Either is defined as: data Either a b = Left a | Right b
07:39:29 <davesque> mauke: ahh, okay
07:40:00 <davesque> jevankovich: right, i've seen it before.  i tried using it for this, but it seemed like it would make the code way more complicated.  guess there's no way to avoid that.
07:40:52 <jevankovich> davesque: It'll make it really complicated if you want to chain 'or's. It'll probably be easier to go with the single typed version
07:41:24 <merijn> I have "(a -> IO b) -> IO b" and "b -> s -> IO s and want to end up with "s -> IO s", any suggestions?
07:41:39 <davesque> jevankovich, mauke: i'll try experimenting with the two.  thanks!
07:41:44 <merijn> Basically, I want to get the second inside the "a -> IO b" bit
07:42:41 <jevankovich> merijn: you could partially apply the second. I'm not sure if that would get what you want, though.
07:42:56 <merijn> jevankovich: How would I partially apply it?
07:43:29 <jevankovich> foo x :: b -> s -> IO s
07:43:34 <mauke> \s -> f return >>= \b -> g b s
07:43:47 <jevankovich> just call foo with some b
07:44:03 <Lethalman> :t \b s f -> do b <- mb; return f s
07:44:04 <lambdabot>     Not in scope: `mb'
07:44:04 <lambdabot>     Perhaps you meant one of these:
07:44:04 <lambdabot>       `b' (line 1), `b' (imported from Debug.SimpleReflect),
07:44:08 <Lethalman> :t \mb s f -> do b <- mb; return f s
07:44:08 <merijn> jevankovich: No, I want the b to be the b produce by "a -> IO b"
07:44:09 <lambdabot> (Monad m, Monad ((->) t1)) => m t -> t1 -> m b -> m b
07:44:21 <Lethalman> mh :P
07:44:25 <mauke> :t \f g s -> f return >>= \b -> g b s
07:44:26 <lambdabot> (Monad m, Monad m1) => ((a1 -> m1 a1) -> m a) -> (a -> t -> m b) -> t -> m b
07:45:32 <jevankovich> If you're inside a do block you might be able to bind the result of the first to some 'variable' and us it on the second
07:45:49 <mauke> :t \f g s -> newEmptyMVar >>= \v -> f (putMVar v) >> takeMVar v >>= \b -> g b s
07:45:50 <lambdabot> Not in scope: `newEmptyMVar'
07:45:50 <lambdabot>     Not in scope: `putMVar'
07:45:50 <lambdabot>     Perhaps you meant `putChar' (imported from Prelude)
07:45:51 <dgpratt> elliott, thanks for the idea, I'll try that and see how it fits
07:45:55 <merijn> I though I'd have to make use of the ContT transformer to turn the first into "ContT a IO b", but then I'm not sure how to stuff the "b -> s -> IO s" into the continuation
07:46:10 <mauke> merijn: if you can't unify a/b, you could just use a variable
07:49:48 <dmwit_> merijn: Supposing you have "foo :: A -> IO B", "bar :: (A -> IO B) -> IO B", and "baz :: B -> S -> IO S", you can write "bar foo >>= \b -> return (baz b) :: IO (S -> IO S)".
07:50:08 <dmwit> Have you got a "foo :: A -> IO B"? If not, you may be in a bit of trouble.
07:51:52 <merijn> Actually, I think what I want isn't possible
07:52:17 * djahandarie wonders why dmwit has switched to upper-case bound variables
07:52:29 <dmwit> Because that way they are not bound variables.
07:52:33 <dmwit> They are concrete types.
07:52:39 <bscarlet> merijn: It does look kind of weird to me.
07:53:08 <dmwit> That is, when they're variables it looks like more things can unify; when they're concrete types, it's more obvious that things aren't intended to unify.
07:53:36 <merijn> The things is that I want to basically replace every invocation of the "a -> IO b" to be changed into "a -> IO s" using the "b -> s -> IO s" type, but the more I think about it, the more it seems like it might not make sense
07:54:25 <merijn> Basically, if baz was "B -> (S -> IO S) -> IO s" I could use >>= from ContT to do that
07:54:45 <bscarlet> merijn: the (a -> IO b) -> IO b is a continuation - a thing that provides an a. The b -> s -> IO s wants a b.
07:54:49 <merijn> Like I said, I'm not sure what I want makes sense
07:56:26 <znaimon> I'm getting a cabal install error: Module `Data.Monoid' does not export `(<>)' regarding hsp-0.9.2 on CentOS6
07:56:30 <znaimon> Anyone have any insight?
07:56:49 <dmwit> upgrade GHC
07:57:05 <dmwit> Also, complain to the package maintainer that their version restriction on "base" is too lax.
07:57:22 <dmwit> Alternate workaround to upgrading GHC: open up the source and replace <> with mappend everywhere.
07:57:56 <znaimon> I can't find any udated versions of GHC that are compatible with Centos 6 :/
07:58:24 <mauke> upgrade centos 6
07:58:51 <znaimon> that's not an option :(
07:59:02 <int-e> build your own ghc
07:59:15 <dmwit> I feel that one of my two proposed options has been ignored here.
07:59:33 <int-e> yes :)
07:59:44 <Clint> but which one
08:00:59 <danharaj> how do I tell cabal to ignore Safe Haskell?
08:01:27 <znaimon> dmwit: your second option would be fantastic if I had any idea what I was doing haha
08:03:16 <dmwit> sed -i 's/(<>)/mappend/;s/<>/`mappend`/' **/*.{l,}hs
08:03:24 <dmwit> znaimon: ^^
08:03:36 <dmwit> 100% untested, read the man pages, beware troll suggestions, etc.
08:04:01 <znaimon> dmwit: what dir would I be running this from?  or does it matter?
08:04:04 <dmwit> might need some 'g's at the end of those 's's.
08:04:08 <dmwit> Run it from the source directory.
08:04:14 <dmwit> If you don't have one, you can get one with cabal unpacke.
08:04:19 <dmwit> cabal unpack, I mean
08:04:52 <dmwit> Also, if you have to ask whether it matters, you *definitely* need to read some man pages first.
08:05:15 <int-e> dmwit: **/ - what's your shell?
08:05:17 <znaimon> probably.  alright.  i'll go do my reading now.
08:05:21 <dmwit> int-e: zsh
08:05:29 <dmwit> Why, does bash not do that?
08:05:47 <int-e> no. ** has the same meaning as *.
08:05:55 <dmwit> bummer
08:06:27 <mauke> find . -type f -exec sed ... {} +
08:06:57 <int-e> find . -name \*.lhs -o -name \*.hs -print0 | xargs -0 sed -i 's/(<>)/mappend/;s/<>/`mappend`/'
08:07:01 * int-e shrugs
08:07:26 <dmwit> looks convenient
08:08:16 <int-e> ok, bash has an option to expand ** like that
08:08:16 <dmwit> Why use xargs over -exec?
08:09:30 <int-e> (bash: shopt -s globstar)
08:09:44 <dmwit> Sounds like the name of a great game.
08:09:46 <int-e> dmwit: fewer execs. just a habit really
08:10:03 <mauke> it's not fewer execs
08:11:30 <dmwit> -P looks interesting, though
08:11:45 <dmwit> I bet find -exec can't do that. =)
08:11:57 <int-e> dmwit: thanks. I can't believe I didn't know the + variant of -exec.
08:12:43 * mux is also partial to using xargs rather than the cumbersome -exec
08:12:59 <dmwit> cumbersome?
08:13:20 <mux> having to terminate commands with \; or +
08:13:58 <mux> also with xargs you can limit to a specified number of parameters with -n, which sometimes comes in handy
08:14:08 <dmwit> > length "\;" < length "-print0 | xargs -0"
08:14:08 <lambdabot>   <hint>:1:10:
08:14:09 <lambdabot>      lexical error in string/character literal at character ';'
08:14:16 <dmwit> > length "\\;" < length "-print0 | xargs -0"
08:14:17 <lambdabot>   True
08:14:17 <elliott> > (length " | xargs", length "-exec +")
08:14:18 <lambdabot>   (8,7)
08:14:33 <dmwit> Oh yeah, forgot the -exec part.
08:14:41 <mux> it's also more UNIXy
08:14:48 <dmwit> mux: Okay, yeah. -n looks nice (and as observed before, -P too).
08:15:10 <dmwit> "more UNIXy" does not hold a lot of weight with me.
08:15:11 <mux> I'm not trying to argue over one vs the other though, they are mostly equivalent, and this is mostly about taste, I guess.
08:15:13 <mux> it does with me ;-)
08:15:14 <dmwit> We have browsers and stuff these days. UNIX is dead.
08:15:38 <tac> dmwit: Plan10: Everything's a webpage.
08:15:38 <int-e> yet we're discussing shell commands
08:16:35 <mux> I also love FreeBSD's -o flag to xargs, which tells it to reopen stdin
08:16:39 <b2coutts> I'm a fan of things being UNIX-y when it's more efficient than the non-UNIX-y alternative
08:16:46 <mux> so you can find ... | xargs -o <interactive program>
08:16:47 <b2coutts> which is often in my experience
08:17:14 <mux> that is not standard though. I added it to FreeBSD's xarg a long time ago
08:17:21 <mux> I think Linux has some equivalent
08:19:20 <int-e> mux: no, the manpage suggests something like  xargs sh -c 'emacs "$@" < /dev/tty' to achieve that effect
08:19:29 <dmwit> int-e: Okay, my claim was too strong.
08:19:34 <mux> ugh, I'll blame Linux
08:25:36 <hpaste> merijn pasted “Suggestions for a nicer generalisation?” at http://lpaste.net/91212
08:25:49 <merijn> nAny suggestions how to make that less ugly?
08:26:12 <merijn> Specifically when before/after/work are less trivial
08:28:21 <zvrba> is there a HO function akin to common lisp's maplist? it's like a fold, except that the folding function receives the rest of the list starting from the current element, except just the element
08:28:49 <zvrba> I have a list of logical pairs, and I find myself manually writing recursion over v1:v2:vs
08:29:03 <zvrba> sometimes removing just v1, sometimes both v1 and v2
08:29:20 <zvrba> hmmm, guess maplist wouldn't help there.
08:29:22 <b2coutts> zvrba: I'm not sure exactly what function you're looking for
08:29:52 <Rembane> zvrba: Do they reside in a tuple or just in a "flat" list?
08:29:59 <zvrba> flat list
08:30:20 <zvrba> it's a list of boundary vertices of a polygon
08:30:40 <zvrba> then the list is filtered by some criterion
08:30:59 <b2coutts> and "pairs" just mean adjacent vertices?
08:31:00 <zvrba> and the remaining verices processed pairwise
08:31:03 <zvrba> yes
08:31:32 <zvrba> I could transform [v1,v2,v3..] to [(v1,v2),(v2,v3),..] but it seems inelegant
08:31:57 <zvrba> indeed, zipWith (,) v (tail v) :-)
08:31:59 <b2coutts> zvrba: how exactly are they processed? seems to me like you could just use a regular fold
08:32:31 <zvrba> b2coutts: well, each v_i is a pair of ints
08:32:34 <mux> zipWith (,) == zip
08:32:41 <zvrba> oh :)
08:33:08 <zvrba> b2coutts: so, v1:v2:v2... if v1.x == v2.x, both v1 and v2 are removed. otherwise, only v1 is removed.
08:33:20 <zvrba> (pardon the obvious shortcut there :))
08:33:25 <b2coutts> zvrba: ah, so you just want to remove duplicate adjacent vertices
08:33:45 <zvrba> b2coutts: well, no, I want to join together in a tuple adjacent vertices with the same x- or y-component
08:34:10 <zvrba> so [(1,2),(1,10),(1,17),(3,10)] -> [((1,2),(1,10))]
08:35:03 <zvrba> so [(1,2),(1,10),(1,17),(1,19),(3,10)] -> [((1,2),(1,10)), ((1,17),(1,19)]
08:35:06 <hape03> @type zip
08:35:06 <lambdabot> [a] -> [b] -> [(a, b)]
08:35:27 <hape03> @type (zipWith (,))
08:35:27 <lambdabot> [a] -> [b] -> [(a, b)]
08:35:30 <hape03> yep
08:35:39 <zvrba> b2coutts: ok I guess it's a case where recursion has to be manually spelled-out :)
08:35:50 <zvrba> (not that I mind)
08:36:24 <b2coutts> zvrba: yeah, I mean what you need to do seems complex enough to deserve its own function
08:37:26 <b2coutts> alternatively you could probably use foldr, where the function checks that its second argument has length at least 2, and if it does, it sees if the first arg and first two points of the second arg form a line
08:37:38 <mr-> zvrba: how about ziping the sequence with itself, once shifted, and filtering that one?
08:38:02 <b2coutts> but this is probably worse than just writing a separate function and using explicit recursion, even if the code is shorter
08:38:03 <zvrba> yeah,that could be another way
08:38:14 <zvrba> mr-: but I think explicit recursion is less obscure in this case.
08:38:28 <zvrba> more "declarative" if you want
08:38:49 <mr-> I don't think so ;-)
08:39:00 <zvrba> http://pastie.org/8174737
08:39:53 <zvrba> p is fst or snd. I have to run it on both components.
08:41:42 <mr-> Oh.. my solution does not quite do what you want
08:42:02 <mr-> > let l = [(1,2),(1,10),(1,17),(1,19),(3,10)] in filter (\((a,b),(c,d)) -> a == c || b == d) $ zip l (tail l)
08:42:08 <lambdabot>   [((1,2),(1,10)),((1,10),(1,17)),((1,17),(1,19))]
08:42:42 <zvrba> nope, not what I want :-)
08:46:22 <mr-> too bad..
08:49:39 <merijn> On a scale from one to very, how evil am I? "loop before after work x = bracket before after (work x) `catch` loop before after work"
08:50:33 <elliott> four
08:51:32 <klrr> is the author of Helm here on irc
08:51:33 <klrr> ??
08:56:22 <klrr> http://lpaste.net/91213 anyone know what "setup: The pkg-config package cairo-pdf is required but it could not be found." mean and what i should do? i tried do "cabal install cairo-pdf" but there was no package called that
08:56:42 <dcoutts> klrr: the hint is that it's a pkg-config package
08:56:55 <dcoutts> pkg-config is a program and a system for managing C libs
08:57:10 <int-e> klrr: so you need pkg-config and the development package for cairo-pdf.
08:57:16 <dcoutts> what it really indicates is that you don't have the devel package for cairo installed
08:57:20 <int-e> (which is a C library_
08:57:28 <Rogach> Hi! Is there some way to reuse argument definitions when using cmdArgs? I tried to do it in this snippet (reuse happens in `common` method), but failed.
08:57:31 <dcoutts> you almost certainly have pkg-config, it's the C lib you're missing
08:57:34 <int-e> (right, it's probably just cairo)
08:58:02 <jevankovich> so if he's running something debian based he should run 'sudo apt-get install libcairo-dev' or something like that. I think
08:58:04 <Rogach> Only the first mode gets the arguments configured, the second one ignores the names/help for arguments.
08:59:52 <klrr> int-e: what's pkg-config?
09:00:11 <klrr> it's not on hackage
09:00:22 <int-e> klrr: it'll come with your distribution
09:00:27 <klrr> okey
09:00:29 <supki> Rogach: I don't think your snippet got linked in channel.
09:00:42 <Rogach> supki: Sorry! http://lpaste.net/91214
09:00:42 <klrr> i got no idea about this, is it some kind of C header file im missing?
09:00:43 <int-e> klrr: it's a command line program for querying data about installed C libraries.
09:01:05 <jevankovich> klrr: what OS are you running?
09:01:07 <klrr> int-e: so i most likely doesnt have the right header files aka clibs?
09:01:09 <klrr> ubuntu
09:01:28 <geekosaur> klrr, it's a bunch of non-Haskell stuff you are missing, as you've been told a couple of times
09:01:46 <klrr> cairo-dev-header-C stuff package
09:01:51 <jevankovich> klrr: sudo apt-get install libcairo2-dev will get what you need, I think
09:01:57 <int-e> klrr: for example, pkg-config --list-all will list the libraries that pkg-config knows about, once it is installed.
09:02:01 <klrr> oh thanks for writing it out for me :D
09:02:30 <klrr> int-e: okey, useful took
09:02:33 <klrr> tool*
09:03:08 <klrr> now everything works ^^ thanks
09:03:19 <jevankovich> No problem. Happy to help
09:03:41 * hackagebot metadata 0.1.4.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.4.0 (KatsutoshiItoh)
09:05:06 <klrr> i always forget you also need header files to link libs that has bindings to C code, i always just install the normal dynamically linked library xD
09:09:27 <klrr> anyone know a library for playing audio files?
09:16:34 <Pranz> klrr, there exists OpenAL bindings
09:18:34 <klrr> Pranz: will have a look
09:19:24 <klrr> Pranz: it says 3d audio, odes it still work with 2d games ?
09:19:47 <Pranz> klrr, Yeah, altough it may not be the fastest alternative then
09:19:59 <Pranz> but I don't know that much about sound really
09:19:59 <klrr> is there better alternatives?
09:20:10 <jevankovich> Since you're doing a 2d game, I'm curious what you're using to draw to the screen
09:20:10 <ocharles> bleh, there's no real pattern for  (a -> b -> m c) -> m a -> m b -> m c  is there?
09:20:15 <klrr> i tried look into handling it using SDL, but it seems that the haskell bindings doesnt have that
09:20:19 <Pranz> klrr, not a single library I don't think
09:20:29 <klrr> jevankovich: cairo, well, im using Helm game engine
09:20:30 <Gracenotes> http://hackage.haskell.org/package/SDL-mixer
09:20:45 <Pranz> ah!
09:20:47 <Pranz> slipped my mind
09:20:48 <Gracenotes> SDL mixer has some limitations, though.
09:20:50 <klrr> aa it was a seperated library Gracenotes thanks!
09:21:02 <klrr> any improntant to know?
09:21:03 <ocharles> I guess I can use applicative and then join the whole thing at the end
09:21:06 <Pranz> klrr, altough 3D sound may find its place you know
09:21:12 <Gracenotes> I haven't used this, I just Googled sdl mixer haskell
09:21:17 <Pranz> klrr, if you wanna place sound further back and use various effects
09:21:21 <klrr> ok
09:21:34 <klrr> Pranz: i dont want such advanced stuff
09:21:39 <Gracenotes> also, if you want to play more than one thing at once, and want to be particular about starting and ending sound at a specific time
09:21:56 <Gracenotes> I can't promise anything about the sound quality either
09:22:07 <klrr> well, i will try and see if it works
09:22:14 <Gracenotes> yes, report back :)
09:22:15 <Pranz> klrr, what os are you making for?
09:22:29 <klrr> im just playing around, so unix-like oses only atm
09:22:50 <jevankovich> I think SDL just plays the sound. OpenAL does a lot of processing and will even offload to the soundcard I think
09:23:16 <klrr> jevankovich: if you were interested what i used for drawing, using helm which uses cairo http://helm-engine.org/
09:24:34 <Pranz> klrr, hmm, that seems interesting
09:25:00 <klrr> Pranz: it does :D im super excited
09:25:43 <Pranz> klrr, you may find #haskell-game useful for more gamespecific questions
09:26:13 <Placinta> Hi. I'm trying to create a value that is wrapped in a Maybe and a Writer monad. I want to use a WriterT monad transformer, but I just can't get the correct value constructor. I try something like WriterT ["A message"] Just 1, but I get an error. Can anybody tell me how I can fix that?
09:26:44 <klrr> Pranz: im already on there
09:26:55 <Pranz> oh
09:27:26 <Clint> Placinta: you don't do things that way
09:28:26 <Placinta> Clint: What is the problem doing it this way?
09:28:36 <Clint> Placinta: well it doesn't make sense
09:28:41 <Clint> what are you trying to do?
09:29:40 <Pranz> Placinta, return $ Just 1 >>= log "a message"
09:29:41 <Pranz> maybe?
09:29:57 <Pranz> if log is what I think it is
09:30:15 <Pranz> eh, may have to wrap parantheses around the expression before ">>="
09:30:30 <Placinta> I'm trying to figure out, how to construct a value in a monad, in a monad transformer in 1 line
09:30:47 <Clint> i don't think the WriterT transformer does what you think it does then
09:33:00 <Placinta> A Writer lets you log messages. I can apply it to simple values, like 1,3. If I have a a value with a context, say Just 3, I would need a monad transformer WriterT to be able to log operations on said value, no?
09:33:38 <Pranz> Placinta, no
09:33:46 <Pranz> or
09:33:51 <Pranz> hmm
09:33:53 <Gracenotes> :t tell ["a"] >> return 1
09:33:54 <lambdabot> (Num b, MonadWriter [[Char]] m) => m b
09:33:54 <Pranz> I don't think so
09:34:00 <Clint> > runWriter $ tell ["Howdy"] >> return (Just 3)
09:34:01 <lambdabot>   (Just 3,["Howdy"])
09:34:06 <geekosaur> no, transformer doesn't transform the logged value. afaik if a is a Monoid then Maybe a is also a monoid, but you would have to then consistently log Maybe a
09:34:08 <Gracenotes> :t tell ["a"] >> return 1 :: WriterT [String] Maybe Int
09:34:09 <lambdabot> WriterT [String] Maybe Int
09:34:27 <geekosaur> and there is no type appropriate way to have it handle either a or Maybe a
09:34:45 <geekosaur> unless you want multiple Writer-s, one for each type (and *there* you are looking at WriterT)
09:34:58 <Gracenotes> you don't need 'return (Just 3)'; 'return 3' will work
09:35:06 <geekosaur> but you won't have any sequence information between their respective logs
09:35:17 <Gracenotes> at least, if you're using WriterT
09:35:28 <Clint> i was too lazy for type signature
09:35:39 <monochrom> I agree with the assessment that you misunderstood WriterT
09:36:01 <monochrom> or at least the specific WriterT [String] Maybe a
09:36:55 <Placinta> I need a moment to comprehend this
09:38:06 <Gracenotes> The types of transformers and the nesting of transformers are a bit inverted. WriterT [String] (MaybeT IO) a, when you run this, IO is on the outside, then Maybe, then Writer [String] on the very inside
09:38:22 <jevankovich> Could anybody point me in the direction of some good resources for understanding monad transformers?
09:38:38 <Gracenotes> features propagate up via typeclasses, most often
09:39:07 <Gracenotes> then you get really complex hierarchies etc.
09:41:08 <Gracenotes> well, http://web.archive.org/web/20070224024824/http://cale.yi.org/index.php/How_To_Use_Monad_Transformers used to work
09:41:17 <Gracenotes> it is probably lost forever now
09:41:55 <Gracenotes> they're not really all they're cracked up to be, anyway.
09:41:59 <monochrom> jevankovich: perhaps http://www.haskell.org/haskellwiki/Typeclassopedia#Monad_transformers
09:42:53 <monochrom> hmm, perhaps that's too brief
09:43:53 <Gracenotes> another reason for the above-mentioned inversion is that the difference between 'm a' and 't m a' is a lot smaller if you just enhance the innermost computational context, rather than change the entire semantics of everything. also, makes the types work nice.
09:44:51 <monochrom> I learned them by reading the docs and playing with ReaderT, WriterT, StateT, ContT, respectively
09:44:52 <jevankovich> Okay. Thanks
09:44:53 <shachaf> CodensiT
09:45:09 <monochrom> playing is the key. programming is not a spectator sport.
09:47:19 <ParahSailin> im having a hard time finding where "runGenProcess_" is defined http://hackage.haskell.org/packages/archive/process/latest/doc/html/src/System-Process.html
09:47:40 <Cale> jevankovich: If you'd like, I can take you through the construction of State / StateT which will probably help make the general idea of how monad transformers work pretty clear.
09:47:57 <ParahSailin> nevermind, .Internals
09:47:57 <jevankovich> That'd be great, Cale
09:48:48 <Cale> Actually, come to #haskell-overflow so that we don't have quite as much scrolling :)
09:48:55 <Gracenotes> Cale: is there any hope of getting the tutorial back? or is it lost to posterity?
09:49:03 <Gracenotes> a relic from an ancient time
09:49:32 <Cale> Gracenotes: ummm... I'm not sure why archive.org suddenly decided to honour my old robots.txt when they'd been ignoring it up until last week
09:49:51 <Gracenotes> yeah.. odd
09:50:40 <Gracenotes> ParahSailin: systems-y stuff has a lot of indirection in ghc/base source. This may be a side effect of abstraction.
10:00:08 <tromp_> a nytimes article writes "... penetrated the secure computer networks ..." :(
10:01:03 <monochrom> please don't read nytimes :)
10:01:38 <Gracenotes> :o
10:04:41 <geekosaur> expecting anything like reality on any remotely technical subject from mass media is ..
10:06:44 <Gracenotes> it's not just technical subjects. anyone who's proficient in anything will cringe reading stories about that thing.
10:07:12 <Gracenotes> Explaining complicated things to the general public is painful.
10:07:30 <Setsuna> Hi there, We are looking for a graphics designer for a work, if you are interested pm me, thanks :)
10:09:06 <osfameron> if you want to work for a spammer
10:22:58 <ParahSailin> what is an interesting library that uses arrows
10:36:34 <ReinH> hai everyone
10:37:11 <banister`sleepy> ReinH: sup
10:38:11 <ReinH> banister`sleepy: workin. Not with Haskell though :(
10:38:22 <banister`sleepy> ruby?
10:38:53 <ReinH> banister`sleepy: yep
10:40:02 <banister`sleepy> ReinH: cool, after haskelling for a while i wrote a little lib that makes ruby a little more haskell-y: https://github.com/banister/funkify  yo might like it (or not) :)
10:41:12 <ReinH> banister`sleepy: I think I saw this
10:41:24 <ReinH> yeah, autocurrying, cool
10:41:52 <ReinH> banister`sleepy: and it isn't terrible with the new .() callable syntax either
10:42:07 <ReinH> Proc#[] was too much mixing metaphors for me
10:47:35 <shachaf> Sigh, Tekmo suggests on libraries@ that there's a performance (fusion) problem in base and doesn't give us a way to test it other than using pipes.
10:48:22 <luite> that's a good strategy to get people to use your lib
10:48:48 <shachaf> I'll simply not test it.
10:49:30 <luite> i guess he overplayed his hand then :)
10:56:01 <S_J> > flip (-) 3 4
10:56:01 <lambdabot>   1
10:56:38 <S_J> > map (-) [\f-> flip f 3 4]
10:56:39 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
10:56:39 <lambdabot>    arising from a use ...
10:57:20 <S_J> > map (-) [(\f -> flip f 3 4)]
10:57:21 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
10:57:21 <lambdabot>    arising from a use ...
10:57:27 <S_J> why doesnt that work?
10:57:28 <Rarrikins> > (-) (\f -> flip f 3 4)
10:57:29 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
10:57:29 <lambdabot>    arising from a use ...
10:57:36 <Rarrikins> Because it's doing that.
10:57:56 <Rarrikins> > map (\f -> flip f 3 4) [(-)]
10:57:57 <lambdabot>   [1]
10:58:15 <Rarrikins> > (\f -> flip f 3 4) (-)
10:58:15 <lambdabot>   1
11:00:04 <S_J> so how would i write to do what i wanted? if i have a list of flip f x y
11:01:09 <Rarrikins> S_J: What would the list contain at the end?
11:01:48 <S_J> ints
11:01:54 <ParahSailin> > map ($ (-)) [(\f -> flip f 3 4)]
11:01:55 <lambdabot>   [1]
11:02:00 <S_J> i see
11:02:03 <Rarrikins> > map (flip (-)) [(\f -> f 3 4)]
11:02:04 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:02:04 <lambdabot>    arising from a use ...
11:02:14 <Rarrikins> > map (\a b -> flip (-)) [(\f -> f 3 4)]
11:02:15 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:02:15 <lambdabot>    arising from a use ...
11:02:18 <Rarrikins> > map (\a b -> flip (-) a b) [(\f -> f 3 4)]
11:02:18 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:02:19 <lambdabot>    arising from a use ...
11:02:25 <S_J> incredibly witty name there parahsailin
11:02:26 <Watcher7> > let (|>) a f = f a
11:02:27 <lambdabot>   not an expression: `let (|>) a f = f a'
11:02:43 <alexander__b> back doing typeclassopedia exercises again.
11:02:56 <Rarrikins> > map (\f -> f (flip (-))) [(\f -> f 3 4)]
11:02:57 <lambdabot>   [1]
11:03:02 <Watcher7> Err well anyways.
11:03:11 <alexander__b> is ((->) e) just... like.. writing (+2)?
11:03:18 <Watcher7> map ((-) |>) [(\f -> flip f 3 4)] would work.
11:03:31 <alexander__b> so to make ((->) e) an instance of functor, fmap f g = .  ?
11:03:32 <Rarrikins> > map (\f -> f (-)) [(\f -> flip f 3 4)]
11:03:32 <lambdabot>   [1]
11:03:45 <Pranz> alexander__b, yea, altough it will be like (e ->)
11:03:57 <Pranz> and not (-> e)
11:04:25 <alexander__b> Pranz: I'm not sure I understand the implications
11:04:35 <Rarrikins> @pl (\ g)
11:04:35 <lambdabot> (line 1, column 5):
11:04:35 <lambdabot> unexpected ")"
11:04:35 <lambdabot> expecting letter or digit, operator, pattern or "->"
11:04:57 <Pranz> (e ->) is a value dependent of e
11:05:02 <Rarrikins> > map ($ (-)) [(\f -> flip f 3 4)]
11:05:03 <lambdabot>   [1]
11:05:09 <alexander__b> Pranz: can you give an example of e?
11:05:23 <Pranz> to answer your question, fmap has signature (a -> b) -> f a -> f b
11:05:23 <alexander__b> Pranz: sorry, absolute beginner here (to haskell and functional programming in general)
11:05:33 <Pranz> fmap with (->) e would look like
11:06:06 <Pranz> fmap :: (a -> b) -> (e -> a) -> (e -> b)
11:06:13 <Pranz> which is the same as
11:06:18 <Pranz> fmap :: (a -> b) -> (e -> a) -> e -> b
11:06:28 <Pranz> aka function composition
11:06:38 <Pranz> if you had (-> e), that would be
11:07:02 <Pranz> fmap :: (a -> b) -> (a -> e) -> b -> e
11:07:15 <Pranz> and it is impossible to construct such a function forall a b e.
11:07:49 <bscarlet> alexander__b: ((->) e) is a type, not a value
11:08:30 <alexander__b> bscarlet: please describe the difference. when I have to deal with such a plethora of terminology I eventually get lost.
11:09:24 <Pranz> alexander__b, a value must of a type
11:09:36 <Pranz> forexample, 5 is an Int
11:09:40 <Pranz> written as 5 :: Int
11:10:08 <alexander__b> I felt reasonably confident that instance Functor ((->) e) where fmap f g = . -- but that was intuition, not reasoning because I get lost when all this terminology comes up.
11:10:11 <alexander__b> Pranz: OK.
11:10:20 <Pranz> but Int is not a value, it's nonsenical to say that Int is of some type a
11:10:37 <Pranz> however!
11:10:48 <Pranz> Types can be an instance of a typeclass
11:11:07 <Pranz> forexample, Int is an instance of the Num typeclass
11:11:27 <alexander__b> and Eq and Ord and so forth, yes.
11:11:39 <Pranz> and that means that every value of type Int has the properties of a Num
11:11:54 <Pranz> So 5 and 4 can be added together
11:12:07 <Pranz> Functor is also a typeclass
11:12:20 <Hafydd> A type can be an instance of a unary typeclass.
11:12:40 <Pranz> but here things get even more complicated
11:12:56 <Pranz> Int is a simple kinded type
11:12:57 <alexander__b> Hafydd: I don't follow.
11:13:39 <Pranz> whereas a type can only be made an instance of Functor if it is a higher order type
11:14:04 <Pranz> Maybe is such a type
11:14:06 <alexander__b> Pranz: like []
11:14:11 <Pranz> yeah
11:14:12 <Pranz> exactly
11:14:27 <Hafydd> I forgot, that's a GHC extension.
11:14:42 <Hafydd> Never mind, I suppose you might say pure Haskell only has unary type classes.
11:14:53 <alexander__b> Pranz: OK. following thus far.
11:15:11 <Pranz> alexander__b, when you write the kind of a type, you do it as this: T :: *
11:15:21 <Pranz> so the type T is a simply kinded type
11:15:30 <Hafydd> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#idp48496992
11:15:31 <Pranz> Maybe :: * -> *
11:58:24 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
11:58:24 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
11:58:37 <arkeet> I wish we could write (e ->)
11:58:46 <Pranz> alexander__b, and I guess that's where this lengthy explanation finishes
11:58:49 <arkeet> TypeOperatorSections extension anyone?
11:58:52 <alexander__b> Pranz: hehe
11:58:55 <Pranz> alexander__b, but I was not really sure of your question
11:59:01 <Pranz> alexander__b, anything else that seems foggy?
11:59:19 <arkeet> (of course we could only make left sections.)
11:59:20 <alexander__b> Pranz: not right of what we've gone through right now, no
11:59:25 <alexander__b> thanks a lot btw!
11:59:49 <Pranz> yeah no problem
11:59:52 <Pranz> was in the mood
12:00:09 <S_J> > map (+99) [1..9]
12:00:10 <lambdabot>   [100,101,102,103,104,105,106,107,108]
12:00:16 <Pranz> now I think I'm gonna go out
12:00:16 <Pranz> brb
12:00:22 <totos> Hello, yesterday i asked if someone had problems with OpenGL and Haskell in Ubuntu 13.04. Turns out that by switching to Ubuntu 12.04 everything worked fine. (just for the record)
12:03:28 <alexander__b> the next example is data Pair a = Pair a a. this means that if I do Pair 5, I make a Pair which is two 5s, right?
12:03:41 <shachaf> No.
12:03:43 <geekosaur> no, it means a pair of two things of the same type
12:03:55 <shachaf> Pair 'a' 'b' :: Pair Int
12:03:57 <alexander__b> oh right
12:03:59 <shachaf> s/Int/Char/
12:04:05 <geekosaur> (Pair 5) is a function, it takes another parameter so it can make a Pair
12:04:08 <alexander__b> so it can be a pair of two ints
12:05:04 <alexander__b> I swear the more I learn haskell the less I understand/the more I forget lol
12:05:18 <bscarlet> alexander__b: in that line, the first Pair is first a type constructor (of kind * -> *), and then the second is a data constructor (of type a -> a -> Pair a).
12:05:20 <ski_> Pranz : fyi, Praanz da Kaelve är en figur in Erik Granströms Konfluxsvit (Svavelvinter,m.m.)
12:05:27 <alexander__b> things that seemed easy and understandable when reading LYAH is now lost on me. >_<
12:05:42 <ski_> arkeet : yes
12:05:43 <alexander__b> bscarlet: right
12:05:47 <johnw> @faq Can Haskell confuse you at the same time that it illumines?
12:05:47 <lambdabot> The answer is: Yes! Haskell can do that.
12:05:51 <arkeet> ski_: yes
12:06:37 <Cale> totos: Every new release of Ubuntu since somewhere around 9 or so has been a disappointment to me, making some things worse, and nothing much of interest better. :/
12:07:03 <levi> alexander__b: The trick is practicing what you learn as you learn it, so it sticks better.  And then continuing to practice it all, so you don't forget.
12:07:06 <Cale> If you don't feel at sea when learning something, then you're probably not learning fast enough.
12:07:32 <alexander__b> bscarlet: so Pair 5 would be a concrete type, right?
12:07:59 <bscarlet> alexander__b: No
12:08:05 <merijn> alexander__b: To avoid confusion, maybe start of using "data PairType a = PairValue a a"
12:08:10 <alexander__b> bscarlet: but you said that it was * -> *
12:08:36 <levi> alexander__b: The fact that the type is named Pair and your constructor is also named Pair is probably confusing you.
12:08:39 <alexander__b> merijn: heh
12:08:42 <merijn> alexander__b: The first and second "Pair" are completely unrelated and your text is identical to mine
12:08:48 <alexander__b> ohhh
12:08:50 <ski_> (alt. `data Pair a = MkPair a a')
12:09:02 <bscarlet> alexander__b: Pair Int is a concrete type. Pair 5 could only work with the other pair (which merijn just suggested you rename to PairValue), in which case it'd be a partially applied function.
12:09:06 <alexander__b> I didn't really consider this. that's mean, typeclassopedia. :-P
12:09:51 <levi> Constructors being capitalized like types is kind of confusing.
12:09:57 <merijn> alexander__b: The basic idea is that types and functions are different namespaces so you can have both a "Pair" type constructor and a "Pair" value constructor, but they refer to different things
12:10:10 <alexander__b> merijn: yes I see now
12:10:25 <merijn> levi: I don't think so, because types and constructors can never be used in the same context, so it's always unambiguous which it is
12:10:32 <alexander__b> so I can do Pair 5 6
12:10:37 <ski_> type functions being capitalized like constructors is kind of confusing
12:10:54 <alexander__b> but not Pair (5 :: Int) (6 :: Double)
12:10:58 <alexander__b> because Pair a a.
12:11:01 <merijn> alexander__b: Which would be the same as "PairValue 5 6" and you can do "Pair Char" which is the same as "PairType Char"
12:11:06 <merijn> alexander__b: Yes
12:12:04 <bscarlet> alexander__b: so Pair (5 :: Int) (6 :: Int) :: Pair Int
12:12:21 <totos> Cale: Well, most of ubuntu programs/libraries is far less robust than the average haskell program, that's for sure. There was a reason i had upgraded i keep forgetting right now.
12:12:33 <bscarlet> alexander__b: and Pair (5 :: Int) :: Int -> Pair Int
12:12:40 <alexander__b> bscarlet: so PairValue (5 :: Int) (6 :: Int) :: PairType Int
12:12:46 <bscarlet> alexander__b: yes
12:13:12 <alexander__b> and PairValue (5 :: Int) :: Int -> PairType Int
12:13:22 <bscarlet> alexander__b: yes
12:13:46 <alexander__b> so if I let a = PairValue (5 :: Int)
12:14:00 <totos> Cale: Ubuntu is making some changes to graphics libraries so as to be able to support tablets, so some incompatibilities in OpenGL could sure slip through.
12:14:02 <alexander__b> then a 5 :: PairType Int
12:14:17 <merijn> alexander__b: correct
12:14:32 <Cale> totos: I honestly don't understand what all the fascination with supporting tablets is about.
12:15:45 <alexander__b> so it's PairType that I make an instance of Functor?
12:15:51 <merijn> alexander__b: Yes
12:15:56 <alexander__b> merijn: phew
12:16:03 <Cale> totos: It's *ruined* all the guis, because you have to assume that your user is interacting with your program with their big stubby fingers that cover up whatever they're interacting with and don't have much precision.
12:16:18 <merijn> alexander__b: "instance Functor PairType where fmap f (Pair x y) = {- code goes here -}"
12:16:39 <merijn> eh, I guess that should be (PairValue x y), but you get my drift
12:17:02 <alexander__b> merijn: I did   fmap f (PairValue a b) = Pair (f a) (f b)
12:17:13 <alexander__b> is that even remotely approximating anything within right? :-P
12:17:20 <Cale> totos: and audio's gotten a bit better now, but the conventions there were a big thorn in my side for a while too -- for a time, whenever I had headphones plugged into the back of my computer, my speakers were forcibly muted :P
12:17:35 <Cale> which makes sense on a tablet, but not on a desktop!
12:17:39 <merijn> alexander__b: Yes, that's pretty much it (although you should have PairValue for the result :p)
12:17:49 <totos> Cale: I don't have a tablet, and a console is most of what i want from a computer, but interaction with a computer with the hands looks much more futuristic than the other cases :)
12:17:55 <alexander__b> merijn: right of course typo :-P
12:18:09 <Cale> anyway, this is offtopic here, but yeah, I rage whenever it comes up :P
12:18:22 <alexander__b> PHEW. OK. next exercise. typeclassopedia, I will beat you!
12:18:49 <Cale> totos: Futuristic or not, I think touchscreens are demonstrably worse for most tasks than a keyboard and mouse :P
12:19:08 --- mode: cameron.freenode.net set +o Igloo
12:19:24 <n-dolio> Cale: It's okay. Just carry a crappy bluetooth keyboard and a microscopic mouse with you wherever you go.
12:19:25 <johnw> Cale: my iPad would not be nearly as usable with a keyboard and mouse :)
12:19:31 <n-dolio> Then it's just as good as a desktop.
12:20:12 <Cale> I don't consider iPads very usable at all :P
12:20:34 <levi> Depends on what you want to use them for.
12:20:38 <johnw> mine is more usable than I ever believed it could be, before I started using it
12:21:53 --- mode: cameron.freenode.net set +o Igloo
12:22:06 --- mode: cameron.freenode.net set +o ChanServ
12:22:10 <b2coutts> most of the things I do with a computer would generally be unreasonable to do well with a tablet
12:22:10 <b2coutts> half because of software, half because of hardware
12:22:10 <b2coutts> though I suppose the software part could be solved by some really weird hack on android
12:22:25 <Cale> I don't even own a laptop, though maybe I'll buy one soonish because I plan to do a bit of travelling.
12:23:32 <alexander__b> OK next one is
12:23:33 <alexander__b> data ITree a = Leaf (Int -> a)
12:23:35 <alexander__b>              | Node [ITree a]
12:23:39 <alexander__b> is this right:
12:23:40 <alexander__b> instance Functor (ITree a) where
12:23:42 <alexander__b>   fmap f (Leaf a) -> Leaf (f a)
12:23:44 <alexander__b>   fmap f Node xs = fmap xs
12:23:53 <alexander__b> sorry if this is above the pastelimit of this channel. I'm not sure how long you tolerate here
12:24:08 <johnw> no
12:24:13 <johnw> Leaf is holding a function, not a value
12:24:16 <Cale> It's just so much more expensive than a desktop with similar capabilities, and I don't really feel the need to leave my desk with my computer anyway.
12:24:25 <alexander__b> johnw: ohh
12:24:28 <johnw> plus, you can just use: data ITree a = Node a [ITree a]
12:24:32 <johnw> which is isomorphic to your definition
12:24:37 <johnw> this is called a "rose tree"
12:25:51 <merijn> johnw: No, you're tree is simpler to make a functor
12:26:09 <merijn> Considering he's working through typeclassopedia exercises he shouldn't simplify it like that
12:26:14 <johnw> ah, ok
12:26:38 <alexander__b> the function at Leaf just takes any Int and returns... anything?
12:26:49 <merijn> alexander__b: no, it returns an a
12:26:58 <johnw> the "a" is fixed by the user of ITree
12:27:04 <merijn> alexander__b: If you have "ITree Char" then "Leaf (Int -> Char)"
12:27:07 <alexander__b> oh right
12:27:11 <alexander__b> I see
13:40:50 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
13:40:50 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
13:40:52 <alexander__b> merijn: I think it's two thirds but maths... it's been a while. :-P
13:41:17 <leroux> Haskell Holes.
13:41:18 <merijn> leroux: Not a sort of holes, just holes. But with machinery to automatically fill them in as much as possible
13:41:20 <ski_> leroux : "Polymorphic Type Inference" by Michael Schwartzbach in 1995-03 at <http://cs.au.dk/~mis/typeinf.pdf> might perhaps also be interesting
13:41:28 <leroux> Ahh, isee.
13:41:31 <leroux> Ooh, another paper.
13:42:08 <merijn> leroux: i.e. given a hole plus a bunch of functions/values, try to automatically fill in the hole and then when the compiler gets stuck it asks to user to specify more info so it can continue trying to fill the hole
13:42:54 <johnw> like that animated GIF labelled "SPJ putting the IO Monad into Haskell"
13:42:55 <merijn> leroux: McBride is like me. Way to lazy to program things the compiler can do for you ;)
13:43:05 <leroux> xD
13:43:20 <leroux> merijn: Are holes going to be part of the next GHC release?
13:43:22 <merijn> johnw: I don't actually like that one, it makes it look like the IO monad is some sort of weird hack
13:43:32 <johnw> true
13:43:32 <merijn> leroux: Magic 8ball says: Oh god, I hope so
13:43:53 <ski_> leroux : and "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 is also interesting, e.g. the taxonomy in section 1.3 on different kinds of polymorphism
13:43:59 <johnw> i'm looking forward to holes, although since shachaf taught me how to use implicit params, my itch has been mostly scratched
13:45:57 <merijn> I want type level holes
13:46:10 <merijn> like "foo :: Int -> Blah -> _"
13:46:15 <johnw> I use () for that
13:46:22 <merijn> like "I can't be arsed to figure this out/write it down"
13:46:28 <merijn> johnw: No
13:46:39 <merijn> johnw: I want to be able to write partial type annotations
13:47:00 <merijn> i.e. "Int -> a" for some specific a that I can't be arsed to write down
13:47:08 <johnw> ah
13:47:29 <johnw> "to be arsed" is really a verb?
13:47:45 <merijn> It is in British English
13:49:14 <alexander__b> merijn: I get what you mean with substitution and id now. it is a very useful exercise and technique. thank you.
13:49:16 <merijn> Or maybe it's not really a verb, but the expression is common: http://english.stackexchange.com/questions/14566/where-does-cant-be-arsed-come-from
13:49:21 <merijn> alexander__b: \o/
13:49:40 <alexander__b> it's a verb. "to arse or not to arse".
13:49:57 <johnw> lol
13:50:44 <veryrandomname> how does mfix work?
13:50:51 <merijn> veryrandomname: Voodoo :)
13:50:55 <merijn> veryrandomname: or laziness
13:51:26 <merijn> veryrandomname: Do you understand what this does? "let (x, y) = f x in y"
13:52:47 <veryrandomname> merijn: no. I'm trying hard
13:53:36 <merijn> veryrandomname: It passes one of the results of f as argument to f
13:54:05 <veryrandomname> merijn: oh I didn't even see that!
13:54:19 <jevankovich> how does that even work?
13:54:27 <merijn> jevankovich: laziness :)
13:54:40 <dropdrive> Is there a way to tell Criterion do "try not to use more than X seconds in this benchmark"
13:54:44 <merijn> It relies on the fact that 'f' doesn't need to inspect x to compute "f x"
13:55:03 <jevankovich> Oh. It only works so long as f isn't strict in its first argument?
13:55:09 <merijn> jevankovich: Yeah
13:55:13 <jevankovich> okay
13:55:42 <veryrandomname> merijn: so it works with something like const "a" ?
13:56:01 <veryrandomname> merijn: eh I mean const (1,2) or something
13:56:30 <merijn> veryrandomname: Well, an example I wrote in the past (and lost, so I can't paste it) had a binary tree and a function "f :: a -> a -> Tree a -> (a, a, Tree a)"
13:56:31 <tromp_> > let f x= (x,0) in let (x, y) = f x in y
13:56:32 <lambdabot>   0
13:56:42 <tromp_> is f strict in x?
13:56:46 <alexander__b> typeclassopedia asks for an example of a a * -> * that can't be functor, but IDK any =/
13:57:02 <merijn> veryrandomname: f would insert the first argument in the left most branch of the tree and the second in the rightmost branch of the tree
13:57:13 <tromp_> it is not...
13:57:14 <c_wraith> alexander__b: newtype F a = F (a -> a)
13:57:32 <c_wraith> alexander__b: there are examples that are better-behaved than that one
13:57:40 <ski_> @wiki Tying_the_knot
13:57:41 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_knot
13:57:42 <merijn> veryrandomname: It would return a triple with the leftmost value, rightmost value and the new tree
13:57:44 <ski_> veryrandomname ^
13:57:45 <tromp_> but not being strict in x is not sufficient
13:58:01 <alexander__b> I can barely mention any * -> *s. Maybe. []. Either a. ((->), a). ((,) a)
13:58:12 <tromp_> > let f x= (x,x) in let (x, y) = f x in y
13:58:13 <merijn> veryrandomname: so you could do "let (x, y, tree) = f y x originalTree in tree"
13:58:16 <lambdabot>   mueval-core: Time limit exceeded
13:58:16 <ski_> alexander__b : `IORef',`MVar'
13:58:27 <tromp_> > let f x= (0,x) in let (x, y) = f x in y
13:58:27 <lambdabot>   0
13:58:33 <alexander__b> ski_: I don't know what that means. :-P
13:58:41 <ski_> alexander__b : those can't be functors
13:58:45 <ski_> @kind IORef
13:58:46 <lambdabot> Not in scope: type constructor or class `IORef'
13:58:53 <alexander__b> c_wraith: interesting.
13:58:54 <ski_> @kind Data.IORef.IORef
13:58:55 <lambdabot> * -> *
13:59:04 <alexander__b> ski_: oh, right.
13:59:07 <merijn> veryrandomname: This would swap the left most and rightmost values, by inserting the results of itself (the leftmost and rightmost values) in reverse order in the tree
13:59:10 <alexander__b> ski_: why not?
13:59:18 <ski_> @kind Control.Concurrent.MVar
13:59:19 <lambdabot> * -> *
13:59:22 <merijn> veryrandomname: Which works, because clearly f doesn't need to know what the value are to insert them
13:59:44 <merijn> veryrandomname: Even more similar to mfix is just "fix"
13:59:47 <merijn> :t fix
13:59:48 <lambdabot> (a -> a) -> a
13:59:50 <ski_> alexander__b : because you can't access the value of type `a', without accessing the I/O state hidden in the `IO'monad
13:59:57 <alexander__b> ski_: ah
13:59:57 <merijn> > fix ("Hello! "++)
13:59:58 <lambdabot>   "Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hell...
14:00:19 <ion> Nirvana?
14:00:22 <alexander__b> ski_: I was "hoping" there was some example of precisely that, but I'm not familiar enough with the libraries, heh.
14:00:37 <ski_> alexander__b : in a sense, an `IORef a' doesn't even contain an `a', it's just like an array index, where if you have access to the array, you can use the index to access an element
14:00:51 <ski_> (and similarly for `MVar')
14:01:19 <sipa> > let c = "impossible! " in fix (c++)
14:01:20 <lambdabot>   "impossible! impossible! impossible! impossible! impossible! impossible! im...
14:01:55 <veryrandomname> merijn: ok , but how does mfix run the action only once?
14:02:01 <S_J> > scanl1 (*) 1 [1..10]
14:02:02 <lambdabot>   Couldn't match expected type `[t1] -> t0' with actual type `[a0]'
14:02:12 <S_J> > scanl1 (*) [1..10]
14:02:13 <ski_> (alexander__b : nitpick, `((->), a)' should be `(->) a')
14:02:13 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
14:02:19 <alexander__b> ski_: typo
14:02:26 <ski_> just making sure
14:02:30 <alexander__b> ski_: I almost made it for ((,) a) too
14:03:33 <merijn> veryrandomname: It doesn't
14:03:34 <alexander__b> how do you compose two types?
14:03:41 <merijn> veryrandomname: It runs the action forever
14:03:45 <ski_> veryrandomname : `mfix' works differently for different monads (and not at all for some monads)
14:04:16 <tromp_> > scanl1 (*) [0..]
14:04:17 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:04:20 <alexander__b> "Is this statement true or false? The composition of two Functors is also a Functor." -- does this mean I am supposed to do some sort of type composition? -- please don't answer the question about the statement!
14:04:36 <ski_> @where MonadFix_Cont
14:04:36 <lambdabot> "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-
14:04:36 <lambdabot> slides.pdf>)
14:04:44 <tromp_> > scanl 1 (*) [1..]
14:04:45 <lambdabot>   Could not deduce (GHC.Num.Num
14:04:45 <lambdabot>                      ((a -> a -> a) -> GHC.In...
14:04:45 <merijn> alexander__b: Yes, you have to do type level composition
14:04:52 <veryrandomname> merijn: in this example http://www.haskell.org/haskellwiki/MonadFix it says "the action is not recursively run
14:04:54 <tromp_> :t scanl
14:04:55 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
14:05:02 <tromp_> > scanl (*) 1 [1..]
14:05:03 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
14:05:14 <monochrom> veryrandomname: that is correct, and I wrote it
14:05:17 <merijn> veryrandomname: hmm, I might be mistaken
14:05:18 <tromp_> that gives 0! as well
14:06:01 <merijn> oh!
14:06:01 <ski_> alexander__b : either a type composition, or perhaps just show that for any two concrete `Functor's it's possible to define a composition of them which is a functor
14:06:11 <merijn> Actually, mdo looks like it's exactly what I want :D
14:06:19 <veryrandomname> monochrom: I do believe you. I'm just puzzled how one can only evaluate one expression and not the whole action
14:06:41 <merijn> Now I can eliminate an MVar from my code :D
14:06:59 <alexander__b> found a wiki entry on type composition. will read.
14:07:09 <ski_> @src Maybe mfix
14:07:09 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
14:07:11 <monochrom> mdo is deprecated. try migrating to rec.
14:07:17 <alexander__b> err
14:07:19 <ski_> @src [] mfix
14:07:19 <lambdabot> mfix f = case fix (f . head) of
14:07:19 <lambdabot>            []    -> []
14:07:19 <lambdabot>            (x:_) -> x : mfix (tail . f)
14:07:23 <alexander__b> ok no that didn't help at all lol
14:07:33 <ski_> @src IO mfix
14:07:34 <lambdabot> mfix = fixIO
14:07:35 <ski_> (:
14:08:28 <monochrom> veryrandomname: how it can be done is different for different instances. but you can try to see how it's done for ReaderT, and then for StateT
14:08:57 <veryrandomname> monochrom: ok I will try that. thank you
14:09:06 <monochrom> it is also possible that it can't be done for some monads. I think no one knows how to do it for Cont
14:09:19 <merijn> monochrom: either works for me, it's new code anyway
14:09:36 <merijn> I just didn't realise DoRec was an option for my problem :)
14:09:41 <ski_> alexander__b : e.g. you could claim that `ListMaybe' defined by `data ListMaybe a = Nil | ConsNothing (ListMaybe a) | ConsJust a (ListMaybe a)' is a composition of `[]' and `Maybe'
14:09:47 <monochrom> if it's new code, I urge you to use rec :)
14:10:33 <alexander__b> I feel like I should have read some stuff prior to http://www.haskell.org/haskellwiki/Typeclassopedia
14:10:39 <ski_> monochrom : iirc, Magnus Carlsson (paper above) showed it not possible for the continuation monad
14:10:39 <alexander__b> because it assumes a lot of knowledge I don't have
14:11:06 <merijn> alexander__b: Did you not read anything before typeclassopedia?
14:11:09 <ski_> (but it was a long time since i looked at those, so i might misremember)
14:11:30 <alexander__b> b2coutts: LYAH
14:11:34 <monochrom> oh, I remember now, yes, can't be done for Cont, but can cut some corners
14:11:38 <alexander__b> merijn: eh ^
14:11:44 <merijn> alexander__b: LYAH should cover all of these things
14:11:50 <alexander__b> b2coutts: sorry tabcompletefail. :-)
14:12:26 <alexander__b> merijn: type composition as well? I don't remember that. I remember functors and making things instances of functors. but it's hard to grasp/remember for me.
14:13:00 <merijn> alexander__b: "type composition" is just "make a new datatype that takes them as arguments
14:13:05 <merijn> "data Compose f g a = Compose (f (g a))" :)
14:13:27 <alexander__b> oh
14:14:25 <merijn> Or, using a newtype "newtype Compose f g a = Compose { runCompose :: f (g a) }"
14:14:25 <merijn> "instance (Functor f, Functor g) => Functor (Compose f g) where ..."
14:19:25 <t4nk727> How can I read the filenames of files in a specific folder ordered lexicographically? "getDirectoryContents" from System.Directory  does not do that..? (I also don't get the way this function proceeds concerning reading the filenames)
14:19:25 <t4nk727> ok, I can sort them lexo.
14:19:25 <t4nk727> but how does getDirectoryConents work?
14:19:25 <merijn> t4nk727: It opens the directory and inspects its contents? Not sure what kind of answer you expect here?
14:19:26 <Tene> You can always just look at the source: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/src/System-Directory.html#getDirectoryContents
14:20:40 <t4nk727> ah thanks
16:22:31 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
16:22:31 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
16:22:53 <FreeFull> SLi: Make a minimum test case?
16:24:09 <SLi> The error? The error says that there is no such element in the map :-) Yeah, I'll try to minimize it.
18:24:18 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
18:24:18 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
18:27:17 <nkpart> I just did, it's within one of those '__OSX_AVAILABLE_STARTING' macros, which expands to something like __attribute__((availability(ios,introduced=2.2,deprecated=3.0)))
18:29:24 <dmwit> Okay. It wouldn't surprise me too much to find out gtk2hsC2hs couldn't handle __attribute__s properly.
18:29:37 <dmwit> Have you looked at the OSX building hints on the wiki page?
18:30:14 <roboguy_> is there a good way to modify a single element in a Vector? do you have to explicitly use a mutable vector or can you do an (effectively) in place update outside of a monad?
18:31:43 <shachaf> You can describe in-place update however you like, but the primitives that GHC gives you to actually do it are all in terms of ST or IO.
18:32:17 <nkpart> No, I'll do that. You mean this one for gtk2hs? http://www.haskell.org/haskellwiki/Gtk2Hs/Mac
18:32:19 <roboguy_> shachaf: hmm yeah. maybe it doesn't make sense to do that outside of ST and IO
18:32:32 <shachaf> But for example Data.Vector has various kinds of fusion that use mutability, so I hear.
18:33:18 <dmwit> nkpart: yes
18:34:38 <ogew> newbie question, I am reading on covariant, `data K a = K (a -> Int) -- cannot be functor I kind of understand why`, intutitively, I am guessing `data K a = K (a -> a)` can be functor? can `data K a = K (Int -> a)` be a functor?
18:35:27 * ogew following typeclasspedia
18:35:41 <ski_> `K' defined by `data K a = K (a -> a)' is not a (covariant) functor, because `a' occurs both covariantly (positively) and contravariantly (negatiely) in `a -> a'
18:36:19 <ski_> using `data K a = K (Int -> a)', `K' is a (covariant) functor, since `a' doesn't occur contravariantly in `Int -> a'
18:36:56 <ski_> (but that `K' is not a contravariant functor, since `a' does occur covariantly in `Int -> a')
18:37:41 <ski_> using `data K a = K (a -> Int)', `K' would be a contravariant functor, since `a' doesn't occur covariantly in `a -> Int' (but since it occurs contravariantly, this `K' can't be a covariant functor)
18:38:13 <ogew> ski_: noted thanks.
18:38:32 <ski_> finally, using `data K a = K (Int -> Int)', `a' occurs neither covariantly nor contravariantly in the body `Int -> Int', so `K' is both a covariant as well as a contravariant functor
18:38:48 <leroux> Has anyone had a problem with getting sdl to work?
18:38:49 <leroux> /Users/leroux/.cabal/lib/SDL-0.6.5/ghc-7.6.3/HSSDL-0.6.5.o: unknown symbol `_SDL_HasSSE2'
18:38:57 <haasn> I guess maybe something like a weaker profunctor that gives you dimap' :: (a -> b) -> (b -> a) -> f a -> f b
18:38:57 <leroux> It's OS X.
18:39:10 <elliott> that's Invariant.
18:39:15 <ski_> i.e. you can implement `fmap :: (a -> b) -> (K a -> K b)' as well as `cfmap :: (b -> a) -> (K a -> K b)'
18:39:34 <haasn> elliott: ah, okay
18:39:55 <ski_> in the case when `K' is a covariant functor, this means that `a' occurs covariantly in `K a'
18:40:06 <roboguy_> leroux: are you using the latest GHC?
18:40:06 <ski_> in the case when `K' is a contravariant functor, this means that `a' occurs contrvariantly in `K a'
18:40:15 <leroux> λ :: Downloads  → ghc -v
18:40:16 <leroux> Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.4.2
18:40:30 <ski_> in the `data K a = K (a -> a)' case, one could say that `a' occurs invariantly in `K a'
18:40:50 <leroux> roboguy_: Yes.
18:41:13 <ski_> ogew : hth
18:44:06 <ogew> ski_: what is hth ?
18:45:03 <ski_> "hope this helps" or alternatively "happy to help"
18:45:07 <ogew> ski_: the prelude's Functor is a covariant functor?
18:45:16 <ogew> ski_: yes it does
18:45:23 <ski_> yes, `Functor' is a class for covariant functors
18:45:34 <shachaf> Or alternatively "hope that helps" or "hope that helped".
18:45:42 * ski_ nods
18:45:56 <leroux> roboguy_: I'm trying to get it to work to use Helm.
18:46:43 <ogew> ski_: thanks, they really help, i am noting them all, all 4 examples, as well as cfmap
18:47:15 <ski_> ogew : one way to think of "covariantly/positively" vs. "contravariantly/negatively" occuring is to thing of them as "output" vs. "input"
18:47:40 <ski_> ogew : the first `a' in `a -> a' corresponds to inputs, while the second correspond to outputs
18:47:57 <shachaf> ski_: "instance Functor DList -- Defined in `Data.DList'"
18:48:17 <ski_> while the `a' in `[a]' is only "outputs" (the list doesn't accept any elements of type `a' from you, it provides them *to* you)
18:48:37 <roboguy_> leroux: well, I just tried installing the haskell sdl bindings and it seemed to work ok for me. how did you install the base sdl library that haskell sdl depends on?
18:48:46 <leroux> Yep.
18:48:52 <leroux> Are you on OS X?
18:49:05 <roboguy_> yeah
18:49:09 <leroux> Hmm.
18:49:15 <leroux> So I did $ cabal install sdl
18:49:22 <ski_> ogew : however, not that the `a' in `(a -> Bool) -> Bool' in this sense is then also an "output"
18:49:32 <ski_> s/not/note/
18:49:37 <roboguy_> what about the sdl package that depends on? did you install it with homebrew or macports? or from the source
18:49:39 <ski_> shachaf : hmm !
18:49:48 <leroux> roboguy_: Homebrew.
18:49:57 <roboguy_> hmm, me too
18:50:12 <Ghoul_> reading the second answer here: http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function
18:50:26 <roboguy_> leroux: maybe there's something weird going on with the library path or the output from sdlconfig
18:50:28 <Ghoul_> is there some package that has a heap of templates or classes to make this easier?
18:50:31 <leroux> Possibly...
18:50:37 <leroux> How should I debug this?
18:50:45 <Ghoul_> /s/second/first
18:50:54 <leroux> Hmm.
18:51:04 <leroux> I'm reinstalling SDL right now..
18:51:07 <leroux> And I get
18:51:10 <leroux> configure: WARNING: unrecognized options: --with-compiler, --with-gcc
18:51:16 <leroux> But it continues to compile.
18:52:05 <ogew> <ski_> `K' defined by `data K a = K (a -> a)' is not a (covariant) functor, because `a' occurs both covariantly (positively) and contravariantly (negatiely) in `a -> a'
18:52:40 <ogew> ski_
18:53:11 <ogew> ski_: `data K a b = K (a -> b)` can `K a` be a functor?
18:53:58 <roboguy_> leroux: I'm afraid I don't know too much about that kind of thing, I was just going to see if it was something simple. I would guess that reinstalling sdl could help though.
18:54:04 <leroux> Okay.
18:54:08 <leroux> sdl from brew?
18:54:11 <leroux> I tried already...
18:54:41 <roboguy_> leroux: the only other thing I can think of is that the library path might not point to the place that homebrew installs the libraries (or that the sdl-config program isn't giving the right path)
18:54:48 <ogew> i guess it can... from your explanation
18:54:57 <leroux> Ahh.
18:55:05 <leroux> Could you give me your output for which sdl-config?
18:55:44 <roboguy_> leroux: sure! here's sdl-config --libs: -L/usr/local/lib -lSDLmain -lSDL -Wl,-framework,Cocoa
18:55:52 <leroux> Thmm.
18:56:05 <leroux> I mean.
18:56:08 <leroux> $ which sdl-config
18:56:10 <ski_> shachaf : ah, i see. `fmap id (DL reverse)' is not equal to `DL reverse', but to `DL id'
18:56:18 <adnap> Look what I found: http://hottheory.files.wordpress.com/2013/03/hott-online-207-g21ac918.pdf
18:56:53 <shachaf> ski_: Right. There's an invariant that when you have DL f, f is (equivalent to) (xs ++) for some xs.
18:57:05 <ski_> shachaf : i think this probably(?) works out because the abstract `DList a' type is a subtype of the representation type `[a] -> [a]'
18:58:15 <ski_> ogew : yes, since `b' doesn't occur contravariantly in `a -> b', your `K a' is a covariant functor
18:58:16 <ogew> ski_: `data K a b = K (a -> b)` can `K a` be a functor? Yes because b doesn't occur contravariantly in `a -> b`
18:58:28 * ski_ nods
18:58:31 <ogew> ski_ thanks!
18:58:39 <roboguy_> leroux: actually, when I try to use sdl I get the same error
18:58:41 <roboguy_> that's interesting
18:58:48 <leroux> Hmm.
18:58:51 <roboguy_> same symbol and everything
18:59:03 <ski_> this `K a' is basically the same as `(->) a' (sometimes suggestively typed as `(a ->)')
18:59:18 <ion> Is there a data K a b = … where K a cannot be a functor?
18:59:20 <leroux> I wonder if someone else has run into this problem before.
18:59:36 <ski_> > (fmap (^ 2) (* 3)) 2
18:59:37 <lambdabot>   36
19:00:14 <ogew> ion: data K a b = K (b -> b)  -- cannot be functor
19:00:14 <ski_> ion : `data K a b = MkK (IORef b)' ?
19:00:39 <ion> True, thanks
19:01:06 <ogew> ion: data K a b = K (b -> a)  -- cannot be fucntor too
19:01:11 <ogew> ski_: amirite:)
19:01:37 <ski_> ogew : do you mean that `K a' can't be a (covariant) functor ?
19:01:50 <ogew> yep
19:02:04 <ski_> it looks right, yes
19:02:08 <ogew> ah that is enlightening
19:03:00 <shachaf> ion: The real question is whether there can be K a = ... where K can't be an "invariant functor".
19:03:14 <shachaf> ion: class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b, with the usual functor laws.
19:03:32 <haasn>  shachaf: judging by the class description, no
19:03:54 <shachaf> The answer is not for regular ADTs, i.e. types made from just products, sums, and functions (and recursion)
19:04:08 <shachaf> But using GADTs or rank-2 types you can do it.
19:04:32 <roboguy_> leroux: I wrote a small C program that uses SDL_HasSSE2 and it compiles, links and runs fine
19:04:33 <roboguy_> weird
19:04:40 <leroux> Hmm.
19:04:53 <leroux> So it must be a problem in the cabal install sdl.
19:05:01 <roboguy_> leroux: looks like it
19:07:24 <ski_> shachaf : with the two arguments required to be inverses ?
19:07:28 <tswett> Anyone here familiar with linear typing? What I'm wondering is if there's a programming language that uses the entirety of linear logic for a type system.
19:08:24 <tswett> I know that Clean has uniqueness typing, which has at least some of the features of linear typing. But there are two things I don't know if it has: the "with" and "plus" connectives, and the "bottom" connective.
19:08:26 <shachaf> ski_: I don't think so. Just laws that invmap id id = id and such.
19:08:44 <ski_> shachaf : "whether there can be .... where K can't be an \"invariant functor\"." -- and `IORef'
19:09:36 <shachaf> ski_: OK. I count that as "special weird type things", except it's even more weird because it's less principled. :-)
19:14:11 <t4nk201> Hi, When I use syntax.vim to check my haskell project, it could only load the current file, so will always report error when I am using multiple files, any suggestion?
19:14:49 <ogew> <shachaf> ion: class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b, with the usual functor laws, how do I make `data K a = K (a -> a)` an instance of Invariant
19:14:50 <ski_> tswett : perhaps Linear Twelf .. <http://web.archive.org/web/20070423200704/http://theory.stanford.edu/~iliano/LLF/LLF.html>,<http://ropas.snu.ac.kr/seminar/20000710.html>,<http://www.cs.cmu.edu/~fp/courses/15816-s98/ltwelf.html>
19:15:13 <ski_> tswett : btw, note that uniqueness typing isn't the same thing as linear typing
19:15:14 <Guest94965> how can we make binary tree type an instance of Functor, my main issue is how do i define fmap for it
19:15:30 <shachaf> ogew: It's very confusing when you add text to other people's quoted lines like that. :-(
19:15:50 <shachaf> ogew: Anyway, this is a good exercise.
19:16:11 <ski_> tswett : a unique value is one which haven't been copied *yet*, while a linear value would be one which won't be copied anymore in the future
19:16:27 <ogew> ok ;) original: <shachaf> ion: class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b, with the usual functor laws
19:16:40 <tswett> ski_: *nod* So Clean definitely isn't linear.
19:17:21 <ski_> (so if "copying" means "copying a reference", then you can't safely use update-in-place on linear values, since a reference might have been copied before one of them got "derelicted" to linear status)
19:19:03 <Guest94965> if we apply the function we fmap to all nodes in a binary tree, and the resultant values doesnt result in a binary tree, as in root node becomes smaller than left node after function application,
19:19:14 <ski_> tswett : right. btw, note that Mercury <http://www.mercurylang.org> uses a relatively similar idea as Clean's uniqueness typing, though in Mercury, it's part of the mode system, not the type system (and there's no uniqueness type variables (and hence no bounded polymorphism for them either), also there is in a sense a (logically benevolent) overloading possible in the mode system)
19:20:15 <ski_> hm, <http://bach.istc.kobe-u.ac.jp/llp/> is another Linear Twelf link
19:20:43 <tswett> Now, if I understand correctly, "with" isn't really meaningful with uniqueness typing, because every value can be copied, and copying a "with" defeats its putpose.
19:20:45 <tswett> Is that right?
19:21:45 <ski_> tswett : btw, while not having linear *types*, the linear logic based logic programming languages Lolli <http://www.lix.polytechnique.fr/~dale/lolli/> and Lygon <http://www.cs.rmit.edu.au/lygon/> might perhaps still be interesting
19:22:56 <ski_> you might also want to look at lambdaProlog <http://www.lix.polytechnique.fr/~dale/lProlog/>, on which Lolli (at least) is based on (by replacing the intuitionistic logic by a linear intuitionistic logic)
19:23:37 <ski_> Guest94965 : "binary tree" isn't the same as "binary search tree"
19:23:46 <Guest94965> http://stackoverflow.com/a/2756680 for more detailed explanation,
19:25:05 <Guest94965> ski_: sorry for the mistake.. hope my doubt is clear.. how do i handle this?
19:27:48 <ski_> "Linear Logic: Linear Twelf" <http://www.cs.cmu.edu/~fp/courses/15816-s98/ltwelf.html>
19:28:36 <ski_> Guest94965 : you can't
19:29:45 <Guest94965> so binary search tree cannot be an instance of functor?
19:29:59 <haasn> not if you want to make ‘fmap’ preserve the sorted property
19:30:48 <haasn> parametricity prevents you from knowing anything about the polymorphic variable ‘a’ in ‘BST a’ in the definition of fmap
19:30:49 <Guest94965> yes i want to make fmap preserve the property, how do i do it?
19:30:55 <ogew> shachaf: thanks, i understood the invmap now
19:30:56 <hiptobecubic> you could make fmap map over values instead of keys though, no?
19:30:56 <haasn> so as a result, it's completely impossible to eg. sort it
19:30:58 <ski_> Guest94965 : the type signature `fmap :: (a -> b) -> (F a -> F b)' for a specific functor `F' requires that `fmap' can map a function returning a value in *any* type `b' ("any" here meaning that the *caller* of `fmap' chooses `b', out, the imeplementer of `fmap' can't set any restrictions on `b')
19:31:09 <haasn> Guest94965: write your own function that is not ‘fmap’ but does a similar thing
19:31:18 <haasn> eg. mapBST :: (Ord a, Ord b) => (a -> b) -> BST a -> BST b
19:31:40 <ski_> Guest94965 : while, to implement the mapping operation you want, you have to require `b' to be an orderable type
19:31:54 <haasn> as you'll see this is less general than fmap (due to the Ord a, Ord b requirements) but still very close
19:32:36 <haasn> (you might also break mapBST f . mapBST g = mapBST (f . g) by accidentally re-ordering things that compare as EQ)
19:33:13 <prophile> this is why Data.Set doesn't have a functor instance
19:33:25 <haasn> this is why we need lenses =)
19:33:35 <ski_> tswett : "\"with\" isn't really meaningful with uniqueness typing, because every value can be copied, and copying a \"with\" defeats its putpose. Is that right?" -- i'm not sure
19:34:12 * hackagebot llvm-general 3.2.4.5 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.4.5 (BenjaminScarlet)
19:34:14 * hackagebot llvm-general 3.3.4.5 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.4.5 (BenjaminScarlet)
19:34:21 <roboguy_> haasn: how do lenses relate? I don't know very much about lenses
19:36:27 <haasn> roboguy_: a subset of lenses, setters, are generalizations of functors; eg. Data.Set.setmapped :: (Ord i, Ord j) => Setter (Set i) (Set j) i j -- but still giving you the entire lens API worth of functions to work with
19:36:46 <haasn> compare mapped :: Functor f => Setter (f i) (f j) i j
19:37:16 <roboguy_> haasn: interesting. I've often wondered about Functor like things (that aren't *quite* functors). lens seems a little impenetrable to me, though
19:37:52 <haasn> lens is just a rabbit hole that goes down very deep, it's easy to get into the basics (and there are also other lens packages that aren't ‘lens’ that might be easier to understand conceptually)
19:40:42 <roboguy_> haasn: I read an article or two on what I guess is the basics (which looks a lot like imperative OO programming), but I never know where to go from there. it seems so big. also, sometimes the articles seem incompatible with the lens implementation I'm using (probably since there are multiple lens libraries) which confuses me more
19:43:01 <haasn> roboguy_: have you seen https://github.com/ekmett/lens/wiki/Overview ?
19:43:16 <haasn> that one's fully compatible with ‘lens’, the premier fully featured lens implementation
19:43:26 <roboguy_> haasn: I don't think so, I'll take a look
19:43:29 <haasn> actually, it's a bit outdated on the naming
19:43:32 <haasn> Simple Lens is now Lens'
19:43:49 <haasn> and _1 and _2 are bit more general, but the generalizations all go back to the signatures shown
19:44:01 <roboguy_> haasn: the type synonyms also confuse me, but I guess I should try to ignore what they actually mean for now
19:44:18 <haasn> if you're interested in the internal workings I also recommend reading https://github.com/ekmett/lens/wiki/Derivation
19:44:26 <haasn> then the type synonyms don't have to confuse you. as much :)
19:44:36 <roboguy_> haasn: haha, alright that sounds good
19:44:36 * shachaf should finish writing his lens introduction one of these days.
19:44:49 <roboguy_> shachaf: I would definitely read it
19:44:50 <shachaf> I found Derivation confusing.
19:45:42 <roboguy_> from what I've gathered over time, it sounds like lenses are quite a bit more useful than just doing sort of OO-like stuff
19:45:54 <haasn> shachaf: possible. I read it after I already understood the internal workings to the degree presented there
19:46:29 <haasn> I think my first introduction to this style of lens in general was http://r6.ca/blog/20120623T104901Z.html
19:46:29 <shachaf> I think the right approach to understanding the basic idea of lens is to understand Traversal.
19:46:41 <shachaf> Since everyone understands mapM (right?).
19:46:51 <haasn> yeah that seems like a good idea
19:47:01 <shachaf> Then you can see how you can specialize it in various ways to get various things. But the original pattern makes sense, rather than just looking contrived.
19:47:36 <shachaf> Anyway, that's one approach. Maybe profunctor lenses are an even better way of understanding "lens". :-)
19:47:58 <haasn> The unique property is that ‘traverse’ is the standard Traversal, whereas for Setter we need separate functions like ‘mapped’ (which are essentially ‘fmap’ but with a signature more like ‘traverse’)
19:48:04 <haasn> but ‘traverse’ is a function everybody is already familiar with
19:48:11 <shachaf> Yes.
19:48:29 <shachaf> (Well, if you're familiar with mapM and with Applicative, you can figure out traverse.)
19:49:16 <shachaf> haasn: The SEC approach starts with fmap, which is even simpler.
19:49:23 <roboguy_> I am familiar with mapM and Applicative. I guess I should look at Traversal
19:49:29 <shachaf> But I'm not sure it's as useful pedagogically...
19:49:32 <haasn> shachaf: well yeah, that's the path given in Derivation
19:49:36 <haasn> he starts with (.), heh
19:49:40 <tabemann> case implementation question
19:49:46 <shachaf> haasn: No, I mean for profunctor lenses.
19:49:49 <lightquake> I need to make a lot of HTTP requests to a server (about 2000 or so) and do something with the results by combining them all together; these requests can be made in paralllel. I also would like to be able to throttle the request rate so I don't wreck the server, and be able to easily dummy out the request logic with something that doesn't actually make a request for testing purposes
19:49:52 <haasn> oh
19:49:55 <lightquake> what's a good library for this?
19:49:56 <tabemann> is case ... of implemented to optimize for earlier cases over later cases?
19:50:02 <shachaf> The whole (.).(.) is just confusing for the most part.
19:50:08 <haasn> shachaf: eg. p a b -> p (f a) (f b) ?
19:50:19 <lightquake> tabemann: in the general case, case of will pattern-match in order
19:50:47 <tabemann> I mean, does it generate code optimized to assume that cases *will* be followed?
19:51:13 <lightquake> ah, that i don't know
19:51:14 <tabemann> i.e. does it tell the branch predictor that the cases will be followed or will not be followed
19:51:22 <haasn> roboguy_: in a broad sense, lenses are useful whenever you need to update or read out data structures
19:51:29 <haasn> which, in functional programming, happens to be almost always
19:51:39 <haasn> they have the unique ability of being able to compose them very well
19:53:07 <lightquake> I seem to vaguely remember the pipes library being good at enabling this sort of thing, but I've never used it
19:53:22 <roboguy_> shachaf: I think I understand the (.).(.) stuff. it was confusing at first, but it makes more sense now
19:54:03 <tabemann> lightquake: specifically, what I'm wondering about is, for a case where the first case is the common case, will adding more things to the case have any added expense
19:54:06 <haasn> I guess the (.).(.) thing was really just a shoutout to a common golf trick, and not really as part of an introduction to lenses
19:54:28 <haasn> (but it's essentially the same thing as fmap.fmap, for that matter, just less specialized and possibly more confusing)
19:54:33 <haasn> less general*
19:54:46 <tabemann> I'm just asking because, in what I'm implementing, there's two main ways I could implement certain things, and how cases behave when you add more items to them would likely make me decide which way I want to implement it
19:55:03 <Saizan> lightquake: if you don't find a library it's not too hard to spawn a fixed number of threads and feed them IO actions to run through a channel
19:55:19 <lightquake> tabemann: I wouldn't worry about it unless profiling indicates you need to
19:55:21 <tabemann> hmm... I might want to implement it one way because it'll be faster anyways and won't really have any added expense
19:55:37 <tabemann> lightquake: I'm basically implementing the inner loop of a VM, which is why I'm wondering
19:57:18 <lightquake> Saizan: sure, that works
19:58:09 <tabemann> well... people aren't probably going to be applying continuations *that* often, so I can probably afford a bit of added expense for that for the sake of simpler VM code
19:58:35 <lightquake> Saizan: i was hoping to use this as an excuse to use pipes, especially because I want to be able to do my own cacheing layer and such
19:58:45 <lightquake> (the server I'm making these requests against is… not smart)
19:59:14 <adnap> In, "(bottom, false) U (true, bottom) = (true, false)", what is U?
19:59:52 <ski_> least upper bound, i'd assume
20:00:43 <thoughtpolice> tabemann: GHC doesn't do any fancy branch predictor optimizations. case statements become jump tables in the general case, but it really depends on what you're doing
20:01:16 <haasn> tabemann: afaik it uses basic branching until a certain number of patterns at which point it uses a jump table
20:02:21 <Saizan> lightquake: i don't have experience with pipes but it didn't seem to help with concurrency, could still help about structuring the whole thing
20:02:32 <tabemann> okay, so I probably want to shrink the number of cases such that it's not using indirect branches for common cases, whereas my uncommon cases will be implemented as indirect branches because I'll be branching into closures for them
20:03:30 <adnap> I thought "least upper bound" is a specific element of a set, but here--let B' = {true, false, bottom}--U acts as a function from (B' x B') x (B' x B') -> (B' x B'), right?
20:03:37 <haasn> tabemann: again, I'd benchmark this thing to be sure. But if you have one extremely common case then it might make a difference to use something like: case x of pattern -> code; x -> case x of ... rest
20:03:40 <haasn> no idea. bench it.
20:04:21 <thoughtpolice> honestly you should just profile and read the Core when you want some more insight. the real answers in this case will lie in the Cmm that's generated
20:04:37 <thoughtpolice> but yes, benchmark it if you need to
20:05:48 <tabemann> I can't really benchmark at all until I have this built, where then I'd have to change a whole lot of stuff to change it
20:06:04 <tabemann> and I know this is a common case, as basically the return of every single function application will pass through this code
20:06:18 <adnap> For Y with partial order <=, if X \subset Y, the least upper bound is an element y \in Y such that x <= y for all x \in X and if x <= y' for all X and for some y \in Y, y <= y'
20:06:42 <tabemann> but I've decided which way to go already simply because it'll make my code nicer and more modular
20:06:48 <roboguy_> thoughtpolice: can you look at the cmm code that ghc generates?
20:07:05 <thoughtpolice> ghc -O2 -ddump-cmm ...
20:07:16 <roboguy_> ah, ok. cool
20:07:34 <thoughtpolice> it won't make any sense at all unless you know the operational model pretty well. Core is a lot easier
20:07:49 <thoughtpolice> especially if you supress a lot of the extra stuff it outputs
20:09:07 <adnap> In this case, is U something which takes y_1, y_2 \in Y and finds y \in Y such that y is a least upper bound of {y_1, y_2} ?
20:09:34 <skjermlaus> Is it possible to build win32 binaries (.exe) using GHC from linux?
20:11:01 <haasn> skjermlaus: https://r.duckduckgo.com/l/?kh=-1&uddg=http%3A%2F%2Fhackage.haskell.org%2Ftrac%2Fghc%2Fwiki%2FBuilding%2FCrossCompiling might be relevant
20:11:05 <haasn> oops
20:11:08 <haasn> http://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
20:11:10 <haasn> better link
20:11:16 <thoughtpolice> that only applies to GHC HEAD
20:11:40 <thoughtpolice> and it doesn't fully work yet; no stage2 compiler (so no GHCi/Template Haskell or features dependent on them)
20:12:09 <haasn> ok
20:12:29 <skjermlaus> doubt I'll bother with it then, thanks for the help
20:12:39 <Gracenotes> thoughtpolice: hm, is there anything different in <=stage1 compared to 7.6.3?
20:12:43 <geekosaur> in general cross compiling doesn't work; the LLVM backend has made it potentially possible, but with very limited exceptions it's still potential. (the ARM folks got some mileage out of it, but it involved much banging of heads against brick walls)
20:12:51 <haasn> I wonder if you can run the windows build of GHC with wine
20:13:00 <thoughtpolice> Gracenotes: what do you mean?
20:13:23 <Gracenotes> compared to HEAD, for cross-compilation purposes
20:14:27 <thoughtpolice> Gracenotes: i mean, a lot of the work is A) build system stuff and B) removing stuff like #ifdefs and whatnot
20:15:53 <Gracenotes> thoughtpolice: I'm running into some trouble with cross-compilation with ghc-cabal.. it seems to default to testing configurations with native programs
20:15:59 <shachaf> instance Comonoid r => Monad (r ->) -- > /me / 3
20:16:45 <Gracenotes> and I haven't even got to linking, let along running
20:19:38 <thoughtpolice> well, that can be fixed of course. like i said, it's just not pretty right now. but it can work
20:20:00 <thoughtpolice> the idea is that eventually stage1 will be able to function as a cross compiler, and a compiler port will be the stage2 compiler for that platform
20:20:10 <thoughtpolice> that's because stage2 needs dynamic linking features in the *host* operating system
20:22:52 <thoughtpolice> now, there are also ways we could eventually overcome that I think (laid out by dcoutts,) but there are some subtle parts too
20:23:13 <thoughtpolice> (also there's probably a lot of bugs and stuff of course.)
20:52:41 <Gracenotes> http://uncyclopedia.wikia.com/wiki/Peer
21:09:02 <pentace> Anyone knows if cairo has some kind of overlays, so that you don't need to re-render a graphics or only small parts of it?
21:11:35 <lispy> pentace: you mean for keeping track of which parts of the screen are "dirty"?
21:11:37 <ChongLi> where does ghci look for .dll files?
21:12:03 <lispy> ChongLi: http://msdn.microsoft.com/en-us/library/7d83bc18(v=vs.80).aspx
21:12:21 <lispy> ChongLi: It's possible that ghci adds some GHC specific package directories, but I'm not sure
21:12:33 <pentace> lispy: Kind of
21:12:58 <pentace> I want to display small boxes of information when hovering with the mouse over certain regions
21:12:59 <lispy> pentace: okay. I don't know the answer to your question (I've never used cairo). I just wanted to checked.
21:13:46 <ChongLi> yeah it won't find the dll even though it's in the current directory
21:14:53 <lispy> ChongLi: that's odd. I'm pretty sure I've had that work before. It's possible that the error message is in accurate. Maybe try --verbose?
21:16:12 <Cale> pentace: You should be rendering into a pixmap, and then drawing that pixmap.
21:16:37 <ChongLi> going to paste it
21:16:47 <ChongLi> hpaste.org seems down
21:16:55 <shachaf> See topic.
21:16:55 <Ghoul_> anyone know if gabriel gonzales hangs out here?
21:17:21 <ChongLi> ahh
21:17:24 <pentace> Cale: So can you render a pixmap plus additional elements on top of it?
21:17:45 <hpaste> ChongLi pasted “SDL” at http://lpaste.net/91222
21:17:59 <Cale> Sure
21:18:36 <timbod> I'm just playing with hoogle for the first time, and I don't understand it. Text queries seem ok, but type queries don't do what I expect: hoogle 'Ord a => [a] -> [a]' returns 1746 matches, including things with types nothing like the one specified. Any ideas??
21:19:26 <pentace> Cale: Do you know how such a pixmap is called in cairo, by chance?
21:19:31 <Cale> pentace: If you want to see an example of this, have a look at nymphaea on hackage. It's a little hack that I did with Paolo Martini a long time ago (he went by the name of xerox here, but I haven't seen him around in a long time)
21:19:50 <pentace> Okay, I will, thanks!
21:19:55 <Cale> You can render into a pixmap using renderWithDrawable
21:20:27 <ChongLi> lispy: did you see the paste?
21:20:33 <lispy> ChongLi: oh weird. BTW, instead of fighting with SDL, you could use GLFW-b
21:20:56 <lispy> ChongLi: I have some examples that use it and work on windows with 0 fuss: https://github.com/dagit/nehe-tuts
21:21:02 <lispy> ChongLi: or cabal install nehe-tuts
21:21:06 <ChongLi> it's my friend
21:21:08 <ChongLi> he's using helm
21:21:12 <ChongLi> not SDL directly
21:21:58 <pentace> Oh, it's in gtk not in the cairo package ...
21:29:43 <dakrone> could anyone tell me what the correct return type for http://p.draines.com/137481288294073601a88.txt is? I get http://p.draines.com/1374812933746157b526c.txt when running it, but returning IO (L.ByteString) doesn't seem to fix it
21:30:33 <shachaf> dakrone: What are the types of all those things?
21:31:36 <dakrone> shachaf: http://hackage.haskell.org/packages/archive/http-conduit/1.8.7/doc/html/Network-HTTP-Conduit.html#t:Response is the response object
21:32:06 <dakrone> I'm sorry I don't know entirely what to tell you about what the types are, not that familiar with Haskell
21:32:49 <dakrone> just trying to return the body as a string
21:33:45 <shachaf> A ByteString isn't a string. :-(
21:33:56 <shachaf> Anyway, you should figure out the types.
21:34:01 <shachaf> For example, what's the type of res?
21:34:06 <johnw> poor shachaf, he must have to say that at least 3 times every day
21:34:18 <johnw> it just shouldn't be called a Byte*String*, should it
21:34:20 <dakrone> shachaf: 'res' is the Response type from http-conduit
21:34:31 <shachaf> johnw: Indeed it shouldn't.
21:34:31 <johnw> Bytes might have been better
21:34:55 <shachaf> dakrone: Maybe you want "return (responseBody res)"?
21:35:12 <shachaf> dakrone: Wait, you can't return the ByteString. Look at the type: httpGet :: String -> IO ()
21:35:29 <dakrone> shachaf: yea, that's the type declaration I'm trying to fix
21:35:31 <shachaf> You're saying that you return () (i.e. nothing of value).
21:35:48 <dakrone> yep, I originally wanted IO (String), but was unsure how to convert it
21:35:55 <dakrone> IO (ByteString) is fine too
21:36:00 <shachaf> Are you doing this to learn Haskell? I'd recommend reading some introduction to Haskell first.
21:36:12 <shachaf> OK, then String -> IO L.ByteString, and then "return (...)"
21:36:31 <dakrone> shachaf: I am yea, just trying to write something that does an HTTP request and parses some json
21:37:31 <dakrone> shachaf: that did it, I appreciate the help; sorry for the silly questions
21:37:37 <shachaf> Hmm, I suggest that that's not the best way to learn Haskell.
21:38:22 <shachaf> It's most likely a different kind of language from what you're used to and spending some time up-front on the basics will probably help a lot with things like this.
21:38:54 <dakrone> shachaf: yes, I come from a Clojure background, so no types there :)
21:39:14 <Gracenotes> I hear Clojure has /some/ types
21:39:40 <lispy> sum types?
21:41:34 <aarcane> so I've got a condition guarded by `mod` 2 == 0, and I'm dividing the int argument by 2, namely (len / 2), and it's giving me an Fracitonal Int, but I need to to evaluate it to just an Int.  What do I do ?
21:41:40 <Gracenotes> I hear Scala has /some/ constructor
21:41:44 <pentace> Cale: In that example there are notes like "GHC's garbage collection is poor for ForeignRefs to large objects so we have to be careful". Is there something special you have to take care of?
21:42:24 <mrler> you can use "quot" for integer division
21:43:11 <Gracenotes> 'div' is more standard
21:43:19 <Gracenotes> idiomatically, at least
21:43:24 <Cale> pentace: I'm unsure as to whether that comment still applies or not. I believe that was written when we were on GHC 6.4, and a lot has changed.
21:43:25 <Gracenotes> and a bit more efficient
21:43:53 <roboguy_> Gracenotes: what's the difference between div and quot?
21:44:06 <Gracenotes> or is it the other way around
21:44:17 <Cale> Still, I wouldn't be *too* surprised if that hasn't improved. Basically, ForeignPtrs are single pointers to potentially large blocks of data, and the Haskell GC doesn't know how much data that is, and it won't be counted against the Haskell heap.
21:44:18 <Gracenotes> either way, div is more commonly used
21:44:40 <Cale> but finalisers will only run when the ForeignPtr is *actually* GCed.
21:44:57 <Cale> (at least, this is all in my recollection of things)
21:45:36 <pentace> That means I could potentially run out of memeory if I render the graphics too often?
21:45:49 <pentace> *memory
21:46:19 <Cale> yeah, even if you lose reference to the old ForeignPtr, if the garbage collection doesn't actually happen soon enough for you, there might be problems if you're rendering lots of things really quickly
21:47:40 <pentace> Hhm, I guess the pixmap shouldn't change that often. I will try to implement it tomorrow and see what happens :)
21:47:43 <Cale> I mean, if you're creating lots of new pixmaps really quickly.
21:48:01 <pentace> Thanks again for the pointer!
21:48:23 <frx> aren't GTK objects ref counted?
21:48:45 <frx> if the topic is gtk objects..
21:49:16 <pentace> Yes, I'm using cairo from gtk2hs
21:53:29 <hpaste> aarcane pasted “center list in padding homework” at http://lpaste.net/91223
21:54:38 <Cale> frx: Well, we're talking about GDK Pixmaps, whose Haskell side representation is just a ForeignPtr whose finaliser will reduce the reference count to the object on the C side.
21:55:13 <aarcane> so uh..  What hpaste said.  I'm working on that for my homework, and the sub functions work.  mylength "center" returns 6, and pad 2 '-' returns "--", but for some reason center "center" 10 '-' just returns "center"
21:55:39 <aarcane> and I can't figure out what's wrong, and yes I am allowed to ask for help
21:56:39 <mauke> mod x 2 == 0 better written as even x
21:56:41 <Cale> Why are you pattern matching the list as (x:xs)?
21:57:07 <aarcane> Cale, because it didn't match anything but a single element list when I tried [x]
21:57:14 <Cale> why not just put xs there?
21:57:18 <aarcane> Cale, maybe I'm confusing it with prolog
21:57:19 <mauke> that's because [x] means (x : [])
21:58:00 <Gracenotes> what does center do?
21:58:04 <bss03> @ty replicate
21:58:05 <lambdabot> Int -> a -> [a]
21:58:16 <bss03> makepad = replicate
21:58:34 <mauke> except replicate handles 0
21:58:39 <bss03> @ty foldl'
21:58:40 <lambdabot> (a -> b -> a) -> a -> [b] -> a
21:58:47 <bss03> @ty const . succ
21:58:48 <lambdabot> Enum b => b -> b1 -> b
21:59:01 <aarcane> I have to write it all by hand, so I can't use anything but arithmetic operators.
21:59:10 <bss03> mylength = foldl' (const . succ) 0
21:59:16 <Gracenotes> let's not jump too quickly to library functions
21:59:24 <aarcane> so no library functions
21:59:58 <Gracenotes> what does center do?
22:00:22 <aarcane> and the example output is center "center" 6 '-' = "center", center "center" 7 '-' = "-center", and center "center" 10 '-' = "--center--"
22:00:25 <Gracenotes> it seems to be a good start, if it's correct, but you can see its imperative roots :)
22:00:31 <bss03> Gracenotes: Example: center "text" 10 ' ' = "   text   "
22:00:41 <bss03> Gracenotes: Example: center "text" 2 ' ' = "text"
22:00:48 <Cale> aarcane: You should also try center "center" 1 '-' and see what happens
22:00:48 <bss03> Gracenotes: Example: center "text" 5 ' ' = " text"
22:01:04 <Gracenotes> If I had a nickel for every example that was given to me
22:01:27 <aarcane> Cale, that returns the empty string
22:01:45 <Cale> aarcane: Oh does it?
22:01:58 <Cale> aarcane: I'm pretty sure that it doesn't, with the code you pasted.
22:02:10 <Cale> It in fact returns an infinitely long string.
22:02:19 <aarcane> eee
22:02:26 <Ghoul_> Anyone know why Pipes-Network uses Proxy and not Frames?
22:02:32 <aarcane> you're right.  I ran center "" 1 '-'
22:02:48 <edwardk> startling: yes
22:03:03 <bss03> Ghoul_: Too old for Frames (maybe?)
22:03:16 <Cale> aarcane: (that's just because makepad produces an infinitely long string when you give it a length of 0)
22:03:19 <Ghoul_> Oh, I didn't know they were new
22:03:30 <Ghoul_> Any idea if I should be aiming to use Frames instead of Proxy?
22:04:22 * aarcane plotz
22:04:25 <Ghoul_> "pipes-2.0.0: The introduction of Frames, later deprecated in favor of pipes-safe." baw, low lifetime
22:04:33 <Ghoul_> Looks like Proxy is the-go right now.
22:04:35 <Cale> makepad 0 'a' = 'a' : makepad (-1) 'a' = 'a' : 'a' : makepad (-2) 'a' = ...
22:05:01 <bss03> Ghoul_: Sorry, haven't surveyed the pipes ecosystem for many months, myself.  I seem to remember something about deprecating frames in favor of the "protocol" of pipes-parse or smth like that.  (maybe?)
22:05:06 <Cale> actually, because you used Int, it won't be infinitely long, just very very long :)
22:05:10 <aarcane> okay
22:05:35 <aarcane> I found the first major problem, which is that the <= operator should be >=, and I think I can handle it from here :)
22:05:40 <aarcane> Thanks folks, for bearing with me :)
22:06:25 <Cale> aarcane: While it's okay not to worry about efficiency too much when you're just starting out, it's worth noting that if you write mylength xs twice, it'll potentially be computed twice.
22:06:56 <Cale> aarcane: You might want to define the length of the string in a where clause at the end
22:07:00 <aarcane> Cale, I tried to solve that on another problem, but I couldn't find a way to store mylength xs in a new variable
22:07:08 <Cale> Where clauses scope over guards
22:07:14 <Cale> i.e. you'd have
22:07:32 <Cale> center xs len pad
22:07:34 <Cale>   | ...
22:07:37 <Cale>   | ...
22:07:46 <Cale>  where n = length xs
22:07:53 <aarcane> oh, nice
22:07:56 <aarcane> thanks Cale :)
22:09:36 <mauke> center xs len pad = center2 (length xs) xs len pad
22:09:48 <mauke> center2 n xs len pad = ...
22:10:46 <Cale> You could also do that...
22:17:14 <bss03> center pad len xs = let { lpad n ys = if n < len then rpad (n + 1) (pad:ys) else ys; rpad n ys = if n < len then lpad (n + 1) (ys ++ [pad]) else ys; } in lpad (length xs) xs ?
22:19:24 <bss03> The appending elements on both sides makes me think a banker's queue is a good format for xs instead of a list.
22:19:35 <Gracenotes> there are also some "one-pass" formulations you could make, if you don't need clarity
22:20:16 <pentace> Is there a difference between using a single IORef to store a record with many values and using multiple IORefs for each value?
22:20:21 <Gracenotes> i.e. combine length and center into the same recursive function
22:20:30 <pentace> beside the obious one ;)
22:20:39 <pentace> *obvious
22:20:44 <Gracenotes> is atomicity obvious?
22:21:09 <pentace> hmm
22:21:21 <Gracenotes> you can be guaranteed consistency if all you're doing is swapping out a pointer.
22:21:39 <Gracenotes> well, maybe the runtime can't, but I can. buy my warrantee etc.
22:21:46 <Gracenotes> s/runtime/specification/
22:22:10 <pentace> Atomicity shouldn't be a problem in single-threaded programs, no?
22:22:45 <aarcane> it's just homework.  Obviously efficiency isn't an issue, but readability is.
22:23:06 <aarcane> and if I spend any significant amount of time writing Haskell in the future, I'll focus on clarity and learning the built in library.
22:23:22 <aarcane> For now, thank you everyone.  I've been able to solve the problem well enough.  It's bed time :)
22:23:53 * bss03 should be sleeping.
22:33:08 <NemesisD> hi all, i'm trying to understand a use of an existentially quantified type
22:33:11 <MrWoohoo> I've been reading about ADTs and how things like derivatives made sense in type algebras and whatnot… got me wondering if there is a concept of a "prime" type?
22:33:59 <NemesisD> Ord a => q a -> (forall x. Ord x => x -> x -> Bool) -> a -> Table t -> Table t
22:34:16 <NemesisD> the existential quantification of x there means i couldn't provide a function specialized to Foo -> Foo -> Bool?
22:35:18 <bss03> I'm always a but fuzzy on existentials in Haskell, but yes, I believe that's true.
22:35:42 <bss03> It would have to be a function that works for any Ord, like (==) or (<).
22:35:44 <NemesisD> bummer, although i'm sure there's a good reason for it to be existential
22:36:33 <pentace> MrWoohoo: What do you mean by prime?
22:39:29 <MrWoohoo> LOL Yes, that's what I'm asking I guess… they talk about Algebraic Data Types and then do things like take derevatives of types (one hole context it turns out)… so if things like deratives makes sense… does something like primality make sense in a type algebra
22:39:42 <MrWoohoo> ?
22:40:10 <shachaf> Well, you can have a finite type with a prime number of inhabitants.
22:40:15 <bss03> I think first you have to define division or at least divisibility.
22:40:52 <shachaf> You don't need division for that, just multiplication.
22:41:15 <MrWoohoo> One of the articles on reddit I saw I suspect did some hand waving when it came to division, but it seemed to be logical nonetheless
22:41:46 <shachaf> You can say that T is prime if (A,B) ~~ T means that one of A or B is 1. Or something.
22:41:58 <shachaf> I don't know that that's particularly interesting.
22:42:51 <bss03> Well, you can do the same "trick" of rewriting divisions isn't infinite series and the get correct combinatorial results too... but it doesn't really difine division it just "factors it out" for certain shapes.
22:49:01 <pharaun> Is there any way to look back at the consumed input in parsec and extract it ?
22:50:16 <pharaun> aka for ex i want to be able to do "many1 (anyToken `manyTill` foobar)" and include the foobar expression in the returned string, right now its eating it
22:55:53 <pharaun> well i've figured it out :)
22:56:44 <pharaun> i took the manyTill and wrote a new version that returned the end, but would be nice if i could do what i want with the provided combinator
23:01:32 <dmj> > :t Any
23:01:34 <lambdabot>   <hint>:1:1: parse error on input `:'
23:03:10 <bss03> @ty any
23:03:10 <lambdabot> (a -> Bool) -> [a] -> Bool
23:03:18 <bss03> dmj: ^^
23:04:40 <dmj> @ty Any
23:04:40 <lambdabot> Bool -> Any
23:04:56 <dmj> bss03: Thanks, was curious about Any from GHC.Prim
23:05:16 <dmj> can lambdabot do info?
23:05:20 <dmj> @i Any
23:05:21 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect v @ ? .
23:05:21 <bss03> Ah, didn't realize that was a type.
23:05:28 <bss03> @info Any
23:05:28 <lambdabot> Any
23:05:36 <dmj> bss03: me neither ;)
23:05:42 <bss03> @info String
23:05:42 <lambdabot> String
23:05:51 <dmj> quite telling
23:05:55 <bss03> Yeah, doesn't seem to do much on info.
23:06:29 <CADD> bss03: @ info is for lambdabot commands
23:06:36 <CADD> dmj: ^
23:06:42 <CADD> @info type
23:06:43 <lambdabot> <unknown>.hs: 1: 1:Parse error: type
23:06:49 <CADD> @infomodules
23:06:50 <lambdabot> Unknown command, try @list
23:06:59 <bss03> @instances Any
23:07:00 <lambdabot> Couldn't find class `Any'. Try @instances-importing
23:07:07 <bss03> @instances-importing Any
23:07:08 <lambdabot> Couldn't find class `Any'. Try @instances-importing
23:07:14 <bss03> @instances-importing Eq
23:07:15 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:07:23 <bss03> @instances Eq
23:07:24 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:07:57 <shachaf> You can /msg lambdabot too, by the way.
23:10:10 <bss03> Does lambdabot support DataKinds or ConstraintKinds?
23:13:38 <zvrba> when is it recommended to create a new datatype (data)?
23:14:00 <zvrba> for example, I can represent horizontal/vertical lines like two pairs of coordinates
23:14:21 <zvrba> or, say,  (y,(x1,x2)) (as a tuple or a tagged datatype)
23:19:12 <johnw> i almost always prefer tagged datatypes, but that's me
23:19:33 <johnw> more information in type errors, more differentiation among similar types
23:21:47 <zvrba> johnw: mm. that's what I did. + the information about whether a semgent is vertical or horizontal is encoded in the type (so I don't have to figure it out each time I'm going to use it)
23:23:16 <haasn> If Haskell had an official slogan, what would it be? “Avoid success at all costs”?
23:24:09 <johnw> "Types matter"
23:41:50 <untitaker> Hello, why does this program: http://sprunge.us/bIZU?haskell tell me "Couldn't match expected type `IO b0' with actual type `()'"
23:42:15 <untitaker> for printFizzBuzz
23:43:15 <zvrba> oh. another visitor from ##c :-)
23:43:19 <zvrba> Vorpal: :)
23:43:58 <shiona> untitaker: because you are not returning () in IO
23:44:12 <zvrba> untitaker: the first alternative of printFizzBuzz does not return an IO value
23:44:42 <zvrba> untitaker: as the error says, it returns () instead of IO ()
23:44:51 <Vorpal> zvrba, ? I believe I have had both channels on auto join for years
23:44:53 <untitaker> why should it? I thought ghc could tell that printFizzBuzz is supposed to return () all the time
23:45:08 <zvrba> Vorpal: oh. I have only recently joined haskell though :)
23:45:26 <shachaf> untitaker: If x :: (), there's no meaningful sense in which you can "do I/O" with it.
23:45:32 <shachaf> It's just a useless value.
23:45:34 <zvrba> untitaker: a function must return a value of consistent type. your's doesn't.
23:45:35 <adnap> "A functor F : C -> D is a mapping of the objects of C to the objects of D and the morphisms of C to the morphisms of D..." Can someone explain what C, D "morphisms of C" and "morphisms of D" are in the context of the list functor?
23:45:45 <adnap> (reference: http://vimeo.com/67174266)
23:46:02 <zvrba> untitaker: actually, none of the alternatives return an IO value.
23:46:17 <shachaf> untitaker: I recommend giving everything types.
23:46:36 <shachaf> And also reading an introduction to IO in Haskell.
23:46:41 <shachaf> @google introduction to IO in Haskell
23:46:41 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
23:46:42 <lambdabot> Title: Introduction to IO - HaskellWiki
23:46:43 <shachaf> For example, that one.
23:47:05 <zvrba> on another note. can anybody describe the difference between Batcher's bitonic and merge-exchange sorts?
23:47:19 <zvrba> which of these has more parallelism?
23:49:18 <bakibour> I try to parse a file with Parsec, the elements in there can all start with a comment block. Now i parse all the elements with try (many elementParser) but of course it fails when it switches the element type, because he parses the comment and is stuck in the first parser. Is there any way to get around this problem, while maintaining the order?
23:50:28 <adnap> Oh! C :: a, D :: [a], "morphisms of C" :: (a -> b), "morphisms of D" :: [a] -> [b], where return :: C -> D, fmap :: "morphisms of C" -> morphisms of D"
23:51:30 <supki> s/return/[]/
23:51:47 <adnap> Someone should define a denotational semantics for English which maps to Haskell
23:52:11 <zvrba> hm.
23:53:04 <zvrba> another thing. how is equality of arrows defined in category theory? identity arrow is defined through composition, such that id o f = f and f o id = f. but what does it mean to compare two arrows for equality?
23:53:05 <shachaf> adnap: C = D, the category of Haskell types and functions.
23:53:28 <shachaf> The functor [] has two parts, which are written [] and fmap
23:53:37 <shachaf> [] turns the type "a" into the type "[a]"
23:53:54 <shachaf> fmap turns a function f :: a -> b into a function fmap f :: [a] -> [b]
23:53:55 <zvrba> i mean, if arrows are "functions" in some sense, it's kinda obvious. but Pierce's book also gives example of categories like "2" and "3", where it's not specified what objects and arrows are.
23:54:03 <adnap> shachaf: You're just restating what I said
23:54:15 <shachaf> adnap: No, what you said made no sense.
23:54:42 <shachaf> adnap: I have no idea what "C :: a, D :: [a]" means, for instance.
23:54:56 <shachaf> And return has no place in any of this.
23:55:12 <adnap> C is a category and the type a is a category
23:55:21 <shachaf> The type a is not a category.
23:55:26 <shachaf> There's only one category involved here.
23:55:33 <adnap> Why?
23:55:47 <shachaf> Because that's how the class Functor is defined.
23:56:10 <adnap> Instead of considering the category of Haskell types and functions, why not consider the category of a single Haskell type?
23:56:44 <shachaf> So you're saying, let's come up with some new category, and make a new type class for functors involving that category?
23:56:55 <shachaf> You can do that, but that's not what Functor is. And you'd have to specify what the category is.
23:57:07 <adnap> Functior is a mathematical object
23:57:12 <adnap> *Functor
23:58:04 <adnap> And a Haskell type class
23:58:08 <shachaf> Are you talking about the Haskell class Functor or what?
23:58:31 <adnap> Is Integer a category?
23:58:34 <shachaf> The categorical notion of a functor is more general than the class, which is specifically the class of functors from Hask to Hask.
23:58:49 <shachaf> Not usually.
23:59:16 <adnap> Okay, but what I said makes sense to me
23:59:25 <adnap> Why doesn't it make sense?
23:59:52 <shachaf> It's up to you to show how it makes sense.
