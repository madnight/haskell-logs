00:00:45 <scshunt> is there any particular reason to not enable RankNTypes?
00:04:14 <sopvop> scshunt: There should not be.
00:09:53 <oceanbreeze> Guys teach me some haskell plz
00:13:30 <stevejb> hello, is cabal-uninstall the preferred method for removoing a package which I installed with cabal?
00:14:49 <sopvop> I never heard of cabal-uninstall
00:15:12 <stevejb>  https://github.com/plancalculus/cabal-uninstall
00:16:14 <stevejb> sopvop: well, it seemed to work okay
00:16:55 <sopvop> I think everyone just use sandboxes. cabal-dev, hsenv, HEAD of cabal or made by hand. And just delete the sandbox.
00:17:27 <scshunt> also, is it considered bad form to write code in the list monad?
00:17:35 <scshunt> (using do notation)
00:19:56 <ion> scshunt: Not at all. Why would it?
00:21:32 <scshunt> ion: too imperative! :P
00:22:02 <ion> Eh, Haskell is a great imperative language.
00:22:41 <Walther> @faq Can haskell be a great imperative language?
00:22:41 <kappabot> The answer is: Yes! Haskell can do that.
00:22:45 <Walther> :3
00:23:07 <edkk> haskell do do do
00:25:49 <MrRacoon> and then haskell did
00:26:18 <ion> > do do do do do do do do do do do do do do do do "batman"
00:26:21 <kappabot>   "batman"
00:26:34 <Cale> oceanbreeze: Are you looking for tutorials?
00:26:40 <Cale> @where lyah
00:26:41 <kappabot> http://www.learnyouahaskell.com/
00:28:36 <dmj> @where rwh
00:28:36 <kappabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:28:54 <dmj> @where typeclassopedia
00:28:54 <kappabot> http://www.haskell.org/haskellwiki/Typeclassopedia
00:36:18 <scshunt> ok, so suppose I have some record
00:36:36 <scshunt> call this record type Record
00:37:10 <scshunt> now, suppose I want to extend this by adding some more fields to some subset of all instances of Record. The "correct" way to do this is with BiggerRecord = BiggerRecord { record :: Record, ... }
00:38:03 <scshunt> the relationship here is quite rigid if I am potentially looking at a big hierarchy
00:38:23 <scshunt> but if I have typeclasses instead and extend those by refinement, I can have a much more varied hierarchy because a single type can be an instance of many typeclasses
00:38:30 <scshunt> whereas a single datum can have only one type
00:38:33 <scshunt> if this makes sense?
00:38:48 <scshunt> is there a way to extend this to records, or do I have to have type classes and dummy objects
00:38:50 <koala_man> can you specify a different ~/.cabal directory with cabal command line flags?
00:43:07 <hpaste> haasn pasted “RPN calculator with pretty errors” at http://lpaste.net/91167
00:43:11 <Gracenotes> scshunt: depends on what the thing is
00:43:32 <Gracenotes> and, moreso, how you want to use it
00:45:22 <scshunt> Gracenotes: It is information about a plugin system, so the graph is not necessarily a DAG
00:45:58 <scshunt> and as far as I can tell, any record-based solution will be either extremely terribly hacky or have duplication since records are inherently acyclic where type instances are not
00:46:30 <Gracenotes> well, [mutually] recursive types aren't a problem..
00:48:25 <Gracenotes> it is true that Haskell doesn't have record subtyping... the type system is complicated in other ways
00:51:54 <totos> Hello, anyone managed to install the openglraw package in ubuntu 13.04? I downgraded the ghc to ghc-7.4.1 and ghc-7.4.2 that is depended on, and it still fails.
00:52:03 <Gracenotes> there's weird stuff like HList, which I believe can be used to take 'has-field-x' to a weird extreme
00:52:44 <sopvop> HasField and friends can be neatly solved with lens and ${makeClassy ''Foo}
00:57:20 <Gracenotes> lens is a bit more organic and less likely to be outlawed by the state of California for causing cancer 10 years from now
01:00:53 <Gracenotes> since those three things are related
01:01:54 * Gracenotes should really go to sleep
01:02:58 <augur> Gracenotes: no dont sleep!
01:03:02 <augur> stay awake with us! :D
01:05:49 <hpaste> pharaun pasted “trying to understand the ResumableSource type” at http://lpaste.net/91168
01:06:20 <johnw> hi pharaun
01:06:24 <pharaun> hello ^ i'm trying to understand how i can make the (a) part of my expression a no-op but i can't seem to figure out how
01:06:29 <pharaun> hello johnw :)
01:07:16 <johnw> i've never made a resumable source that way
01:07:25 <pharaun> I am a bit stuck with ResumableSource since that is what conduit-http return and i'm trying to do a caching shim
01:07:52 <pharaun> johnw: how would you normally create a resumable source? i haven't had much luck there :)
01:08:18 <johnw> I usually make them using $$++ Data.Conduit.List.take 0 :)
01:08:27 <pharaun> oh i can do that?
01:08:29 <johnw> sure
01:08:30 <pharaun> sweet!
01:08:42 <pharaun> let me try that out it would be much better than this hack
01:11:46 <pharaun> hmm johnw the type does not seem to match
01:11:54 <johnw> show me?
01:11:58 <pharaun> yeah a sec
01:12:31 <hpaste> pharaun pasted “using $$++ take 0” at http://lpaste.net/91170
01:13:01 <pharaun> oh *facepalm* its
01:13:09 <pharaun>  m (ResumableSource m a, b)
01:13:17 <ffwacom> u mena haskell??
01:13:20 <pharaun> yeah i need to extract the ResumableSource part out of that tuple :)
01:16:06 <pharaun> johnw: sorry, i goofed on that second part, it was a tuple, i should go to bed at this rate! anyway thanks for kicking my head into gear with the $$++ thing
01:16:25 <johnw> sure thing!
01:16:29 <johnw> resumable sources are fun :)
01:16:44 <pharaun> my first time dealing with them so been a bit of a learning trip :)
01:17:06 <pharaun> i'm surprised that i've gotten this far with just following the types :)
01:43:01 <haasn> Is there something like ‘beside’ but for Either instead of (,)?
01:43:09 <haasn> in the context of lens
01:48:46 <mstksg> hey, what happened to lambdabot?
01:50:14 <startling> kappabot usurped her.
01:54:57 <mstksg> shame
01:55:23 <elliott> was there another netsplit?
01:56:00 <johnw> when I see omegabot, I will worry
01:56:11 <elliott> maybe I should put "lambdabot" on highlight
01:56:14 <startling> > "uh-oh"
01:56:17 <kappabot>   "uh-oh"
01:56:25 <lambdabot>   "uh-oh"
01:56:42 <mgsloan> > putStrLn "> \"uh-oh\""
01:56:44 <mstksg> he returns :)
01:56:45 <kappabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
01:56:45 <kappabot>    arising from a use of ...
01:56:51 <lambdabot>   <IO ()>
01:56:59 <mgsloan> > "> \"uh-oh\""
01:57:02 <kappabot>   "> \"uh-oh\""
01:57:05 <lambdabot>   "> \"uh-oh\""
01:57:10 <mgsloan> Hrmph of course
02:01:11 <elliott> kappabot: @part #haskell
02:03:31 <ion> @type let either_ :: Functor f => ((a -> f b) -> s -> f t) -> ((a -> f b) -> s' -> f t') -> (a -> f b) -> Either s s' -> f (Either t t'); either_ l r f = either (fmap Left . l f) (fmap Right . r f) in either_
02:03:32 <lambdabot> Functor f => ((a -> f b) -> s -> f t) -> ((a -> f b) -> s' -> f t') -> (a -> f b) -> Either s s' -> f (Either t t')
02:03:46 <danilo2> Hi! What is the best method to call Haskell from C / C++? I'm writing a batch application (terminal based system) which should communicate with GHCI-like Haskell program. The Haskell program has got some data structures, which C++ code should operate on. :)
02:03:47 <ion> haasn: You figure out if it violates the laws, i can't be bothered. :-P
02:04:17 <startling> man, I almost had a botflood set up. :(
02:04:29 <ion> haasn: That's :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
02:04:40 <elliott> ion: I think we have that in lens
02:05:14 <haasn> ion: oh, neat; I was trying ‘l . f’
02:05:15 <ion> We should have a flat list of all the combinators in lens, with links to the haddocks.
02:05:23 <haasn> elliott: any idea where?
02:05:58 <Lethalman> danilo2, I did it and it's very easy
02:06:06 <ion> lethalman: Like monoids
02:06:16 <Lethalman> danilo2, just search for call haskell from c
02:06:23 <elliott> haasn: nope
02:06:34 <elliott> ion: that exists sorta
02:06:36 <elliott> use the index
02:06:37 <Lethalman> danilo2, you can call haskell functions like you would call C functions, then you can serialize haskell data types
02:07:02 <Lethalman> danilo2, you can run this example straight on http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
02:07:47 <ion> haasn: Control.Lens.Lens.choosing
02:08:07 <haasn> ion: great, thanks
02:09:01 <danilo2> Lethalman - I've seen that article - could you tell me more about this serialization please? How can I "deserialize" and "serialize back" these strctures in C++ code?
02:14:15 <haasn> ion: now I don't suppose there's a name for ‘choosing id’ ;-)
02:15:15 <ion> I think there was, look at Control.Lens.Lens
02:15:29 <startling> :t choosing
02:15:31 <lambdabot> Not in scope: `choosing'
02:15:36 <haasn> I see one for choosing id id but I need to compose a lens onto the right side of an Either only
02:15:40 <startling> :t Control.Lens.choosing
02:15:41 <lambdabot> Functor f => Control.Lens.Type.LensLike f s t a b -> Control.Lens.Type.LensLike f s' t' a b -> Control.Lens.Type.LensLike f (Either s s') (Either t t') a b
02:15:48 <ion> haasn: oh, ok
02:15:57 <startling> :t Control.Lens.choosing id
02:15:57 <lambdabot> Functor f => Control.Lens.Type.LensLike f s' t' s t -> Control.Lens.Type.LensLike f (Either s s') (Either t t') s t
02:16:05 <startling> oh, I see.
02:19:56 <danilo2> Hi Everyone! :D I was asking about communication between C++ and Haskell and couple minutes ago Lethalman told me that I can use http://www.haskell.org/haskellwiki/Calling_Haskell_from_C and serialize haskell data structures - but It seems Lethalman is not here right now - could somebody explain how to serialize and deserialize haskell structures from C++ ?
02:20:06 <danilo2> My oryginal question was: What is the best method to call Haskell from C / C++? I'm writing a batch application (terminal based system) which should communicate with GHCI-like Haskell program. The Haskell program has got some data structures, which C++ code should operate on. :)
02:20:22 <haasn> Hmm, there's no neat alternative to <>~ when you're providing the right argument
02:20:22 <haasn> I have to go through the ugly l %~ (<> x)
02:21:26 <supki> you mean left
02:21:37 <elliott> <>~ appends
02:21:48 <elliott> danilo2: look into the Storable typeclasses.
02:21:56 <elliott> danilo2: also hsc2hs and c2hs
02:22:45 <johnw> and c2hsc
02:23:32 <merijn> johnw: Did I ever mention I <3 you for writing c2hsc?
02:23:43 <johnw> yes!  thank you :):)
02:23:59 <haasn> elliott: oh?
02:24:11 <johnw> it's followers are few but loyal :)
02:24:11 <elliott> haasn: well x += y is x = x + y
02:24:17 <elliott> so x <>= y is x = x <> y
02:24:23 <WBit> how hard is it to create a 2D Pong game in Haskell, for someone just coming from C++?
02:24:27 <elliott> unless edwardk made it dumb and the other way around, but I believe in him.
02:24:28 * johnw used shake in anger for the first time today
02:24:41 <haasn> elliott: right, of course; it makes sense now
02:24:43 <johnw> WBit: knowing no Haskell?  hard
02:24:48 <mauke> WBit: I'd start with hello world and cat
02:25:04 <WBit> Well, I started a week ago...
02:25:57 <WBit> I love the language, where should I place my next steps?
02:26:32 <danilo2> elliott: As I understand these tools help me call C/C++ from Haskell - I need to create binding in the other direction. Am I wrong?
02:26:37 <johnw> you are reading Learn You a Haskell now?
02:27:01 <WBit> Inread Haskell for C programmers
02:27:11 <johnw> @where lyah
02:27:11 <lambdabot> http://www.learnyouahaskell.com/
02:27:14 <WBit> *I read
02:27:16 <johnw> I'd head there next
02:27:22 <johnw> it's fun
02:27:44 <elliott> danilo2: well, they can help you handle the data interchange stuff.
02:27:50 <elliott> it was just re: serialisation things
02:27:50 <Lethalman> danilo2, look for StablePtr and Storage
02:28:06 <WBit> How long will it take me to get to the level.. opengl and stuff?
02:28:27 <merijn> danilo2: All these tools are bidirectional
02:28:29 <hpaste> haasn annotated “clac2” with “clac2 (annotation)” at http://lpaste.net/91171#a91172
02:28:34 <haasn> and with the power of lenses, my clac2 is now complete
02:29:35 <merijn> WBit: It kinda depends on your experience. If you already know like C and opengl, that shouldn't be very tricky. If you don't, then you have to learn both opengl and the more advanced haskell tricks at the same time, which can be tricky
02:29:53 <merijn> WBit: As for Pong, I believe lens has a pong example?
02:29:54 <haasn> except it's bugged!
02:29:56 <haasn> gah
02:30:18 <merijn> WBit: https://github.com/ekmett/lens/blob/master/examples/Pong.hs
02:30:42 <danilo2> elliott, Lethalman, merijn: I Understand these tools (hsc2hs, c2hs AND c2hsc) are helping in solving the same problem - which one should I use in this case? (which one is most powerfull)? Or maybe I'm wrong with this sentence?
02:31:56 <elhuman> Hi. Is there a reason that there is no singleton function for lists?
02:32:04 <elhuman> Like Data.List.singleton x = [x]
02:32:25 <elliott> elhuman: "pure" or "return"
02:32:34 <elliott> or even (:[]) but that's ugly
02:33:05 <johnw> danilo2: c2hsc is meant to "bootstrap" you by creating a whole bunch of .hsc files that you don't have to write by hand.  It helps when you have an existing library with lots of headers
02:33:11 <WBit> merijn: thank you, looks good! I'll spend the next two weeks staring at ot though :)
02:33:20 <johnw> I think c2hs is better if you are writing the C library from scratch along with Haskell library
02:33:27 <elhuman> elliott: thanks, (:[]) is what I am looking for. Does not seem ugly to me :-)
02:33:35 <johnw> hsc2hs compiles the .hsc files that c2hsc produces, for example
02:34:24 <danilo2> johnw: But I dont want to use C library from Haskell at all - I want the C program (or library) ONLY to call Haskell library
02:34:36 <johnw> oh, you want to go C -> Haskell only?
02:34:51 <danilo2> johnw: yes
02:35:02 <johnw> hmm
02:35:23 <danilo2> johnw: and return some results from Haskell bac to C of course
02:35:29 <danilo2> *back
02:36:05 <johnw> i've never tried doing that yet
02:36:45 <johnw> as we speak I'm binding some C++ gSOAP code into Haskell, but that's Haskell originating the communication
02:37:06 <danilo2> I'm trying to do the opposite thing
02:37:10 <johnw> yeah
02:40:50 <merijn> danilo2: There's not much difference, between calling haskell from C and vice versa
02:41:01 <remdezx> Hi! I tried to use c2hsc but I got an error "c2hsc: Failed to run cpp: ExitFailure 1" I run it with command "c2hsc  --prefix=MyModule --gcc=/bin/gcc api.cpp"
02:41:15 <merijn> danilo2: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
02:41:41 <merijn> danilo2: Note that all uses of "Safe" in that C code should be replaced by YourModule
02:42:25 <johnw> remdezx: does --verbose add any info?
02:42:55 <remdezx> merijn: Have you any good examples of how to do such calls?
02:43:01 <remdezx> johnw: no
02:43:10 <remdezx> "gcc: error: : Nie ma takiego pliku ani katalogu c2hsc: Failed to run cpp: ExitFailure 1"
02:43:20 <danilo2> merijn: do you have any examples of  (http://www.haskell.org/haskellwiki/Calling_Haskell_from_C) when haskell returns a structure?
02:43:21 <merijn> remdezx: The wiki entry I just linked is a complete program to do that, haskell + C
02:43:36 <johnw> is there a cpp on your PATH?
02:43:47 <merijn> danilo2: That requires a Storable instance and custom data structure for the struct
02:43:50 <johnw> c2hsc has to run the C preprocessor
02:44:51 <merijn> danilo2: I have some code that uses c2hsc to produce a Storable instance and calling C from haskell using that, that plus the example of calling haskell from C should be enough
02:44:53 <remdezx> johnw: yes, it is in PATH
02:44:54 <merijn> danilo2: https://github.com/merijn/SNet2.0/tree/master/SNet/Interfaces
02:44:54 <danilo2> merijn: I'm trying to do it - anyway = if somebody has a working example with this Storable instance (which is read by C++ code) I would love to see it :)
02:45:38 <danilo2> merijn: Thnak you :) looking at it right now
02:45:52 <merijn> danilo2: basically my code gets a Storable struct from C, if you just change the import to export it should work the other way around :p
02:46:12 <johnw> remdezx: also, it's meant to be run on a header file, if that helps
02:46:31 <johnw> and you may need some --cppopts, to teach it where to find other headers, etc.
02:47:24 <danilo2> merijn: sorry for my silly question, but I dont see any "Storable" in your code
02:48:44 <remdezx> johnw: I was running on cpp, but when I changed to header file I still get an error
02:49:44 <merijn> danilo2: no, I'm running c2hsc to generate it from the C header. You can clone the thing and run "cabal build" to see the code that produces
02:50:18 <johnw> remdezx: what happens if you run "cpp <FILE>" yourself?
02:50:20 <danilo2> merijn: Thnak you! Checking it right now :)
02:50:31 <merijn> There's no forkIOWithUnmaskFinally, I guess?
02:50:53 <johnw> merijn: what would you like that to do?
02:50:58 <remdezx> johnw: it prints it
02:51:18 <merijn> johnw: combine forkIOWithUnmask and forkFinally? :p
02:51:25 <johnw> remdezx: try dropping your --gcc argument, since gcc is the default?
02:51:45 <johnw> merijn: ah, neat
02:51:50 * johnw is a big fan of lifted-base
02:51:58 <remdezx> johnw: I tried it, still the same error
02:52:31 <johnw> remdezx: c2hsc is just calling runPreprocessor, from the language-c library, so I'm not sure why that would be choking for you.  What OS are you on?
02:52:49 <remdezx> johnw: fedora 18
02:53:20 <johnw> try: strace c2hsc  --prefix=MyModule api.cpp
02:53:26 <johnw> see what cpp command it's actually invoking
03:01:50 <merijn> hmm, if I nest async exception masks, do I only need to call the outer restore to restore exceptions?
03:02:04 <johnw> good question!
03:02:13 <johnw> pretty easy to test that one
03:02:19 <remdezx> johnw: thats the output: http://wklej.org/id/1093337/
03:04:51 <johnw> oh, did I mention that c2hsc doesn't work with C++?
03:05:02 <merijn> The FFI doesn't work with C++
03:05:37 <scshunt> hey, is anyone around familiar with TH? Like, really familiar? I'm trying to pull out all the type signatures from a typeclass and declare new functions with the same signatures, but I can't seem to pull out the type variables correctly.
03:05:38 <johnw> you're also using ccache; I wonder if that has an effect
03:06:27 <merijn> uhoh
03:06:31 <merijn> "ghc: ioManagerWakeup: write: Bad file descriptor"
03:06:40 <merijn> ghci doesn't like my test code it seems...
03:07:37 <merijn> well...
03:07:41 <merijn> that bricked ghci pretty hard
03:09:38 <merijn> johnw: Not quite as easy to test as you'd think, apparently
03:09:38 <johnw> :)
03:09:42 <merijn> Does this hard hang your ghci?
03:09:42 <merijn> tid <- mask $ \restore -> mask $ \restore2 -> do { forkIO (threadDelay maxBound `catch` (\(_ :: SomeException) -> putStrLn "w00t!")) }
03:10:12 <johnw> <interactive>: kevent: invalid argument (Invalid argument)
03:10:25 <merijn> I have to kill -9 to get rid of ghci after that
03:10:39 <merijn> Not sure what's wrong, though. seems like it should be valid code
03:11:39 <merijn> if I remove the do it still produces the kevent error, but no hang
03:12:33 <merijn> And I guess I need uninterruptibleMask, since threadDelay is interruptible anyway
03:14:05 <remdezx> johnw: it doesn't run with C too ;(
03:14:36 <merijn> ok, unmasking the outer one works, unmasking the inner crashes, oddly enough
03:14:40 <johnw> remdezx: i'm sorry, remdezx, it's 5:14 AM today and I've spent almost 10 hours battling the SOAP standard.  I'm beat.  Perhaps I can take this up with you another day?
03:15:11 <merijn> It seems odd that the io manager crashes on this, though...maybe it's just ghci
03:15:17 <remdezx> johnw: no problem
03:15:42 <remdezx> johnw: thank you for your help and have a nice day ;)
03:15:55 <johnw> you too, I'm sorry c2hsc was such a bummer this morning
03:16:03 <int-e> merijn: which ghc version is that? ghc 7.6.3 handles this fine, including a followup killThread tid.
03:16:18 <int-e> (linux, x86_64)
03:17:39 <merijn> 7.63 OSX
03:18:43 <hpaste> merijn pasted “hard hang on 7.6.3” at http://lpaste.net/91173
03:18:51 <merijn> That hangs hard on my system
03:19:55 <johnw> John: "How's it hanging, Merijn?"  Merijn: "Hard."  Hmm.
03:20:24 <merijn> in fact
03:20:34 <merijn> Compiling it and running the compiled code exits with: "test: select: Invalid argument"
03:21:04 <johnw> night all
03:21:48 <mauke>  EINVAL nfds is negative or the value contained within timeout is invalid.
03:23:19 <merijn> Wait what...
03:23:23 <merijn> "ghc: unrecognised flags: --with-rtsopts=-threaded"
03:23:42 <merijn> is it -threaded then?
03:23:47 <merijn> Not a runtime option?
03:24:03 <merijn> ah, apparently yes
03:24:14 <int-e> yes, it's a link time option.
03:24:18 <merijn> Weirder and weirder
03:24:38 <int-e> ghci is using the threaded RTS though
03:24:41 <merijn> test: kevent: invalid argument (Invalid argument)
03:24:41 <merijn> test: <stdin>: hGetLine: invalid argument (Bad file descriptor)
03:24:41 <merijn> test: ioManagerDie: write: Bad file descriptor
03:25:05 <mauke> report all the bugs
03:26:39 <merijn> I can't imagine this is a bug...how would any threaded haskell code ever have worked if this code is broken..
03:27:03 <int-e> does it work when compiled?
03:27:04 <mauke> schroedinbug
03:27:47 <int-e> (where by "work" I mean that it hands indefinitely, but can be interrupted by ^C, both before and after the first getLine)
03:27:57 <int-e> *hangs
03:28:02 <merijn> int-e: I'm compiling
03:28:14 <merijn> It crashes straight away
03:28:30 <merijn> Even the simplified case
03:28:43 <int-e> fun.
03:29:19 <hpaste> merijn pasted “crash on 7.6.3” at http://lpaste.net/91174
03:29:33 <merijn> Can someone try that and see if they have different results?
03:30:22 <merijn> Without -threaded it crashes on "select: Invalid argument"
03:30:36 <merijn> With -threaded it crashes with the three errrors from earlier
03:30:37 <hpaste> mauke annotated “crash on 7.6.3” with “crash on 7.6.3 (annotation)” at http://lpaste.net/91174#a91175
03:30:52 <mauke> now with less language extensions
03:30:56 <scshunt> is there a better idiom than "liftM concat $ sequence foo"?
03:31:11 <merijn> :t concatM
03:31:11 <mauke> concat <$> sequence foo
03:31:11 <lambdabot>     Not in scope: `concatM'
03:31:12 <lambdabot>     Perhaps you meant one of these:
03:31:12 <lambdabot>       `concat' (imported from Data.List),
03:31:12 <hpc> it works for me with runghc
03:31:20 <hpc> 7.4.1
03:31:24 <merijn> hmm
03:31:51 <hpc> and it works compiled
03:31:58 <int-e> merijn: still works on Linux, compiled with vanilla and threaded RTSs, and with ghci. It could be your ghc build or a macos thing.
03:32:22 <merijn> int-e: I'm just using the OSX binary install
03:32:40 <mauke> merijn: works on 7.6.2, x86 linux
03:32:53 <mauke> ghc {-O2,} {-threaded,}
03:33:20 <merijn> Crashes in 7.7 I build myself too
03:34:28 <int-e> works fin with a 2 week old 7.7, for me.
03:34:50 <merijn> Narrowing down on the culprit
03:35:08 <merijn> looks like threadDelay is broken
03:36:21 <hpc> pppsh, nobody needs threadDelay ;)
03:36:55 <merijn> I reduced the minimal case for crash to "main = threadDelay maxBound"
03:37:25 <merijn> How the hell can threadDelay be broken on OSX without anyone noticing?!
03:37:26 <hpc> can you reduce it to something like main = threadDelay (whatever 5 seconds is)
03:38:16 <mauke> merijn: maybe maxBound is broken
03:39:02 <merijn> mauke: I suspect a limit that's not being checked
03:39:24 <merijn> Yeah, it seems the combination of "threadDelay maxBound" is dying
03:40:13 <hpc> now write a patch!
03:43:50 <merijn> Selfish GHC bastards, the functions I proposed alredy exist but aren't exported!
03:44:18 <hpc> haha
03:44:22 <merijn> threadWaitReadSTM
03:44:27 <merijn> I wants it :(
03:44:33 <hpc> whatis?
03:44:52 <merijn> "Fd -> IO (STM (), IO ())"
03:45:08 <merijn> i.e. the "STM ()" is retry until Fd is readable
03:45:19 <hpc> snazzy
03:45:28 <elliott> what is the IO ()
03:45:33 <merijn> It would let write a blocking poll between files and TChan's
03:45:34 <hpc> close, i take it
03:45:52 <merijn> No, it unregisters interest in the Fd
03:45:56 <hpc> ah, or that
03:47:54 <scshunt> argh
03:48:31 <scshunt> does anyone know a function which automatically makes functions to wrap classes when using existential types?
03:48:31 <scshunt> would be *really* handy right about now
03:49:53 <merijn> I'm betting GHC isn't checking for overflow on the clock
03:50:12 <supki> scshunt: can you show an example?
03:51:14 <merijn> In the meantime, time for lunch
03:51:45 <merijn> Wait!
03:51:55 <merijn> You guys that tested my code
03:52:01 <merijn> 32bit GHC or 64 bit ghc?
03:53:31 <int-e> merijn: 64bit so far
03:54:11 <scshunt> supki: I have a class Foo a where { bar :: a -> Int }
03:54:27 <merijn> hmm
03:54:42 <scshunt> I have generated a data Baz = forall a. (Foo a) => Baz a
03:55:06 <int-e> merijn: but no trouble with 7.6.1 on x86 either. (the computer is slow so I don't build new ghcs very often)
03:55:14 <scshunt> I would like to create the function barbaz :: forall a. (Foo a) => a -> Int ; barbaz (Baz f) = bar f
03:55:30 <scshunt> supki: doing the correct rewriting of type signatures seems laborious
03:55:36 <scshunt> and I'm wondering if someone has done this form e
03:55:38 <scshunt> *for me
03:56:30 <scshunt> if I don't want to specify an explicit type signature I can do it easily also
03:57:01 <merijn> int-e: OSX has a separate implementation of the code by GHC to obtain a timer
03:57:19 <merijn> int-e: So if my suspicions are right it shouldn't be reproducible on non-OSX anyway
03:57:40 <supki> scshunt: the type of barbaz doesn't look right
03:58:01 <scshunt> supki: err, you're right
03:58:11 <scshunt> forall a. (Foo a) => Baz a -> Int
03:58:33 <supki> that doesn't look right either :)
03:58:37 <scshunt> why not?
03:58:48 <supki> Baz does not have type parameters
03:58:56 <scshunt> oh yeah
03:58:56 <supki> barbaz :: Baz -> Int
03:58:59 <scshunt> right
03:59:17 <supki> you get Foo constraint on a by pattern matching
03:59:18 <scshunt> but if there's some more complex function in Foo, I'll have to dive through and replace all instances of the type variable with Baz
03:59:21 <scshunt> seems bad
03:59:24 <int-e> merijn: yes, I didn't expect the 32 bit code to fail on linux, but it can't hurt to have verified that :)
03:59:42 <scshunt> hence: is there code somewhere that helps with this?
04:19:57 <merijn> ok, it doesn't seem to be an overflow
04:20:26 <merijn> Or at least, the OSX clock gets converted to seconds (as double) and the threadDelay is added to it in Double form
04:24:05 <elliott> eww, it uses double?
04:26:07 <merijn> elliott: Yeah
04:26:21 <merijn> getMonotonicTime :: IO Double
04:27:19 <hpc> that's one way of putting off the 2038 bug...
04:28:23 <elliott> getMoronicTime
04:28:28 <Quadrescence> :)
04:28:50 <Quadrescence> elliott, why do you suppose Double is an issue?
04:30:35 <Quadrescence> I can see only two other reasonable solutions: using a rational number, or using some abstract unit, and having another constant: timeUnitsPerSecond.
04:32:27 <elliott> threadDelay doesn't take a Double anyway.
04:35:49 <tulcod> "cabal: The following packages are likely to be broken by the reinstalls:". okay, sure, can't cabal rebuild them for me?
04:36:13 <dcoutts> tulcod: sure, just ask it to do so
04:36:22 <tulcod> how?
04:36:29 <dcoutts> tulcod: use --dry-run and add those to the list of targets
04:36:36 <tulcod> ugh :-/
04:37:53 <tulcod> dcoutts: okay, i added them to the list of targets, but they're still showing up
04:38:24 <dcoutts> older versions thereof?
04:38:42 <dcoutts> if you're happy to break those ones, you can (or unregister them)
04:39:11 <tulcod> dcoutts: ah yes, older versions :)
04:41:37 <tulcod> dcoutts: fixed it by giving targets in a different order
04:41:43 <tulcod> (which is weird)
04:41:54 <dcoutts> mm, that is a bit odd
04:42:12 <dcoutts> tulcod: is the list of packages (versions) it's going to install different?
04:42:19 <dcoutts> ie in the --dry-run output
04:42:51 <tulcod> dcoutts: sorry, it's already installing
04:44:08 <tulcod> dcoutts: the only new thing was the first package, threepenny-gui, which i couldn't find, so i had to cabal update. after moving the two packages that still showed up as "going to be broken" to the front, it started installing without error
04:44:34 <dcoutts> tulcod: oh doing a cabal update in between could easily change the results
04:45:14 <dcoutts> tulcod: changing the target order can certainly change the solution the solver finds
04:45:14 <tulcod> dcoutts: no, i first did the update, then tried cabal install threepenny-gui, got a bunch of troublesome packages, added those to the list, two remained, moved them to the front, it statred installing
04:45:47 <dcoutts> there can be many solutions, and the target order can affect the search order
04:46:25 <tulcod> dcoutts: well but clearly one solution is better than the other
04:51:21 <mr-> tulcod: It is not always possible to look at all solutions. The search tree can be quite big
04:52:14 <tulcod> okay, but this kind of user intervention should not be necessary
04:56:25 <mr-> I agree.. it is annoying that order matters.. but it does
04:57:32 * hackagebot graph-visit 0.1.0.2 - Graph walk abstraction  http://hackage.haskell.org/package/graph-visit-0.1.0.2 (AtzeDijkstra)
04:57:36 <tulcod> so that's a bug then?
05:01:46 <mr-> I don't think so. It really is just an issue of limited time
05:02:32 * hackagebot macosx-make-standalone 0.1.0.1 - Make a macosx app standalone deployable  http://hackage.haskell.org/package/macosx-make-standalone-0.1.0.1 (AtzeDijkstra)
05:03:03 <tulcod> mr-: i never had this with my distro's package managers
05:03:51 <merijn> ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
05:03:58 <merijn> I found the error
05:04:03 <merijn> Shame!
05:05:57 <supki> tulcod: distro package manager solves different problem
05:05:58 <merijn> Someone is converting a Double to an Int by use of ceil and then converting Int to CInt without any bounds checking
05:12:22 <merijn> int-e: Care to check something for me?
05:12:56 <int-e> merijn: maybe
05:12:59 <merijn> int-e: I'd be interested in maxBound of Int/CInt  on your system
05:13:45 <int-e> (maxBound,maxBound) :: (Int,CInt) => (9223372036854775807,2147483647)
05:14:04 <merijn> ok, so that's the same
05:14:23 <merijn> Basically, the only reason why everyone's runtime system isn't crashing all the time is the fact that linux is really lax
05:14:52 <HugoDaniel> ei merijn how is zmtp3 going ?
05:14:55 <merijn> There is a huge coercion flaw in the RTS and it's just sheer coincidence that linux treats any negative value as an infinite timeout
05:15:07 <merijn> Bug filing time!
05:15:28 <int-e> [pid  8041] poll([{fd=7, events=POLLIN}, {fd=9, events=POLLIN}], 2, -1511828488 <unfinished ...>
05:15:34 <merijn> int-e: Yup, same here
05:15:36 <int-e> merijn: yeah looks like it
05:15:52 <merijn> int-e: But OSX is much stricter than linux and only accepts -1 for infinite timeouts
05:16:06 * elliott wishes we were exposed a way to do infinite timeouts
05:16:08 <int-e> (the other reason is that threadDelay maxBound calls should be pretty rare)
05:16:50 <merijn> int-e: Really? I see them quite frequently as example of "block indefinitely until X happens"
05:17:16 <supki> why not use MVar then?
05:17:30 <Todor> hi everybody
05:17:59 <int-e> merijn: But X should involve communication, so yes, I would expect an MVar to be involved.
05:18:34 <int-e> ymmv
05:19:05 <merijn> int-e: or just an async exception
05:22:27 <Todor> I'm new to haskell and I'd like to solve this problem:
05:22:27 <Todor> I have a list [(A, 1), (A, 2), (A,3), (B,1), (B,3)] and i'd like to change it into [("A", (1,2,3)), ("B",(1,3))]. Can somebody direct me how to solve it?
05:23:17 <Pranz> Todor, map (show . second)
05:23:29 <Pranz> Todor, first* instead of second
05:23:37 <mauke> Todor: are all common keys adjacent?
05:23:39 <Pranz> first and second processes a function on only one part of the tuple
05:24:03 <Pranz> and show turns a data structure into a string
05:24:28 <Todor> eh. slowly please :).
05:24:47 <Todor> the first list has strings too. it was my typo
05:24:51 <nilg```> is there some nothing "instruction" in Haskell? Something that has the IO monad type but does nothing?
05:24:54 <Pranz> Hmm, I didn't read your problem correctly
05:24:57 <Pranz> ah
05:25:09 <Pranz> then
05:25:14 <mauke> Todor: so are they adjacent?
05:25:15 <Todor> they are sorted by first element
05:25:19 <mauke> ok
05:25:37 <Pranz> Todor, do the (1,2,3) have to be a n-tuple?
05:25:46 <Todor> i'd like them to be
05:25:46 <Pranz> or can it be [1,2,3] instead?
05:25:49 <Pranz> ah
05:25:50 <mauke> Todor: they can't be
05:25:55 <mauke> that would be a type error
05:26:00 <Todor> ah, i don't mind a list
05:26:02 <Pranz> Todor, lists are homogenous
05:26:05 <Todor> aha. :)
05:26:06 <mauke> > groupBy (comparing fst) [("A", 1), ("A", 2), ("A", 3), ("B", 1), ("B", 3)]
05:26:07 <lambdabot>   Couldn't match type `GHC.Types.Ordering' with `GHC.Types.Bool'
05:26:07 <lambdabot>  Expected ty...
05:26:20 <mauke> > groupBy ((==) `on` fst) [("A", 1), ("A", 2), ("A", 3), ("B", 1), ("B", 3)]
05:26:21 <lambdabot>   [[("A",1),("A",2),("A",3)],[("B",1),("B",3)]]
05:27:25 <mauke> > (map (fst . head &&& map snd) . groupBy ((==) `on` fst)) [("A", 1), ("A", 2), ("A", 3), ("B", 1), ("B", 3)]
05:27:26 <lambdabot>   [("A",[1,2,3]),("B",[1,3])]
05:28:04 <Todor> hmm... i'd say it's looks easy, when you know the language :) thank you guys!
05:28:39 <Pranz> It's possible to do a more readable variant
05:28:52 <Todor> is it?
05:29:00 <mauke> do you have a constructive proof?
05:29:13 <nilg```> got the answer to the nothing IO: return()
05:29:46 <Pranz> mauke, you can always make something more readable, I'm not complaining on your solution
05:30:14 <Pranz> mauke, just saying that to expect a oneliner of such a solution to be easy to read isn't something you can expect
05:30:22 <Pranz> it was directed to Todor
05:30:33 <mauke> no, I'm interested in other solutions to the problem
05:31:53 <Todor> may I ask another question? What I have to include to get `on`?
05:32:11 <mauke> @hoogle on
05:32:11 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:32:12 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
05:32:12 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
05:32:32 <Todor> wow :) you have nice bots here :)
05:32:55 <Todor> thank you.
05:33:11 <int-e> @botsnack
05:33:11 <lambdabot> :)
05:33:11 <klugez> Todor: Hoogle is also a website you can use: http://www.haskell.org/hoogle/
05:33:22 <Todor> @botsnack
05:33:23 <lambdabot> :)
05:33:57 <Lethalman> if I want to do if x > 10 then foo else if x == 10 then bar else baz
05:33:57 <Lethalman> is there anything I can use instead of if/then/else ?
05:34:00 <alexander__b> Lethalman: ... case?
05:34:07 <alexander__b> pattern matching?
05:34:10 <Lethalman> alexander__b, but then I need guards
05:34:11 <alexander__b> yes?
05:34:18 <mauke> case compare x 10 of GT -> foo; EQ -> bar; LT -> baz
05:34:29 <Lethalman> mauke, that's nicer thanks
05:35:03 <k00mi> there is also MultiWayIf
05:35:04 <Lethalman> but is there something like case x of f x -> .. ; g x -> .....;
05:35:05 <Lethalman> ?
05:35:08 <alexander__b> be generous with the '\n's.
05:35:12 <vlaeter> Hi!  I think this is the right room for this, as cabal is tumbleweed. Anyway; I came quite far getting Phooey to work on my Mac, well actually, I came as far as having a working wx version (by mostly manually cabal unpack and then finding on internet what things to change to get it working) But now i'm stuck at Reactive with this; http://pastebin.com/42zSdvat . If I would be able to actually understand what this is saying, I might be able to fix it, but I 
05:35:12 <vlaeter> no clue what this error means… Can someone help?
05:35:12 <Lethalman> that is, without using guards
05:35:18 <mauke> The paste 42zSdvat has been copied to http://lpaste.net/91176
05:35:51 <Lethalman> aaah yes
05:35:59 <Lethalman> k00mi, awesome that's what I was looking for :-)
05:36:55 <supki> vlaeter: that looks like you're trying to install something really ancient
05:37:31 <Lethalman> argh MultiWayIf not supported by emacs :-(
05:38:13 <vlaeter> supki: I installed the latest Haskell platform and then I use cabal to install things. Not sure how it 'becomes' really ancient like that?
05:39:27 <mauke> merijn: do you have a bug id?
05:39:46 <vlaeter> supki: i didn't checkout anything myself, I used only cabal. It was pulling teeth every step of the way anyway, but at least most is working now. I just kept running into stuff which was very recently fixed and i had to manually update things to get it to work, but they all are the versions coming from the newly installed haskell/cabal on a fresh mac book
05:41:12 <merijn> mauke: for my issue? No, I'm rebuilding ghc to see if my patch works before creating a ticket
05:41:14 <vlaeter> supki: this seems to be the latest http://hackage.haskell.org/package/reactive right? it's trying to install that version when it gives those errors
05:41:16 <Pranz> what is the haskell paste website?
05:41:23 <merijn> mauke: Because I think I solved it already
05:41:25 <int-e> @where paste
05:41:25 <lambdabot> http://lpaste.net/new/haskell
05:41:27 <int-e> hmm
05:41:32 <int-e> @where hpaste
05:41:32 <lambdabot> http://lpaste.net/new/haskell
05:41:40 <merijn> mauke: Patching base means rebuilding a lot of library junk, though, so it takes awhile
05:41:51 <mauke> merijn: oh, nice
05:42:00 <hpaste> Pranz pasted “Group keys and values” at http://lpaste.net/91177
05:42:14 <Pranz> mauke, Todor, there is a solution
05:42:25 <supki> vlaeter: yes, it's from 2010. You probably can install this you really really want but it's not going to be pleasant
05:42:44 <mauke> Pranz: that could be improved by a list comprehension
05:42:55 <supki> vlaeter: the main problem is dependency on (obsolete) category-extras, I would guess
05:43:01 <Pranz> mauke, improved as faster?
05:43:11 <mauke> valuesFor k = [ y | (x, y) <- lst, x == k ]
05:43:14 <mauke> more readable
05:43:27 <merijn> mauke: If I keep up this rate of increase in patch size, my next GHC patch will be an entire module
05:43:34 <Pranz> mauke, ah, indeed
05:43:44 <supki> vlaeter: which in turn depends on invariant which wants ancient version of contravariant package
05:43:47 <merijn> (last patch was 2 characters, this one is about 10 lines)
05:44:06 <vlaeter> supki: ok, so basically, just not use Phooey? Any other high level gui lib which does work? Peferably on wxwidgets as I worked a lot with the C++ version of wxwindows/wxwidgets
05:44:43 <nilg```> Why that program is badly types?
05:44:46 <nilg```> parseLines l = do
05:44:46 <nilg```>   line <- getLine
05:44:46 <nilg```>   parseLines l
05:44:46 <nilg```>  
05:44:53 <vlaeter> supki: (I know the list online, but it doesn't really say which one actually work or not)
05:45:01 <nilg```> (sorry I can't reach hpaste)
05:45:03 <Todor> mauke: thanks :) it's easier to read :)
05:45:06 <mauke> nilg```: it isn't
05:45:10 <mauke> nilg```: and you want lpaste
05:45:15 <int-e> @type M.toList . M.fromListWith (++) . map (second (:[]))
05:45:16 <lambdabot> Ord d => [(d, a)] -> [(d, [a])]
05:45:28 <mauke> Todor: the whole algorithm is less efficient, though
05:45:53 <Todor> mauke: why?
05:46:22 <int-e> Pranz: that might do what you want, if the keys can be compared and the precise order of the result lists doesn't matter.
05:46:32 <int-e> (M is Data.Map)
05:46:35 <mauke> because nub is O(n^2) and the other thing is, too
05:46:49 <mauke> groupBy only considers adjacent elements
05:47:12 <Todor> mauke: ok
05:47:32 <supki> vlaeter: sorry, I know nothing about guis :(
05:47:37 <int-e> @type groupBy ((==) `on` fst) . sortBy (compare `on` fst)
05:47:38 <lambdabot> Ord b1 => [(b1, b)] -> [[(b1, b)]]
05:47:54 <vlaeter> supki: ok, no problem :) thanks for the help; i'll just use wx for now, that's easy enough anyway
05:47:55 <merijn> The bug is actually worse on linux, as it subtly breaks the semantics there
05:48:04 <merijn> (as opposed to just crashing)
05:48:17 <int-e> @type map (fst . head &&& map snd) . groupBy ((==) `on` fst) . sortBy (compare `on` fst) -- getting ugly
05:48:18 <lambdabot> Ord b1 => [(b1, b)] -> [(b1, [b])]
05:48:35 <merijn> If for some weird reason there are no IO events it can cause the runtime toactually miss a wakeup
05:49:14 <merijn> Probably extremely unlikely, but extremely unlike races in the runtime are all the more painful to debug
05:51:34 <jophish> yo yo yo
05:51:34 <mauke> int-e: hey, that's almost my solution again
05:51:34 <jophish> I'm using regex-applicative, but I'm fairly new to haskell and am not sure if what I'm doing is idiomatic or efficient
05:51:50 <jophish> I've tried to implement an 'optional' combinator for regex-applicative, but I'm not sure I ahve it quite right
05:51:52 <jophish> http://pastebin.com/KuecpxbH
05:51:58 <mauke> The paste KuecpxbH has been copied to http://lpaste.net/91178
05:52:08 <merijn> I think using regexes already disqualifies it from being idiomatic :) *hides from the flamewar he just started*
05:52:31 <int-e> mauke: I'd probably use the Data.Map one though. Just need some profiling, and I don't know whether I should use fromListWith (++) or fromListWith (flip (++))
05:52:41 <jophish> also, I have a suspicion that 'read <$> ( (++) <$>' can be simplified
05:53:33 <jophish> also, is MonadPlus a sensible thing to be using here?
05:59:07 <merijn> whooo!
05:59:09 <jophish> Is there a function to concatenate a String and a Maybe String?
05:59:19 <jophish> or should I do this myself?
05:59:20 <merijn> I succesfully fix a GHC bug! Do I get a cookie? :)
05:59:24 <merijn> s/fix/fixed
06:00:02 * Yaniel gives merijn a cookie "there you go :)"
06:01:05 <k00mi> jophish: do you mean returning the original string if it is Nothing?
06:01:18 <jophish> k00mi: exactly
06:02:03 <jophish> I suppose this could be made more general, adding a MonadPlus with mzero if it's Nothing
06:02:53 <jophish> I'm coming from a C++ background, and have no idea what level of generalisation is appropriate in Haskell
06:03:14 <k00mi> jophish: string ++ fromMaybe "" theMaybe, or string ++ concat (maybeToList theMaybe)
06:04:26 <jophish> k00mi: exactly what I have already :D glad to see I got that right]
06:04:42 <jophish> Thanks
06:04:45 <k00mi> heh, ok
06:04:52 <taylorgb> I usually generalise until things stop becoming simpler
06:05:13 <Cale> jophish: It's easy to go crazy about abstraction, because Haskell is good at it, but try to make sure you have at least two instances of any new typeclass :)
06:07:24 <jophish> Sounds like a plan. Thanks
06:09:39 <eikke> is there, using conduits, a way to eg take a Source of ByteString's, then write these to a file (easy) and count the number of bytes yielded by the source (easy), but both at the same time (not easy)?
06:17:14 <merijn> Cale: Well, it depends on what you do. I frequently have typeclasses with only one instance for type level hackery. OTOH, I don't think I've ever implemented a typeclass for non typelevel hackery? :>
06:18:36 <mauke> have you ever used a class with 0 parameters?
06:18:37 <b2coutts> this isn't really a haskell question, but I think it fits well with this channel: the typical way to manage a symbol table is some sort of tree, right? Does it make sense to do an initial pass-through of the code to find which base functions are actually used, and load only those ones into the initial symbol table to speed up operations on the tree?
06:18:54 <Saizan> eikke: lazy or strict?
06:19:28 <b2coutts> I'm writing an interpreter, and figuring out how to optimize it is probably the most interesting CS thing I've ever done
06:19:47 <eikke> Saizan: in what?
06:21:08 <Saizan> eikke: which ByteString type are you using there?
06:21:28 <eikke> Saizan: don't think that matters a lot, but say strict
06:21:54 <eikke> basically I need to do 2 things on my stream (a fold and an iter) within one iteration
06:22:25 <Gothmog_> b2coutts: Most probably not, at least if your tree operations have at most logarithmic complexity.
06:22:47 <Saizan> eikke: make the iter return the lengths and then fold that?
06:22:51 <Eduard_Munteanu> b2coutts: if you make a global Map, it should memoize it
06:23:23 <b2coutts> Gothmog_: they do, but even so you would probably get some sort of speedup; though I suppose the initial symbol table probably wouldn't be large enough for this to make much difference
06:23:46 <Eduard_Munteanu> b2coutts: do you need to update it?
06:24:21 <b2coutts> Eduard_Munteanu: sort of; I don't use mutation, I just pass a new symbol table with another entry added
06:24:34 <Eduard_Munteanu> Ah, so you do need to.
06:24:47 <b2coutts> yeah, for let bindings and such
06:25:11 <Gothmog_> b2coutts: But you also have to pay for the speedup in advance. So I'd dismiss the additional complexity.
06:25:42 <b2coutts> Gothmog_: yeah, but I can see it perhaps being valuable when compile-time is negligible compared to run time
06:26:13 <b2coutts> if you have a short program that looks up a function millions of times, doing an initial pass-through of the code to cut down the size of the symbol table could make it faster
06:26:29 <eikke> Saizan: that doesnt feel very composable
06:27:16 <Gothmog_> Yeah, that's right. However, I still would classify it as a low-priority optimization.
06:27:23 <eikke> in the real app its not about counting bytes, but calculating a hash of the data passed through the pipeline
06:28:08 <merijn> eikke: Is there no &&& like (or arrow instance!) for them?
06:28:30 <taylorgb> b2coutts: What kind of language is it? I mean it sounds like it's a pre-compiled language, but you said it was an interpretter?
06:29:09 <eikke> merijn: interesting thought
06:29:45 <b2coutts> taylorgb: it's actually an interpreter, but the first pass-through just parses the program into a list of tokens, and a list of referenced names could easily be generated from the token list before evaluating it
06:30:14 <merijn> eikke: That'd be my first attempt, as then it's trivial
06:30:42 <eikke> there's no Arrow instance for ConduitM on first sight :)
06:30:51 <eikke> will look further in an hour, got to run now
06:31:50 <taylorgb> I was just thinking that you could lose some flexibility if you make such eliminations. For example, if you want to add more code later to the running program that no references those previously unreferenced things
06:32:06 <taylorgb> er now references
06:32:34 * hackagebot web-routes-boomerang 0.27.1 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.27.1 (JeremyShaw)
06:32:48 <taylorgb> Like if you wanted to implement a repl for your language
06:34:53 <b2coutts> taylorgb: yeah, I suppose it wouldn't extend very well to repls
06:35:12 <b2coutts> right now my interpreter operates under the assumption that it's just given a string representing a program, and it has to create a value from it
06:35:35 <taylorgb> fair enough
06:36:08 <b2coutts> a repl would probably be a good idea though; it would work fairly well with the language
06:36:26 <b2coutts> at some point I'll need to throw out all the code I've written and rewrite from scratch; I'll probably try to include one when I do that
06:38:31 <merijn> Right, any OSX users that like compiling GHC and wanna verify a bug is fixed? :)
07:03:38 <dropdrive> Am I right in thinking that by writing my own Data.Array.Repa.Shape type, I can statically label array "dimensions" and prevent myself from, say, calling (+^) on a "Fruit x Animal" array with a "Country x Month" array?
07:05:47 <zvrba> what happened with comonad.com ?
07:07:14 <merijn> zvrba: I asked edwardk what happened a week ago or so, but I didn't get any response
07:07:20 <zvrba> hm >:
07:07:51 <zvrba> he wrote a post "Abstracting with Applicatives".. I was hoping to get a better idea of what applicatives are useful for
07:08:02 <zvrba> (LYAH gives just toy examples, and the original paper didn't help)
07:08:11 <zvrba> but it's inaccessible :/
07:08:32 <Philippa> zvrba: applicatives describe embedded languages that have a notion of (n-ary) function application, but not necessarily higher-order functions
07:08:46 <Philippa> compare and contrast with monads, which are applicatives that /do/ have their own notion of higher-order function
07:09:40 <merijn> zvrba: Applicatives are mostly useful for things that are almost but not quite monads
07:10:09 <supki> zvrba: there is a mirror at http://comonad.newartisans.com/reader/index.html
07:10:33 <Philippa> It turns out there are things that can be applicatives but not monads (for example, you can write the zipN functions once and for all). You also get the usual engineering trade-offs: a language that's less powerful in some regards (no HOFs) may offer other capabilities that wouldn't be achievable otherwise (eg statically examining the structure of a program/computation)
07:11:13 <merijn> Philippa: The difference between monads and applicatives is that if you write "f <*> x" you can inspect both f and x inside the implementation of <*>
07:11:16 <merijn> eh
07:11:23 <merijn> s/Philippa/zvrba
07:12:33 <zvrba> supki: thanks. found it in google cache too
07:13:43 <zvrba> merijn: how can I inspect functions? if whatever is before <$> takes n arguments, I have to have n-1 <*>s
07:13:55 <zvrba> otherwise it gets partially applied
07:14:49 <Philippa> zvrba: right, and you can tell /that/ too
07:14:55 <zvrba> (+) <$> (Just 3) :: Num a => Maybe (a -> a)
07:15:39 <Philippa> yeah. A typeclass instance'll spot that you've got an -> as the outermost constructor inside the Maybe, for example
07:16:05 <merijn> zvrba: I mean that "(Just f) <*> (Just x)" here <*> can take a look at both the constructor on the left and right
07:16:22 <merijn> zvrba: "(Just x) >>= f" <- no clue what f returns as a constructor
07:16:33 <zvrba> merijn: oh, ok.
07:16:55 <abc22134> @pl \a -> a + b
07:16:55 <lambdabot> (b +)
07:17:04 <zvrba> merijn: but each <*> sees only its immediate neighbors, and f in f<$> sees the whole expression?
07:17:23 <abc22134> @pl \a b -> a + p*b
07:17:26 <lambdabot> flip ((.) . (+)) (p *)
07:17:27 <lambdabot> optimization suspended, use @pl-resume to continue.
07:18:42 <abc22134> @pl-resume
07:18:48 <lambdabot> flip ((.) . (+)) (p *)
07:18:48 <lambdabot> optimization suspended, use @pl-resume to continue.
07:18:52 <abc22134> @pl-resume
07:19:04 <lambdabot> flip ((.) . (+)) (p *)
07:19:04 <lambdabot> optimization suspended, use @pl-resume to continue.
07:19:07 <abc22134> @pl-resume
07:19:15 <dropdrive> Philippa: "right, and you can tell /that/ too" -- how?
07:19:15 <merijn> zvrba: Sure
07:19:22 <lambdabot> Plugin `pl' failed with: <<timeout>>
07:19:31 <merijn> zvrba: Eh, wait, no
07:19:40 <merijn> zvrba: All of them only see their direct neighbors
07:19:50 <zvrba> ... ?
07:19:59 <merijn> You have to compute "f <$> x" before computing "(f <$> x) <*> y"
07:20:14 <zvrba> but the paper starts with defining shortcut syntax like [| f x1 x2 ... x_n |] for an n-ary function
07:20:22 <merijn> Which comes before "((f <$> x) <*> y) <*> z", etc
07:20:24 <zvrba> ah
07:20:36 <Nimatek> Can someone who knows how to build stuff on Windblows please help me with this: http://pastebin.com/LZb0icdg
07:20:39 <mauke> The paste LZb0icdg has been copied to http://lpaste.net/91179
07:20:51 <zvrba> ah, so <$> "lifts" f, and each <*> "threads" it through arguments.
07:20:55 <merijn> zvrba: The brackets are just "automatically insert any number of <*> around all arguments" notation
07:20:58 <merijn> zvrba: Yes
07:21:07 <merijn> zvrba: Remember, <$> is just fmap
07:21:09 <Philippa> dropdrive: standard typeclass (ab)use
07:21:12 <zvrba> yes
07:21:24 <zvrba> Philippa: a concrete example?
07:21:36 <Philippa> though if all you have is <$> and <*>, an f (a -> b) is not necessarily very useful
07:22:50 <Philippa> zvrba: ask someone who writes more code in a day than I do in a year, there're plenty around here. But that function arrow being /inside/ the f is what matters: it's no longer a value-of-function-type so you can dispatch on f (... -> ...), effectively. You just write a typeclass instance fitting that pattern
07:23:21 <Philippa> many applicatives plain don't have any use for that type though: they don't do higher-order functions, so while you've got your hands on a 'function' it's just a black box you can't do anything with
07:23:24 <zvrba> !
07:23:46 <merijn> zvrba: Let's look at a silly example
07:23:50 * CaptainK discovers η-reduction, wonders if you can do that for multiple parameters?
07:24:08 <quchen> zvrba: For a practical example of Applicatives, have a look at the RWH chapter on using Parsec. http://book.realworldhaskell.org/read/using-parsec.html#id652399
07:24:12 <zvrba> Philippa: that was a golden nugget! f (.. -> ..) can be dispatched on since it's not a function type! :)
07:24:23 <merijn> zvrba: Well, "silly" it's used in lens, but still. "newtype Const a b = Const { runConst :: a }"
07:24:39 <zvrba> ok..
07:24:54 <zvrba> quchen: ok, will study it later today.
07:24:55 <Philippa> zvrba: right. It's an f-ed up function, not a function per se :-)
07:25:07 <merijn> zvrba: Clearly "instance Functor (Const a) where "fmap f (Const x)  = Const x"
07:25:51 <Philippa> dropdrive: did I (perhaps implicitly) answer your question adequately?
07:26:03 <merijn> But "Const a" is not an applicative, because after you do "fmap (+) (Const c') :: Num a => Const Char (a -> a)" you can never get the applied (+) out
07:26:27 <merijn> zvrba: The ability to get functions "back out" after an fmap is what makes Applicative different from Functor
07:27:22 <elliott> merijn: huh?
07:27:30 <elliott> (Const a) is an Applicative when a is a Monoid.
07:27:35 * hackagebot cpsa 2.3.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.3.0 (JohnRamsdell)
07:27:43 <elliott> you don't need to get any values out :)
07:27:49 <zvrba> merijn: ok.
07:27:54 <merijn> elliott: hmm, bugger :p
07:27:59 <elliott> (indeed, lens uses this)
07:28:49 <supki> (actually lens uses Accessor which is isomorphic to Const)
07:30:05 <dropdrive> Philippa: Not really, but I'm also kind of a beginner.  Thanks anyway though!
07:31:08 <Philippa> dropdrive: basically, it's down to whether there're any ->s inside the Applicative's constructor
07:32:03 <applicative> merijn: what is the bug in ghc you were talking about
07:33:15 <merijn> applicative: http://ghc.haskell.org/trac/ghc/ticket/8089
07:38:36 <applicative> merijn, really disgusting bug
07:39:17 <applicative> funny, isnt this 'empty' in the alternative instance in the async library
07:39:51 <merijn> applicative: Tell me about it :)
07:42:35 * hackagebot diff3 0.2.0 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.2.0 (OliverCharles)
07:43:16 <applicative> I see, it's the same with e.g. main = runConcurrently empty
07:44:25 <merijn> applicative: Yes
07:45:05 <merijn> Hence why I was so surprised by this breaking
07:46:40 <applicative> i'm a little puzzled since I feel like I have used this alternative instance
07:46:57 <applicative> but i guess not in a way that would land on empty
07:48:22 <quchen> runConcurrently empty?
07:48:48 <quchen> That looks too innocent to be mentioned without being evil.
07:50:20 <quchen> empty = Concurrently $ forever (threadDelay maxBound)
07:50:20 <quchen> Wow.
07:50:48 <merijn> quchen: Why is that evil?
07:51:02 <merijn> quchen: The alternative for async returns the first thing to complete
07:51:03 <quchen> Well, not evil, it's just not what I expected.
07:51:22 <quchen> It makes sense, yes.
07:51:22 <merijn> quchen: ergo, empty never completes
07:51:39 <merijn> quchen: The evil bit is that "threadDelay maxBound" is broken on many machines and will, in fact, downright crash the runtime on OSX
07:51:49 <quchen> But suppose you're not familiar with the Concurrently Alternative instance, you'd expect "runConcurrently empty" to be more of a NOOP than an infinite delay.
07:52:18 <merijn> why?
07:52:18 <quchen> merijn: Oh, the delay is broken? I thought the bug was with this other function (I had a glimpse at your diff)
07:52:35 * hackagebot diff3 0.2.0.3 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.2.0.3 (OliverCharles)
07:52:38 <merijn> quchen: Well, the other function is broken, but threadDelay calls it indirectly
07:53:02 <quchen> "runConcurrently empty" sounds like an empty computation is run to me.
07:53:15 <merijn> quchen: So 64bit GHC on OSX you can write a crashing program with just "import Control.Concurrent; main = threadDelay maxBound"
07:53:15 <quchen> Anyway, my poor taste is OT. :-)
07:53:44 <applicative> quchen: I threw in the async thing, but I guess thats how merijn got into it
07:53:49 <applicative> it's threadDelay
07:54:16 <quchen> Ah, that polling function is part of threadDelay's implementation
07:54:39 <quchen> And it compares the current time of some type to the delay-issuing time of some other type, something along those lines?
07:55:06 <quchen> And somewhere there can be an overflow
07:55:42 <merijn> quchen: No it computes the timeout in seconds as a Double
07:55:54 <merijn> Then converts the Double to Int using ceil
07:56:07 <merijn> Then converts Int to CInt without any bounds checking
07:56:30 <merijn> But on many 64 bit architectures CInt is 32bit, where as 64bit GHC uses 64bit Int
07:56:49 <merijn> So converting Int to CInt can overflow, resulting in a negative value
07:57:02 <quchen> Is there some guarantee that Int > CInt?
07:57:03 <merijn> Passing a negative value to poll is an error on OSX, crashing the runtime
07:57:09 <merijn> quchen: No
07:57:29 <merijn> quchen: But the other way isn't dangerous, as that'd mean the specified timeout is smaller than the max accepted by poll
07:57:49 <merijn> On linux all negative timeouts are treated as infinite, so that's still the wrong semantics (but almost unnoticeable)
07:57:51 <quchen> Isn't the maxPollTimeout function volatile as well?
07:58:02 <merijn> No, why would it be?
07:58:10 <quchen> Maybe not in the current implementation, but who knows what's going to be added in the future
07:58:24 <quchen> Ah, it's in the 'where' clause, overlooked the indentation
07:58:32 <quchen> I guess then it's just a little locally dangerous ;-)
07:58:58 <applicative> hm, so I put the patch on GHC/Event/Poll.hsc
07:59:25 <applicative> now we'll see if can remember what combinations of flags makes this work
07:59:28 <merijn> applicative: You can also just pull the branch of packages-base from my github and use that overwrite libraries/base in your GHC folder
08:00:09 <applicative> merijn: yes, i just did perl boot though to get them, as I stopped building my own when ghc-7.6 was available
08:00:18 <applicative> that is, I haven't been doing it lately
08:01:07 <applicative> wait let me try it yr way
08:01:27 <merijn> Anyhoo, I'm off for a bit
08:01:32 <klrr> hi
08:01:49 <applicative> hi klrr
08:01:58 <applicative> merijn: yes the correct way is easier
08:08:11 <chunkstuntman> http://pastebin.com/aG7icFyE
08:08:17 <mauke> The paste aG7icFyE has been copied to http://lpaste.net/91180
08:08:28 <chunkstuntman> I'm not sure what I would do with the types of the functions to make it compile
08:08:55 <chunkstuntman> also lpaste is down?
08:09:15 <chunkstuntman> how I do say that a function returns a fractional?
08:09:17 <DexterLB> if I have "data Foo = Bar Int | Baz Float", and I have a list [Foo], how do I filter it to a list containing only Bar's?
08:10:28 <chunkstuntman> DexterLB: make a function that pattern matches to the Bar and the Baz
08:10:34 <supki> DexterLB: filter (\foo -> case foo of Bar _ -> True; Baz _ -> False)
08:10:52 <DexterLB> thanks
08:11:39 <supki> chunkstuntman: a fractional isn't a type
08:11:41 <mauke> why not a list containing Ints?
08:11:43 <applicative> chunkstuntman: len x y = floor $ sqrt (fi x^2 + fi y^2); fi = fromIntegral
08:12:32 <applicative> with isPyth a b c = (a^2 + b^2) == ( c^2)
08:15:17 <applicative> I wonder if you could do a swank version of isRight with the cyclotomic library
08:20:17 <danharaj> does anyone know how to make a project with a lot of TH build faster?
08:24:30 <klrr> chrisdone: nice new design for your blog, simple, yet great looking with that selection of fonts and nice grey color
08:26:57 <applicative> somehow building ghc reminds me of the space program of my childhood, instead of "jettison Stage 1!" its "inplace/bin/ghc-stage1"
08:36:38 <applicative> i wonder if i could adjust the ghc Makefile so that a buzzer went off when it was done.
08:37:06 <applicative> and another when it failed
08:37:22 <Saizan> danharaj: maybe make sure ghc is picking compiled code for the macros?
08:38:12 <danharaj> Saizan: How would I do that? TH changes in a module way down the dependency list causes everything to rebuild :3
08:39:24 <scooty-puff> if a package is already using newish language extensions like PolyKinds, is there much of a reason to avoid LambdaCase (i ask because LambdaCase is just syntactic and avoidable, though it is nice)?
08:41:23 <applicative> somehow I think uhc and jhc will have lambda case before they have wacky ghc type extensions
08:41:28 <astor> Is there any language that has toyed with making whitespace more magic, for example such that: a  Just b c was parsed as a (Just b) c because of the double space?
08:42:14 <mauke> why not 'a (Just b c)'?
08:42:28 <astor> mauke because Just takes one parameter
08:42:53 <applicative> certainly astor there are languages that have made much more of white space https://github.com/edwinb/WS-idr/blob/master/hanoi.ws
08:42:57 <mauke> ah, so it would be parsed differently than 'a  just b c'?
08:43:07 <scooty-puff> fixity by whitespace proximity?
08:43:45 <applicative> there is a tradition in logic of using additional whitespace around an infix operator to weaken precedence
08:43:52 <applicative> myabe thats what astor is thinking of
08:44:18 <astor> mauke: the Just a b would be parsed like in haskell today I guess, the difference is that the double space would introduce a parenthesis that ends wherever it needs to end.
08:45:09 <astor> applicative: maybe. *if* we assume fixed-width font, it could improve readability.
08:45:34 <applicative> astor: so for double or triple whitespace "   " we read " $ " so to say
08:47:36 <astor> applicative: I guess it would be similar to $.
08:47:41 <applicative> astor, i do which I could use the unicode nbspace thing in place of $
08:47:43 <mauke> inb4 em-space
08:47:55 <applicative> it would look a little strange if your editor didn't show anything ...
08:48:11 <Saizan> danharaj: by putting them in a different lib, if that's possible
08:48:27 <lingxiao> hey all: in terms of the concepts involved and comfort with haskell required, how advanced does someone have to be to implement a coroutine library?
08:48:32 <danharaj> Saizan: thanks, that's a good idea!
08:48:47 <lingxiao> Knowing there's plethora of sources and existing packages, so not breaking any new grounds here
08:55:19 <applicative> lingxiao: the topic is maybe a bit of a blur but see http://random.axman6.com/blog/?p=231 and the (truly amazing) third article in http://themonadreader.wordpress.com/2011/10/26/issue-19/
08:56:51 <chunkstuntman> http://pastebin.com/pxgsqQjw
08:56:52 <applicative> lingxiao: and of course a million other things
08:56:57 <mauke> The paste pxgsqQjw has been copied to http://lpaste.net/91181
08:57:12 <chunkstuntman> where fi is fromIntegral
08:57:24 <chunkstuntman> why am I being told it's not a fractional?
08:57:31 <edkk> @pl f x y = sum (map a (b x y))
08:57:31 <lambdabot> f = ((sum . map a) .) . b
08:58:22 <lingxiao> applicative: Thank you for the resources! I've following the tutorial on FP complete, and the biggest challenge I found is that implementing coroutines reqiure me to describe computatioons using types in a way that is beyond what I have done
08:59:11 <lingxiao> And I'm really intent on gorking this pattern of thinking, and would like to know..if I do, where does it take me in terms of level?
08:59:15 <lingxiao> of ability*
08:59:29 <ClaudiusMaximus> lingxiao: i'd say it's intermediate/advanced (defining monad transformers is chapter 10 of 12 in Bird's Introduction to Functional Programming in Haskell
09:01:00 <lingxiao> ClaudiusMaximus: see I've been rolling monad transformers for a bit now, but the stuff I'm doing with them is trivial compared tothis, is it the domain (concepts of coroutines) that's new? Or is it a more advanced way to think about layers of compuations that's specific to haskell?
09:02:38 <applicative> chunkstuntman: shouldnt this be sameAngle x y z w = x*z = y*w ?
09:04:17 <applicative> chunkstuntman: which works for any Num and specializes everything to use the same choice of Num instance
09:06:34 <FreeFull> @pl undefined
09:06:34 <lambdabot> undefined
09:06:45 <FreeFull> @pl \x -> const x x
09:06:45 <lambdabot> id
09:06:55 <FreeFull> @pl \x -> const x x x x
09:06:56 <lambdabot> join (join id)
09:07:00 <shachaf> You can /msg lambdabot, you know.
09:07:03 <FreeFull> :t join . join id
09:07:04 <lambdabot>     Occurs check: cannot construct the infinite type:
09:07:04 <lambdabot>       a0 = a0 -> m0 (m0 a1)
09:07:04 <lambdabot>     Expected type: a0 -> a0 -> m0 (m0 a1)
09:10:55 <bytbox> is there some typeclass exposing functions like maxVal :: Word8 = 255 ?
09:11:11 <shachaf> > maxBound :: Word8
09:11:12 <lambdabot>   255
09:11:22 <shachaf> (Not a function, though!)
09:11:31 <bytbox> shachaf: "function" - but thanks
09:15:42 <elliott> shachaf: I,I instance ??? => Bounded (a -> b)
09:31:23 <resnik_> git /quit
09:31:44 <Yaniel> that's a new one
09:32:11 <applicative> is there a context in which that would make sense?
09:32:15 <applicative> git /quit
09:36:18 <applicative> @tell merijn this changes the behavior of threadDelay maxBound inside ghci from "<interactive>: kevent: invalid argument (Invalid argument)" to a seeming threadDelay; however, compiled, it yields "select: Invalid argument"
09:36:18 <lambdabot> Consider it noted.
09:36:44 <nicoo> applicative: Can't one add custom commands to git ?
09:36:53 <nicoo> (or an alias should work)
09:37:01 <applicative> ah no doubt
10:00:49 <applicative> so on os x threadDelay 100000001000000 is what it says, threadDelay 100000001100000 is a catastrophe
10:02:17 <applicative> it's a little hard to see what interesting number is between them
10:04:39 <monochrom> > 100000001000000 :: Int64
10:04:40 <lambdabot>   100000001000000
10:04:50 <monochrom> > 100000001100000 :: Int64
10:04:51 <lambdabot>   100000001100000
10:05:08 <monochrom> what catastrophe did you get?
10:07:46 <applicative> monochrom: inside ghci its kevent: invalid argument
10:08:17 <applicative> i found the breakoff 100000001000040 makes sense 100000001000041 makes no sense
10:08:21 <applicative> bizarre
10:09:06 <applicative> so obviously the alternative instance in async for Concurrently
10:09:26 <applicative> should just be empty = Concurrently $ threadDelay 100000001000040
10:09:56 <applicative> instead of empty = Concurrently $ threadDelay maxBound which just too nice
10:10:08 <applicative> that should be with forever $ , sorry
10:12:41 <applicative> since <|> 'races' the args
10:13:26 <elliott> threadDelay maxBound is bad on 32-bit...
10:13:28 <elliott> even if it works
10:13:32 <elliott> (IIRC)
10:13:43 <applicative> yeah, that's appearing clear
10:14:02 <applicative> merijn made patch which seems to make it okay inside ghci
10:14:04 <elliott> just for being too short
10:15:04 <applicative> but its the same if I compile, though the error is 'select: invalid argument' instead of 'kevent:invalid argument'
10:17:03 <applicative> elliott: but anyway, it seems obvious threadDelay is going to be a delicate matter, maybe simon m. should just stick to something comparatively small?
10:17:21 <elliott> forever (threadDelay maxBound) seems like the best choice once it's fixed.
10:17:29 <elliott> there's no reason the RTS should be doing that Double/Int/CInt nonsense
10:17:43 <c_wraith> man, I reported that RTS bug a long time ago
10:17:44 <applicative>  it's fixed.
10:17:45 <applicative>  it's fixed.
10:17:48 <c_wraith> oh, ok
10:17:49 <applicative> sorry
10:17:59 <applicative> forever (threadDelay maxBound) is pleasing, certainly
10:18:02 <c_wraith> I was going to say if it wasn't fixed by now, that'd be kinda ridiculous
10:18:22 <applicative> does everyone have this on all platforms?
10:18:54 <c_wraith> I only found it on OS X
10:19:08 <c_wraith> with 64-bit GHC, in particular
10:19:20 <applicative> ah that fits with what i understood from merijn
10:20:12 <applicative> It must be simple to understand, but how can his patch have fixed it inside ghci, but not with compilation
10:21:03 <applicative> One bumps into that sort of thing periodically
10:21:03 <c_wraith> if it's some sort of issue with native value sizes, it could be the differences in how interpretation and compilation package things
10:25:09 <zvrba> hm
10:25:14 <jfischoff> what is easy way to glob expand a file path? I want to pass int ".cabal-sandbox/*.conf.d" and have it expand to ".cabal-sandbox/x86_64-linux-ghc-7.6.4-packages.conf.d/".
10:25:40 <zvrba> I have a list of (Int, Int) where I want to sort it independently, once on the 1st, once on the 2nd component as the primary key
10:25:44 <zvrba> now
10:26:20 <zvrba> sortBy (compare . swap) gives a different result from map swap $ sort $ map swap
10:26:31 <zvrba> and I cannot figure out why :S
10:27:29 <zvrba> when sorting by (compare . swap), I get a subsequence like (0,17),(0,22),(2,2)
10:27:34 <c_wraith> compare . swap has entirely the wrong type
10:27:39 <zvrba> huh ?
10:27:45 <c_wraith> :t compare . swap
10:27:46 <lambdabot> (Ord b, Ord a) => (a, b) -> (b, a) -> Ordering
10:27:53 <zvrba> a = b = Int
10:27:59 <zvrba> it typechecks and runs
10:28:05 <c_wraith> :t compare `on` swap
10:28:06 <lambdabot> (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
10:28:46 <c_wraith> yes, make a and b different types, and you can see that it's wrong
10:28:53 <c_wraith> it only worked because a and b were the same type
10:29:10 <zvrba> ok, but still, why is it semantically wrong?
10:29:10 <c_wraith> Because it's a different operation
10:29:19 <c_wraith> it swaps the first one, then it compares it to the second
10:30:42 <c_wraith> unswapped
10:30:42 <conal> zvrba: compare . swap == \ b -> compare (swap b) == \ a b -> compare (swap b) a
10:30:42 <zvrba> ahh!
10:30:42 <zvrba> ok
10:30:42 <elliott> conal: \ b a -> last, no?
10:30:42 <conal> elliott: yes, thx
10:30:43 <conal> zvrba: try 'on' or 'comparing'
10:31:57 <merijn> ok, so who wants to practice their debugging skills or "realising why portability sucks" skills? :p
10:32:15 <zvrba> compare `on` swap gives an error about eta reduce.
10:32:31 <zvrba> sortBy (compare `on` swap)
10:32:38 <zvrba> what to do now?
10:32:56 <zvrba> ah, no, wait
10:33:13 <elliott> that's just an hpaste warning.
10:33:16 <elliott> not a compiler error.
10:33:44 <zvrba> right
10:34:07 <c_wraith> zvrba: it's quite possible for « map swap . sort . map swap » to actually be faster, though
10:34:45 <c_wraith> zvrba: That's one that's going to come down to how well the compiler applies various optimizations.  I'd need to benchmark to know for sure which is better.
10:35:11 <zvrba> c_wraith: yeah, it may be faster. but I don't care about speed right now.
10:35:25 <zvrba> I want to explore different ways of function compositions
10:37:57 <c_wraith> Oh, also...  One more data point about compare . swap.  It's not a coherent comparison function (a < b does not imply b > a). You can get very different results sorting with it with only slightly different input lists
10:38:05 <sclv> $upp0rt1
10:38:09 <sclv> gah
10:38:16 <c_wraith> time to change a password
10:38:22 <zvrba> :)
10:47:39 * hackagebot module-management 0.15.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.15.1 (DavidFox)
10:47:41 * hackagebot music-pitch 1.3.1 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.3.1 (HansHoglund)
10:47:43 * hackagebot music-pitch-literal 1.3.1 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.3.1 (HansHoglund)
10:47:45 * hackagebot music-dynamics 1.3.1 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.3.1 (HansHoglund)
10:47:47 * hackagebot music-dynamics-literal 1.3.1 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.3.1 (HansHoglund)
10:52:49 * hackagebot music-parts 1.3.1 - To be written.  http://hackage.haskell.org/package/music-parts-1.3.1 (HansHoglund)
10:52:51 * hackagebot music-articulation 1.3.1 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.3.1 (HansHoglund)
10:52:53 * hackagebot music-score 1.3.1 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.3.1 (HansHoglund)
10:52:55 * hackagebot music-preludes 1.3.1 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.3.1 (HansHoglund)
10:52:57 * hackagebot music-sibelius 1.3.1 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.3.1 (HansHoglund)
10:56:02 <kqr> i have a question. i want to perform `\g h -> f (g x) (h x)'. i was thinking maybe i could use on, but `f `on` x' gives me `\g h -> f (x g) (x h)' which is not quite what i needed. is there any way to solve this?
10:56:33 <kqr> i was thinking maybe ($) is involved somehow, but i didn't get it to make sense
10:56:43 <monochrom> applicative: "kevent: invalid argument" vs "select: invalid argument" is probably just because -threaded vs no -threaded. (ghci was built with -threaded)
10:56:44 <supki> > liftA2 (f :: Expr -> Expr -> Expr) g h x
10:56:45 <lambdabot>   f (g x) (h x)
10:56:58 <kqr> oh
10:57:24 <enthropy> > f `on` ($ x) :: Expr
10:57:25 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
10:57:25 <lambdabot>              w...
10:58:24 <enthropy> > f `on` ($ x) g h :: Expr
10:58:25 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
10:58:25 <lambdabot>              w...
10:58:34 <enthropy> > (f `on` ($ x)) g h :: Expr
10:58:35 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
10:58:35 <lambdabot>    arising from a us...
10:58:56 <enthropy> well somehow that one is supposed to work too
10:59:16 <kqr> it does
10:59:28 <kqr> i tried messing around with ($) on the functions
10:59:34 <kqr> didn't think that i could do it on the argument!
10:59:37 <kqr> thanks
10:59:40 <supki> > ((f :: Expr -> Expr -> Expr) `on` ($ x)) g h
10:59:41 <djahandarie> > ((f :: Expr -> Expr -> Expr) `on` ($ x)) g h
10:59:41 <lambdabot>   f (g x) (h x)
10:59:42 <lambdabot>   f (g x) (h x)
11:01:36 <jfischoff> is expected behavior that :set -package-db=blah doesn't have an affect when specified in the .ghci file, or am I doing something wrong?
11:02:52 <elliott> probably runs too late?
11:03:57 <jfischoff> I guess so
11:04:14 <jfischoff> a warning message would be nice :p
11:04:50 <geekosaur> doesn't the ghc manual indicate in the options summary whether it's valid in various contexts (.ghci, GHC_OPTIONS pragma, etc.)?
11:05:58 <geekosaur> hm, not quite in the form I implied, there's a "Static/Dynamic" indication, with some exceptions that are "static/:set"
11:07:51 <jfischoff> geekosaur: I see. I guess if it doesn't have a :set then you can't use :set ...
11:07:52 <jfischoff> okay
11:08:09 <geekosaur> it is usable if it is dynamic or if it is static/:set
11:08:21 <geekosaur> if just static, not usable
11:08:29 * jfischoff nods
11:10:26 <merijn> Gah
11:10:32 <merijn> I hate it when I typo my commit messages :(
11:11:15 <sm> and push them ?
11:11:21 <aristid> merijn: i've been thinking that we need a meta-history for the history
11:11:31 <aristid> merijn: so we can change the history without throwing away data :)
11:11:39 <merijn> sm: Of course
11:12:08 <merijn> I left out the word "fixed" in "Really fixed blahblah" >.<
11:12:19 <merijn> Also, got to love commits that go
11:12:23 <merijn> "Fixed issue X"
11:12:31 <merijn> Next commit: "*really* fixed issue X"
11:12:35 <sm> heh
11:13:03 <merijn> I changed one underflow into another >.>
11:13:09 <merijn> anyhoo, time to run
11:13:18 <sm> metahistory sounds almost like one of things that'll come to pass
11:13:36 <sm> s/almost//
11:13:50 <monochrom> commit messages need version control too :)
11:13:56 <aristid> sm: \o/ thanks for the confidence
11:13:58 <aristid> monochrom: indeed!
11:14:21 <sm> not just the messages, but the way hunks were grouped into patches - that can always be improved
11:14:30 <aristid> note that the version control for the commit messages also needs version control
11:14:32 <aristid> ad infinitum
11:14:49 <sm> with metahistory, you still have the developer's working patches, as well as the final cleaned-up ones
11:18:17 <sm> as you just said :)
11:18:49 <dmwit> metacircular history
11:20:17 <monochrom> aristid: I'm betting on commit messages' version control doesn't have its own commit messages, and therefore the chain stops there :)
11:20:23 <tdammers> http://whatthecommit.com/
11:27:44 <applicative> @tell merijn with the new patch, rebuilding, I get my errors inside ghci back, in the form " c_poll: invalid argument" ; the compiled main = threadDelay maxBound says still "select: invalid argument"
11:27:44 <lambdabot> Consider it noted.
11:30:59 <dav> compiling on the raspi is slow, but cross-compiling is just too much of a mess. giving up.
11:54:05 <tdammers>  /volunteer CommitteeR GET POST
11:54:09 <tdammers> sorry
11:54:11 <tdammers> wrong window
12:05:19 <Ralith> @src ap
12:05:19 <lambdabot> ap = liftM2 id
12:21:06 <davd> is there any generic statistics library (defined over Traversal, Foldable etc)?
12:22:05 <davd> hstatistics and statstics (by bos) seem to be limited to vector.
12:26:05 <davd> ah, monoid-statistics might suffice. cool library.
12:27:03 <davd> obviously a nice approach to model based on the algebraic structure instead of focusing on some arbitrary container.
12:31:20 <hpaste> LowPotential pasted “Filtering and Extracting from Enumerations” at http://lpaste.net/91187
12:31:49 <LowPotential> I have a question about the best way to go about doing something that seems relatively simple (in the above lpaste. Feedback would be appreciated.
12:33:02 <supki> @ty mapMaybe
12:33:03 <lambdabot> (a -> Maybe b) -> [a] -> [b]
12:33:07 <shachaf> LowPotential: You want to do both of them in one step, as in mapMaybe.
12:33:10 <shachaf> A list comprehension also works.
12:33:20 <shachaf> E.g.: [x | Circle x <- map radius shapes] or something.
12:34:42 <LowPotential> supki shachaf: mapMaybe looks perfect. Thanks!
12:35:44 <LowPotential> Actually, in hindsight, this seems like an obvious solution.
12:37:22 <dwcook> Lots of things are obvious in hindsight :)
12:38:04 <dwcook> For example, my first thought was this one
12:38:07 <dwcook> @type catMaybes
12:38:08 <lambdabot> [Maybe a] -> [a]
12:40:26 <yesthisisuser> i see (.:) defined as (.).(.) a lot of times.. where does that convention come from? is it actually defined somewhere as (.:) = (.).(.)?
12:41:23 <Taneb> There's the pointless-fun library, maybe some other places too?
12:42:04 <yesthisisuser> ok
12:42:54 <Cale> It was in lambdabot for a long time.
12:43:01 <Cale> :t (.:)
12:43:02 <lambdabot>     Not in scope: `.:'
12:43:02 <lambdabot>     Perhaps you meant one of these:
12:43:02 <lambdabot>       `.' (imported from Data.Function),
12:43:09 <Cale> But apparently not right now
12:45:49 <tromp_> that looks like the predator operator  http://1withabullet.files.wordpress.com/2011/06/predator-laser-sight.png
12:46:56 <ski_> yesthisisuser : i derived `(.:) = (.) . (.)' a long time ago ..
12:51:05 <yesthisisuser> one day i would like to define an operator (/>^.^\>)
12:52:25 <startling> :t let (/>^.^\>) = (<*>) in (/>^.^\>)
12:52:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:57:20 <dgpratt> what is lambdabot trying to tell me? optimization suspended, use @pl-resume to continue
12:57:37 <startling> dgpratt, use @pl-resume
12:57:53 <dgpratt> startling, um...in what context?
12:58:11 <dgpratt> like instead of @pl ?
12:58:19 <shachaf> dgpratt: @pl is broken.
12:58:25 <startling> oh.
12:58:25 <shachaf> Try `cabal install pointfree` or something.
12:58:39 <dgpratt> shachaf, ok, thanks
13:01:04 <Speteor> Hey, anyone know how to install the haskell platform on CentOS6?
13:01:22 <geekosaur> it's in epel (not sure if it's current though)
13:01:37 <c4iff> Hey I have a few questions about wikimedia -> odt with pandoc is this the right place to ask them?
13:02:13 <shachaf> Probably not.
13:02:18 <shachaf> Is #pandoc a thing?
13:02:27 <c4iff> not really no one is in there
13:02:31 <josephle> it looks relatively empty
13:02:38 <startling> might as well; someone here might know.
13:03:20 <c4iff> it's kinda simple i'm having an issue with <br /> tags being put out in text literally in the final document
13:03:45 <c4iff> To lock a user’s password:<br /><code>usermod –L <username> <br> Example:  usermod –L exampleuser</code>
13:03:56 <c4iff> is the example of text i'm using
13:04:10 <c4iff> and it works when i close the code brackets before and restart them after the line break
13:04:31 <c4iff> but there's gotta be a better way than to go back and open and close them all
13:15:27 <Kimberley> kim@kim-Lenovo-H520S:~$ which cabal-dev
13:15:28 <Kimberley> kim@kim-Lenovo-H520S:~$
13:15:37 <Kimberley> Sorry, wrong window.
13:15:44 <triyo> I wish to understand the formal origins of Lenses. Are there any papers on the subject I could read?
13:16:08 <Gracenotes> There are many such origins, I think
13:16:17 <shachaf> What makes an origin formal?
13:16:49 <taylorgb> Being described in a research paper?
13:17:23 <triyo> Hmm, sorry, not what I meant. @taylorgb: yes, that's what I mean.
13:18:34 <Gracenotes> I'm not sure how you feel about talks, but there is one on YouTube from NYHUG that is two hours of all lenses all the time
13:18:51 <Gracenotes> given by edwardk
13:19:16 <triyo> Gracenotes: sure, thanks. Talk will be fine too.
13:19:21 <Clint> and 30 seconds on prisms
13:19:25 <taylorgb> I think Oleg needs to create a scheme for expressing queries in the type system. Asking things in here is always so precarious.
13:20:30 <Gracenotes> Well, no one is ever on IRC to ask for something for its own purpose; you want to do X to do Y under assumptions Z
13:21:10 <jfischoff> triyo: some lens slides http://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf
13:21:41 <Gracenotes> lenses can be derived many ways, but, as with a few constructs, usually there is only one or two that's useful for computational thinking
13:22:03 <triyo> jfischoff: thanks for the link.
13:22:20 * Gracenotes is blathering
13:22:37 <Gracenotes> here is the talk, if you haven't found it: http://www.youtube.com/watch?v=cefnmjtAolY
13:22:50 <Gracenotes> slides in description
13:23:12 <heckler0077> So I was looking for a mod function that would work with floats, and found mod' in Data.Fixed
13:23:21 <triyo> Gracenotes: thank!
13:23:21 <heckler0077> Problem is that it gives a segmentation fault with this code:
13:23:22 <heckler0077> mod' (-0.1) 4
13:23:24 <triyo> *thanks
13:23:41 <heckler0077> note the negative non-integral in the first argument
13:23:49 <heckler0077> Anyone know what's going on here?
13:24:21 <Gracenotes> > mod' (-0.1) 4
13:24:22 <lambdabot>   3.9
13:24:24 <shachaf> heckler0077: That sounds like maybe related to an old bug GHC had on Mac OS X.
13:24:30 <shachaf> You should never get segfaults from things like that.
13:24:32 <heckler0077> Yep, this is OS X
13:24:37 <shachaf> What version of GHC?
13:24:51 <heckler0077> 7.6.3
13:24:57 <heckler0077> I'm using GHCi
13:25:04 <shachaf> Hmm.
13:25:08 <shachaf> 64-bit or 32-bit version?
13:26:14 <heckler0077> I'm pretty sure I installed the 32-bit version.
13:26:33 <heckler0077> Is there something I should look at when running ghci -v to tell me for sure?
13:26:37 <shachaf> ghc --info?
13:28:55 <heckler0077> ("target arch","ArchX86")
13:30:03 <shachaf> OK, that's 32-bit.
13:30:04 <shachaf> Hmm.
13:30:33 <shachaf> I don't know. Not supposed to happen. :-)
13:30:46 <heckler0077> heh, thought so
13:31:32 <heckler0077> Some sort of bug report I should file or anything like that?
13:37:03 <startling> is there a way to get the current position from parsers/trifecta?
13:39:31 <triyo> Anyone know where http://comonad.com/ is gone to? It seems to be down.
13:39:38 <shachaf> It's down.
13:40:17 <shachaf> There's a temporary mirror you can find through Google or something.
13:40:32 <startling> ah, "mark"
13:50:55 <_justjust> how wasname of the tool to automatically download a vm image and start it to work with it
13:51:02 <_justjust> something with v?
13:52:40 <_justjust> vagrant
13:53:19 <johnw> http://comonad.newartisans.com
14:07:22 <startling> is there a Getter on "extract"ing things from a comonad in lens?
14:07:36 <Taneb> "to extract"
14:07:44 <Taneb> :t to extract
14:07:45 <lambdabot>     Not in scope: `to'
14:07:45 <lambdabot>     Perhaps you meant one of these:
14:07:45 <lambdabot>       `t' (imported from Debug.SimpleReflect),
14:07:53 <Taneb> :t Control.Lens.to extract
14:07:53 <lambdabot> Not in scope: `extract'
14:07:56 <startling> :t Control.Lens.to
14:07:57 <lambdabot> (Functor f, Control.Lens.Internal.Indexed.Conjoined p, Data.Functor.Contravariant.Contravariant f) => (s -> a) -> p a (f a) -> p s (f s)
14:08:00 <Taneb> :t Control.Lens.to Control.Comonad.extract
14:08:00 <lambdabot> (Functor f, Control.Lens.Internal.Indexed.Conjoined p, Data.Functor.Contravariant.Contravariant f, Control.Comonad.Comonad w) => p a (f a) -> p (w a) (f (w a))
14:08:07 <Taneb> > (1, 2) ^. Control.Lens.to Control.Comonad.extract
14:08:08 <lambdabot>   Not in scope: `Control.Lens.to'Not in scope: `Control.Comonad.extract'Not i...
14:08:15 <startling> does it just turn a function into a getter?
14:08:18 <Taneb> Yeah
14:08:21 <startling> cool.
14:08:43 <Taneb> Getters are pretty muched rejigged functions
14:09:29 <startling> sure.
14:09:46 <`Jake`> Strange that the function for [Either a b] -> [b] is called rights but the function for [Maybe a] -> [a] is called catMaybes instead of justs...
14:09:54 <Taneb> You could probably make something more powerful than a getter, though
14:10:11 <Taneb> `Jake`, that is odd
14:11:13 <PTDub> Hey guys, I wanted to ask a question from a beginners perspective...
14:12:20 <Taneb> PTDub, fire away!
14:12:58 <PTDub> I just started to learn the basics of programming earlier this summer, and I want to start getting really specific with one language so that I can start writing useful applications. Why should I learn haskell over the imperative languages, and would haskell be harder for me to learn because I'm a beginner?
14:13:45 <Taneb> A lot of Haskell may be easier to learn as a beginner because you will have less to unlearn
14:14:00 <PTDub> haha okay, I never thought about it that way!
14:14:39 <Taneb> I'm not in a very good position to recommend you to learn one language over another as your first language, though
14:16:01 <`Jake`> PTDub: if you google for first language haskell you might find some discussions
14:16:19 <Jeanne-Kamikaze> is the "haskell is easier to learn as a beginner" based on some actual experience with test subjects, or is that some randomly formed opinionated guess?
14:16:31 <PTDub> Yeah, I understand there's a lot to consider. I like Ruby because its very approachable and has a good web framework. But I also like the concept of learning Haskell instead because from what I am hearing functional languages are superior in many ways, and Haskell has the Yesod framework.
14:16:49 <taylorgb> I'm not sure Haskell is precisely the best choice for a first language that you want to build desktop applications for
14:16:58 <Jeanne-Kamikaze> me neither
14:17:01 <taylorgb> Some back-end things, web and other stuff, then sure
14:17:09 <tac> Jeanne-Kamikaze: It's like any other language war issue. Totally opinion backed by enough intimidation to be taken as true.
14:17:14 <PTDub> I'm not thinking of building desktop apps, I want to build apps for the raspberry pi
14:17:43 <startling> Jeanne-Kamikaze: I think they mean "it's easier for a beginner to learn haskell then it is for a developer experienced with imperative languages", which I think is fair.
14:17:54 <PTDub> Jake: thanks
14:18:02 <Jeanne-Kamikaze> I'm not too sure about that either
14:18:04 <taylorgb> I don't really buy the unlearn argument either
14:18:20 <startling> OK.
14:18:38 <ipuustin> PTDub: Raspberry Pi is tricky, because the haskell packages there don't have ghci support
14:18:41 <taylorgb> Maybe it's true for intermediate level programmers, but if you're advanced level then you'll have encountered lots of the theory and practical side in other languages
14:18:44 <`Jake`> I started with imperative languages and I must admit that I've never had a problem with unlearning
14:18:45 <tac> taylorgb: I think there's in general less frustration with "why does something so easy in C become so difficult in Haskell"
14:19:08 <ipuustin> PTDub: meaning that many "core" packages just cannot be installed with cabal
14:19:37 <taylorgb> tac: I think it's all swings and roundabouts, as it always is
14:19:55 <taylorgb> Choose any language and there are things that are easy and things that are migraine-inducing
14:19:59 <tac> Right
14:20:08 <PTDub> <ipusstin> thanks for that input. From your experience, if I was going to choose a language based on the immediate application of writing programs for the pi, what would your recomendation be?
14:20:16 <tac> But if you already *know* something is easy, it's very hard to believe there's ever a good reason for a language to make it harder.
14:20:33 <tac> In Haskell, you have to be very disciplined about how you manage side effects. It's a good thing. But only on a large scale.
14:20:41 <taylorgb> I suppose C programmers get frustrated because when they write C they can at least string all the effects together and get something that does what they expected
14:20:44 <PTDub> <taylorgb> which language came easiest for you? What was your first language?
14:20:49 <tac> On a small scale (and you always teach on a small scale), it is frustrating no having destructive updates
14:21:00 <Jeanne-Kamikaze> yeah
14:21:07 <Jeanne-Kamikaze> PTDub, just learn C ^^
14:21:14 <ipuustin> PTDub: that I can't tell you :-) But they say that Python is the "native" dev language for RaspPi, and that's also maybe the easiest language to learn
14:21:16 <Jeanne-Kamikaze> indeed
14:21:16 <tac> but if you don't know how "easy" destructive updates area, then you just think it's the frustration of programming in general :)
14:21:21 <taylorgb> Nothing really came easy to me, but I started with basic, then moved onto C++
14:21:26 <Taneb> tac, I found Haskell made loads of sense when I was learning it. I found it a lot easier than, eg, Python
14:22:13 <Jeanne-Kamikaze> I only find python harder because of lack of types, but apparently people learning languages have no problem with that
14:22:51 <taylorgb> It was totally clear to me that Haskell is a language that is probably predictive of languages of the future
14:23:09 <PTDub> Taneb: what is your background? Meaning do you find math comes easily to you? Anything in specific which you think contributed to your acquisition of Haskell?
14:23:16 <Jeanne-Kamikaze> my python code is 20% code and 80% type comments
14:23:56 <Taneb> PTDub, maths is what I am good at but I am not very advanced, I guess.
14:24:00 <tac> taylorgb: It helps that it's a research language. Of course, it's going to be the first to try out the tools of the future.
14:24:03 <Peaker> hmm.. increased my QuickCheck test set size, and it's finding real issues, nice...
14:24:03 <taylorgb> I always think back to star trek when the dialogue would talk about doing some analysis by implementing some new algorithm, which will take just a few hours and you realise that such a thing certainly wouldn't happen in C++
14:24:35 <Peaker> and of course the errors have nothing to do with the properties being checked.. giving true credence to the saying "Try to prove *any* property of your code, and find the bugs!"
14:24:43 <Gracenotes> well, I'm more of the opinion that it will happen in C++
14:24:56 <Gracenotes> I have little faith in rules- or logic-based AI systems, tbh
14:25:00 <Gracenotes> anyway, off-topic, sorreh
14:25:10 <DanBurton> Haskell's whole raison d'etre is to be a playground for trying new things with languages
14:25:29 <CADD> DanBurton: precisely
14:25:31 <koala_man> Jeanne-Kamikaze: I think it's related to how the code is written. not having types is easier when code is simple, short, and written entirely by yourself with nothing but keyboard input and putStrLns
14:25:54 <PTDub> Thanks for your comments Taneb, Jeanne-Kamikaze, ipuustin, taylorgb
14:25:58 <koala_man> while it's a huge pain for more complex code involving multiple APIs and authors
14:26:13 <Jeanne-Kamikaze> I get dizzy past 100 lines of code
14:26:19 <CADD> DanBurton: some people actually complain that haskell is too "language-oriented" over being "community-oriented", i have no idea why these people are complaining.
14:26:32 <`Jake`> I wonder how he will decide.
14:26:51 <tac> CADD: because Cabal hell, et al.
14:27:19 <CADD> tac: true, but dep hell happens with any statically typed lang
14:27:42 <carter> CADD they have it in python too
14:27:42 <CADD> tac: haskell is just even worse, since its strongly typed and inferred
14:27:51 <carter> continuum analytics has a sat  solver to help their build tool :)
14:28:06 <CADD> carter: right they do, iirc they created pyenv to try to deal with it
14:29:35 <Jeanne-Kamikaze> In general though, I think learning haskell made me much better at every other language
14:30:26 <CADD> Jeanne-Kamikaze: I tend to agree, but haskell is definatly not the end of the road if you are interested in PLT.
14:30:50 <tac> CADD: it's still generally true of Haskell that the community doesn't prioritise those kinds of issues to the same degree as, say, Python or Ruby.
14:31:14 <CADD> Jeanne-Kamikaze: Jeanne-Kamikaze: take, forth for example. not as much to learn as haskell, still a bunch of mind bending concepts
14:31:17 <Jeanne-Kamikaze> like I don't know, in Java you're trained in the data encapsulation and destructive updates mindset, and modeling everything as an object and so on and it all looks like some bloody mess that you never really managed to understand
14:31:18 <CADD> tac: exactly
14:32:00 <Jeanne-Kamikaze> but then you learn haskell, and it's like ok, state patterns is just lack of closures, visitor is lack of first class functions, this isn't really a data structure, but a function applied to something else, etc.
14:32:07 <Peaker> if cabal dependencies were specified/updated on the web, collaboratively, outside of .cabal files, that could be much nicer
14:32:16 <Jeanne-Kamikaze> so you realise that of all that mess, half of it is just "lack of X"
14:32:36 <Jeanne-Kamikaze> and the language forces you to hack your way around the lack of X in weird ways
14:32:45 <Peaker> Jeanne-Kamikaze, Visitor is mainly lack of sum types
14:32:59 <Jeanne-Kamikaze> but it's the whole metaphor thing from paul graham
14:33:05 <Jeanne-Kamikaze> if you just learn java, then you can only think in terms of java
14:33:15 <Peaker> the main part of Visitor is the church encoding of a sum type, rather than the iteration
14:33:46 <Peaker> and is a useful trick even in languages that have sum types (e.g: "foldr" or "maybe" :-)
14:34:45 <josephle> Peaker: it was really cool when the sum type was defined as a visitor pattern when I learned System F :-)
14:35:02 * tac has no idea what a "visitor" pattern is
14:37:05 <Peaker> tac, you don't have closed sum types in languages like Java (it's actually aimed at pre-generics, too, I think). so you do something like (with all the class boilerplate of course):  Visitor = (A -> IO (), B -> IO (), C -> IO) ;  visitMyType :: MyType -> Visitor -> IO ()   and visitMyType can call the appropriate method, and the IO () can return arbitrary data, so it's an approximation of:  (A -> r) -> (B -> r) -> (C -> r) -> MyType -> r
14:37:07 <zzing> Can anyone direct me to the best page for explaining how the list monad works? I think I understood it once, but I haven't done haskell since September.
14:37:30 <josephle> t1 + t2 = forall a . (a -> t1) -> (a -> t2) -> a in System F
14:37:35 <Peaker> zzing, list monad is (:[]) and concatMap
14:37:51 <Peaker> josephle, your arrows are backwards
14:38:43 <zzing> Peaker, I was looking for something with a discussion on it. Monads always make my head go batty
14:38:47 <josephle> oops
14:38:47 <josephle> wait, are they?
14:38:48 <tac> > [1,2,3] >>= \x -> [x, 10 * x]
14:38:48 <lambdabot>   [1,10,2,20,3,30]
14:38:48 <josephle> oh wait
14:38:48 <josephle> yes
14:38:48 <josephle> t1 + t2 = forall a . (t1 -> a) -> (t2 -> a) -> a
14:38:52 <Peaker> josephle, it's because of exponentiation:  (t1^a) * (t2^a) = nothing useful...    (a^t1)*(a^t2) = a^(t1+t2)  that's why "t1+t2" appears in there
14:39:11 <Peaker> josephle, a->b = b^a
14:39:24 <josephle> *injection* functions define a sum (d'oh)
14:39:54 <josephle> Peaker: ah, that's right. I haven't done much exponents in a while.
14:40:05 <Peaker> zzing, values >>= computation      in list monad is basically like trying computation on each of the values, getting a list of results for each value, and flattening at all into a list of all "possibilities". list monad can be thought of as one trying out all possible values in all the lists involved
14:41:53 <Peaker> zzing, return x   is just "x" as a single possibility
14:42:19 <Peaker> > filterM (\x -> if odd x then [True] else [True,False]) [1..4]
14:42:20 <lambdabot>   [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
14:42:22 <`Jake`> do notation for list monads is just a list comprehension, if that helps
14:42:52 <FreeFull> zzing: The list monad is concatMap
14:43:05 <Peaker> zzing, for odd elements of 1..4, in the boolean predicate of filterM, we just do one possibility (put them in), and in even cases, we do both possibilities (put in, put out)
14:43:10 <FreeFull> For lists, (>>=) = flip concatMap
14:43:38 <pxqr> is it possible to add callback on GC?
14:43:54 <pxqr> after GC or before, no matter.
14:44:32 <FreeFull> I don't think the GC is in any direct way observable from within the program
14:44:36 <Peaker> pxqr, sort of, with Weak ptrs or ForeignPtrs
14:45:05 <Peaker> pxqr, http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
14:45:10 <pxqr> Peaker: yeah, but is it reliable?
14:46:06 <zzing> Peaker, the magical part I was trying to remember was if you had   x <- [1,2,3,4]; y <- [5,6,7,8]; return (x,y)    that it would do all of the combinations.
14:46:42 <Peaker> pxqr, No :)
14:47:05 <Peaker> zzing, it desugars to:   [1,2,3,4] >>= \x -> [5,6,7,8] >>= \y -> return (x,y)
14:47:30 <Peaker> zzing, and that is:  concatMap (\x -> concatMap (\y -> [x,y]) [5,6,7,8]) [1,2,3,4]
14:47:41 <Peaker> oops
14:47:46 <Peaker> zzing, and that is:  concatMap (\x -> concatMap (\y -> [(x,y)]) [5,6,7,8]) [1,2,3,4]
14:48:08 <Peaker> zzing, basically, every time you bind or have <- in a "do" block in list monad, you loop
14:48:30 <Peaker> zzing, over all the options (or 0 options to cut that branch entirely, list monad can also represent "failures")
14:48:52 <zzing> Peaker, which is taking 1 then running concatMap (\y -> [(1,y)]) [5,6,7,8]    in the first element?
14:49:07 <BrianHV> how would I write a parsec parser that can handle either \r\n or just plain \n?
14:49:25 <BrianHV> many1 (oneOf "\r\n") will capture too many
14:49:43 <pxqr> Peaker: does WeakPtr and ForeignPtr have different GC "pressure"?
14:49:59 <Peaker> zzing, x gets 1 then 2 then 3 then 4.  For each of those, the whole inner concatMap expr on the inner list runs
14:50:09 <Peaker> pxqr, what does that mean?
14:50:16 <augur> zzing: better to just try it and see!
14:50:22 <pxqr> I think ForeignPtr should be sufficient for my purpose.
14:50:28 <augur> > do x <- [1,2,3,4] ; y <- [5,6,7,8] ; return (x,y)
14:50:29 <lambdabot>   [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4...
14:50:35 <Peaker> BrianHV, string "\r\n" <|> char '\n' ?
14:51:00 <zzing> When I get back from my meeting, I should do a bit of work to build up my foo again. Applicative and Monads await.
14:51:10 <Peaker> zzing, :-)
14:51:11 <pxqr> Peaker: It means "does WeakPtr will be GCed as soon as ForeignPtr or not".
14:51:29 <Peaker> pxqr, I don't know
14:51:37 <zzing> Does there exist a super awesome site that explains it in detail with exercises?
14:51:45 <zzing> (both concepts ideally)
14:51:53 <BrianHV> Peaker: that could do it. I also found the "optional" combinator. one of those should work. thanks!
14:53:28 <Peaker> zzing, LYAH maybe?
14:53:33 <Peaker> not sure about exercises
14:54:01 <zzing> I can take a look at it.  It does try to be fun.
14:54:03 <quchen> BrianHV: On a side note, certain IO functions convert \r\n to \n automatically, e.g. openFile. (It's of course a good idea to have a robust parser anyway.)
14:54:45 <BrianHV> quchen: good to know. right now I'm just using getContents to read from stdin.
14:55:57 <quchen> BrianHV: Look through the docs of System.IO a little in case you run into trouble. There is this thing called binary mode, which will handle files literally, and uhmmm... non-binary mode, which will do some silent conversions based on what OS you're running your program on.
14:56:34 <quchen> The reasoning behind this is that it's desirable to have everything normalized to \n internally, while the output functions can worry about replacing \n with whatever the OS or silly OS requires.
14:56:46 <resttime> hello I'd like to know if/how I can get the behavior I want with monads here: http://pastebin.com/L2UvLhsh
14:56:52 <mauke> The paste L2UvLhsh has been copied to http://lpaste.net/91188
14:57:16 <quchen> The downside is that reading Windows files on Unix is awkward and you should probably open them in binary mode and parse them with an every-case-covered parser.
14:57:38 <quchen> resttime: Have a look at mapM.
14:57:40 <quchen> :t mapM
14:57:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:58:38 <hpaste> haasn annotated “RPN calculator with pretty errors” with “RPN calculator with pretty errors (working)” at http://lpaste.net/91167#a91189
15:00:06 <resttime> quchen: thanks, is it possible to set a conditional to stop running when I get type "Nothing" ?
15:01:13 <quchen> `fmap (takeWhile isJust)` will do that for you.
15:01:57 <quchen> I wish dmwit was here to see this excellent use case of non-smelly isJust ;-P
15:04:08 <m3ga> quchen: in hspec unit tests i often have checks like :   something `shouldBe` isJust
15:08:02 <resttime> quchen: getSearchPages3 query = (takeWhile isJust) <$> mapM (getSearchPage query) [1..] seems to go infinite
15:08:18 <resttime> seems kind of odd since that doesn't seem lazy
15:10:56 <lispy> ICFP has some amazing papers this year
15:11:08 <lispy> I just finished skimming the closed type families paper
15:11:10 <lispy> great stuff
15:11:28 <djahandarie> lispy, anything else you think looks particularly nice?
15:11:37 <djahandarie> I thought the FRP papers were pretty interesting. Nice to see that surging again.
15:11:49 <lispy> djahandarie: the generalization of stream fusion to SIMD is great
15:11:57 <djahandarie> Ah, yes.
15:12:22 <lispy> Those are the only two papers I've looked at so far, but just those two are enough to make me say it :)
15:12:31 <djahandarie> Hehe.
15:13:32 <lispy> I'll have to look at the FRP stuff. I finally wrote a few programs using FRP and was not that impressed
15:13:49 <lispy> I used reactive-banana (ran into performance issues) and yampa
15:13:52 <djahandarie> I didn't look at the SIMD one in detail. How different is it from the "Haskell beats C" version that was released awhile ago?
15:14:10 <lispy> djahandarie: the new title is more honest
15:14:16 <lispy> I don't know how the content varies
15:14:34 <quchen> resttime: That's odd. `takeWhile isJust <$> (return $ cycle [Just 1])` prints like mad.
15:14:38 <djahandarie> I think the old title was just there to get people to read it :P
15:14:44 * djahandarie wonders if spj was behind that
15:14:46 <quchen> (If entered in GHCi)
15:14:48 <lispy> The problem with the old title is that, as the authors point out C is a strawman here, and it's not that it beat the whole language.
15:14:55 <Peaker> lispy, did you see the (very old) demos by conal: http://conal.net/fran/tutorial.htm ?
15:15:03 <lispy> Peaker: years ago
15:15:26 <lispy> Peaker: I was trying to write sometihng where I wanted to observe state and change the future based on it
15:15:29 <lispy> FRP is not so good at that
15:16:16 <lispy> I did get it working with AFRP
15:16:23 <lispy> delayed switching, etc
15:16:56 <resttime> quchen: I guess I might have to look for another solution
15:16:57 <quchen> resttime: And if you add a Nothing to the list it terminates,
15:16:58 <quchen> takeWhile isJust <$> ((return $ replicate 100 (Just 1) ++ [Nothing]) :: IO [Maybe Int])
15:17:11 <quchen> Are you sure your getSearchPage results in Nothing at some point?
15:17:49 <resttime> yup
15:18:03 <resttime> 2, _page = "2"}),Nothing,Nothing] is when [1..4]
15:18:30 <resttime> i'm parsing JSON off the web
15:18:48 <quchen> Could you post a minimal (non-) working example?
15:18:57 <quchen> i.e. compiles but does the wrong thing
15:19:05 <Peaker> lispy, changing the future based on observations is exactly what that tutorial shows, isn't it?
15:22:08 <resttime> this should be it http://lpaste.net/91188
15:24:26 <quchen> And what does it do if you add the fmap?
15:24:40 <quchen> resttime: ^
15:24:47 <resttime> just runs forever
15:25:43 <quchen> Try modifying `getSearchPage query` to `print "foobar" >> getSearchPage query`
15:25:54 <quchen> Does it print infinite foobars, or does it halt at some point?
15:26:08 <quchen> Eh, that code is rubbish, make that
15:26:18 <quchen> \n -> print n >> getSearchPage query n
15:27:57 <resttime> keeps going
15:28:10 <resttime> 1 2 3 4 etc
15:28:52 <quchen> Could you add a main function I can reproduce this with?
15:30:17 <danbst> Hello! Any Cabal\GCC\Win32 hackers here? Got trouble while installing `ls-usb` package http://lpaste.net/91190 . Maybe someone can point to the root of the problem?
15:31:22 <resttime> should be it http://lpaste.net/edit/91188
15:32:01 <resttime> forgot title : http://lpaste.net/91188
15:33:05 <jfischoff> is there a way to prevent cabal from downloading anyting during a cabal install?
15:33:13 <jfischoff> I would rather it fail ...
15:34:07 <dcoutts> jfischoff: no, that's a missing feature. You can cabal fetch first, or remove that repo from the config.
15:34:48 <quchen> resttime: That does indeed not stop on Nothings. Time to put on my thinking cap.
15:35:11 <jfischoff> dcoutts: if possible to set the repos from the command line, so as to disable them if they are set in the config?
15:35:48 <dcoutts> jfischoff: I think only possible to add more, but you can also tell it to use an alternative config from the command line, so the answer is really yes
15:36:10 <jfischoff> dcoutts: ah that works thanks
15:36:30 <dcoutts> jfischoff: I guess one reason it's not been implemented is because there's a slight subtlety: should the solver try to avoid picking source packages that have not been downloaded (a bit tricky and perhaps confusing) or should it do the solving irrespective of the downloaded status and then just fail if it needs one that has not been downloaded
15:37:35 <jfischoff> dcoutts: for my purposes fail is fine.
15:37:35 <jfischoff> err failing
15:37:36 <dcoutts> jfischoff: sure, just saying why it's not been implemented, there are other use cases
15:37:45 * jfischoff nods
15:38:51 <dcoutts> jfischoff: with the new sandboxing, there's another option: don't install any source packages that are not already explicitly added to the sandbox
15:39:05 <dcoutts> which might be more useful
15:39:52 <quchen> resttime: I guess IO isn't as lazy as I had thought. Not a very satisfying answer for you I'm afraid :-\
15:42:22 <resttime> quchen: that's okay thanks for the help especially with mapM, the good news is that max pages is always supplied so I can get the first page mapM and then map up to that
15:42:48 <quchen> Sounds like a good workaround at least.
15:43:02 <quchen> I'm still confused about why the take version doesn't work though.
15:43:05 <resttime> quchen: that's what I spent the most time on but I guess I'm a little disheartened that lazy isn't there
15:43:21 <jfischoff> dcoutts: back. wait how do I do that with sandboxing?
15:44:24 <dcoutts> jfischoff: sorry, I mean it's another plausible way to implement a feature like that, it does not exist
15:44:33 <resttime> quchen: thanks again for the help
15:44:35 <jfischoff> ah
15:44:44 <quchen> resttime: Sorry for the lack of insight :-\
15:44:49 <jfischoff> yeah that would be nice for sandboxing
15:45:11 <dcoutts> jfischoff: can you explain the use case in a little more detail?
15:45:55 <jfischoff> dcoutts: I want to ensure that all programmers have the same thirdparty code and have the sources checked into our repository
15:46:38 <dcoutts> jfischoff: ok, and so the no download is a safety feature of sorts
15:46:45 <dcoutts> to remove other things from the environment
15:46:51 <jfischoff> dcoutts: yeah
15:46:59 <dcoutts> but actually the best solution is really to remove the other things from the environment
15:47:10 <jfischoff> what do you mean?
15:47:25 <dcoutts> jfischoff: ie not build it in the presence of hackage
15:47:35 <dcoutts> but with your own specific set of sources
15:48:03 <quchen> resttime: I'm guessing it's because IO is evaluated in order, so the `return (x:xs)` in sequence's source isn't reached before the whole list has been (recursively) sequenced
15:48:26 <dcoutts> jfischoff: which could all be local dirs in the sandbox, or could be a private hackage archive (either local files or local http)
15:48:48 <dcoutts> jfischoff: cabal already supports local hackage archives btw
15:49:00 <quchen> The result may be known already and could probably be determined by the compiler, but IO guarantees that all actions are evaluated one after another, so that the side effects are always performed
15:49:14 <quchen> That's just a guess though
15:49:39 <jfischoff> dcoutts: when you say local hackage archives you mean file local correct?
15:49:46 <dcoutts> jfischoff: yes or http
15:50:36 <dcoutts> jfischoff: so the thing I'm not sure of is if the sandbox config file allows to override the repos set in ~/.cabal/config, I'd have to check
15:50:54 <quchen> resttime: Anyway, you can always go with an explicitly recursive version. Not as idiomatic maybe, but sometimes it's easier to bend the rules a little :-)
15:51:08 <jfischoff> dcoutts: I'm looking at it. I think it does.
15:51:10 <dcoutts> jfischoff: ideally it would allow that, and then you could just check in the local config file into the source repo
15:51:12 <resttime> quchen: that makes sense, I'll remember that if I mix IO with mapM again, for now I'll be playing with the newly discovered mapM
15:52:58 <jfischoff> dcoutts: so check in the sources to the local hackage archive, and use the sandboxing for multiple first source packages?
15:53:12 <jfischoff> err first party source packages
15:54:28 <jfischoff> err I mean add-source
15:57:31 <dcoutts> jfischoff: sorry terminology confusion. There's two options really: one is to put the sources directly into the sandbox as local unpacked dirs (sandbox approach). The other is to use a local hackage archive. A hackage archive contains tarballs and an index. They can be accessed via local filesystem or http (as we do for the central community one).
15:57:55 * hackagebot haste-compiler 0.2.2 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.2 (AntonEkblad)
15:57:57 * hackagebot cassandra-cql 0.3.0.1 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.3.0.1 (StephenBlackheath)
15:58:06 <jfischoff> well three I guess because the sandbox has its own local package index right?
15:58:37 <jfischoff> or is that the package folder you were referring to (the sandbox packages folder)?
15:58:57 <jfischoff> and what goes in there, sdists?
15:59:05 <dcoutts> jfischoff: the sandbox uses the same mechanism for its local package index (a tarball).
15:59:20 <dcoutts> jfischoff: actually, you're right of course, you can add tarballs to a sandbox, not just unpacked dirs
15:59:40 <dcoutts> (at least I think you can)
15:59:50 <jfischoff> I hope so :)
16:00:22 <jfischoff> I've never done this, is it one big tar ball or the sdists that you upload to hackage?
16:00:32 <dcoutts> jfischoff: sdists
16:00:38 <jfischoff> great
16:01:06 <jfischoff> okay cool I think I have everything I need now.
16:01:31 <dcoutts> jfischoff: let us know how you get on, I don't think this aspect has been tested much yet :-)
16:02:15 <Rarrikins> > take 10 (let fibs = 55 : 55 : zipWith (+) fibs (tail fibs) in fix$(<$>)<$>(:)<*>((<$>((:[{- fib-fib-fibs! -}])<$>))(=<<)<$>(*)<$>(*2))$1)
16:02:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
16:02:17 <dcoutts> jfischoff: but certainly the local config file stuff is supposed to help with this kind of situation where you want to tie down the environment, and share that between multiple devs by checking it into the source control
16:03:07 <dmwit> Rarrikins: If you're curious, I have a StackOverflow post explaining (a slight variant of) that code.
16:03:27 <Rarrikins> dmwit: Sure :)
16:04:27 <dmwit> http://stackoverflow.com/a/12660526/791604
16:04:35 <Rarrikins> Thanks
16:07:31 <jfischoff> dcoutts: one issue with checking in the cabal.sandbox.config is the paths are absolute, which makes it harder to share between devs :(
16:07:56 <dcoutts> jfischoff: hmm
16:08:36 <dcoutts> jfischoff: yeah, no idea if relative paths there will be interpreted as relative to the top of the sandbox (useful) or to the current dir (useless)
16:08:46 <dcoutts> jfischoff: try it, and if it's not the useful one, file a ticket
16:08:57 * jfischoff nods
16:20:02 <enthropy> can Writer be lazy enough for this application: http://lpaste.net/91191
16:26:37 <Saizan> enthropy: make the pattern on line 6 irrefutable
16:26:48 <Saizan> enthropy: i.e. "~(_, All w) <- listen xs"
16:28:14 <Saizan> enthropy: though the if is strict on the w anyway, so i'm not sure how much that helps
16:28:44 <enthropy> Saizan: yeah that doesn't make it work
16:31:06 <dpwright> I have a couple of questions regarding the State Monad
16:32:05 <Saizan> for a foldr to work on an infinite lists the step function needs to be non-strict on the second argument
16:32:18 <dpwright> First is: is there such a thing as a "read-only" state monad, and does that even make sense?  I have a load of functions that pass state around as parameters at the moment, and seeing that scattered all over the place made me think "maybe this would be neater if I put that state into the State monad and made passing it implicit"
16:32:31 <elliott> Reader
16:32:38 <dpwright> but none (or very few) of these functions actually need to modify that state
16:32:39 <elliott> (it's just a function)
16:33:19 <dpwright> elliott: Thank you! good point, I've never used anything but State and IO monads, so... when all you have is a hammer, etc
16:33:36 <dpwright> I'll take a look at Reader before deciding whether my second question is even relevant
16:33:40 <elliott> you can also think of Writer as "write-only" state :)
16:34:02 <joelteon> you can think of RWS as a reader-writer-state
16:37:22 <dpwright> hmm, not sure I follow that last bit -- if Reader is like RO state and Writer is like "write-only", then if you were to combine them wouldn't you get just State?  In which case wouldn't reader-writer-state be equivalent to state-state? (I am sure the answer's "no", I have no idea what RWS actually is...)
16:37:30 <tabemann> no
16:37:44 <twanvl> RWS has three parameters, r, w and s
16:37:56 <tabemann> because Writer operates on monoids, using mempty for the initial state, and mappend for further states
16:38:12 <sipa> and reader is actually "scoped modifiable"
16:38:14 <shachaf> dpwright: I'd recommend not worrying about RWS.
16:38:39 <pentace> When would you use RWS instead of State?
16:38:47 <shachaf> Reader is actually just a function.
16:39:42 <jfischoff> shachaf: hey a function is a lot
16:40:45 <enthropy> Saizan: this one works http://lpaste.net/91192, no Writer used though
16:43:58 <dpwright> thanks all -- Reader fits what I want to do perfectly
16:44:17 <shachaf> dpwright: Note that Reader is really just (->).
16:45:00 <shachaf> > let foo :: a -> Int -> [a]; foo x = do { n <- ask; return (replicate n x) } in foo 'a' 5
16:45:01 <lambdabot>   "aaaaa"
16:46:15 <dpwright> shachaf: That's interesting!
16:47:00 <dpwright> there's a lot of mystery in that for me
16:47:31 <ChongLi> trying to walk my friend through installing dependencies for helm on windows :(
16:47:44 <dpwright> but in that case, it does seem appropriate then
16:48:07 <dpwright> I'm essentially trying to tidy up the same thing being passed as the first parameter to all these functions
16:48:32 <dpwright> so an equivalent to (->) sounds like what I'd be looking for
16:49:12 <ChongLi> is anyone working on the windows external dependencies situation?
16:49:20 <dpwright> (whether having it in a monad rather than just as an explicit function parameter like that is any "tidier" is a point of style I don't think I'm really qualified to judge yet... but that's another matter)
16:49:54 <shachaf> dpwright: The point is that "(r ->)" *is* a monad, in the same way that "Reader r" is.
16:50:10 <shachaf> Just a different type that means the same thing.
16:50:25 <shachaf> I'm not saying you shouldn't use the name Reader.
16:51:01 <dpwright> shachaf: Ahhh!
16:54:55 <b2coutts> how can I force ghc to clean up .o and .hi files after compiling?
16:56:48 <c_wraith> one version of GHC would delete them (and your .hs files) if you had a compilation error.  That was...  hardcore mode?
16:56:58 <b2coutts> ha
16:57:07 <b2coutts> rm -rf /* if there's a compilation error
16:57:34 <dmwit> Suicide Linux replaces the shells with ones that do that on shell syntax errors.
16:57:54 <b2coutts> haha yeah I've heard of that
16:58:00 <dmwit> anyway
16:58:06 <dmwit> Don't know a way to do what you asked.
16:58:31 <b2coutts> I'm making a Makefile anyway; would the reasonable approach be to just rm *.o *.hi after compilation?
16:59:00 <dmwit> That seems plausible. Why are you doing this?
16:59:13 <dpwright> I don't know how to do that, but I use -odir and -hdir to specify a working directory, which makes clearing them up easier, if that helps
16:59:15 <b2coutts> I just don't like having the directory polluted by a bunch of useless files
16:59:34 <twanvl_> if you use cabal, those files go into a separate directory
16:59:57 <jevankovich> They're not that useless. If a file doesn't need to be recompiled ghc will use the existing *.o to link
17:00:05 <b2coutts> I guess
17:00:15 <b2coutts> compilation time for my program is negligible, though
17:00:51 <jonkri> In what order are functions evaluated? For example, in "1:2:3:[]", "Haskell" seems to know to apply 3:[] first, before for example 1:2. Why is this?
17:00:56 <b2coutts> how can I get cabal to handle those files for me? right now I'm just using `ghc main.sh`
17:01:11 <Rarrikins> jonkri: In the order that the results are required.
17:01:31 <jonkri> I would have expected 1:2 to evaluate first, like left to right.
17:01:50 <enthropy> jonkri: you're wondering why it means   1:(2:(3:[])), not with the parentheses the other way?
17:01:55 <Rarrikins> jonkri: It depends on what is required. You can get it to evaluate that way by, for instance, printing the head.
17:02:25 <b2coutts> jonkri: afaik : has this behaviour because the haskell devs figured it would be more useful that way
17:02:32 <jevankovich> jonkri: I think that the order that "1:2:3:[]" is evaluated is determined by the type of (:) and if it is defined as infixl or infixr
17:02:34 <elliott> jonkri: I don't know what you mean.
17:02:52 <elliott> what leads you to state the observation you gave?
17:02:52 <b2coutts> priority can vary between infix operators
17:03:22 <jevankovich> It can't evaluate 1:2 first because 2 isn't a list. It has to evaluate 3:[] first for it to type check.
17:03:42 <SLi> Hmm, there's no function in Data.Tree to list (only) the leaves of the tree?
17:03:53 <b2coutts> I don't think it's a matter of typechecking
17:03:56 <b2coutts> > []:3
17:03:57 <lambdabot>   No instance for (GHC.Show.Show a0)
17:03:57 <lambdabot>    arising from a use of `M694120727.sho...
17:04:07 <b2coutts> it's just left-associative
17:04:28 <enthropy> b2coutts: other people say right-associative for the same thing :)
17:04:32 <b2coutts> wait that example didn't make sense
17:04:49 <b2coutts> enthropy: yeah, after I typed it I wasn't sure if I actually said the right one or now
17:04:49 <enthropy> > foldr f [a,b,c]
17:04:49 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr
17:04:49 <b2coutts> not*
17:04:49 <lambdabot>                      [D...
17:04:52 <b2coutts> I figured I had a 50-50 shot :P
17:05:00 <enthropy> > foldr (f::Expr -> Expr) [a,b,c] :: Expr
17:05:00 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
17:05:01 <lambdabot>              w...
17:05:05 <enthropy> > foldr (f::Expr -> Expr) x [a,b,c] :: Expr
17:05:06 <lambdabot>   Couldn't match type `Debug.SimpleReflect.Expr.Expr'
17:05:06 <lambdabot>                with `De...
17:05:15 <enthropy> > foldr f x [a,b,c] :: Expr
17:05:16 <lambdabot>   f a (f b (f c x))
17:05:25 <enthropy> > foldl f x [a,b,c] :: Expr
17:05:26 <lambdabot>   f (f (f x a) b) c
17:05:30 <jevankovich> Though its associative-ness was chosen so that you could write 1:2:3:[] without having to add parentheses and the type-checker would be happy
17:07:02 <Saizan> enthropy: well, you've changed most of the logic in filterAcutesN, Writer has little to do with it
17:10:37 <enthropy> Saizan: it's supposed to be the same logic, but I guess foldr is the wrong approach for applying a function to something an indefinite number of times (for reasons you pointed out)
17:12:24 <enthropy> or the original value has to be supplied as a 4th argument to foldr
17:13:11 <Saizan> enthropy: in that way, yes. with iterate you're iterating from the seed and growing it as you proceed building the list
17:14:19 <Saizan> enthropy: your foldr was trying to put the seed at the end of an infinite list, and that's not going to be very useful unless your iteration function can stop without looking at its argument somewhere along the way
17:28:59 <hpaste> znaimon pasted “CentOS / pgconfig error” at http://lpaste.net/91193
17:29:37 <znaimon> If anyone has a moment, a little insight into what's going on with cabal on my CentOS instance would be fantastic.
17:30:24 <shachaf> znaimon: Looks like you're using an old version of base or something? I don't know what you're using.
17:30:24 <geekosaur> do you have postgres installed?
17:30:37 <shachaf> By the way --prefix=$HOME sounds like a sort of bad idea.
17:30:46 <shachaf> Generally cabal things go in ~/.cabal.
17:30:56 <znaimon> geekosaur, yes, postgres-9.1, all libs, devel, server, etc
17:31:02 <shachaf> (By default. And you might be best off stickin with that.)
17:31:16 <geekosaur> hm. pgconfig should be in the devel package
17:31:40 <znaimon> do I have to restart the postgres service
17:31:40 <znaimon> ?
17:31:40 <shachaf> I would run with -v3 or strace or something to figure out what's going on.
17:32:33 * geekosaur attempts to find out what postgres is on centos6, it's not entirely unheard of for it to be too old to be useful
17:32:46 <znaimon> 9.1 is a pretty recent version afaik
17:33:57 <shachaf> You still haven't mentioned what version of base you're using. :-)
17:34:16 <shachaf> Fixing the first error always seems like a good idea to me.
17:34:17 <znaimon> shachaf: where would I find that out?
17:34:28 <shachaf> I don't know how Fedora does it.
17:34:31 <shachaf> You could try ghc-pkg list base
17:34:41 <shachaf> Or saying what version of GHC you have would work too.
17:34:43 <znaimon> 4.3.1.0
17:35:13 <shachaf> OK.
17:35:21 * shachaf wonders what version of GHC that maps to.
17:35:32 <ReinH> oh hai
17:35:33 <shachaf> Anyway, you might need a newer one to fix the first error. I don't know.
17:35:50 <shachaf> Do you have a pgconfig at all?
17:36:02 <znaimon> yes, I've configured it
17:36:25 <shachaf> I mean: Do you have a program called "pgconfig" at all?
17:36:29 <geekosaur> that's not what pgconfig is
17:36:50 <geekosaur> pgconfig reports locations of development headers and libraries for use by programs that want to link against it
17:37:29 <znaimon> then I'm not sure I have that
17:37:42 <znaimon> I've search it, but all I find is pg_config for python
17:39:19 <geekosaur> well.\
17:39:37 <geekosaur> pg_config turns out to actually be it. gg rhel for renaming it...
17:39:50 <geekosaur> http://rpmfind.net//linux/RPM/centos/6.4/i386/Packages/postgresql-devel-8.4.13-1.el6_3.i686.html
17:40:13 <geekosaur> (handy way to check contents of various rpm-based distributions' packages)
17:40:21 <znaimon> so I need to downgrade to postgresql 8.4.13?
17:40:26 <znaimon> :/
17:40:52 <geekosaur> hm, where did you install yours from? this is the one in the centos 6.4 distribution
17:41:06 <geekosaur> (which means it's the one from rhel6)
17:41:19 <znaimon> yeah, i had originally installed 8.4.13
17:41:20 <geekosaur> (I did say they tend to be out of date)
17:41:42 <znaimon> but then I noticed that  a later version was available for RHEL6/centos 6
17:41:59 <znaimon> 9.1 -- the difference seemed enough that it might be worth an upgrade, so that's what I did.
17:41:59 <geekosaur> in any case, it looks like pgconfig is called pg_config on rhel/centos for some reason. this may require some hackery in the cabal package to deal with
17:42:11 <bitonic> is there an accepted generic “containers” class? <http://hackage.haskell.org/packages/archive/keys/3.0.3/doc/html/Data-Key.html> solves part of the problem
17:42:20 <znaimon> i mean, probably just have to find it in the package and then ln it
17:42:54 <geekosaur> it's very likely that /usr/bin/pg_config is what you want, then
17:43:17 <heatsink> bitonic, what container class features do you have in mind?
17:43:18 <geekosaur> you can check with: rpm -qf /usr/bin/pg_config, it should be from postgresql-devel
17:43:31 <heatsink> There's Functor, Applicative, Monad, Traversable, and Foldable
17:43:45 <bitonic> heatsink: lookup, insert, membership, toList/fromList, etc.
17:43:49 <bitonic> Data.Map basically
17:43:56 <znaimon> geekosaur: just searched /usr/bin
17:44:00 <znaimon> no such pg_config file
17:44:11 <zRecursive> :hoogle Data.Map
17:44:21 <heatsink> I don't know of any class generalization of Data.Map.
17:44:35 <orzo> If i use a string as a stack, consing on the front and tailing off it, will laziness cause a thunk-build-up problem?
17:44:43 <orzo> sorry, a list as a stack
17:44:50 <znaimon> geekosaur: Wait!  Found It!
17:45:00 <dmwit> orzo: insufficient data for meaningful answer
17:45:03 <znaimon> where am I linking to/what file name?
17:45:21 <geekosaur> well, cabal is looking for a program named pgconfig
17:45:46 <dcoutts_> geekosaur: it'll be custom code in the Setup.hs
17:45:53 <dcoutts_> you can modify that to look for either name
17:45:56 <BMeph> bitonic: Be a haskell Hero, and Make one! :)
17:46:04 <dcoutts_> geekosaur: and send the maintainers the patch
17:46:30 * geekosaur is not the one installing it, just using one of his local centos vms to try to help someone else untangle it
17:47:22 <znaimon> dcoutts_: but where is Setup.hs currently looking?
17:47:44 <dcoutts_> znaimon: probably on the path
17:47:53 <dcoutts_> look at the Setup.hs and see
17:48:40 <znaimon> dcoutts_: when there are only two lines in the Setup.hs I'm looking at
17:49:02 <dcoutts_> what package are we talking about?
17:49:41 <znaimon> dcoutts_: well, I was following these directions: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Build_your_project
17:49:58 <znaimon> dcoutts_: I just ran that first cabal install command
17:50:09 <znaimon> and I'm in the same directory as the Setup.hs I'm looking at right now
17:50:11 <bitonic> BMeph: eh.  we already have “keys”, it really wouldn’t take much.  maybe I will
17:50:21 <bitonic> but I’m surprised it’t not there somewhere already
17:50:35 <dcoutts_> znaimon: but presumably you're talking about another package, something to do with postgres right?
17:50:50 <znaimon> yes, I'm trying to install my own instance of hpaste/lpaste
17:52:04 <dcoutts_> znaimon: ah, it's postgresql-libpq that was failing, ok
17:53:19 <znaimon> dcoutts_: sorry, how would I remedy that?
17:54:00 <dcoutts_> znaimon: ok, so it does already look for either pgconfig or pg_config
17:54:23 <dcoutts_> znaimon: cabal unpack postgresql-libpq, and then look at postgresql-libpq-0.8.2.3/Setup.hs
17:54:59 <dcoutts_> you'll see that the definition of pgconfigProgram makes it look for either "pgconfig" or "pg_config"
17:55:08 <dcoutts_> and it's looking on the $PATH
17:55:42 <dcoutts_> so you should make sure you have the postgres system package that includes the dev libs and the pgconfig/pg_config program
17:56:52 <hpaste> znaimon pasted “postgresql Setup.hs” at http://lpaste.net/91194
17:57:04 <znaimon> dcoutts_: it has the lines for both it would seem :/
17:57:24 <dcoutts_> yes, that's what I was looking at
17:58:10 <znaimon> dcoutts_: so, I have pg_config and the entire postgresql devel package
17:58:21 <dcoutts_> ok, try it, should work
17:58:31 <znaimon> i had it before, and it didn't work
17:58:39 <znaimon> should I be changing something in setup.hs here?
17:58:49 <dcoutts_> what is the error now then, got the log?
17:59:06 <dcoutts_> if you cabal install postgresql-libpq
17:59:36 <dcoutts_> znaimon: and pg_config is definately on the path right?
17:59:54 <dcoutts_> you can run it normally from the commandline
18:01:22 <dcoutts_> znaimon: or for more detail: cd postgresql-libpq-0.8.2.3; runghc Setup.hs configure -v3
18:02:08 <dcoutts_> erm, runghc Setup.hs configure -v3 --user
18:02:23 <hpaste> dcoutts_ pasted “postgresql Setup.hs” at http://lpaste.net/91195
18:04:43 <dcoutts_> znaimon: are you quite sure it's on the path?
18:04:51 <znaimon> path is $HOME
18:04:57 <znaimon> which is ~/ amirite?
18:04:59 <dcoutts_> see in the log there, it's definitely looking, but not finding it
18:05:11 <dcoutts_> znaimon: I mean the $PATH env var
18:05:28 <znaimon> anyway I can check what that is?
18:05:39 <geekosaur> znaimon: at a shell prompt, enter: type pg_config
18:05:41 <dcoutts_> znaimon: what happens if you run pg_config
18:05:42 <dmwit> I don't believe that your path is $HOME.
18:05:49 <dcoutts_> znaimon: or pgconfig
18:05:55 <dmwit> Can you try "echo $PATH" to double-check?
18:06:13 * ski_ . o O ( `printenv PATH' )
18:06:13 <geekosaur> (this asks the shell what type of thing it is, including doing a path search for it if it's not a builtin etc.)
18:06:17 <znaimon> returns /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/.cabal/bin:/root/bin
18:08:13 <geekosaur> um. you've been doing cabal installs as root?
18:08:28 <c_wraith> well that's a great way to break everything
18:08:32 <geekosaur> bad plan; the packages are not installed globally, they're installed in root's private packages where nothing can find them
18:08:49 <znaimon> geekosaur: if this was my server/configuration, I wouldn't be in root
18:09:17 <znaimon> rather, someone else wants me to compile/install this app and explicitly told me to just use root
18:09:36 <geekosaur> I wonder if they know whatt they were asking
18:09:36 <znaimon> would you recommend starting over on a regular user?
18:10:05 <znaimon> and probably not
18:10:08 <geekosaur> I suspect they want it installed globally. which means (a) root, AND (b) cabal install --global. And is a bad idea for a number of reasons
18:10:55 <dcoutts_> znaimon: it's possible to do "--global" installs as root, not necessarily recommended. But that does make it available to all users.
18:11:14 <znaimon> dcoutts_: this VPS instance is only going to be used for this one compile and running this one app
18:11:40 <dcoutts_> znaimon: usually easier to do it as the user that will be using/running it
18:11:52 <znaimon> dcoutts_: there is only the root user on this VPS
18:12:05 <znaimon> so I guess root will be using/running it (?)
18:12:17 <dcoutts_> znaimon: btw, where did you get with "type pgconfig" or "type pg_config"
18:13:22 <znaimon> want me to paste the result, dcoutts_?
18:13:30 <dcoutts_> sure
18:13:43 <hpaste> dcoutts_ pasted “pg_config return” at http://lpaste.net/91196
18:13:45 <dcoutts_> znaimon: we're guessing that it's actually not on the $PATH
18:14:07 <znaimon> dcoutts_: yeah, it's not $PATH, but given what $path returned, I'm not sure what $PATH is either
18:14:27 <dcoutts_> znaimon: so cabal will not find it unless it is on the $PATH
18:14:45 <znaimon> it's a whole bunch of paths separated by colons
18:14:49 <znaimon> which one is it, dcoutts_?
18:15:08 <dcoutts_> where is pg_config exactly?
18:15:14 <geekosaur> $path is not necessarily the same thing as $PATH. (in zsh it's the same thing in a different format. in bash it's meaningless)
18:15:21 <dcoutts_> easiest thing to do is temporarily alter the $PATH while doing the build
18:15:23 <znaimon> geekosaur: I meant capitalised
18:15:28 <znaimon> hmmmm
18:16:05 <znaimon> dcoutts_: it's in /usr/pgsql-9.1/bin
18:16:18 <dcoutts_> znaimon: for reference, the $PATH is the list of directories where programs are found (or rather where by default they are looked for)
18:16:18 <znaimon> but I can make a hardlink to it wherever
18:16:28 <znaimon> dcoutts_: so any one of those locations should work?
18:16:32 <dcoutts_> znaimon: this is a general unix thing, not haskell/cabal specific
18:16:50 <dcoutts_> znaimon: easier is to just change the $PATH during the build, it's just an environment variable
18:16:55 <dcoutts_> e.g. in your shell:
18:17:03 <dcoutts_> export PATH=$PATH:/usr/pgsql-9.1/bin
18:17:14 <dcoutts_> that's just local to that shell, and temporary
18:17:16 <Clint> no need for the export
18:18:23 <znaimon> so if I was running cabal install, it would be cabal install --PATH=$PATH:/user/pgsql-9.1/bin ?
18:18:41 <geekosaur> znaimon, no
18:18:44 <dcoutts_> znaimon: the $PATH is a unix environment variable
18:18:51 <znaimon> so I change it first?
18:18:53 <dcoutts_> znaimon: the shell lets you alter env vars
18:18:56 <geekosaur> just type at a shell prompt: export PATH=$PATH:/usr/pgsql-9.1/bin
18:19:12 <dcoutts_> you can check the value of any env var like: echo $PATH
18:19:26 <Clint> you can also leave out the "export " since it's unnecessary
18:19:30 <znaimon> dcoutts_: down to one error now
18:19:43 <znaimon> postgresql-libpq-0.8.2.3 failed during the configure step
18:19:57 <znaimon> wait, hold up
18:20:08 <geekosaur> that's just the summary, the actual error should be above it
18:20:08 <znaimon> setup: Missing dependency on a foreign library:
18:20:09 <znaimon> * Missing C library: pq
18:20:33 <shachaf> I suspect you're missing the C library pq.
18:20:36 <znaimon> should I write in --extra-include-dirs=/path/to/something
18:20:43 <Clint> or it's wedged into /usr/pgwhatsit somewhere
18:21:02 <shachaf> Or it's not installed?
18:21:17 <znaimon> shachaf: i have literally every postgresql package available on yum
18:21:34 <znaimon> well, relevant ones atleast.
18:21:35 <Clint> the rpms installed into /usr/pgsql-9.1?
18:21:37 <shachaf> OK, so where are the files from the libpq package?
18:21:40 <dcoutts_> znaimon: if you need --extra-include-dirs= then you probably also need --extra-lib-dirs
18:22:04 <znaimon> dcoutts_: include dirs would be /usr/pgsql-9.1/bin , but what would lib dirs be?
18:22:16 <shachaf> I doubt include-dirs would be /bin
18:22:16 <dcoutts_> znaimon: if it's /usr/pgsql-9.1, then it'd probably be --extra-include-dirs=/usr/pgsql-9.1/include --extra-lib-dirs=/usr/pgsql-9.1/lib
18:22:26 <dcoutts_> znaimon: but you can check those dirs
18:23:03 * dcoutts_ is very surprised that centos puts postgres in these  non-standard locations
18:23:24 <znaimon> dcoutts_: i didn't use the outdated default package
18:23:31 <znaimon> dcoutts_: I used a more recent version,
18:23:50 <geekosaur> centos packages 8.4 in the standard locations
18:23:58 <dcoutts_> I see
18:24:08 <znaimon> but 9.1 was installed separately through RPM on this precarious setup
18:24:09 <geekosaur> but now you're tinding out the problems with using third party packages
18:24:17 <dcoutts_> znaimon: ok, so you do need those --extra-include-dirs= and --extra-lib-dirs=
18:24:29 <znaimon> dcoutts_:  I used the --extra-include-dirs=/usr/pgsql-9.1/include --extra-lib-dirs=/usr/pgsql-9.1/lib you gave me
18:24:32 <znaimon> and everything worked fine
18:24:40 <dcoutts_> good
18:24:40 <znaimon> and now stuff's compiling properly for the moment.
18:24:41 <znaimon> thanks!
18:25:34 <znaimon> dcoutts_: sorry, one more thing
18:25:40 <znaimon> hsp-0.9.2 is failing to install
18:26:01 <dcoutts_>     Module `Data.Monoid' does not export `(<>)'
18:26:25 <znaimon> yep, that was one thing
18:26:27 <dcoutts_> znaimon: that version of hsp wants a later base (ie later ghc), or you should use an older hsp that works with your older ghc
18:26:39 <dcoutts_> (assuming that's still what the problem is)
18:26:47 <znaimon> yeah, i'd guess so
18:26:55 <znaimon> how would I update base?
18:27:03 <znaimon> cabal install base?
18:27:07 <dcoutts_> you don't, base is tied to ghc
18:27:17 <znaimon> GHC is the default yum package :(
18:27:24 <dcoutts_> so it's probably easier to downgrade the hsp version
18:27:50 <znaimon> any idea where I can find an earlier ver?
18:28:13 * geekosaur no longer has a centos with haskell-platform installed but it *was* a pretty old version. meanwhile it sounds like this package's dependencies are horked
18:28:57 <znaimon> geekosaur: yeah, CentOS is good for many things, but haskell environments aren't one of them
18:29:01 <dcoutts_> znaimon: you'll want to do something like (in the dir for your top-level project): cabal install ./ --constraint='hsp < 0.9.2' --dry-run
18:29:26 <dcoutts_> znaimon: installing an older hsp is easy, but we want to pick one that works with the other things you're installing
18:29:42 <geekosaur> up to date packages aren't any of them :)
18:29:58 <dcoutts_> znaimon: to see what versions are available, use: cabal info hsp
18:30:10 <geekosaur> sometimes I think rhel and debian are in a race to see who can ship the most out of date packages
18:30:15 <znaimon> running that command above, dcoutts_one moment
18:30:37 <znaimon> dcoutts_: returned this:
18:30:44 <znaimon> In order, the following would be installed (use -v for more details):
18:30:44 <znaimon> hsp-0.9.1
18:30:44 <znaimon> HJScript-0.7.0
18:30:45 <geekosaur> (since debian finally shipped wheezy, rhel and derivatives are winning now)
18:30:45 <znaimon> hpaste-1.2.0
18:30:58 <Clint> pfft, only if you go by stable
18:31:18 <znaimon> geekosaur: whereas I'm running Arch with the latest linux kernel on my 2013 MBA with no issues
18:31:48 <dcoutts_> znaimon: of course this doesn't guarantee that hsp-0.9.1 really works with your version of base either, but you can try it and if it doesn't, try an older one
18:31:49 <relrod> geekosaur: (disclaimer, I work at RH, but not on the RHEL team - and I'm not speaking on RH's behalf) - it's becomes really hard because people want the most stable software (i.e., old, tested versions), except for *one* particular package that they want at the latest and greatest version. It never ends well.
18:31:56 <geekosaur> sure, and I run mint in my non-work-related VMs
18:32:01 <znaimon> dcoutts_: i'm running it again sans- --dry-run
18:32:09 <geekosaur> relrod, yes, I know
18:32:14 <dcoutts_> znaimon: technically speaking this is an error in the hsp package, that it has the wrong version constraint for base
18:32:45 <znaimon> dcoutts_: yeah, I'm thinking 0.9.1 doesn't work either
18:32:48 <znaimon>  Module `Data.Monoid' does not export `(<>)' same error
18:33:37 <geekosaur> relrod, I used to maintain the linux-with-additions setup for a department of a major university, everyone wanted a stable system so their ancient stuff would keep working unmodified except they needed the absolute latest version of $something. naturally this would break someone else who needed $something kept ancient...
18:33:53 <Clint> znaimon: did you have a choice other than centos?
18:33:59 <znaimon> Clint: nope
18:34:17 <znaimon> Clint: someone else's server and configuration.  all I have is access to a root account and instructions to compile and install this app
18:34:19 <geekosaur> (and tenured profs are worse than enterprises when it comes to wanting stuff to stay static. we in 2011 were still supporting software from 1998 for some profs...)
18:34:46 <Clint> znaimon: fun stuff
18:34:55 <znaimon> Clint: indeed, indeed
18:35:05 <znaimon> dcoutts_: trying again with hsp 0.9.0
18:35:34 <relrod> geekosaur: yeah :( It's a hard thing to solve. I'm on the Fedora team (we also maintain the EPEL repo for RHEL), and there's been discussion about this problem for years. :/
18:35:50 <tabemann> efficiency question:
18:36:12 <tabemann> if I have a record where certain members will be updated very frequently and certain members will not
18:36:43 <tabemann> would it make things more efficient if I broke the record into two records, one which contains values that change frequently and one which contains values that do not
18:36:51 <tabemann> and make the first record point at the second record
18:37:32 <znaimon>  dcoutts_ so, hsp 0.9.0 doesn't work because of Module `Data.Monoid' does not export `(<>)'
18:37:41 <geekosaur> probably not, it's all pointers and if you break it into two records then *two* things are being constantly updated instead of just one
18:37:45 <znaimon> but HJScript-0.7.0 requires hsp >= 0.9
18:37:59 <Demos> unless you are like sending them to the GPU :D
18:39:10 <elodin> are there any resources online for practice problems  or challenges when first learning haskell?
18:39:12 <tabemann> geekosaur: I should note the stuff that would go in the second record would also be *accessed* far less frequently than stuff in the first record, so the expense of following another pointer is minima
18:39:38 <Demos> elodin, LYAH and RWH are good
18:40:06 <tabemann> hmm... reducing the amount of stuff to copy on updates of the frequently-changing stuff probably is outweighed by other expenses, such as inherent costs built into the VM design...
18:40:25 <tabemann> @where LYAH
18:40:25 <lambdabot> http://www.learnyouahaskell.com/
18:40:27 <jevankovich> elodin: for practice problems Project Euler is nice. Some of the problems lend themselves to nice looking, if a bit slow, solutions in Haskell
18:40:28 <tabemann> @where RWH
18:40:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:04:33 <Modius> Working through scheme/48-hours thing - what's the >>= - based form of liftM (Number . read) $ many1 digit   ?  (i.e. without liftm)
19:06:08 <c_wraith> Modius: liftM f x   is the same as    x >>= return . f
19:07:05 <dmwit> ?src liftM
19:07:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:07:30 <dmwit> @@ @undo @src liftM
19:07:30 <lambdabot>  liftM f m1 = m1 >>= \ x1 -> return (f x1);
19:08:40 <Modius> Thanks
19:09:26 <Modius> Anyone on here an emacs/haskell user?  I press C-c C-t the bottom emacs line animates through 2 type sigs; but when I press it repeatedly it highlights different levels of expression - any good advice on setting this up?
19:14:29 <enthropy> is the gscan in http://www.haskell.org/haskellwiki/Graham_Scan_Implementation supposed to be idempotent?
19:17:09 <c_wraith> shouldn't graham scan always be idempotent?
19:17:53 <c_wraith> I guess not, since the starting point could change
19:25:58 <hpaste> enthropy pasted “graham scan bug?” at http://lpaste.net/91197
19:26:36 <enthropy> c_wraith: ^^ is one case where you get a shorter list if you run gscan twice
19:29:21 <c_wraith> holy crap, lots of digits
19:30:05 <c_wraith> but still, randomly chosen points from quickcheck are exceptionally unlikely to be colinear
19:30:09 <enthropy> probably should try smallcheck, or maybe quickcheck's shrinking features
19:30:48 <c_wraith> Plot that set of points.
19:30:59 <c_wraith> I'm willing to bet there's a broken case in the library
19:31:18 <c_wraith> err, implementation rather.  not library
19:32:34 <c_wraith> because the set of points in a convex hull should be idempotent, if no 3 points are colinear.
19:38:45 <enthropy> http://i.imgur.com/D8LPzJw.png shows it eventually gets everything (same data points as in the paste)
19:46:17 <jevankovich> Would ST be a reasonable thing to use when trying to implement an emulator?
19:52:53 <Gracenotes> potentially, if there's some amount of RAM you have to model
19:53:17 <jevankovich> Thanks
20:06:12 <Rarrikins> Why do GHC-compiled programs stop responding to Ctrl-C right when they start swapping excessively?
20:06:21 <Rarrikins> That seems like the absolute worst time to stop responding to that.
20:07:23 <zRecursive> Rarrikins: The GHC-7.6.x created xmonad sometimes stop responding to keys too
20:07:43 <Nisstyre> zRecursive: really?
20:07:47 <zRecursive> GHC-7.4.x has no problems
20:07:59 <Nisstyre> zRecursive: I think my laptop xmonad is compiled with 7.6
20:08:08 <Nisstyre> I haven't had any problems
20:08:59 <zRecursive> ("M-C-x", spawn "~/bin/ml")  sometimes not work ...
20:09:29 <zRecursive> not stable enough
20:34:18 <MedDev> is it sacrilege to use 4 space tabs instead of 2?
20:35:41 <jevankovich> I'm not sure it really matters so long as you stay consistent and follow whatever standard is present in the code-base you're in.
20:35:50 <shachaf> Are you *trying* to start an argument? :-(
20:35:54 <shachaf> You can use whatever indentation you like, for the most part.
20:36:20 <shachaf> Note that if you use hard tabs GHC will treat them as hard tabs, i.e. aligning up to the next (8-column) tabstop.
20:36:42 <mgsloan> 1 space is totally where it's at
20:36:47 <shachaf> But arguments about indentation have no place in this channel. :-)
20:37:04 <jevankovich> shachaf: I found that out the hard way. Made debugging an absolute nightmare when the editor showed 4-space tabs
20:41:39 <MedDev> shachaf, i was just wondering ;)
20:41:56 <Modius> Hypothetical - instance Show ... where and I have several cases of show defined in there, is there a clean way to have them all share a function inside the instance definition?
20:42:09 <Modius> I'm aware great style may dictate putting the function at toplevel; but I want to know if it's possible
20:42:44 <shachaf> Not really.
20:42:57 <shachaf> show = realShow where realShow = ...; helper = ...
20:43:09 <shachaf> Or show x = case x of { ... -> ... } where ...
20:43:32 <shachaf> But nothing in general, especially if you define showsPrec and show and so on.
20:44:02 <jevankovich> If it's in a library it'd probably be okay to have it top level and then not export it
20:45:27 <Rarrikins> Does anyone remember the Haskell-like language of a year or two ago that was supposed to be for low-level programming?
20:45:55 <zzing> Rarrikins, it wasn't systems programming was it? THere is idris
20:46:12 <Modius> Aah yes case - and that ties into the "where vs let" I was reading then, that is the construct.  So A: it takes a "case", and B: doing it this way could get dumb, just put the function or its shared utility at the toplevel.
20:46:55 <Rarrikins> No, I think it had the ability to, for instance, define the bit layout of things.
20:47:23 <MedDev> Rarrikins, http://hackage.haskell.org/package/atom ?
20:47:50 <jevankovich> Speaking of where and let, is there any difference, other than appearance, between the two? They seem quite interchangeable
20:48:34 <applicative>  in core they both turn into let
20:49:11 <Rarrikins> MedDev: That was probably it. Thanks.
20:49:15 <jevankovich> So where is just fancy syntax that lets you put let bindings at the end of an expression? Neat. Thanks
20:50:24 <applicative> where is one of the best things in haskell. i think it was in miranda
20:50:43 <shachaf> jevankovich: "where" isn't for expressions. It's for bindings.
20:50:57 <shachaf> "x where y = z" is an error.
20:51:40 <jevankovich> Could you explain that a bit more?
20:51:47 <dmwit> jevankovich: ...and "where" blocks scope over multiple guards.
20:51:49 <shachaf> Also, Core isn't very relevant to the semantics of Haskell. :-) But "where" and "let" do mean the same thing, with the "obvious" translation.
20:52:21 <shachaf> jevankovich: In "x = y where ...", the "where ..." belongs to the "x ="
20:52:28 <shachaf> "where" doesn't stand on its own.
20:52:55 <dmwit> For example, print (let x = 3 in x) is okay. print (x where x = 3) is illegal.
20:53:05 <Rarrikins> Oh, wait. It was called Habit.
20:53:11 <elliott> where used to be an expression.
20:53:12 <elliott> in 1.2 or whatever.
20:53:18 <jevankovich> Okay. It needs to be in some sort of definition then?
20:53:42 <monochrom> use "let...in..." if you don't want a definition
20:53:55 <applicative> never use let ... in ...
20:53:57 <dmwit> > let f x | let y = x in y = 3 | not y = 4 in f True
20:53:58 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
20:53:58 <lambdabot>              with actual type...
20:54:01 <shachaf> Also valid: "case x of Just y | good y -> ... | otherwise = ... where help = ...y..."
20:54:12 <dmwit> > let f x | y = 3 | not y = 4 where y = x in f True
20:54:13 <lambdabot>   3
20:54:17 <shachaf> ; Nothing -> ...(can't use y, or help, in here)
20:55:17 <applicative> the important difference is between let and where on the one hand and case & co on the other
20:55:43 <jevankovich> Okay. I think I get it. Thanks
20:55:51 <applicative> in each case we have an imperative and a declarative syntax
20:55:59 <applicative> as peyton jones put it
20:56:01 <monochrom> I don't understand. (what does "& co" refer to?)
20:56:02 <shachaf> "let x = y in z" ---> "case y of x -> z"! (except for polymorphism)
20:56:30 <enthropy> and laziness?
20:56:31 <applicative> monochrom: f Nothing = 3; f (Just _) = 5
20:56:44 <applicative> is the declarative 'case'
20:56:50 <enthropy> > let Just _ = Nothing in 0
20:56:51 <lambdabot>   0
20:57:08 <shachaf> enthropy: Yes, x was a variable here, not an arbitrary pattern.
20:57:13 <applicative> case y of x doesn't resolve cases
20:57:26 <frx> why doens't it?
20:57:31 <frx> doesn't
20:57:35 <monochrom> ok, now I don't understand why you paint it as imperative and declarative.
20:57:44 <jevankovich> So imperative case or declarative pattern match at the function definition?
20:57:50 <applicative> i'm quoting peyton jones, monochrom
20:58:20 <applicative> replace 'case' with is a little strange with "match"
20:58:31 <applicative> not that "let" is a command
20:58:31 <biscarch> Hey guys, any idea why a lib I'm `cabal install`ing wouldn't be able to resolve itself as a dependency?
20:58:50 <applicative> which occurs at the top level in ml languages for example
20:59:22 <applicative> note that 'let' is a command, rather
20:59:36 <applicative> it's loathesome
21:00:27 <dmwit> biscarch: You should paste the exact command you ran and its full output somewhere for us to look at.
21:00:30 <dmwit> ?where hpaste
21:00:30 <lambdabot> http://lpaste.net/new/haskell
21:00:48 <monochrom> ok, this is getting nonsense and pointless. I don't care what role "let" plays elsewhere. "let ... in ..." in haskell is not imperative. "case ... of ..." in haskell is not imperative. that's my opinion. I have no further comment.
21:01:05 <applicative> biscarch: you mean cabal install couldn't figure out what version to install
21:01:11 <elliott> monochrom++ (and I hate let...in)
21:01:18 <applicative> monochrom: in haskell, i agree
21:01:24 <biscarch> dmwit: applicative http://lpaste.net/91198
21:01:47 <biscarch> bump-resource-pool is what I'm trying to install
21:02:28 <applicative> monochrom: just defending my perfectly reasonable remark against shachaf 's typical trolling
21:02:45 <shachaf> applicative: Huh?
21:02:45 <tabemann> okay, random question
21:02:47 <biscarch> it's happening in another lib as well, going to raise an issue with the repo soon to see if the install instructions need to be updated
21:03:01 * elliott didn't see any shachaf trolling...
21:03:09 <tabemann> which is typically more expensive - two IORefs, with no bounds checking, or a single two-item IOArray, with bounds checking
21:03:11 <applicative> elliott: no, but you're the same
21:03:25 <monochrom> seriously, did some troll took over applicative's computer?
21:03:44 <applicative> oh you pasted it biscarch
21:03:52 <elliott> applicative: I don't understand your accusations. or why you would make them without evidence.
21:04:31 <applicative> biscarch: you are inside a bump-whatever directory?
21:04:39 <biscarch> applicative: yes
21:04:41 <applicative> elliott: it's in the nature of the case
21:04:44 <biscarch> root of the project
21:04:59 <biscarch> with the .cabal file
21:05:11 <elliott> applicative: what does that mean?
21:05:35 <jevankovich> Could it be a circular dependency? Would cabal detect that?
21:06:11 <biscarch> jevankovich: It doesn't require itself in the .cabal
21:06:47 <applicative> this is a little obscure, it does look like its depending on itself in .cabal but that cant be right
21:06:54 <biscarch> and I was able to install it at a different commit an .hsenv ago or two
21:07:08 <dmwit> biscarch: cabal --version ?
21:07:26 <biscarch> dmwit: 1.16.0
21:07:55 <biscarch> updated cabal from a fresh hsenv and then started installing packages
21:08:13 <dmwit> Can we see the cabal file?
21:08:29 <elliott> applicative: seriously though, I don't appreciate slinging random accusations of repeated trolling like that and then going silent when asked to justify them.
21:09:10 <jevankovich> I don't remember seeing anybody trolling any(body/thing)
21:09:39 <biscarch> dmwit: seems as though it's being identified as spam on lpaste… Just a sec...
21:10:28 <applicative> lpaste is a little delicate that way, which is just as well
21:11:28 <biscarch> applicative: dmwit http://lpaste.net/91199
21:11:33 <shachaf> applicative: What's with all the trolling accusations?
21:11:45 <biscarch> seems it wanted author name and irc channel...
21:12:55 <dmwit> biscarch: Strange. And that's the full output of cabal install --verbose?
21:13:01 <dmwit> I would have expected a bit more.
21:13:06 <biscarch> yes, full output.
21:13:10 <biscarch> I expected more as well
21:13:17 <monochrom> I think so, you need -v3
21:13:22 <jevankovich> It's a very terse verbose
21:13:57 <monochrom> -v3 is admittedly long but I know how to read it
21:14:30 <shachaf> applicative: (Are you going to ignore all these questions? If I was actually doing something unreasonable I'd like to know. But right now it looks like you're making a baseless accusation, which isn't great.)
21:14:44 <biscarch> monochrom: ah, thanks. It looks like there's an unknown package
21:14:59 <biscarch> "unknown package: selectable"
21:14:59 <monochrom> ah
21:15:21 <biscarch> I was looking for that yesterday actually, debugging the same install. It would appear it's supposed to be in base?
21:15:28 <applicative> biscarch: there seems to be no difficulty installing bos repository, even if i rename it bump- ..
21:15:30 <monochrom> yeah, selectable isn't on hackage. if you have to, you should install it first
21:15:35 <applicative> biscarch: is this your renaming?
21:15:52 <biscarch> applicative: no, I can link the repo if necessary
21:16:01 <applicative> bah, this is completely opaque, I blame hsenv
21:16:01 <jevankovich> odd that cabal ate up such an important error
21:16:01 <monochrom> s/if you have to/if you have it/
21:16:52 <biscarch> monochrom: it's a fork of bos/pool, which also has selectable IIRC
21:17:02 <biscarch> I have no idea what selectable is
21:17:18 <monochrom> then you need a line in ~/.cabal/config referring to that repo
21:17:23 <adnap> > trace "test" 42
21:17:24 <lambdabot>   Not in scope: `trace'
21:17:26 <applicative> where is this bump-blah repo
21:17:37 <biscarch> applicative: https://github.com/bumptech/pool
21:17:43 <monochrom> (and then "cabal update", and then cabal will see it)
21:17:45 <adnap> > Debug.Trace.trace "test" 42
21:17:46 <lambdabot>   Not in scope: `Debug.Trace.trace'
21:18:18 <biscarch> monochrom: referring to the selectable repo? or the pool repo?
21:18:48 <monochrom> actually, neither. cabal's notion of "package repo"
21:19:05 <Heather> Good morning
21:19:17 <Heather> How to check what OS / platform is running?
21:19:39 <monochrom> well then, it may be easier to manually fetch selectable and "cabal install" inside its tree first
21:19:53 <elliott> Heather: try http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-Info.html
21:20:31 <Heather> elliott thanks
21:20:45 <biscarch> monochrom: I'd love to :) but I have no idea where it is. Can't find it with cabal or google.
21:22:00 <biscarch> ah, I think "selectable" is fork-only
21:23:18 <biscarch> I'm going to raise an issue with the fork project about it. This is just a dependency of the real lib I'm trying to install anyway
21:23:27 <biscarch> thanks for taking a look @all
21:26:50 <dmwit> biscarch: You could consider filing a bug against cabal for giving such an unhelpful error.
21:26:53 <dmwit> (seriously)
21:27:22 <dmwit> biscarch: Bonus points if you give a small (i.e. not git cloning bos' entire repository!) reproducible example.
21:27:40 <biscarch> haha, ok. I'll see what I can do for a minimal case
21:28:07 <dmwit> (But a big example is better than no example, of course.)
21:28:27 <biscarch> naturally
21:28:28 <jevankovich> If you found something on hackage that depends on something not on hackage, that may give the same error
21:55:03 <Heather> How can I case some cases by one ?
21:55:18 <Rarrikins> Heather: Huh?
21:55:21 <Heather> MultiCase as descripted here: http://www.haskell.org/haskellwiki/MultiCase but not implemented
21:55:36 <Heather> so how can I make the same or something alike
21:56:20 <Rarrikins> What does it mean to case a case?
21:56:34 <shachaf> You can use a tuple: case (x,y) of (Nothing,Nothing) -> ...; ...
21:56:34 <zRecursive> :t (*>)
21:56:35 <lambdabot> Applicative f => f a -> f b -> f b
21:57:22 <Heather> So In my situation I have System.Info.os and want to say that if there is "mingw32", "cygwin32" then it's Windows
21:57:43 <Heather> So I use case but I can't use it alike "win32" | "..." ->
21:57:46 <shachaf> Oh, no, I misread.
21:58:15 <shachaf> Use a guard and elem: ... | os `elem` ["mingw32","cygwin32"] ...
21:58:35 <tabemann> dammit - haskell-mode in Emacs doesn't like multiline strings...
21:58:47 * shachaf wonders whether this is a Pugs thing.
21:58:50 <Heather> shachaf what is ... here?
21:58:59 <shachaf> Heather: That depends.
21:59:15 <shachaf> You can say let x | ... = ... | ... = ...
21:59:16 <Heather> shachaf I just must return variable based on os
21:59:19 <shachaf> Or you can do a bunch of other things.
21:59:59 <Heather> so can I write return os | os elem [....] = "windows" ?
22:00:04 <Heather> looks not sane for me
22:00:23 <shachaf> No.
22:00:41 <shachaf> You should look up guard syntax. Or give more context. Or something.
22:00:41 <Heather> shachaf then how?
22:00:58 <Heather> shachaf well just return string based on os
22:01:29 <Rarrikins> Heather: You want to get a String of the name of your OS?
22:01:35 <Heather> shachaf I understand how guards works but no t sure how to apply them here
22:02:07 <Heather> Rarrikins I want to match os and return string based on this match
22:02:08 <Rarrikins> Heather: Or to get a different String based on the name of your OS?
22:02:11 <Rarrikins> Ahh
22:02:16 <Heather> Rarrikins yes
22:04:47 <Heather> Rarrikins can I do it using guards?
22:05:01 <Rarrikins> > let f os | os `elem` ["os a", "os b", "os c"] = "zomg" | os `elem` ["os d", "os e", "os f"] = "kthx" in map f ["os a", "os b", "os c", "os d", "os e", "os f"]
22:05:02 <lambdabot>   ["zomg","zomg","zomg","kthx","kthx","kthx"]
22:05:18 <Heather> ...
22:05:53 <Heather> so f will be matching function
22:06:12 <Rarrikins> No, it's the function that turns the OS name into the result.
22:07:38 <Rarrikins> elem is the function used to match things.
22:07:54 <kallisti> anyone interested in designing an awesome IRC bot framework in Haskell?
22:08:31 <lambdabot> definitely not
22:09:42 <Heather> > let matchOS os | os `elem` ("win32" | "mingw32") = "Win" | otherwise = "_"
22:09:43 <lambdabot>   <hint>:1:37: parse error on input `|'
22:10:06 <Heather> ah array )
22:10:15 <shachaf> Heather: You may not actually want a function like that because "os" is already a global thing.
22:10:19 <Rarrikins> @type elem
22:10:19 <lambdabot> Eq a => a -> [a] -> Bool
22:10:38 <jevankovich> elem's second argument is a list. you'd want 'os `elem` ["win32", "mingw32"]'
22:10:40 <shachaf> Like I said before, people can't help you much without either guessing or knowing context.
22:10:47 <Heather> shachaf what do you mean?
22:11:31 <jevankovich> He means that you didn't explain the situation very well. You didn't explain what you wanted some function to do
22:11:37 <shachaf> I mean: Show code. Or show a type of a thing you want to write. Or something.
22:11:39 <Heather> > let matchOS os | os `elem` ["win32", "mingw32"] = "Win" | otherwise = ""
22:11:40 <lambdabot>   not an expression: `let matchOS os | os `elem` ["win32", "mingw32"] = "Win"...
22:12:09 <shachaf> I'm pretty sure that what Rarrikins gave *isn't* what you want to write, at least not on its own, because it shadows the variable os.
22:12:21 <shachaf> But I can't be completely sure, not without context.
22:13:09 <Heather> shachaf well I think it's what I wanted to have :: String
22:13:20 <shachaf> OK. So you can write
22:13:44 <shachaf> myThing :: String; myThing | os `elem` ["win32", "mingw32"] = "windows" | os `elem` ... = ... | otherwise = ...
22:15:16 <Heather> > myThing :: String; myThing | os `elem` ["win32", "mingw32"] = "windows"
22:15:17 <lambdabot>   <hint>:1:18: parse error on input `;'
22:15:37 <jevankovich> Though it might be better to make a datatype that enumerates the possible OS options
22:18:01 <shachaf> It would.
22:19:58 <Heather> Rarrikins shachaf well now it works as I wanted it to, thank you.
22:20:20 <Crockeo> Would anyone mind helping me a bit with IO? More specifically-- actually lemme just do a copy paste.
22:20:46 <shachaf> specifically++
22:20:59 <Rarrikins> Heather: You're welcome.
22:21:05 <shachaf> Please don't paste directly into the channel.
22:21:17 <Crockeo> I'm not, I'm using the tool-thing at the top
22:21:19 <Crockeo> but it's taking a while
22:21:22 <shachaf> Use a paste website like sprunge.us
22:21:25 <shachaf> OK.
22:22:39 <Crockeo> Okay, so it's taking a while, lemme retry this...
22:23:13 <hpaste> Crockeo pasted “Contrived IO Example” at http://lpaste.net/91200
22:23:20 <Crockeo> Fantastic!
22:23:34 <Crockeo> Okay, so in that example, it's rather simplistic but it illustrates my question well
22:24:15 <Crockeo> what is it about the IO system (which is lazy along with everything else, right?) that prints out the "putStr" after the "getLine", and never prints out the "putStrLn"?
22:24:26 <shachaf> It has nothing to do with laziness.
22:24:28 <Crockeo> specifically when compiled, rather than run through GHCi
22:24:34 <shachaf> It's buffering, just like it would be in e.g. C.
22:24:53 <shachaf> You can flush stdout after the putStr.
22:25:15 <Crockeo> Ooooh, okay. I was mistaken as to the cause, then.
22:25:19 <shachaf> I don't know about the «and never prints out the "putStrLn"» part.
22:25:36 <jevankovich> I never realized the need to flush
22:26:03 <Crockeo> Does that mean something about "getLine" buffers the input?
22:26:05 <Crockeo> er--
22:26:06 <shachaf> putStrLn will flush automatically. The default buffering mode is LineBuffering.
22:26:06 <Crockeo> I mean
22:26:07 <shachaf> er++
22:26:08 <Crockeo> flushes stdout
22:26:18 <shachaf> No.
22:26:31 <shachaf> This is pretty much the same behavior you might expect in C a program.
22:26:34 <shachaf> Well, s/expect/get/
22:28:40 <Crockeo> Hm, okay. I mean, personally I've never had a problem with IO buffering in C (maybe because I work in it so little) but I presume the solution is somewhat similar?
22:31:24 <monochrom> in fact, I think haskell I/O buffering deliberately follows c-on-unix
22:31:31 <Crockeo> (that is doing something along the lines of "hSetBuffering stdout NoBuffering"?)
22:33:47 <shachaf> I think hSetBuffering stdout NoBuffering will be significantly less efficient than the C equivalent, due to doing a system call per character.
22:33:51 <shachaf> But I might be wrong. I don't remember.
22:34:56 <Ralith> Crockeo: you should rather flush when you finish writing
22:35:16 <shachaf> That's what I wrote above.
22:36:19 <Crockeo> Which, to do so on stdout would be, 'hflush stdout', yes?
22:36:34 <Crockeo> 'hFlush stdout' *
22:37:01 <jevankovich> How, using the Haskell SDL bindings, can I blit an arbitrary byte array or something similar to the screen?
22:40:02 <Crockeo> Alright, changed from hSetBuffering in the beginning to hFlush when I'm done writing. It's working perfectly, thank you!
22:40:12 <Crockeo> Now I think I'm going to bed because I'm being woken up in 6 hours.
22:40:21 <Crockeo> Thanks for your help everyone.
23:30:11 <MedDev> lol
23:30:26 <MedDev> wrong window :|
23:33:02 <mike4_> are there more Haskell channels?
23:33:12 <mike4_> like Haskell philosophy? or something?
23:33:26 <johnw> there are several
23:53:30 <predator217> how can I traverse a state action over a large list without blowing the stack? E.g. as in: let action = modify (+1) :: State Int () in execState (traverse (const action) [0..99999999]) 0
23:53:38 <predator217> i am using Control.Monad.State.Strict
23:56:20 <johnw> you'll need to write a custom version of modify
23:56:25 <johnw> the strict state monad is not strict in the state
23:56:38 <johnw> if you google, you'll find a Stack Overflow question that answers this exact point, plus a discussion haskell-cafe
23:56:58 <predator217> okay thank you I will have a look
23:57:36 <predator217> what exactly is it strict in?
23:57:50 <predator217> the hackage doc says only 'strict state monads'
23:57:51 <johnw> haskell-cafe goes into that, I don't remember just now
23:58:03 <predator217> never mind ;)
23:58:09 <johnw> i just remember us here in #haskell finding this out after several hours of scratching our heads :)
23:59:02 <predator217> sounds like fun
23:59:28 <johnw> space leaks are just unintended puzzles
