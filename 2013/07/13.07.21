00:08:11 <Gracenotes> anything about ghci's bytecode format on the interwebs?
00:18:58 <mstksg> \q lambdabot
01:08:12 <shachaf> Is there some kind of dual to Traversable that gives you something like (w a -> b) -> w (t a) -> t b?
01:18:19 <shachaf> Unrelatedly, you can write (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
01:21:59 <shachaf> Which is actually not a very interesting function.
01:43:31 <klrr> morning
01:44:40 <klrr> what happens if i have installed a version of a library using hackage and then later install a newer version of that library using a local .cabal file? does it mess up anything?
02:07:22 <alanz> klrr: should not cause a problem, so long as you do not force it when it says it may need reinstalls of other packages
02:07:44 <Saizan> klrr: make sure they have different version numbers, otherwise cabal-install might get confused
02:08:08 <Saizan> klrr: also, libraries built against the older version won't work with the new unless you rebuild them
02:09:17 * hackagebot conduit 1.0.7.3 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.7.3 (MichaelSnoyman)
02:09:19 * hackagebot shakespeare-css 1.0.6.2 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6.2 (MichaelSnoyman)
02:09:21 * hackagebot shakespeare-js 1.1.4.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.4.1 (MichaelSnoyman)
02:09:23 * hackagebot shakespeare-text 1.0.0.6 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.6 (MichaelSnoyman)
02:18:44 <merijn> mornin'
02:22:40 <klrr> Saizan: okey, thanks
02:23:30 <Bacta> Hi all
02:23:34 <Bacta> How is everyone?
02:35:50 <klrr> the moment when you cant copy your error since the directing the output to a file doesnt work
02:44:37 <merijn> klrr: What do you mean "directing the output to a file doesn't work"?
02:44:47 <merijn> klrr: You mean errors are still printed to a terminal?
03:11:57 <mikolaj`> Why in haskell unary minus can't be used in an expression like '2 * -2'? This rises an error, while in python it is perfectly valid.
03:12:21 <banister> mikolaj`: because it interprets it as the - function
03:12:27 <mikolaj`> Uhm okay
03:12:35 <banister> mikolaj`: just put () around it i think
03:12:38 <mikolaj`> When I put it in paratheses
03:12:38 <banister> 2 * (-2)
03:13:50 <mikolaj`> But are integeres literals? If so, why there are no negative literals. I would suspect that's how it works in python?
03:13:58 <mikolaj`> *integers
03:14:06 <banister> mikolaj`: shh
03:15:20 <mikolaj`> Perhaps I should ignore for know :> I am still on the first page of "Learn you a Haskell"...
03:15:39 <banister> mikolaj`: yeah, i think he explains it later on
03:16:33 <azm> why would you compare Haskell with Python ?
03:16:44 <azm> Python is not a centre of universe
03:16:50 <mikolaj`> It it is true in most imperative languages, no?
03:17:11 <Quadrescence> azm, well, by some metrics, it's a lot closer to the center around which companies revolve.
03:17:25 <azm> yes, companies.
03:17:29 <azm> not universe
03:17:34 <azm> ;)
03:17:47 <yesthisisuser> i think it is explained in "real world haskell"
03:17:51 <banister> python itself has a tonne of warts
03:18:05 <arcatan> surely everybody compares Haskell to what they happen to know
03:18:20 <azm> ..which does not make sense
03:18:38 <azm> I think its better start learning haskell on clean table.
03:19:02 <yesthisisuser> " If we did not need to wrap a negative number in parentheses, we would have two profoundly different ways to read f-3:"
03:19:11 <yesthisisuser> "it could be either “apply the function f to the number -3”, or “subtract the number 3 from the variable f”
03:19:22 <yesthisisuser> (from the Real World Haskell book)
03:20:47 <mikolaj`> yesthisisuser: So in haskell it is possible to have an object that is a function, but can be used as argument to '+' operator?
03:21:06 <mikolaj`> (or '-')
03:21:43 <yesthisisuser> when you write 5 - 3.. it is really (-) 5 3  using the infix form of (-).. if that is what you mean
03:21:57 <mikolaj`> If I know scheme, then yes ^^
03:21:59 <mikolaj`> indeed
03:22:45 <arcatan> the unary minus is a bit of a special case in Haskell, as it's the only unary operator. -x means negate x, and you can implement the Num typeclass to provide negate for your own types.
03:26:10 <gdrapal> @pl \xs n -> take n xs
03:26:10 <lambdabot> flip take
03:27:13 <alexander__b> I have a function parse. I want to be able to do getArgs and >>= words the result and return that, so that I in main can do foo <- parse
03:27:20 <alexander__b> what must parse look like?
03:31:28 <chrisbuchholz> I am trying to implement a version of Init with the type signature [a] -> Maybe [a]. My current version looks like this: https://gist.github.com/ChrisBuchholz/6048179 but i dont know how do implement Maybe when im using recursion like that -  `x : safeInit xs` will fail when safeInit returns 'Just [a]' instead of '[a]'. I was thinking I could split it up into two functions, one that does the computation and one that applies the Maybe
03:31:34 <chrisbuchholz> ... non-elegant. Any tips on how to proceed?
03:32:50 <merijn> chrisbuchholz: I'll take "what is fmap?" for 500 :)
03:33:05 <merijn> > fmap (1:) (Just [])
03:33:06 <lambdabot>   Just [1]
03:33:11 <merijn> > fmap (1:) Nothing
03:33:12 <lambdabot>   Nothing
03:33:40 <chrisbuchholz> merijn: i shall google
03:33:53 <merijn> :t fmap
03:33:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:34:03 <merijn> chrisbuchholz: See the 2 examples I just ran
03:34:32 <chrisbuchholz> merijn: yeah, but im not sure i understand them, but, sure, am looking right now :)
03:35:28 <merijn> chrisbuchholz: If you specialise "fmap :: Functor f => (a -> b) -> f a -> b" to the Maybe functor, you get "fmap :: (a -> b) -> Maybe a -> Maybe b"
03:36:06 <merijn> If you use a partially applied (:) you have a function "[a] -> [a]", so "fmap (x:) :: Maybe [a] -> Maybe [a]"
03:39:29 <chrisbuchholz> merijn: i have read what you're saying, but im still trying to understand it, hence the silence :D
03:39:49 <merijn> chrisbuchholz: unrelated, there is of course a much simpler way to implement safeInit :p
03:40:05 <dyn> btw, what is safeInit?
03:40:09 <merijn> "safeInit [] = Nothing; safeInit l = Just (init l)"
03:40:16 <merijn> dyn: init that doesn't throw an exception
03:40:18 <merijn> > init []
03:40:19 <lambdabot>   *Exception: Prelude.init: empty list
03:40:23 <merijn> > init [1,2,3]
03:40:24 <lambdabot>   [1,2]
03:40:39 <merijn> dyn: Where init returns a list with the last element dropped
03:40:42 <chrisbuchholz> merijn: yeah, thats not very elegant at all using init inside of it :)
03:40:49 <dyn> ah ok
03:41:14 <merijn> chrisbuchholz: I disagree that it's not very elegant, but gaining some experience with Functor's is good too
03:42:16 <chrisbuchholz> merijn: sure, i just think its masking the real problem
03:42:19 <merijn> chrisbuchholz: Basically, fmap lets you fiddle with the type inside a Functor. In case of Maybe, the implementation of fmap "knows" that Maybe can be Nothing, in which case it will just return Nothing too
03:42:38 <merijn> @src Maybe fmap
03:42:38 <lambdabot> fmap _ Nothing       = Nothing
03:42:38 <lambdabot> fmap f (Just a)      = Just (f a)
03:43:02 <chrisbuchholz> merijn: right, i think i need to understand it before i can apply it :)
03:43:32 <merijn> chrisbuchholz: Those two lines are the entire implementation of fmap
03:44:23 <chrisbuchholz> merijn: sure, but i guess i dont get as much out of those two lines a you probably do. Im not well versed in reading haskell yet .)
03:44:50 <merijn> chrisbuchholz: hmm, what are you reading to learn Haskell?
03:45:01 <dyn> chrisbuchholz: _ stands for anything.. so like fmap <anything> to Nothing equals to Nothing
03:45:42 <chrisbuchholz> i have read most of LYAH and are now playing with Real World Haskell, which i think is much better - feel like i am understanding things better when im reading about them in RWH than in LYAH
03:45:46 <dyn> and fmap (function f) to (Just a) is Just (f applied to a)
03:45:54 <dyn> (if that helps)
03:46:27 <dyn> chrisbuchholz: I had had just an opposite experience :)
03:46:32 <chrisbuchholz> dyn: yeah, its not as much translation the syntax, but figure out how to understand it, if you know what i mean
03:46:40 <chrisbuchholz> dyn: oh :P
03:47:04 <dyn> I had also put away RWH and currently catching up with the fpcomplete tutorials
03:47:39 <dyn> but I also thought LYAH is the most entertaining computer book I've ever read
03:47:41 <merijn> dyn: Fun fact, _ is just a variable name, ghc will just not warn about unused variables starting with _
03:48:08 <dyn> merijn: wow nice, didnt know that
03:48:15 <Bacta> Hi ll
03:48:18 <Bacta> *all
03:48:21 <Bacta> How is everybody?
03:48:31 <merijn> chrisbuchholz: Chapter 8 and 11 of LYAH should explain Functor in quite some detail, I think RWH kinda glosses over the details
03:48:49 <merijn> > let f _ x = x in f 1 'c'
03:48:50 <lambdabot>   'c'
03:48:53 <merijn> > let f _foo x = x in f 1 'c'
03:48:54 <lambdabot>   'c'
03:49:04 <kartoffelbrei> dyn: i found "The land of lisp" to be quite entertaining as well.
03:49:25 <kartoffelbrei> i especially like the alien comics
03:49:29 <chrisbuchholz> dyn: yeah, i think its good, but i have been reading it for a while, i just felt i wasnt understanding things proberly. Then i found an SO thread giving tips on what to read to learn haskell, and it said to read RWH after the sixth chapter of LYAH, and since i read chapter six a long time ago, i figured it could try out RWH and i did and so far i have liked it very much
03:49:45 <alexander__b> I never had time to finish the land of lisp, but the chapters I read were fun.
03:49:54 <alexander__b> however, I think it moved a bit too quickly for my noobness.
03:50:07 <Bacta> How is everyone?
03:50:23 <dyn> kartoffelbrei: the website looks fun indeed
03:50:35 <chrisbuchholz> merijn: its probably the fact that RWH scoots over the stuff and just lets you play with some actual appliances of haskell, that i like it, coming from reading LYAH where i feel its just very "read this, read this" and not very much "do this!"
03:50:37 <dyn> Bacta: not mentioning my hangover, excellent ;)
03:50:49 <Bacta> That's good XD
03:51:17 <Bacta> I'm doing great btw XD
03:51:18 <merijn> chrisbuchholz: Oh, I agree, at the same time I feel RWH glosses over a bunch of explanation, though. Maybe you wanna switch back and forth between the two
03:51:54 <chrisbuchholz> merijn: probably. I use LYAH to look up specific stuff all the time already though
03:52:09 <chrisbuchholz> merijn: just using RWH for like exercises
03:52:21 <merijn> chrisbuchholz: In that case you might wanna jump to chapter 11 which covers Functors (and refers back to earlier things with additional background)
03:52:50 <chrisbuchholz> merijn: will keep that in mind
03:53:03 <latermuse> chrisbuchholz: after a while, i began to prefer reading the theoretical stuff over the applicatable tutorials
03:54:07 <chrisbuchholz> latermuse: sure! There comes a time when you understand things enough that you can grasp it in your head, and what you need to keep up on is theory and you can figure the rest out yourself, but im not there at all with haskell :D
03:55:08 <chrisbuchholz> latermuse: i need some exercises that makes me use techniques in real life because i dont understand haskell enough to be able to just think up stuff my self and do it. Not really yet.
03:55:41 <Bacta> How is everybody?
03:56:17 <merijn> chrisbuchholz: The approach that seems to work well is reading LYAH first, just to get familiar with a bunch of stuff, then start reading RWH and actually writing code and when you vaguely remember reading about something in LYAH you can go back and reread it in a context where it's use is clearer to you
03:56:35 <Bacta> How is everybody?
03:56:42 <tulcod> merijn: in retrospect, YES.
03:57:30 <Bacta> Hi MindlessDrone
03:57:34 <Bacta> How you doing?
03:58:04 <dyn> I wonder if that's the proper place to test irc bots under development
03:58:14 <Bacta> How are you dyn?
03:59:03 <chrisbuchholz> merijn: yeah, i didnt get through with LYAH before it started to get boring and i needed to code some stuff to keep up on it :)
03:59:12 <alexander__b> not sure if Bacta is a bot or not but it's spamming me (and probably other people) with insults. pls2ban.
04:00:00 <Bacta> Huh?
04:00:22 <chrisbuchholz> alexander__b: yeah, it did that to me too
04:00:23 <merijn> @where ops
04:00:23 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
04:00:23 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:00:43 --- mode: ChanServ set +o Igloo
04:00:56 <latermuse> alexander__b: me too with the spam from Bacta
04:01:00 --- mode: Igloo set +b *!*@124-197-56-160.callplus.net.nz
04:01:03 --- kick: Bacta was kicked by Igloo (Bacta)
04:01:08 <merijn> Igloo: Thanks :)
04:01:19 <alexander__b> Igloo: cheers
04:01:26 <zRecursive> latermuse: who is Bacta ?
04:01:26 <dyn> is it a common habit to start the lines with <|> when wrapping haskell code multiline? I find it a bit cumbersome to format that properly with vim
04:01:51 <merijn> zRecursive: No, clue, he was just asking off-topic things and spamming people with insults
04:02:05 <dyn> (and the same question applies to line-starting commas)
04:02:08 <latermuse> zRecursive: I dont know. Just some random guy.
04:02:12 <merijn> dyn: I tend to put combinators at the start of a line in case of a line continuation, yes
04:02:32 <merijn> dyn: If you have problems with vim's auto-indent sucking, I have the solution for you! </self-pimping>
04:02:37 <dyn> merijn: and you're formatting those lines yourself or your editor of choice helps with those?
04:02:39 <kartoffelbrei> zRecursive: iguess he was just a spambot of some kind. His message looked very "uniformley" to me.
04:02:49 <dyn> merijn: I'm all ears.. :)
04:02:56 <zRecursive> yeah, bad spam
04:03:02 <merijn> dyn: I got fed up with the sucky haskell auto-indent, so I wrote my own: https://github.com/merijn/haskellFoldIndent
04:03:32 <yesthisisuser> is there anyone here using Leksah? i tried asking on #leksah but there is not much activity there.. i am looking for where the editor style definition files are stored (on linux)
04:04:00 <merijn> dyn: It's a work in progress, but very usable. Although I'm a bit opinionated about how Haskell should be indented, so if you have very different views on indentation it might not work out for you :p
04:04:46 <dyn> merijn: I'm way too deep into my learning phase to form my own views..
04:05:27 <merijn> dyn: Good, that means I can dogmatically enforce my views easier ;)
04:05:36 <dyn> merijn: for now.. yes ;)
04:05:51 <dyn> merijn: strange.. looks like I have your stuff already in ~/.vim/. Can I double-check somehow if it's enabled?
04:06:03 <dyn> merijn: or maybe it's clashing with some other vim-haskell stuff?
04:06:29 <merijn> dyn: It might be clashing with other haskell indentation plugins, if they exist
04:06:44 <dyn> I have haskellmode.vim in autoload/ and haskellFoldIndent in .vim/bundle/
04:07:35 <merijn> Easiest way to check is to see how it indents data declaration and whether that behavior changes when you change "let g:HaskellFoldIndent_AlignDataDecl = 1"
04:08:26 <merijn> dyn: Having it in ~/.vim/bundle mean that you should have pathogen installed/enabled it also relies on you enabling plugins in .vimrc "filetype plugin indent on"
04:09:00 <dyn> I have filetype plugin indent on in my .vimrc
04:09:10 <dyn> and have pathogen also
04:09:55 <dyn> merijn: should your plugin reindent the file properly on =G ?
04:10:41 <merijn> dyn: It doesn't do that anymore as it's impossible to do that sanely without actually parsing Haskell, which is hard (if not impossible) in vim's indentation implementation
04:11:11 <dyn> merijn: ok, I won't expect it then
04:11:19 <zRecursive> :t (*>)
04:11:20 <lambdabot> Applicative f => f a -> f b -> f b
04:12:21 <lpaste> merijn pasted “indentation problem” at http://lpaste.net/91091
04:12:31 <merijn> dyn: See that problem
04:13:00 <merijn> The code's meaning changes if you dedent the commented line and it's impossible to decide which it should be
04:13:21 <dyn> merijn: yeah right
04:13:23 <dyn> makes sense
04:13:46 <dyn> merijn: http://lpaste.net/91092 <- is this how it should be indented properly?
04:14:03 <merijn> dyn: You should check whether the indentation of data matches up with that described in the README and whether it changes if you toggle the variable name I mentioned between 0 and 1
04:14:25 <dyn> merijn: or with the "(string" words aligned?
04:14:37 <merijn> dyn: I prefer this style
04:14:42 <dyn> ok
04:15:11 <merijn> Actually, I'd probably have the first line follow the equals sign and then have the rest indented below that
04:15:26 <lpaste> merijn annotated “indent” with “indent (annotation)” at http://lpaste.net/91092#a91093
04:15:34 <dyn> merijn: and how would you get it to indent the first line with the equal sign?
04:15:49 <dyn> merijn: oh I see what you mean
04:15:56 <merijn> It depends on how long the function name/arguments are, though
04:16:12 <merijn> If the function names/arguments are long I'd be more likely to linebreak after the =
04:16:33 <dyn> merijn: I'm not sure if I see any changes on setting let g:HaskellFoldIndent_AlignDataDecl to 0 or 1
04:16:36 <merijn> My rule of thumb is, use whatever looks prettiest/reads easiest
04:17:22 <merijn> dyn: The difference should be that data declarations have their | indented to match the = or just one indent (see the first examples in the README) if that doesn't happen, your other plugins are overwriting mine
04:17:59 <dyn> merijn: and it applies to stuff I'll type after the setting change, I guess
04:18:28 <merijn> dyn: Yeah
04:18:36 <merijn> It should, lemme confirm, though :p
04:19:22 <dyn> merijn: it seems to align the | with the = in both setting for me
04:19:31 <dyn> no matter if it's 0 or 1
04:20:14 <merijn> dyn: Then the haskellmode stuff is clobbering it
04:20:29 <dyn> merijn: ok, let me get rid of it
04:21:29 <merijn> dyn: Presumably the haskellmode file is setting "indentexpr" and "indentkeys" somewhere, you can either find those places and disable those
04:21:55 <merijn> Or just disable haskellmode entirely, or figure out if their is a specific file that's messing with the settings and only exclude that
04:22:13 <dyn> merijn: I'll just try to get rid of it for now
04:22:27 <merijn> Depending on which haskellmode features you use, you might just wanna ditch it for syntastic+hdevtools
04:22:37 <dyn> I also seem to have .vim/ftplugin/haskell.vim, haskell_doc.vim and haskell_hpaste.vim
04:22:51 <dyn> *and* syntastic as well (geez)
04:22:54 <merijn> dyn: probably the first one is clobbering things
04:23:04 <dyn> a complete haskell nirvana in my ~/.vim/
04:24:40 <dyn> merijn: you prefer your bitbucket hg repo or github?
04:25:19 <dyn> or you're keeping them in sync?
04:26:11 <merijn> I keep both in sync, but I use mercurial myself, so github is more of a "convenient/common mirror" than the real repo
04:26:48 <merijn> (I'm just using hg-git to convert and push the Mercurial history to github)
04:30:28 <dyn> ok, I'll just keep it running with syntastic and your stuff
04:31:04 <merijn> dyn: I think syntastic for haskell needs hdevtools (which will also let you query for types in your code)
04:31:24 <merijn> dyn: my .vimrc has my config for those two if you're interested
04:31:38 <dyn> merijn: sure
04:33:38 <dyn> merijn: where is it?
04:34:39 <merijn> dyn: github.com/merijn/dotfiles
04:35:09 <dyn> merijn: thanks
04:38:36 <dyn> merijn: love your .ghci ;)
04:40:15 <merijn> dyn: I've grown really accustomed to it, it's much nicer than all this imported module clutter
04:42:19 <alexander__b> every other commit I make I break pi, and don't understand why: https://secure.plaimi.net/~alexander/tmp/clac.hs why doesn't pi work here?
04:42:48 <alexander__b> ./clac 2 pi -- 3.141592653589793
04:43:00 <alexander__b> ./clac pi -- clac: clac.hs:65:1-26: Non-exhaustive patterns in function unOp
04:43:07 <alexander__b> oh right yes
04:43:50 <alexander__b> > const pi
04:43:51 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
04:43:51 <lambdabot>    arising from a use ...
04:43:56 <alexander__b> > const pi 2
04:43:57 <lambdabot>   3.141592653589793
04:43:59 <alexander__b> right.
04:45:31 <dyn> merijn: what does :Helptags does for you?
04:45:59 <dyn> merijn: I have such a command in vim but it does exactly nothing (no errors either)
04:47:15 <merijn> dyn: No clue, seems to be a builtin vim command?
04:47:26 <dyn> merijn: but does it do anything visible for you?
04:47:45 <merijn> nope
04:48:25 <wakalabis> hi
04:48:36 <wakalabis> anybody there?
04:48:41 <dyn> I started off with a clean ./.vim, installed pathogen, haskellFoldIndent, syntastic and hdevtools and the latter does not seem to work at all. No errors, but I have no :HdevtoolsType command for example
04:48:57 <alexander__b> dyn: I recommend ghc-mod
04:50:12 <supki> dyn: what does  which hdevtools  say?
04:50:31 <dyn> alexander__b: will check in a sec
04:50:35 <dyn> supki: hmn?
04:50:44 <alexander__b> dyn: oh yeh, do you actually have hdevtools? as in not the hdevtools-vim plugin, but hdevtools the program
04:50:46 <wakalabis> I have a stupid question. Maybe someone can help me?
04:50:54 <dyn> supki: ahh I see what you mean
04:50:57 <dyn> alexander__b: right
04:51:00 <alexander__b> wakalabis: no one will know unless you ask
04:51:02 <Taneb> wakalabis, fire away
04:51:09 <alexander__b> dyn: cabal install hdevtools or something
04:51:10 <wakalabis> thanks
04:51:16 <wakalabis> I'm reading MonadWriter documentation
04:51:24 <wakalabis> it starts with "class (Monoid w, Monad m) => MonadWriter w m | m -> w where"
04:51:38 <wakalabis> What does the pipe character mean in this context?
04:52:03 <wakalabis> I know it works as a guard. But I don't know what it means in a class declaration
04:52:23 <Eduard_Munteanu> wakalabis: functional dependencies
04:52:34 <Eduard_Munteanu> (also known as fundeps)
04:52:50 <Walther> Just curious; why does cabal install hakyll take so long? It seems like it compiles ...everything, like the entire Haskell default libraries and whatnot, even if I have ghc etc installed
04:53:03 <Eduard_Munteanu> wakalabis: it says "m determines w"
04:53:04 <merijn> alexander__b: Why do you recommend ghc-mod?
04:53:22 <wakalabis> Eduard_Munteanu: thanks
04:53:26 <hpc> Walther: exactly what packages is it recompiling?
04:53:51 <shiona> Walther: if hakyll depends on older versions of the packages you currently have it will build those.. or at least that is what it used to do
04:53:52 <alexander__b> merijn: because it ruls in vim. auto type signatures, completion, and _i is awesome.
04:54:14 <wakalabis> Eduard_Munteanu: Thanks, now I can research by name (fundep)
04:54:18 <Walther> hpc: it seems to be compiling stuff like Data, Blaze, Crypto
04:54:24 <Walther> shiona: ah
04:54:26 <Eduard_Munteanu> wakalabis: or IOW, if you define an instance with some m and w, the compiler knows you won't define another one with the same 'm' but different 'w'
04:54:28 <wakalabis> Eduard_Munteanu: and find out exactly what it means (http://www.haskell.org/haskellwiki/Functional_dependencies)
04:54:33 <merijn> alexander__b: Except that it was a pain to get working and after a bit I decided "screw it, I just wanted error highlighting with syntastic"
04:54:48 <alexander__b> merijn: syntastic is great, yes
04:54:49 <Walther> I'm just used to precompiled (debian-like) packages, compiling isn't really my thing
04:55:00 <Walther> gah... now it's compiling Text
04:55:15 <Walther> it's like 10 minutes in on cabal install hakyll
04:56:04 <hpc> once you have that stuff compiled, future packages will try to reuse the resulting code
04:59:28 <alexander__b> ,("pi"  , (:)    (pi :: Double)) was what I was looking for
04:59:32 * alexander__b is pleased with himself
05:02:04 <alexander__b> anyone know how to make Fx treat .hs as plaintext?
05:02:33 <hpc> what content type does firefox see?
05:03:07 <alexander__b> IDK it has haskell source code in the list of file types
05:03:10 <tulcod> alexander__b: unless you're loading from disk, firefox takes the hints from the webserver
05:03:38 <alexander__b> tulcod: yes, I know. I just want Firefox to show it as plaintext because I know it is able to.
05:03:53 <tulcod> then save to disk?
05:04:12 <alexander__b> no... I want to just show it as when visiting a .txt "site".
05:04:27 <tulcod> alexander__b: there is no way to force that AFAIK
05:04:37 <Walther> about::config
05:04:40 <alexander__b> lolomg. *don't* set Fx to open it with Fx at least. I suddently had... *many* tabs of that file. :-P
05:04:47 <Walther> you can pretty much set all the things in about:config
05:04:57 <tulcod> alexander__b: it will even force you to download a .html file if the webserver tells it to
05:05:19 <alexander__b> tulcod: it sounds like something that should be possible to override.
05:05:42 <tulcod> alexander__b: maybe, but then you're in the wrong channel
05:06:35 <alexander__b> it's the wrong channel to ask about vim plugins as well IMO, but I still tend to get answers to remotely-haskell-related questions in here. :-)
05:07:23 <alexander__b> is there some sort of guideline/de fact standard/blah about how to order functions? i.e. main at top or bottom, and such things.
05:07:30 <tulcod> your question about firefox is not remotely haskell related. it's a question about mime type resolution
05:08:41 <tulcod> alexander__b: actually i'm interested in that as well
05:09:07 <tulcod> is there any haskell code style guide?
05:09:13 <alexander__b> not an official one, no
05:09:21 <alexander__b> ghc has one, but it's a bit lol and legacy
05:09:24 <merijn> alexander__b: I group in sections, main/exported code at the top, internal at the bottom
05:09:48 <alexander__b> merijn: would you be of the type that always places the program start at the top? (e.g. main)
05:10:02 <alexander__b> as a game hacker, I have come to value such predictability...
05:10:07 <tulcod> also, merijn, what are you doing all day answering noob questions here. don't you have anything better to do? (don't get me wrong, i'm very grateful)
05:10:14 <merijn> No, I would usually place main at the bottom, or just before all internal crud
05:10:24 <merijn> tulcod: I'm procrastinating :p
05:10:27 <alexander__b> tulcod: http://www.haskell.org/haskellwiki/Programming_guidelines -- sort of official-ish
05:10:45 <alexander__b> at least the closest there is I suspect
05:10:57 <tulcod> alexander__b: yeah, but that's hardly a guideline
05:11:08 <alexander__b> whatdo you mean?
05:11:19 <tulcod> it doesn't exactly resolve all my questions
05:11:41 <alexander__b> it covers most of what coding guidelines tend to cover
05:13:34 <twomashi2> if I have `data Stuff = Foo | Bar | Baz`, is it possible to have a function that accepts only Foo or Bar while still sharing the same polymorphic type?
05:14:13 <tulcod> twomashi2: you can error on Baz, or return a Nothing if Baz is given
05:14:40 <twomashi2> tolcod: was hoping to use the type system
05:14:42 <tulcod> twomashi2: but we don't really have subtypes in haskell
05:15:57 <twomashi2> subtypes eh.. hmm. gonna have a look anyway, see if this is what I need
05:16:23 <tulcod> twomashi2: why do you want to make it like that?
05:17:27 <twomashi2> tulcod: long story, i want to make a type checked graph of functions that can be invoked independently on data streams
05:18:22 <tulcod> twomashi2: uh. arrows?
05:18:42 <twomashi2> tulcod: I'm new ish… go on?
05:18:42 <tulcod> disclaimer: i don't know arrows
05:19:01 <tulcod> maybe someone who actually knows haskell can back me up here?
05:19:48 <merijn> You could probably encode what you want in the type system, but I wouldn't think it's very wise to attempt it as a haskell newbie
05:20:52 <twomashi2> merijn: I'm not totally new either :). hoping someone can point me in the right direction
05:20:54 <hpc> twomashi2: the direct answer to your question is GADTs
05:21:34 <hpc> that may or may not be a useful answer to your question
05:21:42 <hpc> and your question may or may not even be what you really want
05:21:48 <hpc> (such is the nature of irc questions)
05:22:05 <merijn> GADTs + phantom type seems the best approach
05:22:42 * twomashi2 adds GADTs, phantom types and arrows to reading list
05:22:52 <twomashi2> thanks
05:22:58 <merijn> twomashi2: The haskell wikibook has good chapters on phantom types and GADTs
05:23:12 <twomashi2> merijn: looking at it now
05:34:21 * hackagebot threepenny-gui 0.1.0.0 - Small GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.1.0.0 (HeinrichApfelmus)
05:34:23 * hackagebot toolshed 0.15.0.0 - Utilities used by other packages.  http://hackage.haskell.org/package/toolshed-0.15.0.0 (AlistairWard)
05:39:21 * hackagebot factory 0.2.1.0 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.1.0 (AlistairWard)
05:39:23 * hackagebot squeeze 1.0.4.0 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.4.0 (AlistairWard)
05:44:57 <ignacio> I wonder if there's an "irrational" data type
05:46:55 <tulcod> ignacio: does a sequence space count? it's mathematically sort of the same thing
05:47:27 <tulcod> if so, then [[Int]] would be one
05:49:04 <mirari_> Is Either a functor?
05:49:49 <Alex_M> m for f
05:49:56 <merijn> mirari_: Yes
05:49:57 <Taneb> mirari_, yes
05:49:59 <tulcod> mirari_: "Either a" is a functor
05:50:07 <merijn> mirari_: Might need to impoter Data.Either to get the instance, though
05:50:14 <merijn> s/impoter/import
05:50:48 <Alex_M> m for f in pvt
05:50:50 <mirari_> WHen you say Either a, what do you mean? Either has two type parameters a and b
05:51:00 <tulcod> mirari_: exactly. and a functor has one type parameter.
05:51:05 <mirari_> (sorry for newbie questions - im trying to learn type classes by implementing stuff myself)
05:51:16 <tulcod> mirari_: so you need to already give one before we can call it a functor
05:51:17 <mirari_> tulcod: So its a functor if I fix the first param?
05:51:33 <tulcod> yeah. although that may be due to my lack of understanding of the type system.
05:52:18 <tulcod> @kind Functor
05:52:18 <lambdabot> (* -> *) -> Constraint
05:52:22 <tulcod> @kind Either
05:52:22 <lambdabot> * -> * -> *
05:53:28 <merijn> "Either x" is a functor, forall possible values of x
05:53:36 <merijn> :t fmap
05:53:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:53:47 <merijn> if you replace f with "Either x", you get
05:53:55 <mirari_> Yeah, I see, thanks :)
05:53:59 <merijn> "(a -> b) -> Either x a -> Either x b"
05:54:26 <mirari_> What are some interesting functors in addition to Maybe and List? (just for playing with- that is)
05:55:23 <merijn> IO, State, Reader, Writer, (r ->)
05:55:38 <Hafydd> Two of those are the same.
05:55:50 <ignacio> tulcod: good point
05:56:04 <chrisbuchholz> merijn: all right, could you please show me the version of my safeInit that uses fmap? https://gist.github.com/ChrisBuchholz/6048179
05:56:34 <tulcod> ignacio: but then we could just as well include any uncountable data type :)
05:56:57 <Hafydd> What's an example of an uncountable data type?
05:57:28 <lpaste> merijn pasted “safeInit” at http://lpaste.net/91094
05:57:55 <ignacio> a type whose members are solutions of equations
05:58:13 <ignacio> you mean an IRL example?
05:58:21 <merijn> Although, tbh the recursion with fmap is unneccesary if you just call a helper function that assumes a non-empty list (i.e. init) after checking that it's non-empty
05:59:09 <Hafydd> ignacio: I mean a concrete example. I assume you were talking about programming language data types.
05:59:37 <ignacio> hmm
06:00:09 <ignacio> well it's clear that the computer has a finite number of states
06:01:11 <ignacio> so we'd have to define "uncountable data type" properly
06:01:37 <Hafydd> Yes... that may be the issue.
06:01:53 <chrisbuchholz> merijn: yeah, something like this: https://gist.github.com/ChrisBuchholz/6048179
06:02:02 <Hafydd> I'd understand it to mean: there is no injection from the natural numbers to the values of the type.
06:02:26 <chrisbuchholz> merijn: but thanks, i have been reading LYAH and just couldnt get the fmap thing out of my head, so thanks for the example :D
06:02:54 <ignacio> I don't know how ugly this is, but what about referencing the real world?
06:03:17 <Hafydd> As an uncountable data type?!
06:03:26 <ignacio> store an IP address
06:03:54 <ignacio> pinging it gives you a rational approximation to the real value that's your time delay to that IP
06:03:56 <yesthisisuser> conceptually .. Float should be uncountable but its implementation is not
06:04:08 <yesthisisuser> i mean the set of real numbers is uncountable
06:04:27 <Hafydd> ignacio: any such algorithm could only output a countable number of values.
06:04:35 <Hafydd> (Since there's only a countable number of inputs)
06:04:49 <ignacio> Hafydd: yes, all haskell functions only output a countable number of values
06:05:00 <ignacio> actually the function would be IO Double
06:05:19 <ignacio> that's why we have to define uncountable data type
06:05:31 <Hafydd> The result has to be stored in some data type, which will occupy only a finite number of bits at a time - therefore, its values are countable.
06:06:07 <ignacio> there's no way we're getting values from an infinite set
06:06:07 <Hafydd> In particular, Double is countable.
06:06:42 <ignacio> so the closest we can get to uncountable data type would be "there's a real somewhere, and we can evaluate f :: Real -> Double"
06:06:44 <klrr> 11:44 < merijn> klrr: What do you mean "directing the output to a file doesn't work"?
06:06:47 <klrr> 11:44 < merijn> klrr: You mean errors are still printed to a terminal?
06:07:07 <Hafydd> Alright, but that's still not uncountable. It doesn't make the term "uncountable data type" make sense.
06:07:14 <ignacio> or in this case f :: Real -> IO Double
06:07:40 <klrr> merijn: yes, i was using runhaskell, and i did "runhaskell foobar.hs > log.txt" and the log.txt was empty and output was still in terminal
06:07:53 <merijn> klrr: That's because errors don't go to stdout
06:07:57 <Hafydd> Such a function _couldn't_ fulfill the requirement of giving an approximation as close as you like.
06:07:58 <merijn> klrr: Errors are written to stderr
06:08:05 <merijn> klrr: > only redirects stdout
06:08:14 <merijn> klrr: In bash you want "2>" to redirect stderr
06:08:29 <klrr> merijn: okey, so it was my lack of knowledge of how to use terminal, sry, thanks for explaining i did actually not know that
06:09:00 <merijn> klrr: It's to make sure that it's possible to log error and output separately
06:09:11 <ignacio> if you interpret it as decimal digits, cycle [1..] gives you an irrational number
06:09:53 <Hafydd> If you interpret 1 as pi, 1 gives an irrational number.]
06:10:32 <Hafydd> Also, what's the interpretation of the decimal digits 7,8,9,10,11?
06:11:23 <ignacio> "0." ++ (concat (map show [1..]))
06:11:27 <ignacio> > "0." ++ (concat (map show [1..]))
06:11:28 <lambdabot>   "0.123456789101112131415161718192021222324252627282930313233343536373839404...
06:11:37 <Hafydd> Oh, right.
06:13:21 <ignacio> you could have a type (Double, Double) with (x,y) representing (x + pi*y)
06:13:33 <alexander__b> I'm doing some exercises from typeclassopedia. how would a functor instance for ((,) e) look like?
06:13:40 <ignacio> that gets you irrational numbers
06:14:12 <Hafydd> Not all of them.
06:14:19 <ignacio> just the good ones
06:14:33 <ignacio> add e if you wanna get fancy
06:14:47 <ion> > "0," ++ (show =<< [1..])
06:14:48 <lambdabot>   "0,123456789101112131415161718192021222324252627282930313233343536373839404...
06:14:49 <Hafydd> instance Floating (Double,Double) where { pi = (0,1) }
06:14:55 <ignacio> maybe a couple more powers of pi if you wanna integrate gaussians
06:15:02 <ignacio> and you're good to go
06:15:24 <alexander__b> I don't think I fully understand what "((,) e)" means. I get that the e is "some annotation" with a type. so fmap f that_annotation would return that_annotation.
06:15:33 <Hafydd> Now that I'm "good to go", what am I going to do with this data type?
06:15:38 <alexander__b> but I'm not entirely sure what the (,) is nor how to deal with it
06:15:46 <ion> alexander_b: First of all, what would the type signature for fmap specialized for ((,) e) look like?
06:15:53 <ion> alexander_b: (a,b) = (,) a b
06:15:58 <ignacio> Hafydd: anything but multiply two elements
06:16:00 <ignacio> just don't do that
06:16:23 <applicative> alexander__b: suppose we called the type Pair a b rather than (a,b), the the Functor would be Pair a
06:16:27 <Hafydd> What am I going to achieve with it?
06:16:36 <ignacio> great... things?
06:16:43 <ignacio> maybe a blog post or two
06:16:58 <Hafydd> Ah yes, the blog post - the pinnacle of intellectual achievement.
06:17:18 <applicative> ((,) e) and ((->) e) are a little alarming, admittedly, alexander__b
06:17:26 <Hafydd> (,) a b = (a,b)
06:17:48 <Hafydd> In the Haskell report, (a,b) is defined as a sugar.
06:18:57 <alexander__b> applicative: sooo... instance Functor (,) where? sorry, I'm not getting it.
06:19:20 <applicative> alexander__b: no, Functor can only have one open slot so to speak, it has to be the last parameter
06:19:21 <merijn> alexander__b: (,) can't be a functor for the same reason Pair can't be. A functor has one type argument, not two
06:19:32 <alexander__b> right
06:19:46 <merijn> alexander__b: Did you get the earlier example of "Either x" being a functor?
06:19:52 <applicative> so if i define data Pair a b = P a b , then I write instance Functor (Pair a) where ...
06:19:59 <alexander__b> merijn: sort of kind of when I think very hard about it
06:20:05 <alexander__b> merijn: it's still a bit witchcraft to me TBH
06:20:15 <merijn> alexander__b: ((,) e) is partially applied (,) type
06:20:20 <applicative> alexander__b: it is a little difficult because there are two different kinds of generality going on
06:20:41 <applicative> alexander__b: suppose I defined data StringPair a  = StringPair String a
06:20:42 <merijn> "fmap :: Functor f => (a -> b) -> f a -> f b" specialise to "f = ((,) e)"
06:20:47 <ion> alexander_b: “class Functor f where fmap :: (a -> b) -> f a -> f b”. If “f” is “(,) e”, what is the specialized fmap type signature?
06:20:53 <ignacio> last night I couldn't go to sleep because I was "debugging" a haskell expression in my head
06:20:57 <ignacio> ffs
06:21:13 <ion> ignacio: You should have used pattern matching instead of head.
06:21:20 <merijn> "fmap :: (a -> b) -> ((,) e) a -> ((,) e) b", resugar (,) gives: "fmap :: (a -> b) -> (e, a) -> (e, b)"
06:21:35 <applicative> alexander__b: then StringPair would be a Functor, instance Functor StringPair where fmap (StringPair str x) = StringPair str (f x)
06:21:40 <merijn> ion: "in his head" not "in head"
06:21:53 <ion> merijn: OH, REALLY?
06:22:15 <Hafydd> head (x:xs) = x -- Hafydd's implementation of head; DO NOT STEAL.
06:23:09 <applicative> alexander__b: but with the functor instance for (_,_), you are just doing this for String and everything at once, thus you have one variable and one missing variable in instance Functor ((,) a) or instance Functor (Pair a) or instance Functor (Either a)
06:23:22 <applicative> you are really defining infinitely many Functor instances at once
06:24:13 <alexander__b> applicative: I think maybe I shoudl do this after eating. I haven't eaten all day, and this is making my head hurt. thanks for the explanations though.
06:24:37 <applicative> oh no! i hope i'm not making things worse
06:25:22 <alexander__b> no, my level of grokking is at a status quo
06:25:33 <alexander__b> you did not deteriote it. :-)
06:25:38 <applicative> hah
06:25:48 <alexander__b> *deteriorate
06:26:13 <applicative> there is a little conceptual finesse in getting something like that, but once you're past it, you cant remember what you were thinking
06:26:17 <Fossilet> First time comer ;)
06:26:33 <alexander__b> applicative: yen I expect a lot of these things with haskell to eventually become intuition.
06:27:14 <merijn> alexander__b: What helps is to take types like these, grab a pen and paper and manually substitute/expand types
06:27:25 <alexander__b> applicative: will it be "instance Functor ((,) e) where" though?
06:27:33 <merijn> alexander__b: Yes
06:27:36 <applicative> alexander__b: its amazing how far that is true, it isn't just that you get use to it, it really is simple, but involves some funny movements of the mind to get through a door
06:27:41 <ion> alexander_b: Let me try to summarize this: “class Functor f where fmap :: (a -> b) -> f a -> f b”, “instance Functor ((,) e) where …”: f = (,) e therefore the instance’s fmap :: (a -> b) -> (,) e a -> (,) e b, that is, fmap :: (a -> b) -> (e, a) -> (e, b). If you can come up with an implementation of that type, you’ll have what you need for the instance definition.
06:27:46 <applicative> this keeps happening as long as you study it and like languages
06:28:00 <alexander__b> ion: that post has too much syntax for my brain to even begin to read it before I've had some food
06:28:06 <applicative> hah
06:28:15 <alexander__b> that I can smell the chicken from the kitchen does not help
06:28:40 <ion> alexander_b: Sure, take a break and think about it with a refreshed brain. :-)
06:28:58 <applicative> alexander__b: instance Functor StringPair and likewise instance Functor a-Pair, written instance Functor ((,)a)
06:29:48 <applicative> what was going on Fossilet
06:34:45 <Fossilet> Just learing Haskell and coming here for the first time :)
06:37:00 <Cale> Fossilet: Welcome! Let us know if you have any questions!
06:38:19 <mirari_> What is the human speakable name of <*> ?
06:38:42 <Banistertab> Mirari: ap
06:38:43 <Eduard_Munteanu> mirari_: mm, you could say "ap"
06:38:43 <Fossilet> Cale, I just came to pointfree and find it interesting :)
06:38:57 <mirari_> ah, makes sense
06:39:54 <yesthisisuser> hmm.. I'm looking at the acid-state tutorials.. came across this line: do HelloWorldState string <- ask
06:40:16 <yesthisisuser> not really sure about the HelloWorldState data constructor there
06:40:23 <Clint> it's pattern-matching
06:40:44 <yesthisisuser> how does it look "desugared"?
06:40:50 <lpaste> isomorphic pasted “case” at http://lpaste.net/91095
06:41:06 <isomorphic> ^-- what should this code print?
06:41:37 <Eduard_Munteanu> yesthisisuser: ask >>= \(HelloWordState string) -> ...
06:42:15 <yesthisisuser> ok. interesting
06:42:46 <Eduard_Munteanu> isomorphic: foo there merely binds the value to that name, it doesn't check for equality with foo
06:43:42 <Eduard_Munteanu> isomorphic: IOW, it matches anything
06:44:01 <isomorphic> Eduard_Munteanu:  And within the blocks in case, foo has the value assigned to val, above?
06:44:34 <Cale> isomorphic: yes
06:44:35 <Clint> only in the first block
06:44:39 <Eduard_Munteanu> isomorphic: yes... just like when you do    case somelist of (x:xs) -> ...
06:44:59 <Cale> The pattern foo overlaps with the pattern _ -- in fact, they both match everything.
06:45:02 <Eduard_Munteanu> The second case is dead code.
06:45:02 <isomorphic> Ah gotcha - Thanks Clint - I think I see why
06:45:54 <isomorphic> Cool.   foo is actually based on an enum that comes in via the FFI - what's a good way to do case-like check for this arrangement, eg: with values defined by functions?
06:46:15 <isomorphic> Am I back to chained ifs?
06:46:27 <Eduard_Munteanu> isomorphic: make it an Enum?
06:46:52 <Eduard_Munteanu> isomorphic: also you can match on number literals
06:48:10 <iri> I'm having trouble wrapping my head around the IO monad with the following code: http://hastebin.com/rahutatuxa.hs
06:48:36 <iri> It works if I just do "mapM process contents" and/or sort contents, but if I try to filter it, it doesn't. What am I missing?
06:49:13 <merijn> iri: contents :: [String], "filterM foo contents :: IO [String]"
06:49:36 <merijn> (because directoryExists has type "String -> IO Bool", presumably)
06:49:39 <iri> Oh, <- pulls the value out of the IO monad?
06:49:54 <merijn> not really
06:49:55 <iri> Right, I think that's what I was missing.
06:50:04 <Eduard_Munteanu> @quote shachaf.*bin.ls
06:50:05 <lambdabot> No quotes match. Whoa.
06:50:27 <merijn> iri: "do { x <- foo; bar x }" is syntactic sugar for "foo >>= \x -> bar x"
06:50:29 <iri> No, sorry, when I said "that's what I was missing" I was referring to String -> IO Bool.
06:51:05 <iri> merijn, where x is the "unpacked" foo? (i.e, the operation of reading from disk, or whatever)
06:51:11 <merijn> :t (>>=)
06:51:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:51:50 <merijn> iri: Yes, >>= performs monad-specific "magic" to compose something taking an 'a' and a monadic 'a'
06:52:04 <Eduard_Munteanu> @quote /bin/ls
06:52:04 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:52:06 <merijn> iri: Alternatively you can use a combination of fmap and join with your mapM
06:52:11 <merijn> :t fmap
06:52:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:52:13 <merijn> :t join
06:52:14 <lambdabot> Monad m => m (m a) -> m a
06:52:18 <wakalabis> Do you guys know of a list of haskell exercises, so that I can practice writing haskell code?
06:52:24 <merijn> @where exercises
06:52:24 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
06:52:35 <iri> merijn: thanks, I will digest this a little
06:52:46 <iri> (before asking further questions)
06:52:51 <wakalabis> merijin: thanks
06:53:05 <yesthisisuser> oh. right.. (\(Something x) -> foo x) is just the same as (\x -> case x of Something x -> foo x)..
06:53:14 <yesthisisuser> or
06:53:29 <mirari_> I just had an aha-moment.. The type of <*> for Applicative List is very interesting
06:54:26 <merijn> mirari_: Fun fact, there are two possible ways to implement Applicative for list
06:54:36 <iri> :t filterM
06:54:36 <Eduard_Munteanu> :t zipWith ($)
06:54:37 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
06:54:37 <lambdabot> [b -> c] -> [b] -> [c]
06:54:45 <mirari_> merijn so it seems, reading on that now
06:56:18 <wakalabis> haskell makes my head explode
06:56:42 <Eduard_Munteanu> It's a common side-effect. :P
06:56:51 <Nisstyre-laptop> wakalabis: other languages make my head explode
06:56:53 <wakalabis> I thought haskell was pure
06:57:04 <Nisstyre-laptop> try reasoning about the type safety of a wordpress plugin
06:57:15 <kryft> Nisstyre-laptop: haha
06:57:16 <wakalabis> If making my head explode is a side effect, then it can never be really pure
06:58:07 <mirari_> Nisstyre-laptop rofl
06:58:11 <mirari_> :D
06:58:36 <wakalabis> haskell sure has the best community
06:58:45 <mirari_> I don't even think you can define type safety for JavaScript / PHP
06:58:56 <isomorphic> Eduard_Munteanu:  Thanks :)
06:59:06 <Nisstyre-laptop> mirari_: true, I should've said exception safety
07:08:13 <iri> Okay, I have something which works.  Any advice how to improve it? http://hastebin.com/riguqepeli.hs
07:21:05 <ignacio> apparently hastebin doesn't work without JS
07:21:16 <iri> ignacio: ah, apologies
07:22:09 <lpaste> iri pasted “filterM” at http://lpaste.net/91096
07:22:45 <iri> hmm, it says "error redundant do" but ghc seems fine with it
07:23:10 <geekosaur> hlint is a bit sensitive
07:23:44 <quchen> iri: The warnings and errors LPaste gives you are HLint suggestions. "Warning" means that you should probably correct the suggestion, while "Error" means that you definitely should.
07:23:54 <geekosaur> (it's more of a coding stye critique than a syntax checker, in fact it won't complain at all about bad syntax)
07:23:55 <quchen> They aren't Haskell syntax errors or anything.
07:24:12 <iri> gotcha
07:24:24 <iri> any other improvements I could make to this code?
07:24:37 <quchen> Use spaces.
07:25:07 <quchen> The Haskell community has decided to indent using spaces only, and doing anything else gets you in an annoying tarpit of a discussion you don't wanna be part of.
07:25:35 <iri> acknowledged ;-)
07:27:00 <klrr> since i get so many errors, i guess it's my logic is what is wrong, anyone got an idea how to write this correctly?  https://gist.github.com/klrr/6048707
07:27:44 <aristid> quchen: sounds like you aren't a wholehearted believer in spaces-only! your soul must be purged.
07:27:57 <quchen> aristid: Go away.
07:28:05 <quchen> ;-)
07:28:18 <aristid> quchen: ah don't worry i wouldn't actually start a discussion now :P
07:28:46 <quchen> iri: Here's how I would have indented it. http://lpaste.net/91096
07:29:07 <quchen> Also note that you don't need to do a "let … in" in do blocks, you can just use a standalone "let".
07:29:49 <iri> what does "fmap not . X" do?
07:29:55 <iri> how does it read?
07:30:13 <Nisstyre> :t fmap not . x
07:30:13 <lambdabot>     Couldn't match expected type `a0 -> f0 Bool'
07:30:13 <lambdabot>                 with actual type `Expr'
07:30:13 <lambdabot>     In the second argument of `(.)', namely `x'
07:30:17 <quchen> That's just your function rewritten, iri.
07:30:30 <Nisstyre> :t fmap not . undefined
07:30:31 <lambdabot> Functor f => a -> f Bool
07:30:43 <quchen> You had the pointful "\x -> not <$> doesDirectoryExist x", the pointfree version of that is "fmap not . doesDirectoryExist".
07:31:28 <merijn> "\x -> not <$> doesDirectoryExist x" -> "\x -> fmap not (doesDirectoryExist x)" -> "fmap not . doesDirectoryExist"
07:31:37 <merijn> @src (.)
07:31:37 <lambdabot> (f . g) x = f (g x)
07:31:37 <lambdabot> NB: In lambdabot,  (.) = fmap
07:35:00 <klrr> anyone know any example code of using pipe 4.0?
07:40:34 <jmcarthur> klrr: pipes 4 isn't even released yet, is it?
07:48:12 <klrr> jmcarthur: nope but when i asked on mailing list he directed me to learn pipes 4.0 instead
07:50:17 <klrr> ive asked on mailing list instead now
07:52:29 <aristid> jmcarthur: it isn't, but using pipes 3 once you've seen pipes 4 would be just too painful :D
07:52:48 <aristid> he got rid of proxy transformers. no more runIdentityP
07:55:39 <simukis_> Oh awesome!
07:55:48 <jmcarthur> i agree that pipes 4 looks much simpler
07:55:51 <simukis_> that's what was hurting me the most!
07:56:04 <jmcarthur> i'm glad Tekmo has been focusing on simplifying it
07:57:44 <aristid> yes, he also seems to plan on partially dekleislifying it, although i'm not sure that will be a net simplification
07:58:56 <wakalabis> what does haskel.org run on? snap? yesod? php?
07:59:09 <luite> php
07:59:19 <yesthisisuser> hmm
08:00:15 <wakalabis> Who is worse shod than the shoemaker's wife
08:00:19 <Demos> not even Acme.PHP
08:00:20 <wakalabis> ?
08:32:57 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
08:32:57 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
08:35:10 <jmcarthur> since there are only four cases, i'll just enumerate them to make sure i'm clear.  if the type needs to be (F a -> F b) then i must use foo. if the type needs to be (F a -> G b) then it doesn't matter which one i use. there is no inhabitant for (G a -> F b). if the type needs to be (G a -> G b) then i must use bar.
08:35:24 <jmcarthur> writing all that out makes me wonder if the right thing to do is just to use a MPTC
08:40:06 <S_J> is it possible to use QuickCheck for C code or should i use the Erlang/QuViq quickcheck then?
08:41:49 <jmcarthur> S_J: if you bind the C functions then it's trivial to use QuickCheck to test them
08:46:55 <S_J> bind? you mean FFI?
08:46:59 <jmcarthur> yes
08:47:15 <S_J> no quirks associated with it?
08:47:35 <applicative> S_J: I thought there were some demos of C uses on the quviq site
08:48:15 <applicative> S_J: oh, that's basically what you're saying you want to haskell qc
08:48:23 <klrr> chrisdone: https://github.com/chrisdone/lpaste/issues/16 found a small bug in lpaste, tried solve it but in the source code the Irclog.hs searches a different website than the one running at lpaste.net so i didnt dare touching it
08:48:25 <applicative> you want to use Haskell
08:50:09 <lpaste> applicative pasted “more pipes nonsense” at http://lpaste.net/91100
08:50:32 <applicative> klrr: here's some more ringing of the changes ^^^
08:50:44 <klrr> applicative: thanks :)
08:50:59 <applicative> klrr: i'm still trying to get accustomed to the new picture he has going
08:51:36 <applicative> klrr: but for example the last line is something like the preferred form for this echo
08:51:39 <applicative> manytimesModerne = runEffect $ client1 //>  server1
08:51:47 <notdan> Is this the code using the new pipes-4?
08:51:52 <klrr> notdan: yes
08:51:59 <notdan> cool
08:52:16 <applicative> yes, but I was trying to bring out the preference for the style I just used
08:52:43 <applicative> there will be more use of pointy combinators instead of >-> >~> you will use 'for' and so on
08:52:56 <klrr> i wanna rewrite my irc bot with pipes :) simulating the server im connecting to in the code itself as a Server
08:53:29 <applicative> notdan: so if client1 is forever getting lines and sending them on
08:53:43 <applicative> manytimesModerne = runEffect $ client1 //> lift . putStrLn
08:54:00 <applicative> is the whole story, you don't make a second recursive printer so to say
08:54:19 <klrr> chrisdone: is the source code for lpaste outdated on github? cause the one on github is using another irc log than the one online, why is that?
08:54:19 <applicative> thats just one point, i am still trying to get others ;)
08:55:45 <klrr> ive heard many people say that why haskell was not homoiconic was due to a good paper someone wrote about it, anyone know which paper?
08:57:05 <S_J> applicative, jmcarthur: yes im learning quvic now, im just wondering if the Haskell quickcheck, the original, is easy to sue with C. which is betetr if you have used both?
08:57:22 <jmcarthur> i've not used quvic
08:57:43 <applicative> jmcarthur: but you've qc'd C via the FFI?
08:58:00 <klrr> what's quvic?
08:58:05 <applicative> klrr:
08:58:23 <applicative> a company that puts quickcheck artillery on your code
08:58:37 <applicative> using Erlang as their main internal language
08:58:55 <applicative> I wonder if it's doing well>
08:59:08 <klrr> ive never used quickcheck, you mean they write tests for you?
08:59:11 <banister> applicative: have oyu looked into elixir (the ruby-like language built on top of the erlang vm)
08:59:27 <klrr> http://www.wideanglesoftware.com/quivic/ <- that? says no longer for sale
08:59:50 <klrr> that was some unrelated youtube stuff sry
08:59:54 <klrr> dont click the link
08:59:56 <applicative> http://www.quviq.com/index.html
09:00:04 <klrr> okey thanks
09:00:14 <applicative> my the typo was my fault sorry
09:00:16 <jmcarthur> applicative: i have, but not much
09:00:27 <klrr> okey there software writes tests for you :)
09:00:32 <notdan> It's a company where John Hughes work, isn't it?
09:00:35 <mirari_> Is it true that the "tree monad" (a monad on a binary tree)'s <*> (app) takes a tree of functions and a tree of values and applies the function at each node to its corresponding value in the tree (i.e. at the same place)?
09:00:38 <notdan> oh yeah
09:00:43 <applicative> notdan: yes
09:00:48 <notdan> they build quickcheck or erlang and stuff
09:00:49 <notdan> iirc
09:00:59 <applicative> there's a really good video somewhere of Hughes hawking it at some google thing
09:01:03 <jmcarthur> klrr: quickcheck lets you write properties and generates inputs to test it with. it doesn't generate the actual tests. it would have no way to know what tests to generate.
09:01:19 <applicative> the irrationality of the 'unit test' culture is brought out with immeasurable force
09:01:38 <jmcarthur> mirari_: no, that doesn't sound right, unless the tree has a static shape
09:02:00 <mirari_> jmcarthur: this is what the types lead me to think
09:02:33 <jmcarthur> mirari_: for the tree to be a monad it must either have a static shape (in which case it would behave the way you described) or all the values must be at the leaves, not internal nodes (in which case the result will be some combinatorial explosion of the inputs)
09:02:55 <klrr> jmcarthur: okey
09:03:36 <jmcarthur> mirari_: the leaves of the left tree would be replaced with copies of the right tree, where the values are replaced with the results of applying the function that was replaced in the left tree to the value that was there before
09:03:43 <mirari_> jmcarthur this is similiar to a list right? (if we *don't* take the non-deterministic interpretation)
09:03:45 <jmcarthur> that was awkwardly phrased
09:04:09 <jmcarthur> mirari_: the combinatorial explosion thing is actually very much like the non-deterministic interpretation
09:04:11 <applicative> the hughes video i was thinking of I think is http://www.youtube.com/watch?v=XgasxJWgZBM this, from the ICFP, I feel like there was a version at google too
09:04:23 <jmcarthur> mirari_: the "choice" is just dependent on which path to a leaf you take
09:04:30 <jmcarthur> *on which leaf you choose
09:04:53 <jmcarthur> the only difference is that there are paths involved, whereas the list monad hides all that
09:04:55 <Saizan> yeah, in place of the original leaf you'll get a whole new tree
09:05:37 <mirari_> I'm a bit confused. First things first, are you saying that a tree which stores its values in the internal nodes is not a monad?
09:05:54 <jmcarthur> mirari_: it can be as long as it has a static shape, but i doubt this is what you are talking about
09:06:08 <mirari_> yeah, it would make little sense to have a static shape
09:06:20 <mirari_> so the values should be in the leaves?
09:06:35 <jmcarthur> mirari_: there are also other kinds of special cases where values in the internal nodes can make sense
09:06:37 <jmcarthur> mirari_: e.g. lists
09:06:49 <jmcarthur> mirari_: but for general trees, yes, the values need to be in the leaves
09:07:09 <mirari_> ok, let me try that
09:08:19 <jmcarthur> mirari_: if it is not this way, then you can't substitute entire trees in place of the values without doing something fancier (e.g. with lists the fancy thing is concatentation)
09:08:31 <jmcarthur> mirari_: when all the values are in the leaves, they can just be replaced with new tree
09:08:33 <jmcarthur> *trees
09:08:54 <mirari_> starting to make sense :)
09:12:46 <applicative> zvrba: oh i made a mistake in that paste, the last line should be manytimesModerne = runEffect $ client2 //>  server1
09:12:58 <S_J> applicative: "the irrationality of the 'unit test' culture is brought out with immeasurable force", how do you mean?
09:13:14 <applicative> well, I mean, he does it with great art.
09:13:29 <applicative> S_J: you have a pile of unit tests, you run them each night
09:13:38 <applicative> each corresponds to some past bug
09:14:07 <applicative> with quickcheck you test general properties
09:14:18 <applicative> every night you accumulate more evidence, more cases
09:15:11 <mirari_> I'm looking at <*>, it gets a Tree[A => B] and a Tree[A], now how should its implementation behave? Should it be: Whenver we find a value (i.e. in a leaf) then we apply that value to the entire tree [A => B] to produce a new tree and then attach this tree? (Sorry for using non-haskell syntax. I'm doing a haskell tutorial in Scala)
09:15:47 <jophish> Yo yo yo!
09:16:00 <applicative> the unit test people are under the impression that when you modify code, any bug is likely to be the one you used to have and put among the unit tests
09:16:01 <notdan> Hm, doesn't runhaskell support MIN_VERSION_* macros?
09:16:17 <applicative> hm, is that a cabal thing, notdan
09:16:20 <S_J> applicative: it corresponds to some past bug it is a regression test, isnt it? a unit test you would have written before you wrote the code...
09:16:22 <notdan> oh
09:16:33 <notdan> yeah,. true
09:16:44 <S_J> applicative: i see your point though
09:16:51 <applicative> well, fine, the point is that the orientation is not toward generality in test
09:16:59 <applicative> toward 'properties'
09:17:28 <applicative> and then a mechanism that can over time go through indefinitely many cases
09:17:50 <S_J> applicative: I see. Am I right to assume though that qithout soem code coverage analysis, quickcheck is a bit, well it is hard to know what yopu really tested sicne it is random.
09:17:54 <applicative> yes i was putting types of test together, the point is they dont uh, do quickcheck
09:18:03 <jmcarthur> mirari_: i think it's easier to think about what (>>=) should do than what (<*>) should do, in this case.
09:18:13 <jmcarthur> mirari_: because it is a bit more constrained
09:18:21 <S_J> What can you say about defining properties so that random tests actually test them and not just miss the errors by bad luck.
09:18:29 <enthropy> S_J: have you seen hpc (haskell program coverage)?
09:18:47 <jophish> I've written a compiler in C++, and would quite like to implement it in Haskell. In my C++ I use a custom recursive descent parser which allows me to be quite flexible with error messages and bad input. For example if there are some mismatched parentheses in an expression I can log an error message about this and skip until the next semicolon (statement end). Parsec seems to be a pretty popular parser frame
09:18:48 <jophish> work for Haskell, but I'm unsure if it can give me these nice systems (bespoke error messages) (skipping over bad input until we know where we are again). What do people suggest?
09:19:06 <jmcarthur> mirari_: for some tree t and some function f, t >>= f would visit every value in t, replacing the entire leaf it's in with the result of applying f to it
09:19:07 <applicative> S_J: I would have thought no, the thought is that the practice is you 'run the test' each night. If the code base never changes, in fact you end up with a total test since, crudely all Int/Char/String etc combinations have been tested
09:19:18 <S_J> enthropy: yes, i have played with it. Problem is i mostly code in C and thats where i want to applyc quickcheck. so im trying to learn more about property testing, it cons and pros and find the best tool to use it for C
09:19:22 <jophish> Also, I've not been able to find much information on how Parsec handles preprocessed files, especially with regards to line numbers.
09:20:09 <applicative> S_J: in any case I am just repeating Hughes badly and from 2 yrs memory
09:20:18 <jmcarthur> S_J: there's also SmallCheck, which exhaustively enumerates all possibilities up to a specified input size. for a small enough domain, it is a sufficient *proof* of correctness. for domains that are still too large, it's at least a proof for smaller sizes.
09:20:21 <S_J> I see, I will watch the link
09:20:56 <banister> applicative: if hughes and conal elliot could have a fight but their fighting avatars embodied their prowess in haskell, who would win
09:21:00 <applicative> S_J: If I remember rightly, its one of those cases where a video is worth watching. Usually I would much prefer the slides....
09:21:26 <mirari_> jmcarthur: I see, let me see if I can implement >>=
09:21:48 <jmcarthur> S_J: and there's also LazySmallCheck which has some intelligence for certain kinds of properties to eliminate entire classes of inputs with a single test
09:21:50 <applicative> banister: lennart augustsson would enter the ring and break their heads against each other
09:22:17 * conal needs a chat-bot that chimes in every time someone misspells his last name.
09:22:21 <jmcarthur> S_J: for certain kinds of properties, LazySmallCheck can prove their correctness, even with an infinite number of inputs sometimes
09:22:29 <applicative> did i
09:22:31 <applicative> oh i see
09:22:36 <applicative> conal, no you would win!
09:23:21 <applicative> or, Mr Elliott to you
09:23:26 <mirari_> jmcarthur: >>= constructs a new tree t from t by replacing all leafs in t with
09:23:28 <mirari_> woops
09:23:58 <mirari_> jmcarthur: >>= constructs a new tree t' from t by replacing all leafs in t with a new subtree computed by  A => Tree[B] ?
09:24:08 <jmcarthur> mirari_: that sounds right to me
09:24:11 <mirari_> jmcarthur like a list
09:24:12 <mirari_> yeah
09:24:34 <lpaste> applicative revised “more pipes nonsense”: “more pipes nonsense” at http://lpaste.net/91100
09:24:39 <jmcarthur> mirari_: another way to think of monads:  "return" => "variable", "bind" => "substitution"
09:25:08 <mirari_> jmcarthur return is "pure" right?
09:25:11 <jmcarthur> mirari_: yup
09:26:58 <Saizan> jophish: I think parsec has primitives to query and set line numbers so that should be fine, it has good support for custom error messages too (that was one of the main goals of the lib), skipping and restarting might need a bit of thinking, but a loop external to the parsec parser could be a solution
09:27:27 <applicative> zvrba: I take you saw the pipes - related networking module Renzo C made for pipes-4 https://github.com/k0001?tab=repositories
09:27:36 <applicative> packages, rather
09:27:56 <applicative> parsec is all about error messages jophish
09:28:04 <applicative> that why we use attoparsec!
09:28:26 <Saizan> jophish: otherwise you might want to look at so-called online parsers, which tend to just a accumulate a list of errors and proceed by "correcting" the input text, or have a pre-parsing that divides the input into independent chunks
09:28:45 <jophish> Saizan: that sounds exactly what I want
09:29:54 <jophish> applicative: attoparsec is a specialised version of parsec?
09:29:55 <applicative> http://hackage.haskell.org/package/uu-parsinglib
09:30:31 <applicative> jophish: it is or was faster because bytestring and then text were the focus, but it didn't bother with extensive error machinery.
09:31:08 <applicative> it isn't really for parsing programming languages i wouldn't think.  that's a crucial part of the parsec and uu idea though
09:31:25 <jophish> ah, I probably prefer ease of use and error messages over speed at the moment
09:31:32 <applicative> though they can do what you please.  uu doesn't do text and bytestring I think
09:31:48 <applicative> jophish: yes i think that's characteristic for a programming language
09:31:57 <applicative> nobody writes a half-gigabyte script
09:32:02 <jophish> exactly :)
09:32:09 <Saizan> http://hackage.haskell.org/package/trifecta <- also nice
09:32:21 <applicative> right trifecta, I forgot about that
09:32:38 <applicative> dylukes had a little language implemented with it
09:32:40 <jophish> gosh, colored error messages. I'm sold
09:33:26 <jmcarthur> the documentation is the main problem with trifecta
09:33:34 <applicative> https://github.com/DylanLukes/Winchester-STG-Compiler hah, it's named for the high school around the corner from me
09:34:15 <applicative> yes trifecta predates edwardk's discovery of the merits of documentation
09:35:12 <jophish> Parsec certainly seems to be the most widely used of these
09:35:31 <applicative> i mentioned the 'stg-compiler' since it uses trifecta and i know he was in forever back and forth with edwardk
09:36:10 <applicative> jophish: yes it bread and butter haskell really
09:36:38 <applicative> for simple purposes using attoparsec though is hardly different, modulo familiar parsing subtleties
09:37:11 <applicative> the main parser 'combinators' always end up being pretty much the same
09:38:12 <applicative> note that this doesn't import any parsing library at all https://github.com/ekmett/parsers/blob/master/src/Text/Parser/Combinators.hs
09:38:46 <jophish> I might see if I can find an elegant way of skipping bad code (à la Clang)
09:39:31 <notdan> http://lpaste.net/91102 So I have a question about strict/lazy evaluation. How can I make sure that 'rw w' part gets fully evaluated when the workers' is requested/needed?
09:39:47 <notdan> The next line is actually: "atomically $ writeTVar wrkrs workers'"
09:40:02 <notdan> should I worry about 'rw w' not getting evaluated?
09:40:29 <applicative> if you are you can seq them of course.  the monad may matter to this
09:40:31 <Saizan> yeah
09:40:44 <Saizan> workers' <- forM workers $ \(w, rw) -> (,) <$> rw w <*> rw
09:40:46 <applicative> oh i see where you are
09:41:11 <Cale> notdan: Probably you mean the result of executing the action rw w?
09:41:30 <applicative> you are carring a function in the tuple?
09:41:34 <jophish> Thanks very much, applicative, Saizan
09:41:39 <notdan> Cale: yes, I mean exactly that
09:41:56 <Cale> notdan: and for that, you could write something like  pair !x y = (x,y)  and use that in place of (,)
09:41:58 <applicative> jophish: good luck, people here know a lot about parsing, so ask them if you get stuck
09:42:11 <jophish> will do, Thanks again
09:42:35 <notdan> applicative: because I need to store some functions paired with some values
09:42:38 <notdan> I mean, why not?
09:42:53 <applicative> no reason why not, sorry.
09:43:21 <applicative> its just that at first I said well seq if you need to, but that doesn't do much for a function
09:43:22 <Gracenotes> 'rw w' looks like it should be executed, assuming your monad itself is somewhat strict
09:43:30 <notdan> Cale: thanks, I'll try that
09:43:37 <notdan> Gracenotes: well, my monad is IO
09:43:39 <Gracenotes> otherwise, it could leave monadic actions in a thunk
09:43:47 <Gracenotes> ah, IO is pretty strict.
09:43:50 <notdan> and I am also using "workers'" in the STM monad
09:43:54 <Saizan> yeah, the side-effects are going to be executed
09:44:17 <Saizan> nothing in that code is forcing evaluation of the result though
09:44:52 <Gracenotes> I would assume, from that code sample, that you would execute whatever action is required to return from 'rw w', but it may not e.g. do some pure computation at the tail end of that.
09:44:56 <Saizan> notdan: btw Cale's pair will only force the outermost constructor of x, which might not be enough if it has many parts
09:45:24 <applicative> Saizan is right that some things will depend on what happens next with workers'
09:46:09 <Gracenotes> (or pure computations safely interleaved with the IO actions, but without direct dependencies)
09:47:09 <Saizan> yeah, it's maybe better to make rw responsible for the forcing
09:47:14 <notdan> Right. Thanks.
09:47:24 <notdan> Saizan: that's what I decidede to do.
09:47:33 <notdan> Lazy evaluation always bites me :S
09:50:15 <applicative> what is the return type of rw?
09:51:15 <applicative> there is also the expedient of a strict pair type, for one aspect of this. somehow they never do much for me
09:51:59 <applicative> notdan have you seen tibbe's tutorials? they go a bit overboard on some points but are good
09:52:05 <notdan> rw :: Worker a -> m (Worker a), but usually m ~ IO
09:52:09 <notdan> applicative: no I haven't
09:52:16 <notdan> I would be glad if you could link them to me
09:52:20 <applicative> http://www.slideshare.net/tibbe/highperformance-haskell there are others around
09:52:49 <notdan> Thanks
09:53:10 <applicative> here's a sort of case study of designing a type http://www.scs.stanford.edu/11au-cs240h/notes/performance.html#(1)
09:54:32 * hackagebot fclabels 1.1.7 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.7 (SebastiaanVisser)
09:55:01 <applicative> I think there's a few too many bangpatterns around, the best part is about getting strictness and perhaps unpackedness in types where that makes sense, then bang patterns arent needed
09:55:12 <applicative> i mean in tibbes notes ^^^
09:55:48 <applicative> a delicate point is that though (,) is lazy, like lists, the compiler is incredibly good with them
09:55:49 <monochrom> tibbe likes to add more bangs :)
09:56:22 <notdan> Cool, thanks for the links :)
09:56:24 <applicative> yeah I think he might have a different view now, going by blurry memory from the not too distant past
09:56:56 <applicative> I think that the wisdom: really think about adding !s to the parameters in your types is a good one
09:57:34 <applicative> even recursive ones, if anticipate that they will be small and so on, not sure what criteria could be precisely formulated
09:58:23 <applicative> monochrom and i were arguing with him on here not long ago, he was even putting ! on String and function parameters because -- he said -- it should be your default
09:58:46 <applicative> he was thinking pedagogically
09:58:57 <applicative> i think we thought: a little too pedagically.
09:59:12 <applicative> bah typing
09:59:19 <monochrom> yes, I remember that discussion :)
10:00:07 <notdan> Oh I remember that I was a little bit surprised too when I was reading his haskell style guide
10:00:10 <applicative> I saw his point, but I thought it doesn't take long to explain 'functions are different' ; things that are already ultralazy are different etc
10:00:20 <applicative> notdan: right, thats how it came
10:00:24 <applicative> up
10:01:10 <applicative> he, if i understood, thought beginners might be reading it, and they might as well put ! on every parameter
10:02:42 <Gracenotes> functions are fairly arbitrary boundaries of computation
10:03:54 <elliott> it seems like the style guide recommends function parameters being lazy
10:03:58 <elliott> (but not constructor parameters)
10:03:58 <Gracenotes> modulo all that software engineering reusability stuff
10:04:27 <applicative> elliott: you mean just writing f x = ... and not f !x = ...
10:04:28 <applicative> yes
10:05:16 <applicative> my impression is that the going pedagogical wisdom -- I could use a bit -- is that you should make your constructors strict, and then forget about it
10:05:52 <elliott> strict constructors sounds like an awful default to me in Haskell
10:06:00 <applicative> it does
10:06:08 <applicative> thats why its pedagogical wisdom
10:06:22 <applicative> for recursive types it really repels me
10:06:51 <applicative> but many have agreed that if you make your types strict in all parameters youll never see a space leak
10:07:09 <applicative> of course i can produce good space leaks with just Prelude types ;)
10:07:32 <notdan> Well for recursive types you might actually want laziness if you want to have an infinite type/term
10:07:42 <applicative> certainly then yes
10:07:54 <Saizan> or even just stream-like processing
10:08:01 <applicative> but if I'm thinking of binary trees that will at most be ten nodes deep
10:08:34 <notdan> But I guess you can actually construct an infinite type even with strictness annotations. I read somewhere on Bob Harper's blog that it's the reason you can't express Peaon arith in Haskell
10:08:49 <notdan> but I am not sure if that's 100% correct because I don't know much aboutlaziness
10:08:49 <Gracenotes> infinite terms are a bit gimmick-y, but mostly laziness improves modularity quite a bit.
10:08:52 <applicative> but where you are doing 'stream like processing' from their point of view the type is sort of a control thing, not genuine 'data' so to say
10:09:06 <applicative> infinite terms are not gimmicky, doing without them is
10:09:53 <applicative> notdan: i don't know what inf = S inf is when data N = Z | S !N
10:09:59 <notdan> Saizan: hm, I might be wrong but I thought that you need strictness especially if you are doing stream-like processing
10:10:01 <applicative> but it exists, that was his point
10:10:11 <notdan> that's the problem with lazy IO, isn't it?
10:10:22 <applicative> whats the problem with lazy IO
10:10:54 <applicative> i mean which of the above were you thinking of
10:11:02 <merijn> applicative: Quite a bit, things like odds behavior in case of exceptions and resource leaks
10:11:11 <notdan> applicative: yeah, I guess it's not related to evaluation strategies at all
10:11:24 <applicative> merijn: i'm familiar with it, I was trying to understand notdan
10:11:32 <notdan> applicative: I was refering to Saizan's comment that you might want laziness if you are doing stream-like processing
10:11:37 <applicative> yes
10:12:02 * applicative suspects Saizan shares his secret love of lazy io wherever possible
10:12:02 <Saizan> notdan: lazy IO is not just laziness, it's side-effects piggy-backing on laziness
10:12:03 <notdan> but I thought all the streaming-data libraries like conduit and pipes were using strict evaluation mainly
10:12:06 <Gracenotes> I mean, you rarely need actually infinite terms, but being able to structure your code based on codata lets you focus more on the actual flow of data and less on manually organizing the granularity of computation.
10:12:07 <notdan> oh
10:12:58 <applicative> Gracenotes: if you dont allow infinite terms, you have to explicitly control for length, e.g. of lists in each use. it's moronic
10:13:02 <Saizan> notdan: but i meant to use stream-processing more generally, i.e. incremental construction of some value, which is useful even for finite ones
10:13:23 <applicative> you cant write zip mylist [1..]  this is not trivial
10:13:25 <monochrom> "stream-like processing" does not refer to I/O. rather, it refers to things done in vector
10:14:15 <Saizan> notdan: e.g. map (+1) [1..10^6] works in constant space if you consume the result linearly as well
10:14:50 <Gracenotes> applicative: yes, you would have to introduce something like izip, but what I mean is that they are a happy by-product of non-strict semantics, but rarely approach anything more substantial than 'clever'
10:14:51 <applicative> reverse $ map (+1) [1..10^6] bad
10:15:49 <davd> [pipes] anyone got an idea on how to use Control.Proxy.TCP.socketReadTimeoutS and Control.Proxy.Binary.decodeD together? mismatch in EitherP argument and an additional StateT layer for decoding. I only care about termination when failing.
10:15:57 <applicative> we do things like zip mylist [1..] all over the place in haskell, that was just a sort of demo example
10:16:24 <applicative> otherwise many operations require controlling for the size of the structure and then comes mistakes
10:17:36 <applicative> I really think the potentially infinite types are no joke, even if one would like unrelentingly finite ones too
10:18:01 <applicative> davd: hm, our thoughts have all turned to pipes-4.0
10:18:11 <applicative> man, i'm talking too much today, sorry
10:18:53 <applicative> davd let me look, in theory i know about pipes, but tcp uh, no
10:19:06 <davd> just paste, wait one second.
10:19:09 <davd> pasted*
10:19:48 <davd> (isn't it supposed to post new links?) - http://lpaste.net/91103
10:20:13 <davd> yeah, pipes-4.0 looks great, but all dependencies seem to be stuck on 3.3 at the moment..
10:23:14 <aristid> oh i think i understand the fuss about the change to push-based pipes a bit more now. it allows getting rid of most of the stupid () function arguments.
10:23:16 <davd> so I'm trying to model a pipeline where bytes are read, parsed into the corresponding ADT, and then sent into an Input (from pipes-concurrency).
10:24:14 <aristid> davd: would it be a stream of those ADTs, or one huge ADT?
10:24:28 <davd> aristid: several different
10:24:39 <jophish> hello again, installing some packages with cabal. I'm on OSX, all the packages I'm installing throw loads of warnings during preprocessing. Mostly "warning: missing terminating ' character [-Winvalid-pp-token]"
10:24:57 <aristid> davd: i think you want a Monad m => Pipe ByteString MyADT m ()
10:25:10 <jophish>      error: '#' is not followed by a macro parameter #define FSLIT(x) (mkFastString# (x#))
10:25:11 <jophish> I get one error installing cairo:
10:25:29 <jophish> Is this a well known problem with an easy fix, or should I dig a little deeper?
10:26:46 <jmcarthur> aristid: yeah, i came to the same conclusion while writing my own ocaml implementation of pipes. my decision to focus on push-based was originally motivated by the fact that for IO and, especially, strict languages like ocaml, push-based is a bit more intuitive, and i only discovered this other benefit later, that everything can really look like bind.
10:27:37 <aristid> jmcarthur: it looks like Tekmo is making exactly the same discoveries, a bit later than you :)
10:27:37 <jmcarthur> aristid: that having been said, it's also true of pull-based architecture, but you have to use the flipped bind, which many people aren'
10:27:40 <jmcarthur> *aren't used to
10:27:43 <aristid> jmcarthur: but he's using a real language :P
10:27:51 <jmcarthur> true true
10:31:25 <davd> aristid: yeah, the type signature you gave looks right. I'm not really sure however how to integrate it with the proxy transformers (as mentioned above).
10:32:42 <aristid> davd: well, proxy transformers are a thing of the past! :)
10:32:46 <aristid> or present
10:32:52 <aristid> but with Tekmo that's the same thing :)
10:33:07 <monochrom> yikes, past = present
10:33:37 <davd> yikes, I should have put my vacation a few weeks later :)
10:33:53 <aristid> davd: is this your haskell hacking vacation?:D
10:34:00 <davd> yeah
10:34:06 <aristid> ah
10:34:21 <aristid> davd: well you could use the github version of pipes:)
10:34:22 <davd> pipes is still great though :)
10:35:01 <davd> sure, but the dependencies are still at 3.3 (such as pipes-binary). I'm not really capable of rewriting them as of now.
10:37:15 <applicative> yes i dont see a pipes-binary-4.0
10:37:51 <applicative> man, the types will be much easier now dav
10:37:53 <applicative> davd
10:38:18 <applicative> EitherP StateP all end up inside as EitherT x (StateT s m))
10:38:31 <davd> yeah, that's great!
10:39:25 <applicative> as you had it socketReadTimeoutS needed more arguments, but getting the transformer from the binary one, to fit the transformer the tcp module is a little rough
10:40:00 <davd> yeah, it was given only as an outline of the pipeline.
10:40:17 <davd> maybe I should wait for 4.0 to stabilize..
10:40:42 <applicative> yes, i saw that the main problem was matching the 'pipe' types
10:40:54 <davd> indeed.
10:41:38 <davd> I've been thinking about how cool it would be to use something like djinn for stuff like this. have you heard of anyone using it in development?
10:41:55 <davd> highly abstract should be a perfect fit, I guess.
10:47:05 <mellum> So, I want to generate all unordered pairs from a list, like from [1, 2, 3] [(1, 2), (1, 3), (2, 3)]. Can I do this with list comprehensions somehow?
10:47:06 <Cale> davd: djinn is very limited in scope
10:47:12 <mm_freak> side note:
10:47:14 <mm_freak> @google blah
10:47:15 <lambdabot> http://www.urbandictionary.com/define.php?term=blah
10:47:16 <lambdabot> Title: Urban Dictionary: blah
10:47:19 <mm_freak> huh?!
10:47:25 <mm_freak> @google usenet
10:47:26 <lambdabot> Plugin `search' failed with: user error (https not supported)
10:47:28 <mm_freak> ah, there
10:47:50 <elliott> it can't fetch titles of https pages
10:47:51 <Cale> mellum: You sure can
10:48:06 <Cale> > [(x,y) | (x:xs) <- tails [1,2,3], y <- xs]
10:48:07 <lambdabot>   [(1,2),(1,3),(2,3)]
10:48:26 <mellum> Cale: thanks
10:48:35 <S_J> anyone that has used quviq for C? i cant compile my code as the tutorial movie does it
10:48:36 <mellum> would this be, like, the most canonical way to do it?
10:48:55 <applicative> davd: this typechecks for example \x y z -> socketReadTimeoutS x y z >-> liftP . (mapD Just >-> decodeD >-> printD)
10:49:11 <monochrom> yikes, blah means depressing. I should use it less in my examples.
10:49:11 <applicative> it's two EitherP's deep though
10:49:14 <davd> applicative: " liftP . liftP . f >-> mapD Just >-> g" actually typechecks. since I only care about termination it might actually produce the wanted result in practice. still no reuse of EitherP though (explicitly layered twice).
10:49:25 <applicative> oh, there you are
10:49:30 <davd> hmm..
10:49:38 <monochrom> "data X blah bleh = ..." => "data X happy joy = ..." :)
10:49:51 <davd> applicative: does your version "reuse" the EitherP?
10:50:18 <applicative> davd oh yeah
10:50:28 <davd> excellent! :)
10:50:35 <davd> applicative: thanks, you're awesome!
10:51:18 <applicative> or maybe i dont understand you. anyway its clearly a matter of adjust liftP s
10:51:54 <applicative> Thanks to cabal sandbox I now how the hackage pipes machinery and the github pipes machinery on a single machine
10:52:01 <applicative> and I almost know what I'm doing!
10:52:36 <davd> applicative: I believe we are talking about the same issue, since our versions different amounts of liftP.
10:52:47 <davd> versions use *
10:52:55 <applicative> yeah
10:53:02 <applicative> well see what actually happens!
10:53:40 <mm_freak> elliott: but it should =)
10:54:04 <davd> Cale: any specific issues with djinn for more larger projects? (such as pipes)
10:54:38 <applicative> I can't yet have master having a sandbox with several co-developed packages, I wish someone would write an idiot's guide
10:55:48 <notdan> if I have package A that depends on package B I do this to build A: cabal-dev install ../B ./ (in the A's folder)
10:56:07 <notdan> Or I do cabal-dev add-source ../B && cabal-dev install --only-dependencies
10:56:11 <Cale> davd: Djinn is generally only useful to infer terms with highly polymorphic types which don't involve recursive types at all.
10:56:35 <elliott> applicative: cabal sandbox init; cabal sandbox add-source pkg1 pkg2 pkg3 main-pkg; cabal install ./main-pkg should do it
10:56:45 <davd> Cale: ah, okay.
10:57:45 <Cale> davd: It's basically a proof search for a fragment of intuitionistic logic which is decidable, which then writes out the proof as a Haskell program.
10:57:47 <notdan> elliott: is this the new Cabal?
10:58:11 <applicative> Cale he just needs a more powerful djinn, like the awesome https://github.com/luqui/Djest
10:58:19 <elliott> notdan: yes
10:58:31 <applicative> the programming language where you dont have to write the code, just the unit tests
10:59:27 <applicative> elliott: yes, thats pretty much what I was doing, but I wanted just to build ./my-pkg
10:59:56 <applicative> i guess there's not a problem, i just feel i'm lacking in some obvious simplifying insight
11:00:18 <elliott> well, after that you can just do the install line
11:00:22 <applicative> elliott: i meant, i just do cabal build on my project
11:02:05 <Eduard_Munteanu> Grr, is there an extension that allows empty record updates?
11:02:27 <applicative> whats and empty record update? foo {}
11:02:36 <Nisstyre> why would you want that?
11:02:37 <Eduard_Munteanu> applicative: yes
11:02:48 <Eduard_Munteanu> Nisstyre: because I'm laying out my code ahead of time
11:02:52 <Nisstyre> oh ok
11:05:14 <applicative> Eduard_Munteanu: theres only one solution
11:05:27 <applicative> add {#LANGUAGE RecordWildCards, RecordPuns, DisambiguateRecordFields, TraditionalRecordSyntax#--}
11:05:30 <applicative> and see what happens
11:05:35 <Eduard_Munteanu> Haha.
11:05:58 <applicative> i wonder what TraditionalRecordSyntax means
11:06:13 <applicative> if only we had traditional record syntax ...
11:07:11 <Hafydd> {-# LANGUAGE TraditionalLanguagePragmaSyntax #-}
11:07:39 <applicative> oh I see, NoTraditionalRecordSyntax is the extension
11:09:03 <Eduard_Munteanu> They should rename that to RefractoryRecordSyntax to make sure you don't want it.
11:11:40 <Eduard_Munteanu> Hm, quicker solution... turn '{ }' into '{- -}'.
11:12:03 <applicative> mdo is still legitimate right?
11:12:09 <applicative> haha
11:14:04 <applicative> ah, yes its still there with RecursiveDo
11:14:31 * Eduard_Munteanu should get hasktags or something, typing find commands gets annoying quickly, but no Gentoo ebuilds for that it seems
11:14:41 <applicative> that suggests that theres a place in parser where one might skillfully introduce 'ado' or 'mydo' or something
11:15:21 <Eduard_Munteanu> do-bee-do-wop
11:15:59 <applicative> do-be-do-wop would be very useful for pretty printing ...
11:16:38 <mm_freak> module Main with TraditionalLanguagePragma where {-# LANGUAGE … #–}
11:16:38 <Eduard_Munteanu> Maybe it can play some elevator music while the monadic computation unfolds. :P
11:16:38 <applicative> no one takes it seriously but I think there is a dire need for more syntactic innovations like do
11:17:36 <applicative> i would do without do blocks myself -- except that you get to use statement syntax and thus avoid tons of parentheses and nonsense
11:17:53 <applicative> try using $ in a desugared do block full of liftIOs or something
11:19:30 <joelteon> is cabal configure --with-executable-profiling all I need to enable profiling? no GHC flags?
11:22:58 <Hafydd> Much do {} about nothing.
11:24:00 <banister> applicative: what's the diff b/w liftM and liftIO ?
11:24:35 <Eduard_Munteanu> banister: they're not related at all, liftIO is for monad transformers
11:24:50 <joelteon> ok, i'll pastebin my session, this is confusing
11:24:51 <Eduard_Munteanu> :t liftIO
11:24:52 <lambdabot> MonadIO m => IO a -> m a
11:25:16 <applicative> joelteon: I think yes , but keep in mind that all dependencies must be compiled with profiling
11:25:51 <applicative> joelteon: so it is best to start ~/.cabal or a sandbox afresh with library profile = True in the cabal/config
11:25:58 <applicative> whats the line
11:26:33 <banister> Eduard_Munteanu: but no one understands monad transformers, they're too hard
11:26:34 <applicative> right uncomment the line library-profiling: True
11:26:45 <applicative> joelteon: ^^
11:26:56 <Eduard_Munteanu> banister: mm, not really
11:27:35 <applicative> liftIO (putChar 'a') can have the type StateT s (ReaderT conf IO) ()
11:28:02 <joelteon> i've had that enabled the entire time
11:28:03 <applicative> monad transformers are easy theyre just a pain in the neck
11:28:09 <applicative> joelteon: oh
11:28:25 <joelteon> ghc is just complaining
11:28:27 <joelteon> hang on
11:28:29 <applicative> but then you dont need to give a flag on the command line
11:28:49 <applicative> could it be your distributition wasn't giving you prof libraries?
11:29:15 <notdan> Dammit, all pipermail links on haskell.org are broken :(
11:29:47 <Eduard_Munteanu> Is there a common extension for Haskell scripts (runhaskell)?
11:30:54 <applicative> notdan: you mean at like http://www.haskell.org/pipermail/haskell-cafe/
11:30:57 <applicative> they seem ok to me
11:31:18 <applicative> runhaskell main.hs runs scripts yes
11:31:28 <applicative> or runghc if you have ghc
11:31:56 <Eduard_Munteanu> applicative: ah, I know that, I was wondering if I should append .hs, use no extension or something else.
11:33:17 <applicative> with #!/usr/bin/env runhaskell
11:33:28 <joelteon> this is the problem: https://gist.github.com/joelteon/b1e1644aced8277c20dc
11:33:30 <applicative> it doesn't matter what you call the file if its executable
11:33:43 <applicative> Eduard_Munteanu: or am i clueless.
11:33:46 <applicative> no, just did it
11:34:25 <Eduard_Munteanu> applicative: sure, I know it works. I was wondering what people usually call those haskell scripts.
11:34:31 <applicative> joelteon: we can see colour being built there
11:34:36 <flebron> Hi. Is there a reason why main's signature isn't something like [String] -> IO Int?
11:34:50 <joelteon> what about colour?
11:34:58 <applicative> joelteon: and it isnt being built with profiling, which make .p_o files in addition to .o files
11:35:07 <joelteon> hmmm
11:35:46 <joelteon> ok, looks like I'll just rebuild everything
11:36:25 <applicative> oh wait, you also want enable library profiling.
11:36:25 <elliott> flebron: why single out argv?
11:36:46 <flebron> Well you just did :p I didn't tell you what the [String] was :p
11:37:10 <applicative> Eduard_Munteanu: oh i see ; it seemed an improbably elementary question
11:38:16 <applicative> what I would like to remember is the trick where the file is executuble with #usr/bin/whatever, but is an lhs file, so its also a valid haskell file
11:39:04 <twomashi2> oshit
11:40:58 <applicative> Eduard_Munteanu: I had a secret plan for a special module type .hscript or something , where you just write the do block for main with do, at the top level.
11:41:25 <sm> applicative: yes please
11:41:32 <applicative> if you wanted to define a function you'd have to use monadic let and it would appear you had let at the top level
11:41:34 <sm> and no imports needed
11:41:38 <Eduard_Munteanu> applicative: hm, that'd be doable
11:41:43 <applicative> the whole thing would look a bit ocamlish
11:42:01 <twomashi2> applicative: would imports work
11:42:40 <applicative> Eduard_Munteanu: yeah i did an extremely primitive version once, which was more like what would result if you typed each line of the script into ghci in succession
11:43:09 <applicative> twomashi2: in ghci you can make a line import Data.Text so yes :)
11:43:22 <applicative> and you can do it half way down the 'module' ...
11:43:43 <Eduard_Munteanu> applicative: perhaps you could just have the script wrap the input in a real "main = ..." Haskell file?
11:43:57 <Eduard_Munteanu> Or do you want it to work with ghci?
11:44:11 <applicative> Eduard_Munteanu: I'm not sure what my scheme was
11:44:25 <applicative> secretly I was wanting to make a point about .ml files
11:44:30 <applicative> if i remember
11:45:06 <applicative> but anyway, if we had a little ancillary scripting language where it's implied that it 'main' so to speak
11:45:36 <applicative> there could be some interesting syntactic niceties added independently of 'real haskell'
11:46:34 <applicative> the hs file should just be libraries anyway. main is another subject
11:47:20 <applicative> or so i was imagining one might say, if i remember
12:03:27 <yesthisisuser> is it possible to write a strict data definition without BangPatterns? e.g. data X a = X !a
12:06:48 <joelteon> why would you do that
12:08:56 <elliott> yesthisisuser: yes, ! in data types is not an extension
12:08:58 <elliott> it is standard haskell
12:09:24 <yesthisisuser> aha
12:09:31 <yesthisisuser> interesting
12:22:26 * ignacio is now known as (the artist formerly known as (the artist formerly known as ( the artist formerly known as ...
12:23:41 <alexander__b> applicative: rereading your posts now, I understand how to do it with your Stringpair and Either. as an exercise I wrote the Functor instance for Stringpair, and it looks right -- and agrees with your posts.
12:23:49 <Cale> > fix ("the artist formerly known as " ++)
12:23:51 <lambdabot>   "the artist formerly known as the artist formerly known as the artist forme...
12:24:08 <ion> > fix (("the artist formerly known as " ++) . show)
12:24:10 <lambdabot>   "the artist formerly known as \"the artist formerly known as \\\"the artist...
12:24:14 <merijn> hmm, any suggestions how to name your library of the module names you want are already taken?
12:24:21 <alexander__b> applicative: so now I understand how it works with Either. I'm still not positive on how fmap for ((,),e) will look though
12:24:35 <merijn> I guess that name colission on the moduel isn't very nice?
12:24:51 <merijn> alexander__b: "fmap f (a, b) = (a, f b)"
12:25:00 <alexander__b> merijn: oh. that's what I did.
12:25:08 <alexander__b> I thought it was too simple to be correct.
12:25:15 <ion> (,) e, not ((,),e)
12:25:32 <alexander__b> ((,) e) in typeclassopedia
12:25:46 <alexander__b> oh I miswrote
12:26:13 <ion> Glad you figured it out, congrats.
12:26:20 <alexander__b> well I didn't really
12:26:23 <ion> > fmap f (a,b)
12:26:24 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:26:24 <lambdabot>    arising from a us...
12:26:30 <ion> > fmap f (a,b) :: (Expr, Expr)
12:26:31 <alexander__b> I mean, I didn't reason my way to it. it was just intuition.
12:26:31 <lambdabot>   (a,f b)
12:26:43 <alexander__b> so I'm still not sure how it works.
12:26:51 <alexander__b> or rather why it works
12:27:24 <merijn> alexander__b: Why wouldn't it work?
12:27:42 <alexander__b> ((,) e) is sugar for (e,). so there's... some partial application thing going on
12:27:44 <ion> “fmap :: Functor f => (a -> b) -> f a -> f b” for “f = (e,)” is “fmap :: (a -> b) -> (e,a) -> (e,b)”. And there’s only one implementation of that that makes sense.
12:28:24 <merijn> alexander__b: No, "(e,)" is sugar for "(,) e"
12:28:25 <ion> alexander_b: The other way around, (e,) is sugar for (,) e (although hypothetical sugar, you can’t use that on the type level even with TupleSections IIRC).
12:28:36 <alexander__b> merijn: right, yes.
12:28:41 <merijn> alexander__b: And yes, it's a partial application of the tuple type constructor
12:28:45 <alexander__b> ion: yes, typeclassopedia mentions this.
12:28:47 <elliott> alexander__b: it's the same partial application as "instance Functor []" really
12:28:54 <elliott> or "instance Functor Identity" or "instance Functor IO"
12:29:09 <merijn> "(,) e" is to "(e, x)" as "Either e" is to "Either e x" and "Maybe" is to "Maybe x"
12:29:11 <alexander__b> it's just hard to grok because I can't do like I did with either, which was just :i Either and read the data declaration.
12:29:22 <alexander__b> merijn: thanks. there we go.
12:29:28 <elliott> data (,) a b = (,) a b
12:29:29 <elliott> :p
12:29:31 <merijn> alexander__b: It's very clear when you looke at the kinds
12:29:32 <alexander__b> merijn: makes perfect sense now.
12:29:36 <merijn> :k Either
12:29:46 <merijn> oh, lambdabot doesn't do :k?
12:29:49 <merijn> @kind Either
12:29:55 <alexander__b> what's the '*'s?
12:30:10 <elliott> it doesn't. new @run plugin will when I get around to it
12:30:12 <merijn> Wait, did lambdabot respond? I don't see anything
12:30:15 <elliott> no
12:30:20 <elliott> um hmm
12:30:20 <elliott> > 123
12:30:21 <alexander__b> ohhh I can do :k (,) as well
12:30:27 <elliott> uhhhhhhhh
12:30:35 <geekosaur> sigh, netsplits still break lambdabot's brain I see
12:30:38 <elliott> well merijn, I'm afraid I'm going to have to say you broke it.
12:30:38 <ion> * means a type, * -> * is a tyle-level function that takes a type parameter and returns a type.
12:30:46 <ion> Either :: * -> * -> *
12:30:49 <elliott> lambdabot: @quit
12:30:49 <ion> Either a :: * -> *
12:30:51 <elliott> worth a try.
12:30:53 <lambdabot> * -> * -> *
12:30:53 <lambdabot> * -> * -> *
12:30:53 <lambdabot>   mueval-core: Time limit exceeded
12:30:54 <ion> Either a b :: *
12:30:55 <merijn> alexander__b: Ok, you know how 'c' has type Char?
12:30:58 <elliott> uh.
12:30:58 <alexander__b> merijn: no I have like five ghcis on different workspaces :-P
12:30:59 <geekosaur> oh, there we go
12:31:03 <elliott> that's not *quite* what I wanted
12:31:06 <merijn> alexander__b: What is the "type" of Char?
12:31:07 <alexander__b> merijn: ya
12:31:09 <elliott> need a @quit-iff-you're-broken
12:31:18 <alexander__b> merijn: uh
12:31:23 <alexander__b> merijn: IDK
12:31:26 <elliott> ok so I lied, lambdabot does do :k.
12:31:27 <elliott> enjoy.
12:31:31 <alexander__b> merijn: sounds almost like a trick question. :-P
12:31:33 <joelteon> :k is the best smiley
12:31:37 <merijn> alexander__b: In haskell we commonly call the "type" of a type a Kind
12:31:43 <lambdabot> Not in scope: type variable `is'
12:31:50 <merijn> alexander__b: And the kind of a normal haskell type is *
12:31:56 <alexander__b> ah
12:31:59 <merijn> So, 'c' :: Char and Char :: *
12:32:13 <merijn> Now the kind of "Maybe :: * -> *"
12:32:13 <ion> (+) :: Integer -> Integer -> Integer
12:32:16 <ion> Either :: * -> * -> *
12:32:19 <alexander__b> so Maybe is * -> *
12:32:20 <ion> (+) 1 2 :: Integer
12:32:30 <ion> Either String (IO ()) :: *
12:32:31 <alexander__b> and Either must be * -> * -> *
12:32:33 <alexander__b> and the same for (,)
12:32:35 <merijn> alexander__b: That is, Maybe is a type that *takes* a type of kind * and returns one of type *
12:32:38 <merijn> alexander__b: Yes
12:32:55 <alexander__b> merijn: and this means that the * must be the same, right?
12:33:12 <alexander__b> because you can't have a Maybe that takes a Char and returns Just Int, right?
12:33:21 <merijn> alexander__b: No, because you can have multiple different values be of type Char too, right?
12:33:35 <yesthisisuser> types of kind * are the types that can hold values
12:33:45 <ion> alexander_b: There’s no Just Int. Just is a value-level thing, Int is a type-level thing.
12:33:54 <alexander__b> ion: right
12:33:58 <merijn> alexander__b: It doesn't return the same *, it returns *a* *, but you don't know what it is
12:34:08 <alexander__b> yes Maybe = Just Something | Nothing
12:34:17 <merijn> "Int :: *", "Maybe :: * -> *", "Maybe Int :: *"
12:34:19 <alexander__b> merijn: right
12:34:27 <alexander__b> ohhhhh cake
12:34:28 <alexander__b> BBL
12:34:53 <ion> alexander: Incidentally, you can have a Something such that Something Char = Int, for instance. But that’s a more advanced topic that you almost certainly don’t need to study right now.
12:35:00 <merijn> alexander__b: You can also have slightly more complex kinds, like "data Foo f a = Foo (f a)" where "Foo :: (* -> *) -> * -> *"
12:35:20 <yesthisisuser> LYAH explains it in a simple way: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
12:36:34 <ReinH> Why don't Repa arrays have a // operator? Is this not a common use case?
12:40:44 <ion> > type family Foo a; type instance Foo Char = Integer
12:40:45 <lambdabot>   <hint>:1:1: parse error on input `type'
12:43:33 <merijn> Any suggestions how to avoid name collisions if the module names you wanted are already occupied by another library? Should I just invent an entirely new name?
12:43:37 <dmwit> ?let type family Foo a; type instance Foo Char = Integer
12:43:37 <lambdabot>  Parse failed: Parse error: ;
12:43:47 <dmwit> ?let type family Foo a
12:43:48 <lambdabot>  Parse failed: Parse error: EOF
12:43:50 <ion> Oh, i forgot about @let
12:43:56 <dmwit> Doesn't work anyway. =P
12:43:57 <ion> (Not that it works either, but anyway)
12:44:27 <ion> @let class Foo a where { type Bar a }
12:44:27 <lambdabot>  Parse failed: TypeFamilies is not enabled
12:45:09 <dmwit> merijn: There's not much else for it, especially if you think people will use both your package and the other package in the same project.
12:45:59 * dmwit gives Catbuntu a cookie
12:46:52 <merijn> dmwit: Well, I should hope not, for the latter as I'm doing a Haskell implementation and the existing library is a set of FFI based bindings to an existing C library :p
12:47:23 <alexander__b> ion: OK thanks for the clarification.
12:47:24 <alexander__b> yesthisisuser: I'll reread that section
12:47:24 <alexander__b> yesthisisuser: I read the entire book, but the last few chapters were *very* theoretical and things got too meta and abstract to me, so I thought I'd do more practical things and revisit as questions popped up. like now. :-)
12:47:24 <dmwit> I dunno. I could easily see a benchmark project importing both.
12:47:35 <merijn> hmm, I guess I could just pick System.ZeroMQ, since the existing thing uses System.ZMQ
12:48:36 <merijn> alexander__b: as a clarification "Int :: *" and "Maybe Int :: *" are "the same" in much the same way that "'a' :: Char" and "'c' :: Char" are the same (i.e. not at all :p)
12:48:59 <alexander__b> merijn: errr OK. :-)
12:49:20 <elliott> merijn: same API?
12:49:41 <dmwit> alexander__b: You may be getting confused because of, e.g., "id :: a -> a".
12:49:58 <dmwit> alexander__b: We know because of the type that "id" returns exactly the thing you passed it (up to bottoms).
12:50:01 <merijn> alexander__b: That is, "Maybe Int" is just "Maybe Int" and nothing else. Anyway, the definition of Functor says that functors have kind "* -> *", which is why "Either e" is a functor, but "Either" is not, it's a kind error
12:50:10 <alexander__b> dmwit: I wasn't until you brought it up :-P
12:50:13 <merijn> elliott: No, wildly incompatible as that's one of the main reasons to imeplement it :)
12:50:22 <elliott> merijn: ok, then I agree pick another name
12:50:24 <dmwit> alexander__b: However, in the type "id :: a -> a", "a" is a variable. In the kind "Maybe :: * -> *", "*" is not a variable: it is a kind constant.
12:51:26 <dmwit> alexander__b: A bit like noting that "not :: Bool -> Bool" doesn't necessarily return exactly the thing you passed it: it can do more because "Bool" isn't a variable, but a (type-level) constant.
12:51:33 <merijn> elliott: i.e. I want nicer integration with forkIO and STM
12:55:35 <applicative> hah, i managed to find my moronic haskellscript 'interpreter'
12:58:52 <kqr> funny how i automatically read moronic as monadic
13:03:49 <mikolaj> How does haskell represent an object like '[1,1..1]'? Is this equivalent to streams in lisp?
13:04:09 <mikolaj> *stream
13:07:42 <dmwit> mikolaj: The spec doesn't prescribe a representation.
13:08:16 <dmwit> If you want to explore GHC's choices, I can recommend vacuum-cairo. It's awesome.
13:09:46 <hpc> that reminds me, i don't have that
13:11:51 <hpc> vacuum-cairo uses a system svg library where it could probably be using blaze
13:11:57 <hpc> or something
13:13:54 <lpaste> applicative pasted “The Inglorious Pennsylvania HaskellScript Interpreter” at http://lpaste.net/91105
13:13:55 <lpaste> applicative pasted “The Inglorious Pennsylvania HaskellScript Interpreter” at http://lpaste.net/91106
13:14:47 <ion> HaskellScript, huh?
13:15:18 <davd> ghci-style
13:15:42 <lpaste> applicative annotated “The Inglorious Pennsylvania HaskellScript Interpreter” with “The Inglorious Pennsylvania HaskellScript Interpreter (output)” at http://lpaste.net/91106#a91107
13:15:52 <Peaker> Hey, in potentially-pure monads like StateT-of-unknown-m, how would you place assertions in a way that guarantees their triggering and is nice?  If you do something like:  unless invariantUpheld $ error "Oops! Broken invariant"     in a StateT do block, and the monad is instantiated to Identity, and nobody reads the previous state after this point, then the assertion may not actually be reached
13:16:34 <lpaste> applicative annotated “The Inglorious Pennsylvania HaskellScript Interpreter” with “The Inglorious Pennsylvania HaskellScript Interpreter (implementation)” at http://lpaste.net/91106#a91108
13:16:35 <Peaker> I thought about using:   assertStr :: String -> Bool -> a -> a   (for some reason Control.Exception.assert has no error string which is critical for debugging such failures)  on a nested do block, like:
13:17:01 <Peaker> assertStr "Invariant X broken" invariantCondition $ do ... nested code here ...       but adding a nesting level for each assert is very :(
13:17:17 <elliott> Peaker: how about make a class MonadAssert or such?
13:17:26 <elliott> where for IO it can do the clean thing, at least.
13:17:31 <applicative> ion uh, it needs a lot of help
13:17:44 <Peaker> elliott, but I don't want to constraint my exposed type just for assertions :(
13:17:53 <Peaker> (about my internal invariants)
13:18:08 <ion> applicative: What is it meant for?
13:18:38 <ReinH> there's also hood
13:19:05 <applicative> it is itself a joke but i was arguing one could imagine a 'scripting language' in which haskell libraries are imported but the lines are all 'imperatives' and so on
13:19:18 <sm> applicative: fun!
13:19:21 <applicative> so one just says things like print 3 at the top level
13:20:06 <Peaker> elliott, hmm.. imagine you wanted to implement your suggestion but then use "State" and not StateT in:  pureFoo :: Monad m => StateT s m ()
13:20:09 <applicative> this of course is just sending it through ghci which - uh - wont scale
13:20:20 <applicative> such a thing could be useful, with a more free syntax for example
13:20:31 <Peaker> elliott, you'd replace "Monad" with "MonadAssert", and then you'd need to have a new Identity newtype that has a left-strict (>>=) for it to work
13:20:32 <applicative> given that, it wouldn't export only import and so on
13:20:56 <Peaker> elliott, But that wouldn't be "State", but some isomorphic thing :(
13:21:06 <elliott> Peaker: hmm, I guess
13:21:55 <Peaker> I could just use Control.Monad.Trans.State.Strict  *if*  they had made its put/modify be strict on old state which would probably be much closer to people's expectation of a strict state monad
13:22:07 <Peaker> (and disallowed use of lazy put/modify on strict StateT)
13:22:08 <applicative> ion my secret idea when i was thinking of it was about how languages so often require things to go in a certain, which show that they are imperative through and through. agda for example is just imperatives. not the the 'hscript' with the syntax of the lines of a do block looks a little ml ish
13:22:32 <merijn> Peaker: Add an extra strict field to your state that should be () but might have an error and then write a MonadState instance for it?
13:23:40 <merijn> Which library do I want for parsing binary data?
13:23:43 <Peaker> merijn, Unless I misunderstand, that won't help -- because if you use:  error "bla" >> put validValue   the error is forgotten (I guess maybe the strict state monad will fix this even though it's not strict on the state, but I'm not sure)
13:23:45 <applicative> ion note that with this disgusting implementation a 'haskellscript' can have nonsense lines that dont type check or even syntax check, and it just keeps on going. It makes php look safe
13:23:53 * sm totally wants a haskellscript that's as well adapted for scripting as ruby
13:23:56 <Peaker> merijn, binary/cereal seem to both be front-ends on the same backend these days, I think
13:24:03 <luite> merijn: attoparsec probably, unless it's for serializing haskell structures
13:24:17 <Peaker> luite, is attoparsec good for binary data?
13:24:20 <merijn> Peaker: That's for serialisation, I mean just binary data
13:24:22 <hpc> applicative: i would still prefer this to php
13:24:29 <applicative> hah
13:24:32 <hpc> applicative: at least here, you still know that something was wrong
13:24:42 <Peaker> merijn, I don't understand, binary's Get monad is about parsing binary data?
13:24:47 <ion> applicative: heh
13:24:54 <luite> Peaker: yeah it used to be only for ByteString, but i think they added some text support later
13:24:55 <applicative> after running the 'script' it tells you where you were bad ...
13:24:58 <merijn> hmm, lemme check, I'm not that familiar with binary
13:25:11 <applicative> it almost gets the line number right
13:25:14 <Peaker> luite, ByteString/Text as in latin-1/UTF8 parsing, but that implies text either way, and merijn said binary data
13:25:43 <Peaker> (afaik attoparsec was always about parsing text, but from ByteStrings and later Text?)
13:26:11 <merijn> Peaker: Networking protocols, so it's a mix of ASCII + arbitrary bytes
13:26:34 <merijn> Peaker: Doesn't seem to be
13:26:36 <merijn> Peaker: "A fast parser combinator library, aimed particularly at dealing efficiently with network protocols and complicated text/binary file formats."
13:26:48 <merijn> Sounds like that's exactly what I want
13:27:08 <Peaker> merijn, indeed Data.Attoparsec.ByteString deals with Word8's and not Chars, so that's good
13:28:14 <applicative> attoparsec added Text not so long ago
13:29:30 <applicative> it was completely unusable for a text type like me for the first couple years
13:29:34 <merijn> Peaker: It looks like attoparsec is more suited to parsing data of unknown length, although that might just be me not looking at the API of binary long enough to get it :p
13:33:40 <Peaker> merijn, the API of binary is a very simple "Get" monad to parse data.. it has getters for various word sizes, or just bytestrings of some specified length
13:33:58 <Peaker> merijn, and for putting it uses the standard silly writer trick to get "do" notation for a monoid
13:34:59 <erisco> is there this function anywhere?   inf :: [a] -> [a] ; inf ~(x:xs) = x : inf xs   ?
13:35:04 <Peaker> merijn, http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html#v:getByteString  <-- lets you get varying length inputs
13:36:13 <Peaker> erisco, I see you're continuing the forage into maximally lazy functions? :)
13:36:18 <merijn> erisco: cycle?
13:36:25 <erisco> @src cycle
13:36:26 <lambdabot> cycle [] = undefined
13:36:26 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:36:33 <erisco> hm, not cycle
13:36:37 <merijn> erisco: Wait, yours crashes after you run out of arguments?
13:36:48 <erisco> yes
13:36:56 <Peaker> it's not cycle -- it's more like "map id" that makes an infinite list's spine not depend on an input infinite's list elements
13:37:04 <merijn> I don't understand what inf is supposed to do?
13:37:24 <Peaker> it takes an infinite list, and returns an infinite list that may behave more lazily
13:37:24 <erisco> Peaker, it is critical for what I'm working on. I just realized I can collapse four functions into one with this 'inf' function
13:37:50 <erisco> merijn, you might think of it as a hint to the compiler that the list is infinite
13:37:54 <Peaker> > length . take 5 . reverse [1..]
13:37:55 <lambdabot>   Couldn't match expected type `a0 -> [a1]' with actual type `[a2]'
13:38:02 <Peaker> > length . take 5 $ reverse [1..]
13:38:10 <merijn> Peaker: Right, but I'm dealing with a network protocol so I end up having things like "a command out of a set of possible commands with different lengths"
13:38:11 <lambdabot>   mueval-core: Time limit exceeded
13:38:25 <Peaker> > let inf ~(x:xs) = x : inf xs in length . take 5 . inf $ reverse [1..]
13:38:26 <tulcod> i'm interfacing with a C lib. one of its functions is void load_vars(type ** list);, where it saves a one-dim list of variables to *list (so load_vars has *list=malloc(...)). can i interface with such a function without additional C code?
13:38:28 <lambdabot>   5
13:38:35 <elliott> heh, inf is cute.
13:38:36 <erisco> Peaker, useful aint it? :)
13:38:41 <merijn> tulcod: Yup
13:38:41 <Gracenotes> that seems paradoxical
13:38:51 <Peaker> erisco, Yes, I also had it turn up once :)
13:38:51 <merijn> tulcod: The FFI supports a Ptr type
13:38:54 <elliott> Peaker: that said, "length . take 5 . inf" is not very compelling.
13:38:58 <elliott> because it is a constant function.
13:39:07 <elliott> you might as well not bother with the reverse [1..].
13:39:08 <merijn> tulcod: "Ptr (Ptr CChar)" is "char **" for example
13:39:18 <tulcod> merijn: well yes, but isn't that supposed to have a set value?
13:39:20 <Peaker> elliott, it's not very easy to find a compelling example, I think :)
13:39:21 <merijn> tulcod: Take a look at Foreign.Ptr and Foreign.Marshal
13:39:34 <erisco> I am using for infinite cartesian product ... instead of needing four functions, I can reduce to one :D
13:39:35 <Peaker> erisco, I was writing a lazier foldl and something similar turned up
13:39:43 <Gracenotes> > let inf ~(x:xs) = x : inf xs in length . take 5 . inf $ [] -- to be explicit about it
13:39:44 <lambdabot>   5
13:39:45 <aristid> haha i like how Tekmo has a list of reasons why he chose a particular name for a function (await), but the _number one_ reason is that it has the same number of characters as "yield"
13:39:53 <Azdle> I just want to start by saying that I don't know haskell, but I'm trying to build a library so that I can call it from C++ (LibPandoc). When I run `runhaskell Setup.lhs build` I get this error message:  http://pastebin.com/Md8s7eXE Can anyone help me figure out what is going wrong?
13:40:02 <aristid> for some reason await feels like a longer word than yield to me though.
13:40:26 <LadyAurora> aristid: await has more syllables
13:40:26 <Peaker> foldl can be lazier than as defined in stdlib
13:40:29 <monochrom> hehe
13:40:30 <tulcod> merijn: so what, i make a Ptr (Ptr CChar), pass that to the C function, and then... read it out? all in a big do{} ?
13:41:14 <aristid> LadyAurora: that must be it.
13:41:22 <Peaker> but a lazier foldl (at least naively) is O(N^2)
13:41:38 * monochrom suggests a third name for yield and await: back_to_you
13:41:40 <merijn> tulcod: Pretty much
13:41:55 <ion> Why is there no ForeignPtr variant of unsafePackCStringLength in Data.ByteString.Unsafe? Is Data.ByteString.Internal.fromForeignPtr is the best way to do it? Do i have a fundamental misunderstanding of something?
13:42:19 <tulcod> ion: wouldn't you juts use withForeignPtr?
13:42:41 <ion> tulcod: Because it’s “Internal” and not just “Unsafe”. :-P
13:42:46 <merijn> tulcod: For some examples, I have this code dealing with char**: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L193
13:43:11 <ion> tulcod: And its documentation says you should use the latter.
13:43:17 <Peaker> merijn, that seems leaky/unsafe
13:43:44 <jmcarthur> Peaker: what is the lazier foldl?
13:43:45 <merijn> Peaker: What does?
13:43:57 <Peaker> merijn, isn't there some "withNewArray" variant (or allocaArray) to do alloc/free safely, rather than "newArray0" followed by unprotected "free"?
13:44:05 <erisco> elliott, Peaker I'll pastebin my "compelling" example in a second
13:44:06 <jmcarthur> Peaker: index every element? (that doesn't sound any lazier to me, but...)
13:44:10 <tulcod> merijn: hm, yes, but you're just reading the return value, that's not fair :P
13:44:24 <tulcod> merijn: but it's good to have an example, thanks!
13:44:50 <merijn> Peaker: Yes, but I'd have to nest it with two lambda's and it generally just looks freaking awful
13:45:20 <Peaker> merijn, lambda nesting need not imply indenting, and syntactic-awful is better than leaky/semantic-awful
13:45:26 <merijn> the withX functions in foreign don't really play well when you need multiple such arguments
13:45:37 <Peaker> merijn, why?  withX $ \x -> withY $ \y -> ... ?
13:46:11 <merijn> Peaker: How is this leaky/semantic awful?
13:46:12 <merijn> Peaker: It's an internal unexported function fo like 5 lines...
13:46:34 <Peaker> merijn, because if you get any async exceptions in the middle or such - you'll leak the allocated stuff?
13:47:12 <merijn> That'll teach you not to use async exceptions! :>
13:47:21 <elliott> you can't just ignore async exceptions.
13:47:22 <Peaker> jmcarthur, foldl f z [] = z ; foldl f z xs = f (foldl f z (init xs)) (last xs)
13:47:37 <Peaker> merijn, what's so bad about two nested lambdas for "alloca"?
13:47:43 <Peaker> merijn, put them in same indent
13:48:50 <merijn> Peaker: How do I do th case that way?
13:48:52 <Peaker> jmcarthur, so if the list is non-empty, you are productively generating an "f" call before looking at the content of the list
13:49:03 <jmcarthur> @src foldl
13:49:03 <lambdabot> foldl f z []     = z
13:49:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:49:04 <Peaker> jmcarthur, though it will be O(N^2) :-(
13:49:08 <jmcarthur> i see
13:49:42 <jmcarthur> hmm... i wonder if there is a way to fix that
13:49:55 <jmcarthur> oh i bet there is
13:49:58 <jmcarthur> might take some work
13:50:09 <jmcarthur> i think this will be my exercise for the moment
13:50:41 <Peaker> merijn, use: where allocaEnv f = case env' of [] -> f nullPtr ; _ -> allocaArray0 nullPtr env' f
13:51:18 <cdk> lets say I have some concurrent process running in another thread, and I have some state for it in an IORef. I want to change the state in my main thread, and have the process immediately stop (maybe do some cleanup), and reread from the IORef, then restart using the new state. My current idea is to throw my own custom exception to the thread, and have it running in a exception handler that will do what I want. Is this an abuse of the exception 
13:51:22 <Azdle> cabal install pandoc
13:51:24 <Azdle> oops
13:51:39 <Peaker> merijn, then you can use: forkExecWithPty x y path search argv' env' = <newline> allocaArray0 nullPtr (path:argv') $ \argv -> <newline> allocaEnv $ \env -> <newline>
13:51:49 <ignacio> happens to the worst of us
13:52:03 <Peaker> merijn, do you know the ContT wrapping trick for functions like alloca or bracket?
13:52:07 <ignacio> passwd hunter22
13:52:16 <merijn> Peaker: Besides, the parent code isn't async proof either, as that uses mapM with newCString
13:52:25 <merijn> Peaker: So I'd have to rework that too
13:52:39 <Peaker> merijn, mapM is a case where you really want the ContT transform
13:52:43 <merijn> And we're already well under way into making the code very hairy and ugly
13:52:50 <Peaker> merijn, and then that becomes safe too
13:52:54 <merijn> Peaker: Now, I don't know it
13:53:27 <merijn> eh
13:53:28 <Peaker> merijn, alloca/bracket are in CPS -- i.e: they look like:   func :: Params -> (Resource -> IO r) -> IO r
13:53:29 <merijn> s/Now/No
13:53:34 <shachaf> Hooray for the ContT trick.
13:53:45 <hpc> oh my
13:53:46 <Peaker> merijn, And (Resource -> IO r) -> IO r  ===  ContT r IO Resource
13:53:55 <applicative> Azdle: whats wrong?
13:54:10 <Peaker> merijn, and it turns out that the monadic instance for ContT will compose brackets/alloca's correctly -- i.e: nest them properly
13:54:38 <Peaker> merijn, so if you do:  newCString' :: String -> ContT r IO CString     then you can still use your mapM!
13:54:49 <merijn> cdk: It's pretty much what async exceptions are for, but you have to keep in mind that you might interrupt your code mid-operation, so you have to make sure that's safe
13:54:50 <shachaf> This kind of trick is sort of the point of using a monad in the first place. It's just that this lets you use an arbitrary CPSed thing.
13:55:09 <Peaker> merijn, it will do alloca/nesting for you and your code will look essentially the same
13:55:16 <Azdle> applicative: I'm having issues trying to compile: https://github.com/ShabbyX/libpandoc
13:55:19 <Peaker> merijn, with a few more liftIO's sprinkled, maybe
13:55:26 <merijn> hmmm
13:55:33 <merijn> I'd need to look into that sometime
13:55:54 <shachaf> Peaker: liftIO only works with IO in positive position, of course. :-(
13:56:01 <Azdle> applicative: it tells me I need to recompile something with -fPIC, but I don't know where to add that flag. pastebin.com/Md8s7eXE
13:56:18 <cdk> merijn: I suppose i would have to mask the "dangerous" parts of the concurrent code, so that I only catch exceptions when its safe?
13:56:18 <Peaker> shachaf, of course, but that's a different problem (since for this problem, IO in negative position is wrapped via ContT data constructor directly)
13:56:20 <tulcod> it'd be great if the haskell API docs could be SEO'd to give prefer the latest version
13:56:25 <merijn> cdk: Yes
13:56:43 <Peaker> shachaf, I figured this "trick" out when I was wondering what Haskell's equivalent of Python's "with nested(...) as [x,y,z] .." was and was really happy to realize it's just "sequence" :)
13:56:48 <Taneb> When ListT m is a monad, is it operationally equivalent to LogicT m?
13:56:51 <applicative> Azdle: this is over my head, but thats a C flag right?
13:57:07 <shachaf> Peaker: I don't know of a good general solution for that.
13:57:08 <Azdle> applicative: as far as I know
13:57:09 <applicative> Azdle: I was hoping you were a poet needing help installing pandoc
13:57:18 <shachaf> Hmm, I don't know with nested(). But I can believe that.
13:57:27 <applicative> right so, there are incantations to add for stuff to pass to gcc
13:57:33 <Azdle> applicative: Ah, life would be so much simpler...
13:57:35 <shachaf> CPS is good.
13:57:36 <Peaker> cdk, using async exceptions to interrupt some long computation and make a thread do something else does not sound like abuse
13:57:49 <erisco> elliott, Peaker sorry I was taking some time to reduce my example to be as simple as possible
13:57:49 <cdk> merijn: if I composed "dangerous" parts in STM, so they would all be executed atomically, could an async exception still interupt it?
13:58:13 <hpc> fun thing to look out for when doing the bracket trick:
13:58:27 <applicative> ghc also accepts fPIC though Azdle
13:58:30 <hpc> if you acquire a resource inside callCC and then break out, the resource will not be freed
13:58:36 <Peaker> shachaf, Python has a built-in-to-syntax "with" statement that is essentially like "bracket", except the init/fini function pair is called a "context manager", which is the pair by having __enter__/__exit__ methods.   "nested" builds a context manager from a list of them, by nesting __enters__ and doing __exit__ cleanup appropriately
13:58:41 <merijn> cdk: There is an STM primitve for dealing with exceptions
13:58:51 <cdk> okay, i'll look there. thanks
13:59:34 <merijn> catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a
13:59:46 <applicative> Azdle: so for example you can add  -fPIC  to the last line of the cabal file where the ghc-options are
14:00:09 <applicative> Azdle: but i think youll need an expert
14:00:40 <Azdle> applicative: I actually tried that, didn't change anything.
14:01:06 <applicative> ld is the thing complaining. hm
14:01:08 <lpaste> jmcarthur pasted “lazier foldl” at http://lpaste.net/91109
14:01:12 <jmcarthur> Peaker: ^^
14:01:15 <Azdle> applicative: Good to know that I was even trying in the right place.
14:01:59 <shachaf> I wonder whether you can use Codensity instead of ContT for this in general.
14:02:05 <shachaf> Probably doesn't work that well...
14:02:50 <Azdle> Actually, I wonder if the problem is with using `cabal install`.
14:02:59 <Peaker> jmcarthur, did you quickcheck this == foldl?
14:03:07 <jmcarthur> ah, no. it could have bugs
14:03:17 <Azdle> I actually thinkg I need to recompile pandoc itself....
14:03:23 <jmcarthur> i'll do that now and see if anything comes up
14:03:30 <jmcarthur> but it feels right to me
14:04:07 <shachaf> > let foldl :: (a -> b -> a) -> a -> [b] -> a; foldl f z = go <*> reverse where go [] _ = z; go (_:xs) ~(y:ys) = f (go xs ys) y in foldl f z [a,b,c,d]
14:04:08 <lambdabot>   f (f (f (f z a) b) c) d
14:04:16 <Azdle> Is there some way I can pass compile flags to cabal?
14:04:53 <Peaker> jmcarthur, cute, now I get it
14:05:06 <Peaker> jmcarthur, first param to go is just a counter of when to stop
14:05:10 <jmcarthur> that's right
14:05:24 <shachaf> > let moldl :: (a -> b -> a) -> a -> [b] -> a; moldl f z = go <*> reverse where go [] _ = z; go (_:xs) ~(y:ys) = f (go xs ys) y in moldl f z ([a,b,c]:undefined)
14:05:25 <lambdabot>   f *Exception: Prelude.undefined
14:05:28 <shachaf> > let moldl :: (a -> b -> a) -> a -> [b] -> a; moldl f z = go <*> reverse where go [] _ = z; go (_:xs) ~(y:ys) = f (go xs ys) y in foldl f z ([a,b,c]:undefined)
14:05:29 <lambdabot>   *Exception: Prelude.undefined
14:05:38 <erisco> elliott, Peaker here I think this is good
14:05:38 <erisco> http://lpaste.net/91110
14:05:52 <erisco> if that aint compelling I dunno what is
14:06:10 <Peaker> shachaf, did you mean:  a:b:c:undefined ?
14:06:16 <shachaf> Er, yes, I did.
14:06:32 <shachaf> > let moldl :: (a -> b -> a) -> a -> [b] -> a; moldl f z = go <*> reverse where go [] _ = z; go (_:xs) ~(y:ys) = f (go xs ys) y in moldl f z (a:b:c:undefined)
14:06:33 <lambdabot>   f (f (f *Exception: Prelude.undefined
14:06:50 <erisco> I am using my carp functions because list applicative <*> doesn't work well with infinite lists ... my carp function makes the example more compelling
14:06:59 <Peaker> erisco, what's with the (mappend) brackets?
14:07:00 <shachaf> This reminds me of the lazy reverse we were doing in here a while ago.
14:07:06 <shachaf> Probably because it's a direct generalization of it.
14:07:15 <erisco> Peaker, I suppose it is not necessary. I often forget
14:07:23 <LadyAurora> Lazy all the things?
14:07:27 <shachaf> > let moldl :: (a -> b -> a) -> a -> [b] -> a; moldl f z = go <*> reverse where go [] _ = z; go (_:xs) ~(y:ys) = f (go xs ys) y in length . take 5 $ moldl (flip (:)) [] [1..]
14:07:28 <lambdabot>   5
14:07:30 <applicative> Azdle yes look under cabal configure --help
14:08:13 <applicative> Azdle: --with-ghc-options= ...
14:08:18 <jmcarthur> passes quickcheck
14:08:25 <applicative> Azdle: --with-gcc-options= ... rather
14:08:34 <Azdle> applicative: Oh, I must have misread something.
14:09:10 <applicative> how come haskell-src-exts takes so long to compile, there's something creepy abou tit
14:09:26 <erisco> so there's my one liner contribution to the Haskell community :P
14:09:54 <jmcarthur> applicative: i have noticed that libraries that have complicated AST types take a long time to compile in general
14:10:15 <applicative> jmcarthur: well it is Language.Haskell.Exts.Annotated.Syntax that take forever
14:10:19 <jmcarthur> yup
14:10:55 <erisco> Peaker, is that cool? I'm fishing for some Haskell karma
14:10:56 <Azdle> applicative: I'm thinking that it is actually asking me to recompile pandoc (a haskell project AFAIK), so I want to send the -fPIC to ghc not gcc, right?
14:11:14 <luite> applicative: yeah they are rather terrible.... i'm currently optimizing ghcjs to make it take less than 20 minutes ;p
14:11:17 <Azdle> in which case I'd just use  `cabal install pandoc -fPIC --reinstall`, right?
14:11:50 <Peaker> erisco, inf is cool :)  the code on hpaste is too long/involved for me to dive in ATM
14:12:00 <elliott> luite: perahps you can use the ghc api to parse haskell
14:12:04 <elliott> it's less scary than it looks, IME
14:12:08 <erisco> Peaker, all the carp functions are redundant to read, as I tried to indicate in the comment
14:12:08 <elliott> oh
14:12:12 <elliott> I guess you're not talking about using haskell-src-exts
14:12:30 <erisco> Peaker, I simply supplied them in case one wanted to run the examples. it is more compelling than using <*> from list applicative
14:12:56 <erisco> I probably should have put them at the bottom instead the top
14:13:43 <luite> elliott: haskell-src-exts was used in some ghcjs test cases and we had a demo that compiled fay to js, that also depends on it obviously :)
14:13:59 <zRecursive> what does "~" mean in ~(x:xs) ?
14:14:21 <erisco> zRecursive, that means you're guaranteeing to the compiler that the pattern will match
14:14:24 <hpc> it's an i-forget-the-term pattern
14:14:27 <hpc> irrefutable
14:14:30 <erisco> irrefutable pattern
14:14:49 <hpc> > let (x:xs) = [] in x -- you get errors like this if the pattern fails
14:14:50 <lambdabot>   *Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern (x...
14:15:26 <hpc> it's mostly a syntactic trick to get out of writing extra let-ins
14:15:27 <zRecursive> thx
14:16:31 <jmcarthur> zRecursive: \ ~(x, y) -> g x y   ==   \ pair -> g (fst pair) (snd pair)
14:16:53 <jmcarthur> zRecursive: that is, you can start evaluating g without having to evaluate pair first
14:17:24 <jmcarthur> zRecursive: because you have told the compiler that you know it will match anyway, so why bother evaluating it?
14:18:00 <erisco> herp derp my b' c' d' are wrong
14:18:01 <zRecursive> jmcarthur: neat
14:18:53 <nooodl> > let inf ~(x:xs) = x : inf xs in length . take 5 $ inf []
14:18:54 <lambdabot>   5
14:18:57 <Peaker> if all tuple matches were automatically ~ matches, maybe we'd have nicer semantics (e.g: instance Monoid () would have less room for bikeshedding on bottom behaviors)
14:18:59 <nooodl> it's pretty cool how this works :o
14:19:01 <Peaker> s/tuple/product
14:20:09 <elliott> unlifted tuples are sort of weird.
14:20:18 <elliott> like they make seq even stranger.
14:20:20 <erisco> nooodl, that is rather hilarious
14:20:36 <jmcarthur> i think it's seq that's weird
14:20:42 <elliott> true.
14:20:44 <jmcarthur> unboxed tuples are pretty natural, really
14:20:48 <Peaker> elliott, "seq" is an abomination :P
14:20:51 <elliott> I didn't say unboxed.
14:20:56 <elliott> not the same thing.
14:20:56 <jmcarthur> sorry, unlifted
14:21:07 <jmcarthur> yeah, my fingers just did the wrong thing
14:21:10 <zRecursive> let inf ~(x:xs) = x : inf xs in length . take 5 $ inf [] => 5  seems hard to understand ...
14:21:14 <elliott> right.
14:21:23 <elliott> http://stackoverflow.com/questions/2488228/disadvantage-of-unlifted-type-products http://james-iry.blogspot.co.uk/2011/05/why-eager-languages-dont-have-products.html (+comments)
14:21:53 <elliott> but still, seq is so useful. unlifted products aren't worth it, given that their only advantage involves _|_, so if you're just going to ignore things involving _|_ because they're not purist enough...
14:21:58 <Peaker> zRecursive, inf ~(x:xs) = ...  says you only actually look at the LHS if anyone ever asks for the value of "x" or "xs".  But nobody does
14:22:01 <elliott> oh, Peaker asked that question.
14:22:43 <Peaker> elliott, if Seq is a class, and tuples have a no-op seq, what would that cause?
14:22:52 <elliott> annoyance for people who want to seq a tuple.
14:22:53 <Peaker> or a magical "seq" simply does nothing on tuples?
14:22:58 <elliott> like if you do a foldl'.
14:23:01 <elliott> with a tuple accumulator
14:23:03 <elliott> (this is very common)
14:23:08 <elliott> or, well, hmm.
14:23:11 <zRecursive> Peaker: it starts from info [] ...
14:23:18 <elliott> that isn't quite what I mean but anyway it would be irritating.
14:23:28 <elliott> if you make seq not work on a bunch of stuff why have it at all?
14:23:36 <Peaker> elliott, foldl' on a tuple wouldn't work now would it?
14:23:52 <jmcarthur> i like Seq as a type class, but i don'
14:23:54 <jmcarthur> oops
14:23:58 <elliott> I meant something that didn't make sense.
14:23:59 <jmcarthur> but i don't like dummy instances
14:24:22 <travisb> they've tried the idea of Seq as type class, I think
14:24:28 <jmcarthur> if there are dummy instances then it might as well still be a primitive instead
14:24:30 <elliott> so hey, does anyone know anything about this idea of non-parametric (dependent) products??
14:24:34 <travisb> the problem it caused is that it made Seq a => infect everything
14:24:42 <jmcarthur> travisb: yes, there were a number of regressions in the haskell spec...
14:24:47 <Peaker> zRecursive, try to read it as:  inf ? = ? : inf ?         note that if nobody asks the question marks what they are, it's basically like a repeat ?
14:24:50 <elliott> let's say as well as (Pi (x:A). B) you have (Pi? A. B) (where A : Type)
14:24:52 <elliott> where you can write
14:24:59 <travisb> and anywhere you added seq to something, you had to add a chain of Seq a => to everything that ever used it
14:25:02 <elliott> seq : Pi? A. Pi (B:TypE). A -> B -> B
14:25:06 <jmcarthur> travisb: yeah, which is a problem if you tend to use Seq a lot
14:25:10 <elliott> and seq can do case analysis on the structure of A
14:25:16 <jmcarthur> travisb: but i think seq is to be discouraged anyway
14:25:24 <zRecursive> Peaker: thx
14:25:25 <elliott> (using a closed-universe define-all-types-in-one-go-with-W-or-whatever type system)
14:25:38 <jmcarthur> travisb: (except for some performance-related things)
14:25:40 <Peaker> elliott, I don't understand your tuple example -- seq on tuples being a no-op or seq on tuples just forcing a tuple of thunks is probably similarly bad?
14:25:43 <elliott> and then you could also define the observational equality type like that? and you couldn't apply non-parametric stuff to a type you're parametric in.
14:25:58 * travisb doesn't consider a matter of operating in constant space to be merely "performance"
14:25:59 <jmcarthur> travisb: (but for performance-related things, you normally have monomorphic types anyway)
14:26:12 <elliott> Peaker: I think I was confused. anyway seq on tuples just "doing nothing" would be semantically wrong
14:26:16 <elliott> because seq _|_ x = _|_ would be broken
14:26:29 <tulcod> merijn: could you check my FFI for the Ptr (Ptr a) stuff?
14:27:07 <jmcarthur> travisb: true, but i'm not saying not to use seq at all
14:27:15 <jmcarthur> just to not use it unless you need it
14:27:25 <lpaste> tulcod pasted “FFI code” at http://lpaste.net/91111
14:27:40 <Peaker> elliott, everyone uses seq for eagerness, not for that semantic property.. I wonder why it is useful to define seq like that...
14:28:01 <Peaker> I guess sometimes you use it to propagate bottoms
14:28:06 <erisco> what is the purpose of Applicative or Alternative if there are both: many functions which can satisfy <*> and <|> for T :: * -> *   AND you actually need to make use of all those definitions?
14:28:19 <erisco> workarounds seem really ugly
14:28:36 <erisco> you can give superfluous value constructors for T just to signal to <*> or <|> of which definition to use
14:28:49 <erisco> or you can introduce T2, T3, etc, and convert between them
14:29:00 <elliott> I have no idea what you mean.
14:29:11 <htau> Has anyone ever gotten a heap overflow that was cause soley by (,)  and []? Granted I knew that what I was doing was not ideal, but I was not expecting that to be the form of the problem.
14:29:13 <elliott> the fact that Applicative instances are not unique?
14:29:21 <elliott> that is true but rare that more than one is really useful.
14:29:23 <erisco> elliott, yes you should say that
14:29:27 <elliott> and Monad has the same property.
14:29:34 <erisco> sure, I just haven't used Monad personally
14:29:58 <elliott> we use typeclasses when there is usually one *obvious* instance that obeys the laws and works consistently with a type's other instances.
14:30:02 <elliott> it's a judgement call.
14:30:19 <elliott> for numeric types, it was decided: there is no obvious monoid for them, we will provide Sum and Product newtype wrappers to let you choose insetad
14:30:22 <elliott> *instead
14:30:27 <elliott> so there is no Monoid Integer.
14:30:29 <erisco> elliott, but in the situation I outlined, does one prudently ignore trying to define applicative instances?
14:30:45 <erisco> I was trying to say "if this situation is true, then in that case what use is Applicative"
14:31:07 <elliott> did you outline a more specific situation? if so I missed it, if not, I'm afraid it's too general to say :)
14:31:10 <erisco> elliott, right, I suppose that is a good example.
14:31:42 <elliott> for Applicatives, we have [], where you have a "cartesian product" applicative and a "zippy" applicative
14:32:03 <elliott> the latter is arguably more useful, it generalises zipWithN for all N. however, the former has a corresponding monad that "agrees" with it, the latter does not (cannot)
14:32:12 <elliott> so we have the former as the instance for [], and the latter is available as the ZipList newtype wrapper
14:32:22 <elliott> (admittedly usually too clunky to use when zipWithN exist for reasonable N)
14:32:36 <erisco> okay, so it uses the approach to introduce wrapper types, which I was referring to with T2, T3 ...
14:32:58 <elliott> if you get up to T3 then I suggest at least one of those instances either disobeys the laws or is totally useless
14:33:03 <elliott> or your original T is much too big :P
14:33:22 <erisco> well I did just come up with my inf function, so that actually saves the day for me I think
14:33:56 <elliott> ah, this is about those functions?
14:34:02 <elliott> I suspect the ones that are biased to left or right disobey the associativity laws.
14:34:08 <elliott> so the choice is easier.
14:34:11 <elliott> but I don't fully understand it.
14:34:42 <erisco> they don't change behaviour just laziness
14:34:51 <elliott> but laziness *is* behaviour :)
14:34:54 <erisco> um, that is a bit unclear... the results don't change, just the laziness
14:35:03 <elliott> oh, just how fast they are produced?
14:35:14 <elliott> admittedly, we often ignore _|_ for laws. but when dealing with infinite things we tend to be a littel stricter
14:35:31 <erisco> well, there are two modes of "fast" in this context ... hanging and not hanging
14:36:23 <erisco> so I originally had four definitions for each permutation of laziness on LHS and RHS ... thankfully I pulled that problem out of the definition, so I think I am good to go to define a list wrapper type
14:36:27 <prophile> is it possible to implement ST in pure haskell?
14:36:32 <jmcarthur> i can't actually think of any examples off the top of my head where we ignore _|_ for laws in base
14:37:05 <erisco> but nonetheless it was rather worrisome to realize the arbitrage in what is chosen for <*>
14:37:08 <jmcarthur> prophile: yes, but i doubt it can be done without a O(log n) extra cost in the number of references you use.
14:37:54 <prophile> jmcarthur: okay - i'm interested in the theoretical side, rather than actually using it :)
14:38:10 <jmcarthur> prophile: and it just occurred to me that GC could be a problem too, for some computations
14:38:26 <erisco> elliott, because the wrapper types work, but if you want to switch which definition of <*> you are using, is there any concise way to do so?
14:38:34 <erisco> that is what really worried me :P
14:39:47 <elliott> not really. multiple instances are sort of at odds with the tradeoff typeclasses make. though there can be ways to make it more workable, e.g. lens/newtype have some convenient utilities for this kind of instance-motivated newtype wrapping
14:40:02 <jmcarthur> prophile: the idea would be to implement a heterogeneous map and a corresponding type for keys such that you have a function   lookup :: Map -> Ref a -> Maybe a
14:40:18 <erisco> > (,) <$> (ZipList ((,)<$>[1,2,3]<*>[4,5,6])) [7,8,9]
14:40:19 <lambdabot>   Couldn't match expected type `[t0] -> f0 a0'
14:40:19 <lambdabot>              with actual type ...
14:40:22 <jmcarthur> prophile: and then make an appropriate monad and do the higher rank trick and all that if you want
14:40:39 <jmcarthur> prophile: the implementation is a little involved. there are a couple things like this on hackage. let me find one
14:40:41 <erisco> :t ZipList
14:40:43 <lambdabot> [a] -> ZipList a
14:40:58 <zRecursive> seems "> sqrt 1000000000000" is faster than "ghc -e 'sqrt 100...'" ?  i am curious how lambdabot does it ?
14:40:59 <erisco> > (,) <$> (ZipList ((,)<$>[1,2,3]<*>[4,5,6])) (ZipList [7,8,9])
14:40:59 <prophile> jmcarthur: thanks
14:41:00 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList a3
14:41:00 <lambdabot>               ...
14:41:15 <erisco> mkay what am I doing wrong
14:41:32 <erisco> > (,) <$> (ZipList ((,)<$>[1,2,3]<*>[4,5,6])) <*> (ZipList [7,8,9])
14:41:33 <lambdabot>   No instance for (GHC.Show.Show
14:41:33 <lambdabot>                     (Control.Applicative.Zip...
14:41:35 <prophile> jmcarthur: I'd hoped there would have been something in the original paper
14:41:38 <erisco> ah ha
14:41:45 <elliott> you need to use getZipList at the end
14:41:46 <elliott> unfortunately.
14:41:52 <elliott> it would be a lot better with shorter names and more instances
14:41:52 <prophile> but SPJ seems to have an unfortunate pragmatic streak :)
14:41:57 <erisco> > getZipList $ (,) <$> (ZipList ((,)<$>[1,2,3]<*>[4,5,6])) <*> (ZipList [7,8,9])
14:41:58 <lambdabot>   [((1,4),7),((1,5),8),((1,6),9)]
14:42:09 <erisco> there we go. so that is the hassle I am speaking of
14:42:44 <jmcarthur> prophile: here's one that has a fairly principled implementation: http://hackage.haskell.org/packages/archive/dependent-map/0.1.1.1/doc/html/Data-Dependent-Map.html
14:42:53 <prophile> jmcarthur: shiny, thanks
14:43:15 <jmcarthur> prophile: but you'd probably need to use some Typeable sort of thing in the keys to work on arbitrary types, for this implementation at least
14:43:29 <erisco> this is just my novice theorycrafting... but it seems that the concept of <*> -- that being the laws of <*> -- is being conflated with the necessity of a function called <*>
14:44:02 <elliott> you could say the same about (+)
14:44:06 <prophile> jmcarthur: well, it seemed there might be some trick with stacking monad transforms in a data types a la carte type fashion
14:44:07 <shachaf> And birds.
14:44:10 <elliott> well, ok, except we don't have any stated laws for (+).
14:44:18 <erisco> I should be able to have booBaz and hahHah functions which are both instances of <*>
14:44:30 <jmcarthur> prophile: here's another thing i know little about http://hackage.haskell.org/packages/archive/hetero-map/0.21/doc/html/src/HeteroMap-Map.html
14:44:32 <erisco> if that makes sense
14:44:47 <jmcarthur> prophile: i don't know of such an approach for implementing ST
14:45:03 * prophile reads about these packages
14:45:26 <jmcarthur> prophile: anyway, those obviously don't offer an ST monad, but it could be implemented in terms of something like these i think
14:45:50 <erisco> though if classes were vague enough to not guarantee that <*> and pure are real functions to call... then they wouldn't have much practical purpose I suppose
14:46:40 <banister> erisco: why is pure called pure ?
14:47:24 <prophile> because were it called "bambi" it would tend to upset kids
14:48:03 <LadyAurora> erisco: because return was already taken
14:48:46 <zRecursive> @hoogle lambdabot
14:48:46 <lambdabot> package lambdabot
14:48:46 <lambdabot> package lambdabot-utils
14:49:01 <zRecursive> @where lambdabot
14:49:01 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
14:49:08 <elliott> "pure" is a pretty good name for pure.
14:49:10 <erisco> what if you could make what I'll dub a "function concept". it will be named (let's make one called <*>). you tell the compiler what laws <*> satisfies
14:49:35 <zRecursive> :t (<*>)
14:49:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:49:39 <erisco> you can then define a function which inherits the concept of <*>, which is informing the compiler that it obeys the same laws
14:50:02 <erisco> then I can define a higher order function that only accepts something of <*> concept?
14:50:15 <erisco> or have I reinvented type classes :P
14:50:36 <erisco> with the added fluff of laws which the compiler can't actually guarantee
14:50:47 <banister> erisco: but what is pure about it
14:51:05 <erisco> banister, I don't know what you mean
14:51:24 <banister> erisco: why did they choose the word 'pure' ? :)
14:51:35 <erisco> banister, why?
14:51:37 <banister> i dont understand what's 'pure' about it :)
14:51:40 <banister> erisco: im curious
14:51:47 <prophile> banister: the values it "creates" in some senses represent purely the value it is given
14:51:50 <banister> you dont have to answer, u can just say 'i dismiss u, go away!'
14:51:52 <banister> :)
14:51:54 <prophile> in the 'no extra information' sense
14:51:54 <erisco> banister, I don't know
14:52:15 <tulcod> banister: functions in haskell are functions in the *pure, mathematical* sense
14:52:31 <tulcod> but mathematical is a bit long
14:52:33 <erisco> (pure 5) :: Maybe     "this 5 is purely a Maybe" ?
14:52:34 <erisco> best I have
14:53:43 <jmcarthur> i think both pure and return are bad names for those functions
14:53:50 <LadyAurora> tulcod: functions in C are too, they just pass around the universe implicitly
14:53:56 <prophile> I quite like 'unit' as an alternative
14:54:36 <tulcod> LadyAurora: i get your point, but you can't read that off from their type
14:55:07 <jmcarthur> tulcod: to be fair, you can't read everything from haskell types either, such as the implicit inclusion of _|_ in every type
14:57:13 <jmcarthur> is there a name for a function that could be interpreted as either a fold or an unfold? map is an example, since it can be seen as folding a list to generate a new one or as unfolding a list using an existing list as a seed.
14:59:18 <shachaf> So there's this pattern in a lot of Haskell things where you have two things which are vaguely dual to each other, where one is universal, and the other is existential. Often the universal one is the return value from a function and the existential one is the arguments to the same function.
14:59:23 <shachaf> E.g. Yoneda/CoYoneda, Codensity/Density, Ran/Lan in general, Mu/Nu, Bazaar, ...
14:59:24 <shachaf> Is there a thing that talks about that, or something?
14:59:45 <jmcarthur> shachaf: i, too, am currently interested in exactly this question
15:00:07 <shachaf> jmcarthur: Yes, I just posted this in another channel a few minutes ago and then I saw your question here and thought it might be related.
15:00:10 <jmcarthur> the universal/existential aspect is definitely no coincidence
15:00:47 <jmcarthur> i've been mulling over whether there is a way to be polymorphic over whether a recursive function is a fold or unfold (in the sense of Mu and Nu)
15:01:15 <jmcarthur> but it's tough since you have to reject Nu->Mu but allow Mu->Mu, Nu->Nu, and Mu->Nu
15:01:15 <shachaf> Respectively, Yoneda/CoYoneda are return/arguments of fmap, Codensity/Density are return/arguments of (>>=)/(=>>), Mu/Nu are return/arguments of fold/unfold, Bazaar is return value of traverse, etc.
15:01:24 <jmcarthur> right
15:02:06 <jmcarthur> you pointed out Ran/Lan. these i know the least about.
15:02:37 <shachaf> Well, a lot of these things are special cases of Ran/Lan.
15:02:43 <jmcarthur> right
15:02:57 <shachaf> I don't think I properly understand kan extensions as such, though.
15:03:02 <jmcarthur> i get that. i just wonder if maybe i'm missing out on the meat of this by not knowing much about them
15:04:10 <shachaf> I don't think Mu/Nu can be said to be special cases of that very easily, though.
15:04:31 <shachaf> So this is some more general pattern.
15:05:02 <jmcarthur> maybe it's just going to boil down to initial/terminal objects
15:05:48 <shachaf> Hmm, that's possible.
15:06:54 <jmcarthur> google has led me to an interesting remark:  <edwardk> you probably want (forall b. a -> (a -> b) -> f b) -> a -> Mu f -- that makes it clear you are applying the yoneda lemma to f
15:08:51 <shachaf> (a -> Yoneda f a) -> a -> Mu f?
15:09:04 * shachaf looks at logs for the context.
15:09:14 <jmcarthur> https://code.google.com/p/irc-logs/source/browse/trunk/logs/freenode/haskell/2009/2009-03-13?r=67
15:09:31 <shachaf> Yep, I found it.
15:10:21 <shachaf> I guess this Mu is what I usually call Fix.
15:10:45 <jmcarthur> ah
15:11:00 <shachaf> (a -> Yoneda f a) is like (a -> f a) when f is a functor.
15:11:22 <shachaf> So in that case that's the same as Functor f => (a -> f a) -> a -> Fix f, which is the usual type for unfold.
15:11:28 <jmcarthur> oh, the conversation is just about removing Functor
15:11:41 <jmcarthur> okay, so kind of boring after all
15:12:20 <shachaf> And I guess you could say fold :: Fix f -> (CoYoneda f a -> a) -> a ?
15:13:19 <shachaf> Hmm, #haskell sure was a different place in 2009.
15:14:11 <shachaf> Oh, dolio's cata is indeed that, except encoded with a forall.
15:14:12 <augur-afk> shachaf: teeeechnically Fix is Nu
15:14:37 <augur-afk> because haskell has codata only
15:16:45 <jmcarthur> i am 90% convinced that Mu, Fix, and Nu are all distinct things. without using recursion, you can convert Mu->Fix and Fix->Nu, but not Nu->Fix or Fix->Mu.
15:17:02 <jmcarthur> not sure what that makes Fix, really
15:17:10 <augur> er..
15:17:14 <augur> can you?
15:17:22 <shachaf> Fix is just weird.
15:17:26 <augur> why?
15:17:46 <shachaf> Mu gives you maximal power for you can do with it, Nu gives you minimal power.
15:18:03 <shachaf> So those conversions are easy.
15:18:04 <augur> what
15:18:13 <shachaf> (But in turn you can make Nu inhabitants that aren't Mu inhabitants.)
15:18:26 <lpaste> jmcarthur pasted “mu->fix->nu” at http://lpaste.net/91112
15:18:31 <jmcarthur> augur: ^^
15:18:47 <jmcarthur> augur: but try to go the other way without recursion...
15:18:57 <augur> oh, jmcarthur, thats not a standard mu for type theory
15:19:05 <augur> most mu's in type theory are identical to fix
15:19:08 <augur> from what ive seen anyway
15:19:26 <jmcarthur> augur: but this mu is "more initial" than fix anyway
15:19:40 <augur> i dont know how its "more initial"
15:19:48 <augur> if its initial, its initial, and thats about all there is to it
15:20:03 <jmcarthur> sure. i'm just saying that fix is not the initial object here
15:20:08 <augur> which is certainly true of Fix/normal mu
15:20:15 <dolio> Initial object of what?
15:20:23 <augur> well its probably not initial in haskell, jmcarthur, this is probably true
15:20:41 <jmcarthur> i don't actually know what. the arrows are haskell functions that don't use recursion in their implementations
15:21:12 <jmcarthur> they are some sort of natural transformations in hask i guess
15:21:31 <augur> im not sure why recursion is so naughty here to, jmcarthur
15:21:38 <dolio> Initial object of hand waving.
15:21:54 <jmcarthur> yes, the handwave category
15:22:04 <jmcarthur> the restriction is arbitrary but, i think, interesting
15:22:14 <shachaf> That's the only category we really talk about in here.
15:22:26 <augur> jmcarthur: well, then thats boring :D
15:22:51 <augur> i mean, Fix f is initial in normal settings for type theory
15:23:46 <augur> im not sure you can really define much without genuine recursion tho
15:23:52 <augur> unless you allow infinitary case
15:23:55 <shachaf> jmcarthur: I need to go but you should tell me if you figure anything out.
15:24:12 <jmcarthur> shachaf: oh, i surely won't. i'm a complete amatuer
15:24:15 <augur> actually, without recursive, at best you get something equivalent to projections
15:24:55 <augur> banning recursion essentially makes every object isomorphic to some boring finite product
15:25:05 <augur> or something like that
15:25:25 <erisco> > :t (<**>)
15:25:26 <lambdabot>   <hint>:1:1: parse error on input `:'
15:25:28 <augur> Fix without recursive functions is basically pointless, and vice versa
15:25:30 <erisco> :t (<**>)
15:25:31 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
15:25:45 <erisco> :t (<||>)
15:25:46 <lambdabot>     Not in scope: `<||>'
15:25:46 <lambdabot>     Perhaps you meant `<|>' (imported from Control.Applicative)
15:25:50 <jmcarthur> augur: i guess that's true. if Mu has folds and Nu has unfolds then it's unfair to just reject recursion for Fix
15:26:03 <shachaf> jmcarthur: If you figure out what question I should be asking, for instance, that would be helpful.
15:26:38 <jmcarthur> s/unfair/kind of weird/
15:31:05 <mayhew> Is there a standard amount of spaces to indent by for Haskell?
15:31:37 <lispy> mayhew: I use 2
15:31:43 <ion> mayhew: Some use two, some use four, whereever the layout doesn’t dictate it.
15:32:06 <LadyAurora> mayhew: π spaces
15:32:16 <banister> do most haskellers use emacs?
15:32:18 <mayhew> There's no general community consensus like Python?
15:32:39 <Nisstyre> banister: I doubt it
15:33:00 <shachaf> There are multiple general community consensuses.
15:33:20 <banister> misv: i noticed that a lot of core haskell programmers use haskell, anyway
15:33:35 <tulcod> mayhew: as a haskell noob, i think this is a general problem with right about everything in haskell: there is no consensus
15:33:39 <banister> misv: simon peyton jones, for example
15:33:48 * shachaf goes now.
15:33:49 <Nisstyre> tulcod: why is that a problem?
15:33:59 <tulcod> everyone's doing something else
15:34:02 <banister> err Nisstyre*
15:34:24 <tulcod> Nisstyre: ergo you never know what the user expects from you, or what you can expect from upstream
15:34:48 <Nisstyre> tulcod: you can expect at least what's in the spec
15:35:44 <tulcod> Nisstyre: well yes, it's not as much a problem as in other languages :)
15:35:58 <Peaker> I use 2 spaces for indent, but regret it and would change to 4, but changing indents is a PITA (merge hell, emacs configs, ...)
15:36:25 <LadyAurora> Why do you regret it?
15:36:26 <tulcod> we should use tabs *ducks*
15:36:27 <Peaker> the rationale was "Haskell functions are short&sweet, so 2 spaces are enough", but in fact, functions can grow to be a page-ful of where clauses...
15:36:37 <Peaker> and 2 spaces are not very nice there
15:36:45 <bel3atar_> let primes = filter isPrime [1..10] where isPrime x = null $ filter (== 0) $ map (x `mod`) [2..x]
15:36:55 <Peaker> and 4 spaces is a low-enough number to not push everything off the page
15:37:06 <LadyAurora> tulcod: use zero-width non-breaking spaces
15:38:18 <jmcarthur> i like 2 spaces even for large functions. i never find myself using nested where clauses though
15:38:59 <LadyAurora> Is ZWNBSP a valid whitespace in the context of indentation?
15:39:10 <mietek> What happened to the haskell.org pipermail archive?
15:39:24 <tulcod> gnight all
15:40:41 <tabemann> <tabemann> random question
15:40:43 <tabemann> <tabemann> is there a good way to determine whether two IORefs or two IOArrays point at the same mutable state?
15:40:45 <mietek> It looks like everything between July 2002 and July 2013 is gone?
15:40:46 <tabemann> <tabemann> (other than simply modify one and see if the other changes, which would be very unsafe for numerous reasons for what I'm doing)
15:40:51 <mietek> http://www.haskell.org/pipermail/haskell/
15:41:03 <tabemann> (i.e. will simple == work?)
15:41:31 <mietek> I really hope there were backups
15:42:21 <jmcarthur> tabemann: you could StableNames
15:42:37 <jmcarthur> tabemann: just make sure you understand the gotchas
15:43:16 <jmcarthur> tabemann: alternatively, you could make your own wrappers that include unique identifiers
15:43:38 <jmcarthur> tabemann: actually... IORef is an instance of Eq already
15:44:42 <tabemann> but does Eq on IORef measure that they are actually the same IORef (i.e. modifying one will modify the other), or only that they contain identical data?
15:44:58 <jmcarthur> edwardk: maybe you would know an answer for this: <shachaf> So there's this pattern in a lot of Haskell things where you have two things which are vaguely dual to each other, where one is universal, and the other is existential. Often the universal one is the return value from a function and the existential one is the arguments to the same function. E.g. Yoneda/CoYoneda, Codensity/Density, Ran/Lan in
15:45:00 <jmcarthur> general, Mu/Nu, Bazaar, ... Is there a thing that talks about that, or something?
15:45:06 <jmcarthur> tabemann: it should not do the latter because that would be impure
15:45:39 <LadyAurora> tabemann: the latter would return IO Bool, not Bool
15:46:15 <tabemann> of course
15:46:33 <tabemann> so I presume the Eq instance for IOArray behaves the same way, that it measures that they are really the same IOArray
15:46:43 <LadyAurora> And would require (Eq a) => a.
15:46:55 <LadyAurora> Try it and see.
15:47:01 <LadyAurora> That's the surest way.
15:47:47 <Peaker> I doubt it's the surest way (since it can equal or not-equal randomly or in an Implementation-defined way that may change)?
15:48:17 <jmcarthur> the source is the surest way
15:48:37 <jmcarthur> if there is no spec
15:51:21 <tabemann> okay, testing it with IOArray seems to work
15:53:40 <dmwit> Yes, (==) checks pointer equality for IORefs and IOArrays.
16:10:58 <zRecursive> :hoogle IORefs
16:14:45 * hackagebot threepenny-gui 0.1.0.1 - Small GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.1.0.1 (HeinrichApfelmus)
16:18:57 <jfischoff> does anyone know if sugar haskell makes it easy to make your own type level literals (strings and numbers etc)?
16:19:08 <Clint> did i hallucinate some sort of library that converts NominalDiffTime to human-readable text?
16:25:33 <dmwit> Clint: formatTime?
16:27:24 <Clint> dmwit: how do i make that produce something like "1 day, 1 second" from 86401?
16:27:59 <dmwit> Oh, hm, I guess NominalDiffTime doesn't have a FormatTime instance after all.
16:32:07 <skinkitten> is there a project euler channel?
16:34:12 <pdxleif> Is there a way to say "the next 20 bindings have the same signature"?
16:34:32 <geekosaur> foo1, foo2, foo3, ... :: signature
16:34:44 <geekosaur> (you have to list them all but you don't need a separate signature for each)
16:34:50 <pentace> Clint: the MissingH package has renderSecs
16:34:56 <pdxleif> Cool, thanks!
16:35:15 <applicative> Clint: dont import MissingH, just cut and paste. Thank you.
16:35:52 <Clint> pentace: thanks
16:35:59 <Clint> applicative: ok?
16:36:14 <applicative> its just such a monster
16:36:18 <ion> > let go _ 0 = Nothing; go bs'@[] a = Just (a, (bs', 0)); go (b:bs') a = Just (r, (bs', q)) where { (q, r) = a `quotRem` b } in unfoldr (uncurry go) ([60,60,24],86402)
16:36:19 <lambdabot>   [2,0,0,1]
16:36:51 * Clint wonders what a TimeDiff is
16:37:30 <Clint> this is full of old-time horribleness
16:37:46 <hpc> just noticed in this one module i am using liftIO, but never actually importing it
16:38:07 <hpc> but it still works, because Control.Monad.State exports Control.Monad.Trans
16:38:30 <ion> Therefore you do import it. :-P
16:38:41 <hpc> which exports Control.Monad.IO.Class
16:38:51 <hpc> yeah, but it's kind of a rube goldberg
16:41:15 <applicative> TimeDiff isn't so bad if you start from noTimeDiff :) Clint
16:41:34 <applicative> noTimeDiff {tdSec = 4000}
16:45:40 <monochrom> I arbitrarily prefer "signature" = "variable :: type", as opposed to, you know, "type" = "variable :: signature"
16:46:23 <dmwit> huh?
16:46:47 <monochrom> or perhaps "type" = "signature" and "declaration" = "variable :: type"
16:47:31 <monochrom> oh, when you see "joy :: Int -> ()", which part do you say is "type"? is "signature"?
16:48:23 <dmwit> oh
16:52:58 <ion> “Int -> ()” is the flodscroff and “joy :: Int -> ()” is the scribdobble.
16:53:41 <monochrom> is that German? :)
16:53:50 <ion> yes
16:55:34 <monochrom> 217 predators. that's scary. :)
17:06:56 <sobhan> if a is an IO String and i do b <-a b will be a String ?
17:07:17 <scshunt> yes
17:08:21 <sobhan> thanks
17:11:03 <ignacio> that took me a couple of reads
17:11:58 <ignacio> "why is he applying a to b?"
17:14:41 <dmj> anyone know of example code that uses snaplet-auth with snaplet-acid-state?
17:15:08 <dmj> or even if they are even compatible
17:24:46 * hackagebot network-bitcoin 1.3.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.3.0 (ClarkGaebel)
17:26:44 <ReinH> I need f :: Maybe [a] -> Maybe a that returns the first a or Nothing if Just [] or Nothing if Nothing.
17:26:52 <ReinH> Is there a nicer way than (join . fmap listToMaybe) ?
17:27:09 <ReinH> hoogle doesn't have anything
17:27:25 <mstksg> are there any haskell web frameworks that use combinators for type-safe routing?
17:28:27 <dmwit> ReinH: Perhaps you can modify whateven it is that builds your Maybe [a] to build a [First a] or Maybe [First a].
17:29:39 <erisco> mstksg, Yesod might have such a thing
17:30:34 <ReinH> dmwit: in this case it's a Map.Map [a]
17:31:12 <ReinH> I'm primarily indexing the map by key and I want either just the first element of the list or Nothing
17:32:35 <ReinH> @pl f a b = a <|> id <$> b
17:32:38 <lambdabot> f = id (fix (const (flip ((.) . (<|>)) (id <$>))))
17:32:38 <lambdabot> optimization suspended, use @pl-resume to continue.
17:32:51 <ReinH> nah.
17:32:55 <ReinH> pointed it is
17:33:39 <pentace> id <$> b?
17:34:04 <ReinH> pentace: it's not actually id
17:34:15 <watermind> what do you call a non-higher-order type?
17:34:39 <watermind> polynomial?
17:37:11 <dmwit> :t fmap head
17:37:12 <lambdabot> Functor f => f [b] -> f b
17:37:28 <dmwit> :t (>>= listToMaybe)
17:37:29 <lambdabot> Maybe [b] -> Maybe b
17:37:32 <dmwit> ReinH: ?
17:38:03 <ReinH> dmwit: (fmap head) (Just [])
17:38:06 <dmwit> m >>= f = join (fmap f m) -- is the standard definition of (>>=) in terms of join, by the way
17:38:17 <dmwit> > Just [] >>= listToMaybe
17:38:17 <lambdabot>   Nothing
17:38:25 <ReinH> dmwit: yeah I should have figured that one out
17:38:33 <ReinH> that's what I get at staring at something for too long
17:38:34 <ReinH> duh
17:38:44 <mstksg> erisco: it looks like yesod uses strings to specify routes?
17:41:24 <banister`sleep> :t listToMaybe
17:41:24 <lambdabot> [a] -> Maybe a
17:43:31 <erisco> > listToMaybe []
17:43:32 <lambdabot>   Nothing
17:43:36 <erisco> > listToMaybe [1..]
17:43:37 <lambdabot>   Just 1
17:47:05 <skinkitten> is there a project euler channel?
17:47:56 <pentace> skinkitten: /msg alis list *euler*
17:49:03 <skinkitten> aw there isn't a big number of people in them
17:49:06 <skinkitten> thanks pentace
17:50:45 <pentace> skinkitten: Are you trying to solve them in Haskell?
17:51:12 <skinkitten> never used haskell before, only in here because you people are pretty smart
17:51:17 <skinkitten> using python
17:51:37 <skinkitten> still learning to program
17:52:48 <skinkitten> right now, i'm trying to find a way to code a sqrt method
17:54:15 <dmwit> That seems like a really bad idea.
17:54:16 <blackdog> skinkitten: so, newton's method or something?
17:55:59 <skinkitten> blackdog: i'll do it which ever way you know how. you know newton's method?
17:56:23 <blackdog> skinkitten: you can find it on wikipedia - it's a method for successive approximations.
17:56:29 <skinkitten> can you teach me?
17:56:56 <skinkitten> make me write a small method to build up to it
17:56:56 <blackdog> but you should probably work out whether you're meant to be implementing it for pedagogical reasons, or if you just need a library routine.
17:57:15 <skinkitten> learning reasons, exercise
17:57:33 <blackdog> skinkitten: go read the wiki page, then. if you're doing it in python, though, you should probably ask for feedback in the python channel.
17:57:35 <skinkitten> pedagogical
17:57:57 <blackdog> skinkitten: http://mitpress.mit.edu/sicp/full-text/sicp/book/node12.html is also interesting.
17:57:59 <skinkitten> but we've come so far together
17:58:02 <skinkitten> :}
17:58:18 <shachaf> jmcarthur: Any response from edwardk that I missed?
17:58:40 <mstksg> skinkitten: you can also post inquiries to the good people of stackoverflow.com
17:58:49 <jmcarthur> shachaf: no idea. i've been having trouble with the machine i irc from and was cut off. there was certainly no immediate response
17:59:38 <shachaf> jmcarthur: At least now I understand where Mendler algebras come from!
18:00:05 <skinkitten> thanks
18:01:16 <jmcarthur> there is that
18:01:46 <jmcarthur> this page actually explains that fairly well http://www.haskell.org/haskellwiki/Catamorphisms
18:01:57 <jmcarthur> guess who probably wrote it
18:02:01 <jmcarthur> lol
18:02:07 <shachaf> Freenode wins!
18:02:35 <ReinH> Is there an easy way to make a k-tuple containing Num elements into an instance of Num? So that, e.g., (1,1) + (1,0) = (2,1)
18:02:54 <jmcarthur> > (1,1) + (1,0)
18:02:55 <lambdabot>   No instance for (GHC.Show.Show t1)
18:02:55 <lambdabot>    arising from a use of `M1522020666.sh...
18:03:00 <jmcarthur> o_O
18:03:12 <jmcarthur> > (1,1) + (1,0) :: (Int, Int)
18:03:13 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int, GHC.Types.Int))
18:03:13 <lambdabot>    arising fro...
18:03:20 <shachaf> @hackage NumInstances
18:03:20 <lambdabot> http://hackage.haskell.org/package/NumInstances
18:03:21 <jmcarthur> ah... why did i think there was one
18:03:30 <jmcarthur> oh, because i have NumInstances in my .ghci
18:04:07 <ReinH> ah. The one thing I didn't google for.
18:11:40 <jmcarthur> oh, edwardk didn't write that page
18:12:20 <jmcarthur> oh, scratch that actually. the original version was copied from http://knol.google.com/k/catamorphisms
18:12:22 <shachaf> jmcarthur: Isn't that "knol" article his?
18:12:26 <shachaf> Right.
18:15:41 <applicative> oh there's a typical olde school Mu data declaration on the catamorphisms wiki page
18:15:52 <pdxleif> I'm trying to add a "source-repository" section to my .cabal file, but I don't think I'm doing it write, it says "Construct not supported at this position" on the next construct (that was formerly valid) that it encounters.
18:16:55 <applicative> isnt source-repository github.com/pdxleif or whatever
18:17:31 <pdxleif> I was going off this - https://github.com/DougBurke/swish/blob/master/swish.cabal#L83
18:17:55 <pdxleif> Only with git instead of mercurial, and https://github.com/LeifW/yaml2owl.git instead
18:18:15 <pdxleif> But even if I copy & paste his into my .cabal file, "cabal sdist" still complains
18:18:39 <applicative> ah
18:19:13 <pdxleif> Hmm, I can move his copied 'n pasted one to the end of the file, and it seems to work.
18:20:48 <dmwit> If you want help, you're definitely going to have to give us your cabal file to look at.
18:21:16 <pdxleif> Apparently as long as it comes after the line "cabal-version:       >=1.8" it works.
18:21:21 <pdxleif> I'll push this to github in a sec
18:26:18 <shachaf> jmcarthur: Oh, there's also Free/Cofree, sort of.
18:26:30 <shachaf> Well, not really.
18:26:49 <shachaf> You can implement Monad as class Functor m => Monad m where monad :: Free m a -> m a
18:27:02 <shachaf> And Comonad as class Functor w => Comonad w where comonad :: w a -> Cofree w a
18:27:20 <applicative> no, really?
18:27:43 <shachaf> Hmm?
18:28:13 <applicative> monad :: Free m a -> m a
18:28:19 <applicative> i think im seeing though
18:28:20 <elliott> Free M ~~ 1 + M + M^2 + M^3 + M^4 + M^5 + ... -- so you get both return an an arbitrary number of joins
18:28:38 <elliott> *and an
18:28:39 <shachaf> Zero or more, in particular. Where zero joins is return.
18:28:48 <elliott> no, zero joins is id :P
18:28:53 <elliott> the return case is (-1) joins.
18:28:55 <shachaf> OK, -1 joins.
18:29:23 <lpaste> htau pasted “Does this cause your terminal to go mad?” at http://lpaste.net/91113
18:29:31 <applicative> do you put any constraint of monad :: Free m a -> m a
18:29:34 <applicative> on
18:29:54 <elliott> applicative: think of it like mconcat
18:29:56 <elliott> mconcat :: [a] -> a
18:29:59 <elliott> i.e. free monoid on a -> a
18:30:01 <shachaf> Well, it's in a class. So there's a Monad m constraint.
18:30:08 <elliott> monad is free monad on m -> m
18:30:19 <shachaf> It's indeed like mconcat.
18:30:21 <elliott> shachaf: I think applicative means laws
18:30:28 <shachaf> Oh.
18:30:38 <htau> I am curious if anyone else has the same trouble
18:30:42 <shachaf> Well, there are the usual monad laws. I'm not entirely sure how they should be expressed here.
18:30:57 <pdxleif> uploaded the .cabal file - https://github.com/LeifW/yaml2owl/blob/master/yaml2owl.cabal
18:31:16 <elliott> shachaf: I thought I figured them out.
18:31:26 <elliott> the mconcat laws are quite nice
18:31:29 <elliott> though I forget what they are
18:31:32 <elliott> well, it comes down to just one law
18:31:38 <shachaf> elliott: Did you? OK. I don't remember.
18:31:45 <elliott> perhaps: mconcat . concat = mconcat . map mconcat
18:32:07 <elliott> which is startlingly similar to join . join = join . fmap join
18:32:09 <applicative> htau: no, i get 'Exception: Prelude.head'
18:32:14 <shachaf> Hmm, I remember that conversation but I don't think we figured it all out.
18:32:28 <shachaf> elliott: I'm talking about the laws for monad, not for mconcat.
18:32:35 <htau> hmm did you give in an argument?
18:32:40 <elliott> shachaf: yes, I know.
18:32:41 <htau> it*
18:33:46 <applicative> htau: oh wait, i misunderstood something no wonder
18:34:24 <htau> you can just hardcode the string, I just wanted to replicate the bug conditiions as closely as I could
18:34:41 <applicative> htau: seems like I'm getting forever $ putChar '\t'
18:35:02 <htau> ah, that seems right
18:35:45 <htau> Do you have an inkling as to why?
18:35:51 <dmwit> htau: scannerF has no base case
18:36:02 <applicative> htau: yeah, its the same look in ghci if i just do forever (putChar ' ')
18:36:10 <htau> Ah, copy pase failure
18:36:17 <applicative> dmwit to the rescue
18:36:56 <htau> yes indeed, I piped it in from another file with tail and it cut off to critical part
18:37:18 <htau> the*
18:37:27 <htau> many thanks
18:38:44 <jmcarthur> just read the logs on tunes to catch up
18:38:50 <applicative> htau: if i add the obvious base case i get ("a b c",[1,2,3])
18:38:56 <jmcarthur> i think the monad laws are simply implied by Free, no?
18:39:19 <jmcarthur> err
18:39:27 <jmcarthur> no, that doesn't feel right
18:39:36 <shachaf> I'm not sure what you mean, but I think I'll go with "no".
18:39:48 * hackagebot yaml2owl 0.0.1 - Generate OWL schema from YAML syntax, and an RDFa template.  http://hackage.haskell.org/package/yaml2owl-0.0.1 (LeifWarner)
18:40:07 <jmcarthur> that would be like saying [a] -> a implies the monoid laws
18:40:10 <shachaf> jmcarthur: At one point I observed that return :: a -> m a and join :: m (m a) -> m a could be combined into a sort of monad :: Either a (m (m a)) -> m a
18:40:24 <shachaf> Obviously that should be subject to the same laws as regular return/join.
18:40:42 <shachaf> This Free thing is just a generalization of that to 0-or-more ms rather 0/2 ms.
18:40:55 <shachaf> (And the same thing for Cofree.)
18:40:57 <jmcarthur> hmm
18:41:06 <jmcarthur> i see
18:41:31 <shachaf> monad :: (Id :+: (m . m)) ~> m
18:41:38 <jmcarthur> I + (M . M) ~> M
18:41:42 <jmcarthur> :P
18:41:42 <shachaf> Yes.
18:42:23 <dmwit> By analogy, the free monoid would be data FreeMonoid a = MAppend (FreeMonoid a) (FreeMonoid a) | MEmpty. But we teach that [a] is the free monoid instead because it's what you get when you quotient that type by the monoid laws.
18:42:43 <dmwit> I think probably the thing you get by quotienting Free by the monad laws is too complicated for Haskell's ADT framework.
18:42:44 <shachaf> dmwit: By analogy to what?
18:42:49 <dmwit> By analogy to Free.
18:42:50 <shachaf> Free has to be right-associated. It's not a tree.
18:43:20 <dmwit> That means it quotients by one but not all of the laws.
18:43:56 <shachaf> Free m *is* a monad.
18:44:07 <applicative> instance Monad Maybe where monad = const Nothing
18:44:12 <shachaf> It's just not the same monad as m.
18:44:22 <shachaf> So you need laws, but that's laws for the individual monad.
18:44:39 <jmcarthur> analogous to your FreeMonoid would be   data FreeMonad f a where Return :: a -> FreeMonad f a; Bind :: FreeMonad f a -> (a -> FreeMonad f b) -> FreeMonad f b
18:44:47 <dmwit> Okay, I looked it up. I had the wrong definition of Free in mind.
18:44:50 <htau> applicative: that is what I expected and hoped to get, though I am curious why ghc did not throw an error
18:44:54 <dmwit> Yes, what jmcarthur is writing.
18:44:57 <shachaf> There are way too many things that are called Free.
18:45:01 <dmwit> Apologies, and ignore me, as usual.
18:45:25 <shachaf> I'm going to call it Freem now.
18:46:01 <shachaf> jmcarthur: If you drop the FreeMonad from the first argument of Bind you end up with a real free monad (whenever f is a functor, at least).
18:46:13 <applicative> > break (== 'z') ""
18:46:14 <shachaf> Which I suppose there's no point in saying at this point.
18:46:14 <lambdabot>   ("","")
18:47:12 <elliott> shachaf: clearly class Functor m => Monad m where monad :: Free Monad m a -> m a
18:47:29 <shachaf> Clearlliott.
18:47:54 <shachaf> elliott: So you say that you worked out the laws for Freem-Monad? What are they?
18:48:03 <elliott> I don't remember them.
18:48:12 <elliott> but they were good.
18:48:14 <shachaf> elliott is all about the Kleisli arrows these days, anyway. Functor constraints are beneath him.
18:48:43 <elliott> the mconcat law is mconcat . concat = mconcat . map mconcat
18:48:51 <tabemann> is there any real good reason why runStateT doesn't take Monad m => but evalStateT does?
18:48:54 <elliott> I bet one of the laws is monad . monad = monad . fmap monad or something.
18:48:58 <elliott> ok, that's ridiculous
18:49:08 <elliott> tabemann: the latter needs it to liftM over the result.
18:49:14 <tabemann> yeah
18:49:25 <htau> applicative: but '\t' ? shouldn't that translate to forever $ putStrLn ""? or it that how terminals behave in that case
18:51:07 <applicative> htau: it wasn't '\t' it was ' '
18:51:14 <applicative> my first guess was wrong
18:51:33 <htau> ah, then all is clear
18:53:48 <applicative> htau: in  (f w) : scannerF f delim s'' where (w, s'') = break (== delim) s'
18:54:40 <applicative> here f is id but we keep breaking and taking the first element of the pair
18:54:42 <applicative> > break (== '1') " "
18:54:43 <lambdabot>   (" ","")
18:59:48 * hackagebot unix-time 0.1.10 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.10 (KazuYamamoto)
18:59:53 <applicative> htau: its sort of like
18:59:54 <applicative> >  unwords $ unfoldr (Just . break (== ';')) ""
18:59:55 <lambdabot>   "                                                                          ...
19:02:15 <htau> True, though in this case it is most like words sans base case
19:02:22 <htau> @src words
19:02:22 <lambdabot> words s = case dropWhile isSpace s of
19:02:22 <lambdabot>     "" -> []
19:02:22 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
19:02:37 <applicative> ah, hes
19:02:45 <dmwit> htau: You might like
19:02:47 <dmwit> ?hackage split
19:02:48 <lambdabot> http://hackage.haskell.org/package/split
19:02:54 <applicative> ah yes, rather
19:03:07 <applicative> naw, just reimplement it htau
19:03:38 <htau> I always forget the name of that library...
19:03:47 <applicative> grr this pipes-4 nonsense is breaking my feeble brain
19:04:50 <htau> so I usually just pipe in similar functions from a "mini-parse" library I keep.
19:07:01 * tabemann is kind of wishing that the record syntax in Haskell had just autogenerated "setter" functions for records rather than using the silly record update syntax...
19:07:38 <dibblego> tabemann: you might be interested in hackage/lens
19:09:24 <applicative> i was going to say, tabemann, i have just the template haskell for you
19:09:30 <elliott> tabemann: doesn't work for type-changing in the presence of multiple fields
19:09:33 <tabemann> it's probably not essential for what I'm doing, and it's kind of performance-essential
19:09:44 <elliott> lens has very good performance for simple record setting.
19:09:52 <elliott> like, if it is any different to using the record updates directly, that's a bug.
19:09:59 <tabemann> elliott: yeah, setter functions don't work for multiple updates
19:10:06 <elliott> it should get completely inlined away alwys
19:10:08 <elliott> *always
19:10:30 * tabemann is implementing push/pop actions for updating his scheme thread state...
19:10:42 <applicative> sure you just compose them
19:12:35 <applicative> is lens in scope with lambdabot?
19:12:37 <applicative> > (4,5) & (_1 .~ 'a') . (_2 .~ 17)
19:12:38 <lambdabot>   Not in scope: `_1'Not in scope: `.~'
19:12:38 <lambdabot>  Perhaps you meant one of these:
19:12:38 <lambdabot>    `....
19:12:41 <applicative> bah
19:12:57 <applicative> ('a',17)
19:13:42 <applicative> tabemann: lenses are pretty dream for MonadState things
19:13:45 <applicative> pretty dreamy
19:14:43 <tabemann> yeah, I'm basically passing around a ThreadState through StateT, and wrapping that in SchemeT so users don't just modify state with put and get themselves
19:14:44 <shachaf> @let import Control.Lens.Tuple
19:14:45 <lambdabot>  Defined.
19:14:51 <shachaf> @let import Control.Lens.Setter
19:14:52 <lambdabot>  Defined.
19:14:53 <shachaf> Etc.
19:15:28 <applicative> > (4,5,"california") & (_1 .~ 'a') . (_2 .~ 17) . (_3 .~ True)
19:15:30 <lambdabot>   Not in scope: `&'
19:15:38 <applicative> foiled again
19:15:44 <shachaf> @let import Control.Lens.Combinators
19:15:45 <lambdabot>  Defined.
19:15:52 <shachaf> You can import the next ones.
19:16:33 <applicative> > (4,5,"california", Just 1) & (_1 .~ 'a') . (_2 .~ 17) . (_3 .~ True) . (_4 .~ "Portugal")
19:16:34 <lambdabot>   ('a',17,True,"Portugal")
19:16:41 <applicative> at last
19:18:14 <pentace> > Just 1 & (_1 .~ 'a')
19:18:16 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1
19:18:16 <lambdabot>                      (Data.Mayb...
19:19:58 <applicative> > flip runState (0,0) (_1 .= 3 >> _2 .= 12 >> _1 %= (+33))
19:19:59 <lambdabot>   ((),(36,12))
19:20:47 <applicative> > (Just 1,"pentace") & (_1 .~ 'a')
19:20:48 <lambdabot>   ('a',"pentace")
19:21:27 <pentace> Can't you use it directly on a Maybe?
19:21:44 <applicative> If Maybe a has a Field1 instance
19:21:56 <shachaf> pentace: _1 is for tuples.
19:22:03 <applicative> which is a little improbable, but everything about lens is improbable
19:22:13 <shachaf> > set _Just 'a' (Just 1)
19:22:14 <lambdabot>   Not in scope: `_Just'
19:22:22 <shachaf> > set traverse 'a' (Just 1)
19:22:22 <lambdabot>   Not in scope: `traverse'
19:22:23 <lambdabot>  Perhaps you meant one of these:
19:22:23 <lambdabot>    `T.traverse' (...
19:22:25 * shachaf sighs.
19:22:30 <shachaf> @let import Control.Lens.Traversal
19:22:31 <lambdabot>  Defined.
19:22:34 <shachaf> > set traverse 'a' (Just 1)
19:22:36 <lambdabot>   Just 'a'
19:22:39 <shachaf> > set traverse 'a' Nothing
19:22:40 <lambdabot>   Nothing
19:22:45 <applicative> the system doesn't work unless everything is in scope
19:23:01 <shachaf> Usually you just have to import Control.Lens.
19:23:18 <applicative> but that wreaks havoc for lambdabot?
19:23:28 <applicative> yes, I know most of this would have been in scope
19:24:47 <pentace> Can you define new data types in lambdabot?
19:26:20 <shachaf> Yes, in /msg you can just say "@let data ...".
19:31:56 <pentace> Wow, the lens API looks complicated ...
19:36:58 <tabemann> what package is Control.Lens.* in, because I'm searching Hoogle and Hackage, and only seeing stuff that's in Data.Lens.*
19:37:05 <ion> pentace: It’s basically the same thing fmap and traverse do.
19:37:07 <ion> @hackage lens
19:37:07 <lambdabot> http://hackage.haskell.org/package/lens
19:37:14 <shachaf> @google control.lens
19:37:15 <lambdabot> http://hackage.haskell.org/packages/archive/lens/1.2/doc/html/Control-Lens.html
19:37:16 <lambdabot> Title: Control.Lens
19:37:19 <shachaf> Yes, that.
19:37:39 <shachaf> Hoogle is not a good way of searching Hackage. Try Google or Hayoo.
19:37:44 <shachaf> Or maybe even Yahoo?
19:37:49 <tabemann> okay, I was using Hoogle there
19:37:52 <pentace> ion: You mean the complete package?
19:38:18 <ion> pentace: The essence of Control.Lens lenses and traversals.
19:39:11 <shachaf> Understanding Traversal is the most important step to understanding lens.
19:42:12 <dmwit> new-hackage also has a pretty good search
19:44:49 * hackagebot handa-gdata 0.6.5 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.5 (BrianBush)
19:45:49 <tabemann> that page for lens makes my brain hurt
19:48:01 <Zenol> Short question. In haskell, is it the same as doing fct (x:xs) = x : fct xs and fct acc (x:xs) = fct (x : acc) xs (Excepted the fact that the list is reversed in the second case)
19:48:37 <Zenol> Because the second is tailrec, but we are computing a lazy list, so I think that fct actualy return "x : fct xs" as a thunk. Nop?
19:48:43 <dibblego> Zenol: no, they are quite different — in what context do you see this?
19:49:18 <Zenol> I just wonder if it's usefull to rewrite "tailrec" a function that produce a lazy result.
19:50:39 <shachaf> Forget about tail recursion for a while. Haskell is not evaluated the way you think it is.
19:51:41 <Zenol> also, map is implemented as map f (x:xs) = f x : map f xs
19:52:09 <Zenol> not as mapAux acc f (x:xs) = mapAux (f x : acc) xs
19:53:00 <Zenol> shachaf> Is not evaluated the way I think it is? So x : fct xs do not create a thunk that would only be evaluated once : will be deconstructed?
19:53:10 <jdhutah> maybe a dumb question, but is there a tool to help check for partial functions? or is this dumb because its equivalent to the halting problem or something?
19:53:31 <dibblego> jdhutah: haskell's type checker helps with this
19:53:56 <shachaf> jdhutah: In general it's equivalent to the halting problem, yes.
19:54:06 <shachaf> jdhutah: There are lots of specific kinds of partiality that GHC can catch, though.
19:54:22 <shachaf> E.g. forgetting to pattern-match on something. You should compile with -Wall for that.
19:54:29 <jdhutah> ah ok
19:54:31 <jdhutah> thanks
19:54:35 <shachaf> Some kinds of partiality it catches at runtime, e.g. "let x = x in x" (<<loop>>).
19:54:50 <jdhutah> right
19:55:02 <shachaf> By which I don't actually mean catches.
19:55:08 <shachaf> Or maybe I don't mean partiality?
19:55:28 <shachaf> I mean infinite loops. It catches them and turns them into, uh, OK, ignore what I've been saying.
19:55:33 <jdhutah> i think uncomputability counts
19:55:33 <jdhutah> ha
19:55:46 <jdhutah> ok i get the gist though, ghc has some detection builtin
19:55:46 <shachaf> Anyway, -Wall is good.
19:55:53 <jdhutah> just can't definitively catch everything
19:56:05 <jdhutah> yeah, will use. thanks much
19:56:09 <shachaf> Try a language like Agda for that!
19:56:20 <jdhutah> ha
19:56:29 <meretrix> I just did some quick tests, and it seems on my oldish hardware, threadDelay has an effective minimum delay of about 1.0-1.5ms.  Does that sound about right? Is it just a limit of the linux scheduler?
19:56:52 * Zenol was just snobbed
19:57:06 <applicative> snobbed?
19:57:09 <shachaf> Zenol: Oops, I didn't see your message.
19:57:16 <applicative> ah well
19:57:22 <shachaf> Maybe try "shachaf:" instead of "shachaf>". :-)
19:57:24 <Zenol> applicative> Ok, this word didn't exist in english >.<
19:57:47 <shachaf> Anyway, I don't know how you think it's evaluated, so I can't say.
19:57:52 <elliott> perhaps you mean "snubbed"
19:58:23 <bscarlet> > let fct (x:xs) = x:fct xs in take 10 (fct [0..])
19:58:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
19:58:29 <shachaf> Most people who start out with Haskell and talk about tail recursion etc. tend to have a very different mental model of GHC evaluation from what GHC actually does.
19:58:32 <shachaf> But whatever.
19:58:37 <bscarlet> > let fct acc (x:xs) = fct (x : acc) xs in take 10 (fct [] [0..])
19:58:40 <lambdabot>   mueval-core: Time limit exceeded
19:59:03 <shachaf> meretrix: GHC threads aren't Linux threads. So whatever it is will probably be more complicated than that.
19:59:13 <Zenol> shachaf: I thought that when you apply a lazy function or a lazy data type constructor, instead of really computing something, it just say "oh, I have a box of the right type! Fine, I'll just go out of the function and give the box."
20:00:31 <Zenol> shachaf: but not sure it's right. Anyway, the fact that map isn't writen with accumulator/tailrec confirm my intuition that doing that isn't good in haskell. But I would like to understand why.
20:01:48 <bscarlet> Zenol: I give a simple example of what one can do that the other can't above. I don't know if that helps.
20:01:57 <Zenol> yeh there is also the infinite data issue.
20:02:54 <roboguy_> Zenol: it does do things lazily and that's why accumulator parameters don't necessarily get the performance you'd expect (without strictness annotations). it builds up a big thunk which can (perhaps counterintuitively at first) give a stack overflow (even though it's tail recursive)
20:04:16 <Zenol> roboguy_> Oh, I see. In the first case the tunk is just a call to :, and in the second the tunk is the whole list.
20:04:16 <dmj> roboguy_: thunks can be evaluated to WHNF using seq, right?
20:04:28 <roboguy_> dmj: yeah
20:04:55 <dmj> so foldl' is truly tail recursive then?
20:05:02 <dmj> @src foldl'
20:05:02 <lambdabot> foldl' f a []     = a
20:05:02 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:05:16 <latro`a> only up to WHNF
20:05:18 <roboguy_> dmj: well so is foldl, but foldl' is strict also
20:05:26 <shachaf> foldl and foldl' are both tail-recursive and tail recursion means different things in Haskell than it does in, say, Scheme.
20:05:35 <latro`a> if you fold a list of tuples, thunks still accumulate, just not to the tuples
20:05:40 <latro`a> *foldl'
20:06:14 <latro`a> err, if you foldl' with an f whose return type is a tuple, rather
20:07:46 <roboguy_> or, to be more clear, foldl and foldl' are both tail recursive but foldl is lazy and foldl' is strict
20:07:54 <Zenol> yes but using fold' with a list as accumulator would be a bad idea, right?
20:08:17 <roboguy_> Zenol: foldl' is strict, so the thunks don't accumulate in that way
20:09:03 <applicative> meretrix: hah, i see, if I just replicate (threadDelay 0) it seems to be coming out to .3 microseconds for each (non) delay
20:09:43 <roboguy_> Zenol: accumulator parameters should always be strict, to avoid overflows
20:10:25 <Zenol> yes...
20:11:00 <shachaf> roboguy_: Except when they shouldn't.
20:11:16 <roboguy_> shachaf: I figured there would be exceptions after I said that. what's a good example?
20:11:29 <tabemann> (premature) optimization question:
20:11:47 <shachaf> tabemann: (premature) answer: Don't do it. Just don't.
20:11:56 <shachaf> This applies to all premature optimization.
20:12:02 <applicative> yes, use bang patterns everywhere
20:12:11 <dmwit> uh
20:12:12 <tabemann> in my Scheme runtime, when I'm checking for instructions in a function, a properly compiled function will never let me reach the end of it, so if I do reach the end of it, I should raise an exception anyways...
20:12:16 <dmwit> Is foldl' really tail-recursive?
20:12:25 <dmwit> Its outermost call is seq, not foldl'.
20:12:34 <shachaf> Hmm, true.
20:12:42 <tabemann> sooo... should I just omit the check for checking whether an index in a function is valid, because (!) will return bottom for me if I go over bounds anyways?
20:12:47 <shachaf> OK, it's not tail-recursive.
20:13:03 <applicative> does seq count? maybe the compiler reads it to mean, treat this as tail recursive if possible
20:13:08 <shachaf> tabemann: That is such a localized thing that if it ever makes a difference, you can test for it yourself.
20:13:23 <roboguy_> does seq add to the call stack in the way that would implied by saying it's not tail recursive, though?
20:13:34 <applicative> the data list definition is wrong as dons sometimes pointed out
20:13:34 <dmj> shachaf: foldl' isn't but foldl is?
20:13:35 <dmwit> Call stacks are different with laziness.
20:14:01 <Zenol> I would be really surprised if foldl' can't execute in fixed memory...
20:14:37 <dmwit> Zenol: It can. As people have been trying to say: tail recursion isn't the right question to ask about Haskell code.
20:14:44 <tabemann> shachaf: the only reason why I'm considering omitting the check is that this is *such* an inner loop thing (i.e. it is done for *every* VM instruction), that the optimization may be worth it
20:14:57 <shachaf> tabemann: OK, so put the check in, and then take it out if it matters.
20:15:04 <shachaf> Write a correct program first.
20:15:10 <tabemann> and also by doing so I can avoid calling bounds for every single VM instruction, and avoid passing around the size by hand (if I want to avoid applying bounds)
20:15:53 <shachaf> If this is really so important that you have to do it now, and you're knowledgeable enough to know that you should do it now, then you should also know how to figure out the answer yourself.
20:15:56 <tabemann> okay, I'll put in the check for starters, but I'm going to have it raise an exception anyways, but with a more meaningful message than if (!) went over bounds
20:16:13 <shachaf> (Namely, look up the source of (!), see if it does a check. Maybe you really want to use an unsafe function instead and do the check yourself. Maybe something else.)
20:16:24 <tabemann> so if the compiler puts out bad code I'll know
20:16:36 <Zenol> dwit> we are probably not calling a tail rec the same thing. For me it's nothing more that something that can be rewriten by the compiler as a loop. In the case of foldl', it's probably the case, and for foldl probably not(although nobodie explained how ghc handle think and that was my real question)
20:16:41 <tabemann> the Data.Array page doesn't point at any sources for (!)
20:16:47 <Zenol> but I really need to sleep before the sun wakeup.
20:16:57 <Zenol> 'night.
20:17:35 <lpaste> applicative pasted “foldl_dons” at http://lpaste.net/91114
20:18:02 <tabemann> okay, looked in Data.Array.Unsafe, there's no unsafe version of (!) at least in there
20:18:03 <applicative> the second of those, is I think what dons thinks is the intended but botched definition
20:18:13 <dmj> dmwit: I'd be curious to learn more about stack allocation in haskell. Would Int vs. Integer, be a good example?
20:18:34 <dmwit> Stack allocation happens when you force a thunk.
20:19:45 <roboguy_> non-tail recursion can eventually lead to a stack overflow from the call stack right? maybe I don't actually understand very well
20:19:57 <applicative> the complications with the explicit seq in Data.List make no sense, the argument should be strict, then we don't need to seq the expression op x y
20:20:22 <dmj> dmwit: is it right to say seq forces a thunk into whnf
20:20:35 <dmwit> hm
20:20:40 <dmwit> seq is a function.
20:21:09 <dmj> everything is a function tho right
20:21:14 <dmwit> No.
20:21:17 <dmj> except values
20:21:29 <tabemann> to the user, but internally, is applying x `seq` y actually resulting in anything being pushed onto the stack before the evaluation of y?
20:21:30 <dmwit> Some values are functions. True is a value, and not a function.
20:21:39 <applicative> no, everything is an exception
20:22:07 <dmwit> Let's talk about pseq. It's easier.
20:22:09 <applicative> hu, it's zero-ary
20:22:40 <NemesisD> has anyone used acid state's Memory.Pure backend for testing before?
20:22:47 <dmwit> When you force "pseq a b", the promise is that "a" will be reduced to WHNF before "b" is forced.
20:22:47 <dmj> tabemann: I'd like to know as well
20:23:51 <dmwit> So, to evaluate "pseq a b", GHC will push "a" onto the stack; when it pops, then it will push "b" onto the stack.
20:24:59 <dmwit> roboguy_: foldl is tail-recursive and also the easiest way to cause a stack overflow.
20:26:27 <applicative> foldl is the general abstracted form of a 'tail recursive' definition
20:26:53 <roboguy_> dmwit: I understand that, I was wondering about *non* tail recursive functions though
20:26:55 <tabemann> whereas non-tail recursive code is fine as long as the chain of function applications between the application of the recursive function and the return value is broken by a lazy argument, i.e. why foldr (:) foo bar doesn't overflow the stack
20:27:31 <tabemann> while foldr (+) 0 [1..100000000000] does (because (+) is strict on its second argument)
20:27:33 <dmwit> roboguy_: Guarded recursion is not tail-recursive, and will generally speaking not cause a stack overflow.
20:27:57 <roboguy_> hmm
20:29:59 <dmwit> (e.g. "foo n x = n : foo n x" is an example of guarded recursion)
20:31:18 <tabemann> (this is something I had to get used to coming from OCaml, where that kind of thing is a big no-no, whereas it is a very common idiom in Haskell)
20:31:26 <applicative> or to make the contrast with tail recursion plain
20:31:37 <applicative> foo n x = (:) n (foo n x)
20:31:52 <applicative> where the outermost operation is the constructor, so its 'productive'
20:32:53 <applicative> > let foo n x = n : foo n x in foo 4 ()
20:32:54 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
20:38:56 <dmwit> All of a sudden I feel silly for the "x" bit.
20:50:57 <dmj> is it safe to say thunks are put on the heap, but evaluated on the stack?
20:52:06 <dmwit> That sounds right.
20:52:42 <dmj> vundebar
20:53:26 <dmj> just found this article, hope its good. http://users.aber.ac.uk/afc/stricthaskell.html
20:55:03 <carter> dmj the tibbel high performance haskell talk from a few years ago is still good
20:55:23 <tabemann> it is
20:55:26 <dmwit> If you want to learn about how Haskell does evaluation, I'd point you to "Inside 234s" or whatever it's called.
20:55:43 <dmwit> Let's see if I can find the article I'm thinking of...
20:56:12 <dmwit> http://blog.ezyang.com/2011/04/the-haskell-heap/
20:56:50 <dmj> carter: thanks I need to give that a re-read
20:56:57 <NemesisD> anyone know of any other databases in haskell that have in-memory modes in addition to persisted for testing other than acid-state
20:57:24 <dmj> dmwit: thanks!
20:57:36 <tabemann> cool - B&N has Okasaki's book, so I use that B&N card I got for a gift on something actually useful
20:58:21 <NemesisD> ugh is there seriously no test suite for acid-state?
21:00:07 <dmj> NemesisD: Not sure if this will help, but maybe trying Data.Binary encode and decode, writing/reading from disk, might work, unless you need something more complicated.
21:00:19 <lpaste> DiegoNolan pasted “StackOveflw” at http://lpaste.net/91115
21:00:30 <DiegoNolan> why is this code causing a stackoverflow?
21:00:44 <DiegoNolan> with about 4K strings
21:00:51 <DiegoNolan> of about 10characters length
21:01:34 <NemesisD> dmj: my needs are a bit beyond trying to roll my own persistence layer. i like acid-state in theory but in practice i have problems and i'm bothered by it seemingly having no tests
21:02:17 <NemesisD> dmj: the reason why i'm tempted to sticking to pure haskell stuff is i'm storing my data in a table from the tables package, makes it really nice for lens-based lookups, manipulation, etc
21:03:11 <dmwit> DiegoNolan: Because WHNF only evaluates lists to either (:) _ _ or [].
21:03:31 <dmwit> DiegoNolan: Hence the second argument to "go" is building up an enormous thunk right underneath the top-most (:).
21:03:49 <DiegoNolan> what is WHNF
21:04:09 <DiegoNolan> do i have to move a strict datastructure?
21:04:58 <dmj> DiegoNolan: http://www.haskell.org/haskellwiki/Weak_head_normal_form
21:05:31 <dmwit> WHNF is a fancy way of saying you evaluate only until you reach a constructor and no farther.
21:06:06 <DiegoNolan> ic
21:06:25 <DiegoNolan> should i just make a sequence and then convert it to list and then return?
21:06:26 <dmwit> e.g. (error "foo" : error "bar") doesn't throw any exceptions if you only go to WHNF.
21:06:32 <dmwit> re: do you have to move to a strict data structure: no.
21:06:36 <DiegoNolan> ah
21:06:42 <dmwit> You could easily build up the list in reverse, and reverse it once at the end.
21:06:43 <DiegoNolan> use deep seq?
21:06:48 <DiegoNolan> ah
21:06:49 <DiegoNolan> okay
21:06:57 <DiegoNolan> lemme give it a shot
21:07:13 <dmwit> or
21:07:38 <dmwit> Even better, just write commaSeparated xs = last xs ++ "," -- ?
21:07:48 <dmwit> Since go doesn't use acc at all in the second clause.
21:08:30 <DiegoNolan> wait
21:08:37 <DiegoNolan> last xs ++ "," --
21:08:42 <DiegoNolan> what is the remaining part
21:08:48 <dmwit> -- starts a comment
21:08:52 <dmj> NemesisD: Can you just encode the entire table :) You wouldn't get "transparent logging to disk" though.
21:09:05 <dmwit> Also, I no longer understand why it stack overflows.
21:09:13 <shachaf> What stack overflows?
21:10:09 <DiegoNolan> dmwit: how does using last help me?
21:10:17 <dmwit> It doesn't stack overflow here.
21:10:25 <dmwit> Are you sure you are showing us the same code you're running?
21:10:38 <DiegoNolan> yeah
21:10:43 <DiegoNolan> i mena there is other stuff
21:10:52 <DiegoNolan> but i'm pretty sure that is what is doing it
21:11:07 <dmwit> Can you give us enough instructions to reproduce the stack overflow ourselves, please?
21:11:19 <dmwit> shachaf: http://lpaste.net/91115
21:13:09 <DiegoNolan> dmwit: i guess it isn't there
21:13:28 <DiegoNolan> dmwit: there is way too much code needed to provide it all
21:14:02 <shachaf> dmwit: How do you get it to stack overflow?
21:14:18 <dmwit> Okay, well, producing a minimal reproducing sample is a good way to find a problem, so I suggest attempting that exercise.
21:14:21 <dmwit> shachaf: no
21:14:43 <dmwit> shachaf: I just read it quickly and took a guess. Then later I noticed that it doesn't even use acc in the second clause and did a double-take.
21:14:44 <shachaf> dmwit: That's a good way to do it.
21:15:11 <dmwit> err
21:15:16 <dmwit> misread your question, sorry =P
21:15:25 <dmwit> I thought you asked "Did you get it to stack overflow?".
21:15:51 <dmwit> But if you read my answer as a Prolog-style answer, it seems to be correct. =P
21:15:58 <shachaf> I read it as mauke-style.
21:16:20 <shachaf> Which seemed odd because mauke would be on the other side if anything.
21:16:51 <DiegoNolan> if you want a tuple to be strict do you have to put the bang patterns in each part?
21:17:11 <dmwit> I feel that arbitrarily strictifying things is a mistake if you don't know what's causing your stack overflow yet.
21:27:32 <volitek> im trying to cabal install yesod but fast-logger fails to compile... what should i do?
21:27:56 <volitek> i get a type error about bytestrings and io bytestrings
21:28:11 <DiegoNolan> dmwit: I found the cause
21:28:22 <DiegoNolan> dmwit: other places in code
21:28:26 <dmwit> Nice! What was wrong?
21:28:57 <DiegoNolan> i had a function that iterated over every image in a pixel and then calculated the mean RGB values
21:29:01 <DiegoNolan> i guess it was too lazy
21:29:10 <dmwit> volitek: Open up the code and take a stab at fixing it. Or complain to the maintainer. Or install an older version.
21:29:21 <dmwit> ...or install a newer version!
21:29:25 <DiegoNolan> i agree that i shouldn't be throwing bang patterns everywhere but it is usally very difficult to find the overflow
21:29:42 <DiegoNolan> very easy to be reckless when prototyping
21:29:56 <dmwit> Ah, yeah, I can't count how many times I've been bitten by a lazy iteration.
21:30:12 <NemesisD> this is maddening: (acid', w' :: EWatch) <- update acid $ insert w: couldn't match type EWatch with (t0, EWatch), expected EventResult CreateWatchEvent, actual type (t0, EWatch)
21:30:25 <dmwit> Typically iterating something super-innocuous... like (+1). =P
21:30:55 <tabemann> basically when accumulating, the accumulator should be strict
21:31:04 <NemesisD> i think i need help reading that, my pattern is treating it like a tuple, its saying i'm expecting an EventResult CreateWatchEvent but actually getting a tuple, but i'm expecting a tuple
21:31:17 <NemesisD> have i lost my ability to read ghc errors?
21:31:26 <volitek> dmwit: how do i install an old version?
21:32:00 <dmwit> volitek: cabal install yesod --constraint "fast-logger == 0.0.0.0"
21:32:11 <dmwit> ...pick a better version number than 0.0.0.0, of course.
21:33:13 <volitek> thanks a lot :)
21:33:34 <dmwit> NemesisD: Perhaps you could paste the exact error and the line it references to lpaste.
21:33:52 <dmwit> Bonus points for including enough code that we can reproduce the error ourselves.
21:34:40 <tabemann> my my my global reference dereferencing is looking *ex-pen-sive*...
21:35:42 <tabemann> hmm
21:35:50 <dmwit> Global reference? What's that?
21:36:09 <dmwit> ;-)
21:36:25 <tabemann> I don't know what in the way of unsafe operations it may be using under the hood, but just how thread-safe is Data.HashMap.Strict, i.e. is it okay if someone else is inserting into the same hashmap to make a new hashmap while doing a lookup in it in a different thread
21:36:37 <tabemann> it's in my scheme, I've got a VM instruction to look up a globally-bound name
21:37:11 <NemesisD> dmwit: code is here https://github.com/MichaelXavier/vigilance/blob/master/test/Utils/Vigilance/TableOpsSpec.hs#L31
21:37:16 <tabemann> and in the present implementation, it has to grab a lock the first time a globally-bound name is looked up in any piece of code, to protect the lookup from any potential defines happening simultaneously in a different thread
21:37:34 <lpaste> NemesisD pasted “vigilance error” at http://lpaste.net/91116
21:37:45 <dmwit> tabemann: Thread-safe? Thread safety comes free with purity.
21:38:13 <tabemann> dmwit: that's why I was wondering if it was doing anything thread-safe under the hood, while being outwardsly pure
21:38:18 <tabemann> i.e. is it *reentrant*
21:38:24 <tabemann> s/safe/unsafe
21:38:43 <NemesisD> dmwit: i think the problem is  idon't know how EventResult works in acid-state
21:39:09 <tabemann> if it's reentrant than I've just got a race condition when a dereferencing occurs at the same time as define, but it should still be *safe*
21:39:13 <dmwit> tabemann: The data structure is pure.
21:39:51 <dmwit> "pure" isn't the right word.
21:39:55 <dmwit> I don't know what the right word is.
21:40:13 <dmwit> There are no IORefs, IOArrays, MVars, etc. inside.
21:41:05 <tabemann> from asking around before, apparently IORefs and IOArrays *are* safe with concurrent accesses, i.e. there may be race conditions, but at no point what someone might get out of, say, readIORef, will be *inconsistent*
21:41:53 <isomorphic> Slightly OT, but does anybody happen to know how MVars seem to know when they'll never get more data / deadlocked?
21:42:07 <dmwit> tabemann: I'm a bit lost now. Do you feel your question has been answered or not?
21:42:12 <tabemann> yes
21:42:16 <dmwit> great =)
21:43:12 <dmwit> isomorphic: It's the same question as knowing when to garbage collect pure values.
21:43:42 <isomorphic> dmwit:  Thanks.  :)
21:44:59 <dmwit> That is, the runtime gives MVars a bit of support; it knows when all referencing threads are waiting to read (or when all referencing threads are waiting to write).
21:45:05 <elliott> tabemann: what do you mean by consistent? there can be very weird ordering properties with IORefs
21:45:08 <elliott> Data.IORef documentation describes it
21:45:43 <tabemann> elliott: I mean I won't get garbage out of readIORef, just that I'm not guaranteed any particular ordering
21:46:01 <elliott> sure
21:47:29 <tabemann> I figure that the case of code being executed while a different thread is simultaneously doing defines is unlikely enough that it's better to optimize for faster lookups (and to avoid blocking on concurrent lookups) than to ensure consistent ordering on looking up new defines
21:49:51 * hackagebot ec2-signature 1.0 - The Amazon EC2 style signature calculator.  http://hackage.haskell.org/package/ec2-signature-1.0 (YusukeNomura)
21:51:52 <dmwit> NemesisD: Presumably EventResult CreateWatchEvent evaluates (at the type level) to a tuple type.
21:52:16 <dmwit> err
21:53:25 <dmwit> Presumably I have no idea which way "expected" and "actual" go for patterns.
21:54:10 <NemesisD> shmm
21:56:42 <dmwit> Okay, the expected type is the type inferred for the pattern from elsewhere, and the actual type is the type of the thing it's being bound to.
21:56:54 * tabemann wonders how firing (nuclear) missiles (to the moon) became the canonical example of unsafe things one can do with IO, and particularly unsafePerformIO...
21:57:29 <mgsloan> tabemann: Can you think of a more unsafe thing that's controlled by computers?
21:58:08 <dmwit> NemesisD: Dunno whether that helps you read the error or not. It didn't help me. =P
21:58:47 <volitek> dmwit: didnt work in the end... :( where are the haskell files kept for cabal packages? I can only find a tar.gz and a couple .hi files
21:59:07 <mgsloan> dmwit / NemesisD: I really dislike how type synonyms make type errors confusing, and I do think that's what's happening here
21:59:19 <NemesisD> ah ok
21:59:19 <tabemann> mgsloan: that's assuming that your machine running Haskell is actually hooked up to a system for launching missiles; I presume they actually program in things like Ada for those kinds of things
21:59:19 <dmwit> What's weird is that usually I expect that in "couldn't match W with X; expected Y, actual Z" we have "W" as a subterm of "Y" and "X" as a subterm of "Z".
21:59:43 <dmwit> mgsloan: Yes, it seems like there must be some synonyms or families or something here.
21:59:43 <mgsloan> NemesisD: When I run into stuff like this I usually use ":i" in ghci on the types involved, especially the thing I suspect to be a type synonym
21:59:54 <tabemann> and of course Ada doesn't even bother with attempting to be pure
22:00:07 <dmwit> volitek: You can use cabal unpack.
22:00:35 <mgsloan> NemesisD: In the case that that thing uses types I don't understand, I often use ":i" on them as well incase they're also type synonyms
22:01:01 <mgsloan> (though you don't see that too much outside of e.g. lens :) )
22:01:10 <NemesisD> oh in ghci?
22:01:14 <mgsloan> yup!
22:01:23 <dmwit> Oh, you want to know something else fun?
22:01:39 <dmwit> On occasion, I have found that -fdefer-type-errors gives *better* type errors than -fno-defer-type-errors.
22:01:43 <NemesisD> this would be a lot easier if acid-state actually had examples of their Memory.Pure version
22:04:32 <mgsloan> dmwit: That's pretty strange!   It'd be interesting if -fdefer-type-errors could be augmented to serialize the values involved in the type error, when possible.  The most primitive version of this would just be using "show", but something using cloudhaskell style serialization would be cooler
22:05:15 <mgsloan> Could do neat things like load up the values into ghci when a runtime type error occurs
22:06:09 <mgsloan> In some cases I think having these concrete values would be much more explanatory, and would give you a starting point to figuring out what the code should be
22:06:36 <dmwit> urr?
22:06:52 <mgsloan> webb?
22:06:53 <dmwit> Suppose I wrote "() ()". What would you want to be serialized?
22:07:02 <dmwit> (Sorry I'm not following.)
22:07:28 <mgsloan> Right, it might not be feasible for type errors in general
22:08:17 <mgsloan> I'd probably want both units serialized though, because they're both involved in the function application
22:08:50 <mgsloan> My understanding of -fdefer-type-errors is that it replaces the expression that the type error occurs at with a runtime exception
22:09:41 <dmwit> right
22:10:36 <mgsloan> So, it seems to me like the values of the sub-expressions involved in the type error could be serialized (given appropriate instances)
22:11:15 <mgsloan> Anyway, just a crazy scheme to easily associate concrete values with what otherwise might be obtuse type errors
22:11:20 <dmwit> Oh, I see what you mean.
22:11:42 <dmwit> I mean, that seems orthogonal to -fdefer-type-errors, though.
22:12:11 <mgsloan> Sure, though it seems to me that the -fdefer-type-errors machinery is a step towards a reasonable way to implement this
22:12:25 <dmwit> And you would also need to take care of things that evaluate to bottom and lazy infinite structures and all manner of tricky traps.
22:14:05 <mgsloan> dmwit: True true.  If this were really a ghci feature, though it'd probably be possible to just leave the values as thunks
22:14:23 <mgsloan> Hmm, maybe using the debugger + defer-type-errors already makes this possible
22:14:52 * hackagebot simple-sendfile 0.2.12 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.12 (KazuYamamoto)
22:20:40 <NemesisD> this underscores the need for complete example code, so i filed an issue on acid-state to write an example for their memory.pure variation
22:20:58 <elliott> a
22:21:00 <elliott> oops.
22:21:21 <NemesisD> culturally i've noticed that haskell libraries are pretty stingy with the examples
22:22:19 <augur> nullcone_: how can we help you with your haskell problems!
22:23:50 <mgsloan> NemesisD: I think it's also a bit of an infrastructure bug - neither cabal or haddocks really provide a nice way of including examples
22:24:52 <NemesisD> mgsloan: that's true. the format is pretty painful
22:25:34 <NemesisD> i like the pattern of an examples directory, though its not exactly very discoverable if you're browsing haddocks on the hackage site
22:34:52 * hackagebot fast-logger 0.3.2 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.3.2 (KazuYamamoto)
22:39:52 * hackagebot mighttpd2 2.8.6 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.6 (KazuYamamoto)
22:51:08 <pdxleif> What GHC version are we sposta get a parallel IO manager in?
22:52:57 <blackdog> pdxleif: dunno. it's in HEAD, right?
22:55:27 <pdxleif> Yeah, I heard it hit that back in February - that mean it'll be in 7.8?
22:55:40 <pdxleif> assuming all goes well
23:10:21 <zvrba> hello
23:10:48 <zvrba> in C++ I use std::set and its lower_bound method for partial key searches
23:11:25 <zvrba> (e.g., I have a set of pairs and I do set.lower_bound(pair(3,-1))  to find any item having its 1st component set to 3 (all components are positive))
23:11:59 <zvrba> I see that Data.Set has neither iterators nor "approximate" searches. what would be the alternative then?
23:13:39 <Cale> zvrba: What's the type of the operation you want?
23:14:07 <zvrba> Set s -> s -> s
23:14:16 <zvrba> or perhaps s -> Set s -> s
23:14:17 <Cale> errrrr
23:14:31 <dmitrymatveev> s is not an iterator here, though
23:14:34 <zvrba> no
23:14:40 <zvrba> but you can make it value-based
23:14:48 <zvrba> predecessor and successor of an element
23:14:55 <dmitrymatveev> it breaks the semantics you would like to expect
23:14:59 <Cale> zvrba: I'm not sure I understand what it is that you're trying to compute
23:15:01 <zvrba> it won't be as efficient, but I can live with it
23:15:21 <dmitrymatveev> or do you just want to find "next after"/"previous before" elements for a given one in the set?
23:15:27 <Cale> You have a Set of pairs, and you're trying to find the least element of the Set whose first component is 3?
23:15:28 <zvrba> dmitrymatveev: yes.
23:15:41 <zvrba> dmitrymatveev: also, when the element is not necessarily in the set.
23:15:45 <Cale> Or filter the Set for elements whose first component is 3?
23:16:02 <Cale> Or perhaps you don't want a Set at all, and would be happier with Data.Map?
23:16:15 <zvrba> Cale: given {3,5,10,11} [need not complicate with pairs]: map 3 to 3, map 4 to 5, map 10 to 11
23:16:18 <zvrba> rerm
23:16:19 <zvrba> map 3 to 5
23:16:22 <zvrba> map 4 to 5
23:16:28 <zvrba> map 17 to "None"
23:16:35 <zvrba> map 6 to 10
23:16:51 <zvrba> (read "map" there as query)
23:17:05 <Cale> Perhaps you're looking for splitMember
23:17:17 <Cale> Or just split
23:17:29 <Cale> split :: Ord a => a -> Set a -> (Set a, Set a)Source
23:17:30 <Cale> O(log n). The expression (split x set) is a pair (set1,set2) where set1 comprises the elements of set less than x and set2 comprises the elements of set greater than x.
23:17:34 <zvrba> I don't need two maps. I just want to search for the next element as defined by ordering.
23:17:38 <zvrba> it's a simple query.
23:18:03 <zvrba> yeah, I guess I could do it by combining split with findMin/findMax
23:18:10 <Cale> lookupGT :: Ord a => a -> Set a -> Maybe aSource
23:18:10 <Cale> O(log n). Find smallest element greater than the given one.
23:18:17 <zvrba> oh
23:18:27 <zvrba> I haven't found that one i online docs
23:18:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
23:18:49 <zvrba> ah, I've been looking at some version number, not latest
23:18:54 <Cale> ah, yeah
23:19:06 <Cale> Google tends to have a bad habit of preferring old ones
23:19:24 <zvrba> no, but I've looked at the documentation that came installed with GHC
23:19:30 <zvrba> it's the last in 2012
23:19:40 <zvrba> (haskell platform 2012.x)
23:20:07 <Cale> In any case, if you don't have lookupGT, you could just split and then findMin
23:20:13 <zvrba> oh, definitely upgraded package. my docs have only null,size,member,notMember under Query
23:20:16 <Cale> Which is O(log n) regardless
23:21:28 <zvrba> ok, problem solved :-)
23:23:56 <Cale> split is both lazy and doesn't reconstruct most of the tree (of course, if it did, it would be at least O(log n) time). I believe if you were to split and findMin, then lookupGT would only be very slightly faster.
23:25:17 <ogew> Hi, I am new and had read LYAH, but I still have trouble reading real world codes. What is next for me? Will learning formal proof help me?
23:25:29 <zvrba> well, as I understand it, split would have to reconstruct up to O (log n) nodes for each query. lookupGT doesn't need to reconstruct anything.
23:25:48 <zvrba> yes, it's a very query-intensive task.
23:26:17 <zvrba> I usually have n queries on a set of n elements.
23:26:42 <zvrba> I guess I can also do it with a map in this particular case.
23:26:55 <zvrba> Map from Int to [Int]
23:33:22 <kartoffelbrei> ogew: I don't think studiying formal logic and stuff will help you much. Knowing it is good if you attempt to do some crazy type hackery, but it's not that useful "everyday, real world" code.
23:34:20 <mstksg> ogew: try "Real World Haskell"
23:34:35 <mstksg> delving into formal logic might be counterproductive at this point
23:36:02 <ogew> Thanks kartoffelbrei, mstksg. I will try Real World Haskell
23:38:22 <mstksg> ogew: if you have trouble reading code, though, it might be more straightforward to just look up tutorials/posts about the libraries or tehcniques that the code is reading that you don't understand
23:40:43 <mstksg> is there a persistance/database abstraction in haskell that doesn't rely on TH?
23:43:47 <ogew> Seems like you are right. in particular, it is these image processing libraries. It could be my lacking of knowhow in "image processing" rather than haskell language, i will try searching for tutorials/posts specifically on those libraries.
23:44:14 <ogew> Thanks
23:53:27 <yesthisisuser> ogew: however, if you're interested in math theory have a look at http://www.amazon.com/Haskell-Programming-Second-Edition-Computing/dp/0954300696
23:59:24 <ogew> yesthisisuser: yep, I was about to read that. Shelved it but definitely coming back
