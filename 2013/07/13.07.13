00:02:50 <xacrus> hello does anyone have a rgb2cmky converter in haskell?
00:13:18 <xacrus> ?
00:14:47 <Gracenotes> I can't find anything, but I'm sure someone must have needed it at some point.
00:15:50 <Gracenotes> The formula itself is very simple
00:15:55 <Gracenotes> because they are duals of each other, in some sense
00:17:52 <Gracenotes> A pure Haskell package with conversions with RGB, HSV, HSL, CMYK, Lab, etc. would be nice
00:18:05 <Gracenotes> Efficient conversions
00:18:33 <Gracenotes> I can't seem to find one; rgb2cmyk is simple to do yourself, and there may be some wrappers that do it (e.g. imagemagick)
00:19:42 <xacrus> something like this?:http://pastebin.com/Nz11imES
00:19:49 <mauke> The paste Nz11imES has been copied to http://lpaste.net/90866
00:21:50 <Gracenotes> This page recommends similar-looking formulas, not sure if they're exactly the same as yours: http://www.rapidtables.com/convert/color/rgb-to-cmyk.htm
00:24:27 <shachaf> Oh, Yoneda is just Yoneda f a = (a ->) ~> f
00:28:59 <shachaf> The dual would seem to be Foo f a = (-> a) ~> f, where f is contravariant.
00:29:05 <shachaf> Where does CoYoneda come from?
00:29:48 <johnw> edwardk told me that coyoneda isn't dual to yoneda in that sense
00:29:54 <johnw> it's not the same "co"
00:30:06 <shachaf> Right.
00:30:08 <edwardk> coyoneda is a bad name
00:30:11 <shachaf> Which is why I asked where it comes from.
00:30:28 <johnw> edwardk: hello!
00:30:32 <shachaf> It seems "dual" in an adjunctiony sort of way if anything. But I don't really know.
00:30:54 <johnw> is it lan/ran dual?
00:31:34 <edwardk> there is a reason why the docs and type don't say 'Coyoneda' any more
00:31:38 <shachaf> I guess they are both Kan extensions.
00:31:42 <Gracenotes> I'll know I'll have made it if my last name is made into a portmanteu one day
00:31:53 <shachaf> edwardk: Yes, now it's just a name conflict.
00:32:28 <edwardk> Cogruen sounds like congruent
00:32:44 <shachaf> So what *is* the thing that used to be called CoYoneda?
00:32:57 <shachaf> Yoneda F A is a natural transformation (A ->) ~> F
00:33:02 <edwardk> both of them are versions of the yoneda lemma
00:33:43 <edwardk> https://en.wikipedia.org/wiki/Yoneda_lemma#General_version
00:33:53 <Gracenotes> Yes, I think I'll call people lastname-firstname with co prepended to both
00:34:54 <shachaf> Ghoul_: That thing is a pattern match.
00:36:02 <Ghoul_> shachaf: pattern matches in core don't need to be prefixed with case ... of ... ?
00:36:09 <shachaf> They do.
00:37:57 <Ghoul_> so, there's an implied lambda ?
00:38:01 <shachaf> No.
00:38:46 <shachaf> I suggest you read an introduction to Core syntax.
00:38:53 <shachaf> There are various of them, including in the GHC commentary.
00:39:02 <Ghoul_> ok, thanks.
00:41:20 <Cale> @tell xacrus you might find http://hackage.haskell.org/package/colour useful, though I don't think it has built-in support for a conversion to/from CMYK
00:41:20 <lambdabot> Consider it noted.
00:43:11 <shachaf> edwardk: So the general version talks about natural transformations.
00:43:35 <shachaf> I see how that corresponds to Yoneda but not exactly CoYoneda.
00:45:13 <Gracenotes> Cale: oh, that one actually does have Lab
00:45:31 <Cale> yeah
00:46:05 <Gracenotes> not much on conversion either though... still useful for most things; CMYK is usually at the end of a long pipeline of color ops anyway, is my impression
00:54:03 <shachaf> Hmm f g = exists x. (f x, g x) -- f contravariant, g covariant (or vice versa)
00:54:08 <shachaf> What's that?
00:54:13 <johnw> shachaf: I kind of lrooks like CoYoneda is the uncurried version of contravariant yoneda
00:54:39 <Lethalman> so I've managed to call haskell from c, it's very cool
00:54:40 <RichiH> http://paste.debian.net/15838/ -- there's a dependency problem when using cabal install; is there anything i can do about that except wait it out?
00:54:49 <RichiH> (and optionally report it somewhere)
00:54:55 <Lethalman> but I have a question: if I want to preserve some state between multiple calls to haskell, what should I do?
00:55:03 <shachaf> RichiH: Yes, you need to install happy.
00:55:03 <Lethalman> I believe I have a couple of options here
00:55:16 <shachaf> RichiH: It is a binary and the cabal dependency thing only handles libraries.
00:55:20 <johnw> Lethalman: you'll need to use an IORef and a StablePtr to pass it through the FFI barrier
00:55:22 <Lethalman> 1) return some state from haskell and preserve it in the application, and pass it everytime to haskell
00:55:41 <Lethalman> johnw, any docs about that?
00:55:41 <RichiH> shachaf: k, sec
00:55:51 <johnw> Lethalman: Foreign.Storable
00:56:01 <johnw> I assume you know about IORefs?
00:56:12 <RichiH> shachaf: how do i use happy to fix that then?
00:56:18 <Lethalman> johnw, somehow yes, they can store values across IO actions
00:56:24 <shachaf> RichiH: Did you install happy?
00:56:24 <RichiH> (it's installed via debian package)
00:56:24 <johnw> right
00:56:26 <RichiH> yes
00:56:45 <shachaf> RichiH: Find out why it's failing, I guess. Maybe it's not in your PATH. Maybe you need a newer version. I don't know.
00:56:50 <Lethalman> johnw, there's no example I can look at right? :P
00:56:58 <shachaf> I would use strace. :-)
00:57:07 <johnw> so, you create a StablePtr (IORef a), then cast it to a Ptr and pass the Ptr through to the "other side", where you can cast it back, dereference the stable ptr, and then read/write the IORef
00:57:12 <shachaf> johnw: Uncurried how?
00:57:44 <johnw> shachaf: contravariant yoneda is forall r. (r -> a) -> f r, right?
00:57:50 <Lethalman> johnw, let's say I don't want to pass it to C, I just want it in haskell
00:58:02 <shachaf> johnw: Yes.
00:58:07 <Lethalman> is that still necessary?
00:58:13 <Lethalman> or I can do something with global IORefs ?
00:58:16 <shachaf> For a contravariant f.
00:58:20 <RichiH> shachaf: can you point me to some docs or give keywords to google with?
00:58:36 <johnw> so, if we convert that exponential to a product type, we have "f r" and "r -> a", which starts to look like CoYoneda.  This is just a guess, though, I could be completely wrong
00:58:37 * RichiH is trying to follow http://git-annex.branchable.com/install/cabal/ as he needs a fix implemented after the last release
00:58:40 <shachaf> RichiH: Not sure. Are you quite sure it's installed?
00:59:01 <RichiH> and that's, quite literally, the first time i do anything with haskell other than run precompiled binaries
00:59:19 <johnw> Lethalman: can you describe your usage scenario a bit more?
00:59:22 <RichiH> shachaf: i installed cabal-install and happy from the debian unstable repos
00:59:30 <shachaf> johnw: How do you "convert that exponential to a product type"? There's no (->) left in the final thing.
00:59:42 <Lethalman> johnw, mh I'm simply calling some haskell functions from C... let's say I have some cache haskell side
00:59:43 <RichiH> then i went to the building from git checkout section and got stuck on the third command
00:59:50 <shachaf> RichiH: You could try cabal install happy, and putting ~/.cabal/bin in your PATH, and seeing if that fixes it.
00:59:55 <Lethalman> I'd like that to be preserved across C->haskell calls transparently
01:00:04 <shachaf> Or you could strace it. That is what I would do. If you're comfortable with that method of debugging.
01:00:17 <shachaf> E.g. strace -fo OUT cabal install foo
01:00:25 <shachaf> Oh, you're using --bindir, so you don't need to change your PATH, I guess...
01:00:27 <johnw> shachaf: ok, I'll stop guessing
01:00:37 <shachaf> johnw: I think it must be something along those lines.
01:00:40 <RichiH> shachaf: is there a benefit in installing happy from source as compared to installing packaged versions?
01:00:41 <shachaf> But I don't know what.
01:01:05 <johnw> Lethalman: do you mean C -> Haskell -> C, or just that you want to keep state on the Haskell side between calls from C?
01:01:10 <shachaf> RichiH: Perhaps the failure is because the version is too old. Though that doesn't really match the error message.
01:01:15 <Lethalman> johnw, the latter
01:01:25 <shachaf> RichiH: Did you try -v or whatever the option for verbosity is?
01:01:26 <johnw> Lethalman: ah, that's easy then, just use an IORef in your Haskell code
01:01:34 <Lethalman> johnw, exactly, a global IORef right?
01:01:36 <shachaf> RichiH: -v3, I think.
01:01:43 <shachaf> RichiH: Might tell you more.
01:01:45 <johnw> Lethalman: that's one way, sure
01:01:58 <Lethalman> johnw, what are the alternatives?
01:02:13 <johnw> Lethalman: the other is to hand back a Ptr to a StablePtr (IORef a) to C, and expect the C code to hand back that same pointer each time
01:02:21 <johnw> that would allow you to have a "create" method to get it all started
01:02:21 <RichiH> shachaf: fwiw, happy 1.18 seems to be current and debian installed 1.18.10-2
01:02:27 <edwardk> back
01:02:27 <Lethalman> ok, that's exactly what I was guessing
01:02:40 <shachaf> RichiH: OK, so it's probably not versions.
01:02:40 <edwardk> shachaf: look up the co-yoneda lemma in http://ncatlab.org/nlab/show/Kan+extension
01:02:43 <Lethalman> johnw, any third alternative? :-
01:02:44 <Lethalman> :-)
01:02:48 <edwardk> shachaf: that is the construction that that follows
01:02:59 <johnw> Lethalman: persist the state to a file, but that's just a global by another name
01:03:05 <Lethalman> alright
01:03:07 <Lethalman> thanks a lot
01:03:25 <edwardk> at least as i recall
01:03:28 <Lethalman> basically, I'm creating a gui with vala and gtk3
01:03:32 <RichiH> shachaf: adding ~/.cabal/bin to my path didn't work either, will try to run verbosse now
01:03:34 <RichiH> verbose, too
01:03:35 <shachaf> edwardk: Yes, it looks like the various left kan extension things. But I would need to figure out kan extensions properly to understand it. :-)
01:03:36 <Lethalman> now I have to decide whether calling haskell from C
01:03:45 <Lethalman> that is making haskell a service to the gui
01:03:49 <Lethalman> or the other way round
01:03:54 <edwardk> that construction is based on Lan Identity
01:03:58 <shachaf> Right.
01:04:05 <Lethalman> I'd like to do this experiment rather than writing the whole app in vala
01:04:14 <shachaf> edwardk: Is Hmm f g = exists x. (f x, g x) related to natural transformations somehow?
01:04:36 <Lethalman> so that I (try to) get the best of the two worlds
01:04:51 <edwardk> to dinatural transformations if the f and g are co and contravariant respectively
01:05:04 <RichiH> shachaf: http://paste.debian.net/15839/
01:05:05 <dcoutts_> RichiH: it'll find it if happy is on your $PATH (or if you explicitly specify --with-happy=)
01:05:22 <johnw> Lethalman: if you drive it from Haskell, then you have more options, because you can pass pointers to closures to C, so you won't need globals or pointers passed around anymore
01:05:28 <shachaf> RichiH: It's saying it found happy.
01:05:34 <johnw> (well, other than the FunPtr)
01:05:42 <shachaf> RichiH: This is not the error you had before. Now it's saying it can't find hmake.
01:05:55 <shachaf> RichiH: Er, not hmake.
01:05:56 <shachaf> alex
01:06:07 <Lethalman> johnw, yes, if I call C from haskell I may run into callbacks/mainloop problems
01:06:24 <shachaf> RichiH: I think you fixed your problem with the initial happy installation but then pasted the old error instead of the real one.
01:06:33 <Lethalman> if I call haskell from c, I'm basically using it as a library
01:06:42 <Lethalman> not sure yet what to do
01:07:09 <shachaf> edwardk: Aha.
01:07:25 <Lethalman> johnw, also, if I call C from haskell, I need some kind of representation of the gui
01:07:36 <Lethalman> or bindings to tkgtk3
01:08:06 <Lethalman> that is I can do window <- createWindowFromC
01:08:13 <Lethalman> but then what is window and how do I manipulate it
01:09:09 <johnw> Lethalman: you can write as much of the code in C as you like
01:09:15 <shachaf> edwardk: OK, so this is related to coends, too, I guess.
01:09:20 <johnw> Lethalman: draw the line wherever works best
01:09:31 <Lethalman> johnw, indeed, I believe I'll call haskell from C though
01:09:38 <Lethalman> also... my last concern
01:09:39 <edwardk> yeah. thats why i wrote 'kan extensions iii: as ends and coends' ;)
01:09:42 <Lethalman> what about forkIO
01:10:19 <shachaf> edwardk: Yes, let me just look that up on comonad.com.
01:10:21 <johnw> Lethalman: what about it?
01:10:34 <shachaf> edwardk: (I know about johnw's mirror. You should still get it back up!)
01:10:44 <Lethalman> johnw, is it possible to pass a C callback to haskell that will then be called later?
01:10:49 <edwardk> johnw has a mirror
01:10:56 <edwardk> =P
01:10:59 <edwardk> yes yes
01:11:02 <johnw> Lethalman: sure, it works both ways
01:11:08 <Lethalman> johnw, that is I'm a little concerned about the gui mainloop and the haskell rts
01:11:23 <RichiH> dcoutts, shachaf: i installed alex as well and now it's building
01:11:28 <Lethalman> johnw, awesome! :-)
01:11:37 <johnw> Lethalman: the Haskell Gtk library uses forkOS to pin resources to threads, but I don't know much about that
01:11:45 <RichiH> thanks
01:11:49 <Lethalman> ah I see
01:12:13 <Lethalman> well I don't care much about that, rather about what happens if I call a C callback from withing a forked IO in haskell
01:12:24 <Lethalman> but I've probably just starting playing with it
01:12:28 <Lethalman> thanks a lot for the insights :-)
01:13:10 <johnw> i'm not sure how heaps are dealt with in C when calling C functions from multiple Haskell threads, I'd like to read up on that
01:14:54 <Lethalman> johnw, I believe I can put it safe by deferring the C callback computation to the main gui thread
01:15:08 <johnw> ah, yes, that's one way
01:15:09 <Lethalman> that is my_callback() { run_in_main_thread(my_real_callback); }
01:15:23 <Lethalman> this is the most used trick in gui programming afterall
01:15:55 <Lethalman> and vala lets you do it very easily with lambdas
01:15:57 <johnw> that's what they call the actor model, right?
01:16:08 <johnw> you queue work to be run in a dedicated thread
01:16:44 <Lethalman> johnw, mh yes, not sure it's actor model... it's more like the javascript thing, multiple workers but one loop
01:17:16 <Lethalman> that is you let the other things done in thread workers, but then you write all the gui/interaction/real stuff in one thread
01:17:28 <Lethalman> and yes, they are queued
01:17:41 <johnw> ah, it looks like what you described is the "reactor" pattern
01:17:48 <Lethalman> johnw, exactly, the reactor pattern
01:18:05 <Lethalman> i let haskell to the work, then display it back in the main thread
01:18:18 <johnw> edwardk: added lens as a dependency in our IDE today :)
01:18:25 <edwardk> =)
01:18:26 <johnw> until now it was just a dependency in some of the sub-libraries
01:18:31 <Lethalman> wait what IDE :-)
01:18:42 <johnw> fpcomplete.com's beta IDE
01:18:46 <shachaf> lens 3.10 is coming out soon!
01:18:51 <Lethalman> ah ok
01:18:54 <johnw> i'm looking forward to it!
01:19:00 <shachaf> edwardk: I have the feeling no one else is going to volunteer to do the eta-shuffling thing.
01:19:05 <edwardk> Soon my plot to sabotage FP Complete will be complete. Make you depend on it everywhere then stop maintenance
01:19:07 <johnw> shachaf: edwardk wasn't able to get to the sexiness of profunctor lenses in his talk :(
01:19:19 <shachaf> If no one else does it I can go through the code and do it.
01:19:31 <edwardk> shachaf: seems likely to wind up as you
01:19:37 <shachaf> Any vague plans on when to release it?
01:19:44 <johnw> I nominate shachaf, anyone object?
01:19:55 <shachaf> I nominate cmccann.
01:20:06 <edwardk> i want to have the custom reflection in for 3.10 so it works with GHC head
01:20:24 <edwardk> so whenever that happens
01:21:23 <shachaf> That's related to the handwritten Typeable instance?
01:22:45 <edwardk> yeah
01:27:20 <astor> johnw: Is there a way to use persistent with FPComplete IDE?
01:28:13 <johnw> astor: sure, we use it ourselves
01:30:37 <zRecursive> why printf "%.20f\n" (pi :: Double) => 3.14159265358979300000 ?
01:30:54 <astor> Am I supposed to run the backend on my own server, or ir maybe the sqlite library available on the VM?
01:30:57 <johnw> Double only has so many bits
01:31:42 <zRecursive> less than 20 digits after point ?
01:31:57 <johnw> > sizeOf (undefined :: Double)
01:31:58 <lambdabot>   Not in scope: `sizeOf'
01:31:59 <lambdabot>  Perhaps you meant one of these:
01:31:59 <lambdabot>    `IM.size' (impor...
01:32:04 <capisce> base-10 decimal digits yes
01:32:26 <zRecursive> johnw: i see now, thx
01:32:50 <johnw> it's 64-bits, with I think 52 bits of significand
01:33:06 <johnw> (plus one implied bit)
01:34:45 * hackagebot git-gpush 2.0.0.0 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-2.0.0.0 (JohnWiegley)
01:34:47 * hackagebot git-monitor 2.0.0.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-2.0.0.0 (JohnWiegley)
01:34:49 * hackagebot gitlib-test 2.0.0.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-2.0.0.0 (JohnWiegley)
01:34:51 * hackagebot gitlib-cross 2.0.0.0 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-2.0.0.0 (JohnWiegley)
01:34:53 * hackagebot gitlib-cmdline 2.0.0.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-2.0.0.0 (JohnWiegley)
01:34:56 <zRecursive> in CL (format t "~,2f" 9.575) => 9.57, however in haskell printf "%.2f" 9.575 => 9.58   9.58 is what i need, how does haskell achieve it ?
01:36:01 <zRecursive> some lispers said 9.57 cannot be represented accurately
01:36:11 <zRecursive> 9.575
01:36:22 <johnw> there are many algorithms for rendering binary fractions to decimal floating-point
01:36:42 <johnw> i'm not sure what format is using
01:36:48 <johnw> I know MFPR can do a very good job
01:37:04 <zRecursive> what does MFPR mean ?
01:37:11 <johnw> it's a library that extends GMP
01:37:21 <johnw> just giving it as an example
01:38:04 <johnw> I once spent several weeks on a contract writing FP rendering algorithms
01:38:34 <johnw> 0.1 is rather hard to represent also
01:39:55 * hackagebot gitlib-sample 2.0.0.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-2.0.0.0 (JohnWiegley)
01:39:57 * hackagebot gitlib-s3 2.0.0.0 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-2.0.0.0 (JohnWiegley)
01:39:59 * hackagebot gitlib 2.0.0.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-2.0.0.0 (JohnWiegley)
01:40:01 * hackagebot gitlib-libgit2 2.0.0.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-2.0.0.0 (JohnWiegley)
01:40:10 <zRecursive> in our finantial function, i just encounter (+ 8.15 (* (- 11 8.15) 0.5)) => 9.575, i lose precision :(
01:40:33 <johnw> you can use Rational numbers
01:40:58 <johnw> and then a package like "numbers" for accurate rendering to decimal floating point strings
01:41:09 <johnw> fsvo accurate
01:41:39 <zRecursive> but it is old CL applications
01:41:46 <johnw> CL has rational
01:42:10 <zRecursive> johnw: i need to delve into it
01:42:34 <zRecursive> avoid using floating in those functions
01:44:28 <johnw> usually a good idea
01:45:05 <zRecursive> sure, awful floating number
01:45:23 <johnw> they're great for computing lots of things, but not money!
01:46:09 <zRecursive> yeah, it will cause money loss
01:48:52 * zRecursive googling common lisp rational
01:49:22 <johnw> it's a feature of the language, #lisp would be a good place to go further
02:05:02 <cads> hey RichiH, would you be interested in having a vcsh  landingpage / faq / wiki?
02:22:38 <hape01> is it a big deal to get ghc-mod activated in emacs? I added (autoload 'ghc-init "ghc" nil t)     and       (add-hook 'haskell-mode-hook (lambda () (ghc-init)))   to ~/.emacs  but I get no reaction in emacs... i cabal insalled ghc-mod  correctly. any hint?
02:23:26 <johnw> make sure ghc-mod.el is finding the ghc-mod executable
02:23:49 <hape01> johnw: I investigate on this, thanks
02:28:30 <aristid>  johnw what's the big change in gitlib-* 2.0? :)
02:28:44 <johnw> lots of simplifications, and changes in the API for consistency
02:28:53 <johnw> i dropped several types which I discovered were redundant
02:29:04 <johnw> so, 2.0 is pretty much the same functionality, but streamlined
02:29:36 <aristid> ah.
02:30:01 <johnw> it was the size of the refactoring that justified the move to 2.x, in my thinking
02:44:16 <hvr> johnw: is the libgit2 backend mem-leak free?
02:44:38 <johnw> i'm not sure how to answer that
02:44:40 <hape01> johnw: haskell mode itself was missing. ghc-mod runs better on top of that :-)
02:44:51 <johnw> i'd consider it a pretty major flaw if I knowingly released memory leaks
02:45:08 <hvr> johnw: actually I meant the libgit2 c-lib :)
02:45:22 <hvr> johnw: I was wondering if you'd recommend using the libgit backend for long-running processes
02:45:23 <johnw> ah, that I can't guarantee
02:45:29 <johnw> yes, I use it for long-running processes
02:45:35 <johnw> git-monitor, in particular
02:46:03 <johnw> and I've used it on some pretty huge data sets before, and didn't notice any problems from leaking
02:46:12 <hvr> johnw: one of those low-prio tasks I have on my TODO list, was trying to write a git daemon for trac's git plugin
02:46:21 <johnw> ah, cool
02:46:34 <johnw> a perfect application!
02:46:47 <hvr> johnw: to help cache the metada views on the git-repo that Trac needs, and which cause performance issues right now for larger repos
02:47:10 <johnw> right, libgit2 has vastly superior IOPS and memory footprint
02:47:37 <johnw> most especially when dealing with lots of small objects
02:47:49 <elliott> trac :(
02:47:52 <hvr> oh, and is there a "cheap" method to check whether the git repo has been modified?
02:48:01 <johnw> you mean, the working tree?
02:48:23 <hvr> johnw: nope, I mean just the .git/ folder contents
02:48:40 <johnw> nothing that I know of, besides checking timestamps
02:49:07 <hvr> elliott: ...you don't like Trac? :)
02:49:54 <elliott> I honestly didn't realise anyone did :P
02:50:13 <bitonic> probably better than bugzilla
02:50:32 <johnw> bugzilla is a huge pita to maintain, in my experience
02:54:05 <bitonic> yeah.  I could live with it when I had to
02:55:38 <hvr> elliott: well, I like it because it's rather lightweight and highly customizable (especially the ticket state-flow)
03:06:09 <notdan> If I have a 'TyCon', how can I check that it is IO?
03:06:50 <johnw> tyConName == "IO"?
03:09:01 <elliott> that would catch Control.NotIO.IO
03:09:11 <elliott> maybe best to fetch it out of (return () :: IO ()) and compare?
03:09:12 <johnw> that's true
03:09:21 <johnw> there's also tyConModule
03:09:41 <elliott> yeah, but I think that'll give you some GHC.* thing that wouldn't be portable (in an imaginary universe where we care)
03:10:07 <johnw> i agree, fetching out of a canonical example and comparing is the best bet
03:10:17 <notdan> johnw: tyConName returns Name, not string, I tried that :(
03:10:20 <notdan> elliott: oh, thanks
03:13:12 <notdan> Hm, I realized that this wouldn't help me much. What I am trying to do is to evaluate an expression and, if it's in the IO monad, extract it using unsafePerformIO
03:13:47 <notdan> But if I am to extract the TyCon and compare it and yada yada then the types won't match
03:14:17 <notdan> because in one case I have to use unsafePerformIO :: IO a -> a and in another case I alreadyu have something of type a
03:15:05 <elliott> I suggest not using unsafePerformIO...
03:15:09 <elliott> but this is what cast/gcast are for
03:15:10 <elliott> :t cast
03:15:11 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
03:15:11 <elliott> :t gcast
03:15:12 <lambdabot> (Typeable a, Typeable b) => c a -> Maybe (c b)
03:15:15 <elliott> well, not gcast
03:16:02 <elliott> I guess cast is kind of annoying because it could be (IO a) for some random a. hmm.
03:16:30 <notdan> cast is just safer unsafeCoerce, isn't it?
03:16:31 <elliott> you should be able to use gcast to do it with a GADT, anyway
03:16:33 <elliott> yes
03:16:35 <elliott> that's what you want!
03:16:38 <elliott> it'll only cast if the types match
03:16:50 <WzC> Question: I'm still fiddling with haskell FFI stuff. I have a small bit of C code that produces a .a file that ghc should link to when producing binaries. How do I tell cabal about that?
03:16:56 <notdan> Well, but I want to extract the value from the IO monad
03:17:01 <notdan> so the types won't match
03:17:09 <elliott> you'll get an IO () with a little trickery.
03:17:12 <elliott> and then you can just run that action.
03:17:35 <WzC> (i.e. I can compile my stuff using) `ghc --make src/Main.hs c_src/internal.a' but now I still need to convince cabal to include c_src/internal.a when linking
03:17:58 <elliott> oh
03:18:04 <elliott> right, getting the value out will be a little trickier.
03:18:06 <elliott> but it's ok, you can do it
03:18:12 <elliott> (I think)
03:18:46 <notdan> Well I am doing this right now: http://lpaste.net/459280201788948480
03:18:54 <notdan> which is not pretty
03:19:15 <elliott> unrelated, but: I suggest not doing let __cmCompileExpr = ...
03:19:25 <elliott> because funny things happen if you use __cmCompileExpr in the experssion :)
03:19:37 <elliott> @yhjulwwiefzojcbxybbruweejw
03:19:37 <lambdabot> Exception: <<loop>>
03:19:40 <elliott> @yhjulwwiefzojcbxybbruweejw
03:19:40 <lambdabot> Exception: <<loop>>
03:19:42 <elliott> lol.
03:19:43 <elliott> @yhjulwwiefzojcbxybbruweejw
03:19:43 <lambdabot> "\"#$%&'()*+,\""
03:19:51 <notdan> Oh, I guess I can just use liftIO instead of unsafePerformIO
03:20:02 <notdan> elliott: I took this code from InteractiveEval :D
03:20:22 <notdan> I don't know tbh why are they using __cmCompileExpr
03:20:24 <elliott> I hope this is running heavily sandboxed, by the way? :p
03:20:52 <notdan> elliott: this is running in a VM, under rlimits, cgroups in a chrooted filesystem with SELinux enabled
03:21:04 <elliott> okay, fair
03:21:13 <notdan> :P
03:21:26 <elliott> the chroot seems like a little overkill :P
03:22:54 <notdan> Well, you never know what's going to happen :) and it's easier to configure SELinux that way
03:25:40 <elliott> what kind of VM?
03:28:22 <notdan> vagrant-powered VirtualBox VM
03:28:42 <notdan> It's for my GSoC project, I'll be writing about the design and the security limitations in details soon
03:37:40 <numberten> is there a formal name for curly braced, I want to say compiler directives, included at the beginning of files?
03:38:03 <Cale> numberten: pragmas
03:38:16 <numberten> ah yes, thank you Cale
03:38:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
03:38:44 <numberten> thanks
03:46:52 <RichiH> cads: i have been pondering that in the past, yes
03:47:14 <RichiH> cads: either as a subpage of richardhartmann.de or vcsh.github.org
03:47:30 <RichiH> cads: why do you ask?
04:05:54 <prophile> @hoogle (Monad m, Comonad w) => m a -> (w a -> m b) -> w b
04:05:54 <lambdabot> Warning: Unknown class Comonad
04:05:54 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
04:05:54 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
04:06:03 <prophile> @hoogle (Monad m, CoMonad w) => m a -> (w a -> m b) -> w b
04:06:03 <lambdabot> Warning: Unknown class CoMonad
04:06:03 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
04:06:03 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
04:06:05 <prophile> :<
04:11:39 <FreeFull> prophile: Hmm, what would such a function be useful for?
04:12:05 <FreeFull> prophile: I can't see many cases where w and m wouldn't be the same
04:14:52 <sanbonpe> Hey, I may be doing something unhaskelly here (let me know!), but what do I do in the case that I want to construct a data type from a list of tuples (basically a crappy map structure ...)? The paste above should give more information. I could do a find (or filter) operation for each parameter and have a long call to the RequestParams constructor, is there a way to make it a bit nicer?
04:15:04 <sanbonpe> http://lpaste.net/90868
04:15:35 <elliott> sanbonpe: are you parsing JSON or something?
04:15:43 <sanbonpe> get parameters
04:15:59 <sanbonpe> using yesod, if that makes a difference
04:16:12 <sanbonpe> get parameters from an ajax call
04:16:17 <elliott> ah, hm
04:16:25 <elliott> can you get it as a Map?
04:16:32 <elliott> you can call RequestParams as a record constructor
04:16:38 <elliott> like RequestParams { foo = ..., bar = ... }
04:16:50 <elliott> that + Map lookups would be pretty good, though the error handling will make things uglier
04:17:01 <elliott> I'd be surprised if Yesod didn't have something nice for doing this
04:53:36 <oksen> say I have a type (Word8, Word8, Word8), and I want to apply fromIntegral to each item in the tuple, is there a way to achieve this without repeating myself for each item?
04:54:22 <Cale> oksen: At least to some extent, the answer is no, and that's one of the reasons why triples and larger tuples are awkward to work with.
04:54:41 <Cale> You could of course write  mapTriple f (x,y,z) = (f x, f y, f z)
04:54:51 <Cale> and then use mapTriple fromIntegral
04:56:42 <oksen> yeah, that's pretty terrible. tuples are not an instance of Functor like list is right?
04:57:05 <oksen> no nevermind that last question :p
04:58:06 <oksen> tuples are odd
04:58:55 <oksen> why are they in haskell?
04:59:03 <CaptainK> tuples are even
05:00:06 <CaptainK> part of category theory
05:02:45 <Cale> oksen: Well, there are cases where they are handy things to have around.
05:03:01 <supki> @ty over Control.Lens.each :: (a -> b) -> (a, a, a) -> (b, b, b)
05:03:02 <lambdabot> (a -> b) -> (a, a, a) -> (b, b, b)
05:03:03 <Cale> oksen: But for the most part, once you get much larger than a pair, you're better off defining your own datatypes
05:05:16 <oksen> I use them for rgb
05:05:23 <oksen> Perhaps better make a datatype
05:06:39 <CaptainK> http://en.wikipedia.org/wiki/Tuple
05:06:55 <CaptainK> explains the difference of using tuples compared to lists
05:09:14 <merijn> Are there any tools for scanning which (uncaught) IO exceptions a piece of code may throw?
05:09:29 <merijn> i.e. how do I know which errors I should be trying to handle/mitigate
05:11:14 <oksen> thanks CaptainK, Cale, supki
05:12:20 <CaptainK> oksen: learning it myself ;)
05:14:05 <pshr> !info
05:16:25 <Cale> oksen: You might also like the colour package on hackage.
05:16:59 <Yaniel> what matrix library should I use with OpenGL 3+ ?
05:18:24 <pshr> !learn
05:18:39 <elliott> pshr: hi, can we help?
05:18:44 <pshr> Hello every one are there any learning resources to start with ?
05:18:53 <pshr> hi elliott
05:18:55 <elliott> @where lyah
05:18:55 <lambdabot> http://www.learnyouahaskell.com/
05:19:01 <elliott> is a good introductory book
05:19:22 <pshr> thank you
05:19:24 <CaptainK> search for learning haskell fast and hard
05:19:30 <Cale> pshr: and don't be afraid to ask any specific questions you might have
05:20:07 <pshr> ok Cale :)
05:21:57 <pshr> CaptainK, http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ is this it ?
05:22:28 <CaptainK> yep, that great to just get into it, lyah has nice pictures :P
05:22:54 <CaptainK> but smoke a joint and stare at yann's pictures
05:23:03 <Cale> heh
05:23:39 <Cale> Every time this question comes up I feel guilty for not having written a book yet.
05:23:44 <merijn> After skimming I don't really like that the Hardy Way trick
05:24:11 <merijn> Referring to IO as "hell difficulty" and using that stupid "RealWorld" analogy are red flags :(
05:24:34 <Cale> Oh, yeah, I really dislike the RealWorld analogy
05:24:40 <CaptainK> it amazes me there is no book that really helps a newbie with just the layout and work environment descriptions
05:25:07 <Cale> CaptainK: What do you mean by that?
05:25:10 <merijn> CaptainK: I thought the wikibook explanation onf layout was really sufficient to understand it
05:25:19 <elliott> I think that last linked tutorial is awful, if it's anything like what I remember it being when it first made the rounds.
05:25:23 <elliott> ymmv.
05:25:38 <CaptainK> reserved words, usage of "do" and let", how to start a program with "main = do" , they are explained just not very well imho
05:26:09 <merijn> CaptainK: You don't really have to start with "main = do", though
05:26:23 <merijn> Haskell layout: https://en.wikibooks.org/wiki/Haskell/Indentation
05:26:23 <CaptainK> exactly, and that is not very well described
05:26:37 <merijn> Read once, grok the gory details and you know all you need about layout
05:27:00 <merijn> hell, it's literally the first Google hit for "haskell indentation"
05:27:32 <Cale> If you're interested in purchasing a book, then Graham Hutton's Programming in Haskell is quite good as an introductory textbook, but it doesn't go terribly far.
05:27:41 <CaptainK> merijn: not seen that link before, looks good
05:28:10 <Cale> (but what it covers, it does quite a good job of)
05:28:20 <CaptainK> ya and you will find haskell number biased, again only imho
05:28:21 <klrr_> Cale: did you work on ipwnstudios?
05:28:28 <Cale> klrr_: Yes
05:28:36 <klrr_> Cale: is the startup dead?
05:29:30 <Cale> klrr_: It's not active. I'm not sure it's completely dead.
05:29:42 <klrr_> Cale: oh nice :D
05:30:01 <klrr_> Cale: that it's not dead
05:30:03 <CaptainK> I found this really helpful as a newbie, great to print out and keep next to the keyboard
05:30:04 <CaptainK> http://cheatsheet.codeslower.com/
05:30:36 <merijn> CaptainK: Hell, I still use that for when I forget pattern guard syntax again :p
05:31:51 <CaptainK> haha, there are a few ways to skin the cat in haskell, "if then else" and guards are that "sugar" we all talk about
05:31:59 <Cale> klrr_: We have the better part of a game engine done, and a fair amount of art resources and lots of music for the game. It's just there's a fair amount left to do to actually put together a playable action RPG. What we have might be okay for some kind of little arena combat thing, and that might be our first goal to produce something we could sell if we started working on things again.
05:32:59 <klrr_> Cale: okey, is it using sodium library for FRP, saw that it was written by one of the programmers at ipwnstudios?
05:34:02 <Cale> No, it's using another library which we put together for arrowised FRP.
05:34:37 <klrr_> Cale: okey
05:34:42 <Cale> But our system pretty much requires a preprocessor for translating the proc/do notation in terms of our replacement for the Arrow class.
05:35:11 <merijn> Cale: If you ever feel motivated to write it up, I'd love to read up on the high level design of it
05:35:46 <Cale> merijn: Yeah, at some point Ryan and Stephen and I really need to get together and put together a paper or two.
05:36:18 <danharaj> Cale: Ryan told me a bit about your system. I'm impressed you got that kind of performance on mobile devices.
05:36:38 <Cale> Mobile devices are pretty impressive these days :)
05:38:28 <merijn> Now we're completely off-topic, is there a right way to mention (unpublished) papers on your CV? Or should I just dump them on arXiv and pretend that counts as published? :p
05:38:40 <Cale> haha
05:38:55 <Cale> Well, arXiv is definitely better than nothing?
05:39:29 <danharaj> You can call it a pre-print and put it on your website :P
05:42:42 <merijn> danharaj: I guess that means I finally should get around to making one of those >.>
05:42:45 <Cale> merijn: I forget how much I said before about the really high level design of it, but basically what we did to make the Arrow class actually useful pretty much ended up being an encoding of the data for a symmetric monoidal category.
05:43:31 <merijn> danharaj: Well, I still plan to revise and resubmit it at some point, to a conference that will accept my brilliance...
05:43:32 <danharaj> Cale: Did you make it traced or use some other mechanism for feedback?
05:44:58 <Cale> i.e. with explicit associators like assocl :: (Arrow (~>)) => (a,(b,c)) ~> ((a,b),c) and left/right unit isomorphisms in both directions, and explicit swap :: (Arrow (~>)) => (a,b) ~> (b,a) -- actually our real library generalised over pairs as well, but I'm not sure we really took advantage of that.
05:45:50 <Cale> But the idea is that once you have that stuff explicit, then you can make the proc/do notation only use arr when it's *really* required, rather than shoving it in between every single line of code.
05:47:14 <Cale> and then since your arrows aren't all wired up with black boxes in between every adjacent pair, you can do a meaningful amount of analysis to simplify things
05:49:16 <Cale> The whole point of Arrow relative to Monad as I see it is that the Monad interface limits the amount of analysis you can do to a computation before you really start to execute it. Every time you hit x >>= f, the f is a black box that you can't see inside to determine that the result of computing x is perhaps pointless, or possible to simplify.
05:49:45 <Cale> While with f >>> g the f and g are both of some datatype that you have some amount of control over.
05:50:01 <merijn> Speaking of arrows
05:50:32 <Cale> So, you can perhaps perform some simplification. But arr kind of spoils that picture, because if what you have is f >>> arr h >>> g, then h can do pretty much anything at all and you can't inspect it because it's a function.
05:50:34 <merijn> Has sanyone looked into the notion of indexed arrows (i.e. similar to indexed monads)?
05:51:11 <Cale> merijn: That's certainly a reasonable idea.
05:51:48 <danharaj> merijn: if you think of arrows as monads in a profunctor category then you can think of indexed arrows as a profunctor monad in a category other than * fairly easily.
05:51:52 <merijn> Although, I have to admit I only glanced over the Kleisli Arrows of Outrageous Fortune paper, as usual McBride requires slightly more discipline to read than I had at that time :)
05:52:06 <danharaj> I love that paper!
05:52:19 <merijn> danharaj: You lost me about 9 words into that sentence
05:53:05 <Cale> But yeah, the thing which kills the existing Arrow class is the fact that if you want to use proc/do notation for arrows, that thing is going to stick arr in between pretty much every line of the do-block in order to wire results along from one computation to the following ones, and it has to because there's no other way to manipulate the bunches of results of past computations and get them to where they need to go.
05:54:00 <danharaj> Cale: So as I understand it you did a deep embedding of most of the arrow machinery but GHC's proc notation doesn't do the best translation into your model.
05:54:09 <Cale> right
05:55:15 <Cale> Well, we added to the arrow machinery so that everything could be explicit. Pretty much our only uses of arr were when there's any sort of complex expression to the right of -< or when there's a pattern match to the left of <-
05:55:28 <Cale> (which are pretty much unavoidable cases)
05:55:50 <Cale> (i.e. on a type which isn't composed of pairs)
05:56:23 <danharaj> Could the network modify itself during execution?
05:56:58 <Cale> There were specific primitives for that
05:57:18 <danharaj> ah, like yampa's routing combinators I suppose?
05:58:40 <merijn> Is this a weird word? "non-cache-coherent"
05:58:50 <danharaj> why not cache incoherent?
05:59:25 <merijn> danharaj: Because "not forall X" is not the same as "forall (not X)"
05:59:44 <danharaj> is cache a quantifier?
05:59:57 <merijn> danharaj: I'm not sure whether using "cache-incoherent" to refer to hardware without cache-coherency is correct
06:00:04 <danharaj> oh
06:00:33 <danharaj> fair enough
06:01:11 <Cale> danharaj: Basically, our primitive for that was that given some monoid c, there's a primitive arrow which takes as inputs (a behaviour) b, and an Event [b ~> (c, Event ())], and produces a resulting behaviour of type c
06:01:29 <Peaker> what do you guys think of http://i.imgur.com/gH8Ok6Y.png ?
06:02:01 <Peaker> (no real pattern matching support yet so using a case func)
06:02:04 <danharaj> what am I loooking at here
06:02:09 <Cale> The idea being that we can spawn bunches of arrows on each occurrence of this event, they all receive the same input b, and produce results of type c which are then combined using the monoid operation.
06:02:14 <Peaker> definition of "find"
06:02:28 <Peaker> in lamdu
06:02:55 <merijn> Peaker: I'm finding it a bit visually noisy
06:03:28 <aristid> Peaker: i find the huge variety of font sizes a bit jarring
06:03:30 <Peaker> we'll get rid of the record notations in there which will instead look like flat vertical arg lists
06:03:55 <Peaker> we threw away brackets in favor of boxes
06:04:03 <merijn> Peaker: I think it'd be desirable to more clearly show the types below find are it's arguments
06:04:11 <danharaj> I think it looks kind of cool.
06:04:29 <aristid> Peaker: the thing i really like about the subtext 2 demo was how it was an entirely regular table (for the case expression)
06:04:54 <merijn> Peaker: I'm also not particularly fond of the braces to show multiple values/types, but maybe that's just lack of being used to it
06:05:07 <Cale> Why is there no green arrow after empty?
06:05:10 <aristid> Peaker: so perhaps something you could try to do is making things "line up"
06:05:17 <Peaker> aristid, I don't think we'll go so far as subtext... we want to be at least roughly similar to e.g Haskell
06:05:36 <Peaker> merijn, it's record syntax
06:05:56 <Peaker> we'll flatten record syntax when it's in "the parameter"s position
06:05:56 <aristid> Peaker: consider for example those p : a -> Bol and xs : List a expressions
06:05:58 <merijn> Peaker: Oh, because you didn't really have currying yet, right?
06:06:07 <aristid> Peaker: is there a reason why the : couldn't line up there?
06:06:12 <Peaker> we threw away currying for records
06:06:15 <Cale> Nothing looks like a parameter to empty there rather than the result of that branch of the case expression
06:06:28 <Cale> Also, why listcase instead of a general case construct?
06:06:36 <Peaker> it's a parameter called "empty"
06:06:46 <Peaker> Cale, we don't yet support case (we will)
06:06:53 <merijn> Cale: I'm guessing the green arrow is a lambda
06:06:54 <aristid> Peaker: also, _why_ don't you want to go as far as subtext for the case expression? :)
06:06:59 <Cale> oh
06:07:08 <merijn> Where the x record is it's argument
06:07:13 <Cale> I see
06:07:26 <merijn> But I could be wrong :p
06:07:30 <Cale> empty and cons are named parameters to listcase xs
06:07:39 <Peaker> aristid, it may or may not work, and we're already taking much "innovation risk" here
06:07:59 <Peaker> Cale, yeah, same as then/else
06:08:27 <Peaker> aristid, you're right about : alignments
06:08:30 <Peaker> (thanks :) )
06:08:34 <Cale> I was expecting that they were patterns, and the part immediately following would be arguments (which was an assumption which works for the x in the cons case)
06:08:51 <Cale> (i.e. constructor patterns)
06:08:55 <merijn> Peaker: Was I right in thinking that the green arrow is a lambda?
06:09:08 <Cale> merijn: I think so
06:09:31 <Cale> I despise x.foo as record selector syntax, but that's a personal thing ;)
06:09:35 <Peaker> merijn, yeah, and red arrow is pi.  similarly to: green { is record val, red { is record type
06:09:50 <Peaker> Cale, well, it isn't really Haskell, function composition will probably look different to .
06:10:34 <merijn> Peaker: I would prefer some way to more clearly distinguish the scope of a lambda
06:10:45 <Cale> Even so, I think it's out of place in a language where functions go before their arguments :)
06:10:52 <merijn> i.e. a separate background for the lambda too? Thought that might be to noisy
06:11:15 <Peaker> merijn, the lambda is boxed if there's ambiguity
06:12:35 <Peaker> aristid, if we use same font size everywhere, how do we de-emphasize things like the param names which you don't type in and do not edit?
06:12:49 <aristid> Peaker: i don't say same
06:12:54 <Peaker> (or things like the "OO" presentation mode)
06:13:06 <aristid> Peaker: just not so many!
06:13:06 <astor> if I have data X = A | B | C deriving (??), what is an easy way to get foo :: X -> String so that foo A = "A", foo B = "B" etc.
06:13:20 <Peaker> astor, deriving (Show)
06:13:26 <Cale> :t show
06:13:27 <lambdabot> Show a => a -> String
06:13:58 <Peaker> Cale, most of the ML-style languages do the same "." thing, right?
06:14:58 <astor> doh, that was too easy :-)
06:16:01 <merijn> astor: Brilliant, no? :p
06:16:16 <Cale> Peaker: with various delimiters
06:16:49 <Cale> Peaker: I believe OCaml uses #
06:17:08 <merijn> I don't think taking syntax hints from OCaml is a good move :p
06:17:11 <Cale> However, I think it's backwards
06:17:37 <Cale> It's nicer to at least approximate function application, even if you're not going to identify the operation with function application.
06:26:32 <Philonous> I wonder whether separating all the types of a package into a Types module is an anti-pattern. It seems I invariably end up either with lots of orphan instances or lots of utility code in the Types module which defeats it's purpose.
06:27:10 <Cale> Philonous: It's an annoying necessity a lot of the time
06:27:52 <Cale> Because GHC doesn't properly support mutually recursive modules
06:28:12 <Philonous> That would indeed solve the problem
06:28:21 <Cale> So, you end up pulling out some things in order to not have modules depend on one another, and usually those things happen to be types
06:31:07 <Philonous> So, is it preferable to clutter up the Types modules ore to have orphan instances?
06:31:25 <Philonous> I guess the orphan instances aren't a problem when I don't expose the module separately.
06:32:44 <circle> I'm parsing a tree, and I want to add a node to the tree if it passes a test, but not add it if it doesn't. won't this cause an "insufficient pattern matching" error?
06:32:45 <aristid> Philonous: you could just make one big module with everything:)
06:32:50 <circle> since I'll only match for the successful case
06:33:50 <OrangeDu1k> Hey, does anyone know how I can access the "Stream" element of a parsec GenParser
06:34:23 <Philonous> circle:  You should match both cases and if the test doesn't pass just return the original tree
06:34:41 <circle> Philonous: Good idea.
06:34:49 <circle> Philonous: Thanks.
06:35:04 <aristid> Philonous: i applaud your problem guessing skills :)
06:35:09 <circle> wait, there's a problem there
06:35:30 <circle> this is a recursive function. returning the original tree will yield an infinite loop
06:35:52 <merijn> Philonous: If you create a hs_boot file you can have recursive dependencies in ghc
06:36:46 <merijn> Philonous: But yes I know that annoying feeling of having nicely separated code and then having to mash it all together >.>
06:37:35 <merijn> circle: Maybe lpaste your code so we can see what you mean?
06:37:37 <Philonous> circle:  Can you paste some code?
06:37:45 <Philonous> @where hpaste
06:37:45 <lambdabot> http://lpaste.net/new/haskell
06:37:56 <circle> I'm trying to develop the code atm, but I'll ahve some in a bit
06:39:21 <aristid> merijn: i wonder if module boundaries also impede ghc optimizations
06:40:38 <circle> trying to do alpha-beta pruning
06:46:10 <circle> easy to implement in say python...
06:48:42 <Philippa_> circle: would shoving a Maybe around your node type work?
06:49:25 <Philippa_> Maybe there's more, Maybe we decided to prune it?
06:49:51 * hackagebot helm 0.3.0 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.3.0 (ZackCorr)
06:49:52 <aristid> circle: perhaps you should explain your function a bit more, and show the code you already have, even if it does not compile.
06:49:55 <Philippa_> OrangeDu1k: there's a get/set pair of operations in the Parsec primitives module
06:49:55 <merijn> pffft, all the haskell/FP people in Scotland, and not a single haskell/FP group meeting up in Edinburgh :<
06:50:10 <Philippa_> can't remember their names, you okay looking them up yourself?
06:50:56 <Philippa_> merijn: pick a list and propose one, and make sure the Glasgow folks hear too?
06:50:56 <Philippa_> also, on the academic side there's things like SPLS
06:53:14 <merijn> hmm, I hadn't even heard of SPLS
06:58:00 <zvrba> are there any guidelines for when to use local function definition (where) vs. module-level definition?
07:03:53 <drostie> zvrba: I usually use local definition for (a) "workhorse" functions and (b) incomplete snippets.
07:05:15 <drostie> zvrba: like, I don't know, I might do `notNothing x = unMaybe (Just x) = x` is a function which takes you out of the Maybe monad if you're really truly sure that whatever's going on is not actually in the Maybe
07:05:19 <drostie> er.
07:05:29 <drostie> that submitted before I was ready for it.
07:06:26 <drostie> notNothing Nothing = False; notNothing _ = True; unMaybe (Just x) = x; and then I might map unMaybe . takeWhile notNothing.
07:06:31 <FreeFull> :t fromJust
07:06:32 <lambdabot> Maybe a -> a
07:06:41 <klrr__> HAI HASKELLERS!
07:06:59 <FreeFull> :t isJust
07:06:59 <lambdabot> Maybe a -> Bool
07:07:42 <drostie> FreeFull: fair enough. ^_^
07:08:01 <zvrba> mm. ok.
07:08:14 <drostie> zvrba: anyway if I've got that sort of weird partial code I'd probably put it in a where clause.
07:09:02 <drostie> And the other stuff is when I need to say something like "fn x is really fn' x 0 []".
07:09:26 <drostie> then fn' is a "workhorse" function which really does what fn is supposed to do.
07:09:34 <zvrba> right.
07:11:25 <merijn> zvrba: I try to minimise the scope of functions, so I put most things that are only used once in where clauses
07:11:53 <FreeFull> drostie: Usually the workhouse function is called go in that case I think
07:12:05 <merijn> The smaller the scope of things, the less time you need to worry about "where else is this used?"
07:12:34 <merijn> drostie: Also, catMaybes :p
07:12:37 <merijn> :t catMaybes
07:12:38 <lambdabot> [Maybe a] -> [a]
07:13:10 <drostie> I know I know, this code is in Data.Maybe, I was trying to come up with an ad-hoc example of an incomplete function, sheesh. ^_^
07:13:14 <merijn> fromJust is awful, btw, fromMaybe and Maybe are better
07:13:46 <aristid> :t fromMaybe
07:13:46 <lambdabot> a -> Maybe a -> a
07:13:58 <merijn> eh, I meant maybe for the second
07:13:59 <merijn> :t maybe
07:14:00 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:14:24 <FreeFull> @src reverse
07:14:24 <lambdabot> reverse = foldl (flip (:)) []
07:14:34 <FreeFull> merijn: catMaybes is different
07:14:40 <merijn> Yeah, I saw
07:14:57 <FreeFull> http://new-hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#reverse
07:15:09 <FreeFull> This has the "workhorse" as rev
07:19:32 <Twey> zvrba: I use where when the definition only makes sense in the context of its containing function.  If it's a function that *could* be shared, I try to make it so.
07:19:38 <Twey> (even if not exported)
07:19:52 * hackagebot aivika 0.5.4 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.5.4 (DavidSorokin)
07:19:59 <merijn> That proud moment where you produce a 201 character long type signature :>
07:20:19 <kryft> merijn: Congratulations! I'm so happy for you!
07:20:36 <kryft> merijn: Is it traditional to smoke a cigar?
07:20:50 <merijn> Only once it works >.>
07:21:00 <zvrba> read "X" :: Char -> returns no parse exception. Why?
07:21:11 <zvrba> (in ghci)
07:21:31 <merijn> Why would it?
07:21:39 <merijn> > read "X" :: Char
07:21:40 <lambdabot>   *Exception: Prelude.read: no parse
07:21:46 <merijn> oh, duh
07:21:47 <geekosaur> I get one here..
07:21:57 <FreeFull> > read "'X'" :: Char
07:21:58 <lambdabot>   'X'
07:21:59 <merijn> geekosaur: I think we misparsed the question
07:22:09 <merijn> "returns (no parse exception)"
07:22:11 <merijn> not
07:22:22 <merijn> "returns no (parse exception)"
07:22:30 <zvrba> right. i meant the first one.
07:22:32 <merijn> zvrba: Because of this
07:22:35 <FreeFull> zvrba: I think you want something like head
07:22:37 <merijn> > show 'X'
07:22:38 <lambdabot>   "'X'"
07:22:51 <FreeFull> > head "X"
07:22:52 <lambdabot>   'X'
07:22:54 <zvrba> so read will only parse valid Haskell syntax?
07:23:05 <merijn> zvrba: It will parse whatever it was coded to parse
07:23:21 <geekosaur> a simulation thereof; see the definition of the Read and Show typeclasses in the Report
07:23:23 <merijn> zvrba: In most cases this is whatever most closely matches haskell syntax
07:23:24 <zvrba> well, yes, but Char requires '' delimiters?
07:23:35 <merijn> zvrba: Yes
07:23:36 <zvrba> (rhetorical question)
07:23:46 <zvrba> ok
07:23:55 <merijn> zvrba: What were you trying to parse it for?
07:24:52 * hackagebot aivika-experiment 0.2.2 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.2.2 (DavidSorokin)
07:25:10 <zvrba> merijn: for example "X 13 45"
07:25:34 <zvrba> (1 character followed by 2 numbers)
07:25:48 <merijn> zvrba: You probably want a proper parser library like parsec for that
07:25:59 <merijn> > read "X 13 45" :: Char
07:26:00 <lambdabot>   *Exception: Prelude.read: no parse
07:26:04 <merijn> > read "'X' 13 45" :: Char
07:26:05 <lambdabot>   *Exception: Prelude.read: no parse
07:26:13 <zvrba> merijn: not ready for that yet. just learning haskell now.
07:26:34 <geekosaur> yeh, read is not a general parser framework, it's designed to parse Haskell literals of some variety. (`X 13 45` would be parseable iff you have some `data X = X Int Int deriving (Read)` or similar)
07:26:43 <merijn> zvrba: Oh, better yet! Implement your own parsing library as learning exercise :>
07:26:57 <zvrba> blah :-P
07:27:05 <zvrba> but I did this though: http://pastie.org/8137544
07:27:09 <geekosaur> also you'd want to use reads probably, but by that point you really will be happier with a proper parsing library :)
07:27:11 <merijn> zvrba: I'm reasonably serious, it's not very hard
07:27:16 <zvrba> parses stuff like "3 4.12 3.75 -9.87"
07:27:30 <zvrba> (in general, an Int n followed by n floats)
07:27:50 <kryft> Yes, it's not that difficult, and actually you'll see that Parsec isn't that hard either
07:27:53 <merijn> zvrba: Implementing a parser combinator library is a good exercise in implementing your own monad too :)
07:28:24 <zvrba> today is the day where I got my first monadic code to work: vectors <- DV.replicateM nVectors (do { l <- getLine; return (parseLengthAndItems l :: [Float]); })
07:28:35 <zvrba> (and the first haskell 'program' for that matter :-P)
07:28:43 <zvrba> DV is Data.Vector
07:29:04 <merijn> zvrba: you can simplify that to "fmap parseLengthAndItems getLine" :p
07:29:17 <zvrba> ah!
07:29:18 <merijn> (the do block, that is)
07:29:21 <zvrba> I knew I was missing something :=)
07:29:29 <zvrba> I tried to use liftM
07:29:30 <merijn> zvrba: There is also <$> which is infix fmap
07:29:42 <merijn> zvrba: liftM should work too, it should be the same as fmap
07:29:46 <zvrba> but liftM returns a function whereas replicateM wanted a value there.
07:29:52 * hackagebot aivika-experiment-chart 0.2.2 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.2.2 (DavidSorokin)
07:30:11 <merijn> :t fmap id
07:30:12 <lambdabot> Functor f => f b -> f b
07:30:16 <merijn> :t liftM id
07:30:16 <lambdabot> Monad m => m r -> m r
07:30:31 <merijn> :t fmap id getLine
07:30:32 <lambdabot> IO String
07:30:38 <merijn> :t liftM id getLine
07:30:39 <lambdabot> IO String
07:31:15 <kryft> If I want to do numerics in Haskell - basically various matrix operations - should I use hmatrix? Am I likely to run into trouble as an inexperienced haskeller? Performance isn't terribly important for now (in case getting good performance requires cleverness that I am unlikely to possess)
07:31:17 <merijn> zvrba: Currying means there is no difference between "returns a function" and "just needs more arguments"
07:31:32 <merijn> kryft: I found it relatively easy to use (hmatrix)
07:32:13 <zvrba> merijn: right. but it takes time to internalize that simple fact.
07:32:29 <merijn> :t Data.Vector.replicateM
07:32:30 <lambdabot> Monad m => Int -> m a -> m (Data.Vector.Vector a)
07:32:31 <kryft> merijn: What did you use it for?
07:32:39 <zvrba> fmap worked there, but I can't make it shorter since I have to specify the return type of parseLengthAndItems ([Float])
07:32:44 <merijn> :t Data.Vector.replicateM 1 (fmap id getLine)
07:32:45 <lambdabot> IO (Data.Vector.Vector String)
07:33:00 <merijn> :t Data.Vector.replicateM 1 (id <$> getLine)
07:33:01 <lambdabot> IO (Data.Vector.Vector String)
07:33:13 <merijn> zvrba: Sure you can
07:33:27 <zvrba> how?
07:33:38 <merijn> :t Data.Vector.replicateM 1 (read <$> getLine) :: IO (Data.Vector.Vector [Float])
07:33:39 <lambdabot> IO (Data.Vector.Vector [Float])
07:33:58 <merijn> zvrba: If you specify the outer type GHC will propagate the type constraint inwards :)
07:34:00 <mauke> what are the types of DV.replicateM and parseLengthAndItems?
07:34:10 <merijn> :t Data.Vector.replicateM
07:34:11 <lambdabot> Monad m => Int -> m a -> m (Data.Vector.Vector a)
07:34:19 <zvrba> arseLengthAndItems :: Read a => String -> [a]
07:34:25 <merijn> zvrba: Actually, if you use the vector somewhere, type inference might figure it out for you
07:34:26 <zvrba> merijn: oh, right! :)
07:34:39 <mauke> "arse"
07:34:39 <zvrba> I do use it afterwards
07:34:52 <zvrba> "parse"
07:34:55 <zvrba> c/p error
07:35:06 <applicative> zvrba: you want a vector of *lists* of floats? not a vector of floats?
07:35:26 <zvrba> applicative: yes.
07:35:32 <applicative> i guess so hm
07:35:40 <zvrba> solving this one: http://www.reddit.com/r/dailyprogrammer/comments/1hzq9y/071013_challenge_129_intermediate_ndimensional/
07:36:03 <zvrba> project euler requires too much time spent on math, too little on programming.
07:36:08 <merijn> zvrba: if you use the "vectors" result somewhere as having the [Float] type, then type inference should notice that and specify that constraint for you, without the manual type annotation
07:36:41 <merijn> zvrba: You usually only need to add manual constraints if, for an odd reason, there's no way for GHC to figure it out on it's own
07:36:43 <zvrba> merijn: ok, I'll try it. have to finish the program first :)
07:36:44 <merijn> for example
07:36:51 <merijn> :t print . (+1) . read
07:36:52 <lambdabot> String -> IO ()
07:36:57 <merijn> oh, blah
07:37:01 <merijn> Stupid defaulting
07:37:07 <zvrba> defaulting?
07:37:09 <mauke> :t print . read
07:37:10 <lambdabot> String -> IO ()
07:37:13 <mauke> stupid extended defaulting
07:38:02 <merijn> zvrba: It can't figure out which Num to use there, print just wants "Show a" and read can return "Read a", i.e. that function could be using any a which is Num, Read and Show (which are a lot), so how can GHC pick which to use
07:38:20 <merijn> zvrba: lambdabot has some extended defaulting which says "just pick Int" or "just pick Integer"
07:38:25 <mauke> no
07:38:29 <mauke> that's normal defaulting
07:38:42 <geekosaur> ghci has it too, and extended defaulting makes it pick the least useful possible one ( () )
07:39:04 <Philonous> Wait, () has a num instance?
07:39:09 <Philonous> > 1 :: ()
07:39:11 <lambdabot>   No instance for (GHC.Num.Num ()) arising from the literal `1'
07:39:11 <lambdabot>  Possible fix...
07:39:29 <merijn> zvrba: Anyway, it's not very common to have to specify the Read result type
07:39:32 <applicative> "extended" defaulting
07:39:50 <merijn> zvrba: And GHC will complain when you have to, so just leave them out unless GHC complains
07:40:05 <zvrba> merijn: ok.
07:42:02 <misterdanb> hello
07:50:55 <kartlos> hey guys, is there a function that is like filter but returns both the resulting list and the list with the elements that are filtered out?
07:51:26 <elliott> :t partition
07:51:27 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
07:51:48 <kartlos> elliott: awesome, thanks!
07:52:41 <mauke> ask yourself what its type would be, then ask hoogle
08:00:16 <tomejaguar> I'm sure this is an age old question
08:00:35 <tomejaguar> What do I do if I want to do (-1) and have it mean \x -> x - 1?
08:00:47 <danharaj> :t sub
08:00:48 <lambdabot>     Not in scope: `sub'
08:00:49 <lambdabot>     Perhaps you meant one of these:
08:00:49 <lambdabot>       `sum' (imported from Data.List),
08:00:55 <danharaj> err
08:01:17 <tomejaguar> Ah subtract
08:01:32 <tomejaguar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:subtract
08:01:39 <tomejaguar> I did try "minus"
08:01:43 <tomejaguar> :)
08:04:19 <Philonous> (\x -> x - 1) would work, too
08:04:45 <tomejaguar> It would, but I prefer subtract "1"
08:04:58 <tomejaguar> *"subtract 1"
08:04:59 <LambdaDusk> please tell me someone else finally made an oauth 2.0 client lib for haskell because my trials always run into the problem I have no idea how it works and reading the rfc 3 times only makes me feel dumber
08:05:08 <tomejaguar> because lambdas are slightly less readable imo
08:05:42 <zvrba> how can I import only ! from Data.Vector as unqualified, but rest as qualified ?
08:06:05 <Clint> with two lines
08:06:10 <tomejaguar> import Data.Vector ((!))
08:06:16 <tomejaguar> import qualified Data.Vector
08:06:19 <zvrba> ok
08:06:21 <Twey> LambdaDusk: I think there's something with Yesod
08:06:37 <LambdaDusk> Twey: nope, oauth 1.0 only
08:06:54 <Twey> Hm, really?  I'm sure I remember seeing a 2.0 lib.
08:07:17 <LambdaDusk> Twey: me too, but neither authenticate-oauth nor hoauth implement oauth 2
08:08:31 <Twey> LambdaDusk: There's a package called hoauth2
08:08:44 <Twey> That does 2.0
08:08:57 <Twey> Doesn't seem very well-documented, though
08:09:20 <LambdaDusk> Twey: I missed that one, huh
08:09:51 <Clint> was oauth 2.0 the one that was widely regarded as terrible?
08:09:52 <LambdaDusk> looks like it is exactly the package I have been trying to make all day
08:10:13 <LambdaDusk> Clint: mostly, yes, because of corporate meddling
08:10:19 * Clint nods.
08:10:38 <Twey> LambdaDusk: This exists too, if you want a quick example of implementation: https://gist.github.com/qzchenwl/2351071
08:11:38 <LambdaDusk> Clint: OAuth 1 is problematic because the spec leaves room for interpretation
08:11:49 <Clint> hmm
08:12:38 <LambdaDusk> Twey: thanks
08:12:43 <Nisstyre> LambdaDusk: yeah, it really really sucks when websites have slightly different versions of a protocol
08:13:12 <Nisstyre> makes me want to bash my head into a wall
08:14:24 <notdan> http://paste.lisp.org/display/138033 can sombody help me out, with does the default display implementation does not type check? Could not deduce (DisplayOpts a0 ~ DisplayOpts a)
08:14:53 * hackagebot nemesis-titan 2013.7.13 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.7.13 (JinjingWang)
08:14:55 <Nisstyre> notdan: a0 and a could be different types
08:14:57 <notdan> but I don't understand why there are ambigouous type variable
08:15:32 <LambdaDusk> Nisstyre: for oauth 1 the twitter ipmlementation seems to be reference one
08:15:50 <Nisstyre> LambdaDusk: that doesn't really solve the problem if facebook decides to use a different one
08:16:33 <misterdanb> anyone out here, who would like to try help me with network foo? i made a server socket to send a file from disk over the network (binary file, read and sent using bytestring), but when i try to download it with wget only arrives partially and stops at a more or less random percentage value (except some rare times, when it arrives successfully)… i have _no_ idea, why this happens and why it doesn't work as expected…
08:16:35 <mauke> notdan: what's the error message?
08:16:52 <mauke> misterdanb: define "stops"
08:16:58 <notdan> mauke: Could not deduce (DisplayOpts a0 ~ DisplayOpts a)
08:16:58 <notdan> from the context (Display a)
08:17:09 <mauke> notdan: what's the complete error message?
08:18:09 <misterdanb> mauke: 2013-07-13 16:38:29 (200 MB/s) - Lesefehler bei Byte 3929808/4030454 (Die Verbindung wurde vom Kommunikationspartner zurückgesetzt). Erneuter Versuch. --- (it's german for "Read error at byte .../... (the connection has been reset by the communication partner))
08:18:18 <misterdanb> mauke: that's the error message of wget
08:18:22 <mauke> connection reset by peer :-)
08:18:31 <LambdaDusk> Nisstyre: OAuth 2 wanted to fix it with exact specifications, but the sponsoring corporations wanted an easy system, so the guy who made it said himself it's not really a nice authentication system
08:18:46 <misterdanb> mauke: haskell says: hPutBuf: resource vanished (Connection reset by peer)
08:19:03 <mauke> huh, interesting
08:19:15 <mauke> that sounds like EPIPE
08:19:26 <mauke> ... no, it doesn't
08:19:31 <Cale> notdan: What's the type of displayListOf?
08:19:57 <misterdanb> mauke: the network itself is pretty okay, tested other tools to send files
08:20:18 <mauke> misterdanb: show your code?
08:21:26 <misterdanb> http://lpaste.net/90871
08:22:07 <misterdanb> mauke: (excuse bad coding convetions, i'm new to haskell ^^)
08:22:35 <Cale> notdan: oh, I see, it's the other line
08:22:41 <Cale> notdan: display a = displayOpts defaultOpts a
08:22:46 <FreeFull> Networking always has problems no matter what language you use
08:23:11 <Cale> There's no way for it to tell that defaultOpts is meant to be of type DisplayOpts a for this a
08:23:11 <mauke> misterdanb: your code is not exception safe
08:24:00 <Cale> er, hmm
08:24:03 <Cale> no, there is
08:24:26 <Cale> (specifically, that displayOpts is also passed a value of type a)
08:24:49 <misterdanb> mauke: uhm k… (haven't done exceptions in haskell yet)
08:25:16 <mauke> depends on your definition of "done"
08:25:41 <misterdanb> mauke: haven't even read something of that topic ^^
08:26:48 <Nisstyre> misterdanb: it's possible to use things like Control.Exception to help make your code exception safe
08:26:48 <drostie> Has anyone tried to implement one of Demaine et al.'s two ideas for persistent tries? The theory is a bit dense and wishy-washy and I'd love to see something more concrete, even if in the end I just build something like bytestring-tries or so.
08:27:15 <Nisstyre> misterdanb: assuming you can't just use Maybe/Either/etc...
08:27:16 <CaptainK> amazing you can still have succes in haskell programming, but not really understand what you're doing :P
08:27:24 <mauke> Nisstyre: what
08:27:48 <Nisstyre> mauke: I mean assuming you can't just not use code that might raise exceptions
08:27:57 <CaptainK> map being used to call code is so strange to an imperative programer
08:28:03 <mauke> Nisstyre: what does this have to do with the code in question?
08:28:07 <Nisstyre> mauke: nothing
08:28:55 <banister> shachaf: are you excited about this book? http://shop.oreilly.com/product/0636920026365.do
08:29:09 <mauke> misterdanb: I don't see any obvious problems in the code
08:29:34 <mauke> apparently something is interrupting the connection somewhere
08:29:53 * hackagebot nemesis-titan 2013.7.13.1 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.7.13.1 (JinjingWang)
08:29:55 <banister> or anyone else excited about it? :D
08:30:03 <misterdanb> mauke: i had it tested by some other people in network, too, but the same errors occured
08:31:09 <drostie> misterdanb: "20% cooler than woof." I'm sold. :D
08:31:33 <Cale> CaptainK: If it compiles, ship it
08:31:50 <misterdanb> drostie: at least 20% less working v.v…
08:32:25 <notdan> mauke: http://paste.lisp.org/display/138035 - the full error message (sorry I got disconnected)
08:32:52 <notdan> Cale: but why can't I enforce it to be of the correct type by explicitly giving it a type: (defaultOpts :: DisplayOpts a)?
08:32:57 <CaptainK> Cale: omg that is so scary, wonder how many programs are like that?
08:33:36 <Cale> CaptainK: It actually is surprisingly often the case that if a Haskell program, even a highly nontrivial one, compiles, then it also works correctly.
08:33:36 <drostie> misterdanb: what's the problem exactly? I only signed on just before your lpaste link.
08:33:38 <shachaf> banister: ?
08:33:42 <applicative> notdan: what is the type of displayListOf
08:33:57 <banister> shachaf: do you think it'll be a decent book?
08:34:06 <Cale> applicative: that's actually not the problem, you can remove that from the class definition and still have the problem he's running into
08:34:19 <notdan> applicative: displayListOf :: (a -> DisplayResult) ->  [a] -> DisplayResult
08:34:21 <Cale> (Though it would have been nice of notdan to have pasted the complete code...)
08:34:26 <applicative> Cale yes, but I can easily solve one of the problems
08:34:27 <shachaf> banister: Yes. But why me?
08:34:28 <CaptainK> could not get hackell to minix :(
08:34:33 <drostie> Cale: well, 'it compiles' just means that the remaining problems are semantic, but you could still just not understand the semantics of the components you've got.
08:34:38 <banister> shachaf: because you have mad skillz
08:34:44 <notdan> Cale, applicative: sorry I didn't paste it, I forgot it was there
08:34:56 <Cale> drostie: Well, types mean a fair amount.
08:35:00 <misterdanb> drostie: 2013-07-13 16:38:29 (200 MB/s) - Lesefehler bei Byte 3929808/4030454 (Die Verbindung wurde vom Kommunikationspartner zurückgesetzt). Erneuter Versuch. --- (it's german for "Read error at byte .../... (the connection has been reset by the communication partner)) <- error message of wget
08:35:00 <misterdanb> hPutBuf: resource vanished (Connection reset by peer) <- error message of haskell
08:35:10 <Cale> and say a fair amount about the semantics of the program
08:36:05 <CaptainK> you can do it if you install the development release of minix, but I only want the core functionality.  Does anyone have a setup running just the bare minimum to free up more resources for haskell doing serious compiles?
08:36:13 <applicative> notdan: the main trouble is that this is like defining class AssociatedString a where associatedString :: String
08:36:24 <merijn> CaptainK: w.r.t succesfully programming haskell without understanding what you're doing: You'd be surprised how many peoples code I've debugged without knowing what they were trying :p
08:36:25 <mauke> notdan: defaultOpts cannot be used
08:36:35 <CaptainK> lol
08:36:54 <merijn> CaptainK: Similarly, a lot of my own code consists of, "write type signature, fiddle with random permutations of code until it compiles, huh...it works..."
08:36:58 <applicative> if defaultOpts had the type a -> DisplayOpts a, this would take care of most of it
08:37:09 <CaptainK> at least you might know what your doing...
08:37:32 <Cale> Or another way to solve the problem is to make DisplayOpts into an associated data family
08:37:33 <notdan> applicative: but String does not depend on 'a', however 'DisplayOpts a' does
08:37:36 <mauke> notdan: to find the right defaultOpts, ghc has to find the 'Display' instance for 'a'. for that it needs to know 'a'. there is no way to deduce 'a' from 'DisplayOpts a'
08:37:38 <applicative> then the default implementation of display would be display a = displayOpts (defaultOpts a) a
08:37:40 <Cale> rather than an associated type synonym
08:37:48 <CaptainK> then you're reading the parse and mismatch errors a lot...thats what helps me.
08:37:54 <notdan> Cale: to make it injective?
08:38:01 <Cale> yeah
08:38:18 <applicative> notdan: but it still cant deduce from the fact that something is of type Display a, what the a is
08:38:28 <notdan> mauke: but why can't it deduce 'a' from the second argument?
08:38:36 <CaptainK> which brings me to another question, Where is a more comprehensive list of understanding haskell error messages?
08:38:38 <mauke> notdan: what second argument?
08:38:43 <mauke> notdan: defaultOpts takes no arguments
08:38:48 <applicative> same as it cant figure from the fact that something is of type String, what it's the associatedString of
08:39:30 <applicative> well, displayOpts could be displayOpts for anything
08:39:33 <notdan> mauke: the second argument for displayOpts :: DisplayOpts a -> a -> ..
08:39:46 <mauke> notdan: we don't care about displayOpts
08:39:54 <mauke> notdan: the problem is defaultOpts
08:39:55 <misterdanb> drostie: any idea?
08:40:20 <applicative> mauke: but the trouble is that displayOpts doesn't make sense, given defaultOpts
08:40:26 <mauke> applicative: what?
08:40:40 <mauke> applicative: the problem is that defaultOpts cannot be used
08:40:42 <mauke> regardless of context
08:40:52 <notdan> mauke: yes, I understand that. But I am using defaultOpts in displayOpts
08:40:54 <merijn> hmm
08:41:02 <mauke> notdan: you're trying to but failing
08:41:02 <applicative> mauke, right, as is being shown in the case of displayOpts
08:41:06 <mauke> because defaultOpts cannot be used
08:41:06 <notdan> and 'a' can be deduced from the context
08:41:15 <notdan> so why can't DisplayOpts a be deduced?
08:41:20 <mauke> what
08:41:23 <mauke> notdan: wrong question
08:41:34 <mauke> notdan: the problem is that you don't have 'a'
08:41:41 <mauke> or rather: that there are different 'a's
08:41:50 <mauke> because there's another one flying around that is obviously known
08:42:09 * CaptainK takes boy out in kayak, bbl
08:42:29 <mauke> notdan: you seem to think that 'display' should use 'defaultOpts' from the same instance declaration (i.e. for the same 'a')
08:42:36 <mauke> this is not expressed anywhere in the code
08:42:50 <notdan> Yeah, that's what I don't understand. Why there are several a's? The type signature of displayOpts mentiones only one 'a'.
08:43:07 <mauke> sigh. displayOpts is irrelevant
08:44:52 <mauke> notdan: instance Display Int where { type DisplayOpts Int = String; ... }
08:44:59 <mauke> notdan: instance Display () where { type DisplayOpts () = String; ... }
08:45:03 <notdan> Why is it irrelevant? Usually, given the type of 'f' and the type of 'f x' you can deduce the type of 'x'
08:45:20 <mauke> notdan: correct. we can deduce the type of 'x'
08:45:22 <mauke> but that's not enough
08:45:42 <mauke> notdan: display (42 :: Int)
08:45:50 <mauke> notdan: now in my example, a = Int
08:46:26 <mauke> 'displayOpts :: DisplayOpts a -> a -> DisplayResult' gets instantiated to 'displayOpts :: DisplayOpts Int -> Int -> DisplayResult'
08:46:43 <mauke> 'DisplayOpts Int' becomes 'String'
08:46:59 <mauke> we end up with: displayOpts :: String -> Int -> DisplayResult
08:47:06 <notdan> ah
08:47:09 <notdan> I see
08:47:17 <mauke> type constraint: defaultOpts :: String
08:47:21 <mauke> what's the corresponding 'a'?
08:47:44 <notdan> thanks for clearing this up for me. I was confused thinking that it would resolve displayOpts :: DisplayOpts Int without replacing DisplayOpts Int by String beforehand
08:47:57 <mauke> well, it's just a type alias
08:48:08 <mauke> it doesn't really exist by itself
08:48:20 <zvrba> I have something like this: forM_ [1..nCommands] (\_ -> fmap (doCommand vectors . words) getLine)
08:48:27 <zvrba> doCommand produces an IO () with print
08:48:40 <zvrba> the program patiently waits for nCommands lines to be entered
08:48:45 <zvrba> however, nothing is ever printed
08:48:47 <notdan> And there are no newtype-families :(
08:48:51 <notdan> thanks again mauke
08:48:53 <zvrba> what's wrong?
08:49:00 <mauke> yay
08:49:21 <zvrba> (I know that the program waits for the correct # of comands because it writes out an error message if I input EOF earlier)
08:49:22 <mauke> zvrba: that looks like replicateM_, btw
08:49:29 <zvrba> true
08:49:33 <mauke> zvrba: fmap is wrong
08:49:35 <zvrba> didn't know about that one
08:49:45 <zvrba> how is it wrong?
08:49:50 <mauke> if doCommands produces an IO (), then the type of the fmap thing is IO (IO ())
08:50:05 <mauke> :t fmap print getLine
08:50:05 <lambdabot> IO (IO ())
08:50:13 <zvrba> hmm
08:50:25 <zvrba> I have this: doCommand :: DV.Vector [Float] -> [String] -> IO ()
08:50:32 <zvrba> how to make it take IO [String]
08:50:34 <notdan> doCommand vectors . words =<< getLine
08:50:35 <zvrba> instead?
08:50:55 <mauke> zvrba: you want >>= for that. or do-notation
08:51:01 <mauke> :t (>>=)
08:51:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:51:04 <Cale> Or of course, you could join
08:51:07 <Cale> :t join
08:51:07 <lambdabot> Monad m => m (m a) -> m a
08:51:13 <mauke> sure, but >>= is a bit more direct
08:51:22 <Cale> But join (fmap f x) is the same thing as f =<< x
08:51:30 <mauke> ^ read as: IO a -> (a -> IO b) -> IO b
08:51:35 <mauke> :t getLine >>= print
08:51:35 <lambdabot> IO ()
08:51:47 <zvrba> ah, I need monadic composition
08:51:49 <zvrba> ok..
08:51:51 <mauke> @src join
08:51:51 <lambdabot> join x =  x >>= id
08:52:13 <zvrba> but if fmap is wrong, why did it typecheck?
08:52:36 <merijn> zvrba: Well, it's not wrong
08:52:38 <mauke> it's "wrong" in the sense that it doesn't do what you want here
08:52:40 <Cale> zvrba: You're computing a bunch of IO actions as the results here, and then forM_ is discarding those results
08:52:42 <merijn> zvrba: It's just not what you wanted :p
08:52:45 <mauke> it's valid code, though
08:53:12 <mauke> > length [print 1, print "hi", return ()]
08:53:13 <lambdabot>   3
08:53:25 <mauke> ^ valid code that does nothing with the IO actions it computed
08:53:49 <merijn> zvrba: "fmap print getLine" is an IO action that produces an IO action, specifically its an action that reads a line and then returns an action to print that line
08:54:05 <merijn> zvrba: on the other "print =<< getLine" is an action that reads a line and prints it
08:54:34 <Cale> zvrba: Does that all make sense? :)
08:54:56 <drostie> misterdanb: I can't quite reproduce the error in my own case, sorry. :<
08:55:17 <zvrba> Cale: not quite. except that it sounds like I had an extra level of nesting.
08:56:21 <Cale> zvrba: Okay, so an IO action  x :: IO t  is a value representing a piece of code which could be executed to produce a result of type t, and in the meantime have any sort of effect your computer can perform.
08:57:15 <Cale> zvrba: Evaluating the value x here won't do anything much (except make your CPU a little bit hotter, perhaps), just as opening the source code of a program in a text editor won't cause that program to run.
08:57:51 <zvrba> ok, got that
08:58:02 <misterdanb> drostie: so the code works for you and your network?
08:58:20 <Cale> zvrba: doCommand :: DV.Vector [Float] -> [String] -> IO ()  is something which, supplied with some parameters, is going to produce an action of type IO ()
08:58:20 <zvrba> lyah says to call forM_ when you're not interested in the eventual result of whatever the function produces
08:58:28 <Cale> right
08:58:32 <zvrba> i.e., you map over it just for side-effects
08:58:38 <zvrba> right
08:58:51 <zvrba> so why isn't that list of IO () not executed?
08:58:56 <Cale> and in this case, the result of each iteration of your loop was in fact an action that you cared about
08:59:02 <zvrba> yes
08:59:08 <zvrba> so what did fmap do?
08:59:09 <mauke> it's not a list of IO ()
08:59:16 <mauke> it's a list of IO (IO ())
08:59:21 <Cale> fmap :: (a -> b) -> IO a -> IO b
08:59:26 <zvrba> ah
08:59:28 <zvrba> i get it now
08:59:31 <Cale> So specialising that a little more, we have:
08:59:41 <Cale> fmap :: (a -> IO t) -> IO a -> IO (IO t)
09:00:21 <mauke> fmap :: (String -> IO ()) -> IO String -> IO (IO ())
09:00:48 <zvrba> an running IO (IO ()) just returns an IO () which does nothing
09:00:54 <zvrba> or..?
09:01:10 <mauke> the outer IO can have side effects (and does: your program consumes input)
09:01:23 <Cale> zvrba: Well, some initial part of the effects will happen, and then an action will be produced which you can decide to run or not.
09:01:23 <mauke> the inner IO is thrown away by your program, so it has no effect
09:01:45 <Cale> zvrba: For instance, you could use forM in place of forM_ here to get a list of the IO actions resulting from each iteration of the loop
09:01:51 <mauke> you could collect those IO actions and run them later
09:01:53 <Cale> and then run all those actions afterward
09:01:59 <mauke> Cale: or just some of them!
09:02:03 <Cale> indeed
09:02:03 <zvrba> oh, that's actually cool :)
09:02:07 <mauke> or reorder them, etc
09:02:19 <mauke> first class imperative code :-)
09:03:12 <mauke> > "pong"
09:03:12 <lambdabot>   "pong"
09:07:22 <zvrba> good, the program works now
09:10:50 <merijn> zvrba: Yes, it's pretty cool, a nice example I saw was this type for installing event handlers "(a -> IO ()) -> IO (IO ())", it's a function that takes an event handler that does some IO based on an event ("a -> IO ()") and returns an IO action ("IO (IO ())"), this IO action is what actually registers the callback and when executed the action returns a new action that unregisters the callback
09:11:43 <zvrba> :)
09:26:29 <Fuuzetsu> Let us hear your opinions: http://lpaste.net/90872
09:27:36 <drostie> Can anyone quickly answer how to stat() in Haskell? Hoogle is giving me lots of results for State. :<
09:28:03 <Cale> drostie: Remind me what stat does
09:28:14 <Fuuzetsu> @pl extractPrefix p = uncurry ((>>) . guard . on (==) (map toUpper) p) . second return . splitAt (length p)
09:28:14 <lambdabot> extractPrefix = ap ((.) . uncurry . (((>>) . guard) .) . on (==) (map toUpper)) ((second return .) . splitAt . length)
09:28:55 <Cale> drostie: Perhaps you want the stuff in System.Directory?
09:29:00 <drostie> Cale: it gives you filesystem information about the file without reading the file; in this case the info I want is the length of it.
09:30:11 <Cale> drostie: I don't think there's a platform-independent way, but you can use getFileStatus from System.Posix.Files
09:30:58 <Cale> and then there's a function fileSize :: FileStatus -> FileOffset
09:31:04 <Cale> type FileOffset = COff
09:31:13 <drostie> Thanks! :D
09:31:13 <Cale> newtype COff = COff Int64
09:31:21 <drostie> this looks like exactly the API I need.
09:32:11 <Cale> There really ought to be a platform independent API for getting a bit more information about files.
09:35:18 <merijn> drostie: You might want to look in the System.Posix hierarchy of things
09:36:05 <merijn> drostie: The docs for getFileStatus mention "Note: calls stat"
09:36:09 <merijn> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Files.html
09:36:17 <merijn> non-portable, obviously
09:50:21 <drostie> merijn: that's what Cale pointed me to; thanks!
09:58:36 <merijn> Man, I need an @pl that doesn't so much make my code pointfree as it mangles my pointfree code to be nicer :p
09:58:39 <merijn> @pl (fmap.fmap) (fmap f *** id)
09:58:40 <lambdabot> fmap (fmap (fmap f *** id))
09:59:24 <merijn> @pl \x -> Foo $ (fmap.fmap) (fmap f *** id) x
09:59:25 <lambdabot> Foo . fmap (fmap (fmap f *** id))
10:18:27 <robstewartuk> I'm failing to load a package, when trying to link to HSatomic-primops in the atommic-primops library.: "unkown symbol `cas'".
10:18:46 <robstewartuk> Suspicions are raise on line 13 of https://github.com/rrnewton/haskell-lockfree-queue/blob/master/AtomicPrimops/cbits/primops.cmm
10:19:04 <robstewartuk> I have a non-default GHC installation:
10:19:33 <robstewartuk> ~/sw/ghc/ghc-7.6.3-BUILD/lib/ghc-7.6.3/include/stg/SMP.h
10:19:38 <NemesisD> is there any point in using Int over Integral for non-performance-critical code?
10:19:48 <robstewartuk> The error itself is:
10:20:05 <NemesisD> Integer not Integral
10:20:05 <robstewartuk> Loading package atomic-primops-0.2.2 ... linking ... ghc: ~/.cabal/lib/atomic-primops-0.2.2/ghc-7.6.3/HSatomic-primops-0.2.2.o: unknown symbol `cas'
10:24:35 <mcstar> Int overflows, it can be nice
10:26:20 <NemesisD> hmm. i've got a type that can easily be converted to an int(eger) that i'd like to do arithmetic on. is there an easier way to make this happen than coding Eq, Ord, Num, Enum, Real, and Integral?
10:27:36 <NemesisD> converting back from an int(eger) might be a bit dicier
10:29:40 <NemesisD> hmm, nm i think i'm approaching this wrong
10:31:51 <monochrom> I would write the necessary instances. in the long run anyway.
10:33:53 <NemesisD> i think i needed fewer intances than i needed. the datatype represents an interval: Every Integer TimeUnit; data TimeUnit = Seconds ...
10:34:40 <NemesisD> the only operations i think i'll need to do is advance a UTCTime in seconds
10:35:22 <mcstar> interval arithmetic is nice to implement line of sight algorithms
10:35:52 <mcstar> i dont think i found packages for that, but i might have not even searched, idk
10:38:26 <NemesisD> mine probably won't be generally applicable. i'm building a dead-man's switch service where you register periodic activities and they notify you when those tasks  don't get done at the specified interval
10:39:04 <NemesisD> i thought about doing this for a while, then I saw a really basic service crop up that did this and charged $19/mo for it
10:39:19 <mcstar> o.O
10:39:28 <NemesisD> my reaction too
10:39:47 <mcstar> do they notify you by email, or they drive to your house with a bat?
10:40:31 <mcstar> (in the latter case i could understand the cost)
10:42:25 <NemesisD> lol
10:43:18 <NemesisD> i'm of the opinion that if you build a business model on a product that easy to build, someone's going to come along and just make an open source version
10:44:39 <joseanpg> #F#
11:00:56 <magneticduck> question: does the {- commenting style only work until a maxium amount of lines?
11:01:01 <magneticduck> or is vim just glitching out
11:01:23 <magneticduck> because when I use {- to commend a large block, it seems that only the first 50 or so lines go blue
11:01:46 <timemage> magneticduck, it's probably just vim.
11:01:50 <magneticduck> it seems to compile ok though.. so I expect it's just vim
11:01:53 <arnsholt> Pretty sure it's a vim glitch
11:01:56 <magneticduck> alright then. anybody else have this problem?
11:02:00 <mcstar> vim's fault
11:02:08 <magneticduck> so much hate for vim here :<
11:02:16 <lelf> use emacs
11:02:16 <arnsholt> I have the same problem. Code works fine though
11:02:20 <magneticduck> poor vim, taking all the blame
11:02:29 <magneticduck> rofl lelf; that would be ONE solution
11:02:42 <magneticduck> but I could also use cat; no colors to worry about at all!
11:02:50 <lelf> poor vim, cannot even highlight comments
11:02:52 <arnsholt> I can usually convince it to highlight it properly by scrolling a bit
11:03:11 <magneticduck> or echo >> along with various shell utils
11:03:24 <Demos> ed
11:03:25 <arnsholt> It's a weird bug in the syntax, indeed. Anyone know who maintains that stuff?
11:03:28 <Demos> ?
11:03:48 <timemage> magneticduck, i like vim.  i just realise that what it does to do syntax highlighting is not exactly parsing.  it fails fairly often for nontrivial grammars.  also sometimes if you reload the buffer it will "fix" itself.
11:03:57 <magneticduck> "alternative" text editors seem to be a running joke whenever we talk about vim vs emacs
11:04:15 <magneticduck> hm, how do I reload the buffer in question?
11:04:26 <Demos> ed is hardly alternative!
11:04:30 <timemage> magneticduck, just :edit
11:04:31 <magneticduck> I'm a bit of a vim newbie; I'm also "lazy" (I only learn what's right in front of me)
11:04:33 <magneticduck> ah ty
11:04:58 <joseanpg> Hello
11:05:05 <haasn> timemage: doesn't vim usually disregard stuff that's written some distance before the start of your buffer (to conserve memory / processing power on very large files)?
11:05:17 <haasn> I've found that causes all sorts of highlighting issues with stuff like lhs
11:05:28 <haasn> fortunately, there's a setting to make it always highlight the whole file
11:05:46 <magneticduck> enlighten us!
11:06:01 <magneticduck> I'm not working with files more than 600 lines, and it's a good processor
11:06:03 <haasn> “syntax sync fromstart” or similar
11:06:22 <magneticduck> issue solved
11:06:28 <magneticduck> ty
11:06:46 <magneticduck> there's a new line for vimrc
11:07:24 <timemage> haasn, i don't know much about its internals.  but when you run into problems you can often find errors in the syntax file that aren't simple to fix.
11:08:31 <haasn> yeah, but my setting is generally eliminates the class of highlighting errors that are fixed by just “reloading the buffer” or “scrolling a bit”
11:08:42 <magneticduck> sure, but in this case it's just a simple problem caused by syntax outside of the viewed scope I imagine
11:08:54 <magneticduck> no real parsing problems
11:09:00 <magneticduck> ^
11:09:20 <timemage> a lot of them look like what people do when the try to "parse" a web page.  by which i mean they throw a bunch of regular expression at the problem that for the most part work.   not such a horrible thing if it only means thing are the wrong color sometimes.
11:09:32 <timemage> haasn, yeah.  i'll make a note of it.
11:09:59 <zvrba> i have a program that gives a different result in ghci and after being compiled with ghc
11:10:35 <magneticduck> what kind of program
11:10:39 <magneticduck> uh
11:10:42 <zvrba> http://pastie.org/8137946
11:10:56 <zvrba> the check 1 case always return false even in cases like Graph and GRAPH
11:11:06 <zvrba> i'm solving this one: http://www.reddit.com/r/dailyprogrammer/comments/1heozl/070113_challenge_131_easy_who_tests_the_tests/
11:11:19 <zvrba> again, the output is OK for the test input when run in ghci
11:11:29 <zvrba> but all "1" tests return "BAD"
11:11:51 <magneticduck> somebody braver than me must solve this one
11:12:31 <haasn> the two things I can think of that might contribute to a difference: 1. GHCi using different defaulting settings, 2. something like line buffering perhaps
11:12:55 <magneticduck> I'm trying to think what setting could be on in GHC that would cause something like that
11:12:59 <zvrba> hmm
11:13:09 <zvrba> i set explicitly line buffering in main
11:13:17 <zvrba> though, I run just p131 directly in the ghci session
11:13:18 <magneticduck> my bet is on line buffering
11:13:28 <zvrba> (repl within eclipse)
11:13:46 <pentace> zvrba: Try to give n/check/checkOne an explicit type signature
11:14:25 <zvrba> pentace: uh, why?
11:14:33 <zvrba> magneticduck: and why would line buffering matter at all?
11:15:13 <pentace> zvrba: GHC might default (read n) to a different type then Int(eger)
11:15:37 <magneticduck> zvrba: I have no idea, but it sounds the least impossible
11:15:40 <Lethalman> with gio I can enumerate the files in a directory asynchronously
11:15:44 <Lethalman> can I do that with haskell?
11:15:54 <zvrba> anyway, adding type signatures didn't help
11:15:59 <Lethalman> I'd like to retrieve the list of files of a directory, but it takes very long cause there are tons of files
11:16:07 <zvrba> pentace: ah, hardly, it reads exactly 6 lines..
11:16:21 <danharaj> Does anyone use sublime text?
11:16:24 <zvrba> but hlint complains about "too strict if"
11:16:27 <zvrba> what does that mean?
11:16:29 <monochrom> haskell can call gio too. http://hackage.haskell.org/package/gio
11:16:31 <Lethalman> should I rewrite getDirectoryContents to return one file at time, or there's something already?
11:16:52 <Lethalman> monochrom, mh yes, apart using gio itself
11:17:16 <haasn> danharaj: I used to use ST2 before I switched to vim
11:17:51 <optimusbrine> danharaj, I use it, though I am using st3 beta atm
11:17:54 <magneticduck> danharaj: I used to
11:18:14 <danharaj> I'm using st3 as well. I was wondering if anyone has suggestions to optimize it for haskell.
11:18:29 <haasn> Hmm, I just added syntax highlighting and hlint support
11:18:38 <zvrba> does getLine always strip newline?
11:18:42 <monochrom> yes
11:18:47 <Demos> how is ST3, what is different compared to st2
11:19:15 <Lethalman> monochrom, getDirectoryContents returns an IO [FilePath], and it does by enumerating the files internally
11:19:19 <haasn> I imagine Sublime Text would be a lot more interesting if it were free
11:19:27 <Lethalman> so let's say I have files <- getDirectoryContents ..
11:19:38 <Lethalman> files won't be filled until I use it
11:19:55 <Lethalman> but let's say I only want (firstFile:_) = files
11:20:03 * haasn wonders if one of the async packages would be useful here
11:20:11 <Lethalman> will the action fill the whole files?
11:20:34 <Lethalman> or will only return the first readDirStream file
11:20:40 <zvrba> haasn: what default settings were you talking about?
11:20:45 <chrisdone> is it me or do we need a (a -> Bool) -> a -> Maybe a
11:20:46 <haasn> Lethalman: depends on how much getDirectoryContents abuses lazy I/O I guess
11:20:53 <Lethalman> http://hackage.haskell.org/packages/archive/directory/1.2.0.1/doc/html/src/System-Directory.html#getDirectoryContents
11:21:00 <chrisdone> @hoogle (a -> Bool) -> a -> Maybe a
11:21:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:21:00 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:21:00 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
11:21:13 <Lethalman> seems lazy but I'm a little unsure :S
11:21:42 <chrisdone> hmm, foldable's find is a good approximation
11:21:52 <haasn> zvrba: defaulting; as in picking suitable types to fill in for certain sets of constraints eg. Floating a --> a ~ Double
11:21:54 <optimusbrine> danharaj, idk really, i just use the default configuration.
11:22:14 <S_J> whats the point of records when you have ADTs?
11:22:17 <haasn> zvrba: sometimes weird things can happen when stuff defaults to () or similar, and GHCi uses more aggressive defaulting rules than GHC in order to prevent ambiguous type errors, but I don't think it would be relevant here
11:22:19 <zvrba> maybe I should just update the haskell platform
11:23:04 <elliott> chrisdone: x <$ guard (p x)
11:23:21 <Lethalman> so lately I was reading in this chat about ghc-mod and emacs
11:23:32 <Lethalman> is it this? http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html or there's something more recent?
11:23:54 <chrisdone> > mapMaybe (Data.Foldable.find ((==0).(`mod` 2)) . Just) [1..10]
11:23:55 <lambdabot>   Not in scope: `Data.Foldable.find'
11:23:55 <lambdabot>  Perhaps you meant one of these:
11:23:55 <lambdabot>    `Dat...
11:24:00 <chrisdone> D:
11:24:12 <chrisdone> how old is lambdabot's base?
11:24:42 <haasn> Lethalman: I don't see any unsafeInterleaveIO there
11:24:50 <Lethalman> ah
11:25:03 <elliott> chrisdone: not old at all
11:25:04 <Lethalman> haasn, so it will fetch all the files once I start reading the list
11:25:05 <elliott> :T F.find
11:25:07 <elliott> :t F.find
11:25:08 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
11:25:13 <monochrom> rather, lambdabot's import statement may assign a different name to Data.Foldable
11:25:19 <chrisdone> ah, it imports fully qualified
11:25:27 <chrisdone> > mapMaybe (F.find ((==0).(`mod` 2)) . Just) [1..10]
11:25:28 <lambdabot>   [2,4,6,8,10]
11:25:31 <haasn> Lethalman: looks like the body of ‘loop’ will execute all of the ‘Posix.readDirStream’ actions before constructing the list
11:25:39 <haasn> ie. returning
11:25:48 <Lethalman> yes
11:25:58 <elliott> chrisdone: s/Just/Identity/
11:25:59 <monochrom> lambdabot's naming convention is random
11:26:00 <haasn> of course, maybe Posix.readDirStream has unsafeInterleaveIO in its body. I don't know. Test it?
11:26:03 <Lethalman> but functions like map can compute only the first element for example
11:26:10 <Lethalman> haasn, yes trying to test
11:26:19 <elliott> monochrom: I tried to rationalise it somewhat
11:26:37 <chrisdone> > mapMaybe (\x -> pure x <* guard (((==0).(`mod` 2)) x)) [1..10]
11:26:38 <lambdabot>   [2,4,6,8,10]
11:26:43 <chrisdone> elliott: ^ that's pretty wordy
11:26:52 <BMeph> Does it betray my programming history too much, that I have a name for (==0): zeroP? ;)
11:27:20 <elliott> chrisdone: why pure x <* and not x <$?
11:27:32 <Lethalman> haasn, the strace seems the same for both print files and print (head files)
11:27:40 <chrisdone> > mapMaybe (\x -> x <$ guard (((==0).(`mod` 2)) x)) [1..10]
11:27:41 <haasn> Lethalman: yeah, but what would happen in that case is that the RTS still executes all of the necessary IO actions; then sticks the results of them into some useless thunks that then get garbage collected away because the rest of your code only looks at the head
11:27:41 <lambdabot>   [2,4,6,8,10]
11:27:47 <chrisdone> elliott: ^ that's still pretty wordy =p
11:27:50 <monochrom> it is not enough to rationalise. you have to make it either discoverable or predictable
11:27:52 <elliott> ensure p x = x <$ guard (p x) -- a common name, I think
11:28:07 <haasn> Lethalman: the RTS doesn't know if Posix.readDirStream performs side effects or not, so it still has to execute all of the traversing before deciding to throw away teh results
11:28:19 <haasn> or it would potentially change semantics
11:28:24 <Lethalman> haasn, ah ok, that's because the IO action must be executed anyway entirely
11:28:29 <haasn> yes
11:28:33 <Lethalman> ok thanks
11:28:40 <haasn> (unless unsafeInterleaveIO aka evil lazy IO is used)
11:28:40 <Lethalman> I believe I'm going to use gio enumerator then
11:28:40 <monochrom> predictable means if I'm told Data.ByteString -> BS, then I expect Data.Foldable -> FD; if I'm told Data.Foldable -> F, then I expect Data.ByteString -> B
11:29:04 <haasn> monochrom: I go by the caps; ByteString has B and S; Foldable only has F
11:29:48 <monochrom> and in either case, and also haasn's case, I still cannot guess Control.Monad.State -> ?
11:30:06 <monochrom> i.e., is it M.S or S?
11:30:07 <elliott> there is also Sym and Seq. sorry.
11:30:25 <haasn> monochrom: yeah, it breaks down fast
11:30:47 <monochrom> in fact, M.S? S? M.St? St? MN.S? MN.St? ...
11:30:55 * BMeph wonders why Foldable -> FD, and not, say, -> FA ...
11:31:08 <haasn> the easiest solution would be to allow Control.Monad.State so nobody has to do any guessing
11:31:27 <monochrom> BS and FD denote the first two consonants
11:31:33 <chrisdone> elliott: ensure seems a nice name
11:32:08 <BMeph> monochrom: T and L are consonants. :)
11:32:33 <monochrom> ah, first two syllables' consonants!
11:32:41 <BMeph> chrisdone: Nice name; horrid beverage. ;)
11:33:31 <monochrom> anyway the current scheme is unpredictable, and I see that no scheme is predictable, except for just using the bloody full name
11:33:58 <S_J> isnt bind better than >>=. i mean afew of those >>= <*> is opk but when you have 10-20 it is hard to remember what each does
11:34:24 <elliott> monochrom: yes ideally the full name would be available. I should fix the fact that it isn't
11:34:26 <merijn> w00t! I finally figured out a sane design! Too bad my implementation doesn't actually work >.>
11:34:30 <BMeph> In ByteString's case, I suspect someone is making some kind of obscure joke, relating it to "BS". :)
11:34:34 <elliott> in fact I think it is a bug in GHC that after importing Foo, Foo.bar can ever not work
11:34:39 <elliott> erm
11:34:40 <elliott> not a bug in GHC
11:34:42 <elliott> but a bug in the Report
11:35:20 <aristid> bad style to use asserts for invariants that are difficult to encode in the type system?
11:35:53 <S_J> :t concat
11:35:53 <lambdabot> [[a]] -> [a]
11:36:33 <monochrom> Foo.bar cannot work? that is not my understanding or experience
11:37:18 <S_J> whats a good simple Applicative to implement to get the point?
11:37:38 <monochrom> for example Prelude.head usually works
11:37:47 <monochrom> > Prelude.head [()]
11:37:48 <lambdabot>   ()
11:37:50 <BMeph> S_J: What point?
11:37:51 <elliott> monochrom: I mean I think it is a bug that it is possible for it not to work
11:38:04 <elliott> as in, "import qualified Data.Bytestring as BS", I think "Data.ByteString.foo" should still work.
11:38:22 <monochrom> ok, adding "as" is different
11:39:24 <monochrom> let me think if I can defend that
11:40:35 <chrisdone> Twey: http://lpaste.net/90872 =)
11:40:45 <monochrom> I guess the only defense is, say, I really hate the names Data.ByteString and Data.ByteString.Lazy, I philosophically oppose those names, and therefore I do...
11:40:51 <jfischoff> monochrom: what's your opinion on teaching users to use Applicative <*> vs using do notation?
11:41:10 <monochrom> import Data.ByteString as Data.ByteString.Eager; import Data.ByteString.Lazy as Data.ByteString
11:41:19 <monochrom> teach both
11:41:22 <chrisdone> elliott: ensure was for that ^ =p
11:41:40 <elliott> monochrom: can you even import as "Foo.Bar"?
11:41:46 <monochrom> yes!
11:41:49 <elliott> whoa.
11:42:01 <elliott> you're scaring me, monochrom.
11:42:10 <jfischoff> jfischoff: agreed. I'm trying to win an argument at work that Applicative style has value
11:42:18 <jfischoff> its not working … yet
11:42:25 <chrisdone> i've done that before for something
11:42:43 <monochrom> have you read my http://www.vex.net/~trebla/haskell/module.xhtml ? :)
11:42:47 <elliott> chrisdone: use (<$>) instead of fmap and I think the last is ok. I think the version before the first one is also ok (the one where you remove "on")
11:42:57 <chrisdone> elliott: i prefer fmap to <$>, personally
11:43:04 <joseanpg> jfischoff: applicative, of course
11:43:34 <jfischoff> the social of issues of integrating haskell into an organizing are challenging
11:44:15 <monochrom> anyway, apart from my niche scarce corner-case usage defense, I can see that "import Data.ByteString as B" giving you both B.head and Data.ByteString.head is convenient most of the time
11:44:41 <elliott> module.xhtml scares me also
11:44:57 * hackagebot GLFW-b 1.0.1 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.0.1 (BrianLewis)
11:45:00 <monochrom> OTOH perhaps a simpler defense is "each import line enables exactly one module name, KISS"
11:45:06 <applicative> because it's xhtml?
11:45:26 <chrisdone> elliott: normal words instead of operators are easier to type, edit and read for me. for me, <$> is the canonical example of this
11:45:47 <elliott> chrisdone: aw, but <$> is so pretty.
11:46:02 <Twey> chrisdone: I suggested something like that.  I used uncurry and splitAt, though, to avoid traversing p twice.
11:46:03 <elliott> monochrom: does "import M \n import M" work?
11:46:07 <nexx> on the neo2 layout it is not a problem :D
11:46:14 <monochrom> I haven't tried.
11:46:31 <chrisdone> i don't even think it's that pretty? surely some nice unicode would be pretty :D
11:46:31 <elliott> it shall remain a mystery
11:46:36 <Twey> ( Fuuzetsu )
11:47:00 <monochrom> it is allowed. I added two "import Prelude"s :)
11:47:08 <elliott> too many Preludes.
11:47:08 <applicative> the $ in haskell is already hideous, how could <$> be anything but horrible
11:47:43 * applicative has a keybinding to replace $ with / that he uses when no one's looking 
11:47:44 <chrisdone> applicative: sums up my sentiment. i've actually all but stopped using $ in my daily code
11:48:53 <monochrom> my only use of $ is to please haskell emacs mode's indenter, i.e., "forkIO $ do\n" vs "forkIO (do\n"
11:48:58 <S_J> whats the state of haskell on heroku nowadays?
11:49:17 <chrisdone> monochrom: right, with my mode i can do forkIO (do …) happily
11:49:36 <monochrom> then again I'm still at 2.8.0 and haven't tried newer versions
11:49:46 * applicative does forkIO/ do ...
11:49:54 <elliott> applicative: do you ever divide numbers?
11:50:01 <applicative> nope
11:50:17 <applicative> i import prelude, hiding division!
11:50:23 <elliott> weirdo
11:50:30 <elliott> that's almost as bad as that lib that uses (-) for ($)
11:50:38 <elliott> like great, now you can't write factorial
11:50:45 <elliott> hope it's elegant enough for you
11:50:53 <chrisdone> monochrom: http://lpaste.net/90878 ← some genuine code i wrote. editor fully supports it like lisp =p
11:51:03 <applicative> hah
11:52:08 * applicative concedes that forkIO/ do ... is untenable; maybe unicode nonbreaking space...
11:52:23 <chrisdone> in a way, arithmetic can really feel very domain specific. unless you're into writing number applications, you can get away with not using the Num class for ages
11:52:35 <monochrom> if it is "withSocketDo (forkIO (forever (do \n", would the do-block be way too to the right?
11:52:36 <chrisdone> so operators like +, *, /, etc. are sitting there unused
11:52:37 <applicative> yes, its amazing
11:53:26 <jfischoff> chrisdone: do you forgo operators when writing parsers? No <|>?
11:53:28 <chrisdone> i don't do much number work in haskell, which is probably for the best because i don't like writing fromIntegral and `div`, kinda defies the point of using special operators in the first place if the code doesn't even look much like maths anymore
11:54:21 <monochrom> import Prelude hiding ((+)); import Text.Parsec((<|>) as (+), ...)
11:55:27 <chrisdone> jfischoff: i did, those kind of "n-ary" functions (i mean x <|> y <|> z in lisp is (<|> x y z)) i've been trying with lists like mconcat [x,y,z]
11:55:32 <ion> TIL you can rename imports like that.
11:56:02 <chrisdone> ion: you can't
11:56:06 <monochrom> no no, "(<|>) as (+)" is just my dream, no one else allows it
11:56:09 <ion> Heh, ok
11:56:10 <chrisdone> though i think it was possible in haskell 1.4 or something
11:56:30 <chrisdone> or i saw it on a super old mailing list archive being discussed
11:57:04 <monochrom> but maybe you haven't known you can "import Text.Parsec as Prelude; import System.IO.Unsafe as Prelude; ..."
11:57:14 <chrisdone> monochrom: it makes sense really, i think people are warming up to modules having specific domain languages?
11:57:16 <jfischoff> chrisdone: Fair enough. How about if the types are different i.e. <*>?
11:57:40 <chrisdone> like for all my view functions on sites using blaze-html, i NoImplicitPrelude the module and just use blaze-html, it's surprising how little of Prelude you need
11:58:01 <jfischoff> As we try to make coding conventions at work I'm trying to broaden my perspective...
11:59:21 <chrisdone> jfischoff: yeah, sadly it has to be an operator or nested aps =[
11:59:35 <chrisdone> though i did see a funky approach using do-notation
11:59:48 <jfischoff> you can definitely use do notation
11:59:50 <chrisdone> with RebindableSyntax you can locally replace (>>) with e.g. <*> and get what you want
11:59:58 <jfischoff> ah
12:00:01 <ion> monochrom: heh
12:00:05 <elliott> wow gross
12:00:06 <jfischoff> that would be bad
12:00:13 <jfischoff> hmm
12:00:56 <jfischoff> I like the restrictiveness of Foo <$> p1 <*> p2
12:01:12 <jfischoff> but I understand how foreign it is to new haskellers
12:01:22 <monochrom> jfischoff: I feel that "<*> vs do for readability" boils down to "more verbose vs less noise for readability"
12:01:44 <monochrom> err, I flipped it. "less noise vs more verbose for readability"
12:02:14 <jfischoff> I think you can mess things up with the do notation. Using a bound variable twice accidentally
12:02:33 <jfischoff> names open the door for more complicated code
12:02:47 <chrisdone> yeah, it's a pity do-notation is monad-specific
12:03:01 <monochrom> there are really people who say, "tmp1 = f(x) \n y = g(tmp1)" is more readable than "y = g(f(x))". there are really people who say "one concept per line"
12:03:44 <Fuuzetsu> Twey: the version with fmap is far nicer
12:03:53 <jfischoff> temporary variables do provide a way to document things
12:04:07 <chrisdone> jfischoff: we got something like: do Foo; p1; p2 or something when messing on reddit with RebindableSyntax. correct type, nice syntax
12:04:12 <jfischoff> but in general I don't use them
12:04:19 <chrisdone> trying to find the post
12:04:29 <jfischoff> ah
12:04:29 <monochrom> you will never be able to sell "f <$> a <*> b" to people who swear by tmp1
12:04:51 <jfischoff> yeah… your probably right
12:05:06 <chrisdone> here we go:
12:05:12 <banister> jfischoff: you're* ;)
12:05:28 <jfischoff> although I was one of the people back in my C++ days
12:05:29 <chrisdone> http://www.reddit.com/r/haskell/comments/16zrsp/generalizing_do_notation/c80wmfr
12:05:29 <applicative> goo = ap tmp1 b where tmp1 = fmap f a is a little strange...
12:05:41 <monochrom> anyway, I'm of the "readable means less noise" camp
12:05:48 <chrisdone> jfischoff: check that out ^
12:06:00 <jfischoff> banister: oh man, just be happy you can even parse anything I write ;)
12:06:03 <chrisdone> and see sjoerd's post beneath
12:06:21 <monochrom> I despise "readable means more verbose". I mock them. http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
12:06:40 <applicative> yes, it's nice, too bad we can't modify 'do' readily
12:06:41 <Twey> Fuuzetsu: It uses a function that doesn't exist, the same as my nicer one
12:06:56 <dEPy> what advantage does reader monad has over applicative?
12:06:57 <chrisdone> applicative: well those examples work and are usable at least
12:06:59 <jfischoff> chrisdone: No way man. Explaining how that works is not going to go well. ;)
12:07:14 <chrisdone> jfischoff: explaining to who?
12:07:28 <jfischoff> Non Haskell tech leads
12:07:29 <monochrom> i.e., to pay lip service to them, I just split "g(f(x))" into two lines, still denying them of the tmp1 they hug so much :)
12:07:36 <applicative> no I like it, somehow RebindableSyntax gives me errors, but maybe I'm not used to it
12:07:41 <chrisdone> jfischoff: oh, i was just talking to you, not your tech leads
12:07:45 <jfischoff> ah
12:08:25 <Twey> Fuuzetsu: And iterates p twice
12:08:32 <applicative> do let (>>) = (<>) ; "hello"; " " ; "world"
12:08:46 <jfischoff> Yeah I always tell people think of <*> as space…not sure that is better or worse
12:09:25 <mauke> do (>>) <- foo; bar; baz
12:09:28 <applicative> I suppose people have less to complain about with that, than with the blaze-html way
12:09:37 <applicative> which makes them complain about the wrong monad instance
12:09:39 <chrisdone> mauke: oh that's nice
12:10:04 <Twey> mauke: O.O
12:10:14 <mauke> do (>>=) <- foo; (>>=) <- bar; (>>=) <- baz; quux
12:10:19 <Twey> Oh gods
12:10:20 <elliott> mauke: you're fired
12:10:31 <chrisdone> do (>>) <- list; 1; 2; 3; 4
12:10:53 <chrisdone> oh: do (>>) <- list; 1; 2; 3; 4; [] -- needs the nil
12:11:40 <applicative> a foo bar baz = do (>>) <- foo; bar; baz
12:11:45 <applicative> has type
12:11:52 <applicative> a :: Monad m => m (t -> t1 -> m b) -> t -> t1 -> m b
12:11:58 <Twey> chrisdone: I ended up writing: extractPrefix p = uncurry ((>>) . guard) . (on (==) (map toUpper) p *** return) . splitAt (length p)
12:12:03 <Twey> Which I think is pretty neat
12:12:26 <Twey> (insofar as it can be without any non-stdlib functions)
12:12:26 <applicative> how often do I have m (t -> t1 -> m b)
12:12:36 <chrisdone> Twey: it's neat but i'd never want to read it in real code
12:12:52 <Twey> chrisdone: Why's that?  It's a pretty straightforward pipeline
12:13:10 <chrisdone> it depends if you spend all day golfing one-liners like a factor programmer
12:13:13 <S_J> I dont get Applicative: (<*>) :: f (a -> b) -> f a -> f b but hen how can it be implemented like: gs <*> xs = [ g x | g <- gs, x <- xs ] where both args are of teh same tume? and not f(a->b) and f a
12:13:41 <Twey> chrisdone: Eh, I'd write it as a two- or three-liner
12:13:52 <k00mi> Twey: (on (==) (map toUpper) p *** return), that's what you call a straightforward pipeline?
12:14:27 <merijn> S_J: Why do you think both arguments are of the same type?
12:14:30 <Twey> k00mi: Sure.  Compare the first element of the pair to p case-insensitively, wrap the second element
12:14:34 <chrisdone> and uncurry ((>>) . guard)
12:14:54 <chrisdone> Twey: funnily, i also wrote it using *** and then passing it to uncury with (>>)
12:15:05 <Twey> chrisdone: ((>>) . guard) pretty much your ‘ensure’ :þ
12:15:20 <Twey> (I called it ‘check’)
12:15:28 <chrisdone> yeah, a name is better
12:15:31 <Twey> s/pretty/is pretty/
12:15:49 <Twey> Yeah, but it's fairly obvious what it does if you're used to reading composition
12:16:22 <chrisdone> i can read it and figure it out yeah
12:17:07 <chrisdone> but it feels like a puzzle whose motivation is brevity over legibility
12:17:20 <chrisdone> i'm just glad i don't have to read the code of people who think pipelines are perfectly readable because they never publish anything =p
12:17:22 <Twey> The only thing that makes it a little less pretty is the tuple, but that's the price of splitAt
12:17:23 <Eduard_Munteanu> Say module B defines a data type and some functions which operate on it. Module A only needs the data declaration of that type, but A is imported by B. Do I really need the hsboot tricks for this?
12:17:38 <k00mi> Twey: I'd take some time to figure that out, splitting it in named parts just makes it clearer and hurts noone
12:18:01 <Twey> k00mi: Blame Fuuzetsu for that — he didn't want names in his helper function :þ
12:18:10 <Eduard_Munteanu> I mean A only needs to know about that type, it doesn't need anything else from B.
12:18:14 <Fuuzetsu> Twey: I didn't need any with a simple if then else
12:19:09 <Twey> k00mi: Hmn, though I don't think I'd bother naming that, either.  Not until I used it somewhere else, at least.
12:19:13 <chrisdone> Eduard_Munteanu: then put the type in a separate Types module?
12:19:42 <monochrom> or put the type in B.hs-boot
12:20:04 <Eduard_Munteanu> chrisdone: then I need to put a bunch of functions in that Types module, because it's supposed to be opaque
12:20:16 <monochrom> then put the type in B.hs-boot
12:20:28 <k00mi> Twey: my problem is probably that I'm not very familiar with the Arrow combinators
12:20:32 <Eduard_Munteanu> Hm, doesn't seem that bad, thanks.
12:21:19 * chrisdone . o O ( 'opaque' data types are kind of redundant in haskell )
12:21:28 <Eduard_Munteanu> But why doesn't GHC only look at the thing I'm importing?
12:21:42 <k00mi> anyways, I just discovered that Network.Socket.inet_addr fails for "255.255.255.255" which is a known problem since a couple of years
12:21:44 <chrisdone> it doesn't implement cyclic imports
12:21:48 * Eduard_Munteanu is just curious
12:21:51 <monochrom> demand-supply curve
12:21:58 <k00mi> is there a reason that hasn't been fixed?
12:22:05 <Eduard_Munteanu> Yeah, but it's not really a cycle, morally. :)
12:22:13 <Twey> k00mi: Aha. (***) is just a combination first and second: it lets you do things to both elements of a pair at the same time
12:22:27 <chrisdone> sure: the import is a cycle, the code dependency isn't
12:22:54 <Fuuzetsu> :t (***)
12:22:55 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:23:05 <chrisdone> welcome to arrows
12:23:06 <Eduard_Munteanu> I mean   import B(Foo)   isn't.
12:23:09 <Fuuzetsu> where ‘a’ is just ‘->’
12:23:52 <k00mi> Twey: I know, but I always have to brood over what those combinators mean when I see them in code
12:23:55 <Eduard_Munteanu> Anyway, I'll just do the boot thingy.
12:24:41 <simon> is there an operator that lets me do: f `op` g = \(x, y) -> (f x, g y)?
12:25:03 <Eduard_Munteanu> :t (&&&)
12:25:04 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
12:25:04 <k00mi> heh
12:25:19 <simon> cool, thanks :)
12:31:09 <merijn> no, &&& is wrong
12:31:12 <merijn> It's ***
12:31:36 <merijn> "(f &&& g) = \x -> (f x, g x)"
12:31:53 <supki> > f *** g $ (x, y) :: (Expr, Expr)
12:31:54 <lambdabot>   (f x,g y)
12:31:54 <Eduard_Munteanu> Err... oops.
12:31:54 <merijn> "(f *** g) = \(x, y) -> (f x, g y)"
12:32:36 <applicative> @pl a f g x = (f x , g x)
12:32:36 <lambdabot> a = liftM2 (,)
12:32:37 <Eduard_Munteanu> simon: ^
12:32:42 <supki> > f &&& g $ x :: (Expr, Expr)
12:32:42 <lambdabot>   (f x,g x)
12:33:20 <Eduard_Munteanu> :q
12:33:25 <applicative> > liftM2 (,) f g x :: (Expr, Expr)
12:33:26 <lambdabot>   (f x,g x)
12:33:30 <Twey> k00mi: You just read it like this: http://paste.pm/8b5.js
12:33:44 <Twey> I would like a reversed compose.  (>>>) seems a bit too long.
12:34:11 <applicative> there's not one in lens?  just & for flip ($) I guess
12:34:38 <FreeFull> > let (˙) = flip (.) in f ˙ g :: Expr
12:34:39 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
12:34:39 <lambdabot>              w...
12:34:43 <edwardk> we don't have flipped (.) just flipped ($)
12:34:51 <FreeFull> > let (˙) = flip (.) in f ˙ g
12:34:52 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
12:34:52 <lambdabot>    arising from a u...
12:35:06 <Twey> applicative: Any libraries outside base, Fuuzetsu is copying and pasting into his code.  I thought it best to keep package dependencies to a minimum.
12:35:09 <edwardk> you can get by with (<<<) and (>>>) and the like
12:35:11 <applicative> > let (˙) = flip (.) in (f ˙ g) x:: Expr
12:35:12 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:35:12 <lambdabot>    arising from a us...
12:35:15 <applicative> bah
12:35:28 <FreeFull> > (g . f) :: Expr
12:35:29 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
12:35:29 <lambdabot>              w...
12:35:33 <Twey> edwardk: Yeah, but that's three characters for a rather common operation
12:35:44 <FreeFull> applicative: Seems expr doesn't do function composition
12:35:46 <applicative> > (g . f) x :: Expr
12:35:46 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:35:46 <lambdabot>    arising from a us...
12:35:51 <Twey> I've used it from time to time, when I'm not doing a lot of them, but the notation is pretty heavy
12:35:51 <applicative> yeah
12:36:02 <FreeFull> Which is surprising
12:36:17 <edwardk> twey: hence why i never bothered to make up a shorter name. it already exists. it has the right precedence, and the 'lensy' way to do it is to be pointful and start a chain of &'s
12:36:18 <Eduard_Munteanu> Hrm, is this known?  ghc: panic! (the 'impossible' happened) (GHC version 7.4.2 for x86_64-unknown-linux): unbox_strict_arg_ty: not a product
12:36:19 <applicative> > g (f x) :: Expr
12:36:20 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
12:36:20 <lambdabot>    arising from a us...
12:36:24 <applicative> ah there
12:36:44 <Eduard_Munteanu> It chokes on that newtype I have in the boot file.
12:36:53 <applicative> > g (f (x ::Expr) :: Expr) :: Expr
12:36:54 <lambdabot>   g (f x)
12:36:55 <johnw> Eduard_Munteanu: can you show us the newtype?
12:36:56 <edwardk> and there aren't enough good operators of one or two character length to make another one that is just a repeat with all the same properties
12:37:35 <Eduard_Munteanu> johnw: newtype Color = Color Pixel    where   type Pixel = Word32
12:37:46 <johnw> <<< and >>> and no longer than <=< and >=>, and I don't mind those
12:38:17 <chrisdone> yeah but >=> is the same length as >>=
12:38:18 <johnw> can you show me where you're doing the case analysis on it?
12:38:22 <chrisdone> whereas >>> is massive compared to .
12:38:25 <johnw> true
12:38:36 <Twey> Yeah
12:38:49 <chrisdone> do we have lens in lambdabot?
12:38:51 <chrisdone> :t (&)
12:38:52 <lambdabot> Not in scope: `&'
12:38:55 <johnw> :(:(
12:39:03 <Eduard_Munteanu> johnw: I just pattern-match on it in a couple of functions, it's something in xmonad
12:39:05 <johnw> > let import Control.Lens
12:39:06 <lambdabot>   <hint>:1:5: parse error on input `import'
12:39:13 <johnw> @let import Control.Lens
12:39:14 <lambdabot>  .L.hs:38:1:
12:39:14 <lambdabot>      Control.Lens: Can't be safely imported!
12:39:14 <lambdabot>      The module its...
12:39:23 <monochrom> lambdabot has lens, just not sure which version
12:39:26 <chrisdone> ohhh
12:39:28 <Twey> Lens isn't safe?
12:39:32 <applicative> > let f % g = g . f in (+1) % (*2) % even $ 3
12:39:32 <lambdabot>   True
12:39:36 <chrisdone> so that's why lambdabot can do import, because it's using -XSafe? nice
12:39:43 <Twey> Yeah
12:40:07 <edwardk> elliott is working on fixing the import issue
12:40:16 * chrisdone . o O ( tho i suppose a lambdabot-base package could easily provide a restricted import list )
12:40:17 <edwardk> it appears to be a minor concern with Control.Lens.Action infecting other stuff
12:40:23 <Eduard_Munteanu> johnw: setBorderColor :: Window -> Color -> X ()    setBorderColor w (Color c) = withDisplay $ \d -> io $ setWindowBorder d w c
12:40:37 <johnw> huh, seems inoffensive enough
12:40:44 <elliott> yeah it turns out nobody uses safe haskell
12:40:49 <elliott> and it's been unusable for months
12:40:49 * applicative feels the contagion
12:40:59 <Eduard_Munteanu> johnw: funnily it happens while XMonad.ManageHook is compiling, which isn't using that at all
12:41:07 <johnw> plus, then we can write "/bin/rm -fr /" ^! act system
12:41:39 <applicative> It doesn't matter whether anyone uses -XSafe, we need it in arguments against trolls...
12:42:05 <Eduard_Munteanu> johnw: it's referred to in the module doing the SOURCE import, as a strict field for a datatype.
12:42:31 <Eduard_Munteanu>     , normalBorder  :: !Color        [...]
12:44:07 <Eduard_Munteanu> johnw: ghc doesn't panic anymore if I omit the '!'
12:44:20 <johnw> I'd make a bug on the Trac about that then
12:44:38 <S_J> is there a Monad combinator?
12:44:42 <Eduard_Munteanu> I will, thanks.
12:44:58 <Eduard_Munteanu> S_J: what do you mean by "combinator"?
12:45:00 <applicative> S_J: ?
12:45:14 <Eduard_Munteanu> I'm guessing it's about "combining" monads.
12:45:23 <Twey> Eduard_Munteanu: Oh, I see.
12:45:29 <applicative> oh, hm
12:45:30 <S_J> merijn: gs and xs, are they not both lists (referring to posts 10min ago)
12:46:08 <danharaj> oh my god
12:46:13 <danharaj> ghci has tab completion???
12:46:24 <applicative>  gs <*> xs = [ g x | g <- gs, x <- xs ]
12:46:24 <chrisdone> yeah…
12:46:24 <aristid> danharaj: it does!!!
12:46:33 <applicative> S_J:  they are both lists ^^
12:46:43 <johnw> S_J: one is a list of functions, the other a list of arguments to those functions
12:46:48 <applicative> S_J: gs is a list of functions, xs is a list of arguments
12:46:57 <applicative> as johnw says
12:46:58 <aristid> chrisdone: i never figured out how to use the ghci tab completion inside emacs :P
12:47:03 <johnw> as applicative says :)
12:47:33 <tij_> what is the best way to modify a cell of a list?
12:47:42 <applicative> S_J: maybe the problem is, that this is just the implementation of <*> for lists only?
12:47:47 <johnw> tij_: by creating a new list with that cell onwards replaced
12:47:49 <chrisdone> aristid: there wasn't any… tho hvr has patched ghci in HEAD and made a ghci wrapper that provides a :complete command with which the latest haskell-mode can tab complete
12:47:55 <merijn> S_J: Yes, but they're not lists with the same type of element inside
12:48:09 <tij_> johnw: so take everything before position, modify position, and take everything after position?
12:48:27 <johnw> tij_: yes; everything after the mutated cell will be copied, everything before will be shared
12:48:41 <aristid> chrisdone: oh nice
12:49:00 <aristid> chrisdone: that won't hit 7.8 though, will it?
12:49:03 <tij_> johnw: ok that's what I'm doing currently
12:49:11 <johnw> > let (x,y) = splitAt 3 [1,2,3,4,5] in init x ++ [6] ++ y
12:49:12 <lambdabot>   [1,2,6,4,5]
12:49:25 <johnw> tij_: note that there are other data structures, depending on what kind of semantics you need
12:49:31 <chrisdone> aristid: no idea
12:49:55 <tij_> johnw: i'm writing a brainfuck interpreter, so I need to move around the array and modify individual positions
12:50:01 <chrisdone> aristid: fwiw: http://hackage.haskell.org/package/ghci-ng
12:50:17 <aristid> chrisdone: nice
12:50:58 <robde> hello. how come (!!) is not :: [a] -> Maybe a? and one more question: isn’t exception as bad as null in imperative languages?
12:51:20 <merijn> robde: Historical reasons, same way head is not "[a] -> Maybe a"
12:51:23 <robde> * [a] -> Int -> a
12:51:23 <merijn> robde: Yes, it's terrible
12:51:27 <Eduard_Munteanu> robde: (!!) is a bad idea, yeah
12:51:29 <johnw> > [1,2,3,4,5] & ix 2 .~ 6
12:51:30 <lambdabot>   Not in scope: `ix'
12:51:31 <lambdabot>  Perhaps you meant one of these:
12:51:31 <lambdabot>    `id' (imported from ...
12:51:33 <johnw> that's a bit easier, syntax-wise
12:51:35 <merijn> @quote beware
12:51:35 <johnw> if you are using lens
12:51:36 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
12:51:45 <Lethalman> ha! can't use cabal glib :-( http://paste.debian.net/15923/
12:51:46 <geekosaur> but partially it's because using (!!) is not a good idea anyway
12:51:49 <Lethalman> hints? ^^
12:51:50 <johnw> tij_: maybe use a mutable vector then?
12:52:07 <johnw> robde: "find" is the safe version of !!
12:52:20 <Lethalman> ghc --version is 7.6.3
12:52:28 <Lethalman> while cabal --version is 1.17
12:52:36 <Lethalman> maybe that's the problem, I have too recent cabal uhm
12:52:37 <chrisdone> always distrust a function whose name consists of shouting
12:52:44 <johnw> Lethalman: fix the Setup.hs file
12:52:54 <johnw> Lethalman: send back a patch :)
12:53:30 <Lethalman> johnw, but I believe I have something messed up
12:53:37 <Twey> robde: It's quite rare that you want to be using (!!).  Lists are designed for forward-iterating, not random-access.
12:53:54 <Lethalman> for example, cabal install cabal-install gives me: http://paste.debian.net/15924/
12:53:58 <Twey> robde: head likewise.  You probably just want to pattern-match.
12:53:59 <Lethalman> it's because I have too recent cabal
12:54:01 <Lethalman> how do I downgrade?
12:54:06 <johnw> !! is sort of just as bad as fromJust
12:54:44 <Lethalman> :t find
12:54:45 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:54:46 <Lethalman> :t (!!)
12:54:47 <lambdabot> [a] -> Int -> a
12:54:53 <johnw> ah, sorry
12:55:07 <Lethalman> @hoogle [a] -> Int -> Maybe a
12:55:08 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:55:08 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:55:08 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
12:55:10 <johnw> the safe package defines atMay
12:55:15 <johnw> [a] -> Int -> Maybe a
12:55:18 <Lethalman> @hoogle atMay
12:55:18 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:55:18 <lambdabot> Test.QuickCheck.Gen suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
12:55:18 <lambdabot> Test.QuickCheck suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
12:55:20 <johnw> also, lens has ^?
12:55:24 <johnw> [1,2,3] ^? ix 5
12:55:36 <Lethalman> any idea how I can downgrade my cabal? :P
12:56:01 <applicative> Lethalman: ghc-pkg unregister Cabal-1.17 or something
12:56:01 <johnw> Lethalman: unregister Cabal and cabal-install, download the current release tarball, bootstrap it
12:56:05 <chrisdone> if you use NonEmpty (lists) then you can use `extract' as a total `head'
12:56:07 <S_J> ok so i get how to implement Applicative now but i have a hard time envisioning the use. When would I for exmaple have (Just function) ? or maybe Maybe isnt what I should focus on, is IO more applicable for Applicative? :)
12:56:44 <johnw> S_J: Applicative are almost always more useful than you think they are :)
12:57:02 <applicative> > (+) <$> Just 1 <*> Just 2
12:57:03 <Lethalman> applicative, johnw unregistered but cabal --version still gives 1.17
12:57:03 <lambdabot>   Just 3
12:57:11 <Taneb> S_J, parsers are a great example of why Applicatives are useful
12:57:11 <johnw> Lethalman: unregistering doesn't delete the ibnary
12:57:16 <Lethalman> mh
12:57:17 <johnw> that's why I said to bootstrap from the release tarball
12:57:32 <applicative> Lethalman: ghc-pkg list Cabal
12:57:39 <applicative> Lethalman: what does it say
12:57:40 <Lethalman> weirdly enough, I'm now able to do cabal install cabal-install
12:57:47 <Lethalman> probably it's using cabal 1.17 binary with 1.16 library :P
12:57:59 <applicative> cabal-1.17, if it's built, can build cabal-1.16
12:58:08 <Lethalman> alright now I got cabal 1.16
12:58:10 <Lethalman> thanks
12:58:20 <S_J> And Applicative makes no sense for a Matrix...right?
12:58:24 <chrisdone> all applicatives seem to be parsers, forms, commandline, basically digestive functors. i don't think i've seen an interesting applicative that isn't
12:58:39 <johnw> chrisdone: have you seen the fuzzcheck code I wrote?
12:58:45 <applicative> S_J: a 'zip' applicative would make sense
12:58:49 <johnw> there is a nice use of applicative there which doesn't fit that list
12:58:54 <chrisdone> johnw: is it also a monad? =p
12:58:57 <johnw> no
12:59:02 <johnw> and it can't be, in fact
12:59:31 <johnw> i use an applicative writer to capture the "show" of every argument being passed to a function call, so that when it throws an exception I can show you what the call looked like at runtime
12:59:56 <johnw> (up to the argument that threw an exception, if that happens during argument evaluation)
13:00:30 <johnw> anyway, Applicatives form an algebra of their own, with products, sums, etc., which Monads do not (and hence all the monad transformer complexity)
13:00:57 <johnw> so, unless you need the specific semantics of a Monad, Applicatives can offer much more flexibility
13:01:16 <hvr> aristid, chrisdone: fyi, the :complete command patch has been merged in GHC HEAD already
13:01:41 <hvr> so yes, it's part of GHC 7.8 unless somebody takes it out again
13:01:43 <Saizan> x/
13:02:02 <aristid> hvr: nice
13:02:41 <hvr> and ghci-ng is not a wrapper but rather a ghci drop-in replacement w/ backported features
13:04:47 <hvr> This one's e.g. will be available in ghci-ng too: http://ghc.haskell.org/trac/ghc/ticket/8047
13:09:07 <S_J> If someonse answered before I can't find it, so I'll reask. What is the state of haskell on Heroku these days?
13:09:36 <johnw> @google Haskell Heroku
13:09:37 <lambdabot> Plugin `search' failed with: user error (https not supported)
13:14:32 <cads> RichiH: My thoughts are a site would be very simple to implement/deploy, and would give new VCSH users a good place to collect some basic materials.
13:14:35 <NemesisD> i just had a thought: couldn't using monoid on a sum type pretty much give you a state machine with an initial state of mempty?
13:15:31 <merijn> chrisdone: In FRP behaviors and events are Applicative and they're not digestive functors
13:16:01 <NemesisD> hmm maybe not, i don't think you could handle unsupported transitions
13:17:27 <NemesisD> handle via silence i guess: FinalState `mappend` NonFinalState = FinalState
13:17:46 <RichiH> cads: maybe i should do something like git-annex does and compile docs/ straigth to www
13:17:49 <Lethalman> oh yeah guys, ghc-mod in emacs is awesome
13:17:56 <cads> RichiH: A simple horizontal menu, linking to 3 pages.  1. Frontpage: introduce vcsh and sketch the use case (derived from current readme) 2. Media page: structure available lectures and lecture slides (derived from existing talks) 3. Faq page: help kill the most annoying/repetitive questions you currently get about it. The page can also link interested parties directly to the project's Issues engine, and invite them to fork it.
13:18:43 <Sonarpulse> I was looking at endianness-related packages and found them all lacking
13:18:51 <BMeph> cads: ...or, to go fork themselves? ;)
13:18:53 <Sonarpulse> so i forked one and made https://github.com/Ericson2314/data-endian
13:19:00 <Sonarpulse> what do you all think?
13:20:22 <merijn> Sonarpulse: You're still using the same package name and the cabal file refers to the original sites, might wanna fix that
13:20:27 <cads> RichiH: yeah, Github's project pages allow you to use Jekyll to maintain a set of markdown file pages, which get rendered into a project page. This is one I put up to provide a comfortable project gateway for myself for mysel - I want to say I spent all of ten minutes on it http://maxsu.github.io/socrates/
13:20:35 <Sonarpulse> merijn: yeah I will
13:20:56 <Sonarpulse> but just wondering if you guys thought it was different enough to merit Yet Another endianness package
13:21:52 <Sonarpulse> Also, I read about http://ghc.haskell.org/trac/ghc/ticket/7902 I hope my package could provide a high-level interface over that
13:23:41 <cads> RichiH: Page development happens in a branch called gh-pages (example: https://github.com/maxsu/socrates/tree/gh-pages ). If you use jekyll the page dev happens in basic markdown, so it's very easy to accept pull requests to your gh-branch.
13:24:29 <zvrba> merijn: any idea why this code http://pastie.org/8137946 returns different result in ghci and ghc?
13:24:45 <zvrba> merijn: in particular, the check 1 case; it never returns true
13:24:54 <RichiH> cads: github pages don't allow direct editing, though
13:24:58 <zvrba> (when run in ghc)
13:25:00 <RichiH> at most, you can send pull requests
13:25:17 <zvrba> i'm solving this: http://www.reddit.com/r/dailyprogrammer/comments/1heozl/070113_challenge_131_easy_who_tests_the_tests/
13:25:29 <zvrba> the test example gives correct result in ghci, but not in ghc
13:27:59 <merijn> RichiH: They do now!
13:28:28 <merijn> Unless I misunderstood your comment
13:28:42 <cads> RichiH: right, you would retail control over the RichiH.github.io/vcsh page. Other project page systems like dokuwiki allow content editing, but have to be hosted separately.
13:29:14 <cads> communal content editing, I should say
13:29:14 <merijn> zvrba: ooh, I have a sneaky suspicion
13:29:22 <zvrba> please do tell!
13:30:50 <robstewartuk> hi, I'm wondering if someone could replicate the following compilation error..
13:30:53 <robstewartuk> $ cabal install atomic-primops
13:30:57 <merijn> zvrba: Try running this paste in ghc and ghci, then paste the output: http://lpaste.net/90879
13:31:11 <robstewartuk> $ ghci
13:31:25 <robstewartuk> % Prelude> :m Data.Atomics
13:31:37 <robstewartuk> Prelude Data.Atomics> writeBarrier
13:32:00 <robstewartuk> Loading package atomic-primops-0.2.2 ... linking ... <interactive>: ~/.cabal/lib/atomic-primops-0.2.2/ghc-7.6.3/HSatomic-primops-0.2.2.o: unknown symbol `cas'
13:32:17 <merijn> robstewartuk: Which OS/arch are you on?
13:32:26 <robstewartuk> Ubuntu 64bit
13:32:37 <cads> RichiH: anyway, the reason I mention all this is that I'm learning about github's pages, and I'd like to put together a site for the VCSH project as a learning / portfolio piece.
13:33:11 <robstewartuk> i.e. can someone install `atomic-primops`, load Data.Atomics, and try using any of the functions, to invoke the link attempt?
13:33:19 <robstewartuk> and - are you successful?
13:34:08 <RichiH> merijn: oh, ok?
13:34:13 <merijn> robstewartuk: The problem seems to be that your linker can't find the compiled symbols
13:34:31 <merijn> RichiH: i.e. github allows on-site editing of files now
13:34:33 <robstewartuk> ok, how do I point ghci at them?
13:34:44 <RichiH> merijn: neat
13:35:14 <robstewartuk> merijn: just checked out your github. you at HWU??
13:35:48 <cads> RichiH, merijn, I know there are tools like prose.io http://prose.io/
13:35:58 <merijn> robstewartuk: Yeah
13:36:21 <robstewartuk> me too.
13:36:25 <RichiH> cads: that sounds very interesting... as i said, i did consider going the git-annex way, i.e. having doc/ as a subdirectory in master. that has the advantage of retaining all comments etc in the same place, thus allowing you to package that along with everything else and putting it into debian, etc
13:36:39 <merijn> RichiH: I can't find the link atm, but just recently there was a blog post discussing the ability to edit files directly on github
13:38:05 <robstewartuk> merijn: are you able to reproduce my 3 steps, by any chance?
13:40:00 <cads> RichiH: these guys have been using github pages and jekyll to build blogs and even web services with very low server side footprint: http://developmentseed.org/blog/2012/07/27/build-cms-free-websites/
13:40:44 <RichiH> cads: you are _more_ than welcome to clone vcsh and start playing with this
13:41:14 <zvrba> merijn: ok, mistery solved. the executable didn't finish properly (it hung in the background), so newer versions of the exe-file didn't get overwritten by recompilation
13:41:28 <merijn> zvrba: >.>
13:41:28 <zvrba> merijn: so old, buggy code was constantly getting executed.
13:41:37 <RichiH> cads: i can not promise as of right now that i will use it as i am more familiar with ikiwiki and like the ability to do stuff in the same source tree; but even if that would not be used, the _content_ would be _very_ useful in any case
13:41:40 <augur> eeeee
13:41:45 <augur> oplss 2013 in like a week!
13:41:51 <zvrba> found out when I tried to run the program from cmd and found it had an old timestamp >:
13:42:06 <RichiH> cads: also, if you enjoy writing tests for shell scripts, i have endless thanks to shower you with ;)
13:42:15 <monochrom> robstewartuk: yes, it happens here too
13:42:22 <zvrba> merijn: but thanks for bothering to look :)
13:42:23 <merijn> robstewartuk: I haven't tried, but I'm on an entirely different OS + architecture, so I'm not sure whether any results would be relevant
13:42:32 <robstewartuk> monochrom: oohh.
13:42:59 <robstewartuk> are you using a distro packaged ghc, or your own build?
13:43:29 <monochrom> my own
13:43:35 <robstewartuk> me too.
13:44:12 <cads> RichiH:  Sure. On my side, I can't promise results that you'll be thrilled with, and will understand if you thumbs down the final result. The content will be published under VCSH's same GPL 2 license, so you will be more than welcome to use it in any form you desire.
13:44:17 <robstewartuk> monochrom: any clue how to fix it?
13:44:47 <monochrom> no
13:46:57 <cads> RichiH: haha, like many topics, I'm relatively ignorant of shell scripts, though I'm forced to struggle with them on occasion
13:48:51 <b2coutts> does the halting problem suggest that there exist programs where we have no idea if they will halt or not?
13:49:06 <johnw> right
13:49:18 <b2coutts> are there simple/interesting examples of such programs?
13:49:35 <johnw> there is also another problem which states that you can't determine if an algorithm is the optimal solution to a problem either
13:50:00 <b2coutts> it seems interesting to me that we've written code where we cannot tell if it will halt or not
13:50:04 <elliott> b2coutts: e.g. a program which searches for goldbach conjecture counterexamples
13:50:40 <b2coutts> elliott: oh, interesting
13:51:43 <RichiH> cads: on the plus side, both jekyll and ikiwiki compile markdown
13:51:44 <b2coutts> is the goldbach conjecture's truth provably undecidable? if not, is there a program that it is provably unknowable whether or not it halts?
13:51:50 <RichiH> so that'll work for both
13:52:02 <Sonarpulse> Agda AFIAK forces you to write programs that are proven to terminate
13:52:30 <Sonarpulse> I once heard someone talk of some system where "non-termination" was designated an effect type
13:52:35 <b2coutts> Sonarpulse: weird, does that mean it isn't turing complete?
13:52:42 <elliott> no
13:52:55 <elliott> you can write a brainfuck interpreter in agda, because of codata.
13:52:58 <Ralith> idris has totality annotations
13:53:11 <merijn> b2coutts: It's not turing complete in the same sense that haskell can't do IO
13:53:17 <Sonarpulse> ^ interesting, I read the idris tutorial
13:53:21 <Ralith> you can write code that must terminate, and code that may not, and it's all checked (conservatively)
13:53:23 <Sonarpulse> great introduction to dependant tpyes
13:53:42 <Sonarpulse> Ralith: agda, idris, or both?
13:53:49 <Ralith> Sonarpulse: idris
13:53:54 <b2coutts> ah
13:54:07 <Ralith> idris has codata and productivity checking too
13:54:15 <Ralith> so you can go whichever route
13:54:47 <Sonarpulse> but agda has codata too, according to elliot, so it sounds like they both have optional non-termination
13:54:50 <Sonarpulse> sounds best to me
13:55:00 <Ralith> codata is different tha noptional non-termination
13:55:58 <Sonarpulse> how so? this is the first time I have heard of "codata"
13:56:27 <Ralith> then it might be easiest to just read up on it
13:56:31 * Ralith needs to get to the store
13:56:32 <Sonarpulse> alright
13:56:48 <Ralith> the important notion is productivity checking versus totality checking versus no checking
13:56:56 <Sonarpulse> ok
13:57:32 <Ralith> idris lets you have all of them; I believe agda only offers the first two, though you should verify this with an agdaer
13:57:36 <Ralith> an agdite?
13:57:46 <Sonarpulse> ha, ok
13:57:51 <cads> RichiH: Feel free to shoot me a sketch of ideas of what you'd like to see on the site. Once the basic site is in form, we can chat about how it works, what might need to be revised and added. When I'm done, I can had the site over.
13:57:58 <dolio> You can turn off the checkers in Agda.
13:58:01 <Sonarpulse> do you all think agda, idris, (and epigram) now is like miranda, haskell, and typedML back in the day?
13:58:03 <cads> RichiH: I look forward to contributing to VCSH!
13:58:03 <hpc> Ralith: agda has a flag to turn it off entirely
13:58:11 <Ralith> hpc: but not selectively?
13:58:16 <hpc> Ralith: the choice is either (the first two) or (none at all)
13:58:18 <dolio> You can turn it off per-function.
13:58:26 <Sonarpulse> IE, eventually we will combine the best of these dependant-typed languages into one?
13:58:28 <hpc> you can?
13:58:38 <Ralith> can you call unchecked-totality functions from checked-totality functions?
13:58:59 <dolio> Yes.
13:59:13 <hpc> in any event, i am not sure how much sense it makes to have only one or the other turned off
13:59:15 <Ralith> idris disallows that (unless you explicitly assert totality)
13:59:21 <Sonarpulse> I would LOVE to see GHC replcace system F with some dependantly typed thing, and then have haskell & "winning" depdantly-typed langauge in a kinda java-scala relationship
13:59:51 <Sonarpulse> (already feel mean for comparing Java to Haskell)
14:00:02 <elliott> I think that wish underestimates how different dependently-typed programming is.
14:00:12 <Ralith> the purpose is to admit nontotal code but to make it hard to use it unless you really mean to
14:00:25 <Sonarpulse> elliott: I read though the idris intro
14:00:38 <hpc> Sonarpulse: so far it seems the fight is between idris and agda
14:00:42 <Sonarpulse> it sounded like it's a complete semantic superset
14:00:45 <Sonarpulse> of haskell
14:00:49 <Ralith> Sonarpulse: idris is strict
14:01:03 <elliott> Idris is conservative as dependent langauges go, but even then...
14:01:14 <Sonarpulse> good point, but it lazyness annontation
14:01:17 <Ralith> conservative? really?
14:01:23 <Ralith> how's that?
14:01:29 <elliott> sure, compared to Agda or such.
14:01:34 <elliott> it cares more about practicality.
14:01:36 <hpc> idris seems to be quite deliberately trying to be hard to write proofs with
14:01:38 <dolio> Have you read it's mission statement?
14:01:41 <Ralith> I'm not sure I'd call that conservative
14:01:42 <elliott> than being as fancy as possible.
14:02:07 <Ralith> you might well call agda more conservative for not targeting practicality overtly
14:02:07 <Lethalman> I'm looking at gio FileEnumerator
14:02:17 <Lethalman> basically, you call fileEnumeratorNext to get the next Maybe FileInfo
14:02:18 <dolio> At one point there was a big mention of "we're not solving any research problems."
14:02:24 <Lethalman> I'd like to turn this into some enumerator
14:02:28 <Lethalman> then I found the enumerator hackage
14:02:29 <Ralith> dolio: that's nonsense
14:02:31 <Lethalman> and lost :P
14:02:33 <Sonarpulse> IMO both haskell and idris should maybe have ! -> mandatory strict, ? -> mandatory lazy, unspecified as some default
14:02:35 <johnw> Lethalman: are you aware of filesystem-conduit?
14:02:38 <Ralith> dolio: most of idris's TODO list is research problems :P
14:02:43 <Lethalman> johnw, eek no, let me see
14:02:43 <Ralith> though perhaps not the biggest ones available
14:02:51 <johnw> enumerator is kind of old, I believe
14:03:14 <Sonarpulse> idris did seem more practical
14:03:27 <Sonarpulse> but this IS dependant types we are talking about, so I don't mind
14:03:30 <Ralith> hpc: what about idris feels obstructive wrt. proofwriting to you?
14:03:31 <Lethalman> johnw, traverse seems to do it hierarchically, I just one a single directory
14:03:46 <johnw> Lethalman: ah, then just listDirectory from system-fileio
14:03:53 <hpc> Ralith: it's turing-complete by default
14:04:03 <Lethalman> johnw, what's wrong with enumerator?
14:04:10 <Ralith> hpc: you mean it admits non-total definitions by default?
14:04:17 <johnw> Lethalman: I think it's just old, and lacks the large ecosystem of either conduit or pipes
14:04:19 <hpc> same thing :P
14:04:24 <Lethalman> ah
14:04:39 <johnw> so, if you're going to invest time in learning an iteratees/enumerators library, pick one that will pay off in future
14:04:50 <Ralith> hpc: that's just because the totality checker's really slapdash right now. If you were to contribute a more reliable/complete revision of it, I expect edwinb could be talked into changing the default ^^
14:04:54 <Lethalman> johnw, listDirectory does it all at once, I wanted some incremental thing due to huge directory listings
14:04:56 <johnw> I use conduit all over the place in my work
14:05:20 <Ralith> hpc: and honestly, putting '%default total' at the head of your file or applying the corresponding command line parameter is not hard.
14:05:25 <hpc> Ralith: i like it off by default; it's the only dependently typed language i have seen work that way
14:05:31 <Lethalman> I believe I could just do repeat
14:05:41 <Lethalman> repeat someIOAction
14:06:00 <hpc> and it makes a lot more sense for a language that has the goal of being useful for writing practical programs
14:06:00 <Lethalman> then I get an [IO File]
14:06:11 <johnw> Lethalman: there's another option
14:06:18 <Lethalman> but that's just unsafe
14:06:21 <johnw> just copy the source for "traverse" from filesystem-conduit, and change it to not be recursive
14:06:25 <johnw> it's a fairly simple function
14:06:28 <hpc> as opposed to agda's totality-by-default and (in the nicest way possible) academic-masturbatory standard library
14:06:28 <Ralith> hpc: oh, well, I write most of my code with '%default total' because the vast majority of my code generally passes even those weak totality checks, and it's really good at detecting some of the errors I tend to make
14:06:45 <Ralith> hpc: I don't really think the default matters much so long as both options are available.
14:07:04 <Ralith> s/weak/conservative/
14:07:17 <elliott> at least Agda's strings are unicode.
14:07:24 <hpc> i think picking a good default is even more important than even having the option available
14:07:32 <Lethalman> johnw, mh don't know.... I have  nextFile :: IO (Maybe FilePath)
14:07:38 <Ralith> hpc: why?
14:07:43 <Ralith> elliott: idris's strings are more or less TODO :P
14:07:44 <johnw> Lethalman: ok
14:07:52 <Lethalman> do you think it's suitable for conduit?
14:07:59 <Lethalman> I don't know, I can just stick with it, or do some cool things with it
14:08:00 <johnw> Lethalman: completely
14:08:06 <elliott> Ralith: languages don't really get any time to get strings right these days...
14:08:15 <johnw> Lethalman: a conduit source is really just a function that calls "yield", just like Python's generators
14:08:19 <hpc> because if you add up enough '%default total' flags and {-# LANGUAGE #-} and {-# OPTION #-} and what have you, it starts to look a lot like the top of a .cpp file
14:08:27 <johnw> and likewise, a sink just calls await
14:08:28 <Ralith> elliott: got a writeup on 'how to do strings Right' anywhere I can stick in my notes?
14:08:36 <johnw> and a pipe does both
14:08:38 <elliott> Ralith: nope. maybe that ancient joel spolsky piece.
14:08:41 <Lethalman> johnw, completely what, use conduit with that function? think it's worthwhile?
14:08:47 <Ralith> elliott: oh, well, I'm well familiar with that
14:09:02 <elliott> Ralith: it's always going to come down to a big list of Things That Are Wrong more than advice on what to do right.
14:09:04 <johnw> Lethalman: it depends on whether you want to do "stream" style processing with the file paths that come out of that function
14:09:18 <Ralith> I do care about proper string support, it's just that there's so much more important stuff to work on first.
14:09:25 <johnw> for example: getFiles "somedir" $$ CL.mapM_ print
14:09:27 <johnw> that kind of thing
14:09:34 <johnw> (where CL is Data.Conduit.List)
14:09:35 <aristid> johnw: i wonder if it would be possible to change all of conduits for a thin glue layer on top of pipes 4.0 :P
14:09:44 <johnw> there is a pipes-conduit pacakge
14:09:56 <Lethalman> mh ok
14:09:59 <Lethalman> will look at thos
14:10:10 <Ralith> hpc: I generally find that far more of my code is total than not, so defaulting to totality minimizes that :P
14:10:25 <Ralith> hpc: regardless, totality is available as a declaration-level specifier as well.
14:10:28 <Lethalman> thanks :-)
14:10:53 <johnw> Lethalman: have you done any Common Lisp?
14:10:59 <aristid> now i can't decide between storable and unboxed vectors :D which are better?:)
14:11:04 <Lethalman> johnw, no
14:11:25 <aristid> (i suppose it depends on the circumstances, but which)
14:11:37 <johnw> Lethalman: I was going to say that conduit is lot like a vastly simpler to use version of the SERIES library (due to Haskell's laziness by default), but I guess the analogy would be lost here :)
14:12:26 <Lethalman> or... given a IO (Maybe a) get a Stream a
14:12:27 <Lethalman> that is
14:12:50 <johnw> well, a Source IO a
14:12:52 <Lethalman> @hoogle m (Maybe a) -> m (Stream a)
14:12:52 <lambdabot> Did you mean: m (Maybe a) -> m IODeviceType
14:12:52 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
14:12:52 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => (forall d. Data d => c (t d)) -> Maybe (c a)
14:13:06 <Lethalman> johnw, whatever, is that something easy to do?
14:13:10 <johnw> trivial
14:13:22 <johnw> look at the source code for "traverse" in filesystem-conduit
14:13:25 <Lethalman> guess so, I mean is there some one-line helper :P
14:13:33 <Lethalman> johnw, looking at it
14:13:43 <johnw> using conduit is a *lot* like writing generator/iterator based code in Python
14:13:49 <johnw> i mean, it feels like almost the same thing sometimes
14:13:55 <johnw> I think pipes is the same way
14:14:01 <johnw> (I just haven't written any real code with pipes yet)
14:14:46 <Lethalman> ok so I do liftIO $ nextFile
14:15:08 <Lethalman> case nextFile of Nothing -> return (); Just x -> yield x ?
14:15:19 <johnw> forM_ (liftIO nextFile) yield
14:15:26 <johnw> wait
14:15:32 <Lethalman> eh, Maybe :-)
14:15:34 <johnw> om forM_ (liftIO nextFile) yield
14:15:43 <johnw> where om m f = (m >>=) . flip f
14:15:47 <johnw> using chrisdone's cool new combinator
14:15:52 <Lethalman> ah, om is what I call partialM :-)
14:16:08 <Lethalman> cause it looks like partial application
14:16:20 <Lethalman> :t \m f = (m >>=) . flip f
14:16:20 <lambdabot> parse error on input `='
14:16:24 <Lethalman> :t \m f -> (m >>=) . flip f
14:16:25 <lambdabot> Monad m => m a1 -> (a1 -> a -> m b) -> a -> m b
14:16:31 <Lethalman> see... doesn't look like so?
14:17:46 <johnw> hmm.. did I mess something up
14:18:18 <johnw> :t \m f x -> m >>= \y -> f y x
14:18:19 <lambdabot> Monad m => m a -> (a -> t -> m b) -> t -> m b
14:18:26 <johnw> no, that's right
14:18:45 <Lethalman> johnw, it was right, you just flipped the params
14:18:52 <Lethalman> :t \f m = (m >>=) . flip f
14:18:53 <lambdabot> parse error on input `='
14:18:56 <Lethalman> :t \f m -< (m >>=) . flip f
14:18:57 <lambdabot> parse error on input `-<'
14:18:58 <Lethalman> sigh
14:19:02 <Lethalman> :t \f m -> (m >>=) . flip f
14:19:02 <lambdabot> Monad m => (a1 -> a -> m b) -> m a1 -> a -> m b
14:19:06 <Lethalman> that's it
14:19:09 <johnw> you want \m f
14:19:15 <johnw> so that you can say: om when True $ do ...
14:19:23 <johnw> so that you can say: om when (return True) $ do ...
14:19:25 <Lethalman> right
14:19:50 <johnw> my suggestion to chrisdone is that we define nom = flip om
14:20:16 <Gracenotes> I thought that's what the operator was on first seeing the name
14:20:32 <Lethalman> I'd call it partialM though
14:20:39 <Lethalman> what's the sense of om
14:20:40 <johnw> partialM is an annoyingly long name
14:20:43 <FreeFull> om nom nom nom nom
14:20:47 <Lethalman> :(
14:20:47 <johnw> om when instead of whenM, etc.
14:20:53 <johnw> partialM when would just bug me
14:20:58 <Gracenotes> like, some combinator C (perhaps type-level) where C x = C, and then without the n?
14:21:20 <supki> partialM sounds like it's partial
14:21:25 <johnw> right, that too
14:21:47 <johnw> "partialM x" sounds like "this monadic action may not complete"
14:23:58 <merijn> argh
14:24:06 <merijn> I found an odd case
14:24:07 <Sonarpulse> did github get rid of git:// urls? I am makign a package for hackage
14:24:17 <Sonarpulse> and wondering what I should do for the repo URL
14:24:22 <Sonarpulse> (the endianness package)
14:24:35 <johnw> git:// still works
14:24:40 <johnw> they just default to https:// now
14:24:44 <johnw> since that can support both
14:24:46 <merijn> Where I get a type error if I have an expression directly in another, but it compiles when I move the expression to a named/typed expression
14:24:48 <johnw> (read-only and read-write)
14:25:36 <Saizan> can you use the new emacs haskell mode simply to load files, rather than having to make a cabal project?
14:25:44 <aristid> johnw: i hate the new github clone url interface.
14:25:50 <johnw> Saizan: how do you mean?
14:26:05 <Sonarpulse> should I use git:// then?
14:26:07 <johnw> Saizan: inf-haskell.el lets you use a dumb ghci and just load code into it, if that's what you mean
14:26:30 <johnw> Sonarpulse: I would prefer that, personally
14:26:49 <johnw> https:// URLs constantly ask me for my username and password, since I haven't put that info anywhere that git can see it
14:27:29 <Saizan> johnw: i've found that my old haskell-mode configuration doesn't work anymore, i'm trying to recover that
14:27:39 <johnw> Saizan: ah, yeah, lots has changed
14:27:48 <johnw> what did you use to invoke which doesn't work anymore?
14:27:58 <Sonarpulse> going with it!
14:28:58 <hpc> holy crap, the new clone UI is so annoying
14:29:09 <Lethalman> I often encounter this flow
14:29:10 <Saizan> johnw: (load "haskell-site-file") and then something like (add-hook 'haskell-mode-hook 'simple-indent)
14:29:14 <Lethalman> have an IO (Maybe a)
14:29:16 <johnw> hpc: send them feedback
14:29:16 <hpc> it even requires allowing fastly.net javascript in order to work
14:29:21 <Lethalman> and a function a -> IO b
14:29:27 <johnw> hpc: they've fixed a few things for me recently in their new UI stuff
14:29:42 <Lethalman> then I'd like IO (Maybe a) -> (a -> IO b) -> IO (Maybe b)
14:29:43 <johnw> Saizan: ah.  I think it's haskell-autoloads now or something
14:30:00 <Lethalman> is there anything already or should write my function to do this?
14:30:06 <Saizan> johnw: yeah, found that, i guess i just need to trim down the example configuration to something more standard
14:30:26 <johnw> Lethalman: you can use fmap
14:30:36 <Lethalman> johnw, not really, I'd get IO (IO ...)
14:30:41 <Lethalman> then join etc.
14:30:54 <johnw> :t fmap f <$> (return (Just 10) :: IO (Maybe Int))
14:30:55 <lambdabot> FromExpr b => IO (Maybe b)
14:31:00 <Gracenotes> Lethalman: that's >>=, not fmap
14:31:25 <johnw> where f there is Int -> b
14:31:30 <Gracenotes> well, also, fmap Just gets you from IO b to IO (Maybe b)
14:31:48 <johnw> do fmap f =<<, if f is Int -> IO b
14:32:00 <johnw> wait, no that doesn't work
14:32:11 <Lethalman> johnw, but I have Int -> IO b
14:32:13 <monochrom> robstewartuk: "cabal unpack atomic-primops" then see DEVLOG.md, it discusses what the author knows so far
14:32:35 <johnw> maybe (return Nothing) (Just <$> f) =<<
14:32:44 <johnw> i'm sure there's an idiom for that somewhere...
14:32:56 <Lethalman> :t maybe (return Nothing) (Just <$> f) =<<
14:32:57 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:32:58 <Gracenotes> fmap Just also gets you from Int -> IO b to Int -> IO (Maybe b)
14:33:02 <Lethalman> :t \f -> maybe (return Nothing) (Just <$> f) =<<
14:33:03 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:33:10 <Lethalman> :t \f -> maybe (return Nothing) (Just <$> f) (=<<)
14:33:10 <johnw> one sec, let me work this out
14:33:10 <lambdabot>     Couldn't match expected type `Maybe a0'
14:33:10 <lambdabot>                 with actual type `(a1 -> m0 b0) -> m0 a1 -> m0 b0'
14:33:11 <lambdabot>     In the third argument of `maybe', namely `(=<<)'
14:33:18 <Lethalman> mh but yes, something like that
14:33:19 <supki> @ty flip ((=<<) . T.traverse)
14:33:20 <lambdabot> (Monad m, Applicative m, T.Traversable t) => m (t a) -> (a -> m b) -> m (t b)
14:33:29 <Lethalman> \o/
14:33:29 <Twey> Lethalman: You need brackets around that operator
14:33:37 <Lethalman> Twey, why?
14:33:37 <Gracenotes> Lethalman: anyway, you might like MaybeT better.
14:33:58 <Sonarpulse> another issue, I tried to put a URL (to a GHC ticket) in the package description
14:34:00 <Twey> Lethalman: Because it's only applied to one argument — you need to make a section
14:34:04 <Sonarpulse> and cabal removed all the /s
14:34:12 <Sonarpulse> what is the proper way to include it?
14:34:15 <Lethalman> Twey, don't get that sorry
14:34:16 <Gracenotes> Lethalman: lift will get you from IO a to IO (Maybe a)
14:34:19 <ion> @type \foo f -> foo >>= traverse f
14:34:19 <lambdabot>     Not in scope: `traverse'
14:34:19 <lambdabot>     Perhaps you meant one of these:
14:34:19 <lambdabot>       `T.traverse' (imported from Data.Traversable),
14:34:22 <ion> @type \foo f -> foo >>= T.traverse f
14:34:22 <lambdabot> (Monad m, Applicative m, T.Traversable t) => m (t a) -> (a -> m b) -> m (t b)
14:34:30 <Twey> :t 5 +
14:34:30 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:34:34 <Twey> :t (5 +)
14:34:34 <lambdabot> Num a => a -> a
14:34:37 <Twey> Lethalman: ^
14:34:39 <Lethalman> Gracenotes, ah thanks, will take in consideration
14:34:47 <Gracenotes> Lethalman: so yeah, rather than just making the types work, also consider the context.
14:34:51 <Lethalman> Twey, I was thinking of brackets package sorry :P
14:34:55 <haasn> Hmm. My first thought was that effective lenses could do this; but it seems that only monadic folds are implemented, not monadic traversals
14:35:07 <ion> Ah, supki already said that.
14:35:09 <Gracenotes> You can do it tersely and idiomatically, or you can abstract properly and do it in an embedded sort of way.
14:35:15 <Gracenotes> If the situation calls for it
14:35:17 <johnw> Lethalman: https://gist.github.com/5992303
14:35:26 <johnw> the idiom is sequenceA . fmap f =<< g
14:35:27 <Lethalman> but I don't want it to be traversable :S
14:35:38 <Twey> Lethalman: What's that library?
14:35:42 <johnw> now, does sequenceA . fmap have another name
14:35:43 <Lethalman> mh
14:35:43 <Twey> I can't seem to find it
14:36:00 <Lethalman> Twey, I meant this: http://www.haskell.org/haskellwiki/Bracket_pattern
14:36:04 <ion> lethalman: Maybe is Traversable whether you want it or not.
14:36:05 <Twey> Oh, right.
14:36:12 <Lethalman> ion, right :P
14:36:16 <johnw> traversable gives you the distributive property that you need to generalize m (n a) -> n (m a)
14:37:02 <johnw> haha
14:37:07 <johnw> sequenceA . fmap = traverse!
14:37:15 <johnw> traverse f =<< g 10
14:37:23 <johnw> aka: forM f =<< g 10
14:37:34 <johnw> err, no
14:37:44 <johnw> mapM
14:38:01 <johnw> and then you don't need traversable anymore
14:38:04 <ion> This is one of the cases where mapM won’t work as a traverse substitute.
14:38:15 <johnw> ah, you're right
14:38:20 <johnw> you need traversable's mapM
14:38:25 <johnw> aka, traverse
14:38:39 <johnw> or wait until GHC 7.10 when mapM will be based on Traversable :)
14:39:54 <Twey> Is Traversable in base now?
14:39:56 <robde> is there a (:) operator for the end of a list?
14:40:08 <johnw> robde: Data.Sequence has a "snoc"
14:40:14 <Twey> robde: No; you can write ++ [foo], but you probably don't want to
14:40:21 <johnw> is O(1) to append an element to both beginning and end
14:40:44 <Twey> robde: If you need to cons to both ends of a list, consider a different data structure, like Data.Sequence
14:41:03 <Twey> robde: Of course, if you only need to cons to the end of the list, just write the list backwards :þ  (and reverse when you're done if necessary)
14:41:04 <johnw> "reducers" has a generalized snoc that works for lists too, although it's just ++ [x]
14:41:57 <johnw> lastly, you can use a DList to do a bunch of ++[x] style snocs, and construction of the final list will be cheap
14:42:05 <johnw> (I'm pretty sure)
14:43:38 <Twey> Yep
14:43:42 <jmcarthur> Twey: Traversable has been in base for quite a while. or do you mean in the Prelude?
14:44:14 <Lethalman> Gracenotes, MaybeT was perfect, thanks
14:44:54 <Twey> jmcarthur: No, I meant in base.  I've not been keeping up with recent developments so well
14:45:11 <Twey> That's good to know
14:45:21 <johnw> Lethalman: how did you use it?
14:45:48 <johnw> runMaybeT $ lift f =<< g 10?
14:46:05 <carter> johnw somehow i never realized you're also the author of ledger
14:46:14 <johnw> carter: that's me!
14:46:21 <jmcarthur> Twey: Traversable dates back to as early as base 2.0, possibly even before that (i can't find older docs than that as easily)
14:46:31 <Lethalman> I'm only blocked at one thing
14:46:45 <Lethalman> I have a Maybe value I should fed to MaybeT IO FilePath
14:46:45 <Lethalman> :S
14:46:50 <Lethalman> err it's a Maybe FilePath
14:46:52 <carter> i looked at it / hledger eons ago, and then was like "huh, i should first understand the accounting stuff needed"
14:46:59 <carter> somehow that never quite happened
14:47:22 <Lethalman> ah no it's Maybe ByteString that's why it doesn't work
14:47:53 <Twey> jmcarthur: What GHC version was that?
14:48:11 <Lethalman> mh no
14:48:44 <carter> johnw relatedly: are there any good expositions on how to understand double entry accounting?
14:49:42 <aristid> carter: just grab a textbook? :P
14:49:48 <carter> which one
14:49:50 <aristid> carter: it's not rocket science though.
14:49:53 <carter> yes
14:50:12 <astor> I just watched http://skillsmatter.com/podcast/home/lazy-io-and-alternatives-in-haskell/jd-7959 which was also posted to reddit.  It describes how the bracket pattern, lazy IO etc. don't work and why pipes etc. are better.  However after watching it, I don't see that pipes resourceT etc solves anything except move the problem one step further.  Those things will release resources as long as the result is in whnf, and don't guarantee
14:50:13 <astor> anything more than that as far as I understand.
14:50:15 <carter> but i actaully have a hard time teasing out ideas from books that are example driven with no concise theory summaryies
14:50:48 <aristid> carter: untested: http://www.amazon.com/Principles-Accounting-Belverd-E-Needles/dp/1439037744 :P
14:50:56 <aristid> dat price.
14:51:06 <astor> It seems to me that resources can only be acquired and released safely through an interface that only communicates NFData.  Am I wrong?
14:51:09 <carter> aristid that price says i shouldn't buy it
14:51:25 <aristid> carter: above all it says it's a textbook
14:51:38 <aristid> carter: maybe you could get the german translation on the cheap!
14:51:41 <carter> aristid i've never bought a math text that pricey
14:51:50 <carter> aristid i tried to take german once
14:51:54 <Lethalman> @hoogle Maybe a -> MaybeT m a
14:51:54 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
14:51:54 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
14:51:54 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
14:51:59 <carter> the 8am part of the class killed it for me ;)
14:52:08 <carter> well that and other reasons
14:52:45 <Lethalman> I'm trying (return foo) :: IO (Maybe FilePath) without success :-(
14:53:32 <aristid> carter: well i don't really know which english-language accounting textbooks are good. i figure you'd want something aimed at university students though, to get at least some theory.
14:53:47 <aupiff> I'm sorry for this inane question, but on OSX running ghci 7.6.3, I type "import Monad" and get the following error:
14:53:59 <aupiff>     Could not find module `Monad'
14:53:59 <aupiff>     It is a member of the hidden package `haskell98-2.0.0.2'.
14:54:00 <aupiff>     Use -v to see a list of the files searched for.
14:54:10 <haasn> aupiff: are you using some really really outdated textbook? =P
14:54:16 <Lethalman> ah!
14:54:20 <Lethalman> MaybeT $ return foo
14:54:20 <aupiff> potentially!
14:54:24 <johnw> carter: if it helps, I still have to do that too (learn some accounting) ;)
14:54:34 <jmcarthur> Twey: i don't know which ghc version it was, but the commit that added it to base was made on 2005-11-29
14:54:50 <carter> johnw but you wrote software for it already! you must already be an expert :P
14:54:54 <Twey> Huh.
14:55:01 * hackagebot nemesis-titan 2013.7.14 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.7.14 (JinjingWang)
14:55:01 <aupiff> haasn: is it no longer necessary to import Monad? Is there a more contemporary module? I am reading "write you a scheme"
14:55:17 <carter> johnw: speaking of which, i'm having fun lately seeing how badly modern C compilers are at autovectorization
14:55:20 <haasn> aupiff: I'm not sure here, but I'm guessing what the book refers to as Monad is now Control.Monad
14:55:32 <haasn> that said, a lot of Monad-related functions should be in the Prelude either way
14:55:37 <jmcarthur> aupiff: the Monad typeclass should be in scope by default. there are some additional functions and such in Control.Monad
14:56:28 <aupiff> haasn: thanks, that was it!
14:56:38 <aupiff> jmcarthur: ok, great to know, thank you.
14:59:39 <johnw> carter: interesting
14:59:59 <carter> johnw i have a lot of examples
15:00:18 <carter> where if auto vectorization is to happen, i need to do a copy first
15:01:02 <carter> johnw aristid like,  just first copying the data you're working on into a local stack buffer then doing the manipulations makes vectorization happen quite a bit more
15:01:49 <carter> because it's easier to "prove" to the compiler than than good alignment and packing has been afoot
15:01:59 <aristid> heh.
15:02:15 <carter> *then, that
15:02:31 <aristid> carter: you can probably tell me under which circumstances Unboxed vectors are better than Storables?:)
15:02:51 <carter> aristid yup
15:03:17 <carter> so Storable arrays actually conflate two ideas
15:03:41 <merijn> aupiff: In case of doubt you can also use Hoogle to find the correct module for functions if they've changed
15:03:56 <carter> aristid Storable arrays  have two things going on
15:04:14 <aristid> carter: i need Storable if i want to interface with C, right?
15:04:25 <carter> aristid not quite
15:04:46 <Lethalman> wow
15:04:49 <FreeFull> I think for interfacing with C you would just use Foreign
15:04:52 <Lethalman> so I got a MaybeT withing a MaybeT :P
15:04:59 <carter> FreeFull lemme finish :)
15:05:30 <carter> aristid for general arbitrary C + HS interaction, storable, because the use Pinnned arrays underneath,
15:05:33 <carter> is Safe
15:05:34 <Lethalman> let's look at it: http://paste.debian.net/15948/
15:05:35 <johnw> Lethalman: do you have the whole algorithm to show us?
15:05:36 <Lethalman> :P
15:05:43 <Lethalman> johnw, that's my nextFile ahhah
15:05:44 <Lethalman> funny
15:05:57 <johnw> I think MaybeT is kind of overkill there, but it's your function :)
15:06:03 <Lethalman> btw I can split that function
15:06:10 <Lethalman> in Enumerator -> MaybeT
15:06:17 <carter> aristid so if you've got reentrant C code that calls back into Haskell then returns and does some more work and then returns to haskell,
15:06:25 <Lethalman> but I wanted to do some exercise with all that nesting
15:06:43 <carter> there might be a GC when you've run the haskell code within the c code
15:07:02 <carter> and which point, if the array isn't Pinned, you're reading/writing garbage in C land
15:07:10 <aristid> carter: and even if it's reachable the GC might move it around, right?
15:07:25 <carter> aristid yes
15:07:26 <carter> buttt
15:07:47 <carter> if your C code doesn't call *back* into GHC, and merely does some work then returns, either is safe
15:08:07 <aristid> carter: so calling read(2) and such would actually be just fine?
15:08:16 <carter> googling it now
15:08:28 <carter> aristid yes
15:08:30 <aristid> man 2 read...
15:08:31 <carter> that said
15:08:38 <carter> http://linux.die.net/man/2/read
15:08:55 <carter> aristid so one difference in storable vs unboxed is Pinning
15:08:56 <aristid> i believe even os x should have that manpage locally:)
15:08:59 <carter> but thats not the MIG one
15:09:02 <carter> *BIG
15:09:07 <aristid> carter: ok, what's big?
15:09:25 <carter> aristid the big difference is Storable using an Array of Structs style layout
15:09:30 <carter> and unboxed uses a struct of arrays
15:09:42 <johnw> Lethalman: compare with something along these lines: https://gist.github.com/5992412
15:09:49 <aristid> carter: storable does not support complex types afaik
15:09:55 <carter> aristid nope, it does
15:10:11 <carter> http://hackage.haskell.org/package/storable-complex
15:10:11 <Lethalman> johnw, awesome, that's what I was looking at! thanks :)
15:10:14 <johnw> that doesn't type check, yet, but gives you the general form
15:10:16 <carter> orphan instance for no good reasons ;)
15:10:18 <jmcarthur> storable does, but unboxed might have trouble with some kinds of sum types and such
15:10:23 <johnw> whileJust is from monad-loops
15:10:25 <carter> http://hackage.haskell.org/packages/archive/storable-complex/0.2.1/doc/html/src/Foreign-Storable-Complex.html
15:10:45 <Lethalman> ok
15:10:48 <jmcarthur> oh, i did not interpret that as "Complex"
15:11:01 <aristid> carter: well let me rephrase that. none of the standard instances are on non-primitive types.
15:11:44 <carter> for Storable?
15:12:08 <aristid> carter: so indeed, Unboxed has the big advantage when it comes to slightly more complex types, because it supports them better and, for reasons unknown to me, struct-of-vectors is the "recommended" layout.
15:12:10 <carter> jmcarthur hrmmm, yeah, Sums / Either , etc
15:12:18 <aristid> carter: yes, for storable.
15:12:37 <carter> aristid Storable actually might be better for Sum / Either types
15:12:41 <carter> in terms of ease of encoding
15:12:45 <carter> assuming you can use a fixed size
15:13:00 <carter> aristid for product types
15:13:02 <carter> like Complex
15:13:16 <carter> the rason why the Struct of arrays approach is "better"
15:13:21 <carter> is
15:13:25 <aristid> carter: for Either types you'd need to waste a lot of bytes due to alignment :/
15:13:27 <jmcarthur> sometimes better
15:13:33 <carter> jmcarthur yes
15:13:45 <carter> lets assume < 8 ary Products
15:13:47 <carter> :)
15:13:48 <aristid> carter: Either is like one bit, but you'd need usually 4 or 8 bytes for the alignment
15:13:50 * jmcarthur segfaults
15:14:05 <Lethalman> johnw, this is already better ;) http://paste.debian.net/15950/
15:14:13 <Lethalman> except that case of
15:14:14 <Lethalman> :t maybe
15:14:15 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:14:28 <aristid> carter: do continue explaining why struct-of-arrays is "better"
15:14:29 <carter> aristid yeah, turns into a DB + compression fast
15:14:32 <carter> aristid ok
15:14:46 <carter> aristid consider just adding two vectors of complex numbers
15:14:53 <johnw> try: fmap unpack . fileInfoGetName <$> fileEnumeratorNextFile enumerator Nothing
15:15:01 * hackagebot typesafe-endian 0.1.0.0 - Enforce endianness with types  http://hackage.haskell.org/package/typesafe-endian-0.1.0.0 (JohnEricson)
15:15:21 <aristid> carter: ok.
15:15:27 <johnw> and instead of enumerator <- fileEnumerateChildren, fileLister <$> fileEnumerateChildren...
15:15:35 <Lethalman>   return $ maybe Nothing (\x -> unpack <$> fileInfoGetName x) info
15:15:44 <carter> brb
15:15:53 <Lethalman> mh
15:15:59 <johnw> ah, I see
15:16:06 <johnw> you need traverse and not fmap
15:16:06 <Lethalman> ok the second
15:16:27 <johnw> traverse (unpack <$> fileInfoGetName)
15:16:27 <Lethalman> yes
15:16:37 <johnw> anyway, that's just golfing at this point
15:16:45 <Lethalman> eheh yes
15:17:16 <Lethalman> now, given my lovely nextFile :: IO (Maybe FilePath)
15:17:18 <merijn> Dammit
15:17:30 <Lethalman> will try to get the source tomorrow from your paste :-)
15:17:46 <Lethalman> it should be something like whileJust nextFile yield as far as I've understood
15:17:49 <merijn> My reactive-banana code keeps crashing on <<loop>>, but I'm not sure whether it's my code that's broken or the library :\
15:17:52 <johnw> fileLister = traverse (unpack <$> fileInfoGetName) <=< flip fileEnumeratorNextFile Nothing
15:17:55 <johnw> :)
15:18:01 <Lethalman> :t whileJust
15:18:01 <lambdabot> Not in scope: `whileJust'
15:18:07 <Lethalman> @hoogle whileJust
15:18:07 <lambdabot> No results found
15:18:09 <johnw> :t Control.Monad.Loops.whileJust
15:18:10 <lambdabot> Monad m => m (Maybe a) -> (a -> m b) -> m [b]
15:18:33 <johnw> i think there's whileJust_ too
15:18:34 <Lethalman> oh well
15:18:35 <Twey> unfoldM?
15:18:37 <johnw> :t Control.Monad.Loops.whileJust_
15:18:38 <lambdabot> Monad m => m (Maybe a) -> (a -> m b) -> m ()
15:18:43 <Twey> :t unfoldr
15:18:44 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:18:47 <johnw> :t Control.Monad.Loops.unfoldM
15:18:48 <lambdabot> Monad m => m (Maybe a) -> m [a]
15:18:49 <Lethalman> that's exactly it
15:18:54 <Twey> Hm
15:19:14 <Lethalman> but can yield be (a -> m b) ?
15:19:23 <johnw> :t Data.Conduit.yield
15:19:24 <lambdabot> Monad m => o -> Data.Conduit.Internal.ConduitM i o m ()
15:19:30 <Lethalman> ehm yes :P what's that eheh
15:19:42 <johnw> what would yield :: a -> m b mean?
15:19:47 <johnw> conduits aren't bidirectional
15:20:02 <johnw> i think pipes can do that, though
15:20:22 <johnw> yield is effectively a -> m ()
15:20:31 <johnw> and await is m (Maybe a)
15:20:47 <Lethalman> yeah
15:21:01 <Lethalman> so whileJust_ works with yield
15:21:05 <johnw> yep
15:21:16 <Lethalman> yes, my nextFile is pretty much an await after all
15:21:22 <johnw> exactly
15:21:25 <carter> aristid consider doing complex multiplication
15:21:38 <johnw> your nextFile really only works this way because you're using another enumerator library :)
15:21:39 <carter> (a+ib)* (c+di)
15:22:06 <johnw> if you did it by hand (say, by dipping into the C FFI to call readdir, etc.), you'd find yourself needing to use continuations to do this efficiently
15:22:07 <carter> = (ac - bd) + i(ac + bd) right?
15:22:20 <Lethalman> johnw, why?
15:22:36 <sipa> carter: i(ad+bc)
15:22:48 <carter> good catch
15:23:03 <johnw> Lethalman: how else do you encode "resuming" of a computation, so that it calls stat for the next file but without reading in a whole list at once?
15:23:16 <Lethalman> johnw, cause readdir already does it
15:23:17 <carter> aristid with the struct of arrays layout
15:23:21 <carter> (as with unboxed)
15:23:22 <Lethalman> so it's IO (Maybe FilePath)
15:23:24 <carter> i can vectorize the math
15:23:27 <FreeFull> Arriving at how to do complex multiplication isn't that hard
15:23:31 <Lethalman> johnw, which is exactly the fileEnumeratorNextFile
15:23:40 <johnw> Lethalman: readdir does it, but how do you get Haskell's flow of control to go back into the code where you call the readdir
15:23:43 <carter> FreeFull the focus is on vectorization :)
15:23:49 <S_J> pure == return? why are monads more general than Applicatives and not the other way around?
15:23:50 <johnw> I bet fileEnumeratorNextFile uses a continuation underneath :)
15:23:51 <aristid> carter: ok, you switched away from addition because that works equally welll in both methods?:)
15:23:59 <Lethalman> johnw, no I pass enumerator all the time, see the code
15:24:00 <carter> yup
15:24:03 <sipa> S_J: historic reason
15:24:08 <johnw> yes, and what is enumerator
15:24:10 <FreeFull> (a + ib)(c + id) = ac + ibid + aid + ibc
15:24:17 <johnw> it's a data type holding a continuation value
15:24:18 <aristid> carter: vectorise, as in use SIMD instructions?
15:24:18 <Lethalman> johnw, and that's what readdir is :-)
15:24:19 <FreeFull> i*i = -1 so
15:24:23 <carter> aristid yup
15:24:23 <johnw> but readdir is stateful
15:24:24 <Lethalman> johnw, you pass in the same arguments
15:24:27 <johnw> you have to get that state back to readdir
15:24:31 <FreeFull> ac - bd + i(ad + bc)
15:24:39 <Lethalman> johnw, the state of fileEnumeratorNextFIle is enumerator
15:24:47 <Lethalman> just like tthe state of readdir is the DIR* ent
15:24:50 <johnw> yes, and what is the type of enumerator!
15:24:55 <Lethalman> sigh
15:24:59 <carter> aristid you could SIMD with the array of  struct layout
15:25:05 <carter> but you need to do explicit shuffling
15:25:05 <Lethalman> johnw, there's no difference between fileENumeratorNextFile and readdir
15:25:11 <johnw> well, actually, I see what you mean
15:25:17 <Lethalman> I can just substitute my code with readdir
15:25:19 <johnw> the DIR* is keeping the state, so you only need to pass that around
15:25:35 <Lethalman> yes, I pass around with simply partial application
15:25:37 <banister> is there a way to curry arbitrary arguments ?
15:25:38 <johnw> continuations are only for when you aren't mutating something in place
15:25:43 <banister> i mean partially apply*
15:25:52 <mauke> banister: explicit lambda
15:25:58 <carter> aristid makes sense?
15:26:02 <Lethalman> johnw, yes, readdir mutates, that's why it works, as well as fileEnumeratorNextFile
15:26:10 <ofan> carter: hi!
15:26:14 <carter> ofan hello!
15:26:15 <Lethalman> the OS api is stateful by itself
15:26:15 <johnw> Lethalman: ok, I understand now.  I didn't have my C cap on, just the Haskell cap :)
15:26:16 <carter> welcome!
15:26:21 <ofan> yay
15:26:32 <aristid> carter: the channel is a bit busy right now so all your statements are so spread out :/
15:26:34 <carter> hey everyone: ofan  is doing great work for his haskell GSOC
15:26:41 <carter> aristid soke
15:26:43 <Lethalman> johnw, it would have been a continuation if readdir would return the next state, right?
15:27:03 <carter> namely: ofan's working to make the C++ ffi experience nice :)
15:27:05 <johnw> Lethalman: yes
15:27:06 <Lethalman> or sort of
15:27:14 <Taneb> carter, ooh, marvellous!
15:27:17 <mauke> carter: ew
15:27:27 <Lethalman> ok thanks everybody :-)
15:27:29 <Lethalman> night
15:27:31 <carter> mauke be nice, theres some neat libs in C++
15:27:37 <johnw> Lethalman: example: https://gist.github.com/5992457
15:27:39 <carter> that we dont have the time to port to haskell
15:27:50 <carter> Taneb yeah
15:27:53 <johnw> some iteratee libraries basically boil down to that inside
15:28:02 <aupiff> jkjljjk
15:28:07 <carter> gratned, the coolest C++ lib of them all, LLVM, has its own style of ffi
15:28:09 <johnw> (that code is a simplification from an Oleg paper)
15:28:20 <carter> ofan actually: you may find looking at llvm-general handy,
15:28:34 <johnw> aristid: you can go to #haskell-llvm, and then we won't drown you out :)
15:28:45 <johnw> aristid: carter luvs to chat there!
15:28:47 <Lethalman> mh too complex right now :P
15:28:47 <carter> aristid ofan  i'm heading off for dinner
15:29:02 <carter> johnw #haskell-llvm is like #haskell-lens
15:29:03 <johnw> Lethalman: yeah, it's hairy at first for sure
15:29:05 <Lethalman> how do you guys can keep your head after all those type parameters and functions :P
15:29:10 <johnw> #haskell-lens is the new #haskell-theory
15:29:12 <aristid> carter: ok cool, cya:)
15:29:13 <ofan> carter: ok, I sent you an email, pls check it later. see you.
15:29:18 <carter> ofan saw it
15:29:20 <carter> will do
15:29:24 <carter> enjoy the evening!
15:29:25 <johnw> Lethalman: practice
15:29:26 <haasn> I spy a fry monad!
15:29:29 <johnw> bye carter!
15:29:30 <Lethalman> johnw, hope so eheh
15:29:30 <haasn> free, monad
15:29:33 <carter> Lethalman also the type systems helps
15:29:35 <haasn> free, even*
15:29:36 <Taneb> I thought #haskell-lens was #haskell-edwardk
15:29:43 <carter> Taneb exactly :)
15:29:47 <FreeFull> The me monad
15:29:48 <johnw> Lethalman: it does become second nature after a while, but you have to actually use this stuff a LOT
15:30:11 <carter> Taneb that said, once i do my release next week, i'll be hosting another haskell channel
15:30:24 <johnw> I just noticed that my Stepper is basically a Free monad
15:30:49 <johnw> haasn: haha, just read what you said :)
15:31:13 <merijn> chrisdone: lpaste.net doesn't do announcements in #haskell?
15:31:14 <zzo38> The new Hackage isn't very good; it wastes most of the screen with really wide margins.
15:31:19 <zzo38> Can you fix this please?
15:31:36 <haasn> Fry ((a,) `Comp` CCT r m)
15:31:52 <merijn> Any reactive-banana people that can help me figure out how to do this without the code crashing with <<loop>>? http://lpaste.net/90880
15:34:40 <b6> does hackage have a server admin contact?
15:35:50 <yitz> b6: what's the problem?
15:36:12 <b6> yitz: build failure due to library that they might not mind being installed there.
15:36:24 <b6> yitz: i just need libxxf86vm.
15:36:37 <b6> yitz: other x libs seem to be on there.
15:36:45 <yitz> b6: so upload it
15:37:06 <haasn> yitz: I think he means a C library
15:37:09 <yitz> b6: assuming you have ported it to haskell. hackage is for haskell code.
15:37:19 <b6> yitz: say what? i mean i want someone with root to use some package manager to install a library.
15:37:30 <haasn> yitz: one that his package depends on
15:37:40 <yitz> b6: there are no c libraries on haskell
15:37:49 <yitz> *hackage
15:38:36 <yitz> b6: you are expected to get x libs from you OS package manager
15:38:44 <yitz> *your
15:38:53 * yitz can't type today, sorry
15:39:22 <haasn> yitz: I think you're misunderstanding
15:39:41 <b6> yitz: take a look: http://hackage.haskell.org/packages/archive/GLFW-b/1.0.0/logs/failure/ghc-7.6  this package would build on hackage if that box had Xxf86vm. that box has other x libraries installed.
15:39:52 <haasn> He uploaded a package that has some C library in its external dependencies that are required for building it (+ the documentation)
15:40:15 <johnw> haasn: https://gist.github.com/5992485
15:40:22 <yitz> ok so people who want to install it need to make sure to get the c libraries. from somewhere else, not from hackage.
15:40:34 <haasn> johnw: much cleaner, /obviously/
15:40:40 <johnw> haha
15:40:47 <haasn> johnw: I don't think you're actually using the monad instance
15:40:54 <johnw> no, not in that code
15:41:03 <b6> yitz: i know. the problem is, if it doesn't build on hackage, the haddock docs don't get built either. that means if anyone depends on my library, their docs don't get built on hackage either.
15:41:18 <johnw> so, is Free ~ Mu, such that I can use catamorphisms for Free values?
15:41:35 <b6> yitz: so, because of big problems in haddock/cabal that can't be fixed quickly, i'm hoping someone will just install a harmless library alongside other similar harmless libraries.
15:41:35 <haasn> johnw: I don't see why not
15:41:36 <yitz> b6: ah. hmm. i see.
15:41:49 <haasn> johnw: free is to mu as list is to stream, and catamorphisms work on lists just fine
15:42:01 <johnw> ahh
15:43:05 <yitz> hackage should try harder to build haddocks. if a build fails, it should try just cabal haddock
15:43:35 <b6> yitz: i think the deal is, cabal haddock won't succeed because cabal configure didn't succeed, because the dependency wouldn't build. :(
15:43:58 <b6> yitz: but there is actually no problem with the dependency. it builds on all platforms we care about. it just has problems on hackage.
15:44:59 <yitz> b6: well ross paterson runs the current hackage server. ask him.
15:45:06 <b6> yitz: ok. thanks.
15:45:52 <yitz> b6: there is some re-organisation going on now in server admin though. that was true up the past couple of weeks
15:46:00 <yitz> *up to
15:46:13 <b6> ok. if he's not the guy, he can probably forward it.
15:46:17 <yitz> sure
15:47:47 <haasn> ?where hpaste
15:47:47 <lambdabot> http://lpaste.net/new/haskell
15:48:07 <haasn> johnw: http://lpaste.net/90881 ?
15:49:16 <johnw> yeah, looks good to me
15:49:18 <johnw> thanks!
15:49:29 <johnw> i'm surprised that's not in "free", I'll make a pull request
15:50:03 <johnw> of course, with the obligatory {-# INLINE cata #-} :)
15:51:52 <haasn> johnw: you could probably copy over all of the *morphisms from edwardk's packages :P
15:59:51 <banister> if i have: foo x y z = x + y + z
16:00:01 <banister> (3 `foo` 4) 5
16:00:02 <banister> works
16:00:21 <Ralith> that is expected
16:00:21 <johnw> yeah, likely
16:00:28 <banister> but there can only be one parameter on the left hand side of the `foo` ?
16:00:38 <benmachine> banister: yes
16:00:49 <mauke> there is no syntax for otherwise
16:00:57 <Ralith> remember, 'foo :: t -> u -> v -> w' is equivalent to 'foo :: t -> u -> (v -> w)'
16:00:59 <benmachine> if you had (a b `foo` c) then that would just be foo applied to ab and c
16:01:03 <benmachine> er, a b
16:01:05 <S_J> How much memory and processor power is needed to run Haskell? Can you run haskell on bare metal or you need an OS underneath it?
16:01:18 <Ralith> S_J: are those questions supposed to be related?
16:01:24 <banister> mauke: so that means i can partially apply x or partially apply y
16:01:28 <banister> but i can't partially apply z ?
16:01:39 <mauke> banister: ... didn't I already answer that question?
16:01:44 <benmachine> banister: not with operator-section syntax
16:02:04 <banister> mauke: well you said it was impossible totally, but using sections i can partially apply the second arg ;)
16:02:15 <S_J> Ralith: no they are 2 separete questions?
16:02:24 <banister> which is at least better than being only able to partially apply the first arg
16:02:40 <mauke> meh
16:02:41 <banister> mauke: sorry, i misrepresented your answer
16:02:51 <mauke> you can do anything if you add enough 'flip's
16:03:53 <mauke> @pl \z -> foo x y z
16:03:53 <lambdabot> foo x y
16:03:56 <mauke> @pl \y -> foo x y z
16:03:56 <lambdabot> flip (foo x) z
16:04:00 <mauke> @pl \x -> foo x y z
16:04:00 <lambdabot> flip (flip foo y) z
16:05:03 <benmachine> @pl \x y -> foo x y z
16:05:03 <lambdabot> flip flip z . foo
16:09:28 <Ralith> S_J: haskell's requirements are implementation defined
16:10:19 <benmachine> Ralith: nevertheless, it's a reasonable question if you want to know what implementations exist
16:10:26 <Twey> S_J: Most (all?) implementations are not designed to run without an OS, but there has been some research in that direction (House &c.)
16:10:45 <Ralith> S_J: http://corp.galois.com/halvm may also be of interest
16:11:37 <Ralith> http://hasp.cs.pdx.edu/ also
16:29:53 <JOhnNash> Hi. How can I write a function (==) :: (Eq a, Eq b, Typeable a, Typeable b) => a -> b -> Bool that returns False for different types and the regular comparison result for equal types?
16:30:10 <mauke> @let x === y = cast x == Just y
16:30:11 <lambdabot>  Defined.
16:30:14 <mauke> :t (===)
16:30:15 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
16:30:52 <FreeFull> > 3 === 'a'
16:30:56 <lambdabot>   mueval-core: Time limit exceeded
16:31:01 <FreeFull> > 3 === 'a'
16:31:04 <JOhnNash> rWOW. I thought the speed of light cannot be surpassed?
16:31:05 <lambdabot>   mueval-core: Time limit exceeded
16:31:07 <FreeFull> > 3 === 3
16:31:11 <lambdabot>   mueval-core: Time limit exceeded
16:31:15 <hpc> > 3
16:31:16 <lambdabot>   3
16:31:23 <hpc> > cast 3 :: Char
16:31:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:31:24 <lambdabot>              with actual type...
16:31:30 <hpc> > cast 3 :: Maybe Char
16:31:31 <lambdabot>   Nothing
16:31:39 <hpc> lambdabot, you are the best
16:31:40 <mauke> > () === ()
16:31:43 <lambdabot>   True
16:31:48 <mauke> > 3 === 'a'
16:31:51 <lambdabot>   False
16:32:09 <JOhnNash> Why was the time limit hit in some of the examples?
16:32:15 <JOhnNash> Does that mean it does not work?
16:32:16 <Peaker> When implementing type-inference/checking in the presence of rank-n types, is it normal for unification to have to check if a type-variable does not escape its scope?
16:32:35 <geekosaur> ...you can write it that way, but it's a code smell of sorts in Haskell. strict types should not allow such comparisons
16:32:52 <geekosaur> JOhnNash, because of a bug in the bot (we suspect)
16:33:09 <benmachine> JOhnNash: try ghci
16:33:19 <erisco> I recall some function that did   [a] -> [a] -> [a]   such as f [1,2,3] [8, 9] = [1,8,1,9,2,8,2,9,3,8,3,9]
16:33:21 <FreeFull> > (fromEnum 3 :: Char) === 3
16:33:22 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:33:22 <lambdabot>              with actual type...
16:33:27 <erisco> but have lost the name
16:33:38 <FreeFull> > '3' === 3
16:33:41 <lambdabot>   False
16:33:44 <geekosaur> (in the previous iteration of lambdabot, someone found a spot where someone assumed that delayThread worked in milliseconds --- it's actually microseconds. nobody seems to know if the current one has that bug still)
16:33:51 <FreeFull> > '\3' === 3
16:33:54 <lambdabot>   False
16:33:56 <geekosaur> er, threadDelay
16:33:59 <geekosaur> bad me
16:33:59 <FreeFull> Why the error there?
16:34:07 <FreeFull> Oh, wiat
16:34:10 <geekosaur> er? they're not the same type
16:34:12 <FreeFull> I wanted toEnum
16:34:18 <FreeFull> > (toEnum 3 :: Char) === 3
16:34:20 <Peaker> geekosaur, good evidence that the whole practice of using Int/Integer for units is terrible
16:34:21 <lambdabot>   False
16:34:26 <mauke> FreeFull: chr
16:34:28 <JOhnNash> OK:
16:34:42 <elliott> geekosaur: I replaced the same bit Cale did in the same way
16:34:45 <Peaker> (rather than an abstract Time type with "fromMillis", "fromMicros" construction functions)
16:34:48 <elliott> so I suspect it was never the probelm
16:34:51 <hpc> i thought it was evidence that threadDelay should take Double seconds
16:34:56 <Peaker> or just "millis/micros"
16:34:58 <NemesisD> do you guys have any suggestions for writing reliable processes that run in separate threads
16:35:08 <Cale> elliott: It was definitely the problem at one point
16:35:12 <NemesisD> i.e. i need several processes that must run for the life of the program, even if they hit errors
16:35:24 <hpc> NemesisD: you mean threads? processes are completely different
16:35:28 <Peaker> hpc, Double has some disadvantages, and it's still not entirely clear it's in seconds
16:35:39 <NemesisD> hpc: sorry, meant processes in the erlang sense
16:35:56 <JOhnNash> I have a (polymorphic?) list type using existential quantification to basically hold values of the Eq class. Doesn't it make sense to compare any two elements of such a list using the just defined (===)?
16:35:58 <Peaker> hpc, especially if you see: threadDelay 2    vs.   threadDelay (seconds 2)
16:35:58 <hpc> ah
16:36:17 <mauke> NemesisD: async package, maybe?
16:36:17 <Peaker> @type (===)
16:36:18 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
16:36:38 <Peaker> JOhnNash, it's likely a bad idea, what do you need it for?
16:36:40 <hpc> NemesisD: to give an admitedly somewhat unhelpful answer, write your forked computations so they do not generate errors
16:37:10 <hpc> using functions from libraries or your own creation that absorb errors
16:37:12 <erisco> > concatMap ((:) . uncurry) [(x, y) | x <- [1,2,3], y <- [8,9]]
16:37:12 <lambdabot>   Couldn't match type `[(a0, b1) -> c0] -> [(a0, b1) -> c0]'
16:37:12 <lambdabot>                w...
16:37:19 <erisco> :t uncurry
16:37:20 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:37:30 <erisco> > concatMap ((:) . curry) [(x, y) | x <- [1,2,3], y <- [8,9]]
16:37:31 <lambdabot>   Couldn't match type `[a0 -> b1 -> c0] -> [a0 -> b1 -> c0]'
16:37:31 <lambdabot>                w...
16:37:39 <hpc> like withFile' :: FilePath -> (String -> IO a) -> Either IOError a
16:37:58 <NemesisD> hpc: at a certain point that isn't enough though. i personally do not throw exceptions because i find them to be a major language wart
16:37:58 <erisco> bah
16:38:12 <NemesisD> hpc: but at a certain point, connections disappear,  networks get flaky, etc
16:38:46 <hpc> withConnection :: URL -> (String -> IO a) -> Either IOError a -- :P
16:38:57 <erisco> > concatMap (uncurry (:)) [(x, y) | x <- [1,2,3], y <- [8,9]]
16:38:58 <lambdabot>   No instance for (GHC.Show.Show b0)
16:38:58 <lambdabot>    arising from a use of `M377904989.sho...
16:39:28 <JOhnNash> Peaker, I actually need a list of pairs of such types (a,b), where the possible combinations are restricted. I started using ADT, but do not know how to enforce the restriction.
16:39:29 <NemesisD> hpc: what i'd really love is some sort of analysis tool that could warn me when code was not exception/error safe
16:39:45 <Peaker> JOhnNash, what problem are you solving?
16:40:09 <erisco> > concatMap (\(x,y) -> [x, y]) [(x, y) | x <- [1,2,3], y <- [8,9]]
16:40:10 <lambdabot>   [1,8,1,9,2,8,2,9,3,8,3,9]
16:40:16 <NemesisD> as much work as we put into fighting partial functions, anyone can throw an exception and the type checker is none the wiser. it causes me much worry
16:40:19 <JOhnNash> Peaker, construction a type safe configuration.
16:40:34 <Peaker> JOhnNash, of what?
16:40:38 <erisco> lambdabot as a way to rewrite lambdas into non-lambdas yes? what is the call?
16:41:02 <geekosaur> you mean @pointless aka @pl?
16:41:11 <Peaker> @pl \(x,y) -> [x,y]
16:41:14 <lambdabot> ap (flip ((.) . (:)) (: []) . fst) snd
16:41:14 <lambdabot> optimization suspended, use @pl-resume to continue.
16:41:18 <geekosaur> which is nto quite the same thing
16:41:27 <erisco> oh lord that is hideous :P
16:41:45 <geekosaur> and yes, it often generates horrid garbage. lambdas and points are not necessarily evil
16:41:59 <benmachine> the @pl command doesn't always find the best solution
16:42:12 <benmachine> @pl \x y -> [x,y]
16:42:13 <lambdabot> (. return) . (:)
16:42:22 <JOhnNash> Peaker, not sure yet. I was thinking about software that needs different things configured, Think of e.g. xorg. The different displays have different settings and the different inputs have different setting.
16:42:26 <benmachine> :t uncurry (. (:[])) . (:))
16:42:27 <lambdabot> parse error on input `)'
16:42:34 <benmachine> :t uncurry ((. (:[])) . (:))
16:42:34 <lambdabot> (b, b) -> [b]
16:42:44 <benmachine> still horrible, but less so :P
16:42:49 <Peaker> erisco, ($ []) . uncurry (.) . ((:) *** (:))
16:43:15 <JOhnNash> Peaker, So I wanted a list of (Key,Val). for example: data Key = Display Integer | Input String
16:43:16 <erisco> I just wanted to check that I wasn't missing an alternative. no reason I can't use the lambda
16:43:17 <FreeFull> > uncurry ((. (:[])) . (:)) $ (3,4)
16:43:18 <lambdabot>   [3,4]
16:43:19 <Peaker> (apply (:) on both, then compose, then apply on empty list)
16:43:21 <FreeFull> I see
16:43:28 <Peaker> erisco, yes, use the lambda :)
16:43:46 <Peaker> erisco, or name it in a "where pairList (x,y) = [x,y]"
16:43:53 <FreeFull> @hoogle ([a],[a]) -> [a]
16:43:53 <lambdabot> Network.CGI.Protocol formEncode :: [(String, String)] -> String
16:43:53 <lambdabot> Network.CGI formEncode :: [(String, String)] -> String
16:43:53 <lambdabot> Network.HTTP.Base urlEncodeVars :: [(String, String)] -> String
16:43:59 <banister> where can i find a list of cool combinators, like memoize() etc?
16:44:21 <banister> i'd like to learn about a bunch of handy combinators
16:44:24 <Peaker> I wish hoogle could find only generalized functions rather than specialized ones, or at least, only allow type-class specialization and not concrete-type specialization
16:44:36 <yitz> banister: memoize isn't there, but lens sure is a pretty big list of cool combinators
16:45:19 <yitz> banister: i'll admit that i'm not using those though
16:45:38 <FreeFull> There probably are multiple libraries with memoization stuff
16:45:56 <yitz> there have been some blog posts about it in the past
16:46:09 <JOhnNash> Peaker, And then: data Values = DisplaySettings (Integer,Integer) | InputSettings ...
16:46:41 <banister> yitz: thx
16:46:49 <yitz> but i have seen enough of them to become convinced that "memoization" isn't really a useful concept.
16:46:55 <Peaker> JOhnNash, is this meant to parse a specific config format? or can you use e.g: json?
16:46:58 <yitz> just fix your algorithm
16:47:12 <Peaker> JOhnNash, what I do in my configuration is simply define an ADT for my total configuration, and then use TH to generate to/from JSON on it
16:47:25 <erisco> is Eq required to check if xs == []? seems odd
16:47:35 <mauke> erisco: null
16:47:36 <JOhnNash> Peaker, wow, how?
16:47:39 <mauke> == always requires Eq
16:47:40 <FreeFull> > null []
16:47:41 <lambdabot>   True
16:47:56 <Peaker> JOhnNash, http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-TH.html
16:47:59 <erisco> :t null
16:48:00 <lambdabot> [a] -> Bool
16:48:08 <erisco> @src null
16:48:08 <lambdabot> null []     = True
16:48:08 <lambdabot> null (_:_)  = False
16:48:21 <Peaker> JOhnNash, data Config = Config { .. all my configs here .. } ; deriveJSON id ''Config
16:48:23 <erisco> okay I figured ... slightly odd how pattern matching dodges this
16:48:24 <hpc> yitz: sometimes you just gotta make your pure functions stateful ;)
16:48:41 <JOhnNash> Peaker, cool
16:48:43 <benmachine> erisco: I used to think so, but it all makes sense in the end
16:48:45 <mauke> erisco: wrong way around
16:48:49 <geekosaur> pattern matching compares constructors; Eq compares values
16:48:50 <mauke> pattern matching is built in
16:48:54 <mauke> == is just a library function
16:48:54 <JOhnNash> Peaker, question remains however: Why is (===) a bad idea?
16:48:56 <benmachine> erisco: pattern matching is primitive, equality is defined using pattern matching
16:49:11 <benmachine> JOhnNash: because ideally you should know whether or not the types are equal already
16:49:16 <yitz> hpc: pretty rare to need to do that.
16:49:26 <hpc> benmachine: not just ideally; you do
16:49:31 <hpc> that's the nature of static type systems
16:49:32 <benmachine> JOhnNash: in fact, it's pretty much guaranteed that either the answer would be False or you'd be able to use == anyway
16:49:38 <hpc> yitz: i know, i was being sarcastic ;)
16:49:47 <yitz> hpc: ok :)
16:53:16 <yitz> JOhnNash: it's always a good idea to avoid hard-wiring unneeded assumptions into your code.
16:54:03 <JOhnNash> yitz, are you referring to the assumption about the allowed pairs, i.e. (Display, DisplaySettings)?
16:54:46 <yitz> JOhnNash: no just a general remark about avoiding ==
16:56:47 <JOhnNash> I am also wondering, how I could get a function, that reads out the val for a given key? i.e. get store (Display 2) :: DisplaySettings
16:57:15 <JOhnNash> and get store (Input "Keyboard A") :: InputSettings
16:57:20 <S_J> does template haskell allow you to define your own syntax?
16:57:41 <yitz> S_J: yes. quasiquoters are specifically designed for that.
16:58:26 <S_J> how can $ be replaced
16:58:48 <yitz> S_J: but they require your syntax to be enclosed in special brackets with predefined syntax
16:58:54 <S_J> > let makeList n = [1..n] in map (+1) makeList 3
16:58:55 <lambdabot>   Couldn't match expected type `a0 -> t0' with actual type `[b0]'Couldn't mat...
16:58:58 <S_J> > let makeList n = [1..n] in map (+1) id makeList 3
16:58:59 <lambdabot>   Couldn't match expected type `(t1 -> [t1]) -> a1 -> t0'
16:58:59 <lambdabot>              with a...
16:59:04 <S_J> > let makeList n = [1..n] in map (+1) $ makeList 3
16:59:05 <lambdabot>   [2,3,4]
16:59:53 <slack1256> S_J: $ replaced with another symbol?
17:00:42 <yitz> S_J: you can define anything you want to be the same as $. and you can disallow $ itself by doing import Prelude hiding (($))
17:01:01 <yitz> @src ($)
17:01:01 <lambdabot> f $ x = f x
17:01:19 <slack1256> exactly ($) is an operator defined in pure haskell
17:01:37 <slack1256> the only grace of it, is that it has low fixity, so you can avoid parentesis
17:02:00 <slack1256> > let makeList n = [1..n] in map (+1) (makeList 3)
17:02:01 <lambdabot>   [2,3,4]
17:02:06 <slack1256> > let makeList n = [1..n] in map (+1) $ makeList 3
17:02:07 <lambdabot>   [2,3,4]
17:02:08 <yitz> S_J: actually, ($) == id, except $ requires its first argument to be a function
17:02:29 <slack1256> @type ($)
17:02:30 <lambdabot> (a -> b) -> a -> b
17:02:33 <slack1256> @type (id)
17:02:34 <lambdabot> a -> a
17:03:03 <slack1256> @type (id id)
17:03:04 <lambdabot> a -> a
17:03:43 <Twey> :t id id id id id id id
17:03:44 <lambdabot> a -> a
17:03:45 <yitz> > (map (+1)
17:03:46 <lambdabot>   <hint>:1:10:
17:03:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
17:03:54 <slack1256> @type (map (+1))
17:03:55 <lambdabot> Num b => [b] -> [b]
17:03:58 <yitz> > map (+1) `id` [1..5]
17:03:59 <lambdabot>   [2,3,4,5,6]
17:04:18 <slack1256> ^ That ways is analogous to ($)
17:04:57 <slack1256> Anyways you can get far in making languages in pure haskell without templace haskell
17:05:04 <slack1256> @hackage BASIC
17:05:04 <lambdabot> http://hackage.haskell.org/package/BASIC
17:08:05 <yitz> https://github.com/bjpop/berp
17:10:29 <Peaker> yitz, I wonder what Haskeller could like Python enough to do that kind of thing :)
17:13:45 <slack1256> Maybe is not a thing about liking as much as convenience
17:13:45 <slack1256> ML and company have long history of being good languages to be building compilers
17:13:45 <slack1256> the same applies to haskell
17:13:58 <slack1256> That being said I don't know a single things about compiler design
17:14:02 <yitz> Peaker: it's a proof that haskell >= python
17:14:09 <Peaker> yitz, why?
17:14:44 <yitz> Peaker: python can be implemented simply and elegantly in haskell, therefore haskell is at least as powerful
17:14:54 <slack1256> Hahhaa
17:14:55 <slack1256> that is true
17:15:09 <slack1256> but also the proof of python >= haskell is at the corner of the street
17:15:31 <Peaker> yitz, or it could be a testament to Python's simplicity
17:15:46 <Peaker> and "power" isn't the main (or maybe even the most important) attribute
17:16:15 <yitz> slack1256: i tried that once. it's possible to write a very simplistic haskell implementation in python, but far harder than the opposite. and even then it's so simplistic as to be almost unusable.
17:16:19 <Peaker> is it a complete implementation, btw?
17:16:58 <slack1256> neat
17:17:06 <yitz> Peaker: i think it's at least *almost* complete. well, i doubt he actually included all of the batteries.
17:17:44 <yitz> Peaker: more recently he wrote blip, which compiles the python to python byte code, so you can use any existing libraries with it
17:18:54 <yitz> Peaker: python is undoubtedly simpler. but scheme is simpler still - i'm sure berp took more than 48 hours to write.
17:20:01 <Peaker> yitz, yeah, but those criterions of power/simplicity are simplistic... both are desirable but a language being simpler or more powerful isn't enough on its own
17:20:37 <Peaker> for example, the downside of Haskell is that it is harder to learn -- and for hobby programmers who don't program much, or for people who tend to write small programs, learning Haskell may not pay off
17:21:05 <Peaker> so being more powerful doesn't necessarily justify being harder to learn (for everyone)
17:22:27 <yitz> Peaker: true.
17:23:27 <NemesisD> mauke: have you ever used async for something like this? is it something like: workForever = eitherT handleError (const workForever) $ waitCatch (async worker)
17:24:04 <Twey> Peaker: I'm not convinced on the ‘harder to learn’ bit.
17:24:11 <S_J> :t const
17:24:12 <lambdabot> a -> b -> a
17:24:18 <S_J> > const 5 3
17:24:19 <lambdabot>   5
17:24:51 <Peaker> Twey, Scheme is probably easier to learn in the sense that you can start writing programs within a couple of hours.  Define "learn" as "becoming minimally productive"
17:25:19 <slack1256> oh maybe that right
17:25:37 <slack1256> I was minimally productive in haskell on week (considering is my first language)
17:25:41 <Twey> Scheme sure, mostly.  Python's full of weird edge-cases and disjointed features, though.
17:26:12 <Peaker> Learning Python fully is hard, true.  But becoming minimally productive in Python is easier than in Haskell
17:26:22 <NemesisD> define productive
17:26:34 <Peaker> Can write simple programs that solve simple problems
17:26:38 <NemesisD> does productive mean solving euler problems or developing production systems
17:26:41 <yitz> Peaker: especially if you already know one or more other conventional languages
17:26:50 <Peaker> NemesisD, the former and something in between
17:26:51 <Twey> Hm, really?  What do you need to be minimally productive in Haskell, really?  An understanding of recursion and a basic grasp of do-notation?
17:27:13 <Peaker> Twey, you need to know quite a bit about types to understand the pesky error messages
17:28:14 <yitz> Peaker: the claim from people doing programming 101 courses using haskell is that it doesn't take longer than python when it is your first programming language.
17:28:55 <Peaker> yitz, I'm a bit suspicious of that, because people who know Haskell tend to be enthusiastic about it (I know I am) and may skew such results
17:29:01 <yitz> Peaker: the idea of python was to take some ideas that a lot of people are already familiar with and put them together is a simple and (fairly) coherent way.
17:29:19 <argiopeweb> Twey: One could make the argument that you can waltz around primitive recursion and restrict yourself to mapping over lists, at least for awhile.
17:29:35 <yitz> Peaker: could be. but i doubt there is much of a diffence
17:29:49 <yitz> *difference
17:30:16 <Peaker> yitz, and to focus on a particular form of "readability" which is a clean/consistent syntax and a limited set of "blessed-by-Guido" abstractions that everyone uses (which IMO brings the wrong kind of readability, where you can read every line, but it's harder to understand the whole)
17:30:54 <Peaker> also the syntax is well-designed to cope with the limited set of abstractions, so Python tens to be less line-noisy than Haskell, for example (instead, it is program-noisy)
17:31:10 <yitz> Peaker: sounds like a good assessment.
17:31:38 <yitz> Peaker: except my python code has become more haskell-like in those senses, now that i know haskell.
17:32:00 <yitz> Peaker: let's just say i can't help using lots of generators :)
17:33:18 <Peaker> ditto :)
17:33:52 <codesoup> imnsho, the reason 101 types say haskell doesn't take longer than python is because completely new people trip up on indentation on both languages, so they don't get anywhere with either.
17:34:07 <yitz> codesoup: haha
17:34:18 <codesoup> otoh, if you are used to block indentation of any kind from the usual suspects, indenting the same way will work just fine in either python or haskell
17:34:37 <codesoup> (even if it would be unidiomatic in haskell)
17:35:39 <yitz> codesoup: spj used block indentation in his "beautiful concurrency", where the main audience was expected to be people not familiar with haskell
17:35:52 <banister> .
17:36:12 <banister> yitz: does python have any nice operators for composing functions? like func1 * func2 ?
17:36:40 <yitz> banister: not general ones, but you can compose generators fairly painlessly
17:36:56 <banister> yitz: wow, compose generators? how does that work?
17:37:07 <dolio> yitz: SPJ write Haskell like few other people anyway.
17:37:48 <dolio> Writes, even.
17:38:00 <yitz> dolio: true, but the BC paper was definitley not focused on haskell syntax.
17:40:04 * hackagebot bindings-sqlite3 1.0.2 - Low level bindings to sqlite3.  http://hackage.haskell.org/package/bindings-sqlite3-1.0.2 (MauricioAntunes)
17:41:02 <Twey> banister: lambda x: f(g(x)) :þ
17:41:16 <Twey> banister: http://bugs.python.org/issue1506122
17:41:35 <banister> Twey: cool
17:41:58 <banister> Twey: ruby doesn't come up composition operators either, but i messed around with it the other day and came up with this: https://github.com/banister/funkify :)
17:42:12 <banister> sorry to spam
17:42:57 <yitz> haha - that python feature request was rejected for this reason: "The proposed code may be useful sometimes, but is not generic enough for the standard library.  For example, the f() function can only take one argument, when g() can accept any number."
17:43:07 <banister> mainly composing from left to right though: pass(3) >= mult(5) | add(1) | negate  #=> -16
17:44:51 <yitz> banister: syntactically there is no special syntax for composing either functions or generators. however, the idea that laziness makes functions more composible is also true to a certain degree for python generators.
17:45:14 <banister> yitz: how does laziness make functions more composable?
17:45:29 <yitz> banister: because you can ignore edge effects
17:45:39 <banister> yitz: interesting,can you give an example?
17:45:50 <cdk> @pl \f x y -> f x >> f y
17:45:53 <lambdabot> ap (flip . ((.) .) . ((>>) .)) id
17:45:53 <lambdabot> optimization suspended, use @pl-resume to continue.
17:46:04 <yitz> @pl-resume
17:46:10 <lambdabot> ap (flip . ((.) .) . ((>>) .)) id
17:46:10 <lambdabot> optimization suspended, use @pl-resume to continue.
17:46:43 <benmachine> :t liftM2 (>>) ($ x) ($ y) f
17:46:44 <lambdabot> (Monad m, FromExpr (m a)) => m a
17:46:48 <benmachine> err
17:46:48 <banister> yitz: what's an edge effect?
17:46:51 <benmachine> :t \f x y -> liftM2 (>>) ($ x) ($ y) f
17:46:52 <lambdabot> Monad m => (a1 -> m a) -> a1 -> a1 -> m a
17:46:56 <Twey> banister: You could probably manage to do something like composable(f) + g + h
17:47:39 <cdk> benmachine: that works, but is argueably worse than what I started with haha
17:47:41 <Twey> Or compose + f + g + h
17:47:51 <banister> Twey: you mean in the ruby lib or are you tlaking about osmething else?
17:47:56 <Twey> You can't monkey-patch built-in types in Python
17:47:58 <Twey> No, in Python
17:48:08 <benmachine> cdk: it's not really pointfree, even
17:48:34 <benmachine> :t (>>) `on` f
17:48:34 <lambdabot> (Monad m, Show a, FromExpr (m a1)) => a -> a -> m a1
17:48:40 <benmachine> :t \f -> (>>) `on` f
17:48:40 <lambdabot> Monad m => (a -> m a1) -> a -> a -> m a1
17:48:59 <banister> Twey: oh!
17:49:00 <cdk> ahh :)
17:49:07 <banister> Twey: cool
17:49:27 <banister> Twey: yeah, ruby's monkeypatching is both a blessing and a curse
17:51:15 <benmachine> monkeypatching always seemed like a mad idea to me
17:51:28 <benmachine> but maybe I should just be grateful I never needed it
17:51:49 <yitz> banister: well, for a contrived example, let's say you have a function to add 5 to a range of numbers, and a function to multiply by 2
17:52:00 <banister> benmachine: so long as you're working with a team of experienced programmers who dont go crazy with it, it's actually pretty cool
17:52:03 <banister> IMO
17:52:53 <benmachine> banister: but it does make insanity pretty easy to attain if your discipline falters even a ltitle
17:53:23 <NemesisD> anyone have any suggestions for cleaning this up? i think theres some sort of EitherT or EitherRT trick i could do here http://pastie.org/8138702
17:53:36 <banister> benmachine: yeah, or if you're using a third party library written by a maniac
17:53:54 <yitz> banister: in a strict language you can't just compose those two, because you have to check somehow that you are iterating over the same range.
17:54:24 <yitz> banister: and a list type is not the same thing, because that requires you to keep everything in memory.
17:54:45 <benmachine> NemesisD: consider using the 'either' function, either f g (Left x) = f x; either f g (Right y) = g y
17:55:33 <benmachine> NemesisD: this may also be a suitable application of "forever"
17:55:34 <benmachine> :t forever
17:55:35 <lambdabot> Monad m => m a -> m b
17:55:38 <benmachine> in Control.Monad
17:55:42 <yitz> banister: in haskell you can just say (*2).(+5). In python, you can combine two generators/iterators in a similar way, but the syntax is a lot hairier.
17:55:51 <NemesisD> benmachine: well its a bit weird because its in an IO monad and i only want to do something on Left, then do the same thing on both left and right
17:56:04 <NemesisD> that both thing being recurse
17:56:14 <benmachine> NemesisD: right, have forever take care of the recursion
17:56:35 <optimusbrine> so essentially, laziness makes functions more composable because you do not need the indirection of iterators. Lazy data structures are already iterators.
17:56:42 <Twey> banister: http://lpaste.net/90883
17:56:55 <benmachine> NemesisD: make use of the fact that return () >> m is equal to m by monad laws
17:57:05 <yitz> optimusbrine: sort of.
17:57:42 <cdk> NemesisD: I think you could do: forever $ (async action >>= waitCatch) >>= either handler (const $ return ())
17:58:18 <benmachine> cdk: yeah, that's roughly what I was thinking; note that >>= is left-associative so some of those parens are unnecessary
17:58:37 <cdk> benmachine: probably, just being explicit since its a one-liner
17:59:34 <cdk> that function cleans up pretty nice though
18:01:22 <NemesisD> hmmm
18:01:37 <NemesisD> the only part that could get any cleaner is the const $ return () idiom
18:01:48 <banister> Twey: dc sorry, that paste looks cool, but over my head as i dont know any python :)
18:01:54 <NemesisD> which i'll look into, i think i saw something that only maps over the left but leaves the right alone
18:03:24 <cdk> too bad the Functor instance is the opposite of what you want
18:03:26 <NemesisD> btw am i the only one that almost never uses >>=, favoring =<<
18:03:39 <hpc> i tend to avoid using either
18:03:46 <yitz> NemesisD: or this: either (handler e >>) id $ workForeverWith handler action
18:03:59 <hpc> i can usually find a nicer way to write those sorts of things with do-notation
18:04:10 <NemesisD> hpc: http://hackage.haskell.org/packages/archive/errors/latest/doc/html/Data-EitherR.html looks like it has that opposite functor instance
18:04:28 <benmachine> NemesisD: I use =<< frequently
18:05:06 <cdk> NemesisD: or you could return your error in Right. but thats probably not worth it just for this one function.
18:05:39 <yitz> NemesisD: oops, i meant: either (handler e >>) id result $ workForeverWith handler action
18:06:07 <NemesisD> yitz: where's e coming from
18:06:11 <NemesisD> oh i see
18:06:52 <external-reality> (>>=) or (=<<) or do -- it all depends on context.
18:07:36 <benmachine> I still don't see
18:08:10 <Twey> NemesisD: http://pastie.org/8138755
18:09:31 <yitz> NemesisD: oh ok, cdk is right, you're ignoring the value for Right, so there has to be a const somewhere
18:10:05 <yitz> benmachine: yeah :~
18:11:13 <Twey> You could use const () instead of return, but I don't think it makes much difference
18:12:34 <yitz> either (\e -> handler e >>) (const id) result $ workForeverWith handler action
18:13:41 <Twey> yitz: workForeverWith doesn't return an Either.
18:13:49 <Twey> Oh, never mind, misread.
18:15:45 <yitz> either (\e -> (handler e >>)) (const id) result $ workForeverWith handler action -- fixes syntax error
18:18:06 <cdk> :t \handler -> forever $ either handler void
18:18:06 <lambdabot> Functor f => (a -> f ()) -> Either a (f a1) -> b
18:18:16 <cdk> nope :(
18:18:30 <yitz> @type void
18:18:31 <lambdabot> Functor f => f a -> f ()
18:43:46 <v4hn_> Heya, what's the best way to get a full ghc+platform source build compiled and installed on a system without ghc at the moment?
18:44:10 <tdimiduk> @pl \a b -> length . filter (==Just b) . map (Map.lookup a)
18:44:13 <lambdabot> ((length .) .) . flip ((.) . filter . flip (==) . Just) . map . Map.lookup
18:44:13 <lambdabot> optimization suspended, use @pl-resume to continue.
18:44:25 <slack1256> v4hn_: do the boostrap processes
18:44:38 <slack1256> But I would argue that is better to install the binary if possible
18:45:19 <v4hn_> well installing binaries on source distributions is not appreciated normally...
18:45:35 <NemesisD> i think i golfed down that function pretty good: workForeverWith handler action = forever $ waitHandle =<< async action; where waitHandle = either handle return <=< waitCatch
18:46:03 <Twey> v4hn_: Grab a recent binary, use it to compile the source, then compile the platform?
18:46:04 <monochrom> http://www.haskell.org/ghc/download_ghc_7_6_3 has GHC binaries. skip the "Stop!" because clearly it doesn't apply to your situation.
18:46:16 <NemesisD> i tried to eta reduce (? not sure if i'm using that term right) away the "action" argument but that didn't go well, doubt it will be more readable
18:46:59 <monochrom> after you have GHC up, you can build the rest of Haskell Platform from source
18:47:04 <Twey> > (length *** length) ("workForeverWith handler action = forever $ waitHandle =<< async action; where waitHandle = either handle return <=<  waitCatch", "workForeverWith handler action = async action >>= waitCatch >>= either handler return >> workForeverWith handler action
18:47:05 <lambdabot>   <hint>:1:272:
18:47:05 <lambdabot>      lexical error in string/character literal at end of input
18:47:07 <gienah> v4hn_: it may depend on which source distribution this is
18:47:12 <Twey> > (length *** length) ("workForeverWith handler action = forever $ waitHandle =<< async action; where waitHandle = either handle return <=<  waitCatch", "workForeverWith handler action = async action >>= waitCatch >>= either handler return >> workForeverWith handler action")
18:47:12 <lambdabot>   (126,119)
18:47:46 <Twey> NemesisD: Mine's still shorter :þ  (and, I think, more readable — left to right)
18:47:49 <v4hn_> gienah: one which ghc was not yet ported to - Lunar-Linux
18:48:39 <v4hn_> The "Porting GHC to a new platform" page in the wiki mentions this is no longer supported and I should cross compile instead
18:48:46 <slack1256> V4hn: do as monochrom says, download the binary, install it use to compile ghc from source.
18:49:03 <slack1256> then the plataform.
18:49:07 <cdk> > length $ "workForeverWith handler action = forever $ async action >>= waitCatch >>= either handler (\_ -> return ())"
18:49:08 <lambdabot>   <hint>:1:102:
18:49:08 <lambdabot>      lexical error in string/character literal at character '_'
18:49:22 <cdk> > length $ "workForeverWith handler action = forever $ async action >>= waitCatch >>= either handler (const $ return ())"
18:49:22 <v4hn_> ok, I'll try that then
18:49:22 <lambdabot>   108
18:49:23 <Twey> NemesisD: I wouldn't remove either of those arguments; they're both used non-linearly and not in any pattern that's nicely packaged by the standard library, as far as I can tell
18:49:44 <cdk> if we're golfing, mines still shorter
18:50:06 <cdk> probably just because i dont have to write workForeverWith twice
18:50:17 <Twey> cdk: Yeah, ‘forever’ is a good idea
18:52:24 <Twey> > length "workForeverWith handler action = forever $ async action >>= waitCatch >>= either handler (<$ ())"
18:52:25 <lambdabot>   96
18:52:37 <cdk> nice :)
18:52:51 <Twey> Thank you!
18:53:07 <gienah> v4hn_: if those binaries don't work then you could try the Gentoo ones (search for arch_binaries in the ebuild), and the Gentoo ebuild might be useful for figuring out how to build it: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-lang/ghc/ghc-7.6.3.ebuild
18:54:49 <cdk> :t (<$ ())
18:54:50 <lambdabot>     Couldn't match expected type `f0 b0' with actual type `()'
18:54:50 <lambdabot>     In the second argument of `(<$)', namely `()'
18:54:50 <lambdabot>     In the expression: (<$ ())
18:54:53 <cdk> problem ^
18:55:34 <elliott> perhaps it is meant to be (() <$), aka void
18:55:53 <cdk> :t (<$ return ()) -- works
18:55:53 <lambdabot> (Monad f, Functor f) => a -> f a
18:56:08 <elliott> ...aka return? :P
18:56:32 <cdk> elliott: ahh, yes. and it actually doesnt work
18:56:40 <cdk> too much golfing, not enough type checking
18:56:53 <Twey> Oh, yes, sorry
18:57:01 <Twey> (() <$) is what I meant
18:57:11 <cdk> void doesnt work
18:57:14 <Twey> It's late/early :þ
18:57:24 <Twey> void is not defined outside λb, as far as I know
18:58:00 <elliott> Control.Monad
18:58:04 <elliott> or Control.Functor if htey fixed that
18:58:20 <Twey> Oh yeah, there it is
18:58:34 <Twey> > length "workForeverWith handler action = forever $ async action >>= waitCatch >>= either handler void" -- then
18:58:35 <lambdabot>   93
18:58:44 <cdk> Twey: that doesnt work unfortunately
18:58:53 <cdk> :t \f -> either f void
18:58:53 <lambdabot> Functor f => (a -> f ()) -> Either a (f a1) -> f ()
18:58:57 <Twey> No, needs a return
19:04:54 <Twey> > length "workForeverWith handler action = forever $ async action >>= waitCatch >>= either handler return"
19:04:55 <lambdabot>   95
19:05:10 <cdk> wont typecheck
19:05:19 <Twey> Does for me
19:05:22 <cdk> you need the (const $ return ())
19:05:30 <Twey> :t forever
19:05:31 <lambdabot> Monad m => m a -> m b
19:05:35 <Twey> Doesn't need to be ()
19:06:36 <cdk> :t \f -> either f return
19:06:37 <lambdabot> Monad m => (a -> m b) -> Either a b -> m b
19:06:53 <cdk> since the handler returns IO (), the Right value has to be a ()
19:07:21 <cdk> you need the const to ignore it and return () anyways
19:08:05 <erisco> @pl \(x,y) -> (,) <$> x <*> y
19:08:05 <lambdabot> uncurry ((((,) <$>) .) . (<*>))
19:08:28 <Twey> Ah, yeah, I was checking with a more liberal version of waitCatch
19:08:50 <erisco> @pl \x y -> (,) <$> x <*> y
19:08:50 <lambdabot> (((,) <$>) .) . (<*>)
19:09:00 <cdk> :t liftM2 (,) -- erisco
19:09:01 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
19:09:54 <pentace> :t liftA2 (,)  -- for Applicatives
19:09:55 <lambdabot> Applicative f => f a -> f b -> f (a, b)
19:30:11 * hackagebot helm 0.3.1 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.3.1 (ZackCorr)
19:34:13 <applicative> > length "workForeverWith handler = foreverK $ async >=> waitCatch >=> either handler return"
19:34:14 <lambdabot>   82
19:36:10 <applicative> "A functionally reactive game engine, with headgear to protect you from the headache of game development provided."
19:39:34 <erisco> an easier way to do this  (refer to 'qux')? http://lpaste.net/90884   does cartesian product of list of monoids in a way that both lists can be infinite
19:39:40 * optimusbrine loves imaginary hats
19:39:56 <erisco> it makes up a bijection between the two lists essentially, but the logic is ... well took me a while
19:40:34 <erisco> monoid is not required except for mushing the product together with mappend... could be a tuple as well
19:42:28 <erisco> some type cleanup could be done but my main question is if there is already a better way to do this with common Haskell libraries
19:50:30 <cdk> @hoogle foreverK
19:50:30 <lambdabot> No results found
19:50:58 <cdk> :t foreverK
19:50:58 <lambdabot>     Not in scope: `foreverK'
19:50:59 <lambdabot>     Perhaps you meant `forever' (imported from Control.Monad.Writer)
19:52:28 <applicative> foreverK is in the pipes empire somewhere
19:52:48 <applicative> foreverK z = forever . z
19:53:44 <cdk> ahh, i was trying to golf the "action" argument away with (>=>) but couldnt do it with forever
19:54:40 <erisco> there this is cleaner: http://lpaste.net/90885
19:55:39 <erisco> infCartProd (,) [1..] [1..]   for the magics :)
19:56:04 <cdk> why didnt you use liftM2 (,) instead of (,) <$> x <*> y?
19:56:19 <erisco> cdk, because I haven't used monads before :(
19:56:19 <cdk> and also mapMaybe instead of catMaybes . map?
19:56:34 <cdk> oh, i suggested it in channel. I guess you didnt see
19:56:51 <erisco> I know you did, but I don't understand monads, so :P
19:56:55 <erisco> I'll change it over blindly though
19:57:35 <cdk> liftM2 takes a function of 2 arguments, and turns it into a function of two monadic arguments
19:58:03 <cdk> infact, f <$> x <*> y is the definition for liftA2 f x y
19:58:05 <erisco> cdk, catMaybe looks like a combination of map and filter?
19:58:36 <cdk> hmm? you're using catMaybe atm. I say replace catMaybe . map with mapMaybe
19:58:49 <applicative> ah I see erisco, you are enumerating the rationals like Cantor
19:58:54 <cdk> > mapMaybe (\x -> if odd x then Just x else Nothing) [1..10]
19:58:54 <lambdabot>   [1,3,5,7,9]
19:59:17 <erisco> applicative, yeah, it is one way to form a bijection between the two infinite sequences
20:00:04 <erisco> applicative, but importantly it allows your program to exhaustively work on the cartesian product of two infinite sequences, without getting stuck on the first item of the first sequence
20:00:38 <applicative> yes, it doesn't seem to get stuck or collect any unpleasantness.
20:02:27 <carter> johnw whats the link to your ghc head mac nightlies? b6 on #haskell-game could use it :)
20:03:23 <erisco> cdk, both those suggestions worked nicely, thanks. http://lpaste.net/90886
20:03:52 <cdk> :t unzip -- erisco, you could also use this to get xss and yss from leveled
20:03:53 <lambdabot> [(a, b)] -> ([a], [b])
20:04:17 <carter> https://www.dropbox.com/sh/l24540a7ndwte01/NvlRh4_0IH/dist
20:04:28 <erisco> :D I was trying to initially avoid the leveled step, but the logic was too obscure for me
20:05:14 <erisco> unfortunately it makes the algorithm a tad less efficient than possible
20:06:05 <cdk> you could probably build the lists in paralle in level and avoid needlessly unzipping too, mind if I take a crack at it?
20:06:08 <cdk> parallel*
20:06:29 <erisco> go ahead :)
20:07:17 <erisco> it would be more optimal to remove the levelling step altogether, but it makes 're' hard to define -- at least I found it more difficult to figure out
20:08:05 <erisco> since by levelling the list, we don't take advantage of one list being significantly smaller... so we get O(n^2) instead of a more pleasant O(mn) which it should be
20:09:58 <cdk> http://lpaste.net/90886
20:12:54 <cdk> hmm, that doesnt work...
20:13:39 <erisco> I think I can also maintain lB in reversed form, which would save sticking ++[b] on the end. rather minor that one
20:15:48 <cdk> there, this typechecks: http://lpaste.net/90886 . should probably be more efficient
20:18:08 <erisco> cdk, and I removed the silliness of saving lB frontwards only to reverse it for the calculation
20:20:01 <cdk> @hoogle (a -> b -> Maybe c) -> [a] -> [b] -> [c]
20:20:01 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
20:20:21 <cdk> too bad theres no zipWithMaybe
20:20:34 <cdk> it would clean up step a little more
20:22:28 <cdk> step a = fmap (uncurry f) . catMaybes . zipWith (liftM2 (,)) a . reverse -- a little shorter
20:23:30 <erisco> liftA2 right?
20:23:55 <cdk> every Monad is an Applicative, so liftA2 and liftM2 both work in this case
20:24:40 <erisco> this is fairly nice now: http://lpaste.net/90889
20:24:56 <cdk> yes, looks good :)
20:25:32 <tac> Does does -XImpredicativeTypes do?
20:26:43 <erisco> the blemish logically is the O(n^2) complexity and that infCartProd (,) [1..] [] or infCartProd (,) [] [1..] will hang
20:27:29 <erisco> all due to the levelling :s I'll have to spend more time working out how to define 're' for ragged lists
20:28:27 <erisco> I can catch the empty list thing in the definition of infCartProd, so that is a fix for that ... just want the slightly better complexity then :)
20:34:50 <cdk> erisco: you could optimize level a bit further, but if you plan on trying to remove it entirely theres not much point
20:34:53 <pentace> tac: It allows you to do things like data X = X (forall x . x), IIRC
20:35:11 <tac> hmm
20:35:13 <erisco> cdk, yeah, removing it is the best optimization. anything else doesn't actually improve complexity
20:35:46 <monochrom> no, ImpredicativeTypes allowed something scarier. Just id :: Maybe (forall a. a->a)
20:36:05 <monochrom> data X = X (forall ...) is merely RankNTypes or something
20:36:05 <erisco> cdk, hm, maybe I can make an applicative interface for this. given one cartesian product, you can of course keep chaining them together
20:36:24 <cdk> level xs [] = (map Just xs, repeat Nothing); level [] ys = (repeat Nothing, map Just ys)
20:37:38 <erisco> cdk, with repeat I get an infinite list tho =\
20:37:59 <monochrom> even merely PolymorphicComponents
20:38:00 <erisco> the purpose is to make sure each list is of equal length
20:38:17 <cdk> ahh, you're right of course. nvm then
20:39:16 <monochrom> but GHC hasn't really supported ImpredicativeTypes for a long time.
20:52:58 <erisco> cdk, trivially made the Applicative interface too. thanks for the help :) g'night
21:04:44 <johnw> carter: hi
21:04:51 <johnw> @tell carter http://ghc.newartisans.com
21:04:52 <lambdabot> Consider it noted.
21:05:45 <joelteon> ghc-7.7
21:23:47 <anemator> hi all, i can't make sense of the line 'catch (runReaderT run st) (const $ return ())' in the 'roll your own irc bot' tutorial. any help would be greatly appreciated.
21:25:56 <ParahSail1n> @ty catch
21:25:57 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
21:26:00 <johnw> so, the catch ... part is swallowing exceptions
21:26:24 <johnw> the runReaderT part is executing run with st as the "environment", which run can "ask" to get at
21:26:50 <johnw> that code implies they are still using old exceptions, too
21:27:01 <ParahSail1n> @ty runReaderT
21:27:02 <lambdabot> ReaderT r m a -> r -> m a
21:28:39 <anemator> thanks guys.
21:28:49 <anemator> err folks*
21:29:00 <johnw> btw, "try" is a better thing to use than that catch trick
21:29:05 <johnw> try $ runReaderT run st
21:29:10 <joelteon> is there significant overhead introduced by liftIO?
21:29:54 <anemator> ok
21:30:16 <johnw> joelteon: why would you think so?
21:30:30 <joelteon> well, I'm just asking because I dream of a standard library where IO a is MonadIO m => m a instead
21:30:51 <joelteon> there, I said it
21:31:10 <johnw> ah, I think that's preferable unless the only thing that the function does is IO
21:31:39 <johnw> using MonadIO m is nice in that it "calls out" the points in your algorithm that rely on IO
21:31:57 <joelteon> yeah I just like not saying liftIO $
21:33:15 <johnw> I use MonadIO m _so that_ I have to say liftIO :)
21:34:28 <joelteon> yeah, but if you're already in MonadIO, you have to liftIO plain IO actions
21:40:11 <tac> joelteon: no one likes monad transformers. But they are what we have to work with (for now)
21:40:22 <joelteon> yeah well
22:01:34 <NemesisD> anyone in here use the tables library?
22:05:01 <johnw> oh, nice, an edwardk library that I haven't used yet!
22:05:56 <johnw> it's kind of like using persistent with the :inmemory: SQLite backend
22:06:27 <elliott> you can use it with acid-state
22:07:44 <ethoma> I ported some code from C to Haskell using the IO monad with IOArrays and IORefs for pretty much the whole thing. I am getting a 30x performance hit with only 7.5% of time in the GC. Is this typical for these structures?
22:07:46 <NemesisD> yeah ive actually used it with acid-state before, worked pretty well
22:08:48 <johnw> ethoma: is the code small enough to show via pastie?
22:09:09 <ethoma> No but I have a Github link if you like
22:09:41 <johnw> I'm really all qualified to answer your question, I was just asking because it's easier to look at code, so sure GitHub link would help
22:10:31 <ethoma> It is not much more than 1k lines of code. https://github.com/EricThoma/Veggie-chess. Readme is a bit outdated I believe.
22:12:58 <ethoma> Some of it is probably fairly bad - and I was going to clean it up until I saw the 30x performance hit, now I am trying to figure out that problem first. I think cleaning it up should give me 20-30% or so but not 30000%.
22:15:05 <carter> ethoma did you paste a link? my connections wonky
22:15:43 <carter> johnw thanks for the link, somehow i missed the lambdabot tell
22:18:07 <carter> ethoma did you post a link..?
22:18:29 <ethoma> The code has only been tested on 32 bit GHC Windows. idk if it will play nice with other systems as there is some assembly called from FFI. Typing perft 5 will make it run.
22:18:42 <ethoma> carter: yes https://github.com/EricThoma/Veggie-chess
22:18:52 <NemesisD> *slowly backs away*
22:19:58 <johnw> carter: sure thing
22:20:04 <carter> ethoma you included the .o files in the github
22:20:09 <ethoma> NemesisD: I know. There is also some very hacky C code from FFI that I need to port over but haven't yet because the pointer hacking is making my head hurt.
22:21:18 <carter> ethoma i'm not even seeing stuff that justifes asm
22:21:24 <ethoma> carter: I apologize. It was a personal repo and have been just using some bad .bat script to compile. I will be less lazy and try to fix that now.
22:21:30 <carter> you could just use the compiler intrinsics :)
22:21:36 <carter> ethoma its ok
22:21:42 <carter> just giving Feedback
22:21:52 <Ghoul_> is it possible to rewind an acid state in realtime
22:22:07 <carter> Ghoul_ i don't think its designed for that use case
22:22:18 <carter> ethoma GHC 32 bit has a pretty spare calling convention
22:22:27 <Ghoul_> rollback is probably a better word, not rewind.
22:22:34 <Ghoul_> Not possible?
22:22:50 <Ghoul_> I've had an app floating in the back of my head for a while that needs something like that, but i haven't found it yet
22:22:57 <carter> Ghoul_ not saying that, just saying i think its meant to support rollback, not real time probably
22:23:07 <carter> it might give you the design substrate
22:23:21 <carter> otoh, try and find out :)
22:23:54 <carter> ethoma soooo, one strength with GHC haskell is that its very good at inlining
22:24:06 <carter> ethoma could you try doing a build with -fllvm?
22:24:25 <ethoma> carter: I did try to rewrite the heavily used "lsb" function (least significant bit position) in regular Haskell. I took a slight performance hit. The overhead of FFI seems to not be too high then.
22:24:30 <NemesisD> isn't there a tardis monad or something
22:24:36 <carter> oh yeah
22:24:45 <Ghoul_> A tardis monad?
22:24:46 <Ghoul_> :D
22:24:58 <carter> ethoma : have you used profiling tools to see what the bottle neck is?
22:25:02 <Ghoul_> Oh wow, thats a real thing.
22:25:03 <carter> ghc has VERY good profiling tools
22:26:23 <Ghoul_> Bahaha the tardis monad is awesome.
22:27:34 <ethoma> carter: I would need to install llvm, which I had trouble doing earlier on Windows. I will try it on mac soon. Profiler output -pa here: http://lpaste.net/90891
22:28:16 <carter> darn, my connection is droppy
22:29:32 <Ghoul_> ethoma: does llvm not work for you on Windows either?
22:29:47 <Ghoul_> I can't make mine find llvm using ghc 7.6.3 even if it's in path
22:30:20 <carter> ethoma also might be handy to a  functional version for comparison
22:30:33 <carter> its actually really subtle to optmize imperative code well!
22:30:47 * carter writing some right now
22:31:54 <pharaun> tard monad?
22:31:56 <NemesisD> hmm lens' "update" functions can change types can't they?
22:31:57 <pharaun> *tardis
22:32:22 <edwardk> > (1,2) & _2 .~ "hello"
22:32:23 <lambdabot>   Not in scope: `_2'Not in scope: `&'
22:32:25 <pharaun> ha nice monad
22:32:26 <optimusbrine> it works if you use a a specific version of mingw gcc. I think currently it has to be <=4.4
22:32:31 <ethoma> Ghoul_: I couldn't even really find a version. All of them seemed to not be for Windows.
22:32:32 <edwardk> (yes)
22:33:22 <NemesisD> i hath summoned the edwardk
22:33:49 <dolio> comonad
22:33:55 <edwardk> =P
22:34:15 <ethoma> carter: Thanks for the help. I may try that later, but it would take some time - especially considering the difficulty of no mutability with a chess engine.
22:34:29 <stevejb> hello, I am having trouble with a certain mapping, described here; http://lpaste.net/8759572176555737088
22:34:38 <shachaf> edawrdk: Is lens back on /hilight?
22:34:40 <NemesisD> at sleepaway camp i heard that if you say comonad 3 times in a mirror, edwardk will appear behind you and help you with lens
22:34:51 <thoughtpolice> shachaf: did it ever get off?
22:35:03 <carter> ethoma might not make a big help
22:35:09 <carter> ethoma first try doing profiling :)
22:35:20 <carter> so you can figure out whats the slow part
22:35:27 <edwardk> if you say it 3 times on channel, edwardk will appear behind you and brain you over the head ;)
22:35:37 <carter> bing bing bing
22:35:43 <carter> went the textual client
22:35:58 <NemesisD> lol
22:36:04 <carter> "bah, too many pop up notifications" went the edwardk
22:36:31 <carter> "time to nerdsnipe folks with my newest of libs"
22:36:52 <carter> (they are very nice libs generally)
22:37:00 <NemesisD> edwardk: i was mentioning in the lens channel, i've got a data Watch i = Watch { _watchId :: i}; type NewWatch = Watch (), type EWatch = Watch ID
22:37:35 <NemesisD> given thaat lenses can type change, seems pretty easy to wrap insert' for something like create :: NewWatch -> Table EWatch -> (EWatch, Table EWatch)
22:43:57 <pentace> stevejb: "map (\p -> maybe (const default_value) id $ lookup p $ zip special special_nums) combos" as a first approximation
22:44:55 <stevejb> pentace: thank you. I think that that answered my real question which was that a maybe is necessary, since I cannot provably say that special is a subset of combos
22:45:15 * hackagebot HLearn-datastructures 1.0.0 -   http://hackage.haskell.org/package/HLearn-datastructures-1.0.0 (MikeIzbicki)
22:45:17 * hackagebot HLearn-approximation 1.0.0 -   http://hackage.haskell.org/package/HLearn-approximation-1.0.0 (MikeIzbicki)
22:47:24 <carter> ethoma that said: i'm totally unfamiliar with how to write nice chess code
22:50:54 <johnw> shachaf: can we upgrade lambdabot to the newest version of lens?
22:52:42 <ethoma> carter: Funny thing is: I just downloaded another chess engine written in Haskell of github. Mine is 20x faster than that one. So that is a factor of 600 off of C. Chess engines are a weak point for Haskell perhaps.
22:56:47 <edwardk> one can write a fast chess engine in haskell, it just won't be idiomatic haskell
23:28:45 <ethoma> edwardK: I haven't seen one yet. I just found one that is within a factor of 10 of my C engine and a factor of 20 of professional engines. My Haskell engine code reads like C code because it is in imperative monadic style sort of. I am going to do my best to get it as close to C as I can.
23:30:19 <ethoma> edwardK: I bet it is possible, but I will need to do a lot of hacking around with strictness and find unboxed IORefs and such. I have many more optimizations to do.
23:31:03 <Gracenotes> what is the basic algorithm you are using?
23:31:19 <edwardk> … and hence the resulting code won't be very "haskell" as I mentioned earlier.
23:32:36 <zRecursive> what's error ?    http://paste.lisp.org/display/138041
23:32:53 <zRecursive>     parse error on input `pickSSQ'
23:33:10 <mstksg> ethercro1: if your code is as c like as possible why don't you just develop for the c platform?
23:33:16 <mstksg> what advantage do you gain from haskell?
23:33:27 <Gracenotes> zRecursive: is the recursive call supposed to be in a do-block?
23:33:57 <zRecursive> Gracenotes: yeah
23:34:06 <mstksg> (just curious)
23:34:43 <Gracenotes> zRecursive: sure, okay, so put it in a do-block
23:35:02 <Taneb> Can any of Haste/ghcjs/UHC/whatever use WebGL as a drop-in replacement for OpenGL (is that even remotely a question I should ask?)
23:35:08 <zRecursive> Gracenotes: how about the inner do ?
23:35:42 <Gracenotes> all statements in a do-block need the same indentation.
23:36:14 <mstksg> sorry, edwardk, not ethercrol
23:37:00 <Gracenotes> (a statement can also have multiple lines, like that if statement, if it were in a do-block)
23:37:47 <zRecursive> Gracenotes: http://paste.lisp.org/display/138042
23:38:32 <roboguy_> zRecursive: I think you need all three dos
23:38:49 <Gracenotes> zRecursive: also, the last line in a do block (the most immediate issue) can't be a <- statement
23:39:30 <Gracenotes> This code looks like rather unidiomatic Haskell, with the recursion on count and also count==1, and the (!!), and the ++[..]
23:39:38 <zRecursive> "gr <- goodRed" raise error ...
23:40:25 <Gracenotes> As a consequence, it will also perform very badly if count is remotely large
23:40:40 <zRecursive> Gracenotes: count==1 needs special handling
23:40:58 <Gracenotes> zRecursive: so make a separate top-level case for it
23:42:02 <zRecursive> Gracenotes: yeah, but can we fix it in such a situation ?
23:42:09 <hamishmack> Taneb: GHCJS can't yet.  It will compile and run, but the FFI calls will fail.  If you want, you can add shims here https://github.com/ghcjs/shims/tree/master/pkg
23:42:26 <Taneb> Thank you, hamishmack
23:42:36 <Gracenotes> zRecursive: also, instead of using (!!) on okBlue in decreasing order, reverse it and pattern match on it
23:42:44 <Gracenotes> or something similar
23:43:22 <Gracenotes> there is also an issue that, even if you do have 3 do statements, as suggested by roboguy_, red will not be in scope in the last line
23:44:59 <roboguy_> yeah, that's a good point. you need to move that recursive call into the right scope. and like Gracenotes said, you should use a top-level definition to take care of count==1 which would probably simplify the do syntax nicely
23:45:46 <zRecursive> ok
23:50:12 <Gracenotes> zRecursive: http://lpaste.net/2334493417490350080
23:50:31 <Gracenotes> These are a couple of variants that, if not compiling, should be a bit closer
23:51:48 <Gracenotes> Note that (!!) is really to be avoided, and xs++[x] is also to be avoided. As a result, I've assumed that okBlue is reversed in the second function compared to the first, and also blue is at the front of return lists rather than end
23:52:46 <Gracenotes> Haskell lists can be very efficient if they're used as what they are, singly linked lists.
23:53:37 <Gracenotes> and safe, too. otherwise, no guarantees.
23:54:03 <zRecursive> Gracenotes: thanks for your suggestion !  As the count isnot too big, i need to make it work first
23:54:37 <Gracenotes> sure. structuring code the right way the first time will make it *much* easier to change later.
23:55:23 <Gracenotes> the more you move assumptions you make from your head (as in many imperative languages) to the compiler, the better your code can be both maintained and optimized! win-win
23:56:03 <Gracenotes> Anywho, that is just the particulars of do notation and indentation.
23:56:57 <zRecursive> Gracenotes: ok, the 1st step is up one level: http://paste.lisp.org/display/138043
23:57:12 <zRecursive> it still doesnot work though
23:57:51 <Gracenotes> 'does not work' is a bit vague
23:58:14 <Gracenotes> I would guess the issue might be line 5, put a $ after return
