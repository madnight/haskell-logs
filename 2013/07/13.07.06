00:09:05 <twomashi2> could someone show me how to stream lazily from stdin to an IO causing function that can process the lines (perhaps recursively) ?
00:10:38 <startling> twomashi2, do you really mean "lazily" or just "line-by-line"?
00:11:54 <twomashi2> really lazily; i need to consume it recursively, doing filtering and aggregations.
00:13:36 <wleslie> have I done something wrong? http://bpaste.net/show/38cWz30c7gFwVE8TvTpn/
00:52:23 <Kinnison> win 24
00:52:26 <Kinnison> oops
01:05:03 <circle> Let's say I wanted to make a tree with 5 branches on each node.
01:05:40 <circle> Is there any 'cleaner' way than just have an algebraic data structure with 6 arguments for the node part?
01:05:43 <circle> 5*&
01:06:18 <startling> nope.
01:06:43 <startling> circle, see http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
01:07:31 <startling> (Manuel says: Including one more declaration gives a segmentation fault.)
01:07:35 <circle> startling, I don't get it.
01:07:50 <startling> circle, that's how all the tuple types in GHC are defined
01:08:01 <circle> Hmm.
01:08:26 <circle> Could you give an example of a good tree data structure with 5 subtrees for each node? WHat's the best way to set that up?
01:08:49 <shachaf> That depends on why it has 5 subtrees.
01:09:09 <startling> data Five a = Five a a a a a
01:09:54 <startling> newtype Tree a = Tree (Five (Either (Tree a) a))
01:09:58 <circle> It needs to be recursive.
01:10:08 <circle> Hmm.
01:10:13 <circle> Yeah, that makes sense.
01:10:52 <startling> (you could use Free instead and get a lot of nice instances for free)
01:11:07 <circle> What's "Free"?
01:11:49 <startling> http://hackage.haskell.org/packages/archive/free/3.4.2/doc/html/Control-Monad-Free.html
01:12:12 <startling> you'd have newtype Tree a = Tree (Free Five a), I think
01:12:54 <startling> with a Functor instance for Five and GeneralizedNewtypeDeriving, you could derive (Functor, Applicative, Monad)
01:13:09 <circle> wpuld this work? data Tree a = Leaf | (Five a) Tree
01:13:16 <circle> wait, nvm
01:13:19 <circle> ignore.
01:13:23 <startling> haha k
01:13:37 <circle> data Tree a = Leaf | (Five Tree) a
01:13:51 <circle> data Tree = Leaf | Node (Five Tree) a
01:13:58 <startling> nope.
01:13:59 <circle> how about that second one?
01:15:03 <circle> Why wouldn't it owrk?
01:15:14 <startling> where's "a" from?
01:15:46 <circle> yeah, missed that out
01:15:57 <circle> add it as an argument to Tree
01:17:15 <startling> still looks pretty wron.
01:17:16 <startling> g
01:17:49 <circle> what's wrong?
01:18:26 <startling> what's a Leaf?
01:18:43 <startling> what's a Five Tree ?
01:36:41 <djwurtz> Does anyone else get an error when calling infix functions?
01:36:42 <djwurtz> for example: 2 'mod' 1
01:37:07 <shachaf> The syntax is: 2 `mod` 1
01:37:29 <shachaf> The function isn't an infix function, by the way. It's just a regular function being called in a special way.
01:37:54 <djwurtz> ohhhh
01:38:22 <shachaf> Also, when you ask a question like that, you should ideally say what the error was.
01:38:59 <djwurtz> thanks!
01:41:32 <Lethalman> hi
01:41:52 <Lethalman> I've installed ghc from git and ghc-pkg describe base says 4.7.0.0
01:42:05 <Lethalman> then I try to bootstrap cabal-install and requires base>=3 && base<4.7
01:42:18 <Lethalman> or better, the HTTP requires base<4.7
01:42:21 <Lethalman> so I can't bootstrap :S
02:01:41 <supki> Lethalman: why do you bootstrap cabal-install with HEAD?
02:01:59 <Lethalman> supki, because there's no guide about installing cabal 1.18
02:02:12 <supki> ?
02:02:26 <Lethalman> supki, there's no hacking guide
02:02:33 <Lethalman> supki, what should I do to install cabal 1.18?
02:03:16 <supki> I don't know, I've installed cabal git HEAD with ghc-7.6.3 just fine
02:03:21 <supki> but it's 1.17
02:04:10 <Lethalman> supki, ghc 7.6 is fine
02:04:23 <Lethalman> supki, but ghc 7.8 has base 4.7 which is the upper bound of HTTP package
02:04:34 <Lethalman> supki, see https://github.com/haskell/HTTP/pull/38 not being accepted
02:05:42 <supki> cabal-install should work even if it's built by older ghc
02:05:52 <supki> apparently I don't understand something :[
02:07:56 <Lethalman> supki, the HTTP package requires base<4.7
02:08:11 <Lethalman> supki, the HTTP package is bootstrapped by cabal
02:08:18 <Lethalman> supki, ghc 7.8 has base 4.7
02:08:24 <Lethalman> => cabal bootstrap fails :P
02:09:35 * Lethalman changing the dep manually
02:12:24 <Lethalman> same goes for the stm and unix package
02:12:29 <Lethalman> stm requires unix < 2.7 but unix is exactly 2.7
02:14:21 <Moggle> @src sequence
02:14:21 <lambdabot> sequence []     = return []
02:14:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:14:21 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
02:14:23 <Lethalman> ah no, cabal-install itself requires unix not stm sorry
02:14:24 <Lethalman> :S
02:19:53 <circle> startling, you defined the Five datastructure
02:20:01 <osa1> what is a primitive recursive function in haskell?
02:20:04 <circle> startling, Leaf is just one form a Tree can take.
02:20:23 <startling> circle, okay, but your Leaf is empty
02:20:39 <circle> startling, yes it is
02:20:45 <circle> startling, that's intentional.
02:22:46 <LordBrain> osa1, undefined is in the prelude
02:22:47 <LordBrain> heh
02:22:56 <LordBrain> not sure what you mean by 'primitive'
02:23:07 <LordBrain> is this a homework q?
02:23:45 <startling> circle: that's an odd tree
02:23:50 <Lethalman> supki, turns out I didn't need to bootstrap at all :P just cabal install Cabal.cabal and cabal-install.cabal :S
02:24:28 <startling> circle, anyway, my other point is that "Five Tree" is an incomplete type
02:25:08 <osa1> LordBrain: it's primitive in this sense: http://en.wikipedia.org/wiki/Primitive_recursive_function
02:25:32 <osa1> LordBrain: I wish it's a homework, we don't get homeworks like this in my school, we only get java stuff ...
02:27:18 <LordBrain> that page lists addition as an example
02:29:25 <LordBrain> it says most functions are primitive recurssive
02:32:35 <Gracenotes> in the realm of Turing machines, the set of languages which require Turing machines to recognize, and not just linear bounded automata, is quite difficult to construct; you need some weird diagonalization arguments.
02:34:17 <Gracenotes> It seems that a similar thing is the case of primitive recursive vs. all recursive.
02:36:23 <Gracenotes> (of course, all universal Turing machines have to be Turing machines, but that definition is cheating...)
02:43:07 <mr-> Gracenotes: you are saying it is very difficult to determine the set of primitive rec. functions?
02:58:18 * Lethalman in cabal hell with all dependencies broken
03:11:36 * hackagebot hmatrix 0.15.0.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.15.0.0 (AlbertoRuiz)
03:13:26 <Pip> Do you guys use any vim haskell plugin?
03:28:10 <mr-> Pip: Yes, vim-hdevtools
03:29:52 <mr-> Pip: merijn has a nice vimrc online, if you are looking for inspiration https://github.com/merijn/dotfiles/blob/master/vimrc
03:32:38 <adnap> Hey
03:34:43 <Pip> mr-, How did you install it?
03:34:56 <mr-> Pip: using vundle
03:38:27 <adnap> > runStateT (do { get; liftIO $ putStrLn "hi" }) 0
03:38:28 <lambdabot>   No instance for (Control.Monad.IO.Class.MonadIO m0)
03:38:28 <lambdabot>    arising from a use o...
03:39:44 <acube> adnap: If you run that in GHCi, it works
03:44:13 <adnap> In, http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html, I don't understand how "boss.health -= 10" is a "StateT Game IO ()"
03:47:25 <haasn> :t ?boss.?health -= 10
03:47:26 <lambdabot> parse error on input `?'
03:47:38 <haasn> :t \boss health -> boss.health -= 10
03:47:39 <lambdabot> (Num a, MonadState s m) => (b -> s -> Mutator s) -> ((a -> Mutator a) -> b) -> m ()
03:47:55 <byorgey> oh, is lens back in lambdabot now? yay!
03:48:04 <byorgey> @type (-=)
03:48:05 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
03:48:13 <byorgey> adnap: does the type of (-=) make sense?
03:48:29 <byorgey> it takes a setter and a value of type a, and produces a monadic computation for some state monad
03:48:41 <haasn> assuming ‘boss’ has s ~ Game, ie. is something like Lens Game Boss; then that works via the Monad m => MonadState Game (StateT s m) instance
03:49:05 <haasn> err
03:49:08 <haasn> MonadState s (StateT s m)
03:49:42 <byorgey> adnap: perhaps your question is how (.) can possibly be used to compose 'boss' and 'health'?  That is the magic of the lens library.  To understand it I recommend watching the video of edwardk's NY Haskell group talk.
03:50:07 <adnap> No
03:50:48 <FreeFull> :t _1
03:50:49 <lambdabot> Not in scope: `_1'
03:50:53 <byorgey> adnap: which are you saying 'no' to?
03:51:04 <haasn> byorgey: the question, presumably
03:51:18 <haasn> oh, wait
03:51:20 <haasn> you asked two
03:51:28 <byorgey> I have done enough presuming, I want to hear adnap explain their question more fully now =)
03:51:36 <haasn> apologies
03:52:18 <adnap> I understand how (.) composes lenses. I don't understand the type of (-=). It seems like the types for the library are different from what I was taught in this channel, such as with https://gist.github.com/ion1/5924946
03:52:49 <haasn> adnap: (-=) pulls everything into the State monad environment as well
03:52:59 <haasn> :t (-~)
03:52:59 <byorgey> adnap: different how?
03:53:00 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
03:53:03 <haasn> perhaps this one will make more sense?
03:53:16 <haasn> (-=) is just (-~) + modify
03:53:24 <adnap> I don't know these.
03:53:42 <byorgey> adnap: what don't you understand about the type of (-=) ?
03:53:50 <adnap> I know 1_, over, view, traverse, and both
03:53:54 <haasn> lens -~ num  = over lens (subtract num)
03:54:03 <haasn> it's just a convenience function
03:54:05 <haasn> think of it like over
03:54:17 <adnap> I hate the lens typedefs
03:54:20 <adnap> I hate stab
03:54:27 <arkeet> I love stab
03:54:29 <haasn> they're what make it so general, unfortunately
03:54:48 <supki> stab is better than abcd at least
03:54:51 <arkeet> true
03:55:05 <adnap> (a -> f b) -> (s -> f t) makes way more sense
03:55:19 <arkeet> l -~ x  =  over l (subtract x)
03:55:27 <arkeet> l -= x = modify (l -~ x)
03:55:28 <arkeet> easy
03:55:47 <adnap> Okay. I don't understand this ASetter stuff
03:55:55 <haasn> ASetter = something you can use ‘over’ on
03:56:02 <haasn> basically, it means you can input a Setter, a Traversal, a Lens, w/e
03:56:12 <adnap> And what is this? :t over... over :: Profunctor p => Setting p s t a b -> p a b -> s -> t
03:56:14 <haasn> but not a Getter, for example
03:56:19 <arkeet> don't worry about the Profunctor stuff.
03:56:22 <arkeet> just pretend p = (->)
03:56:41 <adnap> It would be nice if the types in the library were like in https://gist.github.com/ion1/5924946
03:56:47 <adnap> I can understand ^
03:56:51 <haasn> yeah, the Profunctor is just a generalization of (->) (to allow for indices as well, ie. instead of a -> f b you can have i -> a -> f b)
03:56:51 <arkeet> the types you should think about are in the documentation.
03:56:56 <adnap> The library is full of nonsense typedefs
03:57:14 <arkeet> have you looked at the documentation?
03:57:17 <haasn> the typedefs make it easier for a programmer to look at them and understand what it's supposed to represent, imo
03:57:17 <arkeet> for example, where it says  over :: Setter s t a b -> (a -> b) -> s -> t
03:57:52 <haasn> better to read “ASetter” and know “a setter is expected here” than to read “Contravariant f => (a -> f b) -> s -> f t” or whatever
03:58:13 <haasn> oh, it's not even that general; (a -> Mutator b) -> s -> Mutator t
03:58:18 <arkeet> there's a reason these extra type signatures are in the documentation.
03:58:42 <haasn> ah, and Contravariant is used for reading
03:58:46 <adnap> I will stop complaining. I want to understand the answer to my question
03:58:59 <haasn> which question?
03:59:24 <adnap> In, http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html, I don't understand how "boss.health -= 10" is a "StateT Game IO ()"
04:00:12 <arkeet> well, boss.health is a Lens' Int Game
04:00:17 <arkeet> right?
04:00:21 <haasn> Lens' Game Int
04:00:26 <arkeet> i.e. Lens Int Int Game Game
04:00:28 <arkeet> are you sure?
04:00:33 <adnap> First, can you make a "StateT Game IO ()" with a "Game -> ((), Game)"?
04:00:48 <arkeet> haasn: the "inner" type comes first.
04:01:04 <arkeet> oh well.
04:01:11 <arkeet> wait.
04:01:14 <arkeet> I'm backwards.
04:01:22 <arkeet> those type synonyms are backwards .:p
04:01:23 <arkeet> ok.
04:01:35 <adnap> Hey, maybe it's 'cause stab is confusing
04:01:42 <haasn> I just think of it as going from left to right, the same way you compose them
04:01:44 <arkeet> no, I just thought it was abst for some reason.
04:02:00 <haasn> how can you forget “abst” <-> “stab” when they have such memorable names? =)
04:02:05 <FreeFull> adnap: Yes, you can
04:02:10 <arkeet> I had in mind (a -> f b) -> (s -> f t)
04:02:12 <FreeFull> :t state
04:02:13 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
04:02:29 <haasn> arkeet: they are that way
04:02:31 <adnap> Alright, so somehow a Lens is like a "Game -> ((), Game)"?
04:02:36 <arkeet> haasn: I know. I was just confused.
04:02:39 <arkeet> adnap: no
04:02:52 <haasn> a Lens Game Int is like Game -> (Int, Int -> Game)
04:02:53 <arkeet> adnap: let's start from the inside.
04:02:58 <Aetherspawn> When does windows get 7.6.2 ?
04:03:17 <FreeFull> @let import Control.Lens.Lens
04:03:18 <arkeet> Aetherspawn: ghc?
04:03:19 <lambdabot>  Defined.
04:03:20 <adnap> Wanna take it to #haskell-lens?
04:03:22 <arkeet> Aetherspawn: windows already has 7.6.3
04:03:27 <FreeFull> :t _1
04:03:28 <lambdabot> Not in scope: `_1'
04:03:35 <adnap> :t 1_
04:03:35 <arkeet> adnap: that's probably a good idea.
04:03:36 <lambdabot> Pattern syntax in expression context: _
04:03:42 <haasn> @let import Control.Lens.Tuple
04:03:43 <lambdabot>  Defined.
04:03:44 <haasn> :t _1
04:03:45 <lambdabot> (Functor f, Control.Lens.Internal.Indexed.Indexable Int p, Field1 s t a b) => p a (f b) -> s -> f t
04:03:48 <Aetherspawn> Oh, theres a 2013 release I missed
04:03:50 <Aetherspawn> neat!
04:03:58 <arkeet> oh, you're talking about the platform.
04:04:06 * adnap goes to #haskell-lens
04:04:13 <haasn> sadly _1 is no longer a good first introduction due to the overly generalized type signature =P
04:04:55 <adnap> I disagree. I understood it with https://gist.github.com/ion1/5924946
04:05:06 <haasn> adnap: yes, that's a good example
04:05:11 <haasn> adnap: I mean the _1 in lens
04:05:21 <haasn> as in, you can't :t _1 and have it make a lot of sense
04:05:24 <adnap> Well, I hope it's the same thing, but more general
04:05:27 <haasn> it is
04:05:37 <adnap> Yes, this is why I hate the lens documentation currently
04:05:56 <adnap> I have been taught "simple" lenses in here, and the documentation is incomprehensible to me
04:06:05 <haasn> but the documentation gets it right
04:06:09 <haasn>  _1 :: Lens (a,b) (a',b) a a' -- from the documentation
04:06:10 <adnap> And the typedefs seem to obfuscate more than help
04:06:32 <arkeet> I've moved to #haskell-lens. you should too
04:16:37 * hackagebot llvm-general 3.2.4.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.4.0 (BenjaminScarlet)
04:16:39 * hackagebot llvm-general 3.3.4.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.4.0 (BenjaminScarlet)
04:18:03 <acube> Should I use GHC.Generics or syb?
04:18:48 <haasn> (what does lens use for Data.Data.Lens ?)
04:19:03 <acube> Data.Data.Lens uses syb I think
04:19:35 <luite> not syb, but Data.Data / Typeable yeah
04:19:38 <haasn> oh, Data.Data from base
04:20:08 <Pip> mr-, I have installed all of them, so how to make vim-hdevtools work with vim?
04:20:32 <acube> When should one use Data.Data / Typeable and when GHC.Generics then?
04:21:19 <evancz> User cutsea110 was here a couple days ago with a problem using "regex-pcre-builtin" http://ircbrowse.net/browse/haskell?events_page=455928 http://webcache.googleusercontent.com/search?q=cache:http://hpaste.org/raw/90389
04:21:23 <evancz> was there any resolution?
04:26:26 <evancz> ah, found it on stack overflow: http://stackoverflow.com/questions/17361047/compiling-libpandoc-and-undefined-reference-to-utf8-table4-in-regex-pcre-builtin
04:34:39 <mr-> Pip: look at the vimrc I pointed you to. It has some nice keybindings. e.g. tab gives you the type of what is under your pointer
04:35:10 <mr-> s/pointer/cursor/ #maybe
04:35:13 <Pip> mr-, I did exactly what this tells to do but still don't work ----> https://github.com/bitc/vim-hdevtools/blob/master/README.md
04:35:40 <mr-> what do you mean, "don't work" ?
04:35:46 <Moggle> @src newTVarIO
04:35:46 <lambdabot> Source not found. You type like i drive.
04:35:48 <Moggle> alas.
04:36:06 <Pip> mr-, Alright, how to tell if hdevtools is working?
04:36:24 <Moggle> i suppose it's just newTVarIO = atomically (return newTVar)
04:36:32 <Pip> I also have Syntastic plugin installed through pathogen
04:37:04 <haasn> Moggle: in theory, yes
04:37:11 <haasn> or something like atomically . newTVar at least
04:37:20 <haasn> Moggle: the main difference is that you can unsafePerformIO it
04:37:21 <supki> Pip: did you add hdevtools as syntax checker?
04:37:23 <mr-> Pip: open a haskell file, move your cursor to somewhere interesting, and do :HdevtoolsType
04:37:28 <haasn> if you try doing that with atomically, you'll get an exception
04:37:41 <Moggle> intriguing, haasn
04:38:03 <Pip> E492: Not an editor command
04:38:03 <seliopou> are module exports—e.g., `module A ( module B, … ) where …`—not affected by import qualified? i.e., if I do something like `import qualified A as A`, then names from B can't be accessed as `A.b`?
04:38:16 <Pip> supki, How to do that?
04:38:41 <supki> Pip: oh, I think the problem is something else then
04:38:49 <supki> Pip: what does  which hdevtools  say?
04:39:00 <Pip> damn
04:39:11 <Pip> I forgot to add hdevtools to my $PATH
04:40:45 <Pip> so how to check where hdevtools is installed ?
04:40:50 <Pip> I installed it with cabal
04:41:03 <supki> ~/.cabal/bin probably
04:41:04 <mr-> Pip: probably ~/.cabal/bin/
04:41:10 <Pip> right
04:51:26 <Pip> mr-, Alright, so how to make syntastic to work with vim to instantly check syntax?
04:53:23 <mr-> Pip: I don't know, I don't use that
04:54:48 <luite> Pip: you can use hdevtools with that
04:55:05 <Pip> Understood
04:57:25 <supki> Pip: I think you need to tell syntastic that you want to use hdevtools as syntax checker
04:57:34 <supki> i.e. https://github.com/supki/.dotfiles/blob/master/core/vimrc#L240
04:59:20 <Pip> supki, And it's supposed to be checking syntax instantly and automatically, right?
04:59:56 <supki> on buffer saves
05:07:37 <Pip> Is there any debugger for haskell?
05:08:46 <luite> Pip: GHCi has a debugger
05:08:57 <luite> but i don't think it's used that much
05:10:00 <Pip> Why?
05:11:12 <luite> i think most people try to split up code in small enough blocks so that direct testing in GHCi is possible, just evaluating some expressions, or running things through quickcheck
05:44:52 <acube> Why is Rep a of kind * -> * in GHC.Generics? There is this p parameter everywhere, that seems unused
05:45:27 <acube> Hmm, except in Par1
05:47:43 <isomorphic> hey is there some type of 'safe' peek for Foreign.Ptr - the standard one seems to be happy to dereference null (which I can obviously fix) - not sure if that's something that somebody else has fixef
05:48:39 <elliott> isomorphic: you might be able to stop it dereferencing null but that wno't stop it dereferencing 123 or 2948734 or any other random pointer you haven't allocated
05:48:57 <lasticot> Hi everyone! How do I link the state monad module when compiling with ghc ?
05:49:16 <elliott> lasticot: what GHC version?
05:49:24 <elliott> "ghc foo.hs" should work just fine in any vaguely recent GHC
05:49:33 <elliott> if you have something ancient you might ned "ghc --make foo.hs"
05:49:49 <lasticot> eliott: 7.4.1
05:50:54 <isomorphic> elliott:   True.   The stuff that I'm dereferencing is generated on the C side of an FFI - so, admittedly I'm relying on its correctness.   Are you saying I should perhaps be trapping the signal?
05:51:35 <elliott> well, I would try and construct your program so it never even thinks about dereferencing NULL in the first place :)
05:52:37 <isomorphic> Well, I was thinking I'd check if I'd been handed NULL by the C side, and avoid dereferencing that…. can you suggest anything else?
05:52:53 <elliott> why is the C side giving you NULL?
05:53:20 <elliott> I mean, ok, casing on nullPtr might truly be the reasonable thing here, but I'm curious as to where it's coming from in the first place
05:53:32 <isomorphic> that's the way the interface is defined - it hands back null to indicate lack of a value
05:54:13 <elliott> ok, then I'd compare to nullPtr. but I wouldn't see this as a "safe deference" so much as not dereferencing it when it's not actually a pointer
05:54:29 <elliott> I might try and turn it into a Maybe value ASAP too, so I don't have to remember this.
05:57:06 <lasticot> elliott: is it possible that the haskell package for ubuntu doesn't contain this module?
05:57:54 <elliott> lasticot: ah. I think so.
05:58:01 <elliott> lasticot: you might wish to consider installing the haskell-platform package
05:58:09 <elliott> which comes with a good set of popular libraries.
05:58:24 <lasticot> elliott: ok thank you :-)
06:48:44 <kartlos> I'm trying to read large binary files, I want to read/parse the file and the do things like sort data and print it out again, would you recommend using Lazy ByteStrings or Strict ByteStrings, or maybe some other data type?
06:53:51 <ab9rf> kartlos: attoparsec?
06:55:29 <kartlos> ab9rf: thanks, this only uses strict bytestrings, so are those more efficient than lazy bytestrings?
06:55:52 <ab9rf> eh, that's a nontrivial question
06:57:18 <ab9rf> also, attoparsec has lazy bytestring support, and also supports incremental consumption
07:07:00 <kartlos> ab9rf: are there some examples of efficient attoparsec usage?
07:16:41 * hackagebot reactive-io 0.1 - IO-oriented FRP library  http://hackage.haskell.org/package/reactive-io-0.1 (RomanCheplyaka)
07:23:10 <kartlos> ab9rf: thanks for the attoparsec suggestion, looks like it's exactly what I need :)
07:29:05 <HugoDaniel> :)
07:34:21 <watermind> I've played with types and kinds quite a bit, but now this is confusing me...
07:34:27 <watermind> from https://typesandkinds.wordpress.com/2012/12/01/decidable-propositional-equality-in-haskell/
07:34:52 <watermind> data Vec :: * -> Nat -> * where  -- so Nat is a kind
07:35:06 <watermind> later on
07:35:10 <watermind> boolEq :: Nat -> Nat -> Bool
07:35:20 <watermind> but isn't Nat a kind and Bool a type?
07:35:42 <FreeFull> watermind: When you're doing dependent typing, the boundary between kinds and types gets blurry
07:36:05 <watermind> FreeFull: I get that is true in Agda, but in haskell I thought there was more of a separation
07:36:14 <elliott> watermind: it's using the DataKinds extension
07:36:18 <elliott> which lifts every type to a kind automatically.
07:36:26 <watermind> FreeFull: in dependent typing there's also a blury line between types and values but not in haskell
07:36:37 <elliott> (when there is ambiguity between a type name and a constructor for a type lifted to a kind, you say 'Constructor for the lifted version)
07:36:39 <watermind> elliott:  oh so here Bool is being lifted
07:36:42 <elliott> no
07:36:43 <elliott> Nat is
07:36:47 <watermind> :/
07:36:57 <elliott> Nat is a regular type that gets automatically lifted to a kind
07:37:01 <elliott> so data Vec :: * -> Nat -> * works
07:37:03 <watermind> right I get that
07:37:17 <watermind> just not why,  boolEq :: Nat -> Nat -> Bool     work
07:37:18 <watermind> works
07:37:21 <watermind> wait
07:37:25 <elliott> because Nat is a type...
07:37:28 <watermind> right
07:37:29 <watermind> argh
07:37:32 <elliott> why does String -> String -> Bool work? :)
07:37:48 <watermind> right right I totally forgot it still denoted a type
07:38:08 <watermind> I just mentally lifted it to a kind and forgot about the rest
07:38:16 <watermind> this overloading makes my brian hurt
07:38:19 <watermind> brain
07:41:32 <asante> i'm just working through http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell when i try to compile the first knapsack solution for the profiling version, ghc complains about "Could not find module `Test.QuickCheck'" - but this is installed and i can run the quickcheck tests from within ghci
07:41:37 <bxc_> should i be able to add a "me too" comment onto http://hackage.haskell.org/trac/hackage/ticket/955 ?
07:41:59 <Peaker> asante, which version of quickcheck do you have?
07:42:13 <asante> Peaker: 2.6
07:43:48 <asante> oh, i just realised that importing Test.Quickcheck from wihthin ghci also won't work, but loading the .hs file does!
07:44:01 <Peaker> asante, note QuickCheck is case sensitive
07:45:13 <asante> ok thanks. that was the error in ghci.
07:45:19 <asante> but ghc still wont compile..
07:45:28 <Peaker> asante, maybe you're using different ghc versions in the two cases?
07:45:35 <Peaker> do you have more than one ghc version installed?
07:46:56 <asante> Peaker: doesn't seem so. ghci says 7.6.3, ghc -v also
07:48:06 <Peaker> asante, can you paste the exact ghci session that worked, and the exact ghc command + file you're building that didnt?
07:51:59 <asante> is hpaste down?
07:53:02 <asante> Peaker: http://ideone.com/exrY2S
07:53:30 <asante> ghc -O --make -prof -auto-all -o hgth hgth.hs
07:53:46 <asante> ghci:   :l hgth.hs
07:53:59 <Peaker> asante, -prof -auto-all requires quickcheck to be installed with profiling
07:54:15 <asante> ah nice ok thanks
07:54:25 <Peaker> asante, you can change ~/.cabal/config to enable library-profiling: True
07:54:44 <Peaker> asante, then nuke your ~/.ghc and reinstall everything - you'll get profiling versions of everything
07:54:47 <asante> i thought i had just recompiled my haskell libs with profiling, but quickcheck still isnt
07:55:24 <Peaker> asante, a profiling version of any lib requires the profiling versions of all its deps, recursively. There's no good way to install all those except nuking ~/.ghc and reinstalling everything after changing ~/.cabal/config, unfortunately
07:56:27 <asante> ok. i thought gentoo's use flags would manage that, when setting profile, but it seems, as if some where left over.
08:03:32 * bxc_ grrs at cabal from git telling him to use an unreleased version of ghc
08:05:02 <lasticot> I receive this error at compilation: "Not in scope: type constructor or class `State'". But did put the line: "import Control.Monad.State"
08:05:17 <lasticot> I don't understand where is my mistake.
08:08:35 <lasticot> sorry about earlier, I found my mistake ...
08:16:05 <namoamitabuddha> type Listm x = [x]
08:16:12 <namoamitabuddha> type Listl h x = h x
08:16:20 <namoamitabuddha> [3] :: Listl Listm Int
08:16:29 <namoamitabuddha> Why is that illegal?
08:16:42 <elliott> it is legal if you turn on LiberalTypeSynonyms, I think.
08:17:06 <elliott> but generally, you're just not allowed to pass a partially-applied type synonym
08:17:20 <elliott> type Listm = []
08:17:22 <elliott> should let it work too
08:17:25 <pentace> Hey! I've ported my attoparsec parser to parsec and now some of the parsers fail on some inputs while some still work. Is there anything special you have to watch out for when porting from attoparsec?
08:17:57 <namoamitabuddha> instance Functor [] where fmap = map
08:18:14 <namoamitabuddha> It's not something like Functor [a]
08:18:23 <elliott> hmm?
08:18:39 <elliott> [a] is sugar for [] a
08:18:42 <elliott> at the type level
08:18:52 <namoamitabuddha> Oh, no
08:19:11 <namoamitabuddha> I mean, Functor [] <- that's a type constructor
08:19:22 <elliott> [] is a type constructor, sure
08:19:28 <namoamitabuddha> However, if: type Listl h x = h x
08:19:37 <namoamitabuddha> h should be a type, not a type constructor
08:19:39 <namoamitabuddha> right?
08:20:25 <mike4_> does haskell compare in performance speed to C or C++?
08:20:39 <byorgey> namoamitabuddha: no, in that case h must have kind  * -> *
08:20:47 <byorgey> i.e. it must be a "type constructor"
08:20:50 <haasn> Haskell wasn't a very fast runner, I doubt he could approach the speed of light
08:21:16 <Demos> haskell can be fast, but you have to optimize it
08:21:39 <namoamitabuddha> byorgey: Oh
08:21:58 <namoamitabuddha> byorgey: However, what about: type Listm x = [x]
08:22:03 <mike4_> it runs like python and java?
08:22:05 <namoamitabuddha> byorgey: It's also a type-constructor?
08:22:10 <byorgey> namoamitabuddha: in that case   x :: *
08:22:16 <byorgey> and  Listm :: * -> *
08:22:31 <byorgey> namoamitabuddha: however, you are not allowed to pass a type synonym like  Listm  as a bare argument to something else.
08:22:41 <byorgey> namoamitabuddha: type synonyms must always be applied to all their arguments
08:22:47 <byorgey> for technical reasons
08:22:54 <mike4_> does haskell run as fast as python.
08:22:58 <mike4_> ?
08:22:58 <byorgey> mike4_: usually much faster.
08:23:06 <namoamitabuddha> byorgey: However, Listl [] Int works
08:23:23 <mike4_> but slower than c and c++
08:23:27 <namoamitabuddha> byorgey: I don't know why.
08:23:32 <haasn> (how fast are pythons actually?)
08:23:38 <byorgey> namoamitabuddha: because [] is not a type synonym.
08:23:41 <namoamitabuddha> mike4_: What do you mean by "slower than C or C++"
08:23:49 <namoamitabuddha> byorgey: I see.
08:23:52 <byorgey> mike4_: ultimately, it does not make a lot of sense to compare speeds of languages.
08:24:00 <luite> haasn: african or european?
08:24:12 <byorgey> mike4_: can you answer this question: "which uses less words, Hebrew or Japanese?"
08:24:14 <haasn> luite: I don't know that!
08:24:59 <byorgey> or this one: "which is faster, cars made of metal or cars made of plastic?"
08:25:23 <mike4_> well does Haskell apps run slower than C and C++?
08:25:32 <Demos> no, not usually
08:25:50 <namoamitabuddha> I think the following question is okay.
08:25:51 <mike4_> faster?
08:26:10 <Demos> maybe... in the end it all depends
08:26:25 <Demos> the one thing haskell is not good at is hard real time apps
08:26:55 <Eduard_Munteanu> For the same algos, they can be slower than C. But how much? Maybe the extra development time can be used to gain performance some other way instead of plumbing C code.
08:27:09 <elliott> mike4_: you've asked an awful lot of questions comparing Haskell to other languages (or outright insulting Haskell) in your time here. is that your only intention in this channel?
08:27:16 <byorgey> mike4_: would you like to learn Haskell?
08:27:18 <byorgey> @lyah
08:27:18 <lambdabot> Unknown command, try @list
08:27:22 <byorgey> @where lyah
08:27:22 <lambdabot> http://www.learnyouahaskell.com/
08:27:25 <byorgey> @where rwh
08:27:25 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:27:29 <byorgey> mike4_: start here ^^^
08:27:44 <byorgey> then you can see for yourself how the performance of your Haskell programs stacks up.
08:28:24 <namoamitabuddha> Theoretically, comparing two languages is nonsense.
08:28:41 <pentace> Also the speed really depends on the specific compiler
08:28:42 <haasn> depends on how different they are
08:28:58 <hashcat> mike4_: i suggest you school of haskell at fpcomplete.com
08:34:23 <mike4_> ok
08:40:06 <lasticot> I'm trying to code a snake game, the code I'm goining to link is false, but I wanted to have your opinion on the overall architecture. Given that how much I am struggling, the problem may come from the approach itself.
08:40:08 <hpaste> lasticot pasted “gameSkeleton” at http://paste.tryhaskell.org/90710
08:40:36 <hashcat> mike4_: i think Haskell has a better property for optimizing because of good math association
08:41:43 * hackagebot Hclip 0.1.0.0 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-0.1.0.0 (JensThomas)
08:56:46 <pentace> Another try: I've ported my attoparsec parser to parsec and now some of the parsers fail on some inputs while some still work. Is there anything special you have to watch out for when porting from attoparsec?
08:58:22 <elliott> I think attoparsec automatically "try"s and Parsec doesn't or something.
08:58:27 <elliott> so you might have to turn (p <|> q) into (try p <|> q).
08:58:29 <elliott> for backtracking.
08:58:34 <byorgey> yes, attoparsec does backtracking
08:59:00 <pentace> ohhhh
08:59:38 <byorgey> pentace: maybe the documentation here will help: http://hackage.haskell.org/packages/archive/attoparsec-parsec/0.0.2/doc/html/Data-Attoparsec-Text-Parsec.html
09:00:28 <elliott> it's funny that attoparsec takes the "less performant" choice here :)
09:00:56 <lasticot> does anyone know of a tutorial or a project where I could learn to manage input incoming during the execution of a program?
09:01:12 <pentace> byorgey: Unfortunately, that won't help as I have to switch to parsec because I need the monadic part of it
09:01:56 <byorgey> pentace: I didn't mean the package, I just meant reading the Haddock documentation there might help explain what you need to be careful of
09:02:20 <pentace> ah, okay
09:02:21 <byorgey> elliott: ISTR that bos tried removing backtracking and it made performance *worse* =)
09:02:38 <byorgey> I don't remember why, I think he wrote a blog post about it
09:02:43 <elliott> byorgey: because you have to track whether you're backtracking, maybe.
09:02:48 <byorgey> dunno
09:03:08 <elliott> pentace: hm, er, attoparec has Monad instances...
09:03:22 <pentace> try'ing a small parser actually helped
09:04:05 <pentace> elliott: Where are they?
09:04:26 <byorgey> lasticot: "managing input" is quite vague.  Do you mean an I/O tutorial?  Or do you need to do something like streaming input?  Are you talking about user input, or input from a file? ...?
09:05:08 <elliott> pentace: they're... just there, as far as I know.
09:05:14 <pentace> elliott: The docs explicitly say "Unlike Parsec 3, Attoparsec does not support being used as a monad transformer"
09:05:29 <elliott> like, look here: http://hackage.haskell.org/packages/archive/attoparsec/0.10.4.0/doc/html/Data-Attoparsec-Types.html#t:Parser
09:05:32 <lasticot> byorgey: I mean user input, that kind of input you would find in a video game for example
09:05:35 <elliott> pentace: oh. well monad is different to monad transformer.
09:05:43 <elliott> attoparsec's Parser is a monad, just not a monad transformer.
09:06:05 <KeyboardNotFound> Which is good IDE for haskel for linux ?
09:06:17 <elliott> you can try leksah if you want an IDE. any editor will work, though
09:07:45 <nexx> If you have no problem with eclipse, you might like eclipseFP
09:08:28 <pentace> elliott: dammit .. thanks for pointing that out!
09:08:57 <elliott> pentace: hehe :)
09:09:41 <acube> Is there some cases in which GHC's setSessionDynFlags doesn't return ?A
09:10:06 <acube> Are
09:10:08 <acube> *
09:10:22 <Demos> many of the thing an IDE provides are not really necessary for haskell, a debugger in particular
09:15:08 <pentace> Well, I still need a user state for my parser, so the porting wasn't all in vain :)
09:28:35 <b2coutts> is there a built-in logical or? (i.e., (\ x y z -> x z || y z))
09:28:47 <mauke> ಠ_ಠ
09:29:39 <b2coutts> s/logical/functional
09:30:04 <Fuuzetsu> Hey, I'm looking for a list indexed by its length. Does anyone know where I can find one?
09:30:04 <nicoo> @ty  x y z -> x z || y z
09:30:05 <lambdabot> parse error on input `->'
09:30:13 <nicoo> @ty \ x y z -> x z || y z
09:30:14 <lambdabot> (t -> Bool) -> (t -> Bool) -> t -> Bool
09:30:30 <Fuuzetsu> :t liftM2 (||)
09:30:33 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
09:30:38 <nicoo> @hoogle (t -> Bool) -> (t -> Bool) -> t -> Bool
09:30:39 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:30:39 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
09:30:39 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
09:31:32 <Fuuzetsu> :t liftM2 (||) f
09:31:33 <lambdabot> (Monad m, FromExpr (m Bool)) => m Bool -> m Bool
09:31:44 <Fuuzetsu> :t liftM2 (||) (f :: a -> b)
09:31:45 <lambdabot>     No instance for (FromExpr b) arising from a use of `f'
09:31:45 <lambdabot>     Possible fix:
09:31:45 <lambdabot>       add (FromExpr b) to the context of
09:31:59 <Fuuzetsu> :t liftM2 (||) (f :: a -> b) (g :: a -> b)
09:32:00 <lambdabot>     No instance for (FromExpr b) arising from a use of `f'
09:32:00 <lambdabot>     Possible fix:
09:32:00 <lambdabot>       add (FromExpr b) to the context of
09:32:19 <mauke> :t liftM2 (||)
09:32:20 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
09:32:31 <dolio> I don't know that a debugger isn't necessary.
09:32:36 <skuggi> @pl (\ x y z -> x z || y z)
09:32:36 <lambdabot> liftM2 (||)
09:32:56 <dolio> Well, it's never necessary, I suppose.
09:33:38 <Demos> debugging haskell code is what we call not fun
09:34:19 <t7> suer trace print string thing
09:34:23 <t7> use*
09:34:33 <t7> also write modular code so you can check it with ghci
09:36:56 <dolio> There used to be a very good (reportedly) debugger that worked with Haskell, but it hasn't been maintained.
09:37:16 <dolio> And GHC has a debugger, but I've not used it. I don't think it's the same.
09:37:37 <Demos> well it does, but stepping through lazy code is pretty strange
09:38:42 <dolio> Yeah, I'm not sure stepping is what you want to do.
09:38:49 <dolio> The old debugger was called buddha.
09:39:06 <dolio> And what you did, I believe, was specify an expression to evaluate....
09:39:14 <dolio> Then it'd tell you the answer, and ask you if it was correct.
09:39:40 <dolio> If it wasn't, you'd drill down into parts of the process that gave you the wrong answer, and find which parts of that were wrong.
09:39:48 <dolio> Until you found the problem.
09:41:22 <dolio> So, it was more along the lines of how you structure algorithms in a functional language.
09:41:27 <dolio> Rather than stepping through evaluation.
09:56:45 * hackagebot boxes 0.1.3 - 2D text pretty-printing library  http://hackage.haskell.org/package/boxes-0.1.3 (BennoFuenfstueck)
10:00:03 <slack1256> any introduction to data structures assuming only knowledge in functional programming
10:00:25 <slack1256> something that discusses data structures with SML code examples
10:00:40 <slack1256> no pointers and stuff.
10:02:20 <elliott> slack1256: Purely Functional Data Structures by Okasaki?
10:02:25 <elliott> plus something on finger trees.
10:02:35 <elliott> it uses ML in fact :P
10:03:02 <slack1256> yes he does, but my but I am looking something more basic
10:03:20 <slack1256> I don't know even the basic of design of data structures (my background isn't CS)
10:04:28 <slack1256> althought the examples of the queue in okasaki (the lazy implementation) really is clear. but when he starts disccusing worst case structures from amortized ones I lost it.
10:11:24 <wole> :t </>
10:11:25 <lambdabot> parse error on input `</>'
10:11:42 <wole> :t (</>)
10:11:43 <lambdabot>     Not in scope: `</>'
10:11:44 <lambdabot>     Perhaps you meant one of these:
10:11:44 <lambdabot>       `<>' (imported from Data.Monoid),
10:11:54 <wole> :t (<\>)
10:11:55 <lambdabot>     Not in scope: `<\>'
10:11:55 <lambdabot>     Perhaps you meant one of these:
10:11:55 <lambdabot>       `<>' (imported from Data.Monoid),
10:15:18 <DiegoNolan> from a high level perspective where should game state be stored?
10:15:31 <DiegoNolan> should i just be passing a god object through the main loop
10:15:38 <DiegoNolan> or is there a better way to do that
10:16:49 <NemesisD> how do you guys avoid orphaned instances when defining Arbitrary instances for your datatypes?
10:17:02 <c_wraith> I don't
10:17:27 <NemesisD> don't avoid them or don't encounter them
10:17:31 <c_wraith> I'm happy to put {-# OPTIONS_GHC -fno-warn-orphan-instances #-} at the top of the file
10:17:35 <NemesisD> ah ok
10:18:10 <elliott> NemesisD: submit the instances upstream
10:18:31 <magneticduck> @pl (\a b -> f $ g a b)
10:18:31 <lambdabot> (f .) . g
10:18:43 <magneticduck> oh
10:19:07 <magneticduck> say, when do people use (.) . (.) ?
10:19:37 <magneticduck> actually, that's obvious
10:19:58 <magneticduck> @pl (\a b -> f $ a . b)
10:19:58 <lambdabot> (f .) . (.)
10:20:02 <magneticduck> uh
10:20:19 <magneticduck> when f is id... but
10:20:34 <magneticduck>  @pl (\a b -> a . b)  >_>
10:20:43 <magneticduck> nevermind, I'm lost again
10:21:12 <magneticduck> wait, that's not right; for what f is (f .) reducable to (.)
10:23:21 <magneticduck> @t (.) . (.0
10:23:21 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:23:24 <magneticduck> @t (.) . (.)
10:23:25 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:23:37 <magneticduck> @type (.) . (.)
10:23:38 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:24:31 * magneticduck goes back to writing code
10:27:12 <chrisdone_> ahoy hoy
10:27:20 <magneticduck> hoy ahoy hoy
10:27:25 <magneticduck> *hoy hoy hoy hoy hoy*
10:27:46 <chrisdone> magneticduck: aren't ducks supposed to quack? or is that the effects of the magnetism?
10:28:38 <magneticduck> yeah I dunno; I mainly go ROAARR
10:28:43 * magneticduck roars
10:29:02 <nschoe> chrisdone, how do you quack on irc ? ^^
10:29:17 <nschoe>  /quack ?
10:29:26 <magneticduck> @quack
10:29:26 <lambdabot> I don't perform such side effects on command!
10:29:44 <nschoe> ho man.. I love lambdabot ^^
10:30:20 <magneticduck> I'm totally suprised that you guys haven't pounced on my theoretical question yet
10:30:27 <magneticduck> need more coffee?
10:30:31 <magneticduck> :<
10:30:42 <slack1256> @help
10:30:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:30:48 <slack1256> @help slap
10:30:48 <lambdabot> slap <nick>. Slap someone amusingly.
10:30:53 <slack1256> oh really
10:30:55 <slack1256> mmm
10:30:56 <magneticduck> @slap slack1256
10:30:56 * lambdabot secretly deletes slack1256's source code
10:31:23 <magneticduck> @list
10:31:23 <lambdabot> What module?  Try @listmodules for some ideas.
10:31:25 <slack1256> mmmm
10:31:30 <slack1256> I dont know if to be happy or sad.
10:31:59 <slack1256> @listmodules
10:31:59 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
10:32:00 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
10:32:16 <slack1256> @quote free
10:32:16 <lambdabot> Korollary says: darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
10:32:30 <nicoo> @quote darcs
10:32:30 <lambdabot> darcs says: It's too late to use atexit
10:32:35 <nicoo> @quote darcs
10:32:35 <lambdabot> darcs says: It's too late to use atexit
10:32:40 <slack1256> @quote goverment
10:32:40 <lambdabot> No quotes match. Just try something else.
10:32:46 <slack1256> @quote else
10:32:46 <lambdabot> rickyclarkson says: I've been experimenting with functional programming from within Java (is this like asking your wife to dress up as someone else?)
10:32:54 <nicoo> @quote government
10:32:54 <lambdabot> dmwit says: [on leetspeek] I think the government should use this as an encryption technique.
10:33:22 <magneticduck> @quote duck
10:33:22 <lambdabot> ab9rf says: (on duck typing) if you want a duck-submarine-employee-tomato, you can do that
10:33:29 <slack1256> @quote okasaki
10:33:29 <lambdabot> mauke says: Fire Lord Okasaki
10:33:42 <magneticduck> A DUCK SUBMARINE EMPLOYEE TOMATO??!?! I LOVE TOMATOES!
10:34:06 <magneticduck> @quote roar
10:34:06 <lambdabot> No quotes match. Just what do you think you're doing Dave?
10:34:21 <magneticduck> my name is not dave and I know perfectly well what I'm doing
10:35:14 <magneticduck> @quote spam
10:35:15 <lambdabot> dolio says: [regarding a paypal spam message on #haskell] Take that, Harrop! Does OCaml have illegal cracking utilities?
10:35:31 <byorgey> speaking of spam...
10:35:53 <copumpkin> o.O
10:36:02 * magneticduck shuts up
10:36:06 <magneticduck> :<
10:36:29 <monochrom> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html is interesting. I'm studying it.
10:37:36 <byorgey> magneticduck: that wasn't directed (only) at you...
10:38:10 <magneticduck> yeah but I'm a repeat offender
10:38:29 <byorgey> #haskell is quite large so it's worth being intentional about keeping the signal-to-noise ratio high
10:38:38 * slack1256 almost passed unnoticed on that. (sorry)
11:12:33 <DiegoNolan> how do you do a fold on data.Sequnce?
11:13:30 <benmachine> DiegoNolan: using the Foldable instance
11:13:30 <acube> DiegoNolan: Use fold from Data.Foldable
11:13:45 <DiegoNolan> i can just do foldl (+) mySeq
11:13:49 <DiegoNolan> i can just do foldl (+) 0 mySeq
11:13:53 <DiegoNolan> and that will be sum?
11:14:07 <acube> use getSum $ foldMap Sum mySeq
11:14:23 <DiegoNolan> what is getSum?
11:14:39 <roconnor> data Sum a = Sum { getSum :: a}
11:14:46 <roconnor> well s/data/newtype/
11:15:32 <acube> @ty getSum
11:15:34 <lambdabot> Sum a -> a
11:15:35 <roconnor> Sum is turns a number into an additive monoid
11:16:51 <acube> can one implement foldr/foldl with Foldable?
11:18:37 <acube> ok, I can just use foldr f x . toList
11:19:20 <byorgey> acube: Foldable actually already has a foldr method
11:19:26 <byorgey> @type Data.Foldable.foldr
11:19:27 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:19:53 <byorgey> with the property that Data.Foldable.foldr f x === foldr f x . toList
11:20:19 <acube> @src Data.Foldable.foldr
11:20:19 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:20:30 <carter> byorgey hmatrix base is now bsd!
11:20:32 <codesoup> is there a foldr that doesn't overflow? or just foldl' the reverse list?
11:21:21 <twomashi2> How do i define a type that boxes either an Int or a String? I thought I could just go `data IntOrString = Int | String`
11:21:38 <byorgey> carter: nice!
11:21:49 <dwcook> twomashi2, data IntOrString = I Int | S String
11:21:59 <dwcook> You need data constructors
11:22:00 <carter> i'm a bit peeved it took him 6 months to say yes
11:22:04 <carter> but glad it happened
11:22:06 <byorgey> codesoup: there is no strict foldr (indeed, such a thing does not even make sense)
11:22:15 <twomashi2> dwcook: brill thanks
11:22:30 <byorgey> codesoup: if you want to do a strict accumulation over a list from right-to-left, indeed, just foldl' the reverse
11:22:46 <acube> twomashi2: You could also use Either Int String
11:22:56 <acube> > Left "String" :: Either String Int
11:22:57 <lambdabot>   Left "String"
11:23:04 <acube> > Right 42 :: Either String Int
11:23:04 <twomashi2> acube: im in the odd situation of not wanting to bring in any deps.
11:23:05 <lambdabot>   Right 42
11:23:14 <acube> twomashi2: Either is in base
11:23:26 <acube> even in Prelude
11:23:29 <twomashi2> acube: thanks I did not know that
11:23:57 <dwcook> Not wanting to bring in dependencies is not an odd situation. Not being able to is.
11:25:00 <twomashi2> dwcook: its a bit of both. it would be nice if there was a way to compile a haskell program statically into a big binary with everything included..
11:26:52 <acube> twomashi2: haskell is compile statically by default afaik
11:27:19 <Gracenotes> why do Haskell talks on skillsmatter.com all have 'scala' in their URL?
11:29:17 <Gracenotes> seems like an instance of poor schema/routing design
11:31:05 <Gracenotes> although if they are both the same language, someone should let me know
11:33:43 <byorgey> Gracenotes: well, all those newfangled fancy-schmancy "functional" languages are pretty much all the same, right?
11:35:30 <copumpkin> just use unlambda
11:40:07 <chrisdone> unsafePerformLambda
11:40:29 <pentace> What would be a good data type to store the contents of a csv file, i.e. a list of rows of Strings, when I need to access columns by a column name and be able to easily traverse the list in order? My impression is that [Map String String] will have too much overhead.
11:41:58 <chrisdone> it depends how much you care about efficiency. if it's a thousand lines, it doesn't matter. [[String]], fine
11:42:01 <dialelo> t
11:42:06 <twomashi2> how do I turn `id` into a -> [a] where the list is a singleton with the input
11:42:10 <chrisdone> there're csv libraries out there that make those decisions for you, though
11:42:16 <twomashi2> trying to bind it to (:)..
11:42:19 <chrisdone> cassava, for example
11:42:19 <twomashi2> ( : )
11:42:24 <chrisdone> or was it cavassa
11:42:45 <byorgey> twomashi2: id cannot have the type  a -> [a]
11:42:57 <byorgey> cassava is right
11:43:04 <byorgey> CaSsaVa
11:43:16 <twomashi2> byorgey: right… basically I thought there was a way to do (\x -> [x]) using id and ( : )
11:43:58 <byorgey> twomashi2: (:) []  :: a -> [a]
11:44:04 <pentace> chrisdone: I had a llok at it but there was some problem with that library ... can't recall atm
11:44:08 <pentace> *look
11:44:13 <byorgey> oops, I mean  (:[])
11:44:43 <byorgey> pentace: if you really care about performance so much that [Map String String] has too much overhead, then you shouldn't be implementing it yourself anyway.
11:44:56 <twomashi2> byorgey:  perfect thx
11:45:03 <chrisdone> pentace: it's the best csv lib for haskell, i'd be interested in hearing problems about it
11:45:36 <pentace> byorgey: I don't understand what you mean
11:46:21 <byorgey> pentace: I mean that [Map String String] is likely to be fine unless you need to process massive CSV files really fast
11:46:36 <byorgey> and if that's the case, then you should use an existing high-performance CSV library.
11:47:55 <pentace> Hm, maybe I should just use the straight-forward approach and care about performance later (if at all) :p
11:52:28 <chrisdone> does anybody else love reading APIs like some wizard reading a new book of spells? "YES, MORE POWER"
11:52:55 <pentace> chrisdone: I recall, I failed installing the vector package on my system because C support on my Windows machine is, let's say, not optimal. So not a problem with cassava itself ...
11:53:53 <byorgey> pentace: "maybe I should just use the straight-forward approach and care about performance later" -- yes, that's exactly what I would suggest.
11:54:08 <byorgey> premature optimization leads to all sorts of trouble.
11:54:20 <chrisdone> indeed, windows is generally not very optimal for programming outside of the MS blessed languages
12:08:02 <ksf> why doesn't cabal install respect a custom Setup.hs?
12:08:28 <Saizan> ksf: do you have build-type: Custom?
12:10:04 <ksf> that's it, thanks.
12:15:15 <ksf> is there a way to temporarily disable cabal's package paranoia?
12:15:21 <ksf> that is, disable --hide-all-packages?
12:15:54 <Saizan> i don't think so
12:16:03 <byorgey> nope
12:16:17 <byorgey> you have a bunch of required packages not listed in your build-depends, eh?
12:16:35 <byorgey> note that cabal init  can now auto-populate build-depends
12:16:37 <ksf> nah, I'm just too lazy to add them while hacking around.
12:16:52 <byorgey> fair enough.
12:17:05 <ksf> and on second thought, I shouldn't be using cabal in the first place, with all that generating going on.
12:17:30 <ksf> ...but generate a cabal project for release. if this ever gets released, that is.
12:17:32 <byorgey> I hope to hack on a mode to make that auto-populating behavior available when working on a package (not just when generating the initial .cabal file)
12:18:08 <byorgey> yeah, if you don't need/want to use cabal to do building while you're in development, then you can just wait and run cabal init when you get ready to release
12:19:14 <ksf> also, to pre-generate things. no need to ship a lexer unalexed or an attribute grammar unuuagc'd
12:19:55 <chrisdone> hamishmack: any updates on the webkit library DOM access?
12:19:58 <byorgey> right
12:25:18 <bhuemer> hello! :) I was trying to use monads to implement backtracking for one of my projects, but I think I got it wrong - here's a reduced version of my misunderstanding https://gist.github.com/bhuemer/646479d3a9ef71adcf61
12:25:37 <bhuemer> I was hoping that someone could advise me how I could implement something like that?
12:26:25 <bhuemer> basically: I have a function that generates possible solutions and another set of functions that filter those solutions later on
12:27:01 <bhuemer> if I use Maybe, it doesn't go back and re-generate another solution - which is what I was hoping for
12:28:25 <ciaranm> bhuemer: list monad
12:28:53 <bhuemer> yeah, I only wanted to take the first solution though
12:29:10 <ski> > let generate :: MonadPlus m => Integer -> Integer -> m Integer; generate min max | min < max = return min `mplus` generate (min + 1) max | otherwise = mzero; filteredGen :: MonadPlus m => m Integer; filteredGen = do a <- generate 0 10; guard (a > 5); return a in filteredGen :: [Integer]
12:29:12 <lambdabot>   [6,7,8,9]
12:29:29 <bhuemer> or do you mean, the generate function should use a list monad regardless of what filteredGen uses?
12:29:31 <ski> you need list monad (or something similar which can backtrack), to keep track of the intermediate, tentative solutions
12:30:18 <byorgey> you can use the list monad and then call 'listToMaybe' at the very end if you only want one solution
12:30:22 <ski> > let generate :: MonadPlus m => Integer -> Integer -> m Integer; generate min max | min < max = return min `mplus` generate (min + 1) max | otherwise = mzero; filteredGen :: MonadPlus m => m Integer; filteredGen = do a <- generate 0 10; guard (a > 5); return a in listToMaybe filteredGen :: Maybe Integer
12:30:24 <lambdabot>   Just 6
12:30:57 <ski> (type ascription not needed)
12:31:27 <byorgey> the point is that the MonadPlus instance for Maybe cannot do backtracking.
12:31:32 <byorgey> > Just 3 `mplus` Just 4
12:31:33 <lambdabot>   Just 3
12:31:38 <byorgey> note that the 4 is gone.
12:31:48 <byorgey> you can never get the 4 back after evaluating that mplus.
12:32:06 <bhuemer> okay, listToMaybe sounds good
12:33:05 <FreeFull> > mplus [3] [4]
12:33:07 <lambdabot>   [3,4]
12:33:14 <bhuemer> I mean, as I said, I want to have the ability to generate just the first overall solution as well, but then I get errors saying that it could not deduce (m ~ []) from the context (MonadPlus m)
12:33:36 <FreeFull> > mplus (Left 3) (Right 4)
12:33:37 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error a0)
12:33:37 <lambdabot>    arising from a use ...
12:33:45 <FreeFull> :t (Left £)
12:33:46 <lambdabot> Not in scope: data constructor `'
12:33:46 <lambdabot> Not in scope: `'
12:33:47 <FreeFull> :t (Left 3)
12:33:48 <lambdabot> Num a => Either a b
12:33:58 <byorgey> bhuemer: you can still write all your functions with the type  MonadPlus m => ... m Integer  or whatever.
12:34:23 <byorgey> bhuemer: if you just want the firts solution, then you can call 'listToMaybe' on some function
12:34:39 <byorgey> which will fix m = [], and select the first solution
12:35:09 <bhuemer> yep, as I said, that sounds good :)
12:36:04 <byorgey> I was responding to your saying "then I get errors saying that it could not deduce (m ~ []) from the context (MonadPlus  m)
12:36:25 <byorgey> maybe I don't understand what you were trying to say
12:36:27 <bhuemer> yep, that works
12:36:43 <bhuemer> no, it's fine, thanks byorgey and all the others as well :)
12:36:54 <byorgey> bhuemer: also, you may be interested in the Logic monad, which is muc hbetter for doing backtracking search than the list monad
12:37:03 <byorgey> I forget which package it is in
12:37:30 <byorgey> ah, http://hackage.haskell.org/package/logict
12:38:14 <byorgey> web.mit.edu/~ezyang/Public/threemonads.pdf‎ has a nice introduction to using it
12:38:52 <bhuemer> byorgey: ah, yeah, that sounds interesting :) thank you!
12:47:14 <ksf_> shake is a wonderful tool, but it lacks a decent library.
12:47:59 <ksf_> also, all this clashes with haskellmode.
12:48:25 <ksf_> in fact, every single build system clashes with haskellmode.
12:48:34 <Lethalman> ksf_, what you mean by decent library?
12:50:06 <ksf_> like support for out-of source builds, a generic framework to integrate compilers, such things.
12:51:18 <ksf_> I once hacked on ghc integration, but the way I went for it is a patently bad idea. or, rather, ghc is hard to integrate into build processes without using it as a library.
12:53:15 <ksf_> one feature of the whole thing was that it was completely abstracted away from filenames, though. you required modules, not filepaths.
12:53:46 <ksf_> ...it would search for them and hunt down dependencies and then compile. and then break at the next ghc upgrade.
12:54:41 <Lethalman> ksf_, yes it's still a bare make replacement, not an autotools replacement
12:55:48 <ksf_> and in the end, it's kind of pointless to enable parallel builds outside ghc proper for anything but the largest builds (say, ghc itself), as every ghc process has to read all those interface files again and again.
12:56:53 <Lethalman> ksf_, just to point it out, shake is there not only for haskell projects, I use it e.g. for vala projects
12:57:09 <Lethalman> for example because make doesn't support multiple output files
12:57:37 <Lethalman> so it's just a make replacement, nothing more actually
12:57:38 <ksf_> that's why I said "general compiler integration", not "ghc integration".
12:58:42 <ksf_> but when it comes to foreign projects, I think what's missing is a mode that allows shake to be configured without having ghc installed.
12:59:04 <Lethalman> ksf_, then you lose the dsl
12:59:24 <Lethalman> languages like shake and others are written in haskell mainly because of haskell itself :S
12:59:32 <ksf_> the edsl. you'd gain a dsl :)
13:00:22 <ksf_> the stripped-down version of haskell intended for scripting etc. that I've been dreaming of.
13:01:08 <ksf_> lua, just functional.
13:02:09 <chrisdone> hmm. nice. i like it when c apis have accessor functions. makes it really easy to use with the ffi
13:02:41 <benmachine> ksf_: I'd like something along those lines too
13:03:05 * ksf_ has an idea
13:03:15 <ksf_> he should investigate ehc
13:03:50 <chrisdone> ksf_: what about hugs?
13:03:53 <ksf_> see at which point it can be cut off and used as such a generic DSL implementation.
13:03:54 <chrisdone> that's small
13:04:04 <ksf_> hugs is abandonware
13:04:27 <chrisdone> … so?
13:04:33 <ksf_> ...and written in C
13:04:54 <ksf_> one feature I'd like the language to have is to be analysable from haskell
13:06:07 <chrisdone> ksf_: written in C is a point *against* a language implementation?
13:06:14 <ksf_> yes!
13:06:28 <chrisdone> like, there is a more platform-independent language?
13:07:03 <ksf_> well the whole thing is supposed to be a scripting language for haskell, not a second lua as such.
13:07:13 <johnw> chrisdone: moin!
13:07:24 <chrisdone> johnw: evin!
13:07:35 <johnw> lol
13:08:48 * ksf_ is perplexed.
13:08:57 <ksf_> has "moin" travelled as far as america by now?
13:09:04 <johnw> i got it from IRC
13:09:07 <benmachine> it hasn't travelled as far as me
13:09:15 <johnw> i'm up really really late
13:09:18 <johnw> so I see lots of "moins"
13:09:21 * chrisdone high-fives benmachine 
13:09:43 * benmachine high-fives chrisdone
13:10:23 <ksf_> the etymology of "moin moin" is "moje morn", or "good stiff-but-steady-and-gente-morning-wind"
13:11:06 <chrisdone> benmachine: you ever been to Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch?
13:11:13 <benmachine> chrisdone: can't say I have
13:11:30 <chrisdone> benmachine: i see what you did there
13:11:34 <benmachine> :P
13:11:51 <benmachine> I'm not much of a traveller
13:12:01 <chrisdone> my favourite parts are “llll” and “gogogo”
13:12:53 <benmachine> yes
13:12:54 <ksf_> little known fact: they named it such to cause buffer overflows in the rail network's computers.
13:18:51 <chrisdone> hvr: poke
13:22:09 <chrisdone> mgsloan: i found a wallpaper that best represents my sensibilities http://chrisdone.com/suave.png
13:23:03 <mgsloan> chrisdone: Hahah, I'm not seeing any zen gardens
13:23:27 <simukis_> chrisdone: what's the panel?
13:23:38 <simukis_> chrisdone: link to config file or something?
13:23:42 <chrisdone> :D
13:23:55 <mgsloan> simukis_: It's the new kid on the block!
13:24:09 <chrisdone> simukis_: https://github.com/chrisdone/suave config https://github.com/chrisdone/xmonad-chrisdone/blob/master/src/Main.hs
13:24:33 <ksf_> ...no ehc variant under 8 actually compiles
13:24:43 <simukis_> chrisdone: yay, thanks!
13:24:48 <mcstar> who gave me the haskell-beats-c.pdf paper?
13:25:35 <chrisdone> simukis_: it uses webkit, didn't quite work properly for mgsloan, but works okay for me. so statistically you've got a 50/50 chance of success
13:26:14 * chrisdone . o O ( hm, maybe i should've written "50-50" … )
13:26:53 <mgsloan> In my case it seems to be something wrong with the standalone webkit
13:26:55 <Hafydd> As in 50-50=0?
13:27:44 <chrisdone> Hafydd: oh dear, there's no way to write it unamibuously! put the kids in the car, we're getting out of here
13:28:01 <simukis_> chrisdone: maybe 50% chance?
13:28:03 * chrisdone adds unamibuously to the dictionary
13:28:19 <chrisdone> simukis_: =)
13:28:26 <elliott> p=0.5
13:28:27 <Hafydd> Heh.
13:28:31 <mcstar> the new physical force, unambouyancy
13:29:14 <Hafydd> "You've got a 50/100 chance" "You've got a 50-49.5 chance"
13:29:55 <mcstar> 'he's got a 50% chance of living, but he's got only a 20% chance of that'
13:31:08 <chrisdone> mcstar: unambouyancy, Unarchimedes' principle?
13:31:33 <mcstar> unheureka!
13:31:39 <chrisdone> hahaha
13:31:42 <simukis_> 20% chance of having 50% chance of living?
13:31:53 <mcstar> anyway, im wondering if the trio did really use the c++ code that they have in the paper
13:31:55 * chrisdone lathers mcstar with lol sauce
13:34:50 <mcstar> Rarrikins: hey, can i bother you?
13:35:47 <mcstar> (he gave me the link to the paper, if anyone was wondering, im not pinging random ppl)
13:38:44 <dmwit> showIntAtBase is too monomorphic. =(
13:39:14 <mcstar> you need showInteger..?
13:39:31 <dmwit> I want it to return a list of things that aren't Char.
13:39:49 <mauke> :t showIntAtBase
13:40:14 <mcstar> oh it turns Int to Strings
13:40:22 <mcstar> what was i thinking...
13:40:57 <dmwit> mauke: showIntAtBase :: (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
13:41:25 <dmwit> a -> (Int -> b) -> a -> [b] -> [b], plz
13:41:51 <mauke> agreed
13:43:29 <mcstar> hm, im trying to decide what it should do based on the type
13:43:54 <mcstar> is the first [b] a list of symbols that the (Int->b) can choose from?
13:44:04 <dmwit> No, [b] -> [b] is a diff-list.
13:44:28 <mcstar> doesnt that have a type alias?
13:44:36 <mcstar> DiffList b ?
13:44:46 * dmwit shrugs with disinterest
13:44:59 <mcstar> well, it would be more descriptive
13:45:02 <mauke> ShowS
13:45:19 <mcstar> oh
13:45:30 <mcstar> so thats why ShowS is more efficient?
13:46:06 <mcstar> also i guees than ShowS is DiffList Char or something
13:46:12 <mcstar> then*
13:46:15 <Gracenotes> usually, if you are evaluating some of a show'd string, you will be evaluating a lot more of it
13:46:27 <benmachine> there's no standard type alias for difflist
13:46:33 <benmachine> there's a dlist package
14:01:06 <NemesisD> i'm getting an error on {-# OPTIONS_GHC -fno-warn-orphan-instances #-} complaining unknown flag. what am i doing wrong?
14:01:45 <monochrom> interesting, let me see what the manual says
14:01:54 <monochrom> is it GHC 7.6?
14:02:07 <NemesisD> monochrom: yep, 7.6.3
14:02:27 <monochrom> -fwarn-orphans
14:02:44 <NemesisD> oh does it default to not warn?
14:02:47 <monochrom> err, -fno-warn-orphans
14:03:04 <monochrom> I mean it's orphans rather than orphan-instances
14:03:05 <NemesisD> gotcha. thanks
14:03:25 <shachaf> monochrom: Don't you think looking at the manual is cheating?
14:03:37 <monochrom> yes, this is why I cheat for you!
14:18:18 <solidus-lake> so what is the main advantage of haskell ove r iterative languages?
14:18:26 <joelteon> that it's better
14:18:32 <solidus-lake> for what problem would you want to use haskell over an iterative language?
14:18:38 <danharaj> all of them
14:18:44 <joelteon> any problem
14:18:47 <chrisdone> @google why haskell
14:18:49 <lambdabot> http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
14:18:49 <lambdabot> Title: Why functional programming? Why Haskell?
14:19:00 <mcstar> iterative language?
14:19:06 <mcstar> did you mean imperative?
14:19:29 <mcstar> it is imperative to use iterative correctly
14:19:39 <mcstar> i must reiterate
14:19:53 <jmcarthur> but some people learn what imperative is iteratively
14:20:00 <mauke> goto your room
14:20:15 <mcstar> sry mauke, i recurse to my room
14:20:25 * jmcarthur tail calls to his room
14:21:03 <acube> There is polykinded typeable in GHC HEAD, is there also a polykinded GHC.Generics?
14:21:14 <danharaj> I wish.
14:21:20 <acube> That means no?
14:21:26 <danharaj> Well, not necessarily.
14:21:43 <danharaj> I don't keep up with GHC head very well.
14:21:56 <danharaj> acube: If it's not a ticket, maybe you should make it one on the Trac!
14:21:56 <simon> if one has a stack of monad transformers, does one want to consider its order? I think I've noticed that Either(T) usually ends up far in (parenthetically -- unsure if this means that it's actually "inside").
14:22:10 <danharaj> simon: In general the order matters.
14:22:19 <simon> danharaj, is this explained somewhere?
14:22:27 <acube> danharaj: I'm not really sure if that's even possible ...
14:22:34 <acube> (Polykinded Generics)
14:22:42 <danharaj> Well what exactly do you mean by polykinded?
14:22:47 <shachaf> simon: Well, just look at the type it expands to in your particular case.
14:23:02 <acube> You can only abstract over one parameter with GHC.Generics as I understood it right now
14:23:26 <acube> Maybe with PolyKinds it would be possible to remove that limitation?
14:23:48 <danharaj> Oh, I thought you meant deriving Generic for things that have DataKind parameters.
14:24:43 <dmwit> ?where hpaste
14:24:43 <lambdabot> http://paste.tryhaskell.org/new/haskell
14:25:07 <hpaste> dmwit pasted “lazy, linear-time pairing of bitstrings” at http://paste.tryhaskell.org/90712
14:25:13 <dmwit> byorgey: ^^
14:25:16 <hvr> chrisdone: wassup?
14:25:24 <dmwit> Also, others who think that's kind of neat. =)
14:25:27 <acube> simon: You might also like @unmtl in this channel
14:25:35 <dmwit> No integer multiplication required!
14:25:59 <acube> @unmtl StateT Int (EitherT String (ReaderT Bool IO))) ()
14:25:59 <lambdabot> Plugin `unmtl' failed with: Parse error: )
14:26:04 <acube> @unmtl StateT Int (EitherT String (ReaderT Bool IO)) ()
14:26:04 <lambdabot> Int -> (EitherT String (ReaderT Bool IO)) ((), Int)
14:26:14 <acube> @unmtl StateT Int (ReaderT Bool IO) ()
14:26:15 <lambdabot> Int -> (ReaderT Bool IO) ((), Int)
14:26:38 <mauke> @unmtl EitherT String (ReaderT Bool IO)
14:26:39 <lambdabot> EitherT String (ReaderT Bool IO)
14:26:48 <acube> hmm ...
14:27:25 <solidus-lake> can haskell bind with external c libraries?
14:27:28 <acube> @unmtl ReaderT Bool IO ()
14:27:28 <lambdabot> Bool -> IO ()
14:27:30 <dmwit> unmtl seems to have gotten a bit worse, huh?
14:27:38 <zRecursive> @unmtl EitherT String (ReaderT Bool IO) == EitherT String (ReaderT Bool IO) ?
14:27:38 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
14:27:44 <simon> acube, I was just about to ask for such a feature, but figured I'd better look for myself ;)
14:27:55 <solidus-lake> or would all external communication have to be done via IO
14:27:58 <zRecursive> @unmtl ReaderT Bool IO
14:27:59 <lambdabot> Plugin `unmtl' failed with: `ReaderT Bool IO' is not applied to enough arguments, giving `/\A. Bool -> IO A'
14:28:00 <solidus-lake> to binaries
14:28:03 <elliott> solidus-lake: yes it can
14:28:15 <solidus-lake> elliott: is there any material on how to do that?
14:28:19 <acube> @unmtl StateT Int (ReaderT Bool IO) () -- Sometime ago, this worked, or am I doing anything wrong?
14:28:20 <lambdabot> Int -> (ReaderT Bool IO) ((), Int)
14:28:41 <solidus-lake> i see lots of things on using haskell packages, but i want to know how something like the haskell OpenGL library actually makes a context or how i would bind to other c-libs
14:29:06 <dmwit> solidus-lake: The FFI is described well in the Haskell Report.
14:29:16 <dmwit> Tools that generate FFI bindings are available as well.
14:29:27 <dmwit> If you want to know how a particular library on Hackage works, well, just open up the source.
14:29:40 <Driscoll> can anyone explain why partial application doesn't work here?
14:29:44 <Driscoll> (tiny snippet of code)
14:29:45 <Driscoll> http://pastebin.com/LEYcbSA7
14:29:50 <mauke> The paste LEYcbSA7 has been copied to http://paste.tryhaskell.org/90713
14:30:10 <dmwit> Driscoll: Because of ghci's extended defaulting.
14:30:19 <Driscoll> i see
14:30:22 <solidus-lake> dmwit: link to ffi on the haskell report?
14:30:23 <Driscoll> ill read up
14:30:24 <dmwit> Driscoll: You can :set -XNoMonomorphismRestriction and it should be fixed.
14:30:28 <dmwit> ?where report
14:30:28 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:30:35 <Driscoll> cool thanks dmwit
14:30:55 <dmwit> solidus-lake: Specifically, http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
14:31:30 <solidus-lake> reading :)
14:31:53 <pentace> Is there a function in base that splits a list on each separator element into a list of sub-lists?
14:32:08 <dmwit> ?hackage split
14:32:08 <lambdabot> http://hackage.haskell.org/package/split
14:32:09 <solidus-lake> thanks, does ghc make smart use of concurrency based off of types by default or do you have to do something special to make it multithreaded etc
14:32:21 <acube> @hoogle splitOn
14:32:21 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
14:32:22 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
14:32:25 <acube> :O
14:32:33 <dmwit> solidus-lake: You might like http://dmwit.com/gtk2hs, despite the misleading URL.
14:32:33 <acube> @hoogle a -> [a] -> [[a]]
14:32:34 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:32:34 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:32:34 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:32:44 <acube> Hmm, hoogle is too weak
14:32:46 <pentace> dmwit: Nice, thanks
14:32:46 <dmwit> solidus-lake: Short answer: no, nothing smart.
14:34:07 <solidus-lake> ah, but all the magic i'd need lives in Control.Concurrent
14:34:27 <dmwit> There is rich support for magic, yes.
14:36:28 <solidus-lake> wizards o_o
14:39:53 <XUnie> Let's consider the factorial function: is there any reason to solve it recursively when you can just "factorial x = product [1..x]"?
14:41:26 <Peaker> Xunie, mostly it's done for pedagogical reasons
14:41:51 * hackagebot ghci-ng 7.6.3.1 - Extended GHCi fork  http://hackage.haskell.org/package/ghci-ng-7.6.3.1 (HerbertValerioRiedel)
14:41:53 * hackagebot ghci-ng 7.6.3.2 - Extended GHCi fork  http://hackage.haskell.org/package/ghci-ng-7.6.3.2 (HerbertValerioRiedel)
14:41:55 <lispy> :t product [1..?x]
14:41:56 <lambdabot> Not in scope: `..?'
14:41:59 <lispy> :t product [1.. ?x]
14:42:00 <lambdabot> parse error on input `?'
14:42:20 <lispy> did implicit params get disabled?
14:43:59 <simon> @unmtl WriterT Int (ReaderT (Int, Int) (Either String)) Bool
14:43:59 <lambdabot> (ReaderT (Int, Int) (Either String)) (Bool, Int)
14:44:41 <arkeet> lispy: it's a new lambdabot.
14:44:42 <mcstar> product is probably defined recursively though
14:44:43 <arkeet> sort of
14:44:55 <arkeet> blame elliott
14:45:05 <osa1> can anyone recommend me a comonad introduction/tutorial/etc. ?
14:45:08 <shachaf> even recursion is defined recursively
14:45:32 <arkeet> speaking of comonads, comonad.com is still down
14:46:14 <thoughtpolice> shachaf: google would agree
14:47:53 <shachaf> did you mean: corecursion
14:48:05 <shachaf> arkeet: edwardk is still down too.
14:49:43 <arkeet> I noticed.
14:57:37 <lispy> arkeet: oh, is cale no longer running it?
14:57:41 <arkeet> indeed
14:57:59 <lispy> I'm so far out of the loop :(
14:58:01 <arkeet> although even if he was, I'd still probably blame elliott
14:58:08 <lispy> heh
14:58:29 <elliott> I also blame me.
14:58:52 <shachaf> I blame only those who do not blame themselves.
15:00:07 <carter> elliott i figured out why i couldn't build lambda bot :)
15:00:25 <Xunie> So ehm. I'm trying to compile my rad program with ghc... and I get some 'undefined references'. I'm using the module "Data.Digits", how can I link my binary to it?
15:00:33 <arkeet> shachaf: let's come up with a semantics where that is possible.
15:00:58 <carter> Xunie could you hpaste the error message and the code?
15:01:05 <mauke> Xunie: what's the error message?
15:01:23 <Xunie> (.text+0x58d): undefined reference to `__stginit_digitszm0zi2_DataziDigits_'
15:01:24 <Xunie> facto.o: In function `s1mk_info':
15:01:34 <Xunie> Will pastebin the source/errors.
15:01:41 <mcstar> dmwit: what is the meaning of 'real time' in the abstract?
15:02:13 <k00mi> is there somewhere a function like 'read' (or better 'maybeRead') for bytestrings?
15:02:13 <Xunie> Is hpaste.org down? :S
15:02:21 <dmwit> mcstar: The transducer does output transitions "often" -- there is a constant number of inputs it can do before it must output.
15:02:24 <arkeet> Xunie: see second item in the topic
15:02:33 <Cale> lispy: Oh, I thought you knew
15:02:46 <Cale> lispy: elliott wanted to take over and fix up some things
15:02:47 <Xunie> Doh, sorry for the spam.
15:03:00 <shachaf> So far he's done the first part.
15:03:12 * elliott has a lot of commits locally!
15:03:21 <shachaf> We're still missing Control.Lens. :-(
15:03:22 <elliott> just need to get the last 90% of @run done
15:03:33 <elliott> well, I think the fact that it times out on half of @runs is about as bad as no lens
15:03:40 <arkeet> elliott: you should just do a lot more 10% work.
15:03:44 <arkeet> like getting lens
15:03:46 <elliott> so I figure I should kill those two birds with one simultaneous stone.
15:03:53 <elliott> because they both involve rebuilding stuff.
15:04:28 <shachaf> elliott: I heard that you live in a glass house, though.
15:04:42 <arkeet> if it's a safe haskell issue, maybe make some "trustworthy imports" module or something.
15:04:44 <hpaste> Xunie pasted “bug” at http://paste.tryhaskell.org/1488438766312882176
15:04:53 <elliott> arkeet: the issue should be solved by new package versions.
15:04:55 <Xunie> I hit 'secret' paste, didn't I? :O
15:04:57 <elliott> so I have to reinstall all the packages.
15:04:59 <arkeet> ok.
15:05:14 <elliott> but I'd rather add the new @run at the same time, since it's almost usable and about a trillion times faster.
15:05:25 <elliott> but I've been busy doing other things, such as nothing.
15:05:26 <mauke> Xunie: there is no -O3
15:05:35 <arkeet> you should stop doing nothing and do something.
15:05:37 <Xunie> Well, I figured that. GCC still accepted it with -O2, and what not.
15:05:40 <elliott> I am. I'm typing on IRC.
15:05:45 <Xunie> I just added the -O3 in out of curiosity.
15:05:51 <arkeet> yo should finish @run
15:05:55 <Xunie> I get this bug with no optimization too.
15:05:57 <arkeet> u
15:06:39 <elliott> maybe tonight.
15:06:43 <mauke> Xunie: what does 'ghc-pkg list digits' say?
15:06:45 <Xunie> I got a different error now. "In function `rCP_info'" instead of `s1mu_info'
15:07:21 <Xunie> /var/lib/ghc-6.12.1/package.conf.d \n /home/xunie/.ghc/i386-linux-6.12.1/package.conf.d \n    digits-0.2   (where "\n" is obviusly a newline)
15:07:21 <lispy> Cale: no worries.
15:07:36 <elliott> Xunie: you should be passing --make probably.
15:07:37 <lispy> Cale: it's possible that I simply forgot
15:07:40 <elliott> first you should be upgrading GHC.
15:07:43 <elliott> then you won't have to
15:07:53 <mauke> ooh, 6.12
15:07:57 <mauke> how quaint
15:08:08 <Xunie> elliott, thanks. I'll look into what --make does and upgrade my old as hell distro.
15:08:28 <arkeet> --make is what you want almost all of the time.
15:08:49 <elliott> which is why it's default now.
15:09:59 <Xunie> Makes sense to intelligently handle the dependencies. It works now, by the way.
15:12:36 <Xunie> Interesting data my program spat out! :O  http://i.imgur.com/7jDvg1m.png
15:13:09 <Xunie> y = amount of 'trailing zeroes' on (factorial x)
15:13:20 <Xunie> Seems quite repetitive!
15:13:29 <arkeet> Xunie: surely that's just a coincidence!
15:13:34 <dmwit> Xunie: There are as many trailing zeros as there are multiples of five.
15:13:43 <Xunie> Makes sense, base 10.
15:13:45 <mauke> zeroes never get lost
15:13:51 <dmwit> Every five it bumps by one; every 25 it bumps by 2; every 125 it bumps by 3, etc.
15:13:52 <mauke> every 2*5 pair adds a zero
15:13:57 <mauke> the bottleneck is 5's
15:14:29 <Xunie> Oh! Let me make a graph for base 16! :3
15:14:47 <mauke> > showHex 255 ""
15:14:49 <lambdabot>   "ff"
15:15:07 <dmwit> I feel if you pay attention to what we're saying you can make a darn good guess about what it will look like in base 16.
15:15:53 <mauke> > showHex (2*2*2*2) ""
15:15:55 <lambdabot>   "10"
15:16:37 <aristid> dmwit: every 8 numbers a hex-0 will be added?
15:16:58 <Xunie> dmwit, I know. But it was so easy to make another graph, which I just did, but it's exactly the same. I'm just saying: curiosity never hurts.
15:17:03 <aristid> hmm actually more often
15:17:08 <dmwit> Yes, more often.
15:17:16 <aristid> but only slightly more often i think
15:17:18 <Xunie> Who knows? My program was buggy? We all made a wrong assumption or my ALU is borked?
15:17:24 <dmwit> It's slightly more complicated because multiples of 4 and 8 come more often than multiples of 16. =)
15:17:33 <Hafydd> > showHex (2^20-1) + "uuuu"
15:17:34 <lambdabot>   Couldn't match type `[GHC.Types.Char]'
15:17:34 <lambdabot>                with `GHC.Base.String...
15:17:39 <aristid> yes but not remotely as often as multiples of 2
15:17:41 <Hafydd> > showHex (2^20-1) "" + "uuuu"
15:17:42 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
15:17:42 <lambdabot>    arising from a use of `GHC...
15:17:48 <dmwit> > showHex (2^20-1) "uuuu"
15:17:49 <lambdabot>   "fffffuuuu"
15:17:59 <pentace> What are the defaulting rules for monads? When I leave out the type signature I get an extremly specific type O.o
15:18:02 <Hafydd> Thank you.
15:18:05 <chrisdone> hvr: gonna send a pull request if you don't mind code reviewing
15:18:18 <aristid> wait hmm actually multiples of 4 should be common enough to impact it significantly
15:18:22 <Hafydd> I seem to have relapsed into Python operators.
15:18:23 <dmwit> aristid: Not remotely? Half of all multiples of two are also multiples of 4...
15:18:42 <mauke> pentace: I don't think there are any
15:19:18 <hvr> chrisdone: I don't mind :-)
15:19:26 <pentace> this is the function: count = sequence .: replicate
15:19:39 <hvr> chrisdone: btw, could you try 'cabal install ghci-ng' to see if it works?
15:19:43 <mauke> :t replicateM
15:19:44 <lambdabot> Monad m => Int -> m a -> m [a]
15:19:49 <dmwit> :t (sequence .) . replicate
15:19:50 <lambdabot> Monad m => Int -> m a -> m [a]
15:20:06 <chrisdone> hvr: sure
15:20:12 <mauke> inb4 monomorphism restriction
15:20:26 <chrisdone> monomorphism prediction
15:20:50 <aristid> dmwit: so i'd guess it's something like every 5-6 numbers
15:21:00 <hvr> monomorphism inception?
15:21:26 <dmwit> ?remember chrisdone <mauke> inb4 monomorphism restriction <chrisdone> monomorphism prediction
15:21:26 <lambdabot> Okay.
15:21:46 <Hafydd> monomorphism instruction
15:22:54 <simon> trying to abuse GeneralizedNewtypeDeriving, I've got: newtype FooM a = FooM (WriterT FooReturn (State FooState) a) deriving (MonadWriter FooReturn, MonadState ?, Monad, Functor, Applicative) -- I'm not sure if my MonadState should be FooState or (State FooState). I'm guessing on the former.
15:23:32 <mauke> do both compile?
15:23:42 <pentace> Okay, without type signature I also can't use it on different monads
15:23:45 <simon> I'll find out that way, I suppose. :)
15:24:28 <pentace> that's just weird
15:24:37 <arkeet> simon: MonadState FooState
15:24:55 <arkeet> you give it a partially applied type class.
15:25:08 <mauke> pentace: it's the monomorphism restriction
15:25:26 <arkeet> simon: in other words, you want an  instance MonadState FooState FooM
15:25:30 <arkeet> so you derive MonadState FooState
15:26:00 <pentace> http://www.haskell.org/haskellwiki/Monomorphism_restriction the first sentence says it all :D
15:27:52 <osa1> :t fmap fix return
15:27:53 <lambdabot> a -> a
15:28:03 <osa1> uh
15:28:15 * dmwit wiggles his fingers
15:28:18 <dmwit> MAGIC
15:28:22 <osa1> heh
15:28:23 <mauke> problem, officer?
15:31:36 <aristid> dmwit: oooook, so apparently the number of zeros in a hex-factorial doubles around every 4.2 numbers (experimental figure, i'm not a proper mathematician)
15:32:00 <Cale> aristid: you mean just at the very end?
15:32:16 <mauke> yes
15:32:29 <aristid> Cale: no, averaged.
15:32:43 <aristid> Cale: this is from the first 500 factorials.
15:33:05 <danharaj> So this week I learned that arrows are strong monads in the bicategory of profunctors. Who knew?
15:33:20 <aristid> Cale: with this horrible horrible ghci fragment: (let fac = product . enumFromTo 1; countZeros = length . takeWhile (=='0') . reverse; runAvg = zipWith (flip (/)) [1..] . scanl1 (+) in runAvg . map (fromIntegral . length) . group $ map (countZeros . flip showHex "" . fac) [1 ..]) !! 500
15:33:35 <BitPuffin> Can Haskell run the same way as Erlang where it's distributed amongst many devices?
15:33:41 <Cale> aristid: You're only counting 0's at the end of the expansion
15:33:41 <BitPuffin> Like does it have that built in?
15:33:50 <danharaj> BitPuffin: Cloud Haskell is an ongoing active project.
15:33:50 <elliott> danharaj: they're also relative monads in something something something.
15:33:52 <Cale> (that's what I was asking)
15:33:57 <danharaj> elliott: I am intrigued.
15:33:59 <aristid> Cale: oh. yes.
15:34:00 <BitPuffin> danharaj: is it usable?
15:34:03 <Cale> BitPuffin: It doesn't have it built in
15:34:13 <elliott> danharaj: something something something something
15:34:30 <danharaj> BitPuffin: Theoretically? I haven't used it. It probably would be fine for small projects.
15:34:45 <danharaj> elliott: are we playing the categorification of hanged man now? :)
15:34:56 <aristid> Cale: easy enough to change the code to work also for non-ending zeroes i guess, but that makes the mathematics messier i think
15:34:57 <Cale> aristid: A number in hexadecimal has a zero at the end of its expansion whenever it has a factor of 16 = 2^4.
15:35:14 <BitPuffin> danharaj: but basically it will work with regular haskell, or is it a subset of the language or something
15:35:31 <danharaj> BitPuffin: hold on let me link you to a good talk about it given by spj.
15:35:41 <danharaj> (incidentally "good talk given by spj" is redundant)
15:35:42 <aristid> Cale: yes, we talked about this earlier. my first guess was that it would be every 8 numbers, but i ignored the high frequency of 4s and 8s there.
15:36:11 <elliott> danharaj: http://www.cs.nott.ac.uk/~txa/publ/Relative_Monads.pdf remembers the details better than I
15:36:15 <Cale> aristid: Every even positive integer less than or equal to n will contribute a factor of 2 to n!, and every 4th will contribute a second, and every 8th will contribute a third, and so on.
15:36:17 <danharaj> BitPuffin: http://skillsmatter.com/podcast/home/haskell-cloud/js-4179
15:36:28 <chrisdone> hvr: i'll tell you when it's ready for review =)
15:36:36 <danharaj> BitPuffin: allegedly this talk is more modern and dcoutts is a cool guy as well: http://skillsmatter.com/podcast/home/cloud-haskell/ac-5258
15:36:58 <hvr> chrisdone: alright :) ... but I'll be afk soon for today
15:37:09 <aristid> Cale: every 16th will add a whole 0 immediately
15:37:29 <yrrebaer> @let answer=(\(x,y,z)->(y,z)).head.head.filter((2==).length).Data.List.groupBy(\x y->(f x)==(f y)).Data.List.sortBy(\x y->compare(f x)(f y))$map(\(x,y)->(x+y,x,y))candidates where{ocp2=[11,17,23,27,29,35,37,41,47,51,53];candidates=[(i,j)|i<-[2..49],j<-[3..97],even$i*j,elem(i+j)ocp2,length(filter(\x->((==0).rem(i*j))x&&x/=(i*j)&&elem(x+div(i*j)x) ocp2)[2..97])==2];f (z,_,_)=z}
15:37:30 <lambdabot>  Defined.
15:37:34 <yrrebaer> > answer
15:37:38 <lambdabot>   mueval-core: Time limit exceeded
15:37:40 <danharaj> elliott: that's hilarious. I've read the first half of that paper enough that I know the definition of relative monad but never looked at the abstract or the arrow result. :P
15:37:46 <aristid> yrrebaer: and i thought my ghci one-liners were horrible.
15:37:49 <elliott> yrrebaer: yikes
15:37:57 <elliott> is it meant to give 42?
15:38:05 <yrrebaer> No, (3,14)
15:38:19 <BitPuffin> danharaj: thanks! too bad I can't watch them now with the limited bandwidth, but I'll keep them open in a tab until I get back home :)
15:38:28 <aristid> yrrebaer: lambdabot isn't going to give you a lot of computing resources ;)
15:38:36 <Cale> aristid: So, on average as n becomes large, the number of factors of 2 contributed by numbers less than n will be n/2 + n/4 + n/8 + n/16 + ... = n * (sum over k >= 1 of 1/2^k) = n
15:38:52 <yrrebaer> Well, I tested it on my machine and it gave the answer in under 0.2 seconds
15:39:09 <yrrebaer> And I didn't know whether lambdabot would think it's OK, so I went here to test it
15:39:17 <Cale> aristid: and so we'll expect n/4 zeroes at the end of n! when n is large :)
15:39:43 <Cale> We could be more precise about that analysis to get an exact count of course
15:41:22 <chrisdone> hvr: alright, this looks pretty good: https://github.com/haskell/haskell-mode/pull/177
15:41:25 <danharaj> elliott: would you happen to know what kinds of functors' initial algebras model HOAS?
15:41:46 <elliott> danharaj: um, maybe the paper Initial Algebras Are Enough! is related
15:41:56 <elliott> *Algebra Semantics Is
15:42:13 <danharaj> elliott: thanks. I have like 20 papers that are 'related' and I don't want to read them all. You are my lazy evaluator!
15:42:19 <danharaj> (Well, part of it anyway.)
15:42:23 <danharaj> (My runtime system is extensive.)
15:43:40 <sclv> danharaj: not sure if that's a coherent question to ask, actually...
15:44:21 <sclv> hoas involves a parameter in the contravariant position, so not a functor...
15:44:40 <elliott> it's, like, an invariant functor, man.
15:45:50 <sclv> you can't cata the fixpoint of an invariant functor
15:46:06 <sclv> you can hylo it, i suppose.
15:46:18 <Peaker> anyvariant functor you mean?  invariant functor is contradiction in terms?
15:46:48 <sclv> bivariant functor -- i guess its really a profunctor where a and b are the same
15:47:34 <sclv> don't know of any machinery to handle that sort of stuff in the initial algebra world -- its an interesting question.
15:47:55 <osa1> looks like this syntax is illegal: newtype Fun a b = (->) a b is there a valid way to do that?
15:48:16 <osa1> ah, nevermind
15:48:18 <sclv> my sense is debrujin maps most neatly to doing \ calc algebraically
15:48:20 <mauke> osa1: newtype Fun a b = F ((->) a b)
15:48:27 <osa1> mauke: right, thanks
15:48:29 <sclv> or F (a -> b) even
15:50:14 <danharaj> sclv: hmm, then I am confused by the finally tagless paper, which calls a GADT encoding of HOAS "initial"
15:51:30 <elliott> Peaker: anyvariant isn't it.
15:51:32 <sclv> oh i think its initial in a broader sense. but not necessarily "initial algebra representable in haskell"
15:51:33 <elliott> anyvariant is iso to Proxy
15:52:05 <Peaker> Functor implies covariant, if it's also contravariant, it makes it anyvariant, doesn't it?
15:52:21 <danharaj> sclv: well I didn't expect it to be a functor on *, at least.
15:52:33 <elliott> Peaker: (a -> b) -> (b -> a) -> f a -> f b is to what I refer
15:52:38 <elliott> that is neither co nor contra
15:53:39 <sclv> danharaj: quick grep thru the paper doesn't seem to use initial in that sense?
15:53:52 <sclv> they just mean initial/final as in adt/church i think?
15:54:31 <danharaj> sclv: certainly that can't be a coincidence.
15:54:34 <sclv> also they seem to use debruijn in some places
15:54:55 <danharaj> sclv: which paper are we reading by the way? I'm looking at "Typed Tagless Final Interpreters"
15:54:57 <Peaker> elliott, ah, so not a Functor
15:55:13 <sclv> danharaj: oh, its not! but its just a broader/more general usage of the term. things you use induction vs. coinduction on
15:55:19 <sclv> recursion/corecursion
15:55:31 <danharaj> sclv: right but those should have categorical semantics!
15:55:33 <elliott> Peaker: but a functor
15:55:39 <sclv> i was looking at "finally tagless" -- i'll look at the other
15:55:42 <danharaj> Just on more complicated categories.
15:55:47 <elliott> initially tagless
15:56:31 <danharaj> sclv: I think the notion is the same informal one in both papers.
15:57:09 <danharaj> sclv: Typed Tagless Final Interpreters has an embedding of linear lambda calculus though, it's like, the coolest example of Carette et al.'s idea.
15:58:37 <osa1> I don't understand how is this type safe: `fix (return 10) :: Int`
15:58:43 <danharaj> :t fix
15:58:44 <lambdabot> (a -> a) -> a
15:58:49 <osa1> :t fix (return 10)
15:58:50 <lambdabot> Num a => a
15:59:02 <shachaf> return = const
15:59:04 <elliott> osa1: it's using the monad instance for functions
15:59:07 <shachaf> > fix (const 10)
15:59:09 <lambdabot>   10
15:59:20 <shachaf> It won't work with any other type.
15:59:39 <osa1> elliott: functions are monads??
15:59:41 <danharaj> :t fix (return "ponies")
15:59:42 <lambdabot> [Char]
16:00:10 <geekosaur> @src (->) (>>=)
16:00:11 <lambdabot> f >>= k = \ r -> k (f r) r
16:00:19 <shachaf> osa1: No, (r ->) is a monad, for any r.
16:00:33 <shachaf> It's just like Reader.
16:00:52 <hvr> AB
16:01:15 <osa1> ahh, that explains. I'll derive it on a paper. thanks.
16:01:57 <sclv> danharaj: you may enjoy this https://www.fpcomplete.com/user/mutjida/typed-tagless-final-linear-lambda-calculus
16:02:42 <danharaj> sclv: I think that's an adaptation of oleg's work :P
16:02:51 <S_J> Isnt there some Cabal setup program? I remember this, so youm dont have to writ all the files required youtself...
16:02:59 <elliott> cabal init
16:03:03 <elliott> probably.
16:03:06 <S_J> yes
16:03:08 <sclv> the tagless stuff may be an adaptation. wouldn't be surprised if the linear stuff was arrived at independently
16:03:39 <danharaj> sclv: ok. Sounds like a good read then.
16:04:09 <sclv> (he did his dis on linear stuff well before the tagless stuff)
16:08:37 <S_J> do i call runhaskell or cabal build or soemthing?
16:10:19 <troydm> S_J: cabal init maybe
16:12:06 <sclv> danharaj: i note that oleg in fact notes that the non-covariance of Lam puts it outside the scope of the ghani/johan stuff
16:13:14 <danharaj> sclv: mm. I hold out hope.
16:13:36 <sclv> recall initial algebra semantics make sense in the world of catamorphisms, basically. full evaluation moves us to hylo, so its sort of sensical that we're not going to get a fully initial story here, since hoas "complects" different portions of evaluation.
16:13:51 <sclv> that's a very handwavy statement on my part, i know, but it informs my intuition that it just doesn't match up.
16:14:16 <sclv> names are a non-local effect
16:17:17 <danharaj> hmm. this paper looks interesting: http://arxiv.org/pdf/1012.1010v3.pdf
16:18:04 <johnw> danharaj: it does!  thanks for the link
16:18:43 <danharaj> can anyone get past the springer paywall? There's a paper I want to read that is being held by the fascists.
16:18:55 <elliott> this paper looks interesting. https://upload.wikimedia.org/wikipedia/commons/e/e5/Stack_of_Copy_Paper.jpg
16:21:35 <startling> elliott: ah, yes, cicero
16:21:39 <simon> :t runState (runWriterT x)
16:21:39 <lambdabot>     Couldn't match expected type `WriterT w0 (StateT s0 Identity) a0'
16:21:40 <lambdabot>                 with actual type `Expr'
16:21:40 <lambdabot>     In the first argument of `runWriterT', namely `x'
16:22:21 <startling> :t runState . runWriterT
16:22:22 <lambdabot> WriterT w (StateT s Identity) a -> s -> ((a, w), s)
16:22:37 <startling> :t x
16:22:38 <lambdabot> Expr
16:26:31 <Ghoul_> is there some kind of performance benchmark (or general knowledge which is faster or "less fat" at the moment) for Pipes vs Conduits?
16:26:52 <S_J> im confused to when i have Setup.hs, do i run runhaskell or cabal? what comamnd do i give to cabal?
16:27:12 <ChongLi> cabal build
16:27:24 <ChongLi> assuming you also have a .cabal file
16:28:23 <sclv> elliott: i was not interested by that paper.
16:28:38 <sclv> the stock looked a bit light for my taste
16:29:13 <elliott> sclv: sorry you have inferior taste to me.
16:29:40 <chrisdone> The Paper
16:29:46 <shachaf> sclv: The darker version is out of stock.
16:30:13 <sclv> stack my paper high
16:31:05 <startling> Ghoul_: pipes is much "less fat" if you take that to mean "less support libraries"
16:31:25 <Ghoul_> they claim to be "blazingly fast"
16:31:36 <hpaste> S_J pasted “cabal problem” at http://paste.tryhaskell.org/90714
16:31:40 <Ghoul_> are they actually faster than conduit right now?
16:31:51 <S_J> Error: No 'Main-Is' field found for executable markovgenerator ## http://paste.tryhaskell.org/90714 <- cabal file, whats wrong?
16:31:51 <elliott> I believe they're comparable in speed.
16:31:57 <johnw> Ghoul_: for which task?
16:32:16 <sclv> ?google haskell pipes benchmarks
16:32:17 <lambdabot> http://www.haskellforall.com/2012/10/pipes-25-faster-and-slimmer.html
16:32:17 <lambdabot> Title: Haskell for all: pipes-2.5: Faster and slimmer
16:32:35 <sclv> ^^ if only there was some way to answer questions such as Ghoul_'s using a "program" on a "network"
16:32:49 <sclv> one day Haskell will get us there...
16:32:53 <Ghoul_> johnw: general thoroughput
16:33:05 <Ghoul_> and thanks for the link
16:33:10 <sclv> :-)
16:33:14 <johnw> Ghoul_: it's hard to answer any optimization question that generally, but I don't know; maybe use criterion and setup some benchmarks?
16:33:17 <sclv> the real answer is it doesn't @#$@% matter
16:33:32 <startling> Ghoul_: "general thoroughput" isn't really a thing you can measure
16:33:44 <sclv> because if you're losing time in your IO layer, then either you have a terrible terrible IO layer, or a trivial problem, or are doing something wrong
16:33:52 <chrisdone> johnw: this branch is good https://github.com/haskell/haskell-mode/tree/highlight-type-info loading a module now imports everything that is loaded for that module, and also everything that module imports. and C-c C-t and C-c C-i show syntax highlighted as haskell
16:35:12 <johnw> nice!
16:37:06 <sclv> (nb my above generalization fails to hold in the one specific instance where you're writing a high performance datastore. but even there it turns out algos matter way more than constant factors, typically)
16:42:08 <hpaste> S_J pasted “cabal parse file” at http://paste.tryhaskell.org/90715
16:42:20 <S_J> ^^ help with cabal please
16:42:41 <elliott> it takes module names, not file names
16:46:50 <Eduard_Munteanu> What's a nice Haskell lib for drawing DAGs?
16:47:04 <johnw> diagrams?
16:47:21 <Eduard_Munteanu> Hm, forgot about it. Does it take care of layout for me?
16:47:32 <johnw> i believe it does a little bit of layout, but not a lot
16:47:33 <Eduard_Munteanu> Something like 'dot'.
16:47:37 <johnw> however, it's completely programmatic
16:47:43 <johnw> why not just output in dot format then?
16:47:56 <elliott> there's a gnuplot library
16:48:01 <Eduard_Munteanu> I guess I could, wasn't sure if there was anything better.
16:48:20 <johnw> I'd ask in #diagrams
16:48:28 <johnw> maybe someone has written some DAG layout code
16:48:38 <Eduard_Munteanu> elliott: does gnuplot lay out DAGs?
16:49:10 <peddie> Eduard_Munteanu: graphviz?
16:49:19 <elliott> oh, I meant graphviz.
16:49:21 <elliott> there's a graphviz library.
16:49:23 <Eduard_Munteanu> peddie: yeah, that's dot
16:49:26 <Eduard_Munteanu> Ah.
16:49:28 <peddie> right
16:49:41 <Eduard_Munteanu> Hm, I'll look for that, thanks.
16:49:43 <peddie> but the haskell lib is called graphviz I thought
16:51:09 <sclv> iirc graphviz has the best layout algos around. diagrams has decent ones but there was some talk of farming out complex layouts from diagrams to graphviz, optionally
16:51:14 <Eduard_Munteanu> peddie: graphviz is actually the package dot belongs to, as well.
16:51:52 <peddie> oh, is dot another library, or a command-line utility?
16:52:08 <Eduard_Munteanu> peddie: cmdline utility, part of the original graphviz
16:52:15 <peddie> oh, I see
16:52:26 <peddie> so there's a lib on hackage that's Data.GraphViz, which is all I've ever used
16:52:26 <Eduard_Munteanu> peddie: Haskell's stuff is merely a binding / generator for the actual graphviz
16:52:29 <peddie> yeah
16:52:31 <Eduard_Munteanu> Ah.
16:52:33 <peddie> I figured
16:52:52 <peddie> also graphviz has an fgl interface, I believe
16:52:55 <peddie> er
16:52:59 <peddie> you know, the hackage library
16:53:01 <peddie> heh
16:54:18 <startling> we should get better at naming haskell packages.
16:54:35 <startling> I feel like bindings-graphiz or something would be more appropriate
16:54:45 <peddie> startling: even just prepending an "h" to everything would work for a lot of cases
16:55:42 <sclv> hpackage
16:55:45 <sclv> hfoo
16:55:49 <sclv> hutils
16:56:16 <c_wraith> hhackage
16:56:23 <c_wraith> For the haskell version of the haskell package repository
16:56:43 <Eduard_Munteanu> hpyjquery   -- when binding to it once isn't enough...
16:56:45 <chrisdone> hmm. cabal configure -v3 --extra-include-dirs=/usr/include/libnm-glib/ works but extra-include-dirs: my cabal file doesn't work, says missing header file. i can see with -v3 that it doesn't include an -I in the args to gcc. what's all that about?
16:56:52 <S_J> can i pass -fhpc  to ghc via cabal?
16:57:09 <mauke> hhhehehe
16:57:19 <johnw> S_J: yes
16:57:50 <peddie> well, if you're trying to differentiate a haskell interface to an existing library from the existing library itself, e.g. hgraphviz isn't too confusing
16:58:01 <peddie> of course bindings-graphviz is more descriptive if it really is just an FFI binding
16:58:26 <startling> ah yes, "hack", the ack bindings
16:58:53 * peddie shrugs
16:59:12 <johnw> there are 38 libraries on Hackage that start with "bindings-", if you need a precedent
16:59:16 <hpaste> Cale pasted “words” at http://paste.tryhaskell.org/90716
16:59:16 <peddie> I think the names of hmatrix and bindings-gsl make sense
17:00:02 <hpaste> Cale revised “words”: “words” at http://paste.tryhaskell.org/90716
17:01:52 <sclv> don't forget the text processing package hawk
17:02:38 <sclv> its not really an ffi binding to graphviz iirc -- lots of stuff is really over the cmd line
17:03:18 <peddie> sclv: I guess the dividing line I had in mind is whether it provides a higher-level haskelly interface like hmatrix or is just a straight-up binding like bindings-gsl
17:04:43 <Eduard_Munteanu> It reminds me it was about time Hackage / cabal got some support for signing / checksumming stuff securely. :(
17:04:46 <peddie> we got confused when I tried to answer someone's question, because the hackage package had the same name as the standalone program it binds to
17:05:21 <Eduard_Munteanu> Just configure https:// and include a sha256sum for each package. :/
17:10:37 <sclv> Eduard_Munteanu: have you looked at the new hackage repo?
17:10:50 <Eduard_Munteanu> sclv: oh? Where's that?
17:10:51 <sclv> you should see if it does what you want, and if not, submit a patch :-)
17:11:13 * Eduard_Munteanu vows to scratch those itches productively :P
17:12:40 <Eduard_Munteanu> http://new-hackage.haskell.org/   ?
17:12:51 <Eduard_Munteanu> Surprisingly easy to Google. :)
17:14:16 <sclv> yep, and the link to the darcs repo at the bottom of that page
17:15:03 <sclv> there's a low traffic cabal-devel list that ppl use for discussing new-hackage too, though its mainly just duncan plugging away at the moment
17:22:46 <osa1> how is this parsed: (\x -> f x >>= g) ? ((\x -> f x) >>= g) or (\x -> (f x >>= g)) ?
17:23:48 <Eduard_Munteanu> osa1: the lambda extends as far as it can
17:24:01 <Eduard_Munteanu> So it's the latter.
17:24:19 <osa1> thanks
17:26:15 <ChongLi> osa1: and that's the secret to do notation
17:26:35 <ChongLi> it just desugars to nested lambdas and binds
17:28:16 <monochrom> :)
17:32:02 <monochrom> @botsnack
17:32:02 <lambdabot> :)
17:33:38 <zRecursive> why is GHC slower than CLISP ?  time ghc -e 'sqrt 1000000' => 1000.0 0.816 secs
17:33:39 <zRecursive>    time cl "(sqrt 1000000)" => 1000 0.420 secs
17:34:28 <dmwit> Because you're not compiling.
17:34:40 <dmwit> Also, because microbenchmarks suck.
17:34:54 <danharaj> that's more like a femtobenchmark
17:35:05 <zRecursive> dmwit: CLISP not compiling too ?
17:35:23 <benmachine> yeah, that's going to be overwhelmingly timing how long the respective runtime systems take to initialise
17:35:30 <benmachine> or something like that
17:35:38 <shachaf> The time to evaluate that expression is completely insignificant compared to all the overhead.
17:35:47 <dmwit> zRecursive: Compile both of them, then.
17:35:59 <shachaf> Even if you compile them you won't get a meaningful result.
17:36:04 <benmachine> now let's hold on
17:36:19 <shachaf> (Or, at least, a result much more meaningful than compiling an empty program.)
17:36:26 <benmachine> the original question was "why is GHC slower than CLISP?"
17:36:31 <zRecursive> dmwit: i see, but here the Expr is got from user
17:36:41 <benmachine> the proper answer to that is, that's not really a question that makes sense
17:37:40 * zRecursive in fact i am curious if GHC can do script things instead of CLISP
17:37:43 <exFalso> hi, does anyone know where i can specify compile options for xmonad? (already asked in #xmonad)
17:38:02 <dmwit> exFalso: no easy way
17:38:23 <dmwit> You can build it yourself.
17:38:27 <exFalso> dmwit: i'm willing to modify xmonad source
17:38:31 <dmwit> Or you can modify xmonad core to have the options you want and reinstall.
17:38:34 <exFalso> dmwit: just not sure where to look
17:39:03 <dmwit> Also, you don't need -threaded to do concurrent X11 stuff. Just open a fresh display for each thread.
17:39:16 <dmwit> err
17:39:22 <dmwit> I take that back. That's not a claim I want to stand by.
17:39:39 <exFalso> i kind of want to do things with the same display:)
17:39:45 <zRecursive> exFalso: cat ~/bin/build-xmonad #!/bin/sh\n ghc -Wall -O2 xmonad.hs\n strip -p --strip-unneeded --remove-section=.comment -o xmonad-small xmonad
17:40:02 <dmwit> exFalso: Can I ask why?
17:40:10 <dmwit> I'm honestly surprised.
17:40:28 <exFalso> dmwit: i'd like to use XTest events in a loop
17:40:48 <exFalso> can i just do that without forking, or will that block everything?
17:41:06 <dmwit> I don't know enough to answer that.
17:41:12 <dmwit> (Which is why I took back my old claim. =P)
17:41:18 <exFalso> :)
17:41:20 <dmwit> Oh, well.
17:41:25 <dmwit> You certainly can't do it without forking.
17:41:26 <exFalso> well i guess trying doesnt hurt
17:41:34 <dmwit> But I was asking why you don't want to open a fresh display.
17:42:02 <exFalso> i'm not familiar with X terminology, ithought a new display means new... verything
17:42:09 <dmwit> (You can't do it without forking. Whether you can do it without -threaded is a different question.)
17:42:11 <Ghoul_> the new hackage looks nice, but functionally its still easier to google "hackage <packagename>"
17:42:23 <dmwit> exFalso: Nah. Display's are basically X's mutexes.
17:42:28 <exFalso> oh
17:43:23 <exFalso> well i tried forkIO with default compile options, whenever i did a threadDelay in the forked thread the xmonad's waiter thread blocked and only continued with the loop if i issued another event
17:44:21 <zRecursive> IIRC, donot compile xmonad using "-threaded" option
17:44:30 <exFalso> i'll try it with another display (at least i get rid of the global mutex i use now)
17:44:49 <exFalso> zRecursive: yeah, xlib doesnt like concurrency
17:49:10 <zRecursive> After using ghci's etags command to produce TAGS, in emacs buffer created by 'run-haskell, i can M-<Tab> to auto-complete. Is it your way to use haskell in Emacs ?
17:50:27 <zRecursive> In fact i like running ghci in xterm, but it is NOT integrated well with Emacs
17:55:10 <exFalso> zRecursive: have you tried ghc-mod?
17:55:27 <exFalso> C-c C-z will launch a ghci session in emacs
17:56:07 <exFalso> it also has all kinds of sweet features
17:56:18 <exFalso> http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html
17:56:47 <exFalso> but this is not all, have a look at its help in emacs
17:57:54 <zRecursive> exFalso: thx, but it seems has no auto-completion
17:58:30 <exFalso> it does... the very first entry on that page
17:58:59 <zRecursive> no response when pressing <Tab> ?
17:59:00 <exFalso> idk whether theres a way to use that with say AC-mode
17:59:35 <exFalso> first off have you installed ghc-mod?
17:59:51 <zRecursive> so i use TAGS, (visit-tags-table "/media/D/qachina/db/doc/haskell") before C-cC-z
17:59:52 <exFalso> second, the shortcut for completion in ghc-mod is C-M-i
18:00:53 <exFalso> installation info is here http://www.mew.org/~kazu/proj/ghc-mod/en/install.html
18:01:13 <zRecursive> yeah, it is C-M-i instead of <Tab>, thanks
18:01:33 <exFalso> also, you dont need etags for thi
18:01:33 <exFalso> s
18:02:05 <zRecursive> great ! using ETAGS, it is M-<Tab> to auto complete
18:02:46 <Michae___> What would the implementation of scan for a rose tree look like?
18:02:57 <exFalso> that works too, but you dont need etags:)
18:03:16 <zRecursive> yeah, same me time
18:03:20 <byorgey> Michae___: scan? as in, something like scanr or scanl?
18:03:36 <zRecursive> s/same/save/
18:05:00 <danharaj> scanr would probably correspond to incrementally folding a tree
18:05:00 <exFalso> Michae___: well you'd need to thikn about how you want to traverse the tree
18:05:19 <danharaj> scanl seems straightforward
18:05:19 <Michae___> exFalso: In this case, bottom up what be best
18:05:27 <Michae___> and yes, scanl
18:06:06 <exFalso> what do you mean by bottom up? depth first, or breadth first?
18:06:57 <byorgey> the obvious thing that occurs to me is to first write a Foldable instance (if one doesn't already exist) and just do  scanl . toList
18:07:14 <Michae___> Breadth first, starting at the bottom
18:07:17 <byorgey> if that's not efficient enough for some reason then you can try thinking about something more sophisticated.
18:07:52 <danharaj> I was thinking it would push the accumulator down the tree, replacing each node with the current accumulated value.
18:08:00 <exFalso> so id you want breadth first then it's not as trivial as it sounds, try to do what byorgey suggests, write a Foldable instance for breadth first traversal first
18:08:05 <exFalso> *if
18:08:16 <byorgey> oh, if you want to get a Tree out instead of a list, then my suggestion doesn't work
18:08:46 <byorgey> writing a Foldable instance for breadth first traversal sounds tricky.
18:10:23 <danharaj> I can think of an ugly way.
18:11:15 <danharaj> Reminds me of a week-long kick I had on tree transducers.
18:11:20 <sclv> > scanl (+) 0 [1..10]
18:11:20 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
18:11:28 <sclv> scanl is top down, no?
18:11:41 <Michae___> what's that daharaj?
18:12:01 <danharaj> Michae___: a tree transducer is a program that takes a tree of one type and outputs a tree of another type, possibly with the nodes relabeled.
18:12:17 <danharaj> Some kinds of transducers have very simple structure, e.g. folds.
18:12:19 <simon> byorgey, if it were depth-first, it would be straight-forward, right?
18:12:21 <Michae___> That seems to be what I want to do
18:12:33 <sclv> top down breadth first fold should be easy, i think?
18:12:41 <byorgey> simon: yes
18:12:52 <sclv> it depends if you want a full traversal or just path-prefixes?
18:13:02 <byorgey> Eduard_Munteanu: diagrams doesn't do graph layout.  the graphviz bindings actually let you round-trip a graph through dot etc. so you never have to leave Haskell-land.  You just have to have graphviz installed.
18:13:06 <sclv> the latter seems closer to what a scan would do, intuitively
18:13:30 <danharaj> yes I thought of folding paths to a node and labeling the node with that accumulation.
18:14:23 <danharaj> Michae___: what do you want? it seems you question was ambiguous.
18:14:29 <Eduard_Munteanu> Thanks, byorgey
18:15:14 <byorgey> Michae___: perhaps you can give an example?  I am now confused about what you want too.
18:17:10 <Ghoul_> :t foldl
18:17:10 <lambdabot> (a -> b -> a) -> a -> [b] -> a
18:17:21 <Michae___> I'm sorry, I'll try to refrase it. I'm trying to infer types from a parse tree, so I want to start at each bottom element, determine its type, then using its type and that of its siblings, do the same with its parents, until the top. So it's kind of a bastardized breadth first, bottom up search. I'm building the typed tree all along, and then using the value at the node of the untyped tree to add to the typed tree, whi
18:17:22 <Michae___> ch is why I thought it ideal for a scan
18:17:56 <Ghoul_> how do I fold an initial value into every function in a list and get the output
18:18:08 <Ghoul_> ie: 3 into [ (+3), (+1) ] and yield 7
18:18:26 <johnw> > map 3 [(+3)]
18:18:27 <lambdabot>   Could not deduce (GHC.Num.Num
18:18:27 <lambdabot>                      ((GHC.Integer.Type.Integ...
18:18:34 <johnw> > map ($ 3) [(+3)]
18:18:35 <lambdabot>   [6]
18:18:44 <byorgey> Michae___: oh.  I'm pretty sure that is just a fold.
18:18:54 <prophile> @hoogle (Monad m) => [m a] -> m [a]
18:18:54 <Ghoul_> Yes, however
18:18:55 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:18:55 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
18:18:55 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
18:18:56 <Ghoul_> thats not quite the same
18:19:07 <danharaj> byorgey: it sounds to me like a fold that memoizes its results at the nodes instead of smashing down the tree.
18:19:07 <byorgey> that's exactly what a fold is -- you compute values for the leaves, and then use those values + the parent node to compute the value for the parent node, and so on
18:19:09 <Ghoul_> > map ($ 3) [(+3), (+1)]
18:19:10 <lambdabot>   [6,4]
18:19:11 <prophile> (sequence [(+ 3), (+ 1)]) 3
18:19:15 <prophile> > (sequence [(+ 3), (+ 1)]) 3
18:19:16 <byorgey> danharaj: ...which is just a fold.
18:19:16 <lambdabot>   [6,4]
18:19:28 <byorgey> folds don't have to "smash" anything.  a fold could produce another tree as output.
18:19:35 <byorgey> in fact fmap can always be implemented as a fold.
18:19:59 <Michae___> byorgey: Yes, but I'm storing the computed values, and the stored values are what I want to return, so I'm thinking it would be more natural as a scan, though I could be wrong
18:20:01 <shachaf> yay, initial algebras "and stuff"
18:20:08 <danharaj> byorgey: you're correct. I was thinking of it like (w a -> b) -> w a -> w b.
18:20:12 <byorgey> Michae___: you are wrong =)
18:20:42 <byorgey> Michae___: you can use a fold to produce, e.g. an annotated tree, where all nodes have been paired with their inferred types
18:22:55 <byorgey> > let treeFold f (Node a ts) = f a (fmap (treeFold f) ts) in  treeFold (\a xs -> (a, a + sum xs)) (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]])
18:22:56 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t0)
18:22:56 <lambdabot>  Expected t...
18:23:01 <simon> it could also be a map in which you map a non-annotated tree into an annotated one. if you want to accumulate information on the side, it could be a monadic map, (Monad m) => (a -> b) -> Exp a -> m (Exp b)
18:23:17 <shachaf> simon: (a -> m b)
18:23:20 <byorgey> > let treeFold f (Node a ts) = f a (fmap (treeFold f) ts) in  treeFold (\a xs -> (a, a + (sum . map snd $ xs))) (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]])
18:23:21 <lambdabot>   (1,15)
18:23:26 <simon> shachaf, thanks.
18:23:31 <prophile> I love listening to spj's talks
18:23:31 <byorgey> err, whoops
18:23:40 <shachaf> Some people mean Data.Foldable by "fold"
18:23:47 <Ghoul_> > let fns = [ (+1), (+2), (+3) ] in foldl (\x y -> (fns !! y) x) 3 [0..(length fns - 1)]
18:23:48 <lambdabot>   9
18:23:53 <shachaf> It's annoying that the two mostly-unrelated things have the same name.
18:24:22 <danharaj> shachaf: who talks about Data.Foldable anymore with lens around? :P
18:24:32 <shachaf> danharaj: lens people.
18:24:38 <dmj> data Tree a = Empty | Tree a :^: Tree a
18:24:39 <byorgey> > let treeFold f (Node a ts) = f a (fmap (treeFold f) ts) in  treeFold (\a xs -> Node (a, a + (sum . map (snd . rootLabel) $ xs)) xs) (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]])
18:24:40 <lambdabot>   Node {rootLabel = (1,15), subForest = [Node {rootLabel = (2,2), subForest =...
18:24:45 <byorgey> ^^^ there we go.
18:24:48 <dmj> what is that symbol? :^:
18:24:56 <danharaj> dmj: not standard
18:24:57 <Ghoul_> a guy with a pointy nose
18:25:06 <byorgey> Michae___: ^^^ there's an example of folding a rose tree in order to annotate each node with the sum of its entire subtree
18:25:23 <dmj> danharaj: from "Functional Programming with Overloading and Higher-Order Polymorphism"
18:25:34 <sclv> Michae___: just read this related post like 30 min ago http://brianmckenna.org/blog/type_annotation_cofree
18:25:35 <dmj> danharaj: It's valid haskell tho
18:25:45 <byorgey> this kind of thing is a lot more concise with attribute grammars but it's certainly possible to do it with a fold
18:25:46 <danharaj> dmj: It's defined somewhere there then.
18:25:50 <sclv> but byorgey's solution is probably more straightforward
18:25:58 <shachaf> dmj: It's defined right there.
18:26:12 <byorgey> dmj: it is an infix data constructor
18:26:14 <shachaf> dmj: The definition defines the type construct Tree and the data constructors Empty and (:^:)
18:26:28 <shachaf> type cosntructor
18:26:34 <shachaf> type constructor
18:26:57 <byorgey> typo constructor
18:27:16 <shachaf> That's me.
18:27:17 <dmj> byorgey: ah, was not aware of infix data constructors
18:27:32 <byorgey> dmj: note they are requred to begin with :
18:27:43 <byorgey> required, even
18:27:53 <danharaj> Can't tell if in #haskell or #sweetbroandhellajeff
18:27:54 <shachaf> The typo constructor strikes again!
18:32:54 <Ghoul_> > mapAccumL (\x f -> (f x, [])) 3 [(+2), (+3)]
18:32:55 <lambdabot>   (8,[[],[]])
18:33:11 <Ghoul_> (is there an accum function that doesn't care about the part on the right of the tuple?)
18:34:04 <danharaj> hmm
18:34:35 <Ghoul_> Nevermind, I'm silly
18:34:36 <Ghoul_> > foldl (\x f -> f x) 3 [(+2), (+3)]
18:34:37 <lambdabot>   8
18:34:38 <Ghoul_> lol
18:34:47 <danharaj> how does one model haskell constraints categorically?
18:35:30 <sclv> typeclass constraints?
18:35:44 <danharaj> sure, but I'm particularly interested in equality constraints.
19:12:55 <external-reality> I'm convinced that only with code-review, caring programmers, and a language like Haskell (that let's one easily spot redundancy, misinterpretation, and discrepancy in data representations) can a software team slow the rate of decay in legibility in code.
19:14:42 <external-reality> After all it's Haskell that taught me to see mistakes in other languages. Don't quite know how but after 4 years with Haskell I can see mistakes in all code much more easily.
19:15:53 <zRecursive> external-reality: how to you debug a haskell app. ?
19:16:41 <dmwit> [citation needed]
19:16:58 <zRecursive> ghci and printf is my tools as a haskell newbie
19:17:07 <dmwit> Those are pretty good tools.
19:17:25 <dmwit> I guess some people are also able to use ghci's debugger to good effect.
19:17:29 <dmwit> But I'm not. :3
19:17:52 <dolio> Someone should resurrect buddha.
19:17:53 <zRecursive> i never use breakpoint ?!
19:19:15 <dmwit> dolio: What's buddha?
19:19:27 <dmwit> Also, as long as we're talking about resurrections, what happened to hat?
19:19:27 <dolio> An old "declarative debugger".
19:20:00 <zRecursive> i only used GDB before
19:21:39 <external-reality> zRecursive: With the debugger of course. I don't get many baffling bugs quite often though. I wrestle with the type system sometimes.
19:23:03 <external-reality> zRecursive: If you asked me how I profile a Haskell program. I would have to direct you toward someone more skilled than I.
19:23:27 <zRecursive> external-reality: sometimes "type check" cannot guarantee a correct code ?
19:23:37 <dolio> dmwit: I'm not entirely sure how it differed from hat, or which came first.
19:24:02 <dmwit> ah
19:24:09 <external-reality> zRecursive: I don't recall saying that it ever guaranteed anything.
19:24:49 <Cale> zRecursive: Usually breaking your program down into smaller parts and then ensuring that those parts work correctly will help you find bugs.
19:24:55 <zRecursive> external-reality: I will learn "profile a haskell program" later, but first i need to master the debugging skills
19:25:23 <dolio> dmwit: The descriptions I've heard of buddha sound like "hat-detect".
19:25:27 <zRecursive> Cale: yeah
19:25:31 <external-reality> zRecursive: I agree with Cale.
19:25:38 <Cale> You don't tend to need a typical sort of debugger, because functions are referentially transparent -- if they produce a certain result for some parameters, they'll always produce that result when given those parameters
19:25:52 <Cale> That lets you test and debug things in isolation from the rest of the program.
19:26:06 <dolio> You run a faulty example, and then drill in until you find the source of the problem.
19:26:17 <Cale> (and have some guarantee that they'll work the same way in the full program)
19:26:37 <external-reality> Cale: If I'm knee deep in side effects the ghci debugger comes in handy.
19:28:15 <zRecursive> Haskell is too abstractive to debug app by instruction step by step as C does
19:28:22 <external-reality> Cale: For example I was porting a little bit blitter and used the debugger.
19:29:43 <external-reality> ZRecursive: That is not always so. The ST Monad allows a coder to code very imperative like in pure code.
19:30:51 <external-reality> ZRecursive: Monads sequence the operations. The steps will jump around a bit differently but I still find debugging useful sometimes.
19:31:59 <zRecursive> external-reality: more experience is welcome as i never use the debug tool in GHCi
19:34:30 <DiegoNolan> what is the package name of Control.Lens?
19:34:36 <Clint> DiegoNolan: lens
19:34:56 <DiegoNolan> hmm
19:35:07 <external-reality> zRecursive: DiegoNolan: What or Why?
19:35:15 <external-reality>  DiegoNolan: What or Why?
19:35:31 <DiegoNolan> i have it in installed but ghci can't find it
19:36:09 <external-reality> Uh oh, looks like ghci might be looking at the wrong package.conf or something.
19:36:38 <zRecursive> Just finishing `cabal install ghc-mod`, how to set dir1/dir2 in (setq ghc-ghc-options '("-idir1" "-idir2")) ?
19:37:54 <zRecursive> moreover, do i  need (setq ghc-hlint-options '("--ignore=Use camelCase")) ?
19:41:02 <external-reality> zRecursive: What version of emacs are you using.
19:42:04 <zRecursive> external-reality: emacs --version => GNU Emacs 23.4.1
20:00:24 <S11001001> Can any applicatives contradict?: (f *** g) <$> (liftA2 (,) ma mb) = liftA2 (,) (f <$> ma) (g <$> mb)
20:01:18 <dolio> No.
20:01:36 <S11001001> dolio: Okay, then the naturality law isn't very useful: https://github.com/ghc/packages-base/blob/ghc-7.6.3-release/Control/Monad/Zip.hs#L29
20:02:05 <S11001001> dolio: I propose instead: f . fst <$> mzip ma ma = f . snd <$> mzip ma ma = f <$> ma
20:02:20 <dolio> Oh, do you mean, is it possible to write an instance that contradicts that?
20:02:26 <dolio> I don't know the answer to that question.
20:02:27 <S11001001> dolio: Yes
20:02:32 <S11001001> dolio: I don't think it is possible.
20:03:01 <S11001001> dolio: that is, I think it arises from the existing Applicative laws.
20:03:50 <shachaf> S11001001: This "naturality" is one of the standard Applicative laws, at least when expressed in one form.
20:04:12 <S11001001> shachaf: the one I'm referring to is the one on MonadZip; sorry I didn't clarify that
20:04:14 <dolio> MonadZip doesn't have an applicative superclass.
20:04:23 <S11001001> dolio: it will
20:04:27 <shachaf> See section 7 in http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
20:04:36 <shachaf> S11001001: But mzip is not going to be the same as liftA2 (,)
20:04:48 <S11001001> shachaf: Exactly my point
20:05:07 <S11001001> shachaf: as it stands the law on mzip isn't strong enough to forbid that
20:06:17 <shachaf> What's the motivation for mzip other than making zipping monad comprehensions work?
20:06:26 <dolio> There isn't one.
20:07:12 <shachaf> It has exactly one instance.
20:07:32 <shachaf> I'm not sure it makes much sense to talk about what its laws "should" be given that.
20:07:54 <dolio> It could probably have more.
20:07:55 <S11001001> shachaf: then should it list laws at all?
20:08:05 <dolio> Like Maybe.
20:08:20 <shachaf> True.
20:08:32 <shachaf> And its Maybe instance would probably be the same as liftA2
20:08:38 <dolio> Yes.
20:09:00 <shachaf> And there's Stream, I guess.
20:09:34 <shachaf> It seems like associativity is a good that's missing. Unless you can derive it somehow.
20:10:14 <S11001001> shachaf: it derives from the one I suggested above, I believe
20:11:09 <S11001001> I'm not sure about the "information preservation" law; that seems okay and might help in more situations, including associativity.
20:11:27 <shachaf> S11001001: Isn't it simpler to say fst <$> mzip ma ma = snd <$> mzip ma ma = ma?
20:11:30 <shachaf> Or is that not the same?
20:11:53 <S11001001> shachaf: yeah, that's even better
20:12:17 <S11001001> /the same
20:13:22 <shachaf> This sounds like a law for a subclass of Applicative.
20:13:25 <shachaf> (Or of Apply.)
20:13:26 <shachaf> Maybe.
20:14:01 <S11001001> shachaf: With the proposed -libraries change this will be a subclass of Applicative
20:15:26 <CaptainK> how do I load a matching text decoder here? http://ideone.com/eemTfe
20:16:01 <CaptainK> if I'm asking the question right, looking for no escape sequences in the output
20:16:09 <shachaf> S11001001: No, I mean, a law on liftA2.
20:16:22 <monochrom> use putStrLn. mapM_ putStrLn contents
20:17:44 <S11001001> shachaf: Oh, yeah.
20:23:15 <sclv> i don't think Maybe can give you the appropriate Zip
20:23:16 <sclv> because it kills information preservation?
20:23:42 <shachaf> What do you mean?
20:23:43 <sclv> the only properly zippy things are representables, i think
20:24:10 <sclv> and except for the degenerate case their zippy applicative and monadic operations don't coincide
20:24:25 <sclv> shachaf: well if i mzip Nothing and Just 1
20:24:27 <S11001001> sclv: I don't think it kills information preservation; the precondition excludes anything but Just/Just and Nothing/Nothing
20:24:28 <sclv> I get Nothing, eh?
20:24:34 <shachaf> sclv: And zip [] [1] = []
20:24:40 <sclv> oh, i see
20:24:42 <sclv> misread that
20:24:57 <sclv> this is a "smushy zip"
20:26:29 <sclv> in that case, the zip operation isn't even a proper applicative.
20:26:48 <shachaf> Why not?
20:27:03 <CaptainK> monochrom: [Decode error - output not utf-8]
20:27:04 <sclv> oh, mispoke, proper monad i meant.
20:27:19 <sclv> which it isn't anyway -- i'm talking in circles a bit
20:27:45 <shachaf> ZipList isn't a monad... *Or is it*?!
20:28:57 <sclv> so yeah there are a zillion monadzips then
20:29:07 <sclv> but the laws seem ok to me
20:30:34 <shachaf> A bit odd that it doesn't have an identity.
20:30:35 <sclv> i'm curious about how zips and binds distribute in general though -- seems like there should be some nice properties
20:30:46 <sclv> identity law?
20:31:07 <byorgey> CaptainK: what version of GHC do you have?
20:31:09 <sclv> or identity as in "pure"?
20:32:02 <shachaf> Yes, as in pure.
20:32:04 <CaptainK> byorgey: you are on the right track...I just loaded it into GHC instead of Sublime Text and it works, so its a Sublime thing...err not so sublime :P
20:32:20 <shachaf> I mean, it's MonadZip, so it has return.
20:32:27 <byorgey> CaptainK: OK, so Sublime must be storing files using some encoding other than UTF-8
20:32:31 <byorgey> you can probably configure that
20:32:34 <shachaf> But it's not compatible with zipping.
20:32:40 <CaptainK> yes, I believe so
20:32:57 <shachaf> I wonder whether you implicitly get something like an identity from list comprehensions. I guess not?
20:33:48 <sclv> shachaf: isn't return () identity?
20:33:48 <CaptainK> interesting anyway,  should figure it out, but I'm more interested in learning more basic haskell
20:34:17 <shachaf> sclv: Presumably it would be repeat () for lists.
20:34:20 <shachaf> Like ZipList.
20:34:47 <shachaf> I mean, liftM fst (mzip x (return ())) /= x
20:34:52 <sclv> oh, right, good point
20:35:18 <sclv> yeah it would make sense to equip it with an appropriate zip identity operation
20:35:45 <shachaf> There's no explicit way to give an empty zipping comprehension with the current notation, though.
20:36:01 <sclv> right, so as long as this class comes from the needs of sugar, we don't care :-)
20:36:29 <roconnor> > pure () :: ZipList
20:36:30 <lambdabot>   Expecting one more argument to `Control.Applicative.ZipList'
20:36:37 <roconnor> > pure () :: ZipList ()
20:36:38 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList ()))
20:36:38 <lambdabot>    arising...
20:36:56 <lispy> are there any tricks for defining a storable instance when you don't have a C header?
20:37:04 <sclv> it might be fun to try to build some actually interesting toys designed for use with monad comprehensions
20:37:14 <dolio> You don't need an identity to desugar the syntax, and that's presumably the only reason this class exists.
20:37:20 <sclv> we haven't had much collective fun with them since they've arisen
20:37:22 <johnw> lispy: it's all just numbers, can you figure out what they are another way?
20:37:23 <lispy> I have a record and I want to convert it to C without writing a .h file, specifically
20:37:38 <sclv> dolio: but there is a point that the class is tantalizingly like something actually more interesting :-)
20:38:03 <dolio> I could even contrive a MonadZip without an identity. :)
20:38:09 <elliott> desugar-based design :(
20:38:16 <shachaf> The law fmap fst (zip m m) = m seems like a vaguely interesting one, at least.
20:38:18 <lispy> johnw: johnw take for instance, this type https://github.com/dagit/haray/blob/master/src/Graphics/Rendering/Haray/HitRecord.hs#L12
20:38:48 <johnw> lispy: I mean, you can fake a Storable instance however you want
20:39:12 <johnw> as long as you peek/poke at the right offsets, and return the right alignment and sizeOf
20:39:28 <johnw> but how is C going to know what your structure layout is?
20:39:30 <lispy> I just realize what's making it difficult. Instead of writing instance Storable a => Storable (HitRecord a) where, I should just do it for Float and Double
20:39:37 <johnw> ah
20:39:52 <monochrom> what is Texture a?
20:40:05 <lispy> The problem I'm having in this instance is getting at the sizeOf a
20:40:05 <shachaf> @let instance Show a => Show (ZipList a) where showsPrec n (ZipList xs) = showParen (n > 10) $ showString "ZipList " . shows xs
20:40:06 <lambdabot>  Defined.
20:40:44 <lispy> monochrom: I think for the purposes of marshaling to C I have to ignore that one: https://github.com/dagit/haray/blob/master/src/Graphics/Rendering/Haray/Texture.hs#L12
20:41:28 <lispy> why do I have a bang on a function :)
20:41:35 <monochrom> this is no fun. I am given too little information on constraints and requirements.
20:41:35 <dolio> shachaf: What if I want my comprehensions to work with strict lists? :þ
20:41:40 <lispy> It's almost like I changed something and never removed it...
20:42:04 <shachaf> dolio: It would be more believable if you used some other pronoun in that sentence.
20:42:11 <dolio> Heh.
20:42:54 <lispy> monochrom: The goal is to port my Haskell-based raytracer to opencl. Currently, it works for scenes that are hard-coded in the OpenCL kernel. I'm looking for a way to lift that constaint. Right now I'm exploring marshalling my types to OpenCL
20:42:58 <lispy> monochrom: does that clarify at all?
20:43:33 <lispy> I picked HitRecord to see how it works, but I don't actually need to marshal hitrecords
20:43:42 <lispy> Sorry if that was confusing
20:45:27 <CaptainK> How do you strip out the \NUL in a file with each line having: "\NULm\NULo\NULd\NULo\NUL"?
20:45:52 <elliott> that file looks like utf-16.
20:46:01 <CaptainK> its spanish?
20:46:18 <CaptainK> modo
20:46:33 <CaptainK> ic
20:46:39 <LordBrain> Does hdevtools + syntastic in vim provide a way to insert a type signature or the function my cursor is on?
20:46:44 <monochrom> I don't understand "marshal to OpenCL". does it mean OpenCL will know or assume a struct layout and read its fields? or does it mean OpenCL just passes and copies around a block of memory verbatim but never give it semantics?
20:46:45 <CaptainK> printed properly?
20:47:12 <LordBrain> *for the function
20:47:29 <johnw> LordBrain: ghc-mod can do that, but I've not yet gotten it working with hdevtools
20:47:39 <lispy> monochrom: the former
20:47:54 <LordBrain> johnw, they interfere with eachother huh?
20:48:09 <monochrom> then I don't understand avoiding writing a *.h file or a struct declaration.
20:48:09 <johnw> i've never tried to combine them
20:48:21 <LordBrain> oh so maybe it would work fine?
20:48:22 <CaptainK> do you see ice with the e having an accent? ic
20:48:36 <monochrom> do you know what struct layout OpenCL will assume?
20:48:38 <LordBrain> just be slower probably
20:48:38 <lispy> monochrom: normal C like gcc assumes is slightly different than opencl's c99-isms
20:49:08 <lispy> I'm not sure yet what an OpenCL float3 would map to in C99
20:49:17 <lispy> float[3], perhaps
20:49:34 <LordBrain> johnw, i remember seeing a post years ago on how to do it yourself using ghci, i think dons blog... is taht post still available somewhere?
20:49:37 <lispy> monochrom: I still have a lot of unknowns with this myself
20:49:47 <CaptainK> ee with the "n" having a "virgulilla".???
20:50:28 <lispy> but yeah, maybe writing some .h files would be the path of least resistance...
20:50:37 <byorgey> CaptainK: yes
20:51:14 <CaptainK> ok gtk
20:51:44 <byorgey> CaptainK: this sounds very strange: "a file with each line having: "\NULm\NULo\NULd\NULo\NUL""
20:51:51 <byorgey> are you sure you know what encoding is used for the file?
20:51:54 <solidus-lake> is hacanon no longer in use?
20:52:00 <solidus-lake> the project page says access denied
20:52:02 <CaptainK> no not sure
20:52:14 <CaptainK> I'll see if I can post the link...
20:52:24 <solidus-lake> and if its discontinued is there another effort to auto generate bindings for c libs?
20:52:41 <byorgey> CaptainK: try opening a terminal and typing 'file <filename>'
20:52:48 <byorgey> where <filename> is the name of your file
20:52:58 <byorgey> it might auto-detect the encoding
20:53:08 <solidus-lake> stepcut: are you around?
20:53:15 <monochrom> hsc2hs uses gcc to find offsets and sizes. if you say, that's wrong answer for OpenCL, then I agree hsc2hs is useless, and therefore *.h is useless. But then, equally true, writing the Storable instance by hand requires knowing, knowing, really knowing, what OpenCL assumes.
20:54:04 <johnw> what it assumes, for which compiler, for all platforms, for all time
20:54:48 <CaptainK> byorgey: There is a info file with it saying that it is encoded for Windows, and that is what I'm on.
20:55:03 <byorgey> "encoded for Windows".  not helpful. =P
20:55:11 <byorgey> sorry, I thought you were on OSX
20:55:12 <CaptainK> lol, thats what I thought.
20:55:18 <solidus-lake> monochrom: OpenCL is an open standard
20:55:19 <monochrom> it usually means UTF-16
20:55:34 <CaptainK> could try it on one of my vm's
20:55:35 <solidus-lake> monochrom: and im sure ati / nvidia has posted enough details
20:55:37 <monochrom> I am too lazy to learn OpenCL tonight. perhaps another day
20:56:05 <solidus-lake> monochrom: are you thinking of linking to OpenCL from haskell?
20:56:14 <monochrom> I am not. lispy is.
20:56:20 <byorgey> ah, so since elliott originally said it looked like UTF-16, and monochrom says "encoded for Windows" usually means UTF-16, let's assume it is using UTF-16.
20:56:38 <CaptainK> ok, we can try something?
20:56:43 <monochrom> it's highly like UTF-16 with BOM at the beginning.
20:56:44 <solidus-lake> lispy: OpenCL stores its own memory in a configuration that is per device, the specification for opencl does not dictate size or implimentaiton
20:56:54 <solidus-lake> lispy: use a small c program that transfers things to open cl
20:56:59 <solidus-lake> lispy: wrap the c program in haskell
20:57:04 <solidus-lake> think thats your best bet
20:57:20 <solidus-lake> unless you want to dig into device specs
20:57:31 <LordBrain> johnw, i found a link for dons's script from 2006, but it says access denied.
20:57:48 <solidus-lake> OpenCL is compiled on the device as a shader so its going to be very hard to reliably know what that memory space looks like
20:58:01 <byorgey> CaptainK: in that case the solution is probably to use the hSetEncoding function to specify the encoding when reading the file.
20:58:13 <byorgey> Unless someone wants to correct me and suggest some higher-level way to do this.
20:58:31 <CaptainK> that sounds like a good thing for me to know
20:58:39 <byorgey> in any case, reading the file as if it is UTF-8 and then stripping out the resulting \NUL characters is NOT the right thing to do.
20:58:45 <CaptainK> dealing with many languages
20:59:00 <CaptainK> true
20:59:14 <lispy> solidus-lake: I'm trying to pass a chunk of memory (struct SceneElement *) to the kernel. I figured I would make my layout match on both sides.
20:59:19 <CaptainK> it needs to be parsed properly
20:59:19 <lispy> solidus-lake: are you saying this won't work?
20:59:41 <lispy> solidus-lake: I'm not sure what you mean by having a C program transfer the memory
20:59:44 <CaptainK> want the characters to match.
21:00:02 <lispy> solidus-lake: how is that different than using something like Binary or Storable to get a chunk of bytes?
21:00:15 <CaptainK> however, when I cut and paste some characters like I did here: http://ideone.com/eemTfe
21:00:47 <solidus-lake> lispy: sorry, i thought you couldn't interface with opencl data directly, thought it had to be piped back through the drivers interface to whatever language you wanted
21:01:04 <CaptainK> then those characters work in GHC but Sublime Text compains [Decode error - output not utf-8]
21:02:24 <byorgey> what do you mean, Sublime Text complains?
21:02:35 <lispy> solidus-lake: I'm getting confused. Here is an example program that sends float* to the kernel: http://dagit.github.io/posts/2013-04-29-opencl-and-language-c-quote.html
21:02:45 <lispy> solidus-lake: I don't know if this actually generalizes to structs or not
21:03:17 <lispy> maybe I have to push pointers to chunks of memory containing many primitive types?
21:03:38 <lispy> I have a book on opencl but I loaned it to a friend...
21:04:02 <CaptainK> byorgey: it spits out that message when I try the build, but in GHC it likes it without error
21:04:26 <byorgey> CaptainK: Sublime Text gives you an error message?  Or GHC does?
21:04:42 <byorgey> and by "in GHC" do you mean "in GHCi"?
21:05:04 <CaptainK> Sublime gives me an error message about the decode when I try to build
21:05:13 <CaptainK> GHCi does not
21:05:18 <CaptainK> BUT
21:05:41 <CaptainK> when I switch from let contents = ["age","aire","air","air"]
21:05:44 <CaptainK> to
21:05:57 <CaptainK> contents <- fmap lines (readFile "es.txt")
21:06:21 <mauke> print contents
21:06:23 <CaptainK> then GHCi spits out the \NUL characters and so does Sublime
21:06:33 <mauke> ah
21:06:35 <CaptainK> mauke: did that
21:06:50 <byorgey> CaptainK: yes, that's because readFile uses your default locale encoding, which is wrong for es.txt
21:07:00 <byorgey> you have to use hSetEncoding as I said above
21:07:40 <solidus-lake> lispy: very cool! didn't know that interface existed, so whats your question then?
21:07:48 <solidus-lake> lispy: sorry i assumed you were asking something you werent
21:08:16 <solidus-lake> lispy: i'm not sure if i can help but maybe, to be honest i've worked with cuda before and only read briefly on openCL but thats enough for me to fully understand the snippet you sent
21:08:28 <CaptainK> ok and can you give me an example of hSetEncoding ...meanwhile googling it
21:08:31 <byorgey> CaptainK: use openFile to get a handle, then hSetEncoding, then hGetContents.
21:08:46 <byorgey> CaptainK: don't google, hoogle =)
21:08:56 <byorgey> @where hoogle
21:08:56 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
21:09:03 <CaptainK> newbie here so ok, looking
21:09:24 <byorgey> for looking up names of library functions you always want to use hoogle instead of google
21:09:31 <byorgey> google might find you out-of-date documentation
21:09:37 <shachaf> Or Hayoo.
21:09:57 <byorgey> yes, or hayoo, once you start wanting to look up things from packages that are not indexed by hoogle
21:10:20 <byorgey> hoogle also has a very nice search-by-type feature.
21:10:36 <byorgey> @hoogle [a] -> [a]
21:10:37 <lambdabot> Prelude cycle :: [a] -> [a]
21:10:37 <lambdabot> Data.List cycle :: [a] -> [a]
21:10:37 <lambdabot> Prelude init :: [a] -> [a]
21:10:44 <shachaf> I,I a family of packages indexed by a search engine
21:10:53 <lispy> solidus-lake: I'm trying to pass a bunch of structs to an opencl kernel. These are structs that I want to define.
21:10:56 <johnw> owl face!
21:11:06 <lispy> solidus-lake: I found some SO questions that make me think this is a reasonable thing to do
21:11:34 <joelteon> (QvQ)
21:11:36 <lispy> solidus-lake: Now, the trick I'm having is how to properly define the marshalling code from Haskell types to raw memory
21:11:44 <solidus-lake> lispy: kk, the memory of those structs match the way you define them then ;)
21:12:15 <lispy> will the memory layout on the host in C match the memory layout expected on the device?
21:12:20 <solidus-lake> lispy: looks like that code you sent to me is using c to interface with opencl, so their structs memory will match whatever the memory type is in c
21:12:31 <lispy> I think they will if I use the cl_foo types in a struct on the host
21:13:00 <solidus-lake> lispy: yes
21:14:15 <solidus-lake> lispy: i think your a little confused on how opencl interacts with local and device memory
21:14:17 <lispy> that means I have to write my structs twice :(
21:15:05 <solidus-lake> in that example what they are doing is defining c structs that are used to pass the values off to opencl and instructing opencl and then telling opencl what the layout of the memory of those structs are
21:15:22 <solidus-lake> openCL if it's anything like cuda should have an interface to then get the result back and put it back into that struct
21:15:46 <solidus-lake> so from your perspective your just writing an interface in your code to take the c struct and you should never worry about how its stored on the device
21:15:53 <lispy> solidus-lake: if you mean the example from my blog, it's just using float*
21:16:10 <solidus-lake> lispy yeah, but its initializing it an array of 20 floats that are the size of cfloat
21:16:21 <solidus-lake> and its getting the size from c itself it looks like by calling sizeof
21:16:37 <lispy> :t sizeOf
21:16:38 <lambdabot>     Not in scope: `sizeOf'
21:16:38 <lambdabot>     Perhaps you meant one of these:
21:16:38 <lambdabot>       `IM.size' (imported from Data.IntMap),
21:16:44 <lispy> sizeOf is from Storable
21:17:07 <shachaf> sizeOf should take a proxy. :-(
21:17:16 <lispy> So, that example makes sense to me because it's using a contiguous chunk of memory as floats.
21:17:24 <shachaf> Maybe I should complain on libraries@.
21:17:29 <lispy> structs can be more onerous
21:17:40 <shachaf> Maybe I can trick lispy into complaining for me.
21:18:25 <solidus-lake> lispy, but you can still get the size of their elements and pass a pointer back and forth
21:18:55 <CaptainK> I'm not understanding from this: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html , how I use hSetEncoding and hGetEncoding...are there any examples?
21:19:06 <lispy> solidus-lake: yes, if my host C compiler doesn't play too many tricks relative to the device :)
21:19:49 <solidus-lake> lispy: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs
21:19:53 <shachaf> So, given that g (\j -> j (map (cata j) m)) = k (map g m), is g = cata k?
21:19:58 <solidus-lake> lispy:  the openCL libraries take care of that for you ;)
21:20:15 <solidus-lake> lispy: OpenCL says it'll play nicely with c, if you play nicely with c, everyone plays nicely
21:20:26 <lispy> solidus-lake: I'm familiar with the FFI. What I'm not familiar with is the memory layout differences between host and opencl.
21:20:49 <solidus-lake> lispy: my point is that OpenCL is designed in such a way that it need not be known
21:21:37 <lispy> cool. Now I just need to define my structs twice. Once for host and once for opencl. Anyway to use the same header?
21:22:09 <lispy> the types seem to have different names between the two. cl_float vs. float
21:22:13 <solidus-lake> lispy afaik no, those are two different things
21:22:35 <solidus-lake> if it makes you feel better c programs that interface with OpenCL have to do the same thing
21:23:28 <byorgey> CaptainK: do { h <- openFile "es.txt" ReadMode; hSetEncoding h utf16; contents <- hGetContents h; ... }
21:23:44 <monochrom> that makes my cynical side feel better and my sympathetic side feel worse
21:23:52 <shachaf> S11001001: I guess your thing is just an "idempotent monoidal functor" or something like that.
21:24:41 <S11001001> shachaf: that sounds like a good characterization
21:25:51 <shachaf> So you think zipping should be idempotent (in the effects). Which I guess is reasonable.
21:27:14 <CaptainK> byorgey: do I have to import anything into Prelude?
21:29:57 <lispy> solidus-lake: ah. Well, thanks for your help.
21:30:42 <solidus-lake> lispy: no problem :) hope it was helpfull and not harmfull, like i said, i come from cuda's world mostly
21:31:09 <CaptainK> how do you query lamdabot where hGetHandle lives?
21:31:12 <lispy> solidus-lake: It's good. I'm just bummed that I need to make a header file for the host :)
21:31:13 <solidus-lake> lispy: also another hting to think about, the way you represent data in OpenCL doesn't have to map 1:1 to the representation in C, chances are you can rejigger it to play nicer with how your using openCL
21:35:55 <byorgey> @hoogle hGetHandle
21:35:55 <lambdabot> No results found
21:36:07 <byorgey> @hoogle hSetEncoding
21:36:07 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
21:36:07 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
21:36:14 <byorgey> CaptainK: you have to import System.IO
21:36:26 <CaptainK> ok, gtk
21:38:06 <CaptainK> Now getting this on output \nmont\233\nmont\243\n
21:38:37 <CaptainK> so still missing the right set...looking
21:41:26 <byorgey> CaptainK: don't use print
21:41:52 <CaptainK> ok, putStrLn
21:41:52 <byorgey> CaptainK: the Show instance for String is going to convert strings to that sort of format using \233 and so on
21:42:05 <CaptainK> ah ya, that I did see before
21:42:16 <byorgey> putStrLn just puts the raw String on the terminal, instead of passing it through Show first
21:44:55 <CaptainK> and print passes it through show, ok that I need to know
21:45:04 <CaptainK> seems to be working now
21:46:22 <byorgey> great =)
21:46:34 <byorgey> CaptainK: yes, in fact print is defined as   print = putStrLn . show
21:46:51 <CaptainK> > :t print
21:46:52 <lambdabot>   <hint>:1:1: parse error on input `:'
21:47:43 <byorgey> :t print
21:47:43 <lambdabot> Show a => a -> IO ()
21:54:18 * dmwit waves vaguely
21:54:33 * tgeeky wonders why dmwit is doing a Nazi salute
21:55:14 <elliott> tgeeky: wtf?
21:55:19 <DigitalKiwi> godwins law
21:55:34 <DigitalKiwi> well, not quite, but close enough
21:55:38 <dmwit> tgeeky decided to skip the argument and get straight to the conclusion.
21:55:38 <tgeeky> elliott: wave ... vaguely
21:55:47 <tgeeky> it's a bit like a half-wave
21:55:58 <tgeeky> i wish I knew the name of the salute
21:56:03 <tgeeky> since it was used by many countries before Naziism
21:56:06 <johnw> a bit inappropriate, tgeeky
21:56:09 <DigitalKiwi> the hitler wave
21:56:18 <tgeeky> no, it's a standard military salute used by US soldiers too
21:56:53 <DigitalKiwi> oh so now you're comparing US military to hitler
21:56:56 <dmwit> What if we stopped discussing this now?
21:56:57 <DigitalKiwi> where does this end
21:56:58 <tgeeky> lol
21:57:01 * hackagebot git-gpush 1.3.1 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-1.3.1 (JohnWiegley)
21:57:03 <tgeeky> dmwit: I already did!
21:57:04 * hackagebot git-monitor 1.3.2 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-1.3.2 (JohnWiegley)
21:57:21 * DigitalKiwi is joking ofc, sarcasm not translating well over internet
21:58:02 <dmwit> Any cool hacks lately?
21:58:16 <DigitalKiwi> i tried to get lamdabot to talk to multibot_ but it failed
21:58:24 <DigitalKiwi> it would have been epic
21:58:48 <DigitalKiwi> and lamdabot ignores multibot_ because multibot_ puts a space before everything
21:58:59 * DigitalKiwi was much saddened
21:59:37 <dmwit> Sounds like good engineering thwarted you. =)
21:59:42 <dmwit> hooray!
21:59:44 <DigitalKiwi> :<
22:00:05 <DigitalKiwi> I did find that multibot_ lets me download from the internet
22:00:19 <dmwit> I think lambdabot can do that, too.
22:00:31 <DigitalKiwi> i couldn't get anything to execute in lamdabot
22:00:42 <DigitalKiwi> it's like "eval does nothing pervasively"
22:00:45 <dmwit> http://dmwit.com/bacteria?somereallyreallyreallyreallylongstringbecauseIcannotremembertherightlength
22:01:03 <dmwit> Hm, maybe that got removed or something.
22:01:07 <DigitalKiwi> @help eval
22:01:08 <lambdabot> eval. Do nothing (perversely)
22:01:18 <dmwit> Perhaps you want run.
22:01:20 <dmwit> ?help run
22:01:20 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
22:01:20 <DigitalKiwi> err, that word, whatever
22:01:27 <DigitalKiwi> oh
22:01:33 <DigitalKiwi> but, no IO :<
22:01:50 <dmwit> You can program pre-set answers with ?where.
22:02:02 * hackagebot gitlib 1.3.1 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-1.3.1 (JohnWiegley)
22:02:04 * hackagebot gitlib-cmdline 1.3.1 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-1.3.1 (JohnWiegley)
22:02:06 * hackagebot gitlib-cross 1.3.1 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-1.3.1 (JohnWiegley)
22:02:08 * hackagebot gitlib-libgit2 1.3.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-1.3.1 (JohnWiegley)
22:02:08 <DigitalKiwi> ?help where
22:02:08 <lambdabot> where <key>. Return element associated with key
22:02:10 * hackagebot gitlib-s3 1.3.1 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-1.3.1 (JohnWiegley)
22:02:20 <dmwit> (Am I understanding the problem statement that you wanted to set the two bots up in a loop?)
22:02:29 <DigitalKiwi> I'd never!
22:02:31 <DigitalKiwi> (yes)
22:02:33 <byorgey> woah, git galore
22:02:36 <dmwit> okay =)
22:02:41 <elliott> it is fairly easy to loop lambdabot
22:02:49 <tgeeky> byorgey: how wonderful
22:02:55 <byorgey> probably
22:03:04 <elliott> however, I could @ignore + multibot_ :)
22:03:08 <DigitalKiwi> I need to start using git more :<
22:03:36 <byorgey> :< = sad cthulhu?
22:03:39 <DigitalKiwi> I have like 7 projects atm, a few are in git, but I don't commit atm :<
22:03:42 <dmwit> byorgey: So, I don't know if you read far enough in that pairing function paper. But the main idea of the linear time function is remarkably simple.
22:03:58 <dmwit> (I read the rest of the paper a few days ago.)
22:03:59 <byorgey> dmwit: I didn't.  But I read your paste, and it was remarkably simple =)
22:04:08 <dmwit> yeah =)
22:04:22 <tgeeky> link?
22:04:48 <byorgey> the best kind of idea: simple, obvious once you've seen it, but hard to come up with in the first place.
22:05:08 <dmwit> http://paste.tryhaskell.org/90712
22:06:08 <dmwit> tgeeky: The problem statement is to give a bijection between N x N and N.
22:06:17 <dmwit> tgeeky: (In case you don't know what pairing functions are. ;-)
22:06:53 <dmwit> tgeeky: The one we all know and love where you go along diagonals requires integer multiplication, and the best known multiplication algorithms are super-linear in the number of bits.
22:07:02 <mm_freak_> > fix (2^)
22:07:06 <lambdabot>   mueval-core: Time limit exceeded
22:07:12 * hackagebot gitlib-sample 1.3.1 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-1.3.1 (JohnWiegley)
22:07:13 <shachaf> Even more linear than linear, right?
22:07:14 * hackagebot gitlib-test 1.3.1 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-1.3.1 (JohnWiegley)
22:07:25 <dmwit> Maybe super-linear isn't the right word. =)
22:07:34 <tgeeky> more than?
22:07:37 <dmwit> Anyway nobody knows if it can be done in linear time or not.
22:07:51 <dmwit> yes, it's something weird like n * log log n or something
22:08:20 <kwos> dmwit: n * log log n is de facto n for most practical purposes LOL
22:08:48 <elliott> dmwit only cares about impractical purposes.
22:08:57 <kwos> obviously :)
22:08:59 <dmwit> kwos: Sure. This algorithm has some other fun features, though.
22:09:08 <kwos> yeah, I get that
22:09:48 <dmwit> For example, it never reads more than three bits before outputting something.
22:09:52 <monochrom> wait until you see n * log n * log (log n) * log (log (log n))
22:10:12 <kwos> that's probably enough to get your PhD, no?
22:10:13 <mm_freak_> i wonder to what number 'fix (2^)' or 'fix log' converge
22:10:15 <kwos> and a job on wall st
22:10:42 <shachaf> n * inverse_ackermann(n)
22:11:46 <CaptainK> ok GHCi prints out my utf16 great, but when I try to get a length it gets upset here : http://ideone.com/OYFB7m
22:11:47 <monochrom> fix (2^) and fix log converge to ⊥.
22:11:51 <dmwit> mm_freak_: Should we expect them to converge?
22:12:17 <shachaf> I would say that they are ⊥.
22:12:17 <joelteon> :t log
22:12:18 <lambdabot> Floating a => a -> a
22:12:23 <joelteon> > log 0.2
22:12:24 <lambdabot>   -1.6094379124341003
22:12:27 <joelteon> > log -1.6
22:12:28 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
22:12:28 <lambdabot>    arising from a use ...
22:12:30 <mauke> CaptainK: x is characters, not words
22:12:32 <joelteon> huh
22:12:34 <joelteon> > fix log 10
22:12:35 <lambdabot>   Could not deduce (GHC.Float.Floating
22:12:35 <lambdabot>                      (GHC.Integer.Type...
22:12:38 <mm_freak_> the former is definitely bottom, because (^) is strict in its second argument
22:12:42 <dmwit> > log (-1.6)
22:12:42 <mm_freak_> the latter…  well, depends
22:12:43 <lambdabot>   NaN
22:12:48 <mm_freak_> it doesn't have to be bottom
22:13:00 <elliott> I rather suspect log is strict.
22:13:06 <dmwit> joelteon: log -1.6 is (-) log 1.6
22:13:16 <mm_freak_> elliott: log can be calculated lazily as far as i know
22:13:18 <joelteon> > log NaN
22:13:18 <elliott> its codomain is discrete (is that the word?) and it is not the constant function.
22:13:19 <lambdabot>   Not in scope: data constructor `NaN'
22:13:22 <mm_freak_> at least for real numbers
22:13:26 <joelteon> > log (log (-1.6))
22:13:27 <lambdabot>   NaN
22:13:34 <joelteon> so it converges to NaN
22:13:53 <mauke> > iterate log 1
22:13:55 <lambdabot>   [1.0,0.0,-Infinity,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,...
22:14:03 <dmwit> BATMAN!
22:14:03 <mm_freak_> joelteon: the conclusion would be correct, but the premise is wrong
22:14:07 <mm_freak_> you don't have a starting value
22:14:25 <joelteon> any number?
22:14:27 <mm_freak_> > log (1/0)
22:14:28 <lambdabot>   Infinity
22:14:31 <monochrom> I agree about batman :)
22:14:40 <mm_freak_> so it could go to infinity just as well
22:14:44 <joelteon> > log (log (1/0))
22:14:45 <lambdabot>   Infinity
22:14:48 <arkeet> but log x < x for any positive real x
22:14:51 <mauke> > log undefined
22:14:52 <lambdabot>   *Exception: Prelude.undefined
22:14:57 <arkeet> log x <= x - 1, even.
22:15:00 <mauke> it could go to undefined
22:15:40 <joelteon> well that doesn't really count
22:16:16 <CaptainK> mauke: but when I take out the "length part it works so this: let wordsfive = [x| x <- contents, length x == 5]
22:16:36 <CaptainK> becomes this: let wordsfive = [x| x <- contents] and I get a printing of words not characters
22:16:44 <mauke> CaptainK: no, you don't
22:16:57 <CaptainK> its zipping them up?
22:16:59 <mauke> no
22:17:06 <mauke> [x| x <- contents] is equivalent to contents
22:17:13 <mauke> you're simply printing the whole string
22:17:43 <CaptainK> so I can't do a length on it?
22:17:56 <mauke> you can do a length on strings
22:18:04 <mauke> 'length contents' is fine
22:18:24 <dmwit> CaptainK: A word on getting help from mauke: before each question you ask, you should stop and think about exactly what it is you want to ask.
22:18:42 <mauke> doesn't exactly require thought
22:18:44 <dmwit> CaptainK: Because mauke will answer exactly the question you ask and nothing more, and leave you to draw your own conclusions. =)
22:18:49 <mauke> you could also ask "what should I be asking?"
22:19:06 <dmwit> I like that question. =)
22:19:19 <CaptainK> ya because the logic works fine on other text files...just this utf16 encoding is failing
22:19:24 <monochrom> same for getting help from me.
22:19:39 <mauke> same for programming computers
22:19:59 <dmwit> I don't believe the encoding has anything to do with the problem you're having.
22:20:04 <tgeeky> Before you address me, ask yourself "Have this really gotten this desperate?"
22:20:08 <monochrom> I love computers for exactly this. but I digress.
22:20:39 <CaptainK> ok, but why does it fail with the utf16 file and utf8 works perfectly
22:20:44 <mauke> CaptainK: no
22:20:55 <elliott> mauke: what should I be asking?
22:21:06 <mauke> elliott: I don't know. what are you trying to achieve?
22:21:19 <elliott> mauke: trying to ask you a good question
22:21:27 <shachaf> The correct question to ask mauke is "what should I be asking?".
22:21:34 <shachaf> Therefore he'll tell you that you should be asking exactly that.
22:21:43 <CaptainK> How would you get a length of this string? let wordsfive = [x| x <- contents, length x == 5]
22:21:53 <mauke> CaptainK: that's not a string, that's a type error
22:21:54 <tgeeky> CaptainK: you wouldn't use list comprehensions to do it
22:22:09 <mauke> tgeeky: I would
22:22:12 <CaptainK> but I want list comprehnsion
22:22:25 <mauke> elliott: then you're done
22:22:43 <CaptainK> it works fine with utf8
22:22:54 <mauke> CaptainK: no, it doesn't
22:23:19 <CaptainK> ok, so I'm just imaging the words streaming across with only 5 characters in length
22:23:32 <elliott> mauke: I'm enlightened
22:23:35 <dmwit> CaptainK: You are not operating on words.
22:23:39 <mauke> CaptainK: yes
22:23:47 <CaptainK> what am I operating on?
22:23:51 <dmwit> Characters.
22:23:51 <mauke> characters
22:24:02 <CaptainK> then why do they come out words?
22:24:06 <mauke> they don't
22:24:24 <mauke> I don't know what you're running but it's not the code you posted
22:24:27 <CaptainK> they come out in strings of characters yes that is obvious
22:24:29 <shachaf> words of a curious character
22:24:30 <arkeet> what is contents?
22:24:47 <mauke> arkeet: contents <- hGetContents ...
22:25:02 <arkeet> then yeah, type error.
22:25:36 <dmwit> CaptainK: Perhaps you would like the "words" function.
22:25:37 <dmwit> :t words
22:25:38 <lambdabot> String -> [String]
22:27:38 <CaptainK> thats in Prelude? so unless intentional, you should not use variables with the name "words"?
22:28:02 <mauke> you should never use variables unintentionally
22:28:07 <dmwit> mauke++
22:28:12 <tgeeky> mauke++
22:28:14 <dmwit> Just the answer I was about to type.
22:28:16 <tgeeky> that's worth two.
22:28:42 <elliott> mauke: you can run the same code but interpret the results differently (or wrongly). I think that's more likely than running different code here, though admittedly I only skimmed context.
22:28:57 <mauke> elliott: you can't run code with type errors
22:28:58 <tgeeky> CaptainK: you will want to hide words if you want to use words.
22:29:13 <elliott> mauke: that does change things, admittedly
22:29:20 <CaptainK> ok, thats good to know
22:29:26 <mauke> the essence of static typing :-)
22:29:43 <CaptainK> what other functions are named with all small letters?
22:29:55 <tgeeky> CaptainK: Start ghci and hit tab.
22:30:12 <arkeet> most functions are named with all small letters.
22:31:13 <dmwit> "all small letters" is a strange criterion. Why are those names special?
22:31:20 <CaptainK> I thought they had a capital letter somewhere to distinguish them
22:31:50 <arkeet> no
22:31:51 <tgeeky> CaptainK: you should read the specification or the Haskell report
22:31:53 <tgeeky> to learn about these things
22:31:54 <tgeeky> and not guess
22:31:58 <shachaf> Hmm, constructors should require a capital letter anywhere, rather than just the beginning of the word.
22:32:08 <shachaf> That would be a good rule.
22:32:11 <arkeet> but what would we do about camelCase?
22:32:17 <shachaf> We wouldn't use it.
22:32:25 <arkeet> what would we use?
22:32:28 <shachaf> (Except perhaps in constructors.)
22:32:30 <CaptainK> yes, you can keep reading , but at sometime you need to dive in
22:33:06 <startling> does anyone have a thing for pipes to turn two clients into one?
22:33:09 <shachaf> You could read the whole report before diving in, if you wanted to.
22:33:32 <tgeeky> certainly the sections that explain in exactly which circumstances lowercase and uppercase is significant
22:33:44 <startling> shachaf: what would that give you?
22:33:49 <dmwit> (...but your friends don't read the Report, and if they don't read the Report, they're no friends of mine...)
22:33:50 <mauke> CaptainK: abs, acos, acosh, all, and, any, asin, asinh, atan, atanh, break, ceiling, compare, concat, const, cos, cosh, curry, cycle, div, drop, either, elem, error, even, exp, exponent, fail, filter, flip, floor, fmap, foldl, foldr, fst, gcd, head, id, init, interact, iterate, last, lcm, length, lines, log, lookup, map, max, maximum, maybe, min, mod, negate, not, null, odd, or, pi, pred, print, product, quot, read, reads, recip, rem, repeat,
22:33:54 <CaptainK> tgeeky: I'll look at it now that I need to know
22:33:56 <mauke>  replicate, return, reverse, round, scanl, scanr, seq, sequence, show, shows, significand, signum, sin, sinh, snd, span, sqrt, subtract, succ, sum, tail, take, tan, tanh, truncate, uncurry, undefined, unlines, until, unwords, unzip, words, zip
22:33:58 <CaptainK> ah thats cool
22:34:08 <dmwit> I knew mauke would deliver.
22:34:15 <tgeeky> hehe
22:34:47 <mauke> which identifier is not on the list?
22:35:05 <dmwit> identifier, singular?
22:35:13 <mauke> yes
22:35:13 <monochrom> I dived and read concurrently. why do one when you can do both. you have two eyes and two hands.
22:35:16 <dmwit> zipWith?
22:35:20 <mauke> dmwit: contains W
22:35:22 <arkeet> mauke: you could have just told him about :browse
22:35:35 <mauke> arkeet: I don't know about :browse
22:35:38 <arkeet> now you do!
22:35:40 <dmwit> Also, all constructors ever. [], :, True, False, Nothing, Just, ...
22:35:46 <CaptainK> lol :browse
22:35:48 <mauke> dmwit: those contain non-lowercase characters
22:36:08 <dmwit> Oh, I understand your question now.
22:36:31 <dmwit> I can't say I'm terribly interested in answering it, though. =P
22:36:48 <tgeeky> where ?
22:36:57 <dmwit> that's a keyword, not an identifier
22:37:26 <shachaf> mauke: Hmm, I have some more in Prelude.
22:37:29 <shachaf> Like Prelude.lex
22:37:33 <shachaf> (I never knew that existed...)
22:37:43 <dmwit> Everybody forgets about lex.
22:38:11 <mauke> shachaf++  # nice, you found a genuine mistake
22:38:42 <startling> dmwit, that's how he likes it.
22:38:50 <mauke> but the one I skipped on purpose was 'otherwise'
22:38:57 <startling> dmwit: then he runs for president or some shit and everyone forgets he's a supervillain.
22:39:24 <mauke> .oO( just like mitt )
22:39:41 <shachaf> otherwise isn't a function.
22:40:07 <mauke> shachaf: I like the way you think
22:40:30 <halfie> is anybody actively working on http://ghc.haskell.org/trac/ghc/ticket/703 ?
22:41:43 <shachaf> mauke: Also minimum.
22:42:13 <mauke> :-(
22:42:21 <mauke> my emperor
22:42:39 * shachaf wonders whether mauke typed that in by hand from memory or something.
22:44:03 <mauke> I hit tab in ghci and retyped the results
22:48:12 <startling> who knows about pipes here? I have a pretty involved question that I don't want to type out if everyone is just going to ignore me (again).
22:50:47 <arkeet> startling: make a paste out of it and link it when convenient.
22:50:48 <shachaf> I am an expert in canals, sewers, and capillary tubing.
22:50:59 <elliott> that's not a very inviting way to solicit answerers.
22:50:59 <shachaf> I also know a bit about cigars.
22:51:22 <shachaf> Indeed it isn't.
22:51:31 <nullFxn> Wow, there's a lot of M'F'ing people on the Haskell channell...coollll...
22:51:38 <Cale> startling: I don't really know much, and generally try to avoid iteratee libraries, but who knows, I might be able to help?
22:51:46 <startling> shachaf: ceci n'est pas une pipe
22:52:11 <dmwit> ?where justask applies to regulars, too ;-)
22:52:11 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
22:52:13 <shachaf> But if you volunteer to help, you encourage people to ask for volunteers. :-(
22:52:17 <mauke> je ne parle pas francais
22:52:29 <elliott> you can put it on SO if you don't want it to be "wasted" if there's nobody around.
22:52:36 <elliott> and linking SO questions in here to solicit answers is OK.
22:52:37 <arkeet> that's a good idea.
22:52:47 <arkeet> I keep forgetting about these websites.
22:53:01 <elliott> as a bonus, if someone answers it on IRC you can answer it yourself and get the sweet rep for it.
22:54:00 <shachaf> Maybe I should become one of those people who ask-and-answer questions on SO.
22:54:08 <arkeet> maybe I should use SO.
22:54:18 <startling> alright, so I'd like to have zip two clients together to create a third client which requests their common type, feeds it to both of them, and sends a tuple of both responses back upstream.
22:54:38 <shachaf> People gave you good advice on asking this sort of question and you're ignoring it. :-(
22:55:12 <startling> shachaf, I don't have a SO account; I was going to try it after this if this didn't work.
22:55:34 <shachaf> I don't think you need an account to ask.
22:56:01 <shachaf> But anyway the other advice was making an hpaste with your question, so that you can link to it easily at some later point.
22:56:16 <arkeet> shachaf: you don't?
22:56:25 <arkeet> you shouldn't need any rep to ask, though
22:56:38 <arkeet> I think the SO method is better.
22:56:41 <shachaf> arkeet: Oh, I'm wrong.
22:56:47 <arkeet> it would probably get more attention.
22:57:00 <arkeet> and when tekmo is around you can poke him with it.
22:57:06 * shachaf notes that Tekmo reads SO and not usually IRC.
22:57:12 <arkeet> even that.
22:59:24 <startling> shachaf: so you're saying it's wholly inappropriate for me to continue asking here?
22:59:56 <elliott> I think shachaf was expressing dismay, not disallowance.
23:00:04 <startling> OK.
23:00:05 <shachaf> Yes.
23:00:18 <shachaf> You can ask. I just doubt you'll get good answers, and I think at least typing the question up in a paste would be more useful for you.
23:02:13 <dmwit> FWIW, what I've seen of the question so far is 100% appropriate here.
23:04:33 <shachaf> Yes. It isn't inappropriate, and if you'd just asked it it would've been fine with me.
23:04:35 <byorgey> the only part that wasn't appropriate was the "(again)" bit.
23:05:31 <byorgey> well, maybe not inappropriate, but it immediately puts everyone on the defensive, so not very useful for getting answers.
23:08:54 <Cale> startling: What type are clients?
23:13:33 <Cale> startling: Or: what would the type of the operation you want be?
23:19:44 <CaptainK> ok, how do you map this : mywords <- hGetContents h So instead of getting a bunch of characters, you get words from characters after hitting \n ?
23:20:52 <Cale> CaptainK: You could write  mywords <- fmap words (hGetContents h)
23:21:37 <Cale> CaptainK: You could also use 'let'
23:21:54 <Cale> do xs <- hGetContents h
23:22:00 <Cale>    let ws = words xs
23:22:05 <Cale>    ... other stuff ...
23:22:33 <CaptainK> Turn this: "hello\nworld\n" into ["hello","world] ?
23:22:43 <joelteon> lines
23:22:53 <Cale> words will also do that...
23:23:00 <Cale> But you might be looking for lines
23:23:09 <Cale> > words "hello\nworld\n"
23:23:10 <lambdabot>   ["hello","world"]
23:23:15 <Cale> > words "hello there\nworld\n"
23:23:17 <lambdabot>   ["hello","there","world"]
23:23:20 <Cale> > lines "hello there\nworld\n"
23:23:21 <lambdabot>   ["hello there","world"]
23:31:55 <Ghoul_> is there a good way to view .lhs files online
23:32:01 <Ghoul_> as you write them?
23:32:15 <mauke> yeah, a text editor
23:32:24 <CaptainK> online
23:32:33 <Ghoul_> Well, yes, but I want to view the "pretty" version
23:32:39 <mauke> define "pretty"
23:32:45 <CaptainK> ide
23:32:47 <Ghoul_> post-latex
23:32:52 <mauke> wait, what latex?
23:32:53 <CaptainK> emacs
23:33:04 <byorgey> Ghoul_: perhaps you want lhs2tex?
23:33:34 <Ghoul_> hmm, yes.
23:33:34 <mauke> ah, I only use the plain text form
23:33:59 <shachaf> Perhaps you want while true; do ... in.hs out.whatever; inotifywait -e modify in.hs; done
23:34:21 <shachaf> And then something similar in whatever program you use to view the file.
23:34:44 <Ghoul_> Well, online is the go because I'm back on Windows.
23:34:55 <shachaf> I don't know what "online" means.
23:35:00 <shachaf> Via a web browser?
23:35:21 <Ghoul_> yeah
23:35:40 <Ghoul_> (And with recent discovery, gist does a good job of viewing them)
23:37:06 <fragamus> is there an up-to-date version (using commonly used libraries) of http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
23:37:24 <byorgey> I doubt it
23:37:50 <shachaf> http://hackage.haskell.org/package/comonad would be the place to get Comonad from.
23:38:07 <shachaf> Oh, that page defines its own Comonad.
23:38:22 <shachaf> Which library is missing?
23:40:33 <fragamus> nothing is missing but I knew that it used an outdated comonad
23:43:56 <CaptainK> how do you map "hello\nworld\n" to ["hello","world"]?
23:44:25 <dmwit> CaptainK: We've answered that question several times now.
23:44:34 <dmwit> Can you say what it is about the answers that you didn't like?
23:45:04 <CaptainK> didn't see the answer to that question, can you show me where it is?
23:45:20 <johnw> 01:22 <Cale> > lines "hello there\nworld\n"
23:45:23 <mauke> CaptainK: 22 minutes ago
23:45:23 <shachaf> CaptainK: There are logs in the topic.
23:45:38 <dmwit> 01:25 < dmwit> CaptainK: Perhaps you would like the "words" function.
23:45:39 <CaptainK> musta mist that...thanks
23:45:59 <dmwit> 02:20 < Cale> CaptainK: You could write  mywords <- fmap words (hGetContents h)
23:46:05 <Cale> CaptainK: Do you want words, or lines?
23:46:18 <mauke> > map init . chunksOf 6 $"hello\nworld\n"
23:46:19 <lambdabot>   ["hello","world"]
23:46:33 <johnw> I'm imagine that at some point, I'll be able to answer anyone's question by just quoting Cale
23:47:09 <dmwit> I bet Cale has used each letter, number, and punctuation at least once by now. =)
23:47:16 <johnw> haha
23:47:18 <CaptainK> ok thanks so much, yep thats what I needed
23:47:25 <johnw> I mean by copying whole lines!
23:48:25 <mauke> but do you mean lines or words?
23:48:54 <johnw> ask me again in 22 mins
23:48:58 <dmwit> (Also, I find "I musta mist that" quite surprising given that you responded to my suggestion with a followup question about lower-case identifiers.)
23:50:41 <CaptainK> yes yes, its two in the morning and my chair is on a tilt
